// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18477 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83594 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20657 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42374 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42374 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42374 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42819 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42711 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42711 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49185 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49185 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49185 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 08_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 08_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49185 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49185 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 08_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 08_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49185 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49185 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49185 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49185 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49185 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49185 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49185 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49185 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49185 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49185 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57867 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57867 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57867 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57867 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57867 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 54046 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 54046 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54168 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43107 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42711 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55432 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42711 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 54046 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54168 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42944 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54168 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54168 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42944 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54168 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42944 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 54046 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54168 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54168 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54168 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42944 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 54046 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54168 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 54046 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54168 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42944 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 5 5$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54168 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42711 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42711 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88300 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 34
7534: PUSH
7535: LD_INT 32
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 34
7544: PUSH
7545: LD_INT 88
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 72
7561: PUSH
7562: LD_INT 4
7564: GREATEREQUAL
7565: PUSH
7566: LD_VAR 0 7
7570: PUSH
7571: LD_INT 0
7573: LESSEQUAL
7574: OR
7575: IFFALSE 7498
// wait ( 0 0$10 ) ;
7577: LD_INT 350
7579: PPUSH
7580: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7584: LD_ADDR_VAR 0 2
7588: PUSH
7589: LD_EXP 69
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 32
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 88
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 72
7630: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_EXP 69
7640: PUSH
7641: LD_INT 2
7643: ARRAY
7644: PPUSH
7645: LD_INT 3
7647: PUSH
7648: LD_INT 34
7650: PUSH
7651: LD_INT 32
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 88
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 72
7677: ST_TO_ADDR
// if tmp2 then
7678: LD_VAR 0 3
7682: IFFALSE 7700
// tmp := tmp union tmp2 ;
7684: LD_ADDR_VAR 0 2
7688: PUSH
7689: LD_VAR 0 2
7693: PUSH
7694: LD_VAR 0 3
7698: UNION
7699: ST_TO_ADDR
// if not tmp then
7700: LD_VAR 0 2
7704: NOT
7705: IFFALSE 7709
// exit ;
7707: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7709: LD_VAR 0 3
7713: PPUSH
7714: CALL 51308 0 1
7718: PUSH
7719: LD_INT 50
7721: PPUSH
7722: CALL_OW 13
7726: OR
7727: IFFALSE 7760
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7729: LD_ADDR_VAR 0 4
7733: PUSH
7734: LD_INT 48
7736: PUSH
7737: LD_INT 33
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 71
7746: PUSH
7747: LD_INT 88
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: ST_TO_ADDR
7758: GO 7789
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 128
7767: PUSH
7768: LD_INT 94
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 180
7777: PUSH
7778: LD_INT 135
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: ST_TO_ADDR
// if w = 3 then
7789: LD_VAR 0 5
7793: PUSH
7794: LD_INT 3
7796: EQUAL
7797: IFFALSE 7828
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_INT 91
7806: PUSH
7807: LD_INT 58
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 117
7816: PUSH
7817: LD_INT 107
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7828: LD_INT 28
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 70
7845: IFFALSE 7865
// coords := [ [ 163 , 41 ] ] ;
7847: LD_ADDR_VAR 0 4
7851: PUSH
7852: LD_INT 163
7854: PUSH
7855: LD_INT 41
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7865: LD_VAR 0 2
7869: PPUSH
7870: LD_VAR 0 4
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PPUSH
7879: LD_VAR 0 4
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: CALL_OW 114
// p := 30 ;
7892: LD_ADDR_VAR 0 7
7896: PUSH
7897: LD_INT 30
7899: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7900: LD_INT 35
7902: PPUSH
7903: CALL_OW 67
// p := Dec ( p ) ;
7907: LD_ADDR_VAR 0 7
7911: PUSH
7912: LD_VAR 0 7
7916: PPUSH
7917: CALL 88300 0 1
7921: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 60
7929: PUSH
7930: EMPTY
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: PUSH
7938: LD_INT 0
7940: EQUAL
7941: PUSH
7942: LD_VAR 0 7
7946: PUSH
7947: LD_INT 0
7949: LESSEQUAL
7950: OR
7951: IFFALSE 7900
// repeat wait ( 0 0$2 ) ;
7953: LD_INT 70
7955: PPUSH
7956: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7960: LD_ADDR_VAR 0 2
7964: PUSH
7965: LD_VAR 0 2
7969: PPUSH
7970: LD_INT 50
7972: PUSH
7973: EMPTY
7974: LIST
7975: PPUSH
7976: CALL_OW 72
7980: ST_TO_ADDR
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82511 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7953
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 54046 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 54046 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54168 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87315 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 17027 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16849 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 17027 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 17027 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16849 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 17027 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 17027 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17253 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17253 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16849 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 17027 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 17027 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16849 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 17027 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 17027 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16849 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 17027 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 17027 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 17027 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 17027 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 17027 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55432 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15865 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
15844: LD_OWVAR 57
15848: IFFALSE 15862
// begin end_the_mission_allowed := false ;
15850: LD_ADDR_OWVAR 57
15854: PUSH
15855: LD_INT 0
15857: ST_TO_ADDR
// EndMission ;
15858: CALL 15865 0 0
// end ; end ;
15862: PPOPN 1
15864: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15865: LD_INT 0
15867: PPUSH
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
// m1 := false ;
15872: LD_ADDR_VAR 0 3
15876: PUSH
15877: LD_INT 0
15879: ST_TO_ADDR
// m2 := false ;
15880: LD_ADDR_VAR 0 4
15884: PUSH
15885: LD_INT 0
15887: ST_TO_ADDR
// m3 := false ;
15888: LD_ADDR_VAR 0 5
15892: PUSH
15893: LD_INT 0
15895: ST_TO_ADDR
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 9 then
15896: LD_INT 22
15898: PUSH
15899: LD_INT 1
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: LD_INT 21
15908: PUSH
15909: LD_INT 1
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: LD_INT 23
15918: PUSH
15919: LD_INT 1
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 50
15928: PUSH
15929: EMPTY
15930: LIST
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: LIST
15936: LIST
15937: PPUSH
15938: CALL_OW 69
15942: PPUSH
15943: CALL 51308 0 1
15947: PUSH
15948: LD_INT 9
15950: LESS
15951: IFFALSE 15962
// begin YouLost ( LostVictory ) ;
15953: LD_STRING LostVictory
15955: PPUSH
15956: CALL_OW 104
// exit ;
15960: GO 16844
// end ; if not am_veh_consturcted then
15962: LD_EXP 20
15966: NOT
15967: IFFALSE 15976
// SetAchievement ( ACH_ARABTECH ) ;
15969: LD_STRING ACH_ARABTECH
15971: PPUSH
15972: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15976: LD_OWVAR 1
15980: PUSH
15981: LD_INT 252000
15983: PUSH
15984: LD_INT 210000
15986: PUSH
15987: LD_INT 199500
15989: PUSH
15990: LD_INT 193200
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: PUSH
15999: LD_OWVAR 67
16003: ARRAY
16004: LESS
16005: IFFALSE 16027
// begin m3 := true ;
16007: LD_ADDR_VAR 0 5
16011: PUSH
16012: LD_INT 1
16014: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
16015: LD_STRING Time1
16017: PPUSH
16018: LD_INT 1
16020: PPUSH
16021: CALL_OW 101
// end else
16025: GO 16058
// if not powell_warn then
16027: LD_EXP 16
16031: NOT
16032: IFFALSE 16047
// AddMedal ( Time1 , - 1 ) else
16034: LD_STRING Time1
16036: PPUSH
16037: LD_INT 1
16039: NEG
16040: PPUSH
16041: CALL_OW 101
16045: GO 16058
// AddMedal ( Time1 , - 2 ) ;
16047: LD_STRING Time1
16049: PPUSH
16050: LD_INT 2
16052: NEG
16053: PPUSH
16054: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
16058: LD_EXP 17
16062: PUSH
16063: LD_INT 5
16065: PUSH
16066: LD_INT 4
16068: PUSH
16069: LD_INT 3
16071: PUSH
16072: LD_INT 3
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: PUSH
16081: LD_OWVAR 67
16085: ARRAY
16086: GREATEREQUAL
16087: IFFALSE 16102
// AddMedal ( Destroy , - 2 ) else
16089: LD_STRING Destroy
16091: PPUSH
16092: LD_INT 2
16094: NEG
16095: PPUSH
16096: CALL_OW 101
16100: GO 16235
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16102: LD_INT 22
16104: PUSH
16105: LD_INT 2
16107: PUSH
16108: EMPTY
16109: LIST
16110: LIST
16111: PUSH
16112: LD_INT 21
16114: PUSH
16115: LD_INT 3
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 50
16124: PUSH
16125: EMPTY
16126: LIST
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: LIST
16132: PPUSH
16133: CALL_OW 69
16137: PUSH
16138: LD_INT 25
16140: GREATEREQUAL
16141: IFFALSE 16156
// AddMedal ( Destroy , - 1 ) else
16143: LD_STRING Destroy
16145: PPUSH
16146: LD_INT 1
16148: NEG
16149: PPUSH
16150: CALL_OW 101
16154: GO 16235
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16156: LD_INT 22
16158: PUSH
16159: LD_INT 2
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 21
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 50
16178: PUSH
16179: EMPTY
16180: LIST
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: PPUSH
16187: CALL_OW 69
16191: PUSH
16192: LD_INT 15
16194: GREATEREQUAL
16195: IFFALSE 16217
// begin m1 := true ;
16197: LD_ADDR_VAR 0 3
16201: PUSH
16202: LD_INT 1
16204: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16205: LD_STRING Destroy
16207: PPUSH
16208: LD_INT 1
16210: PPUSH
16211: CALL_OW 101
// end else
16215: GO 16235
// begin m1 := true ;
16217: LD_ADDR_VAR 0 3
16221: PUSH
16222: LD_INT 1
16224: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16225: LD_STRING Destroy
16227: PPUSH
16228: LD_INT 2
16230: PPUSH
16231: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16235: LD_EXP 13
16239: PPUSH
16240: LD_STRING 11_artifact_captured
16242: PPUSH
16243: CALL_OW 39
// if artifact_get then
16247: LD_EXP 13
16251: IFFALSE 16273
// begin m2 := true ;
16253: LD_ADDR_VAR 0 4
16257: PUSH
16258: LD_INT 1
16260: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16261: LD_STRING Artefact
16263: PPUSH
16264: LD_INT 1
16266: PPUSH
16267: CALL_OW 101
// end else
16271: GO 16284
// AddMedal ( Artefact , - 1 ) ;
16273: LD_STRING Artefact
16275: PPUSH
16276: LD_INT 1
16278: NEG
16279: PPUSH
16280: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16284: LD_VAR 0 3
16288: PUSH
16289: LD_VAR 0 4
16293: AND
16294: PUSH
16295: LD_VAR 0 5
16299: AND
16300: PUSH
16301: LD_OWVAR 67
16305: PUSH
16306: LD_INT 3
16308: GREATEREQUAL
16309: AND
16310: IFFALSE 16322
// SetAchievementEX ( ACH_AMER , 11 ) ;
16312: LD_STRING ACH_AMER
16314: PPUSH
16315: LD_INT 11
16317: PPUSH
16318: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16322: LD_VAR 0 3
16326: PUSH
16327: LD_VAR 0 4
16331: AND
16332: PUSH
16333: LD_VAR 0 5
16337: AND
16338: PUSH
16339: LD_EXP 17
16343: PUSH
16344: LD_INT 0
16346: EQUAL
16347: AND
16348: IFFALSE 16364
// begin wait ( 3 ) ;
16350: LD_INT 3
16352: PPUSH
16353: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16357: LD_STRING ACH_GENERAL
16359: PPUSH
16360: CALL_OW 543
// end ; if tick <= 100 100$00 then
16364: LD_OWVAR 1
16368: PUSH
16369: LD_INT 210000
16371: LESSEQUAL
16372: IFFALSE 16388
// begin wait ( 3 ) ;
16374: LD_INT 3
16376: PPUSH
16377: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16381: LD_STRING ACH_ASPEED_11
16383: PPUSH
16384: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16388: LD_STRING MAIN
16390: PPUSH
16391: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16395: LD_ADDR_EXP 19
16399: PUSH
16400: LD_EXP 19
16404: PPUSH
16405: LD_INT 51
16407: PUSH
16408: EMPTY
16409: LIST
16410: PPUSH
16411: CALL_OW 72
16415: ST_TO_ADDR
// tmp := JMM ^ selected ;
16416: LD_ADDR_VAR 0 2
16420: PUSH
16421: LD_EXP 21
16425: PUSH
16426: LD_EXP 19
16430: ADD
16431: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16432: LD_VAR 0 2
16436: PPUSH
16437: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16441: LD_VAR 0 2
16445: PUSH
16446: LD_EXP 21
16450: PUSH
16451: LD_EXP 22
16455: PUSH
16456: LD_EXP 23
16460: PUSH
16461: LD_EXP 24
16465: PUSH
16466: LD_EXP 25
16470: PUSH
16471: LD_EXP 26
16475: PUSH
16476: LD_EXP 27
16480: PUSH
16481: LD_EXP 28
16485: PUSH
16486: LD_EXP 29
16490: PUSH
16491: LD_EXP 31
16495: PUSH
16496: LD_EXP 32
16500: PUSH
16501: LD_EXP 33
16505: PUSH
16506: LD_EXP 34
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: LIST
16515: LIST
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: DIFF
16526: PPUSH
16527: LD_STRING 11c_others
16529: PPUSH
16530: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16534: LD_EXP 21
16538: PPUSH
16539: LD_EXP 3
16543: PUSH
16544: LD_STRING JMM
16546: STR
16547: PPUSH
16548: CALL_OW 38
// if Lisa then
16552: LD_EXP 22
16556: IFFALSE 16576
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16558: LD_EXP 22
16562: PPUSH
16563: LD_EXP 3
16567: PUSH
16568: LD_STRING Lisa
16570: STR
16571: PPUSH
16572: CALL_OW 38
// if Donaldson then
16576: LD_EXP 23
16580: IFFALSE 16600
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16582: LD_EXP 23
16586: PPUSH
16587: LD_EXP 3
16591: PUSH
16592: LD_STRING Donaldson
16594: STR
16595: PPUSH
16596: CALL_OW 38
// if Bobby then
16600: LD_EXP 24
16604: IFFALSE 16624
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16606: LD_EXP 24
16610: PPUSH
16611: LD_EXP 3
16615: PUSH
16616: LD_STRING Bobby
16618: STR
16619: PPUSH
16620: CALL_OW 38
// if Cyrus then
16624: LD_EXP 25
16628: IFFALSE 16648
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16630: LD_EXP 25
16634: PPUSH
16635: LD_EXP 3
16639: PUSH
16640: LD_STRING Cyrus
16642: STR
16643: PPUSH
16644: CALL_OW 38
// if Denis then
16648: LD_EXP 26
16652: IFFALSE 16672
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16654: LD_EXP 26
16658: PPUSH
16659: LD_EXP 3
16663: PUSH
16664: LD_STRING Denis
16666: STR
16667: PPUSH
16668: CALL_OW 38
// if Brown then
16672: LD_EXP 27
16676: IFFALSE 16696
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16678: LD_EXP 27
16682: PPUSH
16683: LD_EXP 3
16687: PUSH
16688: LD_STRING Brown
16690: STR
16691: PPUSH
16692: CALL_OW 38
// if Gladstone then
16696: LD_EXP 28
16700: IFFALSE 16720
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16702: LD_EXP 28
16706: PPUSH
16707: LD_EXP 3
16711: PUSH
16712: LD_STRING Gladstone
16714: STR
16715: PPUSH
16716: CALL_OW 38
// if Houten then
16720: LD_EXP 29
16724: IFFALSE 16744
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16726: LD_EXP 29
16730: PPUSH
16731: LD_EXP 3
16735: PUSH
16736: LD_STRING Houten
16738: STR
16739: PPUSH
16740: CALL_OW 38
// if Cornel then
16744: LD_EXP 31
16748: IFFALSE 16768
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16750: LD_EXP 31
16754: PPUSH
16755: LD_EXP 3
16759: PUSH
16760: LD_STRING Cornell
16762: STR
16763: PPUSH
16764: CALL_OW 38
// if Gary then
16768: LD_EXP 32
16772: IFFALSE 16792
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16774: LD_EXP 32
16778: PPUSH
16779: LD_EXP 3
16783: PUSH
16784: LD_STRING Gary
16786: STR
16787: PPUSH
16788: CALL_OW 38
// if Frank then
16792: LD_EXP 33
16796: IFFALSE 16816
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16798: LD_EXP 33
16802: PPUSH
16803: LD_EXP 3
16807: PUSH
16808: LD_STRING Frank
16810: STR
16811: PPUSH
16812: CALL_OW 38
// if Kikuchi then
16816: LD_EXP 34
16820: IFFALSE 16840
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16822: LD_EXP 34
16826: PPUSH
16827: LD_EXP 3
16831: PUSH
16832: LD_STRING Kikuchi
16834: STR
16835: PPUSH
16836: CALL_OW 38
// YouWin ;
16840: CALL_OW 103
// end ;
16844: LD_VAR 0 1
16848: RET
// export function CanSayRand ( side ) ; begin
16849: LD_INT 0
16851: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16852: LD_ADDR_VAR 0 2
16856: PUSH
16857: LD_INT 52
16859: PUSH
16860: EMPTY
16861: LIST
16862: PUSH
16863: LD_INT 22
16865: PUSH
16866: LD_VAR 0 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 2
16877: PUSH
16878: LD_INT 25
16880: PUSH
16881: LD_INT 1
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: LD_INT 25
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: PUSH
16898: LD_INT 25
16900: PUSH
16901: LD_INT 3
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 25
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: LIST
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 69
16934: PUSH
16935: LD_EXP 21
16939: PUSH
16940: LD_EXP 33
16944: PUSH
16945: LD_EXP 22
16949: PUSH
16950: LD_EXP 23
16954: PUSH
16955: LD_EXP 24
16959: PUSH
16960: LD_EXP 25
16964: PUSH
16965: LD_EXP 26
16969: PUSH
16970: LD_EXP 27
16974: PUSH
16975: LD_EXP 28
16979: PUSH
16980: LD_EXP 29
16984: PUSH
16985: LD_EXP 30
16989: PUSH
16990: LD_EXP 31
16994: PUSH
16995: LD_EXP 32
16999: PUSH
17000: LD_EXP 34
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: LIST
17020: DIFF
17021: ST_TO_ADDR
// end ;
17022: LD_VAR 0 2
17026: RET
// export function SayRand ( sex , dial ) ; begin
17027: LD_INT 0
17029: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
17030: LD_ADDR_VAR 0 3
17034: PUSH
17035: LD_INT 52
17037: PUSH
17038: EMPTY
17039: LIST
17040: PUSH
17041: LD_INT 22
17043: PUSH
17044: LD_INT 1
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 26
17053: PUSH
17054: LD_VAR 0 1
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: LD_INT 2
17065: PUSH
17066: LD_INT 25
17068: PUSH
17069: LD_INT 1
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 25
17078: PUSH
17079: LD_INT 2
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: LD_INT 25
17088: PUSH
17089: LD_INT 3
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 25
17098: PUSH
17099: LD_INT 4
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: PPUSH
17119: CALL_OW 69
17123: PUSH
17124: LD_EXP 21
17128: PUSH
17129: LD_EXP 33
17133: PUSH
17134: LD_EXP 22
17138: PUSH
17139: LD_EXP 23
17143: PUSH
17144: LD_EXP 24
17148: PUSH
17149: LD_EXP 25
17153: PUSH
17154: LD_EXP 26
17158: PUSH
17159: LD_EXP 27
17163: PUSH
17164: LD_EXP 28
17168: PUSH
17169: LD_EXP 29
17173: PUSH
17174: LD_EXP 30
17178: PUSH
17179: LD_EXP 31
17183: PUSH
17184: LD_EXP 32
17188: PUSH
17189: LD_EXP 34
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: DIFF
17210: ST_TO_ADDR
// if not result then
17211: LD_VAR 0 3
17215: NOT
17216: IFFALSE 17220
// exit ;
17218: GO 17248
// result := result [ 1 ] ;
17220: LD_ADDR_VAR 0 3
17224: PUSH
17225: LD_VAR 0 3
17229: PUSH
17230: LD_INT 1
17232: ARRAY
17233: ST_TO_ADDR
// Say ( result , dial ) ;
17234: LD_VAR 0 3
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL_OW 88
// end ;
17248: LD_VAR 0 3
17252: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17253: LD_INT 0
17255: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17256: LD_ADDR_VAR 0 4
17260: PUSH
17261: LD_INT 22
17263: PUSH
17264: LD_INT 1
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: LD_INT 26
17273: PUSH
17274: LD_VAR 0 1
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: LD_INT 2
17285: PUSH
17286: LD_INT 25
17288: PUSH
17289: LD_INT 1
17291: PUSH
17292: EMPTY
17293: LIST
17294: LIST
17295: PUSH
17296: LD_INT 25
17298: PUSH
17299: LD_INT 2
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: LD_INT 25
17308: PUSH
17309: LD_INT 3
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 25
17318: PUSH
17319: LD_INT 4
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: EMPTY
17327: LIST
17328: LIST
17329: LIST
17330: LIST
17331: LIST
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: PPUSH
17338: CALL_OW 69
17342: PUSH
17343: LD_EXP 21
17347: PUSH
17348: LD_EXP 33
17352: PUSH
17353: LD_EXP 22
17357: PUSH
17358: LD_EXP 23
17362: PUSH
17363: LD_EXP 24
17367: PUSH
17368: LD_EXP 25
17372: PUSH
17373: LD_EXP 26
17377: PUSH
17378: LD_EXP 27
17382: PUSH
17383: LD_EXP 28
17387: PUSH
17388: LD_EXP 29
17392: PUSH
17393: LD_EXP 30
17397: PUSH
17398: LD_EXP 31
17402: PUSH
17403: LD_EXP 32
17407: PUSH
17408: LD_EXP 34
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: LIST
17426: LIST
17427: LIST
17428: PUSH
17429: LD_VAR 0 3
17433: ADD
17434: DIFF
17435: ST_TO_ADDR
// if not result then
17436: LD_VAR 0 4
17440: NOT
17441: IFFALSE 17445
// exit ;
17443: GO 17473
// result := result [ 1 ] ;
17445: LD_ADDR_VAR 0 4
17449: PUSH
17450: LD_VAR 0 4
17454: PUSH
17455: LD_INT 1
17457: ARRAY
17458: ST_TO_ADDR
// Say ( result , dial ) ;
17459: LD_VAR 0 4
17463: PPUSH
17464: LD_VAR 0 2
17468: PPUSH
17469: CALL_OW 88
// end ; end_of_file
17473: LD_VAR 0 4
17477: RET
// export function CustomEvent ( event ) ; begin
17478: LD_INT 0
17480: PPUSH
// end ;
17481: LD_VAR 0 2
17485: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17486: LD_VAR 0 1
17490: PPUSH
17491: CALL_OW 255
17495: PUSH
17496: LD_INT 1
17498: EQUAL
17499: IFFALSE 17509
// artifact_get := true ;
17501: LD_ADDR_EXP 13
17505: PUSH
17506: LD_INT 1
17508: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17509: LD_VAR 0 1
17513: PPUSH
17514: CALL_OW 255
17518: PUSH
17519: LD_INT 2
17521: EQUAL
17522: IFFALSE 17540
// begin artifact_get := false ;
17524: LD_ADDR_EXP 13
17528: PUSH
17529: LD_INT 0
17531: ST_TO_ADDR
// artifact_stolen := true ;
17532: LD_ADDR_EXP 12
17536: PUSH
17537: LD_INT 1
17539: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17540: LD_ADDR_EXP 14
17544: PUSH
17545: LD_INT 1
17547: ST_TO_ADDR
// end ;
17548: PPOPN 2
17550: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17551: LD_ADDR_EXP 14
17555: PUSH
17556: LD_INT 0
17558: ST_TO_ADDR
// end ;
17559: PPOPN 2
17561: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17562: LD_VAR 0 1
17566: PPUSH
17567: CALL 107948 0 1
// if un = JMM then
17571: LD_VAR 0 1
17575: PUSH
17576: LD_EXP 21
17580: EQUAL
17581: IFFALSE 17592
// begin YouLost ( JMM ) ;
17583: LD_STRING JMM
17585: PPUSH
17586: CALL_OW 104
// exit ;
17590: GO 17724
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17592: LD_VAR 0 1
17596: PUSH
17597: LD_INT 22
17599: PUSH
17600: LD_INT 1
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 21
17609: PUSH
17610: LD_INT 1
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: LD_INT 2
17619: PUSH
17620: LD_INT 25
17622: PUSH
17623: LD_INT 1
17625: PUSH
17626: EMPTY
17627: LIST
17628: LIST
17629: PUSH
17630: LD_INT 25
17632: PUSH
17633: LD_INT 2
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PUSH
17640: LD_INT 25
17642: PUSH
17643: LD_INT 3
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: PUSH
17650: LD_INT 25
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: PUSH
17660: LD_INT 25
17662: PUSH
17663: LD_INT 5
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: PUSH
17670: LD_INT 25
17672: PUSH
17673: LD_INT 8
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: LIST
17686: LIST
17687: LIST
17688: PUSH
17689: EMPTY
17690: LIST
17691: LIST
17692: LIST
17693: PPUSH
17694: CALL_OW 69
17698: IN
17699: IFFALSE 17715
// loses_counter := loses_counter + 1 ;
17701: LD_ADDR_EXP 17
17705: PUSH
17706: LD_EXP 17
17710: PUSH
17711: LD_INT 1
17713: PLUS
17714: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL 46201 0 1
// end ;
17724: PPOPN 1
17726: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17727: LD_VAR 0 1
17731: PPUSH
17732: LD_VAR 0 2
17736: PPUSH
17737: CALL 48533 0 2
// end ;
17741: PPOPN 2
17743: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17744: LD_VAR 0 1
17748: PPUSH
17749: CALL 47842 0 1
// end ;
17753: PPOPN 1
17755: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17756: LD_VAR 0 1
17760: PPUSH
17761: LD_VAR 0 2
17765: PPUSH
17766: LD_VAR 0 3
17770: PPUSH
17771: LD_VAR 0 4
17775: PPUSH
17776: LD_VAR 0 5
17780: PPUSH
17781: CALL 45517 0 5
// end ;
17785: PPOPN 5
17787: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17788: LD_VAR 0 1
17792: PPUSH
17793: LD_VAR 0 2
17797: PPUSH
17798: CALL 108006 0 2
// if GetNation ( vehicle ) = nation_american then
17802: LD_VAR 0 1
17806: PPUSH
17807: CALL_OW 248
17811: PUSH
17812: LD_INT 1
17814: EQUAL
17815: IFFALSE 17825
// am_veh_consturcted := true ;
17817: LD_ADDR_EXP 20
17821: PUSH
17822: LD_INT 1
17824: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17825: LD_VAR 0 1
17829: PPUSH
17830: LD_VAR 0 2
17834: PPUSH
17835: CALL 45070 0 2
// end ;
17839: PPOPN 2
17841: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17842: LD_VAR 0 1
17846: PPUSH
17847: CALL_OW 247
17851: PUSH
17852: LD_INT 2
17854: EQUAL
17855: IFFALSE 17859
// exit ;
17857: GO 17876
// if not kamikazed then
17859: LD_EXP 11
17863: NOT
17864: IFFALSE 17876
// kamikazed := unit ;
17866: LD_ADDR_EXP 11
17870: PUSH
17871: LD_VAR 0 1
17875: ST_TO_ADDR
// end ;
17876: PPOPN 1
17878: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17879: LD_INT 0
17881: PPUSH
17882: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17883: LD_VAR 0 1
17887: PPUSH
17888: LD_VAR 0 2
17892: PPUSH
17893: LD_VAR 0 3
17897: PPUSH
17898: LD_VAR 0 4
17902: PPUSH
17903: CALL 44908 0 4
// end ;
17907: PPOPN 6
17909: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17910: LD_INT 0
17912: PPUSH
// begin if building = ar_dep_n then
17913: LD_VAR 0 1
17917: PUSH
17918: LD_INT 94
17920: EQUAL
17921: IFFALSE 17973
// begin for i := 1 to 3 do
17923: LD_ADDR_VAR 0 4
17927: PUSH
17928: DOUBLE
17929: LD_INT 1
17931: DEC
17932: ST_TO_ADDR
17933: LD_INT 3
17935: PUSH
17936: FOR_TO
17937: IFFALSE 17971
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17939: LD_INT 115
17941: PUSH
17942: LD_VAR 0 4
17946: PUSH
17947: LD_INT 2
17949: MUL
17950: PLUS
17951: PPUSH
17952: LD_INT 6
17954: PPUSH
17955: LD_INT 1
17957: PPUSH
17958: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17962: LD_INT 10
17964: PPUSH
17965: CALL_OW 67
// end ;
17969: GO 17936
17971: POP
17972: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17973: LD_VAR 0 1
17977: PPUSH
17978: LD_VAR 0 2
17982: PPUSH
17983: LD_VAR 0 3
17987: PPUSH
17988: CALL 44683 0 3
// end ;
17992: PPOPN 4
17994: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: CALL 45897 0 2
// end ;
18009: PPOPN 2
18011: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
18012: LD_VAR 0 1
18016: PPUSH
18017: LD_VAR 0 2
18021: PPUSH
18022: CALL 44377 0 2
// end ;
18026: PPOPN 2
18028: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
18029: LD_VAR 0 1
18033: PPUSH
18034: LD_VAR 0 2
18038: PPUSH
18039: CALL 44568 0 2
// end ;
18043: PPOPN 2
18045: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
18046: LD_VAR 0 1
18050: PPUSH
18051: CALL 47601 0 1
// end ;
18055: PPOPN 1
18057: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
18058: LD_VAR 0 1
18062: PPUSH
18063: LD_VAR 0 2
18067: PPUSH
18068: CALL 48828 0 2
// end ;
18072: PPOPN 2
18074: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
18075: LD_VAR 0 1
18079: PPUSH
18080: LD_VAR 0 2
18084: PPUSH
18085: LD_VAR 0 3
18089: PPUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: CALL 49044 0 4
// end ;
18099: PPOPN 4
18101: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18102: LD_VAR 0 1
18106: PPUSH
18107: CALL 107990 0 1
// end ;
18111: PPOPN 1
18113: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18114: LD_INT 22
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: PUSH
18124: LD_INT 50
18126: PUSH
18127: EMPTY
18128: LIST
18129: PUSH
18130: LD_INT 21
18132: PUSH
18133: LD_INT 1
18135: PUSH
18136: EMPTY
18137: LIST
18138: LIST
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: LIST
18144: PPUSH
18145: CALL_OW 69
18149: IFFALSE 18233
18151: GO 18153
18153: DISABLE
18154: LD_INT 0
18156: PPUSH
// begin enable ;
18157: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18158: LD_ADDR_VAR 0 1
18162: PUSH
18163: LD_INT 22
18165: PUSH
18166: LD_INT 2
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 50
18175: PUSH
18176: EMPTY
18177: LIST
18178: PUSH
18179: LD_INT 21
18181: PUSH
18182: LD_INT 1
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: PUSH
18189: EMPTY
18190: LIST
18191: LIST
18192: LIST
18193: PPUSH
18194: CALL_OW 69
18198: PUSH
18199: FOR_IN
18200: IFFALSE 18231
// if GetFuel ( i ) < 3 then
18202: LD_VAR 0 1
18206: PPUSH
18207: CALL_OW 261
18211: PUSH
18212: LD_INT 3
18214: LESS
18215: IFFALSE 18229
// SetFuel ( i , 5 ) ;
18217: LD_VAR 0 1
18221: PPUSH
18222: LD_INT 5
18224: PPUSH
18225: CALL_OW 240
18229: GO 18199
18231: POP
18232: POP
// end ; end_of_file
18233: PPOPN 1
18235: END
// every 0 0$1 trigger game do
18236: LD_EXP 2
18240: IFFALSE 18270
18242: GO 18244
18244: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18245: LD_INT 7
18247: PUSH
18248: LD_INT 6
18250: PUSH
18251: LD_INT 4
18253: PUSH
18254: LD_INT 6
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: PPUSH
18263: LD_INT 1750
18265: PPUSH
18266: CALL 18271 0 2
18270: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
// if not areas then
18276: LD_VAR 0 1
18280: NOT
18281: IFFALSE 18285
// exit ;
18283: GO 18415
// repeat wait ( time ) ;
18285: LD_VAR 0 2
18289: PPUSH
18290: CALL_OW 67
// for i in areas do
18294: LD_ADDR_VAR 0 4
18298: PUSH
18299: LD_VAR 0 1
18303: PUSH
18304: FOR_IN
18305: IFFALSE 18374
// begin p := rand ( 1 , 90 ) ;
18307: LD_ADDR_VAR 0 5
18311: PUSH
18312: LD_INT 1
18314: PPUSH
18315: LD_INT 90
18317: PPUSH
18318: CALL_OW 12
18322: ST_TO_ADDR
// if Prob ( p ) then
18323: LD_VAR 0 5
18327: PPUSH
18328: CALL_OW 13
18332: IFFALSE 18372
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18334: LD_INT 2
18336: PPUSH
18337: LD_INT 5
18339: PPUSH
18340: CALL_OW 12
18344: PPUSH
18345: LD_VAR 0 4
18349: PPUSH
18350: LD_INT 1
18352: PPUSH
18353: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18357: LD_INT 735
18359: PPUSH
18360: LD_INT 1295
18362: PPUSH
18363: CALL_OW 12
18367: PPUSH
18368: CALL_OW 67
// end ; end ;
18372: GO 18304
18374: POP
18375: POP
// time := time + 0 0$3 ;
18376: LD_ADDR_VAR 0 2
18380: PUSH
18381: LD_VAR 0 2
18385: PUSH
18386: LD_INT 105
18388: PLUS
18389: ST_TO_ADDR
// if time > 3 3$00 then
18390: LD_VAR 0 2
18394: PUSH
18395: LD_INT 6300
18397: GREATER
18398: IFFALSE 18408
// time := 0 0$40 ;
18400: LD_ADDR_VAR 0 2
18404: PUSH
18405: LD_INT 1400
18407: ST_TO_ADDR
// until not game ;
18408: LD_EXP 2
18412: NOT
18413: IFFALSE 18285
// end ;
18415: LD_VAR 0 3
18419: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18420: LD_OWVAR 1
18424: PUSH
18425: LD_INT 84000
18427: PUSH
18428: LD_INT 73500
18430: PUSH
18431: LD_INT 63000
18433: PUSH
18434: LD_INT 52500
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: PUSH
18443: LD_OWVAR 67
18447: ARRAY
18448: LESS
18449: IFFALSE 18476
18451: GO 18453
18453: DISABLE
// begin enable ;
18454: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18455: LD_INT 1
18457: PPUSH
18458: LD_INT 5
18460: PPUSH
18461: CALL_OW 12
18465: PPUSH
18466: LD_INT 7
18468: PPUSH
18469: LD_INT 1
18471: PPUSH
18472: CALL_OW 55
// end ; end_of_file
18476: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18477: LD_INT 0
18479: PPUSH
18480: PPUSH
// skirmish := false ;
18481: LD_ADDR_EXP 48
18485: PUSH
18486: LD_INT 0
18488: ST_TO_ADDR
// debug_mc := false ;
18489: LD_ADDR_EXP 49
18493: PUSH
18494: LD_INT 0
18496: ST_TO_ADDR
// mc_bases := [ ] ;
18497: LD_ADDR_EXP 50
18501: PUSH
18502: EMPTY
18503: ST_TO_ADDR
// mc_sides := [ ] ;
18504: LD_ADDR_EXP 76
18508: PUSH
18509: EMPTY
18510: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18511: LD_ADDR_EXP 51
18515: PUSH
18516: EMPTY
18517: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18518: LD_ADDR_EXP 52
18522: PUSH
18523: EMPTY
18524: ST_TO_ADDR
// mc_need_heal := [ ] ;
18525: LD_ADDR_EXP 53
18529: PUSH
18530: EMPTY
18531: ST_TO_ADDR
// mc_healers := [ ] ;
18532: LD_ADDR_EXP 54
18536: PUSH
18537: EMPTY
18538: ST_TO_ADDR
// mc_build_list := [ ] ;
18539: LD_ADDR_EXP 55
18543: PUSH
18544: EMPTY
18545: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18546: LD_ADDR_EXP 82
18550: PUSH
18551: EMPTY
18552: ST_TO_ADDR
// mc_builders := [ ] ;
18553: LD_ADDR_EXP 56
18557: PUSH
18558: EMPTY
18559: ST_TO_ADDR
// mc_construct_list := [ ] ;
18560: LD_ADDR_EXP 57
18564: PUSH
18565: EMPTY
18566: ST_TO_ADDR
// mc_turret_list := [ ] ;
18567: LD_ADDR_EXP 58
18571: PUSH
18572: EMPTY
18573: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18574: LD_ADDR_EXP 59
18578: PUSH
18579: EMPTY
18580: ST_TO_ADDR
// mc_miners := [ ] ;
18581: LD_ADDR_EXP 64
18585: PUSH
18586: EMPTY
18587: ST_TO_ADDR
// mc_mines := [ ] ;
18588: LD_ADDR_EXP 63
18592: PUSH
18593: EMPTY
18594: ST_TO_ADDR
// mc_minefields := [ ] ;
18595: LD_ADDR_EXP 65
18599: PUSH
18600: EMPTY
18601: ST_TO_ADDR
// mc_crates := [ ] ;
18602: LD_ADDR_EXP 66
18606: PUSH
18607: EMPTY
18608: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18609: LD_ADDR_EXP 67
18613: PUSH
18614: EMPTY
18615: ST_TO_ADDR
// mc_crates_area := [ ] ;
18616: LD_ADDR_EXP 68
18620: PUSH
18621: EMPTY
18622: ST_TO_ADDR
// mc_vehicles := [ ] ;
18623: LD_ADDR_EXP 69
18627: PUSH
18628: EMPTY
18629: ST_TO_ADDR
// mc_attack := [ ] ;
18630: LD_ADDR_EXP 70
18634: PUSH
18635: EMPTY
18636: ST_TO_ADDR
// mc_produce := [ ] ;
18637: LD_ADDR_EXP 71
18641: PUSH
18642: EMPTY
18643: ST_TO_ADDR
// mc_defender := [ ] ;
18644: LD_ADDR_EXP 72
18648: PUSH
18649: EMPTY
18650: ST_TO_ADDR
// mc_parking := [ ] ;
18651: LD_ADDR_EXP 74
18655: PUSH
18656: EMPTY
18657: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18658: LD_ADDR_EXP 60
18662: PUSH
18663: EMPTY
18664: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18665: LD_ADDR_EXP 62
18669: PUSH
18670: EMPTY
18671: ST_TO_ADDR
// mc_scan := [ ] ;
18672: LD_ADDR_EXP 73
18676: PUSH
18677: EMPTY
18678: ST_TO_ADDR
// mc_scan_area := [ ] ;
18679: LD_ADDR_EXP 75
18683: PUSH
18684: EMPTY
18685: ST_TO_ADDR
// mc_tech := [ ] ;
18686: LD_ADDR_EXP 77
18690: PUSH
18691: EMPTY
18692: ST_TO_ADDR
// mc_class := [ ] ;
18693: LD_ADDR_EXP 91
18697: PUSH
18698: EMPTY
18699: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18700: LD_ADDR_EXP 92
18704: PUSH
18705: EMPTY
18706: ST_TO_ADDR
// mc_is_defending := [ ] ;
18707: LD_ADDR_EXP 93
18711: PUSH
18712: EMPTY
18713: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18714: LD_ADDR_EXP 84
18718: PUSH
18719: EMPTY
18720: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18721: LD_ADDR_EXP 94
18725: PUSH
18726: LD_INT 0
18728: ST_TO_ADDR
// end ;
18729: LD_VAR 0 1
18733: RET
// export function MC_Kill ( base ) ; begin
18734: LD_INT 0
18736: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18737: LD_ADDR_EXP 50
18741: PUSH
18742: LD_EXP 50
18746: PPUSH
18747: LD_VAR 0 1
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18759: LD_ADDR_EXP 51
18763: PUSH
18764: LD_EXP 51
18768: PPUSH
18769: LD_VAR 0 1
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18781: LD_ADDR_EXP 52
18785: PUSH
18786: LD_EXP 52
18790: PPUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18803: LD_ADDR_EXP 53
18807: PUSH
18808: LD_EXP 53
18812: PPUSH
18813: LD_VAR 0 1
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18825: LD_ADDR_EXP 54
18829: PUSH
18830: LD_EXP 54
18834: PPUSH
18835: LD_VAR 0 1
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18847: LD_ADDR_EXP 55
18851: PUSH
18852: LD_EXP 55
18856: PPUSH
18857: LD_VAR 0 1
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18869: LD_ADDR_EXP 56
18873: PUSH
18874: LD_EXP 56
18878: PPUSH
18879: LD_VAR 0 1
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18891: LD_ADDR_EXP 57
18895: PUSH
18896: LD_EXP 57
18900: PPUSH
18901: LD_VAR 0 1
18905: PPUSH
18906: EMPTY
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18913: LD_ADDR_EXP 58
18917: PUSH
18918: LD_EXP 58
18922: PPUSH
18923: LD_VAR 0 1
18927: PPUSH
18928: EMPTY
18929: PPUSH
18930: CALL_OW 1
18934: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18935: LD_ADDR_EXP 59
18939: PUSH
18940: LD_EXP 59
18944: PPUSH
18945: LD_VAR 0 1
18949: PPUSH
18950: EMPTY
18951: PPUSH
18952: CALL_OW 1
18956: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18957: LD_ADDR_EXP 60
18961: PUSH
18962: LD_EXP 60
18966: PPUSH
18967: LD_VAR 0 1
18971: PPUSH
18972: EMPTY
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18979: LD_ADDR_EXP 61
18983: PUSH
18984: LD_EXP 61
18988: PPUSH
18989: LD_VAR 0 1
18993: PPUSH
18994: LD_INT 0
18996: PPUSH
18997: CALL_OW 1
19001: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19002: LD_ADDR_EXP 62
19006: PUSH
19007: LD_EXP 62
19011: PPUSH
19012: LD_VAR 0 1
19016: PPUSH
19017: EMPTY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19024: LD_ADDR_EXP 63
19028: PUSH
19029: LD_EXP 63
19033: PPUSH
19034: LD_VAR 0 1
19038: PPUSH
19039: EMPTY
19040: PPUSH
19041: CALL_OW 1
19045: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19046: LD_ADDR_EXP 64
19050: PUSH
19051: LD_EXP 64
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: EMPTY
19062: PPUSH
19063: CALL_OW 1
19067: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19068: LD_ADDR_EXP 65
19072: PUSH
19073: LD_EXP 65
19077: PPUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: EMPTY
19084: PPUSH
19085: CALL_OW 1
19089: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19090: LD_ADDR_EXP 66
19094: PUSH
19095: LD_EXP 66
19099: PPUSH
19100: LD_VAR 0 1
19104: PPUSH
19105: EMPTY
19106: PPUSH
19107: CALL_OW 1
19111: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19112: LD_ADDR_EXP 67
19116: PUSH
19117: LD_EXP 67
19121: PPUSH
19122: LD_VAR 0 1
19126: PPUSH
19127: EMPTY
19128: PPUSH
19129: CALL_OW 1
19133: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19134: LD_ADDR_EXP 68
19138: PUSH
19139: LD_EXP 68
19143: PPUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: EMPTY
19150: PPUSH
19151: CALL_OW 1
19155: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19156: LD_ADDR_EXP 69
19160: PUSH
19161: LD_EXP 69
19165: PPUSH
19166: LD_VAR 0 1
19170: PPUSH
19171: EMPTY
19172: PPUSH
19173: CALL_OW 1
19177: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19178: LD_ADDR_EXP 70
19182: PUSH
19183: LD_EXP 70
19187: PPUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: EMPTY
19194: PPUSH
19195: CALL_OW 1
19199: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19200: LD_ADDR_EXP 71
19204: PUSH
19205: LD_EXP 71
19209: PPUSH
19210: LD_VAR 0 1
19214: PPUSH
19215: EMPTY
19216: PPUSH
19217: CALL_OW 1
19221: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19222: LD_ADDR_EXP 72
19226: PUSH
19227: LD_EXP 72
19231: PPUSH
19232: LD_VAR 0 1
19236: PPUSH
19237: EMPTY
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19244: LD_ADDR_EXP 73
19248: PUSH
19249: LD_EXP 73
19253: PPUSH
19254: LD_VAR 0 1
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL_OW 1
19265: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19266: LD_ADDR_EXP 74
19270: PUSH
19271: LD_EXP 74
19275: PPUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: EMPTY
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19288: LD_ADDR_EXP 75
19292: PUSH
19293: LD_EXP 75
19297: PPUSH
19298: LD_VAR 0 1
19302: PPUSH
19303: EMPTY
19304: PPUSH
19305: CALL_OW 1
19309: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19310: LD_ADDR_EXP 77
19314: PUSH
19315: LD_EXP 77
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: EMPTY
19326: PPUSH
19327: CALL_OW 1
19331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19332: LD_ADDR_EXP 79
19336: PUSH
19337: LD_EXP 79
19341: PPUSH
19342: LD_VAR 0 1
19346: PPUSH
19347: EMPTY
19348: PPUSH
19349: CALL_OW 1
19353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19354: LD_ADDR_EXP 80
19358: PUSH
19359: LD_EXP 80
19363: PPUSH
19364: LD_VAR 0 1
19368: PPUSH
19369: EMPTY
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19376: LD_ADDR_EXP 81
19380: PUSH
19381: LD_EXP 81
19385: PPUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: EMPTY
19392: PPUSH
19393: CALL_OW 1
19397: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19398: LD_ADDR_EXP 82
19402: PUSH
19403: LD_EXP 82
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: EMPTY
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19420: LD_ADDR_EXP 83
19424: PUSH
19425: LD_EXP 83
19429: PPUSH
19430: LD_VAR 0 1
19434: PPUSH
19435: EMPTY
19436: PPUSH
19437: CALL_OW 1
19441: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19442: LD_ADDR_EXP 84
19446: PUSH
19447: LD_EXP 84
19451: PPUSH
19452: LD_VAR 0 1
19456: PPUSH
19457: EMPTY
19458: PPUSH
19459: CALL_OW 1
19463: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19464: LD_ADDR_EXP 85
19468: PUSH
19469: LD_EXP 85
19473: PPUSH
19474: LD_VAR 0 1
19478: PPUSH
19479: EMPTY
19480: PPUSH
19481: CALL_OW 1
19485: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19486: LD_ADDR_EXP 86
19490: PUSH
19491: LD_EXP 86
19495: PPUSH
19496: LD_VAR 0 1
19500: PPUSH
19501: EMPTY
19502: PPUSH
19503: CALL_OW 1
19507: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19508: LD_ADDR_EXP 87
19512: PUSH
19513: LD_EXP 87
19517: PPUSH
19518: LD_VAR 0 1
19522: PPUSH
19523: EMPTY
19524: PPUSH
19525: CALL_OW 1
19529: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19530: LD_ADDR_EXP 88
19534: PUSH
19535: LD_EXP 88
19539: PPUSH
19540: LD_VAR 0 1
19544: PPUSH
19545: EMPTY
19546: PPUSH
19547: CALL_OW 1
19551: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19552: LD_ADDR_EXP 89
19556: PUSH
19557: LD_EXP 89
19561: PPUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: EMPTY
19568: PPUSH
19569: CALL_OW 1
19573: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19574: LD_ADDR_EXP 90
19578: PUSH
19579: LD_EXP 90
19583: PPUSH
19584: LD_VAR 0 1
19588: PPUSH
19589: EMPTY
19590: PPUSH
19591: CALL_OW 1
19595: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19596: LD_ADDR_EXP 91
19600: PUSH
19601: LD_EXP 91
19605: PPUSH
19606: LD_VAR 0 1
19610: PPUSH
19611: EMPTY
19612: PPUSH
19613: CALL_OW 1
19617: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19618: LD_ADDR_EXP 92
19622: PUSH
19623: LD_EXP 92
19627: PPUSH
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_INT 0
19635: PPUSH
19636: CALL_OW 1
19640: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19641: LD_ADDR_EXP 93
19645: PUSH
19646: LD_EXP 93
19650: PPUSH
19651: LD_VAR 0 1
19655: PPUSH
19656: LD_INT 0
19658: PPUSH
19659: CALL_OW 1
19663: ST_TO_ADDR
// end ;
19664: LD_VAR 0 2
19668: RET
// export function MC_Add ( side , units ) ; var base ; begin
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
// base := mc_bases + 1 ;
19673: LD_ADDR_VAR 0 4
19677: PUSH
19678: LD_EXP 50
19682: PUSH
19683: LD_INT 1
19685: PLUS
19686: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19687: LD_ADDR_EXP 76
19691: PUSH
19692: LD_EXP 76
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 1
19706: PPUSH
19707: CALL_OW 1
19711: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19712: LD_ADDR_EXP 50
19716: PUSH
19717: LD_EXP 50
19721: PPUSH
19722: LD_VAR 0 4
19726: PPUSH
19727: LD_VAR 0 2
19731: PPUSH
19732: CALL_OW 1
19736: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19737: LD_ADDR_EXP 51
19741: PUSH
19742: LD_EXP 51
19746: PPUSH
19747: LD_VAR 0 4
19751: PPUSH
19752: EMPTY
19753: PPUSH
19754: CALL_OW 1
19758: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19759: LD_ADDR_EXP 52
19763: PUSH
19764: LD_EXP 52
19768: PPUSH
19769: LD_VAR 0 4
19773: PPUSH
19774: EMPTY
19775: PPUSH
19776: CALL_OW 1
19780: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19781: LD_ADDR_EXP 53
19785: PUSH
19786: LD_EXP 53
19790: PPUSH
19791: LD_VAR 0 4
19795: PPUSH
19796: EMPTY
19797: PPUSH
19798: CALL_OW 1
19802: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19803: LD_ADDR_EXP 54
19807: PUSH
19808: LD_EXP 54
19812: PPUSH
19813: LD_VAR 0 4
19817: PPUSH
19818: EMPTY
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19825: LD_ADDR_EXP 55
19829: PUSH
19830: LD_EXP 55
19834: PPUSH
19835: LD_VAR 0 4
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19847: LD_ADDR_EXP 56
19851: PUSH
19852: LD_EXP 56
19856: PPUSH
19857: LD_VAR 0 4
19861: PPUSH
19862: EMPTY
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19869: LD_ADDR_EXP 57
19873: PUSH
19874: LD_EXP 57
19878: PPUSH
19879: LD_VAR 0 4
19883: PPUSH
19884: EMPTY
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19891: LD_ADDR_EXP 58
19895: PUSH
19896: LD_EXP 58
19900: PPUSH
19901: LD_VAR 0 4
19905: PPUSH
19906: EMPTY
19907: PPUSH
19908: CALL_OW 1
19912: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19913: LD_ADDR_EXP 59
19917: PUSH
19918: LD_EXP 59
19922: PPUSH
19923: LD_VAR 0 4
19927: PPUSH
19928: EMPTY
19929: PPUSH
19930: CALL_OW 1
19934: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19935: LD_ADDR_EXP 60
19939: PUSH
19940: LD_EXP 60
19944: PPUSH
19945: LD_VAR 0 4
19949: PPUSH
19950: EMPTY
19951: PPUSH
19952: CALL_OW 1
19956: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19957: LD_ADDR_EXP 61
19961: PUSH
19962: LD_EXP 61
19966: PPUSH
19967: LD_VAR 0 4
19971: PPUSH
19972: LD_INT 0
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19980: LD_ADDR_EXP 62
19984: PUSH
19985: LD_EXP 62
19989: PPUSH
19990: LD_VAR 0 4
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20002: LD_ADDR_EXP 63
20006: PUSH
20007: LD_EXP 63
20011: PPUSH
20012: LD_VAR 0 4
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20024: LD_ADDR_EXP 64
20028: PUSH
20029: LD_EXP 64
20033: PPUSH
20034: LD_VAR 0 4
20038: PPUSH
20039: EMPTY
20040: PPUSH
20041: CALL_OW 1
20045: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20046: LD_ADDR_EXP 65
20050: PUSH
20051: LD_EXP 65
20055: PPUSH
20056: LD_VAR 0 4
20060: PPUSH
20061: EMPTY
20062: PPUSH
20063: CALL_OW 1
20067: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20068: LD_ADDR_EXP 66
20072: PUSH
20073: LD_EXP 66
20077: PPUSH
20078: LD_VAR 0 4
20082: PPUSH
20083: EMPTY
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20090: LD_ADDR_EXP 67
20094: PUSH
20095: LD_EXP 67
20099: PPUSH
20100: LD_VAR 0 4
20104: PPUSH
20105: EMPTY
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20112: LD_ADDR_EXP 68
20116: PUSH
20117: LD_EXP 68
20121: PPUSH
20122: LD_VAR 0 4
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20134: LD_ADDR_EXP 69
20138: PUSH
20139: LD_EXP 69
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20156: LD_ADDR_EXP 70
20160: PUSH
20161: LD_EXP 70
20165: PPUSH
20166: LD_VAR 0 4
20170: PPUSH
20171: EMPTY
20172: PPUSH
20173: CALL_OW 1
20177: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20178: LD_ADDR_EXP 71
20182: PUSH
20183: LD_EXP 71
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: EMPTY
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20200: LD_ADDR_EXP 72
20204: PUSH
20205: LD_EXP 72
20209: PPUSH
20210: LD_VAR 0 4
20214: PPUSH
20215: EMPTY
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20222: LD_ADDR_EXP 73
20226: PUSH
20227: LD_EXP 73
20231: PPUSH
20232: LD_VAR 0 4
20236: PPUSH
20237: EMPTY
20238: PPUSH
20239: CALL_OW 1
20243: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20244: LD_ADDR_EXP 74
20248: PUSH
20249: LD_EXP 74
20253: PPUSH
20254: LD_VAR 0 4
20258: PPUSH
20259: EMPTY
20260: PPUSH
20261: CALL_OW 1
20265: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20266: LD_ADDR_EXP 75
20270: PUSH
20271: LD_EXP 75
20275: PPUSH
20276: LD_VAR 0 4
20280: PPUSH
20281: EMPTY
20282: PPUSH
20283: CALL_OW 1
20287: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20288: LD_ADDR_EXP 77
20292: PUSH
20293: LD_EXP 77
20297: PPUSH
20298: LD_VAR 0 4
20302: PPUSH
20303: EMPTY
20304: PPUSH
20305: CALL_OW 1
20309: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20310: LD_ADDR_EXP 79
20314: PUSH
20315: LD_EXP 79
20319: PPUSH
20320: LD_VAR 0 4
20324: PPUSH
20325: EMPTY
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20332: LD_ADDR_EXP 80
20336: PUSH
20337: LD_EXP 80
20341: PPUSH
20342: LD_VAR 0 4
20346: PPUSH
20347: EMPTY
20348: PPUSH
20349: CALL_OW 1
20353: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20354: LD_ADDR_EXP 81
20358: PUSH
20359: LD_EXP 81
20363: PPUSH
20364: LD_VAR 0 4
20368: PPUSH
20369: EMPTY
20370: PPUSH
20371: CALL_OW 1
20375: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20376: LD_ADDR_EXP 82
20380: PUSH
20381: LD_EXP 82
20385: PPUSH
20386: LD_VAR 0 4
20390: PPUSH
20391: EMPTY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20398: LD_ADDR_EXP 83
20402: PUSH
20403: LD_EXP 83
20407: PPUSH
20408: LD_VAR 0 4
20412: PPUSH
20413: EMPTY
20414: PPUSH
20415: CALL_OW 1
20419: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20420: LD_ADDR_EXP 84
20424: PUSH
20425: LD_EXP 84
20429: PPUSH
20430: LD_VAR 0 4
20434: PPUSH
20435: EMPTY
20436: PPUSH
20437: CALL_OW 1
20441: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20442: LD_ADDR_EXP 85
20446: PUSH
20447: LD_EXP 85
20451: PPUSH
20452: LD_VAR 0 4
20456: PPUSH
20457: EMPTY
20458: PPUSH
20459: CALL_OW 1
20463: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20464: LD_ADDR_EXP 86
20468: PUSH
20469: LD_EXP 86
20473: PPUSH
20474: LD_VAR 0 4
20478: PPUSH
20479: EMPTY
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20486: LD_ADDR_EXP 87
20490: PUSH
20491: LD_EXP 87
20495: PPUSH
20496: LD_VAR 0 4
20500: PPUSH
20501: EMPTY
20502: PPUSH
20503: CALL_OW 1
20507: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20508: LD_ADDR_EXP 88
20512: PUSH
20513: LD_EXP 88
20517: PPUSH
20518: LD_VAR 0 4
20522: PPUSH
20523: EMPTY
20524: PPUSH
20525: CALL_OW 1
20529: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20530: LD_ADDR_EXP 89
20534: PUSH
20535: LD_EXP 89
20539: PPUSH
20540: LD_VAR 0 4
20544: PPUSH
20545: EMPTY
20546: PPUSH
20547: CALL_OW 1
20551: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20552: LD_ADDR_EXP 90
20556: PUSH
20557: LD_EXP 90
20561: PPUSH
20562: LD_VAR 0 4
20566: PPUSH
20567: EMPTY
20568: PPUSH
20569: CALL_OW 1
20573: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20574: LD_ADDR_EXP 91
20578: PUSH
20579: LD_EXP 91
20583: PPUSH
20584: LD_VAR 0 4
20588: PPUSH
20589: EMPTY
20590: PPUSH
20591: CALL_OW 1
20595: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20596: LD_ADDR_EXP 92
20600: PUSH
20601: LD_EXP 92
20605: PPUSH
20606: LD_VAR 0 4
20610: PPUSH
20611: LD_INT 0
20613: PPUSH
20614: CALL_OW 1
20618: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20619: LD_ADDR_EXP 93
20623: PUSH
20624: LD_EXP 93
20628: PPUSH
20629: LD_VAR 0 4
20633: PPUSH
20634: LD_INT 0
20636: PPUSH
20637: CALL_OW 1
20641: ST_TO_ADDR
// result := base ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 4
20651: ST_TO_ADDR
// end ;
20652: LD_VAR 0 3
20656: RET
// export function MC_Start ( ) ; var i ; begin
20657: LD_INT 0
20659: PPUSH
20660: PPUSH
// for i = 1 to mc_bases do
20661: LD_ADDR_VAR 0 2
20665: PUSH
20666: DOUBLE
20667: LD_INT 1
20669: DEC
20670: ST_TO_ADDR
20671: LD_EXP 50
20675: PUSH
20676: FOR_TO
20677: IFFALSE 21777
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20679: LD_ADDR_EXP 50
20683: PUSH
20684: LD_EXP 50
20688: PPUSH
20689: LD_VAR 0 2
20693: PPUSH
20694: LD_EXP 50
20698: PUSH
20699: LD_VAR 0 2
20703: ARRAY
20704: PUSH
20705: LD_INT 0
20707: DIFF
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20714: LD_ADDR_EXP 51
20718: PUSH
20719: LD_EXP 51
20723: PPUSH
20724: LD_VAR 0 2
20728: PPUSH
20729: EMPTY
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20736: LD_ADDR_EXP 52
20740: PUSH
20741: LD_EXP 52
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: EMPTY
20752: PPUSH
20753: CALL_OW 1
20757: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20758: LD_ADDR_EXP 53
20762: PUSH
20763: LD_EXP 53
20767: PPUSH
20768: LD_VAR 0 2
20772: PPUSH
20773: EMPTY
20774: PPUSH
20775: CALL_OW 1
20779: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20780: LD_ADDR_EXP 54
20784: PUSH
20785: LD_EXP 54
20789: PPUSH
20790: LD_VAR 0 2
20794: PPUSH
20795: EMPTY
20796: PUSH
20797: EMPTY
20798: PUSH
20799: EMPTY
20800: LIST
20801: LIST
20802: PPUSH
20803: CALL_OW 1
20807: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20808: LD_ADDR_EXP 55
20812: PUSH
20813: LD_EXP 55
20817: PPUSH
20818: LD_VAR 0 2
20822: PPUSH
20823: EMPTY
20824: PPUSH
20825: CALL_OW 1
20829: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20830: LD_ADDR_EXP 82
20834: PUSH
20835: LD_EXP 82
20839: PPUSH
20840: LD_VAR 0 2
20844: PPUSH
20845: EMPTY
20846: PPUSH
20847: CALL_OW 1
20851: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20852: LD_ADDR_EXP 56
20856: PUSH
20857: LD_EXP 56
20861: PPUSH
20862: LD_VAR 0 2
20866: PPUSH
20867: EMPTY
20868: PPUSH
20869: CALL_OW 1
20873: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20874: LD_ADDR_EXP 57
20878: PUSH
20879: LD_EXP 57
20883: PPUSH
20884: LD_VAR 0 2
20888: PPUSH
20889: EMPTY
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20896: LD_ADDR_EXP 58
20900: PUSH
20901: LD_EXP 58
20905: PPUSH
20906: LD_VAR 0 2
20910: PPUSH
20911: LD_EXP 50
20915: PUSH
20916: LD_VAR 0 2
20920: ARRAY
20921: PPUSH
20922: LD_INT 2
20924: PUSH
20925: LD_INT 30
20927: PUSH
20928: LD_INT 32
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: LD_INT 30
20937: PUSH
20938: LD_INT 33
20940: PUSH
20941: EMPTY
20942: LIST
20943: LIST
20944: PUSH
20945: EMPTY
20946: LIST
20947: LIST
20948: LIST
20949: PPUSH
20950: CALL_OW 72
20954: PPUSH
20955: CALL_OW 1
20959: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20960: LD_ADDR_EXP 59
20964: PUSH
20965: LD_EXP 59
20969: PPUSH
20970: LD_VAR 0 2
20974: PPUSH
20975: LD_EXP 50
20979: PUSH
20980: LD_VAR 0 2
20984: ARRAY
20985: PPUSH
20986: LD_INT 2
20988: PUSH
20989: LD_INT 30
20991: PUSH
20992: LD_INT 32
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: PUSH
20999: LD_INT 30
21001: PUSH
21002: LD_INT 31
21004: PUSH
21005: EMPTY
21006: LIST
21007: LIST
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: LIST
21013: PUSH
21014: LD_INT 58
21016: PUSH
21017: EMPTY
21018: LIST
21019: PUSH
21020: EMPTY
21021: LIST
21022: LIST
21023: PPUSH
21024: CALL_OW 72
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
21034: LD_ADDR_EXP 60
21038: PUSH
21039: LD_EXP 60
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
21056: LD_ADDR_EXP 64
21060: PUSH
21061: LD_EXP 64
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
21078: LD_ADDR_EXP 63
21082: PUSH
21083: LD_EXP 63
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21100: LD_ADDR_EXP 65
21104: PUSH
21105: LD_EXP 65
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21122: LD_ADDR_EXP 66
21126: PUSH
21127: LD_EXP 66
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21144: LD_ADDR_EXP 67
21148: PUSH
21149: LD_EXP 67
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21166: LD_ADDR_EXP 68
21170: PUSH
21171: LD_EXP 68
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21188: LD_ADDR_EXP 69
21192: PUSH
21193: LD_EXP 69
21197: PPUSH
21198: LD_VAR 0 2
21202: PPUSH
21203: EMPTY
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21210: LD_ADDR_EXP 70
21214: PUSH
21215: LD_EXP 70
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: EMPTY
21226: PPUSH
21227: CALL_OW 1
21231: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21232: LD_ADDR_EXP 71
21236: PUSH
21237: LD_EXP 71
21241: PPUSH
21242: LD_VAR 0 2
21246: PPUSH
21247: EMPTY
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21254: LD_ADDR_EXP 72
21258: PUSH
21259: LD_EXP 72
21263: PPUSH
21264: LD_VAR 0 2
21268: PPUSH
21269: EMPTY
21270: PPUSH
21271: CALL_OW 1
21275: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21276: LD_ADDR_EXP 61
21280: PUSH
21281: LD_EXP 61
21285: PPUSH
21286: LD_VAR 0 2
21290: PPUSH
21291: LD_INT 0
21293: PPUSH
21294: CALL_OW 1
21298: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21299: LD_ADDR_EXP 74
21303: PUSH
21304: LD_EXP 74
21308: PPUSH
21309: LD_VAR 0 2
21313: PPUSH
21314: LD_INT 0
21316: PPUSH
21317: CALL_OW 1
21321: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21322: LD_ADDR_EXP 62
21326: PUSH
21327: LD_EXP 62
21331: PPUSH
21332: LD_VAR 0 2
21336: PPUSH
21337: EMPTY
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21344: LD_ADDR_EXP 73
21348: PUSH
21349: LD_EXP 73
21353: PPUSH
21354: LD_VAR 0 2
21358: PPUSH
21359: LD_INT 0
21361: PPUSH
21362: CALL_OW 1
21366: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21367: LD_ADDR_EXP 75
21371: PUSH
21372: LD_EXP 75
21376: PPUSH
21377: LD_VAR 0 2
21381: PPUSH
21382: EMPTY
21383: PPUSH
21384: CALL_OW 1
21388: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21389: LD_ADDR_EXP 78
21393: PUSH
21394: LD_EXP 78
21398: PPUSH
21399: LD_VAR 0 2
21403: PPUSH
21404: LD_INT 0
21406: PPUSH
21407: CALL_OW 1
21411: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21412: LD_ADDR_EXP 79
21416: PUSH
21417: LD_EXP 79
21421: PPUSH
21422: LD_VAR 0 2
21426: PPUSH
21427: EMPTY
21428: PPUSH
21429: CALL_OW 1
21433: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21434: LD_ADDR_EXP 80
21438: PUSH
21439: LD_EXP 80
21443: PPUSH
21444: LD_VAR 0 2
21448: PPUSH
21449: EMPTY
21450: PPUSH
21451: CALL_OW 1
21455: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21456: LD_ADDR_EXP 81
21460: PUSH
21461: LD_EXP 81
21465: PPUSH
21466: LD_VAR 0 2
21470: PPUSH
21471: EMPTY
21472: PPUSH
21473: CALL_OW 1
21477: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21478: LD_ADDR_EXP 83
21482: PUSH
21483: LD_EXP 83
21487: PPUSH
21488: LD_VAR 0 2
21492: PPUSH
21493: LD_EXP 50
21497: PUSH
21498: LD_VAR 0 2
21502: ARRAY
21503: PPUSH
21504: LD_INT 2
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 6
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: LD_INT 30
21519: PUSH
21520: LD_INT 7
21522: PUSH
21523: EMPTY
21524: LIST
21525: LIST
21526: PUSH
21527: LD_INT 30
21529: PUSH
21530: LD_INT 8
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PPUSH
21543: CALL_OW 72
21547: PPUSH
21548: CALL_OW 1
21552: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21553: LD_ADDR_EXP 84
21557: PUSH
21558: LD_EXP 84
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: EMPTY
21569: PPUSH
21570: CALL_OW 1
21574: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21575: LD_ADDR_EXP 85
21579: PUSH
21580: LD_EXP 85
21584: PPUSH
21585: LD_VAR 0 2
21589: PPUSH
21590: EMPTY
21591: PPUSH
21592: CALL_OW 1
21596: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21597: LD_ADDR_EXP 86
21601: PUSH
21602: LD_EXP 86
21606: PPUSH
21607: LD_VAR 0 2
21611: PPUSH
21612: EMPTY
21613: PPUSH
21614: CALL_OW 1
21618: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21619: LD_ADDR_EXP 87
21623: PUSH
21624: LD_EXP 87
21628: PPUSH
21629: LD_VAR 0 2
21633: PPUSH
21634: EMPTY
21635: PPUSH
21636: CALL_OW 1
21640: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21641: LD_ADDR_EXP 88
21645: PUSH
21646: LD_EXP 88
21650: PPUSH
21651: LD_VAR 0 2
21655: PPUSH
21656: EMPTY
21657: PPUSH
21658: CALL_OW 1
21662: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21663: LD_ADDR_EXP 89
21667: PUSH
21668: LD_EXP 89
21672: PPUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: EMPTY
21679: PPUSH
21680: CALL_OW 1
21684: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21685: LD_ADDR_EXP 90
21689: PUSH
21690: LD_EXP 90
21694: PPUSH
21695: LD_VAR 0 2
21699: PPUSH
21700: EMPTY
21701: PPUSH
21702: CALL_OW 1
21706: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21707: LD_ADDR_EXP 91
21711: PUSH
21712: LD_EXP 91
21716: PPUSH
21717: LD_VAR 0 2
21721: PPUSH
21722: EMPTY
21723: PPUSH
21724: CALL_OW 1
21728: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21729: LD_ADDR_EXP 92
21733: PUSH
21734: LD_EXP 92
21738: PPUSH
21739: LD_VAR 0 2
21743: PPUSH
21744: LD_INT 0
21746: PPUSH
21747: CALL_OW 1
21751: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21752: LD_ADDR_EXP 93
21756: PUSH
21757: LD_EXP 93
21761: PPUSH
21762: LD_VAR 0 2
21766: PPUSH
21767: LD_INT 0
21769: PPUSH
21770: CALL_OW 1
21774: ST_TO_ADDR
// end ;
21775: GO 20676
21777: POP
21778: POP
// MC_InitSides ( ) ;
21779: CALL 22065 0 0
// MC_InitResearch ( ) ;
21783: CALL 21804 0 0
// CustomInitMacro ( ) ;
21787: CALL 304 0 0
// skirmish := true ;
21791: LD_ADDR_EXP 48
21795: PUSH
21796: LD_INT 1
21798: ST_TO_ADDR
// end ;
21799: LD_VAR 0 1
21803: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21804: LD_INT 0
21806: PPUSH
21807: PPUSH
21808: PPUSH
21809: PPUSH
21810: PPUSH
21811: PPUSH
// if not mc_bases then
21812: LD_EXP 50
21816: NOT
21817: IFFALSE 21821
// exit ;
21819: GO 22060
// for i = 1 to 8 do
21821: LD_ADDR_VAR 0 2
21825: PUSH
21826: DOUBLE
21827: LD_INT 1
21829: DEC
21830: ST_TO_ADDR
21831: LD_INT 8
21833: PUSH
21834: FOR_TO
21835: IFFALSE 21861
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21837: LD_ADDR_EXP 77
21841: PUSH
21842: LD_EXP 77
21846: PPUSH
21847: LD_VAR 0 2
21851: PPUSH
21852: EMPTY
21853: PPUSH
21854: CALL_OW 1
21858: ST_TO_ADDR
21859: GO 21834
21861: POP
21862: POP
// tmp := [ ] ;
21863: LD_ADDR_VAR 0 5
21867: PUSH
21868: EMPTY
21869: ST_TO_ADDR
// for i = 1 to mc_sides do
21870: LD_ADDR_VAR 0 2
21874: PUSH
21875: DOUBLE
21876: LD_INT 1
21878: DEC
21879: ST_TO_ADDR
21880: LD_EXP 76
21884: PUSH
21885: FOR_TO
21886: IFFALSE 21944
// if not mc_sides [ i ] in tmp then
21888: LD_EXP 76
21892: PUSH
21893: LD_VAR 0 2
21897: ARRAY
21898: PUSH
21899: LD_VAR 0 5
21903: IN
21904: NOT
21905: IFFALSE 21942
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21907: LD_ADDR_VAR 0 5
21911: PUSH
21912: LD_VAR 0 5
21916: PPUSH
21917: LD_VAR 0 5
21921: PUSH
21922: LD_INT 1
21924: PLUS
21925: PPUSH
21926: LD_EXP 76
21930: PUSH
21931: LD_VAR 0 2
21935: ARRAY
21936: PPUSH
21937: CALL_OW 2
21941: ST_TO_ADDR
21942: GO 21885
21944: POP
21945: POP
// if not tmp then
21946: LD_VAR 0 5
21950: NOT
21951: IFFALSE 21955
// exit ;
21953: GO 22060
// for j in tmp do
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 5
21964: PUSH
21965: FOR_IN
21966: IFFALSE 22058
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21968: LD_ADDR_VAR 0 6
21972: PUSH
21973: LD_INT 22
21975: PUSH
21976: LD_VAR 0 3
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: PPUSH
21985: CALL_OW 69
21989: ST_TO_ADDR
// if not un then
21990: LD_VAR 0 6
21994: NOT
21995: IFFALSE 21999
// continue ;
21997: GO 21965
// nation := GetNation ( un [ 1 ] ) ;
21999: LD_ADDR_VAR 0 4
22003: PUSH
22004: LD_VAR 0 6
22008: PUSH
22009: LD_INT 1
22011: ARRAY
22012: PPUSH
22013: CALL_OW 248
22017: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
22018: LD_ADDR_EXP 77
22022: PUSH
22023: LD_EXP 77
22027: PPUSH
22028: LD_VAR 0 3
22032: PPUSH
22033: LD_VAR 0 3
22037: PPUSH
22038: LD_VAR 0 4
22042: PPUSH
22043: LD_INT 1
22045: PPUSH
22046: CALL 49269 0 3
22050: PPUSH
22051: CALL_OW 1
22055: ST_TO_ADDR
// end ;
22056: GO 21965
22058: POP
22059: POP
// end ;
22060: LD_VAR 0 1
22064: RET
// export function MC_InitSides ( ) ; var i ; begin
22065: LD_INT 0
22067: PPUSH
22068: PPUSH
// if not mc_bases then
22069: LD_EXP 50
22073: NOT
22074: IFFALSE 22078
// exit ;
22076: GO 22152
// for i = 1 to mc_bases do
22078: LD_ADDR_VAR 0 2
22082: PUSH
22083: DOUBLE
22084: LD_INT 1
22086: DEC
22087: ST_TO_ADDR
22088: LD_EXP 50
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22150
// if mc_bases [ i ] then
22096: LD_EXP 50
22100: PUSH
22101: LD_VAR 0 2
22105: ARRAY
22106: IFFALSE 22148
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22108: LD_ADDR_EXP 76
22112: PUSH
22113: LD_EXP 76
22117: PPUSH
22118: LD_VAR 0 2
22122: PPUSH
22123: LD_EXP 50
22127: PUSH
22128: LD_VAR 0 2
22132: ARRAY
22133: PUSH
22134: LD_INT 1
22136: ARRAY
22137: PPUSH
22138: CALL_OW 255
22142: PPUSH
22143: CALL_OW 1
22147: ST_TO_ADDR
22148: GO 22093
22150: POP
22151: POP
// end ;
22152: LD_VAR 0 1
22156: RET
// every 0 0$03 trigger skirmish do
22157: LD_EXP 48
22161: IFFALSE 22315
22163: GO 22165
22165: DISABLE
// begin enable ;
22166: ENABLE
// MC_CheckBuildings ( ) ;
22167: CALL 26827 0 0
// MC_CheckPeopleLife ( ) ;
22171: CALL 26988 0 0
// RaiseSailEvent ( 100 ) ;
22175: LD_INT 100
22177: PPUSH
22178: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22182: LD_INT 103
22184: PPUSH
22185: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22189: LD_INT 104
22191: PPUSH
22192: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22196: LD_INT 105
22198: PPUSH
22199: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22203: LD_INT 106
22205: PPUSH
22206: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22210: LD_INT 107
22212: PPUSH
22213: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22217: LD_INT 108
22219: PPUSH
22220: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22224: LD_INT 109
22226: PPUSH
22227: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22231: LD_INT 110
22233: PPUSH
22234: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22238: LD_INT 111
22240: PPUSH
22241: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22245: LD_INT 112
22247: PPUSH
22248: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22252: LD_INT 113
22254: PPUSH
22255: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22259: LD_INT 120
22261: PPUSH
22262: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22266: LD_INT 121
22268: PPUSH
22269: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22273: LD_INT 122
22275: PPUSH
22276: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22280: LD_INT 123
22282: PPUSH
22283: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22287: LD_INT 124
22289: PPUSH
22290: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22294: LD_INT 125
22296: PPUSH
22297: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22301: LD_INT 126
22303: PPUSH
22304: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22308: LD_INT 200
22310: PPUSH
22311: CALL_OW 427
// end ;
22315: END
// on SailEvent ( event ) do begin if event < 100 then
22316: LD_VAR 0 1
22320: PUSH
22321: LD_INT 100
22323: LESS
22324: IFFALSE 22335
// CustomEvent ( event ) ;
22326: LD_VAR 0 1
22330: PPUSH
22331: CALL 17478 0 1
// if event = 100 then
22335: LD_VAR 0 1
22339: PUSH
22340: LD_INT 100
22342: EQUAL
22343: IFFALSE 22349
// MC_ClassManager ( ) ;
22345: CALL 22741 0 0
// if event = 101 then
22349: LD_VAR 0 1
22353: PUSH
22354: LD_INT 101
22356: EQUAL
22357: IFFALSE 22363
// MC_RepairBuildings ( ) ;
22359: CALL 27573 0 0
// if event = 102 then
22363: LD_VAR 0 1
22367: PUSH
22368: LD_INT 102
22370: EQUAL
22371: IFFALSE 22377
// MC_Heal ( ) ;
22373: CALL 28508 0 0
// if event = 103 then
22377: LD_VAR 0 1
22381: PUSH
22382: LD_INT 103
22384: EQUAL
22385: IFFALSE 22391
// MC_Build ( ) ;
22387: CALL 28930 0 0
// if event = 104 then
22391: LD_VAR 0 1
22395: PUSH
22396: LD_INT 104
22398: EQUAL
22399: IFFALSE 22405
// MC_TurretWeapon ( ) ;
22401: CALL 30564 0 0
// if event = 105 then
22405: LD_VAR 0 1
22409: PUSH
22410: LD_INT 105
22412: EQUAL
22413: IFFALSE 22419
// MC_BuildUpgrade ( ) ;
22415: CALL 30115 0 0
// if event = 106 then
22419: LD_VAR 0 1
22423: PUSH
22424: LD_INT 106
22426: EQUAL
22427: IFFALSE 22433
// MC_PlantMines ( ) ;
22429: CALL 30994 0 0
// if event = 107 then
22433: LD_VAR 0 1
22437: PUSH
22438: LD_INT 107
22440: EQUAL
22441: IFFALSE 22447
// MC_CollectCrates ( ) ;
22443: CALL 31792 0 0
// if event = 108 then
22447: LD_VAR 0 1
22451: PUSH
22452: LD_INT 108
22454: EQUAL
22455: IFFALSE 22461
// MC_LinkRemoteControl ( ) ;
22457: CALL 33642 0 0
// if event = 109 then
22461: LD_VAR 0 1
22465: PUSH
22466: LD_INT 109
22468: EQUAL
22469: IFFALSE 22475
// MC_ProduceVehicle ( ) ;
22471: CALL 33823 0 0
// if event = 110 then
22475: LD_VAR 0 1
22479: PUSH
22480: LD_INT 110
22482: EQUAL
22483: IFFALSE 22489
// MC_SendAttack ( ) ;
22485: CALL 34289 0 0
// if event = 111 then
22489: LD_VAR 0 1
22493: PUSH
22494: LD_INT 111
22496: EQUAL
22497: IFFALSE 22503
// MC_Defend ( ) ;
22499: CALL 34397 0 0
// if event = 112 then
22503: LD_VAR 0 1
22507: PUSH
22508: LD_INT 112
22510: EQUAL
22511: IFFALSE 22517
// MC_Research ( ) ;
22513: CALL 35277 0 0
// if event = 113 then
22517: LD_VAR 0 1
22521: PUSH
22522: LD_INT 113
22524: EQUAL
22525: IFFALSE 22531
// MC_MinesTrigger ( ) ;
22527: CALL 36391 0 0
// if event = 120 then
22531: LD_VAR 0 1
22535: PUSH
22536: LD_INT 120
22538: EQUAL
22539: IFFALSE 22545
// MC_RepairVehicle ( ) ;
22541: CALL 36490 0 0
// if event = 121 then
22545: LD_VAR 0 1
22549: PUSH
22550: LD_INT 121
22552: EQUAL
22553: IFFALSE 22559
// MC_TameApe ( ) ;
22555: CALL 37259 0 0
// if event = 122 then
22559: LD_VAR 0 1
22563: PUSH
22564: LD_INT 122
22566: EQUAL
22567: IFFALSE 22573
// MC_ChangeApeClass ( ) ;
22569: CALL 38088 0 0
// if event = 123 then
22573: LD_VAR 0 1
22577: PUSH
22578: LD_INT 123
22580: EQUAL
22581: IFFALSE 22587
// MC_Bazooka ( ) ;
22583: CALL 38738 0 0
// if event = 124 then
22587: LD_VAR 0 1
22591: PUSH
22592: LD_INT 124
22594: EQUAL
22595: IFFALSE 22601
// MC_TeleportExit ( ) ;
22597: CALL 38936 0 0
// if event = 125 then
22601: LD_VAR 0 1
22605: PUSH
22606: LD_INT 125
22608: EQUAL
22609: IFFALSE 22615
// MC_Deposits ( ) ;
22611: CALL 39583 0 0
// if event = 126 then
22615: LD_VAR 0 1
22619: PUSH
22620: LD_INT 126
22622: EQUAL
22623: IFFALSE 22629
// MC_RemoteDriver ( ) ;
22625: CALL 40208 0 0
// if event = 200 then
22629: LD_VAR 0 1
22633: PUSH
22634: LD_INT 200
22636: EQUAL
22637: IFFALSE 22643
// MC_Idle ( ) ;
22639: CALL 42115 0 0
// end ;
22643: PPOPN 1
22645: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22646: LD_INT 0
22648: PPUSH
22649: PPUSH
// if not mc_bases [ base ] or not tag then
22650: LD_EXP 50
22654: PUSH
22655: LD_VAR 0 1
22659: ARRAY
22660: NOT
22661: PUSH
22662: LD_VAR 0 2
22666: NOT
22667: OR
22668: IFFALSE 22672
// exit ;
22670: GO 22736
// for i in mc_bases [ base ] union mc_ape [ base ] do
22672: LD_ADDR_VAR 0 4
22676: PUSH
22677: LD_EXP 50
22681: PUSH
22682: LD_VAR 0 1
22686: ARRAY
22687: PUSH
22688: LD_EXP 79
22692: PUSH
22693: LD_VAR 0 1
22697: ARRAY
22698: UNION
22699: PUSH
22700: FOR_IN
22701: IFFALSE 22734
// if GetTag ( i ) = tag then
22703: LD_VAR 0 4
22707: PPUSH
22708: CALL_OW 110
22712: PUSH
22713: LD_VAR 0 2
22717: EQUAL
22718: IFFALSE 22732
// SetTag ( i , 0 ) ;
22720: LD_VAR 0 4
22724: PPUSH
22725: LD_INT 0
22727: PPUSH
22728: CALL_OW 109
22732: GO 22700
22734: POP
22735: POP
// end ;
22736: LD_VAR 0 3
22740: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22741: LD_INT 0
22743: PPUSH
22744: PPUSH
22745: PPUSH
22746: PPUSH
22747: PPUSH
22748: PPUSH
22749: PPUSH
22750: PPUSH
// if not mc_bases then
22751: LD_EXP 50
22755: NOT
22756: IFFALSE 22760
// exit ;
22758: GO 23209
// for i = 1 to mc_bases do
22760: LD_ADDR_VAR 0 2
22764: PUSH
22765: DOUBLE
22766: LD_INT 1
22768: DEC
22769: ST_TO_ADDR
22770: LD_EXP 50
22774: PUSH
22775: FOR_TO
22776: IFFALSE 23207
// begin tmp := MC_ClassCheckReq ( i ) ;
22778: LD_ADDR_VAR 0 4
22782: PUSH
22783: LD_VAR 0 2
22787: PPUSH
22788: CALL 23214 0 1
22792: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22793: LD_ADDR_EXP 91
22797: PUSH
22798: LD_EXP 91
22802: PPUSH
22803: LD_VAR 0 2
22807: PPUSH
22808: LD_VAR 0 4
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22818: LD_ADDR_VAR 0 6
22822: PUSH
22823: LD_EXP 50
22827: PUSH
22828: LD_VAR 0 2
22832: ARRAY
22833: PPUSH
22834: LD_INT 2
22836: PUSH
22837: LD_INT 30
22839: PUSH
22840: LD_INT 4
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 30
22849: PUSH
22850: LD_INT 5
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: PPUSH
22862: CALL_OW 72
22866: PUSH
22867: LD_EXP 50
22871: PUSH
22872: LD_VAR 0 2
22876: ARRAY
22877: PPUSH
22878: LD_INT 2
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 0
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 1
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: PPUSH
22906: CALL_OW 72
22910: PUSH
22911: LD_EXP 50
22915: PUSH
22916: LD_VAR 0 2
22920: ARRAY
22921: PPUSH
22922: LD_INT 30
22924: PUSH
22925: LD_INT 3
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 72
22936: PUSH
22937: LD_EXP 50
22941: PUSH
22942: LD_VAR 0 2
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: LD_INT 6
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 7
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 30
22973: PUSH
22974: LD_INT 8
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: LIST
22986: PPUSH
22987: CALL_OW 72
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: LIST
22996: LIST
22997: ST_TO_ADDR
// for j := 1 to 4 do
22998: LD_ADDR_VAR 0 3
23002: PUSH
23003: DOUBLE
23004: LD_INT 1
23006: DEC
23007: ST_TO_ADDR
23008: LD_INT 4
23010: PUSH
23011: FOR_TO
23012: IFFALSE 23203
// begin if not tmp [ j ] then
23014: LD_VAR 0 4
23018: PUSH
23019: LD_VAR 0 3
23023: ARRAY
23024: NOT
23025: IFFALSE 23029
// continue ;
23027: GO 23011
// for p in tmp [ j ] do
23029: LD_ADDR_VAR 0 5
23033: PUSH
23034: LD_VAR 0 4
23038: PUSH
23039: LD_VAR 0 3
23043: ARRAY
23044: PUSH
23045: FOR_IN
23046: IFFALSE 23199
// begin if not b [ j ] then
23048: LD_VAR 0 6
23052: PUSH
23053: LD_VAR 0 3
23057: ARRAY
23058: NOT
23059: IFFALSE 23063
// break ;
23061: GO 23199
// e := 0 ;
23063: LD_ADDR_VAR 0 7
23067: PUSH
23068: LD_INT 0
23070: ST_TO_ADDR
// for k in b [ j ] do
23071: LD_ADDR_VAR 0 8
23075: PUSH
23076: LD_VAR 0 6
23080: PUSH
23081: LD_VAR 0 3
23085: ARRAY
23086: PUSH
23087: FOR_IN
23088: IFFALSE 23115
// if IsNotFull ( k ) then
23090: LD_VAR 0 8
23094: PPUSH
23095: CALL 51390 0 1
23099: IFFALSE 23113
// begin e := k ;
23101: LD_ADDR_VAR 0 7
23105: PUSH
23106: LD_VAR 0 8
23110: ST_TO_ADDR
// break ;
23111: GO 23115
// end ;
23113: GO 23087
23115: POP
23116: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23117: LD_VAR 0 7
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 7
23131: PPUSH
23132: CALL 85549 0 2
23136: NOT
23137: AND
23138: IFFALSE 23197
// begin if IsInUnit ( p ) then
23140: LD_VAR 0 5
23144: PPUSH
23145: CALL_OW 310
23149: IFFALSE 23160
// ComExitBuilding ( p ) ;
23151: LD_VAR 0 5
23155: PPUSH
23156: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23160: LD_VAR 0 5
23164: PPUSH
23165: LD_VAR 0 7
23169: PPUSH
23170: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23174: LD_VAR 0 5
23178: PPUSH
23179: LD_VAR 0 3
23183: PPUSH
23184: CALL_OW 183
// AddComExitBuilding ( p ) ;
23188: LD_VAR 0 5
23192: PPUSH
23193: CALL_OW 182
// end ; end ;
23197: GO 23045
23199: POP
23200: POP
// end ;
23201: GO 23011
23203: POP
23204: POP
// end ;
23205: GO 22775
23207: POP
23208: POP
// end ;
23209: LD_VAR 0 1
23213: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23214: LD_INT 0
23216: PPUSH
23217: PPUSH
23218: PPUSH
23219: PPUSH
23220: PPUSH
23221: PPUSH
23222: PPUSH
23223: PPUSH
23224: PPUSH
23225: PPUSH
23226: PPUSH
23227: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23228: LD_ADDR_VAR 0 2
23232: PUSH
23233: LD_INT 0
23235: PUSH
23236: LD_INT 0
23238: PUSH
23239: LD_INT 0
23241: PUSH
23242: LD_INT 0
23244: PUSH
23245: EMPTY
23246: LIST
23247: LIST
23248: LIST
23249: LIST
23250: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23251: LD_VAR 0 1
23255: NOT
23256: PUSH
23257: LD_EXP 50
23261: PUSH
23262: LD_VAR 0 1
23266: ARRAY
23267: NOT
23268: OR
23269: PUSH
23270: LD_EXP 50
23274: PUSH
23275: LD_VAR 0 1
23279: ARRAY
23280: PPUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 30
23286: PUSH
23287: LD_INT 0
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 30
23296: PUSH
23297: LD_INT 1
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: LIST
23308: PPUSH
23309: CALL_OW 72
23313: NOT
23314: OR
23315: IFFALSE 23319
// exit ;
23317: GO 26822
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23319: LD_ADDR_VAR 0 4
23323: PUSH
23324: LD_EXP 50
23328: PUSH
23329: LD_VAR 0 1
23333: ARRAY
23334: PPUSH
23335: LD_INT 2
23337: PUSH
23338: LD_INT 25
23340: PUSH
23341: LD_INT 1
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 25
23350: PUSH
23351: LD_INT 2
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 25
23360: PUSH
23361: LD_INT 3
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: LD_INT 25
23370: PUSH
23371: LD_INT 4
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: LD_INT 25
23380: PUSH
23381: LD_INT 5
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: PUSH
23388: LD_INT 25
23390: PUSH
23391: LD_INT 8
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: PUSH
23398: LD_INT 25
23400: PUSH
23401: LD_INT 9
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: ST_TO_ADDR
// if not tmp then
23423: LD_VAR 0 4
23427: NOT
23428: IFFALSE 23432
// exit ;
23430: GO 26822
// for i in tmp do
23432: LD_ADDR_VAR 0 3
23436: PUSH
23437: LD_VAR 0 4
23441: PUSH
23442: FOR_IN
23443: IFFALSE 23474
// if GetTag ( i ) then
23445: LD_VAR 0 3
23449: PPUSH
23450: CALL_OW 110
23454: IFFALSE 23472
// tmp := tmp diff i ;
23456: LD_ADDR_VAR 0 4
23460: PUSH
23461: LD_VAR 0 4
23465: PUSH
23466: LD_VAR 0 3
23470: DIFF
23471: ST_TO_ADDR
23472: GO 23442
23474: POP
23475: POP
// if not tmp then
23476: LD_VAR 0 4
23480: NOT
23481: IFFALSE 23485
// exit ;
23483: GO 26822
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23485: LD_ADDR_VAR 0 5
23489: PUSH
23490: LD_EXP 50
23494: PUSH
23495: LD_VAR 0 1
23499: ARRAY
23500: PPUSH
23501: LD_INT 2
23503: PUSH
23504: LD_INT 25
23506: PUSH
23507: LD_INT 1
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: PUSH
23514: LD_INT 25
23516: PUSH
23517: LD_INT 5
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: PUSH
23524: LD_INT 25
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 25
23536: PUSH
23537: LD_INT 9
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: PPUSH
23551: CALL_OW 72
23555: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23556: LD_ADDR_VAR 0 6
23560: PUSH
23561: LD_EXP 50
23565: PUSH
23566: LD_VAR 0 1
23570: ARRAY
23571: PPUSH
23572: LD_INT 25
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PPUSH
23582: CALL_OW 72
23586: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23587: LD_ADDR_VAR 0 7
23591: PUSH
23592: LD_EXP 50
23596: PUSH
23597: LD_VAR 0 1
23601: ARRAY
23602: PPUSH
23603: LD_INT 25
23605: PUSH
23606: LD_INT 3
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: PPUSH
23613: CALL_OW 72
23617: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23618: LD_ADDR_VAR 0 8
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 25
23636: PUSH
23637: LD_INT 4
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: PUSH
23644: LD_INT 24
23646: PUSH
23647: LD_INT 251
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: ST_TO_ADDR
// if mc_is_defending [ base ] then
23663: LD_EXP 93
23667: PUSH
23668: LD_VAR 0 1
23672: ARRAY
23673: IFFALSE 24134
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23675: LD_ADDR_EXP 92
23679: PUSH
23680: LD_EXP 92
23684: PPUSH
23685: LD_VAR 0 1
23689: PPUSH
23690: LD_INT 4
23692: PPUSH
23693: CALL_OW 1
23697: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23698: LD_ADDR_VAR 0 12
23702: PUSH
23703: LD_EXP 50
23707: PUSH
23708: LD_VAR 0 1
23712: ARRAY
23713: PPUSH
23714: LD_INT 2
23716: PUSH
23717: LD_INT 30
23719: PUSH
23720: LD_INT 4
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PUSH
23727: LD_INT 30
23729: PUSH
23730: LD_INT 5
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: LIST
23741: PPUSH
23742: CALL_OW 72
23746: ST_TO_ADDR
// if not b then
23747: LD_VAR 0 12
23751: NOT
23752: IFFALSE 23756
// exit ;
23754: GO 26822
// p := [ ] ;
23756: LD_ADDR_VAR 0 11
23760: PUSH
23761: EMPTY
23762: ST_TO_ADDR
// if sci >= 2 then
23763: LD_VAR 0 8
23767: PUSH
23768: LD_INT 2
23770: GREATEREQUAL
23771: IFFALSE 23802
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23773: LD_ADDR_VAR 0 8
23777: PUSH
23778: LD_VAR 0 8
23782: PUSH
23783: LD_INT 1
23785: ARRAY
23786: PUSH
23787: LD_VAR 0 8
23791: PUSH
23792: LD_INT 2
23794: ARRAY
23795: PUSH
23796: EMPTY
23797: LIST
23798: LIST
23799: ST_TO_ADDR
23800: GO 23863
// if sci = 1 then
23802: LD_VAR 0 8
23806: PUSH
23807: LD_INT 1
23809: EQUAL
23810: IFFALSE 23831
// sci := [ sci [ 1 ] ] else
23812: LD_ADDR_VAR 0 8
23816: PUSH
23817: LD_VAR 0 8
23821: PUSH
23822: LD_INT 1
23824: ARRAY
23825: PUSH
23826: EMPTY
23827: LIST
23828: ST_TO_ADDR
23829: GO 23863
// if sci = 0 then
23831: LD_VAR 0 8
23835: PUSH
23836: LD_INT 0
23838: EQUAL
23839: IFFALSE 23863
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23841: LD_ADDR_VAR 0 11
23845: PUSH
23846: LD_VAR 0 4
23850: PPUSH
23851: LD_INT 4
23853: PPUSH
23854: CALL 85421 0 2
23858: PUSH
23859: LD_INT 1
23861: ARRAY
23862: ST_TO_ADDR
// if eng > 4 then
23863: LD_VAR 0 6
23867: PUSH
23868: LD_INT 4
23870: GREATER
23871: IFFALSE 23917
// for i = eng downto 4 do
23873: LD_ADDR_VAR 0 3
23877: PUSH
23878: DOUBLE
23879: LD_VAR 0 6
23883: INC
23884: ST_TO_ADDR
23885: LD_INT 4
23887: PUSH
23888: FOR_DOWNTO
23889: IFFALSE 23915
// eng := eng diff eng [ i ] ;
23891: LD_ADDR_VAR 0 6
23895: PUSH
23896: LD_VAR 0 6
23900: PUSH
23901: LD_VAR 0 6
23905: PUSH
23906: LD_VAR 0 3
23910: ARRAY
23911: DIFF
23912: ST_TO_ADDR
23913: GO 23888
23915: POP
23916: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23917: LD_ADDR_VAR 0 4
23921: PUSH
23922: LD_VAR 0 4
23926: PUSH
23927: LD_VAR 0 5
23931: PUSH
23932: LD_VAR 0 6
23936: UNION
23937: PUSH
23938: LD_VAR 0 7
23942: UNION
23943: PUSH
23944: LD_VAR 0 8
23948: UNION
23949: DIFF
23950: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23951: LD_ADDR_VAR 0 13
23955: PUSH
23956: LD_EXP 50
23960: PUSH
23961: LD_VAR 0 1
23965: ARRAY
23966: PPUSH
23967: LD_INT 2
23969: PUSH
23970: LD_INT 30
23972: PUSH
23973: LD_INT 32
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: LD_INT 30
23982: PUSH
23983: LD_INT 31
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: LIST
23994: PPUSH
23995: CALL_OW 72
23999: PUSH
24000: LD_EXP 50
24004: PUSH
24005: LD_VAR 0 1
24009: ARRAY
24010: PPUSH
24011: LD_INT 2
24013: PUSH
24014: LD_INT 30
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: LD_INT 30
24026: PUSH
24027: LD_INT 5
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: PPUSH
24039: CALL_OW 72
24043: PUSH
24044: LD_INT 6
24046: MUL
24047: PLUS
24048: ST_TO_ADDR
// if bcount < tmp then
24049: LD_VAR 0 13
24053: PUSH
24054: LD_VAR 0 4
24058: LESS
24059: IFFALSE 24105
// for i = tmp downto bcount do
24061: LD_ADDR_VAR 0 3
24065: PUSH
24066: DOUBLE
24067: LD_VAR 0 4
24071: INC
24072: ST_TO_ADDR
24073: LD_VAR 0 13
24077: PUSH
24078: FOR_DOWNTO
24079: IFFALSE 24103
// tmp := Delete ( tmp , tmp ) ;
24081: LD_ADDR_VAR 0 4
24085: PUSH
24086: LD_VAR 0 4
24090: PPUSH
24091: LD_VAR 0 4
24095: PPUSH
24096: CALL_OW 3
24100: ST_TO_ADDR
24101: GO 24078
24103: POP
24104: POP
// result := [ tmp , 0 , 0 , p ] ;
24105: LD_ADDR_VAR 0 2
24109: PUSH
24110: LD_VAR 0 4
24114: PUSH
24115: LD_INT 0
24117: PUSH
24118: LD_INT 0
24120: PUSH
24121: LD_VAR 0 11
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: ST_TO_ADDR
// exit ;
24132: GO 26822
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24134: LD_EXP 50
24138: PUSH
24139: LD_VAR 0 1
24143: ARRAY
24144: PPUSH
24145: LD_INT 2
24147: PUSH
24148: LD_INT 30
24150: PUSH
24151: LD_INT 6
24153: PUSH
24154: EMPTY
24155: LIST
24156: LIST
24157: PUSH
24158: LD_INT 30
24160: PUSH
24161: LD_INT 7
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: PUSH
24168: LD_INT 30
24170: PUSH
24171: LD_INT 8
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: LIST
24182: LIST
24183: PPUSH
24184: CALL_OW 72
24188: NOT
24189: PUSH
24190: LD_EXP 50
24194: PUSH
24195: LD_VAR 0 1
24199: ARRAY
24200: PPUSH
24201: LD_INT 30
24203: PUSH
24204: LD_INT 3
24206: PUSH
24207: EMPTY
24208: LIST
24209: LIST
24210: PPUSH
24211: CALL_OW 72
24215: NOT
24216: AND
24217: IFFALSE 24289
// begin if eng = tmp then
24219: LD_VAR 0 6
24223: PUSH
24224: LD_VAR 0 4
24228: EQUAL
24229: IFFALSE 24233
// exit ;
24231: GO 26822
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24233: LD_ADDR_EXP 92
24237: PUSH
24238: LD_EXP 92
24242: PPUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_INT 1
24250: PPUSH
24251: CALL_OW 1
24255: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24256: LD_ADDR_VAR 0 2
24260: PUSH
24261: LD_INT 0
24263: PUSH
24264: LD_VAR 0 4
24268: PUSH
24269: LD_VAR 0 6
24273: DIFF
24274: PUSH
24275: LD_INT 0
24277: PUSH
24278: LD_INT 0
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: ST_TO_ADDR
// exit ;
24287: GO 26822
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24289: LD_EXP 77
24293: PUSH
24294: LD_EXP 76
24298: PUSH
24299: LD_VAR 0 1
24303: ARRAY
24304: ARRAY
24305: PUSH
24306: LD_EXP 50
24310: PUSH
24311: LD_VAR 0 1
24315: ARRAY
24316: PPUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 30
24322: PUSH
24323: LD_INT 6
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: PUSH
24330: LD_INT 30
24332: PUSH
24333: LD_INT 7
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PUSH
24340: LD_INT 30
24342: PUSH
24343: LD_INT 8
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: PPUSH
24356: CALL_OW 72
24360: AND
24361: PUSH
24362: LD_EXP 50
24366: PUSH
24367: LD_VAR 0 1
24371: ARRAY
24372: PPUSH
24373: LD_INT 30
24375: PUSH
24376: LD_INT 3
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PPUSH
24383: CALL_OW 72
24387: NOT
24388: AND
24389: IFFALSE 24603
// begin if sci >= 6 then
24391: LD_VAR 0 8
24395: PUSH
24396: LD_INT 6
24398: GREATEREQUAL
24399: IFFALSE 24403
// exit ;
24401: GO 26822
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24403: LD_ADDR_EXP 92
24407: PUSH
24408: LD_EXP 92
24412: PPUSH
24413: LD_VAR 0 1
24417: PPUSH
24418: LD_INT 2
24420: PPUSH
24421: CALL_OW 1
24425: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24426: LD_ADDR_VAR 0 9
24430: PUSH
24431: LD_VAR 0 4
24435: PUSH
24436: LD_VAR 0 8
24440: DIFF
24441: PPUSH
24442: LD_INT 4
24444: PPUSH
24445: CALL 85421 0 2
24449: ST_TO_ADDR
// p := [ ] ;
24450: LD_ADDR_VAR 0 11
24454: PUSH
24455: EMPTY
24456: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24457: LD_VAR 0 8
24461: PUSH
24462: LD_INT 6
24464: LESS
24465: PUSH
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 6
24473: GREATER
24474: AND
24475: IFFALSE 24556
// begin for i = 1 to 6 - sci do
24477: LD_ADDR_VAR 0 3
24481: PUSH
24482: DOUBLE
24483: LD_INT 1
24485: DEC
24486: ST_TO_ADDR
24487: LD_INT 6
24489: PUSH
24490: LD_VAR 0 8
24494: MINUS
24495: PUSH
24496: FOR_TO
24497: IFFALSE 24552
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24499: LD_ADDR_VAR 0 11
24503: PUSH
24504: LD_VAR 0 11
24508: PPUSH
24509: LD_VAR 0 11
24513: PUSH
24514: LD_INT 1
24516: PLUS
24517: PPUSH
24518: LD_VAR 0 9
24522: PUSH
24523: LD_INT 1
24525: ARRAY
24526: PPUSH
24527: CALL_OW 2
24531: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24532: LD_ADDR_VAR 0 9
24536: PUSH
24537: LD_VAR 0 9
24541: PPUSH
24542: LD_INT 1
24544: PPUSH
24545: CALL_OW 3
24549: ST_TO_ADDR
// end ;
24550: GO 24496
24552: POP
24553: POP
// end else
24554: GO 24576
// if sort then
24556: LD_VAR 0 9
24560: IFFALSE 24576
// p := sort [ 1 ] ;
24562: LD_ADDR_VAR 0 11
24566: PUSH
24567: LD_VAR 0 9
24571: PUSH
24572: LD_INT 1
24574: ARRAY
24575: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24576: LD_ADDR_VAR 0 2
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: LD_INT 0
24586: PUSH
24587: LD_INT 0
24589: PUSH
24590: LD_VAR 0 11
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: LIST
24599: LIST
24600: ST_TO_ADDR
// exit ;
24601: GO 26822
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24603: LD_EXP 77
24607: PUSH
24608: LD_EXP 76
24612: PUSH
24613: LD_VAR 0 1
24617: ARRAY
24618: ARRAY
24619: PUSH
24620: LD_EXP 50
24624: PUSH
24625: LD_VAR 0 1
24629: ARRAY
24630: PPUSH
24631: LD_INT 2
24633: PUSH
24634: LD_INT 30
24636: PUSH
24637: LD_INT 6
24639: PUSH
24640: EMPTY
24641: LIST
24642: LIST
24643: PUSH
24644: LD_INT 30
24646: PUSH
24647: LD_INT 7
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 30
24656: PUSH
24657: LD_INT 8
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: PPUSH
24670: CALL_OW 72
24674: AND
24675: PUSH
24676: LD_EXP 50
24680: PUSH
24681: LD_VAR 0 1
24685: ARRAY
24686: PPUSH
24687: LD_INT 30
24689: PUSH
24690: LD_INT 3
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PPUSH
24697: CALL_OW 72
24701: AND
24702: IFFALSE 25436
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24704: LD_ADDR_EXP 92
24708: PUSH
24709: LD_EXP 92
24713: PPUSH
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_INT 3
24721: PPUSH
24722: CALL_OW 1
24726: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24727: LD_ADDR_VAR 0 2
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: LD_INT 0
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: LD_INT 0
24743: PUSH
24744: EMPTY
24745: LIST
24746: LIST
24747: LIST
24748: LIST
24749: ST_TO_ADDR
// if not eng then
24750: LD_VAR 0 6
24754: NOT
24755: IFFALSE 24818
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24757: LD_ADDR_VAR 0 11
24761: PUSH
24762: LD_VAR 0 4
24766: PPUSH
24767: LD_INT 2
24769: PPUSH
24770: CALL 85421 0 2
24774: PUSH
24775: LD_INT 1
24777: ARRAY
24778: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24779: LD_ADDR_VAR 0 2
24783: PUSH
24784: LD_VAR 0 2
24788: PPUSH
24789: LD_INT 2
24791: PPUSH
24792: LD_VAR 0 11
24796: PPUSH
24797: CALL_OW 1
24801: ST_TO_ADDR
// tmp := tmp diff p ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 4
24811: PUSH
24812: LD_VAR 0 11
24816: DIFF
24817: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24818: LD_VAR 0 4
24822: PUSH
24823: LD_VAR 0 8
24827: PUSH
24828: LD_INT 6
24830: LESS
24831: AND
24832: IFFALSE 25020
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24834: LD_ADDR_VAR 0 9
24838: PUSH
24839: LD_VAR 0 4
24843: PUSH
24844: LD_VAR 0 8
24848: PUSH
24849: LD_VAR 0 7
24853: UNION
24854: DIFF
24855: PPUSH
24856: LD_INT 4
24858: PPUSH
24859: CALL 85421 0 2
24863: ST_TO_ADDR
// p := [ ] ;
24864: LD_ADDR_VAR 0 11
24868: PUSH
24869: EMPTY
24870: ST_TO_ADDR
// if sort then
24871: LD_VAR 0 9
24875: IFFALSE 24991
// for i = 1 to 6 - sci do
24877: LD_ADDR_VAR 0 3
24881: PUSH
24882: DOUBLE
24883: LD_INT 1
24885: DEC
24886: ST_TO_ADDR
24887: LD_INT 6
24889: PUSH
24890: LD_VAR 0 8
24894: MINUS
24895: PUSH
24896: FOR_TO
24897: IFFALSE 24989
// begin if i = sort then
24899: LD_VAR 0 3
24903: PUSH
24904: LD_VAR 0 9
24908: EQUAL
24909: IFFALSE 24913
// break ;
24911: GO 24989
// if GetClass ( i ) = 4 then
24913: LD_VAR 0 3
24917: PPUSH
24918: CALL_OW 257
24922: PUSH
24923: LD_INT 4
24925: EQUAL
24926: IFFALSE 24930
// continue ;
24928: GO 24896
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24930: LD_ADDR_VAR 0 11
24934: PUSH
24935: LD_VAR 0 11
24939: PPUSH
24940: LD_VAR 0 11
24944: PUSH
24945: LD_INT 1
24947: PLUS
24948: PPUSH
24949: LD_VAR 0 9
24953: PUSH
24954: LD_VAR 0 3
24958: ARRAY
24959: PPUSH
24960: CALL_OW 2
24964: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24965: LD_ADDR_VAR 0 4
24969: PUSH
24970: LD_VAR 0 4
24974: PUSH
24975: LD_VAR 0 9
24979: PUSH
24980: LD_VAR 0 3
24984: ARRAY
24985: DIFF
24986: ST_TO_ADDR
// end ;
24987: GO 24896
24989: POP
24990: POP
// if p then
24991: LD_VAR 0 11
24995: IFFALSE 25020
// result := Replace ( result , 4 , p ) ;
24997: LD_ADDR_VAR 0 2
25001: PUSH
25002: LD_VAR 0 2
25006: PPUSH
25007: LD_INT 4
25009: PPUSH
25010: LD_VAR 0 11
25014: PPUSH
25015: CALL_OW 1
25019: ST_TO_ADDR
// end ; if tmp and mech < 6 then
25020: LD_VAR 0 4
25024: PUSH
25025: LD_VAR 0 7
25029: PUSH
25030: LD_INT 6
25032: LESS
25033: AND
25034: IFFALSE 25222
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25036: LD_ADDR_VAR 0 9
25040: PUSH
25041: LD_VAR 0 4
25045: PUSH
25046: LD_VAR 0 8
25050: PUSH
25051: LD_VAR 0 7
25055: UNION
25056: DIFF
25057: PPUSH
25058: LD_INT 3
25060: PPUSH
25061: CALL 85421 0 2
25065: ST_TO_ADDR
// p := [ ] ;
25066: LD_ADDR_VAR 0 11
25070: PUSH
25071: EMPTY
25072: ST_TO_ADDR
// if sort then
25073: LD_VAR 0 9
25077: IFFALSE 25193
// for i = 1 to 6 - mech do
25079: LD_ADDR_VAR 0 3
25083: PUSH
25084: DOUBLE
25085: LD_INT 1
25087: DEC
25088: ST_TO_ADDR
25089: LD_INT 6
25091: PUSH
25092: LD_VAR 0 7
25096: MINUS
25097: PUSH
25098: FOR_TO
25099: IFFALSE 25191
// begin if i = sort then
25101: LD_VAR 0 3
25105: PUSH
25106: LD_VAR 0 9
25110: EQUAL
25111: IFFALSE 25115
// break ;
25113: GO 25191
// if GetClass ( i ) = 3 then
25115: LD_VAR 0 3
25119: PPUSH
25120: CALL_OW 257
25124: PUSH
25125: LD_INT 3
25127: EQUAL
25128: IFFALSE 25132
// continue ;
25130: GO 25098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25132: LD_ADDR_VAR 0 11
25136: PUSH
25137: LD_VAR 0 11
25141: PPUSH
25142: LD_VAR 0 11
25146: PUSH
25147: LD_INT 1
25149: PLUS
25150: PPUSH
25151: LD_VAR 0 9
25155: PUSH
25156: LD_VAR 0 3
25160: ARRAY
25161: PPUSH
25162: CALL_OW 2
25166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25167: LD_ADDR_VAR 0 4
25171: PUSH
25172: LD_VAR 0 4
25176: PUSH
25177: LD_VAR 0 9
25181: PUSH
25182: LD_VAR 0 3
25186: ARRAY
25187: DIFF
25188: ST_TO_ADDR
// end ;
25189: GO 25098
25191: POP
25192: POP
// if p then
25193: LD_VAR 0 11
25197: IFFALSE 25222
// result := Replace ( result , 3 , p ) ;
25199: LD_ADDR_VAR 0 2
25203: PUSH
25204: LD_VAR 0 2
25208: PPUSH
25209: LD_INT 3
25211: PPUSH
25212: LD_VAR 0 11
25216: PPUSH
25217: CALL_OW 1
25221: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25222: LD_VAR 0 4
25226: PUSH
25227: LD_INT 6
25229: GREATER
25230: PUSH
25231: LD_VAR 0 6
25235: PUSH
25236: LD_INT 6
25238: LESS
25239: AND
25240: IFFALSE 25434
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25242: LD_ADDR_VAR 0 9
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 8
25256: PUSH
25257: LD_VAR 0 7
25261: UNION
25262: PUSH
25263: LD_VAR 0 6
25267: UNION
25268: DIFF
25269: PPUSH
25270: LD_INT 2
25272: PPUSH
25273: CALL 85421 0 2
25277: ST_TO_ADDR
// p := [ ] ;
25278: LD_ADDR_VAR 0 11
25282: PUSH
25283: EMPTY
25284: ST_TO_ADDR
// if sort then
25285: LD_VAR 0 9
25289: IFFALSE 25405
// for i = 1 to 6 - eng do
25291: LD_ADDR_VAR 0 3
25295: PUSH
25296: DOUBLE
25297: LD_INT 1
25299: DEC
25300: ST_TO_ADDR
25301: LD_INT 6
25303: PUSH
25304: LD_VAR 0 6
25308: MINUS
25309: PUSH
25310: FOR_TO
25311: IFFALSE 25403
// begin if i = sort then
25313: LD_VAR 0 3
25317: PUSH
25318: LD_VAR 0 9
25322: EQUAL
25323: IFFALSE 25327
// break ;
25325: GO 25403
// if GetClass ( i ) = 2 then
25327: LD_VAR 0 3
25331: PPUSH
25332: CALL_OW 257
25336: PUSH
25337: LD_INT 2
25339: EQUAL
25340: IFFALSE 25344
// continue ;
25342: GO 25310
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25344: LD_ADDR_VAR 0 11
25348: PUSH
25349: LD_VAR 0 11
25353: PPUSH
25354: LD_VAR 0 11
25358: PUSH
25359: LD_INT 1
25361: PLUS
25362: PPUSH
25363: LD_VAR 0 9
25367: PUSH
25368: LD_VAR 0 3
25372: ARRAY
25373: PPUSH
25374: CALL_OW 2
25378: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25379: LD_ADDR_VAR 0 4
25383: PUSH
25384: LD_VAR 0 4
25388: PUSH
25389: LD_VAR 0 9
25393: PUSH
25394: LD_VAR 0 3
25398: ARRAY
25399: DIFF
25400: ST_TO_ADDR
// end ;
25401: GO 25310
25403: POP
25404: POP
// if p then
25405: LD_VAR 0 11
25409: IFFALSE 25434
// result := Replace ( result , 2 , p ) ;
25411: LD_ADDR_VAR 0 2
25415: PUSH
25416: LD_VAR 0 2
25420: PPUSH
25421: LD_INT 2
25423: PPUSH
25424: LD_VAR 0 11
25428: PPUSH
25429: CALL_OW 1
25433: ST_TO_ADDR
// end ; exit ;
25434: GO 26822
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25436: LD_EXP 77
25440: PUSH
25441: LD_EXP 76
25445: PUSH
25446: LD_VAR 0 1
25450: ARRAY
25451: ARRAY
25452: NOT
25453: PUSH
25454: LD_EXP 50
25458: PUSH
25459: LD_VAR 0 1
25463: ARRAY
25464: PPUSH
25465: LD_INT 30
25467: PUSH
25468: LD_INT 3
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PPUSH
25475: CALL_OW 72
25479: AND
25480: PUSH
25481: LD_EXP 55
25485: PUSH
25486: LD_VAR 0 1
25490: ARRAY
25491: AND
25492: IFFALSE 26100
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25494: LD_ADDR_EXP 92
25498: PUSH
25499: LD_EXP 92
25503: PPUSH
25504: LD_VAR 0 1
25508: PPUSH
25509: LD_INT 5
25511: PPUSH
25512: CALL_OW 1
25516: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25517: LD_ADDR_VAR 0 2
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 0
25527: PUSH
25528: LD_INT 0
25530: PUSH
25531: LD_INT 0
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: LIST
25538: LIST
25539: ST_TO_ADDR
// if sci > 1 then
25540: LD_VAR 0 8
25544: PUSH
25545: LD_INT 1
25547: GREATER
25548: IFFALSE 25576
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25550: LD_ADDR_VAR 0 4
25554: PUSH
25555: LD_VAR 0 4
25559: PUSH
25560: LD_VAR 0 8
25564: PUSH
25565: LD_VAR 0 8
25569: PUSH
25570: LD_INT 1
25572: ARRAY
25573: DIFF
25574: DIFF
25575: ST_TO_ADDR
// if tmp and not sci then
25576: LD_VAR 0 4
25580: PUSH
25581: LD_VAR 0 8
25585: NOT
25586: AND
25587: IFFALSE 25656
// begin sort := SortBySkill ( tmp , 4 ) ;
25589: LD_ADDR_VAR 0 9
25593: PUSH
25594: LD_VAR 0 4
25598: PPUSH
25599: LD_INT 4
25601: PPUSH
25602: CALL 85421 0 2
25606: ST_TO_ADDR
// if sort then
25607: LD_VAR 0 9
25611: IFFALSE 25627
// p := sort [ 1 ] ;
25613: LD_ADDR_VAR 0 11
25617: PUSH
25618: LD_VAR 0 9
25622: PUSH
25623: LD_INT 1
25625: ARRAY
25626: ST_TO_ADDR
// if p then
25627: LD_VAR 0 11
25631: IFFALSE 25656
// result := Replace ( result , 4 , p ) ;
25633: LD_ADDR_VAR 0 2
25637: PUSH
25638: LD_VAR 0 2
25642: PPUSH
25643: LD_INT 4
25645: PPUSH
25646: LD_VAR 0 11
25650: PPUSH
25651: CALL_OW 1
25655: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25656: LD_ADDR_VAR 0 4
25660: PUSH
25661: LD_VAR 0 4
25665: PUSH
25666: LD_VAR 0 7
25670: DIFF
25671: ST_TO_ADDR
// if tmp and mech < 6 then
25672: LD_VAR 0 4
25676: PUSH
25677: LD_VAR 0 7
25681: PUSH
25682: LD_INT 6
25684: LESS
25685: AND
25686: IFFALSE 25874
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25688: LD_ADDR_VAR 0 9
25692: PUSH
25693: LD_VAR 0 4
25697: PUSH
25698: LD_VAR 0 8
25702: PUSH
25703: LD_VAR 0 7
25707: UNION
25708: DIFF
25709: PPUSH
25710: LD_INT 3
25712: PPUSH
25713: CALL 85421 0 2
25717: ST_TO_ADDR
// p := [ ] ;
25718: LD_ADDR_VAR 0 11
25722: PUSH
25723: EMPTY
25724: ST_TO_ADDR
// if sort then
25725: LD_VAR 0 9
25729: IFFALSE 25845
// for i = 1 to 6 - mech do
25731: LD_ADDR_VAR 0 3
25735: PUSH
25736: DOUBLE
25737: LD_INT 1
25739: DEC
25740: ST_TO_ADDR
25741: LD_INT 6
25743: PUSH
25744: LD_VAR 0 7
25748: MINUS
25749: PUSH
25750: FOR_TO
25751: IFFALSE 25843
// begin if i = sort then
25753: LD_VAR 0 3
25757: PUSH
25758: LD_VAR 0 9
25762: EQUAL
25763: IFFALSE 25767
// break ;
25765: GO 25843
// if GetClass ( i ) = 3 then
25767: LD_VAR 0 3
25771: PPUSH
25772: CALL_OW 257
25776: PUSH
25777: LD_INT 3
25779: EQUAL
25780: IFFALSE 25784
// continue ;
25782: GO 25750
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25784: LD_ADDR_VAR 0 11
25788: PUSH
25789: LD_VAR 0 11
25793: PPUSH
25794: LD_VAR 0 11
25798: PUSH
25799: LD_INT 1
25801: PLUS
25802: PPUSH
25803: LD_VAR 0 9
25807: PUSH
25808: LD_VAR 0 3
25812: ARRAY
25813: PPUSH
25814: CALL_OW 2
25818: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25819: LD_ADDR_VAR 0 4
25823: PUSH
25824: LD_VAR 0 4
25828: PUSH
25829: LD_VAR 0 9
25833: PUSH
25834: LD_VAR 0 3
25838: ARRAY
25839: DIFF
25840: ST_TO_ADDR
// end ;
25841: GO 25750
25843: POP
25844: POP
// if p then
25845: LD_VAR 0 11
25849: IFFALSE 25874
// result := Replace ( result , 3 , p ) ;
25851: LD_ADDR_VAR 0 2
25855: PUSH
25856: LD_VAR 0 2
25860: PPUSH
25861: LD_INT 3
25863: PPUSH
25864: LD_VAR 0 11
25868: PPUSH
25869: CALL_OW 1
25873: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25874: LD_ADDR_VAR 0 4
25878: PUSH
25879: LD_VAR 0 4
25883: PUSH
25884: LD_VAR 0 6
25888: DIFF
25889: ST_TO_ADDR
// if tmp and eng < 6 then
25890: LD_VAR 0 4
25894: PUSH
25895: LD_VAR 0 6
25899: PUSH
25900: LD_INT 6
25902: LESS
25903: AND
25904: IFFALSE 26098
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25906: LD_ADDR_VAR 0 9
25910: PUSH
25911: LD_VAR 0 4
25915: PUSH
25916: LD_VAR 0 8
25920: PUSH
25921: LD_VAR 0 7
25925: UNION
25926: PUSH
25927: LD_VAR 0 6
25931: UNION
25932: DIFF
25933: PPUSH
25934: LD_INT 2
25936: PPUSH
25937: CALL 85421 0 2
25941: ST_TO_ADDR
// p := [ ] ;
25942: LD_ADDR_VAR 0 11
25946: PUSH
25947: EMPTY
25948: ST_TO_ADDR
// if sort then
25949: LD_VAR 0 9
25953: IFFALSE 26069
// for i = 1 to 6 - eng do
25955: LD_ADDR_VAR 0 3
25959: PUSH
25960: DOUBLE
25961: LD_INT 1
25963: DEC
25964: ST_TO_ADDR
25965: LD_INT 6
25967: PUSH
25968: LD_VAR 0 6
25972: MINUS
25973: PUSH
25974: FOR_TO
25975: IFFALSE 26067
// begin if i = sort then
25977: LD_VAR 0 3
25981: PUSH
25982: LD_VAR 0 9
25986: EQUAL
25987: IFFALSE 25991
// break ;
25989: GO 26067
// if GetClass ( i ) = 2 then
25991: LD_VAR 0 3
25995: PPUSH
25996: CALL_OW 257
26000: PUSH
26001: LD_INT 2
26003: EQUAL
26004: IFFALSE 26008
// continue ;
26006: GO 25974
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26008: LD_ADDR_VAR 0 11
26012: PUSH
26013: LD_VAR 0 11
26017: PPUSH
26018: LD_VAR 0 11
26022: PUSH
26023: LD_INT 1
26025: PLUS
26026: PPUSH
26027: LD_VAR 0 9
26031: PUSH
26032: LD_VAR 0 3
26036: ARRAY
26037: PPUSH
26038: CALL_OW 2
26042: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26043: LD_ADDR_VAR 0 4
26047: PUSH
26048: LD_VAR 0 4
26052: PUSH
26053: LD_VAR 0 9
26057: PUSH
26058: LD_VAR 0 3
26062: ARRAY
26063: DIFF
26064: ST_TO_ADDR
// end ;
26065: GO 25974
26067: POP
26068: POP
// if p then
26069: LD_VAR 0 11
26073: IFFALSE 26098
// result := Replace ( result , 2 , p ) ;
26075: LD_ADDR_VAR 0 2
26079: PUSH
26080: LD_VAR 0 2
26084: PPUSH
26085: LD_INT 2
26087: PPUSH
26088: LD_VAR 0 11
26092: PPUSH
26093: CALL_OW 1
26097: ST_TO_ADDR
// end ; exit ;
26098: GO 26822
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26100: LD_EXP 77
26104: PUSH
26105: LD_EXP 76
26109: PUSH
26110: LD_VAR 0 1
26114: ARRAY
26115: ARRAY
26116: NOT
26117: PUSH
26118: LD_EXP 50
26122: PUSH
26123: LD_VAR 0 1
26127: ARRAY
26128: PPUSH
26129: LD_INT 30
26131: PUSH
26132: LD_INT 3
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PPUSH
26139: CALL_OW 72
26143: AND
26144: PUSH
26145: LD_EXP 55
26149: PUSH
26150: LD_VAR 0 1
26154: ARRAY
26155: NOT
26156: AND
26157: IFFALSE 26822
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26159: LD_ADDR_EXP 92
26163: PUSH
26164: LD_EXP 92
26168: PPUSH
26169: LD_VAR 0 1
26173: PPUSH
26174: LD_INT 6
26176: PPUSH
26177: CALL_OW 1
26181: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26182: LD_ADDR_VAR 0 2
26186: PUSH
26187: LD_INT 0
26189: PUSH
26190: LD_INT 0
26192: PUSH
26193: LD_INT 0
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: ST_TO_ADDR
// if sci >= 1 then
26205: LD_VAR 0 8
26209: PUSH
26210: LD_INT 1
26212: GREATEREQUAL
26213: IFFALSE 26235
// tmp := tmp diff sci [ 1 ] ;
26215: LD_ADDR_VAR 0 4
26219: PUSH
26220: LD_VAR 0 4
26224: PUSH
26225: LD_VAR 0 8
26229: PUSH
26230: LD_INT 1
26232: ARRAY
26233: DIFF
26234: ST_TO_ADDR
// if tmp and not sci then
26235: LD_VAR 0 4
26239: PUSH
26240: LD_VAR 0 8
26244: NOT
26245: AND
26246: IFFALSE 26315
// begin sort := SortBySkill ( tmp , 4 ) ;
26248: LD_ADDR_VAR 0 9
26252: PUSH
26253: LD_VAR 0 4
26257: PPUSH
26258: LD_INT 4
26260: PPUSH
26261: CALL 85421 0 2
26265: ST_TO_ADDR
// if sort then
26266: LD_VAR 0 9
26270: IFFALSE 26286
// p := sort [ 1 ] ;
26272: LD_ADDR_VAR 0 11
26276: PUSH
26277: LD_VAR 0 9
26281: PUSH
26282: LD_INT 1
26284: ARRAY
26285: ST_TO_ADDR
// if p then
26286: LD_VAR 0 11
26290: IFFALSE 26315
// result := Replace ( result , 4 , p ) ;
26292: LD_ADDR_VAR 0 2
26296: PUSH
26297: LD_VAR 0 2
26301: PPUSH
26302: LD_INT 4
26304: PPUSH
26305: LD_VAR 0 11
26309: PPUSH
26310: CALL_OW 1
26314: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26315: LD_ADDR_VAR 0 4
26319: PUSH
26320: LD_VAR 0 4
26324: PUSH
26325: LD_VAR 0 7
26329: DIFF
26330: ST_TO_ADDR
// if tmp and mech < 6 then
26331: LD_VAR 0 4
26335: PUSH
26336: LD_VAR 0 7
26340: PUSH
26341: LD_INT 6
26343: LESS
26344: AND
26345: IFFALSE 26527
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26347: LD_ADDR_VAR 0 9
26351: PUSH
26352: LD_VAR 0 4
26356: PUSH
26357: LD_VAR 0 7
26361: DIFF
26362: PPUSH
26363: LD_INT 3
26365: PPUSH
26366: CALL 85421 0 2
26370: ST_TO_ADDR
// p := [ ] ;
26371: LD_ADDR_VAR 0 11
26375: PUSH
26376: EMPTY
26377: ST_TO_ADDR
// if sort then
26378: LD_VAR 0 9
26382: IFFALSE 26498
// for i = 1 to 6 - mech do
26384: LD_ADDR_VAR 0 3
26388: PUSH
26389: DOUBLE
26390: LD_INT 1
26392: DEC
26393: ST_TO_ADDR
26394: LD_INT 6
26396: PUSH
26397: LD_VAR 0 7
26401: MINUS
26402: PUSH
26403: FOR_TO
26404: IFFALSE 26496
// begin if i = sort then
26406: LD_VAR 0 3
26410: PUSH
26411: LD_VAR 0 9
26415: EQUAL
26416: IFFALSE 26420
// break ;
26418: GO 26496
// if GetClass ( i ) = 3 then
26420: LD_VAR 0 3
26424: PPUSH
26425: CALL_OW 257
26429: PUSH
26430: LD_INT 3
26432: EQUAL
26433: IFFALSE 26437
// continue ;
26435: GO 26403
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26437: LD_ADDR_VAR 0 11
26441: PUSH
26442: LD_VAR 0 11
26446: PPUSH
26447: LD_VAR 0 11
26451: PUSH
26452: LD_INT 1
26454: PLUS
26455: PPUSH
26456: LD_VAR 0 9
26460: PUSH
26461: LD_VAR 0 3
26465: ARRAY
26466: PPUSH
26467: CALL_OW 2
26471: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26472: LD_ADDR_VAR 0 4
26476: PUSH
26477: LD_VAR 0 4
26481: PUSH
26482: LD_VAR 0 9
26486: PUSH
26487: LD_VAR 0 3
26491: ARRAY
26492: DIFF
26493: ST_TO_ADDR
// end ;
26494: GO 26403
26496: POP
26497: POP
// if p then
26498: LD_VAR 0 11
26502: IFFALSE 26527
// result := Replace ( result , 3 , p ) ;
26504: LD_ADDR_VAR 0 2
26508: PUSH
26509: LD_VAR 0 2
26513: PPUSH
26514: LD_INT 3
26516: PPUSH
26517: LD_VAR 0 11
26521: PPUSH
26522: CALL_OW 1
26526: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26527: LD_ADDR_VAR 0 4
26531: PUSH
26532: LD_VAR 0 4
26536: PUSH
26537: LD_VAR 0 6
26541: DIFF
26542: ST_TO_ADDR
// if tmp and eng < 4 then
26543: LD_VAR 0 4
26547: PUSH
26548: LD_VAR 0 6
26552: PUSH
26553: LD_INT 4
26555: LESS
26556: AND
26557: IFFALSE 26747
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26559: LD_ADDR_VAR 0 9
26563: PUSH
26564: LD_VAR 0 4
26568: PUSH
26569: LD_VAR 0 7
26573: PUSH
26574: LD_VAR 0 6
26578: UNION
26579: DIFF
26580: PPUSH
26581: LD_INT 2
26583: PPUSH
26584: CALL 85421 0 2
26588: ST_TO_ADDR
// p := [ ] ;
26589: LD_ADDR_VAR 0 11
26593: PUSH
26594: EMPTY
26595: ST_TO_ADDR
// if sort then
26596: LD_VAR 0 9
26600: IFFALSE 26716
// for i = 1 to 4 - eng do
26602: LD_ADDR_VAR 0 3
26606: PUSH
26607: DOUBLE
26608: LD_INT 1
26610: DEC
26611: ST_TO_ADDR
26612: LD_INT 4
26614: PUSH
26615: LD_VAR 0 6
26619: MINUS
26620: PUSH
26621: FOR_TO
26622: IFFALSE 26714
// begin if i = sort then
26624: LD_VAR 0 3
26628: PUSH
26629: LD_VAR 0 9
26633: EQUAL
26634: IFFALSE 26638
// break ;
26636: GO 26714
// if GetClass ( i ) = 2 then
26638: LD_VAR 0 3
26642: PPUSH
26643: CALL_OW 257
26647: PUSH
26648: LD_INT 2
26650: EQUAL
26651: IFFALSE 26655
// continue ;
26653: GO 26621
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26655: LD_ADDR_VAR 0 11
26659: PUSH
26660: LD_VAR 0 11
26664: PPUSH
26665: LD_VAR 0 11
26669: PUSH
26670: LD_INT 1
26672: PLUS
26673: PPUSH
26674: LD_VAR 0 9
26678: PUSH
26679: LD_VAR 0 3
26683: ARRAY
26684: PPUSH
26685: CALL_OW 2
26689: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26690: LD_ADDR_VAR 0 4
26694: PUSH
26695: LD_VAR 0 4
26699: PUSH
26700: LD_VAR 0 9
26704: PUSH
26705: LD_VAR 0 3
26709: ARRAY
26710: DIFF
26711: ST_TO_ADDR
// end ;
26712: GO 26621
26714: POP
26715: POP
// if p then
26716: LD_VAR 0 11
26720: IFFALSE 26745
// result := Replace ( result , 2 , p ) ;
26722: LD_ADDR_VAR 0 2
26726: PUSH
26727: LD_VAR 0 2
26731: PPUSH
26732: LD_INT 2
26734: PPUSH
26735: LD_VAR 0 11
26739: PPUSH
26740: CALL_OW 1
26744: ST_TO_ADDR
// end else
26745: GO 26791
// for i = eng downto 5 do
26747: LD_ADDR_VAR 0 3
26751: PUSH
26752: DOUBLE
26753: LD_VAR 0 6
26757: INC
26758: ST_TO_ADDR
26759: LD_INT 5
26761: PUSH
26762: FOR_DOWNTO
26763: IFFALSE 26789
// tmp := tmp union eng [ i ] ;
26765: LD_ADDR_VAR 0 4
26769: PUSH
26770: LD_VAR 0 4
26774: PUSH
26775: LD_VAR 0 6
26779: PUSH
26780: LD_VAR 0 3
26784: ARRAY
26785: UNION
26786: ST_TO_ADDR
26787: GO 26762
26789: POP
26790: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26791: LD_ADDR_VAR 0 2
26795: PUSH
26796: LD_VAR 0 2
26800: PPUSH
26801: LD_INT 1
26803: PPUSH
26804: LD_VAR 0 4
26808: PUSH
26809: LD_VAR 0 5
26813: DIFF
26814: PPUSH
26815: CALL_OW 1
26819: ST_TO_ADDR
// exit ;
26820: GO 26822
// end ; end ;
26822: LD_VAR 0 2
26826: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26827: LD_INT 0
26829: PPUSH
26830: PPUSH
26831: PPUSH
// if not mc_bases then
26832: LD_EXP 50
26836: NOT
26837: IFFALSE 26841
// exit ;
26839: GO 26983
// for i = 1 to mc_bases do
26841: LD_ADDR_VAR 0 2
26845: PUSH
26846: DOUBLE
26847: LD_INT 1
26849: DEC
26850: ST_TO_ADDR
26851: LD_EXP 50
26855: PUSH
26856: FOR_TO
26857: IFFALSE 26974
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26859: LD_ADDR_VAR 0 3
26863: PUSH
26864: LD_EXP 50
26868: PUSH
26869: LD_VAR 0 2
26873: ARRAY
26874: PPUSH
26875: LD_INT 21
26877: PUSH
26878: LD_INT 3
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 3
26887: PUSH
26888: LD_INT 2
26890: PUSH
26891: LD_INT 30
26893: PUSH
26894: LD_INT 29
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 30
26903: PUSH
26904: LD_INT 30
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 3
26922: PUSH
26923: LD_INT 24
26925: PUSH
26926: LD_INT 1000
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: LIST
26941: PPUSH
26942: CALL_OW 72
26946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26947: LD_ADDR_EXP 51
26951: PUSH
26952: LD_EXP 51
26956: PPUSH
26957: LD_VAR 0 2
26961: PPUSH
26962: LD_VAR 0 3
26966: PPUSH
26967: CALL_OW 1
26971: ST_TO_ADDR
// end ;
26972: GO 26856
26974: POP
26975: POP
// RaiseSailEvent ( 101 ) ;
26976: LD_INT 101
26978: PPUSH
26979: CALL_OW 427
// end ;
26983: LD_VAR 0 1
26987: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26988: LD_INT 0
26990: PPUSH
26991: PPUSH
26992: PPUSH
26993: PPUSH
26994: PPUSH
26995: PPUSH
26996: PPUSH
// if not mc_bases then
26997: LD_EXP 50
27001: NOT
27002: IFFALSE 27006
// exit ;
27004: GO 27568
// for i = 1 to mc_bases do
27006: LD_ADDR_VAR 0 2
27010: PUSH
27011: DOUBLE
27012: LD_INT 1
27014: DEC
27015: ST_TO_ADDR
27016: LD_EXP 50
27020: PUSH
27021: FOR_TO
27022: IFFALSE 27559
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
27024: LD_ADDR_VAR 0 5
27028: PUSH
27029: LD_EXP 50
27033: PUSH
27034: LD_VAR 0 2
27038: ARRAY
27039: PUSH
27040: LD_EXP 79
27044: PUSH
27045: LD_VAR 0 2
27049: ARRAY
27050: UNION
27051: PPUSH
27052: LD_INT 21
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: LD_INT 3
27067: PUSH
27068: LD_INT 54
27070: PUSH
27071: EMPTY
27072: LIST
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 3
27080: PUSH
27081: LD_INT 24
27083: PUSH
27084: LD_INT 1000
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: LIST
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PPUSH
27104: CALL_OW 72
27108: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27109: LD_ADDR_VAR 0 6
27113: PUSH
27114: LD_EXP 50
27118: PUSH
27119: LD_VAR 0 2
27123: ARRAY
27124: PPUSH
27125: LD_INT 21
27127: PUSH
27128: LD_INT 1
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: LD_INT 1
27137: PUSH
27138: LD_INT 3
27140: PUSH
27141: LD_INT 54
27143: PUSH
27144: EMPTY
27145: LIST
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 3
27153: PUSH
27154: LD_INT 24
27156: PUSH
27157: LD_INT 250
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: LIST
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PPUSH
27177: CALL_OW 72
27181: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27182: LD_ADDR_VAR 0 7
27186: PUSH
27187: LD_VAR 0 5
27191: PUSH
27192: LD_VAR 0 6
27196: DIFF
27197: ST_TO_ADDR
// if not need_heal_1 then
27198: LD_VAR 0 6
27202: NOT
27203: IFFALSE 27236
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27205: LD_ADDR_EXP 53
27209: PUSH
27210: LD_EXP 53
27214: PPUSH
27215: LD_VAR 0 2
27219: PUSH
27220: LD_INT 1
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PPUSH
27227: EMPTY
27228: PPUSH
27229: CALL 54168 0 3
27233: ST_TO_ADDR
27234: GO 27306
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27236: LD_ADDR_EXP 53
27240: PUSH
27241: LD_EXP 53
27245: PPUSH
27246: LD_VAR 0 2
27250: PUSH
27251: LD_INT 1
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PPUSH
27258: LD_EXP 53
27262: PUSH
27263: LD_VAR 0 2
27267: ARRAY
27268: PUSH
27269: LD_INT 1
27271: ARRAY
27272: PPUSH
27273: LD_INT 3
27275: PUSH
27276: LD_INT 24
27278: PUSH
27279: LD_INT 1000
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PPUSH
27290: CALL_OW 72
27294: PUSH
27295: LD_VAR 0 6
27299: UNION
27300: PPUSH
27301: CALL 54168 0 3
27305: ST_TO_ADDR
// if not need_heal_2 then
27306: LD_VAR 0 7
27310: NOT
27311: IFFALSE 27344
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27313: LD_ADDR_EXP 53
27317: PUSH
27318: LD_EXP 53
27322: PPUSH
27323: LD_VAR 0 2
27327: PUSH
27328: LD_INT 2
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PPUSH
27335: EMPTY
27336: PPUSH
27337: CALL 54168 0 3
27341: ST_TO_ADDR
27342: GO 27376
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27344: LD_ADDR_EXP 53
27348: PUSH
27349: LD_EXP 53
27353: PPUSH
27354: LD_VAR 0 2
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PPUSH
27366: LD_VAR 0 7
27370: PPUSH
27371: CALL 54168 0 3
27375: ST_TO_ADDR
// if need_heal_2 then
27376: LD_VAR 0 7
27380: IFFALSE 27541
// for j in need_heal_2 do
27382: LD_ADDR_VAR 0 3
27386: PUSH
27387: LD_VAR 0 7
27391: PUSH
27392: FOR_IN
27393: IFFALSE 27539
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27395: LD_ADDR_VAR 0 5
27399: PUSH
27400: LD_EXP 50
27404: PUSH
27405: LD_VAR 0 2
27409: ARRAY
27410: PPUSH
27411: LD_INT 2
27413: PUSH
27414: LD_INT 30
27416: PUSH
27417: LD_INT 6
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: LD_INT 30
27426: PUSH
27427: LD_INT 7
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: LD_INT 30
27436: PUSH
27437: LD_INT 8
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: PUSH
27444: LD_INT 30
27446: PUSH
27447: LD_INT 0
27449: PUSH
27450: EMPTY
27451: LIST
27452: LIST
27453: PUSH
27454: LD_INT 30
27456: PUSH
27457: LD_INT 1
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: PPUSH
27472: CALL_OW 72
27476: ST_TO_ADDR
// if tmp then
27477: LD_VAR 0 5
27481: IFFALSE 27537
// begin k := NearestUnitToUnit ( tmp , j ) ;
27483: LD_ADDR_VAR 0 4
27487: PUSH
27488: LD_VAR 0 5
27492: PPUSH
27493: LD_VAR 0 3
27497: PPUSH
27498: CALL_OW 74
27502: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27503: LD_VAR 0 3
27507: PPUSH
27508: LD_VAR 0 4
27512: PPUSH
27513: CALL_OW 296
27517: PUSH
27518: LD_INT 5
27520: GREATER
27521: IFFALSE 27537
// ComMoveToNearbyEntrance ( j , k ) ;
27523: LD_VAR 0 3
27527: PPUSH
27528: LD_VAR 0 4
27532: PPUSH
27533: CALL 87794 0 2
// end ; end ;
27537: GO 27392
27539: POP
27540: POP
// if not need_heal_1 and not need_heal_2 then
27541: LD_VAR 0 6
27545: NOT
27546: PUSH
27547: LD_VAR 0 7
27551: NOT
27552: AND
27553: IFFALSE 27557
// continue ;
27555: GO 27021
// end ;
27557: GO 27021
27559: POP
27560: POP
// RaiseSailEvent ( 102 ) ;
27561: LD_INT 102
27563: PPUSH
27564: CALL_OW 427
// end ;
27568: LD_VAR 0 1
27572: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27573: LD_INT 0
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
// if not mc_bases then
27583: LD_EXP 50
27587: NOT
27588: IFFALSE 27592
// exit ;
27590: GO 28503
// for i = 1 to mc_bases do
27592: LD_ADDR_VAR 0 2
27596: PUSH
27597: DOUBLE
27598: LD_INT 1
27600: DEC
27601: ST_TO_ADDR
27602: LD_EXP 50
27606: PUSH
27607: FOR_TO
27608: IFFALSE 28501
// begin if not mc_building_need_repair [ i ] then
27610: LD_EXP 51
27614: PUSH
27615: LD_VAR 0 2
27619: ARRAY
27620: NOT
27621: IFFALSE 27806
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27623: LD_ADDR_VAR 0 6
27627: PUSH
27628: LD_EXP 69
27632: PUSH
27633: LD_VAR 0 2
27637: ARRAY
27638: PPUSH
27639: LD_INT 3
27641: PUSH
27642: LD_INT 24
27644: PUSH
27645: LD_INT 1000
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: LD_INT 34
27661: PUSH
27662: LD_INT 13
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 34
27671: PUSH
27672: LD_INT 52
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 34
27681: PUSH
27682: LD_INT 88
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PPUSH
27699: CALL_OW 72
27703: ST_TO_ADDR
// if cranes then
27704: LD_VAR 0 6
27708: IFFALSE 27770
// for j in cranes do
27710: LD_ADDR_VAR 0 3
27714: PUSH
27715: LD_VAR 0 6
27719: PUSH
27720: FOR_IN
27721: IFFALSE 27768
// if not IsInArea ( j , mc_parking [ i ] ) then
27723: LD_VAR 0 3
27727: PPUSH
27728: LD_EXP 74
27732: PUSH
27733: LD_VAR 0 2
27737: ARRAY
27738: PPUSH
27739: CALL_OW 308
27743: NOT
27744: IFFALSE 27766
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27746: LD_VAR 0 3
27750: PPUSH
27751: LD_EXP 74
27755: PUSH
27756: LD_VAR 0 2
27760: ARRAY
27761: PPUSH
27762: CALL_OW 113
27766: GO 27720
27768: POP
27769: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27770: LD_ADDR_EXP 52
27774: PUSH
27775: LD_EXP 52
27779: PPUSH
27780: LD_VAR 0 2
27784: PPUSH
27785: EMPTY
27786: PPUSH
27787: CALL_OW 1
27791: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27792: LD_VAR 0 2
27796: PPUSH
27797: LD_INT 101
27799: PPUSH
27800: CALL 22646 0 2
// continue ;
27804: GO 27607
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27806: LD_ADDR_EXP 56
27810: PUSH
27811: LD_EXP 56
27815: PPUSH
27816: LD_VAR 0 2
27820: PPUSH
27821: EMPTY
27822: PPUSH
27823: CALL_OW 1
27827: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27828: LD_VAR 0 2
27832: PPUSH
27833: LD_INT 103
27835: PPUSH
27836: CALL 22646 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27840: LD_ADDR_VAR 0 5
27844: PUSH
27845: LD_EXP 50
27849: PUSH
27850: LD_VAR 0 2
27854: ARRAY
27855: PUSH
27856: LD_EXP 79
27860: PUSH
27861: LD_VAR 0 2
27865: ARRAY
27866: UNION
27867: PPUSH
27868: LD_INT 2
27870: PUSH
27871: LD_INT 25
27873: PUSH
27874: LD_INT 2
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 25
27883: PUSH
27884: LD_INT 16
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: LIST
27895: PUSH
27896: EMPTY
27897: LIST
27898: PPUSH
27899: CALL_OW 72
27903: ST_TO_ADDR
// if mc_need_heal [ i ] then
27904: LD_EXP 53
27908: PUSH
27909: LD_VAR 0 2
27913: ARRAY
27914: IFFALSE 27958
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27916: LD_ADDR_VAR 0 5
27920: PUSH
27921: LD_VAR 0 5
27925: PUSH
27926: LD_EXP 53
27930: PUSH
27931: LD_VAR 0 2
27935: ARRAY
27936: PUSH
27937: LD_INT 1
27939: ARRAY
27940: PUSH
27941: LD_EXP 53
27945: PUSH
27946: LD_VAR 0 2
27950: ARRAY
27951: PUSH
27952: LD_INT 2
27954: ARRAY
27955: UNION
27956: DIFF
27957: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27958: LD_ADDR_VAR 0 6
27962: PUSH
27963: LD_EXP 69
27967: PUSH
27968: LD_VAR 0 2
27972: ARRAY
27973: PPUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 34
27979: PUSH
27980: LD_INT 13
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 34
27989: PUSH
27990: LD_INT 52
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: PUSH
27997: LD_INT 34
27999: PUSH
28000: LD_INT 88
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: PPUSH
28013: CALL_OW 72
28017: ST_TO_ADDR
// if cranes then
28018: LD_VAR 0 6
28022: IFFALSE 28190
// begin for j in cranes do
28024: LD_ADDR_VAR 0 3
28028: PUSH
28029: LD_VAR 0 6
28033: PUSH
28034: FOR_IN
28035: IFFALSE 28188
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
28037: LD_VAR 0 3
28041: PPUSH
28042: CALL_OW 256
28046: PUSH
28047: LD_INT 1000
28049: EQUAL
28050: PUSH
28051: LD_VAR 0 3
28055: PPUSH
28056: CALL_OW 314
28060: NOT
28061: AND
28062: IFFALSE 28128
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
28064: LD_ADDR_VAR 0 8
28068: PUSH
28069: LD_EXP 51
28073: PUSH
28074: LD_VAR 0 2
28078: ARRAY
28079: PPUSH
28080: LD_VAR 0 3
28084: PPUSH
28085: CALL_OW 74
28089: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28090: LD_VAR 0 8
28094: PPUSH
28095: LD_INT 16
28097: PPUSH
28098: CALL 57133 0 2
28102: PUSH
28103: LD_INT 4
28105: ARRAY
28106: PUSH
28107: LD_INT 10
28109: LESS
28110: IFFALSE 28126
// ComRepairBuilding ( j , to_repair ) ;
28112: LD_VAR 0 3
28116: PPUSH
28117: LD_VAR 0 8
28121: PPUSH
28122: CALL_OW 130
// end else
28126: GO 28186
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28128: LD_VAR 0 3
28132: PPUSH
28133: CALL_OW 256
28137: PUSH
28138: LD_INT 500
28140: LESS
28141: PUSH
28142: LD_VAR 0 3
28146: PPUSH
28147: LD_EXP 74
28151: PUSH
28152: LD_VAR 0 2
28156: ARRAY
28157: PPUSH
28158: CALL_OW 308
28162: NOT
28163: AND
28164: IFFALSE 28186
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28166: LD_VAR 0 3
28170: PPUSH
28171: LD_EXP 74
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: PPUSH
28182: CALL_OW 113
// end ;
28186: GO 28034
28188: POP
28189: POP
// end ; if tmp > 3 then
28190: LD_VAR 0 5
28194: PUSH
28195: LD_INT 3
28197: GREATER
28198: IFFALSE 28218
// tmp := ShrinkArray ( tmp , 4 ) ;
28200: LD_ADDR_VAR 0 5
28204: PUSH
28205: LD_VAR 0 5
28209: PPUSH
28210: LD_INT 4
28212: PPUSH
28213: CALL 87232 0 2
28217: ST_TO_ADDR
// if not tmp then
28218: LD_VAR 0 5
28222: NOT
28223: IFFALSE 28227
// continue ;
28225: GO 27607
// for j in tmp do
28227: LD_ADDR_VAR 0 3
28231: PUSH
28232: LD_VAR 0 5
28236: PUSH
28237: FOR_IN
28238: IFFALSE 28497
// begin if IsInUnit ( j ) then
28240: LD_VAR 0 3
28244: PPUSH
28245: CALL_OW 310
28249: IFFALSE 28260
// ComExitBuilding ( j ) ;
28251: LD_VAR 0 3
28255: PPUSH
28256: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28260: LD_VAR 0 3
28264: PUSH
28265: LD_EXP 52
28269: PUSH
28270: LD_VAR 0 2
28274: ARRAY
28275: IN
28276: NOT
28277: IFFALSE 28335
// begin SetTag ( j , 101 ) ;
28279: LD_VAR 0 3
28283: PPUSH
28284: LD_INT 101
28286: PPUSH
28287: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28291: LD_ADDR_EXP 52
28295: PUSH
28296: LD_EXP 52
28300: PPUSH
28301: LD_VAR 0 2
28305: PUSH
28306: LD_EXP 52
28310: PUSH
28311: LD_VAR 0 2
28315: ARRAY
28316: PUSH
28317: LD_INT 1
28319: PLUS
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PPUSH
28325: LD_VAR 0 3
28329: PPUSH
28330: CALL 54168 0 3
28334: ST_TO_ADDR
// end ; wait ( 1 ) ;
28335: LD_INT 1
28337: PPUSH
28338: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28342: LD_ADDR_VAR 0 7
28346: PUSH
28347: LD_EXP 51
28351: PUSH
28352: LD_VAR 0 2
28356: ARRAY
28357: ST_TO_ADDR
// if mc_scan [ i ] then
28358: LD_EXP 73
28362: PUSH
28363: LD_VAR 0 2
28367: ARRAY
28368: IFFALSE 28430
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28370: LD_ADDR_VAR 0 7
28374: PUSH
28375: LD_EXP 51
28379: PUSH
28380: LD_VAR 0 2
28384: ARRAY
28385: PPUSH
28386: LD_INT 3
28388: PUSH
28389: LD_INT 30
28391: PUSH
28392: LD_INT 32
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 30
28401: PUSH
28402: LD_INT 33
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PUSH
28409: LD_INT 30
28411: PUSH
28412: LD_INT 31
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: PPUSH
28425: CALL_OW 72
28429: ST_TO_ADDR
// if not to_repair_tmp then
28430: LD_VAR 0 7
28434: NOT
28435: IFFALSE 28439
// continue ;
28437: GO 28237
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28439: LD_ADDR_VAR 0 8
28443: PUSH
28444: LD_VAR 0 7
28448: PPUSH
28449: LD_VAR 0 3
28453: PPUSH
28454: CALL_OW 74
28458: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28459: LD_VAR 0 8
28463: PPUSH
28464: LD_INT 16
28466: PPUSH
28467: CALL 57133 0 2
28471: PUSH
28472: LD_INT 4
28474: ARRAY
28475: PUSH
28476: LD_INT 14
28478: LESS
28479: IFFALSE 28495
// ComRepairBuilding ( j , to_repair ) ;
28481: LD_VAR 0 3
28485: PPUSH
28486: LD_VAR 0 8
28490: PPUSH
28491: CALL_OW 130
// end ;
28495: GO 28237
28497: POP
28498: POP
// end ;
28499: GO 27607
28501: POP
28502: POP
// end ;
28503: LD_VAR 0 1
28507: RET
// export function MC_Heal ; var i , j , tmp ; begin
28508: LD_INT 0
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
// if not mc_bases then
28514: LD_EXP 50
28518: NOT
28519: IFFALSE 28523
// exit ;
28521: GO 28925
// for i = 1 to mc_bases do
28523: LD_ADDR_VAR 0 2
28527: PUSH
28528: DOUBLE
28529: LD_INT 1
28531: DEC
28532: ST_TO_ADDR
28533: LD_EXP 50
28537: PUSH
28538: FOR_TO
28539: IFFALSE 28923
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28541: LD_EXP 53
28545: PUSH
28546: LD_VAR 0 2
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: NOT
28556: PUSH
28557: LD_EXP 53
28561: PUSH
28562: LD_VAR 0 2
28566: ARRAY
28567: PUSH
28568: LD_INT 2
28570: ARRAY
28571: NOT
28572: AND
28573: IFFALSE 28611
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28575: LD_ADDR_EXP 54
28579: PUSH
28580: LD_EXP 54
28584: PPUSH
28585: LD_VAR 0 2
28589: PPUSH
28590: EMPTY
28591: PPUSH
28592: CALL_OW 1
28596: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28597: LD_VAR 0 2
28601: PPUSH
28602: LD_INT 102
28604: PPUSH
28605: CALL 22646 0 2
// continue ;
28609: GO 28538
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28611: LD_ADDR_VAR 0 4
28615: PUSH
28616: LD_EXP 50
28620: PUSH
28621: LD_VAR 0 2
28625: ARRAY
28626: PPUSH
28627: LD_INT 25
28629: PUSH
28630: LD_INT 4
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PPUSH
28637: CALL_OW 72
28641: ST_TO_ADDR
// if not tmp then
28642: LD_VAR 0 4
28646: NOT
28647: IFFALSE 28651
// continue ;
28649: GO 28538
// if mc_taming [ i ] then
28651: LD_EXP 81
28655: PUSH
28656: LD_VAR 0 2
28660: ARRAY
28661: IFFALSE 28685
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28663: LD_ADDR_EXP 81
28667: PUSH
28668: LD_EXP 81
28672: PPUSH
28673: LD_VAR 0 2
28677: PPUSH
28678: EMPTY
28679: PPUSH
28680: CALL_OW 1
28684: ST_TO_ADDR
// for j in tmp do
28685: LD_ADDR_VAR 0 3
28689: PUSH
28690: LD_VAR 0 4
28694: PUSH
28695: FOR_IN
28696: IFFALSE 28919
// begin if IsInUnit ( j ) then
28698: LD_VAR 0 3
28702: PPUSH
28703: CALL_OW 310
28707: IFFALSE 28718
// ComExitBuilding ( j ) ;
28709: LD_VAR 0 3
28713: PPUSH
28714: CALL_OW 122
// if not j in mc_healers [ i ] then
28718: LD_VAR 0 3
28722: PUSH
28723: LD_EXP 54
28727: PUSH
28728: LD_VAR 0 2
28732: ARRAY
28733: IN
28734: NOT
28735: IFFALSE 28781
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28737: LD_ADDR_EXP 54
28741: PUSH
28742: LD_EXP 54
28746: PPUSH
28747: LD_VAR 0 2
28751: PUSH
28752: LD_EXP 54
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PUSH
28763: LD_INT 1
28765: PLUS
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PPUSH
28771: LD_VAR 0 3
28775: PPUSH
28776: CALL 54168 0 3
28780: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 110
28790: PUSH
28791: LD_INT 102
28793: NONEQUAL
28794: IFFALSE 28808
// SetTag ( j , 102 ) ;
28796: LD_VAR 0 3
28800: PPUSH
28801: LD_INT 102
28803: PPUSH
28804: CALL_OW 109
// Wait ( 3 ) ;
28808: LD_INT 3
28810: PPUSH
28811: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28815: LD_EXP 53
28819: PUSH
28820: LD_VAR 0 2
28824: ARRAY
28825: PUSH
28826: LD_INT 1
28828: ARRAY
28829: IFFALSE 28861
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28831: LD_VAR 0 3
28835: PPUSH
28836: LD_EXP 53
28840: PUSH
28841: LD_VAR 0 2
28845: ARRAY
28846: PUSH
28847: LD_INT 1
28849: ARRAY
28850: PUSH
28851: LD_INT 1
28853: ARRAY
28854: PPUSH
28855: CALL_OW 128
28859: GO 28917
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28861: LD_VAR 0 3
28865: PPUSH
28866: CALL_OW 314
28870: NOT
28871: PUSH
28872: LD_EXP 53
28876: PUSH
28877: LD_VAR 0 2
28881: ARRAY
28882: PUSH
28883: LD_INT 2
28885: ARRAY
28886: AND
28887: IFFALSE 28917
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28889: LD_VAR 0 3
28893: PPUSH
28894: LD_EXP 53
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PUSH
28905: LD_INT 2
28907: ARRAY
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: CALL_OW 128
// end ;
28917: GO 28695
28919: POP
28920: POP
// end ;
28921: GO 28538
28923: POP
28924: POP
// end ;
28925: LD_VAR 0 1
28929: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28930: LD_INT 0
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
// if not mc_bases then
28938: LD_EXP 50
28942: NOT
28943: IFFALSE 28947
// exit ;
28945: GO 30110
// for i = 1 to mc_bases do
28947: LD_ADDR_VAR 0 2
28951: PUSH
28952: DOUBLE
28953: LD_INT 1
28955: DEC
28956: ST_TO_ADDR
28957: LD_EXP 50
28961: PUSH
28962: FOR_TO
28963: IFFALSE 30108
// begin if mc_scan [ i ] then
28965: LD_EXP 73
28969: PUSH
28970: LD_VAR 0 2
28974: ARRAY
28975: IFFALSE 28979
// continue ;
28977: GO 28962
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28979: LD_EXP 55
28983: PUSH
28984: LD_VAR 0 2
28988: ARRAY
28989: NOT
28990: PUSH
28991: LD_EXP 57
28995: PUSH
28996: LD_VAR 0 2
29000: ARRAY
29001: NOT
29002: AND
29003: PUSH
29004: LD_EXP 56
29008: PUSH
29009: LD_VAR 0 2
29013: ARRAY
29014: AND
29015: IFFALSE 29053
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29017: LD_ADDR_EXP 56
29021: PUSH
29022: LD_EXP 56
29026: PPUSH
29027: LD_VAR 0 2
29031: PPUSH
29032: EMPTY
29033: PPUSH
29034: CALL_OW 1
29038: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29039: LD_VAR 0 2
29043: PPUSH
29044: LD_INT 103
29046: PPUSH
29047: CALL 22646 0 2
// continue ;
29051: GO 28962
// end ; if mc_construct_list [ i ] then
29053: LD_EXP 57
29057: PUSH
29058: LD_VAR 0 2
29062: ARRAY
29063: IFFALSE 29283
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29065: LD_ADDR_VAR 0 5
29069: PUSH
29070: LD_EXP 50
29074: PUSH
29075: LD_VAR 0 2
29079: ARRAY
29080: PPUSH
29081: LD_INT 25
29083: PUSH
29084: LD_INT 2
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PPUSH
29091: CALL_OW 72
29095: PUSH
29096: LD_EXP 52
29100: PUSH
29101: LD_VAR 0 2
29105: ARRAY
29106: DIFF
29107: ST_TO_ADDR
// if not tmp then
29108: LD_VAR 0 5
29112: NOT
29113: IFFALSE 29117
// continue ;
29115: GO 28962
// for j in tmp do
29117: LD_ADDR_VAR 0 3
29121: PUSH
29122: LD_VAR 0 5
29126: PUSH
29127: FOR_IN
29128: IFFALSE 29279
// begin if not mc_builders [ i ] then
29130: LD_EXP 56
29134: PUSH
29135: LD_VAR 0 2
29139: ARRAY
29140: NOT
29141: IFFALSE 29199
// begin SetTag ( j , 103 ) ;
29143: LD_VAR 0 3
29147: PPUSH
29148: LD_INT 103
29150: PPUSH
29151: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29155: LD_ADDR_EXP 56
29159: PUSH
29160: LD_EXP 56
29164: PPUSH
29165: LD_VAR 0 2
29169: PUSH
29170: LD_EXP 56
29174: PUSH
29175: LD_VAR 0 2
29179: ARRAY
29180: PUSH
29181: LD_INT 1
29183: PLUS
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PPUSH
29189: LD_VAR 0 3
29193: PPUSH
29194: CALL 54168 0 3
29198: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29199: LD_VAR 0 3
29203: PPUSH
29204: CALL_OW 310
29208: IFFALSE 29219
// ComExitBuilding ( j ) ;
29210: LD_VAR 0 3
29214: PPUSH
29215: CALL_OW 122
// wait ( 3 ) ;
29219: LD_INT 3
29221: PPUSH
29222: CALL_OW 67
// if not mc_construct_list [ i ] then
29226: LD_EXP 57
29230: PUSH
29231: LD_VAR 0 2
29235: ARRAY
29236: NOT
29237: IFFALSE 29241
// break ;
29239: GO 29279
// if not HasTask ( j ) then
29241: LD_VAR 0 3
29245: PPUSH
29246: CALL_OW 314
29250: NOT
29251: IFFALSE 29277
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29253: LD_VAR 0 3
29257: PPUSH
29258: LD_EXP 57
29262: PUSH
29263: LD_VAR 0 2
29267: ARRAY
29268: PUSH
29269: LD_INT 1
29271: ARRAY
29272: PPUSH
29273: CALL 57406 0 2
// end ;
29277: GO 29127
29279: POP
29280: POP
// end else
29281: GO 30106
// if mc_build_list [ i ] then
29283: LD_EXP 55
29287: PUSH
29288: LD_VAR 0 2
29292: ARRAY
29293: IFFALSE 30106
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29295: LD_EXP 55
29299: PUSH
29300: LD_VAR 0 2
29304: ARRAY
29305: PUSH
29306: LD_INT 1
29308: ARRAY
29309: PUSH
29310: LD_INT 1
29312: ARRAY
29313: PPUSH
29314: CALL 57230 0 1
29318: PUSH
29319: LD_EXP 50
29323: PUSH
29324: LD_VAR 0 2
29328: ARRAY
29329: PPUSH
29330: LD_INT 2
29332: PUSH
29333: LD_INT 30
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 30
29345: PUSH
29346: LD_INT 3
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: LIST
29357: PPUSH
29358: CALL_OW 72
29362: NOT
29363: AND
29364: IFFALSE 29469
// begin for j = 1 to mc_build_list [ i ] do
29366: LD_ADDR_VAR 0 3
29370: PUSH
29371: DOUBLE
29372: LD_INT 1
29374: DEC
29375: ST_TO_ADDR
29376: LD_EXP 55
29380: PUSH
29381: LD_VAR 0 2
29385: ARRAY
29386: PUSH
29387: FOR_TO
29388: IFFALSE 29467
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29390: LD_EXP 55
29394: PUSH
29395: LD_VAR 0 2
29399: ARRAY
29400: PUSH
29401: LD_VAR 0 3
29405: ARRAY
29406: PUSH
29407: LD_INT 1
29409: ARRAY
29410: PUSH
29411: LD_INT 2
29413: EQUAL
29414: IFFALSE 29465
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29416: LD_ADDR_EXP 55
29420: PUSH
29421: LD_EXP 55
29425: PPUSH
29426: LD_VAR 0 2
29430: PPUSH
29431: LD_EXP 55
29435: PUSH
29436: LD_VAR 0 2
29440: ARRAY
29441: PPUSH
29442: LD_VAR 0 3
29446: PPUSH
29447: LD_INT 1
29449: PPUSH
29450: LD_INT 0
29452: PPUSH
29453: CALL 53586 0 4
29457: PPUSH
29458: CALL_OW 1
29462: ST_TO_ADDR
// break ;
29463: GO 29467
// end ;
29465: GO 29387
29467: POP
29468: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29469: LD_ADDR_VAR 0 6
29473: PUSH
29474: LD_EXP 50
29478: PUSH
29479: LD_VAR 0 2
29483: ARRAY
29484: PPUSH
29485: LD_INT 2
29487: PUSH
29488: LD_INT 30
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 30
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: LIST
29512: PPUSH
29513: CALL_OW 72
29517: ST_TO_ADDR
// for k := 1 to depot do
29518: LD_ADDR_VAR 0 4
29522: PUSH
29523: DOUBLE
29524: LD_INT 1
29526: DEC
29527: ST_TO_ADDR
29528: LD_VAR 0 6
29532: PUSH
29533: FOR_TO
29534: IFFALSE 30104
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29536: LD_EXP 55
29540: PUSH
29541: LD_VAR 0 2
29545: ARRAY
29546: PUSH
29547: LD_INT 1
29549: ARRAY
29550: PUSH
29551: LD_INT 1
29553: ARRAY
29554: PUSH
29555: LD_INT 0
29557: EQUAL
29558: PUSH
29559: LD_VAR 0 6
29563: PUSH
29564: LD_VAR 0 4
29568: ARRAY
29569: PPUSH
29570: LD_EXP 55
29574: PUSH
29575: LD_VAR 0 2
29579: ARRAY
29580: PUSH
29581: LD_INT 1
29583: ARRAY
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: LD_EXP 55
29593: PUSH
29594: LD_VAR 0 2
29598: ARRAY
29599: PUSH
29600: LD_INT 1
29602: ARRAY
29603: PUSH
29604: LD_INT 2
29606: ARRAY
29607: PPUSH
29608: LD_EXP 55
29612: PUSH
29613: LD_VAR 0 2
29617: ARRAY
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PUSH
29623: LD_INT 3
29625: ARRAY
29626: PPUSH
29627: LD_EXP 55
29631: PUSH
29632: LD_VAR 0 2
29636: ARRAY
29637: PUSH
29638: LD_INT 1
29640: ARRAY
29641: PUSH
29642: LD_INT 4
29644: ARRAY
29645: PPUSH
29646: CALL 62642 0 5
29650: OR
29651: IFFALSE 29932
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29653: LD_ADDR_VAR 0 5
29657: PUSH
29658: LD_EXP 50
29662: PUSH
29663: LD_VAR 0 2
29667: ARRAY
29668: PPUSH
29669: LD_INT 25
29671: PUSH
29672: LD_INT 2
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PPUSH
29679: CALL_OW 72
29683: PUSH
29684: LD_EXP 52
29688: PUSH
29689: LD_VAR 0 2
29693: ARRAY
29694: DIFF
29695: ST_TO_ADDR
// if not tmp then
29696: LD_VAR 0 5
29700: NOT
29701: IFFALSE 29705
// continue ;
29703: GO 29533
// for j in tmp do
29705: LD_ADDR_VAR 0 3
29709: PUSH
29710: LD_VAR 0 5
29714: PUSH
29715: FOR_IN
29716: IFFALSE 29928
// begin if not mc_builders [ i ] then
29718: LD_EXP 56
29722: PUSH
29723: LD_VAR 0 2
29727: ARRAY
29728: NOT
29729: IFFALSE 29787
// begin SetTag ( j , 103 ) ;
29731: LD_VAR 0 3
29735: PPUSH
29736: LD_INT 103
29738: PPUSH
29739: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29743: LD_ADDR_EXP 56
29747: PUSH
29748: LD_EXP 56
29752: PPUSH
29753: LD_VAR 0 2
29757: PUSH
29758: LD_EXP 56
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PUSH
29769: LD_INT 1
29771: PLUS
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PPUSH
29777: LD_VAR 0 3
29781: PPUSH
29782: CALL 54168 0 3
29786: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29787: LD_VAR 0 3
29791: PPUSH
29792: CALL_OW 310
29796: IFFALSE 29807
// ComExitBuilding ( j ) ;
29798: LD_VAR 0 3
29802: PPUSH
29803: CALL_OW 122
// wait ( 3 ) ;
29807: LD_INT 3
29809: PPUSH
29810: CALL_OW 67
// if not mc_build_list [ i ] then
29814: LD_EXP 55
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: NOT
29825: IFFALSE 29829
// break ;
29827: GO 29928
// if not HasTask ( j ) then
29829: LD_VAR 0 3
29833: PPUSH
29834: CALL_OW 314
29838: NOT
29839: IFFALSE 29926
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29841: LD_VAR 0 3
29845: PPUSH
29846: LD_EXP 55
29850: PUSH
29851: LD_VAR 0 2
29855: ARRAY
29856: PUSH
29857: LD_INT 1
29859: ARRAY
29860: PUSH
29861: LD_INT 1
29863: ARRAY
29864: PPUSH
29865: LD_EXP 55
29869: PUSH
29870: LD_VAR 0 2
29874: ARRAY
29875: PUSH
29876: LD_INT 1
29878: ARRAY
29879: PUSH
29880: LD_INT 2
29882: ARRAY
29883: PPUSH
29884: LD_EXP 55
29888: PUSH
29889: LD_VAR 0 2
29893: ARRAY
29894: PUSH
29895: LD_INT 1
29897: ARRAY
29898: PUSH
29899: LD_INT 3
29901: ARRAY
29902: PPUSH
29903: LD_EXP 55
29907: PUSH
29908: LD_VAR 0 2
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: ARRAY
29917: PUSH
29918: LD_INT 4
29920: ARRAY
29921: PPUSH
29922: CALL_OW 145
// end ;
29926: GO 29715
29928: POP
29929: POP
// end else
29930: GO 30102
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29932: LD_EXP 50
29936: PUSH
29937: LD_VAR 0 2
29941: ARRAY
29942: PPUSH
29943: LD_EXP 55
29947: PUSH
29948: LD_VAR 0 2
29952: ARRAY
29953: PUSH
29954: LD_INT 1
29956: ARRAY
29957: PUSH
29958: LD_INT 1
29960: ARRAY
29961: PPUSH
29962: LD_EXP 55
29966: PUSH
29967: LD_VAR 0 2
29971: ARRAY
29972: PUSH
29973: LD_INT 1
29975: ARRAY
29976: PUSH
29977: LD_INT 2
29979: ARRAY
29980: PPUSH
29981: LD_EXP 55
29985: PUSH
29986: LD_VAR 0 2
29990: ARRAY
29991: PUSH
29992: LD_INT 1
29994: ARRAY
29995: PUSH
29996: LD_INT 3
29998: ARRAY
29999: PPUSH
30000: LD_EXP 55
30004: PUSH
30005: LD_VAR 0 2
30009: ARRAY
30010: PUSH
30011: LD_INT 1
30013: ARRAY
30014: PUSH
30015: LD_INT 4
30017: ARRAY
30018: PPUSH
30019: LD_EXP 50
30023: PUSH
30024: LD_VAR 0 2
30028: ARRAY
30029: PPUSH
30030: LD_INT 21
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PPUSH
30040: CALL_OW 72
30044: PPUSH
30045: EMPTY
30046: PPUSH
30047: CALL 61396 0 7
30051: NOT
30052: IFFALSE 30102
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30054: LD_ADDR_EXP 55
30058: PUSH
30059: LD_EXP 55
30063: PPUSH
30064: LD_VAR 0 2
30068: PPUSH
30069: LD_EXP 55
30073: PUSH
30074: LD_VAR 0 2
30078: ARRAY
30079: PPUSH
30080: LD_INT 1
30082: PPUSH
30083: LD_INT 1
30085: NEG
30086: PPUSH
30087: LD_INT 0
30089: PPUSH
30090: CALL 53586 0 4
30094: PPUSH
30095: CALL_OW 1
30099: ST_TO_ADDR
// continue ;
30100: GO 29533
// end ; end ;
30102: GO 29533
30104: POP
30105: POP
// end ; end ;
30106: GO 28962
30108: POP
30109: POP
// end ;
30110: LD_VAR 0 1
30114: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30115: LD_INT 0
30117: PPUSH
30118: PPUSH
30119: PPUSH
30120: PPUSH
30121: PPUSH
30122: PPUSH
// if not mc_bases then
30123: LD_EXP 50
30127: NOT
30128: IFFALSE 30132
// exit ;
30130: GO 30559
// for i = 1 to mc_bases do
30132: LD_ADDR_VAR 0 2
30136: PUSH
30137: DOUBLE
30138: LD_INT 1
30140: DEC
30141: ST_TO_ADDR
30142: LD_EXP 50
30146: PUSH
30147: FOR_TO
30148: IFFALSE 30557
// begin tmp := mc_build_upgrade [ i ] ;
30150: LD_ADDR_VAR 0 4
30154: PUSH
30155: LD_EXP 82
30159: PUSH
30160: LD_VAR 0 2
30164: ARRAY
30165: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30166: LD_ADDR_VAR 0 6
30170: PUSH
30171: LD_EXP 83
30175: PUSH
30176: LD_VAR 0 2
30180: ARRAY
30181: PPUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 30
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 30
30197: PUSH
30198: LD_INT 7
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: LIST
30209: PPUSH
30210: CALL_OW 72
30214: ST_TO_ADDR
// if not tmp and not lab then
30215: LD_VAR 0 4
30219: NOT
30220: PUSH
30221: LD_VAR 0 6
30225: NOT
30226: AND
30227: IFFALSE 30231
// continue ;
30229: GO 30147
// if tmp then
30231: LD_VAR 0 4
30235: IFFALSE 30355
// for j in tmp do
30237: LD_ADDR_VAR 0 3
30241: PUSH
30242: LD_VAR 0 4
30246: PUSH
30247: FOR_IN
30248: IFFALSE 30353
// begin if UpgradeCost ( j ) then
30250: LD_VAR 0 3
30254: PPUSH
30255: CALL 61056 0 1
30259: IFFALSE 30351
// begin ComUpgrade ( j ) ;
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30270: LD_ADDR_EXP 82
30274: PUSH
30275: LD_EXP 82
30279: PPUSH
30280: LD_VAR 0 2
30284: PPUSH
30285: LD_EXP 82
30289: PUSH
30290: LD_VAR 0 2
30294: ARRAY
30295: PUSH
30296: LD_VAR 0 3
30300: DIFF
30301: PPUSH
30302: CALL_OW 1
30306: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30307: LD_ADDR_EXP 57
30311: PUSH
30312: LD_EXP 57
30316: PPUSH
30317: LD_VAR 0 2
30321: PUSH
30322: LD_EXP 57
30326: PUSH
30327: LD_VAR 0 2
30331: ARRAY
30332: PUSH
30333: LD_INT 1
30335: PLUS
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PPUSH
30341: LD_VAR 0 3
30345: PPUSH
30346: CALL 54168 0 3
30350: ST_TO_ADDR
// end ; end ;
30351: GO 30247
30353: POP
30354: POP
// if not lab or not mc_lab_upgrade [ i ] then
30355: LD_VAR 0 6
30359: NOT
30360: PUSH
30361: LD_EXP 84
30365: PUSH
30366: LD_VAR 0 2
30370: ARRAY
30371: NOT
30372: OR
30373: IFFALSE 30377
// continue ;
30375: GO 30147
// for j in lab do
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 6
30386: PUSH
30387: FOR_IN
30388: IFFALSE 30553
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30390: LD_VAR 0 3
30394: PPUSH
30395: CALL_OW 266
30399: PUSH
30400: LD_INT 6
30402: PUSH
30403: LD_INT 7
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: IN
30410: PUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: CALL_OW 461
30420: PUSH
30421: LD_INT 1
30423: NONEQUAL
30424: AND
30425: IFFALSE 30551
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30427: LD_VAR 0 3
30431: PPUSH
30432: LD_EXP 84
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: PPUSH
30447: CALL 61261 0 2
30451: IFFALSE 30551
// begin ComCancel ( j ) ;
30453: LD_VAR 0 3
30457: PPUSH
30458: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30462: LD_VAR 0 3
30466: PPUSH
30467: LD_EXP 84
30471: PUSH
30472: LD_VAR 0 2
30476: ARRAY
30477: PUSH
30478: LD_INT 1
30480: ARRAY
30481: PPUSH
30482: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30486: LD_VAR 0 3
30490: PUSH
30491: LD_EXP 57
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: IN
30502: NOT
30503: IFFALSE 30549
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30505: LD_ADDR_EXP 57
30509: PUSH
30510: LD_EXP 57
30514: PPUSH
30515: LD_VAR 0 2
30519: PUSH
30520: LD_EXP 57
30524: PUSH
30525: LD_VAR 0 2
30529: ARRAY
30530: PUSH
30531: LD_INT 1
30533: PLUS
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PPUSH
30539: LD_VAR 0 3
30543: PPUSH
30544: CALL 54168 0 3
30548: ST_TO_ADDR
// break ;
30549: GO 30553
// end ; end ; end ;
30551: GO 30387
30553: POP
30554: POP
// end ;
30555: GO 30147
30557: POP
30558: POP
// end ;
30559: LD_VAR 0 1
30563: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30564: LD_INT 0
30566: PPUSH
30567: PPUSH
30568: PPUSH
30569: PPUSH
30570: PPUSH
30571: PPUSH
30572: PPUSH
30573: PPUSH
30574: PPUSH
// if not mc_bases then
30575: LD_EXP 50
30579: NOT
30580: IFFALSE 30584
// exit ;
30582: GO 30989
// for i = 1 to mc_bases do
30584: LD_ADDR_VAR 0 2
30588: PUSH
30589: DOUBLE
30590: LD_INT 1
30592: DEC
30593: ST_TO_ADDR
30594: LD_EXP 50
30598: PUSH
30599: FOR_TO
30600: IFFALSE 30987
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30602: LD_EXP 58
30606: PUSH
30607: LD_VAR 0 2
30611: ARRAY
30612: NOT
30613: PUSH
30614: LD_EXP 50
30618: PUSH
30619: LD_VAR 0 2
30623: ARRAY
30624: PPUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 3
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: NOT
30640: OR
30641: IFFALSE 30645
// continue ;
30643: GO 30599
// busy := false ;
30645: LD_ADDR_VAR 0 8
30649: PUSH
30650: LD_INT 0
30652: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30653: LD_ADDR_VAR 0 4
30657: PUSH
30658: LD_EXP 50
30662: PUSH
30663: LD_VAR 0 2
30667: ARRAY
30668: PPUSH
30669: LD_INT 30
30671: PUSH
30672: LD_INT 3
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PPUSH
30679: CALL_OW 72
30683: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30684: LD_ADDR_VAR 0 6
30688: PUSH
30689: LD_EXP 58
30693: PUSH
30694: LD_VAR 0 2
30698: ARRAY
30699: PPUSH
30700: LD_INT 2
30702: PUSH
30703: LD_INT 30
30705: PUSH
30706: LD_INT 32
30708: PUSH
30709: EMPTY
30710: LIST
30711: LIST
30712: PUSH
30713: LD_INT 30
30715: PUSH
30716: LD_INT 33
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: LIST
30727: PPUSH
30728: CALL_OW 72
30732: ST_TO_ADDR
// if not t then
30733: LD_VAR 0 6
30737: NOT
30738: IFFALSE 30742
// continue ;
30740: GO 30599
// for j in tmp do
30742: LD_ADDR_VAR 0 3
30746: PUSH
30747: LD_VAR 0 4
30751: PUSH
30752: FOR_IN
30753: IFFALSE 30783
// if not BuildingStatus ( j ) = bs_idle then
30755: LD_VAR 0 3
30759: PPUSH
30760: CALL_OW 461
30764: PUSH
30765: LD_INT 2
30767: EQUAL
30768: NOT
30769: IFFALSE 30781
// begin busy := true ;
30771: LD_ADDR_VAR 0 8
30775: PUSH
30776: LD_INT 1
30778: ST_TO_ADDR
// break ;
30779: GO 30783
// end ;
30781: GO 30752
30783: POP
30784: POP
// if busy then
30785: LD_VAR 0 8
30789: IFFALSE 30793
// continue ;
30791: GO 30599
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30793: LD_ADDR_VAR 0 7
30797: PUSH
30798: LD_VAR 0 6
30802: PPUSH
30803: LD_INT 35
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PPUSH
30813: CALL_OW 72
30817: ST_TO_ADDR
// if tw then
30818: LD_VAR 0 7
30822: IFFALSE 30899
// begin tw := tw [ 1 ] ;
30824: LD_ADDR_VAR 0 7
30828: PUSH
30829: LD_VAR 0 7
30833: PUSH
30834: LD_INT 1
30836: ARRAY
30837: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30838: LD_ADDR_VAR 0 9
30842: PUSH
30843: LD_VAR 0 7
30847: PPUSH
30848: LD_EXP 75
30852: PUSH
30853: LD_VAR 0 2
30857: ARRAY
30858: PPUSH
30859: CALL 59553 0 2
30863: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30864: LD_EXP 89
30868: PUSH
30869: LD_VAR 0 2
30873: ARRAY
30874: IFFALSE 30897
// if not weapon in mc_allowed_tower_weapons [ i ] then
30876: LD_VAR 0 9
30880: PUSH
30881: LD_EXP 89
30885: PUSH
30886: LD_VAR 0 2
30890: ARRAY
30891: IN
30892: NOT
30893: IFFALSE 30897
// continue ;
30895: GO 30599
// end else
30897: GO 30962
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30899: LD_ADDR_VAR 0 5
30903: PUSH
30904: LD_EXP 58
30908: PUSH
30909: LD_VAR 0 2
30913: ARRAY
30914: PPUSH
30915: LD_VAR 0 4
30919: PPUSH
30920: CALL 86465 0 2
30924: ST_TO_ADDR
// if not tmp2 then
30925: LD_VAR 0 5
30929: NOT
30930: IFFALSE 30934
// continue ;
30932: GO 30599
// tw := tmp2 [ 1 ] ;
30934: LD_ADDR_VAR 0 7
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: LD_INT 1
30946: ARRAY
30947: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30948: LD_ADDR_VAR 0 9
30952: PUSH
30953: LD_VAR 0 5
30957: PUSH
30958: LD_INT 2
30960: ARRAY
30961: ST_TO_ADDR
// end ; if not weapon then
30962: LD_VAR 0 9
30966: NOT
30967: IFFALSE 30971
// continue ;
30969: GO 30599
// ComPlaceWeapon ( tw , weapon ) ;
30971: LD_VAR 0 7
30975: PPUSH
30976: LD_VAR 0 9
30980: PPUSH
30981: CALL_OW 148
// end ;
30985: GO 30599
30987: POP
30988: POP
// end ;
30989: LD_VAR 0 1
30993: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30994: LD_INT 0
30996: PPUSH
30997: PPUSH
30998: PPUSH
30999: PPUSH
31000: PPUSH
31001: PPUSH
31002: PPUSH
// if not mc_bases then
31003: LD_EXP 50
31007: NOT
31008: IFFALSE 31012
// exit ;
31010: GO 31787
// for i = 1 to mc_bases do
31012: LD_ADDR_VAR 0 2
31016: PUSH
31017: DOUBLE
31018: LD_INT 1
31020: DEC
31021: ST_TO_ADDR
31022: LD_EXP 50
31026: PUSH
31027: FOR_TO
31028: IFFALSE 31785
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
31030: LD_EXP 63
31034: PUSH
31035: LD_VAR 0 2
31039: ARRAY
31040: NOT
31041: PUSH
31042: LD_EXP 63
31046: PUSH
31047: LD_VAR 0 2
31051: ARRAY
31052: PUSH
31053: LD_EXP 64
31057: PUSH
31058: LD_VAR 0 2
31062: ARRAY
31063: EQUAL
31064: OR
31065: PUSH
31066: LD_EXP 73
31070: PUSH
31071: LD_VAR 0 2
31075: ARRAY
31076: OR
31077: IFFALSE 31081
// continue ;
31079: GO 31027
// if mc_miners [ i ] then
31081: LD_EXP 64
31085: PUSH
31086: LD_VAR 0 2
31090: ARRAY
31091: IFFALSE 31472
// begin for j = mc_miners [ i ] downto 1 do
31093: LD_ADDR_VAR 0 3
31097: PUSH
31098: DOUBLE
31099: LD_EXP 64
31103: PUSH
31104: LD_VAR 0 2
31108: ARRAY
31109: INC
31110: ST_TO_ADDR
31111: LD_INT 1
31113: PUSH
31114: FOR_DOWNTO
31115: IFFALSE 31470
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31117: LD_EXP 64
31121: PUSH
31122: LD_VAR 0 2
31126: ARRAY
31127: PUSH
31128: LD_VAR 0 3
31132: ARRAY
31133: PPUSH
31134: CALL_OW 301
31138: PUSH
31139: LD_EXP 64
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PUSH
31150: LD_VAR 0 3
31154: ARRAY
31155: PPUSH
31156: CALL_OW 257
31160: PUSH
31161: LD_INT 1
31163: NONEQUAL
31164: OR
31165: IFFALSE 31228
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31167: LD_ADDR_VAR 0 5
31171: PUSH
31172: LD_EXP 64
31176: PUSH
31177: LD_VAR 0 2
31181: ARRAY
31182: PUSH
31183: LD_EXP 64
31187: PUSH
31188: LD_VAR 0 2
31192: ARRAY
31193: PUSH
31194: LD_VAR 0 3
31198: ARRAY
31199: DIFF
31200: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31201: LD_ADDR_EXP 64
31205: PUSH
31206: LD_EXP 64
31210: PPUSH
31211: LD_VAR 0 2
31215: PPUSH
31216: LD_VAR 0 5
31220: PPUSH
31221: CALL_OW 1
31225: ST_TO_ADDR
// continue ;
31226: GO 31114
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31228: LD_EXP 64
31232: PUSH
31233: LD_VAR 0 2
31237: ARRAY
31238: PUSH
31239: LD_VAR 0 3
31243: ARRAY
31244: PPUSH
31245: CALL_OW 257
31249: PUSH
31250: LD_INT 1
31252: EQUAL
31253: PUSH
31254: LD_EXP 64
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: PUSH
31265: LD_VAR 0 3
31269: ARRAY
31270: PPUSH
31271: CALL_OW 459
31275: NOT
31276: AND
31277: PUSH
31278: LD_EXP 64
31282: PUSH
31283: LD_VAR 0 2
31287: ARRAY
31288: PUSH
31289: LD_VAR 0 3
31293: ARRAY
31294: PPUSH
31295: CALL_OW 314
31299: NOT
31300: AND
31301: IFFALSE 31468
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31303: LD_EXP 64
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: PUSH
31314: LD_VAR 0 3
31318: ARRAY
31319: PPUSH
31320: CALL_OW 310
31324: IFFALSE 31347
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31326: LD_EXP 64
31330: PUSH
31331: LD_VAR 0 2
31335: ARRAY
31336: PUSH
31337: LD_VAR 0 3
31341: ARRAY
31342: PPUSH
31343: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31347: LD_EXP 64
31351: PUSH
31352: LD_VAR 0 2
31356: ARRAY
31357: PUSH
31358: LD_VAR 0 3
31362: ARRAY
31363: PPUSH
31364: CALL_OW 314
31368: NOT
31369: IFFALSE 31468
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31371: LD_ADDR_VAR 0 7
31375: PUSH
31376: LD_VAR 0 3
31380: PUSH
31381: LD_EXP 63
31385: PUSH
31386: LD_VAR 0 2
31390: ARRAY
31391: PPUSH
31392: CALL 51308 0 1
31396: MOD
31397: PUSH
31398: LD_INT 1
31400: PLUS
31401: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31402: LD_EXP 64
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PUSH
31413: LD_VAR 0 3
31417: ARRAY
31418: PPUSH
31419: LD_EXP 63
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 7
31434: ARRAY
31435: PUSH
31436: LD_INT 1
31438: ARRAY
31439: PPUSH
31440: LD_EXP 63
31444: PUSH
31445: LD_VAR 0 2
31449: ARRAY
31450: PUSH
31451: LD_VAR 0 7
31455: ARRAY
31456: PUSH
31457: LD_INT 2
31459: ARRAY
31460: PPUSH
31461: LD_INT 0
31463: PPUSH
31464: CALL_OW 193
// end ; end ; end ;
31468: GO 31114
31470: POP
31471: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31472: LD_ADDR_VAR 0 5
31476: PUSH
31477: LD_EXP 50
31481: PUSH
31482: LD_VAR 0 2
31486: ARRAY
31487: PPUSH
31488: LD_INT 2
31490: PUSH
31491: LD_INT 30
31493: PUSH
31494: LD_INT 4
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 30
31503: PUSH
31504: LD_INT 5
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 30
31513: PUSH
31514: LD_INT 32
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: PPUSH
31527: CALL_OW 72
31531: ST_TO_ADDR
// if not tmp then
31532: LD_VAR 0 5
31536: NOT
31537: IFFALSE 31541
// continue ;
31539: GO 31027
// list := [ ] ;
31541: LD_ADDR_VAR 0 6
31545: PUSH
31546: EMPTY
31547: ST_TO_ADDR
// for j in tmp do
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_VAR 0 5
31557: PUSH
31558: FOR_IN
31559: IFFALSE 31628
// begin for k in UnitsInside ( j ) do
31561: LD_ADDR_VAR 0 4
31565: PUSH
31566: LD_VAR 0 3
31570: PPUSH
31571: CALL_OW 313
31575: PUSH
31576: FOR_IN
31577: IFFALSE 31624
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31579: LD_VAR 0 4
31583: PPUSH
31584: CALL_OW 257
31588: PUSH
31589: LD_INT 1
31591: EQUAL
31592: PUSH
31593: LD_VAR 0 4
31597: PPUSH
31598: CALL_OW 459
31602: NOT
31603: AND
31604: IFFALSE 31622
// list := list ^ k ;
31606: LD_ADDR_VAR 0 6
31610: PUSH
31611: LD_VAR 0 6
31615: PUSH
31616: LD_VAR 0 4
31620: ADD
31621: ST_TO_ADDR
31622: GO 31576
31624: POP
31625: POP
// end ;
31626: GO 31558
31628: POP
31629: POP
// list := list diff mc_miners [ i ] ;
31630: LD_ADDR_VAR 0 6
31634: PUSH
31635: LD_VAR 0 6
31639: PUSH
31640: LD_EXP 64
31644: PUSH
31645: LD_VAR 0 2
31649: ARRAY
31650: DIFF
31651: ST_TO_ADDR
// if not list then
31652: LD_VAR 0 6
31656: NOT
31657: IFFALSE 31661
// continue ;
31659: GO 31027
// k := mc_mines [ i ] - mc_miners [ i ] ;
31661: LD_ADDR_VAR 0 4
31665: PUSH
31666: LD_EXP 63
31670: PUSH
31671: LD_VAR 0 2
31675: ARRAY
31676: PUSH
31677: LD_EXP 64
31681: PUSH
31682: LD_VAR 0 2
31686: ARRAY
31687: MINUS
31688: ST_TO_ADDR
// if k > list then
31689: LD_VAR 0 4
31693: PUSH
31694: LD_VAR 0 6
31698: GREATER
31699: IFFALSE 31711
// k := list ;
31701: LD_ADDR_VAR 0 4
31705: PUSH
31706: LD_VAR 0 6
31710: ST_TO_ADDR
// for j = 1 to k do
31711: LD_ADDR_VAR 0 3
31715: PUSH
31716: DOUBLE
31717: LD_INT 1
31719: DEC
31720: ST_TO_ADDR
31721: LD_VAR 0 4
31725: PUSH
31726: FOR_TO
31727: IFFALSE 31781
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31729: LD_ADDR_EXP 64
31733: PUSH
31734: LD_EXP 64
31738: PPUSH
31739: LD_VAR 0 2
31743: PUSH
31744: LD_EXP 64
31748: PUSH
31749: LD_VAR 0 2
31753: ARRAY
31754: PUSH
31755: LD_INT 1
31757: PLUS
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PPUSH
31763: LD_VAR 0 6
31767: PUSH
31768: LD_VAR 0 3
31772: ARRAY
31773: PPUSH
31774: CALL 54168 0 3
31778: ST_TO_ADDR
31779: GO 31726
31781: POP
31782: POP
// end ;
31783: GO 31027
31785: POP
31786: POP
// end ;
31787: LD_VAR 0 1
31791: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31792: LD_INT 0
31794: PPUSH
31795: PPUSH
31796: PPUSH
31797: PPUSH
31798: PPUSH
31799: PPUSH
31800: PPUSH
31801: PPUSH
31802: PPUSH
31803: PPUSH
31804: PPUSH
// if not mc_bases then
31805: LD_EXP 50
31809: NOT
31810: IFFALSE 31814
// exit ;
31812: GO 33637
// for i = 1 to mc_bases do
31814: LD_ADDR_VAR 0 2
31818: PUSH
31819: DOUBLE
31820: LD_INT 1
31822: DEC
31823: ST_TO_ADDR
31824: LD_EXP 50
31828: PUSH
31829: FOR_TO
31830: IFFALSE 33635
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31832: LD_EXP 50
31836: PUSH
31837: LD_VAR 0 2
31841: ARRAY
31842: NOT
31843: PUSH
31844: LD_EXP 57
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: OR
31855: IFFALSE 31859
// continue ;
31857: GO 31829
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31859: LD_EXP 66
31863: PUSH
31864: LD_VAR 0 2
31868: ARRAY
31869: NOT
31870: PUSH
31871: LD_EXP 67
31875: PUSH
31876: LD_VAR 0 2
31880: ARRAY
31881: AND
31882: IFFALSE 31920
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31884: LD_ADDR_EXP 67
31888: PUSH
31889: LD_EXP 67
31893: PPUSH
31894: LD_VAR 0 2
31898: PPUSH
31899: EMPTY
31900: PPUSH
31901: CALL_OW 1
31905: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31906: LD_VAR 0 2
31910: PPUSH
31911: LD_INT 107
31913: PPUSH
31914: CALL 22646 0 2
// continue ;
31918: GO 31829
// end ; target := [ ] ;
31920: LD_ADDR_VAR 0 7
31924: PUSH
31925: EMPTY
31926: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31927: LD_ADDR_VAR 0 6
31931: PUSH
31932: LD_EXP 50
31936: PUSH
31937: LD_VAR 0 2
31941: ARRAY
31942: PUSH
31943: LD_INT 1
31945: ARRAY
31946: PPUSH
31947: CALL_OW 255
31951: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31952: LD_ADDR_VAR 0 9
31956: PUSH
31957: LD_EXP 50
31961: PUSH
31962: LD_VAR 0 2
31966: ARRAY
31967: PPUSH
31968: LD_INT 2
31970: PUSH
31971: LD_INT 30
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 30
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: LIST
31995: PPUSH
31996: CALL_OW 72
32000: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
32001: LD_ADDR_VAR 0 3
32005: PUSH
32006: DOUBLE
32007: LD_EXP 66
32011: PUSH
32012: LD_VAR 0 2
32016: ARRAY
32017: INC
32018: ST_TO_ADDR
32019: LD_INT 1
32021: PUSH
32022: FOR_DOWNTO
32023: IFFALSE 32268
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32025: LD_EXP 66
32029: PUSH
32030: LD_VAR 0 2
32034: ARRAY
32035: PUSH
32036: LD_VAR 0 3
32040: ARRAY
32041: PUSH
32042: LD_INT 2
32044: ARRAY
32045: PPUSH
32046: LD_EXP 66
32050: PUSH
32051: LD_VAR 0 2
32055: ARRAY
32056: PUSH
32057: LD_VAR 0 3
32061: ARRAY
32062: PUSH
32063: LD_INT 3
32065: ARRAY
32066: PPUSH
32067: CALL_OW 488
32071: PUSH
32072: LD_EXP 66
32076: PUSH
32077: LD_VAR 0 2
32081: ARRAY
32082: PUSH
32083: LD_VAR 0 3
32087: ARRAY
32088: PUSH
32089: LD_INT 2
32091: ARRAY
32092: PPUSH
32093: LD_EXP 66
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: PUSH
32104: LD_VAR 0 3
32108: ARRAY
32109: PUSH
32110: LD_INT 3
32112: ARRAY
32113: PPUSH
32114: CALL_OW 284
32118: PUSH
32119: LD_INT 0
32121: EQUAL
32122: AND
32123: IFFALSE 32178
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32125: LD_ADDR_VAR 0 5
32129: PUSH
32130: LD_EXP 66
32134: PUSH
32135: LD_VAR 0 2
32139: ARRAY
32140: PPUSH
32141: LD_VAR 0 3
32145: PPUSH
32146: CALL_OW 3
32150: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32151: LD_ADDR_EXP 66
32155: PUSH
32156: LD_EXP 66
32160: PPUSH
32161: LD_VAR 0 2
32165: PPUSH
32166: LD_VAR 0 5
32170: PPUSH
32171: CALL_OW 1
32175: ST_TO_ADDR
// continue ;
32176: GO 32022
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32178: LD_VAR 0 6
32182: PPUSH
32183: LD_EXP 66
32187: PUSH
32188: LD_VAR 0 2
32192: ARRAY
32193: PUSH
32194: LD_VAR 0 3
32198: ARRAY
32199: PUSH
32200: LD_INT 2
32202: ARRAY
32203: PPUSH
32204: LD_EXP 66
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_VAR 0 3
32219: ARRAY
32220: PUSH
32221: LD_INT 3
32223: ARRAY
32224: PPUSH
32225: LD_INT 30
32227: PPUSH
32228: CALL 55432 0 4
32232: PUSH
32233: LD_INT 4
32235: ARRAY
32236: PUSH
32237: LD_INT 0
32239: EQUAL
32240: IFFALSE 32266
// begin target := mc_crates [ i ] [ j ] ;
32242: LD_ADDR_VAR 0 7
32246: PUSH
32247: LD_EXP 66
32251: PUSH
32252: LD_VAR 0 2
32256: ARRAY
32257: PUSH
32258: LD_VAR 0 3
32262: ARRAY
32263: ST_TO_ADDR
// break ;
32264: GO 32268
// end ; end ;
32266: GO 32022
32268: POP
32269: POP
// if not target then
32270: LD_VAR 0 7
32274: NOT
32275: IFFALSE 32279
// continue ;
32277: GO 31829
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32279: LD_ADDR_VAR 0 8
32283: PUSH
32284: LD_EXP 69
32288: PUSH
32289: LD_VAR 0 2
32293: ARRAY
32294: PPUSH
32295: LD_INT 2
32297: PUSH
32298: LD_INT 3
32300: PUSH
32301: LD_INT 58
32303: PUSH
32304: EMPTY
32305: LIST
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 61
32313: PUSH
32314: EMPTY
32315: LIST
32316: PUSH
32317: LD_INT 33
32319: PUSH
32320: LD_INT 5
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 33
32329: PUSH
32330: LD_INT 3
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 34
32349: PUSH
32350: LD_INT 32
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 34
32359: PUSH
32360: LD_INT 51
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 34
32369: PUSH
32370: LD_INT 12
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not cargo then
32392: LD_VAR 0 8
32396: NOT
32397: IFFALSE 33103
// begin if mc_crates_collector [ i ] < 5 then
32399: LD_EXP 67
32403: PUSH
32404: LD_VAR 0 2
32408: ARRAY
32409: PUSH
32410: LD_INT 5
32412: LESS
32413: IFFALSE 32779
// begin if mc_ape [ i ] then
32415: LD_EXP 79
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: IFFALSE 32472
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32427: LD_ADDR_VAR 0 5
32431: PUSH
32432: LD_EXP 79
32436: PUSH
32437: LD_VAR 0 2
32441: ARRAY
32442: PPUSH
32443: LD_INT 25
32445: PUSH
32446: LD_INT 16
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 24
32455: PUSH
32456: LD_INT 750
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PPUSH
32467: CALL_OW 72
32471: ST_TO_ADDR
// if not tmp then
32472: LD_VAR 0 5
32476: NOT
32477: IFFALSE 32524
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32479: LD_ADDR_VAR 0 5
32483: PUSH
32484: LD_EXP 50
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PPUSH
32495: LD_INT 25
32497: PUSH
32498: LD_INT 2
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 24
32507: PUSH
32508: LD_INT 750
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PPUSH
32519: CALL_OW 72
32523: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32524: LD_EXP 79
32528: PUSH
32529: LD_VAR 0 2
32533: ARRAY
32534: PUSH
32535: LD_EXP 50
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PPUSH
32546: LD_INT 25
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 24
32558: PUSH
32559: LD_INT 750
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PPUSH
32570: CALL_OW 72
32574: AND
32575: PUSH
32576: LD_VAR 0 5
32580: PUSH
32581: LD_INT 5
32583: LESS
32584: AND
32585: IFFALSE 32667
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32587: LD_ADDR_VAR 0 3
32591: PUSH
32592: LD_EXP 50
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: PPUSH
32603: LD_INT 25
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 24
32615: PUSH
32616: LD_INT 750
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PPUSH
32627: CALL_OW 72
32631: PUSH
32632: FOR_IN
32633: IFFALSE 32665
// begin tmp := tmp union j ;
32635: LD_ADDR_VAR 0 5
32639: PUSH
32640: LD_VAR 0 5
32644: PUSH
32645: LD_VAR 0 3
32649: UNION
32650: ST_TO_ADDR
// if tmp >= 5 then
32651: LD_VAR 0 5
32655: PUSH
32656: LD_INT 5
32658: GREATEREQUAL
32659: IFFALSE 32663
// break ;
32661: GO 32665
// end ;
32663: GO 32632
32665: POP
32666: POP
// end ; if not tmp then
32667: LD_VAR 0 5
32671: NOT
32672: IFFALSE 32676
// continue ;
32674: GO 31829
// for j in tmp do
32676: LD_ADDR_VAR 0 3
32680: PUSH
32681: LD_VAR 0 5
32685: PUSH
32686: FOR_IN
32687: IFFALSE 32777
// if not GetTag ( j ) then
32689: LD_VAR 0 3
32693: PPUSH
32694: CALL_OW 110
32698: NOT
32699: IFFALSE 32775
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32701: LD_ADDR_EXP 67
32705: PUSH
32706: LD_EXP 67
32710: PPUSH
32711: LD_VAR 0 2
32715: PUSH
32716: LD_EXP 67
32720: PUSH
32721: LD_VAR 0 2
32725: ARRAY
32726: PUSH
32727: LD_INT 1
32729: PLUS
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PPUSH
32735: LD_VAR 0 3
32739: PPUSH
32740: CALL 54168 0 3
32744: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32745: LD_VAR 0 3
32749: PPUSH
32750: LD_INT 107
32752: PPUSH
32753: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32757: LD_EXP 67
32761: PUSH
32762: LD_VAR 0 2
32766: ARRAY
32767: PUSH
32768: LD_INT 5
32770: GREATEREQUAL
32771: IFFALSE 32775
// break ;
32773: GO 32777
// end ;
32775: GO 32686
32777: POP
32778: POP
// end ; if mc_crates_collector [ i ] and target then
32779: LD_EXP 67
32783: PUSH
32784: LD_VAR 0 2
32788: ARRAY
32789: PUSH
32790: LD_VAR 0 7
32794: AND
32795: IFFALSE 33101
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32797: LD_EXP 67
32801: PUSH
32802: LD_VAR 0 2
32806: ARRAY
32807: PUSH
32808: LD_VAR 0 7
32812: PUSH
32813: LD_INT 1
32815: ARRAY
32816: LESS
32817: IFFALSE 32837
// tmp := mc_crates_collector [ i ] else
32819: LD_ADDR_VAR 0 5
32823: PUSH
32824: LD_EXP 67
32828: PUSH
32829: LD_VAR 0 2
32833: ARRAY
32834: ST_TO_ADDR
32835: GO 32851
// tmp := target [ 1 ] ;
32837: LD_ADDR_VAR 0 5
32841: PUSH
32842: LD_VAR 0 7
32846: PUSH
32847: LD_INT 1
32849: ARRAY
32850: ST_TO_ADDR
// k := 0 ;
32851: LD_ADDR_VAR 0 4
32855: PUSH
32856: LD_INT 0
32858: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32859: LD_ADDR_VAR 0 3
32863: PUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: FOR_IN
32876: IFFALSE 33099
// begin k := k + 1 ;
32878: LD_ADDR_VAR 0 4
32882: PUSH
32883: LD_VAR 0 4
32887: PUSH
32888: LD_INT 1
32890: PLUS
32891: ST_TO_ADDR
// if k > tmp then
32892: LD_VAR 0 4
32896: PUSH
32897: LD_VAR 0 5
32901: GREATER
32902: IFFALSE 32906
// break ;
32904: GO 33099
// if not GetClass ( j ) in [ 2 , 16 ] then
32906: LD_VAR 0 3
32910: PPUSH
32911: CALL_OW 257
32915: PUSH
32916: LD_INT 2
32918: PUSH
32919: LD_INT 16
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: IN
32926: NOT
32927: IFFALSE 32980
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32929: LD_ADDR_EXP 67
32933: PUSH
32934: LD_EXP 67
32938: PPUSH
32939: LD_VAR 0 2
32943: PPUSH
32944: LD_EXP 67
32948: PUSH
32949: LD_VAR 0 2
32953: ARRAY
32954: PUSH
32955: LD_VAR 0 3
32959: DIFF
32960: PPUSH
32961: CALL_OW 1
32965: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32966: LD_VAR 0 3
32970: PPUSH
32971: LD_INT 0
32973: PPUSH
32974: CALL_OW 109
// continue ;
32978: GO 32875
// end ; if IsInUnit ( j ) then
32980: LD_VAR 0 3
32984: PPUSH
32985: CALL_OW 310
32989: IFFALSE 33000
// ComExitBuilding ( j ) ;
32991: LD_VAR 0 3
32995: PPUSH
32996: CALL_OW 122
// wait ( 3 ) ;
33000: LD_INT 3
33002: PPUSH
33003: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
33007: LD_VAR 0 3
33011: PPUSH
33012: CALL_OW 314
33016: PUSH
33017: LD_VAR 0 6
33021: PPUSH
33022: LD_VAR 0 7
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: PPUSH
33031: LD_VAR 0 7
33035: PUSH
33036: LD_INT 3
33038: ARRAY
33039: PPUSH
33040: LD_INT 30
33042: PPUSH
33043: CALL 55432 0 4
33047: PUSH
33048: LD_INT 4
33050: ARRAY
33051: AND
33052: IFFALSE 33070
// ComStandNearbyBuilding ( j , depot ) else
33054: LD_VAR 0 3
33058: PPUSH
33059: LD_VAR 0 9
33063: PPUSH
33064: CALL 50770 0 2
33068: GO 33097
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33070: LD_VAR 0 3
33074: PPUSH
33075: LD_VAR 0 7
33079: PUSH
33080: LD_INT 2
33082: ARRAY
33083: PPUSH
33084: LD_VAR 0 7
33088: PUSH
33089: LD_INT 3
33091: ARRAY
33092: PPUSH
33093: CALL_OW 117
// end ;
33097: GO 32875
33099: POP
33100: POP
// end ; end else
33101: GO 33633
// begin for j in cargo do
33103: LD_ADDR_VAR 0 3
33107: PUSH
33108: LD_VAR 0 8
33112: PUSH
33113: FOR_IN
33114: IFFALSE 33631
// begin if GetTag ( j ) <> 0 then
33116: LD_VAR 0 3
33120: PPUSH
33121: CALL_OW 110
33125: PUSH
33126: LD_INT 0
33128: NONEQUAL
33129: IFFALSE 33133
// continue ;
33131: GO 33113
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33133: LD_VAR 0 3
33137: PPUSH
33138: CALL_OW 256
33142: PUSH
33143: LD_INT 1000
33145: LESS
33146: PUSH
33147: LD_VAR 0 3
33151: PPUSH
33152: LD_EXP 74
33156: PUSH
33157: LD_VAR 0 2
33161: ARRAY
33162: PPUSH
33163: CALL_OW 308
33167: NOT
33168: AND
33169: IFFALSE 33191
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33171: LD_VAR 0 3
33175: PPUSH
33176: LD_EXP 74
33180: PUSH
33181: LD_VAR 0 2
33185: ARRAY
33186: PPUSH
33187: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33191: LD_VAR 0 3
33195: PPUSH
33196: CALL_OW 256
33200: PUSH
33201: LD_INT 1000
33203: LESS
33204: PUSH
33205: LD_VAR 0 3
33209: PPUSH
33210: LD_EXP 74
33214: PUSH
33215: LD_VAR 0 2
33219: ARRAY
33220: PPUSH
33221: CALL_OW 308
33225: AND
33226: IFFALSE 33230
// continue ;
33228: GO 33113
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33230: LD_VAR 0 3
33234: PPUSH
33235: CALL_OW 262
33239: PUSH
33240: LD_INT 2
33242: EQUAL
33243: PUSH
33244: LD_VAR 0 3
33248: PPUSH
33249: CALL_OW 261
33253: PUSH
33254: LD_INT 15
33256: LESS
33257: AND
33258: IFFALSE 33262
// continue ;
33260: GO 33113
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33262: LD_VAR 0 3
33266: PPUSH
33267: CALL_OW 262
33271: PUSH
33272: LD_INT 1
33274: EQUAL
33275: PUSH
33276: LD_VAR 0 3
33280: PPUSH
33281: CALL_OW 261
33285: PUSH
33286: LD_INT 10
33288: LESS
33289: AND
33290: IFFALSE 33570
// begin if not depot then
33292: LD_VAR 0 9
33296: NOT
33297: IFFALSE 33301
// continue ;
33299: GO 33113
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33301: LD_VAR 0 3
33305: PPUSH
33306: LD_VAR 0 9
33310: PPUSH
33311: LD_VAR 0 3
33315: PPUSH
33316: CALL_OW 74
33320: PPUSH
33321: CALL_OW 296
33325: PUSH
33326: LD_INT 6
33328: LESS
33329: IFFALSE 33345
// SetFuel ( j , 100 ) else
33331: LD_VAR 0 3
33335: PPUSH
33336: LD_INT 100
33338: PPUSH
33339: CALL_OW 240
33343: GO 33570
// if GetFuel ( j ) = 0 then
33345: LD_VAR 0 3
33349: PPUSH
33350: CALL_OW 261
33354: PUSH
33355: LD_INT 0
33357: EQUAL
33358: IFFALSE 33570
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33360: LD_ADDR_EXP 69
33364: PUSH
33365: LD_EXP 69
33369: PPUSH
33370: LD_VAR 0 2
33374: PPUSH
33375: LD_EXP 69
33379: PUSH
33380: LD_VAR 0 2
33384: ARRAY
33385: PUSH
33386: LD_VAR 0 3
33390: DIFF
33391: PPUSH
33392: CALL_OW 1
33396: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33397: LD_VAR 0 3
33401: PPUSH
33402: CALL_OW 263
33406: PUSH
33407: LD_INT 1
33409: EQUAL
33410: IFFALSE 33426
// ComExitVehicle ( IsInUnit ( j ) ) ;
33412: LD_VAR 0 3
33416: PPUSH
33417: CALL_OW 310
33421: PPUSH
33422: CALL_OW 121
// if GetControl ( j ) = control_remote then
33426: LD_VAR 0 3
33430: PPUSH
33431: CALL_OW 263
33435: PUSH
33436: LD_INT 2
33438: EQUAL
33439: IFFALSE 33450
// ComUnlink ( j ) ;
33441: LD_VAR 0 3
33445: PPUSH
33446: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33450: LD_ADDR_VAR 0 10
33454: PUSH
33455: LD_VAR 0 2
33459: PPUSH
33460: LD_INT 3
33462: PPUSH
33463: CALL 43214 0 2
33467: ST_TO_ADDR
// if fac then
33468: LD_VAR 0 10
33472: IFFALSE 33568
// begin for k in fac do
33474: LD_ADDR_VAR 0 4
33478: PUSH
33479: LD_VAR 0 10
33483: PUSH
33484: FOR_IN
33485: IFFALSE 33566
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33487: LD_ADDR_VAR 0 11
33491: PUSH
33492: LD_VAR 0 10
33496: PPUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: CALL_OW 265
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 262
33516: PPUSH
33517: LD_VAR 0 3
33521: PPUSH
33522: CALL_OW 263
33526: PPUSH
33527: LD_VAR 0 3
33531: PPUSH
33532: CALL_OW 264
33536: PPUSH
33537: CALL 51666 0 5
33541: ST_TO_ADDR
// if components then
33542: LD_VAR 0 11
33546: IFFALSE 33564
// begin MC_InsertProduceList ( i , components ) ;
33548: LD_VAR 0 2
33552: PPUSH
33553: LD_VAR 0 11
33557: PPUSH
33558: CALL 42759 0 2
// break ;
33562: GO 33566
// end ; end ;
33564: GO 33484
33566: POP
33567: POP
// end ; continue ;
33568: GO 33113
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33570: LD_VAR 0 3
33574: PPUSH
33575: LD_INT 1
33577: PPUSH
33578: CALL_OW 289
33582: PUSH
33583: LD_INT 100
33585: LESS
33586: PUSH
33587: LD_VAR 0 3
33591: PPUSH
33592: CALL_OW 314
33596: NOT
33597: AND
33598: IFFALSE 33627
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33600: LD_VAR 0 3
33604: PPUSH
33605: LD_VAR 0 7
33609: PUSH
33610: LD_INT 2
33612: ARRAY
33613: PPUSH
33614: LD_VAR 0 7
33618: PUSH
33619: LD_INT 3
33621: ARRAY
33622: PPUSH
33623: CALL_OW 117
// break ;
33627: GO 33631
// end ;
33629: GO 33113
33631: POP
33632: POP
// end ; end ;
33633: GO 31829
33635: POP
33636: POP
// end ;
33637: LD_VAR 0 1
33641: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33642: LD_INT 0
33644: PPUSH
33645: PPUSH
33646: PPUSH
33647: PPUSH
// if not mc_bases then
33648: LD_EXP 50
33652: NOT
33653: IFFALSE 33657
// exit ;
33655: GO 33818
// for i = 1 to mc_bases do
33657: LD_ADDR_VAR 0 2
33661: PUSH
33662: DOUBLE
33663: LD_INT 1
33665: DEC
33666: ST_TO_ADDR
33667: LD_EXP 50
33671: PUSH
33672: FOR_TO
33673: IFFALSE 33816
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33675: LD_ADDR_VAR 0 4
33679: PUSH
33680: LD_EXP 69
33684: PUSH
33685: LD_VAR 0 2
33689: ARRAY
33690: PUSH
33691: LD_EXP 72
33695: PUSH
33696: LD_VAR 0 2
33700: ARRAY
33701: UNION
33702: PPUSH
33703: LD_INT 33
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PPUSH
33713: CALL_OW 72
33717: ST_TO_ADDR
// if tmp then
33718: LD_VAR 0 4
33722: IFFALSE 33814
// for j in tmp do
33724: LD_ADDR_VAR 0 3
33728: PUSH
33729: LD_VAR 0 4
33733: PUSH
33734: FOR_IN
33735: IFFALSE 33812
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33737: LD_VAR 0 3
33741: PPUSH
33742: CALL_OW 312
33746: NOT
33747: PUSH
33748: LD_VAR 0 3
33752: PPUSH
33753: CALL_OW 256
33757: PUSH
33758: LD_INT 250
33760: GREATEREQUAL
33761: AND
33762: IFFALSE 33775
// Connect ( j ) else
33764: LD_VAR 0 3
33768: PPUSH
33769: CALL 57514 0 1
33773: GO 33810
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33775: LD_VAR 0 3
33779: PPUSH
33780: CALL_OW 256
33784: PUSH
33785: LD_INT 250
33787: LESS
33788: PUSH
33789: LD_VAR 0 3
33793: PPUSH
33794: CALL_OW 312
33798: AND
33799: IFFALSE 33810
// ComUnlink ( j ) ;
33801: LD_VAR 0 3
33805: PPUSH
33806: CALL_OW 136
33810: GO 33734
33812: POP
33813: POP
// end ;
33814: GO 33672
33816: POP
33817: POP
// end ;
33818: LD_VAR 0 1
33822: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33823: LD_INT 0
33825: PPUSH
33826: PPUSH
33827: PPUSH
33828: PPUSH
33829: PPUSH
// if not mc_bases then
33830: LD_EXP 50
33834: NOT
33835: IFFALSE 33839
// exit ;
33837: GO 34284
// for i = 1 to mc_bases do
33839: LD_ADDR_VAR 0 2
33843: PUSH
33844: DOUBLE
33845: LD_INT 1
33847: DEC
33848: ST_TO_ADDR
33849: LD_EXP 50
33853: PUSH
33854: FOR_TO
33855: IFFALSE 34282
// begin if not mc_produce [ i ] then
33857: LD_EXP 71
33861: PUSH
33862: LD_VAR 0 2
33866: ARRAY
33867: NOT
33868: IFFALSE 33872
// continue ;
33870: GO 33854
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33872: LD_ADDR_VAR 0 5
33876: PUSH
33877: LD_EXP 50
33881: PUSH
33882: LD_VAR 0 2
33886: ARRAY
33887: PPUSH
33888: LD_INT 30
33890: PUSH
33891: LD_INT 3
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PPUSH
33898: CALL_OW 72
33902: ST_TO_ADDR
// if not fac then
33903: LD_VAR 0 5
33907: NOT
33908: IFFALSE 33912
// continue ;
33910: GO 33854
// for j in fac do
33912: LD_ADDR_VAR 0 3
33916: PUSH
33917: LD_VAR 0 5
33921: PUSH
33922: FOR_IN
33923: IFFALSE 34278
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33925: LD_VAR 0 3
33929: PPUSH
33930: CALL_OW 461
33934: PUSH
33935: LD_INT 2
33937: NONEQUAL
33938: PUSH
33939: LD_VAR 0 3
33943: PPUSH
33944: LD_INT 15
33946: PPUSH
33947: CALL 57133 0 2
33951: PUSH
33952: LD_INT 4
33954: ARRAY
33955: OR
33956: IFFALSE 33960
// continue ;
33958: GO 33922
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33960: LD_VAR 0 3
33964: PPUSH
33965: LD_EXP 71
33969: PUSH
33970: LD_VAR 0 2
33974: ARRAY
33975: PUSH
33976: LD_INT 1
33978: ARRAY
33979: PUSH
33980: LD_INT 1
33982: ARRAY
33983: PPUSH
33984: LD_EXP 71
33988: PUSH
33989: LD_VAR 0 2
33993: ARRAY
33994: PUSH
33995: LD_INT 1
33997: ARRAY
33998: PUSH
33999: LD_INT 2
34001: ARRAY
34002: PPUSH
34003: LD_EXP 71
34007: PUSH
34008: LD_VAR 0 2
34012: ARRAY
34013: PUSH
34014: LD_INT 1
34016: ARRAY
34017: PUSH
34018: LD_INT 3
34020: ARRAY
34021: PPUSH
34022: LD_EXP 71
34026: PUSH
34027: LD_VAR 0 2
34031: ARRAY
34032: PUSH
34033: LD_INT 1
34035: ARRAY
34036: PUSH
34037: LD_INT 4
34039: ARRAY
34040: PPUSH
34041: CALL_OW 448
34045: PUSH
34046: LD_VAR 0 3
34050: PPUSH
34051: LD_EXP 71
34055: PUSH
34056: LD_VAR 0 2
34060: ARRAY
34061: PUSH
34062: LD_INT 1
34064: ARRAY
34065: PUSH
34066: LD_INT 1
34068: ARRAY
34069: PUSH
34070: LD_EXP 71
34074: PUSH
34075: LD_VAR 0 2
34079: ARRAY
34080: PUSH
34081: LD_INT 1
34083: ARRAY
34084: PUSH
34085: LD_INT 2
34087: ARRAY
34088: PUSH
34089: LD_EXP 71
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PUSH
34100: LD_INT 1
34102: ARRAY
34103: PUSH
34104: LD_INT 3
34106: ARRAY
34107: PUSH
34108: LD_EXP 71
34112: PUSH
34113: LD_VAR 0 2
34117: ARRAY
34118: PUSH
34119: LD_INT 1
34121: ARRAY
34122: PUSH
34123: LD_INT 4
34125: ARRAY
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: PPUSH
34133: CALL 60909 0 2
34137: AND
34138: IFFALSE 34276
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34140: LD_VAR 0 3
34144: PPUSH
34145: LD_EXP 71
34149: PUSH
34150: LD_VAR 0 2
34154: ARRAY
34155: PUSH
34156: LD_INT 1
34158: ARRAY
34159: PUSH
34160: LD_INT 1
34162: ARRAY
34163: PPUSH
34164: LD_EXP 71
34168: PUSH
34169: LD_VAR 0 2
34173: ARRAY
34174: PUSH
34175: LD_INT 1
34177: ARRAY
34178: PUSH
34179: LD_INT 2
34181: ARRAY
34182: PPUSH
34183: LD_EXP 71
34187: PUSH
34188: LD_VAR 0 2
34192: ARRAY
34193: PUSH
34194: LD_INT 1
34196: ARRAY
34197: PUSH
34198: LD_INT 3
34200: ARRAY
34201: PPUSH
34202: LD_EXP 71
34206: PUSH
34207: LD_VAR 0 2
34211: ARRAY
34212: PUSH
34213: LD_INT 1
34215: ARRAY
34216: PUSH
34217: LD_INT 4
34219: ARRAY
34220: PPUSH
34221: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34225: LD_ADDR_VAR 0 4
34229: PUSH
34230: LD_EXP 71
34234: PUSH
34235: LD_VAR 0 2
34239: ARRAY
34240: PPUSH
34241: LD_INT 1
34243: PPUSH
34244: CALL_OW 3
34248: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34249: LD_ADDR_EXP 71
34253: PUSH
34254: LD_EXP 71
34258: PPUSH
34259: LD_VAR 0 2
34263: PPUSH
34264: LD_VAR 0 4
34268: PPUSH
34269: CALL_OW 1
34273: ST_TO_ADDR
// break ;
34274: GO 34278
// end ; end ;
34276: GO 33922
34278: POP
34279: POP
// end ;
34280: GO 33854
34282: POP
34283: POP
// end ;
34284: LD_VAR 0 1
34288: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34289: LD_INT 0
34291: PPUSH
34292: PPUSH
34293: PPUSH
// if not mc_bases then
34294: LD_EXP 50
34298: NOT
34299: IFFALSE 34303
// exit ;
34301: GO 34392
// for i = 1 to mc_bases do
34303: LD_ADDR_VAR 0 2
34307: PUSH
34308: DOUBLE
34309: LD_INT 1
34311: DEC
34312: ST_TO_ADDR
34313: LD_EXP 50
34317: PUSH
34318: FOR_TO
34319: IFFALSE 34390
// begin if mc_attack [ i ] then
34321: LD_EXP 70
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: IFFALSE 34388
// begin tmp := mc_attack [ i ] [ 1 ] ;
34333: LD_ADDR_VAR 0 3
34337: PUSH
34338: LD_EXP 70
34342: PUSH
34343: LD_VAR 0 2
34347: ARRAY
34348: PUSH
34349: LD_INT 1
34351: ARRAY
34352: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34353: LD_ADDR_EXP 70
34357: PUSH
34358: LD_EXP 70
34362: PPUSH
34363: LD_VAR 0 2
34367: PPUSH
34368: EMPTY
34369: PPUSH
34370: CALL_OW 1
34374: ST_TO_ADDR
// Attack ( tmp ) ;
34375: LD_VAR 0 3
34379: PPUSH
34380: CALL 113232 0 1
// exit ;
34384: POP
34385: POP
34386: GO 34392
// end ; end ;
34388: GO 34318
34390: POP
34391: POP
// end ;
34392: LD_VAR 0 1
34396: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34397: LD_INT 0
34399: PPUSH
34400: PPUSH
34401: PPUSH
34402: PPUSH
34403: PPUSH
34404: PPUSH
34405: PPUSH
// if not mc_bases then
34406: LD_EXP 50
34410: NOT
34411: IFFALSE 34415
// exit ;
34413: GO 35272
// for i = 1 to mc_bases do
34415: LD_ADDR_VAR 0 2
34419: PUSH
34420: DOUBLE
34421: LD_INT 1
34423: DEC
34424: ST_TO_ADDR
34425: LD_EXP 50
34429: PUSH
34430: FOR_TO
34431: IFFALSE 35270
// begin if not mc_bases [ i ] then
34433: LD_EXP 50
34437: PUSH
34438: LD_VAR 0 2
34442: ARRAY
34443: NOT
34444: IFFALSE 34448
// continue ;
34446: GO 34430
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34448: LD_ADDR_VAR 0 7
34452: PUSH
34453: LD_EXP 50
34457: PUSH
34458: LD_VAR 0 2
34462: ARRAY
34463: PUSH
34464: LD_INT 1
34466: ARRAY
34467: PPUSH
34468: CALL 50992 0 1
34472: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34473: LD_ADDR_EXP 73
34477: PUSH
34478: LD_EXP 73
34482: PPUSH
34483: LD_VAR 0 2
34487: PPUSH
34488: LD_EXP 50
34492: PUSH
34493: LD_VAR 0 2
34497: ARRAY
34498: PUSH
34499: LD_INT 1
34501: ARRAY
34502: PPUSH
34503: CALL_OW 255
34507: PPUSH
34508: LD_EXP 75
34512: PUSH
34513: LD_VAR 0 2
34517: ARRAY
34518: PPUSH
34519: CALL 50957 0 2
34523: PPUSH
34524: CALL_OW 1
34528: ST_TO_ADDR
// if not mc_scan [ i ] then
34529: LD_EXP 73
34533: PUSH
34534: LD_VAR 0 2
34538: ARRAY
34539: NOT
34540: IFFALSE 34718
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34542: LD_ADDR_EXP 93
34546: PUSH
34547: LD_EXP 93
34551: PPUSH
34552: LD_VAR 0 2
34556: PPUSH
34557: LD_INT 0
34559: PPUSH
34560: CALL_OW 1
34564: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34565: LD_ADDR_VAR 0 4
34569: PUSH
34570: LD_EXP 50
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: PPUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 25
34586: PUSH
34587: LD_INT 5
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 25
34596: PUSH
34597: LD_INT 8
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 25
34606: PUSH
34607: LD_INT 9
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: PPUSH
34620: CALL_OW 72
34624: ST_TO_ADDR
// if not tmp then
34625: LD_VAR 0 4
34629: NOT
34630: IFFALSE 34634
// continue ;
34632: GO 34430
// for j in tmp do
34634: LD_ADDR_VAR 0 3
34638: PUSH
34639: LD_VAR 0 4
34643: PUSH
34644: FOR_IN
34645: IFFALSE 34716
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34647: LD_VAR 0 3
34651: PPUSH
34652: CALL_OW 310
34656: PPUSH
34657: CALL_OW 266
34661: PUSH
34662: LD_INT 5
34664: EQUAL
34665: PUSH
34666: LD_VAR 0 3
34670: PPUSH
34671: CALL_OW 257
34675: PUSH
34676: LD_INT 1
34678: EQUAL
34679: AND
34680: PUSH
34681: LD_VAR 0 3
34685: PPUSH
34686: CALL_OW 459
34690: NOT
34691: AND
34692: PUSH
34693: LD_VAR 0 7
34697: AND
34698: IFFALSE 34714
// ComChangeProfession ( j , class ) ;
34700: LD_VAR 0 3
34704: PPUSH
34705: LD_VAR 0 7
34709: PPUSH
34710: CALL_OW 123
34714: GO 34644
34716: POP
34717: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34718: LD_EXP 73
34722: PUSH
34723: LD_VAR 0 2
34727: ARRAY
34728: PUSH
34729: LD_EXP 93
34733: PUSH
34734: LD_VAR 0 2
34738: ARRAY
34739: NOT
34740: AND
34741: PUSH
34742: LD_EXP 72
34746: PUSH
34747: LD_VAR 0 2
34751: ARRAY
34752: NOT
34753: AND
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 50
34768: PUSH
34769: EMPTY
34770: LIST
34771: PUSH
34772: LD_INT 2
34774: PUSH
34775: LD_INT 30
34777: PUSH
34778: LD_INT 32
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 30
34787: PUSH
34788: LD_INT 33
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 30
34797: PUSH
34798: LD_INT 4
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 30
34807: PUSH
34808: LD_INT 5
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PPUSH
34826: CALL_OW 72
34830: PUSH
34831: LD_INT 4
34833: LESS
34834: PUSH
34835: LD_EXP 50
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PPUSH
34846: LD_INT 3
34848: PUSH
34849: LD_INT 24
34851: PUSH
34852: LD_INT 1000
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 2
34865: PUSH
34866: LD_INT 30
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 30
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: LIST
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PPUSH
34895: CALL_OW 72
34899: OR
34900: AND
34901: IFFALSE 35152
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34903: LD_ADDR_EXP 93
34907: PUSH
34908: LD_EXP 93
34912: PPUSH
34913: LD_VAR 0 2
34917: PPUSH
34918: LD_INT 1
34920: PPUSH
34921: CALL_OW 1
34925: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34926: LD_ADDR_VAR 0 4
34930: PUSH
34931: LD_EXP 50
34935: PUSH
34936: LD_VAR 0 2
34940: ARRAY
34941: PPUSH
34942: LD_INT 2
34944: PUSH
34945: LD_INT 25
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 25
34957: PUSH
34958: LD_INT 5
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 25
34967: PUSH
34968: LD_INT 8
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 25
34977: PUSH
34978: LD_INT 9
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: PPUSH
34992: CALL_OW 72
34996: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34997: LD_ADDR_VAR 0 4
35001: PUSH
35002: LD_VAR 0 4
35006: PUSH
35007: LD_VAR 0 4
35011: PPUSH
35012: LD_INT 18
35014: PPUSH
35015: CALL 84486 0 2
35019: DIFF
35020: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35021: LD_VAR 0 4
35025: NOT
35026: PUSH
35027: LD_EXP 50
35031: PUSH
35032: LD_VAR 0 2
35036: ARRAY
35037: PPUSH
35038: LD_INT 2
35040: PUSH
35041: LD_INT 30
35043: PUSH
35044: LD_INT 4
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 30
35053: PUSH
35054: LD_INT 5
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: LIST
35065: PPUSH
35066: CALL_OW 72
35070: NOT
35071: AND
35072: IFFALSE 35134
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
35074: LD_ADDR_VAR 0 4
35078: PUSH
35079: LD_EXP 50
35083: PUSH
35084: LD_VAR 0 2
35088: ARRAY
35089: PPUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 25
35095: PUSH
35096: LD_INT 2
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 25
35105: PUSH
35106: LD_INT 3
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 25
35115: PUSH
35116: LD_INT 4
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: PPUSH
35129: CALL_OW 72
35133: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35134: LD_VAR 0 2
35138: PPUSH
35139: LD_VAR 0 4
35143: PPUSH
35144: CALL 117941 0 2
// exit ;
35148: POP
35149: POP
35150: GO 35272
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35152: LD_EXP 73
35156: PUSH
35157: LD_VAR 0 2
35161: ARRAY
35162: PUSH
35163: LD_EXP 93
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: NOT
35174: AND
35175: PUSH
35176: LD_EXP 72
35180: PUSH
35181: LD_VAR 0 2
35185: ARRAY
35186: AND
35187: IFFALSE 35268
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35189: LD_ADDR_EXP 93
35193: PUSH
35194: LD_EXP 93
35198: PPUSH
35199: LD_VAR 0 2
35203: PPUSH
35204: LD_INT 1
35206: PPUSH
35207: CALL_OW 1
35211: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35212: LD_ADDR_VAR 0 4
35216: PUSH
35217: LD_EXP 72
35221: PUSH
35222: LD_VAR 0 2
35226: ARRAY
35227: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35228: LD_ADDR_EXP 72
35232: PUSH
35233: LD_EXP 72
35237: PPUSH
35238: LD_VAR 0 2
35242: PPUSH
35243: EMPTY
35244: PPUSH
35245: CALL_OW 1
35249: ST_TO_ADDR
// Defend ( i , tmp ) ;
35250: LD_VAR 0 2
35254: PPUSH
35255: LD_VAR 0 4
35259: PPUSH
35260: CALL 118537 0 2
// exit ;
35264: POP
35265: POP
35266: GO 35272
// end ; end ;
35268: GO 34430
35270: POP
35271: POP
// end ;
35272: LD_VAR 0 1
35276: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35277: LD_INT 0
35279: PPUSH
35280: PPUSH
35281: PPUSH
35282: PPUSH
35283: PPUSH
35284: PPUSH
35285: PPUSH
35286: PPUSH
35287: PPUSH
35288: PPUSH
35289: PPUSH
// if not mc_bases then
35290: LD_EXP 50
35294: NOT
35295: IFFALSE 35299
// exit ;
35297: GO 36386
// for i = 1 to mc_bases do
35299: LD_ADDR_VAR 0 2
35303: PUSH
35304: DOUBLE
35305: LD_INT 1
35307: DEC
35308: ST_TO_ADDR
35309: LD_EXP 50
35313: PUSH
35314: FOR_TO
35315: IFFALSE 36384
// begin tmp := mc_lab [ i ] ;
35317: LD_ADDR_VAR 0 6
35321: PUSH
35322: LD_EXP 83
35326: PUSH
35327: LD_VAR 0 2
35331: ARRAY
35332: ST_TO_ADDR
// if not tmp then
35333: LD_VAR 0 6
35337: NOT
35338: IFFALSE 35342
// continue ;
35340: GO 35314
// idle_lab := 0 ;
35342: LD_ADDR_VAR 0 11
35346: PUSH
35347: LD_INT 0
35349: ST_TO_ADDR
// for j in tmp do
35350: LD_ADDR_VAR 0 3
35354: PUSH
35355: LD_VAR 0 6
35359: PUSH
35360: FOR_IN
35361: IFFALSE 36380
// begin researching := false ;
35363: LD_ADDR_VAR 0 10
35367: PUSH
35368: LD_INT 0
35370: ST_TO_ADDR
// side := GetSide ( j ) ;
35371: LD_ADDR_VAR 0 4
35375: PUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 255
35385: ST_TO_ADDR
// if not mc_tech [ side ] then
35386: LD_EXP 77
35390: PUSH
35391: LD_VAR 0 4
35395: ARRAY
35396: NOT
35397: IFFALSE 35401
// continue ;
35399: GO 35360
// if BuildingStatus ( j ) = bs_idle then
35401: LD_VAR 0 3
35405: PPUSH
35406: CALL_OW 461
35410: PUSH
35411: LD_INT 2
35413: EQUAL
35414: IFFALSE 35602
// begin if idle_lab and UnitsInside ( j ) < 6 then
35416: LD_VAR 0 11
35420: PUSH
35421: LD_VAR 0 3
35425: PPUSH
35426: CALL_OW 313
35430: PUSH
35431: LD_INT 6
35433: LESS
35434: AND
35435: IFFALSE 35506
// begin tmp2 := UnitsInside ( idle_lab ) ;
35437: LD_ADDR_VAR 0 9
35441: PUSH
35442: LD_VAR 0 11
35446: PPUSH
35447: CALL_OW 313
35451: ST_TO_ADDR
// if tmp2 then
35452: LD_VAR 0 9
35456: IFFALSE 35498
// for x in tmp2 do
35458: LD_ADDR_VAR 0 7
35462: PUSH
35463: LD_VAR 0 9
35467: PUSH
35468: FOR_IN
35469: IFFALSE 35496
// begin ComExitBuilding ( x ) ;
35471: LD_VAR 0 7
35475: PPUSH
35476: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35480: LD_VAR 0 7
35484: PPUSH
35485: LD_VAR 0 3
35489: PPUSH
35490: CALL_OW 180
// end ;
35494: GO 35468
35496: POP
35497: POP
// idle_lab := 0 ;
35498: LD_ADDR_VAR 0 11
35502: PUSH
35503: LD_INT 0
35505: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35506: LD_ADDR_VAR 0 5
35510: PUSH
35511: LD_EXP 77
35515: PUSH
35516: LD_VAR 0 4
35520: ARRAY
35521: PUSH
35522: FOR_IN
35523: IFFALSE 35583
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35525: LD_VAR 0 3
35529: PPUSH
35530: LD_VAR 0 5
35534: PPUSH
35535: CALL_OW 430
35539: PUSH
35540: LD_VAR 0 4
35544: PPUSH
35545: LD_VAR 0 5
35549: PPUSH
35550: CALL 50062 0 2
35554: AND
35555: IFFALSE 35581
// begin researching := true ;
35557: LD_ADDR_VAR 0 10
35561: PUSH
35562: LD_INT 1
35564: ST_TO_ADDR
// ComResearch ( j , t ) ;
35565: LD_VAR 0 3
35569: PPUSH
35570: LD_VAR 0 5
35574: PPUSH
35575: CALL_OW 124
// break ;
35579: GO 35583
// end ;
35581: GO 35522
35583: POP
35584: POP
// if not researching then
35585: LD_VAR 0 10
35589: NOT
35590: IFFALSE 35602
// idle_lab := j ;
35592: LD_ADDR_VAR 0 11
35596: PUSH
35597: LD_VAR 0 3
35601: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 461
35611: PUSH
35612: LD_INT 10
35614: EQUAL
35615: IFFALSE 36203
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35617: LD_EXP 79
35621: PUSH
35622: LD_VAR 0 2
35626: ARRAY
35627: NOT
35628: PUSH
35629: LD_EXP 80
35633: PUSH
35634: LD_VAR 0 2
35638: ARRAY
35639: NOT
35640: AND
35641: PUSH
35642: LD_EXP 77
35646: PUSH
35647: LD_VAR 0 4
35651: ARRAY
35652: PUSH
35653: LD_INT 1
35655: GREATER
35656: AND
35657: IFFALSE 35788
// begin ComCancel ( j ) ;
35659: LD_VAR 0 3
35663: PPUSH
35664: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35668: LD_ADDR_EXP 77
35672: PUSH
35673: LD_EXP 77
35677: PPUSH
35678: LD_VAR 0 4
35682: PPUSH
35683: LD_EXP 77
35687: PUSH
35688: LD_VAR 0 4
35692: ARRAY
35693: PPUSH
35694: LD_EXP 77
35698: PUSH
35699: LD_VAR 0 4
35703: ARRAY
35704: PUSH
35705: LD_INT 1
35707: MINUS
35708: PPUSH
35709: LD_EXP 77
35713: PUSH
35714: LD_VAR 0 4
35718: ARRAY
35719: PPUSH
35720: LD_INT 0
35722: PPUSH
35723: CALL 53586 0 4
35727: PPUSH
35728: CALL_OW 1
35732: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35733: LD_ADDR_EXP 77
35737: PUSH
35738: LD_EXP 77
35742: PPUSH
35743: LD_VAR 0 4
35747: PPUSH
35748: LD_EXP 77
35752: PUSH
35753: LD_VAR 0 4
35757: ARRAY
35758: PPUSH
35759: LD_EXP 77
35763: PUSH
35764: LD_VAR 0 4
35768: ARRAY
35769: PPUSH
35770: LD_INT 1
35772: PPUSH
35773: LD_INT 0
35775: PPUSH
35776: CALL 53586 0 4
35780: PPUSH
35781: CALL_OW 1
35785: ST_TO_ADDR
// continue ;
35786: GO 35360
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35788: LD_EXP 79
35792: PUSH
35793: LD_VAR 0 2
35797: ARRAY
35798: PUSH
35799: LD_EXP 80
35803: PUSH
35804: LD_VAR 0 2
35808: ARRAY
35809: NOT
35810: AND
35811: IFFALSE 35938
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35813: LD_ADDR_EXP 80
35817: PUSH
35818: LD_EXP 80
35822: PPUSH
35823: LD_VAR 0 2
35827: PUSH
35828: LD_EXP 80
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PUSH
35839: LD_INT 1
35841: PLUS
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PPUSH
35847: LD_EXP 79
35851: PUSH
35852: LD_VAR 0 2
35856: ARRAY
35857: PUSH
35858: LD_INT 1
35860: ARRAY
35861: PPUSH
35862: CALL 54168 0 3
35866: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35867: LD_EXP 79
35871: PUSH
35872: LD_VAR 0 2
35876: ARRAY
35877: PUSH
35878: LD_INT 1
35880: ARRAY
35881: PPUSH
35882: LD_INT 112
35884: PPUSH
35885: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35889: LD_ADDR_VAR 0 9
35893: PUSH
35894: LD_EXP 79
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PPUSH
35905: LD_INT 1
35907: PPUSH
35908: CALL_OW 3
35912: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35913: LD_ADDR_EXP 79
35917: PUSH
35918: LD_EXP 79
35922: PPUSH
35923: LD_VAR 0 2
35927: PPUSH
35928: LD_VAR 0 9
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35938: LD_EXP 79
35942: PUSH
35943: LD_VAR 0 2
35947: ARRAY
35948: PUSH
35949: LD_EXP 80
35953: PUSH
35954: LD_VAR 0 2
35958: ARRAY
35959: AND
35960: PUSH
35961: LD_EXP 80
35965: PUSH
35966: LD_VAR 0 2
35970: ARRAY
35971: PUSH
35972: LD_INT 1
35974: ARRAY
35975: PPUSH
35976: CALL_OW 310
35980: NOT
35981: AND
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL_OW 313
35992: PUSH
35993: LD_INT 6
35995: EQUAL
35996: AND
35997: IFFALSE 36053
// begin tmp2 := UnitsInside ( j ) ;
35999: LD_ADDR_VAR 0 9
36003: PUSH
36004: LD_VAR 0 3
36008: PPUSH
36009: CALL_OW 313
36013: ST_TO_ADDR
// if tmp2 = 6 then
36014: LD_VAR 0 9
36018: PUSH
36019: LD_INT 6
36021: EQUAL
36022: IFFALSE 36053
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36024: LD_VAR 0 9
36028: PUSH
36029: LD_INT 1
36031: ARRAY
36032: PPUSH
36033: LD_INT 112
36035: PPUSH
36036: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36040: LD_VAR 0 9
36044: PUSH
36045: LD_INT 1
36047: ARRAY
36048: PPUSH
36049: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_EXP 80
36068: PUSH
36069: LD_VAR 0 2
36073: ARRAY
36074: PUSH
36075: LD_INT 1
36077: ARRAY
36078: PPUSH
36079: CALL_OW 314
36083: NOT
36084: AND
36085: PUSH
36086: LD_EXP 80
36090: PUSH
36091: LD_VAR 0 2
36095: ARRAY
36096: PUSH
36097: LD_INT 1
36099: ARRAY
36100: PPUSH
36101: CALL_OW 310
36105: NOT
36106: AND
36107: IFFALSE 36133
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36109: LD_EXP 80
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: PUSH
36120: LD_INT 1
36122: ARRAY
36123: PPUSH
36124: LD_VAR 0 3
36128: PPUSH
36129: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36133: LD_EXP 80
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_INT 1
36146: ARRAY
36147: PPUSH
36148: CALL_OW 310
36152: PUSH
36153: LD_EXP 80
36157: PUSH
36158: LD_VAR 0 2
36162: ARRAY
36163: PUSH
36164: LD_INT 1
36166: ARRAY
36167: PPUSH
36168: CALL_OW 310
36172: PPUSH
36173: CALL_OW 461
36177: PUSH
36178: LD_INT 3
36180: NONEQUAL
36181: AND
36182: IFFALSE 36203
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36184: LD_EXP 80
36188: PUSH
36189: LD_VAR 0 2
36193: ARRAY
36194: PUSH
36195: LD_INT 1
36197: ARRAY
36198: PPUSH
36199: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36203: LD_VAR 0 3
36207: PPUSH
36208: CALL_OW 461
36212: PUSH
36213: LD_INT 6
36215: EQUAL
36216: PUSH
36217: LD_VAR 0 6
36221: PUSH
36222: LD_INT 1
36224: GREATER
36225: AND
36226: IFFALSE 36378
// begin sci := [ ] ;
36228: LD_ADDR_VAR 0 8
36232: PUSH
36233: EMPTY
36234: ST_TO_ADDR
// for x in ( tmp diff j ) do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 6
36244: PUSH
36245: LD_VAR 0 3
36249: DIFF
36250: PUSH
36251: FOR_IN
36252: IFFALSE 36304
// begin if sci = 6 then
36254: LD_VAR 0 8
36258: PUSH
36259: LD_INT 6
36261: EQUAL
36262: IFFALSE 36266
// break ;
36264: GO 36304
// if BuildingStatus ( x ) = bs_idle then
36266: LD_VAR 0 7
36270: PPUSH
36271: CALL_OW 461
36275: PUSH
36276: LD_INT 2
36278: EQUAL
36279: IFFALSE 36302
// sci := sci ^ UnitsInside ( x ) ;
36281: LD_ADDR_VAR 0 8
36285: PUSH
36286: LD_VAR 0 8
36290: PUSH
36291: LD_VAR 0 7
36295: PPUSH
36296: CALL_OW 313
36300: ADD
36301: ST_TO_ADDR
// end ;
36302: GO 36251
36304: POP
36305: POP
// if not sci then
36306: LD_VAR 0 8
36310: NOT
36311: IFFALSE 36315
// continue ;
36313: GO 35360
// for x in sci do
36315: LD_ADDR_VAR 0 7
36319: PUSH
36320: LD_VAR 0 8
36324: PUSH
36325: FOR_IN
36326: IFFALSE 36376
// if IsInUnit ( x ) and not HasTask ( x ) then
36328: LD_VAR 0 7
36332: PPUSH
36333: CALL_OW 310
36337: PUSH
36338: LD_VAR 0 7
36342: PPUSH
36343: CALL_OW 314
36347: NOT
36348: AND
36349: IFFALSE 36374
// begin ComExitBuilding ( x ) ;
36351: LD_VAR 0 7
36355: PPUSH
36356: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36360: LD_VAR 0 7
36364: PPUSH
36365: LD_VAR 0 3
36369: PPUSH
36370: CALL_OW 180
// end ;
36374: GO 36325
36376: POP
36377: POP
// end ; end ;
36378: GO 35360
36380: POP
36381: POP
// end ;
36382: GO 35314
36384: POP
36385: POP
// end ;
36386: LD_VAR 0 1
36390: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36391: LD_INT 0
36393: PPUSH
36394: PPUSH
// if not mc_bases then
36395: LD_EXP 50
36399: NOT
36400: IFFALSE 36404
// exit ;
36402: GO 36485
// for i = 1 to mc_bases do
36404: LD_ADDR_VAR 0 2
36408: PUSH
36409: DOUBLE
36410: LD_INT 1
36412: DEC
36413: ST_TO_ADDR
36414: LD_EXP 50
36418: PUSH
36419: FOR_TO
36420: IFFALSE 36483
// if mc_mines [ i ] and mc_miners [ i ] then
36422: LD_EXP 63
36426: PUSH
36427: LD_VAR 0 2
36431: ARRAY
36432: PUSH
36433: LD_EXP 64
36437: PUSH
36438: LD_VAR 0 2
36442: ARRAY
36443: AND
36444: IFFALSE 36481
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36446: LD_EXP 64
36450: PUSH
36451: LD_VAR 0 2
36455: ARRAY
36456: PUSH
36457: LD_INT 1
36459: ARRAY
36460: PPUSH
36461: CALL_OW 255
36465: PPUSH
36466: LD_EXP 63
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: PPUSH
36477: CALL 51145 0 2
36481: GO 36419
36483: POP
36484: POP
// end ;
36485: LD_VAR 0 1
36489: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36490: LD_INT 0
36492: PPUSH
36493: PPUSH
36494: PPUSH
36495: PPUSH
36496: PPUSH
36497: PPUSH
36498: PPUSH
36499: PPUSH
// if not mc_bases or not mc_parking then
36500: LD_EXP 50
36504: NOT
36505: PUSH
36506: LD_EXP 74
36510: NOT
36511: OR
36512: IFFALSE 36516
// exit ;
36514: GO 37254
// for i = 1 to mc_bases do
36516: LD_ADDR_VAR 0 2
36520: PUSH
36521: DOUBLE
36522: LD_INT 1
36524: DEC
36525: ST_TO_ADDR
36526: LD_EXP 50
36530: PUSH
36531: FOR_TO
36532: IFFALSE 37252
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36534: LD_EXP 50
36538: PUSH
36539: LD_VAR 0 2
36543: ARRAY
36544: NOT
36545: PUSH
36546: LD_EXP 74
36550: PUSH
36551: LD_VAR 0 2
36555: ARRAY
36556: NOT
36557: OR
36558: IFFALSE 36562
// continue ;
36560: GO 36531
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36562: LD_ADDR_VAR 0 5
36566: PUSH
36567: LD_EXP 50
36571: PUSH
36572: LD_VAR 0 2
36576: ARRAY
36577: PUSH
36578: LD_INT 1
36580: ARRAY
36581: PPUSH
36582: CALL_OW 255
36586: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36587: LD_ADDR_VAR 0 6
36591: PUSH
36592: LD_EXP 50
36596: PUSH
36597: LD_VAR 0 2
36601: ARRAY
36602: PPUSH
36603: LD_INT 30
36605: PUSH
36606: LD_INT 3
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PPUSH
36613: CALL_OW 72
36617: ST_TO_ADDR
// if not fac then
36618: LD_VAR 0 6
36622: NOT
36623: IFFALSE 36674
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36625: LD_ADDR_VAR 0 6
36629: PUSH
36630: LD_EXP 50
36634: PUSH
36635: LD_VAR 0 2
36639: ARRAY
36640: PPUSH
36641: LD_INT 2
36643: PUSH
36644: LD_INT 30
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 30
36656: PUSH
36657: LD_INT 1
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL_OW 72
36673: ST_TO_ADDR
// if not fac then
36674: LD_VAR 0 6
36678: NOT
36679: IFFALSE 36683
// continue ;
36681: GO 36531
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36683: LD_ADDR_VAR 0 7
36687: PUSH
36688: LD_EXP 74
36692: PUSH
36693: LD_VAR 0 2
36697: ARRAY
36698: PPUSH
36699: LD_INT 22
36701: PUSH
36702: LD_VAR 0 5
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 21
36713: PUSH
36714: LD_INT 2
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 3
36723: PUSH
36724: LD_INT 60
36726: PUSH
36727: EMPTY
36728: LIST
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 3
36736: PUSH
36737: LD_INT 24
36739: PUSH
36740: LD_INT 1000
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: PPUSH
36757: CALL_OW 70
36761: ST_TO_ADDR
// for j in fac do
36762: LD_ADDR_VAR 0 3
36766: PUSH
36767: LD_VAR 0 6
36771: PUSH
36772: FOR_IN
36773: IFFALSE 36868
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36775: LD_ADDR_VAR 0 7
36779: PUSH
36780: LD_VAR 0 7
36784: PUSH
36785: LD_INT 22
36787: PUSH
36788: LD_VAR 0 5
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 91
36799: PUSH
36800: LD_VAR 0 3
36804: PUSH
36805: LD_INT 15
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 21
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 3
36825: PUSH
36826: LD_INT 60
36828: PUSH
36829: EMPTY
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 3
36838: PUSH
36839: LD_INT 24
36841: PUSH
36842: LD_INT 1000
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: PPUSH
36860: CALL_OW 69
36864: UNION
36865: ST_TO_ADDR
36866: GO 36772
36868: POP
36869: POP
// if not vehs then
36870: LD_VAR 0 7
36874: NOT
36875: IFFALSE 36901
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36877: LD_ADDR_EXP 62
36881: PUSH
36882: LD_EXP 62
36886: PPUSH
36887: LD_VAR 0 2
36891: PPUSH
36892: EMPTY
36893: PPUSH
36894: CALL_OW 1
36898: ST_TO_ADDR
// continue ;
36899: GO 36531
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36901: LD_ADDR_VAR 0 8
36905: PUSH
36906: LD_EXP 50
36910: PUSH
36911: LD_VAR 0 2
36915: ARRAY
36916: PPUSH
36917: LD_INT 30
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PPUSH
36927: CALL_OW 72
36931: ST_TO_ADDR
// if tmp then
36932: LD_VAR 0 8
36936: IFFALSE 37039
// begin for j in tmp do
36938: LD_ADDR_VAR 0 3
36942: PUSH
36943: LD_VAR 0 8
36947: PUSH
36948: FOR_IN
36949: IFFALSE 37037
// for k in UnitsInside ( j ) do
36951: LD_ADDR_VAR 0 4
36955: PUSH
36956: LD_VAR 0 3
36960: PPUSH
36961: CALL_OW 313
36965: PUSH
36966: FOR_IN
36967: IFFALSE 37033
// if k then
36969: LD_VAR 0 4
36973: IFFALSE 37031
// if not k in mc_repair_vehicle [ i ] then
36975: LD_VAR 0 4
36979: PUSH
36980: LD_EXP 62
36984: PUSH
36985: LD_VAR 0 2
36989: ARRAY
36990: IN
36991: NOT
36992: IFFALSE 37031
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36994: LD_ADDR_EXP 62
36998: PUSH
36999: LD_EXP 62
37003: PPUSH
37004: LD_VAR 0 2
37008: PPUSH
37009: LD_EXP 62
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_VAR 0 4
37024: UNION
37025: PPUSH
37026: CALL_OW 1
37030: ST_TO_ADDR
37031: GO 36966
37033: POP
37034: POP
37035: GO 36948
37037: POP
37038: POP
// end ; if not mc_repair_vehicle [ i ] then
37039: LD_EXP 62
37043: PUSH
37044: LD_VAR 0 2
37048: ARRAY
37049: NOT
37050: IFFALSE 37054
// continue ;
37052: GO 36531
// for j in mc_repair_vehicle [ i ] do
37054: LD_ADDR_VAR 0 3
37058: PUSH
37059: LD_EXP 62
37063: PUSH
37064: LD_VAR 0 2
37068: ARRAY
37069: PUSH
37070: FOR_IN
37071: IFFALSE 37248
// begin if GetClass ( j ) <> 3 then
37073: LD_VAR 0 3
37077: PPUSH
37078: CALL_OW 257
37082: PUSH
37083: LD_INT 3
37085: NONEQUAL
37086: IFFALSE 37127
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37088: LD_ADDR_EXP 62
37092: PUSH
37093: LD_EXP 62
37097: PPUSH
37098: LD_VAR 0 2
37102: PPUSH
37103: LD_EXP 62
37107: PUSH
37108: LD_VAR 0 2
37112: ARRAY
37113: PUSH
37114: LD_VAR 0 3
37118: DIFF
37119: PPUSH
37120: CALL_OW 1
37124: ST_TO_ADDR
// continue ;
37125: GO 37070
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37127: LD_VAR 0 3
37131: PPUSH
37132: CALL_OW 311
37136: NOT
37137: PUSH
37138: LD_VAR 0 3
37142: PUSH
37143: LD_EXP 53
37147: PUSH
37148: LD_VAR 0 2
37152: ARRAY
37153: PUSH
37154: LD_INT 1
37156: ARRAY
37157: IN
37158: NOT
37159: AND
37160: PUSH
37161: LD_VAR 0 3
37165: PUSH
37166: LD_EXP 53
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: PUSH
37177: LD_INT 2
37179: ARRAY
37180: IN
37181: NOT
37182: AND
37183: IFFALSE 37246
// begin if IsInUnit ( j ) then
37185: LD_VAR 0 3
37189: PPUSH
37190: CALL_OW 310
37194: IFFALSE 37207
// ComExitBuilding ( j ) else
37196: LD_VAR 0 3
37200: PPUSH
37201: CALL_OW 122
37205: GO 37246
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37207: LD_VAR 0 3
37211: PPUSH
37212: LD_VAR 0 7
37216: PUSH
37217: LD_INT 1
37219: ARRAY
37220: PPUSH
37221: CALL 88982 0 2
37225: NOT
37226: IFFALSE 37246
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37228: LD_VAR 0 3
37232: PPUSH
37233: LD_VAR 0 7
37237: PUSH
37238: LD_INT 1
37240: ARRAY
37241: PPUSH
37242: CALL_OW 129
// end ; end ;
37246: GO 37070
37248: POP
37249: POP
// end ;
37250: GO 36531
37252: POP
37253: POP
// end ;
37254: LD_VAR 0 1
37258: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37259: LD_INT 0
37261: PPUSH
37262: PPUSH
37263: PPUSH
37264: PPUSH
37265: PPUSH
37266: PPUSH
37267: PPUSH
37268: PPUSH
37269: PPUSH
37270: PPUSH
37271: PPUSH
// if not mc_bases then
37272: LD_EXP 50
37276: NOT
37277: IFFALSE 37281
// exit ;
37279: GO 38083
// for i = 1 to mc_bases do
37281: LD_ADDR_VAR 0 2
37285: PUSH
37286: DOUBLE
37287: LD_INT 1
37289: DEC
37290: ST_TO_ADDR
37291: LD_EXP 50
37295: PUSH
37296: FOR_TO
37297: IFFALSE 38081
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37299: LD_EXP 78
37303: PUSH
37304: LD_VAR 0 2
37308: ARRAY
37309: NOT
37310: PUSH
37311: LD_EXP 53
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: PUSH
37322: LD_INT 1
37324: ARRAY
37325: OR
37326: PUSH
37327: LD_EXP 53
37331: PUSH
37332: LD_VAR 0 2
37336: ARRAY
37337: PUSH
37338: LD_INT 2
37340: ARRAY
37341: OR
37342: PUSH
37343: LD_EXP 76
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: PPUSH
37354: LD_INT 1
37356: PPUSH
37357: CALL_OW 325
37361: NOT
37362: OR
37363: PUSH
37364: LD_EXP 73
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: OR
37375: IFFALSE 37379
// continue ;
37377: GO 37296
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37379: LD_ADDR_VAR 0 8
37383: PUSH
37384: LD_EXP 50
37388: PUSH
37389: LD_VAR 0 2
37393: ARRAY
37394: PPUSH
37395: LD_INT 25
37397: PUSH
37398: LD_INT 4
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 50
37407: PUSH
37408: EMPTY
37409: LIST
37410: PUSH
37411: LD_INT 3
37413: PUSH
37414: LD_INT 60
37416: PUSH
37417: EMPTY
37418: LIST
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: LIST
37428: PPUSH
37429: CALL_OW 72
37433: PUSH
37434: LD_EXP 54
37438: PUSH
37439: LD_VAR 0 2
37443: ARRAY
37444: DIFF
37445: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37446: LD_ADDR_VAR 0 9
37450: PUSH
37451: LD_EXP 50
37455: PUSH
37456: LD_VAR 0 2
37460: ARRAY
37461: PPUSH
37462: LD_INT 2
37464: PUSH
37465: LD_INT 30
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 30
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: LIST
37489: PPUSH
37490: CALL_OW 72
37494: ST_TO_ADDR
// if not tmp or not dep then
37495: LD_VAR 0 8
37499: NOT
37500: PUSH
37501: LD_VAR 0 9
37505: NOT
37506: OR
37507: IFFALSE 37511
// continue ;
37509: GO 37296
// side := GetSide ( tmp [ 1 ] ) ;
37511: LD_ADDR_VAR 0 11
37515: PUSH
37516: LD_VAR 0 8
37520: PUSH
37521: LD_INT 1
37523: ARRAY
37524: PPUSH
37525: CALL_OW 255
37529: ST_TO_ADDR
// dep := dep [ 1 ] ;
37530: LD_ADDR_VAR 0 9
37534: PUSH
37535: LD_VAR 0 9
37539: PUSH
37540: LD_INT 1
37542: ARRAY
37543: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37544: LD_ADDR_VAR 0 7
37548: PUSH
37549: LD_EXP 78
37553: PUSH
37554: LD_VAR 0 2
37558: ARRAY
37559: PPUSH
37560: LD_INT 22
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 25
37572: PUSH
37573: LD_INT 12
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: PUSH
37589: LD_INT 22
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 25
37601: PUSH
37602: LD_INT 12
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 91
37611: PUSH
37612: LD_VAR 0 9
37616: PUSH
37617: LD_INT 20
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: LIST
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: LIST
37629: PPUSH
37630: CALL_OW 69
37634: UNION
37635: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37636: LD_ADDR_VAR 0 10
37640: PUSH
37641: LD_EXP 78
37645: PUSH
37646: LD_VAR 0 2
37650: ARRAY
37651: PPUSH
37652: LD_INT 81
37654: PUSH
37655: LD_VAR 0 11
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PPUSH
37664: CALL_OW 70
37668: ST_TO_ADDR
// if not apes or danger_at_area then
37669: LD_VAR 0 7
37673: NOT
37674: PUSH
37675: LD_VAR 0 10
37679: OR
37680: IFFALSE 37730
// begin if mc_taming [ i ] then
37682: LD_EXP 81
37686: PUSH
37687: LD_VAR 0 2
37691: ARRAY
37692: IFFALSE 37728
// begin MC_Reset ( i , 121 ) ;
37694: LD_VAR 0 2
37698: PPUSH
37699: LD_INT 121
37701: PPUSH
37702: CALL 22646 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37706: LD_ADDR_EXP 81
37710: PUSH
37711: LD_EXP 81
37715: PPUSH
37716: LD_VAR 0 2
37720: PPUSH
37721: EMPTY
37722: PPUSH
37723: CALL_OW 1
37727: ST_TO_ADDR
// end ; continue ;
37728: GO 37296
// end ; for j in tmp do
37730: LD_ADDR_VAR 0 3
37734: PUSH
37735: LD_VAR 0 8
37739: PUSH
37740: FOR_IN
37741: IFFALSE 38077
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37743: LD_VAR 0 3
37747: PUSH
37748: LD_EXP 81
37752: PUSH
37753: LD_VAR 0 2
37757: ARRAY
37758: IN
37759: NOT
37760: PUSH
37761: LD_EXP 81
37765: PUSH
37766: LD_VAR 0 2
37770: ARRAY
37771: PUSH
37772: LD_INT 3
37774: LESS
37775: AND
37776: IFFALSE 37834
// begin SetTag ( j , 121 ) ;
37778: LD_VAR 0 3
37782: PPUSH
37783: LD_INT 121
37785: PPUSH
37786: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37790: LD_ADDR_EXP 81
37794: PUSH
37795: LD_EXP 81
37799: PPUSH
37800: LD_VAR 0 2
37804: PUSH
37805: LD_EXP 81
37809: PUSH
37810: LD_VAR 0 2
37814: ARRAY
37815: PUSH
37816: LD_INT 1
37818: PLUS
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PPUSH
37824: LD_VAR 0 3
37828: PPUSH
37829: CALL 54168 0 3
37833: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37834: LD_VAR 0 3
37838: PUSH
37839: LD_EXP 81
37843: PUSH
37844: LD_VAR 0 2
37848: ARRAY
37849: IN
37850: IFFALSE 38075
// begin if GetClass ( j ) <> 4 then
37852: LD_VAR 0 3
37856: PPUSH
37857: CALL_OW 257
37861: PUSH
37862: LD_INT 4
37864: NONEQUAL
37865: IFFALSE 37918
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37867: LD_ADDR_EXP 81
37871: PUSH
37872: LD_EXP 81
37876: PPUSH
37877: LD_VAR 0 2
37881: PPUSH
37882: LD_EXP 81
37886: PUSH
37887: LD_VAR 0 2
37891: ARRAY
37892: PUSH
37893: LD_VAR 0 3
37897: DIFF
37898: PPUSH
37899: CALL_OW 1
37903: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37904: LD_VAR 0 3
37908: PPUSH
37909: LD_INT 0
37911: PPUSH
37912: CALL_OW 109
// continue ;
37916: GO 37740
// end ; if IsInUnit ( j ) then
37918: LD_VAR 0 3
37922: PPUSH
37923: CALL_OW 310
37927: IFFALSE 37938
// ComExitBuilding ( j ) ;
37929: LD_VAR 0 3
37933: PPUSH
37934: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37938: LD_ADDR_VAR 0 6
37942: PUSH
37943: LD_VAR 0 7
37947: PPUSH
37948: LD_VAR 0 3
37952: PPUSH
37953: CALL_OW 74
37957: ST_TO_ADDR
// if not ape then
37958: LD_VAR 0 6
37962: NOT
37963: IFFALSE 37967
// break ;
37965: GO 38077
// x := GetX ( ape ) ;
37967: LD_ADDR_VAR 0 4
37971: PUSH
37972: LD_VAR 0 6
37976: PPUSH
37977: CALL_OW 250
37981: ST_TO_ADDR
// y := GetY ( ape ) ;
37982: LD_ADDR_VAR 0 5
37986: PUSH
37987: LD_VAR 0 6
37991: PPUSH
37992: CALL_OW 251
37996: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37997: LD_VAR 0 4
38001: PPUSH
38002: LD_VAR 0 5
38006: PPUSH
38007: CALL_OW 488
38011: NOT
38012: PUSH
38013: LD_VAR 0 11
38017: PPUSH
38018: LD_VAR 0 4
38022: PPUSH
38023: LD_VAR 0 5
38027: PPUSH
38028: LD_INT 20
38030: PPUSH
38031: CALL 55432 0 4
38035: PUSH
38036: LD_INT 4
38038: ARRAY
38039: OR
38040: IFFALSE 38044
// break ;
38042: GO 38077
// if not HasTask ( j ) then
38044: LD_VAR 0 3
38048: PPUSH
38049: CALL_OW 314
38053: NOT
38054: IFFALSE 38075
// ComTameXY ( j , x , y ) ;
38056: LD_VAR 0 3
38060: PPUSH
38061: LD_VAR 0 4
38065: PPUSH
38066: LD_VAR 0 5
38070: PPUSH
38071: CALL_OW 131
// end ; end ;
38075: GO 37740
38077: POP
38078: POP
// end ;
38079: GO 37296
38081: POP
38082: POP
// end ;
38083: LD_VAR 0 1
38087: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38088: LD_INT 0
38090: PPUSH
38091: PPUSH
38092: PPUSH
38093: PPUSH
38094: PPUSH
38095: PPUSH
38096: PPUSH
38097: PPUSH
// if not mc_bases then
38098: LD_EXP 50
38102: NOT
38103: IFFALSE 38107
// exit ;
38105: GO 38733
// for i = 1 to mc_bases do
38107: LD_ADDR_VAR 0 2
38111: PUSH
38112: DOUBLE
38113: LD_INT 1
38115: DEC
38116: ST_TO_ADDR
38117: LD_EXP 50
38121: PUSH
38122: FOR_TO
38123: IFFALSE 38731
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38125: LD_EXP 79
38129: PUSH
38130: LD_VAR 0 2
38134: ARRAY
38135: NOT
38136: PUSH
38137: LD_EXP 79
38141: PUSH
38142: LD_VAR 0 2
38146: ARRAY
38147: PPUSH
38148: LD_INT 25
38150: PUSH
38151: LD_INT 12
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PPUSH
38158: CALL_OW 72
38162: NOT
38163: OR
38164: IFFALSE 38168
// continue ;
38166: GO 38122
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38168: LD_ADDR_VAR 0 5
38172: PUSH
38173: LD_EXP 79
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PUSH
38184: LD_INT 1
38186: ARRAY
38187: PPUSH
38188: CALL_OW 255
38192: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38193: LD_VAR 0 5
38197: PPUSH
38198: LD_INT 2
38200: PPUSH
38201: CALL_OW 325
38205: IFFALSE 38458
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38207: LD_ADDR_VAR 0 4
38211: PUSH
38212: LD_EXP 79
38216: PUSH
38217: LD_VAR 0 2
38221: ARRAY
38222: PPUSH
38223: LD_INT 25
38225: PUSH
38226: LD_INT 16
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PPUSH
38233: CALL_OW 72
38237: ST_TO_ADDR
// if tmp < 6 then
38238: LD_VAR 0 4
38242: PUSH
38243: LD_INT 6
38245: LESS
38246: IFFALSE 38458
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38248: LD_ADDR_VAR 0 6
38252: PUSH
38253: LD_EXP 50
38257: PUSH
38258: LD_VAR 0 2
38262: ARRAY
38263: PPUSH
38264: LD_INT 2
38266: PUSH
38267: LD_INT 30
38269: PUSH
38270: LD_INT 0
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 30
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: LIST
38291: PPUSH
38292: CALL_OW 72
38296: ST_TO_ADDR
// if depot then
38297: LD_VAR 0 6
38301: IFFALSE 38458
// begin selected := 0 ;
38303: LD_ADDR_VAR 0 7
38307: PUSH
38308: LD_INT 0
38310: ST_TO_ADDR
// for j in depot do
38311: LD_ADDR_VAR 0 3
38315: PUSH
38316: LD_VAR 0 6
38320: PUSH
38321: FOR_IN
38322: IFFALSE 38353
// begin if UnitsInside ( j ) < 6 then
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 313
38333: PUSH
38334: LD_INT 6
38336: LESS
38337: IFFALSE 38351
// begin selected := j ;
38339: LD_ADDR_VAR 0 7
38343: PUSH
38344: LD_VAR 0 3
38348: ST_TO_ADDR
// break ;
38349: GO 38353
// end ; end ;
38351: GO 38321
38353: POP
38354: POP
// if selected then
38355: LD_VAR 0 7
38359: IFFALSE 38458
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38361: LD_ADDR_VAR 0 3
38365: PUSH
38366: LD_EXP 79
38370: PUSH
38371: LD_VAR 0 2
38375: ARRAY
38376: PPUSH
38377: LD_INT 25
38379: PUSH
38380: LD_INT 12
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PPUSH
38387: CALL_OW 72
38391: PUSH
38392: FOR_IN
38393: IFFALSE 38456
// if not HasTask ( j ) then
38395: LD_VAR 0 3
38399: PPUSH
38400: CALL_OW 314
38404: NOT
38405: IFFALSE 38454
// begin if not IsInUnit ( j ) then
38407: LD_VAR 0 3
38411: PPUSH
38412: CALL_OW 310
38416: NOT
38417: IFFALSE 38433
// ComEnterUnit ( j , selected ) ;
38419: LD_VAR 0 3
38423: PPUSH
38424: LD_VAR 0 7
38428: PPUSH
38429: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_INT 16
38440: PPUSH
38441: CALL_OW 183
// AddComExitBuilding ( j ) ;
38445: LD_VAR 0 3
38449: PPUSH
38450: CALL_OW 182
// end ;
38454: GO 38392
38456: POP
38457: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38458: LD_VAR 0 5
38462: PPUSH
38463: LD_INT 11
38465: PPUSH
38466: CALL_OW 325
38470: IFFALSE 38729
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38472: LD_ADDR_VAR 0 4
38476: PUSH
38477: LD_EXP 79
38481: PUSH
38482: LD_VAR 0 2
38486: ARRAY
38487: PPUSH
38488: LD_INT 25
38490: PUSH
38491: LD_INT 16
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PPUSH
38498: CALL_OW 72
38502: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38503: LD_VAR 0 4
38507: PUSH
38508: LD_INT 6
38510: GREATEREQUAL
38511: PUSH
38512: LD_VAR 0 5
38516: PPUSH
38517: LD_INT 2
38519: PPUSH
38520: CALL_OW 325
38524: NOT
38525: OR
38526: IFFALSE 38729
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38528: LD_ADDR_VAR 0 8
38532: PUSH
38533: LD_EXP 50
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: PPUSH
38544: LD_INT 2
38546: PUSH
38547: LD_INT 30
38549: PUSH
38550: LD_INT 4
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 30
38559: PUSH
38560: LD_INT 5
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: LIST
38571: PPUSH
38572: CALL_OW 72
38576: ST_TO_ADDR
// if barracks then
38577: LD_VAR 0 8
38581: IFFALSE 38729
// begin selected := 0 ;
38583: LD_ADDR_VAR 0 7
38587: PUSH
38588: LD_INT 0
38590: ST_TO_ADDR
// for j in barracks do
38591: LD_ADDR_VAR 0 3
38595: PUSH
38596: LD_VAR 0 8
38600: PUSH
38601: FOR_IN
38602: IFFALSE 38633
// begin if UnitsInside ( j ) < 6 then
38604: LD_VAR 0 3
38608: PPUSH
38609: CALL_OW 313
38613: PUSH
38614: LD_INT 6
38616: LESS
38617: IFFALSE 38631
// begin selected := j ;
38619: LD_ADDR_VAR 0 7
38623: PUSH
38624: LD_VAR 0 3
38628: ST_TO_ADDR
// break ;
38629: GO 38633
// end ; end ;
38631: GO 38601
38633: POP
38634: POP
// if selected then
38635: LD_VAR 0 7
38639: IFFALSE 38729
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38641: LD_ADDR_VAR 0 3
38645: PUSH
38646: LD_EXP 79
38650: PUSH
38651: LD_VAR 0 2
38655: ARRAY
38656: PPUSH
38657: LD_INT 25
38659: PUSH
38660: LD_INT 12
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PPUSH
38667: CALL_OW 72
38671: PUSH
38672: FOR_IN
38673: IFFALSE 38727
// if not IsInUnit ( j ) and not HasTask ( j ) then
38675: LD_VAR 0 3
38679: PPUSH
38680: CALL_OW 310
38684: NOT
38685: PUSH
38686: LD_VAR 0 3
38690: PPUSH
38691: CALL_OW 314
38695: NOT
38696: AND
38697: IFFALSE 38725
// begin ComEnterUnit ( j , selected ) ;
38699: LD_VAR 0 3
38703: PPUSH
38704: LD_VAR 0 7
38708: PPUSH
38709: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38713: LD_VAR 0 3
38717: PPUSH
38718: LD_INT 15
38720: PPUSH
38721: CALL_OW 183
// end ;
38725: GO 38672
38727: POP
38728: POP
// end ; end ; end ; end ; end ;
38729: GO 38122
38731: POP
38732: POP
// end ;
38733: LD_VAR 0 1
38737: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38738: LD_INT 0
38740: PPUSH
38741: PPUSH
38742: PPUSH
38743: PPUSH
// if not mc_bases then
38744: LD_EXP 50
38748: NOT
38749: IFFALSE 38753
// exit ;
38751: GO 38931
// for i = 1 to mc_bases do
38753: LD_ADDR_VAR 0 2
38757: PUSH
38758: DOUBLE
38759: LD_INT 1
38761: DEC
38762: ST_TO_ADDR
38763: LD_EXP 50
38767: PUSH
38768: FOR_TO
38769: IFFALSE 38929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38771: LD_ADDR_VAR 0 4
38775: PUSH
38776: LD_EXP 50
38780: PUSH
38781: LD_VAR 0 2
38785: ARRAY
38786: PPUSH
38787: LD_INT 25
38789: PUSH
38790: LD_INT 9
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PPUSH
38797: CALL_OW 72
38801: ST_TO_ADDR
// if not tmp then
38802: LD_VAR 0 4
38806: NOT
38807: IFFALSE 38811
// continue ;
38809: GO 38768
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38811: LD_EXP 76
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: PPUSH
38822: LD_INT 29
38824: PPUSH
38825: CALL_OW 325
38829: NOT
38830: PUSH
38831: LD_EXP 76
38835: PUSH
38836: LD_VAR 0 2
38840: ARRAY
38841: PPUSH
38842: LD_INT 28
38844: PPUSH
38845: CALL_OW 325
38849: NOT
38850: AND
38851: IFFALSE 38855
// continue ;
38853: GO 38768
// for j in tmp do
38855: LD_ADDR_VAR 0 3
38859: PUSH
38860: LD_VAR 0 4
38864: PUSH
38865: FOR_IN
38866: IFFALSE 38925
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38868: LD_VAR 0 3
38872: PUSH
38873: LD_EXP 53
38877: PUSH
38878: LD_VAR 0 2
38882: ARRAY
38883: PUSH
38884: LD_INT 1
38886: ARRAY
38887: IN
38888: NOT
38889: PUSH
38890: LD_VAR 0 3
38894: PUSH
38895: LD_EXP 53
38899: PUSH
38900: LD_VAR 0 2
38904: ARRAY
38905: PUSH
38906: LD_INT 2
38908: ARRAY
38909: IN
38910: NOT
38911: AND
38912: IFFALSE 38923
// ComSpaceTimeShoot ( j ) ;
38914: LD_VAR 0 3
38918: PPUSH
38919: CALL 50153 0 1
38923: GO 38865
38925: POP
38926: POP
// end ;
38927: GO 38768
38929: POP
38930: POP
// end ;
38931: LD_VAR 0 1
38935: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38936: LD_INT 0
38938: PPUSH
38939: PPUSH
38940: PPUSH
38941: PPUSH
38942: PPUSH
38943: PPUSH
38944: PPUSH
38945: PPUSH
38946: PPUSH
// if not mc_bases then
38947: LD_EXP 50
38951: NOT
38952: IFFALSE 38956
// exit ;
38954: GO 39578
// for i = 1 to mc_bases do
38956: LD_ADDR_VAR 0 2
38960: PUSH
38961: DOUBLE
38962: LD_INT 1
38964: DEC
38965: ST_TO_ADDR
38966: LD_EXP 50
38970: PUSH
38971: FOR_TO
38972: IFFALSE 39576
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38974: LD_EXP 85
38978: PUSH
38979: LD_VAR 0 2
38983: ARRAY
38984: NOT
38985: PUSH
38986: LD_INT 38
38988: PPUSH
38989: LD_EXP 76
38993: PUSH
38994: LD_VAR 0 2
38998: ARRAY
38999: PPUSH
39000: CALL_OW 321
39004: PUSH
39005: LD_INT 2
39007: NONEQUAL
39008: OR
39009: IFFALSE 39013
// continue ;
39011: GO 38971
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_EXP 50
39022: PUSH
39023: LD_VAR 0 2
39027: ARRAY
39028: PPUSH
39029: LD_INT 30
39031: PUSH
39032: LD_INT 34
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PPUSH
39039: CALL_OW 72
39043: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39044: LD_ADDR_VAR 0 9
39048: PUSH
39049: LD_EXP 50
39053: PUSH
39054: LD_VAR 0 2
39058: ARRAY
39059: PPUSH
39060: LD_INT 25
39062: PUSH
39063: LD_INT 4
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PPUSH
39070: CALL_OW 72
39074: PPUSH
39075: LD_INT 0
39077: PPUSH
39078: CALL 84486 0 2
39082: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39083: LD_VAR 0 9
39087: NOT
39088: PUSH
39089: LD_VAR 0 8
39093: NOT
39094: OR
39095: PUSH
39096: LD_EXP 50
39100: PUSH
39101: LD_VAR 0 2
39105: ARRAY
39106: PPUSH
39107: LD_INT 124
39109: PPUSH
39110: CALL 84486 0 2
39114: OR
39115: IFFALSE 39119
// continue ;
39117: GO 38971
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39119: LD_EXP 86
39123: PUSH
39124: LD_VAR 0 2
39128: ARRAY
39129: PUSH
39130: LD_EXP 85
39134: PUSH
39135: LD_VAR 0 2
39139: ARRAY
39140: LESS
39141: PUSH
39142: LD_EXP 86
39146: PUSH
39147: LD_VAR 0 2
39151: ARRAY
39152: PUSH
39153: LD_VAR 0 8
39157: LESS
39158: AND
39159: IFFALSE 39574
// begin tmp := sci [ 1 ] ;
39161: LD_ADDR_VAR 0 7
39165: PUSH
39166: LD_VAR 0 9
39170: PUSH
39171: LD_INT 1
39173: ARRAY
39174: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39175: LD_VAR 0 7
39179: PPUSH
39180: LD_INT 124
39182: PPUSH
39183: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39187: LD_ADDR_VAR 0 3
39191: PUSH
39192: DOUBLE
39193: LD_EXP 85
39197: PUSH
39198: LD_VAR 0 2
39202: ARRAY
39203: INC
39204: ST_TO_ADDR
39205: LD_EXP 85
39209: PUSH
39210: LD_VAR 0 2
39214: ARRAY
39215: PUSH
39216: FOR_DOWNTO
39217: IFFALSE 39560
// begin if IsInUnit ( tmp ) then
39219: LD_VAR 0 7
39223: PPUSH
39224: CALL_OW 310
39228: IFFALSE 39239
// ComExitBuilding ( tmp ) ;
39230: LD_VAR 0 7
39234: PPUSH
39235: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39239: LD_INT 35
39241: PPUSH
39242: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39246: LD_VAR 0 7
39250: PPUSH
39251: CALL_OW 310
39255: NOT
39256: PUSH
39257: LD_VAR 0 7
39261: PPUSH
39262: CALL_OW 314
39266: NOT
39267: AND
39268: IFFALSE 39239
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39270: LD_ADDR_VAR 0 6
39274: PUSH
39275: LD_VAR 0 7
39279: PPUSH
39280: CALL_OW 250
39284: PUSH
39285: LD_VAR 0 7
39289: PPUSH
39290: CALL_OW 251
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39299: LD_INT 35
39301: PPUSH
39302: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39306: LD_ADDR_VAR 0 4
39310: PUSH
39311: LD_EXP 85
39315: PUSH
39316: LD_VAR 0 2
39320: ARRAY
39321: PUSH
39322: LD_VAR 0 3
39326: ARRAY
39327: PUSH
39328: LD_INT 1
39330: ARRAY
39331: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39332: LD_ADDR_VAR 0 5
39336: PUSH
39337: LD_EXP 85
39341: PUSH
39342: LD_VAR 0 2
39346: ARRAY
39347: PUSH
39348: LD_VAR 0 3
39352: ARRAY
39353: PUSH
39354: LD_INT 2
39356: ARRAY
39357: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_INT 10
39365: PPUSH
39366: CALL 57133 0 2
39370: PUSH
39371: LD_INT 4
39373: ARRAY
39374: IFFALSE 39412
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39376: LD_VAR 0 7
39380: PPUSH
39381: LD_VAR 0 6
39385: PUSH
39386: LD_INT 1
39388: ARRAY
39389: PPUSH
39390: LD_VAR 0 6
39394: PUSH
39395: LD_INT 2
39397: ARRAY
39398: PPUSH
39399: CALL_OW 111
// wait ( 0 0$10 ) ;
39403: LD_INT 350
39405: PPUSH
39406: CALL_OW 67
// end else
39410: GO 39438
// begin ComMoveXY ( tmp , x , y ) ;
39412: LD_VAR 0 7
39416: PPUSH
39417: LD_VAR 0 4
39421: PPUSH
39422: LD_VAR 0 5
39426: PPUSH
39427: CALL_OW 111
// wait ( 0 0$3 ) ;
39431: LD_INT 105
39433: PPUSH
39434: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39438: LD_VAR 0 7
39442: PPUSH
39443: LD_VAR 0 4
39447: PPUSH
39448: LD_VAR 0 5
39452: PPUSH
39453: CALL_OW 307
39457: IFFALSE 39299
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39459: LD_VAR 0 7
39463: PPUSH
39464: LD_VAR 0 4
39468: PPUSH
39469: LD_VAR 0 5
39473: PPUSH
39474: LD_VAR 0 8
39478: PUSH
39479: LD_VAR 0 3
39483: ARRAY
39484: PPUSH
39485: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39489: LD_INT 35
39491: PPUSH
39492: CALL_OW 67
// until not HasTask ( tmp ) ;
39496: LD_VAR 0 7
39500: PPUSH
39501: CALL_OW 314
39505: NOT
39506: IFFALSE 39489
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39508: LD_ADDR_EXP 86
39512: PUSH
39513: LD_EXP 86
39517: PPUSH
39518: LD_VAR 0 2
39522: PUSH
39523: LD_EXP 86
39527: PUSH
39528: LD_VAR 0 2
39532: ARRAY
39533: PUSH
39534: LD_INT 1
39536: PLUS
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PPUSH
39542: LD_VAR 0 8
39546: PUSH
39547: LD_VAR 0 3
39551: ARRAY
39552: PPUSH
39553: CALL 54168 0 3
39557: ST_TO_ADDR
// end ;
39558: GO 39216
39560: POP
39561: POP
// MC_Reset ( i , 124 ) ;
39562: LD_VAR 0 2
39566: PPUSH
39567: LD_INT 124
39569: PPUSH
39570: CALL 22646 0 2
// end ; end ;
39574: GO 38971
39576: POP
39577: POP
// end ;
39578: LD_VAR 0 1
39582: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39583: LD_INT 0
39585: PPUSH
39586: PPUSH
39587: PPUSH
// if not mc_bases then
39588: LD_EXP 50
39592: NOT
39593: IFFALSE 39597
// exit ;
39595: GO 40203
// for i = 1 to mc_bases do
39597: LD_ADDR_VAR 0 2
39601: PUSH
39602: DOUBLE
39603: LD_INT 1
39605: DEC
39606: ST_TO_ADDR
39607: LD_EXP 50
39611: PUSH
39612: FOR_TO
39613: IFFALSE 40201
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39615: LD_ADDR_VAR 0 3
39619: PUSH
39620: LD_EXP 50
39624: PUSH
39625: LD_VAR 0 2
39629: ARRAY
39630: PPUSH
39631: LD_INT 25
39633: PUSH
39634: LD_INT 4
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PPUSH
39641: CALL_OW 72
39645: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39646: LD_VAR 0 3
39650: NOT
39651: PUSH
39652: LD_EXP 87
39656: PUSH
39657: LD_VAR 0 2
39661: ARRAY
39662: NOT
39663: OR
39664: PUSH
39665: LD_EXP 50
39669: PUSH
39670: LD_VAR 0 2
39674: ARRAY
39675: PPUSH
39676: LD_INT 2
39678: PUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 30
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: LIST
39703: PPUSH
39704: CALL_OW 72
39708: NOT
39709: OR
39710: IFFALSE 39760
// begin if mc_deposits_finder [ i ] then
39712: LD_EXP 88
39716: PUSH
39717: LD_VAR 0 2
39721: ARRAY
39722: IFFALSE 39758
// begin MC_Reset ( i , 125 ) ;
39724: LD_VAR 0 2
39728: PPUSH
39729: LD_INT 125
39731: PPUSH
39732: CALL 22646 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39736: LD_ADDR_EXP 88
39740: PUSH
39741: LD_EXP 88
39745: PPUSH
39746: LD_VAR 0 2
39750: PPUSH
39751: EMPTY
39752: PPUSH
39753: CALL_OW 1
39757: ST_TO_ADDR
// end ; continue ;
39758: GO 39612
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39760: LD_EXP 87
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: PUSH
39771: LD_INT 1
39773: ARRAY
39774: PUSH
39775: LD_INT 3
39777: ARRAY
39778: PUSH
39779: LD_INT 1
39781: EQUAL
39782: PUSH
39783: LD_INT 20
39785: PPUSH
39786: LD_EXP 76
39790: PUSH
39791: LD_VAR 0 2
39795: ARRAY
39796: PPUSH
39797: CALL_OW 321
39801: PUSH
39802: LD_INT 2
39804: NONEQUAL
39805: AND
39806: IFFALSE 39856
// begin if mc_deposits_finder [ i ] then
39808: LD_EXP 88
39812: PUSH
39813: LD_VAR 0 2
39817: ARRAY
39818: IFFALSE 39854
// begin MC_Reset ( i , 125 ) ;
39820: LD_VAR 0 2
39824: PPUSH
39825: LD_INT 125
39827: PPUSH
39828: CALL 22646 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39832: LD_ADDR_EXP 88
39836: PUSH
39837: LD_EXP 88
39841: PPUSH
39842: LD_VAR 0 2
39846: PPUSH
39847: EMPTY
39848: PPUSH
39849: CALL_OW 1
39853: ST_TO_ADDR
// end ; continue ;
39854: GO 39612
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39856: LD_EXP 87
39860: PUSH
39861: LD_VAR 0 2
39865: ARRAY
39866: PUSH
39867: LD_INT 1
39869: ARRAY
39870: PUSH
39871: LD_INT 1
39873: ARRAY
39874: PPUSH
39875: LD_EXP 87
39879: PUSH
39880: LD_VAR 0 2
39884: ARRAY
39885: PUSH
39886: LD_INT 1
39888: ARRAY
39889: PUSH
39890: LD_INT 2
39892: ARRAY
39893: PPUSH
39894: LD_EXP 76
39898: PUSH
39899: LD_VAR 0 2
39903: ARRAY
39904: PPUSH
39905: CALL_OW 440
39909: IFFALSE 39952
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39911: LD_ADDR_EXP 87
39915: PUSH
39916: LD_EXP 87
39920: PPUSH
39921: LD_VAR 0 2
39925: PPUSH
39926: LD_EXP 87
39930: PUSH
39931: LD_VAR 0 2
39935: ARRAY
39936: PPUSH
39937: LD_INT 1
39939: PPUSH
39940: CALL_OW 3
39944: PPUSH
39945: CALL_OW 1
39949: ST_TO_ADDR
39950: GO 40199
// begin if not mc_deposits_finder [ i ] then
39952: LD_EXP 88
39956: PUSH
39957: LD_VAR 0 2
39961: ARRAY
39962: NOT
39963: IFFALSE 40015
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39965: LD_ADDR_EXP 88
39969: PUSH
39970: LD_EXP 88
39974: PPUSH
39975: LD_VAR 0 2
39979: PPUSH
39980: LD_VAR 0 3
39984: PUSH
39985: LD_INT 1
39987: ARRAY
39988: PUSH
39989: EMPTY
39990: LIST
39991: PPUSH
39992: CALL_OW 1
39996: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39997: LD_VAR 0 3
40001: PUSH
40002: LD_INT 1
40004: ARRAY
40005: PPUSH
40006: LD_INT 125
40008: PPUSH
40009: CALL_OW 109
// end else
40013: GO 40199
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40015: LD_EXP 88
40019: PUSH
40020: LD_VAR 0 2
40024: ARRAY
40025: PUSH
40026: LD_INT 1
40028: ARRAY
40029: PPUSH
40030: CALL_OW 310
40034: IFFALSE 40057
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40036: LD_EXP 88
40040: PUSH
40041: LD_VAR 0 2
40045: ARRAY
40046: PUSH
40047: LD_INT 1
40049: ARRAY
40050: PPUSH
40051: CALL_OW 122
40055: GO 40199
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40057: LD_EXP 88
40061: PUSH
40062: LD_VAR 0 2
40066: ARRAY
40067: PUSH
40068: LD_INT 1
40070: ARRAY
40071: PPUSH
40072: CALL_OW 314
40076: NOT
40077: PUSH
40078: LD_EXP 88
40082: PUSH
40083: LD_VAR 0 2
40087: ARRAY
40088: PUSH
40089: LD_INT 1
40091: ARRAY
40092: PPUSH
40093: LD_EXP 87
40097: PUSH
40098: LD_VAR 0 2
40102: ARRAY
40103: PUSH
40104: LD_INT 1
40106: ARRAY
40107: PUSH
40108: LD_INT 1
40110: ARRAY
40111: PPUSH
40112: LD_EXP 87
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PUSH
40123: LD_INT 1
40125: ARRAY
40126: PUSH
40127: LD_INT 2
40129: ARRAY
40130: PPUSH
40131: CALL_OW 297
40135: PUSH
40136: LD_INT 6
40138: GREATER
40139: AND
40140: IFFALSE 40199
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40142: LD_EXP 88
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: PUSH
40153: LD_INT 1
40155: ARRAY
40156: PPUSH
40157: LD_EXP 87
40161: PUSH
40162: LD_VAR 0 2
40166: ARRAY
40167: PUSH
40168: LD_INT 1
40170: ARRAY
40171: PUSH
40172: LD_INT 1
40174: ARRAY
40175: PPUSH
40176: LD_EXP 87
40180: PUSH
40181: LD_VAR 0 2
40185: ARRAY
40186: PUSH
40187: LD_INT 1
40189: ARRAY
40190: PUSH
40191: LD_INT 2
40193: ARRAY
40194: PPUSH
40195: CALL_OW 111
// end ; end ; end ;
40199: GO 39612
40201: POP
40202: POP
// end ;
40203: LD_VAR 0 1
40207: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40208: LD_INT 0
40210: PPUSH
40211: PPUSH
40212: PPUSH
40213: PPUSH
40214: PPUSH
40215: PPUSH
40216: PPUSH
40217: PPUSH
40218: PPUSH
40219: PPUSH
40220: PPUSH
// if not mc_bases then
40221: LD_EXP 50
40225: NOT
40226: IFFALSE 40230
// exit ;
40228: GO 41170
// for i = 1 to mc_bases do
40230: LD_ADDR_VAR 0 2
40234: PUSH
40235: DOUBLE
40236: LD_INT 1
40238: DEC
40239: ST_TO_ADDR
40240: LD_EXP 50
40244: PUSH
40245: FOR_TO
40246: IFFALSE 41168
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40248: LD_EXP 50
40252: PUSH
40253: LD_VAR 0 2
40257: ARRAY
40258: NOT
40259: PUSH
40260: LD_EXP 73
40264: PUSH
40265: LD_VAR 0 2
40269: ARRAY
40270: OR
40271: IFFALSE 40275
// continue ;
40273: GO 40245
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40275: LD_ADDR_VAR 0 7
40279: PUSH
40280: LD_EXP 50
40284: PUSH
40285: LD_VAR 0 2
40289: ARRAY
40290: PUSH
40291: LD_INT 1
40293: ARRAY
40294: PPUSH
40295: CALL_OW 248
40299: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40300: LD_VAR 0 7
40304: PUSH
40305: LD_INT 3
40307: EQUAL
40308: PUSH
40309: LD_EXP 69
40313: PUSH
40314: LD_VAR 0 2
40318: ARRAY
40319: PUSH
40320: LD_EXP 72
40324: PUSH
40325: LD_VAR 0 2
40329: ARRAY
40330: UNION
40331: PPUSH
40332: LD_INT 33
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PPUSH
40342: CALL_OW 72
40346: NOT
40347: OR
40348: IFFALSE 40352
// continue ;
40350: GO 40245
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40352: LD_ADDR_VAR 0 9
40356: PUSH
40357: LD_EXP 50
40361: PUSH
40362: LD_VAR 0 2
40366: ARRAY
40367: PPUSH
40368: LD_INT 30
40370: PUSH
40371: LD_INT 36
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PPUSH
40378: CALL_OW 72
40382: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40383: LD_ADDR_VAR 0 10
40387: PUSH
40388: LD_EXP 69
40392: PUSH
40393: LD_VAR 0 2
40397: ARRAY
40398: PPUSH
40399: LD_INT 34
40401: PUSH
40402: LD_INT 31
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PPUSH
40409: CALL_OW 72
40413: ST_TO_ADDR
// if not cts and not mcts then
40414: LD_VAR 0 9
40418: NOT
40419: PUSH
40420: LD_VAR 0 10
40424: NOT
40425: AND
40426: IFFALSE 40430
// continue ;
40428: GO 40245
// x := cts ;
40430: LD_ADDR_VAR 0 11
40434: PUSH
40435: LD_VAR 0 9
40439: ST_TO_ADDR
// if not x then
40440: LD_VAR 0 11
40444: NOT
40445: IFFALSE 40457
// x := mcts ;
40447: LD_ADDR_VAR 0 11
40451: PUSH
40452: LD_VAR 0 10
40456: ST_TO_ADDR
// if not x then
40457: LD_VAR 0 11
40461: NOT
40462: IFFALSE 40466
// continue ;
40464: GO 40245
// if mc_remote_driver [ i ] then
40466: LD_EXP 90
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: IFFALSE 40863
// for j in mc_remote_driver [ i ] do
40478: LD_ADDR_VAR 0 3
40482: PUSH
40483: LD_EXP 90
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PUSH
40494: FOR_IN
40495: IFFALSE 40861
// begin if GetClass ( j ) <> 3 then
40497: LD_VAR 0 3
40501: PPUSH
40502: CALL_OW 257
40506: PUSH
40507: LD_INT 3
40509: NONEQUAL
40510: IFFALSE 40563
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40512: LD_ADDR_EXP 90
40516: PUSH
40517: LD_EXP 90
40521: PPUSH
40522: LD_VAR 0 2
40526: PPUSH
40527: LD_EXP 90
40531: PUSH
40532: LD_VAR 0 2
40536: ARRAY
40537: PUSH
40538: LD_VAR 0 3
40542: DIFF
40543: PPUSH
40544: CALL_OW 1
40548: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40549: LD_VAR 0 3
40553: PPUSH
40554: LD_INT 0
40556: PPUSH
40557: CALL_OW 109
// continue ;
40561: GO 40494
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40563: LD_EXP 69
40567: PUSH
40568: LD_VAR 0 2
40572: ARRAY
40573: PPUSH
40574: LD_INT 34
40576: PUSH
40577: LD_INT 31
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 58
40586: PUSH
40587: EMPTY
40588: LIST
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PPUSH
40594: CALL_OW 72
40598: PUSH
40599: LD_VAR 0 3
40603: PPUSH
40604: CALL 84521 0 1
40608: NOT
40609: AND
40610: IFFALSE 40681
// begin if IsInUnit ( j ) then
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: IFFALSE 40632
// ComExitBuilding ( j ) ;
40623: LD_VAR 0 3
40627: PPUSH
40628: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40632: LD_VAR 0 3
40636: PPUSH
40637: LD_EXP 69
40641: PUSH
40642: LD_VAR 0 2
40646: ARRAY
40647: PPUSH
40648: LD_INT 34
40650: PUSH
40651: LD_INT 31
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 58
40660: PUSH
40661: EMPTY
40662: LIST
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PPUSH
40668: CALL_OW 72
40672: PUSH
40673: LD_INT 1
40675: ARRAY
40676: PPUSH
40677: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40681: LD_VAR 0 3
40685: PPUSH
40686: CALL_OW 310
40690: NOT
40691: PUSH
40692: LD_VAR 0 3
40696: PPUSH
40697: CALL_OW 310
40701: PPUSH
40702: CALL_OW 266
40706: PUSH
40707: LD_INT 36
40709: NONEQUAL
40710: PUSH
40711: LD_VAR 0 3
40715: PPUSH
40716: CALL 84521 0 1
40720: NOT
40721: AND
40722: OR
40723: IFFALSE 40859
// begin if IsInUnit ( j ) then
40725: LD_VAR 0 3
40729: PPUSH
40730: CALL_OW 310
40734: IFFALSE 40745
// ComExitBuilding ( j ) ;
40736: LD_VAR 0 3
40740: PPUSH
40741: CALL_OW 122
// ct := 0 ;
40745: LD_ADDR_VAR 0 8
40749: PUSH
40750: LD_INT 0
40752: ST_TO_ADDR
// for k in x do
40753: LD_ADDR_VAR 0 4
40757: PUSH
40758: LD_VAR 0 11
40762: PUSH
40763: FOR_IN
40764: IFFALSE 40837
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40766: LD_VAR 0 4
40770: PPUSH
40771: CALL_OW 264
40775: PUSH
40776: LD_INT 31
40778: EQUAL
40779: PUSH
40780: LD_VAR 0 4
40784: PPUSH
40785: CALL_OW 311
40789: NOT
40790: AND
40791: PUSH
40792: LD_VAR 0 4
40796: PPUSH
40797: CALL_OW 266
40801: PUSH
40802: LD_INT 36
40804: EQUAL
40805: PUSH
40806: LD_VAR 0 4
40810: PPUSH
40811: CALL_OW 313
40815: PUSH
40816: LD_INT 3
40818: LESS
40819: AND
40820: OR
40821: IFFALSE 40835
// begin ct := k ;
40823: LD_ADDR_VAR 0 8
40827: PUSH
40828: LD_VAR 0 4
40832: ST_TO_ADDR
// break ;
40833: GO 40837
// end ;
40835: GO 40763
40837: POP
40838: POP
// if ct then
40839: LD_VAR 0 8
40843: IFFALSE 40859
// ComEnterUnit ( j , ct ) ;
40845: LD_VAR 0 3
40849: PPUSH
40850: LD_VAR 0 8
40854: PPUSH
40855: CALL_OW 120
// end ; end ;
40859: GO 40494
40861: POP
40862: POP
// places := 0 ;
40863: LD_ADDR_VAR 0 5
40867: PUSH
40868: LD_INT 0
40870: ST_TO_ADDR
// for j = 1 to x do
40871: LD_ADDR_VAR 0 3
40875: PUSH
40876: DOUBLE
40877: LD_INT 1
40879: DEC
40880: ST_TO_ADDR
40881: LD_VAR 0 11
40885: PUSH
40886: FOR_TO
40887: IFFALSE 40963
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40889: LD_VAR 0 11
40893: PUSH
40894: LD_VAR 0 3
40898: ARRAY
40899: PPUSH
40900: CALL_OW 264
40904: PUSH
40905: LD_INT 31
40907: EQUAL
40908: IFFALSE 40926
// places := places + 1 else
40910: LD_ADDR_VAR 0 5
40914: PUSH
40915: LD_VAR 0 5
40919: PUSH
40920: LD_INT 1
40922: PLUS
40923: ST_TO_ADDR
40924: GO 40961
// if GetBType ( x [ j ] ) = b_control_tower then
40926: LD_VAR 0 11
40930: PUSH
40931: LD_VAR 0 3
40935: ARRAY
40936: PPUSH
40937: CALL_OW 266
40941: PUSH
40942: LD_INT 36
40944: EQUAL
40945: IFFALSE 40961
// places := places + 3 ;
40947: LD_ADDR_VAR 0 5
40951: PUSH
40952: LD_VAR 0 5
40956: PUSH
40957: LD_INT 3
40959: PLUS
40960: ST_TO_ADDR
40961: GO 40886
40963: POP
40964: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40965: LD_VAR 0 5
40969: PUSH
40970: LD_INT 0
40972: EQUAL
40973: PUSH
40974: LD_VAR 0 5
40978: PUSH
40979: LD_EXP 90
40983: PUSH
40984: LD_VAR 0 2
40988: ARRAY
40989: LESSEQUAL
40990: OR
40991: IFFALSE 40995
// continue ;
40993: GO 40245
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40995: LD_ADDR_VAR 0 6
40999: PUSH
41000: LD_EXP 50
41004: PUSH
41005: LD_VAR 0 2
41009: ARRAY
41010: PPUSH
41011: LD_INT 25
41013: PUSH
41014: LD_INT 3
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PPUSH
41021: CALL_OW 72
41025: PUSH
41026: LD_EXP 90
41030: PUSH
41031: LD_VAR 0 2
41035: ARRAY
41036: DIFF
41037: PPUSH
41038: LD_INT 3
41040: PPUSH
41041: CALL 85421 0 2
41045: ST_TO_ADDR
// for j in tmp do
41046: LD_ADDR_VAR 0 3
41050: PUSH
41051: LD_VAR 0 6
41055: PUSH
41056: FOR_IN
41057: IFFALSE 41092
// if GetTag ( j ) > 0 then
41059: LD_VAR 0 3
41063: PPUSH
41064: CALL_OW 110
41068: PUSH
41069: LD_INT 0
41071: GREATER
41072: IFFALSE 41090
// tmp := tmp diff j ;
41074: LD_ADDR_VAR 0 6
41078: PUSH
41079: LD_VAR 0 6
41083: PUSH
41084: LD_VAR 0 3
41088: DIFF
41089: ST_TO_ADDR
41090: GO 41056
41092: POP
41093: POP
// if not tmp then
41094: LD_VAR 0 6
41098: NOT
41099: IFFALSE 41103
// continue ;
41101: GO 40245
// if places then
41103: LD_VAR 0 5
41107: IFFALSE 41166
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41109: LD_ADDR_EXP 90
41113: PUSH
41114: LD_EXP 90
41118: PPUSH
41119: LD_VAR 0 2
41123: PPUSH
41124: LD_EXP 90
41128: PUSH
41129: LD_VAR 0 2
41133: ARRAY
41134: PUSH
41135: LD_VAR 0 6
41139: PUSH
41140: LD_INT 1
41142: ARRAY
41143: UNION
41144: PPUSH
41145: CALL_OW 1
41149: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41150: LD_VAR 0 6
41154: PUSH
41155: LD_INT 1
41157: ARRAY
41158: PPUSH
41159: LD_INT 126
41161: PPUSH
41162: CALL_OW 109
// end ; end ;
41166: GO 40245
41168: POP
41169: POP
// end ;
41170: LD_VAR 0 1
41174: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41175: LD_INT 0
41177: PPUSH
41178: PPUSH
41179: PPUSH
41180: PPUSH
41181: PPUSH
41182: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41183: LD_VAR 0 1
41187: NOT
41188: PUSH
41189: LD_VAR 0 2
41193: NOT
41194: OR
41195: PUSH
41196: LD_VAR 0 3
41200: NOT
41201: OR
41202: PUSH
41203: LD_VAR 0 4
41207: PUSH
41208: LD_INT 1
41210: PUSH
41211: LD_INT 2
41213: PUSH
41214: LD_INT 3
41216: PUSH
41217: LD_INT 4
41219: PUSH
41220: LD_INT 5
41222: PUSH
41223: LD_INT 8
41225: PUSH
41226: LD_INT 9
41228: PUSH
41229: LD_INT 15
41231: PUSH
41232: LD_INT 16
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: IN
41246: NOT
41247: OR
41248: IFFALSE 41252
// exit ;
41250: GO 42110
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41252: LD_ADDR_VAR 0 2
41256: PUSH
41257: LD_VAR 0 2
41261: PPUSH
41262: LD_INT 21
41264: PUSH
41265: LD_INT 3
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 24
41274: PUSH
41275: LD_INT 250
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PPUSH
41286: CALL_OW 72
41290: ST_TO_ADDR
// case class of 1 , 15 :
41291: LD_VAR 0 4
41295: PUSH
41296: LD_INT 1
41298: DOUBLE
41299: EQUAL
41300: IFTRUE 41310
41302: LD_INT 15
41304: DOUBLE
41305: EQUAL
41306: IFTRUE 41310
41308: GO 41395
41310: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41311: LD_ADDR_VAR 0 8
41315: PUSH
41316: LD_VAR 0 2
41320: PPUSH
41321: LD_INT 2
41323: PUSH
41324: LD_INT 30
41326: PUSH
41327: LD_INT 32
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 30
41336: PUSH
41337: LD_INT 31
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: LIST
41348: PPUSH
41349: CALL_OW 72
41353: PUSH
41354: LD_VAR 0 2
41358: PPUSH
41359: LD_INT 2
41361: PUSH
41362: LD_INT 30
41364: PUSH
41365: LD_INT 4
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 30
41374: PUSH
41375: LD_INT 5
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: LIST
41386: PPUSH
41387: CALL_OW 72
41391: ADD
41392: ST_TO_ADDR
41393: GO 41641
41395: LD_INT 2
41397: DOUBLE
41398: EQUAL
41399: IFTRUE 41409
41401: LD_INT 16
41403: DOUBLE
41404: EQUAL
41405: IFTRUE 41409
41407: GO 41455
41409: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41410: LD_ADDR_VAR 0 8
41414: PUSH
41415: LD_VAR 0 2
41419: PPUSH
41420: LD_INT 2
41422: PUSH
41423: LD_INT 30
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 30
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: LIST
41447: PPUSH
41448: CALL_OW 72
41452: ST_TO_ADDR
41453: GO 41641
41455: LD_INT 3
41457: DOUBLE
41458: EQUAL
41459: IFTRUE 41463
41461: GO 41509
41463: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41464: LD_ADDR_VAR 0 8
41468: PUSH
41469: LD_VAR 0 2
41473: PPUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 30
41479: PUSH
41480: LD_INT 2
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 30
41489: PUSH
41490: LD_INT 3
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: ST_TO_ADDR
41507: GO 41641
41509: LD_INT 4
41511: DOUBLE
41512: EQUAL
41513: IFTRUE 41517
41515: GO 41574
41517: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41518: LD_ADDR_VAR 0 8
41522: PUSH
41523: LD_VAR 0 2
41527: PPUSH
41528: LD_INT 2
41530: PUSH
41531: LD_INT 30
41533: PUSH
41534: LD_INT 6
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 30
41543: PUSH
41544: LD_INT 7
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 30
41553: PUSH
41554: LD_INT 8
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: PPUSH
41567: CALL_OW 72
41571: ST_TO_ADDR
41572: GO 41641
41574: LD_INT 5
41576: DOUBLE
41577: EQUAL
41578: IFTRUE 41594
41580: LD_INT 8
41582: DOUBLE
41583: EQUAL
41584: IFTRUE 41594
41586: LD_INT 9
41588: DOUBLE
41589: EQUAL
41590: IFTRUE 41594
41592: GO 41640
41594: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41595: LD_ADDR_VAR 0 8
41599: PUSH
41600: LD_VAR 0 2
41604: PPUSH
41605: LD_INT 2
41607: PUSH
41608: LD_INT 30
41610: PUSH
41611: LD_INT 4
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 30
41620: PUSH
41621: LD_INT 5
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: LIST
41632: PPUSH
41633: CALL_OW 72
41637: ST_TO_ADDR
41638: GO 41641
41640: POP
// if not tmp then
41641: LD_VAR 0 8
41645: NOT
41646: IFFALSE 41650
// exit ;
41648: GO 42110
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41650: LD_VAR 0 4
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: LD_INT 15
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: IN
41665: PUSH
41666: LD_EXP 59
41670: PUSH
41671: LD_VAR 0 1
41675: ARRAY
41676: AND
41677: IFFALSE 41833
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41679: LD_ADDR_VAR 0 9
41683: PUSH
41684: LD_EXP 59
41688: PUSH
41689: LD_VAR 0 1
41693: ARRAY
41694: PUSH
41695: LD_INT 1
41697: ARRAY
41698: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41699: LD_VAR 0 9
41703: PUSH
41704: LD_EXP 60
41708: PUSH
41709: LD_VAR 0 1
41713: ARRAY
41714: IN
41715: NOT
41716: IFFALSE 41831
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41718: LD_ADDR_EXP 60
41722: PUSH
41723: LD_EXP 60
41727: PPUSH
41728: LD_VAR 0 1
41732: PUSH
41733: LD_EXP 60
41737: PUSH
41738: LD_VAR 0 1
41742: ARRAY
41743: PUSH
41744: LD_INT 1
41746: PLUS
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PPUSH
41752: LD_VAR 0 9
41756: PPUSH
41757: CALL 54168 0 3
41761: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41762: LD_ADDR_EXP 59
41766: PUSH
41767: LD_EXP 59
41771: PPUSH
41772: LD_VAR 0 1
41776: PPUSH
41777: LD_EXP 59
41781: PUSH
41782: LD_VAR 0 1
41786: ARRAY
41787: PUSH
41788: LD_VAR 0 9
41792: DIFF
41793: PPUSH
41794: CALL_OW 1
41798: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41799: LD_VAR 0 3
41803: PPUSH
41804: LD_EXP 60
41808: PUSH
41809: LD_VAR 0 1
41813: ARRAY
41814: PUSH
41815: LD_EXP 60
41819: PUSH
41820: LD_VAR 0 1
41824: ARRAY
41825: ARRAY
41826: PPUSH
41827: CALL_OW 120
// end ; exit ;
41831: GO 42110
// end ; if tmp > 1 then
41833: LD_VAR 0 8
41837: PUSH
41838: LD_INT 1
41840: GREATER
41841: IFFALSE 41945
// for i = 2 to tmp do
41843: LD_ADDR_VAR 0 6
41847: PUSH
41848: DOUBLE
41849: LD_INT 2
41851: DEC
41852: ST_TO_ADDR
41853: LD_VAR 0 8
41857: PUSH
41858: FOR_TO
41859: IFFALSE 41943
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41861: LD_VAR 0 8
41865: PUSH
41866: LD_VAR 0 6
41870: ARRAY
41871: PPUSH
41872: CALL_OW 461
41876: PUSH
41877: LD_INT 6
41879: EQUAL
41880: IFFALSE 41941
// begin x := tmp [ i ] ;
41882: LD_ADDR_VAR 0 9
41886: PUSH
41887: LD_VAR 0 8
41891: PUSH
41892: LD_VAR 0 6
41896: ARRAY
41897: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41898: LD_ADDR_VAR 0 8
41902: PUSH
41903: LD_VAR 0 8
41907: PPUSH
41908: LD_VAR 0 6
41912: PPUSH
41913: CALL_OW 3
41917: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41918: LD_ADDR_VAR 0 8
41922: PUSH
41923: LD_VAR 0 8
41927: PPUSH
41928: LD_INT 1
41930: PPUSH
41931: LD_VAR 0 9
41935: PPUSH
41936: CALL_OW 2
41940: ST_TO_ADDR
// end ;
41941: GO 41858
41943: POP
41944: POP
// for i in tmp do
41945: LD_ADDR_VAR 0 6
41949: PUSH
41950: LD_VAR 0 8
41954: PUSH
41955: FOR_IN
41956: IFFALSE 41983
// begin if IsNotFull ( i ) then
41958: LD_VAR 0 6
41962: PPUSH
41963: CALL 51390 0 1
41967: IFFALSE 41981
// begin j := i ;
41969: LD_ADDR_VAR 0 7
41973: PUSH
41974: LD_VAR 0 6
41978: ST_TO_ADDR
// break ;
41979: GO 41983
// end ; end ;
41981: GO 41955
41983: POP
41984: POP
// if j then
41985: LD_VAR 0 7
41989: IFFALSE 42007
// ComEnterUnit ( unit , j ) else
41991: LD_VAR 0 3
41995: PPUSH
41996: LD_VAR 0 7
42000: PPUSH
42001: CALL_OW 120
42005: GO 42110
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42007: LD_ADDR_VAR 0 10
42011: PUSH
42012: LD_VAR 0 2
42016: PPUSH
42017: LD_INT 2
42019: PUSH
42020: LD_INT 30
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 30
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: LIST
42044: PPUSH
42045: CALL_OW 72
42049: ST_TO_ADDR
// if depot then
42050: LD_VAR 0 10
42054: IFFALSE 42110
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42056: LD_ADDR_VAR 0 10
42060: PUSH
42061: LD_VAR 0 10
42065: PPUSH
42066: LD_VAR 0 3
42070: PPUSH
42071: CALL_OW 74
42075: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42076: LD_VAR 0 3
42080: PPUSH
42081: LD_VAR 0 10
42085: PPUSH
42086: CALL_OW 296
42090: PUSH
42091: LD_INT 10
42093: GREATER
42094: IFFALSE 42110
// ComStandNearbyBuilding ( unit , depot ) ;
42096: LD_VAR 0 3
42100: PPUSH
42101: LD_VAR 0 10
42105: PPUSH
42106: CALL 50770 0 2
// end ; end ; end ;
42110: LD_VAR 0 5
42114: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42115: LD_INT 0
42117: PPUSH
42118: PPUSH
42119: PPUSH
42120: PPUSH
// if not mc_bases then
42121: LD_EXP 50
42125: NOT
42126: IFFALSE 42130
// exit ;
42128: GO 42369
// for i = 1 to mc_bases do
42130: LD_ADDR_VAR 0 2
42134: PUSH
42135: DOUBLE
42136: LD_INT 1
42138: DEC
42139: ST_TO_ADDR
42140: LD_EXP 50
42144: PUSH
42145: FOR_TO
42146: IFFALSE 42367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42148: LD_ADDR_VAR 0 4
42152: PUSH
42153: LD_EXP 50
42157: PUSH
42158: LD_VAR 0 2
42162: ARRAY
42163: PPUSH
42164: LD_INT 21
42166: PUSH
42167: LD_INT 1
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PPUSH
42174: CALL_OW 72
42178: PUSH
42179: LD_EXP 79
42183: PUSH
42184: LD_VAR 0 2
42188: ARRAY
42189: UNION
42190: ST_TO_ADDR
// if not tmp then
42191: LD_VAR 0 4
42195: NOT
42196: IFFALSE 42200
// continue ;
42198: GO 42145
// for j in tmp do
42200: LD_ADDR_VAR 0 3
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: FOR_IN
42211: IFFALSE 42363
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42213: LD_VAR 0 3
42217: PPUSH
42218: CALL_OW 110
42222: NOT
42223: PUSH
42224: LD_VAR 0 3
42228: PPUSH
42229: CALL_OW 314
42233: NOT
42234: AND
42235: PUSH
42236: LD_VAR 0 3
42240: PPUSH
42241: CALL_OW 311
42245: NOT
42246: AND
42247: PUSH
42248: LD_VAR 0 3
42252: PPUSH
42253: CALL_OW 310
42257: NOT
42258: AND
42259: PUSH
42260: LD_VAR 0 3
42264: PUSH
42265: LD_EXP 53
42269: PUSH
42270: LD_VAR 0 2
42274: ARRAY
42275: PUSH
42276: LD_INT 1
42278: ARRAY
42279: IN
42280: NOT
42281: AND
42282: PUSH
42283: LD_VAR 0 3
42287: PUSH
42288: LD_EXP 53
42292: PUSH
42293: LD_VAR 0 2
42297: ARRAY
42298: PUSH
42299: LD_INT 2
42301: ARRAY
42302: IN
42303: NOT
42304: AND
42305: PUSH
42306: LD_VAR 0 3
42310: PUSH
42311: LD_EXP 62
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: IN
42322: NOT
42323: AND
42324: IFFALSE 42361
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42326: LD_VAR 0 2
42330: PPUSH
42331: LD_EXP 50
42335: PUSH
42336: LD_VAR 0 2
42340: ARRAY
42341: PPUSH
42342: LD_VAR 0 3
42346: PPUSH
42347: LD_VAR 0 3
42351: PPUSH
42352: CALL_OW 257
42356: PPUSH
42357: CALL 41175 0 4
// end ;
42361: GO 42210
42363: POP
42364: POP
// end ;
42365: GO 42145
42367: POP
42368: POP
// end ;
42369: LD_VAR 0 1
42373: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42374: LD_INT 0
42376: PPUSH
42377: PPUSH
42378: PPUSH
42379: PPUSH
42380: PPUSH
42381: PPUSH
// if not mc_bases [ base ] then
42382: LD_EXP 50
42386: PUSH
42387: LD_VAR 0 1
42391: ARRAY
42392: NOT
42393: IFFALSE 42397
// exit ;
42395: GO 42598
// tmp := [ ] ;
42397: LD_ADDR_VAR 0 6
42401: PUSH
42402: EMPTY
42403: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42404: LD_ADDR_VAR 0 7
42408: PUSH
42409: LD_VAR 0 3
42413: PPUSH
42414: LD_INT 0
42416: PPUSH
42417: CALL_OW 517
42421: ST_TO_ADDR
// if not list then
42422: LD_VAR 0 7
42426: NOT
42427: IFFALSE 42431
// exit ;
42429: GO 42598
// c := Count ( list [ 1 ] ) ;
42431: LD_ADDR_VAR 0 9
42435: PUSH
42436: LD_VAR 0 7
42440: PUSH
42441: LD_INT 1
42443: ARRAY
42444: PPUSH
42445: CALL 51308 0 1
42449: ST_TO_ADDR
// if amount > c then
42450: LD_VAR 0 2
42454: PUSH
42455: LD_VAR 0 9
42459: GREATER
42460: IFFALSE 42472
// amount := c ;
42462: LD_ADDR_VAR 0 2
42466: PUSH
42467: LD_VAR 0 9
42471: ST_TO_ADDR
// for i := 1 to amount do
42472: LD_ADDR_VAR 0 5
42476: PUSH
42477: DOUBLE
42478: LD_INT 1
42480: DEC
42481: ST_TO_ADDR
42482: LD_VAR 0 2
42486: PUSH
42487: FOR_TO
42488: IFFALSE 42546
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42490: LD_ADDR_VAR 0 6
42494: PUSH
42495: LD_VAR 0 6
42499: PPUSH
42500: LD_VAR 0 5
42504: PPUSH
42505: LD_VAR 0 7
42509: PUSH
42510: LD_INT 1
42512: ARRAY
42513: PUSH
42514: LD_VAR 0 5
42518: ARRAY
42519: PUSH
42520: LD_VAR 0 7
42524: PUSH
42525: LD_INT 2
42527: ARRAY
42528: PUSH
42529: LD_VAR 0 5
42533: ARRAY
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PPUSH
42539: CALL_OW 1
42543: ST_TO_ADDR
42544: GO 42487
42546: POP
42547: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42548: LD_ADDR_EXP 63
42552: PUSH
42553: LD_EXP 63
42557: PPUSH
42558: LD_VAR 0 1
42562: PPUSH
42563: LD_VAR 0 6
42567: PPUSH
42568: CALL_OW 1
42572: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42573: LD_ADDR_EXP 65
42577: PUSH
42578: LD_EXP 65
42582: PPUSH
42583: LD_VAR 0 1
42587: PPUSH
42588: LD_VAR 0 3
42592: PPUSH
42593: CALL_OW 1
42597: ST_TO_ADDR
// end ;
42598: LD_VAR 0 4
42602: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42603: LD_INT 0
42605: PPUSH
// if not mc_bases [ base ] then
42606: LD_EXP 50
42610: PUSH
42611: LD_VAR 0 1
42615: ARRAY
42616: NOT
42617: IFFALSE 42621
// exit ;
42619: GO 42646
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42621: LD_ADDR_EXP 55
42625: PUSH
42626: LD_EXP 55
42630: PPUSH
42631: LD_VAR 0 1
42635: PPUSH
42636: LD_VAR 0 2
42640: PPUSH
42641: CALL_OW 1
42645: ST_TO_ADDR
// end ;
42646: LD_VAR 0 3
42650: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42651: LD_INT 0
42653: PPUSH
// if not mc_bases [ base ] then
42654: LD_EXP 50
42658: PUSH
42659: LD_VAR 0 1
42663: ARRAY
42664: NOT
42665: IFFALSE 42669
// exit ;
42667: GO 42706
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42669: LD_ADDR_EXP 55
42673: PUSH
42674: LD_EXP 55
42678: PPUSH
42679: LD_VAR 0 1
42683: PPUSH
42684: LD_EXP 55
42688: PUSH
42689: LD_VAR 0 1
42693: ARRAY
42694: PUSH
42695: LD_VAR 0 2
42699: UNION
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// end ;
42706: LD_VAR 0 3
42710: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42711: LD_INT 0
42713: PPUSH
// if not mc_bases [ base ] then
42714: LD_EXP 50
42718: PUSH
42719: LD_VAR 0 1
42723: ARRAY
42724: NOT
42725: IFFALSE 42729
// exit ;
42727: GO 42754
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42729: LD_ADDR_EXP 71
42733: PUSH
42734: LD_EXP 71
42738: PPUSH
42739: LD_VAR 0 1
42743: PPUSH
42744: LD_VAR 0 2
42748: PPUSH
42749: CALL_OW 1
42753: ST_TO_ADDR
// end ;
42754: LD_VAR 0 3
42758: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42759: LD_INT 0
42761: PPUSH
// if not mc_bases [ base ] then
42762: LD_EXP 50
42766: PUSH
42767: LD_VAR 0 1
42771: ARRAY
42772: NOT
42773: IFFALSE 42777
// exit ;
42775: GO 42814
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42777: LD_ADDR_EXP 71
42781: PUSH
42782: LD_EXP 71
42786: PPUSH
42787: LD_VAR 0 1
42791: PPUSH
42792: LD_EXP 71
42796: PUSH
42797: LD_VAR 0 1
42801: ARRAY
42802: PUSH
42803: LD_VAR 0 2
42807: ADD
42808: PPUSH
42809: CALL_OW 1
42813: ST_TO_ADDR
// end ;
42814: LD_VAR 0 3
42818: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42819: LD_INT 0
42821: PPUSH
// if not mc_bases [ base ] then
42822: LD_EXP 50
42826: PUSH
42827: LD_VAR 0 1
42831: ARRAY
42832: NOT
42833: IFFALSE 42837
// exit ;
42835: GO 42891
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42837: LD_ADDR_EXP 72
42841: PUSH
42842: LD_EXP 72
42846: PPUSH
42847: LD_VAR 0 1
42851: PPUSH
42852: LD_VAR 0 2
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42862: LD_ADDR_EXP 61
42866: PUSH
42867: LD_EXP 61
42871: PPUSH
42872: LD_VAR 0 1
42876: PPUSH
42877: LD_VAR 0 2
42881: PUSH
42882: LD_INT 0
42884: PLUS
42885: PPUSH
42886: CALL_OW 1
42890: ST_TO_ADDR
// end ;
42891: LD_VAR 0 3
42895: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42896: LD_INT 0
42898: PPUSH
// if not mc_bases [ base ] then
42899: LD_EXP 50
42903: PUSH
42904: LD_VAR 0 1
42908: ARRAY
42909: NOT
42910: IFFALSE 42914
// exit ;
42912: GO 42939
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42914: LD_ADDR_EXP 61
42918: PUSH
42919: LD_EXP 61
42923: PPUSH
42924: LD_VAR 0 1
42928: PPUSH
42929: LD_VAR 0 2
42933: PPUSH
42934: CALL_OW 1
42938: ST_TO_ADDR
// end ;
42939: LD_VAR 0 3
42943: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42944: LD_INT 0
42946: PPUSH
42947: PPUSH
42948: PPUSH
42949: PPUSH
// if not mc_bases [ base ] then
42950: LD_EXP 50
42954: PUSH
42955: LD_VAR 0 1
42959: ARRAY
42960: NOT
42961: IFFALSE 42965
// exit ;
42963: GO 43030
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42965: LD_ADDR_EXP 70
42969: PUSH
42970: LD_EXP 70
42974: PPUSH
42975: LD_VAR 0 1
42979: PUSH
42980: LD_EXP 70
42984: PUSH
42985: LD_VAR 0 1
42989: ARRAY
42990: PUSH
42991: LD_INT 1
42993: PLUS
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PPUSH
42999: LD_VAR 0 1
43003: PUSH
43004: LD_VAR 0 2
43008: PUSH
43009: LD_VAR 0 3
43013: PUSH
43014: LD_VAR 0 4
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: PPUSH
43025: CALL 54168 0 3
43029: ST_TO_ADDR
// end ;
43030: LD_VAR 0 5
43034: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43035: LD_INT 0
43037: PPUSH
// if not mc_bases [ base ] then
43038: LD_EXP 50
43042: PUSH
43043: LD_VAR 0 1
43047: ARRAY
43048: NOT
43049: IFFALSE 43053
// exit ;
43051: GO 43078
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43053: LD_ADDR_EXP 87
43057: PUSH
43058: LD_EXP 87
43062: PPUSH
43063: LD_VAR 0 1
43067: PPUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: CALL_OW 1
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MC_GetMinesField ( base ) ; begin
43083: LD_INT 0
43085: PPUSH
// result := mc_mines [ base ] ;
43086: LD_ADDR_VAR 0 2
43090: PUSH
43091: LD_EXP 63
43095: PUSH
43096: LD_VAR 0 1
43100: ARRAY
43101: ST_TO_ADDR
// end ;
43102: LD_VAR 0 2
43106: RET
// export function MC_GetProduceList ( base ) ; begin
43107: LD_INT 0
43109: PPUSH
// result := mc_produce [ base ] ;
43110: LD_ADDR_VAR 0 2
43114: PUSH
43115: LD_EXP 71
43119: PUSH
43120: LD_VAR 0 1
43124: ARRAY
43125: ST_TO_ADDR
// end ;
43126: LD_VAR 0 2
43130: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43131: LD_INT 0
43133: PPUSH
43134: PPUSH
// if not mc_bases then
43135: LD_EXP 50
43139: NOT
43140: IFFALSE 43144
// exit ;
43142: GO 43209
// if mc_bases [ base ] then
43144: LD_EXP 50
43148: PUSH
43149: LD_VAR 0 1
43153: ARRAY
43154: IFFALSE 43209
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43156: LD_ADDR_VAR 0 3
43160: PUSH
43161: LD_EXP 50
43165: PUSH
43166: LD_VAR 0 1
43170: ARRAY
43171: PPUSH
43172: LD_INT 30
43174: PUSH
43175: LD_VAR 0 2
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PPUSH
43184: CALL_OW 72
43188: ST_TO_ADDR
// if result then
43189: LD_VAR 0 3
43193: IFFALSE 43209
// result := result [ 1 ] ;
43195: LD_ADDR_VAR 0 3
43199: PUSH
43200: LD_VAR 0 3
43204: PUSH
43205: LD_INT 1
43207: ARRAY
43208: ST_TO_ADDR
// end ; end ;
43209: LD_VAR 0 3
43213: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43214: LD_INT 0
43216: PPUSH
43217: PPUSH
// if not mc_bases then
43218: LD_EXP 50
43222: NOT
43223: IFFALSE 43227
// exit ;
43225: GO 43272
// if mc_bases [ base ] then
43227: LD_EXP 50
43231: PUSH
43232: LD_VAR 0 1
43236: ARRAY
43237: IFFALSE 43272
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43239: LD_ADDR_VAR 0 3
43243: PUSH
43244: LD_EXP 50
43248: PUSH
43249: LD_VAR 0 1
43253: ARRAY
43254: PPUSH
43255: LD_INT 30
43257: PUSH
43258: LD_VAR 0 2
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PPUSH
43267: CALL_OW 72
43271: ST_TO_ADDR
// end ;
43272: LD_VAR 0 3
43276: RET
// export function MC_SetTame ( base , area ) ; begin
43277: LD_INT 0
43279: PPUSH
// if not mc_bases or not base then
43280: LD_EXP 50
43284: NOT
43285: PUSH
43286: LD_VAR 0 1
43290: NOT
43291: OR
43292: IFFALSE 43296
// exit ;
43294: GO 43321
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43296: LD_ADDR_EXP 78
43300: PUSH
43301: LD_EXP 78
43305: PPUSH
43306: LD_VAR 0 1
43310: PPUSH
43311: LD_VAR 0 2
43315: PPUSH
43316: CALL_OW 1
43320: ST_TO_ADDR
// end ;
43321: LD_VAR 0 3
43325: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43326: LD_INT 0
43328: PPUSH
43329: PPUSH
// if not mc_bases or not base then
43330: LD_EXP 50
43334: NOT
43335: PUSH
43336: LD_VAR 0 1
43340: NOT
43341: OR
43342: IFFALSE 43346
// exit ;
43344: GO 43448
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43346: LD_ADDR_VAR 0 4
43350: PUSH
43351: LD_EXP 50
43355: PUSH
43356: LD_VAR 0 1
43360: ARRAY
43361: PPUSH
43362: LD_INT 30
43364: PUSH
43365: LD_VAR 0 2
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PPUSH
43374: CALL_OW 72
43378: ST_TO_ADDR
// if not tmp then
43379: LD_VAR 0 4
43383: NOT
43384: IFFALSE 43388
// exit ;
43386: GO 43448
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43388: LD_ADDR_EXP 82
43392: PUSH
43393: LD_EXP 82
43397: PPUSH
43398: LD_VAR 0 1
43402: PPUSH
43403: LD_EXP 82
43407: PUSH
43408: LD_VAR 0 1
43412: ARRAY
43413: PPUSH
43414: LD_EXP 82
43418: PUSH
43419: LD_VAR 0 1
43423: ARRAY
43424: PUSH
43425: LD_INT 1
43427: PLUS
43428: PPUSH
43429: LD_VAR 0 4
43433: PUSH
43434: LD_INT 1
43436: ARRAY
43437: PPUSH
43438: CALL_OW 2
43442: PPUSH
43443: CALL_OW 1
43447: ST_TO_ADDR
// end ;
43448: LD_VAR 0 3
43452: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43453: LD_INT 0
43455: PPUSH
43456: PPUSH
// if not mc_bases or not base or not kinds then
43457: LD_EXP 50
43461: NOT
43462: PUSH
43463: LD_VAR 0 1
43467: NOT
43468: OR
43469: PUSH
43470: LD_VAR 0 2
43474: NOT
43475: OR
43476: IFFALSE 43480
// exit ;
43478: GO 43541
// for i in kinds do
43480: LD_ADDR_VAR 0 4
43484: PUSH
43485: LD_VAR 0 2
43489: PUSH
43490: FOR_IN
43491: IFFALSE 43539
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43493: LD_ADDR_EXP 84
43497: PUSH
43498: LD_EXP 84
43502: PPUSH
43503: LD_VAR 0 1
43507: PUSH
43508: LD_EXP 84
43512: PUSH
43513: LD_VAR 0 1
43517: ARRAY
43518: PUSH
43519: LD_INT 1
43521: PLUS
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PPUSH
43527: LD_VAR 0 4
43531: PPUSH
43532: CALL 54168 0 3
43536: ST_TO_ADDR
43537: GO 43490
43539: POP
43540: POP
// end ;
43541: LD_VAR 0 3
43545: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43546: LD_INT 0
43548: PPUSH
// if not mc_bases or not base or not areas then
43549: LD_EXP 50
43553: NOT
43554: PUSH
43555: LD_VAR 0 1
43559: NOT
43560: OR
43561: PUSH
43562: LD_VAR 0 2
43566: NOT
43567: OR
43568: IFFALSE 43572
// exit ;
43570: GO 43597
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43572: LD_ADDR_EXP 68
43576: PUSH
43577: LD_EXP 68
43581: PPUSH
43582: LD_VAR 0 1
43586: PPUSH
43587: LD_VAR 0 2
43591: PPUSH
43592: CALL_OW 1
43596: ST_TO_ADDR
// end ;
43597: LD_VAR 0 3
43601: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43602: LD_INT 0
43604: PPUSH
// if not mc_bases or not base or not teleports_exit then
43605: LD_EXP 50
43609: NOT
43610: PUSH
43611: LD_VAR 0 1
43615: NOT
43616: OR
43617: PUSH
43618: LD_VAR 0 2
43622: NOT
43623: OR
43624: IFFALSE 43628
// exit ;
43626: GO 43653
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43628: LD_ADDR_EXP 85
43632: PUSH
43633: LD_EXP 85
43637: PPUSH
43638: LD_VAR 0 1
43642: PPUSH
43643: LD_VAR 0 2
43647: PPUSH
43648: CALL_OW 1
43652: ST_TO_ADDR
// end ;
43653: LD_VAR 0 3
43657: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43658: LD_INT 0
43660: PPUSH
43661: PPUSH
43662: PPUSH
// if not mc_bases or not base or not ext_list then
43663: LD_EXP 50
43667: NOT
43668: PUSH
43669: LD_VAR 0 1
43673: NOT
43674: OR
43675: PUSH
43676: LD_VAR 0 5
43680: NOT
43681: OR
43682: IFFALSE 43686
// exit ;
43684: GO 43859
// tmp := GetFacExtXYD ( x , y , d ) ;
43686: LD_ADDR_VAR 0 8
43690: PUSH
43691: LD_VAR 0 2
43695: PPUSH
43696: LD_VAR 0 3
43700: PPUSH
43701: LD_VAR 0 4
43705: PPUSH
43706: CALL 84551 0 3
43710: ST_TO_ADDR
// if not tmp then
43711: LD_VAR 0 8
43715: NOT
43716: IFFALSE 43720
// exit ;
43718: GO 43859
// for i in tmp do
43720: LD_ADDR_VAR 0 7
43724: PUSH
43725: LD_VAR 0 8
43729: PUSH
43730: FOR_IN
43731: IFFALSE 43857
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43733: LD_ADDR_EXP 55
43737: PUSH
43738: LD_EXP 55
43742: PPUSH
43743: LD_VAR 0 1
43747: PPUSH
43748: LD_EXP 55
43752: PUSH
43753: LD_VAR 0 1
43757: ARRAY
43758: PPUSH
43759: LD_EXP 55
43763: PUSH
43764: LD_VAR 0 1
43768: ARRAY
43769: PUSH
43770: LD_INT 1
43772: PLUS
43773: PPUSH
43774: LD_VAR 0 5
43778: PUSH
43779: LD_INT 1
43781: ARRAY
43782: PUSH
43783: LD_VAR 0 7
43787: PUSH
43788: LD_INT 1
43790: ARRAY
43791: PUSH
43792: LD_VAR 0 7
43796: PUSH
43797: LD_INT 2
43799: ARRAY
43800: PUSH
43801: LD_VAR 0 7
43805: PUSH
43806: LD_INT 3
43808: ARRAY
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: PPUSH
43816: CALL_OW 2
43820: PPUSH
43821: CALL_OW 1
43825: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43826: LD_ADDR_VAR 0 5
43830: PUSH
43831: LD_VAR 0 5
43835: PPUSH
43836: LD_INT 1
43838: PPUSH
43839: CALL_OW 3
43843: ST_TO_ADDR
// if not ext_list then
43844: LD_VAR 0 5
43848: NOT
43849: IFFALSE 43855
// exit ;
43851: POP
43852: POP
43853: GO 43859
// end ;
43855: GO 43730
43857: POP
43858: POP
// end ;
43859: LD_VAR 0 6
43863: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43864: LD_INT 0
43866: PPUSH
// if not mc_bases or not base or not weapon_list then
43867: LD_EXP 50
43871: NOT
43872: PUSH
43873: LD_VAR 0 1
43877: NOT
43878: OR
43879: PUSH
43880: LD_VAR 0 2
43884: NOT
43885: OR
43886: IFFALSE 43890
// exit ;
43888: GO 43915
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43890: LD_ADDR_EXP 89
43894: PUSH
43895: LD_EXP 89
43899: PPUSH
43900: LD_VAR 0 1
43904: PPUSH
43905: LD_VAR 0 2
43909: PPUSH
43910: CALL_OW 1
43914: ST_TO_ADDR
// end ;
43915: LD_VAR 0 3
43919: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43920: LD_INT 0
43922: PPUSH
// if not mc_bases or not base or not tech_list then
43923: LD_EXP 50
43927: NOT
43928: PUSH
43929: LD_VAR 0 1
43933: NOT
43934: OR
43935: PUSH
43936: LD_VAR 0 2
43940: NOT
43941: OR
43942: IFFALSE 43946
// exit ;
43944: GO 43971
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43946: LD_ADDR_EXP 77
43950: PUSH
43951: LD_EXP 77
43955: PPUSH
43956: LD_VAR 0 1
43960: PPUSH
43961: LD_VAR 0 2
43965: PPUSH
43966: CALL_OW 1
43970: ST_TO_ADDR
// end ;
43971: LD_VAR 0 3
43975: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43976: LD_INT 0
43978: PPUSH
// if not mc_bases or not parking_area or not base then
43979: LD_EXP 50
43983: NOT
43984: PUSH
43985: LD_VAR 0 2
43989: NOT
43990: OR
43991: PUSH
43992: LD_VAR 0 1
43996: NOT
43997: OR
43998: IFFALSE 44002
// exit ;
44000: GO 44027
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44002: LD_ADDR_EXP 74
44006: PUSH
44007: LD_EXP 74
44011: PPUSH
44012: LD_VAR 0 1
44016: PPUSH
44017: LD_VAR 0 2
44021: PPUSH
44022: CALL_OW 1
44026: ST_TO_ADDR
// end ;
44027: LD_VAR 0 3
44031: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44032: LD_INT 0
44034: PPUSH
// if not mc_bases or not base or not scan_area then
44035: LD_EXP 50
44039: NOT
44040: PUSH
44041: LD_VAR 0 1
44045: NOT
44046: OR
44047: PUSH
44048: LD_VAR 0 2
44052: NOT
44053: OR
44054: IFFALSE 44058
// exit ;
44056: GO 44083
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44058: LD_ADDR_EXP 75
44062: PUSH
44063: LD_EXP 75
44067: PPUSH
44068: LD_VAR 0 1
44072: PPUSH
44073: LD_VAR 0 2
44077: PPUSH
44078: CALL_OW 1
44082: ST_TO_ADDR
// end ;
44083: LD_VAR 0 3
44087: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44088: LD_INT 0
44090: PPUSH
44091: PPUSH
// if not mc_bases or not base then
44092: LD_EXP 50
44096: NOT
44097: PUSH
44098: LD_VAR 0 1
44102: NOT
44103: OR
44104: IFFALSE 44108
// exit ;
44106: GO 44172
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44108: LD_ADDR_VAR 0 3
44112: PUSH
44113: LD_INT 1
44115: PUSH
44116: LD_INT 2
44118: PUSH
44119: LD_INT 3
44121: PUSH
44122: LD_INT 4
44124: PUSH
44125: LD_INT 11
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44135: LD_ADDR_EXP 77
44139: PUSH
44140: LD_EXP 77
44144: PPUSH
44145: LD_VAR 0 1
44149: PPUSH
44150: LD_EXP 77
44154: PUSH
44155: LD_VAR 0 1
44159: ARRAY
44160: PUSH
44161: LD_VAR 0 3
44165: DIFF
44166: PPUSH
44167: CALL_OW 1
44171: ST_TO_ADDR
// end ;
44172: LD_VAR 0 2
44176: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44177: LD_INT 0
44179: PPUSH
// result := mc_vehicles [ base ] ;
44180: LD_ADDR_VAR 0 3
44184: PUSH
44185: LD_EXP 69
44189: PUSH
44190: LD_VAR 0 1
44194: ARRAY
44195: ST_TO_ADDR
// if onlyCombat then
44196: LD_VAR 0 2
44200: IFFALSE 44372
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44202: LD_ADDR_VAR 0 3
44206: PUSH
44207: LD_VAR 0 3
44211: PUSH
44212: LD_VAR 0 3
44216: PPUSH
44217: LD_INT 2
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 12
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 51
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 89
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 32
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 13
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 34
44272: PUSH
44273: LD_INT 52
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: LD_INT 34
44282: PUSH
44283: LD_INT 88
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 34
44292: PUSH
44293: LD_INT 14
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 34
44302: PUSH
44303: LD_INT 53
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 34
44312: PUSH
44313: LD_INT 98
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 34
44322: PUSH
44323: LD_INT 31
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 34
44332: PUSH
44333: LD_INT 48
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 34
44342: PUSH
44343: LD_INT 8
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: PPUSH
44366: CALL_OW 72
44370: DIFF
44371: ST_TO_ADDR
// end ; end_of_file
44372: LD_VAR 0 3
44376: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44377: LD_INT 0
44379: PPUSH
44380: PPUSH
44381: PPUSH
// if not mc_bases or not skirmish then
44382: LD_EXP 50
44386: NOT
44387: PUSH
44388: LD_EXP 48
44392: NOT
44393: OR
44394: IFFALSE 44398
// exit ;
44396: GO 44563
// for i = 1 to mc_bases do
44398: LD_ADDR_VAR 0 4
44402: PUSH
44403: DOUBLE
44404: LD_INT 1
44406: DEC
44407: ST_TO_ADDR
44408: LD_EXP 50
44412: PUSH
44413: FOR_TO
44414: IFFALSE 44561
// begin if sci in mc_bases [ i ] then
44416: LD_VAR 0 2
44420: PUSH
44421: LD_EXP 50
44425: PUSH
44426: LD_VAR 0 4
44430: ARRAY
44431: IN
44432: IFFALSE 44559
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44434: LD_ADDR_EXP 79
44438: PUSH
44439: LD_EXP 79
44443: PPUSH
44444: LD_VAR 0 4
44448: PUSH
44449: LD_EXP 79
44453: PUSH
44454: LD_VAR 0 4
44458: ARRAY
44459: PUSH
44460: LD_INT 1
44462: PLUS
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PPUSH
44468: LD_VAR 0 1
44472: PPUSH
44473: CALL 54168 0 3
44477: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44478: LD_ADDR_VAR 0 5
44482: PUSH
44483: LD_EXP 50
44487: PUSH
44488: LD_VAR 0 4
44492: ARRAY
44493: PPUSH
44494: LD_INT 2
44496: PUSH
44497: LD_INT 30
44499: PUSH
44500: LD_INT 0
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 30
44509: PUSH
44510: LD_INT 1
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: PPUSH
44522: CALL_OW 72
44526: PPUSH
44527: LD_VAR 0 1
44531: PPUSH
44532: CALL_OW 74
44536: ST_TO_ADDR
// if tmp then
44537: LD_VAR 0 5
44541: IFFALSE 44557
// ComStandNearbyBuilding ( ape , tmp ) ;
44543: LD_VAR 0 1
44547: PPUSH
44548: LD_VAR 0 5
44552: PPUSH
44553: CALL 50770 0 2
// break ;
44557: GO 44561
// end ; end ;
44559: GO 44413
44561: POP
44562: POP
// end ;
44563: LD_VAR 0 3
44567: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44568: LD_INT 0
44570: PPUSH
44571: PPUSH
44572: PPUSH
// if not mc_bases or not skirmish then
44573: LD_EXP 50
44577: NOT
44578: PUSH
44579: LD_EXP 48
44583: NOT
44584: OR
44585: IFFALSE 44589
// exit ;
44587: GO 44678
// for i = 1 to mc_bases do
44589: LD_ADDR_VAR 0 4
44593: PUSH
44594: DOUBLE
44595: LD_INT 1
44597: DEC
44598: ST_TO_ADDR
44599: LD_EXP 50
44603: PUSH
44604: FOR_TO
44605: IFFALSE 44676
// begin if building in mc_busy_turret_list [ i ] then
44607: LD_VAR 0 1
44611: PUSH
44612: LD_EXP 60
44616: PUSH
44617: LD_VAR 0 4
44621: ARRAY
44622: IN
44623: IFFALSE 44674
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44625: LD_ADDR_VAR 0 5
44629: PUSH
44630: LD_EXP 60
44634: PUSH
44635: LD_VAR 0 4
44639: ARRAY
44640: PUSH
44641: LD_VAR 0 1
44645: DIFF
44646: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44647: LD_ADDR_EXP 60
44651: PUSH
44652: LD_EXP 60
44656: PPUSH
44657: LD_VAR 0 4
44661: PPUSH
44662: LD_VAR 0 5
44666: PPUSH
44667: CALL_OW 1
44671: ST_TO_ADDR
// break ;
44672: GO 44676
// end ; end ;
44674: GO 44604
44676: POP
44677: POP
// end ;
44678: LD_VAR 0 3
44682: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44683: LD_INT 0
44685: PPUSH
44686: PPUSH
44687: PPUSH
// if not mc_bases or not skirmish then
44688: LD_EXP 50
44692: NOT
44693: PUSH
44694: LD_EXP 48
44698: NOT
44699: OR
44700: IFFALSE 44704
// exit ;
44702: GO 44903
// for i = 1 to mc_bases do
44704: LD_ADDR_VAR 0 5
44708: PUSH
44709: DOUBLE
44710: LD_INT 1
44712: DEC
44713: ST_TO_ADDR
44714: LD_EXP 50
44718: PUSH
44719: FOR_TO
44720: IFFALSE 44901
// if building in mc_bases [ i ] then
44722: LD_VAR 0 1
44726: PUSH
44727: LD_EXP 50
44731: PUSH
44732: LD_VAR 0 5
44736: ARRAY
44737: IN
44738: IFFALSE 44899
// begin tmp := mc_bases [ i ] diff building ;
44740: LD_ADDR_VAR 0 6
44744: PUSH
44745: LD_EXP 50
44749: PUSH
44750: LD_VAR 0 5
44754: ARRAY
44755: PUSH
44756: LD_VAR 0 1
44760: DIFF
44761: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44762: LD_ADDR_EXP 50
44766: PUSH
44767: LD_EXP 50
44771: PPUSH
44772: LD_VAR 0 5
44776: PPUSH
44777: LD_VAR 0 6
44781: PPUSH
44782: CALL_OW 1
44786: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44787: LD_VAR 0 1
44791: PUSH
44792: LD_EXP 58
44796: PUSH
44797: LD_VAR 0 5
44801: ARRAY
44802: IN
44803: IFFALSE 44842
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44805: LD_ADDR_EXP 58
44809: PUSH
44810: LD_EXP 58
44814: PPUSH
44815: LD_VAR 0 5
44819: PPUSH
44820: LD_EXP 58
44824: PUSH
44825: LD_VAR 0 5
44829: ARRAY
44830: PUSH
44831: LD_VAR 0 1
44835: DIFF
44836: PPUSH
44837: CALL_OW 1
44841: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44842: LD_VAR 0 1
44846: PUSH
44847: LD_EXP 59
44851: PUSH
44852: LD_VAR 0 5
44856: ARRAY
44857: IN
44858: IFFALSE 44897
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44860: LD_ADDR_EXP 59
44864: PUSH
44865: LD_EXP 59
44869: PPUSH
44870: LD_VAR 0 5
44874: PPUSH
44875: LD_EXP 59
44879: PUSH
44880: LD_VAR 0 5
44884: ARRAY
44885: PUSH
44886: LD_VAR 0 1
44890: DIFF
44891: PPUSH
44892: CALL_OW 1
44896: ST_TO_ADDR
// break ;
44897: GO 44901
// end ;
44899: GO 44719
44901: POP
44902: POP
// end ;
44903: LD_VAR 0 4
44907: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44908: LD_INT 0
44910: PPUSH
44911: PPUSH
44912: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44913: LD_EXP 50
44917: NOT
44918: PUSH
44919: LD_EXP 48
44923: NOT
44924: OR
44925: PUSH
44926: LD_VAR 0 3
44930: PUSH
44931: LD_EXP 76
44935: IN
44936: NOT
44937: OR
44938: IFFALSE 44942
// exit ;
44940: GO 45065
// for i = 1 to mc_vehicles do
44942: LD_ADDR_VAR 0 6
44946: PUSH
44947: DOUBLE
44948: LD_INT 1
44950: DEC
44951: ST_TO_ADDR
44952: LD_EXP 69
44956: PUSH
44957: FOR_TO
44958: IFFALSE 45063
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44960: LD_VAR 0 2
44964: PUSH
44965: LD_EXP 69
44969: PUSH
44970: LD_VAR 0 6
44974: ARRAY
44975: IN
44976: PUSH
44977: LD_VAR 0 1
44981: PUSH
44982: LD_EXP 69
44986: PUSH
44987: LD_VAR 0 6
44991: ARRAY
44992: IN
44993: OR
44994: IFFALSE 45061
// begin tmp := mc_vehicles [ i ] diff old ;
44996: LD_ADDR_VAR 0 7
45000: PUSH
45001: LD_EXP 69
45005: PUSH
45006: LD_VAR 0 6
45010: ARRAY
45011: PUSH
45012: LD_VAR 0 2
45016: DIFF
45017: ST_TO_ADDR
// tmp := tmp diff new ;
45018: LD_ADDR_VAR 0 7
45022: PUSH
45023: LD_VAR 0 7
45027: PUSH
45028: LD_VAR 0 1
45032: DIFF
45033: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45034: LD_ADDR_EXP 69
45038: PUSH
45039: LD_EXP 69
45043: PPUSH
45044: LD_VAR 0 6
45048: PPUSH
45049: LD_VAR 0 7
45053: PPUSH
45054: CALL_OW 1
45058: ST_TO_ADDR
// break ;
45059: GO 45063
// end ;
45061: GO 44957
45063: POP
45064: POP
// end ;
45065: LD_VAR 0 5
45069: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45070: LD_INT 0
45072: PPUSH
45073: PPUSH
45074: PPUSH
45075: PPUSH
// if not mc_bases or not skirmish then
45076: LD_EXP 50
45080: NOT
45081: PUSH
45082: LD_EXP 48
45086: NOT
45087: OR
45088: IFFALSE 45092
// exit ;
45090: GO 45512
// repeat wait ( 0 0$1 ) ;
45092: LD_INT 35
45094: PPUSH
45095: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45099: LD_EXP 94
45103: NOT
45104: IFFALSE 45092
// mc_block_vehicle_constructed_thread := true ;
45106: LD_ADDR_EXP 94
45110: PUSH
45111: LD_INT 1
45113: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45114: LD_ADDR_VAR 0 5
45118: PUSH
45119: LD_VAR 0 1
45123: PPUSH
45124: CALL_OW 255
45128: ST_TO_ADDR
// for i = 1 to mc_bases do
45129: LD_ADDR_VAR 0 4
45133: PUSH
45134: DOUBLE
45135: LD_INT 1
45137: DEC
45138: ST_TO_ADDR
45139: LD_EXP 50
45143: PUSH
45144: FOR_TO
45145: IFFALSE 45502
// begin if factory in mc_bases [ i ] then
45147: LD_VAR 0 2
45151: PUSH
45152: LD_EXP 50
45156: PUSH
45157: LD_VAR 0 4
45161: ARRAY
45162: IN
45163: IFFALSE 45500
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45165: LD_EXP 72
45169: PUSH
45170: LD_VAR 0 4
45174: ARRAY
45175: PUSH
45176: LD_EXP 61
45180: PUSH
45181: LD_VAR 0 4
45185: ARRAY
45186: LESS
45187: PUSH
45188: LD_VAR 0 1
45192: PPUSH
45193: CALL_OW 264
45197: PUSH
45198: LD_INT 31
45200: PUSH
45201: LD_INT 32
45203: PUSH
45204: LD_INT 51
45206: PUSH
45207: LD_INT 89
45209: PUSH
45210: LD_INT 12
45212: PUSH
45213: LD_INT 30
45215: PUSH
45216: LD_INT 98
45218: PUSH
45219: LD_INT 11
45221: PUSH
45222: LD_INT 53
45224: PUSH
45225: LD_INT 14
45227: PUSH
45228: LD_INT 91
45230: PUSH
45231: LD_INT 29
45233: PUSH
45234: LD_INT 99
45236: PUSH
45237: LD_INT 13
45239: PUSH
45240: LD_INT 52
45242: PUSH
45243: LD_INT 88
45245: PUSH
45246: LD_INT 48
45248: PUSH
45249: LD_INT 8
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: IN
45272: NOT
45273: AND
45274: IFFALSE 45322
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45276: LD_ADDR_EXP 72
45280: PUSH
45281: LD_EXP 72
45285: PPUSH
45286: LD_VAR 0 4
45290: PUSH
45291: LD_EXP 72
45295: PUSH
45296: LD_VAR 0 4
45300: ARRAY
45301: PUSH
45302: LD_INT 1
45304: PLUS
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PPUSH
45310: LD_VAR 0 1
45314: PPUSH
45315: CALL 54168 0 3
45319: ST_TO_ADDR
45320: GO 45366
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45322: LD_ADDR_EXP 69
45326: PUSH
45327: LD_EXP 69
45331: PPUSH
45332: LD_VAR 0 4
45336: PUSH
45337: LD_EXP 69
45341: PUSH
45342: LD_VAR 0 4
45346: ARRAY
45347: PUSH
45348: LD_INT 1
45350: PLUS
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PPUSH
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL 54168 0 3
45365: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45366: LD_ADDR_EXP 94
45370: PUSH
45371: LD_INT 0
45373: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45374: LD_VAR 0 1
45378: PPUSH
45379: CALL_OW 263
45383: PUSH
45384: LD_INT 2
45386: EQUAL
45387: IFFALSE 45416
// begin repeat wait ( 0 0$3 ) ;
45389: LD_INT 105
45391: PPUSH
45392: CALL_OW 67
// Connect ( vehicle ) ;
45396: LD_VAR 0 1
45400: PPUSH
45401: CALL 57514 0 1
// until IsControledBy ( vehicle ) ;
45405: LD_VAR 0 1
45409: PPUSH
45410: CALL_OW 312
45414: IFFALSE 45389
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45416: LD_VAR 0 1
45420: PPUSH
45421: LD_EXP 74
45425: PUSH
45426: LD_VAR 0 4
45430: ARRAY
45431: PPUSH
45432: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45436: LD_VAR 0 1
45440: PPUSH
45441: CALL_OW 263
45445: PUSH
45446: LD_INT 1
45448: NONEQUAL
45449: IFFALSE 45453
// break ;
45451: GO 45502
// repeat wait ( 0 0$1 ) ;
45453: LD_INT 35
45455: PPUSH
45456: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45460: LD_VAR 0 1
45464: PPUSH
45465: LD_EXP 74
45469: PUSH
45470: LD_VAR 0 4
45474: ARRAY
45475: PPUSH
45476: CALL_OW 308
45480: IFFALSE 45453
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45482: LD_VAR 0 1
45486: PPUSH
45487: CALL_OW 311
45491: PPUSH
45492: CALL_OW 121
// exit ;
45496: POP
45497: POP
45498: GO 45512
// end ; end ;
45500: GO 45144
45502: POP
45503: POP
// mc_block_vehicle_constructed_thread := false ;
45504: LD_ADDR_EXP 94
45508: PUSH
45509: LD_INT 0
45511: ST_TO_ADDR
// end ;
45512: LD_VAR 0 3
45516: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
45522: PPUSH
// if not mc_bases or not skirmish then
45523: LD_EXP 50
45527: NOT
45528: PUSH
45529: LD_EXP 48
45533: NOT
45534: OR
45535: IFFALSE 45539
// exit ;
45537: GO 45892
// repeat wait ( 0 0$1 ) ;
45539: LD_INT 35
45541: PPUSH
45542: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45546: LD_VAR 0 2
45550: PPUSH
45551: LD_VAR 0 3
45555: PPUSH
45556: CALL_OW 284
45560: IFFALSE 45539
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45562: LD_VAR 0 2
45566: PPUSH
45567: LD_VAR 0 3
45571: PPUSH
45572: CALL_OW 283
45576: PUSH
45577: LD_INT 4
45579: EQUAL
45580: IFFALSE 45584
// exit ;
45582: GO 45892
// for i = 1 to mc_bases do
45584: LD_ADDR_VAR 0 7
45588: PUSH
45589: DOUBLE
45590: LD_INT 1
45592: DEC
45593: ST_TO_ADDR
45594: LD_EXP 50
45598: PUSH
45599: FOR_TO
45600: IFFALSE 45890
// begin if mc_crates_area [ i ] then
45602: LD_EXP 68
45606: PUSH
45607: LD_VAR 0 7
45611: ARRAY
45612: IFFALSE 45723
// for j in mc_crates_area [ i ] do
45614: LD_ADDR_VAR 0 8
45618: PUSH
45619: LD_EXP 68
45623: PUSH
45624: LD_VAR 0 7
45628: ARRAY
45629: PUSH
45630: FOR_IN
45631: IFFALSE 45721
// if InArea ( x , y , j ) then
45633: LD_VAR 0 2
45637: PPUSH
45638: LD_VAR 0 3
45642: PPUSH
45643: LD_VAR 0 8
45647: PPUSH
45648: CALL_OW 309
45652: IFFALSE 45719
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45654: LD_ADDR_EXP 66
45658: PUSH
45659: LD_EXP 66
45663: PPUSH
45664: LD_VAR 0 7
45668: PUSH
45669: LD_EXP 66
45673: PUSH
45674: LD_VAR 0 7
45678: ARRAY
45679: PUSH
45680: LD_INT 1
45682: PLUS
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PPUSH
45688: LD_VAR 0 4
45692: PUSH
45693: LD_VAR 0 2
45697: PUSH
45698: LD_VAR 0 3
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: LIST
45707: PPUSH
45708: CALL 54168 0 3
45712: ST_TO_ADDR
// exit ;
45713: POP
45714: POP
45715: POP
45716: POP
45717: GO 45892
// end ;
45719: GO 45630
45721: POP
45722: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45723: LD_ADDR_VAR 0 9
45727: PUSH
45728: LD_EXP 50
45732: PUSH
45733: LD_VAR 0 7
45737: ARRAY
45738: PPUSH
45739: LD_INT 2
45741: PUSH
45742: LD_INT 30
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 30
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: LIST
45766: PPUSH
45767: CALL_OW 72
45771: ST_TO_ADDR
// if not depot then
45772: LD_VAR 0 9
45776: NOT
45777: IFFALSE 45781
// continue ;
45779: GO 45599
// for j in depot do
45781: LD_ADDR_VAR 0 8
45785: PUSH
45786: LD_VAR 0 9
45790: PUSH
45791: FOR_IN
45792: IFFALSE 45886
// if GetDistUnitXY ( j , x , y ) < 30 then
45794: LD_VAR 0 8
45798: PPUSH
45799: LD_VAR 0 2
45803: PPUSH
45804: LD_VAR 0 3
45808: PPUSH
45809: CALL_OW 297
45813: PUSH
45814: LD_INT 30
45816: LESS
45817: IFFALSE 45884
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45819: LD_ADDR_EXP 66
45823: PUSH
45824: LD_EXP 66
45828: PPUSH
45829: LD_VAR 0 7
45833: PUSH
45834: LD_EXP 66
45838: PUSH
45839: LD_VAR 0 7
45843: ARRAY
45844: PUSH
45845: LD_INT 1
45847: PLUS
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PPUSH
45853: LD_VAR 0 4
45857: PUSH
45858: LD_VAR 0 2
45862: PUSH
45863: LD_VAR 0 3
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: LIST
45872: PPUSH
45873: CALL 54168 0 3
45877: ST_TO_ADDR
// exit ;
45878: POP
45879: POP
45880: POP
45881: POP
45882: GO 45892
// end ;
45884: GO 45791
45886: POP
45887: POP
// end ;
45888: GO 45599
45890: POP
45891: POP
// end ;
45892: LD_VAR 0 6
45896: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45897: LD_INT 0
45899: PPUSH
45900: PPUSH
45901: PPUSH
45902: PPUSH
// if not mc_bases or not skirmish then
45903: LD_EXP 50
45907: NOT
45908: PUSH
45909: LD_EXP 48
45913: NOT
45914: OR
45915: IFFALSE 45919
// exit ;
45917: GO 46196
// side := GetSide ( lab ) ;
45919: LD_ADDR_VAR 0 4
45923: PUSH
45924: LD_VAR 0 2
45928: PPUSH
45929: CALL_OW 255
45933: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45934: LD_VAR 0 4
45938: PUSH
45939: LD_EXP 76
45943: IN
45944: NOT
45945: PUSH
45946: LD_EXP 77
45950: NOT
45951: OR
45952: PUSH
45953: LD_EXP 50
45957: NOT
45958: OR
45959: IFFALSE 45963
// exit ;
45961: GO 46196
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45963: LD_ADDR_EXP 77
45967: PUSH
45968: LD_EXP 77
45972: PPUSH
45973: LD_VAR 0 4
45977: PPUSH
45978: LD_EXP 77
45982: PUSH
45983: LD_VAR 0 4
45987: ARRAY
45988: PUSH
45989: LD_VAR 0 1
45993: DIFF
45994: PPUSH
45995: CALL_OW 1
45999: ST_TO_ADDR
// for i = 1 to mc_bases do
46000: LD_ADDR_VAR 0 5
46004: PUSH
46005: DOUBLE
46006: LD_INT 1
46008: DEC
46009: ST_TO_ADDR
46010: LD_EXP 50
46014: PUSH
46015: FOR_TO
46016: IFFALSE 46194
// begin if lab in mc_bases [ i ] then
46018: LD_VAR 0 2
46022: PUSH
46023: LD_EXP 50
46027: PUSH
46028: LD_VAR 0 5
46032: ARRAY
46033: IN
46034: IFFALSE 46192
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46036: LD_VAR 0 1
46040: PUSH
46041: LD_INT 11
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 3
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: IN
46059: PUSH
46060: LD_EXP 80
46064: PUSH
46065: LD_VAR 0 5
46069: ARRAY
46070: AND
46071: IFFALSE 46192
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46073: LD_ADDR_VAR 0 6
46077: PUSH
46078: LD_EXP 80
46082: PUSH
46083: LD_VAR 0 5
46087: ARRAY
46088: PUSH
46089: LD_INT 1
46091: ARRAY
46092: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46093: LD_ADDR_EXP 80
46097: PUSH
46098: LD_EXP 80
46102: PPUSH
46103: LD_VAR 0 5
46107: PPUSH
46108: EMPTY
46109: PPUSH
46110: CALL_OW 1
46114: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46115: LD_VAR 0 6
46119: PPUSH
46120: LD_INT 0
46122: PPUSH
46123: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46127: LD_VAR 0 6
46131: PPUSH
46132: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46136: LD_ADDR_EXP 79
46140: PUSH
46141: LD_EXP 79
46145: PPUSH
46146: LD_VAR 0 5
46150: PPUSH
46151: LD_EXP 79
46155: PUSH
46156: LD_VAR 0 5
46160: ARRAY
46161: PPUSH
46162: LD_INT 1
46164: PPUSH
46165: LD_VAR 0 6
46169: PPUSH
46170: CALL_OW 2
46174: PPUSH
46175: CALL_OW 1
46179: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46180: LD_VAR 0 5
46184: PPUSH
46185: LD_INT 112
46187: PPUSH
46188: CALL 22646 0 2
// end ; end ; end ;
46192: GO 46015
46194: POP
46195: POP
// end ;
46196: LD_VAR 0 3
46200: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46201: LD_INT 0
46203: PPUSH
46204: PPUSH
46205: PPUSH
46206: PPUSH
46207: PPUSH
46208: PPUSH
46209: PPUSH
46210: PPUSH
// if not mc_bases or not skirmish then
46211: LD_EXP 50
46215: NOT
46216: PUSH
46217: LD_EXP 48
46221: NOT
46222: OR
46223: IFFALSE 46227
// exit ;
46225: GO 47596
// for i = 1 to mc_bases do
46227: LD_ADDR_VAR 0 3
46231: PUSH
46232: DOUBLE
46233: LD_INT 1
46235: DEC
46236: ST_TO_ADDR
46237: LD_EXP 50
46241: PUSH
46242: FOR_TO
46243: IFFALSE 47594
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46245: LD_VAR 0 1
46249: PUSH
46250: LD_EXP 50
46254: PUSH
46255: LD_VAR 0 3
46259: ARRAY
46260: IN
46261: PUSH
46262: LD_VAR 0 1
46266: PUSH
46267: LD_EXP 57
46271: PUSH
46272: LD_VAR 0 3
46276: ARRAY
46277: IN
46278: OR
46279: PUSH
46280: LD_VAR 0 1
46284: PUSH
46285: LD_EXP 72
46289: PUSH
46290: LD_VAR 0 3
46294: ARRAY
46295: IN
46296: OR
46297: PUSH
46298: LD_VAR 0 1
46302: PUSH
46303: LD_EXP 69
46307: PUSH
46308: LD_VAR 0 3
46312: ARRAY
46313: IN
46314: OR
46315: PUSH
46316: LD_VAR 0 1
46320: PUSH
46321: LD_EXP 79
46325: PUSH
46326: LD_VAR 0 3
46330: ARRAY
46331: IN
46332: OR
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_EXP 80
46343: PUSH
46344: LD_VAR 0 3
46348: ARRAY
46349: IN
46350: OR
46351: IFFALSE 47592
// begin if un in mc_ape [ i ] then
46353: LD_VAR 0 1
46357: PUSH
46358: LD_EXP 79
46362: PUSH
46363: LD_VAR 0 3
46367: ARRAY
46368: IN
46369: IFFALSE 46408
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46371: LD_ADDR_EXP 79
46375: PUSH
46376: LD_EXP 79
46380: PPUSH
46381: LD_VAR 0 3
46385: PPUSH
46386: LD_EXP 79
46390: PUSH
46391: LD_VAR 0 3
46395: ARRAY
46396: PUSH
46397: LD_VAR 0 1
46401: DIFF
46402: PPUSH
46403: CALL_OW 1
46407: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46408: LD_VAR 0 1
46412: PUSH
46413: LD_EXP 80
46417: PUSH
46418: LD_VAR 0 3
46422: ARRAY
46423: IN
46424: IFFALSE 46448
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46426: LD_ADDR_EXP 80
46430: PUSH
46431: LD_EXP 80
46435: PPUSH
46436: LD_VAR 0 3
46440: PPUSH
46441: EMPTY
46442: PPUSH
46443: CALL_OW 1
46447: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46448: LD_VAR 0 1
46452: PPUSH
46453: CALL_OW 247
46457: PUSH
46458: LD_INT 2
46460: EQUAL
46461: PUSH
46462: LD_VAR 0 1
46466: PPUSH
46467: CALL_OW 110
46471: PUSH
46472: LD_INT 20
46474: EQUAL
46475: PUSH
46476: LD_VAR 0 1
46480: PUSH
46481: LD_EXP 72
46485: PUSH
46486: LD_VAR 0 3
46490: ARRAY
46491: IN
46492: OR
46493: PUSH
46494: LD_VAR 0 1
46498: PPUSH
46499: CALL_OW 264
46503: PUSH
46504: LD_INT 12
46506: PUSH
46507: LD_INT 51
46509: PUSH
46510: LD_INT 89
46512: PUSH
46513: LD_INT 32
46515: PUSH
46516: LD_INT 13
46518: PUSH
46519: LD_INT 52
46521: PUSH
46522: LD_INT 31
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: IN
46534: OR
46535: AND
46536: IFFALSE 46844
// begin if un in mc_defender [ i ] then
46538: LD_VAR 0 1
46542: PUSH
46543: LD_EXP 72
46547: PUSH
46548: LD_VAR 0 3
46552: ARRAY
46553: IN
46554: IFFALSE 46593
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46556: LD_ADDR_EXP 72
46560: PUSH
46561: LD_EXP 72
46565: PPUSH
46566: LD_VAR 0 3
46570: PPUSH
46571: LD_EXP 72
46575: PUSH
46576: LD_VAR 0 3
46580: ARRAY
46581: PUSH
46582: LD_VAR 0 1
46586: DIFF
46587: PPUSH
46588: CALL_OW 1
46592: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46593: LD_ADDR_VAR 0 8
46597: PUSH
46598: LD_VAR 0 3
46602: PPUSH
46603: LD_INT 3
46605: PPUSH
46606: CALL 43214 0 2
46610: ST_TO_ADDR
// if fac then
46611: LD_VAR 0 8
46615: IFFALSE 46844
// begin for j in fac do
46617: LD_ADDR_VAR 0 4
46621: PUSH
46622: LD_VAR 0 8
46626: PUSH
46627: FOR_IN
46628: IFFALSE 46842
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46630: LD_ADDR_VAR 0 9
46634: PUSH
46635: LD_VAR 0 8
46639: PPUSH
46640: LD_VAR 0 1
46644: PPUSH
46645: CALL_OW 265
46649: PPUSH
46650: LD_VAR 0 1
46654: PPUSH
46655: CALL_OW 262
46659: PPUSH
46660: LD_VAR 0 1
46664: PPUSH
46665: CALL_OW 263
46669: PPUSH
46670: LD_VAR 0 1
46674: PPUSH
46675: CALL_OW 264
46679: PPUSH
46680: CALL 51666 0 5
46684: ST_TO_ADDR
// if components then
46685: LD_VAR 0 9
46689: IFFALSE 46840
// begin if GetWeapon ( un ) = ar_control_tower then
46691: LD_VAR 0 1
46695: PPUSH
46696: CALL_OW 264
46700: PUSH
46701: LD_INT 31
46703: EQUAL
46704: IFFALSE 46821
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46706: LD_VAR 0 1
46710: PPUSH
46711: CALL_OW 311
46715: PPUSH
46716: LD_INT 0
46718: PPUSH
46719: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46723: LD_ADDR_EXP 90
46727: PUSH
46728: LD_EXP 90
46732: PPUSH
46733: LD_VAR 0 3
46737: PPUSH
46738: LD_EXP 90
46742: PUSH
46743: LD_VAR 0 3
46747: ARRAY
46748: PUSH
46749: LD_VAR 0 1
46753: PPUSH
46754: CALL_OW 311
46758: DIFF
46759: PPUSH
46760: CALL_OW 1
46764: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46765: LD_ADDR_VAR 0 7
46769: PUSH
46770: LD_EXP 71
46774: PUSH
46775: LD_VAR 0 3
46779: ARRAY
46780: PPUSH
46781: LD_INT 1
46783: PPUSH
46784: LD_VAR 0 9
46788: PPUSH
46789: CALL_OW 2
46793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46794: LD_ADDR_EXP 71
46798: PUSH
46799: LD_EXP 71
46803: PPUSH
46804: LD_VAR 0 3
46808: PPUSH
46809: LD_VAR 0 7
46813: PPUSH
46814: CALL_OW 1
46818: ST_TO_ADDR
// end else
46819: GO 46838
// MC_InsertProduceList ( i , [ components ] ) ;
46821: LD_VAR 0 3
46825: PPUSH
46826: LD_VAR 0 9
46830: PUSH
46831: EMPTY
46832: LIST
46833: PPUSH
46834: CALL 42759 0 2
// break ;
46838: GO 46842
// end ; end ;
46840: GO 46627
46842: POP
46843: POP
// end ; end ; if GetType ( un ) = unit_building then
46844: LD_VAR 0 1
46848: PPUSH
46849: CALL_OW 247
46853: PUSH
46854: LD_INT 3
46856: EQUAL
46857: IFFALSE 47260
// begin btype := GetBType ( un ) ;
46859: LD_ADDR_VAR 0 5
46863: PUSH
46864: LD_VAR 0 1
46868: PPUSH
46869: CALL_OW 266
46873: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46874: LD_VAR 0 5
46878: PUSH
46879: LD_INT 29
46881: PUSH
46882: LD_INT 30
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: IN
46889: IFFALSE 46962
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46891: LD_VAR 0 1
46895: PPUSH
46896: CALL_OW 250
46900: PPUSH
46901: LD_VAR 0 1
46905: PPUSH
46906: CALL_OW 251
46910: PPUSH
46911: LD_VAR 0 1
46915: PPUSH
46916: CALL_OW 255
46920: PPUSH
46921: CALL_OW 440
46925: NOT
46926: IFFALSE 46962
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46928: LD_VAR 0 1
46932: PPUSH
46933: CALL_OW 250
46937: PPUSH
46938: LD_VAR 0 1
46942: PPUSH
46943: CALL_OW 251
46947: PPUSH
46948: LD_VAR 0 1
46952: PPUSH
46953: CALL_OW 255
46957: PPUSH
46958: CALL_OW 441
// end ; if btype = b_warehouse then
46962: LD_VAR 0 5
46966: PUSH
46967: LD_INT 1
46969: EQUAL
46970: IFFALSE 46988
// begin btype := b_depot ;
46972: LD_ADDR_VAR 0 5
46976: PUSH
46977: LD_INT 0
46979: ST_TO_ADDR
// pos := 1 ;
46980: LD_ADDR_VAR 0 6
46984: PUSH
46985: LD_INT 1
46987: ST_TO_ADDR
// end ; if btype = b_factory then
46988: LD_VAR 0 5
46992: PUSH
46993: LD_INT 3
46995: EQUAL
46996: IFFALSE 47014
// begin btype := b_workshop ;
46998: LD_ADDR_VAR 0 5
47002: PUSH
47003: LD_INT 2
47005: ST_TO_ADDR
// pos := 1 ;
47006: LD_ADDR_VAR 0 6
47010: PUSH
47011: LD_INT 1
47013: ST_TO_ADDR
// end ; if btype = b_barracks then
47014: LD_VAR 0 5
47018: PUSH
47019: LD_INT 5
47021: EQUAL
47022: IFFALSE 47032
// btype := b_armoury ;
47024: LD_ADDR_VAR 0 5
47028: PUSH
47029: LD_INT 4
47031: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47032: LD_VAR 0 5
47036: PUSH
47037: LD_INT 7
47039: PUSH
47040: LD_INT 8
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: IN
47047: IFFALSE 47057
// btype := b_lab ;
47049: LD_ADDR_VAR 0 5
47053: PUSH
47054: LD_INT 6
47056: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47057: LD_ADDR_EXP 55
47061: PUSH
47062: LD_EXP 55
47066: PPUSH
47067: LD_VAR 0 3
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: PUSH
47083: LD_INT 1
47085: PLUS
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PPUSH
47091: LD_VAR 0 5
47095: PUSH
47096: LD_VAR 0 1
47100: PPUSH
47101: CALL_OW 250
47105: PUSH
47106: LD_VAR 0 1
47110: PPUSH
47111: CALL_OW 251
47115: PUSH
47116: LD_VAR 0 1
47120: PPUSH
47121: CALL_OW 254
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: PPUSH
47132: CALL 54168 0 3
47136: ST_TO_ADDR
// if pos = 1 then
47137: LD_VAR 0 6
47141: PUSH
47142: LD_INT 1
47144: EQUAL
47145: IFFALSE 47260
// begin tmp := mc_build_list [ i ] ;
47147: LD_ADDR_VAR 0 7
47151: PUSH
47152: LD_EXP 55
47156: PUSH
47157: LD_VAR 0 3
47161: ARRAY
47162: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47163: LD_VAR 0 7
47167: PPUSH
47168: LD_INT 2
47170: PUSH
47171: LD_INT 30
47173: PUSH
47174: LD_INT 0
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: PUSH
47181: LD_INT 30
47183: PUSH
47184: LD_INT 1
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: PUSH
47191: EMPTY
47192: LIST
47193: LIST
47194: LIST
47195: PPUSH
47196: CALL_OW 72
47200: IFFALSE 47210
// pos := 2 ;
47202: LD_ADDR_VAR 0 6
47206: PUSH
47207: LD_INT 2
47209: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47210: LD_ADDR_VAR 0 7
47214: PUSH
47215: LD_VAR 0 7
47219: PPUSH
47220: LD_VAR 0 6
47224: PPUSH
47225: LD_VAR 0 7
47229: PPUSH
47230: CALL 54494 0 3
47234: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47235: LD_ADDR_EXP 55
47239: PUSH
47240: LD_EXP 55
47244: PPUSH
47245: LD_VAR 0 3
47249: PPUSH
47250: LD_VAR 0 7
47254: PPUSH
47255: CALL_OW 1
47259: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47260: LD_VAR 0 1
47264: PUSH
47265: LD_EXP 50
47269: PUSH
47270: LD_VAR 0 3
47274: ARRAY
47275: IN
47276: IFFALSE 47315
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47278: LD_ADDR_EXP 50
47282: PUSH
47283: LD_EXP 50
47287: PPUSH
47288: LD_VAR 0 3
47292: PPUSH
47293: LD_EXP 50
47297: PUSH
47298: LD_VAR 0 3
47302: ARRAY
47303: PUSH
47304: LD_VAR 0 1
47308: DIFF
47309: PPUSH
47310: CALL_OW 1
47314: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47315: LD_VAR 0 1
47319: PUSH
47320: LD_EXP 57
47324: PUSH
47325: LD_VAR 0 3
47329: ARRAY
47330: IN
47331: IFFALSE 47370
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47333: LD_ADDR_EXP 57
47337: PUSH
47338: LD_EXP 57
47342: PPUSH
47343: LD_VAR 0 3
47347: PPUSH
47348: LD_EXP 57
47352: PUSH
47353: LD_VAR 0 3
47357: ARRAY
47358: PUSH
47359: LD_VAR 0 1
47363: DIFF
47364: PPUSH
47365: CALL_OW 1
47369: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47370: LD_VAR 0 1
47374: PUSH
47375: LD_EXP 69
47379: PUSH
47380: LD_VAR 0 3
47384: ARRAY
47385: IN
47386: IFFALSE 47425
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47388: LD_ADDR_EXP 69
47392: PUSH
47393: LD_EXP 69
47397: PPUSH
47398: LD_VAR 0 3
47402: PPUSH
47403: LD_EXP 69
47407: PUSH
47408: LD_VAR 0 3
47412: ARRAY
47413: PUSH
47414: LD_VAR 0 1
47418: DIFF
47419: PPUSH
47420: CALL_OW 1
47424: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47425: LD_VAR 0 1
47429: PUSH
47430: LD_EXP 72
47434: PUSH
47435: LD_VAR 0 3
47439: ARRAY
47440: IN
47441: IFFALSE 47480
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47443: LD_ADDR_EXP 72
47447: PUSH
47448: LD_EXP 72
47452: PPUSH
47453: LD_VAR 0 3
47457: PPUSH
47458: LD_EXP 72
47462: PUSH
47463: LD_VAR 0 3
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 1
47473: DIFF
47474: PPUSH
47475: CALL_OW 1
47479: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47480: LD_VAR 0 1
47484: PUSH
47485: LD_EXP 59
47489: PUSH
47490: LD_VAR 0 3
47494: ARRAY
47495: IN
47496: IFFALSE 47535
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47498: LD_ADDR_EXP 59
47502: PUSH
47503: LD_EXP 59
47507: PPUSH
47508: LD_VAR 0 3
47512: PPUSH
47513: LD_EXP 59
47517: PUSH
47518: LD_VAR 0 3
47522: ARRAY
47523: PUSH
47524: LD_VAR 0 1
47528: DIFF
47529: PPUSH
47530: CALL_OW 1
47534: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47535: LD_VAR 0 1
47539: PUSH
47540: LD_EXP 58
47544: PUSH
47545: LD_VAR 0 3
47549: ARRAY
47550: IN
47551: IFFALSE 47590
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47553: LD_ADDR_EXP 58
47557: PUSH
47558: LD_EXP 58
47562: PPUSH
47563: LD_VAR 0 3
47567: PPUSH
47568: LD_EXP 58
47572: PUSH
47573: LD_VAR 0 3
47577: ARRAY
47578: PUSH
47579: LD_VAR 0 1
47583: DIFF
47584: PPUSH
47585: CALL_OW 1
47589: ST_TO_ADDR
// end ; break ;
47590: GO 47594
// end ;
47592: GO 46242
47594: POP
47595: POP
// end ;
47596: LD_VAR 0 2
47600: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47601: LD_INT 0
47603: PPUSH
47604: PPUSH
47605: PPUSH
// if not mc_bases or not skirmish then
47606: LD_EXP 50
47610: NOT
47611: PUSH
47612: LD_EXP 48
47616: NOT
47617: OR
47618: IFFALSE 47622
// exit ;
47620: GO 47837
// for i = 1 to mc_bases do
47622: LD_ADDR_VAR 0 3
47626: PUSH
47627: DOUBLE
47628: LD_INT 1
47630: DEC
47631: ST_TO_ADDR
47632: LD_EXP 50
47636: PUSH
47637: FOR_TO
47638: IFFALSE 47835
// begin if building in mc_construct_list [ i ] then
47640: LD_VAR 0 1
47644: PUSH
47645: LD_EXP 57
47649: PUSH
47650: LD_VAR 0 3
47654: ARRAY
47655: IN
47656: IFFALSE 47833
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47658: LD_ADDR_EXP 57
47662: PUSH
47663: LD_EXP 57
47667: PPUSH
47668: LD_VAR 0 3
47672: PPUSH
47673: LD_EXP 57
47677: PUSH
47678: LD_VAR 0 3
47682: ARRAY
47683: PUSH
47684: LD_VAR 0 1
47688: DIFF
47689: PPUSH
47690: CALL_OW 1
47694: ST_TO_ADDR
// if building in mc_lab [ i ] then
47695: LD_VAR 0 1
47699: PUSH
47700: LD_EXP 83
47704: PUSH
47705: LD_VAR 0 3
47709: ARRAY
47710: IN
47711: IFFALSE 47766
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47713: LD_ADDR_EXP 84
47717: PUSH
47718: LD_EXP 84
47722: PPUSH
47723: LD_VAR 0 3
47727: PPUSH
47728: LD_EXP 84
47732: PUSH
47733: LD_VAR 0 3
47737: ARRAY
47738: PPUSH
47739: LD_INT 1
47741: PPUSH
47742: LD_EXP 84
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: PPUSH
47753: LD_INT 0
47755: PPUSH
47756: CALL 53586 0 4
47760: PPUSH
47761: CALL_OW 1
47765: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47766: LD_VAR 0 1
47770: PUSH
47771: LD_EXP 50
47775: PUSH
47776: LD_VAR 0 3
47780: ARRAY
47781: IN
47782: NOT
47783: IFFALSE 47829
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47785: LD_ADDR_EXP 50
47789: PUSH
47790: LD_EXP 50
47794: PPUSH
47795: LD_VAR 0 3
47799: PUSH
47800: LD_EXP 50
47804: PUSH
47805: LD_VAR 0 3
47809: ARRAY
47810: PUSH
47811: LD_INT 1
47813: PLUS
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PPUSH
47819: LD_VAR 0 1
47823: PPUSH
47824: CALL 54168 0 3
47828: ST_TO_ADDR
// exit ;
47829: POP
47830: POP
47831: GO 47837
// end ; end ;
47833: GO 47637
47835: POP
47836: POP
// end ;
47837: LD_VAR 0 2
47841: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47842: LD_INT 0
47844: PPUSH
47845: PPUSH
47846: PPUSH
47847: PPUSH
47848: PPUSH
47849: PPUSH
47850: PPUSH
// if not mc_bases or not skirmish then
47851: LD_EXP 50
47855: NOT
47856: PUSH
47857: LD_EXP 48
47861: NOT
47862: OR
47863: IFFALSE 47867
// exit ;
47865: GO 48528
// for i = 1 to mc_bases do
47867: LD_ADDR_VAR 0 3
47871: PUSH
47872: DOUBLE
47873: LD_INT 1
47875: DEC
47876: ST_TO_ADDR
47877: LD_EXP 50
47881: PUSH
47882: FOR_TO
47883: IFFALSE 48526
// begin if building in mc_construct_list [ i ] then
47885: LD_VAR 0 1
47889: PUSH
47890: LD_EXP 57
47894: PUSH
47895: LD_VAR 0 3
47899: ARRAY
47900: IN
47901: IFFALSE 48524
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47903: LD_ADDR_EXP 57
47907: PUSH
47908: LD_EXP 57
47912: PPUSH
47913: LD_VAR 0 3
47917: PPUSH
47918: LD_EXP 57
47922: PUSH
47923: LD_VAR 0 3
47927: ARRAY
47928: PUSH
47929: LD_VAR 0 1
47933: DIFF
47934: PPUSH
47935: CALL_OW 1
47939: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47940: LD_ADDR_EXP 50
47944: PUSH
47945: LD_EXP 50
47949: PPUSH
47950: LD_VAR 0 3
47954: PUSH
47955: LD_EXP 50
47959: PUSH
47960: LD_VAR 0 3
47964: ARRAY
47965: PUSH
47966: LD_INT 1
47968: PLUS
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PPUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: CALL 54168 0 3
47983: ST_TO_ADDR
// btype := GetBType ( building ) ;
47984: LD_ADDR_VAR 0 5
47988: PUSH
47989: LD_VAR 0 1
47993: PPUSH
47994: CALL_OW 266
47998: ST_TO_ADDR
// side := GetSide ( building ) ;
47999: LD_ADDR_VAR 0 8
48003: PUSH
48004: LD_VAR 0 1
48008: PPUSH
48009: CALL_OW 255
48013: ST_TO_ADDR
// if btype = b_lab then
48014: LD_VAR 0 5
48018: PUSH
48019: LD_INT 6
48021: EQUAL
48022: IFFALSE 48072
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48024: LD_ADDR_EXP 83
48028: PUSH
48029: LD_EXP 83
48033: PPUSH
48034: LD_VAR 0 3
48038: PUSH
48039: LD_EXP 83
48043: PUSH
48044: LD_VAR 0 3
48048: ARRAY
48049: PUSH
48050: LD_INT 1
48052: PLUS
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PPUSH
48058: LD_VAR 0 1
48062: PPUSH
48063: CALL 54168 0 3
48067: ST_TO_ADDR
// exit ;
48068: POP
48069: POP
48070: GO 48528
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48072: LD_VAR 0 5
48076: PUSH
48077: LD_INT 0
48079: PUSH
48080: LD_INT 2
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: IN
48091: IFFALSE 48215
// begin if btype = b_armoury then
48093: LD_VAR 0 5
48097: PUSH
48098: LD_INT 4
48100: EQUAL
48101: IFFALSE 48111
// btype := b_barracks ;
48103: LD_ADDR_VAR 0 5
48107: PUSH
48108: LD_INT 5
48110: ST_TO_ADDR
// if btype = b_depot then
48111: LD_VAR 0 5
48115: PUSH
48116: LD_INT 0
48118: EQUAL
48119: IFFALSE 48129
// btype := b_warehouse ;
48121: LD_ADDR_VAR 0 5
48125: PUSH
48126: LD_INT 1
48128: ST_TO_ADDR
// if btype = b_workshop then
48129: LD_VAR 0 5
48133: PUSH
48134: LD_INT 2
48136: EQUAL
48137: IFFALSE 48147
// btype := b_factory ;
48139: LD_ADDR_VAR 0 5
48143: PUSH
48144: LD_INT 3
48146: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48147: LD_VAR 0 5
48151: PPUSH
48152: LD_VAR 0 8
48156: PPUSH
48157: CALL_OW 323
48161: PUSH
48162: LD_INT 1
48164: EQUAL
48165: IFFALSE 48211
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48167: LD_ADDR_EXP 82
48171: PUSH
48172: LD_EXP 82
48176: PPUSH
48177: LD_VAR 0 3
48181: PUSH
48182: LD_EXP 82
48186: PUSH
48187: LD_VAR 0 3
48191: ARRAY
48192: PUSH
48193: LD_INT 1
48195: PLUS
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PPUSH
48201: LD_VAR 0 1
48205: PPUSH
48206: CALL 54168 0 3
48210: ST_TO_ADDR
// exit ;
48211: POP
48212: POP
48213: GO 48528
// end ; if btype in [ b_bunker , b_turret ] then
48215: LD_VAR 0 5
48219: PUSH
48220: LD_INT 32
48222: PUSH
48223: LD_INT 33
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: IN
48230: IFFALSE 48520
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48232: LD_ADDR_EXP 58
48236: PUSH
48237: LD_EXP 58
48241: PPUSH
48242: LD_VAR 0 3
48246: PUSH
48247: LD_EXP 58
48251: PUSH
48252: LD_VAR 0 3
48256: ARRAY
48257: PUSH
48258: LD_INT 1
48260: PLUS
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL 54168 0 3
48275: ST_TO_ADDR
// if btype = b_bunker then
48276: LD_VAR 0 5
48280: PUSH
48281: LD_INT 32
48283: EQUAL
48284: IFFALSE 48520
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48286: LD_ADDR_EXP 59
48290: PUSH
48291: LD_EXP 59
48295: PPUSH
48296: LD_VAR 0 3
48300: PUSH
48301: LD_EXP 59
48305: PUSH
48306: LD_VAR 0 3
48310: ARRAY
48311: PUSH
48312: LD_INT 1
48314: PLUS
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PPUSH
48320: LD_VAR 0 1
48324: PPUSH
48325: CALL 54168 0 3
48329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48330: LD_ADDR_VAR 0 6
48334: PUSH
48335: LD_EXP 50
48339: PUSH
48340: LD_VAR 0 3
48344: ARRAY
48345: PPUSH
48346: LD_INT 25
48348: PUSH
48349: LD_INT 1
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: PUSH
48356: LD_INT 3
48358: PUSH
48359: LD_INT 54
48361: PUSH
48362: EMPTY
48363: LIST
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PPUSH
48373: CALL_OW 72
48377: ST_TO_ADDR
// if tmp then
48378: LD_VAR 0 6
48382: IFFALSE 48388
// exit ;
48384: POP
48385: POP
48386: GO 48528
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48388: LD_ADDR_VAR 0 6
48392: PUSH
48393: LD_EXP 50
48397: PUSH
48398: LD_VAR 0 3
48402: ARRAY
48403: PPUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 30
48409: PUSH
48410: LD_INT 4
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: PUSH
48417: LD_INT 30
48419: PUSH
48420: LD_INT 5
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: LIST
48431: PPUSH
48432: CALL_OW 72
48436: ST_TO_ADDR
// if not tmp then
48437: LD_VAR 0 6
48441: NOT
48442: IFFALSE 48448
// exit ;
48444: POP
48445: POP
48446: GO 48528
// for j in tmp do
48448: LD_ADDR_VAR 0 4
48452: PUSH
48453: LD_VAR 0 6
48457: PUSH
48458: FOR_IN
48459: IFFALSE 48518
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48461: LD_ADDR_VAR 0 7
48465: PUSH
48466: LD_VAR 0 4
48470: PPUSH
48471: CALL_OW 313
48475: PPUSH
48476: LD_INT 25
48478: PUSH
48479: LD_INT 1
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PPUSH
48486: CALL_OW 72
48490: ST_TO_ADDR
// if units then
48491: LD_VAR 0 7
48495: IFFALSE 48516
// begin ComExitBuilding ( units [ 1 ] ) ;
48497: LD_VAR 0 7
48501: PUSH
48502: LD_INT 1
48504: ARRAY
48505: PPUSH
48506: CALL_OW 122
// exit ;
48510: POP
48511: POP
48512: POP
48513: POP
48514: GO 48528
// end ; end ;
48516: GO 48458
48518: POP
48519: POP
// end ; end ; exit ;
48520: POP
48521: POP
48522: GO 48528
// end ; end ;
48524: GO 47882
48526: POP
48527: POP
// end ;
48528: LD_VAR 0 2
48532: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48533: LD_INT 0
48535: PPUSH
48536: PPUSH
48537: PPUSH
48538: PPUSH
48539: PPUSH
48540: PPUSH
48541: PPUSH
// if not mc_bases or not skirmish then
48542: LD_EXP 50
48546: NOT
48547: PUSH
48548: LD_EXP 48
48552: NOT
48553: OR
48554: IFFALSE 48558
// exit ;
48556: GO 48823
// btype := GetBType ( building ) ;
48558: LD_ADDR_VAR 0 6
48562: PUSH
48563: LD_VAR 0 1
48567: PPUSH
48568: CALL_OW 266
48572: ST_TO_ADDR
// x := GetX ( building ) ;
48573: LD_ADDR_VAR 0 7
48577: PUSH
48578: LD_VAR 0 1
48582: PPUSH
48583: CALL_OW 250
48587: ST_TO_ADDR
// y := GetY ( building ) ;
48588: LD_ADDR_VAR 0 8
48592: PUSH
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 251
48602: ST_TO_ADDR
// d := GetDir ( building ) ;
48603: LD_ADDR_VAR 0 9
48607: PUSH
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 254
48617: ST_TO_ADDR
// for i = 1 to mc_bases do
48618: LD_ADDR_VAR 0 4
48622: PUSH
48623: DOUBLE
48624: LD_INT 1
48626: DEC
48627: ST_TO_ADDR
48628: LD_EXP 50
48632: PUSH
48633: FOR_TO
48634: IFFALSE 48821
// begin if not mc_build_list [ i ] then
48636: LD_EXP 55
48640: PUSH
48641: LD_VAR 0 4
48645: ARRAY
48646: NOT
48647: IFFALSE 48651
// continue ;
48649: GO 48633
// for j := 1 to mc_build_list [ i ] do
48651: LD_ADDR_VAR 0 5
48655: PUSH
48656: DOUBLE
48657: LD_INT 1
48659: DEC
48660: ST_TO_ADDR
48661: LD_EXP 55
48665: PUSH
48666: LD_VAR 0 4
48670: ARRAY
48671: PUSH
48672: FOR_TO
48673: IFFALSE 48817
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48675: LD_VAR 0 6
48679: PUSH
48680: LD_VAR 0 7
48684: PUSH
48685: LD_VAR 0 8
48689: PUSH
48690: LD_VAR 0 9
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: PPUSH
48701: LD_EXP 55
48705: PUSH
48706: LD_VAR 0 4
48710: ARRAY
48711: PUSH
48712: LD_VAR 0 5
48716: ARRAY
48717: PPUSH
48718: CALL 60725 0 2
48722: IFFALSE 48815
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48724: LD_ADDR_EXP 55
48728: PUSH
48729: LD_EXP 55
48733: PPUSH
48734: LD_VAR 0 4
48738: PPUSH
48739: LD_EXP 55
48743: PUSH
48744: LD_VAR 0 4
48748: ARRAY
48749: PPUSH
48750: LD_VAR 0 5
48754: PPUSH
48755: CALL_OW 3
48759: PPUSH
48760: CALL_OW 1
48764: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48765: LD_ADDR_EXP 57
48769: PUSH
48770: LD_EXP 57
48774: PPUSH
48775: LD_VAR 0 4
48779: PUSH
48780: LD_EXP 57
48784: PUSH
48785: LD_VAR 0 4
48789: ARRAY
48790: PUSH
48791: LD_INT 1
48793: PLUS
48794: PUSH
48795: EMPTY
48796: LIST
48797: LIST
48798: PPUSH
48799: LD_VAR 0 1
48803: PPUSH
48804: CALL 54168 0 3
48808: ST_TO_ADDR
// exit ;
48809: POP
48810: POP
48811: POP
48812: POP
48813: GO 48823
// end ;
48815: GO 48672
48817: POP
48818: POP
// end ;
48819: GO 48633
48821: POP
48822: POP
// end ;
48823: LD_VAR 0 3
48827: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48828: LD_INT 0
48830: PPUSH
48831: PPUSH
48832: PPUSH
// if not mc_bases or not skirmish then
48833: LD_EXP 50
48837: NOT
48838: PUSH
48839: LD_EXP 48
48843: NOT
48844: OR
48845: IFFALSE 48849
// exit ;
48847: GO 49039
// for i = 1 to mc_bases do
48849: LD_ADDR_VAR 0 4
48853: PUSH
48854: DOUBLE
48855: LD_INT 1
48857: DEC
48858: ST_TO_ADDR
48859: LD_EXP 50
48863: PUSH
48864: FOR_TO
48865: IFFALSE 48952
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48867: LD_VAR 0 1
48871: PUSH
48872: LD_EXP 58
48876: PUSH
48877: LD_VAR 0 4
48881: ARRAY
48882: IN
48883: PUSH
48884: LD_VAR 0 1
48888: PUSH
48889: LD_EXP 59
48893: PUSH
48894: LD_VAR 0 4
48898: ARRAY
48899: IN
48900: NOT
48901: AND
48902: IFFALSE 48950
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48904: LD_ADDR_EXP 59
48908: PUSH
48909: LD_EXP 59
48913: PPUSH
48914: LD_VAR 0 4
48918: PUSH
48919: LD_EXP 59
48923: PUSH
48924: LD_VAR 0 4
48928: ARRAY
48929: PUSH
48930: LD_INT 1
48932: PLUS
48933: PUSH
48934: EMPTY
48935: LIST
48936: LIST
48937: PPUSH
48938: LD_VAR 0 1
48942: PPUSH
48943: CALL 54168 0 3
48947: ST_TO_ADDR
// break ;
48948: GO 48952
// end ; end ;
48950: GO 48864
48952: POP
48953: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48954: LD_VAR 0 1
48958: PPUSH
48959: CALL_OW 257
48963: PUSH
48964: LD_EXP 76
48968: IN
48969: PUSH
48970: LD_VAR 0 1
48974: PPUSH
48975: CALL_OW 266
48979: PUSH
48980: LD_INT 5
48982: EQUAL
48983: AND
48984: PUSH
48985: LD_VAR 0 2
48989: PPUSH
48990: CALL_OW 110
48994: PUSH
48995: LD_INT 18
48997: NONEQUAL
48998: AND
48999: IFFALSE 49039
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49001: LD_VAR 0 2
49005: PPUSH
49006: CALL_OW 257
49010: PUSH
49011: LD_INT 5
49013: PUSH
49014: LD_INT 8
49016: PUSH
49017: LD_INT 9
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: LIST
49024: IN
49025: IFFALSE 49039
// SetClass ( unit , 1 ) ;
49027: LD_VAR 0 2
49031: PPUSH
49032: LD_INT 1
49034: PPUSH
49035: CALL_OW 336
// end ;
49039: LD_VAR 0 3
49043: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49044: LD_INT 0
49046: PPUSH
49047: PPUSH
// if not mc_bases or not skirmish then
49048: LD_EXP 50
49052: NOT
49053: PUSH
49054: LD_EXP 48
49058: NOT
49059: OR
49060: IFFALSE 49064
// exit ;
49062: GO 49180
// if GetLives ( abandoned_vehicle ) > 250 then
49064: LD_VAR 0 2
49068: PPUSH
49069: CALL_OW 256
49073: PUSH
49074: LD_INT 250
49076: GREATER
49077: IFFALSE 49081
// exit ;
49079: GO 49180
// for i = 1 to mc_bases do
49081: LD_ADDR_VAR 0 6
49085: PUSH
49086: DOUBLE
49087: LD_INT 1
49089: DEC
49090: ST_TO_ADDR
49091: LD_EXP 50
49095: PUSH
49096: FOR_TO
49097: IFFALSE 49178
// begin if driver in mc_bases [ i ] then
49099: LD_VAR 0 1
49103: PUSH
49104: LD_EXP 50
49108: PUSH
49109: LD_VAR 0 6
49113: ARRAY
49114: IN
49115: IFFALSE 49176
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49117: LD_VAR 0 1
49121: PPUSH
49122: LD_EXP 50
49126: PUSH
49127: LD_VAR 0 6
49131: ARRAY
49132: PPUSH
49133: LD_INT 2
49135: PUSH
49136: LD_INT 30
49138: PUSH
49139: LD_INT 0
49141: PUSH
49142: EMPTY
49143: LIST
49144: LIST
49145: PUSH
49146: LD_INT 30
49148: PUSH
49149: LD_INT 1
49151: PUSH
49152: EMPTY
49153: LIST
49154: LIST
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: LIST
49160: PPUSH
49161: CALL_OW 72
49165: PUSH
49166: LD_INT 1
49168: ARRAY
49169: PPUSH
49170: CALL 87794 0 2
// break ;
49174: GO 49178
// end ; end ;
49176: GO 49096
49178: POP
49179: POP
// end ; end_of_file
49180: LD_VAR 0 5
49184: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49185: LD_INT 0
49187: PPUSH
49188: PPUSH
// if exist_mode then
49189: LD_VAR 0 2
49193: IFFALSE 49239
// begin unit := CreateCharacter ( prefix & ident ) ;
49195: LD_ADDR_VAR 0 5
49199: PUSH
49200: LD_VAR 0 3
49204: PUSH
49205: LD_VAR 0 1
49209: STR
49210: PPUSH
49211: CALL_OW 34
49215: ST_TO_ADDR
// if unit then
49216: LD_VAR 0 5
49220: IFFALSE 49237
// DeleteCharacters ( prefix & ident ) ;
49222: LD_VAR 0 3
49226: PUSH
49227: LD_VAR 0 1
49231: STR
49232: PPUSH
49233: CALL_OW 40
// end else
49237: GO 49254
// unit := NewCharacter ( ident ) ;
49239: LD_ADDR_VAR 0 5
49243: PUSH
49244: LD_VAR 0 1
49248: PPUSH
49249: CALL_OW 25
49253: ST_TO_ADDR
// result := unit ;
49254: LD_ADDR_VAR 0 4
49258: PUSH
49259: LD_VAR 0 5
49263: ST_TO_ADDR
// end ;
49264: LD_VAR 0 4
49268: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49269: LD_INT 0
49271: PPUSH
49272: PPUSH
// if not side or not nation then
49273: LD_VAR 0 1
49277: NOT
49278: PUSH
49279: LD_VAR 0 2
49283: NOT
49284: OR
49285: IFFALSE 49289
// exit ;
49287: GO 50057
// case nation of nation_american :
49289: LD_VAR 0 2
49293: PUSH
49294: LD_INT 1
49296: DOUBLE
49297: EQUAL
49298: IFTRUE 49302
49300: GO 49516
49302: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49303: LD_ADDR_VAR 0 4
49307: PUSH
49308: LD_INT 35
49310: PUSH
49311: LD_INT 45
49313: PUSH
49314: LD_INT 46
49316: PUSH
49317: LD_INT 47
49319: PUSH
49320: LD_INT 82
49322: PUSH
49323: LD_INT 83
49325: PUSH
49326: LD_INT 84
49328: PUSH
49329: LD_INT 85
49331: PUSH
49332: LD_INT 86
49334: PUSH
49335: LD_INT 1
49337: PUSH
49338: LD_INT 2
49340: PUSH
49341: LD_INT 6
49343: PUSH
49344: LD_INT 15
49346: PUSH
49347: LD_INT 16
49349: PUSH
49350: LD_INT 7
49352: PUSH
49353: LD_INT 12
49355: PUSH
49356: LD_INT 13
49358: PUSH
49359: LD_INT 10
49361: PUSH
49362: LD_INT 14
49364: PUSH
49365: LD_INT 20
49367: PUSH
49368: LD_INT 21
49370: PUSH
49371: LD_INT 22
49373: PUSH
49374: LD_INT 25
49376: PUSH
49377: LD_INT 32
49379: PUSH
49380: LD_INT 27
49382: PUSH
49383: LD_INT 36
49385: PUSH
49386: LD_INT 69
49388: PUSH
49389: LD_INT 39
49391: PUSH
49392: LD_INT 34
49394: PUSH
49395: LD_INT 40
49397: PUSH
49398: LD_INT 48
49400: PUSH
49401: LD_INT 49
49403: PUSH
49404: LD_INT 50
49406: PUSH
49407: LD_INT 51
49409: PUSH
49410: LD_INT 52
49412: PUSH
49413: LD_INT 53
49415: PUSH
49416: LD_INT 54
49418: PUSH
49419: LD_INT 55
49421: PUSH
49422: LD_INT 56
49424: PUSH
49425: LD_INT 57
49427: PUSH
49428: LD_INT 58
49430: PUSH
49431: LD_INT 59
49433: PUSH
49434: LD_INT 60
49436: PUSH
49437: LD_INT 61
49439: PUSH
49440: LD_INT 62
49442: PUSH
49443: LD_INT 80
49445: PUSH
49446: LD_INT 82
49448: PUSH
49449: LD_INT 83
49451: PUSH
49452: LD_INT 84
49454: PUSH
49455: LD_INT 85
49457: PUSH
49458: LD_INT 86
49460: PUSH
49461: EMPTY
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: LIST
49495: LIST
49496: LIST
49497: LIST
49498: LIST
49499: LIST
49500: LIST
49501: LIST
49502: LIST
49503: LIST
49504: LIST
49505: LIST
49506: LIST
49507: LIST
49508: LIST
49509: LIST
49510: LIST
49511: LIST
49512: LIST
49513: ST_TO_ADDR
49514: GO 49981
49516: LD_INT 2
49518: DOUBLE
49519: EQUAL
49520: IFTRUE 49524
49522: GO 49750
49524: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49525: LD_ADDR_VAR 0 4
49529: PUSH
49530: LD_INT 35
49532: PUSH
49533: LD_INT 45
49535: PUSH
49536: LD_INT 46
49538: PUSH
49539: LD_INT 47
49541: PUSH
49542: LD_INT 82
49544: PUSH
49545: LD_INT 83
49547: PUSH
49548: LD_INT 84
49550: PUSH
49551: LD_INT 85
49553: PUSH
49554: LD_INT 87
49556: PUSH
49557: LD_INT 70
49559: PUSH
49560: LD_INT 1
49562: PUSH
49563: LD_INT 11
49565: PUSH
49566: LD_INT 3
49568: PUSH
49569: LD_INT 4
49571: PUSH
49572: LD_INT 5
49574: PUSH
49575: LD_INT 6
49577: PUSH
49578: LD_INT 15
49580: PUSH
49581: LD_INT 18
49583: PUSH
49584: LD_INT 7
49586: PUSH
49587: LD_INT 17
49589: PUSH
49590: LD_INT 8
49592: PUSH
49593: LD_INT 20
49595: PUSH
49596: LD_INT 21
49598: PUSH
49599: LD_INT 22
49601: PUSH
49602: LD_INT 72
49604: PUSH
49605: LD_INT 26
49607: PUSH
49608: LD_INT 69
49610: PUSH
49611: LD_INT 39
49613: PUSH
49614: LD_INT 40
49616: PUSH
49617: LD_INT 41
49619: PUSH
49620: LD_INT 42
49622: PUSH
49623: LD_INT 43
49625: PUSH
49626: LD_INT 48
49628: PUSH
49629: LD_INT 49
49631: PUSH
49632: LD_INT 50
49634: PUSH
49635: LD_INT 51
49637: PUSH
49638: LD_INT 52
49640: PUSH
49641: LD_INT 53
49643: PUSH
49644: LD_INT 54
49646: PUSH
49647: LD_INT 55
49649: PUSH
49650: LD_INT 56
49652: PUSH
49653: LD_INT 60
49655: PUSH
49656: LD_INT 61
49658: PUSH
49659: LD_INT 62
49661: PUSH
49662: LD_INT 66
49664: PUSH
49665: LD_INT 67
49667: PUSH
49668: LD_INT 68
49670: PUSH
49671: LD_INT 81
49673: PUSH
49674: LD_INT 82
49676: PUSH
49677: LD_INT 83
49679: PUSH
49680: LD_INT 84
49682: PUSH
49683: LD_INT 85
49685: PUSH
49686: LD_INT 87
49688: PUSH
49689: LD_INT 88
49691: PUSH
49692: EMPTY
49693: LIST
49694: LIST
49695: LIST
49696: LIST
49697: LIST
49698: LIST
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: LIST
49705: LIST
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: LIST
49711: LIST
49712: LIST
49713: LIST
49714: LIST
49715: LIST
49716: LIST
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: LIST
49722: LIST
49723: LIST
49724: LIST
49725: LIST
49726: LIST
49727: LIST
49728: LIST
49729: LIST
49730: LIST
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: ST_TO_ADDR
49748: GO 49981
49750: LD_INT 3
49752: DOUBLE
49753: EQUAL
49754: IFTRUE 49758
49756: GO 49980
49758: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49759: LD_ADDR_VAR 0 4
49763: PUSH
49764: LD_INT 46
49766: PUSH
49767: LD_INT 47
49769: PUSH
49770: LD_INT 1
49772: PUSH
49773: LD_INT 2
49775: PUSH
49776: LD_INT 82
49778: PUSH
49779: LD_INT 83
49781: PUSH
49782: LD_INT 84
49784: PUSH
49785: LD_INT 85
49787: PUSH
49788: LD_INT 86
49790: PUSH
49791: LD_INT 11
49793: PUSH
49794: LD_INT 9
49796: PUSH
49797: LD_INT 20
49799: PUSH
49800: LD_INT 19
49802: PUSH
49803: LD_INT 21
49805: PUSH
49806: LD_INT 24
49808: PUSH
49809: LD_INT 22
49811: PUSH
49812: LD_INT 25
49814: PUSH
49815: LD_INT 28
49817: PUSH
49818: LD_INT 29
49820: PUSH
49821: LD_INT 30
49823: PUSH
49824: LD_INT 31
49826: PUSH
49827: LD_INT 37
49829: PUSH
49830: LD_INT 38
49832: PUSH
49833: LD_INT 32
49835: PUSH
49836: LD_INT 27
49838: PUSH
49839: LD_INT 33
49841: PUSH
49842: LD_INT 69
49844: PUSH
49845: LD_INT 39
49847: PUSH
49848: LD_INT 34
49850: PUSH
49851: LD_INT 40
49853: PUSH
49854: LD_INT 71
49856: PUSH
49857: LD_INT 23
49859: PUSH
49860: LD_INT 44
49862: PUSH
49863: LD_INT 48
49865: PUSH
49866: LD_INT 49
49868: PUSH
49869: LD_INT 50
49871: PUSH
49872: LD_INT 51
49874: PUSH
49875: LD_INT 52
49877: PUSH
49878: LD_INT 53
49880: PUSH
49881: LD_INT 54
49883: PUSH
49884: LD_INT 55
49886: PUSH
49887: LD_INT 56
49889: PUSH
49890: LD_INT 57
49892: PUSH
49893: LD_INT 58
49895: PUSH
49896: LD_INT 59
49898: PUSH
49899: LD_INT 63
49901: PUSH
49902: LD_INT 64
49904: PUSH
49905: LD_INT 65
49907: PUSH
49908: LD_INT 82
49910: PUSH
49911: LD_INT 83
49913: PUSH
49914: LD_INT 84
49916: PUSH
49917: LD_INT 85
49919: PUSH
49920: LD_INT 86
49922: PUSH
49923: EMPTY
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: LIST
49929: LIST
49930: LIST
49931: LIST
49932: LIST
49933: LIST
49934: LIST
49935: LIST
49936: LIST
49937: LIST
49938: LIST
49939: LIST
49940: LIST
49941: LIST
49942: LIST
49943: LIST
49944: LIST
49945: LIST
49946: LIST
49947: LIST
49948: LIST
49949: LIST
49950: LIST
49951: LIST
49952: LIST
49953: LIST
49954: LIST
49955: LIST
49956: LIST
49957: LIST
49958: LIST
49959: LIST
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: LIST
49965: LIST
49966: LIST
49967: LIST
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: LIST
49974: LIST
49975: LIST
49976: LIST
49977: ST_TO_ADDR
49978: GO 49981
49980: POP
// if state > - 1 and state < 3 then
49981: LD_VAR 0 3
49985: PUSH
49986: LD_INT 1
49988: NEG
49989: GREATER
49990: PUSH
49991: LD_VAR 0 3
49995: PUSH
49996: LD_INT 3
49998: LESS
49999: AND
50000: IFFALSE 50057
// for i in result do
50002: LD_ADDR_VAR 0 5
50006: PUSH
50007: LD_VAR 0 4
50011: PUSH
50012: FOR_IN
50013: IFFALSE 50055
// if GetTech ( i , side ) <> state then
50015: LD_VAR 0 5
50019: PPUSH
50020: LD_VAR 0 1
50024: PPUSH
50025: CALL_OW 321
50029: PUSH
50030: LD_VAR 0 3
50034: NONEQUAL
50035: IFFALSE 50053
// result := result diff i ;
50037: LD_ADDR_VAR 0 4
50041: PUSH
50042: LD_VAR 0 4
50046: PUSH
50047: LD_VAR 0 5
50051: DIFF
50052: ST_TO_ADDR
50053: GO 50012
50055: POP
50056: POP
// end ;
50057: LD_VAR 0 4
50061: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50062: LD_INT 0
50064: PPUSH
50065: PPUSH
50066: PPUSH
// result := true ;
50067: LD_ADDR_VAR 0 3
50071: PUSH
50072: LD_INT 1
50074: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50075: LD_ADDR_VAR 0 5
50079: PUSH
50080: LD_VAR 0 2
50084: PPUSH
50085: CALL_OW 480
50089: ST_TO_ADDR
// if not tmp then
50090: LD_VAR 0 5
50094: NOT
50095: IFFALSE 50099
// exit ;
50097: GO 50148
// for i in tmp do
50099: LD_ADDR_VAR 0 4
50103: PUSH
50104: LD_VAR 0 5
50108: PUSH
50109: FOR_IN
50110: IFFALSE 50146
// if GetTech ( i , side ) <> state_researched then
50112: LD_VAR 0 4
50116: PPUSH
50117: LD_VAR 0 1
50121: PPUSH
50122: CALL_OW 321
50126: PUSH
50127: LD_INT 2
50129: NONEQUAL
50130: IFFALSE 50144
// begin result := false ;
50132: LD_ADDR_VAR 0 3
50136: PUSH
50137: LD_INT 0
50139: ST_TO_ADDR
// exit ;
50140: POP
50141: POP
50142: GO 50148
// end ;
50144: GO 50109
50146: POP
50147: POP
// end ;
50148: LD_VAR 0 3
50152: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50153: LD_INT 0
50155: PPUSH
50156: PPUSH
50157: PPUSH
50158: PPUSH
50159: PPUSH
50160: PPUSH
50161: PPUSH
50162: PPUSH
50163: PPUSH
50164: PPUSH
50165: PPUSH
50166: PPUSH
50167: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50168: LD_VAR 0 1
50172: NOT
50173: PUSH
50174: LD_VAR 0 1
50178: PPUSH
50179: CALL_OW 257
50183: PUSH
50184: LD_INT 9
50186: NONEQUAL
50187: OR
50188: IFFALSE 50192
// exit ;
50190: GO 50765
// side := GetSide ( unit ) ;
50192: LD_ADDR_VAR 0 9
50196: PUSH
50197: LD_VAR 0 1
50201: PPUSH
50202: CALL_OW 255
50206: ST_TO_ADDR
// tech_space := tech_spacanom ;
50207: LD_ADDR_VAR 0 12
50211: PUSH
50212: LD_INT 29
50214: ST_TO_ADDR
// tech_time := tech_taurad ;
50215: LD_ADDR_VAR 0 13
50219: PUSH
50220: LD_INT 28
50222: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50223: LD_ADDR_VAR 0 11
50227: PUSH
50228: LD_VAR 0 1
50232: PPUSH
50233: CALL_OW 310
50237: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50238: LD_VAR 0 11
50242: PPUSH
50243: CALL_OW 247
50247: PUSH
50248: LD_INT 2
50250: EQUAL
50251: IFFALSE 50255
// exit ;
50253: GO 50765
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50255: LD_ADDR_VAR 0 8
50259: PUSH
50260: LD_INT 81
50262: PUSH
50263: LD_VAR 0 9
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 3
50274: PUSH
50275: LD_INT 21
50277: PUSH
50278: LD_INT 3
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: PUSH
50289: EMPTY
50290: LIST
50291: LIST
50292: PPUSH
50293: CALL_OW 69
50297: ST_TO_ADDR
// if not tmp then
50298: LD_VAR 0 8
50302: NOT
50303: IFFALSE 50307
// exit ;
50305: GO 50765
// if in_unit then
50307: LD_VAR 0 11
50311: IFFALSE 50335
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50313: LD_ADDR_VAR 0 10
50317: PUSH
50318: LD_VAR 0 8
50322: PPUSH
50323: LD_VAR 0 11
50327: PPUSH
50328: CALL_OW 74
50332: ST_TO_ADDR
50333: GO 50355
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50335: LD_ADDR_VAR 0 10
50339: PUSH
50340: LD_VAR 0 8
50344: PPUSH
50345: LD_VAR 0 1
50349: PPUSH
50350: CALL_OW 74
50354: ST_TO_ADDR
// if not enemy then
50355: LD_VAR 0 10
50359: NOT
50360: IFFALSE 50364
// exit ;
50362: GO 50765
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50364: LD_VAR 0 11
50368: PUSH
50369: LD_VAR 0 11
50373: PPUSH
50374: LD_VAR 0 10
50378: PPUSH
50379: CALL_OW 296
50383: PUSH
50384: LD_INT 13
50386: GREATER
50387: AND
50388: PUSH
50389: LD_VAR 0 1
50393: PPUSH
50394: LD_VAR 0 10
50398: PPUSH
50399: CALL_OW 296
50403: PUSH
50404: LD_INT 12
50406: GREATER
50407: OR
50408: IFFALSE 50412
// exit ;
50410: GO 50765
// missile := [ 1 ] ;
50412: LD_ADDR_VAR 0 14
50416: PUSH
50417: LD_INT 1
50419: PUSH
50420: EMPTY
50421: LIST
50422: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50423: LD_VAR 0 9
50427: PPUSH
50428: LD_VAR 0 12
50432: PPUSH
50433: CALL_OW 325
50437: IFFALSE 50466
// missile := Replace ( missile , missile + 1 , 2 ) ;
50439: LD_ADDR_VAR 0 14
50443: PUSH
50444: LD_VAR 0 14
50448: PPUSH
50449: LD_VAR 0 14
50453: PUSH
50454: LD_INT 1
50456: PLUS
50457: PPUSH
50458: LD_INT 2
50460: PPUSH
50461: CALL_OW 1
50465: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50466: LD_VAR 0 9
50470: PPUSH
50471: LD_VAR 0 13
50475: PPUSH
50476: CALL_OW 325
50480: PUSH
50481: LD_VAR 0 10
50485: PPUSH
50486: CALL_OW 255
50490: PPUSH
50491: LD_VAR 0 13
50495: PPUSH
50496: CALL_OW 325
50500: NOT
50501: AND
50502: IFFALSE 50531
// missile := Replace ( missile , missile + 1 , 3 ) ;
50504: LD_ADDR_VAR 0 14
50508: PUSH
50509: LD_VAR 0 14
50513: PPUSH
50514: LD_VAR 0 14
50518: PUSH
50519: LD_INT 1
50521: PLUS
50522: PPUSH
50523: LD_INT 3
50525: PPUSH
50526: CALL_OW 1
50530: ST_TO_ADDR
// if missile < 2 then
50531: LD_VAR 0 14
50535: PUSH
50536: LD_INT 2
50538: LESS
50539: IFFALSE 50543
// exit ;
50541: GO 50765
// x := GetX ( enemy ) ;
50543: LD_ADDR_VAR 0 4
50547: PUSH
50548: LD_VAR 0 10
50552: PPUSH
50553: CALL_OW 250
50557: ST_TO_ADDR
// y := GetY ( enemy ) ;
50558: LD_ADDR_VAR 0 5
50562: PUSH
50563: LD_VAR 0 10
50567: PPUSH
50568: CALL_OW 251
50572: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50573: LD_ADDR_VAR 0 6
50577: PUSH
50578: LD_VAR 0 4
50582: PUSH
50583: LD_INT 1
50585: NEG
50586: PPUSH
50587: LD_INT 1
50589: PPUSH
50590: CALL_OW 12
50594: PLUS
50595: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50596: LD_ADDR_VAR 0 7
50600: PUSH
50601: LD_VAR 0 5
50605: PUSH
50606: LD_INT 1
50608: NEG
50609: PPUSH
50610: LD_INT 1
50612: PPUSH
50613: CALL_OW 12
50617: PLUS
50618: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50619: LD_VAR 0 6
50623: PPUSH
50624: LD_VAR 0 7
50628: PPUSH
50629: CALL_OW 488
50633: NOT
50634: IFFALSE 50656
// begin _x := x ;
50636: LD_ADDR_VAR 0 6
50640: PUSH
50641: LD_VAR 0 4
50645: ST_TO_ADDR
// _y := y ;
50646: LD_ADDR_VAR 0 7
50650: PUSH
50651: LD_VAR 0 5
50655: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50656: LD_ADDR_VAR 0 3
50660: PUSH
50661: LD_INT 1
50663: PPUSH
50664: LD_VAR 0 14
50668: PPUSH
50669: CALL_OW 12
50673: ST_TO_ADDR
// case i of 1 :
50674: LD_VAR 0 3
50678: PUSH
50679: LD_INT 1
50681: DOUBLE
50682: EQUAL
50683: IFTRUE 50687
50685: GO 50704
50687: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50688: LD_VAR 0 1
50692: PPUSH
50693: LD_VAR 0 10
50697: PPUSH
50698: CALL_OW 115
50702: GO 50765
50704: LD_INT 2
50706: DOUBLE
50707: EQUAL
50708: IFTRUE 50712
50710: GO 50734
50712: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50713: LD_VAR 0 1
50717: PPUSH
50718: LD_VAR 0 6
50722: PPUSH
50723: LD_VAR 0 7
50727: PPUSH
50728: CALL_OW 153
50732: GO 50765
50734: LD_INT 3
50736: DOUBLE
50737: EQUAL
50738: IFTRUE 50742
50740: GO 50764
50742: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50743: LD_VAR 0 1
50747: PPUSH
50748: LD_VAR 0 6
50752: PPUSH
50753: LD_VAR 0 7
50757: PPUSH
50758: CALL_OW 154
50762: GO 50765
50764: POP
// end ;
50765: LD_VAR 0 2
50769: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50770: LD_INT 0
50772: PPUSH
50773: PPUSH
50774: PPUSH
50775: PPUSH
50776: PPUSH
50777: PPUSH
// if not unit or not building then
50778: LD_VAR 0 1
50782: NOT
50783: PUSH
50784: LD_VAR 0 2
50788: NOT
50789: OR
50790: IFFALSE 50794
// exit ;
50792: GO 50952
// x := GetX ( building ) ;
50794: LD_ADDR_VAR 0 5
50798: PUSH
50799: LD_VAR 0 2
50803: PPUSH
50804: CALL_OW 250
50808: ST_TO_ADDR
// y := GetY ( building ) ;
50809: LD_ADDR_VAR 0 6
50813: PUSH
50814: LD_VAR 0 2
50818: PPUSH
50819: CALL_OW 251
50823: ST_TO_ADDR
// for i = 0 to 5 do
50824: LD_ADDR_VAR 0 4
50828: PUSH
50829: DOUBLE
50830: LD_INT 0
50832: DEC
50833: ST_TO_ADDR
50834: LD_INT 5
50836: PUSH
50837: FOR_TO
50838: IFFALSE 50950
// begin _x := ShiftX ( x , i , 3 ) ;
50840: LD_ADDR_VAR 0 7
50844: PUSH
50845: LD_VAR 0 5
50849: PPUSH
50850: LD_VAR 0 4
50854: PPUSH
50855: LD_INT 3
50857: PPUSH
50858: CALL_OW 272
50862: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50863: LD_ADDR_VAR 0 8
50867: PUSH
50868: LD_VAR 0 6
50872: PPUSH
50873: LD_VAR 0 4
50877: PPUSH
50878: LD_INT 3
50880: PPUSH
50881: CALL_OW 273
50885: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50886: LD_VAR 0 7
50890: PPUSH
50891: LD_VAR 0 8
50895: PPUSH
50896: CALL_OW 488
50900: NOT
50901: IFFALSE 50905
// continue ;
50903: GO 50837
// if HexInfo ( _x , _y ) = 0 then
50905: LD_VAR 0 7
50909: PPUSH
50910: LD_VAR 0 8
50914: PPUSH
50915: CALL_OW 428
50919: PUSH
50920: LD_INT 0
50922: EQUAL
50923: IFFALSE 50948
// begin ComMoveXY ( unit , _x , _y ) ;
50925: LD_VAR 0 1
50929: PPUSH
50930: LD_VAR 0 7
50934: PPUSH
50935: LD_VAR 0 8
50939: PPUSH
50940: CALL_OW 111
// exit ;
50944: POP
50945: POP
50946: GO 50952
// end ; end ;
50948: GO 50837
50950: POP
50951: POP
// end ;
50952: LD_VAR 0 3
50956: RET
// export function ScanBase ( side , base_area ) ; begin
50957: LD_INT 0
50959: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50960: LD_ADDR_VAR 0 3
50964: PUSH
50965: LD_VAR 0 2
50969: PPUSH
50970: LD_INT 81
50972: PUSH
50973: LD_VAR 0 1
50977: PUSH
50978: EMPTY
50979: LIST
50980: LIST
50981: PPUSH
50982: CALL_OW 70
50986: ST_TO_ADDR
// end ;
50987: LD_VAR 0 3
50991: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50992: LD_INT 0
50994: PPUSH
50995: PPUSH
50996: PPUSH
50997: PPUSH
// result := false ;
50998: LD_ADDR_VAR 0 2
51002: PUSH
51003: LD_INT 0
51005: ST_TO_ADDR
// side := GetSide ( unit ) ;
51006: LD_ADDR_VAR 0 3
51010: PUSH
51011: LD_VAR 0 1
51015: PPUSH
51016: CALL_OW 255
51020: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51021: LD_ADDR_VAR 0 4
51025: PUSH
51026: LD_VAR 0 1
51030: PPUSH
51031: CALL_OW 248
51035: ST_TO_ADDR
// case nat of 1 :
51036: LD_VAR 0 4
51040: PUSH
51041: LD_INT 1
51043: DOUBLE
51044: EQUAL
51045: IFTRUE 51049
51047: GO 51060
51049: POP
// tech := tech_lassight ; 2 :
51050: LD_ADDR_VAR 0 5
51054: PUSH
51055: LD_INT 12
51057: ST_TO_ADDR
51058: GO 51099
51060: LD_INT 2
51062: DOUBLE
51063: EQUAL
51064: IFTRUE 51068
51066: GO 51079
51068: POP
// tech := tech_mortar ; 3 :
51069: LD_ADDR_VAR 0 5
51073: PUSH
51074: LD_INT 41
51076: ST_TO_ADDR
51077: GO 51099
51079: LD_INT 3
51081: DOUBLE
51082: EQUAL
51083: IFTRUE 51087
51085: GO 51098
51087: POP
// tech := tech_bazooka ; end ;
51088: LD_ADDR_VAR 0 5
51092: PUSH
51093: LD_INT 44
51095: ST_TO_ADDR
51096: GO 51099
51098: POP
// if Researched ( side , tech ) then
51099: LD_VAR 0 3
51103: PPUSH
51104: LD_VAR 0 5
51108: PPUSH
51109: CALL_OW 325
51113: IFFALSE 51140
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51115: LD_ADDR_VAR 0 2
51119: PUSH
51120: LD_INT 5
51122: PUSH
51123: LD_INT 8
51125: PUSH
51126: LD_INT 9
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: LIST
51133: PUSH
51134: LD_VAR 0 4
51138: ARRAY
51139: ST_TO_ADDR
// end ;
51140: LD_VAR 0 2
51144: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51145: LD_INT 0
51147: PPUSH
51148: PPUSH
51149: PPUSH
// if not mines then
51150: LD_VAR 0 2
51154: NOT
51155: IFFALSE 51159
// exit ;
51157: GO 51303
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51159: LD_ADDR_VAR 0 5
51163: PUSH
51164: LD_INT 81
51166: PUSH
51167: LD_VAR 0 1
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PUSH
51176: LD_INT 3
51178: PUSH
51179: LD_INT 21
51181: PUSH
51182: LD_INT 3
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: PUSH
51189: EMPTY
51190: LIST
51191: LIST
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PPUSH
51197: CALL_OW 69
51201: ST_TO_ADDR
// for i in mines do
51202: LD_ADDR_VAR 0 4
51206: PUSH
51207: LD_VAR 0 2
51211: PUSH
51212: FOR_IN
51213: IFFALSE 51301
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51215: LD_VAR 0 4
51219: PUSH
51220: LD_INT 1
51222: ARRAY
51223: PPUSH
51224: LD_VAR 0 4
51228: PUSH
51229: LD_INT 2
51231: ARRAY
51232: PPUSH
51233: CALL_OW 458
51237: NOT
51238: IFFALSE 51242
// continue ;
51240: GO 51212
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51242: LD_VAR 0 4
51246: PUSH
51247: LD_INT 1
51249: ARRAY
51250: PPUSH
51251: LD_VAR 0 4
51255: PUSH
51256: LD_INT 2
51258: ARRAY
51259: PPUSH
51260: CALL_OW 428
51264: PUSH
51265: LD_VAR 0 5
51269: IN
51270: IFFALSE 51299
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51272: LD_VAR 0 4
51276: PUSH
51277: LD_INT 1
51279: ARRAY
51280: PPUSH
51281: LD_VAR 0 4
51285: PUSH
51286: LD_INT 2
51288: ARRAY
51289: PPUSH
51290: LD_VAR 0 1
51294: PPUSH
51295: CALL_OW 456
// end ;
51299: GO 51212
51301: POP
51302: POP
// end ;
51303: LD_VAR 0 3
51307: RET
// export function Count ( array ) ; begin
51308: LD_INT 0
51310: PPUSH
// result := array + 0 ;
51311: LD_ADDR_VAR 0 2
51315: PUSH
51316: LD_VAR 0 1
51320: PUSH
51321: LD_INT 0
51323: PLUS
51324: ST_TO_ADDR
// end ;
51325: LD_VAR 0 2
51329: RET
// export function IsEmpty ( building ) ; begin
51330: LD_INT 0
51332: PPUSH
// if not building then
51333: LD_VAR 0 1
51337: NOT
51338: IFFALSE 51342
// exit ;
51340: GO 51385
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51342: LD_ADDR_VAR 0 2
51346: PUSH
51347: LD_VAR 0 1
51351: PUSH
51352: LD_INT 22
51354: PUSH
51355: LD_VAR 0 1
51359: PPUSH
51360: CALL_OW 255
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 58
51371: PUSH
51372: EMPTY
51373: LIST
51374: PUSH
51375: EMPTY
51376: LIST
51377: LIST
51378: PPUSH
51379: CALL_OW 69
51383: IN
51384: ST_TO_ADDR
// end ;
51385: LD_VAR 0 2
51389: RET
// export function IsNotFull ( building ) ; var places ; begin
51390: LD_INT 0
51392: PPUSH
51393: PPUSH
// if not building then
51394: LD_VAR 0 1
51398: NOT
51399: IFFALSE 51403
// exit ;
51401: GO 51431
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51403: LD_ADDR_VAR 0 2
51407: PUSH
51408: LD_VAR 0 1
51412: PPUSH
51413: LD_INT 3
51415: PUSH
51416: LD_INT 62
51418: PUSH
51419: EMPTY
51420: LIST
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PPUSH
51426: CALL_OW 72
51430: ST_TO_ADDR
// end ;
51431: LD_VAR 0 2
51435: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51436: LD_INT 0
51438: PPUSH
51439: PPUSH
51440: PPUSH
51441: PPUSH
// tmp := [ ] ;
51442: LD_ADDR_VAR 0 3
51446: PUSH
51447: EMPTY
51448: ST_TO_ADDR
// list := [ ] ;
51449: LD_ADDR_VAR 0 5
51453: PUSH
51454: EMPTY
51455: ST_TO_ADDR
// for i = 16 to 25 do
51456: LD_ADDR_VAR 0 4
51460: PUSH
51461: DOUBLE
51462: LD_INT 16
51464: DEC
51465: ST_TO_ADDR
51466: LD_INT 25
51468: PUSH
51469: FOR_TO
51470: IFFALSE 51543
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51472: LD_ADDR_VAR 0 3
51476: PUSH
51477: LD_VAR 0 3
51481: PUSH
51482: LD_INT 22
51484: PUSH
51485: LD_VAR 0 1
51489: PPUSH
51490: CALL_OW 255
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: PUSH
51499: LD_INT 91
51501: PUSH
51502: LD_VAR 0 1
51506: PUSH
51507: LD_INT 6
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: LIST
51514: PUSH
51515: LD_INT 30
51517: PUSH
51518: LD_VAR 0 4
51522: PUSH
51523: EMPTY
51524: LIST
51525: LIST
51526: PUSH
51527: EMPTY
51528: LIST
51529: LIST
51530: LIST
51531: PUSH
51532: EMPTY
51533: LIST
51534: PPUSH
51535: CALL_OW 69
51539: ADD
51540: ST_TO_ADDR
51541: GO 51469
51543: POP
51544: POP
// for i = 1 to tmp do
51545: LD_ADDR_VAR 0 4
51549: PUSH
51550: DOUBLE
51551: LD_INT 1
51553: DEC
51554: ST_TO_ADDR
51555: LD_VAR 0 3
51559: PUSH
51560: FOR_TO
51561: IFFALSE 51649
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51563: LD_ADDR_VAR 0 5
51567: PUSH
51568: LD_VAR 0 5
51572: PUSH
51573: LD_VAR 0 3
51577: PUSH
51578: LD_VAR 0 4
51582: ARRAY
51583: PPUSH
51584: CALL_OW 266
51588: PUSH
51589: LD_VAR 0 3
51593: PUSH
51594: LD_VAR 0 4
51598: ARRAY
51599: PPUSH
51600: CALL_OW 250
51604: PUSH
51605: LD_VAR 0 3
51609: PUSH
51610: LD_VAR 0 4
51614: ARRAY
51615: PPUSH
51616: CALL_OW 251
51620: PUSH
51621: LD_VAR 0 3
51625: PUSH
51626: LD_VAR 0 4
51630: ARRAY
51631: PPUSH
51632: CALL_OW 254
51636: PUSH
51637: EMPTY
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: PUSH
51643: EMPTY
51644: LIST
51645: ADD
51646: ST_TO_ADDR
51647: GO 51560
51649: POP
51650: POP
// result := list ;
51651: LD_ADDR_VAR 0 2
51655: PUSH
51656: LD_VAR 0 5
51660: ST_TO_ADDR
// end ;
51661: LD_VAR 0 2
51665: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51666: LD_INT 0
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
51674: PPUSH
// if not factory then
51675: LD_VAR 0 1
51679: NOT
51680: IFFALSE 51684
// exit ;
51682: GO 52277
// if control = control_apeman then
51684: LD_VAR 0 4
51688: PUSH
51689: LD_INT 5
51691: EQUAL
51692: IFFALSE 51801
// begin tmp := UnitsInside ( factory ) ;
51694: LD_ADDR_VAR 0 8
51698: PUSH
51699: LD_VAR 0 1
51703: PPUSH
51704: CALL_OW 313
51708: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51709: LD_VAR 0 8
51713: PPUSH
51714: LD_INT 25
51716: PUSH
51717: LD_INT 12
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: PPUSH
51724: CALL_OW 72
51728: NOT
51729: IFFALSE 51739
// control := control_manual ;
51731: LD_ADDR_VAR 0 4
51735: PUSH
51736: LD_INT 1
51738: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51739: LD_ADDR_VAR 0 8
51743: PUSH
51744: LD_VAR 0 1
51748: PPUSH
51749: CALL 51436 0 1
51753: ST_TO_ADDR
// if tmp then
51754: LD_VAR 0 8
51758: IFFALSE 51801
// begin for i in tmp do
51760: LD_ADDR_VAR 0 7
51764: PUSH
51765: LD_VAR 0 8
51769: PUSH
51770: FOR_IN
51771: IFFALSE 51799
// if i [ 1 ] = b_ext_radio then
51773: LD_VAR 0 7
51777: PUSH
51778: LD_INT 1
51780: ARRAY
51781: PUSH
51782: LD_INT 22
51784: EQUAL
51785: IFFALSE 51797
// begin control := control_remote ;
51787: LD_ADDR_VAR 0 4
51791: PUSH
51792: LD_INT 2
51794: ST_TO_ADDR
// break ;
51795: GO 51799
// end ;
51797: GO 51770
51799: POP
51800: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51801: LD_VAR 0 1
51805: PPUSH
51806: LD_VAR 0 2
51810: PPUSH
51811: LD_VAR 0 3
51815: PPUSH
51816: LD_VAR 0 4
51820: PPUSH
51821: LD_VAR 0 5
51825: PPUSH
51826: CALL_OW 448
51830: IFFALSE 51865
// begin result := [ chassis , engine , control , weapon ] ;
51832: LD_ADDR_VAR 0 6
51836: PUSH
51837: LD_VAR 0 2
51841: PUSH
51842: LD_VAR 0 3
51846: PUSH
51847: LD_VAR 0 4
51851: PUSH
51852: LD_VAR 0 5
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: LIST
51861: LIST
51862: ST_TO_ADDR
// exit ;
51863: GO 52277
// end ; _chassis := AvailableChassisList ( factory ) ;
51865: LD_ADDR_VAR 0 9
51869: PUSH
51870: LD_VAR 0 1
51874: PPUSH
51875: CALL_OW 475
51879: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51880: LD_ADDR_VAR 0 11
51884: PUSH
51885: LD_VAR 0 1
51889: PPUSH
51890: CALL_OW 476
51894: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51895: LD_ADDR_VAR 0 12
51899: PUSH
51900: LD_VAR 0 1
51904: PPUSH
51905: CALL_OW 477
51909: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51910: LD_ADDR_VAR 0 10
51914: PUSH
51915: LD_VAR 0 1
51919: PPUSH
51920: CALL_OW 478
51924: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51925: LD_VAR 0 9
51929: NOT
51930: PUSH
51931: LD_VAR 0 11
51935: NOT
51936: OR
51937: PUSH
51938: LD_VAR 0 12
51942: NOT
51943: OR
51944: PUSH
51945: LD_VAR 0 10
51949: NOT
51950: OR
51951: IFFALSE 51986
// begin result := [ chassis , engine , control , weapon ] ;
51953: LD_ADDR_VAR 0 6
51957: PUSH
51958: LD_VAR 0 2
51962: PUSH
51963: LD_VAR 0 3
51967: PUSH
51968: LD_VAR 0 4
51972: PUSH
51973: LD_VAR 0 5
51977: PUSH
51978: EMPTY
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: ST_TO_ADDR
// exit ;
51984: GO 52277
// end ; if not chassis in _chassis then
51986: LD_VAR 0 2
51990: PUSH
51991: LD_VAR 0 9
51995: IN
51996: NOT
51997: IFFALSE 52023
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51999: LD_ADDR_VAR 0 2
52003: PUSH
52004: LD_VAR 0 9
52008: PUSH
52009: LD_INT 1
52011: PPUSH
52012: LD_VAR 0 9
52016: PPUSH
52017: CALL_OW 12
52021: ARRAY
52022: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52023: LD_VAR 0 2
52027: PPUSH
52028: LD_VAR 0 3
52032: PPUSH
52033: CALL 52282 0 2
52037: NOT
52038: IFFALSE 52097
// repeat engine := _engine [ 1 ] ;
52040: LD_ADDR_VAR 0 3
52044: PUSH
52045: LD_VAR 0 11
52049: PUSH
52050: LD_INT 1
52052: ARRAY
52053: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52054: LD_ADDR_VAR 0 11
52058: PUSH
52059: LD_VAR 0 11
52063: PPUSH
52064: LD_INT 1
52066: PPUSH
52067: CALL_OW 3
52071: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52072: LD_VAR 0 2
52076: PPUSH
52077: LD_VAR 0 3
52081: PPUSH
52082: CALL 52282 0 2
52086: PUSH
52087: LD_VAR 0 11
52091: PUSH
52092: EMPTY
52093: EQUAL
52094: OR
52095: IFFALSE 52040
// if not control in _control then
52097: LD_VAR 0 4
52101: PUSH
52102: LD_VAR 0 12
52106: IN
52107: NOT
52108: IFFALSE 52134
// control := _control [ rand ( 1 , _control ) ] ;
52110: LD_ADDR_VAR 0 4
52114: PUSH
52115: LD_VAR 0 12
52119: PUSH
52120: LD_INT 1
52122: PPUSH
52123: LD_VAR 0 12
52127: PPUSH
52128: CALL_OW 12
52132: ARRAY
52133: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52134: LD_VAR 0 2
52138: PPUSH
52139: LD_VAR 0 5
52143: PPUSH
52144: CALL 52502 0 2
52148: NOT
52149: IFFALSE 52208
// repeat weapon := _weapon [ 1 ] ;
52151: LD_ADDR_VAR 0 5
52155: PUSH
52156: LD_VAR 0 10
52160: PUSH
52161: LD_INT 1
52163: ARRAY
52164: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52165: LD_ADDR_VAR 0 10
52169: PUSH
52170: LD_VAR 0 10
52174: PPUSH
52175: LD_INT 1
52177: PPUSH
52178: CALL_OW 3
52182: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52183: LD_VAR 0 2
52187: PPUSH
52188: LD_VAR 0 5
52192: PPUSH
52193: CALL 52502 0 2
52197: PUSH
52198: LD_VAR 0 10
52202: PUSH
52203: EMPTY
52204: EQUAL
52205: OR
52206: IFFALSE 52151
// result := [ ] ;
52208: LD_ADDR_VAR 0 6
52212: PUSH
52213: EMPTY
52214: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52215: LD_VAR 0 1
52219: PPUSH
52220: LD_VAR 0 2
52224: PPUSH
52225: LD_VAR 0 3
52229: PPUSH
52230: LD_VAR 0 4
52234: PPUSH
52235: LD_VAR 0 5
52239: PPUSH
52240: CALL_OW 448
52244: IFFALSE 52277
// result := [ chassis , engine , control , weapon ] ;
52246: LD_ADDR_VAR 0 6
52250: PUSH
52251: LD_VAR 0 2
52255: PUSH
52256: LD_VAR 0 3
52260: PUSH
52261: LD_VAR 0 4
52265: PUSH
52266: LD_VAR 0 5
52270: PUSH
52271: EMPTY
52272: LIST
52273: LIST
52274: LIST
52275: LIST
52276: ST_TO_ADDR
// end ;
52277: LD_VAR 0 6
52281: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52282: LD_INT 0
52284: PPUSH
// if not chassis or not engine then
52285: LD_VAR 0 1
52289: NOT
52290: PUSH
52291: LD_VAR 0 2
52295: NOT
52296: OR
52297: IFFALSE 52301
// exit ;
52299: GO 52497
// case engine of engine_solar :
52301: LD_VAR 0 2
52305: PUSH
52306: LD_INT 2
52308: DOUBLE
52309: EQUAL
52310: IFTRUE 52314
52312: GO 52352
52314: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52315: LD_ADDR_VAR 0 3
52319: PUSH
52320: LD_INT 11
52322: PUSH
52323: LD_INT 12
52325: PUSH
52326: LD_INT 13
52328: PUSH
52329: LD_INT 14
52331: PUSH
52332: LD_INT 1
52334: PUSH
52335: LD_INT 2
52337: PUSH
52338: LD_INT 3
52340: PUSH
52341: EMPTY
52342: LIST
52343: LIST
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: ST_TO_ADDR
52350: GO 52481
52352: LD_INT 1
52354: DOUBLE
52355: EQUAL
52356: IFTRUE 52360
52358: GO 52422
52360: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52361: LD_ADDR_VAR 0 3
52365: PUSH
52366: LD_INT 11
52368: PUSH
52369: LD_INT 12
52371: PUSH
52372: LD_INT 13
52374: PUSH
52375: LD_INT 14
52377: PUSH
52378: LD_INT 1
52380: PUSH
52381: LD_INT 2
52383: PUSH
52384: LD_INT 3
52386: PUSH
52387: LD_INT 4
52389: PUSH
52390: LD_INT 5
52392: PUSH
52393: LD_INT 21
52395: PUSH
52396: LD_INT 23
52398: PUSH
52399: LD_INT 22
52401: PUSH
52402: LD_INT 24
52404: PUSH
52405: EMPTY
52406: LIST
52407: LIST
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: LIST
52416: LIST
52417: LIST
52418: LIST
52419: ST_TO_ADDR
52420: GO 52481
52422: LD_INT 3
52424: DOUBLE
52425: EQUAL
52426: IFTRUE 52430
52428: GO 52480
52430: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52431: LD_ADDR_VAR 0 3
52435: PUSH
52436: LD_INT 13
52438: PUSH
52439: LD_INT 14
52441: PUSH
52442: LD_INT 2
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: LD_INT 21
52456: PUSH
52457: LD_INT 22
52459: PUSH
52460: LD_INT 23
52462: PUSH
52463: LD_INT 24
52465: PUSH
52466: EMPTY
52467: LIST
52468: LIST
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: LIST
52475: LIST
52476: LIST
52477: ST_TO_ADDR
52478: GO 52481
52480: POP
// result := ( chassis in result ) ;
52481: LD_ADDR_VAR 0 3
52485: PUSH
52486: LD_VAR 0 1
52490: PUSH
52491: LD_VAR 0 3
52495: IN
52496: ST_TO_ADDR
// end ;
52497: LD_VAR 0 3
52501: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52502: LD_INT 0
52504: PPUSH
// if not chassis or not weapon then
52505: LD_VAR 0 1
52509: NOT
52510: PUSH
52511: LD_VAR 0 2
52515: NOT
52516: OR
52517: IFFALSE 52521
// exit ;
52519: GO 53581
// case weapon of us_machine_gun :
52521: LD_VAR 0 2
52525: PUSH
52526: LD_INT 2
52528: DOUBLE
52529: EQUAL
52530: IFTRUE 52534
52532: GO 52564
52534: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52535: LD_ADDR_VAR 0 3
52539: PUSH
52540: LD_INT 1
52542: PUSH
52543: LD_INT 2
52545: PUSH
52546: LD_INT 3
52548: PUSH
52549: LD_INT 4
52551: PUSH
52552: LD_INT 5
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: ST_TO_ADDR
52562: GO 53565
52564: LD_INT 3
52566: DOUBLE
52567: EQUAL
52568: IFTRUE 52572
52570: GO 52602
52572: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52573: LD_ADDR_VAR 0 3
52577: PUSH
52578: LD_INT 1
52580: PUSH
52581: LD_INT 2
52583: PUSH
52584: LD_INT 3
52586: PUSH
52587: LD_INT 4
52589: PUSH
52590: LD_INT 5
52592: PUSH
52593: EMPTY
52594: LIST
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: ST_TO_ADDR
52600: GO 53565
52602: LD_INT 11
52604: DOUBLE
52605: EQUAL
52606: IFTRUE 52610
52608: GO 52640
52610: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52611: LD_ADDR_VAR 0 3
52615: PUSH
52616: LD_INT 1
52618: PUSH
52619: LD_INT 2
52621: PUSH
52622: LD_INT 3
52624: PUSH
52625: LD_INT 4
52627: PUSH
52628: LD_INT 5
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: LIST
52635: LIST
52636: LIST
52637: ST_TO_ADDR
52638: GO 53565
52640: LD_INT 4
52642: DOUBLE
52643: EQUAL
52644: IFTRUE 52648
52646: GO 52674
52648: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52649: LD_ADDR_VAR 0 3
52653: PUSH
52654: LD_INT 2
52656: PUSH
52657: LD_INT 3
52659: PUSH
52660: LD_INT 4
52662: PUSH
52663: LD_INT 5
52665: PUSH
52666: EMPTY
52667: LIST
52668: LIST
52669: LIST
52670: LIST
52671: ST_TO_ADDR
52672: GO 53565
52674: LD_INT 5
52676: DOUBLE
52677: EQUAL
52678: IFTRUE 52682
52680: GO 52708
52682: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52683: LD_ADDR_VAR 0 3
52687: PUSH
52688: LD_INT 2
52690: PUSH
52691: LD_INT 3
52693: PUSH
52694: LD_INT 4
52696: PUSH
52697: LD_INT 5
52699: PUSH
52700: EMPTY
52701: LIST
52702: LIST
52703: LIST
52704: LIST
52705: ST_TO_ADDR
52706: GO 53565
52708: LD_INT 9
52710: DOUBLE
52711: EQUAL
52712: IFTRUE 52716
52714: GO 52742
52716: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_INT 2
52724: PUSH
52725: LD_INT 3
52727: PUSH
52728: LD_INT 4
52730: PUSH
52731: LD_INT 5
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: LIST
52738: LIST
52739: ST_TO_ADDR
52740: GO 53565
52742: LD_INT 7
52744: DOUBLE
52745: EQUAL
52746: IFTRUE 52750
52748: GO 52776
52750: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52751: LD_ADDR_VAR 0 3
52755: PUSH
52756: LD_INT 2
52758: PUSH
52759: LD_INT 3
52761: PUSH
52762: LD_INT 4
52764: PUSH
52765: LD_INT 5
52767: PUSH
52768: EMPTY
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: ST_TO_ADDR
52774: GO 53565
52776: LD_INT 12
52778: DOUBLE
52779: EQUAL
52780: IFTRUE 52784
52782: GO 52810
52784: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52785: LD_ADDR_VAR 0 3
52789: PUSH
52790: LD_INT 2
52792: PUSH
52793: LD_INT 3
52795: PUSH
52796: LD_INT 4
52798: PUSH
52799: LD_INT 5
52801: PUSH
52802: EMPTY
52803: LIST
52804: LIST
52805: LIST
52806: LIST
52807: ST_TO_ADDR
52808: GO 53565
52810: LD_INT 13
52812: DOUBLE
52813: EQUAL
52814: IFTRUE 52818
52816: GO 52844
52818: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52819: LD_ADDR_VAR 0 3
52823: PUSH
52824: LD_INT 2
52826: PUSH
52827: LD_INT 3
52829: PUSH
52830: LD_INT 4
52832: PUSH
52833: LD_INT 5
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: LIST
52840: LIST
52841: ST_TO_ADDR
52842: GO 53565
52844: LD_INT 14
52846: DOUBLE
52847: EQUAL
52848: IFTRUE 52852
52850: GO 52870
52852: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52853: LD_ADDR_VAR 0 3
52857: PUSH
52858: LD_INT 4
52860: PUSH
52861: LD_INT 5
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: ST_TO_ADDR
52868: GO 53565
52870: LD_INT 6
52872: DOUBLE
52873: EQUAL
52874: IFTRUE 52878
52876: GO 52896
52878: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52879: LD_ADDR_VAR 0 3
52883: PUSH
52884: LD_INT 4
52886: PUSH
52887: LD_INT 5
52889: PUSH
52890: EMPTY
52891: LIST
52892: LIST
52893: ST_TO_ADDR
52894: GO 53565
52896: LD_INT 10
52898: DOUBLE
52899: EQUAL
52900: IFTRUE 52904
52902: GO 52922
52904: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52905: LD_ADDR_VAR 0 3
52909: PUSH
52910: LD_INT 4
52912: PUSH
52913: LD_INT 5
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: ST_TO_ADDR
52920: GO 53565
52922: LD_INT 22
52924: DOUBLE
52925: EQUAL
52926: IFTRUE 52930
52928: GO 52956
52930: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52931: LD_ADDR_VAR 0 3
52935: PUSH
52936: LD_INT 11
52938: PUSH
52939: LD_INT 12
52941: PUSH
52942: LD_INT 13
52944: PUSH
52945: LD_INT 14
52947: PUSH
52948: EMPTY
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: ST_TO_ADDR
52954: GO 53565
52956: LD_INT 23
52958: DOUBLE
52959: EQUAL
52960: IFTRUE 52964
52962: GO 52990
52964: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52965: LD_ADDR_VAR 0 3
52969: PUSH
52970: LD_INT 11
52972: PUSH
52973: LD_INT 12
52975: PUSH
52976: LD_INT 13
52978: PUSH
52979: LD_INT 14
52981: PUSH
52982: EMPTY
52983: LIST
52984: LIST
52985: LIST
52986: LIST
52987: ST_TO_ADDR
52988: GO 53565
52990: LD_INT 24
52992: DOUBLE
52993: EQUAL
52994: IFTRUE 52998
52996: GO 53024
52998: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52999: LD_ADDR_VAR 0 3
53003: PUSH
53004: LD_INT 11
53006: PUSH
53007: LD_INT 12
53009: PUSH
53010: LD_INT 13
53012: PUSH
53013: LD_INT 14
53015: PUSH
53016: EMPTY
53017: LIST
53018: LIST
53019: LIST
53020: LIST
53021: ST_TO_ADDR
53022: GO 53565
53024: LD_INT 30
53026: DOUBLE
53027: EQUAL
53028: IFTRUE 53032
53030: GO 53058
53032: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53033: LD_ADDR_VAR 0 3
53037: PUSH
53038: LD_INT 11
53040: PUSH
53041: LD_INT 12
53043: PUSH
53044: LD_INT 13
53046: PUSH
53047: LD_INT 14
53049: PUSH
53050: EMPTY
53051: LIST
53052: LIST
53053: LIST
53054: LIST
53055: ST_TO_ADDR
53056: GO 53565
53058: LD_INT 25
53060: DOUBLE
53061: EQUAL
53062: IFTRUE 53066
53064: GO 53084
53066: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53067: LD_ADDR_VAR 0 3
53071: PUSH
53072: LD_INT 13
53074: PUSH
53075: LD_INT 14
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: ST_TO_ADDR
53082: GO 53565
53084: LD_INT 27
53086: DOUBLE
53087: EQUAL
53088: IFTRUE 53092
53090: GO 53110
53092: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53093: LD_ADDR_VAR 0 3
53097: PUSH
53098: LD_INT 13
53100: PUSH
53101: LD_INT 14
53103: PUSH
53104: EMPTY
53105: LIST
53106: LIST
53107: ST_TO_ADDR
53108: GO 53565
53110: LD_INT 92
53112: DOUBLE
53113: EQUAL
53114: IFTRUE 53118
53116: GO 53144
53118: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53119: LD_ADDR_VAR 0 3
53123: PUSH
53124: LD_INT 11
53126: PUSH
53127: LD_INT 12
53129: PUSH
53130: LD_INT 13
53132: PUSH
53133: LD_INT 14
53135: PUSH
53136: EMPTY
53137: LIST
53138: LIST
53139: LIST
53140: LIST
53141: ST_TO_ADDR
53142: GO 53565
53144: LD_INT 28
53146: DOUBLE
53147: EQUAL
53148: IFTRUE 53152
53150: GO 53170
53152: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53153: LD_ADDR_VAR 0 3
53157: PUSH
53158: LD_INT 13
53160: PUSH
53161: LD_INT 14
53163: PUSH
53164: EMPTY
53165: LIST
53166: LIST
53167: ST_TO_ADDR
53168: GO 53565
53170: LD_INT 29
53172: DOUBLE
53173: EQUAL
53174: IFTRUE 53178
53176: GO 53196
53178: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53179: LD_ADDR_VAR 0 3
53183: PUSH
53184: LD_INT 13
53186: PUSH
53187: LD_INT 14
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: ST_TO_ADDR
53194: GO 53565
53196: LD_INT 31
53198: DOUBLE
53199: EQUAL
53200: IFTRUE 53204
53202: GO 53222
53204: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53205: LD_ADDR_VAR 0 3
53209: PUSH
53210: LD_INT 13
53212: PUSH
53213: LD_INT 14
53215: PUSH
53216: EMPTY
53217: LIST
53218: LIST
53219: ST_TO_ADDR
53220: GO 53565
53222: LD_INT 26
53224: DOUBLE
53225: EQUAL
53226: IFTRUE 53230
53228: GO 53248
53230: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53231: LD_ADDR_VAR 0 3
53235: PUSH
53236: LD_INT 13
53238: PUSH
53239: LD_INT 14
53241: PUSH
53242: EMPTY
53243: LIST
53244: LIST
53245: ST_TO_ADDR
53246: GO 53565
53248: LD_INT 42
53250: DOUBLE
53251: EQUAL
53252: IFTRUE 53256
53254: GO 53282
53256: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_INT 21
53264: PUSH
53265: LD_INT 22
53267: PUSH
53268: LD_INT 23
53270: PUSH
53271: LD_INT 24
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: LIST
53278: LIST
53279: ST_TO_ADDR
53280: GO 53565
53282: LD_INT 43
53284: DOUBLE
53285: EQUAL
53286: IFTRUE 53290
53288: GO 53316
53290: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53291: LD_ADDR_VAR 0 3
53295: PUSH
53296: LD_INT 21
53298: PUSH
53299: LD_INT 22
53301: PUSH
53302: LD_INT 23
53304: PUSH
53305: LD_INT 24
53307: PUSH
53308: EMPTY
53309: LIST
53310: LIST
53311: LIST
53312: LIST
53313: ST_TO_ADDR
53314: GO 53565
53316: LD_INT 44
53318: DOUBLE
53319: EQUAL
53320: IFTRUE 53324
53322: GO 53350
53324: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53325: LD_ADDR_VAR 0 3
53329: PUSH
53330: LD_INT 21
53332: PUSH
53333: LD_INT 22
53335: PUSH
53336: LD_INT 23
53338: PUSH
53339: LD_INT 24
53341: PUSH
53342: EMPTY
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: ST_TO_ADDR
53348: GO 53565
53350: LD_INT 45
53352: DOUBLE
53353: EQUAL
53354: IFTRUE 53358
53356: GO 53384
53358: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53359: LD_ADDR_VAR 0 3
53363: PUSH
53364: LD_INT 21
53366: PUSH
53367: LD_INT 22
53369: PUSH
53370: LD_INT 23
53372: PUSH
53373: LD_INT 24
53375: PUSH
53376: EMPTY
53377: LIST
53378: LIST
53379: LIST
53380: LIST
53381: ST_TO_ADDR
53382: GO 53565
53384: LD_INT 49
53386: DOUBLE
53387: EQUAL
53388: IFTRUE 53392
53390: GO 53418
53392: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53393: LD_ADDR_VAR 0 3
53397: PUSH
53398: LD_INT 21
53400: PUSH
53401: LD_INT 22
53403: PUSH
53404: LD_INT 23
53406: PUSH
53407: LD_INT 24
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: LIST
53414: LIST
53415: ST_TO_ADDR
53416: GO 53565
53418: LD_INT 51
53420: DOUBLE
53421: EQUAL
53422: IFTRUE 53426
53424: GO 53452
53426: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53427: LD_ADDR_VAR 0 3
53431: PUSH
53432: LD_INT 21
53434: PUSH
53435: LD_INT 22
53437: PUSH
53438: LD_INT 23
53440: PUSH
53441: LD_INT 24
53443: PUSH
53444: EMPTY
53445: LIST
53446: LIST
53447: LIST
53448: LIST
53449: ST_TO_ADDR
53450: GO 53565
53452: LD_INT 52
53454: DOUBLE
53455: EQUAL
53456: IFTRUE 53460
53458: GO 53486
53460: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53461: LD_ADDR_VAR 0 3
53465: PUSH
53466: LD_INT 21
53468: PUSH
53469: LD_INT 22
53471: PUSH
53472: LD_INT 23
53474: PUSH
53475: LD_INT 24
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: LIST
53482: LIST
53483: ST_TO_ADDR
53484: GO 53565
53486: LD_INT 53
53488: DOUBLE
53489: EQUAL
53490: IFTRUE 53494
53492: GO 53512
53494: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53495: LD_ADDR_VAR 0 3
53499: PUSH
53500: LD_INT 23
53502: PUSH
53503: LD_INT 24
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: ST_TO_ADDR
53510: GO 53565
53512: LD_INT 46
53514: DOUBLE
53515: EQUAL
53516: IFTRUE 53520
53518: GO 53538
53520: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53521: LD_ADDR_VAR 0 3
53525: PUSH
53526: LD_INT 23
53528: PUSH
53529: LD_INT 24
53531: PUSH
53532: EMPTY
53533: LIST
53534: LIST
53535: ST_TO_ADDR
53536: GO 53565
53538: LD_INT 47
53540: DOUBLE
53541: EQUAL
53542: IFTRUE 53546
53544: GO 53564
53546: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53547: LD_ADDR_VAR 0 3
53551: PUSH
53552: LD_INT 23
53554: PUSH
53555: LD_INT 24
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: ST_TO_ADDR
53562: GO 53565
53564: POP
// result := ( chassis in result ) ;
53565: LD_ADDR_VAR 0 3
53569: PUSH
53570: LD_VAR 0 1
53574: PUSH
53575: LD_VAR 0 3
53579: IN
53580: ST_TO_ADDR
// end ;
53581: LD_VAR 0 3
53585: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53586: LD_INT 0
53588: PPUSH
53589: PPUSH
53590: PPUSH
53591: PPUSH
53592: PPUSH
53593: PPUSH
53594: PPUSH
// result := array ;
53595: LD_ADDR_VAR 0 5
53599: PUSH
53600: LD_VAR 0 1
53604: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53605: LD_VAR 0 1
53609: NOT
53610: PUSH
53611: LD_VAR 0 2
53615: NOT
53616: OR
53617: PUSH
53618: LD_VAR 0 3
53622: NOT
53623: OR
53624: PUSH
53625: LD_VAR 0 2
53629: PUSH
53630: LD_VAR 0 1
53634: GREATER
53635: OR
53636: PUSH
53637: LD_VAR 0 3
53641: PUSH
53642: LD_VAR 0 1
53646: GREATER
53647: OR
53648: IFFALSE 53652
// exit ;
53650: GO 53948
// if direction then
53652: LD_VAR 0 4
53656: IFFALSE 53720
// begin d := 1 ;
53658: LD_ADDR_VAR 0 9
53662: PUSH
53663: LD_INT 1
53665: ST_TO_ADDR
// if i_from > i_to then
53666: LD_VAR 0 2
53670: PUSH
53671: LD_VAR 0 3
53675: GREATER
53676: IFFALSE 53702
// length := ( array - i_from ) + i_to else
53678: LD_ADDR_VAR 0 11
53682: PUSH
53683: LD_VAR 0 1
53687: PUSH
53688: LD_VAR 0 2
53692: MINUS
53693: PUSH
53694: LD_VAR 0 3
53698: PLUS
53699: ST_TO_ADDR
53700: GO 53718
// length := i_to - i_from ;
53702: LD_ADDR_VAR 0 11
53706: PUSH
53707: LD_VAR 0 3
53711: PUSH
53712: LD_VAR 0 2
53716: MINUS
53717: ST_TO_ADDR
// end else
53718: GO 53781
// begin d := - 1 ;
53720: LD_ADDR_VAR 0 9
53724: PUSH
53725: LD_INT 1
53727: NEG
53728: ST_TO_ADDR
// if i_from > i_to then
53729: LD_VAR 0 2
53733: PUSH
53734: LD_VAR 0 3
53738: GREATER
53739: IFFALSE 53759
// length := i_from - i_to else
53741: LD_ADDR_VAR 0 11
53745: PUSH
53746: LD_VAR 0 2
53750: PUSH
53751: LD_VAR 0 3
53755: MINUS
53756: ST_TO_ADDR
53757: GO 53781
// length := ( array - i_to ) + i_from ;
53759: LD_ADDR_VAR 0 11
53763: PUSH
53764: LD_VAR 0 1
53768: PUSH
53769: LD_VAR 0 3
53773: MINUS
53774: PUSH
53775: LD_VAR 0 2
53779: PLUS
53780: ST_TO_ADDR
// end ; if not length then
53781: LD_VAR 0 11
53785: NOT
53786: IFFALSE 53790
// exit ;
53788: GO 53948
// tmp := array ;
53790: LD_ADDR_VAR 0 10
53794: PUSH
53795: LD_VAR 0 1
53799: ST_TO_ADDR
// for i = 1 to length do
53800: LD_ADDR_VAR 0 6
53804: PUSH
53805: DOUBLE
53806: LD_INT 1
53808: DEC
53809: ST_TO_ADDR
53810: LD_VAR 0 11
53814: PUSH
53815: FOR_TO
53816: IFFALSE 53936
// begin for j = 1 to array do
53818: LD_ADDR_VAR 0 7
53822: PUSH
53823: DOUBLE
53824: LD_INT 1
53826: DEC
53827: ST_TO_ADDR
53828: LD_VAR 0 1
53832: PUSH
53833: FOR_TO
53834: IFFALSE 53922
// begin k := j + d ;
53836: LD_ADDR_VAR 0 8
53840: PUSH
53841: LD_VAR 0 7
53845: PUSH
53846: LD_VAR 0 9
53850: PLUS
53851: ST_TO_ADDR
// if k > array then
53852: LD_VAR 0 8
53856: PUSH
53857: LD_VAR 0 1
53861: GREATER
53862: IFFALSE 53872
// k := 1 ;
53864: LD_ADDR_VAR 0 8
53868: PUSH
53869: LD_INT 1
53871: ST_TO_ADDR
// if not k then
53872: LD_VAR 0 8
53876: NOT
53877: IFFALSE 53889
// k := array ;
53879: LD_ADDR_VAR 0 8
53883: PUSH
53884: LD_VAR 0 1
53888: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53889: LD_ADDR_VAR 0 10
53893: PUSH
53894: LD_VAR 0 10
53898: PPUSH
53899: LD_VAR 0 8
53903: PPUSH
53904: LD_VAR 0 1
53908: PUSH
53909: LD_VAR 0 7
53913: ARRAY
53914: PPUSH
53915: CALL_OW 1
53919: ST_TO_ADDR
// end ;
53920: GO 53833
53922: POP
53923: POP
// array := tmp ;
53924: LD_ADDR_VAR 0 1
53928: PUSH
53929: LD_VAR 0 10
53933: ST_TO_ADDR
// end ;
53934: GO 53815
53936: POP
53937: POP
// result := array ;
53938: LD_ADDR_VAR 0 5
53942: PUSH
53943: LD_VAR 0 1
53947: ST_TO_ADDR
// end ;
53948: LD_VAR 0 5
53952: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53953: LD_INT 0
53955: PPUSH
53956: PPUSH
// result := 0 ;
53957: LD_ADDR_VAR 0 3
53961: PUSH
53962: LD_INT 0
53964: ST_TO_ADDR
// if not array or not value in array then
53965: LD_VAR 0 1
53969: NOT
53970: PUSH
53971: LD_VAR 0 2
53975: PUSH
53976: LD_VAR 0 1
53980: IN
53981: NOT
53982: OR
53983: IFFALSE 53987
// exit ;
53985: GO 54041
// for i = 1 to array do
53987: LD_ADDR_VAR 0 4
53991: PUSH
53992: DOUBLE
53993: LD_INT 1
53995: DEC
53996: ST_TO_ADDR
53997: LD_VAR 0 1
54001: PUSH
54002: FOR_TO
54003: IFFALSE 54039
// if value = array [ i ] then
54005: LD_VAR 0 2
54009: PUSH
54010: LD_VAR 0 1
54014: PUSH
54015: LD_VAR 0 4
54019: ARRAY
54020: EQUAL
54021: IFFALSE 54037
// begin result := i ;
54023: LD_ADDR_VAR 0 3
54027: PUSH
54028: LD_VAR 0 4
54032: ST_TO_ADDR
// exit ;
54033: POP
54034: POP
54035: GO 54041
// end ;
54037: GO 54002
54039: POP
54040: POP
// end ;
54041: LD_VAR 0 3
54045: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54046: LD_INT 0
54048: PPUSH
// vc_chassis := chassis ;
54049: LD_ADDR_OWVAR 37
54053: PUSH
54054: LD_VAR 0 1
54058: ST_TO_ADDR
// vc_engine := engine ;
54059: LD_ADDR_OWVAR 39
54063: PUSH
54064: LD_VAR 0 2
54068: ST_TO_ADDR
// vc_control := control ;
54069: LD_ADDR_OWVAR 38
54073: PUSH
54074: LD_VAR 0 3
54078: ST_TO_ADDR
// vc_weapon := weapon ;
54079: LD_ADDR_OWVAR 40
54083: PUSH
54084: LD_VAR 0 4
54088: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54089: LD_ADDR_OWVAR 41
54093: PUSH
54094: LD_VAR 0 5
54098: ST_TO_ADDR
// end ;
54099: LD_VAR 0 6
54103: RET
// export function WantPlant ( unit ) ; var task ; begin
54104: LD_INT 0
54106: PPUSH
54107: PPUSH
// result := false ;
54108: LD_ADDR_VAR 0 2
54112: PUSH
54113: LD_INT 0
54115: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54116: LD_ADDR_VAR 0 3
54120: PUSH
54121: LD_VAR 0 1
54125: PPUSH
54126: CALL_OW 437
54130: ST_TO_ADDR
// if task then
54131: LD_VAR 0 3
54135: IFFALSE 54163
// if task [ 1 ] [ 1 ] = p then
54137: LD_VAR 0 3
54141: PUSH
54142: LD_INT 1
54144: ARRAY
54145: PUSH
54146: LD_INT 1
54148: ARRAY
54149: PUSH
54150: LD_STRING p
54152: EQUAL
54153: IFFALSE 54163
// result := true ;
54155: LD_ADDR_VAR 0 2
54159: PUSH
54160: LD_INT 1
54162: ST_TO_ADDR
// end ;
54163: LD_VAR 0 2
54167: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54168: LD_INT 0
54170: PPUSH
54171: PPUSH
54172: PPUSH
54173: PPUSH
// if pos < 1 then
54174: LD_VAR 0 2
54178: PUSH
54179: LD_INT 1
54181: LESS
54182: IFFALSE 54186
// exit ;
54184: GO 54489
// if pos = 1 then
54186: LD_VAR 0 2
54190: PUSH
54191: LD_INT 1
54193: EQUAL
54194: IFFALSE 54227
// result := Replace ( arr , pos [ 1 ] , value ) else
54196: LD_ADDR_VAR 0 4
54200: PUSH
54201: LD_VAR 0 1
54205: PPUSH
54206: LD_VAR 0 2
54210: PUSH
54211: LD_INT 1
54213: ARRAY
54214: PPUSH
54215: LD_VAR 0 3
54219: PPUSH
54220: CALL_OW 1
54224: ST_TO_ADDR
54225: GO 54489
// begin tmp := arr ;
54227: LD_ADDR_VAR 0 6
54231: PUSH
54232: LD_VAR 0 1
54236: ST_TO_ADDR
// s_arr := [ tmp ] ;
54237: LD_ADDR_VAR 0 7
54241: PUSH
54242: LD_VAR 0 6
54246: PUSH
54247: EMPTY
54248: LIST
54249: ST_TO_ADDR
// for i = 1 to pos - 1 do
54250: LD_ADDR_VAR 0 5
54254: PUSH
54255: DOUBLE
54256: LD_INT 1
54258: DEC
54259: ST_TO_ADDR
54260: LD_VAR 0 2
54264: PUSH
54265: LD_INT 1
54267: MINUS
54268: PUSH
54269: FOR_TO
54270: IFFALSE 54315
// begin tmp := tmp [ pos [ i ] ] ;
54272: LD_ADDR_VAR 0 6
54276: PUSH
54277: LD_VAR 0 6
54281: PUSH
54282: LD_VAR 0 2
54286: PUSH
54287: LD_VAR 0 5
54291: ARRAY
54292: ARRAY
54293: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54294: LD_ADDR_VAR 0 7
54298: PUSH
54299: LD_VAR 0 7
54303: PUSH
54304: LD_VAR 0 6
54308: PUSH
54309: EMPTY
54310: LIST
54311: ADD
54312: ST_TO_ADDR
// end ;
54313: GO 54269
54315: POP
54316: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54317: LD_ADDR_VAR 0 6
54321: PUSH
54322: LD_VAR 0 6
54326: PPUSH
54327: LD_VAR 0 2
54331: PUSH
54332: LD_VAR 0 2
54336: ARRAY
54337: PPUSH
54338: LD_VAR 0 3
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54348: LD_ADDR_VAR 0 7
54352: PUSH
54353: LD_VAR 0 7
54357: PPUSH
54358: LD_VAR 0 7
54362: PPUSH
54363: LD_VAR 0 6
54367: PPUSH
54368: CALL_OW 1
54372: ST_TO_ADDR
// for i = s_arr downto 2 do
54373: LD_ADDR_VAR 0 5
54377: PUSH
54378: DOUBLE
54379: LD_VAR 0 7
54383: INC
54384: ST_TO_ADDR
54385: LD_INT 2
54387: PUSH
54388: FOR_DOWNTO
54389: IFFALSE 54473
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54391: LD_ADDR_VAR 0 6
54395: PUSH
54396: LD_VAR 0 7
54400: PUSH
54401: LD_VAR 0 5
54405: PUSH
54406: LD_INT 1
54408: MINUS
54409: ARRAY
54410: PPUSH
54411: LD_VAR 0 2
54415: PUSH
54416: LD_VAR 0 5
54420: PUSH
54421: LD_INT 1
54423: MINUS
54424: ARRAY
54425: PPUSH
54426: LD_VAR 0 7
54430: PUSH
54431: LD_VAR 0 5
54435: ARRAY
54436: PPUSH
54437: CALL_OW 1
54441: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54442: LD_ADDR_VAR 0 7
54446: PUSH
54447: LD_VAR 0 7
54451: PPUSH
54452: LD_VAR 0 5
54456: PUSH
54457: LD_INT 1
54459: MINUS
54460: PPUSH
54461: LD_VAR 0 6
54465: PPUSH
54466: CALL_OW 1
54470: ST_TO_ADDR
// end ;
54471: GO 54388
54473: POP
54474: POP
// result := s_arr [ 1 ] ;
54475: LD_ADDR_VAR 0 4
54479: PUSH
54480: LD_VAR 0 7
54484: PUSH
54485: LD_INT 1
54487: ARRAY
54488: ST_TO_ADDR
// end ; end ;
54489: LD_VAR 0 4
54493: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54494: LD_INT 0
54496: PPUSH
54497: PPUSH
// if not list then
54498: LD_VAR 0 1
54502: NOT
54503: IFFALSE 54507
// exit ;
54505: GO 54598
// i := list [ pos1 ] ;
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: LD_VAR 0 1
54516: PUSH
54517: LD_VAR 0 2
54521: ARRAY
54522: ST_TO_ADDR
// if not i then
54523: LD_VAR 0 5
54527: NOT
54528: IFFALSE 54532
// exit ;
54530: GO 54598
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54532: LD_ADDR_VAR 0 1
54536: PUSH
54537: LD_VAR 0 1
54541: PPUSH
54542: LD_VAR 0 2
54546: PPUSH
54547: LD_VAR 0 1
54551: PUSH
54552: LD_VAR 0 3
54556: ARRAY
54557: PPUSH
54558: CALL_OW 1
54562: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54563: LD_ADDR_VAR 0 1
54567: PUSH
54568: LD_VAR 0 1
54572: PPUSH
54573: LD_VAR 0 3
54577: PPUSH
54578: LD_VAR 0 5
54582: PPUSH
54583: CALL_OW 1
54587: ST_TO_ADDR
// result := list ;
54588: LD_ADDR_VAR 0 4
54592: PUSH
54593: LD_VAR 0 1
54597: ST_TO_ADDR
// end ;
54598: LD_VAR 0 4
54602: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54603: LD_INT 0
54605: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54606: LD_ADDR_VAR 0 5
54610: PUSH
54611: LD_VAR 0 1
54615: PPUSH
54616: CALL_OW 250
54620: PPUSH
54621: LD_VAR 0 1
54625: PPUSH
54626: CALL_OW 251
54630: PPUSH
54631: LD_VAR 0 2
54635: PPUSH
54636: LD_VAR 0 3
54640: PPUSH
54641: LD_VAR 0 4
54645: PPUSH
54646: CALL 55024 0 5
54650: ST_TO_ADDR
// end ;
54651: LD_VAR 0 5
54655: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54656: LD_INT 0
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
// if not list or not unit then
54662: LD_VAR 0 2
54666: NOT
54667: PUSH
54668: LD_VAR 0 1
54672: NOT
54673: OR
54674: IFFALSE 54678
// exit ;
54676: GO 55019
// result := [ ] ;
54678: LD_ADDR_VAR 0 5
54682: PUSH
54683: EMPTY
54684: ST_TO_ADDR
// for i in list do
54685: LD_ADDR_VAR 0 6
54689: PUSH
54690: LD_VAR 0 2
54694: PUSH
54695: FOR_IN
54696: IFFALSE 54914
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54698: LD_ADDR_VAR 0 8
54702: PUSH
54703: LD_VAR 0 1
54707: PPUSH
54708: LD_VAR 0 6
54712: PUSH
54713: LD_INT 1
54715: ARRAY
54716: PPUSH
54717: LD_VAR 0 6
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: PPUSH
54726: CALL_OW 297
54730: ST_TO_ADDR
// if not Count ( result ) then
54731: LD_VAR 0 5
54735: PPUSH
54736: CALL 51308 0 1
54740: NOT
54741: IFFALSE 54774
// begin result := Join ( result , [ i , tmp ] ) ;
54743: LD_ADDR_VAR 0 5
54747: PUSH
54748: LD_VAR 0 5
54752: PPUSH
54753: LD_VAR 0 6
54757: PUSH
54758: LD_VAR 0 8
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: PPUSH
54767: CALL 86917 0 2
54771: ST_TO_ADDR
// continue ;
54772: GO 54695
// end ; if result [ result ] [ 2 ] <= tmp then
54774: LD_VAR 0 5
54778: PUSH
54779: LD_VAR 0 5
54783: ARRAY
54784: PUSH
54785: LD_INT 2
54787: ARRAY
54788: PUSH
54789: LD_VAR 0 8
54793: LESSEQUAL
54794: IFFALSE 54827
// result := Join ( result , [ i , tmp ] ) else
54796: LD_ADDR_VAR 0 5
54800: PUSH
54801: LD_VAR 0 5
54805: PPUSH
54806: LD_VAR 0 6
54810: PUSH
54811: LD_VAR 0 8
54815: PUSH
54816: EMPTY
54817: LIST
54818: LIST
54819: PPUSH
54820: CALL 86917 0 2
54824: ST_TO_ADDR
54825: GO 54912
// begin for j := 1 to Count ( result ) do
54827: LD_ADDR_VAR 0 7
54831: PUSH
54832: DOUBLE
54833: LD_INT 1
54835: DEC
54836: ST_TO_ADDR
54837: LD_VAR 0 5
54841: PPUSH
54842: CALL 51308 0 1
54846: PUSH
54847: FOR_TO
54848: IFFALSE 54910
// begin if tmp < result [ j ] [ 2 ] then
54850: LD_VAR 0 8
54854: PUSH
54855: LD_VAR 0 5
54859: PUSH
54860: LD_VAR 0 7
54864: ARRAY
54865: PUSH
54866: LD_INT 2
54868: ARRAY
54869: LESS
54870: IFFALSE 54908
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54872: LD_ADDR_VAR 0 5
54876: PUSH
54877: LD_VAR 0 5
54881: PPUSH
54882: LD_VAR 0 7
54886: PPUSH
54887: LD_VAR 0 6
54891: PUSH
54892: LD_VAR 0 8
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: PPUSH
54901: CALL_OW 2
54905: ST_TO_ADDR
// break ;
54906: GO 54910
// end ; end ;
54908: GO 54847
54910: POP
54911: POP
// end ; end ;
54912: GO 54695
54914: POP
54915: POP
// if result and not asc then
54916: LD_VAR 0 5
54920: PUSH
54921: LD_VAR 0 3
54925: NOT
54926: AND
54927: IFFALSE 54944
// result := ReverseArray ( result ) ;
54929: LD_ADDR_VAR 0 5
54933: PUSH
54934: LD_VAR 0 5
54938: PPUSH
54939: CALL 82184 0 1
54943: ST_TO_ADDR
// tmp := [ ] ;
54944: LD_ADDR_VAR 0 8
54948: PUSH
54949: EMPTY
54950: ST_TO_ADDR
// if mode then
54951: LD_VAR 0 4
54955: IFFALSE 55019
// begin for i := 1 to result do
54957: LD_ADDR_VAR 0 6
54961: PUSH
54962: DOUBLE
54963: LD_INT 1
54965: DEC
54966: ST_TO_ADDR
54967: LD_VAR 0 5
54971: PUSH
54972: FOR_TO
54973: IFFALSE 55007
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54975: LD_ADDR_VAR 0 8
54979: PUSH
54980: LD_VAR 0 8
54984: PPUSH
54985: LD_VAR 0 5
54989: PUSH
54990: LD_VAR 0 6
54994: ARRAY
54995: PUSH
54996: LD_INT 1
54998: ARRAY
54999: PPUSH
55000: CALL 86917 0 2
55004: ST_TO_ADDR
55005: GO 54972
55007: POP
55008: POP
// result := tmp ;
55009: LD_ADDR_VAR 0 5
55013: PUSH
55014: LD_VAR 0 8
55018: ST_TO_ADDR
// end ; end ;
55019: LD_VAR 0 5
55023: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55024: LD_INT 0
55026: PPUSH
55027: PPUSH
55028: PPUSH
55029: PPUSH
// if not list then
55030: LD_VAR 0 3
55034: NOT
55035: IFFALSE 55039
// exit ;
55037: GO 55427
// result := [ ] ;
55039: LD_ADDR_VAR 0 6
55043: PUSH
55044: EMPTY
55045: ST_TO_ADDR
// for i in list do
55046: LD_ADDR_VAR 0 7
55050: PUSH
55051: LD_VAR 0 3
55055: PUSH
55056: FOR_IN
55057: IFFALSE 55259
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55059: LD_ADDR_VAR 0 9
55063: PUSH
55064: LD_VAR 0 7
55068: PPUSH
55069: LD_VAR 0 1
55073: PPUSH
55074: LD_VAR 0 2
55078: PPUSH
55079: CALL_OW 297
55083: ST_TO_ADDR
// if not result then
55084: LD_VAR 0 6
55088: NOT
55089: IFFALSE 55115
// result := [ [ i , tmp ] ] else
55091: LD_ADDR_VAR 0 6
55095: PUSH
55096: LD_VAR 0 7
55100: PUSH
55101: LD_VAR 0 9
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: PUSH
55110: EMPTY
55111: LIST
55112: ST_TO_ADDR
55113: GO 55257
// begin if result [ result ] [ 2 ] <= tmp then
55115: LD_VAR 0 6
55119: PUSH
55120: LD_VAR 0 6
55124: ARRAY
55125: PUSH
55126: LD_INT 2
55128: ARRAY
55129: PUSH
55130: LD_VAR 0 9
55134: LESSEQUAL
55135: IFFALSE 55177
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55137: LD_ADDR_VAR 0 6
55141: PUSH
55142: LD_VAR 0 6
55146: PPUSH
55147: LD_VAR 0 6
55151: PUSH
55152: LD_INT 1
55154: PLUS
55155: PPUSH
55156: LD_VAR 0 7
55160: PUSH
55161: LD_VAR 0 9
55165: PUSH
55166: EMPTY
55167: LIST
55168: LIST
55169: PPUSH
55170: CALL_OW 2
55174: ST_TO_ADDR
55175: GO 55257
// for j := 1 to result do
55177: LD_ADDR_VAR 0 8
55181: PUSH
55182: DOUBLE
55183: LD_INT 1
55185: DEC
55186: ST_TO_ADDR
55187: LD_VAR 0 6
55191: PUSH
55192: FOR_TO
55193: IFFALSE 55255
// begin if tmp < result [ j ] [ 2 ] then
55195: LD_VAR 0 9
55199: PUSH
55200: LD_VAR 0 6
55204: PUSH
55205: LD_VAR 0 8
55209: ARRAY
55210: PUSH
55211: LD_INT 2
55213: ARRAY
55214: LESS
55215: IFFALSE 55253
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55217: LD_ADDR_VAR 0 6
55221: PUSH
55222: LD_VAR 0 6
55226: PPUSH
55227: LD_VAR 0 8
55231: PPUSH
55232: LD_VAR 0 7
55236: PUSH
55237: LD_VAR 0 9
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: PPUSH
55246: CALL_OW 2
55250: ST_TO_ADDR
// break ;
55251: GO 55255
// end ; end ;
55253: GO 55192
55255: POP
55256: POP
// end ; end ;
55257: GO 55056
55259: POP
55260: POP
// if result and not asc then
55261: LD_VAR 0 6
55265: PUSH
55266: LD_VAR 0 4
55270: NOT
55271: AND
55272: IFFALSE 55347
// begin tmp := result ;
55274: LD_ADDR_VAR 0 9
55278: PUSH
55279: LD_VAR 0 6
55283: ST_TO_ADDR
// for i = tmp downto 1 do
55284: LD_ADDR_VAR 0 7
55288: PUSH
55289: DOUBLE
55290: LD_VAR 0 9
55294: INC
55295: ST_TO_ADDR
55296: LD_INT 1
55298: PUSH
55299: FOR_DOWNTO
55300: IFFALSE 55345
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55302: LD_ADDR_VAR 0 6
55306: PUSH
55307: LD_VAR 0 6
55311: PPUSH
55312: LD_VAR 0 9
55316: PUSH
55317: LD_VAR 0 7
55321: MINUS
55322: PUSH
55323: LD_INT 1
55325: PLUS
55326: PPUSH
55327: LD_VAR 0 9
55331: PUSH
55332: LD_VAR 0 7
55336: ARRAY
55337: PPUSH
55338: CALL_OW 1
55342: ST_TO_ADDR
55343: GO 55299
55345: POP
55346: POP
// end ; tmp := [ ] ;
55347: LD_ADDR_VAR 0 9
55351: PUSH
55352: EMPTY
55353: ST_TO_ADDR
// if mode then
55354: LD_VAR 0 5
55358: IFFALSE 55427
// begin for i = 1 to result do
55360: LD_ADDR_VAR 0 7
55364: PUSH
55365: DOUBLE
55366: LD_INT 1
55368: DEC
55369: ST_TO_ADDR
55370: LD_VAR 0 6
55374: PUSH
55375: FOR_TO
55376: IFFALSE 55415
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55378: LD_ADDR_VAR 0 9
55382: PUSH
55383: LD_VAR 0 9
55387: PPUSH
55388: LD_VAR 0 7
55392: PPUSH
55393: LD_VAR 0 6
55397: PUSH
55398: LD_VAR 0 7
55402: ARRAY
55403: PUSH
55404: LD_INT 1
55406: ARRAY
55407: PPUSH
55408: CALL_OW 1
55412: ST_TO_ADDR
55413: GO 55375
55415: POP
55416: POP
// result := tmp ;
55417: LD_ADDR_VAR 0 6
55421: PUSH
55422: LD_VAR 0 9
55426: ST_TO_ADDR
// end ; end ;
55427: LD_VAR 0 6
55431: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55432: LD_INT 0
55434: PPUSH
55435: PPUSH
55436: PPUSH
55437: PPUSH
55438: PPUSH
55439: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55440: LD_ADDR_VAR 0 5
55444: PUSH
55445: LD_INT 0
55447: PUSH
55448: LD_INT 0
55450: PUSH
55451: LD_INT 0
55453: PUSH
55454: EMPTY
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: LIST
55460: LIST
55461: ST_TO_ADDR
// if not x or not y then
55462: LD_VAR 0 2
55466: NOT
55467: PUSH
55468: LD_VAR 0 3
55472: NOT
55473: OR
55474: IFFALSE 55478
// exit ;
55476: GO 57128
// if not range then
55478: LD_VAR 0 4
55482: NOT
55483: IFFALSE 55493
// range := 10 ;
55485: LD_ADDR_VAR 0 4
55489: PUSH
55490: LD_INT 10
55492: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55493: LD_ADDR_VAR 0 8
55497: PUSH
55498: LD_INT 81
55500: PUSH
55501: LD_VAR 0 1
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: LD_INT 92
55512: PUSH
55513: LD_VAR 0 2
55517: PUSH
55518: LD_VAR 0 3
55522: PUSH
55523: LD_VAR 0 4
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: LIST
55532: LIST
55533: PUSH
55534: LD_INT 3
55536: PUSH
55537: LD_INT 21
55539: PUSH
55540: LD_INT 3
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: LIST
55555: PPUSH
55556: CALL_OW 69
55560: ST_TO_ADDR
// if not tmp then
55561: LD_VAR 0 8
55565: NOT
55566: IFFALSE 55570
// exit ;
55568: GO 57128
// for i in tmp do
55570: LD_ADDR_VAR 0 6
55574: PUSH
55575: LD_VAR 0 8
55579: PUSH
55580: FOR_IN
55581: IFFALSE 57103
// begin points := [ 0 , 0 , 0 ] ;
55583: LD_ADDR_VAR 0 9
55587: PUSH
55588: LD_INT 0
55590: PUSH
55591: LD_INT 0
55593: PUSH
55594: LD_INT 0
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: LIST
55601: ST_TO_ADDR
// bpoints := 1 ;
55602: LD_ADDR_VAR 0 10
55606: PUSH
55607: LD_INT 1
55609: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55610: LD_VAR 0 6
55614: PPUSH
55615: CALL_OW 247
55619: PUSH
55620: LD_INT 1
55622: DOUBLE
55623: EQUAL
55624: IFTRUE 55628
55626: GO 56206
55628: POP
// begin if GetClass ( i ) = 1 then
55629: LD_VAR 0 6
55633: PPUSH
55634: CALL_OW 257
55638: PUSH
55639: LD_INT 1
55641: EQUAL
55642: IFFALSE 55663
// points := [ 10 , 5 , 3 ] ;
55644: LD_ADDR_VAR 0 9
55648: PUSH
55649: LD_INT 10
55651: PUSH
55652: LD_INT 5
55654: PUSH
55655: LD_INT 3
55657: PUSH
55658: EMPTY
55659: LIST
55660: LIST
55661: LIST
55662: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55663: LD_VAR 0 6
55667: PPUSH
55668: CALL_OW 257
55672: PUSH
55673: LD_INT 2
55675: PUSH
55676: LD_INT 3
55678: PUSH
55679: LD_INT 4
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: LIST
55686: IN
55687: IFFALSE 55708
// points := [ 3 , 2 , 1 ] ;
55689: LD_ADDR_VAR 0 9
55693: PUSH
55694: LD_INT 3
55696: PUSH
55697: LD_INT 2
55699: PUSH
55700: LD_INT 1
55702: PUSH
55703: EMPTY
55704: LIST
55705: LIST
55706: LIST
55707: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55708: LD_VAR 0 6
55712: PPUSH
55713: CALL_OW 257
55717: PUSH
55718: LD_INT 5
55720: EQUAL
55721: IFFALSE 55742
// points := [ 130 , 5 , 2 ] ;
55723: LD_ADDR_VAR 0 9
55727: PUSH
55728: LD_INT 130
55730: PUSH
55731: LD_INT 5
55733: PUSH
55734: LD_INT 2
55736: PUSH
55737: EMPTY
55738: LIST
55739: LIST
55740: LIST
55741: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55742: LD_VAR 0 6
55746: PPUSH
55747: CALL_OW 257
55751: PUSH
55752: LD_INT 8
55754: EQUAL
55755: IFFALSE 55776
// points := [ 35 , 35 , 30 ] ;
55757: LD_ADDR_VAR 0 9
55761: PUSH
55762: LD_INT 35
55764: PUSH
55765: LD_INT 35
55767: PUSH
55768: LD_INT 30
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: LIST
55775: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55776: LD_VAR 0 6
55780: PPUSH
55781: CALL_OW 257
55785: PUSH
55786: LD_INT 9
55788: EQUAL
55789: IFFALSE 55810
// points := [ 20 , 55 , 40 ] ;
55791: LD_ADDR_VAR 0 9
55795: PUSH
55796: LD_INT 20
55798: PUSH
55799: LD_INT 55
55801: PUSH
55802: LD_INT 40
55804: PUSH
55805: EMPTY
55806: LIST
55807: LIST
55808: LIST
55809: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55810: LD_VAR 0 6
55814: PPUSH
55815: CALL_OW 257
55819: PUSH
55820: LD_INT 12
55822: PUSH
55823: LD_INT 16
55825: PUSH
55826: EMPTY
55827: LIST
55828: LIST
55829: IN
55830: IFFALSE 55851
// points := [ 5 , 3 , 2 ] ;
55832: LD_ADDR_VAR 0 9
55836: PUSH
55837: LD_INT 5
55839: PUSH
55840: LD_INT 3
55842: PUSH
55843: LD_INT 2
55845: PUSH
55846: EMPTY
55847: LIST
55848: LIST
55849: LIST
55850: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55851: LD_VAR 0 6
55855: PPUSH
55856: CALL_OW 257
55860: PUSH
55861: LD_INT 17
55863: EQUAL
55864: IFFALSE 55885
// points := [ 100 , 50 , 75 ] ;
55866: LD_ADDR_VAR 0 9
55870: PUSH
55871: LD_INT 100
55873: PUSH
55874: LD_INT 50
55876: PUSH
55877: LD_INT 75
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55885: LD_VAR 0 6
55889: PPUSH
55890: CALL_OW 257
55894: PUSH
55895: LD_INT 15
55897: EQUAL
55898: IFFALSE 55919
// points := [ 10 , 5 , 3 ] ;
55900: LD_ADDR_VAR 0 9
55904: PUSH
55905: LD_INT 10
55907: PUSH
55908: LD_INT 5
55910: PUSH
55911: LD_INT 3
55913: PUSH
55914: EMPTY
55915: LIST
55916: LIST
55917: LIST
55918: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55919: LD_VAR 0 6
55923: PPUSH
55924: CALL_OW 257
55928: PUSH
55929: LD_INT 14
55931: EQUAL
55932: IFFALSE 55953
// points := [ 10 , 0 , 0 ] ;
55934: LD_ADDR_VAR 0 9
55938: PUSH
55939: LD_INT 10
55941: PUSH
55942: LD_INT 0
55944: PUSH
55945: LD_INT 0
55947: PUSH
55948: EMPTY
55949: LIST
55950: LIST
55951: LIST
55952: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55953: LD_VAR 0 6
55957: PPUSH
55958: CALL_OW 257
55962: PUSH
55963: LD_INT 11
55965: EQUAL
55966: IFFALSE 55987
// points := [ 30 , 10 , 5 ] ;
55968: LD_ADDR_VAR 0 9
55972: PUSH
55973: LD_INT 30
55975: PUSH
55976: LD_INT 10
55978: PUSH
55979: LD_INT 5
55981: PUSH
55982: EMPTY
55983: LIST
55984: LIST
55985: LIST
55986: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55987: LD_VAR 0 1
55991: PPUSH
55992: LD_INT 5
55994: PPUSH
55995: CALL_OW 321
55999: PUSH
56000: LD_INT 2
56002: EQUAL
56003: IFFALSE 56020
// bpoints := bpoints * 1.8 ;
56005: LD_ADDR_VAR 0 10
56009: PUSH
56010: LD_VAR 0 10
56014: PUSH
56015: LD_REAL  1.80000000000000E+0000
56018: MUL
56019: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
56020: LD_VAR 0 6
56024: PPUSH
56025: CALL_OW 257
56029: PUSH
56030: LD_INT 1
56032: PUSH
56033: LD_INT 2
56035: PUSH
56036: LD_INT 3
56038: PUSH
56039: LD_INT 4
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: LIST
56046: LIST
56047: IN
56048: PUSH
56049: LD_VAR 0 1
56053: PPUSH
56054: LD_INT 51
56056: PPUSH
56057: CALL_OW 321
56061: PUSH
56062: LD_INT 2
56064: EQUAL
56065: AND
56066: IFFALSE 56083
// bpoints := bpoints * 1.2 ;
56068: LD_ADDR_VAR 0 10
56072: PUSH
56073: LD_VAR 0 10
56077: PUSH
56078: LD_REAL  1.20000000000000E+0000
56081: MUL
56082: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56083: LD_VAR 0 6
56087: PPUSH
56088: CALL_OW 257
56092: PUSH
56093: LD_INT 5
56095: PUSH
56096: LD_INT 7
56098: PUSH
56099: LD_INT 9
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: LIST
56106: IN
56107: PUSH
56108: LD_VAR 0 1
56112: PPUSH
56113: LD_INT 52
56115: PPUSH
56116: CALL_OW 321
56120: PUSH
56121: LD_INT 2
56123: EQUAL
56124: AND
56125: IFFALSE 56142
// bpoints := bpoints * 1.5 ;
56127: LD_ADDR_VAR 0 10
56131: PUSH
56132: LD_VAR 0 10
56136: PUSH
56137: LD_REAL  1.50000000000000E+0000
56140: MUL
56141: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56142: LD_VAR 0 1
56146: PPUSH
56147: LD_INT 66
56149: PPUSH
56150: CALL_OW 321
56154: PUSH
56155: LD_INT 2
56157: EQUAL
56158: IFFALSE 56175
// bpoints := bpoints * 1.1 ;
56160: LD_ADDR_VAR 0 10
56164: PUSH
56165: LD_VAR 0 10
56169: PUSH
56170: LD_REAL  1.10000000000000E+0000
56173: MUL
56174: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56175: LD_ADDR_VAR 0 10
56179: PUSH
56180: LD_VAR 0 10
56184: PUSH
56185: LD_VAR 0 6
56189: PPUSH
56190: LD_INT 1
56192: PPUSH
56193: CALL_OW 259
56197: PUSH
56198: LD_REAL  1.15000000000000E+0000
56201: MUL
56202: MUL
56203: ST_TO_ADDR
// end ; unit_vehicle :
56204: GO 57032
56206: LD_INT 2
56208: DOUBLE
56209: EQUAL
56210: IFTRUE 56214
56212: GO 57020
56214: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56215: LD_VAR 0 6
56219: PPUSH
56220: CALL_OW 264
56224: PUSH
56225: LD_INT 2
56227: PUSH
56228: LD_INT 42
56230: PUSH
56231: LD_INT 24
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: LIST
56238: IN
56239: IFFALSE 56260
// points := [ 25 , 5 , 3 ] ;
56241: LD_ADDR_VAR 0 9
56245: PUSH
56246: LD_INT 25
56248: PUSH
56249: LD_INT 5
56251: PUSH
56252: LD_INT 3
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: LIST
56259: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56260: LD_VAR 0 6
56264: PPUSH
56265: CALL_OW 264
56269: PUSH
56270: LD_INT 4
56272: PUSH
56273: LD_INT 43
56275: PUSH
56276: LD_INT 25
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: LIST
56283: IN
56284: IFFALSE 56305
// points := [ 40 , 15 , 5 ] ;
56286: LD_ADDR_VAR 0 9
56290: PUSH
56291: LD_INT 40
56293: PUSH
56294: LD_INT 15
56296: PUSH
56297: LD_INT 5
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: LIST
56304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56305: LD_VAR 0 6
56309: PPUSH
56310: CALL_OW 264
56314: PUSH
56315: LD_INT 3
56317: PUSH
56318: LD_INT 23
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: IN
56325: IFFALSE 56346
// points := [ 7 , 25 , 8 ] ;
56327: LD_ADDR_VAR 0 9
56331: PUSH
56332: LD_INT 7
56334: PUSH
56335: LD_INT 25
56337: PUSH
56338: LD_INT 8
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: LIST
56345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56346: LD_VAR 0 6
56350: PPUSH
56351: CALL_OW 264
56355: PUSH
56356: LD_INT 5
56358: PUSH
56359: LD_INT 27
56361: PUSH
56362: LD_INT 44
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: LIST
56369: IN
56370: IFFALSE 56391
// points := [ 14 , 50 , 16 ] ;
56372: LD_ADDR_VAR 0 9
56376: PUSH
56377: LD_INT 14
56379: PUSH
56380: LD_INT 50
56382: PUSH
56383: LD_INT 16
56385: PUSH
56386: EMPTY
56387: LIST
56388: LIST
56389: LIST
56390: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56391: LD_VAR 0 6
56395: PPUSH
56396: CALL_OW 264
56400: PUSH
56401: LD_INT 6
56403: PUSH
56404: LD_INT 46
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: IN
56411: IFFALSE 56432
// points := [ 32 , 120 , 70 ] ;
56413: LD_ADDR_VAR 0 9
56417: PUSH
56418: LD_INT 32
56420: PUSH
56421: LD_INT 120
56423: PUSH
56424: LD_INT 70
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: LIST
56431: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56432: LD_VAR 0 6
56436: PPUSH
56437: CALL_OW 264
56441: PUSH
56442: LD_INT 7
56444: PUSH
56445: LD_INT 28
56447: PUSH
56448: LD_INT 45
56450: PUSH
56451: LD_INT 92
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: LIST
56458: LIST
56459: IN
56460: IFFALSE 56481
// points := [ 35 , 20 , 45 ] ;
56462: LD_ADDR_VAR 0 9
56466: PUSH
56467: LD_INT 35
56469: PUSH
56470: LD_INT 20
56472: PUSH
56473: LD_INT 45
56475: PUSH
56476: EMPTY
56477: LIST
56478: LIST
56479: LIST
56480: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56481: LD_VAR 0 6
56485: PPUSH
56486: CALL_OW 264
56490: PUSH
56491: LD_INT 47
56493: PUSH
56494: EMPTY
56495: LIST
56496: IN
56497: IFFALSE 56518
// points := [ 67 , 45 , 75 ] ;
56499: LD_ADDR_VAR 0 9
56503: PUSH
56504: LD_INT 67
56506: PUSH
56507: LD_INT 45
56509: PUSH
56510: LD_INT 75
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: LIST
56517: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56518: LD_VAR 0 6
56522: PPUSH
56523: CALL_OW 264
56527: PUSH
56528: LD_INT 26
56530: PUSH
56531: EMPTY
56532: LIST
56533: IN
56534: IFFALSE 56555
// points := [ 120 , 30 , 80 ] ;
56536: LD_ADDR_VAR 0 9
56540: PUSH
56541: LD_INT 120
56543: PUSH
56544: LD_INT 30
56546: PUSH
56547: LD_INT 80
56549: PUSH
56550: EMPTY
56551: LIST
56552: LIST
56553: LIST
56554: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56555: LD_VAR 0 6
56559: PPUSH
56560: CALL_OW 264
56564: PUSH
56565: LD_INT 22
56567: PUSH
56568: EMPTY
56569: LIST
56570: IN
56571: IFFALSE 56592
// points := [ 40 , 1 , 1 ] ;
56573: LD_ADDR_VAR 0 9
56577: PUSH
56578: LD_INT 40
56580: PUSH
56581: LD_INT 1
56583: PUSH
56584: LD_INT 1
56586: PUSH
56587: EMPTY
56588: LIST
56589: LIST
56590: LIST
56591: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56592: LD_VAR 0 6
56596: PPUSH
56597: CALL_OW 264
56601: PUSH
56602: LD_INT 29
56604: PUSH
56605: EMPTY
56606: LIST
56607: IN
56608: IFFALSE 56629
// points := [ 70 , 200 , 400 ] ;
56610: LD_ADDR_VAR 0 9
56614: PUSH
56615: LD_INT 70
56617: PUSH
56618: LD_INT 200
56620: PUSH
56621: LD_INT 400
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: LIST
56628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56629: LD_VAR 0 6
56633: PPUSH
56634: CALL_OW 264
56638: PUSH
56639: LD_INT 14
56641: PUSH
56642: LD_INT 53
56644: PUSH
56645: EMPTY
56646: LIST
56647: LIST
56648: IN
56649: IFFALSE 56670
// points := [ 40 , 10 , 20 ] ;
56651: LD_ADDR_VAR 0 9
56655: PUSH
56656: LD_INT 40
56658: PUSH
56659: LD_INT 10
56661: PUSH
56662: LD_INT 20
56664: PUSH
56665: EMPTY
56666: LIST
56667: LIST
56668: LIST
56669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56670: LD_VAR 0 6
56674: PPUSH
56675: CALL_OW 264
56679: PUSH
56680: LD_INT 9
56682: PUSH
56683: EMPTY
56684: LIST
56685: IN
56686: IFFALSE 56707
// points := [ 5 , 70 , 20 ] ;
56688: LD_ADDR_VAR 0 9
56692: PUSH
56693: LD_INT 5
56695: PUSH
56696: LD_INT 70
56698: PUSH
56699: LD_INT 20
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: LIST
56706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56707: LD_VAR 0 6
56711: PPUSH
56712: CALL_OW 264
56716: PUSH
56717: LD_INT 10
56719: PUSH
56720: EMPTY
56721: LIST
56722: IN
56723: IFFALSE 56744
// points := [ 35 , 110 , 70 ] ;
56725: LD_ADDR_VAR 0 9
56729: PUSH
56730: LD_INT 35
56732: PUSH
56733: LD_INT 110
56735: PUSH
56736: LD_INT 70
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: LIST
56743: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56744: LD_VAR 0 6
56748: PPUSH
56749: CALL_OW 265
56753: PUSH
56754: LD_INT 25
56756: EQUAL
56757: IFFALSE 56778
// points := [ 80 , 65 , 100 ] ;
56759: LD_ADDR_VAR 0 9
56763: PUSH
56764: LD_INT 80
56766: PUSH
56767: LD_INT 65
56769: PUSH
56770: LD_INT 100
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: LIST
56777: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56778: LD_VAR 0 6
56782: PPUSH
56783: CALL_OW 263
56787: PUSH
56788: LD_INT 1
56790: EQUAL
56791: IFFALSE 56826
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56793: LD_ADDR_VAR 0 10
56797: PUSH
56798: LD_VAR 0 10
56802: PUSH
56803: LD_VAR 0 6
56807: PPUSH
56808: CALL_OW 311
56812: PPUSH
56813: LD_INT 3
56815: PPUSH
56816: CALL_OW 259
56820: PUSH
56821: LD_INT 4
56823: MUL
56824: MUL
56825: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56826: LD_VAR 0 6
56830: PPUSH
56831: CALL_OW 263
56835: PUSH
56836: LD_INT 2
56838: EQUAL
56839: IFFALSE 56890
// begin j := IsControledBy ( i ) ;
56841: LD_ADDR_VAR 0 7
56845: PUSH
56846: LD_VAR 0 6
56850: PPUSH
56851: CALL_OW 312
56855: ST_TO_ADDR
// if j then
56856: LD_VAR 0 7
56860: IFFALSE 56890
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56862: LD_ADDR_VAR 0 10
56866: PUSH
56867: LD_VAR 0 10
56871: PUSH
56872: LD_VAR 0 7
56876: PPUSH
56877: LD_INT 3
56879: PPUSH
56880: CALL_OW 259
56884: PUSH
56885: LD_INT 3
56887: MUL
56888: MUL
56889: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56890: LD_VAR 0 6
56894: PPUSH
56895: CALL_OW 264
56899: PUSH
56900: LD_INT 5
56902: PUSH
56903: LD_INT 6
56905: PUSH
56906: LD_INT 46
56908: PUSH
56909: LD_INT 44
56911: PUSH
56912: LD_INT 47
56914: PUSH
56915: LD_INT 45
56917: PUSH
56918: LD_INT 28
56920: PUSH
56921: LD_INT 7
56923: PUSH
56924: LD_INT 27
56926: PUSH
56927: LD_INT 29
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: LIST
56935: LIST
56936: LIST
56937: LIST
56938: LIST
56939: LIST
56940: LIST
56941: IN
56942: PUSH
56943: LD_VAR 0 1
56947: PPUSH
56948: LD_INT 52
56950: PPUSH
56951: CALL_OW 321
56955: PUSH
56956: LD_INT 2
56958: EQUAL
56959: AND
56960: IFFALSE 56977
// bpoints := bpoints * 1.2 ;
56962: LD_ADDR_VAR 0 10
56966: PUSH
56967: LD_VAR 0 10
56971: PUSH
56972: LD_REAL  1.20000000000000E+0000
56975: MUL
56976: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56977: LD_VAR 0 6
56981: PPUSH
56982: CALL_OW 264
56986: PUSH
56987: LD_INT 6
56989: PUSH
56990: LD_INT 46
56992: PUSH
56993: LD_INT 47
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: LIST
57000: IN
57001: IFFALSE 57018
// bpoints := bpoints * 1.2 ;
57003: LD_ADDR_VAR 0 10
57007: PUSH
57008: LD_VAR 0 10
57012: PUSH
57013: LD_REAL  1.20000000000000E+0000
57016: MUL
57017: ST_TO_ADDR
// end ; unit_building :
57018: GO 57032
57020: LD_INT 3
57022: DOUBLE
57023: EQUAL
57024: IFTRUE 57028
57026: GO 57031
57028: POP
// ; end ;
57029: GO 57032
57031: POP
// for j = 1 to 3 do
57032: LD_ADDR_VAR 0 7
57036: PUSH
57037: DOUBLE
57038: LD_INT 1
57040: DEC
57041: ST_TO_ADDR
57042: LD_INT 3
57044: PUSH
57045: FOR_TO
57046: IFFALSE 57099
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57048: LD_ADDR_VAR 0 5
57052: PUSH
57053: LD_VAR 0 5
57057: PPUSH
57058: LD_VAR 0 7
57062: PPUSH
57063: LD_VAR 0 5
57067: PUSH
57068: LD_VAR 0 7
57072: ARRAY
57073: PUSH
57074: LD_VAR 0 9
57078: PUSH
57079: LD_VAR 0 7
57083: ARRAY
57084: PUSH
57085: LD_VAR 0 10
57089: MUL
57090: PLUS
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
57097: GO 57045
57099: POP
57100: POP
// end ;
57101: GO 55580
57103: POP
57104: POP
// result := Replace ( result , 4 , tmp ) ;
57105: LD_ADDR_VAR 0 5
57109: PUSH
57110: LD_VAR 0 5
57114: PPUSH
57115: LD_INT 4
57117: PPUSH
57118: LD_VAR 0 8
57122: PPUSH
57123: CALL_OW 1
57127: ST_TO_ADDR
// end ;
57128: LD_VAR 0 5
57132: RET
// export function DangerAtRange ( unit , range ) ; begin
57133: LD_INT 0
57135: PPUSH
// if not unit then
57136: LD_VAR 0 1
57140: NOT
57141: IFFALSE 57145
// exit ;
57143: GO 57190
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57145: LD_ADDR_VAR 0 3
57149: PUSH
57150: LD_VAR 0 1
57154: PPUSH
57155: CALL_OW 255
57159: PPUSH
57160: LD_VAR 0 1
57164: PPUSH
57165: CALL_OW 250
57169: PPUSH
57170: LD_VAR 0 1
57174: PPUSH
57175: CALL_OW 251
57179: PPUSH
57180: LD_VAR 0 2
57184: PPUSH
57185: CALL 55432 0 4
57189: ST_TO_ADDR
// end ;
57190: LD_VAR 0 3
57194: RET
// export function DangerInArea ( side , area ) ; begin
57195: LD_INT 0
57197: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57198: LD_ADDR_VAR 0 3
57202: PUSH
57203: LD_VAR 0 2
57207: PPUSH
57208: LD_INT 81
57210: PUSH
57211: LD_VAR 0 1
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: PPUSH
57220: CALL_OW 70
57224: ST_TO_ADDR
// end ;
57225: LD_VAR 0 3
57229: RET
// export function IsExtension ( b ) ; begin
57230: LD_INT 0
57232: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57233: LD_ADDR_VAR 0 2
57237: PUSH
57238: LD_VAR 0 1
57242: PUSH
57243: LD_INT 23
57245: PUSH
57246: LD_INT 20
57248: PUSH
57249: LD_INT 22
57251: PUSH
57252: LD_INT 17
57254: PUSH
57255: LD_INT 24
57257: PUSH
57258: LD_INT 21
57260: PUSH
57261: LD_INT 19
57263: PUSH
57264: LD_INT 16
57266: PUSH
57267: LD_INT 25
57269: PUSH
57270: LD_INT 18
57272: PUSH
57273: EMPTY
57274: LIST
57275: LIST
57276: LIST
57277: LIST
57278: LIST
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: IN
57285: ST_TO_ADDR
// end ;
57286: LD_VAR 0 2
57290: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57291: LD_INT 0
57293: PPUSH
57294: PPUSH
57295: PPUSH
// result := [ ] ;
57296: LD_ADDR_VAR 0 4
57300: PUSH
57301: EMPTY
57302: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57303: LD_ADDR_VAR 0 5
57307: PUSH
57308: LD_VAR 0 2
57312: PPUSH
57313: LD_INT 21
57315: PUSH
57316: LD_INT 3
57318: PUSH
57319: EMPTY
57320: LIST
57321: LIST
57322: PPUSH
57323: CALL_OW 70
57327: ST_TO_ADDR
// if not tmp then
57328: LD_VAR 0 5
57332: NOT
57333: IFFALSE 57337
// exit ;
57335: GO 57401
// if checkLink then
57337: LD_VAR 0 3
57341: IFFALSE 57391
// begin for i in tmp do
57343: LD_ADDR_VAR 0 6
57347: PUSH
57348: LD_VAR 0 5
57352: PUSH
57353: FOR_IN
57354: IFFALSE 57389
// if GetBase ( i ) <> base then
57356: LD_VAR 0 6
57360: PPUSH
57361: CALL_OW 274
57365: PUSH
57366: LD_VAR 0 1
57370: NONEQUAL
57371: IFFALSE 57387
// ComLinkToBase ( base , i ) ;
57373: LD_VAR 0 1
57377: PPUSH
57378: LD_VAR 0 6
57382: PPUSH
57383: CALL_OW 169
57387: GO 57353
57389: POP
57390: POP
// end ; result := tmp ;
57391: LD_ADDR_VAR 0 4
57395: PUSH
57396: LD_VAR 0 5
57400: ST_TO_ADDR
// end ;
57401: LD_VAR 0 4
57405: RET
// export function ComComplete ( units , b ) ; var i ; begin
57406: LD_INT 0
57408: PPUSH
57409: PPUSH
// if not units then
57410: LD_VAR 0 1
57414: NOT
57415: IFFALSE 57419
// exit ;
57417: GO 57509
// for i in units do
57419: LD_ADDR_VAR 0 4
57423: PUSH
57424: LD_VAR 0 1
57428: PUSH
57429: FOR_IN
57430: IFFALSE 57507
// if BuildingStatus ( b ) = bs_build then
57432: LD_VAR 0 2
57436: PPUSH
57437: CALL_OW 461
57441: PUSH
57442: LD_INT 1
57444: EQUAL
57445: IFFALSE 57505
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57447: LD_VAR 0 4
57451: PPUSH
57452: LD_STRING h
57454: PUSH
57455: LD_VAR 0 2
57459: PPUSH
57460: CALL_OW 250
57464: PUSH
57465: LD_VAR 0 2
57469: PPUSH
57470: CALL_OW 251
57474: PUSH
57475: LD_VAR 0 2
57479: PUSH
57480: LD_INT 0
57482: PUSH
57483: LD_INT 0
57485: PUSH
57486: LD_INT 0
57488: PUSH
57489: EMPTY
57490: LIST
57491: LIST
57492: LIST
57493: LIST
57494: LIST
57495: LIST
57496: LIST
57497: PUSH
57498: EMPTY
57499: LIST
57500: PPUSH
57501: CALL_OW 446
57505: GO 57429
57507: POP
57508: POP
// end ;
57509: LD_VAR 0 3
57513: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57514: LD_INT 0
57516: PPUSH
57517: PPUSH
57518: PPUSH
57519: PPUSH
57520: PPUSH
57521: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57522: LD_VAR 0 1
57526: NOT
57527: PUSH
57528: LD_VAR 0 1
57532: PPUSH
57533: CALL_OW 263
57537: PUSH
57538: LD_INT 2
57540: NONEQUAL
57541: OR
57542: IFFALSE 57546
// exit ;
57544: GO 57862
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57546: LD_ADDR_VAR 0 6
57550: PUSH
57551: LD_INT 22
57553: PUSH
57554: LD_VAR 0 1
57558: PPUSH
57559: CALL_OW 255
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PUSH
57568: LD_INT 2
57570: PUSH
57571: LD_INT 30
57573: PUSH
57574: LD_INT 36
57576: PUSH
57577: EMPTY
57578: LIST
57579: LIST
57580: PUSH
57581: LD_INT 34
57583: PUSH
57584: LD_INT 31
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: PUSH
57591: EMPTY
57592: LIST
57593: LIST
57594: LIST
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: PPUSH
57600: CALL_OW 69
57604: ST_TO_ADDR
// if not tmp then
57605: LD_VAR 0 6
57609: NOT
57610: IFFALSE 57614
// exit ;
57612: GO 57862
// result := [ ] ;
57614: LD_ADDR_VAR 0 2
57618: PUSH
57619: EMPTY
57620: ST_TO_ADDR
// for i in tmp do
57621: LD_ADDR_VAR 0 3
57625: PUSH
57626: LD_VAR 0 6
57630: PUSH
57631: FOR_IN
57632: IFFALSE 57703
// begin t := UnitsInside ( i ) ;
57634: LD_ADDR_VAR 0 4
57638: PUSH
57639: LD_VAR 0 3
57643: PPUSH
57644: CALL_OW 313
57648: ST_TO_ADDR
// if t then
57649: LD_VAR 0 4
57653: IFFALSE 57701
// for j in t do
57655: LD_ADDR_VAR 0 7
57659: PUSH
57660: LD_VAR 0 4
57664: PUSH
57665: FOR_IN
57666: IFFALSE 57699
// result := Replace ( result , result + 1 , j ) ;
57668: LD_ADDR_VAR 0 2
57672: PUSH
57673: LD_VAR 0 2
57677: PPUSH
57678: LD_VAR 0 2
57682: PUSH
57683: LD_INT 1
57685: PLUS
57686: PPUSH
57687: LD_VAR 0 7
57691: PPUSH
57692: CALL_OW 1
57696: ST_TO_ADDR
57697: GO 57665
57699: POP
57700: POP
// end ;
57701: GO 57631
57703: POP
57704: POP
// if not result then
57705: LD_VAR 0 2
57709: NOT
57710: IFFALSE 57714
// exit ;
57712: GO 57862
// mech := result [ 1 ] ;
57714: LD_ADDR_VAR 0 5
57718: PUSH
57719: LD_VAR 0 2
57723: PUSH
57724: LD_INT 1
57726: ARRAY
57727: ST_TO_ADDR
// if result > 1 then
57728: LD_VAR 0 2
57732: PUSH
57733: LD_INT 1
57735: GREATER
57736: IFFALSE 57848
// begin for i = 2 to result do
57738: LD_ADDR_VAR 0 3
57742: PUSH
57743: DOUBLE
57744: LD_INT 2
57746: DEC
57747: ST_TO_ADDR
57748: LD_VAR 0 2
57752: PUSH
57753: FOR_TO
57754: IFFALSE 57846
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57756: LD_ADDR_VAR 0 4
57760: PUSH
57761: LD_VAR 0 2
57765: PUSH
57766: LD_VAR 0 3
57770: ARRAY
57771: PPUSH
57772: LD_INT 3
57774: PPUSH
57775: CALL_OW 259
57779: PUSH
57780: LD_VAR 0 2
57784: PUSH
57785: LD_VAR 0 3
57789: ARRAY
57790: PPUSH
57791: CALL_OW 432
57795: MINUS
57796: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57797: LD_VAR 0 4
57801: PUSH
57802: LD_VAR 0 5
57806: PPUSH
57807: LD_INT 3
57809: PPUSH
57810: CALL_OW 259
57814: PUSH
57815: LD_VAR 0 5
57819: PPUSH
57820: CALL_OW 432
57824: MINUS
57825: GREATEREQUAL
57826: IFFALSE 57844
// mech := result [ i ] ;
57828: LD_ADDR_VAR 0 5
57832: PUSH
57833: LD_VAR 0 2
57837: PUSH
57838: LD_VAR 0 3
57842: ARRAY
57843: ST_TO_ADDR
// end ;
57844: GO 57753
57846: POP
57847: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57848: LD_VAR 0 1
57852: PPUSH
57853: LD_VAR 0 5
57857: PPUSH
57858: CALL_OW 135
// end ;
57862: LD_VAR 0 2
57866: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57867: LD_INT 0
57869: PPUSH
57870: PPUSH
57871: PPUSH
57872: PPUSH
57873: PPUSH
57874: PPUSH
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
57879: PPUSH
57880: PPUSH
57881: PPUSH
// result := [ ] ;
57882: LD_ADDR_VAR 0 7
57886: PUSH
57887: EMPTY
57888: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57889: LD_VAR 0 1
57893: PPUSH
57894: CALL_OW 266
57898: PUSH
57899: LD_INT 0
57901: PUSH
57902: LD_INT 1
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: IN
57909: NOT
57910: IFFALSE 57914
// exit ;
57912: GO 59548
// if name then
57914: LD_VAR 0 3
57918: IFFALSE 57934
// SetBName ( base_dep , name ) ;
57920: LD_VAR 0 1
57924: PPUSH
57925: LD_VAR 0 3
57929: PPUSH
57930: CALL_OW 500
// base := GetBase ( base_dep ) ;
57934: LD_ADDR_VAR 0 15
57938: PUSH
57939: LD_VAR 0 1
57943: PPUSH
57944: CALL_OW 274
57948: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57949: LD_ADDR_VAR 0 16
57953: PUSH
57954: LD_VAR 0 1
57958: PPUSH
57959: CALL_OW 255
57963: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57964: LD_ADDR_VAR 0 17
57968: PUSH
57969: LD_VAR 0 1
57973: PPUSH
57974: CALL_OW 248
57978: ST_TO_ADDR
// if sources then
57979: LD_VAR 0 5
57983: IFFALSE 58030
// for i = 1 to 3 do
57985: LD_ADDR_VAR 0 8
57989: PUSH
57990: DOUBLE
57991: LD_INT 1
57993: DEC
57994: ST_TO_ADDR
57995: LD_INT 3
57997: PUSH
57998: FOR_TO
57999: IFFALSE 58028
// AddResourceType ( base , i , sources [ i ] ) ;
58001: LD_VAR 0 15
58005: PPUSH
58006: LD_VAR 0 8
58010: PPUSH
58011: LD_VAR 0 5
58015: PUSH
58016: LD_VAR 0 8
58020: ARRAY
58021: PPUSH
58022: CALL_OW 276
58026: GO 57998
58028: POP
58029: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
58030: LD_ADDR_VAR 0 18
58034: PUSH
58035: LD_VAR 0 15
58039: PPUSH
58040: LD_VAR 0 2
58044: PPUSH
58045: LD_INT 1
58047: PPUSH
58048: CALL 57291 0 3
58052: ST_TO_ADDR
// InitHc ;
58053: CALL_OW 19
// InitUc ;
58057: CALL_OW 18
// uc_side := side ;
58061: LD_ADDR_OWVAR 20
58065: PUSH
58066: LD_VAR 0 16
58070: ST_TO_ADDR
// uc_nation := nation ;
58071: LD_ADDR_OWVAR 21
58075: PUSH
58076: LD_VAR 0 17
58080: ST_TO_ADDR
// if buildings then
58081: LD_VAR 0 18
58085: IFFALSE 59407
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58087: LD_ADDR_VAR 0 19
58091: PUSH
58092: LD_VAR 0 18
58096: PPUSH
58097: LD_INT 2
58099: PUSH
58100: LD_INT 30
58102: PUSH
58103: LD_INT 29
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: PUSH
58110: LD_INT 30
58112: PUSH
58113: LD_INT 30
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: PPUSH
58125: CALL_OW 72
58129: ST_TO_ADDR
// if tmp then
58130: LD_VAR 0 19
58134: IFFALSE 58182
// for i in tmp do
58136: LD_ADDR_VAR 0 8
58140: PUSH
58141: LD_VAR 0 19
58145: PUSH
58146: FOR_IN
58147: IFFALSE 58180
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58149: LD_VAR 0 8
58153: PPUSH
58154: CALL_OW 250
58158: PPUSH
58159: LD_VAR 0 8
58163: PPUSH
58164: CALL_OW 251
58168: PPUSH
58169: LD_VAR 0 16
58173: PPUSH
58174: CALL_OW 441
58178: GO 58146
58180: POP
58181: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58182: LD_VAR 0 18
58186: PPUSH
58187: LD_INT 2
58189: PUSH
58190: LD_INT 30
58192: PUSH
58193: LD_INT 32
58195: PUSH
58196: EMPTY
58197: LIST
58198: LIST
58199: PUSH
58200: LD_INT 30
58202: PUSH
58203: LD_INT 33
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: LIST
58214: PPUSH
58215: CALL_OW 72
58219: IFFALSE 58307
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58221: LD_ADDR_VAR 0 8
58225: PUSH
58226: LD_VAR 0 18
58230: PPUSH
58231: LD_INT 2
58233: PUSH
58234: LD_INT 30
58236: PUSH
58237: LD_INT 32
58239: PUSH
58240: EMPTY
58241: LIST
58242: LIST
58243: PUSH
58244: LD_INT 30
58246: PUSH
58247: LD_INT 33
58249: PUSH
58250: EMPTY
58251: LIST
58252: LIST
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: LIST
58258: PPUSH
58259: CALL_OW 72
58263: PUSH
58264: FOR_IN
58265: IFFALSE 58305
// begin if not GetBWeapon ( i ) then
58267: LD_VAR 0 8
58271: PPUSH
58272: CALL_OW 269
58276: NOT
58277: IFFALSE 58303
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58279: LD_VAR 0 8
58283: PPUSH
58284: LD_VAR 0 8
58288: PPUSH
58289: LD_VAR 0 2
58293: PPUSH
58294: CALL 59553 0 2
58298: PPUSH
58299: CALL_OW 431
// end ;
58303: GO 58264
58305: POP
58306: POP
// end ; for i = 1 to personel do
58307: LD_ADDR_VAR 0 8
58311: PUSH
58312: DOUBLE
58313: LD_INT 1
58315: DEC
58316: ST_TO_ADDR
58317: LD_VAR 0 6
58321: PUSH
58322: FOR_TO
58323: IFFALSE 59387
// begin if i > 4 then
58325: LD_VAR 0 8
58329: PUSH
58330: LD_INT 4
58332: GREATER
58333: IFFALSE 58337
// break ;
58335: GO 59387
// case i of 1 :
58337: LD_VAR 0 8
58341: PUSH
58342: LD_INT 1
58344: DOUBLE
58345: EQUAL
58346: IFTRUE 58350
58348: GO 58430
58350: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58351: LD_ADDR_VAR 0 12
58355: PUSH
58356: LD_VAR 0 18
58360: PPUSH
58361: LD_INT 22
58363: PUSH
58364: LD_VAR 0 16
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: PUSH
58373: LD_INT 58
58375: PUSH
58376: EMPTY
58377: LIST
58378: PUSH
58379: LD_INT 2
58381: PUSH
58382: LD_INT 30
58384: PUSH
58385: LD_INT 32
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PUSH
58392: LD_INT 30
58394: PUSH
58395: LD_INT 4
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: PUSH
58402: LD_INT 30
58404: PUSH
58405: LD_INT 5
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: LIST
58416: LIST
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: LIST
58422: PPUSH
58423: CALL_OW 72
58427: ST_TO_ADDR
58428: GO 58652
58430: LD_INT 2
58432: DOUBLE
58433: EQUAL
58434: IFTRUE 58438
58436: GO 58500
58438: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58439: LD_ADDR_VAR 0 12
58443: PUSH
58444: LD_VAR 0 18
58448: PPUSH
58449: LD_INT 22
58451: PUSH
58452: LD_VAR 0 16
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: LD_INT 2
58463: PUSH
58464: LD_INT 30
58466: PUSH
58467: LD_INT 0
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: PUSH
58474: LD_INT 30
58476: PUSH
58477: LD_INT 1
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: LIST
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: PPUSH
58493: CALL_OW 72
58497: ST_TO_ADDR
58498: GO 58652
58500: LD_INT 3
58502: DOUBLE
58503: EQUAL
58504: IFTRUE 58508
58506: GO 58570
58508: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58509: LD_ADDR_VAR 0 12
58513: PUSH
58514: LD_VAR 0 18
58518: PPUSH
58519: LD_INT 22
58521: PUSH
58522: LD_VAR 0 16
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: PUSH
58531: LD_INT 2
58533: PUSH
58534: LD_INT 30
58536: PUSH
58537: LD_INT 2
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: PUSH
58544: LD_INT 30
58546: PUSH
58547: LD_INT 3
58549: PUSH
58550: EMPTY
58551: LIST
58552: LIST
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: LIST
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: PPUSH
58563: CALL_OW 72
58567: ST_TO_ADDR
58568: GO 58652
58570: LD_INT 4
58572: DOUBLE
58573: EQUAL
58574: IFTRUE 58578
58576: GO 58651
58578: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58579: LD_ADDR_VAR 0 12
58583: PUSH
58584: LD_VAR 0 18
58588: PPUSH
58589: LD_INT 22
58591: PUSH
58592: LD_VAR 0 16
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PUSH
58601: LD_INT 2
58603: PUSH
58604: LD_INT 30
58606: PUSH
58607: LD_INT 6
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: PUSH
58614: LD_INT 30
58616: PUSH
58617: LD_INT 7
58619: PUSH
58620: EMPTY
58621: LIST
58622: LIST
58623: PUSH
58624: LD_INT 30
58626: PUSH
58627: LD_INT 8
58629: PUSH
58630: EMPTY
58631: LIST
58632: LIST
58633: PUSH
58634: EMPTY
58635: LIST
58636: LIST
58637: LIST
58638: LIST
58639: PUSH
58640: EMPTY
58641: LIST
58642: LIST
58643: PPUSH
58644: CALL_OW 72
58648: ST_TO_ADDR
58649: GO 58652
58651: POP
// if i = 1 then
58652: LD_VAR 0 8
58656: PUSH
58657: LD_INT 1
58659: EQUAL
58660: IFFALSE 58771
// begin tmp := [ ] ;
58662: LD_ADDR_VAR 0 19
58666: PUSH
58667: EMPTY
58668: ST_TO_ADDR
// for j in f do
58669: LD_ADDR_VAR 0 9
58673: PUSH
58674: LD_VAR 0 12
58678: PUSH
58679: FOR_IN
58680: IFFALSE 58753
// if GetBType ( j ) = b_bunker then
58682: LD_VAR 0 9
58686: PPUSH
58687: CALL_OW 266
58691: PUSH
58692: LD_INT 32
58694: EQUAL
58695: IFFALSE 58722
// tmp := Insert ( tmp , 1 , j ) else
58697: LD_ADDR_VAR 0 19
58701: PUSH
58702: LD_VAR 0 19
58706: PPUSH
58707: LD_INT 1
58709: PPUSH
58710: LD_VAR 0 9
58714: PPUSH
58715: CALL_OW 2
58719: ST_TO_ADDR
58720: GO 58751
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58722: LD_ADDR_VAR 0 19
58726: PUSH
58727: LD_VAR 0 19
58731: PPUSH
58732: LD_VAR 0 19
58736: PUSH
58737: LD_INT 1
58739: PLUS
58740: PPUSH
58741: LD_VAR 0 9
58745: PPUSH
58746: CALL_OW 2
58750: ST_TO_ADDR
58751: GO 58679
58753: POP
58754: POP
// if tmp then
58755: LD_VAR 0 19
58759: IFFALSE 58771
// f := tmp ;
58761: LD_ADDR_VAR 0 12
58765: PUSH
58766: LD_VAR 0 19
58770: ST_TO_ADDR
// end ; x := personel [ i ] ;
58771: LD_ADDR_VAR 0 13
58775: PUSH
58776: LD_VAR 0 6
58780: PUSH
58781: LD_VAR 0 8
58785: ARRAY
58786: ST_TO_ADDR
// if x = - 1 then
58787: LD_VAR 0 13
58791: PUSH
58792: LD_INT 1
58794: NEG
58795: EQUAL
58796: IFFALSE 59005
// begin for j in f do
58798: LD_ADDR_VAR 0 9
58802: PUSH
58803: LD_VAR 0 12
58807: PUSH
58808: FOR_IN
58809: IFFALSE 59001
// repeat InitHc ;
58811: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58815: LD_VAR 0 9
58819: PPUSH
58820: CALL_OW 266
58824: PUSH
58825: LD_INT 5
58827: EQUAL
58828: IFFALSE 58898
// begin if UnitsInside ( j ) < 3 then
58830: LD_VAR 0 9
58834: PPUSH
58835: CALL_OW 313
58839: PUSH
58840: LD_INT 3
58842: LESS
58843: IFFALSE 58879
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58845: LD_INT 0
58847: PPUSH
58848: LD_INT 5
58850: PUSH
58851: LD_INT 8
58853: PUSH
58854: LD_INT 9
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: LIST
58861: PUSH
58862: LD_VAR 0 17
58866: ARRAY
58867: PPUSH
58868: LD_VAR 0 4
58872: PPUSH
58873: CALL_OW 380
58877: GO 58896
// PrepareHuman ( false , i , skill ) ;
58879: LD_INT 0
58881: PPUSH
58882: LD_VAR 0 8
58886: PPUSH
58887: LD_VAR 0 4
58891: PPUSH
58892: CALL_OW 380
// end else
58896: GO 58915
// PrepareHuman ( false , i , skill ) ;
58898: LD_INT 0
58900: PPUSH
58901: LD_VAR 0 8
58905: PPUSH
58906: LD_VAR 0 4
58910: PPUSH
58911: CALL_OW 380
// un := CreateHuman ;
58915: LD_ADDR_VAR 0 14
58919: PUSH
58920: CALL_OW 44
58924: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58925: LD_ADDR_VAR 0 7
58929: PUSH
58930: LD_VAR 0 7
58934: PPUSH
58935: LD_INT 1
58937: PPUSH
58938: LD_VAR 0 14
58942: PPUSH
58943: CALL_OW 2
58947: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58948: LD_VAR 0 14
58952: PPUSH
58953: LD_VAR 0 9
58957: PPUSH
58958: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58962: LD_VAR 0 9
58966: PPUSH
58967: CALL_OW 313
58971: PUSH
58972: LD_INT 6
58974: EQUAL
58975: PUSH
58976: LD_VAR 0 9
58980: PPUSH
58981: CALL_OW 266
58985: PUSH
58986: LD_INT 32
58988: PUSH
58989: LD_INT 31
58991: PUSH
58992: EMPTY
58993: LIST
58994: LIST
58995: IN
58996: OR
58997: IFFALSE 58811
58999: GO 58808
59001: POP
59002: POP
// end else
59003: GO 59385
// for j = 1 to x do
59005: LD_ADDR_VAR 0 9
59009: PUSH
59010: DOUBLE
59011: LD_INT 1
59013: DEC
59014: ST_TO_ADDR
59015: LD_VAR 0 13
59019: PUSH
59020: FOR_TO
59021: IFFALSE 59383
// begin InitHc ;
59023: CALL_OW 19
// if not f then
59027: LD_VAR 0 12
59031: NOT
59032: IFFALSE 59121
// begin PrepareHuman ( false , i , skill ) ;
59034: LD_INT 0
59036: PPUSH
59037: LD_VAR 0 8
59041: PPUSH
59042: LD_VAR 0 4
59046: PPUSH
59047: CALL_OW 380
// un := CreateHuman ;
59051: LD_ADDR_VAR 0 14
59055: PUSH
59056: CALL_OW 44
59060: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59061: LD_ADDR_VAR 0 7
59065: PUSH
59066: LD_VAR 0 7
59070: PPUSH
59071: LD_INT 1
59073: PPUSH
59074: LD_VAR 0 14
59078: PPUSH
59079: CALL_OW 2
59083: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59084: LD_VAR 0 14
59088: PPUSH
59089: LD_VAR 0 1
59093: PPUSH
59094: CALL_OW 250
59098: PPUSH
59099: LD_VAR 0 1
59103: PPUSH
59104: CALL_OW 251
59108: PPUSH
59109: LD_INT 10
59111: PPUSH
59112: LD_INT 0
59114: PPUSH
59115: CALL_OW 50
// continue ;
59119: GO 59020
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59121: LD_VAR 0 12
59125: PUSH
59126: LD_INT 1
59128: ARRAY
59129: PPUSH
59130: CALL_OW 313
59134: PUSH
59135: LD_VAR 0 12
59139: PUSH
59140: LD_INT 1
59142: ARRAY
59143: PPUSH
59144: CALL_OW 266
59148: PUSH
59149: LD_INT 32
59151: PUSH
59152: LD_INT 31
59154: PUSH
59155: EMPTY
59156: LIST
59157: LIST
59158: IN
59159: AND
59160: PUSH
59161: LD_VAR 0 12
59165: PUSH
59166: LD_INT 1
59168: ARRAY
59169: PPUSH
59170: CALL_OW 313
59174: PUSH
59175: LD_INT 6
59177: EQUAL
59178: OR
59179: IFFALSE 59199
// f := Delete ( f , 1 ) ;
59181: LD_ADDR_VAR 0 12
59185: PUSH
59186: LD_VAR 0 12
59190: PPUSH
59191: LD_INT 1
59193: PPUSH
59194: CALL_OW 3
59198: ST_TO_ADDR
// if not f then
59199: LD_VAR 0 12
59203: NOT
59204: IFFALSE 59222
// begin x := x + 2 ;
59206: LD_ADDR_VAR 0 13
59210: PUSH
59211: LD_VAR 0 13
59215: PUSH
59216: LD_INT 2
59218: PLUS
59219: ST_TO_ADDR
// continue ;
59220: GO 59020
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59222: LD_VAR 0 12
59226: PUSH
59227: LD_INT 1
59229: ARRAY
59230: PPUSH
59231: CALL_OW 266
59235: PUSH
59236: LD_INT 5
59238: EQUAL
59239: IFFALSE 59313
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59241: LD_VAR 0 12
59245: PUSH
59246: LD_INT 1
59248: ARRAY
59249: PPUSH
59250: CALL_OW 313
59254: PUSH
59255: LD_INT 3
59257: LESS
59258: IFFALSE 59294
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59260: LD_INT 0
59262: PPUSH
59263: LD_INT 5
59265: PUSH
59266: LD_INT 8
59268: PUSH
59269: LD_INT 9
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: LIST
59276: PUSH
59277: LD_VAR 0 17
59281: ARRAY
59282: PPUSH
59283: LD_VAR 0 4
59287: PPUSH
59288: CALL_OW 380
59292: GO 59311
// PrepareHuman ( false , i , skill ) ;
59294: LD_INT 0
59296: PPUSH
59297: LD_VAR 0 8
59301: PPUSH
59302: LD_VAR 0 4
59306: PPUSH
59307: CALL_OW 380
// end else
59311: GO 59330
// PrepareHuman ( false , i , skill ) ;
59313: LD_INT 0
59315: PPUSH
59316: LD_VAR 0 8
59320: PPUSH
59321: LD_VAR 0 4
59325: PPUSH
59326: CALL_OW 380
// un := CreateHuman ;
59330: LD_ADDR_VAR 0 14
59334: PUSH
59335: CALL_OW 44
59339: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59340: LD_ADDR_VAR 0 7
59344: PUSH
59345: LD_VAR 0 7
59349: PPUSH
59350: LD_INT 1
59352: PPUSH
59353: LD_VAR 0 14
59357: PPUSH
59358: CALL_OW 2
59362: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59363: LD_VAR 0 14
59367: PPUSH
59368: LD_VAR 0 12
59372: PUSH
59373: LD_INT 1
59375: ARRAY
59376: PPUSH
59377: CALL_OW 52
// end ;
59381: GO 59020
59383: POP
59384: POP
// end ;
59385: GO 58322
59387: POP
59388: POP
// result := result ^ buildings ;
59389: LD_ADDR_VAR 0 7
59393: PUSH
59394: LD_VAR 0 7
59398: PUSH
59399: LD_VAR 0 18
59403: ADD
59404: ST_TO_ADDR
// end else
59405: GO 59548
// begin for i = 1 to personel do
59407: LD_ADDR_VAR 0 8
59411: PUSH
59412: DOUBLE
59413: LD_INT 1
59415: DEC
59416: ST_TO_ADDR
59417: LD_VAR 0 6
59421: PUSH
59422: FOR_TO
59423: IFFALSE 59546
// begin if i > 4 then
59425: LD_VAR 0 8
59429: PUSH
59430: LD_INT 4
59432: GREATER
59433: IFFALSE 59437
// break ;
59435: GO 59546
// x := personel [ i ] ;
59437: LD_ADDR_VAR 0 13
59441: PUSH
59442: LD_VAR 0 6
59446: PUSH
59447: LD_VAR 0 8
59451: ARRAY
59452: ST_TO_ADDR
// if x = - 1 then
59453: LD_VAR 0 13
59457: PUSH
59458: LD_INT 1
59460: NEG
59461: EQUAL
59462: IFFALSE 59466
// continue ;
59464: GO 59422
// PrepareHuman ( false , i , skill ) ;
59466: LD_INT 0
59468: PPUSH
59469: LD_VAR 0 8
59473: PPUSH
59474: LD_VAR 0 4
59478: PPUSH
59479: CALL_OW 380
// un := CreateHuman ;
59483: LD_ADDR_VAR 0 14
59487: PUSH
59488: CALL_OW 44
59492: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59493: LD_VAR 0 14
59497: PPUSH
59498: LD_VAR 0 1
59502: PPUSH
59503: CALL_OW 250
59507: PPUSH
59508: LD_VAR 0 1
59512: PPUSH
59513: CALL_OW 251
59517: PPUSH
59518: LD_INT 10
59520: PPUSH
59521: LD_INT 0
59523: PPUSH
59524: CALL_OW 50
// result := result ^ un ;
59528: LD_ADDR_VAR 0 7
59532: PUSH
59533: LD_VAR 0 7
59537: PUSH
59538: LD_VAR 0 14
59542: ADD
59543: ST_TO_ADDR
// end ;
59544: GO 59422
59546: POP
59547: POP
// end ; end ;
59548: LD_VAR 0 7
59552: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59553: LD_INT 0
59555: PPUSH
59556: PPUSH
59557: PPUSH
59558: PPUSH
59559: PPUSH
59560: PPUSH
59561: PPUSH
59562: PPUSH
59563: PPUSH
59564: PPUSH
59565: PPUSH
59566: PPUSH
59567: PPUSH
59568: PPUSH
59569: PPUSH
59570: PPUSH
// result := false ;
59571: LD_ADDR_VAR 0 3
59575: PUSH
59576: LD_INT 0
59578: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59579: LD_VAR 0 1
59583: NOT
59584: PUSH
59585: LD_VAR 0 1
59589: PPUSH
59590: CALL_OW 266
59594: PUSH
59595: LD_INT 32
59597: PUSH
59598: LD_INT 33
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: IN
59605: NOT
59606: OR
59607: IFFALSE 59611
// exit ;
59609: GO 60720
// nat := GetNation ( tower ) ;
59611: LD_ADDR_VAR 0 12
59615: PUSH
59616: LD_VAR 0 1
59620: PPUSH
59621: CALL_OW 248
59625: ST_TO_ADDR
// side := GetSide ( tower ) ;
59626: LD_ADDR_VAR 0 16
59630: PUSH
59631: LD_VAR 0 1
59635: PPUSH
59636: CALL_OW 255
59640: ST_TO_ADDR
// x := GetX ( tower ) ;
59641: LD_ADDR_VAR 0 10
59645: PUSH
59646: LD_VAR 0 1
59650: PPUSH
59651: CALL_OW 250
59655: ST_TO_ADDR
// y := GetY ( tower ) ;
59656: LD_ADDR_VAR 0 11
59660: PUSH
59661: LD_VAR 0 1
59665: PPUSH
59666: CALL_OW 251
59670: ST_TO_ADDR
// if not x or not y then
59671: LD_VAR 0 10
59675: NOT
59676: PUSH
59677: LD_VAR 0 11
59681: NOT
59682: OR
59683: IFFALSE 59687
// exit ;
59685: GO 60720
// weapon := 0 ;
59687: LD_ADDR_VAR 0 18
59691: PUSH
59692: LD_INT 0
59694: ST_TO_ADDR
// fac_list := [ ] ;
59695: LD_ADDR_VAR 0 17
59699: PUSH
59700: EMPTY
59701: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59702: LD_ADDR_VAR 0 6
59706: PUSH
59707: LD_VAR 0 1
59711: PPUSH
59712: CALL_OW 274
59716: PPUSH
59717: LD_VAR 0 2
59721: PPUSH
59722: LD_INT 0
59724: PPUSH
59725: CALL 57291 0 3
59729: PPUSH
59730: LD_INT 30
59732: PUSH
59733: LD_INT 3
59735: PUSH
59736: EMPTY
59737: LIST
59738: LIST
59739: PPUSH
59740: CALL_OW 72
59744: ST_TO_ADDR
// if not factories then
59745: LD_VAR 0 6
59749: NOT
59750: IFFALSE 59754
// exit ;
59752: GO 60720
// for i in factories do
59754: LD_ADDR_VAR 0 8
59758: PUSH
59759: LD_VAR 0 6
59763: PUSH
59764: FOR_IN
59765: IFFALSE 59790
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59767: LD_ADDR_VAR 0 17
59771: PUSH
59772: LD_VAR 0 17
59776: PUSH
59777: LD_VAR 0 8
59781: PPUSH
59782: CALL_OW 478
59786: UNION
59787: ST_TO_ADDR
59788: GO 59764
59790: POP
59791: POP
// if not fac_list then
59792: LD_VAR 0 17
59796: NOT
59797: IFFALSE 59801
// exit ;
59799: GO 60720
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59801: LD_ADDR_VAR 0 5
59805: PUSH
59806: LD_INT 4
59808: PUSH
59809: LD_INT 5
59811: PUSH
59812: LD_INT 9
59814: PUSH
59815: LD_INT 10
59817: PUSH
59818: LD_INT 6
59820: PUSH
59821: LD_INT 7
59823: PUSH
59824: LD_INT 11
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: LIST
59832: LIST
59833: LIST
59834: LIST
59835: PUSH
59836: LD_INT 27
59838: PUSH
59839: LD_INT 28
59841: PUSH
59842: LD_INT 26
59844: PUSH
59845: LD_INT 30
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: LIST
59852: LIST
59853: PUSH
59854: LD_INT 43
59856: PUSH
59857: LD_INT 44
59859: PUSH
59860: LD_INT 46
59862: PUSH
59863: LD_INT 45
59865: PUSH
59866: LD_INT 47
59868: PUSH
59869: LD_INT 49
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: LIST
59876: LIST
59877: LIST
59878: LIST
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: LIST
59884: PUSH
59885: LD_VAR 0 12
59889: ARRAY
59890: ST_TO_ADDR
// list := list isect fac_list ;
59891: LD_ADDR_VAR 0 5
59895: PUSH
59896: LD_VAR 0 5
59900: PUSH
59901: LD_VAR 0 17
59905: ISECT
59906: ST_TO_ADDR
// if not list then
59907: LD_VAR 0 5
59911: NOT
59912: IFFALSE 59916
// exit ;
59914: GO 60720
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59916: LD_VAR 0 12
59920: PUSH
59921: LD_INT 3
59923: EQUAL
59924: PUSH
59925: LD_INT 49
59927: PUSH
59928: LD_VAR 0 5
59932: IN
59933: AND
59934: PUSH
59935: LD_INT 31
59937: PPUSH
59938: LD_VAR 0 16
59942: PPUSH
59943: CALL_OW 321
59947: PUSH
59948: LD_INT 2
59950: EQUAL
59951: AND
59952: IFFALSE 60012
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59954: LD_INT 22
59956: PUSH
59957: LD_VAR 0 16
59961: PUSH
59962: EMPTY
59963: LIST
59964: LIST
59965: PUSH
59966: LD_INT 35
59968: PUSH
59969: LD_INT 49
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: PUSH
59976: LD_INT 91
59978: PUSH
59979: LD_VAR 0 1
59983: PUSH
59984: LD_INT 10
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: LIST
59991: PUSH
59992: EMPTY
59993: LIST
59994: LIST
59995: LIST
59996: PPUSH
59997: CALL_OW 69
60001: NOT
60002: IFFALSE 60012
// weapon := ru_time_lapser ;
60004: LD_ADDR_VAR 0 18
60008: PUSH
60009: LD_INT 49
60011: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
60012: LD_VAR 0 12
60016: PUSH
60017: LD_INT 1
60019: PUSH
60020: LD_INT 2
60022: PUSH
60023: EMPTY
60024: LIST
60025: LIST
60026: IN
60027: PUSH
60028: LD_INT 11
60030: PUSH
60031: LD_VAR 0 5
60035: IN
60036: PUSH
60037: LD_INT 30
60039: PUSH
60040: LD_VAR 0 5
60044: IN
60045: OR
60046: AND
60047: PUSH
60048: LD_INT 6
60050: PPUSH
60051: LD_VAR 0 16
60055: PPUSH
60056: CALL_OW 321
60060: PUSH
60061: LD_INT 2
60063: EQUAL
60064: AND
60065: IFFALSE 60230
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60067: LD_INT 22
60069: PUSH
60070: LD_VAR 0 16
60074: PUSH
60075: EMPTY
60076: LIST
60077: LIST
60078: PUSH
60079: LD_INT 2
60081: PUSH
60082: LD_INT 35
60084: PUSH
60085: LD_INT 11
60087: PUSH
60088: EMPTY
60089: LIST
60090: LIST
60091: PUSH
60092: LD_INT 35
60094: PUSH
60095: LD_INT 30
60097: PUSH
60098: EMPTY
60099: LIST
60100: LIST
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: LIST
60106: PUSH
60107: LD_INT 91
60109: PUSH
60110: LD_VAR 0 1
60114: PUSH
60115: LD_INT 18
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: LIST
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: LIST
60127: PPUSH
60128: CALL_OW 69
60132: NOT
60133: PUSH
60134: LD_INT 22
60136: PUSH
60137: LD_VAR 0 16
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: LD_INT 2
60148: PUSH
60149: LD_INT 30
60151: PUSH
60152: LD_INT 32
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: LD_INT 30
60161: PUSH
60162: LD_INT 33
60164: PUSH
60165: EMPTY
60166: LIST
60167: LIST
60168: PUSH
60169: EMPTY
60170: LIST
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 91
60176: PUSH
60177: LD_VAR 0 1
60181: PUSH
60182: LD_INT 12
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: LIST
60189: PUSH
60190: EMPTY
60191: LIST
60192: LIST
60193: LIST
60194: PUSH
60195: EMPTY
60196: LIST
60197: PPUSH
60198: CALL_OW 69
60202: PUSH
60203: LD_INT 2
60205: GREATER
60206: AND
60207: IFFALSE 60230
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60209: LD_ADDR_VAR 0 18
60213: PUSH
60214: LD_INT 11
60216: PUSH
60217: LD_INT 30
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: PUSH
60224: LD_VAR 0 12
60228: ARRAY
60229: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60230: LD_VAR 0 18
60234: NOT
60235: PUSH
60236: LD_INT 40
60238: PPUSH
60239: LD_VAR 0 16
60243: PPUSH
60244: CALL_OW 321
60248: PUSH
60249: LD_INT 2
60251: EQUAL
60252: AND
60253: PUSH
60254: LD_INT 7
60256: PUSH
60257: LD_VAR 0 5
60261: IN
60262: PUSH
60263: LD_INT 28
60265: PUSH
60266: LD_VAR 0 5
60270: IN
60271: OR
60272: PUSH
60273: LD_INT 45
60275: PUSH
60276: LD_VAR 0 5
60280: IN
60281: OR
60282: AND
60283: IFFALSE 60537
// begin hex := GetHexInfo ( x , y ) ;
60285: LD_ADDR_VAR 0 4
60289: PUSH
60290: LD_VAR 0 10
60294: PPUSH
60295: LD_VAR 0 11
60299: PPUSH
60300: CALL_OW 546
60304: ST_TO_ADDR
// if hex [ 1 ] then
60305: LD_VAR 0 4
60309: PUSH
60310: LD_INT 1
60312: ARRAY
60313: IFFALSE 60317
// exit ;
60315: GO 60720
// height := hex [ 2 ] ;
60317: LD_ADDR_VAR 0 15
60321: PUSH
60322: LD_VAR 0 4
60326: PUSH
60327: LD_INT 2
60329: ARRAY
60330: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60331: LD_ADDR_VAR 0 14
60335: PUSH
60336: LD_INT 0
60338: PUSH
60339: LD_INT 2
60341: PUSH
60342: LD_INT 3
60344: PUSH
60345: LD_INT 5
60347: PUSH
60348: EMPTY
60349: LIST
60350: LIST
60351: LIST
60352: LIST
60353: ST_TO_ADDR
// for i in tmp do
60354: LD_ADDR_VAR 0 8
60358: PUSH
60359: LD_VAR 0 14
60363: PUSH
60364: FOR_IN
60365: IFFALSE 60535
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60367: LD_ADDR_VAR 0 9
60371: PUSH
60372: LD_VAR 0 10
60376: PPUSH
60377: LD_VAR 0 8
60381: PPUSH
60382: LD_INT 5
60384: PPUSH
60385: CALL_OW 272
60389: PUSH
60390: LD_VAR 0 11
60394: PPUSH
60395: LD_VAR 0 8
60399: PPUSH
60400: LD_INT 5
60402: PPUSH
60403: CALL_OW 273
60407: PUSH
60408: EMPTY
60409: LIST
60410: LIST
60411: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60412: LD_VAR 0 9
60416: PUSH
60417: LD_INT 1
60419: ARRAY
60420: PPUSH
60421: LD_VAR 0 9
60425: PUSH
60426: LD_INT 2
60428: ARRAY
60429: PPUSH
60430: CALL_OW 488
60434: IFFALSE 60533
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60436: LD_ADDR_VAR 0 4
60440: PUSH
60441: LD_VAR 0 9
60445: PUSH
60446: LD_INT 1
60448: ARRAY
60449: PPUSH
60450: LD_VAR 0 9
60454: PUSH
60455: LD_INT 2
60457: ARRAY
60458: PPUSH
60459: CALL_OW 546
60463: ST_TO_ADDR
// if hex [ 1 ] then
60464: LD_VAR 0 4
60468: PUSH
60469: LD_INT 1
60471: ARRAY
60472: IFFALSE 60476
// continue ;
60474: GO 60364
// h := hex [ 2 ] ;
60476: LD_ADDR_VAR 0 13
60480: PUSH
60481: LD_VAR 0 4
60485: PUSH
60486: LD_INT 2
60488: ARRAY
60489: ST_TO_ADDR
// if h + 7 < height then
60490: LD_VAR 0 13
60494: PUSH
60495: LD_INT 7
60497: PLUS
60498: PUSH
60499: LD_VAR 0 15
60503: LESS
60504: IFFALSE 60533
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60506: LD_ADDR_VAR 0 18
60510: PUSH
60511: LD_INT 7
60513: PUSH
60514: LD_INT 28
60516: PUSH
60517: LD_INT 45
60519: PUSH
60520: EMPTY
60521: LIST
60522: LIST
60523: LIST
60524: PUSH
60525: LD_VAR 0 12
60529: ARRAY
60530: ST_TO_ADDR
// break ;
60531: GO 60535
// end ; end ; end ;
60533: GO 60364
60535: POP
60536: POP
// end ; if not weapon then
60537: LD_VAR 0 18
60541: NOT
60542: IFFALSE 60602
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60544: LD_ADDR_VAR 0 5
60548: PUSH
60549: LD_VAR 0 5
60553: PUSH
60554: LD_INT 11
60556: PUSH
60557: LD_INT 30
60559: PUSH
60560: LD_INT 49
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: LIST
60567: DIFF
60568: ST_TO_ADDR
// if not list then
60569: LD_VAR 0 5
60573: NOT
60574: IFFALSE 60578
// exit ;
60576: GO 60720
// weapon := list [ rand ( 1 , list ) ] ;
60578: LD_ADDR_VAR 0 18
60582: PUSH
60583: LD_VAR 0 5
60587: PUSH
60588: LD_INT 1
60590: PPUSH
60591: LD_VAR 0 5
60595: PPUSH
60596: CALL_OW 12
60600: ARRAY
60601: ST_TO_ADDR
// end ; if weapon then
60602: LD_VAR 0 18
60606: IFFALSE 60720
// begin tmp := CostOfWeapon ( weapon ) ;
60608: LD_ADDR_VAR 0 14
60612: PUSH
60613: LD_VAR 0 18
60617: PPUSH
60618: CALL_OW 451
60622: ST_TO_ADDR
// j := GetBase ( tower ) ;
60623: LD_ADDR_VAR 0 9
60627: PUSH
60628: LD_VAR 0 1
60632: PPUSH
60633: CALL_OW 274
60637: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60638: LD_VAR 0 9
60642: PPUSH
60643: LD_INT 1
60645: PPUSH
60646: CALL_OW 275
60650: PUSH
60651: LD_VAR 0 14
60655: PUSH
60656: LD_INT 1
60658: ARRAY
60659: GREATEREQUAL
60660: PUSH
60661: LD_VAR 0 9
60665: PPUSH
60666: LD_INT 2
60668: PPUSH
60669: CALL_OW 275
60673: PUSH
60674: LD_VAR 0 14
60678: PUSH
60679: LD_INT 2
60681: ARRAY
60682: GREATEREQUAL
60683: AND
60684: PUSH
60685: LD_VAR 0 9
60689: PPUSH
60690: LD_INT 3
60692: PPUSH
60693: CALL_OW 275
60697: PUSH
60698: LD_VAR 0 14
60702: PUSH
60703: LD_INT 3
60705: ARRAY
60706: GREATEREQUAL
60707: AND
60708: IFFALSE 60720
// result := weapon ;
60710: LD_ADDR_VAR 0 3
60714: PUSH
60715: LD_VAR 0 18
60719: ST_TO_ADDR
// end ; end ;
60720: LD_VAR 0 3
60724: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60725: LD_INT 0
60727: PPUSH
60728: PPUSH
// result := true ;
60729: LD_ADDR_VAR 0 3
60733: PUSH
60734: LD_INT 1
60736: ST_TO_ADDR
// if array1 = array2 then
60737: LD_VAR 0 1
60741: PUSH
60742: LD_VAR 0 2
60746: EQUAL
60747: IFFALSE 60807
// begin for i = 1 to array1 do
60749: LD_ADDR_VAR 0 4
60753: PUSH
60754: DOUBLE
60755: LD_INT 1
60757: DEC
60758: ST_TO_ADDR
60759: LD_VAR 0 1
60763: PUSH
60764: FOR_TO
60765: IFFALSE 60803
// if array1 [ i ] <> array2 [ i ] then
60767: LD_VAR 0 1
60771: PUSH
60772: LD_VAR 0 4
60776: ARRAY
60777: PUSH
60778: LD_VAR 0 2
60782: PUSH
60783: LD_VAR 0 4
60787: ARRAY
60788: NONEQUAL
60789: IFFALSE 60801
// begin result := false ;
60791: LD_ADDR_VAR 0 3
60795: PUSH
60796: LD_INT 0
60798: ST_TO_ADDR
// break ;
60799: GO 60803
// end ;
60801: GO 60764
60803: POP
60804: POP
// end else
60805: GO 60815
// result := false ;
60807: LD_ADDR_VAR 0 3
60811: PUSH
60812: LD_INT 0
60814: ST_TO_ADDR
// end ;
60815: LD_VAR 0 3
60819: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60820: LD_INT 0
60822: PPUSH
60823: PPUSH
// if not array1 or not array2 then
60824: LD_VAR 0 1
60828: NOT
60829: PUSH
60830: LD_VAR 0 2
60834: NOT
60835: OR
60836: IFFALSE 60840
// exit ;
60838: GO 60904
// result := true ;
60840: LD_ADDR_VAR 0 3
60844: PUSH
60845: LD_INT 1
60847: ST_TO_ADDR
// for i = 1 to array1 do
60848: LD_ADDR_VAR 0 4
60852: PUSH
60853: DOUBLE
60854: LD_INT 1
60856: DEC
60857: ST_TO_ADDR
60858: LD_VAR 0 1
60862: PUSH
60863: FOR_TO
60864: IFFALSE 60902
// if array1 [ i ] <> array2 [ i ] then
60866: LD_VAR 0 1
60870: PUSH
60871: LD_VAR 0 4
60875: ARRAY
60876: PUSH
60877: LD_VAR 0 2
60881: PUSH
60882: LD_VAR 0 4
60886: ARRAY
60887: NONEQUAL
60888: IFFALSE 60900
// begin result := false ;
60890: LD_ADDR_VAR 0 3
60894: PUSH
60895: LD_INT 0
60897: ST_TO_ADDR
// break ;
60898: GO 60902
// end ;
60900: GO 60863
60902: POP
60903: POP
// end ;
60904: LD_VAR 0 3
60908: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60909: LD_INT 0
60911: PPUSH
60912: PPUSH
60913: PPUSH
// pom := GetBase ( fac ) ;
60914: LD_ADDR_VAR 0 5
60918: PUSH
60919: LD_VAR 0 1
60923: PPUSH
60924: CALL_OW 274
60928: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60929: LD_ADDR_VAR 0 4
60933: PUSH
60934: LD_VAR 0 2
60938: PUSH
60939: LD_INT 1
60941: ARRAY
60942: PPUSH
60943: LD_VAR 0 2
60947: PUSH
60948: LD_INT 2
60950: ARRAY
60951: PPUSH
60952: LD_VAR 0 2
60956: PUSH
60957: LD_INT 3
60959: ARRAY
60960: PPUSH
60961: LD_VAR 0 2
60965: PUSH
60966: LD_INT 4
60968: ARRAY
60969: PPUSH
60970: CALL_OW 449
60974: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60975: LD_ADDR_VAR 0 3
60979: PUSH
60980: LD_VAR 0 5
60984: PPUSH
60985: LD_INT 1
60987: PPUSH
60988: CALL_OW 275
60992: PUSH
60993: LD_VAR 0 4
60997: PUSH
60998: LD_INT 1
61000: ARRAY
61001: GREATEREQUAL
61002: PUSH
61003: LD_VAR 0 5
61007: PPUSH
61008: LD_INT 2
61010: PPUSH
61011: CALL_OW 275
61015: PUSH
61016: LD_VAR 0 4
61020: PUSH
61021: LD_INT 2
61023: ARRAY
61024: GREATEREQUAL
61025: AND
61026: PUSH
61027: LD_VAR 0 5
61031: PPUSH
61032: LD_INT 3
61034: PPUSH
61035: CALL_OW 275
61039: PUSH
61040: LD_VAR 0 4
61044: PUSH
61045: LD_INT 3
61047: ARRAY
61048: GREATEREQUAL
61049: AND
61050: ST_TO_ADDR
// end ;
61051: LD_VAR 0 3
61055: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
61056: LD_INT 0
61058: PPUSH
61059: PPUSH
61060: PPUSH
61061: PPUSH
// pom := GetBase ( building ) ;
61062: LD_ADDR_VAR 0 3
61066: PUSH
61067: LD_VAR 0 1
61071: PPUSH
61072: CALL_OW 274
61076: ST_TO_ADDR
// if not pom then
61077: LD_VAR 0 3
61081: NOT
61082: IFFALSE 61086
// exit ;
61084: GO 61256
// btype := GetBType ( building ) ;
61086: LD_ADDR_VAR 0 5
61090: PUSH
61091: LD_VAR 0 1
61095: PPUSH
61096: CALL_OW 266
61100: ST_TO_ADDR
// if btype = b_armoury then
61101: LD_VAR 0 5
61105: PUSH
61106: LD_INT 4
61108: EQUAL
61109: IFFALSE 61119
// btype := b_barracks ;
61111: LD_ADDR_VAR 0 5
61115: PUSH
61116: LD_INT 5
61118: ST_TO_ADDR
// if btype = b_depot then
61119: LD_VAR 0 5
61123: PUSH
61124: LD_INT 0
61126: EQUAL
61127: IFFALSE 61137
// btype := b_warehouse ;
61129: LD_ADDR_VAR 0 5
61133: PUSH
61134: LD_INT 1
61136: ST_TO_ADDR
// if btype = b_workshop then
61137: LD_VAR 0 5
61141: PUSH
61142: LD_INT 2
61144: EQUAL
61145: IFFALSE 61155
// btype := b_factory ;
61147: LD_ADDR_VAR 0 5
61151: PUSH
61152: LD_INT 3
61154: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61155: LD_ADDR_VAR 0 4
61159: PUSH
61160: LD_VAR 0 5
61164: PPUSH
61165: LD_VAR 0 1
61169: PPUSH
61170: CALL_OW 248
61174: PPUSH
61175: CALL_OW 450
61179: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61180: LD_ADDR_VAR 0 2
61184: PUSH
61185: LD_VAR 0 3
61189: PPUSH
61190: LD_INT 1
61192: PPUSH
61193: CALL_OW 275
61197: PUSH
61198: LD_VAR 0 4
61202: PUSH
61203: LD_INT 1
61205: ARRAY
61206: GREATEREQUAL
61207: PUSH
61208: LD_VAR 0 3
61212: PPUSH
61213: LD_INT 2
61215: PPUSH
61216: CALL_OW 275
61220: PUSH
61221: LD_VAR 0 4
61225: PUSH
61226: LD_INT 2
61228: ARRAY
61229: GREATEREQUAL
61230: AND
61231: PUSH
61232: LD_VAR 0 3
61236: PPUSH
61237: LD_INT 3
61239: PPUSH
61240: CALL_OW 275
61244: PUSH
61245: LD_VAR 0 4
61249: PUSH
61250: LD_INT 3
61252: ARRAY
61253: GREATEREQUAL
61254: AND
61255: ST_TO_ADDR
// end ;
61256: LD_VAR 0 2
61260: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61261: LD_INT 0
61263: PPUSH
61264: PPUSH
61265: PPUSH
// pom := GetBase ( building ) ;
61266: LD_ADDR_VAR 0 4
61270: PUSH
61271: LD_VAR 0 1
61275: PPUSH
61276: CALL_OW 274
61280: ST_TO_ADDR
// if not pom then
61281: LD_VAR 0 4
61285: NOT
61286: IFFALSE 61290
// exit ;
61288: GO 61391
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61290: LD_ADDR_VAR 0 5
61294: PUSH
61295: LD_VAR 0 2
61299: PPUSH
61300: LD_VAR 0 1
61304: PPUSH
61305: CALL_OW 248
61309: PPUSH
61310: CALL_OW 450
61314: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61315: LD_ADDR_VAR 0 3
61319: PUSH
61320: LD_VAR 0 4
61324: PPUSH
61325: LD_INT 1
61327: PPUSH
61328: CALL_OW 275
61332: PUSH
61333: LD_VAR 0 5
61337: PUSH
61338: LD_INT 1
61340: ARRAY
61341: GREATEREQUAL
61342: PUSH
61343: LD_VAR 0 4
61347: PPUSH
61348: LD_INT 2
61350: PPUSH
61351: CALL_OW 275
61355: PUSH
61356: LD_VAR 0 5
61360: PUSH
61361: LD_INT 2
61363: ARRAY
61364: GREATEREQUAL
61365: AND
61366: PUSH
61367: LD_VAR 0 4
61371: PPUSH
61372: LD_INT 3
61374: PPUSH
61375: CALL_OW 275
61379: PUSH
61380: LD_VAR 0 5
61384: PUSH
61385: LD_INT 3
61387: ARRAY
61388: GREATEREQUAL
61389: AND
61390: ST_TO_ADDR
// end ;
61391: LD_VAR 0 3
61395: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61396: LD_INT 0
61398: PPUSH
61399: PPUSH
61400: PPUSH
61401: PPUSH
61402: PPUSH
61403: PPUSH
61404: PPUSH
61405: PPUSH
61406: PPUSH
61407: PPUSH
61408: PPUSH
// result := false ;
61409: LD_ADDR_VAR 0 8
61413: PUSH
61414: LD_INT 0
61416: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61417: LD_VAR 0 5
61421: NOT
61422: PUSH
61423: LD_VAR 0 1
61427: NOT
61428: OR
61429: PUSH
61430: LD_VAR 0 2
61434: NOT
61435: OR
61436: PUSH
61437: LD_VAR 0 3
61441: NOT
61442: OR
61443: IFFALSE 61447
// exit ;
61445: GO 62261
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61447: LD_ADDR_VAR 0 14
61451: PUSH
61452: LD_VAR 0 1
61456: PPUSH
61457: LD_VAR 0 2
61461: PPUSH
61462: LD_VAR 0 3
61466: PPUSH
61467: LD_VAR 0 4
61471: PPUSH
61472: LD_VAR 0 5
61476: PUSH
61477: LD_INT 1
61479: ARRAY
61480: PPUSH
61481: CALL_OW 248
61485: PPUSH
61486: LD_INT 0
61488: PPUSH
61489: CALL 63514 0 6
61493: ST_TO_ADDR
// if not hexes then
61494: LD_VAR 0 14
61498: NOT
61499: IFFALSE 61503
// exit ;
61501: GO 62261
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61503: LD_ADDR_VAR 0 17
61507: PUSH
61508: LD_VAR 0 5
61512: PPUSH
61513: LD_INT 22
61515: PUSH
61516: LD_VAR 0 13
61520: PPUSH
61521: CALL_OW 255
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: LD_INT 2
61532: PUSH
61533: LD_INT 30
61535: PUSH
61536: LD_INT 0
61538: PUSH
61539: EMPTY
61540: LIST
61541: LIST
61542: PUSH
61543: LD_INT 30
61545: PUSH
61546: LD_INT 1
61548: PUSH
61549: EMPTY
61550: LIST
61551: LIST
61552: PUSH
61553: EMPTY
61554: LIST
61555: LIST
61556: LIST
61557: PUSH
61558: EMPTY
61559: LIST
61560: LIST
61561: PPUSH
61562: CALL_OW 72
61566: ST_TO_ADDR
// for i = 1 to hexes do
61567: LD_ADDR_VAR 0 9
61571: PUSH
61572: DOUBLE
61573: LD_INT 1
61575: DEC
61576: ST_TO_ADDR
61577: LD_VAR 0 14
61581: PUSH
61582: FOR_TO
61583: IFFALSE 62259
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61585: LD_ADDR_VAR 0 13
61589: PUSH
61590: LD_VAR 0 14
61594: PUSH
61595: LD_VAR 0 9
61599: ARRAY
61600: PUSH
61601: LD_INT 1
61603: ARRAY
61604: PPUSH
61605: LD_VAR 0 14
61609: PUSH
61610: LD_VAR 0 9
61614: ARRAY
61615: PUSH
61616: LD_INT 2
61618: ARRAY
61619: PPUSH
61620: CALL_OW 428
61624: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61625: LD_VAR 0 14
61629: PUSH
61630: LD_VAR 0 9
61634: ARRAY
61635: PUSH
61636: LD_INT 1
61638: ARRAY
61639: PPUSH
61640: LD_VAR 0 14
61644: PUSH
61645: LD_VAR 0 9
61649: ARRAY
61650: PUSH
61651: LD_INT 2
61653: ARRAY
61654: PPUSH
61655: CALL_OW 351
61659: PUSH
61660: LD_VAR 0 14
61664: PUSH
61665: LD_VAR 0 9
61669: ARRAY
61670: PUSH
61671: LD_INT 1
61673: ARRAY
61674: PPUSH
61675: LD_VAR 0 14
61679: PUSH
61680: LD_VAR 0 9
61684: ARRAY
61685: PUSH
61686: LD_INT 2
61688: ARRAY
61689: PPUSH
61690: CALL_OW 488
61694: NOT
61695: OR
61696: PUSH
61697: LD_VAR 0 13
61701: PPUSH
61702: CALL_OW 247
61706: PUSH
61707: LD_INT 3
61709: EQUAL
61710: OR
61711: IFFALSE 61717
// exit ;
61713: POP
61714: POP
61715: GO 62261
// if not tmp then
61717: LD_VAR 0 13
61721: NOT
61722: IFFALSE 61726
// continue ;
61724: GO 61582
// result := true ;
61726: LD_ADDR_VAR 0 8
61730: PUSH
61731: LD_INT 1
61733: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61734: LD_VAR 0 6
61738: PUSH
61739: LD_VAR 0 13
61743: PPUSH
61744: CALL_OW 247
61748: PUSH
61749: LD_INT 2
61751: EQUAL
61752: AND
61753: PUSH
61754: LD_VAR 0 13
61758: PPUSH
61759: CALL_OW 263
61763: PUSH
61764: LD_INT 1
61766: EQUAL
61767: AND
61768: IFFALSE 61932
// begin if IsDrivenBy ( tmp ) then
61770: LD_VAR 0 13
61774: PPUSH
61775: CALL_OW 311
61779: IFFALSE 61783
// continue ;
61781: GO 61582
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61783: LD_VAR 0 6
61787: PPUSH
61788: LD_INT 3
61790: PUSH
61791: LD_INT 60
61793: PUSH
61794: EMPTY
61795: LIST
61796: PUSH
61797: EMPTY
61798: LIST
61799: LIST
61800: PUSH
61801: LD_INT 3
61803: PUSH
61804: LD_INT 55
61806: PUSH
61807: EMPTY
61808: LIST
61809: PUSH
61810: EMPTY
61811: LIST
61812: LIST
61813: PUSH
61814: EMPTY
61815: LIST
61816: LIST
61817: PPUSH
61818: CALL_OW 72
61822: IFFALSE 61930
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61824: LD_ADDR_VAR 0 18
61828: PUSH
61829: LD_VAR 0 6
61833: PPUSH
61834: LD_INT 3
61836: PUSH
61837: LD_INT 60
61839: PUSH
61840: EMPTY
61841: LIST
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PUSH
61847: LD_INT 3
61849: PUSH
61850: LD_INT 55
61852: PUSH
61853: EMPTY
61854: LIST
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: EMPTY
61861: LIST
61862: LIST
61863: PPUSH
61864: CALL_OW 72
61868: PUSH
61869: LD_INT 1
61871: ARRAY
61872: ST_TO_ADDR
// if IsInUnit ( driver ) then
61873: LD_VAR 0 18
61877: PPUSH
61878: CALL_OW 310
61882: IFFALSE 61893
// ComExit ( driver ) ;
61884: LD_VAR 0 18
61888: PPUSH
61889: CALL 87315 0 1
// AddComEnterUnit ( driver , tmp ) ;
61893: LD_VAR 0 18
61897: PPUSH
61898: LD_VAR 0 13
61902: PPUSH
61903: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61907: LD_VAR 0 18
61911: PPUSH
61912: LD_VAR 0 7
61916: PPUSH
61917: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61921: LD_VAR 0 18
61925: PPUSH
61926: CALL_OW 181
// end ; continue ;
61930: GO 61582
// end ; if not cleaners or not tmp in cleaners then
61932: LD_VAR 0 6
61936: NOT
61937: PUSH
61938: LD_VAR 0 13
61942: PUSH
61943: LD_VAR 0 6
61947: IN
61948: NOT
61949: OR
61950: IFFALSE 62257
// begin if dep then
61952: LD_VAR 0 17
61956: IFFALSE 62092
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61958: LD_ADDR_VAR 0 16
61962: PUSH
61963: LD_VAR 0 17
61967: PUSH
61968: LD_INT 1
61970: ARRAY
61971: PPUSH
61972: CALL_OW 250
61976: PPUSH
61977: LD_VAR 0 17
61981: PUSH
61982: LD_INT 1
61984: ARRAY
61985: PPUSH
61986: CALL_OW 254
61990: PPUSH
61991: LD_INT 5
61993: PPUSH
61994: CALL_OW 272
61998: PUSH
61999: LD_VAR 0 17
62003: PUSH
62004: LD_INT 1
62006: ARRAY
62007: PPUSH
62008: CALL_OW 251
62012: PPUSH
62013: LD_VAR 0 17
62017: PUSH
62018: LD_INT 1
62020: ARRAY
62021: PPUSH
62022: CALL_OW 254
62026: PPUSH
62027: LD_INT 5
62029: PPUSH
62030: CALL_OW 273
62034: PUSH
62035: EMPTY
62036: LIST
62037: LIST
62038: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62039: LD_VAR 0 16
62043: PUSH
62044: LD_INT 1
62046: ARRAY
62047: PPUSH
62048: LD_VAR 0 16
62052: PUSH
62053: LD_INT 2
62055: ARRAY
62056: PPUSH
62057: CALL_OW 488
62061: IFFALSE 62092
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62063: LD_VAR 0 13
62067: PPUSH
62068: LD_VAR 0 16
62072: PUSH
62073: LD_INT 1
62075: ARRAY
62076: PPUSH
62077: LD_VAR 0 16
62081: PUSH
62082: LD_INT 2
62084: ARRAY
62085: PPUSH
62086: CALL_OW 111
// continue ;
62090: GO 61582
// end ; end ; r := GetDir ( tmp ) ;
62092: LD_ADDR_VAR 0 15
62096: PUSH
62097: LD_VAR 0 13
62101: PPUSH
62102: CALL_OW 254
62106: ST_TO_ADDR
// if r = 5 then
62107: LD_VAR 0 15
62111: PUSH
62112: LD_INT 5
62114: EQUAL
62115: IFFALSE 62125
// r := 0 ;
62117: LD_ADDR_VAR 0 15
62121: PUSH
62122: LD_INT 0
62124: ST_TO_ADDR
// for j = r to 5 do
62125: LD_ADDR_VAR 0 10
62129: PUSH
62130: DOUBLE
62131: LD_VAR 0 15
62135: DEC
62136: ST_TO_ADDR
62137: LD_INT 5
62139: PUSH
62140: FOR_TO
62141: IFFALSE 62255
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62143: LD_ADDR_VAR 0 11
62147: PUSH
62148: LD_VAR 0 13
62152: PPUSH
62153: CALL_OW 250
62157: PPUSH
62158: LD_VAR 0 10
62162: PPUSH
62163: LD_INT 2
62165: PPUSH
62166: CALL_OW 272
62170: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62171: LD_ADDR_VAR 0 12
62175: PUSH
62176: LD_VAR 0 13
62180: PPUSH
62181: CALL_OW 251
62185: PPUSH
62186: LD_VAR 0 10
62190: PPUSH
62191: LD_INT 2
62193: PPUSH
62194: CALL_OW 273
62198: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62199: LD_VAR 0 11
62203: PPUSH
62204: LD_VAR 0 12
62208: PPUSH
62209: CALL_OW 488
62213: PUSH
62214: LD_VAR 0 11
62218: PPUSH
62219: LD_VAR 0 12
62223: PPUSH
62224: CALL_OW 428
62228: NOT
62229: AND
62230: IFFALSE 62253
// begin ComMoveXY ( tmp , _x , _y ) ;
62232: LD_VAR 0 13
62236: PPUSH
62237: LD_VAR 0 11
62241: PPUSH
62242: LD_VAR 0 12
62246: PPUSH
62247: CALL_OW 111
// break ;
62251: GO 62255
// end ; end ;
62253: GO 62140
62255: POP
62256: POP
// end ; end ;
62257: GO 61582
62259: POP
62260: POP
// end ;
62261: LD_VAR 0 8
62265: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62266: LD_INT 0
62268: PPUSH
// result := true ;
62269: LD_ADDR_VAR 0 3
62273: PUSH
62274: LD_INT 1
62276: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62277: LD_VAR 0 2
62281: PUSH
62282: LD_INT 24
62284: DOUBLE
62285: EQUAL
62286: IFTRUE 62296
62288: LD_INT 33
62290: DOUBLE
62291: EQUAL
62292: IFTRUE 62296
62294: GO 62321
62296: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62297: LD_ADDR_VAR 0 3
62301: PUSH
62302: LD_INT 32
62304: PPUSH
62305: LD_VAR 0 1
62309: PPUSH
62310: CALL_OW 321
62314: PUSH
62315: LD_INT 2
62317: EQUAL
62318: ST_TO_ADDR
62319: GO 62637
62321: LD_INT 20
62323: DOUBLE
62324: EQUAL
62325: IFTRUE 62329
62327: GO 62354
62329: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62330: LD_ADDR_VAR 0 3
62334: PUSH
62335: LD_INT 6
62337: PPUSH
62338: LD_VAR 0 1
62342: PPUSH
62343: CALL_OW 321
62347: PUSH
62348: LD_INT 2
62350: EQUAL
62351: ST_TO_ADDR
62352: GO 62637
62354: LD_INT 22
62356: DOUBLE
62357: EQUAL
62358: IFTRUE 62368
62360: LD_INT 36
62362: DOUBLE
62363: EQUAL
62364: IFTRUE 62368
62366: GO 62393
62368: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62369: LD_ADDR_VAR 0 3
62373: PUSH
62374: LD_INT 15
62376: PPUSH
62377: LD_VAR 0 1
62381: PPUSH
62382: CALL_OW 321
62386: PUSH
62387: LD_INT 2
62389: EQUAL
62390: ST_TO_ADDR
62391: GO 62637
62393: LD_INT 30
62395: DOUBLE
62396: EQUAL
62397: IFTRUE 62401
62399: GO 62426
62401: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62402: LD_ADDR_VAR 0 3
62406: PUSH
62407: LD_INT 20
62409: PPUSH
62410: LD_VAR 0 1
62414: PPUSH
62415: CALL_OW 321
62419: PUSH
62420: LD_INT 2
62422: EQUAL
62423: ST_TO_ADDR
62424: GO 62637
62426: LD_INT 28
62428: DOUBLE
62429: EQUAL
62430: IFTRUE 62440
62432: LD_INT 21
62434: DOUBLE
62435: EQUAL
62436: IFTRUE 62440
62438: GO 62465
62440: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62441: LD_ADDR_VAR 0 3
62445: PUSH
62446: LD_INT 21
62448: PPUSH
62449: LD_VAR 0 1
62453: PPUSH
62454: CALL_OW 321
62458: PUSH
62459: LD_INT 2
62461: EQUAL
62462: ST_TO_ADDR
62463: GO 62637
62465: LD_INT 16
62467: DOUBLE
62468: EQUAL
62469: IFTRUE 62473
62471: GO 62498
62473: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62474: LD_ADDR_VAR 0 3
62478: PUSH
62479: LD_INT 84
62481: PPUSH
62482: LD_VAR 0 1
62486: PPUSH
62487: CALL_OW 321
62491: PUSH
62492: LD_INT 2
62494: EQUAL
62495: ST_TO_ADDR
62496: GO 62637
62498: LD_INT 19
62500: DOUBLE
62501: EQUAL
62502: IFTRUE 62512
62504: LD_INT 23
62506: DOUBLE
62507: EQUAL
62508: IFTRUE 62512
62510: GO 62537
62512: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62513: LD_ADDR_VAR 0 3
62517: PUSH
62518: LD_INT 83
62520: PPUSH
62521: LD_VAR 0 1
62525: PPUSH
62526: CALL_OW 321
62530: PUSH
62531: LD_INT 2
62533: EQUAL
62534: ST_TO_ADDR
62535: GO 62637
62537: LD_INT 17
62539: DOUBLE
62540: EQUAL
62541: IFTRUE 62545
62543: GO 62570
62545: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62546: LD_ADDR_VAR 0 3
62550: PUSH
62551: LD_INT 39
62553: PPUSH
62554: LD_VAR 0 1
62558: PPUSH
62559: CALL_OW 321
62563: PUSH
62564: LD_INT 2
62566: EQUAL
62567: ST_TO_ADDR
62568: GO 62637
62570: LD_INT 18
62572: DOUBLE
62573: EQUAL
62574: IFTRUE 62578
62576: GO 62603
62578: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62579: LD_ADDR_VAR 0 3
62583: PUSH
62584: LD_INT 40
62586: PPUSH
62587: LD_VAR 0 1
62591: PPUSH
62592: CALL_OW 321
62596: PUSH
62597: LD_INT 2
62599: EQUAL
62600: ST_TO_ADDR
62601: GO 62637
62603: LD_INT 27
62605: DOUBLE
62606: EQUAL
62607: IFTRUE 62611
62609: GO 62636
62611: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62612: LD_ADDR_VAR 0 3
62616: PUSH
62617: LD_INT 35
62619: PPUSH
62620: LD_VAR 0 1
62624: PPUSH
62625: CALL_OW 321
62629: PUSH
62630: LD_INT 2
62632: EQUAL
62633: ST_TO_ADDR
62634: GO 62637
62636: POP
// end ;
62637: LD_VAR 0 3
62641: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62642: LD_INT 0
62644: PPUSH
62645: PPUSH
62646: PPUSH
62647: PPUSH
62648: PPUSH
62649: PPUSH
62650: PPUSH
62651: PPUSH
62652: PPUSH
62653: PPUSH
62654: PPUSH
// result := false ;
62655: LD_ADDR_VAR 0 6
62659: PUSH
62660: LD_INT 0
62662: ST_TO_ADDR
// if btype = b_depot then
62663: LD_VAR 0 2
62667: PUSH
62668: LD_INT 0
62670: EQUAL
62671: IFFALSE 62683
// begin result := true ;
62673: LD_ADDR_VAR 0 6
62677: PUSH
62678: LD_INT 1
62680: ST_TO_ADDR
// exit ;
62681: GO 63509
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62683: LD_VAR 0 1
62687: NOT
62688: PUSH
62689: LD_VAR 0 1
62693: PPUSH
62694: CALL_OW 266
62698: PUSH
62699: LD_INT 0
62701: PUSH
62702: LD_INT 1
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: IN
62709: NOT
62710: OR
62711: PUSH
62712: LD_VAR 0 2
62716: NOT
62717: OR
62718: PUSH
62719: LD_VAR 0 5
62723: PUSH
62724: LD_INT 0
62726: PUSH
62727: LD_INT 1
62729: PUSH
62730: LD_INT 2
62732: PUSH
62733: LD_INT 3
62735: PUSH
62736: LD_INT 4
62738: PUSH
62739: LD_INT 5
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: LIST
62749: IN
62750: NOT
62751: OR
62752: PUSH
62753: LD_VAR 0 3
62757: PPUSH
62758: LD_VAR 0 4
62762: PPUSH
62763: CALL_OW 488
62767: NOT
62768: OR
62769: IFFALSE 62773
// exit ;
62771: GO 63509
// side := GetSide ( depot ) ;
62773: LD_ADDR_VAR 0 9
62777: PUSH
62778: LD_VAR 0 1
62782: PPUSH
62783: CALL_OW 255
62787: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62788: LD_VAR 0 9
62792: PPUSH
62793: LD_VAR 0 2
62797: PPUSH
62798: CALL 62266 0 2
62802: NOT
62803: IFFALSE 62807
// exit ;
62805: GO 63509
// pom := GetBase ( depot ) ;
62807: LD_ADDR_VAR 0 10
62811: PUSH
62812: LD_VAR 0 1
62816: PPUSH
62817: CALL_OW 274
62821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62822: LD_ADDR_VAR 0 11
62826: PUSH
62827: LD_VAR 0 2
62831: PPUSH
62832: LD_VAR 0 1
62836: PPUSH
62837: CALL_OW 248
62841: PPUSH
62842: CALL_OW 450
62846: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62847: LD_VAR 0 10
62851: PPUSH
62852: LD_INT 1
62854: PPUSH
62855: CALL_OW 275
62859: PUSH
62860: LD_VAR 0 11
62864: PUSH
62865: LD_INT 1
62867: ARRAY
62868: GREATEREQUAL
62869: PUSH
62870: LD_VAR 0 10
62874: PPUSH
62875: LD_INT 2
62877: PPUSH
62878: CALL_OW 275
62882: PUSH
62883: LD_VAR 0 11
62887: PUSH
62888: LD_INT 2
62890: ARRAY
62891: GREATEREQUAL
62892: AND
62893: PUSH
62894: LD_VAR 0 10
62898: PPUSH
62899: LD_INT 3
62901: PPUSH
62902: CALL_OW 275
62906: PUSH
62907: LD_VAR 0 11
62911: PUSH
62912: LD_INT 3
62914: ARRAY
62915: GREATEREQUAL
62916: AND
62917: NOT
62918: IFFALSE 62922
// exit ;
62920: GO 63509
// if GetBType ( depot ) = b_depot then
62922: LD_VAR 0 1
62926: PPUSH
62927: CALL_OW 266
62931: PUSH
62932: LD_INT 0
62934: EQUAL
62935: IFFALSE 62947
// dist := 28 else
62937: LD_ADDR_VAR 0 14
62941: PUSH
62942: LD_INT 28
62944: ST_TO_ADDR
62945: GO 62955
// dist := 36 ;
62947: LD_ADDR_VAR 0 14
62951: PUSH
62952: LD_INT 36
62954: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62955: LD_VAR 0 1
62959: PPUSH
62960: LD_VAR 0 3
62964: PPUSH
62965: LD_VAR 0 4
62969: PPUSH
62970: CALL_OW 297
62974: PUSH
62975: LD_VAR 0 14
62979: GREATER
62980: IFFALSE 62984
// exit ;
62982: GO 63509
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62984: LD_ADDR_VAR 0 12
62988: PUSH
62989: LD_VAR 0 2
62993: PPUSH
62994: LD_VAR 0 3
62998: PPUSH
62999: LD_VAR 0 4
63003: PPUSH
63004: LD_VAR 0 5
63008: PPUSH
63009: LD_VAR 0 1
63013: PPUSH
63014: CALL_OW 248
63018: PPUSH
63019: LD_INT 0
63021: PPUSH
63022: CALL 63514 0 6
63026: ST_TO_ADDR
// if not hexes then
63027: LD_VAR 0 12
63031: NOT
63032: IFFALSE 63036
// exit ;
63034: GO 63509
// hex := GetHexInfo ( x , y ) ;
63036: LD_ADDR_VAR 0 15
63040: PUSH
63041: LD_VAR 0 3
63045: PPUSH
63046: LD_VAR 0 4
63050: PPUSH
63051: CALL_OW 546
63055: ST_TO_ADDR
// if hex [ 1 ] then
63056: LD_VAR 0 15
63060: PUSH
63061: LD_INT 1
63063: ARRAY
63064: IFFALSE 63068
// exit ;
63066: GO 63509
// height := hex [ 2 ] ;
63068: LD_ADDR_VAR 0 13
63072: PUSH
63073: LD_VAR 0 15
63077: PUSH
63078: LD_INT 2
63080: ARRAY
63081: ST_TO_ADDR
// for i = 1 to hexes do
63082: LD_ADDR_VAR 0 7
63086: PUSH
63087: DOUBLE
63088: LD_INT 1
63090: DEC
63091: ST_TO_ADDR
63092: LD_VAR 0 12
63096: PUSH
63097: FOR_TO
63098: IFFALSE 63428
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63100: LD_VAR 0 12
63104: PUSH
63105: LD_VAR 0 7
63109: ARRAY
63110: PUSH
63111: LD_INT 1
63113: ARRAY
63114: PPUSH
63115: LD_VAR 0 12
63119: PUSH
63120: LD_VAR 0 7
63124: ARRAY
63125: PUSH
63126: LD_INT 2
63128: ARRAY
63129: PPUSH
63130: CALL_OW 488
63134: NOT
63135: PUSH
63136: LD_VAR 0 12
63140: PUSH
63141: LD_VAR 0 7
63145: ARRAY
63146: PUSH
63147: LD_INT 1
63149: ARRAY
63150: PPUSH
63151: LD_VAR 0 12
63155: PUSH
63156: LD_VAR 0 7
63160: ARRAY
63161: PUSH
63162: LD_INT 2
63164: ARRAY
63165: PPUSH
63166: CALL_OW 428
63170: PUSH
63171: LD_INT 0
63173: GREATER
63174: OR
63175: PUSH
63176: LD_VAR 0 12
63180: PUSH
63181: LD_VAR 0 7
63185: ARRAY
63186: PUSH
63187: LD_INT 1
63189: ARRAY
63190: PPUSH
63191: LD_VAR 0 12
63195: PUSH
63196: LD_VAR 0 7
63200: ARRAY
63201: PUSH
63202: LD_INT 2
63204: ARRAY
63205: PPUSH
63206: CALL_OW 351
63210: OR
63211: IFFALSE 63217
// exit ;
63213: POP
63214: POP
63215: GO 63509
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63217: LD_ADDR_VAR 0 8
63221: PUSH
63222: LD_VAR 0 12
63226: PUSH
63227: LD_VAR 0 7
63231: ARRAY
63232: PUSH
63233: LD_INT 1
63235: ARRAY
63236: PPUSH
63237: LD_VAR 0 12
63241: PUSH
63242: LD_VAR 0 7
63246: ARRAY
63247: PUSH
63248: LD_INT 2
63250: ARRAY
63251: PPUSH
63252: CALL_OW 546
63256: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63257: LD_VAR 0 8
63261: PUSH
63262: LD_INT 1
63264: ARRAY
63265: PUSH
63266: LD_VAR 0 8
63270: PUSH
63271: LD_INT 2
63273: ARRAY
63274: PUSH
63275: LD_VAR 0 13
63279: PUSH
63280: LD_INT 2
63282: PLUS
63283: GREATER
63284: OR
63285: PUSH
63286: LD_VAR 0 8
63290: PUSH
63291: LD_INT 2
63293: ARRAY
63294: PUSH
63295: LD_VAR 0 13
63299: PUSH
63300: LD_INT 2
63302: MINUS
63303: LESS
63304: OR
63305: PUSH
63306: LD_VAR 0 8
63310: PUSH
63311: LD_INT 3
63313: ARRAY
63314: PUSH
63315: LD_INT 0
63317: PUSH
63318: LD_INT 8
63320: PUSH
63321: LD_INT 9
63323: PUSH
63324: LD_INT 10
63326: PUSH
63327: LD_INT 11
63329: PUSH
63330: LD_INT 12
63332: PUSH
63333: LD_INT 13
63335: PUSH
63336: LD_INT 16
63338: PUSH
63339: LD_INT 17
63341: PUSH
63342: LD_INT 18
63344: PUSH
63345: LD_INT 19
63347: PUSH
63348: LD_INT 20
63350: PUSH
63351: LD_INT 21
63353: PUSH
63354: EMPTY
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: LIST
63363: LIST
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: IN
63369: NOT
63370: OR
63371: PUSH
63372: LD_VAR 0 8
63376: PUSH
63377: LD_INT 5
63379: ARRAY
63380: NOT
63381: OR
63382: PUSH
63383: LD_VAR 0 8
63387: PUSH
63388: LD_INT 6
63390: ARRAY
63391: PUSH
63392: LD_INT 1
63394: PUSH
63395: LD_INT 2
63397: PUSH
63398: LD_INT 7
63400: PUSH
63401: LD_INT 9
63403: PUSH
63404: LD_INT 10
63406: PUSH
63407: LD_INT 11
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: IN
63418: NOT
63419: OR
63420: IFFALSE 63426
// exit ;
63422: POP
63423: POP
63424: GO 63509
// end ;
63426: GO 63097
63428: POP
63429: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63430: LD_VAR 0 9
63434: PPUSH
63435: LD_VAR 0 3
63439: PPUSH
63440: LD_VAR 0 4
63444: PPUSH
63445: LD_INT 20
63447: PPUSH
63448: CALL 55432 0 4
63452: PUSH
63453: LD_INT 4
63455: ARRAY
63456: IFFALSE 63460
// exit ;
63458: GO 63509
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63460: LD_VAR 0 2
63464: PUSH
63465: LD_INT 29
63467: PUSH
63468: LD_INT 30
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: IN
63475: PUSH
63476: LD_VAR 0 3
63480: PPUSH
63481: LD_VAR 0 4
63485: PPUSH
63486: LD_VAR 0 9
63490: PPUSH
63491: CALL_OW 440
63495: NOT
63496: AND
63497: IFFALSE 63501
// exit ;
63499: GO 63509
// result := true ;
63501: LD_ADDR_VAR 0 6
63505: PUSH
63506: LD_INT 1
63508: ST_TO_ADDR
// end ;
63509: LD_VAR 0 6
63513: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63514: LD_INT 0
63516: PPUSH
63517: PPUSH
63518: PPUSH
63519: PPUSH
63520: PPUSH
63521: PPUSH
63522: PPUSH
63523: PPUSH
63524: PPUSH
63525: PPUSH
63526: PPUSH
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
63531: PPUSH
63532: PPUSH
63533: PPUSH
63534: PPUSH
63535: PPUSH
63536: PPUSH
63537: PPUSH
63538: PPUSH
63539: PPUSH
63540: PPUSH
63541: PPUSH
63542: PPUSH
63543: PPUSH
63544: PPUSH
63545: PPUSH
63546: PPUSH
63547: PPUSH
63548: PPUSH
63549: PPUSH
63550: PPUSH
63551: PPUSH
63552: PPUSH
63553: PPUSH
63554: PPUSH
63555: PPUSH
63556: PPUSH
63557: PPUSH
63558: PPUSH
63559: PPUSH
63560: PPUSH
63561: PPUSH
63562: PPUSH
63563: PPUSH
63564: PPUSH
63565: PPUSH
63566: PPUSH
63567: PPUSH
63568: PPUSH
63569: PPUSH
63570: PPUSH
63571: PPUSH
63572: PPUSH
63573: PPUSH
// result = [ ] ;
63574: LD_ADDR_VAR 0 7
63578: PUSH
63579: EMPTY
63580: ST_TO_ADDR
// temp_list = [ ] ;
63581: LD_ADDR_VAR 0 9
63585: PUSH
63586: EMPTY
63587: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63588: LD_VAR 0 4
63592: PUSH
63593: LD_INT 0
63595: PUSH
63596: LD_INT 1
63598: PUSH
63599: LD_INT 2
63601: PUSH
63602: LD_INT 3
63604: PUSH
63605: LD_INT 4
63607: PUSH
63608: LD_INT 5
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: IN
63619: NOT
63620: PUSH
63621: LD_VAR 0 1
63625: PUSH
63626: LD_INT 0
63628: PUSH
63629: LD_INT 1
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: IN
63636: PUSH
63637: LD_VAR 0 5
63641: PUSH
63642: LD_INT 1
63644: PUSH
63645: LD_INT 2
63647: PUSH
63648: LD_INT 3
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: LIST
63655: IN
63656: NOT
63657: AND
63658: OR
63659: IFFALSE 63663
// exit ;
63661: GO 82054
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63663: LD_VAR 0 1
63667: PUSH
63668: LD_INT 6
63670: PUSH
63671: LD_INT 7
63673: PUSH
63674: LD_INT 8
63676: PUSH
63677: LD_INT 13
63679: PUSH
63680: LD_INT 12
63682: PUSH
63683: LD_INT 15
63685: PUSH
63686: LD_INT 11
63688: PUSH
63689: LD_INT 14
63691: PUSH
63692: LD_INT 10
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: IN
63706: IFFALSE 63716
// btype = b_lab ;
63708: LD_ADDR_VAR 0 1
63712: PUSH
63713: LD_INT 6
63715: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63716: LD_VAR 0 6
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: LD_INT 1
63726: PUSH
63727: LD_INT 2
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: LIST
63734: IN
63735: NOT
63736: PUSH
63737: LD_VAR 0 1
63741: PUSH
63742: LD_INT 0
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: LD_INT 2
63750: PUSH
63751: LD_INT 3
63753: PUSH
63754: LD_INT 6
63756: PUSH
63757: LD_INT 36
63759: PUSH
63760: LD_INT 4
63762: PUSH
63763: LD_INT 5
63765: PUSH
63766: LD_INT 31
63768: PUSH
63769: LD_INT 32
63771: PUSH
63772: LD_INT 33
63774: PUSH
63775: EMPTY
63776: LIST
63777: LIST
63778: LIST
63779: LIST
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: LIST
63787: IN
63788: NOT
63789: PUSH
63790: LD_VAR 0 6
63794: PUSH
63795: LD_INT 1
63797: EQUAL
63798: AND
63799: OR
63800: PUSH
63801: LD_VAR 0 1
63805: PUSH
63806: LD_INT 2
63808: PUSH
63809: LD_INT 3
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: IN
63816: NOT
63817: PUSH
63818: LD_VAR 0 6
63822: PUSH
63823: LD_INT 2
63825: EQUAL
63826: AND
63827: OR
63828: IFFALSE 63838
// mode = 0 ;
63830: LD_ADDR_VAR 0 6
63834: PUSH
63835: LD_INT 0
63837: ST_TO_ADDR
// case mode of 0 :
63838: LD_VAR 0 6
63842: PUSH
63843: LD_INT 0
63845: DOUBLE
63846: EQUAL
63847: IFTRUE 63851
63849: GO 75304
63851: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63852: LD_ADDR_VAR 0 11
63856: PUSH
63857: LD_INT 0
63859: PUSH
63860: LD_INT 0
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 0
63869: PUSH
63870: LD_INT 1
63872: NEG
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 1
63880: PUSH
63881: LD_INT 0
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 1
63890: PUSH
63891: LD_INT 1
63893: PUSH
63894: EMPTY
63895: LIST
63896: LIST
63897: PUSH
63898: LD_INT 0
63900: PUSH
63901: LD_INT 1
63903: PUSH
63904: EMPTY
63905: LIST
63906: LIST
63907: PUSH
63908: LD_INT 1
63910: NEG
63911: PUSH
63912: LD_INT 0
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 1
63921: NEG
63922: PUSH
63923: LD_INT 1
63925: NEG
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: LD_INT 2
63937: NEG
63938: PUSH
63939: EMPTY
63940: LIST
63941: LIST
63942: PUSH
63943: LD_INT 0
63945: PUSH
63946: LD_INT 2
63948: NEG
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 1
63956: PUSH
63957: LD_INT 1
63959: NEG
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: PUSH
63965: LD_INT 1
63967: PUSH
63968: LD_INT 2
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 0
63977: PUSH
63978: LD_INT 2
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PUSH
63985: LD_INT 1
63987: NEG
63988: PUSH
63989: LD_INT 1
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: PUSH
63996: LD_INT 1
63998: PUSH
63999: LD_INT 3
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 0
64008: PUSH
64009: LD_INT 3
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 1
64018: NEG
64019: PUSH
64020: LD_INT 2
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: LIST
64031: LIST
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64045: LD_ADDR_VAR 0 12
64049: PUSH
64050: LD_INT 0
64052: PUSH
64053: LD_INT 0
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 0
64062: PUSH
64063: LD_INT 1
64065: NEG
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: LD_INT 0
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: PUSH
64081: LD_INT 1
64083: PUSH
64084: LD_INT 1
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: LD_INT 0
64093: PUSH
64094: LD_INT 1
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: NEG
64104: PUSH
64105: LD_INT 0
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: LD_INT 1
64114: NEG
64115: PUSH
64116: LD_INT 1
64118: NEG
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 1
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 2
64137: PUSH
64138: LD_INT 0
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PUSH
64145: LD_INT 2
64147: PUSH
64148: LD_INT 1
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 1
64157: NEG
64158: PUSH
64159: LD_INT 1
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 2
64168: NEG
64169: PUSH
64170: LD_INT 0
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 2
64179: NEG
64180: PUSH
64181: LD_INT 1
64183: NEG
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 2
64191: NEG
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 3
64202: NEG
64203: PUSH
64204: LD_INT 0
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 3
64213: NEG
64214: PUSH
64215: LD_INT 1
64217: NEG
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: EMPTY
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64241: LD_ADDR_VAR 0 13
64245: PUSH
64246: LD_INT 0
64248: PUSH
64249: LD_INT 0
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: LD_INT 0
64258: PUSH
64259: LD_INT 1
64261: NEG
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 1
64269: PUSH
64270: LD_INT 0
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 1
64279: PUSH
64280: LD_INT 1
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 0
64289: PUSH
64290: LD_INT 1
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 1
64299: NEG
64300: PUSH
64301: LD_INT 0
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PUSH
64308: LD_INT 1
64310: NEG
64311: PUSH
64312: LD_INT 1
64314: NEG
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: LD_INT 1
64322: NEG
64323: PUSH
64324: LD_INT 2
64326: NEG
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 2
64334: PUSH
64335: LD_INT 1
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 2
64344: PUSH
64345: LD_INT 2
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: LD_INT 1
64354: PUSH
64355: LD_INT 2
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: LD_INT 2
64364: NEG
64365: PUSH
64366: LD_INT 1
64368: NEG
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: LD_INT 2
64376: NEG
64377: PUSH
64378: LD_INT 2
64380: NEG
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: LD_INT 2
64388: NEG
64389: PUSH
64390: LD_INT 3
64392: NEG
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: LD_INT 3
64400: NEG
64401: PUSH
64402: LD_INT 2
64404: NEG
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PUSH
64410: LD_INT 3
64412: NEG
64413: PUSH
64414: LD_INT 3
64416: NEG
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: LIST
64426: LIST
64427: LIST
64428: LIST
64429: LIST
64430: LIST
64431: LIST
64432: LIST
64433: LIST
64434: LIST
64435: LIST
64436: LIST
64437: LIST
64438: LIST
64439: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64440: LD_ADDR_VAR 0 14
64444: PUSH
64445: LD_INT 0
64447: PUSH
64448: LD_INT 0
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 0
64457: PUSH
64458: LD_INT 1
64460: NEG
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: LD_INT 0
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 1
64478: PUSH
64479: LD_INT 1
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 0
64488: PUSH
64489: LD_INT 1
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_INT 1
64498: NEG
64499: PUSH
64500: LD_INT 0
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 1
64509: NEG
64510: PUSH
64511: LD_INT 1
64513: NEG
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 1
64521: NEG
64522: PUSH
64523: LD_INT 2
64525: NEG
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 0
64533: PUSH
64534: LD_INT 2
64536: NEG
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: PUSH
64542: LD_INT 1
64544: PUSH
64545: LD_INT 1
64547: NEG
64548: PUSH
64549: EMPTY
64550: LIST
64551: LIST
64552: PUSH
64553: LD_INT 1
64555: PUSH
64556: LD_INT 2
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: LD_INT 0
64565: PUSH
64566: LD_INT 2
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PUSH
64573: LD_INT 1
64575: NEG
64576: PUSH
64577: LD_INT 1
64579: PUSH
64580: EMPTY
64581: LIST
64582: LIST
64583: PUSH
64584: LD_INT 1
64586: NEG
64587: PUSH
64588: LD_INT 3
64590: NEG
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 0
64598: PUSH
64599: LD_INT 3
64601: NEG
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: PUSH
64610: LD_INT 2
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64636: LD_ADDR_VAR 0 15
64640: PUSH
64641: LD_INT 0
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 0
64653: PUSH
64654: LD_INT 1
64656: NEG
64657: PUSH
64658: EMPTY
64659: LIST
64660: LIST
64661: PUSH
64662: LD_INT 1
64664: PUSH
64665: LD_INT 0
64667: PUSH
64668: EMPTY
64669: LIST
64670: LIST
64671: PUSH
64672: LD_INT 1
64674: PUSH
64675: LD_INT 1
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 0
64684: PUSH
64685: LD_INT 1
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: PUSH
64692: LD_INT 1
64694: NEG
64695: PUSH
64696: LD_INT 0
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 1
64705: NEG
64706: PUSH
64707: LD_INT 1
64709: NEG
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 1
64717: PUSH
64718: LD_INT 1
64720: NEG
64721: PUSH
64722: EMPTY
64723: LIST
64724: LIST
64725: PUSH
64726: LD_INT 2
64728: PUSH
64729: LD_INT 0
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 2
64738: PUSH
64739: LD_INT 1
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: LD_INT 1
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 2
64759: NEG
64760: PUSH
64761: LD_INT 0
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 2
64770: NEG
64771: PUSH
64772: LD_INT 1
64774: NEG
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 2
64782: PUSH
64783: LD_INT 1
64785: NEG
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: LD_INT 3
64793: PUSH
64794: LD_INT 0
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: LD_INT 3
64803: PUSH
64804: LD_INT 1
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: LIST
64828: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64829: LD_ADDR_VAR 0 16
64833: PUSH
64834: LD_INT 0
64836: PUSH
64837: LD_INT 0
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 0
64846: PUSH
64847: LD_INT 1
64849: NEG
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 1
64857: PUSH
64858: LD_INT 0
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: LD_INT 1
64867: PUSH
64868: LD_INT 1
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PUSH
64875: LD_INT 0
64877: PUSH
64878: LD_INT 1
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: NEG
64888: PUSH
64889: LD_INT 0
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PUSH
64896: LD_INT 1
64898: NEG
64899: PUSH
64900: LD_INT 1
64902: NEG
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: PUSH
64908: LD_INT 1
64910: NEG
64911: PUSH
64912: LD_INT 2
64914: NEG
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PUSH
64920: LD_INT 2
64922: PUSH
64923: LD_INT 1
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: PUSH
64930: LD_INT 2
64932: PUSH
64933: LD_INT 2
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PUSH
64940: LD_INT 1
64942: PUSH
64943: LD_INT 2
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 2
64952: NEG
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 2
64964: NEG
64965: PUSH
64966: LD_INT 2
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 3
64976: PUSH
64977: LD_INT 2
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PUSH
64984: LD_INT 3
64986: PUSH
64987: LD_INT 3
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 2
64996: PUSH
64997: LD_INT 3
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65022: LD_ADDR_VAR 0 17
65026: PUSH
65027: LD_INT 0
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 0
65039: PUSH
65040: LD_INT 1
65042: NEG
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 1
65050: PUSH
65051: LD_INT 0
65053: PUSH
65054: EMPTY
65055: LIST
65056: LIST
65057: PUSH
65058: LD_INT 1
65060: PUSH
65061: LD_INT 1
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 0
65070: PUSH
65071: LD_INT 1
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 1
65080: NEG
65081: PUSH
65082: LD_INT 0
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 1
65091: NEG
65092: PUSH
65093: LD_INT 1
65095: NEG
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 1
65103: NEG
65104: PUSH
65105: LD_INT 2
65107: NEG
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PUSH
65113: LD_INT 0
65115: PUSH
65116: LD_INT 2
65118: NEG
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 1
65126: PUSH
65127: LD_INT 1
65129: NEG
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 2
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 2
65147: PUSH
65148: LD_INT 1
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: PUSH
65155: LD_INT 2
65157: PUSH
65158: LD_INT 2
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PUSH
65165: LD_INT 1
65167: PUSH
65168: LD_INT 2
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 0
65177: PUSH
65178: LD_INT 2
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 1
65187: NEG
65188: PUSH
65189: LD_INT 1
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PUSH
65196: LD_INT 2
65198: NEG
65199: PUSH
65200: LD_INT 0
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 2
65209: NEG
65210: PUSH
65211: LD_INT 1
65213: NEG
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: PUSH
65219: LD_INT 2
65221: NEG
65222: PUSH
65223: LD_INT 2
65225: NEG
65226: PUSH
65227: EMPTY
65228: LIST
65229: LIST
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65252: LD_ADDR_VAR 0 18
65256: PUSH
65257: LD_INT 0
65259: PUSH
65260: LD_INT 0
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 0
65269: PUSH
65270: LD_INT 1
65272: NEG
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 1
65280: PUSH
65281: LD_INT 0
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: LD_INT 1
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 0
65300: PUSH
65301: LD_INT 1
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: PUSH
65308: LD_INT 1
65310: NEG
65311: PUSH
65312: LD_INT 0
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 1
65321: NEG
65322: PUSH
65323: LD_INT 1
65325: NEG
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 1
65333: NEG
65334: PUSH
65335: LD_INT 2
65337: NEG
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PUSH
65343: LD_INT 0
65345: PUSH
65346: LD_INT 2
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 1
65356: PUSH
65357: LD_INT 1
65359: NEG
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 2
65367: PUSH
65368: LD_INT 0
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: LD_INT 2
65377: PUSH
65378: LD_INT 1
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PUSH
65385: LD_INT 2
65387: PUSH
65388: LD_INT 2
65390: PUSH
65391: EMPTY
65392: LIST
65393: LIST
65394: PUSH
65395: LD_INT 1
65397: PUSH
65398: LD_INT 2
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: PUSH
65405: LD_INT 0
65407: PUSH
65408: LD_INT 2
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 1
65417: NEG
65418: PUSH
65419: LD_INT 1
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 2
65428: NEG
65429: PUSH
65430: LD_INT 0
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 2
65439: NEG
65440: PUSH
65441: LD_INT 1
65443: NEG
65444: PUSH
65445: EMPTY
65446: LIST
65447: LIST
65448: PUSH
65449: LD_INT 2
65451: NEG
65452: PUSH
65453: LD_INT 2
65455: NEG
65456: PUSH
65457: EMPTY
65458: LIST
65459: LIST
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65482: LD_ADDR_VAR 0 19
65486: PUSH
65487: LD_INT 0
65489: PUSH
65490: LD_INT 0
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: LD_INT 1
65502: NEG
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: LD_INT 1
65510: PUSH
65511: LD_INT 0
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: LD_INT 1
65520: PUSH
65521: LD_INT 1
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 0
65530: PUSH
65531: LD_INT 1
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 1
65540: NEG
65541: PUSH
65542: LD_INT 0
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 1
65551: NEG
65552: PUSH
65553: LD_INT 1
65555: NEG
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 1
65563: NEG
65564: PUSH
65565: LD_INT 2
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 0
65575: PUSH
65576: LD_INT 2
65578: NEG
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 1
65586: PUSH
65587: LD_INT 1
65589: NEG
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 2
65597: PUSH
65598: LD_INT 0
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 2
65607: PUSH
65608: LD_INT 1
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PUSH
65615: LD_INT 2
65617: PUSH
65618: LD_INT 2
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PUSH
65625: LD_INT 1
65627: PUSH
65628: LD_INT 2
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: LD_INT 0
65637: PUSH
65638: LD_INT 2
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 1
65647: NEG
65648: PUSH
65649: LD_INT 1
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 2
65658: NEG
65659: PUSH
65660: LD_INT 0
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 2
65669: NEG
65670: PUSH
65671: LD_INT 1
65673: NEG
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: LD_INT 2
65681: NEG
65682: PUSH
65683: LD_INT 2
65685: NEG
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65712: LD_ADDR_VAR 0 20
65716: PUSH
65717: LD_INT 0
65719: PUSH
65720: LD_INT 0
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 0
65729: PUSH
65730: LD_INT 1
65732: NEG
65733: PUSH
65734: EMPTY
65735: LIST
65736: LIST
65737: PUSH
65738: LD_INT 1
65740: PUSH
65741: LD_INT 0
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 1
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 0
65760: PUSH
65761: LD_INT 1
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 1
65770: NEG
65771: PUSH
65772: LD_INT 0
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 1
65781: NEG
65782: PUSH
65783: LD_INT 1
65785: NEG
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 1
65793: NEG
65794: PUSH
65795: LD_INT 2
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 0
65805: PUSH
65806: LD_INT 2
65808: NEG
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 1
65816: PUSH
65817: LD_INT 1
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 2
65827: PUSH
65828: LD_INT 0
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 2
65837: PUSH
65838: LD_INT 1
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 2
65847: PUSH
65848: LD_INT 2
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 1
65857: PUSH
65858: LD_INT 2
65860: PUSH
65861: EMPTY
65862: LIST
65863: LIST
65864: PUSH
65865: LD_INT 0
65867: PUSH
65868: LD_INT 2
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 1
65877: NEG
65878: PUSH
65879: LD_INT 1
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 2
65888: NEG
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 2
65899: NEG
65900: PUSH
65901: LD_INT 1
65903: NEG
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: LD_INT 2
65911: NEG
65912: PUSH
65913: LD_INT 2
65915: NEG
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65942: LD_ADDR_VAR 0 21
65946: PUSH
65947: LD_INT 0
65949: PUSH
65950: LD_INT 0
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 0
65959: PUSH
65960: LD_INT 1
65962: NEG
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 1
65970: PUSH
65971: LD_INT 0
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: LD_INT 1
65980: PUSH
65981: LD_INT 1
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: PUSH
65988: LD_INT 0
65990: PUSH
65991: LD_INT 1
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 1
66000: NEG
66001: PUSH
66002: LD_INT 0
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 1
66011: NEG
66012: PUSH
66013: LD_INT 1
66015: NEG
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 1
66023: NEG
66024: PUSH
66025: LD_INT 2
66027: NEG
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 0
66035: PUSH
66036: LD_INT 2
66038: NEG
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 1
66046: PUSH
66047: LD_INT 1
66049: NEG
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 2
66057: PUSH
66058: LD_INT 0
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 2
66067: PUSH
66068: LD_INT 1
66070: PUSH
66071: EMPTY
66072: LIST
66073: LIST
66074: PUSH
66075: LD_INT 2
66077: PUSH
66078: LD_INT 2
66080: PUSH
66081: EMPTY
66082: LIST
66083: LIST
66084: PUSH
66085: LD_INT 1
66087: PUSH
66088: LD_INT 2
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 0
66097: PUSH
66098: LD_INT 2
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 1
66107: NEG
66108: PUSH
66109: LD_INT 1
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 2
66118: NEG
66119: PUSH
66120: LD_INT 0
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 2
66129: NEG
66130: PUSH
66131: LD_INT 1
66133: NEG
66134: PUSH
66135: EMPTY
66136: LIST
66137: LIST
66138: PUSH
66139: LD_INT 2
66141: NEG
66142: PUSH
66143: LD_INT 2
66145: NEG
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66172: LD_ADDR_VAR 0 22
66176: PUSH
66177: LD_INT 0
66179: PUSH
66180: LD_INT 0
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: LD_INT 1
66192: NEG
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: PUSH
66198: LD_INT 1
66200: PUSH
66201: LD_INT 0
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 1
66210: PUSH
66211: LD_INT 1
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 0
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 1
66230: NEG
66231: PUSH
66232: LD_INT 0
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 1
66241: NEG
66242: PUSH
66243: LD_INT 1
66245: NEG
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 1
66253: NEG
66254: PUSH
66255: LD_INT 2
66257: NEG
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 0
66265: PUSH
66266: LD_INT 2
66268: NEG
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 1
66276: PUSH
66277: LD_INT 1
66279: NEG
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 2
66287: PUSH
66288: LD_INT 0
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 2
66297: PUSH
66298: LD_INT 1
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 2
66307: PUSH
66308: LD_INT 2
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: LD_INT 2
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: LD_INT 2
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 1
66337: NEG
66338: PUSH
66339: LD_INT 1
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: NEG
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 2
66359: NEG
66360: PUSH
66361: LD_INT 1
66363: NEG
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 2
66371: NEG
66372: PUSH
66373: LD_INT 2
66375: NEG
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66402: LD_ADDR_VAR 0 23
66406: PUSH
66407: LD_INT 0
66409: PUSH
66410: LD_INT 0
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 0
66419: PUSH
66420: LD_INT 1
66422: NEG
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 1
66430: PUSH
66431: LD_INT 0
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: LD_INT 1
66440: PUSH
66441: LD_INT 1
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 0
66450: PUSH
66451: LD_INT 1
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 1
66460: NEG
66461: PUSH
66462: LD_INT 0
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 1
66471: NEG
66472: PUSH
66473: LD_INT 1
66475: NEG
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: LD_INT 2
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 0
66495: PUSH
66496: LD_INT 2
66498: NEG
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 1
66506: PUSH
66507: LD_INT 1
66509: NEG
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 2
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 2
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 2
66537: PUSH
66538: LD_INT 2
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 1
66547: PUSH
66548: LD_INT 2
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 0
66557: PUSH
66558: LD_INT 2
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 1
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: NEG
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 2
66589: NEG
66590: PUSH
66591: LD_INT 1
66593: NEG
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 2
66601: NEG
66602: PUSH
66603: LD_INT 2
66605: NEG
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 2
66613: NEG
66614: PUSH
66615: LD_INT 3
66617: NEG
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 1
66625: NEG
66626: PUSH
66627: LD_INT 3
66629: NEG
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 1
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 2
66648: PUSH
66649: LD_INT 1
66651: NEG
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66682: LD_ADDR_VAR 0 24
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: LD_INT 0
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 0
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: LD_INT 0
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 1
66720: PUSH
66721: LD_INT 1
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 0
66730: PUSH
66731: LD_INT 1
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: NEG
66741: PUSH
66742: LD_INT 0
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 1
66751: NEG
66752: PUSH
66753: LD_INT 1
66755: NEG
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 2
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: LD_INT 2
66778: NEG
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: PUSH
66787: LD_INT 1
66789: NEG
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 2
66807: PUSH
66808: LD_INT 1
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 2
66817: PUSH
66818: LD_INT 2
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 1
66827: PUSH
66828: LD_INT 2
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: LD_INT 2
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 1
66847: NEG
66848: PUSH
66849: LD_INT 1
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 2
66858: NEG
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 2
66869: NEG
66870: PUSH
66871: LD_INT 1
66873: NEG
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 2
66881: NEG
66882: PUSH
66883: LD_INT 2
66885: NEG
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: LD_INT 2
66896: NEG
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: LD_INT 2
66904: PUSH
66905: LD_INT 1
66907: NEG
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 3
66915: PUSH
66916: LD_INT 1
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 3
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66958: LD_ADDR_VAR 0 25
66962: PUSH
66963: LD_INT 0
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: LD_INT 1
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 1
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 1
66996: PUSH
66997: LD_INT 1
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 0
67006: PUSH
67007: LD_INT 1
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: NEG
67017: PUSH
67018: LD_INT 0
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: LD_INT 1
67031: NEG
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: LD_INT 2
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: LD_INT 2
67054: NEG
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: PUSH
67063: LD_INT 1
67065: NEG
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 2
67073: PUSH
67074: LD_INT 0
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 2
67083: PUSH
67084: LD_INT 1
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 2
67093: PUSH
67094: LD_INT 2
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: LD_INT 2
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 0
67113: PUSH
67114: LD_INT 2
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 1
67123: NEG
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 2
67134: NEG
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 2
67145: NEG
67146: PUSH
67147: LD_INT 1
67149: NEG
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 2
67157: NEG
67158: PUSH
67159: LD_INT 2
67161: NEG
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 3
67169: PUSH
67170: LD_INT 1
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 3
67179: PUSH
67180: LD_INT 2
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 2
67189: PUSH
67190: LD_INT 3
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 1
67199: PUSH
67200: LD_INT 3
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67232: LD_ADDR_VAR 0 26
67236: PUSH
67237: LD_INT 0
67239: PUSH
67240: LD_INT 0
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: LD_INT 1
67252: NEG
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 1
67260: PUSH
67261: LD_INT 0
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: LD_INT 1
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 0
67280: PUSH
67281: LD_INT 1
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: LD_INT 0
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 1
67301: NEG
67302: PUSH
67303: LD_INT 1
67305: NEG
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 1
67313: NEG
67314: PUSH
67315: LD_INT 2
67317: NEG
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: LD_INT 2
67328: NEG
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 1
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 2
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 2
67357: PUSH
67358: LD_INT 1
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: LD_INT 2
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: LD_INT 2
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 0
67387: PUSH
67388: LD_INT 2
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 1
67397: NEG
67398: PUSH
67399: LD_INT 1
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 2
67408: NEG
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 2
67419: NEG
67420: PUSH
67421: LD_INT 1
67423: NEG
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 2
67431: NEG
67432: PUSH
67433: LD_INT 2
67435: NEG
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: PUSH
67441: LD_INT 2
67443: PUSH
67444: LD_INT 3
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: LD_INT 3
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 1
67463: NEG
67464: PUSH
67465: LD_INT 2
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 2
67474: NEG
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67508: LD_ADDR_VAR 0 27
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 0
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: NEG
67567: PUSH
67568: LD_INT 0
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: NEG
67578: PUSH
67579: LD_INT 1
67581: NEG
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 1
67589: NEG
67590: PUSH
67591: LD_INT 2
67593: NEG
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: LD_INT 2
67604: NEG
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 1
67615: NEG
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: LD_INT 1
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 2
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: PUSH
67654: LD_INT 2
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: LD_INT 2
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 1
67673: NEG
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 2
67684: NEG
67685: PUSH
67686: LD_INT 0
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 2
67695: NEG
67696: PUSH
67697: LD_INT 1
67699: NEG
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: NEG
67708: PUSH
67709: LD_INT 2
67711: NEG
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 1
67719: NEG
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 2
67730: NEG
67731: PUSH
67732: LD_INT 1
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 3
67741: NEG
67742: PUSH
67743: LD_INT 1
67745: NEG
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 3
67753: NEG
67754: PUSH
67755: LD_INT 2
67757: NEG
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67788: LD_ADDR_VAR 0 28
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: LD_INT 1
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: PUSH
67827: LD_INT 1
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: LD_INT 1
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: PUSH
67844: LD_INT 1
67846: NEG
67847: PUSH
67848: LD_INT 0
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 1
67857: NEG
67858: PUSH
67859: LD_INT 1
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 1
67869: NEG
67870: PUSH
67871: LD_INT 2
67873: NEG
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 0
67881: PUSH
67882: LD_INT 2
67884: NEG
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 1
67895: NEG
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: LD_INT 0
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: LD_INT 2
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 1
67933: PUSH
67934: LD_INT 2
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 0
67943: PUSH
67944: LD_INT 2
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 1
67953: NEG
67954: PUSH
67955: LD_INT 1
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: LD_INT 2
67964: NEG
67965: PUSH
67966: LD_INT 0
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: NEG
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 2
67987: NEG
67988: PUSH
67989: LD_INT 2
67991: NEG
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 2
67999: NEG
68000: PUSH
68001: LD_INT 3
68003: NEG
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: LD_INT 3
68015: NEG
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 3
68023: NEG
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 3
68035: NEG
68036: PUSH
68037: LD_INT 2
68039: NEG
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68070: LD_ADDR_VAR 0 29
68074: PUSH
68075: LD_INT 0
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: LD_INT 1
68090: NEG
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PUSH
68096: LD_INT 1
68098: PUSH
68099: LD_INT 0
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 1
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 0
68118: PUSH
68119: LD_INT 1
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 1
68128: NEG
68129: PUSH
68130: LD_INT 0
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 1
68139: NEG
68140: PUSH
68141: LD_INT 1
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 1
68151: NEG
68152: PUSH
68153: LD_INT 2
68155: NEG
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 0
68163: PUSH
68164: LD_INT 2
68166: NEG
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 1
68174: PUSH
68175: LD_INT 1
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 2
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 2
68195: PUSH
68196: LD_INT 1
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 1
68205: PUSH
68206: LD_INT 2
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 0
68215: PUSH
68216: LD_INT 2
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 1
68225: NEG
68226: PUSH
68227: LD_INT 1
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 2
68236: NEG
68237: PUSH
68238: LD_INT 1
68240: NEG
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 2
68248: NEG
68249: PUSH
68250: LD_INT 2
68252: NEG
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 2
68260: NEG
68261: PUSH
68262: LD_INT 3
68264: NEG
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 2
68272: PUSH
68273: LD_INT 1
68275: NEG
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 3
68283: PUSH
68284: LD_INT 1
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 1
68293: PUSH
68294: LD_INT 3
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 1
68303: NEG
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 3
68314: NEG
68315: PUSH
68316: LD_INT 2
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68349: LD_ADDR_VAR 0 30
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 1
68377: PUSH
68378: LD_INT 0
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: NEG
68408: PUSH
68409: LD_INT 0
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 1
68418: NEG
68419: PUSH
68420: LD_INT 1
68422: NEG
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: LD_INT 2
68434: NEG
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 0
68442: PUSH
68443: LD_INT 2
68445: NEG
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: LD_INT 1
68456: NEG
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 2
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: LD_INT 2
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: PUSH
68495: LD_INT 2
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 1
68504: NEG
68505: PUSH
68506: LD_INT 1
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 2
68515: NEG
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 2
68526: NEG
68527: PUSH
68528: LD_INT 1
68530: NEG
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: LD_INT 1
68538: NEG
68539: PUSH
68540: LD_INT 3
68542: NEG
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 1
68550: PUSH
68551: LD_INT 2
68553: NEG
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 3
68561: PUSH
68562: LD_INT 2
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 2
68571: PUSH
68572: LD_INT 3
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 2
68581: NEG
68582: PUSH
68583: LD_INT 1
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 3
68592: NEG
68593: PUSH
68594: LD_INT 1
68596: NEG
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68627: LD_ADDR_VAR 0 31
68631: PUSH
68632: LD_INT 0
68634: PUSH
68635: LD_INT 0
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 0
68644: PUSH
68645: LD_INT 1
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: LD_INT 0
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: PUSH
68663: LD_INT 1
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 0
68675: PUSH
68676: LD_INT 1
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 1
68685: NEG
68686: PUSH
68687: LD_INT 0
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 1
68696: NEG
68697: PUSH
68698: LD_INT 1
68700: NEG
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PUSH
68710: LD_INT 2
68712: NEG
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: LD_INT 1
68723: NEG
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 2
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: LD_INT 1
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: LD_INT 2
68751: PUSH
68752: LD_INT 2
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 0
68771: PUSH
68772: LD_INT 2
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 1
68781: NEG
68782: PUSH
68783: LD_INT 1
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 2
68792: NEG
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 2
68804: NEG
68805: PUSH
68806: LD_INT 2
68808: NEG
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 2
68816: NEG
68817: PUSH
68818: LD_INT 3
68820: NEG
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 2
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 3
68839: PUSH
68840: LD_INT 1
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 1
68849: PUSH
68850: LD_INT 3
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 1
68859: NEG
68860: PUSH
68861: LD_INT 2
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 3
68870: NEG
68871: PUSH
68872: LD_INT 2
68874: NEG
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68905: LD_ADDR_VAR 0 32
68909: PUSH
68910: LD_INT 0
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 0
68922: PUSH
68923: LD_INT 1
68925: NEG
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 1
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 1
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 0
68953: PUSH
68954: LD_INT 1
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 1
68963: NEG
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 1
68974: NEG
68975: PUSH
68976: LD_INT 1
68978: NEG
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: NEG
68987: PUSH
68988: LD_INT 2
68990: NEG
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 0
68998: PUSH
68999: LD_INT 2
69001: NEG
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: PUSH
69010: LD_INT 1
69012: NEG
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 2
69020: PUSH
69021: LD_INT 1
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 0
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 1
69060: NEG
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 2
69071: NEG
69072: PUSH
69073: LD_INT 0
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 2
69082: NEG
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: LD_INT 3
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: PUSH
69107: LD_INT 2
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 3
69117: PUSH
69118: LD_INT 2
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 2
69127: PUSH
69128: LD_INT 3
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 2
69137: NEG
69138: PUSH
69139: LD_INT 1
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 3
69148: NEG
69149: PUSH
69150: LD_INT 1
69152: NEG
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69183: LD_ADDR_VAR 0 33
69187: PUSH
69188: LD_INT 0
69190: PUSH
69191: LD_INT 0
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: LD_INT 1
69203: NEG
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 1
69211: PUSH
69212: LD_INT 0
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: PUSH
69222: LD_INT 1
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: LD_INT 1
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: LD_INT 0
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 1
69264: NEG
69265: PUSH
69266: LD_INT 2
69268: NEG
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 1
69276: PUSH
69277: LD_INT 1
69279: NEG
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 2
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: LD_INT 2
69297: PUSH
69298: LD_INT 1
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: LD_INT 2
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: LD_INT 1
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 2
69349: NEG
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: LD_INT 2
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 2
69373: NEG
69374: PUSH
69375: LD_INT 3
69377: NEG
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 2
69385: PUSH
69386: LD_INT 1
69388: NEG
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 3
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 3
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: NEG
69417: PUSH
69418: LD_INT 2
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 3
69427: NEG
69428: PUSH
69429: LD_INT 2
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69462: LD_ADDR_VAR 0 34
69466: PUSH
69467: LD_INT 0
69469: PUSH
69470: LD_INT 0
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 0
69479: PUSH
69480: LD_INT 1
69482: NEG
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: LD_INT 0
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 0
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 0
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 1
69531: NEG
69532: PUSH
69533: LD_INT 1
69535: NEG
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 1
69543: NEG
69544: PUSH
69545: LD_INT 2
69547: NEG
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: LD_INT 2
69558: NEG
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 2
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 2
69587: PUSH
69588: LD_INT 2
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 1
69597: PUSH
69598: LD_INT 2
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: LD_INT 1
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 2
69629: NEG
69630: PUSH
69631: LD_INT 1
69633: NEG
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: LD_INT 2
69641: NEG
69642: PUSH
69643: LD_INT 2
69645: NEG
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 1
69653: NEG
69654: PUSH
69655: LD_INT 3
69657: NEG
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 1
69665: PUSH
69666: LD_INT 2
69668: NEG
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 3
69676: PUSH
69677: LD_INT 2
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 2
69686: PUSH
69687: LD_INT 3
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 2
69696: NEG
69697: PUSH
69698: LD_INT 1
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 3
69707: NEG
69708: PUSH
69709: LD_INT 1
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69742: LD_ADDR_VAR 0 35
69746: PUSH
69747: LD_INT 0
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 0
69759: PUSH
69760: LD_INT 1
69762: NEG
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: LD_INT 0
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: LD_INT 1
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 0
69790: PUSH
69791: LD_INT 1
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 1
69800: NEG
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 1
69815: NEG
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 1
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: LD_INT 1
69837: NEG
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69854: LD_ADDR_VAR 0 36
69858: PUSH
69859: LD_INT 0
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 0
69871: PUSH
69872: LD_INT 1
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: LD_INT 0
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: LD_INT 1
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 1
69912: NEG
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 2
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: LD_INT 2
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69966: LD_ADDR_VAR 0 37
69970: PUSH
69971: LD_INT 0
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: LD_INT 1
69986: NEG
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 1
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 0
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: NEG
70025: PUSH
70026: LD_INT 0
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70078: LD_ADDR_VAR 0 38
70082: PUSH
70083: LD_INT 0
70085: PUSH
70086: LD_INT 0
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 0
70095: PUSH
70096: LD_INT 1
70098: NEG
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: LD_INT 0
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 0
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 1
70136: NEG
70137: PUSH
70138: LD_INT 0
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 1
70147: NEG
70148: PUSH
70149: LD_INT 1
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: PUSH
70160: LD_INT 1
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: NEG
70170: PUSH
70171: LD_INT 1
70173: NEG
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70190: LD_ADDR_VAR 0 39
70194: PUSH
70195: LD_INT 0
70197: PUSH
70198: LD_INT 0
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: LD_INT 1
70210: NEG
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: LD_INT 1
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: LD_INT 1
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: LD_INT 1
70248: NEG
70249: PUSH
70250: LD_INT 0
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: PUSH
70261: LD_INT 1
70263: NEG
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 1
70271: NEG
70272: PUSH
70273: LD_INT 2
70275: NEG
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: LD_INT 2
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70302: LD_ADDR_VAR 0 40
70306: PUSH
70307: LD_INT 0
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 0
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 1
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 1
70340: PUSH
70341: LD_INT 1
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 0
70350: PUSH
70351: LD_INT 1
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 1
70360: NEG
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 1
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 1
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 1
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70414: LD_ADDR_VAR 0 41
70418: PUSH
70419: LD_INT 0
70421: PUSH
70422: LD_INT 0
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: LD_INT 1
70434: NEG
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: LD_INT 0
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: LD_INT 1
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 0
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: NEG
70473: PUSH
70474: LD_INT 0
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: LD_INT 2
70499: NEG
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 1
70507: PUSH
70508: LD_INT 1
70510: NEG
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 2
70518: PUSH
70519: LD_INT 0
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 2
70528: PUSH
70529: LD_INT 1
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 2
70538: PUSH
70539: LD_INT 2
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: LD_INT 2
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: NEG
70559: PUSH
70560: LD_INT 1
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: NEG
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 2
70580: NEG
70581: PUSH
70582: LD_INT 1
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 2
70592: NEG
70593: PUSH
70594: LD_INT 2
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 2
70604: NEG
70605: PUSH
70606: LD_INT 3
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: LD_INT 1
70619: NEG
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 3
70627: PUSH
70628: LD_INT 0
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 3
70637: PUSH
70638: LD_INT 1
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 3
70647: PUSH
70648: LD_INT 2
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: PUSH
70658: LD_INT 3
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 2
70667: PUSH
70668: LD_INT 3
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 2
70677: NEG
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 3
70688: NEG
70689: PUSH
70690: LD_INT 0
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 3
70699: NEG
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 3
70711: NEG
70712: PUSH
70713: LD_INT 2
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 3
70723: NEG
70724: PUSH
70725: LD_INT 3
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70764: LD_ADDR_VAR 0 42
70768: PUSH
70769: LD_INT 0
70771: PUSH
70772: LD_INT 0
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 0
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: PUSH
70803: LD_INT 1
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: NEG
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 2
70879: PUSH
70880: LD_INT 1
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 2
70889: PUSH
70890: LD_INT 2
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: PUSH
70900: LD_INT 2
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: LD_INT 2
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: LD_INT 1
70934: NEG
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: NEG
70943: PUSH
70944: LD_INT 2
70946: NEG
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: NEG
70955: PUSH
70956: LD_INT 3
70958: NEG
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: NEG
70967: PUSH
70968: LD_INT 3
70970: NEG
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 0
70978: PUSH
70979: LD_INT 3
70981: NEG
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 1
70989: PUSH
70990: LD_INT 2
70992: NEG
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 3
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 3
71010: PUSH
71011: LD_INT 3
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 2
71020: PUSH
71021: LD_INT 3
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 1
71030: PUSH
71031: LD_INT 3
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 0
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 1
71050: NEG
71051: PUSH
71052: LD_INT 2
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 3
71061: NEG
71062: PUSH
71063: LD_INT 2
71065: NEG
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 3
71073: NEG
71074: PUSH
71075: LD_INT 3
71077: NEG
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: LIST
71113: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71114: LD_ADDR_VAR 0 43
71118: PUSH
71119: LD_INT 0
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: LD_INT 0
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 1
71152: PUSH
71153: LD_INT 1
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 0
71162: PUSH
71163: LD_INT 1
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 0
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: LD_INT 1
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 1
71195: NEG
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 0
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: LD_INT 1
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 2
71239: PUSH
71240: LD_INT 1
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 1
71249: PUSH
71250: LD_INT 2
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 0
71259: PUSH
71260: LD_INT 2
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: NEG
71270: PUSH
71271: LD_INT 1
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: LD_INT 0
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 2
71291: NEG
71292: PUSH
71293: LD_INT 1
71295: NEG
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: LD_INT 3
71307: NEG
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: LD_INT 3
71318: NEG
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: LD_INT 2
71329: NEG
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 2
71337: PUSH
71338: LD_INT 1
71340: NEG
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 3
71348: PUSH
71349: LD_INT 0
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 3
71358: PUSH
71359: LD_INT 1
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 1
71368: PUSH
71369: LD_INT 3
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 0
71378: PUSH
71379: LD_INT 3
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 2
71399: NEG
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 3
71410: NEG
71411: PUSH
71412: LD_INT 0
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 3
71421: NEG
71422: PUSH
71423: LD_INT 1
71425: NEG
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: LIST
71459: LIST
71460: LIST
71461: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71462: LD_ADDR_VAR 0 44
71466: PUSH
71467: LD_INT 0
71469: PUSH
71470: LD_INT 0
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 0
71479: PUSH
71480: LD_INT 1
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 1
71490: PUSH
71491: LD_INT 0
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 1
71500: PUSH
71501: LD_INT 1
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 0
71510: PUSH
71511: LD_INT 1
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: LD_INT 0
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: LD_INT 1
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: NEG
71544: PUSH
71545: LD_INT 2
71547: NEG
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: LD_INT 1
71558: NEG
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 2
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 2
71576: PUSH
71577: LD_INT 1
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 2
71586: PUSH
71587: LD_INT 2
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: LD_INT 2
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 1
71606: NEG
71607: PUSH
71608: LD_INT 1
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: NEG
71618: PUSH
71619: LD_INT 0
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 2
71628: NEG
71629: PUSH
71630: LD_INT 1
71632: NEG
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 2
71640: NEG
71641: PUSH
71642: LD_INT 2
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 2
71652: NEG
71653: PUSH
71654: LD_INT 3
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 3
71675: PUSH
71676: LD_INT 0
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 3
71685: PUSH
71686: LD_INT 1
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 3
71695: PUSH
71696: LD_INT 2
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 3
71705: PUSH
71706: LD_INT 3
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 2
71715: PUSH
71716: LD_INT 3
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 2
71725: NEG
71726: PUSH
71727: LD_INT 1
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 3
71736: NEG
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 3
71747: NEG
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 3
71759: NEG
71760: PUSH
71761: LD_INT 2
71763: NEG
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 3
71771: NEG
71772: PUSH
71773: LD_INT 3
71775: NEG
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71812: LD_ADDR_VAR 0 45
71816: PUSH
71817: LD_INT 0
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: LD_INT 1
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 1
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: PUSH
71851: LD_INT 1
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: LD_INT 1
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: LD_INT 0
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: LD_INT 1
71885: NEG
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 1
71893: NEG
71894: PUSH
71895: LD_INT 2
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 0
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 2
71927: PUSH
71928: LD_INT 1
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 2
71937: PUSH
71938: LD_INT 2
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: LD_INT 2
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 0
71957: PUSH
71958: LD_INT 2
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 1
71967: NEG
71968: PUSH
71969: LD_INT 1
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: LD_INT 1
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 2
71990: NEG
71991: PUSH
71992: LD_INT 2
71994: NEG
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: LD_INT 3
72006: NEG
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 1
72014: NEG
72015: PUSH
72016: LD_INT 3
72018: NEG
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 0
72026: PUSH
72027: LD_INT 3
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 1
72037: PUSH
72038: LD_INT 2
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 3
72048: PUSH
72049: LD_INT 2
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 3
72058: PUSH
72059: LD_INT 3
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 2
72068: PUSH
72069: LD_INT 3
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: LD_INT 3
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: LD_INT 3
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: LD_INT 2
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 3
72109: NEG
72110: PUSH
72111: LD_INT 2
72113: NEG
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 3
72121: NEG
72122: PUSH
72123: LD_INT 3
72125: NEG
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72162: LD_ADDR_VAR 0 46
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 1
72182: NEG
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 1
72243: NEG
72244: PUSH
72245: LD_INT 2
72247: NEG
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: LD_INT 2
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 2
72277: PUSH
72278: LD_INT 0
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 2
72287: PUSH
72288: LD_INT 1
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 2
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: LD_INT 2
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 1
72317: NEG
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 2
72328: NEG
72329: PUSH
72330: LD_INT 0
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: NEG
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 1
72351: NEG
72352: PUSH
72353: LD_INT 3
72355: NEG
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: LD_INT 3
72366: NEG
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 1
72374: PUSH
72375: LD_INT 2
72377: NEG
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 2
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 3
72396: PUSH
72397: LD_INT 0
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 3
72406: PUSH
72407: LD_INT 1
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 1
72416: PUSH
72417: LD_INT 3
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 3
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 1
72436: NEG
72437: PUSH
72438: LD_INT 2
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 2
72447: NEG
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 3
72458: NEG
72459: PUSH
72460: LD_INT 0
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 3
72469: NEG
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: EMPTY
72476: LIST
72477: LIST
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72510: LD_ADDR_VAR 0 47
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 1
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: PUSH
72549: LD_INT 1
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: LD_INT 1
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 1
72568: NEG
72569: PUSH
72570: LD_INT 0
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 1
72579: NEG
72580: PUSH
72581: LD_INT 1
72583: NEG
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 1
72591: NEG
72592: PUSH
72593: LD_INT 2
72595: NEG
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 0
72603: PUSH
72604: LD_INT 2
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 1
72614: PUSH
72615: LD_INT 1
72617: NEG
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 2
72625: NEG
72626: PUSH
72627: LD_INT 1
72629: NEG
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 2
72637: NEG
72638: PUSH
72639: LD_INT 2
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72661: LD_ADDR_VAR 0 48
72665: PUSH
72666: LD_INT 0
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: LD_INT 1
72681: NEG
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: PUSH
72700: LD_INT 1
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 0
72709: PUSH
72710: LD_INT 1
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 1
72719: NEG
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 1
72730: NEG
72731: PUSH
72732: LD_INT 1
72734: NEG
72735: PUSH
72736: EMPTY
72737: LIST
72738: LIST
72739: PUSH
72740: LD_INT 1
72742: NEG
72743: PUSH
72744: LD_INT 2
72746: NEG
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 0
72754: PUSH
72755: LD_INT 2
72757: NEG
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: PUSH
72766: LD_INT 1
72768: NEG
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: LD_INT 0
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 2
72786: PUSH
72787: LD_INT 1
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: LIST
72806: LIST
72807: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72808: LD_ADDR_VAR 0 49
72812: PUSH
72813: LD_INT 0
72815: PUSH
72816: LD_INT 0
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 0
72825: PUSH
72826: LD_INT 1
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: LD_INT 1
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: LD_INT 1
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 1
72866: NEG
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 1
72877: NEG
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 1
72892: NEG
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 2
72900: PUSH
72901: LD_INT 0
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 2
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 2
72920: PUSH
72921: LD_INT 2
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 1
72930: PUSH
72931: LD_INT 2
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72952: LD_ADDR_VAR 0 50
72956: PUSH
72957: LD_INT 0
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 0
72969: PUSH
72970: LD_INT 1
72972: NEG
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PUSH
72978: LD_INT 1
72980: PUSH
72981: LD_INT 0
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: PUSH
72988: LD_INT 1
72990: PUSH
72991: LD_INT 1
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 0
73000: PUSH
73001: LD_INT 1
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 1
73010: NEG
73011: PUSH
73012: LD_INT 0
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: LD_INT 1
73021: NEG
73022: PUSH
73023: LD_INT 1
73025: NEG
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 2
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: PUSH
73044: LD_INT 2
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: LD_INT 2
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: LD_INT 0
73063: PUSH
73064: LD_INT 2
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: LD_INT 1
73073: NEG
73074: PUSH
73075: LD_INT 1
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73096: LD_ADDR_VAR 0 51
73100: PUSH
73101: LD_INT 0
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 0
73113: PUSH
73114: LD_INT 1
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 1
73124: PUSH
73125: LD_INT 0
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 1
73134: PUSH
73135: LD_INT 1
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 0
73144: PUSH
73145: LD_INT 1
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 1
73154: NEG
73155: PUSH
73156: LD_INT 0
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 1
73165: NEG
73166: PUSH
73167: LD_INT 1
73169: NEG
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PUSH
73175: LD_INT 1
73177: PUSH
73178: LD_INT 2
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 0
73187: PUSH
73188: LD_INT 2
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: LD_INT 1
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 2
73208: NEG
73209: PUSH
73210: LD_INT 0
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: PUSH
73217: LD_INT 2
73219: NEG
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73243: LD_ADDR_VAR 0 52
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: LD_INT 1
73263: NEG
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: LD_INT 0
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: LD_INT 1
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 0
73291: PUSH
73292: LD_INT 1
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 1
73301: NEG
73302: PUSH
73303: LD_INT 0
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 1
73312: NEG
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: LD_INT 2
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 1
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 2
73347: NEG
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 2
73358: NEG
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PUSH
73368: LD_INT 2
73370: NEG
73371: PUSH
73372: LD_INT 2
73374: NEG
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73394: LD_ADDR_VAR 0 53
73398: PUSH
73399: LD_INT 0
73401: PUSH
73402: LD_INT 0
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 0
73411: PUSH
73412: LD_INT 1
73414: NEG
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 1
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 1
73432: PUSH
73433: LD_INT 1
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 0
73442: PUSH
73443: LD_INT 1
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: LD_INT 0
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 1
73463: NEG
73464: PUSH
73465: LD_INT 1
73467: NEG
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 1
73475: NEG
73476: PUSH
73477: LD_INT 2
73479: NEG
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 0
73487: PUSH
73488: LD_INT 2
73490: NEG
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 1
73498: PUSH
73499: LD_INT 1
73501: NEG
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 2
73509: PUSH
73510: LD_INT 0
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 2
73519: PUSH
73520: LD_INT 1
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 2
73529: PUSH
73530: LD_INT 2
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 1
73539: PUSH
73540: LD_INT 2
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 0
73549: PUSH
73550: LD_INT 2
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 1
73559: NEG
73560: PUSH
73561: LD_INT 1
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 2
73570: NEG
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 2
73581: NEG
73582: PUSH
73583: LD_INT 1
73585: NEG
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: PUSH
73591: LD_INT 2
73593: NEG
73594: PUSH
73595: LD_INT 2
73597: NEG
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73624: LD_ADDR_VAR 0 54
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: LD_INT 1
73644: NEG
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PUSH
73650: LD_INT 1
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 1
73662: PUSH
73663: LD_INT 1
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 0
73672: PUSH
73673: LD_INT 1
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: LD_INT 0
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 1
73693: NEG
73694: PUSH
73695: LD_INT 1
73697: NEG
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 1
73705: NEG
73706: PUSH
73707: LD_INT 2
73709: NEG
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 0
73717: PUSH
73718: LD_INT 2
73720: NEG
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 1
73728: PUSH
73729: LD_INT 1
73731: NEG
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: PUSH
73737: LD_INT 2
73739: PUSH
73740: LD_INT 0
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 2
73749: PUSH
73750: LD_INT 1
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 2
73759: PUSH
73760: LD_INT 2
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: PUSH
73767: LD_INT 1
73769: PUSH
73770: LD_INT 2
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 0
73779: PUSH
73780: LD_INT 2
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 1
73789: NEG
73790: PUSH
73791: LD_INT 1
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 2
73800: NEG
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 2
73811: NEG
73812: PUSH
73813: LD_INT 1
73815: NEG
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: LD_INT 2
73823: NEG
73824: PUSH
73825: LD_INT 2
73827: NEG
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73854: LD_ADDR_VAR 0 55
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: LD_INT 1
73874: NEG
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: LD_INT 0
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 1
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 0
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 1
73923: NEG
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: LD_INT 2
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: LD_INT 2
73950: NEG
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 1
73961: NEG
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 2
73969: PUSH
73970: LD_INT 0
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: LD_INT 1
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 2
73989: PUSH
73990: LD_INT 2
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: LD_INT 2
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: LD_INT 2
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: NEG
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 2
74041: NEG
74042: PUSH
74043: LD_INT 1
74045: NEG
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 2
74053: NEG
74054: PUSH
74055: LD_INT 2
74057: NEG
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74084: LD_ADDR_VAR 0 56
74088: PUSH
74089: LD_INT 0
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: LD_INT 1
74104: NEG
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 1
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 1
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: NEG
74143: PUSH
74144: LD_INT 0
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 1
74153: NEG
74154: PUSH
74155: LD_INT 1
74157: NEG
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: LD_INT 2
74169: NEG
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 0
74177: PUSH
74178: LD_INT 2
74180: NEG
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 1
74188: PUSH
74189: LD_INT 1
74191: NEG
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: LD_INT 0
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 2
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 2
74219: PUSH
74220: LD_INT 2
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 1
74229: PUSH
74230: LD_INT 2
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 0
74239: PUSH
74240: LD_INT 2
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 1
74249: NEG
74250: PUSH
74251: LD_INT 1
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: LD_INT 0
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 2
74271: NEG
74272: PUSH
74273: LD_INT 1
74275: NEG
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 2
74283: NEG
74284: PUSH
74285: LD_INT 2
74287: NEG
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74314: LD_ADDR_VAR 0 57
74318: PUSH
74319: LD_INT 0
74321: PUSH
74322: LD_INT 0
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 0
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: PUSH
74340: LD_INT 1
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 1
74352: PUSH
74353: LD_INT 1
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 0
74362: PUSH
74363: LD_INT 1
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 1
74372: NEG
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 1
74383: NEG
74384: PUSH
74385: LD_INT 1
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: LD_INT 2
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 0
74407: PUSH
74408: LD_INT 2
74410: NEG
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 1
74418: PUSH
74419: LD_INT 1
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 2
74429: PUSH
74430: LD_INT 0
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 2
74439: PUSH
74440: LD_INT 1
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: LD_INT 2
74449: PUSH
74450: LD_INT 2
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 1
74459: PUSH
74460: LD_INT 2
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: LD_INT 2
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: LD_INT 1
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 2
74490: NEG
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 2
74501: NEG
74502: PUSH
74503: LD_INT 1
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 2
74513: NEG
74514: PUSH
74515: LD_INT 2
74517: NEG
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: LIST
74535: LIST
74536: LIST
74537: LIST
74538: LIST
74539: LIST
74540: LIST
74541: LIST
74542: LIST
74543: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74544: LD_ADDR_VAR 0 58
74548: PUSH
74549: LD_INT 0
74551: PUSH
74552: LD_INT 0
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 0
74561: PUSH
74562: LD_INT 1
74564: NEG
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: LD_INT 0
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 1
74582: PUSH
74583: LD_INT 1
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: LD_INT 0
74592: PUSH
74593: LD_INT 1
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 1
74602: NEG
74603: PUSH
74604: LD_INT 0
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 1
74613: NEG
74614: PUSH
74615: LD_INT 1
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 1
74625: NEG
74626: PUSH
74627: LD_INT 2
74629: NEG
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 0
74637: PUSH
74638: LD_INT 2
74640: NEG
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: PUSH
74649: LD_INT 1
74651: NEG
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 2
74659: PUSH
74660: LD_INT 0
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: LD_INT 1
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 2
74679: PUSH
74680: LD_INT 2
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: PUSH
74690: LD_INT 2
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 0
74699: PUSH
74700: LD_INT 2
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 1
74709: NEG
74710: PUSH
74711: LD_INT 1
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PUSH
74718: LD_INT 2
74720: NEG
74721: PUSH
74722: LD_INT 0
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 2
74731: NEG
74732: PUSH
74733: LD_INT 1
74735: NEG
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 2
74743: NEG
74744: PUSH
74745: LD_INT 2
74747: NEG
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74774: LD_ADDR_VAR 0 59
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: LD_INT 0
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 0
74791: PUSH
74792: LD_INT 1
74794: NEG
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: LD_INT 0
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: LD_INT 1
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 0
74822: PUSH
74823: LD_INT 1
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: LD_INT 1
74832: NEG
74833: PUSH
74834: LD_INT 0
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74862: LD_ADDR_VAR 0 60
74866: PUSH
74867: LD_INT 0
74869: PUSH
74870: LD_INT 0
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: LD_INT 0
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 1
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: LD_INT 1
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 0
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: LD_INT 1
74935: NEG
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74950: LD_ADDR_VAR 0 61
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: LD_INT 0
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 0
74967: PUSH
74968: LD_INT 1
74970: NEG
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: PUSH
74989: LD_INT 1
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 0
74998: PUSH
74999: LD_INT 1
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 1
75008: NEG
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 1
75019: NEG
75020: PUSH
75021: LD_INT 1
75023: NEG
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75038: LD_ADDR_VAR 0 62
75042: PUSH
75043: LD_INT 0
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 0
75055: PUSH
75056: LD_INT 1
75058: NEG
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: LD_INT 0
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 1
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 1
75096: NEG
75097: PUSH
75098: LD_INT 0
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: LD_INT 1
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75126: LD_ADDR_VAR 0 63
75130: PUSH
75131: LD_INT 0
75133: PUSH
75134: LD_INT 0
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 0
75143: PUSH
75144: LD_INT 1
75146: NEG
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: LD_INT 0
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: LD_INT 1
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 0
75174: PUSH
75175: LD_INT 1
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 1
75184: NEG
75185: PUSH
75186: LD_INT 0
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: NEG
75196: PUSH
75197: LD_INT 1
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75214: LD_ADDR_VAR 0 64
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: LD_INT 1
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 0
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 1
75272: NEG
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 1
75283: NEG
75284: PUSH
75285: LD_INT 1
75287: NEG
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: LIST
75299: LIST
75300: LIST
75301: ST_TO_ADDR
// end ; 1 :
75302: GO 81199
75304: LD_INT 1
75306: DOUBLE
75307: EQUAL
75308: IFTRUE 75312
75310: GO 77935
75312: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75313: LD_ADDR_VAR 0 11
75317: PUSH
75318: LD_INT 1
75320: NEG
75321: PUSH
75322: LD_INT 3
75324: NEG
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: LD_INT 3
75335: NEG
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: LD_INT 2
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: LIST
75356: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75357: LD_ADDR_VAR 0 12
75361: PUSH
75362: LD_INT 2
75364: PUSH
75365: LD_INT 1
75367: NEG
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: PUSH
75373: LD_INT 3
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 3
75385: PUSH
75386: LD_INT 1
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: LIST
75397: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75398: LD_ADDR_VAR 0 13
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: LD_INT 2
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 3
75415: PUSH
75416: LD_INT 3
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 2
75425: PUSH
75426: LD_INT 3
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: LIST
75437: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75438: LD_ADDR_VAR 0 14
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 3
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 0
75455: PUSH
75456: LD_INT 3
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 1
75465: NEG
75466: PUSH
75467: LD_INT 2
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: LIST
75478: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75479: LD_ADDR_VAR 0 15
75483: PUSH
75484: LD_INT 2
75486: NEG
75487: PUSH
75488: LD_INT 1
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 3
75497: NEG
75498: PUSH
75499: LD_INT 0
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 3
75508: NEG
75509: PUSH
75510: LD_INT 1
75512: NEG
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: LIST
75522: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75523: LD_ADDR_VAR 0 16
75527: PUSH
75528: LD_INT 2
75530: NEG
75531: PUSH
75532: LD_INT 3
75534: NEG
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 3
75542: NEG
75543: PUSH
75544: LD_INT 2
75546: NEG
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 3
75554: NEG
75555: PUSH
75556: LD_INT 3
75558: NEG
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: LIST
75568: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75569: LD_ADDR_VAR 0 17
75573: PUSH
75574: LD_INT 1
75576: NEG
75577: PUSH
75578: LD_INT 3
75580: NEG
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 0
75588: PUSH
75589: LD_INT 3
75591: NEG
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 1
75599: PUSH
75600: LD_INT 2
75602: NEG
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: LIST
75612: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75613: LD_ADDR_VAR 0 18
75617: PUSH
75618: LD_INT 2
75620: PUSH
75621: LD_INT 1
75623: NEG
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 3
75631: PUSH
75632: LD_INT 0
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 3
75641: PUSH
75642: LD_INT 1
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: LIST
75653: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75654: LD_ADDR_VAR 0 19
75658: PUSH
75659: LD_INT 3
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 3
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 2
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: LIST
75693: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75694: LD_ADDR_VAR 0 20
75698: PUSH
75699: LD_INT 1
75701: PUSH
75702: LD_INT 3
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 0
75711: PUSH
75712: LD_INT 3
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: LD_INT 2
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: LIST
75734: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75735: LD_ADDR_VAR 0 21
75739: PUSH
75740: LD_INT 2
75742: NEG
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 3
75753: NEG
75754: PUSH
75755: LD_INT 0
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 3
75764: NEG
75765: PUSH
75766: LD_INT 1
75768: NEG
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: LIST
75778: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75779: LD_ADDR_VAR 0 22
75783: PUSH
75784: LD_INT 2
75786: NEG
75787: PUSH
75788: LD_INT 3
75790: NEG
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 3
75798: NEG
75799: PUSH
75800: LD_INT 2
75802: NEG
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 3
75810: NEG
75811: PUSH
75812: LD_INT 3
75814: NEG
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: LIST
75824: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75825: LD_ADDR_VAR 0 23
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: LD_INT 3
75835: NEG
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: PUSH
75841: LD_INT 1
75843: NEG
75844: PUSH
75845: LD_INT 4
75847: NEG
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: LD_INT 1
75855: PUSH
75856: LD_INT 3
75858: NEG
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: LIST
75868: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75869: LD_ADDR_VAR 0 24
75873: PUSH
75874: LD_INT 3
75876: PUSH
75877: LD_INT 0
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 3
75886: PUSH
75887: LD_INT 1
75889: NEG
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 4
75897: PUSH
75898: LD_INT 1
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: LIST
75909: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75910: LD_ADDR_VAR 0 25
75914: PUSH
75915: LD_INT 3
75917: PUSH
75918: LD_INT 3
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 4
75927: PUSH
75928: LD_INT 3
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 3
75937: PUSH
75938: LD_INT 4
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: LIST
75949: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75950: LD_ADDR_VAR 0 26
75954: PUSH
75955: LD_INT 0
75957: PUSH
75958: LD_INT 3
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: LD_INT 4
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 1
75977: NEG
75978: PUSH
75979: LD_INT 3
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: LIST
75990: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75991: LD_ADDR_VAR 0 27
75995: PUSH
75996: LD_INT 3
75998: NEG
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 3
76009: NEG
76010: PUSH
76011: LD_INT 1
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 4
76020: NEG
76021: PUSH
76022: LD_INT 1
76024: NEG
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: LIST
76034: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76035: LD_ADDR_VAR 0 28
76039: PUSH
76040: LD_INT 3
76042: NEG
76043: PUSH
76044: LD_INT 3
76046: NEG
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 3
76054: NEG
76055: PUSH
76056: LD_INT 4
76058: NEG
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 4
76066: NEG
76067: PUSH
76068: LD_INT 3
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: LIST
76080: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76081: LD_ADDR_VAR 0 29
76085: PUSH
76086: LD_INT 1
76088: NEG
76089: PUSH
76090: LD_INT 3
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 0
76100: PUSH
76101: LD_INT 3
76103: NEG
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 1
76111: PUSH
76112: LD_INT 2
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: NEG
76123: PUSH
76124: LD_INT 4
76126: NEG
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 0
76134: PUSH
76135: LD_INT 4
76137: NEG
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: LD_INT 3
76148: NEG
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 1
76156: NEG
76157: PUSH
76158: LD_INT 5
76160: NEG
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 0
76168: PUSH
76169: LD_INT 5
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 1
76179: PUSH
76180: LD_INT 4
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 1
76190: NEG
76191: PUSH
76192: LD_INT 6
76194: NEG
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: LD_INT 6
76205: NEG
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 1
76213: PUSH
76214: LD_INT 5
76216: NEG
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: LIST
76231: LIST
76232: LIST
76233: LIST
76234: LIST
76235: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76236: LD_ADDR_VAR 0 30
76240: PUSH
76241: LD_INT 2
76243: PUSH
76244: LD_INT 1
76246: NEG
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 3
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 3
76264: PUSH
76265: LD_INT 1
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 3
76274: PUSH
76275: LD_INT 1
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 4
76285: PUSH
76286: LD_INT 0
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 4
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 4
76305: PUSH
76306: LD_INT 1
76308: NEG
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 5
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 5
76326: PUSH
76327: LD_INT 1
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 5
76336: PUSH
76337: LD_INT 1
76339: NEG
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 6
76347: PUSH
76348: LD_INT 0
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 6
76357: PUSH
76358: LD_INT 1
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: LIST
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76379: LD_ADDR_VAR 0 31
76383: PUSH
76384: LD_INT 3
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 3
76396: PUSH
76397: LD_INT 3
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 2
76406: PUSH
76407: LD_INT 3
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 4
76416: PUSH
76417: LD_INT 3
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 4
76426: PUSH
76427: LD_INT 4
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 3
76436: PUSH
76437: LD_INT 4
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 5
76446: PUSH
76447: LD_INT 4
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 5
76456: PUSH
76457: LD_INT 5
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 4
76466: PUSH
76467: LD_INT 5
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 6
76476: PUSH
76477: LD_INT 5
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 6
76486: PUSH
76487: LD_INT 6
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 5
76496: PUSH
76497: LD_INT 6
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: LIST
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: LIST
76516: LIST
76517: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76518: LD_ADDR_VAR 0 32
76522: PUSH
76523: LD_INT 1
76525: PUSH
76526: LD_INT 3
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 0
76535: PUSH
76536: LD_INT 3
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: LD_INT 2
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 1
76556: PUSH
76557: LD_INT 4
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 0
76566: PUSH
76567: LD_INT 4
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 1
76576: NEG
76577: PUSH
76578: LD_INT 3
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 1
76587: PUSH
76588: LD_INT 5
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: LD_INT 5
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 1
76607: NEG
76608: PUSH
76609: LD_INT 4
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: PUSH
76619: LD_INT 6
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 0
76628: PUSH
76629: LD_INT 6
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 1
76638: NEG
76639: PUSH
76640: LD_INT 5
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76661: LD_ADDR_VAR 0 33
76665: PUSH
76666: LD_INT 2
76668: NEG
76669: PUSH
76670: LD_INT 1
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 3
76679: NEG
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 3
76690: NEG
76691: PUSH
76692: LD_INT 1
76694: NEG
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 3
76702: NEG
76703: PUSH
76704: LD_INT 1
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 4
76713: NEG
76714: PUSH
76715: LD_INT 0
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 4
76724: NEG
76725: PUSH
76726: LD_INT 1
76728: NEG
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 4
76736: NEG
76737: PUSH
76738: LD_INT 1
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 5
76747: NEG
76748: PUSH
76749: LD_INT 0
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 5
76758: NEG
76759: PUSH
76760: LD_INT 1
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 5
76770: NEG
76771: PUSH
76772: LD_INT 1
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 6
76781: NEG
76782: PUSH
76783: LD_INT 0
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 6
76792: NEG
76793: PUSH
76794: LD_INT 1
76796: NEG
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76816: LD_ADDR_VAR 0 34
76820: PUSH
76821: LD_INT 2
76823: NEG
76824: PUSH
76825: LD_INT 3
76827: NEG
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 3
76835: NEG
76836: PUSH
76837: LD_INT 2
76839: NEG
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 3
76847: NEG
76848: PUSH
76849: LD_INT 3
76851: NEG
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 3
76859: NEG
76860: PUSH
76861: LD_INT 4
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 4
76871: NEG
76872: PUSH
76873: LD_INT 3
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 4
76883: NEG
76884: PUSH
76885: LD_INT 4
76887: NEG
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 4
76895: NEG
76896: PUSH
76897: LD_INT 5
76899: NEG
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 5
76907: NEG
76908: PUSH
76909: LD_INT 4
76911: NEG
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 5
76919: NEG
76920: PUSH
76921: LD_INT 5
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 5
76931: NEG
76932: PUSH
76933: LD_INT 6
76935: NEG
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 6
76943: NEG
76944: PUSH
76945: LD_INT 5
76947: NEG
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 6
76955: NEG
76956: PUSH
76957: LD_INT 6
76959: NEG
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: LIST
76969: LIST
76970: LIST
76971: LIST
76972: LIST
76973: LIST
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76979: LD_ADDR_VAR 0 41
76983: PUSH
76984: LD_INT 0
76986: PUSH
76987: LD_INT 2
76989: NEG
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: LD_INT 1
76997: NEG
76998: PUSH
76999: LD_INT 3
77001: NEG
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 1
77009: PUSH
77010: LD_INT 2
77012: NEG
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: LIST
77022: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77023: LD_ADDR_VAR 0 42
77027: PUSH
77028: LD_INT 2
77030: PUSH
77031: LD_INT 0
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 2
77040: PUSH
77041: LD_INT 1
77043: NEG
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 3
77051: PUSH
77052: LD_INT 1
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: LIST
77063: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77064: LD_ADDR_VAR 0 43
77068: PUSH
77069: LD_INT 2
77071: PUSH
77072: LD_INT 2
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 3
77081: PUSH
77082: LD_INT 2
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 2
77091: PUSH
77092: LD_INT 3
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: LIST
77103: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77104: LD_ADDR_VAR 0 44
77108: PUSH
77109: LD_INT 0
77111: PUSH
77112: LD_INT 2
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: LD_INT 3
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 1
77131: NEG
77132: PUSH
77133: LD_INT 2
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: LIST
77144: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77145: LD_ADDR_VAR 0 45
77149: PUSH
77150: LD_INT 2
77152: NEG
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 2
77163: NEG
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 3
77174: NEG
77175: PUSH
77176: LD_INT 1
77178: NEG
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: LIST
77188: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77189: LD_ADDR_VAR 0 46
77193: PUSH
77194: LD_INT 2
77196: NEG
77197: PUSH
77198: LD_INT 2
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 2
77208: NEG
77209: PUSH
77210: LD_INT 3
77212: NEG
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 3
77220: NEG
77221: PUSH
77222: LD_INT 2
77224: NEG
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: LIST
77234: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77235: LD_ADDR_VAR 0 47
77239: PUSH
77240: LD_INT 2
77242: NEG
77243: PUSH
77244: LD_INT 3
77246: NEG
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 1
77254: NEG
77255: PUSH
77256: LD_INT 3
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77268: LD_ADDR_VAR 0 48
77272: PUSH
77273: LD_INT 1
77275: PUSH
77276: LD_INT 2
77278: NEG
77279: PUSH
77280: EMPTY
77281: LIST
77282: LIST
77283: PUSH
77284: LD_INT 2
77286: PUSH
77287: LD_INT 1
77289: NEG
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77299: LD_ADDR_VAR 0 49
77303: PUSH
77304: LD_INT 3
77306: PUSH
77307: LD_INT 1
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 3
77316: PUSH
77317: LD_INT 2
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77328: LD_ADDR_VAR 0 50
77332: PUSH
77333: LD_INT 2
77335: PUSH
77336: LD_INT 3
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: PUSH
77343: LD_INT 1
77345: PUSH
77346: LD_INT 3
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77357: LD_ADDR_VAR 0 51
77361: PUSH
77362: LD_INT 1
77364: NEG
77365: PUSH
77366: LD_INT 2
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 2
77375: NEG
77376: PUSH
77377: LD_INT 1
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77388: LD_ADDR_VAR 0 52
77392: PUSH
77393: LD_INT 3
77395: NEG
77396: PUSH
77397: LD_INT 1
77399: NEG
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 3
77407: NEG
77408: PUSH
77409: LD_INT 2
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77421: LD_ADDR_VAR 0 53
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: LD_INT 3
77432: NEG
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: LD_INT 3
77443: NEG
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 1
77451: PUSH
77452: LD_INT 2
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77465: LD_ADDR_VAR 0 54
77469: PUSH
77470: LD_INT 2
77472: PUSH
77473: LD_INT 1
77475: NEG
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 3
77483: PUSH
77484: LD_INT 0
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: LD_INT 3
77493: PUSH
77494: LD_INT 1
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: LIST
77505: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77506: LD_ADDR_VAR 0 55
77510: PUSH
77511: LD_INT 3
77513: PUSH
77514: LD_INT 2
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: LD_INT 3
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 2
77533: PUSH
77534: LD_INT 3
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: LIST
77545: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77546: LD_ADDR_VAR 0 56
77550: PUSH
77551: LD_INT 1
77553: PUSH
77554: LD_INT 3
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 0
77563: PUSH
77564: LD_INT 3
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 1
77573: NEG
77574: PUSH
77575: LD_INT 2
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: LIST
77586: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77587: LD_ADDR_VAR 0 57
77591: PUSH
77592: LD_INT 2
77594: NEG
77595: PUSH
77596: LD_INT 1
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 3
77605: NEG
77606: PUSH
77607: LD_INT 0
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 3
77616: NEG
77617: PUSH
77618: LD_INT 1
77620: NEG
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: LIST
77630: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77631: LD_ADDR_VAR 0 58
77635: PUSH
77636: LD_INT 2
77638: NEG
77639: PUSH
77640: LD_INT 3
77642: NEG
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 3
77650: NEG
77651: PUSH
77652: LD_INT 2
77654: NEG
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 3
77662: NEG
77663: PUSH
77664: LD_INT 3
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: LIST
77676: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77677: LD_ADDR_VAR 0 59
77681: PUSH
77682: LD_INT 1
77684: NEG
77685: PUSH
77686: LD_INT 2
77688: NEG
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 0
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: LIST
77720: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77721: LD_ADDR_VAR 0 60
77725: PUSH
77726: LD_INT 1
77728: PUSH
77729: LD_INT 1
77731: NEG
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 2
77739: PUSH
77740: LD_INT 0
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 2
77749: PUSH
77750: LD_INT 1
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: LIST
77761: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77762: LD_ADDR_VAR 0 61
77766: PUSH
77767: LD_INT 2
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 2
77779: PUSH
77780: LD_INT 2
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 1
77789: PUSH
77790: LD_INT 2
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: LIST
77801: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77802: LD_ADDR_VAR 0 62
77806: PUSH
77807: LD_INT 1
77809: PUSH
77810: LD_INT 2
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 0
77819: PUSH
77820: LD_INT 2
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 1
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: LIST
77842: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77843: LD_ADDR_VAR 0 63
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: LD_INT 1
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 2
77861: NEG
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 2
77872: NEG
77873: PUSH
77874: LD_INT 1
77876: NEG
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: LIST
77886: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77887: LD_ADDR_VAR 0 64
77891: PUSH
77892: LD_INT 1
77894: NEG
77895: PUSH
77896: LD_INT 2
77898: NEG
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 2
77906: NEG
77907: PUSH
77908: LD_INT 1
77910: NEG
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 2
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: LIST
77932: ST_TO_ADDR
// end ; 2 :
77933: GO 81199
77935: LD_INT 2
77937: DOUBLE
77938: EQUAL
77939: IFTRUE 77943
77941: GO 81198
77943: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77944: LD_ADDR_VAR 0 29
77948: PUSH
77949: LD_INT 4
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 4
77961: PUSH
77962: LD_INT 1
77964: NEG
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 5
77972: PUSH
77973: LD_INT 0
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 5
77982: PUSH
77983: LD_INT 1
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 4
77992: PUSH
77993: LD_INT 1
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 3
78002: PUSH
78003: LD_INT 0
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 3
78012: PUSH
78013: LD_INT 1
78015: NEG
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: LD_INT 2
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 5
78034: PUSH
78035: LD_INT 2
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 3
78044: PUSH
78045: LD_INT 3
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 3
78054: PUSH
78055: LD_INT 2
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 4
78064: PUSH
78065: LD_INT 3
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 4
78074: PUSH
78075: LD_INT 4
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 3
78084: PUSH
78085: LD_INT 4
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 2
78094: PUSH
78095: LD_INT 3
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 2
78104: PUSH
78105: LD_INT 2
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 4
78114: PUSH
78115: LD_INT 2
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 2
78124: PUSH
78125: LD_INT 4
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 0
78134: PUSH
78135: LD_INT 4
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 0
78144: PUSH
78145: LD_INT 3
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: LD_INT 1
78154: PUSH
78155: LD_INT 4
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: LD_INT 5
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: LD_INT 5
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 1
78184: NEG
78185: PUSH
78186: LD_INT 4
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 1
78195: NEG
78196: PUSH
78197: LD_INT 3
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 2
78206: PUSH
78207: LD_INT 5
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 2
78216: NEG
78217: PUSH
78218: LD_INT 3
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 3
78227: NEG
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 3
78238: NEG
78239: PUSH
78240: LD_INT 1
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 2
78250: NEG
78251: PUSH
78252: LD_INT 0
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 2
78261: NEG
78262: PUSH
78263: LD_INT 1
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 3
78272: NEG
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 4
78283: NEG
78284: PUSH
78285: LD_INT 0
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 4
78294: NEG
78295: PUSH
78296: LD_INT 1
78298: NEG
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 4
78306: NEG
78307: PUSH
78308: LD_INT 2
78310: NEG
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 2
78318: NEG
78319: PUSH
78320: LD_INT 2
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 4
78329: NEG
78330: PUSH
78331: LD_INT 4
78333: NEG
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 4
78341: NEG
78342: PUSH
78343: LD_INT 5
78345: NEG
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: LD_INT 4
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 3
78365: NEG
78366: PUSH
78367: LD_INT 3
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 4
78377: NEG
78378: PUSH
78379: LD_INT 3
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 5
78389: NEG
78390: PUSH
78391: LD_INT 4
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 5
78401: NEG
78402: PUSH
78403: LD_INT 5
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 3
78413: NEG
78414: PUSH
78415: LD_INT 5
78417: NEG
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 5
78425: NEG
78426: PUSH
78427: LD_INT 3
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: LIST
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: LIST
78476: LIST
78477: LIST
78478: LIST
78479: LIST
78480: LIST
78481: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78482: LD_ADDR_VAR 0 30
78486: PUSH
78487: LD_INT 4
78489: PUSH
78490: LD_INT 4
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 4
78499: PUSH
78500: LD_INT 3
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 5
78509: PUSH
78510: LD_INT 4
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 5
78519: PUSH
78520: LD_INT 5
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 4
78529: PUSH
78530: LD_INT 5
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 3
78539: PUSH
78540: LD_INT 4
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 3
78549: PUSH
78550: LD_INT 3
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 5
78559: PUSH
78560: LD_INT 3
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 3
78569: PUSH
78570: LD_INT 5
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 0
78579: PUSH
78580: LD_INT 3
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 0
78589: PUSH
78590: LD_INT 2
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: LD_INT 1
78599: PUSH
78600: LD_INT 3
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 1
78609: PUSH
78610: LD_INT 4
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 0
78619: PUSH
78620: LD_INT 4
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 1
78629: NEG
78630: PUSH
78631: LD_INT 3
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 1
78640: NEG
78641: PUSH
78642: LD_INT 2
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 2
78651: PUSH
78652: LD_INT 4
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 2
78661: NEG
78662: PUSH
78663: LD_INT 2
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 4
78672: NEG
78673: PUSH
78674: LD_INT 0
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 4
78683: NEG
78684: PUSH
78685: LD_INT 1
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 3
78695: NEG
78696: PUSH
78697: LD_INT 0
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 3
78706: NEG
78707: PUSH
78708: LD_INT 1
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 4
78717: NEG
78718: PUSH
78719: LD_INT 1
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 5
78728: NEG
78729: PUSH
78730: LD_INT 0
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 5
78739: NEG
78740: PUSH
78741: LD_INT 1
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 5
78751: NEG
78752: PUSH
78753: LD_INT 2
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 3
78763: NEG
78764: PUSH
78765: LD_INT 2
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: LD_INT 3
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 3
78786: NEG
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 2
78798: NEG
78799: PUSH
78800: LD_INT 3
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 2
78810: NEG
78811: PUSH
78812: LD_INT 2
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 3
78822: NEG
78823: PUSH
78824: LD_INT 2
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 4
78834: NEG
78835: PUSH
78836: LD_INT 3
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 4
78846: NEG
78847: PUSH
78848: LD_INT 4
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 2
78858: NEG
78859: PUSH
78860: LD_INT 4
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 4
78870: NEG
78871: PUSH
78872: LD_INT 2
78874: NEG
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 0
78882: PUSH
78883: LD_INT 4
78885: NEG
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 0
78893: PUSH
78894: LD_INT 5
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 1
78904: PUSH
78905: LD_INT 4
78907: NEG
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 1
78915: PUSH
78916: LD_INT 3
78918: NEG
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 0
78926: PUSH
78927: LD_INT 3
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 1
78937: NEG
78938: PUSH
78939: LD_INT 4
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 1
78949: NEG
78950: PUSH
78951: LD_INT 5
78953: NEG
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 2
78961: PUSH
78962: LD_INT 3
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 2
78972: NEG
78973: PUSH
78974: LD_INT 5
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79029: LD_ADDR_VAR 0 31
79033: PUSH
79034: LD_INT 0
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 0
79046: PUSH
79047: LD_INT 3
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: PUSH
79057: LD_INT 4
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: PUSH
79067: LD_INT 5
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 0
79076: PUSH
79077: LD_INT 5
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 1
79086: NEG
79087: PUSH
79088: LD_INT 4
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: LD_INT 3
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 2
79108: PUSH
79109: LD_INT 5
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 2
79118: NEG
79119: PUSH
79120: LD_INT 3
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 3
79129: NEG
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: NEG
79153: PUSH
79154: LD_INT 0
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 2
79163: NEG
79164: PUSH
79165: LD_INT 1
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 3
79174: NEG
79175: PUSH
79176: LD_INT 1
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 4
79185: NEG
79186: PUSH
79187: LD_INT 0
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 4
79196: NEG
79197: PUSH
79198: LD_INT 1
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 4
79208: NEG
79209: PUSH
79210: LD_INT 2
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 2
79220: NEG
79221: PUSH
79222: LD_INT 2
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 4
79231: NEG
79232: PUSH
79233: LD_INT 4
79235: NEG
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 4
79243: NEG
79244: PUSH
79245: LD_INT 5
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 3
79255: NEG
79256: PUSH
79257: LD_INT 4
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 3
79267: NEG
79268: PUSH
79269: LD_INT 3
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 4
79279: NEG
79280: PUSH
79281: LD_INT 3
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 5
79291: NEG
79292: PUSH
79293: LD_INT 4
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 5
79303: NEG
79304: PUSH
79305: LD_INT 5
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 3
79315: NEG
79316: PUSH
79317: LD_INT 5
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 5
79327: NEG
79328: PUSH
79329: LD_INT 3
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: LD_INT 3
79342: NEG
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PUSH
79348: LD_INT 0
79350: PUSH
79351: LD_INT 4
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 1
79361: PUSH
79362: LD_INT 3
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 1
79372: PUSH
79373: LD_INT 2
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 0
79383: PUSH
79384: LD_INT 2
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: LD_INT 3
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 1
79406: NEG
79407: PUSH
79408: LD_INT 4
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 2
79418: PUSH
79419: LD_INT 2
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 2
79429: NEG
79430: PUSH
79431: LD_INT 4
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 4
79441: PUSH
79442: LD_INT 0
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 4
79451: PUSH
79452: LD_INT 1
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 5
79462: PUSH
79463: LD_INT 0
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 5
79472: PUSH
79473: LD_INT 1
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 4
79482: PUSH
79483: LD_INT 1
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 3
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 3
79502: PUSH
79503: LD_INT 1
79505: NEG
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 3
79513: PUSH
79514: LD_INT 2
79516: NEG
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 5
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: LIST
79576: LIST
79577: LIST
79578: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79579: LD_ADDR_VAR 0 32
79583: PUSH
79584: LD_INT 4
79586: NEG
79587: PUSH
79588: LD_INT 0
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 4
79597: NEG
79598: PUSH
79599: LD_INT 1
79601: NEG
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 3
79609: NEG
79610: PUSH
79611: LD_INT 0
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 3
79620: NEG
79621: PUSH
79622: LD_INT 1
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 4
79631: NEG
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 5
79642: NEG
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 5
79653: NEG
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 5
79665: NEG
79666: PUSH
79667: LD_INT 2
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 3
79677: NEG
79678: PUSH
79679: LD_INT 2
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 3
79688: NEG
79689: PUSH
79690: LD_INT 3
79692: NEG
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: LD_INT 4
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: LD_INT 3
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 2
79724: NEG
79725: PUSH
79726: LD_INT 2
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: LD_INT 2
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 4
79748: NEG
79749: PUSH
79750: LD_INT 3
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 4
79760: NEG
79761: PUSH
79762: LD_INT 4
79764: NEG
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 2
79772: NEG
79773: PUSH
79774: LD_INT 4
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 4
79784: NEG
79785: PUSH
79786: LD_INT 2
79788: NEG
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 0
79796: PUSH
79797: LD_INT 4
79799: NEG
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 0
79807: PUSH
79808: LD_INT 5
79810: NEG
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: LD_INT 4
79821: NEG
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 1
79829: PUSH
79830: LD_INT 3
79832: NEG
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 0
79840: PUSH
79841: LD_INT 3
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: NEG
79852: PUSH
79853: LD_INT 4
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: NEG
79864: PUSH
79865: LD_INT 5
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 2
79875: PUSH
79876: LD_INT 3
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 2
79886: NEG
79887: PUSH
79888: LD_INT 5
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 3
79898: PUSH
79899: LD_INT 0
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 1
79911: NEG
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 4
79919: PUSH
79920: LD_INT 0
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 4
79929: PUSH
79930: LD_INT 1
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 3
79939: PUSH
79940: LD_INT 1
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 2
79949: PUSH
79950: LD_INT 0
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 2
79970: PUSH
79971: LD_INT 2
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 4
79981: PUSH
79982: LD_INT 2
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 4
79991: PUSH
79992: LD_INT 4
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 4
80001: PUSH
80002: LD_INT 3
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 5
80011: PUSH
80012: LD_INT 4
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 5
80021: PUSH
80022: LD_INT 5
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 4
80031: PUSH
80032: LD_INT 5
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 3
80041: PUSH
80042: LD_INT 4
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 3
80051: PUSH
80052: LD_INT 3
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 5
80061: PUSH
80062: LD_INT 3
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 3
80071: PUSH
80072: LD_INT 5
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80126: LD_ADDR_VAR 0 33
80130: PUSH
80131: LD_INT 4
80133: NEG
80134: PUSH
80135: LD_INT 4
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 4
80145: NEG
80146: PUSH
80147: LD_INT 5
80149: NEG
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 3
80157: NEG
80158: PUSH
80159: LD_INT 4
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 3
80169: NEG
80170: PUSH
80171: LD_INT 3
80173: NEG
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 4
80181: NEG
80182: PUSH
80183: LD_INT 3
80185: NEG
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 5
80193: NEG
80194: PUSH
80195: LD_INT 4
80197: NEG
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 5
80205: NEG
80206: PUSH
80207: LD_INT 5
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 3
80217: NEG
80218: PUSH
80219: LD_INT 5
80221: NEG
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 5
80229: NEG
80230: PUSH
80231: LD_INT 3
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 0
80241: PUSH
80242: LD_INT 3
80244: NEG
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 0
80252: PUSH
80253: LD_INT 4
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: LD_INT 3
80266: NEG
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: LD_INT 2
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: LD_INT 3
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 1
80308: NEG
80309: PUSH
80310: LD_INT 4
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: PUSH
80321: LD_INT 2
80323: NEG
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 2
80331: NEG
80332: PUSH
80333: LD_INT 4
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 4
80343: PUSH
80344: LD_INT 0
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 4
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 5
80364: PUSH
80365: LD_INT 0
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 5
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 4
80384: PUSH
80385: LD_INT 1
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 3
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 3
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 3
80415: PUSH
80416: LD_INT 2
80418: NEG
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 5
80426: PUSH
80427: LD_INT 2
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 3
80436: PUSH
80437: LD_INT 3
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 3
80446: PUSH
80447: LD_INT 2
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 4
80456: PUSH
80457: LD_INT 3
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: PUSH
80464: LD_INT 4
80466: PUSH
80467: LD_INT 4
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 3
80476: PUSH
80477: LD_INT 4
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: LD_INT 3
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 2
80496: PUSH
80497: LD_INT 2
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 4
80506: PUSH
80507: LD_INT 2
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 2
80516: PUSH
80517: LD_INT 4
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: LD_INT 4
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 0
80536: PUSH
80537: LD_INT 3
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 1
80546: PUSH
80547: LD_INT 4
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 1
80556: PUSH
80557: LD_INT 5
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 0
80566: PUSH
80567: LD_INT 5
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: LD_INT 4
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 1
80587: NEG
80588: PUSH
80589: LD_INT 3
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 2
80598: PUSH
80599: LD_INT 5
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 2
80608: NEG
80609: PUSH
80610: LD_INT 3
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80664: LD_ADDR_VAR 0 34
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: LD_INT 4
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 0
80682: PUSH
80683: LD_INT 5
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 1
80693: PUSH
80694: LD_INT 4
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 1
80704: PUSH
80705: LD_INT 3
80707: NEG
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 0
80715: PUSH
80716: LD_INT 3
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 1
80726: NEG
80727: PUSH
80728: LD_INT 4
80730: NEG
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 1
80738: NEG
80739: PUSH
80740: LD_INT 5
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 2
80750: PUSH
80751: LD_INT 3
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 2
80761: NEG
80762: PUSH
80763: LD_INT 5
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 3
80773: PUSH
80774: LD_INT 0
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 3
80783: PUSH
80784: LD_INT 1
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 4
80794: PUSH
80795: LD_INT 0
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 4
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 3
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: LD_INT 0
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 2
80834: PUSH
80835: LD_INT 1
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 2
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 4
80856: PUSH
80857: LD_INT 2
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 4
80866: PUSH
80867: LD_INT 4
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 4
80876: PUSH
80877: LD_INT 3
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 5
80886: PUSH
80887: LD_INT 4
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 5
80896: PUSH
80897: LD_INT 5
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 4
80906: PUSH
80907: LD_INT 5
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 3
80916: PUSH
80917: LD_INT 4
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 3
80926: PUSH
80927: LD_INT 3
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 5
80936: PUSH
80937: LD_INT 3
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 3
80946: PUSH
80947: LD_INT 5
80949: PUSH
80950: EMPTY
80951: LIST
80952: LIST
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: LD_INT 3
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: LD_INT 2
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 3
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: LD_INT 4
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 4
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: NEG
81007: PUSH
81008: LD_INT 3
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 2
81028: PUSH
81029: LD_INT 4
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 2
81038: NEG
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 4
81049: NEG
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 4
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: NEG
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 3
81072: NEG
81073: PUSH
81074: LD_INT 0
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 3
81083: NEG
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 4
81094: NEG
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 5
81105: NEG
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 5
81116: NEG
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 5
81128: NEG
81129: PUSH
81130: LD_INT 2
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 3
81140: NEG
81141: PUSH
81142: LD_INT 2
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: ST_TO_ADDR
// end ; end ;
81196: GO 81199
81198: POP
// case btype of b_depot , b_warehouse :
81199: LD_VAR 0 1
81203: PUSH
81204: LD_INT 0
81206: DOUBLE
81207: EQUAL
81208: IFTRUE 81218
81210: LD_INT 1
81212: DOUBLE
81213: EQUAL
81214: IFTRUE 81218
81216: GO 81419
81218: POP
// case nation of nation_american :
81219: LD_VAR 0 5
81223: PUSH
81224: LD_INT 1
81226: DOUBLE
81227: EQUAL
81228: IFTRUE 81232
81230: GO 81288
81232: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81233: LD_ADDR_VAR 0 9
81237: PUSH
81238: LD_VAR 0 11
81242: PUSH
81243: LD_VAR 0 12
81247: PUSH
81248: LD_VAR 0 13
81252: PUSH
81253: LD_VAR 0 14
81257: PUSH
81258: LD_VAR 0 15
81262: PUSH
81263: LD_VAR 0 16
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: PUSH
81276: LD_VAR 0 4
81280: PUSH
81281: LD_INT 1
81283: PLUS
81284: ARRAY
81285: ST_TO_ADDR
81286: GO 81417
81288: LD_INT 2
81290: DOUBLE
81291: EQUAL
81292: IFTRUE 81296
81294: GO 81352
81296: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81297: LD_ADDR_VAR 0 9
81301: PUSH
81302: LD_VAR 0 17
81306: PUSH
81307: LD_VAR 0 18
81311: PUSH
81312: LD_VAR 0 19
81316: PUSH
81317: LD_VAR 0 20
81321: PUSH
81322: LD_VAR 0 21
81326: PUSH
81327: LD_VAR 0 22
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: PUSH
81340: LD_VAR 0 4
81344: PUSH
81345: LD_INT 1
81347: PLUS
81348: ARRAY
81349: ST_TO_ADDR
81350: GO 81417
81352: LD_INT 3
81354: DOUBLE
81355: EQUAL
81356: IFTRUE 81360
81358: GO 81416
81360: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81361: LD_ADDR_VAR 0 9
81365: PUSH
81366: LD_VAR 0 23
81370: PUSH
81371: LD_VAR 0 24
81375: PUSH
81376: LD_VAR 0 25
81380: PUSH
81381: LD_VAR 0 26
81385: PUSH
81386: LD_VAR 0 27
81390: PUSH
81391: LD_VAR 0 28
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: PUSH
81404: LD_VAR 0 4
81408: PUSH
81409: LD_INT 1
81411: PLUS
81412: ARRAY
81413: ST_TO_ADDR
81414: GO 81417
81416: POP
81417: GO 81972
81419: LD_INT 2
81421: DOUBLE
81422: EQUAL
81423: IFTRUE 81433
81425: LD_INT 3
81427: DOUBLE
81428: EQUAL
81429: IFTRUE 81433
81431: GO 81489
81433: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81434: LD_ADDR_VAR 0 9
81438: PUSH
81439: LD_VAR 0 29
81443: PUSH
81444: LD_VAR 0 30
81448: PUSH
81449: LD_VAR 0 31
81453: PUSH
81454: LD_VAR 0 32
81458: PUSH
81459: LD_VAR 0 33
81463: PUSH
81464: LD_VAR 0 34
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: PUSH
81477: LD_VAR 0 4
81481: PUSH
81482: LD_INT 1
81484: PLUS
81485: ARRAY
81486: ST_TO_ADDR
81487: GO 81972
81489: LD_INT 16
81491: DOUBLE
81492: EQUAL
81493: IFTRUE 81551
81495: LD_INT 17
81497: DOUBLE
81498: EQUAL
81499: IFTRUE 81551
81501: LD_INT 18
81503: DOUBLE
81504: EQUAL
81505: IFTRUE 81551
81507: LD_INT 19
81509: DOUBLE
81510: EQUAL
81511: IFTRUE 81551
81513: LD_INT 22
81515: DOUBLE
81516: EQUAL
81517: IFTRUE 81551
81519: LD_INT 20
81521: DOUBLE
81522: EQUAL
81523: IFTRUE 81551
81525: LD_INT 21
81527: DOUBLE
81528: EQUAL
81529: IFTRUE 81551
81531: LD_INT 23
81533: DOUBLE
81534: EQUAL
81535: IFTRUE 81551
81537: LD_INT 24
81539: DOUBLE
81540: EQUAL
81541: IFTRUE 81551
81543: LD_INT 25
81545: DOUBLE
81546: EQUAL
81547: IFTRUE 81551
81549: GO 81607
81551: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81552: LD_ADDR_VAR 0 9
81556: PUSH
81557: LD_VAR 0 35
81561: PUSH
81562: LD_VAR 0 36
81566: PUSH
81567: LD_VAR 0 37
81571: PUSH
81572: LD_VAR 0 38
81576: PUSH
81577: LD_VAR 0 39
81581: PUSH
81582: LD_VAR 0 40
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: PUSH
81595: LD_VAR 0 4
81599: PUSH
81600: LD_INT 1
81602: PLUS
81603: ARRAY
81604: ST_TO_ADDR
81605: GO 81972
81607: LD_INT 6
81609: DOUBLE
81610: EQUAL
81611: IFTRUE 81663
81613: LD_INT 7
81615: DOUBLE
81616: EQUAL
81617: IFTRUE 81663
81619: LD_INT 8
81621: DOUBLE
81622: EQUAL
81623: IFTRUE 81663
81625: LD_INT 13
81627: DOUBLE
81628: EQUAL
81629: IFTRUE 81663
81631: LD_INT 12
81633: DOUBLE
81634: EQUAL
81635: IFTRUE 81663
81637: LD_INT 15
81639: DOUBLE
81640: EQUAL
81641: IFTRUE 81663
81643: LD_INT 11
81645: DOUBLE
81646: EQUAL
81647: IFTRUE 81663
81649: LD_INT 14
81651: DOUBLE
81652: EQUAL
81653: IFTRUE 81663
81655: LD_INT 10
81657: DOUBLE
81658: EQUAL
81659: IFTRUE 81663
81661: GO 81719
81663: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81664: LD_ADDR_VAR 0 9
81668: PUSH
81669: LD_VAR 0 41
81673: PUSH
81674: LD_VAR 0 42
81678: PUSH
81679: LD_VAR 0 43
81683: PUSH
81684: LD_VAR 0 44
81688: PUSH
81689: LD_VAR 0 45
81693: PUSH
81694: LD_VAR 0 46
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: PUSH
81707: LD_VAR 0 4
81711: PUSH
81712: LD_INT 1
81714: PLUS
81715: ARRAY
81716: ST_TO_ADDR
81717: GO 81972
81719: LD_INT 36
81721: DOUBLE
81722: EQUAL
81723: IFTRUE 81727
81725: GO 81783
81727: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81728: LD_ADDR_VAR 0 9
81732: PUSH
81733: LD_VAR 0 47
81737: PUSH
81738: LD_VAR 0 48
81742: PUSH
81743: LD_VAR 0 49
81747: PUSH
81748: LD_VAR 0 50
81752: PUSH
81753: LD_VAR 0 51
81757: PUSH
81758: LD_VAR 0 52
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: PUSH
81771: LD_VAR 0 4
81775: PUSH
81776: LD_INT 1
81778: PLUS
81779: ARRAY
81780: ST_TO_ADDR
81781: GO 81972
81783: LD_INT 4
81785: DOUBLE
81786: EQUAL
81787: IFTRUE 81809
81789: LD_INT 5
81791: DOUBLE
81792: EQUAL
81793: IFTRUE 81809
81795: LD_INT 34
81797: DOUBLE
81798: EQUAL
81799: IFTRUE 81809
81801: LD_INT 37
81803: DOUBLE
81804: EQUAL
81805: IFTRUE 81809
81807: GO 81865
81809: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81810: LD_ADDR_VAR 0 9
81814: PUSH
81815: LD_VAR 0 53
81819: PUSH
81820: LD_VAR 0 54
81824: PUSH
81825: LD_VAR 0 55
81829: PUSH
81830: LD_VAR 0 56
81834: PUSH
81835: LD_VAR 0 57
81839: PUSH
81840: LD_VAR 0 58
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: PUSH
81853: LD_VAR 0 4
81857: PUSH
81858: LD_INT 1
81860: PLUS
81861: ARRAY
81862: ST_TO_ADDR
81863: GO 81972
81865: LD_INT 31
81867: DOUBLE
81868: EQUAL
81869: IFTRUE 81915
81871: LD_INT 32
81873: DOUBLE
81874: EQUAL
81875: IFTRUE 81915
81877: LD_INT 33
81879: DOUBLE
81880: EQUAL
81881: IFTRUE 81915
81883: LD_INT 27
81885: DOUBLE
81886: EQUAL
81887: IFTRUE 81915
81889: LD_INT 26
81891: DOUBLE
81892: EQUAL
81893: IFTRUE 81915
81895: LD_INT 28
81897: DOUBLE
81898: EQUAL
81899: IFTRUE 81915
81901: LD_INT 29
81903: DOUBLE
81904: EQUAL
81905: IFTRUE 81915
81907: LD_INT 30
81909: DOUBLE
81910: EQUAL
81911: IFTRUE 81915
81913: GO 81971
81915: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81916: LD_ADDR_VAR 0 9
81920: PUSH
81921: LD_VAR 0 59
81925: PUSH
81926: LD_VAR 0 60
81930: PUSH
81931: LD_VAR 0 61
81935: PUSH
81936: LD_VAR 0 62
81940: PUSH
81941: LD_VAR 0 63
81945: PUSH
81946: LD_VAR 0 64
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: PUSH
81959: LD_VAR 0 4
81963: PUSH
81964: LD_INT 1
81966: PLUS
81967: ARRAY
81968: ST_TO_ADDR
81969: GO 81972
81971: POP
// temp_list2 = [ ] ;
81972: LD_ADDR_VAR 0 10
81976: PUSH
81977: EMPTY
81978: ST_TO_ADDR
// for i in temp_list do
81979: LD_ADDR_VAR 0 8
81983: PUSH
81984: LD_VAR 0 9
81988: PUSH
81989: FOR_IN
81990: IFFALSE 82042
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81992: LD_ADDR_VAR 0 10
81996: PUSH
81997: LD_VAR 0 10
82001: PUSH
82002: LD_VAR 0 8
82006: PUSH
82007: LD_INT 1
82009: ARRAY
82010: PUSH
82011: LD_VAR 0 2
82015: PLUS
82016: PUSH
82017: LD_VAR 0 8
82021: PUSH
82022: LD_INT 2
82024: ARRAY
82025: PUSH
82026: LD_VAR 0 3
82030: PLUS
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: EMPTY
82037: LIST
82038: ADD
82039: ST_TO_ADDR
82040: GO 81989
82042: POP
82043: POP
// result = temp_list2 ;
82044: LD_ADDR_VAR 0 7
82048: PUSH
82049: LD_VAR 0 10
82053: ST_TO_ADDR
// end ;
82054: LD_VAR 0 7
82058: RET
// export function EnemyInRange ( unit , dist ) ; begin
82059: LD_INT 0
82061: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82062: LD_ADDR_VAR 0 3
82066: PUSH
82067: LD_VAR 0 1
82071: PPUSH
82072: CALL_OW 255
82076: PPUSH
82077: LD_VAR 0 1
82081: PPUSH
82082: CALL_OW 250
82086: PPUSH
82087: LD_VAR 0 1
82091: PPUSH
82092: CALL_OW 251
82096: PPUSH
82097: LD_VAR 0 2
82101: PPUSH
82102: CALL 55432 0 4
82106: PUSH
82107: LD_INT 4
82109: ARRAY
82110: ST_TO_ADDR
// end ;
82111: LD_VAR 0 3
82115: RET
// export function PlayerSeeMe ( unit ) ; begin
82116: LD_INT 0
82118: PPUSH
// result := See ( your_side , unit ) ;
82119: LD_ADDR_VAR 0 2
82123: PUSH
82124: LD_OWVAR 2
82128: PPUSH
82129: LD_VAR 0 1
82133: PPUSH
82134: CALL_OW 292
82138: ST_TO_ADDR
// end ;
82139: LD_VAR 0 2
82143: RET
// export function ReverseDir ( unit ) ; begin
82144: LD_INT 0
82146: PPUSH
// if not unit then
82147: LD_VAR 0 1
82151: NOT
82152: IFFALSE 82156
// exit ;
82154: GO 82179
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82156: LD_ADDR_VAR 0 2
82160: PUSH
82161: LD_VAR 0 1
82165: PPUSH
82166: CALL_OW 254
82170: PUSH
82171: LD_INT 3
82173: PLUS
82174: PUSH
82175: LD_INT 6
82177: MOD
82178: ST_TO_ADDR
// end ;
82179: LD_VAR 0 2
82183: RET
// export function ReverseArray ( array ) ; var i ; begin
82184: LD_INT 0
82186: PPUSH
82187: PPUSH
// if not array then
82188: LD_VAR 0 1
82192: NOT
82193: IFFALSE 82197
// exit ;
82195: GO 82252
// result := [ ] ;
82197: LD_ADDR_VAR 0 2
82201: PUSH
82202: EMPTY
82203: ST_TO_ADDR
// for i := array downto 1 do
82204: LD_ADDR_VAR 0 3
82208: PUSH
82209: DOUBLE
82210: LD_VAR 0 1
82214: INC
82215: ST_TO_ADDR
82216: LD_INT 1
82218: PUSH
82219: FOR_DOWNTO
82220: IFFALSE 82250
// result := Join ( result , array [ i ] ) ;
82222: LD_ADDR_VAR 0 2
82226: PUSH
82227: LD_VAR 0 2
82231: PPUSH
82232: LD_VAR 0 1
82236: PUSH
82237: LD_VAR 0 3
82241: ARRAY
82242: PPUSH
82243: CALL 86917 0 2
82247: ST_TO_ADDR
82248: GO 82219
82250: POP
82251: POP
// end ;
82252: LD_VAR 0 2
82256: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82257: LD_INT 0
82259: PPUSH
82260: PPUSH
82261: PPUSH
82262: PPUSH
82263: PPUSH
82264: PPUSH
// if not unit or not hexes then
82265: LD_VAR 0 1
82269: NOT
82270: PUSH
82271: LD_VAR 0 2
82275: NOT
82276: OR
82277: IFFALSE 82281
// exit ;
82279: GO 82404
// dist := 9999 ;
82281: LD_ADDR_VAR 0 5
82285: PUSH
82286: LD_INT 9999
82288: ST_TO_ADDR
// for i = 1 to hexes do
82289: LD_ADDR_VAR 0 4
82293: PUSH
82294: DOUBLE
82295: LD_INT 1
82297: DEC
82298: ST_TO_ADDR
82299: LD_VAR 0 2
82303: PUSH
82304: FOR_TO
82305: IFFALSE 82392
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82307: LD_ADDR_VAR 0 6
82311: PUSH
82312: LD_VAR 0 1
82316: PPUSH
82317: LD_VAR 0 2
82321: PUSH
82322: LD_VAR 0 4
82326: ARRAY
82327: PUSH
82328: LD_INT 1
82330: ARRAY
82331: PPUSH
82332: LD_VAR 0 2
82336: PUSH
82337: LD_VAR 0 4
82341: ARRAY
82342: PUSH
82343: LD_INT 2
82345: ARRAY
82346: PPUSH
82347: CALL_OW 297
82351: ST_TO_ADDR
// if tdist < dist then
82352: LD_VAR 0 6
82356: PUSH
82357: LD_VAR 0 5
82361: LESS
82362: IFFALSE 82390
// begin hex := hexes [ i ] ;
82364: LD_ADDR_VAR 0 8
82368: PUSH
82369: LD_VAR 0 2
82373: PUSH
82374: LD_VAR 0 4
82378: ARRAY
82379: ST_TO_ADDR
// dist := tdist ;
82380: LD_ADDR_VAR 0 5
82384: PUSH
82385: LD_VAR 0 6
82389: ST_TO_ADDR
// end ; end ;
82390: GO 82304
82392: POP
82393: POP
// result := hex ;
82394: LD_ADDR_VAR 0 3
82398: PUSH
82399: LD_VAR 0 8
82403: ST_TO_ADDR
// end ;
82404: LD_VAR 0 3
82408: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82409: LD_INT 0
82411: PPUSH
82412: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82413: LD_VAR 0 1
82417: NOT
82418: PUSH
82419: LD_VAR 0 1
82423: PUSH
82424: LD_INT 21
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 23
82436: PUSH
82437: LD_INT 2
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PPUSH
82448: CALL_OW 69
82452: IN
82453: NOT
82454: OR
82455: IFFALSE 82459
// exit ;
82457: GO 82506
// for i = 1 to 3 do
82459: LD_ADDR_VAR 0 3
82463: PUSH
82464: DOUBLE
82465: LD_INT 1
82467: DEC
82468: ST_TO_ADDR
82469: LD_INT 3
82471: PUSH
82472: FOR_TO
82473: IFFALSE 82504
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82475: LD_VAR 0 1
82479: PPUSH
82480: CALL_OW 250
82484: PPUSH
82485: LD_VAR 0 1
82489: PPUSH
82490: CALL_OW 251
82494: PPUSH
82495: LD_INT 1
82497: PPUSH
82498: CALL_OW 453
82502: GO 82472
82504: POP
82505: POP
// end ;
82506: LD_VAR 0 2
82510: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82511: LD_INT 0
82513: PPUSH
82514: PPUSH
82515: PPUSH
82516: PPUSH
82517: PPUSH
82518: PPUSH
// if not unit or not enemy_unit then
82519: LD_VAR 0 1
82523: NOT
82524: PUSH
82525: LD_VAR 0 2
82529: NOT
82530: OR
82531: IFFALSE 82535
// exit ;
82533: GO 83002
// if GetLives ( i ) < 250 then
82535: LD_VAR 0 4
82539: PPUSH
82540: CALL_OW 256
82544: PUSH
82545: LD_INT 250
82547: LESS
82548: IFFALSE 82561
// begin ComAutodestruct ( i ) ;
82550: LD_VAR 0 4
82554: PPUSH
82555: CALL 82409 0 1
// exit ;
82559: GO 83002
// end ; x := GetX ( enemy_unit ) ;
82561: LD_ADDR_VAR 0 7
82565: PUSH
82566: LD_VAR 0 2
82570: PPUSH
82571: CALL_OW 250
82575: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82576: LD_ADDR_VAR 0 8
82580: PUSH
82581: LD_VAR 0 2
82585: PPUSH
82586: CALL_OW 251
82590: ST_TO_ADDR
// if not x or not y then
82591: LD_VAR 0 7
82595: NOT
82596: PUSH
82597: LD_VAR 0 8
82601: NOT
82602: OR
82603: IFFALSE 82607
// exit ;
82605: GO 83002
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82607: LD_ADDR_VAR 0 6
82611: PUSH
82612: LD_VAR 0 7
82616: PPUSH
82617: LD_INT 0
82619: PPUSH
82620: LD_INT 4
82622: PPUSH
82623: CALL_OW 272
82627: PUSH
82628: LD_VAR 0 8
82632: PPUSH
82633: LD_INT 0
82635: PPUSH
82636: LD_INT 4
82638: PPUSH
82639: CALL_OW 273
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_VAR 0 7
82652: PPUSH
82653: LD_INT 1
82655: PPUSH
82656: LD_INT 4
82658: PPUSH
82659: CALL_OW 272
82663: PUSH
82664: LD_VAR 0 8
82668: PPUSH
82669: LD_INT 1
82671: PPUSH
82672: LD_INT 4
82674: PPUSH
82675: CALL_OW 273
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_VAR 0 7
82688: PPUSH
82689: LD_INT 2
82691: PPUSH
82692: LD_INT 4
82694: PPUSH
82695: CALL_OW 272
82699: PUSH
82700: LD_VAR 0 8
82704: PPUSH
82705: LD_INT 2
82707: PPUSH
82708: LD_INT 4
82710: PPUSH
82711: CALL_OW 273
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_VAR 0 7
82724: PPUSH
82725: LD_INT 3
82727: PPUSH
82728: LD_INT 4
82730: PPUSH
82731: CALL_OW 272
82735: PUSH
82736: LD_VAR 0 8
82740: PPUSH
82741: LD_INT 3
82743: PPUSH
82744: LD_INT 4
82746: PPUSH
82747: CALL_OW 273
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_VAR 0 7
82760: PPUSH
82761: LD_INT 4
82763: PPUSH
82764: LD_INT 4
82766: PPUSH
82767: CALL_OW 272
82771: PUSH
82772: LD_VAR 0 8
82776: PPUSH
82777: LD_INT 4
82779: PPUSH
82780: LD_INT 4
82782: PPUSH
82783: CALL_OW 273
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_VAR 0 7
82796: PPUSH
82797: LD_INT 5
82799: PPUSH
82800: LD_INT 4
82802: PPUSH
82803: CALL_OW 272
82807: PUSH
82808: LD_VAR 0 8
82812: PPUSH
82813: LD_INT 5
82815: PPUSH
82816: LD_INT 4
82818: PPUSH
82819: CALL_OW 273
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: ST_TO_ADDR
// for i = tmp downto 1 do
82836: LD_ADDR_VAR 0 4
82840: PUSH
82841: DOUBLE
82842: LD_VAR 0 6
82846: INC
82847: ST_TO_ADDR
82848: LD_INT 1
82850: PUSH
82851: FOR_DOWNTO
82852: IFFALSE 82953
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82854: LD_VAR 0 6
82858: PUSH
82859: LD_VAR 0 4
82863: ARRAY
82864: PUSH
82865: LD_INT 1
82867: ARRAY
82868: PPUSH
82869: LD_VAR 0 6
82873: PUSH
82874: LD_VAR 0 4
82878: ARRAY
82879: PUSH
82880: LD_INT 2
82882: ARRAY
82883: PPUSH
82884: CALL_OW 488
82888: NOT
82889: PUSH
82890: LD_VAR 0 6
82894: PUSH
82895: LD_VAR 0 4
82899: ARRAY
82900: PUSH
82901: LD_INT 1
82903: ARRAY
82904: PPUSH
82905: LD_VAR 0 6
82909: PUSH
82910: LD_VAR 0 4
82914: ARRAY
82915: PUSH
82916: LD_INT 2
82918: ARRAY
82919: PPUSH
82920: CALL_OW 428
82924: PUSH
82925: LD_INT 0
82927: NONEQUAL
82928: OR
82929: IFFALSE 82951
// tmp := Delete ( tmp , i ) ;
82931: LD_ADDR_VAR 0 6
82935: PUSH
82936: LD_VAR 0 6
82940: PPUSH
82941: LD_VAR 0 4
82945: PPUSH
82946: CALL_OW 3
82950: ST_TO_ADDR
82951: GO 82851
82953: POP
82954: POP
// j := GetClosestHex ( unit , tmp ) ;
82955: LD_ADDR_VAR 0 5
82959: PUSH
82960: LD_VAR 0 1
82964: PPUSH
82965: LD_VAR 0 6
82969: PPUSH
82970: CALL 82257 0 2
82974: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82975: LD_VAR 0 1
82979: PPUSH
82980: LD_VAR 0 5
82984: PUSH
82985: LD_INT 1
82987: ARRAY
82988: PPUSH
82989: LD_VAR 0 5
82993: PUSH
82994: LD_INT 2
82996: ARRAY
82997: PPUSH
82998: CALL_OW 111
// end ;
83002: LD_VAR 0 3
83006: RET
// export function PrepareApemanSoldier ( ) ; begin
83007: LD_INT 0
83009: PPUSH
// uc_nation := 0 ;
83010: LD_ADDR_OWVAR 21
83014: PUSH
83015: LD_INT 0
83017: ST_TO_ADDR
// hc_sex := sex_male ;
83018: LD_ADDR_OWVAR 27
83022: PUSH
83023: LD_INT 1
83025: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
83026: LD_ADDR_OWVAR 28
83030: PUSH
83031: LD_INT 15
83033: ST_TO_ADDR
// hc_gallery :=  ;
83034: LD_ADDR_OWVAR 33
83038: PUSH
83039: LD_STRING 
83041: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83042: LD_ADDR_OWVAR 31
83046: PUSH
83047: LD_INT 0
83049: PPUSH
83050: LD_INT 3
83052: PPUSH
83053: CALL_OW 12
83057: PUSH
83058: LD_INT 0
83060: PPUSH
83061: LD_INT 3
83063: PPUSH
83064: CALL_OW 12
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: LD_INT 0
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: ST_TO_ADDR
// end ;
83081: LD_VAR 0 1
83085: RET
// export function PrepareApemanEngineer ( ) ; begin
83086: LD_INT 0
83088: PPUSH
// uc_nation := 0 ;
83089: LD_ADDR_OWVAR 21
83093: PUSH
83094: LD_INT 0
83096: ST_TO_ADDR
// hc_sex := sex_male ;
83097: LD_ADDR_OWVAR 27
83101: PUSH
83102: LD_INT 1
83104: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83105: LD_ADDR_OWVAR 28
83109: PUSH
83110: LD_INT 16
83112: ST_TO_ADDR
// hc_gallery :=  ;
83113: LD_ADDR_OWVAR 33
83117: PUSH
83118: LD_STRING 
83120: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83121: LD_ADDR_OWVAR 31
83125: PUSH
83126: LD_INT 0
83128: PPUSH
83129: LD_INT 3
83131: PPUSH
83132: CALL_OW 12
83136: PUSH
83137: LD_INT 0
83139: PPUSH
83140: LD_INT 3
83142: PPUSH
83143: CALL_OW 12
83147: PUSH
83148: LD_INT 0
83150: PUSH
83151: LD_INT 0
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: ST_TO_ADDR
// end ;
83160: LD_VAR 0 1
83164: RET
// export function PrepareApeman ( agressivity ) ; begin
83165: LD_INT 0
83167: PPUSH
// uc_side := 0 ;
83168: LD_ADDR_OWVAR 20
83172: PUSH
83173: LD_INT 0
83175: ST_TO_ADDR
// uc_nation := 0 ;
83176: LD_ADDR_OWVAR 21
83180: PUSH
83181: LD_INT 0
83183: ST_TO_ADDR
// hc_sex := sex_male ;
83184: LD_ADDR_OWVAR 27
83188: PUSH
83189: LD_INT 1
83191: ST_TO_ADDR
// hc_class := class_apeman ;
83192: LD_ADDR_OWVAR 28
83196: PUSH
83197: LD_INT 12
83199: ST_TO_ADDR
// hc_gallery :=  ;
83200: LD_ADDR_OWVAR 33
83204: PUSH
83205: LD_STRING 
83207: ST_TO_ADDR
// if agressivity = 0 then
83208: LD_VAR 0 1
83212: PUSH
83213: LD_INT 0
83215: EQUAL
83216: IFFALSE 83228
// hc_agressivity := 0 else
83218: LD_ADDR_OWVAR 35
83222: PUSH
83223: LD_INT 0
83225: ST_TO_ADDR
83226: GO 83249
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83228: LD_ADDR_OWVAR 35
83232: PUSH
83233: LD_VAR 0 1
83237: NEG
83238: PPUSH
83239: LD_VAR 0 1
83243: PPUSH
83244: CALL_OW 12
83248: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83249: LD_ADDR_OWVAR 31
83253: PUSH
83254: LD_INT 0
83256: PPUSH
83257: LD_INT 3
83259: PPUSH
83260: CALL_OW 12
83264: PUSH
83265: LD_INT 0
83267: PPUSH
83268: LD_INT 3
83270: PPUSH
83271: CALL_OW 12
83275: PUSH
83276: LD_INT 0
83278: PUSH
83279: LD_INT 0
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: ST_TO_ADDR
// end ;
83288: LD_VAR 0 2
83292: RET
// export function PrepareTiger ( agressivity ) ; begin
83293: LD_INT 0
83295: PPUSH
// uc_side := 0 ;
83296: LD_ADDR_OWVAR 20
83300: PUSH
83301: LD_INT 0
83303: ST_TO_ADDR
// uc_nation := 0 ;
83304: LD_ADDR_OWVAR 21
83308: PUSH
83309: LD_INT 0
83311: ST_TO_ADDR
// hc_class := class_tiger ;
83312: LD_ADDR_OWVAR 28
83316: PUSH
83317: LD_INT 14
83319: ST_TO_ADDR
// hc_gallery :=  ;
83320: LD_ADDR_OWVAR 33
83324: PUSH
83325: LD_STRING 
83327: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83328: LD_ADDR_OWVAR 35
83332: PUSH
83333: LD_VAR 0 1
83337: NEG
83338: PPUSH
83339: LD_VAR 0 1
83343: PPUSH
83344: CALL_OW 12
83348: ST_TO_ADDR
// end ;
83349: LD_VAR 0 2
83353: RET
// export function PrepareEnchidna ( ) ; begin
83354: LD_INT 0
83356: PPUSH
// uc_side := 0 ;
83357: LD_ADDR_OWVAR 20
83361: PUSH
83362: LD_INT 0
83364: ST_TO_ADDR
// uc_nation := 0 ;
83365: LD_ADDR_OWVAR 21
83369: PUSH
83370: LD_INT 0
83372: ST_TO_ADDR
// hc_class := class_baggie ;
83373: LD_ADDR_OWVAR 28
83377: PUSH
83378: LD_INT 13
83380: ST_TO_ADDR
// hc_gallery :=  ;
83381: LD_ADDR_OWVAR 33
83385: PUSH
83386: LD_STRING 
83388: ST_TO_ADDR
// end ;
83389: LD_VAR 0 1
83393: RET
// export function PrepareFrog ( ) ; begin
83394: LD_INT 0
83396: PPUSH
// uc_side := 0 ;
83397: LD_ADDR_OWVAR 20
83401: PUSH
83402: LD_INT 0
83404: ST_TO_ADDR
// uc_nation := 0 ;
83405: LD_ADDR_OWVAR 21
83409: PUSH
83410: LD_INT 0
83412: ST_TO_ADDR
// hc_class := class_frog ;
83413: LD_ADDR_OWVAR 28
83417: PUSH
83418: LD_INT 19
83420: ST_TO_ADDR
// hc_gallery :=  ;
83421: LD_ADDR_OWVAR 33
83425: PUSH
83426: LD_STRING 
83428: ST_TO_ADDR
// end ;
83429: LD_VAR 0 1
83433: RET
// export function PrepareFish ( ) ; begin
83434: LD_INT 0
83436: PPUSH
// uc_side := 0 ;
83437: LD_ADDR_OWVAR 20
83441: PUSH
83442: LD_INT 0
83444: ST_TO_ADDR
// uc_nation := 0 ;
83445: LD_ADDR_OWVAR 21
83449: PUSH
83450: LD_INT 0
83452: ST_TO_ADDR
// hc_class := class_fish ;
83453: LD_ADDR_OWVAR 28
83457: PUSH
83458: LD_INT 20
83460: ST_TO_ADDR
// hc_gallery :=  ;
83461: LD_ADDR_OWVAR 33
83465: PUSH
83466: LD_STRING 
83468: ST_TO_ADDR
// end ;
83469: LD_VAR 0 1
83473: RET
// export function PrepareBird ( ) ; begin
83474: LD_INT 0
83476: PPUSH
// uc_side := 0 ;
83477: LD_ADDR_OWVAR 20
83481: PUSH
83482: LD_INT 0
83484: ST_TO_ADDR
// uc_nation := 0 ;
83485: LD_ADDR_OWVAR 21
83489: PUSH
83490: LD_INT 0
83492: ST_TO_ADDR
// hc_class := class_phororhacos ;
83493: LD_ADDR_OWVAR 28
83497: PUSH
83498: LD_INT 18
83500: ST_TO_ADDR
// hc_gallery :=  ;
83501: LD_ADDR_OWVAR 33
83505: PUSH
83506: LD_STRING 
83508: ST_TO_ADDR
// end ;
83509: LD_VAR 0 1
83513: RET
// export function PrepareHorse ( ) ; begin
83514: LD_INT 0
83516: PPUSH
// uc_side := 0 ;
83517: LD_ADDR_OWVAR 20
83521: PUSH
83522: LD_INT 0
83524: ST_TO_ADDR
// uc_nation := 0 ;
83525: LD_ADDR_OWVAR 21
83529: PUSH
83530: LD_INT 0
83532: ST_TO_ADDR
// hc_class := class_horse ;
83533: LD_ADDR_OWVAR 28
83537: PUSH
83538: LD_INT 21
83540: ST_TO_ADDR
// hc_gallery :=  ;
83541: LD_ADDR_OWVAR 33
83545: PUSH
83546: LD_STRING 
83548: ST_TO_ADDR
// end ;
83549: LD_VAR 0 1
83553: RET
// export function PrepareMastodont ( ) ; begin
83554: LD_INT 0
83556: PPUSH
// uc_side := 0 ;
83557: LD_ADDR_OWVAR 20
83561: PUSH
83562: LD_INT 0
83564: ST_TO_ADDR
// uc_nation := 0 ;
83565: LD_ADDR_OWVAR 21
83569: PUSH
83570: LD_INT 0
83572: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83573: LD_ADDR_OWVAR 37
83577: PUSH
83578: LD_INT 31
83580: ST_TO_ADDR
// vc_control := control_rider ;
83581: LD_ADDR_OWVAR 38
83585: PUSH
83586: LD_INT 4
83588: ST_TO_ADDR
// end ;
83589: LD_VAR 0 1
83593: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83594: LD_INT 0
83596: PPUSH
83597: PPUSH
83598: PPUSH
// uc_side = 0 ;
83599: LD_ADDR_OWVAR 20
83603: PUSH
83604: LD_INT 0
83606: ST_TO_ADDR
// uc_nation = 0 ;
83607: LD_ADDR_OWVAR 21
83611: PUSH
83612: LD_INT 0
83614: ST_TO_ADDR
// InitHc_All ( ) ;
83615: CALL_OW 584
// InitVc ;
83619: CALL_OW 20
// if mastodonts then
83623: LD_VAR 0 6
83627: IFFALSE 83694
// for i = 1 to mastodonts do
83629: LD_ADDR_VAR 0 11
83633: PUSH
83634: DOUBLE
83635: LD_INT 1
83637: DEC
83638: ST_TO_ADDR
83639: LD_VAR 0 6
83643: PUSH
83644: FOR_TO
83645: IFFALSE 83692
// begin vc_chassis := 31 ;
83647: LD_ADDR_OWVAR 37
83651: PUSH
83652: LD_INT 31
83654: ST_TO_ADDR
// vc_control := control_rider ;
83655: LD_ADDR_OWVAR 38
83659: PUSH
83660: LD_INT 4
83662: ST_TO_ADDR
// animal := CreateVehicle ;
83663: LD_ADDR_VAR 0 12
83667: PUSH
83668: CALL_OW 45
83672: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83673: LD_VAR 0 12
83677: PPUSH
83678: LD_VAR 0 8
83682: PPUSH
83683: LD_INT 0
83685: PPUSH
83686: CALL 85822 0 3
// end ;
83690: GO 83644
83692: POP
83693: POP
// if horses then
83694: LD_VAR 0 5
83698: IFFALSE 83765
// for i = 1 to horses do
83700: LD_ADDR_VAR 0 11
83704: PUSH
83705: DOUBLE
83706: LD_INT 1
83708: DEC
83709: ST_TO_ADDR
83710: LD_VAR 0 5
83714: PUSH
83715: FOR_TO
83716: IFFALSE 83763
// begin hc_class := 21 ;
83718: LD_ADDR_OWVAR 28
83722: PUSH
83723: LD_INT 21
83725: ST_TO_ADDR
// hc_gallery :=  ;
83726: LD_ADDR_OWVAR 33
83730: PUSH
83731: LD_STRING 
83733: ST_TO_ADDR
// animal := CreateHuman ;
83734: LD_ADDR_VAR 0 12
83738: PUSH
83739: CALL_OW 44
83743: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83744: LD_VAR 0 12
83748: PPUSH
83749: LD_VAR 0 8
83753: PPUSH
83754: LD_INT 0
83756: PPUSH
83757: CALL 85822 0 3
// end ;
83761: GO 83715
83763: POP
83764: POP
// if birds then
83765: LD_VAR 0 1
83769: IFFALSE 83836
// for i = 1 to birds do
83771: LD_ADDR_VAR 0 11
83775: PUSH
83776: DOUBLE
83777: LD_INT 1
83779: DEC
83780: ST_TO_ADDR
83781: LD_VAR 0 1
83785: PUSH
83786: FOR_TO
83787: IFFALSE 83834
// begin hc_class := 18 ;
83789: LD_ADDR_OWVAR 28
83793: PUSH
83794: LD_INT 18
83796: ST_TO_ADDR
// hc_gallery =  ;
83797: LD_ADDR_OWVAR 33
83801: PUSH
83802: LD_STRING 
83804: ST_TO_ADDR
// animal := CreateHuman ;
83805: LD_ADDR_VAR 0 12
83809: PUSH
83810: CALL_OW 44
83814: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83815: LD_VAR 0 12
83819: PPUSH
83820: LD_VAR 0 8
83824: PPUSH
83825: LD_INT 0
83827: PPUSH
83828: CALL 85822 0 3
// end ;
83832: GO 83786
83834: POP
83835: POP
// if tigers then
83836: LD_VAR 0 2
83840: IFFALSE 83924
// for i = 1 to tigers do
83842: LD_ADDR_VAR 0 11
83846: PUSH
83847: DOUBLE
83848: LD_INT 1
83850: DEC
83851: ST_TO_ADDR
83852: LD_VAR 0 2
83856: PUSH
83857: FOR_TO
83858: IFFALSE 83922
// begin hc_class = class_tiger ;
83860: LD_ADDR_OWVAR 28
83864: PUSH
83865: LD_INT 14
83867: ST_TO_ADDR
// hc_gallery =  ;
83868: LD_ADDR_OWVAR 33
83872: PUSH
83873: LD_STRING 
83875: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83876: LD_ADDR_OWVAR 35
83880: PUSH
83881: LD_INT 7
83883: NEG
83884: PPUSH
83885: LD_INT 7
83887: PPUSH
83888: CALL_OW 12
83892: ST_TO_ADDR
// animal := CreateHuman ;
83893: LD_ADDR_VAR 0 12
83897: PUSH
83898: CALL_OW 44
83902: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83903: LD_VAR 0 12
83907: PPUSH
83908: LD_VAR 0 8
83912: PPUSH
83913: LD_INT 0
83915: PPUSH
83916: CALL 85822 0 3
// end ;
83920: GO 83857
83922: POP
83923: POP
// if apemans then
83924: LD_VAR 0 3
83928: IFFALSE 84051
// for i = 1 to apemans do
83930: LD_ADDR_VAR 0 11
83934: PUSH
83935: DOUBLE
83936: LD_INT 1
83938: DEC
83939: ST_TO_ADDR
83940: LD_VAR 0 3
83944: PUSH
83945: FOR_TO
83946: IFFALSE 84049
// begin hc_class = class_apeman ;
83948: LD_ADDR_OWVAR 28
83952: PUSH
83953: LD_INT 12
83955: ST_TO_ADDR
// hc_gallery =  ;
83956: LD_ADDR_OWVAR 33
83960: PUSH
83961: LD_STRING 
83963: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83964: LD_ADDR_OWVAR 35
83968: PUSH
83969: LD_INT 2
83971: NEG
83972: PPUSH
83973: LD_INT 2
83975: PPUSH
83976: CALL_OW 12
83980: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83981: LD_ADDR_OWVAR 31
83985: PUSH
83986: LD_INT 1
83988: PPUSH
83989: LD_INT 3
83991: PPUSH
83992: CALL_OW 12
83996: PUSH
83997: LD_INT 1
83999: PPUSH
84000: LD_INT 3
84002: PPUSH
84003: CALL_OW 12
84007: PUSH
84008: LD_INT 0
84010: PUSH
84011: LD_INT 0
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: ST_TO_ADDR
// animal := CreateHuman ;
84020: LD_ADDR_VAR 0 12
84024: PUSH
84025: CALL_OW 44
84029: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84030: LD_VAR 0 12
84034: PPUSH
84035: LD_VAR 0 8
84039: PPUSH
84040: LD_INT 0
84042: PPUSH
84043: CALL 85822 0 3
// end ;
84047: GO 83945
84049: POP
84050: POP
// if enchidnas then
84051: LD_VAR 0 4
84055: IFFALSE 84122
// for i = 1 to enchidnas do
84057: LD_ADDR_VAR 0 11
84061: PUSH
84062: DOUBLE
84063: LD_INT 1
84065: DEC
84066: ST_TO_ADDR
84067: LD_VAR 0 4
84071: PUSH
84072: FOR_TO
84073: IFFALSE 84120
// begin hc_class = 13 ;
84075: LD_ADDR_OWVAR 28
84079: PUSH
84080: LD_INT 13
84082: ST_TO_ADDR
// hc_gallery =  ;
84083: LD_ADDR_OWVAR 33
84087: PUSH
84088: LD_STRING 
84090: ST_TO_ADDR
// animal := CreateHuman ;
84091: LD_ADDR_VAR 0 12
84095: PUSH
84096: CALL_OW 44
84100: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84101: LD_VAR 0 12
84105: PPUSH
84106: LD_VAR 0 8
84110: PPUSH
84111: LD_INT 0
84113: PPUSH
84114: CALL 85822 0 3
// end ;
84118: GO 84072
84120: POP
84121: POP
// if fishes then
84122: LD_VAR 0 7
84126: IFFALSE 84193
// for i = 1 to fishes do
84128: LD_ADDR_VAR 0 11
84132: PUSH
84133: DOUBLE
84134: LD_INT 1
84136: DEC
84137: ST_TO_ADDR
84138: LD_VAR 0 7
84142: PUSH
84143: FOR_TO
84144: IFFALSE 84191
// begin hc_class = 20 ;
84146: LD_ADDR_OWVAR 28
84150: PUSH
84151: LD_INT 20
84153: ST_TO_ADDR
// hc_gallery =  ;
84154: LD_ADDR_OWVAR 33
84158: PUSH
84159: LD_STRING 
84161: ST_TO_ADDR
// animal := CreateHuman ;
84162: LD_ADDR_VAR 0 12
84166: PUSH
84167: CALL_OW 44
84171: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84172: LD_VAR 0 12
84176: PPUSH
84177: LD_VAR 0 9
84181: PPUSH
84182: LD_INT 0
84184: PPUSH
84185: CALL 85822 0 3
// end ;
84189: GO 84143
84191: POP
84192: POP
// end ;
84193: LD_VAR 0 10
84197: RET
// export function WantHeal ( sci , unit ) ; begin
84198: LD_INT 0
84200: PPUSH
// if GetTaskList ( sci ) > 0 then
84201: LD_VAR 0 1
84205: PPUSH
84206: CALL_OW 437
84210: PUSH
84211: LD_INT 0
84213: GREATER
84214: IFFALSE 84284
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84216: LD_VAR 0 1
84220: PPUSH
84221: CALL_OW 437
84225: PUSH
84226: LD_INT 1
84228: ARRAY
84229: PUSH
84230: LD_INT 1
84232: ARRAY
84233: PUSH
84234: LD_STRING l
84236: EQUAL
84237: PUSH
84238: LD_VAR 0 1
84242: PPUSH
84243: CALL_OW 437
84247: PUSH
84248: LD_INT 1
84250: ARRAY
84251: PUSH
84252: LD_INT 4
84254: ARRAY
84255: PUSH
84256: LD_VAR 0 2
84260: EQUAL
84261: AND
84262: IFFALSE 84274
// result := true else
84264: LD_ADDR_VAR 0 3
84268: PUSH
84269: LD_INT 1
84271: ST_TO_ADDR
84272: GO 84282
// result := false ;
84274: LD_ADDR_VAR 0 3
84278: PUSH
84279: LD_INT 0
84281: ST_TO_ADDR
// end else
84282: GO 84292
// result := false ;
84284: LD_ADDR_VAR 0 3
84288: PUSH
84289: LD_INT 0
84291: ST_TO_ADDR
// end ;
84292: LD_VAR 0 3
84296: RET
// export function HealTarget ( sci ) ; begin
84297: LD_INT 0
84299: PPUSH
// if not sci then
84300: LD_VAR 0 1
84304: NOT
84305: IFFALSE 84309
// exit ;
84307: GO 84374
// result := 0 ;
84309: LD_ADDR_VAR 0 2
84313: PUSH
84314: LD_INT 0
84316: ST_TO_ADDR
// if GetTaskList ( sci ) then
84317: LD_VAR 0 1
84321: PPUSH
84322: CALL_OW 437
84326: IFFALSE 84374
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84328: LD_VAR 0 1
84332: PPUSH
84333: CALL_OW 437
84337: PUSH
84338: LD_INT 1
84340: ARRAY
84341: PUSH
84342: LD_INT 1
84344: ARRAY
84345: PUSH
84346: LD_STRING l
84348: EQUAL
84349: IFFALSE 84374
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84351: LD_ADDR_VAR 0 2
84355: PUSH
84356: LD_VAR 0 1
84360: PPUSH
84361: CALL_OW 437
84365: PUSH
84366: LD_INT 1
84368: ARRAY
84369: PUSH
84370: LD_INT 4
84372: ARRAY
84373: ST_TO_ADDR
// end ;
84374: LD_VAR 0 2
84378: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84379: LD_INT 0
84381: PPUSH
84382: PPUSH
84383: PPUSH
84384: PPUSH
// if not base_units then
84385: LD_VAR 0 1
84389: NOT
84390: IFFALSE 84394
// exit ;
84392: GO 84481
// result := false ;
84394: LD_ADDR_VAR 0 2
84398: PUSH
84399: LD_INT 0
84401: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84402: LD_ADDR_VAR 0 5
84406: PUSH
84407: LD_VAR 0 1
84411: PPUSH
84412: LD_INT 21
84414: PUSH
84415: LD_INT 3
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PPUSH
84422: CALL_OW 72
84426: ST_TO_ADDR
// if not tmp then
84427: LD_VAR 0 5
84431: NOT
84432: IFFALSE 84436
// exit ;
84434: GO 84481
// for i in tmp do
84436: LD_ADDR_VAR 0 3
84440: PUSH
84441: LD_VAR 0 5
84445: PUSH
84446: FOR_IN
84447: IFFALSE 84479
// begin result := EnemyInRange ( i , 22 ) ;
84449: LD_ADDR_VAR 0 2
84453: PUSH
84454: LD_VAR 0 3
84458: PPUSH
84459: LD_INT 22
84461: PPUSH
84462: CALL 82059 0 2
84466: ST_TO_ADDR
// if result then
84467: LD_VAR 0 2
84471: IFFALSE 84477
// exit ;
84473: POP
84474: POP
84475: GO 84481
// end ;
84477: GO 84446
84479: POP
84480: POP
// end ;
84481: LD_VAR 0 2
84485: RET
// export function FilterByTag ( units , tag ) ; begin
84486: LD_INT 0
84488: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84489: LD_ADDR_VAR 0 3
84493: PUSH
84494: LD_VAR 0 1
84498: PPUSH
84499: LD_INT 120
84501: PUSH
84502: LD_VAR 0 2
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PPUSH
84511: CALL_OW 72
84515: ST_TO_ADDR
// end ;
84516: LD_VAR 0 3
84520: RET
// export function IsDriver ( un ) ; begin
84521: LD_INT 0
84523: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84524: LD_ADDR_VAR 0 2
84528: PUSH
84529: LD_VAR 0 1
84533: PUSH
84534: LD_INT 55
84536: PUSH
84537: EMPTY
84538: LIST
84539: PPUSH
84540: CALL_OW 69
84544: IN
84545: ST_TO_ADDR
// end ;
84546: LD_VAR 0 2
84550: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84551: LD_INT 0
84553: PPUSH
84554: PPUSH
// list := [ ] ;
84555: LD_ADDR_VAR 0 5
84559: PUSH
84560: EMPTY
84561: ST_TO_ADDR
// case d of 0 :
84562: LD_VAR 0 3
84566: PUSH
84567: LD_INT 0
84569: DOUBLE
84570: EQUAL
84571: IFTRUE 84575
84573: GO 84708
84575: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84576: LD_ADDR_VAR 0 5
84580: PUSH
84581: LD_VAR 0 1
84585: PUSH
84586: LD_INT 4
84588: MINUS
84589: PUSH
84590: LD_VAR 0 2
84594: PUSH
84595: LD_INT 4
84597: MINUS
84598: PUSH
84599: LD_INT 2
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: LIST
84606: PUSH
84607: LD_VAR 0 1
84611: PUSH
84612: LD_INT 3
84614: MINUS
84615: PUSH
84616: LD_VAR 0 2
84620: PUSH
84621: LD_INT 1
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: LIST
84628: PUSH
84629: LD_VAR 0 1
84633: PUSH
84634: LD_INT 4
84636: PLUS
84637: PUSH
84638: LD_VAR 0 2
84642: PUSH
84643: LD_INT 4
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: LIST
84650: PUSH
84651: LD_VAR 0 1
84655: PUSH
84656: LD_INT 3
84658: PLUS
84659: PUSH
84660: LD_VAR 0 2
84664: PUSH
84665: LD_INT 3
84667: PLUS
84668: PUSH
84669: LD_INT 5
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: LIST
84676: PUSH
84677: LD_VAR 0 1
84681: PUSH
84682: LD_VAR 0 2
84686: PUSH
84687: LD_INT 4
84689: PLUS
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: LIST
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: ST_TO_ADDR
// end ; 1 :
84706: GO 85406
84708: LD_INT 1
84710: DOUBLE
84711: EQUAL
84712: IFTRUE 84716
84714: GO 84849
84716: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84717: LD_ADDR_VAR 0 5
84721: PUSH
84722: LD_VAR 0 1
84726: PUSH
84727: LD_VAR 0 2
84731: PUSH
84732: LD_INT 4
84734: MINUS
84735: PUSH
84736: LD_INT 3
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: LIST
84743: PUSH
84744: LD_VAR 0 1
84748: PUSH
84749: LD_INT 3
84751: MINUS
84752: PUSH
84753: LD_VAR 0 2
84757: PUSH
84758: LD_INT 3
84760: MINUS
84761: PUSH
84762: LD_INT 2
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: LIST
84769: PUSH
84770: LD_VAR 0 1
84774: PUSH
84775: LD_INT 4
84777: MINUS
84778: PUSH
84779: LD_VAR 0 2
84783: PUSH
84784: LD_INT 1
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: LIST
84791: PUSH
84792: LD_VAR 0 1
84796: PUSH
84797: LD_VAR 0 2
84801: PUSH
84802: LD_INT 3
84804: PLUS
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: LIST
84813: PUSH
84814: LD_VAR 0 1
84818: PUSH
84819: LD_INT 4
84821: PLUS
84822: PUSH
84823: LD_VAR 0 2
84827: PUSH
84828: LD_INT 4
84830: PLUS
84831: PUSH
84832: LD_INT 5
84834: PUSH
84835: EMPTY
84836: LIST
84837: LIST
84838: LIST
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: ST_TO_ADDR
// end ; 2 :
84847: GO 85406
84849: LD_INT 2
84851: DOUBLE
84852: EQUAL
84853: IFTRUE 84857
84855: GO 84986
84857: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84858: LD_ADDR_VAR 0 5
84862: PUSH
84863: LD_VAR 0 1
84867: PUSH
84868: LD_VAR 0 2
84872: PUSH
84873: LD_INT 3
84875: MINUS
84876: PUSH
84877: LD_INT 3
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: LIST
84884: PUSH
84885: LD_VAR 0 1
84889: PUSH
84890: LD_INT 4
84892: PLUS
84893: PUSH
84894: LD_VAR 0 2
84898: PUSH
84899: LD_INT 4
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: LIST
84906: PUSH
84907: LD_VAR 0 1
84911: PUSH
84912: LD_VAR 0 2
84916: PUSH
84917: LD_INT 4
84919: PLUS
84920: PUSH
84921: LD_INT 0
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: LIST
84928: PUSH
84929: LD_VAR 0 1
84933: PUSH
84934: LD_INT 3
84936: MINUS
84937: PUSH
84938: LD_VAR 0 2
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: LIST
84950: PUSH
84951: LD_VAR 0 1
84955: PUSH
84956: LD_INT 4
84958: MINUS
84959: PUSH
84960: LD_VAR 0 2
84964: PUSH
84965: LD_INT 4
84967: MINUS
84968: PUSH
84969: LD_INT 2
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: LIST
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: ST_TO_ADDR
// end ; 3 :
84984: GO 85406
84986: LD_INT 3
84988: DOUBLE
84989: EQUAL
84990: IFTRUE 84994
84992: GO 85127
84994: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84995: LD_ADDR_VAR 0 5
84999: PUSH
85000: LD_VAR 0 1
85004: PUSH
85005: LD_INT 3
85007: PLUS
85008: PUSH
85009: LD_VAR 0 2
85013: PUSH
85014: LD_INT 4
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: LIST
85021: PUSH
85022: LD_VAR 0 1
85026: PUSH
85027: LD_INT 4
85029: PLUS
85030: PUSH
85031: LD_VAR 0 2
85035: PUSH
85036: LD_INT 4
85038: PLUS
85039: PUSH
85040: LD_INT 5
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: LIST
85047: PUSH
85048: LD_VAR 0 1
85052: PUSH
85053: LD_INT 4
85055: MINUS
85056: PUSH
85057: LD_VAR 0 2
85061: PUSH
85062: LD_INT 1
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: LIST
85069: PUSH
85070: LD_VAR 0 1
85074: PUSH
85075: LD_VAR 0 2
85079: PUSH
85080: LD_INT 4
85082: MINUS
85083: PUSH
85084: LD_INT 3
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: LIST
85091: PUSH
85092: LD_VAR 0 1
85096: PUSH
85097: LD_INT 3
85099: MINUS
85100: PUSH
85101: LD_VAR 0 2
85105: PUSH
85106: LD_INT 3
85108: MINUS
85109: PUSH
85110: LD_INT 2
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: LIST
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: ST_TO_ADDR
// end ; 4 :
85125: GO 85406
85127: LD_INT 4
85129: DOUBLE
85130: EQUAL
85131: IFTRUE 85135
85133: GO 85268
85135: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85136: LD_ADDR_VAR 0 5
85140: PUSH
85141: LD_VAR 0 1
85145: PUSH
85146: LD_VAR 0 2
85150: PUSH
85151: LD_INT 4
85153: PLUS
85154: PUSH
85155: LD_INT 0
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: LIST
85162: PUSH
85163: LD_VAR 0 1
85167: PUSH
85168: LD_INT 3
85170: PLUS
85171: PUSH
85172: LD_VAR 0 2
85176: PUSH
85177: LD_INT 3
85179: PLUS
85180: PUSH
85181: LD_INT 5
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: LIST
85188: PUSH
85189: LD_VAR 0 1
85193: PUSH
85194: LD_INT 4
85196: PLUS
85197: PUSH
85198: LD_VAR 0 2
85202: PUSH
85203: LD_INT 4
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: LIST
85210: PUSH
85211: LD_VAR 0 1
85215: PUSH
85216: LD_VAR 0 2
85220: PUSH
85221: LD_INT 3
85223: MINUS
85224: PUSH
85225: LD_INT 3
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: LIST
85232: PUSH
85233: LD_VAR 0 1
85237: PUSH
85238: LD_INT 4
85240: MINUS
85241: PUSH
85242: LD_VAR 0 2
85246: PUSH
85247: LD_INT 4
85249: MINUS
85250: PUSH
85251: LD_INT 2
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: LIST
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: ST_TO_ADDR
// end ; 5 :
85266: GO 85406
85268: LD_INT 5
85270: DOUBLE
85271: EQUAL
85272: IFTRUE 85276
85274: GO 85405
85276: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85277: LD_ADDR_VAR 0 5
85281: PUSH
85282: LD_VAR 0 1
85286: PUSH
85287: LD_INT 4
85289: MINUS
85290: PUSH
85291: LD_VAR 0 2
85295: PUSH
85296: LD_INT 1
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: LIST
85303: PUSH
85304: LD_VAR 0 1
85308: PUSH
85309: LD_VAR 0 2
85313: PUSH
85314: LD_INT 4
85316: MINUS
85317: PUSH
85318: LD_INT 3
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: LIST
85325: PUSH
85326: LD_VAR 0 1
85330: PUSH
85331: LD_INT 4
85333: PLUS
85334: PUSH
85335: LD_VAR 0 2
85339: PUSH
85340: LD_INT 4
85342: PLUS
85343: PUSH
85344: LD_INT 5
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: LIST
85351: PUSH
85352: LD_VAR 0 1
85356: PUSH
85357: LD_INT 3
85359: PLUS
85360: PUSH
85361: LD_VAR 0 2
85365: PUSH
85366: LD_INT 4
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: LIST
85373: PUSH
85374: LD_VAR 0 1
85378: PUSH
85379: LD_VAR 0 2
85383: PUSH
85384: LD_INT 3
85386: PLUS
85387: PUSH
85388: LD_INT 0
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: LIST
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: ST_TO_ADDR
// end ; end ;
85403: GO 85406
85405: POP
// result := list ;
85406: LD_ADDR_VAR 0 4
85410: PUSH
85411: LD_VAR 0 5
85415: ST_TO_ADDR
// end ;
85416: LD_VAR 0 4
85420: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85421: LD_INT 0
85423: PPUSH
85424: PPUSH
85425: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85426: LD_VAR 0 1
85430: NOT
85431: PUSH
85432: LD_VAR 0 2
85436: PUSH
85437: LD_INT 1
85439: PUSH
85440: LD_INT 2
85442: PUSH
85443: LD_INT 3
85445: PUSH
85446: LD_INT 4
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: IN
85455: NOT
85456: OR
85457: IFFALSE 85461
// exit ;
85459: GO 85544
// tmp := [ ] ;
85461: LD_ADDR_VAR 0 5
85465: PUSH
85466: EMPTY
85467: ST_TO_ADDR
// for i in units do
85468: LD_ADDR_VAR 0 4
85472: PUSH
85473: LD_VAR 0 1
85477: PUSH
85478: FOR_IN
85479: IFFALSE 85513
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85481: LD_ADDR_VAR 0 5
85485: PUSH
85486: LD_VAR 0 5
85490: PPUSH
85491: LD_VAR 0 4
85495: PPUSH
85496: LD_VAR 0 2
85500: PPUSH
85501: CALL_OW 259
85505: PPUSH
85506: CALL 86917 0 2
85510: ST_TO_ADDR
85511: GO 85478
85513: POP
85514: POP
// if not tmp then
85515: LD_VAR 0 5
85519: NOT
85520: IFFALSE 85524
// exit ;
85522: GO 85544
// result := SortListByListDesc ( units , tmp ) ;
85524: LD_ADDR_VAR 0 3
85528: PUSH
85529: LD_VAR 0 1
85533: PPUSH
85534: LD_VAR 0 5
85538: PPUSH
85539: CALL_OW 77
85543: ST_TO_ADDR
// end ;
85544: LD_VAR 0 3
85548: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85549: LD_INT 0
85551: PPUSH
85552: PPUSH
85553: PPUSH
// result := false ;
85554: LD_ADDR_VAR 0 3
85558: PUSH
85559: LD_INT 0
85561: ST_TO_ADDR
// if not building then
85562: LD_VAR 0 2
85566: NOT
85567: IFFALSE 85571
// exit ;
85569: GO 85709
// x := GetX ( building ) ;
85571: LD_ADDR_VAR 0 4
85575: PUSH
85576: LD_VAR 0 2
85580: PPUSH
85581: CALL_OW 250
85585: ST_TO_ADDR
// y := GetY ( building ) ;
85586: LD_ADDR_VAR 0 5
85590: PUSH
85591: LD_VAR 0 2
85595: PPUSH
85596: CALL_OW 251
85600: ST_TO_ADDR
// if not x or not y then
85601: LD_VAR 0 4
85605: NOT
85606: PUSH
85607: LD_VAR 0 5
85611: NOT
85612: OR
85613: IFFALSE 85617
// exit ;
85615: GO 85709
// if GetTaskList ( unit ) then
85617: LD_VAR 0 1
85621: PPUSH
85622: CALL_OW 437
85626: IFFALSE 85709
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85628: LD_STRING e
85630: PUSH
85631: LD_VAR 0 1
85635: PPUSH
85636: CALL_OW 437
85640: PUSH
85641: LD_INT 1
85643: ARRAY
85644: PUSH
85645: LD_INT 1
85647: ARRAY
85648: EQUAL
85649: PUSH
85650: LD_VAR 0 4
85654: PUSH
85655: LD_VAR 0 1
85659: PPUSH
85660: CALL_OW 437
85664: PUSH
85665: LD_INT 1
85667: ARRAY
85668: PUSH
85669: LD_INT 2
85671: ARRAY
85672: EQUAL
85673: AND
85674: PUSH
85675: LD_VAR 0 5
85679: PUSH
85680: LD_VAR 0 1
85684: PPUSH
85685: CALL_OW 437
85689: PUSH
85690: LD_INT 1
85692: ARRAY
85693: PUSH
85694: LD_INT 3
85696: ARRAY
85697: EQUAL
85698: AND
85699: IFFALSE 85709
// result := true end ;
85701: LD_ADDR_VAR 0 3
85705: PUSH
85706: LD_INT 1
85708: ST_TO_ADDR
// end ;
85709: LD_VAR 0 3
85713: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85714: LD_INT 0
85716: PPUSH
// result := false ;
85717: LD_ADDR_VAR 0 4
85721: PUSH
85722: LD_INT 0
85724: ST_TO_ADDR
// if GetTaskList ( unit ) then
85725: LD_VAR 0 1
85729: PPUSH
85730: CALL_OW 437
85734: IFFALSE 85817
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85736: LD_STRING M
85738: PUSH
85739: LD_VAR 0 1
85743: PPUSH
85744: CALL_OW 437
85748: PUSH
85749: LD_INT 1
85751: ARRAY
85752: PUSH
85753: LD_INT 1
85755: ARRAY
85756: EQUAL
85757: PUSH
85758: LD_VAR 0 2
85762: PUSH
85763: LD_VAR 0 1
85767: PPUSH
85768: CALL_OW 437
85772: PUSH
85773: LD_INT 1
85775: ARRAY
85776: PUSH
85777: LD_INT 2
85779: ARRAY
85780: EQUAL
85781: AND
85782: PUSH
85783: LD_VAR 0 3
85787: PUSH
85788: LD_VAR 0 1
85792: PPUSH
85793: CALL_OW 437
85797: PUSH
85798: LD_INT 1
85800: ARRAY
85801: PUSH
85802: LD_INT 3
85804: ARRAY
85805: EQUAL
85806: AND
85807: IFFALSE 85817
// result := true ;
85809: LD_ADDR_VAR 0 4
85813: PUSH
85814: LD_INT 1
85816: ST_TO_ADDR
// end ; end ;
85817: LD_VAR 0 4
85821: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85822: LD_INT 0
85824: PPUSH
85825: PPUSH
85826: PPUSH
85827: PPUSH
// if not unit or not area then
85828: LD_VAR 0 1
85832: NOT
85833: PUSH
85834: LD_VAR 0 2
85838: NOT
85839: OR
85840: IFFALSE 85844
// exit ;
85842: GO 86020
// tmp := AreaToList ( area , i ) ;
85844: LD_ADDR_VAR 0 6
85848: PUSH
85849: LD_VAR 0 2
85853: PPUSH
85854: LD_VAR 0 5
85858: PPUSH
85859: CALL_OW 517
85863: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85864: LD_ADDR_VAR 0 5
85868: PUSH
85869: DOUBLE
85870: LD_INT 1
85872: DEC
85873: ST_TO_ADDR
85874: LD_VAR 0 6
85878: PUSH
85879: LD_INT 1
85881: ARRAY
85882: PUSH
85883: FOR_TO
85884: IFFALSE 86018
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85886: LD_ADDR_VAR 0 7
85890: PUSH
85891: LD_VAR 0 6
85895: PUSH
85896: LD_INT 1
85898: ARRAY
85899: PUSH
85900: LD_VAR 0 5
85904: ARRAY
85905: PUSH
85906: LD_VAR 0 6
85910: PUSH
85911: LD_INT 2
85913: ARRAY
85914: PUSH
85915: LD_VAR 0 5
85919: ARRAY
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85925: LD_INT 92
85927: PUSH
85928: LD_VAR 0 7
85932: PUSH
85933: LD_INT 1
85935: ARRAY
85936: PUSH
85937: LD_VAR 0 7
85941: PUSH
85942: LD_INT 2
85944: ARRAY
85945: PUSH
85946: LD_INT 2
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: PPUSH
85955: CALL_OW 69
85959: PUSH
85960: LD_INT 0
85962: EQUAL
85963: IFFALSE 86016
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85965: LD_VAR 0 1
85969: PPUSH
85970: LD_VAR 0 7
85974: PUSH
85975: LD_INT 1
85977: ARRAY
85978: PPUSH
85979: LD_VAR 0 7
85983: PUSH
85984: LD_INT 2
85986: ARRAY
85987: PPUSH
85988: LD_VAR 0 3
85992: PPUSH
85993: CALL_OW 48
// result := IsPlaced ( unit ) ;
85997: LD_ADDR_VAR 0 4
86001: PUSH
86002: LD_VAR 0 1
86006: PPUSH
86007: CALL_OW 305
86011: ST_TO_ADDR
// exit ;
86012: POP
86013: POP
86014: GO 86020
// end ; end ;
86016: GO 85883
86018: POP
86019: POP
// end ;
86020: LD_VAR 0 4
86024: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
86025: LD_INT 0
86027: PPUSH
86028: PPUSH
86029: PPUSH
// if not side or side > 8 then
86030: LD_VAR 0 1
86034: NOT
86035: PUSH
86036: LD_VAR 0 1
86040: PUSH
86041: LD_INT 8
86043: GREATER
86044: OR
86045: IFFALSE 86049
// exit ;
86047: GO 86236
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86049: LD_ADDR_VAR 0 4
86053: PUSH
86054: LD_INT 22
86056: PUSH
86057: LD_VAR 0 1
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 21
86068: PUSH
86069: LD_INT 3
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PPUSH
86080: CALL_OW 69
86084: ST_TO_ADDR
// if not tmp then
86085: LD_VAR 0 4
86089: NOT
86090: IFFALSE 86094
// exit ;
86092: GO 86236
// enable_addtolog := true ;
86094: LD_ADDR_OWVAR 81
86098: PUSH
86099: LD_INT 1
86101: ST_TO_ADDR
// AddToLog ( [ ) ;
86102: LD_STRING [
86104: PPUSH
86105: CALL_OW 561
// for i in tmp do
86109: LD_ADDR_VAR 0 3
86113: PUSH
86114: LD_VAR 0 4
86118: PUSH
86119: FOR_IN
86120: IFFALSE 86227
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86122: LD_STRING [
86124: PUSH
86125: LD_VAR 0 3
86129: PPUSH
86130: CALL_OW 266
86134: STR
86135: PUSH
86136: LD_STRING , 
86138: STR
86139: PUSH
86140: LD_VAR 0 3
86144: PPUSH
86145: CALL_OW 250
86149: STR
86150: PUSH
86151: LD_STRING , 
86153: STR
86154: PUSH
86155: LD_VAR 0 3
86159: PPUSH
86160: CALL_OW 251
86164: STR
86165: PUSH
86166: LD_STRING , 
86168: STR
86169: PUSH
86170: LD_VAR 0 3
86174: PPUSH
86175: CALL_OW 254
86179: STR
86180: PUSH
86181: LD_STRING , 
86183: STR
86184: PUSH
86185: LD_VAR 0 3
86189: PPUSH
86190: LD_INT 1
86192: PPUSH
86193: CALL_OW 268
86197: STR
86198: PUSH
86199: LD_STRING , 
86201: STR
86202: PUSH
86203: LD_VAR 0 3
86207: PPUSH
86208: LD_INT 2
86210: PPUSH
86211: CALL_OW 268
86215: STR
86216: PUSH
86217: LD_STRING ],
86219: STR
86220: PPUSH
86221: CALL_OW 561
// end ;
86225: GO 86119
86227: POP
86228: POP
// AddToLog ( ]; ) ;
86229: LD_STRING ];
86231: PPUSH
86232: CALL_OW 561
// end ;
86236: LD_VAR 0 2
86240: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86241: LD_INT 0
86243: PPUSH
86244: PPUSH
86245: PPUSH
86246: PPUSH
86247: PPUSH
// if not area or not rate or not max then
86248: LD_VAR 0 1
86252: NOT
86253: PUSH
86254: LD_VAR 0 2
86258: NOT
86259: OR
86260: PUSH
86261: LD_VAR 0 4
86265: NOT
86266: OR
86267: IFFALSE 86271
// exit ;
86269: GO 86460
// while 1 do
86271: LD_INT 1
86273: IFFALSE 86460
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86275: LD_ADDR_VAR 0 9
86279: PUSH
86280: LD_VAR 0 1
86284: PPUSH
86285: LD_INT 1
86287: PPUSH
86288: CALL_OW 287
86292: PUSH
86293: LD_INT 10
86295: MUL
86296: ST_TO_ADDR
// r := rate / 10 ;
86297: LD_ADDR_VAR 0 7
86301: PUSH
86302: LD_VAR 0 2
86306: PUSH
86307: LD_INT 10
86309: DIVREAL
86310: ST_TO_ADDR
// time := 1 1$00 ;
86311: LD_ADDR_VAR 0 8
86315: PUSH
86316: LD_INT 2100
86318: ST_TO_ADDR
// if amount < min then
86319: LD_VAR 0 9
86323: PUSH
86324: LD_VAR 0 3
86328: LESS
86329: IFFALSE 86347
// r := r * 2 else
86331: LD_ADDR_VAR 0 7
86335: PUSH
86336: LD_VAR 0 7
86340: PUSH
86341: LD_INT 2
86343: MUL
86344: ST_TO_ADDR
86345: GO 86373
// if amount > max then
86347: LD_VAR 0 9
86351: PUSH
86352: LD_VAR 0 4
86356: GREATER
86357: IFFALSE 86373
// r := r / 2 ;
86359: LD_ADDR_VAR 0 7
86363: PUSH
86364: LD_VAR 0 7
86368: PUSH
86369: LD_INT 2
86371: DIVREAL
86372: ST_TO_ADDR
// time := time / r ;
86373: LD_ADDR_VAR 0 8
86377: PUSH
86378: LD_VAR 0 8
86382: PUSH
86383: LD_VAR 0 7
86387: DIVREAL
86388: ST_TO_ADDR
// if time < 0 then
86389: LD_VAR 0 8
86393: PUSH
86394: LD_INT 0
86396: LESS
86397: IFFALSE 86414
// time := time * - 1 ;
86399: LD_ADDR_VAR 0 8
86403: PUSH
86404: LD_VAR 0 8
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: MUL
86413: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86414: LD_VAR 0 8
86418: PUSH
86419: LD_INT 35
86421: PPUSH
86422: LD_INT 875
86424: PPUSH
86425: CALL_OW 12
86429: PLUS
86430: PPUSH
86431: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86435: LD_INT 1
86437: PPUSH
86438: LD_INT 5
86440: PPUSH
86441: CALL_OW 12
86445: PPUSH
86446: LD_VAR 0 1
86450: PPUSH
86451: LD_INT 1
86453: PPUSH
86454: CALL_OW 55
// end ;
86458: GO 86271
// end ;
86460: LD_VAR 0 5
86464: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86465: LD_INT 0
86467: PPUSH
86468: PPUSH
86469: PPUSH
86470: PPUSH
86471: PPUSH
86472: PPUSH
86473: PPUSH
86474: PPUSH
// if not turrets or not factories then
86475: LD_VAR 0 1
86479: NOT
86480: PUSH
86481: LD_VAR 0 2
86485: NOT
86486: OR
86487: IFFALSE 86491
// exit ;
86489: GO 86798
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86491: LD_ADDR_VAR 0 10
86495: PUSH
86496: LD_INT 5
86498: PUSH
86499: LD_INT 6
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: PUSH
86506: LD_INT 2
86508: PUSH
86509: LD_INT 4
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 3
86518: PUSH
86519: LD_INT 5
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 24
86533: PUSH
86534: LD_INT 25
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 23
86543: PUSH
86544: LD_INT 27
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 42
86557: PUSH
86558: LD_INT 43
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 44
86567: PUSH
86568: LD_INT 46
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 45
86577: PUSH
86578: LD_INT 47
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: LIST
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: LIST
86594: ST_TO_ADDR
// result := [ ] ;
86595: LD_ADDR_VAR 0 3
86599: PUSH
86600: EMPTY
86601: ST_TO_ADDR
// for i in turrets do
86602: LD_ADDR_VAR 0 4
86606: PUSH
86607: LD_VAR 0 1
86611: PUSH
86612: FOR_IN
86613: IFFALSE 86796
// begin nat := GetNation ( i ) ;
86615: LD_ADDR_VAR 0 7
86619: PUSH
86620: LD_VAR 0 4
86624: PPUSH
86625: CALL_OW 248
86629: ST_TO_ADDR
// weapon := 0 ;
86630: LD_ADDR_VAR 0 8
86634: PUSH
86635: LD_INT 0
86637: ST_TO_ADDR
// if not nat then
86638: LD_VAR 0 7
86642: NOT
86643: IFFALSE 86647
// continue ;
86645: GO 86612
// for j in list [ nat ] do
86647: LD_ADDR_VAR 0 5
86651: PUSH
86652: LD_VAR 0 10
86656: PUSH
86657: LD_VAR 0 7
86661: ARRAY
86662: PUSH
86663: FOR_IN
86664: IFFALSE 86705
// if GetBWeapon ( i ) = j [ 1 ] then
86666: LD_VAR 0 4
86670: PPUSH
86671: CALL_OW 269
86675: PUSH
86676: LD_VAR 0 5
86680: PUSH
86681: LD_INT 1
86683: ARRAY
86684: EQUAL
86685: IFFALSE 86703
// begin weapon := j [ 2 ] ;
86687: LD_ADDR_VAR 0 8
86691: PUSH
86692: LD_VAR 0 5
86696: PUSH
86697: LD_INT 2
86699: ARRAY
86700: ST_TO_ADDR
// break ;
86701: GO 86705
// end ;
86703: GO 86663
86705: POP
86706: POP
// if not weapon then
86707: LD_VAR 0 8
86711: NOT
86712: IFFALSE 86716
// continue ;
86714: GO 86612
// for k in factories do
86716: LD_ADDR_VAR 0 6
86720: PUSH
86721: LD_VAR 0 2
86725: PUSH
86726: FOR_IN
86727: IFFALSE 86792
// begin weapons := AvailableWeaponList ( k ) ;
86729: LD_ADDR_VAR 0 9
86733: PUSH
86734: LD_VAR 0 6
86738: PPUSH
86739: CALL_OW 478
86743: ST_TO_ADDR
// if not weapons then
86744: LD_VAR 0 9
86748: NOT
86749: IFFALSE 86753
// continue ;
86751: GO 86726
// if weapon in weapons then
86753: LD_VAR 0 8
86757: PUSH
86758: LD_VAR 0 9
86762: IN
86763: IFFALSE 86790
// begin result := [ i , weapon ] ;
86765: LD_ADDR_VAR 0 3
86769: PUSH
86770: LD_VAR 0 4
86774: PUSH
86775: LD_VAR 0 8
86779: PUSH
86780: EMPTY
86781: LIST
86782: LIST
86783: ST_TO_ADDR
// exit ;
86784: POP
86785: POP
86786: POP
86787: POP
86788: GO 86798
// end ; end ;
86790: GO 86726
86792: POP
86793: POP
// end ;
86794: GO 86612
86796: POP
86797: POP
// end ;
86798: LD_VAR 0 3
86802: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86803: LD_INT 0
86805: PPUSH
// if not side or side > 8 then
86806: LD_VAR 0 3
86810: NOT
86811: PUSH
86812: LD_VAR 0 3
86816: PUSH
86817: LD_INT 8
86819: GREATER
86820: OR
86821: IFFALSE 86825
// exit ;
86823: GO 86884
// if not range then
86825: LD_VAR 0 4
86829: NOT
86830: IFFALSE 86841
// range := - 12 ;
86832: LD_ADDR_VAR 0 4
86836: PUSH
86837: LD_INT 12
86839: NEG
86840: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86841: LD_VAR 0 1
86845: PPUSH
86846: LD_VAR 0 2
86850: PPUSH
86851: LD_VAR 0 3
86855: PPUSH
86856: LD_VAR 0 4
86860: PPUSH
86861: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86865: LD_VAR 0 1
86869: PPUSH
86870: LD_VAR 0 2
86874: PPUSH
86875: LD_VAR 0 3
86879: PPUSH
86880: CALL_OW 331
// end ;
86884: LD_VAR 0 5
86888: RET
// export function Video ( mode ) ; begin
86889: LD_INT 0
86891: PPUSH
// ingame_video = mode ;
86892: LD_ADDR_OWVAR 52
86896: PUSH
86897: LD_VAR 0 1
86901: ST_TO_ADDR
// interface_hidden = mode ;
86902: LD_ADDR_OWVAR 54
86906: PUSH
86907: LD_VAR 0 1
86911: ST_TO_ADDR
// end ;
86912: LD_VAR 0 2
86916: RET
// export function Join ( array , element ) ; begin
86917: LD_INT 0
86919: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86920: LD_ADDR_VAR 0 3
86924: PUSH
86925: LD_VAR 0 1
86929: PPUSH
86930: LD_VAR 0 1
86934: PUSH
86935: LD_INT 1
86937: PLUS
86938: PPUSH
86939: LD_VAR 0 2
86943: PPUSH
86944: CALL_OW 1
86948: ST_TO_ADDR
// end ;
86949: LD_VAR 0 3
86953: RET
// export function JoinUnion ( array , element ) ; begin
86954: LD_INT 0
86956: PPUSH
// result := array union element ;
86957: LD_ADDR_VAR 0 3
86961: PUSH
86962: LD_VAR 0 1
86966: PUSH
86967: LD_VAR 0 2
86971: UNION
86972: ST_TO_ADDR
// end ;
86973: LD_VAR 0 3
86977: RET
// export function GetBehemoths ( side ) ; begin
86978: LD_INT 0
86980: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86981: LD_ADDR_VAR 0 2
86985: PUSH
86986: LD_INT 22
86988: PUSH
86989: LD_VAR 0 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 31
87000: PUSH
87001: LD_INT 25
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PPUSH
87012: CALL_OW 69
87016: ST_TO_ADDR
// end ;
87017: LD_VAR 0 2
87021: RET
// export function Shuffle ( array ) ; var i , index ; begin
87022: LD_INT 0
87024: PPUSH
87025: PPUSH
87026: PPUSH
// result := [ ] ;
87027: LD_ADDR_VAR 0 2
87031: PUSH
87032: EMPTY
87033: ST_TO_ADDR
// if not array then
87034: LD_VAR 0 1
87038: NOT
87039: IFFALSE 87043
// exit ;
87041: GO 87142
// Randomize ;
87043: CALL_OW 10
// for i = array downto 1 do
87047: LD_ADDR_VAR 0 3
87051: PUSH
87052: DOUBLE
87053: LD_VAR 0 1
87057: INC
87058: ST_TO_ADDR
87059: LD_INT 1
87061: PUSH
87062: FOR_DOWNTO
87063: IFFALSE 87140
// begin index := rand ( 1 , array ) ;
87065: LD_ADDR_VAR 0 4
87069: PUSH
87070: LD_INT 1
87072: PPUSH
87073: LD_VAR 0 1
87077: PPUSH
87078: CALL_OW 12
87082: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87083: LD_ADDR_VAR 0 2
87087: PUSH
87088: LD_VAR 0 2
87092: PPUSH
87093: LD_VAR 0 2
87097: PUSH
87098: LD_INT 1
87100: PLUS
87101: PPUSH
87102: LD_VAR 0 1
87106: PUSH
87107: LD_VAR 0 4
87111: ARRAY
87112: PPUSH
87113: CALL_OW 2
87117: ST_TO_ADDR
// array := Delete ( array , index ) ;
87118: LD_ADDR_VAR 0 1
87122: PUSH
87123: LD_VAR 0 1
87127: PPUSH
87128: LD_VAR 0 4
87132: PPUSH
87133: CALL_OW 3
87137: ST_TO_ADDR
// end ;
87138: GO 87062
87140: POP
87141: POP
// end ;
87142: LD_VAR 0 2
87146: RET
// export function GetBaseMaterials ( base ) ; begin
87147: LD_INT 0
87149: PPUSH
// result := [ 0 , 0 , 0 ] ;
87150: LD_ADDR_VAR 0 2
87154: PUSH
87155: LD_INT 0
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: LIST
87168: ST_TO_ADDR
// if not base then
87169: LD_VAR 0 1
87173: NOT
87174: IFFALSE 87178
// exit ;
87176: GO 87227
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87178: LD_ADDR_VAR 0 2
87182: PUSH
87183: LD_VAR 0 1
87187: PPUSH
87188: LD_INT 1
87190: PPUSH
87191: CALL_OW 275
87195: PUSH
87196: LD_VAR 0 1
87200: PPUSH
87201: LD_INT 2
87203: PPUSH
87204: CALL_OW 275
87208: PUSH
87209: LD_VAR 0 1
87213: PPUSH
87214: LD_INT 3
87216: PPUSH
87217: CALL_OW 275
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: LIST
87226: ST_TO_ADDR
// end ;
87227: LD_VAR 0 2
87231: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87232: LD_INT 0
87234: PPUSH
87235: PPUSH
// result := array ;
87236: LD_ADDR_VAR 0 3
87240: PUSH
87241: LD_VAR 0 1
87245: ST_TO_ADDR
// if size >= result then
87246: LD_VAR 0 2
87250: PUSH
87251: LD_VAR 0 3
87255: GREATEREQUAL
87256: IFFALSE 87260
// exit ;
87258: GO 87310
// if size then
87260: LD_VAR 0 2
87264: IFFALSE 87310
// for i := array downto size do
87266: LD_ADDR_VAR 0 4
87270: PUSH
87271: DOUBLE
87272: LD_VAR 0 1
87276: INC
87277: ST_TO_ADDR
87278: LD_VAR 0 2
87282: PUSH
87283: FOR_DOWNTO
87284: IFFALSE 87308
// result := Delete ( result , result ) ;
87286: LD_ADDR_VAR 0 3
87290: PUSH
87291: LD_VAR 0 3
87295: PPUSH
87296: LD_VAR 0 3
87300: PPUSH
87301: CALL_OW 3
87305: ST_TO_ADDR
87306: GO 87283
87308: POP
87309: POP
// end ;
87310: LD_VAR 0 3
87314: RET
// export function ComExit ( unit ) ; var tmp ; begin
87315: LD_INT 0
87317: PPUSH
87318: PPUSH
// if not IsInUnit ( unit ) then
87319: LD_VAR 0 1
87323: PPUSH
87324: CALL_OW 310
87328: NOT
87329: IFFALSE 87333
// exit ;
87331: GO 87393
// tmp := IsInUnit ( unit ) ;
87333: LD_ADDR_VAR 0 3
87337: PUSH
87338: LD_VAR 0 1
87342: PPUSH
87343: CALL_OW 310
87347: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87348: LD_VAR 0 3
87352: PPUSH
87353: CALL_OW 247
87357: PUSH
87358: LD_INT 2
87360: EQUAL
87361: IFFALSE 87374
// ComExitVehicle ( unit ) else
87363: LD_VAR 0 1
87367: PPUSH
87368: CALL_OW 121
87372: GO 87383
// ComExitBuilding ( unit ) ;
87374: LD_VAR 0 1
87378: PPUSH
87379: CALL_OW 122
// result := tmp ;
87383: LD_ADDR_VAR 0 2
87387: PUSH
87388: LD_VAR 0 3
87392: ST_TO_ADDR
// end ;
87393: LD_VAR 0 2
87397: RET
// export function ComExitAll ( units ) ; var i ; begin
87398: LD_INT 0
87400: PPUSH
87401: PPUSH
// if not units then
87402: LD_VAR 0 1
87406: NOT
87407: IFFALSE 87411
// exit ;
87409: GO 87437
// for i in units do
87411: LD_ADDR_VAR 0 3
87415: PUSH
87416: LD_VAR 0 1
87420: PUSH
87421: FOR_IN
87422: IFFALSE 87435
// ComExit ( i ) ;
87424: LD_VAR 0 3
87428: PPUSH
87429: CALL 87315 0 1
87433: GO 87421
87435: POP
87436: POP
// end ;
87437: LD_VAR 0 2
87441: RET
// export function ResetHc ; begin
87442: LD_INT 0
87444: PPUSH
// InitHc ;
87445: CALL_OW 19
// hc_importance := 0 ;
87449: LD_ADDR_OWVAR 32
87453: PUSH
87454: LD_INT 0
87456: ST_TO_ADDR
// end ;
87457: LD_VAR 0 1
87461: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87462: LD_INT 0
87464: PPUSH
87465: PPUSH
87466: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87467: LD_ADDR_VAR 0 6
87471: PUSH
87472: LD_VAR 0 1
87476: PUSH
87477: LD_VAR 0 3
87481: PLUS
87482: PUSH
87483: LD_INT 2
87485: DIV
87486: ST_TO_ADDR
// if _x < 0 then
87487: LD_VAR 0 6
87491: PUSH
87492: LD_INT 0
87494: LESS
87495: IFFALSE 87512
// _x := _x * - 1 ;
87497: LD_ADDR_VAR 0 6
87501: PUSH
87502: LD_VAR 0 6
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: MUL
87511: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87512: LD_ADDR_VAR 0 7
87516: PUSH
87517: LD_VAR 0 2
87521: PUSH
87522: LD_VAR 0 4
87526: PLUS
87527: PUSH
87528: LD_INT 2
87530: DIV
87531: ST_TO_ADDR
// if _y < 0 then
87532: LD_VAR 0 7
87536: PUSH
87537: LD_INT 0
87539: LESS
87540: IFFALSE 87557
// _y := _y * - 1 ;
87542: LD_ADDR_VAR 0 7
87546: PUSH
87547: LD_VAR 0 7
87551: PUSH
87552: LD_INT 1
87554: NEG
87555: MUL
87556: ST_TO_ADDR
// result := [ _x , _y ] ;
87557: LD_ADDR_VAR 0 5
87561: PUSH
87562: LD_VAR 0 6
87566: PUSH
87567: LD_VAR 0 7
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: ST_TO_ADDR
// end ;
87576: LD_VAR 0 5
87580: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87581: LD_INT 0
87583: PPUSH
87584: PPUSH
87585: PPUSH
87586: PPUSH
// task := GetTaskList ( unit ) ;
87587: LD_ADDR_VAR 0 7
87591: PUSH
87592: LD_VAR 0 1
87596: PPUSH
87597: CALL_OW 437
87601: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87602: LD_VAR 0 7
87606: NOT
87607: PUSH
87608: LD_VAR 0 1
87612: PPUSH
87613: LD_VAR 0 2
87617: PPUSH
87618: CALL_OW 308
87622: NOT
87623: AND
87624: IFFALSE 87628
// exit ;
87626: GO 87746
// if IsInArea ( unit , area ) then
87628: LD_VAR 0 1
87632: PPUSH
87633: LD_VAR 0 2
87637: PPUSH
87638: CALL_OW 308
87642: IFFALSE 87660
// begin ComMoveToArea ( unit , goAway ) ;
87644: LD_VAR 0 1
87648: PPUSH
87649: LD_VAR 0 3
87653: PPUSH
87654: CALL_OW 113
// exit ;
87658: GO 87746
// end ; if task [ 1 ] [ 1 ] <> M then
87660: LD_VAR 0 7
87664: PUSH
87665: LD_INT 1
87667: ARRAY
87668: PUSH
87669: LD_INT 1
87671: ARRAY
87672: PUSH
87673: LD_STRING M
87675: NONEQUAL
87676: IFFALSE 87680
// exit ;
87678: GO 87746
// x := task [ 1 ] [ 2 ] ;
87680: LD_ADDR_VAR 0 5
87684: PUSH
87685: LD_VAR 0 7
87689: PUSH
87690: LD_INT 1
87692: ARRAY
87693: PUSH
87694: LD_INT 2
87696: ARRAY
87697: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87698: LD_ADDR_VAR 0 6
87702: PUSH
87703: LD_VAR 0 7
87707: PUSH
87708: LD_INT 1
87710: ARRAY
87711: PUSH
87712: LD_INT 3
87714: ARRAY
87715: ST_TO_ADDR
// if InArea ( x , y , area ) then
87716: LD_VAR 0 5
87720: PPUSH
87721: LD_VAR 0 6
87725: PPUSH
87726: LD_VAR 0 2
87730: PPUSH
87731: CALL_OW 309
87735: IFFALSE 87746
// ComStop ( unit ) ;
87737: LD_VAR 0 1
87741: PPUSH
87742: CALL_OW 141
// end ;
87746: LD_VAR 0 4
87750: RET
// export function Abs ( value ) ; begin
87751: LD_INT 0
87753: PPUSH
// result := value ;
87754: LD_ADDR_VAR 0 2
87758: PUSH
87759: LD_VAR 0 1
87763: ST_TO_ADDR
// if value < 0 then
87764: LD_VAR 0 1
87768: PUSH
87769: LD_INT 0
87771: LESS
87772: IFFALSE 87789
// result := value * - 1 ;
87774: LD_ADDR_VAR 0 2
87778: PUSH
87779: LD_VAR 0 1
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: MUL
87788: ST_TO_ADDR
// end ;
87789: LD_VAR 0 2
87793: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87794: LD_INT 0
87796: PPUSH
87797: PPUSH
87798: PPUSH
87799: PPUSH
87800: PPUSH
87801: PPUSH
87802: PPUSH
87803: PPUSH
// if not unit or not building then
87804: LD_VAR 0 1
87808: NOT
87809: PUSH
87810: LD_VAR 0 2
87814: NOT
87815: OR
87816: IFFALSE 87820
// exit ;
87818: GO 88046
// x := GetX ( building ) ;
87820: LD_ADDR_VAR 0 4
87824: PUSH
87825: LD_VAR 0 2
87829: PPUSH
87830: CALL_OW 250
87834: ST_TO_ADDR
// y := GetY ( building ) ;
87835: LD_ADDR_VAR 0 6
87839: PUSH
87840: LD_VAR 0 2
87844: PPUSH
87845: CALL_OW 251
87849: ST_TO_ADDR
// d := GetDir ( building ) ;
87850: LD_ADDR_VAR 0 8
87854: PUSH
87855: LD_VAR 0 2
87859: PPUSH
87860: CALL_OW 254
87864: ST_TO_ADDR
// r := 4 ;
87865: LD_ADDR_VAR 0 9
87869: PUSH
87870: LD_INT 4
87872: ST_TO_ADDR
// for i := 1 to 5 do
87873: LD_ADDR_VAR 0 10
87877: PUSH
87878: DOUBLE
87879: LD_INT 1
87881: DEC
87882: ST_TO_ADDR
87883: LD_INT 5
87885: PUSH
87886: FOR_TO
87887: IFFALSE 88044
// begin _x := ShiftX ( x , d , r + i ) ;
87889: LD_ADDR_VAR 0 5
87893: PUSH
87894: LD_VAR 0 4
87898: PPUSH
87899: LD_VAR 0 8
87903: PPUSH
87904: LD_VAR 0 9
87908: PUSH
87909: LD_VAR 0 10
87913: PLUS
87914: PPUSH
87915: CALL_OW 272
87919: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87920: LD_ADDR_VAR 0 7
87924: PUSH
87925: LD_VAR 0 6
87929: PPUSH
87930: LD_VAR 0 8
87934: PPUSH
87935: LD_VAR 0 9
87939: PUSH
87940: LD_VAR 0 10
87944: PLUS
87945: PPUSH
87946: CALL_OW 273
87950: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87951: LD_VAR 0 5
87955: PPUSH
87956: LD_VAR 0 7
87960: PPUSH
87961: CALL_OW 488
87965: PUSH
87966: LD_VAR 0 5
87970: PPUSH
87971: LD_VAR 0 7
87975: PPUSH
87976: CALL_OW 428
87980: PPUSH
87981: CALL_OW 247
87985: PUSH
87986: LD_INT 3
87988: PUSH
87989: LD_INT 2
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: IN
87996: NOT
87997: AND
87998: IFFALSE 88042
// begin ComMoveXY ( unit , _x , _y ) ;
88000: LD_VAR 0 1
88004: PPUSH
88005: LD_VAR 0 5
88009: PPUSH
88010: LD_VAR 0 7
88014: PPUSH
88015: CALL_OW 111
// result := [ _x , _y ] ;
88019: LD_ADDR_VAR 0 3
88023: PUSH
88024: LD_VAR 0 5
88028: PUSH
88029: LD_VAR 0 7
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: ST_TO_ADDR
// exit ;
88038: POP
88039: POP
88040: GO 88046
// end ; end ;
88042: GO 87886
88044: POP
88045: POP
// end ;
88046: LD_VAR 0 3
88050: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88051: LD_INT 0
88053: PPUSH
88054: PPUSH
88055: PPUSH
// result := 0 ;
88056: LD_ADDR_VAR 0 3
88060: PUSH
88061: LD_INT 0
88063: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88064: LD_VAR 0 1
88068: PUSH
88069: LD_INT 0
88071: LESS
88072: PUSH
88073: LD_VAR 0 1
88077: PUSH
88078: LD_INT 8
88080: GREATER
88081: OR
88082: PUSH
88083: LD_VAR 0 2
88087: PUSH
88088: LD_INT 0
88090: LESS
88091: OR
88092: PUSH
88093: LD_VAR 0 2
88097: PUSH
88098: LD_INT 8
88100: GREATER
88101: OR
88102: IFFALSE 88106
// exit ;
88104: GO 88181
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88106: LD_ADDR_VAR 0 4
88110: PUSH
88111: LD_INT 22
88113: PUSH
88114: LD_VAR 0 2
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PPUSH
88123: CALL_OW 69
88127: PUSH
88128: FOR_IN
88129: IFFALSE 88179
// begin un := UnitShoot ( i ) ;
88131: LD_ADDR_VAR 0 5
88135: PUSH
88136: LD_VAR 0 4
88140: PPUSH
88141: CALL_OW 504
88145: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88146: LD_VAR 0 5
88150: PPUSH
88151: CALL_OW 255
88155: PUSH
88156: LD_VAR 0 1
88160: EQUAL
88161: IFFALSE 88177
// begin result := un ;
88163: LD_ADDR_VAR 0 3
88167: PUSH
88168: LD_VAR 0 5
88172: ST_TO_ADDR
// exit ;
88173: POP
88174: POP
88175: GO 88181
// end ; end ;
88177: GO 88128
88179: POP
88180: POP
// end ;
88181: LD_VAR 0 3
88185: RET
// export function GetCargoBay ( units ) ; begin
88186: LD_INT 0
88188: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88189: LD_ADDR_VAR 0 2
88193: PUSH
88194: LD_VAR 0 1
88198: PPUSH
88199: LD_INT 2
88201: PUSH
88202: LD_INT 34
88204: PUSH
88205: LD_INT 12
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 34
88214: PUSH
88215: LD_INT 51
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 34
88224: PUSH
88225: LD_INT 32
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 34
88234: PUSH
88235: LD_INT 89
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: PPUSH
88249: CALL_OW 72
88253: ST_TO_ADDR
// end ;
88254: LD_VAR 0 2
88258: RET
// export function Negate ( value ) ; begin
88259: LD_INT 0
88261: PPUSH
// result := not value ;
88262: LD_ADDR_VAR 0 2
88266: PUSH
88267: LD_VAR 0 1
88271: NOT
88272: ST_TO_ADDR
// end ;
88273: LD_VAR 0 2
88277: RET
// export function Inc ( value ) ; begin
88278: LD_INT 0
88280: PPUSH
// result := value + 1 ;
88281: LD_ADDR_VAR 0 2
88285: PUSH
88286: LD_VAR 0 1
88290: PUSH
88291: LD_INT 1
88293: PLUS
88294: ST_TO_ADDR
// end ;
88295: LD_VAR 0 2
88299: RET
// export function Dec ( value ) ; begin
88300: LD_INT 0
88302: PPUSH
// result := value - 1 ;
88303: LD_ADDR_VAR 0 2
88307: PUSH
88308: LD_VAR 0 1
88312: PUSH
88313: LD_INT 1
88315: MINUS
88316: ST_TO_ADDR
// end ;
88317: LD_VAR 0 2
88321: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88322: LD_INT 0
88324: PPUSH
88325: PPUSH
88326: PPUSH
88327: PPUSH
88328: PPUSH
88329: PPUSH
88330: PPUSH
88331: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88332: LD_VAR 0 1
88336: PPUSH
88337: LD_VAR 0 2
88341: PPUSH
88342: CALL_OW 488
88346: NOT
88347: PUSH
88348: LD_VAR 0 3
88352: PPUSH
88353: LD_VAR 0 4
88357: PPUSH
88358: CALL_OW 488
88362: NOT
88363: OR
88364: IFFALSE 88377
// begin result := - 1 ;
88366: LD_ADDR_VAR 0 5
88370: PUSH
88371: LD_INT 1
88373: NEG
88374: ST_TO_ADDR
// exit ;
88375: GO 88612
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88377: LD_ADDR_VAR 0 12
88381: PUSH
88382: LD_VAR 0 1
88386: PPUSH
88387: LD_VAR 0 2
88391: PPUSH
88392: LD_VAR 0 3
88396: PPUSH
88397: LD_VAR 0 4
88401: PPUSH
88402: CALL 87462 0 4
88406: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88407: LD_ADDR_VAR 0 11
88411: PUSH
88412: LD_VAR 0 1
88416: PPUSH
88417: LD_VAR 0 2
88421: PPUSH
88422: LD_VAR 0 12
88426: PUSH
88427: LD_INT 1
88429: ARRAY
88430: PPUSH
88431: LD_VAR 0 12
88435: PUSH
88436: LD_INT 2
88438: ARRAY
88439: PPUSH
88440: CALL_OW 298
88444: ST_TO_ADDR
// distance := 9999 ;
88445: LD_ADDR_VAR 0 10
88449: PUSH
88450: LD_INT 9999
88452: ST_TO_ADDR
// for i := 0 to 5 do
88453: LD_ADDR_VAR 0 6
88457: PUSH
88458: DOUBLE
88459: LD_INT 0
88461: DEC
88462: ST_TO_ADDR
88463: LD_INT 5
88465: PUSH
88466: FOR_TO
88467: IFFALSE 88610
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88469: LD_ADDR_VAR 0 7
88473: PUSH
88474: LD_VAR 0 1
88478: PPUSH
88479: LD_VAR 0 6
88483: PPUSH
88484: LD_VAR 0 11
88488: PPUSH
88489: CALL_OW 272
88493: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88494: LD_ADDR_VAR 0 8
88498: PUSH
88499: LD_VAR 0 2
88503: PPUSH
88504: LD_VAR 0 6
88508: PPUSH
88509: LD_VAR 0 11
88513: PPUSH
88514: CALL_OW 273
88518: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88519: LD_VAR 0 7
88523: PPUSH
88524: LD_VAR 0 8
88528: PPUSH
88529: CALL_OW 488
88533: NOT
88534: IFFALSE 88538
// continue ;
88536: GO 88466
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88538: LD_ADDR_VAR 0 9
88542: PUSH
88543: LD_VAR 0 12
88547: PUSH
88548: LD_INT 1
88550: ARRAY
88551: PPUSH
88552: LD_VAR 0 12
88556: PUSH
88557: LD_INT 2
88559: ARRAY
88560: PPUSH
88561: LD_VAR 0 7
88565: PPUSH
88566: LD_VAR 0 8
88570: PPUSH
88571: CALL_OW 298
88575: ST_TO_ADDR
// if tmp < distance then
88576: LD_VAR 0 9
88580: PUSH
88581: LD_VAR 0 10
88585: LESS
88586: IFFALSE 88608
// begin result := i ;
88588: LD_ADDR_VAR 0 5
88592: PUSH
88593: LD_VAR 0 6
88597: ST_TO_ADDR
// distance := tmp ;
88598: LD_ADDR_VAR 0 10
88602: PUSH
88603: LD_VAR 0 9
88607: ST_TO_ADDR
// end ; end ;
88608: GO 88466
88610: POP
88611: POP
// end ;
88612: LD_VAR 0 5
88616: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88617: LD_INT 0
88619: PPUSH
88620: PPUSH
// if not driver or not IsInUnit ( driver ) then
88621: LD_VAR 0 1
88625: NOT
88626: PUSH
88627: LD_VAR 0 1
88631: PPUSH
88632: CALL_OW 310
88636: NOT
88637: OR
88638: IFFALSE 88642
// exit ;
88640: GO 88732
// vehicle := IsInUnit ( driver ) ;
88642: LD_ADDR_VAR 0 3
88646: PUSH
88647: LD_VAR 0 1
88651: PPUSH
88652: CALL_OW 310
88656: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88657: LD_VAR 0 1
88661: PPUSH
88662: LD_STRING \
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: LD_INT 0
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: LD_INT 0
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: PUSH
88692: LD_STRING E
88694: PUSH
88695: LD_INT 0
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_VAR 0 3
88705: PUSH
88706: LD_INT 0
88708: PUSH
88709: LD_INT 0
88711: PUSH
88712: LD_INT 0
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PPUSH
88728: CALL_OW 446
// end ;
88732: LD_VAR 0 2
88736: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88737: LD_INT 0
88739: PPUSH
88740: PPUSH
// if not driver or not IsInUnit ( driver ) then
88741: LD_VAR 0 1
88745: NOT
88746: PUSH
88747: LD_VAR 0 1
88751: PPUSH
88752: CALL_OW 310
88756: NOT
88757: OR
88758: IFFALSE 88762
// exit ;
88760: GO 88852
// vehicle := IsInUnit ( driver ) ;
88762: LD_ADDR_VAR 0 3
88766: PUSH
88767: LD_VAR 0 1
88771: PPUSH
88772: CALL_OW 310
88776: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88777: LD_VAR 0 1
88781: PPUSH
88782: LD_STRING \
88784: PUSH
88785: LD_INT 0
88787: PUSH
88788: LD_INT 0
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: PUSH
88812: LD_STRING E
88814: PUSH
88815: LD_INT 0
88817: PUSH
88818: LD_INT 0
88820: PUSH
88821: LD_VAR 0 3
88825: PUSH
88826: LD_INT 0
88828: PUSH
88829: LD_INT 0
88831: PUSH
88832: LD_INT 0
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PPUSH
88848: CALL_OW 447
// end ;
88852: LD_VAR 0 2
88856: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88857: LD_INT 0
88859: PPUSH
88860: PPUSH
88861: PPUSH
// tmp := [ ] ;
88862: LD_ADDR_VAR 0 5
88866: PUSH
88867: EMPTY
88868: ST_TO_ADDR
// for i in units do
88869: LD_ADDR_VAR 0 4
88873: PUSH
88874: LD_VAR 0 1
88878: PUSH
88879: FOR_IN
88880: IFFALSE 88918
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88882: LD_ADDR_VAR 0 5
88886: PUSH
88887: LD_VAR 0 5
88891: PPUSH
88892: LD_VAR 0 5
88896: PUSH
88897: LD_INT 1
88899: PLUS
88900: PPUSH
88901: LD_VAR 0 4
88905: PPUSH
88906: CALL_OW 256
88910: PPUSH
88911: CALL_OW 2
88915: ST_TO_ADDR
88916: GO 88879
88918: POP
88919: POP
// if not tmp then
88920: LD_VAR 0 5
88924: NOT
88925: IFFALSE 88929
// exit ;
88927: GO 88977
// if asc then
88929: LD_VAR 0 2
88933: IFFALSE 88957
// result := SortListByListAsc ( units , tmp ) else
88935: LD_ADDR_VAR 0 3
88939: PUSH
88940: LD_VAR 0 1
88944: PPUSH
88945: LD_VAR 0 5
88949: PPUSH
88950: CALL_OW 76
88954: ST_TO_ADDR
88955: GO 88977
// result := SortListByListDesc ( units , tmp ) ;
88957: LD_ADDR_VAR 0 3
88961: PUSH
88962: LD_VAR 0 1
88966: PPUSH
88967: LD_VAR 0 5
88971: PPUSH
88972: CALL_OW 77
88976: ST_TO_ADDR
// end ;
88977: LD_VAR 0 3
88981: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88982: LD_INT 0
88984: PPUSH
88985: PPUSH
// task := GetTaskList ( mech ) ;
88986: LD_ADDR_VAR 0 4
88990: PUSH
88991: LD_VAR 0 1
88995: PPUSH
88996: CALL_OW 437
89000: ST_TO_ADDR
// if not task then
89001: LD_VAR 0 4
89005: NOT
89006: IFFALSE 89010
// exit ;
89008: GO 89052
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
89010: LD_ADDR_VAR 0 3
89014: PUSH
89015: LD_VAR 0 4
89019: PUSH
89020: LD_INT 1
89022: ARRAY
89023: PUSH
89024: LD_INT 1
89026: ARRAY
89027: PUSH
89028: LD_STRING r
89030: EQUAL
89031: PUSH
89032: LD_VAR 0 4
89036: PUSH
89037: LD_INT 1
89039: ARRAY
89040: PUSH
89041: LD_INT 4
89043: ARRAY
89044: PUSH
89045: LD_VAR 0 2
89049: EQUAL
89050: AND
89051: ST_TO_ADDR
// end ;
89052: LD_VAR 0 3
89056: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
89057: LD_INT 0
89059: PPUSH
// SetDir ( unit , d ) ;
89060: LD_VAR 0 1
89064: PPUSH
89065: LD_VAR 0 4
89069: PPUSH
89070: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
89074: LD_VAR 0 1
89078: PPUSH
89079: LD_VAR 0 2
89083: PPUSH
89084: LD_VAR 0 3
89088: PPUSH
89089: LD_VAR 0 5
89093: PPUSH
89094: CALL_OW 48
// end ;
89098: LD_VAR 0 6
89102: RET
// export function ToNaturalNumber ( number ) ; begin
89103: LD_INT 0
89105: PPUSH
// result := number div 1 ;
89106: LD_ADDR_VAR 0 2
89110: PUSH
89111: LD_VAR 0 1
89115: PUSH
89116: LD_INT 1
89118: DIV
89119: ST_TO_ADDR
// if number < 0 then
89120: LD_VAR 0 1
89124: PUSH
89125: LD_INT 0
89127: LESS
89128: IFFALSE 89138
// result := 0 ;
89130: LD_ADDR_VAR 0 2
89134: PUSH
89135: LD_INT 0
89137: ST_TO_ADDR
// end ;
89138: LD_VAR 0 2
89142: RET
// export function SortByClass ( units , class ) ; var un ; begin
89143: LD_INT 0
89145: PPUSH
89146: PPUSH
// if not units or not class then
89147: LD_VAR 0 1
89151: NOT
89152: PUSH
89153: LD_VAR 0 2
89157: NOT
89158: OR
89159: IFFALSE 89163
// exit ;
89161: GO 89258
// result := [ ] ;
89163: LD_ADDR_VAR 0 3
89167: PUSH
89168: EMPTY
89169: ST_TO_ADDR
// for un in units do
89170: LD_ADDR_VAR 0 4
89174: PUSH
89175: LD_VAR 0 1
89179: PUSH
89180: FOR_IN
89181: IFFALSE 89256
// if GetClass ( un ) = class then
89183: LD_VAR 0 4
89187: PPUSH
89188: CALL_OW 257
89192: PUSH
89193: LD_VAR 0 2
89197: EQUAL
89198: IFFALSE 89225
// result := Insert ( result , 1 , un ) else
89200: LD_ADDR_VAR 0 3
89204: PUSH
89205: LD_VAR 0 3
89209: PPUSH
89210: LD_INT 1
89212: PPUSH
89213: LD_VAR 0 4
89217: PPUSH
89218: CALL_OW 2
89222: ST_TO_ADDR
89223: GO 89254
// result := Replace ( result , result + 1 , un ) ;
89225: LD_ADDR_VAR 0 3
89229: PUSH
89230: LD_VAR 0 3
89234: PPUSH
89235: LD_VAR 0 3
89239: PUSH
89240: LD_INT 1
89242: PLUS
89243: PPUSH
89244: LD_VAR 0 4
89248: PPUSH
89249: CALL_OW 1
89253: ST_TO_ADDR
89254: GO 89180
89256: POP
89257: POP
// end ;
89258: LD_VAR 0 3
89262: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89263: LD_INT 0
89265: PPUSH
89266: PPUSH
89267: PPUSH
89268: PPUSH
89269: PPUSH
89270: PPUSH
89271: PPUSH
// result := [ ] ;
89272: LD_ADDR_VAR 0 4
89276: PUSH
89277: EMPTY
89278: ST_TO_ADDR
// if x - r < 0 then
89279: LD_VAR 0 1
89283: PUSH
89284: LD_VAR 0 3
89288: MINUS
89289: PUSH
89290: LD_INT 0
89292: LESS
89293: IFFALSE 89305
// min_x := 0 else
89295: LD_ADDR_VAR 0 8
89299: PUSH
89300: LD_INT 0
89302: ST_TO_ADDR
89303: GO 89321
// min_x := x - r ;
89305: LD_ADDR_VAR 0 8
89309: PUSH
89310: LD_VAR 0 1
89314: PUSH
89315: LD_VAR 0 3
89319: MINUS
89320: ST_TO_ADDR
// if y - r < 0 then
89321: LD_VAR 0 2
89325: PUSH
89326: LD_VAR 0 3
89330: MINUS
89331: PUSH
89332: LD_INT 0
89334: LESS
89335: IFFALSE 89347
// min_y := 0 else
89337: LD_ADDR_VAR 0 7
89341: PUSH
89342: LD_INT 0
89344: ST_TO_ADDR
89345: GO 89363
// min_y := y - r ;
89347: LD_ADDR_VAR 0 7
89351: PUSH
89352: LD_VAR 0 2
89356: PUSH
89357: LD_VAR 0 3
89361: MINUS
89362: ST_TO_ADDR
// max_x := x + r ;
89363: LD_ADDR_VAR 0 9
89367: PUSH
89368: LD_VAR 0 1
89372: PUSH
89373: LD_VAR 0 3
89377: PLUS
89378: ST_TO_ADDR
// max_y := y + r ;
89379: LD_ADDR_VAR 0 10
89383: PUSH
89384: LD_VAR 0 2
89388: PUSH
89389: LD_VAR 0 3
89393: PLUS
89394: ST_TO_ADDR
// for _x = min_x to max_x do
89395: LD_ADDR_VAR 0 5
89399: PUSH
89400: DOUBLE
89401: LD_VAR 0 8
89405: DEC
89406: ST_TO_ADDR
89407: LD_VAR 0 9
89411: PUSH
89412: FOR_TO
89413: IFFALSE 89514
// for _y = min_y to max_y do
89415: LD_ADDR_VAR 0 6
89419: PUSH
89420: DOUBLE
89421: LD_VAR 0 7
89425: DEC
89426: ST_TO_ADDR
89427: LD_VAR 0 10
89431: PUSH
89432: FOR_TO
89433: IFFALSE 89510
// begin if not ValidHex ( _x , _y ) then
89435: LD_VAR 0 5
89439: PPUSH
89440: LD_VAR 0 6
89444: PPUSH
89445: CALL_OW 488
89449: NOT
89450: IFFALSE 89454
// continue ;
89452: GO 89432
// if GetResourceTypeXY ( _x , _y ) then
89454: LD_VAR 0 5
89458: PPUSH
89459: LD_VAR 0 6
89463: PPUSH
89464: CALL_OW 283
89468: IFFALSE 89508
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89470: LD_ADDR_VAR 0 4
89474: PUSH
89475: LD_VAR 0 4
89479: PPUSH
89480: LD_VAR 0 4
89484: PUSH
89485: LD_INT 1
89487: PLUS
89488: PPUSH
89489: LD_VAR 0 5
89493: PUSH
89494: LD_VAR 0 6
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PPUSH
89503: CALL_OW 1
89507: ST_TO_ADDR
// end ;
89508: GO 89432
89510: POP
89511: POP
89512: GO 89412
89514: POP
89515: POP
// end ;
89516: LD_VAR 0 4
89520: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89521: LD_INT 0
89523: PPUSH
89524: PPUSH
89525: PPUSH
89526: PPUSH
89527: PPUSH
89528: PPUSH
89529: PPUSH
89530: PPUSH
// if not units then
89531: LD_VAR 0 1
89535: NOT
89536: IFFALSE 89540
// exit ;
89538: GO 90068
// result := UnitFilter ( units , [ f_ok ] ) ;
89540: LD_ADDR_VAR 0 3
89544: PUSH
89545: LD_VAR 0 1
89549: PPUSH
89550: LD_INT 50
89552: PUSH
89553: EMPTY
89554: LIST
89555: PPUSH
89556: CALL_OW 72
89560: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89561: LD_ADDR_VAR 0 8
89565: PUSH
89566: LD_VAR 0 1
89570: PUSH
89571: LD_INT 1
89573: ARRAY
89574: PPUSH
89575: CALL_OW 255
89579: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89580: LD_ADDR_VAR 0 10
89584: PUSH
89585: LD_INT 29
89587: PUSH
89588: LD_INT 91
89590: PUSH
89591: LD_INT 49
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: LIST
89598: ST_TO_ADDR
// if not result then
89599: LD_VAR 0 3
89603: NOT
89604: IFFALSE 89608
// exit ;
89606: GO 90068
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89608: LD_ADDR_VAR 0 5
89612: PUSH
89613: LD_INT 81
89615: PUSH
89616: LD_VAR 0 8
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PPUSH
89625: CALL_OW 69
89629: ST_TO_ADDR
// for i in result do
89630: LD_ADDR_VAR 0 4
89634: PUSH
89635: LD_VAR 0 3
89639: PUSH
89640: FOR_IN
89641: IFFALSE 90066
// begin tag := GetTag ( i ) + 1 ;
89643: LD_ADDR_VAR 0 9
89647: PUSH
89648: LD_VAR 0 4
89652: PPUSH
89653: CALL_OW 110
89657: PUSH
89658: LD_INT 1
89660: PLUS
89661: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
89662: LD_ADDR_VAR 0 7
89666: PUSH
89667: LD_VAR 0 4
89671: PPUSH
89672: CALL_OW 250
89676: PPUSH
89677: LD_VAR 0 4
89681: PPUSH
89682: CALL_OW 251
89686: PPUSH
89687: LD_INT 4
89689: PPUSH
89690: CALL 89263 0 3
89694: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
89695: LD_VAR 0 4
89699: PPUSH
89700: CALL_OW 247
89704: PUSH
89705: LD_INT 2
89707: EQUAL
89708: PUSH
89709: LD_VAR 0 7
89713: PUSH
89714: LD_INT 2
89716: GREATER
89717: AND
89718: PUSH
89719: LD_VAR 0 4
89723: PPUSH
89724: CALL_OW 264
89728: PUSH
89729: LD_VAR 0 10
89733: IN
89734: NOT
89735: AND
89736: IFFALSE 89775
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89738: LD_VAR 0 4
89742: PPUSH
89743: LD_VAR 0 7
89747: PUSH
89748: LD_INT 1
89750: ARRAY
89751: PUSH
89752: LD_INT 1
89754: ARRAY
89755: PPUSH
89756: LD_VAR 0 7
89760: PUSH
89761: LD_INT 1
89763: ARRAY
89764: PUSH
89765: LD_INT 2
89767: ARRAY
89768: PPUSH
89769: CALL_OW 116
89773: GO 90064
// if path > tag then
89775: LD_VAR 0 2
89779: PUSH
89780: LD_VAR 0 9
89784: GREATER
89785: IFFALSE 89993
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89787: LD_ADDR_VAR 0 6
89791: PUSH
89792: LD_VAR 0 5
89796: PPUSH
89797: LD_INT 91
89799: PUSH
89800: LD_VAR 0 4
89804: PUSH
89805: LD_INT 8
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: LIST
89812: PPUSH
89813: CALL_OW 72
89817: ST_TO_ADDR
// if nearEnemy then
89818: LD_VAR 0 6
89822: IFFALSE 89891
// begin if GetWeapon ( i ) = ru_time_lapser then
89824: LD_VAR 0 4
89828: PPUSH
89829: CALL_OW 264
89833: PUSH
89834: LD_INT 49
89836: EQUAL
89837: IFFALSE 89865
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89839: LD_VAR 0 4
89843: PPUSH
89844: LD_VAR 0 6
89848: PPUSH
89849: LD_VAR 0 4
89853: PPUSH
89854: CALL_OW 74
89858: PPUSH
89859: CALL_OW 112
89863: GO 89889
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89865: LD_VAR 0 4
89869: PPUSH
89870: LD_VAR 0 6
89874: PPUSH
89875: LD_VAR 0 4
89879: PPUSH
89880: CALL_OW 74
89884: PPUSH
89885: CALL 91139 0 2
// end else
89889: GO 89991
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89891: LD_VAR 0 4
89895: PPUSH
89896: LD_VAR 0 2
89900: PUSH
89901: LD_VAR 0 9
89905: ARRAY
89906: PUSH
89907: LD_INT 1
89909: ARRAY
89910: PPUSH
89911: LD_VAR 0 2
89915: PUSH
89916: LD_VAR 0 9
89920: ARRAY
89921: PUSH
89922: LD_INT 2
89924: ARRAY
89925: PPUSH
89926: CALL_OW 297
89930: PUSH
89931: LD_INT 6
89933: GREATER
89934: IFFALSE 89977
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89936: LD_VAR 0 4
89940: PPUSH
89941: LD_VAR 0 2
89945: PUSH
89946: LD_VAR 0 9
89950: ARRAY
89951: PUSH
89952: LD_INT 1
89954: ARRAY
89955: PPUSH
89956: LD_VAR 0 2
89960: PUSH
89961: LD_VAR 0 9
89965: ARRAY
89966: PUSH
89967: LD_INT 2
89969: ARRAY
89970: PPUSH
89971: CALL_OW 114
89975: GO 89991
// SetTag ( i , tag ) ;
89977: LD_VAR 0 4
89981: PPUSH
89982: LD_VAR 0 9
89986: PPUSH
89987: CALL_OW 109
// end else
89991: GO 90064
// if enemy then
89993: LD_VAR 0 5
89997: IFFALSE 90064
// begin if GetWeapon ( i ) = ru_time_lapser then
89999: LD_VAR 0 4
90003: PPUSH
90004: CALL_OW 264
90008: PUSH
90009: LD_INT 49
90011: EQUAL
90012: IFFALSE 90040
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
90014: LD_VAR 0 4
90018: PPUSH
90019: LD_VAR 0 5
90023: PPUSH
90024: LD_VAR 0 4
90028: PPUSH
90029: CALL_OW 74
90033: PPUSH
90034: CALL_OW 112
90038: GO 90064
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
90040: LD_VAR 0 4
90044: PPUSH
90045: LD_VAR 0 5
90049: PPUSH
90050: LD_VAR 0 4
90054: PPUSH
90055: CALL_OW 74
90059: PPUSH
90060: CALL 91139 0 2
// end ; end ;
90064: GO 89640
90066: POP
90067: POP
// end ;
90068: LD_VAR 0 3
90072: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
90073: LD_INT 0
90075: PPUSH
90076: PPUSH
90077: PPUSH
// if not unit or IsInUnit ( unit ) then
90078: LD_VAR 0 1
90082: NOT
90083: PUSH
90084: LD_VAR 0 1
90088: PPUSH
90089: CALL_OW 310
90093: OR
90094: IFFALSE 90098
// exit ;
90096: GO 90189
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
90098: LD_ADDR_VAR 0 4
90102: PUSH
90103: LD_VAR 0 1
90107: PPUSH
90108: CALL_OW 250
90112: PPUSH
90113: LD_VAR 0 2
90117: PPUSH
90118: LD_INT 1
90120: PPUSH
90121: CALL_OW 272
90125: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90126: LD_ADDR_VAR 0 5
90130: PUSH
90131: LD_VAR 0 1
90135: PPUSH
90136: CALL_OW 251
90140: PPUSH
90141: LD_VAR 0 2
90145: PPUSH
90146: LD_INT 1
90148: PPUSH
90149: CALL_OW 273
90153: ST_TO_ADDR
// if ValidHex ( x , y ) then
90154: LD_VAR 0 4
90158: PPUSH
90159: LD_VAR 0 5
90163: PPUSH
90164: CALL_OW 488
90168: IFFALSE 90189
// ComTurnXY ( unit , x , y ) ;
90170: LD_VAR 0 1
90174: PPUSH
90175: LD_VAR 0 4
90179: PPUSH
90180: LD_VAR 0 5
90184: PPUSH
90185: CALL_OW 118
// end ;
90189: LD_VAR 0 3
90193: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90194: LD_INT 0
90196: PPUSH
90197: PPUSH
// result := false ;
90198: LD_ADDR_VAR 0 3
90202: PUSH
90203: LD_INT 0
90205: ST_TO_ADDR
// if not units then
90206: LD_VAR 0 2
90210: NOT
90211: IFFALSE 90215
// exit ;
90213: GO 90260
// for i in units do
90215: LD_ADDR_VAR 0 4
90219: PUSH
90220: LD_VAR 0 2
90224: PUSH
90225: FOR_IN
90226: IFFALSE 90258
// if See ( side , i ) then
90228: LD_VAR 0 1
90232: PPUSH
90233: LD_VAR 0 4
90237: PPUSH
90238: CALL_OW 292
90242: IFFALSE 90256
// begin result := true ;
90244: LD_ADDR_VAR 0 3
90248: PUSH
90249: LD_INT 1
90251: ST_TO_ADDR
// exit ;
90252: POP
90253: POP
90254: GO 90260
// end ;
90256: GO 90225
90258: POP
90259: POP
// end ;
90260: LD_VAR 0 3
90264: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90265: LD_INT 0
90267: PPUSH
90268: PPUSH
90269: PPUSH
90270: PPUSH
// if not unit or not points then
90271: LD_VAR 0 1
90275: NOT
90276: PUSH
90277: LD_VAR 0 2
90281: NOT
90282: OR
90283: IFFALSE 90287
// exit ;
90285: GO 90377
// dist := 99999 ;
90287: LD_ADDR_VAR 0 5
90291: PUSH
90292: LD_INT 99999
90294: ST_TO_ADDR
// for i in points do
90295: LD_ADDR_VAR 0 4
90299: PUSH
90300: LD_VAR 0 2
90304: PUSH
90305: FOR_IN
90306: IFFALSE 90375
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90308: LD_ADDR_VAR 0 6
90312: PUSH
90313: LD_VAR 0 1
90317: PPUSH
90318: LD_VAR 0 4
90322: PUSH
90323: LD_INT 1
90325: ARRAY
90326: PPUSH
90327: LD_VAR 0 4
90331: PUSH
90332: LD_INT 2
90334: ARRAY
90335: PPUSH
90336: CALL_OW 297
90340: ST_TO_ADDR
// if tmpDist < dist then
90341: LD_VAR 0 6
90345: PUSH
90346: LD_VAR 0 5
90350: LESS
90351: IFFALSE 90373
// begin result := i ;
90353: LD_ADDR_VAR 0 3
90357: PUSH
90358: LD_VAR 0 4
90362: ST_TO_ADDR
// dist := tmpDist ;
90363: LD_ADDR_VAR 0 5
90367: PUSH
90368: LD_VAR 0 6
90372: ST_TO_ADDR
// end ; end ;
90373: GO 90305
90375: POP
90376: POP
// end ;
90377: LD_VAR 0 3
90381: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90382: LD_INT 0
90384: PPUSH
// uc_side := side ;
90385: LD_ADDR_OWVAR 20
90389: PUSH
90390: LD_VAR 0 1
90394: ST_TO_ADDR
// uc_nation := 3 ;
90395: LD_ADDR_OWVAR 21
90399: PUSH
90400: LD_INT 3
90402: ST_TO_ADDR
// vc_chassis := 25 ;
90403: LD_ADDR_OWVAR 37
90407: PUSH
90408: LD_INT 25
90410: ST_TO_ADDR
// vc_engine := engine_siberite ;
90411: LD_ADDR_OWVAR 39
90415: PUSH
90416: LD_INT 3
90418: ST_TO_ADDR
// vc_control := control_computer ;
90419: LD_ADDR_OWVAR 38
90423: PUSH
90424: LD_INT 3
90426: ST_TO_ADDR
// vc_weapon := 59 ;
90427: LD_ADDR_OWVAR 40
90431: PUSH
90432: LD_INT 59
90434: ST_TO_ADDR
// result := CreateVehicle ;
90435: LD_ADDR_VAR 0 5
90439: PUSH
90440: CALL_OW 45
90444: ST_TO_ADDR
// SetDir ( result , d ) ;
90445: LD_VAR 0 5
90449: PPUSH
90450: LD_VAR 0 4
90454: PPUSH
90455: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90459: LD_VAR 0 5
90463: PPUSH
90464: LD_VAR 0 2
90468: PPUSH
90469: LD_VAR 0 3
90473: PPUSH
90474: LD_INT 0
90476: PPUSH
90477: CALL_OW 48
// end ;
90481: LD_VAR 0 5
90485: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90486: LD_INT 0
90488: PPUSH
90489: PPUSH
90490: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90491: LD_ADDR_VAR 0 2
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: LD_INT 0
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90514: LD_VAR 0 1
90518: NOT
90519: PUSH
90520: LD_VAR 0 1
90524: PPUSH
90525: CALL_OW 264
90529: PUSH
90530: LD_INT 12
90532: PUSH
90533: LD_INT 51
90535: PUSH
90536: LD_INT 32
90538: PUSH
90539: LD_INT 89
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: IN
90548: NOT
90549: OR
90550: IFFALSE 90554
// exit ;
90552: GO 90652
// for i := 1 to 3 do
90554: LD_ADDR_VAR 0 3
90558: PUSH
90559: DOUBLE
90560: LD_INT 1
90562: DEC
90563: ST_TO_ADDR
90564: LD_INT 3
90566: PUSH
90567: FOR_TO
90568: IFFALSE 90650
// begin tmp := GetCargo ( cargo , i ) ;
90570: LD_ADDR_VAR 0 4
90574: PUSH
90575: LD_VAR 0 1
90579: PPUSH
90580: LD_VAR 0 3
90584: PPUSH
90585: CALL_OW 289
90589: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90590: LD_ADDR_VAR 0 2
90594: PUSH
90595: LD_VAR 0 2
90599: PPUSH
90600: LD_VAR 0 3
90604: PPUSH
90605: LD_VAR 0 4
90609: PPUSH
90610: CALL_OW 1
90614: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90615: LD_ADDR_VAR 0 2
90619: PUSH
90620: LD_VAR 0 2
90624: PPUSH
90625: LD_INT 4
90627: PPUSH
90628: LD_VAR 0 2
90632: PUSH
90633: LD_INT 4
90635: ARRAY
90636: PUSH
90637: LD_VAR 0 4
90641: PLUS
90642: PPUSH
90643: CALL_OW 1
90647: ST_TO_ADDR
// end ;
90648: GO 90567
90650: POP
90651: POP
// end ;
90652: LD_VAR 0 2
90656: RET
// export function Length ( array ) ; begin
90657: LD_INT 0
90659: PPUSH
// result := array + 0 ;
90660: LD_ADDR_VAR 0 2
90664: PUSH
90665: LD_VAR 0 1
90669: PUSH
90670: LD_INT 0
90672: PLUS
90673: ST_TO_ADDR
// end ;
90674: LD_VAR 0 2
90678: RET
// export function PrepareArray ( array ) ; begin
90679: LD_INT 0
90681: PPUSH
// result := array diff 0 ;
90682: LD_ADDR_VAR 0 2
90686: PUSH
90687: LD_VAR 0 1
90691: PUSH
90692: LD_INT 0
90694: DIFF
90695: ST_TO_ADDR
// if not result [ 1 ] then
90696: LD_VAR 0 2
90700: PUSH
90701: LD_INT 1
90703: ARRAY
90704: NOT
90705: IFFALSE 90725
// result := Delete ( result , 1 ) ;
90707: LD_ADDR_VAR 0 2
90711: PUSH
90712: LD_VAR 0 2
90716: PPUSH
90717: LD_INT 1
90719: PPUSH
90720: CALL_OW 3
90724: ST_TO_ADDR
// end ;
90725: LD_VAR 0 2
90729: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90730: LD_INT 0
90732: PPUSH
90733: PPUSH
90734: PPUSH
90735: PPUSH
// sibRocketRange := 25 ;
90736: LD_ADDR_VAR 0 6
90740: PUSH
90741: LD_INT 25
90743: ST_TO_ADDR
// result := false ;
90744: LD_ADDR_VAR 0 4
90748: PUSH
90749: LD_INT 0
90751: ST_TO_ADDR
// for i := 0 to 5 do
90752: LD_ADDR_VAR 0 5
90756: PUSH
90757: DOUBLE
90758: LD_INT 0
90760: DEC
90761: ST_TO_ADDR
90762: LD_INT 5
90764: PUSH
90765: FOR_TO
90766: IFFALSE 90833
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90768: LD_VAR 0 1
90772: PPUSH
90773: LD_VAR 0 5
90777: PPUSH
90778: LD_VAR 0 6
90782: PPUSH
90783: CALL_OW 272
90787: PPUSH
90788: LD_VAR 0 2
90792: PPUSH
90793: LD_VAR 0 5
90797: PPUSH
90798: LD_VAR 0 6
90802: PPUSH
90803: CALL_OW 273
90807: PPUSH
90808: LD_VAR 0 3
90812: PPUSH
90813: CALL_OW 309
90817: IFFALSE 90831
// begin result := true ;
90819: LD_ADDR_VAR 0 4
90823: PUSH
90824: LD_INT 1
90826: ST_TO_ADDR
// exit ;
90827: POP
90828: POP
90829: GO 90835
// end ;
90831: GO 90765
90833: POP
90834: POP
// end ;
90835: LD_VAR 0 4
90839: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
90840: LD_INT 0
90842: PPUSH
90843: PPUSH
90844: PPUSH
// if btype = b_depot then
90845: LD_VAR 0 2
90849: PUSH
90850: LD_INT 0
90852: EQUAL
90853: IFFALSE 90865
// begin result := true ;
90855: LD_ADDR_VAR 0 3
90859: PUSH
90860: LD_INT 1
90862: ST_TO_ADDR
// exit ;
90863: GO 90981
// end ; pom := GetBase ( depot ) ;
90865: LD_ADDR_VAR 0 4
90869: PUSH
90870: LD_VAR 0 1
90874: PPUSH
90875: CALL_OW 274
90879: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
90880: LD_ADDR_VAR 0 5
90884: PUSH
90885: LD_VAR 0 2
90889: PPUSH
90890: LD_VAR 0 1
90894: PPUSH
90895: CALL_OW 248
90899: PPUSH
90900: CALL_OW 450
90904: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
90905: LD_ADDR_VAR 0 3
90909: PUSH
90910: LD_VAR 0 4
90914: PPUSH
90915: LD_INT 1
90917: PPUSH
90918: CALL_OW 275
90922: PUSH
90923: LD_VAR 0 5
90927: PUSH
90928: LD_INT 1
90930: ARRAY
90931: GREATEREQUAL
90932: PUSH
90933: LD_VAR 0 4
90937: PPUSH
90938: LD_INT 2
90940: PPUSH
90941: CALL_OW 275
90945: PUSH
90946: LD_VAR 0 5
90950: PUSH
90951: LD_INT 2
90953: ARRAY
90954: GREATEREQUAL
90955: AND
90956: PUSH
90957: LD_VAR 0 4
90961: PPUSH
90962: LD_INT 3
90964: PPUSH
90965: CALL_OW 275
90969: PUSH
90970: LD_VAR 0 5
90974: PUSH
90975: LD_INT 3
90977: ARRAY
90978: GREATEREQUAL
90979: AND
90980: ST_TO_ADDR
// end ;
90981: LD_VAR 0 3
90985: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90986: LD_INT 0
90988: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90989: LD_VAR 0 1
90993: PPUSH
90994: LD_VAR 0 2
90998: PPUSH
90999: LD_INT 0
91001: PPUSH
91002: LD_INT 0
91004: PPUSH
91005: LD_INT 1
91007: PPUSH
91008: LD_INT 0
91010: PPUSH
91011: CALL_OW 587
// end ;
91015: LD_VAR 0 3
91019: RET
// export function CenterOnNow ( unit ) ; begin
91020: LD_INT 0
91022: PPUSH
// result := IsInUnit ( unit ) ;
91023: LD_ADDR_VAR 0 2
91027: PUSH
91028: LD_VAR 0 1
91032: PPUSH
91033: CALL_OW 310
91037: ST_TO_ADDR
// if not result then
91038: LD_VAR 0 2
91042: NOT
91043: IFFALSE 91055
// result := unit ;
91045: LD_ADDR_VAR 0 2
91049: PUSH
91050: LD_VAR 0 1
91054: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
91055: LD_VAR 0 1
91059: PPUSH
91060: CALL_OW 87
// end ;
91064: LD_VAR 0 2
91068: RET
// export function ComMoveHex ( unit , hex ) ; begin
91069: LD_INT 0
91071: PPUSH
// if not hex then
91072: LD_VAR 0 2
91076: NOT
91077: IFFALSE 91081
// exit ;
91079: GO 91134
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
91081: LD_VAR 0 2
91085: PUSH
91086: LD_INT 1
91088: ARRAY
91089: PPUSH
91090: LD_VAR 0 2
91094: PUSH
91095: LD_INT 2
91097: ARRAY
91098: PPUSH
91099: CALL_OW 428
91103: IFFALSE 91107
// exit ;
91105: GO 91134
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
91107: LD_VAR 0 1
91111: PPUSH
91112: LD_VAR 0 2
91116: PUSH
91117: LD_INT 1
91119: ARRAY
91120: PPUSH
91121: LD_VAR 0 2
91125: PUSH
91126: LD_INT 2
91128: ARRAY
91129: PPUSH
91130: CALL_OW 111
// end ;
91134: LD_VAR 0 3
91138: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
91139: LD_INT 0
91141: PPUSH
91142: PPUSH
91143: PPUSH
// if not unit or not enemy then
91144: LD_VAR 0 1
91148: NOT
91149: PUSH
91150: LD_VAR 0 2
91154: NOT
91155: OR
91156: IFFALSE 91160
// exit ;
91158: GO 91284
// x := GetX ( enemy ) ;
91160: LD_ADDR_VAR 0 4
91164: PUSH
91165: LD_VAR 0 2
91169: PPUSH
91170: CALL_OW 250
91174: ST_TO_ADDR
// y := GetY ( enemy ) ;
91175: LD_ADDR_VAR 0 5
91179: PUSH
91180: LD_VAR 0 2
91184: PPUSH
91185: CALL_OW 251
91189: ST_TO_ADDR
// if ValidHex ( x , y ) then
91190: LD_VAR 0 4
91194: PPUSH
91195: LD_VAR 0 5
91199: PPUSH
91200: CALL_OW 488
91204: IFFALSE 91284
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
91206: LD_VAR 0 2
91210: PPUSH
91211: CALL_OW 247
91215: PUSH
91216: LD_INT 3
91218: PUSH
91219: LD_INT 2
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: IN
91226: PUSH
91227: LD_VAR 0 1
91231: PPUSH
91232: CALL_OW 255
91236: PPUSH
91237: LD_VAR 0 2
91241: PPUSH
91242: CALL_OW 292
91246: OR
91247: IFFALSE 91265
// ComAttackUnit ( unit , enemy ) else
91249: LD_VAR 0 1
91253: PPUSH
91254: LD_VAR 0 2
91258: PPUSH
91259: CALL_OW 115
91263: GO 91284
// ComAgressiveMove ( unit , x , y ) ;
91265: LD_VAR 0 1
91269: PPUSH
91270: LD_VAR 0 4
91274: PPUSH
91275: LD_VAR 0 5
91279: PPUSH
91280: CALL_OW 114
// end ;
91284: LD_VAR 0 3
91288: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91289: LD_INT 0
91291: PPUSH
91292: PPUSH
91293: PPUSH
// list := AreaToList ( area , 0 ) ;
91294: LD_ADDR_VAR 0 5
91298: PUSH
91299: LD_VAR 0 1
91303: PPUSH
91304: LD_INT 0
91306: PPUSH
91307: CALL_OW 517
91311: ST_TO_ADDR
// if not list then
91312: LD_VAR 0 5
91316: NOT
91317: IFFALSE 91321
// exit ;
91319: GO 91451
// if all then
91321: LD_VAR 0 2
91325: IFFALSE 91413
// begin for i := 1 to list [ 1 ] do
91327: LD_ADDR_VAR 0 4
91331: PUSH
91332: DOUBLE
91333: LD_INT 1
91335: DEC
91336: ST_TO_ADDR
91337: LD_VAR 0 5
91341: PUSH
91342: LD_INT 1
91344: ARRAY
91345: PUSH
91346: FOR_TO
91347: IFFALSE 91409
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91349: LD_ADDR_VAR 0 3
91353: PUSH
91354: LD_VAR 0 3
91358: PPUSH
91359: LD_VAR 0 3
91363: PUSH
91364: LD_INT 1
91366: PLUS
91367: PPUSH
91368: LD_VAR 0 5
91372: PUSH
91373: LD_INT 1
91375: ARRAY
91376: PUSH
91377: LD_VAR 0 4
91381: ARRAY
91382: PUSH
91383: LD_VAR 0 5
91387: PUSH
91388: LD_INT 2
91390: ARRAY
91391: PUSH
91392: LD_VAR 0 4
91396: ARRAY
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PPUSH
91402: CALL_OW 1
91406: ST_TO_ADDR
91407: GO 91346
91409: POP
91410: POP
// exit ;
91411: GO 91451
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
91413: LD_ADDR_VAR 0 3
91417: PUSH
91418: LD_VAR 0 5
91422: PUSH
91423: LD_INT 1
91425: ARRAY
91426: PUSH
91427: LD_INT 1
91429: ARRAY
91430: PUSH
91431: LD_VAR 0 5
91435: PUSH
91436: LD_INT 2
91438: ARRAY
91439: PUSH
91440: LD_INT 1
91442: ARRAY
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: EMPTY
91449: LIST
91450: ST_TO_ADDR
// end ;
91451: LD_VAR 0 3
91455: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
91456: LD_INT 0
91458: PPUSH
91459: PPUSH
// list := AreaToList ( area , 0 ) ;
91460: LD_ADDR_VAR 0 4
91464: PUSH
91465: LD_VAR 0 1
91469: PPUSH
91470: LD_INT 0
91472: PPUSH
91473: CALL_OW 517
91477: ST_TO_ADDR
// if not list then
91478: LD_VAR 0 4
91482: NOT
91483: IFFALSE 91487
// exit ;
91485: GO 91528
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91487: LD_ADDR_VAR 0 3
91491: PUSH
91492: LD_VAR 0 4
91496: PUSH
91497: LD_INT 1
91499: ARRAY
91500: PUSH
91501: LD_INT 1
91503: ARRAY
91504: PUSH
91505: LD_VAR 0 4
91509: PUSH
91510: LD_INT 2
91512: ARRAY
91513: PUSH
91514: LD_INT 1
91516: ARRAY
91517: PUSH
91518: LD_VAR 0 2
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: LIST
91527: ST_TO_ADDR
// end ;
91528: LD_VAR 0 3
91532: RET
// export function First ( array ) ; begin
91533: LD_INT 0
91535: PPUSH
// if not array then
91536: LD_VAR 0 1
91540: NOT
91541: IFFALSE 91545
// exit ;
91543: GO 91559
// result := array [ 1 ] ;
91545: LD_ADDR_VAR 0 2
91549: PUSH
91550: LD_VAR 0 1
91554: PUSH
91555: LD_INT 1
91557: ARRAY
91558: ST_TO_ADDR
// end ;
91559: LD_VAR 0 2
91563: RET
// export function Last ( array ) ; begin
91564: LD_INT 0
91566: PPUSH
// if not array then
91567: LD_VAR 0 1
91571: NOT
91572: IFFALSE 91576
// exit ;
91574: GO 91592
// result := array [ array ] ;
91576: LD_ADDR_VAR 0 2
91580: PUSH
91581: LD_VAR 0 1
91585: PUSH
91586: LD_VAR 0 1
91590: ARRAY
91591: ST_TO_ADDR
// end ;
91592: LD_VAR 0 2
91596: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
91597: LD_INT 0
91599: PPUSH
91600: PPUSH
// result := [ ] ;
91601: LD_ADDR_VAR 0 5
91605: PUSH
91606: EMPTY
91607: ST_TO_ADDR
// if not array then
91608: LD_VAR 0 1
91612: NOT
91613: IFFALSE 91617
// exit ;
91615: GO 91729
// for i := 1 to array do
91617: LD_ADDR_VAR 0 6
91621: PUSH
91622: DOUBLE
91623: LD_INT 1
91625: DEC
91626: ST_TO_ADDR
91627: LD_VAR 0 1
91631: PUSH
91632: FOR_TO
91633: IFFALSE 91727
// if array [ i ] [ index ] = value then
91635: LD_VAR 0 1
91639: PUSH
91640: LD_VAR 0 6
91644: ARRAY
91645: PUSH
91646: LD_VAR 0 2
91650: ARRAY
91651: PUSH
91652: LD_VAR 0 3
91656: EQUAL
91657: IFFALSE 91725
// begin if indexColumn then
91659: LD_VAR 0 4
91663: IFFALSE 91699
// result := Join ( result , array [ i ] [ indexColumn ] ) else
91665: LD_ADDR_VAR 0 5
91669: PUSH
91670: LD_VAR 0 5
91674: PPUSH
91675: LD_VAR 0 1
91679: PUSH
91680: LD_VAR 0 6
91684: ARRAY
91685: PUSH
91686: LD_VAR 0 4
91690: ARRAY
91691: PPUSH
91692: CALL 86917 0 2
91696: ST_TO_ADDR
91697: GO 91725
// result := Join ( result , array [ i ] ) ;
91699: LD_ADDR_VAR 0 5
91703: PUSH
91704: LD_VAR 0 5
91708: PPUSH
91709: LD_VAR 0 1
91713: PUSH
91714: LD_VAR 0 6
91718: ARRAY
91719: PPUSH
91720: CALL 86917 0 2
91724: ST_TO_ADDR
// end ;
91725: GO 91632
91727: POP
91728: POP
// end ;
91729: LD_VAR 0 5
91733: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
91734: LD_INT 0
91736: PPUSH
// if not vehicles or not parkingPoint then
91737: LD_VAR 0 1
91741: NOT
91742: PUSH
91743: LD_VAR 0 2
91747: NOT
91748: OR
91749: IFFALSE 91753
// exit ;
91751: GO 91851
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
91753: LD_ADDR_VAR 0 1
91757: PUSH
91758: LD_VAR 0 1
91762: PPUSH
91763: LD_INT 50
91765: PUSH
91766: EMPTY
91767: LIST
91768: PUSH
91769: LD_INT 3
91771: PUSH
91772: LD_INT 92
91774: PUSH
91775: LD_VAR 0 2
91779: PUSH
91780: LD_INT 1
91782: ARRAY
91783: PUSH
91784: LD_VAR 0 2
91788: PUSH
91789: LD_INT 2
91791: ARRAY
91792: PUSH
91793: LD_INT 8
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PPUSH
91810: CALL_OW 72
91814: ST_TO_ADDR
// if not vehicles then
91815: LD_VAR 0 1
91819: NOT
91820: IFFALSE 91824
// exit ;
91822: GO 91851
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
91824: LD_VAR 0 1
91828: PPUSH
91829: LD_VAR 0 2
91833: PUSH
91834: LD_INT 1
91836: ARRAY
91837: PPUSH
91838: LD_VAR 0 2
91842: PUSH
91843: LD_INT 2
91845: ARRAY
91846: PPUSH
91847: CALL_OW 111
// end ;
91851: LD_VAR 0 3
91855: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
91856: LD_INT 0
91858: PPUSH
91859: PPUSH
91860: PPUSH
// if not side or not area then
91861: LD_VAR 0 1
91865: NOT
91866: PUSH
91867: LD_VAR 0 2
91871: NOT
91872: OR
91873: IFFALSE 91877
// exit ;
91875: GO 91996
// tmp := AreaToList ( area , 0 ) ;
91877: LD_ADDR_VAR 0 5
91881: PUSH
91882: LD_VAR 0 2
91886: PPUSH
91887: LD_INT 0
91889: PPUSH
91890: CALL_OW 517
91894: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
91895: LD_ADDR_VAR 0 4
91899: PUSH
91900: DOUBLE
91901: LD_INT 1
91903: DEC
91904: ST_TO_ADDR
91905: LD_VAR 0 5
91909: PUSH
91910: LD_INT 1
91912: ARRAY
91913: PUSH
91914: FOR_TO
91915: IFFALSE 91994
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
91917: LD_VAR 0 5
91921: PUSH
91922: LD_INT 1
91924: ARRAY
91925: PUSH
91926: LD_VAR 0 4
91930: ARRAY
91931: PPUSH
91932: LD_VAR 0 5
91936: PUSH
91937: LD_INT 2
91939: ARRAY
91940: PUSH
91941: LD_VAR 0 4
91945: ARRAY
91946: PPUSH
91947: CALL_OW 351
91951: IFFALSE 91992
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
91953: LD_VAR 0 5
91957: PUSH
91958: LD_INT 1
91960: ARRAY
91961: PUSH
91962: LD_VAR 0 4
91966: ARRAY
91967: PPUSH
91968: LD_VAR 0 5
91972: PUSH
91973: LD_INT 2
91975: ARRAY
91976: PUSH
91977: LD_VAR 0 4
91981: ARRAY
91982: PPUSH
91983: LD_VAR 0 1
91987: PPUSH
91988: CALL_OW 244
// end ;
91992: GO 91914
91994: POP
91995: POP
// end ; end_of_file end_of_file
91996: LD_VAR 0 3
92000: RET
// export globalGameSaveCounter ; every 0 0$1 do
92001: GO 92003
92003: DISABLE
// begin enable ;
92004: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92005: LD_STRING updateTimer(
92007: PUSH
92008: LD_OWVAR 1
92012: STR
92013: PUSH
92014: LD_STRING );
92016: STR
92017: PPUSH
92018: CALL_OW 559
// end ;
92022: END
// every 0 0$1 do
92023: GO 92025
92025: DISABLE
// begin globalGameSaveCounter := 0 ;
92026: LD_ADDR_EXP 95
92030: PUSH
92031: LD_INT 0
92033: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92034: LD_STRING setGameSaveCounter(0)
92036: PPUSH
92037: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92041: LD_STRING initStreamRollete();
92043: PPUSH
92044: CALL_OW 559
// InitStreamMode ;
92048: CALL 93391 0 0
// DefineStreamItems ( false ) ;
92052: LD_INT 0
92054: PPUSH
92055: CALL 93855 0 1
// end ;
92059: END
// export function SOS_MapStart ( ) ; begin
92060: LD_INT 0
92062: PPUSH
// if streamModeActive then
92063: LD_EXP 96
92067: IFFALSE 92076
// DefineStreamItems ( true ) ;
92069: LD_INT 1
92071: PPUSH
92072: CALL 93855 0 1
// UpdateLuaVariables ( ) ;
92076: CALL 92093 0 0
// UpdateFactoryWaypoints ( ) ;
92080: CALL 106857 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92084: CALL 107109 0 0
// end ;
92088: LD_VAR 0 1
92092: RET
// function UpdateLuaVariables ( ) ; begin
92093: LD_INT 0
92095: PPUSH
// if globalGameSaveCounter then
92096: LD_EXP 95
92100: IFFALSE 92134
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92102: LD_ADDR_EXP 95
92106: PUSH
92107: LD_EXP 95
92111: PPUSH
92112: CALL 88278 0 1
92116: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92117: LD_STRING setGameSaveCounter(
92119: PUSH
92120: LD_EXP 95
92124: STR
92125: PUSH
92126: LD_STRING )
92128: STR
92129: PPUSH
92130: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92134: LD_STRING setGameDifficulty(
92136: PUSH
92137: LD_OWVAR 67
92141: STR
92142: PUSH
92143: LD_STRING )
92145: STR
92146: PPUSH
92147: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92151: LD_STRING displayDifficulty(
92153: PUSH
92154: LD_OWVAR 67
92158: STR
92159: PUSH
92160: LD_STRING )
92162: STR
92163: PPUSH
92164: CALL_OW 559
// end ;
92168: LD_VAR 0 1
92172: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92173: LD_INT 0
92175: PPUSH
// if p2 = stream_mode then
92176: LD_VAR 0 2
92180: PUSH
92181: LD_INT 100
92183: EQUAL
92184: IFFALSE 93187
// begin if not StreamModeActive then
92186: LD_EXP 96
92190: NOT
92191: IFFALSE 92201
// StreamModeActive := true ;
92193: LD_ADDR_EXP 96
92197: PUSH
92198: LD_INT 1
92200: ST_TO_ADDR
// if p3 = 0 then
92201: LD_VAR 0 3
92205: PUSH
92206: LD_INT 0
92208: EQUAL
92209: IFFALSE 92215
// InitStreamMode ;
92211: CALL 93391 0 0
// if p3 = 1 then
92215: LD_VAR 0 3
92219: PUSH
92220: LD_INT 1
92222: EQUAL
92223: IFFALSE 92233
// sRocket := true ;
92225: LD_ADDR_EXP 101
92229: PUSH
92230: LD_INT 1
92232: ST_TO_ADDR
// if p3 = 2 then
92233: LD_VAR 0 3
92237: PUSH
92238: LD_INT 2
92240: EQUAL
92241: IFFALSE 92251
// sSpeed := true ;
92243: LD_ADDR_EXP 100
92247: PUSH
92248: LD_INT 1
92250: ST_TO_ADDR
// if p3 = 3 then
92251: LD_VAR 0 3
92255: PUSH
92256: LD_INT 3
92258: EQUAL
92259: IFFALSE 92269
// sEngine := true ;
92261: LD_ADDR_EXP 102
92265: PUSH
92266: LD_INT 1
92268: ST_TO_ADDR
// if p3 = 4 then
92269: LD_VAR 0 3
92273: PUSH
92274: LD_INT 4
92276: EQUAL
92277: IFFALSE 92287
// sSpec := true ;
92279: LD_ADDR_EXP 99
92283: PUSH
92284: LD_INT 1
92286: ST_TO_ADDR
// if p3 = 5 then
92287: LD_VAR 0 3
92291: PUSH
92292: LD_INT 5
92294: EQUAL
92295: IFFALSE 92305
// sLevel := true ;
92297: LD_ADDR_EXP 103
92301: PUSH
92302: LD_INT 1
92304: ST_TO_ADDR
// if p3 = 6 then
92305: LD_VAR 0 3
92309: PUSH
92310: LD_INT 6
92312: EQUAL
92313: IFFALSE 92323
// sArmoury := true ;
92315: LD_ADDR_EXP 104
92319: PUSH
92320: LD_INT 1
92322: ST_TO_ADDR
// if p3 = 7 then
92323: LD_VAR 0 3
92327: PUSH
92328: LD_INT 7
92330: EQUAL
92331: IFFALSE 92341
// sRadar := true ;
92333: LD_ADDR_EXP 105
92337: PUSH
92338: LD_INT 1
92340: ST_TO_ADDR
// if p3 = 8 then
92341: LD_VAR 0 3
92345: PUSH
92346: LD_INT 8
92348: EQUAL
92349: IFFALSE 92359
// sBunker := true ;
92351: LD_ADDR_EXP 106
92355: PUSH
92356: LD_INT 1
92358: ST_TO_ADDR
// if p3 = 9 then
92359: LD_VAR 0 3
92363: PUSH
92364: LD_INT 9
92366: EQUAL
92367: IFFALSE 92377
// sHack := true ;
92369: LD_ADDR_EXP 107
92373: PUSH
92374: LD_INT 1
92376: ST_TO_ADDR
// if p3 = 10 then
92377: LD_VAR 0 3
92381: PUSH
92382: LD_INT 10
92384: EQUAL
92385: IFFALSE 92395
// sFire := true ;
92387: LD_ADDR_EXP 108
92391: PUSH
92392: LD_INT 1
92394: ST_TO_ADDR
// if p3 = 11 then
92395: LD_VAR 0 3
92399: PUSH
92400: LD_INT 11
92402: EQUAL
92403: IFFALSE 92413
// sRefresh := true ;
92405: LD_ADDR_EXP 109
92409: PUSH
92410: LD_INT 1
92412: ST_TO_ADDR
// if p3 = 12 then
92413: LD_VAR 0 3
92417: PUSH
92418: LD_INT 12
92420: EQUAL
92421: IFFALSE 92431
// sExp := true ;
92423: LD_ADDR_EXP 110
92427: PUSH
92428: LD_INT 1
92430: ST_TO_ADDR
// if p3 = 13 then
92431: LD_VAR 0 3
92435: PUSH
92436: LD_INT 13
92438: EQUAL
92439: IFFALSE 92449
// sDepot := true ;
92441: LD_ADDR_EXP 111
92445: PUSH
92446: LD_INT 1
92448: ST_TO_ADDR
// if p3 = 14 then
92449: LD_VAR 0 3
92453: PUSH
92454: LD_INT 14
92456: EQUAL
92457: IFFALSE 92467
// sFlag := true ;
92459: LD_ADDR_EXP 112
92463: PUSH
92464: LD_INT 1
92466: ST_TO_ADDR
// if p3 = 15 then
92467: LD_VAR 0 3
92471: PUSH
92472: LD_INT 15
92474: EQUAL
92475: IFFALSE 92485
// sKamikadze := true ;
92477: LD_ADDR_EXP 120
92481: PUSH
92482: LD_INT 1
92484: ST_TO_ADDR
// if p3 = 16 then
92485: LD_VAR 0 3
92489: PUSH
92490: LD_INT 16
92492: EQUAL
92493: IFFALSE 92503
// sTroll := true ;
92495: LD_ADDR_EXP 121
92499: PUSH
92500: LD_INT 1
92502: ST_TO_ADDR
// if p3 = 17 then
92503: LD_VAR 0 3
92507: PUSH
92508: LD_INT 17
92510: EQUAL
92511: IFFALSE 92521
// sSlow := true ;
92513: LD_ADDR_EXP 122
92517: PUSH
92518: LD_INT 1
92520: ST_TO_ADDR
// if p3 = 18 then
92521: LD_VAR 0 3
92525: PUSH
92526: LD_INT 18
92528: EQUAL
92529: IFFALSE 92539
// sLack := true ;
92531: LD_ADDR_EXP 123
92535: PUSH
92536: LD_INT 1
92538: ST_TO_ADDR
// if p3 = 19 then
92539: LD_VAR 0 3
92543: PUSH
92544: LD_INT 19
92546: EQUAL
92547: IFFALSE 92557
// sTank := true ;
92549: LD_ADDR_EXP 125
92553: PUSH
92554: LD_INT 1
92556: ST_TO_ADDR
// if p3 = 20 then
92557: LD_VAR 0 3
92561: PUSH
92562: LD_INT 20
92564: EQUAL
92565: IFFALSE 92575
// sRemote := true ;
92567: LD_ADDR_EXP 126
92571: PUSH
92572: LD_INT 1
92574: ST_TO_ADDR
// if p3 = 21 then
92575: LD_VAR 0 3
92579: PUSH
92580: LD_INT 21
92582: EQUAL
92583: IFFALSE 92593
// sPowell := true ;
92585: LD_ADDR_EXP 127
92589: PUSH
92590: LD_INT 1
92592: ST_TO_ADDR
// if p3 = 22 then
92593: LD_VAR 0 3
92597: PUSH
92598: LD_INT 22
92600: EQUAL
92601: IFFALSE 92611
// sTeleport := true ;
92603: LD_ADDR_EXP 130
92607: PUSH
92608: LD_INT 1
92610: ST_TO_ADDR
// if p3 = 23 then
92611: LD_VAR 0 3
92615: PUSH
92616: LD_INT 23
92618: EQUAL
92619: IFFALSE 92629
// sOilTower := true ;
92621: LD_ADDR_EXP 132
92625: PUSH
92626: LD_INT 1
92628: ST_TO_ADDR
// if p3 = 24 then
92629: LD_VAR 0 3
92633: PUSH
92634: LD_INT 24
92636: EQUAL
92637: IFFALSE 92647
// sShovel := true ;
92639: LD_ADDR_EXP 133
92643: PUSH
92644: LD_INT 1
92646: ST_TO_ADDR
// if p3 = 25 then
92647: LD_VAR 0 3
92651: PUSH
92652: LD_INT 25
92654: EQUAL
92655: IFFALSE 92665
// sSheik := true ;
92657: LD_ADDR_EXP 134
92661: PUSH
92662: LD_INT 1
92664: ST_TO_ADDR
// if p3 = 26 then
92665: LD_VAR 0 3
92669: PUSH
92670: LD_INT 26
92672: EQUAL
92673: IFFALSE 92683
// sEarthquake := true ;
92675: LD_ADDR_EXP 136
92679: PUSH
92680: LD_INT 1
92682: ST_TO_ADDR
// if p3 = 27 then
92683: LD_VAR 0 3
92687: PUSH
92688: LD_INT 27
92690: EQUAL
92691: IFFALSE 92701
// sAI := true ;
92693: LD_ADDR_EXP 137
92697: PUSH
92698: LD_INT 1
92700: ST_TO_ADDR
// if p3 = 28 then
92701: LD_VAR 0 3
92705: PUSH
92706: LD_INT 28
92708: EQUAL
92709: IFFALSE 92719
// sCargo := true ;
92711: LD_ADDR_EXP 140
92715: PUSH
92716: LD_INT 1
92718: ST_TO_ADDR
// if p3 = 29 then
92719: LD_VAR 0 3
92723: PUSH
92724: LD_INT 29
92726: EQUAL
92727: IFFALSE 92737
// sDLaser := true ;
92729: LD_ADDR_EXP 141
92733: PUSH
92734: LD_INT 1
92736: ST_TO_ADDR
// if p3 = 30 then
92737: LD_VAR 0 3
92741: PUSH
92742: LD_INT 30
92744: EQUAL
92745: IFFALSE 92755
// sExchange := true ;
92747: LD_ADDR_EXP 142
92751: PUSH
92752: LD_INT 1
92754: ST_TO_ADDR
// if p3 = 31 then
92755: LD_VAR 0 3
92759: PUSH
92760: LD_INT 31
92762: EQUAL
92763: IFFALSE 92773
// sFac := true ;
92765: LD_ADDR_EXP 143
92769: PUSH
92770: LD_INT 1
92772: ST_TO_ADDR
// if p3 = 32 then
92773: LD_VAR 0 3
92777: PUSH
92778: LD_INT 32
92780: EQUAL
92781: IFFALSE 92791
// sPower := true ;
92783: LD_ADDR_EXP 144
92787: PUSH
92788: LD_INT 1
92790: ST_TO_ADDR
// if p3 = 33 then
92791: LD_VAR 0 3
92795: PUSH
92796: LD_INT 33
92798: EQUAL
92799: IFFALSE 92809
// sRandom := true ;
92801: LD_ADDR_EXP 145
92805: PUSH
92806: LD_INT 1
92808: ST_TO_ADDR
// if p3 = 34 then
92809: LD_VAR 0 3
92813: PUSH
92814: LD_INT 34
92816: EQUAL
92817: IFFALSE 92827
// sShield := true ;
92819: LD_ADDR_EXP 146
92823: PUSH
92824: LD_INT 1
92826: ST_TO_ADDR
// if p3 = 35 then
92827: LD_VAR 0 3
92831: PUSH
92832: LD_INT 35
92834: EQUAL
92835: IFFALSE 92845
// sTime := true ;
92837: LD_ADDR_EXP 147
92841: PUSH
92842: LD_INT 1
92844: ST_TO_ADDR
// if p3 = 36 then
92845: LD_VAR 0 3
92849: PUSH
92850: LD_INT 36
92852: EQUAL
92853: IFFALSE 92863
// sTools := true ;
92855: LD_ADDR_EXP 148
92859: PUSH
92860: LD_INT 1
92862: ST_TO_ADDR
// if p3 = 101 then
92863: LD_VAR 0 3
92867: PUSH
92868: LD_INT 101
92870: EQUAL
92871: IFFALSE 92881
// sSold := true ;
92873: LD_ADDR_EXP 113
92877: PUSH
92878: LD_INT 1
92880: ST_TO_ADDR
// if p3 = 102 then
92881: LD_VAR 0 3
92885: PUSH
92886: LD_INT 102
92888: EQUAL
92889: IFFALSE 92899
// sDiff := true ;
92891: LD_ADDR_EXP 114
92895: PUSH
92896: LD_INT 1
92898: ST_TO_ADDR
// if p3 = 103 then
92899: LD_VAR 0 3
92903: PUSH
92904: LD_INT 103
92906: EQUAL
92907: IFFALSE 92917
// sFog := true ;
92909: LD_ADDR_EXP 117
92913: PUSH
92914: LD_INT 1
92916: ST_TO_ADDR
// if p3 = 104 then
92917: LD_VAR 0 3
92921: PUSH
92922: LD_INT 104
92924: EQUAL
92925: IFFALSE 92935
// sReset := true ;
92927: LD_ADDR_EXP 118
92931: PUSH
92932: LD_INT 1
92934: ST_TO_ADDR
// if p3 = 105 then
92935: LD_VAR 0 3
92939: PUSH
92940: LD_INT 105
92942: EQUAL
92943: IFFALSE 92953
// sSun := true ;
92945: LD_ADDR_EXP 119
92949: PUSH
92950: LD_INT 1
92952: ST_TO_ADDR
// if p3 = 106 then
92953: LD_VAR 0 3
92957: PUSH
92958: LD_INT 106
92960: EQUAL
92961: IFFALSE 92971
// sTiger := true ;
92963: LD_ADDR_EXP 115
92967: PUSH
92968: LD_INT 1
92970: ST_TO_ADDR
// if p3 = 107 then
92971: LD_VAR 0 3
92975: PUSH
92976: LD_INT 107
92978: EQUAL
92979: IFFALSE 92989
// sBomb := true ;
92981: LD_ADDR_EXP 116
92985: PUSH
92986: LD_INT 1
92988: ST_TO_ADDR
// if p3 = 108 then
92989: LD_VAR 0 3
92993: PUSH
92994: LD_INT 108
92996: EQUAL
92997: IFFALSE 93007
// sWound := true ;
92999: LD_ADDR_EXP 124
93003: PUSH
93004: LD_INT 1
93006: ST_TO_ADDR
// if p3 = 109 then
93007: LD_VAR 0 3
93011: PUSH
93012: LD_INT 109
93014: EQUAL
93015: IFFALSE 93025
// sBetray := true ;
93017: LD_ADDR_EXP 128
93021: PUSH
93022: LD_INT 1
93024: ST_TO_ADDR
// if p3 = 110 then
93025: LD_VAR 0 3
93029: PUSH
93030: LD_INT 110
93032: EQUAL
93033: IFFALSE 93043
// sContamin := true ;
93035: LD_ADDR_EXP 129
93039: PUSH
93040: LD_INT 1
93042: ST_TO_ADDR
// if p3 = 111 then
93043: LD_VAR 0 3
93047: PUSH
93048: LD_INT 111
93050: EQUAL
93051: IFFALSE 93061
// sOil := true ;
93053: LD_ADDR_EXP 131
93057: PUSH
93058: LD_INT 1
93060: ST_TO_ADDR
// if p3 = 112 then
93061: LD_VAR 0 3
93065: PUSH
93066: LD_INT 112
93068: EQUAL
93069: IFFALSE 93079
// sStu := true ;
93071: LD_ADDR_EXP 135
93075: PUSH
93076: LD_INT 1
93078: ST_TO_ADDR
// if p3 = 113 then
93079: LD_VAR 0 3
93083: PUSH
93084: LD_INT 113
93086: EQUAL
93087: IFFALSE 93097
// sBazooka := true ;
93089: LD_ADDR_EXP 138
93093: PUSH
93094: LD_INT 1
93096: ST_TO_ADDR
// if p3 = 114 then
93097: LD_VAR 0 3
93101: PUSH
93102: LD_INT 114
93104: EQUAL
93105: IFFALSE 93115
// sMortar := true ;
93107: LD_ADDR_EXP 139
93111: PUSH
93112: LD_INT 1
93114: ST_TO_ADDR
// if p3 = 115 then
93115: LD_VAR 0 3
93119: PUSH
93120: LD_INT 115
93122: EQUAL
93123: IFFALSE 93133
// sRanger := true ;
93125: LD_ADDR_EXP 149
93129: PUSH
93130: LD_INT 1
93132: ST_TO_ADDR
// if p3 = 116 then
93133: LD_VAR 0 3
93137: PUSH
93138: LD_INT 116
93140: EQUAL
93141: IFFALSE 93151
// sComputer := true ;
93143: LD_ADDR_EXP 150
93147: PUSH
93148: LD_INT 1
93150: ST_TO_ADDR
// if p3 = 117 then
93151: LD_VAR 0 3
93155: PUSH
93156: LD_INT 117
93158: EQUAL
93159: IFFALSE 93169
// s30 := true ;
93161: LD_ADDR_EXP 151
93165: PUSH
93166: LD_INT 1
93168: ST_TO_ADDR
// if p3 = 118 then
93169: LD_VAR 0 3
93173: PUSH
93174: LD_INT 118
93176: EQUAL
93177: IFFALSE 93187
// s60 := true ;
93179: LD_ADDR_EXP 152
93183: PUSH
93184: LD_INT 1
93186: ST_TO_ADDR
// end ; if p2 = hack_mode then
93187: LD_VAR 0 2
93191: PUSH
93192: LD_INT 101
93194: EQUAL
93195: IFFALSE 93323
// begin case p3 of 1 :
93197: LD_VAR 0 3
93201: PUSH
93202: LD_INT 1
93204: DOUBLE
93205: EQUAL
93206: IFTRUE 93210
93208: GO 93217
93210: POP
// hHackUnlimitedResources ; 2 :
93211: CALL 105470 0 0
93215: GO 93323
93217: LD_INT 2
93219: DOUBLE
93220: EQUAL
93221: IFTRUE 93225
93223: GO 93232
93225: POP
// hHackSetLevel10 ; 3 :
93226: CALL 105603 0 0
93230: GO 93323
93232: LD_INT 3
93234: DOUBLE
93235: EQUAL
93236: IFTRUE 93240
93238: GO 93247
93240: POP
// hHackSetLevel10YourUnits ; 4 :
93241: CALL 105688 0 0
93245: GO 93323
93247: LD_INT 4
93249: DOUBLE
93250: EQUAL
93251: IFTRUE 93255
93253: GO 93262
93255: POP
// hHackInvincible ; 5 :
93256: CALL 106136 0 0
93260: GO 93323
93262: LD_INT 5
93264: DOUBLE
93265: EQUAL
93266: IFTRUE 93270
93268: GO 93277
93270: POP
// hHackInvisible ; 6 :
93271: CALL 106247 0 0
93275: GO 93323
93277: LD_INT 6
93279: DOUBLE
93280: EQUAL
93281: IFTRUE 93285
93283: GO 93292
93285: POP
// hHackChangeYourSide ; 7 :
93286: CALL 106304 0 0
93290: GO 93323
93292: LD_INT 7
93294: DOUBLE
93295: EQUAL
93296: IFTRUE 93300
93298: GO 93307
93300: POP
// hHackChangeUnitSide ; 8 :
93301: CALL 106346 0 0
93305: GO 93323
93307: LD_INT 8
93309: DOUBLE
93310: EQUAL
93311: IFTRUE 93315
93313: GO 93322
93315: POP
// hHackFog ; end ;
93316: CALL 106447 0 0
93320: GO 93323
93322: POP
// end ; if p2 = game_save_mode then
93323: LD_VAR 0 2
93327: PUSH
93328: LD_INT 102
93330: EQUAL
93331: IFFALSE 93386
// begin if p3 = 1 then
93333: LD_VAR 0 3
93337: PUSH
93338: LD_INT 1
93340: EQUAL
93341: IFFALSE 93353
// globalGameSaveCounter := p4 ;
93343: LD_ADDR_EXP 95
93347: PUSH
93348: LD_VAR 0 4
93352: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93353: LD_VAR 0 3
93357: PUSH
93358: LD_INT 2
93360: EQUAL
93361: PUSH
93362: LD_EXP 95
93366: AND
93367: IFFALSE 93386
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93369: LD_STRING setGameSaveCounter(
93371: PUSH
93372: LD_EXP 95
93376: STR
93377: PUSH
93378: LD_STRING )
93380: STR
93381: PPUSH
93382: CALL_OW 559
// end ; end ;
93386: LD_VAR 0 7
93390: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93391: LD_INT 0
93393: PPUSH
// streamModeActive := false ;
93394: LD_ADDR_EXP 96
93398: PUSH
93399: LD_INT 0
93401: ST_TO_ADDR
// normalCounter := 36 ;
93402: LD_ADDR_EXP 97
93406: PUSH
93407: LD_INT 36
93409: ST_TO_ADDR
// hardcoreCounter := 18 ;
93410: LD_ADDR_EXP 98
93414: PUSH
93415: LD_INT 18
93417: ST_TO_ADDR
// sRocket := false ;
93418: LD_ADDR_EXP 101
93422: PUSH
93423: LD_INT 0
93425: ST_TO_ADDR
// sSpeed := false ;
93426: LD_ADDR_EXP 100
93430: PUSH
93431: LD_INT 0
93433: ST_TO_ADDR
// sEngine := false ;
93434: LD_ADDR_EXP 102
93438: PUSH
93439: LD_INT 0
93441: ST_TO_ADDR
// sSpec := false ;
93442: LD_ADDR_EXP 99
93446: PUSH
93447: LD_INT 0
93449: ST_TO_ADDR
// sLevel := false ;
93450: LD_ADDR_EXP 103
93454: PUSH
93455: LD_INT 0
93457: ST_TO_ADDR
// sArmoury := false ;
93458: LD_ADDR_EXP 104
93462: PUSH
93463: LD_INT 0
93465: ST_TO_ADDR
// sRadar := false ;
93466: LD_ADDR_EXP 105
93470: PUSH
93471: LD_INT 0
93473: ST_TO_ADDR
// sBunker := false ;
93474: LD_ADDR_EXP 106
93478: PUSH
93479: LD_INT 0
93481: ST_TO_ADDR
// sHack := false ;
93482: LD_ADDR_EXP 107
93486: PUSH
93487: LD_INT 0
93489: ST_TO_ADDR
// sFire := false ;
93490: LD_ADDR_EXP 108
93494: PUSH
93495: LD_INT 0
93497: ST_TO_ADDR
// sRefresh := false ;
93498: LD_ADDR_EXP 109
93502: PUSH
93503: LD_INT 0
93505: ST_TO_ADDR
// sExp := false ;
93506: LD_ADDR_EXP 110
93510: PUSH
93511: LD_INT 0
93513: ST_TO_ADDR
// sDepot := false ;
93514: LD_ADDR_EXP 111
93518: PUSH
93519: LD_INT 0
93521: ST_TO_ADDR
// sFlag := false ;
93522: LD_ADDR_EXP 112
93526: PUSH
93527: LD_INT 0
93529: ST_TO_ADDR
// sKamikadze := false ;
93530: LD_ADDR_EXP 120
93534: PUSH
93535: LD_INT 0
93537: ST_TO_ADDR
// sTroll := false ;
93538: LD_ADDR_EXP 121
93542: PUSH
93543: LD_INT 0
93545: ST_TO_ADDR
// sSlow := false ;
93546: LD_ADDR_EXP 122
93550: PUSH
93551: LD_INT 0
93553: ST_TO_ADDR
// sLack := false ;
93554: LD_ADDR_EXP 123
93558: PUSH
93559: LD_INT 0
93561: ST_TO_ADDR
// sTank := false ;
93562: LD_ADDR_EXP 125
93566: PUSH
93567: LD_INT 0
93569: ST_TO_ADDR
// sRemote := false ;
93570: LD_ADDR_EXP 126
93574: PUSH
93575: LD_INT 0
93577: ST_TO_ADDR
// sPowell := false ;
93578: LD_ADDR_EXP 127
93582: PUSH
93583: LD_INT 0
93585: ST_TO_ADDR
// sTeleport := false ;
93586: LD_ADDR_EXP 130
93590: PUSH
93591: LD_INT 0
93593: ST_TO_ADDR
// sOilTower := false ;
93594: LD_ADDR_EXP 132
93598: PUSH
93599: LD_INT 0
93601: ST_TO_ADDR
// sShovel := false ;
93602: LD_ADDR_EXP 133
93606: PUSH
93607: LD_INT 0
93609: ST_TO_ADDR
// sSheik := false ;
93610: LD_ADDR_EXP 134
93614: PUSH
93615: LD_INT 0
93617: ST_TO_ADDR
// sEarthquake := false ;
93618: LD_ADDR_EXP 136
93622: PUSH
93623: LD_INT 0
93625: ST_TO_ADDR
// sAI := false ;
93626: LD_ADDR_EXP 137
93630: PUSH
93631: LD_INT 0
93633: ST_TO_ADDR
// sCargo := false ;
93634: LD_ADDR_EXP 140
93638: PUSH
93639: LD_INT 0
93641: ST_TO_ADDR
// sDLaser := false ;
93642: LD_ADDR_EXP 141
93646: PUSH
93647: LD_INT 0
93649: ST_TO_ADDR
// sExchange := false ;
93650: LD_ADDR_EXP 142
93654: PUSH
93655: LD_INT 0
93657: ST_TO_ADDR
// sFac := false ;
93658: LD_ADDR_EXP 143
93662: PUSH
93663: LD_INT 0
93665: ST_TO_ADDR
// sPower := false ;
93666: LD_ADDR_EXP 144
93670: PUSH
93671: LD_INT 0
93673: ST_TO_ADDR
// sRandom := false ;
93674: LD_ADDR_EXP 145
93678: PUSH
93679: LD_INT 0
93681: ST_TO_ADDR
// sShield := false ;
93682: LD_ADDR_EXP 146
93686: PUSH
93687: LD_INT 0
93689: ST_TO_ADDR
// sTime := false ;
93690: LD_ADDR_EXP 147
93694: PUSH
93695: LD_INT 0
93697: ST_TO_ADDR
// sTools := false ;
93698: LD_ADDR_EXP 148
93702: PUSH
93703: LD_INT 0
93705: ST_TO_ADDR
// sSold := false ;
93706: LD_ADDR_EXP 113
93710: PUSH
93711: LD_INT 0
93713: ST_TO_ADDR
// sDiff := false ;
93714: LD_ADDR_EXP 114
93718: PUSH
93719: LD_INT 0
93721: ST_TO_ADDR
// sFog := false ;
93722: LD_ADDR_EXP 117
93726: PUSH
93727: LD_INT 0
93729: ST_TO_ADDR
// sReset := false ;
93730: LD_ADDR_EXP 118
93734: PUSH
93735: LD_INT 0
93737: ST_TO_ADDR
// sSun := false ;
93738: LD_ADDR_EXP 119
93742: PUSH
93743: LD_INT 0
93745: ST_TO_ADDR
// sTiger := false ;
93746: LD_ADDR_EXP 115
93750: PUSH
93751: LD_INT 0
93753: ST_TO_ADDR
// sBomb := false ;
93754: LD_ADDR_EXP 116
93758: PUSH
93759: LD_INT 0
93761: ST_TO_ADDR
// sWound := false ;
93762: LD_ADDR_EXP 124
93766: PUSH
93767: LD_INT 0
93769: ST_TO_ADDR
// sBetray := false ;
93770: LD_ADDR_EXP 128
93774: PUSH
93775: LD_INT 0
93777: ST_TO_ADDR
// sContamin := false ;
93778: LD_ADDR_EXP 129
93782: PUSH
93783: LD_INT 0
93785: ST_TO_ADDR
// sOil := false ;
93786: LD_ADDR_EXP 131
93790: PUSH
93791: LD_INT 0
93793: ST_TO_ADDR
// sStu := false ;
93794: LD_ADDR_EXP 135
93798: PUSH
93799: LD_INT 0
93801: ST_TO_ADDR
// sBazooka := false ;
93802: LD_ADDR_EXP 138
93806: PUSH
93807: LD_INT 0
93809: ST_TO_ADDR
// sMortar := false ;
93810: LD_ADDR_EXP 139
93814: PUSH
93815: LD_INT 0
93817: ST_TO_ADDR
// sRanger := false ;
93818: LD_ADDR_EXP 149
93822: PUSH
93823: LD_INT 0
93825: ST_TO_ADDR
// sComputer := false ;
93826: LD_ADDR_EXP 150
93830: PUSH
93831: LD_INT 0
93833: ST_TO_ADDR
// s30 := false ;
93834: LD_ADDR_EXP 151
93838: PUSH
93839: LD_INT 0
93841: ST_TO_ADDR
// s60 := false ;
93842: LD_ADDR_EXP 152
93846: PUSH
93847: LD_INT 0
93849: ST_TO_ADDR
// end ;
93850: LD_VAR 0 1
93854: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93855: LD_INT 0
93857: PPUSH
93858: PPUSH
93859: PPUSH
93860: PPUSH
93861: PPUSH
93862: PPUSH
93863: PPUSH
// result := [ ] ;
93864: LD_ADDR_VAR 0 2
93868: PUSH
93869: EMPTY
93870: ST_TO_ADDR
// if campaign_id = 1 then
93871: LD_OWVAR 69
93875: PUSH
93876: LD_INT 1
93878: EQUAL
93879: IFFALSE 97045
// begin case mission_number of 1 :
93881: LD_OWVAR 70
93885: PUSH
93886: LD_INT 1
93888: DOUBLE
93889: EQUAL
93890: IFTRUE 93894
93892: GO 93970
93894: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93895: LD_ADDR_VAR 0 2
93899: PUSH
93900: LD_INT 2
93902: PUSH
93903: LD_INT 4
93905: PUSH
93906: LD_INT 11
93908: PUSH
93909: LD_INT 12
93911: PUSH
93912: LD_INT 15
93914: PUSH
93915: LD_INT 16
93917: PUSH
93918: LD_INT 22
93920: PUSH
93921: LD_INT 23
93923: PUSH
93924: LD_INT 26
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 101
93940: PUSH
93941: LD_INT 102
93943: PUSH
93944: LD_INT 106
93946: PUSH
93947: LD_INT 116
93949: PUSH
93950: LD_INT 117
93952: PUSH
93953: LD_INT 118
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: ST_TO_ADDR
93968: GO 97043
93970: LD_INT 2
93972: DOUBLE
93973: EQUAL
93974: IFTRUE 93978
93976: GO 94062
93978: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93979: LD_ADDR_VAR 0 2
93983: PUSH
93984: LD_INT 2
93986: PUSH
93987: LD_INT 4
93989: PUSH
93990: LD_INT 11
93992: PUSH
93993: LD_INT 12
93995: PUSH
93996: LD_INT 15
93998: PUSH
93999: LD_INT 16
94001: PUSH
94002: LD_INT 22
94004: PUSH
94005: LD_INT 23
94007: PUSH
94008: LD_INT 26
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 101
94024: PUSH
94025: LD_INT 102
94027: PUSH
94028: LD_INT 105
94030: PUSH
94031: LD_INT 106
94033: PUSH
94034: LD_INT 108
94036: PUSH
94037: LD_INT 116
94039: PUSH
94040: LD_INT 117
94042: PUSH
94043: LD_INT 118
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: ST_TO_ADDR
94060: GO 97043
94062: LD_INT 3
94064: DOUBLE
94065: EQUAL
94066: IFTRUE 94070
94068: GO 94158
94070: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94071: LD_ADDR_VAR 0 2
94075: PUSH
94076: LD_INT 2
94078: PUSH
94079: LD_INT 4
94081: PUSH
94082: LD_INT 5
94084: PUSH
94085: LD_INT 11
94087: PUSH
94088: LD_INT 12
94090: PUSH
94091: LD_INT 15
94093: PUSH
94094: LD_INT 16
94096: PUSH
94097: LD_INT 22
94099: PUSH
94100: LD_INT 26
94102: PUSH
94103: LD_INT 36
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 101
94120: PUSH
94121: LD_INT 102
94123: PUSH
94124: LD_INT 105
94126: PUSH
94127: LD_INT 106
94129: PUSH
94130: LD_INT 108
94132: PUSH
94133: LD_INT 116
94135: PUSH
94136: LD_INT 117
94138: PUSH
94139: LD_INT 118
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: ST_TO_ADDR
94156: GO 97043
94158: LD_INT 4
94160: DOUBLE
94161: EQUAL
94162: IFTRUE 94166
94164: GO 94262
94166: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94167: LD_ADDR_VAR 0 2
94171: PUSH
94172: LD_INT 2
94174: PUSH
94175: LD_INT 4
94177: PUSH
94178: LD_INT 5
94180: PUSH
94181: LD_INT 8
94183: PUSH
94184: LD_INT 11
94186: PUSH
94187: LD_INT 12
94189: PUSH
94190: LD_INT 15
94192: PUSH
94193: LD_INT 16
94195: PUSH
94196: LD_INT 22
94198: PUSH
94199: LD_INT 23
94201: PUSH
94202: LD_INT 26
94204: PUSH
94205: LD_INT 36
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 101
94224: PUSH
94225: LD_INT 102
94227: PUSH
94228: LD_INT 105
94230: PUSH
94231: LD_INT 106
94233: PUSH
94234: LD_INT 108
94236: PUSH
94237: LD_INT 116
94239: PUSH
94240: LD_INT 117
94242: PUSH
94243: LD_INT 118
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: ST_TO_ADDR
94260: GO 97043
94262: LD_INT 5
94264: DOUBLE
94265: EQUAL
94266: IFTRUE 94270
94268: GO 94382
94270: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94271: LD_ADDR_VAR 0 2
94275: PUSH
94276: LD_INT 2
94278: PUSH
94279: LD_INT 4
94281: PUSH
94282: LD_INT 5
94284: PUSH
94285: LD_INT 6
94287: PUSH
94288: LD_INT 8
94290: PUSH
94291: LD_INT 11
94293: PUSH
94294: LD_INT 12
94296: PUSH
94297: LD_INT 15
94299: PUSH
94300: LD_INT 16
94302: PUSH
94303: LD_INT 22
94305: PUSH
94306: LD_INT 23
94308: PUSH
94309: LD_INT 25
94311: PUSH
94312: LD_INT 26
94314: PUSH
94315: LD_INT 36
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 101
94336: PUSH
94337: LD_INT 102
94339: PUSH
94340: LD_INT 105
94342: PUSH
94343: LD_INT 106
94345: PUSH
94346: LD_INT 108
94348: PUSH
94349: LD_INT 109
94351: PUSH
94352: LD_INT 112
94354: PUSH
94355: LD_INT 116
94357: PUSH
94358: LD_INT 117
94360: PUSH
94361: LD_INT 118
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: ST_TO_ADDR
94380: GO 97043
94382: LD_INT 6
94384: DOUBLE
94385: EQUAL
94386: IFTRUE 94390
94388: GO 94522
94390: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94391: LD_ADDR_VAR 0 2
94395: PUSH
94396: LD_INT 2
94398: PUSH
94399: LD_INT 4
94401: PUSH
94402: LD_INT 5
94404: PUSH
94405: LD_INT 6
94407: PUSH
94408: LD_INT 8
94410: PUSH
94411: LD_INT 11
94413: PUSH
94414: LD_INT 12
94416: PUSH
94417: LD_INT 15
94419: PUSH
94420: LD_INT 16
94422: PUSH
94423: LD_INT 20
94425: PUSH
94426: LD_INT 21
94428: PUSH
94429: LD_INT 22
94431: PUSH
94432: LD_INT 23
94434: PUSH
94435: LD_INT 25
94437: PUSH
94438: LD_INT 26
94440: PUSH
94441: LD_INT 30
94443: PUSH
94444: LD_INT 31
94446: PUSH
94447: LD_INT 32
94449: PUSH
94450: LD_INT 36
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 101
94476: PUSH
94477: LD_INT 102
94479: PUSH
94480: LD_INT 105
94482: PUSH
94483: LD_INT 106
94485: PUSH
94486: LD_INT 108
94488: PUSH
94489: LD_INT 109
94491: PUSH
94492: LD_INT 112
94494: PUSH
94495: LD_INT 116
94497: PUSH
94498: LD_INT 117
94500: PUSH
94501: LD_INT 118
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: ST_TO_ADDR
94520: GO 97043
94522: LD_INT 7
94524: DOUBLE
94525: EQUAL
94526: IFTRUE 94530
94528: GO 94642
94530: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94531: LD_ADDR_VAR 0 2
94535: PUSH
94536: LD_INT 2
94538: PUSH
94539: LD_INT 4
94541: PUSH
94542: LD_INT 5
94544: PUSH
94545: LD_INT 7
94547: PUSH
94548: LD_INT 11
94550: PUSH
94551: LD_INT 12
94553: PUSH
94554: LD_INT 15
94556: PUSH
94557: LD_INT 16
94559: PUSH
94560: LD_INT 20
94562: PUSH
94563: LD_INT 21
94565: PUSH
94566: LD_INT 22
94568: PUSH
94569: LD_INT 23
94571: PUSH
94572: LD_INT 25
94574: PUSH
94575: LD_INT 26
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 101
94596: PUSH
94597: LD_INT 102
94599: PUSH
94600: LD_INT 103
94602: PUSH
94603: LD_INT 105
94605: PUSH
94606: LD_INT 106
94608: PUSH
94609: LD_INT 108
94611: PUSH
94612: LD_INT 112
94614: PUSH
94615: LD_INT 116
94617: PUSH
94618: LD_INT 117
94620: PUSH
94621: LD_INT 118
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: ST_TO_ADDR
94640: GO 97043
94642: LD_INT 8
94644: DOUBLE
94645: EQUAL
94646: IFTRUE 94650
94648: GO 94790
94650: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94651: LD_ADDR_VAR 0 2
94655: PUSH
94656: LD_INT 2
94658: PUSH
94659: LD_INT 4
94661: PUSH
94662: LD_INT 5
94664: PUSH
94665: LD_INT 6
94667: PUSH
94668: LD_INT 7
94670: PUSH
94671: LD_INT 8
94673: PUSH
94674: LD_INT 11
94676: PUSH
94677: LD_INT 12
94679: PUSH
94680: LD_INT 15
94682: PUSH
94683: LD_INT 16
94685: PUSH
94686: LD_INT 20
94688: PUSH
94689: LD_INT 21
94691: PUSH
94692: LD_INT 22
94694: PUSH
94695: LD_INT 23
94697: PUSH
94698: LD_INT 25
94700: PUSH
94701: LD_INT 26
94703: PUSH
94704: LD_INT 30
94706: PUSH
94707: LD_INT 31
94709: PUSH
94710: LD_INT 32
94712: PUSH
94713: LD_INT 36
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 101
94740: PUSH
94741: LD_INT 102
94743: PUSH
94744: LD_INT 103
94746: PUSH
94747: LD_INT 105
94749: PUSH
94750: LD_INT 106
94752: PUSH
94753: LD_INT 108
94755: PUSH
94756: LD_INT 109
94758: PUSH
94759: LD_INT 112
94761: PUSH
94762: LD_INT 116
94764: PUSH
94765: LD_INT 117
94767: PUSH
94768: LD_INT 118
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: ST_TO_ADDR
94788: GO 97043
94790: LD_INT 9
94792: DOUBLE
94793: EQUAL
94794: IFTRUE 94798
94796: GO 94946
94798: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94799: LD_ADDR_VAR 0 2
94803: PUSH
94804: LD_INT 2
94806: PUSH
94807: LD_INT 4
94809: PUSH
94810: LD_INT 5
94812: PUSH
94813: LD_INT 6
94815: PUSH
94816: LD_INT 7
94818: PUSH
94819: LD_INT 8
94821: PUSH
94822: LD_INT 11
94824: PUSH
94825: LD_INT 12
94827: PUSH
94828: LD_INT 15
94830: PUSH
94831: LD_INT 16
94833: PUSH
94834: LD_INT 20
94836: PUSH
94837: LD_INT 21
94839: PUSH
94840: LD_INT 22
94842: PUSH
94843: LD_INT 23
94845: PUSH
94846: LD_INT 25
94848: PUSH
94849: LD_INT 26
94851: PUSH
94852: LD_INT 28
94854: PUSH
94855: LD_INT 30
94857: PUSH
94858: LD_INT 31
94860: PUSH
94861: LD_INT 32
94863: PUSH
94864: LD_INT 36
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 101
94892: PUSH
94893: LD_INT 102
94895: PUSH
94896: LD_INT 103
94898: PUSH
94899: LD_INT 105
94901: PUSH
94902: LD_INT 106
94904: PUSH
94905: LD_INT 108
94907: PUSH
94908: LD_INT 109
94910: PUSH
94911: LD_INT 112
94913: PUSH
94914: LD_INT 114
94916: PUSH
94917: LD_INT 116
94919: PUSH
94920: LD_INT 117
94922: PUSH
94923: LD_INT 118
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: ST_TO_ADDR
94944: GO 97043
94946: LD_INT 10
94948: DOUBLE
94949: EQUAL
94950: IFTRUE 94954
94952: GO 95150
94954: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94955: LD_ADDR_VAR 0 2
94959: PUSH
94960: LD_INT 2
94962: PUSH
94963: LD_INT 4
94965: PUSH
94966: LD_INT 5
94968: PUSH
94969: LD_INT 6
94971: PUSH
94972: LD_INT 7
94974: PUSH
94975: LD_INT 8
94977: PUSH
94978: LD_INT 9
94980: PUSH
94981: LD_INT 10
94983: PUSH
94984: LD_INT 11
94986: PUSH
94987: LD_INT 12
94989: PUSH
94990: LD_INT 13
94992: PUSH
94993: LD_INT 14
94995: PUSH
94996: LD_INT 15
94998: PUSH
94999: LD_INT 16
95001: PUSH
95002: LD_INT 17
95004: PUSH
95005: LD_INT 18
95007: PUSH
95008: LD_INT 19
95010: PUSH
95011: LD_INT 20
95013: PUSH
95014: LD_INT 21
95016: PUSH
95017: LD_INT 22
95019: PUSH
95020: LD_INT 23
95022: PUSH
95023: LD_INT 24
95025: PUSH
95026: LD_INT 25
95028: PUSH
95029: LD_INT 26
95031: PUSH
95032: LD_INT 28
95034: PUSH
95035: LD_INT 30
95037: PUSH
95038: LD_INT 31
95040: PUSH
95041: LD_INT 32
95043: PUSH
95044: LD_INT 36
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: PUSH
95078: LD_INT 101
95080: PUSH
95081: LD_INT 102
95083: PUSH
95084: LD_INT 103
95086: PUSH
95087: LD_INT 104
95089: PUSH
95090: LD_INT 105
95092: PUSH
95093: LD_INT 106
95095: PUSH
95096: LD_INT 107
95098: PUSH
95099: LD_INT 108
95101: PUSH
95102: LD_INT 109
95104: PUSH
95105: LD_INT 110
95107: PUSH
95108: LD_INT 111
95110: PUSH
95111: LD_INT 112
95113: PUSH
95114: LD_INT 114
95116: PUSH
95117: LD_INT 116
95119: PUSH
95120: LD_INT 117
95122: PUSH
95123: LD_INT 118
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: ST_TO_ADDR
95148: GO 97043
95150: LD_INT 11
95152: DOUBLE
95153: EQUAL
95154: IFTRUE 95158
95156: GO 95362
95158: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95159: LD_ADDR_VAR 0 2
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: LD_INT 3
95169: PUSH
95170: LD_INT 4
95172: PUSH
95173: LD_INT 5
95175: PUSH
95176: LD_INT 6
95178: PUSH
95179: LD_INT 7
95181: PUSH
95182: LD_INT 8
95184: PUSH
95185: LD_INT 9
95187: PUSH
95188: LD_INT 10
95190: PUSH
95191: LD_INT 11
95193: PUSH
95194: LD_INT 12
95196: PUSH
95197: LD_INT 13
95199: PUSH
95200: LD_INT 14
95202: PUSH
95203: LD_INT 15
95205: PUSH
95206: LD_INT 16
95208: PUSH
95209: LD_INT 17
95211: PUSH
95212: LD_INT 18
95214: PUSH
95215: LD_INT 19
95217: PUSH
95218: LD_INT 20
95220: PUSH
95221: LD_INT 21
95223: PUSH
95224: LD_INT 22
95226: PUSH
95227: LD_INT 23
95229: PUSH
95230: LD_INT 24
95232: PUSH
95233: LD_INT 25
95235: PUSH
95236: LD_INT 26
95238: PUSH
95239: LD_INT 28
95241: PUSH
95242: LD_INT 30
95244: PUSH
95245: LD_INT 31
95247: PUSH
95248: LD_INT 32
95250: PUSH
95251: LD_INT 34
95253: PUSH
95254: LD_INT 36
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 101
95292: PUSH
95293: LD_INT 102
95295: PUSH
95296: LD_INT 103
95298: PUSH
95299: LD_INT 104
95301: PUSH
95302: LD_INT 105
95304: PUSH
95305: LD_INT 106
95307: PUSH
95308: LD_INT 107
95310: PUSH
95311: LD_INT 108
95313: PUSH
95314: LD_INT 109
95316: PUSH
95317: LD_INT 110
95319: PUSH
95320: LD_INT 111
95322: PUSH
95323: LD_INT 112
95325: PUSH
95326: LD_INT 114
95328: PUSH
95329: LD_INT 116
95331: PUSH
95332: LD_INT 117
95334: PUSH
95335: LD_INT 118
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: ST_TO_ADDR
95360: GO 97043
95362: LD_INT 12
95364: DOUBLE
95365: EQUAL
95366: IFTRUE 95370
95368: GO 95590
95370: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95371: LD_ADDR_VAR 0 2
95375: PUSH
95376: LD_INT 1
95378: PUSH
95379: LD_INT 2
95381: PUSH
95382: LD_INT 3
95384: PUSH
95385: LD_INT 4
95387: PUSH
95388: LD_INT 5
95390: PUSH
95391: LD_INT 6
95393: PUSH
95394: LD_INT 7
95396: PUSH
95397: LD_INT 8
95399: PUSH
95400: LD_INT 9
95402: PUSH
95403: LD_INT 10
95405: PUSH
95406: LD_INT 11
95408: PUSH
95409: LD_INT 12
95411: PUSH
95412: LD_INT 13
95414: PUSH
95415: LD_INT 14
95417: PUSH
95418: LD_INT 15
95420: PUSH
95421: LD_INT 16
95423: PUSH
95424: LD_INT 17
95426: PUSH
95427: LD_INT 18
95429: PUSH
95430: LD_INT 19
95432: PUSH
95433: LD_INT 20
95435: PUSH
95436: LD_INT 21
95438: PUSH
95439: LD_INT 22
95441: PUSH
95442: LD_INT 23
95444: PUSH
95445: LD_INT 24
95447: PUSH
95448: LD_INT 25
95450: PUSH
95451: LD_INT 26
95453: PUSH
95454: LD_INT 27
95456: PUSH
95457: LD_INT 28
95459: PUSH
95460: LD_INT 30
95462: PUSH
95463: LD_INT 31
95465: PUSH
95466: LD_INT 32
95468: PUSH
95469: LD_INT 33
95471: PUSH
95472: LD_INT 34
95474: PUSH
95475: LD_INT 36
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 101
95516: PUSH
95517: LD_INT 102
95519: PUSH
95520: LD_INT 103
95522: PUSH
95523: LD_INT 104
95525: PUSH
95526: LD_INT 105
95528: PUSH
95529: LD_INT 106
95531: PUSH
95532: LD_INT 107
95534: PUSH
95535: LD_INT 108
95537: PUSH
95538: LD_INT 109
95540: PUSH
95541: LD_INT 110
95543: PUSH
95544: LD_INT 111
95546: PUSH
95547: LD_INT 112
95549: PUSH
95550: LD_INT 113
95552: PUSH
95553: LD_INT 114
95555: PUSH
95556: LD_INT 116
95558: PUSH
95559: LD_INT 117
95561: PUSH
95562: LD_INT 118
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: ST_TO_ADDR
95588: GO 97043
95590: LD_INT 13
95592: DOUBLE
95593: EQUAL
95594: IFTRUE 95598
95596: GO 95806
95598: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95599: LD_ADDR_VAR 0 2
95603: PUSH
95604: LD_INT 1
95606: PUSH
95607: LD_INT 2
95609: PUSH
95610: LD_INT 3
95612: PUSH
95613: LD_INT 4
95615: PUSH
95616: LD_INT 5
95618: PUSH
95619: LD_INT 8
95621: PUSH
95622: LD_INT 9
95624: PUSH
95625: LD_INT 10
95627: PUSH
95628: LD_INT 11
95630: PUSH
95631: LD_INT 12
95633: PUSH
95634: LD_INT 14
95636: PUSH
95637: LD_INT 15
95639: PUSH
95640: LD_INT 16
95642: PUSH
95643: LD_INT 17
95645: PUSH
95646: LD_INT 18
95648: PUSH
95649: LD_INT 19
95651: PUSH
95652: LD_INT 20
95654: PUSH
95655: LD_INT 21
95657: PUSH
95658: LD_INT 22
95660: PUSH
95661: LD_INT 23
95663: PUSH
95664: LD_INT 24
95666: PUSH
95667: LD_INT 25
95669: PUSH
95670: LD_INT 26
95672: PUSH
95673: LD_INT 27
95675: PUSH
95676: LD_INT 28
95678: PUSH
95679: LD_INT 30
95681: PUSH
95682: LD_INT 31
95684: PUSH
95685: LD_INT 32
95687: PUSH
95688: LD_INT 33
95690: PUSH
95691: LD_INT 34
95693: PUSH
95694: LD_INT 36
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: PUSH
95730: LD_INT 101
95732: PUSH
95733: LD_INT 102
95735: PUSH
95736: LD_INT 103
95738: PUSH
95739: LD_INT 104
95741: PUSH
95742: LD_INT 105
95744: PUSH
95745: LD_INT 106
95747: PUSH
95748: LD_INT 107
95750: PUSH
95751: LD_INT 108
95753: PUSH
95754: LD_INT 109
95756: PUSH
95757: LD_INT 110
95759: PUSH
95760: LD_INT 111
95762: PUSH
95763: LD_INT 112
95765: PUSH
95766: LD_INT 113
95768: PUSH
95769: LD_INT 114
95771: PUSH
95772: LD_INT 116
95774: PUSH
95775: LD_INT 117
95777: PUSH
95778: LD_INT 118
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: ST_TO_ADDR
95804: GO 97043
95806: LD_INT 14
95808: DOUBLE
95809: EQUAL
95810: IFTRUE 95814
95812: GO 96038
95814: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95815: LD_ADDR_VAR 0 2
95819: PUSH
95820: LD_INT 1
95822: PUSH
95823: LD_INT 2
95825: PUSH
95826: LD_INT 3
95828: PUSH
95829: LD_INT 4
95831: PUSH
95832: LD_INT 5
95834: PUSH
95835: LD_INT 6
95837: PUSH
95838: LD_INT 7
95840: PUSH
95841: LD_INT 8
95843: PUSH
95844: LD_INT 9
95846: PUSH
95847: LD_INT 10
95849: PUSH
95850: LD_INT 11
95852: PUSH
95853: LD_INT 12
95855: PUSH
95856: LD_INT 13
95858: PUSH
95859: LD_INT 14
95861: PUSH
95862: LD_INT 15
95864: PUSH
95865: LD_INT 16
95867: PUSH
95868: LD_INT 17
95870: PUSH
95871: LD_INT 18
95873: PUSH
95874: LD_INT 19
95876: PUSH
95877: LD_INT 20
95879: PUSH
95880: LD_INT 21
95882: PUSH
95883: LD_INT 22
95885: PUSH
95886: LD_INT 23
95888: PUSH
95889: LD_INT 24
95891: PUSH
95892: LD_INT 25
95894: PUSH
95895: LD_INT 26
95897: PUSH
95898: LD_INT 27
95900: PUSH
95901: LD_INT 28
95903: PUSH
95904: LD_INT 29
95906: PUSH
95907: LD_INT 30
95909: PUSH
95910: LD_INT 31
95912: PUSH
95913: LD_INT 32
95915: PUSH
95916: LD_INT 33
95918: PUSH
95919: LD_INT 34
95921: PUSH
95922: LD_INT 36
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: PUSH
95962: LD_INT 101
95964: PUSH
95965: LD_INT 102
95967: PUSH
95968: LD_INT 103
95970: PUSH
95971: LD_INT 104
95973: PUSH
95974: LD_INT 105
95976: PUSH
95977: LD_INT 106
95979: PUSH
95980: LD_INT 107
95982: PUSH
95983: LD_INT 108
95985: PUSH
95986: LD_INT 109
95988: PUSH
95989: LD_INT 110
95991: PUSH
95992: LD_INT 111
95994: PUSH
95995: LD_INT 112
95997: PUSH
95998: LD_INT 113
96000: PUSH
96001: LD_INT 114
96003: PUSH
96004: LD_INT 116
96006: PUSH
96007: LD_INT 117
96009: PUSH
96010: LD_INT 118
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: ST_TO_ADDR
96036: GO 97043
96038: LD_INT 15
96040: DOUBLE
96041: EQUAL
96042: IFTRUE 96046
96044: GO 96270
96046: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96047: LD_ADDR_VAR 0 2
96051: PUSH
96052: LD_INT 1
96054: PUSH
96055: LD_INT 2
96057: PUSH
96058: LD_INT 3
96060: PUSH
96061: LD_INT 4
96063: PUSH
96064: LD_INT 5
96066: PUSH
96067: LD_INT 6
96069: PUSH
96070: LD_INT 7
96072: PUSH
96073: LD_INT 8
96075: PUSH
96076: LD_INT 9
96078: PUSH
96079: LD_INT 10
96081: PUSH
96082: LD_INT 11
96084: PUSH
96085: LD_INT 12
96087: PUSH
96088: LD_INT 13
96090: PUSH
96091: LD_INT 14
96093: PUSH
96094: LD_INT 15
96096: PUSH
96097: LD_INT 16
96099: PUSH
96100: LD_INT 17
96102: PUSH
96103: LD_INT 18
96105: PUSH
96106: LD_INT 19
96108: PUSH
96109: LD_INT 20
96111: PUSH
96112: LD_INT 21
96114: PUSH
96115: LD_INT 22
96117: PUSH
96118: LD_INT 23
96120: PUSH
96121: LD_INT 24
96123: PUSH
96124: LD_INT 25
96126: PUSH
96127: LD_INT 26
96129: PUSH
96130: LD_INT 27
96132: PUSH
96133: LD_INT 28
96135: PUSH
96136: LD_INT 29
96138: PUSH
96139: LD_INT 30
96141: PUSH
96142: LD_INT 31
96144: PUSH
96145: LD_INT 32
96147: PUSH
96148: LD_INT 33
96150: PUSH
96151: LD_INT 34
96153: PUSH
96154: LD_INT 36
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: PUSH
96194: LD_INT 101
96196: PUSH
96197: LD_INT 102
96199: PUSH
96200: LD_INT 103
96202: PUSH
96203: LD_INT 104
96205: PUSH
96206: LD_INT 105
96208: PUSH
96209: LD_INT 106
96211: PUSH
96212: LD_INT 107
96214: PUSH
96215: LD_INT 108
96217: PUSH
96218: LD_INT 109
96220: PUSH
96221: LD_INT 110
96223: PUSH
96224: LD_INT 111
96226: PUSH
96227: LD_INT 112
96229: PUSH
96230: LD_INT 113
96232: PUSH
96233: LD_INT 114
96235: PUSH
96236: LD_INT 116
96238: PUSH
96239: LD_INT 117
96241: PUSH
96242: LD_INT 118
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: ST_TO_ADDR
96268: GO 97043
96270: LD_INT 16
96272: DOUBLE
96273: EQUAL
96274: IFTRUE 96278
96276: GO 96414
96278: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96279: LD_ADDR_VAR 0 2
96283: PUSH
96284: LD_INT 2
96286: PUSH
96287: LD_INT 4
96289: PUSH
96290: LD_INT 5
96292: PUSH
96293: LD_INT 7
96295: PUSH
96296: LD_INT 11
96298: PUSH
96299: LD_INT 12
96301: PUSH
96302: LD_INT 15
96304: PUSH
96305: LD_INT 16
96307: PUSH
96308: LD_INT 20
96310: PUSH
96311: LD_INT 21
96313: PUSH
96314: LD_INT 22
96316: PUSH
96317: LD_INT 23
96319: PUSH
96320: LD_INT 25
96322: PUSH
96323: LD_INT 26
96325: PUSH
96326: LD_INT 30
96328: PUSH
96329: LD_INT 31
96331: PUSH
96332: LD_INT 32
96334: PUSH
96335: LD_INT 33
96337: PUSH
96338: LD_INT 34
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: PUSH
96362: LD_INT 101
96364: PUSH
96365: LD_INT 102
96367: PUSH
96368: LD_INT 103
96370: PUSH
96371: LD_INT 106
96373: PUSH
96374: LD_INT 108
96376: PUSH
96377: LD_INT 112
96379: PUSH
96380: LD_INT 113
96382: PUSH
96383: LD_INT 114
96385: PUSH
96386: LD_INT 116
96388: PUSH
96389: LD_INT 117
96391: PUSH
96392: LD_INT 118
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: ST_TO_ADDR
96412: GO 97043
96414: LD_INT 17
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96422
96420: GO 96646
96422: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96423: LD_ADDR_VAR 0 2
96427: PUSH
96428: LD_INT 1
96430: PUSH
96431: LD_INT 2
96433: PUSH
96434: LD_INT 3
96436: PUSH
96437: LD_INT 4
96439: PUSH
96440: LD_INT 5
96442: PUSH
96443: LD_INT 6
96445: PUSH
96446: LD_INT 7
96448: PUSH
96449: LD_INT 8
96451: PUSH
96452: LD_INT 9
96454: PUSH
96455: LD_INT 10
96457: PUSH
96458: LD_INT 11
96460: PUSH
96461: LD_INT 12
96463: PUSH
96464: LD_INT 13
96466: PUSH
96467: LD_INT 14
96469: PUSH
96470: LD_INT 15
96472: PUSH
96473: LD_INT 16
96475: PUSH
96476: LD_INT 17
96478: PUSH
96479: LD_INT 18
96481: PUSH
96482: LD_INT 19
96484: PUSH
96485: LD_INT 20
96487: PUSH
96488: LD_INT 21
96490: PUSH
96491: LD_INT 22
96493: PUSH
96494: LD_INT 23
96496: PUSH
96497: LD_INT 24
96499: PUSH
96500: LD_INT 25
96502: PUSH
96503: LD_INT 26
96505: PUSH
96506: LD_INT 27
96508: PUSH
96509: LD_INT 28
96511: PUSH
96512: LD_INT 29
96514: PUSH
96515: LD_INT 30
96517: PUSH
96518: LD_INT 31
96520: PUSH
96521: LD_INT 32
96523: PUSH
96524: LD_INT 33
96526: PUSH
96527: LD_INT 34
96529: PUSH
96530: LD_INT 36
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 101
96572: PUSH
96573: LD_INT 102
96575: PUSH
96576: LD_INT 103
96578: PUSH
96579: LD_INT 104
96581: PUSH
96582: LD_INT 105
96584: PUSH
96585: LD_INT 106
96587: PUSH
96588: LD_INT 107
96590: PUSH
96591: LD_INT 108
96593: PUSH
96594: LD_INT 109
96596: PUSH
96597: LD_INT 110
96599: PUSH
96600: LD_INT 111
96602: PUSH
96603: LD_INT 112
96605: PUSH
96606: LD_INT 113
96608: PUSH
96609: LD_INT 114
96611: PUSH
96612: LD_INT 116
96614: PUSH
96615: LD_INT 117
96617: PUSH
96618: LD_INT 118
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: ST_TO_ADDR
96644: GO 97043
96646: LD_INT 18
96648: DOUBLE
96649: EQUAL
96650: IFTRUE 96654
96652: GO 96802
96654: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96655: LD_ADDR_VAR 0 2
96659: PUSH
96660: LD_INT 2
96662: PUSH
96663: LD_INT 4
96665: PUSH
96666: LD_INT 5
96668: PUSH
96669: LD_INT 7
96671: PUSH
96672: LD_INT 11
96674: PUSH
96675: LD_INT 12
96677: PUSH
96678: LD_INT 15
96680: PUSH
96681: LD_INT 16
96683: PUSH
96684: LD_INT 20
96686: PUSH
96687: LD_INT 21
96689: PUSH
96690: LD_INT 22
96692: PUSH
96693: LD_INT 23
96695: PUSH
96696: LD_INT 25
96698: PUSH
96699: LD_INT 26
96701: PUSH
96702: LD_INT 30
96704: PUSH
96705: LD_INT 31
96707: PUSH
96708: LD_INT 32
96710: PUSH
96711: LD_INT 33
96713: PUSH
96714: LD_INT 34
96716: PUSH
96717: LD_INT 35
96719: PUSH
96720: LD_INT 36
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 101
96748: PUSH
96749: LD_INT 102
96751: PUSH
96752: LD_INT 103
96754: PUSH
96755: LD_INT 106
96757: PUSH
96758: LD_INT 108
96760: PUSH
96761: LD_INT 112
96763: PUSH
96764: LD_INT 113
96766: PUSH
96767: LD_INT 114
96769: PUSH
96770: LD_INT 115
96772: PUSH
96773: LD_INT 116
96775: PUSH
96776: LD_INT 117
96778: PUSH
96779: LD_INT 118
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: ST_TO_ADDR
96800: GO 97043
96802: LD_INT 19
96804: DOUBLE
96805: EQUAL
96806: IFTRUE 96810
96808: GO 97042
96810: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96811: LD_ADDR_VAR 0 2
96815: PUSH
96816: LD_INT 1
96818: PUSH
96819: LD_INT 2
96821: PUSH
96822: LD_INT 3
96824: PUSH
96825: LD_INT 4
96827: PUSH
96828: LD_INT 5
96830: PUSH
96831: LD_INT 6
96833: PUSH
96834: LD_INT 7
96836: PUSH
96837: LD_INT 8
96839: PUSH
96840: LD_INT 9
96842: PUSH
96843: LD_INT 10
96845: PUSH
96846: LD_INT 11
96848: PUSH
96849: LD_INT 12
96851: PUSH
96852: LD_INT 13
96854: PUSH
96855: LD_INT 14
96857: PUSH
96858: LD_INT 15
96860: PUSH
96861: LD_INT 16
96863: PUSH
96864: LD_INT 17
96866: PUSH
96867: LD_INT 18
96869: PUSH
96870: LD_INT 19
96872: PUSH
96873: LD_INT 20
96875: PUSH
96876: LD_INT 21
96878: PUSH
96879: LD_INT 22
96881: PUSH
96882: LD_INT 23
96884: PUSH
96885: LD_INT 24
96887: PUSH
96888: LD_INT 25
96890: PUSH
96891: LD_INT 26
96893: PUSH
96894: LD_INT 27
96896: PUSH
96897: LD_INT 28
96899: PUSH
96900: LD_INT 29
96902: PUSH
96903: LD_INT 30
96905: PUSH
96906: LD_INT 31
96908: PUSH
96909: LD_INT 32
96911: PUSH
96912: LD_INT 33
96914: PUSH
96915: LD_INT 34
96917: PUSH
96918: LD_INT 35
96920: PUSH
96921: LD_INT 36
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: PUSH
96962: LD_INT 101
96964: PUSH
96965: LD_INT 102
96967: PUSH
96968: LD_INT 103
96970: PUSH
96971: LD_INT 104
96973: PUSH
96974: LD_INT 105
96976: PUSH
96977: LD_INT 106
96979: PUSH
96980: LD_INT 107
96982: PUSH
96983: LD_INT 108
96985: PUSH
96986: LD_INT 109
96988: PUSH
96989: LD_INT 110
96991: PUSH
96992: LD_INT 111
96994: PUSH
96995: LD_INT 112
96997: PUSH
96998: LD_INT 113
97000: PUSH
97001: LD_INT 114
97003: PUSH
97004: LD_INT 115
97006: PUSH
97007: LD_INT 116
97009: PUSH
97010: LD_INT 117
97012: PUSH
97013: LD_INT 118
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: ST_TO_ADDR
97040: GO 97043
97042: POP
// end else
97043: GO 97274
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97045: LD_ADDR_VAR 0 2
97049: PUSH
97050: LD_INT 1
97052: PUSH
97053: LD_INT 2
97055: PUSH
97056: LD_INT 3
97058: PUSH
97059: LD_INT 4
97061: PUSH
97062: LD_INT 5
97064: PUSH
97065: LD_INT 6
97067: PUSH
97068: LD_INT 7
97070: PUSH
97071: LD_INT 8
97073: PUSH
97074: LD_INT 9
97076: PUSH
97077: LD_INT 10
97079: PUSH
97080: LD_INT 11
97082: PUSH
97083: LD_INT 12
97085: PUSH
97086: LD_INT 13
97088: PUSH
97089: LD_INT 14
97091: PUSH
97092: LD_INT 15
97094: PUSH
97095: LD_INT 16
97097: PUSH
97098: LD_INT 17
97100: PUSH
97101: LD_INT 18
97103: PUSH
97104: LD_INT 19
97106: PUSH
97107: LD_INT 20
97109: PUSH
97110: LD_INT 21
97112: PUSH
97113: LD_INT 22
97115: PUSH
97116: LD_INT 23
97118: PUSH
97119: LD_INT 24
97121: PUSH
97122: LD_INT 25
97124: PUSH
97125: LD_INT 26
97127: PUSH
97128: LD_INT 27
97130: PUSH
97131: LD_INT 28
97133: PUSH
97134: LD_INT 29
97136: PUSH
97137: LD_INT 30
97139: PUSH
97140: LD_INT 31
97142: PUSH
97143: LD_INT 32
97145: PUSH
97146: LD_INT 33
97148: PUSH
97149: LD_INT 34
97151: PUSH
97152: LD_INT 35
97154: PUSH
97155: LD_INT 36
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 101
97198: PUSH
97199: LD_INT 102
97201: PUSH
97202: LD_INT 103
97204: PUSH
97205: LD_INT 104
97207: PUSH
97208: LD_INT 105
97210: PUSH
97211: LD_INT 106
97213: PUSH
97214: LD_INT 107
97216: PUSH
97217: LD_INT 108
97219: PUSH
97220: LD_INT 109
97222: PUSH
97223: LD_INT 110
97225: PUSH
97226: LD_INT 111
97228: PUSH
97229: LD_INT 112
97231: PUSH
97232: LD_INT 113
97234: PUSH
97235: LD_INT 114
97237: PUSH
97238: LD_INT 115
97240: PUSH
97241: LD_INT 116
97243: PUSH
97244: LD_INT 117
97246: PUSH
97247: LD_INT 118
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: PUSH
97270: EMPTY
97271: LIST
97272: LIST
97273: ST_TO_ADDR
// if result then
97274: LD_VAR 0 2
97278: IFFALSE 98064
// begin normal :=  ;
97280: LD_ADDR_VAR 0 5
97284: PUSH
97285: LD_STRING 
97287: ST_TO_ADDR
// hardcore :=  ;
97288: LD_ADDR_VAR 0 6
97292: PUSH
97293: LD_STRING 
97295: ST_TO_ADDR
// active :=  ;
97296: LD_ADDR_VAR 0 7
97300: PUSH
97301: LD_STRING 
97303: ST_TO_ADDR
// for i = 1 to normalCounter do
97304: LD_ADDR_VAR 0 8
97308: PUSH
97309: DOUBLE
97310: LD_INT 1
97312: DEC
97313: ST_TO_ADDR
97314: LD_EXP 97
97318: PUSH
97319: FOR_TO
97320: IFFALSE 97421
// begin tmp := 0 ;
97322: LD_ADDR_VAR 0 3
97326: PUSH
97327: LD_STRING 0
97329: ST_TO_ADDR
// if result [ 1 ] then
97330: LD_VAR 0 2
97334: PUSH
97335: LD_INT 1
97337: ARRAY
97338: IFFALSE 97403
// if result [ 1 ] [ 1 ] = i then
97340: LD_VAR 0 2
97344: PUSH
97345: LD_INT 1
97347: ARRAY
97348: PUSH
97349: LD_INT 1
97351: ARRAY
97352: PUSH
97353: LD_VAR 0 8
97357: EQUAL
97358: IFFALSE 97403
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97360: LD_ADDR_VAR 0 2
97364: PUSH
97365: LD_VAR 0 2
97369: PPUSH
97370: LD_INT 1
97372: PPUSH
97373: LD_VAR 0 2
97377: PUSH
97378: LD_INT 1
97380: ARRAY
97381: PPUSH
97382: LD_INT 1
97384: PPUSH
97385: CALL_OW 3
97389: PPUSH
97390: CALL_OW 1
97394: ST_TO_ADDR
// tmp := 1 ;
97395: LD_ADDR_VAR 0 3
97399: PUSH
97400: LD_STRING 1
97402: ST_TO_ADDR
// end ; normal := normal & tmp ;
97403: LD_ADDR_VAR 0 5
97407: PUSH
97408: LD_VAR 0 5
97412: PUSH
97413: LD_VAR 0 3
97417: STR
97418: ST_TO_ADDR
// end ;
97419: GO 97319
97421: POP
97422: POP
// for i = 1 to hardcoreCounter do
97423: LD_ADDR_VAR 0 8
97427: PUSH
97428: DOUBLE
97429: LD_INT 1
97431: DEC
97432: ST_TO_ADDR
97433: LD_EXP 98
97437: PUSH
97438: FOR_TO
97439: IFFALSE 97544
// begin tmp := 0 ;
97441: LD_ADDR_VAR 0 3
97445: PUSH
97446: LD_STRING 0
97448: ST_TO_ADDR
// if result [ 2 ] then
97449: LD_VAR 0 2
97453: PUSH
97454: LD_INT 2
97456: ARRAY
97457: IFFALSE 97526
// if result [ 2 ] [ 1 ] = 100 + i then
97459: LD_VAR 0 2
97463: PUSH
97464: LD_INT 2
97466: ARRAY
97467: PUSH
97468: LD_INT 1
97470: ARRAY
97471: PUSH
97472: LD_INT 100
97474: PUSH
97475: LD_VAR 0 8
97479: PLUS
97480: EQUAL
97481: IFFALSE 97526
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97483: LD_ADDR_VAR 0 2
97487: PUSH
97488: LD_VAR 0 2
97492: PPUSH
97493: LD_INT 2
97495: PPUSH
97496: LD_VAR 0 2
97500: PUSH
97501: LD_INT 2
97503: ARRAY
97504: PPUSH
97505: LD_INT 1
97507: PPUSH
97508: CALL_OW 3
97512: PPUSH
97513: CALL_OW 1
97517: ST_TO_ADDR
// tmp := 1 ;
97518: LD_ADDR_VAR 0 3
97522: PUSH
97523: LD_STRING 1
97525: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97526: LD_ADDR_VAR 0 6
97530: PUSH
97531: LD_VAR 0 6
97535: PUSH
97536: LD_VAR 0 3
97540: STR
97541: ST_TO_ADDR
// end ;
97542: GO 97438
97544: POP
97545: POP
// if isGameLoad then
97546: LD_VAR 0 1
97550: IFFALSE 98025
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97552: LD_ADDR_VAR 0 4
97556: PUSH
97557: LD_EXP 101
97561: PUSH
97562: LD_EXP 100
97566: PUSH
97567: LD_EXP 102
97571: PUSH
97572: LD_EXP 99
97576: PUSH
97577: LD_EXP 103
97581: PUSH
97582: LD_EXP 104
97586: PUSH
97587: LD_EXP 105
97591: PUSH
97592: LD_EXP 106
97596: PUSH
97597: LD_EXP 107
97601: PUSH
97602: LD_EXP 108
97606: PUSH
97607: LD_EXP 109
97611: PUSH
97612: LD_EXP 110
97616: PUSH
97617: LD_EXP 111
97621: PUSH
97622: LD_EXP 112
97626: PUSH
97627: LD_EXP 120
97631: PUSH
97632: LD_EXP 121
97636: PUSH
97637: LD_EXP 122
97641: PUSH
97642: LD_EXP 123
97646: PUSH
97647: LD_EXP 125
97651: PUSH
97652: LD_EXP 126
97656: PUSH
97657: LD_EXP 127
97661: PUSH
97662: LD_EXP 130
97666: PUSH
97667: LD_EXP 132
97671: PUSH
97672: LD_EXP 133
97676: PUSH
97677: LD_EXP 134
97681: PUSH
97682: LD_EXP 136
97686: PUSH
97687: LD_EXP 137
97691: PUSH
97692: LD_EXP 140
97696: PUSH
97697: LD_EXP 141
97701: PUSH
97702: LD_EXP 142
97706: PUSH
97707: LD_EXP 143
97711: PUSH
97712: LD_EXP 144
97716: PUSH
97717: LD_EXP 145
97721: PUSH
97722: LD_EXP 146
97726: PUSH
97727: LD_EXP 147
97731: PUSH
97732: LD_EXP 148
97736: PUSH
97737: LD_EXP 113
97741: PUSH
97742: LD_EXP 114
97746: PUSH
97747: LD_EXP 117
97751: PUSH
97752: LD_EXP 118
97756: PUSH
97757: LD_EXP 119
97761: PUSH
97762: LD_EXP 115
97766: PUSH
97767: LD_EXP 116
97771: PUSH
97772: LD_EXP 124
97776: PUSH
97777: LD_EXP 128
97781: PUSH
97782: LD_EXP 129
97786: PUSH
97787: LD_EXP 131
97791: PUSH
97792: LD_EXP 135
97796: PUSH
97797: LD_EXP 138
97801: PUSH
97802: LD_EXP 139
97806: PUSH
97807: LD_EXP 149
97811: PUSH
97812: LD_EXP 150
97816: PUSH
97817: LD_EXP 151
97821: PUSH
97822: LD_EXP 152
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: ST_TO_ADDR
// tmp :=  ;
97883: LD_ADDR_VAR 0 3
97887: PUSH
97888: LD_STRING 
97890: ST_TO_ADDR
// for i = 1 to normalCounter do
97891: LD_ADDR_VAR 0 8
97895: PUSH
97896: DOUBLE
97897: LD_INT 1
97899: DEC
97900: ST_TO_ADDR
97901: LD_EXP 97
97905: PUSH
97906: FOR_TO
97907: IFFALSE 97943
// begin if flags [ i ] then
97909: LD_VAR 0 4
97913: PUSH
97914: LD_VAR 0 8
97918: ARRAY
97919: IFFALSE 97941
// tmp := tmp & i & ; ;
97921: LD_ADDR_VAR 0 3
97925: PUSH
97926: LD_VAR 0 3
97930: PUSH
97931: LD_VAR 0 8
97935: STR
97936: PUSH
97937: LD_STRING ;
97939: STR
97940: ST_TO_ADDR
// end ;
97941: GO 97906
97943: POP
97944: POP
// for i = 1 to hardcoreCounter do
97945: LD_ADDR_VAR 0 8
97949: PUSH
97950: DOUBLE
97951: LD_INT 1
97953: DEC
97954: ST_TO_ADDR
97955: LD_EXP 98
97959: PUSH
97960: FOR_TO
97961: IFFALSE 98007
// begin if flags [ normalCounter + i ] then
97963: LD_VAR 0 4
97967: PUSH
97968: LD_EXP 97
97972: PUSH
97973: LD_VAR 0 8
97977: PLUS
97978: ARRAY
97979: IFFALSE 98005
// tmp := tmp & ( 100 + i ) & ; ;
97981: LD_ADDR_VAR 0 3
97985: PUSH
97986: LD_VAR 0 3
97990: PUSH
97991: LD_INT 100
97993: PUSH
97994: LD_VAR 0 8
97998: PLUS
97999: STR
98000: PUSH
98001: LD_STRING ;
98003: STR
98004: ST_TO_ADDR
// end ;
98005: GO 97960
98007: POP
98008: POP
// if tmp then
98009: LD_VAR 0 3
98013: IFFALSE 98025
// active := tmp ;
98015: LD_ADDR_VAR 0 7
98019: PUSH
98020: LD_VAR 0 3
98024: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98025: LD_STRING getStreamItemsFromMission("
98027: PUSH
98028: LD_VAR 0 5
98032: STR
98033: PUSH
98034: LD_STRING ","
98036: STR
98037: PUSH
98038: LD_VAR 0 6
98042: STR
98043: PUSH
98044: LD_STRING ","
98046: STR
98047: PUSH
98048: LD_VAR 0 7
98052: STR
98053: PUSH
98054: LD_STRING ")
98056: STR
98057: PPUSH
98058: CALL_OW 559
// end else
98062: GO 98071
// ToLua ( getStreamItemsFromMission("","","") ) ;
98064: LD_STRING getStreamItemsFromMission("","","")
98066: PPUSH
98067: CALL_OW 559
// end ;
98071: LD_VAR 0 2
98075: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98076: LD_EXP 96
98080: PUSH
98081: LD_EXP 101
98085: AND
98086: IFFALSE 98210
98088: GO 98090
98090: DISABLE
98091: LD_INT 0
98093: PPUSH
98094: PPUSH
// begin enable ;
98095: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98096: LD_ADDR_VAR 0 2
98100: PUSH
98101: LD_INT 22
98103: PUSH
98104: LD_OWVAR 2
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: PUSH
98113: LD_INT 2
98115: PUSH
98116: LD_INT 34
98118: PUSH
98119: LD_INT 7
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 34
98128: PUSH
98129: LD_INT 45
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: LD_INT 34
98138: PUSH
98139: LD_INT 28
98141: PUSH
98142: EMPTY
98143: LIST
98144: LIST
98145: PUSH
98146: LD_INT 34
98148: PUSH
98149: LD_INT 47
98151: PUSH
98152: EMPTY
98153: LIST
98154: LIST
98155: PUSH
98156: EMPTY
98157: LIST
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: PPUSH
98167: CALL_OW 69
98171: ST_TO_ADDR
// if not tmp then
98172: LD_VAR 0 2
98176: NOT
98177: IFFALSE 98181
// exit ;
98179: GO 98210
// for i in tmp do
98181: LD_ADDR_VAR 0 1
98185: PUSH
98186: LD_VAR 0 2
98190: PUSH
98191: FOR_IN
98192: IFFALSE 98208
// begin SetLives ( i , 0 ) ;
98194: LD_VAR 0 1
98198: PPUSH
98199: LD_INT 0
98201: PPUSH
98202: CALL_OW 234
// end ;
98206: GO 98191
98208: POP
98209: POP
// end ;
98210: PPOPN 2
98212: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98213: LD_EXP 96
98217: PUSH
98218: LD_EXP 102
98222: AND
98223: IFFALSE 98307
98225: GO 98227
98227: DISABLE
98228: LD_INT 0
98230: PPUSH
98231: PPUSH
// begin enable ;
98232: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98233: LD_ADDR_VAR 0 2
98237: PUSH
98238: LD_INT 22
98240: PUSH
98241: LD_OWVAR 2
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: PUSH
98250: LD_INT 32
98252: PUSH
98253: LD_INT 3
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PUSH
98260: EMPTY
98261: LIST
98262: LIST
98263: PPUSH
98264: CALL_OW 69
98268: ST_TO_ADDR
// if not tmp then
98269: LD_VAR 0 2
98273: NOT
98274: IFFALSE 98278
// exit ;
98276: GO 98307
// for i in tmp do
98278: LD_ADDR_VAR 0 1
98282: PUSH
98283: LD_VAR 0 2
98287: PUSH
98288: FOR_IN
98289: IFFALSE 98305
// begin SetLives ( i , 0 ) ;
98291: LD_VAR 0 1
98295: PPUSH
98296: LD_INT 0
98298: PPUSH
98299: CALL_OW 234
// end ;
98303: GO 98288
98305: POP
98306: POP
// end ;
98307: PPOPN 2
98309: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98310: LD_EXP 96
98314: PUSH
98315: LD_EXP 99
98319: AND
98320: IFFALSE 98413
98322: GO 98324
98324: DISABLE
98325: LD_INT 0
98327: PPUSH
// begin enable ;
98328: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98329: LD_ADDR_VAR 0 1
98333: PUSH
98334: LD_INT 22
98336: PUSH
98337: LD_OWVAR 2
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 2
98348: PUSH
98349: LD_INT 25
98351: PUSH
98352: LD_INT 5
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 25
98361: PUSH
98362: LD_INT 9
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 25
98371: PUSH
98372: LD_INT 8
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: PPUSH
98389: CALL_OW 69
98393: PUSH
98394: FOR_IN
98395: IFFALSE 98411
// begin SetClass ( i , 1 ) ;
98397: LD_VAR 0 1
98401: PPUSH
98402: LD_INT 1
98404: PPUSH
98405: CALL_OW 336
// end ;
98409: GO 98394
98411: POP
98412: POP
// end ;
98413: PPOPN 1
98415: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98416: LD_EXP 96
98420: PUSH
98421: LD_EXP 100
98425: AND
98426: PUSH
98427: LD_OWVAR 65
98431: PUSH
98432: LD_INT 7
98434: LESS
98435: AND
98436: IFFALSE 98450
98438: GO 98440
98440: DISABLE
// begin enable ;
98441: ENABLE
// game_speed := 7 ;
98442: LD_ADDR_OWVAR 65
98446: PUSH
98447: LD_INT 7
98449: ST_TO_ADDR
// end ;
98450: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98451: LD_EXP 96
98455: PUSH
98456: LD_EXP 103
98460: AND
98461: IFFALSE 98663
98463: GO 98465
98465: DISABLE
98466: LD_INT 0
98468: PPUSH
98469: PPUSH
98470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98471: LD_ADDR_VAR 0 3
98475: PUSH
98476: LD_INT 81
98478: PUSH
98479: LD_OWVAR 2
98483: PUSH
98484: EMPTY
98485: LIST
98486: LIST
98487: PUSH
98488: LD_INT 21
98490: PUSH
98491: LD_INT 1
98493: PUSH
98494: EMPTY
98495: LIST
98496: LIST
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: PPUSH
98502: CALL_OW 69
98506: ST_TO_ADDR
// if not tmp then
98507: LD_VAR 0 3
98511: NOT
98512: IFFALSE 98516
// exit ;
98514: GO 98663
// if tmp > 5 then
98516: LD_VAR 0 3
98520: PUSH
98521: LD_INT 5
98523: GREATER
98524: IFFALSE 98536
// k := 5 else
98526: LD_ADDR_VAR 0 2
98530: PUSH
98531: LD_INT 5
98533: ST_TO_ADDR
98534: GO 98546
// k := tmp ;
98536: LD_ADDR_VAR 0 2
98540: PUSH
98541: LD_VAR 0 3
98545: ST_TO_ADDR
// for i := 1 to k do
98546: LD_ADDR_VAR 0 1
98550: PUSH
98551: DOUBLE
98552: LD_INT 1
98554: DEC
98555: ST_TO_ADDR
98556: LD_VAR 0 2
98560: PUSH
98561: FOR_TO
98562: IFFALSE 98661
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98564: LD_VAR 0 3
98568: PUSH
98569: LD_VAR 0 1
98573: ARRAY
98574: PPUSH
98575: LD_VAR 0 1
98579: PUSH
98580: LD_INT 4
98582: MOD
98583: PUSH
98584: LD_INT 1
98586: PLUS
98587: PPUSH
98588: CALL_OW 259
98592: PUSH
98593: LD_INT 10
98595: LESS
98596: IFFALSE 98659
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98598: LD_VAR 0 3
98602: PUSH
98603: LD_VAR 0 1
98607: ARRAY
98608: PPUSH
98609: LD_VAR 0 1
98613: PUSH
98614: LD_INT 4
98616: MOD
98617: PUSH
98618: LD_INT 1
98620: PLUS
98621: PPUSH
98622: LD_VAR 0 3
98626: PUSH
98627: LD_VAR 0 1
98631: ARRAY
98632: PPUSH
98633: LD_VAR 0 1
98637: PUSH
98638: LD_INT 4
98640: MOD
98641: PUSH
98642: LD_INT 1
98644: PLUS
98645: PPUSH
98646: CALL_OW 259
98650: PUSH
98651: LD_INT 1
98653: PLUS
98654: PPUSH
98655: CALL_OW 237
98659: GO 98561
98661: POP
98662: POP
// end ;
98663: PPOPN 3
98665: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98666: LD_EXP 96
98670: PUSH
98671: LD_EXP 104
98675: AND
98676: IFFALSE 98696
98678: GO 98680
98680: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98681: LD_INT 4
98683: PPUSH
98684: LD_OWVAR 2
98688: PPUSH
98689: LD_INT 0
98691: PPUSH
98692: CALL_OW 324
98696: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98697: LD_EXP 96
98701: PUSH
98702: LD_EXP 133
98706: AND
98707: IFFALSE 98727
98709: GO 98711
98711: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98712: LD_INT 19
98714: PPUSH
98715: LD_OWVAR 2
98719: PPUSH
98720: LD_INT 0
98722: PPUSH
98723: CALL_OW 324
98727: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98728: LD_EXP 96
98732: PUSH
98733: LD_EXP 105
98737: AND
98738: IFFALSE 98840
98740: GO 98742
98742: DISABLE
98743: LD_INT 0
98745: PPUSH
98746: PPUSH
// begin enable ;
98747: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98748: LD_ADDR_VAR 0 2
98752: PUSH
98753: LD_INT 22
98755: PUSH
98756: LD_OWVAR 2
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 2
98767: PUSH
98768: LD_INT 34
98770: PUSH
98771: LD_INT 11
98773: PUSH
98774: EMPTY
98775: LIST
98776: LIST
98777: PUSH
98778: LD_INT 34
98780: PUSH
98781: LD_INT 30
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: LIST
98792: PUSH
98793: EMPTY
98794: LIST
98795: LIST
98796: PPUSH
98797: CALL_OW 69
98801: ST_TO_ADDR
// if not tmp then
98802: LD_VAR 0 2
98806: NOT
98807: IFFALSE 98811
// exit ;
98809: GO 98840
// for i in tmp do
98811: LD_ADDR_VAR 0 1
98815: PUSH
98816: LD_VAR 0 2
98820: PUSH
98821: FOR_IN
98822: IFFALSE 98838
// begin SetLives ( i , 0 ) ;
98824: LD_VAR 0 1
98828: PPUSH
98829: LD_INT 0
98831: PPUSH
98832: CALL_OW 234
// end ;
98836: GO 98821
98838: POP
98839: POP
// end ;
98840: PPOPN 2
98842: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98843: LD_EXP 96
98847: PUSH
98848: LD_EXP 106
98852: AND
98853: IFFALSE 98873
98855: GO 98857
98857: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98858: LD_INT 32
98860: PPUSH
98861: LD_OWVAR 2
98865: PPUSH
98866: LD_INT 0
98868: PPUSH
98869: CALL_OW 324
98873: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98874: LD_EXP 96
98878: PUSH
98879: LD_EXP 107
98883: AND
98884: IFFALSE 99065
98886: GO 98888
98888: DISABLE
98889: LD_INT 0
98891: PPUSH
98892: PPUSH
98893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98894: LD_ADDR_VAR 0 2
98898: PUSH
98899: LD_INT 22
98901: PUSH
98902: LD_OWVAR 2
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: PUSH
98911: LD_INT 33
98913: PUSH
98914: LD_INT 3
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PPUSH
98925: CALL_OW 69
98929: ST_TO_ADDR
// if not tmp then
98930: LD_VAR 0 2
98934: NOT
98935: IFFALSE 98939
// exit ;
98937: GO 99065
// side := 0 ;
98939: LD_ADDR_VAR 0 3
98943: PUSH
98944: LD_INT 0
98946: ST_TO_ADDR
// for i := 1 to 8 do
98947: LD_ADDR_VAR 0 1
98951: PUSH
98952: DOUBLE
98953: LD_INT 1
98955: DEC
98956: ST_TO_ADDR
98957: LD_INT 8
98959: PUSH
98960: FOR_TO
98961: IFFALSE 99009
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98963: LD_OWVAR 2
98967: PUSH
98968: LD_VAR 0 1
98972: NONEQUAL
98973: PUSH
98974: LD_OWVAR 2
98978: PPUSH
98979: LD_VAR 0 1
98983: PPUSH
98984: CALL_OW 81
98988: PUSH
98989: LD_INT 2
98991: EQUAL
98992: AND
98993: IFFALSE 99007
// begin side := i ;
98995: LD_ADDR_VAR 0 3
98999: PUSH
99000: LD_VAR 0 1
99004: ST_TO_ADDR
// break ;
99005: GO 99009
// end ;
99007: GO 98960
99009: POP
99010: POP
// if not side then
99011: LD_VAR 0 3
99015: NOT
99016: IFFALSE 99020
// exit ;
99018: GO 99065
// for i := 1 to tmp do
99020: LD_ADDR_VAR 0 1
99024: PUSH
99025: DOUBLE
99026: LD_INT 1
99028: DEC
99029: ST_TO_ADDR
99030: LD_VAR 0 2
99034: PUSH
99035: FOR_TO
99036: IFFALSE 99063
// if Prob ( 60 ) then
99038: LD_INT 60
99040: PPUSH
99041: CALL_OW 13
99045: IFFALSE 99061
// SetSide ( i , side ) ;
99047: LD_VAR 0 1
99051: PPUSH
99052: LD_VAR 0 3
99056: PPUSH
99057: CALL_OW 235
99061: GO 99035
99063: POP
99064: POP
// end ;
99065: PPOPN 3
99067: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99068: LD_EXP 96
99072: PUSH
99073: LD_EXP 109
99077: AND
99078: IFFALSE 99197
99080: GO 99082
99082: DISABLE
99083: LD_INT 0
99085: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99086: LD_ADDR_VAR 0 1
99090: PUSH
99091: LD_INT 22
99093: PUSH
99094: LD_OWVAR 2
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PUSH
99103: LD_INT 21
99105: PUSH
99106: LD_INT 1
99108: PUSH
99109: EMPTY
99110: LIST
99111: LIST
99112: PUSH
99113: LD_INT 3
99115: PUSH
99116: LD_INT 23
99118: PUSH
99119: LD_INT 0
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: PUSH
99126: EMPTY
99127: LIST
99128: LIST
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: LIST
99134: PPUSH
99135: CALL_OW 69
99139: PUSH
99140: FOR_IN
99141: IFFALSE 99195
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99143: LD_VAR 0 1
99147: PPUSH
99148: CALL_OW 257
99152: PUSH
99153: LD_INT 1
99155: PUSH
99156: LD_INT 2
99158: PUSH
99159: LD_INT 3
99161: PUSH
99162: LD_INT 4
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: IN
99171: IFFALSE 99193
// SetClass ( un , rand ( 1 , 4 ) ) ;
99173: LD_VAR 0 1
99177: PPUSH
99178: LD_INT 1
99180: PPUSH
99181: LD_INT 4
99183: PPUSH
99184: CALL_OW 12
99188: PPUSH
99189: CALL_OW 336
99193: GO 99140
99195: POP
99196: POP
// end ;
99197: PPOPN 1
99199: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99200: LD_EXP 96
99204: PUSH
99205: LD_EXP 108
99209: AND
99210: IFFALSE 99289
99212: GO 99214
99214: DISABLE
99215: LD_INT 0
99217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99218: LD_ADDR_VAR 0 1
99222: PUSH
99223: LD_INT 22
99225: PUSH
99226: LD_OWVAR 2
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: PUSH
99235: LD_INT 21
99237: PUSH
99238: LD_INT 3
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PPUSH
99249: CALL_OW 69
99253: ST_TO_ADDR
// if not tmp then
99254: LD_VAR 0 1
99258: NOT
99259: IFFALSE 99263
// exit ;
99261: GO 99289
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99263: LD_VAR 0 1
99267: PUSH
99268: LD_INT 1
99270: PPUSH
99271: LD_VAR 0 1
99275: PPUSH
99276: CALL_OW 12
99280: ARRAY
99281: PPUSH
99282: LD_INT 100
99284: PPUSH
99285: CALL_OW 234
// end ;
99289: PPOPN 1
99291: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99292: LD_EXP 96
99296: PUSH
99297: LD_EXP 110
99301: AND
99302: IFFALSE 99400
99304: GO 99306
99306: DISABLE
99307: LD_INT 0
99309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99310: LD_ADDR_VAR 0 1
99314: PUSH
99315: LD_INT 22
99317: PUSH
99318: LD_OWVAR 2
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: PUSH
99327: LD_INT 21
99329: PUSH
99330: LD_INT 1
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: PPUSH
99341: CALL_OW 69
99345: ST_TO_ADDR
// if not tmp then
99346: LD_VAR 0 1
99350: NOT
99351: IFFALSE 99355
// exit ;
99353: GO 99400
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99355: LD_VAR 0 1
99359: PUSH
99360: LD_INT 1
99362: PPUSH
99363: LD_VAR 0 1
99367: PPUSH
99368: CALL_OW 12
99372: ARRAY
99373: PPUSH
99374: LD_INT 1
99376: PPUSH
99377: LD_INT 4
99379: PPUSH
99380: CALL_OW 12
99384: PPUSH
99385: LD_INT 3000
99387: PPUSH
99388: LD_INT 9000
99390: PPUSH
99391: CALL_OW 12
99395: PPUSH
99396: CALL_OW 492
// end ;
99400: PPOPN 1
99402: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99403: LD_EXP 96
99407: PUSH
99408: LD_EXP 111
99412: AND
99413: IFFALSE 99433
99415: GO 99417
99417: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99418: LD_INT 1
99420: PPUSH
99421: LD_OWVAR 2
99425: PPUSH
99426: LD_INT 0
99428: PPUSH
99429: CALL_OW 324
99433: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99434: LD_EXP 96
99438: PUSH
99439: LD_EXP 112
99443: AND
99444: IFFALSE 99527
99446: GO 99448
99448: DISABLE
99449: LD_INT 0
99451: PPUSH
99452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99453: LD_ADDR_VAR 0 2
99457: PUSH
99458: LD_INT 22
99460: PUSH
99461: LD_OWVAR 2
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PUSH
99470: LD_INT 21
99472: PUSH
99473: LD_INT 3
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PUSH
99480: EMPTY
99481: LIST
99482: LIST
99483: PPUSH
99484: CALL_OW 69
99488: ST_TO_ADDR
// if not tmp then
99489: LD_VAR 0 2
99493: NOT
99494: IFFALSE 99498
// exit ;
99496: GO 99527
// for i in tmp do
99498: LD_ADDR_VAR 0 1
99502: PUSH
99503: LD_VAR 0 2
99507: PUSH
99508: FOR_IN
99509: IFFALSE 99525
// SetBLevel ( i , 10 ) ;
99511: LD_VAR 0 1
99515: PPUSH
99516: LD_INT 10
99518: PPUSH
99519: CALL_OW 241
99523: GO 99508
99525: POP
99526: POP
// end ;
99527: PPOPN 2
99529: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99530: LD_EXP 96
99534: PUSH
99535: LD_EXP 113
99539: AND
99540: IFFALSE 99651
99542: GO 99544
99544: DISABLE
99545: LD_INT 0
99547: PPUSH
99548: PPUSH
99549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99550: LD_ADDR_VAR 0 3
99554: PUSH
99555: LD_INT 22
99557: PUSH
99558: LD_OWVAR 2
99562: PUSH
99563: EMPTY
99564: LIST
99565: LIST
99566: PUSH
99567: LD_INT 25
99569: PUSH
99570: LD_INT 1
99572: PUSH
99573: EMPTY
99574: LIST
99575: LIST
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: PPUSH
99581: CALL_OW 69
99585: ST_TO_ADDR
// if not tmp then
99586: LD_VAR 0 3
99590: NOT
99591: IFFALSE 99595
// exit ;
99593: GO 99651
// un := tmp [ rand ( 1 , tmp ) ] ;
99595: LD_ADDR_VAR 0 2
99599: PUSH
99600: LD_VAR 0 3
99604: PUSH
99605: LD_INT 1
99607: PPUSH
99608: LD_VAR 0 3
99612: PPUSH
99613: CALL_OW 12
99617: ARRAY
99618: ST_TO_ADDR
// if Crawls ( un ) then
99619: LD_VAR 0 2
99623: PPUSH
99624: CALL_OW 318
99628: IFFALSE 99639
// ComWalk ( un ) ;
99630: LD_VAR 0 2
99634: PPUSH
99635: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99639: LD_VAR 0 2
99643: PPUSH
99644: LD_INT 5
99646: PPUSH
99647: CALL_OW 336
// end ;
99651: PPOPN 3
99653: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99654: LD_EXP 96
99658: PUSH
99659: LD_EXP 114
99663: AND
99664: PUSH
99665: LD_OWVAR 67
99669: PUSH
99670: LD_INT 4
99672: LESS
99673: AND
99674: IFFALSE 99693
99676: GO 99678
99678: DISABLE
// begin Difficulty := Difficulty + 1 ;
99679: LD_ADDR_OWVAR 67
99683: PUSH
99684: LD_OWVAR 67
99688: PUSH
99689: LD_INT 1
99691: PLUS
99692: ST_TO_ADDR
// end ;
99693: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99694: LD_EXP 96
99698: PUSH
99699: LD_EXP 115
99703: AND
99704: IFFALSE 99807
99706: GO 99708
99708: DISABLE
99709: LD_INT 0
99711: PPUSH
// begin for i := 1 to 5 do
99712: LD_ADDR_VAR 0 1
99716: PUSH
99717: DOUBLE
99718: LD_INT 1
99720: DEC
99721: ST_TO_ADDR
99722: LD_INT 5
99724: PUSH
99725: FOR_TO
99726: IFFALSE 99805
// begin uc_nation := nation_nature ;
99728: LD_ADDR_OWVAR 21
99732: PUSH
99733: LD_INT 0
99735: ST_TO_ADDR
// uc_side := 0 ;
99736: LD_ADDR_OWVAR 20
99740: PUSH
99741: LD_INT 0
99743: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99744: LD_ADDR_OWVAR 29
99748: PUSH
99749: LD_INT 12
99751: PUSH
99752: LD_INT 12
99754: PUSH
99755: EMPTY
99756: LIST
99757: LIST
99758: ST_TO_ADDR
// hc_agressivity := 20 ;
99759: LD_ADDR_OWVAR 35
99763: PUSH
99764: LD_INT 20
99766: ST_TO_ADDR
// hc_class := class_tiger ;
99767: LD_ADDR_OWVAR 28
99771: PUSH
99772: LD_INT 14
99774: ST_TO_ADDR
// hc_gallery :=  ;
99775: LD_ADDR_OWVAR 33
99779: PUSH
99780: LD_STRING 
99782: ST_TO_ADDR
// hc_name :=  ;
99783: LD_ADDR_OWVAR 26
99787: PUSH
99788: LD_STRING 
99790: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99791: CALL_OW 44
99795: PPUSH
99796: LD_INT 0
99798: PPUSH
99799: CALL_OW 51
// end ;
99803: GO 99725
99805: POP
99806: POP
// end ;
99807: PPOPN 1
99809: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99810: LD_EXP 96
99814: PUSH
99815: LD_EXP 116
99819: AND
99820: IFFALSE 99829
99822: GO 99824
99824: DISABLE
// StreamSibBomb ;
99825: CALL 99830 0 0
99829: END
// export function StreamSibBomb ; var i , x , y ; begin
99830: LD_INT 0
99832: PPUSH
99833: PPUSH
99834: PPUSH
99835: PPUSH
// result := false ;
99836: LD_ADDR_VAR 0 1
99840: PUSH
99841: LD_INT 0
99843: ST_TO_ADDR
// for i := 1 to 16 do
99844: LD_ADDR_VAR 0 2
99848: PUSH
99849: DOUBLE
99850: LD_INT 1
99852: DEC
99853: ST_TO_ADDR
99854: LD_INT 16
99856: PUSH
99857: FOR_TO
99858: IFFALSE 100057
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99860: LD_ADDR_VAR 0 3
99864: PUSH
99865: LD_INT 10
99867: PUSH
99868: LD_INT 20
99870: PUSH
99871: LD_INT 30
99873: PUSH
99874: LD_INT 40
99876: PUSH
99877: LD_INT 50
99879: PUSH
99880: LD_INT 60
99882: PUSH
99883: LD_INT 70
99885: PUSH
99886: LD_INT 80
99888: PUSH
99889: LD_INT 90
99891: PUSH
99892: LD_INT 100
99894: PUSH
99895: LD_INT 110
99897: PUSH
99898: LD_INT 120
99900: PUSH
99901: LD_INT 130
99903: PUSH
99904: LD_INT 140
99906: PUSH
99907: LD_INT 150
99909: PUSH
99910: EMPTY
99911: LIST
99912: LIST
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: PUSH
99927: LD_INT 1
99929: PPUSH
99930: LD_INT 15
99932: PPUSH
99933: CALL_OW 12
99937: ARRAY
99938: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99939: LD_ADDR_VAR 0 4
99943: PUSH
99944: LD_INT 10
99946: PUSH
99947: LD_INT 20
99949: PUSH
99950: LD_INT 30
99952: PUSH
99953: LD_INT 40
99955: PUSH
99956: LD_INT 50
99958: PUSH
99959: LD_INT 60
99961: PUSH
99962: LD_INT 70
99964: PUSH
99965: LD_INT 80
99967: PUSH
99968: LD_INT 90
99970: PUSH
99971: LD_INT 100
99973: PUSH
99974: LD_INT 110
99976: PUSH
99977: LD_INT 120
99979: PUSH
99980: LD_INT 130
99982: PUSH
99983: LD_INT 140
99985: PUSH
99986: LD_INT 150
99988: PUSH
99989: EMPTY
99990: LIST
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: PUSH
100006: LD_INT 1
100008: PPUSH
100009: LD_INT 15
100011: PPUSH
100012: CALL_OW 12
100016: ARRAY
100017: ST_TO_ADDR
// if ValidHex ( x , y ) then
100018: LD_VAR 0 3
100022: PPUSH
100023: LD_VAR 0 4
100027: PPUSH
100028: CALL_OW 488
100032: IFFALSE 100055
// begin result := [ x , y ] ;
100034: LD_ADDR_VAR 0 1
100038: PUSH
100039: LD_VAR 0 3
100043: PUSH
100044: LD_VAR 0 4
100048: PUSH
100049: EMPTY
100050: LIST
100051: LIST
100052: ST_TO_ADDR
// break ;
100053: GO 100057
// end ; end ;
100055: GO 99857
100057: POP
100058: POP
// if result then
100059: LD_VAR 0 1
100063: IFFALSE 100123
// begin ToLua ( playSibBomb() ) ;
100065: LD_STRING playSibBomb()
100067: PPUSH
100068: CALL_OW 559
// wait ( 0 0$14 ) ;
100072: LD_INT 490
100074: PPUSH
100075: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100079: LD_VAR 0 1
100083: PUSH
100084: LD_INT 1
100086: ARRAY
100087: PPUSH
100088: LD_VAR 0 1
100092: PUSH
100093: LD_INT 2
100095: ARRAY
100096: PPUSH
100097: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100101: LD_VAR 0 1
100105: PUSH
100106: LD_INT 1
100108: ARRAY
100109: PPUSH
100110: LD_VAR 0 1
100114: PUSH
100115: LD_INT 2
100117: ARRAY
100118: PPUSH
100119: CALL_OW 429
// end ; end ;
100123: LD_VAR 0 1
100127: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100128: LD_EXP 96
100132: PUSH
100133: LD_EXP 118
100137: AND
100138: IFFALSE 100150
100140: GO 100142
100142: DISABLE
// YouLost (  ) ;
100143: LD_STRING 
100145: PPUSH
100146: CALL_OW 104
100150: END
// every 0 0$1 trigger StreamModeActive and sFog do
100151: LD_EXP 96
100155: PUSH
100156: LD_EXP 117
100160: AND
100161: IFFALSE 100175
100163: GO 100165
100165: DISABLE
// FogOff ( your_side ) ;
100166: LD_OWVAR 2
100170: PPUSH
100171: CALL_OW 344
100175: END
// every 0 0$1 trigger StreamModeActive and sSun do
100176: LD_EXP 96
100180: PUSH
100181: LD_EXP 119
100185: AND
100186: IFFALSE 100214
100188: GO 100190
100190: DISABLE
// begin solar_recharge_percent := 0 ;
100191: LD_ADDR_OWVAR 79
100195: PUSH
100196: LD_INT 0
100198: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100199: LD_INT 10500
100201: PPUSH
100202: CALL_OW 67
// solar_recharge_percent := 100 ;
100206: LD_ADDR_OWVAR 79
100210: PUSH
100211: LD_INT 100
100213: ST_TO_ADDR
// end ;
100214: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100215: LD_EXP 96
100219: PUSH
100220: LD_EXP 120
100224: AND
100225: IFFALSE 100464
100227: GO 100229
100229: DISABLE
100230: LD_INT 0
100232: PPUSH
100233: PPUSH
100234: PPUSH
// begin tmp := [ ] ;
100235: LD_ADDR_VAR 0 3
100239: PUSH
100240: EMPTY
100241: ST_TO_ADDR
// for i := 1 to 6 do
100242: LD_ADDR_VAR 0 1
100246: PUSH
100247: DOUBLE
100248: LD_INT 1
100250: DEC
100251: ST_TO_ADDR
100252: LD_INT 6
100254: PUSH
100255: FOR_TO
100256: IFFALSE 100361
// begin uc_nation := nation_nature ;
100258: LD_ADDR_OWVAR 21
100262: PUSH
100263: LD_INT 0
100265: ST_TO_ADDR
// uc_side := 0 ;
100266: LD_ADDR_OWVAR 20
100270: PUSH
100271: LD_INT 0
100273: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100274: LD_ADDR_OWVAR 29
100278: PUSH
100279: LD_INT 12
100281: PUSH
100282: LD_INT 12
100284: PUSH
100285: EMPTY
100286: LIST
100287: LIST
100288: ST_TO_ADDR
// hc_agressivity := 20 ;
100289: LD_ADDR_OWVAR 35
100293: PUSH
100294: LD_INT 20
100296: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100297: LD_ADDR_OWVAR 28
100301: PUSH
100302: LD_INT 17
100304: ST_TO_ADDR
// hc_gallery :=  ;
100305: LD_ADDR_OWVAR 33
100309: PUSH
100310: LD_STRING 
100312: ST_TO_ADDR
// hc_name :=  ;
100313: LD_ADDR_OWVAR 26
100317: PUSH
100318: LD_STRING 
100320: ST_TO_ADDR
// un := CreateHuman ;
100321: LD_ADDR_VAR 0 2
100325: PUSH
100326: CALL_OW 44
100330: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100331: LD_VAR 0 2
100335: PPUSH
100336: LD_INT 1
100338: PPUSH
100339: CALL_OW 51
// tmp := tmp ^ un ;
100343: LD_ADDR_VAR 0 3
100347: PUSH
100348: LD_VAR 0 3
100352: PUSH
100353: LD_VAR 0 2
100357: ADD
100358: ST_TO_ADDR
// end ;
100359: GO 100255
100361: POP
100362: POP
// repeat wait ( 0 0$1 ) ;
100363: LD_INT 35
100365: PPUSH
100366: CALL_OW 67
// for un in tmp do
100370: LD_ADDR_VAR 0 2
100374: PUSH
100375: LD_VAR 0 3
100379: PUSH
100380: FOR_IN
100381: IFFALSE 100455
// begin if IsDead ( un ) then
100383: LD_VAR 0 2
100387: PPUSH
100388: CALL_OW 301
100392: IFFALSE 100412
// begin tmp := tmp diff un ;
100394: LD_ADDR_VAR 0 3
100398: PUSH
100399: LD_VAR 0 3
100403: PUSH
100404: LD_VAR 0 2
100408: DIFF
100409: ST_TO_ADDR
// continue ;
100410: GO 100380
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100412: LD_VAR 0 2
100416: PPUSH
100417: LD_INT 3
100419: PUSH
100420: LD_INT 22
100422: PUSH
100423: LD_INT 0
100425: PUSH
100426: EMPTY
100427: LIST
100428: LIST
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: PPUSH
100434: CALL_OW 69
100438: PPUSH
100439: LD_VAR 0 2
100443: PPUSH
100444: CALL_OW 74
100448: PPUSH
100449: CALL_OW 115
// end ;
100453: GO 100380
100455: POP
100456: POP
// until not tmp ;
100457: LD_VAR 0 3
100461: NOT
100462: IFFALSE 100363
// end ;
100464: PPOPN 3
100466: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100467: LD_EXP 96
100471: PUSH
100472: LD_EXP 121
100476: AND
100477: IFFALSE 100531
100479: GO 100481
100481: DISABLE
// begin ToLua ( displayTroll(); ) ;
100482: LD_STRING displayTroll();
100484: PPUSH
100485: CALL_OW 559
// wait ( 3 3$00 ) ;
100489: LD_INT 6300
100491: PPUSH
100492: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100496: LD_STRING hideTroll();
100498: PPUSH
100499: CALL_OW 559
// wait ( 1 1$00 ) ;
100503: LD_INT 2100
100505: PPUSH
100506: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100510: LD_STRING displayTroll();
100512: PPUSH
100513: CALL_OW 559
// wait ( 1 1$00 ) ;
100517: LD_INT 2100
100519: PPUSH
100520: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100524: LD_STRING hideTroll();
100526: PPUSH
100527: CALL_OW 559
// end ;
100531: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100532: LD_EXP 96
100536: PUSH
100537: LD_EXP 122
100541: AND
100542: IFFALSE 100605
100544: GO 100546
100546: DISABLE
100547: LD_INT 0
100549: PPUSH
// begin p := 0 ;
100550: LD_ADDR_VAR 0 1
100554: PUSH
100555: LD_INT 0
100557: ST_TO_ADDR
// repeat game_speed := 1 ;
100558: LD_ADDR_OWVAR 65
100562: PUSH
100563: LD_INT 1
100565: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100566: LD_INT 35
100568: PPUSH
100569: CALL_OW 67
// p := p + 1 ;
100573: LD_ADDR_VAR 0 1
100577: PUSH
100578: LD_VAR 0 1
100582: PUSH
100583: LD_INT 1
100585: PLUS
100586: ST_TO_ADDR
// until p >= 60 ;
100587: LD_VAR 0 1
100591: PUSH
100592: LD_INT 60
100594: GREATEREQUAL
100595: IFFALSE 100558
// game_speed := 4 ;
100597: LD_ADDR_OWVAR 65
100601: PUSH
100602: LD_INT 4
100604: ST_TO_ADDR
// end ;
100605: PPOPN 1
100607: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100608: LD_EXP 96
100612: PUSH
100613: LD_EXP 123
100617: AND
100618: IFFALSE 100764
100620: GO 100622
100622: DISABLE
100623: LD_INT 0
100625: PPUSH
100626: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100627: LD_ADDR_VAR 0 1
100631: PUSH
100632: LD_INT 22
100634: PUSH
100635: LD_OWVAR 2
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PUSH
100644: LD_INT 2
100646: PUSH
100647: LD_INT 30
100649: PUSH
100650: LD_INT 0
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PUSH
100657: LD_INT 30
100659: PUSH
100660: LD_INT 1
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: LIST
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: PPUSH
100676: CALL_OW 69
100680: ST_TO_ADDR
// if not depot then
100681: LD_VAR 0 1
100685: NOT
100686: IFFALSE 100690
// exit ;
100688: GO 100764
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100690: LD_ADDR_VAR 0 2
100694: PUSH
100695: LD_VAR 0 1
100699: PUSH
100700: LD_INT 1
100702: PPUSH
100703: LD_VAR 0 1
100707: PPUSH
100708: CALL_OW 12
100712: ARRAY
100713: PPUSH
100714: CALL_OW 274
100718: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100719: LD_VAR 0 2
100723: PPUSH
100724: LD_INT 1
100726: PPUSH
100727: LD_INT 0
100729: PPUSH
100730: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100734: LD_VAR 0 2
100738: PPUSH
100739: LD_INT 2
100741: PPUSH
100742: LD_INT 0
100744: PPUSH
100745: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100749: LD_VAR 0 2
100753: PPUSH
100754: LD_INT 3
100756: PPUSH
100757: LD_INT 0
100759: PPUSH
100760: CALL_OW 277
// end ;
100764: PPOPN 2
100766: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100767: LD_EXP 96
100771: PUSH
100772: LD_EXP 124
100776: AND
100777: IFFALSE 100874
100779: GO 100781
100781: DISABLE
100782: LD_INT 0
100784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100785: LD_ADDR_VAR 0 1
100789: PUSH
100790: LD_INT 22
100792: PUSH
100793: LD_OWVAR 2
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: LD_INT 21
100804: PUSH
100805: LD_INT 1
100807: PUSH
100808: EMPTY
100809: LIST
100810: LIST
100811: PUSH
100812: LD_INT 3
100814: PUSH
100815: LD_INT 23
100817: PUSH
100818: LD_INT 0
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: LIST
100833: PPUSH
100834: CALL_OW 69
100838: ST_TO_ADDR
// if not tmp then
100839: LD_VAR 0 1
100843: NOT
100844: IFFALSE 100848
// exit ;
100846: GO 100874
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100848: LD_VAR 0 1
100852: PUSH
100853: LD_INT 1
100855: PPUSH
100856: LD_VAR 0 1
100860: PPUSH
100861: CALL_OW 12
100865: ARRAY
100866: PPUSH
100867: LD_INT 200
100869: PPUSH
100870: CALL_OW 234
// end ;
100874: PPOPN 1
100876: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100877: LD_EXP 96
100881: PUSH
100882: LD_EXP 125
100886: AND
100887: IFFALSE 100966
100889: GO 100891
100891: DISABLE
100892: LD_INT 0
100894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100895: LD_ADDR_VAR 0 1
100899: PUSH
100900: LD_INT 22
100902: PUSH
100903: LD_OWVAR 2
100907: PUSH
100908: EMPTY
100909: LIST
100910: LIST
100911: PUSH
100912: LD_INT 21
100914: PUSH
100915: LD_INT 2
100917: PUSH
100918: EMPTY
100919: LIST
100920: LIST
100921: PUSH
100922: EMPTY
100923: LIST
100924: LIST
100925: PPUSH
100926: CALL_OW 69
100930: ST_TO_ADDR
// if not tmp then
100931: LD_VAR 0 1
100935: NOT
100936: IFFALSE 100940
// exit ;
100938: GO 100966
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100940: LD_VAR 0 1
100944: PUSH
100945: LD_INT 1
100947: PPUSH
100948: LD_VAR 0 1
100952: PPUSH
100953: CALL_OW 12
100957: ARRAY
100958: PPUSH
100959: LD_INT 60
100961: PPUSH
100962: CALL_OW 234
// end ;
100966: PPOPN 1
100968: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100969: LD_EXP 96
100973: PUSH
100974: LD_EXP 126
100978: AND
100979: IFFALSE 101078
100981: GO 100983
100983: DISABLE
100984: LD_INT 0
100986: PPUSH
100987: PPUSH
// begin enable ;
100988: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100989: LD_ADDR_VAR 0 1
100993: PUSH
100994: LD_INT 22
100996: PUSH
100997: LD_OWVAR 2
101001: PUSH
101002: EMPTY
101003: LIST
101004: LIST
101005: PUSH
101006: LD_INT 61
101008: PUSH
101009: EMPTY
101010: LIST
101011: PUSH
101012: LD_INT 33
101014: PUSH
101015: LD_INT 2
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: LIST
101026: PPUSH
101027: CALL_OW 69
101031: ST_TO_ADDR
// if not tmp then
101032: LD_VAR 0 1
101036: NOT
101037: IFFALSE 101041
// exit ;
101039: GO 101078
// for i in tmp do
101041: LD_ADDR_VAR 0 2
101045: PUSH
101046: LD_VAR 0 1
101050: PUSH
101051: FOR_IN
101052: IFFALSE 101076
// if IsControledBy ( i ) then
101054: LD_VAR 0 2
101058: PPUSH
101059: CALL_OW 312
101063: IFFALSE 101074
// ComUnlink ( i ) ;
101065: LD_VAR 0 2
101069: PPUSH
101070: CALL_OW 136
101074: GO 101051
101076: POP
101077: POP
// end ;
101078: PPOPN 2
101080: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101081: LD_EXP 96
101085: PUSH
101086: LD_EXP 127
101090: AND
101091: IFFALSE 101231
101093: GO 101095
101095: DISABLE
101096: LD_INT 0
101098: PPUSH
101099: PPUSH
// begin ToLua ( displayPowell(); ) ;
101100: LD_STRING displayPowell();
101102: PPUSH
101103: CALL_OW 559
// uc_side := 0 ;
101107: LD_ADDR_OWVAR 20
101111: PUSH
101112: LD_INT 0
101114: ST_TO_ADDR
// uc_nation := 2 ;
101115: LD_ADDR_OWVAR 21
101119: PUSH
101120: LD_INT 2
101122: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101123: LD_ADDR_OWVAR 37
101127: PUSH
101128: LD_INT 14
101130: ST_TO_ADDR
// vc_engine := engine_siberite ;
101131: LD_ADDR_OWVAR 39
101135: PUSH
101136: LD_INT 3
101138: ST_TO_ADDR
// vc_control := control_apeman ;
101139: LD_ADDR_OWVAR 38
101143: PUSH
101144: LD_INT 5
101146: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101147: LD_ADDR_OWVAR 40
101151: PUSH
101152: LD_INT 29
101154: ST_TO_ADDR
// un := CreateVehicle ;
101155: LD_ADDR_VAR 0 2
101159: PUSH
101160: CALL_OW 45
101164: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101165: LD_VAR 0 2
101169: PPUSH
101170: LD_INT 1
101172: PPUSH
101173: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101177: LD_INT 35
101179: PPUSH
101180: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101184: LD_VAR 0 2
101188: PPUSH
101189: LD_INT 22
101191: PUSH
101192: LD_OWVAR 2
101196: PUSH
101197: EMPTY
101198: LIST
101199: LIST
101200: PPUSH
101201: CALL_OW 69
101205: PPUSH
101206: LD_VAR 0 2
101210: PPUSH
101211: CALL_OW 74
101215: PPUSH
101216: CALL_OW 115
// until IsDead ( un ) ;
101220: LD_VAR 0 2
101224: PPUSH
101225: CALL_OW 301
101229: IFFALSE 101177
// end ;
101231: PPOPN 2
101233: END
// every 0 0$1 trigger StreamModeActive and sStu do
101234: LD_EXP 96
101238: PUSH
101239: LD_EXP 135
101243: AND
101244: IFFALSE 101260
101246: GO 101248
101248: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101249: LD_STRING displayStucuk();
101251: PPUSH
101252: CALL_OW 559
// ResetFog ;
101256: CALL_OW 335
// end ;
101260: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101261: LD_EXP 96
101265: PUSH
101266: LD_EXP 128
101270: AND
101271: IFFALSE 101412
101273: GO 101275
101275: DISABLE
101276: LD_INT 0
101278: PPUSH
101279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101280: LD_ADDR_VAR 0 2
101284: PUSH
101285: LD_INT 22
101287: PUSH
101288: LD_OWVAR 2
101292: PUSH
101293: EMPTY
101294: LIST
101295: LIST
101296: PUSH
101297: LD_INT 21
101299: PUSH
101300: LD_INT 1
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PUSH
101307: EMPTY
101308: LIST
101309: LIST
101310: PPUSH
101311: CALL_OW 69
101315: ST_TO_ADDR
// if not tmp then
101316: LD_VAR 0 2
101320: NOT
101321: IFFALSE 101325
// exit ;
101323: GO 101412
// un := tmp [ rand ( 1 , tmp ) ] ;
101325: LD_ADDR_VAR 0 1
101329: PUSH
101330: LD_VAR 0 2
101334: PUSH
101335: LD_INT 1
101337: PPUSH
101338: LD_VAR 0 2
101342: PPUSH
101343: CALL_OW 12
101347: ARRAY
101348: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101349: LD_VAR 0 1
101353: PPUSH
101354: LD_INT 0
101356: PPUSH
101357: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101361: LD_VAR 0 1
101365: PPUSH
101366: LD_OWVAR 3
101370: PUSH
101371: LD_VAR 0 1
101375: DIFF
101376: PPUSH
101377: LD_VAR 0 1
101381: PPUSH
101382: CALL_OW 74
101386: PPUSH
101387: CALL_OW 115
// wait ( 0 0$20 ) ;
101391: LD_INT 700
101393: PPUSH
101394: CALL_OW 67
// SetSide ( un , your_side ) ;
101398: LD_VAR 0 1
101402: PPUSH
101403: LD_OWVAR 2
101407: PPUSH
101408: CALL_OW 235
// end ;
101412: PPOPN 2
101414: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101415: LD_EXP 96
101419: PUSH
101420: LD_EXP 129
101424: AND
101425: IFFALSE 101531
101427: GO 101429
101429: DISABLE
101430: LD_INT 0
101432: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101433: LD_ADDR_VAR 0 1
101437: PUSH
101438: LD_INT 22
101440: PUSH
101441: LD_OWVAR 2
101445: PUSH
101446: EMPTY
101447: LIST
101448: LIST
101449: PUSH
101450: LD_INT 2
101452: PUSH
101453: LD_INT 30
101455: PUSH
101456: LD_INT 0
101458: PUSH
101459: EMPTY
101460: LIST
101461: LIST
101462: PUSH
101463: LD_INT 30
101465: PUSH
101466: LD_INT 1
101468: PUSH
101469: EMPTY
101470: LIST
101471: LIST
101472: PUSH
101473: EMPTY
101474: LIST
101475: LIST
101476: LIST
101477: PUSH
101478: EMPTY
101479: LIST
101480: LIST
101481: PPUSH
101482: CALL_OW 69
101486: ST_TO_ADDR
// if not depot then
101487: LD_VAR 0 1
101491: NOT
101492: IFFALSE 101496
// exit ;
101494: GO 101531
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101496: LD_VAR 0 1
101500: PUSH
101501: LD_INT 1
101503: ARRAY
101504: PPUSH
101505: CALL_OW 250
101509: PPUSH
101510: LD_VAR 0 1
101514: PUSH
101515: LD_INT 1
101517: ARRAY
101518: PPUSH
101519: CALL_OW 251
101523: PPUSH
101524: LD_INT 70
101526: PPUSH
101527: CALL_OW 495
// end ;
101531: PPOPN 1
101533: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101534: LD_EXP 96
101538: PUSH
101539: LD_EXP 130
101543: AND
101544: IFFALSE 101755
101546: GO 101548
101548: DISABLE
101549: LD_INT 0
101551: PPUSH
101552: PPUSH
101553: PPUSH
101554: PPUSH
101555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101556: LD_ADDR_VAR 0 5
101560: PUSH
101561: LD_INT 22
101563: PUSH
101564: LD_OWVAR 2
101568: PUSH
101569: EMPTY
101570: LIST
101571: LIST
101572: PUSH
101573: LD_INT 21
101575: PUSH
101576: LD_INT 1
101578: PUSH
101579: EMPTY
101580: LIST
101581: LIST
101582: PUSH
101583: EMPTY
101584: LIST
101585: LIST
101586: PPUSH
101587: CALL_OW 69
101591: ST_TO_ADDR
// if not tmp then
101592: LD_VAR 0 5
101596: NOT
101597: IFFALSE 101601
// exit ;
101599: GO 101755
// for i in tmp do
101601: LD_ADDR_VAR 0 1
101605: PUSH
101606: LD_VAR 0 5
101610: PUSH
101611: FOR_IN
101612: IFFALSE 101753
// begin d := rand ( 0 , 5 ) ;
101614: LD_ADDR_VAR 0 4
101618: PUSH
101619: LD_INT 0
101621: PPUSH
101622: LD_INT 5
101624: PPUSH
101625: CALL_OW 12
101629: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101630: LD_ADDR_VAR 0 2
101634: PUSH
101635: LD_VAR 0 1
101639: PPUSH
101640: CALL_OW 250
101644: PPUSH
101645: LD_VAR 0 4
101649: PPUSH
101650: LD_INT 3
101652: PPUSH
101653: LD_INT 12
101655: PPUSH
101656: CALL_OW 12
101660: PPUSH
101661: CALL_OW 272
101665: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101666: LD_ADDR_VAR 0 3
101670: PUSH
101671: LD_VAR 0 1
101675: PPUSH
101676: CALL_OW 251
101680: PPUSH
101681: LD_VAR 0 4
101685: PPUSH
101686: LD_INT 3
101688: PPUSH
101689: LD_INT 12
101691: PPUSH
101692: CALL_OW 12
101696: PPUSH
101697: CALL_OW 273
101701: ST_TO_ADDR
// if ValidHex ( x , y ) then
101702: LD_VAR 0 2
101706: PPUSH
101707: LD_VAR 0 3
101711: PPUSH
101712: CALL_OW 488
101716: IFFALSE 101751
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101718: LD_VAR 0 1
101722: PPUSH
101723: LD_VAR 0 2
101727: PPUSH
101728: LD_VAR 0 3
101732: PPUSH
101733: LD_INT 3
101735: PPUSH
101736: LD_INT 6
101738: PPUSH
101739: CALL_OW 12
101743: PPUSH
101744: LD_INT 1
101746: PPUSH
101747: CALL_OW 483
// end ;
101751: GO 101611
101753: POP
101754: POP
// end ;
101755: PPOPN 5
101757: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101758: LD_EXP 96
101762: PUSH
101763: LD_EXP 131
101767: AND
101768: IFFALSE 101862
101770: GO 101772
101772: DISABLE
101773: LD_INT 0
101775: PPUSH
101776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101777: LD_ADDR_VAR 0 2
101781: PUSH
101782: LD_INT 22
101784: PUSH
101785: LD_OWVAR 2
101789: PUSH
101790: EMPTY
101791: LIST
101792: LIST
101793: PUSH
101794: LD_INT 32
101796: PUSH
101797: LD_INT 1
101799: PUSH
101800: EMPTY
101801: LIST
101802: LIST
101803: PUSH
101804: LD_INT 21
101806: PUSH
101807: LD_INT 2
101809: PUSH
101810: EMPTY
101811: LIST
101812: LIST
101813: PUSH
101814: EMPTY
101815: LIST
101816: LIST
101817: LIST
101818: PPUSH
101819: CALL_OW 69
101823: ST_TO_ADDR
// if not tmp then
101824: LD_VAR 0 2
101828: NOT
101829: IFFALSE 101833
// exit ;
101831: GO 101862
// for i in tmp do
101833: LD_ADDR_VAR 0 1
101837: PUSH
101838: LD_VAR 0 2
101842: PUSH
101843: FOR_IN
101844: IFFALSE 101860
// SetFuel ( i , 0 ) ;
101846: LD_VAR 0 1
101850: PPUSH
101851: LD_INT 0
101853: PPUSH
101854: CALL_OW 240
101858: GO 101843
101860: POP
101861: POP
// end ;
101862: PPOPN 2
101864: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101865: LD_EXP 96
101869: PUSH
101870: LD_EXP 132
101874: AND
101875: IFFALSE 101941
101877: GO 101879
101879: DISABLE
101880: LD_INT 0
101882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101883: LD_ADDR_VAR 0 1
101887: PUSH
101888: LD_INT 22
101890: PUSH
101891: LD_OWVAR 2
101895: PUSH
101896: EMPTY
101897: LIST
101898: LIST
101899: PUSH
101900: LD_INT 30
101902: PUSH
101903: LD_INT 29
101905: PUSH
101906: EMPTY
101907: LIST
101908: LIST
101909: PUSH
101910: EMPTY
101911: LIST
101912: LIST
101913: PPUSH
101914: CALL_OW 69
101918: ST_TO_ADDR
// if not tmp then
101919: LD_VAR 0 1
101923: NOT
101924: IFFALSE 101928
// exit ;
101926: GO 101941
// DestroyUnit ( tmp [ 1 ] ) ;
101928: LD_VAR 0 1
101932: PUSH
101933: LD_INT 1
101935: ARRAY
101936: PPUSH
101937: CALL_OW 65
// end ;
101941: PPOPN 1
101943: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101944: LD_EXP 96
101948: PUSH
101949: LD_EXP 134
101953: AND
101954: IFFALSE 102083
101956: GO 101958
101958: DISABLE
101959: LD_INT 0
101961: PPUSH
// begin uc_side := 0 ;
101962: LD_ADDR_OWVAR 20
101966: PUSH
101967: LD_INT 0
101969: ST_TO_ADDR
// uc_nation := nation_arabian ;
101970: LD_ADDR_OWVAR 21
101974: PUSH
101975: LD_INT 2
101977: ST_TO_ADDR
// hc_gallery :=  ;
101978: LD_ADDR_OWVAR 33
101982: PUSH
101983: LD_STRING 
101985: ST_TO_ADDR
// hc_name :=  ;
101986: LD_ADDR_OWVAR 26
101990: PUSH
101991: LD_STRING 
101993: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101994: LD_INT 1
101996: PPUSH
101997: LD_INT 11
101999: PPUSH
102000: LD_INT 10
102002: PPUSH
102003: CALL_OW 380
// un := CreateHuman ;
102007: LD_ADDR_VAR 0 1
102011: PUSH
102012: CALL_OW 44
102016: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102017: LD_VAR 0 1
102021: PPUSH
102022: LD_INT 1
102024: PPUSH
102025: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102029: LD_INT 35
102031: PPUSH
102032: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102036: LD_VAR 0 1
102040: PPUSH
102041: LD_INT 22
102043: PUSH
102044: LD_OWVAR 2
102048: PUSH
102049: EMPTY
102050: LIST
102051: LIST
102052: PPUSH
102053: CALL_OW 69
102057: PPUSH
102058: LD_VAR 0 1
102062: PPUSH
102063: CALL_OW 74
102067: PPUSH
102068: CALL_OW 115
// until IsDead ( un ) ;
102072: LD_VAR 0 1
102076: PPUSH
102077: CALL_OW 301
102081: IFFALSE 102029
// end ;
102083: PPOPN 1
102085: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102086: LD_EXP 96
102090: PUSH
102091: LD_EXP 136
102095: AND
102096: IFFALSE 102108
102098: GO 102100
102100: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102101: LD_STRING earthquake(getX(game), 0, 32)
102103: PPUSH
102104: CALL_OW 559
102108: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102109: LD_EXP 96
102113: PUSH
102114: LD_EXP 137
102118: AND
102119: IFFALSE 102210
102121: GO 102123
102123: DISABLE
102124: LD_INT 0
102126: PPUSH
// begin enable ;
102127: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102128: LD_ADDR_VAR 0 1
102132: PUSH
102133: LD_INT 22
102135: PUSH
102136: LD_OWVAR 2
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PUSH
102145: LD_INT 21
102147: PUSH
102148: LD_INT 2
102150: PUSH
102151: EMPTY
102152: LIST
102153: LIST
102154: PUSH
102155: LD_INT 33
102157: PUSH
102158: LD_INT 3
102160: PUSH
102161: EMPTY
102162: LIST
102163: LIST
102164: PUSH
102165: EMPTY
102166: LIST
102167: LIST
102168: LIST
102169: PPUSH
102170: CALL_OW 69
102174: ST_TO_ADDR
// if not tmp then
102175: LD_VAR 0 1
102179: NOT
102180: IFFALSE 102184
// exit ;
102182: GO 102210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102184: LD_VAR 0 1
102188: PUSH
102189: LD_INT 1
102191: PPUSH
102192: LD_VAR 0 1
102196: PPUSH
102197: CALL_OW 12
102201: ARRAY
102202: PPUSH
102203: LD_INT 1
102205: PPUSH
102206: CALL_OW 234
// end ;
102210: PPOPN 1
102212: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102213: LD_EXP 96
102217: PUSH
102218: LD_EXP 138
102222: AND
102223: IFFALSE 102364
102225: GO 102227
102227: DISABLE
102228: LD_INT 0
102230: PPUSH
102231: PPUSH
102232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102233: LD_ADDR_VAR 0 3
102237: PUSH
102238: LD_INT 22
102240: PUSH
102241: LD_OWVAR 2
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PUSH
102250: LD_INT 25
102252: PUSH
102253: LD_INT 1
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: PUSH
102260: EMPTY
102261: LIST
102262: LIST
102263: PPUSH
102264: CALL_OW 69
102268: ST_TO_ADDR
// if not tmp then
102269: LD_VAR 0 3
102273: NOT
102274: IFFALSE 102278
// exit ;
102276: GO 102364
// un := tmp [ rand ( 1 , tmp ) ] ;
102278: LD_ADDR_VAR 0 2
102282: PUSH
102283: LD_VAR 0 3
102287: PUSH
102288: LD_INT 1
102290: PPUSH
102291: LD_VAR 0 3
102295: PPUSH
102296: CALL_OW 12
102300: ARRAY
102301: ST_TO_ADDR
// if Crawls ( un ) then
102302: LD_VAR 0 2
102306: PPUSH
102307: CALL_OW 318
102311: IFFALSE 102322
// ComWalk ( un ) ;
102313: LD_VAR 0 2
102317: PPUSH
102318: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102322: LD_VAR 0 2
102326: PPUSH
102327: LD_INT 9
102329: PPUSH
102330: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102334: LD_INT 28
102336: PPUSH
102337: LD_OWVAR 2
102341: PPUSH
102342: LD_INT 2
102344: PPUSH
102345: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102349: LD_INT 29
102351: PPUSH
102352: LD_OWVAR 2
102356: PPUSH
102357: LD_INT 2
102359: PPUSH
102360: CALL_OW 322
// end ;
102364: PPOPN 3
102366: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102367: LD_EXP 96
102371: PUSH
102372: LD_EXP 139
102376: AND
102377: IFFALSE 102488
102379: GO 102381
102381: DISABLE
102382: LD_INT 0
102384: PPUSH
102385: PPUSH
102386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102387: LD_ADDR_VAR 0 3
102391: PUSH
102392: LD_INT 22
102394: PUSH
102395: LD_OWVAR 2
102399: PUSH
102400: EMPTY
102401: LIST
102402: LIST
102403: PUSH
102404: LD_INT 25
102406: PUSH
102407: LD_INT 1
102409: PUSH
102410: EMPTY
102411: LIST
102412: LIST
102413: PUSH
102414: EMPTY
102415: LIST
102416: LIST
102417: PPUSH
102418: CALL_OW 69
102422: ST_TO_ADDR
// if not tmp then
102423: LD_VAR 0 3
102427: NOT
102428: IFFALSE 102432
// exit ;
102430: GO 102488
// un := tmp [ rand ( 1 , tmp ) ] ;
102432: LD_ADDR_VAR 0 2
102436: PUSH
102437: LD_VAR 0 3
102441: PUSH
102442: LD_INT 1
102444: PPUSH
102445: LD_VAR 0 3
102449: PPUSH
102450: CALL_OW 12
102454: ARRAY
102455: ST_TO_ADDR
// if Crawls ( un ) then
102456: LD_VAR 0 2
102460: PPUSH
102461: CALL_OW 318
102465: IFFALSE 102476
// ComWalk ( un ) ;
102467: LD_VAR 0 2
102471: PPUSH
102472: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102476: LD_VAR 0 2
102480: PPUSH
102481: LD_INT 8
102483: PPUSH
102484: CALL_OW 336
// end ;
102488: PPOPN 3
102490: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102491: LD_EXP 96
102495: PUSH
102496: LD_EXP 140
102500: AND
102501: IFFALSE 102645
102503: GO 102505
102505: DISABLE
102506: LD_INT 0
102508: PPUSH
102509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102510: LD_ADDR_VAR 0 2
102514: PUSH
102515: LD_INT 22
102517: PUSH
102518: LD_OWVAR 2
102522: PUSH
102523: EMPTY
102524: LIST
102525: LIST
102526: PUSH
102527: LD_INT 21
102529: PUSH
102530: LD_INT 2
102532: PUSH
102533: EMPTY
102534: LIST
102535: LIST
102536: PUSH
102537: LD_INT 2
102539: PUSH
102540: LD_INT 34
102542: PUSH
102543: LD_INT 12
102545: PUSH
102546: EMPTY
102547: LIST
102548: LIST
102549: PUSH
102550: LD_INT 34
102552: PUSH
102553: LD_INT 51
102555: PUSH
102556: EMPTY
102557: LIST
102558: LIST
102559: PUSH
102560: LD_INT 34
102562: PUSH
102563: LD_INT 32
102565: PUSH
102566: EMPTY
102567: LIST
102568: LIST
102569: PUSH
102570: EMPTY
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: PUSH
102576: EMPTY
102577: LIST
102578: LIST
102579: LIST
102580: PPUSH
102581: CALL_OW 69
102585: ST_TO_ADDR
// if not tmp then
102586: LD_VAR 0 2
102590: NOT
102591: IFFALSE 102595
// exit ;
102593: GO 102645
// for i in tmp do
102595: LD_ADDR_VAR 0 1
102599: PUSH
102600: LD_VAR 0 2
102604: PUSH
102605: FOR_IN
102606: IFFALSE 102643
// if GetCargo ( i , mat_artifact ) = 0 then
102608: LD_VAR 0 1
102612: PPUSH
102613: LD_INT 4
102615: PPUSH
102616: CALL_OW 289
102620: PUSH
102621: LD_INT 0
102623: EQUAL
102624: IFFALSE 102641
// SetCargo ( i , mat_siberit , 100 ) ;
102626: LD_VAR 0 1
102630: PPUSH
102631: LD_INT 3
102633: PPUSH
102634: LD_INT 100
102636: PPUSH
102637: CALL_OW 290
102641: GO 102605
102643: POP
102644: POP
// end ;
102645: PPOPN 2
102647: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102648: LD_EXP 96
102652: PUSH
102653: LD_EXP 141
102657: AND
102658: IFFALSE 102841
102660: GO 102662
102662: DISABLE
102663: LD_INT 0
102665: PPUSH
102666: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102667: LD_ADDR_VAR 0 2
102671: PUSH
102672: LD_INT 22
102674: PUSH
102675: LD_OWVAR 2
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: PPUSH
102684: CALL_OW 69
102688: ST_TO_ADDR
// if not tmp then
102689: LD_VAR 0 2
102693: NOT
102694: IFFALSE 102698
// exit ;
102696: GO 102841
// for i := 1 to 2 do
102698: LD_ADDR_VAR 0 1
102702: PUSH
102703: DOUBLE
102704: LD_INT 1
102706: DEC
102707: ST_TO_ADDR
102708: LD_INT 2
102710: PUSH
102711: FOR_TO
102712: IFFALSE 102839
// begin uc_side := your_side ;
102714: LD_ADDR_OWVAR 20
102718: PUSH
102719: LD_OWVAR 2
102723: ST_TO_ADDR
// uc_nation := nation_american ;
102724: LD_ADDR_OWVAR 21
102728: PUSH
102729: LD_INT 1
102731: ST_TO_ADDR
// vc_chassis := us_morphling ;
102732: LD_ADDR_OWVAR 37
102736: PUSH
102737: LD_INT 5
102739: ST_TO_ADDR
// vc_engine := engine_siberite ;
102740: LD_ADDR_OWVAR 39
102744: PUSH
102745: LD_INT 3
102747: ST_TO_ADDR
// vc_control := control_computer ;
102748: LD_ADDR_OWVAR 38
102752: PUSH
102753: LD_INT 3
102755: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102756: LD_ADDR_OWVAR 40
102760: PUSH
102761: LD_INT 10
102763: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102764: LD_VAR 0 2
102768: PUSH
102769: LD_INT 1
102771: ARRAY
102772: PPUSH
102773: CALL_OW 310
102777: NOT
102778: IFFALSE 102825
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102780: CALL_OW 45
102784: PPUSH
102785: LD_VAR 0 2
102789: PUSH
102790: LD_INT 1
102792: ARRAY
102793: PPUSH
102794: CALL_OW 250
102798: PPUSH
102799: LD_VAR 0 2
102803: PUSH
102804: LD_INT 1
102806: ARRAY
102807: PPUSH
102808: CALL_OW 251
102812: PPUSH
102813: LD_INT 12
102815: PPUSH
102816: LD_INT 1
102818: PPUSH
102819: CALL_OW 50
102823: GO 102837
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102825: CALL_OW 45
102829: PPUSH
102830: LD_INT 1
102832: PPUSH
102833: CALL_OW 51
// end ;
102837: GO 102711
102839: POP
102840: POP
// end ;
102841: PPOPN 2
102843: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102844: LD_EXP 96
102848: PUSH
102849: LD_EXP 142
102853: AND
102854: IFFALSE 103076
102856: GO 102858
102858: DISABLE
102859: LD_INT 0
102861: PPUSH
102862: PPUSH
102863: PPUSH
102864: PPUSH
102865: PPUSH
102866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102867: LD_ADDR_VAR 0 6
102871: PUSH
102872: LD_INT 22
102874: PUSH
102875: LD_OWVAR 2
102879: PUSH
102880: EMPTY
102881: LIST
102882: LIST
102883: PUSH
102884: LD_INT 21
102886: PUSH
102887: LD_INT 1
102889: PUSH
102890: EMPTY
102891: LIST
102892: LIST
102893: PUSH
102894: LD_INT 3
102896: PUSH
102897: LD_INT 23
102899: PUSH
102900: LD_INT 0
102902: PUSH
102903: EMPTY
102904: LIST
102905: LIST
102906: PUSH
102907: EMPTY
102908: LIST
102909: LIST
102910: PUSH
102911: EMPTY
102912: LIST
102913: LIST
102914: LIST
102915: PPUSH
102916: CALL_OW 69
102920: ST_TO_ADDR
// if not tmp then
102921: LD_VAR 0 6
102925: NOT
102926: IFFALSE 102930
// exit ;
102928: GO 103076
// s1 := rand ( 1 , 4 ) ;
102930: LD_ADDR_VAR 0 2
102934: PUSH
102935: LD_INT 1
102937: PPUSH
102938: LD_INT 4
102940: PPUSH
102941: CALL_OW 12
102945: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102946: LD_ADDR_VAR 0 4
102950: PUSH
102951: LD_VAR 0 6
102955: PUSH
102956: LD_INT 1
102958: ARRAY
102959: PPUSH
102960: LD_VAR 0 2
102964: PPUSH
102965: CALL_OW 259
102969: ST_TO_ADDR
// if s1 = 1 then
102970: LD_VAR 0 2
102974: PUSH
102975: LD_INT 1
102977: EQUAL
102978: IFFALSE 102998
// s2 := rand ( 2 , 4 ) else
102980: LD_ADDR_VAR 0 3
102984: PUSH
102985: LD_INT 2
102987: PPUSH
102988: LD_INT 4
102990: PPUSH
102991: CALL_OW 12
102995: ST_TO_ADDR
102996: GO 103006
// s2 := 1 ;
102998: LD_ADDR_VAR 0 3
103002: PUSH
103003: LD_INT 1
103005: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103006: LD_ADDR_VAR 0 5
103010: PUSH
103011: LD_VAR 0 6
103015: PUSH
103016: LD_INT 1
103018: ARRAY
103019: PPUSH
103020: LD_VAR 0 3
103024: PPUSH
103025: CALL_OW 259
103029: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103030: LD_VAR 0 6
103034: PUSH
103035: LD_INT 1
103037: ARRAY
103038: PPUSH
103039: LD_VAR 0 2
103043: PPUSH
103044: LD_VAR 0 5
103048: PPUSH
103049: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103053: LD_VAR 0 6
103057: PUSH
103058: LD_INT 1
103060: ARRAY
103061: PPUSH
103062: LD_VAR 0 3
103066: PPUSH
103067: LD_VAR 0 4
103071: PPUSH
103072: CALL_OW 237
// end ;
103076: PPOPN 6
103078: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103079: LD_EXP 96
103083: PUSH
103084: LD_EXP 143
103088: AND
103089: IFFALSE 103168
103091: GO 103093
103093: DISABLE
103094: LD_INT 0
103096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103097: LD_ADDR_VAR 0 1
103101: PUSH
103102: LD_INT 22
103104: PUSH
103105: LD_OWVAR 2
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: PUSH
103114: LD_INT 30
103116: PUSH
103117: LD_INT 3
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: PUSH
103124: EMPTY
103125: LIST
103126: LIST
103127: PPUSH
103128: CALL_OW 69
103132: ST_TO_ADDR
// if not tmp then
103133: LD_VAR 0 1
103137: NOT
103138: IFFALSE 103142
// exit ;
103140: GO 103168
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103142: LD_VAR 0 1
103146: PUSH
103147: LD_INT 1
103149: PPUSH
103150: LD_VAR 0 1
103154: PPUSH
103155: CALL_OW 12
103159: ARRAY
103160: PPUSH
103161: LD_INT 1
103163: PPUSH
103164: CALL_OW 234
// end ;
103168: PPOPN 1
103170: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103171: LD_EXP 96
103175: PUSH
103176: LD_EXP 144
103180: AND
103181: IFFALSE 103293
103183: GO 103185
103185: DISABLE
103186: LD_INT 0
103188: PPUSH
103189: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103190: LD_ADDR_VAR 0 2
103194: PUSH
103195: LD_INT 22
103197: PUSH
103198: LD_OWVAR 2
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: PUSH
103207: LD_INT 2
103209: PUSH
103210: LD_INT 30
103212: PUSH
103213: LD_INT 27
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: PUSH
103220: LD_INT 30
103222: PUSH
103223: LD_INT 26
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: PUSH
103230: LD_INT 30
103232: PUSH
103233: LD_INT 28
103235: PUSH
103236: EMPTY
103237: LIST
103238: LIST
103239: PUSH
103240: EMPTY
103241: LIST
103242: LIST
103243: LIST
103244: LIST
103245: PUSH
103246: EMPTY
103247: LIST
103248: LIST
103249: PPUSH
103250: CALL_OW 69
103254: ST_TO_ADDR
// if not tmp then
103255: LD_VAR 0 2
103259: NOT
103260: IFFALSE 103264
// exit ;
103262: GO 103293
// for i in tmp do
103264: LD_ADDR_VAR 0 1
103268: PUSH
103269: LD_VAR 0 2
103273: PUSH
103274: FOR_IN
103275: IFFALSE 103291
// SetLives ( i , 1 ) ;
103277: LD_VAR 0 1
103281: PPUSH
103282: LD_INT 1
103284: PPUSH
103285: CALL_OW 234
103289: GO 103274
103291: POP
103292: POP
// end ;
103293: PPOPN 2
103295: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103296: LD_EXP 96
103300: PUSH
103301: LD_EXP 145
103305: AND
103306: IFFALSE 103593
103308: GO 103310
103310: DISABLE
103311: LD_INT 0
103313: PPUSH
103314: PPUSH
103315: PPUSH
// begin i := rand ( 1 , 7 ) ;
103316: LD_ADDR_VAR 0 1
103320: PUSH
103321: LD_INT 1
103323: PPUSH
103324: LD_INT 7
103326: PPUSH
103327: CALL_OW 12
103331: ST_TO_ADDR
// case i of 1 :
103332: LD_VAR 0 1
103336: PUSH
103337: LD_INT 1
103339: DOUBLE
103340: EQUAL
103341: IFTRUE 103345
103343: GO 103355
103345: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103346: LD_STRING earthquake(getX(game), 0, 32)
103348: PPUSH
103349: CALL_OW 559
103353: GO 103593
103355: LD_INT 2
103357: DOUBLE
103358: EQUAL
103359: IFTRUE 103363
103361: GO 103377
103363: POP
// begin ToLua ( displayStucuk(); ) ;
103364: LD_STRING displayStucuk();
103366: PPUSH
103367: CALL_OW 559
// ResetFog ;
103371: CALL_OW 335
// end ; 3 :
103375: GO 103593
103377: LD_INT 3
103379: DOUBLE
103380: EQUAL
103381: IFTRUE 103385
103383: GO 103489
103385: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103386: LD_ADDR_VAR 0 2
103390: PUSH
103391: LD_INT 22
103393: PUSH
103394: LD_OWVAR 2
103398: PUSH
103399: EMPTY
103400: LIST
103401: LIST
103402: PUSH
103403: LD_INT 25
103405: PUSH
103406: LD_INT 1
103408: PUSH
103409: EMPTY
103410: LIST
103411: LIST
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PPUSH
103417: CALL_OW 69
103421: ST_TO_ADDR
// if not tmp then
103422: LD_VAR 0 2
103426: NOT
103427: IFFALSE 103431
// exit ;
103429: GO 103593
// un := tmp [ rand ( 1 , tmp ) ] ;
103431: LD_ADDR_VAR 0 3
103435: PUSH
103436: LD_VAR 0 2
103440: PUSH
103441: LD_INT 1
103443: PPUSH
103444: LD_VAR 0 2
103448: PPUSH
103449: CALL_OW 12
103453: ARRAY
103454: ST_TO_ADDR
// if Crawls ( un ) then
103455: LD_VAR 0 3
103459: PPUSH
103460: CALL_OW 318
103464: IFFALSE 103475
// ComWalk ( un ) ;
103466: LD_VAR 0 3
103470: PPUSH
103471: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103475: LD_VAR 0 3
103479: PPUSH
103480: LD_INT 8
103482: PPUSH
103483: CALL_OW 336
// end ; 4 :
103487: GO 103593
103489: LD_INT 4
103491: DOUBLE
103492: EQUAL
103493: IFTRUE 103497
103495: GO 103571
103497: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103498: LD_ADDR_VAR 0 2
103502: PUSH
103503: LD_INT 22
103505: PUSH
103506: LD_OWVAR 2
103510: PUSH
103511: EMPTY
103512: LIST
103513: LIST
103514: PUSH
103515: LD_INT 30
103517: PUSH
103518: LD_INT 29
103520: PUSH
103521: EMPTY
103522: LIST
103523: LIST
103524: PUSH
103525: EMPTY
103526: LIST
103527: LIST
103528: PPUSH
103529: CALL_OW 69
103533: ST_TO_ADDR
// if not tmp then
103534: LD_VAR 0 2
103538: NOT
103539: IFFALSE 103543
// exit ;
103541: GO 103593
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103543: LD_VAR 0 2
103547: PUSH
103548: LD_INT 1
103550: ARRAY
103551: PPUSH
103552: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103556: LD_VAR 0 2
103560: PUSH
103561: LD_INT 1
103563: ARRAY
103564: PPUSH
103565: CALL_OW 65
// end ; 5 .. 7 :
103569: GO 103593
103571: LD_INT 5
103573: DOUBLE
103574: GREATEREQUAL
103575: IFFALSE 103583
103577: LD_INT 7
103579: DOUBLE
103580: LESSEQUAL
103581: IFTRUE 103585
103583: GO 103592
103585: POP
// StreamSibBomb ; end ;
103586: CALL 99830 0 0
103590: GO 103593
103592: POP
// end ;
103593: PPOPN 3
103595: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103596: LD_EXP 96
103600: PUSH
103601: LD_EXP 146
103605: AND
103606: IFFALSE 103762
103608: GO 103610
103610: DISABLE
103611: LD_INT 0
103613: PPUSH
103614: PPUSH
103615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103616: LD_ADDR_VAR 0 2
103620: PUSH
103621: LD_INT 81
103623: PUSH
103624: LD_OWVAR 2
103628: PUSH
103629: EMPTY
103630: LIST
103631: LIST
103632: PUSH
103633: LD_INT 2
103635: PUSH
103636: LD_INT 21
103638: PUSH
103639: LD_INT 1
103641: PUSH
103642: EMPTY
103643: LIST
103644: LIST
103645: PUSH
103646: LD_INT 21
103648: PUSH
103649: LD_INT 2
103651: PUSH
103652: EMPTY
103653: LIST
103654: LIST
103655: PUSH
103656: EMPTY
103657: LIST
103658: LIST
103659: LIST
103660: PUSH
103661: EMPTY
103662: LIST
103663: LIST
103664: PPUSH
103665: CALL_OW 69
103669: ST_TO_ADDR
// if not tmp then
103670: LD_VAR 0 2
103674: NOT
103675: IFFALSE 103679
// exit ;
103677: GO 103762
// p := 0 ;
103679: LD_ADDR_VAR 0 3
103683: PUSH
103684: LD_INT 0
103686: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103687: LD_INT 35
103689: PPUSH
103690: CALL_OW 67
// p := p + 1 ;
103694: LD_ADDR_VAR 0 3
103698: PUSH
103699: LD_VAR 0 3
103703: PUSH
103704: LD_INT 1
103706: PLUS
103707: ST_TO_ADDR
// for i in tmp do
103708: LD_ADDR_VAR 0 1
103712: PUSH
103713: LD_VAR 0 2
103717: PUSH
103718: FOR_IN
103719: IFFALSE 103750
// if GetLives ( i ) < 1000 then
103721: LD_VAR 0 1
103725: PPUSH
103726: CALL_OW 256
103730: PUSH
103731: LD_INT 1000
103733: LESS
103734: IFFALSE 103748
// SetLives ( i , 1000 ) ;
103736: LD_VAR 0 1
103740: PPUSH
103741: LD_INT 1000
103743: PPUSH
103744: CALL_OW 234
103748: GO 103718
103750: POP
103751: POP
// until p > 20 ;
103752: LD_VAR 0 3
103756: PUSH
103757: LD_INT 20
103759: GREATER
103760: IFFALSE 103687
// end ;
103762: PPOPN 3
103764: END
// every 0 0$1 trigger StreamModeActive and sTime do
103765: LD_EXP 96
103769: PUSH
103770: LD_EXP 147
103774: AND
103775: IFFALSE 103810
103777: GO 103779
103779: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103780: LD_INT 28
103782: PPUSH
103783: LD_OWVAR 2
103787: PPUSH
103788: LD_INT 2
103790: PPUSH
103791: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103795: LD_INT 30
103797: PPUSH
103798: LD_OWVAR 2
103802: PPUSH
103803: LD_INT 2
103805: PPUSH
103806: CALL_OW 322
// end ;
103810: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103811: LD_EXP 96
103815: PUSH
103816: LD_EXP 148
103820: AND
103821: IFFALSE 103942
103823: GO 103825
103825: DISABLE
103826: LD_INT 0
103828: PPUSH
103829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103830: LD_ADDR_VAR 0 2
103834: PUSH
103835: LD_INT 22
103837: PUSH
103838: LD_OWVAR 2
103842: PUSH
103843: EMPTY
103844: LIST
103845: LIST
103846: PUSH
103847: LD_INT 21
103849: PUSH
103850: LD_INT 1
103852: PUSH
103853: EMPTY
103854: LIST
103855: LIST
103856: PUSH
103857: LD_INT 3
103859: PUSH
103860: LD_INT 23
103862: PUSH
103863: LD_INT 0
103865: PUSH
103866: EMPTY
103867: LIST
103868: LIST
103869: PUSH
103870: EMPTY
103871: LIST
103872: LIST
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: LIST
103878: PPUSH
103879: CALL_OW 69
103883: ST_TO_ADDR
// if not tmp then
103884: LD_VAR 0 2
103888: NOT
103889: IFFALSE 103893
// exit ;
103891: GO 103942
// for i in tmp do
103893: LD_ADDR_VAR 0 1
103897: PUSH
103898: LD_VAR 0 2
103902: PUSH
103903: FOR_IN
103904: IFFALSE 103940
// begin if Crawls ( i ) then
103906: LD_VAR 0 1
103910: PPUSH
103911: CALL_OW 318
103915: IFFALSE 103926
// ComWalk ( i ) ;
103917: LD_VAR 0 1
103921: PPUSH
103922: CALL_OW 138
// SetClass ( i , 2 ) ;
103926: LD_VAR 0 1
103930: PPUSH
103931: LD_INT 2
103933: PPUSH
103934: CALL_OW 336
// end ;
103938: GO 103903
103940: POP
103941: POP
// end ;
103942: PPOPN 2
103944: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103945: LD_EXP 96
103949: PUSH
103950: LD_EXP 149
103954: AND
103955: IFFALSE 104243
103957: GO 103959
103959: DISABLE
103960: LD_INT 0
103962: PPUSH
103963: PPUSH
103964: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103965: LD_OWVAR 2
103969: PPUSH
103970: LD_INT 9
103972: PPUSH
103973: LD_INT 1
103975: PPUSH
103976: LD_INT 1
103978: PPUSH
103979: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103983: LD_INT 9
103985: PPUSH
103986: LD_OWVAR 2
103990: PPUSH
103991: CALL_OW 343
// uc_side := 9 ;
103995: LD_ADDR_OWVAR 20
103999: PUSH
104000: LD_INT 9
104002: ST_TO_ADDR
// uc_nation := 2 ;
104003: LD_ADDR_OWVAR 21
104007: PUSH
104008: LD_INT 2
104010: ST_TO_ADDR
// hc_name := Dark Warrior ;
104011: LD_ADDR_OWVAR 26
104015: PUSH
104016: LD_STRING Dark Warrior
104018: ST_TO_ADDR
// hc_gallery :=  ;
104019: LD_ADDR_OWVAR 33
104023: PUSH
104024: LD_STRING 
104026: ST_TO_ADDR
// hc_noskilllimit := true ;
104027: LD_ADDR_OWVAR 76
104031: PUSH
104032: LD_INT 1
104034: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104035: LD_ADDR_OWVAR 31
104039: PUSH
104040: LD_INT 30
104042: PUSH
104043: LD_INT 30
104045: PUSH
104046: LD_INT 30
104048: PUSH
104049: LD_INT 30
104051: PUSH
104052: EMPTY
104053: LIST
104054: LIST
104055: LIST
104056: LIST
104057: ST_TO_ADDR
// un := CreateHuman ;
104058: LD_ADDR_VAR 0 3
104062: PUSH
104063: CALL_OW 44
104067: ST_TO_ADDR
// hc_noskilllimit := false ;
104068: LD_ADDR_OWVAR 76
104072: PUSH
104073: LD_INT 0
104075: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104076: LD_VAR 0 3
104080: PPUSH
104081: LD_INT 1
104083: PPUSH
104084: CALL_OW 51
// ToLua ( playRanger() ) ;
104088: LD_STRING playRanger()
104090: PPUSH
104091: CALL_OW 559
// p := 0 ;
104095: LD_ADDR_VAR 0 2
104099: PUSH
104100: LD_INT 0
104102: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104103: LD_INT 35
104105: PPUSH
104106: CALL_OW 67
// p := p + 1 ;
104110: LD_ADDR_VAR 0 2
104114: PUSH
104115: LD_VAR 0 2
104119: PUSH
104120: LD_INT 1
104122: PLUS
104123: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104124: LD_VAR 0 3
104128: PPUSH
104129: CALL_OW 256
104133: PUSH
104134: LD_INT 1000
104136: LESS
104137: IFFALSE 104151
// SetLives ( un , 1000 ) ;
104139: LD_VAR 0 3
104143: PPUSH
104144: LD_INT 1000
104146: PPUSH
104147: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104151: LD_VAR 0 3
104155: PPUSH
104156: LD_INT 81
104158: PUSH
104159: LD_OWVAR 2
104163: PUSH
104164: EMPTY
104165: LIST
104166: LIST
104167: PUSH
104168: LD_INT 91
104170: PUSH
104171: LD_VAR 0 3
104175: PUSH
104176: LD_INT 30
104178: PUSH
104179: EMPTY
104180: LIST
104181: LIST
104182: LIST
104183: PUSH
104184: EMPTY
104185: LIST
104186: LIST
104187: PPUSH
104188: CALL_OW 69
104192: PPUSH
104193: LD_VAR 0 3
104197: PPUSH
104198: CALL_OW 74
104202: PPUSH
104203: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104207: LD_VAR 0 2
104211: PUSH
104212: LD_INT 80
104214: GREATER
104215: PUSH
104216: LD_VAR 0 3
104220: PPUSH
104221: CALL_OW 301
104225: OR
104226: IFFALSE 104103
// if un then
104228: LD_VAR 0 3
104232: IFFALSE 104243
// RemoveUnit ( un ) ;
104234: LD_VAR 0 3
104238: PPUSH
104239: CALL_OW 64
// end ;
104243: PPOPN 3
104245: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104246: LD_EXP 150
104250: IFFALSE 104366
104252: GO 104254
104254: DISABLE
104255: LD_INT 0
104257: PPUSH
104258: PPUSH
104259: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104260: LD_ADDR_VAR 0 2
104264: PUSH
104265: LD_INT 81
104267: PUSH
104268: LD_OWVAR 2
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: PUSH
104277: LD_INT 21
104279: PUSH
104280: LD_INT 1
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PUSH
104287: EMPTY
104288: LIST
104289: LIST
104290: PPUSH
104291: CALL_OW 69
104295: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104296: LD_STRING playComputer()
104298: PPUSH
104299: CALL_OW 559
// if not tmp then
104303: LD_VAR 0 2
104307: NOT
104308: IFFALSE 104312
// exit ;
104310: GO 104366
// for i in tmp do
104312: LD_ADDR_VAR 0 1
104316: PUSH
104317: LD_VAR 0 2
104321: PUSH
104322: FOR_IN
104323: IFFALSE 104364
// for j := 1 to 4 do
104325: LD_ADDR_VAR 0 3
104329: PUSH
104330: DOUBLE
104331: LD_INT 1
104333: DEC
104334: ST_TO_ADDR
104335: LD_INT 4
104337: PUSH
104338: FOR_TO
104339: IFFALSE 104360
// SetSkill ( i , j , 10 ) ;
104341: LD_VAR 0 1
104345: PPUSH
104346: LD_VAR 0 3
104350: PPUSH
104351: LD_INT 10
104353: PPUSH
104354: CALL_OW 237
104358: GO 104338
104360: POP
104361: POP
104362: GO 104322
104364: POP
104365: POP
// end ;
104366: PPOPN 3
104368: END
// every 0 0$1 trigger s30 do var i , tmp ;
104369: LD_EXP 151
104373: IFFALSE 104442
104375: GO 104377
104377: DISABLE
104378: LD_INT 0
104380: PPUSH
104381: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104382: LD_ADDR_VAR 0 2
104386: PUSH
104387: LD_INT 22
104389: PUSH
104390: LD_OWVAR 2
104394: PUSH
104395: EMPTY
104396: LIST
104397: LIST
104398: PPUSH
104399: CALL_OW 69
104403: ST_TO_ADDR
// if not tmp then
104404: LD_VAR 0 2
104408: NOT
104409: IFFALSE 104413
// exit ;
104411: GO 104442
// for i in tmp do
104413: LD_ADDR_VAR 0 1
104417: PUSH
104418: LD_VAR 0 2
104422: PUSH
104423: FOR_IN
104424: IFFALSE 104440
// SetLives ( i , 300 ) ;
104426: LD_VAR 0 1
104430: PPUSH
104431: LD_INT 300
104433: PPUSH
104434: CALL_OW 234
104438: GO 104423
104440: POP
104441: POP
// end ;
104442: PPOPN 2
104444: END
// every 0 0$1 trigger s60 do var i , tmp ;
104445: LD_EXP 152
104449: IFFALSE 104518
104451: GO 104453
104453: DISABLE
104454: LD_INT 0
104456: PPUSH
104457: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104458: LD_ADDR_VAR 0 2
104462: PUSH
104463: LD_INT 22
104465: PUSH
104466: LD_OWVAR 2
104470: PUSH
104471: EMPTY
104472: LIST
104473: LIST
104474: PPUSH
104475: CALL_OW 69
104479: ST_TO_ADDR
// if not tmp then
104480: LD_VAR 0 2
104484: NOT
104485: IFFALSE 104489
// exit ;
104487: GO 104518
// for i in tmp do
104489: LD_ADDR_VAR 0 1
104493: PUSH
104494: LD_VAR 0 2
104498: PUSH
104499: FOR_IN
104500: IFFALSE 104516
// SetLives ( i , 600 ) ;
104502: LD_VAR 0 1
104506: PPUSH
104507: LD_INT 600
104509: PPUSH
104510: CALL_OW 234
104514: GO 104499
104516: POP
104517: POP
// end ;
104518: PPOPN 2
104520: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104521: LD_INT 0
104523: PPUSH
// case cmd of 301 :
104524: LD_VAR 0 1
104528: PUSH
104529: LD_INT 301
104531: DOUBLE
104532: EQUAL
104533: IFTRUE 104537
104535: GO 104569
104537: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104538: LD_VAR 0 6
104542: PPUSH
104543: LD_VAR 0 7
104547: PPUSH
104548: LD_VAR 0 8
104552: PPUSH
104553: LD_VAR 0 4
104557: PPUSH
104558: LD_VAR 0 5
104562: PPUSH
104563: CALL 105778 0 5
104567: GO 104690
104569: LD_INT 302
104571: DOUBLE
104572: EQUAL
104573: IFTRUE 104577
104575: GO 104614
104577: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104578: LD_VAR 0 6
104582: PPUSH
104583: LD_VAR 0 7
104587: PPUSH
104588: LD_VAR 0 8
104592: PPUSH
104593: LD_VAR 0 9
104597: PPUSH
104598: LD_VAR 0 4
104602: PPUSH
104603: LD_VAR 0 5
104607: PPUSH
104608: CALL 105869 0 6
104612: GO 104690
104614: LD_INT 303
104616: DOUBLE
104617: EQUAL
104618: IFTRUE 104622
104620: GO 104659
104622: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104623: LD_VAR 0 6
104627: PPUSH
104628: LD_VAR 0 7
104632: PPUSH
104633: LD_VAR 0 8
104637: PPUSH
104638: LD_VAR 0 9
104642: PPUSH
104643: LD_VAR 0 4
104647: PPUSH
104648: LD_VAR 0 5
104652: PPUSH
104653: CALL 104695 0 6
104657: GO 104690
104659: LD_INT 304
104661: DOUBLE
104662: EQUAL
104663: IFTRUE 104667
104665: GO 104689
104667: POP
// hHackTeleport ( unit , x , y ) ; end ;
104668: LD_VAR 0 2
104672: PPUSH
104673: LD_VAR 0 4
104677: PPUSH
104678: LD_VAR 0 5
104682: PPUSH
104683: CALL 106462 0 3
104687: GO 104690
104689: POP
// end ;
104690: LD_VAR 0 12
104694: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104695: LD_INT 0
104697: PPUSH
104698: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104699: LD_VAR 0 1
104703: PUSH
104704: LD_INT 1
104706: LESS
104707: PUSH
104708: LD_VAR 0 1
104712: PUSH
104713: LD_INT 3
104715: GREATER
104716: OR
104717: PUSH
104718: LD_VAR 0 5
104722: PPUSH
104723: LD_VAR 0 6
104727: PPUSH
104728: CALL_OW 428
104732: OR
104733: IFFALSE 104737
// exit ;
104735: GO 105465
// uc_side := your_side ;
104737: LD_ADDR_OWVAR 20
104741: PUSH
104742: LD_OWVAR 2
104746: ST_TO_ADDR
// uc_nation := nation ;
104747: LD_ADDR_OWVAR 21
104751: PUSH
104752: LD_VAR 0 1
104756: ST_TO_ADDR
// bc_level = 1 ;
104757: LD_ADDR_OWVAR 43
104761: PUSH
104762: LD_INT 1
104764: ST_TO_ADDR
// case btype of 1 :
104765: LD_VAR 0 2
104769: PUSH
104770: LD_INT 1
104772: DOUBLE
104773: EQUAL
104774: IFTRUE 104778
104776: GO 104789
104778: POP
// bc_type := b_depot ; 2 :
104779: LD_ADDR_OWVAR 42
104783: PUSH
104784: LD_INT 0
104786: ST_TO_ADDR
104787: GO 105409
104789: LD_INT 2
104791: DOUBLE
104792: EQUAL
104793: IFTRUE 104797
104795: GO 104808
104797: POP
// bc_type := b_warehouse ; 3 :
104798: LD_ADDR_OWVAR 42
104802: PUSH
104803: LD_INT 1
104805: ST_TO_ADDR
104806: GO 105409
104808: LD_INT 3
104810: DOUBLE
104811: EQUAL
104812: IFTRUE 104816
104814: GO 104827
104816: POP
// bc_type := b_lab ; 4 .. 9 :
104817: LD_ADDR_OWVAR 42
104821: PUSH
104822: LD_INT 6
104824: ST_TO_ADDR
104825: GO 105409
104827: LD_INT 4
104829: DOUBLE
104830: GREATEREQUAL
104831: IFFALSE 104839
104833: LD_INT 9
104835: DOUBLE
104836: LESSEQUAL
104837: IFTRUE 104841
104839: GO 104901
104841: POP
// begin bc_type := b_lab_half ;
104842: LD_ADDR_OWVAR 42
104846: PUSH
104847: LD_INT 7
104849: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104850: LD_ADDR_OWVAR 44
104854: PUSH
104855: LD_INT 10
104857: PUSH
104858: LD_INT 11
104860: PUSH
104861: LD_INT 12
104863: PUSH
104864: LD_INT 15
104866: PUSH
104867: LD_INT 14
104869: PUSH
104870: LD_INT 13
104872: PUSH
104873: EMPTY
104874: LIST
104875: LIST
104876: LIST
104877: LIST
104878: LIST
104879: LIST
104880: PUSH
104881: LD_VAR 0 2
104885: PUSH
104886: LD_INT 3
104888: MINUS
104889: ARRAY
104890: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104891: LD_ADDR_OWVAR 45
104895: PUSH
104896: LD_INT 9
104898: ST_TO_ADDR
// end ; 10 .. 13 :
104899: GO 105409
104901: LD_INT 10
104903: DOUBLE
104904: GREATEREQUAL
104905: IFFALSE 104913
104907: LD_INT 13
104909: DOUBLE
104910: LESSEQUAL
104911: IFTRUE 104915
104913: GO 104992
104915: POP
// begin bc_type := b_lab_full ;
104916: LD_ADDR_OWVAR 42
104920: PUSH
104921: LD_INT 8
104923: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104924: LD_ADDR_OWVAR 44
104928: PUSH
104929: LD_INT 10
104931: PUSH
104932: LD_INT 12
104934: PUSH
104935: LD_INT 14
104937: PUSH
104938: LD_INT 13
104940: PUSH
104941: EMPTY
104942: LIST
104943: LIST
104944: LIST
104945: LIST
104946: PUSH
104947: LD_VAR 0 2
104951: PUSH
104952: LD_INT 9
104954: MINUS
104955: ARRAY
104956: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104957: LD_ADDR_OWVAR 45
104961: PUSH
104962: LD_INT 11
104964: PUSH
104965: LD_INT 15
104967: PUSH
104968: LD_INT 12
104970: PUSH
104971: LD_INT 15
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: LIST
104978: LIST
104979: PUSH
104980: LD_VAR 0 2
104984: PUSH
104985: LD_INT 9
104987: MINUS
104988: ARRAY
104989: ST_TO_ADDR
// end ; 14 :
104990: GO 105409
104992: LD_INT 14
104994: DOUBLE
104995: EQUAL
104996: IFTRUE 105000
104998: GO 105011
105000: POP
// bc_type := b_workshop ; 15 :
105001: LD_ADDR_OWVAR 42
105005: PUSH
105006: LD_INT 2
105008: ST_TO_ADDR
105009: GO 105409
105011: LD_INT 15
105013: DOUBLE
105014: EQUAL
105015: IFTRUE 105019
105017: GO 105030
105019: POP
// bc_type := b_factory ; 16 :
105020: LD_ADDR_OWVAR 42
105024: PUSH
105025: LD_INT 3
105027: ST_TO_ADDR
105028: GO 105409
105030: LD_INT 16
105032: DOUBLE
105033: EQUAL
105034: IFTRUE 105038
105036: GO 105049
105038: POP
// bc_type := b_ext_gun ; 17 :
105039: LD_ADDR_OWVAR 42
105043: PUSH
105044: LD_INT 17
105046: ST_TO_ADDR
105047: GO 105409
105049: LD_INT 17
105051: DOUBLE
105052: EQUAL
105053: IFTRUE 105057
105055: GO 105085
105057: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105058: LD_ADDR_OWVAR 42
105062: PUSH
105063: LD_INT 19
105065: PUSH
105066: LD_INT 23
105068: PUSH
105069: LD_INT 19
105071: PUSH
105072: EMPTY
105073: LIST
105074: LIST
105075: LIST
105076: PUSH
105077: LD_VAR 0 1
105081: ARRAY
105082: ST_TO_ADDR
105083: GO 105409
105085: LD_INT 18
105087: DOUBLE
105088: EQUAL
105089: IFTRUE 105093
105091: GO 105104
105093: POP
// bc_type := b_ext_radar ; 19 :
105094: LD_ADDR_OWVAR 42
105098: PUSH
105099: LD_INT 20
105101: ST_TO_ADDR
105102: GO 105409
105104: LD_INT 19
105106: DOUBLE
105107: EQUAL
105108: IFTRUE 105112
105110: GO 105123
105112: POP
// bc_type := b_ext_radio ; 20 :
105113: LD_ADDR_OWVAR 42
105117: PUSH
105118: LD_INT 22
105120: ST_TO_ADDR
105121: GO 105409
105123: LD_INT 20
105125: DOUBLE
105126: EQUAL
105127: IFTRUE 105131
105129: GO 105142
105131: POP
// bc_type := b_ext_siberium ; 21 :
105132: LD_ADDR_OWVAR 42
105136: PUSH
105137: LD_INT 21
105139: ST_TO_ADDR
105140: GO 105409
105142: LD_INT 21
105144: DOUBLE
105145: EQUAL
105146: IFTRUE 105150
105148: GO 105161
105150: POP
// bc_type := b_ext_computer ; 22 :
105151: LD_ADDR_OWVAR 42
105155: PUSH
105156: LD_INT 24
105158: ST_TO_ADDR
105159: GO 105409
105161: LD_INT 22
105163: DOUBLE
105164: EQUAL
105165: IFTRUE 105169
105167: GO 105180
105169: POP
// bc_type := b_ext_track ; 23 :
105170: LD_ADDR_OWVAR 42
105174: PUSH
105175: LD_INT 16
105177: ST_TO_ADDR
105178: GO 105409
105180: LD_INT 23
105182: DOUBLE
105183: EQUAL
105184: IFTRUE 105188
105186: GO 105199
105188: POP
// bc_type := b_ext_laser ; 24 :
105189: LD_ADDR_OWVAR 42
105193: PUSH
105194: LD_INT 25
105196: ST_TO_ADDR
105197: GO 105409
105199: LD_INT 24
105201: DOUBLE
105202: EQUAL
105203: IFTRUE 105207
105205: GO 105218
105207: POP
// bc_type := b_control_tower ; 25 :
105208: LD_ADDR_OWVAR 42
105212: PUSH
105213: LD_INT 36
105215: ST_TO_ADDR
105216: GO 105409
105218: LD_INT 25
105220: DOUBLE
105221: EQUAL
105222: IFTRUE 105226
105224: GO 105237
105226: POP
// bc_type := b_breastwork ; 26 :
105227: LD_ADDR_OWVAR 42
105231: PUSH
105232: LD_INT 31
105234: ST_TO_ADDR
105235: GO 105409
105237: LD_INT 26
105239: DOUBLE
105240: EQUAL
105241: IFTRUE 105245
105243: GO 105256
105245: POP
// bc_type := b_bunker ; 27 :
105246: LD_ADDR_OWVAR 42
105250: PUSH
105251: LD_INT 32
105253: ST_TO_ADDR
105254: GO 105409
105256: LD_INT 27
105258: DOUBLE
105259: EQUAL
105260: IFTRUE 105264
105262: GO 105275
105264: POP
// bc_type := b_turret ; 28 :
105265: LD_ADDR_OWVAR 42
105269: PUSH
105270: LD_INT 33
105272: ST_TO_ADDR
105273: GO 105409
105275: LD_INT 28
105277: DOUBLE
105278: EQUAL
105279: IFTRUE 105283
105281: GO 105294
105283: POP
// bc_type := b_armoury ; 29 :
105284: LD_ADDR_OWVAR 42
105288: PUSH
105289: LD_INT 4
105291: ST_TO_ADDR
105292: GO 105409
105294: LD_INT 29
105296: DOUBLE
105297: EQUAL
105298: IFTRUE 105302
105300: GO 105313
105302: POP
// bc_type := b_barracks ; 30 :
105303: LD_ADDR_OWVAR 42
105307: PUSH
105308: LD_INT 5
105310: ST_TO_ADDR
105311: GO 105409
105313: LD_INT 30
105315: DOUBLE
105316: EQUAL
105317: IFTRUE 105321
105319: GO 105332
105321: POP
// bc_type := b_solar_power ; 31 :
105322: LD_ADDR_OWVAR 42
105326: PUSH
105327: LD_INT 27
105329: ST_TO_ADDR
105330: GO 105409
105332: LD_INT 31
105334: DOUBLE
105335: EQUAL
105336: IFTRUE 105340
105338: GO 105351
105340: POP
// bc_type := b_oil_power ; 32 :
105341: LD_ADDR_OWVAR 42
105345: PUSH
105346: LD_INT 26
105348: ST_TO_ADDR
105349: GO 105409
105351: LD_INT 32
105353: DOUBLE
105354: EQUAL
105355: IFTRUE 105359
105357: GO 105370
105359: POP
// bc_type := b_siberite_power ; 33 :
105360: LD_ADDR_OWVAR 42
105364: PUSH
105365: LD_INT 28
105367: ST_TO_ADDR
105368: GO 105409
105370: LD_INT 33
105372: DOUBLE
105373: EQUAL
105374: IFTRUE 105378
105376: GO 105389
105378: POP
// bc_type := b_oil_mine ; 34 :
105379: LD_ADDR_OWVAR 42
105383: PUSH
105384: LD_INT 29
105386: ST_TO_ADDR
105387: GO 105409
105389: LD_INT 34
105391: DOUBLE
105392: EQUAL
105393: IFTRUE 105397
105395: GO 105408
105397: POP
// bc_type := b_siberite_mine ; end ;
105398: LD_ADDR_OWVAR 42
105402: PUSH
105403: LD_INT 30
105405: ST_TO_ADDR
105406: GO 105409
105408: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105409: LD_ADDR_VAR 0 8
105413: PUSH
105414: LD_VAR 0 5
105418: PPUSH
105419: LD_VAR 0 6
105423: PPUSH
105424: LD_VAR 0 3
105428: PPUSH
105429: CALL_OW 47
105433: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105434: LD_OWVAR 42
105438: PUSH
105439: LD_INT 32
105441: PUSH
105442: LD_INT 33
105444: PUSH
105445: EMPTY
105446: LIST
105447: LIST
105448: IN
105449: IFFALSE 105465
// PlaceWeaponTurret ( b , weapon ) ;
105451: LD_VAR 0 8
105455: PPUSH
105456: LD_VAR 0 4
105460: PPUSH
105461: CALL_OW 431
// end ;
105465: LD_VAR 0 7
105469: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105470: LD_INT 0
105472: PPUSH
105473: PPUSH
105474: PPUSH
105475: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105476: LD_ADDR_VAR 0 4
105480: PUSH
105481: LD_INT 22
105483: PUSH
105484: LD_OWVAR 2
105488: PUSH
105489: EMPTY
105490: LIST
105491: LIST
105492: PUSH
105493: LD_INT 2
105495: PUSH
105496: LD_INT 30
105498: PUSH
105499: LD_INT 0
105501: PUSH
105502: EMPTY
105503: LIST
105504: LIST
105505: PUSH
105506: LD_INT 30
105508: PUSH
105509: LD_INT 1
105511: PUSH
105512: EMPTY
105513: LIST
105514: LIST
105515: PUSH
105516: EMPTY
105517: LIST
105518: LIST
105519: LIST
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PPUSH
105525: CALL_OW 69
105529: ST_TO_ADDR
// if not tmp then
105530: LD_VAR 0 4
105534: NOT
105535: IFFALSE 105539
// exit ;
105537: GO 105598
// for i in tmp do
105539: LD_ADDR_VAR 0 2
105543: PUSH
105544: LD_VAR 0 4
105548: PUSH
105549: FOR_IN
105550: IFFALSE 105596
// for j = 1 to 3 do
105552: LD_ADDR_VAR 0 3
105556: PUSH
105557: DOUBLE
105558: LD_INT 1
105560: DEC
105561: ST_TO_ADDR
105562: LD_INT 3
105564: PUSH
105565: FOR_TO
105566: IFFALSE 105592
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105568: LD_VAR 0 2
105572: PPUSH
105573: CALL_OW 274
105577: PPUSH
105578: LD_VAR 0 3
105582: PPUSH
105583: LD_INT 99999
105585: PPUSH
105586: CALL_OW 277
105590: GO 105565
105592: POP
105593: POP
105594: GO 105549
105596: POP
105597: POP
// end ;
105598: LD_VAR 0 1
105602: RET
// export function hHackSetLevel10 ; var i , j ; begin
105603: LD_INT 0
105605: PPUSH
105606: PPUSH
105607: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105608: LD_ADDR_VAR 0 2
105612: PUSH
105613: LD_INT 21
105615: PUSH
105616: LD_INT 1
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: PPUSH
105623: CALL_OW 69
105627: PUSH
105628: FOR_IN
105629: IFFALSE 105681
// if IsSelected ( i ) then
105631: LD_VAR 0 2
105635: PPUSH
105636: CALL_OW 306
105640: IFFALSE 105679
// begin for j := 1 to 4 do
105642: LD_ADDR_VAR 0 3
105646: PUSH
105647: DOUBLE
105648: LD_INT 1
105650: DEC
105651: ST_TO_ADDR
105652: LD_INT 4
105654: PUSH
105655: FOR_TO
105656: IFFALSE 105677
// SetSkill ( i , j , 10 ) ;
105658: LD_VAR 0 2
105662: PPUSH
105663: LD_VAR 0 3
105667: PPUSH
105668: LD_INT 10
105670: PPUSH
105671: CALL_OW 237
105675: GO 105655
105677: POP
105678: POP
// end ;
105679: GO 105628
105681: POP
105682: POP
// end ;
105683: LD_VAR 0 1
105687: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105688: LD_INT 0
105690: PPUSH
105691: PPUSH
105692: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105693: LD_ADDR_VAR 0 2
105697: PUSH
105698: LD_INT 22
105700: PUSH
105701: LD_OWVAR 2
105705: PUSH
105706: EMPTY
105707: LIST
105708: LIST
105709: PUSH
105710: LD_INT 21
105712: PUSH
105713: LD_INT 1
105715: PUSH
105716: EMPTY
105717: LIST
105718: LIST
105719: PUSH
105720: EMPTY
105721: LIST
105722: LIST
105723: PPUSH
105724: CALL_OW 69
105728: PUSH
105729: FOR_IN
105730: IFFALSE 105771
// begin for j := 1 to 4 do
105732: LD_ADDR_VAR 0 3
105736: PUSH
105737: DOUBLE
105738: LD_INT 1
105740: DEC
105741: ST_TO_ADDR
105742: LD_INT 4
105744: PUSH
105745: FOR_TO
105746: IFFALSE 105767
// SetSkill ( i , j , 10 ) ;
105748: LD_VAR 0 2
105752: PPUSH
105753: LD_VAR 0 3
105757: PPUSH
105758: LD_INT 10
105760: PPUSH
105761: CALL_OW 237
105765: GO 105745
105767: POP
105768: POP
// end ;
105769: GO 105729
105771: POP
105772: POP
// end ;
105773: LD_VAR 0 1
105777: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105778: LD_INT 0
105780: PPUSH
// uc_side := your_side ;
105781: LD_ADDR_OWVAR 20
105785: PUSH
105786: LD_OWVAR 2
105790: ST_TO_ADDR
// uc_nation := nation ;
105791: LD_ADDR_OWVAR 21
105795: PUSH
105796: LD_VAR 0 1
105800: ST_TO_ADDR
// InitHc ;
105801: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105805: LD_INT 0
105807: PPUSH
105808: LD_VAR 0 2
105812: PPUSH
105813: LD_VAR 0 3
105817: PPUSH
105818: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105822: LD_VAR 0 4
105826: PPUSH
105827: LD_VAR 0 5
105831: PPUSH
105832: CALL_OW 428
105836: PUSH
105837: LD_INT 0
105839: EQUAL
105840: IFFALSE 105864
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105842: CALL_OW 44
105846: PPUSH
105847: LD_VAR 0 4
105851: PPUSH
105852: LD_VAR 0 5
105856: PPUSH
105857: LD_INT 1
105859: PPUSH
105860: CALL_OW 48
// end ;
105864: LD_VAR 0 6
105868: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105869: LD_INT 0
105871: PPUSH
105872: PPUSH
// uc_side := your_side ;
105873: LD_ADDR_OWVAR 20
105877: PUSH
105878: LD_OWVAR 2
105882: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105883: LD_VAR 0 1
105887: PUSH
105888: LD_INT 1
105890: PUSH
105891: LD_INT 2
105893: PUSH
105894: LD_INT 3
105896: PUSH
105897: LD_INT 4
105899: PUSH
105900: LD_INT 5
105902: PUSH
105903: EMPTY
105904: LIST
105905: LIST
105906: LIST
105907: LIST
105908: LIST
105909: IN
105910: IFFALSE 105922
// uc_nation := nation_american else
105912: LD_ADDR_OWVAR 21
105916: PUSH
105917: LD_INT 1
105919: ST_TO_ADDR
105920: GO 105965
// if chassis in [ 11 , 12 , 13 , 14 ] then
105922: LD_VAR 0 1
105926: PUSH
105927: LD_INT 11
105929: PUSH
105930: LD_INT 12
105932: PUSH
105933: LD_INT 13
105935: PUSH
105936: LD_INT 14
105938: PUSH
105939: EMPTY
105940: LIST
105941: LIST
105942: LIST
105943: LIST
105944: IN
105945: IFFALSE 105957
// uc_nation := nation_arabian else
105947: LD_ADDR_OWVAR 21
105951: PUSH
105952: LD_INT 2
105954: ST_TO_ADDR
105955: GO 105965
// uc_nation := nation_russian ;
105957: LD_ADDR_OWVAR 21
105961: PUSH
105962: LD_INT 3
105964: ST_TO_ADDR
// vc_chassis := chassis ;
105965: LD_ADDR_OWVAR 37
105969: PUSH
105970: LD_VAR 0 1
105974: ST_TO_ADDR
// vc_engine := engine ;
105975: LD_ADDR_OWVAR 39
105979: PUSH
105980: LD_VAR 0 2
105984: ST_TO_ADDR
// vc_control := control ;
105985: LD_ADDR_OWVAR 38
105989: PUSH
105990: LD_VAR 0 3
105994: ST_TO_ADDR
// vc_weapon := weapon ;
105995: LD_ADDR_OWVAR 40
105999: PUSH
106000: LD_VAR 0 4
106004: ST_TO_ADDR
// un := CreateVehicle ;
106005: LD_ADDR_VAR 0 8
106009: PUSH
106010: CALL_OW 45
106014: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106015: LD_VAR 0 8
106019: PPUSH
106020: LD_INT 0
106022: PPUSH
106023: LD_INT 5
106025: PPUSH
106026: CALL_OW 12
106030: PPUSH
106031: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106035: LD_VAR 0 8
106039: PPUSH
106040: LD_VAR 0 5
106044: PPUSH
106045: LD_VAR 0 6
106049: PPUSH
106050: LD_INT 1
106052: PPUSH
106053: CALL_OW 48
// end ;
106057: LD_VAR 0 7
106061: RET
// export hInvincible ; every 1 do
106062: GO 106064
106064: DISABLE
// hInvincible := [ ] ;
106065: LD_ADDR_EXP 153
106069: PUSH
106070: EMPTY
106071: ST_TO_ADDR
106072: END
// every 10 do var i ;
106073: GO 106075
106075: DISABLE
106076: LD_INT 0
106078: PPUSH
// begin enable ;
106079: ENABLE
// if not hInvincible then
106080: LD_EXP 153
106084: NOT
106085: IFFALSE 106089
// exit ;
106087: GO 106133
// for i in hInvincible do
106089: LD_ADDR_VAR 0 1
106093: PUSH
106094: LD_EXP 153
106098: PUSH
106099: FOR_IN
106100: IFFALSE 106131
// if GetLives ( i ) < 1000 then
106102: LD_VAR 0 1
106106: PPUSH
106107: CALL_OW 256
106111: PUSH
106112: LD_INT 1000
106114: LESS
106115: IFFALSE 106129
// SetLives ( i , 1000 ) ;
106117: LD_VAR 0 1
106121: PPUSH
106122: LD_INT 1000
106124: PPUSH
106125: CALL_OW 234
106129: GO 106099
106131: POP
106132: POP
// end ;
106133: PPOPN 1
106135: END
// export function hHackInvincible ; var i ; begin
106136: LD_INT 0
106138: PPUSH
106139: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106140: LD_ADDR_VAR 0 2
106144: PUSH
106145: LD_INT 2
106147: PUSH
106148: LD_INT 21
106150: PUSH
106151: LD_INT 1
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: PUSH
106158: LD_INT 21
106160: PUSH
106161: LD_INT 2
106163: PUSH
106164: EMPTY
106165: LIST
106166: LIST
106167: PUSH
106168: EMPTY
106169: LIST
106170: LIST
106171: LIST
106172: PPUSH
106173: CALL_OW 69
106177: PUSH
106178: FOR_IN
106179: IFFALSE 106240
// if IsSelected ( i ) then
106181: LD_VAR 0 2
106185: PPUSH
106186: CALL_OW 306
106190: IFFALSE 106238
// begin if i in hInvincible then
106192: LD_VAR 0 2
106196: PUSH
106197: LD_EXP 153
106201: IN
106202: IFFALSE 106222
// hInvincible := hInvincible diff i else
106204: LD_ADDR_EXP 153
106208: PUSH
106209: LD_EXP 153
106213: PUSH
106214: LD_VAR 0 2
106218: DIFF
106219: ST_TO_ADDR
106220: GO 106238
// hInvincible := hInvincible union i ;
106222: LD_ADDR_EXP 153
106226: PUSH
106227: LD_EXP 153
106231: PUSH
106232: LD_VAR 0 2
106236: UNION
106237: ST_TO_ADDR
// end ;
106238: GO 106178
106240: POP
106241: POP
// end ;
106242: LD_VAR 0 1
106246: RET
// export function hHackInvisible ; var i , j ; begin
106247: LD_INT 0
106249: PPUSH
106250: PPUSH
106251: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106252: LD_ADDR_VAR 0 2
106256: PUSH
106257: LD_INT 21
106259: PUSH
106260: LD_INT 1
106262: PUSH
106263: EMPTY
106264: LIST
106265: LIST
106266: PPUSH
106267: CALL_OW 69
106271: PUSH
106272: FOR_IN
106273: IFFALSE 106297
// if IsSelected ( i ) then
106275: LD_VAR 0 2
106279: PPUSH
106280: CALL_OW 306
106284: IFFALSE 106295
// ComForceInvisible ( i ) ;
106286: LD_VAR 0 2
106290: PPUSH
106291: CALL_OW 496
106295: GO 106272
106297: POP
106298: POP
// end ;
106299: LD_VAR 0 1
106303: RET
// export function hHackChangeYourSide ; begin
106304: LD_INT 0
106306: PPUSH
// if your_side = 8 then
106307: LD_OWVAR 2
106311: PUSH
106312: LD_INT 8
106314: EQUAL
106315: IFFALSE 106327
// your_side := 0 else
106317: LD_ADDR_OWVAR 2
106321: PUSH
106322: LD_INT 0
106324: ST_TO_ADDR
106325: GO 106341
// your_side := your_side + 1 ;
106327: LD_ADDR_OWVAR 2
106331: PUSH
106332: LD_OWVAR 2
106336: PUSH
106337: LD_INT 1
106339: PLUS
106340: ST_TO_ADDR
// end ;
106341: LD_VAR 0 1
106345: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106346: LD_INT 0
106348: PPUSH
106349: PPUSH
106350: PPUSH
// for i in all_units do
106351: LD_ADDR_VAR 0 2
106355: PUSH
106356: LD_OWVAR 3
106360: PUSH
106361: FOR_IN
106362: IFFALSE 106440
// if IsSelected ( i ) then
106364: LD_VAR 0 2
106368: PPUSH
106369: CALL_OW 306
106373: IFFALSE 106438
// begin j := GetSide ( i ) ;
106375: LD_ADDR_VAR 0 3
106379: PUSH
106380: LD_VAR 0 2
106384: PPUSH
106385: CALL_OW 255
106389: ST_TO_ADDR
// if j = 8 then
106390: LD_VAR 0 3
106394: PUSH
106395: LD_INT 8
106397: EQUAL
106398: IFFALSE 106410
// j := 0 else
106400: LD_ADDR_VAR 0 3
106404: PUSH
106405: LD_INT 0
106407: ST_TO_ADDR
106408: GO 106424
// j := j + 1 ;
106410: LD_ADDR_VAR 0 3
106414: PUSH
106415: LD_VAR 0 3
106419: PUSH
106420: LD_INT 1
106422: PLUS
106423: ST_TO_ADDR
// SetSide ( i , j ) ;
106424: LD_VAR 0 2
106428: PPUSH
106429: LD_VAR 0 3
106433: PPUSH
106434: CALL_OW 235
// end ;
106438: GO 106361
106440: POP
106441: POP
// end ;
106442: LD_VAR 0 1
106446: RET
// export function hHackFog ; begin
106447: LD_INT 0
106449: PPUSH
// FogOff ( true ) ;
106450: LD_INT 1
106452: PPUSH
106453: CALL_OW 344
// end ;
106457: LD_VAR 0 1
106461: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106462: LD_INT 0
106464: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106465: LD_VAR 0 1
106469: PPUSH
106470: LD_VAR 0 2
106474: PPUSH
106475: LD_VAR 0 3
106479: PPUSH
106480: LD_INT 1
106482: PPUSH
106483: LD_INT 1
106485: PPUSH
106486: CALL_OW 483
// CenterOnXY ( x , y ) ;
106490: LD_VAR 0 2
106494: PPUSH
106495: LD_VAR 0 3
106499: PPUSH
106500: CALL_OW 84
// end ;
106504: LD_VAR 0 4
106508: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106509: LD_INT 0
106511: PPUSH
106512: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106513: LD_VAR 0 1
106517: NOT
106518: PUSH
106519: LD_VAR 0 2
106523: PPUSH
106524: LD_VAR 0 3
106528: PPUSH
106529: CALL_OW 488
106533: NOT
106534: OR
106535: PUSH
106536: LD_VAR 0 1
106540: PPUSH
106541: CALL_OW 266
106545: PUSH
106546: LD_INT 3
106548: NONEQUAL
106549: PUSH
106550: LD_VAR 0 1
106554: PPUSH
106555: CALL_OW 247
106559: PUSH
106560: LD_INT 1
106562: EQUAL
106563: NOT
106564: AND
106565: OR
106566: IFFALSE 106570
// exit ;
106568: GO 106852
// if GetType ( factory ) = unit_human then
106570: LD_VAR 0 1
106574: PPUSH
106575: CALL_OW 247
106579: PUSH
106580: LD_INT 1
106582: EQUAL
106583: IFFALSE 106600
// factory := IsInUnit ( factory ) ;
106585: LD_ADDR_VAR 0 1
106589: PUSH
106590: LD_VAR 0 1
106594: PPUSH
106595: CALL_OW 310
106599: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106600: LD_VAR 0 1
106604: PPUSH
106605: CALL_OW 266
106609: PUSH
106610: LD_INT 3
106612: NONEQUAL
106613: IFFALSE 106617
// exit ;
106615: GO 106852
// for i := 1 to Count ( factoryWaypoints ) do
106617: LD_ADDR_VAR 0 5
106621: PUSH
106622: DOUBLE
106623: LD_INT 1
106625: DEC
106626: ST_TO_ADDR
106627: LD_EXP 154
106631: PPUSH
106632: CALL 51308 0 1
106636: PUSH
106637: FOR_TO
106638: IFFALSE 106800
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
106640: LD_VAR 0 2
106644: PPUSH
106645: LD_VAR 0 3
106649: PPUSH
106650: CALL_OW 428
106654: PUSH
106655: LD_EXP 154
106659: PUSH
106660: LD_VAR 0 5
106664: ARRAY
106665: PUSH
106666: LD_INT 2
106668: ARRAY
106669: EQUAL
106670: IFFALSE 106702
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106672: LD_ADDR_EXP 154
106676: PUSH
106677: LD_EXP 154
106681: PPUSH
106682: LD_VAR 0 5
106686: PPUSH
106687: CALL_OW 3
106691: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106692: CALL 106857 0 0
// exit ;
106696: POP
106697: POP
106698: GO 106852
// end else
106700: GO 106798
// if factory = factoryWaypoints [ i ] [ 2 ] then
106702: LD_VAR 0 1
106706: PUSH
106707: LD_EXP 154
106711: PUSH
106712: LD_VAR 0 5
106716: ARRAY
106717: PUSH
106718: LD_INT 2
106720: ARRAY
106721: EQUAL
106722: IFFALSE 106798
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106724: LD_ADDR_EXP 154
106728: PUSH
106729: LD_EXP 154
106733: PPUSH
106734: LD_VAR 0 5
106738: PPUSH
106739: CALL_OW 3
106743: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106744: LD_ADDR_EXP 154
106748: PUSH
106749: LD_EXP 154
106753: PPUSH
106754: LD_VAR 0 1
106758: PPUSH
106759: CALL_OW 255
106763: PUSH
106764: LD_VAR 0 1
106768: PUSH
106769: LD_VAR 0 2
106773: PUSH
106774: LD_VAR 0 3
106778: PUSH
106779: EMPTY
106780: LIST
106781: LIST
106782: LIST
106783: LIST
106784: PPUSH
106785: CALL 86917 0 2
106789: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106790: CALL 106857 0 0
// exit ;
106794: POP
106795: POP
106796: GO 106852
// end ; end ;
106798: GO 106637
106800: POP
106801: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106802: LD_ADDR_EXP 154
106806: PUSH
106807: LD_EXP 154
106811: PPUSH
106812: LD_VAR 0 1
106816: PPUSH
106817: CALL_OW 255
106821: PUSH
106822: LD_VAR 0 1
106826: PUSH
106827: LD_VAR 0 2
106831: PUSH
106832: LD_VAR 0 3
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: LIST
106841: LIST
106842: PPUSH
106843: CALL 86917 0 2
106847: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106848: CALL 106857 0 0
// end ;
106852: LD_VAR 0 4
106856: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106857: LD_INT 0
106859: PPUSH
106860: PPUSH
106861: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106862: LD_STRING resetFactoryWaypoint();
106864: PPUSH
106865: CALL_OW 559
// if factoryWaypoints then
106869: LD_EXP 154
106873: IFFALSE 106994
// begin list := factoryWaypoints ;
106875: LD_ADDR_VAR 0 3
106879: PUSH
106880: LD_EXP 154
106884: ST_TO_ADDR
// for i := 1 to list do
106885: LD_ADDR_VAR 0 2
106889: PUSH
106890: DOUBLE
106891: LD_INT 1
106893: DEC
106894: ST_TO_ADDR
106895: LD_VAR 0 3
106899: PUSH
106900: FOR_TO
106901: IFFALSE 106992
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106903: LD_STRING setFactoryWaypointXY(
106905: PUSH
106906: LD_VAR 0 3
106910: PUSH
106911: LD_VAR 0 2
106915: ARRAY
106916: PUSH
106917: LD_INT 1
106919: ARRAY
106920: STR
106921: PUSH
106922: LD_STRING ,
106924: STR
106925: PUSH
106926: LD_VAR 0 3
106930: PUSH
106931: LD_VAR 0 2
106935: ARRAY
106936: PUSH
106937: LD_INT 2
106939: ARRAY
106940: STR
106941: PUSH
106942: LD_STRING ,
106944: STR
106945: PUSH
106946: LD_VAR 0 3
106950: PUSH
106951: LD_VAR 0 2
106955: ARRAY
106956: PUSH
106957: LD_INT 3
106959: ARRAY
106960: STR
106961: PUSH
106962: LD_STRING ,
106964: STR
106965: PUSH
106966: LD_VAR 0 3
106970: PUSH
106971: LD_VAR 0 2
106975: ARRAY
106976: PUSH
106977: LD_INT 4
106979: ARRAY
106980: STR
106981: PUSH
106982: LD_STRING )
106984: STR
106985: PPUSH
106986: CALL_OW 559
106990: GO 106900
106992: POP
106993: POP
// end ; end ;
106994: LD_VAR 0 1
106998: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106999: LD_INT 0
107001: PPUSH
// if HexInfo ( x , y ) = warehouse then
107002: LD_VAR 0 2
107006: PPUSH
107007: LD_VAR 0 3
107011: PPUSH
107012: CALL_OW 428
107016: PUSH
107017: LD_VAR 0 1
107021: EQUAL
107022: IFFALSE 107049
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107024: LD_ADDR_EXP 155
107028: PUSH
107029: LD_EXP 155
107033: PPUSH
107034: LD_VAR 0 1
107038: PPUSH
107039: LD_INT 0
107041: PPUSH
107042: CALL_OW 1
107046: ST_TO_ADDR
107047: GO 107100
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107049: LD_ADDR_EXP 155
107053: PUSH
107054: LD_EXP 155
107058: PPUSH
107059: LD_VAR 0 1
107063: PPUSH
107064: LD_VAR 0 1
107068: PPUSH
107069: CALL_OW 255
107073: PUSH
107074: LD_VAR 0 1
107078: PUSH
107079: LD_VAR 0 2
107083: PUSH
107084: LD_VAR 0 3
107088: PUSH
107089: EMPTY
107090: LIST
107091: LIST
107092: LIST
107093: LIST
107094: PPUSH
107095: CALL_OW 1
107099: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107100: CALL 107109 0 0
// end ;
107104: LD_VAR 0 4
107108: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107109: LD_INT 0
107111: PPUSH
107112: PPUSH
107113: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107114: LD_STRING resetWarehouseGatheringPoints();
107116: PPUSH
107117: CALL_OW 559
// if warehouseGatheringPoints then
107121: LD_EXP 155
107125: IFFALSE 107251
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107127: LD_ADDR_VAR 0 3
107131: PUSH
107132: LD_EXP 155
107136: PPUSH
107137: CALL 90679 0 1
107141: ST_TO_ADDR
// for i := 1 to list do
107142: LD_ADDR_VAR 0 2
107146: PUSH
107147: DOUBLE
107148: LD_INT 1
107150: DEC
107151: ST_TO_ADDR
107152: LD_VAR 0 3
107156: PUSH
107157: FOR_TO
107158: IFFALSE 107249
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107160: LD_STRING setWarehouseGatheringPointXY(
107162: PUSH
107163: LD_VAR 0 3
107167: PUSH
107168: LD_VAR 0 2
107172: ARRAY
107173: PUSH
107174: LD_INT 1
107176: ARRAY
107177: STR
107178: PUSH
107179: LD_STRING ,
107181: STR
107182: PUSH
107183: LD_VAR 0 3
107187: PUSH
107188: LD_VAR 0 2
107192: ARRAY
107193: PUSH
107194: LD_INT 2
107196: ARRAY
107197: STR
107198: PUSH
107199: LD_STRING ,
107201: STR
107202: PUSH
107203: LD_VAR 0 3
107207: PUSH
107208: LD_VAR 0 2
107212: ARRAY
107213: PUSH
107214: LD_INT 3
107216: ARRAY
107217: STR
107218: PUSH
107219: LD_STRING ,
107221: STR
107222: PUSH
107223: LD_VAR 0 3
107227: PUSH
107228: LD_VAR 0 2
107232: ARRAY
107233: PUSH
107234: LD_INT 4
107236: ARRAY
107237: STR
107238: PUSH
107239: LD_STRING )
107241: STR
107242: PPUSH
107243: CALL_OW 559
107247: GO 107157
107249: POP
107250: POP
// end ; end ;
107251: LD_VAR 0 1
107255: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107256: LD_EXP 155
107260: IFFALSE 107945
107262: GO 107264
107264: DISABLE
107265: LD_INT 0
107267: PPUSH
107268: PPUSH
107269: PPUSH
107270: PPUSH
107271: PPUSH
107272: PPUSH
107273: PPUSH
107274: PPUSH
107275: PPUSH
// begin enable ;
107276: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107277: LD_ADDR_VAR 0 3
107281: PUSH
107282: LD_EXP 155
107286: PPUSH
107287: CALL 90679 0 1
107291: ST_TO_ADDR
// if not list then
107292: LD_VAR 0 3
107296: NOT
107297: IFFALSE 107301
// exit ;
107299: GO 107945
// for i := 1 to list do
107301: LD_ADDR_VAR 0 1
107305: PUSH
107306: DOUBLE
107307: LD_INT 1
107309: DEC
107310: ST_TO_ADDR
107311: LD_VAR 0 3
107315: PUSH
107316: FOR_TO
107317: IFFALSE 107943
// begin depot := list [ i ] [ 2 ] ;
107319: LD_ADDR_VAR 0 8
107323: PUSH
107324: LD_VAR 0 3
107328: PUSH
107329: LD_VAR 0 1
107333: ARRAY
107334: PUSH
107335: LD_INT 2
107337: ARRAY
107338: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107339: LD_ADDR_VAR 0 5
107343: PUSH
107344: LD_VAR 0 3
107348: PUSH
107349: LD_VAR 0 1
107353: ARRAY
107354: PUSH
107355: LD_INT 1
107357: ARRAY
107358: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107359: LD_VAR 0 8
107363: PPUSH
107364: CALL_OW 301
107368: PUSH
107369: LD_VAR 0 5
107373: PUSH
107374: LD_VAR 0 8
107378: PPUSH
107379: CALL_OW 255
107383: NONEQUAL
107384: OR
107385: IFFALSE 107414
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107387: LD_ADDR_EXP 155
107391: PUSH
107392: LD_EXP 155
107396: PPUSH
107397: LD_VAR 0 8
107401: PPUSH
107402: LD_INT 0
107404: PPUSH
107405: CALL_OW 1
107409: ST_TO_ADDR
// exit ;
107410: POP
107411: POP
107412: GO 107945
// end ; x := list [ i ] [ 3 ] ;
107414: LD_ADDR_VAR 0 6
107418: PUSH
107419: LD_VAR 0 3
107423: PUSH
107424: LD_VAR 0 1
107428: ARRAY
107429: PUSH
107430: LD_INT 3
107432: ARRAY
107433: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107434: LD_ADDR_VAR 0 7
107438: PUSH
107439: LD_VAR 0 3
107443: PUSH
107444: LD_VAR 0 1
107448: ARRAY
107449: PUSH
107450: LD_INT 4
107452: ARRAY
107453: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107454: LD_ADDR_VAR 0 9
107458: PUSH
107459: LD_VAR 0 6
107463: PPUSH
107464: LD_VAR 0 7
107468: PPUSH
107469: LD_INT 16
107471: PPUSH
107472: CALL 89263 0 3
107476: ST_TO_ADDR
// if not cratesNearbyPoint then
107477: LD_VAR 0 9
107481: NOT
107482: IFFALSE 107488
// exit ;
107484: POP
107485: POP
107486: GO 107945
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107488: LD_ADDR_VAR 0 4
107492: PUSH
107493: LD_INT 22
107495: PUSH
107496: LD_VAR 0 5
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: PUSH
107505: LD_INT 3
107507: PUSH
107508: LD_INT 60
107510: PUSH
107511: EMPTY
107512: LIST
107513: PUSH
107514: EMPTY
107515: LIST
107516: LIST
107517: PUSH
107518: LD_INT 91
107520: PUSH
107521: LD_VAR 0 8
107525: PUSH
107526: LD_INT 6
107528: PUSH
107529: EMPTY
107530: LIST
107531: LIST
107532: LIST
107533: PUSH
107534: LD_INT 2
107536: PUSH
107537: LD_INT 25
107539: PUSH
107540: LD_INT 2
107542: PUSH
107543: EMPTY
107544: LIST
107545: LIST
107546: PUSH
107547: LD_INT 25
107549: PUSH
107550: LD_INT 16
107552: PUSH
107553: EMPTY
107554: LIST
107555: LIST
107556: PUSH
107557: EMPTY
107558: LIST
107559: LIST
107560: LIST
107561: PUSH
107562: EMPTY
107563: LIST
107564: LIST
107565: LIST
107566: LIST
107567: PPUSH
107568: CALL_OW 69
107572: PUSH
107573: LD_VAR 0 8
107577: PPUSH
107578: CALL_OW 313
107582: PPUSH
107583: LD_INT 3
107585: PUSH
107586: LD_INT 60
107588: PUSH
107589: EMPTY
107590: LIST
107591: PUSH
107592: EMPTY
107593: LIST
107594: LIST
107595: PUSH
107596: LD_INT 2
107598: PUSH
107599: LD_INT 25
107601: PUSH
107602: LD_INT 2
107604: PUSH
107605: EMPTY
107606: LIST
107607: LIST
107608: PUSH
107609: LD_INT 25
107611: PUSH
107612: LD_INT 16
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: LIST
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PPUSH
107628: CALL_OW 72
107632: UNION
107633: ST_TO_ADDR
// if tmp then
107634: LD_VAR 0 4
107638: IFFALSE 107718
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107640: LD_ADDR_VAR 0 4
107644: PUSH
107645: LD_VAR 0 4
107649: PPUSH
107650: LD_INT 3
107652: PPUSH
107653: CALL 87232 0 2
107657: ST_TO_ADDR
// for j in tmp do
107658: LD_ADDR_VAR 0 2
107662: PUSH
107663: LD_VAR 0 4
107667: PUSH
107668: FOR_IN
107669: IFFALSE 107712
// begin if IsInUnit ( j ) then
107671: LD_VAR 0 2
107675: PPUSH
107676: CALL_OW 310
107680: IFFALSE 107691
// ComExit ( j ) ;
107682: LD_VAR 0 2
107686: PPUSH
107687: CALL 87315 0 1
// AddComCollect ( j , x , y ) ;
107691: LD_VAR 0 2
107695: PPUSH
107696: LD_VAR 0 6
107700: PPUSH
107701: LD_VAR 0 7
107705: PPUSH
107706: CALL_OW 177
// end ;
107710: GO 107668
107712: POP
107713: POP
// exit ;
107714: POP
107715: POP
107716: GO 107945
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107718: LD_ADDR_VAR 0 4
107722: PUSH
107723: LD_INT 22
107725: PUSH
107726: LD_VAR 0 5
107730: PUSH
107731: EMPTY
107732: LIST
107733: LIST
107734: PUSH
107735: LD_INT 91
107737: PUSH
107738: LD_VAR 0 8
107742: PUSH
107743: LD_INT 8
107745: PUSH
107746: EMPTY
107747: LIST
107748: LIST
107749: LIST
107750: PUSH
107751: LD_INT 2
107753: PUSH
107754: LD_INT 34
107756: PUSH
107757: LD_INT 12
107759: PUSH
107760: EMPTY
107761: LIST
107762: LIST
107763: PUSH
107764: LD_INT 34
107766: PUSH
107767: LD_INT 51
107769: PUSH
107770: EMPTY
107771: LIST
107772: LIST
107773: PUSH
107774: LD_INT 34
107776: PUSH
107777: LD_INT 32
107779: PUSH
107780: EMPTY
107781: LIST
107782: LIST
107783: PUSH
107784: LD_INT 34
107786: PUSH
107787: LD_INT 89
107789: PUSH
107790: EMPTY
107791: LIST
107792: LIST
107793: PUSH
107794: EMPTY
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: PUSH
107801: EMPTY
107802: LIST
107803: LIST
107804: LIST
107805: PPUSH
107806: CALL_OW 69
107810: ST_TO_ADDR
// if tmp then
107811: LD_VAR 0 4
107815: IFFALSE 107941
// begin for j in tmp do
107817: LD_ADDR_VAR 0 2
107821: PUSH
107822: LD_VAR 0 4
107826: PUSH
107827: FOR_IN
107828: IFFALSE 107939
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107830: LD_VAR 0 2
107834: PPUSH
107835: CALL_OW 262
107839: PUSH
107840: LD_INT 3
107842: EQUAL
107843: PUSH
107844: LD_VAR 0 2
107848: PPUSH
107849: CALL_OW 261
107853: PUSH
107854: LD_INT 20
107856: GREATER
107857: OR
107858: PUSH
107859: LD_VAR 0 2
107863: PPUSH
107864: CALL_OW 314
107868: NOT
107869: AND
107870: PUSH
107871: LD_VAR 0 2
107875: PPUSH
107876: CALL_OW 263
107880: PUSH
107881: LD_INT 1
107883: NONEQUAL
107884: PUSH
107885: LD_VAR 0 2
107889: PPUSH
107890: CALL_OW 311
107894: OR
107895: AND
107896: IFFALSE 107937
// begin ComCollect ( j , x , y ) ;
107898: LD_VAR 0 2
107902: PPUSH
107903: LD_VAR 0 6
107907: PPUSH
107908: LD_VAR 0 7
107912: PPUSH
107913: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107917: LD_VAR 0 2
107921: PPUSH
107922: LD_VAR 0 8
107926: PPUSH
107927: CALL_OW 172
// exit ;
107931: POP
107932: POP
107933: POP
107934: POP
107935: GO 107945
// end ;
107937: GO 107827
107939: POP
107940: POP
// end ; end ;
107941: GO 107316
107943: POP
107944: POP
// end ; end_of_file
107945: PPOPN 9
107947: END
// export function SOS_UnitDestroyed ( un ) ; begin
107948: LD_INT 0
107950: PPUSH
// ComRadiation ( un ) ;
107951: LD_VAR 0 1
107955: PPUSH
107956: CALL 108937 0 1
// end ;
107960: LD_VAR 0 2
107964: RET
// export function SOS_UnitKamikazed ( un ) ; begin
107965: LD_INT 0
107967: PPUSH
// ComRadiation ( un ) ;
107968: LD_VAR 0 1
107972: PPUSH
107973: CALL 108937 0 1
// end ;
107977: LD_VAR 0 2
107981: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107982: LD_INT 0
107984: PPUSH
// end ;
107985: LD_VAR 0 4
107989: RET
// export function SOS_Command ( cmd ) ; begin
107990: LD_INT 0
107992: PPUSH
// end ;
107993: LD_VAR 0 2
107997: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107998: LD_INT 0
108000: PPUSH
// end ;
108001: LD_VAR 0 6
108005: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , tag , driver , hex ; begin
108006: LD_INT 0
108008: PPUSH
108009: PPUSH
108010: PPUSH
108011: PPUSH
108012: PPUSH
// if not vehicle or not factory then
108013: LD_VAR 0 1
108017: NOT
108018: PUSH
108019: LD_VAR 0 2
108023: NOT
108024: OR
108025: IFFALSE 108029
// exit ;
108027: GO 108528
// if not factoryWaypoints then
108029: LD_EXP 154
108033: NOT
108034: IFFALSE 108038
// exit ;
108036: GO 108528
// for i := 1 to Count ( factoryWaypoints ) do
108038: LD_ADDR_VAR 0 4
108042: PUSH
108043: DOUBLE
108044: LD_INT 1
108046: DEC
108047: ST_TO_ADDR
108048: LD_EXP 154
108052: PPUSH
108053: CALL 51308 0 1
108057: PUSH
108058: FOR_TO
108059: IFFALSE 108526
// if factoryWaypoints [ i ] [ 2 ] = factory then
108061: LD_EXP 154
108065: PUSH
108066: LD_VAR 0 4
108070: ARRAY
108071: PUSH
108072: LD_INT 2
108074: ARRAY
108075: PUSH
108076: LD_VAR 0 2
108080: EQUAL
108081: IFFALSE 108524
// begin if GetControl ( vehicle ) = control_manual then
108083: LD_VAR 0 1
108087: PPUSH
108088: CALL_OW 263
108092: PUSH
108093: LD_INT 1
108095: EQUAL
108096: IFFALSE 108407
// begin driver := IsDrivenBy ( vehicle ) ;
108098: LD_ADDR_VAR 0 6
108102: PUSH
108103: LD_VAR 0 1
108107: PPUSH
108108: CALL_OW 311
108112: ST_TO_ADDR
// tag := GetTag ( driver ) ;
108113: LD_ADDR_VAR 0 5
108117: PUSH
108118: LD_VAR 0 6
108122: PPUSH
108123: CALL_OW 110
108127: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
108128: LD_VAR 0 5
108132: PUSH
108133: LD_INT 501
108135: EQUAL
108136: PUSH
108137: LD_VAR 0 1
108141: PPUSH
108142: CALL_OW 110
108146: PUSH
108147: LD_INT 501
108149: EQUAL
108150: OR
108151: IFFALSE 108157
// exit ;
108153: POP
108154: POP
108155: GO 108528
// if not HasTask ( driver ) then
108157: LD_VAR 0 6
108161: PPUSH
108162: CALL_OW 314
108166: NOT
108167: IFFALSE 108405
// begin SetTag ( driver , tDriver ) ;
108169: LD_VAR 0 6
108173: PPUSH
108174: LD_INT 501
108176: PPUSH
108177: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
108181: LD_VAR 0 1
108185: PPUSH
108186: LD_INT 501
108188: PPUSH
108189: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108193: LD_ADDR_VAR 0 7
108197: PUSH
108198: LD_EXP 154
108202: PUSH
108203: LD_VAR 0 4
108207: ARRAY
108208: PUSH
108209: LD_INT 3
108211: ARRAY
108212: PPUSH
108213: LD_EXP 154
108217: PUSH
108218: LD_VAR 0 4
108222: ARRAY
108223: PUSH
108224: LD_INT 4
108226: ARRAY
108227: PPUSH
108228: CALL_OW 428
108232: ST_TO_ADDR
// if hex then
108233: LD_VAR 0 7
108237: IFFALSE 108255
// ComMoveUnit ( driver , hex ) else
108239: LD_VAR 0 6
108243: PPUSH
108244: LD_VAR 0 7
108248: PPUSH
108249: CALL_OW 112
108253: GO 108294
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108255: LD_VAR 0 6
108259: PPUSH
108260: LD_EXP 154
108264: PUSH
108265: LD_VAR 0 4
108269: ARRAY
108270: PUSH
108271: LD_INT 3
108273: ARRAY
108274: PPUSH
108275: LD_EXP 154
108279: PUSH
108280: LD_VAR 0 4
108284: ARRAY
108285: PUSH
108286: LD_INT 4
108288: ARRAY
108289: PPUSH
108290: CALL_OW 111
// AddComExitVehicle ( driver ) ;
108294: LD_VAR 0 6
108298: PPUSH
108299: CALL_OW 181
// if Multiplayer then
108303: LD_OWVAR 4
108307: IFFALSE 108356
// begin repeat wait ( 10 ) ;
108309: LD_INT 10
108311: PPUSH
108312: CALL_OW 67
// until not IsInUnit ( driver ) ;
108316: LD_VAR 0 6
108320: PPUSH
108321: CALL_OW 310
108325: NOT
108326: IFFALSE 108309
// if not HasTask ( driver ) then
108328: LD_VAR 0 6
108332: PPUSH
108333: CALL_OW 314
108337: NOT
108338: IFFALSE 108354
// ComEnterUnit ( driver , factory ) ;
108340: LD_VAR 0 6
108344: PPUSH
108345: LD_VAR 0 2
108349: PPUSH
108350: CALL_OW 120
// end else
108354: GO 108370
// AddComEnterUnit ( driver , factory ) ;
108356: LD_VAR 0 6
108360: PPUSH
108361: LD_VAR 0 2
108365: PPUSH
108366: CALL_OW 180
// wait ( 0 0$1 ) ;
108370: LD_INT 35
108372: PPUSH
108373: CALL_OW 67
// SetTag ( driver , tag ) ;
108377: LD_VAR 0 6
108381: PPUSH
108382: LD_VAR 0 5
108386: PPUSH
108387: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
108391: LD_VAR 0 1
108395: PPUSH
108396: LD_INT 0
108398: PPUSH
108399: CALL_OW 109
// break ;
108403: GO 108526
// end ; end else
108405: GO 108524
// if GetControl ( vehicle ) = control_remote then
108407: LD_VAR 0 1
108411: PPUSH
108412: CALL_OW 263
108416: PUSH
108417: LD_INT 2
108419: EQUAL
108420: IFFALSE 108483
// begin wait ( 0 0$2 ) ;
108422: LD_INT 70
108424: PPUSH
108425: CALL_OW 67
// if Connect ( vehicle ) then
108429: LD_VAR 0 1
108433: PPUSH
108434: CALL 57514 0 1
108438: IFFALSE 108479
// AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108440: LD_VAR 0 1
108444: PPUSH
108445: LD_EXP 154
108449: PUSH
108450: LD_VAR 0 4
108454: ARRAY
108455: PUSH
108456: LD_INT 3
108458: ARRAY
108459: PPUSH
108460: LD_EXP 154
108464: PUSH
108465: LD_VAR 0 4
108469: ARRAY
108470: PUSH
108471: LD_INT 4
108473: ARRAY
108474: PPUSH
108475: CALL_OW 171
// break ;
108479: GO 108526
// end else
108481: GO 108524
// begin AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108483: LD_VAR 0 1
108487: PPUSH
108488: LD_EXP 154
108492: PUSH
108493: LD_VAR 0 4
108497: ARRAY
108498: PUSH
108499: LD_INT 3
108501: ARRAY
108502: PPUSH
108503: LD_EXP 154
108507: PUSH
108508: LD_VAR 0 4
108512: ARRAY
108513: PUSH
108514: LD_INT 4
108516: ARRAY
108517: PPUSH
108518: CALL_OW 171
// break ;
108522: GO 108526
// end ; end ;
108524: GO 108058
108526: POP
108527: POP
// end ;
108528: LD_VAR 0 3
108532: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108533: LD_INT 0
108535: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108536: LD_VAR 0 1
108540: PUSH
108541: LD_INT 250
108543: EQUAL
108544: PUSH
108545: LD_VAR 0 2
108549: PPUSH
108550: CALL_OW 264
108554: PUSH
108555: LD_INT 81
108557: EQUAL
108558: AND
108559: IFFALSE 108580
// MinerPlaceMine ( unit , x , y ) ;
108561: LD_VAR 0 2
108565: PPUSH
108566: LD_VAR 0 4
108570: PPUSH
108571: LD_VAR 0 5
108575: PPUSH
108576: CALL 111672 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108580: LD_VAR 0 1
108584: PUSH
108585: LD_INT 251
108587: EQUAL
108588: PUSH
108589: LD_VAR 0 2
108593: PPUSH
108594: CALL_OW 264
108598: PUSH
108599: LD_INT 81
108601: EQUAL
108602: AND
108603: IFFALSE 108624
// MinerDetonateMine ( unit , x , y ) ;
108605: LD_VAR 0 2
108609: PPUSH
108610: LD_VAR 0 4
108614: PPUSH
108615: LD_VAR 0 5
108619: PPUSH
108620: CALL 111947 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108624: LD_VAR 0 1
108628: PUSH
108629: LD_INT 252
108631: EQUAL
108632: PUSH
108633: LD_VAR 0 2
108637: PPUSH
108638: CALL_OW 264
108642: PUSH
108643: LD_INT 81
108645: EQUAL
108646: AND
108647: IFFALSE 108668
// MinerCreateMinefield ( unit , x , y ) ;
108649: LD_VAR 0 2
108653: PPUSH
108654: LD_VAR 0 4
108658: PPUSH
108659: LD_VAR 0 5
108663: PPUSH
108664: CALL 112364 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108668: LD_VAR 0 1
108672: PUSH
108673: LD_INT 253
108675: EQUAL
108676: PUSH
108677: LD_VAR 0 2
108681: PPUSH
108682: CALL_OW 257
108686: PUSH
108687: LD_INT 5
108689: EQUAL
108690: AND
108691: IFFALSE 108712
// ComBinocular ( unit , x , y ) ;
108693: LD_VAR 0 2
108697: PPUSH
108698: LD_VAR 0 4
108702: PPUSH
108703: LD_VAR 0 5
108707: PPUSH
108708: CALL 112733 0 3
// if selectedUnit then
108712: LD_VAR 0 3
108716: IFFALSE 108772
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108718: LD_VAR 0 1
108722: PUSH
108723: LD_INT 254
108725: EQUAL
108726: PUSH
108727: LD_VAR 0 2
108731: PPUSH
108732: CALL_OW 264
108736: PUSH
108737: LD_INT 99
108739: EQUAL
108740: AND
108741: PUSH
108742: LD_VAR 0 3
108746: PPUSH
108747: CALL_OW 263
108751: PUSH
108752: LD_INT 3
108754: EQUAL
108755: AND
108756: IFFALSE 108772
// HackDestroyVehicle ( unit , selectedUnit ) ;
108758: LD_VAR 0 2
108762: PPUSH
108763: LD_VAR 0 3
108767: PPUSH
108768: CALL 111036 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108772: LD_VAR 0 1
108776: PUSH
108777: LD_INT 255
108779: EQUAL
108780: PUSH
108781: LD_VAR 0 2
108785: PPUSH
108786: CALL_OW 264
108790: PUSH
108791: LD_INT 14
108793: PUSH
108794: LD_INT 53
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: IN
108801: AND
108802: PUSH
108803: LD_VAR 0 4
108807: PPUSH
108808: LD_VAR 0 5
108812: PPUSH
108813: CALL_OW 488
108817: AND
108818: IFFALSE 108842
// CutTreeXYR ( unit , x , y , 12 ) ;
108820: LD_VAR 0 2
108824: PPUSH
108825: LD_VAR 0 4
108829: PPUSH
108830: LD_VAR 0 5
108834: PPUSH
108835: LD_INT 12
108837: PPUSH
108838: CALL 109033 0 4
// if cmd = 256 then
108842: LD_VAR 0 1
108846: PUSH
108847: LD_INT 256
108849: EQUAL
108850: IFFALSE 108871
// SetFactoryWaypoint ( unit , x , y ) ;
108852: LD_VAR 0 2
108856: PPUSH
108857: LD_VAR 0 4
108861: PPUSH
108862: LD_VAR 0 5
108866: PPUSH
108867: CALL 106509 0 3
// if cmd = 257 then
108871: LD_VAR 0 1
108875: PUSH
108876: LD_INT 257
108878: EQUAL
108879: IFFALSE 108900
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108881: LD_VAR 0 2
108885: PPUSH
108886: LD_VAR 0 4
108890: PPUSH
108891: LD_VAR 0 5
108895: PPUSH
108896: CALL 106999 0 3
// if cmd = 258 then
108900: LD_VAR 0 1
108904: PUSH
108905: LD_INT 258
108907: EQUAL
108908: IFFALSE 108932
// BurnTreeXYR ( unit , x , y , 8 ) ;
108910: LD_VAR 0 2
108914: PPUSH
108915: LD_VAR 0 4
108919: PPUSH
108920: LD_VAR 0 5
108924: PPUSH
108925: LD_INT 8
108927: PPUSH
108928: CALL 109427 0 4
// end ;
108932: LD_VAR 0 6
108936: RET
// export function ComRadiation ( un ) ; var eff ; begin
108937: LD_INT 0
108939: PPUSH
108940: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
108941: LD_VAR 0 1
108945: PPUSH
108946: CALL_OW 264
108950: PUSH
108951: LD_INT 91
108953: NONEQUAL
108954: IFFALSE 108958
// exit ;
108956: GO 109028
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108958: LD_INT 68
108960: PPUSH
108961: LD_VAR 0 1
108965: PPUSH
108966: CALL_OW 255
108970: PPUSH
108971: CALL_OW 321
108975: PUSH
108976: LD_INT 2
108978: EQUAL
108979: IFFALSE 108991
// eff := 70 else
108981: LD_ADDR_VAR 0 3
108985: PUSH
108986: LD_INT 70
108988: ST_TO_ADDR
108989: GO 108999
// eff := 30 ;
108991: LD_ADDR_VAR 0 3
108995: PUSH
108996: LD_INT 30
108998: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108999: LD_VAR 0 1
109003: PPUSH
109004: CALL_OW 250
109008: PPUSH
109009: LD_VAR 0 1
109013: PPUSH
109014: CALL_OW 251
109018: PPUSH
109019: LD_VAR 0 3
109023: PPUSH
109024: CALL_OW 495
// end ;
109028: LD_VAR 0 2
109032: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109033: LD_INT 0
109035: PPUSH
109036: PPUSH
109037: PPUSH
109038: PPUSH
109039: PPUSH
109040: PPUSH
109041: PPUSH
109042: PPUSH
109043: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109044: LD_VAR 0 1
109048: PPUSH
109049: CALL_OW 302
109053: NOT
109054: PUSH
109055: LD_VAR 0 2
109059: PPUSH
109060: LD_VAR 0 3
109064: PPUSH
109065: CALL_OW 488
109069: NOT
109070: OR
109071: PUSH
109072: LD_VAR 0 4
109076: NOT
109077: OR
109078: IFFALSE 109082
// exit ;
109080: GO 109422
// list := [ ] ;
109082: LD_ADDR_VAR 0 13
109086: PUSH
109087: EMPTY
109088: ST_TO_ADDR
// if x - r < 0 then
109089: LD_VAR 0 2
109093: PUSH
109094: LD_VAR 0 4
109098: MINUS
109099: PUSH
109100: LD_INT 0
109102: LESS
109103: IFFALSE 109115
// min_x := 0 else
109105: LD_ADDR_VAR 0 7
109109: PUSH
109110: LD_INT 0
109112: ST_TO_ADDR
109113: GO 109131
// min_x := x - r ;
109115: LD_ADDR_VAR 0 7
109119: PUSH
109120: LD_VAR 0 2
109124: PUSH
109125: LD_VAR 0 4
109129: MINUS
109130: ST_TO_ADDR
// if y - r < 0 then
109131: LD_VAR 0 3
109135: PUSH
109136: LD_VAR 0 4
109140: MINUS
109141: PUSH
109142: LD_INT 0
109144: LESS
109145: IFFALSE 109157
// min_y := 0 else
109147: LD_ADDR_VAR 0 8
109151: PUSH
109152: LD_INT 0
109154: ST_TO_ADDR
109155: GO 109173
// min_y := y - r ;
109157: LD_ADDR_VAR 0 8
109161: PUSH
109162: LD_VAR 0 3
109166: PUSH
109167: LD_VAR 0 4
109171: MINUS
109172: ST_TO_ADDR
// max_x := x + r ;
109173: LD_ADDR_VAR 0 9
109177: PUSH
109178: LD_VAR 0 2
109182: PUSH
109183: LD_VAR 0 4
109187: PLUS
109188: ST_TO_ADDR
// max_y := y + r ;
109189: LD_ADDR_VAR 0 10
109193: PUSH
109194: LD_VAR 0 3
109198: PUSH
109199: LD_VAR 0 4
109203: PLUS
109204: ST_TO_ADDR
// for _x = min_x to max_x do
109205: LD_ADDR_VAR 0 11
109209: PUSH
109210: DOUBLE
109211: LD_VAR 0 7
109215: DEC
109216: ST_TO_ADDR
109217: LD_VAR 0 9
109221: PUSH
109222: FOR_TO
109223: IFFALSE 109340
// for _y = min_y to max_y do
109225: LD_ADDR_VAR 0 12
109229: PUSH
109230: DOUBLE
109231: LD_VAR 0 8
109235: DEC
109236: ST_TO_ADDR
109237: LD_VAR 0 10
109241: PUSH
109242: FOR_TO
109243: IFFALSE 109336
// begin if not ValidHex ( _x , _y ) then
109245: LD_VAR 0 11
109249: PPUSH
109250: LD_VAR 0 12
109254: PPUSH
109255: CALL_OW 488
109259: NOT
109260: IFFALSE 109264
// continue ;
109262: GO 109242
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109264: LD_VAR 0 11
109268: PPUSH
109269: LD_VAR 0 12
109273: PPUSH
109274: CALL_OW 351
109278: PUSH
109279: LD_VAR 0 11
109283: PPUSH
109284: LD_VAR 0 12
109288: PPUSH
109289: CALL_OW 554
109293: AND
109294: IFFALSE 109334
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109296: LD_ADDR_VAR 0 13
109300: PUSH
109301: LD_VAR 0 13
109305: PPUSH
109306: LD_VAR 0 13
109310: PUSH
109311: LD_INT 1
109313: PLUS
109314: PPUSH
109315: LD_VAR 0 11
109319: PUSH
109320: LD_VAR 0 12
109324: PUSH
109325: EMPTY
109326: LIST
109327: LIST
109328: PPUSH
109329: CALL_OW 2
109333: ST_TO_ADDR
// end ;
109334: GO 109242
109336: POP
109337: POP
109338: GO 109222
109340: POP
109341: POP
// if not list then
109342: LD_VAR 0 13
109346: NOT
109347: IFFALSE 109351
// exit ;
109349: GO 109422
// for i in list do
109351: LD_ADDR_VAR 0 6
109355: PUSH
109356: LD_VAR 0 13
109360: PUSH
109361: FOR_IN
109362: IFFALSE 109420
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109364: LD_VAR 0 1
109368: PPUSH
109369: LD_STRING M
109371: PUSH
109372: LD_VAR 0 6
109376: PUSH
109377: LD_INT 1
109379: ARRAY
109380: PUSH
109381: LD_VAR 0 6
109385: PUSH
109386: LD_INT 2
109388: ARRAY
109389: PUSH
109390: LD_INT 0
109392: PUSH
109393: LD_INT 0
109395: PUSH
109396: LD_INT 0
109398: PUSH
109399: LD_INT 0
109401: PUSH
109402: EMPTY
109403: LIST
109404: LIST
109405: LIST
109406: LIST
109407: LIST
109408: LIST
109409: LIST
109410: PUSH
109411: EMPTY
109412: LIST
109413: PPUSH
109414: CALL_OW 447
109418: GO 109361
109420: POP
109421: POP
// end ;
109422: LD_VAR 0 5
109426: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
109427: LD_INT 0
109429: PPUSH
109430: PPUSH
109431: PPUSH
109432: PPUSH
109433: PPUSH
109434: PPUSH
109435: PPUSH
109436: PPUSH
109437: PPUSH
109438: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109439: LD_VAR 0 1
109443: PPUSH
109444: CALL_OW 302
109448: NOT
109449: PUSH
109450: LD_VAR 0 2
109454: PPUSH
109455: LD_VAR 0 3
109459: PPUSH
109460: CALL_OW 488
109464: NOT
109465: OR
109466: PUSH
109467: LD_VAR 0 4
109471: NOT
109472: OR
109473: IFFALSE 109477
// exit ;
109475: GO 109990
// list := [ ] ;
109477: LD_ADDR_VAR 0 13
109481: PUSH
109482: EMPTY
109483: ST_TO_ADDR
// if x - r < 0 then
109484: LD_VAR 0 2
109488: PUSH
109489: LD_VAR 0 4
109493: MINUS
109494: PUSH
109495: LD_INT 0
109497: LESS
109498: IFFALSE 109510
// min_x := 0 else
109500: LD_ADDR_VAR 0 7
109504: PUSH
109505: LD_INT 0
109507: ST_TO_ADDR
109508: GO 109526
// min_x := x - r ;
109510: LD_ADDR_VAR 0 7
109514: PUSH
109515: LD_VAR 0 2
109519: PUSH
109520: LD_VAR 0 4
109524: MINUS
109525: ST_TO_ADDR
// if y - r < 0 then
109526: LD_VAR 0 3
109530: PUSH
109531: LD_VAR 0 4
109535: MINUS
109536: PUSH
109537: LD_INT 0
109539: LESS
109540: IFFALSE 109552
// min_y := 0 else
109542: LD_ADDR_VAR 0 8
109546: PUSH
109547: LD_INT 0
109549: ST_TO_ADDR
109550: GO 109568
// min_y := y - r ;
109552: LD_ADDR_VAR 0 8
109556: PUSH
109557: LD_VAR 0 3
109561: PUSH
109562: LD_VAR 0 4
109566: MINUS
109567: ST_TO_ADDR
// max_x := x + r ;
109568: LD_ADDR_VAR 0 9
109572: PUSH
109573: LD_VAR 0 2
109577: PUSH
109578: LD_VAR 0 4
109582: PLUS
109583: ST_TO_ADDR
// max_y := y + r ;
109584: LD_ADDR_VAR 0 10
109588: PUSH
109589: LD_VAR 0 3
109593: PUSH
109594: LD_VAR 0 4
109598: PLUS
109599: ST_TO_ADDR
// for _x = min_x to max_x do
109600: LD_ADDR_VAR 0 11
109604: PUSH
109605: DOUBLE
109606: LD_VAR 0 7
109610: DEC
109611: ST_TO_ADDR
109612: LD_VAR 0 9
109616: PUSH
109617: FOR_TO
109618: IFFALSE 109735
// for _y = min_y to max_y do
109620: LD_ADDR_VAR 0 12
109624: PUSH
109625: DOUBLE
109626: LD_VAR 0 8
109630: DEC
109631: ST_TO_ADDR
109632: LD_VAR 0 10
109636: PUSH
109637: FOR_TO
109638: IFFALSE 109731
// begin if not ValidHex ( _x , _y ) then
109640: LD_VAR 0 11
109644: PPUSH
109645: LD_VAR 0 12
109649: PPUSH
109650: CALL_OW 488
109654: NOT
109655: IFFALSE 109659
// continue ;
109657: GO 109637
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109659: LD_VAR 0 11
109663: PPUSH
109664: LD_VAR 0 12
109668: PPUSH
109669: CALL_OW 351
109673: PUSH
109674: LD_VAR 0 11
109678: PPUSH
109679: LD_VAR 0 12
109683: PPUSH
109684: CALL_OW 554
109688: AND
109689: IFFALSE 109729
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109691: LD_ADDR_VAR 0 13
109695: PUSH
109696: LD_VAR 0 13
109700: PPUSH
109701: LD_VAR 0 13
109705: PUSH
109706: LD_INT 1
109708: PLUS
109709: PPUSH
109710: LD_VAR 0 11
109714: PUSH
109715: LD_VAR 0 12
109719: PUSH
109720: EMPTY
109721: LIST
109722: LIST
109723: PPUSH
109724: CALL_OW 2
109728: ST_TO_ADDR
// end ;
109729: GO 109637
109731: POP
109732: POP
109733: GO 109617
109735: POP
109736: POP
// if not list then
109737: LD_VAR 0 13
109741: NOT
109742: IFFALSE 109746
// exit ;
109744: GO 109990
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109746: LD_ADDR_VAR 0 13
109750: PUSH
109751: LD_VAR 0 1
109755: PPUSH
109756: LD_VAR 0 13
109760: PPUSH
109761: LD_INT 1
109763: PPUSH
109764: LD_INT 1
109766: PPUSH
109767: CALL 54656 0 4
109771: ST_TO_ADDR
// ComStop ( flame ) ;
109772: LD_VAR 0 1
109776: PPUSH
109777: CALL_OW 141
// for i in list do
109781: LD_ADDR_VAR 0 6
109785: PUSH
109786: LD_VAR 0 13
109790: PUSH
109791: FOR_IN
109792: IFFALSE 109823
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109794: LD_VAR 0 1
109798: PPUSH
109799: LD_VAR 0 6
109803: PUSH
109804: LD_INT 1
109806: ARRAY
109807: PPUSH
109808: LD_VAR 0 6
109812: PUSH
109813: LD_INT 2
109815: ARRAY
109816: PPUSH
109817: CALL_OW 176
109821: GO 109791
109823: POP
109824: POP
// repeat wait ( 0 0$1 ) ;
109825: LD_INT 35
109827: PPUSH
109828: CALL_OW 67
// task := GetTaskList ( flame ) ;
109832: LD_ADDR_VAR 0 14
109836: PUSH
109837: LD_VAR 0 1
109841: PPUSH
109842: CALL_OW 437
109846: ST_TO_ADDR
// if not task then
109847: LD_VAR 0 14
109851: NOT
109852: IFFALSE 109856
// exit ;
109854: GO 109990
// if task [ 1 ] [ 1 ] <> | then
109856: LD_VAR 0 14
109860: PUSH
109861: LD_INT 1
109863: ARRAY
109864: PUSH
109865: LD_INT 1
109867: ARRAY
109868: PUSH
109869: LD_STRING |
109871: NONEQUAL
109872: IFFALSE 109876
// exit ;
109874: GO 109990
// _x := task [ 1 ] [ 2 ] ;
109876: LD_ADDR_VAR 0 11
109880: PUSH
109881: LD_VAR 0 14
109885: PUSH
109886: LD_INT 1
109888: ARRAY
109889: PUSH
109890: LD_INT 2
109892: ARRAY
109893: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
109894: LD_ADDR_VAR 0 12
109898: PUSH
109899: LD_VAR 0 14
109903: PUSH
109904: LD_INT 1
109906: ARRAY
109907: PUSH
109908: LD_INT 3
109910: ARRAY
109911: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
109912: LD_VAR 0 11
109916: PPUSH
109917: LD_VAR 0 12
109921: PPUSH
109922: CALL_OW 351
109926: NOT
109927: PUSH
109928: LD_VAR 0 11
109932: PPUSH
109933: LD_VAR 0 12
109937: PPUSH
109938: CALL_OW 554
109942: NOT
109943: OR
109944: IFFALSE 109978
// begin task := Delete ( task , 1 ) ;
109946: LD_ADDR_VAR 0 14
109950: PUSH
109951: LD_VAR 0 14
109955: PPUSH
109956: LD_INT 1
109958: PPUSH
109959: CALL_OW 3
109963: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
109964: LD_VAR 0 1
109968: PPUSH
109969: LD_VAR 0 14
109973: PPUSH
109974: CALL_OW 446
// end ; until not HasTask ( flame ) ;
109978: LD_VAR 0 1
109982: PPUSH
109983: CALL_OW 314
109987: NOT
109988: IFFALSE 109825
// end ;
109990: LD_VAR 0 5
109994: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109995: LD_EXP 157
109999: NOT
110000: IFFALSE 110050
110002: GO 110004
110004: DISABLE
// begin initHack := true ;
110005: LD_ADDR_EXP 157
110009: PUSH
110010: LD_INT 1
110012: ST_TO_ADDR
// hackTanks := [ ] ;
110013: LD_ADDR_EXP 158
110017: PUSH
110018: EMPTY
110019: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110020: LD_ADDR_EXP 159
110024: PUSH
110025: EMPTY
110026: ST_TO_ADDR
// hackLimit := 3 ;
110027: LD_ADDR_EXP 160
110031: PUSH
110032: LD_INT 3
110034: ST_TO_ADDR
// hackDist := 12 ;
110035: LD_ADDR_EXP 161
110039: PUSH
110040: LD_INT 12
110042: ST_TO_ADDR
// hackCounter := [ ] ;
110043: LD_ADDR_EXP 162
110047: PUSH
110048: EMPTY
110049: ST_TO_ADDR
// end ;
110050: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110051: LD_EXP 157
110055: PUSH
110056: LD_INT 34
110058: PUSH
110059: LD_INT 99
110061: PUSH
110062: EMPTY
110063: LIST
110064: LIST
110065: PPUSH
110066: CALL_OW 69
110070: AND
110071: IFFALSE 110324
110073: GO 110075
110075: DISABLE
110076: LD_INT 0
110078: PPUSH
110079: PPUSH
// begin enable ;
110080: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110081: LD_ADDR_VAR 0 1
110085: PUSH
110086: LD_INT 34
110088: PUSH
110089: LD_INT 99
110091: PUSH
110092: EMPTY
110093: LIST
110094: LIST
110095: PPUSH
110096: CALL_OW 69
110100: PUSH
110101: FOR_IN
110102: IFFALSE 110322
// begin if not i in hackTanks then
110104: LD_VAR 0 1
110108: PUSH
110109: LD_EXP 158
110113: IN
110114: NOT
110115: IFFALSE 110198
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110117: LD_ADDR_EXP 158
110121: PUSH
110122: LD_EXP 158
110126: PPUSH
110127: LD_EXP 158
110131: PUSH
110132: LD_INT 1
110134: PLUS
110135: PPUSH
110136: LD_VAR 0 1
110140: PPUSH
110141: CALL_OW 1
110145: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110146: LD_ADDR_EXP 159
110150: PUSH
110151: LD_EXP 159
110155: PPUSH
110156: LD_EXP 159
110160: PUSH
110161: LD_INT 1
110163: PLUS
110164: PPUSH
110165: EMPTY
110166: PPUSH
110167: CALL_OW 1
110171: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110172: LD_ADDR_EXP 162
110176: PUSH
110177: LD_EXP 162
110181: PPUSH
110182: LD_EXP 162
110186: PUSH
110187: LD_INT 1
110189: PLUS
110190: PPUSH
110191: EMPTY
110192: PPUSH
110193: CALL_OW 1
110197: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110198: LD_VAR 0 1
110202: PPUSH
110203: CALL_OW 302
110207: NOT
110208: IFFALSE 110221
// begin HackUnlinkAll ( i ) ;
110210: LD_VAR 0 1
110214: PPUSH
110215: CALL 110327 0 1
// continue ;
110219: GO 110101
// end ; HackCheckCapturedStatus ( i ) ;
110221: LD_VAR 0 1
110225: PPUSH
110226: CALL 110770 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110230: LD_ADDR_VAR 0 2
110234: PUSH
110235: LD_INT 81
110237: PUSH
110238: LD_VAR 0 1
110242: PPUSH
110243: CALL_OW 255
110247: PUSH
110248: EMPTY
110249: LIST
110250: LIST
110251: PUSH
110252: LD_INT 33
110254: PUSH
110255: LD_INT 3
110257: PUSH
110258: EMPTY
110259: LIST
110260: LIST
110261: PUSH
110262: LD_INT 91
110264: PUSH
110265: LD_VAR 0 1
110269: PUSH
110270: LD_EXP 161
110274: PUSH
110275: EMPTY
110276: LIST
110277: LIST
110278: LIST
110279: PUSH
110280: LD_INT 50
110282: PUSH
110283: EMPTY
110284: LIST
110285: PUSH
110286: EMPTY
110287: LIST
110288: LIST
110289: LIST
110290: LIST
110291: PPUSH
110292: CALL_OW 69
110296: ST_TO_ADDR
// if not tmp then
110297: LD_VAR 0 2
110301: NOT
110302: IFFALSE 110306
// continue ;
110304: GO 110101
// HackLink ( i , tmp ) ;
110306: LD_VAR 0 1
110310: PPUSH
110311: LD_VAR 0 2
110315: PPUSH
110316: CALL 110463 0 2
// end ;
110320: GO 110101
110322: POP
110323: POP
// end ;
110324: PPOPN 2
110326: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110327: LD_INT 0
110329: PPUSH
110330: PPUSH
110331: PPUSH
// if not hack in hackTanks then
110332: LD_VAR 0 1
110336: PUSH
110337: LD_EXP 158
110341: IN
110342: NOT
110343: IFFALSE 110347
// exit ;
110345: GO 110458
// index := GetElementIndex ( hackTanks , hack ) ;
110347: LD_ADDR_VAR 0 4
110351: PUSH
110352: LD_EXP 158
110356: PPUSH
110357: LD_VAR 0 1
110361: PPUSH
110362: CALL 53953 0 2
110366: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110367: LD_EXP 159
110371: PUSH
110372: LD_VAR 0 4
110376: ARRAY
110377: IFFALSE 110458
// begin for i in hackTanksCaptured [ index ] do
110379: LD_ADDR_VAR 0 3
110383: PUSH
110384: LD_EXP 159
110388: PUSH
110389: LD_VAR 0 4
110393: ARRAY
110394: PUSH
110395: FOR_IN
110396: IFFALSE 110422
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110398: LD_VAR 0 3
110402: PUSH
110403: LD_INT 1
110405: ARRAY
110406: PPUSH
110407: LD_VAR 0 3
110411: PUSH
110412: LD_INT 2
110414: ARRAY
110415: PPUSH
110416: CALL_OW 235
110420: GO 110395
110422: POP
110423: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110424: LD_ADDR_EXP 159
110428: PUSH
110429: LD_EXP 159
110433: PPUSH
110434: LD_VAR 0 4
110438: PPUSH
110439: EMPTY
110440: PPUSH
110441: CALL_OW 1
110445: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110446: LD_VAR 0 1
110450: PPUSH
110451: LD_INT 0
110453: PPUSH
110454: CALL_OW 505
// end ; end ;
110458: LD_VAR 0 2
110462: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110463: LD_INT 0
110465: PPUSH
110466: PPUSH
110467: PPUSH
// if not hack in hackTanks or not vehicles then
110468: LD_VAR 0 1
110472: PUSH
110473: LD_EXP 158
110477: IN
110478: NOT
110479: PUSH
110480: LD_VAR 0 2
110484: NOT
110485: OR
110486: IFFALSE 110490
// exit ;
110488: GO 110765
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110490: LD_ADDR_VAR 0 2
110494: PUSH
110495: LD_VAR 0 1
110499: PPUSH
110500: LD_VAR 0 2
110504: PPUSH
110505: LD_INT 1
110507: PPUSH
110508: LD_INT 1
110510: PPUSH
110511: CALL 54603 0 4
110515: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110516: LD_ADDR_VAR 0 5
110520: PUSH
110521: LD_EXP 158
110525: PPUSH
110526: LD_VAR 0 1
110530: PPUSH
110531: CALL 53953 0 2
110535: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110536: LD_EXP 159
110540: PUSH
110541: LD_VAR 0 5
110545: ARRAY
110546: PUSH
110547: LD_EXP 160
110551: LESS
110552: IFFALSE 110741
// begin for i := 1 to vehicles do
110554: LD_ADDR_VAR 0 4
110558: PUSH
110559: DOUBLE
110560: LD_INT 1
110562: DEC
110563: ST_TO_ADDR
110564: LD_VAR 0 2
110568: PUSH
110569: FOR_TO
110570: IFFALSE 110739
// begin if hackTanksCaptured [ index ] = hackLimit then
110572: LD_EXP 159
110576: PUSH
110577: LD_VAR 0 5
110581: ARRAY
110582: PUSH
110583: LD_EXP 160
110587: EQUAL
110588: IFFALSE 110592
// break ;
110590: GO 110739
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110592: LD_ADDR_EXP 162
110596: PUSH
110597: LD_EXP 162
110601: PPUSH
110602: LD_VAR 0 5
110606: PPUSH
110607: LD_EXP 162
110611: PUSH
110612: LD_VAR 0 5
110616: ARRAY
110617: PUSH
110618: LD_INT 1
110620: PLUS
110621: PPUSH
110622: CALL_OW 1
110626: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110627: LD_ADDR_EXP 159
110631: PUSH
110632: LD_EXP 159
110636: PPUSH
110637: LD_VAR 0 5
110641: PUSH
110642: LD_EXP 159
110646: PUSH
110647: LD_VAR 0 5
110651: ARRAY
110652: PUSH
110653: LD_INT 1
110655: PLUS
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: PPUSH
110661: LD_VAR 0 2
110665: PUSH
110666: LD_VAR 0 4
110670: ARRAY
110671: PUSH
110672: LD_VAR 0 2
110676: PUSH
110677: LD_VAR 0 4
110681: ARRAY
110682: PPUSH
110683: CALL_OW 255
110687: PUSH
110688: EMPTY
110689: LIST
110690: LIST
110691: PPUSH
110692: CALL 54168 0 3
110696: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110697: LD_VAR 0 2
110701: PUSH
110702: LD_VAR 0 4
110706: ARRAY
110707: PPUSH
110708: LD_VAR 0 1
110712: PPUSH
110713: CALL_OW 255
110717: PPUSH
110718: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110722: LD_VAR 0 2
110726: PUSH
110727: LD_VAR 0 4
110731: ARRAY
110732: PPUSH
110733: CALL_OW 141
// end ;
110737: GO 110569
110739: POP
110740: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110741: LD_VAR 0 1
110745: PPUSH
110746: LD_EXP 159
110750: PUSH
110751: LD_VAR 0 5
110755: ARRAY
110756: PUSH
110757: LD_INT 0
110759: PLUS
110760: PPUSH
110761: CALL_OW 505
// end ;
110765: LD_VAR 0 3
110769: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110770: LD_INT 0
110772: PPUSH
110773: PPUSH
110774: PPUSH
110775: PPUSH
// if not hack in hackTanks then
110776: LD_VAR 0 1
110780: PUSH
110781: LD_EXP 158
110785: IN
110786: NOT
110787: IFFALSE 110791
// exit ;
110789: GO 111031
// index := GetElementIndex ( hackTanks , hack ) ;
110791: LD_ADDR_VAR 0 4
110795: PUSH
110796: LD_EXP 158
110800: PPUSH
110801: LD_VAR 0 1
110805: PPUSH
110806: CALL 53953 0 2
110810: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110811: LD_ADDR_VAR 0 3
110815: PUSH
110816: DOUBLE
110817: LD_EXP 159
110821: PUSH
110822: LD_VAR 0 4
110826: ARRAY
110827: INC
110828: ST_TO_ADDR
110829: LD_INT 1
110831: PUSH
110832: FOR_DOWNTO
110833: IFFALSE 111005
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110835: LD_ADDR_VAR 0 5
110839: PUSH
110840: LD_EXP 159
110844: PUSH
110845: LD_VAR 0 4
110849: ARRAY
110850: PUSH
110851: LD_VAR 0 3
110855: ARRAY
110856: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110857: LD_VAR 0 5
110861: PUSH
110862: LD_INT 1
110864: ARRAY
110865: PPUSH
110866: CALL_OW 302
110870: NOT
110871: PUSH
110872: LD_VAR 0 5
110876: PUSH
110877: LD_INT 1
110879: ARRAY
110880: PPUSH
110881: CALL_OW 255
110885: PUSH
110886: LD_VAR 0 1
110890: PPUSH
110891: CALL_OW 255
110895: NONEQUAL
110896: OR
110897: IFFALSE 111003
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110899: LD_VAR 0 5
110903: PUSH
110904: LD_INT 1
110906: ARRAY
110907: PPUSH
110908: CALL_OW 305
110912: PUSH
110913: LD_VAR 0 5
110917: PUSH
110918: LD_INT 1
110920: ARRAY
110921: PPUSH
110922: CALL_OW 255
110926: PUSH
110927: LD_VAR 0 1
110931: PPUSH
110932: CALL_OW 255
110936: EQUAL
110937: AND
110938: IFFALSE 110962
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110940: LD_VAR 0 5
110944: PUSH
110945: LD_INT 1
110947: ARRAY
110948: PPUSH
110949: LD_VAR 0 5
110953: PUSH
110954: LD_INT 2
110956: ARRAY
110957: PPUSH
110958: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110962: LD_ADDR_EXP 159
110966: PUSH
110967: LD_EXP 159
110971: PPUSH
110972: LD_VAR 0 4
110976: PPUSH
110977: LD_EXP 159
110981: PUSH
110982: LD_VAR 0 4
110986: ARRAY
110987: PPUSH
110988: LD_VAR 0 3
110992: PPUSH
110993: CALL_OW 3
110997: PPUSH
110998: CALL_OW 1
111002: ST_TO_ADDR
// end ; end ;
111003: GO 110832
111005: POP
111006: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111007: LD_VAR 0 1
111011: PPUSH
111012: LD_EXP 159
111016: PUSH
111017: LD_VAR 0 4
111021: ARRAY
111022: PUSH
111023: LD_INT 0
111025: PLUS
111026: PPUSH
111027: CALL_OW 505
// end ;
111031: LD_VAR 0 2
111035: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111036: LD_INT 0
111038: PPUSH
111039: PPUSH
111040: PPUSH
111041: PPUSH
// if not hack in hackTanks then
111042: LD_VAR 0 1
111046: PUSH
111047: LD_EXP 158
111051: IN
111052: NOT
111053: IFFALSE 111057
// exit ;
111055: GO 111142
// index := GetElementIndex ( hackTanks , hack ) ;
111057: LD_ADDR_VAR 0 5
111061: PUSH
111062: LD_EXP 158
111066: PPUSH
111067: LD_VAR 0 1
111071: PPUSH
111072: CALL 53953 0 2
111076: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111077: LD_ADDR_VAR 0 4
111081: PUSH
111082: DOUBLE
111083: LD_INT 1
111085: DEC
111086: ST_TO_ADDR
111087: LD_EXP 159
111091: PUSH
111092: LD_VAR 0 5
111096: ARRAY
111097: PUSH
111098: FOR_TO
111099: IFFALSE 111140
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111101: LD_EXP 159
111105: PUSH
111106: LD_VAR 0 5
111110: ARRAY
111111: PUSH
111112: LD_VAR 0 4
111116: ARRAY
111117: PUSH
111118: LD_INT 1
111120: ARRAY
111121: PUSH
111122: LD_VAR 0 2
111126: EQUAL
111127: IFFALSE 111138
// KillUnit ( vehicle ) ;
111129: LD_VAR 0 2
111133: PPUSH
111134: CALL_OW 66
111138: GO 111098
111140: POP
111141: POP
// end ;
111142: LD_VAR 0 3
111146: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111147: LD_EXP 163
111151: NOT
111152: IFFALSE 111187
111154: GO 111156
111156: DISABLE
// begin initMiner := true ;
111157: LD_ADDR_EXP 163
111161: PUSH
111162: LD_INT 1
111164: ST_TO_ADDR
// minersList := [ ] ;
111165: LD_ADDR_EXP 164
111169: PUSH
111170: EMPTY
111171: ST_TO_ADDR
// minerMinesList := [ ] ;
111172: LD_ADDR_EXP 165
111176: PUSH
111177: EMPTY
111178: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111179: LD_ADDR_EXP 166
111183: PUSH
111184: LD_INT 5
111186: ST_TO_ADDR
// end ;
111187: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111188: LD_EXP 163
111192: PUSH
111193: LD_INT 34
111195: PUSH
111196: LD_INT 81
111198: PUSH
111199: EMPTY
111200: LIST
111201: LIST
111202: PPUSH
111203: CALL_OW 69
111207: AND
111208: IFFALSE 111669
111210: GO 111212
111212: DISABLE
111213: LD_INT 0
111215: PPUSH
111216: PPUSH
111217: PPUSH
111218: PPUSH
// begin enable ;
111219: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111220: LD_ADDR_VAR 0 1
111224: PUSH
111225: LD_INT 34
111227: PUSH
111228: LD_INT 81
111230: PUSH
111231: EMPTY
111232: LIST
111233: LIST
111234: PPUSH
111235: CALL_OW 69
111239: PUSH
111240: FOR_IN
111241: IFFALSE 111313
// begin if not i in minersList then
111243: LD_VAR 0 1
111247: PUSH
111248: LD_EXP 164
111252: IN
111253: NOT
111254: IFFALSE 111311
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111256: LD_ADDR_EXP 164
111260: PUSH
111261: LD_EXP 164
111265: PPUSH
111266: LD_EXP 164
111270: PUSH
111271: LD_INT 1
111273: PLUS
111274: PPUSH
111275: LD_VAR 0 1
111279: PPUSH
111280: CALL_OW 1
111284: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111285: LD_ADDR_EXP 165
111289: PUSH
111290: LD_EXP 165
111294: PPUSH
111295: LD_EXP 165
111299: PUSH
111300: LD_INT 1
111302: PLUS
111303: PPUSH
111304: EMPTY
111305: PPUSH
111306: CALL_OW 1
111310: ST_TO_ADDR
// end end ;
111311: GO 111240
111313: POP
111314: POP
// for i := minerMinesList downto 1 do
111315: LD_ADDR_VAR 0 1
111319: PUSH
111320: DOUBLE
111321: LD_EXP 165
111325: INC
111326: ST_TO_ADDR
111327: LD_INT 1
111329: PUSH
111330: FOR_DOWNTO
111331: IFFALSE 111667
// begin if IsLive ( minersList [ i ] ) then
111333: LD_EXP 164
111337: PUSH
111338: LD_VAR 0 1
111342: ARRAY
111343: PPUSH
111344: CALL_OW 300
111348: IFFALSE 111376
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111350: LD_EXP 164
111354: PUSH
111355: LD_VAR 0 1
111359: ARRAY
111360: PPUSH
111361: LD_EXP 165
111365: PUSH
111366: LD_VAR 0 1
111370: ARRAY
111371: PPUSH
111372: CALL_OW 505
// if not minerMinesList [ i ] then
111376: LD_EXP 165
111380: PUSH
111381: LD_VAR 0 1
111385: ARRAY
111386: NOT
111387: IFFALSE 111391
// continue ;
111389: GO 111330
// for j := minerMinesList [ i ] downto 1 do
111391: LD_ADDR_VAR 0 2
111395: PUSH
111396: DOUBLE
111397: LD_EXP 165
111401: PUSH
111402: LD_VAR 0 1
111406: ARRAY
111407: INC
111408: ST_TO_ADDR
111409: LD_INT 1
111411: PUSH
111412: FOR_DOWNTO
111413: IFFALSE 111663
// begin side := GetSide ( minersList [ i ] ) ;
111415: LD_ADDR_VAR 0 3
111419: PUSH
111420: LD_EXP 164
111424: PUSH
111425: LD_VAR 0 1
111429: ARRAY
111430: PPUSH
111431: CALL_OW 255
111435: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111436: LD_ADDR_VAR 0 4
111440: PUSH
111441: LD_EXP 165
111445: PUSH
111446: LD_VAR 0 1
111450: ARRAY
111451: PUSH
111452: LD_VAR 0 2
111456: ARRAY
111457: PUSH
111458: LD_INT 1
111460: ARRAY
111461: PPUSH
111462: LD_EXP 165
111466: PUSH
111467: LD_VAR 0 1
111471: ARRAY
111472: PUSH
111473: LD_VAR 0 2
111477: ARRAY
111478: PUSH
111479: LD_INT 2
111481: ARRAY
111482: PPUSH
111483: CALL_OW 428
111487: ST_TO_ADDR
// if not tmp then
111488: LD_VAR 0 4
111492: NOT
111493: IFFALSE 111497
// continue ;
111495: GO 111412
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111497: LD_VAR 0 4
111501: PUSH
111502: LD_INT 81
111504: PUSH
111505: LD_VAR 0 3
111509: PUSH
111510: EMPTY
111511: LIST
111512: LIST
111513: PPUSH
111514: CALL_OW 69
111518: IN
111519: PUSH
111520: LD_EXP 165
111524: PUSH
111525: LD_VAR 0 1
111529: ARRAY
111530: PUSH
111531: LD_VAR 0 2
111535: ARRAY
111536: PUSH
111537: LD_INT 1
111539: ARRAY
111540: PPUSH
111541: LD_EXP 165
111545: PUSH
111546: LD_VAR 0 1
111550: ARRAY
111551: PUSH
111552: LD_VAR 0 2
111556: ARRAY
111557: PUSH
111558: LD_INT 2
111560: ARRAY
111561: PPUSH
111562: CALL_OW 458
111566: AND
111567: IFFALSE 111661
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111569: LD_EXP 165
111573: PUSH
111574: LD_VAR 0 1
111578: ARRAY
111579: PUSH
111580: LD_VAR 0 2
111584: ARRAY
111585: PUSH
111586: LD_INT 1
111588: ARRAY
111589: PPUSH
111590: LD_EXP 165
111594: PUSH
111595: LD_VAR 0 1
111599: ARRAY
111600: PUSH
111601: LD_VAR 0 2
111605: ARRAY
111606: PUSH
111607: LD_INT 2
111609: ARRAY
111610: PPUSH
111611: LD_VAR 0 3
111615: PPUSH
111616: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111620: LD_ADDR_EXP 165
111624: PUSH
111625: LD_EXP 165
111629: PPUSH
111630: LD_VAR 0 1
111634: PPUSH
111635: LD_EXP 165
111639: PUSH
111640: LD_VAR 0 1
111644: ARRAY
111645: PPUSH
111646: LD_VAR 0 2
111650: PPUSH
111651: CALL_OW 3
111655: PPUSH
111656: CALL_OW 1
111660: ST_TO_ADDR
// end ; end ;
111661: GO 111412
111663: POP
111664: POP
// end ;
111665: GO 111330
111667: POP
111668: POP
// end ;
111669: PPOPN 4
111671: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111672: LD_INT 0
111674: PPUSH
111675: PPUSH
// result := false ;
111676: LD_ADDR_VAR 0 4
111680: PUSH
111681: LD_INT 0
111683: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111684: LD_VAR 0 1
111688: PPUSH
111689: CALL_OW 264
111693: PUSH
111694: LD_INT 81
111696: EQUAL
111697: NOT
111698: IFFALSE 111702
// exit ;
111700: GO 111942
// index := GetElementIndex ( minersList , unit ) ;
111702: LD_ADDR_VAR 0 5
111706: PUSH
111707: LD_EXP 164
111711: PPUSH
111712: LD_VAR 0 1
111716: PPUSH
111717: CALL 53953 0 2
111721: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111722: LD_EXP 165
111726: PUSH
111727: LD_VAR 0 5
111731: ARRAY
111732: PUSH
111733: LD_EXP 166
111737: GREATEREQUAL
111738: IFFALSE 111742
// exit ;
111740: GO 111942
// ComMoveXY ( unit , x , y ) ;
111742: LD_VAR 0 1
111746: PPUSH
111747: LD_VAR 0 2
111751: PPUSH
111752: LD_VAR 0 3
111756: PPUSH
111757: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111761: LD_INT 35
111763: PPUSH
111764: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111768: LD_VAR 0 1
111772: PPUSH
111773: LD_VAR 0 2
111777: PPUSH
111778: LD_VAR 0 3
111782: PPUSH
111783: CALL 85714 0 3
111787: NOT
111788: PUSH
111789: LD_VAR 0 1
111793: PPUSH
111794: CALL_OW 314
111798: AND
111799: IFFALSE 111803
// exit ;
111801: GO 111942
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111803: LD_VAR 0 2
111807: PPUSH
111808: LD_VAR 0 3
111812: PPUSH
111813: CALL_OW 428
111817: PUSH
111818: LD_VAR 0 1
111822: EQUAL
111823: PUSH
111824: LD_VAR 0 1
111828: PPUSH
111829: CALL_OW 314
111833: NOT
111834: AND
111835: IFFALSE 111761
// PlaySoundXY ( x , y , PlantMine ) ;
111837: LD_VAR 0 2
111841: PPUSH
111842: LD_VAR 0 3
111846: PPUSH
111847: LD_STRING PlantMine
111849: PPUSH
111850: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111854: LD_VAR 0 2
111858: PPUSH
111859: LD_VAR 0 3
111863: PPUSH
111864: LD_VAR 0 1
111868: PPUSH
111869: CALL_OW 255
111873: PPUSH
111874: LD_INT 0
111876: PPUSH
111877: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111881: LD_ADDR_EXP 165
111885: PUSH
111886: LD_EXP 165
111890: PPUSH
111891: LD_VAR 0 5
111895: PUSH
111896: LD_EXP 165
111900: PUSH
111901: LD_VAR 0 5
111905: ARRAY
111906: PUSH
111907: LD_INT 1
111909: PLUS
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: PPUSH
111915: LD_VAR 0 2
111919: PUSH
111920: LD_VAR 0 3
111924: PUSH
111925: EMPTY
111926: LIST
111927: LIST
111928: PPUSH
111929: CALL 54168 0 3
111933: ST_TO_ADDR
// result := true ;
111934: LD_ADDR_VAR 0 4
111938: PUSH
111939: LD_INT 1
111941: ST_TO_ADDR
// end ;
111942: LD_VAR 0 4
111946: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111947: LD_INT 0
111949: PPUSH
111950: PPUSH
111951: PPUSH
// if not unit in minersList then
111952: LD_VAR 0 1
111956: PUSH
111957: LD_EXP 164
111961: IN
111962: NOT
111963: IFFALSE 111967
// exit ;
111965: GO 112359
// index := GetElementIndex ( minersList , unit ) ;
111967: LD_ADDR_VAR 0 6
111971: PUSH
111972: LD_EXP 164
111976: PPUSH
111977: LD_VAR 0 1
111981: PPUSH
111982: CALL 53953 0 2
111986: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111987: LD_ADDR_VAR 0 5
111991: PUSH
111992: DOUBLE
111993: LD_EXP 165
111997: PUSH
111998: LD_VAR 0 6
112002: ARRAY
112003: INC
112004: ST_TO_ADDR
112005: LD_INT 1
112007: PUSH
112008: FOR_DOWNTO
112009: IFFALSE 112170
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112011: LD_EXP 165
112015: PUSH
112016: LD_VAR 0 6
112020: ARRAY
112021: PUSH
112022: LD_VAR 0 5
112026: ARRAY
112027: PUSH
112028: LD_INT 1
112030: ARRAY
112031: PUSH
112032: LD_VAR 0 2
112036: EQUAL
112037: PUSH
112038: LD_EXP 165
112042: PUSH
112043: LD_VAR 0 6
112047: ARRAY
112048: PUSH
112049: LD_VAR 0 5
112053: ARRAY
112054: PUSH
112055: LD_INT 2
112057: ARRAY
112058: PUSH
112059: LD_VAR 0 3
112063: EQUAL
112064: AND
112065: IFFALSE 112168
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112067: LD_EXP 165
112071: PUSH
112072: LD_VAR 0 6
112076: ARRAY
112077: PUSH
112078: LD_VAR 0 5
112082: ARRAY
112083: PUSH
112084: LD_INT 1
112086: ARRAY
112087: PPUSH
112088: LD_EXP 165
112092: PUSH
112093: LD_VAR 0 6
112097: ARRAY
112098: PUSH
112099: LD_VAR 0 5
112103: ARRAY
112104: PUSH
112105: LD_INT 2
112107: ARRAY
112108: PPUSH
112109: LD_VAR 0 1
112113: PPUSH
112114: CALL_OW 255
112118: PPUSH
112119: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112123: LD_ADDR_EXP 165
112127: PUSH
112128: LD_EXP 165
112132: PPUSH
112133: LD_VAR 0 6
112137: PPUSH
112138: LD_EXP 165
112142: PUSH
112143: LD_VAR 0 6
112147: ARRAY
112148: PPUSH
112149: LD_VAR 0 5
112153: PPUSH
112154: CALL_OW 3
112158: PPUSH
112159: CALL_OW 1
112163: ST_TO_ADDR
// exit ;
112164: POP
112165: POP
112166: GO 112359
// end ; end ;
112168: GO 112008
112170: POP
112171: POP
// for i := minerMinesList [ index ] downto 1 do
112172: LD_ADDR_VAR 0 5
112176: PUSH
112177: DOUBLE
112178: LD_EXP 165
112182: PUSH
112183: LD_VAR 0 6
112187: ARRAY
112188: INC
112189: ST_TO_ADDR
112190: LD_INT 1
112192: PUSH
112193: FOR_DOWNTO
112194: IFFALSE 112357
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112196: LD_EXP 165
112200: PUSH
112201: LD_VAR 0 6
112205: ARRAY
112206: PUSH
112207: LD_VAR 0 5
112211: ARRAY
112212: PUSH
112213: LD_INT 1
112215: ARRAY
112216: PPUSH
112217: LD_EXP 165
112221: PUSH
112222: LD_VAR 0 6
112226: ARRAY
112227: PUSH
112228: LD_VAR 0 5
112232: ARRAY
112233: PUSH
112234: LD_INT 2
112236: ARRAY
112237: PPUSH
112238: LD_VAR 0 2
112242: PPUSH
112243: LD_VAR 0 3
112247: PPUSH
112248: CALL_OW 298
112252: PUSH
112253: LD_INT 6
112255: LESS
112256: IFFALSE 112355
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112258: LD_EXP 165
112262: PUSH
112263: LD_VAR 0 6
112267: ARRAY
112268: PUSH
112269: LD_VAR 0 5
112273: ARRAY
112274: PUSH
112275: LD_INT 1
112277: ARRAY
112278: PPUSH
112279: LD_EXP 165
112283: PUSH
112284: LD_VAR 0 6
112288: ARRAY
112289: PUSH
112290: LD_VAR 0 5
112294: ARRAY
112295: PUSH
112296: LD_INT 2
112298: ARRAY
112299: PPUSH
112300: LD_VAR 0 1
112304: PPUSH
112305: CALL_OW 255
112309: PPUSH
112310: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112314: LD_ADDR_EXP 165
112318: PUSH
112319: LD_EXP 165
112323: PPUSH
112324: LD_VAR 0 6
112328: PPUSH
112329: LD_EXP 165
112333: PUSH
112334: LD_VAR 0 6
112338: ARRAY
112339: PPUSH
112340: LD_VAR 0 5
112344: PPUSH
112345: CALL_OW 3
112349: PPUSH
112350: CALL_OW 1
112354: ST_TO_ADDR
// end ; end ;
112355: GO 112193
112357: POP
112358: POP
// end ;
112359: LD_VAR 0 4
112363: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112364: LD_INT 0
112366: PPUSH
112367: PPUSH
112368: PPUSH
112369: PPUSH
112370: PPUSH
112371: PPUSH
112372: PPUSH
112373: PPUSH
112374: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112375: LD_VAR 0 1
112379: PPUSH
112380: CALL_OW 264
112384: PUSH
112385: LD_INT 81
112387: EQUAL
112388: NOT
112389: PUSH
112390: LD_VAR 0 1
112394: PUSH
112395: LD_EXP 164
112399: IN
112400: NOT
112401: OR
112402: IFFALSE 112406
// exit ;
112404: GO 112728
// index := GetElementIndex ( minersList , unit ) ;
112406: LD_ADDR_VAR 0 6
112410: PUSH
112411: LD_EXP 164
112415: PPUSH
112416: LD_VAR 0 1
112420: PPUSH
112421: CALL 53953 0 2
112425: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112426: LD_ADDR_VAR 0 8
112430: PUSH
112431: LD_EXP 166
112435: PUSH
112436: LD_EXP 165
112440: PUSH
112441: LD_VAR 0 6
112445: ARRAY
112446: MINUS
112447: ST_TO_ADDR
// if not minesFreeAmount then
112448: LD_VAR 0 8
112452: NOT
112453: IFFALSE 112457
// exit ;
112455: GO 112728
// tmp := [ ] ;
112457: LD_ADDR_VAR 0 7
112461: PUSH
112462: EMPTY
112463: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112464: LD_ADDR_VAR 0 5
112468: PUSH
112469: DOUBLE
112470: LD_INT 1
112472: DEC
112473: ST_TO_ADDR
112474: LD_VAR 0 8
112478: PUSH
112479: FOR_TO
112480: IFFALSE 112675
// begin _d := rand ( 0 , 5 ) ;
112482: LD_ADDR_VAR 0 11
112486: PUSH
112487: LD_INT 0
112489: PPUSH
112490: LD_INT 5
112492: PPUSH
112493: CALL_OW 12
112497: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112498: LD_ADDR_VAR 0 12
112502: PUSH
112503: LD_INT 2
112505: PPUSH
112506: LD_INT 6
112508: PPUSH
112509: CALL_OW 12
112513: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112514: LD_ADDR_VAR 0 9
112518: PUSH
112519: LD_VAR 0 2
112523: PPUSH
112524: LD_VAR 0 11
112528: PPUSH
112529: LD_VAR 0 12
112533: PPUSH
112534: CALL_OW 272
112538: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112539: LD_ADDR_VAR 0 10
112543: PUSH
112544: LD_VAR 0 3
112548: PPUSH
112549: LD_VAR 0 11
112553: PPUSH
112554: LD_VAR 0 12
112558: PPUSH
112559: CALL_OW 273
112563: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112564: LD_VAR 0 9
112568: PPUSH
112569: LD_VAR 0 10
112573: PPUSH
112574: CALL_OW 488
112578: PUSH
112579: LD_VAR 0 9
112583: PUSH
112584: LD_VAR 0 10
112588: PUSH
112589: EMPTY
112590: LIST
112591: LIST
112592: PUSH
112593: LD_VAR 0 7
112597: IN
112598: NOT
112599: AND
112600: PUSH
112601: LD_VAR 0 9
112605: PPUSH
112606: LD_VAR 0 10
112610: PPUSH
112611: CALL_OW 458
112615: NOT
112616: AND
112617: IFFALSE 112659
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112619: LD_ADDR_VAR 0 7
112623: PUSH
112624: LD_VAR 0 7
112628: PPUSH
112629: LD_VAR 0 7
112633: PUSH
112634: LD_INT 1
112636: PLUS
112637: PPUSH
112638: LD_VAR 0 9
112642: PUSH
112643: LD_VAR 0 10
112647: PUSH
112648: EMPTY
112649: LIST
112650: LIST
112651: PPUSH
112652: CALL_OW 1
112656: ST_TO_ADDR
112657: GO 112673
// i := i - 1 ;
112659: LD_ADDR_VAR 0 5
112663: PUSH
112664: LD_VAR 0 5
112668: PUSH
112669: LD_INT 1
112671: MINUS
112672: ST_TO_ADDR
// end ;
112673: GO 112479
112675: POP
112676: POP
// for i in tmp do
112677: LD_ADDR_VAR 0 5
112681: PUSH
112682: LD_VAR 0 7
112686: PUSH
112687: FOR_IN
112688: IFFALSE 112726
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112690: LD_VAR 0 1
112694: PPUSH
112695: LD_VAR 0 5
112699: PUSH
112700: LD_INT 1
112702: ARRAY
112703: PPUSH
112704: LD_VAR 0 5
112708: PUSH
112709: LD_INT 2
112711: ARRAY
112712: PPUSH
112713: CALL 111672 0 3
112717: NOT
112718: IFFALSE 112724
// exit ;
112720: POP
112721: POP
112722: GO 112728
112724: GO 112687
112726: POP
112727: POP
// end ;
112728: LD_VAR 0 4
112732: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
112733: LD_INT 0
112735: PPUSH
112736: PPUSH
112737: PPUSH
112738: PPUSH
112739: PPUSH
112740: PPUSH
112741: PPUSH
112742: PPUSH
112743: PPUSH
// if GetClass ( unit ) <> class_sniper then
112744: LD_VAR 0 1
112748: PPUSH
112749: CALL_OW 257
112753: PUSH
112754: LD_INT 5
112756: NONEQUAL
112757: IFFALSE 112761
// exit ;
112759: GO 113227
// dist := 8 ;
112761: LD_ADDR_VAR 0 5
112765: PUSH
112766: LD_INT 8
112768: ST_TO_ADDR
// viewRange := 12 ;
112769: LD_ADDR_VAR 0 8
112773: PUSH
112774: LD_INT 12
112776: ST_TO_ADDR
// side := GetSide ( unit ) ;
112777: LD_ADDR_VAR 0 6
112781: PUSH
112782: LD_VAR 0 1
112786: PPUSH
112787: CALL_OW 255
112791: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112792: LD_INT 61
112794: PPUSH
112795: LD_VAR 0 6
112799: PPUSH
112800: CALL_OW 321
112804: PUSH
112805: LD_INT 2
112807: EQUAL
112808: IFFALSE 112818
// viewRange := 16 ;
112810: LD_ADDR_VAR 0 8
112814: PUSH
112815: LD_INT 16
112817: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112818: LD_VAR 0 1
112822: PPUSH
112823: LD_VAR 0 2
112827: PPUSH
112828: LD_VAR 0 3
112832: PPUSH
112833: CALL_OW 297
112837: PUSH
112838: LD_VAR 0 5
112842: GREATER
112843: IFFALSE 112922
// begin ComMoveXY ( unit , x , y ) ;
112845: LD_VAR 0 1
112849: PPUSH
112850: LD_VAR 0 2
112854: PPUSH
112855: LD_VAR 0 3
112859: PPUSH
112860: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112864: LD_INT 35
112866: PPUSH
112867: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112871: LD_VAR 0 1
112875: PPUSH
112876: LD_VAR 0 2
112880: PPUSH
112881: LD_VAR 0 3
112885: PPUSH
112886: CALL 85714 0 3
112890: NOT
112891: IFFALSE 112895
// exit ;
112893: GO 113227
// until GetDistUnitXY ( unit , x , y ) < dist ;
112895: LD_VAR 0 1
112899: PPUSH
112900: LD_VAR 0 2
112904: PPUSH
112905: LD_VAR 0 3
112909: PPUSH
112910: CALL_OW 297
112914: PUSH
112915: LD_VAR 0 5
112919: LESS
112920: IFFALSE 112864
// end ; ComTurnXY ( unit , x , y ) ;
112922: LD_VAR 0 1
112926: PPUSH
112927: LD_VAR 0 2
112931: PPUSH
112932: LD_VAR 0 3
112936: PPUSH
112937: CALL_OW 118
// repeat if Multiplayer then
112941: LD_OWVAR 4
112945: IFFALSE 112956
// wait ( 35 ) else
112947: LD_INT 35
112949: PPUSH
112950: CALL_OW 67
112954: GO 112963
// wait ( 5 ) ;
112956: LD_INT 5
112958: PPUSH
112959: CALL_OW 67
// _d := GetDir ( unit ) ;
112963: LD_ADDR_VAR 0 11
112967: PUSH
112968: LD_VAR 0 1
112972: PPUSH
112973: CALL_OW 254
112977: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
112978: LD_ADDR_VAR 0 7
112982: PUSH
112983: LD_VAR 0 1
112987: PPUSH
112988: CALL_OW 250
112992: PPUSH
112993: LD_VAR 0 1
112997: PPUSH
112998: CALL_OW 251
113002: PPUSH
113003: LD_VAR 0 2
113007: PPUSH
113008: LD_VAR 0 3
113012: PPUSH
113013: CALL 88322 0 4
113017: ST_TO_ADDR
// until dir = _d ;
113018: LD_VAR 0 7
113022: PUSH
113023: LD_VAR 0 11
113027: EQUAL
113028: IFFALSE 112941
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
113030: LD_ADDR_VAR 0 9
113034: PUSH
113035: LD_VAR 0 1
113039: PPUSH
113040: CALL_OW 250
113044: PPUSH
113045: LD_VAR 0 7
113049: PPUSH
113050: LD_VAR 0 5
113054: PPUSH
113055: CALL_OW 272
113059: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
113060: LD_ADDR_VAR 0 10
113064: PUSH
113065: LD_VAR 0 1
113069: PPUSH
113070: CALL_OW 251
113074: PPUSH
113075: LD_VAR 0 7
113079: PPUSH
113080: LD_VAR 0 5
113084: PPUSH
113085: CALL_OW 273
113089: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113090: LD_VAR 0 9
113094: PPUSH
113095: LD_VAR 0 10
113099: PPUSH
113100: CALL_OW 488
113104: NOT
113105: IFFALSE 113109
// exit ;
113107: GO 113227
// ComAnimCustom ( unit , 1 ) ;
113109: LD_VAR 0 1
113113: PPUSH
113114: LD_INT 1
113116: PPUSH
113117: CALL_OW 592
// p := 0 ;
113121: LD_ADDR_VAR 0 12
113125: PUSH
113126: LD_INT 0
113128: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113129: LD_VAR 0 9
113133: PPUSH
113134: LD_VAR 0 10
113138: PPUSH
113139: LD_VAR 0 6
113143: PPUSH
113144: LD_VAR 0 8
113148: PPUSH
113149: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
113153: LD_INT 35
113155: PPUSH
113156: CALL_OW 67
// p := Inc ( p ) ;
113160: LD_ADDR_VAR 0 12
113164: PUSH
113165: LD_VAR 0 12
113169: PPUSH
113170: CALL 88278 0 1
113174: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
113175: LD_VAR 0 12
113179: PUSH
113180: LD_INT 3
113182: EQUAL
113183: PUSH
113184: LD_VAR 0 1
113188: PPUSH
113189: CALL_OW 302
113193: NOT
113194: OR
113195: PUSH
113196: LD_VAR 0 1
113200: PPUSH
113201: CALL_OW 301
113205: OR
113206: IFFALSE 113153
// RemoveSeeing ( _x , _y , side ) ;
113208: LD_VAR 0 9
113212: PPUSH
113213: LD_VAR 0 10
113217: PPUSH
113218: LD_VAR 0 6
113222: PPUSH
113223: CALL_OW 331
// end ; end_of_file
113227: LD_VAR 0 4
113231: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113232: LD_INT 0
113234: PPUSH
113235: PPUSH
113236: PPUSH
113237: PPUSH
113238: PPUSH
113239: PPUSH
113240: PPUSH
113241: PPUSH
113242: PPUSH
113243: PPUSH
113244: PPUSH
113245: PPUSH
113246: PPUSH
113247: PPUSH
113248: PPUSH
113249: PPUSH
113250: PPUSH
113251: PPUSH
113252: PPUSH
113253: PPUSH
113254: PPUSH
113255: PPUSH
113256: PPUSH
113257: PPUSH
113258: PPUSH
113259: PPUSH
113260: PPUSH
113261: PPUSH
113262: PPUSH
113263: PPUSH
113264: PPUSH
113265: PPUSH
113266: PPUSH
113267: PPUSH
// if not list then
113268: LD_VAR 0 1
113272: NOT
113273: IFFALSE 113277
// exit ;
113275: GO 117936
// base := list [ 1 ] ;
113277: LD_ADDR_VAR 0 3
113281: PUSH
113282: LD_VAR 0 1
113286: PUSH
113287: LD_INT 1
113289: ARRAY
113290: ST_TO_ADDR
// group := list [ 2 ] ;
113291: LD_ADDR_VAR 0 4
113295: PUSH
113296: LD_VAR 0 1
113300: PUSH
113301: LD_INT 2
113303: ARRAY
113304: ST_TO_ADDR
// path := list [ 3 ] ;
113305: LD_ADDR_VAR 0 5
113309: PUSH
113310: LD_VAR 0 1
113314: PUSH
113315: LD_INT 3
113317: ARRAY
113318: ST_TO_ADDR
// flags := list [ 4 ] ;
113319: LD_ADDR_VAR 0 6
113323: PUSH
113324: LD_VAR 0 1
113328: PUSH
113329: LD_INT 4
113331: ARRAY
113332: ST_TO_ADDR
// mined := [ ] ;
113333: LD_ADDR_VAR 0 27
113337: PUSH
113338: EMPTY
113339: ST_TO_ADDR
// bombed := [ ] ;
113340: LD_ADDR_VAR 0 28
113344: PUSH
113345: EMPTY
113346: ST_TO_ADDR
// healers := [ ] ;
113347: LD_ADDR_VAR 0 31
113351: PUSH
113352: EMPTY
113353: ST_TO_ADDR
// to_heal := [ ] ;
113354: LD_ADDR_VAR 0 30
113358: PUSH
113359: EMPTY
113360: ST_TO_ADDR
// repairs := [ ] ;
113361: LD_ADDR_VAR 0 33
113365: PUSH
113366: EMPTY
113367: ST_TO_ADDR
// to_repair := [ ] ;
113368: LD_ADDR_VAR 0 32
113372: PUSH
113373: EMPTY
113374: ST_TO_ADDR
// if not group or not path then
113375: LD_VAR 0 4
113379: NOT
113380: PUSH
113381: LD_VAR 0 5
113385: NOT
113386: OR
113387: IFFALSE 113391
// exit ;
113389: GO 117936
// side := GetSide ( group [ 1 ] ) ;
113391: LD_ADDR_VAR 0 35
113395: PUSH
113396: LD_VAR 0 4
113400: PUSH
113401: LD_INT 1
113403: ARRAY
113404: PPUSH
113405: CALL_OW 255
113409: ST_TO_ADDR
// if flags then
113410: LD_VAR 0 6
113414: IFFALSE 113558
// begin f_ignore_area := flags [ 1 ] ;
113416: LD_ADDR_VAR 0 17
113420: PUSH
113421: LD_VAR 0 6
113425: PUSH
113426: LD_INT 1
113428: ARRAY
113429: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113430: LD_ADDR_VAR 0 18
113434: PUSH
113435: LD_VAR 0 6
113439: PUSH
113440: LD_INT 2
113442: ARRAY
113443: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113444: LD_ADDR_VAR 0 19
113448: PUSH
113449: LD_VAR 0 6
113453: PUSH
113454: LD_INT 3
113456: ARRAY
113457: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113458: LD_ADDR_VAR 0 20
113462: PUSH
113463: LD_VAR 0 6
113467: PUSH
113468: LD_INT 4
113470: ARRAY
113471: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113472: LD_ADDR_VAR 0 21
113476: PUSH
113477: LD_VAR 0 6
113481: PUSH
113482: LD_INT 5
113484: ARRAY
113485: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113486: LD_ADDR_VAR 0 22
113490: PUSH
113491: LD_VAR 0 6
113495: PUSH
113496: LD_INT 6
113498: ARRAY
113499: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113500: LD_ADDR_VAR 0 23
113504: PUSH
113505: LD_VAR 0 6
113509: PUSH
113510: LD_INT 7
113512: ARRAY
113513: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113514: LD_ADDR_VAR 0 24
113518: PUSH
113519: LD_VAR 0 6
113523: PUSH
113524: LD_INT 8
113526: ARRAY
113527: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113528: LD_ADDR_VAR 0 25
113532: PUSH
113533: LD_VAR 0 6
113537: PUSH
113538: LD_INT 9
113540: ARRAY
113541: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113542: LD_ADDR_VAR 0 26
113546: PUSH
113547: LD_VAR 0 6
113551: PUSH
113552: LD_INT 10
113554: ARRAY
113555: ST_TO_ADDR
// end else
113556: GO 113638
// begin f_ignore_area := false ;
113558: LD_ADDR_VAR 0 17
113562: PUSH
113563: LD_INT 0
113565: ST_TO_ADDR
// f_capture := false ;
113566: LD_ADDR_VAR 0 18
113570: PUSH
113571: LD_INT 0
113573: ST_TO_ADDR
// f_ignore_civ := false ;
113574: LD_ADDR_VAR 0 19
113578: PUSH
113579: LD_INT 0
113581: ST_TO_ADDR
// f_murder := false ;
113582: LD_ADDR_VAR 0 20
113586: PUSH
113587: LD_INT 0
113589: ST_TO_ADDR
// f_mines := false ;
113590: LD_ADDR_VAR 0 21
113594: PUSH
113595: LD_INT 0
113597: ST_TO_ADDR
// f_repair := false ;
113598: LD_ADDR_VAR 0 22
113602: PUSH
113603: LD_INT 0
113605: ST_TO_ADDR
// f_heal := false ;
113606: LD_ADDR_VAR 0 23
113610: PUSH
113611: LD_INT 0
113613: ST_TO_ADDR
// f_spacetime := false ;
113614: LD_ADDR_VAR 0 24
113618: PUSH
113619: LD_INT 0
113621: ST_TO_ADDR
// f_attack_depot := false ;
113622: LD_ADDR_VAR 0 25
113626: PUSH
113627: LD_INT 0
113629: ST_TO_ADDR
// f_crawl := false ;
113630: LD_ADDR_VAR 0 26
113634: PUSH
113635: LD_INT 0
113637: ST_TO_ADDR
// end ; if f_heal then
113638: LD_VAR 0 23
113642: IFFALSE 113669
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113644: LD_ADDR_VAR 0 31
113648: PUSH
113649: LD_VAR 0 4
113653: PPUSH
113654: LD_INT 25
113656: PUSH
113657: LD_INT 4
113659: PUSH
113660: EMPTY
113661: LIST
113662: LIST
113663: PPUSH
113664: CALL_OW 72
113668: ST_TO_ADDR
// if f_repair then
113669: LD_VAR 0 22
113673: IFFALSE 113700
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113675: LD_ADDR_VAR 0 33
113679: PUSH
113680: LD_VAR 0 4
113684: PPUSH
113685: LD_INT 25
113687: PUSH
113688: LD_INT 3
113690: PUSH
113691: EMPTY
113692: LIST
113693: LIST
113694: PPUSH
113695: CALL_OW 72
113699: ST_TO_ADDR
// units_path := [ ] ;
113700: LD_ADDR_VAR 0 16
113704: PUSH
113705: EMPTY
113706: ST_TO_ADDR
// for i = 1 to group do
113707: LD_ADDR_VAR 0 7
113711: PUSH
113712: DOUBLE
113713: LD_INT 1
113715: DEC
113716: ST_TO_ADDR
113717: LD_VAR 0 4
113721: PUSH
113722: FOR_TO
113723: IFFALSE 113752
// units_path := Replace ( units_path , i , path ) ;
113725: LD_ADDR_VAR 0 16
113729: PUSH
113730: LD_VAR 0 16
113734: PPUSH
113735: LD_VAR 0 7
113739: PPUSH
113740: LD_VAR 0 5
113744: PPUSH
113745: CALL_OW 1
113749: ST_TO_ADDR
113750: GO 113722
113752: POP
113753: POP
// repeat for i = group downto 1 do
113754: LD_ADDR_VAR 0 7
113758: PUSH
113759: DOUBLE
113760: LD_VAR 0 4
113764: INC
113765: ST_TO_ADDR
113766: LD_INT 1
113768: PUSH
113769: FOR_DOWNTO
113770: IFFALSE 117892
// begin wait ( 5 ) ;
113772: LD_INT 5
113774: PPUSH
113775: CALL_OW 67
// tmp := [ ] ;
113779: LD_ADDR_VAR 0 14
113783: PUSH
113784: EMPTY
113785: ST_TO_ADDR
// attacking := false ;
113786: LD_ADDR_VAR 0 29
113790: PUSH
113791: LD_INT 0
113793: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113794: LD_VAR 0 4
113798: PUSH
113799: LD_VAR 0 7
113803: ARRAY
113804: PPUSH
113805: CALL_OW 301
113809: PUSH
113810: LD_VAR 0 4
113814: PUSH
113815: LD_VAR 0 7
113819: ARRAY
113820: NOT
113821: OR
113822: IFFALSE 113931
// begin if GetType ( group [ i ] ) = unit_human then
113824: LD_VAR 0 4
113828: PUSH
113829: LD_VAR 0 7
113833: ARRAY
113834: PPUSH
113835: CALL_OW 247
113839: PUSH
113840: LD_INT 1
113842: EQUAL
113843: IFFALSE 113889
// begin to_heal := to_heal diff group [ i ] ;
113845: LD_ADDR_VAR 0 30
113849: PUSH
113850: LD_VAR 0 30
113854: PUSH
113855: LD_VAR 0 4
113859: PUSH
113860: LD_VAR 0 7
113864: ARRAY
113865: DIFF
113866: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113867: LD_ADDR_VAR 0 31
113871: PUSH
113872: LD_VAR 0 31
113876: PUSH
113877: LD_VAR 0 4
113881: PUSH
113882: LD_VAR 0 7
113886: ARRAY
113887: DIFF
113888: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113889: LD_ADDR_VAR 0 4
113893: PUSH
113894: LD_VAR 0 4
113898: PPUSH
113899: LD_VAR 0 7
113903: PPUSH
113904: CALL_OW 3
113908: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113909: LD_ADDR_VAR 0 16
113913: PUSH
113914: LD_VAR 0 16
113918: PPUSH
113919: LD_VAR 0 7
113923: PPUSH
113924: CALL_OW 3
113928: ST_TO_ADDR
// continue ;
113929: GO 113769
// end ; if f_repair then
113931: LD_VAR 0 22
113935: IFFALSE 114424
// begin if GetType ( group [ i ] ) = unit_vehicle then
113937: LD_VAR 0 4
113941: PUSH
113942: LD_VAR 0 7
113946: ARRAY
113947: PPUSH
113948: CALL_OW 247
113952: PUSH
113953: LD_INT 2
113955: EQUAL
113956: IFFALSE 114146
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113958: LD_VAR 0 4
113962: PUSH
113963: LD_VAR 0 7
113967: ARRAY
113968: PPUSH
113969: CALL_OW 256
113973: PUSH
113974: LD_INT 700
113976: LESS
113977: PUSH
113978: LD_VAR 0 4
113982: PUSH
113983: LD_VAR 0 7
113987: ARRAY
113988: PUSH
113989: LD_VAR 0 32
113993: IN
113994: NOT
113995: AND
113996: IFFALSE 114020
// to_repair := to_repair union group [ i ] ;
113998: LD_ADDR_VAR 0 32
114002: PUSH
114003: LD_VAR 0 32
114007: PUSH
114008: LD_VAR 0 4
114012: PUSH
114013: LD_VAR 0 7
114017: ARRAY
114018: UNION
114019: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114020: LD_VAR 0 4
114024: PUSH
114025: LD_VAR 0 7
114029: ARRAY
114030: PPUSH
114031: CALL_OW 256
114035: PUSH
114036: LD_INT 1000
114038: EQUAL
114039: PUSH
114040: LD_VAR 0 4
114044: PUSH
114045: LD_VAR 0 7
114049: ARRAY
114050: PUSH
114051: LD_VAR 0 32
114055: IN
114056: AND
114057: IFFALSE 114081
// to_repair := to_repair diff group [ i ] ;
114059: LD_ADDR_VAR 0 32
114063: PUSH
114064: LD_VAR 0 32
114068: PUSH
114069: LD_VAR 0 4
114073: PUSH
114074: LD_VAR 0 7
114078: ARRAY
114079: DIFF
114080: ST_TO_ADDR
// if group [ i ] in to_repair then
114081: LD_VAR 0 4
114085: PUSH
114086: LD_VAR 0 7
114090: ARRAY
114091: PUSH
114092: LD_VAR 0 32
114096: IN
114097: IFFALSE 114144
// begin if not IsInArea ( group [ i ] , f_repair ) then
114099: LD_VAR 0 4
114103: PUSH
114104: LD_VAR 0 7
114108: ARRAY
114109: PPUSH
114110: LD_VAR 0 22
114114: PPUSH
114115: CALL_OW 308
114119: NOT
114120: IFFALSE 114142
// ComMoveToArea ( group [ i ] , f_repair ) ;
114122: LD_VAR 0 4
114126: PUSH
114127: LD_VAR 0 7
114131: ARRAY
114132: PPUSH
114133: LD_VAR 0 22
114137: PPUSH
114138: CALL_OW 113
// continue ;
114142: GO 113769
// end ; end else
114144: GO 114424
// if group [ i ] in repairs then
114146: LD_VAR 0 4
114150: PUSH
114151: LD_VAR 0 7
114155: ARRAY
114156: PUSH
114157: LD_VAR 0 33
114161: IN
114162: IFFALSE 114424
// begin if IsInUnit ( group [ i ] ) then
114164: LD_VAR 0 4
114168: PUSH
114169: LD_VAR 0 7
114173: ARRAY
114174: PPUSH
114175: CALL_OW 310
114179: IFFALSE 114247
// begin z := IsInUnit ( group [ i ] ) ;
114181: LD_ADDR_VAR 0 13
114185: PUSH
114186: LD_VAR 0 4
114190: PUSH
114191: LD_VAR 0 7
114195: ARRAY
114196: PPUSH
114197: CALL_OW 310
114201: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114202: LD_VAR 0 13
114206: PUSH
114207: LD_VAR 0 32
114211: IN
114212: PUSH
114213: LD_VAR 0 13
114217: PPUSH
114218: LD_VAR 0 22
114222: PPUSH
114223: CALL_OW 308
114227: AND
114228: IFFALSE 114245
// ComExitVehicle ( group [ i ] ) ;
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PPUSH
114241: CALL_OW 121
// end else
114245: GO 114424
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114247: LD_ADDR_VAR 0 13
114251: PUSH
114252: LD_VAR 0 4
114256: PPUSH
114257: LD_INT 95
114259: PUSH
114260: LD_VAR 0 22
114264: PUSH
114265: EMPTY
114266: LIST
114267: LIST
114268: PUSH
114269: LD_INT 58
114271: PUSH
114272: EMPTY
114273: LIST
114274: PUSH
114275: EMPTY
114276: LIST
114277: LIST
114278: PPUSH
114279: CALL_OW 72
114283: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114284: LD_VAR 0 4
114288: PUSH
114289: LD_VAR 0 7
114293: ARRAY
114294: PPUSH
114295: CALL_OW 314
114299: NOT
114300: IFFALSE 114422
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114302: LD_ADDR_VAR 0 10
114306: PUSH
114307: LD_VAR 0 13
114311: PPUSH
114312: LD_VAR 0 4
114316: PUSH
114317: LD_VAR 0 7
114321: ARRAY
114322: PPUSH
114323: CALL_OW 74
114327: ST_TO_ADDR
// if not x then
114328: LD_VAR 0 10
114332: NOT
114333: IFFALSE 114337
// continue ;
114335: GO 113769
// if GetLives ( x ) < 1000 then
114337: LD_VAR 0 10
114341: PPUSH
114342: CALL_OW 256
114346: PUSH
114347: LD_INT 1000
114349: LESS
114350: IFFALSE 114374
// ComRepairVehicle ( group [ i ] , x ) else
114352: LD_VAR 0 4
114356: PUSH
114357: LD_VAR 0 7
114361: ARRAY
114362: PPUSH
114363: LD_VAR 0 10
114367: PPUSH
114368: CALL_OW 129
114372: GO 114422
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114374: LD_VAR 0 23
114378: PUSH
114379: LD_VAR 0 4
114383: PUSH
114384: LD_VAR 0 7
114388: ARRAY
114389: PPUSH
114390: CALL_OW 256
114394: PUSH
114395: LD_INT 1000
114397: LESS
114398: AND
114399: NOT
114400: IFFALSE 114422
// ComEnterUnit ( group [ i ] , x ) ;
114402: LD_VAR 0 4
114406: PUSH
114407: LD_VAR 0 7
114411: ARRAY
114412: PPUSH
114413: LD_VAR 0 10
114417: PPUSH
114418: CALL_OW 120
// end ; continue ;
114422: GO 113769
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114424: LD_VAR 0 23
114428: PUSH
114429: LD_VAR 0 4
114433: PUSH
114434: LD_VAR 0 7
114438: ARRAY
114439: PPUSH
114440: CALL_OW 247
114444: PUSH
114445: LD_INT 1
114447: EQUAL
114448: AND
114449: IFFALSE 114927
// begin if group [ i ] in healers then
114451: LD_VAR 0 4
114455: PUSH
114456: LD_VAR 0 7
114460: ARRAY
114461: PUSH
114462: LD_VAR 0 31
114466: IN
114467: IFFALSE 114740
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114469: LD_VAR 0 4
114473: PUSH
114474: LD_VAR 0 7
114478: ARRAY
114479: PPUSH
114480: LD_VAR 0 23
114484: PPUSH
114485: CALL_OW 308
114489: NOT
114490: PUSH
114491: LD_VAR 0 4
114495: PUSH
114496: LD_VAR 0 7
114500: ARRAY
114501: PPUSH
114502: CALL_OW 314
114506: NOT
114507: AND
114508: IFFALSE 114532
// ComMoveToArea ( group [ i ] , f_heal ) else
114510: LD_VAR 0 4
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PPUSH
114521: LD_VAR 0 23
114525: PPUSH
114526: CALL_OW 113
114530: GO 114738
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114532: LD_VAR 0 4
114536: PUSH
114537: LD_VAR 0 7
114541: ARRAY
114542: PPUSH
114543: CALL 84297 0 1
114547: PPUSH
114548: CALL_OW 256
114552: PUSH
114553: LD_INT 1000
114555: EQUAL
114556: IFFALSE 114575
// ComStop ( group [ i ] ) else
114558: LD_VAR 0 4
114562: PUSH
114563: LD_VAR 0 7
114567: ARRAY
114568: PPUSH
114569: CALL_OW 141
114573: GO 114738
// if not HasTask ( group [ i ] ) and to_heal then
114575: LD_VAR 0 4
114579: PUSH
114580: LD_VAR 0 7
114584: ARRAY
114585: PPUSH
114586: CALL_OW 314
114590: NOT
114591: PUSH
114592: LD_VAR 0 30
114596: AND
114597: IFFALSE 114738
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114599: LD_ADDR_VAR 0 13
114603: PUSH
114604: LD_VAR 0 30
114608: PPUSH
114609: LD_INT 3
114611: PUSH
114612: LD_INT 54
114614: PUSH
114615: EMPTY
114616: LIST
114617: PUSH
114618: EMPTY
114619: LIST
114620: LIST
114621: PPUSH
114622: CALL_OW 72
114626: PPUSH
114627: LD_VAR 0 4
114631: PUSH
114632: LD_VAR 0 7
114636: ARRAY
114637: PPUSH
114638: CALL_OW 74
114642: ST_TO_ADDR
// if z then
114643: LD_VAR 0 13
114647: IFFALSE 114738
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114649: LD_INT 91
114651: PUSH
114652: LD_VAR 0 13
114656: PUSH
114657: LD_INT 10
114659: PUSH
114660: EMPTY
114661: LIST
114662: LIST
114663: LIST
114664: PUSH
114665: LD_INT 81
114667: PUSH
114668: LD_VAR 0 13
114672: PPUSH
114673: CALL_OW 255
114677: PUSH
114678: EMPTY
114679: LIST
114680: LIST
114681: PUSH
114682: EMPTY
114683: LIST
114684: LIST
114685: PPUSH
114686: CALL_OW 69
114690: PUSH
114691: LD_INT 0
114693: EQUAL
114694: IFFALSE 114718
// ComHeal ( group [ i ] , z ) else
114696: LD_VAR 0 4
114700: PUSH
114701: LD_VAR 0 7
114705: ARRAY
114706: PPUSH
114707: LD_VAR 0 13
114711: PPUSH
114712: CALL_OW 128
114716: GO 114738
// ComMoveToArea ( group [ i ] , f_heal ) ;
114718: LD_VAR 0 4
114722: PUSH
114723: LD_VAR 0 7
114727: ARRAY
114728: PPUSH
114729: LD_VAR 0 23
114733: PPUSH
114734: CALL_OW 113
// end ; continue ;
114738: GO 113769
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114740: LD_VAR 0 4
114744: PUSH
114745: LD_VAR 0 7
114749: ARRAY
114750: PPUSH
114751: CALL_OW 256
114755: PUSH
114756: LD_INT 700
114758: LESS
114759: PUSH
114760: LD_VAR 0 4
114764: PUSH
114765: LD_VAR 0 7
114769: ARRAY
114770: PUSH
114771: LD_VAR 0 30
114775: IN
114776: NOT
114777: AND
114778: IFFALSE 114802
// to_heal := to_heal union group [ i ] ;
114780: LD_ADDR_VAR 0 30
114784: PUSH
114785: LD_VAR 0 30
114789: PUSH
114790: LD_VAR 0 4
114794: PUSH
114795: LD_VAR 0 7
114799: ARRAY
114800: UNION
114801: ST_TO_ADDR
// if group [ i ] in to_heal then
114802: LD_VAR 0 4
114806: PUSH
114807: LD_VAR 0 7
114811: ARRAY
114812: PUSH
114813: LD_VAR 0 30
114817: IN
114818: IFFALSE 114927
// begin if GetLives ( group [ i ] ) = 1000 then
114820: LD_VAR 0 4
114824: PUSH
114825: LD_VAR 0 7
114829: ARRAY
114830: PPUSH
114831: CALL_OW 256
114835: PUSH
114836: LD_INT 1000
114838: EQUAL
114839: IFFALSE 114865
// to_heal := to_heal diff group [ i ] else
114841: LD_ADDR_VAR 0 30
114845: PUSH
114846: LD_VAR 0 30
114850: PUSH
114851: LD_VAR 0 4
114855: PUSH
114856: LD_VAR 0 7
114860: ARRAY
114861: DIFF
114862: ST_TO_ADDR
114863: GO 114927
// begin if not IsInArea ( group [ i ] , to_heal ) then
114865: LD_VAR 0 4
114869: PUSH
114870: LD_VAR 0 7
114874: ARRAY
114875: PPUSH
114876: LD_VAR 0 30
114880: PPUSH
114881: CALL_OW 308
114885: NOT
114886: IFFALSE 114910
// ComMoveToArea ( group [ i ] , f_heal ) else
114888: LD_VAR 0 4
114892: PUSH
114893: LD_VAR 0 7
114897: ARRAY
114898: PPUSH
114899: LD_VAR 0 23
114903: PPUSH
114904: CALL_OW 113
114908: GO 114925
// ComHold ( group [ i ] ) ;
114910: LD_VAR 0 4
114914: PUSH
114915: LD_VAR 0 7
114919: ARRAY
114920: PPUSH
114921: CALL_OW 140
// continue ;
114925: GO 113769
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114927: LD_VAR 0 4
114931: PUSH
114932: LD_VAR 0 7
114936: ARRAY
114937: PPUSH
114938: LD_INT 10
114940: PPUSH
114941: CALL 82059 0 2
114945: NOT
114946: PUSH
114947: LD_VAR 0 16
114951: PUSH
114952: LD_VAR 0 7
114956: ARRAY
114957: PUSH
114958: EMPTY
114959: EQUAL
114960: NOT
114961: AND
114962: IFFALSE 115228
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114964: LD_VAR 0 4
114968: PUSH
114969: LD_VAR 0 7
114973: ARRAY
114974: PPUSH
114975: CALL_OW 262
114979: PUSH
114980: LD_INT 1
114982: PUSH
114983: LD_INT 2
114985: PUSH
114986: EMPTY
114987: LIST
114988: LIST
114989: IN
114990: IFFALSE 115031
// if GetFuel ( group [ i ] ) < 10 then
114992: LD_VAR 0 4
114996: PUSH
114997: LD_VAR 0 7
115001: ARRAY
115002: PPUSH
115003: CALL_OW 261
115007: PUSH
115008: LD_INT 10
115010: LESS
115011: IFFALSE 115031
// SetFuel ( group [ i ] , 12 ) ;
115013: LD_VAR 0 4
115017: PUSH
115018: LD_VAR 0 7
115022: ARRAY
115023: PPUSH
115024: LD_INT 12
115026: PPUSH
115027: CALL_OW 240
// if units_path [ i ] then
115031: LD_VAR 0 16
115035: PUSH
115036: LD_VAR 0 7
115040: ARRAY
115041: IFFALSE 115226
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115043: LD_VAR 0 4
115047: PUSH
115048: LD_VAR 0 7
115052: ARRAY
115053: PPUSH
115054: LD_VAR 0 16
115058: PUSH
115059: LD_VAR 0 7
115063: ARRAY
115064: PUSH
115065: LD_INT 1
115067: ARRAY
115068: PUSH
115069: LD_INT 1
115071: ARRAY
115072: PPUSH
115073: LD_VAR 0 16
115077: PUSH
115078: LD_VAR 0 7
115082: ARRAY
115083: PUSH
115084: LD_INT 1
115086: ARRAY
115087: PUSH
115088: LD_INT 2
115090: ARRAY
115091: PPUSH
115092: CALL_OW 297
115096: PUSH
115097: LD_INT 6
115099: GREATER
115100: IFFALSE 115175
// begin if not HasTask ( group [ i ] ) then
115102: LD_VAR 0 4
115106: PUSH
115107: LD_VAR 0 7
115111: ARRAY
115112: PPUSH
115113: CALL_OW 314
115117: NOT
115118: IFFALSE 115173
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115120: LD_VAR 0 4
115124: PUSH
115125: LD_VAR 0 7
115129: ARRAY
115130: PPUSH
115131: LD_VAR 0 16
115135: PUSH
115136: LD_VAR 0 7
115140: ARRAY
115141: PUSH
115142: LD_INT 1
115144: ARRAY
115145: PUSH
115146: LD_INT 1
115148: ARRAY
115149: PPUSH
115150: LD_VAR 0 16
115154: PUSH
115155: LD_VAR 0 7
115159: ARRAY
115160: PUSH
115161: LD_INT 1
115163: ARRAY
115164: PUSH
115165: LD_INT 2
115167: ARRAY
115168: PPUSH
115169: CALL_OW 114
// end else
115173: GO 115226
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115175: LD_ADDR_VAR 0 15
115179: PUSH
115180: LD_VAR 0 16
115184: PUSH
115185: LD_VAR 0 7
115189: ARRAY
115190: PPUSH
115191: LD_INT 1
115193: PPUSH
115194: CALL_OW 3
115198: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115199: LD_ADDR_VAR 0 16
115203: PUSH
115204: LD_VAR 0 16
115208: PPUSH
115209: LD_VAR 0 7
115213: PPUSH
115214: LD_VAR 0 15
115218: PPUSH
115219: CALL_OW 1
115223: ST_TO_ADDR
// continue ;
115224: GO 113769
// end ; end ; end else
115226: GO 117890
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115228: LD_ADDR_VAR 0 14
115232: PUSH
115233: LD_INT 81
115235: PUSH
115236: LD_VAR 0 4
115240: PUSH
115241: LD_VAR 0 7
115245: ARRAY
115246: PPUSH
115247: CALL_OW 255
115251: PUSH
115252: EMPTY
115253: LIST
115254: LIST
115255: PPUSH
115256: CALL_OW 69
115260: ST_TO_ADDR
// if not tmp then
115261: LD_VAR 0 14
115265: NOT
115266: IFFALSE 115270
// continue ;
115268: GO 113769
// if f_ignore_area then
115270: LD_VAR 0 17
115274: IFFALSE 115362
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115276: LD_ADDR_VAR 0 15
115280: PUSH
115281: LD_VAR 0 14
115285: PPUSH
115286: LD_INT 3
115288: PUSH
115289: LD_INT 92
115291: PUSH
115292: LD_VAR 0 17
115296: PUSH
115297: LD_INT 1
115299: ARRAY
115300: PUSH
115301: LD_VAR 0 17
115305: PUSH
115306: LD_INT 2
115308: ARRAY
115309: PUSH
115310: LD_VAR 0 17
115314: PUSH
115315: LD_INT 3
115317: ARRAY
115318: PUSH
115319: EMPTY
115320: LIST
115321: LIST
115322: LIST
115323: LIST
115324: PUSH
115325: EMPTY
115326: LIST
115327: LIST
115328: PPUSH
115329: CALL_OW 72
115333: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115334: LD_VAR 0 14
115338: PUSH
115339: LD_VAR 0 15
115343: DIFF
115344: IFFALSE 115362
// tmp := tmp diff tmp2 ;
115346: LD_ADDR_VAR 0 14
115350: PUSH
115351: LD_VAR 0 14
115355: PUSH
115356: LD_VAR 0 15
115360: DIFF
115361: ST_TO_ADDR
// end ; if not f_murder then
115362: LD_VAR 0 20
115366: NOT
115367: IFFALSE 115425
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115369: LD_ADDR_VAR 0 15
115373: PUSH
115374: LD_VAR 0 14
115378: PPUSH
115379: LD_INT 3
115381: PUSH
115382: LD_INT 50
115384: PUSH
115385: EMPTY
115386: LIST
115387: PUSH
115388: EMPTY
115389: LIST
115390: LIST
115391: PPUSH
115392: CALL_OW 72
115396: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115397: LD_VAR 0 14
115401: PUSH
115402: LD_VAR 0 15
115406: DIFF
115407: IFFALSE 115425
// tmp := tmp diff tmp2 ;
115409: LD_ADDR_VAR 0 14
115413: PUSH
115414: LD_VAR 0 14
115418: PUSH
115419: LD_VAR 0 15
115423: DIFF
115424: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115425: LD_ADDR_VAR 0 14
115429: PUSH
115430: LD_VAR 0 4
115434: PUSH
115435: LD_VAR 0 7
115439: ARRAY
115440: PPUSH
115441: LD_VAR 0 14
115445: PPUSH
115446: LD_INT 1
115448: PPUSH
115449: LD_INT 1
115451: PPUSH
115452: CALL 54603 0 4
115456: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115457: LD_VAR 0 4
115461: PUSH
115462: LD_VAR 0 7
115466: ARRAY
115467: PPUSH
115468: CALL_OW 257
115472: PUSH
115473: LD_INT 1
115475: EQUAL
115476: IFFALSE 115924
// begin if WantPlant ( group [ i ] ) then
115478: LD_VAR 0 4
115482: PUSH
115483: LD_VAR 0 7
115487: ARRAY
115488: PPUSH
115489: CALL 54104 0 1
115493: IFFALSE 115497
// continue ;
115495: GO 113769
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115497: LD_VAR 0 18
115501: PUSH
115502: LD_VAR 0 4
115506: PUSH
115507: LD_VAR 0 7
115511: ARRAY
115512: PPUSH
115513: CALL_OW 310
115517: NOT
115518: AND
115519: PUSH
115520: LD_VAR 0 14
115524: PUSH
115525: LD_INT 1
115527: ARRAY
115528: PUSH
115529: LD_VAR 0 14
115533: PPUSH
115534: LD_INT 21
115536: PUSH
115537: LD_INT 2
115539: PUSH
115540: EMPTY
115541: LIST
115542: LIST
115543: PUSH
115544: LD_INT 58
115546: PUSH
115547: EMPTY
115548: LIST
115549: PUSH
115550: EMPTY
115551: LIST
115552: LIST
115553: PPUSH
115554: CALL_OW 72
115558: IN
115559: AND
115560: IFFALSE 115596
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115562: LD_VAR 0 4
115566: PUSH
115567: LD_VAR 0 7
115571: ARRAY
115572: PPUSH
115573: LD_VAR 0 14
115577: PUSH
115578: LD_INT 1
115580: ARRAY
115581: PPUSH
115582: CALL_OW 120
// attacking := true ;
115586: LD_ADDR_VAR 0 29
115590: PUSH
115591: LD_INT 1
115593: ST_TO_ADDR
// continue ;
115594: GO 113769
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115596: LD_VAR 0 26
115600: PUSH
115601: LD_VAR 0 4
115605: PUSH
115606: LD_VAR 0 7
115610: ARRAY
115611: PPUSH
115612: CALL_OW 257
115616: PUSH
115617: LD_INT 1
115619: EQUAL
115620: AND
115621: PUSH
115622: LD_VAR 0 4
115626: PUSH
115627: LD_VAR 0 7
115631: ARRAY
115632: PPUSH
115633: CALL_OW 256
115637: PUSH
115638: LD_INT 800
115640: LESS
115641: AND
115642: PUSH
115643: LD_VAR 0 4
115647: PUSH
115648: LD_VAR 0 7
115652: ARRAY
115653: PPUSH
115654: CALL_OW 318
115658: NOT
115659: AND
115660: IFFALSE 115677
// ComCrawl ( group [ i ] ) ;
115662: LD_VAR 0 4
115666: PUSH
115667: LD_VAR 0 7
115671: ARRAY
115672: PPUSH
115673: CALL_OW 137
// if f_mines then
115677: LD_VAR 0 21
115681: IFFALSE 115924
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115683: LD_VAR 0 14
115687: PUSH
115688: LD_INT 1
115690: ARRAY
115691: PPUSH
115692: CALL_OW 247
115696: PUSH
115697: LD_INT 3
115699: EQUAL
115700: PUSH
115701: LD_VAR 0 14
115705: PUSH
115706: LD_INT 1
115708: ARRAY
115709: PUSH
115710: LD_VAR 0 27
115714: IN
115715: NOT
115716: AND
115717: IFFALSE 115924
// begin x := GetX ( tmp [ 1 ] ) ;
115719: LD_ADDR_VAR 0 10
115723: PUSH
115724: LD_VAR 0 14
115728: PUSH
115729: LD_INT 1
115731: ARRAY
115732: PPUSH
115733: CALL_OW 250
115737: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115738: LD_ADDR_VAR 0 11
115742: PUSH
115743: LD_VAR 0 14
115747: PUSH
115748: LD_INT 1
115750: ARRAY
115751: PPUSH
115752: CALL_OW 251
115756: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115757: LD_ADDR_VAR 0 12
115761: PUSH
115762: LD_VAR 0 4
115766: PUSH
115767: LD_VAR 0 7
115771: ARRAY
115772: PPUSH
115773: CALL 82144 0 1
115777: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115778: LD_VAR 0 4
115782: PUSH
115783: LD_VAR 0 7
115787: ARRAY
115788: PPUSH
115789: LD_VAR 0 10
115793: PPUSH
115794: LD_VAR 0 11
115798: PPUSH
115799: LD_VAR 0 14
115803: PUSH
115804: LD_INT 1
115806: ARRAY
115807: PPUSH
115808: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115812: LD_VAR 0 4
115816: PUSH
115817: LD_VAR 0 7
115821: ARRAY
115822: PPUSH
115823: LD_VAR 0 10
115827: PPUSH
115828: LD_VAR 0 12
115832: PPUSH
115833: LD_INT 7
115835: PPUSH
115836: CALL_OW 272
115840: PPUSH
115841: LD_VAR 0 11
115845: PPUSH
115846: LD_VAR 0 12
115850: PPUSH
115851: LD_INT 7
115853: PPUSH
115854: CALL_OW 273
115858: PPUSH
115859: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115863: LD_VAR 0 4
115867: PUSH
115868: LD_VAR 0 7
115872: ARRAY
115873: PPUSH
115874: LD_INT 71
115876: PPUSH
115877: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115881: LD_ADDR_VAR 0 27
115885: PUSH
115886: LD_VAR 0 27
115890: PPUSH
115891: LD_VAR 0 27
115895: PUSH
115896: LD_INT 1
115898: PLUS
115899: PPUSH
115900: LD_VAR 0 14
115904: PUSH
115905: LD_INT 1
115907: ARRAY
115908: PPUSH
115909: CALL_OW 1
115913: ST_TO_ADDR
// attacking := true ;
115914: LD_ADDR_VAR 0 29
115918: PUSH
115919: LD_INT 1
115921: ST_TO_ADDR
// continue ;
115922: GO 113769
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115924: LD_VAR 0 4
115928: PUSH
115929: LD_VAR 0 7
115933: ARRAY
115934: PPUSH
115935: CALL_OW 257
115939: PUSH
115940: LD_INT 17
115942: EQUAL
115943: PUSH
115944: LD_VAR 0 4
115948: PUSH
115949: LD_VAR 0 7
115953: ARRAY
115954: PPUSH
115955: CALL_OW 110
115959: PUSH
115960: LD_INT 71
115962: EQUAL
115963: NOT
115964: AND
115965: IFFALSE 116111
// begin attacking := false ;
115967: LD_ADDR_VAR 0 29
115971: PUSH
115972: LD_INT 0
115974: ST_TO_ADDR
// k := 5 ;
115975: LD_ADDR_VAR 0 9
115979: PUSH
115980: LD_INT 5
115982: ST_TO_ADDR
// if tmp < k then
115983: LD_VAR 0 14
115987: PUSH
115988: LD_VAR 0 9
115992: LESS
115993: IFFALSE 116005
// k := tmp ;
115995: LD_ADDR_VAR 0 9
115999: PUSH
116000: LD_VAR 0 14
116004: ST_TO_ADDR
// for j = 1 to k do
116005: LD_ADDR_VAR 0 8
116009: PUSH
116010: DOUBLE
116011: LD_INT 1
116013: DEC
116014: ST_TO_ADDR
116015: LD_VAR 0 9
116019: PUSH
116020: FOR_TO
116021: IFFALSE 116109
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116023: LD_VAR 0 14
116027: PUSH
116028: LD_VAR 0 8
116032: ARRAY
116033: PUSH
116034: LD_VAR 0 14
116038: PPUSH
116039: LD_INT 58
116041: PUSH
116042: EMPTY
116043: LIST
116044: PPUSH
116045: CALL_OW 72
116049: IN
116050: NOT
116051: IFFALSE 116107
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116053: LD_VAR 0 4
116057: PUSH
116058: LD_VAR 0 7
116062: ARRAY
116063: PPUSH
116064: LD_VAR 0 14
116068: PUSH
116069: LD_VAR 0 8
116073: ARRAY
116074: PPUSH
116075: CALL_OW 115
// attacking := true ;
116079: LD_ADDR_VAR 0 29
116083: PUSH
116084: LD_INT 1
116086: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116087: LD_VAR 0 4
116091: PUSH
116092: LD_VAR 0 7
116096: ARRAY
116097: PPUSH
116098: LD_INT 71
116100: PPUSH
116101: CALL_OW 109
// continue ;
116105: GO 116020
// end ; end ;
116107: GO 116020
116109: POP
116110: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116111: LD_VAR 0 4
116115: PUSH
116116: LD_VAR 0 7
116120: ARRAY
116121: PPUSH
116122: CALL_OW 257
116126: PUSH
116127: LD_INT 8
116129: EQUAL
116130: PUSH
116131: LD_VAR 0 4
116135: PUSH
116136: LD_VAR 0 7
116140: ARRAY
116141: PPUSH
116142: CALL_OW 264
116146: PUSH
116147: LD_INT 28
116149: PUSH
116150: LD_INT 45
116152: PUSH
116153: LD_INT 7
116155: PUSH
116156: LD_INT 47
116158: PUSH
116159: EMPTY
116160: LIST
116161: LIST
116162: LIST
116163: LIST
116164: IN
116165: OR
116166: IFFALSE 116422
// begin attacking := false ;
116168: LD_ADDR_VAR 0 29
116172: PUSH
116173: LD_INT 0
116175: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116176: LD_VAR 0 14
116180: PUSH
116181: LD_INT 1
116183: ARRAY
116184: PPUSH
116185: CALL_OW 266
116189: PUSH
116190: LD_INT 32
116192: PUSH
116193: LD_INT 31
116195: PUSH
116196: LD_INT 33
116198: PUSH
116199: LD_INT 4
116201: PUSH
116202: LD_INT 5
116204: PUSH
116205: EMPTY
116206: LIST
116207: LIST
116208: LIST
116209: LIST
116210: LIST
116211: IN
116212: IFFALSE 116398
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116214: LD_ADDR_VAR 0 9
116218: PUSH
116219: LD_VAR 0 14
116223: PUSH
116224: LD_INT 1
116226: ARRAY
116227: PPUSH
116228: CALL_OW 266
116232: PPUSH
116233: LD_VAR 0 14
116237: PUSH
116238: LD_INT 1
116240: ARRAY
116241: PPUSH
116242: CALL_OW 250
116246: PPUSH
116247: LD_VAR 0 14
116251: PUSH
116252: LD_INT 1
116254: ARRAY
116255: PPUSH
116256: CALL_OW 251
116260: PPUSH
116261: LD_VAR 0 14
116265: PUSH
116266: LD_INT 1
116268: ARRAY
116269: PPUSH
116270: CALL_OW 254
116274: PPUSH
116275: LD_VAR 0 14
116279: PUSH
116280: LD_INT 1
116282: ARRAY
116283: PPUSH
116284: CALL_OW 248
116288: PPUSH
116289: LD_INT 0
116291: PPUSH
116292: CALL 63514 0 6
116296: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116297: LD_ADDR_VAR 0 8
116301: PUSH
116302: LD_VAR 0 4
116306: PUSH
116307: LD_VAR 0 7
116311: ARRAY
116312: PPUSH
116313: LD_VAR 0 9
116317: PPUSH
116318: CALL 82257 0 2
116322: ST_TO_ADDR
// if j then
116323: LD_VAR 0 8
116327: IFFALSE 116396
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116329: LD_VAR 0 8
116333: PUSH
116334: LD_INT 1
116336: ARRAY
116337: PPUSH
116338: LD_VAR 0 8
116342: PUSH
116343: LD_INT 2
116345: ARRAY
116346: PPUSH
116347: CALL_OW 488
116351: IFFALSE 116396
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116353: LD_VAR 0 4
116357: PUSH
116358: LD_VAR 0 7
116362: ARRAY
116363: PPUSH
116364: LD_VAR 0 8
116368: PUSH
116369: LD_INT 1
116371: ARRAY
116372: PPUSH
116373: LD_VAR 0 8
116377: PUSH
116378: LD_INT 2
116380: ARRAY
116381: PPUSH
116382: CALL_OW 116
// attacking := true ;
116386: LD_ADDR_VAR 0 29
116390: PUSH
116391: LD_INT 1
116393: ST_TO_ADDR
// continue ;
116394: GO 113769
// end ; end else
116396: GO 116422
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116398: LD_VAR 0 4
116402: PUSH
116403: LD_VAR 0 7
116407: ARRAY
116408: PPUSH
116409: LD_VAR 0 14
116413: PUSH
116414: LD_INT 1
116416: ARRAY
116417: PPUSH
116418: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116422: LD_VAR 0 4
116426: PUSH
116427: LD_VAR 0 7
116431: ARRAY
116432: PPUSH
116433: CALL_OW 265
116437: PUSH
116438: LD_INT 11
116440: EQUAL
116441: IFFALSE 116719
// begin k := 10 ;
116443: LD_ADDR_VAR 0 9
116447: PUSH
116448: LD_INT 10
116450: ST_TO_ADDR
// x := 0 ;
116451: LD_ADDR_VAR 0 10
116455: PUSH
116456: LD_INT 0
116458: ST_TO_ADDR
// if tmp < k then
116459: LD_VAR 0 14
116463: PUSH
116464: LD_VAR 0 9
116468: LESS
116469: IFFALSE 116481
// k := tmp ;
116471: LD_ADDR_VAR 0 9
116475: PUSH
116476: LD_VAR 0 14
116480: ST_TO_ADDR
// for j = k downto 1 do
116481: LD_ADDR_VAR 0 8
116485: PUSH
116486: DOUBLE
116487: LD_VAR 0 9
116491: INC
116492: ST_TO_ADDR
116493: LD_INT 1
116495: PUSH
116496: FOR_DOWNTO
116497: IFFALSE 116572
// begin if GetType ( tmp [ j ] ) = unit_human then
116499: LD_VAR 0 14
116503: PUSH
116504: LD_VAR 0 8
116508: ARRAY
116509: PPUSH
116510: CALL_OW 247
116514: PUSH
116515: LD_INT 1
116517: EQUAL
116518: IFFALSE 116570
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116520: LD_VAR 0 4
116524: PUSH
116525: LD_VAR 0 7
116529: ARRAY
116530: PPUSH
116531: LD_VAR 0 14
116535: PUSH
116536: LD_VAR 0 8
116540: ARRAY
116541: PPUSH
116542: CALL 82511 0 2
// x := tmp [ j ] ;
116546: LD_ADDR_VAR 0 10
116550: PUSH
116551: LD_VAR 0 14
116555: PUSH
116556: LD_VAR 0 8
116560: ARRAY
116561: ST_TO_ADDR
// attacking := true ;
116562: LD_ADDR_VAR 0 29
116566: PUSH
116567: LD_INT 1
116569: ST_TO_ADDR
// end ; end ;
116570: GO 116496
116572: POP
116573: POP
// if not x then
116574: LD_VAR 0 10
116578: NOT
116579: IFFALSE 116719
// begin attacking := true ;
116581: LD_ADDR_VAR 0 29
116585: PUSH
116586: LD_INT 1
116588: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116589: LD_VAR 0 4
116593: PUSH
116594: LD_VAR 0 7
116598: ARRAY
116599: PPUSH
116600: CALL_OW 250
116604: PPUSH
116605: LD_VAR 0 4
116609: PUSH
116610: LD_VAR 0 7
116614: ARRAY
116615: PPUSH
116616: CALL_OW 251
116620: PPUSH
116621: CALL_OW 546
116625: PUSH
116626: LD_INT 2
116628: ARRAY
116629: PUSH
116630: LD_VAR 0 14
116634: PUSH
116635: LD_INT 1
116637: ARRAY
116638: PPUSH
116639: CALL_OW 250
116643: PPUSH
116644: LD_VAR 0 14
116648: PUSH
116649: LD_INT 1
116651: ARRAY
116652: PPUSH
116653: CALL_OW 251
116657: PPUSH
116658: CALL_OW 546
116662: PUSH
116663: LD_INT 2
116665: ARRAY
116666: EQUAL
116667: IFFALSE 116695
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116669: LD_VAR 0 4
116673: PUSH
116674: LD_VAR 0 7
116678: ARRAY
116679: PPUSH
116680: LD_VAR 0 14
116684: PUSH
116685: LD_INT 1
116687: ARRAY
116688: PPUSH
116689: CALL 82511 0 2
116693: GO 116719
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116695: LD_VAR 0 4
116699: PUSH
116700: LD_VAR 0 7
116704: ARRAY
116705: PPUSH
116706: LD_VAR 0 14
116710: PUSH
116711: LD_INT 1
116713: ARRAY
116714: PPUSH
116715: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116719: LD_VAR 0 4
116723: PUSH
116724: LD_VAR 0 7
116728: ARRAY
116729: PPUSH
116730: CALL_OW 264
116734: PUSH
116735: LD_INT 29
116737: EQUAL
116738: IFFALSE 117104
// begin if WantsToAttack ( group [ i ] ) in bombed then
116740: LD_VAR 0 4
116744: PUSH
116745: LD_VAR 0 7
116749: ARRAY
116750: PPUSH
116751: CALL_OW 319
116755: PUSH
116756: LD_VAR 0 28
116760: IN
116761: IFFALSE 116765
// continue ;
116763: GO 113769
// k := 8 ;
116765: LD_ADDR_VAR 0 9
116769: PUSH
116770: LD_INT 8
116772: ST_TO_ADDR
// x := 0 ;
116773: LD_ADDR_VAR 0 10
116777: PUSH
116778: LD_INT 0
116780: ST_TO_ADDR
// if tmp < k then
116781: LD_VAR 0 14
116785: PUSH
116786: LD_VAR 0 9
116790: LESS
116791: IFFALSE 116803
// k := tmp ;
116793: LD_ADDR_VAR 0 9
116797: PUSH
116798: LD_VAR 0 14
116802: ST_TO_ADDR
// for j = 1 to k do
116803: LD_ADDR_VAR 0 8
116807: PUSH
116808: DOUBLE
116809: LD_INT 1
116811: DEC
116812: ST_TO_ADDR
116813: LD_VAR 0 9
116817: PUSH
116818: FOR_TO
116819: IFFALSE 116951
// begin if GetType ( tmp [ j ] ) = unit_building then
116821: LD_VAR 0 14
116825: PUSH
116826: LD_VAR 0 8
116830: ARRAY
116831: PPUSH
116832: CALL_OW 247
116836: PUSH
116837: LD_INT 3
116839: EQUAL
116840: IFFALSE 116949
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116842: LD_VAR 0 14
116846: PUSH
116847: LD_VAR 0 8
116851: ARRAY
116852: PUSH
116853: LD_VAR 0 28
116857: IN
116858: NOT
116859: PUSH
116860: LD_VAR 0 14
116864: PUSH
116865: LD_VAR 0 8
116869: ARRAY
116870: PPUSH
116871: CALL_OW 313
116875: AND
116876: IFFALSE 116949
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116878: LD_VAR 0 4
116882: PUSH
116883: LD_VAR 0 7
116887: ARRAY
116888: PPUSH
116889: LD_VAR 0 14
116893: PUSH
116894: LD_VAR 0 8
116898: ARRAY
116899: PPUSH
116900: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116904: LD_ADDR_VAR 0 28
116908: PUSH
116909: LD_VAR 0 28
116913: PPUSH
116914: LD_VAR 0 28
116918: PUSH
116919: LD_INT 1
116921: PLUS
116922: PPUSH
116923: LD_VAR 0 14
116927: PUSH
116928: LD_VAR 0 8
116932: ARRAY
116933: PPUSH
116934: CALL_OW 1
116938: ST_TO_ADDR
// attacking := true ;
116939: LD_ADDR_VAR 0 29
116943: PUSH
116944: LD_INT 1
116946: ST_TO_ADDR
// break ;
116947: GO 116951
// end ; end ;
116949: GO 116818
116951: POP
116952: POP
// if not attacking and f_attack_depot then
116953: LD_VAR 0 29
116957: NOT
116958: PUSH
116959: LD_VAR 0 25
116963: AND
116964: IFFALSE 117059
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116966: LD_ADDR_VAR 0 13
116970: PUSH
116971: LD_VAR 0 14
116975: PPUSH
116976: LD_INT 2
116978: PUSH
116979: LD_INT 30
116981: PUSH
116982: LD_INT 0
116984: PUSH
116985: EMPTY
116986: LIST
116987: LIST
116988: PUSH
116989: LD_INT 30
116991: PUSH
116992: LD_INT 1
116994: PUSH
116995: EMPTY
116996: LIST
116997: LIST
116998: PUSH
116999: EMPTY
117000: LIST
117001: LIST
117002: LIST
117003: PPUSH
117004: CALL_OW 72
117008: ST_TO_ADDR
// if z then
117009: LD_VAR 0 13
117013: IFFALSE 117059
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117015: LD_VAR 0 4
117019: PUSH
117020: LD_VAR 0 7
117024: ARRAY
117025: PPUSH
117026: LD_VAR 0 13
117030: PPUSH
117031: LD_VAR 0 4
117035: PUSH
117036: LD_VAR 0 7
117040: ARRAY
117041: PPUSH
117042: CALL_OW 74
117046: PPUSH
117047: CALL_OW 115
// attacking := true ;
117051: LD_ADDR_VAR 0 29
117055: PUSH
117056: LD_INT 1
117058: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117059: LD_VAR 0 4
117063: PUSH
117064: LD_VAR 0 7
117068: ARRAY
117069: PPUSH
117070: CALL_OW 256
117074: PUSH
117075: LD_INT 500
117077: LESS
117078: IFFALSE 117104
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117080: LD_VAR 0 4
117084: PUSH
117085: LD_VAR 0 7
117089: ARRAY
117090: PPUSH
117091: LD_VAR 0 14
117095: PUSH
117096: LD_INT 1
117098: ARRAY
117099: PPUSH
117100: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117104: LD_VAR 0 4
117108: PUSH
117109: LD_VAR 0 7
117113: ARRAY
117114: PPUSH
117115: CALL_OW 264
117119: PUSH
117120: LD_INT 49
117122: EQUAL
117123: IFFALSE 117244
// begin if not HasTask ( group [ i ] ) then
117125: LD_VAR 0 4
117129: PUSH
117130: LD_VAR 0 7
117134: ARRAY
117135: PPUSH
117136: CALL_OW 314
117140: NOT
117141: IFFALSE 117244
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117143: LD_ADDR_VAR 0 9
117147: PUSH
117148: LD_INT 81
117150: PUSH
117151: LD_VAR 0 4
117155: PUSH
117156: LD_VAR 0 7
117160: ARRAY
117161: PPUSH
117162: CALL_OW 255
117166: PUSH
117167: EMPTY
117168: LIST
117169: LIST
117170: PPUSH
117171: CALL_OW 69
117175: PPUSH
117176: LD_VAR 0 4
117180: PUSH
117181: LD_VAR 0 7
117185: ARRAY
117186: PPUSH
117187: CALL_OW 74
117191: ST_TO_ADDR
// if k then
117192: LD_VAR 0 9
117196: IFFALSE 117244
// if GetDistUnits ( group [ i ] , k ) > 10 then
117198: LD_VAR 0 4
117202: PUSH
117203: LD_VAR 0 7
117207: ARRAY
117208: PPUSH
117209: LD_VAR 0 9
117213: PPUSH
117214: CALL_OW 296
117218: PUSH
117219: LD_INT 10
117221: GREATER
117222: IFFALSE 117244
// ComMoveUnit ( group [ i ] , k ) ;
117224: LD_VAR 0 4
117228: PUSH
117229: LD_VAR 0 7
117233: ARRAY
117234: PPUSH
117235: LD_VAR 0 9
117239: PPUSH
117240: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117244: LD_VAR 0 4
117248: PUSH
117249: LD_VAR 0 7
117253: ARRAY
117254: PPUSH
117255: CALL_OW 256
117259: PUSH
117260: LD_INT 250
117262: LESS
117263: PUSH
117264: LD_VAR 0 4
117268: PUSH
117269: LD_VAR 0 7
117273: ARRAY
117274: PUSH
117275: LD_INT 21
117277: PUSH
117278: LD_INT 2
117280: PUSH
117281: EMPTY
117282: LIST
117283: LIST
117284: PUSH
117285: LD_INT 23
117287: PUSH
117288: LD_INT 2
117290: PUSH
117291: EMPTY
117292: LIST
117293: LIST
117294: PUSH
117295: EMPTY
117296: LIST
117297: LIST
117298: PPUSH
117299: CALL_OW 69
117303: IN
117304: AND
117305: IFFALSE 117430
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117307: LD_ADDR_VAR 0 9
117311: PUSH
117312: LD_OWVAR 3
117316: PUSH
117317: LD_VAR 0 4
117321: PUSH
117322: LD_VAR 0 7
117326: ARRAY
117327: DIFF
117328: PPUSH
117329: LD_VAR 0 4
117333: PUSH
117334: LD_VAR 0 7
117338: ARRAY
117339: PPUSH
117340: CALL_OW 74
117344: ST_TO_ADDR
// if not k then
117345: LD_VAR 0 9
117349: NOT
117350: IFFALSE 117354
// continue ;
117352: GO 113769
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117354: LD_VAR 0 9
117358: PUSH
117359: LD_INT 81
117361: PUSH
117362: LD_VAR 0 4
117366: PUSH
117367: LD_VAR 0 7
117371: ARRAY
117372: PPUSH
117373: CALL_OW 255
117377: PUSH
117378: EMPTY
117379: LIST
117380: LIST
117381: PPUSH
117382: CALL_OW 69
117386: IN
117387: PUSH
117388: LD_VAR 0 9
117392: PPUSH
117393: LD_VAR 0 4
117397: PUSH
117398: LD_VAR 0 7
117402: ARRAY
117403: PPUSH
117404: CALL_OW 296
117408: PUSH
117409: LD_INT 5
117411: LESS
117412: AND
117413: IFFALSE 117430
// ComAutodestruct ( group [ i ] ) ;
117415: LD_VAR 0 4
117419: PUSH
117420: LD_VAR 0 7
117424: ARRAY
117425: PPUSH
117426: CALL 82409 0 1
// end ; if f_attack_depot then
117430: LD_VAR 0 25
117434: IFFALSE 117546
// begin k := 6 ;
117436: LD_ADDR_VAR 0 9
117440: PUSH
117441: LD_INT 6
117443: ST_TO_ADDR
// if tmp < k then
117444: LD_VAR 0 14
117448: PUSH
117449: LD_VAR 0 9
117453: LESS
117454: IFFALSE 117466
// k := tmp ;
117456: LD_ADDR_VAR 0 9
117460: PUSH
117461: LD_VAR 0 14
117465: ST_TO_ADDR
// for j = 1 to k do
117466: LD_ADDR_VAR 0 8
117470: PUSH
117471: DOUBLE
117472: LD_INT 1
117474: DEC
117475: ST_TO_ADDR
117476: LD_VAR 0 9
117480: PUSH
117481: FOR_TO
117482: IFFALSE 117544
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117484: LD_VAR 0 8
117488: PPUSH
117489: CALL_OW 266
117493: PUSH
117494: LD_INT 0
117496: PUSH
117497: LD_INT 1
117499: PUSH
117500: EMPTY
117501: LIST
117502: LIST
117503: IN
117504: IFFALSE 117542
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117506: LD_VAR 0 4
117510: PUSH
117511: LD_VAR 0 7
117515: ARRAY
117516: PPUSH
117517: LD_VAR 0 14
117521: PUSH
117522: LD_VAR 0 8
117526: ARRAY
117527: PPUSH
117528: CALL_OW 115
// attacking := true ;
117532: LD_ADDR_VAR 0 29
117536: PUSH
117537: LD_INT 1
117539: ST_TO_ADDR
// break ;
117540: GO 117544
// end ;
117542: GO 117481
117544: POP
117545: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117546: LD_VAR 0 4
117550: PUSH
117551: LD_VAR 0 7
117555: ARRAY
117556: PPUSH
117557: CALL_OW 302
117561: PUSH
117562: LD_VAR 0 29
117566: NOT
117567: AND
117568: IFFALSE 117890
// begin if GetTag ( group [ i ] ) = 71 then
117570: LD_VAR 0 4
117574: PUSH
117575: LD_VAR 0 7
117579: ARRAY
117580: PPUSH
117581: CALL_OW 110
117585: PUSH
117586: LD_INT 71
117588: EQUAL
117589: IFFALSE 117630
// begin if HasTask ( group [ i ] ) then
117591: LD_VAR 0 4
117595: PUSH
117596: LD_VAR 0 7
117600: ARRAY
117601: PPUSH
117602: CALL_OW 314
117606: IFFALSE 117612
// continue else
117608: GO 113769
117610: GO 117630
// SetTag ( group [ i ] , 0 ) ;
117612: LD_VAR 0 4
117616: PUSH
117617: LD_VAR 0 7
117621: ARRAY
117622: PPUSH
117623: LD_INT 0
117625: PPUSH
117626: CALL_OW 109
// end ; k := 8 ;
117630: LD_ADDR_VAR 0 9
117634: PUSH
117635: LD_INT 8
117637: ST_TO_ADDR
// x := 0 ;
117638: LD_ADDR_VAR 0 10
117642: PUSH
117643: LD_INT 0
117645: ST_TO_ADDR
// if tmp < k then
117646: LD_VAR 0 14
117650: PUSH
117651: LD_VAR 0 9
117655: LESS
117656: IFFALSE 117668
// k := tmp ;
117658: LD_ADDR_VAR 0 9
117662: PUSH
117663: LD_VAR 0 14
117667: ST_TO_ADDR
// for j = 1 to k do
117668: LD_ADDR_VAR 0 8
117672: PUSH
117673: DOUBLE
117674: LD_INT 1
117676: DEC
117677: ST_TO_ADDR
117678: LD_VAR 0 9
117682: PUSH
117683: FOR_TO
117684: IFFALSE 117782
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117686: LD_VAR 0 14
117690: PUSH
117691: LD_VAR 0 8
117695: ARRAY
117696: PPUSH
117697: CALL_OW 247
117701: PUSH
117702: LD_INT 1
117704: EQUAL
117705: PUSH
117706: LD_VAR 0 14
117710: PUSH
117711: LD_VAR 0 8
117715: ARRAY
117716: PPUSH
117717: CALL_OW 256
117721: PUSH
117722: LD_INT 250
117724: LESS
117725: PUSH
117726: LD_VAR 0 20
117730: AND
117731: PUSH
117732: LD_VAR 0 20
117736: NOT
117737: PUSH
117738: LD_VAR 0 14
117742: PUSH
117743: LD_VAR 0 8
117747: ARRAY
117748: PPUSH
117749: CALL_OW 256
117753: PUSH
117754: LD_INT 250
117756: GREATEREQUAL
117757: AND
117758: OR
117759: AND
117760: IFFALSE 117780
// begin x := tmp [ j ] ;
117762: LD_ADDR_VAR 0 10
117766: PUSH
117767: LD_VAR 0 14
117771: PUSH
117772: LD_VAR 0 8
117776: ARRAY
117777: ST_TO_ADDR
// break ;
117778: GO 117782
// end ;
117780: GO 117683
117782: POP
117783: POP
// if x then
117784: LD_VAR 0 10
117788: IFFALSE 117812
// ComAttackUnit ( group [ i ] , x ) else
117790: LD_VAR 0 4
117794: PUSH
117795: LD_VAR 0 7
117799: ARRAY
117800: PPUSH
117801: LD_VAR 0 10
117805: PPUSH
117806: CALL_OW 115
117810: GO 117836
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117812: LD_VAR 0 4
117816: PUSH
117817: LD_VAR 0 7
117821: ARRAY
117822: PPUSH
117823: LD_VAR 0 14
117827: PUSH
117828: LD_INT 1
117830: ARRAY
117831: PPUSH
117832: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117836: LD_VAR 0 4
117840: PUSH
117841: LD_VAR 0 7
117845: ARRAY
117846: PPUSH
117847: CALL_OW 314
117851: NOT
117852: IFFALSE 117890
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117854: LD_VAR 0 4
117858: PUSH
117859: LD_VAR 0 7
117863: ARRAY
117864: PPUSH
117865: LD_VAR 0 14
117869: PPUSH
117870: LD_VAR 0 4
117874: PUSH
117875: LD_VAR 0 7
117879: ARRAY
117880: PPUSH
117881: CALL_OW 74
117885: PPUSH
117886: CALL_OW 115
// end ; end ; end ;
117890: GO 113769
117892: POP
117893: POP
// wait ( 0 0$2 ) ;
117894: LD_INT 70
117896: PPUSH
117897: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117901: LD_VAR 0 4
117905: NOT
117906: PUSH
117907: LD_VAR 0 4
117911: PUSH
117912: EMPTY
117913: EQUAL
117914: OR
117915: PUSH
117916: LD_INT 81
117918: PUSH
117919: LD_VAR 0 35
117923: PUSH
117924: EMPTY
117925: LIST
117926: LIST
117927: PPUSH
117928: CALL_OW 69
117932: NOT
117933: OR
117934: IFFALSE 113754
// end ;
117936: LD_VAR 0 2
117940: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117941: LD_INT 0
117943: PPUSH
117944: PPUSH
117945: PPUSH
117946: PPUSH
117947: PPUSH
117948: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117949: LD_VAR 0 1
117953: NOT
117954: PUSH
117955: LD_EXP 50
117959: PUSH
117960: LD_VAR 0 1
117964: ARRAY
117965: NOT
117966: OR
117967: PUSH
117968: LD_VAR 0 2
117972: NOT
117973: OR
117974: IFFALSE 117978
// exit ;
117976: GO 118532
// side := mc_sides [ base ] ;
117978: LD_ADDR_VAR 0 6
117982: PUSH
117983: LD_EXP 76
117987: PUSH
117988: LD_VAR 0 1
117992: ARRAY
117993: ST_TO_ADDR
// if not side then
117994: LD_VAR 0 6
117998: NOT
117999: IFFALSE 118003
// exit ;
118001: GO 118532
// for i in solds do
118003: LD_ADDR_VAR 0 7
118007: PUSH
118008: LD_VAR 0 2
118012: PUSH
118013: FOR_IN
118014: IFFALSE 118075
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118016: LD_VAR 0 7
118020: PPUSH
118021: CALL_OW 310
118025: PPUSH
118026: CALL_OW 266
118030: PUSH
118031: LD_INT 32
118033: PUSH
118034: LD_INT 31
118036: PUSH
118037: EMPTY
118038: LIST
118039: LIST
118040: IN
118041: IFFALSE 118061
// solds := solds diff i else
118043: LD_ADDR_VAR 0 2
118047: PUSH
118048: LD_VAR 0 2
118052: PUSH
118053: LD_VAR 0 7
118057: DIFF
118058: ST_TO_ADDR
118059: GO 118073
// SetTag ( i , 18 ) ;
118061: LD_VAR 0 7
118065: PPUSH
118066: LD_INT 18
118068: PPUSH
118069: CALL_OW 109
118073: GO 118013
118075: POP
118076: POP
// if not solds then
118077: LD_VAR 0 2
118081: NOT
118082: IFFALSE 118086
// exit ;
118084: GO 118532
// repeat wait ( 0 0$2 ) ;
118086: LD_INT 70
118088: PPUSH
118089: CALL_OW 67
// enemy := mc_scan [ base ] ;
118093: LD_ADDR_VAR 0 4
118097: PUSH
118098: LD_EXP 73
118102: PUSH
118103: LD_VAR 0 1
118107: ARRAY
118108: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118109: LD_EXP 50
118113: PUSH
118114: LD_VAR 0 1
118118: ARRAY
118119: NOT
118120: PUSH
118121: LD_EXP 50
118125: PUSH
118126: LD_VAR 0 1
118130: ARRAY
118131: PUSH
118132: EMPTY
118133: EQUAL
118134: OR
118135: IFFALSE 118172
// begin for i in solds do
118137: LD_ADDR_VAR 0 7
118141: PUSH
118142: LD_VAR 0 2
118146: PUSH
118147: FOR_IN
118148: IFFALSE 118161
// ComStop ( i ) ;
118150: LD_VAR 0 7
118154: PPUSH
118155: CALL_OW 141
118159: GO 118147
118161: POP
118162: POP
// solds := [ ] ;
118163: LD_ADDR_VAR 0 2
118167: PUSH
118168: EMPTY
118169: ST_TO_ADDR
// exit ;
118170: GO 118532
// end ; for i in solds do
118172: LD_ADDR_VAR 0 7
118176: PUSH
118177: LD_VAR 0 2
118181: PUSH
118182: FOR_IN
118183: IFFALSE 118504
// begin if IsInUnit ( i ) then
118185: LD_VAR 0 7
118189: PPUSH
118190: CALL_OW 310
118194: IFFALSE 118205
// ComExitBuilding ( i ) ;
118196: LD_VAR 0 7
118200: PPUSH
118201: CALL_OW 122
// if GetLives ( i ) > 500 then
118205: LD_VAR 0 7
118209: PPUSH
118210: CALL_OW 256
118214: PUSH
118215: LD_INT 500
118217: GREATER
118218: IFFALSE 118271
// begin e := NearestUnitToUnit ( enemy , i ) ;
118220: LD_ADDR_VAR 0 5
118224: PUSH
118225: LD_VAR 0 4
118229: PPUSH
118230: LD_VAR 0 7
118234: PPUSH
118235: CALL_OW 74
118239: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118240: LD_VAR 0 7
118244: PPUSH
118245: LD_VAR 0 5
118249: PPUSH
118250: CALL_OW 250
118254: PPUSH
118255: LD_VAR 0 5
118259: PPUSH
118260: CALL_OW 251
118264: PPUSH
118265: CALL_OW 114
// end else
118269: GO 118502
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118271: LD_VAR 0 7
118275: PPUSH
118276: LD_EXP 50
118280: PUSH
118281: LD_VAR 0 1
118285: ARRAY
118286: PPUSH
118287: LD_INT 2
118289: PUSH
118290: LD_INT 30
118292: PUSH
118293: LD_INT 0
118295: PUSH
118296: EMPTY
118297: LIST
118298: LIST
118299: PUSH
118300: LD_INT 30
118302: PUSH
118303: LD_INT 1
118305: PUSH
118306: EMPTY
118307: LIST
118308: LIST
118309: PUSH
118310: LD_INT 30
118312: PUSH
118313: LD_INT 6
118315: PUSH
118316: EMPTY
118317: LIST
118318: LIST
118319: PUSH
118320: EMPTY
118321: LIST
118322: LIST
118323: LIST
118324: LIST
118325: PPUSH
118326: CALL_OW 72
118330: PPUSH
118331: LD_VAR 0 7
118335: PPUSH
118336: CALL_OW 74
118340: PPUSH
118341: CALL_OW 296
118345: PUSH
118346: LD_INT 10
118348: GREATER
118349: IFFALSE 118502
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118351: LD_ADDR_VAR 0 8
118355: PUSH
118356: LD_EXP 50
118360: PUSH
118361: LD_VAR 0 1
118365: ARRAY
118366: PPUSH
118367: LD_INT 2
118369: PUSH
118370: LD_INT 30
118372: PUSH
118373: LD_INT 0
118375: PUSH
118376: EMPTY
118377: LIST
118378: LIST
118379: PUSH
118380: LD_INT 30
118382: PUSH
118383: LD_INT 1
118385: PUSH
118386: EMPTY
118387: LIST
118388: LIST
118389: PUSH
118390: LD_INT 30
118392: PUSH
118393: LD_INT 6
118395: PUSH
118396: EMPTY
118397: LIST
118398: LIST
118399: PUSH
118400: EMPTY
118401: LIST
118402: LIST
118403: LIST
118404: LIST
118405: PPUSH
118406: CALL_OW 72
118410: PPUSH
118411: LD_VAR 0 7
118415: PPUSH
118416: CALL_OW 74
118420: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118421: LD_VAR 0 7
118425: PPUSH
118426: LD_VAR 0 8
118430: PPUSH
118431: CALL_OW 250
118435: PPUSH
118436: LD_INT 3
118438: PPUSH
118439: LD_INT 5
118441: PPUSH
118442: CALL_OW 272
118446: PPUSH
118447: LD_VAR 0 8
118451: PPUSH
118452: CALL_OW 251
118456: PPUSH
118457: LD_INT 3
118459: PPUSH
118460: LD_INT 5
118462: PPUSH
118463: CALL_OW 273
118467: PPUSH
118468: CALL_OW 111
// SetTag ( i , 0 ) ;
118472: LD_VAR 0 7
118476: PPUSH
118477: LD_INT 0
118479: PPUSH
118480: CALL_OW 109
// solds := solds diff i ;
118484: LD_ADDR_VAR 0 2
118488: PUSH
118489: LD_VAR 0 2
118493: PUSH
118494: LD_VAR 0 7
118498: DIFF
118499: ST_TO_ADDR
// continue ;
118500: GO 118182
// end ; end ;
118502: GO 118182
118504: POP
118505: POP
// until not solds or not enemy ;
118506: LD_VAR 0 2
118510: NOT
118511: PUSH
118512: LD_VAR 0 4
118516: NOT
118517: OR
118518: IFFALSE 118086
// MC_Reset ( base , 18 ) ;
118520: LD_VAR 0 1
118524: PPUSH
118525: LD_INT 18
118527: PPUSH
118528: CALL 22646 0 2
// end ;
118532: LD_VAR 0 3
118536: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118537: LD_INT 0
118539: PPUSH
118540: PPUSH
118541: PPUSH
118542: PPUSH
118543: PPUSH
118544: PPUSH
118545: PPUSH
118546: PPUSH
118547: PPUSH
118548: PPUSH
118549: PPUSH
118550: PPUSH
118551: PPUSH
118552: PPUSH
118553: PPUSH
118554: PPUSH
118555: PPUSH
118556: PPUSH
118557: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118558: LD_ADDR_VAR 0 12
118562: PUSH
118563: LD_EXP 50
118567: PUSH
118568: LD_VAR 0 1
118572: ARRAY
118573: PPUSH
118574: LD_INT 25
118576: PUSH
118577: LD_INT 3
118579: PUSH
118580: EMPTY
118581: LIST
118582: LIST
118583: PPUSH
118584: CALL_OW 72
118588: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118589: LD_EXP 90
118593: PUSH
118594: LD_VAR 0 1
118598: ARRAY
118599: IFFALSE 118623
// mechs := mechs diff mc_remote_driver [ base ] ;
118601: LD_ADDR_VAR 0 12
118605: PUSH
118606: LD_VAR 0 12
118610: PUSH
118611: LD_EXP 90
118615: PUSH
118616: LD_VAR 0 1
118620: ARRAY
118621: DIFF
118622: ST_TO_ADDR
// for i in mechs do
118623: LD_ADDR_VAR 0 4
118627: PUSH
118628: LD_VAR 0 12
118632: PUSH
118633: FOR_IN
118634: IFFALSE 118669
// if GetTag ( i ) > 0 then
118636: LD_VAR 0 4
118640: PPUSH
118641: CALL_OW 110
118645: PUSH
118646: LD_INT 0
118648: GREATER
118649: IFFALSE 118667
// mechs := mechs diff i ;
118651: LD_ADDR_VAR 0 12
118655: PUSH
118656: LD_VAR 0 12
118660: PUSH
118661: LD_VAR 0 4
118665: DIFF
118666: ST_TO_ADDR
118667: GO 118633
118669: POP
118670: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118671: LD_ADDR_VAR 0 8
118675: PUSH
118676: LD_EXP 50
118680: PUSH
118681: LD_VAR 0 1
118685: ARRAY
118686: PPUSH
118687: LD_INT 2
118689: PUSH
118690: LD_INT 25
118692: PUSH
118693: LD_INT 1
118695: PUSH
118696: EMPTY
118697: LIST
118698: LIST
118699: PUSH
118700: LD_INT 25
118702: PUSH
118703: LD_INT 5
118705: PUSH
118706: EMPTY
118707: LIST
118708: LIST
118709: PUSH
118710: LD_INT 25
118712: PUSH
118713: LD_INT 8
118715: PUSH
118716: EMPTY
118717: LIST
118718: LIST
118719: PUSH
118720: LD_INT 25
118722: PUSH
118723: LD_INT 9
118725: PUSH
118726: EMPTY
118727: LIST
118728: LIST
118729: PUSH
118730: EMPTY
118731: LIST
118732: LIST
118733: LIST
118734: LIST
118735: LIST
118736: PPUSH
118737: CALL_OW 72
118741: ST_TO_ADDR
// if not defenders and not solds then
118742: LD_VAR 0 2
118746: NOT
118747: PUSH
118748: LD_VAR 0 8
118752: NOT
118753: AND
118754: IFFALSE 118758
// exit ;
118756: GO 120528
// depot_under_attack := false ;
118758: LD_ADDR_VAR 0 16
118762: PUSH
118763: LD_INT 0
118765: ST_TO_ADDR
// sold_defenders := [ ] ;
118766: LD_ADDR_VAR 0 17
118770: PUSH
118771: EMPTY
118772: ST_TO_ADDR
// if mechs then
118773: LD_VAR 0 12
118777: IFFALSE 118930
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118779: LD_ADDR_VAR 0 4
118783: PUSH
118784: LD_VAR 0 2
118788: PPUSH
118789: LD_INT 21
118791: PUSH
118792: LD_INT 2
118794: PUSH
118795: EMPTY
118796: LIST
118797: LIST
118798: PPUSH
118799: CALL_OW 72
118803: PUSH
118804: FOR_IN
118805: IFFALSE 118928
// begin if GetTag ( i ) <> 20 then
118807: LD_VAR 0 4
118811: PPUSH
118812: CALL_OW 110
118816: PUSH
118817: LD_INT 20
118819: NONEQUAL
118820: IFFALSE 118834
// SetTag ( i , 20 ) ;
118822: LD_VAR 0 4
118826: PPUSH
118827: LD_INT 20
118829: PPUSH
118830: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118834: LD_VAR 0 4
118838: PPUSH
118839: CALL_OW 263
118843: PUSH
118844: LD_INT 1
118846: EQUAL
118847: PUSH
118848: LD_VAR 0 4
118852: PPUSH
118853: CALL_OW 311
118857: NOT
118858: AND
118859: IFFALSE 118926
// begin un := mechs [ 1 ] ;
118861: LD_ADDR_VAR 0 10
118865: PUSH
118866: LD_VAR 0 12
118870: PUSH
118871: LD_INT 1
118873: ARRAY
118874: ST_TO_ADDR
// ComExit ( un ) ;
118875: LD_VAR 0 10
118879: PPUSH
118880: CALL 87315 0 1
// AddComEnterUnit ( un , i ) ;
118884: LD_VAR 0 10
118888: PPUSH
118889: LD_VAR 0 4
118893: PPUSH
118894: CALL_OW 180
// SetTag ( un , 19 ) ;
118898: LD_VAR 0 10
118902: PPUSH
118903: LD_INT 19
118905: PPUSH
118906: CALL_OW 109
// mechs := mechs diff un ;
118910: LD_ADDR_VAR 0 12
118914: PUSH
118915: LD_VAR 0 12
118919: PUSH
118920: LD_VAR 0 10
118924: DIFF
118925: ST_TO_ADDR
// end ; end ;
118926: GO 118804
118928: POP
118929: POP
// if solds then
118930: LD_VAR 0 8
118934: IFFALSE 118993
// for i in solds do
118936: LD_ADDR_VAR 0 4
118940: PUSH
118941: LD_VAR 0 8
118945: PUSH
118946: FOR_IN
118947: IFFALSE 118991
// if not GetTag ( i ) then
118949: LD_VAR 0 4
118953: PPUSH
118954: CALL_OW 110
118958: NOT
118959: IFFALSE 118989
// begin defenders := defenders union i ;
118961: LD_ADDR_VAR 0 2
118965: PUSH
118966: LD_VAR 0 2
118970: PUSH
118971: LD_VAR 0 4
118975: UNION
118976: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118977: LD_VAR 0 4
118981: PPUSH
118982: LD_INT 18
118984: PPUSH
118985: CALL_OW 109
// end ;
118989: GO 118946
118991: POP
118992: POP
// repeat wait ( 0 0$2 ) ;
118993: LD_INT 70
118995: PPUSH
118996: CALL_OW 67
// enemy := mc_scan [ base ] ;
119000: LD_ADDR_VAR 0 21
119004: PUSH
119005: LD_EXP 73
119009: PUSH
119010: LD_VAR 0 1
119014: ARRAY
119015: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119016: LD_EXP 50
119020: PUSH
119021: LD_VAR 0 1
119025: ARRAY
119026: NOT
119027: PUSH
119028: LD_EXP 50
119032: PUSH
119033: LD_VAR 0 1
119037: ARRAY
119038: PUSH
119039: EMPTY
119040: EQUAL
119041: OR
119042: IFFALSE 119079
// begin for i in defenders do
119044: LD_ADDR_VAR 0 4
119048: PUSH
119049: LD_VAR 0 2
119053: PUSH
119054: FOR_IN
119055: IFFALSE 119068
// ComStop ( i ) ;
119057: LD_VAR 0 4
119061: PPUSH
119062: CALL_OW 141
119066: GO 119054
119068: POP
119069: POP
// defenders := [ ] ;
119070: LD_ADDR_VAR 0 2
119074: PUSH
119075: EMPTY
119076: ST_TO_ADDR
// exit ;
119077: GO 120528
// end ; for i in defenders do
119079: LD_ADDR_VAR 0 4
119083: PUSH
119084: LD_VAR 0 2
119088: PUSH
119089: FOR_IN
119090: IFFALSE 119988
// begin e := NearestUnitToUnit ( enemy , i ) ;
119092: LD_ADDR_VAR 0 13
119096: PUSH
119097: LD_VAR 0 21
119101: PPUSH
119102: LD_VAR 0 4
119106: PPUSH
119107: CALL_OW 74
119111: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119112: LD_ADDR_VAR 0 7
119116: PUSH
119117: LD_EXP 50
119121: PUSH
119122: LD_VAR 0 1
119126: ARRAY
119127: PPUSH
119128: LD_INT 2
119130: PUSH
119131: LD_INT 30
119133: PUSH
119134: LD_INT 0
119136: PUSH
119137: EMPTY
119138: LIST
119139: LIST
119140: PUSH
119141: LD_INT 30
119143: PUSH
119144: LD_INT 1
119146: PUSH
119147: EMPTY
119148: LIST
119149: LIST
119150: PUSH
119151: EMPTY
119152: LIST
119153: LIST
119154: LIST
119155: PPUSH
119156: CALL_OW 72
119160: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119161: LD_ADDR_VAR 0 16
119165: PUSH
119166: LD_VAR 0 7
119170: NOT
119171: PUSH
119172: LD_VAR 0 7
119176: PPUSH
119177: LD_INT 3
119179: PUSH
119180: LD_INT 24
119182: PUSH
119183: LD_INT 600
119185: PUSH
119186: EMPTY
119187: LIST
119188: LIST
119189: PUSH
119190: EMPTY
119191: LIST
119192: LIST
119193: PPUSH
119194: CALL_OW 72
119198: OR
119199: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119200: LD_VAR 0 4
119204: PPUSH
119205: CALL_OW 247
119209: PUSH
119210: LD_INT 2
119212: DOUBLE
119213: EQUAL
119214: IFTRUE 119218
119216: GO 119614
119218: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119219: LD_VAR 0 4
119223: PPUSH
119224: CALL_OW 256
119228: PUSH
119229: LD_INT 1000
119231: EQUAL
119232: PUSH
119233: LD_VAR 0 4
119237: PPUSH
119238: LD_VAR 0 13
119242: PPUSH
119243: CALL_OW 296
119247: PUSH
119248: LD_INT 40
119250: LESS
119251: PUSH
119252: LD_VAR 0 13
119256: PPUSH
119257: LD_EXP 75
119261: PUSH
119262: LD_VAR 0 1
119266: ARRAY
119267: PPUSH
119268: CALL_OW 308
119272: OR
119273: AND
119274: IFFALSE 119396
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119276: LD_VAR 0 4
119280: PPUSH
119281: CALL_OW 262
119285: PUSH
119286: LD_INT 1
119288: EQUAL
119289: PUSH
119290: LD_VAR 0 4
119294: PPUSH
119295: CALL_OW 261
119299: PUSH
119300: LD_INT 30
119302: LESS
119303: AND
119304: PUSH
119305: LD_VAR 0 7
119309: AND
119310: IFFALSE 119380
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119312: LD_VAR 0 4
119316: PPUSH
119317: LD_VAR 0 7
119321: PPUSH
119322: LD_VAR 0 4
119326: PPUSH
119327: CALL_OW 74
119331: PPUSH
119332: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119336: LD_VAR 0 4
119340: PPUSH
119341: LD_VAR 0 7
119345: PPUSH
119346: LD_VAR 0 4
119350: PPUSH
119351: CALL_OW 74
119355: PPUSH
119356: CALL_OW 296
119360: PUSH
119361: LD_INT 6
119363: LESS
119364: IFFALSE 119378
// SetFuel ( i , 100 ) ;
119366: LD_VAR 0 4
119370: PPUSH
119371: LD_INT 100
119373: PPUSH
119374: CALL_OW 240
// end else
119378: GO 119394
// ComAttackUnit ( i , e ) ;
119380: LD_VAR 0 4
119384: PPUSH
119385: LD_VAR 0 13
119389: PPUSH
119390: CALL_OW 115
// end else
119394: GO 119497
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119396: LD_VAR 0 13
119400: PPUSH
119401: LD_EXP 75
119405: PUSH
119406: LD_VAR 0 1
119410: ARRAY
119411: PPUSH
119412: CALL_OW 308
119416: NOT
119417: PUSH
119418: LD_VAR 0 4
119422: PPUSH
119423: LD_VAR 0 13
119427: PPUSH
119428: CALL_OW 296
119432: PUSH
119433: LD_INT 40
119435: GREATEREQUAL
119436: AND
119437: PUSH
119438: LD_VAR 0 4
119442: PPUSH
119443: CALL_OW 256
119447: PUSH
119448: LD_INT 650
119450: LESSEQUAL
119451: OR
119452: PUSH
119453: LD_VAR 0 4
119457: PPUSH
119458: LD_EXP 74
119462: PUSH
119463: LD_VAR 0 1
119467: ARRAY
119468: PPUSH
119469: CALL_OW 308
119473: NOT
119474: AND
119475: IFFALSE 119497
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119477: LD_VAR 0 4
119481: PPUSH
119482: LD_EXP 74
119486: PUSH
119487: LD_VAR 0 1
119491: ARRAY
119492: PPUSH
119493: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119497: LD_VAR 0 4
119501: PPUSH
119502: CALL_OW 256
119506: PUSH
119507: LD_INT 1000
119509: LESS
119510: PUSH
119511: LD_VAR 0 4
119515: PPUSH
119516: CALL_OW 263
119520: PUSH
119521: LD_INT 1
119523: EQUAL
119524: AND
119525: PUSH
119526: LD_VAR 0 4
119530: PPUSH
119531: CALL_OW 311
119535: AND
119536: PUSH
119537: LD_VAR 0 4
119541: PPUSH
119542: LD_EXP 74
119546: PUSH
119547: LD_VAR 0 1
119551: ARRAY
119552: PPUSH
119553: CALL_OW 308
119557: AND
119558: IFFALSE 119612
// begin mech := IsDrivenBy ( i ) ;
119560: LD_ADDR_VAR 0 9
119564: PUSH
119565: LD_VAR 0 4
119569: PPUSH
119570: CALL_OW 311
119574: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119575: LD_VAR 0 9
119579: PPUSH
119580: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119584: LD_VAR 0 9
119588: PPUSH
119589: LD_VAR 0 4
119593: PPUSH
119594: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119598: LD_VAR 0 9
119602: PPUSH
119603: LD_VAR 0 4
119607: PPUSH
119608: CALL_OW 180
// end ; end ; unit_human :
119612: GO 119959
119614: LD_INT 1
119616: DOUBLE
119617: EQUAL
119618: IFTRUE 119622
119620: GO 119958
119622: POP
// begin b := IsInUnit ( i ) ;
119623: LD_ADDR_VAR 0 18
119627: PUSH
119628: LD_VAR 0 4
119632: PPUSH
119633: CALL_OW 310
119637: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119638: LD_ADDR_VAR 0 19
119642: PUSH
119643: LD_VAR 0 18
119647: NOT
119648: PUSH
119649: LD_VAR 0 18
119653: PPUSH
119654: CALL_OW 266
119658: PUSH
119659: LD_INT 32
119661: PUSH
119662: LD_INT 31
119664: PUSH
119665: EMPTY
119666: LIST
119667: LIST
119668: IN
119669: OR
119670: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119671: LD_VAR 0 18
119675: PPUSH
119676: CALL_OW 266
119680: PUSH
119681: LD_INT 5
119683: EQUAL
119684: PUSH
119685: LD_VAR 0 4
119689: PPUSH
119690: CALL_OW 257
119694: PUSH
119695: LD_INT 1
119697: PUSH
119698: LD_INT 2
119700: PUSH
119701: LD_INT 3
119703: PUSH
119704: LD_INT 4
119706: PUSH
119707: EMPTY
119708: LIST
119709: LIST
119710: LIST
119711: LIST
119712: IN
119713: AND
119714: IFFALSE 119751
// begin class := AllowSpecClass ( i ) ;
119716: LD_ADDR_VAR 0 20
119720: PUSH
119721: LD_VAR 0 4
119725: PPUSH
119726: CALL 50992 0 1
119730: ST_TO_ADDR
// if class then
119731: LD_VAR 0 20
119735: IFFALSE 119751
// ComChangeProfession ( i , class ) ;
119737: LD_VAR 0 4
119741: PPUSH
119742: LD_VAR 0 20
119746: PPUSH
119747: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119751: LD_VAR 0 16
119755: PUSH
119756: LD_VAR 0 2
119760: PPUSH
119761: LD_INT 21
119763: PUSH
119764: LD_INT 2
119766: PUSH
119767: EMPTY
119768: LIST
119769: LIST
119770: PPUSH
119771: CALL_OW 72
119775: PUSH
119776: LD_INT 1
119778: LESSEQUAL
119779: OR
119780: PUSH
119781: LD_VAR 0 19
119785: AND
119786: PUSH
119787: LD_VAR 0 4
119791: PUSH
119792: LD_VAR 0 17
119796: IN
119797: NOT
119798: AND
119799: IFFALSE 119892
// begin if b then
119801: LD_VAR 0 18
119805: IFFALSE 119854
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119807: LD_VAR 0 18
119811: PPUSH
119812: LD_VAR 0 21
119816: PPUSH
119817: LD_VAR 0 18
119821: PPUSH
119822: CALL_OW 74
119826: PPUSH
119827: CALL_OW 296
119831: PUSH
119832: LD_INT 10
119834: LESS
119835: PUSH
119836: LD_VAR 0 18
119840: PPUSH
119841: CALL_OW 461
119845: PUSH
119846: LD_INT 7
119848: NONEQUAL
119849: AND
119850: IFFALSE 119854
// continue ;
119852: GO 119089
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119854: LD_ADDR_VAR 0 17
119858: PUSH
119859: LD_VAR 0 17
119863: PPUSH
119864: LD_VAR 0 17
119868: PUSH
119869: LD_INT 1
119871: PLUS
119872: PPUSH
119873: LD_VAR 0 4
119877: PPUSH
119878: CALL_OW 1
119882: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119883: LD_VAR 0 4
119887: PPUSH
119888: CALL_OW 122
// end ; if sold_defenders then
119892: LD_VAR 0 17
119896: IFFALSE 119956
// if i in sold_defenders then
119898: LD_VAR 0 4
119902: PUSH
119903: LD_VAR 0 17
119907: IN
119908: IFFALSE 119956
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119910: LD_VAR 0 4
119914: PPUSH
119915: CALL_OW 314
119919: NOT
119920: PUSH
119921: LD_VAR 0 4
119925: PPUSH
119926: LD_VAR 0 13
119930: PPUSH
119931: CALL_OW 296
119935: PUSH
119936: LD_INT 30
119938: LESS
119939: AND
119940: IFFALSE 119956
// ComAttackUnit ( i , e ) ;
119942: LD_VAR 0 4
119946: PPUSH
119947: LD_VAR 0 13
119951: PPUSH
119952: CALL_OW 115
// end ; end ; end ;
119956: GO 119959
119958: POP
// if IsDead ( i ) then
119959: LD_VAR 0 4
119963: PPUSH
119964: CALL_OW 301
119968: IFFALSE 119986
// defenders := defenders diff i ;
119970: LD_ADDR_VAR 0 2
119974: PUSH
119975: LD_VAR 0 2
119979: PUSH
119980: LD_VAR 0 4
119984: DIFF
119985: ST_TO_ADDR
// end ;
119986: GO 119089
119988: POP
119989: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119990: LD_VAR 0 21
119994: NOT
119995: PUSH
119996: LD_VAR 0 2
120000: NOT
120001: OR
120002: PUSH
120003: LD_EXP 50
120007: PUSH
120008: LD_VAR 0 1
120012: ARRAY
120013: NOT
120014: OR
120015: IFFALSE 118993
// MC_Reset ( base , 18 ) ;
120017: LD_VAR 0 1
120021: PPUSH
120022: LD_INT 18
120024: PPUSH
120025: CALL 22646 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120029: LD_ADDR_VAR 0 2
120033: PUSH
120034: LD_VAR 0 2
120038: PUSH
120039: LD_VAR 0 2
120043: PPUSH
120044: LD_INT 2
120046: PUSH
120047: LD_INT 25
120049: PUSH
120050: LD_INT 1
120052: PUSH
120053: EMPTY
120054: LIST
120055: LIST
120056: PUSH
120057: LD_INT 25
120059: PUSH
120060: LD_INT 5
120062: PUSH
120063: EMPTY
120064: LIST
120065: LIST
120066: PUSH
120067: LD_INT 25
120069: PUSH
120070: LD_INT 8
120072: PUSH
120073: EMPTY
120074: LIST
120075: LIST
120076: PUSH
120077: LD_INT 25
120079: PUSH
120080: LD_INT 9
120082: PUSH
120083: EMPTY
120084: LIST
120085: LIST
120086: PUSH
120087: EMPTY
120088: LIST
120089: LIST
120090: LIST
120091: LIST
120092: LIST
120093: PPUSH
120094: CALL_OW 72
120098: DIFF
120099: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120100: LD_VAR 0 21
120104: NOT
120105: PUSH
120106: LD_VAR 0 2
120110: PPUSH
120111: LD_INT 21
120113: PUSH
120114: LD_INT 2
120116: PUSH
120117: EMPTY
120118: LIST
120119: LIST
120120: PPUSH
120121: CALL_OW 72
120125: AND
120126: IFFALSE 120464
// begin tmp := FilterByTag ( defenders , 19 ) ;
120128: LD_ADDR_VAR 0 11
120132: PUSH
120133: LD_VAR 0 2
120137: PPUSH
120138: LD_INT 19
120140: PPUSH
120141: CALL 84486 0 2
120145: ST_TO_ADDR
// if tmp then
120146: LD_VAR 0 11
120150: IFFALSE 120220
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120152: LD_ADDR_VAR 0 11
120156: PUSH
120157: LD_VAR 0 11
120161: PPUSH
120162: LD_INT 25
120164: PUSH
120165: LD_INT 3
120167: PUSH
120168: EMPTY
120169: LIST
120170: LIST
120171: PPUSH
120172: CALL_OW 72
120176: ST_TO_ADDR
// if tmp then
120177: LD_VAR 0 11
120181: IFFALSE 120220
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120183: LD_ADDR_EXP 62
120187: PUSH
120188: LD_EXP 62
120192: PPUSH
120193: LD_VAR 0 1
120197: PPUSH
120198: LD_EXP 62
120202: PUSH
120203: LD_VAR 0 1
120207: ARRAY
120208: PUSH
120209: LD_VAR 0 11
120213: UNION
120214: PPUSH
120215: CALL_OW 1
120219: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120220: LD_VAR 0 1
120224: PPUSH
120225: LD_INT 19
120227: PPUSH
120228: CALL 22646 0 2
// repeat wait ( 0 0$1 ) ;
120232: LD_INT 35
120234: PPUSH
120235: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120239: LD_EXP 50
120243: PUSH
120244: LD_VAR 0 1
120248: ARRAY
120249: NOT
120250: PUSH
120251: LD_EXP 50
120255: PUSH
120256: LD_VAR 0 1
120260: ARRAY
120261: PUSH
120262: EMPTY
120263: EQUAL
120264: OR
120265: IFFALSE 120302
// begin for i in defenders do
120267: LD_ADDR_VAR 0 4
120271: PUSH
120272: LD_VAR 0 2
120276: PUSH
120277: FOR_IN
120278: IFFALSE 120291
// ComStop ( i ) ;
120280: LD_VAR 0 4
120284: PPUSH
120285: CALL_OW 141
120289: GO 120277
120291: POP
120292: POP
// defenders := [ ] ;
120293: LD_ADDR_VAR 0 2
120297: PUSH
120298: EMPTY
120299: ST_TO_ADDR
// exit ;
120300: GO 120528
// end ; for i in defenders do
120302: LD_ADDR_VAR 0 4
120306: PUSH
120307: LD_VAR 0 2
120311: PUSH
120312: FOR_IN
120313: IFFALSE 120402
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120315: LD_VAR 0 4
120319: PPUSH
120320: LD_EXP 74
120324: PUSH
120325: LD_VAR 0 1
120329: ARRAY
120330: PPUSH
120331: CALL_OW 308
120335: NOT
120336: IFFALSE 120360
// ComMoveToArea ( i , mc_parking [ base ] ) else
120338: LD_VAR 0 4
120342: PPUSH
120343: LD_EXP 74
120347: PUSH
120348: LD_VAR 0 1
120352: ARRAY
120353: PPUSH
120354: CALL_OW 113
120358: GO 120400
// if GetControl ( i ) = control_manual then
120360: LD_VAR 0 4
120364: PPUSH
120365: CALL_OW 263
120369: PUSH
120370: LD_INT 1
120372: EQUAL
120373: IFFALSE 120400
// if IsDrivenBy ( i ) then
120375: LD_VAR 0 4
120379: PPUSH
120380: CALL_OW 311
120384: IFFALSE 120400
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120386: LD_VAR 0 4
120390: PPUSH
120391: CALL_OW 311
120395: PPUSH
120396: CALL_OW 121
// end ;
120400: GO 120312
120402: POP
120403: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120404: LD_VAR 0 2
120408: PPUSH
120409: LD_INT 95
120411: PUSH
120412: LD_EXP 74
120416: PUSH
120417: LD_VAR 0 1
120421: ARRAY
120422: PUSH
120423: EMPTY
120424: LIST
120425: LIST
120426: PPUSH
120427: CALL_OW 72
120431: PUSH
120432: LD_VAR 0 2
120436: EQUAL
120437: PUSH
120438: LD_EXP 73
120442: PUSH
120443: LD_VAR 0 1
120447: ARRAY
120448: OR
120449: PUSH
120450: LD_EXP 50
120454: PUSH
120455: LD_VAR 0 1
120459: ARRAY
120460: NOT
120461: OR
120462: IFFALSE 120232
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120464: LD_ADDR_EXP 72
120468: PUSH
120469: LD_EXP 72
120473: PPUSH
120474: LD_VAR 0 1
120478: PPUSH
120479: LD_VAR 0 2
120483: PPUSH
120484: LD_INT 21
120486: PUSH
120487: LD_INT 2
120489: PUSH
120490: EMPTY
120491: LIST
120492: LIST
120493: PPUSH
120494: CALL_OW 72
120498: PPUSH
120499: CALL_OW 1
120503: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120504: LD_VAR 0 1
120508: PPUSH
120509: LD_INT 19
120511: PPUSH
120512: CALL 22646 0 2
// MC_Reset ( base , 20 ) ;
120516: LD_VAR 0 1
120520: PPUSH
120521: LD_INT 20
120523: PPUSH
120524: CALL 22646 0 2
// end ; end_of_file
120528: LD_VAR 0 3
120532: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120533: LD_VAR 0 1
120537: PUSH
120538: LD_INT 200
120540: DOUBLE
120541: GREATEREQUAL
120542: IFFALSE 120550
120544: LD_INT 299
120546: DOUBLE
120547: LESSEQUAL
120548: IFTRUE 120552
120550: GO 120584
120552: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120553: LD_VAR 0 1
120557: PPUSH
120558: LD_VAR 0 2
120562: PPUSH
120563: LD_VAR 0 3
120567: PPUSH
120568: LD_VAR 0 4
120572: PPUSH
120573: LD_VAR 0 5
120577: PPUSH
120578: CALL 108533 0 5
120582: GO 120661
120584: LD_INT 300
120586: DOUBLE
120587: GREATEREQUAL
120588: IFFALSE 120596
120590: LD_INT 399
120592: DOUBLE
120593: LESSEQUAL
120594: IFTRUE 120598
120596: GO 120660
120598: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120599: LD_VAR 0 1
120603: PPUSH
120604: LD_VAR 0 2
120608: PPUSH
120609: LD_VAR 0 3
120613: PPUSH
120614: LD_VAR 0 4
120618: PPUSH
120619: LD_VAR 0 5
120623: PPUSH
120624: LD_VAR 0 6
120628: PPUSH
120629: LD_VAR 0 7
120633: PPUSH
120634: LD_VAR 0 8
120638: PPUSH
120639: LD_VAR 0 9
120643: PPUSH
120644: LD_VAR 0 10
120648: PPUSH
120649: LD_VAR 0 11
120653: PPUSH
120654: CALL 104521 0 11
120658: GO 120661
120660: POP
// end ;
120661: PPOPN 11
120663: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120664: LD_VAR 0 1
120668: PPUSH
120669: LD_VAR 0 2
120673: PPUSH
120674: LD_VAR 0 3
120678: PPUSH
120679: LD_VAR 0 4
120683: PPUSH
120684: LD_VAR 0 5
120688: PPUSH
120689: CALL 107998 0 5
// end ; end_of_file
120693: PPOPN 5
120695: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120696: LD_VAR 0 1
120700: PPUSH
120701: LD_VAR 0 2
120705: PPUSH
120706: LD_VAR 0 3
120710: PPUSH
120711: LD_VAR 0 4
120715: PPUSH
120716: LD_VAR 0 5
120720: PPUSH
120721: LD_VAR 0 6
120725: PPUSH
120726: CALL 92173 0 6
// end ;
120730: PPOPN 6
120732: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120733: LD_INT 0
120735: PPUSH
// begin if not units then
120736: LD_VAR 0 1
120740: NOT
120741: IFFALSE 120745
// exit ;
120743: GO 120745
// end ;
120745: PPOPN 7
120747: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120748: CALL 92060 0 0
// end ;
120752: PPOPN 1
120754: END
