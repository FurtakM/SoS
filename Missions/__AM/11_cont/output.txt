// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17223 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82168 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19335 0 0
// Action ;
  89: CALL 7913 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40552 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40552 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40552 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 40978 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47262 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47262 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47262 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47262 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47262 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47262 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47262 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47262 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47262 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47262 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47262 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47262 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47262 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47262 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47262 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2347: LD_ADDR_VAR 0 5
2351: PUSH
2352: LD_INT 5
2354: PUSH
2355: LD_INT 6
2357: PUSH
2358: LD_INT 7
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: LD_OWVAR 67
2370: ARRAY
2371: ST_TO_ADDR
// uc_side := 2 ;
2372: LD_ADDR_OWVAR 20
2376: PUSH
2377: LD_INT 2
2379: ST_TO_ADDR
// uc_nation := 2 ;
2380: LD_ADDR_OWVAR 21
2384: PUSH
2385: LD_INT 2
2387: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2388: LD_ADDR_OWVAR 37
2392: PUSH
2393: LD_INT 14
2395: ST_TO_ADDR
// vc_engine := engine_siberite ;
2396: LD_ADDR_OWVAR 39
2400: PUSH
2401: LD_INT 3
2403: ST_TO_ADDR
// vc_control := control_manual ;
2404: LD_ADDR_OWVAR 38
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2412: LD_ADDR_OWVAR 40
2416: PUSH
2417: LD_INT 31
2419: ST_TO_ADDR
// for i = 1 to 3 do
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: DOUBLE
2426: LD_INT 1
2428: DEC
2429: ST_TO_ADDR
2430: LD_INT 3
2432: PUSH
2433: FOR_TO
2434: IFFALSE 2518
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2436: LD_INT 0
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: LD_VAR 0 5
2446: PPUSH
2447: CALL_OW 380
// un := CreateVehicle ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: CALL_OW 45
2460: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 5
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2481: LD_VAR 0 4
2485: PPUSH
2486: LD_INT 156
2488: PPUSH
2489: LD_INT 15
2491: PPUSH
2492: LD_INT 6
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2502: CALL_OW 44
2506: PPUSH
2507: LD_VAR 0 4
2511: PPUSH
2512: CALL_OW 52
// end ;
2516: GO 2433
2518: POP
2519: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , [ 3 , 4 , 5 ] [ Difficulty ] , - 1 , 4 ] ) ;
2520: LD_ADDR_EXP 37
2524: PUSH
2525: LD_INT 94
2527: PPUSH
2528: LD_INT 28
2530: PPUSH
2531: LD_STRING dammam
2533: PPUSH
2534: LD_VAR 0 5
2538: PPUSH
2539: LD_INT 10000
2541: PUSH
2542: LD_INT 1000
2544: PUSH
2545: LD_INT 300
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PPUSH
2553: LD_INT 1
2555: NEG
2556: PUSH
2557: LD_INT 3
2559: PUSH
2560: LD_INT 4
2562: PUSH
2563: LD_INT 5
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: LIST
2570: PUSH
2571: LD_OWVAR 67
2575: ARRAY
2576: PUSH
2577: LD_INT 1
2579: NEG
2580: PUSH
2581: LD_INT 4
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: PPUSH
2590: CALL 57786 0 6
2594: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 3 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2595: LD_ADDR_EXP 37
2599: PUSH
2600: LD_EXP 37
2604: PUSH
2605: LD_INT 122
2607: PPUSH
2608: LD_INT 25
2610: PPUSH
2611: LD_STRING 
2613: PPUSH
2614: LD_VAR 0 5
2618: PPUSH
2619: LD_INT 500
2621: PUSH
2622: LD_INT 60
2624: PUSH
2625: LD_INT 0
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: LIST
2632: PPUSH
2633: LD_INT 1
2635: NEG
2636: PUSH
2637: LD_INT 3
2639: PUSH
2640: LD_INT 3
2642: PUSH
2643: LD_INT 4
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: LIST
2650: PUSH
2651: LD_OWVAR 67
2655: ARRAY
2656: PUSH
2657: LD_INT 2
2659: PUSH
2660: LD_INT 0
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL 57786 0 6
2673: UNION
2674: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2675: LD_ADDR_EXP 35
2679: PUSH
2680: LD_INT 45
2682: PPUSH
2683: LD_INT 24
2685: PPUSH
2686: LD_STRING jeddah
2688: PPUSH
2689: LD_VAR 0 5
2693: PPUSH
2694: LD_INT 700
2696: PUSH
2697: LD_INT 300
2699: PUSH
2700: LD_INT 10
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 1
2710: NEG
2711: PUSH
2712: LD_INT 5
2714: PUSH
2715: LD_INT 3
2717: PUSH
2718: LD_INT 2
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: LIST
2725: LIST
2726: PPUSH
2727: CALL 57786 0 6
2731: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2732: LD_ADDR_EXP 36
2736: PUSH
2737: LD_INT 7
2739: PPUSH
2740: LD_INT 27
2742: PPUSH
2743: LD_STRING riyadh
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: LD_INT 500
2753: PUSH
2754: LD_INT 60
2756: PUSH
2757: LD_INT 0
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_INT 4
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: LD_INT 1
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL 57786 0 6
2787: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 12 , 3 , 3 , 2 ] ) ;
2788: LD_ADDR_EXP 39
2792: PUSH
2793: LD_INT 204
2795: PPUSH
2796: LD_INT 26
2798: PPUSH
2799: LD_STRING 
2801: PPUSH
2802: LD_VAR 0 5
2806: PPUSH
2807: LD_INT 500
2809: PUSH
2810: LD_INT 50
2812: PUSH
2813: LD_INT 0
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: LIST
2820: PPUSH
2821: LD_INT 12
2823: PUSH
2824: LD_INT 3
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 2
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL 57786 0 6
2843: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2844: LD_ADDR_EXP 50
2848: PUSH
2849: LD_EXP 37
2853: PUSH
2854: LD_EXP 35
2858: PUSH
2859: LD_EXP 39
2863: PUSH
2864: EMPTY
2865: LIST
2866: LIST
2867: LIST
2868: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2869: LD_ADDR_VAR 0 2
2873: PUSH
2874: LD_INT 22
2876: PUSH
2877: LD_INT 2
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PUSH
2884: LD_INT 30
2886: PUSH
2887: LD_INT 31
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: PUSH
2894: LD_INT 58
2896: PUSH
2897: EMPTY
2898: LIST
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: PPUSH
2905: CALL_OW 69
2909: PUSH
2910: FOR_IN
2911: IFFALSE 3036
// begin if GetBase ( i ) then
2913: LD_VAR 0 2
2917: PPUSH
2918: CALL_OW 274
2922: IFFALSE 2926
// continue ;
2924: GO 2910
// d := GetDir ( i ) ;
2926: LD_ADDR_VAR 0 3
2930: PUSH
2931: LD_VAR 0 2
2935: PPUSH
2936: CALL_OW 254
2940: ST_TO_ADDR
// if d < 3 then
2941: LD_VAR 0 3
2945: PUSH
2946: LD_INT 3
2948: LESS
2949: IFFALSE 2967
// d := d + 3 else
2951: LD_ADDR_VAR 0 3
2955: PUSH
2956: LD_VAR 0 3
2960: PUSH
2961: LD_INT 3
2963: PLUS
2964: ST_TO_ADDR
2965: GO 2981
// d := d - 3 ;
2967: LD_ADDR_VAR 0 3
2971: PUSH
2972: LD_VAR 0 3
2976: PUSH
2977: LD_INT 3
2979: MINUS
2980: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2981: LD_INT 0
2983: PPUSH
2984: LD_INT 8
2986: PPUSH
2987: LD_VAR 0 5
2991: PPUSH
2992: CALL_OW 380
// un := CreateHuman ;
2996: LD_ADDR_VAR 0 4
3000: PUSH
3001: CALL_OW 44
3005: ST_TO_ADDR
// SetDir ( un , d ) ;
3006: LD_VAR 0 4
3010: PPUSH
3011: LD_VAR 0 3
3015: PPUSH
3016: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3020: LD_VAR 0 4
3024: PPUSH
3025: LD_VAR 0 2
3029: PPUSH
3030: CALL_OW 52
// end ;
3034: GO 2910
3036: POP
3037: POP
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3417
// begin ar_kamikadze := [ ] ;
3048: LD_ADDR_EXP 42
3052: PUSH
3053: EMPTY
3054: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3055: LD_INT 0
3057: PPUSH
3058: LD_INT 1
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: CALL_OW 380
// un := CreateHuman ;
3070: LD_ADDR_VAR 0 4
3074: PUSH
3075: CALL_OW 44
3079: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3080: LD_VAR 0 4
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3092: LD_VAR 0 4
3096: PPUSH
3097: LD_INT 23
3099: PPUSH
3100: LD_INT 44
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 48
// ComCrawl ( un ) ;
3110: LD_VAR 0 4
3114: PPUSH
3115: CALL_OW 137
// un := CreateHuman ;
3119: LD_ADDR_VAR 0 4
3123: PUSH
3124: CALL_OW 44
3128: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3129: LD_VAR 0 4
3133: PPUSH
3134: LD_INT 3
3136: PPUSH
3137: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3141: LD_VAR 0 4
3145: PPUSH
3146: LD_INT 30
3148: PPUSH
3149: LD_INT 39
3151: PPUSH
3152: LD_INT 0
3154: PPUSH
3155: CALL_OW 48
// ComCrawl ( un ) ;
3159: LD_VAR 0 4
3163: PPUSH
3164: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3168: LD_INT 0
3170: PPUSH
3171: LD_INT 17
3173: PPUSH
3174: LD_VAR 0 5
3178: PPUSH
3179: CALL_OW 380
// un := CreateHuman ;
3183: LD_ADDR_VAR 0 4
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3193: LD_VAR 0 4
3197: PPUSH
3198: LD_INT 3
3200: PPUSH
3201: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3205: LD_VAR 0 4
3209: PPUSH
3210: LD_INT 45
3212: PPUSH
3213: LD_INT 86
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 48
// ComHold ( un ) ;
3223: LD_VAR 0 4
3227: PPUSH
3228: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3232: LD_ADDR_EXP 42
3236: PUSH
3237: LD_EXP 42
3241: PPUSH
3242: LD_EXP 42
3246: PUSH
3247: LD_INT 1
3249: PLUS
3250: PPUSH
3251: LD_VAR 0 4
3255: PPUSH
3256: CALL_OW 1
3260: ST_TO_ADDR
// un := CreateHuman ;
3261: LD_ADDR_VAR 0 4
3265: PUSH
3266: CALL_OW 44
3270: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3271: LD_VAR 0 4
3275: PPUSH
3276: LD_INT 3
3278: PPUSH
3279: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3283: LD_VAR 0 4
3287: PPUSH
3288: LD_INT 60
3290: PPUSH
3291: LD_INT 85
3293: PPUSH
3294: LD_INT 0
3296: PPUSH
3297: CALL_OW 48
// ComHold ( un ) ;
3301: LD_VAR 0 4
3305: PPUSH
3306: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3310: LD_ADDR_EXP 42
3314: PUSH
3315: LD_EXP 42
3319: PPUSH
3320: LD_EXP 42
3324: PUSH
3325: LD_INT 1
3327: PLUS
3328: PPUSH
3329: LD_VAR 0 4
3333: PPUSH
3334: CALL_OW 1
3338: ST_TO_ADDR
// un := CreateHuman ;
3339: LD_ADDR_VAR 0 4
3343: PUSH
3344: CALL_OW 44
3348: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3349: LD_VAR 0 4
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3361: LD_VAR 0 4
3365: PPUSH
3366: LD_INT 222
3368: PPUSH
3369: LD_INT 166
3371: PPUSH
3372: LD_INT 0
3374: PPUSH
3375: CALL_OW 48
// ComHold ( un ) ;
3379: LD_VAR 0 4
3383: PPUSH
3384: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3388: LD_ADDR_EXP 42
3392: PUSH
3393: LD_EXP 42
3397: PPUSH
3398: LD_EXP 42
3402: PUSH
3403: LD_INT 1
3405: PLUS
3406: PPUSH
3407: LD_VAR 0 4
3411: PPUSH
3412: CALL_OW 1
3416: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3417: LD_ADDR_EXP 40
3421: PUSH
3422: EMPTY
3423: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3424: LD_INT 1
3426: PPUSH
3427: LD_INT 1
3429: PPUSH
3430: LD_VAR 0 5
3434: PPUSH
3435: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3439: LD_ADDR_OWVAR 26
3443: PUSH
3444: LD_STRING Pavel Grigorovic
3446: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3447: LD_ADDR_OWVAR 33
3451: PUSH
3452: LD_STRING SecondCharsGal
3454: ST_TO_ADDR
// hc_face_number := 4 ;
3455: LD_ADDR_OWVAR 34
3459: PUSH
3460: LD_INT 4
3462: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3463: LD_ADDR_EXP 40
3467: PUSH
3468: LD_EXP 40
3472: PPUSH
3473: LD_INT 1
3475: PPUSH
3476: CALL_OW 44
3480: PPUSH
3481: CALL_OW 1
3485: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3486: LD_INT 2
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_INT 2
3494: PPUSH
3495: CALL_OW 380
// hc_name := Lucy Sebel ;
3499: LD_ADDR_OWVAR 26
3503: PUSH
3504: LD_STRING Lucy Sebel
3506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3507: LD_ADDR_OWVAR 33
3511: PUSH
3512: LD_STRING SecondCharsGal
3514: ST_TO_ADDR
// hc_face_number := 15 ;
3515: LD_ADDR_OWVAR 34
3519: PUSH
3520: LD_INT 15
3522: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3523: LD_ADDR_EXP 40
3527: PUSH
3528: LD_EXP 40
3532: PPUSH
3533: LD_INT 2
3535: PPUSH
3536: CALL_OW 44
3540: PPUSH
3541: CALL_OW 1
3545: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3546: LD_INT 2
3548: PPUSH
3549: LD_INT 4
3551: PPUSH
3552: LD_INT 2
3554: PPUSH
3555: CALL_OW 380
// hc_gallery :=  ;
3559: LD_ADDR_OWVAR 33
3563: PUSH
3564: LD_STRING 
3566: ST_TO_ADDR
// hc_name :=  ;
3567: LD_ADDR_OWVAR 26
3571: PUSH
3572: LD_STRING 
3574: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3575: LD_ADDR_EXP 40
3579: PUSH
3580: LD_EXP 40
3584: PPUSH
3585: LD_INT 3
3587: PPUSH
3588: CALL_OW 44
3592: PPUSH
3593: CALL_OW 1
3597: ST_TO_ADDR
// hc_sex := sex_male ;
3598: LD_ADDR_OWVAR 27
3602: PUSH
3603: LD_INT 1
3605: ST_TO_ADDR
// hc_class = 11 ;
3606: LD_ADDR_OWVAR 28
3610: PUSH
3611: LD_INT 11
3613: ST_TO_ADDR
// hc_gallery = sandar ;
3614: LD_ADDR_OWVAR 33
3618: PUSH
3619: LD_STRING sandar
3621: ST_TO_ADDR
// hc_face_number = 33 ;
3622: LD_ADDR_OWVAR 34
3626: PUSH
3627: LD_INT 33
3629: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3630: LD_ADDR_OWVAR 26
3634: PUSH
3635: LD_STRING Thabit Muhair Saliba
3637: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3638: LD_ADDR_OWVAR 31
3642: PUSH
3643: LD_INT 0
3645: PUSH
3646: LD_INT 0
3648: PUSH
3649: LD_INT 0
3651: PUSH
3652: LD_INT 0
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: ST_TO_ADDR
// Saliba = CreateHuman ;
3661: LD_ADDR_EXP 44
3665: PUSH
3666: CALL_OW 44
3670: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3671: LD_EXP 44
3675: PPUSH
3676: LD_INT 7
3678: PPUSH
3679: CALL_OW 52
// if gensher_active then
3683: LD_EXP 18
3687: IFFALSE 3714
// begin Gensher = NewCharacter ( Dietrich ) ;
3689: LD_ADDR_EXP 45
3693: PUSH
3694: LD_STRING Dietrich
3696: PPUSH
3697: CALL_OW 25
3701: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3702: LD_EXP 45
3706: PPUSH
3707: LD_INT 94
3709: PPUSH
3710: CALL_OW 52
// end ; InitHc ;
3714: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3718: LD_ADDR_EXP 41
3722: PUSH
3723: EMPTY
3724: ST_TO_ADDR
// for i = 1 to 5 do
3725: LD_ADDR_VAR 0 2
3729: PUSH
3730: DOUBLE
3731: LD_INT 1
3733: DEC
3734: ST_TO_ADDR
3735: LD_INT 5
3737: PUSH
3738: FOR_TO
3739: IFFALSE 3911
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3741: LD_INT 13
3743: PUSH
3744: LD_INT 14
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PUSH
3751: LD_INT 1
3753: PPUSH
3754: LD_INT 2
3756: PPUSH
3757: CALL_OW 12
3761: ARRAY
3762: PPUSH
3763: LD_INT 1
3765: PUSH
3766: LD_INT 2
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 2
3778: PPUSH
3779: CALL_OW 12
3783: ARRAY
3784: PPUSH
3785: LD_INT 1
3787: PPUSH
3788: LD_INT 25
3790: PUSH
3791: LD_INT 27
3793: PUSH
3794: LD_INT 26
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: LIST
3801: PUSH
3802: LD_INT 1
3804: PPUSH
3805: LD_INT 3
3807: PPUSH
3808: CALL_OW 12
3812: ARRAY
3813: PPUSH
3814: LD_INT 60
3816: PPUSH
3817: LD_INT 100
3819: PPUSH
3820: CALL_OW 12
3824: PPUSH
3825: CALL 54377 0 5
// un := CreateVehicle ;
3829: LD_ADDR_VAR 0 4
3833: PUSH
3834: CALL_OW 45
3838: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3839: LD_ADDR_EXP 41
3843: PUSH
3844: LD_EXP 41
3848: PPUSH
3849: LD_EXP 41
3853: PUSH
3854: LD_INT 1
3856: PLUS
3857: PPUSH
3858: LD_VAR 0 4
3862: PPUSH
3863: CALL_OW 1
3867: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3868: LD_VAR 0 4
3872: PPUSH
3873: LD_INT 0
3875: PPUSH
3876: LD_INT 5
3878: PPUSH
3879: CALL_OW 12
3883: PPUSH
3884: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3888: LD_VAR 0 4
3892: PPUSH
3893: LD_INT 124
3895: PPUSH
3896: LD_INT 141
3898: PPUSH
3899: LD_INT 8
3901: PPUSH
3902: LD_INT 0
3904: PPUSH
3905: CALL_OW 50
// end ;
3909: GO 3738
3911: POP
3912: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3913: LD_ADDR_EXP 43
3917: PUSH
3918: EMPTY
3919: PUSH
3920: EMPTY
3921: PUSH
3922: EMPTY
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: LIST
3928: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3929: LD_ADDR_VAR 0 3
3933: PUSH
3934: DOUBLE
3935: LD_INT 1
3937: DEC
3938: ST_TO_ADDR
3939: LD_INT 3
3941: PUSH
3942: LD_INT 3
3944: PUSH
3945: LD_INT 4
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: LIST
3952: PUSH
3953: LD_OWVAR 67
3957: ARRAY
3958: PUSH
3959: FOR_TO
3960: IFFALSE 4174
// for i = 1 to 3 do
3962: LD_ADDR_VAR 0 2
3966: PUSH
3967: DOUBLE
3968: LD_INT 1
3970: DEC
3971: ST_TO_ADDR
3972: LD_INT 3
3974: PUSH
3975: FOR_TO
3976: IFFALSE 4170
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3978: LD_INT 14
3980: PPUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 2
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 2
3996: PPUSH
3997: CALL_OW 12
4001: ARRAY
4002: PPUSH
4003: LD_INT 1
4005: PUSH
4006: LD_INT 5
4008: PUSH
4009: EMPTY
4010: LIST
4011: LIST
4012: PUSH
4013: LD_INT 1
4015: PPUSH
4016: LD_INT 2
4018: PPUSH
4019: CALL_OW 12
4023: ARRAY
4024: PPUSH
4025: LD_INT 25
4027: PUSH
4028: LD_INT 27
4030: PUSH
4031: LD_INT 26
4033: PUSH
4034: LD_INT 28
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 1
4045: PPUSH
4046: LD_INT 4
4048: PPUSH
4049: CALL_OW 12
4053: ARRAY
4054: PPUSH
4055: LD_INT 100
4057: PPUSH
4058: CALL 54377 0 5
// un := CreateVehicle ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: CALL_OW 45
4071: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4072: LD_ADDR_EXP 43
4076: PUSH
4077: LD_EXP 43
4081: PPUSH
4082: LD_VAR 0 2
4086: PUSH
4087: LD_EXP 43
4091: PUSH
4092: LD_VAR 0 2
4096: ARRAY
4097: PUSH
4098: LD_INT 1
4100: PLUS
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PPUSH
4106: LD_VAR 0 4
4110: PPUSH
4111: CALL 54499 0 3
4115: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4116: LD_VAR 0 4
4120: PPUSH
4121: LD_INT 0
4123: PPUSH
4124: LD_INT 5
4126: PPUSH
4127: CALL_OW 12
4131: PPUSH
4132: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4136: LD_VAR 0 4
4140: PPUSH
4141: LD_INT 20
4143: PUSH
4144: LD_INT 21
4146: PUSH
4147: LD_INT 22
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_VAR 0 2
4159: ARRAY
4160: PPUSH
4161: LD_INT 0
4163: PPUSH
4164: CALL_OW 49
// end ;
4168: GO 3975
4170: POP
4171: POP
4172: GO 3959
4174: POP
4175: POP
// InitHc ;
4176: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4180: LD_INT 4
4182: PPUSH
4183: LD_INT 5
4185: PPUSH
4186: LD_INT 10
4188: PPUSH
4189: LD_INT 5
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 58
// end ;
4199: LD_VAR 0 1
4203: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4204: LD_EXP 42
4208: IFFALSE 4282
4210: GO 4212
4212: DISABLE
4213: LD_INT 0
4215: PPUSH
// begin enable ;
4216: ENABLE
// for i in ar_kamikadze do
4217: LD_ADDR_VAR 0 1
4221: PUSH
4222: LD_EXP 42
4226: PUSH
4227: FOR_IN
4228: IFFALSE 4280
// if See ( 1 , i ) then
4230: LD_INT 1
4232: PPUSH
4233: LD_VAR 0 1
4237: PPUSH
4238: CALL_OW 292
4242: IFFALSE 4278
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4244: LD_VAR 0 1
4248: PPUSH
4249: LD_INT 81
4251: PUSH
4252: LD_INT 2
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PPUSH
4259: CALL_OW 69
4263: PPUSH
4264: LD_VAR 0 1
4268: PPUSH
4269: CALL_OW 74
4273: PPUSH
4274: CALL_OW 115
4278: GO 4227
4280: POP
4281: POP
// end ;
4282: PPOPN 1
4284: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4285: LD_EXP 13
4289: IFFALSE 4606
4291: GO 4293
4293: DISABLE
4294: LD_INT 0
4296: PPUSH
4297: PPUSH
4298: PPUSH
4299: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4300: LD_INT 35
4302: PPUSH
4303: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4307: LD_INT 1
4309: PPUSH
4310: CALL 41266 0 1
4314: PUSH
4315: LD_INT 0
4317: EQUAL
4318: IFFALSE 4300
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4320: LD_INT 1
4322: PPUSH
4323: LD_INT 14
4325: PUSH
4326: LD_INT 3
4328: PUSH
4329: LD_INT 2
4331: PUSH
4332: LD_INT 32
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: PPUSH
4344: CALL 40870 0 2
// repeat wait ( 0 0$1 ) ;
4348: LD_INT 35
4350: PPUSH
4351: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4355: LD_EXP 69
4359: PUSH
4360: LD_INT 1
4362: ARRAY
4363: PPUSH
4364: LD_INT 33
4366: PUSH
4367: LD_INT 2
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 34
4376: PUSH
4377: LD_INT 32
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PPUSH
4388: CALL_OW 72
4392: IFFALSE 4348
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_EXP 69
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: LD_INT 33
4410: PUSH
4411: LD_INT 2
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 34
4420: PUSH
4421: LD_INT 32
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PPUSH
4432: CALL_OW 72
4436: PUSH
4437: LD_INT 1
4439: ARRAY
4440: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4441: LD_ADDR_VAR 0 4
4445: PUSH
4446: LD_INT 5
4448: PPUSH
4449: CALL_OW 469
4453: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4454: LD_INT 35
4456: PPUSH
4457: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4461: LD_ADDR_VAR 0 4
4465: PUSH
4466: LD_INT 5
4468: PPUSH
4469: CALL_OW 469
4473: ST_TO_ADDR
// tmp := 100 ;
4474: LD_ADDR_VAR 0 3
4478: PUSH
4479: LD_INT 100
4481: ST_TO_ADDR
// if pos then
4482: LD_VAR 0 4
4486: IFFALSE 4526
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4488: LD_ADDR_VAR 0 3
4492: PUSH
4493: LD_INT 2
4495: PPUSH
4496: LD_VAR 0 4
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: LD_VAR 0 4
4509: PUSH
4510: LD_INT 2
4512: ARRAY
4513: PPUSH
4514: LD_INT 20
4516: PPUSH
4517: CALL 55395 0 4
4521: PUSH
4522: LD_INT 4
4524: ARRAY
4525: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4526: LD_VAR 0 4
4530: PUSH
4531: LD_EXP 14
4535: NOT
4536: AND
4537: PUSH
4538: LD_VAR 0 3
4542: PUSH
4543: LD_INT 10
4545: LESS
4546: AND
4547: IFFALSE 4454
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4549: LD_VAR 0 2
4553: PPUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_INT 1
4561: ARRAY
4562: PPUSH
4563: LD_VAR 0 4
4567: PUSH
4568: LD_INT 2
4570: ARRAY
4571: PPUSH
4572: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4576: LD_VAR 0 2
4580: PPUSH
4581: LD_INT 198
4583: PPUSH
4584: LD_INT 113
4586: PPUSH
4587: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4591: LD_VAR 0 2
4595: PPUSH
4596: LD_INT 124
4598: PPUSH
4599: LD_INT 7
4601: PPUSH
4602: CALL_OW 171
// end ;
4606: PPOPN 4
4608: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4609: LD_EXP 6
4613: IFFALSE 7289
4615: GO 4617
4617: DISABLE
4618: LD_INT 0
4620: PPUSH
4621: PPUSH
4622: PPUSH
4623: PPUSH
4624: PPUSH
4625: PPUSH
4626: PPUSH
4627: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4628: LD_ADDR_VAR 0 4
4632: PUSH
4633: LD_INT 5
4635: PUSH
4636: LD_INT 6
4638: PUSH
4639: LD_INT 7
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: LIST
4646: PUSH
4647: LD_OWVAR 67
4651: ARRAY
4652: ST_TO_ADDR
// coords := [ ] ;
4653: LD_ADDR_VAR 0 5
4657: PUSH
4658: EMPTY
4659: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4660: LD_ADDR_VAR 0 6
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 0
4670: PUSH
4671: LD_INT 0
4673: PUSH
4674: LD_INT 0
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: LD_INT 0
4682: PUSH
4683: LD_INT 0
4685: PUSH
4686: LD_INT 0
4688: PUSH
4689: LD_INT 1
4691: PUSH
4692: LD_INT 0
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: LIST
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4707: LD_INT 1
4709: PPUSH
4710: LD_INT 14
4712: PUSH
4713: LD_INT 1
4715: PUSH
4716: LD_INT 2
4718: PUSH
4719: LD_INT 28
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 14
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: LD_INT 2
4736: PUSH
4737: LD_INT 25
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: PUSH
4746: LD_INT 14
4748: PUSH
4749: LD_INT 1
4751: PUSH
4752: LD_INT 2
4754: PUSH
4755: LD_INT 28
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: PUSH
4764: LD_INT 14
4766: PUSH
4767: LD_INT 1
4769: PUSH
4770: LD_INT 2
4772: PUSH
4773: LD_INT 29
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: PUSH
4782: EMPTY
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: PPUSH
4788: CALL 40870 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4792: LD_INT 21000
4794: PUSH
4795: LD_INT 19950
4797: PUSH
4798: LD_INT 18900
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: LIST
4805: PUSH
4806: LD_OWVAR 67
4810: ARRAY
4811: PPUSH
4812: CALL_OW 67
// InitHc ;
4816: CALL_OW 19
// InitUc ;
4820: CALL_OW 18
// uc_side := 2 ;
4824: LD_ADDR_OWVAR 20
4828: PUSH
4829: LD_INT 2
4831: ST_TO_ADDR
// uc_nation := 2 ;
4832: LD_ADDR_OWVAR 21
4836: PUSH
4837: LD_INT 2
4839: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4840: LD_ADDR_VAR 0 3
4844: PUSH
4845: EMPTY
4846: PUSH
4847: EMPTY
4848: PUSH
4849: EMPTY
4850: PUSH
4851: EMPTY
4852: PUSH
4853: EMPTY
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4862: LD_ADDR_VAR 0 3
4866: PUSH
4867: LD_VAR 0 3
4871: PPUSH
4872: LD_INT 1
4874: PPUSH
4875: LD_EXP 69
4879: PUSH
4880: LD_INT 1
4882: ARRAY
4883: PUSH
4884: LD_INT 34
4886: PUSH
4887: LD_INT 32
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PPUSH
4894: CALL_OW 69
4898: DIFF
4899: PPUSH
4900: CALL_OW 1
4904: ST_TO_ADDR
// for i = 1 to Difficulty do
4905: LD_ADDR_VAR 0 1
4909: PUSH
4910: DOUBLE
4911: LD_INT 1
4913: DEC
4914: ST_TO_ADDR
4915: LD_OWVAR 67
4919: PUSH
4920: FOR_TO
4921: IFFALSE 5059
// begin uc_side := 2 ;
4923: LD_ADDR_OWVAR 20
4927: PUSH
4928: LD_INT 2
4930: ST_TO_ADDR
// uc_nation := 2 ;
4931: LD_ADDR_OWVAR 21
4935: PUSH
4936: LD_INT 2
4938: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4939: LD_INT 13
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: LD_INT 29
4950: PPUSH
4951: LD_INT 100
4953: PPUSH
4954: CALL 54377 0 5
// un := CreateVehicle ;
4958: LD_ADDR_VAR 0 2
4962: PUSH
4963: CALL_OW 45
4967: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4968: LD_ADDR_VAR 0 3
4972: PUSH
4973: LD_VAR 0 3
4977: PPUSH
4978: LD_INT 1
4980: PUSH
4981: LD_VAR 0 3
4985: PUSH
4986: LD_INT 1
4988: ARRAY
4989: PUSH
4990: LD_INT 1
4992: PLUS
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PPUSH
4998: LD_VAR 0 2
5002: PPUSH
5003: CALL 54499 0 3
5007: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 3
5015: PPUSH
5016: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 16
5027: PPUSH
5028: LD_INT 0
5030: PPUSH
5031: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 51
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 111
// wait ( 0 0$2 ) ;
5050: LD_INT 70
5052: PPUSH
5053: CALL_OW 67
// end ;
5057: GO 4920
5059: POP
5060: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5061: LD_ADDR_VAR 0 5
5065: PUSH
5066: LD_INT 51
5068: PUSH
5069: LD_INT 24
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 75
5078: PUSH
5079: LD_INT 90
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5090: LD_INT 1
5092: PPUSH
5093: LD_VAR 0 3
5097: PUSH
5098: LD_INT 1
5100: ARRAY
5101: PPUSH
5102: LD_VAR 0 5
5106: PPUSH
5107: LD_VAR 0 6
5111: PPUSH
5112: CALL 41103 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5116: LD_ADDR_VAR 0 1
5120: PUSH
5121: DOUBLE
5122: LD_INT 1
5124: DEC
5125: ST_TO_ADDR
5126: LD_INT 1
5128: PUSH
5129: LD_INT 3
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: LIST
5139: PUSH
5140: LD_OWVAR 67
5144: ARRAY
5145: PUSH
5146: FOR_TO
5147: IFFALSE 5247
// begin uc_side := 2 ;
5149: LD_ADDR_OWVAR 20
5153: PUSH
5154: LD_INT 2
5156: ST_TO_ADDR
// uc_nation := 2 ;
5157: LD_ADDR_OWVAR 21
5161: PUSH
5162: LD_INT 2
5164: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5165: LD_INT 0
5167: PPUSH
5168: LD_INT 17
5170: PPUSH
5171: LD_VAR 0 4
5175: PPUSH
5176: CALL_OW 380
// un := CreateHuman ;
5180: LD_ADDR_VAR 0 2
5184: PUSH
5185: CALL_OW 44
5189: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5190: LD_ADDR_VAR 0 3
5194: PUSH
5195: LD_VAR 0 3
5199: PPUSH
5200: LD_INT 2
5202: PUSH
5203: LD_VAR 0 3
5207: PUSH
5208: LD_INT 2
5210: ARRAY
5211: PUSH
5212: LD_INT 1
5214: PLUS
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PPUSH
5220: LD_VAR 0 2
5224: PPUSH
5225: CALL 54499 0 3
5229: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5230: LD_VAR 0 2
5234: PPUSH
5235: LD_INT 13
5237: PPUSH
5238: LD_INT 0
5240: PPUSH
5241: CALL_OW 49
// end ;
5245: GO 5146
5247: POP
5248: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5249: LD_ADDR_VAR 0 1
5253: PUSH
5254: DOUBLE
5255: LD_INT 1
5257: DEC
5258: ST_TO_ADDR
5259: LD_INT 3
5261: PUSH
5262: LD_INT 4
5264: PUSH
5265: LD_INT 4
5267: PUSH
5268: EMPTY
5269: LIST
5270: LIST
5271: LIST
5272: PUSH
5273: LD_OWVAR 67
5277: ARRAY
5278: PUSH
5279: FOR_TO
5280: IFFALSE 5401
// begin uc_side := 2 ;
5282: LD_ADDR_OWVAR 20
5286: PUSH
5287: LD_INT 2
5289: ST_TO_ADDR
// uc_nation := 2 ;
5290: LD_ADDR_OWVAR 21
5294: PUSH
5295: LD_INT 2
5297: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5298: LD_INT 0
5300: PPUSH
5301: LD_INT 1
5303: PUSH
5304: LD_INT 8
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PUSH
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 2
5318: MOD
5319: PUSH
5320: LD_INT 1
5322: PLUS
5323: ARRAY
5324: PPUSH
5325: LD_VAR 0 4
5329: PPUSH
5330: CALL_OW 380
// un := CreateHuman ;
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: CALL_OW 44
5343: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: LD_VAR 0 3
5353: PPUSH
5354: LD_INT 2
5356: PUSH
5357: LD_VAR 0 3
5361: PUSH
5362: LD_INT 2
5364: ARRAY
5365: PUSH
5366: LD_INT 1
5368: PLUS
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: PPUSH
5374: LD_VAR 0 2
5378: PPUSH
5379: CALL 54499 0 3
5383: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5384: LD_VAR 0 2
5388: PPUSH
5389: LD_INT 13
5391: PPUSH
5392: LD_INT 0
5394: PPUSH
5395: CALL_OW 49
// end ;
5399: GO 5279
5401: POP
5402: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5403: LD_ADDR_VAR 0 5
5407: PUSH
5408: LD_INT 67
5410: PUSH
5411: LD_INT 112
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PUSH
5418: LD_INT 85
5420: PUSH
5421: LD_INT 130
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5432: LD_INT 2
5434: PPUSH
5435: LD_VAR 0 3
5439: PUSH
5440: LD_INT 2
5442: ARRAY
5443: PPUSH
5444: LD_VAR 0 5
5448: PPUSH
5449: LD_VAR 0 6
5453: PPUSH
5454: CALL 41103 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5458: LD_ADDR_VAR 0 1
5462: PUSH
5463: DOUBLE
5464: LD_INT 1
5466: DEC
5467: ST_TO_ADDR
5468: LD_INT 1
5470: PUSH
5471: LD_INT 2
5473: PUSH
5474: LD_INT 3
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: PUSH
5482: LD_OWVAR 67
5486: ARRAY
5487: PUSH
5488: FOR_TO
5489: IFFALSE 5589
// begin uc_side := 2 ;
5491: LD_ADDR_OWVAR 20
5495: PUSH
5496: LD_INT 2
5498: ST_TO_ADDR
// uc_nation := 2 ;
5499: LD_ADDR_OWVAR 21
5503: PUSH
5504: LD_INT 2
5506: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5507: LD_INT 0
5509: PPUSH
5510: LD_INT 17
5512: PPUSH
5513: LD_VAR 0 4
5517: PPUSH
5518: CALL_OW 380
// un := CreateHuman ;
5522: LD_ADDR_VAR 0 2
5526: PUSH
5527: CALL_OW 44
5531: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5532: LD_ADDR_VAR 0 3
5536: PUSH
5537: LD_VAR 0 3
5541: PPUSH
5542: LD_INT 3
5544: PUSH
5545: LD_VAR 0 3
5549: PUSH
5550: LD_INT 3
5552: ARRAY
5553: PUSH
5554: LD_INT 1
5556: PLUS
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: PPUSH
5562: LD_VAR 0 2
5566: PPUSH
5567: CALL 54499 0 3
5571: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5572: LD_VAR 0 2
5576: PPUSH
5577: LD_INT 14
5579: PPUSH
5580: LD_INT 0
5582: PPUSH
5583: CALL_OW 49
// end ;
5587: GO 5488
5589: POP
5590: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5591: LD_ADDR_VAR 0 5
5595: PUSH
5596: LD_INT 148
5598: PUSH
5599: LD_INT 158
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 148
5608: PUSH
5609: LD_INT 158
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5620: LD_INT 3
5622: PPUSH
5623: LD_VAR 0 3
5627: PUSH
5628: LD_INT 3
5630: ARRAY
5631: PPUSH
5632: LD_VAR 0 5
5636: PPUSH
5637: LD_VAR 0 6
5641: PPUSH
5642: CALL 41103 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5646: LD_ADDR_VAR 0 1
5650: PUSH
5651: DOUBLE
5652: LD_INT 1
5654: DEC
5655: ST_TO_ADDR
5656: LD_INT 2
5658: PUSH
5659: LD_INT 4
5661: PUSH
5662: LD_INT 4
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: PUSH
5670: LD_OWVAR 67
5674: ARRAY
5675: PUSH
5676: FOR_TO
5677: IFFALSE 5901
// begin uc_side := 2 ;
5679: LD_ADDR_OWVAR 20
5683: PUSH
5684: LD_INT 2
5686: ST_TO_ADDR
// uc_nation := 2 ;
5687: LD_ADDR_OWVAR 21
5691: PUSH
5692: LD_INT 2
5694: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5695: LD_INT 14
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: LD_INT 1
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 1
5713: PPUSH
5714: LD_INT 2
5716: PPUSH
5717: CALL_OW 12
5721: ARRAY
5722: PPUSH
5723: LD_INT 27
5725: PUSH
5726: LD_INT 26
5728: PUSH
5729: LD_INT 28
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 3
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PPUSH
5749: LD_INT 100
5751: PPUSH
5752: CALL 54377 0 5
// un := CreateVehicle ;
5756: LD_ADDR_VAR 0 2
5760: PUSH
5761: CALL_OW 45
5765: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5766: LD_ADDR_VAR 0 3
5770: PUSH
5771: LD_VAR 0 3
5775: PPUSH
5776: LD_INT 4
5778: PUSH
5779: LD_VAR 0 3
5783: PUSH
5784: LD_INT 4
5786: ARRAY
5787: PUSH
5788: LD_INT 1
5790: PLUS
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PPUSH
5796: LD_VAR 0 2
5800: PPUSH
5801: CALL 54499 0 3
5805: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5806: LD_VAR 0 2
5810: PPUSH
5811: LD_INT 5
5813: PPUSH
5814: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5818: LD_VAR 0 2
5822: PPUSH
5823: LD_INT 15
5825: PPUSH
5826: LD_INT 0
5828: PPUSH
5829: CALL_OW 49
// if GetControl ( un ) = control_manual then
5833: LD_VAR 0 2
5837: PPUSH
5838: CALL_OW 263
5842: PUSH
5843: LD_INT 1
5845: EQUAL
5846: IFFALSE 5877
// begin PrepareHuman ( false , 3 , skill ) ;
5848: LD_INT 0
5850: PPUSH
5851: LD_INT 3
5853: PPUSH
5854: LD_VAR 0 4
5858: PPUSH
5859: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5863: CALL_OW 44
5867: PPUSH
5868: LD_VAR 0 2
5872: PPUSH
5873: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5877: LD_VAR 0 2
5881: PPUSH
5882: LD_INT 179
5884: PPUSH
5885: LD_INT 135
5887: PPUSH
5888: CALL_OW 111
// wait ( 0 0$2 ) ;
5892: LD_INT 70
5894: PPUSH
5895: CALL_OW 67
// end ;
5899: GO 5676
5901: POP
5902: POP
// vc_chassis := 15 ;
5903: LD_ADDR_OWVAR 37
5907: PUSH
5908: LD_INT 15
5910: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5911: LD_ADDR_VAR 0 3
5915: PUSH
5916: LD_VAR 0 3
5920: PPUSH
5921: LD_INT 4
5923: PUSH
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 4
5931: ARRAY
5932: PUSH
5933: LD_INT 1
5935: PLUS
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: PPUSH
5941: CALL_OW 45
5945: PPUSH
5946: CALL 54499 0 3
5950: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5951: LD_VAR 0 3
5955: PUSH
5956: LD_INT 4
5958: ARRAY
5959: PUSH
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 4
5967: ARRAY
5968: ARRAY
5969: PPUSH
5970: LD_INT 15
5972: PPUSH
5973: LD_INT 0
5975: PPUSH
5976: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5980: LD_INT 0
5982: PPUSH
5983: LD_INT 11
5985: PPUSH
5986: LD_VAR 0 4
5990: PPUSH
5991: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 3
6004: PPUSH
6005: LD_INT 4
6007: PUSH
6008: LD_VAR 0 3
6012: PUSH
6013: LD_INT 4
6015: ARRAY
6016: PUSH
6017: LD_INT 1
6019: PLUS
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL_OW 44
6029: PPUSH
6030: CALL 54499 0 3
6034: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6035: LD_VAR 0 3
6039: PUSH
6040: LD_INT 4
6042: ARRAY
6043: PUSH
6044: LD_VAR 0 3
6048: PUSH
6049: LD_INT 4
6051: ARRAY
6052: ARRAY
6053: PPUSH
6054: LD_VAR 0 3
6058: PUSH
6059: LD_INT 4
6061: ARRAY
6062: PUSH
6063: LD_VAR 0 3
6067: PUSH
6068: LD_INT 4
6070: ARRAY
6071: PUSH
6072: LD_INT 1
6074: MINUS
6075: ARRAY
6076: PPUSH
6077: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6081: LD_ADDR_VAR 0 5
6085: PUSH
6086: LD_INT 148
6088: PUSH
6089: LD_INT 140
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6099: LD_INT 1
6101: PPUSH
6102: LD_VAR 0 3
6106: PUSH
6107: LD_INT 4
6109: ARRAY
6110: PPUSH
6111: LD_VAR 0 5
6115: PPUSH
6116: LD_VAR 0 6
6120: PPUSH
6121: CALL 41103 0 4
// if gensher_active then
6125: LD_EXP 18
6129: IFFALSE 6531
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6131: LD_EXP 45
6135: PPUSH
6136: LD_STRING D10-Diet-1
6138: PPUSH
6139: CALL_OW 94
// for i = 1 to 2 do
6143: LD_ADDR_VAR 0 1
6147: PUSH
6148: DOUBLE
6149: LD_INT 1
6151: DEC
6152: ST_TO_ADDR
6153: LD_INT 2
6155: PUSH
6156: FOR_TO
6157: IFFALSE 6295
// begin uc_side := 2 ;
6159: LD_ADDR_OWVAR 20
6163: PUSH
6164: LD_INT 2
6166: ST_TO_ADDR
// uc_nation := 2 ;
6167: LD_ADDR_OWVAR 21
6171: PUSH
6172: LD_INT 2
6174: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6175: LD_INT 13
6177: PPUSH
6178: LD_INT 3
6180: PPUSH
6181: LD_INT 5
6183: PPUSH
6184: LD_INT 29
6186: PPUSH
6187: LD_INT 100
6189: PPUSH
6190: CALL 54377 0 5
// un := CreateVehicle ;
6194: LD_ADDR_VAR 0 2
6198: PUSH
6199: CALL_OW 45
6203: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6204: LD_ADDR_VAR 0 3
6208: PUSH
6209: LD_VAR 0 3
6213: PPUSH
6214: LD_INT 5
6216: PUSH
6217: LD_VAR 0 3
6221: PUSH
6222: LD_INT 5
6224: ARRAY
6225: PUSH
6226: LD_INT 1
6228: PLUS
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PPUSH
6234: LD_VAR 0 2
6238: PPUSH
6239: CALL 54499 0 3
6243: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6244: LD_VAR 0 2
6248: PPUSH
6249: LD_INT 0
6251: PPUSH
6252: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6256: LD_VAR 0 2
6260: PPUSH
6261: LD_INT 23
6263: PPUSH
6264: LD_INT 0
6266: PPUSH
6267: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6271: LD_VAR 0 2
6275: PPUSH
6276: LD_INT 85
6278: PPUSH
6279: LD_INT 152
6281: PPUSH
6282: CALL_OW 111
// wait ( 0 0$2 ) ;
6286: LD_INT 70
6288: PPUSH
6289: CALL_OW 67
// end ;
6293: GO 6156
6295: POP
6296: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6297: LD_ADDR_VAR 0 1
6301: PUSH
6302: DOUBLE
6303: LD_INT 1
6305: DEC
6306: ST_TO_ADDR
6307: LD_INT 2
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 3
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: PUSH
6321: LD_OWVAR 67
6325: ARRAY
6326: PUSH
6327: FOR_TO
6328: IFFALSE 6485
// begin uc_side := 2 ;
6330: LD_ADDR_OWVAR 20
6334: PUSH
6335: LD_INT 2
6337: ST_TO_ADDR
// uc_nation := 2 ;
6338: LD_ADDR_OWVAR 21
6342: PUSH
6343: LD_INT 2
6345: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6346: LD_INT 14
6348: PPUSH
6349: LD_INT 3
6351: PPUSH
6352: LD_INT 5
6354: PPUSH
6355: LD_INT 27
6357: PUSH
6358: LD_INT 28
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_INT 2
6370: PPUSH
6371: CALL_OW 12
6375: ARRAY
6376: PPUSH
6377: LD_INT 100
6379: PPUSH
6380: CALL 54377 0 5
// un := CreateVehicle ;
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: CALL_OW 45
6393: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6394: LD_ADDR_VAR 0 3
6398: PUSH
6399: LD_VAR 0 3
6403: PPUSH
6404: LD_INT 5
6406: PUSH
6407: LD_VAR 0 3
6411: PUSH
6412: LD_INT 5
6414: ARRAY
6415: PUSH
6416: LD_INT 1
6418: PLUS
6419: PUSH
6420: EMPTY
6421: LIST
6422: LIST
6423: PPUSH
6424: LD_VAR 0 2
6428: PPUSH
6429: CALL 54499 0 3
6433: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6434: LD_VAR 0 2
6438: PPUSH
6439: LD_INT 0
6441: PPUSH
6442: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6446: LD_VAR 0 2
6450: PPUSH
6451: LD_INT 23
6453: PPUSH
6454: LD_INT 0
6456: PPUSH
6457: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6461: LD_VAR 0 2
6465: PPUSH
6466: LD_INT 85
6468: PPUSH
6469: LD_INT 152
6471: PPUSH
6472: CALL_OW 111
// wait ( 0 0$2 ) ;
6476: LD_INT 70
6478: PPUSH
6479: CALL_OW 67
// end ;
6483: GO 6327
6485: POP
6486: POP
// coords := [ [ 97 , 143 ] ] ;
6487: LD_ADDR_VAR 0 5
6491: PUSH
6492: LD_INT 97
6494: PUSH
6495: LD_INT 143
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6505: LD_INT 1
6507: PPUSH
6508: LD_VAR 0 3
6512: PUSH
6513: LD_INT 5
6515: ARRAY
6516: PPUSH
6517: LD_VAR 0 5
6521: PPUSH
6522: LD_VAR 0 6
6526: PPUSH
6527: CALL 41103 0 4
// end ; Wait ( 13 13$00 ) ;
6531: LD_INT 27300
6533: PPUSH
6534: CALL_OW 67
// tmp := [ ] ;
6538: LD_ADDR_VAR 0 3
6542: PUSH
6543: EMPTY
6544: ST_TO_ADDR
// w := 1 ;
6545: LD_ADDR_VAR 0 7
6549: PUSH
6550: LD_INT 1
6552: ST_TO_ADDR
// repeat tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// if w mod 4 = 0 then
6560: LD_VAR 0 7
6564: PUSH
6565: LD_INT 4
6567: MOD
6568: PUSH
6569: LD_INT 0
6571: EQUAL
6572: IFFALSE 6659
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6574: LD_ADDR_VAR 0 8
6578: PUSH
6579: LD_INT 11
6581: PUSH
6582: LD_INT 1
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 24
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: PUSH
6597: LD_INT 11
6599: PUSH
6600: LD_INT 1
6602: PUSH
6603: LD_INT 2
6605: PUSH
6606: LD_INT 24
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 11
6617: PUSH
6618: LD_INT 1
6620: PUSH
6621: LD_INT 2
6623: PUSH
6624: LD_INT 24
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 11
6635: PUSH
6636: LD_INT 1
6638: PUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 24
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: ST_TO_ADDR
6657: GO 6761
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6659: LD_ADDR_VAR 0 8
6663: PUSH
6664: LD_INT 14
6666: PUSH
6667: LD_INT 1
6669: PUSH
6670: LD_INT 2
6672: PUSH
6673: LD_INT 28
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 14
6684: PUSH
6685: LD_INT 1
6687: PUSH
6688: LD_INT 2
6690: PUSH
6691: LD_INT 25
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: PUSH
6700: LD_INT 14
6702: PUSH
6703: LD_INT 1
6705: PUSH
6706: LD_INT 2
6708: PUSH
6709: LD_INT 28
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 14
6720: PUSH
6721: LD_INT 1
6723: PUSH
6724: LD_INT 2
6726: PUSH
6727: LD_INT 29
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 11
6738: PUSH
6739: LD_INT 1
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: LD_INT 24
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: ST_TO_ADDR
// if w mod 3 = 0 then
6761: LD_VAR 0 7
6765: PUSH
6766: LD_INT 3
6768: MOD
6769: PUSH
6770: LD_INT 0
6772: EQUAL
6773: IFFALSE 6849
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6775: LD_ADDR_VAR 0 8
6779: PUSH
6780: LD_VAR 0 8
6784: PPUSH
6785: LD_INT 1
6787: PUSH
6788: LD_VAR 0 8
6792: PUSH
6793: LD_VAR 0 1
6797: ARRAY
6798: PUSH
6799: LD_INT 1
6801: PLUS
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: PPUSH
6807: LD_INT 14
6809: PUSH
6810: LD_INT 1
6812: PUSH
6813: LD_INT 2
6815: PUSH
6816: LD_INT 25
6818: PUSH
6819: LD_INT 28
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 1
6828: PPUSH
6829: LD_INT 2
6831: PPUSH
6832: CALL_OW 12
6836: ARRAY
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 54499 0 3
6848: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6849: LD_INT 1
6851: PPUSH
6852: LD_VAR 0 8
6856: PPUSH
6857: CALL 40870 0 2
// if GetSide ( ar_dep_w ) = 2 then
6861: LD_INT 45
6863: PPUSH
6864: CALL_OW 255
6868: PUSH
6869: LD_INT 2
6871: EQUAL
6872: IFFALSE 6957
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6874: LD_ADDR_VAR 0 8
6878: PUSH
6879: LD_INT 14
6881: PUSH
6882: LD_INT 1
6884: PUSH
6885: LD_INT 2
6887: PUSH
6888: LD_INT 28
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: LIST
6896: PUSH
6897: LD_INT 14
6899: PUSH
6900: LD_INT 1
6902: PUSH
6903: LD_INT 2
6905: PUSH
6906: LD_INT 27
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 14
6917: PUSH
6918: LD_INT 1
6920: PUSH
6921: LD_INT 2
6923: PUSH
6924: LD_INT 27
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: LIST
6937: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6938: LD_INT 2
6940: PPUSH
6941: LD_VAR 0 8
6945: PPUSH
6946: CALL 40870 0 2
// wait ( 0 0$50 ) ;
6950: LD_INT 1750
6952: PPUSH
6953: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6957: LD_INT 35
6959: PPUSH
6960: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6964: LD_EXP 69
6968: PUSH
6969: LD_INT 1
6971: ARRAY
6972: PPUSH
6973: LD_INT 3
6975: PUSH
6976: LD_INT 34
6978: PUSH
6979: LD_INT 32
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PPUSH
6990: CALL_OW 72
6994: PUSH
6995: LD_INT 4
6997: GREATEREQUAL
6998: IFFALSE 6957
// wait ( 0 0$10 ) ;
7000: LD_INT 350
7002: PPUSH
7003: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7007: LD_ADDR_VAR 0 3
7011: PUSH
7012: LD_EXP 69
7016: PUSH
7017: LD_INT 1
7019: ARRAY
7020: PPUSH
7021: LD_INT 3
7023: PUSH
7024: LD_INT 34
7026: PUSH
7027: LD_INT 32
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7043: LD_INT 100
7045: PPUSH
7046: CALL_OW 13
7050: PUSH
7051: LD_INT 50
7053: LESS
7054: IFFALSE 7087
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7056: LD_ADDR_VAR 0 5
7060: PUSH
7061: LD_INT 55
7063: PUSH
7064: LD_INT 7
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 75
7073: PUSH
7074: LD_INT 90
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: ST_TO_ADDR
7085: GO 7116
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7087: LD_ADDR_VAR 0 5
7091: PUSH
7092: LD_INT 128
7094: PUSH
7095: LD_INT 94
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: PUSH
7102: LD_INT 180
7104: PUSH
7105: LD_INT 135
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: ST_TO_ADDR
// if w mod 4 = 0 then
7116: LD_VAR 0 7
7120: PUSH
7121: LD_INT 4
7123: MOD
7124: PUSH
7125: LD_INT 0
7127: EQUAL
7128: IFFALSE 7159
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7130: LD_ADDR_VAR 0 5
7134: PUSH
7135: LD_INT 91
7137: PUSH
7138: LD_INT 58
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 117
7147: PUSH
7148: LD_INT 107
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
7159: LD_INT 1
7161: PPUSH
7162: LD_VAR 0 3
7166: PPUSH
7167: LD_VAR 0 5
7171: PPUSH
7172: LD_VAR 0 6
7176: PPUSH
7177: CALL 41103 0 4
// if mc_vehicles [ 2 ] then
7181: LD_EXP 69
7185: PUSH
7186: LD_INT 2
7188: ARRAY
7189: IFFALSE 7225
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7191: LD_INT 2
7193: PPUSH
7194: LD_EXP 69
7198: PUSH
7199: LD_INT 2
7201: ARRAY
7202: PPUSH
7203: LD_INT 73
7205: PUSH
7206: LD_INT 115
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: PUSH
7213: EMPTY
7214: LIST
7215: PPUSH
7216: LD_VAR 0 6
7220: PPUSH
7221: CALL 41103 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7225: LD_INT 22050
7227: PPUSH
7228: LD_INT 28350
7230: PPUSH
7231: CALL_OW 12
7235: PPUSH
7236: CALL_OW 67
// w := w + 1 ;
7240: LD_ADDR_VAR 0 7
7244: PUSH
7245: LD_VAR 0 7
7249: PUSH
7250: LD_INT 1
7252: PLUS
7253: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7254: LD_INT 94
7256: PPUSH
7257: CALL_OW 301
7261: PUSH
7262: LD_EXP 50
7266: PUSH
7267: LD_INT 1
7269: ARRAY
7270: PPUSH
7271: LD_INT 30
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL_OW 72
7285: NOT
7286: OR
7287: IFFALSE 6553
// end ;
7289: PPOPN 8
7291: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7292: LD_INT 204
7294: IFFALSE 7760
7296: GO 7298
7298: DISABLE
7299: LD_INT 0
7301: PPUSH
7302: PPUSH
7303: PPUSH
7304: PPUSH
// begin enable ;
7305: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7306: LD_INT 35
7308: PPUSH
7309: LD_INT 1190
7311: PPUSH
7312: CALL_OW 12
7316: PPUSH
7317: CALL_OW 67
// tmp := [ ] ;
7321: LD_ADDR_VAR 0 2
7325: PUSH
7326: EMPTY
7327: ST_TO_ADDR
// uc_side := 8 ;
7328: LD_ADDR_OWVAR 20
7332: PUSH
7333: LD_INT 8
7335: ST_TO_ADDR
// uc_nation := 2 ;
7336: LD_ADDR_OWVAR 21
7340: PUSH
7341: LD_INT 2
7343: ST_TO_ADDR
// InitHc ;
7344: CALL_OW 19
// for i = 1 to 3 do
7348: LD_ADDR_VAR 0 1
7352: PUSH
7353: DOUBLE
7354: LD_INT 1
7356: DEC
7357: ST_TO_ADDR
7358: LD_INT 3
7360: PUSH
7361: FOR_TO
7362: IFFALSE 7489
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7364: LD_INT 13
7366: PUSH
7367: LD_INT 14
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: LD_INT 1
7376: PPUSH
7377: LD_INT 2
7379: PPUSH
7380: CALL_OW 12
7384: ARRAY
7385: PPUSH
7386: LD_INT 3
7388: PPUSH
7389: LD_INT 5
7391: PPUSH
7392: LD_INT 27
7394: PUSH
7395: LD_INT 28
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 1
7404: PPUSH
7405: LD_INT 2
7407: PPUSH
7408: CALL_OW 12
7412: ARRAY
7413: PPUSH
7414: LD_INT 100
7416: PPUSH
7417: CALL 54377 0 5
// un := CreateVehicle ;
7421: LD_ADDR_VAR 0 3
7425: PUSH
7426: CALL_OW 45
7430: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7431: LD_VAR 0 3
7435: PPUSH
7436: LD_INT 4
7438: PPUSH
7439: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7443: LD_VAR 0 3
7447: PPUSH
7448: LD_INT 15
7450: PPUSH
7451: LD_INT 0
7453: PPUSH
7454: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7458: LD_ADDR_VAR 0 2
7462: PUSH
7463: LD_VAR 0 2
7467: PPUSH
7468: LD_VAR 0 2
7472: PUSH
7473: LD_INT 1
7475: PLUS
7476: PPUSH
7477: LD_VAR 0 3
7481: PPUSH
7482: CALL_OW 1
7486: ST_TO_ADDR
// end ;
7487: GO 7361
7489: POP
7490: POP
// for i = 1 to 4 do
7491: LD_ADDR_VAR 0 1
7495: PUSH
7496: DOUBLE
7497: LD_INT 1
7499: DEC
7500: ST_TO_ADDR
7501: LD_INT 4
7503: PUSH
7504: FOR_TO
7505: IFFALSE 7576
// begin PrepareHuman ( false , 1 , 6 ) ;
7507: LD_INT 0
7509: PPUSH
7510: LD_INT 1
7512: PPUSH
7513: LD_INT 6
7515: PPUSH
7516: CALL_OW 380
// un := CreateHuman ;
7520: LD_ADDR_VAR 0 3
7524: PUSH
7525: CALL_OW 44
7529: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 15
7537: PPUSH
7538: LD_INT 0
7540: PPUSH
7541: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7545: LD_ADDR_VAR 0 2
7549: PUSH
7550: LD_VAR 0 2
7554: PPUSH
7555: LD_VAR 0 2
7559: PUSH
7560: LD_INT 1
7562: PLUS
7563: PPUSH
7564: LD_VAR 0 3
7568: PPUSH
7569: CALL_OW 1
7573: ST_TO_ADDR
// end ;
7574: GO 7504
7576: POP
7577: POP
// wait ( 0 0$3 ) ;
7578: LD_INT 105
7580: PPUSH
7581: CALL_OW 67
// for i in tmp do
7585: LD_ADDR_VAR 0 1
7589: PUSH
7590: LD_VAR 0 2
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7664
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL_OW 257
7607: PUSH
7608: LD_INT 1
7610: EQUAL
7611: PUSH
7612: LD_VAR 0 1
7616: PPUSH
7617: CALL_OW 247
7621: PUSH
7622: LD_INT 2
7624: EQUAL
7625: OR
7626: IFFALSE 7662
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7628: LD_VAR 0 1
7632: PPUSH
7633: LD_INT 81
7635: PUSH
7636: LD_INT 8
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PPUSH
7643: CALL_OW 69
7647: PPUSH
7648: LD_VAR 0 1
7652: PPUSH
7653: CALL_OW 74
7657: PPUSH
7658: CALL_OW 115
7662: GO 7595
7664: POP
7665: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_INT 210
7673: PPUSH
7674: LD_INT 178
7676: PPUSH
7677: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7681: LD_ADDR_VAR 0 4
7685: PUSH
7686: LD_INT 10
7688: PPUSH
7689: LD_INT 22
7691: PUSH
7692: LD_INT 8
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: PPUSH
7699: CALL_OW 70
7703: ST_TO_ADDR
// if x then
7704: LD_VAR 0 4
7708: IFFALSE 7736
// for i in x do
7710: LD_ADDR_VAR 0 1
7714: PUSH
7715: LD_VAR 0 4
7719: PUSH
7720: FOR_IN
7721: IFFALSE 7734
// RemoveUnit ( i ) ;
7723: LD_VAR 0 1
7727: PPUSH
7728: CALL_OW 64
7732: GO 7720
7734: POP
7735: POP
// wait ( 0 0$1 ) ;
7736: LD_INT 35
7738: PPUSH
7739: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7743: LD_INT 22
7745: PUSH
7746: LD_INT 8
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PPUSH
7753: CALL_OW 69
7757: NOT
7758: IFFALSE 7666
// end ;
7760: PPOPN 4
7762: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7763: LD_INT 22
7765: PUSH
7766: LD_INT 2
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: LD_INT 34
7775: PUSH
7776: LD_INT 31
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: LD_INT 3
7785: PUSH
7786: LD_INT 24
7788: PUSH
7789: LD_INT 1000
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: IFFALSE 7912
7811: GO 7813
7813: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7814: LD_INT 45
7816: PPUSH
7817: CALL_OW 302
7821: PUSH
7822: LD_INT 45
7824: PPUSH
7825: CALL_OW 255
7829: AND
7830: IFFALSE 7873
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7832: LD_INT 22
7834: PUSH
7835: LD_INT 2
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PUSH
7842: LD_INT 34
7844: PUSH
7845: LD_INT 31
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PPUSH
7856: CALL_OW 69
7860: PPUSH
7861: LD_INT 18
7863: PPUSH
7864: LD_INT 8
7866: PPUSH
7867: CALL_OW 111
7871: GO 7912
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7873: LD_INT 22
7875: PUSH
7876: LD_INT 2
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: LD_INT 34
7885: PUSH
7886: LD_INT 31
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PPUSH
7897: CALL_OW 69
7901: PPUSH
7902: LD_INT 106
7904: PPUSH
7905: LD_INT 14
7907: PPUSH
7908: CALL_OW 111
// end ; end_of_file
7912: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7913: LD_INT 0
7915: PPUSH
7916: PPUSH
7917: PPUSH
7918: PPUSH
7919: PPUSH
7920: PPUSH
// InGameOn ;
7921: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7925: LD_EXP 21
7929: PPUSH
7930: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7934: LD_INT 2
7936: PPUSH
7937: LD_INT 1
7939: PPUSH
7940: LD_INT 1
7942: PPUSH
7943: LD_INT 1
7945: PPUSH
7946: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7950: LD_ADDR_VAR 0 2
7954: PUSH
7955: LD_INT 22
7957: PUSH
7958: LD_INT 1
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PUSH
7965: LD_INT 25
7967: PUSH
7968: LD_INT 1
7970: PUSH
7971: EMPTY
7972: LIST
7973: LIST
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 69
7983: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7984: LD_ADDR_VAR 0 4
7988: PUSH
7989: LD_INT 22
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 34
8001: PUSH
8002: LD_INT 11
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 69
8017: PUSH
8018: LD_INT 1
8020: ARRAY
8021: ST_TO_ADDR
// for i = 1 to tmp do
8022: LD_ADDR_VAR 0 6
8026: PUSH
8027: DOUBLE
8028: LD_INT 1
8030: DEC
8031: ST_TO_ADDR
8032: LD_VAR 0 2
8036: PUSH
8037: FOR_TO
8038: IFFALSE 8085
// begin if i = 5 then
8040: LD_VAR 0 6
8044: PUSH
8045: LD_INT 5
8047: EQUAL
8048: IFFALSE 8052
// break ;
8050: GO 8085
// sols := Replace ( sols , i , tmp [ i ] ) ;
8052: LD_ADDR_VAR 0 5
8056: PUSH
8057: LD_VAR 0 5
8061: PPUSH
8062: LD_VAR 0 6
8066: PPUSH
8067: LD_VAR 0 2
8071: PUSH
8072: LD_VAR 0 6
8076: ARRAY
8077: PPUSH
8078: CALL_OW 1
8082: ST_TO_ADDR
// end ;
8083: GO 8037
8085: POP
8086: POP
// tmp := ar_force_tmp ;
8087: LD_ADDR_VAR 0 2
8091: PUSH
8092: LD_EXP 40
8096: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8097: LD_VAR 0 2
8101: PUSH
8102: LD_INT 1
8104: ARRAY
8105: PPUSH
8106: LD_INT 108
8108: PPUSH
8109: LD_INT 139
8111: PPUSH
8112: LD_INT 0
8114: PPUSH
8115: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_EXP 21
8132: PPUSH
8133: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 2
8144: ARRAY
8145: PPUSH
8146: LD_INT 114
8148: PPUSH
8149: LD_INT 132
8151: PPUSH
8152: LD_INT 0
8154: PPUSH
8155: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8159: LD_VAR 0 2
8163: PUSH
8164: LD_INT 3
8166: ARRAY
8167: PPUSH
8168: LD_INT 115
8170: PPUSH
8171: LD_INT 132
8173: PPUSH
8174: LD_INT 0
8176: PPUSH
8177: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8181: LD_VAR 0 2
8185: PUSH
8186: LD_INT 2
8188: ARRAY
8189: PUSH
8190: LD_VAR 0 2
8194: PUSH
8195: LD_INT 3
8197: ARRAY
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: PPUSH
8203: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8207: LD_VAR 0 4
8211: PPUSH
8212: LD_INT 83
8214: PPUSH
8215: LD_INT 123
8217: PPUSH
8218: CALL_OW 111
// Wait ( 0 0$01 ) ;
8222: LD_INT 35
8224: PPUSH
8225: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8229: LD_INT 90
8231: PPUSH
8232: LD_INT 144
8234: PPUSH
8235: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8239: LD_VAR 0 5
8243: PPUSH
8244: LD_INT 88
8246: PPUSH
8247: LD_INT 129
8249: PPUSH
8250: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8254: LD_ADDR_VAR 0 3
8258: PUSH
8259: LD_INT 92
8261: PUSH
8262: LD_INT 131
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 88
8271: PUSH
8272: LD_INT 127
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 91
8281: PUSH
8282: LD_INT 132
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PUSH
8289: LD_INT 92
8291: PUSH
8292: LD_INT 134
8294: PUSH
8295: EMPTY
8296: LIST
8297: LIST
8298: PUSH
8299: EMPTY
8300: LIST
8301: LIST
8302: LIST
8303: LIST
8304: ST_TO_ADDR
// for i = 1 to sols do
8305: LD_ADDR_VAR 0 6
8309: PUSH
8310: DOUBLE
8311: LD_INT 1
8313: DEC
8314: ST_TO_ADDR
8315: LD_VAR 0 5
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8394
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8323: LD_VAR 0 5
8327: PUSH
8328: LD_VAR 0 6
8332: ARRAY
8333: PPUSH
8334: LD_VAR 0 3
8338: PUSH
8339: LD_VAR 0 6
8343: ARRAY
8344: PUSH
8345: LD_INT 1
8347: ARRAY
8348: PPUSH
8349: LD_VAR 0 3
8353: PUSH
8354: LD_VAR 0 6
8358: ARRAY
8359: PUSH
8360: LD_INT 2
8362: ARRAY
8363: PPUSH
8364: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8368: LD_VAR 0 5
8372: PUSH
8373: LD_VAR 0 6
8377: ARRAY
8378: PPUSH
8379: CALL_OW 197
// AddComHold ( sols ) ;
8383: LD_VAR 0 5
8387: PPUSH
8388: CALL_OW 200
// end ;
8392: GO 8320
8394: POP
8395: POP
// repeat wait ( 0 0$1 ) ;
8396: LD_INT 35
8398: PPUSH
8399: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8403: LD_VAR 0 5
8407: PUSH
8408: LD_INT 1
8410: ARRAY
8411: PPUSH
8412: LD_INT 92
8414: PPUSH
8415: LD_INT 131
8417: PPUSH
8418: CALL_OW 297
8422: PUSH
8423: LD_INT 4
8425: LESS
8426: IFFALSE 8396
// CenterOnXY ( 96 , 139 ) ;
8428: LD_INT 96
8430: PPUSH
8431: LD_INT 139
8433: PPUSH
8434: CALL_OW 84
// wait ( 0 0$3 ) ;
8438: LD_INT 105
8440: PPUSH
8441: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8445: LD_INT 111
8447: PPUSH
8448: LD_INT 135
8450: PPUSH
8451: LD_INT 1
8453: PPUSH
8454: LD_INT 25
8456: NEG
8457: PPUSH
8458: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8462: LD_VAR 0 2
8466: PUSH
8467: LD_INT 2
8469: ARRAY
8470: PPUSH
8471: LD_VAR 0 2
8475: PUSH
8476: LD_INT 1
8478: ARRAY
8479: PPUSH
8480: CALL_OW 250
8484: PUSH
8485: LD_INT 3
8487: PLUS
8488: PPUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 1
8496: ARRAY
8497: PPUSH
8498: CALL_OW 251
8502: PPUSH
8503: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 3
8514: ARRAY
8515: PPUSH
8516: LD_INT 7
8518: PPUSH
8519: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8523: LD_VAR 0 2
8527: PUSH
8528: LD_INT 2
8530: ARRAY
8531: PPUSH
8532: LD_VAR 0 2
8536: PUSH
8537: LD_INT 1
8539: ARRAY
8540: PPUSH
8541: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8545: LD_INT 35
8547: PPUSH
8548: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8552: LD_VAR 0 2
8556: PUSH
8557: LD_INT 1
8559: ARRAY
8560: PPUSH
8561: LD_VAR 0 2
8565: PUSH
8566: LD_INT 2
8568: ARRAY
8569: PPUSH
8570: CALL_OW 296
8574: PUSH
8575: LD_INT 5
8577: LESS
8578: IFFALSE 8545
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8580: LD_VAR 0 2
8584: PUSH
8585: LD_INT 1
8587: ARRAY
8588: PPUSH
8589: LD_VAR 0 2
8593: PUSH
8594: LD_INT 2
8596: ARRAY
8597: PPUSH
8598: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8602: LD_VAR 0 2
8606: PUSH
8607: LD_INT 1
8609: ARRAY
8610: PPUSH
8611: LD_STRING D1a-Merc1-1
8613: PPUSH
8614: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8618: LD_VAR 0 2
8622: PUSH
8623: LD_INT 2
8625: ARRAY
8626: PPUSH
8627: LD_STRING D1a-FMerc2-1
8629: PPUSH
8630: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8634: LD_VAR 0 2
8638: PUSH
8639: LD_INT 2
8641: ARRAY
8642: PPUSH
8643: LD_VAR 0 2
8647: PUSH
8648: LD_INT 1
8650: ARRAY
8651: PPUSH
8652: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8656: LD_VAR 0 2
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_INT 500
8667: PPUSH
8668: CALL_OW 234
// wait ( 0 0$2 ) ;
8672: LD_INT 70
8674: PPUSH
8675: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8679: LD_VAR 0 2
8683: PUSH
8684: LD_INT 1
8686: ARRAY
8687: PPUSH
8688: LD_INT 2
8690: PPUSH
8691: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8695: LD_INT 10
8697: PPUSH
8698: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8702: LD_VAR 0 2
8706: PUSH
8707: LD_INT 1
8709: ARRAY
8710: PPUSH
8711: LD_STRING D1a-Merc1-2
8713: PPUSH
8714: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8718: LD_INT 7
8720: PPUSH
8721: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8725: LD_VAR 0 2
8729: PUSH
8730: LD_INT 1
8732: ARRAY
8733: PPUSH
8734: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8738: LD_VAR 0 2
8742: PUSH
8743: LD_INT 2
8745: ARRAY
8746: PPUSH
8747: LD_INT 10
8749: PPUSH
8750: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8754: LD_VAR 0 2
8758: PUSH
8759: LD_INT 2
8761: ARRAY
8762: PPUSH
8763: LD_STRING D1a-FMerc2-2
8765: PPUSH
8766: CALL_OW 88
// wait ( 0 0$1 ) ;
8770: LD_INT 35
8772: PPUSH
8773: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8777: LD_INT 7
8779: PPUSH
8780: CALL_OW 85
// wait ( 0 0$2 ) ;
8784: LD_INT 70
8786: PPUSH
8787: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8791: LD_EXP 44
8795: PPUSH
8796: LD_STRING D1a-Saliba-1
8798: PPUSH
8799: CALL_OW 91
// KillUnit ( Saliba ) ;
8803: LD_EXP 44
8807: PPUSH
8808: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8812: LD_VAR 0 2
8816: PUSH
8817: LD_INT 3
8819: ARRAY
8820: PPUSH
8821: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8825: LD_EXP 21
8829: PPUSH
8830: CALL_OW 85
// wait ( 0 0$1 ) ;
8834: LD_INT 35
8836: PPUSH
8837: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8841: LD_VAR 0 5
8845: PPUSH
8846: LD_INT 88
8848: PPUSH
8849: LD_INT 141
8851: PPUSH
8852: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8856: LD_VAR 0 5
8860: PPUSH
8861: LD_INT 70
8863: PPUSH
8864: CALL_OW 202
// wait ( 0 0$2 ) ;
8868: LD_INT 70
8870: PPUSH
8871: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8875: LD_INT 2
8877: PPUSH
8878: LD_INT 1
8880: PPUSH
8881: LD_INT 2
8883: PPUSH
8884: LD_INT 1
8886: PPUSH
8887: CALL_OW 80
// InGameOff ;
8891: CALL_OW 9
// ComWalk ( sols ) ;
8895: LD_VAR 0 5
8899: PPUSH
8900: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8904: LD_STRING M1
8906: PPUSH
8907: CALL_OW 337
// game_speed := 4 ;
8911: LD_ADDR_OWVAR 65
8915: PUSH
8916: LD_INT 4
8918: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8919: LD_INT 111
8921: PPUSH
8922: LD_INT 135
8924: PPUSH
8925: LD_INT 1
8927: PPUSH
8928: CALL_OW 331
// SaveForQuickRestart ;
8932: CALL_OW 22
// ar_run := true ;
8936: LD_ADDR_EXP 5
8940: PUSH
8941: LD_INT 1
8943: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8944: LD_INT 35
8946: PPUSH
8947: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8951: LD_INT 22
8953: PUSH
8954: LD_INT 1
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 91
8963: PUSH
8964: LD_INT 7
8966: PUSH
8967: LD_INT 10
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: LIST
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: PPUSH
8979: CALL_OW 69
8983: PUSH
8984: LD_INT 7
8986: PPUSH
8987: CALL_OW 256
8991: PUSH
8992: LD_INT 999
8994: LESS
8995: OR
8996: IFFALSE 8944
// if GetSide ( ar_dep_s ) = 2 then
8998: LD_INT 7
9000: PPUSH
9001: CALL_OW 255
9005: PUSH
9006: LD_INT 2
9008: EQUAL
9009: IFFALSE 9021
// SetSide ( ar_dep_s , 1 ) ;
9011: LD_INT 7
9013: PPUSH
9014: LD_INT 1
9016: PPUSH
9017: CALL_OW 235
// end ;
9021: LD_VAR 0 1
9025: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9026: LD_EXP 5
9030: IFFALSE 9390
9032: GO 9034
9034: DISABLE
9035: LD_INT 0
9037: PPUSH
9038: PPUSH
9039: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9040: LD_ADDR_VAR 0 2
9044: PUSH
9045: LD_EXP 40
9049: PUSH
9050: LD_EXP 36
9054: PPUSH
9055: LD_INT 2
9057: PUSH
9058: LD_INT 21
9060: PUSH
9061: LD_INT 2
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: LD_INT 21
9070: PUSH
9071: LD_INT 1
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: LIST
9082: PPUSH
9083: CALL_OW 72
9087: ADD
9088: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9089: LD_VAR 0 2
9093: PPUSH
9094: LD_INT 5
9096: PPUSH
9097: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9101: LD_INT 5
9103: PPUSH
9104: LD_INT 1
9106: PPUSH
9107: CALL_OW 343
// k := 1 ;
9111: LD_ADDR_VAR 0 3
9115: PUSH
9116: LD_INT 1
9118: ST_TO_ADDR
// for i in tmp do
9119: LD_ADDR_VAR 0 1
9123: PUSH
9124: LD_VAR 0 2
9128: PUSH
9129: FOR_IN
9130: IFFALSE 9215
// begin if IsInUnit ( i ) then
9132: LD_VAR 0 1
9136: PPUSH
9137: CALL_OW 310
9141: IFFALSE 9152
// ComExitBuilding ( i ) ;
9143: LD_VAR 0 1
9147: PPUSH
9148: CALL_OW 122
// if GetClass ( i ) = 3 then
9152: LD_VAR 0 1
9156: PPUSH
9157: CALL_OW 257
9161: PUSH
9162: LD_INT 3
9164: EQUAL
9165: IFFALSE 9201
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9167: LD_VAR 0 1
9171: PPUSH
9172: LD_EXP 41
9176: PUSH
9177: LD_VAR 0 3
9181: ARRAY
9182: PPUSH
9183: CALL_OW 180
// k := k + 1 ;
9187: LD_ADDR_VAR 0 3
9191: PUSH
9192: LD_VAR 0 3
9196: PUSH
9197: LD_INT 1
9199: PLUS
9200: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9201: LD_VAR 0 1
9205: PPUSH
9206: LD_INT 10
9208: PPUSH
9209: CALL_OW 173
// end ;
9213: GO 9129
9215: POP
9216: POP
// ar_patrol := true ;
9217: LD_ADDR_EXP 7
9221: PUSH
9222: LD_INT 1
9224: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9225: LD_INT 10
9227: PPUSH
9228: CALL_OW 67
// for i in tmp do
9232: LD_ADDR_VAR 0 1
9236: PUSH
9237: LD_VAR 0 2
9241: PUSH
9242: FOR_IN
9243: IFFALSE 9271
// if not HasTask ( i ) then
9245: LD_VAR 0 1
9249: PPUSH
9250: CALL_OW 314
9254: NOT
9255: IFFALSE 9269
// ComMoveToArea ( i , escape_area ) ;
9257: LD_VAR 0 1
9261: PPUSH
9262: LD_INT 10
9264: PPUSH
9265: CALL_OW 113
9269: GO 9242
9271: POP
9272: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9273: LD_ADDR_VAR 0 3
9277: PUSH
9278: LD_VAR 0 2
9282: PPUSH
9283: LD_INT 95
9285: PUSH
9286: LD_INT 10
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PPUSH
9293: CALL_OW 72
9297: ST_TO_ADDR
// if k then
9298: LD_VAR 0 3
9302: IFFALSE 9371
// for i in k do
9304: LD_ADDR_VAR 0 1
9308: PUSH
9309: LD_VAR 0 3
9313: PUSH
9314: FOR_IN
9315: IFFALSE 9369
// begin if IsInUnit ( i ) then
9317: LD_VAR 0 1
9321: PPUSH
9322: CALL_OW 310
9326: IFFALSE 9342
// RemoveUnit ( IsInUnit ( i ) ) ;
9328: LD_VAR 0 1
9332: PPUSH
9333: CALL_OW 310
9337: PPUSH
9338: CALL_OW 64
// RemoveUnit ( i ) ;
9342: LD_VAR 0 1
9346: PPUSH
9347: CALL_OW 64
// tmp := tmp diff i ;
9351: LD_ADDR_VAR 0 2
9355: PUSH
9356: LD_VAR 0 2
9360: PUSH
9361: LD_VAR 0 1
9365: DIFF
9366: ST_TO_ADDR
// end ;
9367: GO 9314
9369: POP
9370: POP
// until tmp = [ ] ;
9371: LD_VAR 0 2
9375: PUSH
9376: EMPTY
9377: EQUAL
9378: IFFALSE 9225
// ChangeSideFog ( 5 , 5 ) ;
9380: LD_INT 5
9382: PPUSH
9383: LD_INT 5
9385: PPUSH
9386: CALL_OW 343
// end ;
9390: PPOPN 3
9392: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9393: LD_EXP 7
9397: IFFALSE 9687
9399: GO 9401
9401: DISABLE
9402: LD_INT 0
9404: PPUSH
9405: PPUSH
9406: PPUSH
// begin uc_side := 2 ;
9407: LD_ADDR_OWVAR 20
9411: PUSH
9412: LD_INT 2
9414: ST_TO_ADDR
// uc_nation := 2 ;
9415: LD_ADDR_OWVAR 21
9419: PUSH
9420: LD_INT 2
9422: ST_TO_ADDR
// InitHc ;
9423: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9427: LD_INT 1
9429: PPUSH
9430: LD_INT 1
9432: PPUSH
9433: LD_INT 6
9435: PPUSH
9436: CALL_OW 380
// un := CreateHuman ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: CALL_OW 44
9449: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9450: LD_INT 14
9452: PPUSH
9453: LD_INT 1
9455: PPUSH
9456: LD_INT 1
9458: PPUSH
9459: LD_INT 27
9461: PPUSH
9462: LD_INT 98
9464: PPUSH
9465: CALL 54377 0 5
// veh := CreateVehicle ;
9469: LD_ADDR_VAR 0 3
9473: PUSH
9474: CALL_OW 45
9478: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9479: LD_VAR 0 3
9483: PPUSH
9484: LD_INT 4
9486: PPUSH
9487: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9491: LD_VAR 0 3
9495: PPUSH
9496: LD_INT 179
9498: PPUSH
9499: LD_INT 135
9501: PPUSH
9502: LD_INT 0
9504: PPUSH
9505: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9509: LD_VAR 0 2
9513: PPUSH
9514: LD_VAR 0 3
9518: PPUSH
9519: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9523: LD_VAR 0 2
9527: PPUSH
9528: LD_INT 126
9530: PPUSH
9531: LD_INT 133
9533: PPUSH
9534: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9538: LD_INT 10
9540: PPUSH
9541: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9545: LD_INT 1
9547: PPUSH
9548: LD_VAR 0 3
9552: PPUSH
9553: CALL_OW 292
9557: PUSH
9558: LD_VAR 0 3
9562: PPUSH
9563: LD_INT 7
9565: PPUSH
9566: CALL_OW 296
9570: PUSH
9571: LD_INT 9
9573: LESS
9574: OR
9575: IFFALSE 9538
// ComHold ( veh ) ;
9577: LD_VAR 0 3
9581: PPUSH
9582: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9586: LD_VAR 0 2
9590: PPUSH
9591: LD_STRING D2aa-Ar1-1
9593: PPUSH
9594: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9598: LD_VAR 0 2
9602: PPUSH
9603: LD_INT 177
9605: PPUSH
9606: LD_INT 96
9608: PPUSH
9609: CALL_OW 111
// AddComExitVehicle ( un ) ;
9613: LD_VAR 0 2
9617: PPUSH
9618: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9622: LD_INT 35
9624: PPUSH
9625: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9629: LD_VAR 0 2
9633: PPUSH
9634: LD_INT 204
9636: PPUSH
9637: CALL_OW 296
9641: PUSH
9642: LD_INT 15
9644: LESS
9645: IFFALSE 9622
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9647: LD_ADDR_EXP 50
9651: PUSH
9652: LD_EXP 50
9656: PPUSH
9657: LD_INT 3
9659: PUSH
9660: LD_EXP 50
9664: PUSH
9665: LD_INT 3
9667: ARRAY
9668: PUSH
9669: LD_INT 1
9671: PLUS
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_VAR 0 2
9681: PPUSH
9682: CALL 54499 0 3
9686: ST_TO_ADDR
// end ;
9687: PPOPN 3
9689: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9690: LD_INT 7
9692: PPUSH
9693: CALL_OW 255
9697: PUSH
9698: LD_INT 1
9700: EQUAL
9701: PUSH
9702: LD_INT 7
9704: PPUSH
9705: CALL_OW 301
9709: OR
9710: IFFALSE 12134
9712: GO 9714
9714: DISABLE
9715: LD_INT 0
9717: PPUSH
9718: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9719: LD_ADDR_VAR 0 1
9723: PUSH
9724: LD_EXP 36
9728: PPUSH
9729: LD_INT 21
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: PPUSH
9739: CALL_OW 72
9743: PUSH
9744: FOR_IN
9745: IFFALSE 9761
// SetSide ( i , 1 ) ;
9747: LD_VAR 0 1
9751: PPUSH
9752: LD_INT 1
9754: PPUSH
9755: CALL_OW 235
9759: GO 9744
9761: POP
9762: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9763: LD_ADDR_VAR 0 2
9767: PUSH
9768: LD_INT 46
9770: PUSH
9771: LD_INT 41
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 50
9780: PUSH
9781: LD_INT 25
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 57
9790: PUSH
9791: LD_INT 75
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: PUSH
9798: LD_INT 75
9800: PUSH
9801: LD_INT 89
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PUSH
9808: LD_INT 51
9810: PUSH
9811: LD_INT 45
9813: PUSH
9814: EMPTY
9815: LIST
9816: LIST
9817: PUSH
9818: LD_INT 95
9820: PUSH
9821: LD_INT 95
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PUSH
9828: LD_INT 84
9830: PUSH
9831: LD_INT 77
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PUSH
9838: LD_INT 101
9840: PUSH
9841: LD_INT 76
9843: PUSH
9844: EMPTY
9845: LIST
9846: LIST
9847: PUSH
9848: LD_INT 118
9850: PUSH
9851: LD_INT 81
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: PUSH
9858: LD_INT 139
9860: PUSH
9861: LD_INT 97
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PUSH
9868: LD_INT 129
9870: PUSH
9871: LD_INT 114
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PUSH
9878: LD_INT 154
9880: PUSH
9881: LD_INT 111
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: LIST
9901: ST_TO_ADDR
// base_captured := true ;
9902: LD_ADDR_EXP 6
9906: PUSH
9907: LD_INT 1
9909: ST_TO_ADDR
// DialogueOn ;
9910: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9914: LD_EXP 21
9918: PPUSH
9919: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9923: LD_EXP 21
9927: PPUSH
9928: LD_STRING D2-JMM-1
9930: PPUSH
9931: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9935: LD_EXP 30
9939: PPUSH
9940: LD_STRING D2-Pow-1
9942: PPUSH
9943: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9947: LD_EXP 21
9951: PPUSH
9952: LD_STRING D2-JMM-2
9954: PPUSH
9955: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9959: LD_EXP 30
9963: PPUSH
9964: LD_STRING D2-Pow-2
9966: PPUSH
9967: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9971: LD_EXP 21
9975: PPUSH
9976: LD_STRING D2-JMM-3
9978: PPUSH
9979: CALL_OW 88
// DialogueOff ;
9983: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9987: LD_STRING M2
9989: PPUSH
9990: CALL_OW 337
// Wait ( 0 0$2 ) ;
9994: LD_INT 70
9996: PPUSH
9997: CALL_OW 67
// if IsOk ( Gary ) then
10001: LD_EXP 32
10005: PPUSH
10006: CALL_OW 302
10010: IFFALSE 10024
// Say ( Gary , D2a-Gary-1 ) ;
10012: LD_EXP 32
10016: PPUSH
10017: LD_STRING D2a-Gary-1
10019: PPUSH
10020: CALL_OW 88
// if IsOk ( Bobby ) then
10024: LD_EXP 24
10028: PPUSH
10029: CALL_OW 302
10033: IFFALSE 10047
// Say ( Bobby , D2a-Bobby-1 ) ;
10035: LD_EXP 24
10039: PPUSH
10040: LD_STRING D2a-Bobby-1
10042: PPUSH
10043: CALL_OW 88
// if IsOk ( Cyrus ) then
10047: LD_EXP 25
10051: PPUSH
10052: CALL_OW 302
10056: IFFALSE 10070
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10058: LD_EXP 25
10062: PPUSH
10063: LD_STRING D2a-Cyrus-1
10065: PPUSH
10066: CALL_OW 88
// if IsOk ( Lisa ) then
10070: LD_EXP 22
10074: PPUSH
10075: CALL_OW 302
10079: IFFALSE 10093
// Say ( Lisa , D2a-Lisa-1 ) ;
10081: LD_EXP 22
10085: PPUSH
10086: LD_STRING D2a-Lisa-1
10088: PPUSH
10089: CALL_OW 88
// if IsOk ( Frank ) then
10093: LD_EXP 33
10097: PPUSH
10098: CALL_OW 302
10102: IFFALSE 10116
// Say ( Frank , D2a-Frank-1 ) ;
10104: LD_EXP 33
10108: PPUSH
10109: LD_STRING D2a-Frank-1
10111: PPUSH
10112: CALL_OW 88
// if IsOk ( Cornel ) then
10116: LD_EXP 31
10120: PPUSH
10121: CALL_OW 302
10125: IFFALSE 10139
// Say ( Cornel , D2a-Corn-1 ) ;
10127: LD_EXP 31
10131: PPUSH
10132: LD_STRING D2a-Corn-1
10134: PPUSH
10135: CALL_OW 88
// if IsOk ( Donaldson ) then
10139: LD_EXP 23
10143: PPUSH
10144: CALL_OW 302
10148: IFFALSE 10162
// Say ( Donaldson , D2a-Don-1 ) ;
10150: LD_EXP 23
10154: PPUSH
10155: LD_STRING D2a-Don-1
10157: PPUSH
10158: CALL_OW 88
// if IsOk ( Brown ) then
10162: LD_EXP 27
10166: PPUSH
10167: CALL_OW 302
10171: IFFALSE 10185
// Say ( Brown , D2a-Brown-1 ) ;
10173: LD_EXP 27
10177: PPUSH
10178: LD_STRING D2a-Brown-1
10180: PPUSH
10181: CALL_OW 88
// Wait ( 0 0$30 ) ;
10185: LD_INT 1050
10187: PPUSH
10188: CALL_OW 67
// if IsOk ( Frank ) then
10192: LD_EXP 33
10196: PPUSH
10197: CALL_OW 302
10201: IFFALSE 10467
// begin DialogueOn ;
10203: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10207: LD_EXP 21
10211: PUSH
10212: LD_EXP 33
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PPUSH
10221: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10225: LD_EXP 33
10229: PPUSH
10230: LD_STRING D3F-Frank-1
10232: PPUSH
10233: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10237: LD_EXP 21
10241: PPUSH
10242: LD_STRING D3F-JMM-1
10244: PPUSH
10245: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10249: LD_EXP 33
10253: PPUSH
10254: LD_STRING D3F-Frank-2
10256: PPUSH
10257: CALL_OW 88
// case Query ( QFrank ) of 1 :
10261: LD_STRING QFrank
10263: PPUSH
10264: CALL_OW 97
10268: PUSH
10269: LD_INT 1
10271: DOUBLE
10272: EQUAL
10273: IFTRUE 10277
10275: GO 10300
10277: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10278: LD_EXP 21
10282: PPUSH
10283: LD_STRING D3Fa-JMM-1
10285: PPUSH
10286: CALL_OW 88
// us_scout := 1 ;
10290: LD_ADDR_EXP 8
10294: PUSH
10295: LD_INT 1
10297: ST_TO_ADDR
// end ; 2 :
10298: GO 10463
10300: LD_INT 2
10302: DOUBLE
10303: EQUAL
10304: IFTRUE 10308
10306: GO 10430
10308: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10309: LD_EXP 21
10313: PPUSH
10314: LD_STRING D3Fb-JMM-1
10316: PPUSH
10317: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10321: LD_EXP 33
10325: PPUSH
10326: LD_STRING D3Fb-Frank-1
10328: PPUSH
10329: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10333: LD_STRING QFrank2
10335: PPUSH
10336: CALL_OW 97
10340: PUSH
10341: LD_INT 1
10343: DOUBLE
10344: EQUAL
10345: IFTRUE 10349
10347: GO 10396
10349: POP
// begin us_scout := 2 ;
10350: LD_ADDR_EXP 8
10354: PUSH
10355: LD_INT 2
10357: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10358: LD_EXP 21
10362: PPUSH
10363: LD_STRING D3Fba-JMM-1
10365: PPUSH
10366: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10370: LD_EXP 33
10374: PPUSH
10375: LD_STRING D3Fba-Frank-1
10377: PPUSH
10378: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10382: LD_EXP 21
10386: PPUSH
10387: LD_STRING D3Fba-JMM-2
10389: PPUSH
10390: CALL_OW 88
// end ; 2 :
10394: GO 10428
10396: LD_INT 2
10398: DOUBLE
10399: EQUAL
10400: IFTRUE 10404
10402: GO 10427
10404: POP
// begin us_scout := 0 ;
10405: LD_ADDR_EXP 8
10409: PUSH
10410: LD_INT 0
10412: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10413: LD_EXP 21
10417: PPUSH
10418: LD_STRING D3Fbb-JMM-1
10420: PPUSH
10421: CALL_OW 88
// end ; end ;
10425: GO 10428
10427: POP
// end ; 3 :
10428: GO 10463
10430: LD_INT 3
10432: DOUBLE
10433: EQUAL
10434: IFTRUE 10438
10436: GO 10462
10438: POP
// begin us_scout := - 1 ;
10439: LD_ADDR_EXP 8
10443: PUSH
10444: LD_INT 1
10446: NEG
10447: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10448: LD_EXP 21
10452: PPUSH
10453: LD_STRING D3Fc-JMM-1
10455: PPUSH
10456: CALL_OW 88
// end ; end ;
10460: GO 10463
10462: POP
// DialogueOff ;
10463: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10467: LD_EXP 8
10471: PUSH
10472: LD_INT 1
10474: NEG
10475: PUSH
10476: LD_INT 0
10478: PUSH
10479: EMPTY
10480: LIST
10481: LIST
10482: IN
10483: IFFALSE 10487
// exit ;
10485: GO 12134
// if us_scout in [ 1 , 2 ] then
10487: LD_EXP 8
10491: PUSH
10492: LD_INT 1
10494: PUSH
10495: LD_INT 2
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: IN
10502: IFFALSE 11201
// begin if IsInUnit ( Frank ) then
10504: LD_EXP 33
10508: PPUSH
10509: CALL_OW 310
10513: IFFALSE 10524
// ComExitBuilding ( Frank ) ;
10515: LD_EXP 33
10519: PPUSH
10520: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10524: LD_EXP 33
10528: PPUSH
10529: CALL_OW 311
10533: IFFALSE 10544
// ComExitVehicle ( Frank ) ;
10535: LD_EXP 33
10539: PPUSH
10540: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10544: LD_EXP 33
10548: PPUSH
10549: LD_INT 4
10551: PPUSH
10552: CALL_OW 235
// wait ( 0 0$1 ) ;
10556: LD_INT 35
10558: PPUSH
10559: CALL_OW 67
// if us_scout = 2 then
10563: LD_EXP 8
10567: PUSH
10568: LD_INT 2
10570: EQUAL
10571: IFFALSE 10939
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10573: LD_EXP 33
10577: PPUSH
10578: LD_INT 75
10580: PPUSH
10581: LD_INT 63
10583: PPUSH
10584: CALL_OW 111
// AddComHold ( Frank ) ;
10588: LD_EXP 33
10592: PPUSH
10593: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10597: LD_EXP 33
10601: PPUSH
10602: LD_INT 770
10604: PPUSH
10605: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10609: LD_EXP 33
10613: PPUSH
10614: LD_INT 100
10616: PPUSH
10617: LD_INT 75
10619: PPUSH
10620: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10624: LD_EXP 33
10628: PPUSH
10629: LD_INT 123
10631: PPUSH
10632: LD_INT 103
10634: PPUSH
10635: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10639: LD_EXP 33
10643: PPUSH
10644: LD_INT 138
10646: PPUSH
10647: LD_INT 108
10649: PPUSH
10650: CALL_OW 171
// AddComHold ( Frank ) ;
10654: LD_EXP 33
10658: PPUSH
10659: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10663: LD_INT 35
10665: PPUSH
10666: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10670: LD_EXP 33
10674: PPUSH
10675: LD_INT 138
10677: PPUSH
10678: LD_INT 108
10680: PPUSH
10681: CALL_OW 307
10685: IFFALSE 10663
// AddComMoveXY ( Frank , 125 , 132 ) ;
10687: LD_EXP 33
10691: PPUSH
10692: LD_INT 125
10694: PPUSH
10695: LD_INT 132
10697: PPUSH
10698: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10702: LD_INT 35
10704: PPUSH
10705: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10709: LD_INT 1
10711: PPUSH
10712: LD_EXP 33
10716: PPUSH
10717: CALL_OW 292
10721: PUSH
10722: LD_EXP 33
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 296
10734: PUSH
10735: LD_INT 7
10737: LESS
10738: OR
10739: IFFALSE 10702
// DialogueOn ;
10741: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10745: LD_EXP 33
10749: PPUSH
10750: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10754: LD_INT 10
10756: PPUSH
10757: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10761: LD_EXP 21
10765: PPUSH
10766: LD_STRING D4Fa-JMM-1
10768: PPUSH
10769: CALL_OW 88
// for i in points do
10773: LD_ADDR_VAR 0 1
10777: PUSH
10778: LD_VAR 0 2
10782: PUSH
10783: FOR_IN
10784: IFFALSE 10842
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10786: LD_VAR 0 1
10790: PUSH
10791: LD_INT 1
10793: ARRAY
10794: PPUSH
10795: LD_VAR 0 1
10799: PUSH
10800: LD_INT 2
10802: ARRAY
10803: PPUSH
10804: LD_INT 1
10806: PPUSH
10807: LD_INT 20
10809: NEG
10810: PPUSH
10811: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10815: LD_VAR 0 1
10819: PUSH
10820: LD_INT 1
10822: ARRAY
10823: PPUSH
10824: LD_VAR 0 1
10828: PUSH
10829: LD_INT 2
10831: ARRAY
10832: PPUSH
10833: LD_INT 1
10835: PPUSH
10836: CALL_OW 331
// end ;
10840: GO 10783
10842: POP
10843: POP
// dwait ( 0 0$0.5 ) ;
10844: LD_INT 18
10846: PPUSH
10847: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10851: LD_INT 42
10853: PPUSH
10854: LD_INT 27
10856: PPUSH
10857: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10861: LD_EXP 33
10865: PPUSH
10866: LD_STRING D4Fa-Frank-1
10868: PPUSH
10869: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10873: LD_INT 18
10875: PPUSH
10876: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10880: LD_EXP 21
10884: PPUSH
10885: LD_STRING D4Fa-JMM-2
10887: PPUSH
10888: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10892: LD_INT 118
10894: PPUSH
10895: LD_INT 80
10897: PPUSH
10898: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10902: LD_EXP 33
10906: PPUSH
10907: LD_STRING D4Fa-Frank-2
10909: PPUSH
10910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10914: LD_INT 10
10916: PPUSH
10917: CALL_OW 68
// DialogueOff ;
10921: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10925: LD_EXP 33
10929: PPUSH
10930: LD_INT 1
10932: PPUSH
10933: CALL_OW 235
// end else
10937: GO 11201
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10939: LD_INT 2
10941: PPUSH
10942: LD_INT 4
10944: PPUSH
10945: LD_INT 2
10947: PPUSH
10948: LD_INT 1
10950: PPUSH
10951: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10955: LD_EXP 33
10959: PPUSH
10960: LD_INT 75
10962: PPUSH
10963: LD_INT 63
10965: PPUSH
10966: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10970: LD_EXP 33
10974: PPUSH
10975: LD_INT 175
10977: PPUSH
10978: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10982: LD_EXP 33
10986: PPUSH
10987: LD_INT 102
10989: PPUSH
10990: LD_INT 76
10992: PPUSH
10993: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10997: LD_EXP 33
11001: PPUSH
11002: LD_INT 108
11004: PPUSH
11005: LD_INT 70
11007: PPUSH
11008: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11012: LD_INT 35
11014: PPUSH
11015: CALL_OW 67
// until See ( 2 , Frank ) ;
11019: LD_INT 2
11021: PPUSH
11022: LD_EXP 33
11026: PPUSH
11027: CALL_OW 292
11031: IFFALSE 11012
// ComMoveXY ( Frank , 112 , 118 ) ;
11033: LD_EXP 33
11037: PPUSH
11038: LD_INT 112
11040: PPUSH
11041: LD_INT 118
11043: PPUSH
11044: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11048: LD_EXP 33
11052: PPUSH
11053: CALL_OW 256
11057: PUSH
11058: LD_INT 750
11060: GREATEREQUAL
11061: IFFALSE 11075
// SetLives ( Frank , 700 ) ;
11063: LD_EXP 33
11067: PPUSH
11068: LD_INT 700
11070: PPUSH
11071: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11075: LD_INT 35
11077: PPUSH
11078: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11082: LD_INT 1
11084: PPUSH
11085: LD_EXP 33
11089: PPUSH
11090: CALL_OW 292
11094: PUSH
11095: LD_EXP 33
11099: PPUSH
11100: LD_INT 7
11102: PPUSH
11103: CALL_OW 296
11107: PUSH
11108: LD_INT 17
11110: LESS
11111: OR
11112: IFFALSE 11075
// DialogueOn ;
11114: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11118: LD_EXP 33
11122: PPUSH
11123: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11127: LD_EXP 33
11131: PPUSH
11132: LD_STRING D4Fb-Frank-1
11134: PPUSH
11135: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11139: LD_EXP 21
11143: PPUSH
11144: LD_STRING D4Fb-JMM-1
11146: PPUSH
11147: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11151: LD_INT 2
11153: PPUSH
11154: LD_STRING D4Fb-FSci1-1
11156: PPUSH
11157: CALL 16038 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11161: LD_EXP 33
11165: PPUSH
11166: LD_STRING D4Fb-Frank-2
11168: PPUSH
11169: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11173: LD_EXP 21
11177: PPUSH
11178: LD_STRING D4Fb-JMM-2
11180: PPUSH
11181: CALL_OW 88
// DialogueOff ;
11185: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11189: LD_EXP 33
11193: PPUSH
11194: LD_INT 1
11196: PPUSH
11197: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11201: LD_EXP 34
11205: PPUSH
11206: CALL_OW 302
11210: PUSH
11211: LD_EXP 33
11215: NOT
11216: AND
11217: IFFALSE 11365
// begin DialogueOn ;
11219: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11223: LD_EXP 21
11227: PUSH
11228: LD_EXP 34
11232: PUSH
11233: EMPTY
11234: LIST
11235: LIST
11236: PPUSH
11237: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11241: LD_EXP 34
11245: PPUSH
11246: LD_STRING D3Y-Yam-1
11248: PPUSH
11249: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11253: LD_EXP 21
11257: PPUSH
11258: LD_STRING D3Y-JMM-1
11260: PPUSH
11261: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11265: LD_EXP 34
11269: PPUSH
11270: LD_STRING D3Y-Yam-2
11272: PPUSH
11273: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11277: LD_STRING QYamoko
11279: PPUSH
11280: CALL_OW 97
11284: PUSH
11285: LD_INT 1
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11328
11293: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11294: LD_EXP 21
11298: PPUSH
11299: LD_STRING D3Ya-JMM-1
11301: PPUSH
11302: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11306: LD_EXP 34
11310: PPUSH
11311: LD_STRING D3Ya-Yam-1
11313: PPUSH
11314: CALL_OW 88
// us_scout := 1 ;
11318: LD_ADDR_EXP 8
11322: PUSH
11323: LD_INT 1
11325: ST_TO_ADDR
// end ; 2 :
11326: GO 11361
11328: LD_INT 2
11330: DOUBLE
11331: EQUAL
11332: IFTRUE 11336
11334: GO 11360
11336: POP
// begin us_scout := - 1 ;
11337: LD_ADDR_EXP 8
11341: PUSH
11342: LD_INT 1
11344: NEG
11345: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11346: LD_EXP 21
11350: PPUSH
11351: LD_STRING D3Yb-JMM-1
11353: PPUSH
11354: CALL_OW 88
// end ; end ;
11358: GO 11361
11360: POP
// DialogueOff ;
11361: CALL_OW 7
// end ; if Frank then
11365: LD_EXP 33
11369: IFFALSE 11373
// exit ;
11371: GO 12134
// if us_scout in [ - 1 , 0 ] then
11373: LD_EXP 8
11377: PUSH
11378: LD_INT 1
11380: NEG
11381: PUSH
11382: LD_INT 0
11384: PUSH
11385: EMPTY
11386: LIST
11387: LIST
11388: IN
11389: IFFALSE 11393
// exit ;
11391: GO 12134
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11393: LD_ADDR_EXP 8
11397: PUSH
11398: LD_INT 2
11400: PUSH
11401: LD_INT 2
11403: PUSH
11404: LD_INT 1
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: LIST
11411: PUSH
11412: LD_OWVAR 67
11416: ARRAY
11417: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11418: LD_EXP 8
11422: PUSH
11423: LD_INT 1
11425: PUSH
11426: LD_INT 2
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: IN
11433: IFFALSE 12134
// begin if IsInUnit ( Kikuchi ) then
11435: LD_EXP 34
11439: PPUSH
11440: CALL_OW 310
11444: IFFALSE 11455
// ComExitBuilding ( Kikuchi ) ;
11446: LD_EXP 34
11450: PPUSH
11451: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11455: LD_EXP 34
11459: PPUSH
11460: CALL_OW 311
11464: IFFALSE 11475
// ComExitVehicle ( Kikuchi ) ;
11466: LD_EXP 34
11470: PPUSH
11471: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11475: LD_EXP 34
11479: PPUSH
11480: LD_INT 4
11482: PPUSH
11483: CALL_OW 235
// wait ( 0 0$1 ) ;
11487: LD_INT 35
11489: PPUSH
11490: CALL_OW 67
// if us_scout = 2 then
11494: LD_EXP 8
11498: PUSH
11499: LD_INT 2
11501: EQUAL
11502: IFFALSE 11882
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11504: LD_EXP 34
11508: PPUSH
11509: LD_INT 75
11511: PPUSH
11512: LD_INT 63
11514: PPUSH
11515: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11519: LD_EXP 34
11523: PPUSH
11524: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11528: LD_EXP 34
11532: PPUSH
11533: LD_INT 770
11535: PPUSH
11536: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11540: LD_EXP 34
11544: PPUSH
11545: LD_INT 100
11547: PPUSH
11548: LD_INT 75
11550: PPUSH
11551: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11555: LD_EXP 34
11559: PPUSH
11560: LD_INT 123
11562: PPUSH
11563: LD_INT 103
11565: PPUSH
11566: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11570: LD_EXP 34
11574: PPUSH
11575: LD_INT 138
11577: PPUSH
11578: LD_INT 108
11580: PPUSH
11581: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11585: LD_EXP 34
11589: PPUSH
11590: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11594: LD_INT 35
11596: PPUSH
11597: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11601: LD_EXP 34
11605: PPUSH
11606: LD_INT 138
11608: PPUSH
11609: LD_INT 108
11611: PPUSH
11612: CALL_OW 307
11616: IFFALSE 11594
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11618: LD_EXP 34
11622: PPUSH
11623: LD_INT 125
11625: PPUSH
11626: LD_INT 132
11628: PPUSH
11629: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11633: LD_INT 35
11635: PPUSH
11636: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11640: LD_INT 1
11642: PPUSH
11643: LD_EXP 34
11647: PPUSH
11648: CALL_OW 292
11652: PUSH
11653: LD_EXP 34
11657: PPUSH
11658: LD_INT 7
11660: PPUSH
11661: CALL_OW 296
11665: PUSH
11666: LD_INT 7
11668: LESS
11669: OR
11670: IFFALSE 11633
// DialogueOn ;
11672: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11676: LD_EXP 34
11680: PPUSH
11681: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11685: LD_INT 10
11687: PPUSH
11688: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11692: LD_EXP 34
11696: PPUSH
11697: LD_STRING D4Ya-Yam-1
11699: PPUSH
11700: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11704: LD_EXP 21
11708: PPUSH
11709: LD_STRING D4Ya-JMM-1
11711: PPUSH
11712: CALL_OW 88
// for i in points do
11716: LD_ADDR_VAR 0 1
11720: PUSH
11721: LD_VAR 0 2
11725: PUSH
11726: FOR_IN
11727: IFFALSE 11785
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11729: LD_VAR 0 1
11733: PUSH
11734: LD_INT 1
11736: ARRAY
11737: PPUSH
11738: LD_VAR 0 1
11742: PUSH
11743: LD_INT 2
11745: ARRAY
11746: PPUSH
11747: LD_INT 1
11749: PPUSH
11750: LD_INT 20
11752: NEG
11753: PPUSH
11754: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11758: LD_VAR 0 1
11762: PUSH
11763: LD_INT 1
11765: ARRAY
11766: PPUSH
11767: LD_VAR 0 1
11771: PUSH
11772: LD_INT 2
11774: ARRAY
11775: PPUSH
11776: LD_INT 1
11778: PPUSH
11779: CALL_OW 331
// end ;
11783: GO 11726
11785: POP
11786: POP
// dwait ( 0 0$0.5 ) ;
11787: LD_INT 18
11789: PPUSH
11790: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11794: LD_INT 42
11796: PPUSH
11797: LD_INT 27
11799: PPUSH
11800: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11804: LD_EXP 34
11808: PPUSH
11809: LD_STRING D4Ya-Yam-2
11811: PPUSH
11812: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11816: LD_INT 18
11818: PPUSH
11819: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11823: LD_INT 118
11825: PPUSH
11826: LD_INT 80
11828: PPUSH
11829: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11833: LD_EXP 21
11837: PPUSH
11838: LD_STRING D4Ya-JMM-2
11840: PPUSH
11841: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11845: LD_EXP 34
11849: PPUSH
11850: LD_STRING D4Ya-Yam-3
11852: PPUSH
11853: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11857: LD_INT 10
11859: PPUSH
11860: CALL_OW 68
// DialogueOff ;
11864: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_INT 1
11875: PPUSH
11876: CALL_OW 235
// end else
11880: GO 12134
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11882: LD_INT 2
11884: PPUSH
11885: LD_INT 4
11887: PPUSH
11888: LD_INT 2
11890: PPUSH
11891: LD_INT 1
11893: PPUSH
11894: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11898: LD_EXP 34
11902: PPUSH
11903: LD_INT 75
11905: PPUSH
11906: LD_INT 63
11908: PPUSH
11909: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11913: LD_EXP 34
11917: PPUSH
11918: LD_INT 175
11920: PPUSH
11921: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11925: LD_EXP 34
11929: PPUSH
11930: LD_INT 102
11932: PPUSH
11933: LD_INT 76
11935: PPUSH
11936: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11940: LD_EXP 34
11944: PPUSH
11945: LD_INT 108
11947: PPUSH
11948: LD_INT 70
11950: PPUSH
11951: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11955: LD_INT 35
11957: PPUSH
11958: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11962: LD_INT 2
11964: PPUSH
11965: LD_EXP 34
11969: PPUSH
11970: CALL_OW 292
11974: IFFALSE 11955
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11976: LD_EXP 34
11980: PPUSH
11981: LD_INT 112
11983: PPUSH
11984: LD_INT 118
11986: PPUSH
11987: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11991: LD_EXP 34
11995: PPUSH
11996: CALL_OW 256
12000: PUSH
12001: LD_INT 750
12003: GREATEREQUAL
12004: IFFALSE 12018
// SetLives ( Kikuchi , 700 ) ;
12006: LD_EXP 34
12010: PPUSH
12011: LD_INT 700
12013: PPUSH
12014: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12018: LD_INT 35
12020: PPUSH
12021: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12025: LD_INT 1
12027: PPUSH
12028: LD_EXP 34
12032: PPUSH
12033: CALL_OW 292
12037: PUSH
12038: LD_EXP 34
12042: PPUSH
12043: LD_INT 7
12045: PPUSH
12046: CALL_OW 296
12050: PUSH
12051: LD_INT 17
12053: LESS
12054: OR
12055: IFFALSE 12018
// DialogueOn ;
12057: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12061: LD_EXP 34
12065: PPUSH
12066: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12070: LD_EXP 34
12074: PPUSH
12075: LD_STRING D4Yb-Yam-1
12077: PPUSH
12078: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12082: LD_EXP 21
12086: PPUSH
12087: LD_STRING D4Yb-JMM-1
12089: PPUSH
12090: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12094: LD_EXP 34
12098: PPUSH
12099: LD_STRING D4Yb-Yam-2
12101: PPUSH
12102: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12106: LD_EXP 21
12110: PPUSH
12111: LD_STRING D4Yb-JMM-2
12113: PPUSH
12114: CALL_OW 88
// DialogueOff ;
12118: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12122: LD_EXP 34
12126: PPUSH
12127: LD_INT 1
12129: PPUSH
12130: CALL_OW 235
// end ; end ; end ;
12134: PPOPN 2
12136: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12137: LD_EXP 6
12141: IFFALSE 13174
12143: GO 12145
12145: DISABLE
12146: LD_INT 0
12148: PPUSH
12149: PPUSH
12150: PPUSH
12151: PPUSH
// begin enable ;
12152: ENABLE
// if not seen [ 1 ] then
12153: LD_EXP 9
12157: PUSH
12158: LD_INT 1
12160: ARRAY
12161: NOT
12162: IFFALSE 12342
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12164: LD_ADDR_VAR 0 2
12168: PUSH
12169: LD_INT 22
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: LD_INT 2
12181: PUSH
12182: LD_INT 25
12184: PUSH
12185: LD_INT 11
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 33
12194: PUSH
12195: LD_INT 4
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: PPUSH
12211: CALL_OW 69
12215: ST_TO_ADDR
// if tmp then
12216: LD_VAR 0 2
12220: IFFALSE 12342
// for i in tmp do
12222: LD_ADDR_VAR 0 1
12226: PUSH
12227: LD_VAR 0 2
12231: PUSH
12232: FOR_IN
12233: IFFALSE 12340
// if See ( 1 , i ) then
12235: LD_INT 1
12237: PPUSH
12238: LD_VAR 0 1
12242: PPUSH
12243: CALL_OW 292
12247: IFFALSE 12338
// begin seen := Replace ( seen , 1 , true ) ;
12249: LD_ADDR_EXP 9
12253: PUSH
12254: LD_EXP 9
12258: PPUSH
12259: LD_INT 1
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: CALL_OW 1
12269: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12270: LD_INT 1
12272: PPUSH
12273: CALL 15860 0 1
12277: IFFALSE 12338
// begin DialogueOn ;
12279: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12283: LD_VAR 0 1
12287: PPUSH
12288: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12292: LD_INT 10
12294: PPUSH
12295: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12299: LD_ADDR_VAR 0 3
12303: PUSH
12304: LD_INT 1
12306: PPUSH
12307: LD_STRING D5a-Sol2-1
12309: PPUSH
12310: CALL 16038 0 2
12314: ST_TO_ADDR
// if not un then
12315: LD_VAR 0 3
12319: NOT
12320: IFFALSE 12332
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12322: LD_INT 2
12324: PPUSH
12325: LD_STRING D5a-FSol2-1
12327: PPUSH
12328: CALL 16038 0 2
// DialogueOff ;
12332: CALL_OW 7
// break ;
12336: GO 12340
// end ; end ;
12338: GO 12232
12340: POP
12341: POP
// end ; if not seen [ 2 ] then
12342: LD_EXP 9
12346: PUSH
12347: LD_INT 2
12349: ARRAY
12350: NOT
12351: IFFALSE 12576
// begin can_kamikazed := true ;
12353: LD_ADDR_EXP 10
12357: PUSH
12358: LD_INT 1
12360: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12361: LD_ADDR_VAR 0 2
12365: PUSH
12366: LD_INT 22
12368: PUSH
12369: LD_INT 2
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PUSH
12376: LD_INT 25
12378: PUSH
12379: LD_INT 17
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PPUSH
12390: CALL_OW 69
12394: ST_TO_ADDR
// if tmp then
12395: LD_VAR 0 2
12399: IFFALSE 12576
// for i in tmp do
12401: LD_ADDR_VAR 0 1
12405: PUSH
12406: LD_VAR 0 2
12410: PUSH
12411: FOR_IN
12412: IFFALSE 12574
// if See ( 1 , i ) then
12414: LD_INT 1
12416: PPUSH
12417: LD_VAR 0 1
12421: PPUSH
12422: CALL_OW 292
12426: IFFALSE 12572
// begin seen := Replace ( seen , 2 , true ) ;
12428: LD_ADDR_EXP 9
12432: PUSH
12433: LD_EXP 9
12437: PPUSH
12438: LD_INT 2
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: CALL_OW 1
12448: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12449: LD_INT 1
12451: PPUSH
12452: CALL 15860 0 1
12456: IFFALSE 12572
// begin DialogueOn ;
12458: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12462: LD_VAR 0 1
12466: PPUSH
12467: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12471: LD_INT 10
12473: PPUSH
12474: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12478: LD_ADDR_VAR 0 3
12482: PUSH
12483: LD_INT 1
12485: PPUSH
12486: LD_STRING D5b-Sol1-1
12488: PPUSH
12489: CALL 16038 0 2
12493: ST_TO_ADDR
// if not un then
12494: LD_VAR 0 3
12498: NOT
12499: IFFALSE 12517
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12501: LD_ADDR_VAR 0 3
12505: PUSH
12506: LD_INT 2
12508: PPUSH
12509: LD_STRING D5b-FSol1-1
12511: PPUSH
12512: CALL 16038 0 2
12516: ST_TO_ADDR
// if un then
12517: LD_VAR 0 3
12521: IFFALSE 12566
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12523: LD_ADDR_VAR 0 4
12527: PUSH
12528: LD_INT 1
12530: PPUSH
12531: LD_STRING D5b-Sol2-1
12533: PPUSH
12534: LD_VAR 0 3
12538: PPUSH
12539: CALL 16264 0 3
12543: ST_TO_ADDR
// if not un2 then
12544: LD_VAR 0 4
12548: NOT
12549: IFFALSE 12566
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12551: LD_INT 2
12553: PPUSH
12554: LD_STRING D5b-FSol2-1
12556: PPUSH
12557: LD_VAR 0 3
12561: PPUSH
12562: CALL 16264 0 3
// end ; DialogueOff ;
12566: CALL_OW 7
// break ;
12570: GO 12574
// end ; end ;
12572: GO 12411
12574: POP
12575: POP
// end ; if not seen [ 3 ] then
12576: LD_EXP 9
12580: PUSH
12581: LD_INT 3
12583: ARRAY
12584: NOT
12585: IFFALSE 12759
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12587: LD_ADDR_VAR 0 2
12591: PUSH
12592: LD_INT 22
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 33
12604: PUSH
12605: LD_INT 2
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PPUSH
12616: CALL_OW 69
12620: ST_TO_ADDR
// if tmp then
12621: LD_VAR 0 2
12625: IFFALSE 12759
// for i in tmp do
12627: LD_ADDR_VAR 0 1
12631: PUSH
12632: LD_VAR 0 2
12636: PUSH
12637: FOR_IN
12638: IFFALSE 12757
// if See ( 1 , i ) then
12640: LD_INT 1
12642: PPUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: CALL_OW 292
12652: IFFALSE 12755
// begin seen := Replace ( seen , 3 , true ) ;
12654: LD_ADDR_EXP 9
12658: PUSH
12659: LD_EXP 9
12663: PPUSH
12664: LD_INT 3
12666: PPUSH
12667: LD_INT 1
12669: PPUSH
12670: CALL_OW 1
12674: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12675: LD_INT 1
12677: PPUSH
12678: CALL 15860 0 1
12682: IFFALSE 12755
// begin DialogueOn ;
12684: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12688: LD_VAR 0 1
12692: PPUSH
12693: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12697: LD_INT 10
12699: PPUSH
12700: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12704: LD_ADDR_VAR 0 3
12708: PUSH
12709: LD_INT 1
12711: PPUSH
12712: LD_STRING D8-Sol1-1
12714: PPUSH
12715: CALL 16038 0 2
12719: ST_TO_ADDR
// if not un then
12720: LD_VAR 0 3
12724: NOT
12725: IFFALSE 12737
// SayRand ( sex_female , D8-FSol1-1 ) ;
12727: LD_INT 2
12729: PPUSH
12730: LD_STRING D8-FSol1-1
12732: PPUSH
12733: CALL 16038 0 2
// Say ( JMM , D8-JMM-1 ) ;
12737: LD_EXP 21
12741: PPUSH
12742: LD_STRING D8-JMM-1
12744: PPUSH
12745: CALL_OW 88
// DialogueOff ;
12749: CALL_OW 7
// break ;
12753: GO 12757
// end ; end ;
12755: GO 12637
12757: POP
12758: POP
// end ; if not seen [ 4 ] then
12759: LD_EXP 9
12763: PUSH
12764: LD_INT 4
12766: ARRAY
12767: NOT
12768: IFFALSE 12930
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12770: LD_ADDR_VAR 0 2
12774: PUSH
12775: LD_INT 22
12777: PUSH
12778: LD_INT 2
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 33
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: ST_TO_ADDR
// if tmp then
12804: LD_VAR 0 2
12808: IFFALSE 12930
// for i in tmp do
12810: LD_ADDR_VAR 0 1
12814: PUSH
12815: LD_VAR 0 2
12819: PUSH
12820: FOR_IN
12821: IFFALSE 12928
// if See ( 1 , i ) then
12823: LD_INT 1
12825: PPUSH
12826: LD_VAR 0 1
12830: PPUSH
12831: CALL_OW 292
12835: IFFALSE 12926
// begin seen := Replace ( seen , 4 , true ) ;
12837: LD_ADDR_EXP 9
12841: PUSH
12842: LD_EXP 9
12846: PPUSH
12847: LD_INT 4
12849: PPUSH
12850: LD_INT 1
12852: PPUSH
12853: CALL_OW 1
12857: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12858: LD_INT 1
12860: PPUSH
12861: CALL 15860 0 1
12865: IFFALSE 12926
// begin DialogueOn ;
12867: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12871: LD_VAR 0 1
12875: PPUSH
12876: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12880: LD_INT 10
12882: PPUSH
12883: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12887: LD_ADDR_VAR 0 3
12891: PUSH
12892: LD_INT 1
12894: PPUSH
12895: LD_STRING D5a-Sol1-1
12897: PPUSH
12898: CALL 16038 0 2
12902: ST_TO_ADDR
// if not un then
12903: LD_VAR 0 3
12907: NOT
12908: IFFALSE 12920
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12910: LD_INT 2
12912: PPUSH
12913: LD_STRING D5a-FSol1-1
12915: PPUSH
12916: CALL 16038 0 2
// DialogueOff ;
12920: CALL_OW 7
// break ;
12924: GO 12928
// end ; end ;
12926: GO 12820
12928: POP
12929: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12930: LD_EXP 9
12934: PUSH
12935: LD_INT 5
12937: ARRAY
12938: NOT
12939: PUSH
12940: LD_EXP 9
12944: PUSH
12945: LD_INT 3
12947: ARRAY
12948: AND
12949: IFFALSE 13123
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12951: LD_ADDR_VAR 0 2
12955: PUSH
12956: LD_INT 22
12958: PUSH
12959: LD_INT 2
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 34
12968: PUSH
12969: LD_INT 31
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PPUSH
12980: CALL_OW 69
12984: ST_TO_ADDR
// if tmp then
12985: LD_VAR 0 2
12989: IFFALSE 13123
// for i in tmp do
12991: LD_ADDR_VAR 0 1
12995: PUSH
12996: LD_VAR 0 2
13000: PUSH
13001: FOR_IN
13002: IFFALSE 13121
// if See ( 1 , i ) then
13004: LD_INT 1
13006: PPUSH
13007: LD_VAR 0 1
13011: PPUSH
13012: CALL_OW 292
13016: IFFALSE 13119
// begin seen := Replace ( seen , 5 , true ) ;
13018: LD_ADDR_EXP 9
13022: PUSH
13023: LD_EXP 9
13027: PPUSH
13028: LD_INT 5
13030: PPUSH
13031: LD_INT 1
13033: PPUSH
13034: CALL_OW 1
13038: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13039: LD_INT 1
13041: PPUSH
13042: CALL 15860 0 1
13046: IFFALSE 13119
// begin DialogueOn ;
13048: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13052: LD_VAR 0 1
13056: PPUSH
13057: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13061: LD_INT 10
13063: PPUSH
13064: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13068: LD_ADDR_VAR 0 3
13072: PUSH
13073: LD_INT 1
13075: PPUSH
13076: LD_STRING D8a-Sol2-1
13078: PPUSH
13079: CALL 16038 0 2
13083: ST_TO_ADDR
// if not un then
13084: LD_VAR 0 3
13088: NOT
13089: IFFALSE 13101
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13091: LD_INT 2
13093: PPUSH
13094: LD_STRING D8a-FSol2-1
13096: PPUSH
13097: CALL 16038 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13101: LD_EXP 21
13105: PPUSH
13106: LD_STRING D8a-JMM-1
13108: PPUSH
13109: CALL_OW 88
// DialogueOff ;
13113: CALL_OW 7
// break ;
13117: GO 13121
// end ; end ;
13119: GO 13001
13121: POP
13122: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13123: LD_EXP 9
13127: PUSH
13128: LD_INT 1
13130: ARRAY
13131: PUSH
13132: LD_EXP 9
13136: PUSH
13137: LD_INT 2
13139: ARRAY
13140: AND
13141: PUSH
13142: LD_EXP 9
13146: PUSH
13147: LD_INT 3
13149: ARRAY
13150: AND
13151: PUSH
13152: LD_EXP 9
13156: PUSH
13157: LD_INT 4
13159: ARRAY
13160: AND
13161: PUSH
13162: LD_EXP 9
13166: PUSH
13167: LD_INT 5
13169: ARRAY
13170: AND
13171: IFFALSE 13174
// disable ;
13173: DISABLE
// end ;
13174: PPOPN 4
13176: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13177: LD_EXP 10
13181: PUSH
13182: LD_EXP 11
13186: AND
13187: IFFALSE 13385
13189: GO 13191
13191: DISABLE
13192: LD_INT 0
13194: PPUSH
// begin DialogueOn ;
13195: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13199: LD_EXP 11
13203: PPUSH
13204: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13208: LD_ADDR_VAR 0 1
13212: PUSH
13213: LD_INT 1
13215: PPUSH
13216: LD_STRING D5c-Sol1-1
13218: PPUSH
13219: CALL 16038 0 2
13223: ST_TO_ADDR
// if not un then
13224: LD_VAR 0 1
13228: NOT
13229: IFFALSE 13247
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13231: LD_ADDR_VAR 0 1
13235: PUSH
13236: LD_INT 2
13238: PPUSH
13239: LD_STRING D5c-FSol1-1
13241: PPUSH
13242: CALL 16038 0 2
13246: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13247: LD_EXP 21
13251: PPUSH
13252: LD_STRING D5c-JMM-1
13254: PPUSH
13255: CALL_OW 88
// if IsOk ( Lisa ) then
13259: LD_EXP 22
13263: PPUSH
13264: CALL_OW 302
13268: IFFALSE 13284
// Say ( Lisa , D5d-Lisa-1 ) else
13270: LD_EXP 22
13274: PPUSH
13275: LD_STRING D5d-Lisa-1
13277: PPUSH
13278: CALL_OW 88
13282: GO 13369
// if IsOk ( Cyrus ) then
13284: LD_EXP 25
13288: PPUSH
13289: CALL_OW 302
13293: IFFALSE 13309
// Say ( Cyrus , D5d-Cyrus-1 ) else
13295: LD_EXP 25
13299: PPUSH
13300: LD_STRING D5d-Cyrus-1
13302: PPUSH
13303: CALL_OW 88
13307: GO 13369
// if IsOk ( Gary ) then
13309: LD_EXP 32
13313: PPUSH
13314: CALL_OW 302
13318: IFFALSE 13334
// Say ( Gary , D5d-Gary-1 ) else
13320: LD_EXP 32
13324: PPUSH
13325: LD_STRING D5d-Gary-1
13327: PPUSH
13328: CALL_OW 88
13332: GO 13369
// if GetSex ( un ) = sex_male then
13334: LD_VAR 0 1
13338: PPUSH
13339: CALL_OW 258
13343: PUSH
13344: LD_INT 1
13346: EQUAL
13347: IFFALSE 13363
// Say ( un , D5d-Sol1-1 ) else
13349: LD_VAR 0 1
13353: PPUSH
13354: LD_STRING D5d-Sol1-1
13356: PPUSH
13357: CALL_OW 88
13361: GO 13369
// begin DialogueOff ;
13363: CALL_OW 7
// exit ;
13367: GO 13385
// end ; Say ( JMM , D5d-JMM-1 ) ;
13369: LD_EXP 21
13373: PPUSH
13374: LD_STRING D5d-JMM-1
13376: PPUSH
13377: CALL_OW 88
// DialogueOff ;
13381: CALL_OW 7
// end ;
13385: PPOPN 1
13387: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13388: LD_INT 1
13390: PPUSH
13391: LD_INT 17
13393: PPUSH
13394: CALL_OW 294
13398: PUSH
13399: LD_INT 2
13401: GREATEREQUAL
13402: IFFALSE 13523
13404: GO 13406
13406: DISABLE
13407: LD_INT 0
13409: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13410: LD_INT 10
13412: PPUSH
13413: LD_INT 5
13415: PPUSH
13416: LD_INT 1
13418: PPUSH
13419: LD_INT 10
13421: NEG
13422: PPUSH
13423: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13427: LD_INT 10
13429: PPUSH
13430: LD_INT 5
13432: PPUSH
13433: LD_INT 1
13435: PPUSH
13436: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13440: LD_INT 10
13442: PPUSH
13443: LD_INT 5
13445: PPUSH
13446: CALL_OW 86
// DialogueOn ;
13450: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13454: LD_ADDR_VAR 0 1
13458: PUSH
13459: LD_INT 1
13461: PPUSH
13462: LD_STRING D6-Sci1-1
13464: PPUSH
13465: CALL 16038 0 2
13469: ST_TO_ADDR
// if un then
13470: LD_VAR 0 1
13474: IFFALSE 13512
// begin Say ( JMM , D6-JMM-1 ) ;
13476: LD_EXP 21
13480: PPUSH
13481: LD_STRING D6-JMM-1
13483: PPUSH
13484: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13488: LD_VAR 0 1
13492: PPUSH
13493: LD_STRING D6-Sci1-2
13495: PPUSH
13496: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13500: LD_EXP 21
13504: PPUSH
13505: LD_STRING D6-JMM-2
13507: PPUSH
13508: CALL_OW 88
// end ; DialogueOff ;
13512: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13516: LD_STRING M3
13518: PPUSH
13519: CALL_OW 337
// end ;
13523: PPOPN 1
13525: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13526: LD_OWVAR 1
13530: PUSH
13531: LD_INT 42000
13533: GREATEREQUAL
13534: PUSH
13535: LD_INT 2
13537: PPUSH
13538: LD_INT 169
13540: PPUSH
13541: LD_INT 90
13543: PPUSH
13544: LD_INT 10
13546: PPUSH
13547: CALL 55395 0 4
13551: PUSH
13552: LD_INT 4
13554: ARRAY
13555: PUSH
13556: LD_INT 0
13558: EQUAL
13559: PUSH
13560: LD_INT 45
13562: PPUSH
13563: CALL_OW 301
13567: OR
13568: PUSH
13569: LD_INT 45
13571: PPUSH
13572: CALL_OW 255
13576: PUSH
13577: LD_INT 1
13579: EQUAL
13580: OR
13581: AND
13582: PUSH
13583: LD_INT 94
13585: PPUSH
13586: CALL_OW 301
13590: NOT
13591: AND
13592: IFFALSE 14797
13594: GO 13596
13596: DISABLE
13597: LD_INT 0
13599: PPUSH
13600: PPUSH
13601: PPUSH
13602: PPUSH
13603: PPUSH
// begin uc_side := 5 ;
13604: LD_ADDR_OWVAR 20
13608: PUSH
13609: LD_INT 5
13611: ST_TO_ADDR
// uc_nation := 2 ;
13612: LD_ADDR_OWVAR 21
13616: PUSH
13617: LD_INT 2
13619: ST_TO_ADDR
// InitHc ;
13620: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13624: LD_INT 1
13626: PPUSH
13627: LD_INT 3
13629: PPUSH
13630: LD_INT 8
13632: PPUSH
13633: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13637: LD_ADDR_OWVAR 29
13641: PUSH
13642: LD_INT 12
13644: PUSH
13645: LD_INT 12
13647: PUSH
13648: EMPTY
13649: LIST
13650: LIST
13651: ST_TO_ADDR
// hc_name := Hans Felige ;
13652: LD_ADDR_OWVAR 26
13656: PUSH
13657: LD_STRING Hans Felige
13659: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13660: LD_ADDR_OWVAR 33
13664: PUSH
13665: LD_STRING SecondCharsGal
13667: ST_TO_ADDR
// hc_face_number := 7 ;
13668: LD_ADDR_OWVAR 34
13672: PUSH
13673: LD_INT 7
13675: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13676: LD_ADDR_EXP 46
13680: PUSH
13681: CALL_OW 44
13685: ST_TO_ADDR
// InitHc ;
13686: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13690: LD_INT 1
13692: PPUSH
13693: LD_INT 16
13695: PPUSH
13696: LD_INT 2
13698: PPUSH
13699: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13703: LD_ADDR_OWVAR 29
13707: PUSH
13708: LD_INT 12
13710: PUSH
13711: LD_INT 12
13713: PUSH
13714: EMPTY
13715: LIST
13716: LIST
13717: ST_TO_ADDR
// hc_name :=  ;
13718: LD_ADDR_OWVAR 26
13722: PUSH
13723: LD_STRING 
13725: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13726: LD_ADDR_EXP 47
13730: PUSH
13731: CALL_OW 44
13735: ST_TO_ADDR
// InitHc ;
13736: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13740: LD_INT 35
13742: PPUSH
13743: CALL_OW 67
// until not InBattle ( 1 ) ;
13747: LD_INT 1
13749: PPUSH
13750: CALL_OW 463
13754: NOT
13755: IFFALSE 13740
// wait ( 0 0$5 ) ;
13757: LD_INT 175
13759: PPUSH
13760: CALL_OW 67
// DialogueOn ;
13764: CALL_OW 6
// InGameOn ;
13768: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13772: LD_ADDR_VAR 0 1
13776: PUSH
13777: LD_INT 22
13779: PUSH
13780: LD_INT 1
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: PUSH
13787: LD_INT 2
13789: PUSH
13790: LD_INT 25
13792: PUSH
13793: LD_INT 1
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 25
13802: PUSH
13803: LD_INT 2
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PUSH
13810: LD_INT 25
13812: PUSH
13813: LD_INT 3
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 25
13822: PUSH
13823: LD_INT 4
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 25
13832: PUSH
13833: LD_INT 5
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: PUSH
13840: LD_INT 25
13842: PUSH
13843: LD_INT 8
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: PUSH
13850: EMPTY
13851: LIST
13852: LIST
13853: LIST
13854: LIST
13855: LIST
13856: LIST
13857: LIST
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: PPUSH
13863: CALL_OW 69
13867: PUSH
13868: LD_EXP 21
13872: PUSH
13873: LD_EXP 22
13877: PUSH
13878: LD_EXP 23
13882: PUSH
13883: LD_EXP 24
13887: PUSH
13888: LD_EXP 25
13892: PUSH
13893: LD_EXP 26
13897: PUSH
13898: LD_EXP 27
13902: PUSH
13903: LD_EXP 28
13907: PUSH
13908: LD_EXP 29
13912: PUSH
13913: LD_EXP 31
13917: PUSH
13918: LD_EXP 32
13922: PUSH
13923: LD_EXP 33
13927: PUSH
13928: LD_EXP 34
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: DIFF
13948: PPUSH
13949: LD_INT 26
13951: PUSH
13952: LD_INT 1
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 72
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: ST_TO_ADDR
// if Brown then
13968: LD_EXP 27
13972: IFFALSE 13984
// un := Brown ;
13974: LD_ADDR_VAR 0 1
13978: PUSH
13979: LD_EXP 27
13983: ST_TO_ADDR
// if un then
13984: LD_VAR 0 1
13988: IFFALSE 14014
// begin Say ( un , D7-Sol1-1 ) ;
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_STRING D7-Sol1-1
13997: PPUSH
13998: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14002: LD_EXP 21
14006: PPUSH
14007: LD_STRING D7-JMM-1
14009: PPUSH
14010: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14014: LD_EXP 46
14018: PPUSH
14019: LD_STRING D7-Ar1-1
14021: PPUSH
14022: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14026: LD_EXP 21
14030: PPUSH
14031: LD_STRING D7-JMM-2
14033: PPUSH
14034: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14038: LD_EXP 46
14042: PPUSH
14043: LD_STRING D7-Ar1-2
14045: PPUSH
14046: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14050: LD_EXP 21
14054: PPUSH
14055: LD_STRING D7-JMM-3
14057: PPUSH
14058: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14062: LD_EXP 46
14066: PPUSH
14067: LD_STRING D7-Ar1-3
14069: PPUSH
14070: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14074: LD_EXP 21
14078: PPUSH
14079: LD_STRING D7-JMM-4
14081: PPUSH
14082: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14086: LD_EXP 46
14090: PPUSH
14091: LD_STRING D7-Ar1-4
14093: PPUSH
14094: CALL_OW 94
// InGameOff ;
14098: CALL_OW 9
// DialogueOff ;
14102: CALL_OW 7
// case Query ( QCameras ) of 1 :
14106: LD_STRING QCameras
14108: PPUSH
14109: CALL_OW 97
14113: PUSH
14114: LD_INT 1
14116: DOUBLE
14117: EQUAL
14118: IFTRUE 14122
14120: GO 14125
14122: POP
// ; 2 :
14123: GO 14139
14125: LD_INT 2
14127: DOUBLE
14128: EQUAL
14129: IFTRUE 14133
14131: GO 14138
14133: POP
// exit ; end ;
14134: GO 14797
14136: GO 14139
14138: POP
// ChangeMissionObjectives ( MCar ) ;
14139: LD_STRING MCar
14141: PPUSH
14142: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14146: LD_INT 124
14148: PPUSH
14149: LD_INT 90
14151: PPUSH
14152: LD_INT 1
14154: PPUSH
14155: LD_INT 6
14157: NEG
14158: PPUSH
14159: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14163: LD_INT 124
14165: PPUSH
14166: LD_INT 90
14168: PPUSH
14169: LD_INT 1
14171: PPUSH
14172: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14176: LD_INT 12
14178: PPUSH
14179: LD_INT 1
14181: PPUSH
14182: CALL_OW 424
// wait ( 3 ) ;
14186: LD_INT 3
14188: PPUSH
14189: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14193: LD_INT 124
14195: PPUSH
14196: LD_INT 90
14198: PPUSH
14199: CALL_OW 86
// cargo := false ;
14203: LD_ADDR_VAR 0 3
14207: PUSH
14208: LD_INT 0
14210: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14211: LD_INT 35
14213: PPUSH
14214: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14218: LD_ADDR_VAR 0 3
14222: PUSH
14223: LD_INT 12
14225: PPUSH
14226: LD_INT 32
14228: PUSH
14229: LD_INT 3
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: LD_INT 34
14238: PUSH
14239: LD_INT 32
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: PUSH
14246: LD_INT 58
14248: PUSH
14249: EMPTY
14250: LIST
14251: PUSH
14252: EMPTY
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL_OW 70
14261: ST_TO_ADDR
// until cargo ;
14262: LD_VAR 0 3
14266: IFFALSE 14211
// cargo := cargo [ 1 ] ;
14268: LD_ADDR_VAR 0 3
14272: PUSH
14273: LD_VAR 0 3
14277: PUSH
14278: LD_INT 1
14280: ARRAY
14281: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14282: LD_VAR 0 3
14286: PPUSH
14287: LD_INT 5
14289: PPUSH
14290: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14294: LD_INT 12
14296: PPUSH
14297: LD_INT 0
14299: PPUSH
14300: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14304: LD_EXP 46
14308: PPUSH
14309: LD_INT 11
14311: PPUSH
14312: LD_INT 0
14314: PPUSH
14315: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14319: LD_EXP 47
14323: PPUSH
14324: LD_INT 11
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14334: LD_EXP 46
14338: PUSH
14339: LD_EXP 47
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PPUSH
14348: LD_INT 12
14350: PPUSH
14351: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14355: LD_EXP 46
14359: PPUSH
14360: LD_VAR 0 3
14364: PPUSH
14365: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14369: LD_EXP 46
14373: PUSH
14374: LD_EXP 47
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PPUSH
14383: LD_INT 209
14385: PPUSH
14386: LD_INT 178
14388: PPUSH
14389: CALL_OW 171
// escaped := 0 ;
14393: LD_ADDR_VAR 0 5
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// while ( true ) do
14401: LD_INT 1
14403: IFFALSE 14619
// begin wait ( 0 0$1 ) ;
14405: LD_INT 35
14407: PPUSH
14408: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14412: LD_EXP 46
14416: PPUSH
14417: CALL_OW 314
14421: NOT
14422: PUSH
14423: LD_EXP 47
14427: PPUSH
14428: CALL_OW 314
14432: NOT
14433: OR
14434: IFFALSE 14460
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14436: LD_EXP 46
14440: PUSH
14441: LD_EXP 47
14445: PUSH
14446: EMPTY
14447: LIST
14448: LIST
14449: PPUSH
14450: LD_INT 209
14452: PPUSH
14453: LD_INT 178
14455: PPUSH
14456: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14460: LD_EXP 46
14464: PPUSH
14465: LD_INT 10
14467: PPUSH
14468: CALL_OW 308
14472: IFFALSE 14497
// begin RemoveUnit ( ar_mechanic ) ;
14474: LD_EXP 46
14478: PPUSH
14479: CALL_OW 64
// escaped := escaped + 1 ;
14483: LD_ADDR_VAR 0 5
14487: PUSH
14488: LD_VAR 0 5
14492: PUSH
14493: LD_INT 1
14495: PLUS
14496: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14497: LD_EXP 47
14501: PPUSH
14502: LD_INT 10
14504: PPUSH
14505: CALL_OW 308
14509: IFFALSE 14534
// begin RemoveUnit ( ar_mechanic_friend ) ;
14511: LD_EXP 47
14515: PPUSH
14516: CALL_OW 64
// escaped := escaped + 1 ;
14520: LD_ADDR_VAR 0 5
14524: PUSH
14525: LD_VAR 0 5
14529: PUSH
14530: LD_INT 1
14532: PLUS
14533: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14534: LD_VAR 0 3
14538: PPUSH
14539: LD_INT 10
14541: PPUSH
14542: CALL_OW 308
14546: IFFALSE 14557
// RemoveUnit ( cargo ) ;
14548: LD_VAR 0 3
14552: PPUSH
14553: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14557: LD_EXP 46
14561: PPUSH
14562: CALL_OW 305
14566: NOT
14567: PUSH
14568: LD_VAR 0 5
14572: PUSH
14573: LD_INT 2
14575: GREATEREQUAL
14576: AND
14577: IFFALSE 14581
// break ;
14579: GO 14619
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14581: LD_EXP 46
14585: PPUSH
14586: CALL_OW 305
14590: NOT
14591: PUSH
14592: LD_EXP 47
14596: PPUSH
14597: CALL_OW 305
14601: NOT
14602: AND
14603: PUSH
14604: LD_VAR 0 5
14608: PUSH
14609: LD_INT 2
14611: LESS
14612: AND
14613: IFFALSE 14617
// exit ;
14615: GO 14797
// end ;
14617: GO 14401
// wait ( 0 0$2 ) ;
14619: LD_INT 70
14621: PPUSH
14622: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14626: LD_EXP 46
14630: PPUSH
14631: LD_STRING D7a-Ar1-1
14633: PPUSH
14634: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14638: LD_ADDR_VAR 0 4
14642: PUSH
14643: LD_INT 129
14645: PUSH
14646: LD_INT 10
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: PUSH
14653: LD_INT 103
14655: PUSH
14656: LD_INT 6
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 148
14665: PUSH
14666: LD_INT 47
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 155
14675: PUSH
14676: LD_INT 16
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: ST_TO_ADDR
// if Difficulty = 1 then
14689: LD_OWVAR 67
14693: PUSH
14694: LD_INT 1
14696: EQUAL
14697: IFFALSE 14734
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14699: LD_ADDR_VAR 0 4
14703: PUSH
14704: LD_VAR 0 4
14708: PUSH
14709: LD_INT 78
14711: PUSH
14712: LD_INT 7
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: LD_INT 104
14721: PUSH
14722: LD_INT 43
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: ADD
14733: ST_TO_ADDR
// for i in tmp do
14734: LD_ADDR_VAR 0 2
14738: PUSH
14739: LD_VAR 0 4
14743: PUSH
14744: FOR_IN
14745: IFFALSE 14778
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14747: LD_VAR 0 2
14751: PUSH
14752: LD_INT 1
14754: ARRAY
14755: PPUSH
14756: LD_VAR 0 2
14760: PUSH
14761: LD_INT 2
14763: ARRAY
14764: PPUSH
14765: LD_INT 1
14767: PPUSH
14768: LD_INT 9
14770: NEG
14771: PPUSH
14772: CALL_OW 330
14776: GO 14744
14778: POP
14779: POP
// SetAchievement ( ACH_FRIEND ) ;
14780: LD_STRING ACH_FRIEND
14782: PPUSH
14783: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14787: LD_INT 129
14789: PPUSH
14790: LD_INT 10
14792: PPUSH
14793: CALL_OW 84
// end ;
14797: PPOPN 5
14799: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14800: LD_EXP 15
14804: PUSH
14805: LD_INT 21000
14807: MINUS
14808: PUSH
14809: LD_OWVAR 1
14813: LESSEQUAL
14814: IFFALSE 14854
14816: GO 14818
14818: DISABLE
// begin powell_warn := true ;
14819: LD_ADDR_EXP 16
14823: PUSH
14824: LD_INT 1
14826: ST_TO_ADDR
// DialogueOn ;
14827: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14831: LD_EXP 30
14835: PPUSH
14836: LD_STRING D9-Pow-1
14838: PPUSH
14839: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14843: LD_INT 10
14845: PPUSH
14846: CALL_OW 68
// DialogueOff ;
14850: CALL_OW 7
// end ;
14854: END
// every 0 0$1 trigger game_time <= tick do
14855: LD_EXP 15
14859: PUSH
14860: LD_OWVAR 1
14864: LESSEQUAL
14865: IFFALSE 14904
14867: GO 14869
14869: DISABLE
// begin DialogueOn ;
14870: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14874: LD_EXP 30
14878: PPUSH
14879: LD_STRING D9a-Pow-1
14881: PPUSH
14882: CALL_OW 94
// dwait ( 0 0$2 ) ;
14886: LD_INT 70
14888: PPUSH
14889: CALL_OW 68
// DialogueOff ;
14893: CALL_OW 7
// YouLost ( Command ) ;
14897: LD_STRING Command
14899: PPUSH
14900: CALL_OW 104
// end ;
14904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14905: LD_INT 22
14907: PUSH
14908: LD_INT 2
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: PUSH
14915: LD_INT 30
14917: PUSH
14918: LD_INT 1
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PPUSH
14929: CALL_OW 69
14933: PUSH
14934: LD_INT 0
14936: EQUAL
14937: PUSH
14938: LD_EXP 21
14942: PPUSH
14943: CALL_OW 302
14947: AND
14948: IFFALSE 15857
14950: GO 14952
14952: DISABLE
14953: LD_INT 0
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
// begin m1 := false ;
14959: LD_ADDR_VAR 0 2
14963: PUSH
14964: LD_INT 0
14966: ST_TO_ADDR
// m2 := false ;
14967: LD_ADDR_VAR 0 3
14971: PUSH
14972: LD_INT 0
14974: ST_TO_ADDR
// m3 := false ;
14975: LD_ADDR_VAR 0 4
14979: PUSH
14980: LD_INT 0
14982: ST_TO_ADDR
// if not am_veh_consturcted then
14983: LD_EXP 20
14987: NOT
14988: IFFALSE 14997
// SetAchievement ( ACH_ARABTECH ) ;
14990: LD_STRING ACH_ARABTECH
14992: PPUSH
14993: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
14997: LD_OWVAR 1
15001: PUSH
15002: LD_INT 252000
15004: PUSH
15005: LD_INT 210000
15007: PUSH
15008: LD_INT 199500
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: PUSH
15016: LD_OWVAR 67
15020: ARRAY
15021: LESS
15022: IFFALSE 15044
// begin m3 := true ;
15024: LD_ADDR_VAR 0 4
15028: PUSH
15029: LD_INT 1
15031: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15032: LD_STRING Time1
15034: PPUSH
15035: LD_INT 1
15037: PPUSH
15038: CALL_OW 101
// end else
15042: GO 15075
// if not powell_warn then
15044: LD_EXP 16
15048: NOT
15049: IFFALSE 15064
// AddMedal ( Time1 , - 1 ) else
15051: LD_STRING Time1
15053: PPUSH
15054: LD_INT 1
15056: NEG
15057: PPUSH
15058: CALL_OW 101
15062: GO 15075
// AddMedal ( Time1 , - 2 ) ;
15064: LD_STRING Time1
15066: PPUSH
15067: LD_INT 2
15069: NEG
15070: PPUSH
15071: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15075: LD_EXP 17
15079: PUSH
15080: LD_INT 5
15082: PUSH
15083: LD_INT 4
15085: PUSH
15086: LD_INT 3
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: LIST
15093: PUSH
15094: LD_OWVAR 67
15098: ARRAY
15099: GREATEREQUAL
15100: IFFALSE 15115
// AddMedal ( Destroy , - 2 ) else
15102: LD_STRING Destroy
15104: PPUSH
15105: LD_INT 2
15107: NEG
15108: PPUSH
15109: CALL_OW 101
15113: GO 15248
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15115: LD_INT 22
15117: PUSH
15118: LD_INT 2
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: PUSH
15125: LD_INT 21
15127: PUSH
15128: LD_INT 3
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 50
15137: PUSH
15138: EMPTY
15139: LIST
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: LIST
15145: PPUSH
15146: CALL_OW 69
15150: PUSH
15151: LD_INT 25
15153: GREATEREQUAL
15154: IFFALSE 15169
// AddMedal ( Destroy , - 1 ) else
15156: LD_STRING Destroy
15158: PPUSH
15159: LD_INT 1
15161: NEG
15162: PPUSH
15163: CALL_OW 101
15167: GO 15248
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15169: LD_INT 22
15171: PUSH
15172: LD_INT 2
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: PUSH
15179: LD_INT 21
15181: PUSH
15182: LD_INT 3
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: PUSH
15189: LD_INT 50
15191: PUSH
15192: EMPTY
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 15
15207: GREATEREQUAL
15208: IFFALSE 15230
// begin m1 := true ;
15210: LD_ADDR_VAR 0 2
15214: PUSH
15215: LD_INT 1
15217: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15218: LD_STRING Destroy
15220: PPUSH
15221: LD_INT 1
15223: PPUSH
15224: CALL_OW 101
// end else
15228: GO 15248
// begin m1 := true ;
15230: LD_ADDR_VAR 0 2
15234: PUSH
15235: LD_INT 1
15237: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15238: LD_STRING Destroy
15240: PPUSH
15241: LD_INT 2
15243: PPUSH
15244: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15248: LD_EXP 13
15252: PPUSH
15253: LD_STRING 11_artifact_captured
15255: PPUSH
15256: CALL_OW 39
// if artifact_get then
15260: LD_EXP 13
15264: IFFALSE 15286
// begin m2 := true ;
15266: LD_ADDR_VAR 0 3
15270: PUSH
15271: LD_INT 1
15273: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15274: LD_STRING Artefact
15276: PPUSH
15277: LD_INT 1
15279: PPUSH
15280: CALL_OW 101
// end else
15284: GO 15297
// AddMedal ( Artefact , - 1 ) ;
15286: LD_STRING Artefact
15288: PPUSH
15289: LD_INT 1
15291: NEG
15292: PPUSH
15293: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15297: LD_VAR 0 2
15301: PUSH
15302: LD_VAR 0 3
15306: AND
15307: PUSH
15308: LD_VAR 0 4
15312: AND
15313: PUSH
15314: LD_OWVAR 67
15318: PUSH
15319: LD_INT 3
15321: EQUAL
15322: AND
15323: IFFALSE 15335
// SetAchievementEX ( ACH_AMER , 11 ) ;
15325: LD_STRING ACH_AMER
15327: PPUSH
15328: LD_INT 11
15330: PPUSH
15331: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15335: LD_VAR 0 2
15339: PUSH
15340: LD_VAR 0 3
15344: AND
15345: PUSH
15346: LD_VAR 0 4
15350: AND
15351: PUSH
15352: LD_EXP 17
15356: PUSH
15357: LD_INT 0
15359: EQUAL
15360: AND
15361: IFFALSE 15377
// begin wait ( 3 ) ;
15363: LD_INT 3
15365: PPUSH
15366: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15370: LD_STRING ACH_GENERAL
15372: PPUSH
15373: CALL_OW 543
// end ; if tick <= 100 100$00 then
15377: LD_OWVAR 1
15381: PUSH
15382: LD_INT 210000
15384: LESSEQUAL
15385: IFFALSE 15401
// begin wait ( 3 ) ;
15387: LD_INT 3
15389: PPUSH
15390: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15394: LD_STRING ACH_ASPEED_11
15396: PPUSH
15397: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15401: LD_STRING MAIN
15403: PPUSH
15404: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15408: LD_ADDR_EXP 19
15412: PUSH
15413: LD_EXP 19
15417: PPUSH
15418: LD_INT 51
15420: PUSH
15421: EMPTY
15422: LIST
15423: PPUSH
15424: CALL_OW 72
15428: ST_TO_ADDR
// tmp := JMM ^ selected ;
15429: LD_ADDR_VAR 0 1
15433: PUSH
15434: LD_EXP 21
15438: PUSH
15439: LD_EXP 19
15443: ADD
15444: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15445: LD_VAR 0 1
15449: PPUSH
15450: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15454: LD_VAR 0 1
15458: PUSH
15459: LD_EXP 21
15463: PUSH
15464: LD_EXP 22
15468: PUSH
15469: LD_EXP 23
15473: PUSH
15474: LD_EXP 24
15478: PUSH
15479: LD_EXP 25
15483: PUSH
15484: LD_EXP 26
15488: PUSH
15489: LD_EXP 27
15493: PUSH
15494: LD_EXP 28
15498: PUSH
15499: LD_EXP 29
15503: PUSH
15504: LD_EXP 31
15508: PUSH
15509: LD_EXP 32
15513: PUSH
15514: LD_EXP 33
15518: PUSH
15519: LD_EXP 34
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: DIFF
15539: PPUSH
15540: LD_STRING 11c_others
15542: PPUSH
15543: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15547: LD_EXP 21
15551: PPUSH
15552: LD_EXP 3
15556: PUSH
15557: LD_STRING JMM
15559: STR
15560: PPUSH
15561: CALL_OW 38
// if Lisa then
15565: LD_EXP 22
15569: IFFALSE 15589
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15571: LD_EXP 22
15575: PPUSH
15576: LD_EXP 3
15580: PUSH
15581: LD_STRING Lisa
15583: STR
15584: PPUSH
15585: CALL_OW 38
// if Donaldson then
15589: LD_EXP 23
15593: IFFALSE 15613
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15595: LD_EXP 23
15599: PPUSH
15600: LD_EXP 3
15604: PUSH
15605: LD_STRING Donaldson
15607: STR
15608: PPUSH
15609: CALL_OW 38
// if Bobby then
15613: LD_EXP 24
15617: IFFALSE 15637
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15619: LD_EXP 24
15623: PPUSH
15624: LD_EXP 3
15628: PUSH
15629: LD_STRING Bobby
15631: STR
15632: PPUSH
15633: CALL_OW 38
// if Cyrus then
15637: LD_EXP 25
15641: IFFALSE 15661
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15643: LD_EXP 25
15647: PPUSH
15648: LD_EXP 3
15652: PUSH
15653: LD_STRING Cyrus
15655: STR
15656: PPUSH
15657: CALL_OW 38
// if Denis then
15661: LD_EXP 26
15665: IFFALSE 15685
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15667: LD_EXP 26
15671: PPUSH
15672: LD_EXP 3
15676: PUSH
15677: LD_STRING Denis
15679: STR
15680: PPUSH
15681: CALL_OW 38
// if Brown then
15685: LD_EXP 27
15689: IFFALSE 15709
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15691: LD_EXP 27
15695: PPUSH
15696: LD_EXP 3
15700: PUSH
15701: LD_STRING Brown
15703: STR
15704: PPUSH
15705: CALL_OW 38
// if Gladstone then
15709: LD_EXP 28
15713: IFFALSE 15733
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15715: LD_EXP 28
15719: PPUSH
15720: LD_EXP 3
15724: PUSH
15725: LD_STRING Gladstone
15727: STR
15728: PPUSH
15729: CALL_OW 38
// if Houten then
15733: LD_EXP 29
15737: IFFALSE 15757
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15739: LD_EXP 29
15743: PPUSH
15744: LD_EXP 3
15748: PUSH
15749: LD_STRING Houten
15751: STR
15752: PPUSH
15753: CALL_OW 38
// if Cornel then
15757: LD_EXP 31
15761: IFFALSE 15781
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15763: LD_EXP 31
15767: PPUSH
15768: LD_EXP 3
15772: PUSH
15773: LD_STRING Cornell
15775: STR
15776: PPUSH
15777: CALL_OW 38
// if Gary then
15781: LD_EXP 32
15785: IFFALSE 15805
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15787: LD_EXP 32
15791: PPUSH
15792: LD_EXP 3
15796: PUSH
15797: LD_STRING Gary
15799: STR
15800: PPUSH
15801: CALL_OW 38
// if Frank then
15805: LD_EXP 33
15809: IFFALSE 15829
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15811: LD_EXP 33
15815: PPUSH
15816: LD_EXP 3
15820: PUSH
15821: LD_STRING Frank
15823: STR
15824: PPUSH
15825: CALL_OW 38
// if Kikuchi then
15829: LD_EXP 34
15833: IFFALSE 15853
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15835: LD_EXP 34
15839: PPUSH
15840: LD_EXP 3
15844: PUSH
15845: LD_STRING Kikuchi
15847: STR
15848: PPUSH
15849: CALL_OW 38
// YouWin ;
15853: CALL_OW 103
// end ;
15857: PPOPN 4
15859: END
// export function CanSayRand ( side ) ; begin
15860: LD_INT 0
15862: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15863: LD_ADDR_VAR 0 2
15867: PUSH
15868: LD_INT 52
15870: PUSH
15871: EMPTY
15872: LIST
15873: PUSH
15874: LD_INT 22
15876: PUSH
15877: LD_VAR 0 1
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: PUSH
15886: LD_INT 2
15888: PUSH
15889: LD_INT 25
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 25
15901: PUSH
15902: LD_INT 2
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 25
15911: PUSH
15912: LD_INT 3
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: PUSH
15919: LD_INT 25
15921: PUSH
15922: LD_INT 4
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: LIST
15933: LIST
15934: LIST
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: LIST
15940: PPUSH
15941: CALL_OW 69
15945: PUSH
15946: LD_EXP 21
15950: PUSH
15951: LD_EXP 33
15955: PUSH
15956: LD_EXP 22
15960: PUSH
15961: LD_EXP 23
15965: PUSH
15966: LD_EXP 24
15970: PUSH
15971: LD_EXP 25
15975: PUSH
15976: LD_EXP 26
15980: PUSH
15981: LD_EXP 27
15985: PUSH
15986: LD_EXP 28
15990: PUSH
15991: LD_EXP 29
15995: PUSH
15996: LD_EXP 30
16000: PUSH
16001: LD_EXP 31
16005: PUSH
16006: LD_EXP 32
16010: PUSH
16011: LD_EXP 34
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: DIFF
16032: ST_TO_ADDR
// end ;
16033: LD_VAR 0 2
16037: RET
// export function SayRand ( sex , dial ) ; begin
16038: LD_INT 0
16040: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16041: LD_ADDR_VAR 0 3
16045: PUSH
16046: LD_INT 52
16048: PUSH
16049: EMPTY
16050: LIST
16051: PUSH
16052: LD_INT 22
16054: PUSH
16055: LD_INT 1
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: PUSH
16062: LD_INT 26
16064: PUSH
16065: LD_VAR 0 1
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: PUSH
16074: LD_INT 2
16076: PUSH
16077: LD_INT 25
16079: PUSH
16080: LD_INT 1
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: PUSH
16087: LD_INT 25
16089: PUSH
16090: LD_INT 2
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: LD_INT 25
16099: PUSH
16100: LD_INT 3
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: LD_INT 25
16109: PUSH
16110: LD_INT 4
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: LIST
16128: LIST
16129: PPUSH
16130: CALL_OW 69
16134: PUSH
16135: LD_EXP 21
16139: PUSH
16140: LD_EXP 33
16144: PUSH
16145: LD_EXP 22
16149: PUSH
16150: LD_EXP 23
16154: PUSH
16155: LD_EXP 24
16159: PUSH
16160: LD_EXP 25
16164: PUSH
16165: LD_EXP 26
16169: PUSH
16170: LD_EXP 27
16174: PUSH
16175: LD_EXP 28
16179: PUSH
16180: LD_EXP 29
16184: PUSH
16185: LD_EXP 30
16189: PUSH
16190: LD_EXP 31
16194: PUSH
16195: LD_EXP 32
16199: PUSH
16200: LD_EXP 34
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: DIFF
16221: ST_TO_ADDR
// if not result then
16222: LD_VAR 0 3
16226: NOT
16227: IFFALSE 16231
// exit ;
16229: GO 16259
// result := result [ 1 ] ;
16231: LD_ADDR_VAR 0 3
16235: PUSH
16236: LD_VAR 0 3
16240: PUSH
16241: LD_INT 1
16243: ARRAY
16244: ST_TO_ADDR
// Say ( result , dial ) ;
16245: LD_VAR 0 3
16249: PPUSH
16250: LD_VAR 0 2
16254: PPUSH
16255: CALL_OW 88
// end ;
16259: LD_VAR 0 3
16263: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16264: LD_INT 0
16266: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16267: LD_ADDR_VAR 0 4
16271: PUSH
16272: LD_INT 22
16274: PUSH
16275: LD_INT 1
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: PUSH
16282: LD_INT 26
16284: PUSH
16285: LD_VAR 0 1
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: LD_INT 25
16299: PUSH
16300: LD_INT 1
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PUSH
16307: LD_INT 25
16309: PUSH
16310: LD_INT 2
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PUSH
16317: LD_INT 25
16319: PUSH
16320: LD_INT 3
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: LD_INT 25
16329: PUSH
16330: LD_INT 4
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: LIST
16341: LIST
16342: LIST
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: LIST
16348: PPUSH
16349: CALL_OW 69
16353: PUSH
16354: LD_EXP 21
16358: PUSH
16359: LD_EXP 33
16363: PUSH
16364: LD_EXP 22
16368: PUSH
16369: LD_EXP 23
16373: PUSH
16374: LD_EXP 24
16378: PUSH
16379: LD_EXP 25
16383: PUSH
16384: LD_EXP 26
16388: PUSH
16389: LD_EXP 27
16393: PUSH
16394: LD_EXP 28
16398: PUSH
16399: LD_EXP 29
16403: PUSH
16404: LD_EXP 30
16408: PUSH
16409: LD_EXP 31
16413: PUSH
16414: LD_EXP 32
16418: PUSH
16419: LD_EXP 34
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: LIST
16428: LIST
16429: LIST
16430: LIST
16431: LIST
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: PUSH
16440: LD_VAR 0 3
16444: ADD
16445: DIFF
16446: ST_TO_ADDR
// if not result then
16447: LD_VAR 0 4
16451: NOT
16452: IFFALSE 16456
// exit ;
16454: GO 16484
// result := result [ 1 ] ;
16456: LD_ADDR_VAR 0 4
16460: PUSH
16461: LD_VAR 0 4
16465: PUSH
16466: LD_INT 1
16468: ARRAY
16469: ST_TO_ADDR
// Say ( result , dial ) ;
16470: LD_VAR 0 4
16474: PPUSH
16475: LD_VAR 0 2
16479: PPUSH
16480: CALL_OW 88
// end ; end_of_file
16484: LD_VAR 0 4
16488: RET
// export function CustomEvent ( event ) ; begin
16489: LD_INT 0
16491: PPUSH
// end ;
16492: LD_VAR 0 2
16496: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16497: LD_VAR 0 1
16501: PPUSH
16502: CALL_OW 255
16506: PUSH
16507: LD_INT 1
16509: EQUAL
16510: IFFALSE 16520
// artifact_get := true ;
16512: LD_ADDR_EXP 13
16516: PUSH
16517: LD_INT 1
16519: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16520: LD_VAR 0 1
16524: PPUSH
16525: CALL_OW 255
16529: PUSH
16530: LD_INT 2
16532: EQUAL
16533: IFFALSE 16551
// begin artifact_get := false ;
16535: LD_ADDR_EXP 13
16539: PUSH
16540: LD_INT 0
16542: ST_TO_ADDR
// artifact_stolen := true ;
16543: LD_ADDR_EXP 12
16547: PUSH
16548: LD_INT 1
16550: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16551: LD_ADDR_EXP 14
16555: PUSH
16556: LD_INT 1
16558: ST_TO_ADDR
// end ;
16559: PPOPN 2
16561: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16562: LD_ADDR_EXP 14
16566: PUSH
16567: LD_INT 0
16569: ST_TO_ADDR
// end ;
16570: PPOPN 2
16572: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16573: LD_VAR 0 1
16577: PUSH
16578: LD_EXP 21
16582: EQUAL
16583: IFFALSE 16594
// begin YouLost ( JMM ) ;
16585: LD_STRING JMM
16587: PPUSH
16588: CALL_OW 104
// exit ;
16592: GO 16726
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16594: LD_VAR 0 1
16598: PUSH
16599: LD_INT 22
16601: PUSH
16602: LD_INT 1
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: PUSH
16609: LD_INT 21
16611: PUSH
16612: LD_INT 1
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 2
16621: PUSH
16622: LD_INT 25
16624: PUSH
16625: LD_INT 1
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: PUSH
16632: LD_INT 25
16634: PUSH
16635: LD_INT 2
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: PUSH
16642: LD_INT 25
16644: PUSH
16645: LD_INT 3
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: PUSH
16652: LD_INT 25
16654: PUSH
16655: LD_INT 4
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: PUSH
16662: LD_INT 25
16664: PUSH
16665: LD_INT 5
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PUSH
16672: LD_INT 25
16674: PUSH
16675: LD_INT 8
16677: PUSH
16678: EMPTY
16679: LIST
16680: LIST
16681: PUSH
16682: EMPTY
16683: LIST
16684: LIST
16685: LIST
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: LIST
16695: PPUSH
16696: CALL_OW 69
16700: IN
16701: IFFALSE 16717
// loses_counter := loses_counter + 1 ;
16703: LD_ADDR_EXP 17
16707: PUSH
16708: LD_EXP 17
16712: PUSH
16713: LD_INT 1
16715: PLUS
16716: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: CALL 44310 0 1
// end ;
16726: PPOPN 1
16728: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16729: LD_VAR 0 1
16733: PPUSH
16734: LD_VAR 0 2
16738: PPUSH
16739: CALL 46644 0 2
// end ;
16743: PPOPN 2
16745: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16746: LD_VAR 0 1
16750: PPUSH
16751: CALL 45953 0 1
// end ;
16755: PPOPN 1
16757: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16758: LD_VAR 0 1
16762: PPUSH
16763: LD_VAR 0 2
16767: PPUSH
16768: LD_VAR 0 3
16772: PPUSH
16773: LD_VAR 0 4
16777: PPUSH
16778: LD_VAR 0 5
16782: PPUSH
16783: CALL 43626 0 5
// end ;
16787: PPOPN 5
16789: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16790: LD_VAR 0 1
16794: PPUSH
16795: CALL_OW 248
16799: PUSH
16800: LD_INT 1
16802: EQUAL
16803: IFFALSE 16813
// am_veh_consturcted := true ;
16805: LD_ADDR_EXP 20
16809: PUSH
16810: LD_INT 1
16812: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16813: LD_VAR 0 1
16817: PPUSH
16818: LD_VAR 0 2
16822: PPUSH
16823: CALL 43222 0 2
// end ;
16827: PPOPN 2
16829: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16830: LD_VAR 0 1
16834: PPUSH
16835: CALL_OW 247
16839: PUSH
16840: LD_INT 2
16842: EQUAL
16843: IFFALSE 16847
// exit ;
16845: GO 16864
// if not kamikazed then
16847: LD_EXP 11
16851: NOT
16852: IFFALSE 16864
// kamikazed := unit ;
16854: LD_ADDR_EXP 11
16858: PUSH
16859: LD_VAR 0 1
16863: ST_TO_ADDR
// end ;
16864: PPOPN 1
16866: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16867: LD_INT 0
16869: PPUSH
16870: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16871: LD_VAR 0 1
16875: PPUSH
16876: LD_VAR 0 2
16880: PPUSH
16881: LD_VAR 0 3
16885: PPUSH
16886: LD_VAR 0 4
16890: PPUSH
16891: CALL 43060 0 4
// end ;
16895: PPOPN 6
16897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16898: LD_VAR 0 1
16902: PPUSH
16903: LD_VAR 0 2
16907: PPUSH
16908: LD_VAR 0 3
16912: PPUSH
16913: CALL 42835 0 3
// end ;
16917: PPOPN 3
16919: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16920: LD_VAR 0 1
16924: PPUSH
16925: LD_VAR 0 2
16929: PPUSH
16930: CALL 44006 0 2
// end ;
16934: PPOPN 2
16936: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: CALL 42529 0 2
// end ;
16951: PPOPN 2
16953: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16954: LD_VAR 0 1
16958: PPUSH
16959: LD_VAR 0 2
16963: PPUSH
16964: CALL 42720 0 2
// end ;
16968: PPOPN 2
16970: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16971: LD_VAR 0 1
16975: PPUSH
16976: CALL 45712 0 1
// end ;
16980: PPOPN 1
16982: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16983: LD_VAR 0 1
16987: PPUSH
16988: LD_VAR 0 2
16992: PPUSH
16993: CALL 46905 0 2
// end ;
16997: PPOPN 2
16999: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17000: LD_VAR 0 1
17004: PPUSH
17005: LD_VAR 0 2
17009: PPUSH
17010: LD_VAR 0 3
17014: PPUSH
17015: LD_VAR 0 4
17019: PPUSH
17020: CALL 47121 0 4
// end ;
17024: PPOPN 4
17026: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17027: LD_VAR 0 1
17031: PPUSH
17032: CALL 90569 0 1
// end ; end_of_file
17036: PPOPN 1
17038: END
// every 0 0$1 trigger game do
17039: LD_EXP 2
17043: IFFALSE 17073
17045: GO 17047
17047: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17048: LD_INT 7
17050: PUSH
17051: LD_INT 6
17053: PUSH
17054: LD_INT 4
17056: PUSH
17057: LD_INT 6
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: PPUSH
17066: LD_INT 1750
17068: PPUSH
17069: CALL 17074 0 2
17073: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17074: LD_INT 0
17076: PPUSH
17077: PPUSH
17078: PPUSH
// if not areas then
17079: LD_VAR 0 1
17083: NOT
17084: IFFALSE 17088
// exit ;
17086: GO 17218
// repeat wait ( time ) ;
17088: LD_VAR 0 2
17092: PPUSH
17093: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17097: LD_ADDR_VAR 0 5
17101: PUSH
17102: LD_INT 1
17104: PPUSH
17105: LD_INT 90
17107: PPUSH
17108: CALL_OW 12
17112: ST_TO_ADDR
// for i in areas do
17113: LD_ADDR_VAR 0 4
17117: PUSH
17118: LD_VAR 0 1
17122: PUSH
17123: FOR_IN
17124: IFFALSE 17177
// begin if Prob ( p ) then
17126: LD_VAR 0 5
17130: PPUSH
17131: CALL_OW 13
17135: IFFALSE 17175
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17137: LD_INT 1
17139: PPUSH
17140: LD_INT 5
17142: PPUSH
17143: CALL_OW 12
17147: PPUSH
17148: LD_VAR 0 4
17152: PPUSH
17153: LD_INT 1
17155: PPUSH
17156: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17160: LD_INT 385
17162: PPUSH
17163: LD_INT 595
17165: PPUSH
17166: CALL_OW 12
17170: PPUSH
17171: CALL_OW 67
// end ; end ;
17175: GO 17123
17177: POP
17178: POP
// time := time + 0 0$3 ;
17179: LD_ADDR_VAR 0 2
17183: PUSH
17184: LD_VAR 0 2
17188: PUSH
17189: LD_INT 105
17191: PLUS
17192: ST_TO_ADDR
// if time > 7 7$00 then
17193: LD_VAR 0 2
17197: PUSH
17198: LD_INT 14700
17200: GREATER
17201: IFFALSE 17211
// time := 0 0$40 ;
17203: LD_ADDR_VAR 0 2
17207: PUSH
17208: LD_INT 1400
17210: ST_TO_ADDR
// until not game ;
17211: LD_EXP 2
17215: NOT
17216: IFFALSE 17088
// end ; end_of_file
17218: LD_VAR 0 3
17222: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17223: LD_INT 0
17225: PPUSH
17226: PPUSH
// skirmish := false ;
17227: LD_ADDR_EXP 48
17231: PUSH
17232: LD_INT 0
17234: ST_TO_ADDR
// debug_mc := false ;
17235: LD_ADDR_EXP 49
17239: PUSH
17240: LD_INT 0
17242: ST_TO_ADDR
// mc_bases := [ ] ;
17243: LD_ADDR_EXP 50
17247: PUSH
17248: EMPTY
17249: ST_TO_ADDR
// mc_sides := [ ] ;
17250: LD_ADDR_EXP 76
17254: PUSH
17255: EMPTY
17256: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17257: LD_ADDR_EXP 51
17261: PUSH
17262: EMPTY
17263: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17264: LD_ADDR_EXP 52
17268: PUSH
17269: EMPTY
17270: ST_TO_ADDR
// mc_need_heal := [ ] ;
17271: LD_ADDR_EXP 53
17275: PUSH
17276: EMPTY
17277: ST_TO_ADDR
// mc_healers := [ ] ;
17278: LD_ADDR_EXP 54
17282: PUSH
17283: EMPTY
17284: ST_TO_ADDR
// mc_build_list := [ ] ;
17285: LD_ADDR_EXP 55
17289: PUSH
17290: EMPTY
17291: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17292: LD_ADDR_EXP 82
17296: PUSH
17297: EMPTY
17298: ST_TO_ADDR
// mc_builders := [ ] ;
17299: LD_ADDR_EXP 56
17303: PUSH
17304: EMPTY
17305: ST_TO_ADDR
// mc_construct_list := [ ] ;
17306: LD_ADDR_EXP 57
17310: PUSH
17311: EMPTY
17312: ST_TO_ADDR
// mc_turret_list := [ ] ;
17313: LD_ADDR_EXP 58
17317: PUSH
17318: EMPTY
17319: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17320: LD_ADDR_EXP 59
17324: PUSH
17325: EMPTY
17326: ST_TO_ADDR
// mc_miners := [ ] ;
17327: LD_ADDR_EXP 64
17331: PUSH
17332: EMPTY
17333: ST_TO_ADDR
// mc_mines := [ ] ;
17334: LD_ADDR_EXP 63
17338: PUSH
17339: EMPTY
17340: ST_TO_ADDR
// mc_minefields := [ ] ;
17341: LD_ADDR_EXP 65
17345: PUSH
17346: EMPTY
17347: ST_TO_ADDR
// mc_crates := [ ] ;
17348: LD_ADDR_EXP 66
17352: PUSH
17353: EMPTY
17354: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17355: LD_ADDR_EXP 67
17359: PUSH
17360: EMPTY
17361: ST_TO_ADDR
// mc_crates_area := [ ] ;
17362: LD_ADDR_EXP 68
17366: PUSH
17367: EMPTY
17368: ST_TO_ADDR
// mc_vehicles := [ ] ;
17369: LD_ADDR_EXP 69
17373: PUSH
17374: EMPTY
17375: ST_TO_ADDR
// mc_attack := [ ] ;
17376: LD_ADDR_EXP 70
17380: PUSH
17381: EMPTY
17382: ST_TO_ADDR
// mc_produce := [ ] ;
17383: LD_ADDR_EXP 71
17387: PUSH
17388: EMPTY
17389: ST_TO_ADDR
// mc_defender := [ ] ;
17390: LD_ADDR_EXP 72
17394: PUSH
17395: EMPTY
17396: ST_TO_ADDR
// mc_parking := [ ] ;
17397: LD_ADDR_EXP 74
17401: PUSH
17402: EMPTY
17403: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17404: LD_ADDR_EXP 60
17408: PUSH
17409: EMPTY
17410: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17411: LD_ADDR_EXP 62
17415: PUSH
17416: EMPTY
17417: ST_TO_ADDR
// mc_scan := [ ] ;
17418: LD_ADDR_EXP 73
17422: PUSH
17423: EMPTY
17424: ST_TO_ADDR
// mc_scan_area := [ ] ;
17425: LD_ADDR_EXP 75
17429: PUSH
17430: EMPTY
17431: ST_TO_ADDR
// mc_tech := [ ] ;
17432: LD_ADDR_EXP 77
17436: PUSH
17437: EMPTY
17438: ST_TO_ADDR
// mc_class := [ ] ;
17439: LD_ADDR_EXP 91
17443: PUSH
17444: EMPTY
17445: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17446: LD_ADDR_EXP 92
17450: PUSH
17451: EMPTY
17452: ST_TO_ADDR
// end ;
17453: LD_VAR 0 1
17457: RET
// export function MC_Kill ( base ) ; begin
17458: LD_INT 0
17460: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17461: LD_ADDR_EXP 50
17465: PUSH
17466: LD_EXP 50
17470: PPUSH
17471: LD_VAR 0 1
17475: PPUSH
17476: EMPTY
17477: PPUSH
17478: CALL_OW 1
17482: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17483: LD_ADDR_EXP 51
17487: PUSH
17488: LD_EXP 51
17492: PPUSH
17493: LD_VAR 0 1
17497: PPUSH
17498: EMPTY
17499: PPUSH
17500: CALL_OW 1
17504: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17505: LD_ADDR_EXP 52
17509: PUSH
17510: LD_EXP 52
17514: PPUSH
17515: LD_VAR 0 1
17519: PPUSH
17520: EMPTY
17521: PPUSH
17522: CALL_OW 1
17526: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17527: LD_ADDR_EXP 53
17531: PUSH
17532: LD_EXP 53
17536: PPUSH
17537: LD_VAR 0 1
17541: PPUSH
17542: EMPTY
17543: PPUSH
17544: CALL_OW 1
17548: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17549: LD_ADDR_EXP 54
17553: PUSH
17554: LD_EXP 54
17558: PPUSH
17559: LD_VAR 0 1
17563: PPUSH
17564: EMPTY
17565: PPUSH
17566: CALL_OW 1
17570: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17571: LD_ADDR_EXP 55
17575: PUSH
17576: LD_EXP 55
17580: PPUSH
17581: LD_VAR 0 1
17585: PPUSH
17586: EMPTY
17587: PPUSH
17588: CALL_OW 1
17592: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17593: LD_ADDR_EXP 56
17597: PUSH
17598: LD_EXP 56
17602: PPUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: EMPTY
17609: PPUSH
17610: CALL_OW 1
17614: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17615: LD_ADDR_EXP 57
17619: PUSH
17620: LD_EXP 57
17624: PPUSH
17625: LD_VAR 0 1
17629: PPUSH
17630: EMPTY
17631: PPUSH
17632: CALL_OW 1
17636: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17637: LD_ADDR_EXP 58
17641: PUSH
17642: LD_EXP 58
17646: PPUSH
17647: LD_VAR 0 1
17651: PPUSH
17652: EMPTY
17653: PPUSH
17654: CALL_OW 1
17658: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17659: LD_ADDR_EXP 59
17663: PUSH
17664: LD_EXP 59
17668: PPUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: EMPTY
17675: PPUSH
17676: CALL_OW 1
17680: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17681: LD_ADDR_EXP 60
17685: PUSH
17686: LD_EXP 60
17690: PPUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: EMPTY
17697: PPUSH
17698: CALL_OW 1
17702: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17703: LD_ADDR_EXP 61
17707: PUSH
17708: LD_EXP 61
17712: PPUSH
17713: LD_VAR 0 1
17717: PPUSH
17718: LD_INT 0
17720: PPUSH
17721: CALL_OW 1
17725: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17726: LD_ADDR_EXP 62
17730: PUSH
17731: LD_EXP 62
17735: PPUSH
17736: LD_VAR 0 1
17740: PPUSH
17741: EMPTY
17742: PPUSH
17743: CALL_OW 1
17747: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17748: LD_ADDR_EXP 63
17752: PUSH
17753: LD_EXP 63
17757: PPUSH
17758: LD_VAR 0 1
17762: PPUSH
17763: EMPTY
17764: PPUSH
17765: CALL_OW 1
17769: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17770: LD_ADDR_EXP 64
17774: PUSH
17775: LD_EXP 64
17779: PPUSH
17780: LD_VAR 0 1
17784: PPUSH
17785: EMPTY
17786: PPUSH
17787: CALL_OW 1
17791: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17792: LD_ADDR_EXP 65
17796: PUSH
17797: LD_EXP 65
17801: PPUSH
17802: LD_VAR 0 1
17806: PPUSH
17807: EMPTY
17808: PPUSH
17809: CALL_OW 1
17813: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17814: LD_ADDR_EXP 66
17818: PUSH
17819: LD_EXP 66
17823: PPUSH
17824: LD_VAR 0 1
17828: PPUSH
17829: EMPTY
17830: PPUSH
17831: CALL_OW 1
17835: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17836: LD_ADDR_EXP 67
17840: PUSH
17841: LD_EXP 67
17845: PPUSH
17846: LD_VAR 0 1
17850: PPUSH
17851: EMPTY
17852: PPUSH
17853: CALL_OW 1
17857: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17858: LD_ADDR_EXP 68
17862: PUSH
17863: LD_EXP 68
17867: PPUSH
17868: LD_VAR 0 1
17872: PPUSH
17873: EMPTY
17874: PPUSH
17875: CALL_OW 1
17879: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17880: LD_ADDR_EXP 69
17884: PUSH
17885: LD_EXP 69
17889: PPUSH
17890: LD_VAR 0 1
17894: PPUSH
17895: EMPTY
17896: PPUSH
17897: CALL_OW 1
17901: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17902: LD_ADDR_EXP 70
17906: PUSH
17907: LD_EXP 70
17911: PPUSH
17912: LD_VAR 0 1
17916: PPUSH
17917: EMPTY
17918: PPUSH
17919: CALL_OW 1
17923: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17924: LD_ADDR_EXP 71
17928: PUSH
17929: LD_EXP 71
17933: PPUSH
17934: LD_VAR 0 1
17938: PPUSH
17939: EMPTY
17940: PPUSH
17941: CALL_OW 1
17945: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17946: LD_ADDR_EXP 72
17950: PUSH
17951: LD_EXP 72
17955: PPUSH
17956: LD_VAR 0 1
17960: PPUSH
17961: EMPTY
17962: PPUSH
17963: CALL_OW 1
17967: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17968: LD_ADDR_EXP 73
17972: PUSH
17973: LD_EXP 73
17977: PPUSH
17978: LD_VAR 0 1
17982: PPUSH
17983: EMPTY
17984: PPUSH
17985: CALL_OW 1
17989: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17990: LD_ADDR_EXP 74
17994: PUSH
17995: LD_EXP 74
17999: PPUSH
18000: LD_VAR 0 1
18004: PPUSH
18005: EMPTY
18006: PPUSH
18007: CALL_OW 1
18011: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18012: LD_ADDR_EXP 75
18016: PUSH
18017: LD_EXP 75
18021: PPUSH
18022: LD_VAR 0 1
18026: PPUSH
18027: EMPTY
18028: PPUSH
18029: CALL_OW 1
18033: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18034: LD_ADDR_EXP 77
18038: PUSH
18039: LD_EXP 77
18043: PPUSH
18044: LD_VAR 0 1
18048: PPUSH
18049: EMPTY
18050: PPUSH
18051: CALL_OW 1
18055: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18056: LD_ADDR_EXP 79
18060: PUSH
18061: LD_EXP 79
18065: PPUSH
18066: LD_VAR 0 1
18070: PPUSH
18071: EMPTY
18072: PPUSH
18073: CALL_OW 1
18077: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18078: LD_ADDR_EXP 80
18082: PUSH
18083: LD_EXP 80
18087: PPUSH
18088: LD_VAR 0 1
18092: PPUSH
18093: EMPTY
18094: PPUSH
18095: CALL_OW 1
18099: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18100: LD_ADDR_EXP 81
18104: PUSH
18105: LD_EXP 81
18109: PPUSH
18110: LD_VAR 0 1
18114: PPUSH
18115: EMPTY
18116: PPUSH
18117: CALL_OW 1
18121: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18122: LD_ADDR_EXP 82
18126: PUSH
18127: LD_EXP 82
18131: PPUSH
18132: LD_VAR 0 1
18136: PPUSH
18137: EMPTY
18138: PPUSH
18139: CALL_OW 1
18143: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18144: LD_ADDR_EXP 83
18148: PUSH
18149: LD_EXP 83
18153: PPUSH
18154: LD_VAR 0 1
18158: PPUSH
18159: EMPTY
18160: PPUSH
18161: CALL_OW 1
18165: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18166: LD_ADDR_EXP 84
18170: PUSH
18171: LD_EXP 84
18175: PPUSH
18176: LD_VAR 0 1
18180: PPUSH
18181: EMPTY
18182: PPUSH
18183: CALL_OW 1
18187: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18188: LD_ADDR_EXP 85
18192: PUSH
18193: LD_EXP 85
18197: PPUSH
18198: LD_VAR 0 1
18202: PPUSH
18203: EMPTY
18204: PPUSH
18205: CALL_OW 1
18209: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18210: LD_ADDR_EXP 86
18214: PUSH
18215: LD_EXP 86
18219: PPUSH
18220: LD_VAR 0 1
18224: PPUSH
18225: EMPTY
18226: PPUSH
18227: CALL_OW 1
18231: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18232: LD_ADDR_EXP 87
18236: PUSH
18237: LD_EXP 87
18241: PPUSH
18242: LD_VAR 0 1
18246: PPUSH
18247: EMPTY
18248: PPUSH
18249: CALL_OW 1
18253: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18254: LD_ADDR_EXP 88
18258: PUSH
18259: LD_EXP 88
18263: PPUSH
18264: LD_VAR 0 1
18268: PPUSH
18269: EMPTY
18270: PPUSH
18271: CALL_OW 1
18275: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18276: LD_ADDR_EXP 89
18280: PUSH
18281: LD_EXP 89
18285: PPUSH
18286: LD_VAR 0 1
18290: PPUSH
18291: EMPTY
18292: PPUSH
18293: CALL_OW 1
18297: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18298: LD_ADDR_EXP 90
18302: PUSH
18303: LD_EXP 90
18307: PPUSH
18308: LD_VAR 0 1
18312: PPUSH
18313: EMPTY
18314: PPUSH
18315: CALL_OW 1
18319: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18320: LD_ADDR_EXP 91
18324: PUSH
18325: LD_EXP 91
18329: PPUSH
18330: LD_VAR 0 1
18334: PPUSH
18335: EMPTY
18336: PPUSH
18337: CALL_OW 1
18341: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18342: LD_ADDR_EXP 92
18346: PUSH
18347: LD_EXP 92
18351: PPUSH
18352: LD_VAR 0 1
18356: PPUSH
18357: LD_INT 0
18359: PPUSH
18360: CALL_OW 1
18364: ST_TO_ADDR
// end ;
18365: LD_VAR 0 2
18369: RET
// export function MC_Add ( side , units ) ; var base ; begin
18370: LD_INT 0
18372: PPUSH
18373: PPUSH
// base := mc_bases + 1 ;
18374: LD_ADDR_VAR 0 4
18378: PUSH
18379: LD_EXP 50
18383: PUSH
18384: LD_INT 1
18386: PLUS
18387: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18388: LD_ADDR_EXP 76
18392: PUSH
18393: LD_EXP 76
18397: PPUSH
18398: LD_VAR 0 4
18402: PPUSH
18403: LD_VAR 0 1
18407: PPUSH
18408: CALL_OW 1
18412: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18413: LD_ADDR_EXP 50
18417: PUSH
18418: LD_EXP 50
18422: PPUSH
18423: LD_VAR 0 4
18427: PPUSH
18428: LD_VAR 0 2
18432: PPUSH
18433: CALL_OW 1
18437: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18438: LD_ADDR_EXP 51
18442: PUSH
18443: LD_EXP 51
18447: PPUSH
18448: LD_VAR 0 4
18452: PPUSH
18453: EMPTY
18454: PPUSH
18455: CALL_OW 1
18459: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18460: LD_ADDR_EXP 52
18464: PUSH
18465: LD_EXP 52
18469: PPUSH
18470: LD_VAR 0 4
18474: PPUSH
18475: EMPTY
18476: PPUSH
18477: CALL_OW 1
18481: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18482: LD_ADDR_EXP 53
18486: PUSH
18487: LD_EXP 53
18491: PPUSH
18492: LD_VAR 0 4
18496: PPUSH
18497: EMPTY
18498: PPUSH
18499: CALL_OW 1
18503: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18504: LD_ADDR_EXP 54
18508: PUSH
18509: LD_EXP 54
18513: PPUSH
18514: LD_VAR 0 4
18518: PPUSH
18519: EMPTY
18520: PPUSH
18521: CALL_OW 1
18525: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18526: LD_ADDR_EXP 55
18530: PUSH
18531: LD_EXP 55
18535: PPUSH
18536: LD_VAR 0 4
18540: PPUSH
18541: EMPTY
18542: PPUSH
18543: CALL_OW 1
18547: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18548: LD_ADDR_EXP 56
18552: PUSH
18553: LD_EXP 56
18557: PPUSH
18558: LD_VAR 0 4
18562: PPUSH
18563: EMPTY
18564: PPUSH
18565: CALL_OW 1
18569: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18570: LD_ADDR_EXP 57
18574: PUSH
18575: LD_EXP 57
18579: PPUSH
18580: LD_VAR 0 4
18584: PPUSH
18585: EMPTY
18586: PPUSH
18587: CALL_OW 1
18591: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18592: LD_ADDR_EXP 58
18596: PUSH
18597: LD_EXP 58
18601: PPUSH
18602: LD_VAR 0 4
18606: PPUSH
18607: EMPTY
18608: PPUSH
18609: CALL_OW 1
18613: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18614: LD_ADDR_EXP 59
18618: PUSH
18619: LD_EXP 59
18623: PPUSH
18624: LD_VAR 0 4
18628: PPUSH
18629: EMPTY
18630: PPUSH
18631: CALL_OW 1
18635: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18636: LD_ADDR_EXP 60
18640: PUSH
18641: LD_EXP 60
18645: PPUSH
18646: LD_VAR 0 4
18650: PPUSH
18651: EMPTY
18652: PPUSH
18653: CALL_OW 1
18657: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18658: LD_ADDR_EXP 61
18662: PUSH
18663: LD_EXP 61
18667: PPUSH
18668: LD_VAR 0 4
18672: PPUSH
18673: LD_INT 0
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18681: LD_ADDR_EXP 62
18685: PUSH
18686: LD_EXP 62
18690: PPUSH
18691: LD_VAR 0 4
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18703: LD_ADDR_EXP 63
18707: PUSH
18708: LD_EXP 63
18712: PPUSH
18713: LD_VAR 0 4
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18725: LD_ADDR_EXP 64
18729: PUSH
18730: LD_EXP 64
18734: PPUSH
18735: LD_VAR 0 4
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18747: LD_ADDR_EXP 65
18751: PUSH
18752: LD_EXP 65
18756: PPUSH
18757: LD_VAR 0 4
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18769: LD_ADDR_EXP 66
18773: PUSH
18774: LD_EXP 66
18778: PPUSH
18779: LD_VAR 0 4
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18791: LD_ADDR_EXP 67
18795: PUSH
18796: LD_EXP 67
18800: PPUSH
18801: LD_VAR 0 4
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18813: LD_ADDR_EXP 68
18817: PUSH
18818: LD_EXP 68
18822: PPUSH
18823: LD_VAR 0 4
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18835: LD_ADDR_EXP 69
18839: PUSH
18840: LD_EXP 69
18844: PPUSH
18845: LD_VAR 0 4
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18857: LD_ADDR_EXP 70
18861: PUSH
18862: LD_EXP 70
18866: PPUSH
18867: LD_VAR 0 4
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18879: LD_ADDR_EXP 71
18883: PUSH
18884: LD_EXP 71
18888: PPUSH
18889: LD_VAR 0 4
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18901: LD_ADDR_EXP 72
18905: PUSH
18906: LD_EXP 72
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18923: LD_ADDR_EXP 73
18927: PUSH
18928: LD_EXP 73
18932: PPUSH
18933: LD_VAR 0 4
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18945: LD_ADDR_EXP 74
18949: PUSH
18950: LD_EXP 74
18954: PPUSH
18955: LD_VAR 0 4
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18967: LD_ADDR_EXP 75
18971: PUSH
18972: LD_EXP 75
18976: PPUSH
18977: LD_VAR 0 4
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18989: LD_ADDR_EXP 77
18993: PUSH
18994: LD_EXP 77
18998: PPUSH
18999: LD_VAR 0 4
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19011: LD_ADDR_EXP 79
19015: PUSH
19016: LD_EXP 79
19020: PPUSH
19021: LD_VAR 0 4
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19033: LD_ADDR_EXP 80
19037: PUSH
19038: LD_EXP 80
19042: PPUSH
19043: LD_VAR 0 4
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19055: LD_ADDR_EXP 81
19059: PUSH
19060: LD_EXP 81
19064: PPUSH
19065: LD_VAR 0 4
19069: PPUSH
19070: EMPTY
19071: PPUSH
19072: CALL_OW 1
19076: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19077: LD_ADDR_EXP 82
19081: PUSH
19082: LD_EXP 82
19086: PPUSH
19087: LD_VAR 0 4
19091: PPUSH
19092: EMPTY
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19099: LD_ADDR_EXP 83
19103: PUSH
19104: LD_EXP 83
19108: PPUSH
19109: LD_VAR 0 4
19113: PPUSH
19114: EMPTY
19115: PPUSH
19116: CALL_OW 1
19120: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19121: LD_ADDR_EXP 84
19125: PUSH
19126: LD_EXP 84
19130: PPUSH
19131: LD_VAR 0 4
19135: PPUSH
19136: EMPTY
19137: PPUSH
19138: CALL_OW 1
19142: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19143: LD_ADDR_EXP 85
19147: PUSH
19148: LD_EXP 85
19152: PPUSH
19153: LD_VAR 0 4
19157: PPUSH
19158: EMPTY
19159: PPUSH
19160: CALL_OW 1
19164: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19165: LD_ADDR_EXP 86
19169: PUSH
19170: LD_EXP 86
19174: PPUSH
19175: LD_VAR 0 4
19179: PPUSH
19180: EMPTY
19181: PPUSH
19182: CALL_OW 1
19186: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19187: LD_ADDR_EXP 87
19191: PUSH
19192: LD_EXP 87
19196: PPUSH
19197: LD_VAR 0 4
19201: PPUSH
19202: EMPTY
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19209: LD_ADDR_EXP 88
19213: PUSH
19214: LD_EXP 88
19218: PPUSH
19219: LD_VAR 0 4
19223: PPUSH
19224: EMPTY
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19231: LD_ADDR_EXP 89
19235: PUSH
19236: LD_EXP 89
19240: PPUSH
19241: LD_VAR 0 4
19245: PPUSH
19246: EMPTY
19247: PPUSH
19248: CALL_OW 1
19252: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19253: LD_ADDR_EXP 90
19257: PUSH
19258: LD_EXP 90
19262: PPUSH
19263: LD_VAR 0 4
19267: PPUSH
19268: EMPTY
19269: PPUSH
19270: CALL_OW 1
19274: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19275: LD_ADDR_EXP 91
19279: PUSH
19280: LD_EXP 91
19284: PPUSH
19285: LD_VAR 0 4
19289: PPUSH
19290: EMPTY
19291: PPUSH
19292: CALL_OW 1
19296: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19297: LD_ADDR_EXP 92
19301: PUSH
19302: LD_EXP 92
19306: PPUSH
19307: LD_VAR 0 4
19311: PPUSH
19312: LD_INT 0
19314: PPUSH
19315: CALL_OW 1
19319: ST_TO_ADDR
// result := base ;
19320: LD_ADDR_VAR 0 3
19324: PUSH
19325: LD_VAR 0 4
19329: ST_TO_ADDR
// end ;
19330: LD_VAR 0 3
19334: RET
// export function MC_Start ( ) ; var i ; begin
19335: LD_INT 0
19337: PPUSH
19338: PPUSH
// for i = 1 to mc_bases do
19339: LD_ADDR_VAR 0 2
19343: PUSH
19344: DOUBLE
19345: LD_INT 1
19347: DEC
19348: ST_TO_ADDR
19349: LD_EXP 50
19353: PUSH
19354: FOR_TO
19355: IFFALSE 20432
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19357: LD_ADDR_EXP 50
19361: PUSH
19362: LD_EXP 50
19366: PPUSH
19367: LD_VAR 0 2
19371: PPUSH
19372: LD_EXP 50
19376: PUSH
19377: LD_VAR 0 2
19381: ARRAY
19382: PUSH
19383: LD_INT 0
19385: DIFF
19386: PPUSH
19387: CALL_OW 1
19391: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19392: LD_ADDR_EXP 51
19396: PUSH
19397: LD_EXP 51
19401: PPUSH
19402: LD_VAR 0 2
19406: PPUSH
19407: EMPTY
19408: PPUSH
19409: CALL_OW 1
19413: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19414: LD_ADDR_EXP 52
19418: PUSH
19419: LD_EXP 52
19423: PPUSH
19424: LD_VAR 0 2
19428: PPUSH
19429: EMPTY
19430: PPUSH
19431: CALL_OW 1
19435: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19436: LD_ADDR_EXP 53
19440: PUSH
19441: LD_EXP 53
19445: PPUSH
19446: LD_VAR 0 2
19450: PPUSH
19451: EMPTY
19452: PPUSH
19453: CALL_OW 1
19457: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19458: LD_ADDR_EXP 54
19462: PUSH
19463: LD_EXP 54
19467: PPUSH
19468: LD_VAR 0 2
19472: PPUSH
19473: EMPTY
19474: PUSH
19475: EMPTY
19476: PUSH
19477: EMPTY
19478: LIST
19479: LIST
19480: PPUSH
19481: CALL_OW 1
19485: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19486: LD_ADDR_EXP 55
19490: PUSH
19491: LD_EXP 55
19495: PPUSH
19496: LD_VAR 0 2
19500: PPUSH
19501: EMPTY
19502: PPUSH
19503: CALL_OW 1
19507: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19508: LD_ADDR_EXP 82
19512: PUSH
19513: LD_EXP 82
19517: PPUSH
19518: LD_VAR 0 2
19522: PPUSH
19523: EMPTY
19524: PPUSH
19525: CALL_OW 1
19529: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19530: LD_ADDR_EXP 56
19534: PUSH
19535: LD_EXP 56
19539: PPUSH
19540: LD_VAR 0 2
19544: PPUSH
19545: EMPTY
19546: PPUSH
19547: CALL_OW 1
19551: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19552: LD_ADDR_EXP 57
19556: PUSH
19557: LD_EXP 57
19561: PPUSH
19562: LD_VAR 0 2
19566: PPUSH
19567: EMPTY
19568: PPUSH
19569: CALL_OW 1
19573: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19574: LD_ADDR_EXP 58
19578: PUSH
19579: LD_EXP 58
19583: PPUSH
19584: LD_VAR 0 2
19588: PPUSH
19589: LD_EXP 50
19593: PUSH
19594: LD_VAR 0 2
19598: ARRAY
19599: PPUSH
19600: LD_INT 2
19602: PUSH
19603: LD_INT 30
19605: PUSH
19606: LD_INT 32
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PUSH
19613: LD_INT 30
19615: PUSH
19616: LD_INT 33
19618: PUSH
19619: EMPTY
19620: LIST
19621: LIST
19622: PUSH
19623: EMPTY
19624: LIST
19625: LIST
19626: LIST
19627: PPUSH
19628: CALL_OW 72
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19638: LD_ADDR_EXP 59
19642: PUSH
19643: LD_EXP 59
19647: PPUSH
19648: LD_VAR 0 2
19652: PPUSH
19653: LD_EXP 50
19657: PUSH
19658: LD_VAR 0 2
19662: ARRAY
19663: PPUSH
19664: LD_INT 2
19666: PUSH
19667: LD_INT 30
19669: PUSH
19670: LD_INT 32
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PUSH
19677: LD_INT 30
19679: PUSH
19680: LD_INT 31
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: LIST
19691: PUSH
19692: LD_INT 58
19694: PUSH
19695: EMPTY
19696: LIST
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: PPUSH
19702: CALL_OW 72
19706: PPUSH
19707: CALL_OW 1
19711: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19712: LD_ADDR_EXP 60
19716: PUSH
19717: LD_EXP 60
19721: PPUSH
19722: LD_VAR 0 2
19726: PPUSH
19727: EMPTY
19728: PPUSH
19729: CALL_OW 1
19733: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19734: LD_ADDR_EXP 64
19738: PUSH
19739: LD_EXP 64
19743: PPUSH
19744: LD_VAR 0 2
19748: PPUSH
19749: EMPTY
19750: PPUSH
19751: CALL_OW 1
19755: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19756: LD_ADDR_EXP 63
19760: PUSH
19761: LD_EXP 63
19765: PPUSH
19766: LD_VAR 0 2
19770: PPUSH
19771: EMPTY
19772: PPUSH
19773: CALL_OW 1
19777: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19778: LD_ADDR_EXP 65
19782: PUSH
19783: LD_EXP 65
19787: PPUSH
19788: LD_VAR 0 2
19792: PPUSH
19793: EMPTY
19794: PPUSH
19795: CALL_OW 1
19799: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19800: LD_ADDR_EXP 66
19804: PUSH
19805: LD_EXP 66
19809: PPUSH
19810: LD_VAR 0 2
19814: PPUSH
19815: EMPTY
19816: PPUSH
19817: CALL_OW 1
19821: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19822: LD_ADDR_EXP 67
19826: PUSH
19827: LD_EXP 67
19831: PPUSH
19832: LD_VAR 0 2
19836: PPUSH
19837: EMPTY
19838: PPUSH
19839: CALL_OW 1
19843: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19844: LD_ADDR_EXP 68
19848: PUSH
19849: LD_EXP 68
19853: PPUSH
19854: LD_VAR 0 2
19858: PPUSH
19859: EMPTY
19860: PPUSH
19861: CALL_OW 1
19865: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19866: LD_ADDR_EXP 69
19870: PUSH
19871: LD_EXP 69
19875: PPUSH
19876: LD_VAR 0 2
19880: PPUSH
19881: EMPTY
19882: PPUSH
19883: CALL_OW 1
19887: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19888: LD_ADDR_EXP 70
19892: PUSH
19893: LD_EXP 70
19897: PPUSH
19898: LD_VAR 0 2
19902: PPUSH
19903: EMPTY
19904: PPUSH
19905: CALL_OW 1
19909: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19910: LD_ADDR_EXP 71
19914: PUSH
19915: LD_EXP 71
19919: PPUSH
19920: LD_VAR 0 2
19924: PPUSH
19925: EMPTY
19926: PPUSH
19927: CALL_OW 1
19931: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19932: LD_ADDR_EXP 72
19936: PUSH
19937: LD_EXP 72
19941: PPUSH
19942: LD_VAR 0 2
19946: PPUSH
19947: EMPTY
19948: PPUSH
19949: CALL_OW 1
19953: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19954: LD_ADDR_EXP 61
19958: PUSH
19959: LD_EXP 61
19963: PPUSH
19964: LD_VAR 0 2
19968: PPUSH
19969: LD_INT 0
19971: PPUSH
19972: CALL_OW 1
19976: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19977: LD_ADDR_EXP 74
19981: PUSH
19982: LD_EXP 74
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_INT 0
19994: PPUSH
19995: CALL_OW 1
19999: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20000: LD_ADDR_EXP 62
20004: PUSH
20005: LD_EXP 62
20009: PPUSH
20010: LD_VAR 0 2
20014: PPUSH
20015: EMPTY
20016: PPUSH
20017: CALL_OW 1
20021: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20022: LD_ADDR_EXP 73
20026: PUSH
20027: LD_EXP 73
20031: PPUSH
20032: LD_VAR 0 2
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20045: LD_ADDR_EXP 75
20049: PUSH
20050: LD_EXP 75
20054: PPUSH
20055: LD_VAR 0 2
20059: PPUSH
20060: EMPTY
20061: PPUSH
20062: CALL_OW 1
20066: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20067: LD_ADDR_EXP 78
20071: PUSH
20072: LD_EXP 78
20076: PPUSH
20077: LD_VAR 0 2
20081: PPUSH
20082: LD_INT 0
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20090: LD_ADDR_EXP 79
20094: PUSH
20095: LD_EXP 79
20099: PPUSH
20100: LD_VAR 0 2
20104: PPUSH
20105: EMPTY
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20112: LD_ADDR_EXP 80
20116: PUSH
20117: LD_EXP 80
20121: PPUSH
20122: LD_VAR 0 2
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20134: LD_ADDR_EXP 81
20138: PUSH
20139: LD_EXP 81
20143: PPUSH
20144: LD_VAR 0 2
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20156: LD_ADDR_EXP 83
20160: PUSH
20161: LD_EXP 83
20165: PPUSH
20166: LD_VAR 0 2
20170: PPUSH
20171: LD_EXP 50
20175: PUSH
20176: LD_VAR 0 2
20180: ARRAY
20181: PPUSH
20182: LD_INT 2
20184: PUSH
20185: LD_INT 30
20187: PUSH
20188: LD_INT 6
20190: PUSH
20191: EMPTY
20192: LIST
20193: LIST
20194: PUSH
20195: LD_INT 30
20197: PUSH
20198: LD_INT 7
20200: PUSH
20201: EMPTY
20202: LIST
20203: LIST
20204: PUSH
20205: LD_INT 30
20207: PUSH
20208: LD_INT 8
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: PPUSH
20221: CALL_OW 72
20225: PPUSH
20226: CALL_OW 1
20230: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20231: LD_ADDR_EXP 84
20235: PUSH
20236: LD_EXP 84
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: EMPTY
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20253: LD_ADDR_EXP 85
20257: PUSH
20258: LD_EXP 85
20262: PPUSH
20263: LD_VAR 0 2
20267: PPUSH
20268: EMPTY
20269: PPUSH
20270: CALL_OW 1
20274: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20275: LD_ADDR_EXP 86
20279: PUSH
20280: LD_EXP 86
20284: PPUSH
20285: LD_VAR 0 2
20289: PPUSH
20290: EMPTY
20291: PPUSH
20292: CALL_OW 1
20296: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20297: LD_ADDR_EXP 87
20301: PUSH
20302: LD_EXP 87
20306: PPUSH
20307: LD_VAR 0 2
20311: PPUSH
20312: EMPTY
20313: PPUSH
20314: CALL_OW 1
20318: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20319: LD_ADDR_EXP 88
20323: PUSH
20324: LD_EXP 88
20328: PPUSH
20329: LD_VAR 0 2
20333: PPUSH
20334: EMPTY
20335: PPUSH
20336: CALL_OW 1
20340: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20341: LD_ADDR_EXP 89
20345: PUSH
20346: LD_EXP 89
20350: PPUSH
20351: LD_VAR 0 2
20355: PPUSH
20356: EMPTY
20357: PPUSH
20358: CALL_OW 1
20362: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20363: LD_ADDR_EXP 90
20367: PUSH
20368: LD_EXP 90
20372: PPUSH
20373: LD_VAR 0 2
20377: PPUSH
20378: EMPTY
20379: PPUSH
20380: CALL_OW 1
20384: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20385: LD_ADDR_EXP 91
20389: PUSH
20390: LD_EXP 91
20394: PPUSH
20395: LD_VAR 0 2
20399: PPUSH
20400: EMPTY
20401: PPUSH
20402: CALL_OW 1
20406: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20407: LD_ADDR_EXP 92
20411: PUSH
20412: LD_EXP 92
20416: PPUSH
20417: LD_VAR 0 2
20421: PPUSH
20422: LD_INT 0
20424: PPUSH
20425: CALL_OW 1
20429: ST_TO_ADDR
// end ;
20430: GO 19354
20432: POP
20433: POP
// MC_InitSides ( ) ;
20434: CALL 20720 0 0
// MC_InitResearch ( ) ;
20438: CALL 20459 0 0
// CustomInitMacro ( ) ;
20442: CALL 300 0 0
// skirmish := true ;
20446: LD_ADDR_EXP 48
20450: PUSH
20451: LD_INT 1
20453: ST_TO_ADDR
// end ;
20454: LD_VAR 0 1
20458: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20459: LD_INT 0
20461: PPUSH
20462: PPUSH
20463: PPUSH
20464: PPUSH
20465: PPUSH
20466: PPUSH
// if not mc_bases then
20467: LD_EXP 50
20471: NOT
20472: IFFALSE 20476
// exit ;
20474: GO 20715
// for i = 1 to 8 do
20476: LD_ADDR_VAR 0 2
20480: PUSH
20481: DOUBLE
20482: LD_INT 1
20484: DEC
20485: ST_TO_ADDR
20486: LD_INT 8
20488: PUSH
20489: FOR_TO
20490: IFFALSE 20516
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20492: LD_ADDR_EXP 77
20496: PUSH
20497: LD_EXP 77
20501: PPUSH
20502: LD_VAR 0 2
20506: PPUSH
20507: EMPTY
20508: PPUSH
20509: CALL_OW 1
20513: ST_TO_ADDR
20514: GO 20489
20516: POP
20517: POP
// tmp := [ ] ;
20518: LD_ADDR_VAR 0 5
20522: PUSH
20523: EMPTY
20524: ST_TO_ADDR
// for i = 1 to mc_sides do
20525: LD_ADDR_VAR 0 2
20529: PUSH
20530: DOUBLE
20531: LD_INT 1
20533: DEC
20534: ST_TO_ADDR
20535: LD_EXP 76
20539: PUSH
20540: FOR_TO
20541: IFFALSE 20599
// if not mc_sides [ i ] in tmp then
20543: LD_EXP 76
20547: PUSH
20548: LD_VAR 0 2
20552: ARRAY
20553: PUSH
20554: LD_VAR 0 5
20558: IN
20559: NOT
20560: IFFALSE 20597
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20562: LD_ADDR_VAR 0 5
20566: PUSH
20567: LD_VAR 0 5
20571: PPUSH
20572: LD_VAR 0 5
20576: PUSH
20577: LD_INT 1
20579: PLUS
20580: PPUSH
20581: LD_EXP 76
20585: PUSH
20586: LD_VAR 0 2
20590: ARRAY
20591: PPUSH
20592: CALL_OW 2
20596: ST_TO_ADDR
20597: GO 20540
20599: POP
20600: POP
// if not tmp then
20601: LD_VAR 0 5
20605: NOT
20606: IFFALSE 20610
// exit ;
20608: GO 20715
// for j in tmp do
20610: LD_ADDR_VAR 0 3
20614: PUSH
20615: LD_VAR 0 5
20619: PUSH
20620: FOR_IN
20621: IFFALSE 20713
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20623: LD_ADDR_VAR 0 6
20627: PUSH
20628: LD_INT 22
20630: PUSH
20631: LD_VAR 0 3
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PPUSH
20640: CALL_OW 69
20644: ST_TO_ADDR
// if not un then
20645: LD_VAR 0 6
20649: NOT
20650: IFFALSE 20654
// continue ;
20652: GO 20620
// nation := GetNation ( un [ 1 ] ) ;
20654: LD_ADDR_VAR 0 4
20658: PUSH
20659: LD_VAR 0 6
20663: PUSH
20664: LD_INT 1
20666: ARRAY
20667: PPUSH
20668: CALL_OW 248
20672: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20673: LD_ADDR_EXP 77
20677: PUSH
20678: LD_EXP 77
20682: PPUSH
20683: LD_VAR 0 3
20687: PPUSH
20688: LD_VAR 0 3
20692: PPUSH
20693: LD_VAR 0 4
20697: PPUSH
20698: LD_INT 1
20700: PPUSH
20701: CALL 47325 0 3
20705: PPUSH
20706: CALL_OW 1
20710: ST_TO_ADDR
// end ;
20711: GO 20620
20713: POP
20714: POP
// end ;
20715: LD_VAR 0 1
20719: RET
// export function MC_InitSides ( ) ; var i ; begin
20720: LD_INT 0
20722: PPUSH
20723: PPUSH
// if not mc_bases then
20724: LD_EXP 50
20728: NOT
20729: IFFALSE 20733
// exit ;
20731: GO 20807
// for i = 1 to mc_bases do
20733: LD_ADDR_VAR 0 2
20737: PUSH
20738: DOUBLE
20739: LD_INT 1
20741: DEC
20742: ST_TO_ADDR
20743: LD_EXP 50
20747: PUSH
20748: FOR_TO
20749: IFFALSE 20805
// if mc_bases [ i ] then
20751: LD_EXP 50
20755: PUSH
20756: LD_VAR 0 2
20760: ARRAY
20761: IFFALSE 20803
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20763: LD_ADDR_EXP 76
20767: PUSH
20768: LD_EXP 76
20772: PPUSH
20773: LD_VAR 0 2
20777: PPUSH
20778: LD_EXP 50
20782: PUSH
20783: LD_VAR 0 2
20787: ARRAY
20788: PUSH
20789: LD_INT 1
20791: ARRAY
20792: PPUSH
20793: CALL_OW 255
20797: PPUSH
20798: CALL_OW 1
20802: ST_TO_ADDR
20803: GO 20748
20805: POP
20806: POP
// end ;
20807: LD_VAR 0 1
20811: RET
// every 0 0$01 trigger skirmish do
20812: LD_EXP 48
20816: IFFALSE 20970
20818: GO 20820
20820: DISABLE
// begin enable ;
20821: ENABLE
// MC_CheckBuildings ( ) ;
20822: CALL 25468 0 0
// MC_CheckPeopleLife ( ) ;
20826: CALL 25593 0 0
// RaiseSailEvent ( 100 ) ;
20830: LD_INT 100
20832: PPUSH
20833: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20837: LD_INT 103
20839: PPUSH
20840: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20844: LD_INT 104
20846: PPUSH
20847: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20851: LD_INT 105
20853: PPUSH
20854: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20858: LD_INT 106
20860: PPUSH
20861: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20865: LD_INT 107
20867: PPUSH
20868: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20872: LD_INT 108
20874: PPUSH
20875: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20879: LD_INT 109
20881: PPUSH
20882: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20886: LD_INT 110
20888: PPUSH
20889: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20893: LD_INT 111
20895: PPUSH
20896: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20900: LD_INT 112
20902: PPUSH
20903: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20907: LD_INT 113
20909: PPUSH
20910: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20914: LD_INT 120
20916: PPUSH
20917: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20921: LD_INT 121
20923: PPUSH
20924: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20928: LD_INT 122
20930: PPUSH
20931: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20935: LD_INT 123
20937: PPUSH
20938: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20942: LD_INT 124
20944: PPUSH
20945: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20949: LD_INT 125
20951: PPUSH
20952: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20956: LD_INT 126
20958: PPUSH
20959: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20963: LD_INT 200
20965: PPUSH
20966: CALL_OW 427
// end ;
20970: END
// on SailEvent ( event ) do begin if event < 100 then
20971: LD_VAR 0 1
20975: PUSH
20976: LD_INT 100
20978: LESS
20979: IFFALSE 20990
// CustomEvent ( event ) ;
20981: LD_VAR 0 1
20985: PPUSH
20986: CALL 16489 0 1
// if event = 100 then
20990: LD_VAR 0 1
20994: PUSH
20995: LD_INT 100
20997: EQUAL
20998: IFFALSE 21004
// MC_ClassManager ( ) ;
21000: CALL 21396 0 0
// if event = 101 then
21004: LD_VAR 0 1
21008: PUSH
21009: LD_INT 101
21011: EQUAL
21012: IFFALSE 21018
// MC_RepairBuildings ( ) ;
21014: CALL 26189 0 0
// if event = 102 then
21018: LD_VAR 0 1
21022: PUSH
21023: LD_INT 102
21025: EQUAL
21026: IFFALSE 21032
// MC_Heal ( ) ;
21028: CALL 27053 0 0
// if event = 103 then
21032: LD_VAR 0 1
21036: PUSH
21037: LD_INT 103
21039: EQUAL
21040: IFFALSE 21046
// MC_Build ( ) ;
21042: CALL 27475 0 0
// if event = 104 then
21046: LD_VAR 0 1
21050: PUSH
21051: LD_INT 104
21053: EQUAL
21054: IFFALSE 21060
// MC_TurretWeapon ( ) ;
21056: CALL 29088 0 0
// if event = 105 then
21060: LD_VAR 0 1
21064: PUSH
21065: LD_INT 105
21067: EQUAL
21068: IFFALSE 21074
// MC_BuildUpgrade ( ) ;
21070: CALL 28639 0 0
// if event = 106 then
21074: LD_VAR 0 1
21078: PUSH
21079: LD_INT 106
21081: EQUAL
21082: IFFALSE 21088
// MC_PlantMines ( ) ;
21084: CALL 29518 0 0
// if event = 107 then
21088: LD_VAR 0 1
21092: PUSH
21093: LD_INT 107
21095: EQUAL
21096: IFFALSE 21102
// MC_CollectCrates ( ) ;
21098: CALL 30316 0 0
// if event = 108 then
21102: LD_VAR 0 1
21106: PUSH
21107: LD_INT 108
21109: EQUAL
21110: IFFALSE 21116
// MC_LinkRemoteControl ( ) ;
21112: CALL 32092 0 0
// if event = 109 then
21116: LD_VAR 0 1
21120: PUSH
21121: LD_INT 109
21123: EQUAL
21124: IFFALSE 21130
// MC_ProduceVehicle ( ) ;
21126: CALL 32273 0 0
// if event = 110 then
21130: LD_VAR 0 1
21134: PUSH
21135: LD_INT 110
21137: EQUAL
21138: IFFALSE 21144
// MC_SendAttack ( ) ;
21140: CALL 32739 0 0
// if event = 111 then
21144: LD_VAR 0 1
21148: PUSH
21149: LD_INT 111
21151: EQUAL
21152: IFFALSE 21158
// MC_Defend ( ) ;
21154: CALL 32847 0 0
// if event = 112 then
21158: LD_VAR 0 1
21162: PUSH
21163: LD_INT 112
21165: EQUAL
21166: IFFALSE 21172
// MC_Research ( ) ;
21168: CALL 33452 0 0
// if event = 113 then
21172: LD_VAR 0 1
21176: PUSH
21177: LD_INT 113
21179: EQUAL
21180: IFFALSE 21186
// MC_MinesTrigger ( ) ;
21182: CALL 34566 0 0
// if event = 120 then
21186: LD_VAR 0 1
21190: PUSH
21191: LD_INT 120
21193: EQUAL
21194: IFFALSE 21200
// MC_RepairVehicle ( ) ;
21196: CALL 34665 0 0
// if event = 121 then
21200: LD_VAR 0 1
21204: PUSH
21205: LD_INT 121
21207: EQUAL
21208: IFFALSE 21214
// MC_TameApe ( ) ;
21210: CALL 35395 0 0
// if event = 122 then
21214: LD_VAR 0 1
21218: PUSH
21219: LD_INT 122
21221: EQUAL
21222: IFFALSE 21228
// MC_ChangeApeClass ( ) ;
21224: CALL 36224 0 0
// if event = 123 then
21228: LD_VAR 0 1
21232: PUSH
21233: LD_INT 123
21235: EQUAL
21236: IFFALSE 21242
// MC_Bazooka ( ) ;
21238: CALL 36874 0 0
// if event = 124 then
21242: LD_VAR 0 1
21246: PUSH
21247: LD_INT 124
21249: EQUAL
21250: IFFALSE 21256
// MC_TeleportExit ( ) ;
21252: CALL 37072 0 0
// if event = 125 then
21256: LD_VAR 0 1
21260: PUSH
21261: LD_INT 125
21263: EQUAL
21264: IFFALSE 21270
// MC_Deposits ( ) ;
21266: CALL 37719 0 0
// if event = 126 then
21270: LD_VAR 0 1
21274: PUSH
21275: LD_INT 126
21277: EQUAL
21278: IFFALSE 21284
// MC_RemoteDriver ( ) ;
21280: CALL 38344 0 0
// if event = 200 then
21284: LD_VAR 0 1
21288: PUSH
21289: LD_INT 200
21291: EQUAL
21292: IFFALSE 21298
// MC_Idle ( ) ;
21294: CALL 40293 0 0
// end ;
21298: PPOPN 1
21300: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21301: LD_INT 0
21303: PPUSH
21304: PPUSH
// if not mc_bases [ base ] or not tag then
21305: LD_EXP 50
21309: PUSH
21310: LD_VAR 0 1
21314: ARRAY
21315: NOT
21316: PUSH
21317: LD_VAR 0 2
21321: NOT
21322: OR
21323: IFFALSE 21327
// exit ;
21325: GO 21391
// for i in mc_bases [ base ] union mc_ape [ base ] do
21327: LD_ADDR_VAR 0 4
21331: PUSH
21332: LD_EXP 50
21336: PUSH
21337: LD_VAR 0 1
21341: ARRAY
21342: PUSH
21343: LD_EXP 79
21347: PUSH
21348: LD_VAR 0 1
21352: ARRAY
21353: UNION
21354: PUSH
21355: FOR_IN
21356: IFFALSE 21389
// if GetTag ( i ) = tag then
21358: LD_VAR 0 4
21362: PPUSH
21363: CALL_OW 110
21367: PUSH
21368: LD_VAR 0 2
21372: EQUAL
21373: IFFALSE 21387
// SetTag ( i , 0 ) ;
21375: LD_VAR 0 4
21379: PPUSH
21380: LD_INT 0
21382: PPUSH
21383: CALL_OW 109
21387: GO 21355
21389: POP
21390: POP
// end ;
21391: LD_VAR 0 3
21395: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21396: LD_INT 0
21398: PPUSH
21399: PPUSH
21400: PPUSH
21401: PPUSH
21402: PPUSH
21403: PPUSH
21404: PPUSH
21405: PPUSH
// if not mc_bases then
21406: LD_EXP 50
21410: NOT
21411: IFFALSE 21415
// exit ;
21413: GO 21873
// for i = 1 to mc_bases do
21415: LD_ADDR_VAR 0 2
21419: PUSH
21420: DOUBLE
21421: LD_INT 1
21423: DEC
21424: ST_TO_ADDR
21425: LD_EXP 50
21429: PUSH
21430: FOR_TO
21431: IFFALSE 21871
// begin tmp := MC_ClassCheckReq ( i ) ;
21433: LD_ADDR_VAR 0 4
21437: PUSH
21438: LD_VAR 0 2
21442: PPUSH
21443: CALL 21878 0 1
21447: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21448: LD_ADDR_EXP 91
21452: PUSH
21453: LD_EXP 91
21457: PPUSH
21458: LD_VAR 0 2
21462: PPUSH
21463: LD_VAR 0 4
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// if not tmp then
21473: LD_VAR 0 4
21477: NOT
21478: IFFALSE 21482
// continue ;
21480: GO 21430
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21482: LD_ADDR_VAR 0 6
21486: PUSH
21487: LD_EXP 50
21491: PUSH
21492: LD_VAR 0 2
21496: ARRAY
21497: PPUSH
21498: LD_INT 2
21500: PUSH
21501: LD_INT 30
21503: PUSH
21504: LD_INT 4
21506: PUSH
21507: EMPTY
21508: LIST
21509: LIST
21510: PUSH
21511: LD_INT 30
21513: PUSH
21514: LD_INT 5
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: LIST
21525: PPUSH
21526: CALL_OW 72
21530: PUSH
21531: LD_EXP 50
21535: PUSH
21536: LD_VAR 0 2
21540: ARRAY
21541: PPUSH
21542: LD_INT 2
21544: PUSH
21545: LD_INT 30
21547: PUSH
21548: LD_INT 0
21550: PUSH
21551: EMPTY
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_INT 1
21560: PUSH
21561: EMPTY
21562: LIST
21563: LIST
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: PPUSH
21570: CALL_OW 72
21574: PUSH
21575: LD_EXP 50
21579: PUSH
21580: LD_VAR 0 2
21584: ARRAY
21585: PPUSH
21586: LD_INT 30
21588: PUSH
21589: LD_INT 3
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PPUSH
21596: CALL_OW 72
21600: PUSH
21601: LD_EXP 50
21605: PUSH
21606: LD_VAR 0 2
21610: ARRAY
21611: PPUSH
21612: LD_INT 2
21614: PUSH
21615: LD_INT 30
21617: PUSH
21618: LD_INT 6
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 30
21627: PUSH
21628: LD_INT 7
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 30
21637: PUSH
21638: LD_INT 8
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: PPUSH
21651: CALL_OW 72
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: ST_TO_ADDR
// for j = 1 to 4 do
21662: LD_ADDR_VAR 0 3
21666: PUSH
21667: DOUBLE
21668: LD_INT 1
21670: DEC
21671: ST_TO_ADDR
21672: LD_INT 4
21674: PUSH
21675: FOR_TO
21676: IFFALSE 21867
// begin if not tmp [ j ] then
21678: LD_VAR 0 4
21682: PUSH
21683: LD_VAR 0 3
21687: ARRAY
21688: NOT
21689: IFFALSE 21693
// continue ;
21691: GO 21675
// for p in tmp [ j ] do
21693: LD_ADDR_VAR 0 5
21697: PUSH
21698: LD_VAR 0 4
21702: PUSH
21703: LD_VAR 0 3
21707: ARRAY
21708: PUSH
21709: FOR_IN
21710: IFFALSE 21863
// begin if not b [ j ] then
21712: LD_VAR 0 6
21716: PUSH
21717: LD_VAR 0 3
21721: ARRAY
21722: NOT
21723: IFFALSE 21727
// break ;
21725: GO 21863
// e := 0 ;
21727: LD_ADDR_VAR 0 7
21731: PUSH
21732: LD_INT 0
21734: ST_TO_ADDR
// for k in b [ j ] do
21735: LD_ADDR_VAR 0 8
21739: PUSH
21740: LD_VAR 0 6
21744: PUSH
21745: LD_VAR 0 3
21749: ARRAY
21750: PUSH
21751: FOR_IN
21752: IFFALSE 21779
// if IsNotFull ( k ) then
21754: LD_VAR 0 8
21758: PPUSH
21759: CALL 51765 0 1
21763: IFFALSE 21777
// begin e := k ;
21765: LD_ADDR_VAR 0 7
21769: PUSH
21770: LD_VAR 0 8
21774: ST_TO_ADDR
// break ;
21775: GO 21779
// end ;
21777: GO 21751
21779: POP
21780: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21781: LD_VAR 0 7
21785: PUSH
21786: LD_VAR 0 5
21790: PPUSH
21791: LD_VAR 0 7
21795: PPUSH
21796: CALL 88887 0 2
21800: NOT
21801: AND
21802: IFFALSE 21861
// begin if IsInUnit ( p ) then
21804: LD_VAR 0 5
21808: PPUSH
21809: CALL_OW 310
21813: IFFALSE 21824
// ComExitBuilding ( p ) ;
21815: LD_VAR 0 5
21819: PPUSH
21820: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21824: LD_VAR 0 5
21828: PPUSH
21829: LD_VAR 0 7
21833: PPUSH
21834: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21838: LD_VAR 0 5
21842: PPUSH
21843: LD_VAR 0 3
21847: PPUSH
21848: CALL_OW 183
// AddComExitBuilding ( p ) ;
21852: LD_VAR 0 5
21856: PPUSH
21857: CALL_OW 182
// end ; end ;
21861: GO 21709
21863: POP
21864: POP
// end ;
21865: GO 21675
21867: POP
21868: POP
// end ;
21869: GO 21430
21871: POP
21872: POP
// end ;
21873: LD_VAR 0 1
21877: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21878: LD_INT 0
21880: PPUSH
21881: PPUSH
21882: PPUSH
21883: PPUSH
21884: PPUSH
21885: PPUSH
21886: PPUSH
21887: PPUSH
21888: PPUSH
21889: PPUSH
21890: PPUSH
21891: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21892: LD_VAR 0 1
21896: NOT
21897: PUSH
21898: LD_EXP 50
21902: PUSH
21903: LD_VAR 0 1
21907: ARRAY
21908: NOT
21909: OR
21910: PUSH
21911: LD_EXP 50
21915: PUSH
21916: LD_VAR 0 1
21920: ARRAY
21921: PPUSH
21922: LD_INT 2
21924: PUSH
21925: LD_INT 30
21927: PUSH
21928: LD_INT 0
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PUSH
21935: LD_INT 30
21937: PUSH
21938: LD_INT 1
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: LIST
21949: PPUSH
21950: CALL_OW 72
21954: NOT
21955: OR
21956: IFFALSE 21960
// exit ;
21958: GO 25463
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21960: LD_ADDR_VAR 0 4
21964: PUSH
21965: LD_EXP 50
21969: PUSH
21970: LD_VAR 0 1
21974: ARRAY
21975: PPUSH
21976: LD_INT 2
21978: PUSH
21979: LD_INT 25
21981: PUSH
21982: LD_INT 1
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: PUSH
21989: LD_INT 25
21991: PUSH
21992: LD_INT 2
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: LD_INT 25
22001: PUSH
22002: LD_INT 3
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: LD_INT 25
22011: PUSH
22012: LD_INT 4
22014: PUSH
22015: EMPTY
22016: LIST
22017: LIST
22018: PUSH
22019: LD_INT 25
22021: PUSH
22022: LD_INT 5
22024: PUSH
22025: EMPTY
22026: LIST
22027: LIST
22028: PUSH
22029: LD_INT 25
22031: PUSH
22032: LD_INT 8
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 25
22041: PUSH
22042: LD_INT 9
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: PUSH
22049: EMPTY
22050: LIST
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: PPUSH
22059: CALL_OW 72
22063: ST_TO_ADDR
// if not tmp then
22064: LD_VAR 0 4
22068: NOT
22069: IFFALSE 22073
// exit ;
22071: GO 25463
// for i in tmp do
22073: LD_ADDR_VAR 0 3
22077: PUSH
22078: LD_VAR 0 4
22082: PUSH
22083: FOR_IN
22084: IFFALSE 22115
// if GetTag ( i ) then
22086: LD_VAR 0 3
22090: PPUSH
22091: CALL_OW 110
22095: IFFALSE 22113
// tmp := tmp diff i ;
22097: LD_ADDR_VAR 0 4
22101: PUSH
22102: LD_VAR 0 4
22106: PUSH
22107: LD_VAR 0 3
22111: DIFF
22112: ST_TO_ADDR
22113: GO 22083
22115: POP
22116: POP
// if not tmp then
22117: LD_VAR 0 4
22121: NOT
22122: IFFALSE 22126
// exit ;
22124: GO 25463
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22126: LD_ADDR_VAR 0 5
22130: PUSH
22131: LD_EXP 50
22135: PUSH
22136: LD_VAR 0 1
22140: ARRAY
22141: PPUSH
22142: LD_INT 2
22144: PUSH
22145: LD_INT 25
22147: PUSH
22148: LD_INT 1
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PUSH
22155: LD_INT 25
22157: PUSH
22158: LD_INT 5
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: LD_INT 25
22167: PUSH
22168: LD_INT 8
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: LD_INT 25
22177: PUSH
22178: LD_INT 9
22180: PUSH
22181: EMPTY
22182: LIST
22183: LIST
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: LIST
22189: LIST
22190: LIST
22191: PPUSH
22192: CALL_OW 72
22196: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22197: LD_ADDR_VAR 0 6
22201: PUSH
22202: LD_EXP 50
22206: PUSH
22207: LD_VAR 0 1
22211: ARRAY
22212: PPUSH
22213: LD_INT 25
22215: PUSH
22216: LD_INT 2
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PPUSH
22223: CALL_OW 72
22227: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22228: LD_ADDR_VAR 0 7
22232: PUSH
22233: LD_EXP 50
22237: PUSH
22238: LD_VAR 0 1
22242: ARRAY
22243: PPUSH
22244: LD_INT 25
22246: PUSH
22247: LD_INT 3
22249: PUSH
22250: EMPTY
22251: LIST
22252: LIST
22253: PPUSH
22254: CALL_OW 72
22258: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22259: LD_ADDR_VAR 0 8
22263: PUSH
22264: LD_EXP 50
22268: PUSH
22269: LD_VAR 0 1
22273: ARRAY
22274: PPUSH
22275: LD_INT 25
22277: PUSH
22278: LD_INT 4
22280: PUSH
22281: EMPTY
22282: LIST
22283: LIST
22284: PUSH
22285: LD_INT 24
22287: PUSH
22288: LD_INT 251
22290: PUSH
22291: EMPTY
22292: LIST
22293: LIST
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PPUSH
22299: CALL_OW 72
22303: ST_TO_ADDR
// if mc_scan [ base ] then
22304: LD_EXP 73
22308: PUSH
22309: LD_VAR 0 1
22313: ARRAY
22314: IFFALSE 22775
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22316: LD_ADDR_EXP 92
22320: PUSH
22321: LD_EXP 92
22325: PPUSH
22326: LD_VAR 0 1
22330: PPUSH
22331: LD_INT 4
22333: PPUSH
22334: CALL_OW 1
22338: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22339: LD_ADDR_VAR 0 12
22343: PUSH
22344: LD_EXP 50
22348: PUSH
22349: LD_VAR 0 1
22353: ARRAY
22354: PPUSH
22355: LD_INT 2
22357: PUSH
22358: LD_INT 30
22360: PUSH
22361: LD_INT 4
22363: PUSH
22364: EMPTY
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 30
22370: PUSH
22371: LD_INT 5
22373: PUSH
22374: EMPTY
22375: LIST
22376: LIST
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: LIST
22382: PPUSH
22383: CALL_OW 72
22387: ST_TO_ADDR
// if not b then
22388: LD_VAR 0 12
22392: NOT
22393: IFFALSE 22397
// exit ;
22395: GO 25463
// p := [ ] ;
22397: LD_ADDR_VAR 0 11
22401: PUSH
22402: EMPTY
22403: ST_TO_ADDR
// if sci >= 2 then
22404: LD_VAR 0 8
22408: PUSH
22409: LD_INT 2
22411: GREATEREQUAL
22412: IFFALSE 22443
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22414: LD_ADDR_VAR 0 8
22418: PUSH
22419: LD_VAR 0 8
22423: PUSH
22424: LD_INT 1
22426: ARRAY
22427: PUSH
22428: LD_VAR 0 8
22432: PUSH
22433: LD_INT 2
22435: ARRAY
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: ST_TO_ADDR
22441: GO 22504
// if sci = 1 then
22443: LD_VAR 0 8
22447: PUSH
22448: LD_INT 1
22450: EQUAL
22451: IFFALSE 22472
// sci := [ sci [ 1 ] ] else
22453: LD_ADDR_VAR 0 8
22457: PUSH
22458: LD_VAR 0 8
22462: PUSH
22463: LD_INT 1
22465: ARRAY
22466: PUSH
22467: EMPTY
22468: LIST
22469: ST_TO_ADDR
22470: GO 22504
// if sci = 0 then
22472: LD_VAR 0 8
22476: PUSH
22477: LD_INT 0
22479: EQUAL
22480: IFFALSE 22504
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22482: LD_ADDR_VAR 0 11
22486: PUSH
22487: LD_VAR 0 4
22491: PPUSH
22492: LD_INT 4
22494: PPUSH
22495: CALL 88750 0 2
22499: PUSH
22500: LD_INT 1
22502: ARRAY
22503: ST_TO_ADDR
// if eng > 4 then
22504: LD_VAR 0 6
22508: PUSH
22509: LD_INT 4
22511: GREATER
22512: IFFALSE 22558
// for i = eng downto 4 do
22514: LD_ADDR_VAR 0 3
22518: PUSH
22519: DOUBLE
22520: LD_VAR 0 6
22524: INC
22525: ST_TO_ADDR
22526: LD_INT 4
22528: PUSH
22529: FOR_DOWNTO
22530: IFFALSE 22556
// eng := eng diff eng [ i ] ;
22532: LD_ADDR_VAR 0 6
22536: PUSH
22537: LD_VAR 0 6
22541: PUSH
22542: LD_VAR 0 6
22546: PUSH
22547: LD_VAR 0 3
22551: ARRAY
22552: DIFF
22553: ST_TO_ADDR
22554: GO 22529
22556: POP
22557: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22558: LD_ADDR_VAR 0 4
22562: PUSH
22563: LD_VAR 0 4
22567: PUSH
22568: LD_VAR 0 5
22572: PUSH
22573: LD_VAR 0 6
22577: UNION
22578: PUSH
22579: LD_VAR 0 7
22583: UNION
22584: PUSH
22585: LD_VAR 0 8
22589: UNION
22590: DIFF
22591: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22592: LD_ADDR_VAR 0 13
22596: PUSH
22597: LD_EXP 50
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PPUSH
22608: LD_INT 2
22610: PUSH
22611: LD_INT 30
22613: PUSH
22614: LD_INT 32
22616: PUSH
22617: EMPTY
22618: LIST
22619: LIST
22620: PUSH
22621: LD_INT 30
22623: PUSH
22624: LD_INT 31
22626: PUSH
22627: EMPTY
22628: LIST
22629: LIST
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: LIST
22635: PPUSH
22636: CALL_OW 72
22640: PUSH
22641: LD_EXP 50
22645: PUSH
22646: LD_VAR 0 1
22650: ARRAY
22651: PPUSH
22652: LD_INT 2
22654: PUSH
22655: LD_INT 30
22657: PUSH
22658: LD_INT 4
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 30
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: PPUSH
22680: CALL_OW 72
22684: PUSH
22685: LD_INT 6
22687: MUL
22688: PLUS
22689: ST_TO_ADDR
// if bcount < tmp then
22690: LD_VAR 0 13
22694: PUSH
22695: LD_VAR 0 4
22699: LESS
22700: IFFALSE 22746
// for i = tmp downto bcount do
22702: LD_ADDR_VAR 0 3
22706: PUSH
22707: DOUBLE
22708: LD_VAR 0 4
22712: INC
22713: ST_TO_ADDR
22714: LD_VAR 0 13
22718: PUSH
22719: FOR_DOWNTO
22720: IFFALSE 22744
// tmp := Delete ( tmp , tmp ) ;
22722: LD_ADDR_VAR 0 4
22726: PUSH
22727: LD_VAR 0 4
22731: PPUSH
22732: LD_VAR 0 4
22736: PPUSH
22737: CALL_OW 3
22741: ST_TO_ADDR
22742: GO 22719
22744: POP
22745: POP
// result := [ tmp , 0 , 0 , p ] ;
22746: LD_ADDR_VAR 0 2
22750: PUSH
22751: LD_VAR 0 4
22755: PUSH
22756: LD_INT 0
22758: PUSH
22759: LD_INT 0
22761: PUSH
22762: LD_VAR 0 11
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: ST_TO_ADDR
// exit ;
22773: GO 25463
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22775: LD_EXP 50
22779: PUSH
22780: LD_VAR 0 1
22784: ARRAY
22785: PPUSH
22786: LD_INT 2
22788: PUSH
22789: LD_INT 30
22791: PUSH
22792: LD_INT 6
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: PUSH
22799: LD_INT 30
22801: PUSH
22802: LD_INT 7
22804: PUSH
22805: EMPTY
22806: LIST
22807: LIST
22808: PUSH
22809: LD_INT 30
22811: PUSH
22812: LD_INT 8
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: PPUSH
22825: CALL_OW 72
22829: NOT
22830: PUSH
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 1
22840: ARRAY
22841: PPUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PPUSH
22852: CALL_OW 72
22856: NOT
22857: AND
22858: IFFALSE 22930
// begin if eng = tmp then
22860: LD_VAR 0 6
22864: PUSH
22865: LD_VAR 0 4
22869: EQUAL
22870: IFFALSE 22874
// exit ;
22872: GO 25463
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22874: LD_ADDR_EXP 92
22878: PUSH
22879: LD_EXP 92
22883: PPUSH
22884: LD_VAR 0 1
22888: PPUSH
22889: LD_INT 1
22891: PPUSH
22892: CALL_OW 1
22896: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22897: LD_ADDR_VAR 0 2
22901: PUSH
22902: LD_INT 0
22904: PUSH
22905: LD_VAR 0 4
22909: PUSH
22910: LD_VAR 0 6
22914: DIFF
22915: PUSH
22916: LD_INT 0
22918: PUSH
22919: LD_INT 0
22921: PUSH
22922: EMPTY
22923: LIST
22924: LIST
22925: LIST
22926: LIST
22927: ST_TO_ADDR
// exit ;
22928: GO 25463
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22930: LD_EXP 77
22934: PUSH
22935: LD_EXP 76
22939: PUSH
22940: LD_VAR 0 1
22944: ARRAY
22945: ARRAY
22946: PUSH
22947: LD_EXP 50
22951: PUSH
22952: LD_VAR 0 1
22956: ARRAY
22957: PPUSH
22958: LD_INT 2
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 6
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 30
22973: PUSH
22974: LD_INT 7
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: LD_INT 30
22983: PUSH
22984: LD_INT 8
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: LIST
22995: LIST
22996: PPUSH
22997: CALL_OW 72
23001: AND
23002: PUSH
23003: LD_EXP 50
23007: PUSH
23008: LD_VAR 0 1
23012: ARRAY
23013: PPUSH
23014: LD_INT 30
23016: PUSH
23017: LD_INT 3
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: PPUSH
23024: CALL_OW 72
23028: NOT
23029: AND
23030: IFFALSE 23244
// begin if sci >= 6 then
23032: LD_VAR 0 8
23036: PUSH
23037: LD_INT 6
23039: GREATEREQUAL
23040: IFFALSE 23044
// exit ;
23042: GO 25463
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23044: LD_ADDR_EXP 92
23048: PUSH
23049: LD_EXP 92
23053: PPUSH
23054: LD_VAR 0 1
23058: PPUSH
23059: LD_INT 2
23061: PPUSH
23062: CALL_OW 1
23066: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23067: LD_ADDR_VAR 0 9
23071: PUSH
23072: LD_VAR 0 4
23076: PUSH
23077: LD_VAR 0 8
23081: DIFF
23082: PPUSH
23083: LD_INT 4
23085: PPUSH
23086: CALL 88750 0 2
23090: ST_TO_ADDR
// p := [ ] ;
23091: LD_ADDR_VAR 0 11
23095: PUSH
23096: EMPTY
23097: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23098: LD_VAR 0 8
23102: PUSH
23103: LD_INT 6
23105: LESS
23106: PUSH
23107: LD_VAR 0 9
23111: PUSH
23112: LD_INT 6
23114: GREATER
23115: AND
23116: IFFALSE 23197
// begin for i = 1 to 6 - sci do
23118: LD_ADDR_VAR 0 3
23122: PUSH
23123: DOUBLE
23124: LD_INT 1
23126: DEC
23127: ST_TO_ADDR
23128: LD_INT 6
23130: PUSH
23131: LD_VAR 0 8
23135: MINUS
23136: PUSH
23137: FOR_TO
23138: IFFALSE 23193
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23140: LD_ADDR_VAR 0 11
23144: PUSH
23145: LD_VAR 0 11
23149: PPUSH
23150: LD_VAR 0 11
23154: PUSH
23155: LD_INT 1
23157: PLUS
23158: PPUSH
23159: LD_VAR 0 9
23163: PUSH
23164: LD_INT 1
23166: ARRAY
23167: PPUSH
23168: CALL_OW 2
23172: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23173: LD_ADDR_VAR 0 9
23177: PUSH
23178: LD_VAR 0 9
23182: PPUSH
23183: LD_INT 1
23185: PPUSH
23186: CALL_OW 3
23190: ST_TO_ADDR
// end ;
23191: GO 23137
23193: POP
23194: POP
// end else
23195: GO 23217
// if sort then
23197: LD_VAR 0 9
23201: IFFALSE 23217
// p := sort [ 1 ] ;
23203: LD_ADDR_VAR 0 11
23207: PUSH
23208: LD_VAR 0 9
23212: PUSH
23213: LD_INT 1
23215: ARRAY
23216: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23217: LD_ADDR_VAR 0 2
23221: PUSH
23222: LD_INT 0
23224: PUSH
23225: LD_INT 0
23227: PUSH
23228: LD_INT 0
23230: PUSH
23231: LD_VAR 0 11
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: ST_TO_ADDR
// exit ;
23242: GO 25463
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23244: LD_EXP 77
23248: PUSH
23249: LD_EXP 76
23253: PUSH
23254: LD_VAR 0 1
23258: ARRAY
23259: ARRAY
23260: PUSH
23261: LD_EXP 50
23265: PUSH
23266: LD_VAR 0 1
23270: ARRAY
23271: PPUSH
23272: LD_INT 2
23274: PUSH
23275: LD_INT 30
23277: PUSH
23278: LD_INT 6
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: PUSH
23285: LD_INT 30
23287: PUSH
23288: LD_INT 7
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 30
23297: PUSH
23298: LD_INT 8
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: LIST
23309: LIST
23310: PPUSH
23311: CALL_OW 72
23315: AND
23316: PUSH
23317: LD_EXP 50
23321: PUSH
23322: LD_VAR 0 1
23326: ARRAY
23327: PPUSH
23328: LD_INT 30
23330: PUSH
23331: LD_INT 3
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: AND
23343: IFFALSE 24077
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23345: LD_ADDR_EXP 92
23349: PUSH
23350: LD_EXP 92
23354: PPUSH
23355: LD_VAR 0 1
23359: PPUSH
23360: LD_INT 3
23362: PPUSH
23363: CALL_OW 1
23367: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23368: LD_ADDR_VAR 0 2
23372: PUSH
23373: LD_INT 0
23375: PUSH
23376: LD_INT 0
23378: PUSH
23379: LD_INT 0
23381: PUSH
23382: LD_INT 0
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: ST_TO_ADDR
// if not eng then
23391: LD_VAR 0 6
23395: NOT
23396: IFFALSE 23459
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23398: LD_ADDR_VAR 0 11
23402: PUSH
23403: LD_VAR 0 4
23407: PPUSH
23408: LD_INT 2
23410: PPUSH
23411: CALL 88750 0 2
23415: PUSH
23416: LD_INT 1
23418: ARRAY
23419: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23420: LD_ADDR_VAR 0 2
23424: PUSH
23425: LD_VAR 0 2
23429: PPUSH
23430: LD_INT 2
23432: PPUSH
23433: LD_VAR 0 11
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// tmp := tmp diff p ;
23443: LD_ADDR_VAR 0 4
23447: PUSH
23448: LD_VAR 0 4
23452: PUSH
23453: LD_VAR 0 11
23457: DIFF
23458: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23459: LD_VAR 0 4
23463: PUSH
23464: LD_VAR 0 8
23468: PUSH
23469: LD_INT 6
23471: LESS
23472: AND
23473: IFFALSE 23661
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23475: LD_ADDR_VAR 0 9
23479: PUSH
23480: LD_VAR 0 4
23484: PUSH
23485: LD_VAR 0 8
23489: PUSH
23490: LD_VAR 0 7
23494: UNION
23495: DIFF
23496: PPUSH
23497: LD_INT 4
23499: PPUSH
23500: CALL 88750 0 2
23504: ST_TO_ADDR
// p := [ ] ;
23505: LD_ADDR_VAR 0 11
23509: PUSH
23510: EMPTY
23511: ST_TO_ADDR
// if sort then
23512: LD_VAR 0 9
23516: IFFALSE 23632
// for i = 1 to 6 - sci do
23518: LD_ADDR_VAR 0 3
23522: PUSH
23523: DOUBLE
23524: LD_INT 1
23526: DEC
23527: ST_TO_ADDR
23528: LD_INT 6
23530: PUSH
23531: LD_VAR 0 8
23535: MINUS
23536: PUSH
23537: FOR_TO
23538: IFFALSE 23630
// begin if i = sort then
23540: LD_VAR 0 3
23544: PUSH
23545: LD_VAR 0 9
23549: EQUAL
23550: IFFALSE 23554
// break ;
23552: GO 23630
// if GetClass ( i ) = 4 then
23554: LD_VAR 0 3
23558: PPUSH
23559: CALL_OW 257
23563: PUSH
23564: LD_INT 4
23566: EQUAL
23567: IFFALSE 23571
// continue ;
23569: GO 23537
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23571: LD_ADDR_VAR 0 11
23575: PUSH
23576: LD_VAR 0 11
23580: PPUSH
23581: LD_VAR 0 11
23585: PUSH
23586: LD_INT 1
23588: PLUS
23589: PPUSH
23590: LD_VAR 0 9
23594: PUSH
23595: LD_VAR 0 3
23599: ARRAY
23600: PPUSH
23601: CALL_OW 2
23605: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23606: LD_ADDR_VAR 0 4
23610: PUSH
23611: LD_VAR 0 4
23615: PUSH
23616: LD_VAR 0 9
23620: PUSH
23621: LD_VAR 0 3
23625: ARRAY
23626: DIFF
23627: ST_TO_ADDR
// end ;
23628: GO 23537
23630: POP
23631: POP
// if p then
23632: LD_VAR 0 11
23636: IFFALSE 23661
// result := Replace ( result , 4 , p ) ;
23638: LD_ADDR_VAR 0 2
23642: PUSH
23643: LD_VAR 0 2
23647: PPUSH
23648: LD_INT 4
23650: PPUSH
23651: LD_VAR 0 11
23655: PPUSH
23656: CALL_OW 1
23660: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23661: LD_VAR 0 4
23665: PUSH
23666: LD_VAR 0 7
23670: PUSH
23671: LD_INT 6
23673: LESS
23674: AND
23675: IFFALSE 23863
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23677: LD_ADDR_VAR 0 9
23681: PUSH
23682: LD_VAR 0 4
23686: PUSH
23687: LD_VAR 0 8
23691: PUSH
23692: LD_VAR 0 7
23696: UNION
23697: DIFF
23698: PPUSH
23699: LD_INT 3
23701: PPUSH
23702: CALL 88750 0 2
23706: ST_TO_ADDR
// p := [ ] ;
23707: LD_ADDR_VAR 0 11
23711: PUSH
23712: EMPTY
23713: ST_TO_ADDR
// if sort then
23714: LD_VAR 0 9
23718: IFFALSE 23834
// for i = 1 to 6 - mech do
23720: LD_ADDR_VAR 0 3
23724: PUSH
23725: DOUBLE
23726: LD_INT 1
23728: DEC
23729: ST_TO_ADDR
23730: LD_INT 6
23732: PUSH
23733: LD_VAR 0 7
23737: MINUS
23738: PUSH
23739: FOR_TO
23740: IFFALSE 23832
// begin if i = sort then
23742: LD_VAR 0 3
23746: PUSH
23747: LD_VAR 0 9
23751: EQUAL
23752: IFFALSE 23756
// break ;
23754: GO 23832
// if GetClass ( i ) = 3 then
23756: LD_VAR 0 3
23760: PPUSH
23761: CALL_OW 257
23765: PUSH
23766: LD_INT 3
23768: EQUAL
23769: IFFALSE 23773
// continue ;
23771: GO 23739
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23773: LD_ADDR_VAR 0 11
23777: PUSH
23778: LD_VAR 0 11
23782: PPUSH
23783: LD_VAR 0 11
23787: PUSH
23788: LD_INT 1
23790: PLUS
23791: PPUSH
23792: LD_VAR 0 9
23796: PUSH
23797: LD_VAR 0 3
23801: ARRAY
23802: PPUSH
23803: CALL_OW 2
23807: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23808: LD_ADDR_VAR 0 4
23812: PUSH
23813: LD_VAR 0 4
23817: PUSH
23818: LD_VAR 0 9
23822: PUSH
23823: LD_VAR 0 3
23827: ARRAY
23828: DIFF
23829: ST_TO_ADDR
// end ;
23830: GO 23739
23832: POP
23833: POP
// if p then
23834: LD_VAR 0 11
23838: IFFALSE 23863
// result := Replace ( result , 3 , p ) ;
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 2
23849: PPUSH
23850: LD_INT 3
23852: PPUSH
23853: LD_VAR 0 11
23857: PPUSH
23858: CALL_OW 1
23862: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23863: LD_VAR 0 4
23867: PUSH
23868: LD_INT 6
23870: GREATER
23871: PUSH
23872: LD_VAR 0 6
23876: PUSH
23877: LD_INT 6
23879: LESS
23880: AND
23881: IFFALSE 24075
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23883: LD_ADDR_VAR 0 9
23887: PUSH
23888: LD_VAR 0 4
23892: PUSH
23893: LD_VAR 0 8
23897: PUSH
23898: LD_VAR 0 7
23902: UNION
23903: PUSH
23904: LD_VAR 0 6
23908: UNION
23909: DIFF
23910: PPUSH
23911: LD_INT 2
23913: PPUSH
23914: CALL 88750 0 2
23918: ST_TO_ADDR
// p := [ ] ;
23919: LD_ADDR_VAR 0 11
23923: PUSH
23924: EMPTY
23925: ST_TO_ADDR
// if sort then
23926: LD_VAR 0 9
23930: IFFALSE 24046
// for i = 1 to 6 - eng do
23932: LD_ADDR_VAR 0 3
23936: PUSH
23937: DOUBLE
23938: LD_INT 1
23940: DEC
23941: ST_TO_ADDR
23942: LD_INT 6
23944: PUSH
23945: LD_VAR 0 6
23949: MINUS
23950: PUSH
23951: FOR_TO
23952: IFFALSE 24044
// begin if i = sort then
23954: LD_VAR 0 3
23958: PUSH
23959: LD_VAR 0 9
23963: EQUAL
23964: IFFALSE 23968
// break ;
23966: GO 24044
// if GetClass ( i ) = 2 then
23968: LD_VAR 0 3
23972: PPUSH
23973: CALL_OW 257
23977: PUSH
23978: LD_INT 2
23980: EQUAL
23981: IFFALSE 23985
// continue ;
23983: GO 23951
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23985: LD_ADDR_VAR 0 11
23989: PUSH
23990: LD_VAR 0 11
23994: PPUSH
23995: LD_VAR 0 11
23999: PUSH
24000: LD_INT 1
24002: PLUS
24003: PPUSH
24004: LD_VAR 0 9
24008: PUSH
24009: LD_VAR 0 3
24013: ARRAY
24014: PPUSH
24015: CALL_OW 2
24019: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24020: LD_ADDR_VAR 0 4
24024: PUSH
24025: LD_VAR 0 4
24029: PUSH
24030: LD_VAR 0 9
24034: PUSH
24035: LD_VAR 0 3
24039: ARRAY
24040: DIFF
24041: ST_TO_ADDR
// end ;
24042: GO 23951
24044: POP
24045: POP
// if p then
24046: LD_VAR 0 11
24050: IFFALSE 24075
// result := Replace ( result , 2 , p ) ;
24052: LD_ADDR_VAR 0 2
24056: PUSH
24057: LD_VAR 0 2
24061: PPUSH
24062: LD_INT 2
24064: PPUSH
24065: LD_VAR 0 11
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// end ; exit ;
24075: GO 25463
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24077: LD_EXP 77
24081: PUSH
24082: LD_EXP 76
24086: PUSH
24087: LD_VAR 0 1
24091: ARRAY
24092: ARRAY
24093: NOT
24094: PUSH
24095: LD_EXP 50
24099: PUSH
24100: LD_VAR 0 1
24104: ARRAY
24105: PPUSH
24106: LD_INT 30
24108: PUSH
24109: LD_INT 3
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: PPUSH
24116: CALL_OW 72
24120: AND
24121: PUSH
24122: LD_EXP 55
24126: PUSH
24127: LD_VAR 0 1
24131: ARRAY
24132: AND
24133: IFFALSE 24741
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24135: LD_ADDR_EXP 92
24139: PUSH
24140: LD_EXP 92
24144: PPUSH
24145: LD_VAR 0 1
24149: PPUSH
24150: LD_INT 5
24152: PPUSH
24153: CALL_OW 1
24157: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24158: LD_ADDR_VAR 0 2
24162: PUSH
24163: LD_INT 0
24165: PUSH
24166: LD_INT 0
24168: PUSH
24169: LD_INT 0
24171: PUSH
24172: LD_INT 0
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: ST_TO_ADDR
// if sci > 1 then
24181: LD_VAR 0 8
24185: PUSH
24186: LD_INT 1
24188: GREATER
24189: IFFALSE 24217
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24191: LD_ADDR_VAR 0 4
24195: PUSH
24196: LD_VAR 0 4
24200: PUSH
24201: LD_VAR 0 8
24205: PUSH
24206: LD_VAR 0 8
24210: PUSH
24211: LD_INT 1
24213: ARRAY
24214: DIFF
24215: DIFF
24216: ST_TO_ADDR
// if tmp and not sci then
24217: LD_VAR 0 4
24221: PUSH
24222: LD_VAR 0 8
24226: NOT
24227: AND
24228: IFFALSE 24297
// begin sort := SortBySkill ( tmp , 4 ) ;
24230: LD_ADDR_VAR 0 9
24234: PUSH
24235: LD_VAR 0 4
24239: PPUSH
24240: LD_INT 4
24242: PPUSH
24243: CALL 88750 0 2
24247: ST_TO_ADDR
// if sort then
24248: LD_VAR 0 9
24252: IFFALSE 24268
// p := sort [ 1 ] ;
24254: LD_ADDR_VAR 0 11
24258: PUSH
24259: LD_VAR 0 9
24263: PUSH
24264: LD_INT 1
24266: ARRAY
24267: ST_TO_ADDR
// if p then
24268: LD_VAR 0 11
24272: IFFALSE 24297
// result := Replace ( result , 4 , p ) ;
24274: LD_ADDR_VAR 0 2
24278: PUSH
24279: LD_VAR 0 2
24283: PPUSH
24284: LD_INT 4
24286: PPUSH
24287: LD_VAR 0 11
24291: PPUSH
24292: CALL_OW 1
24296: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24297: LD_ADDR_VAR 0 4
24301: PUSH
24302: LD_VAR 0 4
24306: PUSH
24307: LD_VAR 0 7
24311: DIFF
24312: ST_TO_ADDR
// if tmp and mech < 6 then
24313: LD_VAR 0 4
24317: PUSH
24318: LD_VAR 0 7
24322: PUSH
24323: LD_INT 6
24325: LESS
24326: AND
24327: IFFALSE 24515
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24329: LD_ADDR_VAR 0 9
24333: PUSH
24334: LD_VAR 0 4
24338: PUSH
24339: LD_VAR 0 8
24343: PUSH
24344: LD_VAR 0 7
24348: UNION
24349: DIFF
24350: PPUSH
24351: LD_INT 3
24353: PPUSH
24354: CALL 88750 0 2
24358: ST_TO_ADDR
// p := [ ] ;
24359: LD_ADDR_VAR 0 11
24363: PUSH
24364: EMPTY
24365: ST_TO_ADDR
// if sort then
24366: LD_VAR 0 9
24370: IFFALSE 24486
// for i = 1 to 6 - mech do
24372: LD_ADDR_VAR 0 3
24376: PUSH
24377: DOUBLE
24378: LD_INT 1
24380: DEC
24381: ST_TO_ADDR
24382: LD_INT 6
24384: PUSH
24385: LD_VAR 0 7
24389: MINUS
24390: PUSH
24391: FOR_TO
24392: IFFALSE 24484
// begin if i = sort then
24394: LD_VAR 0 3
24398: PUSH
24399: LD_VAR 0 9
24403: EQUAL
24404: IFFALSE 24408
// break ;
24406: GO 24484
// if GetClass ( i ) = 3 then
24408: LD_VAR 0 3
24412: PPUSH
24413: CALL_OW 257
24417: PUSH
24418: LD_INT 3
24420: EQUAL
24421: IFFALSE 24425
// continue ;
24423: GO 24391
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24425: LD_ADDR_VAR 0 11
24429: PUSH
24430: LD_VAR 0 11
24434: PPUSH
24435: LD_VAR 0 11
24439: PUSH
24440: LD_INT 1
24442: PLUS
24443: PPUSH
24444: LD_VAR 0 9
24448: PUSH
24449: LD_VAR 0 3
24453: ARRAY
24454: PPUSH
24455: CALL_OW 2
24459: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24460: LD_ADDR_VAR 0 4
24464: PUSH
24465: LD_VAR 0 4
24469: PUSH
24470: LD_VAR 0 9
24474: PUSH
24475: LD_VAR 0 3
24479: ARRAY
24480: DIFF
24481: ST_TO_ADDR
// end ;
24482: GO 24391
24484: POP
24485: POP
// if p then
24486: LD_VAR 0 11
24490: IFFALSE 24515
// result := Replace ( result , 3 , p ) ;
24492: LD_ADDR_VAR 0 2
24496: PUSH
24497: LD_VAR 0 2
24501: PPUSH
24502: LD_INT 3
24504: PPUSH
24505: LD_VAR 0 11
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24515: LD_ADDR_VAR 0 4
24519: PUSH
24520: LD_VAR 0 4
24524: PUSH
24525: LD_VAR 0 6
24529: DIFF
24530: ST_TO_ADDR
// if tmp and eng < 6 then
24531: LD_VAR 0 4
24535: PUSH
24536: LD_VAR 0 6
24540: PUSH
24541: LD_INT 6
24543: LESS
24544: AND
24545: IFFALSE 24739
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24547: LD_ADDR_VAR 0 9
24551: PUSH
24552: LD_VAR 0 4
24556: PUSH
24557: LD_VAR 0 8
24561: PUSH
24562: LD_VAR 0 7
24566: UNION
24567: PUSH
24568: LD_VAR 0 6
24572: UNION
24573: DIFF
24574: PPUSH
24575: LD_INT 2
24577: PPUSH
24578: CALL 88750 0 2
24582: ST_TO_ADDR
// p := [ ] ;
24583: LD_ADDR_VAR 0 11
24587: PUSH
24588: EMPTY
24589: ST_TO_ADDR
// if sort then
24590: LD_VAR 0 9
24594: IFFALSE 24710
// for i = 1 to 6 - eng do
24596: LD_ADDR_VAR 0 3
24600: PUSH
24601: DOUBLE
24602: LD_INT 1
24604: DEC
24605: ST_TO_ADDR
24606: LD_INT 6
24608: PUSH
24609: LD_VAR 0 6
24613: MINUS
24614: PUSH
24615: FOR_TO
24616: IFFALSE 24708
// begin if i = sort then
24618: LD_VAR 0 3
24622: PUSH
24623: LD_VAR 0 9
24627: EQUAL
24628: IFFALSE 24632
// break ;
24630: GO 24708
// if GetClass ( i ) = 2 then
24632: LD_VAR 0 3
24636: PPUSH
24637: CALL_OW 257
24641: PUSH
24642: LD_INT 2
24644: EQUAL
24645: IFFALSE 24649
// continue ;
24647: GO 24615
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24649: LD_ADDR_VAR 0 11
24653: PUSH
24654: LD_VAR 0 11
24658: PPUSH
24659: LD_VAR 0 11
24663: PUSH
24664: LD_INT 1
24666: PLUS
24667: PPUSH
24668: LD_VAR 0 9
24672: PUSH
24673: LD_VAR 0 3
24677: ARRAY
24678: PPUSH
24679: CALL_OW 2
24683: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24684: LD_ADDR_VAR 0 4
24688: PUSH
24689: LD_VAR 0 4
24693: PUSH
24694: LD_VAR 0 9
24698: PUSH
24699: LD_VAR 0 3
24703: ARRAY
24704: DIFF
24705: ST_TO_ADDR
// end ;
24706: GO 24615
24708: POP
24709: POP
// if p then
24710: LD_VAR 0 11
24714: IFFALSE 24739
// result := Replace ( result , 2 , p ) ;
24716: LD_ADDR_VAR 0 2
24720: PUSH
24721: LD_VAR 0 2
24725: PPUSH
24726: LD_INT 2
24728: PPUSH
24729: LD_VAR 0 11
24733: PPUSH
24734: CALL_OW 1
24738: ST_TO_ADDR
// end ; exit ;
24739: GO 25463
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24741: LD_EXP 77
24745: PUSH
24746: LD_EXP 76
24750: PUSH
24751: LD_VAR 0 1
24755: ARRAY
24756: ARRAY
24757: NOT
24758: PUSH
24759: LD_EXP 50
24763: PUSH
24764: LD_VAR 0 1
24768: ARRAY
24769: PPUSH
24770: LD_INT 30
24772: PUSH
24773: LD_INT 3
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PPUSH
24780: CALL_OW 72
24784: AND
24785: PUSH
24786: LD_EXP 55
24790: PUSH
24791: LD_VAR 0 1
24795: ARRAY
24796: NOT
24797: AND
24798: IFFALSE 25463
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24800: LD_ADDR_EXP 92
24804: PUSH
24805: LD_EXP 92
24809: PPUSH
24810: LD_VAR 0 1
24814: PPUSH
24815: LD_INT 6
24817: PPUSH
24818: CALL_OW 1
24822: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24823: LD_ADDR_VAR 0 2
24827: PUSH
24828: LD_INT 0
24830: PUSH
24831: LD_INT 0
24833: PUSH
24834: LD_INT 0
24836: PUSH
24837: LD_INT 0
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: LIST
24844: LIST
24845: ST_TO_ADDR
// if sci >= 1 then
24846: LD_VAR 0 8
24850: PUSH
24851: LD_INT 1
24853: GREATEREQUAL
24854: IFFALSE 24876
// tmp := tmp diff sci [ 1 ] ;
24856: LD_ADDR_VAR 0 4
24860: PUSH
24861: LD_VAR 0 4
24865: PUSH
24866: LD_VAR 0 8
24870: PUSH
24871: LD_INT 1
24873: ARRAY
24874: DIFF
24875: ST_TO_ADDR
// if tmp and not sci then
24876: LD_VAR 0 4
24880: PUSH
24881: LD_VAR 0 8
24885: NOT
24886: AND
24887: IFFALSE 24956
// begin sort := SortBySkill ( tmp , 4 ) ;
24889: LD_ADDR_VAR 0 9
24893: PUSH
24894: LD_VAR 0 4
24898: PPUSH
24899: LD_INT 4
24901: PPUSH
24902: CALL 88750 0 2
24906: ST_TO_ADDR
// if sort then
24907: LD_VAR 0 9
24911: IFFALSE 24927
// p := sort [ 1 ] ;
24913: LD_ADDR_VAR 0 11
24917: PUSH
24918: LD_VAR 0 9
24922: PUSH
24923: LD_INT 1
24925: ARRAY
24926: ST_TO_ADDR
// if p then
24927: LD_VAR 0 11
24931: IFFALSE 24956
// result := Replace ( result , 4 , p ) ;
24933: LD_ADDR_VAR 0 2
24937: PUSH
24938: LD_VAR 0 2
24942: PPUSH
24943: LD_INT 4
24945: PPUSH
24946: LD_VAR 0 11
24950: PPUSH
24951: CALL_OW 1
24955: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: LD_VAR 0 4
24965: PUSH
24966: LD_VAR 0 7
24970: DIFF
24971: ST_TO_ADDR
// if tmp and mech < 6 then
24972: LD_VAR 0 4
24976: PUSH
24977: LD_VAR 0 7
24981: PUSH
24982: LD_INT 6
24984: LESS
24985: AND
24986: IFFALSE 25168
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24988: LD_ADDR_VAR 0 9
24992: PUSH
24993: LD_VAR 0 4
24997: PUSH
24998: LD_VAR 0 7
25002: DIFF
25003: PPUSH
25004: LD_INT 3
25006: PPUSH
25007: CALL 88750 0 2
25011: ST_TO_ADDR
// p := [ ] ;
25012: LD_ADDR_VAR 0 11
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// if sort then
25019: LD_VAR 0 9
25023: IFFALSE 25139
// for i = 1 to 6 - mech do
25025: LD_ADDR_VAR 0 3
25029: PUSH
25030: DOUBLE
25031: LD_INT 1
25033: DEC
25034: ST_TO_ADDR
25035: LD_INT 6
25037: PUSH
25038: LD_VAR 0 7
25042: MINUS
25043: PUSH
25044: FOR_TO
25045: IFFALSE 25137
// begin if i = sort then
25047: LD_VAR 0 3
25051: PUSH
25052: LD_VAR 0 9
25056: EQUAL
25057: IFFALSE 25061
// break ;
25059: GO 25137
// if GetClass ( i ) = 3 then
25061: LD_VAR 0 3
25065: PPUSH
25066: CALL_OW 257
25070: PUSH
25071: LD_INT 3
25073: EQUAL
25074: IFFALSE 25078
// continue ;
25076: GO 25044
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25078: LD_ADDR_VAR 0 11
25082: PUSH
25083: LD_VAR 0 11
25087: PPUSH
25088: LD_VAR 0 11
25092: PUSH
25093: LD_INT 1
25095: PLUS
25096: PPUSH
25097: LD_VAR 0 9
25101: PUSH
25102: LD_VAR 0 3
25106: ARRAY
25107: PPUSH
25108: CALL_OW 2
25112: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25113: LD_ADDR_VAR 0 4
25117: PUSH
25118: LD_VAR 0 4
25122: PUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_VAR 0 3
25132: ARRAY
25133: DIFF
25134: ST_TO_ADDR
// end ;
25135: GO 25044
25137: POP
25138: POP
// if p then
25139: LD_VAR 0 11
25143: IFFALSE 25168
// result := Replace ( result , 3 , p ) ;
25145: LD_ADDR_VAR 0 2
25149: PUSH
25150: LD_VAR 0 2
25154: PPUSH
25155: LD_INT 3
25157: PPUSH
25158: LD_VAR 0 11
25162: PPUSH
25163: CALL_OW 1
25167: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25168: LD_ADDR_VAR 0 4
25172: PUSH
25173: LD_VAR 0 4
25177: PUSH
25178: LD_VAR 0 6
25182: DIFF
25183: ST_TO_ADDR
// if tmp and eng < 4 then
25184: LD_VAR 0 4
25188: PUSH
25189: LD_VAR 0 6
25193: PUSH
25194: LD_INT 4
25196: LESS
25197: AND
25198: IFFALSE 25388
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25200: LD_ADDR_VAR 0 9
25204: PUSH
25205: LD_VAR 0 4
25209: PUSH
25210: LD_VAR 0 7
25214: PUSH
25215: LD_VAR 0 6
25219: UNION
25220: DIFF
25221: PPUSH
25222: LD_INT 2
25224: PPUSH
25225: CALL 88750 0 2
25229: ST_TO_ADDR
// p := [ ] ;
25230: LD_ADDR_VAR 0 11
25234: PUSH
25235: EMPTY
25236: ST_TO_ADDR
// if sort then
25237: LD_VAR 0 9
25241: IFFALSE 25357
// for i = 1 to 4 - eng do
25243: LD_ADDR_VAR 0 3
25247: PUSH
25248: DOUBLE
25249: LD_INT 1
25251: DEC
25252: ST_TO_ADDR
25253: LD_INT 4
25255: PUSH
25256: LD_VAR 0 6
25260: MINUS
25261: PUSH
25262: FOR_TO
25263: IFFALSE 25355
// begin if i = sort then
25265: LD_VAR 0 3
25269: PUSH
25270: LD_VAR 0 9
25274: EQUAL
25275: IFFALSE 25279
// break ;
25277: GO 25355
// if GetClass ( i ) = 2 then
25279: LD_VAR 0 3
25283: PPUSH
25284: CALL_OW 257
25288: PUSH
25289: LD_INT 2
25291: EQUAL
25292: IFFALSE 25296
// continue ;
25294: GO 25262
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25296: LD_ADDR_VAR 0 11
25300: PUSH
25301: LD_VAR 0 11
25305: PPUSH
25306: LD_VAR 0 11
25310: PUSH
25311: LD_INT 1
25313: PLUS
25314: PPUSH
25315: LD_VAR 0 9
25319: PUSH
25320: LD_VAR 0 3
25324: ARRAY
25325: PPUSH
25326: CALL_OW 2
25330: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25331: LD_ADDR_VAR 0 4
25335: PUSH
25336: LD_VAR 0 4
25340: PUSH
25341: LD_VAR 0 9
25345: PUSH
25346: LD_VAR 0 3
25350: ARRAY
25351: DIFF
25352: ST_TO_ADDR
// end ;
25353: GO 25262
25355: POP
25356: POP
// if p then
25357: LD_VAR 0 11
25361: IFFALSE 25386
// result := Replace ( result , 2 , p ) ;
25363: LD_ADDR_VAR 0 2
25367: PUSH
25368: LD_VAR 0 2
25372: PPUSH
25373: LD_INT 2
25375: PPUSH
25376: LD_VAR 0 11
25380: PPUSH
25381: CALL_OW 1
25385: ST_TO_ADDR
// end else
25386: GO 25432
// for i = eng downto 5 do
25388: LD_ADDR_VAR 0 3
25392: PUSH
25393: DOUBLE
25394: LD_VAR 0 6
25398: INC
25399: ST_TO_ADDR
25400: LD_INT 5
25402: PUSH
25403: FOR_DOWNTO
25404: IFFALSE 25430
// tmp := tmp union eng [ i ] ;
25406: LD_ADDR_VAR 0 4
25410: PUSH
25411: LD_VAR 0 4
25415: PUSH
25416: LD_VAR 0 6
25420: PUSH
25421: LD_VAR 0 3
25425: ARRAY
25426: UNION
25427: ST_TO_ADDR
25428: GO 25403
25430: POP
25431: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25432: LD_ADDR_VAR 0 2
25436: PUSH
25437: LD_VAR 0 2
25441: PPUSH
25442: LD_INT 1
25444: PPUSH
25445: LD_VAR 0 4
25449: PUSH
25450: LD_VAR 0 5
25454: DIFF
25455: PPUSH
25456: CALL_OW 1
25460: ST_TO_ADDR
// exit ;
25461: GO 25463
// end ; end ;
25463: LD_VAR 0 2
25467: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25468: LD_INT 0
25470: PPUSH
25471: PPUSH
25472: PPUSH
// if not mc_bases then
25473: LD_EXP 50
25477: NOT
25478: IFFALSE 25482
// exit ;
25480: GO 25588
// for i = 1 to mc_bases do
25482: LD_ADDR_VAR 0 2
25486: PUSH
25487: DOUBLE
25488: LD_INT 1
25490: DEC
25491: ST_TO_ADDR
25492: LD_EXP 50
25496: PUSH
25497: FOR_TO
25498: IFFALSE 25579
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25500: LD_ADDR_VAR 0 3
25504: PUSH
25505: LD_EXP 50
25509: PUSH
25510: LD_VAR 0 2
25514: ARRAY
25515: PPUSH
25516: LD_INT 21
25518: PUSH
25519: LD_INT 3
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 3
25528: PUSH
25529: LD_INT 24
25531: PUSH
25532: LD_INT 1000
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PPUSH
25547: CALL_OW 72
25551: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25552: LD_ADDR_EXP 51
25556: PUSH
25557: LD_EXP 51
25561: PPUSH
25562: LD_VAR 0 2
25566: PPUSH
25567: LD_VAR 0 3
25571: PPUSH
25572: CALL_OW 1
25576: ST_TO_ADDR
// end ;
25577: GO 25497
25579: POP
25580: POP
// RaiseSailEvent ( 101 ) ;
25581: LD_INT 101
25583: PPUSH
25584: CALL_OW 427
// end ;
25588: LD_VAR 0 1
25592: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25593: LD_INT 0
25595: PPUSH
25596: PPUSH
25597: PPUSH
25598: PPUSH
25599: PPUSH
25600: PPUSH
25601: PPUSH
// if not mc_bases then
25602: LD_EXP 50
25606: NOT
25607: IFFALSE 25611
// exit ;
25609: GO 26184
// for i = 1 to mc_bases do
25611: LD_ADDR_VAR 0 2
25615: PUSH
25616: DOUBLE
25617: LD_INT 1
25619: DEC
25620: ST_TO_ADDR
25621: LD_EXP 50
25625: PUSH
25626: FOR_TO
25627: IFFALSE 26175
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25629: LD_ADDR_VAR 0 5
25633: PUSH
25634: LD_EXP 50
25638: PUSH
25639: LD_VAR 0 2
25643: ARRAY
25644: PUSH
25645: LD_EXP 79
25649: PUSH
25650: LD_VAR 0 2
25654: ARRAY
25655: UNION
25656: PPUSH
25657: LD_INT 21
25659: PUSH
25660: LD_INT 1
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PUSH
25667: LD_INT 1
25669: PUSH
25670: LD_INT 3
25672: PUSH
25673: LD_INT 54
25675: PUSH
25676: EMPTY
25677: LIST
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 3
25685: PUSH
25686: LD_INT 24
25688: PUSH
25689: LD_INT 800
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: LIST
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PPUSH
25709: CALL_OW 72
25713: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25714: LD_ADDR_VAR 0 6
25718: PUSH
25719: LD_EXP 50
25723: PUSH
25724: LD_VAR 0 2
25728: ARRAY
25729: PPUSH
25730: LD_INT 21
25732: PUSH
25733: LD_INT 1
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: LD_INT 1
25742: PUSH
25743: LD_INT 3
25745: PUSH
25746: LD_INT 54
25748: PUSH
25749: EMPTY
25750: LIST
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 3
25758: PUSH
25759: LD_INT 24
25761: PUSH
25762: LD_INT 250
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: LIST
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PPUSH
25782: CALL_OW 72
25786: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25787: LD_ADDR_VAR 0 7
25791: PUSH
25792: LD_VAR 0 5
25796: PUSH
25797: LD_VAR 0 6
25801: DIFF
25802: ST_TO_ADDR
// if not need_heal_1 then
25803: LD_VAR 0 6
25807: NOT
25808: IFFALSE 25841
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25810: LD_ADDR_EXP 53
25814: PUSH
25815: LD_EXP 53
25819: PPUSH
25820: LD_VAR 0 2
25824: PUSH
25825: LD_INT 1
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PPUSH
25832: EMPTY
25833: PPUSH
25834: CALL 54499 0 3
25838: ST_TO_ADDR
25839: GO 25911
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25841: LD_ADDR_EXP 53
25845: PUSH
25846: LD_EXP 53
25850: PPUSH
25851: LD_VAR 0 2
25855: PUSH
25856: LD_INT 1
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PPUSH
25863: LD_EXP 53
25867: PUSH
25868: LD_VAR 0 2
25872: ARRAY
25873: PUSH
25874: LD_INT 1
25876: ARRAY
25877: PPUSH
25878: LD_INT 3
25880: PUSH
25881: LD_INT 24
25883: PUSH
25884: LD_INT 1000
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PPUSH
25895: CALL_OW 72
25899: PUSH
25900: LD_VAR 0 6
25904: UNION
25905: PPUSH
25906: CALL 54499 0 3
25910: ST_TO_ADDR
// if not need_heal_2 then
25911: LD_VAR 0 7
25915: NOT
25916: IFFALSE 25949
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25918: LD_ADDR_EXP 53
25922: PUSH
25923: LD_EXP 53
25927: PPUSH
25928: LD_VAR 0 2
25932: PUSH
25933: LD_INT 2
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PPUSH
25940: EMPTY
25941: PPUSH
25942: CALL 54499 0 3
25946: ST_TO_ADDR
25947: GO 25981
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25949: LD_ADDR_EXP 53
25953: PUSH
25954: LD_EXP 53
25958: PPUSH
25959: LD_VAR 0 2
25963: PUSH
25964: LD_INT 2
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: PPUSH
25971: LD_VAR 0 7
25975: PPUSH
25976: CALL 54499 0 3
25980: ST_TO_ADDR
// if need_heal_2 then
25981: LD_VAR 0 7
25985: IFFALSE 26157
// for j in need_heal_2 do
25987: LD_ADDR_VAR 0 3
25991: PUSH
25992: LD_VAR 0 7
25996: PUSH
25997: FOR_IN
25998: IFFALSE 26155
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
26000: LD_ADDR_VAR 0 5
26004: PUSH
26005: LD_EXP 50
26009: PUSH
26010: LD_VAR 0 2
26014: ARRAY
26015: PPUSH
26016: LD_INT 2
26018: PUSH
26019: LD_INT 30
26021: PUSH
26022: LD_INT 6
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 30
26031: PUSH
26032: LD_INT 7
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 30
26041: PUSH
26042: LD_INT 8
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: LD_INT 30
26051: PUSH
26052: LD_INT 0
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PUSH
26059: LD_INT 30
26061: PUSH
26062: LD_INT 1
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 25
26071: PUSH
26072: LD_INT 4
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: LIST
26086: LIST
26087: PPUSH
26088: CALL_OW 72
26092: ST_TO_ADDR
// if tmp then
26093: LD_VAR 0 5
26097: IFFALSE 26153
// begin k := NearestUnitToUnit ( tmp , j ) ;
26099: LD_ADDR_VAR 0 4
26103: PUSH
26104: LD_VAR 0 5
26108: PPUSH
26109: LD_VAR 0 3
26113: PPUSH
26114: CALL_OW 74
26118: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
26119: LD_VAR 0 3
26123: PPUSH
26124: LD_VAR 0 4
26128: PPUSH
26129: CALL_OW 296
26133: PUSH
26134: LD_INT 7
26136: GREATER
26137: IFFALSE 26153
// ComMoveUnit ( j , k ) ;
26139: LD_VAR 0 3
26143: PPUSH
26144: LD_VAR 0 4
26148: PPUSH
26149: CALL_OW 112
// end ; end ;
26153: GO 25997
26155: POP
26156: POP
// if not need_heal_1 and not need_heal_2 then
26157: LD_VAR 0 6
26161: NOT
26162: PUSH
26163: LD_VAR 0 7
26167: NOT
26168: AND
26169: IFFALSE 26173
// continue ;
26171: GO 25626
// end ;
26173: GO 25626
26175: POP
26176: POP
// RaiseSailEvent ( 102 ) ;
26177: LD_INT 102
26179: PPUSH
26180: CALL_OW 427
// end ;
26184: LD_VAR 0 1
26188: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26189: LD_INT 0
26191: PPUSH
26192: PPUSH
26193: PPUSH
26194: PPUSH
26195: PPUSH
26196: PPUSH
26197: PPUSH
26198: PPUSH
// if not mc_bases then
26199: LD_EXP 50
26203: NOT
26204: IFFALSE 26208
// exit ;
26206: GO 27048
// for i = 1 to mc_bases do
26208: LD_ADDR_VAR 0 2
26212: PUSH
26213: DOUBLE
26214: LD_INT 1
26216: DEC
26217: ST_TO_ADDR
26218: LD_EXP 50
26222: PUSH
26223: FOR_TO
26224: IFFALSE 27046
// begin if not mc_building_need_repair [ i ] then
26226: LD_EXP 51
26230: PUSH
26231: LD_VAR 0 2
26235: ARRAY
26236: NOT
26237: IFFALSE 26411
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26239: LD_ADDR_VAR 0 6
26243: PUSH
26244: LD_EXP 69
26248: PUSH
26249: LD_VAR 0 2
26253: ARRAY
26254: PPUSH
26255: LD_INT 3
26257: PUSH
26258: LD_INT 24
26260: PUSH
26261: LD_INT 1000
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 2
26274: PUSH
26275: LD_INT 34
26277: PUSH
26278: LD_INT 13
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: PUSH
26285: LD_INT 34
26287: PUSH
26288: LD_INT 52
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: PPUSH
26304: CALL_OW 72
26308: ST_TO_ADDR
// if cranes then
26309: LD_VAR 0 6
26313: IFFALSE 26375
// for j in cranes do
26315: LD_ADDR_VAR 0 3
26319: PUSH
26320: LD_VAR 0 6
26324: PUSH
26325: FOR_IN
26326: IFFALSE 26373
// if not IsInArea ( j , mc_parking [ i ] ) then
26328: LD_VAR 0 3
26332: PPUSH
26333: LD_EXP 74
26337: PUSH
26338: LD_VAR 0 2
26342: ARRAY
26343: PPUSH
26344: CALL_OW 308
26348: NOT
26349: IFFALSE 26371
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26351: LD_VAR 0 3
26355: PPUSH
26356: LD_EXP 74
26360: PUSH
26361: LD_VAR 0 2
26365: ARRAY
26366: PPUSH
26367: CALL_OW 113
26371: GO 26325
26373: POP
26374: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26375: LD_ADDR_EXP 52
26379: PUSH
26380: LD_EXP 52
26384: PPUSH
26385: LD_VAR 0 2
26389: PPUSH
26390: EMPTY
26391: PPUSH
26392: CALL_OW 1
26396: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26397: LD_VAR 0 2
26401: PPUSH
26402: LD_INT 101
26404: PPUSH
26405: CALL 21301 0 2
// continue ;
26409: GO 26223
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26411: LD_ADDR_EXP 56
26415: PUSH
26416: LD_EXP 56
26420: PPUSH
26421: LD_VAR 0 2
26425: PPUSH
26426: EMPTY
26427: PPUSH
26428: CALL_OW 1
26432: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26433: LD_VAR 0 2
26437: PPUSH
26438: LD_INT 103
26440: PPUSH
26441: CALL 21301 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26445: LD_ADDR_VAR 0 5
26449: PUSH
26450: LD_EXP 50
26454: PUSH
26455: LD_VAR 0 2
26459: ARRAY
26460: PUSH
26461: LD_EXP 79
26465: PUSH
26466: LD_VAR 0 2
26470: ARRAY
26471: UNION
26472: PPUSH
26473: LD_INT 2
26475: PUSH
26476: LD_INT 25
26478: PUSH
26479: LD_INT 2
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 25
26488: PUSH
26489: LD_INT 16
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: LIST
26500: PUSH
26501: EMPTY
26502: LIST
26503: PPUSH
26504: CALL_OW 72
26508: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26509: LD_ADDR_VAR 0 6
26513: PUSH
26514: LD_EXP 69
26518: PUSH
26519: LD_VAR 0 2
26523: ARRAY
26524: PPUSH
26525: LD_INT 2
26527: PUSH
26528: LD_INT 34
26530: PUSH
26531: LD_INT 13
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: LD_INT 34
26540: PUSH
26541: LD_INT 52
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: LIST
26552: PPUSH
26553: CALL_OW 72
26557: ST_TO_ADDR
// if cranes then
26558: LD_VAR 0 6
26562: IFFALSE 26698
// begin for j in cranes do
26564: LD_ADDR_VAR 0 3
26568: PUSH
26569: LD_VAR 0 6
26573: PUSH
26574: FOR_IN
26575: IFFALSE 26696
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26577: LD_VAR 0 3
26581: PPUSH
26582: CALL_OW 256
26586: PUSH
26587: LD_INT 500
26589: GREATEREQUAL
26590: PUSH
26591: LD_VAR 0 3
26595: PPUSH
26596: CALL_OW 314
26600: NOT
26601: AND
26602: IFFALSE 26636
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26604: LD_VAR 0 3
26608: PPUSH
26609: LD_EXP 51
26613: PUSH
26614: LD_VAR 0 2
26618: ARRAY
26619: PPUSH
26620: LD_VAR 0 3
26624: PPUSH
26625: CALL_OW 74
26629: PPUSH
26630: CALL_OW 130
26634: GO 26694
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 256
26645: PUSH
26646: LD_INT 500
26648: LESS
26649: PUSH
26650: LD_VAR 0 3
26654: PPUSH
26655: LD_EXP 74
26659: PUSH
26660: LD_VAR 0 2
26664: ARRAY
26665: PPUSH
26666: CALL_OW 308
26670: NOT
26671: AND
26672: IFFALSE 26694
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26674: LD_VAR 0 3
26678: PPUSH
26679: LD_EXP 74
26683: PUSH
26684: LD_VAR 0 2
26688: ARRAY
26689: PPUSH
26690: CALL_OW 113
26694: GO 26574
26696: POP
26697: POP
// end ; if not tmp then
26698: LD_VAR 0 5
26702: NOT
26703: IFFALSE 26707
// continue ;
26705: GO 26223
// for j in tmp do
26707: LD_ADDR_VAR 0 3
26711: PUSH
26712: LD_VAR 0 5
26716: PUSH
26717: FOR_IN
26718: IFFALSE 27042
// begin if mc_need_heal [ i ] then
26720: LD_EXP 53
26724: PUSH
26725: LD_VAR 0 2
26729: ARRAY
26730: IFFALSE 26778
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26732: LD_VAR 0 3
26736: PUSH
26737: LD_EXP 53
26741: PUSH
26742: LD_VAR 0 2
26746: ARRAY
26747: PUSH
26748: LD_INT 1
26750: ARRAY
26751: IN
26752: PUSH
26753: LD_VAR 0 3
26757: PUSH
26758: LD_EXP 53
26762: PUSH
26763: LD_VAR 0 2
26767: ARRAY
26768: PUSH
26769: LD_INT 2
26771: ARRAY
26772: IN
26773: OR
26774: IFFALSE 26778
// continue ;
26776: GO 26717
// if IsInUnit ( j ) then
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL_OW 310
26787: IFFALSE 26798
// ComExitBuilding ( j ) ;
26789: LD_VAR 0 3
26793: PPUSH
26794: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26798: LD_VAR 0 3
26802: PUSH
26803: LD_EXP 52
26807: PUSH
26808: LD_VAR 0 2
26812: ARRAY
26813: IN
26814: NOT
26815: IFFALSE 26873
// begin SetTag ( j , 101 ) ;
26817: LD_VAR 0 3
26821: PPUSH
26822: LD_INT 101
26824: PPUSH
26825: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26829: LD_ADDR_EXP 52
26833: PUSH
26834: LD_EXP 52
26838: PPUSH
26839: LD_VAR 0 2
26843: PUSH
26844: LD_EXP 52
26848: PUSH
26849: LD_VAR 0 2
26853: ARRAY
26854: PUSH
26855: LD_INT 1
26857: PLUS
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: PPUSH
26863: LD_VAR 0 3
26867: PPUSH
26868: CALL 54499 0 3
26872: ST_TO_ADDR
// end ; wait ( 1 ) ;
26873: LD_INT 1
26875: PPUSH
26876: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
26880: LD_ADDR_VAR 0 7
26884: PUSH
26885: LD_EXP 51
26889: PUSH
26890: LD_VAR 0 2
26894: ARRAY
26895: ST_TO_ADDR
// if mc_scan [ i ] then
26896: LD_EXP 73
26900: PUSH
26901: LD_VAR 0 2
26905: ARRAY
26906: IFFALSE 26975
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
26908: LD_ADDR_VAR 0 7
26912: PUSH
26913: LD_EXP 51
26917: PUSH
26918: LD_VAR 0 2
26922: ARRAY
26923: PPUSH
26924: LD_INT 3
26926: PUSH
26927: LD_INT 2
26929: PUSH
26930: LD_INT 30
26932: PUSH
26933: LD_INT 32
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 30
26942: PUSH
26943: LD_INT 33
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 31
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PPUSH
26970: CALL_OW 72
26974: ST_TO_ADDR
// if not to_repair_tmp then
26975: LD_VAR 0 7
26979: NOT
26980: IFFALSE 26984
// continue ;
26982: GO 26717
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
26984: LD_ADDR_VAR 0 8
26988: PUSH
26989: LD_VAR 0 7
26993: PPUSH
26994: LD_VAR 0 3
26998: PPUSH
26999: CALL_OW 74
27003: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
27004: LD_VAR 0 8
27008: PPUSH
27009: LD_INT 14
27011: PPUSH
27012: CALL 57092 0 2
27016: PUSH
27017: LD_INT 4
27019: ARRAY
27020: PUSH
27021: LD_INT 5
27023: LESS
27024: IFFALSE 27040
// ComRepairBuilding ( j , to_repair ) ;
27026: LD_VAR 0 3
27030: PPUSH
27031: LD_VAR 0 8
27035: PPUSH
27036: CALL_OW 130
// end ;
27040: GO 26717
27042: POP
27043: POP
// end ;
27044: GO 26223
27046: POP
27047: POP
// end ;
27048: LD_VAR 0 1
27052: RET
// export function MC_Heal ; var i , j , tmp ; begin
27053: LD_INT 0
27055: PPUSH
27056: PPUSH
27057: PPUSH
27058: PPUSH
// if not mc_bases then
27059: LD_EXP 50
27063: NOT
27064: IFFALSE 27068
// exit ;
27066: GO 27470
// for i = 1 to mc_bases do
27068: LD_ADDR_VAR 0 2
27072: PUSH
27073: DOUBLE
27074: LD_INT 1
27076: DEC
27077: ST_TO_ADDR
27078: LD_EXP 50
27082: PUSH
27083: FOR_TO
27084: IFFALSE 27468
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27086: LD_EXP 53
27090: PUSH
27091: LD_VAR 0 2
27095: ARRAY
27096: PUSH
27097: LD_INT 1
27099: ARRAY
27100: NOT
27101: PUSH
27102: LD_EXP 53
27106: PUSH
27107: LD_VAR 0 2
27111: ARRAY
27112: PUSH
27113: LD_INT 2
27115: ARRAY
27116: NOT
27117: AND
27118: IFFALSE 27156
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27120: LD_ADDR_EXP 54
27124: PUSH
27125: LD_EXP 54
27129: PPUSH
27130: LD_VAR 0 2
27134: PPUSH
27135: EMPTY
27136: PPUSH
27137: CALL_OW 1
27141: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27142: LD_VAR 0 2
27146: PPUSH
27147: LD_INT 102
27149: PPUSH
27150: CALL 21301 0 2
// continue ;
27154: GO 27083
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27156: LD_ADDR_VAR 0 4
27160: PUSH
27161: LD_EXP 50
27165: PUSH
27166: LD_VAR 0 2
27170: ARRAY
27171: PPUSH
27172: LD_INT 25
27174: PUSH
27175: LD_INT 4
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PPUSH
27182: CALL_OW 72
27186: ST_TO_ADDR
// if not tmp then
27187: LD_VAR 0 4
27191: NOT
27192: IFFALSE 27196
// continue ;
27194: GO 27083
// if mc_taming [ i ] then
27196: LD_EXP 81
27200: PUSH
27201: LD_VAR 0 2
27205: ARRAY
27206: IFFALSE 27230
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27208: LD_ADDR_EXP 81
27212: PUSH
27213: LD_EXP 81
27217: PPUSH
27218: LD_VAR 0 2
27222: PPUSH
27223: EMPTY
27224: PPUSH
27225: CALL_OW 1
27229: ST_TO_ADDR
// for j in tmp do
27230: LD_ADDR_VAR 0 3
27234: PUSH
27235: LD_VAR 0 4
27239: PUSH
27240: FOR_IN
27241: IFFALSE 27464
// begin if IsInUnit ( j ) then
27243: LD_VAR 0 3
27247: PPUSH
27248: CALL_OW 310
27252: IFFALSE 27263
// ComExitBuilding ( j ) ;
27254: LD_VAR 0 3
27258: PPUSH
27259: CALL_OW 122
// if not j in mc_healers [ i ] then
27263: LD_VAR 0 3
27267: PUSH
27268: LD_EXP 54
27272: PUSH
27273: LD_VAR 0 2
27277: ARRAY
27278: IN
27279: NOT
27280: IFFALSE 27326
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27282: LD_ADDR_EXP 54
27286: PUSH
27287: LD_EXP 54
27291: PPUSH
27292: LD_VAR 0 2
27296: PUSH
27297: LD_EXP 54
27301: PUSH
27302: LD_VAR 0 2
27306: ARRAY
27307: PUSH
27308: LD_INT 1
27310: PLUS
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PPUSH
27316: LD_VAR 0 3
27320: PPUSH
27321: CALL 54499 0 3
27325: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27326: LD_VAR 0 3
27330: PPUSH
27331: CALL_OW 110
27335: PUSH
27336: LD_INT 102
27338: NONEQUAL
27339: IFFALSE 27353
// SetTag ( j , 102 ) ;
27341: LD_VAR 0 3
27345: PPUSH
27346: LD_INT 102
27348: PPUSH
27349: CALL_OW 109
// Wait ( 3 ) ;
27353: LD_INT 3
27355: PPUSH
27356: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27360: LD_EXP 53
27364: PUSH
27365: LD_VAR 0 2
27369: ARRAY
27370: PUSH
27371: LD_INT 1
27373: ARRAY
27374: IFFALSE 27406
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27376: LD_VAR 0 3
27380: PPUSH
27381: LD_EXP 53
27385: PUSH
27386: LD_VAR 0 2
27390: ARRAY
27391: PUSH
27392: LD_INT 1
27394: ARRAY
27395: PUSH
27396: LD_INT 1
27398: ARRAY
27399: PPUSH
27400: CALL_OW 128
27404: GO 27462
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27406: LD_VAR 0 3
27410: PPUSH
27411: CALL_OW 314
27415: NOT
27416: PUSH
27417: LD_EXP 53
27421: PUSH
27422: LD_VAR 0 2
27426: ARRAY
27427: PUSH
27428: LD_INT 2
27430: ARRAY
27431: AND
27432: IFFALSE 27462
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27434: LD_VAR 0 3
27438: PPUSH
27439: LD_EXP 53
27443: PUSH
27444: LD_VAR 0 2
27448: ARRAY
27449: PUSH
27450: LD_INT 2
27452: ARRAY
27453: PUSH
27454: LD_INT 1
27456: ARRAY
27457: PPUSH
27458: CALL_OW 128
// end ;
27462: GO 27240
27464: POP
27465: POP
// end ;
27466: GO 27083
27468: POP
27469: POP
// end ;
27470: LD_VAR 0 1
27474: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27475: LD_INT 0
27477: PPUSH
27478: PPUSH
27479: PPUSH
27480: PPUSH
27481: PPUSH
// if not mc_bases then
27482: LD_EXP 50
27486: NOT
27487: IFFALSE 27491
// exit ;
27489: GO 28634
// for i = 1 to mc_bases do
27491: LD_ADDR_VAR 0 2
27495: PUSH
27496: DOUBLE
27497: LD_INT 1
27499: DEC
27500: ST_TO_ADDR
27501: LD_EXP 50
27505: PUSH
27506: FOR_TO
27507: IFFALSE 28632
// begin if mc_scan [ i ] then
27509: LD_EXP 73
27513: PUSH
27514: LD_VAR 0 2
27518: ARRAY
27519: IFFALSE 27523
// continue ;
27521: GO 27506
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27523: LD_EXP 55
27527: PUSH
27528: LD_VAR 0 2
27532: ARRAY
27533: NOT
27534: PUSH
27535: LD_EXP 57
27539: PUSH
27540: LD_VAR 0 2
27544: ARRAY
27545: NOT
27546: AND
27547: PUSH
27548: LD_EXP 56
27552: PUSH
27553: LD_VAR 0 2
27557: ARRAY
27558: AND
27559: IFFALSE 27597
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27561: LD_ADDR_EXP 56
27565: PUSH
27566: LD_EXP 56
27570: PPUSH
27571: LD_VAR 0 2
27575: PPUSH
27576: EMPTY
27577: PPUSH
27578: CALL_OW 1
27582: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27583: LD_VAR 0 2
27587: PPUSH
27588: LD_INT 103
27590: PPUSH
27591: CALL 21301 0 2
// continue ;
27595: GO 27506
// end ; if mc_construct_list [ i ] then
27597: LD_EXP 57
27601: PUSH
27602: LD_VAR 0 2
27606: ARRAY
27607: IFFALSE 27827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27609: LD_ADDR_VAR 0 4
27613: PUSH
27614: LD_EXP 50
27618: PUSH
27619: LD_VAR 0 2
27623: ARRAY
27624: PPUSH
27625: LD_INT 25
27627: PUSH
27628: LD_INT 2
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PPUSH
27635: CALL_OW 72
27639: PUSH
27640: LD_EXP 52
27644: PUSH
27645: LD_VAR 0 2
27649: ARRAY
27650: DIFF
27651: ST_TO_ADDR
// if not tmp then
27652: LD_VAR 0 4
27656: NOT
27657: IFFALSE 27661
// continue ;
27659: GO 27506
// for j in tmp do
27661: LD_ADDR_VAR 0 3
27665: PUSH
27666: LD_VAR 0 4
27670: PUSH
27671: FOR_IN
27672: IFFALSE 27823
// begin if not mc_builders [ i ] then
27674: LD_EXP 56
27678: PUSH
27679: LD_VAR 0 2
27683: ARRAY
27684: NOT
27685: IFFALSE 27743
// begin SetTag ( j , 103 ) ;
27687: LD_VAR 0 3
27691: PPUSH
27692: LD_INT 103
27694: PPUSH
27695: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27699: LD_ADDR_EXP 56
27703: PUSH
27704: LD_EXP 56
27708: PPUSH
27709: LD_VAR 0 2
27713: PUSH
27714: LD_EXP 56
27718: PUSH
27719: LD_VAR 0 2
27723: ARRAY
27724: PUSH
27725: LD_INT 1
27727: PLUS
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: PPUSH
27733: LD_VAR 0 3
27737: PPUSH
27738: CALL 54499 0 3
27742: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27743: LD_VAR 0 3
27747: PPUSH
27748: CALL_OW 310
27752: IFFALSE 27763
// ComExitBuilding ( j ) ;
27754: LD_VAR 0 3
27758: PPUSH
27759: CALL_OW 122
// wait ( 3 ) ;
27763: LD_INT 3
27765: PPUSH
27766: CALL_OW 67
// if not mc_construct_list [ i ] then
27770: LD_EXP 57
27774: PUSH
27775: LD_VAR 0 2
27779: ARRAY
27780: NOT
27781: IFFALSE 27785
// break ;
27783: GO 27823
// if not HasTask ( j ) then
27785: LD_VAR 0 3
27789: PPUSH
27790: CALL_OW 314
27794: NOT
27795: IFFALSE 27821
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27797: LD_VAR 0 3
27801: PPUSH
27802: LD_EXP 57
27806: PUSH
27807: LD_VAR 0 2
27811: ARRAY
27812: PUSH
27813: LD_INT 1
27815: ARRAY
27816: PPUSH
27817: CALL 57350 0 2
// end ;
27821: GO 27671
27823: POP
27824: POP
// end else
27825: GO 28630
// if mc_build_list [ i ] then
27827: LD_EXP 55
27831: PUSH
27832: LD_VAR 0 2
27836: ARRAY
27837: IFFALSE 28630
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27839: LD_ADDR_VAR 0 5
27843: PUSH
27844: LD_EXP 50
27848: PUSH
27849: LD_VAR 0 2
27853: ARRAY
27854: PPUSH
27855: LD_INT 2
27857: PUSH
27858: LD_INT 30
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PUSH
27868: LD_INT 30
27870: PUSH
27871: LD_INT 1
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: LIST
27882: PPUSH
27883: CALL_OW 72
27887: ST_TO_ADDR
// if depot then
27888: LD_VAR 0 5
27892: IFFALSE 27910
// depot := depot [ 1 ] else
27894: LD_ADDR_VAR 0 5
27898: PUSH
27899: LD_VAR 0 5
27903: PUSH
27904: LD_INT 1
27906: ARRAY
27907: ST_TO_ADDR
27908: GO 27918
// depot := 0 ;
27910: LD_ADDR_VAR 0 5
27914: PUSH
27915: LD_INT 0
27917: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27918: LD_EXP 55
27922: PUSH
27923: LD_VAR 0 2
27927: ARRAY
27928: PUSH
27929: LD_INT 1
27931: ARRAY
27932: PUSH
27933: LD_INT 1
27935: ARRAY
27936: PPUSH
27937: CALL 57180 0 1
27941: PUSH
27942: LD_EXP 50
27946: PUSH
27947: LD_VAR 0 2
27951: ARRAY
27952: PPUSH
27953: LD_INT 2
27955: PUSH
27956: LD_INT 30
27958: PUSH
27959: LD_INT 2
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 30
27968: PUSH
27969: LD_INT 3
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: LIST
27980: PPUSH
27981: CALL_OW 72
27985: NOT
27986: AND
27987: IFFALSE 28092
// begin for j = 1 to mc_build_list [ i ] do
27989: LD_ADDR_VAR 0 3
27993: PUSH
27994: DOUBLE
27995: LD_INT 1
27997: DEC
27998: ST_TO_ADDR
27999: LD_EXP 55
28003: PUSH
28004: LD_VAR 0 2
28008: ARRAY
28009: PUSH
28010: FOR_TO
28011: IFFALSE 28090
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28013: LD_EXP 55
28017: PUSH
28018: LD_VAR 0 2
28022: ARRAY
28023: PUSH
28024: LD_VAR 0 3
28028: ARRAY
28029: PUSH
28030: LD_INT 1
28032: ARRAY
28033: PUSH
28034: LD_INT 2
28036: EQUAL
28037: IFFALSE 28088
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28039: LD_ADDR_EXP 55
28043: PUSH
28044: LD_EXP 55
28048: PPUSH
28049: LD_VAR 0 2
28053: PPUSH
28054: LD_EXP 55
28058: PUSH
28059: LD_VAR 0 2
28063: ARRAY
28064: PPUSH
28065: LD_VAR 0 3
28069: PPUSH
28070: LD_INT 1
28072: PPUSH
28073: LD_INT 0
28075: PPUSH
28076: CALL 53917 0 4
28080: PPUSH
28081: CALL_OW 1
28085: ST_TO_ADDR
// break ;
28086: GO 28090
// end ;
28088: GO 28010
28090: POP
28091: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28092: LD_EXP 55
28096: PUSH
28097: LD_VAR 0 2
28101: ARRAY
28102: PUSH
28103: LD_INT 1
28105: ARRAY
28106: PUSH
28107: LD_INT 1
28109: ARRAY
28110: PUSH
28111: LD_INT 0
28113: EQUAL
28114: PUSH
28115: LD_VAR 0 5
28119: PUSH
28120: LD_VAR 0 5
28124: PPUSH
28125: LD_EXP 55
28129: PUSH
28130: LD_VAR 0 2
28134: ARRAY
28135: PUSH
28136: LD_INT 1
28138: ARRAY
28139: PUSH
28140: LD_INT 1
28142: ARRAY
28143: PPUSH
28144: LD_EXP 55
28148: PUSH
28149: LD_VAR 0 2
28153: ARRAY
28154: PUSH
28155: LD_INT 1
28157: ARRAY
28158: PUSH
28159: LD_INT 2
28161: ARRAY
28162: PPUSH
28163: LD_EXP 55
28167: PUSH
28168: LD_VAR 0 2
28172: ARRAY
28173: PUSH
28174: LD_INT 1
28176: ARRAY
28177: PUSH
28178: LD_INT 3
28180: ARRAY
28181: PPUSH
28182: LD_EXP 55
28186: PUSH
28187: LD_VAR 0 2
28191: ARRAY
28192: PUSH
28193: LD_INT 1
28195: ARRAY
28196: PUSH
28197: LD_INT 4
28199: ARRAY
28200: PPUSH
28201: CALL 61914 0 5
28205: AND
28206: OR
28207: IFFALSE 28488
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28209: LD_ADDR_VAR 0 4
28213: PUSH
28214: LD_EXP 50
28218: PUSH
28219: LD_VAR 0 2
28223: ARRAY
28224: PPUSH
28225: LD_INT 25
28227: PUSH
28228: LD_INT 2
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PPUSH
28235: CALL_OW 72
28239: PUSH
28240: LD_EXP 52
28244: PUSH
28245: LD_VAR 0 2
28249: ARRAY
28250: DIFF
28251: ST_TO_ADDR
// if not tmp then
28252: LD_VAR 0 4
28256: NOT
28257: IFFALSE 28261
// continue ;
28259: GO 27506
// for j in tmp do
28261: LD_ADDR_VAR 0 3
28265: PUSH
28266: LD_VAR 0 4
28270: PUSH
28271: FOR_IN
28272: IFFALSE 28484
// begin if not mc_builders [ i ] then
28274: LD_EXP 56
28278: PUSH
28279: LD_VAR 0 2
28283: ARRAY
28284: NOT
28285: IFFALSE 28343
// begin SetTag ( j , 103 ) ;
28287: LD_VAR 0 3
28291: PPUSH
28292: LD_INT 103
28294: PPUSH
28295: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28299: LD_ADDR_EXP 56
28303: PUSH
28304: LD_EXP 56
28308: PPUSH
28309: LD_VAR 0 2
28313: PUSH
28314: LD_EXP 56
28318: PUSH
28319: LD_VAR 0 2
28323: ARRAY
28324: PUSH
28325: LD_INT 1
28327: PLUS
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PPUSH
28333: LD_VAR 0 3
28337: PPUSH
28338: CALL 54499 0 3
28342: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28343: LD_VAR 0 3
28347: PPUSH
28348: CALL_OW 310
28352: IFFALSE 28363
// ComExitBuilding ( j ) ;
28354: LD_VAR 0 3
28358: PPUSH
28359: CALL_OW 122
// wait ( 3 ) ;
28363: LD_INT 3
28365: PPUSH
28366: CALL_OW 67
// if not mc_build_list [ i ] then
28370: LD_EXP 55
28374: PUSH
28375: LD_VAR 0 2
28379: ARRAY
28380: NOT
28381: IFFALSE 28385
// break ;
28383: GO 28484
// if not HasTask ( j ) then
28385: LD_VAR 0 3
28389: PPUSH
28390: CALL_OW 314
28394: NOT
28395: IFFALSE 28482
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28397: LD_VAR 0 3
28401: PPUSH
28402: LD_EXP 55
28406: PUSH
28407: LD_VAR 0 2
28411: ARRAY
28412: PUSH
28413: LD_INT 1
28415: ARRAY
28416: PUSH
28417: LD_INT 1
28419: ARRAY
28420: PPUSH
28421: LD_EXP 55
28425: PUSH
28426: LD_VAR 0 2
28430: ARRAY
28431: PUSH
28432: LD_INT 1
28434: ARRAY
28435: PUSH
28436: LD_INT 2
28438: ARRAY
28439: PPUSH
28440: LD_EXP 55
28444: PUSH
28445: LD_VAR 0 2
28449: ARRAY
28450: PUSH
28451: LD_INT 1
28453: ARRAY
28454: PUSH
28455: LD_INT 3
28457: ARRAY
28458: PPUSH
28459: LD_EXP 55
28463: PUSH
28464: LD_VAR 0 2
28468: ARRAY
28469: PUSH
28470: LD_INT 1
28472: ARRAY
28473: PUSH
28474: LD_INT 4
28476: ARRAY
28477: PPUSH
28478: CALL_OW 145
// end ;
28482: GO 28271
28484: POP
28485: POP
// end else
28486: GO 28630
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28488: LD_EXP 50
28492: PUSH
28493: LD_VAR 0 2
28497: ARRAY
28498: PPUSH
28499: LD_EXP 55
28503: PUSH
28504: LD_VAR 0 2
28508: ARRAY
28509: PUSH
28510: LD_INT 1
28512: ARRAY
28513: PUSH
28514: LD_INT 1
28516: ARRAY
28517: PPUSH
28518: LD_EXP 55
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: PUSH
28529: LD_INT 1
28531: ARRAY
28532: PUSH
28533: LD_INT 2
28535: ARRAY
28536: PPUSH
28537: LD_EXP 55
28541: PUSH
28542: LD_VAR 0 2
28546: ARRAY
28547: PUSH
28548: LD_INT 1
28550: ARRAY
28551: PUSH
28552: LD_INT 3
28554: ARRAY
28555: PPUSH
28556: LD_EXP 55
28560: PUSH
28561: LD_VAR 0 2
28565: ARRAY
28566: PUSH
28567: LD_INT 1
28569: ARRAY
28570: PUSH
28571: LD_INT 4
28573: ARRAY
28574: PPUSH
28575: CALL 61250 0 5
28579: NOT
28580: IFFALSE 28630
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28582: LD_ADDR_EXP 55
28586: PUSH
28587: LD_EXP 55
28591: PPUSH
28592: LD_VAR 0 2
28596: PPUSH
28597: LD_EXP 55
28601: PUSH
28602: LD_VAR 0 2
28606: ARRAY
28607: PPUSH
28608: LD_INT 1
28610: PPUSH
28611: LD_INT 1
28613: NEG
28614: PPUSH
28615: LD_INT 0
28617: PPUSH
28618: CALL 53917 0 4
28622: PPUSH
28623: CALL_OW 1
28627: ST_TO_ADDR
// continue ;
28628: GO 27506
// end ; end ; end ;
28630: GO 27506
28632: POP
28633: POP
// end ;
28634: LD_VAR 0 1
28638: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28639: LD_INT 0
28641: PPUSH
28642: PPUSH
28643: PPUSH
28644: PPUSH
28645: PPUSH
28646: PPUSH
// if not mc_bases then
28647: LD_EXP 50
28651: NOT
28652: IFFALSE 28656
// exit ;
28654: GO 29083
// for i = 1 to mc_bases do
28656: LD_ADDR_VAR 0 2
28660: PUSH
28661: DOUBLE
28662: LD_INT 1
28664: DEC
28665: ST_TO_ADDR
28666: LD_EXP 50
28670: PUSH
28671: FOR_TO
28672: IFFALSE 29081
// begin tmp := mc_build_upgrade [ i ] ;
28674: LD_ADDR_VAR 0 4
28678: PUSH
28679: LD_EXP 82
28683: PUSH
28684: LD_VAR 0 2
28688: ARRAY
28689: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28690: LD_ADDR_VAR 0 6
28694: PUSH
28695: LD_EXP 83
28699: PUSH
28700: LD_VAR 0 2
28704: ARRAY
28705: PPUSH
28706: LD_INT 2
28708: PUSH
28709: LD_INT 30
28711: PUSH
28712: LD_INT 6
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 30
28721: PUSH
28722: LD_INT 7
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: LIST
28733: PPUSH
28734: CALL_OW 72
28738: ST_TO_ADDR
// if not tmp and not lab then
28739: LD_VAR 0 4
28743: NOT
28744: PUSH
28745: LD_VAR 0 6
28749: NOT
28750: AND
28751: IFFALSE 28755
// continue ;
28753: GO 28671
// if tmp then
28755: LD_VAR 0 4
28759: IFFALSE 28879
// for j in tmp do
28761: LD_ADDR_VAR 0 3
28765: PUSH
28766: LD_VAR 0 4
28770: PUSH
28771: FOR_IN
28772: IFFALSE 28877
// begin if UpgradeCost ( j ) then
28774: LD_VAR 0 3
28778: PPUSH
28779: CALL 60910 0 1
28783: IFFALSE 28875
// begin ComUpgrade ( j ) ;
28785: LD_VAR 0 3
28789: PPUSH
28790: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28794: LD_ADDR_EXP 82
28798: PUSH
28799: LD_EXP 82
28803: PPUSH
28804: LD_VAR 0 2
28808: PPUSH
28809: LD_EXP 82
28813: PUSH
28814: LD_VAR 0 2
28818: ARRAY
28819: PUSH
28820: LD_VAR 0 3
28824: DIFF
28825: PPUSH
28826: CALL_OW 1
28830: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28831: LD_ADDR_EXP 57
28835: PUSH
28836: LD_EXP 57
28840: PPUSH
28841: LD_VAR 0 2
28845: PUSH
28846: LD_EXP 57
28850: PUSH
28851: LD_VAR 0 2
28855: ARRAY
28856: PUSH
28857: LD_INT 1
28859: PLUS
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PPUSH
28865: LD_VAR 0 3
28869: PPUSH
28870: CALL 54499 0 3
28874: ST_TO_ADDR
// end ; end ;
28875: GO 28771
28877: POP
28878: POP
// if not lab or not mc_lab_upgrade [ i ] then
28879: LD_VAR 0 6
28883: NOT
28884: PUSH
28885: LD_EXP 84
28889: PUSH
28890: LD_VAR 0 2
28894: ARRAY
28895: NOT
28896: OR
28897: IFFALSE 28901
// continue ;
28899: GO 28671
// for j in lab do
28901: LD_ADDR_VAR 0 3
28905: PUSH
28906: LD_VAR 0 6
28910: PUSH
28911: FOR_IN
28912: IFFALSE 29077
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28914: LD_VAR 0 3
28918: PPUSH
28919: CALL_OW 266
28923: PUSH
28924: LD_INT 6
28926: PUSH
28927: LD_INT 7
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: IN
28934: PUSH
28935: LD_VAR 0 3
28939: PPUSH
28940: CALL_OW 461
28944: PUSH
28945: LD_INT 1
28947: NONEQUAL
28948: AND
28949: IFFALSE 29075
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28951: LD_VAR 0 3
28955: PPUSH
28956: LD_EXP 84
28960: PUSH
28961: LD_VAR 0 2
28965: ARRAY
28966: PUSH
28967: LD_INT 1
28969: ARRAY
28970: PPUSH
28971: CALL 61115 0 2
28975: IFFALSE 29075
// begin ComCancel ( j ) ;
28977: LD_VAR 0 3
28981: PPUSH
28982: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28986: LD_VAR 0 3
28990: PPUSH
28991: LD_EXP 84
28995: PUSH
28996: LD_VAR 0 2
29000: ARRAY
29001: PUSH
29002: LD_INT 1
29004: ARRAY
29005: PPUSH
29006: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29010: LD_VAR 0 3
29014: PUSH
29015: LD_EXP 57
29019: PUSH
29020: LD_VAR 0 2
29024: ARRAY
29025: IN
29026: NOT
29027: IFFALSE 29073
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29029: LD_ADDR_EXP 57
29033: PUSH
29034: LD_EXP 57
29038: PPUSH
29039: LD_VAR 0 2
29043: PUSH
29044: LD_EXP 57
29048: PUSH
29049: LD_VAR 0 2
29053: ARRAY
29054: PUSH
29055: LD_INT 1
29057: PLUS
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PPUSH
29063: LD_VAR 0 3
29067: PPUSH
29068: CALL 54499 0 3
29072: ST_TO_ADDR
// break ;
29073: GO 29077
// end ; end ; end ;
29075: GO 28911
29077: POP
29078: POP
// end ;
29079: GO 28671
29081: POP
29082: POP
// end ;
29083: LD_VAR 0 1
29087: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29088: LD_INT 0
29090: PPUSH
29091: PPUSH
29092: PPUSH
29093: PPUSH
29094: PPUSH
29095: PPUSH
29096: PPUSH
29097: PPUSH
29098: PPUSH
// if not mc_bases then
29099: LD_EXP 50
29103: NOT
29104: IFFALSE 29108
// exit ;
29106: GO 29513
// for i = 1 to mc_bases do
29108: LD_ADDR_VAR 0 2
29112: PUSH
29113: DOUBLE
29114: LD_INT 1
29116: DEC
29117: ST_TO_ADDR
29118: LD_EXP 50
29122: PUSH
29123: FOR_TO
29124: IFFALSE 29511
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29126: LD_EXP 58
29130: PUSH
29131: LD_VAR 0 2
29135: ARRAY
29136: NOT
29137: PUSH
29138: LD_EXP 50
29142: PUSH
29143: LD_VAR 0 2
29147: ARRAY
29148: PPUSH
29149: LD_INT 30
29151: PUSH
29152: LD_INT 3
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PPUSH
29159: CALL_OW 72
29163: NOT
29164: OR
29165: IFFALSE 29169
// continue ;
29167: GO 29123
// busy := false ;
29169: LD_ADDR_VAR 0 8
29173: PUSH
29174: LD_INT 0
29176: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29177: LD_ADDR_VAR 0 4
29181: PUSH
29182: LD_EXP 50
29186: PUSH
29187: LD_VAR 0 2
29191: ARRAY
29192: PPUSH
29193: LD_INT 30
29195: PUSH
29196: LD_INT 3
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PPUSH
29203: CALL_OW 72
29207: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29208: LD_ADDR_VAR 0 6
29212: PUSH
29213: LD_EXP 58
29217: PUSH
29218: LD_VAR 0 2
29222: ARRAY
29223: PPUSH
29224: LD_INT 2
29226: PUSH
29227: LD_INT 30
29229: PUSH
29230: LD_INT 32
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 30
29239: PUSH
29240: LD_INT 33
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 72
29256: ST_TO_ADDR
// if not t then
29257: LD_VAR 0 6
29261: NOT
29262: IFFALSE 29266
// continue ;
29264: GO 29123
// for j in tmp do
29266: LD_ADDR_VAR 0 3
29270: PUSH
29271: LD_VAR 0 4
29275: PUSH
29276: FOR_IN
29277: IFFALSE 29307
// if not BuildingStatus ( j ) = bs_idle then
29279: LD_VAR 0 3
29283: PPUSH
29284: CALL_OW 461
29288: PUSH
29289: LD_INT 2
29291: EQUAL
29292: NOT
29293: IFFALSE 29305
// begin busy := true ;
29295: LD_ADDR_VAR 0 8
29299: PUSH
29300: LD_INT 1
29302: ST_TO_ADDR
// break ;
29303: GO 29307
// end ;
29305: GO 29276
29307: POP
29308: POP
// if busy then
29309: LD_VAR 0 8
29313: IFFALSE 29317
// continue ;
29315: GO 29123
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29317: LD_ADDR_VAR 0 7
29321: PUSH
29322: LD_VAR 0 6
29326: PPUSH
29327: LD_INT 35
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// if tw then
29342: LD_VAR 0 7
29346: IFFALSE 29423
// begin tw := tw [ 1 ] ;
29348: LD_ADDR_VAR 0 7
29352: PUSH
29353: LD_VAR 0 7
29357: PUSH
29358: LD_INT 1
29360: ARRAY
29361: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29362: LD_ADDR_VAR 0 9
29366: PUSH
29367: LD_VAR 0 7
29371: PPUSH
29372: LD_EXP 75
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PPUSH
29383: CALL 59469 0 2
29387: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29388: LD_EXP 89
29392: PUSH
29393: LD_VAR 0 2
29397: ARRAY
29398: IFFALSE 29421
// if not weapon in mc_allowed_tower_weapons [ i ] then
29400: LD_VAR 0 9
29404: PUSH
29405: LD_EXP 89
29409: PUSH
29410: LD_VAR 0 2
29414: ARRAY
29415: IN
29416: NOT
29417: IFFALSE 29421
// continue ;
29419: GO 29123
// end else
29421: GO 29486
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29423: LD_ADDR_VAR 0 5
29427: PUSH
29428: LD_EXP 58
29432: PUSH
29433: LD_VAR 0 2
29437: ARRAY
29438: PPUSH
29439: LD_VAR 0 4
29443: PPUSH
29444: CALL 89673 0 2
29448: ST_TO_ADDR
// if not tmp2 then
29449: LD_VAR 0 5
29453: NOT
29454: IFFALSE 29458
// continue ;
29456: GO 29123
// tw := tmp2 [ 1 ] ;
29458: LD_ADDR_VAR 0 7
29462: PUSH
29463: LD_VAR 0 5
29467: PUSH
29468: LD_INT 1
29470: ARRAY
29471: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29472: LD_ADDR_VAR 0 9
29476: PUSH
29477: LD_VAR 0 5
29481: PUSH
29482: LD_INT 2
29484: ARRAY
29485: ST_TO_ADDR
// end ; if not weapon then
29486: LD_VAR 0 9
29490: NOT
29491: IFFALSE 29495
// continue ;
29493: GO 29123
// ComPlaceWeapon ( tw , weapon ) ;
29495: LD_VAR 0 7
29499: PPUSH
29500: LD_VAR 0 9
29504: PPUSH
29505: CALL_OW 148
// end ;
29509: GO 29123
29511: POP
29512: POP
// end ;
29513: LD_VAR 0 1
29517: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29518: LD_INT 0
29520: PPUSH
29521: PPUSH
29522: PPUSH
29523: PPUSH
29524: PPUSH
29525: PPUSH
// if not mc_bases then
29526: LD_EXP 50
29530: NOT
29531: IFFALSE 29535
// exit ;
29533: GO 30311
// for i = 1 to mc_bases do
29535: LD_ADDR_VAR 0 2
29539: PUSH
29540: DOUBLE
29541: LD_INT 1
29543: DEC
29544: ST_TO_ADDR
29545: LD_EXP 50
29549: PUSH
29550: FOR_TO
29551: IFFALSE 30309
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29553: LD_EXP 63
29557: PUSH
29558: LD_VAR 0 2
29562: ARRAY
29563: NOT
29564: PUSH
29565: LD_EXP 63
29569: PUSH
29570: LD_VAR 0 2
29574: ARRAY
29575: PUSH
29576: LD_EXP 64
29580: PUSH
29581: LD_VAR 0 2
29585: ARRAY
29586: EQUAL
29587: OR
29588: PUSH
29589: LD_EXP 73
29593: PUSH
29594: LD_VAR 0 2
29598: ARRAY
29599: OR
29600: IFFALSE 29604
// continue ;
29602: GO 29550
// if mc_miners [ i ] then
29604: LD_EXP 64
29608: PUSH
29609: LD_VAR 0 2
29613: ARRAY
29614: IFFALSE 29996
// begin for j = mc_miners [ i ] downto 1 do
29616: LD_ADDR_VAR 0 3
29620: PUSH
29621: DOUBLE
29622: LD_EXP 64
29626: PUSH
29627: LD_VAR 0 2
29631: ARRAY
29632: INC
29633: ST_TO_ADDR
29634: LD_INT 1
29636: PUSH
29637: FOR_DOWNTO
29638: IFFALSE 29994
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29640: LD_EXP 64
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: PUSH
29651: LD_VAR 0 3
29655: ARRAY
29656: PPUSH
29657: CALL_OW 301
29661: PUSH
29662: LD_EXP 64
29666: PUSH
29667: LD_VAR 0 2
29671: ARRAY
29672: PUSH
29673: LD_VAR 0 3
29677: ARRAY
29678: PPUSH
29679: CALL_OW 257
29683: PUSH
29684: LD_INT 1
29686: NONEQUAL
29687: OR
29688: IFFALSE 29751
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29690: LD_ADDR_VAR 0 5
29694: PUSH
29695: LD_EXP 64
29699: PUSH
29700: LD_VAR 0 2
29704: ARRAY
29705: PUSH
29706: LD_EXP 64
29710: PUSH
29711: LD_VAR 0 2
29715: ARRAY
29716: PUSH
29717: LD_VAR 0 3
29721: ARRAY
29722: DIFF
29723: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29724: LD_ADDR_EXP 64
29728: PUSH
29729: LD_EXP 64
29733: PPUSH
29734: LD_VAR 0 2
29738: PPUSH
29739: LD_VAR 0 5
29743: PPUSH
29744: CALL_OW 1
29748: ST_TO_ADDR
// continue ;
29749: GO 29637
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29751: LD_EXP 64
29755: PUSH
29756: LD_VAR 0 2
29760: ARRAY
29761: PUSH
29762: LD_VAR 0 3
29766: ARRAY
29767: PPUSH
29768: CALL_OW 257
29772: PUSH
29773: LD_INT 1
29775: EQUAL
29776: PUSH
29777: LD_EXP 64
29781: PUSH
29782: LD_VAR 0 2
29786: ARRAY
29787: PUSH
29788: LD_VAR 0 3
29792: ARRAY
29793: PPUSH
29794: CALL_OW 459
29798: NOT
29799: AND
29800: PUSH
29801: LD_EXP 64
29805: PUSH
29806: LD_VAR 0 2
29810: ARRAY
29811: PUSH
29812: LD_VAR 0 3
29816: ARRAY
29817: PPUSH
29818: CALL_OW 314
29822: NOT
29823: AND
29824: IFFALSE 29992
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29826: LD_EXP 64
29830: PUSH
29831: LD_VAR 0 2
29835: ARRAY
29836: PUSH
29837: LD_VAR 0 3
29841: ARRAY
29842: PPUSH
29843: CALL_OW 310
29847: IFFALSE 29870
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29849: LD_EXP 64
29853: PUSH
29854: LD_VAR 0 2
29858: ARRAY
29859: PUSH
29860: LD_VAR 0 3
29864: ARRAY
29865: PPUSH
29866: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29870: LD_EXP 64
29874: PUSH
29875: LD_VAR 0 2
29879: ARRAY
29880: PUSH
29881: LD_VAR 0 3
29885: ARRAY
29886: PPUSH
29887: CALL_OW 314
29891: NOT
29892: IFFALSE 29992
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
29894: LD_EXP 64
29898: PUSH
29899: LD_VAR 0 2
29903: ARRAY
29904: PUSH
29905: LD_VAR 0 3
29909: ARRAY
29910: PPUSH
29911: LD_EXP 63
29915: PUSH
29916: LD_VAR 0 2
29920: ARRAY
29921: PUSH
29922: LD_VAR 0 3
29926: PUSH
29927: LD_EXP 63
29931: PUSH
29932: LD_VAR 0 2
29936: ARRAY
29937: MOD
29938: PUSH
29939: LD_INT 1
29941: PLUS
29942: ARRAY
29943: PUSH
29944: LD_INT 1
29946: ARRAY
29947: PPUSH
29948: LD_EXP 63
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: PUSH
29959: LD_VAR 0 3
29963: PUSH
29964: LD_EXP 63
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: MOD
29975: PUSH
29976: LD_INT 1
29978: PLUS
29979: ARRAY
29980: PUSH
29981: LD_INT 2
29983: ARRAY
29984: PPUSH
29985: LD_INT 0
29987: PPUSH
29988: CALL_OW 193
// end ; end ;
29992: GO 29637
29994: POP
29995: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
29996: LD_ADDR_VAR 0 5
30000: PUSH
30001: LD_EXP 50
30005: PUSH
30006: LD_VAR 0 2
30010: ARRAY
30011: PPUSH
30012: LD_INT 2
30014: PUSH
30015: LD_INT 30
30017: PUSH
30018: LD_INT 4
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 30
30027: PUSH
30028: LD_INT 5
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 30
30037: PUSH
30038: LD_INT 32
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 72
30055: ST_TO_ADDR
// if not tmp then
30056: LD_VAR 0 5
30060: NOT
30061: IFFALSE 30065
// continue ;
30063: GO 29550
// list := [ ] ;
30065: LD_ADDR_VAR 0 6
30069: PUSH
30070: EMPTY
30071: ST_TO_ADDR
// for j in tmp do
30072: LD_ADDR_VAR 0 3
30076: PUSH
30077: LD_VAR 0 5
30081: PUSH
30082: FOR_IN
30083: IFFALSE 30152
// begin for k in UnitsInside ( j ) do
30085: LD_ADDR_VAR 0 4
30089: PUSH
30090: LD_VAR 0 3
30094: PPUSH
30095: CALL_OW 313
30099: PUSH
30100: FOR_IN
30101: IFFALSE 30148
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30103: LD_VAR 0 4
30107: PPUSH
30108: CALL_OW 257
30112: PUSH
30113: LD_INT 1
30115: EQUAL
30116: PUSH
30117: LD_VAR 0 4
30121: PPUSH
30122: CALL_OW 459
30126: NOT
30127: AND
30128: IFFALSE 30146
// list := list ^ k ;
30130: LD_ADDR_VAR 0 6
30134: PUSH
30135: LD_VAR 0 6
30139: PUSH
30140: LD_VAR 0 4
30144: ADD
30145: ST_TO_ADDR
30146: GO 30100
30148: POP
30149: POP
// end ;
30150: GO 30082
30152: POP
30153: POP
// list := list diff mc_miners [ i ] ;
30154: LD_ADDR_VAR 0 6
30158: PUSH
30159: LD_VAR 0 6
30163: PUSH
30164: LD_EXP 64
30168: PUSH
30169: LD_VAR 0 2
30173: ARRAY
30174: DIFF
30175: ST_TO_ADDR
// if not list then
30176: LD_VAR 0 6
30180: NOT
30181: IFFALSE 30185
// continue ;
30183: GO 29550
// k := mc_mines [ i ] - mc_miners [ i ] ;
30185: LD_ADDR_VAR 0 4
30189: PUSH
30190: LD_EXP 63
30194: PUSH
30195: LD_VAR 0 2
30199: ARRAY
30200: PUSH
30201: LD_EXP 64
30205: PUSH
30206: LD_VAR 0 2
30210: ARRAY
30211: MINUS
30212: ST_TO_ADDR
// if k > list then
30213: LD_VAR 0 4
30217: PUSH
30218: LD_VAR 0 6
30222: GREATER
30223: IFFALSE 30235
// k := list ;
30225: LD_ADDR_VAR 0 4
30229: PUSH
30230: LD_VAR 0 6
30234: ST_TO_ADDR
// for j = 1 to k do
30235: LD_ADDR_VAR 0 3
30239: PUSH
30240: DOUBLE
30241: LD_INT 1
30243: DEC
30244: ST_TO_ADDR
30245: LD_VAR 0 4
30249: PUSH
30250: FOR_TO
30251: IFFALSE 30305
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30253: LD_ADDR_EXP 64
30257: PUSH
30258: LD_EXP 64
30262: PPUSH
30263: LD_VAR 0 2
30267: PUSH
30268: LD_EXP 64
30272: PUSH
30273: LD_VAR 0 2
30277: ARRAY
30278: PUSH
30279: LD_INT 1
30281: PLUS
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PPUSH
30287: LD_VAR 0 6
30291: PUSH
30292: LD_VAR 0 3
30296: ARRAY
30297: PPUSH
30298: CALL 54499 0 3
30302: ST_TO_ADDR
30303: GO 30250
30305: POP
30306: POP
// end ;
30307: GO 29550
30309: POP
30310: POP
// end ;
30311: LD_VAR 0 1
30315: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30316: LD_INT 0
30318: PPUSH
30319: PPUSH
30320: PPUSH
30321: PPUSH
30322: PPUSH
30323: PPUSH
30324: PPUSH
30325: PPUSH
30326: PPUSH
30327: PPUSH
// if not mc_bases then
30328: LD_EXP 50
30332: NOT
30333: IFFALSE 30337
// exit ;
30335: GO 32087
// for i = 1 to mc_bases do
30337: LD_ADDR_VAR 0 2
30341: PUSH
30342: DOUBLE
30343: LD_INT 1
30345: DEC
30346: ST_TO_ADDR
30347: LD_EXP 50
30351: PUSH
30352: FOR_TO
30353: IFFALSE 32085
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30355: LD_EXP 50
30359: PUSH
30360: LD_VAR 0 2
30364: ARRAY
30365: NOT
30366: PUSH
30367: LD_EXP 57
30371: PUSH
30372: LD_VAR 0 2
30376: ARRAY
30377: OR
30378: IFFALSE 30382
// continue ;
30380: GO 30352
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30382: LD_EXP 66
30386: PUSH
30387: LD_VAR 0 2
30391: ARRAY
30392: NOT
30393: PUSH
30394: LD_EXP 67
30398: PUSH
30399: LD_VAR 0 2
30403: ARRAY
30404: AND
30405: IFFALSE 30443
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30407: LD_ADDR_EXP 67
30411: PUSH
30412: LD_EXP 67
30416: PPUSH
30417: LD_VAR 0 2
30421: PPUSH
30422: EMPTY
30423: PPUSH
30424: CALL_OW 1
30428: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30429: LD_VAR 0 2
30433: PPUSH
30434: LD_INT 107
30436: PPUSH
30437: CALL 21301 0 2
// continue ;
30441: GO 30352
// end ; target := [ ] ;
30443: LD_ADDR_VAR 0 6
30447: PUSH
30448: EMPTY
30449: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30450: LD_ADDR_VAR 0 3
30454: PUSH
30455: DOUBLE
30456: LD_EXP 66
30460: PUSH
30461: LD_VAR 0 2
30465: ARRAY
30466: INC
30467: ST_TO_ADDR
30468: LD_INT 1
30470: PUSH
30471: FOR_DOWNTO
30472: IFFALSE 30732
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30474: LD_EXP 66
30478: PUSH
30479: LD_VAR 0 2
30483: ARRAY
30484: PUSH
30485: LD_VAR 0 3
30489: ARRAY
30490: PUSH
30491: LD_INT 2
30493: ARRAY
30494: PPUSH
30495: LD_EXP 66
30499: PUSH
30500: LD_VAR 0 2
30504: ARRAY
30505: PUSH
30506: LD_VAR 0 3
30510: ARRAY
30511: PUSH
30512: LD_INT 3
30514: ARRAY
30515: PPUSH
30516: CALL_OW 488
30520: PUSH
30521: LD_EXP 66
30525: PUSH
30526: LD_VAR 0 2
30530: ARRAY
30531: PUSH
30532: LD_VAR 0 3
30536: ARRAY
30537: PUSH
30538: LD_INT 2
30540: ARRAY
30541: PPUSH
30542: LD_EXP 66
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: PUSH
30553: LD_VAR 0 3
30557: ARRAY
30558: PUSH
30559: LD_INT 3
30561: ARRAY
30562: PPUSH
30563: CALL_OW 284
30567: PUSH
30568: LD_INT 0
30570: EQUAL
30571: AND
30572: IFFALSE 30627
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30574: LD_ADDR_VAR 0 5
30578: PUSH
30579: LD_EXP 66
30583: PUSH
30584: LD_VAR 0 2
30588: ARRAY
30589: PPUSH
30590: LD_VAR 0 3
30594: PPUSH
30595: CALL_OW 3
30599: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30600: LD_ADDR_EXP 66
30604: PUSH
30605: LD_EXP 66
30609: PPUSH
30610: LD_VAR 0 2
30614: PPUSH
30615: LD_VAR 0 5
30619: PPUSH
30620: CALL_OW 1
30624: ST_TO_ADDR
// continue ;
30625: GO 30471
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30627: LD_EXP 50
30631: PUSH
30632: LD_VAR 0 2
30636: ARRAY
30637: PUSH
30638: LD_INT 1
30640: ARRAY
30641: PPUSH
30642: CALL_OW 255
30646: PPUSH
30647: LD_EXP 66
30651: PUSH
30652: LD_VAR 0 2
30656: ARRAY
30657: PUSH
30658: LD_VAR 0 3
30662: ARRAY
30663: PUSH
30664: LD_INT 2
30666: ARRAY
30667: PPUSH
30668: LD_EXP 66
30672: PUSH
30673: LD_VAR 0 2
30677: ARRAY
30678: PUSH
30679: LD_VAR 0 3
30683: ARRAY
30684: PUSH
30685: LD_INT 3
30687: ARRAY
30688: PPUSH
30689: LD_INT 30
30691: PPUSH
30692: CALL 55395 0 4
30696: PUSH
30697: LD_INT 4
30699: ARRAY
30700: PUSH
30701: LD_INT 0
30703: EQUAL
30704: IFFALSE 30730
// begin target := mc_crates [ i ] [ j ] ;
30706: LD_ADDR_VAR 0 6
30710: PUSH
30711: LD_EXP 66
30715: PUSH
30716: LD_VAR 0 2
30720: ARRAY
30721: PUSH
30722: LD_VAR 0 3
30726: ARRAY
30727: ST_TO_ADDR
// break ;
30728: GO 30732
// end ; end ;
30730: GO 30471
30732: POP
30733: POP
// if not target then
30734: LD_VAR 0 6
30738: NOT
30739: IFFALSE 30743
// continue ;
30741: GO 30352
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30743: LD_ADDR_VAR 0 7
30747: PUSH
30748: LD_EXP 69
30752: PUSH
30753: LD_VAR 0 2
30757: ARRAY
30758: PPUSH
30759: LD_INT 2
30761: PUSH
30762: LD_INT 3
30764: PUSH
30765: LD_INT 58
30767: PUSH
30768: EMPTY
30769: LIST
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 61
30777: PUSH
30778: EMPTY
30779: LIST
30780: PUSH
30781: LD_INT 33
30783: PUSH
30784: LD_INT 5
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 33
30793: PUSH
30794: LD_INT 3
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 2
30810: PUSH
30811: LD_INT 34
30813: PUSH
30814: LD_INT 32
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 34
30823: PUSH
30824: LD_INT 51
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 34
30833: PUSH
30834: LD_INT 12
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: PUSH
30847: EMPTY
30848: LIST
30849: LIST
30850: PPUSH
30851: CALL_OW 72
30855: ST_TO_ADDR
// if not cargo then
30856: LD_VAR 0 7
30860: NOT
30861: IFFALSE 31504
// begin if mc_crates_collector [ i ] < 5 then
30863: LD_EXP 67
30867: PUSH
30868: LD_VAR 0 2
30872: ARRAY
30873: PUSH
30874: LD_INT 5
30876: LESS
30877: IFFALSE 31243
// begin if mc_ape [ i ] then
30879: LD_EXP 79
30883: PUSH
30884: LD_VAR 0 2
30888: ARRAY
30889: IFFALSE 30936
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30891: LD_ADDR_VAR 0 5
30895: PUSH
30896: LD_EXP 79
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PPUSH
30907: LD_INT 25
30909: PUSH
30910: LD_INT 16
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: LD_INT 24
30919: PUSH
30920: LD_INT 750
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PPUSH
30931: CALL_OW 72
30935: ST_TO_ADDR
// if not tmp then
30936: LD_VAR 0 5
30940: NOT
30941: IFFALSE 30988
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30943: LD_ADDR_VAR 0 5
30947: PUSH
30948: LD_EXP 50
30952: PUSH
30953: LD_VAR 0 2
30957: ARRAY
30958: PPUSH
30959: LD_INT 25
30961: PUSH
30962: LD_INT 2
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 24
30971: PUSH
30972: LD_INT 750
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PPUSH
30983: CALL_OW 72
30987: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
30988: LD_EXP 79
30992: PUSH
30993: LD_VAR 0 2
30997: ARRAY
30998: PUSH
30999: LD_EXP 50
31003: PUSH
31004: LD_VAR 0 2
31008: ARRAY
31009: PPUSH
31010: LD_INT 25
31012: PUSH
31013: LD_INT 2
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 24
31022: PUSH
31023: LD_INT 750
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PPUSH
31034: CALL_OW 72
31038: AND
31039: PUSH
31040: LD_VAR 0 5
31044: PUSH
31045: LD_INT 5
31047: LESS
31048: AND
31049: IFFALSE 31131
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31051: LD_ADDR_VAR 0 3
31055: PUSH
31056: LD_EXP 50
31060: PUSH
31061: LD_VAR 0 2
31065: ARRAY
31066: PPUSH
31067: LD_INT 25
31069: PUSH
31070: LD_INT 2
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 24
31079: PUSH
31080: LD_INT 750
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PPUSH
31091: CALL_OW 72
31095: PUSH
31096: FOR_IN
31097: IFFALSE 31129
// begin tmp := tmp union j ;
31099: LD_ADDR_VAR 0 5
31103: PUSH
31104: LD_VAR 0 5
31108: PUSH
31109: LD_VAR 0 3
31113: UNION
31114: ST_TO_ADDR
// if tmp >= 5 then
31115: LD_VAR 0 5
31119: PUSH
31120: LD_INT 5
31122: GREATEREQUAL
31123: IFFALSE 31127
// break ;
31125: GO 31129
// end ;
31127: GO 31096
31129: POP
31130: POP
// end ; if not tmp then
31131: LD_VAR 0 5
31135: NOT
31136: IFFALSE 31140
// continue ;
31138: GO 30352
// for j in tmp do
31140: LD_ADDR_VAR 0 3
31144: PUSH
31145: LD_VAR 0 5
31149: PUSH
31150: FOR_IN
31151: IFFALSE 31241
// if not GetTag ( j ) then
31153: LD_VAR 0 3
31157: PPUSH
31158: CALL_OW 110
31162: NOT
31163: IFFALSE 31239
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31165: LD_ADDR_EXP 67
31169: PUSH
31170: LD_EXP 67
31174: PPUSH
31175: LD_VAR 0 2
31179: PUSH
31180: LD_EXP 67
31184: PUSH
31185: LD_VAR 0 2
31189: ARRAY
31190: PUSH
31191: LD_INT 1
31193: PLUS
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PPUSH
31199: LD_VAR 0 3
31203: PPUSH
31204: CALL 54499 0 3
31208: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31209: LD_VAR 0 3
31213: PPUSH
31214: LD_INT 107
31216: PPUSH
31217: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31221: LD_EXP 67
31225: PUSH
31226: LD_VAR 0 2
31230: ARRAY
31231: PUSH
31232: LD_INT 5
31234: GREATEREQUAL
31235: IFFALSE 31239
// break ;
31237: GO 31241
// end ;
31239: GO 31150
31241: POP
31242: POP
// end ; if mc_crates_collector [ i ] and target then
31243: LD_EXP 67
31247: PUSH
31248: LD_VAR 0 2
31252: ARRAY
31253: PUSH
31254: LD_VAR 0 6
31258: AND
31259: IFFALSE 31502
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31261: LD_EXP 67
31265: PUSH
31266: LD_VAR 0 2
31270: ARRAY
31271: PUSH
31272: LD_VAR 0 6
31276: PUSH
31277: LD_INT 1
31279: ARRAY
31280: LESS
31281: IFFALSE 31301
// tmp := mc_crates_collector [ i ] else
31283: LD_ADDR_VAR 0 5
31287: PUSH
31288: LD_EXP 67
31292: PUSH
31293: LD_VAR 0 2
31297: ARRAY
31298: ST_TO_ADDR
31299: GO 31315
// tmp := target [ 1 ] ;
31301: LD_ADDR_VAR 0 5
31305: PUSH
31306: LD_VAR 0 6
31310: PUSH
31311: LD_INT 1
31313: ARRAY
31314: ST_TO_ADDR
// k := 0 ;
31315: LD_ADDR_VAR 0 4
31319: PUSH
31320: LD_INT 0
31322: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31323: LD_ADDR_VAR 0 3
31327: PUSH
31328: LD_EXP 67
31332: PUSH
31333: LD_VAR 0 2
31337: ARRAY
31338: PUSH
31339: FOR_IN
31340: IFFALSE 31500
// begin k := k + 1 ;
31342: LD_ADDR_VAR 0 4
31346: PUSH
31347: LD_VAR 0 4
31351: PUSH
31352: LD_INT 1
31354: PLUS
31355: ST_TO_ADDR
// if k > tmp then
31356: LD_VAR 0 4
31360: PUSH
31361: LD_VAR 0 5
31365: GREATER
31366: IFFALSE 31370
// break ;
31368: GO 31500
// if not GetClass ( j ) in [ 2 , 16 ] then
31370: LD_VAR 0 3
31374: PPUSH
31375: CALL_OW 257
31379: PUSH
31380: LD_INT 2
31382: PUSH
31383: LD_INT 16
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: IN
31390: NOT
31391: IFFALSE 31444
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31393: LD_ADDR_EXP 67
31397: PUSH
31398: LD_EXP 67
31402: PPUSH
31403: LD_VAR 0 2
31407: PPUSH
31408: LD_EXP 67
31412: PUSH
31413: LD_VAR 0 2
31417: ARRAY
31418: PUSH
31419: LD_VAR 0 3
31423: DIFF
31424: PPUSH
31425: CALL_OW 1
31429: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31430: LD_VAR 0 3
31434: PPUSH
31435: LD_INT 0
31437: PPUSH
31438: CALL_OW 109
// continue ;
31442: GO 31339
// end ; if IsInUnit ( j ) then
31444: LD_VAR 0 3
31448: PPUSH
31449: CALL_OW 310
31453: IFFALSE 31464
// ComExitBuilding ( j ) ;
31455: LD_VAR 0 3
31459: PPUSH
31460: CALL_OW 122
// wait ( 3 ) ;
31464: LD_INT 3
31466: PPUSH
31467: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31471: LD_VAR 0 3
31475: PPUSH
31476: LD_VAR 0 6
31480: PUSH
31481: LD_INT 2
31483: ARRAY
31484: PPUSH
31485: LD_VAR 0 6
31489: PUSH
31490: LD_INT 3
31492: ARRAY
31493: PPUSH
31494: CALL_OW 117
// end ;
31498: GO 31339
31500: POP
31501: POP
// end ; end else
31502: GO 32083
// begin for j in cargo do
31504: LD_ADDR_VAR 0 3
31508: PUSH
31509: LD_VAR 0 7
31513: PUSH
31514: FOR_IN
31515: IFFALSE 32081
// begin if GetTag ( j ) <> 0 then
31517: LD_VAR 0 3
31521: PPUSH
31522: CALL_OW 110
31526: PUSH
31527: LD_INT 0
31529: NONEQUAL
31530: IFFALSE 31534
// continue ;
31532: GO 31514
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31534: LD_VAR 0 3
31538: PPUSH
31539: CALL_OW 256
31543: PUSH
31544: LD_INT 1000
31546: LESS
31547: PUSH
31548: LD_VAR 0 3
31552: PPUSH
31553: LD_EXP 74
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PPUSH
31564: CALL_OW 308
31568: NOT
31569: AND
31570: IFFALSE 31592
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31572: LD_VAR 0 3
31576: PPUSH
31577: LD_EXP 74
31581: PUSH
31582: LD_VAR 0 2
31586: ARRAY
31587: PPUSH
31588: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31592: LD_VAR 0 3
31596: PPUSH
31597: CALL_OW 256
31601: PUSH
31602: LD_INT 1000
31604: LESS
31605: PUSH
31606: LD_VAR 0 3
31610: PPUSH
31611: LD_EXP 74
31615: PUSH
31616: LD_VAR 0 2
31620: ARRAY
31621: PPUSH
31622: CALL_OW 308
31626: AND
31627: IFFALSE 31631
// continue ;
31629: GO 31514
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31631: LD_VAR 0 3
31635: PPUSH
31636: CALL_OW 262
31640: PUSH
31641: LD_INT 2
31643: EQUAL
31644: PUSH
31645: LD_VAR 0 3
31649: PPUSH
31650: CALL_OW 261
31654: PUSH
31655: LD_INT 15
31657: LESS
31658: AND
31659: IFFALSE 31663
// continue ;
31661: GO 31514
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31663: LD_VAR 0 3
31667: PPUSH
31668: CALL_OW 262
31672: PUSH
31673: LD_INT 1
31675: EQUAL
31676: PUSH
31677: LD_VAR 0 3
31681: PPUSH
31682: CALL_OW 261
31686: PUSH
31687: LD_INT 10
31689: LESS
31690: AND
31691: IFFALSE 32020
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31693: LD_ADDR_VAR 0 8
31697: PUSH
31698: LD_EXP 50
31702: PUSH
31703: LD_VAR 0 2
31707: ARRAY
31708: PPUSH
31709: LD_INT 2
31711: PUSH
31712: LD_INT 30
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 30
31724: PUSH
31725: LD_INT 1
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 72
31741: ST_TO_ADDR
// if not depot then
31742: LD_VAR 0 8
31746: NOT
31747: IFFALSE 31751
// continue ;
31749: GO 31514
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31751: LD_VAR 0 3
31755: PPUSH
31756: LD_VAR 0 8
31760: PPUSH
31761: LD_VAR 0 3
31765: PPUSH
31766: CALL_OW 74
31770: PPUSH
31771: CALL_OW 296
31775: PUSH
31776: LD_INT 6
31778: LESS
31779: IFFALSE 31795
// SetFuel ( j , 100 ) else
31781: LD_VAR 0 3
31785: PPUSH
31786: LD_INT 100
31788: PPUSH
31789: CALL_OW 240
31793: GO 32020
// if GetFuel ( j ) = 0 then
31795: LD_VAR 0 3
31799: PPUSH
31800: CALL_OW 261
31804: PUSH
31805: LD_INT 0
31807: EQUAL
31808: IFFALSE 32020
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31810: LD_ADDR_EXP 69
31814: PUSH
31815: LD_EXP 69
31819: PPUSH
31820: LD_VAR 0 2
31824: PPUSH
31825: LD_EXP 69
31829: PUSH
31830: LD_VAR 0 2
31834: ARRAY
31835: PUSH
31836: LD_VAR 0 3
31840: DIFF
31841: PPUSH
31842: CALL_OW 1
31846: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31847: LD_VAR 0 3
31851: PPUSH
31852: CALL_OW 263
31856: PUSH
31857: LD_INT 1
31859: EQUAL
31860: IFFALSE 31876
// ComExitVehicle ( IsInUnit ( j ) ) ;
31862: LD_VAR 0 3
31866: PPUSH
31867: CALL_OW 310
31871: PPUSH
31872: CALL_OW 121
// if GetControl ( j ) = control_remote then
31876: LD_VAR 0 3
31880: PPUSH
31881: CALL_OW 263
31885: PUSH
31886: LD_INT 2
31888: EQUAL
31889: IFFALSE 31900
// ComUnlink ( j ) ;
31891: LD_VAR 0 3
31895: PPUSH
31896: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31900: LD_ADDR_VAR 0 9
31904: PUSH
31905: LD_VAR 0 2
31909: PPUSH
31910: LD_INT 3
31912: PPUSH
31913: CALL 41373 0 2
31917: ST_TO_ADDR
// if fac then
31918: LD_VAR 0 9
31922: IFFALSE 32018
// begin for k in fac do
31924: LD_ADDR_VAR 0 4
31928: PUSH
31929: LD_VAR 0 9
31933: PUSH
31934: FOR_IN
31935: IFFALSE 32016
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31937: LD_ADDR_VAR 0 10
31941: PUSH
31942: LD_VAR 0 9
31946: PPUSH
31947: LD_VAR 0 3
31951: PPUSH
31952: CALL_OW 265
31956: PPUSH
31957: LD_VAR 0 3
31961: PPUSH
31962: CALL_OW 262
31966: PPUSH
31967: LD_VAR 0 3
31971: PPUSH
31972: CALL_OW 263
31976: PPUSH
31977: LD_VAR 0 3
31981: PPUSH
31982: CALL_OW 264
31986: PPUSH
31987: CALL 52031 0 5
31991: ST_TO_ADDR
// if components then
31992: LD_VAR 0 10
31996: IFFALSE 32014
// begin MC_InsertProduceList ( i , components ) ;
31998: LD_VAR 0 2
32002: PPUSH
32003: LD_VAR 0 10
32007: PPUSH
32008: CALL 40918 0 2
// break ;
32012: GO 32016
// end ; end ;
32014: GO 31934
32016: POP
32017: POP
// end ; continue ;
32018: GO 31514
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32020: LD_VAR 0 3
32024: PPUSH
32025: LD_INT 1
32027: PPUSH
32028: CALL_OW 289
32032: PUSH
32033: LD_INT 100
32035: LESS
32036: PUSH
32037: LD_VAR 0 3
32041: PPUSH
32042: CALL_OW 314
32046: NOT
32047: AND
32048: IFFALSE 32077
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32050: LD_VAR 0 3
32054: PPUSH
32055: LD_VAR 0 6
32059: PUSH
32060: LD_INT 2
32062: ARRAY
32063: PPUSH
32064: LD_VAR 0 6
32068: PUSH
32069: LD_INT 3
32071: ARRAY
32072: PPUSH
32073: CALL_OW 117
// break ;
32077: GO 32081
// end ;
32079: GO 31514
32081: POP
32082: POP
// end ; end ;
32083: GO 30352
32085: POP
32086: POP
// end ;
32087: LD_VAR 0 1
32091: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32092: LD_INT 0
32094: PPUSH
32095: PPUSH
32096: PPUSH
32097: PPUSH
// if not mc_bases then
32098: LD_EXP 50
32102: NOT
32103: IFFALSE 32107
// exit ;
32105: GO 32268
// for i = 1 to mc_bases do
32107: LD_ADDR_VAR 0 2
32111: PUSH
32112: DOUBLE
32113: LD_INT 1
32115: DEC
32116: ST_TO_ADDR
32117: LD_EXP 50
32121: PUSH
32122: FOR_TO
32123: IFFALSE 32266
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32125: LD_ADDR_VAR 0 4
32129: PUSH
32130: LD_EXP 69
32134: PUSH
32135: LD_VAR 0 2
32139: ARRAY
32140: PUSH
32141: LD_EXP 72
32145: PUSH
32146: LD_VAR 0 2
32150: ARRAY
32151: UNION
32152: PPUSH
32153: LD_INT 33
32155: PUSH
32156: LD_INT 2
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PPUSH
32163: CALL_OW 72
32167: ST_TO_ADDR
// if tmp then
32168: LD_VAR 0 4
32172: IFFALSE 32264
// for j in tmp do
32174: LD_ADDR_VAR 0 3
32178: PUSH
32179: LD_VAR 0 4
32183: PUSH
32184: FOR_IN
32185: IFFALSE 32262
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32187: LD_VAR 0 3
32191: PPUSH
32192: CALL_OW 312
32196: NOT
32197: PUSH
32198: LD_VAR 0 3
32202: PPUSH
32203: CALL_OW 256
32207: PUSH
32208: LD_INT 250
32210: GREATEREQUAL
32211: AND
32212: IFFALSE 32225
// Connect ( j ) else
32214: LD_VAR 0 3
32218: PPUSH
32219: CALL 57432 0 1
32223: GO 32260
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32225: LD_VAR 0 3
32229: PPUSH
32230: CALL_OW 256
32234: PUSH
32235: LD_INT 250
32237: LESS
32238: PUSH
32239: LD_VAR 0 3
32243: PPUSH
32244: CALL_OW 312
32248: AND
32249: IFFALSE 32260
// ComUnlink ( j ) ;
32251: LD_VAR 0 3
32255: PPUSH
32256: CALL_OW 136
32260: GO 32184
32262: POP
32263: POP
// end ;
32264: GO 32122
32266: POP
32267: POP
// end ;
32268: LD_VAR 0 1
32272: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32273: LD_INT 0
32275: PPUSH
32276: PPUSH
32277: PPUSH
32278: PPUSH
32279: PPUSH
// if not mc_bases then
32280: LD_EXP 50
32284: NOT
32285: IFFALSE 32289
// exit ;
32287: GO 32734
// for i = 1 to mc_bases do
32289: LD_ADDR_VAR 0 2
32293: PUSH
32294: DOUBLE
32295: LD_INT 1
32297: DEC
32298: ST_TO_ADDR
32299: LD_EXP 50
32303: PUSH
32304: FOR_TO
32305: IFFALSE 32732
// begin if not mc_produce [ i ] then
32307: LD_EXP 71
32311: PUSH
32312: LD_VAR 0 2
32316: ARRAY
32317: NOT
32318: IFFALSE 32322
// continue ;
32320: GO 32304
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32322: LD_ADDR_VAR 0 5
32326: PUSH
32327: LD_EXP 50
32331: PUSH
32332: LD_VAR 0 2
32336: ARRAY
32337: PPUSH
32338: LD_INT 30
32340: PUSH
32341: LD_INT 3
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PPUSH
32348: CALL_OW 72
32352: ST_TO_ADDR
// if not fac then
32353: LD_VAR 0 5
32357: NOT
32358: IFFALSE 32362
// continue ;
32360: GO 32304
// for j in fac do
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_VAR 0 5
32371: PUSH
32372: FOR_IN
32373: IFFALSE 32728
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 461
32384: PUSH
32385: LD_INT 2
32387: NONEQUAL
32388: PUSH
32389: LD_VAR 0 3
32393: PPUSH
32394: LD_INT 15
32396: PPUSH
32397: CALL 57092 0 2
32401: PUSH
32402: LD_INT 4
32404: ARRAY
32405: OR
32406: IFFALSE 32410
// continue ;
32408: GO 32372
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32410: LD_VAR 0 3
32414: PPUSH
32415: LD_EXP 71
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: PUSH
32426: LD_INT 1
32428: ARRAY
32429: PUSH
32430: LD_INT 1
32432: ARRAY
32433: PPUSH
32434: LD_EXP 71
32438: PUSH
32439: LD_VAR 0 2
32443: ARRAY
32444: PUSH
32445: LD_INT 1
32447: ARRAY
32448: PUSH
32449: LD_INT 2
32451: ARRAY
32452: PPUSH
32453: LD_EXP 71
32457: PUSH
32458: LD_VAR 0 2
32462: ARRAY
32463: PUSH
32464: LD_INT 1
32466: ARRAY
32467: PUSH
32468: LD_INT 3
32470: ARRAY
32471: PPUSH
32472: LD_EXP 71
32476: PUSH
32477: LD_VAR 0 2
32481: ARRAY
32482: PUSH
32483: LD_INT 1
32485: ARRAY
32486: PUSH
32487: LD_INT 4
32489: ARRAY
32490: PPUSH
32491: CALL_OW 448
32495: PUSH
32496: LD_VAR 0 3
32500: PPUSH
32501: LD_EXP 71
32505: PUSH
32506: LD_VAR 0 2
32510: ARRAY
32511: PUSH
32512: LD_INT 1
32514: ARRAY
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: PUSH
32520: LD_EXP 71
32524: PUSH
32525: LD_VAR 0 2
32529: ARRAY
32530: PUSH
32531: LD_INT 1
32533: ARRAY
32534: PUSH
32535: LD_INT 2
32537: ARRAY
32538: PUSH
32539: LD_EXP 71
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: ARRAY
32553: PUSH
32554: LD_INT 3
32556: ARRAY
32557: PUSH
32558: LD_EXP 71
32562: PUSH
32563: LD_VAR 0 2
32567: ARRAY
32568: PUSH
32569: LD_INT 1
32571: ARRAY
32572: PUSH
32573: LD_INT 4
32575: ARRAY
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: PPUSH
32583: CALL 60763 0 2
32587: AND
32588: IFFALSE 32726
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32590: LD_VAR 0 3
32594: PPUSH
32595: LD_EXP 71
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PUSH
32606: LD_INT 1
32608: ARRAY
32609: PUSH
32610: LD_INT 1
32612: ARRAY
32613: PPUSH
32614: LD_EXP 71
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PUSH
32625: LD_INT 1
32627: ARRAY
32628: PUSH
32629: LD_INT 2
32631: ARRAY
32632: PPUSH
32633: LD_EXP 71
32637: PUSH
32638: LD_VAR 0 2
32642: ARRAY
32643: PUSH
32644: LD_INT 1
32646: ARRAY
32647: PUSH
32648: LD_INT 3
32650: ARRAY
32651: PPUSH
32652: LD_EXP 71
32656: PUSH
32657: LD_VAR 0 2
32661: ARRAY
32662: PUSH
32663: LD_INT 1
32665: ARRAY
32666: PUSH
32667: LD_INT 4
32669: ARRAY
32670: PPUSH
32671: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32675: LD_ADDR_VAR 0 4
32679: PUSH
32680: LD_EXP 71
32684: PUSH
32685: LD_VAR 0 2
32689: ARRAY
32690: PPUSH
32691: LD_INT 1
32693: PPUSH
32694: CALL_OW 3
32698: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32699: LD_ADDR_EXP 71
32703: PUSH
32704: LD_EXP 71
32708: PPUSH
32709: LD_VAR 0 2
32713: PPUSH
32714: LD_VAR 0 4
32718: PPUSH
32719: CALL_OW 1
32723: ST_TO_ADDR
// break ;
32724: GO 32728
// end ; end ;
32726: GO 32372
32728: POP
32729: POP
// end ;
32730: GO 32304
32732: POP
32733: POP
// end ;
32734: LD_VAR 0 1
32738: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32739: LD_INT 0
32741: PPUSH
32742: PPUSH
32743: PPUSH
// if not mc_bases then
32744: LD_EXP 50
32748: NOT
32749: IFFALSE 32753
// exit ;
32751: GO 32842
// for i = 1 to mc_bases do
32753: LD_ADDR_VAR 0 2
32757: PUSH
32758: DOUBLE
32759: LD_INT 1
32761: DEC
32762: ST_TO_ADDR
32763: LD_EXP 50
32767: PUSH
32768: FOR_TO
32769: IFFALSE 32840
// begin if mc_attack [ i ] then
32771: LD_EXP 70
32775: PUSH
32776: LD_VAR 0 2
32780: ARRAY
32781: IFFALSE 32838
// begin tmp := mc_attack [ i ] [ 1 ] ;
32783: LD_ADDR_VAR 0 3
32787: PUSH
32788: LD_EXP 70
32792: PUSH
32793: LD_VAR 0 2
32797: ARRAY
32798: PUSH
32799: LD_INT 1
32801: ARRAY
32802: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32803: LD_ADDR_EXP 70
32807: PUSH
32808: LD_EXP 70
32812: PPUSH
32813: LD_VAR 0 2
32817: PPUSH
32818: EMPTY
32819: PPUSH
32820: CALL_OW 1
32824: ST_TO_ADDR
// Attack ( tmp ) ;
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL 82953 0 1
// exit ;
32834: POP
32835: POP
32836: GO 32842
// end ; end ;
32838: GO 32768
32840: POP
32841: POP
// end ;
32842: LD_VAR 0 1
32846: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32847: LD_INT 0
32849: PPUSH
32850: PPUSH
32851: PPUSH
32852: PPUSH
32853: PPUSH
32854: PPUSH
32855: PPUSH
// if not mc_bases then
32856: LD_EXP 50
32860: NOT
32861: IFFALSE 32865
// exit ;
32863: GO 33447
// for i = 1 to mc_bases do
32865: LD_ADDR_VAR 0 2
32869: PUSH
32870: DOUBLE
32871: LD_INT 1
32873: DEC
32874: ST_TO_ADDR
32875: LD_EXP 50
32879: PUSH
32880: FOR_TO
32881: IFFALSE 33445
// begin if not mc_bases [ i ] then
32883: LD_EXP 50
32887: PUSH
32888: LD_VAR 0 2
32892: ARRAY
32893: NOT
32894: IFFALSE 32898
// continue ;
32896: GO 32880
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32898: LD_ADDR_VAR 0 7
32902: PUSH
32903: LD_EXP 50
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: PUSH
32914: LD_INT 1
32916: ARRAY
32917: PPUSH
32918: CALL 51335 0 1
32922: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32923: LD_ADDR_EXP 73
32927: PUSH
32928: LD_EXP 73
32932: PPUSH
32933: LD_VAR 0 2
32937: PPUSH
32938: LD_EXP 50
32942: PUSH
32943: LD_VAR 0 2
32947: ARRAY
32948: PUSH
32949: LD_INT 1
32951: ARRAY
32952: PPUSH
32953: CALL_OW 255
32957: PPUSH
32958: LD_EXP 75
32962: PUSH
32963: LD_VAR 0 2
32967: ARRAY
32968: PPUSH
32969: CALL 48889 0 2
32973: PPUSH
32974: CALL_OW 1
32978: ST_TO_ADDR
// if not mc_scan [ i ] then
32979: LD_EXP 73
32983: PUSH
32984: LD_VAR 0 2
32988: ARRAY
32989: NOT
32990: IFFALSE 33145
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32992: LD_ADDR_VAR 0 4
32996: PUSH
32997: LD_EXP 50
33001: PUSH
33002: LD_VAR 0 2
33006: ARRAY
33007: PPUSH
33008: LD_INT 2
33010: PUSH
33011: LD_INT 25
33013: PUSH
33014: LD_INT 5
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 25
33023: PUSH
33024: LD_INT 8
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 25
33033: PUSH
33034: LD_INT 9
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: PPUSH
33047: CALL_OW 72
33051: ST_TO_ADDR
// if not tmp then
33052: LD_VAR 0 4
33056: NOT
33057: IFFALSE 33061
// continue ;
33059: GO 32880
// for j in tmp do
33061: LD_ADDR_VAR 0 3
33065: PUSH
33066: LD_VAR 0 4
33070: PUSH
33071: FOR_IN
33072: IFFALSE 33143
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33074: LD_VAR 0 3
33078: PPUSH
33079: CALL_OW 310
33083: PPUSH
33084: CALL_OW 266
33088: PUSH
33089: LD_INT 5
33091: EQUAL
33092: PUSH
33093: LD_VAR 0 3
33097: PPUSH
33098: CALL_OW 257
33102: PUSH
33103: LD_INT 1
33105: EQUAL
33106: AND
33107: PUSH
33108: LD_VAR 0 3
33112: PPUSH
33113: CALL_OW 459
33117: NOT
33118: AND
33119: PUSH
33120: LD_VAR 0 7
33124: AND
33125: IFFALSE 33141
// ComChangeProfession ( j , class ) ;
33127: LD_VAR 0 3
33131: PPUSH
33132: LD_VAR 0 7
33136: PPUSH
33137: CALL_OW 123
33141: GO 33071
33143: POP
33144: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33145: LD_EXP 73
33149: PUSH
33150: LD_VAR 0 2
33154: ARRAY
33155: PUSH
33156: LD_EXP 72
33160: PUSH
33161: LD_VAR 0 2
33165: ARRAY
33166: NOT
33167: AND
33168: PUSH
33169: LD_EXP 50
33173: PUSH
33174: LD_VAR 0 2
33178: ARRAY
33179: PPUSH
33180: LD_INT 30
33182: PUSH
33183: LD_INT 32
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PPUSH
33190: CALL_OW 72
33194: NOT
33195: AND
33196: PUSH
33197: LD_EXP 50
33201: PUSH
33202: LD_VAR 0 2
33206: ARRAY
33207: PPUSH
33208: LD_INT 2
33210: PUSH
33211: LD_INT 30
33213: PUSH
33214: LD_INT 4
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 30
33223: PUSH
33224: LD_INT 5
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: LIST
33235: PPUSH
33236: CALL_OW 72
33240: NOT
33241: AND
33242: IFFALSE 33374
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33244: LD_ADDR_VAR 0 4
33248: PUSH
33249: LD_EXP 50
33253: PUSH
33254: LD_VAR 0 2
33258: ARRAY
33259: PPUSH
33260: LD_INT 2
33262: PUSH
33263: LD_INT 25
33265: PUSH
33266: LD_INT 1
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 25
33275: PUSH
33276: LD_INT 5
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 25
33285: PUSH
33286: LD_INT 8
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 25
33295: PUSH
33296: LD_INT 9
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: PPUSH
33310: CALL_OW 72
33314: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33315: LD_ADDR_VAR 0 4
33319: PUSH
33320: LD_VAR 0 4
33324: PUSH
33325: LD_VAR 0 4
33329: PPUSH
33330: LD_INT 18
33332: PPUSH
33333: CALL 87762 0 2
33337: DIFF
33338: ST_TO_ADDR
// if tmp then
33339: LD_VAR 0 4
33343: IFFALSE 33374
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33345: LD_VAR 0 2
33349: PPUSH
33350: LD_VAR 0 4
33354: PPUSH
33355: LD_EXP 75
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: PPUSH
33366: CALL 48924 0 3
// exit ;
33370: POP
33371: POP
33372: GO 33447
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33374: LD_EXP 73
33378: PUSH
33379: LD_VAR 0 2
33383: ARRAY
33384: PUSH
33385: LD_EXP 72
33389: PUSH
33390: LD_VAR 0 2
33394: ARRAY
33395: AND
33396: IFFALSE 33443
// begin tmp := mc_defender [ i ] ;
33398: LD_ADDR_VAR 0 4
33402: PUSH
33403: LD_EXP 72
33407: PUSH
33408: LD_VAR 0 2
33412: ARRAY
33413: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33414: LD_VAR 0 2
33418: PPUSH
33419: LD_VAR 0 4
33423: PPUSH
33424: LD_EXP 73
33428: PUSH
33429: LD_VAR 0 2
33433: ARRAY
33434: PPUSH
33435: CALL 49485 0 3
// exit ;
33439: POP
33440: POP
33441: GO 33447
// end ; end ;
33443: GO 32880
33445: POP
33446: POP
// end ;
33447: LD_VAR 0 1
33451: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33452: LD_INT 0
33454: PPUSH
33455: PPUSH
33456: PPUSH
33457: PPUSH
33458: PPUSH
33459: PPUSH
33460: PPUSH
33461: PPUSH
33462: PPUSH
33463: PPUSH
33464: PPUSH
// if not mc_bases then
33465: LD_EXP 50
33469: NOT
33470: IFFALSE 33474
// exit ;
33472: GO 34561
// for i = 1 to mc_bases do
33474: LD_ADDR_VAR 0 2
33478: PUSH
33479: DOUBLE
33480: LD_INT 1
33482: DEC
33483: ST_TO_ADDR
33484: LD_EXP 50
33488: PUSH
33489: FOR_TO
33490: IFFALSE 34559
// begin tmp := mc_lab [ i ] ;
33492: LD_ADDR_VAR 0 6
33496: PUSH
33497: LD_EXP 83
33501: PUSH
33502: LD_VAR 0 2
33506: ARRAY
33507: ST_TO_ADDR
// if not tmp then
33508: LD_VAR 0 6
33512: NOT
33513: IFFALSE 33517
// continue ;
33515: GO 33489
// idle_lab := 0 ;
33517: LD_ADDR_VAR 0 11
33521: PUSH
33522: LD_INT 0
33524: ST_TO_ADDR
// for j in tmp do
33525: LD_ADDR_VAR 0 3
33529: PUSH
33530: LD_VAR 0 6
33534: PUSH
33535: FOR_IN
33536: IFFALSE 34555
// begin researching := false ;
33538: LD_ADDR_VAR 0 10
33542: PUSH
33543: LD_INT 0
33545: ST_TO_ADDR
// side := GetSide ( j ) ;
33546: LD_ADDR_VAR 0 4
33550: PUSH
33551: LD_VAR 0 3
33555: PPUSH
33556: CALL_OW 255
33560: ST_TO_ADDR
// if not mc_tech [ side ] then
33561: LD_EXP 77
33565: PUSH
33566: LD_VAR 0 4
33570: ARRAY
33571: NOT
33572: IFFALSE 33576
// continue ;
33574: GO 33535
// if BuildingStatus ( j ) = bs_idle then
33576: LD_VAR 0 3
33580: PPUSH
33581: CALL_OW 461
33585: PUSH
33586: LD_INT 2
33588: EQUAL
33589: IFFALSE 33777
// begin if idle_lab and UnitsInside ( j ) < 6 then
33591: LD_VAR 0 11
33595: PUSH
33596: LD_VAR 0 3
33600: PPUSH
33601: CALL_OW 313
33605: PUSH
33606: LD_INT 6
33608: LESS
33609: AND
33610: IFFALSE 33681
// begin tmp2 := UnitsInside ( idle_lab ) ;
33612: LD_ADDR_VAR 0 9
33616: PUSH
33617: LD_VAR 0 11
33621: PPUSH
33622: CALL_OW 313
33626: ST_TO_ADDR
// if tmp2 then
33627: LD_VAR 0 9
33631: IFFALSE 33673
// for x in tmp2 do
33633: LD_ADDR_VAR 0 7
33637: PUSH
33638: LD_VAR 0 9
33642: PUSH
33643: FOR_IN
33644: IFFALSE 33671
// begin ComExitBuilding ( x ) ;
33646: LD_VAR 0 7
33650: PPUSH
33651: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33655: LD_VAR 0 7
33659: PPUSH
33660: LD_VAR 0 3
33664: PPUSH
33665: CALL_OW 180
// end ;
33669: GO 33643
33671: POP
33672: POP
// idle_lab := 0 ;
33673: LD_ADDR_VAR 0 11
33677: PUSH
33678: LD_INT 0
33680: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33681: LD_ADDR_VAR 0 5
33685: PUSH
33686: LD_EXP 77
33690: PUSH
33691: LD_VAR 0 4
33695: ARRAY
33696: PUSH
33697: FOR_IN
33698: IFFALSE 33758
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33700: LD_VAR 0 3
33704: PPUSH
33705: LD_VAR 0 5
33709: PPUSH
33710: CALL_OW 430
33714: PUSH
33715: LD_VAR 0 4
33719: PPUSH
33720: LD_VAR 0 5
33724: PPUSH
33725: CALL 47994 0 2
33729: AND
33730: IFFALSE 33756
// begin researching := true ;
33732: LD_ADDR_VAR 0 10
33736: PUSH
33737: LD_INT 1
33739: ST_TO_ADDR
// ComResearch ( j , t ) ;
33740: LD_VAR 0 3
33744: PPUSH
33745: LD_VAR 0 5
33749: PPUSH
33750: CALL_OW 124
// break ;
33754: GO 33758
// end ;
33756: GO 33697
33758: POP
33759: POP
// if not researching then
33760: LD_VAR 0 10
33764: NOT
33765: IFFALSE 33777
// idle_lab := j ;
33767: LD_ADDR_VAR 0 11
33771: PUSH
33772: LD_VAR 0 3
33776: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33777: LD_VAR 0 3
33781: PPUSH
33782: CALL_OW 461
33786: PUSH
33787: LD_INT 10
33789: EQUAL
33790: IFFALSE 34378
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33792: LD_EXP 79
33796: PUSH
33797: LD_VAR 0 2
33801: ARRAY
33802: NOT
33803: PUSH
33804: LD_EXP 80
33808: PUSH
33809: LD_VAR 0 2
33813: ARRAY
33814: NOT
33815: AND
33816: PUSH
33817: LD_EXP 77
33821: PUSH
33822: LD_VAR 0 4
33826: ARRAY
33827: PUSH
33828: LD_INT 1
33830: GREATER
33831: AND
33832: IFFALSE 33963
// begin ComCancel ( j ) ;
33834: LD_VAR 0 3
33838: PPUSH
33839: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33843: LD_ADDR_EXP 77
33847: PUSH
33848: LD_EXP 77
33852: PPUSH
33853: LD_VAR 0 4
33857: PPUSH
33858: LD_EXP 77
33862: PUSH
33863: LD_VAR 0 4
33867: ARRAY
33868: PPUSH
33869: LD_EXP 77
33873: PUSH
33874: LD_VAR 0 4
33878: ARRAY
33879: PUSH
33880: LD_INT 1
33882: MINUS
33883: PPUSH
33884: LD_EXP 77
33888: PUSH
33889: LD_VAR 0 4
33893: ARRAY
33894: PPUSH
33895: LD_INT 0
33897: PPUSH
33898: CALL 53917 0 4
33902: PPUSH
33903: CALL_OW 1
33907: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33908: LD_ADDR_EXP 77
33912: PUSH
33913: LD_EXP 77
33917: PPUSH
33918: LD_VAR 0 4
33922: PPUSH
33923: LD_EXP 77
33927: PUSH
33928: LD_VAR 0 4
33932: ARRAY
33933: PPUSH
33934: LD_EXP 77
33938: PUSH
33939: LD_VAR 0 4
33943: ARRAY
33944: PPUSH
33945: LD_INT 1
33947: PPUSH
33948: LD_INT 0
33950: PPUSH
33951: CALL 53917 0 4
33955: PPUSH
33956: CALL_OW 1
33960: ST_TO_ADDR
// continue ;
33961: GO 33535
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
33963: LD_EXP 79
33967: PUSH
33968: LD_VAR 0 2
33972: ARRAY
33973: PUSH
33974: LD_EXP 80
33978: PUSH
33979: LD_VAR 0 2
33983: ARRAY
33984: NOT
33985: AND
33986: IFFALSE 34113
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
33988: LD_ADDR_EXP 80
33992: PUSH
33993: LD_EXP 80
33997: PPUSH
33998: LD_VAR 0 2
34002: PUSH
34003: LD_EXP 80
34007: PUSH
34008: LD_VAR 0 2
34012: ARRAY
34013: PUSH
34014: LD_INT 1
34016: PLUS
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PPUSH
34022: LD_EXP 79
34026: PUSH
34027: LD_VAR 0 2
34031: ARRAY
34032: PUSH
34033: LD_INT 1
34035: ARRAY
34036: PPUSH
34037: CALL 54499 0 3
34041: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34042: LD_EXP 79
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PUSH
34053: LD_INT 1
34055: ARRAY
34056: PPUSH
34057: LD_INT 112
34059: PPUSH
34060: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34064: LD_ADDR_VAR 0 9
34068: PUSH
34069: LD_EXP 79
34073: PUSH
34074: LD_VAR 0 2
34078: ARRAY
34079: PPUSH
34080: LD_INT 1
34082: PPUSH
34083: CALL_OW 3
34087: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34088: LD_ADDR_EXP 79
34092: PUSH
34093: LD_EXP 79
34097: PPUSH
34098: LD_VAR 0 2
34102: PPUSH
34103: LD_VAR 0 9
34107: PPUSH
34108: CALL_OW 1
34112: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34113: LD_EXP 79
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_EXP 80
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: AND
34135: PUSH
34136: LD_EXP 80
34140: PUSH
34141: LD_VAR 0 2
34145: ARRAY
34146: PUSH
34147: LD_INT 1
34149: ARRAY
34150: PPUSH
34151: CALL_OW 310
34155: NOT
34156: AND
34157: PUSH
34158: LD_VAR 0 3
34162: PPUSH
34163: CALL_OW 313
34167: PUSH
34168: LD_INT 6
34170: EQUAL
34171: AND
34172: IFFALSE 34228
// begin tmp2 := UnitsInside ( j ) ;
34174: LD_ADDR_VAR 0 9
34178: PUSH
34179: LD_VAR 0 3
34183: PPUSH
34184: CALL_OW 313
34188: ST_TO_ADDR
// if tmp2 = 6 then
34189: LD_VAR 0 9
34193: PUSH
34194: LD_INT 6
34196: EQUAL
34197: IFFALSE 34228
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34199: LD_VAR 0 9
34203: PUSH
34204: LD_INT 1
34206: ARRAY
34207: PPUSH
34208: LD_INT 112
34210: PPUSH
34211: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34215: LD_VAR 0 9
34219: PUSH
34220: LD_INT 1
34222: ARRAY
34223: PPUSH
34224: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34228: LD_EXP 80
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: PUSH
34239: LD_EXP 80
34243: PUSH
34244: LD_VAR 0 2
34248: ARRAY
34249: PUSH
34250: LD_INT 1
34252: ARRAY
34253: PPUSH
34254: CALL_OW 314
34258: NOT
34259: AND
34260: PUSH
34261: LD_EXP 80
34265: PUSH
34266: LD_VAR 0 2
34270: ARRAY
34271: PUSH
34272: LD_INT 1
34274: ARRAY
34275: PPUSH
34276: CALL_OW 310
34280: NOT
34281: AND
34282: IFFALSE 34308
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34284: LD_EXP 80
34288: PUSH
34289: LD_VAR 0 2
34293: ARRAY
34294: PUSH
34295: LD_INT 1
34297: ARRAY
34298: PPUSH
34299: LD_VAR 0 3
34303: PPUSH
34304: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34308: LD_EXP 80
34312: PUSH
34313: LD_VAR 0 2
34317: ARRAY
34318: PUSH
34319: LD_INT 1
34321: ARRAY
34322: PPUSH
34323: CALL_OW 310
34327: PUSH
34328: LD_EXP 80
34332: PUSH
34333: LD_VAR 0 2
34337: ARRAY
34338: PUSH
34339: LD_INT 1
34341: ARRAY
34342: PPUSH
34343: CALL_OW 310
34347: PPUSH
34348: CALL_OW 461
34352: PUSH
34353: LD_INT 3
34355: NONEQUAL
34356: AND
34357: IFFALSE 34378
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34359: LD_EXP 80
34363: PUSH
34364: LD_VAR 0 2
34368: ARRAY
34369: PUSH
34370: LD_INT 1
34372: ARRAY
34373: PPUSH
34374: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34378: LD_VAR 0 3
34382: PPUSH
34383: CALL_OW 461
34387: PUSH
34388: LD_INT 6
34390: EQUAL
34391: PUSH
34392: LD_VAR 0 6
34396: PUSH
34397: LD_INT 1
34399: GREATER
34400: AND
34401: IFFALSE 34553
// begin sci := [ ] ;
34403: LD_ADDR_VAR 0 8
34407: PUSH
34408: EMPTY
34409: ST_TO_ADDR
// for x in ( tmp diff j ) do
34410: LD_ADDR_VAR 0 7
34414: PUSH
34415: LD_VAR 0 6
34419: PUSH
34420: LD_VAR 0 3
34424: DIFF
34425: PUSH
34426: FOR_IN
34427: IFFALSE 34479
// begin if sci = 6 then
34429: LD_VAR 0 8
34433: PUSH
34434: LD_INT 6
34436: EQUAL
34437: IFFALSE 34441
// break ;
34439: GO 34479
// if BuildingStatus ( x ) = bs_idle then
34441: LD_VAR 0 7
34445: PPUSH
34446: CALL_OW 461
34450: PUSH
34451: LD_INT 2
34453: EQUAL
34454: IFFALSE 34477
// sci := sci ^ UnitsInside ( x ) ;
34456: LD_ADDR_VAR 0 8
34460: PUSH
34461: LD_VAR 0 8
34465: PUSH
34466: LD_VAR 0 7
34470: PPUSH
34471: CALL_OW 313
34475: ADD
34476: ST_TO_ADDR
// end ;
34477: GO 34426
34479: POP
34480: POP
// if not sci then
34481: LD_VAR 0 8
34485: NOT
34486: IFFALSE 34490
// continue ;
34488: GO 33535
// for x in sci do
34490: LD_ADDR_VAR 0 7
34494: PUSH
34495: LD_VAR 0 8
34499: PUSH
34500: FOR_IN
34501: IFFALSE 34551
// if IsInUnit ( x ) and not HasTask ( x ) then
34503: LD_VAR 0 7
34507: PPUSH
34508: CALL_OW 310
34512: PUSH
34513: LD_VAR 0 7
34517: PPUSH
34518: CALL_OW 314
34522: NOT
34523: AND
34524: IFFALSE 34549
// begin ComExitBuilding ( x ) ;
34526: LD_VAR 0 7
34530: PPUSH
34531: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34535: LD_VAR 0 7
34539: PPUSH
34540: LD_VAR 0 3
34544: PPUSH
34545: CALL_OW 180
// end ;
34549: GO 34500
34551: POP
34552: POP
// end ; end ;
34553: GO 33535
34555: POP
34556: POP
// end ;
34557: GO 33489
34559: POP
34560: POP
// end ;
34561: LD_VAR 0 1
34565: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34566: LD_INT 0
34568: PPUSH
34569: PPUSH
// if not mc_bases then
34570: LD_EXP 50
34574: NOT
34575: IFFALSE 34579
// exit ;
34577: GO 34660
// for i = 1 to mc_bases do
34579: LD_ADDR_VAR 0 2
34583: PUSH
34584: DOUBLE
34585: LD_INT 1
34587: DEC
34588: ST_TO_ADDR
34589: LD_EXP 50
34593: PUSH
34594: FOR_TO
34595: IFFALSE 34658
// if mc_mines [ i ] and mc_miners [ i ] then
34597: LD_EXP 63
34601: PUSH
34602: LD_VAR 0 2
34606: ARRAY
34607: PUSH
34608: LD_EXP 64
34612: PUSH
34613: LD_VAR 0 2
34617: ARRAY
34618: AND
34619: IFFALSE 34656
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34621: LD_EXP 64
34625: PUSH
34626: LD_VAR 0 2
34630: ARRAY
34631: PUSH
34632: LD_INT 1
34634: ARRAY
34635: PPUSH
34636: CALL_OW 255
34640: PPUSH
34641: LD_EXP 63
34645: PUSH
34646: LD_VAR 0 2
34650: ARRAY
34651: PPUSH
34652: CALL 51488 0 2
34656: GO 34594
34658: POP
34659: POP
// end ;
34660: LD_VAR 0 1
34664: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34665: LD_INT 0
34667: PPUSH
34668: PPUSH
34669: PPUSH
34670: PPUSH
34671: PPUSH
34672: PPUSH
34673: PPUSH
34674: PPUSH
// if not mc_bases or not mc_parking then
34675: LD_EXP 50
34679: NOT
34680: PUSH
34681: LD_EXP 74
34685: NOT
34686: OR
34687: IFFALSE 34691
// exit ;
34689: GO 35390
// for i = 1 to mc_bases do
34691: LD_ADDR_VAR 0 2
34695: PUSH
34696: DOUBLE
34697: LD_INT 1
34699: DEC
34700: ST_TO_ADDR
34701: LD_EXP 50
34705: PUSH
34706: FOR_TO
34707: IFFALSE 35388
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34709: LD_EXP 50
34713: PUSH
34714: LD_VAR 0 2
34718: ARRAY
34719: NOT
34720: PUSH
34721: LD_EXP 74
34725: PUSH
34726: LD_VAR 0 2
34730: ARRAY
34731: NOT
34732: OR
34733: IFFALSE 34737
// continue ;
34735: GO 34706
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34737: LD_ADDR_VAR 0 5
34741: PUSH
34742: LD_EXP 50
34746: PUSH
34747: LD_VAR 0 2
34751: ARRAY
34752: PUSH
34753: LD_INT 1
34755: ARRAY
34756: PPUSH
34757: CALL_OW 255
34761: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34762: LD_ADDR_VAR 0 6
34766: PUSH
34767: LD_EXP 50
34771: PUSH
34772: LD_VAR 0 2
34776: ARRAY
34777: PPUSH
34778: LD_INT 30
34780: PUSH
34781: LD_INT 3
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PPUSH
34788: CALL_OW 72
34792: ST_TO_ADDR
// if not fac then
34793: LD_VAR 0 6
34797: NOT
34798: IFFALSE 34849
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34800: LD_ADDR_VAR 0 6
34804: PUSH
34805: LD_EXP 50
34809: PUSH
34810: LD_VAR 0 2
34814: ARRAY
34815: PPUSH
34816: LD_INT 2
34818: PUSH
34819: LD_INT 30
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 30
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: LIST
34843: PPUSH
34844: CALL_OW 72
34848: ST_TO_ADDR
// if not fac then
34849: LD_VAR 0 6
34853: NOT
34854: IFFALSE 34858
// continue ;
34856: GO 34706
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34858: LD_ADDR_VAR 0 7
34862: PUSH
34863: LD_EXP 74
34867: PUSH
34868: LD_VAR 0 2
34872: ARRAY
34873: PPUSH
34874: LD_INT 22
34876: PUSH
34877: LD_VAR 0 5
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 21
34888: PUSH
34889: LD_INT 2
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 3
34898: PUSH
34899: LD_INT 24
34901: PUSH
34902: LD_INT 1000
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: LIST
34917: PPUSH
34918: CALL_OW 70
34922: ST_TO_ADDR
// for j in fac do
34923: LD_ADDR_VAR 0 3
34927: PUSH
34928: LD_VAR 0 6
34932: PUSH
34933: FOR_IN
34934: IFFALSE 35015
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34936: LD_ADDR_VAR 0 7
34940: PUSH
34941: LD_VAR 0 7
34945: PUSH
34946: LD_INT 22
34948: PUSH
34949: LD_VAR 0 5
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 91
34960: PUSH
34961: LD_VAR 0 3
34965: PUSH
34966: LD_INT 15
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 21
34976: PUSH
34977: LD_INT 2
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 3
34986: PUSH
34987: LD_INT 24
34989: PUSH
34990: LD_INT 1000
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: PPUSH
35007: CALL_OW 69
35011: UNION
35012: ST_TO_ADDR
35013: GO 34933
35015: POP
35016: POP
// if not vehs then
35017: LD_VAR 0 7
35021: NOT
35022: IFFALSE 35048
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35024: LD_ADDR_EXP 62
35028: PUSH
35029: LD_EXP 62
35033: PPUSH
35034: LD_VAR 0 2
35038: PPUSH
35039: EMPTY
35040: PPUSH
35041: CALL_OW 1
35045: ST_TO_ADDR
// continue ;
35046: GO 34706
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35048: LD_ADDR_VAR 0 8
35052: PUSH
35053: LD_EXP 50
35057: PUSH
35058: LD_VAR 0 2
35062: ARRAY
35063: PPUSH
35064: LD_INT 30
35066: PUSH
35067: LD_INT 3
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PPUSH
35074: CALL_OW 72
35078: ST_TO_ADDR
// if tmp then
35079: LD_VAR 0 8
35083: IFFALSE 35186
// begin for j in tmp do
35085: LD_ADDR_VAR 0 3
35089: PUSH
35090: LD_VAR 0 8
35094: PUSH
35095: FOR_IN
35096: IFFALSE 35184
// for k in UnitsInside ( j ) do
35098: LD_ADDR_VAR 0 4
35102: PUSH
35103: LD_VAR 0 3
35107: PPUSH
35108: CALL_OW 313
35112: PUSH
35113: FOR_IN
35114: IFFALSE 35180
// if k then
35116: LD_VAR 0 4
35120: IFFALSE 35178
// if not k in mc_repair_vehicle [ i ] then
35122: LD_VAR 0 4
35126: PUSH
35127: LD_EXP 62
35131: PUSH
35132: LD_VAR 0 2
35136: ARRAY
35137: IN
35138: NOT
35139: IFFALSE 35178
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35141: LD_ADDR_EXP 62
35145: PUSH
35146: LD_EXP 62
35150: PPUSH
35151: LD_VAR 0 2
35155: PPUSH
35156: LD_EXP 62
35160: PUSH
35161: LD_VAR 0 2
35165: ARRAY
35166: PUSH
35167: LD_VAR 0 4
35171: UNION
35172: PPUSH
35173: CALL_OW 1
35177: ST_TO_ADDR
35178: GO 35113
35180: POP
35181: POP
35182: GO 35095
35184: POP
35185: POP
// end ; if not mc_repair_vehicle [ i ] then
35186: LD_EXP 62
35190: PUSH
35191: LD_VAR 0 2
35195: ARRAY
35196: NOT
35197: IFFALSE 35201
// continue ;
35199: GO 34706
// for j in mc_repair_vehicle [ i ] do
35201: LD_ADDR_VAR 0 3
35205: PUSH
35206: LD_EXP 62
35210: PUSH
35211: LD_VAR 0 2
35215: ARRAY
35216: PUSH
35217: FOR_IN
35218: IFFALSE 35384
// begin if GetClass ( j ) <> 3 then
35220: LD_VAR 0 3
35224: PPUSH
35225: CALL_OW 257
35229: PUSH
35230: LD_INT 3
35232: NONEQUAL
35233: IFFALSE 35274
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35235: LD_ADDR_EXP 62
35239: PUSH
35240: LD_EXP 62
35244: PPUSH
35245: LD_VAR 0 2
35249: PPUSH
35250: LD_EXP 62
35254: PUSH
35255: LD_VAR 0 2
35259: ARRAY
35260: PUSH
35261: LD_VAR 0 3
35265: DIFF
35266: PPUSH
35267: CALL_OW 1
35271: ST_TO_ADDR
// continue ;
35272: GO 35217
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35274: LD_VAR 0 3
35278: PPUSH
35279: CALL_OW 311
35283: NOT
35284: PUSH
35285: LD_VAR 0 3
35289: PUSH
35290: LD_EXP 53
35294: PUSH
35295: LD_VAR 0 2
35299: ARRAY
35300: PUSH
35301: LD_INT 1
35303: ARRAY
35304: IN
35305: NOT
35306: AND
35307: PUSH
35308: LD_VAR 0 3
35312: PUSH
35313: LD_EXP 53
35317: PUSH
35318: LD_VAR 0 2
35322: ARRAY
35323: PUSH
35324: LD_INT 2
35326: ARRAY
35327: IN
35328: NOT
35329: AND
35330: IFFALSE 35382
// begin if IsInUnit ( j ) then
35332: LD_VAR 0 3
35336: PPUSH
35337: CALL_OW 310
35341: IFFALSE 35352
// ComExitBuilding ( j ) ;
35343: LD_VAR 0 3
35347: PPUSH
35348: CALL_OW 122
// if not HasTask ( j ) then
35352: LD_VAR 0 3
35356: PPUSH
35357: CALL_OW 314
35361: NOT
35362: IFFALSE 35382
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35364: LD_VAR 0 3
35368: PPUSH
35369: LD_VAR 0 7
35373: PUSH
35374: LD_INT 1
35376: ARRAY
35377: PPUSH
35378: CALL_OW 189
// end ; end ;
35382: GO 35217
35384: POP
35385: POP
// end ;
35386: GO 34706
35388: POP
35389: POP
// end ;
35390: LD_VAR 0 1
35394: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35395: LD_INT 0
35397: PPUSH
35398: PPUSH
35399: PPUSH
35400: PPUSH
35401: PPUSH
35402: PPUSH
35403: PPUSH
35404: PPUSH
35405: PPUSH
35406: PPUSH
35407: PPUSH
// if not mc_bases then
35408: LD_EXP 50
35412: NOT
35413: IFFALSE 35417
// exit ;
35415: GO 36219
// for i = 1 to mc_bases do
35417: LD_ADDR_VAR 0 2
35421: PUSH
35422: DOUBLE
35423: LD_INT 1
35425: DEC
35426: ST_TO_ADDR
35427: LD_EXP 50
35431: PUSH
35432: FOR_TO
35433: IFFALSE 36217
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35435: LD_EXP 78
35439: PUSH
35440: LD_VAR 0 2
35444: ARRAY
35445: NOT
35446: PUSH
35447: LD_EXP 53
35451: PUSH
35452: LD_VAR 0 2
35456: ARRAY
35457: PUSH
35458: LD_INT 1
35460: ARRAY
35461: OR
35462: PUSH
35463: LD_EXP 53
35467: PUSH
35468: LD_VAR 0 2
35472: ARRAY
35473: PUSH
35474: LD_INT 2
35476: ARRAY
35477: OR
35478: PUSH
35479: LD_EXP 76
35483: PUSH
35484: LD_VAR 0 2
35488: ARRAY
35489: PPUSH
35490: LD_INT 1
35492: PPUSH
35493: CALL_OW 325
35497: NOT
35498: OR
35499: PUSH
35500: LD_EXP 73
35504: PUSH
35505: LD_VAR 0 2
35509: ARRAY
35510: OR
35511: IFFALSE 35515
// continue ;
35513: GO 35432
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35515: LD_ADDR_VAR 0 8
35519: PUSH
35520: LD_EXP 50
35524: PUSH
35525: LD_VAR 0 2
35529: ARRAY
35530: PPUSH
35531: LD_INT 25
35533: PUSH
35534: LD_INT 4
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 50
35543: PUSH
35544: EMPTY
35545: LIST
35546: PUSH
35547: LD_INT 3
35549: PUSH
35550: LD_INT 60
35552: PUSH
35553: EMPTY
35554: LIST
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: LIST
35564: PPUSH
35565: CALL_OW 72
35569: PUSH
35570: LD_EXP 54
35574: PUSH
35575: LD_VAR 0 2
35579: ARRAY
35580: DIFF
35581: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35582: LD_ADDR_VAR 0 9
35586: PUSH
35587: LD_EXP 50
35591: PUSH
35592: LD_VAR 0 2
35596: ARRAY
35597: PPUSH
35598: LD_INT 2
35600: PUSH
35601: LD_INT 30
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 30
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: LIST
35625: PPUSH
35626: CALL_OW 72
35630: ST_TO_ADDR
// if not tmp or not dep then
35631: LD_VAR 0 8
35635: NOT
35636: PUSH
35637: LD_VAR 0 9
35641: NOT
35642: OR
35643: IFFALSE 35647
// continue ;
35645: GO 35432
// side := GetSide ( tmp [ 1 ] ) ;
35647: LD_ADDR_VAR 0 11
35651: PUSH
35652: LD_VAR 0 8
35656: PUSH
35657: LD_INT 1
35659: ARRAY
35660: PPUSH
35661: CALL_OW 255
35665: ST_TO_ADDR
// dep := dep [ 1 ] ;
35666: LD_ADDR_VAR 0 9
35670: PUSH
35671: LD_VAR 0 9
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35680: LD_ADDR_VAR 0 7
35684: PUSH
35685: LD_EXP 78
35689: PUSH
35690: LD_VAR 0 2
35694: ARRAY
35695: PPUSH
35696: LD_INT 22
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 25
35708: PUSH
35709: LD_INT 12
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PPUSH
35720: CALL_OW 70
35724: PUSH
35725: LD_INT 22
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 25
35737: PUSH
35738: LD_INT 12
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 91
35747: PUSH
35748: LD_VAR 0 9
35752: PUSH
35753: LD_INT 20
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: LIST
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: LIST
35765: PPUSH
35766: CALL_OW 69
35770: UNION
35771: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35772: LD_ADDR_VAR 0 10
35776: PUSH
35777: LD_EXP 78
35781: PUSH
35782: LD_VAR 0 2
35786: ARRAY
35787: PPUSH
35788: LD_INT 81
35790: PUSH
35791: LD_VAR 0 11
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PPUSH
35800: CALL_OW 70
35804: ST_TO_ADDR
// if not apes or danger_at_area then
35805: LD_VAR 0 7
35809: NOT
35810: PUSH
35811: LD_VAR 0 10
35815: OR
35816: IFFALSE 35866
// begin if mc_taming [ i ] then
35818: LD_EXP 81
35822: PUSH
35823: LD_VAR 0 2
35827: ARRAY
35828: IFFALSE 35864
// begin MC_Reset ( i , 121 ) ;
35830: LD_VAR 0 2
35834: PPUSH
35835: LD_INT 121
35837: PPUSH
35838: CALL 21301 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35842: LD_ADDR_EXP 81
35846: PUSH
35847: LD_EXP 81
35851: PPUSH
35852: LD_VAR 0 2
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// end ; continue ;
35864: GO 35432
// end ; for j in tmp do
35866: LD_ADDR_VAR 0 3
35870: PUSH
35871: LD_VAR 0 8
35875: PUSH
35876: FOR_IN
35877: IFFALSE 36213
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35879: LD_VAR 0 3
35883: PUSH
35884: LD_EXP 81
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: IN
35895: NOT
35896: PUSH
35897: LD_EXP 81
35901: PUSH
35902: LD_VAR 0 2
35906: ARRAY
35907: PUSH
35908: LD_INT 3
35910: LESS
35911: AND
35912: IFFALSE 35970
// begin SetTag ( j , 121 ) ;
35914: LD_VAR 0 3
35918: PPUSH
35919: LD_INT 121
35921: PPUSH
35922: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35926: LD_ADDR_EXP 81
35930: PUSH
35931: LD_EXP 81
35935: PPUSH
35936: LD_VAR 0 2
35940: PUSH
35941: LD_EXP 81
35945: PUSH
35946: LD_VAR 0 2
35950: ARRAY
35951: PUSH
35952: LD_INT 1
35954: PLUS
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PPUSH
35960: LD_VAR 0 3
35964: PPUSH
35965: CALL 54499 0 3
35969: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
35970: LD_VAR 0 3
35974: PUSH
35975: LD_EXP 81
35979: PUSH
35980: LD_VAR 0 2
35984: ARRAY
35985: IN
35986: IFFALSE 36211
// begin if GetClass ( j ) <> 4 then
35988: LD_VAR 0 3
35992: PPUSH
35993: CALL_OW 257
35997: PUSH
35998: LD_INT 4
36000: NONEQUAL
36001: IFFALSE 36054
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36003: LD_ADDR_EXP 81
36007: PUSH
36008: LD_EXP 81
36012: PPUSH
36013: LD_VAR 0 2
36017: PPUSH
36018: LD_EXP 81
36022: PUSH
36023: LD_VAR 0 2
36027: ARRAY
36028: PUSH
36029: LD_VAR 0 3
36033: DIFF
36034: PPUSH
36035: CALL_OW 1
36039: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36040: LD_VAR 0 3
36044: PPUSH
36045: LD_INT 0
36047: PPUSH
36048: CALL_OW 109
// continue ;
36052: GO 35876
// end ; if IsInUnit ( j ) then
36054: LD_VAR 0 3
36058: PPUSH
36059: CALL_OW 310
36063: IFFALSE 36074
// ComExitBuilding ( j ) ;
36065: LD_VAR 0 3
36069: PPUSH
36070: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36074: LD_ADDR_VAR 0 6
36078: PUSH
36079: LD_VAR 0 7
36083: PPUSH
36084: LD_VAR 0 3
36088: PPUSH
36089: CALL_OW 74
36093: ST_TO_ADDR
// if not ape then
36094: LD_VAR 0 6
36098: NOT
36099: IFFALSE 36103
// break ;
36101: GO 36213
// x := GetX ( ape ) ;
36103: LD_ADDR_VAR 0 4
36107: PUSH
36108: LD_VAR 0 6
36112: PPUSH
36113: CALL_OW 250
36117: ST_TO_ADDR
// y := GetY ( ape ) ;
36118: LD_ADDR_VAR 0 5
36122: PUSH
36123: LD_VAR 0 6
36127: PPUSH
36128: CALL_OW 251
36132: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36133: LD_VAR 0 4
36137: PPUSH
36138: LD_VAR 0 5
36142: PPUSH
36143: CALL_OW 488
36147: NOT
36148: PUSH
36149: LD_VAR 0 11
36153: PPUSH
36154: LD_VAR 0 4
36158: PPUSH
36159: LD_VAR 0 5
36163: PPUSH
36164: LD_INT 20
36166: PPUSH
36167: CALL 55395 0 4
36171: PUSH
36172: LD_INT 4
36174: ARRAY
36175: OR
36176: IFFALSE 36180
// break ;
36178: GO 36213
// if not HasTask ( j ) then
36180: LD_VAR 0 3
36184: PPUSH
36185: CALL_OW 314
36189: NOT
36190: IFFALSE 36211
// ComTameXY ( j , x , y ) ;
36192: LD_VAR 0 3
36196: PPUSH
36197: LD_VAR 0 4
36201: PPUSH
36202: LD_VAR 0 5
36206: PPUSH
36207: CALL_OW 131
// end ; end ;
36211: GO 35876
36213: POP
36214: POP
// end ;
36215: GO 35432
36217: POP
36218: POP
// end ;
36219: LD_VAR 0 1
36223: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36224: LD_INT 0
36226: PPUSH
36227: PPUSH
36228: PPUSH
36229: PPUSH
36230: PPUSH
36231: PPUSH
36232: PPUSH
36233: PPUSH
// if not mc_bases then
36234: LD_EXP 50
36238: NOT
36239: IFFALSE 36243
// exit ;
36241: GO 36869
// for i = 1 to mc_bases do
36243: LD_ADDR_VAR 0 2
36247: PUSH
36248: DOUBLE
36249: LD_INT 1
36251: DEC
36252: ST_TO_ADDR
36253: LD_EXP 50
36257: PUSH
36258: FOR_TO
36259: IFFALSE 36867
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36261: LD_EXP 79
36265: PUSH
36266: LD_VAR 0 2
36270: ARRAY
36271: NOT
36272: PUSH
36273: LD_EXP 79
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PPUSH
36284: LD_INT 25
36286: PUSH
36287: LD_INT 12
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 72
36298: NOT
36299: OR
36300: IFFALSE 36304
// continue ;
36302: GO 36258
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36304: LD_ADDR_VAR 0 5
36308: PUSH
36309: LD_EXP 79
36313: PUSH
36314: LD_VAR 0 2
36318: ARRAY
36319: PUSH
36320: LD_INT 1
36322: ARRAY
36323: PPUSH
36324: CALL_OW 255
36328: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36329: LD_VAR 0 5
36333: PPUSH
36334: LD_INT 2
36336: PPUSH
36337: CALL_OW 325
36341: IFFALSE 36594
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36343: LD_ADDR_VAR 0 4
36347: PUSH
36348: LD_EXP 79
36352: PUSH
36353: LD_VAR 0 2
36357: ARRAY
36358: PPUSH
36359: LD_INT 25
36361: PUSH
36362: LD_INT 16
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PPUSH
36369: CALL_OW 72
36373: ST_TO_ADDR
// if tmp < 6 then
36374: LD_VAR 0 4
36378: PUSH
36379: LD_INT 6
36381: LESS
36382: IFFALSE 36594
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36384: LD_ADDR_VAR 0 6
36388: PUSH
36389: LD_EXP 50
36393: PUSH
36394: LD_VAR 0 2
36398: ARRAY
36399: PPUSH
36400: LD_INT 2
36402: PUSH
36403: LD_INT 30
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 30
36415: PUSH
36416: LD_INT 1
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: LIST
36427: PPUSH
36428: CALL_OW 72
36432: ST_TO_ADDR
// if depot then
36433: LD_VAR 0 6
36437: IFFALSE 36594
// begin selected := 0 ;
36439: LD_ADDR_VAR 0 7
36443: PUSH
36444: LD_INT 0
36446: ST_TO_ADDR
// for j in depot do
36447: LD_ADDR_VAR 0 3
36451: PUSH
36452: LD_VAR 0 6
36456: PUSH
36457: FOR_IN
36458: IFFALSE 36489
// begin if UnitsInside ( j ) < 6 then
36460: LD_VAR 0 3
36464: PPUSH
36465: CALL_OW 313
36469: PUSH
36470: LD_INT 6
36472: LESS
36473: IFFALSE 36487
// begin selected := j ;
36475: LD_ADDR_VAR 0 7
36479: PUSH
36480: LD_VAR 0 3
36484: ST_TO_ADDR
// break ;
36485: GO 36489
// end ; end ;
36487: GO 36457
36489: POP
36490: POP
// if selected then
36491: LD_VAR 0 7
36495: IFFALSE 36594
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36497: LD_ADDR_VAR 0 3
36501: PUSH
36502: LD_EXP 79
36506: PUSH
36507: LD_VAR 0 2
36511: ARRAY
36512: PPUSH
36513: LD_INT 25
36515: PUSH
36516: LD_INT 12
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PPUSH
36523: CALL_OW 72
36527: PUSH
36528: FOR_IN
36529: IFFALSE 36592
// if not HasTask ( j ) then
36531: LD_VAR 0 3
36535: PPUSH
36536: CALL_OW 314
36540: NOT
36541: IFFALSE 36590
// begin if not IsInUnit ( j ) then
36543: LD_VAR 0 3
36547: PPUSH
36548: CALL_OW 310
36552: NOT
36553: IFFALSE 36569
// ComEnterUnit ( j , selected ) ;
36555: LD_VAR 0 3
36559: PPUSH
36560: LD_VAR 0 7
36564: PPUSH
36565: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36569: LD_VAR 0 3
36573: PPUSH
36574: LD_INT 16
36576: PPUSH
36577: CALL_OW 183
// AddComExitBuilding ( j ) ;
36581: LD_VAR 0 3
36585: PPUSH
36586: CALL_OW 182
// end ;
36590: GO 36528
36592: POP
36593: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36594: LD_VAR 0 5
36598: PPUSH
36599: LD_INT 11
36601: PPUSH
36602: CALL_OW 325
36606: IFFALSE 36865
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36608: LD_ADDR_VAR 0 4
36612: PUSH
36613: LD_EXP 79
36617: PUSH
36618: LD_VAR 0 2
36622: ARRAY
36623: PPUSH
36624: LD_INT 25
36626: PUSH
36627: LD_INT 16
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PPUSH
36634: CALL_OW 72
36638: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36639: LD_VAR 0 4
36643: PUSH
36644: LD_INT 6
36646: GREATEREQUAL
36647: PUSH
36648: LD_VAR 0 5
36652: PPUSH
36653: LD_INT 2
36655: PPUSH
36656: CALL_OW 325
36660: NOT
36661: OR
36662: IFFALSE 36865
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36664: LD_ADDR_VAR 0 8
36668: PUSH
36669: LD_EXP 50
36673: PUSH
36674: LD_VAR 0 2
36678: ARRAY
36679: PPUSH
36680: LD_INT 2
36682: PUSH
36683: LD_INT 30
36685: PUSH
36686: LD_INT 4
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 30
36695: PUSH
36696: LD_INT 5
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: LIST
36707: PPUSH
36708: CALL_OW 72
36712: ST_TO_ADDR
// if barracks then
36713: LD_VAR 0 8
36717: IFFALSE 36865
// begin selected := 0 ;
36719: LD_ADDR_VAR 0 7
36723: PUSH
36724: LD_INT 0
36726: ST_TO_ADDR
// for j in barracks do
36727: LD_ADDR_VAR 0 3
36731: PUSH
36732: LD_VAR 0 8
36736: PUSH
36737: FOR_IN
36738: IFFALSE 36769
// begin if UnitsInside ( j ) < 6 then
36740: LD_VAR 0 3
36744: PPUSH
36745: CALL_OW 313
36749: PUSH
36750: LD_INT 6
36752: LESS
36753: IFFALSE 36767
// begin selected := j ;
36755: LD_ADDR_VAR 0 7
36759: PUSH
36760: LD_VAR 0 3
36764: ST_TO_ADDR
// break ;
36765: GO 36769
// end ; end ;
36767: GO 36737
36769: POP
36770: POP
// if selected then
36771: LD_VAR 0 7
36775: IFFALSE 36865
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36777: LD_ADDR_VAR 0 3
36781: PUSH
36782: LD_EXP 79
36786: PUSH
36787: LD_VAR 0 2
36791: ARRAY
36792: PPUSH
36793: LD_INT 25
36795: PUSH
36796: LD_INT 12
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PPUSH
36803: CALL_OW 72
36807: PUSH
36808: FOR_IN
36809: IFFALSE 36863
// if not IsInUnit ( j ) and not HasTask ( j ) then
36811: LD_VAR 0 3
36815: PPUSH
36816: CALL_OW 310
36820: NOT
36821: PUSH
36822: LD_VAR 0 3
36826: PPUSH
36827: CALL_OW 314
36831: NOT
36832: AND
36833: IFFALSE 36861
// begin ComEnterUnit ( j , selected ) ;
36835: LD_VAR 0 3
36839: PPUSH
36840: LD_VAR 0 7
36844: PPUSH
36845: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36849: LD_VAR 0 3
36853: PPUSH
36854: LD_INT 15
36856: PPUSH
36857: CALL_OW 183
// end ;
36861: GO 36808
36863: POP
36864: POP
// end ; end ; end ; end ; end ;
36865: GO 36258
36867: POP
36868: POP
// end ;
36869: LD_VAR 0 1
36873: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36874: LD_INT 0
36876: PPUSH
36877: PPUSH
36878: PPUSH
36879: PPUSH
// if not mc_bases then
36880: LD_EXP 50
36884: NOT
36885: IFFALSE 36889
// exit ;
36887: GO 37067
// for i = 1 to mc_bases do
36889: LD_ADDR_VAR 0 2
36893: PUSH
36894: DOUBLE
36895: LD_INT 1
36897: DEC
36898: ST_TO_ADDR
36899: LD_EXP 50
36903: PUSH
36904: FOR_TO
36905: IFFALSE 37065
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36907: LD_ADDR_VAR 0 4
36911: PUSH
36912: LD_EXP 50
36916: PUSH
36917: LD_VAR 0 2
36921: ARRAY
36922: PPUSH
36923: LD_INT 25
36925: PUSH
36926: LD_INT 9
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PPUSH
36933: CALL_OW 72
36937: ST_TO_ADDR
// if not tmp then
36938: LD_VAR 0 4
36942: NOT
36943: IFFALSE 36947
// continue ;
36945: GO 36904
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
36947: LD_EXP 76
36951: PUSH
36952: LD_VAR 0 2
36956: ARRAY
36957: PPUSH
36958: LD_INT 29
36960: PPUSH
36961: CALL_OW 325
36965: NOT
36966: PUSH
36967: LD_EXP 76
36971: PUSH
36972: LD_VAR 0 2
36976: ARRAY
36977: PPUSH
36978: LD_INT 28
36980: PPUSH
36981: CALL_OW 325
36985: NOT
36986: AND
36987: IFFALSE 36991
// continue ;
36989: GO 36904
// for j in tmp do
36991: LD_ADDR_VAR 0 3
36995: PUSH
36996: LD_VAR 0 4
37000: PUSH
37001: FOR_IN
37002: IFFALSE 37061
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37004: LD_VAR 0 3
37008: PUSH
37009: LD_EXP 53
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_INT 1
37022: ARRAY
37023: IN
37024: NOT
37025: PUSH
37026: LD_VAR 0 3
37030: PUSH
37031: LD_EXP 53
37035: PUSH
37036: LD_VAR 0 2
37040: ARRAY
37041: PUSH
37042: LD_INT 2
37044: ARRAY
37045: IN
37046: NOT
37047: AND
37048: IFFALSE 37059
// ComSpaceTimeShoot ( j ) ;
37050: LD_VAR 0 3
37054: PPUSH
37055: CALL 48085 0 1
37059: GO 37001
37061: POP
37062: POP
// end ;
37063: GO 36904
37065: POP
37066: POP
// end ;
37067: LD_VAR 0 1
37071: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37072: LD_INT 0
37074: PPUSH
37075: PPUSH
37076: PPUSH
37077: PPUSH
37078: PPUSH
37079: PPUSH
37080: PPUSH
37081: PPUSH
37082: PPUSH
// if not mc_bases then
37083: LD_EXP 50
37087: NOT
37088: IFFALSE 37092
// exit ;
37090: GO 37714
// for i = 1 to mc_bases do
37092: LD_ADDR_VAR 0 2
37096: PUSH
37097: DOUBLE
37098: LD_INT 1
37100: DEC
37101: ST_TO_ADDR
37102: LD_EXP 50
37106: PUSH
37107: FOR_TO
37108: IFFALSE 37712
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37110: LD_EXP 85
37114: PUSH
37115: LD_VAR 0 2
37119: ARRAY
37120: NOT
37121: PUSH
37122: LD_INT 38
37124: PPUSH
37125: LD_EXP 76
37129: PUSH
37130: LD_VAR 0 2
37134: ARRAY
37135: PPUSH
37136: CALL_OW 321
37140: PUSH
37141: LD_INT 2
37143: NONEQUAL
37144: OR
37145: IFFALSE 37149
// continue ;
37147: GO 37107
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37149: LD_ADDR_VAR 0 8
37153: PUSH
37154: LD_EXP 50
37158: PUSH
37159: LD_VAR 0 2
37163: ARRAY
37164: PPUSH
37165: LD_INT 30
37167: PUSH
37168: LD_INT 34
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: PPUSH
37175: CALL_OW 72
37179: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37180: LD_ADDR_VAR 0 9
37184: PUSH
37185: LD_EXP 50
37189: PUSH
37190: LD_VAR 0 2
37194: ARRAY
37195: PPUSH
37196: LD_INT 25
37198: PUSH
37199: LD_INT 4
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PPUSH
37206: CALL_OW 72
37210: PPUSH
37211: LD_INT 0
37213: PPUSH
37214: CALL 87762 0 2
37218: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37219: LD_VAR 0 9
37223: NOT
37224: PUSH
37225: LD_VAR 0 8
37229: NOT
37230: OR
37231: PUSH
37232: LD_EXP 50
37236: PUSH
37237: LD_VAR 0 2
37241: ARRAY
37242: PPUSH
37243: LD_INT 124
37245: PPUSH
37246: CALL 87762 0 2
37250: OR
37251: IFFALSE 37255
// continue ;
37253: GO 37107
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37255: LD_EXP 86
37259: PUSH
37260: LD_VAR 0 2
37264: ARRAY
37265: PUSH
37266: LD_EXP 85
37270: PUSH
37271: LD_VAR 0 2
37275: ARRAY
37276: LESS
37277: PUSH
37278: LD_EXP 86
37282: PUSH
37283: LD_VAR 0 2
37287: ARRAY
37288: PUSH
37289: LD_VAR 0 8
37293: LESS
37294: AND
37295: IFFALSE 37710
// begin tmp := sci [ 1 ] ;
37297: LD_ADDR_VAR 0 7
37301: PUSH
37302: LD_VAR 0 9
37306: PUSH
37307: LD_INT 1
37309: ARRAY
37310: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37311: LD_VAR 0 7
37315: PPUSH
37316: LD_INT 124
37318: PPUSH
37319: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37323: LD_ADDR_VAR 0 3
37327: PUSH
37328: DOUBLE
37329: LD_EXP 85
37333: PUSH
37334: LD_VAR 0 2
37338: ARRAY
37339: INC
37340: ST_TO_ADDR
37341: LD_EXP 85
37345: PUSH
37346: LD_VAR 0 2
37350: ARRAY
37351: PUSH
37352: FOR_DOWNTO
37353: IFFALSE 37696
// begin if IsInUnit ( tmp ) then
37355: LD_VAR 0 7
37359: PPUSH
37360: CALL_OW 310
37364: IFFALSE 37375
// ComExitBuilding ( tmp ) ;
37366: LD_VAR 0 7
37370: PPUSH
37371: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37375: LD_INT 35
37377: PPUSH
37378: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37382: LD_VAR 0 7
37386: PPUSH
37387: CALL_OW 310
37391: NOT
37392: PUSH
37393: LD_VAR 0 7
37397: PPUSH
37398: CALL_OW 314
37402: NOT
37403: AND
37404: IFFALSE 37375
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37406: LD_ADDR_VAR 0 6
37410: PUSH
37411: LD_VAR 0 7
37415: PPUSH
37416: CALL_OW 250
37420: PUSH
37421: LD_VAR 0 7
37425: PPUSH
37426: CALL_OW 251
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37435: LD_INT 35
37437: PPUSH
37438: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37442: LD_ADDR_VAR 0 4
37446: PUSH
37447: LD_EXP 85
37451: PUSH
37452: LD_VAR 0 2
37456: ARRAY
37457: PUSH
37458: LD_VAR 0 3
37462: ARRAY
37463: PUSH
37464: LD_INT 1
37466: ARRAY
37467: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37468: LD_ADDR_VAR 0 5
37472: PUSH
37473: LD_EXP 85
37477: PUSH
37478: LD_VAR 0 2
37482: ARRAY
37483: PUSH
37484: LD_VAR 0 3
37488: ARRAY
37489: PUSH
37490: LD_INT 2
37492: ARRAY
37493: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37494: LD_VAR 0 7
37498: PPUSH
37499: LD_INT 10
37501: PPUSH
37502: CALL 57092 0 2
37506: PUSH
37507: LD_INT 4
37509: ARRAY
37510: IFFALSE 37548
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37512: LD_VAR 0 7
37516: PPUSH
37517: LD_VAR 0 6
37521: PUSH
37522: LD_INT 1
37524: ARRAY
37525: PPUSH
37526: LD_VAR 0 6
37530: PUSH
37531: LD_INT 2
37533: ARRAY
37534: PPUSH
37535: CALL_OW 111
// wait ( 0 0$10 ) ;
37539: LD_INT 350
37541: PPUSH
37542: CALL_OW 67
// end else
37546: GO 37574
// begin ComMoveXY ( tmp , x , y ) ;
37548: LD_VAR 0 7
37552: PPUSH
37553: LD_VAR 0 4
37557: PPUSH
37558: LD_VAR 0 5
37562: PPUSH
37563: CALL_OW 111
// wait ( 0 0$3 ) ;
37567: LD_INT 105
37569: PPUSH
37570: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37574: LD_VAR 0 7
37578: PPUSH
37579: LD_VAR 0 4
37583: PPUSH
37584: LD_VAR 0 5
37588: PPUSH
37589: CALL_OW 307
37593: IFFALSE 37435
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37595: LD_VAR 0 7
37599: PPUSH
37600: LD_VAR 0 4
37604: PPUSH
37605: LD_VAR 0 5
37609: PPUSH
37610: LD_VAR 0 8
37614: PUSH
37615: LD_VAR 0 3
37619: ARRAY
37620: PPUSH
37621: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37625: LD_INT 35
37627: PPUSH
37628: CALL_OW 67
// until not HasTask ( tmp ) ;
37632: LD_VAR 0 7
37636: PPUSH
37637: CALL_OW 314
37641: NOT
37642: IFFALSE 37625
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37644: LD_ADDR_EXP 86
37648: PUSH
37649: LD_EXP 86
37653: PPUSH
37654: LD_VAR 0 2
37658: PUSH
37659: LD_EXP 86
37663: PUSH
37664: LD_VAR 0 2
37668: ARRAY
37669: PUSH
37670: LD_INT 1
37672: PLUS
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PPUSH
37678: LD_VAR 0 8
37682: PUSH
37683: LD_VAR 0 3
37687: ARRAY
37688: PPUSH
37689: CALL 54499 0 3
37693: ST_TO_ADDR
// end ;
37694: GO 37352
37696: POP
37697: POP
// MC_Reset ( i , 124 ) ;
37698: LD_VAR 0 2
37702: PPUSH
37703: LD_INT 124
37705: PPUSH
37706: CALL 21301 0 2
// end ; end ;
37710: GO 37107
37712: POP
37713: POP
// end ;
37714: LD_VAR 0 1
37718: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37719: LD_INT 0
37721: PPUSH
37722: PPUSH
37723: PPUSH
// if not mc_bases then
37724: LD_EXP 50
37728: NOT
37729: IFFALSE 37733
// exit ;
37731: GO 38339
// for i = 1 to mc_bases do
37733: LD_ADDR_VAR 0 2
37737: PUSH
37738: DOUBLE
37739: LD_INT 1
37741: DEC
37742: ST_TO_ADDR
37743: LD_EXP 50
37747: PUSH
37748: FOR_TO
37749: IFFALSE 38337
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37751: LD_ADDR_VAR 0 3
37755: PUSH
37756: LD_EXP 50
37760: PUSH
37761: LD_VAR 0 2
37765: ARRAY
37766: PPUSH
37767: LD_INT 25
37769: PUSH
37770: LD_INT 4
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PPUSH
37777: CALL_OW 72
37781: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37782: LD_VAR 0 3
37786: NOT
37787: PUSH
37788: LD_EXP 87
37792: PUSH
37793: LD_VAR 0 2
37797: ARRAY
37798: NOT
37799: OR
37800: PUSH
37801: LD_EXP 50
37805: PUSH
37806: LD_VAR 0 2
37810: ARRAY
37811: PPUSH
37812: LD_INT 2
37814: PUSH
37815: LD_INT 30
37817: PUSH
37818: LD_INT 0
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 30
37827: PUSH
37828: LD_INT 1
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: LIST
37839: PPUSH
37840: CALL_OW 72
37844: NOT
37845: OR
37846: IFFALSE 37896
// begin if mc_deposits_finder [ i ] then
37848: LD_EXP 88
37852: PUSH
37853: LD_VAR 0 2
37857: ARRAY
37858: IFFALSE 37894
// begin MC_Reset ( i , 125 ) ;
37860: LD_VAR 0 2
37864: PPUSH
37865: LD_INT 125
37867: PPUSH
37868: CALL 21301 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37872: LD_ADDR_EXP 88
37876: PUSH
37877: LD_EXP 88
37881: PPUSH
37882: LD_VAR 0 2
37886: PPUSH
37887: EMPTY
37888: PPUSH
37889: CALL_OW 1
37893: ST_TO_ADDR
// end ; continue ;
37894: GO 37748
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37896: LD_EXP 87
37900: PUSH
37901: LD_VAR 0 2
37905: ARRAY
37906: PUSH
37907: LD_INT 1
37909: ARRAY
37910: PUSH
37911: LD_INT 3
37913: ARRAY
37914: PUSH
37915: LD_INT 1
37917: EQUAL
37918: PUSH
37919: LD_INT 20
37921: PPUSH
37922: LD_EXP 76
37926: PUSH
37927: LD_VAR 0 2
37931: ARRAY
37932: PPUSH
37933: CALL_OW 321
37937: PUSH
37938: LD_INT 2
37940: NONEQUAL
37941: AND
37942: IFFALSE 37992
// begin if mc_deposits_finder [ i ] then
37944: LD_EXP 88
37948: PUSH
37949: LD_VAR 0 2
37953: ARRAY
37954: IFFALSE 37990
// begin MC_Reset ( i , 125 ) ;
37956: LD_VAR 0 2
37960: PPUSH
37961: LD_INT 125
37963: PPUSH
37964: CALL 21301 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37968: LD_ADDR_EXP 88
37972: PUSH
37973: LD_EXP 88
37977: PPUSH
37978: LD_VAR 0 2
37982: PPUSH
37983: EMPTY
37984: PPUSH
37985: CALL_OW 1
37989: ST_TO_ADDR
// end ; continue ;
37990: GO 37748
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
37992: LD_EXP 87
37996: PUSH
37997: LD_VAR 0 2
38001: ARRAY
38002: PUSH
38003: LD_INT 1
38005: ARRAY
38006: PUSH
38007: LD_INT 1
38009: ARRAY
38010: PPUSH
38011: LD_EXP 87
38015: PUSH
38016: LD_VAR 0 2
38020: ARRAY
38021: PUSH
38022: LD_INT 1
38024: ARRAY
38025: PUSH
38026: LD_INT 2
38028: ARRAY
38029: PPUSH
38030: LD_EXP 76
38034: PUSH
38035: LD_VAR 0 2
38039: ARRAY
38040: PPUSH
38041: CALL_OW 440
38045: IFFALSE 38088
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38047: LD_ADDR_EXP 87
38051: PUSH
38052: LD_EXP 87
38056: PPUSH
38057: LD_VAR 0 2
38061: PPUSH
38062: LD_EXP 87
38066: PUSH
38067: LD_VAR 0 2
38071: ARRAY
38072: PPUSH
38073: LD_INT 1
38075: PPUSH
38076: CALL_OW 3
38080: PPUSH
38081: CALL_OW 1
38085: ST_TO_ADDR
38086: GO 38335
// begin if not mc_deposits_finder [ i ] then
38088: LD_EXP 88
38092: PUSH
38093: LD_VAR 0 2
38097: ARRAY
38098: NOT
38099: IFFALSE 38151
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38101: LD_ADDR_EXP 88
38105: PUSH
38106: LD_EXP 88
38110: PPUSH
38111: LD_VAR 0 2
38115: PPUSH
38116: LD_VAR 0 3
38120: PUSH
38121: LD_INT 1
38123: ARRAY
38124: PUSH
38125: EMPTY
38126: LIST
38127: PPUSH
38128: CALL_OW 1
38132: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38133: LD_VAR 0 3
38137: PUSH
38138: LD_INT 1
38140: ARRAY
38141: PPUSH
38142: LD_INT 125
38144: PPUSH
38145: CALL_OW 109
// end else
38149: GO 38335
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38151: LD_EXP 88
38155: PUSH
38156: LD_VAR 0 2
38160: ARRAY
38161: PUSH
38162: LD_INT 1
38164: ARRAY
38165: PPUSH
38166: CALL_OW 310
38170: IFFALSE 38193
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38172: LD_EXP 88
38176: PUSH
38177: LD_VAR 0 2
38181: ARRAY
38182: PUSH
38183: LD_INT 1
38185: ARRAY
38186: PPUSH
38187: CALL_OW 122
38191: GO 38335
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38193: LD_EXP 88
38197: PUSH
38198: LD_VAR 0 2
38202: ARRAY
38203: PUSH
38204: LD_INT 1
38206: ARRAY
38207: PPUSH
38208: CALL_OW 314
38212: NOT
38213: PUSH
38214: LD_EXP 88
38218: PUSH
38219: LD_VAR 0 2
38223: ARRAY
38224: PUSH
38225: LD_INT 1
38227: ARRAY
38228: PPUSH
38229: LD_EXP 87
38233: PUSH
38234: LD_VAR 0 2
38238: ARRAY
38239: PUSH
38240: LD_INT 1
38242: ARRAY
38243: PUSH
38244: LD_INT 1
38246: ARRAY
38247: PPUSH
38248: LD_EXP 87
38252: PUSH
38253: LD_VAR 0 2
38257: ARRAY
38258: PUSH
38259: LD_INT 1
38261: ARRAY
38262: PUSH
38263: LD_INT 2
38265: ARRAY
38266: PPUSH
38267: CALL_OW 297
38271: PUSH
38272: LD_INT 6
38274: GREATER
38275: AND
38276: IFFALSE 38335
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38278: LD_EXP 88
38282: PUSH
38283: LD_VAR 0 2
38287: ARRAY
38288: PUSH
38289: LD_INT 1
38291: ARRAY
38292: PPUSH
38293: LD_EXP 87
38297: PUSH
38298: LD_VAR 0 2
38302: ARRAY
38303: PUSH
38304: LD_INT 1
38306: ARRAY
38307: PUSH
38308: LD_INT 1
38310: ARRAY
38311: PPUSH
38312: LD_EXP 87
38316: PUSH
38317: LD_VAR 0 2
38321: ARRAY
38322: PUSH
38323: LD_INT 1
38325: ARRAY
38326: PUSH
38327: LD_INT 2
38329: ARRAY
38330: PPUSH
38331: CALL_OW 111
// end ; end ; end ;
38335: GO 37748
38337: POP
38338: POP
// end ;
38339: LD_VAR 0 1
38343: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38344: LD_INT 0
38346: PPUSH
38347: PPUSH
38348: PPUSH
38349: PPUSH
38350: PPUSH
38351: PPUSH
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
// if not mc_bases then
38357: LD_EXP 50
38361: NOT
38362: IFFALSE 38366
// exit ;
38364: GO 39306
// for i = 1 to mc_bases do
38366: LD_ADDR_VAR 0 2
38370: PUSH
38371: DOUBLE
38372: LD_INT 1
38374: DEC
38375: ST_TO_ADDR
38376: LD_EXP 50
38380: PUSH
38381: FOR_TO
38382: IFFALSE 39304
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38384: LD_EXP 50
38388: PUSH
38389: LD_VAR 0 2
38393: ARRAY
38394: NOT
38395: PUSH
38396: LD_EXP 73
38400: PUSH
38401: LD_VAR 0 2
38405: ARRAY
38406: OR
38407: IFFALSE 38411
// continue ;
38409: GO 38381
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38411: LD_ADDR_VAR 0 7
38415: PUSH
38416: LD_EXP 50
38420: PUSH
38421: LD_VAR 0 2
38425: ARRAY
38426: PUSH
38427: LD_INT 1
38429: ARRAY
38430: PPUSH
38431: CALL_OW 248
38435: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38436: LD_VAR 0 7
38440: PUSH
38441: LD_INT 3
38443: EQUAL
38444: PUSH
38445: LD_EXP 69
38449: PUSH
38450: LD_VAR 0 2
38454: ARRAY
38455: PUSH
38456: LD_EXP 72
38460: PUSH
38461: LD_VAR 0 2
38465: ARRAY
38466: UNION
38467: PPUSH
38468: LD_INT 33
38470: PUSH
38471: LD_INT 2
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PPUSH
38478: CALL_OW 72
38482: NOT
38483: OR
38484: IFFALSE 38488
// continue ;
38486: GO 38381
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38488: LD_ADDR_VAR 0 9
38492: PUSH
38493: LD_EXP 50
38497: PUSH
38498: LD_VAR 0 2
38502: ARRAY
38503: PPUSH
38504: LD_INT 30
38506: PUSH
38507: LD_INT 36
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PPUSH
38514: CALL_OW 72
38518: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38519: LD_ADDR_VAR 0 10
38523: PUSH
38524: LD_EXP 69
38528: PUSH
38529: LD_VAR 0 2
38533: ARRAY
38534: PPUSH
38535: LD_INT 34
38537: PUSH
38538: LD_INT 31
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PPUSH
38545: CALL_OW 72
38549: ST_TO_ADDR
// if not cts and not mcts then
38550: LD_VAR 0 9
38554: NOT
38555: PUSH
38556: LD_VAR 0 10
38560: NOT
38561: AND
38562: IFFALSE 38566
// continue ;
38564: GO 38381
// x := cts ;
38566: LD_ADDR_VAR 0 11
38570: PUSH
38571: LD_VAR 0 9
38575: ST_TO_ADDR
// if not x then
38576: LD_VAR 0 11
38580: NOT
38581: IFFALSE 38593
// x := mcts ;
38583: LD_ADDR_VAR 0 11
38587: PUSH
38588: LD_VAR 0 10
38592: ST_TO_ADDR
// if not x then
38593: LD_VAR 0 11
38597: NOT
38598: IFFALSE 38602
// continue ;
38600: GO 38381
// if mc_remote_driver [ i ] then
38602: LD_EXP 90
38606: PUSH
38607: LD_VAR 0 2
38611: ARRAY
38612: IFFALSE 38999
// for j in mc_remote_driver [ i ] do
38614: LD_ADDR_VAR 0 3
38618: PUSH
38619: LD_EXP 90
38623: PUSH
38624: LD_VAR 0 2
38628: ARRAY
38629: PUSH
38630: FOR_IN
38631: IFFALSE 38997
// begin if GetClass ( j ) <> 3 then
38633: LD_VAR 0 3
38637: PPUSH
38638: CALL_OW 257
38642: PUSH
38643: LD_INT 3
38645: NONEQUAL
38646: IFFALSE 38699
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38648: LD_ADDR_EXP 90
38652: PUSH
38653: LD_EXP 90
38657: PPUSH
38658: LD_VAR 0 2
38662: PPUSH
38663: LD_EXP 90
38667: PUSH
38668: LD_VAR 0 2
38672: ARRAY
38673: PUSH
38674: LD_VAR 0 3
38678: DIFF
38679: PPUSH
38680: CALL_OW 1
38684: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38685: LD_VAR 0 3
38689: PPUSH
38690: LD_INT 0
38692: PPUSH
38693: CALL_OW 109
// continue ;
38697: GO 38630
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38699: LD_EXP 69
38703: PUSH
38704: LD_VAR 0 2
38708: ARRAY
38709: PPUSH
38710: LD_INT 34
38712: PUSH
38713: LD_INT 31
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 58
38722: PUSH
38723: EMPTY
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PPUSH
38730: CALL_OW 72
38734: PUSH
38735: LD_VAR 0 3
38739: PPUSH
38740: CALL 87850 0 1
38744: NOT
38745: AND
38746: IFFALSE 38817
// begin if IsInUnit ( j ) then
38748: LD_VAR 0 3
38752: PPUSH
38753: CALL_OW 310
38757: IFFALSE 38768
// ComExitBuilding ( j ) ;
38759: LD_VAR 0 3
38763: PPUSH
38764: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38768: LD_VAR 0 3
38772: PPUSH
38773: LD_EXP 69
38777: PUSH
38778: LD_VAR 0 2
38782: ARRAY
38783: PPUSH
38784: LD_INT 34
38786: PUSH
38787: LD_INT 31
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 58
38796: PUSH
38797: EMPTY
38798: LIST
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PPUSH
38804: CALL_OW 72
38808: PUSH
38809: LD_INT 1
38811: ARRAY
38812: PPUSH
38813: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38817: LD_VAR 0 3
38821: PPUSH
38822: CALL_OW 310
38826: NOT
38827: PUSH
38828: LD_VAR 0 3
38832: PPUSH
38833: CALL_OW 310
38837: PPUSH
38838: CALL_OW 266
38842: PUSH
38843: LD_INT 36
38845: NONEQUAL
38846: PUSH
38847: LD_VAR 0 3
38851: PPUSH
38852: CALL 87850 0 1
38856: NOT
38857: AND
38858: OR
38859: IFFALSE 38995
// begin if IsInUnit ( j ) then
38861: LD_VAR 0 3
38865: PPUSH
38866: CALL_OW 310
38870: IFFALSE 38881
// ComExitBuilding ( j ) ;
38872: LD_VAR 0 3
38876: PPUSH
38877: CALL_OW 122
// ct := 0 ;
38881: LD_ADDR_VAR 0 8
38885: PUSH
38886: LD_INT 0
38888: ST_TO_ADDR
// for k in x do
38889: LD_ADDR_VAR 0 4
38893: PUSH
38894: LD_VAR 0 11
38898: PUSH
38899: FOR_IN
38900: IFFALSE 38973
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38902: LD_VAR 0 4
38906: PPUSH
38907: CALL_OW 264
38911: PUSH
38912: LD_INT 31
38914: EQUAL
38915: PUSH
38916: LD_VAR 0 4
38920: PPUSH
38921: CALL_OW 311
38925: NOT
38926: AND
38927: PUSH
38928: LD_VAR 0 4
38932: PPUSH
38933: CALL_OW 266
38937: PUSH
38938: LD_INT 36
38940: EQUAL
38941: PUSH
38942: LD_VAR 0 4
38946: PPUSH
38947: CALL_OW 313
38951: PUSH
38952: LD_INT 3
38954: LESS
38955: AND
38956: OR
38957: IFFALSE 38971
// begin ct := k ;
38959: LD_ADDR_VAR 0 8
38963: PUSH
38964: LD_VAR 0 4
38968: ST_TO_ADDR
// break ;
38969: GO 38973
// end ;
38971: GO 38899
38973: POP
38974: POP
// if ct then
38975: LD_VAR 0 8
38979: IFFALSE 38995
// ComEnterUnit ( j , ct ) ;
38981: LD_VAR 0 3
38985: PPUSH
38986: LD_VAR 0 8
38990: PPUSH
38991: CALL_OW 120
// end ; end ;
38995: GO 38630
38997: POP
38998: POP
// places := 0 ;
38999: LD_ADDR_VAR 0 5
39003: PUSH
39004: LD_INT 0
39006: ST_TO_ADDR
// for j = 1 to x do
39007: LD_ADDR_VAR 0 3
39011: PUSH
39012: DOUBLE
39013: LD_INT 1
39015: DEC
39016: ST_TO_ADDR
39017: LD_VAR 0 11
39021: PUSH
39022: FOR_TO
39023: IFFALSE 39099
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39025: LD_VAR 0 11
39029: PUSH
39030: LD_VAR 0 3
39034: ARRAY
39035: PPUSH
39036: CALL_OW 264
39040: PUSH
39041: LD_INT 31
39043: EQUAL
39044: IFFALSE 39062
// places := places + 1 else
39046: LD_ADDR_VAR 0 5
39050: PUSH
39051: LD_VAR 0 5
39055: PUSH
39056: LD_INT 1
39058: PLUS
39059: ST_TO_ADDR
39060: GO 39097
// if GetBType ( x [ j ] ) = b_control_tower then
39062: LD_VAR 0 11
39066: PUSH
39067: LD_VAR 0 3
39071: ARRAY
39072: PPUSH
39073: CALL_OW 266
39077: PUSH
39078: LD_INT 36
39080: EQUAL
39081: IFFALSE 39097
// places := places + 3 ;
39083: LD_ADDR_VAR 0 5
39087: PUSH
39088: LD_VAR 0 5
39092: PUSH
39093: LD_INT 3
39095: PLUS
39096: ST_TO_ADDR
39097: GO 39022
39099: POP
39100: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39101: LD_VAR 0 5
39105: PUSH
39106: LD_INT 0
39108: EQUAL
39109: PUSH
39110: LD_VAR 0 5
39114: PUSH
39115: LD_EXP 90
39119: PUSH
39120: LD_VAR 0 2
39124: ARRAY
39125: LESSEQUAL
39126: OR
39127: IFFALSE 39131
// continue ;
39129: GO 38381
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39131: LD_ADDR_VAR 0 6
39135: PUSH
39136: LD_EXP 50
39140: PUSH
39141: LD_VAR 0 2
39145: ARRAY
39146: PPUSH
39147: LD_INT 25
39149: PUSH
39150: LD_INT 3
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PPUSH
39157: CALL_OW 72
39161: PUSH
39162: LD_EXP 90
39166: PUSH
39167: LD_VAR 0 2
39171: ARRAY
39172: DIFF
39173: PPUSH
39174: LD_INT 3
39176: PPUSH
39177: CALL 88750 0 2
39181: ST_TO_ADDR
// for j in tmp do
39182: LD_ADDR_VAR 0 3
39186: PUSH
39187: LD_VAR 0 6
39191: PUSH
39192: FOR_IN
39193: IFFALSE 39228
// if GetTag ( j ) > 0 then
39195: LD_VAR 0 3
39199: PPUSH
39200: CALL_OW 110
39204: PUSH
39205: LD_INT 0
39207: GREATER
39208: IFFALSE 39226
// tmp := tmp diff j ;
39210: LD_ADDR_VAR 0 6
39214: PUSH
39215: LD_VAR 0 6
39219: PUSH
39220: LD_VAR 0 3
39224: DIFF
39225: ST_TO_ADDR
39226: GO 39192
39228: POP
39229: POP
// if not tmp then
39230: LD_VAR 0 6
39234: NOT
39235: IFFALSE 39239
// continue ;
39237: GO 38381
// if places then
39239: LD_VAR 0 5
39243: IFFALSE 39302
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39245: LD_ADDR_EXP 90
39249: PUSH
39250: LD_EXP 90
39254: PPUSH
39255: LD_VAR 0 2
39259: PPUSH
39260: LD_EXP 90
39264: PUSH
39265: LD_VAR 0 2
39269: ARRAY
39270: PUSH
39271: LD_VAR 0 6
39275: PUSH
39276: LD_INT 1
39278: ARRAY
39279: UNION
39280: PPUSH
39281: CALL_OW 1
39285: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39286: LD_VAR 0 6
39290: PUSH
39291: LD_INT 1
39293: ARRAY
39294: PPUSH
39295: LD_INT 126
39297: PPUSH
39298: CALL_OW 109
// end ; end ;
39302: GO 38381
39304: POP
39305: POP
// end ;
39306: LD_VAR 0 1
39310: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39311: LD_INT 0
39313: PPUSH
39314: PPUSH
39315: PPUSH
39316: PPUSH
39317: PPUSH
39318: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39319: LD_VAR 0 1
39323: NOT
39324: PUSH
39325: LD_VAR 0 2
39329: NOT
39330: OR
39331: PUSH
39332: LD_VAR 0 3
39336: NOT
39337: OR
39338: PUSH
39339: LD_VAR 0 4
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 3
39352: PUSH
39353: LD_INT 4
39355: PUSH
39356: LD_INT 5
39358: PUSH
39359: LD_INT 8
39361: PUSH
39362: LD_INT 9
39364: PUSH
39365: LD_INT 15
39367: PUSH
39368: LD_INT 16
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: IN
39382: NOT
39383: OR
39384: IFFALSE 39388
// exit ;
39386: GO 40288
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39388: LD_ADDR_VAR 0 2
39392: PUSH
39393: LD_VAR 0 2
39397: PPUSH
39398: LD_INT 21
39400: PUSH
39401: LD_INT 3
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 24
39410: PUSH
39411: LD_INT 250
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PPUSH
39422: CALL_OW 72
39426: ST_TO_ADDR
// case class of 1 , 15 :
39427: LD_VAR 0 4
39431: PUSH
39432: LD_INT 1
39434: DOUBLE
39435: EQUAL
39436: IFTRUE 39446
39438: LD_INT 15
39440: DOUBLE
39441: EQUAL
39442: IFTRUE 39446
39444: GO 39531
39446: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39447: LD_ADDR_VAR 0 8
39451: PUSH
39452: LD_VAR 0 2
39456: PPUSH
39457: LD_INT 2
39459: PUSH
39460: LD_INT 30
39462: PUSH
39463: LD_INT 32
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 30
39472: PUSH
39473: LD_INT 31
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: LIST
39484: PPUSH
39485: CALL_OW 72
39489: PUSH
39490: LD_VAR 0 2
39494: PPUSH
39495: LD_INT 2
39497: PUSH
39498: LD_INT 30
39500: PUSH
39501: LD_INT 4
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 30
39510: PUSH
39511: LD_INT 5
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: LIST
39522: PPUSH
39523: CALL_OW 72
39527: ADD
39528: ST_TO_ADDR
39529: GO 39777
39531: LD_INT 2
39533: DOUBLE
39534: EQUAL
39535: IFTRUE 39545
39537: LD_INT 16
39539: DOUBLE
39540: EQUAL
39541: IFTRUE 39545
39543: GO 39591
39545: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39546: LD_ADDR_VAR 0 8
39550: PUSH
39551: LD_VAR 0 2
39555: PPUSH
39556: LD_INT 2
39558: PUSH
39559: LD_INT 30
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 30
39571: PUSH
39572: LD_INT 1
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: LIST
39583: PPUSH
39584: CALL_OW 72
39588: ST_TO_ADDR
39589: GO 39777
39591: LD_INT 3
39593: DOUBLE
39594: EQUAL
39595: IFTRUE 39599
39597: GO 39645
39599: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39600: LD_ADDR_VAR 0 8
39604: PUSH
39605: LD_VAR 0 2
39609: PPUSH
39610: LD_INT 2
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 2
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 30
39625: PUSH
39626: LD_INT 3
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: LIST
39637: PPUSH
39638: CALL_OW 72
39642: ST_TO_ADDR
39643: GO 39777
39645: LD_INT 4
39647: DOUBLE
39648: EQUAL
39649: IFTRUE 39653
39651: GO 39710
39653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39654: LD_ADDR_VAR 0 8
39658: PUSH
39659: LD_VAR 0 2
39663: PPUSH
39664: LD_INT 2
39666: PUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 6
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 30
39679: PUSH
39680: LD_INT 7
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 30
39689: PUSH
39690: LD_INT 8
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: PPUSH
39703: CALL_OW 72
39707: ST_TO_ADDR
39708: GO 39777
39710: LD_INT 5
39712: DOUBLE
39713: EQUAL
39714: IFTRUE 39730
39716: LD_INT 8
39718: DOUBLE
39719: EQUAL
39720: IFTRUE 39730
39722: LD_INT 9
39724: DOUBLE
39725: EQUAL
39726: IFTRUE 39730
39728: GO 39776
39730: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39731: LD_ADDR_VAR 0 8
39735: PUSH
39736: LD_VAR 0 2
39740: PPUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 30
39746: PUSH
39747: LD_INT 4
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 30
39756: PUSH
39757: LD_INT 5
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: LIST
39768: PPUSH
39769: CALL_OW 72
39773: ST_TO_ADDR
39774: GO 39777
39776: POP
// if not tmp then
39777: LD_VAR 0 8
39781: NOT
39782: IFFALSE 39786
// exit ;
39784: GO 40288
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39786: LD_VAR 0 4
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 15
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: IN
39801: PUSH
39802: LD_EXP 59
39806: PUSH
39807: LD_VAR 0 1
39811: ARRAY
39812: AND
39813: IFFALSE 39969
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39815: LD_ADDR_VAR 0 9
39819: PUSH
39820: LD_EXP 59
39824: PUSH
39825: LD_VAR 0 1
39829: ARRAY
39830: PUSH
39831: LD_INT 1
39833: ARRAY
39834: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39835: LD_VAR 0 9
39839: PUSH
39840: LD_EXP 60
39844: PUSH
39845: LD_VAR 0 1
39849: ARRAY
39850: IN
39851: NOT
39852: IFFALSE 39967
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39854: LD_ADDR_EXP 60
39858: PUSH
39859: LD_EXP 60
39863: PPUSH
39864: LD_VAR 0 1
39868: PUSH
39869: LD_EXP 60
39873: PUSH
39874: LD_VAR 0 1
39878: ARRAY
39879: PUSH
39880: LD_INT 1
39882: PLUS
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PPUSH
39888: LD_VAR 0 9
39892: PPUSH
39893: CALL 54499 0 3
39897: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39898: LD_ADDR_EXP 59
39902: PUSH
39903: LD_EXP 59
39907: PPUSH
39908: LD_VAR 0 1
39912: PPUSH
39913: LD_EXP 59
39917: PUSH
39918: LD_VAR 0 1
39922: ARRAY
39923: PUSH
39924: LD_VAR 0 9
39928: DIFF
39929: PPUSH
39930: CALL_OW 1
39934: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39935: LD_VAR 0 3
39939: PPUSH
39940: LD_EXP 60
39944: PUSH
39945: LD_VAR 0 1
39949: ARRAY
39950: PUSH
39951: LD_EXP 60
39955: PUSH
39956: LD_VAR 0 1
39960: ARRAY
39961: ARRAY
39962: PPUSH
39963: CALL_OW 120
// end ; exit ;
39967: GO 40288
// end ; if tmp > 1 then
39969: LD_VAR 0 8
39973: PUSH
39974: LD_INT 1
39976: GREATER
39977: IFFALSE 40081
// for i = 2 to tmp do
39979: LD_ADDR_VAR 0 6
39983: PUSH
39984: DOUBLE
39985: LD_INT 2
39987: DEC
39988: ST_TO_ADDR
39989: LD_VAR 0 8
39993: PUSH
39994: FOR_TO
39995: IFFALSE 40079
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
39997: LD_VAR 0 8
40001: PUSH
40002: LD_VAR 0 6
40006: ARRAY
40007: PPUSH
40008: CALL_OW 461
40012: PUSH
40013: LD_INT 6
40015: EQUAL
40016: IFFALSE 40077
// begin x := tmp [ i ] ;
40018: LD_ADDR_VAR 0 9
40022: PUSH
40023: LD_VAR 0 8
40027: PUSH
40028: LD_VAR 0 6
40032: ARRAY
40033: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40034: LD_ADDR_VAR 0 8
40038: PUSH
40039: LD_VAR 0 8
40043: PPUSH
40044: LD_VAR 0 6
40048: PPUSH
40049: CALL_OW 3
40053: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40054: LD_ADDR_VAR 0 8
40058: PUSH
40059: LD_VAR 0 8
40063: PPUSH
40064: LD_INT 1
40066: PPUSH
40067: LD_VAR 0 9
40071: PPUSH
40072: CALL_OW 2
40076: ST_TO_ADDR
// end ;
40077: GO 39994
40079: POP
40080: POP
// for i in tmp do
40081: LD_ADDR_VAR 0 6
40085: PUSH
40086: LD_VAR 0 8
40090: PUSH
40091: FOR_IN
40092: IFFALSE 40161
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40094: LD_VAR 0 6
40098: PPUSH
40099: CALL_OW 313
40103: PUSH
40104: LD_INT 6
40106: LESS
40107: PUSH
40108: LD_VAR 0 6
40112: PPUSH
40113: CALL_OW 266
40117: PUSH
40118: LD_INT 31
40120: PUSH
40121: LD_INT 32
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: IN
40128: NOT
40129: AND
40130: PUSH
40131: LD_VAR 0 6
40135: PPUSH
40136: CALL_OW 313
40140: PUSH
40141: LD_INT 0
40143: EQUAL
40144: OR
40145: IFFALSE 40159
// begin j := i ;
40147: LD_ADDR_VAR 0 7
40151: PUSH
40152: LD_VAR 0 6
40156: ST_TO_ADDR
// break ;
40157: GO 40161
// end ; end ;
40159: GO 40091
40161: POP
40162: POP
// if j then
40163: LD_VAR 0 7
40167: IFFALSE 40185
// ComEnterUnit ( unit , j ) else
40169: LD_VAR 0 3
40173: PPUSH
40174: LD_VAR 0 7
40178: PPUSH
40179: CALL_OW 120
40183: GO 40288
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40185: LD_ADDR_VAR 0 10
40189: PUSH
40190: LD_VAR 0 2
40194: PPUSH
40195: LD_INT 2
40197: PUSH
40198: LD_INT 30
40200: PUSH
40201: LD_INT 0
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 30
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: LIST
40222: PPUSH
40223: CALL_OW 72
40227: ST_TO_ADDR
// if depot then
40228: LD_VAR 0 10
40232: IFFALSE 40288
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40234: LD_ADDR_VAR 0 10
40238: PUSH
40239: LD_VAR 0 10
40243: PPUSH
40244: LD_VAR 0 3
40248: PPUSH
40249: CALL_OW 74
40253: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40254: LD_VAR 0 3
40258: PPUSH
40259: LD_VAR 0 10
40263: PPUSH
40264: CALL_OW 296
40268: PUSH
40269: LD_INT 10
40271: GREATER
40272: IFFALSE 40288
// ComStandNearbyBuilding ( unit , depot ) ;
40274: LD_VAR 0 3
40278: PPUSH
40279: LD_VAR 0 10
40283: PPUSH
40284: CALL 48702 0 2
// end ; end ; end ;
40288: LD_VAR 0 5
40292: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40293: LD_INT 0
40295: PPUSH
40296: PPUSH
40297: PPUSH
40298: PPUSH
// if not mc_bases then
40299: LD_EXP 50
40303: NOT
40304: IFFALSE 40308
// exit ;
40306: GO 40547
// for i = 1 to mc_bases do
40308: LD_ADDR_VAR 0 2
40312: PUSH
40313: DOUBLE
40314: LD_INT 1
40316: DEC
40317: ST_TO_ADDR
40318: LD_EXP 50
40322: PUSH
40323: FOR_TO
40324: IFFALSE 40545
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40326: LD_ADDR_VAR 0 4
40330: PUSH
40331: LD_EXP 50
40335: PUSH
40336: LD_VAR 0 2
40340: ARRAY
40341: PPUSH
40342: LD_INT 21
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PPUSH
40352: CALL_OW 72
40356: PUSH
40357: LD_EXP 79
40361: PUSH
40362: LD_VAR 0 2
40366: ARRAY
40367: UNION
40368: ST_TO_ADDR
// if not tmp then
40369: LD_VAR 0 4
40373: NOT
40374: IFFALSE 40378
// continue ;
40376: GO 40323
// for j in tmp do
40378: LD_ADDR_VAR 0 3
40382: PUSH
40383: LD_VAR 0 4
40387: PUSH
40388: FOR_IN
40389: IFFALSE 40541
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40391: LD_VAR 0 3
40395: PPUSH
40396: CALL_OW 110
40400: NOT
40401: PUSH
40402: LD_VAR 0 3
40406: PPUSH
40407: CALL_OW 314
40411: NOT
40412: AND
40413: PUSH
40414: LD_VAR 0 3
40418: PPUSH
40419: CALL_OW 311
40423: NOT
40424: AND
40425: PUSH
40426: LD_VAR 0 3
40430: PPUSH
40431: CALL_OW 310
40435: NOT
40436: AND
40437: PUSH
40438: LD_VAR 0 3
40442: PUSH
40443: LD_EXP 53
40447: PUSH
40448: LD_VAR 0 2
40452: ARRAY
40453: PUSH
40454: LD_INT 1
40456: ARRAY
40457: IN
40458: NOT
40459: AND
40460: PUSH
40461: LD_VAR 0 3
40465: PUSH
40466: LD_EXP 53
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: PUSH
40477: LD_INT 2
40479: ARRAY
40480: IN
40481: NOT
40482: AND
40483: PUSH
40484: LD_VAR 0 3
40488: PUSH
40489: LD_EXP 62
40493: PUSH
40494: LD_VAR 0 2
40498: ARRAY
40499: IN
40500: NOT
40501: AND
40502: IFFALSE 40539
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40504: LD_VAR 0 2
40508: PPUSH
40509: LD_EXP 50
40513: PUSH
40514: LD_VAR 0 2
40518: ARRAY
40519: PPUSH
40520: LD_VAR 0 3
40524: PPUSH
40525: LD_VAR 0 3
40529: PPUSH
40530: CALL_OW 257
40534: PPUSH
40535: CALL 39311 0 4
// end ;
40539: GO 40388
40541: POP
40542: POP
// end ;
40543: GO 40323
40545: POP
40546: POP
// end ;
40547: LD_VAR 0 1
40551: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40552: LD_INT 0
40554: PPUSH
40555: PPUSH
40556: PPUSH
40557: PPUSH
40558: PPUSH
40559: PPUSH
// if not mc_bases [ base ] then
40560: LD_EXP 50
40564: PUSH
40565: LD_VAR 0 1
40569: ARRAY
40570: NOT
40571: IFFALSE 40575
// exit ;
40573: GO 40757
// tmp := [ ] ;
40575: LD_ADDR_VAR 0 6
40579: PUSH
40580: EMPTY
40581: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40582: LD_ADDR_VAR 0 7
40586: PUSH
40587: LD_VAR 0 3
40591: PPUSH
40592: LD_INT 0
40594: PPUSH
40595: CALL_OW 517
40599: ST_TO_ADDR
// if not list then
40600: LD_VAR 0 7
40604: NOT
40605: IFFALSE 40609
// exit ;
40607: GO 40757
// for i = 1 to amount do
40609: LD_ADDR_VAR 0 5
40613: PUSH
40614: DOUBLE
40615: LD_INT 1
40617: DEC
40618: ST_TO_ADDR
40619: LD_VAR 0 2
40623: PUSH
40624: FOR_TO
40625: IFFALSE 40705
// begin x := rand ( 1 , list [ 1 ] ) ;
40627: LD_ADDR_VAR 0 8
40631: PUSH
40632: LD_INT 1
40634: PPUSH
40635: LD_VAR 0 7
40639: PUSH
40640: LD_INT 1
40642: ARRAY
40643: PPUSH
40644: CALL_OW 12
40648: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40649: LD_ADDR_VAR 0 6
40653: PUSH
40654: LD_VAR 0 6
40658: PPUSH
40659: LD_VAR 0 5
40663: PPUSH
40664: LD_VAR 0 7
40668: PUSH
40669: LD_INT 1
40671: ARRAY
40672: PUSH
40673: LD_VAR 0 8
40677: ARRAY
40678: PUSH
40679: LD_VAR 0 7
40683: PUSH
40684: LD_INT 2
40686: ARRAY
40687: PUSH
40688: LD_VAR 0 8
40692: ARRAY
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PPUSH
40698: CALL_OW 1
40702: ST_TO_ADDR
// end ;
40703: GO 40624
40705: POP
40706: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40707: LD_ADDR_EXP 63
40711: PUSH
40712: LD_EXP 63
40716: PPUSH
40717: LD_VAR 0 1
40721: PPUSH
40722: LD_VAR 0 6
40726: PPUSH
40727: CALL_OW 1
40731: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40732: LD_ADDR_EXP 65
40736: PUSH
40737: LD_EXP 65
40741: PPUSH
40742: LD_VAR 0 1
40746: PPUSH
40747: LD_VAR 0 3
40751: PPUSH
40752: CALL_OW 1
40756: ST_TO_ADDR
// end ;
40757: LD_VAR 0 4
40761: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40762: LD_INT 0
40764: PPUSH
// if not mc_bases [ base ] then
40765: LD_EXP 50
40769: PUSH
40770: LD_VAR 0 1
40774: ARRAY
40775: NOT
40776: IFFALSE 40780
// exit ;
40778: GO 40805
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40780: LD_ADDR_EXP 55
40784: PUSH
40785: LD_EXP 55
40789: PPUSH
40790: LD_VAR 0 1
40794: PPUSH
40795: LD_VAR 0 2
40799: PPUSH
40800: CALL_OW 1
40804: ST_TO_ADDR
// end ;
40805: LD_VAR 0 3
40809: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40810: LD_INT 0
40812: PPUSH
// if not mc_bases [ base ] then
40813: LD_EXP 50
40817: PUSH
40818: LD_VAR 0 1
40822: ARRAY
40823: NOT
40824: IFFALSE 40828
// exit ;
40826: GO 40865
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40828: LD_ADDR_EXP 55
40832: PUSH
40833: LD_EXP 55
40837: PPUSH
40838: LD_VAR 0 1
40842: PPUSH
40843: LD_EXP 55
40847: PUSH
40848: LD_VAR 0 1
40852: ARRAY
40853: PUSH
40854: LD_VAR 0 2
40858: UNION
40859: PPUSH
40860: CALL_OW 1
40864: ST_TO_ADDR
// end ;
40865: LD_VAR 0 3
40869: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40870: LD_INT 0
40872: PPUSH
// if not mc_bases [ base ] then
40873: LD_EXP 50
40877: PUSH
40878: LD_VAR 0 1
40882: ARRAY
40883: NOT
40884: IFFALSE 40888
// exit ;
40886: GO 40913
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40888: LD_ADDR_EXP 71
40892: PUSH
40893: LD_EXP 71
40897: PPUSH
40898: LD_VAR 0 1
40902: PPUSH
40903: LD_VAR 0 2
40907: PPUSH
40908: CALL_OW 1
40912: ST_TO_ADDR
// end ;
40913: LD_VAR 0 3
40917: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40918: LD_INT 0
40920: PPUSH
// if not mc_bases [ base ] then
40921: LD_EXP 50
40925: PUSH
40926: LD_VAR 0 1
40930: ARRAY
40931: NOT
40932: IFFALSE 40936
// exit ;
40934: GO 40973
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40936: LD_ADDR_EXP 71
40940: PUSH
40941: LD_EXP 71
40945: PPUSH
40946: LD_VAR 0 1
40950: PPUSH
40951: LD_EXP 71
40955: PUSH
40956: LD_VAR 0 1
40960: ARRAY
40961: PUSH
40962: LD_VAR 0 2
40966: ADD
40967: PPUSH
40968: CALL_OW 1
40972: ST_TO_ADDR
// end ;
40973: LD_VAR 0 3
40977: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
40978: LD_INT 0
40980: PPUSH
// if not mc_bases [ base ] then
40981: LD_EXP 50
40985: PUSH
40986: LD_VAR 0 1
40990: ARRAY
40991: NOT
40992: IFFALSE 40996
// exit ;
40994: GO 41050
// mc_defender := Replace ( mc_defender , base , deflist ) ;
40996: LD_ADDR_EXP 72
41000: PUSH
41001: LD_EXP 72
41005: PPUSH
41006: LD_VAR 0 1
41010: PPUSH
41011: LD_VAR 0 2
41015: PPUSH
41016: CALL_OW 1
41020: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41021: LD_ADDR_EXP 61
41025: PUSH
41026: LD_EXP 61
41030: PPUSH
41031: LD_VAR 0 1
41035: PPUSH
41036: LD_VAR 0 2
41040: PUSH
41041: LD_INT 0
41043: PLUS
41044: PPUSH
41045: CALL_OW 1
41049: ST_TO_ADDR
// end ;
41050: LD_VAR 0 3
41054: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41055: LD_INT 0
41057: PPUSH
// if not mc_bases [ base ] then
41058: LD_EXP 50
41062: PUSH
41063: LD_VAR 0 1
41067: ARRAY
41068: NOT
41069: IFFALSE 41073
// exit ;
41071: GO 41098
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41073: LD_ADDR_EXP 61
41077: PUSH
41078: LD_EXP 61
41082: PPUSH
41083: LD_VAR 0 1
41087: PPUSH
41088: LD_VAR 0 2
41092: PPUSH
41093: CALL_OW 1
41097: ST_TO_ADDR
// end ;
41098: LD_VAR 0 3
41102: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41103: LD_INT 0
41105: PPUSH
41106: PPUSH
41107: PPUSH
41108: PPUSH
// if not mc_bases [ base ] then
41109: LD_EXP 50
41113: PUSH
41114: LD_VAR 0 1
41118: ARRAY
41119: NOT
41120: IFFALSE 41124
// exit ;
41122: GO 41189
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41124: LD_ADDR_EXP 70
41128: PUSH
41129: LD_EXP 70
41133: PPUSH
41134: LD_VAR 0 1
41138: PUSH
41139: LD_EXP 70
41143: PUSH
41144: LD_VAR 0 1
41148: ARRAY
41149: PUSH
41150: LD_INT 1
41152: PLUS
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PPUSH
41158: LD_VAR 0 1
41162: PUSH
41163: LD_VAR 0 2
41167: PUSH
41168: LD_VAR 0 3
41172: PUSH
41173: LD_VAR 0 4
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: PPUSH
41184: CALL 54499 0 3
41188: ST_TO_ADDR
// end ;
41189: LD_VAR 0 5
41193: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41194: LD_INT 0
41196: PPUSH
// if not mc_bases [ base ] then
41197: LD_EXP 50
41201: PUSH
41202: LD_VAR 0 1
41206: ARRAY
41207: NOT
41208: IFFALSE 41212
// exit ;
41210: GO 41237
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41212: LD_ADDR_EXP 87
41216: PUSH
41217: LD_EXP 87
41221: PPUSH
41222: LD_VAR 0 1
41226: PPUSH
41227: LD_VAR 0 2
41231: PPUSH
41232: CALL_OW 1
41236: ST_TO_ADDR
// end ;
41237: LD_VAR 0 3
41241: RET
// export function MC_GetMinesField ( base ) ; begin
41242: LD_INT 0
41244: PPUSH
// result := mc_mines [ base ] ;
41245: LD_ADDR_VAR 0 2
41249: PUSH
41250: LD_EXP 63
41254: PUSH
41255: LD_VAR 0 1
41259: ARRAY
41260: ST_TO_ADDR
// end ;
41261: LD_VAR 0 2
41265: RET
// export function MC_GetProduceList ( base ) ; begin
41266: LD_INT 0
41268: PPUSH
// result := mc_produce [ base ] ;
41269: LD_ADDR_VAR 0 2
41273: PUSH
41274: LD_EXP 71
41278: PUSH
41279: LD_VAR 0 1
41283: ARRAY
41284: ST_TO_ADDR
// end ;
41285: LD_VAR 0 2
41289: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41290: LD_INT 0
41292: PPUSH
41293: PPUSH
// if not mc_bases then
41294: LD_EXP 50
41298: NOT
41299: IFFALSE 41303
// exit ;
41301: GO 41368
// if mc_bases [ base ] then
41303: LD_EXP 50
41307: PUSH
41308: LD_VAR 0 1
41312: ARRAY
41313: IFFALSE 41368
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41315: LD_ADDR_VAR 0 3
41319: PUSH
41320: LD_EXP 50
41324: PUSH
41325: LD_VAR 0 1
41329: ARRAY
41330: PPUSH
41331: LD_INT 30
41333: PUSH
41334: LD_VAR 0 2
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PPUSH
41343: CALL_OW 72
41347: ST_TO_ADDR
// if result then
41348: LD_VAR 0 3
41352: IFFALSE 41368
// result := result [ 1 ] ;
41354: LD_ADDR_VAR 0 3
41358: PUSH
41359: LD_VAR 0 3
41363: PUSH
41364: LD_INT 1
41366: ARRAY
41367: ST_TO_ADDR
// end ; end ;
41368: LD_VAR 0 3
41372: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41373: LD_INT 0
41375: PPUSH
41376: PPUSH
// if not mc_bases then
41377: LD_EXP 50
41381: NOT
41382: IFFALSE 41386
// exit ;
41384: GO 41431
// if mc_bases [ base ] then
41386: LD_EXP 50
41390: PUSH
41391: LD_VAR 0 1
41395: ARRAY
41396: IFFALSE 41431
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41398: LD_ADDR_VAR 0 3
41402: PUSH
41403: LD_EXP 50
41407: PUSH
41408: LD_VAR 0 1
41412: ARRAY
41413: PPUSH
41414: LD_INT 30
41416: PUSH
41417: LD_VAR 0 2
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PPUSH
41426: CALL_OW 72
41430: ST_TO_ADDR
// end ;
41431: LD_VAR 0 3
41435: RET
// export function MC_SetTame ( base , area ) ; begin
41436: LD_INT 0
41438: PPUSH
// if not mc_bases or not base then
41439: LD_EXP 50
41443: NOT
41444: PUSH
41445: LD_VAR 0 1
41449: NOT
41450: OR
41451: IFFALSE 41455
// exit ;
41453: GO 41480
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41455: LD_ADDR_EXP 78
41459: PUSH
41460: LD_EXP 78
41464: PPUSH
41465: LD_VAR 0 1
41469: PPUSH
41470: LD_VAR 0 2
41474: PPUSH
41475: CALL_OW 1
41479: ST_TO_ADDR
// end ;
41480: LD_VAR 0 3
41484: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41485: LD_INT 0
41487: PPUSH
41488: PPUSH
// if not mc_bases or not base then
41489: LD_EXP 50
41493: NOT
41494: PUSH
41495: LD_VAR 0 1
41499: NOT
41500: OR
41501: IFFALSE 41505
// exit ;
41503: GO 41607
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41505: LD_ADDR_VAR 0 4
41509: PUSH
41510: LD_EXP 50
41514: PUSH
41515: LD_VAR 0 1
41519: ARRAY
41520: PPUSH
41521: LD_INT 30
41523: PUSH
41524: LD_VAR 0 2
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PPUSH
41533: CALL_OW 72
41537: ST_TO_ADDR
// if not tmp then
41538: LD_VAR 0 4
41542: NOT
41543: IFFALSE 41547
// exit ;
41545: GO 41607
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41547: LD_ADDR_EXP 82
41551: PUSH
41552: LD_EXP 82
41556: PPUSH
41557: LD_VAR 0 1
41561: PPUSH
41562: LD_EXP 82
41566: PUSH
41567: LD_VAR 0 1
41571: ARRAY
41572: PPUSH
41573: LD_EXP 82
41577: PUSH
41578: LD_VAR 0 1
41582: ARRAY
41583: PUSH
41584: LD_INT 1
41586: PLUS
41587: PPUSH
41588: LD_VAR 0 4
41592: PUSH
41593: LD_INT 1
41595: ARRAY
41596: PPUSH
41597: CALL_OW 2
41601: PPUSH
41602: CALL_OW 1
41606: ST_TO_ADDR
// end ;
41607: LD_VAR 0 3
41611: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41612: LD_INT 0
41614: PPUSH
41615: PPUSH
// if not mc_bases or not base or not kinds then
41616: LD_EXP 50
41620: NOT
41621: PUSH
41622: LD_VAR 0 1
41626: NOT
41627: OR
41628: PUSH
41629: LD_VAR 0 2
41633: NOT
41634: OR
41635: IFFALSE 41639
// exit ;
41637: GO 41700
// for i in kinds do
41639: LD_ADDR_VAR 0 4
41643: PUSH
41644: LD_VAR 0 2
41648: PUSH
41649: FOR_IN
41650: IFFALSE 41698
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41652: LD_ADDR_EXP 84
41656: PUSH
41657: LD_EXP 84
41661: PPUSH
41662: LD_VAR 0 1
41666: PUSH
41667: LD_EXP 84
41671: PUSH
41672: LD_VAR 0 1
41676: ARRAY
41677: PUSH
41678: LD_INT 1
41680: PLUS
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PPUSH
41686: LD_VAR 0 4
41690: PPUSH
41691: CALL 54499 0 3
41695: ST_TO_ADDR
41696: GO 41649
41698: POP
41699: POP
// end ;
41700: LD_VAR 0 3
41704: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41705: LD_INT 0
41707: PPUSH
// if not mc_bases or not base or not areas then
41708: LD_EXP 50
41712: NOT
41713: PUSH
41714: LD_VAR 0 1
41718: NOT
41719: OR
41720: PUSH
41721: LD_VAR 0 2
41725: NOT
41726: OR
41727: IFFALSE 41731
// exit ;
41729: GO 41756
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41731: LD_ADDR_EXP 68
41735: PUSH
41736: LD_EXP 68
41740: PPUSH
41741: LD_VAR 0 1
41745: PPUSH
41746: LD_VAR 0 2
41750: PPUSH
41751: CALL_OW 1
41755: ST_TO_ADDR
// end ;
41756: LD_VAR 0 3
41760: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41761: LD_INT 0
41763: PPUSH
// if not mc_bases or not base or not teleports_exit then
41764: LD_EXP 50
41768: NOT
41769: PUSH
41770: LD_VAR 0 1
41774: NOT
41775: OR
41776: PUSH
41777: LD_VAR 0 2
41781: NOT
41782: OR
41783: IFFALSE 41787
// exit ;
41785: GO 41812
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41787: LD_ADDR_EXP 85
41791: PUSH
41792: LD_EXP 85
41796: PPUSH
41797: LD_VAR 0 1
41801: PPUSH
41802: LD_VAR 0 2
41806: PPUSH
41807: CALL_OW 1
41811: ST_TO_ADDR
// end ;
41812: LD_VAR 0 3
41816: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41817: LD_INT 0
41819: PPUSH
41820: PPUSH
41821: PPUSH
// if not mc_bases or not base or not ext_list then
41822: LD_EXP 50
41826: NOT
41827: PUSH
41828: LD_VAR 0 1
41832: NOT
41833: OR
41834: PUSH
41835: LD_VAR 0 5
41839: NOT
41840: OR
41841: IFFALSE 41845
// exit ;
41843: GO 42018
// tmp := GetFacExtXYD ( x , y , d ) ;
41845: LD_ADDR_VAR 0 8
41849: PUSH
41850: LD_VAR 0 2
41854: PPUSH
41855: LD_VAR 0 3
41859: PPUSH
41860: LD_VAR 0 4
41864: PPUSH
41865: CALL 87880 0 3
41869: ST_TO_ADDR
// if not tmp then
41870: LD_VAR 0 8
41874: NOT
41875: IFFALSE 41879
// exit ;
41877: GO 42018
// for i in tmp do
41879: LD_ADDR_VAR 0 7
41883: PUSH
41884: LD_VAR 0 8
41888: PUSH
41889: FOR_IN
41890: IFFALSE 42016
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41892: LD_ADDR_EXP 55
41896: PUSH
41897: LD_EXP 55
41901: PPUSH
41902: LD_VAR 0 1
41906: PPUSH
41907: LD_EXP 55
41911: PUSH
41912: LD_VAR 0 1
41916: ARRAY
41917: PPUSH
41918: LD_EXP 55
41922: PUSH
41923: LD_VAR 0 1
41927: ARRAY
41928: PUSH
41929: LD_INT 1
41931: PLUS
41932: PPUSH
41933: LD_VAR 0 5
41937: PUSH
41938: LD_INT 1
41940: ARRAY
41941: PUSH
41942: LD_VAR 0 7
41946: PUSH
41947: LD_INT 1
41949: ARRAY
41950: PUSH
41951: LD_VAR 0 7
41955: PUSH
41956: LD_INT 2
41958: ARRAY
41959: PUSH
41960: LD_VAR 0 7
41964: PUSH
41965: LD_INT 3
41967: ARRAY
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: LIST
41973: LIST
41974: PPUSH
41975: CALL_OW 2
41979: PPUSH
41980: CALL_OW 1
41984: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
41985: LD_ADDR_VAR 0 5
41989: PUSH
41990: LD_VAR 0 5
41994: PPUSH
41995: LD_INT 1
41997: PPUSH
41998: CALL_OW 3
42002: ST_TO_ADDR
// if not ext_list then
42003: LD_VAR 0 5
42007: NOT
42008: IFFALSE 42014
// exit ;
42010: POP
42011: POP
42012: GO 42018
// end ;
42014: GO 41889
42016: POP
42017: POP
// end ;
42018: LD_VAR 0 6
42022: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42023: LD_INT 0
42025: PPUSH
// if not mc_bases or not base or not weapon_list then
42026: LD_EXP 50
42030: NOT
42031: PUSH
42032: LD_VAR 0 1
42036: NOT
42037: OR
42038: PUSH
42039: LD_VAR 0 2
42043: NOT
42044: OR
42045: IFFALSE 42049
// exit ;
42047: GO 42074
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42049: LD_ADDR_EXP 89
42053: PUSH
42054: LD_EXP 89
42058: PPUSH
42059: LD_VAR 0 1
42063: PPUSH
42064: LD_VAR 0 2
42068: PPUSH
42069: CALL_OW 1
42073: ST_TO_ADDR
// end ;
42074: LD_VAR 0 3
42078: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42079: LD_INT 0
42081: PPUSH
// if not mc_bases or not base or not tech_list then
42082: LD_EXP 50
42086: NOT
42087: PUSH
42088: LD_VAR 0 1
42092: NOT
42093: OR
42094: PUSH
42095: LD_VAR 0 2
42099: NOT
42100: OR
42101: IFFALSE 42105
// exit ;
42103: GO 42130
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42105: LD_ADDR_EXP 77
42109: PUSH
42110: LD_EXP 77
42114: PPUSH
42115: LD_VAR 0 1
42119: PPUSH
42120: LD_VAR 0 2
42124: PPUSH
42125: CALL_OW 1
42129: ST_TO_ADDR
// end ;
42130: LD_VAR 0 3
42134: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42135: LD_INT 0
42137: PPUSH
// if not mc_bases or not parking_area or not base then
42138: LD_EXP 50
42142: NOT
42143: PUSH
42144: LD_VAR 0 2
42148: NOT
42149: OR
42150: PUSH
42151: LD_VAR 0 1
42155: NOT
42156: OR
42157: IFFALSE 42161
// exit ;
42159: GO 42186
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42161: LD_ADDR_EXP 74
42165: PUSH
42166: LD_EXP 74
42170: PPUSH
42171: LD_VAR 0 1
42175: PPUSH
42176: LD_VAR 0 2
42180: PPUSH
42181: CALL_OW 1
42185: ST_TO_ADDR
// end ;
42186: LD_VAR 0 3
42190: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42191: LD_INT 0
42193: PPUSH
// if not mc_bases or not base or not scan_area then
42194: LD_EXP 50
42198: NOT
42199: PUSH
42200: LD_VAR 0 1
42204: NOT
42205: OR
42206: PUSH
42207: LD_VAR 0 2
42211: NOT
42212: OR
42213: IFFALSE 42217
// exit ;
42215: GO 42242
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42217: LD_ADDR_EXP 75
42221: PUSH
42222: LD_EXP 75
42226: PPUSH
42227: LD_VAR 0 1
42231: PPUSH
42232: LD_VAR 0 2
42236: PPUSH
42237: CALL_OW 1
42241: ST_TO_ADDR
// end ;
42242: LD_VAR 0 3
42246: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42247: LD_INT 0
42249: PPUSH
42250: PPUSH
// if not mc_bases or not base then
42251: LD_EXP 50
42255: NOT
42256: PUSH
42257: LD_VAR 0 1
42261: NOT
42262: OR
42263: IFFALSE 42267
// exit ;
42265: GO 42331
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42267: LD_ADDR_VAR 0 3
42271: PUSH
42272: LD_INT 1
42274: PUSH
42275: LD_INT 2
42277: PUSH
42278: LD_INT 3
42280: PUSH
42281: LD_INT 4
42283: PUSH
42284: LD_INT 11
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42294: LD_ADDR_EXP 77
42298: PUSH
42299: LD_EXP 77
42303: PPUSH
42304: LD_VAR 0 1
42308: PPUSH
42309: LD_EXP 77
42313: PUSH
42314: LD_VAR 0 1
42318: ARRAY
42319: PUSH
42320: LD_VAR 0 3
42324: DIFF
42325: PPUSH
42326: CALL_OW 1
42330: ST_TO_ADDR
// end ;
42331: LD_VAR 0 2
42335: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42336: LD_INT 0
42338: PPUSH
// result := mc_vehicles [ base ] ;
42339: LD_ADDR_VAR 0 3
42343: PUSH
42344: LD_EXP 69
42348: PUSH
42349: LD_VAR 0 1
42353: ARRAY
42354: ST_TO_ADDR
// if onlyCombat then
42355: LD_VAR 0 2
42359: IFFALSE 42524
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42361: LD_ADDR_VAR 0 3
42365: PUSH
42366: LD_VAR 0 3
42370: PUSH
42371: LD_VAR 0 3
42375: PPUSH
42376: LD_INT 2
42378: PUSH
42379: LD_INT 34
42381: PUSH
42382: LD_INT 12
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 34
42391: PUSH
42392: LD_INT 51
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 34
42401: PUSH
42402: LD_EXP 94
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 34
42413: PUSH
42414: LD_INT 32
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 34
42423: PUSH
42424: LD_INT 13
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 34
42433: PUSH
42434: LD_INT 52
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 34
42443: PUSH
42444: LD_INT 14
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 34
42453: PUSH
42454: LD_INT 53
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 34
42463: PUSH
42464: LD_EXP 93
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 34
42475: PUSH
42476: LD_INT 31
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 34
42485: PUSH
42486: LD_INT 48
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 34
42495: PUSH
42496: LD_INT 8
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: PPUSH
42518: CALL_OW 72
42522: DIFF
42523: ST_TO_ADDR
// end ; end_of_file
42524: LD_VAR 0 3
42528: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42529: LD_INT 0
42531: PPUSH
42532: PPUSH
42533: PPUSH
// if not mc_bases or not skirmish then
42534: LD_EXP 50
42538: NOT
42539: PUSH
42540: LD_EXP 48
42544: NOT
42545: OR
42546: IFFALSE 42550
// exit ;
42548: GO 42715
// for i = 1 to mc_bases do
42550: LD_ADDR_VAR 0 4
42554: PUSH
42555: DOUBLE
42556: LD_INT 1
42558: DEC
42559: ST_TO_ADDR
42560: LD_EXP 50
42564: PUSH
42565: FOR_TO
42566: IFFALSE 42713
// begin if sci in mc_bases [ i ] then
42568: LD_VAR 0 2
42572: PUSH
42573: LD_EXP 50
42577: PUSH
42578: LD_VAR 0 4
42582: ARRAY
42583: IN
42584: IFFALSE 42711
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42586: LD_ADDR_EXP 79
42590: PUSH
42591: LD_EXP 79
42595: PPUSH
42596: LD_VAR 0 4
42600: PUSH
42601: LD_EXP 79
42605: PUSH
42606: LD_VAR 0 4
42610: ARRAY
42611: PUSH
42612: LD_INT 1
42614: PLUS
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PPUSH
42620: LD_VAR 0 1
42624: PPUSH
42625: CALL 54499 0 3
42629: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42630: LD_ADDR_VAR 0 5
42634: PUSH
42635: LD_EXP 50
42639: PUSH
42640: LD_VAR 0 4
42644: ARRAY
42645: PPUSH
42646: LD_INT 2
42648: PUSH
42649: LD_INT 30
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 30
42661: PUSH
42662: LD_INT 1
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: LIST
42673: PPUSH
42674: CALL_OW 72
42678: PPUSH
42679: LD_VAR 0 1
42683: PPUSH
42684: CALL_OW 74
42688: ST_TO_ADDR
// if tmp then
42689: LD_VAR 0 5
42693: IFFALSE 42709
// ComStandNearbyBuilding ( ape , tmp ) ;
42695: LD_VAR 0 1
42699: PPUSH
42700: LD_VAR 0 5
42704: PPUSH
42705: CALL 48702 0 2
// break ;
42709: GO 42713
// end ; end ;
42711: GO 42565
42713: POP
42714: POP
// end ;
42715: LD_VAR 0 3
42719: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42720: LD_INT 0
42722: PPUSH
42723: PPUSH
42724: PPUSH
// if not mc_bases or not skirmish then
42725: LD_EXP 50
42729: NOT
42730: PUSH
42731: LD_EXP 48
42735: NOT
42736: OR
42737: IFFALSE 42741
// exit ;
42739: GO 42830
// for i = 1 to mc_bases do
42741: LD_ADDR_VAR 0 4
42745: PUSH
42746: DOUBLE
42747: LD_INT 1
42749: DEC
42750: ST_TO_ADDR
42751: LD_EXP 50
42755: PUSH
42756: FOR_TO
42757: IFFALSE 42828
// begin if building in mc_busy_turret_list [ i ] then
42759: LD_VAR 0 1
42763: PUSH
42764: LD_EXP 60
42768: PUSH
42769: LD_VAR 0 4
42773: ARRAY
42774: IN
42775: IFFALSE 42826
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42777: LD_ADDR_VAR 0 5
42781: PUSH
42782: LD_EXP 60
42786: PUSH
42787: LD_VAR 0 4
42791: ARRAY
42792: PUSH
42793: LD_VAR 0 1
42797: DIFF
42798: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42799: LD_ADDR_EXP 60
42803: PUSH
42804: LD_EXP 60
42808: PPUSH
42809: LD_VAR 0 4
42813: PPUSH
42814: LD_VAR 0 5
42818: PPUSH
42819: CALL_OW 1
42823: ST_TO_ADDR
// break ;
42824: GO 42828
// end ; end ;
42826: GO 42756
42828: POP
42829: POP
// end ;
42830: LD_VAR 0 3
42834: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42835: LD_INT 0
42837: PPUSH
42838: PPUSH
42839: PPUSH
// if not mc_bases or not skirmish then
42840: LD_EXP 50
42844: NOT
42845: PUSH
42846: LD_EXP 48
42850: NOT
42851: OR
42852: IFFALSE 42856
// exit ;
42854: GO 43055
// for i = 1 to mc_bases do
42856: LD_ADDR_VAR 0 5
42860: PUSH
42861: DOUBLE
42862: LD_INT 1
42864: DEC
42865: ST_TO_ADDR
42866: LD_EXP 50
42870: PUSH
42871: FOR_TO
42872: IFFALSE 43053
// if building in mc_bases [ i ] then
42874: LD_VAR 0 1
42878: PUSH
42879: LD_EXP 50
42883: PUSH
42884: LD_VAR 0 5
42888: ARRAY
42889: IN
42890: IFFALSE 43051
// begin tmp := mc_bases [ i ] diff building ;
42892: LD_ADDR_VAR 0 6
42896: PUSH
42897: LD_EXP 50
42901: PUSH
42902: LD_VAR 0 5
42906: ARRAY
42907: PUSH
42908: LD_VAR 0 1
42912: DIFF
42913: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42914: LD_ADDR_EXP 50
42918: PUSH
42919: LD_EXP 50
42923: PPUSH
42924: LD_VAR 0 5
42928: PPUSH
42929: LD_VAR 0 6
42933: PPUSH
42934: CALL_OW 1
42938: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42939: LD_VAR 0 1
42943: PUSH
42944: LD_EXP 58
42948: PUSH
42949: LD_VAR 0 5
42953: ARRAY
42954: IN
42955: IFFALSE 42994
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
42957: LD_ADDR_EXP 58
42961: PUSH
42962: LD_EXP 58
42966: PPUSH
42967: LD_VAR 0 5
42971: PPUSH
42972: LD_EXP 58
42976: PUSH
42977: LD_VAR 0 5
42981: ARRAY
42982: PUSH
42983: LD_VAR 0 1
42987: DIFF
42988: PPUSH
42989: CALL_OW 1
42993: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
42994: LD_VAR 0 1
42998: PUSH
42999: LD_EXP 59
43003: PUSH
43004: LD_VAR 0 5
43008: ARRAY
43009: IN
43010: IFFALSE 43049
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43012: LD_ADDR_EXP 59
43016: PUSH
43017: LD_EXP 59
43021: PPUSH
43022: LD_VAR 0 5
43026: PPUSH
43027: LD_EXP 59
43031: PUSH
43032: LD_VAR 0 5
43036: ARRAY
43037: PUSH
43038: LD_VAR 0 1
43042: DIFF
43043: PPUSH
43044: CALL_OW 1
43048: ST_TO_ADDR
// break ;
43049: GO 43053
// end ;
43051: GO 42871
43053: POP
43054: POP
// end ;
43055: LD_VAR 0 4
43059: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43060: LD_INT 0
43062: PPUSH
43063: PPUSH
43064: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43065: LD_EXP 50
43069: NOT
43070: PUSH
43071: LD_EXP 48
43075: NOT
43076: OR
43077: PUSH
43078: LD_VAR 0 3
43082: PUSH
43083: LD_EXP 76
43087: IN
43088: NOT
43089: OR
43090: IFFALSE 43094
// exit ;
43092: GO 43217
// for i = 1 to mc_vehicles do
43094: LD_ADDR_VAR 0 6
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_EXP 69
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43215
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_EXP 69
43121: PUSH
43122: LD_VAR 0 6
43126: ARRAY
43127: IN
43128: PUSH
43129: LD_VAR 0 1
43133: PUSH
43134: LD_EXP 69
43138: PUSH
43139: LD_VAR 0 6
43143: ARRAY
43144: IN
43145: OR
43146: IFFALSE 43213
// begin tmp := mc_vehicles [ i ] diff old ;
43148: LD_ADDR_VAR 0 7
43152: PUSH
43153: LD_EXP 69
43157: PUSH
43158: LD_VAR 0 6
43162: ARRAY
43163: PUSH
43164: LD_VAR 0 2
43168: DIFF
43169: ST_TO_ADDR
// tmp := tmp diff new ;
43170: LD_ADDR_VAR 0 7
43174: PUSH
43175: LD_VAR 0 7
43179: PUSH
43180: LD_VAR 0 1
43184: DIFF
43185: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43186: LD_ADDR_EXP 69
43190: PUSH
43191: LD_EXP 69
43195: PPUSH
43196: LD_VAR 0 6
43200: PPUSH
43201: LD_VAR 0 7
43205: PPUSH
43206: CALL_OW 1
43210: ST_TO_ADDR
// break ;
43211: GO 43215
// end ;
43213: GO 43109
43215: POP
43216: POP
// end ;
43217: LD_VAR 0 5
43221: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43222: LD_INT 0
43224: PPUSH
43225: PPUSH
43226: PPUSH
43227: PPUSH
// if not mc_bases or not skirmish then
43228: LD_EXP 50
43232: NOT
43233: PUSH
43234: LD_EXP 48
43238: NOT
43239: OR
43240: IFFALSE 43244
// exit ;
43242: GO 43621
// side := GetSide ( vehicle ) ;
43244: LD_ADDR_VAR 0 5
43248: PUSH
43249: LD_VAR 0 1
43253: PPUSH
43254: CALL_OW 255
43258: ST_TO_ADDR
// for i = 1 to mc_bases do
43259: LD_ADDR_VAR 0 4
43263: PUSH
43264: DOUBLE
43265: LD_INT 1
43267: DEC
43268: ST_TO_ADDR
43269: LD_EXP 50
43273: PUSH
43274: FOR_TO
43275: IFFALSE 43619
// begin if factory in mc_bases [ i ] then
43277: LD_VAR 0 2
43281: PUSH
43282: LD_EXP 50
43286: PUSH
43287: LD_VAR 0 4
43291: ARRAY
43292: IN
43293: IFFALSE 43617
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43295: LD_EXP 72
43299: PUSH
43300: LD_VAR 0 4
43304: ARRAY
43305: PUSH
43306: LD_EXP 61
43310: PUSH
43311: LD_VAR 0 4
43315: ARRAY
43316: LESS
43317: PUSH
43318: LD_VAR 0 1
43322: PPUSH
43323: CALL_OW 264
43327: PUSH
43328: LD_INT 31
43330: PUSH
43331: LD_INT 32
43333: PUSH
43334: LD_INT 51
43336: PUSH
43337: LD_EXP 94
43341: PUSH
43342: LD_INT 12
43344: PUSH
43345: LD_INT 30
43347: PUSH
43348: LD_EXP 93
43352: PUSH
43353: LD_INT 11
43355: PUSH
43356: LD_INT 53
43358: PUSH
43359: LD_INT 14
43361: PUSH
43362: LD_EXP 97
43366: PUSH
43367: LD_INT 29
43369: PUSH
43370: LD_EXP 95
43374: PUSH
43375: LD_INT 13
43377: PUSH
43378: LD_INT 52
43380: PUSH
43381: LD_INT 48
43383: PUSH
43384: LD_INT 8
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: IN
43406: NOT
43407: AND
43408: IFFALSE 43456
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43410: LD_ADDR_EXP 72
43414: PUSH
43415: LD_EXP 72
43419: PPUSH
43420: LD_VAR 0 4
43424: PUSH
43425: LD_EXP 72
43429: PUSH
43430: LD_VAR 0 4
43434: ARRAY
43435: PUSH
43436: LD_INT 1
43438: PLUS
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PPUSH
43444: LD_VAR 0 1
43448: PPUSH
43449: CALL 54499 0 3
43453: ST_TO_ADDR
43454: GO 43500
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43456: LD_ADDR_EXP 69
43460: PUSH
43461: LD_EXP 69
43465: PPUSH
43466: LD_VAR 0 4
43470: PUSH
43471: LD_EXP 69
43475: PUSH
43476: LD_VAR 0 4
43480: ARRAY
43481: PUSH
43482: LD_INT 1
43484: PLUS
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PPUSH
43490: LD_VAR 0 1
43494: PPUSH
43495: CALL 54499 0 3
43499: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43500: LD_VAR 0 1
43504: PPUSH
43505: CALL_OW 263
43509: PUSH
43510: LD_INT 2
43512: EQUAL
43513: IFFALSE 43533
// begin repeat wait ( 0 0$1 ) ;
43515: LD_INT 35
43517: PPUSH
43518: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43522: LD_VAR 0 1
43526: PPUSH
43527: CALL_OW 312
43531: IFFALSE 43515
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43533: LD_VAR 0 1
43537: PPUSH
43538: LD_EXP 74
43542: PUSH
43543: LD_VAR 0 4
43547: ARRAY
43548: PPUSH
43549: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43553: LD_VAR 0 1
43557: PPUSH
43558: CALL_OW 263
43562: PUSH
43563: LD_INT 1
43565: NONEQUAL
43566: IFFALSE 43570
// break ;
43568: GO 43619
// repeat wait ( 0 0$1 ) ;
43570: LD_INT 35
43572: PPUSH
43573: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43577: LD_VAR 0 1
43581: PPUSH
43582: LD_EXP 74
43586: PUSH
43587: LD_VAR 0 4
43591: ARRAY
43592: PPUSH
43593: CALL_OW 308
43597: IFFALSE 43570
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43599: LD_VAR 0 1
43603: PPUSH
43604: CALL_OW 311
43608: PPUSH
43609: CALL_OW 121
// exit ;
43613: POP
43614: POP
43615: GO 43621
// end ; end ;
43617: GO 43274
43619: POP
43620: POP
// end ;
43621: LD_VAR 0 3
43625: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43626: LD_INT 0
43628: PPUSH
43629: PPUSH
43630: PPUSH
43631: PPUSH
// if not mc_bases or not skirmish then
43632: LD_EXP 50
43636: NOT
43637: PUSH
43638: LD_EXP 48
43642: NOT
43643: OR
43644: IFFALSE 43648
// exit ;
43646: GO 44001
// repeat wait ( 0 0$1 ) ;
43648: LD_INT 35
43650: PPUSH
43651: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43655: LD_VAR 0 2
43659: PPUSH
43660: LD_VAR 0 3
43664: PPUSH
43665: CALL_OW 284
43669: IFFALSE 43648
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43671: LD_VAR 0 2
43675: PPUSH
43676: LD_VAR 0 3
43680: PPUSH
43681: CALL_OW 283
43685: PUSH
43686: LD_INT 4
43688: EQUAL
43689: IFFALSE 43693
// exit ;
43691: GO 44001
// for i = 1 to mc_bases do
43693: LD_ADDR_VAR 0 7
43697: PUSH
43698: DOUBLE
43699: LD_INT 1
43701: DEC
43702: ST_TO_ADDR
43703: LD_EXP 50
43707: PUSH
43708: FOR_TO
43709: IFFALSE 43999
// begin if mc_crates_area [ i ] then
43711: LD_EXP 68
43715: PUSH
43716: LD_VAR 0 7
43720: ARRAY
43721: IFFALSE 43832
// for j in mc_crates_area [ i ] do
43723: LD_ADDR_VAR 0 8
43727: PUSH
43728: LD_EXP 68
43732: PUSH
43733: LD_VAR 0 7
43737: ARRAY
43738: PUSH
43739: FOR_IN
43740: IFFALSE 43830
// if InArea ( x , y , j ) then
43742: LD_VAR 0 2
43746: PPUSH
43747: LD_VAR 0 3
43751: PPUSH
43752: LD_VAR 0 8
43756: PPUSH
43757: CALL_OW 309
43761: IFFALSE 43828
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43763: LD_ADDR_EXP 66
43767: PUSH
43768: LD_EXP 66
43772: PPUSH
43773: LD_VAR 0 7
43777: PUSH
43778: LD_EXP 66
43782: PUSH
43783: LD_VAR 0 7
43787: ARRAY
43788: PUSH
43789: LD_INT 1
43791: PLUS
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PPUSH
43797: LD_VAR 0 4
43801: PUSH
43802: LD_VAR 0 2
43806: PUSH
43807: LD_VAR 0 3
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: LIST
43816: PPUSH
43817: CALL 54499 0 3
43821: ST_TO_ADDR
// exit ;
43822: POP
43823: POP
43824: POP
43825: POP
43826: GO 44001
// end ;
43828: GO 43739
43830: POP
43831: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43832: LD_ADDR_VAR 0 9
43836: PUSH
43837: LD_EXP 50
43841: PUSH
43842: LD_VAR 0 7
43846: ARRAY
43847: PPUSH
43848: LD_INT 2
43850: PUSH
43851: LD_INT 30
43853: PUSH
43854: LD_INT 0
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 30
43863: PUSH
43864: LD_INT 1
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: LIST
43875: PPUSH
43876: CALL_OW 72
43880: ST_TO_ADDR
// if not depot then
43881: LD_VAR 0 9
43885: NOT
43886: IFFALSE 43890
// continue ;
43888: GO 43708
// for j in depot do
43890: LD_ADDR_VAR 0 8
43894: PUSH
43895: LD_VAR 0 9
43899: PUSH
43900: FOR_IN
43901: IFFALSE 43995
// if GetDistUnitXY ( j , x , y ) < 30 then
43903: LD_VAR 0 8
43907: PPUSH
43908: LD_VAR 0 2
43912: PPUSH
43913: LD_VAR 0 3
43917: PPUSH
43918: CALL_OW 297
43922: PUSH
43923: LD_INT 30
43925: LESS
43926: IFFALSE 43993
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43928: LD_ADDR_EXP 66
43932: PUSH
43933: LD_EXP 66
43937: PPUSH
43938: LD_VAR 0 7
43942: PUSH
43943: LD_EXP 66
43947: PUSH
43948: LD_VAR 0 7
43952: ARRAY
43953: PUSH
43954: LD_INT 1
43956: PLUS
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PPUSH
43962: LD_VAR 0 4
43966: PUSH
43967: LD_VAR 0 2
43971: PUSH
43972: LD_VAR 0 3
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: LIST
43981: PPUSH
43982: CALL 54499 0 3
43986: ST_TO_ADDR
// exit ;
43987: POP
43988: POP
43989: POP
43990: POP
43991: GO 44001
// end ;
43993: GO 43900
43995: POP
43996: POP
// end ;
43997: GO 43708
43999: POP
44000: POP
// end ;
44001: LD_VAR 0 6
44005: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44006: LD_INT 0
44008: PPUSH
44009: PPUSH
44010: PPUSH
44011: PPUSH
// if not mc_bases or not skirmish then
44012: LD_EXP 50
44016: NOT
44017: PUSH
44018: LD_EXP 48
44022: NOT
44023: OR
44024: IFFALSE 44028
// exit ;
44026: GO 44305
// side := GetSide ( lab ) ;
44028: LD_ADDR_VAR 0 4
44032: PUSH
44033: LD_VAR 0 2
44037: PPUSH
44038: CALL_OW 255
44042: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44043: LD_VAR 0 4
44047: PUSH
44048: LD_EXP 76
44052: IN
44053: NOT
44054: PUSH
44055: LD_EXP 77
44059: NOT
44060: OR
44061: PUSH
44062: LD_EXP 50
44066: NOT
44067: OR
44068: IFFALSE 44072
// exit ;
44070: GO 44305
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44072: LD_ADDR_EXP 77
44076: PUSH
44077: LD_EXP 77
44081: PPUSH
44082: LD_VAR 0 4
44086: PPUSH
44087: LD_EXP 77
44091: PUSH
44092: LD_VAR 0 4
44096: ARRAY
44097: PUSH
44098: LD_VAR 0 1
44102: DIFF
44103: PPUSH
44104: CALL_OW 1
44108: ST_TO_ADDR
// for i = 1 to mc_bases do
44109: LD_ADDR_VAR 0 5
44113: PUSH
44114: DOUBLE
44115: LD_INT 1
44117: DEC
44118: ST_TO_ADDR
44119: LD_EXP 50
44123: PUSH
44124: FOR_TO
44125: IFFALSE 44303
// begin if lab in mc_bases [ i ] then
44127: LD_VAR 0 2
44131: PUSH
44132: LD_EXP 50
44136: PUSH
44137: LD_VAR 0 5
44141: ARRAY
44142: IN
44143: IFFALSE 44301
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44145: LD_VAR 0 1
44149: PUSH
44150: LD_INT 11
44152: PUSH
44153: LD_INT 4
44155: PUSH
44156: LD_INT 3
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: LIST
44166: LIST
44167: IN
44168: PUSH
44169: LD_EXP 80
44173: PUSH
44174: LD_VAR 0 5
44178: ARRAY
44179: AND
44180: IFFALSE 44301
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44182: LD_ADDR_VAR 0 6
44186: PUSH
44187: LD_EXP 80
44191: PUSH
44192: LD_VAR 0 5
44196: ARRAY
44197: PUSH
44198: LD_INT 1
44200: ARRAY
44201: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44202: LD_ADDR_EXP 80
44206: PUSH
44207: LD_EXP 80
44211: PPUSH
44212: LD_VAR 0 5
44216: PPUSH
44217: EMPTY
44218: PPUSH
44219: CALL_OW 1
44223: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44224: LD_VAR 0 6
44228: PPUSH
44229: LD_INT 0
44231: PPUSH
44232: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44236: LD_VAR 0 6
44240: PPUSH
44241: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44245: LD_ADDR_EXP 79
44249: PUSH
44250: LD_EXP 79
44254: PPUSH
44255: LD_VAR 0 5
44259: PPUSH
44260: LD_EXP 79
44264: PUSH
44265: LD_VAR 0 5
44269: ARRAY
44270: PPUSH
44271: LD_INT 1
44273: PPUSH
44274: LD_VAR 0 6
44278: PPUSH
44279: CALL_OW 2
44283: PPUSH
44284: CALL_OW 1
44288: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44289: LD_VAR 0 5
44293: PPUSH
44294: LD_INT 112
44296: PPUSH
44297: CALL 21301 0 2
// end ; end ; end ;
44301: GO 44124
44303: POP
44304: POP
// end ;
44305: LD_VAR 0 3
44309: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44310: LD_INT 0
44312: PPUSH
44313: PPUSH
44314: PPUSH
44315: PPUSH
44316: PPUSH
44317: PPUSH
44318: PPUSH
44319: PPUSH
// if not mc_bases or not skirmish then
44320: LD_EXP 50
44324: NOT
44325: PUSH
44326: LD_EXP 48
44330: NOT
44331: OR
44332: IFFALSE 44336
// exit ;
44334: GO 45707
// for i = 1 to mc_bases do
44336: LD_ADDR_VAR 0 3
44340: PUSH
44341: DOUBLE
44342: LD_INT 1
44344: DEC
44345: ST_TO_ADDR
44346: LD_EXP 50
44350: PUSH
44351: FOR_TO
44352: IFFALSE 45705
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44354: LD_VAR 0 1
44358: PUSH
44359: LD_EXP 50
44363: PUSH
44364: LD_VAR 0 3
44368: ARRAY
44369: IN
44370: PUSH
44371: LD_VAR 0 1
44375: PUSH
44376: LD_EXP 57
44380: PUSH
44381: LD_VAR 0 3
44385: ARRAY
44386: IN
44387: OR
44388: PUSH
44389: LD_VAR 0 1
44393: PUSH
44394: LD_EXP 72
44398: PUSH
44399: LD_VAR 0 3
44403: ARRAY
44404: IN
44405: OR
44406: PUSH
44407: LD_VAR 0 1
44411: PUSH
44412: LD_EXP 69
44416: PUSH
44417: LD_VAR 0 3
44421: ARRAY
44422: IN
44423: OR
44424: PUSH
44425: LD_VAR 0 1
44429: PUSH
44430: LD_EXP 79
44434: PUSH
44435: LD_VAR 0 3
44439: ARRAY
44440: IN
44441: OR
44442: PUSH
44443: LD_VAR 0 1
44447: PUSH
44448: LD_EXP 80
44452: PUSH
44453: LD_VAR 0 3
44457: ARRAY
44458: IN
44459: OR
44460: IFFALSE 45703
// begin if un in mc_ape [ i ] then
44462: LD_VAR 0 1
44466: PUSH
44467: LD_EXP 79
44471: PUSH
44472: LD_VAR 0 3
44476: ARRAY
44477: IN
44478: IFFALSE 44517
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44480: LD_ADDR_EXP 79
44484: PUSH
44485: LD_EXP 79
44489: PPUSH
44490: LD_VAR 0 3
44494: PPUSH
44495: LD_EXP 79
44499: PUSH
44500: LD_VAR 0 3
44504: ARRAY
44505: PUSH
44506: LD_VAR 0 1
44510: DIFF
44511: PPUSH
44512: CALL_OW 1
44516: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44517: LD_VAR 0 1
44521: PUSH
44522: LD_EXP 80
44526: PUSH
44527: LD_VAR 0 3
44531: ARRAY
44532: IN
44533: IFFALSE 44557
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44535: LD_ADDR_EXP 80
44539: PUSH
44540: LD_EXP 80
44544: PPUSH
44545: LD_VAR 0 3
44549: PPUSH
44550: EMPTY
44551: PPUSH
44552: CALL_OW 1
44556: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44557: LD_VAR 0 1
44561: PPUSH
44562: CALL_OW 247
44566: PUSH
44567: LD_INT 2
44569: EQUAL
44570: PUSH
44571: LD_VAR 0 1
44575: PPUSH
44576: CALL_OW 110
44580: PUSH
44581: LD_INT 20
44583: EQUAL
44584: PUSH
44585: LD_VAR 0 1
44589: PUSH
44590: LD_EXP 72
44594: PUSH
44595: LD_VAR 0 3
44599: ARRAY
44600: IN
44601: OR
44602: PUSH
44603: LD_VAR 0 1
44607: PPUSH
44608: CALL_OW 264
44612: PUSH
44613: LD_INT 12
44615: PUSH
44616: LD_INT 51
44618: PUSH
44619: LD_EXP 94
44623: PUSH
44624: LD_INT 32
44626: PUSH
44627: LD_INT 13
44629: PUSH
44630: LD_INT 52
44632: PUSH
44633: LD_INT 31
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: IN
44645: OR
44646: AND
44647: IFFALSE 44955
// begin if un in mc_defender [ i ] then
44649: LD_VAR 0 1
44653: PUSH
44654: LD_EXP 72
44658: PUSH
44659: LD_VAR 0 3
44663: ARRAY
44664: IN
44665: IFFALSE 44704
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44667: LD_ADDR_EXP 72
44671: PUSH
44672: LD_EXP 72
44676: PPUSH
44677: LD_VAR 0 3
44681: PPUSH
44682: LD_EXP 72
44686: PUSH
44687: LD_VAR 0 3
44691: ARRAY
44692: PUSH
44693: LD_VAR 0 1
44697: DIFF
44698: PPUSH
44699: CALL_OW 1
44703: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44704: LD_ADDR_VAR 0 8
44708: PUSH
44709: LD_VAR 0 3
44713: PPUSH
44714: LD_INT 3
44716: PPUSH
44717: CALL 41373 0 2
44721: ST_TO_ADDR
// if fac then
44722: LD_VAR 0 8
44726: IFFALSE 44955
// begin for j in fac do
44728: LD_ADDR_VAR 0 4
44732: PUSH
44733: LD_VAR 0 8
44737: PUSH
44738: FOR_IN
44739: IFFALSE 44953
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44741: LD_ADDR_VAR 0 9
44745: PUSH
44746: LD_VAR 0 8
44750: PPUSH
44751: LD_VAR 0 1
44755: PPUSH
44756: CALL_OW 265
44760: PPUSH
44761: LD_VAR 0 1
44765: PPUSH
44766: CALL_OW 262
44770: PPUSH
44771: LD_VAR 0 1
44775: PPUSH
44776: CALL_OW 263
44780: PPUSH
44781: LD_VAR 0 1
44785: PPUSH
44786: CALL_OW 264
44790: PPUSH
44791: CALL 52031 0 5
44795: ST_TO_ADDR
// if components then
44796: LD_VAR 0 9
44800: IFFALSE 44951
// begin if GetWeapon ( un ) = ar_control_tower then
44802: LD_VAR 0 1
44806: PPUSH
44807: CALL_OW 264
44811: PUSH
44812: LD_INT 31
44814: EQUAL
44815: IFFALSE 44932
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44817: LD_VAR 0 1
44821: PPUSH
44822: CALL_OW 311
44826: PPUSH
44827: LD_INT 0
44829: PPUSH
44830: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44834: LD_ADDR_EXP 90
44838: PUSH
44839: LD_EXP 90
44843: PPUSH
44844: LD_VAR 0 3
44848: PPUSH
44849: LD_EXP 90
44853: PUSH
44854: LD_VAR 0 3
44858: ARRAY
44859: PUSH
44860: LD_VAR 0 1
44864: PPUSH
44865: CALL_OW 311
44869: DIFF
44870: PPUSH
44871: CALL_OW 1
44875: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44876: LD_ADDR_VAR 0 7
44880: PUSH
44881: LD_EXP 71
44885: PUSH
44886: LD_VAR 0 3
44890: ARRAY
44891: PPUSH
44892: LD_INT 1
44894: PPUSH
44895: LD_VAR 0 9
44899: PPUSH
44900: CALL_OW 2
44904: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44905: LD_ADDR_EXP 71
44909: PUSH
44910: LD_EXP 71
44914: PPUSH
44915: LD_VAR 0 3
44919: PPUSH
44920: LD_VAR 0 7
44924: PPUSH
44925: CALL_OW 1
44929: ST_TO_ADDR
// end else
44930: GO 44949
// MC_InsertProduceList ( i , [ components ] ) ;
44932: LD_VAR 0 3
44936: PPUSH
44937: LD_VAR 0 9
44941: PUSH
44942: EMPTY
44943: LIST
44944: PPUSH
44945: CALL 40918 0 2
// break ;
44949: GO 44953
// end ; end ;
44951: GO 44738
44953: POP
44954: POP
// end ; end ; if GetType ( un ) = unit_building then
44955: LD_VAR 0 1
44959: PPUSH
44960: CALL_OW 247
44964: PUSH
44965: LD_INT 3
44967: EQUAL
44968: IFFALSE 45371
// begin btype := GetBType ( un ) ;
44970: LD_ADDR_VAR 0 5
44974: PUSH
44975: LD_VAR 0 1
44979: PPUSH
44980: CALL_OW 266
44984: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
44985: LD_VAR 0 5
44989: PUSH
44990: LD_INT 29
44992: PUSH
44993: LD_INT 30
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: IN
45000: IFFALSE 45073
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45002: LD_VAR 0 1
45006: PPUSH
45007: CALL_OW 250
45011: PPUSH
45012: LD_VAR 0 1
45016: PPUSH
45017: CALL_OW 251
45021: PPUSH
45022: LD_VAR 0 1
45026: PPUSH
45027: CALL_OW 255
45031: PPUSH
45032: CALL_OW 440
45036: NOT
45037: IFFALSE 45073
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 250
45048: PPUSH
45049: LD_VAR 0 1
45053: PPUSH
45054: CALL_OW 251
45058: PPUSH
45059: LD_VAR 0 1
45063: PPUSH
45064: CALL_OW 255
45068: PPUSH
45069: CALL_OW 441
// end ; if btype = b_warehouse then
45073: LD_VAR 0 5
45077: PUSH
45078: LD_INT 1
45080: EQUAL
45081: IFFALSE 45099
// begin btype := b_depot ;
45083: LD_ADDR_VAR 0 5
45087: PUSH
45088: LD_INT 0
45090: ST_TO_ADDR
// pos := 1 ;
45091: LD_ADDR_VAR 0 6
45095: PUSH
45096: LD_INT 1
45098: ST_TO_ADDR
// end ; if btype = b_factory then
45099: LD_VAR 0 5
45103: PUSH
45104: LD_INT 3
45106: EQUAL
45107: IFFALSE 45125
// begin btype := b_workshop ;
45109: LD_ADDR_VAR 0 5
45113: PUSH
45114: LD_INT 2
45116: ST_TO_ADDR
// pos := 1 ;
45117: LD_ADDR_VAR 0 6
45121: PUSH
45122: LD_INT 1
45124: ST_TO_ADDR
// end ; if btype = b_barracks then
45125: LD_VAR 0 5
45129: PUSH
45130: LD_INT 5
45132: EQUAL
45133: IFFALSE 45143
// btype := b_armoury ;
45135: LD_ADDR_VAR 0 5
45139: PUSH
45140: LD_INT 4
45142: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45143: LD_VAR 0 5
45147: PUSH
45148: LD_INT 7
45150: PUSH
45151: LD_INT 8
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: IN
45158: IFFALSE 45168
// btype := b_lab ;
45160: LD_ADDR_VAR 0 5
45164: PUSH
45165: LD_INT 6
45167: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45168: LD_ADDR_EXP 55
45172: PUSH
45173: LD_EXP 55
45177: PPUSH
45178: LD_VAR 0 3
45182: PUSH
45183: LD_EXP 55
45187: PUSH
45188: LD_VAR 0 3
45192: ARRAY
45193: PUSH
45194: LD_INT 1
45196: PLUS
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PPUSH
45202: LD_VAR 0 5
45206: PUSH
45207: LD_VAR 0 1
45211: PPUSH
45212: CALL_OW 250
45216: PUSH
45217: LD_VAR 0 1
45221: PPUSH
45222: CALL_OW 251
45226: PUSH
45227: LD_VAR 0 1
45231: PPUSH
45232: CALL_OW 254
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: LIST
45241: LIST
45242: PPUSH
45243: CALL 54499 0 3
45247: ST_TO_ADDR
// if pos = 1 then
45248: LD_VAR 0 6
45252: PUSH
45253: LD_INT 1
45255: EQUAL
45256: IFFALSE 45371
// begin tmp := mc_build_list [ i ] ;
45258: LD_ADDR_VAR 0 7
45262: PUSH
45263: LD_EXP 55
45267: PUSH
45268: LD_VAR 0 3
45272: ARRAY
45273: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45274: LD_VAR 0 7
45278: PPUSH
45279: LD_INT 2
45281: PUSH
45282: LD_INT 30
45284: PUSH
45285: LD_INT 0
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 30
45294: PUSH
45295: LD_INT 1
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: LIST
45306: PPUSH
45307: CALL_OW 72
45311: IFFALSE 45321
// pos := 2 ;
45313: LD_ADDR_VAR 0 6
45317: PUSH
45318: LD_INT 2
45320: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45321: LD_ADDR_VAR 0 7
45325: PUSH
45326: LD_VAR 0 7
45330: PPUSH
45331: LD_VAR 0 6
45335: PPUSH
45336: LD_VAR 0 7
45340: PPUSH
45341: CALL 54825 0 3
45345: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45346: LD_ADDR_EXP 55
45350: PUSH
45351: LD_EXP 55
45355: PPUSH
45356: LD_VAR 0 3
45360: PPUSH
45361: LD_VAR 0 7
45365: PPUSH
45366: CALL_OW 1
45370: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45371: LD_VAR 0 1
45375: PUSH
45376: LD_EXP 50
45380: PUSH
45381: LD_VAR 0 3
45385: ARRAY
45386: IN
45387: IFFALSE 45426
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45389: LD_ADDR_EXP 50
45393: PUSH
45394: LD_EXP 50
45398: PPUSH
45399: LD_VAR 0 3
45403: PPUSH
45404: LD_EXP 50
45408: PUSH
45409: LD_VAR 0 3
45413: ARRAY
45414: PUSH
45415: LD_VAR 0 1
45419: DIFF
45420: PPUSH
45421: CALL_OW 1
45425: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45426: LD_VAR 0 1
45430: PUSH
45431: LD_EXP 57
45435: PUSH
45436: LD_VAR 0 3
45440: ARRAY
45441: IN
45442: IFFALSE 45481
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45444: LD_ADDR_EXP 57
45448: PUSH
45449: LD_EXP 57
45453: PPUSH
45454: LD_VAR 0 3
45458: PPUSH
45459: LD_EXP 57
45463: PUSH
45464: LD_VAR 0 3
45468: ARRAY
45469: PUSH
45470: LD_VAR 0 1
45474: DIFF
45475: PPUSH
45476: CALL_OW 1
45480: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45481: LD_VAR 0 1
45485: PUSH
45486: LD_EXP 69
45490: PUSH
45491: LD_VAR 0 3
45495: ARRAY
45496: IN
45497: IFFALSE 45536
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45499: LD_ADDR_EXP 69
45503: PUSH
45504: LD_EXP 69
45508: PPUSH
45509: LD_VAR 0 3
45513: PPUSH
45514: LD_EXP 69
45518: PUSH
45519: LD_VAR 0 3
45523: ARRAY
45524: PUSH
45525: LD_VAR 0 1
45529: DIFF
45530: PPUSH
45531: CALL_OW 1
45535: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45536: LD_VAR 0 1
45540: PUSH
45541: LD_EXP 72
45545: PUSH
45546: LD_VAR 0 3
45550: ARRAY
45551: IN
45552: IFFALSE 45591
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45554: LD_ADDR_EXP 72
45558: PUSH
45559: LD_EXP 72
45563: PPUSH
45564: LD_VAR 0 3
45568: PPUSH
45569: LD_EXP 72
45573: PUSH
45574: LD_VAR 0 3
45578: ARRAY
45579: PUSH
45580: LD_VAR 0 1
45584: DIFF
45585: PPUSH
45586: CALL_OW 1
45590: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45591: LD_VAR 0 1
45595: PUSH
45596: LD_EXP 59
45600: PUSH
45601: LD_VAR 0 3
45605: ARRAY
45606: IN
45607: IFFALSE 45646
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45609: LD_ADDR_EXP 59
45613: PUSH
45614: LD_EXP 59
45618: PPUSH
45619: LD_VAR 0 3
45623: PPUSH
45624: LD_EXP 59
45628: PUSH
45629: LD_VAR 0 3
45633: ARRAY
45634: PUSH
45635: LD_VAR 0 1
45639: DIFF
45640: PPUSH
45641: CALL_OW 1
45645: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45646: LD_VAR 0 1
45650: PUSH
45651: LD_EXP 58
45655: PUSH
45656: LD_VAR 0 3
45660: ARRAY
45661: IN
45662: IFFALSE 45701
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45664: LD_ADDR_EXP 58
45668: PUSH
45669: LD_EXP 58
45673: PPUSH
45674: LD_VAR 0 3
45678: PPUSH
45679: LD_EXP 58
45683: PUSH
45684: LD_VAR 0 3
45688: ARRAY
45689: PUSH
45690: LD_VAR 0 1
45694: DIFF
45695: PPUSH
45696: CALL_OW 1
45700: ST_TO_ADDR
// end ; break ;
45701: GO 45705
// end ;
45703: GO 44351
45705: POP
45706: POP
// end ;
45707: LD_VAR 0 2
45711: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45712: LD_INT 0
45714: PPUSH
45715: PPUSH
45716: PPUSH
// if not mc_bases or not skirmish then
45717: LD_EXP 50
45721: NOT
45722: PUSH
45723: LD_EXP 48
45727: NOT
45728: OR
45729: IFFALSE 45733
// exit ;
45731: GO 45948
// for i = 1 to mc_bases do
45733: LD_ADDR_VAR 0 3
45737: PUSH
45738: DOUBLE
45739: LD_INT 1
45741: DEC
45742: ST_TO_ADDR
45743: LD_EXP 50
45747: PUSH
45748: FOR_TO
45749: IFFALSE 45946
// begin if building in mc_construct_list [ i ] then
45751: LD_VAR 0 1
45755: PUSH
45756: LD_EXP 57
45760: PUSH
45761: LD_VAR 0 3
45765: ARRAY
45766: IN
45767: IFFALSE 45944
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45769: LD_ADDR_EXP 57
45773: PUSH
45774: LD_EXP 57
45778: PPUSH
45779: LD_VAR 0 3
45783: PPUSH
45784: LD_EXP 57
45788: PUSH
45789: LD_VAR 0 3
45793: ARRAY
45794: PUSH
45795: LD_VAR 0 1
45799: DIFF
45800: PPUSH
45801: CALL_OW 1
45805: ST_TO_ADDR
// if building in mc_lab [ i ] then
45806: LD_VAR 0 1
45810: PUSH
45811: LD_EXP 83
45815: PUSH
45816: LD_VAR 0 3
45820: ARRAY
45821: IN
45822: IFFALSE 45877
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45824: LD_ADDR_EXP 84
45828: PUSH
45829: LD_EXP 84
45833: PPUSH
45834: LD_VAR 0 3
45838: PPUSH
45839: LD_EXP 84
45843: PUSH
45844: LD_VAR 0 3
45848: ARRAY
45849: PPUSH
45850: LD_INT 1
45852: PPUSH
45853: LD_EXP 84
45857: PUSH
45858: LD_VAR 0 3
45862: ARRAY
45863: PPUSH
45864: LD_INT 0
45866: PPUSH
45867: CALL 53917 0 4
45871: PPUSH
45872: CALL_OW 1
45876: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45877: LD_VAR 0 1
45881: PUSH
45882: LD_EXP 50
45886: PUSH
45887: LD_VAR 0 3
45891: ARRAY
45892: IN
45893: NOT
45894: IFFALSE 45940
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45896: LD_ADDR_EXP 50
45900: PUSH
45901: LD_EXP 50
45905: PPUSH
45906: LD_VAR 0 3
45910: PUSH
45911: LD_EXP 50
45915: PUSH
45916: LD_VAR 0 3
45920: ARRAY
45921: PUSH
45922: LD_INT 1
45924: PLUS
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PPUSH
45930: LD_VAR 0 1
45934: PPUSH
45935: CALL 54499 0 3
45939: ST_TO_ADDR
// exit ;
45940: POP
45941: POP
45942: GO 45948
// end ; end ;
45944: GO 45748
45946: POP
45947: POP
// end ;
45948: LD_VAR 0 2
45952: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
45953: LD_INT 0
45955: PPUSH
45956: PPUSH
45957: PPUSH
45958: PPUSH
45959: PPUSH
45960: PPUSH
45961: PPUSH
// if not mc_bases or not skirmish then
45962: LD_EXP 50
45966: NOT
45967: PUSH
45968: LD_EXP 48
45972: NOT
45973: OR
45974: IFFALSE 45978
// exit ;
45976: GO 46639
// for i = 1 to mc_bases do
45978: LD_ADDR_VAR 0 3
45982: PUSH
45983: DOUBLE
45984: LD_INT 1
45986: DEC
45987: ST_TO_ADDR
45988: LD_EXP 50
45992: PUSH
45993: FOR_TO
45994: IFFALSE 46637
// begin if building in mc_construct_list [ i ] then
45996: LD_VAR 0 1
46000: PUSH
46001: LD_EXP 57
46005: PUSH
46006: LD_VAR 0 3
46010: ARRAY
46011: IN
46012: IFFALSE 46635
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46014: LD_ADDR_EXP 57
46018: PUSH
46019: LD_EXP 57
46023: PPUSH
46024: LD_VAR 0 3
46028: PPUSH
46029: LD_EXP 57
46033: PUSH
46034: LD_VAR 0 3
46038: ARRAY
46039: PUSH
46040: LD_VAR 0 1
46044: DIFF
46045: PPUSH
46046: CALL_OW 1
46050: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46051: LD_ADDR_EXP 50
46055: PUSH
46056: LD_EXP 50
46060: PPUSH
46061: LD_VAR 0 3
46065: PUSH
46066: LD_EXP 50
46070: PUSH
46071: LD_VAR 0 3
46075: ARRAY
46076: PUSH
46077: LD_INT 1
46079: PLUS
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PPUSH
46085: LD_VAR 0 1
46089: PPUSH
46090: CALL 54499 0 3
46094: ST_TO_ADDR
// btype := GetBType ( building ) ;
46095: LD_ADDR_VAR 0 5
46099: PUSH
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 266
46109: ST_TO_ADDR
// side := GetSide ( building ) ;
46110: LD_ADDR_VAR 0 8
46114: PUSH
46115: LD_VAR 0 1
46119: PPUSH
46120: CALL_OW 255
46124: ST_TO_ADDR
// if btype = b_lab then
46125: LD_VAR 0 5
46129: PUSH
46130: LD_INT 6
46132: EQUAL
46133: IFFALSE 46183
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46135: LD_ADDR_EXP 83
46139: PUSH
46140: LD_EXP 83
46144: PPUSH
46145: LD_VAR 0 3
46149: PUSH
46150: LD_EXP 83
46154: PUSH
46155: LD_VAR 0 3
46159: ARRAY
46160: PUSH
46161: LD_INT 1
46163: PLUS
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PPUSH
46169: LD_VAR 0 1
46173: PPUSH
46174: CALL 54499 0 3
46178: ST_TO_ADDR
// exit ;
46179: POP
46180: POP
46181: GO 46639
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46183: LD_VAR 0 5
46187: PUSH
46188: LD_INT 0
46190: PUSH
46191: LD_INT 2
46193: PUSH
46194: LD_INT 4
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: LIST
46201: IN
46202: IFFALSE 46326
// begin if btype = b_armoury then
46204: LD_VAR 0 5
46208: PUSH
46209: LD_INT 4
46211: EQUAL
46212: IFFALSE 46222
// btype := b_barracks ;
46214: LD_ADDR_VAR 0 5
46218: PUSH
46219: LD_INT 5
46221: ST_TO_ADDR
// if btype = b_depot then
46222: LD_VAR 0 5
46226: PUSH
46227: LD_INT 0
46229: EQUAL
46230: IFFALSE 46240
// btype := b_warehouse ;
46232: LD_ADDR_VAR 0 5
46236: PUSH
46237: LD_INT 1
46239: ST_TO_ADDR
// if btype = b_workshop then
46240: LD_VAR 0 5
46244: PUSH
46245: LD_INT 2
46247: EQUAL
46248: IFFALSE 46258
// btype := b_factory ;
46250: LD_ADDR_VAR 0 5
46254: PUSH
46255: LD_INT 3
46257: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46258: LD_VAR 0 5
46262: PPUSH
46263: LD_VAR 0 8
46267: PPUSH
46268: CALL_OW 323
46272: PUSH
46273: LD_INT 1
46275: EQUAL
46276: IFFALSE 46322
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46278: LD_ADDR_EXP 82
46282: PUSH
46283: LD_EXP 82
46287: PPUSH
46288: LD_VAR 0 3
46292: PUSH
46293: LD_EXP 82
46297: PUSH
46298: LD_VAR 0 3
46302: ARRAY
46303: PUSH
46304: LD_INT 1
46306: PLUS
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PPUSH
46312: LD_VAR 0 1
46316: PPUSH
46317: CALL 54499 0 3
46321: ST_TO_ADDR
// exit ;
46322: POP
46323: POP
46324: GO 46639
// end ; if btype in [ b_bunker , b_turret ] then
46326: LD_VAR 0 5
46330: PUSH
46331: LD_INT 32
46333: PUSH
46334: LD_INT 33
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: IN
46341: IFFALSE 46631
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46343: LD_ADDR_EXP 58
46347: PUSH
46348: LD_EXP 58
46352: PPUSH
46353: LD_VAR 0 3
46357: PUSH
46358: LD_EXP 58
46362: PUSH
46363: LD_VAR 0 3
46367: ARRAY
46368: PUSH
46369: LD_INT 1
46371: PLUS
46372: PUSH
46373: EMPTY
46374: LIST
46375: LIST
46376: PPUSH
46377: LD_VAR 0 1
46381: PPUSH
46382: CALL 54499 0 3
46386: ST_TO_ADDR
// if btype = b_bunker then
46387: LD_VAR 0 5
46391: PUSH
46392: LD_INT 32
46394: EQUAL
46395: IFFALSE 46631
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46397: LD_ADDR_EXP 59
46401: PUSH
46402: LD_EXP 59
46406: PPUSH
46407: LD_VAR 0 3
46411: PUSH
46412: LD_EXP 59
46416: PUSH
46417: LD_VAR 0 3
46421: ARRAY
46422: PUSH
46423: LD_INT 1
46425: PLUS
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PPUSH
46431: LD_VAR 0 1
46435: PPUSH
46436: CALL 54499 0 3
46440: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46441: LD_ADDR_VAR 0 6
46445: PUSH
46446: LD_EXP 50
46450: PUSH
46451: LD_VAR 0 3
46455: ARRAY
46456: PPUSH
46457: LD_INT 25
46459: PUSH
46460: LD_INT 1
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: LD_INT 3
46469: PUSH
46470: LD_INT 54
46472: PUSH
46473: EMPTY
46474: LIST
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PPUSH
46484: CALL_OW 72
46488: ST_TO_ADDR
// if tmp then
46489: LD_VAR 0 6
46493: IFFALSE 46499
// exit ;
46495: POP
46496: POP
46497: GO 46639
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46499: LD_ADDR_VAR 0 6
46503: PUSH
46504: LD_EXP 50
46508: PUSH
46509: LD_VAR 0 3
46513: ARRAY
46514: PPUSH
46515: LD_INT 2
46517: PUSH
46518: LD_INT 30
46520: PUSH
46521: LD_INT 4
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 30
46530: PUSH
46531: LD_INT 5
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: LIST
46542: PPUSH
46543: CALL_OW 72
46547: ST_TO_ADDR
// if not tmp then
46548: LD_VAR 0 6
46552: NOT
46553: IFFALSE 46559
// exit ;
46555: POP
46556: POP
46557: GO 46639
// for j in tmp do
46559: LD_ADDR_VAR 0 4
46563: PUSH
46564: LD_VAR 0 6
46568: PUSH
46569: FOR_IN
46570: IFFALSE 46629
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46572: LD_ADDR_VAR 0 7
46576: PUSH
46577: LD_VAR 0 4
46581: PPUSH
46582: CALL_OW 313
46586: PPUSH
46587: LD_INT 25
46589: PUSH
46590: LD_INT 1
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PPUSH
46597: CALL_OW 72
46601: ST_TO_ADDR
// if units then
46602: LD_VAR 0 7
46606: IFFALSE 46627
// begin ComExitBuilding ( units [ 1 ] ) ;
46608: LD_VAR 0 7
46612: PUSH
46613: LD_INT 1
46615: ARRAY
46616: PPUSH
46617: CALL_OW 122
// exit ;
46621: POP
46622: POP
46623: POP
46624: POP
46625: GO 46639
// end ; end ;
46627: GO 46569
46629: POP
46630: POP
// end ; end ; exit ;
46631: POP
46632: POP
46633: GO 46639
// end ; end ;
46635: GO 45993
46637: POP
46638: POP
// end ;
46639: LD_VAR 0 2
46643: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46644: LD_INT 0
46646: PPUSH
46647: PPUSH
46648: PPUSH
46649: PPUSH
46650: PPUSH
46651: PPUSH
46652: PPUSH
// if not mc_bases or not skirmish then
46653: LD_EXP 50
46657: NOT
46658: PUSH
46659: LD_EXP 48
46663: NOT
46664: OR
46665: IFFALSE 46669
// exit ;
46667: GO 46900
// btype := GetBType ( building ) ;
46669: LD_ADDR_VAR 0 6
46673: PUSH
46674: LD_VAR 0 1
46678: PPUSH
46679: CALL_OW 266
46683: ST_TO_ADDR
// x := GetX ( building ) ;
46684: LD_ADDR_VAR 0 7
46688: PUSH
46689: LD_VAR 0 1
46693: PPUSH
46694: CALL_OW 250
46698: ST_TO_ADDR
// y := GetY ( building ) ;
46699: LD_ADDR_VAR 0 8
46703: PUSH
46704: LD_VAR 0 1
46708: PPUSH
46709: CALL_OW 251
46713: ST_TO_ADDR
// d := GetDir ( building ) ;
46714: LD_ADDR_VAR 0 9
46718: PUSH
46719: LD_VAR 0 1
46723: PPUSH
46724: CALL_OW 254
46728: ST_TO_ADDR
// for i = 1 to mc_bases do
46729: LD_ADDR_VAR 0 4
46733: PUSH
46734: DOUBLE
46735: LD_INT 1
46737: DEC
46738: ST_TO_ADDR
46739: LD_EXP 50
46743: PUSH
46744: FOR_TO
46745: IFFALSE 46898
// begin if not mc_build_list [ i ] then
46747: LD_EXP 55
46751: PUSH
46752: LD_VAR 0 4
46756: ARRAY
46757: NOT
46758: IFFALSE 46762
// continue ;
46760: GO 46744
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46762: LD_VAR 0 6
46766: PUSH
46767: LD_VAR 0 7
46771: PUSH
46772: LD_VAR 0 8
46776: PUSH
46777: LD_VAR 0 9
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: PPUSH
46788: LD_EXP 55
46792: PUSH
46793: LD_VAR 0 4
46797: ARRAY
46798: PUSH
46799: LD_INT 1
46801: ARRAY
46802: PPUSH
46803: CALL 60668 0 2
46807: IFFALSE 46896
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46809: LD_ADDR_EXP 55
46813: PUSH
46814: LD_EXP 55
46818: PPUSH
46819: LD_VAR 0 4
46823: PPUSH
46824: LD_EXP 55
46828: PUSH
46829: LD_VAR 0 4
46833: ARRAY
46834: PPUSH
46835: LD_INT 1
46837: PPUSH
46838: CALL_OW 3
46842: PPUSH
46843: CALL_OW 1
46847: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46848: LD_ADDR_EXP 57
46852: PUSH
46853: LD_EXP 57
46857: PPUSH
46858: LD_VAR 0 4
46862: PUSH
46863: LD_EXP 57
46867: PUSH
46868: LD_VAR 0 4
46872: ARRAY
46873: PUSH
46874: LD_INT 1
46876: PLUS
46877: PUSH
46878: EMPTY
46879: LIST
46880: LIST
46881: PPUSH
46882: LD_VAR 0 1
46886: PPUSH
46887: CALL 54499 0 3
46891: ST_TO_ADDR
// exit ;
46892: POP
46893: POP
46894: GO 46900
// end ; end ;
46896: GO 46744
46898: POP
46899: POP
// end ;
46900: LD_VAR 0 3
46904: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46905: LD_INT 0
46907: PPUSH
46908: PPUSH
46909: PPUSH
// if not mc_bases or not skirmish then
46910: LD_EXP 50
46914: NOT
46915: PUSH
46916: LD_EXP 48
46920: NOT
46921: OR
46922: IFFALSE 46926
// exit ;
46924: GO 47116
// for i = 1 to mc_bases do
46926: LD_ADDR_VAR 0 4
46930: PUSH
46931: DOUBLE
46932: LD_INT 1
46934: DEC
46935: ST_TO_ADDR
46936: LD_EXP 50
46940: PUSH
46941: FOR_TO
46942: IFFALSE 47029
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
46944: LD_VAR 0 1
46948: PUSH
46949: LD_EXP 58
46953: PUSH
46954: LD_VAR 0 4
46958: ARRAY
46959: IN
46960: PUSH
46961: LD_VAR 0 1
46965: PUSH
46966: LD_EXP 59
46970: PUSH
46971: LD_VAR 0 4
46975: ARRAY
46976: IN
46977: NOT
46978: AND
46979: IFFALSE 47027
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46981: LD_ADDR_EXP 59
46985: PUSH
46986: LD_EXP 59
46990: PPUSH
46991: LD_VAR 0 4
46995: PUSH
46996: LD_EXP 59
47000: PUSH
47001: LD_VAR 0 4
47005: ARRAY
47006: PUSH
47007: LD_INT 1
47009: PLUS
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PPUSH
47015: LD_VAR 0 1
47019: PPUSH
47020: CALL 54499 0 3
47024: ST_TO_ADDR
// break ;
47025: GO 47029
// end ; end ;
47027: GO 46941
47029: POP
47030: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47031: LD_VAR 0 1
47035: PPUSH
47036: CALL_OW 257
47040: PUSH
47041: LD_EXP 76
47045: IN
47046: PUSH
47047: LD_VAR 0 1
47051: PPUSH
47052: CALL_OW 266
47056: PUSH
47057: LD_INT 5
47059: EQUAL
47060: AND
47061: PUSH
47062: LD_VAR 0 2
47066: PPUSH
47067: CALL_OW 110
47071: PUSH
47072: LD_INT 18
47074: NONEQUAL
47075: AND
47076: IFFALSE 47116
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47078: LD_VAR 0 2
47082: PPUSH
47083: CALL_OW 257
47087: PUSH
47088: LD_INT 5
47090: PUSH
47091: LD_INT 8
47093: PUSH
47094: LD_INT 9
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: LIST
47101: IN
47102: IFFALSE 47116
// SetClass ( unit , 1 ) ;
47104: LD_VAR 0 2
47108: PPUSH
47109: LD_INT 1
47111: PPUSH
47112: CALL_OW 336
// end ;
47116: LD_VAR 0 3
47120: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47121: LD_INT 0
47123: PPUSH
47124: PPUSH
// if not mc_bases or not skirmish then
47125: LD_EXP 50
47129: NOT
47130: PUSH
47131: LD_EXP 48
47135: NOT
47136: OR
47137: IFFALSE 47141
// exit ;
47139: GO 47257
// if GetLives ( abandoned_vehicle ) > 250 then
47141: LD_VAR 0 2
47145: PPUSH
47146: CALL_OW 256
47150: PUSH
47151: LD_INT 250
47153: GREATER
47154: IFFALSE 47158
// exit ;
47156: GO 47257
// for i = 1 to mc_bases do
47158: LD_ADDR_VAR 0 6
47162: PUSH
47163: DOUBLE
47164: LD_INT 1
47166: DEC
47167: ST_TO_ADDR
47168: LD_EXP 50
47172: PUSH
47173: FOR_TO
47174: IFFALSE 47255
// begin if driver in mc_bases [ i ] then
47176: LD_VAR 0 1
47180: PUSH
47181: LD_EXP 50
47185: PUSH
47186: LD_VAR 0 6
47190: ARRAY
47191: IN
47192: IFFALSE 47253
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47194: LD_VAR 0 1
47198: PPUSH
47199: LD_EXP 50
47203: PUSH
47204: LD_VAR 0 6
47208: ARRAY
47209: PPUSH
47210: LD_INT 2
47212: PUSH
47213: LD_INT 30
47215: PUSH
47216: LD_INT 0
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: PUSH
47223: LD_INT 30
47225: PUSH
47226: LD_INT 1
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: LIST
47237: PPUSH
47238: CALL_OW 72
47242: PUSH
47243: LD_INT 1
47245: ARRAY
47246: PPUSH
47247: CALL_OW 112
// break ;
47251: GO 47255
// end ; end ;
47253: GO 47173
47255: POP
47256: POP
// end ; end_of_file
47257: LD_VAR 0 5
47261: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47262: LD_INT 0
47264: PPUSH
47265: PPUSH
// if exist_mode then
47266: LD_VAR 0 2
47270: IFFALSE 47295
// unit := CreateCharacter ( prefix & ident ) else
47272: LD_ADDR_VAR 0 5
47276: PUSH
47277: LD_VAR 0 3
47281: PUSH
47282: LD_VAR 0 1
47286: STR
47287: PPUSH
47288: CALL_OW 34
47292: ST_TO_ADDR
47293: GO 47310
// unit := NewCharacter ( ident ) ;
47295: LD_ADDR_VAR 0 5
47299: PUSH
47300: LD_VAR 0 1
47304: PPUSH
47305: CALL_OW 25
47309: ST_TO_ADDR
// result := unit ;
47310: LD_ADDR_VAR 0 4
47314: PUSH
47315: LD_VAR 0 5
47319: ST_TO_ADDR
// end ;
47320: LD_VAR 0 4
47324: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47325: LD_INT 0
47327: PPUSH
47328: PPUSH
// if not side or not nation then
47329: LD_VAR 0 1
47333: NOT
47334: PUSH
47335: LD_VAR 0 2
47339: NOT
47340: OR
47341: IFFALSE 47345
// exit ;
47343: GO 47989
// case nation of nation_american :
47345: LD_VAR 0 2
47349: PUSH
47350: LD_INT 1
47352: DOUBLE
47353: EQUAL
47354: IFTRUE 47358
47356: GO 47532
47358: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47359: LD_ADDR_VAR 0 4
47363: PUSH
47364: LD_INT 35
47366: PUSH
47367: LD_INT 45
47369: PUSH
47370: LD_INT 46
47372: PUSH
47373: LD_INT 47
47375: PUSH
47376: LD_INT 1
47378: PUSH
47379: LD_INT 2
47381: PUSH
47382: LD_INT 6
47384: PUSH
47385: LD_INT 15
47387: PUSH
47388: LD_INT 16
47390: PUSH
47391: LD_INT 7
47393: PUSH
47394: LD_INT 12
47396: PUSH
47397: LD_INT 13
47399: PUSH
47400: LD_INT 10
47402: PUSH
47403: LD_INT 14
47405: PUSH
47406: LD_INT 20
47408: PUSH
47409: LD_INT 21
47411: PUSH
47412: LD_INT 22
47414: PUSH
47415: LD_INT 25
47417: PUSH
47418: LD_INT 32
47420: PUSH
47421: LD_INT 27
47423: PUSH
47424: LD_INT 36
47426: PUSH
47427: LD_INT 69
47429: PUSH
47430: LD_INT 39
47432: PUSH
47433: LD_INT 34
47435: PUSH
47436: LD_INT 40
47438: PUSH
47439: LD_INT 48
47441: PUSH
47442: LD_INT 49
47444: PUSH
47445: LD_INT 50
47447: PUSH
47448: LD_INT 51
47450: PUSH
47451: LD_INT 52
47453: PUSH
47454: LD_INT 53
47456: PUSH
47457: LD_INT 54
47459: PUSH
47460: LD_INT 55
47462: PUSH
47463: LD_INT 56
47465: PUSH
47466: LD_INT 57
47468: PUSH
47469: LD_INT 58
47471: PUSH
47472: LD_INT 59
47474: PUSH
47475: LD_INT 60
47477: PUSH
47478: LD_INT 61
47480: PUSH
47481: LD_INT 62
47483: PUSH
47484: LD_INT 80
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: ST_TO_ADDR
47530: GO 47913
47532: LD_INT 2
47534: DOUBLE
47535: EQUAL
47536: IFTRUE 47540
47538: GO 47722
47540: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47541: LD_ADDR_VAR 0 4
47545: PUSH
47546: LD_INT 35
47548: PUSH
47549: LD_INT 45
47551: PUSH
47552: LD_INT 46
47554: PUSH
47555: LD_INT 47
47557: PUSH
47558: LD_INT 70
47560: PUSH
47561: LD_INT 1
47563: PUSH
47564: LD_INT 11
47566: PUSH
47567: LD_INT 3
47569: PUSH
47570: LD_INT 4
47572: PUSH
47573: LD_INT 5
47575: PUSH
47576: LD_INT 6
47578: PUSH
47579: LD_INT 15
47581: PUSH
47582: LD_INT 18
47584: PUSH
47585: LD_INT 7
47587: PUSH
47588: LD_INT 17
47590: PUSH
47591: LD_INT 8
47593: PUSH
47594: LD_INT 20
47596: PUSH
47597: LD_INT 21
47599: PUSH
47600: LD_INT 22
47602: PUSH
47603: LD_INT 72
47605: PUSH
47606: LD_INT 26
47608: PUSH
47609: LD_INT 69
47611: PUSH
47612: LD_INT 39
47614: PUSH
47615: LD_INT 40
47617: PUSH
47618: LD_INT 41
47620: PUSH
47621: LD_INT 42
47623: PUSH
47624: LD_INT 43
47626: PUSH
47627: LD_INT 48
47629: PUSH
47630: LD_INT 49
47632: PUSH
47633: LD_INT 50
47635: PUSH
47636: LD_INT 51
47638: PUSH
47639: LD_INT 52
47641: PUSH
47642: LD_INT 53
47644: PUSH
47645: LD_INT 54
47647: PUSH
47648: LD_INT 55
47650: PUSH
47651: LD_INT 56
47653: PUSH
47654: LD_INT 60
47656: PUSH
47657: LD_INT 61
47659: PUSH
47660: LD_INT 62
47662: PUSH
47663: LD_INT 66
47665: PUSH
47666: LD_INT 67
47668: PUSH
47669: LD_INT 68
47671: PUSH
47672: LD_INT 81
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: LIST
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: ST_TO_ADDR
47720: GO 47913
47722: LD_INT 3
47724: DOUBLE
47725: EQUAL
47726: IFTRUE 47730
47728: GO 47912
47730: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47731: LD_ADDR_VAR 0 4
47735: PUSH
47736: LD_INT 46
47738: PUSH
47739: LD_INT 47
47741: PUSH
47742: LD_INT 1
47744: PUSH
47745: LD_INT 2
47747: PUSH
47748: LD_INT 11
47750: PUSH
47751: LD_INT 9
47753: PUSH
47754: LD_INT 20
47756: PUSH
47757: LD_INT 19
47759: PUSH
47760: LD_INT 21
47762: PUSH
47763: LD_INT 24
47765: PUSH
47766: LD_INT 22
47768: PUSH
47769: LD_INT 25
47771: PUSH
47772: LD_INT 28
47774: PUSH
47775: LD_INT 29
47777: PUSH
47778: LD_INT 30
47780: PUSH
47781: LD_INT 31
47783: PUSH
47784: LD_INT 37
47786: PUSH
47787: LD_INT 38
47789: PUSH
47790: LD_INT 32
47792: PUSH
47793: LD_INT 27
47795: PUSH
47796: LD_INT 33
47798: PUSH
47799: LD_INT 69
47801: PUSH
47802: LD_INT 39
47804: PUSH
47805: LD_INT 34
47807: PUSH
47808: LD_INT 40
47810: PUSH
47811: LD_INT 71
47813: PUSH
47814: LD_INT 23
47816: PUSH
47817: LD_INT 44
47819: PUSH
47820: LD_INT 48
47822: PUSH
47823: LD_INT 49
47825: PUSH
47826: LD_INT 50
47828: PUSH
47829: LD_INT 51
47831: PUSH
47832: LD_INT 52
47834: PUSH
47835: LD_INT 53
47837: PUSH
47838: LD_INT 54
47840: PUSH
47841: LD_INT 55
47843: PUSH
47844: LD_INT 56
47846: PUSH
47847: LD_INT 57
47849: PUSH
47850: LD_INT 58
47852: PUSH
47853: LD_INT 59
47855: PUSH
47856: LD_INT 63
47858: PUSH
47859: LD_INT 64
47861: PUSH
47862: LD_INT 65
47864: PUSH
47865: EMPTY
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: ST_TO_ADDR
47910: GO 47913
47912: POP
// if state > - 1 and state < 3 then
47913: LD_VAR 0 3
47917: PUSH
47918: LD_INT 1
47920: NEG
47921: GREATER
47922: PUSH
47923: LD_VAR 0 3
47927: PUSH
47928: LD_INT 3
47930: LESS
47931: AND
47932: IFFALSE 47989
// for i in result do
47934: LD_ADDR_VAR 0 5
47938: PUSH
47939: LD_VAR 0 4
47943: PUSH
47944: FOR_IN
47945: IFFALSE 47987
// if GetTech ( i , side ) <> state then
47947: LD_VAR 0 5
47951: PPUSH
47952: LD_VAR 0 1
47956: PPUSH
47957: CALL_OW 321
47961: PUSH
47962: LD_VAR 0 3
47966: NONEQUAL
47967: IFFALSE 47985
// result := result diff i ;
47969: LD_ADDR_VAR 0 4
47973: PUSH
47974: LD_VAR 0 4
47978: PUSH
47979: LD_VAR 0 5
47983: DIFF
47984: ST_TO_ADDR
47985: GO 47944
47987: POP
47988: POP
// end ;
47989: LD_VAR 0 4
47993: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
47994: LD_INT 0
47996: PPUSH
47997: PPUSH
47998: PPUSH
// result := true ;
47999: LD_ADDR_VAR 0 3
48003: PUSH
48004: LD_INT 1
48006: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48007: LD_ADDR_VAR 0 5
48011: PUSH
48012: LD_VAR 0 2
48016: PPUSH
48017: CALL_OW 480
48021: ST_TO_ADDR
// if not tmp then
48022: LD_VAR 0 5
48026: NOT
48027: IFFALSE 48031
// exit ;
48029: GO 48080
// for i in tmp do
48031: LD_ADDR_VAR 0 4
48035: PUSH
48036: LD_VAR 0 5
48040: PUSH
48041: FOR_IN
48042: IFFALSE 48078
// if GetTech ( i , side ) <> state_researched then
48044: LD_VAR 0 4
48048: PPUSH
48049: LD_VAR 0 1
48053: PPUSH
48054: CALL_OW 321
48058: PUSH
48059: LD_INT 2
48061: NONEQUAL
48062: IFFALSE 48076
// begin result := false ;
48064: LD_ADDR_VAR 0 3
48068: PUSH
48069: LD_INT 0
48071: ST_TO_ADDR
// exit ;
48072: POP
48073: POP
48074: GO 48080
// end ;
48076: GO 48041
48078: POP
48079: POP
// end ;
48080: LD_VAR 0 3
48084: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48085: LD_INT 0
48087: PPUSH
48088: PPUSH
48089: PPUSH
48090: PPUSH
48091: PPUSH
48092: PPUSH
48093: PPUSH
48094: PPUSH
48095: PPUSH
48096: PPUSH
48097: PPUSH
48098: PPUSH
48099: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48100: LD_VAR 0 1
48104: NOT
48105: PUSH
48106: LD_VAR 0 1
48110: PPUSH
48111: CALL_OW 257
48115: PUSH
48116: LD_INT 9
48118: NONEQUAL
48119: OR
48120: IFFALSE 48124
// exit ;
48122: GO 48697
// side := GetSide ( unit ) ;
48124: LD_ADDR_VAR 0 9
48128: PUSH
48129: LD_VAR 0 1
48133: PPUSH
48134: CALL_OW 255
48138: ST_TO_ADDR
// tech_space := tech_spacanom ;
48139: LD_ADDR_VAR 0 12
48143: PUSH
48144: LD_INT 29
48146: ST_TO_ADDR
// tech_time := tech_taurad ;
48147: LD_ADDR_VAR 0 13
48151: PUSH
48152: LD_INT 28
48154: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48155: LD_ADDR_VAR 0 11
48159: PUSH
48160: LD_VAR 0 1
48164: PPUSH
48165: CALL_OW 310
48169: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48170: LD_VAR 0 11
48174: PPUSH
48175: CALL_OW 247
48179: PUSH
48180: LD_INT 2
48182: EQUAL
48183: IFFALSE 48187
// exit ;
48185: GO 48697
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48187: LD_ADDR_VAR 0 8
48191: PUSH
48192: LD_INT 81
48194: PUSH
48195: LD_VAR 0 9
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: PUSH
48204: LD_INT 3
48206: PUSH
48207: LD_INT 21
48209: PUSH
48210: LD_INT 3
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: PUSH
48217: EMPTY
48218: LIST
48219: LIST
48220: PUSH
48221: EMPTY
48222: LIST
48223: LIST
48224: PPUSH
48225: CALL_OW 69
48229: ST_TO_ADDR
// if not tmp then
48230: LD_VAR 0 8
48234: NOT
48235: IFFALSE 48239
// exit ;
48237: GO 48697
// if in_unit then
48239: LD_VAR 0 11
48243: IFFALSE 48267
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48245: LD_ADDR_VAR 0 10
48249: PUSH
48250: LD_VAR 0 8
48254: PPUSH
48255: LD_VAR 0 11
48259: PPUSH
48260: CALL_OW 74
48264: ST_TO_ADDR
48265: GO 48287
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48267: LD_ADDR_VAR 0 10
48271: PUSH
48272: LD_VAR 0 8
48276: PPUSH
48277: LD_VAR 0 1
48281: PPUSH
48282: CALL_OW 74
48286: ST_TO_ADDR
// if not enemy then
48287: LD_VAR 0 10
48291: NOT
48292: IFFALSE 48296
// exit ;
48294: GO 48697
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48296: LD_VAR 0 11
48300: PUSH
48301: LD_VAR 0 11
48305: PPUSH
48306: LD_VAR 0 10
48310: PPUSH
48311: CALL_OW 296
48315: PUSH
48316: LD_INT 13
48318: GREATER
48319: AND
48320: PUSH
48321: LD_VAR 0 1
48325: PPUSH
48326: LD_VAR 0 10
48330: PPUSH
48331: CALL_OW 296
48335: PUSH
48336: LD_INT 12
48338: GREATER
48339: OR
48340: IFFALSE 48344
// exit ;
48342: GO 48697
// missile := [ 1 ] ;
48344: LD_ADDR_VAR 0 14
48348: PUSH
48349: LD_INT 1
48351: PUSH
48352: EMPTY
48353: LIST
48354: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48355: LD_VAR 0 9
48359: PPUSH
48360: LD_VAR 0 12
48364: PPUSH
48365: CALL_OW 325
48369: IFFALSE 48398
// missile := Insert ( missile , missile + 1 , 2 ) ;
48371: LD_ADDR_VAR 0 14
48375: PUSH
48376: LD_VAR 0 14
48380: PPUSH
48381: LD_VAR 0 14
48385: PUSH
48386: LD_INT 1
48388: PLUS
48389: PPUSH
48390: LD_INT 2
48392: PPUSH
48393: CALL_OW 2
48397: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48398: LD_VAR 0 9
48402: PPUSH
48403: LD_VAR 0 13
48407: PPUSH
48408: CALL_OW 325
48412: PUSH
48413: LD_VAR 0 10
48417: PPUSH
48418: CALL_OW 255
48422: PPUSH
48423: LD_VAR 0 13
48427: PPUSH
48428: CALL_OW 325
48432: NOT
48433: AND
48434: IFFALSE 48463
// missile := Insert ( missile , missile + 1 , 3 ) ;
48436: LD_ADDR_VAR 0 14
48440: PUSH
48441: LD_VAR 0 14
48445: PPUSH
48446: LD_VAR 0 14
48450: PUSH
48451: LD_INT 1
48453: PLUS
48454: PPUSH
48455: LD_INT 3
48457: PPUSH
48458: CALL_OW 2
48462: ST_TO_ADDR
// if missile < 2 then
48463: LD_VAR 0 14
48467: PUSH
48468: LD_INT 2
48470: LESS
48471: IFFALSE 48475
// exit ;
48473: GO 48697
// x := GetX ( enemy ) ;
48475: LD_ADDR_VAR 0 4
48479: PUSH
48480: LD_VAR 0 10
48484: PPUSH
48485: CALL_OW 250
48489: ST_TO_ADDR
// y := GetY ( enemy ) ;
48490: LD_ADDR_VAR 0 5
48494: PUSH
48495: LD_VAR 0 10
48499: PPUSH
48500: CALL_OW 251
48504: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48505: LD_ADDR_VAR 0 6
48509: PUSH
48510: LD_VAR 0 4
48514: PUSH
48515: LD_INT 1
48517: NEG
48518: PPUSH
48519: LD_INT 1
48521: PPUSH
48522: CALL_OW 12
48526: PLUS
48527: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48528: LD_ADDR_VAR 0 7
48532: PUSH
48533: LD_VAR 0 5
48537: PUSH
48538: LD_INT 1
48540: NEG
48541: PPUSH
48542: LD_INT 1
48544: PPUSH
48545: CALL_OW 12
48549: PLUS
48550: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48551: LD_VAR 0 6
48555: PPUSH
48556: LD_VAR 0 7
48560: PPUSH
48561: CALL_OW 488
48565: NOT
48566: IFFALSE 48588
// begin _x := x ;
48568: LD_ADDR_VAR 0 6
48572: PUSH
48573: LD_VAR 0 4
48577: ST_TO_ADDR
// _y := y ;
48578: LD_ADDR_VAR 0 7
48582: PUSH
48583: LD_VAR 0 5
48587: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48588: LD_ADDR_VAR 0 3
48592: PUSH
48593: LD_INT 1
48595: PPUSH
48596: LD_VAR 0 14
48600: PPUSH
48601: CALL_OW 12
48605: ST_TO_ADDR
// case i of 1 :
48606: LD_VAR 0 3
48610: PUSH
48611: LD_INT 1
48613: DOUBLE
48614: EQUAL
48615: IFTRUE 48619
48617: GO 48636
48619: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48620: LD_VAR 0 1
48624: PPUSH
48625: LD_VAR 0 10
48629: PPUSH
48630: CALL_OW 115
48634: GO 48697
48636: LD_INT 2
48638: DOUBLE
48639: EQUAL
48640: IFTRUE 48644
48642: GO 48666
48644: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48645: LD_VAR 0 1
48649: PPUSH
48650: LD_VAR 0 6
48654: PPUSH
48655: LD_VAR 0 7
48659: PPUSH
48660: CALL_OW 153
48664: GO 48697
48666: LD_INT 3
48668: DOUBLE
48669: EQUAL
48670: IFTRUE 48674
48672: GO 48696
48674: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48675: LD_VAR 0 1
48679: PPUSH
48680: LD_VAR 0 6
48684: PPUSH
48685: LD_VAR 0 7
48689: PPUSH
48690: CALL_OW 154
48694: GO 48697
48696: POP
// end ;
48697: LD_VAR 0 2
48701: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48702: LD_INT 0
48704: PPUSH
48705: PPUSH
48706: PPUSH
48707: PPUSH
48708: PPUSH
48709: PPUSH
// if not unit or not building then
48710: LD_VAR 0 1
48714: NOT
48715: PUSH
48716: LD_VAR 0 2
48720: NOT
48721: OR
48722: IFFALSE 48726
// exit ;
48724: GO 48884
// x := GetX ( building ) ;
48726: LD_ADDR_VAR 0 5
48730: PUSH
48731: LD_VAR 0 2
48735: PPUSH
48736: CALL_OW 250
48740: ST_TO_ADDR
// y := GetY ( building ) ;
48741: LD_ADDR_VAR 0 6
48745: PUSH
48746: LD_VAR 0 2
48750: PPUSH
48751: CALL_OW 251
48755: ST_TO_ADDR
// for i = 0 to 5 do
48756: LD_ADDR_VAR 0 4
48760: PUSH
48761: DOUBLE
48762: LD_INT 0
48764: DEC
48765: ST_TO_ADDR
48766: LD_INT 5
48768: PUSH
48769: FOR_TO
48770: IFFALSE 48882
// begin _x := ShiftX ( x , i , 3 ) ;
48772: LD_ADDR_VAR 0 7
48776: PUSH
48777: LD_VAR 0 5
48781: PPUSH
48782: LD_VAR 0 4
48786: PPUSH
48787: LD_INT 3
48789: PPUSH
48790: CALL_OW 272
48794: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48795: LD_ADDR_VAR 0 8
48799: PUSH
48800: LD_VAR 0 6
48804: PPUSH
48805: LD_VAR 0 4
48809: PPUSH
48810: LD_INT 3
48812: PPUSH
48813: CALL_OW 273
48817: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48818: LD_VAR 0 7
48822: PPUSH
48823: LD_VAR 0 8
48827: PPUSH
48828: CALL_OW 488
48832: NOT
48833: IFFALSE 48837
// continue ;
48835: GO 48769
// if HexInfo ( _x , _y ) = 0 then
48837: LD_VAR 0 7
48841: PPUSH
48842: LD_VAR 0 8
48846: PPUSH
48847: CALL_OW 428
48851: PUSH
48852: LD_INT 0
48854: EQUAL
48855: IFFALSE 48880
// begin ComMoveXY ( unit , _x , _y ) ;
48857: LD_VAR 0 1
48861: PPUSH
48862: LD_VAR 0 7
48866: PPUSH
48867: LD_VAR 0 8
48871: PPUSH
48872: CALL_OW 111
// exit ;
48876: POP
48877: POP
48878: GO 48884
// end ; end ;
48880: GO 48769
48882: POP
48883: POP
// end ;
48884: LD_VAR 0 3
48888: RET
// export function ScanBase ( side , base_area ) ; begin
48889: LD_INT 0
48891: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48892: LD_ADDR_VAR 0 3
48896: PUSH
48897: LD_VAR 0 2
48901: PPUSH
48902: LD_INT 81
48904: PUSH
48905: LD_VAR 0 1
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: PPUSH
48914: CALL_OW 70
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
48929: PPUSH
48930: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48931: LD_VAR 0 1
48935: NOT
48936: PUSH
48937: LD_EXP 50
48941: PUSH
48942: LD_VAR 0 1
48946: ARRAY
48947: NOT
48948: OR
48949: PUSH
48950: LD_VAR 0 2
48954: NOT
48955: OR
48956: PUSH
48957: LD_VAR 0 3
48961: NOT
48962: OR
48963: IFFALSE 48967
// exit ;
48965: GO 49480
// side := mc_sides [ base ] ;
48967: LD_ADDR_VAR 0 6
48971: PUSH
48972: LD_EXP 76
48976: PUSH
48977: LD_VAR 0 1
48981: ARRAY
48982: ST_TO_ADDR
// if not side then
48983: LD_VAR 0 6
48987: NOT
48988: IFFALSE 48992
// exit ;
48990: GO 49480
// for i in solds do
48992: LD_ADDR_VAR 0 7
48996: PUSH
48997: LD_VAR 0 2
49001: PUSH
49002: FOR_IN
49003: IFFALSE 49064
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
49005: LD_VAR 0 7
49009: PPUSH
49010: CALL_OW 310
49014: PPUSH
49015: CALL_OW 266
49019: PUSH
49020: LD_INT 32
49022: PUSH
49023: LD_INT 31
49025: PUSH
49026: EMPTY
49027: LIST
49028: LIST
49029: IN
49030: IFFALSE 49050
// solds := solds diff i else
49032: LD_ADDR_VAR 0 2
49036: PUSH
49037: LD_VAR 0 2
49041: PUSH
49042: LD_VAR 0 7
49046: DIFF
49047: ST_TO_ADDR
49048: GO 49062
// SetTag ( i , 18 ) ;
49050: LD_VAR 0 7
49054: PPUSH
49055: LD_INT 18
49057: PPUSH
49058: CALL_OW 109
49062: GO 49002
49064: POP
49065: POP
// if not solds then
49066: LD_VAR 0 2
49070: NOT
49071: IFFALSE 49075
// exit ;
49073: GO 49480
// repeat wait ( 0 0$1 ) ;
49075: LD_INT 35
49077: PPUSH
49078: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
49082: LD_ADDR_VAR 0 5
49086: PUSH
49087: LD_VAR 0 6
49091: PPUSH
49092: LD_VAR 0 3
49096: PPUSH
49097: CALL 48889 0 2
49101: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49102: LD_EXP 50
49106: PUSH
49107: LD_VAR 0 1
49111: ARRAY
49112: NOT
49113: PUSH
49114: LD_EXP 50
49118: PUSH
49119: LD_VAR 0 1
49123: ARRAY
49124: PUSH
49125: EMPTY
49126: EQUAL
49127: OR
49128: IFFALSE 49165
// begin for i in solds do
49130: LD_ADDR_VAR 0 7
49134: PUSH
49135: LD_VAR 0 2
49139: PUSH
49140: FOR_IN
49141: IFFALSE 49154
// ComStop ( i ) ;
49143: LD_VAR 0 7
49147: PPUSH
49148: CALL_OW 141
49152: GO 49140
49154: POP
49155: POP
// solds := [ ] ;
49156: LD_ADDR_VAR 0 2
49160: PUSH
49161: EMPTY
49162: ST_TO_ADDR
// exit ;
49163: GO 49480
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
49165: LD_VAR 0 5
49169: NOT
49170: PUSH
49171: LD_VAR 0 5
49175: PUSH
49176: LD_INT 3
49178: GREATER
49179: OR
49180: PUSH
49181: LD_EXP 72
49185: PUSH
49186: LD_VAR 0 1
49190: ARRAY
49191: OR
49192: IFFALSE 49233
// begin for i in solds do
49194: LD_ADDR_VAR 0 7
49198: PUSH
49199: LD_VAR 0 2
49203: PUSH
49204: FOR_IN
49205: IFFALSE 49229
// if HasTask ( i ) then
49207: LD_VAR 0 7
49211: PPUSH
49212: CALL_OW 314
49216: IFFALSE 49227
// ComStop ( i ) ;
49218: LD_VAR 0 7
49222: PPUSH
49223: CALL_OW 141
49227: GO 49204
49229: POP
49230: POP
// break ;
49231: GO 49468
// end ; for i in solds do
49233: LD_ADDR_VAR 0 7
49237: PUSH
49238: LD_VAR 0 2
49242: PUSH
49243: FOR_IN
49244: IFFALSE 49460
// begin if IsInUnit ( i ) then
49246: LD_VAR 0 7
49250: PPUSH
49251: CALL_OW 310
49255: IFFALSE 49266
// ComExitBuilding ( i ) ;
49257: LD_VAR 0 7
49261: PPUSH
49262: CALL_OW 122
// if GetLives ( i ) > 333 then
49266: LD_VAR 0 7
49270: PPUSH
49271: CALL_OW 256
49275: PUSH
49276: LD_INT 333
49278: GREATER
49279: IFFALSE 49307
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49281: LD_VAR 0 7
49285: PPUSH
49286: LD_VAR 0 5
49290: PPUSH
49291: LD_VAR 0 7
49295: PPUSH
49296: CALL_OW 74
49300: PPUSH
49301: CALL_OW 115
49305: GO 49458
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49307: LD_ADDR_VAR 0 8
49311: PUSH
49312: LD_EXP 50
49316: PUSH
49317: LD_VAR 0 1
49321: ARRAY
49322: PPUSH
49323: LD_INT 2
49325: PUSH
49326: LD_INT 30
49328: PUSH
49329: LD_INT 0
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 30
49338: PUSH
49339: LD_INT 1
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: PUSH
49346: LD_INT 30
49348: PUSH
49349: LD_INT 6
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: PUSH
49356: EMPTY
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: PPUSH
49362: CALL_OW 72
49366: PPUSH
49367: LD_VAR 0 7
49371: PPUSH
49372: CALL_OW 74
49376: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49377: LD_VAR 0 7
49381: PPUSH
49382: LD_VAR 0 8
49386: PPUSH
49387: CALL_OW 250
49391: PPUSH
49392: LD_INT 3
49394: PPUSH
49395: LD_INT 5
49397: PPUSH
49398: CALL_OW 272
49402: PPUSH
49403: LD_VAR 0 8
49407: PPUSH
49408: CALL_OW 251
49412: PPUSH
49413: LD_INT 3
49415: PPUSH
49416: LD_INT 5
49418: PPUSH
49419: CALL_OW 273
49423: PPUSH
49424: CALL_OW 111
// SetTag ( i , 0 ) ;
49428: LD_VAR 0 7
49432: PPUSH
49433: LD_INT 0
49435: PPUSH
49436: CALL_OW 109
// solds := solds diff i ;
49440: LD_ADDR_VAR 0 2
49444: PUSH
49445: LD_VAR 0 2
49449: PUSH
49450: LD_VAR 0 7
49454: DIFF
49455: ST_TO_ADDR
// continue ;
49456: GO 49243
// end ; end ;
49458: GO 49243
49460: POP
49461: POP
// until solds ;
49462: LD_VAR 0 2
49466: IFFALSE 49075
// MC_Reset ( base , 18 ) ;
49468: LD_VAR 0 1
49472: PPUSH
49473: LD_INT 18
49475: PPUSH
49476: CALL 21301 0 2
// end ;
49480: LD_VAR 0 4
49484: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49485: LD_INT 0
49487: PPUSH
49488: PPUSH
49489: PPUSH
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
49494: PPUSH
49495: PPUSH
49496: PPUSH
49497: PPUSH
49498: PPUSH
49499: PPUSH
49500: PPUSH
49501: PPUSH
49502: PPUSH
49503: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49504: LD_ADDR_VAR 0 13
49508: PUSH
49509: LD_EXP 50
49513: PUSH
49514: LD_VAR 0 1
49518: ARRAY
49519: PPUSH
49520: LD_INT 25
49522: PUSH
49523: LD_INT 3
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PPUSH
49530: CALL_OW 72
49534: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49535: LD_EXP 90
49539: PUSH
49540: LD_VAR 0 1
49544: ARRAY
49545: IFFALSE 49569
// mechs := mechs diff mc_remote_driver [ base ] ;
49547: LD_ADDR_VAR 0 13
49551: PUSH
49552: LD_VAR 0 13
49556: PUSH
49557: LD_EXP 90
49561: PUSH
49562: LD_VAR 0 1
49566: ARRAY
49567: DIFF
49568: ST_TO_ADDR
// for i in mechs do
49569: LD_ADDR_VAR 0 5
49573: PUSH
49574: LD_VAR 0 13
49578: PUSH
49579: FOR_IN
49580: IFFALSE 49615
// if GetTag ( i ) > 0 then
49582: LD_VAR 0 5
49586: PPUSH
49587: CALL_OW 110
49591: PUSH
49592: LD_INT 0
49594: GREATER
49595: IFFALSE 49613
// mechs := mechs diff i ;
49597: LD_ADDR_VAR 0 13
49601: PUSH
49602: LD_VAR 0 13
49606: PUSH
49607: LD_VAR 0 5
49611: DIFF
49612: ST_TO_ADDR
49613: GO 49579
49615: POP
49616: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49617: LD_ADDR_VAR 0 9
49621: PUSH
49622: LD_EXP 50
49626: PUSH
49627: LD_VAR 0 1
49631: ARRAY
49632: PPUSH
49633: LD_INT 2
49635: PUSH
49636: LD_INT 25
49638: PUSH
49639: LD_INT 1
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: PUSH
49646: LD_INT 25
49648: PUSH
49649: LD_INT 5
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: PUSH
49656: LD_INT 25
49658: PUSH
49659: LD_INT 8
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PUSH
49666: LD_INT 25
49668: PUSH
49669: LD_INT 9
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: LIST
49680: LIST
49681: LIST
49682: PPUSH
49683: CALL_OW 72
49687: ST_TO_ADDR
// if not defenders and not solds then
49688: LD_VAR 0 2
49692: NOT
49693: PUSH
49694: LD_VAR 0 9
49698: NOT
49699: AND
49700: IFFALSE 49704
// exit ;
49702: GO 51330
// depot_under_attack := false ;
49704: LD_ADDR_VAR 0 17
49708: PUSH
49709: LD_INT 0
49711: ST_TO_ADDR
// sold_defenders := [ ] ;
49712: LD_ADDR_VAR 0 18
49716: PUSH
49717: EMPTY
49718: ST_TO_ADDR
// if mechs then
49719: LD_VAR 0 13
49723: IFFALSE 49852
// for i in defenders do
49725: LD_ADDR_VAR 0 5
49729: PUSH
49730: LD_VAR 0 2
49734: PUSH
49735: FOR_IN
49736: IFFALSE 49850
// begin SetTag ( i , 20 ) ;
49738: LD_VAR 0 5
49742: PPUSH
49743: LD_INT 20
49745: PPUSH
49746: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49750: LD_VAR 0 5
49754: PPUSH
49755: CALL_OW 263
49759: PUSH
49760: LD_INT 1
49762: EQUAL
49763: PUSH
49764: LD_VAR 0 5
49768: PPUSH
49769: CALL_OW 311
49773: NOT
49774: AND
49775: PUSH
49776: LD_VAR 0 13
49780: AND
49781: IFFALSE 49848
// begin un := mechs [ 1 ] ;
49783: LD_ADDR_VAR 0 11
49787: PUSH
49788: LD_VAR 0 13
49792: PUSH
49793: LD_INT 1
49795: ARRAY
49796: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49797: LD_VAR 0 11
49801: PPUSH
49802: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49806: LD_VAR 0 11
49810: PPUSH
49811: LD_VAR 0 5
49815: PPUSH
49816: CALL_OW 180
// SetTag ( un , 19 ) ;
49820: LD_VAR 0 11
49824: PPUSH
49825: LD_INT 19
49827: PPUSH
49828: CALL_OW 109
// mechs := mechs diff un ;
49832: LD_ADDR_VAR 0 13
49836: PUSH
49837: LD_VAR 0 13
49841: PUSH
49842: LD_VAR 0 11
49846: DIFF
49847: ST_TO_ADDR
// end ; end ;
49848: GO 49735
49850: POP
49851: POP
// if solds then
49852: LD_VAR 0 9
49856: IFFALSE 49915
// for i in solds do
49858: LD_ADDR_VAR 0 5
49862: PUSH
49863: LD_VAR 0 9
49867: PUSH
49868: FOR_IN
49869: IFFALSE 49913
// if not GetTag ( i ) then
49871: LD_VAR 0 5
49875: PPUSH
49876: CALL_OW 110
49880: NOT
49881: IFFALSE 49911
// begin defenders := defenders union i ;
49883: LD_ADDR_VAR 0 2
49887: PUSH
49888: LD_VAR 0 2
49892: PUSH
49893: LD_VAR 0 5
49897: UNION
49898: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49899: LD_VAR 0 5
49903: PPUSH
49904: LD_INT 18
49906: PPUSH
49907: CALL_OW 109
// end ;
49911: GO 49868
49913: POP
49914: POP
// repeat wait ( 0 0$1 ) ;
49915: LD_INT 35
49917: PPUSH
49918: CALL_OW 67
// enemy := mc_scan [ base ] ;
49922: LD_ADDR_VAR 0 3
49926: PUSH
49927: LD_EXP 73
49931: PUSH
49932: LD_VAR 0 1
49936: ARRAY
49937: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49938: LD_EXP 50
49942: PUSH
49943: LD_VAR 0 1
49947: ARRAY
49948: NOT
49949: PUSH
49950: LD_EXP 50
49954: PUSH
49955: LD_VAR 0 1
49959: ARRAY
49960: PUSH
49961: EMPTY
49962: EQUAL
49963: OR
49964: IFFALSE 50001
// begin for i in defenders do
49966: LD_ADDR_VAR 0 5
49970: PUSH
49971: LD_VAR 0 2
49975: PUSH
49976: FOR_IN
49977: IFFALSE 49990
// ComStop ( i ) ;
49979: LD_VAR 0 5
49983: PPUSH
49984: CALL_OW 141
49988: GO 49976
49990: POP
49991: POP
// defenders := [ ] ;
49992: LD_ADDR_VAR 0 2
49996: PUSH
49997: EMPTY
49998: ST_TO_ADDR
// exit ;
49999: GO 51330
// end ; for i in defenders do
50001: LD_ADDR_VAR 0 5
50005: PUSH
50006: LD_VAR 0 2
50010: PUSH
50011: FOR_IN
50012: IFFALSE 50830
// begin e := NearestUnitToUnit ( enemy , i ) ;
50014: LD_ADDR_VAR 0 14
50018: PUSH
50019: LD_VAR 0 3
50023: PPUSH
50024: LD_VAR 0 5
50028: PPUSH
50029: CALL_OW 74
50033: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50034: LD_ADDR_VAR 0 8
50038: PUSH
50039: LD_EXP 50
50043: PUSH
50044: LD_VAR 0 1
50048: ARRAY
50049: PPUSH
50050: LD_INT 2
50052: PUSH
50053: LD_INT 30
50055: PUSH
50056: LD_INT 0
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 30
50065: PUSH
50066: LD_INT 1
50068: PUSH
50069: EMPTY
50070: LIST
50071: LIST
50072: PUSH
50073: EMPTY
50074: LIST
50075: LIST
50076: LIST
50077: PPUSH
50078: CALL_OW 72
50082: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
50083: LD_ADDR_VAR 0 17
50087: PUSH
50088: LD_VAR 0 8
50092: NOT
50093: PUSH
50094: LD_VAR 0 8
50098: PPUSH
50099: LD_INT 3
50101: PUSH
50102: LD_INT 24
50104: PUSH
50105: LD_INT 600
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: PUSH
50112: EMPTY
50113: LIST
50114: LIST
50115: PPUSH
50116: CALL_OW 72
50120: OR
50121: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
50122: LD_VAR 0 5
50126: PPUSH
50127: CALL_OW 247
50131: PUSH
50132: LD_INT 2
50134: DOUBLE
50135: EQUAL
50136: IFTRUE 50140
50138: GO 50536
50140: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
50141: LD_VAR 0 5
50145: PPUSH
50146: CALL_OW 256
50150: PUSH
50151: LD_INT 650
50153: GREATER
50154: PUSH
50155: LD_VAR 0 5
50159: PPUSH
50160: LD_VAR 0 14
50164: PPUSH
50165: CALL_OW 296
50169: PUSH
50170: LD_INT 40
50172: LESS
50173: PUSH
50174: LD_VAR 0 14
50178: PPUSH
50179: LD_EXP 75
50183: PUSH
50184: LD_VAR 0 1
50188: ARRAY
50189: PPUSH
50190: CALL_OW 308
50194: OR
50195: AND
50196: IFFALSE 50318
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
50198: LD_VAR 0 5
50202: PPUSH
50203: CALL_OW 262
50207: PUSH
50208: LD_INT 1
50210: EQUAL
50211: PUSH
50212: LD_VAR 0 5
50216: PPUSH
50217: CALL_OW 261
50221: PUSH
50222: LD_INT 30
50224: LESS
50225: AND
50226: PUSH
50227: LD_VAR 0 8
50231: AND
50232: IFFALSE 50302
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
50234: LD_VAR 0 5
50238: PPUSH
50239: LD_VAR 0 8
50243: PPUSH
50244: LD_VAR 0 5
50248: PPUSH
50249: CALL_OW 74
50253: PPUSH
50254: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
50258: LD_VAR 0 5
50262: PPUSH
50263: LD_VAR 0 8
50267: PPUSH
50268: LD_VAR 0 5
50272: PPUSH
50273: CALL_OW 74
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 6
50285: LESS
50286: IFFALSE 50300
// SetFuel ( i , 100 ) ;
50288: LD_VAR 0 5
50292: PPUSH
50293: LD_INT 100
50295: PPUSH
50296: CALL_OW 240
// end else
50300: GO 50316
// ComAttackUnit ( i , e ) ;
50302: LD_VAR 0 5
50306: PPUSH
50307: LD_VAR 0 14
50311: PPUSH
50312: CALL_OW 115
// end else
50316: GO 50419
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
50318: LD_VAR 0 14
50322: PPUSH
50323: LD_EXP 75
50327: PUSH
50328: LD_VAR 0 1
50332: ARRAY
50333: PPUSH
50334: CALL_OW 308
50338: NOT
50339: PUSH
50340: LD_VAR 0 5
50344: PPUSH
50345: LD_VAR 0 14
50349: PPUSH
50350: CALL_OW 296
50354: PUSH
50355: LD_INT 40
50357: GREATEREQUAL
50358: AND
50359: PUSH
50360: LD_VAR 0 5
50364: PPUSH
50365: CALL_OW 256
50369: PUSH
50370: LD_INT 650
50372: LESSEQUAL
50373: OR
50374: PUSH
50375: LD_VAR 0 5
50379: PPUSH
50380: LD_EXP 74
50384: PUSH
50385: LD_VAR 0 1
50389: ARRAY
50390: PPUSH
50391: CALL_OW 308
50395: NOT
50396: AND
50397: IFFALSE 50419
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50399: LD_VAR 0 5
50403: PPUSH
50404: LD_EXP 74
50408: PUSH
50409: LD_VAR 0 1
50413: ARRAY
50414: PPUSH
50415: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50419: LD_VAR 0 5
50423: PPUSH
50424: CALL_OW 256
50428: PUSH
50429: LD_INT 998
50431: LESS
50432: PUSH
50433: LD_VAR 0 5
50437: PPUSH
50438: CALL_OW 263
50442: PUSH
50443: LD_INT 1
50445: EQUAL
50446: AND
50447: PUSH
50448: LD_VAR 0 5
50452: PPUSH
50453: CALL_OW 311
50457: AND
50458: PUSH
50459: LD_VAR 0 5
50463: PPUSH
50464: LD_EXP 74
50468: PUSH
50469: LD_VAR 0 1
50473: ARRAY
50474: PPUSH
50475: CALL_OW 308
50479: AND
50480: IFFALSE 50534
// begin mech := IsDrivenBy ( i ) ;
50482: LD_ADDR_VAR 0 10
50486: PUSH
50487: LD_VAR 0 5
50491: PPUSH
50492: CALL_OW 311
50496: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50497: LD_VAR 0 10
50501: PPUSH
50502: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50506: LD_VAR 0 10
50510: PPUSH
50511: LD_VAR 0 5
50515: PPUSH
50516: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50520: LD_VAR 0 10
50524: PPUSH
50525: LD_VAR 0 5
50529: PPUSH
50530: CALL_OW 180
// end ; end ; unit_human :
50534: GO 50801
50536: LD_INT 1
50538: DOUBLE
50539: EQUAL
50540: IFTRUE 50544
50542: GO 50800
50544: POP
// begin b := IsInUnit ( i ) ;
50545: LD_ADDR_VAR 0 19
50549: PUSH
50550: LD_VAR 0 5
50554: PPUSH
50555: CALL_OW 310
50559: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50560: LD_ADDR_VAR 0 20
50564: PUSH
50565: LD_VAR 0 19
50569: NOT
50570: PUSH
50571: LD_VAR 0 19
50575: PPUSH
50576: CALL_OW 266
50580: PUSH
50581: LD_INT 32
50583: PUSH
50584: LD_INT 31
50586: PUSH
50587: EMPTY
50588: LIST
50589: LIST
50590: IN
50591: OR
50592: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50593: LD_VAR 0 17
50597: PUSH
50598: LD_VAR 0 2
50602: PPUSH
50603: LD_INT 21
50605: PUSH
50606: LD_INT 2
50608: PUSH
50609: EMPTY
50610: LIST
50611: LIST
50612: PPUSH
50613: CALL_OW 72
50617: PUSH
50618: LD_INT 1
50620: LESSEQUAL
50621: OR
50622: PUSH
50623: LD_VAR 0 20
50627: AND
50628: PUSH
50629: LD_VAR 0 5
50633: PUSH
50634: LD_VAR 0 18
50638: IN
50639: NOT
50640: AND
50641: IFFALSE 50734
// begin if b then
50643: LD_VAR 0 19
50647: IFFALSE 50696
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50649: LD_VAR 0 19
50653: PPUSH
50654: LD_VAR 0 3
50658: PPUSH
50659: LD_VAR 0 19
50663: PPUSH
50664: CALL_OW 74
50668: PPUSH
50669: CALL_OW 296
50673: PUSH
50674: LD_INT 10
50676: LESS
50677: PUSH
50678: LD_VAR 0 19
50682: PPUSH
50683: CALL_OW 461
50687: PUSH
50688: LD_INT 7
50690: NONEQUAL
50691: AND
50692: IFFALSE 50696
// continue ;
50694: GO 50011
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50696: LD_ADDR_VAR 0 18
50700: PUSH
50701: LD_VAR 0 18
50705: PPUSH
50706: LD_VAR 0 18
50710: PUSH
50711: LD_INT 1
50713: PLUS
50714: PPUSH
50715: LD_VAR 0 5
50719: PPUSH
50720: CALL_OW 1
50724: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50725: LD_VAR 0 5
50729: PPUSH
50730: CALL_OW 122
// end ; if sold_defenders then
50734: LD_VAR 0 18
50738: IFFALSE 50798
// if i in sold_defenders then
50740: LD_VAR 0 5
50744: PUSH
50745: LD_VAR 0 18
50749: IN
50750: IFFALSE 50798
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50752: LD_VAR 0 5
50756: PPUSH
50757: CALL_OW 314
50761: NOT
50762: PUSH
50763: LD_VAR 0 5
50767: PPUSH
50768: LD_VAR 0 14
50772: PPUSH
50773: CALL_OW 296
50777: PUSH
50778: LD_INT 30
50780: LESS
50781: AND
50782: IFFALSE 50798
// ComAttackUnit ( i , e ) ;
50784: LD_VAR 0 5
50788: PPUSH
50789: LD_VAR 0 14
50793: PPUSH
50794: CALL_OW 115
// end ; end ; end ;
50798: GO 50801
50800: POP
// if IsDead ( i ) then
50801: LD_VAR 0 5
50805: PPUSH
50806: CALL_OW 301
50810: IFFALSE 50828
// defenders := defenders diff i ;
50812: LD_ADDR_VAR 0 2
50816: PUSH
50817: LD_VAR 0 2
50821: PUSH
50822: LD_VAR 0 5
50826: DIFF
50827: ST_TO_ADDR
// end ;
50828: GO 50011
50830: POP
50831: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50832: LD_VAR 0 3
50836: NOT
50837: PUSH
50838: LD_VAR 0 2
50842: NOT
50843: OR
50844: PUSH
50845: LD_EXP 50
50849: PUSH
50850: LD_VAR 0 1
50854: ARRAY
50855: NOT
50856: OR
50857: IFFALSE 49915
// MC_Reset ( base , 18 ) ;
50859: LD_VAR 0 1
50863: PPUSH
50864: LD_INT 18
50866: PPUSH
50867: CALL 21301 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50871: LD_ADDR_VAR 0 2
50875: PUSH
50876: LD_VAR 0 2
50880: PUSH
50881: LD_VAR 0 2
50885: PPUSH
50886: LD_INT 2
50888: PUSH
50889: LD_INT 25
50891: PUSH
50892: LD_INT 1
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: LD_INT 25
50901: PUSH
50902: LD_INT 5
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: PUSH
50909: LD_INT 25
50911: PUSH
50912: LD_INT 8
50914: PUSH
50915: EMPTY
50916: LIST
50917: LIST
50918: PUSH
50919: LD_INT 25
50921: PUSH
50922: LD_INT 9
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: PUSH
50929: EMPTY
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: PPUSH
50936: CALL_OW 72
50940: DIFF
50941: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50942: LD_VAR 0 3
50946: NOT
50947: PUSH
50948: LD_VAR 0 2
50952: PPUSH
50953: LD_INT 21
50955: PUSH
50956: LD_INT 2
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PPUSH
50963: CALL_OW 72
50967: AND
50968: IFFALSE 51306
// begin tmp := FilterByTag ( defenders , 19 ) ;
50970: LD_ADDR_VAR 0 12
50974: PUSH
50975: LD_VAR 0 2
50979: PPUSH
50980: LD_INT 19
50982: PPUSH
50983: CALL 87762 0 2
50987: ST_TO_ADDR
// if tmp then
50988: LD_VAR 0 12
50992: IFFALSE 51062
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
50994: LD_ADDR_VAR 0 12
50998: PUSH
50999: LD_VAR 0 12
51003: PPUSH
51004: LD_INT 25
51006: PUSH
51007: LD_INT 3
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: PPUSH
51014: CALL_OW 72
51018: ST_TO_ADDR
// if tmp then
51019: LD_VAR 0 12
51023: IFFALSE 51062
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
51025: LD_ADDR_EXP 62
51029: PUSH
51030: LD_EXP 62
51034: PPUSH
51035: LD_VAR 0 1
51039: PPUSH
51040: LD_EXP 62
51044: PUSH
51045: LD_VAR 0 1
51049: ARRAY
51050: PUSH
51051: LD_VAR 0 12
51055: UNION
51056: PPUSH
51057: CALL_OW 1
51061: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
51062: LD_VAR 0 1
51066: PPUSH
51067: LD_INT 19
51069: PPUSH
51070: CALL 21301 0 2
// repeat wait ( 0 0$1 ) ;
51074: LD_INT 35
51076: PPUSH
51077: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51081: LD_EXP 50
51085: PUSH
51086: LD_VAR 0 1
51090: ARRAY
51091: NOT
51092: PUSH
51093: LD_EXP 50
51097: PUSH
51098: LD_VAR 0 1
51102: ARRAY
51103: PUSH
51104: EMPTY
51105: EQUAL
51106: OR
51107: IFFALSE 51144
// begin for i in defenders do
51109: LD_ADDR_VAR 0 5
51113: PUSH
51114: LD_VAR 0 2
51118: PUSH
51119: FOR_IN
51120: IFFALSE 51133
// ComStop ( i ) ;
51122: LD_VAR 0 5
51126: PPUSH
51127: CALL_OW 141
51131: GO 51119
51133: POP
51134: POP
// defenders := [ ] ;
51135: LD_ADDR_VAR 0 2
51139: PUSH
51140: EMPTY
51141: ST_TO_ADDR
// exit ;
51142: GO 51330
// end ; for i in defenders do
51144: LD_ADDR_VAR 0 5
51148: PUSH
51149: LD_VAR 0 2
51153: PUSH
51154: FOR_IN
51155: IFFALSE 51244
// begin if not IsInArea ( i , mc_parking [ base ] ) then
51157: LD_VAR 0 5
51161: PPUSH
51162: LD_EXP 74
51166: PUSH
51167: LD_VAR 0 1
51171: ARRAY
51172: PPUSH
51173: CALL_OW 308
51177: NOT
51178: IFFALSE 51202
// ComMoveToArea ( i , mc_parking [ base ] ) else
51180: LD_VAR 0 5
51184: PPUSH
51185: LD_EXP 74
51189: PUSH
51190: LD_VAR 0 1
51194: ARRAY
51195: PPUSH
51196: CALL_OW 113
51200: GO 51242
// if GetControl ( i ) = control_manual then
51202: LD_VAR 0 5
51206: PPUSH
51207: CALL_OW 263
51211: PUSH
51212: LD_INT 1
51214: EQUAL
51215: IFFALSE 51242
// if IsDrivenBy ( i ) then
51217: LD_VAR 0 5
51221: PPUSH
51222: CALL_OW 311
51226: IFFALSE 51242
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
51228: LD_VAR 0 5
51232: PPUSH
51233: CALL_OW 311
51237: PPUSH
51238: CALL_OW 121
// end ;
51242: GO 51154
51244: POP
51245: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_INT 95
51253: PUSH
51254: LD_EXP 74
51258: PUSH
51259: LD_VAR 0 1
51263: ARRAY
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: PPUSH
51269: CALL_OW 72
51273: PUSH
51274: LD_VAR 0 2
51278: EQUAL
51279: PUSH
51280: LD_EXP 73
51284: PUSH
51285: LD_VAR 0 1
51289: ARRAY
51290: OR
51291: PUSH
51292: LD_EXP 50
51296: PUSH
51297: LD_VAR 0 1
51301: ARRAY
51302: NOT
51303: OR
51304: IFFALSE 51074
// end ; MC_Reset ( base , 19 ) ;
51306: LD_VAR 0 1
51310: PPUSH
51311: LD_INT 19
51313: PPUSH
51314: CALL 21301 0 2
// MC_Reset ( base , 20 ) ;
51318: LD_VAR 0 1
51322: PPUSH
51323: LD_INT 20
51325: PPUSH
51326: CALL 21301 0 2
// end ;
51330: LD_VAR 0 4
51334: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// result := false ;
51341: LD_ADDR_VAR 0 2
51345: PUSH
51346: LD_INT 0
51348: ST_TO_ADDR
// side := GetSide ( unit ) ;
51349: LD_ADDR_VAR 0 3
51353: PUSH
51354: LD_VAR 0 1
51358: PPUSH
51359: CALL_OW 255
51363: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51364: LD_ADDR_VAR 0 4
51368: PUSH
51369: LD_VAR 0 1
51373: PPUSH
51374: CALL_OW 248
51378: ST_TO_ADDR
// case nat of 1 :
51379: LD_VAR 0 4
51383: PUSH
51384: LD_INT 1
51386: DOUBLE
51387: EQUAL
51388: IFTRUE 51392
51390: GO 51403
51392: POP
// tech := tech_lassight ; 2 :
51393: LD_ADDR_VAR 0 5
51397: PUSH
51398: LD_INT 12
51400: ST_TO_ADDR
51401: GO 51442
51403: LD_INT 2
51405: DOUBLE
51406: EQUAL
51407: IFTRUE 51411
51409: GO 51422
51411: POP
// tech := tech_mortar ; 3 :
51412: LD_ADDR_VAR 0 5
51416: PUSH
51417: LD_INT 41
51419: ST_TO_ADDR
51420: GO 51442
51422: LD_INT 3
51424: DOUBLE
51425: EQUAL
51426: IFTRUE 51430
51428: GO 51441
51430: POP
// tech := tech_bazooka ; end ;
51431: LD_ADDR_VAR 0 5
51435: PUSH
51436: LD_INT 44
51438: ST_TO_ADDR
51439: GO 51442
51441: POP
// if Researched ( side , tech ) then
51442: LD_VAR 0 3
51446: PPUSH
51447: LD_VAR 0 5
51451: PPUSH
51452: CALL_OW 325
51456: IFFALSE 51483
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51458: LD_ADDR_VAR 0 2
51462: PUSH
51463: LD_INT 5
51465: PUSH
51466: LD_INT 8
51468: PUSH
51469: LD_INT 9
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: LIST
51476: PUSH
51477: LD_VAR 0 4
51481: ARRAY
51482: ST_TO_ADDR
// end ;
51483: LD_VAR 0 2
51487: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51488: LD_INT 0
51490: PPUSH
51491: PPUSH
51492: PPUSH
// if not mines then
51493: LD_VAR 0 2
51497: NOT
51498: IFFALSE 51502
// exit ;
51500: GO 51646
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51502: LD_ADDR_VAR 0 5
51506: PUSH
51507: LD_INT 81
51509: PUSH
51510: LD_VAR 0 1
51514: PUSH
51515: EMPTY
51516: LIST
51517: LIST
51518: PUSH
51519: LD_INT 3
51521: PUSH
51522: LD_INT 21
51524: PUSH
51525: LD_INT 3
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: EMPTY
51533: LIST
51534: LIST
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PPUSH
51540: CALL_OW 69
51544: ST_TO_ADDR
// for i in mines do
51545: LD_ADDR_VAR 0 4
51549: PUSH
51550: LD_VAR 0 2
51554: PUSH
51555: FOR_IN
51556: IFFALSE 51644
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51558: LD_VAR 0 4
51562: PUSH
51563: LD_INT 1
51565: ARRAY
51566: PPUSH
51567: LD_VAR 0 4
51571: PUSH
51572: LD_INT 2
51574: ARRAY
51575: PPUSH
51576: CALL_OW 458
51580: NOT
51581: IFFALSE 51585
// continue ;
51583: GO 51555
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51585: LD_VAR 0 4
51589: PUSH
51590: LD_INT 1
51592: ARRAY
51593: PPUSH
51594: LD_VAR 0 4
51598: PUSH
51599: LD_INT 2
51601: ARRAY
51602: PPUSH
51603: CALL_OW 428
51607: PUSH
51608: LD_VAR 0 5
51612: IN
51613: IFFALSE 51642
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51615: LD_VAR 0 4
51619: PUSH
51620: LD_INT 1
51622: ARRAY
51623: PPUSH
51624: LD_VAR 0 4
51628: PUSH
51629: LD_INT 2
51631: ARRAY
51632: PPUSH
51633: LD_VAR 0 1
51637: PPUSH
51638: CALL_OW 456
// end ;
51642: GO 51555
51644: POP
51645: POP
// end ;
51646: LD_VAR 0 3
51650: RET
// export function Count ( array ) ; var i ; begin
51651: LD_INT 0
51653: PPUSH
51654: PPUSH
// result := 0 ;
51655: LD_ADDR_VAR 0 2
51659: PUSH
51660: LD_INT 0
51662: ST_TO_ADDR
// for i in array do
51663: LD_ADDR_VAR 0 3
51667: PUSH
51668: LD_VAR 0 1
51672: PUSH
51673: FOR_IN
51674: IFFALSE 51698
// if i then
51676: LD_VAR 0 3
51680: IFFALSE 51696
// result := result + 1 ;
51682: LD_ADDR_VAR 0 2
51686: PUSH
51687: LD_VAR 0 2
51691: PUSH
51692: LD_INT 1
51694: PLUS
51695: ST_TO_ADDR
51696: GO 51673
51698: POP
51699: POP
// end ;
51700: LD_VAR 0 2
51704: RET
// export function IsEmpty ( building ) ; begin
51705: LD_INT 0
51707: PPUSH
// if not building then
51708: LD_VAR 0 1
51712: NOT
51713: IFFALSE 51717
// exit ;
51715: GO 51760
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51717: LD_ADDR_VAR 0 2
51721: PUSH
51722: LD_VAR 0 1
51726: PUSH
51727: LD_INT 22
51729: PUSH
51730: LD_VAR 0 1
51734: PPUSH
51735: CALL_OW 255
51739: PUSH
51740: EMPTY
51741: LIST
51742: LIST
51743: PUSH
51744: LD_INT 58
51746: PUSH
51747: EMPTY
51748: LIST
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: PPUSH
51754: CALL_OW 69
51758: IN
51759: ST_TO_ADDR
// end ;
51760: LD_VAR 0 2
51764: RET
// export function IsNotFull ( building ) ; begin
51765: LD_INT 0
51767: PPUSH
// if not building then
51768: LD_VAR 0 1
51772: NOT
51773: IFFALSE 51777
// exit ;
51775: GO 51796
// result := UnitsInside ( building ) < 6 ;
51777: LD_ADDR_VAR 0 2
51781: PUSH
51782: LD_VAR 0 1
51786: PPUSH
51787: CALL_OW 313
51791: PUSH
51792: LD_INT 6
51794: LESS
51795: ST_TO_ADDR
// end ;
51796: LD_VAR 0 2
51800: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51801: LD_INT 0
51803: PPUSH
51804: PPUSH
51805: PPUSH
51806: PPUSH
// tmp := [ ] ;
51807: LD_ADDR_VAR 0 3
51811: PUSH
51812: EMPTY
51813: ST_TO_ADDR
// list := [ ] ;
51814: LD_ADDR_VAR 0 5
51818: PUSH
51819: EMPTY
51820: ST_TO_ADDR
// for i = 16 to 25 do
51821: LD_ADDR_VAR 0 4
51825: PUSH
51826: DOUBLE
51827: LD_INT 16
51829: DEC
51830: ST_TO_ADDR
51831: LD_INT 25
51833: PUSH
51834: FOR_TO
51835: IFFALSE 51908
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51837: LD_ADDR_VAR 0 3
51841: PUSH
51842: LD_VAR 0 3
51846: PUSH
51847: LD_INT 22
51849: PUSH
51850: LD_VAR 0 1
51854: PPUSH
51855: CALL_OW 255
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: LD_INT 91
51866: PUSH
51867: LD_VAR 0 1
51871: PUSH
51872: LD_INT 6
51874: PUSH
51875: EMPTY
51876: LIST
51877: LIST
51878: LIST
51879: PUSH
51880: LD_INT 30
51882: PUSH
51883: LD_VAR 0 4
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: LIST
51896: PUSH
51897: EMPTY
51898: LIST
51899: PPUSH
51900: CALL_OW 69
51904: ADD
51905: ST_TO_ADDR
51906: GO 51834
51908: POP
51909: POP
// for i = 1 to tmp do
51910: LD_ADDR_VAR 0 4
51914: PUSH
51915: DOUBLE
51916: LD_INT 1
51918: DEC
51919: ST_TO_ADDR
51920: LD_VAR 0 3
51924: PUSH
51925: FOR_TO
51926: IFFALSE 52014
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51928: LD_ADDR_VAR 0 5
51932: PUSH
51933: LD_VAR 0 5
51937: PUSH
51938: LD_VAR 0 3
51942: PUSH
51943: LD_VAR 0 4
51947: ARRAY
51948: PPUSH
51949: CALL_OW 266
51953: PUSH
51954: LD_VAR 0 3
51958: PUSH
51959: LD_VAR 0 4
51963: ARRAY
51964: PPUSH
51965: CALL_OW 250
51969: PUSH
51970: LD_VAR 0 3
51974: PUSH
51975: LD_VAR 0 4
51979: ARRAY
51980: PPUSH
51981: CALL_OW 251
51985: PUSH
51986: LD_VAR 0 3
51990: PUSH
51991: LD_VAR 0 4
51995: ARRAY
51996: PPUSH
51997: CALL_OW 254
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: PUSH
52008: EMPTY
52009: LIST
52010: ADD
52011: ST_TO_ADDR
52012: GO 51925
52014: POP
52015: POP
// result := list ;
52016: LD_ADDR_VAR 0 2
52020: PUSH
52021: LD_VAR 0 5
52025: ST_TO_ADDR
// end ;
52026: LD_VAR 0 2
52030: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
52031: LD_INT 0
52033: PPUSH
52034: PPUSH
52035: PPUSH
52036: PPUSH
52037: PPUSH
52038: PPUSH
52039: PPUSH
// if not factory then
52040: LD_VAR 0 1
52044: NOT
52045: IFFALSE 52049
// exit ;
52047: GO 52642
// if control = control_apeman then
52049: LD_VAR 0 4
52053: PUSH
52054: LD_INT 5
52056: EQUAL
52057: IFFALSE 52166
// begin tmp := UnitsInside ( factory ) ;
52059: LD_ADDR_VAR 0 8
52063: PUSH
52064: LD_VAR 0 1
52068: PPUSH
52069: CALL_OW 313
52073: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
52074: LD_VAR 0 8
52078: PPUSH
52079: LD_INT 25
52081: PUSH
52082: LD_INT 12
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: PPUSH
52089: CALL_OW 72
52093: NOT
52094: IFFALSE 52104
// control := control_manual ;
52096: LD_ADDR_VAR 0 4
52100: PUSH
52101: LD_INT 1
52103: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
52104: LD_ADDR_VAR 0 8
52108: PUSH
52109: LD_VAR 0 1
52113: PPUSH
52114: CALL 51801 0 1
52118: ST_TO_ADDR
// if tmp then
52119: LD_VAR 0 8
52123: IFFALSE 52166
// begin for i in tmp do
52125: LD_ADDR_VAR 0 7
52129: PUSH
52130: LD_VAR 0 8
52134: PUSH
52135: FOR_IN
52136: IFFALSE 52164
// if i [ 1 ] = b_ext_radio then
52138: LD_VAR 0 7
52142: PUSH
52143: LD_INT 1
52145: ARRAY
52146: PUSH
52147: LD_INT 22
52149: EQUAL
52150: IFFALSE 52162
// begin control := control_remote ;
52152: LD_ADDR_VAR 0 4
52156: PUSH
52157: LD_INT 2
52159: ST_TO_ADDR
// break ;
52160: GO 52164
// end ;
52162: GO 52135
52164: POP
52165: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52166: LD_VAR 0 1
52170: PPUSH
52171: LD_VAR 0 2
52175: PPUSH
52176: LD_VAR 0 3
52180: PPUSH
52181: LD_VAR 0 4
52185: PPUSH
52186: LD_VAR 0 5
52190: PPUSH
52191: CALL_OW 448
52195: IFFALSE 52230
// begin result := [ chassis , engine , control , weapon ] ;
52197: LD_ADDR_VAR 0 6
52201: PUSH
52202: LD_VAR 0 2
52206: PUSH
52207: LD_VAR 0 3
52211: PUSH
52212: LD_VAR 0 4
52216: PUSH
52217: LD_VAR 0 5
52221: PUSH
52222: EMPTY
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: ST_TO_ADDR
// exit ;
52228: GO 52642
// end ; _chassis := AvailableChassisList ( factory ) ;
52230: LD_ADDR_VAR 0 9
52234: PUSH
52235: LD_VAR 0 1
52239: PPUSH
52240: CALL_OW 475
52244: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52245: LD_ADDR_VAR 0 11
52249: PUSH
52250: LD_VAR 0 1
52254: PPUSH
52255: CALL_OW 476
52259: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52260: LD_ADDR_VAR 0 12
52264: PUSH
52265: LD_VAR 0 1
52269: PPUSH
52270: CALL_OW 477
52274: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52275: LD_ADDR_VAR 0 10
52279: PUSH
52280: LD_VAR 0 1
52284: PPUSH
52285: CALL_OW 478
52289: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52290: LD_VAR 0 9
52294: NOT
52295: PUSH
52296: LD_VAR 0 11
52300: NOT
52301: OR
52302: PUSH
52303: LD_VAR 0 12
52307: NOT
52308: OR
52309: PUSH
52310: LD_VAR 0 10
52314: NOT
52315: OR
52316: IFFALSE 52351
// begin result := [ chassis , engine , control , weapon ] ;
52318: LD_ADDR_VAR 0 6
52322: PUSH
52323: LD_VAR 0 2
52327: PUSH
52328: LD_VAR 0 3
52332: PUSH
52333: LD_VAR 0 4
52337: PUSH
52338: LD_VAR 0 5
52342: PUSH
52343: EMPTY
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: ST_TO_ADDR
// exit ;
52349: GO 52642
// end ; if not chassis in _chassis then
52351: LD_VAR 0 2
52355: PUSH
52356: LD_VAR 0 9
52360: IN
52361: NOT
52362: IFFALSE 52388
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52364: LD_ADDR_VAR 0 2
52368: PUSH
52369: LD_VAR 0 9
52373: PUSH
52374: LD_INT 1
52376: PPUSH
52377: LD_VAR 0 9
52381: PPUSH
52382: CALL_OW 12
52386: ARRAY
52387: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52388: LD_VAR 0 2
52392: PPUSH
52393: LD_VAR 0 3
52397: PPUSH
52398: CALL 52647 0 2
52402: NOT
52403: IFFALSE 52462
// repeat engine := _engine [ 1 ] ;
52405: LD_ADDR_VAR 0 3
52409: PUSH
52410: LD_VAR 0 11
52414: PUSH
52415: LD_INT 1
52417: ARRAY
52418: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52419: LD_ADDR_VAR 0 11
52423: PUSH
52424: LD_VAR 0 11
52428: PPUSH
52429: LD_INT 1
52431: PPUSH
52432: CALL_OW 3
52436: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52437: LD_VAR 0 2
52441: PPUSH
52442: LD_VAR 0 3
52446: PPUSH
52447: CALL 52647 0 2
52451: PUSH
52452: LD_VAR 0 11
52456: PUSH
52457: EMPTY
52458: EQUAL
52459: OR
52460: IFFALSE 52405
// if not control in _control then
52462: LD_VAR 0 4
52466: PUSH
52467: LD_VAR 0 12
52471: IN
52472: NOT
52473: IFFALSE 52499
// control := _control [ rand ( 1 , _control ) ] ;
52475: LD_ADDR_VAR 0 4
52479: PUSH
52480: LD_VAR 0 12
52484: PUSH
52485: LD_INT 1
52487: PPUSH
52488: LD_VAR 0 12
52492: PPUSH
52493: CALL_OW 12
52497: ARRAY
52498: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52499: LD_VAR 0 2
52503: PPUSH
52504: LD_VAR 0 5
52508: PPUSH
52509: CALL 52867 0 2
52513: NOT
52514: IFFALSE 52573
// repeat weapon := _weapon [ 1 ] ;
52516: LD_ADDR_VAR 0 5
52520: PUSH
52521: LD_VAR 0 10
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52530: LD_ADDR_VAR 0 10
52534: PUSH
52535: LD_VAR 0 10
52539: PPUSH
52540: LD_INT 1
52542: PPUSH
52543: CALL_OW 3
52547: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52548: LD_VAR 0 2
52552: PPUSH
52553: LD_VAR 0 5
52557: PPUSH
52558: CALL 52867 0 2
52562: PUSH
52563: LD_VAR 0 10
52567: PUSH
52568: EMPTY
52569: EQUAL
52570: OR
52571: IFFALSE 52516
// result := [ ] ;
52573: LD_ADDR_VAR 0 6
52577: PUSH
52578: EMPTY
52579: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52580: LD_VAR 0 1
52584: PPUSH
52585: LD_VAR 0 2
52589: PPUSH
52590: LD_VAR 0 3
52594: PPUSH
52595: LD_VAR 0 4
52599: PPUSH
52600: LD_VAR 0 5
52604: PPUSH
52605: CALL_OW 448
52609: IFFALSE 52642
// result := [ chassis , engine , control , weapon ] ;
52611: LD_ADDR_VAR 0 6
52615: PUSH
52616: LD_VAR 0 2
52620: PUSH
52621: LD_VAR 0 3
52625: PUSH
52626: LD_VAR 0 4
52630: PUSH
52631: LD_VAR 0 5
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: ST_TO_ADDR
// end ;
52642: LD_VAR 0 6
52646: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52647: LD_INT 0
52649: PPUSH
// if not chassis or not engine then
52650: LD_VAR 0 1
52654: NOT
52655: PUSH
52656: LD_VAR 0 2
52660: NOT
52661: OR
52662: IFFALSE 52666
// exit ;
52664: GO 52862
// case engine of engine_solar :
52666: LD_VAR 0 2
52670: PUSH
52671: LD_INT 2
52673: DOUBLE
52674: EQUAL
52675: IFTRUE 52679
52677: GO 52717
52679: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52680: LD_ADDR_VAR 0 3
52684: PUSH
52685: LD_INT 11
52687: PUSH
52688: LD_INT 12
52690: PUSH
52691: LD_INT 13
52693: PUSH
52694: LD_INT 14
52696: PUSH
52697: LD_INT 1
52699: PUSH
52700: LD_INT 2
52702: PUSH
52703: LD_INT 3
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: LIST
52710: LIST
52711: LIST
52712: LIST
52713: LIST
52714: ST_TO_ADDR
52715: GO 52846
52717: LD_INT 1
52719: DOUBLE
52720: EQUAL
52721: IFTRUE 52725
52723: GO 52787
52725: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52726: LD_ADDR_VAR 0 3
52730: PUSH
52731: LD_INT 11
52733: PUSH
52734: LD_INT 12
52736: PUSH
52737: LD_INT 13
52739: PUSH
52740: LD_INT 14
52742: PUSH
52743: LD_INT 1
52745: PUSH
52746: LD_INT 2
52748: PUSH
52749: LD_INT 3
52751: PUSH
52752: LD_INT 4
52754: PUSH
52755: LD_INT 5
52757: PUSH
52758: LD_INT 21
52760: PUSH
52761: LD_INT 23
52763: PUSH
52764: LD_INT 22
52766: PUSH
52767: LD_INT 24
52769: PUSH
52770: EMPTY
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: ST_TO_ADDR
52785: GO 52846
52787: LD_INT 3
52789: DOUBLE
52790: EQUAL
52791: IFTRUE 52795
52793: GO 52845
52795: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52796: LD_ADDR_VAR 0 3
52800: PUSH
52801: LD_INT 13
52803: PUSH
52804: LD_INT 14
52806: PUSH
52807: LD_INT 2
52809: PUSH
52810: LD_INT 3
52812: PUSH
52813: LD_INT 4
52815: PUSH
52816: LD_INT 5
52818: PUSH
52819: LD_INT 21
52821: PUSH
52822: LD_INT 22
52824: PUSH
52825: LD_INT 23
52827: PUSH
52828: LD_INT 24
52830: PUSH
52831: EMPTY
52832: LIST
52833: LIST
52834: LIST
52835: LIST
52836: LIST
52837: LIST
52838: LIST
52839: LIST
52840: LIST
52841: LIST
52842: ST_TO_ADDR
52843: GO 52846
52845: POP
// result := ( chassis in result ) ;
52846: LD_ADDR_VAR 0 3
52850: PUSH
52851: LD_VAR 0 1
52855: PUSH
52856: LD_VAR 0 3
52860: IN
52861: ST_TO_ADDR
// end ;
52862: LD_VAR 0 3
52866: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52867: LD_INT 0
52869: PPUSH
// if not chassis or not weapon then
52870: LD_VAR 0 1
52874: NOT
52875: PUSH
52876: LD_VAR 0 2
52880: NOT
52881: OR
52882: IFFALSE 52886
// exit ;
52884: GO 53912
// case weapon of us_machine_gun :
52886: LD_VAR 0 2
52890: PUSH
52891: LD_INT 2
52893: DOUBLE
52894: EQUAL
52895: IFTRUE 52899
52897: GO 52929
52899: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52900: LD_ADDR_VAR 0 3
52904: PUSH
52905: LD_INT 1
52907: PUSH
52908: LD_INT 2
52910: PUSH
52911: LD_INT 3
52913: PUSH
52914: LD_INT 4
52916: PUSH
52917: LD_INT 5
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: LIST
52924: LIST
52925: LIST
52926: ST_TO_ADDR
52927: GO 53896
52929: LD_INT 3
52931: DOUBLE
52932: EQUAL
52933: IFTRUE 52937
52935: GO 52967
52937: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_INT 1
52945: PUSH
52946: LD_INT 2
52948: PUSH
52949: LD_INT 3
52951: PUSH
52952: LD_INT 4
52954: PUSH
52955: LD_INT 5
52957: PUSH
52958: EMPTY
52959: LIST
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: ST_TO_ADDR
52965: GO 53896
52967: LD_INT 11
52969: DOUBLE
52970: EQUAL
52971: IFTRUE 52975
52973: GO 53005
52975: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52976: LD_ADDR_VAR 0 3
52980: PUSH
52981: LD_INT 1
52983: PUSH
52984: LD_INT 2
52986: PUSH
52987: LD_INT 3
52989: PUSH
52990: LD_INT 4
52992: PUSH
52993: LD_INT 5
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: LIST
53000: LIST
53001: LIST
53002: ST_TO_ADDR
53003: GO 53896
53005: LD_INT 4
53007: DOUBLE
53008: EQUAL
53009: IFTRUE 53013
53011: GO 53039
53013: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
53014: LD_ADDR_VAR 0 3
53018: PUSH
53019: LD_INT 2
53021: PUSH
53022: LD_INT 3
53024: PUSH
53025: LD_INT 4
53027: PUSH
53028: LD_INT 5
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: LIST
53035: LIST
53036: ST_TO_ADDR
53037: GO 53896
53039: LD_INT 5
53041: DOUBLE
53042: EQUAL
53043: IFTRUE 53047
53045: GO 53073
53047: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
53048: LD_ADDR_VAR 0 3
53052: PUSH
53053: LD_INT 2
53055: PUSH
53056: LD_INT 3
53058: PUSH
53059: LD_INT 4
53061: PUSH
53062: LD_INT 5
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: LIST
53070: ST_TO_ADDR
53071: GO 53896
53073: LD_INT 9
53075: DOUBLE
53076: EQUAL
53077: IFTRUE 53081
53079: GO 53107
53081: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
53082: LD_ADDR_VAR 0 3
53086: PUSH
53087: LD_INT 2
53089: PUSH
53090: LD_INT 3
53092: PUSH
53093: LD_INT 4
53095: PUSH
53096: LD_INT 5
53098: PUSH
53099: EMPTY
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: ST_TO_ADDR
53105: GO 53896
53107: LD_INT 7
53109: DOUBLE
53110: EQUAL
53111: IFTRUE 53115
53113: GO 53141
53115: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53116: LD_ADDR_VAR 0 3
53120: PUSH
53121: LD_INT 2
53123: PUSH
53124: LD_INT 3
53126: PUSH
53127: LD_INT 4
53129: PUSH
53130: LD_INT 5
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: LIST
53137: LIST
53138: ST_TO_ADDR
53139: GO 53896
53141: LD_INT 12
53143: DOUBLE
53144: EQUAL
53145: IFTRUE 53149
53147: GO 53175
53149: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53150: LD_ADDR_VAR 0 3
53154: PUSH
53155: LD_INT 2
53157: PUSH
53158: LD_INT 3
53160: PUSH
53161: LD_INT 4
53163: PUSH
53164: LD_INT 5
53166: PUSH
53167: EMPTY
53168: LIST
53169: LIST
53170: LIST
53171: LIST
53172: ST_TO_ADDR
53173: GO 53896
53175: LD_INT 13
53177: DOUBLE
53178: EQUAL
53179: IFTRUE 53183
53181: GO 53209
53183: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53184: LD_ADDR_VAR 0 3
53188: PUSH
53189: LD_INT 2
53191: PUSH
53192: LD_INT 3
53194: PUSH
53195: LD_INT 4
53197: PUSH
53198: LD_INT 5
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: LIST
53205: LIST
53206: ST_TO_ADDR
53207: GO 53896
53209: LD_INT 14
53211: DOUBLE
53212: EQUAL
53213: IFTRUE 53217
53215: GO 53235
53217: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53218: LD_ADDR_VAR 0 3
53222: PUSH
53223: LD_INT 4
53225: PUSH
53226: LD_INT 5
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: ST_TO_ADDR
53233: GO 53896
53235: LD_INT 6
53237: DOUBLE
53238: EQUAL
53239: IFTRUE 53243
53241: GO 53261
53243: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53244: LD_ADDR_VAR 0 3
53248: PUSH
53249: LD_INT 4
53251: PUSH
53252: LD_INT 5
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: ST_TO_ADDR
53259: GO 53896
53261: LD_INT 10
53263: DOUBLE
53264: EQUAL
53265: IFTRUE 53269
53267: GO 53287
53269: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53270: LD_ADDR_VAR 0 3
53274: PUSH
53275: LD_INT 4
53277: PUSH
53278: LD_INT 5
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: ST_TO_ADDR
53285: GO 53896
53287: LD_INT 22
53289: DOUBLE
53290: EQUAL
53291: IFTRUE 53295
53293: GO 53321
53295: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53296: LD_ADDR_VAR 0 3
53300: PUSH
53301: LD_INT 11
53303: PUSH
53304: LD_INT 12
53306: PUSH
53307: LD_INT 13
53309: PUSH
53310: LD_INT 14
53312: PUSH
53313: EMPTY
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: ST_TO_ADDR
53319: GO 53896
53321: LD_INT 23
53323: DOUBLE
53324: EQUAL
53325: IFTRUE 53329
53327: GO 53355
53329: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53330: LD_ADDR_VAR 0 3
53334: PUSH
53335: LD_INT 11
53337: PUSH
53338: LD_INT 12
53340: PUSH
53341: LD_INT 13
53343: PUSH
53344: LD_INT 14
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: LIST
53351: LIST
53352: ST_TO_ADDR
53353: GO 53896
53355: LD_INT 24
53357: DOUBLE
53358: EQUAL
53359: IFTRUE 53363
53361: GO 53389
53363: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53364: LD_ADDR_VAR 0 3
53368: PUSH
53369: LD_INT 11
53371: PUSH
53372: LD_INT 12
53374: PUSH
53375: LD_INT 13
53377: PUSH
53378: LD_INT 14
53380: PUSH
53381: EMPTY
53382: LIST
53383: LIST
53384: LIST
53385: LIST
53386: ST_TO_ADDR
53387: GO 53896
53389: LD_INT 30
53391: DOUBLE
53392: EQUAL
53393: IFTRUE 53397
53395: GO 53423
53397: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53398: LD_ADDR_VAR 0 3
53402: PUSH
53403: LD_INT 11
53405: PUSH
53406: LD_INT 12
53408: PUSH
53409: LD_INT 13
53411: PUSH
53412: LD_INT 14
53414: PUSH
53415: EMPTY
53416: LIST
53417: LIST
53418: LIST
53419: LIST
53420: ST_TO_ADDR
53421: GO 53896
53423: LD_INT 25
53425: DOUBLE
53426: EQUAL
53427: IFTRUE 53431
53429: GO 53449
53431: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53432: LD_ADDR_VAR 0 3
53436: PUSH
53437: LD_INT 13
53439: PUSH
53440: LD_INT 14
53442: PUSH
53443: EMPTY
53444: LIST
53445: LIST
53446: ST_TO_ADDR
53447: GO 53896
53449: LD_INT 27
53451: DOUBLE
53452: EQUAL
53453: IFTRUE 53457
53455: GO 53475
53457: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53458: LD_ADDR_VAR 0 3
53462: PUSH
53463: LD_INT 13
53465: PUSH
53466: LD_INT 14
53468: PUSH
53469: EMPTY
53470: LIST
53471: LIST
53472: ST_TO_ADDR
53473: GO 53896
53475: LD_INT 28
53477: DOUBLE
53478: EQUAL
53479: IFTRUE 53483
53481: GO 53501
53483: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53484: LD_ADDR_VAR 0 3
53488: PUSH
53489: LD_INT 13
53491: PUSH
53492: LD_INT 14
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: ST_TO_ADDR
53499: GO 53896
53501: LD_INT 29
53503: DOUBLE
53504: EQUAL
53505: IFTRUE 53509
53507: GO 53527
53509: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53510: LD_ADDR_VAR 0 3
53514: PUSH
53515: LD_INT 13
53517: PUSH
53518: LD_INT 14
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: ST_TO_ADDR
53525: GO 53896
53527: LD_INT 31
53529: DOUBLE
53530: EQUAL
53531: IFTRUE 53535
53533: GO 53553
53535: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53536: LD_ADDR_VAR 0 3
53540: PUSH
53541: LD_INT 13
53543: PUSH
53544: LD_INT 14
53546: PUSH
53547: EMPTY
53548: LIST
53549: LIST
53550: ST_TO_ADDR
53551: GO 53896
53553: LD_INT 26
53555: DOUBLE
53556: EQUAL
53557: IFTRUE 53561
53559: GO 53579
53561: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53562: LD_ADDR_VAR 0 3
53566: PUSH
53567: LD_INT 13
53569: PUSH
53570: LD_INT 14
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: ST_TO_ADDR
53577: GO 53896
53579: LD_INT 42
53581: DOUBLE
53582: EQUAL
53583: IFTRUE 53587
53585: GO 53613
53587: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53588: LD_ADDR_VAR 0 3
53592: PUSH
53593: LD_INT 21
53595: PUSH
53596: LD_INT 22
53598: PUSH
53599: LD_INT 23
53601: PUSH
53602: LD_INT 24
53604: PUSH
53605: EMPTY
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: ST_TO_ADDR
53611: GO 53896
53613: LD_INT 43
53615: DOUBLE
53616: EQUAL
53617: IFTRUE 53621
53619: GO 53647
53621: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53622: LD_ADDR_VAR 0 3
53626: PUSH
53627: LD_INT 21
53629: PUSH
53630: LD_INT 22
53632: PUSH
53633: LD_INT 23
53635: PUSH
53636: LD_INT 24
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: LIST
53643: LIST
53644: ST_TO_ADDR
53645: GO 53896
53647: LD_INT 44
53649: DOUBLE
53650: EQUAL
53651: IFTRUE 53655
53653: GO 53681
53655: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53656: LD_ADDR_VAR 0 3
53660: PUSH
53661: LD_INT 21
53663: PUSH
53664: LD_INT 22
53666: PUSH
53667: LD_INT 23
53669: PUSH
53670: LD_INT 24
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: LIST
53677: LIST
53678: ST_TO_ADDR
53679: GO 53896
53681: LD_INT 45
53683: DOUBLE
53684: EQUAL
53685: IFTRUE 53689
53687: GO 53715
53689: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53690: LD_ADDR_VAR 0 3
53694: PUSH
53695: LD_INT 21
53697: PUSH
53698: LD_INT 22
53700: PUSH
53701: LD_INT 23
53703: PUSH
53704: LD_INT 24
53706: PUSH
53707: EMPTY
53708: LIST
53709: LIST
53710: LIST
53711: LIST
53712: ST_TO_ADDR
53713: GO 53896
53715: LD_INT 49
53717: DOUBLE
53718: EQUAL
53719: IFTRUE 53723
53721: GO 53749
53723: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53724: LD_ADDR_VAR 0 3
53728: PUSH
53729: LD_INT 21
53731: PUSH
53732: LD_INT 22
53734: PUSH
53735: LD_INT 23
53737: PUSH
53738: LD_INT 24
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: LIST
53745: LIST
53746: ST_TO_ADDR
53747: GO 53896
53749: LD_INT 51
53751: DOUBLE
53752: EQUAL
53753: IFTRUE 53757
53755: GO 53783
53757: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53758: LD_ADDR_VAR 0 3
53762: PUSH
53763: LD_INT 21
53765: PUSH
53766: LD_INT 22
53768: PUSH
53769: LD_INT 23
53771: PUSH
53772: LD_INT 24
53774: PUSH
53775: EMPTY
53776: LIST
53777: LIST
53778: LIST
53779: LIST
53780: ST_TO_ADDR
53781: GO 53896
53783: LD_INT 52
53785: DOUBLE
53786: EQUAL
53787: IFTRUE 53791
53789: GO 53817
53791: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53792: LD_ADDR_VAR 0 3
53796: PUSH
53797: LD_INT 21
53799: PUSH
53800: LD_INT 22
53802: PUSH
53803: LD_INT 23
53805: PUSH
53806: LD_INT 24
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: LIST
53813: LIST
53814: ST_TO_ADDR
53815: GO 53896
53817: LD_INT 53
53819: DOUBLE
53820: EQUAL
53821: IFTRUE 53825
53823: GO 53843
53825: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53826: LD_ADDR_VAR 0 3
53830: PUSH
53831: LD_INT 23
53833: PUSH
53834: LD_INT 24
53836: PUSH
53837: EMPTY
53838: LIST
53839: LIST
53840: ST_TO_ADDR
53841: GO 53896
53843: LD_INT 46
53845: DOUBLE
53846: EQUAL
53847: IFTRUE 53851
53849: GO 53869
53851: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53852: LD_ADDR_VAR 0 3
53856: PUSH
53857: LD_INT 23
53859: PUSH
53860: LD_INT 24
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: ST_TO_ADDR
53867: GO 53896
53869: LD_INT 47
53871: DOUBLE
53872: EQUAL
53873: IFTRUE 53877
53875: GO 53895
53877: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53878: LD_ADDR_VAR 0 3
53882: PUSH
53883: LD_INT 23
53885: PUSH
53886: LD_INT 24
53888: PUSH
53889: EMPTY
53890: LIST
53891: LIST
53892: ST_TO_ADDR
53893: GO 53896
53895: POP
// result := ( chassis in result ) ;
53896: LD_ADDR_VAR 0 3
53900: PUSH
53901: LD_VAR 0 1
53905: PUSH
53906: LD_VAR 0 3
53910: IN
53911: ST_TO_ADDR
// end ;
53912: LD_VAR 0 3
53916: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53917: LD_INT 0
53919: PPUSH
53920: PPUSH
53921: PPUSH
53922: PPUSH
53923: PPUSH
53924: PPUSH
53925: PPUSH
// result := array ;
53926: LD_ADDR_VAR 0 5
53930: PUSH
53931: LD_VAR 0 1
53935: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53936: LD_VAR 0 1
53940: NOT
53941: PUSH
53942: LD_VAR 0 2
53946: NOT
53947: OR
53948: PUSH
53949: LD_VAR 0 3
53953: NOT
53954: OR
53955: PUSH
53956: LD_VAR 0 2
53960: PUSH
53961: LD_VAR 0 1
53965: GREATER
53966: OR
53967: PUSH
53968: LD_VAR 0 3
53972: PUSH
53973: LD_VAR 0 1
53977: GREATER
53978: OR
53979: IFFALSE 53983
// exit ;
53981: GO 54279
// if direction then
53983: LD_VAR 0 4
53987: IFFALSE 54051
// begin d := 1 ;
53989: LD_ADDR_VAR 0 9
53993: PUSH
53994: LD_INT 1
53996: ST_TO_ADDR
// if i_from > i_to then
53997: LD_VAR 0 2
54001: PUSH
54002: LD_VAR 0 3
54006: GREATER
54007: IFFALSE 54033
// length := ( array - i_from ) + i_to else
54009: LD_ADDR_VAR 0 11
54013: PUSH
54014: LD_VAR 0 1
54018: PUSH
54019: LD_VAR 0 2
54023: MINUS
54024: PUSH
54025: LD_VAR 0 3
54029: PLUS
54030: ST_TO_ADDR
54031: GO 54049
// length := i_to - i_from ;
54033: LD_ADDR_VAR 0 11
54037: PUSH
54038: LD_VAR 0 3
54042: PUSH
54043: LD_VAR 0 2
54047: MINUS
54048: ST_TO_ADDR
// end else
54049: GO 54112
// begin d := - 1 ;
54051: LD_ADDR_VAR 0 9
54055: PUSH
54056: LD_INT 1
54058: NEG
54059: ST_TO_ADDR
// if i_from > i_to then
54060: LD_VAR 0 2
54064: PUSH
54065: LD_VAR 0 3
54069: GREATER
54070: IFFALSE 54090
// length := i_from - i_to else
54072: LD_ADDR_VAR 0 11
54076: PUSH
54077: LD_VAR 0 2
54081: PUSH
54082: LD_VAR 0 3
54086: MINUS
54087: ST_TO_ADDR
54088: GO 54112
// length := ( array - i_to ) + i_from ;
54090: LD_ADDR_VAR 0 11
54094: PUSH
54095: LD_VAR 0 1
54099: PUSH
54100: LD_VAR 0 3
54104: MINUS
54105: PUSH
54106: LD_VAR 0 2
54110: PLUS
54111: ST_TO_ADDR
// end ; if not length then
54112: LD_VAR 0 11
54116: NOT
54117: IFFALSE 54121
// exit ;
54119: GO 54279
// tmp := array ;
54121: LD_ADDR_VAR 0 10
54125: PUSH
54126: LD_VAR 0 1
54130: ST_TO_ADDR
// for i = 1 to length do
54131: LD_ADDR_VAR 0 6
54135: PUSH
54136: DOUBLE
54137: LD_INT 1
54139: DEC
54140: ST_TO_ADDR
54141: LD_VAR 0 11
54145: PUSH
54146: FOR_TO
54147: IFFALSE 54267
// begin for j = 1 to array do
54149: LD_ADDR_VAR 0 7
54153: PUSH
54154: DOUBLE
54155: LD_INT 1
54157: DEC
54158: ST_TO_ADDR
54159: LD_VAR 0 1
54163: PUSH
54164: FOR_TO
54165: IFFALSE 54253
// begin k := j + d ;
54167: LD_ADDR_VAR 0 8
54171: PUSH
54172: LD_VAR 0 7
54176: PUSH
54177: LD_VAR 0 9
54181: PLUS
54182: ST_TO_ADDR
// if k > array then
54183: LD_VAR 0 8
54187: PUSH
54188: LD_VAR 0 1
54192: GREATER
54193: IFFALSE 54203
// k := 1 ;
54195: LD_ADDR_VAR 0 8
54199: PUSH
54200: LD_INT 1
54202: ST_TO_ADDR
// if not k then
54203: LD_VAR 0 8
54207: NOT
54208: IFFALSE 54220
// k := array ;
54210: LD_ADDR_VAR 0 8
54214: PUSH
54215: LD_VAR 0 1
54219: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54220: LD_ADDR_VAR 0 10
54224: PUSH
54225: LD_VAR 0 10
54229: PPUSH
54230: LD_VAR 0 8
54234: PPUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_VAR 0 7
54244: ARRAY
54245: PPUSH
54246: CALL_OW 1
54250: ST_TO_ADDR
// end ;
54251: GO 54164
54253: POP
54254: POP
// array := tmp ;
54255: LD_ADDR_VAR 0 1
54259: PUSH
54260: LD_VAR 0 10
54264: ST_TO_ADDR
// end ;
54265: GO 54146
54267: POP
54268: POP
// result := array ;
54269: LD_ADDR_VAR 0 5
54273: PUSH
54274: LD_VAR 0 1
54278: ST_TO_ADDR
// end ;
54279: LD_VAR 0 5
54283: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54284: LD_INT 0
54286: PPUSH
54287: PPUSH
// result := 0 ;
54288: LD_ADDR_VAR 0 3
54292: PUSH
54293: LD_INT 0
54295: ST_TO_ADDR
// if not array or not value in array then
54296: LD_VAR 0 1
54300: NOT
54301: PUSH
54302: LD_VAR 0 2
54306: PUSH
54307: LD_VAR 0 1
54311: IN
54312: NOT
54313: OR
54314: IFFALSE 54318
// exit ;
54316: GO 54372
// for i = 1 to array do
54318: LD_ADDR_VAR 0 4
54322: PUSH
54323: DOUBLE
54324: LD_INT 1
54326: DEC
54327: ST_TO_ADDR
54328: LD_VAR 0 1
54332: PUSH
54333: FOR_TO
54334: IFFALSE 54370
// if value = array [ i ] then
54336: LD_VAR 0 2
54340: PUSH
54341: LD_VAR 0 1
54345: PUSH
54346: LD_VAR 0 4
54350: ARRAY
54351: EQUAL
54352: IFFALSE 54368
// begin result := i ;
54354: LD_ADDR_VAR 0 3
54358: PUSH
54359: LD_VAR 0 4
54363: ST_TO_ADDR
// exit ;
54364: POP
54365: POP
54366: GO 54372
// end ;
54368: GO 54333
54370: POP
54371: POP
// end ;
54372: LD_VAR 0 3
54376: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54377: LD_INT 0
54379: PPUSH
// vc_chassis := chassis ;
54380: LD_ADDR_OWVAR 37
54384: PUSH
54385: LD_VAR 0 1
54389: ST_TO_ADDR
// vc_engine := engine ;
54390: LD_ADDR_OWVAR 39
54394: PUSH
54395: LD_VAR 0 2
54399: ST_TO_ADDR
// vc_control := control ;
54400: LD_ADDR_OWVAR 38
54404: PUSH
54405: LD_VAR 0 3
54409: ST_TO_ADDR
// vc_weapon := weapon ;
54410: LD_ADDR_OWVAR 40
54414: PUSH
54415: LD_VAR 0 4
54419: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54420: LD_ADDR_OWVAR 41
54424: PUSH
54425: LD_VAR 0 5
54429: ST_TO_ADDR
// end ;
54430: LD_VAR 0 6
54434: RET
// export function WantPlant ( unit ) ; var task ; begin
54435: LD_INT 0
54437: PPUSH
54438: PPUSH
// result := false ;
54439: LD_ADDR_VAR 0 2
54443: PUSH
54444: LD_INT 0
54446: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54447: LD_ADDR_VAR 0 3
54451: PUSH
54452: LD_VAR 0 1
54456: PPUSH
54457: CALL_OW 437
54461: ST_TO_ADDR
// if task then
54462: LD_VAR 0 3
54466: IFFALSE 54494
// if task [ 1 ] [ 1 ] = p then
54468: LD_VAR 0 3
54472: PUSH
54473: LD_INT 1
54475: ARRAY
54476: PUSH
54477: LD_INT 1
54479: ARRAY
54480: PUSH
54481: LD_STRING p
54483: EQUAL
54484: IFFALSE 54494
// result := true ;
54486: LD_ADDR_VAR 0 2
54490: PUSH
54491: LD_INT 1
54493: ST_TO_ADDR
// end ;
54494: LD_VAR 0 2
54498: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54499: LD_INT 0
54501: PPUSH
54502: PPUSH
54503: PPUSH
54504: PPUSH
// if pos < 1 then
54505: LD_VAR 0 2
54509: PUSH
54510: LD_INT 1
54512: LESS
54513: IFFALSE 54517
// exit ;
54515: GO 54820
// if pos = 1 then
54517: LD_VAR 0 2
54521: PUSH
54522: LD_INT 1
54524: EQUAL
54525: IFFALSE 54558
// result := Replace ( arr , pos [ 1 ] , value ) else
54527: LD_ADDR_VAR 0 4
54531: PUSH
54532: LD_VAR 0 1
54536: PPUSH
54537: LD_VAR 0 2
54541: PUSH
54542: LD_INT 1
54544: ARRAY
54545: PPUSH
54546: LD_VAR 0 3
54550: PPUSH
54551: CALL_OW 1
54555: ST_TO_ADDR
54556: GO 54820
// begin tmp := arr ;
54558: LD_ADDR_VAR 0 6
54562: PUSH
54563: LD_VAR 0 1
54567: ST_TO_ADDR
// s_arr := [ tmp ] ;
54568: LD_ADDR_VAR 0 7
54572: PUSH
54573: LD_VAR 0 6
54577: PUSH
54578: EMPTY
54579: LIST
54580: ST_TO_ADDR
// for i = 1 to pos - 1 do
54581: LD_ADDR_VAR 0 5
54585: PUSH
54586: DOUBLE
54587: LD_INT 1
54589: DEC
54590: ST_TO_ADDR
54591: LD_VAR 0 2
54595: PUSH
54596: LD_INT 1
54598: MINUS
54599: PUSH
54600: FOR_TO
54601: IFFALSE 54646
// begin tmp := tmp [ pos [ i ] ] ;
54603: LD_ADDR_VAR 0 6
54607: PUSH
54608: LD_VAR 0 6
54612: PUSH
54613: LD_VAR 0 2
54617: PUSH
54618: LD_VAR 0 5
54622: ARRAY
54623: ARRAY
54624: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54625: LD_ADDR_VAR 0 7
54629: PUSH
54630: LD_VAR 0 7
54634: PUSH
54635: LD_VAR 0 6
54639: PUSH
54640: EMPTY
54641: LIST
54642: ADD
54643: ST_TO_ADDR
// end ;
54644: GO 54600
54646: POP
54647: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54648: LD_ADDR_VAR 0 6
54652: PUSH
54653: LD_VAR 0 6
54657: PPUSH
54658: LD_VAR 0 2
54662: PUSH
54663: LD_VAR 0 2
54667: ARRAY
54668: PPUSH
54669: LD_VAR 0 3
54673: PPUSH
54674: CALL_OW 1
54678: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54679: LD_ADDR_VAR 0 7
54683: PUSH
54684: LD_VAR 0 7
54688: PPUSH
54689: LD_VAR 0 7
54693: PPUSH
54694: LD_VAR 0 6
54698: PPUSH
54699: CALL_OW 1
54703: ST_TO_ADDR
// for i = s_arr downto 2 do
54704: LD_ADDR_VAR 0 5
54708: PUSH
54709: DOUBLE
54710: LD_VAR 0 7
54714: INC
54715: ST_TO_ADDR
54716: LD_INT 2
54718: PUSH
54719: FOR_DOWNTO
54720: IFFALSE 54804
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54722: LD_ADDR_VAR 0 6
54726: PUSH
54727: LD_VAR 0 7
54731: PUSH
54732: LD_VAR 0 5
54736: PUSH
54737: LD_INT 1
54739: MINUS
54740: ARRAY
54741: PPUSH
54742: LD_VAR 0 2
54746: PUSH
54747: LD_VAR 0 5
54751: PUSH
54752: LD_INT 1
54754: MINUS
54755: ARRAY
54756: PPUSH
54757: LD_VAR 0 7
54761: PUSH
54762: LD_VAR 0 5
54766: ARRAY
54767: PPUSH
54768: CALL_OW 1
54772: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54773: LD_ADDR_VAR 0 7
54777: PUSH
54778: LD_VAR 0 7
54782: PPUSH
54783: LD_VAR 0 5
54787: PUSH
54788: LD_INT 1
54790: MINUS
54791: PPUSH
54792: LD_VAR 0 6
54796: PPUSH
54797: CALL_OW 1
54801: ST_TO_ADDR
// end ;
54802: GO 54719
54804: POP
54805: POP
// result := s_arr [ 1 ] ;
54806: LD_ADDR_VAR 0 4
54810: PUSH
54811: LD_VAR 0 7
54815: PUSH
54816: LD_INT 1
54818: ARRAY
54819: ST_TO_ADDR
// end ; end ;
54820: LD_VAR 0 4
54824: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54825: LD_INT 0
54827: PPUSH
54828: PPUSH
// if not list then
54829: LD_VAR 0 1
54833: NOT
54834: IFFALSE 54838
// exit ;
54836: GO 54929
// i := list [ pos1 ] ;
54838: LD_ADDR_VAR 0 5
54842: PUSH
54843: LD_VAR 0 1
54847: PUSH
54848: LD_VAR 0 2
54852: ARRAY
54853: ST_TO_ADDR
// if not i then
54854: LD_VAR 0 5
54858: NOT
54859: IFFALSE 54863
// exit ;
54861: GO 54929
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54863: LD_ADDR_VAR 0 1
54867: PUSH
54868: LD_VAR 0 1
54872: PPUSH
54873: LD_VAR 0 2
54877: PPUSH
54878: LD_VAR 0 1
54882: PUSH
54883: LD_VAR 0 3
54887: ARRAY
54888: PPUSH
54889: CALL_OW 1
54893: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54894: LD_ADDR_VAR 0 1
54898: PUSH
54899: LD_VAR 0 1
54903: PPUSH
54904: LD_VAR 0 3
54908: PPUSH
54909: LD_VAR 0 5
54913: PPUSH
54914: CALL_OW 1
54918: ST_TO_ADDR
// result := list ;
54919: LD_ADDR_VAR 0 4
54923: PUSH
54924: LD_VAR 0 1
54928: ST_TO_ADDR
// end ;
54929: LD_VAR 0 4
54933: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54934: LD_INT 0
54936: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54937: LD_ADDR_VAR 0 5
54941: PUSH
54942: LD_VAR 0 1
54946: PPUSH
54947: CALL_OW 250
54951: PPUSH
54952: LD_VAR 0 1
54956: PPUSH
54957: CALL_OW 251
54961: PPUSH
54962: LD_VAR 0 2
54966: PPUSH
54967: LD_VAR 0 3
54971: PPUSH
54972: LD_VAR 0 4
54976: PPUSH
54977: CALL 54987 0 5
54981: ST_TO_ADDR
// end ;
54982: LD_VAR 0 5
54986: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54987: LD_INT 0
54989: PPUSH
54990: PPUSH
54991: PPUSH
54992: PPUSH
// if not list then
54993: LD_VAR 0 3
54997: NOT
54998: IFFALSE 55002
// exit ;
55000: GO 55390
// result := [ ] ;
55002: LD_ADDR_VAR 0 6
55006: PUSH
55007: EMPTY
55008: ST_TO_ADDR
// for i in list do
55009: LD_ADDR_VAR 0 7
55013: PUSH
55014: LD_VAR 0 3
55018: PUSH
55019: FOR_IN
55020: IFFALSE 55222
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55022: LD_ADDR_VAR 0 9
55026: PUSH
55027: LD_VAR 0 7
55031: PPUSH
55032: LD_VAR 0 1
55036: PPUSH
55037: LD_VAR 0 2
55041: PPUSH
55042: CALL_OW 297
55046: ST_TO_ADDR
// if not result then
55047: LD_VAR 0 6
55051: NOT
55052: IFFALSE 55078
// result := [ [ i , tmp ] ] else
55054: LD_ADDR_VAR 0 6
55058: PUSH
55059: LD_VAR 0 7
55063: PUSH
55064: LD_VAR 0 9
55068: PUSH
55069: EMPTY
55070: LIST
55071: LIST
55072: PUSH
55073: EMPTY
55074: LIST
55075: ST_TO_ADDR
55076: GO 55220
// begin if result [ result ] [ 2 ] < tmp then
55078: LD_VAR 0 6
55082: PUSH
55083: LD_VAR 0 6
55087: ARRAY
55088: PUSH
55089: LD_INT 2
55091: ARRAY
55092: PUSH
55093: LD_VAR 0 9
55097: LESS
55098: IFFALSE 55140
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55100: LD_ADDR_VAR 0 6
55104: PUSH
55105: LD_VAR 0 6
55109: PPUSH
55110: LD_VAR 0 6
55114: PUSH
55115: LD_INT 1
55117: PLUS
55118: PPUSH
55119: LD_VAR 0 7
55123: PUSH
55124: LD_VAR 0 9
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PPUSH
55133: CALL_OW 2
55137: ST_TO_ADDR
55138: GO 55220
// for j = 1 to result do
55140: LD_ADDR_VAR 0 8
55144: PUSH
55145: DOUBLE
55146: LD_INT 1
55148: DEC
55149: ST_TO_ADDR
55150: LD_VAR 0 6
55154: PUSH
55155: FOR_TO
55156: IFFALSE 55218
// begin if tmp < result [ j ] [ 2 ] then
55158: LD_VAR 0 9
55162: PUSH
55163: LD_VAR 0 6
55167: PUSH
55168: LD_VAR 0 8
55172: ARRAY
55173: PUSH
55174: LD_INT 2
55176: ARRAY
55177: LESS
55178: IFFALSE 55216
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55180: LD_ADDR_VAR 0 6
55184: PUSH
55185: LD_VAR 0 6
55189: PPUSH
55190: LD_VAR 0 8
55194: PPUSH
55195: LD_VAR 0 7
55199: PUSH
55200: LD_VAR 0 9
55204: PUSH
55205: EMPTY
55206: LIST
55207: LIST
55208: PPUSH
55209: CALL_OW 2
55213: ST_TO_ADDR
// break ;
55214: GO 55218
// end ; end ;
55216: GO 55155
55218: POP
55219: POP
// end ; end ;
55220: GO 55019
55222: POP
55223: POP
// if result and not asc then
55224: LD_VAR 0 6
55228: PUSH
55229: LD_VAR 0 4
55233: NOT
55234: AND
55235: IFFALSE 55310
// begin tmp := result ;
55237: LD_ADDR_VAR 0 9
55241: PUSH
55242: LD_VAR 0 6
55246: ST_TO_ADDR
// for i = tmp downto 1 do
55247: LD_ADDR_VAR 0 7
55251: PUSH
55252: DOUBLE
55253: LD_VAR 0 9
55257: INC
55258: ST_TO_ADDR
55259: LD_INT 1
55261: PUSH
55262: FOR_DOWNTO
55263: IFFALSE 55308
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55265: LD_ADDR_VAR 0 6
55269: PUSH
55270: LD_VAR 0 6
55274: PPUSH
55275: LD_VAR 0 9
55279: PUSH
55280: LD_VAR 0 7
55284: MINUS
55285: PUSH
55286: LD_INT 1
55288: PLUS
55289: PPUSH
55290: LD_VAR 0 9
55294: PUSH
55295: LD_VAR 0 7
55299: ARRAY
55300: PPUSH
55301: CALL_OW 1
55305: ST_TO_ADDR
55306: GO 55262
55308: POP
55309: POP
// end ; tmp := [ ] ;
55310: LD_ADDR_VAR 0 9
55314: PUSH
55315: EMPTY
55316: ST_TO_ADDR
// if mode then
55317: LD_VAR 0 5
55321: IFFALSE 55390
// begin for i = 1 to result do
55323: LD_ADDR_VAR 0 7
55327: PUSH
55328: DOUBLE
55329: LD_INT 1
55331: DEC
55332: ST_TO_ADDR
55333: LD_VAR 0 6
55337: PUSH
55338: FOR_TO
55339: IFFALSE 55378
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55341: LD_ADDR_VAR 0 9
55345: PUSH
55346: LD_VAR 0 9
55350: PPUSH
55351: LD_VAR 0 7
55355: PPUSH
55356: LD_VAR 0 6
55360: PUSH
55361: LD_VAR 0 7
55365: ARRAY
55366: PUSH
55367: LD_INT 1
55369: ARRAY
55370: PPUSH
55371: CALL_OW 1
55375: ST_TO_ADDR
55376: GO 55338
55378: POP
55379: POP
// result := tmp ;
55380: LD_ADDR_VAR 0 6
55384: PUSH
55385: LD_VAR 0 9
55389: ST_TO_ADDR
// end ; end ;
55390: LD_VAR 0 6
55394: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55395: LD_INT 0
55397: PPUSH
55398: PPUSH
55399: PPUSH
55400: PPUSH
55401: PPUSH
55402: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55403: LD_ADDR_VAR 0 5
55407: PUSH
55408: LD_INT 0
55410: PUSH
55411: LD_INT 0
55413: PUSH
55414: LD_INT 0
55416: PUSH
55417: EMPTY
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: LIST
55424: ST_TO_ADDR
// if not x or not y then
55425: LD_VAR 0 2
55429: NOT
55430: PUSH
55431: LD_VAR 0 3
55435: NOT
55436: OR
55437: IFFALSE 55441
// exit ;
55439: GO 57087
// if not range then
55441: LD_VAR 0 4
55445: NOT
55446: IFFALSE 55456
// range := 10 ;
55448: LD_ADDR_VAR 0 4
55452: PUSH
55453: LD_INT 10
55455: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55456: LD_ADDR_VAR 0 8
55460: PUSH
55461: LD_INT 81
55463: PUSH
55464: LD_VAR 0 1
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PUSH
55473: LD_INT 92
55475: PUSH
55476: LD_VAR 0 2
55480: PUSH
55481: LD_VAR 0 3
55485: PUSH
55486: LD_VAR 0 4
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: LIST
55495: LIST
55496: PUSH
55497: LD_INT 3
55499: PUSH
55500: LD_INT 21
55502: PUSH
55503: LD_INT 3
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: LIST
55518: PPUSH
55519: CALL_OW 69
55523: ST_TO_ADDR
// if not tmp then
55524: LD_VAR 0 8
55528: NOT
55529: IFFALSE 55533
// exit ;
55531: GO 57087
// for i in tmp do
55533: LD_ADDR_VAR 0 6
55537: PUSH
55538: LD_VAR 0 8
55542: PUSH
55543: FOR_IN
55544: IFFALSE 57062
// begin points := [ 0 , 0 , 0 ] ;
55546: LD_ADDR_VAR 0 9
55550: PUSH
55551: LD_INT 0
55553: PUSH
55554: LD_INT 0
55556: PUSH
55557: LD_INT 0
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: LIST
55564: ST_TO_ADDR
// bpoints := 1 ;
55565: LD_ADDR_VAR 0 10
55569: PUSH
55570: LD_INT 1
55572: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55573: LD_VAR 0 6
55577: PPUSH
55578: CALL_OW 247
55582: PUSH
55583: LD_INT 1
55585: DOUBLE
55586: EQUAL
55587: IFTRUE 55591
55589: GO 56169
55591: POP
// begin if GetClass ( i ) = 1 then
55592: LD_VAR 0 6
55596: PPUSH
55597: CALL_OW 257
55601: PUSH
55602: LD_INT 1
55604: EQUAL
55605: IFFALSE 55626
// points := [ 10 , 5 , 3 ] ;
55607: LD_ADDR_VAR 0 9
55611: PUSH
55612: LD_INT 10
55614: PUSH
55615: LD_INT 5
55617: PUSH
55618: LD_INT 3
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: LIST
55625: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55626: LD_VAR 0 6
55630: PPUSH
55631: CALL_OW 257
55635: PUSH
55636: LD_INT 2
55638: PUSH
55639: LD_INT 3
55641: PUSH
55642: LD_INT 4
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: LIST
55649: IN
55650: IFFALSE 55671
// points := [ 3 , 2 , 1 ] ;
55652: LD_ADDR_VAR 0 9
55656: PUSH
55657: LD_INT 3
55659: PUSH
55660: LD_INT 2
55662: PUSH
55663: LD_INT 1
55665: PUSH
55666: EMPTY
55667: LIST
55668: LIST
55669: LIST
55670: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55671: LD_VAR 0 6
55675: PPUSH
55676: CALL_OW 257
55680: PUSH
55681: LD_INT 5
55683: EQUAL
55684: IFFALSE 55705
// points := [ 130 , 5 , 2 ] ;
55686: LD_ADDR_VAR 0 9
55690: PUSH
55691: LD_INT 130
55693: PUSH
55694: LD_INT 5
55696: PUSH
55697: LD_INT 2
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: LIST
55704: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55705: LD_VAR 0 6
55709: PPUSH
55710: CALL_OW 257
55714: PUSH
55715: LD_INT 8
55717: EQUAL
55718: IFFALSE 55739
// points := [ 35 , 35 , 30 ] ;
55720: LD_ADDR_VAR 0 9
55724: PUSH
55725: LD_INT 35
55727: PUSH
55728: LD_INT 35
55730: PUSH
55731: LD_INT 30
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: LIST
55738: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55739: LD_VAR 0 6
55743: PPUSH
55744: CALL_OW 257
55748: PUSH
55749: LD_INT 9
55751: EQUAL
55752: IFFALSE 55773
// points := [ 20 , 55 , 40 ] ;
55754: LD_ADDR_VAR 0 9
55758: PUSH
55759: LD_INT 20
55761: PUSH
55762: LD_INT 55
55764: PUSH
55765: LD_INT 40
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: LIST
55772: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55773: LD_VAR 0 6
55777: PPUSH
55778: CALL_OW 257
55782: PUSH
55783: LD_INT 12
55785: PUSH
55786: LD_INT 16
55788: PUSH
55789: EMPTY
55790: LIST
55791: LIST
55792: IN
55793: IFFALSE 55814
// points := [ 5 , 3 , 2 ] ;
55795: LD_ADDR_VAR 0 9
55799: PUSH
55800: LD_INT 5
55802: PUSH
55803: LD_INT 3
55805: PUSH
55806: LD_INT 2
55808: PUSH
55809: EMPTY
55810: LIST
55811: LIST
55812: LIST
55813: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55814: LD_VAR 0 6
55818: PPUSH
55819: CALL_OW 257
55823: PUSH
55824: LD_INT 17
55826: EQUAL
55827: IFFALSE 55848
// points := [ 100 , 50 , 75 ] ;
55829: LD_ADDR_VAR 0 9
55833: PUSH
55834: LD_INT 100
55836: PUSH
55837: LD_INT 50
55839: PUSH
55840: LD_INT 75
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55848: LD_VAR 0 6
55852: PPUSH
55853: CALL_OW 257
55857: PUSH
55858: LD_INT 15
55860: EQUAL
55861: IFFALSE 55882
// points := [ 10 , 5 , 3 ] ;
55863: LD_ADDR_VAR 0 9
55867: PUSH
55868: LD_INT 10
55870: PUSH
55871: LD_INT 5
55873: PUSH
55874: LD_INT 3
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: LIST
55881: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55882: LD_VAR 0 6
55886: PPUSH
55887: CALL_OW 257
55891: PUSH
55892: LD_INT 14
55894: EQUAL
55895: IFFALSE 55916
// points := [ 10 , 0 , 0 ] ;
55897: LD_ADDR_VAR 0 9
55901: PUSH
55902: LD_INT 10
55904: PUSH
55905: LD_INT 0
55907: PUSH
55908: LD_INT 0
55910: PUSH
55911: EMPTY
55912: LIST
55913: LIST
55914: LIST
55915: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55916: LD_VAR 0 6
55920: PPUSH
55921: CALL_OW 257
55925: PUSH
55926: LD_INT 11
55928: EQUAL
55929: IFFALSE 55950
// points := [ 30 , 10 , 5 ] ;
55931: LD_ADDR_VAR 0 9
55935: PUSH
55936: LD_INT 30
55938: PUSH
55939: LD_INT 10
55941: PUSH
55942: LD_INT 5
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: LIST
55949: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55950: LD_VAR 0 1
55954: PPUSH
55955: LD_INT 5
55957: PPUSH
55958: CALL_OW 321
55962: PUSH
55963: LD_INT 2
55965: EQUAL
55966: IFFALSE 55983
// bpoints := bpoints * 1.8 ;
55968: LD_ADDR_VAR 0 10
55972: PUSH
55973: LD_VAR 0 10
55977: PUSH
55978: LD_REAL  1.80000000000000E+0000
55981: MUL
55982: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55983: LD_VAR 0 6
55987: PPUSH
55988: CALL_OW 257
55992: PUSH
55993: LD_INT 1
55995: PUSH
55996: LD_INT 2
55998: PUSH
55999: LD_INT 3
56001: PUSH
56002: LD_INT 4
56004: PUSH
56005: EMPTY
56006: LIST
56007: LIST
56008: LIST
56009: LIST
56010: IN
56011: PUSH
56012: LD_VAR 0 1
56016: PPUSH
56017: LD_INT 51
56019: PPUSH
56020: CALL_OW 321
56024: PUSH
56025: LD_INT 2
56027: EQUAL
56028: AND
56029: IFFALSE 56046
// bpoints := bpoints * 1.2 ;
56031: LD_ADDR_VAR 0 10
56035: PUSH
56036: LD_VAR 0 10
56040: PUSH
56041: LD_REAL  1.20000000000000E+0000
56044: MUL
56045: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56046: LD_VAR 0 6
56050: PPUSH
56051: CALL_OW 257
56055: PUSH
56056: LD_INT 5
56058: PUSH
56059: LD_INT 7
56061: PUSH
56062: LD_INT 9
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: LIST
56069: IN
56070: PUSH
56071: LD_VAR 0 1
56075: PPUSH
56076: LD_INT 52
56078: PPUSH
56079: CALL_OW 321
56083: PUSH
56084: LD_INT 2
56086: EQUAL
56087: AND
56088: IFFALSE 56105
// bpoints := bpoints * 1.5 ;
56090: LD_ADDR_VAR 0 10
56094: PUSH
56095: LD_VAR 0 10
56099: PUSH
56100: LD_REAL  1.50000000000000E+0000
56103: MUL
56104: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56105: LD_VAR 0 1
56109: PPUSH
56110: LD_INT 66
56112: PPUSH
56113: CALL_OW 321
56117: PUSH
56118: LD_INT 2
56120: EQUAL
56121: IFFALSE 56138
// bpoints := bpoints * 1.1 ;
56123: LD_ADDR_VAR 0 10
56127: PUSH
56128: LD_VAR 0 10
56132: PUSH
56133: LD_REAL  1.10000000000000E+0000
56136: MUL
56137: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56138: LD_ADDR_VAR 0 10
56142: PUSH
56143: LD_VAR 0 10
56147: PUSH
56148: LD_VAR 0 6
56152: PPUSH
56153: LD_INT 1
56155: PPUSH
56156: CALL_OW 259
56160: PUSH
56161: LD_REAL  1.15000000000000E+0000
56164: MUL
56165: MUL
56166: ST_TO_ADDR
// end ; unit_vehicle :
56167: GO 56991
56169: LD_INT 2
56171: DOUBLE
56172: EQUAL
56173: IFTRUE 56177
56175: GO 56979
56177: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56178: LD_VAR 0 6
56182: PPUSH
56183: CALL_OW 264
56187: PUSH
56188: LD_INT 2
56190: PUSH
56191: LD_INT 42
56193: PUSH
56194: LD_INT 24
56196: PUSH
56197: EMPTY
56198: LIST
56199: LIST
56200: LIST
56201: IN
56202: IFFALSE 56223
// points := [ 25 , 5 , 3 ] ;
56204: LD_ADDR_VAR 0 9
56208: PUSH
56209: LD_INT 25
56211: PUSH
56212: LD_INT 5
56214: PUSH
56215: LD_INT 3
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: LIST
56222: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56223: LD_VAR 0 6
56227: PPUSH
56228: CALL_OW 264
56232: PUSH
56233: LD_INT 4
56235: PUSH
56236: LD_INT 43
56238: PUSH
56239: LD_INT 25
56241: PUSH
56242: EMPTY
56243: LIST
56244: LIST
56245: LIST
56246: IN
56247: IFFALSE 56268
// points := [ 40 , 15 , 5 ] ;
56249: LD_ADDR_VAR 0 9
56253: PUSH
56254: LD_INT 40
56256: PUSH
56257: LD_INT 15
56259: PUSH
56260: LD_INT 5
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: LIST
56267: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56268: LD_VAR 0 6
56272: PPUSH
56273: CALL_OW 264
56277: PUSH
56278: LD_INT 3
56280: PUSH
56281: LD_INT 23
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: IN
56288: IFFALSE 56309
// points := [ 7 , 25 , 8 ] ;
56290: LD_ADDR_VAR 0 9
56294: PUSH
56295: LD_INT 7
56297: PUSH
56298: LD_INT 25
56300: PUSH
56301: LD_INT 8
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: LIST
56308: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56309: LD_VAR 0 6
56313: PPUSH
56314: CALL_OW 264
56318: PUSH
56319: LD_INT 5
56321: PUSH
56322: LD_INT 27
56324: PUSH
56325: LD_INT 44
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: LIST
56332: IN
56333: IFFALSE 56354
// points := [ 14 , 50 , 16 ] ;
56335: LD_ADDR_VAR 0 9
56339: PUSH
56340: LD_INT 14
56342: PUSH
56343: LD_INT 50
56345: PUSH
56346: LD_INT 16
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: LIST
56353: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56354: LD_VAR 0 6
56358: PPUSH
56359: CALL_OW 264
56363: PUSH
56364: LD_INT 6
56366: PUSH
56367: LD_INT 46
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: IN
56374: IFFALSE 56395
// points := [ 32 , 120 , 70 ] ;
56376: LD_ADDR_VAR 0 9
56380: PUSH
56381: LD_INT 32
56383: PUSH
56384: LD_INT 120
56386: PUSH
56387: LD_INT 70
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: LIST
56394: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56395: LD_VAR 0 6
56399: PPUSH
56400: CALL_OW 264
56404: PUSH
56405: LD_INT 7
56407: PUSH
56408: LD_INT 28
56410: PUSH
56411: LD_INT 45
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: LIST
56418: IN
56419: IFFALSE 56440
// points := [ 35 , 20 , 45 ] ;
56421: LD_ADDR_VAR 0 9
56425: PUSH
56426: LD_INT 35
56428: PUSH
56429: LD_INT 20
56431: PUSH
56432: LD_INT 45
56434: PUSH
56435: EMPTY
56436: LIST
56437: LIST
56438: LIST
56439: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56440: LD_VAR 0 6
56444: PPUSH
56445: CALL_OW 264
56449: PUSH
56450: LD_INT 47
56452: PUSH
56453: EMPTY
56454: LIST
56455: IN
56456: IFFALSE 56477
// points := [ 67 , 45 , 75 ] ;
56458: LD_ADDR_VAR 0 9
56462: PUSH
56463: LD_INT 67
56465: PUSH
56466: LD_INT 45
56468: PUSH
56469: LD_INT 75
56471: PUSH
56472: EMPTY
56473: LIST
56474: LIST
56475: LIST
56476: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56477: LD_VAR 0 6
56481: PPUSH
56482: CALL_OW 264
56486: PUSH
56487: LD_INT 26
56489: PUSH
56490: EMPTY
56491: LIST
56492: IN
56493: IFFALSE 56514
// points := [ 120 , 30 , 80 ] ;
56495: LD_ADDR_VAR 0 9
56499: PUSH
56500: LD_INT 120
56502: PUSH
56503: LD_INT 30
56505: PUSH
56506: LD_INT 80
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: LIST
56513: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56514: LD_VAR 0 6
56518: PPUSH
56519: CALL_OW 264
56523: PUSH
56524: LD_INT 22
56526: PUSH
56527: EMPTY
56528: LIST
56529: IN
56530: IFFALSE 56551
// points := [ 40 , 1 , 1 ] ;
56532: LD_ADDR_VAR 0 9
56536: PUSH
56537: LD_INT 40
56539: PUSH
56540: LD_INT 1
56542: PUSH
56543: LD_INT 1
56545: PUSH
56546: EMPTY
56547: LIST
56548: LIST
56549: LIST
56550: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56551: LD_VAR 0 6
56555: PPUSH
56556: CALL_OW 264
56560: PUSH
56561: LD_INT 29
56563: PUSH
56564: EMPTY
56565: LIST
56566: IN
56567: IFFALSE 56588
// points := [ 70 , 200 , 400 ] ;
56569: LD_ADDR_VAR 0 9
56573: PUSH
56574: LD_INT 70
56576: PUSH
56577: LD_INT 200
56579: PUSH
56580: LD_INT 400
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: LIST
56587: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56588: LD_VAR 0 6
56592: PPUSH
56593: CALL_OW 264
56597: PUSH
56598: LD_INT 14
56600: PUSH
56601: LD_INT 53
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: IN
56608: IFFALSE 56629
// points := [ 40 , 10 , 20 ] ;
56610: LD_ADDR_VAR 0 9
56614: PUSH
56615: LD_INT 40
56617: PUSH
56618: LD_INT 10
56620: PUSH
56621: LD_INT 20
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: LIST
56628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56629: LD_VAR 0 6
56633: PPUSH
56634: CALL_OW 264
56638: PUSH
56639: LD_INT 9
56641: PUSH
56642: EMPTY
56643: LIST
56644: IN
56645: IFFALSE 56666
// points := [ 5 , 70 , 20 ] ;
56647: LD_ADDR_VAR 0 9
56651: PUSH
56652: LD_INT 5
56654: PUSH
56655: LD_INT 70
56657: PUSH
56658: LD_INT 20
56660: PUSH
56661: EMPTY
56662: LIST
56663: LIST
56664: LIST
56665: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56666: LD_VAR 0 6
56670: PPUSH
56671: CALL_OW 264
56675: PUSH
56676: LD_INT 10
56678: PUSH
56679: EMPTY
56680: LIST
56681: IN
56682: IFFALSE 56703
// points := [ 35 , 110 , 70 ] ;
56684: LD_ADDR_VAR 0 9
56688: PUSH
56689: LD_INT 35
56691: PUSH
56692: LD_INT 110
56694: PUSH
56695: LD_INT 70
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: LIST
56702: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56703: LD_VAR 0 6
56707: PPUSH
56708: CALL_OW 265
56712: PUSH
56713: LD_INT 25
56715: EQUAL
56716: IFFALSE 56737
// points := [ 80 , 65 , 100 ] ;
56718: LD_ADDR_VAR 0 9
56722: PUSH
56723: LD_INT 80
56725: PUSH
56726: LD_INT 65
56728: PUSH
56729: LD_INT 100
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: LIST
56736: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56737: LD_VAR 0 6
56741: PPUSH
56742: CALL_OW 263
56746: PUSH
56747: LD_INT 1
56749: EQUAL
56750: IFFALSE 56785
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56752: LD_ADDR_VAR 0 10
56756: PUSH
56757: LD_VAR 0 10
56761: PUSH
56762: LD_VAR 0 6
56766: PPUSH
56767: CALL_OW 311
56771: PPUSH
56772: LD_INT 3
56774: PPUSH
56775: CALL_OW 259
56779: PUSH
56780: LD_INT 4
56782: MUL
56783: MUL
56784: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56785: LD_VAR 0 6
56789: PPUSH
56790: CALL_OW 263
56794: PUSH
56795: LD_INT 2
56797: EQUAL
56798: IFFALSE 56849
// begin j := IsControledBy ( i ) ;
56800: LD_ADDR_VAR 0 7
56804: PUSH
56805: LD_VAR 0 6
56809: PPUSH
56810: CALL_OW 312
56814: ST_TO_ADDR
// if j then
56815: LD_VAR 0 7
56819: IFFALSE 56849
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56821: LD_ADDR_VAR 0 10
56825: PUSH
56826: LD_VAR 0 10
56830: PUSH
56831: LD_VAR 0 7
56835: PPUSH
56836: LD_INT 3
56838: PPUSH
56839: CALL_OW 259
56843: PUSH
56844: LD_INT 3
56846: MUL
56847: MUL
56848: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56849: LD_VAR 0 6
56853: PPUSH
56854: CALL_OW 264
56858: PUSH
56859: LD_INT 5
56861: PUSH
56862: LD_INT 6
56864: PUSH
56865: LD_INT 46
56867: PUSH
56868: LD_INT 44
56870: PUSH
56871: LD_INT 47
56873: PUSH
56874: LD_INT 45
56876: PUSH
56877: LD_INT 28
56879: PUSH
56880: LD_INT 7
56882: PUSH
56883: LD_INT 27
56885: PUSH
56886: LD_INT 29
56888: PUSH
56889: EMPTY
56890: LIST
56891: LIST
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: IN
56901: PUSH
56902: LD_VAR 0 1
56906: PPUSH
56907: LD_INT 52
56909: PPUSH
56910: CALL_OW 321
56914: PUSH
56915: LD_INT 2
56917: EQUAL
56918: AND
56919: IFFALSE 56936
// bpoints := bpoints * 1.2 ;
56921: LD_ADDR_VAR 0 10
56925: PUSH
56926: LD_VAR 0 10
56930: PUSH
56931: LD_REAL  1.20000000000000E+0000
56934: MUL
56935: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56936: LD_VAR 0 6
56940: PPUSH
56941: CALL_OW 264
56945: PUSH
56946: LD_INT 6
56948: PUSH
56949: LD_INT 46
56951: PUSH
56952: LD_INT 47
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: LIST
56959: IN
56960: IFFALSE 56977
// bpoints := bpoints * 1.2 ;
56962: LD_ADDR_VAR 0 10
56966: PUSH
56967: LD_VAR 0 10
56971: PUSH
56972: LD_REAL  1.20000000000000E+0000
56975: MUL
56976: ST_TO_ADDR
// end ; unit_building :
56977: GO 56991
56979: LD_INT 3
56981: DOUBLE
56982: EQUAL
56983: IFTRUE 56987
56985: GO 56990
56987: POP
// ; end ;
56988: GO 56991
56990: POP
// for j = 1 to 3 do
56991: LD_ADDR_VAR 0 7
56995: PUSH
56996: DOUBLE
56997: LD_INT 1
56999: DEC
57000: ST_TO_ADDR
57001: LD_INT 3
57003: PUSH
57004: FOR_TO
57005: IFFALSE 57058
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57007: LD_ADDR_VAR 0 5
57011: PUSH
57012: LD_VAR 0 5
57016: PPUSH
57017: LD_VAR 0 7
57021: PPUSH
57022: LD_VAR 0 5
57026: PUSH
57027: LD_VAR 0 7
57031: ARRAY
57032: PUSH
57033: LD_VAR 0 9
57037: PUSH
57038: LD_VAR 0 7
57042: ARRAY
57043: PUSH
57044: LD_VAR 0 10
57048: MUL
57049: PLUS
57050: PPUSH
57051: CALL_OW 1
57055: ST_TO_ADDR
57056: GO 57004
57058: POP
57059: POP
// end ;
57060: GO 55543
57062: POP
57063: POP
// result := Replace ( result , 4 , tmp ) ;
57064: LD_ADDR_VAR 0 5
57068: PUSH
57069: LD_VAR 0 5
57073: PPUSH
57074: LD_INT 4
57076: PPUSH
57077: LD_VAR 0 8
57081: PPUSH
57082: CALL_OW 1
57086: ST_TO_ADDR
// end ;
57087: LD_VAR 0 5
57091: RET
// export function DangerAtRange ( unit , range ) ; begin
57092: LD_INT 0
57094: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57095: LD_ADDR_VAR 0 3
57099: PUSH
57100: LD_VAR 0 1
57104: PPUSH
57105: CALL_OW 255
57109: PPUSH
57110: LD_VAR 0 1
57114: PPUSH
57115: CALL_OW 250
57119: PPUSH
57120: LD_VAR 0 1
57124: PPUSH
57125: CALL_OW 251
57129: PPUSH
57130: LD_VAR 0 2
57134: PPUSH
57135: CALL 55395 0 4
57139: ST_TO_ADDR
// end ;
57140: LD_VAR 0 3
57144: RET
// export function DangerInArea ( side , area ) ; begin
57145: LD_INT 0
57147: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57148: LD_ADDR_VAR 0 3
57152: PUSH
57153: LD_VAR 0 2
57157: PPUSH
57158: LD_INT 81
57160: PUSH
57161: LD_VAR 0 1
57165: PUSH
57166: EMPTY
57167: LIST
57168: LIST
57169: PPUSH
57170: CALL_OW 70
57174: ST_TO_ADDR
// end ;
57175: LD_VAR 0 3
57179: RET
// export function IsExtension ( b ) ; begin
57180: LD_INT 0
57182: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57183: LD_ADDR_VAR 0 2
57187: PUSH
57188: LD_VAR 0 1
57192: PUSH
57193: LD_INT 23
57195: PUSH
57196: LD_INT 20
57198: PUSH
57199: LD_INT 22
57201: PUSH
57202: LD_INT 17
57204: PUSH
57205: LD_INT 24
57207: PUSH
57208: LD_INT 21
57210: PUSH
57211: LD_INT 19
57213: PUSH
57214: LD_INT 16
57216: PUSH
57217: LD_INT 25
57219: PUSH
57220: LD_INT 18
57222: PUSH
57223: EMPTY
57224: LIST
57225: LIST
57226: LIST
57227: LIST
57228: LIST
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: LIST
57234: IN
57235: ST_TO_ADDR
// end ;
57236: LD_VAR 0 2
57240: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
57241: LD_INT 0
57243: PPUSH
57244: PPUSH
57245: PPUSH
// result := [ ] ;
57246: LD_ADDR_VAR 0 3
57250: PUSH
57251: EMPTY
57252: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57253: LD_ADDR_VAR 0 4
57257: PUSH
57258: LD_VAR 0 2
57262: PPUSH
57263: LD_INT 21
57265: PUSH
57266: LD_INT 3
57268: PUSH
57269: EMPTY
57270: LIST
57271: LIST
57272: PPUSH
57273: CALL_OW 70
57277: ST_TO_ADDR
// if not tmp then
57278: LD_VAR 0 4
57282: NOT
57283: IFFALSE 57287
// exit ;
57285: GO 57345
// for i in tmp do
57287: LD_ADDR_VAR 0 5
57291: PUSH
57292: LD_VAR 0 4
57296: PUSH
57297: FOR_IN
57298: IFFALSE 57333
// if GetBase ( i ) <> base then
57300: LD_VAR 0 5
57304: PPUSH
57305: CALL_OW 274
57309: PUSH
57310: LD_VAR 0 1
57314: NONEQUAL
57315: IFFALSE 57331
// ComLinkToBase ( base , i ) ;
57317: LD_VAR 0 1
57321: PPUSH
57322: LD_VAR 0 5
57326: PPUSH
57327: CALL_OW 169
57331: GO 57297
57333: POP
57334: POP
// result := tmp ;
57335: LD_ADDR_VAR 0 3
57339: PUSH
57340: LD_VAR 0 4
57344: ST_TO_ADDR
// end ;
57345: LD_VAR 0 3
57349: RET
// export function ComComplete ( unit , b ) ; var i ; begin
57350: LD_INT 0
57352: PPUSH
57353: PPUSH
// if BuildingStatus ( b ) = bs_build then
57354: LD_VAR 0 2
57358: PPUSH
57359: CALL_OW 461
57363: PUSH
57364: LD_INT 1
57366: EQUAL
57367: IFFALSE 57427
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57369: LD_VAR 0 1
57373: PPUSH
57374: LD_STRING h
57376: PUSH
57377: LD_VAR 0 2
57381: PPUSH
57382: CALL_OW 250
57386: PUSH
57387: LD_VAR 0 2
57391: PPUSH
57392: CALL_OW 251
57396: PUSH
57397: LD_VAR 0 2
57401: PUSH
57402: LD_INT 0
57404: PUSH
57405: LD_INT 0
57407: PUSH
57408: LD_INT 0
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: LIST
57415: LIST
57416: LIST
57417: LIST
57418: LIST
57419: PUSH
57420: EMPTY
57421: LIST
57422: PPUSH
57423: CALL_OW 446
// end ;
57427: LD_VAR 0 3
57431: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57432: LD_INT 0
57434: PPUSH
57435: PPUSH
57436: PPUSH
57437: PPUSH
57438: PPUSH
57439: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57440: LD_VAR 0 1
57444: NOT
57445: PUSH
57446: LD_VAR 0 1
57450: PPUSH
57451: CALL_OW 263
57455: PUSH
57456: LD_INT 2
57458: EQUAL
57459: NOT
57460: OR
57461: IFFALSE 57465
// exit ;
57463: GO 57781
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57465: LD_ADDR_VAR 0 6
57469: PUSH
57470: LD_INT 22
57472: PUSH
57473: LD_VAR 0 1
57477: PPUSH
57478: CALL_OW 255
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: PUSH
57487: LD_INT 2
57489: PUSH
57490: LD_INT 30
57492: PUSH
57493: LD_INT 36
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: PUSH
57500: LD_INT 34
57502: PUSH
57503: LD_INT 31
57505: PUSH
57506: EMPTY
57507: LIST
57508: LIST
57509: PUSH
57510: EMPTY
57511: LIST
57512: LIST
57513: LIST
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: PPUSH
57519: CALL_OW 69
57523: ST_TO_ADDR
// if not tmp then
57524: LD_VAR 0 6
57528: NOT
57529: IFFALSE 57533
// exit ;
57531: GO 57781
// result := [ ] ;
57533: LD_ADDR_VAR 0 2
57537: PUSH
57538: EMPTY
57539: ST_TO_ADDR
// for i in tmp do
57540: LD_ADDR_VAR 0 3
57544: PUSH
57545: LD_VAR 0 6
57549: PUSH
57550: FOR_IN
57551: IFFALSE 57622
// begin t := UnitsInside ( i ) ;
57553: LD_ADDR_VAR 0 4
57557: PUSH
57558: LD_VAR 0 3
57562: PPUSH
57563: CALL_OW 313
57567: ST_TO_ADDR
// if t then
57568: LD_VAR 0 4
57572: IFFALSE 57620
// for j in t do
57574: LD_ADDR_VAR 0 7
57578: PUSH
57579: LD_VAR 0 4
57583: PUSH
57584: FOR_IN
57585: IFFALSE 57618
// result := Insert ( result , result + 1 , j ) ;
57587: LD_ADDR_VAR 0 2
57591: PUSH
57592: LD_VAR 0 2
57596: PPUSH
57597: LD_VAR 0 2
57601: PUSH
57602: LD_INT 1
57604: PLUS
57605: PPUSH
57606: LD_VAR 0 7
57610: PPUSH
57611: CALL_OW 2
57615: ST_TO_ADDR
57616: GO 57584
57618: POP
57619: POP
// end ;
57620: GO 57550
57622: POP
57623: POP
// if not result then
57624: LD_VAR 0 2
57628: NOT
57629: IFFALSE 57633
// exit ;
57631: GO 57781
// mech := result [ 1 ] ;
57633: LD_ADDR_VAR 0 5
57637: PUSH
57638: LD_VAR 0 2
57642: PUSH
57643: LD_INT 1
57645: ARRAY
57646: ST_TO_ADDR
// if result > 1 then
57647: LD_VAR 0 2
57651: PUSH
57652: LD_INT 1
57654: GREATER
57655: IFFALSE 57767
// for i = 2 to result do
57657: LD_ADDR_VAR 0 3
57661: PUSH
57662: DOUBLE
57663: LD_INT 2
57665: DEC
57666: ST_TO_ADDR
57667: LD_VAR 0 2
57671: PUSH
57672: FOR_TO
57673: IFFALSE 57765
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57675: LD_ADDR_VAR 0 4
57679: PUSH
57680: LD_VAR 0 2
57684: PUSH
57685: LD_VAR 0 3
57689: ARRAY
57690: PPUSH
57691: LD_INT 3
57693: PPUSH
57694: CALL_OW 259
57698: PUSH
57699: LD_VAR 0 2
57703: PUSH
57704: LD_VAR 0 3
57708: ARRAY
57709: PPUSH
57710: CALL_OW 432
57714: MINUS
57715: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57716: LD_VAR 0 4
57720: PUSH
57721: LD_VAR 0 5
57725: PPUSH
57726: LD_INT 3
57728: PPUSH
57729: CALL_OW 259
57733: PUSH
57734: LD_VAR 0 5
57738: PPUSH
57739: CALL_OW 432
57743: MINUS
57744: GREATEREQUAL
57745: IFFALSE 57763
// mech := result [ i ] ;
57747: LD_ADDR_VAR 0 5
57751: PUSH
57752: LD_VAR 0 2
57756: PUSH
57757: LD_VAR 0 3
57761: ARRAY
57762: ST_TO_ADDR
// end ;
57763: GO 57672
57765: POP
57766: POP
// ComLinkTo ( vehicle , mech ) ;
57767: LD_VAR 0 1
57771: PPUSH
57772: LD_VAR 0 5
57776: PPUSH
57777: CALL_OW 135
// end ;
57781: LD_VAR 0 2
57785: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57786: LD_INT 0
57788: PPUSH
57789: PPUSH
57790: PPUSH
57791: PPUSH
57792: PPUSH
57793: PPUSH
57794: PPUSH
57795: PPUSH
57796: PPUSH
57797: PPUSH
57798: PPUSH
57799: PPUSH
57800: PPUSH
// result := [ ] ;
57801: LD_ADDR_VAR 0 7
57805: PUSH
57806: EMPTY
57807: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57808: LD_VAR 0 1
57812: PPUSH
57813: CALL_OW 266
57817: PUSH
57818: LD_INT 0
57820: PUSH
57821: LD_INT 1
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: IN
57828: NOT
57829: IFFALSE 57833
// exit ;
57831: GO 59464
// if name then
57833: LD_VAR 0 3
57837: IFFALSE 57853
// SetBName ( base_dep , name ) ;
57839: LD_VAR 0 1
57843: PPUSH
57844: LD_VAR 0 3
57848: PPUSH
57849: CALL_OW 500
// base := GetBase ( base_dep ) ;
57853: LD_ADDR_VAR 0 15
57857: PUSH
57858: LD_VAR 0 1
57862: PPUSH
57863: CALL_OW 274
57867: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57868: LD_ADDR_VAR 0 16
57872: PUSH
57873: LD_VAR 0 1
57877: PPUSH
57878: CALL_OW 255
57882: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57883: LD_ADDR_VAR 0 17
57887: PUSH
57888: LD_VAR 0 1
57892: PPUSH
57893: CALL_OW 248
57897: ST_TO_ADDR
// if sources then
57898: LD_VAR 0 5
57902: IFFALSE 57949
// for i = 1 to 3 do
57904: LD_ADDR_VAR 0 8
57908: PUSH
57909: DOUBLE
57910: LD_INT 1
57912: DEC
57913: ST_TO_ADDR
57914: LD_INT 3
57916: PUSH
57917: FOR_TO
57918: IFFALSE 57947
// AddResourceType ( base , i , sources [ i ] ) ;
57920: LD_VAR 0 15
57924: PPUSH
57925: LD_VAR 0 8
57929: PPUSH
57930: LD_VAR 0 5
57934: PUSH
57935: LD_VAR 0 8
57939: ARRAY
57940: PPUSH
57941: CALL_OW 276
57945: GO 57917
57947: POP
57948: POP
// buildings := GetBaseBuildings ( base , area ) ;
57949: LD_ADDR_VAR 0 18
57953: PUSH
57954: LD_VAR 0 15
57958: PPUSH
57959: LD_VAR 0 2
57963: PPUSH
57964: CALL 57241 0 2
57968: ST_TO_ADDR
// InitHc ;
57969: CALL_OW 19
// InitUc ;
57973: CALL_OW 18
// uc_side := side ;
57977: LD_ADDR_OWVAR 20
57981: PUSH
57982: LD_VAR 0 16
57986: ST_TO_ADDR
// uc_nation := nation ;
57987: LD_ADDR_OWVAR 21
57991: PUSH
57992: LD_VAR 0 17
57996: ST_TO_ADDR
// if buildings then
57997: LD_VAR 0 18
58001: IFFALSE 59323
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58003: LD_ADDR_VAR 0 19
58007: PUSH
58008: LD_VAR 0 18
58012: PPUSH
58013: LD_INT 2
58015: PUSH
58016: LD_INT 30
58018: PUSH
58019: LD_INT 29
58021: PUSH
58022: EMPTY
58023: LIST
58024: LIST
58025: PUSH
58026: LD_INT 30
58028: PUSH
58029: LD_INT 30
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: LIST
58040: PPUSH
58041: CALL_OW 72
58045: ST_TO_ADDR
// if tmp then
58046: LD_VAR 0 19
58050: IFFALSE 58098
// for i in tmp do
58052: LD_ADDR_VAR 0 8
58056: PUSH
58057: LD_VAR 0 19
58061: PUSH
58062: FOR_IN
58063: IFFALSE 58096
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58065: LD_VAR 0 8
58069: PPUSH
58070: CALL_OW 250
58074: PPUSH
58075: LD_VAR 0 8
58079: PPUSH
58080: CALL_OW 251
58084: PPUSH
58085: LD_VAR 0 16
58089: PPUSH
58090: CALL_OW 441
58094: GO 58062
58096: POP
58097: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58098: LD_VAR 0 18
58102: PPUSH
58103: LD_INT 2
58105: PUSH
58106: LD_INT 30
58108: PUSH
58109: LD_INT 32
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: PUSH
58116: LD_INT 30
58118: PUSH
58119: LD_INT 33
58121: PUSH
58122: EMPTY
58123: LIST
58124: LIST
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: LIST
58130: PPUSH
58131: CALL_OW 72
58135: IFFALSE 58223
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58137: LD_ADDR_VAR 0 8
58141: PUSH
58142: LD_VAR 0 18
58146: PPUSH
58147: LD_INT 2
58149: PUSH
58150: LD_INT 30
58152: PUSH
58153: LD_INT 32
58155: PUSH
58156: EMPTY
58157: LIST
58158: LIST
58159: PUSH
58160: LD_INT 30
58162: PUSH
58163: LD_INT 33
58165: PUSH
58166: EMPTY
58167: LIST
58168: LIST
58169: PUSH
58170: EMPTY
58171: LIST
58172: LIST
58173: LIST
58174: PPUSH
58175: CALL_OW 72
58179: PUSH
58180: FOR_IN
58181: IFFALSE 58221
// begin if not GetBWeapon ( i ) then
58183: LD_VAR 0 8
58187: PPUSH
58188: CALL_OW 269
58192: NOT
58193: IFFALSE 58219
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58195: LD_VAR 0 8
58199: PPUSH
58200: LD_VAR 0 8
58204: PPUSH
58205: LD_VAR 0 2
58209: PPUSH
58210: CALL 59469 0 2
58214: PPUSH
58215: CALL_OW 431
// end ;
58219: GO 58180
58221: POP
58222: POP
// end ; for i = 1 to personel do
58223: LD_ADDR_VAR 0 8
58227: PUSH
58228: DOUBLE
58229: LD_INT 1
58231: DEC
58232: ST_TO_ADDR
58233: LD_VAR 0 6
58237: PUSH
58238: FOR_TO
58239: IFFALSE 59303
// begin if i > 4 then
58241: LD_VAR 0 8
58245: PUSH
58246: LD_INT 4
58248: GREATER
58249: IFFALSE 58253
// break ;
58251: GO 59303
// case i of 1 :
58253: LD_VAR 0 8
58257: PUSH
58258: LD_INT 1
58260: DOUBLE
58261: EQUAL
58262: IFTRUE 58266
58264: GO 58346
58266: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58267: LD_ADDR_VAR 0 12
58271: PUSH
58272: LD_VAR 0 18
58276: PPUSH
58277: LD_INT 22
58279: PUSH
58280: LD_VAR 0 16
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: LD_INT 58
58291: PUSH
58292: EMPTY
58293: LIST
58294: PUSH
58295: LD_INT 2
58297: PUSH
58298: LD_INT 30
58300: PUSH
58301: LD_INT 32
58303: PUSH
58304: EMPTY
58305: LIST
58306: LIST
58307: PUSH
58308: LD_INT 30
58310: PUSH
58311: LD_INT 4
58313: PUSH
58314: EMPTY
58315: LIST
58316: LIST
58317: PUSH
58318: LD_INT 30
58320: PUSH
58321: LD_INT 5
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: PUSH
58328: EMPTY
58329: LIST
58330: LIST
58331: LIST
58332: LIST
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: LIST
58338: PPUSH
58339: CALL_OW 72
58343: ST_TO_ADDR
58344: GO 58568
58346: LD_INT 2
58348: DOUBLE
58349: EQUAL
58350: IFTRUE 58354
58352: GO 58416
58354: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58355: LD_ADDR_VAR 0 12
58359: PUSH
58360: LD_VAR 0 18
58364: PPUSH
58365: LD_INT 22
58367: PUSH
58368: LD_VAR 0 16
58372: PUSH
58373: EMPTY
58374: LIST
58375: LIST
58376: PUSH
58377: LD_INT 2
58379: PUSH
58380: LD_INT 30
58382: PUSH
58383: LD_INT 0
58385: PUSH
58386: EMPTY
58387: LIST
58388: LIST
58389: PUSH
58390: LD_INT 30
58392: PUSH
58393: LD_INT 1
58395: PUSH
58396: EMPTY
58397: LIST
58398: LIST
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: LIST
58404: PUSH
58405: EMPTY
58406: LIST
58407: LIST
58408: PPUSH
58409: CALL_OW 72
58413: ST_TO_ADDR
58414: GO 58568
58416: LD_INT 3
58418: DOUBLE
58419: EQUAL
58420: IFTRUE 58424
58422: GO 58486
58424: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58425: LD_ADDR_VAR 0 12
58429: PUSH
58430: LD_VAR 0 18
58434: PPUSH
58435: LD_INT 22
58437: PUSH
58438: LD_VAR 0 16
58442: PUSH
58443: EMPTY
58444: LIST
58445: LIST
58446: PUSH
58447: LD_INT 2
58449: PUSH
58450: LD_INT 30
58452: PUSH
58453: LD_INT 2
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: PUSH
58460: LD_INT 30
58462: PUSH
58463: LD_INT 3
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: LIST
58474: PUSH
58475: EMPTY
58476: LIST
58477: LIST
58478: PPUSH
58479: CALL_OW 72
58483: ST_TO_ADDR
58484: GO 58568
58486: LD_INT 4
58488: DOUBLE
58489: EQUAL
58490: IFTRUE 58494
58492: GO 58567
58494: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58495: LD_ADDR_VAR 0 12
58499: PUSH
58500: LD_VAR 0 18
58504: PPUSH
58505: LD_INT 22
58507: PUSH
58508: LD_VAR 0 16
58512: PUSH
58513: EMPTY
58514: LIST
58515: LIST
58516: PUSH
58517: LD_INT 2
58519: PUSH
58520: LD_INT 30
58522: PUSH
58523: LD_INT 6
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: PUSH
58530: LD_INT 30
58532: PUSH
58533: LD_INT 7
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PUSH
58540: LD_INT 30
58542: PUSH
58543: LD_INT 8
58545: PUSH
58546: EMPTY
58547: LIST
58548: LIST
58549: PUSH
58550: EMPTY
58551: LIST
58552: LIST
58553: LIST
58554: LIST
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: PPUSH
58560: CALL_OW 72
58564: ST_TO_ADDR
58565: GO 58568
58567: POP
// if i = 1 then
58568: LD_VAR 0 8
58572: PUSH
58573: LD_INT 1
58575: EQUAL
58576: IFFALSE 58687
// begin tmp := [ ] ;
58578: LD_ADDR_VAR 0 19
58582: PUSH
58583: EMPTY
58584: ST_TO_ADDR
// for j in f do
58585: LD_ADDR_VAR 0 9
58589: PUSH
58590: LD_VAR 0 12
58594: PUSH
58595: FOR_IN
58596: IFFALSE 58669
// if GetBType ( j ) = b_bunker then
58598: LD_VAR 0 9
58602: PPUSH
58603: CALL_OW 266
58607: PUSH
58608: LD_INT 32
58610: EQUAL
58611: IFFALSE 58638
// tmp := Insert ( tmp , 1 , j ) else
58613: LD_ADDR_VAR 0 19
58617: PUSH
58618: LD_VAR 0 19
58622: PPUSH
58623: LD_INT 1
58625: PPUSH
58626: LD_VAR 0 9
58630: PPUSH
58631: CALL_OW 2
58635: ST_TO_ADDR
58636: GO 58667
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58638: LD_ADDR_VAR 0 19
58642: PUSH
58643: LD_VAR 0 19
58647: PPUSH
58648: LD_VAR 0 19
58652: PUSH
58653: LD_INT 1
58655: PLUS
58656: PPUSH
58657: LD_VAR 0 9
58661: PPUSH
58662: CALL_OW 2
58666: ST_TO_ADDR
58667: GO 58595
58669: POP
58670: POP
// if tmp then
58671: LD_VAR 0 19
58675: IFFALSE 58687
// f := tmp ;
58677: LD_ADDR_VAR 0 12
58681: PUSH
58682: LD_VAR 0 19
58686: ST_TO_ADDR
// end ; x := personel [ i ] ;
58687: LD_ADDR_VAR 0 13
58691: PUSH
58692: LD_VAR 0 6
58696: PUSH
58697: LD_VAR 0 8
58701: ARRAY
58702: ST_TO_ADDR
// if x = - 1 then
58703: LD_VAR 0 13
58707: PUSH
58708: LD_INT 1
58710: NEG
58711: EQUAL
58712: IFFALSE 58921
// begin for j in f do
58714: LD_ADDR_VAR 0 9
58718: PUSH
58719: LD_VAR 0 12
58723: PUSH
58724: FOR_IN
58725: IFFALSE 58917
// repeat InitHc ;
58727: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58731: LD_VAR 0 9
58735: PPUSH
58736: CALL_OW 266
58740: PUSH
58741: LD_INT 5
58743: EQUAL
58744: IFFALSE 58814
// begin if UnitsInside ( j ) < 3 then
58746: LD_VAR 0 9
58750: PPUSH
58751: CALL_OW 313
58755: PUSH
58756: LD_INT 3
58758: LESS
58759: IFFALSE 58795
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58761: LD_INT 0
58763: PPUSH
58764: LD_INT 5
58766: PUSH
58767: LD_INT 8
58769: PUSH
58770: LD_INT 9
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: LIST
58777: PUSH
58778: LD_VAR 0 17
58782: ARRAY
58783: PPUSH
58784: LD_VAR 0 4
58788: PPUSH
58789: CALL_OW 380
58793: GO 58812
// PrepareHuman ( false , i , skill ) ;
58795: LD_INT 0
58797: PPUSH
58798: LD_VAR 0 8
58802: PPUSH
58803: LD_VAR 0 4
58807: PPUSH
58808: CALL_OW 380
// end else
58812: GO 58831
// PrepareHuman ( false , i , skill ) ;
58814: LD_INT 0
58816: PPUSH
58817: LD_VAR 0 8
58821: PPUSH
58822: LD_VAR 0 4
58826: PPUSH
58827: CALL_OW 380
// un := CreateHuman ;
58831: LD_ADDR_VAR 0 14
58835: PUSH
58836: CALL_OW 44
58840: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58841: LD_ADDR_VAR 0 7
58845: PUSH
58846: LD_VAR 0 7
58850: PPUSH
58851: LD_INT 1
58853: PPUSH
58854: LD_VAR 0 14
58858: PPUSH
58859: CALL_OW 2
58863: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58864: LD_VAR 0 14
58868: PPUSH
58869: LD_VAR 0 9
58873: PPUSH
58874: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58878: LD_VAR 0 9
58882: PPUSH
58883: CALL_OW 313
58887: PUSH
58888: LD_INT 6
58890: EQUAL
58891: PUSH
58892: LD_VAR 0 9
58896: PPUSH
58897: CALL_OW 266
58901: PUSH
58902: LD_INT 32
58904: PUSH
58905: LD_INT 31
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: IN
58912: OR
58913: IFFALSE 58727
58915: GO 58724
58917: POP
58918: POP
// end else
58919: GO 59301
// for j = 1 to x do
58921: LD_ADDR_VAR 0 9
58925: PUSH
58926: DOUBLE
58927: LD_INT 1
58929: DEC
58930: ST_TO_ADDR
58931: LD_VAR 0 13
58935: PUSH
58936: FOR_TO
58937: IFFALSE 59299
// begin InitHc ;
58939: CALL_OW 19
// if not f then
58943: LD_VAR 0 12
58947: NOT
58948: IFFALSE 59037
// begin PrepareHuman ( false , i , skill ) ;
58950: LD_INT 0
58952: PPUSH
58953: LD_VAR 0 8
58957: PPUSH
58958: LD_VAR 0 4
58962: PPUSH
58963: CALL_OW 380
// un := CreateHuman ;
58967: LD_ADDR_VAR 0 14
58971: PUSH
58972: CALL_OW 44
58976: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58977: LD_ADDR_VAR 0 7
58981: PUSH
58982: LD_VAR 0 7
58986: PPUSH
58987: LD_INT 1
58989: PPUSH
58990: LD_VAR 0 14
58994: PPUSH
58995: CALL_OW 2
58999: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59000: LD_VAR 0 14
59004: PPUSH
59005: LD_VAR 0 1
59009: PPUSH
59010: CALL_OW 250
59014: PPUSH
59015: LD_VAR 0 1
59019: PPUSH
59020: CALL_OW 251
59024: PPUSH
59025: LD_INT 10
59027: PPUSH
59028: LD_INT 0
59030: PPUSH
59031: CALL_OW 50
// continue ;
59035: GO 58936
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59037: LD_VAR 0 12
59041: PUSH
59042: LD_INT 1
59044: ARRAY
59045: PPUSH
59046: CALL_OW 313
59050: PUSH
59051: LD_VAR 0 12
59055: PUSH
59056: LD_INT 1
59058: ARRAY
59059: PPUSH
59060: CALL_OW 266
59064: PUSH
59065: LD_INT 32
59067: PUSH
59068: LD_INT 31
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: IN
59075: AND
59076: PUSH
59077: LD_VAR 0 12
59081: PUSH
59082: LD_INT 1
59084: ARRAY
59085: PPUSH
59086: CALL_OW 313
59090: PUSH
59091: LD_INT 6
59093: EQUAL
59094: OR
59095: IFFALSE 59115
// f := Delete ( f , 1 ) ;
59097: LD_ADDR_VAR 0 12
59101: PUSH
59102: LD_VAR 0 12
59106: PPUSH
59107: LD_INT 1
59109: PPUSH
59110: CALL_OW 3
59114: ST_TO_ADDR
// if not f then
59115: LD_VAR 0 12
59119: NOT
59120: IFFALSE 59138
// begin x := x + 2 ;
59122: LD_ADDR_VAR 0 13
59126: PUSH
59127: LD_VAR 0 13
59131: PUSH
59132: LD_INT 2
59134: PLUS
59135: ST_TO_ADDR
// continue ;
59136: GO 58936
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59138: LD_VAR 0 12
59142: PUSH
59143: LD_INT 1
59145: ARRAY
59146: PPUSH
59147: CALL_OW 266
59151: PUSH
59152: LD_INT 5
59154: EQUAL
59155: IFFALSE 59229
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59157: LD_VAR 0 12
59161: PUSH
59162: LD_INT 1
59164: ARRAY
59165: PPUSH
59166: CALL_OW 313
59170: PUSH
59171: LD_INT 3
59173: LESS
59174: IFFALSE 59210
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59176: LD_INT 0
59178: PPUSH
59179: LD_INT 5
59181: PUSH
59182: LD_INT 8
59184: PUSH
59185: LD_INT 9
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: PUSH
59193: LD_VAR 0 17
59197: ARRAY
59198: PPUSH
59199: LD_VAR 0 4
59203: PPUSH
59204: CALL_OW 380
59208: GO 59227
// PrepareHuman ( false , i , skill ) ;
59210: LD_INT 0
59212: PPUSH
59213: LD_VAR 0 8
59217: PPUSH
59218: LD_VAR 0 4
59222: PPUSH
59223: CALL_OW 380
// end else
59227: GO 59246
// PrepareHuman ( false , i , skill ) ;
59229: LD_INT 0
59231: PPUSH
59232: LD_VAR 0 8
59236: PPUSH
59237: LD_VAR 0 4
59241: PPUSH
59242: CALL_OW 380
// un := CreateHuman ;
59246: LD_ADDR_VAR 0 14
59250: PUSH
59251: CALL_OW 44
59255: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59256: LD_ADDR_VAR 0 7
59260: PUSH
59261: LD_VAR 0 7
59265: PPUSH
59266: LD_INT 1
59268: PPUSH
59269: LD_VAR 0 14
59273: PPUSH
59274: CALL_OW 2
59278: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59279: LD_VAR 0 14
59283: PPUSH
59284: LD_VAR 0 12
59288: PUSH
59289: LD_INT 1
59291: ARRAY
59292: PPUSH
59293: CALL_OW 52
// end ;
59297: GO 58936
59299: POP
59300: POP
// end ;
59301: GO 58238
59303: POP
59304: POP
// result := result ^ buildings ;
59305: LD_ADDR_VAR 0 7
59309: PUSH
59310: LD_VAR 0 7
59314: PUSH
59315: LD_VAR 0 18
59319: ADD
59320: ST_TO_ADDR
// end else
59321: GO 59464
// begin for i = 1 to personel do
59323: LD_ADDR_VAR 0 8
59327: PUSH
59328: DOUBLE
59329: LD_INT 1
59331: DEC
59332: ST_TO_ADDR
59333: LD_VAR 0 6
59337: PUSH
59338: FOR_TO
59339: IFFALSE 59462
// begin if i > 4 then
59341: LD_VAR 0 8
59345: PUSH
59346: LD_INT 4
59348: GREATER
59349: IFFALSE 59353
// break ;
59351: GO 59462
// x := personel [ i ] ;
59353: LD_ADDR_VAR 0 13
59357: PUSH
59358: LD_VAR 0 6
59362: PUSH
59363: LD_VAR 0 8
59367: ARRAY
59368: ST_TO_ADDR
// if x = - 1 then
59369: LD_VAR 0 13
59373: PUSH
59374: LD_INT 1
59376: NEG
59377: EQUAL
59378: IFFALSE 59382
// continue ;
59380: GO 59338
// PrepareHuman ( false , i , skill ) ;
59382: LD_INT 0
59384: PPUSH
59385: LD_VAR 0 8
59389: PPUSH
59390: LD_VAR 0 4
59394: PPUSH
59395: CALL_OW 380
// un := CreateHuman ;
59399: LD_ADDR_VAR 0 14
59403: PUSH
59404: CALL_OW 44
59408: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59409: LD_VAR 0 14
59413: PPUSH
59414: LD_VAR 0 1
59418: PPUSH
59419: CALL_OW 250
59423: PPUSH
59424: LD_VAR 0 1
59428: PPUSH
59429: CALL_OW 251
59433: PPUSH
59434: LD_INT 10
59436: PPUSH
59437: LD_INT 0
59439: PPUSH
59440: CALL_OW 50
// result := result ^ un ;
59444: LD_ADDR_VAR 0 7
59448: PUSH
59449: LD_VAR 0 7
59453: PUSH
59454: LD_VAR 0 14
59458: ADD
59459: ST_TO_ADDR
// end ;
59460: GO 59338
59462: POP
59463: POP
// end ; end ;
59464: LD_VAR 0 7
59468: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59469: LD_INT 0
59471: PPUSH
59472: PPUSH
59473: PPUSH
59474: PPUSH
59475: PPUSH
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
59480: PPUSH
59481: PPUSH
59482: PPUSH
59483: PPUSH
59484: PPUSH
59485: PPUSH
59486: PPUSH
// result := false ;
59487: LD_ADDR_VAR 0 3
59491: PUSH
59492: LD_INT 0
59494: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59495: LD_VAR 0 1
59499: NOT
59500: PUSH
59501: LD_VAR 0 1
59505: PPUSH
59506: CALL_OW 266
59510: PUSH
59511: LD_INT 32
59513: PUSH
59514: LD_INT 33
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: IN
59521: NOT
59522: OR
59523: IFFALSE 59527
// exit ;
59525: GO 60663
// nat := GetNation ( tower ) ;
59527: LD_ADDR_VAR 0 12
59531: PUSH
59532: LD_VAR 0 1
59536: PPUSH
59537: CALL_OW 248
59541: ST_TO_ADDR
// side := GetSide ( tower ) ;
59542: LD_ADDR_VAR 0 16
59546: PUSH
59547: LD_VAR 0 1
59551: PPUSH
59552: CALL_OW 255
59556: ST_TO_ADDR
// x := GetX ( tower ) ;
59557: LD_ADDR_VAR 0 10
59561: PUSH
59562: LD_VAR 0 1
59566: PPUSH
59567: CALL_OW 250
59571: ST_TO_ADDR
// y := GetY ( tower ) ;
59572: LD_ADDR_VAR 0 11
59576: PUSH
59577: LD_VAR 0 1
59581: PPUSH
59582: CALL_OW 251
59586: ST_TO_ADDR
// if not x or not y then
59587: LD_VAR 0 10
59591: NOT
59592: PUSH
59593: LD_VAR 0 11
59597: NOT
59598: OR
59599: IFFALSE 59603
// exit ;
59601: GO 60663
// weapon := 0 ;
59603: LD_ADDR_VAR 0 18
59607: PUSH
59608: LD_INT 0
59610: ST_TO_ADDR
// fac_list := [ ] ;
59611: LD_ADDR_VAR 0 17
59615: PUSH
59616: EMPTY
59617: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59618: LD_ADDR_VAR 0 6
59622: PUSH
59623: LD_VAR 0 1
59627: PPUSH
59628: CALL_OW 274
59632: PPUSH
59633: LD_VAR 0 2
59637: PPUSH
59638: CALL 57241 0 2
59642: PPUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 3
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PPUSH
59653: CALL_OW 72
59657: ST_TO_ADDR
// if not factories then
59658: LD_VAR 0 6
59662: NOT
59663: IFFALSE 59667
// exit ;
59665: GO 60663
// for i in factories do
59667: LD_ADDR_VAR 0 8
59671: PUSH
59672: LD_VAR 0 6
59676: PUSH
59677: FOR_IN
59678: IFFALSE 59703
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59680: LD_ADDR_VAR 0 17
59684: PUSH
59685: LD_VAR 0 17
59689: PUSH
59690: LD_VAR 0 8
59694: PPUSH
59695: CALL_OW 478
59699: UNION
59700: ST_TO_ADDR
59701: GO 59677
59703: POP
59704: POP
// if not fac_list then
59705: LD_VAR 0 17
59709: NOT
59710: IFFALSE 59714
// exit ;
59712: GO 60663
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59714: LD_ADDR_VAR 0 5
59718: PUSH
59719: LD_INT 4
59721: PUSH
59722: LD_INT 5
59724: PUSH
59725: LD_INT 9
59727: PUSH
59728: LD_INT 10
59730: PUSH
59731: LD_INT 6
59733: PUSH
59734: LD_INT 7
59736: PUSH
59737: LD_INT 11
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: PUSH
59749: LD_INT 27
59751: PUSH
59752: LD_INT 28
59754: PUSH
59755: LD_INT 26
59757: PUSH
59758: LD_INT 30
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: LIST
59765: LIST
59766: PUSH
59767: LD_INT 43
59769: PUSH
59770: LD_INT 44
59772: PUSH
59773: LD_INT 46
59775: PUSH
59776: LD_INT 45
59778: PUSH
59779: LD_INT 47
59781: PUSH
59782: LD_INT 49
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: LIST
59789: LIST
59790: LIST
59791: LIST
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: LIST
59797: PUSH
59798: LD_VAR 0 12
59802: ARRAY
59803: ST_TO_ADDR
// for i in list do
59804: LD_ADDR_VAR 0 8
59808: PUSH
59809: LD_VAR 0 5
59813: PUSH
59814: FOR_IN
59815: IFFALSE 59848
// if not i in fac_list then
59817: LD_VAR 0 8
59821: PUSH
59822: LD_VAR 0 17
59826: IN
59827: NOT
59828: IFFALSE 59846
// list := list diff i ;
59830: LD_ADDR_VAR 0 5
59834: PUSH
59835: LD_VAR 0 5
59839: PUSH
59840: LD_VAR 0 8
59844: DIFF
59845: ST_TO_ADDR
59846: GO 59814
59848: POP
59849: POP
// if not list then
59850: LD_VAR 0 5
59854: NOT
59855: IFFALSE 59859
// exit ;
59857: GO 60663
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59859: LD_VAR 0 12
59863: PUSH
59864: LD_INT 3
59866: EQUAL
59867: PUSH
59868: LD_INT 49
59870: PUSH
59871: LD_VAR 0 5
59875: IN
59876: AND
59877: PUSH
59878: LD_INT 31
59880: PPUSH
59881: LD_VAR 0 16
59885: PPUSH
59886: CALL_OW 321
59890: PUSH
59891: LD_INT 2
59893: EQUAL
59894: AND
59895: IFFALSE 59955
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59897: LD_INT 22
59899: PUSH
59900: LD_VAR 0 16
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: LD_INT 35
59911: PUSH
59912: LD_INT 49
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 91
59921: PUSH
59922: LD_VAR 0 1
59926: PUSH
59927: LD_INT 10
59929: PUSH
59930: EMPTY
59931: LIST
59932: LIST
59933: LIST
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: LIST
59939: PPUSH
59940: CALL_OW 69
59944: NOT
59945: IFFALSE 59955
// weapon := ru_time_lapser ;
59947: LD_ADDR_VAR 0 18
59951: PUSH
59952: LD_INT 49
59954: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59955: LD_VAR 0 12
59959: PUSH
59960: LD_INT 1
59962: PUSH
59963: LD_INT 2
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: IN
59970: PUSH
59971: LD_INT 11
59973: PUSH
59974: LD_VAR 0 5
59978: IN
59979: PUSH
59980: LD_INT 30
59982: PUSH
59983: LD_VAR 0 5
59987: IN
59988: OR
59989: AND
59990: PUSH
59991: LD_INT 6
59993: PPUSH
59994: LD_VAR 0 16
59998: PPUSH
59999: CALL_OW 321
60003: PUSH
60004: LD_INT 2
60006: EQUAL
60007: AND
60008: IFFALSE 60173
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60010: LD_INT 22
60012: PUSH
60013: LD_VAR 0 16
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PUSH
60022: LD_INT 2
60024: PUSH
60025: LD_INT 35
60027: PUSH
60028: LD_INT 11
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: PUSH
60035: LD_INT 35
60037: PUSH
60038: LD_INT 30
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: PUSH
60045: EMPTY
60046: LIST
60047: LIST
60048: LIST
60049: PUSH
60050: LD_INT 91
60052: PUSH
60053: LD_VAR 0 1
60057: PUSH
60058: LD_INT 18
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: LIST
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: LIST
60070: PPUSH
60071: CALL_OW 69
60075: NOT
60076: PUSH
60077: LD_INT 22
60079: PUSH
60080: LD_VAR 0 16
60084: PUSH
60085: EMPTY
60086: LIST
60087: LIST
60088: PUSH
60089: LD_INT 2
60091: PUSH
60092: LD_INT 30
60094: PUSH
60095: LD_INT 32
60097: PUSH
60098: EMPTY
60099: LIST
60100: LIST
60101: PUSH
60102: LD_INT 30
60104: PUSH
60105: LD_INT 33
60107: PUSH
60108: EMPTY
60109: LIST
60110: LIST
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: LIST
60116: PUSH
60117: LD_INT 91
60119: PUSH
60120: LD_VAR 0 1
60124: PUSH
60125: LD_INT 12
60127: PUSH
60128: EMPTY
60129: LIST
60130: LIST
60131: LIST
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: LIST
60137: PUSH
60138: EMPTY
60139: LIST
60140: PPUSH
60141: CALL_OW 69
60145: PUSH
60146: LD_INT 2
60148: GREATER
60149: AND
60150: IFFALSE 60173
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60152: LD_ADDR_VAR 0 18
60156: PUSH
60157: LD_INT 11
60159: PUSH
60160: LD_INT 30
60162: PUSH
60163: EMPTY
60164: LIST
60165: LIST
60166: PUSH
60167: LD_VAR 0 12
60171: ARRAY
60172: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60173: LD_VAR 0 18
60177: NOT
60178: PUSH
60179: LD_INT 40
60181: PPUSH
60182: LD_VAR 0 16
60186: PPUSH
60187: CALL_OW 321
60191: PUSH
60192: LD_INT 2
60194: EQUAL
60195: AND
60196: PUSH
60197: LD_INT 7
60199: PUSH
60200: LD_VAR 0 5
60204: IN
60205: PUSH
60206: LD_INT 28
60208: PUSH
60209: LD_VAR 0 5
60213: IN
60214: OR
60215: PUSH
60216: LD_INT 45
60218: PUSH
60219: LD_VAR 0 5
60223: IN
60224: OR
60225: AND
60226: IFFALSE 60480
// begin hex := GetHexInfo ( x , y ) ;
60228: LD_ADDR_VAR 0 4
60232: PUSH
60233: LD_VAR 0 10
60237: PPUSH
60238: LD_VAR 0 11
60242: PPUSH
60243: CALL_OW 546
60247: ST_TO_ADDR
// if hex [ 1 ] then
60248: LD_VAR 0 4
60252: PUSH
60253: LD_INT 1
60255: ARRAY
60256: IFFALSE 60260
// exit ;
60258: GO 60663
// height := hex [ 2 ] ;
60260: LD_ADDR_VAR 0 15
60264: PUSH
60265: LD_VAR 0 4
60269: PUSH
60270: LD_INT 2
60272: ARRAY
60273: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60274: LD_ADDR_VAR 0 14
60278: PUSH
60279: LD_INT 0
60281: PUSH
60282: LD_INT 2
60284: PUSH
60285: LD_INT 3
60287: PUSH
60288: LD_INT 5
60290: PUSH
60291: EMPTY
60292: LIST
60293: LIST
60294: LIST
60295: LIST
60296: ST_TO_ADDR
// for i in tmp do
60297: LD_ADDR_VAR 0 8
60301: PUSH
60302: LD_VAR 0 14
60306: PUSH
60307: FOR_IN
60308: IFFALSE 60478
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60310: LD_ADDR_VAR 0 9
60314: PUSH
60315: LD_VAR 0 10
60319: PPUSH
60320: LD_VAR 0 8
60324: PPUSH
60325: LD_INT 5
60327: PPUSH
60328: CALL_OW 272
60332: PUSH
60333: LD_VAR 0 11
60337: PPUSH
60338: LD_VAR 0 8
60342: PPUSH
60343: LD_INT 5
60345: PPUSH
60346: CALL_OW 273
60350: PUSH
60351: EMPTY
60352: LIST
60353: LIST
60354: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60355: LD_VAR 0 9
60359: PUSH
60360: LD_INT 1
60362: ARRAY
60363: PPUSH
60364: LD_VAR 0 9
60368: PUSH
60369: LD_INT 2
60371: ARRAY
60372: PPUSH
60373: CALL_OW 488
60377: IFFALSE 60476
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60379: LD_ADDR_VAR 0 4
60383: PUSH
60384: LD_VAR 0 9
60388: PUSH
60389: LD_INT 1
60391: ARRAY
60392: PPUSH
60393: LD_VAR 0 9
60397: PUSH
60398: LD_INT 2
60400: ARRAY
60401: PPUSH
60402: CALL_OW 546
60406: ST_TO_ADDR
// if hex [ 1 ] then
60407: LD_VAR 0 4
60411: PUSH
60412: LD_INT 1
60414: ARRAY
60415: IFFALSE 60419
// continue ;
60417: GO 60307
// h := hex [ 2 ] ;
60419: LD_ADDR_VAR 0 13
60423: PUSH
60424: LD_VAR 0 4
60428: PUSH
60429: LD_INT 2
60431: ARRAY
60432: ST_TO_ADDR
// if h + 7 < height then
60433: LD_VAR 0 13
60437: PUSH
60438: LD_INT 7
60440: PLUS
60441: PUSH
60442: LD_VAR 0 15
60446: LESS
60447: IFFALSE 60476
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60449: LD_ADDR_VAR 0 18
60453: PUSH
60454: LD_INT 7
60456: PUSH
60457: LD_INT 28
60459: PUSH
60460: LD_INT 45
60462: PUSH
60463: EMPTY
60464: LIST
60465: LIST
60466: LIST
60467: PUSH
60468: LD_VAR 0 12
60472: ARRAY
60473: ST_TO_ADDR
// break ;
60474: GO 60478
// end ; end ; end ;
60476: GO 60307
60478: POP
60479: POP
// end ; if not weapon then
60480: LD_VAR 0 18
60484: NOT
60485: IFFALSE 60545
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60487: LD_ADDR_VAR 0 5
60491: PUSH
60492: LD_VAR 0 5
60496: PUSH
60497: LD_INT 11
60499: PUSH
60500: LD_INT 30
60502: PUSH
60503: LD_INT 49
60505: PUSH
60506: EMPTY
60507: LIST
60508: LIST
60509: LIST
60510: DIFF
60511: ST_TO_ADDR
// if not list then
60512: LD_VAR 0 5
60516: NOT
60517: IFFALSE 60521
// exit ;
60519: GO 60663
// weapon := list [ rand ( 1 , list ) ] ;
60521: LD_ADDR_VAR 0 18
60525: PUSH
60526: LD_VAR 0 5
60530: PUSH
60531: LD_INT 1
60533: PPUSH
60534: LD_VAR 0 5
60538: PPUSH
60539: CALL_OW 12
60543: ARRAY
60544: ST_TO_ADDR
// end ; if weapon then
60545: LD_VAR 0 18
60549: IFFALSE 60663
// begin tmp := CostOfWeapon ( weapon ) ;
60551: LD_ADDR_VAR 0 14
60555: PUSH
60556: LD_VAR 0 18
60560: PPUSH
60561: CALL_OW 451
60565: ST_TO_ADDR
// j := GetBase ( tower ) ;
60566: LD_ADDR_VAR 0 9
60570: PUSH
60571: LD_VAR 0 1
60575: PPUSH
60576: CALL_OW 274
60580: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60581: LD_VAR 0 9
60585: PPUSH
60586: LD_INT 1
60588: PPUSH
60589: CALL_OW 275
60593: PUSH
60594: LD_VAR 0 14
60598: PUSH
60599: LD_INT 1
60601: ARRAY
60602: GREATEREQUAL
60603: PUSH
60604: LD_VAR 0 9
60608: PPUSH
60609: LD_INT 2
60611: PPUSH
60612: CALL_OW 275
60616: PUSH
60617: LD_VAR 0 14
60621: PUSH
60622: LD_INT 2
60624: ARRAY
60625: GREATEREQUAL
60626: AND
60627: PUSH
60628: LD_VAR 0 9
60632: PPUSH
60633: LD_INT 3
60635: PPUSH
60636: CALL_OW 275
60640: PUSH
60641: LD_VAR 0 14
60645: PUSH
60646: LD_INT 3
60648: ARRAY
60649: GREATEREQUAL
60650: AND
60651: IFFALSE 60663
// result := weapon ;
60653: LD_ADDR_VAR 0 3
60657: PUSH
60658: LD_VAR 0 18
60662: ST_TO_ADDR
// end ; end ;
60663: LD_VAR 0 3
60667: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60668: LD_INT 0
60670: PPUSH
60671: PPUSH
// result := true ;
60672: LD_ADDR_VAR 0 3
60676: PUSH
60677: LD_INT 1
60679: ST_TO_ADDR
// if array1 = array2 then
60680: LD_VAR 0 1
60684: PUSH
60685: LD_VAR 0 2
60689: EQUAL
60690: IFFALSE 60750
// begin for i = 1 to array1 do
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: DOUBLE
60698: LD_INT 1
60700: DEC
60701: ST_TO_ADDR
60702: LD_VAR 0 1
60706: PUSH
60707: FOR_TO
60708: IFFALSE 60746
// if array1 [ i ] <> array2 [ i ] then
60710: LD_VAR 0 1
60714: PUSH
60715: LD_VAR 0 4
60719: ARRAY
60720: PUSH
60721: LD_VAR 0 2
60725: PUSH
60726: LD_VAR 0 4
60730: ARRAY
60731: NONEQUAL
60732: IFFALSE 60744
// begin result := false ;
60734: LD_ADDR_VAR 0 3
60738: PUSH
60739: LD_INT 0
60741: ST_TO_ADDR
// break ;
60742: GO 60746
// end ;
60744: GO 60707
60746: POP
60747: POP
// end else
60748: GO 60758
// result := false ;
60750: LD_ADDR_VAR 0 3
60754: PUSH
60755: LD_INT 0
60757: ST_TO_ADDR
// end ;
60758: LD_VAR 0 3
60762: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60763: LD_INT 0
60765: PPUSH
60766: PPUSH
60767: PPUSH
// pom := GetBase ( fac ) ;
60768: LD_ADDR_VAR 0 5
60772: PUSH
60773: LD_VAR 0 1
60777: PPUSH
60778: CALL_OW 274
60782: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60783: LD_ADDR_VAR 0 4
60787: PUSH
60788: LD_VAR 0 2
60792: PUSH
60793: LD_INT 1
60795: ARRAY
60796: PPUSH
60797: LD_VAR 0 2
60801: PUSH
60802: LD_INT 2
60804: ARRAY
60805: PPUSH
60806: LD_VAR 0 2
60810: PUSH
60811: LD_INT 3
60813: ARRAY
60814: PPUSH
60815: LD_VAR 0 2
60819: PUSH
60820: LD_INT 4
60822: ARRAY
60823: PPUSH
60824: CALL_OW 449
60828: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60829: LD_ADDR_VAR 0 3
60833: PUSH
60834: LD_VAR 0 5
60838: PPUSH
60839: LD_INT 1
60841: PPUSH
60842: CALL_OW 275
60846: PUSH
60847: LD_VAR 0 4
60851: PUSH
60852: LD_INT 1
60854: ARRAY
60855: GREATEREQUAL
60856: PUSH
60857: LD_VAR 0 5
60861: PPUSH
60862: LD_INT 2
60864: PPUSH
60865: CALL_OW 275
60869: PUSH
60870: LD_VAR 0 4
60874: PUSH
60875: LD_INT 2
60877: ARRAY
60878: GREATEREQUAL
60879: AND
60880: PUSH
60881: LD_VAR 0 5
60885: PPUSH
60886: LD_INT 3
60888: PPUSH
60889: CALL_OW 275
60893: PUSH
60894: LD_VAR 0 4
60898: PUSH
60899: LD_INT 3
60901: ARRAY
60902: GREATEREQUAL
60903: AND
60904: ST_TO_ADDR
// end ;
60905: LD_VAR 0 3
60909: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60910: LD_INT 0
60912: PPUSH
60913: PPUSH
60914: PPUSH
60915: PPUSH
// pom := GetBase ( building ) ;
60916: LD_ADDR_VAR 0 3
60920: PUSH
60921: LD_VAR 0 1
60925: PPUSH
60926: CALL_OW 274
60930: ST_TO_ADDR
// if not pom then
60931: LD_VAR 0 3
60935: NOT
60936: IFFALSE 60940
// exit ;
60938: GO 61110
// btype := GetBType ( building ) ;
60940: LD_ADDR_VAR 0 5
60944: PUSH
60945: LD_VAR 0 1
60949: PPUSH
60950: CALL_OW 266
60954: ST_TO_ADDR
// if btype = b_armoury then
60955: LD_VAR 0 5
60959: PUSH
60960: LD_INT 4
60962: EQUAL
60963: IFFALSE 60973
// btype := b_barracks ;
60965: LD_ADDR_VAR 0 5
60969: PUSH
60970: LD_INT 5
60972: ST_TO_ADDR
// if btype = b_depot then
60973: LD_VAR 0 5
60977: PUSH
60978: LD_INT 0
60980: EQUAL
60981: IFFALSE 60991
// btype := b_warehouse ;
60983: LD_ADDR_VAR 0 5
60987: PUSH
60988: LD_INT 1
60990: ST_TO_ADDR
// if btype = b_workshop then
60991: LD_VAR 0 5
60995: PUSH
60996: LD_INT 2
60998: EQUAL
60999: IFFALSE 61009
// btype := b_factory ;
61001: LD_ADDR_VAR 0 5
61005: PUSH
61006: LD_INT 3
61008: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61009: LD_ADDR_VAR 0 4
61013: PUSH
61014: LD_VAR 0 5
61018: PPUSH
61019: LD_VAR 0 1
61023: PPUSH
61024: CALL_OW 248
61028: PPUSH
61029: CALL_OW 450
61033: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61034: LD_ADDR_VAR 0 2
61038: PUSH
61039: LD_VAR 0 3
61043: PPUSH
61044: LD_INT 1
61046: PPUSH
61047: CALL_OW 275
61051: PUSH
61052: LD_VAR 0 4
61056: PUSH
61057: LD_INT 1
61059: ARRAY
61060: GREATEREQUAL
61061: PUSH
61062: LD_VAR 0 3
61066: PPUSH
61067: LD_INT 2
61069: PPUSH
61070: CALL_OW 275
61074: PUSH
61075: LD_VAR 0 4
61079: PUSH
61080: LD_INT 2
61082: ARRAY
61083: GREATEREQUAL
61084: AND
61085: PUSH
61086: LD_VAR 0 3
61090: PPUSH
61091: LD_INT 3
61093: PPUSH
61094: CALL_OW 275
61098: PUSH
61099: LD_VAR 0 4
61103: PUSH
61104: LD_INT 3
61106: ARRAY
61107: GREATEREQUAL
61108: AND
61109: ST_TO_ADDR
// end ;
61110: LD_VAR 0 2
61114: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61115: LD_INT 0
61117: PPUSH
61118: PPUSH
61119: PPUSH
// pom := GetBase ( building ) ;
61120: LD_ADDR_VAR 0 4
61124: PUSH
61125: LD_VAR 0 1
61129: PPUSH
61130: CALL_OW 274
61134: ST_TO_ADDR
// if not pom then
61135: LD_VAR 0 4
61139: NOT
61140: IFFALSE 61144
// exit ;
61142: GO 61245
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61144: LD_ADDR_VAR 0 5
61148: PUSH
61149: LD_VAR 0 2
61153: PPUSH
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 248
61163: PPUSH
61164: CALL_OW 450
61168: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61169: LD_ADDR_VAR 0 3
61173: PUSH
61174: LD_VAR 0 4
61178: PPUSH
61179: LD_INT 1
61181: PPUSH
61182: CALL_OW 275
61186: PUSH
61187: LD_VAR 0 5
61191: PUSH
61192: LD_INT 1
61194: ARRAY
61195: GREATEREQUAL
61196: PUSH
61197: LD_VAR 0 4
61201: PPUSH
61202: LD_INT 2
61204: PPUSH
61205: CALL_OW 275
61209: PUSH
61210: LD_VAR 0 5
61214: PUSH
61215: LD_INT 2
61217: ARRAY
61218: GREATEREQUAL
61219: AND
61220: PUSH
61221: LD_VAR 0 4
61225: PPUSH
61226: LD_INT 3
61228: PPUSH
61229: CALL_OW 275
61233: PUSH
61234: LD_VAR 0 5
61238: PUSH
61239: LD_INT 3
61241: ARRAY
61242: GREATEREQUAL
61243: AND
61244: ST_TO_ADDR
// end ;
61245: LD_VAR 0 3
61249: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
61250: LD_INT 0
61252: PPUSH
61253: PPUSH
61254: PPUSH
61255: PPUSH
61256: PPUSH
61257: PPUSH
61258: PPUSH
61259: PPUSH
61260: PPUSH
61261: PPUSH
// result := false ;
61262: LD_ADDR_VAR 0 6
61266: PUSH
61267: LD_INT 0
61269: ST_TO_ADDR
// if not base or not btype or not x or not y then
61270: LD_VAR 0 1
61274: NOT
61275: PUSH
61276: LD_VAR 0 2
61280: NOT
61281: OR
61282: PUSH
61283: LD_VAR 0 3
61287: NOT
61288: OR
61289: PUSH
61290: LD_VAR 0 4
61294: NOT
61295: OR
61296: IFFALSE 61300
// exit ;
61298: GO 61909
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
61300: LD_ADDR_VAR 0 12
61304: PUSH
61305: LD_VAR 0 2
61309: PPUSH
61310: LD_VAR 0 3
61314: PPUSH
61315: LD_VAR 0 4
61319: PPUSH
61320: LD_VAR 0 5
61324: PPUSH
61325: LD_VAR 0 1
61329: PUSH
61330: LD_INT 1
61332: ARRAY
61333: PPUSH
61334: CALL_OW 248
61338: PPUSH
61339: LD_INT 0
61341: PPUSH
61342: CALL 62746 0 6
61346: ST_TO_ADDR
// if not hexes then
61347: LD_VAR 0 12
61351: NOT
61352: IFFALSE 61356
// exit ;
61354: GO 61909
// for i = 1 to hexes do
61356: LD_ADDR_VAR 0 7
61360: PUSH
61361: DOUBLE
61362: LD_INT 1
61364: DEC
61365: ST_TO_ADDR
61366: LD_VAR 0 12
61370: PUSH
61371: FOR_TO
61372: IFFALSE 61907
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61374: LD_ADDR_VAR 0 11
61378: PUSH
61379: LD_VAR 0 12
61383: PUSH
61384: LD_VAR 0 7
61388: ARRAY
61389: PUSH
61390: LD_INT 1
61392: ARRAY
61393: PPUSH
61394: LD_VAR 0 12
61398: PUSH
61399: LD_VAR 0 7
61403: ARRAY
61404: PUSH
61405: LD_INT 2
61407: ARRAY
61408: PPUSH
61409: CALL_OW 428
61413: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61414: LD_VAR 0 12
61418: PUSH
61419: LD_VAR 0 7
61423: ARRAY
61424: PUSH
61425: LD_INT 1
61427: ARRAY
61428: PPUSH
61429: LD_VAR 0 12
61433: PUSH
61434: LD_VAR 0 7
61438: ARRAY
61439: PUSH
61440: LD_INT 2
61442: ARRAY
61443: PPUSH
61444: CALL_OW 351
61448: PUSH
61449: LD_VAR 0 12
61453: PUSH
61454: LD_VAR 0 7
61458: ARRAY
61459: PUSH
61460: LD_INT 1
61462: ARRAY
61463: PPUSH
61464: LD_VAR 0 12
61468: PUSH
61469: LD_VAR 0 7
61473: ARRAY
61474: PUSH
61475: LD_INT 2
61477: ARRAY
61478: PPUSH
61479: CALL_OW 488
61483: NOT
61484: OR
61485: PUSH
61486: LD_VAR 0 11
61490: PPUSH
61491: CALL_OW 247
61495: PUSH
61496: LD_INT 3
61498: EQUAL
61499: OR
61500: IFFALSE 61506
// exit ;
61502: POP
61503: POP
61504: GO 61909
// if not tmp or not tmp in base then
61506: LD_VAR 0 11
61510: NOT
61511: PUSH
61512: LD_VAR 0 11
61516: PUSH
61517: LD_VAR 0 1
61521: IN
61522: NOT
61523: OR
61524: IFFALSE 61528
// continue ;
61526: GO 61371
// result := true ;
61528: LD_ADDR_VAR 0 6
61532: PUSH
61533: LD_INT 1
61535: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61536: LD_ADDR_VAR 0 15
61540: PUSH
61541: LD_VAR 0 1
61545: PPUSH
61546: LD_INT 22
61548: PUSH
61549: LD_VAR 0 11
61553: PPUSH
61554: CALL_OW 255
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: LD_INT 2
61565: PUSH
61566: LD_INT 30
61568: PUSH
61569: LD_INT 0
61571: PUSH
61572: EMPTY
61573: LIST
61574: LIST
61575: PUSH
61576: LD_INT 30
61578: PUSH
61579: LD_INT 1
61581: PUSH
61582: EMPTY
61583: LIST
61584: LIST
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: LIST
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PPUSH
61595: CALL_OW 72
61599: ST_TO_ADDR
// if dep then
61600: LD_VAR 0 15
61604: IFFALSE 61740
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61606: LD_ADDR_VAR 0 14
61610: PUSH
61611: LD_VAR 0 15
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: CALL_OW 250
61624: PPUSH
61625: LD_VAR 0 15
61629: PUSH
61630: LD_INT 1
61632: ARRAY
61633: PPUSH
61634: CALL_OW 254
61638: PPUSH
61639: LD_INT 5
61641: PPUSH
61642: CALL_OW 272
61646: PUSH
61647: LD_VAR 0 15
61651: PUSH
61652: LD_INT 1
61654: ARRAY
61655: PPUSH
61656: CALL_OW 251
61660: PPUSH
61661: LD_VAR 0 15
61665: PUSH
61666: LD_INT 1
61668: ARRAY
61669: PPUSH
61670: CALL_OW 254
61674: PPUSH
61675: LD_INT 5
61677: PPUSH
61678: CALL_OW 273
61682: PUSH
61683: EMPTY
61684: LIST
61685: LIST
61686: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61687: LD_VAR 0 14
61691: PUSH
61692: LD_INT 1
61694: ARRAY
61695: PPUSH
61696: LD_VAR 0 14
61700: PUSH
61701: LD_INT 2
61703: ARRAY
61704: PPUSH
61705: CALL_OW 488
61709: IFFALSE 61740
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61711: LD_VAR 0 11
61715: PPUSH
61716: LD_VAR 0 14
61720: PUSH
61721: LD_INT 1
61723: ARRAY
61724: PPUSH
61725: LD_VAR 0 14
61729: PUSH
61730: LD_INT 2
61732: ARRAY
61733: PPUSH
61734: CALL_OW 111
// continue ;
61738: GO 61371
// end ; end ; r := GetDir ( tmp ) ;
61740: LD_ADDR_VAR 0 13
61744: PUSH
61745: LD_VAR 0 11
61749: PPUSH
61750: CALL_OW 254
61754: ST_TO_ADDR
// if r = 5 then
61755: LD_VAR 0 13
61759: PUSH
61760: LD_INT 5
61762: EQUAL
61763: IFFALSE 61773
// r := 0 ;
61765: LD_ADDR_VAR 0 13
61769: PUSH
61770: LD_INT 0
61772: ST_TO_ADDR
// for j = r to 5 do
61773: LD_ADDR_VAR 0 8
61777: PUSH
61778: DOUBLE
61779: LD_VAR 0 13
61783: DEC
61784: ST_TO_ADDR
61785: LD_INT 5
61787: PUSH
61788: FOR_TO
61789: IFFALSE 61903
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61791: LD_ADDR_VAR 0 9
61795: PUSH
61796: LD_VAR 0 11
61800: PPUSH
61801: CALL_OW 250
61805: PPUSH
61806: LD_VAR 0 8
61810: PPUSH
61811: LD_INT 2
61813: PPUSH
61814: CALL_OW 272
61818: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61819: LD_ADDR_VAR 0 10
61823: PUSH
61824: LD_VAR 0 11
61828: PPUSH
61829: CALL_OW 251
61833: PPUSH
61834: LD_VAR 0 8
61838: PPUSH
61839: LD_INT 2
61841: PPUSH
61842: CALL_OW 273
61846: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61847: LD_VAR 0 9
61851: PPUSH
61852: LD_VAR 0 10
61856: PPUSH
61857: CALL_OW 488
61861: PUSH
61862: LD_VAR 0 9
61866: PPUSH
61867: LD_VAR 0 10
61871: PPUSH
61872: CALL_OW 428
61876: NOT
61877: AND
61878: IFFALSE 61901
// begin ComMoveXY ( tmp , _x , _y ) ;
61880: LD_VAR 0 11
61884: PPUSH
61885: LD_VAR 0 9
61889: PPUSH
61890: LD_VAR 0 10
61894: PPUSH
61895: CALL_OW 111
// break ;
61899: GO 61903
// end ; end ;
61901: GO 61788
61903: POP
61904: POP
// end ;
61905: GO 61371
61907: POP
61908: POP
// end ;
61909: LD_VAR 0 6
61913: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61914: LD_INT 0
61916: PPUSH
61917: PPUSH
61918: PPUSH
61919: PPUSH
61920: PPUSH
61921: PPUSH
61922: PPUSH
61923: PPUSH
61924: PPUSH
61925: PPUSH
// result := false ;
61926: LD_ADDR_VAR 0 6
61930: PUSH
61931: LD_INT 0
61933: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61934: LD_VAR 0 1
61938: NOT
61939: PUSH
61940: LD_VAR 0 1
61944: PPUSH
61945: CALL_OW 266
61949: PUSH
61950: LD_INT 0
61952: PUSH
61953: LD_INT 1
61955: PUSH
61956: EMPTY
61957: LIST
61958: LIST
61959: IN
61960: NOT
61961: OR
61962: PUSH
61963: LD_VAR 0 2
61967: NOT
61968: OR
61969: PUSH
61970: LD_VAR 0 5
61974: PUSH
61975: LD_INT 0
61977: PUSH
61978: LD_INT 1
61980: PUSH
61981: LD_INT 2
61983: PUSH
61984: LD_INT 3
61986: PUSH
61987: LD_INT 4
61989: PUSH
61990: LD_INT 5
61992: PUSH
61993: EMPTY
61994: LIST
61995: LIST
61996: LIST
61997: LIST
61998: LIST
61999: LIST
62000: IN
62001: NOT
62002: OR
62003: PUSH
62004: LD_VAR 0 3
62008: PPUSH
62009: LD_VAR 0 4
62013: PPUSH
62014: CALL_OW 488
62018: NOT
62019: OR
62020: IFFALSE 62024
// exit ;
62022: GO 62741
// pom := GetBase ( depot ) ;
62024: LD_ADDR_VAR 0 10
62028: PUSH
62029: LD_VAR 0 1
62033: PPUSH
62034: CALL_OW 274
62038: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62039: LD_ADDR_VAR 0 11
62043: PUSH
62044: LD_VAR 0 2
62048: PPUSH
62049: LD_VAR 0 1
62053: PPUSH
62054: CALL_OW 248
62058: PPUSH
62059: CALL_OW 450
62063: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62064: LD_VAR 0 10
62068: PPUSH
62069: LD_INT 1
62071: PPUSH
62072: CALL_OW 275
62076: PUSH
62077: LD_VAR 0 11
62081: PUSH
62082: LD_INT 1
62084: ARRAY
62085: GREATEREQUAL
62086: PUSH
62087: LD_VAR 0 10
62091: PPUSH
62092: LD_INT 2
62094: PPUSH
62095: CALL_OW 275
62099: PUSH
62100: LD_VAR 0 11
62104: PUSH
62105: LD_INT 2
62107: ARRAY
62108: GREATEREQUAL
62109: AND
62110: PUSH
62111: LD_VAR 0 10
62115: PPUSH
62116: LD_INT 3
62118: PPUSH
62119: CALL_OW 275
62123: PUSH
62124: LD_VAR 0 11
62128: PUSH
62129: LD_INT 3
62131: ARRAY
62132: GREATEREQUAL
62133: AND
62134: NOT
62135: IFFALSE 62139
// exit ;
62137: GO 62741
// if GetBType ( depot ) = b_depot then
62139: LD_VAR 0 1
62143: PPUSH
62144: CALL_OW 266
62148: PUSH
62149: LD_INT 0
62151: EQUAL
62152: IFFALSE 62164
// dist := 28 else
62154: LD_ADDR_VAR 0 14
62158: PUSH
62159: LD_INT 28
62161: ST_TO_ADDR
62162: GO 62172
// dist := 36 ;
62164: LD_ADDR_VAR 0 14
62168: PUSH
62169: LD_INT 36
62171: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62172: LD_VAR 0 1
62176: PPUSH
62177: LD_VAR 0 3
62181: PPUSH
62182: LD_VAR 0 4
62186: PPUSH
62187: CALL_OW 297
62191: PUSH
62192: LD_VAR 0 14
62196: GREATER
62197: IFFALSE 62201
// exit ;
62199: GO 62741
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62201: LD_ADDR_VAR 0 12
62205: PUSH
62206: LD_VAR 0 2
62210: PPUSH
62211: LD_VAR 0 3
62215: PPUSH
62216: LD_VAR 0 4
62220: PPUSH
62221: LD_VAR 0 5
62225: PPUSH
62226: LD_VAR 0 1
62230: PPUSH
62231: CALL_OW 248
62235: PPUSH
62236: LD_INT 0
62238: PPUSH
62239: CALL 62746 0 6
62243: ST_TO_ADDR
// if not hexes then
62244: LD_VAR 0 12
62248: NOT
62249: IFFALSE 62253
// exit ;
62251: GO 62741
// hex := GetHexInfo ( x , y ) ;
62253: LD_ADDR_VAR 0 15
62257: PUSH
62258: LD_VAR 0 3
62262: PPUSH
62263: LD_VAR 0 4
62267: PPUSH
62268: CALL_OW 546
62272: ST_TO_ADDR
// if hex [ 1 ] then
62273: LD_VAR 0 15
62277: PUSH
62278: LD_INT 1
62280: ARRAY
62281: IFFALSE 62285
// exit ;
62283: GO 62741
// height := hex [ 2 ] ;
62285: LD_ADDR_VAR 0 13
62289: PUSH
62290: LD_VAR 0 15
62294: PUSH
62295: LD_INT 2
62297: ARRAY
62298: ST_TO_ADDR
// for i = 1 to hexes do
62299: LD_ADDR_VAR 0 7
62303: PUSH
62304: DOUBLE
62305: LD_INT 1
62307: DEC
62308: ST_TO_ADDR
62309: LD_VAR 0 12
62313: PUSH
62314: FOR_TO
62315: IFFALSE 62645
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62317: LD_VAR 0 12
62321: PUSH
62322: LD_VAR 0 7
62326: ARRAY
62327: PUSH
62328: LD_INT 1
62330: ARRAY
62331: PPUSH
62332: LD_VAR 0 12
62336: PUSH
62337: LD_VAR 0 7
62341: ARRAY
62342: PUSH
62343: LD_INT 2
62345: ARRAY
62346: PPUSH
62347: CALL_OW 488
62351: NOT
62352: PUSH
62353: LD_VAR 0 12
62357: PUSH
62358: LD_VAR 0 7
62362: ARRAY
62363: PUSH
62364: LD_INT 1
62366: ARRAY
62367: PPUSH
62368: LD_VAR 0 12
62372: PUSH
62373: LD_VAR 0 7
62377: ARRAY
62378: PUSH
62379: LD_INT 2
62381: ARRAY
62382: PPUSH
62383: CALL_OW 428
62387: PUSH
62388: LD_INT 0
62390: GREATER
62391: OR
62392: PUSH
62393: LD_VAR 0 12
62397: PUSH
62398: LD_VAR 0 7
62402: ARRAY
62403: PUSH
62404: LD_INT 1
62406: ARRAY
62407: PPUSH
62408: LD_VAR 0 12
62412: PUSH
62413: LD_VAR 0 7
62417: ARRAY
62418: PUSH
62419: LD_INT 2
62421: ARRAY
62422: PPUSH
62423: CALL_OW 351
62427: OR
62428: IFFALSE 62434
// exit ;
62430: POP
62431: POP
62432: GO 62741
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62434: LD_ADDR_VAR 0 8
62438: PUSH
62439: LD_VAR 0 12
62443: PUSH
62444: LD_VAR 0 7
62448: ARRAY
62449: PUSH
62450: LD_INT 1
62452: ARRAY
62453: PPUSH
62454: LD_VAR 0 12
62458: PUSH
62459: LD_VAR 0 7
62463: ARRAY
62464: PUSH
62465: LD_INT 2
62467: ARRAY
62468: PPUSH
62469: CALL_OW 546
62473: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62474: LD_VAR 0 8
62478: PUSH
62479: LD_INT 1
62481: ARRAY
62482: PUSH
62483: LD_VAR 0 8
62487: PUSH
62488: LD_INT 2
62490: ARRAY
62491: PUSH
62492: LD_VAR 0 13
62496: PUSH
62497: LD_INT 2
62499: PLUS
62500: GREATER
62501: OR
62502: PUSH
62503: LD_VAR 0 8
62507: PUSH
62508: LD_INT 2
62510: ARRAY
62511: PUSH
62512: LD_VAR 0 13
62516: PUSH
62517: LD_INT 2
62519: MINUS
62520: LESS
62521: OR
62522: PUSH
62523: LD_VAR 0 8
62527: PUSH
62528: LD_INT 3
62530: ARRAY
62531: PUSH
62532: LD_INT 0
62534: PUSH
62535: LD_INT 8
62537: PUSH
62538: LD_INT 9
62540: PUSH
62541: LD_INT 10
62543: PUSH
62544: LD_INT 11
62546: PUSH
62547: LD_INT 12
62549: PUSH
62550: LD_INT 13
62552: PUSH
62553: LD_INT 16
62555: PUSH
62556: LD_INT 17
62558: PUSH
62559: LD_INT 18
62561: PUSH
62562: LD_INT 19
62564: PUSH
62565: LD_INT 20
62567: PUSH
62568: LD_INT 21
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: LIST
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: IN
62586: NOT
62587: OR
62588: PUSH
62589: LD_VAR 0 8
62593: PUSH
62594: LD_INT 5
62596: ARRAY
62597: NOT
62598: OR
62599: PUSH
62600: LD_VAR 0 8
62604: PUSH
62605: LD_INT 6
62607: ARRAY
62608: PUSH
62609: LD_INT 1
62611: PUSH
62612: LD_INT 2
62614: PUSH
62615: LD_INT 7
62617: PUSH
62618: LD_INT 9
62620: PUSH
62621: LD_INT 10
62623: PUSH
62624: LD_INT 11
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: IN
62635: NOT
62636: OR
62637: IFFALSE 62643
// exit ;
62639: POP
62640: POP
62641: GO 62741
// end ;
62643: GO 62314
62645: POP
62646: POP
// side := GetSide ( depot ) ;
62647: LD_ADDR_VAR 0 9
62651: PUSH
62652: LD_VAR 0 1
62656: PPUSH
62657: CALL_OW 255
62661: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62662: LD_VAR 0 9
62666: PPUSH
62667: LD_VAR 0 3
62671: PPUSH
62672: LD_VAR 0 4
62676: PPUSH
62677: LD_INT 20
62679: PPUSH
62680: CALL 55395 0 4
62684: PUSH
62685: LD_INT 4
62687: ARRAY
62688: IFFALSE 62692
// exit ;
62690: GO 62741
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62692: LD_VAR 0 2
62696: PUSH
62697: LD_INT 29
62699: PUSH
62700: LD_INT 30
62702: PUSH
62703: EMPTY
62704: LIST
62705: LIST
62706: IN
62707: PUSH
62708: LD_VAR 0 3
62712: PPUSH
62713: LD_VAR 0 4
62717: PPUSH
62718: LD_VAR 0 9
62722: PPUSH
62723: CALL_OW 440
62727: NOT
62728: AND
62729: IFFALSE 62733
// exit ;
62731: GO 62741
// result := true ;
62733: LD_ADDR_VAR 0 6
62737: PUSH
62738: LD_INT 1
62740: ST_TO_ADDR
// end ;
62741: LD_VAR 0 6
62745: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62746: LD_INT 0
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
62798: PPUSH
62799: PPUSH
62800: PPUSH
62801: PPUSH
62802: PPUSH
62803: PPUSH
62804: PPUSH
62805: PPUSH
// result = [ ] ;
62806: LD_ADDR_VAR 0 7
62810: PUSH
62811: EMPTY
62812: ST_TO_ADDR
// temp_list = [ ] ;
62813: LD_ADDR_VAR 0 9
62817: PUSH
62818: EMPTY
62819: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62820: LD_VAR 0 4
62824: PUSH
62825: LD_INT 0
62827: PUSH
62828: LD_INT 1
62830: PUSH
62831: LD_INT 2
62833: PUSH
62834: LD_INT 3
62836: PUSH
62837: LD_INT 4
62839: PUSH
62840: LD_INT 5
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: LIST
62847: LIST
62848: LIST
62849: LIST
62850: IN
62851: NOT
62852: PUSH
62853: LD_VAR 0 1
62857: PUSH
62858: LD_INT 0
62860: PUSH
62861: LD_INT 1
62863: PUSH
62864: EMPTY
62865: LIST
62866: LIST
62867: IN
62868: PUSH
62869: LD_VAR 0 5
62873: PUSH
62874: LD_INT 1
62876: PUSH
62877: LD_INT 2
62879: PUSH
62880: LD_INT 3
62882: PUSH
62883: EMPTY
62884: LIST
62885: LIST
62886: LIST
62887: IN
62888: NOT
62889: AND
62890: OR
62891: IFFALSE 62895
// exit ;
62893: GO 81286
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62895: LD_VAR 0 1
62899: PUSH
62900: LD_INT 6
62902: PUSH
62903: LD_INT 7
62905: PUSH
62906: LD_INT 8
62908: PUSH
62909: LD_INT 13
62911: PUSH
62912: LD_INT 12
62914: PUSH
62915: LD_INT 15
62917: PUSH
62918: LD_INT 11
62920: PUSH
62921: LD_INT 14
62923: PUSH
62924: LD_INT 10
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: IN
62938: IFFALSE 62948
// btype = b_lab ;
62940: LD_ADDR_VAR 0 1
62944: PUSH
62945: LD_INT 6
62947: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62948: LD_VAR 0 6
62952: PUSH
62953: LD_INT 0
62955: PUSH
62956: LD_INT 1
62958: PUSH
62959: LD_INT 2
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: LIST
62966: IN
62967: NOT
62968: PUSH
62969: LD_VAR 0 1
62973: PUSH
62974: LD_INT 0
62976: PUSH
62977: LD_INT 1
62979: PUSH
62980: LD_INT 2
62982: PUSH
62983: LD_INT 3
62985: PUSH
62986: LD_INT 6
62988: PUSH
62989: LD_INT 36
62991: PUSH
62992: LD_INT 4
62994: PUSH
62995: LD_INT 5
62997: PUSH
62998: LD_INT 31
63000: PUSH
63001: LD_INT 32
63003: PUSH
63004: LD_INT 33
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: IN
63020: NOT
63021: PUSH
63022: LD_VAR 0 6
63026: PUSH
63027: LD_INT 1
63029: EQUAL
63030: AND
63031: OR
63032: PUSH
63033: LD_VAR 0 1
63037: PUSH
63038: LD_INT 2
63040: PUSH
63041: LD_INT 3
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: IN
63048: NOT
63049: PUSH
63050: LD_VAR 0 6
63054: PUSH
63055: LD_INT 2
63057: EQUAL
63058: AND
63059: OR
63060: IFFALSE 63070
// mode = 0 ;
63062: LD_ADDR_VAR 0 6
63066: PUSH
63067: LD_INT 0
63069: ST_TO_ADDR
// case mode of 0 :
63070: LD_VAR 0 6
63074: PUSH
63075: LD_INT 0
63077: DOUBLE
63078: EQUAL
63079: IFTRUE 63083
63081: GO 74536
63083: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63084: LD_ADDR_VAR 0 11
63088: PUSH
63089: LD_INT 0
63091: PUSH
63092: LD_INT 0
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PUSH
63099: LD_INT 0
63101: PUSH
63102: LD_INT 1
63104: NEG
63105: PUSH
63106: EMPTY
63107: LIST
63108: LIST
63109: PUSH
63110: LD_INT 1
63112: PUSH
63113: LD_INT 0
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: PUSH
63120: LD_INT 1
63122: PUSH
63123: LD_INT 1
63125: PUSH
63126: EMPTY
63127: LIST
63128: LIST
63129: PUSH
63130: LD_INT 0
63132: PUSH
63133: LD_INT 1
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: PUSH
63140: LD_INT 1
63142: NEG
63143: PUSH
63144: LD_INT 0
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 1
63153: NEG
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PUSH
63163: LD_INT 1
63165: NEG
63166: PUSH
63167: LD_INT 2
63169: NEG
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: PUSH
63175: LD_INT 0
63177: PUSH
63178: LD_INT 2
63180: NEG
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: LD_INT 1
63188: PUSH
63189: LD_INT 1
63191: NEG
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: LD_INT 1
63199: PUSH
63200: LD_INT 2
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: LD_INT 0
63209: PUSH
63210: LD_INT 2
63212: PUSH
63213: EMPTY
63214: LIST
63215: LIST
63216: PUSH
63217: LD_INT 1
63219: NEG
63220: PUSH
63221: LD_INT 1
63223: PUSH
63224: EMPTY
63225: LIST
63226: LIST
63227: PUSH
63228: LD_INT 1
63230: PUSH
63231: LD_INT 3
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 0
63240: PUSH
63241: LD_INT 3
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 1
63250: NEG
63251: PUSH
63252: LD_INT 2
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: LIST
63275: LIST
63276: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63277: LD_ADDR_VAR 0 12
63281: PUSH
63282: LD_INT 0
63284: PUSH
63285: LD_INT 0
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: LD_INT 0
63294: PUSH
63295: LD_INT 1
63297: NEG
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 1
63305: PUSH
63306: LD_INT 0
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 1
63315: PUSH
63316: LD_INT 1
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PUSH
63323: LD_INT 0
63325: PUSH
63326: LD_INT 1
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 1
63335: NEG
63336: PUSH
63337: LD_INT 0
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 1
63346: NEG
63347: PUSH
63348: LD_INT 1
63350: NEG
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: LD_INT 1
63358: PUSH
63359: LD_INT 1
63361: NEG
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 2
63369: PUSH
63370: LD_INT 0
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 2
63379: PUSH
63380: LD_INT 1
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: LD_INT 1
63389: NEG
63390: PUSH
63391: LD_INT 1
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 2
63400: NEG
63401: PUSH
63402: LD_INT 0
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 2
63411: NEG
63412: PUSH
63413: LD_INT 1
63415: NEG
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 2
63423: NEG
63424: PUSH
63425: LD_INT 1
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: PUSH
63432: LD_INT 3
63434: NEG
63435: PUSH
63436: LD_INT 0
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: LD_INT 3
63445: NEG
63446: PUSH
63447: LD_INT 1
63449: NEG
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63473: LD_ADDR_VAR 0 13
63477: PUSH
63478: LD_INT 0
63480: PUSH
63481: LD_INT 0
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 0
63490: PUSH
63491: LD_INT 1
63493: NEG
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: LD_INT 1
63501: PUSH
63502: LD_INT 0
63504: PUSH
63505: EMPTY
63506: LIST
63507: LIST
63508: PUSH
63509: LD_INT 1
63511: PUSH
63512: LD_INT 1
63514: PUSH
63515: EMPTY
63516: LIST
63517: LIST
63518: PUSH
63519: LD_INT 0
63521: PUSH
63522: LD_INT 1
63524: PUSH
63525: EMPTY
63526: LIST
63527: LIST
63528: PUSH
63529: LD_INT 1
63531: NEG
63532: PUSH
63533: LD_INT 0
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: PUSH
63540: LD_INT 1
63542: NEG
63543: PUSH
63544: LD_INT 1
63546: NEG
63547: PUSH
63548: EMPTY
63549: LIST
63550: LIST
63551: PUSH
63552: LD_INT 1
63554: NEG
63555: PUSH
63556: LD_INT 2
63558: NEG
63559: PUSH
63560: EMPTY
63561: LIST
63562: LIST
63563: PUSH
63564: LD_INT 2
63566: PUSH
63567: LD_INT 1
63569: PUSH
63570: EMPTY
63571: LIST
63572: LIST
63573: PUSH
63574: LD_INT 2
63576: PUSH
63577: LD_INT 2
63579: PUSH
63580: EMPTY
63581: LIST
63582: LIST
63583: PUSH
63584: LD_INT 1
63586: PUSH
63587: LD_INT 2
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PUSH
63594: LD_INT 2
63596: NEG
63597: PUSH
63598: LD_INT 1
63600: NEG
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: LD_INT 2
63608: NEG
63609: PUSH
63610: LD_INT 2
63612: NEG
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: LD_INT 2
63620: NEG
63621: PUSH
63622: LD_INT 3
63624: NEG
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 3
63632: NEG
63633: PUSH
63634: LD_INT 2
63636: NEG
63637: PUSH
63638: EMPTY
63639: LIST
63640: LIST
63641: PUSH
63642: LD_INT 3
63644: NEG
63645: PUSH
63646: LD_INT 3
63648: NEG
63649: PUSH
63650: EMPTY
63651: LIST
63652: LIST
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63672: LD_ADDR_VAR 0 14
63676: PUSH
63677: LD_INT 0
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 0
63689: PUSH
63690: LD_INT 1
63692: NEG
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 1
63700: PUSH
63701: LD_INT 0
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 1
63710: PUSH
63711: LD_INT 1
63713: PUSH
63714: EMPTY
63715: LIST
63716: LIST
63717: PUSH
63718: LD_INT 0
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 1
63730: NEG
63731: PUSH
63732: LD_INT 0
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 1
63741: NEG
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: LD_INT 1
63753: NEG
63754: PUSH
63755: LD_INT 2
63757: NEG
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 0
63765: PUSH
63766: LD_INT 2
63768: NEG
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 1
63776: PUSH
63777: LD_INT 1
63779: NEG
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 1
63787: PUSH
63788: LD_INT 2
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: LD_INT 0
63797: PUSH
63798: LD_INT 2
63800: PUSH
63801: EMPTY
63802: LIST
63803: LIST
63804: PUSH
63805: LD_INT 1
63807: NEG
63808: PUSH
63809: LD_INT 1
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: LD_INT 1
63818: NEG
63819: PUSH
63820: LD_INT 3
63822: NEG
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 0
63830: PUSH
63831: LD_INT 3
63833: NEG
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: PUSH
63842: LD_INT 2
63844: NEG
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63868: LD_ADDR_VAR 0 15
63872: PUSH
63873: LD_INT 0
63875: PUSH
63876: LD_INT 0
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: LD_INT 0
63885: PUSH
63886: LD_INT 1
63888: NEG
63889: PUSH
63890: EMPTY
63891: LIST
63892: LIST
63893: PUSH
63894: LD_INT 1
63896: PUSH
63897: LD_INT 0
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: PUSH
63904: LD_INT 1
63906: PUSH
63907: LD_INT 1
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: PUSH
63914: LD_INT 0
63916: PUSH
63917: LD_INT 1
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 1
63926: NEG
63927: PUSH
63928: LD_INT 0
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 1
63937: NEG
63938: PUSH
63939: LD_INT 1
63941: NEG
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: PUSH
63947: LD_INT 1
63949: PUSH
63950: LD_INT 1
63952: NEG
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PUSH
63958: LD_INT 2
63960: PUSH
63961: LD_INT 0
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PUSH
63968: LD_INT 2
63970: PUSH
63971: LD_INT 1
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: PUSH
63978: LD_INT 1
63980: NEG
63981: PUSH
63982: LD_INT 1
63984: PUSH
63985: EMPTY
63986: LIST
63987: LIST
63988: PUSH
63989: LD_INT 2
63991: NEG
63992: PUSH
63993: LD_INT 0
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 2
64002: NEG
64003: PUSH
64004: LD_INT 1
64006: NEG
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 2
64014: PUSH
64015: LD_INT 1
64017: NEG
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 3
64025: PUSH
64026: LD_INT 0
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 3
64035: PUSH
64036: LD_INT 1
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64061: LD_ADDR_VAR 0 16
64065: PUSH
64066: LD_INT 0
64068: PUSH
64069: LD_INT 0
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 0
64078: PUSH
64079: LD_INT 1
64081: NEG
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 1
64089: PUSH
64090: LD_INT 0
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 1
64099: PUSH
64100: LD_INT 1
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 0
64109: PUSH
64110: LD_INT 1
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 1
64119: NEG
64120: PUSH
64121: LD_INT 0
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 1
64130: NEG
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 1
64142: NEG
64143: PUSH
64144: LD_INT 2
64146: NEG
64147: PUSH
64148: EMPTY
64149: LIST
64150: LIST
64151: PUSH
64152: LD_INT 2
64154: PUSH
64155: LD_INT 1
64157: PUSH
64158: EMPTY
64159: LIST
64160: LIST
64161: PUSH
64162: LD_INT 2
64164: PUSH
64165: LD_INT 2
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PUSH
64172: LD_INT 1
64174: PUSH
64175: LD_INT 2
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 2
64184: NEG
64185: PUSH
64186: LD_INT 1
64188: NEG
64189: PUSH
64190: EMPTY
64191: LIST
64192: LIST
64193: PUSH
64194: LD_INT 2
64196: NEG
64197: PUSH
64198: LD_INT 2
64200: NEG
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: PUSH
64206: LD_INT 3
64208: PUSH
64209: LD_INT 2
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PUSH
64216: LD_INT 3
64218: PUSH
64219: LD_INT 3
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 2
64228: PUSH
64229: LD_INT 3
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64254: LD_ADDR_VAR 0 17
64258: PUSH
64259: LD_INT 0
64261: PUSH
64262: LD_INT 0
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: PUSH
64269: LD_INT 0
64271: PUSH
64272: LD_INT 1
64274: NEG
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 1
64282: PUSH
64283: LD_INT 0
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: LD_INT 1
64292: PUSH
64293: LD_INT 1
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: PUSH
64300: LD_INT 0
64302: PUSH
64303: LD_INT 1
64305: PUSH
64306: EMPTY
64307: LIST
64308: LIST
64309: PUSH
64310: LD_INT 1
64312: NEG
64313: PUSH
64314: LD_INT 0
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 1
64323: NEG
64324: PUSH
64325: LD_INT 1
64327: NEG
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PUSH
64333: LD_INT 1
64335: NEG
64336: PUSH
64337: LD_INT 2
64339: NEG
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: PUSH
64345: LD_INT 0
64347: PUSH
64348: LD_INT 2
64350: NEG
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 1
64358: PUSH
64359: LD_INT 1
64361: NEG
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: PUSH
64367: LD_INT 2
64369: PUSH
64370: LD_INT 0
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 2
64379: PUSH
64380: LD_INT 1
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 2
64389: PUSH
64390: LD_INT 2
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PUSH
64397: LD_INT 1
64399: PUSH
64400: LD_INT 2
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: PUSH
64407: LD_INT 0
64409: PUSH
64410: LD_INT 2
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: PUSH
64417: LD_INT 1
64419: NEG
64420: PUSH
64421: LD_INT 1
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: PUSH
64428: LD_INT 2
64430: NEG
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 2
64441: NEG
64442: PUSH
64443: LD_INT 1
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 2
64453: NEG
64454: PUSH
64455: LD_INT 2
64457: NEG
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64484: LD_ADDR_VAR 0 18
64488: PUSH
64489: LD_INT 0
64491: PUSH
64492: LD_INT 0
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PUSH
64499: LD_INT 0
64501: PUSH
64502: LD_INT 1
64504: NEG
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: LD_INT 1
64512: PUSH
64513: LD_INT 0
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 1
64522: PUSH
64523: LD_INT 1
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 0
64532: PUSH
64533: LD_INT 1
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: LD_INT 1
64542: NEG
64543: PUSH
64544: LD_INT 0
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: LD_INT 1
64553: NEG
64554: PUSH
64555: LD_INT 1
64557: NEG
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: LD_INT 1
64565: NEG
64566: PUSH
64567: LD_INT 2
64569: NEG
64570: PUSH
64571: EMPTY
64572: LIST
64573: LIST
64574: PUSH
64575: LD_INT 0
64577: PUSH
64578: LD_INT 2
64580: NEG
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 1
64588: PUSH
64589: LD_INT 1
64591: NEG
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 2
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 2
64609: PUSH
64610: LD_INT 1
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 2
64619: PUSH
64620: LD_INT 2
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: PUSH
64630: LD_INT 2
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 0
64639: PUSH
64640: LD_INT 2
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PUSH
64647: LD_INT 1
64649: NEG
64650: PUSH
64651: LD_INT 1
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: PUSH
64658: LD_INT 2
64660: NEG
64661: PUSH
64662: LD_INT 0
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 2
64671: NEG
64672: PUSH
64673: LD_INT 1
64675: NEG
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: LD_INT 2
64683: NEG
64684: PUSH
64685: LD_INT 2
64687: NEG
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64714: LD_ADDR_VAR 0 19
64718: PUSH
64719: LD_INT 0
64721: PUSH
64722: LD_INT 0
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: LD_INT 0
64731: PUSH
64732: LD_INT 1
64734: NEG
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 1
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 1
64752: PUSH
64753: LD_INT 1
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PUSH
64760: LD_INT 0
64762: PUSH
64763: LD_INT 1
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: LD_INT 1
64772: NEG
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 1
64783: NEG
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 1
64795: NEG
64796: PUSH
64797: LD_INT 2
64799: NEG
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 0
64807: PUSH
64808: LD_INT 2
64810: NEG
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: LD_INT 1
64821: NEG
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 2
64829: PUSH
64830: LD_INT 0
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 2
64839: PUSH
64840: LD_INT 1
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 2
64849: PUSH
64850: LD_INT 2
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 1
64859: PUSH
64860: LD_INT 2
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 0
64869: PUSH
64870: LD_INT 2
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: LD_INT 1
64879: NEG
64880: PUSH
64881: LD_INT 1
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 2
64890: NEG
64891: PUSH
64892: LD_INT 0
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 2
64901: NEG
64902: PUSH
64903: LD_INT 1
64905: NEG
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 2
64913: NEG
64914: PUSH
64915: LD_INT 2
64917: NEG
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64944: LD_ADDR_VAR 0 20
64948: PUSH
64949: LD_INT 0
64951: PUSH
64952: LD_INT 0
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PUSH
64959: LD_INT 0
64961: PUSH
64962: LD_INT 1
64964: NEG
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: PUSH
64970: LD_INT 1
64972: PUSH
64973: LD_INT 0
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 1
64982: PUSH
64983: LD_INT 1
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 0
64992: PUSH
64993: LD_INT 1
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PUSH
65000: LD_INT 1
65002: NEG
65003: PUSH
65004: LD_INT 0
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 1
65013: NEG
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 1
65025: NEG
65026: PUSH
65027: LD_INT 2
65029: NEG
65030: PUSH
65031: EMPTY
65032: LIST
65033: LIST
65034: PUSH
65035: LD_INT 0
65037: PUSH
65038: LD_INT 2
65040: NEG
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 1
65048: PUSH
65049: LD_INT 1
65051: NEG
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 2
65059: PUSH
65060: LD_INT 0
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 2
65069: PUSH
65070: LD_INT 1
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 2
65079: PUSH
65080: LD_INT 2
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: PUSH
65087: LD_INT 1
65089: PUSH
65090: LD_INT 2
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 0
65099: PUSH
65100: LD_INT 2
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: PUSH
65107: LD_INT 1
65109: NEG
65110: PUSH
65111: LD_INT 1
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: NEG
65121: PUSH
65122: LD_INT 0
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 2
65131: NEG
65132: PUSH
65133: LD_INT 1
65135: NEG
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 2
65143: NEG
65144: PUSH
65145: LD_INT 2
65147: NEG
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65174: LD_ADDR_VAR 0 21
65178: PUSH
65179: LD_INT 0
65181: PUSH
65182: LD_INT 0
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: LD_INT 0
65191: PUSH
65192: LD_INT 1
65194: NEG
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: LD_INT 0
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 1
65212: PUSH
65213: LD_INT 1
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: LD_INT 0
65222: PUSH
65223: LD_INT 1
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 1
65232: NEG
65233: PUSH
65234: LD_INT 0
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: LD_INT 1
65243: NEG
65244: PUSH
65245: LD_INT 1
65247: NEG
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 1
65255: NEG
65256: PUSH
65257: LD_INT 2
65259: NEG
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 0
65267: PUSH
65268: LD_INT 2
65270: NEG
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 1
65278: PUSH
65279: LD_INT 1
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 2
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 2
65299: PUSH
65300: LD_INT 1
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: PUSH
65320: LD_INT 2
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 0
65329: PUSH
65330: LD_INT 2
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 1
65339: NEG
65340: PUSH
65341: LD_INT 1
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 2
65350: NEG
65351: PUSH
65352: LD_INT 0
65354: PUSH
65355: EMPTY
65356: LIST
65357: LIST
65358: PUSH
65359: LD_INT 2
65361: NEG
65362: PUSH
65363: LD_INT 1
65365: NEG
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 2
65373: NEG
65374: PUSH
65375: LD_INT 2
65377: NEG
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65404: LD_ADDR_VAR 0 22
65408: PUSH
65409: LD_INT 0
65411: PUSH
65412: LD_INT 0
65414: PUSH
65415: EMPTY
65416: LIST
65417: LIST
65418: PUSH
65419: LD_INT 0
65421: PUSH
65422: LD_INT 1
65424: NEG
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: PUSH
65430: LD_INT 1
65432: PUSH
65433: LD_INT 0
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 1
65442: PUSH
65443: LD_INT 1
65445: PUSH
65446: EMPTY
65447: LIST
65448: LIST
65449: PUSH
65450: LD_INT 0
65452: PUSH
65453: LD_INT 1
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 1
65462: NEG
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: EMPTY
65468: LIST
65469: LIST
65470: PUSH
65471: LD_INT 1
65473: NEG
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 1
65485: NEG
65486: PUSH
65487: LD_INT 2
65489: NEG
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 0
65497: PUSH
65498: LD_INT 2
65500: NEG
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 1
65508: PUSH
65509: LD_INT 1
65511: NEG
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 2
65529: PUSH
65530: LD_INT 1
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 2
65539: PUSH
65540: LD_INT 2
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 1
65549: PUSH
65550: LD_INT 2
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 0
65559: PUSH
65560: LD_INT 2
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: LD_INT 1
65569: NEG
65570: PUSH
65571: LD_INT 1
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 2
65580: NEG
65581: PUSH
65582: LD_INT 0
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: LD_INT 2
65591: NEG
65592: PUSH
65593: LD_INT 1
65595: NEG
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 2
65603: NEG
65604: PUSH
65605: LD_INT 2
65607: NEG
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65634: LD_ADDR_VAR 0 23
65638: PUSH
65639: LD_INT 0
65641: PUSH
65642: LD_INT 0
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 0
65651: PUSH
65652: LD_INT 1
65654: NEG
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 0
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 1
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 0
65682: PUSH
65683: LD_INT 1
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: NEG
65693: PUSH
65694: LD_INT 0
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 1
65703: NEG
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 1
65715: NEG
65716: PUSH
65717: LD_INT 2
65719: NEG
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 0
65727: PUSH
65728: LD_INT 2
65730: NEG
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 1
65738: PUSH
65739: LD_INT 1
65741: NEG
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 2
65749: PUSH
65750: LD_INT 0
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 2
65759: PUSH
65760: LD_INT 1
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: LD_INT 2
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 1
65779: PUSH
65780: LD_INT 2
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 0
65789: PUSH
65790: LD_INT 2
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 1
65799: NEG
65800: PUSH
65801: LD_INT 1
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 2
65810: NEG
65811: PUSH
65812: LD_INT 0
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: PUSH
65819: LD_INT 2
65821: NEG
65822: PUSH
65823: LD_INT 1
65825: NEG
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 2
65833: NEG
65834: PUSH
65835: LD_INT 2
65837: NEG
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 2
65845: NEG
65846: PUSH
65847: LD_INT 3
65849: NEG
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 1
65857: NEG
65858: PUSH
65859: LD_INT 3
65861: NEG
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: LD_INT 2
65872: NEG
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 2
65880: PUSH
65881: LD_INT 1
65883: NEG
65884: PUSH
65885: EMPTY
65886: LIST
65887: LIST
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65914: LD_ADDR_VAR 0 24
65918: PUSH
65919: LD_INT 0
65921: PUSH
65922: LD_INT 0
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: PUSH
65929: LD_INT 0
65931: PUSH
65932: LD_INT 1
65934: NEG
65935: PUSH
65936: EMPTY
65937: LIST
65938: LIST
65939: PUSH
65940: LD_INT 1
65942: PUSH
65943: LD_INT 0
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PUSH
65950: LD_INT 1
65952: PUSH
65953: LD_INT 1
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: PUSH
65960: LD_INT 0
65962: PUSH
65963: LD_INT 1
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: PUSH
65970: LD_INT 1
65972: NEG
65973: PUSH
65974: LD_INT 0
65976: PUSH
65977: EMPTY
65978: LIST
65979: LIST
65980: PUSH
65981: LD_INT 1
65983: NEG
65984: PUSH
65985: LD_INT 1
65987: NEG
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 1
65995: NEG
65996: PUSH
65997: LD_INT 2
65999: NEG
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 0
66007: PUSH
66008: LD_INT 2
66010: NEG
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 2
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: LD_INT 2
66039: PUSH
66040: LD_INT 1
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: LD_INT 2
66049: PUSH
66050: LD_INT 2
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: LD_INT 1
66059: PUSH
66060: LD_INT 2
66062: PUSH
66063: EMPTY
66064: LIST
66065: LIST
66066: PUSH
66067: LD_INT 0
66069: PUSH
66070: LD_INT 2
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 1
66079: NEG
66080: PUSH
66081: LD_INT 1
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 2
66090: NEG
66091: PUSH
66092: LD_INT 0
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 2
66101: NEG
66102: PUSH
66103: LD_INT 1
66105: NEG
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 2
66113: NEG
66114: PUSH
66115: LD_INT 2
66117: NEG
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 1
66125: PUSH
66126: LD_INT 2
66128: NEG
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 2
66136: PUSH
66137: LD_INT 1
66139: NEG
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 3
66147: PUSH
66148: LD_INT 1
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 3
66157: PUSH
66158: LD_INT 2
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66190: LD_ADDR_VAR 0 25
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 0
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 0
66207: PUSH
66208: LD_INT 1
66210: NEG
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 1
66228: PUSH
66229: LD_INT 1
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 0
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 1
66248: NEG
66249: PUSH
66250: LD_INT 0
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 1
66259: NEG
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 1
66271: NEG
66272: PUSH
66273: LD_INT 2
66275: NEG
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 0
66283: PUSH
66284: LD_INT 2
66286: NEG
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: PUSH
66295: LD_INT 1
66297: NEG
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 2
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 2
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 2
66325: PUSH
66326: LD_INT 2
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 0
66345: PUSH
66346: LD_INT 2
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: PUSH
66353: LD_INT 1
66355: NEG
66356: PUSH
66357: LD_INT 1
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 2
66366: NEG
66367: PUSH
66368: LD_INT 0
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 2
66377: NEG
66378: PUSH
66379: LD_INT 1
66381: NEG
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 2
66389: NEG
66390: PUSH
66391: LD_INT 2
66393: NEG
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 3
66401: PUSH
66402: LD_INT 1
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 3
66411: PUSH
66412: LD_INT 2
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 2
66421: PUSH
66422: LD_INT 3
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: LD_INT 1
66431: PUSH
66432: LD_INT 3
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66464: LD_ADDR_VAR 0 26
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: LD_INT 0
66474: PUSH
66475: EMPTY
66476: LIST
66477: LIST
66478: PUSH
66479: LD_INT 0
66481: PUSH
66482: LD_INT 1
66484: NEG
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PUSH
66490: LD_INT 1
66492: PUSH
66493: LD_INT 0
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: LD_INT 1
66502: PUSH
66503: LD_INT 1
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 0
66512: PUSH
66513: LD_INT 1
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 1
66522: NEG
66523: PUSH
66524: LD_INT 0
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: LD_INT 1
66537: NEG
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 1
66545: NEG
66546: PUSH
66547: LD_INT 2
66549: NEG
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 0
66557: PUSH
66558: LD_INT 2
66560: NEG
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 1
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 2
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 2
66589: PUSH
66590: LD_INT 1
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 2
66599: PUSH
66600: LD_INT 2
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: LD_INT 2
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 0
66619: PUSH
66620: LD_INT 2
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 1
66629: NEG
66630: PUSH
66631: LD_INT 1
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 2
66651: NEG
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: NEG
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 2
66675: PUSH
66676: LD_INT 3
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: PUSH
66686: LD_INT 3
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 1
66695: NEG
66696: PUSH
66697: LD_INT 2
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 2
66706: NEG
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66740: LD_ADDR_VAR 0 27
66744: PUSH
66745: LD_INT 0
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 0
66757: PUSH
66758: LD_INT 1
66760: NEG
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: LD_INT 0
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 1
66778: PUSH
66779: LD_INT 1
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 0
66788: PUSH
66789: LD_INT 1
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 1
66798: NEG
66799: PUSH
66800: LD_INT 0
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: LD_INT 1
66809: NEG
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: LD_INT 2
66825: NEG
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 0
66833: PUSH
66834: LD_INT 2
66836: NEG
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: LD_INT 1
66847: NEG
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 2
66855: PUSH
66856: LD_INT 0
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 2
66865: PUSH
66866: LD_INT 1
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 2
66875: PUSH
66876: LD_INT 2
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 1
66885: PUSH
66886: LD_INT 2
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 0
66895: PUSH
66896: LD_INT 2
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 1
66905: NEG
66906: PUSH
66907: LD_INT 1
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PUSH
66914: LD_INT 2
66916: NEG
66917: PUSH
66918: LD_INT 0
66920: PUSH
66921: EMPTY
66922: LIST
66923: LIST
66924: PUSH
66925: LD_INT 2
66927: NEG
66928: PUSH
66929: LD_INT 1
66931: NEG
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 2
66939: NEG
66940: PUSH
66941: LD_INT 2
66943: NEG
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 1
66951: NEG
66952: PUSH
66953: LD_INT 2
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 2
66962: NEG
66963: PUSH
66964: LD_INT 1
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 3
66973: NEG
66974: PUSH
66975: LD_INT 1
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 3
66985: NEG
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67020: LD_ADDR_VAR 0 28
67024: PUSH
67025: LD_INT 0
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: LD_INT 1
67040: NEG
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: NEG
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: LD_INT 2
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 0
67113: PUSH
67114: LD_INT 2
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 1
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 2
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 2
67145: PUSH
67146: LD_INT 1
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 2
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 1
67165: PUSH
67166: LD_INT 2
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 0
67175: PUSH
67176: LD_INT 2
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 2
67196: NEG
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 2
67207: NEG
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 2
67219: NEG
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 2
67231: NEG
67232: PUSH
67233: LD_INT 3
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: NEG
67244: PUSH
67245: LD_INT 3
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 3
67255: NEG
67256: PUSH
67257: LD_INT 1
67259: NEG
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 3
67267: NEG
67268: PUSH
67269: LD_INT 2
67271: NEG
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67302: LD_ADDR_VAR 0 29
67306: PUSH
67307: LD_INT 0
67309: PUSH
67310: LD_INT 0
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 1
67330: PUSH
67331: LD_INT 0
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 1
67340: PUSH
67341: LD_INT 1
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: LD_INT 1
67353: PUSH
67354: EMPTY
67355: LIST
67356: LIST
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: LD_INT 0
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: NEG
67384: PUSH
67385: LD_INT 2
67387: NEG
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: LD_INT 2
67398: NEG
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 2
67417: PUSH
67418: LD_INT 0
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 2
67427: PUSH
67428: LD_INT 1
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 1
67437: PUSH
67438: LD_INT 2
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 0
67447: PUSH
67448: LD_INT 2
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: LD_INT 1
67457: NEG
67458: PUSH
67459: LD_INT 1
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: LD_INT 1
67472: NEG
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 2
67480: NEG
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 2
67492: NEG
67493: PUSH
67494: LD_INT 3
67496: NEG
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PUSH
67502: LD_INT 2
67504: PUSH
67505: LD_INT 1
67507: NEG
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 3
67515: PUSH
67516: LD_INT 1
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: LD_INT 3
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: LD_INT 1
67535: NEG
67536: PUSH
67537: LD_INT 2
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 3
67546: NEG
67547: PUSH
67548: LD_INT 2
67550: NEG
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67581: LD_ADDR_VAR 0 30
67585: PUSH
67586: LD_INT 0
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 0
67598: PUSH
67599: LD_INT 1
67601: NEG
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: LD_INT 1
67609: PUSH
67610: LD_INT 0
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: PUSH
67617: LD_INT 1
67619: PUSH
67620: LD_INT 1
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 0
67629: PUSH
67630: LD_INT 1
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 1
67639: NEG
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: LD_INT 1
67654: NEG
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 1
67662: NEG
67663: PUSH
67664: LD_INT 2
67666: NEG
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 0
67674: PUSH
67675: LD_INT 2
67677: NEG
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 1
67685: PUSH
67686: LD_INT 1
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 2
67696: PUSH
67697: LD_INT 0
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 2
67706: PUSH
67707: LD_INT 1
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 2
67716: PUSH
67717: LD_INT 2
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: LD_INT 2
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: LD_INT 1
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 2
67747: NEG
67748: PUSH
67749: LD_INT 0
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 2
67758: NEG
67759: PUSH
67760: LD_INT 1
67762: NEG
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: NEG
67771: PUSH
67772: LD_INT 3
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: LD_INT 2
67785: NEG
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 3
67793: PUSH
67794: LD_INT 2
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 3
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 2
67813: NEG
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 3
67824: NEG
67825: PUSH
67826: LD_INT 1
67828: NEG
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67859: LD_ADDR_VAR 0 31
67863: PUSH
67864: LD_INT 0
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: LD_INT 1
67879: NEG
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: LD_INT 1
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 1
67928: NEG
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 1
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 2
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 0
68003: PUSH
68004: LD_INT 2
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: LD_INT 1
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 2
68024: NEG
68025: PUSH
68026: LD_INT 1
68028: NEG
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 2
68036: NEG
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 2
68048: NEG
68049: PUSH
68050: LD_INT 3
68052: NEG
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 2
68060: PUSH
68061: LD_INT 1
68063: NEG
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 3
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 1
68081: PUSH
68082: LD_INT 3
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: LD_INT 2
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 3
68102: NEG
68103: PUSH
68104: LD_INT 2
68106: NEG
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: LIST
68136: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68137: LD_ADDR_VAR 0 32
68141: PUSH
68142: LD_INT 0
68144: PUSH
68145: LD_INT 0
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 0
68154: PUSH
68155: LD_INT 1
68157: NEG
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 1
68165: PUSH
68166: LD_INT 0
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 1
68175: PUSH
68176: LD_INT 1
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 0
68185: PUSH
68186: LD_INT 1
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 1
68195: NEG
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 1
68206: NEG
68207: PUSH
68208: LD_INT 1
68210: NEG
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 1
68218: NEG
68219: PUSH
68220: LD_INT 2
68222: NEG
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 0
68230: PUSH
68231: LD_INT 2
68233: NEG
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 1
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 2
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 2
68262: PUSH
68263: LD_INT 2
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: PUSH
68273: LD_INT 2
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 0
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: NEG
68293: PUSH
68294: LD_INT 1
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 2
68314: NEG
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 1
68326: NEG
68327: PUSH
68328: LD_INT 3
68330: NEG
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: LD_INT 2
68341: NEG
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 3
68349: PUSH
68350: LD_INT 2
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 2
68359: PUSH
68360: LD_INT 3
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 2
68369: NEG
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 3
68380: NEG
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68415: LD_ADDR_VAR 0 33
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: LD_INT 0
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 0
68432: PUSH
68433: LD_INT 1
68435: NEG
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 1
68443: PUSH
68444: LD_INT 0
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: LD_INT 1
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 0
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 1
68473: NEG
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 1
68484: NEG
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: NEG
68497: PUSH
68498: LD_INT 2
68500: NEG
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 1
68508: PUSH
68509: LD_INT 1
68511: NEG
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 2
68519: PUSH
68520: LD_INT 0
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 2
68529: PUSH
68530: LD_INT 1
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 1
68539: PUSH
68540: LD_INT 2
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 0
68549: PUSH
68550: LD_INT 2
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PUSH
68557: LD_INT 1
68559: NEG
68560: PUSH
68561: LD_INT 1
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PUSH
68568: LD_INT 2
68570: NEG
68571: PUSH
68572: LD_INT 0
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 2
68581: NEG
68582: PUSH
68583: LD_INT 1
68585: NEG
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 2
68593: NEG
68594: PUSH
68595: LD_INT 2
68597: NEG
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 2
68605: NEG
68606: PUSH
68607: LD_INT 3
68609: NEG
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 2
68617: PUSH
68618: LD_INT 1
68620: NEG
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PUSH
68626: LD_INT 3
68628: PUSH
68629: LD_INT 1
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 1
68638: PUSH
68639: LD_INT 3
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 1
68648: NEG
68649: PUSH
68650: LD_INT 2
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 3
68659: NEG
68660: PUSH
68661: LD_INT 2
68663: NEG
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68694: LD_ADDR_VAR 0 34
68698: PUSH
68699: LD_INT 0
68701: PUSH
68702: LD_INT 0
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 0
68711: PUSH
68712: LD_INT 1
68714: NEG
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 1
68722: PUSH
68723: LD_INT 0
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: LD_INT 1
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 0
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: NEG
68753: PUSH
68754: LD_INT 0
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 1
68763: NEG
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 1
68775: NEG
68776: PUSH
68777: LD_INT 2
68779: NEG
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 0
68787: PUSH
68788: LD_INT 2
68790: NEG
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 1
68798: PUSH
68799: LD_INT 1
68801: NEG
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 2
68809: PUSH
68810: LD_INT 1
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 2
68819: PUSH
68820: LD_INT 2
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: LD_INT 2
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: LD_INT 1
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 2
68850: NEG
68851: PUSH
68852: LD_INT 0
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 2
68861: NEG
68862: PUSH
68863: LD_INT 1
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 2
68873: NEG
68874: PUSH
68875: LD_INT 2
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: LD_INT 3
68889: NEG
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: LD_INT 2
68900: NEG
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 3
68908: PUSH
68909: LD_INT 2
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: LD_INT 3
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: PUSH
68926: LD_INT 2
68928: NEG
68929: PUSH
68930: LD_INT 1
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 3
68939: NEG
68940: PUSH
68941: LD_INT 1
68943: NEG
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68974: LD_ADDR_VAR 0 35
68978: PUSH
68979: LD_INT 0
68981: PUSH
68982: LD_INT 0
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 0
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 1
69012: PUSH
69013: LD_INT 1
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 0
69022: PUSH
69023: LD_INT 1
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: LD_INT 1
69032: NEG
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 1
69043: NEG
69044: PUSH
69045: LD_INT 1
69047: NEG
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 2
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 2
69065: NEG
69066: PUSH
69067: LD_INT 1
69069: NEG
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69086: LD_ADDR_VAR 0 36
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 0
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 0
69103: PUSH
69104: LD_INT 1
69106: NEG
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: LD_INT 0
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 1
69144: NEG
69145: PUSH
69146: LD_INT 0
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: LD_INT 2
69171: NEG
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 1
69179: PUSH
69180: LD_INT 2
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69198: LD_ADDR_VAR 0 37
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: LD_INT 0
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: LD_INT 1
69218: NEG
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 1
69226: PUSH
69227: LD_INT 0
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 0
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: LD_INT 0
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: LD_INT 1
69271: NEG
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: LD_INT 1
69279: PUSH
69280: LD_INT 1
69282: NEG
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 1
69290: NEG
69291: PUSH
69292: LD_INT 1
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69310: LD_ADDR_VAR 0 38
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 0
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: LD_INT 1
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 0
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: LD_INT 0
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 1
69379: NEG
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 2
69391: PUSH
69392: LD_INT 1
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 2
69401: NEG
69402: PUSH
69403: LD_INT 1
69405: NEG
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69422: LD_ADDR_VAR 0 39
69426: PUSH
69427: LD_INT 0
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 0
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 1
69450: PUSH
69451: LD_INT 0
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 0
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 1
69491: NEG
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: NEG
69504: PUSH
69505: LD_INT 2
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: LD_INT 2
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69534: LD_ADDR_VAR 0 40
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 0
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: LD_INT 0
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 0
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 1
69592: NEG
69593: PUSH
69594: LD_INT 0
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 1
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: NEG
69627: PUSH
69628: LD_INT 1
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69646: LD_ADDR_VAR 0 41
69650: PUSH
69651: LD_INT 0
69653: PUSH
69654: LD_INT 0
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 0
69663: PUSH
69664: LD_INT 1
69666: NEG
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: LD_INT 1
69674: PUSH
69675: LD_INT 0
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: PUSH
69682: LD_INT 1
69684: PUSH
69685: LD_INT 1
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: LD_INT 0
69694: PUSH
69695: LD_INT 1
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: PUSH
69706: LD_INT 0
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 1
69715: NEG
69716: PUSH
69717: LD_INT 1
69719: NEG
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 1
69727: NEG
69728: PUSH
69729: LD_INT 2
69731: NEG
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: LD_INT 1
69742: NEG
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 2
69750: PUSH
69751: LD_INT 0
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 2
69760: PUSH
69761: LD_INT 1
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 2
69770: PUSH
69771: LD_INT 2
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: LD_INT 2
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 1
69790: NEG
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 2
69801: NEG
69802: PUSH
69803: LD_INT 0
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 2
69812: NEG
69813: PUSH
69814: LD_INT 1
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 2
69824: NEG
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 2
69836: NEG
69837: PUSH
69838: LD_INT 3
69840: NEG
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 2
69848: PUSH
69849: LD_INT 1
69851: NEG
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 3
69859: PUSH
69860: LD_INT 0
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 3
69869: PUSH
69870: LD_INT 1
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 3
69879: PUSH
69880: LD_INT 2
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 3
69889: PUSH
69890: LD_INT 3
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 2
69899: PUSH
69900: LD_INT 3
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 2
69909: NEG
69910: PUSH
69911: LD_INT 1
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 3
69920: NEG
69921: PUSH
69922: LD_INT 0
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 3
69931: NEG
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 3
69943: NEG
69944: PUSH
69945: LD_INT 2
69947: NEG
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 3
69955: NEG
69956: PUSH
69957: LD_INT 3
69959: NEG
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69996: LD_ADDR_VAR 0 42
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: LD_INT 0
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 0
70013: PUSH
70014: LD_INT 1
70016: NEG
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: PUSH
70025: LD_INT 0
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: LD_INT 1
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 0
70044: PUSH
70045: LD_INT 1
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: LD_INT 0
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: LD_INT 2
70081: NEG
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 0
70089: PUSH
70090: LD_INT 2
70092: NEG
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 1
70100: PUSH
70101: LD_INT 1
70103: NEG
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 2
70111: PUSH
70112: LD_INT 1
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 2
70121: PUSH
70122: LD_INT 2
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 1
70131: PUSH
70132: LD_INT 2
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: LD_INT 2
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 1
70151: NEG
70152: PUSH
70153: LD_INT 1
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 2
70162: NEG
70163: PUSH
70164: LD_INT 1
70166: NEG
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: LD_INT 2
70178: NEG
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 2
70186: NEG
70187: PUSH
70188: LD_INT 3
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: LD_INT 3
70202: NEG
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 0
70210: PUSH
70211: LD_INT 3
70213: NEG
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 1
70221: PUSH
70222: LD_INT 2
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 3
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 3
70242: PUSH
70243: LD_INT 3
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 2
70252: PUSH
70253: LD_INT 3
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 3
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: LD_INT 3
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: LD_INT 2
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 3
70293: NEG
70294: PUSH
70295: LD_INT 2
70297: NEG
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 3
70305: NEG
70306: PUSH
70307: LD_INT 3
70309: NEG
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70346: LD_ADDR_VAR 0 43
70350: PUSH
70351: LD_INT 0
70353: PUSH
70354: LD_INT 0
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 0
70363: PUSH
70364: LD_INT 1
70366: NEG
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: LD_INT 0
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 1
70384: PUSH
70385: LD_INT 1
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 0
70394: PUSH
70395: LD_INT 1
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 1
70427: NEG
70428: PUSH
70429: LD_INT 2
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 0
70439: PUSH
70440: LD_INT 2
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 2
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 2
70471: PUSH
70472: LD_INT 1
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 1
70481: PUSH
70482: LD_INT 2
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 0
70491: PUSH
70492: LD_INT 2
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 1
70501: NEG
70502: PUSH
70503: LD_INT 1
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 2
70512: NEG
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 2
70523: NEG
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: NEG
70536: PUSH
70537: LD_INT 3
70539: NEG
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 3
70550: NEG
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: PUSH
70559: LD_INT 2
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: PUSH
70570: LD_INT 1
70572: NEG
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 3
70580: PUSH
70581: LD_INT 0
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 3
70590: PUSH
70591: LD_INT 1
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 1
70600: PUSH
70601: LD_INT 3
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: LD_INT 3
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 1
70620: NEG
70621: PUSH
70622: LD_INT 2
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 2
70631: NEG
70632: PUSH
70633: LD_INT 1
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 3
70642: NEG
70643: PUSH
70644: LD_INT 0
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 3
70653: NEG
70654: PUSH
70655: LD_INT 1
70657: NEG
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70694: LD_ADDR_VAR 0 44
70698: PUSH
70699: LD_INT 0
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 1
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 1
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 0
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: LD_INT 0
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: LD_INT 1
70767: NEG
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 1
70775: NEG
70776: PUSH
70777: LD_INT 2
70779: NEG
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 1
70787: PUSH
70788: LD_INT 1
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 2
70808: PUSH
70809: LD_INT 1
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 2
70818: PUSH
70819: LD_INT 2
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: PUSH
70829: LD_INT 2
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: LD_INT 1
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: LD_INT 0
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: LD_INT 1
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 2
70872: NEG
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 3
70888: NEG
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 2
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 3
70907: PUSH
70908: LD_INT 0
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 3
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 3
70927: PUSH
70928: LD_INT 2
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 3
70937: PUSH
70938: LD_INT 3
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 2
70947: PUSH
70948: LD_INT 3
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 2
70957: NEG
70958: PUSH
70959: LD_INT 1
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 3
70968: NEG
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 3
70979: NEG
70980: PUSH
70981: LD_INT 1
70983: NEG
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 3
70991: NEG
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 3
71003: NEG
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71044: LD_ADDR_VAR 0 45
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: LD_INT 0
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 1
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 0
71092: PUSH
71093: LD_INT 1
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 1
71102: NEG
71103: PUSH
71104: LD_INT 0
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 1
71125: NEG
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 0
71137: PUSH
71138: LD_INT 2
71140: NEG
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: LD_INT 1
71151: NEG
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: LD_INT 1
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: LD_INT 2
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 1
71179: PUSH
71180: LD_INT 2
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 0
71189: PUSH
71190: LD_INT 2
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: LD_INT 1
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: LD_INT 1
71214: NEG
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 2
71222: NEG
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 2
71234: NEG
71235: PUSH
71236: LD_INT 3
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: LD_INT 3
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 0
71258: PUSH
71259: LD_INT 3
71261: NEG
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: PUSH
71270: LD_INT 2
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 3
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: PUSH
71291: LD_INT 3
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: LD_INT 3
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: LD_INT 3
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 0
71320: PUSH
71321: LD_INT 3
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 1
71330: NEG
71331: PUSH
71332: LD_INT 2
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: LD_INT 3
71341: NEG
71342: PUSH
71343: LD_INT 2
71345: NEG
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 3
71353: NEG
71354: PUSH
71355: LD_INT 3
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71394: LD_ADDR_VAR 0 46
71398: PUSH
71399: LD_INT 0
71401: PUSH
71402: LD_INT 0
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 0
71411: PUSH
71412: LD_INT 1
71414: NEG
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 1
71432: PUSH
71433: LD_INT 1
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 0
71442: PUSH
71443: LD_INT 1
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 1
71452: NEG
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 1
71475: NEG
71476: PUSH
71477: LD_INT 2
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 0
71487: PUSH
71488: LD_INT 2
71490: NEG
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 1
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 2
71519: PUSH
71520: LD_INT 1
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 1
71529: PUSH
71530: LD_INT 2
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 0
71539: PUSH
71540: LD_INT 2
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 1
71549: NEG
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 2
71571: NEG
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 3
71587: NEG
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: LD_INT 3
71598: NEG
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 1
71606: PUSH
71607: LD_INT 2
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: PUSH
71629: LD_INT 0
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 3
71638: PUSH
71639: LD_INT 1
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 1
71648: PUSH
71649: LD_INT 3
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: LD_INT 3
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 1
71668: NEG
71669: PUSH
71670: LD_INT 2
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 2
71679: NEG
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 3
71690: NEG
71691: PUSH
71692: LD_INT 0
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 3
71701: NEG
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71742: LD_ADDR_VAR 0 47
71746: PUSH
71747: LD_INT 0
71749: PUSH
71750: LD_INT 0
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 0
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: LD_INT 0
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 0
71790: PUSH
71791: LD_INT 1
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 1
71823: NEG
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: LD_INT 0
71835: PUSH
71836: LD_INT 2
71838: NEG
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 1
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 2
71857: NEG
71858: PUSH
71859: LD_INT 1
71861: NEG
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 2
71869: NEG
71870: PUSH
71871: LD_INT 2
71873: NEG
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: LIST
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71893: LD_ADDR_VAR 0 48
71897: PUSH
71898: LD_INT 0
71900: PUSH
71901: LD_INT 0
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 0
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 1
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 1
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: LD_INT 0
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: LD_INT 1
71966: NEG
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 1
71974: NEG
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 0
71986: PUSH
71987: LD_INT 2
71989: NEG
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 1
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 2
72008: PUSH
72009: LD_INT 0
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 2
72018: PUSH
72019: LD_INT 1
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72040: LD_ADDR_VAR 0 49
72044: PUSH
72045: LD_INT 0
72047: PUSH
72048: LD_INT 0
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 0
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: LD_INT 1
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: NEG
72110: PUSH
72111: LD_INT 1
72113: NEG
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: LD_INT 1
72124: NEG
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 2
72132: PUSH
72133: LD_INT 0
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 2
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 2
72152: PUSH
72153: LD_INT 2
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 1
72162: PUSH
72163: LD_INT 2
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72184: LD_ADDR_VAR 0 50
72188: PUSH
72189: LD_INT 0
72191: PUSH
72192: LD_INT 0
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 0
72201: PUSH
72202: LD_INT 1
72204: NEG
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: PUSH
72213: LD_INT 0
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 1
72222: PUSH
72223: LD_INT 1
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: LD_INT 1
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 1
72242: NEG
72243: PUSH
72244: LD_INT 0
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: NEG
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 2
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: LD_INT 2
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 1
72285: PUSH
72286: LD_INT 2
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 0
72295: PUSH
72296: LD_INT 2
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 1
72305: NEG
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72328: LD_ADDR_VAR 0 51
72332: PUSH
72333: LD_INT 0
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 0
72345: PUSH
72346: LD_INT 1
72348: NEG
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: PUSH
72357: LD_INT 0
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 1
72366: PUSH
72367: LD_INT 1
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: LD_INT 1
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: PUSH
72384: LD_INT 1
72386: NEG
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 1
72409: PUSH
72410: LD_INT 2
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: LD_INT 2
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: LD_INT 1
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 2
72440: NEG
72441: PUSH
72442: LD_INT 0
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 2
72451: NEG
72452: PUSH
72453: LD_INT 1
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72475: LD_ADDR_VAR 0 52
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: LD_INT 0
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 0
72492: PUSH
72493: LD_INT 1
72495: NEG
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: LD_INT 0
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 0
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: PUSH
72531: LD_INT 1
72533: NEG
72534: PUSH
72535: LD_INT 0
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 2
72560: NEG
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 1
72568: NEG
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 2
72579: NEG
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 2
72590: NEG
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 2
72602: NEG
72603: PUSH
72604: LD_INT 2
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72626: LD_ADDR_VAR 0 53
72630: PUSH
72631: LD_INT 0
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 0
72643: PUSH
72644: LD_INT 1
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 1
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: PUSH
72665: LD_INT 1
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 0
72674: PUSH
72675: LD_INT 1
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: LD_INT 1
72684: NEG
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 1
72695: NEG
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: LD_INT 2
72711: NEG
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 2
72722: NEG
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 2
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 2
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 2
72761: PUSH
72762: LD_INT 2
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: PUSH
72772: LD_INT 2
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: LD_INT 2
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: LD_INT 1
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 2
72802: NEG
72803: PUSH
72804: LD_INT 0
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 2
72813: NEG
72814: PUSH
72815: LD_INT 1
72817: NEG
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 2
72825: NEG
72826: PUSH
72827: LD_INT 2
72829: NEG
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72856: LD_ADDR_VAR 0 54
72860: PUSH
72861: LD_INT 0
72863: PUSH
72864: LD_INT 0
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: LD_INT 0
72873: PUSH
72874: LD_INT 1
72876: NEG
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 1
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 1
72894: PUSH
72895: LD_INT 1
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 0
72904: PUSH
72905: LD_INT 1
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 1
72914: NEG
72915: PUSH
72916: LD_INT 0
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 1
72937: NEG
72938: PUSH
72939: LD_INT 2
72941: NEG
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 0
72949: PUSH
72950: LD_INT 2
72952: NEG
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 2
72981: PUSH
72982: LD_INT 1
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 2
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: PUSH
73002: LD_INT 2
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 0
73011: PUSH
73012: LD_INT 2
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: LD_INT 1
73021: NEG
73022: PUSH
73023: LD_INT 1
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 2
73032: NEG
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: NEG
73044: PUSH
73045: LD_INT 1
73047: NEG
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 2
73055: NEG
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73086: LD_ADDR_VAR 0 55
73090: PUSH
73091: LD_INT 0
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 0
73103: PUSH
73104: LD_INT 1
73106: NEG
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: LD_INT 0
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 1
73124: PUSH
73125: LD_INT 1
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 0
73134: PUSH
73135: LD_INT 1
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 0
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 1
73155: NEG
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 1
73167: NEG
73168: PUSH
73169: LD_INT 2
73171: NEG
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 0
73179: PUSH
73180: LD_INT 2
73182: NEG
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 1
73190: PUSH
73191: LD_INT 1
73193: NEG
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 2
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 2
73211: PUSH
73212: LD_INT 1
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 2
73221: PUSH
73222: LD_INT 2
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: PUSH
73232: LD_INT 2
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: LD_INT 2
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 1
73251: NEG
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 2
73262: NEG
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: LD_INT 1
73277: NEG
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 2
73285: NEG
73286: PUSH
73287: LD_INT 2
73289: NEG
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73316: LD_ADDR_VAR 0 56
73320: PUSH
73321: LD_INT 0
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 0
73333: PUSH
73334: LD_INT 1
73336: NEG
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 1
73344: PUSH
73345: LD_INT 0
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 1
73354: PUSH
73355: LD_INT 1
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 0
73364: PUSH
73365: LD_INT 1
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: LD_INT 0
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 1
73385: NEG
73386: PUSH
73387: LD_INT 1
73389: NEG
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 1
73397: NEG
73398: PUSH
73399: LD_INT 2
73401: NEG
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 1
73420: PUSH
73421: LD_INT 1
73423: NEG
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 2
73441: PUSH
73442: LD_INT 1
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 2
73451: PUSH
73452: LD_INT 2
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: LD_INT 1
73461: PUSH
73462: LD_INT 2
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: PUSH
73469: LD_INT 0
73471: PUSH
73472: LD_INT 2
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 1
73481: NEG
73482: PUSH
73483: LD_INT 1
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 2
73492: NEG
73493: PUSH
73494: LD_INT 0
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 2
73503: NEG
73504: PUSH
73505: LD_INT 1
73507: NEG
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 2
73515: NEG
73516: PUSH
73517: LD_INT 2
73519: NEG
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73546: LD_ADDR_VAR 0 57
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: LD_INT 0
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: PUSH
73561: LD_INT 0
73563: PUSH
73564: LD_INT 1
73566: NEG
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 1
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 1
73584: PUSH
73585: LD_INT 1
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PUSH
73592: LD_INT 0
73594: PUSH
73595: LD_INT 1
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 1
73604: NEG
73605: PUSH
73606: LD_INT 0
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: NEG
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 1
73627: NEG
73628: PUSH
73629: LD_INT 2
73631: NEG
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 0
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 1
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 2
73661: PUSH
73662: LD_INT 0
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 2
73671: PUSH
73672: LD_INT 1
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 2
73681: PUSH
73682: LD_INT 2
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: PUSH
73692: LD_INT 2
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: PUSH
73699: LD_INT 0
73701: PUSH
73702: LD_INT 2
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: LD_INT 1
73711: NEG
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 2
73722: NEG
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: LD_INT 1
73737: NEG
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 2
73745: NEG
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73776: LD_ADDR_VAR 0 58
73780: PUSH
73781: LD_INT 0
73783: PUSH
73784: LD_INT 0
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: LD_INT 1
73796: NEG
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 1
73804: PUSH
73805: LD_INT 0
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 1
73814: PUSH
73815: LD_INT 1
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 0
73824: PUSH
73825: LD_INT 1
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 1
73845: NEG
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 1
73857: NEG
73858: PUSH
73859: LD_INT 2
73861: NEG
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 0
73869: PUSH
73870: LD_INT 2
73872: NEG
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: LD_INT 1
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 2
73901: PUSH
73902: LD_INT 1
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 2
73911: PUSH
73912: LD_INT 2
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 1
73921: PUSH
73922: LD_INT 2
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 0
73931: PUSH
73932: LD_INT 2
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 1
73941: NEG
73942: PUSH
73943: LD_INT 1
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 2
73952: NEG
73953: PUSH
73954: LD_INT 0
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 2
73963: NEG
73964: PUSH
73965: LD_INT 1
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 2
73975: NEG
73976: PUSH
73977: LD_INT 2
73979: NEG
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74006: LD_ADDR_VAR 0 59
74010: PUSH
74011: LD_INT 0
74013: PUSH
74014: LD_INT 0
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: LD_INT 1
74026: NEG
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 1
74034: PUSH
74035: LD_INT 0
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 1
74044: PUSH
74045: LD_INT 1
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 0
74054: PUSH
74055: LD_INT 1
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 1
74064: NEG
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 1
74075: NEG
74076: PUSH
74077: LD_INT 1
74079: NEG
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: LIST
74089: LIST
74090: LIST
74091: LIST
74092: LIST
74093: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74094: LD_ADDR_VAR 0 60
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: LD_INT 0
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: LD_INT 1
74114: NEG
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: LD_INT 1
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 1
74163: NEG
74164: PUSH
74165: LD_INT 1
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: LIST
74181: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74182: LD_ADDR_VAR 0 61
74186: PUSH
74187: LD_INT 0
74189: PUSH
74190: LD_INT 0
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 0
74199: PUSH
74200: LD_INT 1
74202: NEG
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 1
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: PUSH
74221: LD_INT 1
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: LD_INT 1
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 1
74251: NEG
74252: PUSH
74253: LD_INT 1
74255: NEG
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74270: LD_ADDR_VAR 0 62
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: LD_INT 0
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: LD_INT 1
74290: NEG
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 1
74298: PUSH
74299: LD_INT 0
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: PUSH
74309: LD_INT 1
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 0
74318: PUSH
74319: LD_INT 1
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 1
74328: NEG
74329: PUSH
74330: LD_INT 0
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 1
74339: NEG
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74358: LD_ADDR_VAR 0 63
74362: PUSH
74363: LD_INT 0
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 0
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 1
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 0
74406: PUSH
74407: LD_INT 1
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 1
74416: NEG
74417: PUSH
74418: LD_INT 0
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: LD_INT 1
74431: NEG
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74446: LD_ADDR_VAR 0 64
74450: PUSH
74451: LD_INT 0
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 1
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: NEG
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: ST_TO_ADDR
// end ; 1 :
74534: GO 80431
74536: LD_INT 1
74538: DOUBLE
74539: EQUAL
74540: IFTRUE 74544
74542: GO 77167
74544: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74545: LD_ADDR_VAR 0 11
74549: PUSH
74550: LD_INT 1
74552: NEG
74553: PUSH
74554: LD_INT 3
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: LD_INT 3
74567: NEG
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 1
74575: PUSH
74576: LD_INT 2
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: LIST
74588: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74589: LD_ADDR_VAR 0 12
74593: PUSH
74594: LD_INT 2
74596: PUSH
74597: LD_INT 1
74599: NEG
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: LD_INT 0
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 3
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: LIST
74629: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74630: LD_ADDR_VAR 0 13
74634: PUSH
74635: LD_INT 3
74637: PUSH
74638: LD_INT 2
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 3
74647: PUSH
74648: LD_INT 3
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 2
74657: PUSH
74658: LD_INT 3
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: LIST
74669: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74670: LD_ADDR_VAR 0 14
74674: PUSH
74675: LD_INT 1
74677: PUSH
74678: LD_INT 3
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 0
74687: PUSH
74688: LD_INT 3
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 1
74697: NEG
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: LIST
74710: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74711: LD_ADDR_VAR 0 15
74715: PUSH
74716: LD_INT 2
74718: NEG
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 3
74729: NEG
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 3
74740: NEG
74741: PUSH
74742: LD_INT 1
74744: NEG
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: LIST
74754: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74755: LD_ADDR_VAR 0 16
74759: PUSH
74760: LD_INT 2
74762: NEG
74763: PUSH
74764: LD_INT 3
74766: NEG
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 3
74774: NEG
74775: PUSH
74776: LD_INT 2
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 3
74786: NEG
74787: PUSH
74788: LD_INT 3
74790: NEG
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: LIST
74800: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74801: LD_ADDR_VAR 0 17
74805: PUSH
74806: LD_INT 1
74808: NEG
74809: PUSH
74810: LD_INT 3
74812: NEG
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 0
74820: PUSH
74821: LD_INT 3
74823: NEG
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 1
74831: PUSH
74832: LD_INT 2
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: LIST
74844: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74845: LD_ADDR_VAR 0 18
74849: PUSH
74850: LD_INT 2
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 3
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 3
74873: PUSH
74874: LD_INT 1
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: LIST
74885: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74886: LD_ADDR_VAR 0 19
74890: PUSH
74891: LD_INT 3
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 3
74903: PUSH
74904: LD_INT 3
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 2
74913: PUSH
74914: LD_INT 3
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: LIST
74925: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74926: LD_ADDR_VAR 0 20
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: LD_INT 3
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: LD_INT 3
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PUSH
74951: LD_INT 1
74953: NEG
74954: PUSH
74955: LD_INT 2
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: LIST
74966: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74967: LD_ADDR_VAR 0 21
74971: PUSH
74972: LD_INT 2
74974: NEG
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 3
74985: NEG
74986: PUSH
74987: LD_INT 0
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 3
74996: NEG
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75011: LD_ADDR_VAR 0 22
75015: PUSH
75016: LD_INT 2
75018: NEG
75019: PUSH
75020: LD_INT 3
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 3
75030: NEG
75031: PUSH
75032: LD_INT 2
75034: NEG
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 3
75042: NEG
75043: PUSH
75044: LD_INT 3
75046: NEG
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: LIST
75056: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75057: LD_ADDR_VAR 0 23
75061: PUSH
75062: LD_INT 0
75064: PUSH
75065: LD_INT 3
75067: NEG
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: LD_INT 4
75079: NEG
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: LD_INT 3
75090: NEG
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: LIST
75100: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75101: LD_ADDR_VAR 0 24
75105: PUSH
75106: LD_INT 3
75108: PUSH
75109: LD_INT 0
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 3
75118: PUSH
75119: LD_INT 1
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 4
75129: PUSH
75130: LD_INT 1
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: LIST
75141: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75142: LD_ADDR_VAR 0 25
75146: PUSH
75147: LD_INT 3
75149: PUSH
75150: LD_INT 3
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 4
75159: PUSH
75160: LD_INT 3
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 3
75169: PUSH
75170: LD_INT 4
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: LIST
75181: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75182: LD_ADDR_VAR 0 26
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: LD_INT 3
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: LD_INT 4
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 1
75209: NEG
75210: PUSH
75211: LD_INT 3
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: LIST
75222: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75223: LD_ADDR_VAR 0 27
75227: PUSH
75228: LD_INT 3
75230: NEG
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 3
75241: NEG
75242: PUSH
75243: LD_INT 1
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 4
75252: NEG
75253: PUSH
75254: LD_INT 1
75256: NEG
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: LIST
75266: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75267: LD_ADDR_VAR 0 28
75271: PUSH
75272: LD_INT 3
75274: NEG
75275: PUSH
75276: LD_INT 3
75278: NEG
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 3
75286: NEG
75287: PUSH
75288: LD_INT 4
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 4
75298: NEG
75299: PUSH
75300: LD_INT 3
75302: NEG
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: LIST
75312: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75313: LD_ADDR_VAR 0 29
75317: PUSH
75318: LD_INT 1
75320: NEG
75321: PUSH
75322: LD_INT 3
75324: NEG
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: LD_INT 3
75335: NEG
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: LD_INT 2
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: LD_INT 4
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 0
75366: PUSH
75367: LD_INT 4
75369: NEG
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 1
75377: PUSH
75378: LD_INT 3
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 1
75388: NEG
75389: PUSH
75390: LD_INT 5
75392: NEG
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 0
75400: PUSH
75401: LD_INT 5
75403: NEG
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 1
75411: PUSH
75412: LD_INT 4
75414: NEG
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: NEG
75423: PUSH
75424: LD_INT 6
75426: NEG
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 6
75437: NEG
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 5
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75468: LD_ADDR_VAR 0 30
75472: PUSH
75473: LD_INT 2
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 3
75486: PUSH
75487: LD_INT 0
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 3
75496: PUSH
75497: LD_INT 1
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 3
75506: PUSH
75507: LD_INT 1
75509: NEG
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 4
75517: PUSH
75518: LD_INT 0
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 4
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 4
75537: PUSH
75538: LD_INT 1
75540: NEG
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 5
75548: PUSH
75549: LD_INT 0
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 5
75558: PUSH
75559: LD_INT 1
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 5
75568: PUSH
75569: LD_INT 1
75571: NEG
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 6
75579: PUSH
75580: LD_INT 0
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 6
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75611: LD_ADDR_VAR 0 31
75615: PUSH
75616: LD_INT 3
75618: PUSH
75619: LD_INT 2
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 3
75628: PUSH
75629: LD_INT 3
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 2
75638: PUSH
75639: LD_INT 3
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 4
75648: PUSH
75649: LD_INT 3
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 4
75658: PUSH
75659: LD_INT 4
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 3
75668: PUSH
75669: LD_INT 4
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 5
75678: PUSH
75679: LD_INT 4
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 5
75688: PUSH
75689: LD_INT 5
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 4
75698: PUSH
75699: LD_INT 5
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 6
75708: PUSH
75709: LD_INT 5
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 6
75718: PUSH
75719: LD_INT 6
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_INT 5
75728: PUSH
75729: LD_INT 6
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75750: LD_ADDR_VAR 0 32
75754: PUSH
75755: LD_INT 1
75757: PUSH
75758: LD_INT 3
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: LD_INT 3
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: LD_INT 2
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: PUSH
75789: LD_INT 4
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 0
75798: PUSH
75799: LD_INT 4
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: LD_INT 3
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 1
75819: PUSH
75820: LD_INT 5
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 0
75829: PUSH
75830: LD_INT 5
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 1
75839: NEG
75840: PUSH
75841: LD_INT 4
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: LD_INT 6
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: LD_INT 0
75860: PUSH
75861: LD_INT 6
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: LD_INT 5
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: LIST
75889: LIST
75890: LIST
75891: LIST
75892: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75893: LD_ADDR_VAR 0 33
75897: PUSH
75898: LD_INT 2
75900: NEG
75901: PUSH
75902: LD_INT 1
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 3
75911: NEG
75912: PUSH
75913: LD_INT 0
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: LD_INT 1
75926: NEG
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 3
75934: NEG
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 4
75945: NEG
75946: PUSH
75947: LD_INT 0
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 4
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 4
75968: NEG
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 5
75979: NEG
75980: PUSH
75981: LD_INT 0
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 5
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 5
76002: NEG
76003: PUSH
76004: LD_INT 1
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 6
76013: NEG
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 6
76024: NEG
76025: PUSH
76026: LD_INT 1
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76048: LD_ADDR_VAR 0 34
76052: PUSH
76053: LD_INT 2
76055: NEG
76056: PUSH
76057: LD_INT 3
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 3
76067: NEG
76068: PUSH
76069: LD_INT 2
76071: NEG
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 3
76079: NEG
76080: PUSH
76081: LD_INT 3
76083: NEG
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 3
76091: NEG
76092: PUSH
76093: LD_INT 4
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 4
76103: NEG
76104: PUSH
76105: LD_INT 3
76107: NEG
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 4
76115: NEG
76116: PUSH
76117: LD_INT 4
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 4
76127: NEG
76128: PUSH
76129: LD_INT 5
76131: NEG
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 5
76139: NEG
76140: PUSH
76141: LD_INT 4
76143: NEG
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 5
76151: NEG
76152: PUSH
76153: LD_INT 5
76155: NEG
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 5
76163: NEG
76164: PUSH
76165: LD_INT 6
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 6
76175: NEG
76176: PUSH
76177: LD_INT 5
76179: NEG
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 6
76187: NEG
76188: PUSH
76189: LD_INT 6
76191: NEG
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76211: LD_ADDR_VAR 0 41
76215: PUSH
76216: LD_INT 0
76218: PUSH
76219: LD_INT 2
76221: NEG
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 1
76229: NEG
76230: PUSH
76231: LD_INT 3
76233: NEG
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 1
76241: PUSH
76242: LD_INT 2
76244: NEG
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: LIST
76254: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76255: LD_ADDR_VAR 0 42
76259: PUSH
76260: LD_INT 2
76262: PUSH
76263: LD_INT 0
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 2
76272: PUSH
76273: LD_INT 1
76275: NEG
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: PUSH
76281: LD_INT 3
76283: PUSH
76284: LD_INT 1
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76296: LD_ADDR_VAR 0 43
76300: PUSH
76301: LD_INT 2
76303: PUSH
76304: LD_INT 2
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PUSH
76311: LD_INT 3
76313: PUSH
76314: LD_INT 2
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 2
76323: PUSH
76324: LD_INT 3
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: LIST
76335: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76336: LD_ADDR_VAR 0 44
76340: PUSH
76341: LD_INT 0
76343: PUSH
76344: LD_INT 2
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 1
76353: PUSH
76354: LD_INT 3
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 1
76363: NEG
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: LIST
76376: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76377: LD_ADDR_VAR 0 45
76381: PUSH
76382: LD_INT 2
76384: NEG
76385: PUSH
76386: LD_INT 0
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 2
76395: NEG
76396: PUSH
76397: LD_INT 1
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 3
76406: NEG
76407: PUSH
76408: LD_INT 1
76410: NEG
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: LIST
76420: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76421: LD_ADDR_VAR 0 46
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 2
76440: NEG
76441: PUSH
76442: LD_INT 3
76444: NEG
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 3
76452: NEG
76453: PUSH
76454: LD_INT 2
76456: NEG
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: LIST
76466: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76467: LD_ADDR_VAR 0 47
76471: PUSH
76472: LD_INT 2
76474: NEG
76475: PUSH
76476: LD_INT 3
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 1
76486: NEG
76487: PUSH
76488: LD_INT 3
76490: NEG
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76500: LD_ADDR_VAR 0 48
76504: PUSH
76505: LD_INT 1
76507: PUSH
76508: LD_INT 2
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 2
76518: PUSH
76519: LD_INT 1
76521: NEG
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76531: LD_ADDR_VAR 0 49
76535: PUSH
76536: LD_INT 3
76538: PUSH
76539: LD_INT 1
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 3
76548: PUSH
76549: LD_INT 2
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76560: LD_ADDR_VAR 0 50
76564: PUSH
76565: LD_INT 2
76567: PUSH
76568: LD_INT 3
76570: PUSH
76571: EMPTY
76572: LIST
76573: LIST
76574: PUSH
76575: LD_INT 1
76577: PUSH
76578: LD_INT 3
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76589: LD_ADDR_VAR 0 51
76593: PUSH
76594: LD_INT 1
76596: NEG
76597: PUSH
76598: LD_INT 2
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 2
76607: NEG
76608: PUSH
76609: LD_INT 1
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76620: LD_ADDR_VAR 0 52
76624: PUSH
76625: LD_INT 3
76627: NEG
76628: PUSH
76629: LD_INT 1
76631: NEG
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 3
76639: NEG
76640: PUSH
76641: LD_INT 2
76643: NEG
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76653: LD_ADDR_VAR 0 53
76657: PUSH
76658: LD_INT 1
76660: NEG
76661: PUSH
76662: LD_INT 3
76664: NEG
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: LD_INT 3
76675: NEG
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 1
76683: PUSH
76684: LD_INT 2
76686: NEG
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: LIST
76696: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76697: LD_ADDR_VAR 0 54
76701: PUSH
76702: LD_INT 2
76704: PUSH
76705: LD_INT 1
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 3
76715: PUSH
76716: LD_INT 0
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 3
76725: PUSH
76726: LD_INT 1
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: LIST
76737: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76738: LD_ADDR_VAR 0 55
76742: PUSH
76743: LD_INT 3
76745: PUSH
76746: LD_INT 2
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 3
76755: PUSH
76756: LD_INT 3
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: LD_INT 3
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: LIST
76777: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76778: LD_ADDR_VAR 0 56
76782: PUSH
76783: LD_INT 1
76785: PUSH
76786: LD_INT 3
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: LD_INT 3
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: NEG
76806: PUSH
76807: LD_INT 2
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: LIST
76818: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76819: LD_ADDR_VAR 0 57
76823: PUSH
76824: LD_INT 2
76826: NEG
76827: PUSH
76828: LD_INT 1
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 3
76837: NEG
76838: PUSH
76839: LD_INT 0
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 3
76848: NEG
76849: PUSH
76850: LD_INT 1
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: LIST
76862: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76863: LD_ADDR_VAR 0 58
76867: PUSH
76868: LD_INT 2
76870: NEG
76871: PUSH
76872: LD_INT 3
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 3
76882: NEG
76883: PUSH
76884: LD_INT 2
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 3
76894: NEG
76895: PUSH
76896: LD_INT 3
76898: NEG
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: LIST
76908: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76909: LD_ADDR_VAR 0 59
76913: PUSH
76914: LD_INT 1
76916: NEG
76917: PUSH
76918: LD_INT 2
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 0
76928: PUSH
76929: LD_INT 2
76931: NEG
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: LIST
76952: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76953: LD_ADDR_VAR 0 60
76957: PUSH
76958: LD_INT 1
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 2
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 2
76981: PUSH
76982: LD_INT 1
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: LIST
76993: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76994: LD_ADDR_VAR 0 61
76998: PUSH
76999: LD_INT 2
77001: PUSH
77002: LD_INT 1
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 2
77011: PUSH
77012: LD_INT 2
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: PUSH
77022: LD_INT 2
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: LIST
77033: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77034: LD_ADDR_VAR 0 62
77038: PUSH
77039: LD_INT 1
77041: PUSH
77042: LD_INT 2
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 0
77051: PUSH
77052: LD_INT 2
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 1
77061: NEG
77062: PUSH
77063: LD_INT 1
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: LIST
77074: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77075: LD_ADDR_VAR 0 63
77079: PUSH
77080: LD_INT 1
77082: NEG
77083: PUSH
77084: LD_INT 1
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 2
77093: NEG
77094: PUSH
77095: LD_INT 0
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 2
77104: NEG
77105: PUSH
77106: LD_INT 1
77108: NEG
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: LIST
77118: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77119: LD_ADDR_VAR 0 64
77123: PUSH
77124: LD_INT 1
77126: NEG
77127: PUSH
77128: LD_INT 2
77130: NEG
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 2
77138: NEG
77139: PUSH
77140: LD_INT 1
77142: NEG
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 2
77150: NEG
77151: PUSH
77152: LD_INT 2
77154: NEG
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: LIST
77164: ST_TO_ADDR
// end ; 2 :
77165: GO 80431
77167: LD_INT 2
77169: DOUBLE
77170: EQUAL
77171: IFTRUE 77175
77173: GO 80430
77175: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77176: LD_ADDR_VAR 0 29
77180: PUSH
77181: LD_INT 4
77183: PUSH
77184: LD_INT 0
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 4
77193: PUSH
77194: LD_INT 1
77196: NEG
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 5
77204: PUSH
77205: LD_INT 0
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 5
77214: PUSH
77215: LD_INT 1
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 4
77224: PUSH
77225: LD_INT 1
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 3
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 3
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 3
77255: PUSH
77256: LD_INT 2
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 5
77266: PUSH
77267: LD_INT 2
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 3
77276: PUSH
77277: LD_INT 3
77279: PUSH
77280: EMPTY
77281: LIST
77282: LIST
77283: PUSH
77284: LD_INT 3
77286: PUSH
77287: LD_INT 2
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 4
77296: PUSH
77297: LD_INT 3
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 4
77306: PUSH
77307: LD_INT 4
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 3
77316: PUSH
77317: LD_INT 4
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 2
77326: PUSH
77327: LD_INT 3
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 2
77336: PUSH
77337: LD_INT 2
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 4
77346: PUSH
77347: LD_INT 2
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 2
77356: PUSH
77357: LD_INT 4
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: LD_INT 4
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 0
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 1
77386: PUSH
77387: LD_INT 4
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: LD_INT 5
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 0
77406: PUSH
77407: LD_INT 5
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: NEG
77417: PUSH
77418: LD_INT 4
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 1
77427: NEG
77428: PUSH
77429: LD_INT 3
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 2
77438: PUSH
77439: LD_INT 5
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 2
77448: NEG
77449: PUSH
77450: LD_INT 3
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: LD_INT 3
77459: NEG
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 3
77470: NEG
77471: PUSH
77472: LD_INT 1
77474: NEG
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: LD_INT 2
77482: NEG
77483: PUSH
77484: LD_INT 0
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: LD_INT 2
77493: NEG
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 3
77504: NEG
77505: PUSH
77506: LD_INT 1
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 4
77515: NEG
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 4
77526: NEG
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 4
77538: NEG
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 2
77550: NEG
77551: PUSH
77552: LD_INT 2
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 4
77561: NEG
77562: PUSH
77563: LD_INT 4
77565: NEG
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 4
77573: NEG
77574: PUSH
77575: LD_INT 5
77577: NEG
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 3
77585: NEG
77586: PUSH
77587: LD_INT 4
77589: NEG
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 3
77597: NEG
77598: PUSH
77599: LD_INT 3
77601: NEG
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 4
77609: NEG
77610: PUSH
77611: LD_INT 3
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 5
77621: NEG
77622: PUSH
77623: LD_INT 4
77625: NEG
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 5
77633: NEG
77634: PUSH
77635: LD_INT 5
77637: NEG
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 3
77645: NEG
77646: PUSH
77647: LD_INT 5
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 5
77657: NEG
77658: PUSH
77659: LD_INT 3
77661: NEG
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77714: LD_ADDR_VAR 0 30
77718: PUSH
77719: LD_INT 4
77721: PUSH
77722: LD_INT 4
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 4
77731: PUSH
77732: LD_INT 3
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 5
77741: PUSH
77742: LD_INT 4
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 5
77751: PUSH
77752: LD_INT 5
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 4
77761: PUSH
77762: LD_INT 5
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 3
77771: PUSH
77772: LD_INT 4
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 3
77781: PUSH
77782: LD_INT 3
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 5
77791: PUSH
77792: LD_INT 3
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 3
77801: PUSH
77802: LD_INT 5
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 0
77811: PUSH
77812: LD_INT 3
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 0
77821: PUSH
77822: LD_INT 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 1
77831: PUSH
77832: LD_INT 3
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 1
77841: PUSH
77842: LD_INT 4
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 0
77851: PUSH
77852: LD_INT 4
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 1
77861: NEG
77862: PUSH
77863: LD_INT 3
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 1
77872: NEG
77873: PUSH
77874: LD_INT 2
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 2
77883: PUSH
77884: LD_INT 4
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 2
77893: NEG
77894: PUSH
77895: LD_INT 2
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 4
77904: NEG
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 4
77915: NEG
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 3
77927: NEG
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 3
77938: NEG
77939: PUSH
77940: LD_INT 1
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 4
77949: NEG
77950: PUSH
77951: LD_INT 1
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 5
77960: NEG
77961: PUSH
77962: LD_INT 0
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 5
77971: NEG
77972: PUSH
77973: LD_INT 1
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 5
77983: NEG
77984: PUSH
77985: LD_INT 2
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 3
77995: NEG
77996: PUSH
77997: LD_INT 2
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 3
78006: NEG
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: LD_INT 4
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 2
78030: NEG
78031: PUSH
78032: LD_INT 3
78034: NEG
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 2
78042: NEG
78043: PUSH
78044: LD_INT 2
78046: NEG
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 3
78054: NEG
78055: PUSH
78056: LD_INT 2
78058: NEG
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 4
78066: NEG
78067: PUSH
78068: LD_INT 3
78070: NEG
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 4
78078: NEG
78079: PUSH
78080: LD_INT 4
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 2
78090: NEG
78091: PUSH
78092: LD_INT 4
78094: NEG
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 4
78102: NEG
78103: PUSH
78104: LD_INT 2
78106: NEG
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: LD_INT 4
78117: NEG
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: LD_INT 5
78128: NEG
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 1
78136: PUSH
78137: LD_INT 4
78139: NEG
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 1
78147: PUSH
78148: LD_INT 3
78150: NEG
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 0
78158: PUSH
78159: LD_INT 3
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 1
78169: NEG
78170: PUSH
78171: LD_INT 4
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 1
78181: NEG
78182: PUSH
78183: LD_INT 5
78185: NEG
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 2
78193: PUSH
78194: LD_INT 3
78196: NEG
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 2
78204: NEG
78205: PUSH
78206: LD_INT 5
78208: NEG
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78261: LD_ADDR_VAR 0 31
78265: PUSH
78266: LD_INT 0
78268: PUSH
78269: LD_INT 4
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: LD_INT 3
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 1
78288: PUSH
78289: LD_INT 4
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 1
78298: PUSH
78299: LD_INT 5
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 0
78308: PUSH
78309: LD_INT 5
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 1
78318: NEG
78319: PUSH
78320: LD_INT 4
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 1
78329: NEG
78330: PUSH
78331: LD_INT 3
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 2
78340: PUSH
78341: LD_INT 5
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 2
78350: NEG
78351: PUSH
78352: LD_INT 3
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 3
78361: NEG
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 3
78372: NEG
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 2
78384: NEG
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 2
78395: NEG
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 3
78406: NEG
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 4
78417: NEG
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 4
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 4
78440: NEG
78441: PUSH
78442: LD_INT 2
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 2
78452: NEG
78453: PUSH
78454: LD_INT 2
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 4
78463: NEG
78464: PUSH
78465: LD_INT 4
78467: NEG
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 4
78475: NEG
78476: PUSH
78477: LD_INT 5
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 3
78487: NEG
78488: PUSH
78489: LD_INT 4
78491: NEG
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 3
78499: NEG
78500: PUSH
78501: LD_INT 3
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 4
78511: NEG
78512: PUSH
78513: LD_INT 3
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 5
78523: NEG
78524: PUSH
78525: LD_INT 4
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 5
78535: NEG
78536: PUSH
78537: LD_INT 5
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 3
78547: NEG
78548: PUSH
78549: LD_INT 5
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 5
78559: NEG
78560: PUSH
78561: LD_INT 3
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 0
78571: PUSH
78572: LD_INT 3
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 0
78582: PUSH
78583: LD_INT 4
78585: NEG
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: LD_INT 1
78593: PUSH
78594: LD_INT 3
78596: NEG
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: LD_INT 1
78604: PUSH
78605: LD_INT 2
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 0
78615: PUSH
78616: LD_INT 2
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 1
78626: NEG
78627: PUSH
78628: LD_INT 3
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: NEG
78639: PUSH
78640: LD_INT 4
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 2
78650: PUSH
78651: LD_INT 2
78653: NEG
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 2
78661: NEG
78662: PUSH
78663: LD_INT 4
78665: NEG
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 4
78673: PUSH
78674: LD_INT 0
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 4
78683: PUSH
78684: LD_INT 1
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 5
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 5
78704: PUSH
78705: LD_INT 1
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 4
78714: PUSH
78715: LD_INT 1
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 3
78724: PUSH
78725: LD_INT 0
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 3
78734: PUSH
78735: LD_INT 1
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 3
78745: PUSH
78746: LD_INT 2
78748: NEG
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 5
78756: PUSH
78757: LD_INT 2
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78811: LD_ADDR_VAR 0 32
78815: PUSH
78816: LD_INT 4
78818: NEG
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 4
78829: NEG
78830: PUSH
78831: LD_INT 1
78833: NEG
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 3
78841: NEG
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 3
78852: NEG
78853: PUSH
78854: LD_INT 1
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 4
78863: NEG
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 5
78874: NEG
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 5
78885: NEG
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 5
78897: NEG
78898: PUSH
78899: LD_INT 2
78901: NEG
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 3
78909: NEG
78910: PUSH
78911: LD_INT 2
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 3
78920: NEG
78921: PUSH
78922: LD_INT 3
78924: NEG
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 3
78932: NEG
78933: PUSH
78934: LD_INT 4
78936: NEG
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 2
78944: NEG
78945: PUSH
78946: LD_INT 3
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 2
78956: NEG
78957: PUSH
78958: LD_INT 2
78960: NEG
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 3
78968: NEG
78969: PUSH
78970: LD_INT 2
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 4
78980: NEG
78981: PUSH
78982: LD_INT 3
78984: NEG
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 4
78992: NEG
78993: PUSH
78994: LD_INT 4
78996: NEG
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 2
79004: NEG
79005: PUSH
79006: LD_INT 4
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 4
79016: NEG
79017: PUSH
79018: LD_INT 2
79020: NEG
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 0
79028: PUSH
79029: LD_INT 4
79031: NEG
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: LD_INT 5
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 4
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 1
79061: PUSH
79062: LD_INT 3
79064: NEG
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 0
79072: PUSH
79073: LD_INT 3
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: LD_INT 4
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 1
79095: NEG
79096: PUSH
79097: LD_INT 5
79099: NEG
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 2
79107: PUSH
79108: LD_INT 3
79110: NEG
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 2
79118: NEG
79119: PUSH
79120: LD_INT 5
79122: NEG
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 3
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 3
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 4
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 4
79161: PUSH
79162: LD_INT 1
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 3
79171: PUSH
79172: LD_INT 1
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 2
79181: PUSH
79182: LD_INT 0
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 2
79191: PUSH
79192: LD_INT 1
79194: NEG
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 2
79202: PUSH
79203: LD_INT 2
79205: NEG
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: LD_INT 4
79213: PUSH
79214: LD_INT 2
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 4
79223: PUSH
79224: LD_INT 4
79226: PUSH
79227: EMPTY
79228: LIST
79229: LIST
79230: PUSH
79231: LD_INT 4
79233: PUSH
79234: LD_INT 3
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 5
79243: PUSH
79244: LD_INT 4
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 5
79253: PUSH
79254: LD_INT 5
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: LD_INT 4
79263: PUSH
79264: LD_INT 5
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 3
79273: PUSH
79274: LD_INT 4
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 3
79283: PUSH
79284: LD_INT 3
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 5
79293: PUSH
79294: LD_INT 3
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 3
79303: PUSH
79304: LD_INT 5
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79358: LD_ADDR_VAR 0 33
79362: PUSH
79363: LD_INT 4
79365: NEG
79366: PUSH
79367: LD_INT 4
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 4
79377: NEG
79378: PUSH
79379: LD_INT 5
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 3
79389: NEG
79390: PUSH
79391: LD_INT 4
79393: NEG
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 3
79401: NEG
79402: PUSH
79403: LD_INT 3
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 4
79413: NEG
79414: PUSH
79415: LD_INT 3
79417: NEG
79418: PUSH
79419: EMPTY
79420: LIST
79421: LIST
79422: PUSH
79423: LD_INT 5
79425: NEG
79426: PUSH
79427: LD_INT 4
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 5
79437: NEG
79438: PUSH
79439: LD_INT 5
79441: NEG
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 3
79449: NEG
79450: PUSH
79451: LD_INT 5
79453: NEG
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 5
79461: NEG
79462: PUSH
79463: LD_INT 3
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 0
79473: PUSH
79474: LD_INT 3
79476: NEG
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: LD_INT 0
79484: PUSH
79485: LD_INT 4
79487: NEG
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 1
79495: PUSH
79496: LD_INT 3
79498: NEG
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 1
79506: PUSH
79507: LD_INT 2
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: LD_INT 2
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 1
79528: NEG
79529: PUSH
79530: LD_INT 3
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: NEG
79541: PUSH
79542: LD_INT 4
79544: NEG
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 2
79552: PUSH
79553: LD_INT 2
79555: NEG
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 2
79563: NEG
79564: PUSH
79565: LD_INT 4
79567: NEG
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: LD_INT 4
79575: PUSH
79576: LD_INT 0
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 4
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 5
79596: PUSH
79597: LD_INT 0
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 5
79606: PUSH
79607: LD_INT 1
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 4
79616: PUSH
79617: LD_INT 1
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 3
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 3
79636: PUSH
79637: LD_INT 1
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 3
79647: PUSH
79648: LD_INT 2
79650: NEG
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 5
79658: PUSH
79659: LD_INT 2
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 3
79668: PUSH
79669: LD_INT 3
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: LD_INT 3
79678: PUSH
79679: LD_INT 2
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 4
79688: PUSH
79689: LD_INT 3
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 4
79698: PUSH
79699: LD_INT 4
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 3
79708: PUSH
79709: LD_INT 4
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: LD_INT 3
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 2
79728: PUSH
79729: LD_INT 2
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 4
79738: PUSH
79739: LD_INT 2
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 2
79748: PUSH
79749: LD_INT 4
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PUSH
79756: LD_INT 0
79758: PUSH
79759: LD_INT 4
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 0
79768: PUSH
79769: LD_INT 3
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 1
79778: PUSH
79779: LD_INT 4
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 1
79788: PUSH
79789: LD_INT 5
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 0
79798: PUSH
79799: LD_INT 5
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 1
79808: NEG
79809: PUSH
79810: LD_INT 4
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: LD_INT 3
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 2
79830: PUSH
79831: LD_INT 5
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 2
79840: NEG
79841: PUSH
79842: LD_INT 3
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79896: LD_ADDR_VAR 0 34
79900: PUSH
79901: LD_INT 0
79903: PUSH
79904: LD_INT 4
79906: NEG
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: LD_INT 5
79917: NEG
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 1
79925: PUSH
79926: LD_INT 4
79928: NEG
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 1
79936: PUSH
79937: LD_INT 3
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: LD_INT 3
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: NEG
79959: PUSH
79960: LD_INT 4
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: NEG
79971: PUSH
79972: LD_INT 5
79974: NEG
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 2
79982: PUSH
79983: LD_INT 3
79985: NEG
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 2
79993: NEG
79994: PUSH
79995: LD_INT 5
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 3
80005: PUSH
80006: LD_INT 0
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 3
80015: PUSH
80016: LD_INT 1
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 4
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 4
80036: PUSH
80037: LD_INT 1
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 3
80046: PUSH
80047: LD_INT 1
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 2
80056: PUSH
80057: LD_INT 0
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 2
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 2
80077: PUSH
80078: LD_INT 2
80080: NEG
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 4
80088: PUSH
80089: LD_INT 2
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 4
80098: PUSH
80099: LD_INT 4
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 4
80108: PUSH
80109: LD_INT 3
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 5
80118: PUSH
80119: LD_INT 4
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 5
80128: PUSH
80129: LD_INT 5
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 4
80138: PUSH
80139: LD_INT 5
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 3
80148: PUSH
80149: LD_INT 4
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 3
80158: PUSH
80159: LD_INT 3
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 5
80168: PUSH
80169: LD_INT 3
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 3
80178: PUSH
80179: LD_INT 5
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 0
80188: PUSH
80189: LD_INT 3
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: LD_INT 2
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 1
80208: PUSH
80209: LD_INT 3
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 1
80218: PUSH
80219: LD_INT 4
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 0
80228: PUSH
80229: LD_INT 4
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 1
80238: NEG
80239: PUSH
80240: LD_INT 3
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: LD_INT 2
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: LD_INT 4
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 2
80270: NEG
80271: PUSH
80272: LD_INT 2
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 4
80281: NEG
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 4
80292: NEG
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 3
80304: NEG
80305: PUSH
80306: LD_INT 0
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 3
80315: NEG
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 4
80326: NEG
80327: PUSH
80328: LD_INT 1
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 5
80337: NEG
80338: PUSH
80339: LD_INT 0
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 5
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 5
80360: NEG
80361: PUSH
80362: LD_INT 2
80364: NEG
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 3
80372: NEG
80373: PUSH
80374: LD_INT 2
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: ST_TO_ADDR
// end ; end ;
80428: GO 80431
80430: POP
// case btype of b_depot , b_warehouse :
80431: LD_VAR 0 1
80435: PUSH
80436: LD_INT 0
80438: DOUBLE
80439: EQUAL
80440: IFTRUE 80450
80442: LD_INT 1
80444: DOUBLE
80445: EQUAL
80446: IFTRUE 80450
80448: GO 80651
80450: POP
// case nation of nation_american :
80451: LD_VAR 0 5
80455: PUSH
80456: LD_INT 1
80458: DOUBLE
80459: EQUAL
80460: IFTRUE 80464
80462: GO 80520
80464: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80465: LD_ADDR_VAR 0 9
80469: PUSH
80470: LD_VAR 0 11
80474: PUSH
80475: LD_VAR 0 12
80479: PUSH
80480: LD_VAR 0 13
80484: PUSH
80485: LD_VAR 0 14
80489: PUSH
80490: LD_VAR 0 15
80494: PUSH
80495: LD_VAR 0 16
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: PUSH
80508: LD_VAR 0 4
80512: PUSH
80513: LD_INT 1
80515: PLUS
80516: ARRAY
80517: ST_TO_ADDR
80518: GO 80649
80520: LD_INT 2
80522: DOUBLE
80523: EQUAL
80524: IFTRUE 80528
80526: GO 80584
80528: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80529: LD_ADDR_VAR 0 9
80533: PUSH
80534: LD_VAR 0 17
80538: PUSH
80539: LD_VAR 0 18
80543: PUSH
80544: LD_VAR 0 19
80548: PUSH
80549: LD_VAR 0 20
80553: PUSH
80554: LD_VAR 0 21
80558: PUSH
80559: LD_VAR 0 22
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: PUSH
80572: LD_VAR 0 4
80576: PUSH
80577: LD_INT 1
80579: PLUS
80580: ARRAY
80581: ST_TO_ADDR
80582: GO 80649
80584: LD_INT 3
80586: DOUBLE
80587: EQUAL
80588: IFTRUE 80592
80590: GO 80648
80592: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80593: LD_ADDR_VAR 0 9
80597: PUSH
80598: LD_VAR 0 23
80602: PUSH
80603: LD_VAR 0 24
80607: PUSH
80608: LD_VAR 0 25
80612: PUSH
80613: LD_VAR 0 26
80617: PUSH
80618: LD_VAR 0 27
80622: PUSH
80623: LD_VAR 0 28
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: PUSH
80636: LD_VAR 0 4
80640: PUSH
80641: LD_INT 1
80643: PLUS
80644: ARRAY
80645: ST_TO_ADDR
80646: GO 80649
80648: POP
80649: GO 81204
80651: LD_INT 2
80653: DOUBLE
80654: EQUAL
80655: IFTRUE 80665
80657: LD_INT 3
80659: DOUBLE
80660: EQUAL
80661: IFTRUE 80665
80663: GO 80721
80665: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80666: LD_ADDR_VAR 0 9
80670: PUSH
80671: LD_VAR 0 29
80675: PUSH
80676: LD_VAR 0 30
80680: PUSH
80681: LD_VAR 0 31
80685: PUSH
80686: LD_VAR 0 32
80690: PUSH
80691: LD_VAR 0 33
80695: PUSH
80696: LD_VAR 0 34
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: PUSH
80709: LD_VAR 0 4
80713: PUSH
80714: LD_INT 1
80716: PLUS
80717: ARRAY
80718: ST_TO_ADDR
80719: GO 81204
80721: LD_INT 16
80723: DOUBLE
80724: EQUAL
80725: IFTRUE 80783
80727: LD_INT 17
80729: DOUBLE
80730: EQUAL
80731: IFTRUE 80783
80733: LD_INT 18
80735: DOUBLE
80736: EQUAL
80737: IFTRUE 80783
80739: LD_INT 19
80741: DOUBLE
80742: EQUAL
80743: IFTRUE 80783
80745: LD_INT 22
80747: DOUBLE
80748: EQUAL
80749: IFTRUE 80783
80751: LD_INT 20
80753: DOUBLE
80754: EQUAL
80755: IFTRUE 80783
80757: LD_INT 21
80759: DOUBLE
80760: EQUAL
80761: IFTRUE 80783
80763: LD_INT 23
80765: DOUBLE
80766: EQUAL
80767: IFTRUE 80783
80769: LD_INT 24
80771: DOUBLE
80772: EQUAL
80773: IFTRUE 80783
80775: LD_INT 25
80777: DOUBLE
80778: EQUAL
80779: IFTRUE 80783
80781: GO 80839
80783: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80784: LD_ADDR_VAR 0 9
80788: PUSH
80789: LD_VAR 0 35
80793: PUSH
80794: LD_VAR 0 36
80798: PUSH
80799: LD_VAR 0 37
80803: PUSH
80804: LD_VAR 0 38
80808: PUSH
80809: LD_VAR 0 39
80813: PUSH
80814: LD_VAR 0 40
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: PUSH
80827: LD_VAR 0 4
80831: PUSH
80832: LD_INT 1
80834: PLUS
80835: ARRAY
80836: ST_TO_ADDR
80837: GO 81204
80839: LD_INT 6
80841: DOUBLE
80842: EQUAL
80843: IFTRUE 80895
80845: LD_INT 7
80847: DOUBLE
80848: EQUAL
80849: IFTRUE 80895
80851: LD_INT 8
80853: DOUBLE
80854: EQUAL
80855: IFTRUE 80895
80857: LD_INT 13
80859: DOUBLE
80860: EQUAL
80861: IFTRUE 80895
80863: LD_INT 12
80865: DOUBLE
80866: EQUAL
80867: IFTRUE 80895
80869: LD_INT 15
80871: DOUBLE
80872: EQUAL
80873: IFTRUE 80895
80875: LD_INT 11
80877: DOUBLE
80878: EQUAL
80879: IFTRUE 80895
80881: LD_INT 14
80883: DOUBLE
80884: EQUAL
80885: IFTRUE 80895
80887: LD_INT 10
80889: DOUBLE
80890: EQUAL
80891: IFTRUE 80895
80893: GO 80951
80895: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80896: LD_ADDR_VAR 0 9
80900: PUSH
80901: LD_VAR 0 41
80905: PUSH
80906: LD_VAR 0 42
80910: PUSH
80911: LD_VAR 0 43
80915: PUSH
80916: LD_VAR 0 44
80920: PUSH
80921: LD_VAR 0 45
80925: PUSH
80926: LD_VAR 0 46
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: PUSH
80939: LD_VAR 0 4
80943: PUSH
80944: LD_INT 1
80946: PLUS
80947: ARRAY
80948: ST_TO_ADDR
80949: GO 81204
80951: LD_INT 36
80953: DOUBLE
80954: EQUAL
80955: IFTRUE 80959
80957: GO 81015
80959: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80960: LD_ADDR_VAR 0 9
80964: PUSH
80965: LD_VAR 0 47
80969: PUSH
80970: LD_VAR 0 48
80974: PUSH
80975: LD_VAR 0 49
80979: PUSH
80980: LD_VAR 0 50
80984: PUSH
80985: LD_VAR 0 51
80989: PUSH
80990: LD_VAR 0 52
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: PUSH
81003: LD_VAR 0 4
81007: PUSH
81008: LD_INT 1
81010: PLUS
81011: ARRAY
81012: ST_TO_ADDR
81013: GO 81204
81015: LD_INT 4
81017: DOUBLE
81018: EQUAL
81019: IFTRUE 81041
81021: LD_INT 5
81023: DOUBLE
81024: EQUAL
81025: IFTRUE 81041
81027: LD_INT 34
81029: DOUBLE
81030: EQUAL
81031: IFTRUE 81041
81033: LD_INT 37
81035: DOUBLE
81036: EQUAL
81037: IFTRUE 81041
81039: GO 81097
81041: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81042: LD_ADDR_VAR 0 9
81046: PUSH
81047: LD_VAR 0 53
81051: PUSH
81052: LD_VAR 0 54
81056: PUSH
81057: LD_VAR 0 55
81061: PUSH
81062: LD_VAR 0 56
81066: PUSH
81067: LD_VAR 0 57
81071: PUSH
81072: LD_VAR 0 58
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: PUSH
81085: LD_VAR 0 4
81089: PUSH
81090: LD_INT 1
81092: PLUS
81093: ARRAY
81094: ST_TO_ADDR
81095: GO 81204
81097: LD_INT 31
81099: DOUBLE
81100: EQUAL
81101: IFTRUE 81147
81103: LD_INT 32
81105: DOUBLE
81106: EQUAL
81107: IFTRUE 81147
81109: LD_INT 33
81111: DOUBLE
81112: EQUAL
81113: IFTRUE 81147
81115: LD_INT 27
81117: DOUBLE
81118: EQUAL
81119: IFTRUE 81147
81121: LD_INT 26
81123: DOUBLE
81124: EQUAL
81125: IFTRUE 81147
81127: LD_INT 28
81129: DOUBLE
81130: EQUAL
81131: IFTRUE 81147
81133: LD_INT 29
81135: DOUBLE
81136: EQUAL
81137: IFTRUE 81147
81139: LD_INT 30
81141: DOUBLE
81142: EQUAL
81143: IFTRUE 81147
81145: GO 81203
81147: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
81148: LD_ADDR_VAR 0 9
81152: PUSH
81153: LD_VAR 0 59
81157: PUSH
81158: LD_VAR 0 60
81162: PUSH
81163: LD_VAR 0 61
81167: PUSH
81168: LD_VAR 0 62
81172: PUSH
81173: LD_VAR 0 63
81177: PUSH
81178: LD_VAR 0 64
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: PUSH
81191: LD_VAR 0 4
81195: PUSH
81196: LD_INT 1
81198: PLUS
81199: ARRAY
81200: ST_TO_ADDR
81201: GO 81204
81203: POP
// temp_list2 = [ ] ;
81204: LD_ADDR_VAR 0 10
81208: PUSH
81209: EMPTY
81210: ST_TO_ADDR
// for i in temp_list do
81211: LD_ADDR_VAR 0 8
81215: PUSH
81216: LD_VAR 0 9
81220: PUSH
81221: FOR_IN
81222: IFFALSE 81274
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81224: LD_ADDR_VAR 0 10
81228: PUSH
81229: LD_VAR 0 10
81233: PUSH
81234: LD_VAR 0 8
81238: PUSH
81239: LD_INT 1
81241: ARRAY
81242: PUSH
81243: LD_VAR 0 2
81247: PLUS
81248: PUSH
81249: LD_VAR 0 8
81253: PUSH
81254: LD_INT 2
81256: ARRAY
81257: PUSH
81258: LD_VAR 0 3
81262: PLUS
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: EMPTY
81269: LIST
81270: ADD
81271: ST_TO_ADDR
81272: GO 81221
81274: POP
81275: POP
// result = temp_list2 ;
81276: LD_ADDR_VAR 0 7
81280: PUSH
81281: LD_VAR 0 10
81285: ST_TO_ADDR
// end ;
81286: LD_VAR 0 7
81290: RET
// export function EnemyInRange ( unit , dist ) ; begin
81291: LD_INT 0
81293: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81294: LD_ADDR_VAR 0 3
81298: PUSH
81299: LD_VAR 0 1
81303: PPUSH
81304: CALL_OW 255
81308: PPUSH
81309: LD_VAR 0 1
81313: PPUSH
81314: CALL_OW 250
81318: PPUSH
81319: LD_VAR 0 1
81323: PPUSH
81324: CALL_OW 251
81328: PPUSH
81329: LD_VAR 0 2
81333: PPUSH
81334: CALL 55395 0 4
81338: PUSH
81339: LD_INT 4
81341: ARRAY
81342: ST_TO_ADDR
// end ;
81343: LD_VAR 0 3
81347: RET
// export function PlayerSeeMe ( unit ) ; begin
81348: LD_INT 0
81350: PPUSH
// result := See ( your_side , unit ) ;
81351: LD_ADDR_VAR 0 2
81355: PUSH
81356: LD_OWVAR 2
81360: PPUSH
81361: LD_VAR 0 1
81365: PPUSH
81366: CALL_OW 292
81370: ST_TO_ADDR
// end ;
81371: LD_VAR 0 2
81375: RET
// export function ReverseDir ( unit ) ; begin
81376: LD_INT 0
81378: PPUSH
// if not unit then
81379: LD_VAR 0 1
81383: NOT
81384: IFFALSE 81388
// exit ;
81386: GO 81411
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81388: LD_ADDR_VAR 0 2
81392: PUSH
81393: LD_VAR 0 1
81397: PPUSH
81398: CALL_OW 254
81402: PUSH
81403: LD_INT 3
81405: PLUS
81406: PUSH
81407: LD_INT 6
81409: MOD
81410: ST_TO_ADDR
// end ;
81411: LD_VAR 0 2
81415: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81416: LD_INT 0
81418: PPUSH
81419: PPUSH
81420: PPUSH
81421: PPUSH
81422: PPUSH
// if not hexes then
81423: LD_VAR 0 2
81427: NOT
81428: IFFALSE 81432
// exit ;
81430: GO 81580
// dist := 9999 ;
81432: LD_ADDR_VAR 0 5
81436: PUSH
81437: LD_INT 9999
81439: ST_TO_ADDR
// for i = 1 to hexes do
81440: LD_ADDR_VAR 0 4
81444: PUSH
81445: DOUBLE
81446: LD_INT 1
81448: DEC
81449: ST_TO_ADDR
81450: LD_VAR 0 2
81454: PUSH
81455: FOR_TO
81456: IFFALSE 81568
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81458: LD_VAR 0 1
81462: PPUSH
81463: LD_VAR 0 2
81467: PUSH
81468: LD_VAR 0 4
81472: ARRAY
81473: PUSH
81474: LD_INT 1
81476: ARRAY
81477: PPUSH
81478: LD_VAR 0 2
81482: PUSH
81483: LD_VAR 0 4
81487: ARRAY
81488: PUSH
81489: LD_INT 2
81491: ARRAY
81492: PPUSH
81493: CALL_OW 297
81497: PUSH
81498: LD_VAR 0 5
81502: LESS
81503: IFFALSE 81566
// begin hex := hexes [ i ] ;
81505: LD_ADDR_VAR 0 7
81509: PUSH
81510: LD_VAR 0 2
81514: PUSH
81515: LD_VAR 0 4
81519: ARRAY
81520: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81521: LD_ADDR_VAR 0 5
81525: PUSH
81526: LD_VAR 0 1
81530: PPUSH
81531: LD_VAR 0 2
81535: PUSH
81536: LD_VAR 0 4
81540: ARRAY
81541: PUSH
81542: LD_INT 1
81544: ARRAY
81545: PPUSH
81546: LD_VAR 0 2
81550: PUSH
81551: LD_VAR 0 4
81555: ARRAY
81556: PUSH
81557: LD_INT 2
81559: ARRAY
81560: PPUSH
81561: CALL_OW 297
81565: ST_TO_ADDR
// end ; end ;
81566: GO 81455
81568: POP
81569: POP
// result := hex ;
81570: LD_ADDR_VAR 0 3
81574: PUSH
81575: LD_VAR 0 7
81579: ST_TO_ADDR
// end ;
81580: LD_VAR 0 3
81584: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81585: LD_INT 0
81587: PPUSH
81588: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81589: LD_VAR 0 1
81593: NOT
81594: PUSH
81595: LD_VAR 0 1
81599: PUSH
81600: LD_INT 21
81602: PUSH
81603: LD_INT 2
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 23
81612: PUSH
81613: LD_INT 2
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PPUSH
81624: CALL_OW 69
81628: IN
81629: NOT
81630: OR
81631: IFFALSE 81635
// exit ;
81633: GO 81682
// for i = 1 to 3 do
81635: LD_ADDR_VAR 0 3
81639: PUSH
81640: DOUBLE
81641: LD_INT 1
81643: DEC
81644: ST_TO_ADDR
81645: LD_INT 3
81647: PUSH
81648: FOR_TO
81649: IFFALSE 81680
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81651: LD_VAR 0 1
81655: PPUSH
81656: CALL_OW 250
81660: PPUSH
81661: LD_VAR 0 1
81665: PPUSH
81666: CALL_OW 251
81670: PPUSH
81671: LD_INT 1
81673: PPUSH
81674: CALL_OW 453
81678: GO 81648
81680: POP
81681: POP
// end ;
81682: LD_VAR 0 2
81686: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81687: LD_INT 0
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
81693: PPUSH
81694: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81695: LD_VAR 0 1
81699: NOT
81700: PUSH
81701: LD_VAR 0 2
81705: NOT
81706: OR
81707: PUSH
81708: LD_VAR 0 1
81712: PPUSH
81713: CALL_OW 314
81717: OR
81718: IFFALSE 81722
// exit ;
81720: GO 82163
// x := GetX ( enemy_unit ) ;
81722: LD_ADDR_VAR 0 7
81726: PUSH
81727: LD_VAR 0 2
81731: PPUSH
81732: CALL_OW 250
81736: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81737: LD_ADDR_VAR 0 8
81741: PUSH
81742: LD_VAR 0 2
81746: PPUSH
81747: CALL_OW 251
81751: ST_TO_ADDR
// if not x or not y then
81752: LD_VAR 0 7
81756: NOT
81757: PUSH
81758: LD_VAR 0 8
81762: NOT
81763: OR
81764: IFFALSE 81768
// exit ;
81766: GO 82163
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81768: LD_ADDR_VAR 0 6
81772: PUSH
81773: LD_VAR 0 7
81777: PPUSH
81778: LD_INT 0
81780: PPUSH
81781: LD_INT 4
81783: PPUSH
81784: CALL_OW 272
81788: PUSH
81789: LD_VAR 0 8
81793: PPUSH
81794: LD_INT 0
81796: PPUSH
81797: LD_INT 4
81799: PPUSH
81800: CALL_OW 273
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_VAR 0 7
81813: PPUSH
81814: LD_INT 1
81816: PPUSH
81817: LD_INT 4
81819: PPUSH
81820: CALL_OW 272
81824: PUSH
81825: LD_VAR 0 8
81829: PPUSH
81830: LD_INT 1
81832: PPUSH
81833: LD_INT 4
81835: PPUSH
81836: CALL_OW 273
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_VAR 0 7
81849: PPUSH
81850: LD_INT 2
81852: PPUSH
81853: LD_INT 4
81855: PPUSH
81856: CALL_OW 272
81860: PUSH
81861: LD_VAR 0 8
81865: PPUSH
81866: LD_INT 2
81868: PPUSH
81869: LD_INT 4
81871: PPUSH
81872: CALL_OW 273
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_VAR 0 7
81885: PPUSH
81886: LD_INT 3
81888: PPUSH
81889: LD_INT 4
81891: PPUSH
81892: CALL_OW 272
81896: PUSH
81897: LD_VAR 0 8
81901: PPUSH
81902: LD_INT 3
81904: PPUSH
81905: LD_INT 4
81907: PPUSH
81908: CALL_OW 273
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_VAR 0 7
81921: PPUSH
81922: LD_INT 4
81924: PPUSH
81925: LD_INT 4
81927: PPUSH
81928: CALL_OW 272
81932: PUSH
81933: LD_VAR 0 8
81937: PPUSH
81938: LD_INT 4
81940: PPUSH
81941: LD_INT 4
81943: PPUSH
81944: CALL_OW 273
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_VAR 0 7
81957: PPUSH
81958: LD_INT 5
81960: PPUSH
81961: LD_INT 4
81963: PPUSH
81964: CALL_OW 272
81968: PUSH
81969: LD_VAR 0 8
81973: PPUSH
81974: LD_INT 5
81976: PPUSH
81977: LD_INT 4
81979: PPUSH
81980: CALL_OW 273
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: ST_TO_ADDR
// for i = tmp downto 1 do
81997: LD_ADDR_VAR 0 4
82001: PUSH
82002: DOUBLE
82003: LD_VAR 0 6
82007: INC
82008: ST_TO_ADDR
82009: LD_INT 1
82011: PUSH
82012: FOR_DOWNTO
82013: IFFALSE 82114
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82015: LD_VAR 0 6
82019: PUSH
82020: LD_VAR 0 4
82024: ARRAY
82025: PUSH
82026: LD_INT 1
82028: ARRAY
82029: PPUSH
82030: LD_VAR 0 6
82034: PUSH
82035: LD_VAR 0 4
82039: ARRAY
82040: PUSH
82041: LD_INT 2
82043: ARRAY
82044: PPUSH
82045: CALL_OW 488
82049: NOT
82050: PUSH
82051: LD_VAR 0 6
82055: PUSH
82056: LD_VAR 0 4
82060: ARRAY
82061: PUSH
82062: LD_INT 1
82064: ARRAY
82065: PPUSH
82066: LD_VAR 0 6
82070: PUSH
82071: LD_VAR 0 4
82075: ARRAY
82076: PUSH
82077: LD_INT 2
82079: ARRAY
82080: PPUSH
82081: CALL_OW 428
82085: PUSH
82086: LD_INT 0
82088: NONEQUAL
82089: OR
82090: IFFALSE 82112
// tmp := Delete ( tmp , i ) ;
82092: LD_ADDR_VAR 0 6
82096: PUSH
82097: LD_VAR 0 6
82101: PPUSH
82102: LD_VAR 0 4
82106: PPUSH
82107: CALL_OW 3
82111: ST_TO_ADDR
82112: GO 82012
82114: POP
82115: POP
// j := GetClosestHex ( unit , tmp ) ;
82116: LD_ADDR_VAR 0 5
82120: PUSH
82121: LD_VAR 0 1
82125: PPUSH
82126: LD_VAR 0 6
82130: PPUSH
82131: CALL 81416 0 2
82135: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82136: LD_VAR 0 1
82140: PPUSH
82141: LD_VAR 0 5
82145: PUSH
82146: LD_INT 1
82148: ARRAY
82149: PPUSH
82150: LD_VAR 0 5
82154: PUSH
82155: LD_INT 2
82157: ARRAY
82158: PPUSH
82159: CALL_OW 111
// end ;
82163: LD_VAR 0 3
82167: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82168: LD_INT 0
82170: PPUSH
82171: PPUSH
82172: PPUSH
// uc_side = 0 ;
82173: LD_ADDR_OWVAR 20
82177: PUSH
82178: LD_INT 0
82180: ST_TO_ADDR
// uc_nation = 0 ;
82181: LD_ADDR_OWVAR 21
82185: PUSH
82186: LD_INT 0
82188: ST_TO_ADDR
// InitHc ;
82189: CALL_OW 19
// InitVc ;
82193: CALL_OW 20
// if mastodonts then
82197: LD_VAR 0 6
82201: IFFALSE 82268
// for i = 1 to mastodonts do
82203: LD_ADDR_VAR 0 11
82207: PUSH
82208: DOUBLE
82209: LD_INT 1
82211: DEC
82212: ST_TO_ADDR
82213: LD_VAR 0 6
82217: PUSH
82218: FOR_TO
82219: IFFALSE 82266
// begin vc_chassis := 31 ;
82221: LD_ADDR_OWVAR 37
82225: PUSH
82226: LD_INT 31
82228: ST_TO_ADDR
// vc_control := control_rider ;
82229: LD_ADDR_OWVAR 38
82233: PUSH
82234: LD_INT 4
82236: ST_TO_ADDR
// animal := CreateVehicle ;
82237: LD_ADDR_VAR 0 12
82241: PUSH
82242: CALL_OW 45
82246: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82247: LD_VAR 0 12
82251: PPUSH
82252: LD_VAR 0 8
82256: PPUSH
82257: LD_INT 0
82259: PPUSH
82260: CALL 89039 0 3
// end ;
82264: GO 82218
82266: POP
82267: POP
// if horses then
82268: LD_VAR 0 5
82272: IFFALSE 82339
// for i = 1 to horses do
82274: LD_ADDR_VAR 0 11
82278: PUSH
82279: DOUBLE
82280: LD_INT 1
82282: DEC
82283: ST_TO_ADDR
82284: LD_VAR 0 5
82288: PUSH
82289: FOR_TO
82290: IFFALSE 82337
// begin hc_class := 21 ;
82292: LD_ADDR_OWVAR 28
82296: PUSH
82297: LD_INT 21
82299: ST_TO_ADDR
// hc_gallery :=  ;
82300: LD_ADDR_OWVAR 33
82304: PUSH
82305: LD_STRING 
82307: ST_TO_ADDR
// animal := CreateHuman ;
82308: LD_ADDR_VAR 0 12
82312: PUSH
82313: CALL_OW 44
82317: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82318: LD_VAR 0 12
82322: PPUSH
82323: LD_VAR 0 8
82327: PPUSH
82328: LD_INT 0
82330: PPUSH
82331: CALL 89039 0 3
// end ;
82335: GO 82289
82337: POP
82338: POP
// if birds then
82339: LD_VAR 0 1
82343: IFFALSE 82410
// for i = 1 to birds do
82345: LD_ADDR_VAR 0 11
82349: PUSH
82350: DOUBLE
82351: LD_INT 1
82353: DEC
82354: ST_TO_ADDR
82355: LD_VAR 0 1
82359: PUSH
82360: FOR_TO
82361: IFFALSE 82408
// begin hc_class = 18 ;
82363: LD_ADDR_OWVAR 28
82367: PUSH
82368: LD_INT 18
82370: ST_TO_ADDR
// hc_gallery =  ;
82371: LD_ADDR_OWVAR 33
82375: PUSH
82376: LD_STRING 
82378: ST_TO_ADDR
// animal := CreateHuman ;
82379: LD_ADDR_VAR 0 12
82383: PUSH
82384: CALL_OW 44
82388: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82389: LD_VAR 0 12
82393: PPUSH
82394: LD_VAR 0 8
82398: PPUSH
82399: LD_INT 0
82401: PPUSH
82402: CALL 89039 0 3
// end ;
82406: GO 82360
82408: POP
82409: POP
// if tigers then
82410: LD_VAR 0 2
82414: IFFALSE 82498
// for i = 1 to tigers do
82416: LD_ADDR_VAR 0 11
82420: PUSH
82421: DOUBLE
82422: LD_INT 1
82424: DEC
82425: ST_TO_ADDR
82426: LD_VAR 0 2
82430: PUSH
82431: FOR_TO
82432: IFFALSE 82496
// begin hc_class = class_tiger ;
82434: LD_ADDR_OWVAR 28
82438: PUSH
82439: LD_INT 14
82441: ST_TO_ADDR
// hc_gallery =  ;
82442: LD_ADDR_OWVAR 33
82446: PUSH
82447: LD_STRING 
82449: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82450: LD_ADDR_OWVAR 35
82454: PUSH
82455: LD_INT 7
82457: NEG
82458: PPUSH
82459: LD_INT 7
82461: PPUSH
82462: CALL_OW 12
82466: ST_TO_ADDR
// animal := CreateHuman ;
82467: LD_ADDR_VAR 0 12
82471: PUSH
82472: CALL_OW 44
82476: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82477: LD_VAR 0 12
82481: PPUSH
82482: LD_VAR 0 8
82486: PPUSH
82487: LD_INT 0
82489: PPUSH
82490: CALL 89039 0 3
// end ;
82494: GO 82431
82496: POP
82497: POP
// if apemans then
82498: LD_VAR 0 3
82502: IFFALSE 82625
// for i = 1 to apemans do
82504: LD_ADDR_VAR 0 11
82508: PUSH
82509: DOUBLE
82510: LD_INT 1
82512: DEC
82513: ST_TO_ADDR
82514: LD_VAR 0 3
82518: PUSH
82519: FOR_TO
82520: IFFALSE 82623
// begin hc_class = class_apeman ;
82522: LD_ADDR_OWVAR 28
82526: PUSH
82527: LD_INT 12
82529: ST_TO_ADDR
// hc_gallery =  ;
82530: LD_ADDR_OWVAR 33
82534: PUSH
82535: LD_STRING 
82537: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82538: LD_ADDR_OWVAR 35
82542: PUSH
82543: LD_INT 5
82545: NEG
82546: PPUSH
82547: LD_INT 5
82549: PPUSH
82550: CALL_OW 12
82554: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82555: LD_ADDR_OWVAR 31
82559: PUSH
82560: LD_INT 1
82562: PPUSH
82563: LD_INT 3
82565: PPUSH
82566: CALL_OW 12
82570: PUSH
82571: LD_INT 1
82573: PPUSH
82574: LD_INT 3
82576: PPUSH
82577: CALL_OW 12
82581: PUSH
82582: LD_INT 0
82584: PUSH
82585: LD_INT 0
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: ST_TO_ADDR
// animal := CreateHuman ;
82594: LD_ADDR_VAR 0 12
82598: PUSH
82599: CALL_OW 44
82603: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82604: LD_VAR 0 12
82608: PPUSH
82609: LD_VAR 0 8
82613: PPUSH
82614: LD_INT 0
82616: PPUSH
82617: CALL 89039 0 3
// end ;
82621: GO 82519
82623: POP
82624: POP
// if enchidnas then
82625: LD_VAR 0 4
82629: IFFALSE 82696
// for i = 1 to enchidnas do
82631: LD_ADDR_VAR 0 11
82635: PUSH
82636: DOUBLE
82637: LD_INT 1
82639: DEC
82640: ST_TO_ADDR
82641: LD_VAR 0 4
82645: PUSH
82646: FOR_TO
82647: IFFALSE 82694
// begin hc_class = 13 ;
82649: LD_ADDR_OWVAR 28
82653: PUSH
82654: LD_INT 13
82656: ST_TO_ADDR
// hc_gallery =  ;
82657: LD_ADDR_OWVAR 33
82661: PUSH
82662: LD_STRING 
82664: ST_TO_ADDR
// animal := CreateHuman ;
82665: LD_ADDR_VAR 0 12
82669: PUSH
82670: CALL_OW 44
82674: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82675: LD_VAR 0 12
82679: PPUSH
82680: LD_VAR 0 8
82684: PPUSH
82685: LD_INT 0
82687: PPUSH
82688: CALL 89039 0 3
// end ;
82692: GO 82646
82694: POP
82695: POP
// if fishes then
82696: LD_VAR 0 7
82700: IFFALSE 82767
// for i = 1 to fishes do
82702: LD_ADDR_VAR 0 11
82706: PUSH
82707: DOUBLE
82708: LD_INT 1
82710: DEC
82711: ST_TO_ADDR
82712: LD_VAR 0 7
82716: PUSH
82717: FOR_TO
82718: IFFALSE 82765
// begin hc_class = 20 ;
82720: LD_ADDR_OWVAR 28
82724: PUSH
82725: LD_INT 20
82727: ST_TO_ADDR
// hc_gallery =  ;
82728: LD_ADDR_OWVAR 33
82732: PUSH
82733: LD_STRING 
82735: ST_TO_ADDR
// animal := CreateHuman ;
82736: LD_ADDR_VAR 0 12
82740: PUSH
82741: CALL_OW 44
82745: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82746: LD_VAR 0 12
82750: PPUSH
82751: LD_VAR 0 9
82755: PPUSH
82756: LD_INT 0
82758: PPUSH
82759: CALL 89039 0 3
// end ;
82763: GO 82717
82765: POP
82766: POP
// end ;
82767: LD_VAR 0 10
82771: RET
// export function WantHeal ( sci , unit ) ; begin
82772: LD_INT 0
82774: PPUSH
// if GetTaskList ( sci ) > 0 then
82775: LD_VAR 0 1
82779: PPUSH
82780: CALL_OW 437
82784: PUSH
82785: LD_INT 0
82787: GREATER
82788: IFFALSE 82858
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82790: LD_VAR 0 1
82794: PPUSH
82795: CALL_OW 437
82799: PUSH
82800: LD_INT 1
82802: ARRAY
82803: PUSH
82804: LD_INT 1
82806: ARRAY
82807: PUSH
82808: LD_STRING l
82810: EQUAL
82811: PUSH
82812: LD_VAR 0 1
82816: PPUSH
82817: CALL_OW 437
82821: PUSH
82822: LD_INT 1
82824: ARRAY
82825: PUSH
82826: LD_INT 4
82828: ARRAY
82829: PUSH
82830: LD_VAR 0 2
82834: EQUAL
82835: AND
82836: IFFALSE 82848
// result := true else
82838: LD_ADDR_VAR 0 3
82842: PUSH
82843: LD_INT 1
82845: ST_TO_ADDR
82846: GO 82856
// result := false ;
82848: LD_ADDR_VAR 0 3
82852: PUSH
82853: LD_INT 0
82855: ST_TO_ADDR
// end else
82856: GO 82866
// result := false ;
82858: LD_ADDR_VAR 0 3
82862: PUSH
82863: LD_INT 0
82865: ST_TO_ADDR
// end ;
82866: LD_VAR 0 3
82870: RET
// export function HealTarget ( sci ) ; begin
82871: LD_INT 0
82873: PPUSH
// if not sci then
82874: LD_VAR 0 1
82878: NOT
82879: IFFALSE 82883
// exit ;
82881: GO 82948
// result := 0 ;
82883: LD_ADDR_VAR 0 2
82887: PUSH
82888: LD_INT 0
82890: ST_TO_ADDR
// if GetTaskList ( sci ) then
82891: LD_VAR 0 1
82895: PPUSH
82896: CALL_OW 437
82900: IFFALSE 82948
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82902: LD_VAR 0 1
82906: PPUSH
82907: CALL_OW 437
82911: PUSH
82912: LD_INT 1
82914: ARRAY
82915: PUSH
82916: LD_INT 1
82918: ARRAY
82919: PUSH
82920: LD_STRING l
82922: EQUAL
82923: IFFALSE 82948
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82925: LD_ADDR_VAR 0 2
82929: PUSH
82930: LD_VAR 0 1
82934: PPUSH
82935: CALL_OW 437
82939: PUSH
82940: LD_INT 1
82942: ARRAY
82943: PUSH
82944: LD_INT 4
82946: ARRAY
82947: ST_TO_ADDR
// end ;
82948: LD_VAR 0 2
82952: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82953: LD_INT 0
82955: PPUSH
82956: PPUSH
82957: PPUSH
82958: PPUSH
82959: PPUSH
82960: PPUSH
82961: PPUSH
82962: PPUSH
82963: PPUSH
82964: PPUSH
82965: PPUSH
82966: PPUSH
82967: PPUSH
82968: PPUSH
82969: PPUSH
82970: PPUSH
82971: PPUSH
82972: PPUSH
82973: PPUSH
82974: PPUSH
82975: PPUSH
82976: PPUSH
82977: PPUSH
82978: PPUSH
82979: PPUSH
82980: PPUSH
82981: PPUSH
82982: PPUSH
82983: PPUSH
82984: PPUSH
82985: PPUSH
82986: PPUSH
82987: PPUSH
82988: PPUSH
// if not list then
82989: LD_VAR 0 1
82993: NOT
82994: IFFALSE 82998
// exit ;
82996: GO 87650
// base := list [ 1 ] ;
82998: LD_ADDR_VAR 0 3
83002: PUSH
83003: LD_VAR 0 1
83007: PUSH
83008: LD_INT 1
83010: ARRAY
83011: ST_TO_ADDR
// group := list [ 2 ] ;
83012: LD_ADDR_VAR 0 4
83016: PUSH
83017: LD_VAR 0 1
83021: PUSH
83022: LD_INT 2
83024: ARRAY
83025: ST_TO_ADDR
// path := list [ 3 ] ;
83026: LD_ADDR_VAR 0 5
83030: PUSH
83031: LD_VAR 0 1
83035: PUSH
83036: LD_INT 3
83038: ARRAY
83039: ST_TO_ADDR
// flags := list [ 4 ] ;
83040: LD_ADDR_VAR 0 6
83044: PUSH
83045: LD_VAR 0 1
83049: PUSH
83050: LD_INT 4
83052: ARRAY
83053: ST_TO_ADDR
// mined := [ ] ;
83054: LD_ADDR_VAR 0 27
83058: PUSH
83059: EMPTY
83060: ST_TO_ADDR
// bombed := [ ] ;
83061: LD_ADDR_VAR 0 28
83065: PUSH
83066: EMPTY
83067: ST_TO_ADDR
// healers := [ ] ;
83068: LD_ADDR_VAR 0 31
83072: PUSH
83073: EMPTY
83074: ST_TO_ADDR
// to_heal := [ ] ;
83075: LD_ADDR_VAR 0 30
83079: PUSH
83080: EMPTY
83081: ST_TO_ADDR
// repairs := [ ] ;
83082: LD_ADDR_VAR 0 33
83086: PUSH
83087: EMPTY
83088: ST_TO_ADDR
// to_repair := [ ] ;
83089: LD_ADDR_VAR 0 32
83093: PUSH
83094: EMPTY
83095: ST_TO_ADDR
// if not group or not path then
83096: LD_VAR 0 4
83100: NOT
83101: PUSH
83102: LD_VAR 0 5
83106: NOT
83107: OR
83108: IFFALSE 83112
// exit ;
83110: GO 87650
// side := GetSide ( group [ 1 ] ) ;
83112: LD_ADDR_VAR 0 35
83116: PUSH
83117: LD_VAR 0 4
83121: PUSH
83122: LD_INT 1
83124: ARRAY
83125: PPUSH
83126: CALL_OW 255
83130: ST_TO_ADDR
// if flags then
83131: LD_VAR 0 6
83135: IFFALSE 83279
// begin f_ignore_area := flags [ 1 ] ;
83137: LD_ADDR_VAR 0 17
83141: PUSH
83142: LD_VAR 0 6
83146: PUSH
83147: LD_INT 1
83149: ARRAY
83150: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83151: LD_ADDR_VAR 0 18
83155: PUSH
83156: LD_VAR 0 6
83160: PUSH
83161: LD_INT 2
83163: ARRAY
83164: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83165: LD_ADDR_VAR 0 19
83169: PUSH
83170: LD_VAR 0 6
83174: PUSH
83175: LD_INT 3
83177: ARRAY
83178: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83179: LD_ADDR_VAR 0 20
83183: PUSH
83184: LD_VAR 0 6
83188: PUSH
83189: LD_INT 4
83191: ARRAY
83192: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83193: LD_ADDR_VAR 0 21
83197: PUSH
83198: LD_VAR 0 6
83202: PUSH
83203: LD_INT 5
83205: ARRAY
83206: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83207: LD_ADDR_VAR 0 22
83211: PUSH
83212: LD_VAR 0 6
83216: PUSH
83217: LD_INT 6
83219: ARRAY
83220: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83221: LD_ADDR_VAR 0 23
83225: PUSH
83226: LD_VAR 0 6
83230: PUSH
83231: LD_INT 7
83233: ARRAY
83234: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83235: LD_ADDR_VAR 0 24
83239: PUSH
83240: LD_VAR 0 6
83244: PUSH
83245: LD_INT 8
83247: ARRAY
83248: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83249: LD_ADDR_VAR 0 25
83253: PUSH
83254: LD_VAR 0 6
83258: PUSH
83259: LD_INT 9
83261: ARRAY
83262: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83263: LD_ADDR_VAR 0 26
83267: PUSH
83268: LD_VAR 0 6
83272: PUSH
83273: LD_INT 10
83275: ARRAY
83276: ST_TO_ADDR
// end else
83277: GO 83359
// begin f_ignore_area := false ;
83279: LD_ADDR_VAR 0 17
83283: PUSH
83284: LD_INT 0
83286: ST_TO_ADDR
// f_capture := false ;
83287: LD_ADDR_VAR 0 18
83291: PUSH
83292: LD_INT 0
83294: ST_TO_ADDR
// f_ignore_civ := false ;
83295: LD_ADDR_VAR 0 19
83299: PUSH
83300: LD_INT 0
83302: ST_TO_ADDR
// f_murder := false ;
83303: LD_ADDR_VAR 0 20
83307: PUSH
83308: LD_INT 0
83310: ST_TO_ADDR
// f_mines := false ;
83311: LD_ADDR_VAR 0 21
83315: PUSH
83316: LD_INT 0
83318: ST_TO_ADDR
// f_repair := false ;
83319: LD_ADDR_VAR 0 22
83323: PUSH
83324: LD_INT 0
83326: ST_TO_ADDR
// f_heal := false ;
83327: LD_ADDR_VAR 0 23
83331: PUSH
83332: LD_INT 0
83334: ST_TO_ADDR
// f_spacetime := false ;
83335: LD_ADDR_VAR 0 24
83339: PUSH
83340: LD_INT 0
83342: ST_TO_ADDR
// f_attack_depot := false ;
83343: LD_ADDR_VAR 0 25
83347: PUSH
83348: LD_INT 0
83350: ST_TO_ADDR
// f_crawl := false ;
83351: LD_ADDR_VAR 0 26
83355: PUSH
83356: LD_INT 0
83358: ST_TO_ADDR
// end ; if f_heal then
83359: LD_VAR 0 23
83363: IFFALSE 83390
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83365: LD_ADDR_VAR 0 31
83369: PUSH
83370: LD_VAR 0 4
83374: PPUSH
83375: LD_INT 25
83377: PUSH
83378: LD_INT 4
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PPUSH
83385: CALL_OW 72
83389: ST_TO_ADDR
// if f_repair then
83390: LD_VAR 0 22
83394: IFFALSE 83421
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83396: LD_ADDR_VAR 0 33
83400: PUSH
83401: LD_VAR 0 4
83405: PPUSH
83406: LD_INT 25
83408: PUSH
83409: LD_INT 3
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PPUSH
83416: CALL_OW 72
83420: ST_TO_ADDR
// units_path := [ ] ;
83421: LD_ADDR_VAR 0 16
83425: PUSH
83426: EMPTY
83427: ST_TO_ADDR
// for i = 1 to group do
83428: LD_ADDR_VAR 0 7
83432: PUSH
83433: DOUBLE
83434: LD_INT 1
83436: DEC
83437: ST_TO_ADDR
83438: LD_VAR 0 4
83442: PUSH
83443: FOR_TO
83444: IFFALSE 83473
// units_path := Replace ( units_path , i , path ) ;
83446: LD_ADDR_VAR 0 16
83450: PUSH
83451: LD_VAR 0 16
83455: PPUSH
83456: LD_VAR 0 7
83460: PPUSH
83461: LD_VAR 0 5
83465: PPUSH
83466: CALL_OW 1
83470: ST_TO_ADDR
83471: GO 83443
83473: POP
83474: POP
// repeat for i = group downto 1 do
83475: LD_ADDR_VAR 0 7
83479: PUSH
83480: DOUBLE
83481: LD_VAR 0 4
83485: INC
83486: ST_TO_ADDR
83487: LD_INT 1
83489: PUSH
83490: FOR_DOWNTO
83491: IFFALSE 87613
// begin wait ( 5 ) ;
83493: LD_INT 5
83495: PPUSH
83496: CALL_OW 67
// tmp := [ ] ;
83500: LD_ADDR_VAR 0 14
83504: PUSH
83505: EMPTY
83506: ST_TO_ADDR
// attacking := false ;
83507: LD_ADDR_VAR 0 29
83511: PUSH
83512: LD_INT 0
83514: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83515: LD_VAR 0 4
83519: PUSH
83520: LD_VAR 0 7
83524: ARRAY
83525: PPUSH
83526: CALL_OW 301
83530: PUSH
83531: LD_VAR 0 4
83535: PUSH
83536: LD_VAR 0 7
83540: ARRAY
83541: NOT
83542: OR
83543: IFFALSE 83652
// begin if GetType ( group [ i ] ) = unit_human then
83545: LD_VAR 0 4
83549: PUSH
83550: LD_VAR 0 7
83554: ARRAY
83555: PPUSH
83556: CALL_OW 247
83560: PUSH
83561: LD_INT 1
83563: EQUAL
83564: IFFALSE 83610
// begin to_heal := to_heal diff group [ i ] ;
83566: LD_ADDR_VAR 0 30
83570: PUSH
83571: LD_VAR 0 30
83575: PUSH
83576: LD_VAR 0 4
83580: PUSH
83581: LD_VAR 0 7
83585: ARRAY
83586: DIFF
83587: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83588: LD_ADDR_VAR 0 31
83592: PUSH
83593: LD_VAR 0 31
83597: PUSH
83598: LD_VAR 0 4
83602: PUSH
83603: LD_VAR 0 7
83607: ARRAY
83608: DIFF
83609: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83610: LD_ADDR_VAR 0 4
83614: PUSH
83615: LD_VAR 0 4
83619: PPUSH
83620: LD_VAR 0 7
83624: PPUSH
83625: CALL_OW 3
83629: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83630: LD_ADDR_VAR 0 16
83634: PUSH
83635: LD_VAR 0 16
83639: PPUSH
83640: LD_VAR 0 7
83644: PPUSH
83645: CALL_OW 3
83649: ST_TO_ADDR
// continue ;
83650: GO 83490
// end ; if f_repair then
83652: LD_VAR 0 22
83656: IFFALSE 84145
// begin if GetType ( group [ i ] ) = unit_vehicle then
83658: LD_VAR 0 4
83662: PUSH
83663: LD_VAR 0 7
83667: ARRAY
83668: PPUSH
83669: CALL_OW 247
83673: PUSH
83674: LD_INT 2
83676: EQUAL
83677: IFFALSE 83867
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83679: LD_VAR 0 4
83683: PUSH
83684: LD_VAR 0 7
83688: ARRAY
83689: PPUSH
83690: CALL_OW 256
83694: PUSH
83695: LD_INT 700
83697: LESS
83698: PUSH
83699: LD_VAR 0 4
83703: PUSH
83704: LD_VAR 0 7
83708: ARRAY
83709: PUSH
83710: LD_VAR 0 32
83714: IN
83715: NOT
83716: AND
83717: IFFALSE 83741
// to_repair := to_repair union group [ i ] ;
83719: LD_ADDR_VAR 0 32
83723: PUSH
83724: LD_VAR 0 32
83728: PUSH
83729: LD_VAR 0 4
83733: PUSH
83734: LD_VAR 0 7
83738: ARRAY
83739: UNION
83740: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83741: LD_VAR 0 4
83745: PUSH
83746: LD_VAR 0 7
83750: ARRAY
83751: PPUSH
83752: CALL_OW 256
83756: PUSH
83757: LD_INT 1000
83759: EQUAL
83760: PUSH
83761: LD_VAR 0 4
83765: PUSH
83766: LD_VAR 0 7
83770: ARRAY
83771: PUSH
83772: LD_VAR 0 32
83776: IN
83777: AND
83778: IFFALSE 83802
// to_repair := to_repair diff group [ i ] ;
83780: LD_ADDR_VAR 0 32
83784: PUSH
83785: LD_VAR 0 32
83789: PUSH
83790: LD_VAR 0 4
83794: PUSH
83795: LD_VAR 0 7
83799: ARRAY
83800: DIFF
83801: ST_TO_ADDR
// if group [ i ] in to_repair then
83802: LD_VAR 0 4
83806: PUSH
83807: LD_VAR 0 7
83811: ARRAY
83812: PUSH
83813: LD_VAR 0 32
83817: IN
83818: IFFALSE 83865
// begin if not IsInArea ( group [ i ] , f_repair ) then
83820: LD_VAR 0 4
83824: PUSH
83825: LD_VAR 0 7
83829: ARRAY
83830: PPUSH
83831: LD_VAR 0 22
83835: PPUSH
83836: CALL_OW 308
83840: NOT
83841: IFFALSE 83863
// ComMoveToArea ( group [ i ] , f_repair ) ;
83843: LD_VAR 0 4
83847: PUSH
83848: LD_VAR 0 7
83852: ARRAY
83853: PPUSH
83854: LD_VAR 0 22
83858: PPUSH
83859: CALL_OW 113
// continue ;
83863: GO 83490
// end ; end else
83865: GO 84145
// if group [ i ] in repairs then
83867: LD_VAR 0 4
83871: PUSH
83872: LD_VAR 0 7
83876: ARRAY
83877: PUSH
83878: LD_VAR 0 33
83882: IN
83883: IFFALSE 84145
// begin if IsInUnit ( group [ i ] ) then
83885: LD_VAR 0 4
83889: PUSH
83890: LD_VAR 0 7
83894: ARRAY
83895: PPUSH
83896: CALL_OW 310
83900: IFFALSE 83968
// begin z := IsInUnit ( group [ i ] ) ;
83902: LD_ADDR_VAR 0 13
83906: PUSH
83907: LD_VAR 0 4
83911: PUSH
83912: LD_VAR 0 7
83916: ARRAY
83917: PPUSH
83918: CALL_OW 310
83922: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83923: LD_VAR 0 13
83927: PUSH
83928: LD_VAR 0 32
83932: IN
83933: PUSH
83934: LD_VAR 0 13
83938: PPUSH
83939: LD_VAR 0 22
83943: PPUSH
83944: CALL_OW 308
83948: AND
83949: IFFALSE 83966
// ComExitVehicle ( group [ i ] ) ;
83951: LD_VAR 0 4
83955: PUSH
83956: LD_VAR 0 7
83960: ARRAY
83961: PPUSH
83962: CALL_OW 121
// end else
83966: GO 84145
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83968: LD_ADDR_VAR 0 13
83972: PUSH
83973: LD_VAR 0 4
83977: PPUSH
83978: LD_INT 95
83980: PUSH
83981: LD_VAR 0 22
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 58
83992: PUSH
83993: EMPTY
83994: LIST
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PPUSH
84000: CALL_OW 72
84004: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84005: LD_VAR 0 4
84009: PUSH
84010: LD_VAR 0 7
84014: ARRAY
84015: PPUSH
84016: CALL_OW 314
84020: NOT
84021: IFFALSE 84143
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84023: LD_ADDR_VAR 0 10
84027: PUSH
84028: LD_VAR 0 13
84032: PPUSH
84033: LD_VAR 0 4
84037: PUSH
84038: LD_VAR 0 7
84042: ARRAY
84043: PPUSH
84044: CALL_OW 74
84048: ST_TO_ADDR
// if not x then
84049: LD_VAR 0 10
84053: NOT
84054: IFFALSE 84058
// continue ;
84056: GO 83490
// if GetLives ( x ) < 1000 then
84058: LD_VAR 0 10
84062: PPUSH
84063: CALL_OW 256
84067: PUSH
84068: LD_INT 1000
84070: LESS
84071: IFFALSE 84095
// ComRepairVehicle ( group [ i ] , x ) else
84073: LD_VAR 0 4
84077: PUSH
84078: LD_VAR 0 7
84082: ARRAY
84083: PPUSH
84084: LD_VAR 0 10
84088: PPUSH
84089: CALL_OW 129
84093: GO 84143
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84095: LD_VAR 0 23
84099: PUSH
84100: LD_VAR 0 4
84104: PUSH
84105: LD_VAR 0 7
84109: ARRAY
84110: PPUSH
84111: CALL_OW 256
84115: PUSH
84116: LD_INT 1000
84118: LESS
84119: AND
84120: NOT
84121: IFFALSE 84143
// ComEnterUnit ( group [ i ] , x ) ;
84123: LD_VAR 0 4
84127: PUSH
84128: LD_VAR 0 7
84132: ARRAY
84133: PPUSH
84134: LD_VAR 0 10
84138: PPUSH
84139: CALL_OW 120
// end ; continue ;
84143: GO 83490
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84145: LD_VAR 0 23
84149: PUSH
84150: LD_VAR 0 4
84154: PUSH
84155: LD_VAR 0 7
84159: ARRAY
84160: PPUSH
84161: CALL_OW 247
84165: PUSH
84166: LD_INT 1
84168: EQUAL
84169: AND
84170: IFFALSE 84648
// begin if group [ i ] in healers then
84172: LD_VAR 0 4
84176: PUSH
84177: LD_VAR 0 7
84181: ARRAY
84182: PUSH
84183: LD_VAR 0 31
84187: IN
84188: IFFALSE 84461
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84190: LD_VAR 0 4
84194: PUSH
84195: LD_VAR 0 7
84199: ARRAY
84200: PPUSH
84201: LD_VAR 0 23
84205: PPUSH
84206: CALL_OW 308
84210: NOT
84211: PUSH
84212: LD_VAR 0 4
84216: PUSH
84217: LD_VAR 0 7
84221: ARRAY
84222: PPUSH
84223: CALL_OW 314
84227: NOT
84228: AND
84229: IFFALSE 84253
// ComMoveToArea ( group [ i ] , f_heal ) else
84231: LD_VAR 0 4
84235: PUSH
84236: LD_VAR 0 7
84240: ARRAY
84241: PPUSH
84242: LD_VAR 0 23
84246: PPUSH
84247: CALL_OW 113
84251: GO 84459
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84253: LD_VAR 0 4
84257: PUSH
84258: LD_VAR 0 7
84262: ARRAY
84263: PPUSH
84264: CALL 82871 0 1
84268: PPUSH
84269: CALL_OW 256
84273: PUSH
84274: LD_INT 1000
84276: EQUAL
84277: IFFALSE 84296
// ComStop ( group [ i ] ) else
84279: LD_VAR 0 4
84283: PUSH
84284: LD_VAR 0 7
84288: ARRAY
84289: PPUSH
84290: CALL_OW 141
84294: GO 84459
// if not HasTask ( group [ i ] ) and to_heal then
84296: LD_VAR 0 4
84300: PUSH
84301: LD_VAR 0 7
84305: ARRAY
84306: PPUSH
84307: CALL_OW 314
84311: NOT
84312: PUSH
84313: LD_VAR 0 30
84317: AND
84318: IFFALSE 84459
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84320: LD_ADDR_VAR 0 13
84324: PUSH
84325: LD_VAR 0 30
84329: PPUSH
84330: LD_INT 3
84332: PUSH
84333: LD_INT 54
84335: PUSH
84336: EMPTY
84337: LIST
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: PPUSH
84343: CALL_OW 72
84347: PPUSH
84348: LD_VAR 0 4
84352: PUSH
84353: LD_VAR 0 7
84357: ARRAY
84358: PPUSH
84359: CALL_OW 74
84363: ST_TO_ADDR
// if z then
84364: LD_VAR 0 13
84368: IFFALSE 84459
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84370: LD_INT 91
84372: PUSH
84373: LD_VAR 0 13
84377: PUSH
84378: LD_INT 10
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 81
84388: PUSH
84389: LD_VAR 0 13
84393: PPUSH
84394: CALL_OW 255
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PPUSH
84407: CALL_OW 69
84411: PUSH
84412: LD_INT 0
84414: EQUAL
84415: IFFALSE 84439
// ComHeal ( group [ i ] , z ) else
84417: LD_VAR 0 4
84421: PUSH
84422: LD_VAR 0 7
84426: ARRAY
84427: PPUSH
84428: LD_VAR 0 13
84432: PPUSH
84433: CALL_OW 128
84437: GO 84459
// ComMoveToArea ( group [ i ] , f_heal ) ;
84439: LD_VAR 0 4
84443: PUSH
84444: LD_VAR 0 7
84448: ARRAY
84449: PPUSH
84450: LD_VAR 0 23
84454: PPUSH
84455: CALL_OW 113
// end ; continue ;
84459: GO 83490
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84461: LD_VAR 0 4
84465: PUSH
84466: LD_VAR 0 7
84470: ARRAY
84471: PPUSH
84472: CALL_OW 256
84476: PUSH
84477: LD_INT 700
84479: LESS
84480: PUSH
84481: LD_VAR 0 4
84485: PUSH
84486: LD_VAR 0 7
84490: ARRAY
84491: PUSH
84492: LD_VAR 0 30
84496: IN
84497: NOT
84498: AND
84499: IFFALSE 84523
// to_heal := to_heal union group [ i ] ;
84501: LD_ADDR_VAR 0 30
84505: PUSH
84506: LD_VAR 0 30
84510: PUSH
84511: LD_VAR 0 4
84515: PUSH
84516: LD_VAR 0 7
84520: ARRAY
84521: UNION
84522: ST_TO_ADDR
// if group [ i ] in to_heal then
84523: LD_VAR 0 4
84527: PUSH
84528: LD_VAR 0 7
84532: ARRAY
84533: PUSH
84534: LD_VAR 0 30
84538: IN
84539: IFFALSE 84648
// begin if GetLives ( group [ i ] ) = 1000 then
84541: LD_VAR 0 4
84545: PUSH
84546: LD_VAR 0 7
84550: ARRAY
84551: PPUSH
84552: CALL_OW 256
84556: PUSH
84557: LD_INT 1000
84559: EQUAL
84560: IFFALSE 84586
// to_heal := to_heal diff group [ i ] else
84562: LD_ADDR_VAR 0 30
84566: PUSH
84567: LD_VAR 0 30
84571: PUSH
84572: LD_VAR 0 4
84576: PUSH
84577: LD_VAR 0 7
84581: ARRAY
84582: DIFF
84583: ST_TO_ADDR
84584: GO 84648
// begin if not IsInArea ( group [ i ] , to_heal ) then
84586: LD_VAR 0 4
84590: PUSH
84591: LD_VAR 0 7
84595: ARRAY
84596: PPUSH
84597: LD_VAR 0 30
84601: PPUSH
84602: CALL_OW 308
84606: NOT
84607: IFFALSE 84631
// ComMoveToArea ( group [ i ] , f_heal ) else
84609: LD_VAR 0 4
84613: PUSH
84614: LD_VAR 0 7
84618: ARRAY
84619: PPUSH
84620: LD_VAR 0 23
84624: PPUSH
84625: CALL_OW 113
84629: GO 84646
// ComHold ( group [ i ] ) ;
84631: LD_VAR 0 4
84635: PUSH
84636: LD_VAR 0 7
84640: ARRAY
84641: PPUSH
84642: CALL_OW 140
// continue ;
84646: GO 83490
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84648: LD_VAR 0 4
84652: PUSH
84653: LD_VAR 0 7
84657: ARRAY
84658: PPUSH
84659: LD_INT 10
84661: PPUSH
84662: CALL 81291 0 2
84666: NOT
84667: PUSH
84668: LD_VAR 0 16
84672: PUSH
84673: LD_VAR 0 7
84677: ARRAY
84678: PUSH
84679: EMPTY
84680: EQUAL
84681: NOT
84682: AND
84683: IFFALSE 84949
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84685: LD_VAR 0 4
84689: PUSH
84690: LD_VAR 0 7
84694: ARRAY
84695: PPUSH
84696: CALL_OW 262
84700: PUSH
84701: LD_INT 1
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: IN
84711: IFFALSE 84752
// if GetFuel ( group [ i ] ) < 10 then
84713: LD_VAR 0 4
84717: PUSH
84718: LD_VAR 0 7
84722: ARRAY
84723: PPUSH
84724: CALL_OW 261
84728: PUSH
84729: LD_INT 10
84731: LESS
84732: IFFALSE 84752
// SetFuel ( group [ i ] , 12 ) ;
84734: LD_VAR 0 4
84738: PUSH
84739: LD_VAR 0 7
84743: ARRAY
84744: PPUSH
84745: LD_INT 12
84747: PPUSH
84748: CALL_OW 240
// if units_path [ i ] then
84752: LD_VAR 0 16
84756: PUSH
84757: LD_VAR 0 7
84761: ARRAY
84762: IFFALSE 84947
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84764: LD_VAR 0 4
84768: PUSH
84769: LD_VAR 0 7
84773: ARRAY
84774: PPUSH
84775: LD_VAR 0 16
84779: PUSH
84780: LD_VAR 0 7
84784: ARRAY
84785: PUSH
84786: LD_INT 1
84788: ARRAY
84789: PUSH
84790: LD_INT 1
84792: ARRAY
84793: PPUSH
84794: LD_VAR 0 16
84798: PUSH
84799: LD_VAR 0 7
84803: ARRAY
84804: PUSH
84805: LD_INT 1
84807: ARRAY
84808: PUSH
84809: LD_INT 2
84811: ARRAY
84812: PPUSH
84813: CALL_OW 297
84817: PUSH
84818: LD_INT 6
84820: GREATER
84821: IFFALSE 84896
// begin if not HasTask ( group [ i ] ) then
84823: LD_VAR 0 4
84827: PUSH
84828: LD_VAR 0 7
84832: ARRAY
84833: PPUSH
84834: CALL_OW 314
84838: NOT
84839: IFFALSE 84894
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84841: LD_VAR 0 4
84845: PUSH
84846: LD_VAR 0 7
84850: ARRAY
84851: PPUSH
84852: LD_VAR 0 16
84856: PUSH
84857: LD_VAR 0 7
84861: ARRAY
84862: PUSH
84863: LD_INT 1
84865: ARRAY
84866: PUSH
84867: LD_INT 1
84869: ARRAY
84870: PPUSH
84871: LD_VAR 0 16
84875: PUSH
84876: LD_VAR 0 7
84880: ARRAY
84881: PUSH
84882: LD_INT 1
84884: ARRAY
84885: PUSH
84886: LD_INT 2
84888: ARRAY
84889: PPUSH
84890: CALL_OW 114
// end else
84894: GO 84947
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84896: LD_ADDR_VAR 0 15
84900: PUSH
84901: LD_VAR 0 16
84905: PUSH
84906: LD_VAR 0 7
84910: ARRAY
84911: PPUSH
84912: LD_INT 1
84914: PPUSH
84915: CALL_OW 3
84919: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84920: LD_ADDR_VAR 0 16
84924: PUSH
84925: LD_VAR 0 16
84929: PPUSH
84930: LD_VAR 0 7
84934: PPUSH
84935: LD_VAR 0 15
84939: PPUSH
84940: CALL_OW 1
84944: ST_TO_ADDR
// continue ;
84945: GO 83490
// end ; end ; end else
84947: GO 87611
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84949: LD_ADDR_VAR 0 14
84953: PUSH
84954: LD_INT 81
84956: PUSH
84957: LD_VAR 0 4
84961: PUSH
84962: LD_VAR 0 7
84966: ARRAY
84967: PPUSH
84968: CALL_OW 255
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PPUSH
84977: CALL_OW 69
84981: ST_TO_ADDR
// if not tmp then
84982: LD_VAR 0 14
84986: NOT
84987: IFFALSE 84991
// continue ;
84989: GO 83490
// if f_ignore_area then
84991: LD_VAR 0 17
84995: IFFALSE 85083
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84997: LD_ADDR_VAR 0 15
85001: PUSH
85002: LD_VAR 0 14
85006: PPUSH
85007: LD_INT 3
85009: PUSH
85010: LD_INT 92
85012: PUSH
85013: LD_VAR 0 17
85017: PUSH
85018: LD_INT 1
85020: ARRAY
85021: PUSH
85022: LD_VAR 0 17
85026: PUSH
85027: LD_INT 2
85029: ARRAY
85030: PUSH
85031: LD_VAR 0 17
85035: PUSH
85036: LD_INT 3
85038: ARRAY
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PPUSH
85050: CALL_OW 72
85054: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85055: LD_VAR 0 14
85059: PUSH
85060: LD_VAR 0 15
85064: DIFF
85065: IFFALSE 85083
// tmp := tmp diff tmp2 ;
85067: LD_ADDR_VAR 0 14
85071: PUSH
85072: LD_VAR 0 14
85076: PUSH
85077: LD_VAR 0 15
85081: DIFF
85082: ST_TO_ADDR
// end ; if not f_murder then
85083: LD_VAR 0 20
85087: NOT
85088: IFFALSE 85146
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85090: LD_ADDR_VAR 0 15
85094: PUSH
85095: LD_VAR 0 14
85099: PPUSH
85100: LD_INT 3
85102: PUSH
85103: LD_INT 50
85105: PUSH
85106: EMPTY
85107: LIST
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PPUSH
85113: CALL_OW 72
85117: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85118: LD_VAR 0 14
85122: PUSH
85123: LD_VAR 0 15
85127: DIFF
85128: IFFALSE 85146
// tmp := tmp diff tmp2 ;
85130: LD_ADDR_VAR 0 14
85134: PUSH
85135: LD_VAR 0 14
85139: PUSH
85140: LD_VAR 0 15
85144: DIFF
85145: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85146: LD_ADDR_VAR 0 14
85150: PUSH
85151: LD_VAR 0 4
85155: PUSH
85156: LD_VAR 0 7
85160: ARRAY
85161: PPUSH
85162: LD_VAR 0 14
85166: PPUSH
85167: LD_INT 1
85169: PPUSH
85170: LD_INT 1
85172: PPUSH
85173: CALL 54934 0 4
85177: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85178: LD_VAR 0 4
85182: PUSH
85183: LD_VAR 0 7
85187: ARRAY
85188: PPUSH
85189: CALL_OW 257
85193: PUSH
85194: LD_INT 1
85196: EQUAL
85197: IFFALSE 85645
// begin if WantPlant ( group [ i ] ) then
85199: LD_VAR 0 4
85203: PUSH
85204: LD_VAR 0 7
85208: ARRAY
85209: PPUSH
85210: CALL 54435 0 1
85214: IFFALSE 85218
// continue ;
85216: GO 83490
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85218: LD_VAR 0 18
85222: PUSH
85223: LD_VAR 0 4
85227: PUSH
85228: LD_VAR 0 7
85232: ARRAY
85233: PPUSH
85234: CALL_OW 310
85238: NOT
85239: AND
85240: PUSH
85241: LD_VAR 0 14
85245: PUSH
85246: LD_INT 1
85248: ARRAY
85249: PUSH
85250: LD_VAR 0 14
85254: PPUSH
85255: LD_INT 21
85257: PUSH
85258: LD_INT 2
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 58
85267: PUSH
85268: EMPTY
85269: LIST
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PPUSH
85275: CALL_OW 72
85279: IN
85280: AND
85281: IFFALSE 85317
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85283: LD_VAR 0 4
85287: PUSH
85288: LD_VAR 0 7
85292: ARRAY
85293: PPUSH
85294: LD_VAR 0 14
85298: PUSH
85299: LD_INT 1
85301: ARRAY
85302: PPUSH
85303: CALL_OW 120
// attacking := true ;
85307: LD_ADDR_VAR 0 29
85311: PUSH
85312: LD_INT 1
85314: ST_TO_ADDR
// continue ;
85315: GO 83490
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85317: LD_VAR 0 26
85321: PUSH
85322: LD_VAR 0 4
85326: PUSH
85327: LD_VAR 0 7
85331: ARRAY
85332: PPUSH
85333: CALL_OW 257
85337: PUSH
85338: LD_INT 1
85340: EQUAL
85341: AND
85342: PUSH
85343: LD_VAR 0 4
85347: PUSH
85348: LD_VAR 0 7
85352: ARRAY
85353: PPUSH
85354: CALL_OW 256
85358: PUSH
85359: LD_INT 800
85361: LESS
85362: AND
85363: PUSH
85364: LD_VAR 0 4
85368: PUSH
85369: LD_VAR 0 7
85373: ARRAY
85374: PPUSH
85375: CALL_OW 318
85379: NOT
85380: AND
85381: IFFALSE 85398
// ComCrawl ( group [ i ] ) ;
85383: LD_VAR 0 4
85387: PUSH
85388: LD_VAR 0 7
85392: ARRAY
85393: PPUSH
85394: CALL_OW 137
// if f_mines then
85398: LD_VAR 0 21
85402: IFFALSE 85645
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85404: LD_VAR 0 14
85408: PUSH
85409: LD_INT 1
85411: ARRAY
85412: PPUSH
85413: CALL_OW 247
85417: PUSH
85418: LD_INT 3
85420: EQUAL
85421: PUSH
85422: LD_VAR 0 14
85426: PUSH
85427: LD_INT 1
85429: ARRAY
85430: PUSH
85431: LD_VAR 0 27
85435: IN
85436: NOT
85437: AND
85438: IFFALSE 85645
// begin x := GetX ( tmp [ 1 ] ) ;
85440: LD_ADDR_VAR 0 10
85444: PUSH
85445: LD_VAR 0 14
85449: PUSH
85450: LD_INT 1
85452: ARRAY
85453: PPUSH
85454: CALL_OW 250
85458: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85459: LD_ADDR_VAR 0 11
85463: PUSH
85464: LD_VAR 0 14
85468: PUSH
85469: LD_INT 1
85471: ARRAY
85472: PPUSH
85473: CALL_OW 251
85477: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85478: LD_ADDR_VAR 0 12
85482: PUSH
85483: LD_VAR 0 4
85487: PUSH
85488: LD_VAR 0 7
85492: ARRAY
85493: PPUSH
85494: CALL 81376 0 1
85498: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85499: LD_VAR 0 4
85503: PUSH
85504: LD_VAR 0 7
85508: ARRAY
85509: PPUSH
85510: LD_VAR 0 10
85514: PPUSH
85515: LD_VAR 0 11
85519: PPUSH
85520: LD_VAR 0 14
85524: PUSH
85525: LD_INT 1
85527: ARRAY
85528: PPUSH
85529: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85533: LD_VAR 0 4
85537: PUSH
85538: LD_VAR 0 7
85542: ARRAY
85543: PPUSH
85544: LD_VAR 0 10
85548: PPUSH
85549: LD_VAR 0 12
85553: PPUSH
85554: LD_INT 7
85556: PPUSH
85557: CALL_OW 272
85561: PPUSH
85562: LD_VAR 0 11
85566: PPUSH
85567: LD_VAR 0 12
85571: PPUSH
85572: LD_INT 7
85574: PPUSH
85575: CALL_OW 273
85579: PPUSH
85580: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85584: LD_VAR 0 4
85588: PUSH
85589: LD_VAR 0 7
85593: ARRAY
85594: PPUSH
85595: LD_INT 71
85597: PPUSH
85598: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85602: LD_ADDR_VAR 0 27
85606: PUSH
85607: LD_VAR 0 27
85611: PPUSH
85612: LD_VAR 0 27
85616: PUSH
85617: LD_INT 1
85619: PLUS
85620: PPUSH
85621: LD_VAR 0 14
85625: PUSH
85626: LD_INT 1
85628: ARRAY
85629: PPUSH
85630: CALL_OW 1
85634: ST_TO_ADDR
// attacking := true ;
85635: LD_ADDR_VAR 0 29
85639: PUSH
85640: LD_INT 1
85642: ST_TO_ADDR
// continue ;
85643: GO 83490
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85645: LD_VAR 0 4
85649: PUSH
85650: LD_VAR 0 7
85654: ARRAY
85655: PPUSH
85656: CALL_OW 257
85660: PUSH
85661: LD_INT 17
85663: EQUAL
85664: PUSH
85665: LD_VAR 0 4
85669: PUSH
85670: LD_VAR 0 7
85674: ARRAY
85675: PPUSH
85676: CALL_OW 110
85680: PUSH
85681: LD_INT 71
85683: EQUAL
85684: NOT
85685: AND
85686: IFFALSE 85832
// begin attacking := false ;
85688: LD_ADDR_VAR 0 29
85692: PUSH
85693: LD_INT 0
85695: ST_TO_ADDR
// k := 5 ;
85696: LD_ADDR_VAR 0 9
85700: PUSH
85701: LD_INT 5
85703: ST_TO_ADDR
// if tmp < k then
85704: LD_VAR 0 14
85708: PUSH
85709: LD_VAR 0 9
85713: LESS
85714: IFFALSE 85726
// k := tmp ;
85716: LD_ADDR_VAR 0 9
85720: PUSH
85721: LD_VAR 0 14
85725: ST_TO_ADDR
// for j = 1 to k do
85726: LD_ADDR_VAR 0 8
85730: PUSH
85731: DOUBLE
85732: LD_INT 1
85734: DEC
85735: ST_TO_ADDR
85736: LD_VAR 0 9
85740: PUSH
85741: FOR_TO
85742: IFFALSE 85830
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85744: LD_VAR 0 14
85748: PUSH
85749: LD_VAR 0 8
85753: ARRAY
85754: PUSH
85755: LD_VAR 0 14
85759: PPUSH
85760: LD_INT 58
85762: PUSH
85763: EMPTY
85764: LIST
85765: PPUSH
85766: CALL_OW 72
85770: IN
85771: NOT
85772: IFFALSE 85828
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85774: LD_VAR 0 4
85778: PUSH
85779: LD_VAR 0 7
85783: ARRAY
85784: PPUSH
85785: LD_VAR 0 14
85789: PUSH
85790: LD_VAR 0 8
85794: ARRAY
85795: PPUSH
85796: CALL_OW 115
// attacking := true ;
85800: LD_ADDR_VAR 0 29
85804: PUSH
85805: LD_INT 1
85807: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85808: LD_VAR 0 4
85812: PUSH
85813: LD_VAR 0 7
85817: ARRAY
85818: PPUSH
85819: LD_INT 71
85821: PPUSH
85822: CALL_OW 109
// continue ;
85826: GO 85741
// end ; end ;
85828: GO 85741
85830: POP
85831: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85832: LD_VAR 0 4
85836: PUSH
85837: LD_VAR 0 7
85841: ARRAY
85842: PPUSH
85843: CALL_OW 257
85847: PUSH
85848: LD_INT 8
85850: EQUAL
85851: PUSH
85852: LD_VAR 0 4
85856: PUSH
85857: LD_VAR 0 7
85861: ARRAY
85862: PPUSH
85863: CALL_OW 264
85867: PUSH
85868: LD_INT 28
85870: PUSH
85871: LD_INT 45
85873: PUSH
85874: LD_INT 7
85876: PUSH
85877: LD_INT 47
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: IN
85886: OR
85887: IFFALSE 86143
// begin attacking := false ;
85889: LD_ADDR_VAR 0 29
85893: PUSH
85894: LD_INT 0
85896: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85897: LD_VAR 0 14
85901: PUSH
85902: LD_INT 1
85904: ARRAY
85905: PPUSH
85906: CALL_OW 266
85910: PUSH
85911: LD_INT 32
85913: PUSH
85914: LD_INT 31
85916: PUSH
85917: LD_INT 33
85919: PUSH
85920: LD_INT 4
85922: PUSH
85923: LD_INT 5
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: IN
85933: IFFALSE 86119
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85935: LD_ADDR_VAR 0 9
85939: PUSH
85940: LD_VAR 0 14
85944: PUSH
85945: LD_INT 1
85947: ARRAY
85948: PPUSH
85949: CALL_OW 266
85953: PPUSH
85954: LD_VAR 0 14
85958: PUSH
85959: LD_INT 1
85961: ARRAY
85962: PPUSH
85963: CALL_OW 250
85967: PPUSH
85968: LD_VAR 0 14
85972: PUSH
85973: LD_INT 1
85975: ARRAY
85976: PPUSH
85977: CALL_OW 251
85981: PPUSH
85982: LD_VAR 0 14
85986: PUSH
85987: LD_INT 1
85989: ARRAY
85990: PPUSH
85991: CALL_OW 254
85995: PPUSH
85996: LD_VAR 0 14
86000: PUSH
86001: LD_INT 1
86003: ARRAY
86004: PPUSH
86005: CALL_OW 248
86009: PPUSH
86010: LD_INT 0
86012: PPUSH
86013: CALL 62746 0 6
86017: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86018: LD_ADDR_VAR 0 8
86022: PUSH
86023: LD_VAR 0 4
86027: PUSH
86028: LD_VAR 0 7
86032: ARRAY
86033: PPUSH
86034: LD_VAR 0 9
86038: PPUSH
86039: CALL 81416 0 2
86043: ST_TO_ADDR
// if j then
86044: LD_VAR 0 8
86048: IFFALSE 86117
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86050: LD_VAR 0 8
86054: PUSH
86055: LD_INT 1
86057: ARRAY
86058: PPUSH
86059: LD_VAR 0 8
86063: PUSH
86064: LD_INT 2
86066: ARRAY
86067: PPUSH
86068: CALL_OW 488
86072: IFFALSE 86117
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86074: LD_VAR 0 4
86078: PUSH
86079: LD_VAR 0 7
86083: ARRAY
86084: PPUSH
86085: LD_VAR 0 8
86089: PUSH
86090: LD_INT 1
86092: ARRAY
86093: PPUSH
86094: LD_VAR 0 8
86098: PUSH
86099: LD_INT 2
86101: ARRAY
86102: PPUSH
86103: CALL_OW 116
// attacking := true ;
86107: LD_ADDR_VAR 0 29
86111: PUSH
86112: LD_INT 1
86114: ST_TO_ADDR
// continue ;
86115: GO 83490
// end ; end else
86117: GO 86143
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86119: LD_VAR 0 4
86123: PUSH
86124: LD_VAR 0 7
86128: ARRAY
86129: PPUSH
86130: LD_VAR 0 14
86134: PUSH
86135: LD_INT 1
86137: ARRAY
86138: PPUSH
86139: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86143: LD_VAR 0 4
86147: PUSH
86148: LD_VAR 0 7
86152: ARRAY
86153: PPUSH
86154: CALL_OW 265
86158: PUSH
86159: LD_INT 11
86161: EQUAL
86162: IFFALSE 86440
// begin k := 10 ;
86164: LD_ADDR_VAR 0 9
86168: PUSH
86169: LD_INT 10
86171: ST_TO_ADDR
// x := 0 ;
86172: LD_ADDR_VAR 0 10
86176: PUSH
86177: LD_INT 0
86179: ST_TO_ADDR
// if tmp < k then
86180: LD_VAR 0 14
86184: PUSH
86185: LD_VAR 0 9
86189: LESS
86190: IFFALSE 86202
// k := tmp ;
86192: LD_ADDR_VAR 0 9
86196: PUSH
86197: LD_VAR 0 14
86201: ST_TO_ADDR
// for j = k downto 1 do
86202: LD_ADDR_VAR 0 8
86206: PUSH
86207: DOUBLE
86208: LD_VAR 0 9
86212: INC
86213: ST_TO_ADDR
86214: LD_INT 1
86216: PUSH
86217: FOR_DOWNTO
86218: IFFALSE 86293
// begin if GetType ( tmp [ j ] ) = unit_human then
86220: LD_VAR 0 14
86224: PUSH
86225: LD_VAR 0 8
86229: ARRAY
86230: PPUSH
86231: CALL_OW 247
86235: PUSH
86236: LD_INT 1
86238: EQUAL
86239: IFFALSE 86291
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86241: LD_VAR 0 4
86245: PUSH
86246: LD_VAR 0 7
86250: ARRAY
86251: PPUSH
86252: LD_VAR 0 14
86256: PUSH
86257: LD_VAR 0 8
86261: ARRAY
86262: PPUSH
86263: CALL 81687 0 2
// x := tmp [ j ] ;
86267: LD_ADDR_VAR 0 10
86271: PUSH
86272: LD_VAR 0 14
86276: PUSH
86277: LD_VAR 0 8
86281: ARRAY
86282: ST_TO_ADDR
// attacking := true ;
86283: LD_ADDR_VAR 0 29
86287: PUSH
86288: LD_INT 1
86290: ST_TO_ADDR
// end ; end ;
86291: GO 86217
86293: POP
86294: POP
// if not x then
86295: LD_VAR 0 10
86299: NOT
86300: IFFALSE 86440
// begin attacking := true ;
86302: LD_ADDR_VAR 0 29
86306: PUSH
86307: LD_INT 1
86309: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86310: LD_VAR 0 4
86314: PUSH
86315: LD_VAR 0 7
86319: ARRAY
86320: PPUSH
86321: CALL_OW 250
86325: PPUSH
86326: LD_VAR 0 4
86330: PUSH
86331: LD_VAR 0 7
86335: ARRAY
86336: PPUSH
86337: CALL_OW 251
86341: PPUSH
86342: CALL_OW 546
86346: PUSH
86347: LD_INT 2
86349: ARRAY
86350: PUSH
86351: LD_VAR 0 14
86355: PUSH
86356: LD_INT 1
86358: ARRAY
86359: PPUSH
86360: CALL_OW 250
86364: PPUSH
86365: LD_VAR 0 14
86369: PUSH
86370: LD_INT 1
86372: ARRAY
86373: PPUSH
86374: CALL_OW 251
86378: PPUSH
86379: CALL_OW 546
86383: PUSH
86384: LD_INT 2
86386: ARRAY
86387: EQUAL
86388: IFFALSE 86416
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86390: LD_VAR 0 4
86394: PUSH
86395: LD_VAR 0 7
86399: ARRAY
86400: PPUSH
86401: LD_VAR 0 14
86405: PUSH
86406: LD_INT 1
86408: ARRAY
86409: PPUSH
86410: CALL 81687 0 2
86414: GO 86440
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86416: LD_VAR 0 4
86420: PUSH
86421: LD_VAR 0 7
86425: ARRAY
86426: PPUSH
86427: LD_VAR 0 14
86431: PUSH
86432: LD_INT 1
86434: ARRAY
86435: PPUSH
86436: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86440: LD_VAR 0 4
86444: PUSH
86445: LD_VAR 0 7
86449: ARRAY
86450: PPUSH
86451: CALL_OW 264
86455: PUSH
86456: LD_INT 29
86458: EQUAL
86459: IFFALSE 86825
// begin if WantsToAttack ( group [ i ] ) in bombed then
86461: LD_VAR 0 4
86465: PUSH
86466: LD_VAR 0 7
86470: ARRAY
86471: PPUSH
86472: CALL_OW 319
86476: PUSH
86477: LD_VAR 0 28
86481: IN
86482: IFFALSE 86486
// continue ;
86484: GO 83490
// k := 8 ;
86486: LD_ADDR_VAR 0 9
86490: PUSH
86491: LD_INT 8
86493: ST_TO_ADDR
// x := 0 ;
86494: LD_ADDR_VAR 0 10
86498: PUSH
86499: LD_INT 0
86501: ST_TO_ADDR
// if tmp < k then
86502: LD_VAR 0 14
86506: PUSH
86507: LD_VAR 0 9
86511: LESS
86512: IFFALSE 86524
// k := tmp ;
86514: LD_ADDR_VAR 0 9
86518: PUSH
86519: LD_VAR 0 14
86523: ST_TO_ADDR
// for j = 1 to k do
86524: LD_ADDR_VAR 0 8
86528: PUSH
86529: DOUBLE
86530: LD_INT 1
86532: DEC
86533: ST_TO_ADDR
86534: LD_VAR 0 9
86538: PUSH
86539: FOR_TO
86540: IFFALSE 86672
// begin if GetType ( tmp [ j ] ) = unit_building then
86542: LD_VAR 0 14
86546: PUSH
86547: LD_VAR 0 8
86551: ARRAY
86552: PPUSH
86553: CALL_OW 247
86557: PUSH
86558: LD_INT 3
86560: EQUAL
86561: IFFALSE 86670
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86563: LD_VAR 0 14
86567: PUSH
86568: LD_VAR 0 8
86572: ARRAY
86573: PUSH
86574: LD_VAR 0 28
86578: IN
86579: NOT
86580: PUSH
86581: LD_VAR 0 14
86585: PUSH
86586: LD_VAR 0 8
86590: ARRAY
86591: PPUSH
86592: CALL_OW 313
86596: AND
86597: IFFALSE 86670
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86599: LD_VAR 0 4
86603: PUSH
86604: LD_VAR 0 7
86608: ARRAY
86609: PPUSH
86610: LD_VAR 0 14
86614: PUSH
86615: LD_VAR 0 8
86619: ARRAY
86620: PPUSH
86621: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86625: LD_ADDR_VAR 0 28
86629: PUSH
86630: LD_VAR 0 28
86634: PPUSH
86635: LD_VAR 0 28
86639: PUSH
86640: LD_INT 1
86642: PLUS
86643: PPUSH
86644: LD_VAR 0 14
86648: PUSH
86649: LD_VAR 0 8
86653: ARRAY
86654: PPUSH
86655: CALL_OW 1
86659: ST_TO_ADDR
// attacking := true ;
86660: LD_ADDR_VAR 0 29
86664: PUSH
86665: LD_INT 1
86667: ST_TO_ADDR
// break ;
86668: GO 86672
// end ; end ;
86670: GO 86539
86672: POP
86673: POP
// if not attacking and f_attack_depot then
86674: LD_VAR 0 29
86678: NOT
86679: PUSH
86680: LD_VAR 0 25
86684: AND
86685: IFFALSE 86780
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86687: LD_ADDR_VAR 0 13
86691: PUSH
86692: LD_VAR 0 14
86696: PPUSH
86697: LD_INT 2
86699: PUSH
86700: LD_INT 30
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 30
86712: PUSH
86713: LD_INT 1
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: LIST
86724: PPUSH
86725: CALL_OW 72
86729: ST_TO_ADDR
// if z then
86730: LD_VAR 0 13
86734: IFFALSE 86780
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86736: LD_VAR 0 4
86740: PUSH
86741: LD_VAR 0 7
86745: ARRAY
86746: PPUSH
86747: LD_VAR 0 13
86751: PPUSH
86752: LD_VAR 0 4
86756: PUSH
86757: LD_VAR 0 7
86761: ARRAY
86762: PPUSH
86763: CALL_OW 74
86767: PPUSH
86768: CALL_OW 115
// attacking := true ;
86772: LD_ADDR_VAR 0 29
86776: PUSH
86777: LD_INT 1
86779: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86780: LD_VAR 0 4
86784: PUSH
86785: LD_VAR 0 7
86789: ARRAY
86790: PPUSH
86791: CALL_OW 256
86795: PUSH
86796: LD_INT 500
86798: LESS
86799: IFFALSE 86825
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86801: LD_VAR 0 4
86805: PUSH
86806: LD_VAR 0 7
86810: ARRAY
86811: PPUSH
86812: LD_VAR 0 14
86816: PUSH
86817: LD_INT 1
86819: ARRAY
86820: PPUSH
86821: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86825: LD_VAR 0 4
86829: PUSH
86830: LD_VAR 0 7
86834: ARRAY
86835: PPUSH
86836: CALL_OW 264
86840: PUSH
86841: LD_INT 49
86843: EQUAL
86844: IFFALSE 86965
// begin if not HasTask ( group [ i ] ) then
86846: LD_VAR 0 4
86850: PUSH
86851: LD_VAR 0 7
86855: ARRAY
86856: PPUSH
86857: CALL_OW 314
86861: NOT
86862: IFFALSE 86965
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86864: LD_ADDR_VAR 0 9
86868: PUSH
86869: LD_INT 81
86871: PUSH
86872: LD_VAR 0 4
86876: PUSH
86877: LD_VAR 0 7
86881: ARRAY
86882: PPUSH
86883: CALL_OW 255
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PPUSH
86892: CALL_OW 69
86896: PPUSH
86897: LD_VAR 0 4
86901: PUSH
86902: LD_VAR 0 7
86906: ARRAY
86907: PPUSH
86908: CALL_OW 74
86912: ST_TO_ADDR
// if k then
86913: LD_VAR 0 9
86917: IFFALSE 86965
// if GetDistUnits ( group [ i ] , k ) > 10 then
86919: LD_VAR 0 4
86923: PUSH
86924: LD_VAR 0 7
86928: ARRAY
86929: PPUSH
86930: LD_VAR 0 9
86934: PPUSH
86935: CALL_OW 296
86939: PUSH
86940: LD_INT 10
86942: GREATER
86943: IFFALSE 86965
// ComMoveUnit ( group [ i ] , k ) ;
86945: LD_VAR 0 4
86949: PUSH
86950: LD_VAR 0 7
86954: ARRAY
86955: PPUSH
86956: LD_VAR 0 9
86960: PPUSH
86961: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86965: LD_VAR 0 4
86969: PUSH
86970: LD_VAR 0 7
86974: ARRAY
86975: PPUSH
86976: CALL_OW 256
86980: PUSH
86981: LD_INT 250
86983: LESS
86984: PUSH
86985: LD_VAR 0 4
86989: PUSH
86990: LD_VAR 0 7
86994: ARRAY
86995: PUSH
86996: LD_INT 21
86998: PUSH
86999: LD_INT 2
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: PUSH
87006: LD_INT 23
87008: PUSH
87009: LD_INT 2
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PPUSH
87020: CALL_OW 69
87024: IN
87025: AND
87026: IFFALSE 87151
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87028: LD_ADDR_VAR 0 9
87032: PUSH
87033: LD_OWVAR 3
87037: PUSH
87038: LD_VAR 0 4
87042: PUSH
87043: LD_VAR 0 7
87047: ARRAY
87048: DIFF
87049: PPUSH
87050: LD_VAR 0 4
87054: PUSH
87055: LD_VAR 0 7
87059: ARRAY
87060: PPUSH
87061: CALL_OW 74
87065: ST_TO_ADDR
// if not k then
87066: LD_VAR 0 9
87070: NOT
87071: IFFALSE 87075
// continue ;
87073: GO 83490
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87075: LD_VAR 0 9
87079: PUSH
87080: LD_INT 81
87082: PUSH
87083: LD_VAR 0 4
87087: PUSH
87088: LD_VAR 0 7
87092: ARRAY
87093: PPUSH
87094: CALL_OW 255
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PPUSH
87103: CALL_OW 69
87107: IN
87108: PUSH
87109: LD_VAR 0 9
87113: PPUSH
87114: LD_VAR 0 4
87118: PUSH
87119: LD_VAR 0 7
87123: ARRAY
87124: PPUSH
87125: CALL_OW 296
87129: PUSH
87130: LD_INT 5
87132: LESS
87133: AND
87134: IFFALSE 87151
// ComAutodestruct ( group [ i ] ) ;
87136: LD_VAR 0 4
87140: PUSH
87141: LD_VAR 0 7
87145: ARRAY
87146: PPUSH
87147: CALL 81585 0 1
// end ; if f_attack_depot then
87151: LD_VAR 0 25
87155: IFFALSE 87267
// begin k := 6 ;
87157: LD_ADDR_VAR 0 9
87161: PUSH
87162: LD_INT 6
87164: ST_TO_ADDR
// if tmp < k then
87165: LD_VAR 0 14
87169: PUSH
87170: LD_VAR 0 9
87174: LESS
87175: IFFALSE 87187
// k := tmp ;
87177: LD_ADDR_VAR 0 9
87181: PUSH
87182: LD_VAR 0 14
87186: ST_TO_ADDR
// for j = 1 to k do
87187: LD_ADDR_VAR 0 8
87191: PUSH
87192: DOUBLE
87193: LD_INT 1
87195: DEC
87196: ST_TO_ADDR
87197: LD_VAR 0 9
87201: PUSH
87202: FOR_TO
87203: IFFALSE 87265
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87205: LD_VAR 0 8
87209: PPUSH
87210: CALL_OW 266
87214: PUSH
87215: LD_INT 0
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: IN
87225: IFFALSE 87263
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87227: LD_VAR 0 4
87231: PUSH
87232: LD_VAR 0 7
87236: ARRAY
87237: PPUSH
87238: LD_VAR 0 14
87242: PUSH
87243: LD_VAR 0 8
87247: ARRAY
87248: PPUSH
87249: CALL_OW 115
// attacking := true ;
87253: LD_ADDR_VAR 0 29
87257: PUSH
87258: LD_INT 1
87260: ST_TO_ADDR
// break ;
87261: GO 87265
// end ;
87263: GO 87202
87265: POP
87266: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87267: LD_VAR 0 4
87271: PUSH
87272: LD_VAR 0 7
87276: ARRAY
87277: PPUSH
87278: CALL_OW 302
87282: PUSH
87283: LD_VAR 0 29
87287: NOT
87288: AND
87289: IFFALSE 87611
// begin if GetTag ( group [ i ] ) = 71 then
87291: LD_VAR 0 4
87295: PUSH
87296: LD_VAR 0 7
87300: ARRAY
87301: PPUSH
87302: CALL_OW 110
87306: PUSH
87307: LD_INT 71
87309: EQUAL
87310: IFFALSE 87351
// begin if HasTask ( group [ i ] ) then
87312: LD_VAR 0 4
87316: PUSH
87317: LD_VAR 0 7
87321: ARRAY
87322: PPUSH
87323: CALL_OW 314
87327: IFFALSE 87333
// continue else
87329: GO 83490
87331: GO 87351
// SetTag ( group [ i ] , 0 ) ;
87333: LD_VAR 0 4
87337: PUSH
87338: LD_VAR 0 7
87342: ARRAY
87343: PPUSH
87344: LD_INT 0
87346: PPUSH
87347: CALL_OW 109
// end ; k := 8 ;
87351: LD_ADDR_VAR 0 9
87355: PUSH
87356: LD_INT 8
87358: ST_TO_ADDR
// x := 0 ;
87359: LD_ADDR_VAR 0 10
87363: PUSH
87364: LD_INT 0
87366: ST_TO_ADDR
// if tmp < k then
87367: LD_VAR 0 14
87371: PUSH
87372: LD_VAR 0 9
87376: LESS
87377: IFFALSE 87389
// k := tmp ;
87379: LD_ADDR_VAR 0 9
87383: PUSH
87384: LD_VAR 0 14
87388: ST_TO_ADDR
// for j = 1 to k do
87389: LD_ADDR_VAR 0 8
87393: PUSH
87394: DOUBLE
87395: LD_INT 1
87397: DEC
87398: ST_TO_ADDR
87399: LD_VAR 0 9
87403: PUSH
87404: FOR_TO
87405: IFFALSE 87503
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87407: LD_VAR 0 14
87411: PUSH
87412: LD_VAR 0 8
87416: ARRAY
87417: PPUSH
87418: CALL_OW 247
87422: PUSH
87423: LD_INT 1
87425: EQUAL
87426: PUSH
87427: LD_VAR 0 14
87431: PUSH
87432: LD_VAR 0 8
87436: ARRAY
87437: PPUSH
87438: CALL_OW 256
87442: PUSH
87443: LD_INT 250
87445: LESS
87446: PUSH
87447: LD_VAR 0 20
87451: AND
87452: PUSH
87453: LD_VAR 0 20
87457: NOT
87458: PUSH
87459: LD_VAR 0 14
87463: PUSH
87464: LD_VAR 0 8
87468: ARRAY
87469: PPUSH
87470: CALL_OW 256
87474: PUSH
87475: LD_INT 250
87477: GREATEREQUAL
87478: AND
87479: OR
87480: AND
87481: IFFALSE 87501
// begin x := tmp [ j ] ;
87483: LD_ADDR_VAR 0 10
87487: PUSH
87488: LD_VAR 0 14
87492: PUSH
87493: LD_VAR 0 8
87497: ARRAY
87498: ST_TO_ADDR
// break ;
87499: GO 87503
// end ;
87501: GO 87404
87503: POP
87504: POP
// if x then
87505: LD_VAR 0 10
87509: IFFALSE 87533
// ComAttackUnit ( group [ i ] , x ) else
87511: LD_VAR 0 4
87515: PUSH
87516: LD_VAR 0 7
87520: ARRAY
87521: PPUSH
87522: LD_VAR 0 10
87526: PPUSH
87527: CALL_OW 115
87531: GO 87557
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87533: LD_VAR 0 4
87537: PUSH
87538: LD_VAR 0 7
87542: ARRAY
87543: PPUSH
87544: LD_VAR 0 14
87548: PUSH
87549: LD_INT 1
87551: ARRAY
87552: PPUSH
87553: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87557: LD_VAR 0 4
87561: PUSH
87562: LD_VAR 0 7
87566: ARRAY
87567: PPUSH
87568: CALL_OW 314
87572: NOT
87573: IFFALSE 87611
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87575: LD_VAR 0 4
87579: PUSH
87580: LD_VAR 0 7
87584: ARRAY
87585: PPUSH
87586: LD_VAR 0 14
87590: PPUSH
87591: LD_VAR 0 4
87595: PUSH
87596: LD_VAR 0 7
87600: ARRAY
87601: PPUSH
87602: CALL_OW 74
87606: PPUSH
87607: CALL_OW 115
// end ; end ; end ;
87611: GO 83490
87613: POP
87614: POP
// wait ( 0 0$1 ) ;
87615: LD_INT 35
87617: PPUSH
87618: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87622: LD_VAR 0 4
87626: PUSH
87627: EMPTY
87628: EQUAL
87629: PUSH
87630: LD_INT 81
87632: PUSH
87633: LD_VAR 0 35
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PPUSH
87642: CALL_OW 69
87646: NOT
87647: OR
87648: IFFALSE 83475
// end ;
87650: LD_VAR 0 2
87654: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87655: LD_INT 0
87657: PPUSH
87658: PPUSH
87659: PPUSH
87660: PPUSH
// if not base_units then
87661: LD_VAR 0 1
87665: NOT
87666: IFFALSE 87670
// exit ;
87668: GO 87757
// result := false ;
87670: LD_ADDR_VAR 0 2
87674: PUSH
87675: LD_INT 0
87677: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87678: LD_ADDR_VAR 0 5
87682: PUSH
87683: LD_VAR 0 1
87687: PPUSH
87688: LD_INT 21
87690: PUSH
87691: LD_INT 3
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PPUSH
87698: CALL_OW 72
87702: ST_TO_ADDR
// if not tmp then
87703: LD_VAR 0 5
87707: NOT
87708: IFFALSE 87712
// exit ;
87710: GO 87757
// for i in tmp do
87712: LD_ADDR_VAR 0 3
87716: PUSH
87717: LD_VAR 0 5
87721: PUSH
87722: FOR_IN
87723: IFFALSE 87755
// begin result := EnemyInRange ( i , 22 ) ;
87725: LD_ADDR_VAR 0 2
87729: PUSH
87730: LD_VAR 0 3
87734: PPUSH
87735: LD_INT 22
87737: PPUSH
87738: CALL 81291 0 2
87742: ST_TO_ADDR
// if result then
87743: LD_VAR 0 2
87747: IFFALSE 87753
// exit ;
87749: POP
87750: POP
87751: GO 87757
// end ;
87753: GO 87722
87755: POP
87756: POP
// end ;
87757: LD_VAR 0 2
87761: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87762: LD_INT 0
87764: PPUSH
87765: PPUSH
// if not units then
87766: LD_VAR 0 1
87770: NOT
87771: IFFALSE 87775
// exit ;
87773: GO 87845
// result := [ ] ;
87775: LD_ADDR_VAR 0 3
87779: PUSH
87780: EMPTY
87781: ST_TO_ADDR
// for i in units do
87782: LD_ADDR_VAR 0 4
87786: PUSH
87787: LD_VAR 0 1
87791: PUSH
87792: FOR_IN
87793: IFFALSE 87843
// if GetTag ( i ) = tag then
87795: LD_VAR 0 4
87799: PPUSH
87800: CALL_OW 110
87804: PUSH
87805: LD_VAR 0 2
87809: EQUAL
87810: IFFALSE 87841
// result := Insert ( result , result + 1 , i ) ;
87812: LD_ADDR_VAR 0 3
87816: PUSH
87817: LD_VAR 0 3
87821: PPUSH
87822: LD_VAR 0 3
87826: PUSH
87827: LD_INT 1
87829: PLUS
87830: PPUSH
87831: LD_VAR 0 4
87835: PPUSH
87836: CALL_OW 2
87840: ST_TO_ADDR
87841: GO 87792
87843: POP
87844: POP
// end ;
87845: LD_VAR 0 3
87849: RET
// export function IsDriver ( un ) ; begin
87850: LD_INT 0
87852: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87853: LD_ADDR_VAR 0 2
87857: PUSH
87858: LD_VAR 0 1
87862: PUSH
87863: LD_INT 55
87865: PUSH
87866: EMPTY
87867: LIST
87868: PPUSH
87869: CALL_OW 69
87873: IN
87874: ST_TO_ADDR
// end ;
87875: LD_VAR 0 2
87879: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87880: LD_INT 0
87882: PPUSH
87883: PPUSH
// list := [ ] ;
87884: LD_ADDR_VAR 0 5
87888: PUSH
87889: EMPTY
87890: ST_TO_ADDR
// case d of 0 :
87891: LD_VAR 0 3
87895: PUSH
87896: LD_INT 0
87898: DOUBLE
87899: EQUAL
87900: IFTRUE 87904
87902: GO 88037
87904: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87905: LD_ADDR_VAR 0 5
87909: PUSH
87910: LD_VAR 0 1
87914: PUSH
87915: LD_INT 4
87917: MINUS
87918: PUSH
87919: LD_VAR 0 2
87923: PUSH
87924: LD_INT 4
87926: MINUS
87927: PUSH
87928: LD_INT 2
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: LIST
87935: PUSH
87936: LD_VAR 0 1
87940: PUSH
87941: LD_INT 3
87943: MINUS
87944: PUSH
87945: LD_VAR 0 2
87949: PUSH
87950: LD_INT 1
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: LIST
87957: PUSH
87958: LD_VAR 0 1
87962: PUSH
87963: LD_INT 4
87965: PLUS
87966: PUSH
87967: LD_VAR 0 2
87971: PUSH
87972: LD_INT 4
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: LIST
87979: PUSH
87980: LD_VAR 0 1
87984: PUSH
87985: LD_INT 3
87987: PLUS
87988: PUSH
87989: LD_VAR 0 2
87993: PUSH
87994: LD_INT 3
87996: PLUS
87997: PUSH
87998: LD_INT 5
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: PUSH
88006: LD_VAR 0 1
88010: PUSH
88011: LD_VAR 0 2
88015: PUSH
88016: LD_INT 4
88018: PLUS
88019: PUSH
88020: LD_INT 0
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: LIST
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: ST_TO_ADDR
// end ; 1 :
88035: GO 88735
88037: LD_INT 1
88039: DOUBLE
88040: EQUAL
88041: IFTRUE 88045
88043: GO 88178
88045: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88046: LD_ADDR_VAR 0 5
88050: PUSH
88051: LD_VAR 0 1
88055: PUSH
88056: LD_VAR 0 2
88060: PUSH
88061: LD_INT 4
88063: MINUS
88064: PUSH
88065: LD_INT 3
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: LIST
88072: PUSH
88073: LD_VAR 0 1
88077: PUSH
88078: LD_INT 3
88080: MINUS
88081: PUSH
88082: LD_VAR 0 2
88086: PUSH
88087: LD_INT 3
88089: MINUS
88090: PUSH
88091: LD_INT 2
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: LIST
88098: PUSH
88099: LD_VAR 0 1
88103: PUSH
88104: LD_INT 4
88106: MINUS
88107: PUSH
88108: LD_VAR 0 2
88112: PUSH
88113: LD_INT 1
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: LIST
88120: PUSH
88121: LD_VAR 0 1
88125: PUSH
88126: LD_VAR 0 2
88130: PUSH
88131: LD_INT 3
88133: PLUS
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: LIST
88142: PUSH
88143: LD_VAR 0 1
88147: PUSH
88148: LD_INT 4
88150: PLUS
88151: PUSH
88152: LD_VAR 0 2
88156: PUSH
88157: LD_INT 4
88159: PLUS
88160: PUSH
88161: LD_INT 5
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: LIST
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: ST_TO_ADDR
// end ; 2 :
88176: GO 88735
88178: LD_INT 2
88180: DOUBLE
88181: EQUAL
88182: IFTRUE 88186
88184: GO 88315
88186: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88187: LD_ADDR_VAR 0 5
88191: PUSH
88192: LD_VAR 0 1
88196: PUSH
88197: LD_VAR 0 2
88201: PUSH
88202: LD_INT 3
88204: MINUS
88205: PUSH
88206: LD_INT 3
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: LIST
88213: PUSH
88214: LD_VAR 0 1
88218: PUSH
88219: LD_INT 4
88221: PLUS
88222: PUSH
88223: LD_VAR 0 2
88227: PUSH
88228: LD_INT 4
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: LIST
88235: PUSH
88236: LD_VAR 0 1
88240: PUSH
88241: LD_VAR 0 2
88245: PUSH
88246: LD_INT 4
88248: PLUS
88249: PUSH
88250: LD_INT 0
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: LIST
88257: PUSH
88258: LD_VAR 0 1
88262: PUSH
88263: LD_INT 3
88265: MINUS
88266: PUSH
88267: LD_VAR 0 2
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: LIST
88279: PUSH
88280: LD_VAR 0 1
88284: PUSH
88285: LD_INT 4
88287: MINUS
88288: PUSH
88289: LD_VAR 0 2
88293: PUSH
88294: LD_INT 4
88296: MINUS
88297: PUSH
88298: LD_INT 2
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: LIST
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: ST_TO_ADDR
// end ; 3 :
88313: GO 88735
88315: LD_INT 3
88317: DOUBLE
88318: EQUAL
88319: IFTRUE 88323
88321: GO 88456
88323: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88324: LD_ADDR_VAR 0 5
88328: PUSH
88329: LD_VAR 0 1
88333: PUSH
88334: LD_INT 3
88336: PLUS
88337: PUSH
88338: LD_VAR 0 2
88342: PUSH
88343: LD_INT 4
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: LIST
88350: PUSH
88351: LD_VAR 0 1
88355: PUSH
88356: LD_INT 4
88358: PLUS
88359: PUSH
88360: LD_VAR 0 2
88364: PUSH
88365: LD_INT 4
88367: PLUS
88368: PUSH
88369: LD_INT 5
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: LIST
88376: PUSH
88377: LD_VAR 0 1
88381: PUSH
88382: LD_INT 4
88384: MINUS
88385: PUSH
88386: LD_VAR 0 2
88390: PUSH
88391: LD_INT 1
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: PUSH
88399: LD_VAR 0 1
88403: PUSH
88404: LD_VAR 0 2
88408: PUSH
88409: LD_INT 4
88411: MINUS
88412: PUSH
88413: LD_INT 3
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: LIST
88420: PUSH
88421: LD_VAR 0 1
88425: PUSH
88426: LD_INT 3
88428: MINUS
88429: PUSH
88430: LD_VAR 0 2
88434: PUSH
88435: LD_INT 3
88437: MINUS
88438: PUSH
88439: LD_INT 2
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: LIST
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: ST_TO_ADDR
// end ; 4 :
88454: GO 88735
88456: LD_INT 4
88458: DOUBLE
88459: EQUAL
88460: IFTRUE 88464
88462: GO 88597
88464: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88465: LD_ADDR_VAR 0 5
88469: PUSH
88470: LD_VAR 0 1
88474: PUSH
88475: LD_VAR 0 2
88479: PUSH
88480: LD_INT 4
88482: PLUS
88483: PUSH
88484: LD_INT 0
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: LIST
88491: PUSH
88492: LD_VAR 0 1
88496: PUSH
88497: LD_INT 3
88499: PLUS
88500: PUSH
88501: LD_VAR 0 2
88505: PUSH
88506: LD_INT 3
88508: PLUS
88509: PUSH
88510: LD_INT 5
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: LIST
88517: PUSH
88518: LD_VAR 0 1
88522: PUSH
88523: LD_INT 4
88525: PLUS
88526: PUSH
88527: LD_VAR 0 2
88531: PUSH
88532: LD_INT 4
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: LIST
88539: PUSH
88540: LD_VAR 0 1
88544: PUSH
88545: LD_VAR 0 2
88549: PUSH
88550: LD_INT 3
88552: MINUS
88553: PUSH
88554: LD_INT 3
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: LIST
88561: PUSH
88562: LD_VAR 0 1
88566: PUSH
88567: LD_INT 4
88569: MINUS
88570: PUSH
88571: LD_VAR 0 2
88575: PUSH
88576: LD_INT 4
88578: MINUS
88579: PUSH
88580: LD_INT 2
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: LIST
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: ST_TO_ADDR
// end ; 5 :
88595: GO 88735
88597: LD_INT 5
88599: DOUBLE
88600: EQUAL
88601: IFTRUE 88605
88603: GO 88734
88605: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88606: LD_ADDR_VAR 0 5
88610: PUSH
88611: LD_VAR 0 1
88615: PUSH
88616: LD_INT 4
88618: MINUS
88619: PUSH
88620: LD_VAR 0 2
88624: PUSH
88625: LD_INT 1
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: LIST
88632: PUSH
88633: LD_VAR 0 1
88637: PUSH
88638: LD_VAR 0 2
88642: PUSH
88643: LD_INT 4
88645: MINUS
88646: PUSH
88647: LD_INT 3
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: LIST
88654: PUSH
88655: LD_VAR 0 1
88659: PUSH
88660: LD_INT 4
88662: PLUS
88663: PUSH
88664: LD_VAR 0 2
88668: PUSH
88669: LD_INT 4
88671: PLUS
88672: PUSH
88673: LD_INT 5
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: LIST
88680: PUSH
88681: LD_VAR 0 1
88685: PUSH
88686: LD_INT 3
88688: PLUS
88689: PUSH
88690: LD_VAR 0 2
88694: PUSH
88695: LD_INT 4
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: LIST
88702: PUSH
88703: LD_VAR 0 1
88707: PUSH
88708: LD_VAR 0 2
88712: PUSH
88713: LD_INT 3
88715: PLUS
88716: PUSH
88717: LD_INT 0
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: LIST
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: ST_TO_ADDR
// end ; end ;
88732: GO 88735
88734: POP
// result := list ;
88735: LD_ADDR_VAR 0 4
88739: PUSH
88740: LD_VAR 0 5
88744: ST_TO_ADDR
// end ;
88745: LD_VAR 0 4
88749: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88750: LD_INT 0
88752: PPUSH
88753: PPUSH
88754: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88755: LD_VAR 0 1
88759: NOT
88760: PUSH
88761: LD_VAR 0 2
88765: PUSH
88766: LD_INT 1
88768: PUSH
88769: LD_INT 2
88771: PUSH
88772: LD_INT 3
88774: PUSH
88775: LD_INT 4
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: IN
88784: NOT
88785: OR
88786: IFFALSE 88790
// exit ;
88788: GO 88882
// tmp := [ ] ;
88790: LD_ADDR_VAR 0 5
88794: PUSH
88795: EMPTY
88796: ST_TO_ADDR
// for i in units do
88797: LD_ADDR_VAR 0 4
88801: PUSH
88802: LD_VAR 0 1
88806: PUSH
88807: FOR_IN
88808: IFFALSE 88851
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88810: LD_ADDR_VAR 0 5
88814: PUSH
88815: LD_VAR 0 5
88819: PPUSH
88820: LD_VAR 0 5
88824: PUSH
88825: LD_INT 1
88827: PLUS
88828: PPUSH
88829: LD_VAR 0 4
88833: PPUSH
88834: LD_VAR 0 2
88838: PPUSH
88839: CALL_OW 259
88843: PPUSH
88844: CALL_OW 2
88848: ST_TO_ADDR
88849: GO 88807
88851: POP
88852: POP
// if not tmp then
88853: LD_VAR 0 5
88857: NOT
88858: IFFALSE 88862
// exit ;
88860: GO 88882
// result := SortListByListDesc ( units , tmp ) ;
88862: LD_ADDR_VAR 0 3
88866: PUSH
88867: LD_VAR 0 1
88871: PPUSH
88872: LD_VAR 0 5
88876: PPUSH
88877: CALL_OW 77
88881: ST_TO_ADDR
// end ;
88882: LD_VAR 0 3
88886: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88887: LD_INT 0
88889: PPUSH
88890: PPUSH
88891: PPUSH
// x := GetX ( building ) ;
88892: LD_ADDR_VAR 0 4
88896: PUSH
88897: LD_VAR 0 2
88901: PPUSH
88902: CALL_OW 250
88906: ST_TO_ADDR
// y := GetY ( building ) ;
88907: LD_ADDR_VAR 0 5
88911: PUSH
88912: LD_VAR 0 2
88916: PPUSH
88917: CALL_OW 251
88921: ST_TO_ADDR
// if GetTaskList ( unit ) then
88922: LD_VAR 0 1
88926: PPUSH
88927: CALL_OW 437
88931: IFFALSE 89026
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88933: LD_STRING e
88935: PUSH
88936: LD_VAR 0 1
88940: PPUSH
88941: CALL_OW 437
88945: PUSH
88946: LD_INT 1
88948: ARRAY
88949: PUSH
88950: LD_INT 1
88952: ARRAY
88953: EQUAL
88954: PUSH
88955: LD_VAR 0 4
88959: PUSH
88960: LD_VAR 0 1
88964: PPUSH
88965: CALL_OW 437
88969: PUSH
88970: LD_INT 1
88972: ARRAY
88973: PUSH
88974: LD_INT 2
88976: ARRAY
88977: EQUAL
88978: AND
88979: PUSH
88980: LD_VAR 0 5
88984: PUSH
88985: LD_VAR 0 1
88989: PPUSH
88990: CALL_OW 437
88994: PUSH
88995: LD_INT 1
88997: ARRAY
88998: PUSH
88999: LD_INT 3
89001: ARRAY
89002: EQUAL
89003: AND
89004: IFFALSE 89016
// result := true else
89006: LD_ADDR_VAR 0 3
89010: PUSH
89011: LD_INT 1
89013: ST_TO_ADDR
89014: GO 89024
// result := false ;
89016: LD_ADDR_VAR 0 3
89020: PUSH
89021: LD_INT 0
89023: ST_TO_ADDR
// end else
89024: GO 89034
// result := false ;
89026: LD_ADDR_VAR 0 3
89030: PUSH
89031: LD_INT 0
89033: ST_TO_ADDR
// end ;
89034: LD_VAR 0 3
89038: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89039: LD_INT 0
89041: PPUSH
89042: PPUSH
89043: PPUSH
89044: PPUSH
// if not unit or not area then
89045: LD_VAR 0 1
89049: NOT
89050: PUSH
89051: LD_VAR 0 2
89055: NOT
89056: OR
89057: IFFALSE 89061
// exit ;
89059: GO 89225
// tmp := AreaToList ( area , i ) ;
89061: LD_ADDR_VAR 0 6
89065: PUSH
89066: LD_VAR 0 2
89070: PPUSH
89071: LD_VAR 0 5
89075: PPUSH
89076: CALL_OW 517
89080: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89081: LD_ADDR_VAR 0 5
89085: PUSH
89086: DOUBLE
89087: LD_INT 1
89089: DEC
89090: ST_TO_ADDR
89091: LD_VAR 0 6
89095: PUSH
89096: LD_INT 1
89098: ARRAY
89099: PUSH
89100: FOR_TO
89101: IFFALSE 89223
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89103: LD_ADDR_VAR 0 7
89107: PUSH
89108: LD_VAR 0 6
89112: PUSH
89113: LD_INT 1
89115: ARRAY
89116: PUSH
89117: LD_VAR 0 5
89121: ARRAY
89122: PUSH
89123: LD_VAR 0 6
89127: PUSH
89128: LD_INT 2
89130: ARRAY
89131: PUSH
89132: LD_VAR 0 5
89136: ARRAY
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
89142: LD_VAR 0 7
89146: PUSH
89147: LD_INT 1
89149: ARRAY
89150: PPUSH
89151: LD_VAR 0 7
89155: PUSH
89156: LD_INT 2
89158: ARRAY
89159: PPUSH
89160: CALL_OW 428
89164: PUSH
89165: LD_INT 0
89167: EQUAL
89168: IFFALSE 89221
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89170: LD_VAR 0 1
89174: PPUSH
89175: LD_VAR 0 7
89179: PUSH
89180: LD_INT 1
89182: ARRAY
89183: PPUSH
89184: LD_VAR 0 7
89188: PUSH
89189: LD_INT 2
89191: ARRAY
89192: PPUSH
89193: LD_VAR 0 3
89197: PPUSH
89198: CALL_OW 48
// result := IsPlaced ( unit ) ;
89202: LD_ADDR_VAR 0 4
89206: PUSH
89207: LD_VAR 0 1
89211: PPUSH
89212: CALL_OW 305
89216: ST_TO_ADDR
// exit ;
89217: POP
89218: POP
89219: GO 89225
// end ; end ;
89221: GO 89100
89223: POP
89224: POP
// end ;
89225: LD_VAR 0 4
89229: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89230: LD_INT 0
89232: PPUSH
89233: PPUSH
89234: PPUSH
// if not side or side > 8 then
89235: LD_VAR 0 1
89239: NOT
89240: PUSH
89241: LD_VAR 0 1
89245: PUSH
89246: LD_INT 8
89248: GREATER
89249: OR
89250: IFFALSE 89254
// exit ;
89252: GO 89441
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89254: LD_ADDR_VAR 0 4
89258: PUSH
89259: LD_INT 22
89261: PUSH
89262: LD_VAR 0 1
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 21
89273: PUSH
89274: LD_INT 3
89276: PUSH
89277: EMPTY
89278: LIST
89279: LIST
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PPUSH
89285: CALL_OW 69
89289: ST_TO_ADDR
// if not tmp then
89290: LD_VAR 0 4
89294: NOT
89295: IFFALSE 89299
// exit ;
89297: GO 89441
// enable_addtolog := true ;
89299: LD_ADDR_OWVAR 81
89303: PUSH
89304: LD_INT 1
89306: ST_TO_ADDR
// AddToLog ( [ ) ;
89307: LD_STRING [
89309: PPUSH
89310: CALL_OW 561
// for i in tmp do
89314: LD_ADDR_VAR 0 3
89318: PUSH
89319: LD_VAR 0 4
89323: PUSH
89324: FOR_IN
89325: IFFALSE 89432
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89327: LD_STRING [
89329: PUSH
89330: LD_VAR 0 3
89334: PPUSH
89335: CALL_OW 266
89339: STR
89340: PUSH
89341: LD_STRING , 
89343: STR
89344: PUSH
89345: LD_VAR 0 3
89349: PPUSH
89350: CALL_OW 250
89354: STR
89355: PUSH
89356: LD_STRING , 
89358: STR
89359: PUSH
89360: LD_VAR 0 3
89364: PPUSH
89365: CALL_OW 251
89369: STR
89370: PUSH
89371: LD_STRING , 
89373: STR
89374: PUSH
89375: LD_VAR 0 3
89379: PPUSH
89380: CALL_OW 254
89384: STR
89385: PUSH
89386: LD_STRING , 
89388: STR
89389: PUSH
89390: LD_VAR 0 3
89394: PPUSH
89395: LD_INT 1
89397: PPUSH
89398: CALL_OW 268
89402: STR
89403: PUSH
89404: LD_STRING , 
89406: STR
89407: PUSH
89408: LD_VAR 0 3
89412: PPUSH
89413: LD_INT 2
89415: PPUSH
89416: CALL_OW 268
89420: STR
89421: PUSH
89422: LD_STRING ],
89424: STR
89425: PPUSH
89426: CALL_OW 561
// end ;
89430: GO 89324
89432: POP
89433: POP
// AddToLog ( ]; ) ;
89434: LD_STRING ];
89436: PPUSH
89437: CALL_OW 561
// end ;
89441: LD_VAR 0 2
89445: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89446: LD_INT 0
89448: PPUSH
89449: PPUSH
89450: PPUSH
89451: PPUSH
89452: PPUSH
// if not area or not rate or not max then
89453: LD_VAR 0 1
89457: NOT
89458: PUSH
89459: LD_VAR 0 2
89463: NOT
89464: OR
89465: PUSH
89466: LD_VAR 0 4
89470: NOT
89471: OR
89472: IFFALSE 89476
// exit ;
89474: GO 89668
// while 1 do
89476: LD_INT 1
89478: IFFALSE 89668
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89480: LD_ADDR_VAR 0 9
89484: PUSH
89485: LD_VAR 0 1
89489: PPUSH
89490: LD_INT 1
89492: PPUSH
89493: CALL_OW 287
89497: PUSH
89498: LD_INT 10
89500: MUL
89501: ST_TO_ADDR
// r := rate / 10 ;
89502: LD_ADDR_VAR 0 7
89506: PUSH
89507: LD_VAR 0 2
89511: PUSH
89512: LD_INT 10
89514: DIVREAL
89515: ST_TO_ADDR
// time := 1 1$00 ;
89516: LD_ADDR_VAR 0 8
89520: PUSH
89521: LD_INT 2100
89523: ST_TO_ADDR
// if amount < min then
89524: LD_VAR 0 9
89528: PUSH
89529: LD_VAR 0 3
89533: LESS
89534: IFFALSE 89552
// r := r * 2 else
89536: LD_ADDR_VAR 0 7
89540: PUSH
89541: LD_VAR 0 7
89545: PUSH
89546: LD_INT 2
89548: MUL
89549: ST_TO_ADDR
89550: GO 89578
// if amount > max then
89552: LD_VAR 0 9
89556: PUSH
89557: LD_VAR 0 4
89561: GREATER
89562: IFFALSE 89578
// r := r / 2 ;
89564: LD_ADDR_VAR 0 7
89568: PUSH
89569: LD_VAR 0 7
89573: PUSH
89574: LD_INT 2
89576: DIVREAL
89577: ST_TO_ADDR
// time := time / r ;
89578: LD_ADDR_VAR 0 8
89582: PUSH
89583: LD_VAR 0 8
89587: PUSH
89588: LD_VAR 0 7
89592: DIVREAL
89593: ST_TO_ADDR
// if time < 0 then
89594: LD_VAR 0 8
89598: PUSH
89599: LD_INT 0
89601: LESS
89602: IFFALSE 89619
// time := time * - 1 ;
89604: LD_ADDR_VAR 0 8
89608: PUSH
89609: LD_VAR 0 8
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: MUL
89618: ST_TO_ADDR
// wait ( time ) ;
89619: LD_VAR 0 8
89623: PPUSH
89624: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89628: LD_INT 35
89630: PPUSH
89631: LD_INT 875
89633: PPUSH
89634: CALL_OW 12
89638: PPUSH
89639: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89643: LD_INT 1
89645: PPUSH
89646: LD_INT 5
89648: PPUSH
89649: CALL_OW 12
89653: PPUSH
89654: LD_VAR 0 1
89658: PPUSH
89659: LD_INT 1
89661: PPUSH
89662: CALL_OW 55
// end ;
89666: GO 89476
// end ;
89668: LD_VAR 0 5
89672: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89673: LD_INT 0
89675: PPUSH
89676: PPUSH
89677: PPUSH
89678: PPUSH
89679: PPUSH
89680: PPUSH
89681: PPUSH
89682: PPUSH
// if not turrets or not factories then
89683: LD_VAR 0 1
89687: NOT
89688: PUSH
89689: LD_VAR 0 2
89693: NOT
89694: OR
89695: IFFALSE 89699
// exit ;
89697: GO 90006
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89699: LD_ADDR_VAR 0 10
89703: PUSH
89704: LD_INT 5
89706: PUSH
89707: LD_INT 6
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: PUSH
89714: LD_INT 2
89716: PUSH
89717: LD_INT 4
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 3
89726: PUSH
89727: LD_INT 5
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 24
89741: PUSH
89742: LD_INT 25
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 23
89751: PUSH
89752: LD_INT 27
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 42
89765: PUSH
89766: LD_INT 43
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 44
89775: PUSH
89776: LD_INT 46
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 45
89785: PUSH
89786: LD_INT 47
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: LIST
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: LIST
89802: ST_TO_ADDR
// result := [ ] ;
89803: LD_ADDR_VAR 0 3
89807: PUSH
89808: EMPTY
89809: ST_TO_ADDR
// for i in turrets do
89810: LD_ADDR_VAR 0 4
89814: PUSH
89815: LD_VAR 0 1
89819: PUSH
89820: FOR_IN
89821: IFFALSE 90004
// begin nat := GetNation ( i ) ;
89823: LD_ADDR_VAR 0 7
89827: PUSH
89828: LD_VAR 0 4
89832: PPUSH
89833: CALL_OW 248
89837: ST_TO_ADDR
// weapon := 0 ;
89838: LD_ADDR_VAR 0 8
89842: PUSH
89843: LD_INT 0
89845: ST_TO_ADDR
// if not nat then
89846: LD_VAR 0 7
89850: NOT
89851: IFFALSE 89855
// continue ;
89853: GO 89820
// for j in list [ nat ] do
89855: LD_ADDR_VAR 0 5
89859: PUSH
89860: LD_VAR 0 10
89864: PUSH
89865: LD_VAR 0 7
89869: ARRAY
89870: PUSH
89871: FOR_IN
89872: IFFALSE 89913
// if GetBWeapon ( i ) = j [ 1 ] then
89874: LD_VAR 0 4
89878: PPUSH
89879: CALL_OW 269
89883: PUSH
89884: LD_VAR 0 5
89888: PUSH
89889: LD_INT 1
89891: ARRAY
89892: EQUAL
89893: IFFALSE 89911
// begin weapon := j [ 2 ] ;
89895: LD_ADDR_VAR 0 8
89899: PUSH
89900: LD_VAR 0 5
89904: PUSH
89905: LD_INT 2
89907: ARRAY
89908: ST_TO_ADDR
// break ;
89909: GO 89913
// end ;
89911: GO 89871
89913: POP
89914: POP
// if not weapon then
89915: LD_VAR 0 8
89919: NOT
89920: IFFALSE 89924
// continue ;
89922: GO 89820
// for k in factories do
89924: LD_ADDR_VAR 0 6
89928: PUSH
89929: LD_VAR 0 2
89933: PUSH
89934: FOR_IN
89935: IFFALSE 90000
// begin weapons := AvailableWeaponList ( k ) ;
89937: LD_ADDR_VAR 0 9
89941: PUSH
89942: LD_VAR 0 6
89946: PPUSH
89947: CALL_OW 478
89951: ST_TO_ADDR
// if not weapons then
89952: LD_VAR 0 9
89956: NOT
89957: IFFALSE 89961
// continue ;
89959: GO 89934
// if weapon in weapons then
89961: LD_VAR 0 8
89965: PUSH
89966: LD_VAR 0 9
89970: IN
89971: IFFALSE 89998
// begin result := [ i , weapon ] ;
89973: LD_ADDR_VAR 0 3
89977: PUSH
89978: LD_VAR 0 4
89982: PUSH
89983: LD_VAR 0 8
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: ST_TO_ADDR
// exit ;
89992: POP
89993: POP
89994: POP
89995: POP
89996: GO 90006
// end ; end ;
89998: GO 89934
90000: POP
90001: POP
// end ;
90002: GO 89820
90004: POP
90005: POP
// end ;
90006: LD_VAR 0 3
90010: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90011: LD_INT 0
90013: PPUSH
// if not side or side > 8 then
90014: LD_VAR 0 3
90018: NOT
90019: PUSH
90020: LD_VAR 0 3
90024: PUSH
90025: LD_INT 8
90027: GREATER
90028: OR
90029: IFFALSE 90033
// exit ;
90031: GO 90092
// if not range then
90033: LD_VAR 0 4
90037: NOT
90038: IFFALSE 90049
// range := - 12 ;
90040: LD_ADDR_VAR 0 4
90044: PUSH
90045: LD_INT 12
90047: NEG
90048: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90049: LD_VAR 0 1
90053: PPUSH
90054: LD_VAR 0 2
90058: PPUSH
90059: LD_VAR 0 3
90063: PPUSH
90064: LD_VAR 0 4
90068: PPUSH
90069: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90073: LD_VAR 0 1
90077: PPUSH
90078: LD_VAR 0 2
90082: PPUSH
90083: LD_VAR 0 3
90087: PPUSH
90088: CALL_OW 331
// end ;
90092: LD_VAR 0 5
90096: RET
// export function Video ( mode ) ; begin
90097: LD_INT 0
90099: PPUSH
// ingame_video = mode ;
90100: LD_ADDR_OWVAR 52
90104: PUSH
90105: LD_VAR 0 1
90109: ST_TO_ADDR
// interface_hidden = mode ;
90110: LD_ADDR_OWVAR 54
90114: PUSH
90115: LD_VAR 0 1
90119: ST_TO_ADDR
// end ;
90120: LD_VAR 0 2
90124: RET
// export function Join ( array , element ) ; begin
90125: LD_INT 0
90127: PPUSH
// result := array ^ element ;
90128: LD_ADDR_VAR 0 3
90132: PUSH
90133: LD_VAR 0 1
90137: PUSH
90138: LD_VAR 0 2
90142: ADD
90143: ST_TO_ADDR
// end ;
90144: LD_VAR 0 3
90148: RET
// export function JoinUnion ( array , element ) ; begin
90149: LD_INT 0
90151: PPUSH
// result := array union element ;
90152: LD_ADDR_VAR 0 3
90156: PUSH
90157: LD_VAR 0 1
90161: PUSH
90162: LD_VAR 0 2
90166: UNION
90167: ST_TO_ADDR
// end ;
90168: LD_VAR 0 3
90172: RET
// export function GetBehemoths ( side ) ; begin
90173: LD_INT 0
90175: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
90176: LD_ADDR_VAR 0 2
90180: PUSH
90181: LD_INT 22
90183: PUSH
90184: LD_VAR 0 1
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: LD_INT 31
90195: PUSH
90196: LD_INT 25
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: EMPTY
90204: LIST
90205: LIST
90206: PPUSH
90207: CALL_OW 69
90211: ST_TO_ADDR
// end ;
90212: LD_VAR 0 2
90216: RET
// export function Shuffle ( array ) ; var i , index ; begin
90217: LD_INT 0
90219: PPUSH
90220: PPUSH
90221: PPUSH
// result := [ ] ;
90222: LD_ADDR_VAR 0 2
90226: PUSH
90227: EMPTY
90228: ST_TO_ADDR
// if not array then
90229: LD_VAR 0 1
90233: NOT
90234: IFFALSE 90238
// exit ;
90236: GO 90337
// Randomize ;
90238: CALL_OW 10
// for i = array downto 1 do
90242: LD_ADDR_VAR 0 3
90246: PUSH
90247: DOUBLE
90248: LD_VAR 0 1
90252: INC
90253: ST_TO_ADDR
90254: LD_INT 1
90256: PUSH
90257: FOR_DOWNTO
90258: IFFALSE 90335
// begin index := rand ( 1 , array ) ;
90260: LD_ADDR_VAR 0 4
90264: PUSH
90265: LD_INT 1
90267: PPUSH
90268: LD_VAR 0 1
90272: PPUSH
90273: CALL_OW 12
90277: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90278: LD_ADDR_VAR 0 2
90282: PUSH
90283: LD_VAR 0 2
90287: PPUSH
90288: LD_VAR 0 2
90292: PUSH
90293: LD_INT 1
90295: PLUS
90296: PPUSH
90297: LD_VAR 0 1
90301: PUSH
90302: LD_VAR 0 4
90306: ARRAY
90307: PPUSH
90308: CALL_OW 2
90312: ST_TO_ADDR
// array := Delete ( array , index ) ;
90313: LD_ADDR_VAR 0 1
90317: PUSH
90318: LD_VAR 0 1
90322: PPUSH
90323: LD_VAR 0 4
90327: PPUSH
90328: CALL_OW 3
90332: ST_TO_ADDR
// end ;
90333: GO 90257
90335: POP
90336: POP
// end ;
90337: LD_VAR 0 2
90341: RET
// export function GetBaseMaterials ( base ) ; begin
90342: LD_INT 0
90344: PPUSH
// result := [ 0 , 0 , 0 ] ;
90345: LD_ADDR_VAR 0 2
90349: PUSH
90350: LD_INT 0
90352: PUSH
90353: LD_INT 0
90355: PUSH
90356: LD_INT 0
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: LIST
90363: ST_TO_ADDR
// if not base then
90364: LD_VAR 0 1
90368: NOT
90369: IFFALSE 90373
// exit ;
90371: GO 90422
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90373: LD_ADDR_VAR 0 2
90377: PUSH
90378: LD_VAR 0 1
90382: PPUSH
90383: LD_INT 1
90385: PPUSH
90386: CALL_OW 275
90390: PUSH
90391: LD_VAR 0 1
90395: PPUSH
90396: LD_INT 2
90398: PPUSH
90399: CALL_OW 275
90403: PUSH
90404: LD_VAR 0 1
90408: PPUSH
90409: LD_INT 3
90411: PPUSH
90412: CALL_OW 275
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: LIST
90421: ST_TO_ADDR
// end ; end_of_file
90422: LD_VAR 0 2
90426: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90427: GO 90429
90429: DISABLE
// begin ru_radar := 98 ;
90430: LD_ADDR_EXP 93
90434: PUSH
90435: LD_INT 98
90437: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90438: LD_ADDR_EXP 94
90442: PUSH
90443: LD_INT 89
90445: ST_TO_ADDR
// us_hack := 99 ;
90446: LD_ADDR_EXP 95
90450: PUSH
90451: LD_INT 99
90453: ST_TO_ADDR
// us_artillery := 97 ;
90454: LD_ADDR_EXP 96
90458: PUSH
90459: LD_INT 97
90461: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90462: LD_ADDR_EXP 97
90466: PUSH
90467: LD_INT 91
90469: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
90470: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
90471: LD_INT 0
90473: PPUSH
90474: PPUSH
90475: PPUSH
90476: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90477: LD_VAR 0 1
90481: PPUSH
90482: CALL_OW 264
90486: PUSH
90487: LD_EXP 97
90491: EQUAL
90492: IFFALSE 90564
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90494: LD_INT 68
90496: PPUSH
90497: LD_VAR 0 1
90501: PPUSH
90502: CALL_OW 255
90506: PPUSH
90507: CALL_OW 321
90511: PUSH
90512: LD_INT 2
90514: EQUAL
90515: IFFALSE 90527
// eff := 70 else
90517: LD_ADDR_VAR 0 6
90521: PUSH
90522: LD_INT 70
90524: ST_TO_ADDR
90525: GO 90535
// eff := 30 ;
90527: LD_ADDR_VAR 0 6
90531: PUSH
90532: LD_INT 30
90534: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90535: LD_VAR 0 1
90539: PPUSH
90540: CALL_OW 250
90544: PPUSH
90545: LD_VAR 0 1
90549: PPUSH
90550: CALL_OW 251
90554: PPUSH
90555: LD_VAR 0 6
90559: PPUSH
90560: CALL_OW 495
// end ; end ;
90564: LD_VAR 0 4
90568: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
90569: LD_INT 0
90571: PPUSH
90572: PPUSH
90573: PPUSH
90574: PPUSH
90575: PPUSH
90576: PPUSH
// if cmd = 124 then
90577: LD_VAR 0 1
90581: PUSH
90582: LD_INT 124
90584: EQUAL
90585: IFFALSE 90791
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
90587: LD_ADDR_VAR 0 5
90591: PUSH
90592: LD_INT 2
90594: PUSH
90595: LD_INT 34
90597: PUSH
90598: LD_INT 53
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 34
90607: PUSH
90608: LD_INT 14
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: LIST
90619: PPUSH
90620: CALL_OW 69
90624: ST_TO_ADDR
// if not tmp then
90625: LD_VAR 0 5
90629: NOT
90630: IFFALSE 90634
// exit ;
90632: GO 90791
// for i in tmp do
90634: LD_ADDR_VAR 0 3
90638: PUSH
90639: LD_VAR 0 5
90643: PUSH
90644: FOR_IN
90645: IFFALSE 90789
// begin taskList := GetTaskList ( i ) ;
90647: LD_ADDR_VAR 0 6
90651: PUSH
90652: LD_VAR 0 3
90656: PPUSH
90657: CALL_OW 437
90661: ST_TO_ADDR
// if not taskList then
90662: LD_VAR 0 6
90666: NOT
90667: IFFALSE 90671
// continue ;
90669: GO 90644
// for j = 1 to taskList do
90671: LD_ADDR_VAR 0 4
90675: PUSH
90676: DOUBLE
90677: LD_INT 1
90679: DEC
90680: ST_TO_ADDR
90681: LD_VAR 0 6
90685: PUSH
90686: FOR_TO
90687: IFFALSE 90785
// if taskList [ j ] [ 1 ] = | then
90689: LD_VAR 0 6
90693: PUSH
90694: LD_VAR 0 4
90698: ARRAY
90699: PUSH
90700: LD_INT 1
90702: ARRAY
90703: PUSH
90704: LD_STRING |
90706: EQUAL
90707: IFFALSE 90783
// begin _taskList := Delete ( taskList , 1 ) ;
90709: LD_ADDR_VAR 0 7
90713: PUSH
90714: LD_VAR 0 6
90718: PPUSH
90719: LD_INT 1
90721: PPUSH
90722: CALL_OW 3
90726: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
90727: LD_VAR 0 3
90731: PPUSH
90732: LD_VAR 0 7
90736: PPUSH
90737: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
90741: LD_VAR 0 3
90745: PPUSH
90746: LD_VAR 0 6
90750: PUSH
90751: LD_VAR 0 4
90755: ARRAY
90756: PUSH
90757: LD_INT 2
90759: ARRAY
90760: PPUSH
90761: LD_VAR 0 6
90765: PUSH
90766: LD_VAR 0 4
90770: ARRAY
90771: PUSH
90772: LD_INT 3
90774: ARRAY
90775: PPUSH
90776: LD_INT 8
90778: PPUSH
90779: CALL 90796 0 4
// end ;
90783: GO 90686
90785: POP
90786: POP
// end ;
90787: GO 90644
90789: POP
90790: POP
// end ; end ;
90791: LD_VAR 0 2
90795: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90796: LD_INT 0
90798: PPUSH
90799: PPUSH
90800: PPUSH
90801: PPUSH
90802: PPUSH
90803: PPUSH
90804: PPUSH
90805: PPUSH
90806: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90807: LD_VAR 0 1
90811: NOT
90812: PUSH
90813: LD_VAR 0 2
90817: PPUSH
90818: LD_VAR 0 3
90822: PPUSH
90823: CALL_OW 488
90827: NOT
90828: OR
90829: PUSH
90830: LD_VAR 0 4
90834: NOT
90835: OR
90836: IFFALSE 90840
// exit ;
90838: GO 91180
// list := [ ] ;
90840: LD_ADDR_VAR 0 13
90844: PUSH
90845: EMPTY
90846: ST_TO_ADDR
// if x - r < 0 then
90847: LD_VAR 0 2
90851: PUSH
90852: LD_VAR 0 4
90856: MINUS
90857: PUSH
90858: LD_INT 0
90860: LESS
90861: IFFALSE 90873
// min_x := 0 else
90863: LD_ADDR_VAR 0 7
90867: PUSH
90868: LD_INT 0
90870: ST_TO_ADDR
90871: GO 90889
// min_x := x - r ;
90873: LD_ADDR_VAR 0 7
90877: PUSH
90878: LD_VAR 0 2
90882: PUSH
90883: LD_VAR 0 4
90887: MINUS
90888: ST_TO_ADDR
// if y - r < 0 then
90889: LD_VAR 0 3
90893: PUSH
90894: LD_VAR 0 4
90898: MINUS
90899: PUSH
90900: LD_INT 0
90902: LESS
90903: IFFALSE 90915
// min_y := 0 else
90905: LD_ADDR_VAR 0 8
90909: PUSH
90910: LD_INT 0
90912: ST_TO_ADDR
90913: GO 90931
// min_y := y - r ;
90915: LD_ADDR_VAR 0 8
90919: PUSH
90920: LD_VAR 0 3
90924: PUSH
90925: LD_VAR 0 4
90929: MINUS
90930: ST_TO_ADDR
// max_x := x + r ;
90931: LD_ADDR_VAR 0 9
90935: PUSH
90936: LD_VAR 0 2
90940: PUSH
90941: LD_VAR 0 4
90945: PLUS
90946: ST_TO_ADDR
// max_y := y + r ;
90947: LD_ADDR_VAR 0 10
90951: PUSH
90952: LD_VAR 0 3
90956: PUSH
90957: LD_VAR 0 4
90961: PLUS
90962: ST_TO_ADDR
// for _x = min_x to max_x do
90963: LD_ADDR_VAR 0 11
90967: PUSH
90968: DOUBLE
90969: LD_VAR 0 7
90973: DEC
90974: ST_TO_ADDR
90975: LD_VAR 0 9
90979: PUSH
90980: FOR_TO
90981: IFFALSE 91098
// for _y = min_y to max_y do
90983: LD_ADDR_VAR 0 12
90987: PUSH
90988: DOUBLE
90989: LD_VAR 0 8
90993: DEC
90994: ST_TO_ADDR
90995: LD_VAR 0 10
90999: PUSH
91000: FOR_TO
91001: IFFALSE 91094
// begin if not ValidHex ( _x , _y ) then
91003: LD_VAR 0 11
91007: PPUSH
91008: LD_VAR 0 12
91012: PPUSH
91013: CALL_OW 488
91017: NOT
91018: IFFALSE 91022
// continue ;
91020: GO 91000
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91022: LD_VAR 0 11
91026: PPUSH
91027: LD_VAR 0 12
91031: PPUSH
91032: CALL_OW 351
91036: PUSH
91037: LD_VAR 0 11
91041: PPUSH
91042: LD_VAR 0 12
91046: PPUSH
91047: CALL_OW 554
91051: AND
91052: IFFALSE 91092
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91054: LD_ADDR_VAR 0 13
91058: PUSH
91059: LD_VAR 0 13
91063: PPUSH
91064: LD_VAR 0 13
91068: PUSH
91069: LD_INT 1
91071: PLUS
91072: PPUSH
91073: LD_VAR 0 11
91077: PUSH
91078: LD_VAR 0 12
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PPUSH
91087: CALL_OW 2
91091: ST_TO_ADDR
// end ;
91092: GO 91000
91094: POP
91095: POP
91096: GO 90980
91098: POP
91099: POP
// if not list then
91100: LD_VAR 0 13
91104: NOT
91105: IFFALSE 91109
// exit ;
91107: GO 91180
// for i in list do
91109: LD_ADDR_VAR 0 6
91113: PUSH
91114: LD_VAR 0 13
91118: PUSH
91119: FOR_IN
91120: IFFALSE 91178
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91122: LD_VAR 0 1
91126: PPUSH
91127: LD_STRING M
91129: PUSH
91130: LD_VAR 0 6
91134: PUSH
91135: LD_INT 1
91137: ARRAY
91138: PUSH
91139: LD_VAR 0 6
91143: PUSH
91144: LD_INT 2
91146: ARRAY
91147: PUSH
91148: LD_INT 0
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: LD_INT 0
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: PUSH
91169: EMPTY
91170: LIST
91171: PPUSH
91172: CALL_OW 447
91176: GO 91119
91178: POP
91179: POP
// end ;
91180: LD_VAR 0 5
91184: RET
