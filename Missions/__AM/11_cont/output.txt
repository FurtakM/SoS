// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 16817 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 81800 0 9
// PrepareAmerican ;
  77: CALL 525 0 0
// PrepareArabian ;
  81: CALL 2197 0 0
// MC_Start ( ) ;
  85: CALL 18929 0 0
// Action ;
  89: CALL 7689 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// end ;
 287: LD_VAR 0 1
 291: RET
// export function CustomInitMacro ; var i ; begin
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 296: LD_ADDR_EXP 73
 300: PUSH
 301: LD_INT 20
 303: PUSH
 304: LD_INT 21
 306: PUSH
 307: LD_INT 22
 309: PUSH
 310: EMPTY
 311: LIST
 312: LIST
 313: LIST
 314: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 315: LD_ADDR_EXP 74
 319: PUSH
 320: LD_INT 28
 322: PUSH
 323: LD_INT 24
 325: PUSH
 326: LD_INT 26
 328: PUSH
 329: EMPTY
 330: LIST
 331: LIST
 332: LIST
 333: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PUSH
 340: LD_INT 8
 342: PUSH
 343: LD_INT 9
 345: PUSH
 346: EMPTY
 347: LIST
 348: LIST
 349: LIST
 350: PUSH
 351: LD_OWVAR 67
 355: ARRAY
 356: PPUSH
 357: LD_INT 3
 359: PPUSH
 360: CALL 40250 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 364: LD_INT 2
 366: PPUSH
 367: LD_INT 6
 369: PUSH
 370: LD_INT 8
 372: PUSH
 373: LD_INT 9
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: PUSH
 381: LD_OWVAR 67
 385: ARRAY
 386: PPUSH
 387: LD_INT 2
 389: PPUSH
 390: CALL 40250 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 394: LD_INT 3
 396: PPUSH
 397: LD_INT 6
 399: PUSH
 400: LD_INT 7
 402: PUSH
 403: LD_INT 9
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: PUSH
 411: LD_OWVAR 67
 415: ARRAY
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL 40250 0 3
// for i = 1 to mc_bases do
 424: LD_ADDR_VAR 0 2
 428: PUSH
 429: DOUBLE
 430: LD_INT 1
 432: DEC
 433: ST_TO_ADDR
 434: LD_EXP 49
 438: PUSH
 439: FOR_TO
 440: IFFALSE 464
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 442: LD_VAR 0 2
 446: PPUSH
 447: LD_EXP 42
 451: PUSH
 452: LD_VAR 0 2
 456: ARRAY
 457: PPUSH
 458: CALL 40676 0 2
 462: GO 439
 464: POP
 465: POP
// end ;
 466: LD_VAR 0 1
 470: RET
// function Debuger ; var i ; begin
 471: LD_INT 0
 473: PPUSH
 474: PPUSH
// if not debug then
 475: LD_EXP 1
 479: NOT
 480: IFFALSE 484
// exit ;
 482: GO 520
// game_speed := 5 ;
 484: LD_ADDR_OWVAR 65
 488: PUSH
 489: LD_INT 5
 491: ST_TO_ADDR
// uc_side := 1 ;
 492: LD_ADDR_OWVAR 20
 496: PUSH
 497: LD_INT 1
 499: ST_TO_ADDR
// uc_nation := 1 ;
 500: LD_ADDR_OWVAR 21
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 508: LD_EXP 35
 512: PPUSH
 513: LD_INT 1
 515: PPUSH
 516: CALL_OW 235
// end ; end_of_file
 520: LD_VAR 0 1
 524: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 525: LD_INT 0
 527: PPUSH
 528: PPUSH
 529: PPUSH
 530: PPUSH
 531: PPUSH
 532: PPUSH
 533: PPUSH
 534: PPUSH
// uc_side := 4 ;
 535: LD_ADDR_OWVAR 20
 539: PUSH
 540: LD_INT 4
 542: ST_TO_ADDR
// uc_nation := 1 ;
 543: LD_ADDR_OWVAR 21
 547: PUSH
 548: LD_INT 1
 550: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 551: LD_ADDR_EXP 29
 555: PUSH
 556: LD_STRING Powell
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: LD_STRING 
 564: PPUSH
 565: CALL 46960 0 3
 569: ST_TO_ADDR
// uc_side := 1 ;
 570: LD_ADDR_OWVAR 20
 574: PUSH
 575: LD_INT 1
 577: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 578: LD_ADDR_EXP 20
 582: PUSH
 583: LD_STRING JMM
 585: PPUSH
 586: LD_EXP 1
 590: NOT
 591: PPUSH
 592: LD_EXP 4
 596: PPUSH
 597: CALL 46960 0 3
 601: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 602: LD_EXP 20
 606: PPUSH
 607: CALL_OW 257
 611: PUSH
 612: LD_INT 4
 614: GREATER
 615: IFFALSE 629
// SetClass ( JMM , 1 ) ;
 617: LD_EXP 20
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 629: LD_ADDR_EXP 21
 633: PUSH
 634: LD_STRING Lisa
 636: PPUSH
 637: LD_EXP 1
 641: NOT
 642: PPUSH
 643: LD_EXP 4
 647: PPUSH
 648: CALL 46960 0 3
 652: ST_TO_ADDR
// if not Lisa then
 653: LD_EXP 21
 657: NOT
 658: IFFALSE 673
// Lisa := CreateCharacter ( 10_Lisa ) ;
 660: LD_ADDR_EXP 21
 664: PUSH
 665: LD_STRING 10_Lisa
 667: PPUSH
 668: CALL_OW 34
 672: ST_TO_ADDR
// if not Lisa then
 673: LD_EXP 21
 677: NOT
 678: IFFALSE 693
// Lisa := CreateCharacter ( 09_Lisa ) ;
 680: LD_ADDR_EXP 21
 684: PUSH
 685: LD_STRING 09_Lisa
 687: PPUSH
 688: CALL_OW 34
 692: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 693: LD_ADDR_EXP 30
 697: PUSH
 698: LD_STRING Cornel
 700: PPUSH
 701: LD_EXP 1
 705: NOT
 706: PPUSH
 707: LD_EXP 4
 711: PPUSH
 712: CALL 46960 0 3
 716: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING Donaldson
 724: PPUSH
 725: LD_EXP 1
 729: NOT
 730: PPUSH
 731: LD_EXP 4
 735: PPUSH
 736: CALL 46960 0 3
 740: ST_TO_ADDR
// if not Donaldson then
 741: LD_EXP 22
 745: NOT
 746: IFFALSE 761
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 748: LD_ADDR_EXP 22
 752: PUSH
 753: LD_STRING 10_Donaldson
 755: PPUSH
 756: CALL_OW 34
 760: ST_TO_ADDR
// if not Donaldson then
 761: LD_EXP 22
 765: NOT
 766: IFFALSE 781
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 768: LD_ADDR_EXP 22
 772: PUSH
 773: LD_STRING 09_Donaldson
 775: PPUSH
 776: CALL_OW 34
 780: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 781: LD_ADDR_EXP 23
 785: PUSH
 786: LD_STRING Bobby
 788: PPUSH
 789: LD_EXP 1
 793: NOT
 794: PPUSH
 795: LD_EXP 4
 799: PPUSH
 800: CALL 46960 0 3
 804: ST_TO_ADDR
// if not Bobby then
 805: LD_EXP 23
 809: NOT
 810: IFFALSE 825
// Bobby := CreateCharacter ( 10_Bobby ) ;
 812: LD_ADDR_EXP 23
 816: PUSH
 817: LD_STRING 10_Bobby
 819: PPUSH
 820: CALL_OW 34
 824: ST_TO_ADDR
// if not Bobby then
 825: LD_EXP 23
 829: NOT
 830: IFFALSE 845
// Bobby := CreateCharacter ( 09_Bobby ) ;
 832: LD_ADDR_EXP 23
 836: PUSH
 837: LD_STRING 09_Bobby
 839: PPUSH
 840: CALL_OW 34
 844: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 24
 849: PUSH
 850: LD_STRING Cyrus
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 46960 0 3
 868: ST_TO_ADDR
// if not Cyrus then
 869: LD_EXP 24
 873: NOT
 874: IFFALSE 889
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 876: LD_ADDR_EXP 24
 880: PUSH
 881: LD_STRING 10_Cyrus
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Cyrus then
 889: LD_EXP 24
 893: NOT
 894: IFFALSE 909
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 896: LD_ADDR_EXP 24
 900: PUSH
 901: LD_STRING 09_Cyrus
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 25
 913: PUSH
 914: LD_STRING Denis
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 46960 0 3
 932: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 933: LD_ADDR_EXP 26
 937: PUSH
 938: LD_STRING Brown
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_EXP 4
 951: PPUSH
 952: CALL 46960 0 3
 956: ST_TO_ADDR
// if not Brown then
 957: LD_EXP 26
 961: NOT
 962: IFFALSE 977
// Brown := CreateCharacter ( 10_Brown ) ;
 964: LD_ADDR_EXP 26
 968: PUSH
 969: LD_STRING 10_Brown
 971: PPUSH
 972: CALL_OW 34
 976: ST_TO_ADDR
// if not Brown then
 977: LD_EXP 26
 981: NOT
 982: IFFALSE 997
// Brown := CreateCharacter ( 08_Brown ) ;
 984: LD_ADDR_EXP 26
 988: PUSH
 989: LD_STRING 08_Brown
 991: PPUSH
 992: CALL_OW 34
 996: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 997: LD_ADDR_EXP 27
1001: PUSH
1002: LD_STRING Gladstone
1004: PPUSH
1005: LD_EXP 1
1009: NOT
1010: PPUSH
1011: LD_EXP 4
1015: PPUSH
1016: CALL 46960 0 3
1020: ST_TO_ADDR
// if not Gladstone then
1021: LD_EXP 27
1025: NOT
1026: IFFALSE 1041
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1028: LD_ADDR_EXP 27
1032: PUSH
1033: LD_STRING 10_Gladstone
1035: PPUSH
1036: CALL_OW 34
1040: ST_TO_ADDR
// if not Gladstone then
1041: LD_EXP 27
1045: NOT
1046: IFFALSE 1061
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1048: LD_ADDR_EXP 27
1052: PUSH
1053: LD_STRING 08_Gladstone
1055: PPUSH
1056: CALL_OW 34
1060: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 28
1065: PUSH
1066: LD_STRING Houten
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 46960 0 3
1084: ST_TO_ADDR
// if not Houten then
1085: LD_EXP 28
1089: NOT
1090: IFFALSE 1105
// Houten := CreateCharacter ( 10_Houten ) ;
1092: LD_ADDR_EXP 28
1096: PUSH
1097: LD_STRING 10_Houten
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Houten then
1105: LD_EXP 28
1109: NOT
1110: IFFALSE 1125
// Houten := CreateCharacter ( 09_Houten ) ;
1112: LD_ADDR_EXP 28
1116: PUSH
1117: LD_STRING 09_Houten
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 30
1129: PUSH
1130: LD_STRING Cornell
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 46960 0 3
1148: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1149: LD_ADDR_EXP 31
1153: PUSH
1154: LD_STRING Gary
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_EXP 4
1167: PPUSH
1168: CALL 46960 0 3
1172: ST_TO_ADDR
// if not Gary then
1173: LD_EXP 31
1177: NOT
1178: IFFALSE 1193
// Gary := CreateCharacter ( 10_Gary ) ;
1180: LD_ADDR_EXP 31
1184: PUSH
1185: LD_STRING 10_Gary
1187: PPUSH
1188: CALL_OW 34
1192: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1193: LD_ADDR_EXP 32
1197: PUSH
1198: LD_STRING Frank
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_EXP 4
1211: PPUSH
1212: CALL 46960 0 3
1216: ST_TO_ADDR
// if not Frank then
1217: LD_EXP 32
1221: NOT
1222: IFFALSE 1237
// Frank := CreateCharacter ( 08_Frank ) ;
1224: LD_ADDR_EXP 32
1228: PUSH
1229: LD_STRING 08_Frank
1231: PPUSH
1232: CALL_OW 34
1236: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1237: LD_ADDR_EXP 33
1241: PUSH
1242: LD_STRING Kikuchi
1244: PPUSH
1245: LD_EXP 1
1249: NOT
1250: PPUSH
1251: LD_EXP 4
1255: PPUSH
1256: CALL 46960 0 3
1260: ST_TO_ADDR
// if not Kikuchi then
1261: LD_EXP 33
1265: NOT
1266: IFFALSE 1281
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1268: LD_ADDR_EXP 33
1272: PUSH
1273: LD_STRING 08_Kikuchi
1275: PPUSH
1276: CALL_OW 34
1280: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1281: LD_ADDR_VAR 0 5
1285: PUSH
1286: LD_EXP 21
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 23
1300: PUSH
1301: LD_EXP 24
1305: PUSH
1306: LD_EXP 25
1310: PUSH
1311: LD_EXP 26
1315: PUSH
1316: LD_EXP 27
1320: PUSH
1321: LD_EXP 28
1325: PUSH
1326: LD_EXP 30
1330: PUSH
1331: LD_EXP 31
1335: PUSH
1336: LD_EXP 32
1340: PUSH
1341: LD_EXP 33
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// tmp := tmp diff 0 ;
1360: LD_ADDR_VAR 0 5
1364: PUSH
1365: LD_VAR 0 5
1369: PUSH
1370: LD_INT 0
1372: DIFF
1373: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1374: LD_ADDR_VAR 0 5
1378: PUSH
1379: LD_VAR 0 5
1383: PUSH
1384: LD_STRING 10_lock
1386: PPUSH
1387: CALL_OW 31
1391: UNION
1392: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1393: LD_ADDR_VAR 0 5
1397: PUSH
1398: LD_VAR 0 5
1402: PUSH
1403: LD_STRING 10c_lock
1405: PPUSH
1406: CALL_OW 31
1410: UNION
1411: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1412: LD_STRING 10_lock
1414: PPUSH
1415: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1419: LD_STRING 10c_lock
1421: PPUSH
1422: CALL_OW 40
// for i in tmp do
1426: LD_ADDR_VAR 0 2
1430: PUSH
1431: LD_VAR 0 5
1435: PUSH
1436: FOR_IN
1437: IFFALSE 1475
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1439: LD_VAR 0 2
1443: PPUSH
1444: CALL_OW 257
1448: PUSH
1449: LD_INT 8
1451: PUSH
1452: LD_INT 2
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: IN
1459: IFFALSE 1473
// SetClass ( i , class_soldier ) ;
1461: LD_VAR 0 2
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: CALL_OW 336
1473: GO 1436
1475: POP
1476: POP
// if tmp < 12 then
1477: LD_VAR 0 5
1481: PUSH
1482: LD_INT 12
1484: LESS
1485: IFFALSE 1579
// begin k := 16 - tmp ;
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_INT 16
1494: PUSH
1495: LD_VAR 0 5
1499: MINUS
1500: ST_TO_ADDR
// for i = 1 to k do
1501: LD_ADDR_VAR 0 2
1505: PUSH
1506: DOUBLE
1507: LD_INT 1
1509: DEC
1510: ST_TO_ADDR
1511: LD_VAR 0 3
1515: PUSH
1516: FOR_TO
1517: IFFALSE 1577
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1519: LD_INT 0
1521: PPUSH
1522: LD_INT 1
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 3
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 1
1542: PPUSH
1543: LD_INT 4
1545: PPUSH
1546: CALL_OW 12
1550: ARRAY
1551: PPUSH
1552: LD_INT 6
1554: PPUSH
1555: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1559: LD_ADDR_VAR 0 5
1563: PUSH
1564: LD_VAR 0 5
1568: PUSH
1569: CALL_OW 44
1573: ADD
1574: ST_TO_ADDR
// end ;
1575: GO 1516
1577: POP
1578: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1579: LD_ADDR_EXP 19
1583: PUSH
1584: LD_STRING 1
1586: PPUSH
1587: LD_INT 12
1589: PPUSH
1590: LD_INT 12
1592: PPUSH
1593: LD_INT -5
1595: PUSH
1596: LD_EXP 20
1600: PUSH
1601: LD_INT -2
1603: PUSH
1604: LD_INT -3
1606: PUSH
1607: LD_INT -5
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: PUSH
1617: LD_VAR 0 5
1621: ADD
1622: PUSH
1623: LD_INT -6
1625: PUSH
1626: LD_INT -4
1628: PUSH
1629: LD_EXP 29
1633: PUSH
1634: EMPTY
1635: LIST
1636: LIST
1637: LIST
1638: ADD
1639: PPUSH
1640: LD_INT 1
1642: PUSH
1643: LD_INT 4
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 0
1655: PUSH
1656: LD_INT 5
1658: PUSH
1659: EMPTY
1660: LIST
1661: LIST
1662: LIST
1663: PUSH
1664: LD_INT 4
1666: PUSH
1667: LD_INT 0
1669: PUSH
1670: LD_INT 3
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 5
1680: PUSH
1681: LD_INT 0
1683: PUSH
1684: LD_INT 2
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: PPUSH
1698: CALL_OW 42
1702: ST_TO_ADDR
// others := tmp diff selected ;
1703: LD_ADDR_VAR 0 8
1707: PUSH
1708: LD_VAR 0 5
1712: PUSH
1713: LD_EXP 19
1717: DIFF
1718: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1719: LD_ADDR_VAR 0 8
1723: PUSH
1724: LD_VAR 0 8
1728: PUSH
1729: LD_EXP 21
1733: PUSH
1734: LD_EXP 22
1738: PUSH
1739: LD_EXP 23
1743: PUSH
1744: LD_EXP 24
1748: PUSH
1749: LD_EXP 25
1753: PUSH
1754: LD_EXP 26
1758: PUSH
1759: LD_EXP 27
1763: PUSH
1764: LD_EXP 28
1768: PUSH
1769: LD_EXP 30
1773: PUSH
1774: LD_EXP 31
1778: PUSH
1779: LD_EXP 32
1783: PUSH
1784: LD_EXP 33
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: DIFF
1803: ST_TO_ADDR
// if others then
1804: LD_VAR 0 8
1808: IFFALSE 1822
// SaveCharacters ( others , 11_others ) ;
1810: LD_VAR 0 8
1814: PPUSH
1815: LD_STRING 11_others
1817: PPUSH
1818: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1822: LD_ADDR_VAR 0 6
1826: PUSH
1827: LD_INT 3
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 4
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 5
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: PUSH
1863: LD_INT 4
1865: PUSH
1866: LD_INT 1
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 5
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: PUSH
1881: LD_INT 2
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 7
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: PUSH
1899: LD_INT 3
1901: PUSH
1902: LD_INT 2
1904: PUSH
1905: LD_INT 1
1907: PUSH
1908: LD_INT 7
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: ST_TO_ADDR
// for i in JMM ^ selected do
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_EXP 20
1933: PUSH
1934: LD_EXP 19
1938: ADD
1939: PUSH
1940: FOR_IN
1941: IFFALSE 2130
// begin if GetClass ( i ) = 3 then
1943: LD_VAR 0 2
1947: PPUSH
1948: CALL_OW 257
1952: PUSH
1953: LD_INT 3
1955: EQUAL
1956: IFFALSE 2113
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1958: LD_ADDR_OWVAR 37
1962: PUSH
1963: LD_VAR 0 6
1967: PUSH
1968: LD_INT 1
1970: ARRAY
1971: PUSH
1972: LD_INT 1
1974: ARRAY
1975: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1976: LD_ADDR_OWVAR 39
1980: PUSH
1981: LD_VAR 0 6
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PUSH
1990: LD_INT 2
1992: ARRAY
1993: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1994: LD_ADDR_OWVAR 38
1998: PUSH
1999: LD_VAR 0 6
2003: PUSH
2004: LD_INT 1
2006: ARRAY
2007: PUSH
2008: LD_INT 3
2010: ARRAY
2011: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2012: LD_ADDR_OWVAR 40
2016: PUSH
2017: LD_VAR 0 6
2021: PUSH
2022: LD_INT 1
2024: ARRAY
2025: PUSH
2026: LD_INT 4
2028: ARRAY
2029: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2030: LD_ADDR_VAR 0 6
2034: PUSH
2035: LD_VAR 0 6
2039: PPUSH
2040: LD_INT 1
2042: PPUSH
2043: CALL_OW 3
2047: ST_TO_ADDR
// veh := CreateVehicle ;
2048: LD_ADDR_VAR 0 7
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2058: LD_VAR 0 7
2062: PPUSH
2063: LD_INT 8
2065: PPUSH
2066: LD_INT 0
2068: PPUSH
2069: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2073: LD_VAR 0 2
2077: PPUSH
2078: LD_VAR 0 7
2082: PPUSH
2083: CALL_OW 52
// if i = JMM then
2087: LD_VAR 0 2
2091: PUSH
2092: LD_EXP 20
2096: EQUAL
2097: IFFALSE 2111
// SetMark ( veh , 1 ) ;
2099: LD_VAR 0 7
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: CALL_OW 242
// end else
2111: GO 2128
// PlaceUnitArea ( i , am_hum_start , false ) ;
2113: LD_VAR 0 2
2117: PPUSH
2118: LD_INT 9
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// end ;
2128: GO 1940
2130: POP
2131: POP
// vc_chassis := us_medium_tracked ;
2132: LD_ADDR_OWVAR 37
2136: PUSH
2137: LD_INT 3
2139: ST_TO_ADDR
// vc_engine := engine_solar ;
2140: LD_ADDR_OWVAR 39
2144: PUSH
2145: LD_INT 2
2147: ST_TO_ADDR
// vc_control := control_computer ;
2148: LD_ADDR_OWVAR 38
2152: PUSH
2153: LD_INT 3
2155: ST_TO_ADDR
// vc_weapon := us_radar ;
2156: LD_ADDR_OWVAR 40
2160: PUSH
2161: LD_INT 11
2163: ST_TO_ADDR
// veh := CreateVehicle ;
2164: LD_ADDR_VAR 0 7
2168: PUSH
2169: CALL_OW 45
2173: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2174: LD_VAR 0 7
2178: PPUSH
2179: LD_INT 87
2181: PPUSH
2182: LD_INT 142
2184: PPUSH
2185: LD_INT 0
2187: PPUSH
2188: CALL_OW 48
// end ; end_of_file
2192: LD_VAR 0 1
2196: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
2201: PPUSH
2202: PPUSH
2203: PPUSH
2204: PPUSH
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_INT 5
2212: PUSH
2213: LD_INT 6
2215: PUSH
2216: LD_INT 7
2218: PUSH
2219: EMPTY
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_OWVAR 67
2228: ARRAY
2229: ST_TO_ADDR
// uc_side := 2 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 2
2237: ST_TO_ADDR
// uc_nation := 2 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 2
2245: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2246: LD_ADDR_OWVAR 37
2250: PUSH
2251: LD_INT 14
2253: ST_TO_ADDR
// vc_engine := engine_siberite ;
2254: LD_ADDR_OWVAR 39
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_control := control_manual ;
2262: LD_ADDR_OWVAR 38
2266: PUSH
2267: LD_INT 1
2269: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2270: LD_ADDR_OWVAR 40
2274: PUSH
2275: LD_INT 31
2277: ST_TO_ADDR
// for i = 1 to 3 do
2278: LD_ADDR_VAR 0 2
2282: PUSH
2283: DOUBLE
2284: LD_INT 1
2286: DEC
2287: ST_TO_ADDR
2288: LD_INT 3
2290: PUSH
2291: FOR_TO
2292: IFFALSE 2376
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2294: LD_INT 0
2296: PPUSH
2297: LD_INT 3
2299: PPUSH
2300: LD_VAR 0 5
2304: PPUSH
2305: CALL_OW 380
// un := CreateVehicle ;
2309: LD_ADDR_VAR 0 4
2313: PUSH
2314: CALL_OW 45
2318: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2319: LD_VAR 0 4
2323: PPUSH
2324: LD_INT 0
2326: PPUSH
2327: LD_INT 5
2329: PPUSH
2330: CALL_OW 12
2334: PPUSH
2335: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 156
2346: PPUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 6
2352: PPUSH
2353: LD_INT 0
2355: PPUSH
2356: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2360: CALL_OW 44
2364: PPUSH
2365: LD_VAR 0 4
2369: PPUSH
2370: CALL_OW 52
// end ;
2374: GO 2291
2376: POP
2377: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2378: LD_ADDR_EXP 36
2382: PUSH
2383: LD_INT 94
2385: PPUSH
2386: LD_INT 28
2388: PPUSH
2389: LD_STRING dammam
2391: PPUSH
2392: LD_VAR 0 5
2396: PPUSH
2397: LD_INT 10000
2399: PUSH
2400: LD_INT 1000
2402: PUSH
2403: LD_INT 300
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: LIST
2410: PPUSH
2411: LD_INT 1
2413: NEG
2414: PUSH
2415: LD_INT 5
2417: PUSH
2418: LD_INT 1
2420: NEG
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: LIST
2430: PPUSH
2431: CALL 57395 0 6
2435: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , 4 , 2 , 0 ] ) ;
2436: LD_ADDR_EXP 36
2440: PUSH
2441: LD_EXP 36
2445: PUSH
2446: LD_INT 122
2448: PPUSH
2449: LD_INT 25
2451: PPUSH
2452: LD_STRING 
2454: PPUSH
2455: LD_VAR 0 5
2459: PPUSH
2460: LD_INT 500
2462: PUSH
2463: LD_INT 60
2465: PUSH
2466: LD_INT 0
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: PPUSH
2474: LD_INT 1
2476: NEG
2477: PUSH
2478: LD_INT 4
2480: PUSH
2481: LD_INT 2
2483: PUSH
2484: LD_INT 0
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: PPUSH
2493: CALL 57395 0 6
2497: UNION
2498: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2499: LD_ADDR_EXP 34
2503: PUSH
2504: LD_INT 45
2506: PPUSH
2507: LD_INT 24
2509: PPUSH
2510: LD_STRING jeddah
2512: PPUSH
2513: LD_VAR 0 5
2517: PPUSH
2518: LD_INT 700
2520: PUSH
2521: LD_INT 300
2523: PUSH
2524: LD_INT 10
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: LIST
2531: PPUSH
2532: LD_INT 1
2534: NEG
2535: PUSH
2536: LD_INT 5
2538: PUSH
2539: LD_INT 3
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: PPUSH
2551: CALL 57395 0 6
2555: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2556: LD_ADDR_EXP 35
2560: PUSH
2561: LD_INT 7
2563: PPUSH
2564: LD_INT 27
2566: PPUSH
2567: LD_STRING riyadh
2569: PPUSH
2570: LD_VAR 0 5
2574: PPUSH
2575: LD_INT 500
2577: PUSH
2578: LD_INT 60
2580: PUSH
2581: LD_INT 0
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: PPUSH
2589: LD_INT 4
2591: PUSH
2592: LD_INT 2
2594: PUSH
2595: LD_INT 3
2597: PUSH
2598: LD_INT 1
2600: PUSH
2601: EMPTY
2602: LIST
2603: LIST
2604: LIST
2605: LIST
2606: PPUSH
2607: CALL 57395 0 6
2611: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2612: LD_ADDR_EXP 38
2616: PUSH
2617: LD_INT 204
2619: PPUSH
2620: LD_INT 26
2622: PPUSH
2623: LD_STRING 
2625: PPUSH
2626: LD_VAR 0 5
2630: PPUSH
2631: LD_INT 500
2633: PUSH
2634: LD_INT 50
2636: PUSH
2637: LD_INT 0
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: PPUSH
2645: LD_INT 1
2647: NEG
2648: PUSH
2649: LD_INT 3
2651: PUSH
2652: LD_INT 3
2654: PUSH
2655: LD_INT 2
2657: PUSH
2658: EMPTY
2659: LIST
2660: LIST
2661: LIST
2662: LIST
2663: PPUSH
2664: CALL 57395 0 6
2668: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2669: LD_ADDR_EXP 49
2673: PUSH
2674: LD_EXP 36
2678: PUSH
2679: LD_EXP 34
2683: PUSH
2684: LD_EXP 38
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: LIST
2693: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2694: LD_ADDR_VAR 0 2
2698: PUSH
2699: LD_INT 22
2701: PUSH
2702: LD_INT 2
2704: PUSH
2705: EMPTY
2706: LIST
2707: LIST
2708: PUSH
2709: LD_INT 30
2711: PUSH
2712: LD_INT 31
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: LD_INT 58
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 69
2734: PUSH
2735: FOR_IN
2736: IFFALSE 2861
// begin if GetBase ( i ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: CALL_OW 274
2747: IFFALSE 2751
// continue ;
2749: GO 2735
// d := GetDir ( i ) ;
2751: LD_ADDR_VAR 0 3
2755: PUSH
2756: LD_VAR 0 2
2760: PPUSH
2761: CALL_OW 254
2765: ST_TO_ADDR
// if d < 3 then
2766: LD_VAR 0 3
2770: PUSH
2771: LD_INT 3
2773: LESS
2774: IFFALSE 2792
// d := d + 3 else
2776: LD_ADDR_VAR 0 3
2780: PUSH
2781: LD_VAR 0 3
2785: PUSH
2786: LD_INT 3
2788: PLUS
2789: ST_TO_ADDR
2790: GO 2806
// d := d - 3 ;
2792: LD_ADDR_VAR 0 3
2796: PUSH
2797: LD_VAR 0 3
2801: PUSH
2802: LD_INT 3
2804: MINUS
2805: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2806: LD_INT 0
2808: PPUSH
2809: LD_INT 8
2811: PPUSH
2812: LD_VAR 0 5
2816: PPUSH
2817: CALL_OW 380
// un := CreateHuman ;
2821: LD_ADDR_VAR 0 4
2825: PUSH
2826: CALL_OW 44
2830: ST_TO_ADDR
// SetDir ( un , d ) ;
2831: LD_VAR 0 4
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2845: LD_VAR 0 4
2849: PPUSH
2850: LD_VAR 0 2
2854: PPUSH
2855: CALL_OW 52
// end ;
2859: GO 2735
2861: POP
2862: POP
// if Difficulty > 1 then
2863: LD_OWVAR 67
2867: PUSH
2868: LD_INT 1
2870: GREATER
2871: IFFALSE 3242
// begin ar_kamikadze := [ ] ;
2873: LD_ADDR_EXP 41
2877: PUSH
2878: EMPTY
2879: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateHuman ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 44
2904: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 3
2912: PPUSH
2913: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2917: LD_VAR 0 4
2921: PPUSH
2922: LD_INT 23
2924: PPUSH
2925: LD_INT 44
2927: PPUSH
2928: LD_INT 0
2930: PPUSH
2931: CALL_OW 48
// ComCrawl ( un ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: CALL_OW 137
// un := CreateHuman ;
2944: LD_ADDR_VAR 0 4
2948: PUSH
2949: CALL_OW 44
2953: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2954: LD_VAR 0 4
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2966: LD_VAR 0 4
2970: PPUSH
2971: LD_INT 30
2973: PPUSH
2974: LD_INT 39
2976: PPUSH
2977: LD_INT 0
2979: PPUSH
2980: CALL_OW 48
// ComCrawl ( un ) ;
2984: LD_VAR 0 4
2988: PPUSH
2989: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
2993: LD_INT 0
2995: PPUSH
2996: LD_INT 17
2998: PPUSH
2999: LD_VAR 0 5
3003: PPUSH
3004: CALL_OW 380
// un := CreateHuman ;
3008: LD_ADDR_VAR 0 4
3012: PUSH
3013: CALL_OW 44
3017: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3018: LD_VAR 0 4
3022: PPUSH
3023: LD_INT 3
3025: PPUSH
3026: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3030: LD_VAR 0 4
3034: PPUSH
3035: LD_INT 45
3037: PPUSH
3038: LD_INT 86
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComHold ( un ) ;
3048: LD_VAR 0 4
3052: PPUSH
3053: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3057: LD_ADDR_EXP 41
3061: PUSH
3062: LD_EXP 41
3066: PPUSH
3067: LD_EXP 41
3071: PUSH
3072: LD_INT 1
3074: PLUS
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: CALL_OW 1
3085: ST_TO_ADDR
// un := CreateHuman ;
3086: LD_ADDR_VAR 0 4
3090: PUSH
3091: CALL_OW 44
3095: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3096: LD_VAR 0 4
3100: PPUSH
3101: LD_INT 3
3103: PPUSH
3104: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3108: LD_VAR 0 4
3112: PPUSH
3113: LD_INT 60
3115: PPUSH
3116: LD_INT 85
3118: PPUSH
3119: LD_INT 0
3121: PPUSH
3122: CALL_OW 48
// ComHold ( un ) ;
3126: LD_VAR 0 4
3130: PPUSH
3131: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3135: LD_ADDR_EXP 41
3139: PUSH
3140: LD_EXP 41
3144: PPUSH
3145: LD_EXP 41
3149: PUSH
3150: LD_INT 1
3152: PLUS
3153: PPUSH
3154: LD_VAR 0 4
3158: PPUSH
3159: CALL_OW 1
3163: ST_TO_ADDR
// un := CreateHuman ;
3164: LD_ADDR_VAR 0 4
3168: PUSH
3169: CALL_OW 44
3173: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3174: LD_VAR 0 4
3178: PPUSH
3179: LD_INT 3
3181: PPUSH
3182: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3186: LD_VAR 0 4
3190: PPUSH
3191: LD_INT 222
3193: PPUSH
3194: LD_INT 166
3196: PPUSH
3197: LD_INT 0
3199: PPUSH
3200: CALL_OW 48
// ComHold ( un ) ;
3204: LD_VAR 0 4
3208: PPUSH
3209: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3213: LD_ADDR_EXP 41
3217: PUSH
3218: LD_EXP 41
3222: PPUSH
3223: LD_EXP 41
3227: PUSH
3228: LD_INT 1
3230: PLUS
3231: PPUSH
3232: LD_VAR 0 4
3236: PPUSH
3237: CALL_OW 1
3241: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3242: LD_ADDR_EXP 39
3246: PUSH
3247: EMPTY
3248: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 1
3254: PPUSH
3255: LD_VAR 0 5
3259: PPUSH
3260: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3264: LD_ADDR_OWVAR 26
3268: PUSH
3269: LD_STRING Pavel Grigorovic
3271: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3272: LD_ADDR_OWVAR 33
3276: PUSH
3277: LD_STRING SecondCharsGal
3279: ST_TO_ADDR
// hc_face_number := 4 ;
3280: LD_ADDR_OWVAR 34
3284: PUSH
3285: LD_INT 4
3287: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3288: LD_ADDR_EXP 39
3292: PUSH
3293: LD_EXP 39
3297: PPUSH
3298: LD_INT 1
3300: PPUSH
3301: CALL_OW 44
3305: PPUSH
3306: CALL_OW 1
3310: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3311: LD_INT 2
3313: PPUSH
3314: LD_INT 4
3316: PPUSH
3317: LD_VAR 0 5
3321: PPUSH
3322: CALL_OW 380
// hc_name := Lucy Sebel ;
3326: LD_ADDR_OWVAR 26
3330: PUSH
3331: LD_STRING Lucy Sebel
3333: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3334: LD_ADDR_OWVAR 33
3338: PUSH
3339: LD_STRING SecondCharsGal
3341: ST_TO_ADDR
// hc_face_number := 15 ;
3342: LD_ADDR_OWVAR 34
3346: PUSH
3347: LD_INT 15
3349: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3350: LD_ADDR_EXP 39
3354: PUSH
3355: LD_EXP 39
3359: PPUSH
3360: LD_INT 2
3362: PPUSH
3363: CALL_OW 44
3367: PPUSH
3368: CALL_OW 1
3372: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3373: LD_INT 2
3375: PPUSH
3376: LD_INT 4
3378: PPUSH
3379: LD_VAR 0 5
3383: PPUSH
3384: CALL_OW 380
// hc_gallery :=  ;
3388: LD_ADDR_OWVAR 33
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// hc_name :=  ;
3396: LD_ADDR_OWVAR 26
3400: PUSH
3401: LD_STRING 
3403: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3404: LD_ADDR_EXP 39
3408: PUSH
3409: LD_EXP 39
3413: PPUSH
3414: LD_INT 3
3416: PPUSH
3417: CALL_OW 44
3421: PPUSH
3422: CALL_OW 1
3426: ST_TO_ADDR
// hc_sex := sex_male ;
3427: LD_ADDR_OWVAR 27
3431: PUSH
3432: LD_INT 1
3434: ST_TO_ADDR
// hc_class = 11 ;
3435: LD_ADDR_OWVAR 28
3439: PUSH
3440: LD_INT 11
3442: ST_TO_ADDR
// hc_gallery = sandar ;
3443: LD_ADDR_OWVAR 33
3447: PUSH
3448: LD_STRING sandar
3450: ST_TO_ADDR
// hc_face_number = 33 ;
3451: LD_ADDR_OWVAR 34
3455: PUSH
3456: LD_INT 33
3458: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3459: LD_ADDR_OWVAR 26
3463: PUSH
3464: LD_STRING Thabit Muhair Saliba
3466: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3467: LD_ADDR_OWVAR 31
3471: PUSH
3472: LD_INT 0
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: LD_INT 0
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: ST_TO_ADDR
// Saliba = CreateHuman ;
3490: LD_ADDR_EXP 43
3494: PUSH
3495: CALL_OW 44
3499: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3500: LD_EXP 43
3504: PPUSH
3505: LD_INT 7
3507: PPUSH
3508: CALL_OW 52
// if gensher_active then
3512: LD_EXP 18
3516: IFFALSE 3543
// begin Gensher = NewCharacter ( Dietrich ) ;
3518: LD_ADDR_EXP 44
3522: PUSH
3523: LD_STRING Dietrich
3525: PPUSH
3526: CALL_OW 25
3530: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3531: LD_EXP 44
3535: PPUSH
3536: LD_INT 94
3538: PPUSH
3539: CALL_OW 52
// end ; InitHc ;
3543: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3547: LD_ADDR_EXP 40
3551: PUSH
3552: EMPTY
3553: ST_TO_ADDR
// for i = 1 to 5 do
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: DOUBLE
3560: LD_INT 1
3562: DEC
3563: ST_TO_ADDR
3564: LD_INT 5
3566: PUSH
3567: FOR_TO
3568: IFFALSE 3740
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3570: LD_INT 13
3572: PUSH
3573: LD_INT 14
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: PUSH
3580: LD_INT 1
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 12
3590: ARRAY
3591: PPUSH
3592: LD_INT 1
3594: PUSH
3595: LD_INT 2
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 2
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: PPUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 25
3619: PUSH
3620: LD_INT 27
3622: PUSH
3623: LD_INT 26
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: PUSH
3631: LD_INT 1
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: CALL_OW 12
3641: ARRAY
3642: PPUSH
3643: LD_INT 60
3645: PPUSH
3646: LD_INT 100
3648: PPUSH
3649: CALL_OW 12
3653: PPUSH
3654: CALL 53986 0 5
// un := CreateVehicle ;
3658: LD_ADDR_VAR 0 4
3662: PUSH
3663: CALL_OW 45
3667: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3668: LD_ADDR_EXP 40
3672: PUSH
3673: LD_EXP 40
3677: PPUSH
3678: LD_EXP 40
3682: PUSH
3683: LD_INT 1
3685: PLUS
3686: PPUSH
3687: LD_VAR 0 4
3691: PPUSH
3692: CALL_OW 1
3696: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3697: LD_VAR 0 4
3701: PPUSH
3702: LD_INT 0
3704: PPUSH
3705: LD_INT 5
3707: PPUSH
3708: CALL_OW 12
3712: PPUSH
3713: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3717: LD_VAR 0 4
3721: PPUSH
3722: LD_INT 124
3724: PPUSH
3725: LD_INT 141
3727: PPUSH
3728: LD_INT 8
3730: PPUSH
3731: LD_INT 0
3733: PPUSH
3734: CALL_OW 50
// end ;
3738: GO 3567
3740: POP
3741: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3742: LD_ADDR_EXP 42
3746: PUSH
3747: EMPTY
3748: PUSH
3749: EMPTY
3750: PUSH
3751: EMPTY
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: LIST
3757: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3758: LD_ADDR_VAR 0 3
3762: PUSH
3763: DOUBLE
3764: LD_INT 1
3766: DEC
3767: ST_TO_ADDR
3768: LD_INT 3
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: LD_INT 4
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: LIST
3781: PUSH
3782: LD_OWVAR 67
3786: ARRAY
3787: PUSH
3788: FOR_TO
3789: IFFALSE 4003
// for i = 1 to 3 do
3791: LD_ADDR_VAR 0 2
3795: PUSH
3796: DOUBLE
3797: LD_INT 1
3799: DEC
3800: ST_TO_ADDR
3801: LD_INT 3
3803: PUSH
3804: FOR_TO
3805: IFFALSE 3999
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3807: LD_INT 14
3809: PPUSH
3810: LD_INT 3
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: LD_INT 1
3822: PPUSH
3823: LD_INT 2
3825: PPUSH
3826: CALL_OW 12
3830: ARRAY
3831: PPUSH
3832: LD_INT 1
3834: PUSH
3835: LD_INT 5
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 2
3847: PPUSH
3848: CALL_OW 12
3852: ARRAY
3853: PPUSH
3854: LD_INT 25
3856: PUSH
3857: LD_INT 27
3859: PUSH
3860: LD_INT 26
3862: PUSH
3863: LD_INT 28
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 1
3874: PPUSH
3875: LD_INT 4
3877: PPUSH
3878: CALL_OW 12
3882: ARRAY
3883: PPUSH
3884: LD_INT 100
3886: PPUSH
3887: CALL 53986 0 5
// un := CreateVehicle ;
3891: LD_ADDR_VAR 0 4
3895: PUSH
3896: CALL_OW 45
3900: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3901: LD_ADDR_EXP 42
3905: PUSH
3906: LD_EXP 42
3910: PPUSH
3911: LD_VAR 0 2
3915: PUSH
3916: LD_EXP 42
3920: PUSH
3921: LD_VAR 0 2
3925: ARRAY
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: PPUSH
3935: LD_VAR 0 4
3939: PPUSH
3940: CALL 54108 0 3
3944: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3945: LD_VAR 0 4
3949: PPUSH
3950: LD_INT 0
3952: PPUSH
3953: LD_INT 5
3955: PPUSH
3956: CALL_OW 12
3960: PPUSH
3961: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3965: LD_VAR 0 4
3969: PPUSH
3970: LD_INT 20
3972: PUSH
3973: LD_INT 21
3975: PUSH
3976: LD_INT 22
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: LIST
3983: PUSH
3984: LD_VAR 0 2
3988: ARRAY
3989: PPUSH
3990: LD_INT 0
3992: PPUSH
3993: CALL_OW 49
// end ;
3997: GO 3804
3999: POP
4000: POP
4001: GO 3788
4003: POP
4004: POP
// InitHc ;
4005: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4009: LD_INT 4
4011: PPUSH
4012: LD_INT 5
4014: PPUSH
4015: LD_INT 10
4017: PPUSH
4018: LD_INT 5
4020: PPUSH
4021: LD_INT 0
4023: PPUSH
4024: CALL_OW 58
// end ;
4028: LD_VAR 0 1
4032: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4033: LD_EXP 41
4037: IFFALSE 4111
4039: GO 4041
4041: DISABLE
4042: LD_INT 0
4044: PPUSH
// begin enable ;
4045: ENABLE
// for i in ar_kamikadze do
4046: LD_ADDR_VAR 0 1
4050: PUSH
4051: LD_EXP 41
4055: PUSH
4056: FOR_IN
4057: IFFALSE 4109
// if See ( 1 , i ) then
4059: LD_INT 1
4061: PPUSH
4062: LD_VAR 0 1
4066: PPUSH
4067: CALL_OW 292
4071: IFFALSE 4107
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_INT 81
4080: PUSH
4081: LD_INT 2
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: PPUSH
4088: CALL_OW 69
4092: PPUSH
4093: LD_VAR 0 1
4097: PPUSH
4098: CALL_OW 74
4102: PPUSH
4103: CALL_OW 115
4107: GO 4056
4109: POP
4110: POP
// end ;
4111: PPOPN 1
4113: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4114: LD_EXP 13
4118: IFFALSE 4435
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
4126: PPUSH
4127: PPUSH
4128: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4129: LD_INT 35
4131: PPUSH
4132: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4136: LD_INT 1
4138: PPUSH
4139: CALL 40964 0 1
4143: PUSH
4144: LD_INT 0
4146: EQUAL
4147: IFFALSE 4129
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4149: LD_INT 1
4151: PPUSH
4152: LD_INT 14
4154: PUSH
4155: LD_INT 3
4157: PUSH
4158: LD_INT 2
4160: PUSH
4161: LD_INT 32
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: PUSH
4170: EMPTY
4171: LIST
4172: PPUSH
4173: CALL 40568 0 2
// repeat wait ( 0 0$1 ) ;
4177: LD_INT 35
4179: PPUSH
4180: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4184: LD_EXP 68
4188: PUSH
4189: LD_INT 1
4191: ARRAY
4192: PPUSH
4193: LD_INT 33
4195: PUSH
4196: LD_INT 2
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PUSH
4203: LD_INT 34
4205: PUSH
4206: LD_INT 32
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PPUSH
4217: CALL_OW 72
4221: IFFALSE 4177
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: LD_EXP 68
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PPUSH
4237: LD_INT 33
4239: PUSH
4240: LD_INT 2
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: LD_INT 34
4249: PUSH
4250: LD_INT 32
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: PPUSH
4261: CALL_OW 72
4265: PUSH
4266: LD_INT 1
4268: ARRAY
4269: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4270: LD_ADDR_VAR 0 4
4274: PUSH
4275: LD_INT 5
4277: PPUSH
4278: CALL_OW 469
4282: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4283: LD_INT 35
4285: PPUSH
4286: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4290: LD_ADDR_VAR 0 4
4294: PUSH
4295: LD_INT 5
4297: PPUSH
4298: CALL_OW 469
4302: ST_TO_ADDR
// tmp := 100 ;
4303: LD_ADDR_VAR 0 3
4307: PUSH
4308: LD_INT 100
4310: ST_TO_ADDR
// if pos then
4311: LD_VAR 0 4
4315: IFFALSE 4355
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4317: LD_ADDR_VAR 0 3
4321: PUSH
4322: LD_INT 2
4324: PPUSH
4325: LD_VAR 0 4
4329: PUSH
4330: LD_INT 1
4332: ARRAY
4333: PPUSH
4334: LD_VAR 0 4
4338: PUSH
4339: LD_INT 2
4341: ARRAY
4342: PPUSH
4343: LD_INT 20
4345: PPUSH
4346: CALL 55004 0 4
4350: PUSH
4351: LD_INT 4
4353: ARRAY
4354: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4355: LD_VAR 0 4
4359: PUSH
4360: LD_EXP 14
4364: NOT
4365: AND
4366: PUSH
4367: LD_VAR 0 3
4371: PUSH
4372: LD_INT 10
4374: LESS
4375: AND
4376: IFFALSE 4283
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4378: LD_VAR 0 2
4382: PPUSH
4383: LD_VAR 0 4
4387: PUSH
4388: LD_INT 1
4390: ARRAY
4391: PPUSH
4392: LD_VAR 0 4
4396: PUSH
4397: LD_INT 2
4399: ARRAY
4400: PPUSH
4401: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4405: LD_VAR 0 2
4409: PPUSH
4410: LD_INT 198
4412: PPUSH
4413: LD_INT 113
4415: PPUSH
4416: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4420: LD_VAR 0 2
4424: PPUSH
4425: LD_INT 124
4427: PPUSH
4428: LD_INT 7
4430: PPUSH
4431: CALL_OW 171
// end ;
4435: PPOPN 4
4437: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4438: LD_EXP 6
4442: IFFALSE 7116
4444: GO 4446
4446: DISABLE
4447: LD_INT 0
4449: PPUSH
4450: PPUSH
4451: PPUSH
4452: PPUSH
4453: PPUSH
4454: PPUSH
4455: PPUSH
4456: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4457: LD_ADDR_VAR 0 4
4461: PUSH
4462: LD_INT 5
4464: PUSH
4465: LD_INT 6
4467: PUSH
4468: LD_INT 7
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: LIST
4475: PUSH
4476: LD_OWVAR 67
4480: ARRAY
4481: ST_TO_ADDR
// coords := [ ] ;
4482: LD_ADDR_VAR 0 5
4486: PUSH
4487: EMPTY
4488: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4489: LD_ADDR_VAR 0 6
4493: PUSH
4494: LD_INT 0
4496: PUSH
4497: LD_INT 0
4499: PUSH
4500: LD_INT 0
4502: PUSH
4503: LD_INT 0
4505: PUSH
4506: LD_INT 1
4508: PUSH
4509: LD_INT 0
4511: PUSH
4512: LD_INT 0
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 1
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 14
4541: PUSH
4542: LD_INT 1
4544: PUSH
4545: LD_INT 2
4547: PUSH
4548: LD_INT 28
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 14
4559: PUSH
4560: LD_INT 1
4562: PUSH
4563: LD_INT 2
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: PUSH
4575: LD_INT 14
4577: PUSH
4578: LD_INT 1
4580: PUSH
4581: LD_INT 2
4583: PUSH
4584: LD_INT 28
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: LIST
4591: LIST
4592: PUSH
4593: LD_INT 14
4595: PUSH
4596: LD_INT 1
4598: PUSH
4599: LD_INT 2
4601: PUSH
4602: LD_INT 29
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: LIST
4615: LIST
4616: PPUSH
4617: CALL 40568 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4621: LD_INT 21000
4623: PUSH
4624: LD_INT 19950
4626: PUSH
4627: LD_INT 18900
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: PUSH
4635: LD_OWVAR 67
4639: ARRAY
4640: PPUSH
4641: CALL_OW 67
// InitHc ;
4645: CALL_OW 19
// InitUc ;
4649: CALL_OW 18
// uc_side := 2 ;
4653: LD_ADDR_OWVAR 20
4657: PUSH
4658: LD_INT 2
4660: ST_TO_ADDR
// uc_nation := 2 ;
4661: LD_ADDR_OWVAR 21
4665: PUSH
4666: LD_INT 2
4668: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4669: LD_ADDR_VAR 0 3
4673: PUSH
4674: EMPTY
4675: PUSH
4676: EMPTY
4677: PUSH
4678: EMPTY
4679: PUSH
4680: EMPTY
4681: PUSH
4682: EMPTY
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4691: LD_ADDR_VAR 0 3
4695: PUSH
4696: LD_VAR 0 3
4700: PPUSH
4701: LD_INT 1
4703: PPUSH
4704: LD_EXP 68
4708: PUSH
4709: LD_INT 1
4711: ARRAY
4712: PUSH
4713: LD_INT 34
4715: PUSH
4716: LD_INT 32
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PPUSH
4723: CALL_OW 69
4727: DIFF
4728: PPUSH
4729: CALL_OW 1
4733: ST_TO_ADDR
// for i = 1 to Difficulty do
4734: LD_ADDR_VAR 0 1
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_OWVAR 67
4748: PUSH
4749: FOR_TO
4750: IFFALSE 4888
// begin uc_side := 2 ;
4752: LD_ADDR_OWVAR 20
4756: PUSH
4757: LD_INT 2
4759: ST_TO_ADDR
// uc_nation := 2 ;
4760: LD_ADDR_OWVAR 21
4764: PUSH
4765: LD_INT 2
4767: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4768: LD_INT 13
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: LD_INT 5
4776: PPUSH
4777: LD_INT 29
4779: PPUSH
4780: LD_INT 100
4782: PPUSH
4783: CALL 53986 0 5
// un := CreateVehicle ;
4787: LD_ADDR_VAR 0 2
4791: PUSH
4792: CALL_OW 45
4796: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4797: LD_ADDR_VAR 0 3
4801: PUSH
4802: LD_VAR 0 3
4806: PPUSH
4807: LD_INT 1
4809: PUSH
4810: LD_VAR 0 3
4814: PUSH
4815: LD_INT 1
4817: ARRAY
4818: PUSH
4819: LD_INT 1
4821: PLUS
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PPUSH
4827: LD_VAR 0 2
4831: PPUSH
4832: CALL 54108 0 3
4836: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4837: LD_VAR 0 2
4841: PPUSH
4842: LD_INT 3
4844: PPUSH
4845: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4849: LD_VAR 0 2
4853: PPUSH
4854: LD_INT 16
4856: PPUSH
4857: LD_INT 0
4859: PPUSH
4860: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4864: LD_VAR 0 2
4868: PPUSH
4869: LD_INT 51
4871: PPUSH
4872: LD_INT 10
4874: PPUSH
4875: CALL_OW 111
// wait ( 0 0$2 ) ;
4879: LD_INT 70
4881: PPUSH
4882: CALL_OW 67
// end ;
4886: GO 4749
4888: POP
4889: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4890: LD_ADDR_VAR 0 5
4894: PUSH
4895: LD_INT 51
4897: PUSH
4898: LD_INT 24
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: LD_INT 75
4907: PUSH
4908: LD_INT 90
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4919: LD_INT 1
4921: PPUSH
4922: LD_VAR 0 3
4926: PUSH
4927: LD_INT 1
4929: ARRAY
4930: PPUSH
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_VAR 0 6
4940: PPUSH
4941: CALL 40801 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
4945: LD_ADDR_VAR 0 1
4949: PUSH
4950: DOUBLE
4951: LD_INT 1
4953: DEC
4954: ST_TO_ADDR
4955: LD_INT 1
4957: PUSH
4958: LD_INT 3
4960: PUSH
4961: LD_INT 3
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PUSH
4975: FOR_TO
4976: IFFALSE 5076
// begin uc_side := 2 ;
4978: LD_ADDR_OWVAR 20
4982: PUSH
4983: LD_INT 2
4985: ST_TO_ADDR
// uc_nation := 2 ;
4986: LD_ADDR_OWVAR 21
4990: PUSH
4991: LD_INT 2
4993: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
4994: LD_INT 0
4996: PPUSH
4997: LD_INT 17
4999: PPUSH
5000: LD_VAR 0 4
5004: PPUSH
5005: CALL_OW 380
// un := CreateHuman ;
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: CALL_OW 44
5018: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5019: LD_ADDR_VAR 0 3
5023: PUSH
5024: LD_VAR 0 3
5028: PPUSH
5029: LD_INT 2
5031: PUSH
5032: LD_VAR 0 3
5036: PUSH
5037: LD_INT 2
5039: ARRAY
5040: PUSH
5041: LD_INT 1
5043: PLUS
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: PPUSH
5049: LD_VAR 0 2
5053: PPUSH
5054: CALL 54108 0 3
5058: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5059: LD_VAR 0 2
5063: PPUSH
5064: LD_INT 13
5066: PPUSH
5067: LD_INT 0
5069: PPUSH
5070: CALL_OW 49
// end ;
5074: GO 4975
5076: POP
5077: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5078: LD_ADDR_VAR 0 1
5082: PUSH
5083: DOUBLE
5084: LD_INT 1
5086: DEC
5087: ST_TO_ADDR
5088: LD_INT 2
5090: PUSH
5091: LD_INT 3
5093: PUSH
5094: LD_INT 3
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: LIST
5101: PUSH
5102: LD_OWVAR 67
5106: ARRAY
5107: PUSH
5108: FOR_TO
5109: IFFALSE 5228
// begin uc_side := 2 ;
5111: LD_ADDR_OWVAR 20
5115: PUSH
5116: LD_INT 2
5118: ST_TO_ADDR
// uc_nation := 2 ;
5119: LD_ADDR_OWVAR 21
5123: PUSH
5124: LD_INT 2
5126: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5127: LD_INT 0
5129: PPUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 1
5142: PPUSH
5143: LD_INT 2
5145: PPUSH
5146: CALL_OW 12
5150: ARRAY
5151: PPUSH
5152: LD_VAR 0 4
5156: PPUSH
5157: CALL_OW 380
// un := CreateHuman ;
5161: LD_ADDR_VAR 0 2
5165: PUSH
5166: CALL_OW 44
5170: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5171: LD_ADDR_VAR 0 3
5175: PUSH
5176: LD_VAR 0 3
5180: PPUSH
5181: LD_INT 2
5183: PUSH
5184: LD_VAR 0 3
5188: PUSH
5189: LD_INT 2
5191: ARRAY
5192: PUSH
5193: LD_INT 1
5195: PLUS
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: LD_VAR 0 2
5205: PPUSH
5206: CALL 54108 0 3
5210: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5211: LD_VAR 0 2
5215: PPUSH
5216: LD_INT 13
5218: PPUSH
5219: LD_INT 0
5221: PPUSH
5222: CALL_OW 49
// end ;
5226: GO 5108
5228: POP
5229: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5230: LD_ADDR_VAR 0 5
5234: PUSH
5235: LD_INT 67
5237: PUSH
5238: LD_INT 112
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: LD_INT 85
5247: PUSH
5248: LD_INT 130
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5259: LD_INT 2
5261: PPUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 2
5269: ARRAY
5270: PPUSH
5271: LD_VAR 0 5
5275: PPUSH
5276: LD_VAR 0 6
5280: PPUSH
5281: CALL 40801 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5285: LD_ADDR_VAR 0 1
5289: PUSH
5290: DOUBLE
5291: LD_INT 1
5293: DEC
5294: ST_TO_ADDR
5295: LD_INT 1
5297: PUSH
5298: LD_INT 2
5300: PUSH
5301: LD_INT 3
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: LD_OWVAR 67
5313: ARRAY
5314: PUSH
5315: FOR_TO
5316: IFFALSE 5416
// begin uc_side := 2 ;
5318: LD_ADDR_OWVAR 20
5322: PUSH
5323: LD_INT 2
5325: ST_TO_ADDR
// uc_nation := 2 ;
5326: LD_ADDR_OWVAR 21
5330: PUSH
5331: LD_INT 2
5333: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5334: LD_INT 0
5336: PPUSH
5337: LD_INT 17
5339: PPUSH
5340: LD_VAR 0 4
5344: PPUSH
5345: CALL_OW 380
// un := CreateHuman ;
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: CALL_OW 44
5358: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5359: LD_ADDR_VAR 0 3
5363: PUSH
5364: LD_VAR 0 3
5368: PPUSH
5369: LD_INT 3
5371: PUSH
5372: LD_VAR 0 3
5376: PUSH
5377: LD_INT 3
5379: ARRAY
5380: PUSH
5381: LD_INT 1
5383: PLUS
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PPUSH
5389: LD_VAR 0 2
5393: PPUSH
5394: CALL 54108 0 3
5398: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5399: LD_VAR 0 2
5403: PPUSH
5404: LD_INT 14
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 49
// end ;
5414: GO 5315
5416: POP
5417: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5418: LD_ADDR_VAR 0 5
5422: PUSH
5423: LD_INT 148
5425: PUSH
5426: LD_INT 158
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PUSH
5433: LD_INT 148
5435: PUSH
5436: LD_INT 158
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5447: LD_INT 3
5449: PPUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 3
5457: ARRAY
5458: PPUSH
5459: LD_VAR 0 5
5463: PPUSH
5464: LD_VAR 0 6
5468: PPUSH
5469: CALL 40801 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5473: LD_ADDR_VAR 0 1
5477: PUSH
5478: DOUBLE
5479: LD_INT 1
5481: DEC
5482: ST_TO_ADDR
5483: LD_INT 2
5485: PUSH
5486: LD_INT 4
5488: PUSH
5489: LD_INT 4
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_OWVAR 67
5501: ARRAY
5502: PUSH
5503: FOR_TO
5504: IFFALSE 5728
// begin uc_side := 2 ;
5506: LD_ADDR_OWVAR 20
5510: PUSH
5511: LD_INT 2
5513: ST_TO_ADDR
// uc_nation := 2 ;
5514: LD_ADDR_OWVAR 21
5518: PUSH
5519: LD_INT 2
5521: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5522: LD_INT 14
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: LD_INT 1
5530: PUSH
5531: LD_INT 5
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 1
5540: PPUSH
5541: LD_INT 2
5543: PPUSH
5544: CALL_OW 12
5548: ARRAY
5549: PPUSH
5550: LD_INT 27
5552: PUSH
5553: LD_INT 26
5555: PUSH
5556: LD_INT 28
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 1
5566: PPUSH
5567: LD_INT 3
5569: PPUSH
5570: CALL_OW 12
5574: ARRAY
5575: PPUSH
5576: LD_INT 100
5578: PPUSH
5579: CALL 53986 0 5
// un := CreateVehicle ;
5583: LD_ADDR_VAR 0 2
5587: PUSH
5588: CALL_OW 45
5592: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5593: LD_ADDR_VAR 0 3
5597: PUSH
5598: LD_VAR 0 3
5602: PPUSH
5603: LD_INT 4
5605: PUSH
5606: LD_VAR 0 3
5610: PUSH
5611: LD_INT 4
5613: ARRAY
5614: PUSH
5615: LD_INT 1
5617: PLUS
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: LD_VAR 0 2
5627: PPUSH
5628: CALL 54108 0 3
5632: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5633: LD_VAR 0 2
5637: PPUSH
5638: LD_INT 5
5640: PPUSH
5641: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5645: LD_VAR 0 2
5649: PPUSH
5650: LD_INT 15
5652: PPUSH
5653: LD_INT 0
5655: PPUSH
5656: CALL_OW 49
// if GetControl ( un ) = control_manual then
5660: LD_VAR 0 2
5664: PPUSH
5665: CALL_OW 263
5669: PUSH
5670: LD_INT 1
5672: EQUAL
5673: IFFALSE 5704
// begin PrepareHuman ( false , 3 , skill ) ;
5675: LD_INT 0
5677: PPUSH
5678: LD_INT 3
5680: PPUSH
5681: LD_VAR 0 4
5685: PPUSH
5686: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5690: CALL_OW 44
5694: PPUSH
5695: LD_VAR 0 2
5699: PPUSH
5700: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 179
5711: PPUSH
5712: LD_INT 135
5714: PPUSH
5715: CALL_OW 111
// wait ( 0 0$2 ) ;
5719: LD_INT 70
5721: PPUSH
5722: CALL_OW 67
// end ;
5726: GO 5503
5728: POP
5729: POP
// vc_chassis := 15 ;
5730: LD_ADDR_OWVAR 37
5734: PUSH
5735: LD_INT 15
5737: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5738: LD_ADDR_VAR 0 3
5742: PUSH
5743: LD_VAR 0 3
5747: PPUSH
5748: LD_INT 4
5750: PUSH
5751: LD_VAR 0 3
5755: PUSH
5756: LD_INT 4
5758: ARRAY
5759: PUSH
5760: LD_INT 1
5762: PLUS
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PPUSH
5768: CALL_OW 45
5772: PPUSH
5773: CALL 54108 0 3
5777: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5778: LD_VAR 0 3
5782: PUSH
5783: LD_INT 4
5785: ARRAY
5786: PUSH
5787: LD_VAR 0 3
5791: PUSH
5792: LD_INT 4
5794: ARRAY
5795: ARRAY
5796: PPUSH
5797: LD_INT 15
5799: PPUSH
5800: LD_INT 0
5802: PPUSH
5803: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5807: LD_INT 0
5809: PPUSH
5810: LD_INT 11
5812: PPUSH
5813: LD_VAR 0 4
5817: PPUSH
5818: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 4
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 4
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 44
5856: PPUSH
5857: CALL 54108 0 3
5861: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5862: LD_VAR 0 3
5866: PUSH
5867: LD_INT 4
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 3
5875: PUSH
5876: LD_INT 4
5878: ARRAY
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 3
5885: PUSH
5886: LD_INT 4
5888: ARRAY
5889: PUSH
5890: LD_VAR 0 3
5894: PUSH
5895: LD_INT 4
5897: ARRAY
5898: PUSH
5899: LD_INT 1
5901: MINUS
5902: ARRAY
5903: PPUSH
5904: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5908: LD_ADDR_VAR 0 5
5912: PUSH
5913: LD_INT 148
5915: PUSH
5916: LD_INT 140
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: PUSH
5923: EMPTY
5924: LIST
5925: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5926: LD_INT 1
5928: PPUSH
5929: LD_VAR 0 3
5933: PUSH
5934: LD_INT 4
5936: ARRAY
5937: PPUSH
5938: LD_VAR 0 5
5942: PPUSH
5943: LD_VAR 0 6
5947: PPUSH
5948: CALL 40801 0 4
// if gensher_active then
5952: LD_EXP 18
5956: IFFALSE 6358
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5958: LD_EXP 44
5962: PPUSH
5963: LD_STRING D10-Diet-1
5965: PPUSH
5966: CALL_OW 94
// for i = 1 to 2 do
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: DOUBLE
5976: LD_INT 1
5978: DEC
5979: ST_TO_ADDR
5980: LD_INT 2
5982: PUSH
5983: FOR_TO
5984: IFFALSE 6122
// begin uc_side := 2 ;
5986: LD_ADDR_OWVAR 20
5990: PUSH
5991: LD_INT 2
5993: ST_TO_ADDR
// uc_nation := 2 ;
5994: LD_ADDR_OWVAR 21
5998: PUSH
5999: LD_INT 2
6001: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6002: LD_INT 13
6004: PPUSH
6005: LD_INT 3
6007: PPUSH
6008: LD_INT 5
6010: PPUSH
6011: LD_INT 29
6013: PPUSH
6014: LD_INT 100
6016: PPUSH
6017: CALL 53986 0 5
// un := CreateVehicle ;
6021: LD_ADDR_VAR 0 2
6025: PUSH
6026: CALL_OW 45
6030: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6031: LD_ADDR_VAR 0 3
6035: PUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: LD_INT 5
6043: PUSH
6044: LD_VAR 0 3
6048: PUSH
6049: LD_INT 5
6051: ARRAY
6052: PUSH
6053: LD_INT 1
6055: PLUS
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PPUSH
6061: LD_VAR 0 2
6065: PPUSH
6066: CALL 54108 0 3
6070: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6071: LD_VAR 0 2
6075: PPUSH
6076: LD_INT 0
6078: PPUSH
6079: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6083: LD_VAR 0 2
6087: PPUSH
6088: LD_INT 23
6090: PPUSH
6091: LD_INT 0
6093: PPUSH
6094: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 85
6105: PPUSH
6106: LD_INT 152
6108: PPUSH
6109: CALL_OW 111
// wait ( 0 0$2 ) ;
6113: LD_INT 70
6115: PPUSH
6116: CALL_OW 67
// end ;
6120: GO 5983
6122: POP
6123: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6124: LD_ADDR_VAR 0 1
6128: PUSH
6129: DOUBLE
6130: LD_INT 1
6132: DEC
6133: ST_TO_ADDR
6134: LD_INT 2
6136: PUSH
6137: LD_INT 3
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_OWVAR 67
6152: ARRAY
6153: PUSH
6154: FOR_TO
6155: IFFALSE 6312
// begin uc_side := 2 ;
6157: LD_ADDR_OWVAR 20
6161: PUSH
6162: LD_INT 2
6164: ST_TO_ADDR
// uc_nation := 2 ;
6165: LD_ADDR_OWVAR 21
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6173: LD_INT 14
6175: PPUSH
6176: LD_INT 3
6178: PPUSH
6179: LD_INT 5
6181: PPUSH
6182: LD_INT 27
6184: PUSH
6185: LD_INT 28
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: LD_INT 2
6197: PPUSH
6198: CALL_OW 12
6202: ARRAY
6203: PPUSH
6204: LD_INT 100
6206: PPUSH
6207: CALL 53986 0 5
// un := CreateVehicle ;
6211: LD_ADDR_VAR 0 2
6215: PUSH
6216: CALL_OW 45
6220: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6221: LD_ADDR_VAR 0 3
6225: PUSH
6226: LD_VAR 0 3
6230: PPUSH
6231: LD_INT 5
6233: PUSH
6234: LD_VAR 0 3
6238: PUSH
6239: LD_INT 5
6241: ARRAY
6242: PUSH
6243: LD_INT 1
6245: PLUS
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: PPUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: CALL 54108 0 3
6260: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6261: LD_VAR 0 2
6265: PPUSH
6266: LD_INT 0
6268: PPUSH
6269: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6273: LD_VAR 0 2
6277: PPUSH
6278: LD_INT 23
6280: PPUSH
6281: LD_INT 0
6283: PPUSH
6284: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_INT 85
6295: PPUSH
6296: LD_INT 152
6298: PPUSH
6299: CALL_OW 111
// wait ( 0 0$2 ) ;
6303: LD_INT 70
6305: PPUSH
6306: CALL_OW 67
// end ;
6310: GO 6154
6312: POP
6313: POP
// coords := [ [ 97 , 143 ] ] ;
6314: LD_ADDR_VAR 0 5
6318: PUSH
6319: LD_INT 97
6321: PUSH
6322: LD_INT 143
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: PUSH
6329: EMPTY
6330: LIST
6331: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6332: LD_INT 1
6334: PPUSH
6335: LD_VAR 0 3
6339: PUSH
6340: LD_INT 5
6342: ARRAY
6343: PPUSH
6344: LD_VAR 0 5
6348: PPUSH
6349: LD_VAR 0 6
6353: PPUSH
6354: CALL 40801 0 4
// end ; Wait ( 13 13$00 ) ;
6358: LD_INT 27300
6360: PPUSH
6361: CALL_OW 67
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// w := 1 ;
6372: LD_ADDR_VAR 0 7
6376: PUSH
6377: LD_INT 1
6379: ST_TO_ADDR
// repeat tmp := [ ] ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: EMPTY
6386: ST_TO_ADDR
// if w mod 4 = 0 then
6387: LD_VAR 0 7
6391: PUSH
6392: LD_INT 4
6394: MOD
6395: PUSH
6396: LD_INT 0
6398: EQUAL
6399: IFFALSE 6486
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6401: LD_ADDR_VAR 0 8
6405: PUSH
6406: LD_INT 11
6408: PUSH
6409: LD_INT 1
6411: PUSH
6412: LD_INT 2
6414: PUSH
6415: LD_INT 24
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_INT 11
6426: PUSH
6427: LD_INT 1
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: LD_INT 24
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 11
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 24
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 11
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 24
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: ST_TO_ADDR
6484: GO 6588
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6486: LD_ADDR_VAR 0 8
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: LD_INT 1
6496: PUSH
6497: LD_INT 2
6499: PUSH
6500: LD_INT 28
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 14
6511: PUSH
6512: LD_INT 1
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: LD_INT 25
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: PUSH
6527: LD_INT 14
6529: PUSH
6530: LD_INT 1
6532: PUSH
6533: LD_INT 2
6535: PUSH
6536: LD_INT 28
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: PUSH
6545: LD_INT 14
6547: PUSH
6548: LD_INT 1
6550: PUSH
6551: LD_INT 2
6553: PUSH
6554: LD_INT 29
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_INT 11
6565: PUSH
6566: LD_INT 1
6568: PUSH
6569: LD_INT 2
6571: PUSH
6572: LD_INT 24
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: ST_TO_ADDR
// if w mod 3 = 0 then
6588: LD_VAR 0 7
6592: PUSH
6593: LD_INT 3
6595: MOD
6596: PUSH
6597: LD_INT 0
6599: EQUAL
6600: IFFALSE 6676
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6602: LD_ADDR_VAR 0 8
6606: PUSH
6607: LD_VAR 0 8
6611: PPUSH
6612: LD_INT 1
6614: PUSH
6615: LD_VAR 0 8
6619: PUSH
6620: LD_VAR 0 1
6624: ARRAY
6625: PUSH
6626: LD_INT 1
6628: PLUS
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PPUSH
6634: LD_INT 14
6636: PUSH
6637: LD_INT 1
6639: PUSH
6640: LD_INT 2
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: LD_INT 28
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 2
6658: PPUSH
6659: CALL_OW 12
6663: ARRAY
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PPUSH
6671: CALL 54108 0 3
6675: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6676: LD_INT 1
6678: PPUSH
6679: LD_VAR 0 8
6683: PPUSH
6684: CALL 40568 0 2
// if GetSide ( ar_dep_w ) = 2 then
6688: LD_INT 45
6690: PPUSH
6691: CALL_OW 255
6695: PUSH
6696: LD_INT 2
6698: EQUAL
6699: IFFALSE 6784
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6701: LD_ADDR_VAR 0 8
6705: PUSH
6706: LD_INT 14
6708: PUSH
6709: LD_INT 1
6711: PUSH
6712: LD_INT 2
6714: PUSH
6715: LD_INT 28
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 14
6726: PUSH
6727: LD_INT 1
6729: PUSH
6730: LD_INT 2
6732: PUSH
6733: LD_INT 27
6735: PUSH
6736: EMPTY
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 14
6744: PUSH
6745: LD_INT 1
6747: PUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 27
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6765: LD_INT 2
6767: PPUSH
6768: LD_VAR 0 8
6772: PPUSH
6773: CALL 40568 0 2
// wait ( 0 0$50 ) ;
6777: LD_INT 1750
6779: PPUSH
6780: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6784: LD_INT 35
6786: PPUSH
6787: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6791: LD_EXP 68
6795: PUSH
6796: LD_INT 1
6798: ARRAY
6799: PPUSH
6800: LD_INT 3
6802: PUSH
6803: LD_INT 34
6805: PUSH
6806: LD_INT 32
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PPUSH
6817: CALL_OW 72
6821: PUSH
6822: LD_INT 4
6824: GREATEREQUAL
6825: IFFALSE 6784
// wait ( 0 0$10 ) ;
6827: LD_INT 350
6829: PPUSH
6830: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6834: LD_ADDR_VAR 0 3
6838: PUSH
6839: LD_EXP 68
6843: PUSH
6844: LD_INT 1
6846: ARRAY
6847: PPUSH
6848: LD_INT 3
6850: PUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 32
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PPUSH
6865: CALL_OW 72
6869: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6870: LD_INT 100
6872: PPUSH
6873: CALL_OW 13
6877: PUSH
6878: LD_INT 50
6880: LESS
6881: IFFALSE 6914
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6883: LD_ADDR_VAR 0 5
6887: PUSH
6888: LD_INT 55
6890: PUSH
6891: LD_INT 7
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 75
6900: PUSH
6901: LD_INT 90
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: ST_TO_ADDR
6912: GO 6943
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6914: LD_ADDR_VAR 0 5
6918: PUSH
6919: LD_INT 128
6921: PUSH
6922: LD_INT 94
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 180
6931: PUSH
6932: LD_INT 135
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: ST_TO_ADDR
// if w mod 4 = 0 then
6943: LD_VAR 0 7
6947: PUSH
6948: LD_INT 4
6950: MOD
6951: PUSH
6952: LD_INT 0
6954: EQUAL
6955: IFFALSE 6986
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6957: LD_ADDR_VAR 0 5
6961: PUSH
6962: LD_INT 91
6964: PUSH
6965: LD_INT 58
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 117
6974: PUSH
6975: LD_INT 107
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6986: LD_INT 1
6988: PPUSH
6989: LD_VAR 0 3
6993: PPUSH
6994: LD_VAR 0 5
6998: PPUSH
6999: LD_VAR 0 6
7003: PPUSH
7004: CALL 40801 0 4
// if mc_vehicles [ 2 ] then
7008: LD_EXP 68
7012: PUSH
7013: LD_INT 2
7015: ARRAY
7016: IFFALSE 7052
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7018: LD_INT 2
7020: PPUSH
7021: LD_EXP 68
7025: PUSH
7026: LD_INT 2
7028: ARRAY
7029: PPUSH
7030: LD_INT 73
7032: PUSH
7033: LD_INT 115
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: EMPTY
7041: LIST
7042: PPUSH
7043: LD_VAR 0 6
7047: PPUSH
7048: CALL 40801 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7052: LD_INT 22050
7054: PPUSH
7055: LD_INT 28350
7057: PPUSH
7058: CALL_OW 12
7062: PPUSH
7063: CALL_OW 67
// w := w + 1 ;
7067: LD_ADDR_VAR 0 7
7071: PUSH
7072: LD_VAR 0 7
7076: PUSH
7077: LD_INT 1
7079: PLUS
7080: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7081: LD_INT 94
7083: PPUSH
7084: CALL_OW 301
7088: PUSH
7089: LD_EXP 49
7093: PUSH
7094: LD_INT 1
7096: ARRAY
7097: PPUSH
7098: LD_INT 30
7100: PUSH
7101: LD_INT 3
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: NOT
7113: OR
7114: IFFALSE 6380
// end ;
7116: PPOPN 8
7118: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7119: LD_INT 204
7121: IFFALSE 7595
7123: GO 7125
7125: DISABLE
7126: LD_INT 0
7128: PPUSH
7129: PPUSH
7130: PPUSH
7131: PPUSH
// begin enable ;
7132: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7133: LD_INT 35
7135: PPUSH
7136: LD_INT 1190
7138: PPUSH
7139: CALL_OW 12
7143: PPUSH
7144: CALL_OW 67
// tmp := [ ] ;
7148: LD_ADDR_VAR 0 2
7152: PUSH
7153: EMPTY
7154: ST_TO_ADDR
// uc_side := 8 ;
7155: LD_ADDR_OWVAR 20
7159: PUSH
7160: LD_INT 8
7162: ST_TO_ADDR
// uc_nation := 2 ;
7163: LD_ADDR_OWVAR 21
7167: PUSH
7168: LD_INT 2
7170: ST_TO_ADDR
// InitHc ;
7171: CALL_OW 19
// for i = 1 to 3 do
7175: LD_ADDR_VAR 0 1
7179: PUSH
7180: DOUBLE
7181: LD_INT 1
7183: DEC
7184: ST_TO_ADDR
7185: LD_INT 3
7187: PUSH
7188: FOR_TO
7189: IFFALSE 7316
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7191: LD_INT 13
7193: PUSH
7194: LD_INT 14
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 1
7203: PPUSH
7204: LD_INT 2
7206: PPUSH
7207: CALL_OW 12
7211: ARRAY
7212: PPUSH
7213: LD_INT 3
7215: PPUSH
7216: LD_INT 5
7218: PPUSH
7219: LD_INT 27
7221: PUSH
7222: LD_INT 28
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: LD_INT 1
7231: PPUSH
7232: LD_INT 2
7234: PPUSH
7235: CALL_OW 12
7239: ARRAY
7240: PPUSH
7241: LD_INT 100
7243: PPUSH
7244: CALL 53986 0 5
// un := CreateVehicle ;
7248: LD_ADDR_VAR 0 3
7252: PUSH
7253: CALL_OW 45
7257: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7258: LD_VAR 0 3
7262: PPUSH
7263: LD_INT 4
7265: PPUSH
7266: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7270: LD_VAR 0 3
7274: PPUSH
7275: LD_INT 15
7277: PPUSH
7278: LD_INT 0
7280: PPUSH
7281: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7285: LD_ADDR_VAR 0 2
7289: PUSH
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_VAR 0 2
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PPUSH
7304: LD_VAR 0 3
7308: PPUSH
7309: CALL_OW 1
7313: ST_TO_ADDR
// end ;
7314: GO 7188
7316: POP
7317: POP
// for i = 1 to 4 do
7318: LD_ADDR_VAR 0 1
7322: PUSH
7323: DOUBLE
7324: LD_INT 1
7326: DEC
7327: ST_TO_ADDR
7328: LD_INT 4
7330: PUSH
7331: FOR_TO
7332: IFFALSE 7411
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7334: LD_INT 0
7336: PPUSH
7337: LD_INT 1
7339: PPUSH
7340: LD_INT 4
7342: PPUSH
7343: CALL_OW 12
7347: PPUSH
7348: LD_INT 6
7350: PPUSH
7351: CALL_OW 380
// un := CreateHuman ;
7355: LD_ADDR_VAR 0 3
7359: PUSH
7360: CALL_OW 44
7364: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7365: LD_VAR 0 3
7369: PPUSH
7370: LD_INT 15
7372: PPUSH
7373: LD_INT 0
7375: PPUSH
7376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7380: LD_ADDR_VAR 0 2
7384: PUSH
7385: LD_VAR 0 2
7389: PPUSH
7390: LD_VAR 0 2
7394: PUSH
7395: LD_INT 1
7397: PLUS
7398: PPUSH
7399: LD_VAR 0 3
7403: PPUSH
7404: CALL_OW 1
7408: ST_TO_ADDR
// end ;
7409: GO 7331
7411: POP
7412: POP
// wait ( 0 0$3 ) ;
7413: LD_INT 105
7415: PPUSH
7416: CALL_OW 67
// for i in tmp do
7420: LD_ADDR_VAR 0 1
7424: PUSH
7425: LD_VAR 0 2
7429: PUSH
7430: FOR_IN
7431: IFFALSE 7499
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7433: LD_VAR 0 1
7437: PPUSH
7438: CALL_OW 257
7442: PUSH
7443: LD_INT 1
7445: EQUAL
7446: PUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 247
7456: PUSH
7457: LD_INT 2
7459: EQUAL
7460: OR
7461: IFFALSE 7497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7463: LD_VAR 0 1
7467: PPUSH
7468: LD_INT 81
7470: PUSH
7471: LD_INT 8
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: CALL_OW 74
7492: PPUSH
7493: CALL_OW 115
7497: GO 7430
7499: POP
7500: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7501: LD_VAR 0 2
7505: PPUSH
7506: LD_INT 210
7508: PPUSH
7509: LD_INT 178
7511: PPUSH
7512: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7516: LD_ADDR_VAR 0 4
7520: PUSH
7521: LD_INT 10
7523: PPUSH
7524: LD_INT 22
7526: PUSH
7527: LD_INT 8
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PPUSH
7534: CALL_OW 70
7538: ST_TO_ADDR
// if x then
7539: LD_VAR 0 4
7543: IFFALSE 7571
// for i in x do
7545: LD_ADDR_VAR 0 1
7549: PUSH
7550: LD_VAR 0 4
7554: PUSH
7555: FOR_IN
7556: IFFALSE 7569
// RemoveUnit ( i ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: CALL_OW 64
7567: GO 7555
7569: POP
7570: POP
// wait ( 0 0$1 ) ;
7571: LD_INT 35
7573: PPUSH
7574: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7578: LD_INT 22
7580: PUSH
7581: LD_INT 8
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PPUSH
7588: CALL_OW 69
7592: NOT
7593: IFFALSE 7501
// end ;
7595: PPOPN 4
7597: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7598: LD_INT 22
7600: PUSH
7601: LD_INT 2
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: LD_INT 34
7610: PUSH
7611: LD_INT 31
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: PUSH
7618: LD_INT 3
7620: PUSH
7621: LD_INT 24
7623: PUSH
7624: LD_INT 1000
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 69
7644: IFFALSE 7688
7646: GO 7648
7648: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7649: LD_INT 22
7651: PUSH
7652: LD_INT 2
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 34
7661: PUSH
7662: LD_INT 31
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 69
7677: PPUSH
7678: LD_INT 106
7680: PPUSH
7681: LD_INT 14
7683: PPUSH
7684: CALL_OW 111
// end ; end_of_file
7688: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7689: LD_INT 0
7691: PPUSH
7692: PPUSH
7693: PPUSH
7694: PPUSH
7695: PPUSH
7696: PPUSH
// InGameOn ;
7697: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7701: LD_EXP 20
7705: PPUSH
7706: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7710: LD_INT 2
7712: PPUSH
7713: LD_INT 1
7715: PPUSH
7716: LD_INT 1
7718: PPUSH
7719: LD_INT 1
7721: PPUSH
7722: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7726: LD_ADDR_VAR 0 2
7730: PUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 25
7743: PUSH
7744: LD_INT 1
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 22
7767: PUSH
7768: LD_INT 1
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 34
7777: PUSH
7778: LD_INT 11
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PPUSH
7789: CALL_OW 69
7793: PUSH
7794: LD_INT 1
7796: ARRAY
7797: ST_TO_ADDR
// for i = 1 to tmp do
7798: LD_ADDR_VAR 0 6
7802: PUSH
7803: DOUBLE
7804: LD_INT 1
7806: DEC
7807: ST_TO_ADDR
7808: LD_VAR 0 2
7812: PUSH
7813: FOR_TO
7814: IFFALSE 7861
// begin if i = 5 then
7816: LD_VAR 0 6
7820: PUSH
7821: LD_INT 5
7823: EQUAL
7824: IFFALSE 7828
// break ;
7826: GO 7861
// sols := Replace ( sols , i , tmp [ i ] ) ;
7828: LD_ADDR_VAR 0 5
7832: PUSH
7833: LD_VAR 0 5
7837: PPUSH
7838: LD_VAR 0 6
7842: PPUSH
7843: LD_VAR 0 2
7847: PUSH
7848: LD_VAR 0 6
7852: ARRAY
7853: PPUSH
7854: CALL_OW 1
7858: ST_TO_ADDR
// end ;
7859: GO 7813
7861: POP
7862: POP
// tmp := ar_force_tmp ;
7863: LD_ADDR_VAR 0 2
7867: PUSH
7868: LD_EXP 39
7872: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7873: LD_VAR 0 2
7877: PUSH
7878: LD_INT 1
7880: ARRAY
7881: PPUSH
7882: LD_INT 108
7884: PPUSH
7885: LD_INT 139
7887: PPUSH
7888: LD_INT 0
7890: PPUSH
7891: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7895: LD_VAR 0 2
7899: PUSH
7900: LD_INT 1
7902: ARRAY
7903: PPUSH
7904: LD_EXP 20
7908: PPUSH
7909: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7913: LD_VAR 0 2
7917: PUSH
7918: LD_INT 2
7920: ARRAY
7921: PPUSH
7922: LD_INT 114
7924: PPUSH
7925: LD_INT 132
7927: PPUSH
7928: LD_INT 0
7930: PPUSH
7931: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7935: LD_VAR 0 2
7939: PUSH
7940: LD_INT 3
7942: ARRAY
7943: PPUSH
7944: LD_INT 115
7946: PPUSH
7947: LD_INT 132
7949: PPUSH
7950: LD_INT 0
7952: PPUSH
7953: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7957: LD_VAR 0 2
7961: PUSH
7962: LD_INT 2
7964: ARRAY
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: LD_INT 3
7973: ARRAY
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7983: LD_VAR 0 4
7987: PPUSH
7988: LD_INT 83
7990: PPUSH
7991: LD_INT 123
7993: PPUSH
7994: CALL_OW 111
// Wait ( 0 0$01 ) ;
7998: LD_INT 35
8000: PPUSH
8001: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8005: LD_INT 90
8007: PPUSH
8008: LD_INT 144
8010: PPUSH
8011: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8015: LD_VAR 0 5
8019: PPUSH
8020: LD_INT 88
8022: PPUSH
8023: LD_INT 129
8025: PPUSH
8026: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8030: LD_ADDR_VAR 0 3
8034: PUSH
8035: LD_INT 92
8037: PUSH
8038: LD_INT 131
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 88
8047: PUSH
8048: LD_INT 127
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 91
8057: PUSH
8058: LD_INT 132
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 92
8067: PUSH
8068: LD_INT 134
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: ST_TO_ADDR
// for i = 1 to sols do
8081: LD_ADDR_VAR 0 6
8085: PUSH
8086: DOUBLE
8087: LD_INT 1
8089: DEC
8090: ST_TO_ADDR
8091: LD_VAR 0 5
8095: PUSH
8096: FOR_TO
8097: IFFALSE 8170
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8099: LD_VAR 0 5
8103: PUSH
8104: LD_VAR 0 6
8108: ARRAY
8109: PPUSH
8110: LD_VAR 0 3
8114: PUSH
8115: LD_VAR 0 6
8119: ARRAY
8120: PUSH
8121: LD_INT 1
8123: ARRAY
8124: PPUSH
8125: LD_VAR 0 3
8129: PUSH
8130: LD_VAR 0 6
8134: ARRAY
8135: PUSH
8136: LD_INT 2
8138: ARRAY
8139: PPUSH
8140: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8144: LD_VAR 0 5
8148: PUSH
8149: LD_VAR 0 6
8153: ARRAY
8154: PPUSH
8155: CALL_OW 197
// AddComHold ( sols ) ;
8159: LD_VAR 0 5
8163: PPUSH
8164: CALL_OW 200
// end ;
8168: GO 8096
8170: POP
8171: POP
// repeat wait ( 0 0$1 ) ;
8172: LD_INT 35
8174: PPUSH
8175: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8179: LD_VAR 0 5
8183: PUSH
8184: LD_INT 1
8186: ARRAY
8187: PPUSH
8188: LD_INT 92
8190: PPUSH
8191: LD_INT 131
8193: PPUSH
8194: CALL_OW 297
8198: PUSH
8199: LD_INT 4
8201: LESS
8202: IFFALSE 8172
// CenterOnXY ( 96 , 139 ) ;
8204: LD_INT 96
8206: PPUSH
8207: LD_INT 139
8209: PPUSH
8210: CALL_OW 84
// wait ( 0 0$3 ) ;
8214: LD_INT 105
8216: PPUSH
8217: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8221: LD_INT 111
8223: PPUSH
8224: LD_INT 135
8226: PPUSH
8227: LD_INT 1
8229: PPUSH
8230: LD_INT 25
8232: NEG
8233: PPUSH
8234: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8238: LD_VAR 0 2
8242: PUSH
8243: LD_INT 2
8245: ARRAY
8246: PPUSH
8247: LD_VAR 0 2
8251: PUSH
8252: LD_INT 1
8254: ARRAY
8255: PPUSH
8256: CALL_OW 250
8260: PUSH
8261: LD_INT 3
8263: PLUS
8264: PPUSH
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 1
8272: ARRAY
8273: PPUSH
8274: CALL_OW 251
8278: PPUSH
8279: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8283: LD_VAR 0 2
8287: PUSH
8288: LD_INT 3
8290: ARRAY
8291: PPUSH
8292: LD_INT 7
8294: PPUSH
8295: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8299: LD_VAR 0 2
8303: PUSH
8304: LD_INT 2
8306: ARRAY
8307: PPUSH
8308: LD_VAR 0 2
8312: PUSH
8313: LD_INT 1
8315: ARRAY
8316: PPUSH
8317: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8321: LD_INT 35
8323: PPUSH
8324: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8328: LD_VAR 0 2
8332: PUSH
8333: LD_INT 1
8335: ARRAY
8336: PPUSH
8337: LD_VAR 0 2
8341: PUSH
8342: LD_INT 2
8344: ARRAY
8345: PPUSH
8346: CALL_OW 296
8350: PUSH
8351: LD_INT 5
8353: LESS
8354: IFFALSE 8321
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8356: LD_VAR 0 2
8360: PUSH
8361: LD_INT 1
8363: ARRAY
8364: PPUSH
8365: LD_VAR 0 2
8369: PUSH
8370: LD_INT 2
8372: ARRAY
8373: PPUSH
8374: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PPUSH
8387: LD_STRING D1a-Merc1-1
8389: PPUSH
8390: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8394: LD_VAR 0 2
8398: PUSH
8399: LD_INT 2
8401: ARRAY
8402: PPUSH
8403: LD_STRING D1a-FMerc2-1
8405: PPUSH
8406: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8410: LD_VAR 0 2
8414: PUSH
8415: LD_INT 2
8417: ARRAY
8418: PPUSH
8419: LD_VAR 0 2
8423: PUSH
8424: LD_INT 1
8426: ARRAY
8427: PPUSH
8428: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8432: LD_VAR 0 2
8436: PUSH
8437: LD_INT 1
8439: ARRAY
8440: PPUSH
8441: LD_INT 500
8443: PPUSH
8444: CALL_OW 234
// wait ( 0 0$2 ) ;
8448: LD_INT 70
8450: PPUSH
8451: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8455: LD_VAR 0 2
8459: PUSH
8460: LD_INT 1
8462: ARRAY
8463: PPUSH
8464: LD_INT 2
8466: PPUSH
8467: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8471: LD_INT 10
8473: PPUSH
8474: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8478: LD_VAR 0 2
8482: PUSH
8483: LD_INT 1
8485: ARRAY
8486: PPUSH
8487: LD_STRING D1a-Merc1-2
8489: PPUSH
8490: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8494: LD_INT 7
8496: PPUSH
8497: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8501: LD_VAR 0 2
8505: PUSH
8506: LD_INT 1
8508: ARRAY
8509: PPUSH
8510: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8514: LD_VAR 0 2
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: LD_INT 10
8525: PPUSH
8526: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8530: LD_VAR 0 2
8534: PUSH
8535: LD_INT 2
8537: ARRAY
8538: PPUSH
8539: LD_STRING D1a-FMerc2-2
8541: PPUSH
8542: CALL_OW 88
// wait ( 0 0$1 ) ;
8546: LD_INT 35
8548: PPUSH
8549: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8553: LD_INT 7
8555: PPUSH
8556: CALL_OW 85
// wait ( 0 0$2 ) ;
8560: LD_INT 70
8562: PPUSH
8563: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8567: LD_EXP 43
8571: PPUSH
8572: LD_STRING D1a-Saliba-1
8574: PPUSH
8575: CALL_OW 91
// KillUnit ( Saliba ) ;
8579: LD_EXP 43
8583: PPUSH
8584: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8588: LD_VAR 0 2
8592: PUSH
8593: LD_INT 3
8595: ARRAY
8596: PPUSH
8597: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8601: LD_EXP 20
8605: PPUSH
8606: CALL_OW 85
// wait ( 0 0$1 ) ;
8610: LD_INT 35
8612: PPUSH
8613: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8617: LD_VAR 0 5
8621: PPUSH
8622: LD_INT 88
8624: PPUSH
8625: LD_INT 141
8627: PPUSH
8628: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8632: LD_VAR 0 5
8636: PPUSH
8637: LD_INT 70
8639: PPUSH
8640: CALL_OW 202
// wait ( 0 0$2 ) ;
8644: LD_INT 70
8646: PPUSH
8647: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8651: LD_INT 2
8653: PPUSH
8654: LD_INT 1
8656: PPUSH
8657: LD_INT 2
8659: PPUSH
8660: LD_INT 1
8662: PPUSH
8663: CALL_OW 80
// InGameOff ;
8667: CALL_OW 9
// ComWalk ( sols ) ;
8671: LD_VAR 0 5
8675: PPUSH
8676: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8680: LD_STRING M1
8682: PPUSH
8683: CALL_OW 337
// game_speed := 4 ;
8687: LD_ADDR_OWVAR 65
8691: PUSH
8692: LD_INT 4
8694: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8695: LD_INT 111
8697: PPUSH
8698: LD_INT 135
8700: PPUSH
8701: LD_INT 1
8703: PPUSH
8704: CALL_OW 331
// SaveForQuickRestart ;
8708: CALL_OW 22
// ar_run := true ;
8712: LD_ADDR_EXP 5
8716: PUSH
8717: LD_INT 1
8719: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8720: LD_INT 35
8722: PPUSH
8723: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8727: LD_INT 22
8729: PUSH
8730: LD_INT 1
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: LD_INT 91
8739: PUSH
8740: LD_INT 7
8742: PUSH
8743: LD_INT 10
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: LIST
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: PPUSH
8755: CALL_OW 69
8759: PUSH
8760: LD_INT 7
8762: PPUSH
8763: CALL_OW 256
8767: PUSH
8768: LD_INT 999
8770: LESS
8771: OR
8772: IFFALSE 8720
// if GetSide ( ar_dep_s ) = 2 then
8774: LD_INT 7
8776: PPUSH
8777: CALL_OW 255
8781: PUSH
8782: LD_INT 2
8784: EQUAL
8785: IFFALSE 8797
// SetSide ( ar_dep_s , 1 ) ;
8787: LD_INT 7
8789: PPUSH
8790: LD_INT 1
8792: PPUSH
8793: CALL_OW 235
// end ;
8797: LD_VAR 0 1
8801: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8802: LD_EXP 5
8806: IFFALSE 9166
8808: GO 8810
8810: DISABLE
8811: LD_INT 0
8813: PPUSH
8814: PPUSH
8815: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8816: LD_ADDR_VAR 0 2
8820: PUSH
8821: LD_EXP 39
8825: PUSH
8826: LD_EXP 35
8830: PPUSH
8831: LD_INT 2
8833: PUSH
8834: LD_INT 21
8836: PUSH
8837: LD_INT 2
8839: PUSH
8840: EMPTY
8841: LIST
8842: LIST
8843: PUSH
8844: LD_INT 21
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: LIST
8858: PPUSH
8859: CALL_OW 72
8863: ADD
8864: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8865: LD_VAR 0 2
8869: PPUSH
8870: LD_INT 5
8872: PPUSH
8873: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8877: LD_INT 5
8879: PPUSH
8880: LD_INT 1
8882: PPUSH
8883: CALL_OW 343
// k := 1 ;
8887: LD_ADDR_VAR 0 3
8891: PUSH
8892: LD_INT 1
8894: ST_TO_ADDR
// for i in tmp do
8895: LD_ADDR_VAR 0 1
8899: PUSH
8900: LD_VAR 0 2
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8991
// begin if IsInUnit ( i ) then
8908: LD_VAR 0 1
8912: PPUSH
8913: CALL_OW 310
8917: IFFALSE 8928
// ComExitBuilding ( i ) ;
8919: LD_VAR 0 1
8923: PPUSH
8924: CALL_OW 122
// if GetClass ( i ) = 3 then
8928: LD_VAR 0 1
8932: PPUSH
8933: CALL_OW 257
8937: PUSH
8938: LD_INT 3
8940: EQUAL
8941: IFFALSE 8977
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8943: LD_VAR 0 1
8947: PPUSH
8948: LD_EXP 40
8952: PUSH
8953: LD_VAR 0 3
8957: ARRAY
8958: PPUSH
8959: CALL_OW 180
// k := k + 1 ;
8963: LD_ADDR_VAR 0 3
8967: PUSH
8968: LD_VAR 0 3
8972: PUSH
8973: LD_INT 1
8975: PLUS
8976: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8977: LD_VAR 0 1
8981: PPUSH
8982: LD_INT 10
8984: PPUSH
8985: CALL_OW 173
// end ;
8989: GO 8905
8991: POP
8992: POP
// ar_patrol := true ;
8993: LD_ADDR_EXP 7
8997: PUSH
8998: LD_INT 1
9000: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9001: LD_INT 10
9003: PPUSH
9004: CALL_OW 67
// for i in tmp do
9008: LD_ADDR_VAR 0 1
9012: PUSH
9013: LD_VAR 0 2
9017: PUSH
9018: FOR_IN
9019: IFFALSE 9047
// if not HasTask ( i ) then
9021: LD_VAR 0 1
9025: PPUSH
9026: CALL_OW 314
9030: NOT
9031: IFFALSE 9045
// ComMoveToArea ( i , escape_area ) ;
9033: LD_VAR 0 1
9037: PPUSH
9038: LD_INT 10
9040: PPUSH
9041: CALL_OW 113
9045: GO 9018
9047: POP
9048: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9049: LD_ADDR_VAR 0 3
9053: PUSH
9054: LD_VAR 0 2
9058: PPUSH
9059: LD_INT 95
9061: PUSH
9062: LD_INT 10
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: PPUSH
9069: CALL_OW 72
9073: ST_TO_ADDR
// if k then
9074: LD_VAR 0 3
9078: IFFALSE 9147
// for i in k do
9080: LD_ADDR_VAR 0 1
9084: PUSH
9085: LD_VAR 0 3
9089: PUSH
9090: FOR_IN
9091: IFFALSE 9145
// begin if IsInUnit ( i ) then
9093: LD_VAR 0 1
9097: PPUSH
9098: CALL_OW 310
9102: IFFALSE 9118
// RemoveUnit ( IsInUnit ( i ) ) ;
9104: LD_VAR 0 1
9108: PPUSH
9109: CALL_OW 310
9113: PPUSH
9114: CALL_OW 64
// RemoveUnit ( i ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: CALL_OW 64
// tmp := tmp diff i ;
9127: LD_ADDR_VAR 0 2
9131: PUSH
9132: LD_VAR 0 2
9136: PUSH
9137: LD_VAR 0 1
9141: DIFF
9142: ST_TO_ADDR
// end ;
9143: GO 9090
9145: POP
9146: POP
// until tmp = [ ] ;
9147: LD_VAR 0 2
9151: PUSH
9152: EMPTY
9153: EQUAL
9154: IFFALSE 9001
// ChangeSideFog ( 5 , 5 ) ;
9156: LD_INT 5
9158: PPUSH
9159: LD_INT 5
9161: PPUSH
9162: CALL_OW 343
// end ;
9166: PPOPN 3
9168: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9169: LD_EXP 7
9173: IFFALSE 9463
9175: GO 9177
9177: DISABLE
9178: LD_INT 0
9180: PPUSH
9181: PPUSH
9182: PPUSH
// begin uc_side := 2 ;
9183: LD_ADDR_OWVAR 20
9187: PUSH
9188: LD_INT 2
9190: ST_TO_ADDR
// uc_nation := 2 ;
9191: LD_ADDR_OWVAR 21
9195: PUSH
9196: LD_INT 2
9198: ST_TO_ADDR
// InitHc ;
9199: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9203: LD_INT 1
9205: PPUSH
9206: LD_INT 1
9208: PPUSH
9209: LD_INT 6
9211: PPUSH
9212: CALL_OW 380
// un := CreateHuman ;
9216: LD_ADDR_VAR 0 2
9220: PUSH
9221: CALL_OW 44
9225: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9226: LD_INT 14
9228: PPUSH
9229: LD_INT 1
9231: PPUSH
9232: LD_INT 1
9234: PPUSH
9235: LD_INT 27
9237: PPUSH
9238: LD_INT 98
9240: PPUSH
9241: CALL 53986 0 5
// veh := CreateVehicle ;
9245: LD_ADDR_VAR 0 3
9249: PUSH
9250: CALL_OW 45
9254: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9255: LD_VAR 0 3
9259: PPUSH
9260: LD_INT 4
9262: PPUSH
9263: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9267: LD_VAR 0 3
9271: PPUSH
9272: LD_INT 179
9274: PPUSH
9275: LD_INT 135
9277: PPUSH
9278: LD_INT 0
9280: PPUSH
9281: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9285: LD_VAR 0 2
9289: PPUSH
9290: LD_VAR 0 3
9294: PPUSH
9295: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9299: LD_VAR 0 2
9303: PPUSH
9304: LD_INT 126
9306: PPUSH
9307: LD_INT 133
9309: PPUSH
9310: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9314: LD_INT 10
9316: PPUSH
9317: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9321: LD_INT 1
9323: PPUSH
9324: LD_VAR 0 3
9328: PPUSH
9329: CALL_OW 292
9333: PUSH
9334: LD_VAR 0 3
9338: PPUSH
9339: LD_INT 7
9341: PPUSH
9342: CALL_OW 296
9346: PUSH
9347: LD_INT 9
9349: LESS
9350: OR
9351: IFFALSE 9314
// ComHold ( veh ) ;
9353: LD_VAR 0 3
9357: PPUSH
9358: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_STRING D2aa-Ar1-1
9369: PPUSH
9370: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9374: LD_VAR 0 2
9378: PPUSH
9379: LD_INT 177
9381: PPUSH
9382: LD_INT 96
9384: PPUSH
9385: CALL_OW 111
// AddComExitVehicle ( un ) ;
9389: LD_VAR 0 2
9393: PPUSH
9394: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9398: LD_INT 35
9400: PPUSH
9401: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9405: LD_VAR 0 2
9409: PPUSH
9410: LD_INT 204
9412: PPUSH
9413: CALL_OW 296
9417: PUSH
9418: LD_INT 15
9420: LESS
9421: IFFALSE 9398
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9423: LD_ADDR_EXP 49
9427: PUSH
9428: LD_EXP 49
9432: PPUSH
9433: LD_INT 3
9435: PUSH
9436: LD_EXP 49
9440: PUSH
9441: LD_INT 3
9443: ARRAY
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PPUSH
9453: LD_VAR 0 2
9457: PPUSH
9458: CALL 54108 0 3
9462: ST_TO_ADDR
// end ;
9463: PPOPN 3
9465: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9466: LD_INT 7
9468: PPUSH
9469: CALL_OW 255
9473: PUSH
9474: LD_INT 1
9476: EQUAL
9477: PUSH
9478: LD_INT 7
9480: PPUSH
9481: CALL_OW 301
9485: OR
9486: IFFALSE 11910
9488: GO 9490
9490: DISABLE
9491: LD_INT 0
9493: PPUSH
9494: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9495: LD_ADDR_VAR 0 1
9499: PUSH
9500: LD_EXP 35
9504: PPUSH
9505: LD_INT 21
9507: PUSH
9508: LD_INT 3
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PPUSH
9515: CALL_OW 72
9519: PUSH
9520: FOR_IN
9521: IFFALSE 9537
// SetSide ( i , 1 ) ;
9523: LD_VAR 0 1
9527: PPUSH
9528: LD_INT 1
9530: PPUSH
9531: CALL_OW 235
9535: GO 9520
9537: POP
9538: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9539: LD_ADDR_VAR 0 2
9543: PUSH
9544: LD_INT 46
9546: PUSH
9547: LD_INT 41
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 50
9556: PUSH
9557: LD_INT 25
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 57
9566: PUSH
9567: LD_INT 75
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 75
9576: PUSH
9577: LD_INT 89
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: PUSH
9584: LD_INT 51
9586: PUSH
9587: LD_INT 45
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: PUSH
9594: LD_INT 95
9596: PUSH
9597: LD_INT 95
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 84
9606: PUSH
9607: LD_INT 77
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 101
9616: PUSH
9617: LD_INT 76
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 118
9626: PUSH
9627: LD_INT 81
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 139
9636: PUSH
9637: LD_INT 97
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PUSH
9644: LD_INT 129
9646: PUSH
9647: LD_INT 114
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: LD_INT 154
9656: PUSH
9657: LD_INT 111
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// base_captured := true ;
9678: LD_ADDR_EXP 6
9682: PUSH
9683: LD_INT 1
9685: ST_TO_ADDR
// DialogueOn ;
9686: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9690: LD_EXP 20
9694: PPUSH
9695: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9699: LD_EXP 20
9703: PPUSH
9704: LD_STRING D2-JMM-1
9706: PPUSH
9707: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9711: LD_EXP 29
9715: PPUSH
9716: LD_STRING D2-Pow-1
9718: PPUSH
9719: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9723: LD_EXP 20
9727: PPUSH
9728: LD_STRING D2-JMM-2
9730: PPUSH
9731: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9735: LD_EXP 29
9739: PPUSH
9740: LD_STRING D2-Pow-2
9742: PPUSH
9743: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9747: LD_EXP 20
9751: PPUSH
9752: LD_STRING D2-JMM-3
9754: PPUSH
9755: CALL_OW 88
// DialogueOff ;
9759: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9763: LD_STRING M2
9765: PPUSH
9766: CALL_OW 337
// Wait ( 0 0$2 ) ;
9770: LD_INT 70
9772: PPUSH
9773: CALL_OW 67
// if IsOk ( Gary ) then
9777: LD_EXP 31
9781: PPUSH
9782: CALL_OW 302
9786: IFFALSE 9800
// Say ( Gary , D2a-Gary-1 ) ;
9788: LD_EXP 31
9792: PPUSH
9793: LD_STRING D2a-Gary-1
9795: PPUSH
9796: CALL_OW 88
// if IsOk ( Bobby ) then
9800: LD_EXP 23
9804: PPUSH
9805: CALL_OW 302
9809: IFFALSE 9823
// Say ( Bobby , D2a-Bobby-1 ) ;
9811: LD_EXP 23
9815: PPUSH
9816: LD_STRING D2a-Bobby-1
9818: PPUSH
9819: CALL_OW 88
// if IsOk ( Cyrus ) then
9823: LD_EXP 24
9827: PPUSH
9828: CALL_OW 302
9832: IFFALSE 9846
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9834: LD_EXP 24
9838: PPUSH
9839: LD_STRING D2a-Cyrus-1
9841: PPUSH
9842: CALL_OW 88
// if IsOk ( Lisa ) then
9846: LD_EXP 21
9850: PPUSH
9851: CALL_OW 302
9855: IFFALSE 9869
// Say ( Lisa , D2a-Lisa-1 ) ;
9857: LD_EXP 21
9861: PPUSH
9862: LD_STRING D2a-Lisa-1
9864: PPUSH
9865: CALL_OW 88
// if IsOk ( Frank ) then
9869: LD_EXP 32
9873: PPUSH
9874: CALL_OW 302
9878: IFFALSE 9892
// Say ( Frank , D2a-Frank-1 ) ;
9880: LD_EXP 32
9884: PPUSH
9885: LD_STRING D2a-Frank-1
9887: PPUSH
9888: CALL_OW 88
// if IsOk ( Cornel ) then
9892: LD_EXP 30
9896: PPUSH
9897: CALL_OW 302
9901: IFFALSE 9915
// Say ( Cornel , D2a-Corn-1 ) ;
9903: LD_EXP 30
9907: PPUSH
9908: LD_STRING D2a-Corn-1
9910: PPUSH
9911: CALL_OW 88
// if IsOk ( Donaldson ) then
9915: LD_EXP 22
9919: PPUSH
9920: CALL_OW 302
9924: IFFALSE 9938
// Say ( Donaldson , D2a-Don-1 ) ;
9926: LD_EXP 22
9930: PPUSH
9931: LD_STRING D2a-Don-1
9933: PPUSH
9934: CALL_OW 88
// if IsOk ( Brown ) then
9938: LD_EXP 26
9942: PPUSH
9943: CALL_OW 302
9947: IFFALSE 9961
// Say ( Brown , D2a-Brown-1 ) ;
9949: LD_EXP 26
9953: PPUSH
9954: LD_STRING D2a-Brown-1
9956: PPUSH
9957: CALL_OW 88
// Wait ( 0 0$30 ) ;
9961: LD_INT 1050
9963: PPUSH
9964: CALL_OW 67
// if IsOk ( Frank ) then
9968: LD_EXP 32
9972: PPUSH
9973: CALL_OW 302
9977: IFFALSE 10243
// begin DialogueOn ;
9979: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9983: LD_EXP 20
9987: PUSH
9988: LD_EXP 32
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PPUSH
9997: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10001: LD_EXP 32
10005: PPUSH
10006: LD_STRING D3F-Frank-1
10008: PPUSH
10009: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10013: LD_EXP 20
10017: PPUSH
10018: LD_STRING D3F-JMM-1
10020: PPUSH
10021: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10025: LD_EXP 32
10029: PPUSH
10030: LD_STRING D3F-Frank-2
10032: PPUSH
10033: CALL_OW 88
// case Query ( QFrank ) of 1 :
10037: LD_STRING QFrank
10039: PPUSH
10040: CALL_OW 97
10044: PUSH
10045: LD_INT 1
10047: DOUBLE
10048: EQUAL
10049: IFTRUE 10053
10051: GO 10076
10053: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10054: LD_EXP 20
10058: PPUSH
10059: LD_STRING D3Fa-JMM-1
10061: PPUSH
10062: CALL_OW 88
// us_scout := 1 ;
10066: LD_ADDR_EXP 8
10070: PUSH
10071: LD_INT 1
10073: ST_TO_ADDR
// end ; 2 :
10074: GO 10239
10076: LD_INT 2
10078: DOUBLE
10079: EQUAL
10080: IFTRUE 10084
10082: GO 10206
10084: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10085: LD_EXP 20
10089: PPUSH
10090: LD_STRING D3Fb-JMM-1
10092: PPUSH
10093: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10097: LD_EXP 32
10101: PPUSH
10102: LD_STRING D3Fb-Frank-1
10104: PPUSH
10105: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10109: LD_STRING QFrank2
10111: PPUSH
10112: CALL_OW 97
10116: PUSH
10117: LD_INT 1
10119: DOUBLE
10120: EQUAL
10121: IFTRUE 10125
10123: GO 10172
10125: POP
// begin us_scout := 2 ;
10126: LD_ADDR_EXP 8
10130: PUSH
10131: LD_INT 2
10133: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10134: LD_EXP 20
10138: PPUSH
10139: LD_STRING D3Fba-JMM-1
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10146: LD_EXP 32
10150: PPUSH
10151: LD_STRING D3Fba-Frank-1
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10158: LD_EXP 20
10162: PPUSH
10163: LD_STRING D3Fba-JMM-2
10165: PPUSH
10166: CALL_OW 88
// end ; 2 :
10170: GO 10204
10172: LD_INT 2
10174: DOUBLE
10175: EQUAL
10176: IFTRUE 10180
10178: GO 10203
10180: POP
// begin us_scout := 0 ;
10181: LD_ADDR_EXP 8
10185: PUSH
10186: LD_INT 0
10188: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10189: LD_EXP 20
10193: PPUSH
10194: LD_STRING D3Fbb-JMM-1
10196: PPUSH
10197: CALL_OW 88
// end ; end ;
10201: GO 10204
10203: POP
// end ; 3 :
10204: GO 10239
10206: LD_INT 3
10208: DOUBLE
10209: EQUAL
10210: IFTRUE 10214
10212: GO 10238
10214: POP
// begin us_scout := - 1 ;
10215: LD_ADDR_EXP 8
10219: PUSH
10220: LD_INT 1
10222: NEG
10223: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10224: LD_EXP 20
10228: PPUSH
10229: LD_STRING D3Fc-JMM-1
10231: PPUSH
10232: CALL_OW 88
// end ; end ;
10236: GO 10239
10238: POP
// DialogueOff ;
10239: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10243: LD_EXP 8
10247: PUSH
10248: LD_INT 1
10250: NEG
10251: PUSH
10252: LD_INT 0
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: IN
10259: IFFALSE 10263
// exit ;
10261: GO 11910
// if us_scout in [ 1 , 2 ] then
10263: LD_EXP 8
10267: PUSH
10268: LD_INT 1
10270: PUSH
10271: LD_INT 2
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: IN
10278: IFFALSE 10977
// begin if IsInUnit ( Frank ) then
10280: LD_EXP 32
10284: PPUSH
10285: CALL_OW 310
10289: IFFALSE 10300
// ComExitBuilding ( Frank ) ;
10291: LD_EXP 32
10295: PPUSH
10296: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10300: LD_EXP 32
10304: PPUSH
10305: CALL_OW 311
10309: IFFALSE 10320
// ComExitVehicle ( Frank ) ;
10311: LD_EXP 32
10315: PPUSH
10316: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10320: LD_EXP 32
10324: PPUSH
10325: LD_INT 4
10327: PPUSH
10328: CALL_OW 235
// wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// if us_scout = 2 then
10339: LD_EXP 8
10343: PUSH
10344: LD_INT 2
10346: EQUAL
10347: IFFALSE 10715
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10349: LD_EXP 32
10353: PPUSH
10354: LD_INT 75
10356: PPUSH
10357: LD_INT 63
10359: PPUSH
10360: CALL_OW 111
// AddComHold ( Frank ) ;
10364: LD_EXP 32
10368: PPUSH
10369: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10373: LD_EXP 32
10377: PPUSH
10378: LD_INT 770
10380: PPUSH
10381: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10385: LD_EXP 32
10389: PPUSH
10390: LD_INT 100
10392: PPUSH
10393: LD_INT 75
10395: PPUSH
10396: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10400: LD_EXP 32
10404: PPUSH
10405: LD_INT 123
10407: PPUSH
10408: LD_INT 103
10410: PPUSH
10411: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10415: LD_EXP 32
10419: PPUSH
10420: LD_INT 138
10422: PPUSH
10423: LD_INT 108
10425: PPUSH
10426: CALL_OW 171
// AddComHold ( Frank ) ;
10430: LD_EXP 32
10434: PPUSH
10435: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10439: LD_INT 35
10441: PPUSH
10442: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10446: LD_EXP 32
10450: PPUSH
10451: LD_INT 138
10453: PPUSH
10454: LD_INT 108
10456: PPUSH
10457: CALL_OW 307
10461: IFFALSE 10439
// AddComMoveXY ( Frank , 125 , 132 ) ;
10463: LD_EXP 32
10467: PPUSH
10468: LD_INT 125
10470: PPUSH
10471: LD_INT 132
10473: PPUSH
10474: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10478: LD_INT 35
10480: PPUSH
10481: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10485: LD_INT 1
10487: PPUSH
10488: LD_EXP 32
10492: PPUSH
10493: CALL_OW 292
10497: PUSH
10498: LD_EXP 32
10502: PPUSH
10503: LD_INT 7
10505: PPUSH
10506: CALL_OW 296
10510: PUSH
10511: LD_INT 7
10513: LESS
10514: OR
10515: IFFALSE 10478
// DialogueOn ;
10517: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10521: LD_EXP 32
10525: PPUSH
10526: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10537: LD_EXP 20
10541: PPUSH
10542: LD_STRING D4Fa-JMM-1
10544: PPUSH
10545: CALL_OW 88
// for i in points do
10549: LD_ADDR_VAR 0 1
10553: PUSH
10554: LD_VAR 0 2
10558: PUSH
10559: FOR_IN
10560: IFFALSE 10618
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 2
10578: ARRAY
10579: PPUSH
10580: LD_INT 1
10582: PPUSH
10583: LD_INT 20
10585: NEG
10586: PPUSH
10587: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10591: LD_VAR 0 1
10595: PUSH
10596: LD_INT 1
10598: ARRAY
10599: PPUSH
10600: LD_VAR 0 1
10604: PUSH
10605: LD_INT 2
10607: ARRAY
10608: PPUSH
10609: LD_INT 1
10611: PPUSH
10612: CALL_OW 331
// end ;
10616: GO 10559
10618: POP
10619: POP
// dwait ( 0 0$0.5 ) ;
10620: LD_INT 18
10622: PPUSH
10623: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10627: LD_INT 42
10629: PPUSH
10630: LD_INT 27
10632: PPUSH
10633: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10637: LD_EXP 32
10641: PPUSH
10642: LD_STRING D4Fa-Frank-1
10644: PPUSH
10645: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10649: LD_INT 18
10651: PPUSH
10652: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10656: LD_EXP 20
10660: PPUSH
10661: LD_STRING D4Fa-JMM-2
10663: PPUSH
10664: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10668: LD_INT 118
10670: PPUSH
10671: LD_INT 80
10673: PPUSH
10674: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10678: LD_EXP 32
10682: PPUSH
10683: LD_STRING D4Fa-Frank-2
10685: PPUSH
10686: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10690: LD_INT 10
10692: PPUSH
10693: CALL_OW 68
// DialogueOff ;
10697: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10701: LD_EXP 32
10705: PPUSH
10706: LD_INT 1
10708: PPUSH
10709: CALL_OW 235
// end else
10713: GO 10977
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10715: LD_INT 2
10717: PPUSH
10718: LD_INT 4
10720: PPUSH
10721: LD_INT 2
10723: PPUSH
10724: LD_INT 1
10726: PPUSH
10727: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10731: LD_EXP 32
10735: PPUSH
10736: LD_INT 75
10738: PPUSH
10739: LD_INT 63
10741: PPUSH
10742: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10746: LD_EXP 32
10750: PPUSH
10751: LD_INT 175
10753: PPUSH
10754: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10758: LD_EXP 32
10762: PPUSH
10763: LD_INT 102
10765: PPUSH
10766: LD_INT 76
10768: PPUSH
10769: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10773: LD_EXP 32
10777: PPUSH
10778: LD_INT 108
10780: PPUSH
10781: LD_INT 70
10783: PPUSH
10784: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10788: LD_INT 35
10790: PPUSH
10791: CALL_OW 67
// until See ( 2 , Frank ) ;
10795: LD_INT 2
10797: PPUSH
10798: LD_EXP 32
10802: PPUSH
10803: CALL_OW 292
10807: IFFALSE 10788
// ComMoveXY ( Frank , 112 , 118 ) ;
10809: LD_EXP 32
10813: PPUSH
10814: LD_INT 112
10816: PPUSH
10817: LD_INT 118
10819: PPUSH
10820: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10824: LD_EXP 32
10828: PPUSH
10829: CALL_OW 256
10833: PUSH
10834: LD_INT 750
10836: GREATEREQUAL
10837: IFFALSE 10851
// SetLives ( Frank , 700 ) ;
10839: LD_EXP 32
10843: PPUSH
10844: LD_INT 700
10846: PPUSH
10847: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10851: LD_INT 35
10853: PPUSH
10854: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10858: LD_INT 1
10860: PPUSH
10861: LD_EXP 32
10865: PPUSH
10866: CALL_OW 292
10870: PUSH
10871: LD_EXP 32
10875: PPUSH
10876: LD_INT 7
10878: PPUSH
10879: CALL_OW 296
10883: PUSH
10884: LD_INT 17
10886: LESS
10887: OR
10888: IFFALSE 10851
// DialogueOn ;
10890: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10894: LD_EXP 32
10898: PPUSH
10899: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10903: LD_EXP 32
10907: PPUSH
10908: LD_STRING D4Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10915: LD_EXP 20
10919: PPUSH
10920: LD_STRING D4Fb-JMM-1
10922: PPUSH
10923: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10927: LD_INT 2
10929: PPUSH
10930: LD_STRING D4Fb-FSci1-1
10932: PPUSH
10933: CALL 15655 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10937: LD_EXP 32
10941: PPUSH
10942: LD_STRING D4Fb-Frank-2
10944: PPUSH
10945: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10949: LD_EXP 20
10953: PPUSH
10954: LD_STRING D4Fb-JMM-2
10956: PPUSH
10957: CALL_OW 88
// DialogueOff ;
10961: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10965: LD_EXP 32
10969: PPUSH
10970: LD_INT 1
10972: PPUSH
10973: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10977: LD_EXP 33
10981: PPUSH
10982: CALL_OW 302
10986: PUSH
10987: LD_EXP 32
10991: NOT
10992: AND
10993: IFFALSE 11141
// begin DialogueOn ;
10995: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10999: LD_EXP 20
11003: PUSH
11004: LD_EXP 33
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PPUSH
11013: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11017: LD_EXP 33
11021: PPUSH
11022: LD_STRING D3Y-Yam-1
11024: PPUSH
11025: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11029: LD_EXP 20
11033: PPUSH
11034: LD_STRING D3Y-JMM-1
11036: PPUSH
11037: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11041: LD_EXP 33
11045: PPUSH
11046: LD_STRING D3Y-Yam-2
11048: PPUSH
11049: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11053: LD_STRING QYamoko
11055: PPUSH
11056: CALL_OW 97
11060: PUSH
11061: LD_INT 1
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11104
11069: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11070: LD_EXP 20
11074: PPUSH
11075: LD_STRING D3Ya-JMM-1
11077: PPUSH
11078: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11082: LD_EXP 33
11086: PPUSH
11087: LD_STRING D3Ya-Yam-1
11089: PPUSH
11090: CALL_OW 88
// us_scout := 1 ;
11094: LD_ADDR_EXP 8
11098: PUSH
11099: LD_INT 1
11101: ST_TO_ADDR
// end ; 2 :
11102: GO 11137
11104: LD_INT 2
11106: DOUBLE
11107: EQUAL
11108: IFTRUE 11112
11110: GO 11136
11112: POP
// begin us_scout := - 1 ;
11113: LD_ADDR_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11122: LD_EXP 20
11126: PPUSH
11127: LD_STRING D3Yb-JMM-1
11129: PPUSH
11130: CALL_OW 88
// end ; end ;
11134: GO 11137
11136: POP
// DialogueOff ;
11137: CALL_OW 7
// end ; if Frank then
11141: LD_EXP 32
11145: IFFALSE 11149
// exit ;
11147: GO 11910
// if us_scout in [ - 1 , 0 ] then
11149: LD_EXP 8
11153: PUSH
11154: LD_INT 1
11156: NEG
11157: PUSH
11158: LD_INT 0
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: IN
11165: IFFALSE 11169
// exit ;
11167: GO 11910
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11169: LD_ADDR_EXP 8
11173: PUSH
11174: LD_INT 2
11176: PUSH
11177: LD_INT 2
11179: PUSH
11180: LD_INT 1
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: LIST
11187: PUSH
11188: LD_OWVAR 67
11192: ARRAY
11193: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11194: LD_EXP 8
11198: PUSH
11199: LD_INT 1
11201: PUSH
11202: LD_INT 2
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: IN
11209: IFFALSE 11910
// begin if IsInUnit ( Kikuchi ) then
11211: LD_EXP 33
11215: PPUSH
11216: CALL_OW 310
11220: IFFALSE 11231
// ComExitBuilding ( Kikuchi ) ;
11222: LD_EXP 33
11226: PPUSH
11227: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11231: LD_EXP 33
11235: PPUSH
11236: CALL_OW 311
11240: IFFALSE 11251
// ComExitVehicle ( Kikuchi ) ;
11242: LD_EXP 33
11246: PPUSH
11247: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11251: LD_EXP 33
11255: PPUSH
11256: LD_INT 4
11258: PPUSH
11259: CALL_OW 235
// wait ( 0 0$1 ) ;
11263: LD_INT 35
11265: PPUSH
11266: CALL_OW 67
// if us_scout = 2 then
11270: LD_EXP 8
11274: PUSH
11275: LD_INT 2
11277: EQUAL
11278: IFFALSE 11658
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11280: LD_EXP 33
11284: PPUSH
11285: LD_INT 75
11287: PPUSH
11288: LD_INT 63
11290: PPUSH
11291: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11295: LD_EXP 33
11299: PPUSH
11300: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11304: LD_EXP 33
11308: PPUSH
11309: LD_INT 770
11311: PPUSH
11312: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11316: LD_EXP 33
11320: PPUSH
11321: LD_INT 100
11323: PPUSH
11324: LD_INT 75
11326: PPUSH
11327: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11331: LD_EXP 33
11335: PPUSH
11336: LD_INT 123
11338: PPUSH
11339: LD_INT 103
11341: PPUSH
11342: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11346: LD_EXP 33
11350: PPUSH
11351: LD_INT 138
11353: PPUSH
11354: LD_INT 108
11356: PPUSH
11357: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11361: LD_EXP 33
11365: PPUSH
11366: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11370: LD_INT 35
11372: PPUSH
11373: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11377: LD_EXP 33
11381: PPUSH
11382: LD_INT 138
11384: PPUSH
11385: LD_INT 108
11387: PPUSH
11388: CALL_OW 307
11392: IFFALSE 11370
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11394: LD_EXP 33
11398: PPUSH
11399: LD_INT 125
11401: PPUSH
11402: LD_INT 132
11404: PPUSH
11405: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11409: LD_INT 35
11411: PPUSH
11412: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11416: LD_INT 1
11418: PPUSH
11419: LD_EXP 33
11423: PPUSH
11424: CALL_OW 292
11428: PUSH
11429: LD_EXP 33
11433: PPUSH
11434: LD_INT 7
11436: PPUSH
11437: CALL_OW 296
11441: PUSH
11442: LD_INT 7
11444: LESS
11445: OR
11446: IFFALSE 11409
// DialogueOn ;
11448: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11452: LD_EXP 33
11456: PPUSH
11457: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11461: LD_INT 10
11463: PPUSH
11464: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11468: LD_EXP 33
11472: PPUSH
11473: LD_STRING D4Ya-Yam-1
11475: PPUSH
11476: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11480: LD_EXP 20
11484: PPUSH
11485: LD_STRING D4Ya-JMM-1
11487: PPUSH
11488: CALL_OW 88
// for i in points do
11492: LD_ADDR_VAR 0 1
11496: PUSH
11497: LD_VAR 0 2
11501: PUSH
11502: FOR_IN
11503: IFFALSE 11561
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11505: LD_VAR 0 1
11509: PUSH
11510: LD_INT 1
11512: ARRAY
11513: PPUSH
11514: LD_VAR 0 1
11518: PUSH
11519: LD_INT 2
11521: ARRAY
11522: PPUSH
11523: LD_INT 1
11525: PPUSH
11526: LD_INT 20
11528: NEG
11529: PPUSH
11530: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 1
11541: ARRAY
11542: PPUSH
11543: LD_VAR 0 1
11547: PUSH
11548: LD_INT 2
11550: ARRAY
11551: PPUSH
11552: LD_INT 1
11554: PPUSH
11555: CALL_OW 331
// end ;
11559: GO 11502
11561: POP
11562: POP
// dwait ( 0 0$0.5 ) ;
11563: LD_INT 18
11565: PPUSH
11566: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11570: LD_INT 42
11572: PPUSH
11573: LD_INT 27
11575: PPUSH
11576: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11580: LD_EXP 33
11584: PPUSH
11585: LD_STRING D4Ya-Yam-2
11587: PPUSH
11588: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11592: LD_INT 18
11594: PPUSH
11595: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11599: LD_INT 118
11601: PPUSH
11602: LD_INT 80
11604: PPUSH
11605: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11609: LD_EXP 20
11613: PPUSH
11614: LD_STRING D4Ya-JMM-2
11616: PPUSH
11617: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11621: LD_EXP 33
11625: PPUSH
11626: LD_STRING D4Ya-Yam-3
11628: PPUSH
11629: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11633: LD_INT 10
11635: PPUSH
11636: CALL_OW 68
// DialogueOff ;
11640: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 1
11651: PPUSH
11652: CALL_OW 235
// end else
11656: GO 11910
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11658: LD_INT 2
11660: PPUSH
11661: LD_INT 4
11663: PPUSH
11664: LD_INT 2
11666: PPUSH
11667: LD_INT 1
11669: PPUSH
11670: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 75
11681: PPUSH
11682: LD_INT 63
11684: PPUSH
11685: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 175
11696: PPUSH
11697: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11701: LD_EXP 33
11705: PPUSH
11706: LD_INT 102
11708: PPUSH
11709: LD_INT 76
11711: PPUSH
11712: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11716: LD_EXP 33
11720: PPUSH
11721: LD_INT 108
11723: PPUSH
11724: LD_INT 70
11726: PPUSH
11727: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11731: LD_INT 35
11733: PPUSH
11734: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11738: LD_INT 2
11740: PPUSH
11741: LD_EXP 33
11745: PPUSH
11746: CALL_OW 292
11750: IFFALSE 11731
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11752: LD_EXP 33
11756: PPUSH
11757: LD_INT 112
11759: PPUSH
11760: LD_INT 118
11762: PPUSH
11763: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11767: LD_EXP 33
11771: PPUSH
11772: CALL_OW 256
11776: PUSH
11777: LD_INT 750
11779: GREATEREQUAL
11780: IFFALSE 11794
// SetLives ( Kikuchi , 700 ) ;
11782: LD_EXP 33
11786: PPUSH
11787: LD_INT 700
11789: PPUSH
11790: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11794: LD_INT 35
11796: PPUSH
11797: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11801: LD_INT 1
11803: PPUSH
11804: LD_EXP 33
11808: PPUSH
11809: CALL_OW 292
11813: PUSH
11814: LD_EXP 33
11818: PPUSH
11819: LD_INT 7
11821: PPUSH
11822: CALL_OW 296
11826: PUSH
11827: LD_INT 17
11829: LESS
11830: OR
11831: IFFALSE 11794
// DialogueOn ;
11833: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11837: LD_EXP 33
11841: PPUSH
11842: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11846: LD_EXP 33
11850: PPUSH
11851: LD_STRING D4Yb-Yam-1
11853: PPUSH
11854: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11858: LD_EXP 20
11862: PPUSH
11863: LD_STRING D4Yb-JMM-1
11865: PPUSH
11866: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11870: LD_EXP 33
11874: PPUSH
11875: LD_STRING D4Yb-Yam-2
11877: PPUSH
11878: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11882: LD_EXP 20
11886: PPUSH
11887: LD_STRING D4Yb-JMM-2
11889: PPUSH
11890: CALL_OW 88
// DialogueOff ;
11894: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 1
11905: PPUSH
11906: CALL_OW 235
// end ; end ; end ;
11910: PPOPN 2
11912: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11913: LD_EXP 6
11917: IFFALSE 12950
11919: GO 11921
11921: DISABLE
11922: LD_INT 0
11924: PPUSH
11925: PPUSH
11926: PPUSH
11927: PPUSH
// begin enable ;
11928: ENABLE
// if not seen [ 1 ] then
11929: LD_EXP 9
11933: PUSH
11934: LD_INT 1
11936: ARRAY
11937: NOT
11938: IFFALSE 12118
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11940: LD_ADDR_VAR 0 2
11944: PUSH
11945: LD_INT 22
11947: PUSH
11948: LD_INT 2
11950: PUSH
11951: EMPTY
11952: LIST
11953: LIST
11954: PUSH
11955: LD_INT 2
11957: PUSH
11958: LD_INT 25
11960: PUSH
11961: LD_INT 11
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 33
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: LIST
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PPUSH
11987: CALL_OW 69
11991: ST_TO_ADDR
// if tmp then
11992: LD_VAR 0 2
11996: IFFALSE 12118
// for i in tmp do
11998: LD_ADDR_VAR 0 1
12002: PUSH
12003: LD_VAR 0 2
12007: PUSH
12008: FOR_IN
12009: IFFALSE 12116
// if See ( 1 , i ) then
12011: LD_INT 1
12013: PPUSH
12014: LD_VAR 0 1
12018: PPUSH
12019: CALL_OW 292
12023: IFFALSE 12114
// begin seen := Replace ( seen , 1 , true ) ;
12025: LD_ADDR_EXP 9
12029: PUSH
12030: LD_EXP 9
12034: PPUSH
12035: LD_INT 1
12037: PPUSH
12038: LD_INT 1
12040: PPUSH
12041: CALL_OW 1
12045: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12046: LD_INT 1
12048: PPUSH
12049: CALL 15477 0 1
12053: IFFALSE 12114
// begin DialogueOn ;
12055: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12059: LD_VAR 0 1
12063: PPUSH
12064: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12068: LD_INT 10
12070: PPUSH
12071: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12075: LD_ADDR_VAR 0 3
12079: PUSH
12080: LD_INT 1
12082: PPUSH
12083: LD_STRING D5a-Sol2-1
12085: PPUSH
12086: CALL 15655 0 2
12090: ST_TO_ADDR
// if not un then
12091: LD_VAR 0 3
12095: NOT
12096: IFFALSE 12108
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12098: LD_INT 2
12100: PPUSH
12101: LD_STRING D5a-FSol2-1
12103: PPUSH
12104: CALL 15655 0 2
// DialogueOff ;
12108: CALL_OW 7
// break ;
12112: GO 12116
// end ; end ;
12114: GO 12008
12116: POP
12117: POP
// end ; if not seen [ 2 ] then
12118: LD_EXP 9
12122: PUSH
12123: LD_INT 2
12125: ARRAY
12126: NOT
12127: IFFALSE 12352
// begin can_kamikazed := true ;
12129: LD_ADDR_EXP 10
12133: PUSH
12134: LD_INT 1
12136: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12137: LD_ADDR_VAR 0 2
12141: PUSH
12142: LD_INT 22
12144: PUSH
12145: LD_INT 2
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: PUSH
12152: LD_INT 25
12154: PUSH
12155: LD_INT 17
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PPUSH
12166: CALL_OW 69
12170: ST_TO_ADDR
// if tmp then
12171: LD_VAR 0 2
12175: IFFALSE 12352
// for i in tmp do
12177: LD_ADDR_VAR 0 1
12181: PUSH
12182: LD_VAR 0 2
12186: PUSH
12187: FOR_IN
12188: IFFALSE 12350
// if See ( 1 , i ) then
12190: LD_INT 1
12192: PPUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 292
12202: IFFALSE 12348
// begin seen := Replace ( seen , 2 , true ) ;
12204: LD_ADDR_EXP 9
12208: PUSH
12209: LD_EXP 9
12213: PPUSH
12214: LD_INT 2
12216: PPUSH
12217: LD_INT 1
12219: PPUSH
12220: CALL_OW 1
12224: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12225: LD_INT 1
12227: PPUSH
12228: CALL 15477 0 1
12232: IFFALSE 12348
// begin DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12238: LD_VAR 0 1
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12254: LD_ADDR_VAR 0 3
12258: PUSH
12259: LD_INT 1
12261: PPUSH
12262: LD_STRING D5b-Sol1-1
12264: PPUSH
12265: CALL 15655 0 2
12269: ST_TO_ADDR
// if not un then
12270: LD_VAR 0 3
12274: NOT
12275: IFFALSE 12293
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12277: LD_ADDR_VAR 0 3
12281: PUSH
12282: LD_INT 2
12284: PPUSH
12285: LD_STRING D5b-FSol1-1
12287: PPUSH
12288: CALL 15655 0 2
12292: ST_TO_ADDR
// if un then
12293: LD_VAR 0 3
12297: IFFALSE 12342
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12299: LD_ADDR_VAR 0 4
12303: PUSH
12304: LD_INT 1
12306: PPUSH
12307: LD_STRING D5b-Sol2-1
12309: PPUSH
12310: LD_VAR 0 3
12314: PPUSH
12315: CALL 15881 0 3
12319: ST_TO_ADDR
// if not un2 then
12320: LD_VAR 0 4
12324: NOT
12325: IFFALSE 12342
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12327: LD_INT 2
12329: PPUSH
12330: LD_STRING D5b-FSol2-1
12332: PPUSH
12333: LD_VAR 0 3
12337: PPUSH
12338: CALL 15881 0 3
// end ; DialogueOff ;
12342: CALL_OW 7
// break ;
12346: GO 12350
// end ; end ;
12348: GO 12187
12350: POP
12351: POP
// end ; if not seen [ 3 ] then
12352: LD_EXP 9
12356: PUSH
12357: LD_INT 3
12359: ARRAY
12360: NOT
12361: IFFALSE 12535
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12363: LD_ADDR_VAR 0 2
12367: PUSH
12368: LD_INT 22
12370: PUSH
12371: LD_INT 2
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 33
12380: PUSH
12381: LD_INT 2
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PPUSH
12392: CALL_OW 69
12396: ST_TO_ADDR
// if tmp then
12397: LD_VAR 0 2
12401: IFFALSE 12535
// for i in tmp do
12403: LD_ADDR_VAR 0 1
12407: PUSH
12408: LD_VAR 0 2
12412: PUSH
12413: FOR_IN
12414: IFFALSE 12533
// if See ( 1 , i ) then
12416: LD_INT 1
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 292
12428: IFFALSE 12531
// begin seen := Replace ( seen , 3 , true ) ;
12430: LD_ADDR_EXP 9
12434: PUSH
12435: LD_EXP 9
12439: PPUSH
12440: LD_INT 3
12442: PPUSH
12443: LD_INT 1
12445: PPUSH
12446: CALL_OW 1
12450: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12451: LD_INT 1
12453: PPUSH
12454: CALL 15477 0 1
12458: IFFALSE 12531
// begin DialogueOn ;
12460: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12464: LD_VAR 0 1
12468: PPUSH
12469: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12473: LD_INT 10
12475: PPUSH
12476: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12480: LD_ADDR_VAR 0 3
12484: PUSH
12485: LD_INT 1
12487: PPUSH
12488: LD_STRING D8-Sol1-1
12490: PPUSH
12491: CALL 15655 0 2
12495: ST_TO_ADDR
// if not un then
12496: LD_VAR 0 3
12500: NOT
12501: IFFALSE 12513
// SayRand ( sex_female , D8-FSol1-1 ) ;
12503: LD_INT 2
12505: PPUSH
12506: LD_STRING D8-FSol1-1
12508: PPUSH
12509: CALL 15655 0 2
// Say ( JMM , D8-JMM-1 ) ;
12513: LD_EXP 20
12517: PPUSH
12518: LD_STRING D8-JMM-1
12520: PPUSH
12521: CALL_OW 88
// DialogueOff ;
12525: CALL_OW 7
// break ;
12529: GO 12533
// end ; end ;
12531: GO 12413
12533: POP
12534: POP
// end ; if not seen [ 4 ] then
12535: LD_EXP 9
12539: PUSH
12540: LD_INT 4
12542: ARRAY
12543: NOT
12544: IFFALSE 12706
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12546: LD_ADDR_VAR 0 2
12550: PUSH
12551: LD_INT 22
12553: PUSH
12554: LD_INT 2
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 33
12563: PUSH
12564: LD_INT 5
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PPUSH
12575: CALL_OW 69
12579: ST_TO_ADDR
// if tmp then
12580: LD_VAR 0 2
12584: IFFALSE 12706
// for i in tmp do
12586: LD_ADDR_VAR 0 1
12590: PUSH
12591: LD_VAR 0 2
12595: PUSH
12596: FOR_IN
12597: IFFALSE 12704
// if See ( 1 , i ) then
12599: LD_INT 1
12601: PPUSH
12602: LD_VAR 0 1
12606: PPUSH
12607: CALL_OW 292
12611: IFFALSE 12702
// begin seen := Replace ( seen , 4 , true ) ;
12613: LD_ADDR_EXP 9
12617: PUSH
12618: LD_EXP 9
12622: PPUSH
12623: LD_INT 4
12625: PPUSH
12626: LD_INT 1
12628: PPUSH
12629: CALL_OW 1
12633: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12634: LD_INT 1
12636: PPUSH
12637: CALL 15477 0 1
12641: IFFALSE 12702
// begin DialogueOn ;
12643: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12656: LD_INT 10
12658: PPUSH
12659: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12663: LD_ADDR_VAR 0 3
12667: PUSH
12668: LD_INT 1
12670: PPUSH
12671: LD_STRING D5a-Sol1-1
12673: PPUSH
12674: CALL 15655 0 2
12678: ST_TO_ADDR
// if not un then
12679: LD_VAR 0 3
12683: NOT
12684: IFFALSE 12696
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12686: LD_INT 2
12688: PPUSH
12689: LD_STRING D5a-FSol1-1
12691: PPUSH
12692: CALL 15655 0 2
// DialogueOff ;
12696: CALL_OW 7
// break ;
12700: GO 12704
// end ; end ;
12702: GO 12596
12704: POP
12705: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12706: LD_EXP 9
12710: PUSH
12711: LD_INT 5
12713: ARRAY
12714: NOT
12715: PUSH
12716: LD_EXP 9
12720: PUSH
12721: LD_INT 3
12723: ARRAY
12724: AND
12725: IFFALSE 12899
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12727: LD_ADDR_VAR 0 2
12731: PUSH
12732: LD_INT 22
12734: PUSH
12735: LD_INT 2
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 34
12744: PUSH
12745: LD_INT 31
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: PPUSH
12756: CALL_OW 69
12760: ST_TO_ADDR
// if tmp then
12761: LD_VAR 0 2
12765: IFFALSE 12899
// for i in tmp do
12767: LD_ADDR_VAR 0 1
12771: PUSH
12772: LD_VAR 0 2
12776: PUSH
12777: FOR_IN
12778: IFFALSE 12897
// if See ( 1 , i ) then
12780: LD_INT 1
12782: PPUSH
12783: LD_VAR 0 1
12787: PPUSH
12788: CALL_OW 292
12792: IFFALSE 12895
// begin seen := Replace ( seen , 5 , true ) ;
12794: LD_ADDR_EXP 9
12798: PUSH
12799: LD_EXP 9
12803: PPUSH
12804: LD_INT 5
12806: PPUSH
12807: LD_INT 1
12809: PPUSH
12810: CALL_OW 1
12814: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12815: LD_INT 1
12817: PPUSH
12818: CALL 15477 0 1
12822: IFFALSE 12895
// begin DialogueOn ;
12824: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12828: LD_VAR 0 1
12832: PPUSH
12833: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12837: LD_INT 10
12839: PPUSH
12840: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12844: LD_ADDR_VAR 0 3
12848: PUSH
12849: LD_INT 1
12851: PPUSH
12852: LD_STRING D8a-Sol2-1
12854: PPUSH
12855: CALL 15655 0 2
12859: ST_TO_ADDR
// if not un then
12860: LD_VAR 0 3
12864: NOT
12865: IFFALSE 12877
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12867: LD_INT 2
12869: PPUSH
12870: LD_STRING D8a-FSol2-1
12872: PPUSH
12873: CALL 15655 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12877: LD_EXP 20
12881: PPUSH
12882: LD_STRING D8a-JMM-1
12884: PPUSH
12885: CALL_OW 88
// DialogueOff ;
12889: CALL_OW 7
// break ;
12893: GO 12897
// end ; end ;
12895: GO 12777
12897: POP
12898: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12899: LD_EXP 9
12903: PUSH
12904: LD_INT 1
12906: ARRAY
12907: PUSH
12908: LD_EXP 9
12912: PUSH
12913: LD_INT 2
12915: ARRAY
12916: AND
12917: PUSH
12918: LD_EXP 9
12922: PUSH
12923: LD_INT 3
12925: ARRAY
12926: AND
12927: PUSH
12928: LD_EXP 9
12932: PUSH
12933: LD_INT 4
12935: ARRAY
12936: AND
12937: PUSH
12938: LD_EXP 9
12942: PUSH
12943: LD_INT 5
12945: ARRAY
12946: AND
12947: IFFALSE 12950
// disable ;
12949: DISABLE
// end ;
12950: PPOPN 4
12952: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12953: LD_EXP 10
12957: PUSH
12958: LD_EXP 11
12962: AND
12963: IFFALSE 13161
12965: GO 12967
12967: DISABLE
12968: LD_INT 0
12970: PPUSH
// begin DialogueOn ;
12971: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12975: LD_EXP 11
12979: PPUSH
12980: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12984: LD_ADDR_VAR 0 1
12988: PUSH
12989: LD_INT 1
12991: PPUSH
12992: LD_STRING D5c-Sol1-1
12994: PPUSH
12995: CALL 15655 0 2
12999: ST_TO_ADDR
// if not un then
13000: LD_VAR 0 1
13004: NOT
13005: IFFALSE 13023
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13007: LD_ADDR_VAR 0 1
13011: PUSH
13012: LD_INT 2
13014: PPUSH
13015: LD_STRING D5c-FSol1-1
13017: PPUSH
13018: CALL 15655 0 2
13022: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13023: LD_EXP 20
13027: PPUSH
13028: LD_STRING D5c-JMM-1
13030: PPUSH
13031: CALL_OW 88
// if IsOk ( Lisa ) then
13035: LD_EXP 21
13039: PPUSH
13040: CALL_OW 302
13044: IFFALSE 13060
// Say ( Lisa , D5d-Lisa-1 ) else
13046: LD_EXP 21
13050: PPUSH
13051: LD_STRING D5d-Lisa-1
13053: PPUSH
13054: CALL_OW 88
13058: GO 13145
// if IsOk ( Cyrus ) then
13060: LD_EXP 24
13064: PPUSH
13065: CALL_OW 302
13069: IFFALSE 13085
// Say ( Cyrus , D5d-Cyrus-1 ) else
13071: LD_EXP 24
13075: PPUSH
13076: LD_STRING D5d-Cyrus-1
13078: PPUSH
13079: CALL_OW 88
13083: GO 13145
// if IsOk ( Gary ) then
13085: LD_EXP 31
13089: PPUSH
13090: CALL_OW 302
13094: IFFALSE 13110
// Say ( Gary , D5d-Gary-1 ) else
13096: LD_EXP 31
13100: PPUSH
13101: LD_STRING D5d-Gary-1
13103: PPUSH
13104: CALL_OW 88
13108: GO 13145
// if GetSex ( un ) = sex_male then
13110: LD_VAR 0 1
13114: PPUSH
13115: CALL_OW 258
13119: PUSH
13120: LD_INT 1
13122: EQUAL
13123: IFFALSE 13139
// Say ( un , D5d-Sol1-1 ) else
13125: LD_VAR 0 1
13129: PPUSH
13130: LD_STRING D5d-Sol1-1
13132: PPUSH
13133: CALL_OW 88
13137: GO 13145
// begin DialogueOff ;
13139: CALL_OW 7
// exit ;
13143: GO 13161
// end ; Say ( JMM , D5d-JMM-1 ) ;
13145: LD_EXP 20
13149: PPUSH
13150: LD_STRING D5d-JMM-1
13152: PPUSH
13153: CALL_OW 88
// DialogueOff ;
13157: CALL_OW 7
// end ;
13161: PPOPN 1
13163: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13164: LD_INT 1
13166: PPUSH
13167: LD_INT 17
13169: PPUSH
13170: CALL_OW 294
13174: PUSH
13175: LD_INT 2
13177: GREATEREQUAL
13178: IFFALSE 13299
13180: GO 13182
13182: DISABLE
13183: LD_INT 0
13185: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13186: LD_INT 10
13188: PPUSH
13189: LD_INT 5
13191: PPUSH
13192: LD_INT 1
13194: PPUSH
13195: LD_INT 10
13197: NEG
13198: PPUSH
13199: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13203: LD_INT 10
13205: PPUSH
13206: LD_INT 5
13208: PPUSH
13209: LD_INT 1
13211: PPUSH
13212: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13216: LD_INT 10
13218: PPUSH
13219: LD_INT 5
13221: PPUSH
13222: CALL_OW 86
// DialogueOn ;
13226: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13230: LD_ADDR_VAR 0 1
13234: PUSH
13235: LD_INT 1
13237: PPUSH
13238: LD_STRING D6-Sci1-1
13240: PPUSH
13241: CALL 15655 0 2
13245: ST_TO_ADDR
// if un then
13246: LD_VAR 0 1
13250: IFFALSE 13288
// begin Say ( JMM , D6-JMM-1 ) ;
13252: LD_EXP 20
13256: PPUSH
13257: LD_STRING D6-JMM-1
13259: PPUSH
13260: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13264: LD_VAR 0 1
13268: PPUSH
13269: LD_STRING D6-Sci1-2
13271: PPUSH
13272: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13276: LD_EXP 20
13280: PPUSH
13281: LD_STRING D6-JMM-2
13283: PPUSH
13284: CALL_OW 88
// end ; DialogueOff ;
13288: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13292: LD_STRING M3
13294: PPUSH
13295: CALL_OW 337
// end ;
13299: PPOPN 1
13301: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13302: LD_OWVAR 1
13306: PUSH
13307: LD_INT 42000
13309: GREATEREQUAL
13310: PUSH
13311: LD_INT 2
13313: PPUSH
13314: LD_INT 169
13316: PPUSH
13317: LD_INT 90
13319: PPUSH
13320: LD_INT 10
13322: PPUSH
13323: CALL 55004 0 4
13327: PUSH
13328: LD_INT 4
13330: ARRAY
13331: PUSH
13332: LD_INT 0
13334: EQUAL
13335: PUSH
13336: LD_INT 45
13338: PPUSH
13339: CALL_OW 301
13343: OR
13344: PUSH
13345: LD_INT 45
13347: PPUSH
13348: CALL_OW 255
13352: PUSH
13353: LD_INT 1
13355: EQUAL
13356: OR
13357: AND
13358: PUSH
13359: LD_INT 94
13361: PPUSH
13362: CALL_OW 301
13366: NOT
13367: AND
13368: IFFALSE 14494
13370: GO 13372
13372: DISABLE
13373: LD_INT 0
13375: PPUSH
13376: PPUSH
13377: PPUSH
13378: PPUSH
// begin uc_side := 5 ;
13379: LD_ADDR_OWVAR 20
13383: PUSH
13384: LD_INT 5
13386: ST_TO_ADDR
// uc_nation := 2 ;
13387: LD_ADDR_OWVAR 21
13391: PUSH
13392: LD_INT 2
13394: ST_TO_ADDR
// InitHc ;
13395: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13399: LD_INT 1
13401: PPUSH
13402: LD_INT 3
13404: PPUSH
13405: LD_INT 8
13407: PPUSH
13408: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13412: LD_ADDR_OWVAR 29
13416: PUSH
13417: LD_INT 12
13419: PUSH
13420: LD_INT 12
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13427: LD_ADDR_OWVAR 33
13431: PUSH
13432: LD_STRING SecondCharsGal
13434: ST_TO_ADDR
// hc_face_number := 7 ;
13435: LD_ADDR_OWVAR 34
13439: PUSH
13440: LD_INT 7
13442: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13443: LD_ADDR_EXP 45
13447: PUSH
13448: CALL_OW 44
13452: ST_TO_ADDR
// InitHc ;
13453: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13457: LD_INT 1
13459: PPUSH
13460: LD_INT 16
13462: PPUSH
13463: LD_INT 2
13465: PPUSH
13466: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13470: LD_ADDR_OWVAR 29
13474: PUSH
13475: LD_INT 12
13477: PUSH
13478: LD_INT 12
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: ST_TO_ADDR
// hc_name :=  ;
13485: LD_ADDR_OWVAR 26
13489: PUSH
13490: LD_STRING 
13492: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13493: LD_ADDR_EXP 46
13497: PUSH
13498: CALL_OW 44
13502: ST_TO_ADDR
// InitHc ;
13503: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13507: LD_INT 35
13509: PPUSH
13510: CALL_OW 67
// until not InBattle ( 1 ) ;
13514: LD_INT 1
13516: PPUSH
13517: CALL_OW 463
13521: NOT
13522: IFFALSE 13507
// wait ( 0 0$5 ) ;
13524: LD_INT 175
13526: PPUSH
13527: CALL_OW 67
// DialogueOn ;
13531: CALL_OW 6
// InGameOn ;
13535: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13539: LD_ADDR_VAR 0 1
13543: PUSH
13544: LD_INT 22
13546: PUSH
13547: LD_INT 1
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PUSH
13554: LD_INT 2
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 1
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 25
13569: PUSH
13570: LD_INT 2
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 25
13579: PUSH
13580: LD_INT 3
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 25
13589: PUSH
13590: LD_INT 4
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 25
13599: PUSH
13600: LD_INT 5
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: LD_INT 25
13609: PUSH
13610: LD_INT 8
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: PUSH
13635: LD_EXP 20
13639: PUSH
13640: LD_EXP 21
13644: PUSH
13645: LD_EXP 22
13649: PUSH
13650: LD_EXP 23
13654: PUSH
13655: LD_EXP 24
13659: PUSH
13660: LD_EXP 25
13664: PUSH
13665: LD_EXP 26
13669: PUSH
13670: LD_EXP 27
13674: PUSH
13675: LD_EXP 28
13679: PUSH
13680: LD_EXP 30
13684: PUSH
13685: LD_EXP 31
13689: PUSH
13690: LD_EXP 32
13694: PUSH
13695: LD_EXP 33
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: DIFF
13715: PPUSH
13716: LD_INT 26
13718: PUSH
13719: LD_INT 1
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 72
13730: PUSH
13731: LD_INT 1
13733: ARRAY
13734: ST_TO_ADDR
// if not un and Brown then
13735: LD_VAR 0 1
13739: NOT
13740: PUSH
13741: LD_EXP 26
13745: AND
13746: IFFALSE 13758
// un := Brown ;
13748: LD_ADDR_VAR 0 1
13752: PUSH
13753: LD_EXP 26
13757: ST_TO_ADDR
// if un then
13758: LD_VAR 0 1
13762: IFFALSE 13788
// begin Say ( un , D7-Sol1-1 ) ;
13764: LD_VAR 0 1
13768: PPUSH
13769: LD_STRING D7-Sol1-1
13771: PPUSH
13772: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13776: LD_EXP 20
13780: PPUSH
13781: LD_STRING D7-JMM-1
13783: PPUSH
13784: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13788: LD_EXP 45
13792: PPUSH
13793: LD_STRING D7-Ar1-1
13795: PPUSH
13796: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13800: LD_EXP 20
13804: PPUSH
13805: LD_STRING D7-JMM-2
13807: PPUSH
13808: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13812: LD_EXP 45
13816: PPUSH
13817: LD_STRING D7-Ar1-2
13819: PPUSH
13820: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13824: LD_EXP 20
13828: PPUSH
13829: LD_STRING D7-JMM-3
13831: PPUSH
13832: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13836: LD_EXP 45
13840: PPUSH
13841: LD_STRING D7-Ar1-3
13843: PPUSH
13844: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13848: LD_EXP 20
13852: PPUSH
13853: LD_STRING D7-JMM-4
13855: PPUSH
13856: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13860: LD_EXP 45
13864: PPUSH
13865: LD_STRING D7-Ar1-4
13867: PPUSH
13868: CALL_OW 94
// InGameOff ;
13872: CALL_OW 9
// DialogueOff ;
13876: CALL_OW 7
// case Query ( QCameras ) of 1 :
13880: LD_STRING QCameras
13882: PPUSH
13883: CALL_OW 97
13887: PUSH
13888: LD_INT 1
13890: DOUBLE
13891: EQUAL
13892: IFTRUE 13896
13894: GO 13899
13896: POP
// ; 2 :
13897: GO 13913
13899: LD_INT 2
13901: DOUBLE
13902: EQUAL
13903: IFTRUE 13907
13905: GO 13912
13907: POP
// exit ; end ;
13908: GO 14494
13910: GO 13913
13912: POP
// ChangeMissionObjectives ( MCar ) ;
13913: LD_STRING MCar
13915: PPUSH
13916: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13920: LD_INT 124
13922: PPUSH
13923: LD_INT 90
13925: PPUSH
13926: LD_INT 1
13928: PPUSH
13929: LD_INT 6
13931: NEG
13932: PPUSH
13933: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13937: LD_INT 124
13939: PPUSH
13940: LD_INT 90
13942: PPUSH
13943: LD_INT 1
13945: PPUSH
13946: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13950: LD_INT 12
13952: PPUSH
13953: LD_INT 1
13955: PPUSH
13956: CALL_OW 424
// wait ( 3 ) ;
13960: LD_INT 3
13962: PPUSH
13963: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13967: LD_INT 124
13969: PPUSH
13970: LD_INT 90
13972: PPUSH
13973: CALL_OW 86
// cargo := false ;
13977: LD_ADDR_VAR 0 3
13981: PUSH
13982: LD_INT 0
13984: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13985: LD_INT 35
13987: PPUSH
13988: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13992: LD_ADDR_VAR 0 3
13996: PUSH
13997: LD_INT 12
13999: PPUSH
14000: LD_INT 32
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 34
14012: PUSH
14013: LD_INT 32
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: LD_INT 58
14022: PUSH
14023: EMPTY
14024: LIST
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: PPUSH
14031: CALL_OW 70
14035: ST_TO_ADDR
// until cargo ;
14036: LD_VAR 0 3
14040: IFFALSE 13985
// cargo := cargo [ 1 ] ;
14042: LD_ADDR_VAR 0 3
14046: PUSH
14047: LD_VAR 0 3
14051: PUSH
14052: LD_INT 1
14054: ARRAY
14055: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14056: LD_VAR 0 3
14060: PPUSH
14061: LD_INT 5
14063: PPUSH
14064: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14068: LD_INT 12
14070: PPUSH
14071: LD_INT 0
14073: PPUSH
14074: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14078: LD_EXP 45
14082: PPUSH
14083: LD_INT 11
14085: PPUSH
14086: LD_INT 0
14088: PPUSH
14089: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14093: LD_EXP 46
14097: PPUSH
14098: LD_INT 11
14100: PPUSH
14101: LD_INT 0
14103: PPUSH
14104: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14108: LD_EXP 45
14112: PUSH
14113: LD_EXP 46
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PPUSH
14122: LD_INT 12
14124: PPUSH
14125: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14129: LD_EXP 45
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14143: LD_EXP 45
14147: PUSH
14148: LD_EXP 46
14152: PUSH
14153: EMPTY
14154: LIST
14155: LIST
14156: PPUSH
14157: LD_INT 209
14159: PPUSH
14160: LD_INT 178
14162: PPUSH
14163: CALL_OW 171
// while ( true ) do
14167: LD_INT 1
14169: IFFALSE 14323
// begin wait ( 0 0$1 ) ;
14171: LD_INT 35
14173: PPUSH
14174: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14178: LD_EXP 45
14182: PPUSH
14183: CALL_OW 314
14187: NOT
14188: PUSH
14189: LD_EXP 46
14193: PPUSH
14194: CALL_OW 314
14198: NOT
14199: OR
14200: IFFALSE 14226
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14202: LD_EXP 45
14206: PUSH
14207: LD_EXP 46
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: PPUSH
14216: LD_INT 209
14218: PPUSH
14219: LD_INT 178
14221: PPUSH
14222: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14226: LD_EXP 45
14230: PPUSH
14231: LD_INT 10
14233: PPUSH
14234: CALL_OW 308
14238: IFFALSE 14249
// RemoveUnit ( ar_mechanic ) ;
14240: LD_EXP 45
14244: PPUSH
14245: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14249: LD_EXP 46
14253: PPUSH
14254: LD_INT 10
14256: PPUSH
14257: CALL_OW 308
14261: IFFALSE 14272
// RemoveUnit ( ar_mechanic_friend ) ;
14263: LD_EXP 46
14267: PPUSH
14268: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14272: LD_VAR 0 3
14276: PPUSH
14277: LD_INT 10
14279: PPUSH
14280: CALL_OW 308
14284: IFFALSE 14295
// RemoveUnit ( cargo ) ;
14286: LD_VAR 0 3
14290: PPUSH
14291: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14295: LD_EXP 45
14299: PPUSH
14300: CALL_OW 300
14304: NOT
14305: PUSH
14306: LD_EXP 46
14310: PPUSH
14311: CALL_OW 300
14315: NOT
14316: AND
14317: IFFALSE 14321
// break ;
14319: GO 14323
// end ;
14321: GO 14167
// wait ( 0 0$2 ) ;
14323: LD_INT 70
14325: PPUSH
14326: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14330: LD_EXP 45
14334: PPUSH
14335: LD_STRING D7a-Ar1-1
14337: PPUSH
14338: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14342: LD_ADDR_VAR 0 4
14346: PUSH
14347: LD_INT 129
14349: PUSH
14350: LD_INT 10
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: PUSH
14357: LD_INT 103
14359: PUSH
14360: LD_INT 6
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: LD_INT 148
14369: PUSH
14370: LD_INT 47
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 155
14379: PUSH
14380: LD_INT 16
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: ST_TO_ADDR
// if Difficulty = 1 then
14393: LD_OWVAR 67
14397: PUSH
14398: LD_INT 1
14400: EQUAL
14401: IFFALSE 14438
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14403: LD_ADDR_VAR 0 4
14407: PUSH
14408: LD_VAR 0 4
14412: PUSH
14413: LD_INT 78
14415: PUSH
14416: LD_INT 7
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 104
14425: PUSH
14426: LD_INT 43
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: ADD
14437: ST_TO_ADDR
// for i in tmp do
14438: LD_ADDR_VAR 0 2
14442: PUSH
14443: LD_VAR 0 4
14447: PUSH
14448: FOR_IN
14449: IFFALSE 14482
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14451: LD_VAR 0 2
14455: PUSH
14456: LD_INT 1
14458: ARRAY
14459: PPUSH
14460: LD_VAR 0 2
14464: PUSH
14465: LD_INT 2
14467: ARRAY
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 9
14474: NEG
14475: PPUSH
14476: CALL_OW 330
14480: GO 14448
14482: POP
14483: POP
// CenterOnXY ( 129 , 10 ) ;
14484: LD_INT 129
14486: PPUSH
14487: LD_INT 10
14489: PPUSH
14490: CALL_OW 84
// end ;
14494: PPOPN 4
14496: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14497: LD_EXP 15
14501: PUSH
14502: LD_INT 21000
14504: MINUS
14505: PUSH
14506: LD_OWVAR 1
14510: LESSEQUAL
14511: IFFALSE 14551
14513: GO 14515
14515: DISABLE
// begin powell_warn := true ;
14516: LD_ADDR_EXP 16
14520: PUSH
14521: LD_INT 1
14523: ST_TO_ADDR
// DialogueOn ;
14524: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14528: LD_EXP 29
14532: PPUSH
14533: LD_STRING D9-Pow-1
14535: PPUSH
14536: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14540: LD_INT 10
14542: PPUSH
14543: CALL_OW 68
// DialogueOff ;
14547: CALL_OW 7
// end ;
14551: END
// every 0 0$1 trigger game_time <= tick do
14552: LD_EXP 15
14556: PUSH
14557: LD_OWVAR 1
14561: LESSEQUAL
14562: IFFALSE 14601
14564: GO 14566
14566: DISABLE
// begin DialogueOn ;
14567: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14571: LD_EXP 29
14575: PPUSH
14576: LD_STRING D9a-Pow-1
14578: PPUSH
14579: CALL_OW 94
// dwait ( 0 0$2 ) ;
14583: LD_INT 70
14585: PPUSH
14586: CALL_OW 68
// DialogueOff ;
14590: CALL_OW 7
// YouLost ( Command ) ;
14594: LD_STRING Command
14596: PPUSH
14597: CALL_OW 104
// end ;
14601: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14602: LD_INT 22
14604: PUSH
14605: LD_INT 2
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: PUSH
14612: LD_INT 30
14614: PUSH
14615: LD_INT 1
14617: PUSH
14618: EMPTY
14619: LIST
14620: LIST
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PPUSH
14626: CALL_OW 69
14630: PUSH
14631: LD_INT 0
14633: EQUAL
14634: PUSH
14635: LD_EXP 20
14639: PPUSH
14640: CALL_OW 302
14644: AND
14645: IFFALSE 15474
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
// begin m1 := false ;
14656: LD_ADDR_VAR 0 2
14660: PUSH
14661: LD_INT 0
14663: ST_TO_ADDR
// m2 := false ;
14664: LD_ADDR_VAR 0 3
14668: PUSH
14669: LD_INT 0
14671: ST_TO_ADDR
// m3 := false ;
14672: LD_ADDR_VAR 0 4
14676: PUSH
14677: LD_INT 0
14679: ST_TO_ADDR
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
14680: LD_OWVAR 1
14684: PUSH
14685: LD_INT 252000
14687: PUSH
14688: LD_INT 210000
14690: PUSH
14691: LD_INT 199500
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: LIST
14698: PUSH
14699: LD_OWVAR 67
14703: ARRAY
14704: LESS
14705: IFFALSE 14727
// begin m3 := true ;
14707: LD_ADDR_VAR 0 4
14711: PUSH
14712: LD_INT 1
14714: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
14715: LD_STRING Time1
14717: PPUSH
14718: LD_INT 1
14720: PPUSH
14721: CALL_OW 101
// end else
14725: GO 14758
// if not powell_warn then
14727: LD_EXP 16
14731: NOT
14732: IFFALSE 14747
// AddMedal ( Time1 , - 1 ) else
14734: LD_STRING Time1
14736: PPUSH
14737: LD_INT 1
14739: NEG
14740: PPUSH
14741: CALL_OW 101
14745: GO 14758
// AddMedal ( Time1 , - 2 ) ;
14747: LD_STRING Time1
14749: PPUSH
14750: LD_INT 2
14752: NEG
14753: PPUSH
14754: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14758: LD_EXP 17
14762: PUSH
14763: LD_INT 5
14765: PUSH
14766: LD_INT 4
14768: PUSH
14769: LD_INT 3
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: LIST
14776: PUSH
14777: LD_OWVAR 67
14781: ARRAY
14782: GREATEREQUAL
14783: IFFALSE 14798
// AddMedal ( Destroy , - 2 ) else
14785: LD_STRING Destroy
14787: PPUSH
14788: LD_INT 2
14790: NEG
14791: PPUSH
14792: CALL_OW 101
14796: GO 14931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14798: LD_INT 22
14800: PUSH
14801: LD_INT 2
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: PUSH
14808: LD_INT 21
14810: PUSH
14811: LD_INT 3
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: PUSH
14818: LD_INT 50
14820: PUSH
14821: EMPTY
14822: LIST
14823: PUSH
14824: EMPTY
14825: LIST
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: PUSH
14834: LD_INT 25
14836: GREATEREQUAL
14837: IFFALSE 14852
// AddMedal ( Destroy , - 1 ) else
14839: LD_STRING Destroy
14841: PPUSH
14842: LD_INT 1
14844: NEG
14845: PPUSH
14846: CALL_OW 101
14850: GO 14931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14852: LD_INT 22
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 21
14864: PUSH
14865: LD_INT 3
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 50
14874: PUSH
14875: EMPTY
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 69
14887: PUSH
14888: LD_INT 15
14890: GREATEREQUAL
14891: IFFALSE 14913
// begin m1 := true ;
14893: LD_ADDR_VAR 0 2
14897: PUSH
14898: LD_INT 1
14900: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
14901: LD_STRING Destroy
14903: PPUSH
14904: LD_INT 1
14906: PPUSH
14907: CALL_OW 101
// end else
14911: GO 14931
// begin m1 := true ;
14913: LD_ADDR_VAR 0 2
14917: PUSH
14918: LD_INT 1
14920: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
14921: LD_STRING Destroy
14923: PPUSH
14924: LD_INT 2
14926: PPUSH
14927: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
14931: LD_EXP 13
14935: PPUSH
14936: LD_STRING 11_artifact_captured
14938: PPUSH
14939: CALL_OW 39
// if artifact_get then
14943: LD_EXP 13
14947: IFFALSE 14969
// begin m2 := true ;
14949: LD_ADDR_VAR 0 3
14953: PUSH
14954: LD_INT 1
14956: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
14957: LD_STRING Artefact
14959: PPUSH
14960: LD_INT 1
14962: PPUSH
14963: CALL_OW 101
// end else
14967: GO 14980
// AddMedal ( Artefact , - 1 ) ;
14969: LD_STRING Artefact
14971: PPUSH
14972: LD_INT 1
14974: NEG
14975: PPUSH
14976: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
14980: LD_VAR 0 2
14984: PUSH
14985: LD_VAR 0 3
14989: AND
14990: PUSH
14991: LD_VAR 0 4
14995: AND
14996: PUSH
14997: LD_OWVAR 67
15001: PUSH
15002: LD_INT 3
15004: EQUAL
15005: AND
15006: IFFALSE 15018
// SetAchievementEX ( ACH_AMER , 11 ) ;
15008: LD_STRING ACH_AMER
15010: PPUSH
15011: LD_INT 11
15013: PPUSH
15014: CALL_OW 564
// GiveMedals ( MAIN ) ;
15018: LD_STRING MAIN
15020: PPUSH
15021: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15025: LD_ADDR_EXP 19
15029: PUSH
15030: LD_EXP 19
15034: PPUSH
15035: LD_INT 51
15037: PUSH
15038: EMPTY
15039: LIST
15040: PPUSH
15041: CALL_OW 72
15045: ST_TO_ADDR
// tmp := JMM ^ selected ;
15046: LD_ADDR_VAR 0 1
15050: PUSH
15051: LD_EXP 20
15055: PUSH
15056: LD_EXP 19
15060: ADD
15061: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15062: LD_VAR 0 1
15066: PPUSH
15067: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15071: LD_VAR 0 1
15075: PUSH
15076: LD_EXP 20
15080: PUSH
15081: LD_EXP 21
15085: PUSH
15086: LD_EXP 22
15090: PUSH
15091: LD_EXP 23
15095: PUSH
15096: LD_EXP 24
15100: PUSH
15101: LD_EXP 25
15105: PUSH
15106: LD_EXP 26
15110: PUSH
15111: LD_EXP 27
15115: PUSH
15116: LD_EXP 28
15120: PUSH
15121: LD_EXP 30
15125: PUSH
15126: LD_EXP 31
15130: PUSH
15131: LD_EXP 32
15135: PUSH
15136: LD_EXP 33
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: DIFF
15156: PPUSH
15157: LD_STRING 11c_others
15159: PPUSH
15160: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15164: LD_EXP 20
15168: PPUSH
15169: LD_EXP 3
15173: PUSH
15174: LD_STRING JMM
15176: STR
15177: PPUSH
15178: CALL_OW 38
// if Lisa then
15182: LD_EXP 21
15186: IFFALSE 15206
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15188: LD_EXP 21
15192: PPUSH
15193: LD_EXP 3
15197: PUSH
15198: LD_STRING Lisa
15200: STR
15201: PPUSH
15202: CALL_OW 38
// if Donaldson then
15206: LD_EXP 22
15210: IFFALSE 15230
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15212: LD_EXP 22
15216: PPUSH
15217: LD_EXP 3
15221: PUSH
15222: LD_STRING Donaldson
15224: STR
15225: PPUSH
15226: CALL_OW 38
// if Bobby then
15230: LD_EXP 23
15234: IFFALSE 15254
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15236: LD_EXP 23
15240: PPUSH
15241: LD_EXP 3
15245: PUSH
15246: LD_STRING Bobby
15248: STR
15249: PPUSH
15250: CALL_OW 38
// if Cyrus then
15254: LD_EXP 24
15258: IFFALSE 15278
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15260: LD_EXP 24
15264: PPUSH
15265: LD_EXP 3
15269: PUSH
15270: LD_STRING Cyrus
15272: STR
15273: PPUSH
15274: CALL_OW 38
// if Denis then
15278: LD_EXP 25
15282: IFFALSE 15302
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15284: LD_EXP 25
15288: PPUSH
15289: LD_EXP 3
15293: PUSH
15294: LD_STRING Denis
15296: STR
15297: PPUSH
15298: CALL_OW 38
// if Brown then
15302: LD_EXP 26
15306: IFFALSE 15326
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15308: LD_EXP 26
15312: PPUSH
15313: LD_EXP 3
15317: PUSH
15318: LD_STRING Brown
15320: STR
15321: PPUSH
15322: CALL_OW 38
// if Gladstone then
15326: LD_EXP 27
15330: IFFALSE 15350
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15332: LD_EXP 27
15336: PPUSH
15337: LD_EXP 3
15341: PUSH
15342: LD_STRING Gladstone
15344: STR
15345: PPUSH
15346: CALL_OW 38
// if Houten then
15350: LD_EXP 28
15354: IFFALSE 15374
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15356: LD_EXP 28
15360: PPUSH
15361: LD_EXP 3
15365: PUSH
15366: LD_STRING Houten
15368: STR
15369: PPUSH
15370: CALL_OW 38
// if Cornel then
15374: LD_EXP 30
15378: IFFALSE 15398
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15380: LD_EXP 30
15384: PPUSH
15385: LD_EXP 3
15389: PUSH
15390: LD_STRING Cornell
15392: STR
15393: PPUSH
15394: CALL_OW 38
// if Gary then
15398: LD_EXP 31
15402: IFFALSE 15422
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15404: LD_EXP 31
15408: PPUSH
15409: LD_EXP 3
15413: PUSH
15414: LD_STRING Gary
15416: STR
15417: PPUSH
15418: CALL_OW 38
// if Frank then
15422: LD_EXP 32
15426: IFFALSE 15446
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15428: LD_EXP 32
15432: PPUSH
15433: LD_EXP 3
15437: PUSH
15438: LD_STRING Frank
15440: STR
15441: PPUSH
15442: CALL_OW 38
// if Kikuchi then
15446: LD_EXP 33
15450: IFFALSE 15470
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15452: LD_EXP 33
15456: PPUSH
15457: LD_EXP 3
15461: PUSH
15462: LD_STRING Kikuchi
15464: STR
15465: PPUSH
15466: CALL_OW 38
// YouWin ;
15470: CALL_OW 103
// end ;
15474: PPOPN 4
15476: END
// export function CanSayRand ( side ) ; begin
15477: LD_INT 0
15479: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15480: LD_ADDR_VAR 0 2
15484: PUSH
15485: LD_INT 52
15487: PUSH
15488: EMPTY
15489: LIST
15490: PUSH
15491: LD_INT 22
15493: PUSH
15494: LD_VAR 0 1
15498: PUSH
15499: EMPTY
15500: LIST
15501: LIST
15502: PUSH
15503: LD_INT 2
15505: PUSH
15506: LD_INT 25
15508: PUSH
15509: LD_INT 1
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 25
15518: PUSH
15519: LD_INT 2
15521: PUSH
15522: EMPTY
15523: LIST
15524: LIST
15525: PUSH
15526: LD_INT 25
15528: PUSH
15529: LD_INT 3
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PUSH
15536: LD_INT 25
15538: PUSH
15539: LD_INT 4
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: LIST
15557: PPUSH
15558: CALL_OW 69
15562: PUSH
15563: LD_EXP 20
15567: PUSH
15568: LD_EXP 32
15572: PUSH
15573: LD_EXP 21
15577: PUSH
15578: LD_EXP 22
15582: PUSH
15583: LD_EXP 23
15587: PUSH
15588: LD_EXP 24
15592: PUSH
15593: LD_EXP 25
15597: PUSH
15598: LD_EXP 26
15602: PUSH
15603: LD_EXP 27
15607: PUSH
15608: LD_EXP 28
15612: PUSH
15613: LD_EXP 29
15617: PUSH
15618: LD_EXP 30
15622: PUSH
15623: LD_EXP 31
15627: PUSH
15628: LD_EXP 33
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: LIST
15637: LIST
15638: LIST
15639: LIST
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: DIFF
15649: ST_TO_ADDR
// end ;
15650: LD_VAR 0 2
15654: RET
// export function SayRand ( sex , dial ) ; begin
15655: LD_INT 0
15657: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15658: LD_ADDR_VAR 0 3
15662: PUSH
15663: LD_INT 52
15665: PUSH
15666: EMPTY
15667: LIST
15668: PUSH
15669: LD_INT 22
15671: PUSH
15672: LD_INT 1
15674: PUSH
15675: EMPTY
15676: LIST
15677: LIST
15678: PUSH
15679: LD_INT 26
15681: PUSH
15682: LD_VAR 0 1
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: LD_INT 25
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 25
15706: PUSH
15707: LD_INT 2
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: LD_INT 25
15716: PUSH
15717: LD_INT 3
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 25
15726: PUSH
15727: LD_INT 4
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: LIST
15745: LIST
15746: PPUSH
15747: CALL_OW 69
15751: PUSH
15752: LD_EXP 20
15756: PUSH
15757: LD_EXP 32
15761: PUSH
15762: LD_EXP 21
15766: PUSH
15767: LD_EXP 22
15771: PUSH
15772: LD_EXP 23
15776: PUSH
15777: LD_EXP 24
15781: PUSH
15782: LD_EXP 25
15786: PUSH
15787: LD_EXP 26
15791: PUSH
15792: LD_EXP 27
15796: PUSH
15797: LD_EXP 28
15801: PUSH
15802: LD_EXP 29
15806: PUSH
15807: LD_EXP 30
15811: PUSH
15812: LD_EXP 31
15816: PUSH
15817: LD_EXP 33
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: LIST
15826: LIST
15827: LIST
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: DIFF
15838: ST_TO_ADDR
// if not result then
15839: LD_VAR 0 3
15843: NOT
15844: IFFALSE 15848
// exit ;
15846: GO 15876
// result := result [ 1 ] ;
15848: LD_ADDR_VAR 0 3
15852: PUSH
15853: LD_VAR 0 3
15857: PUSH
15858: LD_INT 1
15860: ARRAY
15861: ST_TO_ADDR
// Say ( result , dial ) ;
15862: LD_VAR 0 3
15866: PPUSH
15867: LD_VAR 0 2
15871: PPUSH
15872: CALL_OW 88
// end ;
15876: LD_VAR 0 3
15880: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15881: LD_INT 0
15883: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15884: LD_ADDR_VAR 0 4
15888: PUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 26
15901: PUSH
15902: LD_VAR 0 1
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 2
15913: PUSH
15914: LD_INT 25
15916: PUSH
15917: LD_INT 1
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: LD_INT 25
15926: PUSH
15927: LD_INT 2
15929: PUSH
15930: EMPTY
15931: LIST
15932: LIST
15933: PUSH
15934: LD_INT 25
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 25
15946: PUSH
15947: LD_INT 4
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: LIST
15958: LIST
15959: LIST
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: LIST
15965: PPUSH
15966: CALL_OW 69
15970: PUSH
15971: LD_EXP 20
15975: PUSH
15976: LD_EXP 32
15980: PUSH
15981: LD_EXP 21
15985: PUSH
15986: LD_EXP 22
15990: PUSH
15991: LD_EXP 23
15995: PUSH
15996: LD_EXP 24
16000: PUSH
16001: LD_EXP 25
16005: PUSH
16006: LD_EXP 26
16010: PUSH
16011: LD_EXP 27
16015: PUSH
16016: LD_EXP 28
16020: PUSH
16021: LD_EXP 29
16025: PUSH
16026: LD_EXP 30
16030: PUSH
16031: LD_EXP 31
16035: PUSH
16036: LD_EXP 33
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: LD_VAR 0 3
16061: ADD
16062: DIFF
16063: ST_TO_ADDR
// if not result then
16064: LD_VAR 0 4
16068: NOT
16069: IFFALSE 16073
// exit ;
16071: GO 16101
// result := result [ 1 ] ;
16073: LD_ADDR_VAR 0 4
16077: PUSH
16078: LD_VAR 0 4
16082: PUSH
16083: LD_INT 1
16085: ARRAY
16086: ST_TO_ADDR
// Say ( result , dial ) ;
16087: LD_VAR 0 4
16091: PPUSH
16092: LD_VAR 0 2
16096: PPUSH
16097: CALL_OW 88
// end ; end_of_file
16101: LD_VAR 0 4
16105: RET
// export function CustomEvent ( event ) ; begin
16106: LD_INT 0
16108: PPUSH
// end ;
16109: LD_VAR 0 2
16113: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16114: LD_VAR 0 1
16118: PPUSH
16119: CALL_OW 255
16123: PUSH
16124: LD_INT 1
16126: EQUAL
16127: IFFALSE 16137
// artifact_get := true ;
16129: LD_ADDR_EXP 13
16133: PUSH
16134: LD_INT 1
16136: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16137: LD_VAR 0 1
16141: PPUSH
16142: CALL_OW 255
16146: PUSH
16147: LD_INT 2
16149: EQUAL
16150: IFFALSE 16168
// begin artifact_get := false ;
16152: LD_ADDR_EXP 13
16156: PUSH
16157: LD_INT 0
16159: ST_TO_ADDR
// artifact_stolen := true ;
16160: LD_ADDR_EXP 12
16164: PUSH
16165: LD_INT 1
16167: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16168: LD_ADDR_EXP 14
16172: PUSH
16173: LD_INT 1
16175: ST_TO_ADDR
// end ;
16176: PPOPN 2
16178: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16179: LD_ADDR_EXP 14
16183: PUSH
16184: LD_INT 0
16186: ST_TO_ADDR
// end ;
16187: PPOPN 2
16189: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16190: LD_VAR 0 1
16194: PUSH
16195: LD_EXP 20
16199: EQUAL
16200: IFFALSE 16211
// begin YouLost ( JMM ) ;
16202: LD_STRING JMM
16204: PPUSH
16205: CALL_OW 104
// exit ;
16209: GO 16343
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16211: LD_VAR 0 1
16215: PUSH
16216: LD_INT 22
16218: PUSH
16219: LD_INT 1
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: PUSH
16226: LD_INT 21
16228: PUSH
16229: LD_INT 1
16231: PUSH
16232: EMPTY
16233: LIST
16234: LIST
16235: PUSH
16236: LD_INT 2
16238: PUSH
16239: LD_INT 25
16241: PUSH
16242: LD_INT 1
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: PUSH
16249: LD_INT 25
16251: PUSH
16252: LD_INT 2
16254: PUSH
16255: EMPTY
16256: LIST
16257: LIST
16258: PUSH
16259: LD_INT 25
16261: PUSH
16262: LD_INT 3
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PUSH
16269: LD_INT 25
16271: PUSH
16272: LD_INT 4
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PUSH
16279: LD_INT 25
16281: PUSH
16282: LD_INT 5
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: PUSH
16289: LD_INT 25
16291: PUSH
16292: LD_INT 8
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: LIST
16312: PPUSH
16313: CALL_OW 69
16317: IN
16318: IFFALSE 16334
// loses_counter := loses_counter + 1 ;
16320: LD_ADDR_EXP 17
16324: PUSH
16325: LD_EXP 17
16329: PUSH
16330: LD_INT 1
16332: PLUS
16333: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16334: LD_VAR 0 1
16338: PPUSH
16339: CALL 44008 0 1
// end ;
16343: PPOPN 1
16345: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_VAR 0 2
16355: PPUSH
16356: CALL 46342 0 2
// end ;
16360: PPOPN 2
16362: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16363: LD_VAR 0 1
16367: PPUSH
16368: CALL 45651 0 1
// end ;
16372: PPOPN 1
16374: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16375: LD_VAR 0 1
16379: PPUSH
16380: LD_VAR 0 2
16384: PPUSH
16385: LD_VAR 0 3
16389: PPUSH
16390: LD_VAR 0 4
16394: PPUSH
16395: LD_VAR 0 5
16399: PPUSH
16400: CALL 43324 0 5
// end ;
16404: PPOPN 5
16406: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
16407: LD_VAR 0 1
16411: PPUSH
16412: LD_VAR 0 2
16416: PPUSH
16417: CALL 42920 0 2
// end ;
16421: PPOPN 2
16423: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL_OW 247
16433: PUSH
16434: LD_INT 2
16436: EQUAL
16437: IFFALSE 16441
// exit ;
16439: GO 16458
// if not kamikazed then
16441: LD_EXP 11
16445: NOT
16446: IFFALSE 16458
// kamikazed := unit ;
16448: LD_ADDR_EXP 11
16452: PUSH
16453: LD_VAR 0 1
16457: ST_TO_ADDR
// end ;
16458: PPOPN 1
16460: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16461: LD_INT 0
16463: PPUSH
16464: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16465: LD_VAR 0 1
16469: PPUSH
16470: LD_VAR 0 2
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: LD_VAR 0 4
16484: PPUSH
16485: CALL 42758 0 4
// end ;
16489: PPOPN 6
16491: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16492: LD_VAR 0 1
16496: PPUSH
16497: LD_VAR 0 2
16501: PPUSH
16502: LD_VAR 0 3
16506: PPUSH
16507: CALL 42533 0 3
// end ;
16511: PPOPN 3
16513: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16514: LD_VAR 0 1
16518: PPUSH
16519: LD_VAR 0 2
16523: PPUSH
16524: CALL 43704 0 2
// end ;
16528: PPOPN 2
16530: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16531: LD_VAR 0 1
16535: PPUSH
16536: LD_VAR 0 2
16540: PPUSH
16541: CALL 42227 0 2
// end ;
16545: PPOPN 2
16547: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16548: LD_VAR 0 1
16552: PPUSH
16553: LD_VAR 0 2
16557: PPUSH
16558: CALL 42418 0 2
// end ;
16562: PPOPN 2
16564: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16565: LD_VAR 0 1
16569: PPUSH
16570: CALL 45410 0 1
// end ;
16574: PPOPN 1
16576: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16577: LD_VAR 0 1
16581: PPUSH
16582: LD_VAR 0 2
16586: PPUSH
16587: CALL 46603 0 2
// end ;
16591: PPOPN 2
16593: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16594: LD_VAR 0 1
16598: PPUSH
16599: LD_VAR 0 2
16603: PPUSH
16604: LD_VAR 0 3
16608: PPUSH
16609: LD_VAR 0 4
16613: PPUSH
16614: CALL 46819 0 4
// end ;
16618: PPOPN 4
16620: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16621: LD_VAR 0 1
16625: PPUSH
16626: CALL 90175 0 1
// end ; end_of_file
16630: PPOPN 1
16632: END
// every 0 0$1 trigger game do
16633: LD_EXP 2
16637: IFFALSE 16667
16639: GO 16641
16641: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16642: LD_INT 7
16644: PUSH
16645: LD_INT 6
16647: PUSH
16648: LD_INT 4
16650: PUSH
16651: LD_INT 6
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: LIST
16658: LIST
16659: PPUSH
16660: LD_INT 1750
16662: PPUSH
16663: CALL 16668 0 2
16667: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16668: LD_INT 0
16670: PPUSH
16671: PPUSH
16672: PPUSH
// if not areas then
16673: LD_VAR 0 1
16677: NOT
16678: IFFALSE 16682
// exit ;
16680: GO 16812
// repeat wait ( time ) ;
16682: LD_VAR 0 2
16686: PPUSH
16687: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16691: LD_ADDR_VAR 0 5
16695: PUSH
16696: LD_INT 1
16698: PPUSH
16699: LD_INT 90
16701: PPUSH
16702: CALL_OW 12
16706: ST_TO_ADDR
// for i in areas do
16707: LD_ADDR_VAR 0 4
16711: PUSH
16712: LD_VAR 0 1
16716: PUSH
16717: FOR_IN
16718: IFFALSE 16771
// begin if Prob ( p ) then
16720: LD_VAR 0 5
16724: PPUSH
16725: CALL_OW 13
16729: IFFALSE 16769
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16731: LD_INT 1
16733: PPUSH
16734: LD_INT 5
16736: PPUSH
16737: CALL_OW 12
16741: PPUSH
16742: LD_VAR 0 4
16746: PPUSH
16747: LD_INT 1
16749: PPUSH
16750: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
16754: LD_INT 385
16756: PPUSH
16757: LD_INT 595
16759: PPUSH
16760: CALL_OW 12
16764: PPUSH
16765: CALL_OW 67
// end ; end ;
16769: GO 16717
16771: POP
16772: POP
// time := time + 0 0$3 ;
16773: LD_ADDR_VAR 0 2
16777: PUSH
16778: LD_VAR 0 2
16782: PUSH
16783: LD_INT 105
16785: PLUS
16786: ST_TO_ADDR
// if time > 7 7$00 then
16787: LD_VAR 0 2
16791: PUSH
16792: LD_INT 14700
16794: GREATER
16795: IFFALSE 16805
// time := 0 0$40 ;
16797: LD_ADDR_VAR 0 2
16801: PUSH
16802: LD_INT 1400
16804: ST_TO_ADDR
// until not game ;
16805: LD_EXP 2
16809: NOT
16810: IFFALSE 16682
// end ; end_of_file
16812: LD_VAR 0 3
16816: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
16817: LD_INT 0
16819: PPUSH
16820: PPUSH
// skirmish := false ;
16821: LD_ADDR_EXP 47
16825: PUSH
16826: LD_INT 0
16828: ST_TO_ADDR
// debug_mc := false ;
16829: LD_ADDR_EXP 48
16833: PUSH
16834: LD_INT 0
16836: ST_TO_ADDR
// mc_bases := [ ] ;
16837: LD_ADDR_EXP 49
16841: PUSH
16842: EMPTY
16843: ST_TO_ADDR
// mc_sides := [ ] ;
16844: LD_ADDR_EXP 75
16848: PUSH
16849: EMPTY
16850: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16851: LD_ADDR_EXP 50
16855: PUSH
16856: EMPTY
16857: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16858: LD_ADDR_EXP 51
16862: PUSH
16863: EMPTY
16864: ST_TO_ADDR
// mc_need_heal := [ ] ;
16865: LD_ADDR_EXP 52
16869: PUSH
16870: EMPTY
16871: ST_TO_ADDR
// mc_healers := [ ] ;
16872: LD_ADDR_EXP 53
16876: PUSH
16877: EMPTY
16878: ST_TO_ADDR
// mc_build_list := [ ] ;
16879: LD_ADDR_EXP 54
16883: PUSH
16884: EMPTY
16885: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16886: LD_ADDR_EXP 81
16890: PUSH
16891: EMPTY
16892: ST_TO_ADDR
// mc_builders := [ ] ;
16893: LD_ADDR_EXP 55
16897: PUSH
16898: EMPTY
16899: ST_TO_ADDR
// mc_construct_list := [ ] ;
16900: LD_ADDR_EXP 56
16904: PUSH
16905: EMPTY
16906: ST_TO_ADDR
// mc_turret_list := [ ] ;
16907: LD_ADDR_EXP 57
16911: PUSH
16912: EMPTY
16913: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16914: LD_ADDR_EXP 58
16918: PUSH
16919: EMPTY
16920: ST_TO_ADDR
// mc_miners := [ ] ;
16921: LD_ADDR_EXP 63
16925: PUSH
16926: EMPTY
16927: ST_TO_ADDR
// mc_mines := [ ] ;
16928: LD_ADDR_EXP 62
16932: PUSH
16933: EMPTY
16934: ST_TO_ADDR
// mc_minefields := [ ] ;
16935: LD_ADDR_EXP 64
16939: PUSH
16940: EMPTY
16941: ST_TO_ADDR
// mc_crates := [ ] ;
16942: LD_ADDR_EXP 65
16946: PUSH
16947: EMPTY
16948: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16949: LD_ADDR_EXP 66
16953: PUSH
16954: EMPTY
16955: ST_TO_ADDR
// mc_crates_area := [ ] ;
16956: LD_ADDR_EXP 67
16960: PUSH
16961: EMPTY
16962: ST_TO_ADDR
// mc_vehicles := [ ] ;
16963: LD_ADDR_EXP 68
16967: PUSH
16968: EMPTY
16969: ST_TO_ADDR
// mc_attack := [ ] ;
16970: LD_ADDR_EXP 69
16974: PUSH
16975: EMPTY
16976: ST_TO_ADDR
// mc_produce := [ ] ;
16977: LD_ADDR_EXP 70
16981: PUSH
16982: EMPTY
16983: ST_TO_ADDR
// mc_defender := [ ] ;
16984: LD_ADDR_EXP 71
16988: PUSH
16989: EMPTY
16990: ST_TO_ADDR
// mc_parking := [ ] ;
16991: LD_ADDR_EXP 73
16995: PUSH
16996: EMPTY
16997: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16998: LD_ADDR_EXP 59
17002: PUSH
17003: EMPTY
17004: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17005: LD_ADDR_EXP 61
17009: PUSH
17010: EMPTY
17011: ST_TO_ADDR
// mc_scan := [ ] ;
17012: LD_ADDR_EXP 72
17016: PUSH
17017: EMPTY
17018: ST_TO_ADDR
// mc_scan_area := [ ] ;
17019: LD_ADDR_EXP 74
17023: PUSH
17024: EMPTY
17025: ST_TO_ADDR
// mc_tech := [ ] ;
17026: LD_ADDR_EXP 76
17030: PUSH
17031: EMPTY
17032: ST_TO_ADDR
// mc_class := [ ] ;
17033: LD_ADDR_EXP 90
17037: PUSH
17038: EMPTY
17039: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17040: LD_ADDR_EXP 91
17044: PUSH
17045: EMPTY
17046: ST_TO_ADDR
// end ;
17047: LD_VAR 0 1
17051: RET
// export function MC_Kill ( base ) ; begin
17052: LD_INT 0
17054: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17055: LD_ADDR_EXP 49
17059: PUSH
17060: LD_EXP 49
17064: PPUSH
17065: LD_VAR 0 1
17069: PPUSH
17070: EMPTY
17071: PPUSH
17072: CALL_OW 1
17076: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17077: LD_ADDR_EXP 50
17081: PUSH
17082: LD_EXP 50
17086: PPUSH
17087: LD_VAR 0 1
17091: PPUSH
17092: EMPTY
17093: PPUSH
17094: CALL_OW 1
17098: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17099: LD_ADDR_EXP 51
17103: PUSH
17104: LD_EXP 51
17108: PPUSH
17109: LD_VAR 0 1
17113: PPUSH
17114: EMPTY
17115: PPUSH
17116: CALL_OW 1
17120: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17121: LD_ADDR_EXP 52
17125: PUSH
17126: LD_EXP 52
17130: PPUSH
17131: LD_VAR 0 1
17135: PPUSH
17136: EMPTY
17137: PPUSH
17138: CALL_OW 1
17142: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17143: LD_ADDR_EXP 53
17147: PUSH
17148: LD_EXP 53
17152: PPUSH
17153: LD_VAR 0 1
17157: PPUSH
17158: EMPTY
17159: PPUSH
17160: CALL_OW 1
17164: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17165: LD_ADDR_EXP 54
17169: PUSH
17170: LD_EXP 54
17174: PPUSH
17175: LD_VAR 0 1
17179: PPUSH
17180: EMPTY
17181: PPUSH
17182: CALL_OW 1
17186: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17187: LD_ADDR_EXP 55
17191: PUSH
17192: LD_EXP 55
17196: PPUSH
17197: LD_VAR 0 1
17201: PPUSH
17202: EMPTY
17203: PPUSH
17204: CALL_OW 1
17208: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17209: LD_ADDR_EXP 56
17213: PUSH
17214: LD_EXP 56
17218: PPUSH
17219: LD_VAR 0 1
17223: PPUSH
17224: EMPTY
17225: PPUSH
17226: CALL_OW 1
17230: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17231: LD_ADDR_EXP 57
17235: PUSH
17236: LD_EXP 57
17240: PPUSH
17241: LD_VAR 0 1
17245: PPUSH
17246: EMPTY
17247: PPUSH
17248: CALL_OW 1
17252: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17253: LD_ADDR_EXP 58
17257: PUSH
17258: LD_EXP 58
17262: PPUSH
17263: LD_VAR 0 1
17267: PPUSH
17268: EMPTY
17269: PPUSH
17270: CALL_OW 1
17274: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17275: LD_ADDR_EXP 59
17279: PUSH
17280: LD_EXP 59
17284: PPUSH
17285: LD_VAR 0 1
17289: PPUSH
17290: EMPTY
17291: PPUSH
17292: CALL_OW 1
17296: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17297: LD_ADDR_EXP 60
17301: PUSH
17302: LD_EXP 60
17306: PPUSH
17307: LD_VAR 0 1
17311: PPUSH
17312: LD_INT 0
17314: PPUSH
17315: CALL_OW 1
17319: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17320: LD_ADDR_EXP 61
17324: PUSH
17325: LD_EXP 61
17329: PPUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: EMPTY
17336: PPUSH
17337: CALL_OW 1
17341: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17342: LD_ADDR_EXP 62
17346: PUSH
17347: LD_EXP 62
17351: PPUSH
17352: LD_VAR 0 1
17356: PPUSH
17357: EMPTY
17358: PPUSH
17359: CALL_OW 1
17363: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17364: LD_ADDR_EXP 63
17368: PUSH
17369: LD_EXP 63
17373: PPUSH
17374: LD_VAR 0 1
17378: PPUSH
17379: EMPTY
17380: PPUSH
17381: CALL_OW 1
17385: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17386: LD_ADDR_EXP 64
17390: PUSH
17391: LD_EXP 64
17395: PPUSH
17396: LD_VAR 0 1
17400: PPUSH
17401: EMPTY
17402: PPUSH
17403: CALL_OW 1
17407: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17408: LD_ADDR_EXP 65
17412: PUSH
17413: LD_EXP 65
17417: PPUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: EMPTY
17424: PPUSH
17425: CALL_OW 1
17429: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17430: LD_ADDR_EXP 66
17434: PUSH
17435: LD_EXP 66
17439: PPUSH
17440: LD_VAR 0 1
17444: PPUSH
17445: EMPTY
17446: PPUSH
17447: CALL_OW 1
17451: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17452: LD_ADDR_EXP 67
17456: PUSH
17457: LD_EXP 67
17461: PPUSH
17462: LD_VAR 0 1
17466: PPUSH
17467: EMPTY
17468: PPUSH
17469: CALL_OW 1
17473: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17474: LD_ADDR_EXP 68
17478: PUSH
17479: LD_EXP 68
17483: PPUSH
17484: LD_VAR 0 1
17488: PPUSH
17489: EMPTY
17490: PPUSH
17491: CALL_OW 1
17495: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17496: LD_ADDR_EXP 69
17500: PUSH
17501: LD_EXP 69
17505: PPUSH
17506: LD_VAR 0 1
17510: PPUSH
17511: EMPTY
17512: PPUSH
17513: CALL_OW 1
17517: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17518: LD_ADDR_EXP 70
17522: PUSH
17523: LD_EXP 70
17527: PPUSH
17528: LD_VAR 0 1
17532: PPUSH
17533: EMPTY
17534: PPUSH
17535: CALL_OW 1
17539: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17540: LD_ADDR_EXP 71
17544: PUSH
17545: LD_EXP 71
17549: PPUSH
17550: LD_VAR 0 1
17554: PPUSH
17555: EMPTY
17556: PPUSH
17557: CALL_OW 1
17561: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17562: LD_ADDR_EXP 72
17566: PUSH
17567: LD_EXP 72
17571: PPUSH
17572: LD_VAR 0 1
17576: PPUSH
17577: EMPTY
17578: PPUSH
17579: CALL_OW 1
17583: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17584: LD_ADDR_EXP 73
17588: PUSH
17589: LD_EXP 73
17593: PPUSH
17594: LD_VAR 0 1
17598: PPUSH
17599: EMPTY
17600: PPUSH
17601: CALL_OW 1
17605: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17606: LD_ADDR_EXP 74
17610: PUSH
17611: LD_EXP 74
17615: PPUSH
17616: LD_VAR 0 1
17620: PPUSH
17621: EMPTY
17622: PPUSH
17623: CALL_OW 1
17627: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17628: LD_ADDR_EXP 76
17632: PUSH
17633: LD_EXP 76
17637: PPUSH
17638: LD_VAR 0 1
17642: PPUSH
17643: EMPTY
17644: PPUSH
17645: CALL_OW 1
17649: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17650: LD_ADDR_EXP 78
17654: PUSH
17655: LD_EXP 78
17659: PPUSH
17660: LD_VAR 0 1
17664: PPUSH
17665: EMPTY
17666: PPUSH
17667: CALL_OW 1
17671: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17672: LD_ADDR_EXP 79
17676: PUSH
17677: LD_EXP 79
17681: PPUSH
17682: LD_VAR 0 1
17686: PPUSH
17687: EMPTY
17688: PPUSH
17689: CALL_OW 1
17693: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17694: LD_ADDR_EXP 80
17698: PUSH
17699: LD_EXP 80
17703: PPUSH
17704: LD_VAR 0 1
17708: PPUSH
17709: EMPTY
17710: PPUSH
17711: CALL_OW 1
17715: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17716: LD_ADDR_EXP 81
17720: PUSH
17721: LD_EXP 81
17725: PPUSH
17726: LD_VAR 0 1
17730: PPUSH
17731: EMPTY
17732: PPUSH
17733: CALL_OW 1
17737: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17738: LD_ADDR_EXP 82
17742: PUSH
17743: LD_EXP 82
17747: PPUSH
17748: LD_VAR 0 1
17752: PPUSH
17753: EMPTY
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17760: LD_ADDR_EXP 83
17764: PUSH
17765: LD_EXP 83
17769: PPUSH
17770: LD_VAR 0 1
17774: PPUSH
17775: EMPTY
17776: PPUSH
17777: CALL_OW 1
17781: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17782: LD_ADDR_EXP 84
17786: PUSH
17787: LD_EXP 84
17791: PPUSH
17792: LD_VAR 0 1
17796: PPUSH
17797: EMPTY
17798: PPUSH
17799: CALL_OW 1
17803: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17804: LD_ADDR_EXP 85
17808: PUSH
17809: LD_EXP 85
17813: PPUSH
17814: LD_VAR 0 1
17818: PPUSH
17819: EMPTY
17820: PPUSH
17821: CALL_OW 1
17825: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17826: LD_ADDR_EXP 86
17830: PUSH
17831: LD_EXP 86
17835: PPUSH
17836: LD_VAR 0 1
17840: PPUSH
17841: EMPTY
17842: PPUSH
17843: CALL_OW 1
17847: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17848: LD_ADDR_EXP 87
17852: PUSH
17853: LD_EXP 87
17857: PPUSH
17858: LD_VAR 0 1
17862: PPUSH
17863: EMPTY
17864: PPUSH
17865: CALL_OW 1
17869: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17870: LD_ADDR_EXP 88
17874: PUSH
17875: LD_EXP 88
17879: PPUSH
17880: LD_VAR 0 1
17884: PPUSH
17885: EMPTY
17886: PPUSH
17887: CALL_OW 1
17891: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17892: LD_ADDR_EXP 89
17896: PUSH
17897: LD_EXP 89
17901: PPUSH
17902: LD_VAR 0 1
17906: PPUSH
17907: EMPTY
17908: PPUSH
17909: CALL_OW 1
17913: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17914: LD_ADDR_EXP 90
17918: PUSH
17919: LD_EXP 90
17923: PPUSH
17924: LD_VAR 0 1
17928: PPUSH
17929: EMPTY
17930: PPUSH
17931: CALL_OW 1
17935: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
17936: LD_ADDR_EXP 91
17940: PUSH
17941: LD_EXP 91
17945: PPUSH
17946: LD_VAR 0 1
17950: PPUSH
17951: LD_INT 0
17953: PPUSH
17954: CALL_OW 1
17958: ST_TO_ADDR
// end ;
17959: LD_VAR 0 2
17963: RET
// export function MC_Add ( side , units ) ; var base ; begin
17964: LD_INT 0
17966: PPUSH
17967: PPUSH
// base := mc_bases + 1 ;
17968: LD_ADDR_VAR 0 4
17972: PUSH
17973: LD_EXP 49
17977: PUSH
17978: LD_INT 1
17980: PLUS
17981: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
17982: LD_ADDR_EXP 75
17986: PUSH
17987: LD_EXP 75
17991: PPUSH
17992: LD_VAR 0 4
17996: PPUSH
17997: LD_VAR 0 1
18001: PPUSH
18002: CALL_OW 1
18006: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18007: LD_ADDR_EXP 49
18011: PUSH
18012: LD_EXP 49
18016: PPUSH
18017: LD_VAR 0 4
18021: PPUSH
18022: LD_VAR 0 2
18026: PPUSH
18027: CALL_OW 1
18031: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18032: LD_ADDR_EXP 50
18036: PUSH
18037: LD_EXP 50
18041: PPUSH
18042: LD_VAR 0 4
18046: PPUSH
18047: EMPTY
18048: PPUSH
18049: CALL_OW 1
18053: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18054: LD_ADDR_EXP 51
18058: PUSH
18059: LD_EXP 51
18063: PPUSH
18064: LD_VAR 0 4
18068: PPUSH
18069: EMPTY
18070: PPUSH
18071: CALL_OW 1
18075: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18076: LD_ADDR_EXP 52
18080: PUSH
18081: LD_EXP 52
18085: PPUSH
18086: LD_VAR 0 4
18090: PPUSH
18091: EMPTY
18092: PPUSH
18093: CALL_OW 1
18097: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18098: LD_ADDR_EXP 53
18102: PUSH
18103: LD_EXP 53
18107: PPUSH
18108: LD_VAR 0 4
18112: PPUSH
18113: EMPTY
18114: PPUSH
18115: CALL_OW 1
18119: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18120: LD_ADDR_EXP 54
18124: PUSH
18125: LD_EXP 54
18129: PPUSH
18130: LD_VAR 0 4
18134: PPUSH
18135: EMPTY
18136: PPUSH
18137: CALL_OW 1
18141: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18142: LD_ADDR_EXP 55
18146: PUSH
18147: LD_EXP 55
18151: PPUSH
18152: LD_VAR 0 4
18156: PPUSH
18157: EMPTY
18158: PPUSH
18159: CALL_OW 1
18163: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18164: LD_ADDR_EXP 56
18168: PUSH
18169: LD_EXP 56
18173: PPUSH
18174: LD_VAR 0 4
18178: PPUSH
18179: EMPTY
18180: PPUSH
18181: CALL_OW 1
18185: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18186: LD_ADDR_EXP 57
18190: PUSH
18191: LD_EXP 57
18195: PPUSH
18196: LD_VAR 0 4
18200: PPUSH
18201: EMPTY
18202: PPUSH
18203: CALL_OW 1
18207: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18208: LD_ADDR_EXP 58
18212: PUSH
18213: LD_EXP 58
18217: PPUSH
18218: LD_VAR 0 4
18222: PPUSH
18223: EMPTY
18224: PPUSH
18225: CALL_OW 1
18229: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18230: LD_ADDR_EXP 59
18234: PUSH
18235: LD_EXP 59
18239: PPUSH
18240: LD_VAR 0 4
18244: PPUSH
18245: EMPTY
18246: PPUSH
18247: CALL_OW 1
18251: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18252: LD_ADDR_EXP 60
18256: PUSH
18257: LD_EXP 60
18261: PPUSH
18262: LD_VAR 0 4
18266: PPUSH
18267: LD_INT 0
18269: PPUSH
18270: CALL_OW 1
18274: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18275: LD_ADDR_EXP 61
18279: PUSH
18280: LD_EXP 61
18284: PPUSH
18285: LD_VAR 0 4
18289: PPUSH
18290: EMPTY
18291: PPUSH
18292: CALL_OW 1
18296: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18297: LD_ADDR_EXP 62
18301: PUSH
18302: LD_EXP 62
18306: PPUSH
18307: LD_VAR 0 4
18311: PPUSH
18312: EMPTY
18313: PPUSH
18314: CALL_OW 1
18318: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18319: LD_ADDR_EXP 63
18323: PUSH
18324: LD_EXP 63
18328: PPUSH
18329: LD_VAR 0 4
18333: PPUSH
18334: EMPTY
18335: PPUSH
18336: CALL_OW 1
18340: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18341: LD_ADDR_EXP 64
18345: PUSH
18346: LD_EXP 64
18350: PPUSH
18351: LD_VAR 0 4
18355: PPUSH
18356: EMPTY
18357: PPUSH
18358: CALL_OW 1
18362: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18363: LD_ADDR_EXP 65
18367: PUSH
18368: LD_EXP 65
18372: PPUSH
18373: LD_VAR 0 4
18377: PPUSH
18378: EMPTY
18379: PPUSH
18380: CALL_OW 1
18384: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18385: LD_ADDR_EXP 66
18389: PUSH
18390: LD_EXP 66
18394: PPUSH
18395: LD_VAR 0 4
18399: PPUSH
18400: EMPTY
18401: PPUSH
18402: CALL_OW 1
18406: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18407: LD_ADDR_EXP 67
18411: PUSH
18412: LD_EXP 67
18416: PPUSH
18417: LD_VAR 0 4
18421: PPUSH
18422: EMPTY
18423: PPUSH
18424: CALL_OW 1
18428: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18429: LD_ADDR_EXP 68
18433: PUSH
18434: LD_EXP 68
18438: PPUSH
18439: LD_VAR 0 4
18443: PPUSH
18444: EMPTY
18445: PPUSH
18446: CALL_OW 1
18450: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18451: LD_ADDR_EXP 69
18455: PUSH
18456: LD_EXP 69
18460: PPUSH
18461: LD_VAR 0 4
18465: PPUSH
18466: EMPTY
18467: PPUSH
18468: CALL_OW 1
18472: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18473: LD_ADDR_EXP 70
18477: PUSH
18478: LD_EXP 70
18482: PPUSH
18483: LD_VAR 0 4
18487: PPUSH
18488: EMPTY
18489: PPUSH
18490: CALL_OW 1
18494: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18495: LD_ADDR_EXP 71
18499: PUSH
18500: LD_EXP 71
18504: PPUSH
18505: LD_VAR 0 4
18509: PPUSH
18510: EMPTY
18511: PPUSH
18512: CALL_OW 1
18516: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18517: LD_ADDR_EXP 72
18521: PUSH
18522: LD_EXP 72
18526: PPUSH
18527: LD_VAR 0 4
18531: PPUSH
18532: EMPTY
18533: PPUSH
18534: CALL_OW 1
18538: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18539: LD_ADDR_EXP 73
18543: PUSH
18544: LD_EXP 73
18548: PPUSH
18549: LD_VAR 0 4
18553: PPUSH
18554: EMPTY
18555: PPUSH
18556: CALL_OW 1
18560: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18561: LD_ADDR_EXP 74
18565: PUSH
18566: LD_EXP 74
18570: PPUSH
18571: LD_VAR 0 4
18575: PPUSH
18576: EMPTY
18577: PPUSH
18578: CALL_OW 1
18582: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18583: LD_ADDR_EXP 76
18587: PUSH
18588: LD_EXP 76
18592: PPUSH
18593: LD_VAR 0 4
18597: PPUSH
18598: EMPTY
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18605: LD_ADDR_EXP 78
18609: PUSH
18610: LD_EXP 78
18614: PPUSH
18615: LD_VAR 0 4
18619: PPUSH
18620: EMPTY
18621: PPUSH
18622: CALL_OW 1
18626: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18627: LD_ADDR_EXP 79
18631: PUSH
18632: LD_EXP 79
18636: PPUSH
18637: LD_VAR 0 4
18641: PPUSH
18642: EMPTY
18643: PPUSH
18644: CALL_OW 1
18648: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18649: LD_ADDR_EXP 80
18653: PUSH
18654: LD_EXP 80
18658: PPUSH
18659: LD_VAR 0 4
18663: PPUSH
18664: EMPTY
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18671: LD_ADDR_EXP 81
18675: PUSH
18676: LD_EXP 81
18680: PPUSH
18681: LD_VAR 0 4
18685: PPUSH
18686: EMPTY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18693: LD_ADDR_EXP 82
18697: PUSH
18698: LD_EXP 82
18702: PPUSH
18703: LD_VAR 0 4
18707: PPUSH
18708: EMPTY
18709: PPUSH
18710: CALL_OW 1
18714: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18715: LD_ADDR_EXP 83
18719: PUSH
18720: LD_EXP 83
18724: PPUSH
18725: LD_VAR 0 4
18729: PPUSH
18730: EMPTY
18731: PPUSH
18732: CALL_OW 1
18736: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18737: LD_ADDR_EXP 84
18741: PUSH
18742: LD_EXP 84
18746: PPUSH
18747: LD_VAR 0 4
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18759: LD_ADDR_EXP 85
18763: PUSH
18764: LD_EXP 85
18768: PPUSH
18769: LD_VAR 0 4
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18781: LD_ADDR_EXP 86
18785: PUSH
18786: LD_EXP 86
18790: PPUSH
18791: LD_VAR 0 4
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18803: LD_ADDR_EXP 87
18807: PUSH
18808: LD_EXP 87
18812: PPUSH
18813: LD_VAR 0 4
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18825: LD_ADDR_EXP 88
18829: PUSH
18830: LD_EXP 88
18834: PPUSH
18835: LD_VAR 0 4
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18847: LD_ADDR_EXP 89
18851: PUSH
18852: LD_EXP 89
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18869: LD_ADDR_EXP 90
18873: PUSH
18874: LD_EXP 90
18878: PPUSH
18879: LD_VAR 0 4
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18891: LD_ADDR_EXP 91
18895: PUSH
18896: LD_EXP 91
18900: PPUSH
18901: LD_VAR 0 4
18905: PPUSH
18906: LD_INT 0
18908: PPUSH
18909: CALL_OW 1
18913: ST_TO_ADDR
// result := base ;
18914: LD_ADDR_VAR 0 3
18918: PUSH
18919: LD_VAR 0 4
18923: ST_TO_ADDR
// end ;
18924: LD_VAR 0 3
18928: RET
// export function MC_Start ( ) ; var i ; begin
18929: LD_INT 0
18931: PPUSH
18932: PPUSH
// for i = 1 to mc_bases do
18933: LD_ADDR_VAR 0 2
18937: PUSH
18938: DOUBLE
18939: LD_INT 1
18941: DEC
18942: ST_TO_ADDR
18943: LD_EXP 49
18947: PUSH
18948: FOR_TO
18949: IFFALSE 20026
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
18951: LD_ADDR_EXP 49
18955: PUSH
18956: LD_EXP 49
18960: PPUSH
18961: LD_VAR 0 2
18965: PPUSH
18966: LD_EXP 49
18970: PUSH
18971: LD_VAR 0 2
18975: ARRAY
18976: PUSH
18977: LD_INT 0
18979: DIFF
18980: PPUSH
18981: CALL_OW 1
18985: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
18986: LD_ADDR_EXP 50
18990: PUSH
18991: LD_EXP 50
18995: PPUSH
18996: LD_VAR 0 2
19000: PPUSH
19001: EMPTY
19002: PPUSH
19003: CALL_OW 1
19007: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19008: LD_ADDR_EXP 51
19012: PUSH
19013: LD_EXP 51
19017: PPUSH
19018: LD_VAR 0 2
19022: PPUSH
19023: EMPTY
19024: PPUSH
19025: CALL_OW 1
19029: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19030: LD_ADDR_EXP 52
19034: PUSH
19035: LD_EXP 52
19039: PPUSH
19040: LD_VAR 0 2
19044: PPUSH
19045: EMPTY
19046: PPUSH
19047: CALL_OW 1
19051: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19052: LD_ADDR_EXP 53
19056: PUSH
19057: LD_EXP 53
19061: PPUSH
19062: LD_VAR 0 2
19066: PPUSH
19067: EMPTY
19068: PUSH
19069: EMPTY
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: PPUSH
19075: CALL_OW 1
19079: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19080: LD_ADDR_EXP 54
19084: PUSH
19085: LD_EXP 54
19089: PPUSH
19090: LD_VAR 0 2
19094: PPUSH
19095: EMPTY
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19102: LD_ADDR_EXP 81
19106: PUSH
19107: LD_EXP 81
19111: PPUSH
19112: LD_VAR 0 2
19116: PPUSH
19117: EMPTY
19118: PPUSH
19119: CALL_OW 1
19123: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19124: LD_ADDR_EXP 55
19128: PUSH
19129: LD_EXP 55
19133: PPUSH
19134: LD_VAR 0 2
19138: PPUSH
19139: EMPTY
19140: PPUSH
19141: CALL_OW 1
19145: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19146: LD_ADDR_EXP 56
19150: PUSH
19151: LD_EXP 56
19155: PPUSH
19156: LD_VAR 0 2
19160: PPUSH
19161: EMPTY
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19168: LD_ADDR_EXP 57
19172: PUSH
19173: LD_EXP 57
19177: PPUSH
19178: LD_VAR 0 2
19182: PPUSH
19183: LD_EXP 49
19187: PUSH
19188: LD_VAR 0 2
19192: ARRAY
19193: PPUSH
19194: LD_INT 2
19196: PUSH
19197: LD_INT 30
19199: PUSH
19200: LD_INT 32
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PUSH
19207: LD_INT 30
19209: PUSH
19210: LD_INT 33
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: PUSH
19217: EMPTY
19218: LIST
19219: LIST
19220: LIST
19221: PPUSH
19222: CALL_OW 72
19226: PPUSH
19227: CALL_OW 1
19231: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19232: LD_ADDR_EXP 58
19236: PUSH
19237: LD_EXP 58
19241: PPUSH
19242: LD_VAR 0 2
19246: PPUSH
19247: LD_EXP 49
19251: PUSH
19252: LD_VAR 0 2
19256: ARRAY
19257: PPUSH
19258: LD_INT 2
19260: PUSH
19261: LD_INT 30
19263: PUSH
19264: LD_INT 32
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: PUSH
19271: LD_INT 30
19273: PUSH
19274: LD_INT 31
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: PUSH
19281: EMPTY
19282: LIST
19283: LIST
19284: LIST
19285: PUSH
19286: LD_INT 58
19288: PUSH
19289: EMPTY
19290: LIST
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: PPUSH
19296: CALL_OW 72
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19306: LD_ADDR_EXP 59
19310: PUSH
19311: LD_EXP 59
19315: PPUSH
19316: LD_VAR 0 2
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19328: LD_ADDR_EXP 63
19332: PUSH
19333: LD_EXP 63
19337: PPUSH
19338: LD_VAR 0 2
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19350: LD_ADDR_EXP 62
19354: PUSH
19355: LD_EXP 62
19359: PPUSH
19360: LD_VAR 0 2
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19372: LD_ADDR_EXP 64
19376: PUSH
19377: LD_EXP 64
19381: PPUSH
19382: LD_VAR 0 2
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19394: LD_ADDR_EXP 65
19398: PUSH
19399: LD_EXP 65
19403: PPUSH
19404: LD_VAR 0 2
19408: PPUSH
19409: EMPTY
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19416: LD_ADDR_EXP 66
19420: PUSH
19421: LD_EXP 66
19425: PPUSH
19426: LD_VAR 0 2
19430: PPUSH
19431: EMPTY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19438: LD_ADDR_EXP 67
19442: PUSH
19443: LD_EXP 67
19447: PPUSH
19448: LD_VAR 0 2
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19460: LD_ADDR_EXP 68
19464: PUSH
19465: LD_EXP 68
19469: PPUSH
19470: LD_VAR 0 2
19474: PPUSH
19475: EMPTY
19476: PPUSH
19477: CALL_OW 1
19481: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19482: LD_ADDR_EXP 69
19486: PUSH
19487: LD_EXP 69
19491: PPUSH
19492: LD_VAR 0 2
19496: PPUSH
19497: EMPTY
19498: PPUSH
19499: CALL_OW 1
19503: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19504: LD_ADDR_EXP 70
19508: PUSH
19509: LD_EXP 70
19513: PPUSH
19514: LD_VAR 0 2
19518: PPUSH
19519: EMPTY
19520: PPUSH
19521: CALL_OW 1
19525: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19526: LD_ADDR_EXP 71
19530: PUSH
19531: LD_EXP 71
19535: PPUSH
19536: LD_VAR 0 2
19540: PPUSH
19541: EMPTY
19542: PPUSH
19543: CALL_OW 1
19547: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19548: LD_ADDR_EXP 60
19552: PUSH
19553: LD_EXP 60
19557: PPUSH
19558: LD_VAR 0 2
19562: PPUSH
19563: LD_INT 0
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19571: LD_ADDR_EXP 73
19575: PUSH
19576: LD_EXP 73
19580: PPUSH
19581: LD_VAR 0 2
19585: PPUSH
19586: LD_INT 0
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19594: LD_ADDR_EXP 61
19598: PUSH
19599: LD_EXP 61
19603: PPUSH
19604: LD_VAR 0 2
19608: PPUSH
19609: EMPTY
19610: PPUSH
19611: CALL_OW 1
19615: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
19616: LD_ADDR_EXP 72
19620: PUSH
19621: LD_EXP 72
19625: PPUSH
19626: LD_VAR 0 2
19630: PPUSH
19631: LD_INT 0
19633: PPUSH
19634: CALL_OW 1
19638: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
19639: LD_ADDR_EXP 74
19643: PUSH
19644: LD_EXP 74
19648: PPUSH
19649: LD_VAR 0 2
19653: PPUSH
19654: EMPTY
19655: PPUSH
19656: CALL_OW 1
19660: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
19661: LD_ADDR_EXP 77
19665: PUSH
19666: LD_EXP 77
19670: PPUSH
19671: LD_VAR 0 2
19675: PPUSH
19676: LD_INT 0
19678: PPUSH
19679: CALL_OW 1
19683: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
19684: LD_ADDR_EXP 78
19688: PUSH
19689: LD_EXP 78
19693: PPUSH
19694: LD_VAR 0 2
19698: PPUSH
19699: EMPTY
19700: PPUSH
19701: CALL_OW 1
19705: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
19706: LD_ADDR_EXP 79
19710: PUSH
19711: LD_EXP 79
19715: PPUSH
19716: LD_VAR 0 2
19720: PPUSH
19721: EMPTY
19722: PPUSH
19723: CALL_OW 1
19727: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
19728: LD_ADDR_EXP 80
19732: PUSH
19733: LD_EXP 80
19737: PPUSH
19738: LD_VAR 0 2
19742: PPUSH
19743: EMPTY
19744: PPUSH
19745: CALL_OW 1
19749: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
19750: LD_ADDR_EXP 82
19754: PUSH
19755: LD_EXP 82
19759: PPUSH
19760: LD_VAR 0 2
19764: PPUSH
19765: LD_EXP 49
19769: PUSH
19770: LD_VAR 0 2
19774: ARRAY
19775: PPUSH
19776: LD_INT 2
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 6
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 7
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 30
19801: PUSH
19802: LD_INT 8
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: PPUSH
19815: CALL_OW 72
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
19825: LD_ADDR_EXP 83
19829: PUSH
19830: LD_EXP 83
19834: PPUSH
19835: LD_VAR 0 2
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
19847: LD_ADDR_EXP 84
19851: PUSH
19852: LD_EXP 84
19856: PPUSH
19857: LD_VAR 0 2
19861: PPUSH
19862: EMPTY
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
19869: LD_ADDR_EXP 85
19873: PUSH
19874: LD_EXP 85
19878: PPUSH
19879: LD_VAR 0 2
19883: PPUSH
19884: EMPTY
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
19891: LD_ADDR_EXP 86
19895: PUSH
19896: LD_EXP 86
19900: PPUSH
19901: LD_VAR 0 2
19905: PPUSH
19906: EMPTY
19907: PPUSH
19908: CALL_OW 1
19912: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
19913: LD_ADDR_EXP 87
19917: PUSH
19918: LD_EXP 87
19922: PPUSH
19923: LD_VAR 0 2
19927: PPUSH
19928: EMPTY
19929: PPUSH
19930: CALL_OW 1
19934: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
19935: LD_ADDR_EXP 88
19939: PUSH
19940: LD_EXP 88
19944: PPUSH
19945: LD_VAR 0 2
19949: PPUSH
19950: EMPTY
19951: PPUSH
19952: CALL_OW 1
19956: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
19957: LD_ADDR_EXP 89
19961: PUSH
19962: LD_EXP 89
19966: PPUSH
19967: LD_VAR 0 2
19971: PPUSH
19972: EMPTY
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
19979: LD_ADDR_EXP 90
19983: PUSH
19984: LD_EXP 90
19988: PPUSH
19989: LD_VAR 0 2
19993: PPUSH
19994: EMPTY
19995: PPUSH
19996: CALL_OW 1
20000: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20001: LD_ADDR_EXP 91
20005: PUSH
20006: LD_EXP 91
20010: PPUSH
20011: LD_VAR 0 2
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// end ;
20024: GO 18948
20026: POP
20027: POP
// MC_InitSides ( ) ;
20028: CALL 20314 0 0
// MC_InitResearch ( ) ;
20032: CALL 20053 0 0
// CustomInitMacro ( ) ;
20036: CALL 292 0 0
// skirmish := true ;
20040: LD_ADDR_EXP 47
20044: PUSH
20045: LD_INT 1
20047: ST_TO_ADDR
// end ;
20048: LD_VAR 0 1
20052: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20053: LD_INT 0
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
// if not mc_bases then
20061: LD_EXP 49
20065: NOT
20066: IFFALSE 20070
// exit ;
20068: GO 20309
// for i = 1 to 8 do
20070: LD_ADDR_VAR 0 2
20074: PUSH
20075: DOUBLE
20076: LD_INT 1
20078: DEC
20079: ST_TO_ADDR
20080: LD_INT 8
20082: PUSH
20083: FOR_TO
20084: IFFALSE 20110
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20086: LD_ADDR_EXP 76
20090: PUSH
20091: LD_EXP 76
20095: PPUSH
20096: LD_VAR 0 2
20100: PPUSH
20101: EMPTY
20102: PPUSH
20103: CALL_OW 1
20107: ST_TO_ADDR
20108: GO 20083
20110: POP
20111: POP
// tmp := [ ] ;
20112: LD_ADDR_VAR 0 5
20116: PUSH
20117: EMPTY
20118: ST_TO_ADDR
// for i = 1 to mc_sides do
20119: LD_ADDR_VAR 0 2
20123: PUSH
20124: DOUBLE
20125: LD_INT 1
20127: DEC
20128: ST_TO_ADDR
20129: LD_EXP 75
20133: PUSH
20134: FOR_TO
20135: IFFALSE 20193
// if not mc_sides [ i ] in tmp then
20137: LD_EXP 75
20141: PUSH
20142: LD_VAR 0 2
20146: ARRAY
20147: PUSH
20148: LD_VAR 0 5
20152: IN
20153: NOT
20154: IFFALSE 20191
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20156: LD_ADDR_VAR 0 5
20160: PUSH
20161: LD_VAR 0 5
20165: PPUSH
20166: LD_VAR 0 5
20170: PUSH
20171: LD_INT 1
20173: PLUS
20174: PPUSH
20175: LD_EXP 75
20179: PUSH
20180: LD_VAR 0 2
20184: ARRAY
20185: PPUSH
20186: CALL_OW 2
20190: ST_TO_ADDR
20191: GO 20134
20193: POP
20194: POP
// if not tmp then
20195: LD_VAR 0 5
20199: NOT
20200: IFFALSE 20204
// exit ;
20202: GO 20309
// for j in tmp do
20204: LD_ADDR_VAR 0 3
20208: PUSH
20209: LD_VAR 0 5
20213: PUSH
20214: FOR_IN
20215: IFFALSE 20307
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20217: LD_ADDR_VAR 0 6
20221: PUSH
20222: LD_INT 22
20224: PUSH
20225: LD_VAR 0 3
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: PPUSH
20234: CALL_OW 69
20238: ST_TO_ADDR
// if not un then
20239: LD_VAR 0 6
20243: NOT
20244: IFFALSE 20248
// continue ;
20246: GO 20214
// nation := GetNation ( un [ 1 ] ) ;
20248: LD_ADDR_VAR 0 4
20252: PUSH
20253: LD_VAR 0 6
20257: PUSH
20258: LD_INT 1
20260: ARRAY
20261: PPUSH
20262: CALL_OW 248
20266: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20267: LD_ADDR_EXP 76
20271: PUSH
20272: LD_EXP 76
20276: PPUSH
20277: LD_VAR 0 3
20281: PPUSH
20282: LD_VAR 0 3
20286: PPUSH
20287: LD_VAR 0 4
20291: PPUSH
20292: LD_INT 1
20294: PPUSH
20295: CALL 47023 0 3
20299: PPUSH
20300: CALL_OW 1
20304: ST_TO_ADDR
// end ;
20305: GO 20214
20307: POP
20308: POP
// end ;
20309: LD_VAR 0 1
20313: RET
// export function MC_InitSides ( ) ; var i ; begin
20314: LD_INT 0
20316: PPUSH
20317: PPUSH
// if not mc_bases then
20318: LD_EXP 49
20322: NOT
20323: IFFALSE 20327
// exit ;
20325: GO 20401
// for i = 1 to mc_bases do
20327: LD_ADDR_VAR 0 2
20331: PUSH
20332: DOUBLE
20333: LD_INT 1
20335: DEC
20336: ST_TO_ADDR
20337: LD_EXP 49
20341: PUSH
20342: FOR_TO
20343: IFFALSE 20399
// if mc_bases [ i ] then
20345: LD_EXP 49
20349: PUSH
20350: LD_VAR 0 2
20354: ARRAY
20355: IFFALSE 20397
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20357: LD_ADDR_EXP 75
20361: PUSH
20362: LD_EXP 75
20366: PPUSH
20367: LD_VAR 0 2
20371: PPUSH
20372: LD_EXP 49
20376: PUSH
20377: LD_VAR 0 2
20381: ARRAY
20382: PUSH
20383: LD_INT 1
20385: ARRAY
20386: PPUSH
20387: CALL_OW 255
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
20397: GO 20342
20399: POP
20400: POP
// end ;
20401: LD_VAR 0 1
20405: RET
// every 0 0$01 trigger skirmish do
20406: LD_EXP 47
20410: IFFALSE 20564
20412: GO 20414
20414: DISABLE
// begin enable ;
20415: ENABLE
// MC_CheckBuildings ( ) ;
20416: CALL 25062 0 0
// MC_CheckPeopleLife ( ) ;
20420: CALL 25187 0 0
// RaiseSailEvent ( 100 ) ;
20424: LD_INT 100
20426: PPUSH
20427: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20431: LD_INT 103
20433: PPUSH
20434: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20438: LD_INT 104
20440: PPUSH
20441: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20445: LD_INT 105
20447: PPUSH
20448: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20452: LD_INT 106
20454: PPUSH
20455: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20459: LD_INT 107
20461: PPUSH
20462: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20466: LD_INT 108
20468: PPUSH
20469: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20473: LD_INT 109
20475: PPUSH
20476: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20480: LD_INT 110
20482: PPUSH
20483: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20487: LD_INT 111
20489: PPUSH
20490: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20494: LD_INT 112
20496: PPUSH
20497: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20501: LD_INT 113
20503: PPUSH
20504: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20508: LD_INT 120
20510: PPUSH
20511: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20515: LD_INT 121
20517: PPUSH
20518: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20522: LD_INT 122
20524: PPUSH
20525: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20529: LD_INT 123
20531: PPUSH
20532: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20536: LD_INT 124
20538: PPUSH
20539: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20543: LD_INT 125
20545: PPUSH
20546: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20550: LD_INT 126
20552: PPUSH
20553: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20557: LD_INT 200
20559: PPUSH
20560: CALL_OW 427
// end ;
20564: END
// on SailEvent ( event ) do begin if event < 100 then
20565: LD_VAR 0 1
20569: PUSH
20570: LD_INT 100
20572: LESS
20573: IFFALSE 20584
// CustomEvent ( event ) ;
20575: LD_VAR 0 1
20579: PPUSH
20580: CALL 16106 0 1
// if event = 100 then
20584: LD_VAR 0 1
20588: PUSH
20589: LD_INT 100
20591: EQUAL
20592: IFFALSE 20598
// MC_ClassManager ( ) ;
20594: CALL 20990 0 0
// if event = 101 then
20598: LD_VAR 0 1
20602: PUSH
20603: LD_INT 101
20605: EQUAL
20606: IFFALSE 20612
// MC_RepairBuildings ( ) ;
20608: CALL 25783 0 0
// if event = 102 then
20612: LD_VAR 0 1
20616: PUSH
20617: LD_INT 102
20619: EQUAL
20620: IFFALSE 20626
// MC_Heal ( ) ;
20622: CALL 26515 0 0
// if event = 103 then
20626: LD_VAR 0 1
20630: PUSH
20631: LD_INT 103
20633: EQUAL
20634: IFFALSE 20640
// MC_Build ( ) ;
20636: CALL 26937 0 0
// if event = 104 then
20640: LD_VAR 0 1
20644: PUSH
20645: LD_INT 104
20647: EQUAL
20648: IFFALSE 20654
// MC_TurretWeapon ( ) ;
20650: CALL 28550 0 0
// if event = 105 then
20654: LD_VAR 0 1
20658: PUSH
20659: LD_INT 105
20661: EQUAL
20662: IFFALSE 20668
// MC_BuildUpgrade ( ) ;
20664: CALL 28101 0 0
// if event = 106 then
20668: LD_VAR 0 1
20672: PUSH
20673: LD_INT 106
20675: EQUAL
20676: IFFALSE 20682
// MC_PlantMines ( ) ;
20678: CALL 28980 0 0
// if event = 107 then
20682: LD_VAR 0 1
20686: PUSH
20687: LD_INT 107
20689: EQUAL
20690: IFFALSE 20696
// MC_CollectCrates ( ) ;
20692: CALL 30014 0 0
// if event = 108 then
20696: LD_VAR 0 1
20700: PUSH
20701: LD_INT 108
20703: EQUAL
20704: IFFALSE 20710
// MC_LinkRemoteControl ( ) ;
20706: CALL 31790 0 0
// if event = 109 then
20710: LD_VAR 0 1
20714: PUSH
20715: LD_INT 109
20717: EQUAL
20718: IFFALSE 20724
// MC_ProduceVehicle ( ) ;
20720: CALL 31971 0 0
// if event = 110 then
20724: LD_VAR 0 1
20728: PUSH
20729: LD_INT 110
20731: EQUAL
20732: IFFALSE 20738
// MC_SendAttack ( ) ;
20734: CALL 32437 0 0
// if event = 111 then
20738: LD_VAR 0 1
20742: PUSH
20743: LD_INT 111
20745: EQUAL
20746: IFFALSE 20752
// MC_Defend ( ) ;
20748: CALL 32545 0 0
// if event = 112 then
20752: LD_VAR 0 1
20756: PUSH
20757: LD_INT 112
20759: EQUAL
20760: IFFALSE 20766
// MC_Research ( ) ;
20762: CALL 33150 0 0
// if event = 113 then
20766: LD_VAR 0 1
20770: PUSH
20771: LD_INT 113
20773: EQUAL
20774: IFFALSE 20780
// MC_MinesTrigger ( ) ;
20776: CALL 34264 0 0
// if event = 120 then
20780: LD_VAR 0 1
20784: PUSH
20785: LD_INT 120
20787: EQUAL
20788: IFFALSE 20794
// MC_RepairVehicle ( ) ;
20790: CALL 34363 0 0
// if event = 121 then
20794: LD_VAR 0 1
20798: PUSH
20799: LD_INT 121
20801: EQUAL
20802: IFFALSE 20808
// MC_TameApe ( ) ;
20804: CALL 35093 0 0
// if event = 122 then
20808: LD_VAR 0 1
20812: PUSH
20813: LD_INT 122
20815: EQUAL
20816: IFFALSE 20822
// MC_ChangeApeClass ( ) ;
20818: CALL 35922 0 0
// if event = 123 then
20822: LD_VAR 0 1
20826: PUSH
20827: LD_INT 123
20829: EQUAL
20830: IFFALSE 20836
// MC_Bazooka ( ) ;
20832: CALL 36572 0 0
// if event = 124 then
20836: LD_VAR 0 1
20840: PUSH
20841: LD_INT 124
20843: EQUAL
20844: IFFALSE 20850
// MC_TeleportExit ( ) ;
20846: CALL 36770 0 0
// if event = 125 then
20850: LD_VAR 0 1
20854: PUSH
20855: LD_INT 125
20857: EQUAL
20858: IFFALSE 20864
// MC_Deposits ( ) ;
20860: CALL 37417 0 0
// if event = 126 then
20864: LD_VAR 0 1
20868: PUSH
20869: LD_INT 126
20871: EQUAL
20872: IFFALSE 20878
// MC_RemoteDriver ( ) ;
20874: CALL 38042 0 0
// if event = 200 then
20878: LD_VAR 0 1
20882: PUSH
20883: LD_INT 200
20885: EQUAL
20886: IFFALSE 20892
// MC_Idle ( ) ;
20888: CALL 39991 0 0
// end ;
20892: PPOPN 1
20894: END
// export function MC_Reset ( base , tag ) ; var i ; begin
20895: LD_INT 0
20897: PPUSH
20898: PPUSH
// if not mc_bases [ base ] or not tag then
20899: LD_EXP 49
20903: PUSH
20904: LD_VAR 0 1
20908: ARRAY
20909: NOT
20910: PUSH
20911: LD_VAR 0 2
20915: NOT
20916: OR
20917: IFFALSE 20921
// exit ;
20919: GO 20985
// for i in mc_bases [ base ] union mc_ape [ base ] do
20921: LD_ADDR_VAR 0 4
20925: PUSH
20926: LD_EXP 49
20930: PUSH
20931: LD_VAR 0 1
20935: ARRAY
20936: PUSH
20937: LD_EXP 78
20941: PUSH
20942: LD_VAR 0 1
20946: ARRAY
20947: UNION
20948: PUSH
20949: FOR_IN
20950: IFFALSE 20983
// if GetTag ( i ) = tag then
20952: LD_VAR 0 4
20956: PPUSH
20957: CALL_OW 110
20961: PUSH
20962: LD_VAR 0 2
20966: EQUAL
20967: IFFALSE 20981
// SetTag ( i , 0 ) ;
20969: LD_VAR 0 4
20973: PPUSH
20974: LD_INT 0
20976: PPUSH
20977: CALL_OW 109
20981: GO 20949
20983: POP
20984: POP
// end ;
20985: LD_VAR 0 3
20989: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
20990: LD_INT 0
20992: PPUSH
20993: PPUSH
20994: PPUSH
20995: PPUSH
20996: PPUSH
20997: PPUSH
20998: PPUSH
20999: PPUSH
// if not mc_bases then
21000: LD_EXP 49
21004: NOT
21005: IFFALSE 21009
// exit ;
21007: GO 21467
// for i = 1 to mc_bases do
21009: LD_ADDR_VAR 0 2
21013: PUSH
21014: DOUBLE
21015: LD_INT 1
21017: DEC
21018: ST_TO_ADDR
21019: LD_EXP 49
21023: PUSH
21024: FOR_TO
21025: IFFALSE 21465
// begin tmp := MC_ClassCheckReq ( i ) ;
21027: LD_ADDR_VAR 0 4
21031: PUSH
21032: LD_VAR 0 2
21036: PPUSH
21037: CALL 21472 0 1
21041: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21042: LD_ADDR_EXP 90
21046: PUSH
21047: LD_EXP 90
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: LD_VAR 0 4
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// if not tmp then
21067: LD_VAR 0 4
21071: NOT
21072: IFFALSE 21076
// continue ;
21074: GO 21024
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21076: LD_ADDR_VAR 0 6
21080: PUSH
21081: LD_EXP 49
21085: PUSH
21086: LD_VAR 0 2
21090: ARRAY
21091: PPUSH
21092: LD_INT 2
21094: PUSH
21095: LD_INT 30
21097: PUSH
21098: LD_INT 4
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: LD_INT 30
21107: PUSH
21108: LD_INT 5
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: LIST
21119: PPUSH
21120: CALL_OW 72
21124: PUSH
21125: LD_EXP 49
21129: PUSH
21130: LD_VAR 0 2
21134: ARRAY
21135: PPUSH
21136: LD_INT 2
21138: PUSH
21139: LD_INT 30
21141: PUSH
21142: LD_INT 0
21144: PUSH
21145: EMPTY
21146: LIST
21147: LIST
21148: PUSH
21149: LD_INT 30
21151: PUSH
21152: LD_INT 1
21154: PUSH
21155: EMPTY
21156: LIST
21157: LIST
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: LIST
21163: PPUSH
21164: CALL_OW 72
21168: PUSH
21169: LD_EXP 49
21173: PUSH
21174: LD_VAR 0 2
21178: ARRAY
21179: PPUSH
21180: LD_INT 30
21182: PUSH
21183: LD_INT 3
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PPUSH
21190: CALL_OW 72
21194: PUSH
21195: LD_EXP 49
21199: PUSH
21200: LD_VAR 0 2
21204: ARRAY
21205: PPUSH
21206: LD_INT 2
21208: PUSH
21209: LD_INT 30
21211: PUSH
21212: LD_INT 6
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PUSH
21219: LD_INT 30
21221: PUSH
21222: LD_INT 7
21224: PUSH
21225: EMPTY
21226: LIST
21227: LIST
21228: PUSH
21229: LD_INT 30
21231: PUSH
21232: LD_INT 8
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: PPUSH
21245: CALL_OW 72
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: LIST
21254: LIST
21255: ST_TO_ADDR
// for j = 1 to 4 do
21256: LD_ADDR_VAR 0 3
21260: PUSH
21261: DOUBLE
21262: LD_INT 1
21264: DEC
21265: ST_TO_ADDR
21266: LD_INT 4
21268: PUSH
21269: FOR_TO
21270: IFFALSE 21461
// begin if not tmp [ j ] then
21272: LD_VAR 0 4
21276: PUSH
21277: LD_VAR 0 3
21281: ARRAY
21282: NOT
21283: IFFALSE 21287
// continue ;
21285: GO 21269
// for p in tmp [ j ] do
21287: LD_ADDR_VAR 0 5
21291: PUSH
21292: LD_VAR 0 4
21296: PUSH
21297: LD_VAR 0 3
21301: ARRAY
21302: PUSH
21303: FOR_IN
21304: IFFALSE 21457
// begin if not b [ j ] then
21306: LD_VAR 0 6
21310: PUSH
21311: LD_VAR 0 3
21315: ARRAY
21316: NOT
21317: IFFALSE 21321
// break ;
21319: GO 21457
// e := 0 ;
21321: LD_ADDR_VAR 0 7
21325: PUSH
21326: LD_INT 0
21328: ST_TO_ADDR
// for k in b [ j ] do
21329: LD_ADDR_VAR 0 8
21333: PUSH
21334: LD_VAR 0 6
21338: PUSH
21339: LD_VAR 0 3
21343: ARRAY
21344: PUSH
21345: FOR_IN
21346: IFFALSE 21373
// if IsNotFull ( k ) then
21348: LD_VAR 0 8
21352: PPUSH
21353: CALL 51374 0 1
21357: IFFALSE 21371
// begin e := k ;
21359: LD_ADDR_VAR 0 7
21363: PUSH
21364: LD_VAR 0 8
21368: ST_TO_ADDR
// break ;
21369: GO 21373
// end ;
21371: GO 21345
21373: POP
21374: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21375: LD_VAR 0 7
21379: PUSH
21380: LD_VAR 0 5
21384: PPUSH
21385: LD_VAR 0 7
21389: PPUSH
21390: CALL 88493 0 2
21394: NOT
21395: AND
21396: IFFALSE 21455
// begin if IsInUnit ( p ) then
21398: LD_VAR 0 5
21402: PPUSH
21403: CALL_OW 310
21407: IFFALSE 21418
// ComExitBuilding ( p ) ;
21409: LD_VAR 0 5
21413: PPUSH
21414: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21418: LD_VAR 0 5
21422: PPUSH
21423: LD_VAR 0 7
21427: PPUSH
21428: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21432: LD_VAR 0 5
21436: PPUSH
21437: LD_VAR 0 3
21441: PPUSH
21442: CALL_OW 183
// AddComExitBuilding ( p ) ;
21446: LD_VAR 0 5
21450: PPUSH
21451: CALL_OW 182
// end ; end ;
21455: GO 21303
21457: POP
21458: POP
// end ;
21459: GO 21269
21461: POP
21462: POP
// end ;
21463: GO 21024
21465: POP
21466: POP
// end ;
21467: LD_VAR 0 1
21471: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21472: LD_INT 0
21474: PPUSH
21475: PPUSH
21476: PPUSH
21477: PPUSH
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
21482: PPUSH
21483: PPUSH
21484: PPUSH
21485: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21486: LD_VAR 0 1
21490: NOT
21491: PUSH
21492: LD_EXP 49
21496: PUSH
21497: LD_VAR 0 1
21501: ARRAY
21502: NOT
21503: OR
21504: PUSH
21505: LD_EXP 49
21509: PUSH
21510: LD_VAR 0 1
21514: ARRAY
21515: PPUSH
21516: LD_INT 2
21518: PUSH
21519: LD_INT 30
21521: PUSH
21522: LD_INT 0
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: PUSH
21529: LD_INT 30
21531: PUSH
21532: LD_INT 1
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: PPUSH
21544: CALL_OW 72
21548: NOT
21549: OR
21550: IFFALSE 21554
// exit ;
21552: GO 25057
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21554: LD_ADDR_VAR 0 4
21558: PUSH
21559: LD_EXP 49
21563: PUSH
21564: LD_VAR 0 1
21568: ARRAY
21569: PPUSH
21570: LD_INT 2
21572: PUSH
21573: LD_INT 25
21575: PUSH
21576: LD_INT 1
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: LD_INT 25
21585: PUSH
21586: LD_INT 2
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 25
21595: PUSH
21596: LD_INT 3
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: PUSH
21603: LD_INT 25
21605: PUSH
21606: LD_INT 4
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 25
21615: PUSH
21616: LD_INT 5
21618: PUSH
21619: EMPTY
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 25
21625: PUSH
21626: LD_INT 8
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PUSH
21633: LD_INT 25
21635: PUSH
21636: LD_INT 9
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 72
21657: ST_TO_ADDR
// if not tmp then
21658: LD_VAR 0 4
21662: NOT
21663: IFFALSE 21667
// exit ;
21665: GO 25057
// for i in tmp do
21667: LD_ADDR_VAR 0 3
21671: PUSH
21672: LD_VAR 0 4
21676: PUSH
21677: FOR_IN
21678: IFFALSE 21709
// if GetTag ( i ) then
21680: LD_VAR 0 3
21684: PPUSH
21685: CALL_OW 110
21689: IFFALSE 21707
// tmp := tmp diff i ;
21691: LD_ADDR_VAR 0 4
21695: PUSH
21696: LD_VAR 0 4
21700: PUSH
21701: LD_VAR 0 3
21705: DIFF
21706: ST_TO_ADDR
21707: GO 21677
21709: POP
21710: POP
// if not tmp then
21711: LD_VAR 0 4
21715: NOT
21716: IFFALSE 21720
// exit ;
21718: GO 25057
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21720: LD_ADDR_VAR 0 5
21724: PUSH
21725: LD_EXP 49
21729: PUSH
21730: LD_VAR 0 1
21734: ARRAY
21735: PPUSH
21736: LD_INT 2
21738: PUSH
21739: LD_INT 25
21741: PUSH
21742: LD_INT 1
21744: PUSH
21745: EMPTY
21746: LIST
21747: LIST
21748: PUSH
21749: LD_INT 25
21751: PUSH
21752: LD_INT 5
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 25
21761: PUSH
21762: LD_INT 8
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 25
21771: PUSH
21772: LD_INT 9
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: PUSH
21779: EMPTY
21780: LIST
21781: LIST
21782: LIST
21783: LIST
21784: LIST
21785: PPUSH
21786: CALL_OW 72
21790: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
21791: LD_ADDR_VAR 0 6
21795: PUSH
21796: LD_EXP 49
21800: PUSH
21801: LD_VAR 0 1
21805: ARRAY
21806: PPUSH
21807: LD_INT 25
21809: PUSH
21810: LD_INT 2
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PPUSH
21817: CALL_OW 72
21821: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
21822: LD_ADDR_VAR 0 7
21826: PUSH
21827: LD_EXP 49
21831: PUSH
21832: LD_VAR 0 1
21836: ARRAY
21837: PPUSH
21838: LD_INT 25
21840: PUSH
21841: LD_INT 3
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PPUSH
21848: CALL_OW 72
21852: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
21853: LD_ADDR_VAR 0 8
21857: PUSH
21858: LD_EXP 49
21862: PUSH
21863: LD_VAR 0 1
21867: ARRAY
21868: PPUSH
21869: LD_INT 25
21871: PUSH
21872: LD_INT 4
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: PUSH
21879: LD_INT 24
21881: PUSH
21882: LD_INT 251
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: PPUSH
21893: CALL_OW 72
21897: ST_TO_ADDR
// if mc_scan [ base ] then
21898: LD_EXP 72
21902: PUSH
21903: LD_VAR 0 1
21907: ARRAY
21908: IFFALSE 22369
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
21910: LD_ADDR_EXP 91
21914: PUSH
21915: LD_EXP 91
21919: PPUSH
21920: LD_VAR 0 1
21924: PPUSH
21925: LD_INT 4
21927: PPUSH
21928: CALL_OW 1
21932: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
21933: LD_ADDR_VAR 0 12
21937: PUSH
21938: LD_EXP 49
21942: PUSH
21943: LD_VAR 0 1
21947: ARRAY
21948: PPUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PPUSH
21977: CALL_OW 72
21981: ST_TO_ADDR
// if not b then
21982: LD_VAR 0 12
21986: NOT
21987: IFFALSE 21991
// exit ;
21989: GO 25057
// p := [ ] ;
21991: LD_ADDR_VAR 0 11
21995: PUSH
21996: EMPTY
21997: ST_TO_ADDR
// if sci >= 2 then
21998: LD_VAR 0 8
22002: PUSH
22003: LD_INT 2
22005: GREATEREQUAL
22006: IFFALSE 22037
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22008: LD_ADDR_VAR 0 8
22012: PUSH
22013: LD_VAR 0 8
22017: PUSH
22018: LD_INT 1
22020: ARRAY
22021: PUSH
22022: LD_VAR 0 8
22026: PUSH
22027: LD_INT 2
22029: ARRAY
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: ST_TO_ADDR
22035: GO 22098
// if sci = 1 then
22037: LD_VAR 0 8
22041: PUSH
22042: LD_INT 1
22044: EQUAL
22045: IFFALSE 22066
// sci := [ sci [ 1 ] ] else
22047: LD_ADDR_VAR 0 8
22051: PUSH
22052: LD_VAR 0 8
22056: PUSH
22057: LD_INT 1
22059: ARRAY
22060: PUSH
22061: EMPTY
22062: LIST
22063: ST_TO_ADDR
22064: GO 22098
// if sci = 0 then
22066: LD_VAR 0 8
22070: PUSH
22071: LD_INT 0
22073: EQUAL
22074: IFFALSE 22098
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22076: LD_ADDR_VAR 0 11
22080: PUSH
22081: LD_VAR 0 4
22085: PPUSH
22086: LD_INT 4
22088: PPUSH
22089: CALL 88356 0 2
22093: PUSH
22094: LD_INT 1
22096: ARRAY
22097: ST_TO_ADDR
// if eng > 4 then
22098: LD_VAR 0 6
22102: PUSH
22103: LD_INT 4
22105: GREATER
22106: IFFALSE 22152
// for i = eng downto 4 do
22108: LD_ADDR_VAR 0 3
22112: PUSH
22113: DOUBLE
22114: LD_VAR 0 6
22118: INC
22119: ST_TO_ADDR
22120: LD_INT 4
22122: PUSH
22123: FOR_DOWNTO
22124: IFFALSE 22150
// eng := eng diff eng [ i ] ;
22126: LD_ADDR_VAR 0 6
22130: PUSH
22131: LD_VAR 0 6
22135: PUSH
22136: LD_VAR 0 6
22140: PUSH
22141: LD_VAR 0 3
22145: ARRAY
22146: DIFF
22147: ST_TO_ADDR
22148: GO 22123
22150: POP
22151: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22152: LD_ADDR_VAR 0 4
22156: PUSH
22157: LD_VAR 0 4
22161: PUSH
22162: LD_VAR 0 5
22166: PUSH
22167: LD_VAR 0 6
22171: UNION
22172: PUSH
22173: LD_VAR 0 7
22177: UNION
22178: PUSH
22179: LD_VAR 0 8
22183: UNION
22184: DIFF
22185: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22186: LD_ADDR_VAR 0 13
22190: PUSH
22191: LD_EXP 49
22195: PUSH
22196: LD_VAR 0 1
22200: ARRAY
22201: PPUSH
22202: LD_INT 2
22204: PUSH
22205: LD_INT 30
22207: PUSH
22208: LD_INT 32
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: PUSH
22215: LD_INT 30
22217: PUSH
22218: LD_INT 31
22220: PUSH
22221: EMPTY
22222: LIST
22223: LIST
22224: PUSH
22225: EMPTY
22226: LIST
22227: LIST
22228: LIST
22229: PPUSH
22230: CALL_OW 72
22234: PUSH
22235: LD_EXP 49
22239: PUSH
22240: LD_VAR 0 1
22244: ARRAY
22245: PPUSH
22246: LD_INT 2
22248: PUSH
22249: LD_INT 30
22251: PUSH
22252: LD_INT 4
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: PUSH
22259: LD_INT 30
22261: PUSH
22262: LD_INT 5
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: LIST
22273: PPUSH
22274: CALL_OW 72
22278: PUSH
22279: LD_INT 6
22281: MUL
22282: PLUS
22283: ST_TO_ADDR
// if bcount < tmp then
22284: LD_VAR 0 13
22288: PUSH
22289: LD_VAR 0 4
22293: LESS
22294: IFFALSE 22340
// for i = tmp downto bcount do
22296: LD_ADDR_VAR 0 3
22300: PUSH
22301: DOUBLE
22302: LD_VAR 0 4
22306: INC
22307: ST_TO_ADDR
22308: LD_VAR 0 13
22312: PUSH
22313: FOR_DOWNTO
22314: IFFALSE 22338
// tmp := Delete ( tmp , tmp ) ;
22316: LD_ADDR_VAR 0 4
22320: PUSH
22321: LD_VAR 0 4
22325: PPUSH
22326: LD_VAR 0 4
22330: PPUSH
22331: CALL_OW 3
22335: ST_TO_ADDR
22336: GO 22313
22338: POP
22339: POP
// result := [ tmp , 0 , 0 , p ] ;
22340: LD_ADDR_VAR 0 2
22344: PUSH
22345: LD_VAR 0 4
22349: PUSH
22350: LD_INT 0
22352: PUSH
22353: LD_INT 0
22355: PUSH
22356: LD_VAR 0 11
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: ST_TO_ADDR
// exit ;
22367: GO 25057
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22369: LD_EXP 49
22373: PUSH
22374: LD_VAR 0 1
22378: ARRAY
22379: PPUSH
22380: LD_INT 2
22382: PUSH
22383: LD_INT 30
22385: PUSH
22386: LD_INT 6
22388: PUSH
22389: EMPTY
22390: LIST
22391: LIST
22392: PUSH
22393: LD_INT 30
22395: PUSH
22396: LD_INT 7
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 8
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: LIST
22417: LIST
22418: PPUSH
22419: CALL_OW 72
22423: NOT
22424: PUSH
22425: LD_EXP 49
22429: PUSH
22430: LD_VAR 0 1
22434: ARRAY
22435: PPUSH
22436: LD_INT 30
22438: PUSH
22439: LD_INT 3
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PPUSH
22446: CALL_OW 72
22450: NOT
22451: AND
22452: IFFALSE 22524
// begin if eng = tmp then
22454: LD_VAR 0 6
22458: PUSH
22459: LD_VAR 0 4
22463: EQUAL
22464: IFFALSE 22468
// exit ;
22466: GO 25057
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22468: LD_ADDR_EXP 91
22472: PUSH
22473: LD_EXP 91
22477: PPUSH
22478: LD_VAR 0 1
22482: PPUSH
22483: LD_INT 1
22485: PPUSH
22486: CALL_OW 1
22490: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22491: LD_ADDR_VAR 0 2
22495: PUSH
22496: LD_INT 0
22498: PUSH
22499: LD_VAR 0 4
22503: PUSH
22504: LD_VAR 0 6
22508: DIFF
22509: PUSH
22510: LD_INT 0
22512: PUSH
22513: LD_INT 0
22515: PUSH
22516: EMPTY
22517: LIST
22518: LIST
22519: LIST
22520: LIST
22521: ST_TO_ADDR
// exit ;
22522: GO 25057
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22524: LD_EXP 76
22528: PUSH
22529: LD_EXP 75
22533: PUSH
22534: LD_VAR 0 1
22538: ARRAY
22539: ARRAY
22540: PUSH
22541: LD_EXP 49
22545: PUSH
22546: LD_VAR 0 1
22550: ARRAY
22551: PPUSH
22552: LD_INT 2
22554: PUSH
22555: LD_INT 30
22557: PUSH
22558: LD_INT 6
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 30
22567: PUSH
22568: LD_INT 7
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PUSH
22575: LD_INT 30
22577: PUSH
22578: LD_INT 8
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: LIST
22589: LIST
22590: PPUSH
22591: CALL_OW 72
22595: AND
22596: PUSH
22597: LD_EXP 49
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PPUSH
22608: LD_INT 30
22610: PUSH
22611: LD_INT 3
22613: PUSH
22614: EMPTY
22615: LIST
22616: LIST
22617: PPUSH
22618: CALL_OW 72
22622: NOT
22623: AND
22624: IFFALSE 22838
// begin if sci >= 6 then
22626: LD_VAR 0 8
22630: PUSH
22631: LD_INT 6
22633: GREATEREQUAL
22634: IFFALSE 22638
// exit ;
22636: GO 25057
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
22638: LD_ADDR_EXP 91
22642: PUSH
22643: LD_EXP 91
22647: PPUSH
22648: LD_VAR 0 1
22652: PPUSH
22653: LD_INT 2
22655: PPUSH
22656: CALL_OW 1
22660: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
22661: LD_ADDR_VAR 0 9
22665: PUSH
22666: LD_VAR 0 4
22670: PUSH
22671: LD_VAR 0 8
22675: DIFF
22676: PPUSH
22677: LD_INT 4
22679: PPUSH
22680: CALL 88356 0 2
22684: ST_TO_ADDR
// p := [ ] ;
22685: LD_ADDR_VAR 0 11
22689: PUSH
22690: EMPTY
22691: ST_TO_ADDR
// if sci < 6 and sort > 6 then
22692: LD_VAR 0 8
22696: PUSH
22697: LD_INT 6
22699: LESS
22700: PUSH
22701: LD_VAR 0 9
22705: PUSH
22706: LD_INT 6
22708: GREATER
22709: AND
22710: IFFALSE 22791
// begin for i = 1 to 6 - sci do
22712: LD_ADDR_VAR 0 3
22716: PUSH
22717: DOUBLE
22718: LD_INT 1
22720: DEC
22721: ST_TO_ADDR
22722: LD_INT 6
22724: PUSH
22725: LD_VAR 0 8
22729: MINUS
22730: PUSH
22731: FOR_TO
22732: IFFALSE 22787
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
22734: LD_ADDR_VAR 0 11
22738: PUSH
22739: LD_VAR 0 11
22743: PPUSH
22744: LD_VAR 0 11
22748: PUSH
22749: LD_INT 1
22751: PLUS
22752: PPUSH
22753: LD_VAR 0 9
22757: PUSH
22758: LD_INT 1
22760: ARRAY
22761: PPUSH
22762: CALL_OW 2
22766: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
22767: LD_ADDR_VAR 0 9
22771: PUSH
22772: LD_VAR 0 9
22776: PPUSH
22777: LD_INT 1
22779: PPUSH
22780: CALL_OW 3
22784: ST_TO_ADDR
// end ;
22785: GO 22731
22787: POP
22788: POP
// end else
22789: GO 22811
// if sort then
22791: LD_VAR 0 9
22795: IFFALSE 22811
// p := sort [ 1 ] ;
22797: LD_ADDR_VAR 0 11
22801: PUSH
22802: LD_VAR 0 9
22806: PUSH
22807: LD_INT 1
22809: ARRAY
22810: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
22811: LD_ADDR_VAR 0 2
22815: PUSH
22816: LD_INT 0
22818: PUSH
22819: LD_INT 0
22821: PUSH
22822: LD_INT 0
22824: PUSH
22825: LD_VAR 0 11
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
// exit ;
22836: GO 25057
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22838: LD_EXP 76
22842: PUSH
22843: LD_EXP 75
22847: PUSH
22848: LD_VAR 0 1
22852: ARRAY
22853: ARRAY
22854: PUSH
22855: LD_EXP 49
22859: PUSH
22860: LD_VAR 0 1
22864: ARRAY
22865: PPUSH
22866: LD_INT 2
22868: PUSH
22869: LD_INT 30
22871: PUSH
22872: LD_INT 6
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: LD_INT 30
22881: PUSH
22882: LD_INT 7
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 8
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: PPUSH
22905: CALL_OW 72
22909: AND
22910: PUSH
22911: LD_EXP 49
22915: PUSH
22916: LD_VAR 0 1
22920: ARRAY
22921: PPUSH
22922: LD_INT 30
22924: PUSH
22925: LD_INT 3
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 72
22936: AND
22937: IFFALSE 23671
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
22939: LD_ADDR_EXP 91
22943: PUSH
22944: LD_EXP 91
22948: PPUSH
22949: LD_VAR 0 1
22953: PPUSH
22954: LD_INT 3
22956: PPUSH
22957: CALL_OW 1
22961: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22962: LD_ADDR_VAR 0 2
22966: PUSH
22967: LD_INT 0
22969: PUSH
22970: LD_INT 0
22972: PUSH
22973: LD_INT 0
22975: PUSH
22976: LD_INT 0
22978: PUSH
22979: EMPTY
22980: LIST
22981: LIST
22982: LIST
22983: LIST
22984: ST_TO_ADDR
// if not eng then
22985: LD_VAR 0 6
22989: NOT
22990: IFFALSE 23053
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
22992: LD_ADDR_VAR 0 11
22996: PUSH
22997: LD_VAR 0 4
23001: PPUSH
23002: LD_INT 2
23004: PPUSH
23005: CALL 88356 0 2
23009: PUSH
23010: LD_INT 1
23012: ARRAY
23013: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23014: LD_ADDR_VAR 0 2
23018: PUSH
23019: LD_VAR 0 2
23023: PPUSH
23024: LD_INT 2
23026: PPUSH
23027: LD_VAR 0 11
23031: PPUSH
23032: CALL_OW 1
23036: ST_TO_ADDR
// tmp := tmp diff p ;
23037: LD_ADDR_VAR 0 4
23041: PUSH
23042: LD_VAR 0 4
23046: PUSH
23047: LD_VAR 0 11
23051: DIFF
23052: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23053: LD_VAR 0 4
23057: PUSH
23058: LD_VAR 0 8
23062: PUSH
23063: LD_INT 6
23065: LESS
23066: AND
23067: IFFALSE 23255
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23069: LD_ADDR_VAR 0 9
23073: PUSH
23074: LD_VAR 0 4
23078: PUSH
23079: LD_VAR 0 8
23083: PUSH
23084: LD_VAR 0 7
23088: UNION
23089: DIFF
23090: PPUSH
23091: LD_INT 4
23093: PPUSH
23094: CALL 88356 0 2
23098: ST_TO_ADDR
// p := [ ] ;
23099: LD_ADDR_VAR 0 11
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// if sort then
23106: LD_VAR 0 9
23110: IFFALSE 23226
// for i = 1 to 6 - sci do
23112: LD_ADDR_VAR 0 3
23116: PUSH
23117: DOUBLE
23118: LD_INT 1
23120: DEC
23121: ST_TO_ADDR
23122: LD_INT 6
23124: PUSH
23125: LD_VAR 0 8
23129: MINUS
23130: PUSH
23131: FOR_TO
23132: IFFALSE 23224
// begin if i = sort then
23134: LD_VAR 0 3
23138: PUSH
23139: LD_VAR 0 9
23143: EQUAL
23144: IFFALSE 23148
// break ;
23146: GO 23224
// if GetClass ( i ) = 4 then
23148: LD_VAR 0 3
23152: PPUSH
23153: CALL_OW 257
23157: PUSH
23158: LD_INT 4
23160: EQUAL
23161: IFFALSE 23165
// continue ;
23163: GO 23131
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23165: LD_ADDR_VAR 0 11
23169: PUSH
23170: LD_VAR 0 11
23174: PPUSH
23175: LD_VAR 0 11
23179: PUSH
23180: LD_INT 1
23182: PLUS
23183: PPUSH
23184: LD_VAR 0 9
23188: PUSH
23189: LD_VAR 0 3
23193: ARRAY
23194: PPUSH
23195: CALL_OW 2
23199: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23200: LD_ADDR_VAR 0 4
23204: PUSH
23205: LD_VAR 0 4
23209: PUSH
23210: LD_VAR 0 9
23214: PUSH
23215: LD_VAR 0 3
23219: ARRAY
23220: DIFF
23221: ST_TO_ADDR
// end ;
23222: GO 23131
23224: POP
23225: POP
// if p then
23226: LD_VAR 0 11
23230: IFFALSE 23255
// result := Replace ( result , 4 , p ) ;
23232: LD_ADDR_VAR 0 2
23236: PUSH
23237: LD_VAR 0 2
23241: PPUSH
23242: LD_INT 4
23244: PPUSH
23245: LD_VAR 0 11
23249: PPUSH
23250: CALL_OW 1
23254: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23255: LD_VAR 0 4
23259: PUSH
23260: LD_VAR 0 7
23264: PUSH
23265: LD_INT 6
23267: LESS
23268: AND
23269: IFFALSE 23457
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23271: LD_ADDR_VAR 0 9
23275: PUSH
23276: LD_VAR 0 4
23280: PUSH
23281: LD_VAR 0 8
23285: PUSH
23286: LD_VAR 0 7
23290: UNION
23291: DIFF
23292: PPUSH
23293: LD_INT 3
23295: PPUSH
23296: CALL 88356 0 2
23300: ST_TO_ADDR
// p := [ ] ;
23301: LD_ADDR_VAR 0 11
23305: PUSH
23306: EMPTY
23307: ST_TO_ADDR
// if sort then
23308: LD_VAR 0 9
23312: IFFALSE 23428
// for i = 1 to 6 - mech do
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: DOUBLE
23320: LD_INT 1
23322: DEC
23323: ST_TO_ADDR
23324: LD_INT 6
23326: PUSH
23327: LD_VAR 0 7
23331: MINUS
23332: PUSH
23333: FOR_TO
23334: IFFALSE 23426
// begin if i = sort then
23336: LD_VAR 0 3
23340: PUSH
23341: LD_VAR 0 9
23345: EQUAL
23346: IFFALSE 23350
// break ;
23348: GO 23426
// if GetClass ( i ) = 3 then
23350: LD_VAR 0 3
23354: PPUSH
23355: CALL_OW 257
23359: PUSH
23360: LD_INT 3
23362: EQUAL
23363: IFFALSE 23367
// continue ;
23365: GO 23333
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23367: LD_ADDR_VAR 0 11
23371: PUSH
23372: LD_VAR 0 11
23376: PPUSH
23377: LD_VAR 0 11
23381: PUSH
23382: LD_INT 1
23384: PLUS
23385: PPUSH
23386: LD_VAR 0 9
23390: PUSH
23391: LD_VAR 0 3
23395: ARRAY
23396: PPUSH
23397: CALL_OW 2
23401: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23402: LD_ADDR_VAR 0 4
23406: PUSH
23407: LD_VAR 0 4
23411: PUSH
23412: LD_VAR 0 9
23416: PUSH
23417: LD_VAR 0 3
23421: ARRAY
23422: DIFF
23423: ST_TO_ADDR
// end ;
23424: GO 23333
23426: POP
23427: POP
// if p then
23428: LD_VAR 0 11
23432: IFFALSE 23457
// result := Replace ( result , 3 , p ) ;
23434: LD_ADDR_VAR 0 2
23438: PUSH
23439: LD_VAR 0 2
23443: PPUSH
23444: LD_INT 3
23446: PPUSH
23447: LD_VAR 0 11
23451: PPUSH
23452: CALL_OW 1
23456: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23457: LD_VAR 0 4
23461: PUSH
23462: LD_INT 6
23464: GREATER
23465: PUSH
23466: LD_VAR 0 6
23470: PUSH
23471: LD_INT 6
23473: LESS
23474: AND
23475: IFFALSE 23669
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23477: LD_ADDR_VAR 0 9
23481: PUSH
23482: LD_VAR 0 4
23486: PUSH
23487: LD_VAR 0 8
23491: PUSH
23492: LD_VAR 0 7
23496: UNION
23497: PUSH
23498: LD_VAR 0 6
23502: UNION
23503: DIFF
23504: PPUSH
23505: LD_INT 2
23507: PPUSH
23508: CALL 88356 0 2
23512: ST_TO_ADDR
// p := [ ] ;
23513: LD_ADDR_VAR 0 11
23517: PUSH
23518: EMPTY
23519: ST_TO_ADDR
// if sort then
23520: LD_VAR 0 9
23524: IFFALSE 23640
// for i = 1 to 6 - eng do
23526: LD_ADDR_VAR 0 3
23530: PUSH
23531: DOUBLE
23532: LD_INT 1
23534: DEC
23535: ST_TO_ADDR
23536: LD_INT 6
23538: PUSH
23539: LD_VAR 0 6
23543: MINUS
23544: PUSH
23545: FOR_TO
23546: IFFALSE 23638
// begin if i = sort then
23548: LD_VAR 0 3
23552: PUSH
23553: LD_VAR 0 9
23557: EQUAL
23558: IFFALSE 23562
// break ;
23560: GO 23638
// if GetClass ( i ) = 2 then
23562: LD_VAR 0 3
23566: PPUSH
23567: CALL_OW 257
23571: PUSH
23572: LD_INT 2
23574: EQUAL
23575: IFFALSE 23579
// continue ;
23577: GO 23545
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23579: LD_ADDR_VAR 0 11
23583: PUSH
23584: LD_VAR 0 11
23588: PPUSH
23589: LD_VAR 0 11
23593: PUSH
23594: LD_INT 1
23596: PLUS
23597: PPUSH
23598: LD_VAR 0 9
23602: PUSH
23603: LD_VAR 0 3
23607: ARRAY
23608: PPUSH
23609: CALL_OW 2
23613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23614: LD_ADDR_VAR 0 4
23618: PUSH
23619: LD_VAR 0 4
23623: PUSH
23624: LD_VAR 0 9
23628: PUSH
23629: LD_VAR 0 3
23633: ARRAY
23634: DIFF
23635: ST_TO_ADDR
// end ;
23636: GO 23545
23638: POP
23639: POP
// if p then
23640: LD_VAR 0 11
23644: IFFALSE 23669
// result := Replace ( result , 2 , p ) ;
23646: LD_ADDR_VAR 0 2
23650: PUSH
23651: LD_VAR 0 2
23655: PPUSH
23656: LD_INT 2
23658: PPUSH
23659: LD_VAR 0 11
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// end ; exit ;
23669: GO 25057
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
23671: LD_EXP 76
23675: PUSH
23676: LD_EXP 75
23680: PUSH
23681: LD_VAR 0 1
23685: ARRAY
23686: ARRAY
23687: NOT
23688: PUSH
23689: LD_EXP 49
23693: PUSH
23694: LD_VAR 0 1
23698: ARRAY
23699: PPUSH
23700: LD_INT 30
23702: PUSH
23703: LD_INT 3
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PPUSH
23710: CALL_OW 72
23714: AND
23715: PUSH
23716: LD_EXP 54
23720: PUSH
23721: LD_VAR 0 1
23725: ARRAY
23726: AND
23727: IFFALSE 24335
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
23729: LD_ADDR_EXP 91
23733: PUSH
23734: LD_EXP 91
23738: PPUSH
23739: LD_VAR 0 1
23743: PPUSH
23744: LD_INT 5
23746: PPUSH
23747: CALL_OW 1
23751: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23752: LD_ADDR_VAR 0 2
23756: PUSH
23757: LD_INT 0
23759: PUSH
23760: LD_INT 0
23762: PUSH
23763: LD_INT 0
23765: PUSH
23766: LD_INT 0
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: ST_TO_ADDR
// if sci > 1 then
23775: LD_VAR 0 8
23779: PUSH
23780: LD_INT 1
23782: GREATER
23783: IFFALSE 23811
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
23785: LD_ADDR_VAR 0 4
23789: PUSH
23790: LD_VAR 0 4
23794: PUSH
23795: LD_VAR 0 8
23799: PUSH
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 1
23807: ARRAY
23808: DIFF
23809: DIFF
23810: ST_TO_ADDR
// if tmp and not sci then
23811: LD_VAR 0 4
23815: PUSH
23816: LD_VAR 0 8
23820: NOT
23821: AND
23822: IFFALSE 23891
// begin sort := SortBySkill ( tmp , 4 ) ;
23824: LD_ADDR_VAR 0 9
23828: PUSH
23829: LD_VAR 0 4
23833: PPUSH
23834: LD_INT 4
23836: PPUSH
23837: CALL 88356 0 2
23841: ST_TO_ADDR
// if sort then
23842: LD_VAR 0 9
23846: IFFALSE 23862
// p := sort [ 1 ] ;
23848: LD_ADDR_VAR 0 11
23852: PUSH
23853: LD_VAR 0 9
23857: PUSH
23858: LD_INT 1
23860: ARRAY
23861: ST_TO_ADDR
// if p then
23862: LD_VAR 0 11
23866: IFFALSE 23891
// result := Replace ( result , 4 , p ) ;
23868: LD_ADDR_VAR 0 2
23872: PUSH
23873: LD_VAR 0 2
23877: PPUSH
23878: LD_INT 4
23880: PPUSH
23881: LD_VAR 0 11
23885: PPUSH
23886: CALL_OW 1
23890: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
23891: LD_ADDR_VAR 0 4
23895: PUSH
23896: LD_VAR 0 4
23900: PUSH
23901: LD_VAR 0 7
23905: DIFF
23906: ST_TO_ADDR
// if tmp and mech < 6 then
23907: LD_VAR 0 4
23911: PUSH
23912: LD_VAR 0 7
23916: PUSH
23917: LD_INT 6
23919: LESS
23920: AND
23921: IFFALSE 24109
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23923: LD_ADDR_VAR 0 9
23927: PUSH
23928: LD_VAR 0 4
23932: PUSH
23933: LD_VAR 0 8
23937: PUSH
23938: LD_VAR 0 7
23942: UNION
23943: DIFF
23944: PPUSH
23945: LD_INT 3
23947: PPUSH
23948: CALL 88356 0 2
23952: ST_TO_ADDR
// p := [ ] ;
23953: LD_ADDR_VAR 0 11
23957: PUSH
23958: EMPTY
23959: ST_TO_ADDR
// if sort then
23960: LD_VAR 0 9
23964: IFFALSE 24080
// for i = 1 to 6 - mech do
23966: LD_ADDR_VAR 0 3
23970: PUSH
23971: DOUBLE
23972: LD_INT 1
23974: DEC
23975: ST_TO_ADDR
23976: LD_INT 6
23978: PUSH
23979: LD_VAR 0 7
23983: MINUS
23984: PUSH
23985: FOR_TO
23986: IFFALSE 24078
// begin if i = sort then
23988: LD_VAR 0 3
23992: PUSH
23993: LD_VAR 0 9
23997: EQUAL
23998: IFFALSE 24002
// break ;
24000: GO 24078
// if GetClass ( i ) = 3 then
24002: LD_VAR 0 3
24006: PPUSH
24007: CALL_OW 257
24011: PUSH
24012: LD_INT 3
24014: EQUAL
24015: IFFALSE 24019
// continue ;
24017: GO 23985
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24019: LD_ADDR_VAR 0 11
24023: PUSH
24024: LD_VAR 0 11
24028: PPUSH
24029: LD_VAR 0 11
24033: PUSH
24034: LD_INT 1
24036: PLUS
24037: PPUSH
24038: LD_VAR 0 9
24042: PUSH
24043: LD_VAR 0 3
24047: ARRAY
24048: PPUSH
24049: CALL_OW 2
24053: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24054: LD_ADDR_VAR 0 4
24058: PUSH
24059: LD_VAR 0 4
24063: PUSH
24064: LD_VAR 0 9
24068: PUSH
24069: LD_VAR 0 3
24073: ARRAY
24074: DIFF
24075: ST_TO_ADDR
// end ;
24076: GO 23985
24078: POP
24079: POP
// if p then
24080: LD_VAR 0 11
24084: IFFALSE 24109
// result := Replace ( result , 3 , p ) ;
24086: LD_ADDR_VAR 0 2
24090: PUSH
24091: LD_VAR 0 2
24095: PPUSH
24096: LD_INT 3
24098: PPUSH
24099: LD_VAR 0 11
24103: PPUSH
24104: CALL_OW 1
24108: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24109: LD_ADDR_VAR 0 4
24113: PUSH
24114: LD_VAR 0 4
24118: PUSH
24119: LD_VAR 0 6
24123: DIFF
24124: ST_TO_ADDR
// if tmp and eng < 6 then
24125: LD_VAR 0 4
24129: PUSH
24130: LD_VAR 0 6
24134: PUSH
24135: LD_INT 6
24137: LESS
24138: AND
24139: IFFALSE 24333
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24141: LD_ADDR_VAR 0 9
24145: PUSH
24146: LD_VAR 0 4
24150: PUSH
24151: LD_VAR 0 8
24155: PUSH
24156: LD_VAR 0 7
24160: UNION
24161: PUSH
24162: LD_VAR 0 6
24166: UNION
24167: DIFF
24168: PPUSH
24169: LD_INT 2
24171: PPUSH
24172: CALL 88356 0 2
24176: ST_TO_ADDR
// p := [ ] ;
24177: LD_ADDR_VAR 0 11
24181: PUSH
24182: EMPTY
24183: ST_TO_ADDR
// if sort then
24184: LD_VAR 0 9
24188: IFFALSE 24304
// for i = 1 to 6 - eng do
24190: LD_ADDR_VAR 0 3
24194: PUSH
24195: DOUBLE
24196: LD_INT 1
24198: DEC
24199: ST_TO_ADDR
24200: LD_INT 6
24202: PUSH
24203: LD_VAR 0 6
24207: MINUS
24208: PUSH
24209: FOR_TO
24210: IFFALSE 24302
// begin if i = sort then
24212: LD_VAR 0 3
24216: PUSH
24217: LD_VAR 0 9
24221: EQUAL
24222: IFFALSE 24226
// break ;
24224: GO 24302
// if GetClass ( i ) = 2 then
24226: LD_VAR 0 3
24230: PPUSH
24231: CALL_OW 257
24235: PUSH
24236: LD_INT 2
24238: EQUAL
24239: IFFALSE 24243
// continue ;
24241: GO 24209
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24243: LD_ADDR_VAR 0 11
24247: PUSH
24248: LD_VAR 0 11
24252: PPUSH
24253: LD_VAR 0 11
24257: PUSH
24258: LD_INT 1
24260: PLUS
24261: PPUSH
24262: LD_VAR 0 9
24266: PUSH
24267: LD_VAR 0 3
24271: ARRAY
24272: PPUSH
24273: CALL_OW 2
24277: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24278: LD_ADDR_VAR 0 4
24282: PUSH
24283: LD_VAR 0 4
24287: PUSH
24288: LD_VAR 0 9
24292: PUSH
24293: LD_VAR 0 3
24297: ARRAY
24298: DIFF
24299: ST_TO_ADDR
// end ;
24300: GO 24209
24302: POP
24303: POP
// if p then
24304: LD_VAR 0 11
24308: IFFALSE 24333
// result := Replace ( result , 2 , p ) ;
24310: LD_ADDR_VAR 0 2
24314: PUSH
24315: LD_VAR 0 2
24319: PPUSH
24320: LD_INT 2
24322: PPUSH
24323: LD_VAR 0 11
24327: PPUSH
24328: CALL_OW 1
24332: ST_TO_ADDR
// end ; exit ;
24333: GO 25057
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24335: LD_EXP 76
24339: PUSH
24340: LD_EXP 75
24344: PUSH
24345: LD_VAR 0 1
24349: ARRAY
24350: ARRAY
24351: NOT
24352: PUSH
24353: LD_EXP 49
24357: PUSH
24358: LD_VAR 0 1
24362: ARRAY
24363: PPUSH
24364: LD_INT 30
24366: PUSH
24367: LD_INT 3
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PPUSH
24374: CALL_OW 72
24378: AND
24379: PUSH
24380: LD_EXP 54
24384: PUSH
24385: LD_VAR 0 1
24389: ARRAY
24390: NOT
24391: AND
24392: IFFALSE 25057
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24394: LD_ADDR_EXP 91
24398: PUSH
24399: LD_EXP 91
24403: PPUSH
24404: LD_VAR 0 1
24408: PPUSH
24409: LD_INT 6
24411: PPUSH
24412: CALL_OW 1
24416: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24417: LD_ADDR_VAR 0 2
24421: PUSH
24422: LD_INT 0
24424: PUSH
24425: LD_INT 0
24427: PUSH
24428: LD_INT 0
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: ST_TO_ADDR
// if sci >= 1 then
24440: LD_VAR 0 8
24444: PUSH
24445: LD_INT 1
24447: GREATEREQUAL
24448: IFFALSE 24470
// tmp := tmp diff sci [ 1 ] ;
24450: LD_ADDR_VAR 0 4
24454: PUSH
24455: LD_VAR 0 4
24459: PUSH
24460: LD_VAR 0 8
24464: PUSH
24465: LD_INT 1
24467: ARRAY
24468: DIFF
24469: ST_TO_ADDR
// if tmp and not sci then
24470: LD_VAR 0 4
24474: PUSH
24475: LD_VAR 0 8
24479: NOT
24480: AND
24481: IFFALSE 24550
// begin sort := SortBySkill ( tmp , 4 ) ;
24483: LD_ADDR_VAR 0 9
24487: PUSH
24488: LD_VAR 0 4
24492: PPUSH
24493: LD_INT 4
24495: PPUSH
24496: CALL 88356 0 2
24500: ST_TO_ADDR
// if sort then
24501: LD_VAR 0 9
24505: IFFALSE 24521
// p := sort [ 1 ] ;
24507: LD_ADDR_VAR 0 11
24511: PUSH
24512: LD_VAR 0 9
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: ST_TO_ADDR
// if p then
24521: LD_VAR 0 11
24525: IFFALSE 24550
// result := Replace ( result , 4 , p ) ;
24527: LD_ADDR_VAR 0 2
24531: PUSH
24532: LD_VAR 0 2
24536: PPUSH
24537: LD_INT 4
24539: PPUSH
24540: LD_VAR 0 11
24544: PPUSH
24545: CALL_OW 1
24549: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24550: LD_ADDR_VAR 0 4
24554: PUSH
24555: LD_VAR 0 4
24559: PUSH
24560: LD_VAR 0 7
24564: DIFF
24565: ST_TO_ADDR
// if tmp and mech < 6 then
24566: LD_VAR 0 4
24570: PUSH
24571: LD_VAR 0 7
24575: PUSH
24576: LD_INT 6
24578: LESS
24579: AND
24580: IFFALSE 24762
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24582: LD_ADDR_VAR 0 9
24586: PUSH
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 7
24596: DIFF
24597: PPUSH
24598: LD_INT 3
24600: PPUSH
24601: CALL 88356 0 2
24605: ST_TO_ADDR
// p := [ ] ;
24606: LD_ADDR_VAR 0 11
24610: PUSH
24611: EMPTY
24612: ST_TO_ADDR
// if sort then
24613: LD_VAR 0 9
24617: IFFALSE 24733
// for i = 1 to 6 - mech do
24619: LD_ADDR_VAR 0 3
24623: PUSH
24624: DOUBLE
24625: LD_INT 1
24627: DEC
24628: ST_TO_ADDR
24629: LD_INT 6
24631: PUSH
24632: LD_VAR 0 7
24636: MINUS
24637: PUSH
24638: FOR_TO
24639: IFFALSE 24731
// begin if i = sort then
24641: LD_VAR 0 3
24645: PUSH
24646: LD_VAR 0 9
24650: EQUAL
24651: IFFALSE 24655
// break ;
24653: GO 24731
// if GetClass ( i ) = 3 then
24655: LD_VAR 0 3
24659: PPUSH
24660: CALL_OW 257
24664: PUSH
24665: LD_INT 3
24667: EQUAL
24668: IFFALSE 24672
// continue ;
24670: GO 24638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24672: LD_ADDR_VAR 0 11
24676: PUSH
24677: LD_VAR 0 11
24681: PPUSH
24682: LD_VAR 0 11
24686: PUSH
24687: LD_INT 1
24689: PLUS
24690: PPUSH
24691: LD_VAR 0 9
24695: PUSH
24696: LD_VAR 0 3
24700: ARRAY
24701: PPUSH
24702: CALL_OW 2
24706: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24707: LD_ADDR_VAR 0 4
24711: PUSH
24712: LD_VAR 0 4
24716: PUSH
24717: LD_VAR 0 9
24721: PUSH
24722: LD_VAR 0 3
24726: ARRAY
24727: DIFF
24728: ST_TO_ADDR
// end ;
24729: GO 24638
24731: POP
24732: POP
// if p then
24733: LD_VAR 0 11
24737: IFFALSE 24762
// result := Replace ( result , 3 , p ) ;
24739: LD_ADDR_VAR 0 2
24743: PUSH
24744: LD_VAR 0 2
24748: PPUSH
24749: LD_INT 3
24751: PPUSH
24752: LD_VAR 0 11
24756: PPUSH
24757: CALL_OW 1
24761: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24762: LD_ADDR_VAR 0 4
24766: PUSH
24767: LD_VAR 0 4
24771: PUSH
24772: LD_VAR 0 6
24776: DIFF
24777: ST_TO_ADDR
// if tmp and eng < 4 then
24778: LD_VAR 0 4
24782: PUSH
24783: LD_VAR 0 6
24787: PUSH
24788: LD_INT 4
24790: LESS
24791: AND
24792: IFFALSE 24982
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
24794: LD_ADDR_VAR 0 9
24798: PUSH
24799: LD_VAR 0 4
24803: PUSH
24804: LD_VAR 0 7
24808: PUSH
24809: LD_VAR 0 6
24813: UNION
24814: DIFF
24815: PPUSH
24816: LD_INT 2
24818: PPUSH
24819: CALL 88356 0 2
24823: ST_TO_ADDR
// p := [ ] ;
24824: LD_ADDR_VAR 0 11
24828: PUSH
24829: EMPTY
24830: ST_TO_ADDR
// if sort then
24831: LD_VAR 0 9
24835: IFFALSE 24951
// for i = 1 to 4 - eng do
24837: LD_ADDR_VAR 0 3
24841: PUSH
24842: DOUBLE
24843: LD_INT 1
24845: DEC
24846: ST_TO_ADDR
24847: LD_INT 4
24849: PUSH
24850: LD_VAR 0 6
24854: MINUS
24855: PUSH
24856: FOR_TO
24857: IFFALSE 24949
// begin if i = sort then
24859: LD_VAR 0 3
24863: PUSH
24864: LD_VAR 0 9
24868: EQUAL
24869: IFFALSE 24873
// break ;
24871: GO 24949
// if GetClass ( i ) = 2 then
24873: LD_VAR 0 3
24877: PPUSH
24878: CALL_OW 257
24882: PUSH
24883: LD_INT 2
24885: EQUAL
24886: IFFALSE 24890
// continue ;
24888: GO 24856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24890: LD_ADDR_VAR 0 11
24894: PUSH
24895: LD_VAR 0 11
24899: PPUSH
24900: LD_VAR 0 11
24904: PUSH
24905: LD_INT 1
24907: PLUS
24908: PPUSH
24909: LD_VAR 0 9
24913: PUSH
24914: LD_VAR 0 3
24918: ARRAY
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24925: LD_ADDR_VAR 0 4
24929: PUSH
24930: LD_VAR 0 4
24934: PUSH
24935: LD_VAR 0 9
24939: PUSH
24940: LD_VAR 0 3
24944: ARRAY
24945: DIFF
24946: ST_TO_ADDR
// end ;
24947: GO 24856
24949: POP
24950: POP
// if p then
24951: LD_VAR 0 11
24955: IFFALSE 24980
// result := Replace ( result , 2 , p ) ;
24957: LD_ADDR_VAR 0 2
24961: PUSH
24962: LD_VAR 0 2
24966: PPUSH
24967: LD_INT 2
24969: PPUSH
24970: LD_VAR 0 11
24974: PPUSH
24975: CALL_OW 1
24979: ST_TO_ADDR
// end else
24980: GO 25026
// for i = eng downto 5 do
24982: LD_ADDR_VAR 0 3
24986: PUSH
24987: DOUBLE
24988: LD_VAR 0 6
24992: INC
24993: ST_TO_ADDR
24994: LD_INT 5
24996: PUSH
24997: FOR_DOWNTO
24998: IFFALSE 25024
// tmp := tmp union eng [ i ] ;
25000: LD_ADDR_VAR 0 4
25004: PUSH
25005: LD_VAR 0 4
25009: PUSH
25010: LD_VAR 0 6
25014: PUSH
25015: LD_VAR 0 3
25019: ARRAY
25020: UNION
25021: ST_TO_ADDR
25022: GO 24997
25024: POP
25025: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25026: LD_ADDR_VAR 0 2
25030: PUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_INT 1
25038: PPUSH
25039: LD_VAR 0 4
25043: PUSH
25044: LD_VAR 0 5
25048: DIFF
25049: PPUSH
25050: CALL_OW 1
25054: ST_TO_ADDR
// exit ;
25055: GO 25057
// end ; end ;
25057: LD_VAR 0 2
25061: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25062: LD_INT 0
25064: PPUSH
25065: PPUSH
25066: PPUSH
// if not mc_bases then
25067: LD_EXP 49
25071: NOT
25072: IFFALSE 25076
// exit ;
25074: GO 25182
// for i = 1 to mc_bases do
25076: LD_ADDR_VAR 0 2
25080: PUSH
25081: DOUBLE
25082: LD_INT 1
25084: DEC
25085: ST_TO_ADDR
25086: LD_EXP 49
25090: PUSH
25091: FOR_TO
25092: IFFALSE 25173
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25094: LD_ADDR_VAR 0 3
25098: PUSH
25099: LD_EXP 49
25103: PUSH
25104: LD_VAR 0 2
25108: ARRAY
25109: PPUSH
25110: LD_INT 21
25112: PUSH
25113: LD_INT 3
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 3
25122: PUSH
25123: LD_INT 24
25125: PUSH
25126: LD_INT 1000
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PPUSH
25141: CALL_OW 72
25145: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25146: LD_ADDR_EXP 50
25150: PUSH
25151: LD_EXP 50
25155: PPUSH
25156: LD_VAR 0 2
25160: PPUSH
25161: LD_VAR 0 3
25165: PPUSH
25166: CALL_OW 1
25170: ST_TO_ADDR
// end ;
25171: GO 25091
25173: POP
25174: POP
// RaiseSailEvent ( 101 ) ;
25175: LD_INT 101
25177: PPUSH
25178: CALL_OW 427
// end ;
25182: LD_VAR 0 1
25186: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25187: LD_INT 0
25189: PPUSH
25190: PPUSH
25191: PPUSH
25192: PPUSH
25193: PPUSH
25194: PPUSH
25195: PPUSH
// if not mc_bases then
25196: LD_EXP 49
25200: NOT
25201: IFFALSE 25205
// exit ;
25203: GO 25778
// for i = 1 to mc_bases do
25205: LD_ADDR_VAR 0 2
25209: PUSH
25210: DOUBLE
25211: LD_INT 1
25213: DEC
25214: ST_TO_ADDR
25215: LD_EXP 49
25219: PUSH
25220: FOR_TO
25221: IFFALSE 25769
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25223: LD_ADDR_VAR 0 5
25227: PUSH
25228: LD_EXP 49
25232: PUSH
25233: LD_VAR 0 2
25237: ARRAY
25238: PUSH
25239: LD_EXP 78
25243: PUSH
25244: LD_VAR 0 2
25248: ARRAY
25249: UNION
25250: PPUSH
25251: LD_INT 21
25253: PUSH
25254: LD_INT 1
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: PUSH
25261: LD_INT 1
25263: PUSH
25264: LD_INT 3
25266: PUSH
25267: LD_INT 54
25269: PUSH
25270: EMPTY
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PUSH
25277: LD_INT 3
25279: PUSH
25280: LD_INT 24
25282: PUSH
25283: LD_INT 800
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: EMPTY
25291: LIST
25292: LIST
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: LIST
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PPUSH
25303: CALL_OW 72
25307: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25308: LD_ADDR_VAR 0 6
25312: PUSH
25313: LD_EXP 49
25317: PUSH
25318: LD_VAR 0 2
25322: ARRAY
25323: PPUSH
25324: LD_INT 21
25326: PUSH
25327: LD_INT 1
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 1
25336: PUSH
25337: LD_INT 3
25339: PUSH
25340: LD_INT 54
25342: PUSH
25343: EMPTY
25344: LIST
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 24
25355: PUSH
25356: LD_INT 250
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PPUSH
25376: CALL_OW 72
25380: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25381: LD_ADDR_VAR 0 7
25385: PUSH
25386: LD_VAR 0 5
25390: PUSH
25391: LD_VAR 0 6
25395: DIFF
25396: ST_TO_ADDR
// if not need_heal_1 then
25397: LD_VAR 0 6
25401: NOT
25402: IFFALSE 25435
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25404: LD_ADDR_EXP 52
25408: PUSH
25409: LD_EXP 52
25413: PPUSH
25414: LD_VAR 0 2
25418: PUSH
25419: LD_INT 1
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PPUSH
25426: EMPTY
25427: PPUSH
25428: CALL 54108 0 3
25432: ST_TO_ADDR
25433: GO 25505
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25435: LD_ADDR_EXP 52
25439: PUSH
25440: LD_EXP 52
25444: PPUSH
25445: LD_VAR 0 2
25449: PUSH
25450: LD_INT 1
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PPUSH
25457: LD_EXP 52
25461: PUSH
25462: LD_VAR 0 2
25466: ARRAY
25467: PUSH
25468: LD_INT 1
25470: ARRAY
25471: PPUSH
25472: LD_INT 3
25474: PUSH
25475: LD_INT 24
25477: PUSH
25478: LD_INT 1000
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PPUSH
25489: CALL_OW 72
25493: PUSH
25494: LD_VAR 0 6
25498: UNION
25499: PPUSH
25500: CALL 54108 0 3
25504: ST_TO_ADDR
// if not need_heal_2 then
25505: LD_VAR 0 7
25509: NOT
25510: IFFALSE 25543
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25512: LD_ADDR_EXP 52
25516: PUSH
25517: LD_EXP 52
25521: PPUSH
25522: LD_VAR 0 2
25526: PUSH
25527: LD_INT 2
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PPUSH
25534: EMPTY
25535: PPUSH
25536: CALL 54108 0 3
25540: ST_TO_ADDR
25541: GO 25575
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25543: LD_ADDR_EXP 52
25547: PUSH
25548: LD_EXP 52
25552: PPUSH
25553: LD_VAR 0 2
25557: PUSH
25558: LD_INT 2
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PPUSH
25565: LD_VAR 0 7
25569: PPUSH
25570: CALL 54108 0 3
25574: ST_TO_ADDR
// if need_heal_2 then
25575: LD_VAR 0 7
25579: IFFALSE 25751
// for j in need_heal_2 do
25581: LD_ADDR_VAR 0 3
25585: PUSH
25586: LD_VAR 0 7
25590: PUSH
25591: FOR_IN
25592: IFFALSE 25749
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
25594: LD_ADDR_VAR 0 5
25598: PUSH
25599: LD_EXP 49
25603: PUSH
25604: LD_VAR 0 2
25608: ARRAY
25609: PPUSH
25610: LD_INT 2
25612: PUSH
25613: LD_INT 30
25615: PUSH
25616: LD_INT 6
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 30
25625: PUSH
25626: LD_INT 7
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 30
25635: PUSH
25636: LD_INT 8
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 30
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 30
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 25
25665: PUSH
25666: LD_INT 4
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: PPUSH
25682: CALL_OW 72
25686: ST_TO_ADDR
// if tmp then
25687: LD_VAR 0 5
25691: IFFALSE 25747
// begin k := NearestUnitToUnit ( tmp , j ) ;
25693: LD_ADDR_VAR 0 4
25697: PUSH
25698: LD_VAR 0 5
25702: PPUSH
25703: LD_VAR 0 3
25707: PPUSH
25708: CALL_OW 74
25712: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
25713: LD_VAR 0 3
25717: PPUSH
25718: LD_VAR 0 4
25722: PPUSH
25723: CALL_OW 296
25727: PUSH
25728: LD_INT 7
25730: GREATER
25731: IFFALSE 25747
// ComMoveUnit ( j , k ) ;
25733: LD_VAR 0 3
25737: PPUSH
25738: LD_VAR 0 4
25742: PPUSH
25743: CALL_OW 112
// end ; end ;
25747: GO 25591
25749: POP
25750: POP
// if not need_heal_1 and not need_heal_2 then
25751: LD_VAR 0 6
25755: NOT
25756: PUSH
25757: LD_VAR 0 7
25761: NOT
25762: AND
25763: IFFALSE 25767
// continue ;
25765: GO 25220
// end ;
25767: GO 25220
25769: POP
25770: POP
// RaiseSailEvent ( 102 ) ;
25771: LD_INT 102
25773: PPUSH
25774: CALL_OW 427
// end ;
25778: LD_VAR 0 1
25782: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
25783: LD_INT 0
25785: PPUSH
25786: PPUSH
25787: PPUSH
25788: PPUSH
25789: PPUSH
25790: PPUSH
// if not mc_bases then
25791: LD_EXP 49
25795: NOT
25796: IFFALSE 25800
// exit ;
25798: GO 26510
// for i = 1 to mc_bases do
25800: LD_ADDR_VAR 0 2
25804: PUSH
25805: DOUBLE
25806: LD_INT 1
25808: DEC
25809: ST_TO_ADDR
25810: LD_EXP 49
25814: PUSH
25815: FOR_TO
25816: IFFALSE 26508
// begin if not mc_building_need_repair [ i ] then
25818: LD_EXP 50
25822: PUSH
25823: LD_VAR 0 2
25827: ARRAY
25828: NOT
25829: IFFALSE 26003
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
25831: LD_ADDR_VAR 0 6
25835: PUSH
25836: LD_EXP 68
25840: PUSH
25841: LD_VAR 0 2
25845: ARRAY
25846: PPUSH
25847: LD_INT 3
25849: PUSH
25850: LD_INT 24
25852: PUSH
25853: LD_INT 1000
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 2
25866: PUSH
25867: LD_INT 34
25869: PUSH
25870: LD_INT 13
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 34
25879: PUSH
25880: LD_INT 52
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PPUSH
25896: CALL_OW 72
25900: ST_TO_ADDR
// if cranes then
25901: LD_VAR 0 6
25905: IFFALSE 25967
// for j in cranes do
25907: LD_ADDR_VAR 0 3
25911: PUSH
25912: LD_VAR 0 6
25916: PUSH
25917: FOR_IN
25918: IFFALSE 25965
// if not IsInArea ( j , mc_parking [ i ] ) then
25920: LD_VAR 0 3
25924: PPUSH
25925: LD_EXP 73
25929: PUSH
25930: LD_VAR 0 2
25934: ARRAY
25935: PPUSH
25936: CALL_OW 308
25940: NOT
25941: IFFALSE 25963
// ComMoveToArea ( j , mc_parking [ i ] ) ;
25943: LD_VAR 0 3
25947: PPUSH
25948: LD_EXP 73
25952: PUSH
25953: LD_VAR 0 2
25957: ARRAY
25958: PPUSH
25959: CALL_OW 113
25963: GO 25917
25965: POP
25966: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25967: LD_ADDR_EXP 51
25971: PUSH
25972: LD_EXP 51
25976: PPUSH
25977: LD_VAR 0 2
25981: PPUSH
25982: EMPTY
25983: PPUSH
25984: CALL_OW 1
25988: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
25989: LD_VAR 0 2
25993: PPUSH
25994: LD_INT 101
25996: PPUSH
25997: CALL 20895 0 2
// continue ;
26001: GO 25815
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26003: LD_ADDR_EXP 55
26007: PUSH
26008: LD_EXP 55
26012: PPUSH
26013: LD_VAR 0 2
26017: PPUSH
26018: EMPTY
26019: PPUSH
26020: CALL_OW 1
26024: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26025: LD_VAR 0 2
26029: PPUSH
26030: LD_INT 103
26032: PPUSH
26033: CALL 20895 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26037: LD_ADDR_VAR 0 5
26041: PUSH
26042: LD_EXP 49
26046: PUSH
26047: LD_VAR 0 2
26051: ARRAY
26052: PUSH
26053: LD_EXP 78
26057: PUSH
26058: LD_VAR 0 2
26062: ARRAY
26063: UNION
26064: PPUSH
26065: LD_INT 2
26067: PUSH
26068: LD_INT 25
26070: PUSH
26071: LD_INT 2
26073: PUSH
26074: EMPTY
26075: LIST
26076: LIST
26077: PUSH
26078: LD_INT 25
26080: PUSH
26081: LD_INT 16
26083: PUSH
26084: EMPTY
26085: LIST
26086: LIST
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: PPUSH
26096: CALL_OW 72
26100: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26101: LD_ADDR_VAR 0 6
26105: PUSH
26106: LD_EXP 68
26110: PUSH
26111: LD_VAR 0 2
26115: ARRAY
26116: PPUSH
26117: LD_INT 2
26119: PUSH
26120: LD_INT 34
26122: PUSH
26123: LD_INT 13
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: PUSH
26130: LD_INT 34
26132: PUSH
26133: LD_INT 52
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: LIST
26144: PPUSH
26145: CALL_OW 72
26149: ST_TO_ADDR
// if cranes then
26150: LD_VAR 0 6
26154: IFFALSE 26290
// begin for j in cranes do
26156: LD_ADDR_VAR 0 3
26160: PUSH
26161: LD_VAR 0 6
26165: PUSH
26166: FOR_IN
26167: IFFALSE 26288
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26169: LD_VAR 0 3
26173: PPUSH
26174: CALL_OW 256
26178: PUSH
26179: LD_INT 500
26181: GREATEREQUAL
26182: PUSH
26183: LD_VAR 0 3
26187: PPUSH
26188: CALL_OW 314
26192: NOT
26193: AND
26194: IFFALSE 26228
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26196: LD_VAR 0 3
26200: PPUSH
26201: LD_EXP 50
26205: PUSH
26206: LD_VAR 0 2
26210: ARRAY
26211: PPUSH
26212: LD_VAR 0 3
26216: PPUSH
26217: CALL_OW 74
26221: PPUSH
26222: CALL_OW 130
26226: GO 26286
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26228: LD_VAR 0 3
26232: PPUSH
26233: CALL_OW 256
26237: PUSH
26238: LD_INT 500
26240: LESS
26241: PUSH
26242: LD_VAR 0 3
26246: PPUSH
26247: LD_EXP 73
26251: PUSH
26252: LD_VAR 0 2
26256: ARRAY
26257: PPUSH
26258: CALL_OW 308
26262: NOT
26263: AND
26264: IFFALSE 26286
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26266: LD_VAR 0 3
26270: PPUSH
26271: LD_EXP 73
26275: PUSH
26276: LD_VAR 0 2
26280: ARRAY
26281: PPUSH
26282: CALL_OW 113
26286: GO 26166
26288: POP
26289: POP
// end ; if not tmp then
26290: LD_VAR 0 5
26294: NOT
26295: IFFALSE 26299
// continue ;
26297: GO 25815
// for j in tmp do
26299: LD_ADDR_VAR 0 3
26303: PUSH
26304: LD_VAR 0 5
26308: PUSH
26309: FOR_IN
26310: IFFALSE 26504
// begin if mc_need_heal [ i ] then
26312: LD_EXP 52
26316: PUSH
26317: LD_VAR 0 2
26321: ARRAY
26322: IFFALSE 26370
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26324: LD_VAR 0 3
26328: PUSH
26329: LD_EXP 52
26333: PUSH
26334: LD_VAR 0 2
26338: ARRAY
26339: PUSH
26340: LD_INT 1
26342: ARRAY
26343: IN
26344: PUSH
26345: LD_VAR 0 3
26349: PUSH
26350: LD_EXP 52
26354: PUSH
26355: LD_VAR 0 2
26359: ARRAY
26360: PUSH
26361: LD_INT 2
26363: ARRAY
26364: IN
26365: OR
26366: IFFALSE 26370
// continue ;
26368: GO 26309
// if IsInUnit ( j ) then
26370: LD_VAR 0 3
26374: PPUSH
26375: CALL_OW 310
26379: IFFALSE 26390
// ComExitBuilding ( j ) ;
26381: LD_VAR 0 3
26385: PPUSH
26386: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26390: LD_VAR 0 3
26394: PUSH
26395: LD_EXP 51
26399: PUSH
26400: LD_VAR 0 2
26404: ARRAY
26405: IN
26406: NOT
26407: IFFALSE 26465
// begin SetTag ( j , 101 ) ;
26409: LD_VAR 0 3
26413: PPUSH
26414: LD_INT 101
26416: PPUSH
26417: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26421: LD_ADDR_EXP 51
26425: PUSH
26426: LD_EXP 51
26430: PPUSH
26431: LD_VAR 0 2
26435: PUSH
26436: LD_EXP 51
26440: PUSH
26441: LD_VAR 0 2
26445: ARRAY
26446: PUSH
26447: LD_INT 1
26449: PLUS
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PPUSH
26455: LD_VAR 0 3
26459: PPUSH
26460: CALL 54108 0 3
26464: ST_TO_ADDR
// end ; wait ( 1 ) ;
26465: LD_INT 1
26467: PPUSH
26468: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_EXP 50
26481: PUSH
26482: LD_VAR 0 2
26486: ARRAY
26487: PPUSH
26488: LD_VAR 0 3
26492: PPUSH
26493: CALL_OW 74
26497: PPUSH
26498: CALL_OW 130
// end ;
26502: GO 26309
26504: POP
26505: POP
// end ;
26506: GO 25815
26508: POP
26509: POP
// end ;
26510: LD_VAR 0 1
26514: RET
// export function MC_Heal ; var i , j , tmp ; begin
26515: LD_INT 0
26517: PPUSH
26518: PPUSH
26519: PPUSH
26520: PPUSH
// if not mc_bases then
26521: LD_EXP 49
26525: NOT
26526: IFFALSE 26530
// exit ;
26528: GO 26932
// for i = 1 to mc_bases do
26530: LD_ADDR_VAR 0 2
26534: PUSH
26535: DOUBLE
26536: LD_INT 1
26538: DEC
26539: ST_TO_ADDR
26540: LD_EXP 49
26544: PUSH
26545: FOR_TO
26546: IFFALSE 26930
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
26548: LD_EXP 52
26552: PUSH
26553: LD_VAR 0 2
26557: ARRAY
26558: PUSH
26559: LD_INT 1
26561: ARRAY
26562: NOT
26563: PUSH
26564: LD_EXP 52
26568: PUSH
26569: LD_VAR 0 2
26573: ARRAY
26574: PUSH
26575: LD_INT 2
26577: ARRAY
26578: NOT
26579: AND
26580: IFFALSE 26618
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
26582: LD_ADDR_EXP 53
26586: PUSH
26587: LD_EXP 53
26591: PPUSH
26592: LD_VAR 0 2
26596: PPUSH
26597: EMPTY
26598: PPUSH
26599: CALL_OW 1
26603: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
26604: LD_VAR 0 2
26608: PPUSH
26609: LD_INT 102
26611: PPUSH
26612: CALL 20895 0 2
// continue ;
26616: GO 26545
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
26618: LD_ADDR_VAR 0 4
26622: PUSH
26623: LD_EXP 49
26627: PUSH
26628: LD_VAR 0 2
26632: ARRAY
26633: PPUSH
26634: LD_INT 25
26636: PUSH
26637: LD_INT 4
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PPUSH
26644: CALL_OW 72
26648: ST_TO_ADDR
// if not tmp then
26649: LD_VAR 0 4
26653: NOT
26654: IFFALSE 26658
// continue ;
26656: GO 26545
// if mc_taming [ i ] then
26658: LD_EXP 80
26662: PUSH
26663: LD_VAR 0 2
26667: ARRAY
26668: IFFALSE 26692
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
26670: LD_ADDR_EXP 80
26674: PUSH
26675: LD_EXP 80
26679: PPUSH
26680: LD_VAR 0 2
26684: PPUSH
26685: EMPTY
26686: PPUSH
26687: CALL_OW 1
26691: ST_TO_ADDR
// for j in tmp do
26692: LD_ADDR_VAR 0 3
26696: PUSH
26697: LD_VAR 0 4
26701: PUSH
26702: FOR_IN
26703: IFFALSE 26926
// begin if IsInUnit ( j ) then
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 310
26714: IFFALSE 26725
// ComExitBuilding ( j ) ;
26716: LD_VAR 0 3
26720: PPUSH
26721: CALL_OW 122
// if not j in mc_healers [ i ] then
26725: LD_VAR 0 3
26729: PUSH
26730: LD_EXP 53
26734: PUSH
26735: LD_VAR 0 2
26739: ARRAY
26740: IN
26741: NOT
26742: IFFALSE 26788
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
26744: LD_ADDR_EXP 53
26748: PUSH
26749: LD_EXP 53
26753: PPUSH
26754: LD_VAR 0 2
26758: PUSH
26759: LD_EXP 53
26763: PUSH
26764: LD_VAR 0 2
26768: ARRAY
26769: PUSH
26770: LD_INT 1
26772: PLUS
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PPUSH
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL 54108 0 3
26787: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
26788: LD_VAR 0 3
26792: PPUSH
26793: CALL_OW 110
26797: PUSH
26798: LD_INT 102
26800: NONEQUAL
26801: IFFALSE 26815
// SetTag ( j , 102 ) ;
26803: LD_VAR 0 3
26807: PPUSH
26808: LD_INT 102
26810: PPUSH
26811: CALL_OW 109
// Wait ( 3 ) ;
26815: LD_INT 3
26817: PPUSH
26818: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
26822: LD_EXP 52
26826: PUSH
26827: LD_VAR 0 2
26831: ARRAY
26832: PUSH
26833: LD_INT 1
26835: ARRAY
26836: IFFALSE 26868
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
26838: LD_VAR 0 3
26842: PPUSH
26843: LD_EXP 52
26847: PUSH
26848: LD_VAR 0 2
26852: ARRAY
26853: PUSH
26854: LD_INT 1
26856: ARRAY
26857: PUSH
26858: LD_INT 1
26860: ARRAY
26861: PPUSH
26862: CALL_OW 128
26866: GO 26924
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
26868: LD_VAR 0 3
26872: PPUSH
26873: CALL_OW 314
26877: NOT
26878: PUSH
26879: LD_EXP 52
26883: PUSH
26884: LD_VAR 0 2
26888: ARRAY
26889: PUSH
26890: LD_INT 2
26892: ARRAY
26893: AND
26894: IFFALSE 26924
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
26896: LD_VAR 0 3
26900: PPUSH
26901: LD_EXP 52
26905: PUSH
26906: LD_VAR 0 2
26910: ARRAY
26911: PUSH
26912: LD_INT 2
26914: ARRAY
26915: PUSH
26916: LD_INT 1
26918: ARRAY
26919: PPUSH
26920: CALL_OW 128
// end ;
26924: GO 26702
26926: POP
26927: POP
// end ;
26928: GO 26545
26930: POP
26931: POP
// end ;
26932: LD_VAR 0 1
26936: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
26937: LD_INT 0
26939: PPUSH
26940: PPUSH
26941: PPUSH
26942: PPUSH
26943: PPUSH
// if not mc_bases then
26944: LD_EXP 49
26948: NOT
26949: IFFALSE 26953
// exit ;
26951: GO 28096
// for i = 1 to mc_bases do
26953: LD_ADDR_VAR 0 2
26957: PUSH
26958: DOUBLE
26959: LD_INT 1
26961: DEC
26962: ST_TO_ADDR
26963: LD_EXP 49
26967: PUSH
26968: FOR_TO
26969: IFFALSE 28094
// begin if mc_scan [ i ] then
26971: LD_EXP 72
26975: PUSH
26976: LD_VAR 0 2
26980: ARRAY
26981: IFFALSE 26985
// continue ;
26983: GO 26968
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
26985: LD_EXP 54
26989: PUSH
26990: LD_VAR 0 2
26994: ARRAY
26995: NOT
26996: PUSH
26997: LD_EXP 56
27001: PUSH
27002: LD_VAR 0 2
27006: ARRAY
27007: NOT
27008: AND
27009: PUSH
27010: LD_EXP 55
27014: PUSH
27015: LD_VAR 0 2
27019: ARRAY
27020: AND
27021: IFFALSE 27059
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27023: LD_ADDR_EXP 55
27027: PUSH
27028: LD_EXP 55
27032: PPUSH
27033: LD_VAR 0 2
27037: PPUSH
27038: EMPTY
27039: PPUSH
27040: CALL_OW 1
27044: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27045: LD_VAR 0 2
27049: PPUSH
27050: LD_INT 103
27052: PPUSH
27053: CALL 20895 0 2
// continue ;
27057: GO 26968
// end ; if mc_construct_list [ i ] then
27059: LD_EXP 56
27063: PUSH
27064: LD_VAR 0 2
27068: ARRAY
27069: IFFALSE 27289
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27071: LD_ADDR_VAR 0 4
27075: PUSH
27076: LD_EXP 49
27080: PUSH
27081: LD_VAR 0 2
27085: ARRAY
27086: PPUSH
27087: LD_INT 25
27089: PUSH
27090: LD_INT 2
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: PUSH
27102: LD_EXP 51
27106: PUSH
27107: LD_VAR 0 2
27111: ARRAY
27112: DIFF
27113: ST_TO_ADDR
// if not tmp then
27114: LD_VAR 0 4
27118: NOT
27119: IFFALSE 27123
// continue ;
27121: GO 26968
// for j in tmp do
27123: LD_ADDR_VAR 0 3
27127: PUSH
27128: LD_VAR 0 4
27132: PUSH
27133: FOR_IN
27134: IFFALSE 27285
// begin if not mc_builders [ i ] then
27136: LD_EXP 55
27140: PUSH
27141: LD_VAR 0 2
27145: ARRAY
27146: NOT
27147: IFFALSE 27205
// begin SetTag ( j , 103 ) ;
27149: LD_VAR 0 3
27153: PPUSH
27154: LD_INT 103
27156: PPUSH
27157: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27161: LD_ADDR_EXP 55
27165: PUSH
27166: LD_EXP 55
27170: PPUSH
27171: LD_VAR 0 2
27175: PUSH
27176: LD_EXP 55
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PUSH
27187: LD_INT 1
27189: PLUS
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PPUSH
27195: LD_VAR 0 3
27199: PPUSH
27200: CALL 54108 0 3
27204: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27205: LD_VAR 0 3
27209: PPUSH
27210: CALL_OW 310
27214: IFFALSE 27225
// ComExitBuilding ( j ) ;
27216: LD_VAR 0 3
27220: PPUSH
27221: CALL_OW 122
// wait ( 3 ) ;
27225: LD_INT 3
27227: PPUSH
27228: CALL_OW 67
// if not mc_construct_list [ i ] then
27232: LD_EXP 56
27236: PUSH
27237: LD_VAR 0 2
27241: ARRAY
27242: NOT
27243: IFFALSE 27247
// break ;
27245: GO 27285
// if not HasTask ( j ) then
27247: LD_VAR 0 3
27251: PPUSH
27252: CALL_OW 314
27256: NOT
27257: IFFALSE 27283
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27259: LD_VAR 0 3
27263: PPUSH
27264: LD_EXP 56
27268: PUSH
27269: LD_VAR 0 2
27273: ARRAY
27274: PUSH
27275: LD_INT 1
27277: ARRAY
27278: PPUSH
27279: CALL 56959 0 2
// end ;
27283: GO 27133
27285: POP
27286: POP
// end else
27287: GO 28092
// if mc_build_list [ i ] then
27289: LD_EXP 54
27293: PUSH
27294: LD_VAR 0 2
27298: ARRAY
27299: IFFALSE 28092
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27301: LD_ADDR_VAR 0 5
27305: PUSH
27306: LD_EXP 49
27310: PUSH
27311: LD_VAR 0 2
27315: ARRAY
27316: PPUSH
27317: LD_INT 2
27319: PUSH
27320: LD_INT 30
27322: PUSH
27323: LD_INT 0
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 30
27332: PUSH
27333: LD_INT 1
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: LIST
27344: PPUSH
27345: CALL_OW 72
27349: ST_TO_ADDR
// if depot then
27350: LD_VAR 0 5
27354: IFFALSE 27372
// depot := depot [ 1 ] else
27356: LD_ADDR_VAR 0 5
27360: PUSH
27361: LD_VAR 0 5
27365: PUSH
27366: LD_INT 1
27368: ARRAY
27369: ST_TO_ADDR
27370: GO 27380
// depot := 0 ;
27372: LD_ADDR_VAR 0 5
27376: PUSH
27377: LD_INT 0
27379: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27380: LD_EXP 54
27384: PUSH
27385: LD_VAR 0 2
27389: ARRAY
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: PUSH
27395: LD_INT 1
27397: ARRAY
27398: PPUSH
27399: CALL 56789 0 1
27403: PUSH
27404: LD_EXP 49
27408: PUSH
27409: LD_VAR 0 2
27413: ARRAY
27414: PPUSH
27415: LD_INT 2
27417: PUSH
27418: LD_INT 30
27420: PUSH
27421: LD_INT 2
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 30
27430: PUSH
27431: LD_INT 3
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: LIST
27442: PPUSH
27443: CALL_OW 72
27447: NOT
27448: AND
27449: IFFALSE 27554
// begin for j = 1 to mc_build_list [ i ] do
27451: LD_ADDR_VAR 0 3
27455: PUSH
27456: DOUBLE
27457: LD_INT 1
27459: DEC
27460: ST_TO_ADDR
27461: LD_EXP 54
27465: PUSH
27466: LD_VAR 0 2
27470: ARRAY
27471: PUSH
27472: FOR_TO
27473: IFFALSE 27552
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
27475: LD_EXP 54
27479: PUSH
27480: LD_VAR 0 2
27484: ARRAY
27485: PUSH
27486: LD_VAR 0 3
27490: ARRAY
27491: PUSH
27492: LD_INT 1
27494: ARRAY
27495: PUSH
27496: LD_INT 2
27498: EQUAL
27499: IFFALSE 27550
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
27501: LD_ADDR_EXP 54
27505: PUSH
27506: LD_EXP 54
27510: PPUSH
27511: LD_VAR 0 2
27515: PPUSH
27516: LD_EXP 54
27520: PUSH
27521: LD_VAR 0 2
27525: ARRAY
27526: PPUSH
27527: LD_VAR 0 3
27531: PPUSH
27532: LD_INT 1
27534: PPUSH
27535: LD_INT 0
27537: PPUSH
27538: CALL 53526 0 4
27542: PPUSH
27543: CALL_OW 1
27547: ST_TO_ADDR
// break ;
27548: GO 27552
// end ;
27550: GO 27472
27552: POP
27553: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
27554: LD_EXP 54
27558: PUSH
27559: LD_VAR 0 2
27563: ARRAY
27564: PUSH
27565: LD_INT 1
27567: ARRAY
27568: PUSH
27569: LD_INT 1
27571: ARRAY
27572: PUSH
27573: LD_INT 0
27575: EQUAL
27576: PUSH
27577: LD_VAR 0 5
27581: PUSH
27582: LD_VAR 0 5
27586: PPUSH
27587: LD_EXP 54
27591: PUSH
27592: LD_VAR 0 2
27596: ARRAY
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PUSH
27602: LD_INT 1
27604: ARRAY
27605: PPUSH
27606: LD_EXP 54
27610: PUSH
27611: LD_VAR 0 2
27615: ARRAY
27616: PUSH
27617: LD_INT 1
27619: ARRAY
27620: PUSH
27621: LD_INT 2
27623: ARRAY
27624: PPUSH
27625: LD_EXP 54
27629: PUSH
27630: LD_VAR 0 2
27634: ARRAY
27635: PUSH
27636: LD_INT 1
27638: ARRAY
27639: PUSH
27640: LD_INT 3
27642: ARRAY
27643: PPUSH
27644: LD_EXP 54
27648: PUSH
27649: LD_VAR 0 2
27653: ARRAY
27654: PUSH
27655: LD_INT 1
27657: ARRAY
27658: PUSH
27659: LD_INT 4
27661: ARRAY
27662: PPUSH
27663: CALL 61523 0 5
27667: AND
27668: OR
27669: IFFALSE 27950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27671: LD_ADDR_VAR 0 4
27675: PUSH
27676: LD_EXP 49
27680: PUSH
27681: LD_VAR 0 2
27685: ARRAY
27686: PPUSH
27687: LD_INT 25
27689: PUSH
27690: LD_INT 2
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PPUSH
27697: CALL_OW 72
27701: PUSH
27702: LD_EXP 51
27706: PUSH
27707: LD_VAR 0 2
27711: ARRAY
27712: DIFF
27713: ST_TO_ADDR
// if not tmp then
27714: LD_VAR 0 4
27718: NOT
27719: IFFALSE 27723
// continue ;
27721: GO 26968
// for j in tmp do
27723: LD_ADDR_VAR 0 3
27727: PUSH
27728: LD_VAR 0 4
27732: PUSH
27733: FOR_IN
27734: IFFALSE 27946
// begin if not mc_builders [ i ] then
27736: LD_EXP 55
27740: PUSH
27741: LD_VAR 0 2
27745: ARRAY
27746: NOT
27747: IFFALSE 27805
// begin SetTag ( j , 103 ) ;
27749: LD_VAR 0 3
27753: PPUSH
27754: LD_INT 103
27756: PPUSH
27757: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27761: LD_ADDR_EXP 55
27765: PUSH
27766: LD_EXP 55
27770: PPUSH
27771: LD_VAR 0 2
27775: PUSH
27776: LD_EXP 55
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: PUSH
27787: LD_INT 1
27789: PLUS
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PPUSH
27795: LD_VAR 0 3
27799: PPUSH
27800: CALL 54108 0 3
27804: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27805: LD_VAR 0 3
27809: PPUSH
27810: CALL_OW 310
27814: IFFALSE 27825
// ComExitBuilding ( j ) ;
27816: LD_VAR 0 3
27820: PPUSH
27821: CALL_OW 122
// wait ( 3 ) ;
27825: LD_INT 3
27827: PPUSH
27828: CALL_OW 67
// if not mc_build_list [ i ] then
27832: LD_EXP 54
27836: PUSH
27837: LD_VAR 0 2
27841: ARRAY
27842: NOT
27843: IFFALSE 27847
// break ;
27845: GO 27946
// if not HasTask ( j ) then
27847: LD_VAR 0 3
27851: PPUSH
27852: CALL_OW 314
27856: NOT
27857: IFFALSE 27944
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
27859: LD_VAR 0 3
27863: PPUSH
27864: LD_EXP 54
27868: PUSH
27869: LD_VAR 0 2
27873: ARRAY
27874: PUSH
27875: LD_INT 1
27877: ARRAY
27878: PUSH
27879: LD_INT 1
27881: ARRAY
27882: PPUSH
27883: LD_EXP 54
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PUSH
27894: LD_INT 1
27896: ARRAY
27897: PUSH
27898: LD_INT 2
27900: ARRAY
27901: PPUSH
27902: LD_EXP 54
27906: PUSH
27907: LD_VAR 0 2
27911: ARRAY
27912: PUSH
27913: LD_INT 1
27915: ARRAY
27916: PUSH
27917: LD_INT 3
27919: ARRAY
27920: PPUSH
27921: LD_EXP 54
27925: PUSH
27926: LD_VAR 0 2
27930: ARRAY
27931: PUSH
27932: LD_INT 1
27934: ARRAY
27935: PUSH
27936: LD_INT 4
27938: ARRAY
27939: PPUSH
27940: CALL_OW 145
// end ;
27944: GO 27733
27946: POP
27947: POP
// end else
27948: GO 28092
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
27950: LD_EXP 49
27954: PUSH
27955: LD_VAR 0 2
27959: ARRAY
27960: PPUSH
27961: LD_EXP 54
27965: PUSH
27966: LD_VAR 0 2
27970: ARRAY
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PUSH
27976: LD_INT 1
27978: ARRAY
27979: PPUSH
27980: LD_EXP 54
27984: PUSH
27985: LD_VAR 0 2
27989: ARRAY
27990: PUSH
27991: LD_INT 1
27993: ARRAY
27994: PUSH
27995: LD_INT 2
27997: ARRAY
27998: PPUSH
27999: LD_EXP 54
28003: PUSH
28004: LD_VAR 0 2
28008: ARRAY
28009: PUSH
28010: LD_INT 1
28012: ARRAY
28013: PUSH
28014: LD_INT 3
28016: ARRAY
28017: PPUSH
28018: LD_EXP 54
28022: PUSH
28023: LD_VAR 0 2
28027: ARRAY
28028: PUSH
28029: LD_INT 1
28031: ARRAY
28032: PUSH
28033: LD_INT 4
28035: ARRAY
28036: PPUSH
28037: CALL 60859 0 5
28041: NOT
28042: IFFALSE 28092
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28044: LD_ADDR_EXP 54
28048: PUSH
28049: LD_EXP 54
28053: PPUSH
28054: LD_VAR 0 2
28058: PPUSH
28059: LD_EXP 54
28063: PUSH
28064: LD_VAR 0 2
28068: ARRAY
28069: PPUSH
28070: LD_INT 1
28072: PPUSH
28073: LD_INT 1
28075: NEG
28076: PPUSH
28077: LD_INT 0
28079: PPUSH
28080: CALL 53526 0 4
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// continue ;
28090: GO 26968
// end ; end ; end ;
28092: GO 26968
28094: POP
28095: POP
// end ;
28096: LD_VAR 0 1
28100: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28101: LD_INT 0
28103: PPUSH
28104: PPUSH
28105: PPUSH
28106: PPUSH
28107: PPUSH
28108: PPUSH
// if not mc_bases then
28109: LD_EXP 49
28113: NOT
28114: IFFALSE 28118
// exit ;
28116: GO 28545
// for i = 1 to mc_bases do
28118: LD_ADDR_VAR 0 2
28122: PUSH
28123: DOUBLE
28124: LD_INT 1
28126: DEC
28127: ST_TO_ADDR
28128: LD_EXP 49
28132: PUSH
28133: FOR_TO
28134: IFFALSE 28543
// begin tmp := mc_build_upgrade [ i ] ;
28136: LD_ADDR_VAR 0 4
28140: PUSH
28141: LD_EXP 81
28145: PUSH
28146: LD_VAR 0 2
28150: ARRAY
28151: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28152: LD_ADDR_VAR 0 6
28156: PUSH
28157: LD_EXP 82
28161: PUSH
28162: LD_VAR 0 2
28166: ARRAY
28167: PPUSH
28168: LD_INT 2
28170: PUSH
28171: LD_INT 30
28173: PUSH
28174: LD_INT 6
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 30
28183: PUSH
28184: LD_INT 7
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: LIST
28195: PPUSH
28196: CALL_OW 72
28200: ST_TO_ADDR
// if not tmp and not lab then
28201: LD_VAR 0 4
28205: NOT
28206: PUSH
28207: LD_VAR 0 6
28211: NOT
28212: AND
28213: IFFALSE 28217
// continue ;
28215: GO 28133
// if tmp then
28217: LD_VAR 0 4
28221: IFFALSE 28341
// for j in tmp do
28223: LD_ADDR_VAR 0 3
28227: PUSH
28228: LD_VAR 0 4
28232: PUSH
28233: FOR_IN
28234: IFFALSE 28339
// begin if UpgradeCost ( j ) then
28236: LD_VAR 0 3
28240: PPUSH
28241: CALL 60519 0 1
28245: IFFALSE 28337
// begin ComUpgrade ( j ) ;
28247: LD_VAR 0 3
28251: PPUSH
28252: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28256: LD_ADDR_EXP 81
28260: PUSH
28261: LD_EXP 81
28265: PPUSH
28266: LD_VAR 0 2
28270: PPUSH
28271: LD_EXP 81
28275: PUSH
28276: LD_VAR 0 2
28280: ARRAY
28281: PUSH
28282: LD_VAR 0 3
28286: DIFF
28287: PPUSH
28288: CALL_OW 1
28292: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28293: LD_ADDR_EXP 56
28297: PUSH
28298: LD_EXP 56
28302: PPUSH
28303: LD_VAR 0 2
28307: PUSH
28308: LD_EXP 56
28312: PUSH
28313: LD_VAR 0 2
28317: ARRAY
28318: PUSH
28319: LD_INT 1
28321: PLUS
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PPUSH
28327: LD_VAR 0 3
28331: PPUSH
28332: CALL 54108 0 3
28336: ST_TO_ADDR
// end ; end ;
28337: GO 28233
28339: POP
28340: POP
// if not lab or not mc_lab_upgrade [ i ] then
28341: LD_VAR 0 6
28345: NOT
28346: PUSH
28347: LD_EXP 83
28351: PUSH
28352: LD_VAR 0 2
28356: ARRAY
28357: NOT
28358: OR
28359: IFFALSE 28363
// continue ;
28361: GO 28133
// for j in lab do
28363: LD_ADDR_VAR 0 3
28367: PUSH
28368: LD_VAR 0 6
28372: PUSH
28373: FOR_IN
28374: IFFALSE 28539
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28376: LD_VAR 0 3
28380: PPUSH
28381: CALL_OW 266
28385: PUSH
28386: LD_INT 6
28388: PUSH
28389: LD_INT 7
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: IN
28396: PUSH
28397: LD_VAR 0 3
28401: PPUSH
28402: CALL_OW 461
28406: PUSH
28407: LD_INT 1
28409: NONEQUAL
28410: AND
28411: IFFALSE 28537
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28413: LD_VAR 0 3
28417: PPUSH
28418: LD_EXP 83
28422: PUSH
28423: LD_VAR 0 2
28427: ARRAY
28428: PUSH
28429: LD_INT 1
28431: ARRAY
28432: PPUSH
28433: CALL 60724 0 2
28437: IFFALSE 28537
// begin ComCancel ( j ) ;
28439: LD_VAR 0 3
28443: PPUSH
28444: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28448: LD_VAR 0 3
28452: PPUSH
28453: LD_EXP 83
28457: PUSH
28458: LD_VAR 0 2
28462: ARRAY
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: PPUSH
28468: CALL_OW 207
// if not j in mc_construct_list [ i ] then
28472: LD_VAR 0 3
28476: PUSH
28477: LD_EXP 56
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: IN
28488: NOT
28489: IFFALSE 28535
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28491: LD_ADDR_EXP 56
28495: PUSH
28496: LD_EXP 56
28500: PPUSH
28501: LD_VAR 0 2
28505: PUSH
28506: LD_EXP 56
28510: PUSH
28511: LD_VAR 0 2
28515: ARRAY
28516: PUSH
28517: LD_INT 1
28519: PLUS
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: LD_VAR 0 3
28529: PPUSH
28530: CALL 54108 0 3
28534: ST_TO_ADDR
// break ;
28535: GO 28539
// end ; end ; end ;
28537: GO 28373
28539: POP
28540: POP
// end ;
28541: GO 28133
28543: POP
28544: POP
// end ;
28545: LD_VAR 0 1
28549: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
28550: LD_INT 0
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
28560: PPUSH
// if not mc_bases then
28561: LD_EXP 49
28565: NOT
28566: IFFALSE 28570
// exit ;
28568: GO 28975
// for i = 1 to mc_bases do
28570: LD_ADDR_VAR 0 2
28574: PUSH
28575: DOUBLE
28576: LD_INT 1
28578: DEC
28579: ST_TO_ADDR
28580: LD_EXP 49
28584: PUSH
28585: FOR_TO
28586: IFFALSE 28973
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
28588: LD_EXP 57
28592: PUSH
28593: LD_VAR 0 2
28597: ARRAY
28598: NOT
28599: PUSH
28600: LD_EXP 49
28604: PUSH
28605: LD_VAR 0 2
28609: ARRAY
28610: PPUSH
28611: LD_INT 30
28613: PUSH
28614: LD_INT 3
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PPUSH
28621: CALL_OW 72
28625: NOT
28626: OR
28627: IFFALSE 28631
// continue ;
28629: GO 28585
// busy := false ;
28631: LD_ADDR_VAR 0 8
28635: PUSH
28636: LD_INT 0
28638: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28639: LD_ADDR_VAR 0 4
28643: PUSH
28644: LD_EXP 49
28648: PUSH
28649: LD_VAR 0 2
28653: ARRAY
28654: PPUSH
28655: LD_INT 30
28657: PUSH
28658: LD_INT 3
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PPUSH
28665: CALL_OW 72
28669: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_EXP 57
28679: PUSH
28680: LD_VAR 0 2
28684: ARRAY
28685: PPUSH
28686: LD_INT 2
28688: PUSH
28689: LD_INT 30
28691: PUSH
28692: LD_INT 32
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 30
28701: PUSH
28702: LD_INT 33
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: LIST
28713: PPUSH
28714: CALL_OW 72
28718: ST_TO_ADDR
// if not t then
28719: LD_VAR 0 6
28723: NOT
28724: IFFALSE 28728
// continue ;
28726: GO 28585
// for j in tmp do
28728: LD_ADDR_VAR 0 3
28732: PUSH
28733: LD_VAR 0 4
28737: PUSH
28738: FOR_IN
28739: IFFALSE 28769
// if not BuildingStatus ( j ) = bs_idle then
28741: LD_VAR 0 3
28745: PPUSH
28746: CALL_OW 461
28750: PUSH
28751: LD_INT 2
28753: EQUAL
28754: NOT
28755: IFFALSE 28767
// begin busy := true ;
28757: LD_ADDR_VAR 0 8
28761: PUSH
28762: LD_INT 1
28764: ST_TO_ADDR
// break ;
28765: GO 28769
// end ;
28767: GO 28738
28769: POP
28770: POP
// if busy then
28771: LD_VAR 0 8
28775: IFFALSE 28779
// continue ;
28777: GO 28585
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
28779: LD_ADDR_VAR 0 7
28783: PUSH
28784: LD_VAR 0 6
28788: PPUSH
28789: LD_INT 35
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PPUSH
28799: CALL_OW 72
28803: ST_TO_ADDR
// if tw then
28804: LD_VAR 0 7
28808: IFFALSE 28885
// begin tw := tw [ 1 ] ;
28810: LD_ADDR_VAR 0 7
28814: PUSH
28815: LD_VAR 0 7
28819: PUSH
28820: LD_INT 1
28822: ARRAY
28823: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
28824: LD_ADDR_VAR 0 9
28828: PUSH
28829: LD_VAR 0 7
28833: PPUSH
28834: LD_EXP 74
28838: PUSH
28839: LD_VAR 0 2
28843: ARRAY
28844: PPUSH
28845: CALL 59078 0 2
28849: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
28850: LD_EXP 88
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: IFFALSE 28883
// if not weapon in mc_allowed_tower_weapons [ i ] then
28862: LD_VAR 0 9
28866: PUSH
28867: LD_EXP 88
28871: PUSH
28872: LD_VAR 0 2
28876: ARRAY
28877: IN
28878: NOT
28879: IFFALSE 28883
// continue ;
28881: GO 28585
// end else
28883: GO 28948
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
28885: LD_ADDR_VAR 0 5
28889: PUSH
28890: LD_EXP 57
28894: PUSH
28895: LD_VAR 0 2
28899: ARRAY
28900: PPUSH
28901: LD_VAR 0 4
28905: PPUSH
28906: CALL 89279 0 2
28910: ST_TO_ADDR
// if not tmp2 then
28911: LD_VAR 0 5
28915: NOT
28916: IFFALSE 28920
// continue ;
28918: GO 28585
// tw := tmp2 [ 1 ] ;
28920: LD_ADDR_VAR 0 7
28924: PUSH
28925: LD_VAR 0 5
28929: PUSH
28930: LD_INT 1
28932: ARRAY
28933: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
28934: LD_ADDR_VAR 0 9
28938: PUSH
28939: LD_VAR 0 5
28943: PUSH
28944: LD_INT 2
28946: ARRAY
28947: ST_TO_ADDR
// end ; if not weapon then
28948: LD_VAR 0 9
28952: NOT
28953: IFFALSE 28957
// continue ;
28955: GO 28585
// ComPlaceWeapon ( tw , weapon ) ;
28957: LD_VAR 0 7
28961: PPUSH
28962: LD_VAR 0 9
28966: PPUSH
28967: CALL_OW 148
// end ;
28971: GO 28585
28973: POP
28974: POP
// end ;
28975: LD_VAR 0 1
28979: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
28980: LD_INT 0
28982: PPUSH
28983: PPUSH
28984: PPUSH
28985: PPUSH
28986: PPUSH
28987: PPUSH
// if not mc_bases then
28988: LD_EXP 49
28992: NOT
28993: IFFALSE 28997
// exit ;
28995: GO 30009
// for i = 1 to mc_bases do
28997: LD_ADDR_VAR 0 2
29001: PUSH
29002: DOUBLE
29003: LD_INT 1
29005: DEC
29006: ST_TO_ADDR
29007: LD_EXP 49
29011: PUSH
29012: FOR_TO
29013: IFFALSE 30007
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
29015: LD_EXP 62
29019: PUSH
29020: LD_VAR 0 2
29024: ARRAY
29025: NOT
29026: PUSH
29027: LD_EXP 62
29031: PUSH
29032: LD_VAR 0 2
29036: ARRAY
29037: PUSH
29038: LD_EXP 63
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: EQUAL
29049: OR
29050: IFFALSE 29054
// continue ;
29052: GO 29012
// if mc_miners [ i ] then
29054: LD_EXP 63
29058: PUSH
29059: LD_VAR 0 2
29063: ARRAY
29064: IFFALSE 29694
// begin k := 1 ;
29066: LD_ADDR_VAR 0 4
29070: PUSH
29071: LD_INT 1
29073: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
29074: LD_ADDR_VAR 0 3
29078: PUSH
29079: DOUBLE
29080: LD_EXP 63
29084: PUSH
29085: LD_VAR 0 2
29089: ARRAY
29090: INC
29091: ST_TO_ADDR
29092: LD_INT 1
29094: PUSH
29095: FOR_DOWNTO
29096: IFFALSE 29692
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29098: LD_EXP 63
29102: PUSH
29103: LD_VAR 0 2
29107: ARRAY
29108: PUSH
29109: LD_VAR 0 3
29113: ARRAY
29114: PPUSH
29115: CALL_OW 301
29119: PUSH
29120: LD_EXP 63
29124: PUSH
29125: LD_VAR 0 2
29129: ARRAY
29130: PUSH
29131: LD_VAR 0 3
29135: ARRAY
29136: PPUSH
29137: CALL_OW 257
29141: PUSH
29142: LD_INT 1
29144: NONEQUAL
29145: OR
29146: IFFALSE 29209
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29148: LD_ADDR_VAR 0 5
29152: PUSH
29153: LD_EXP 63
29157: PUSH
29158: LD_VAR 0 2
29162: ARRAY
29163: PUSH
29164: LD_EXP 63
29168: PUSH
29169: LD_VAR 0 2
29173: ARRAY
29174: PUSH
29175: LD_VAR 0 3
29179: ARRAY
29180: DIFF
29181: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29182: LD_ADDR_EXP 63
29186: PUSH
29187: LD_EXP 63
29191: PPUSH
29192: LD_VAR 0 2
29196: PPUSH
29197: LD_VAR 0 5
29201: PPUSH
29202: CALL_OW 1
29206: ST_TO_ADDR
// continue ;
29207: GO 29095
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
29209: LD_EXP 63
29213: PUSH
29214: LD_VAR 0 2
29218: ARRAY
29219: PUSH
29220: LD_VAR 0 3
29224: ARRAY
29225: PPUSH
29226: CALL 54044 0 1
29230: PUSH
29231: LD_EXP 63
29235: PUSH
29236: LD_VAR 0 2
29240: ARRAY
29241: PUSH
29242: LD_VAR 0 3
29246: ARRAY
29247: PPUSH
29248: CALL_OW 255
29252: PPUSH
29253: LD_EXP 62
29257: PUSH
29258: LD_VAR 0 2
29262: ARRAY
29263: PUSH
29264: LD_VAR 0 4
29268: ARRAY
29269: PUSH
29270: LD_INT 1
29272: ARRAY
29273: PPUSH
29274: LD_EXP 62
29278: PUSH
29279: LD_VAR 0 2
29283: ARRAY
29284: PUSH
29285: LD_VAR 0 4
29289: ARRAY
29290: PUSH
29291: LD_INT 2
29293: ARRAY
29294: PPUSH
29295: LD_INT 15
29297: PPUSH
29298: CALL 55004 0 4
29302: PUSH
29303: LD_INT 4
29305: ARRAY
29306: PUSH
29307: LD_EXP 63
29311: PUSH
29312: LD_VAR 0 2
29316: ARRAY
29317: PUSH
29318: LD_VAR 0 3
29322: ARRAY
29323: PPUSH
29324: LD_INT 10
29326: PPUSH
29327: CALL 56701 0 2
29331: PUSH
29332: LD_INT 4
29334: ARRAY
29335: OR
29336: AND
29337: IFFALSE 29360
// ComStop ( mc_miners [ i ] [ j ] ) ;
29339: LD_EXP 63
29343: PUSH
29344: LD_VAR 0 2
29348: ARRAY
29349: PUSH
29350: LD_VAR 0 3
29354: ARRAY
29355: PPUSH
29356: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
29360: LD_EXP 63
29364: PUSH
29365: LD_VAR 0 2
29369: ARRAY
29370: PUSH
29371: LD_VAR 0 3
29375: ARRAY
29376: PPUSH
29377: CALL_OW 257
29381: PUSH
29382: LD_INT 1
29384: EQUAL
29385: PUSH
29386: LD_EXP 63
29390: PUSH
29391: LD_VAR 0 2
29395: ARRAY
29396: PUSH
29397: LD_VAR 0 3
29401: ARRAY
29402: PPUSH
29403: CALL_OW 459
29407: NOT
29408: AND
29409: PUSH
29410: LD_EXP 63
29414: PUSH
29415: LD_VAR 0 2
29419: ARRAY
29420: PUSH
29421: LD_VAR 0 3
29425: ARRAY
29426: PPUSH
29427: CALL_OW 255
29431: PPUSH
29432: LD_EXP 62
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_VAR 0 4
29447: ARRAY
29448: PUSH
29449: LD_INT 1
29451: ARRAY
29452: PPUSH
29453: LD_EXP 62
29457: PUSH
29458: LD_VAR 0 2
29462: ARRAY
29463: PUSH
29464: LD_VAR 0 4
29468: ARRAY
29469: PUSH
29470: LD_INT 2
29472: ARRAY
29473: PPUSH
29474: LD_INT 15
29476: PPUSH
29477: CALL 55004 0 4
29481: PUSH
29482: LD_INT 4
29484: ARRAY
29485: PUSH
29486: LD_INT 0
29488: EQUAL
29489: AND
29490: PUSH
29491: LD_EXP 63
29495: PUSH
29496: LD_VAR 0 2
29500: ARRAY
29501: PUSH
29502: LD_VAR 0 3
29506: ARRAY
29507: PPUSH
29508: CALL_OW 314
29512: NOT
29513: AND
29514: IFFALSE 29690
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29516: LD_EXP 63
29520: PUSH
29521: LD_VAR 0 2
29525: ARRAY
29526: PUSH
29527: LD_VAR 0 3
29531: ARRAY
29532: PPUSH
29533: CALL_OW 310
29537: IFFALSE 29560
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29539: LD_EXP 63
29543: PUSH
29544: LD_VAR 0 2
29548: ARRAY
29549: PUSH
29550: LD_VAR 0 3
29554: ARRAY
29555: PPUSH
29556: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29560: LD_EXP 63
29564: PUSH
29565: LD_VAR 0 2
29569: ARRAY
29570: PUSH
29571: LD_VAR 0 3
29575: ARRAY
29576: PPUSH
29577: CALL_OW 314
29581: NOT
29582: IFFALSE 29650
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
29584: LD_EXP 63
29588: PUSH
29589: LD_VAR 0 2
29593: ARRAY
29594: PUSH
29595: LD_VAR 0 3
29599: ARRAY
29600: PPUSH
29601: LD_EXP 62
29605: PUSH
29606: LD_VAR 0 2
29610: ARRAY
29611: PUSH
29612: LD_VAR 0 4
29616: ARRAY
29617: PUSH
29618: LD_INT 1
29620: ARRAY
29621: PPUSH
29622: LD_EXP 62
29626: PUSH
29627: LD_VAR 0 2
29631: ARRAY
29632: PUSH
29633: LD_VAR 0 4
29637: ARRAY
29638: PUSH
29639: LD_INT 2
29641: ARRAY
29642: PPUSH
29643: LD_INT 0
29645: PPUSH
29646: CALL_OW 193
// k := k + 1 ;
29650: LD_ADDR_VAR 0 4
29654: PUSH
29655: LD_VAR 0 4
29659: PUSH
29660: LD_INT 1
29662: PLUS
29663: ST_TO_ADDR
// if k > mc_mines [ i ] then
29664: LD_VAR 0 4
29668: PUSH
29669: LD_EXP 62
29673: PUSH
29674: LD_VAR 0 2
29678: ARRAY
29679: GREATER
29680: IFFALSE 29690
// k := 1 ;
29682: LD_ADDR_VAR 0 4
29686: PUSH
29687: LD_INT 1
29689: ST_TO_ADDR
// end ; end ;
29690: GO 29095
29692: POP
29693: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
29694: LD_ADDR_VAR 0 5
29698: PUSH
29699: LD_EXP 49
29703: PUSH
29704: LD_VAR 0 2
29708: ARRAY
29709: PPUSH
29710: LD_INT 2
29712: PUSH
29713: LD_INT 30
29715: PUSH
29716: LD_INT 4
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 30
29725: PUSH
29726: LD_INT 5
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 30
29735: PUSH
29736: LD_INT 32
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: PPUSH
29749: CALL_OW 72
29753: ST_TO_ADDR
// if not tmp then
29754: LD_VAR 0 5
29758: NOT
29759: IFFALSE 29763
// continue ;
29761: GO 29012
// list := [ ] ;
29763: LD_ADDR_VAR 0 6
29767: PUSH
29768: EMPTY
29769: ST_TO_ADDR
// for j in tmp do
29770: LD_ADDR_VAR 0 3
29774: PUSH
29775: LD_VAR 0 5
29779: PUSH
29780: FOR_IN
29781: IFFALSE 29850
// begin for k in UnitsInside ( j ) do
29783: LD_ADDR_VAR 0 4
29787: PUSH
29788: LD_VAR 0 3
29792: PPUSH
29793: CALL_OW 313
29797: PUSH
29798: FOR_IN
29799: IFFALSE 29846
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
29801: LD_VAR 0 4
29805: PPUSH
29806: CALL_OW 257
29810: PUSH
29811: LD_INT 1
29813: EQUAL
29814: PUSH
29815: LD_VAR 0 4
29819: PPUSH
29820: CALL_OW 459
29824: NOT
29825: AND
29826: IFFALSE 29844
// list := list ^ k ;
29828: LD_ADDR_VAR 0 6
29832: PUSH
29833: LD_VAR 0 6
29837: PUSH
29838: LD_VAR 0 4
29842: ADD
29843: ST_TO_ADDR
29844: GO 29798
29846: POP
29847: POP
// end ;
29848: GO 29780
29850: POP
29851: POP
// list := list diff mc_miners [ i ] ;
29852: LD_ADDR_VAR 0 6
29856: PUSH
29857: LD_VAR 0 6
29861: PUSH
29862: LD_EXP 63
29866: PUSH
29867: LD_VAR 0 2
29871: ARRAY
29872: DIFF
29873: ST_TO_ADDR
// if not list then
29874: LD_VAR 0 6
29878: NOT
29879: IFFALSE 29883
// continue ;
29881: GO 29012
// k := mc_mines [ i ] - mc_miners [ i ] ;
29883: LD_ADDR_VAR 0 4
29887: PUSH
29888: LD_EXP 62
29892: PUSH
29893: LD_VAR 0 2
29897: ARRAY
29898: PUSH
29899: LD_EXP 63
29903: PUSH
29904: LD_VAR 0 2
29908: ARRAY
29909: MINUS
29910: ST_TO_ADDR
// if k > list then
29911: LD_VAR 0 4
29915: PUSH
29916: LD_VAR 0 6
29920: GREATER
29921: IFFALSE 29933
// k := list ;
29923: LD_ADDR_VAR 0 4
29927: PUSH
29928: LD_VAR 0 6
29932: ST_TO_ADDR
// for j = 1 to k do
29933: LD_ADDR_VAR 0 3
29937: PUSH
29938: DOUBLE
29939: LD_INT 1
29941: DEC
29942: ST_TO_ADDR
29943: LD_VAR 0 4
29947: PUSH
29948: FOR_TO
29949: IFFALSE 30003
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
29951: LD_ADDR_EXP 63
29955: PUSH
29956: LD_EXP 63
29960: PPUSH
29961: LD_VAR 0 2
29965: PUSH
29966: LD_EXP 63
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: PUSH
29977: LD_INT 1
29979: PLUS
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PPUSH
29985: LD_VAR 0 6
29989: PUSH
29990: LD_VAR 0 3
29994: ARRAY
29995: PPUSH
29996: CALL 54108 0 3
30000: ST_TO_ADDR
30001: GO 29948
30003: POP
30004: POP
// end ;
30005: GO 29012
30007: POP
30008: POP
// end ;
30009: LD_VAR 0 1
30013: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30014: LD_INT 0
30016: PPUSH
30017: PPUSH
30018: PPUSH
30019: PPUSH
30020: PPUSH
30021: PPUSH
30022: PPUSH
30023: PPUSH
30024: PPUSH
30025: PPUSH
// if not mc_bases then
30026: LD_EXP 49
30030: NOT
30031: IFFALSE 30035
// exit ;
30033: GO 31785
// for i = 1 to mc_bases do
30035: LD_ADDR_VAR 0 2
30039: PUSH
30040: DOUBLE
30041: LD_INT 1
30043: DEC
30044: ST_TO_ADDR
30045: LD_EXP 49
30049: PUSH
30050: FOR_TO
30051: IFFALSE 31783
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30053: LD_EXP 49
30057: PUSH
30058: LD_VAR 0 2
30062: ARRAY
30063: NOT
30064: PUSH
30065: LD_EXP 56
30069: PUSH
30070: LD_VAR 0 2
30074: ARRAY
30075: OR
30076: IFFALSE 30080
// continue ;
30078: GO 30050
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30080: LD_EXP 65
30084: PUSH
30085: LD_VAR 0 2
30089: ARRAY
30090: NOT
30091: PUSH
30092: LD_EXP 66
30096: PUSH
30097: LD_VAR 0 2
30101: ARRAY
30102: AND
30103: IFFALSE 30141
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30105: LD_ADDR_EXP 66
30109: PUSH
30110: LD_EXP 66
30114: PPUSH
30115: LD_VAR 0 2
30119: PPUSH
30120: EMPTY
30121: PPUSH
30122: CALL_OW 1
30126: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30127: LD_VAR 0 2
30131: PPUSH
30132: LD_INT 107
30134: PPUSH
30135: CALL 20895 0 2
// continue ;
30139: GO 30050
// end ; target := [ ] ;
30141: LD_ADDR_VAR 0 6
30145: PUSH
30146: EMPTY
30147: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30148: LD_ADDR_VAR 0 3
30152: PUSH
30153: DOUBLE
30154: LD_EXP 65
30158: PUSH
30159: LD_VAR 0 2
30163: ARRAY
30164: INC
30165: ST_TO_ADDR
30166: LD_INT 1
30168: PUSH
30169: FOR_DOWNTO
30170: IFFALSE 30430
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30172: LD_EXP 65
30176: PUSH
30177: LD_VAR 0 2
30181: ARRAY
30182: PUSH
30183: LD_VAR 0 3
30187: ARRAY
30188: PUSH
30189: LD_INT 2
30191: ARRAY
30192: PPUSH
30193: LD_EXP 65
30197: PUSH
30198: LD_VAR 0 2
30202: ARRAY
30203: PUSH
30204: LD_VAR 0 3
30208: ARRAY
30209: PUSH
30210: LD_INT 3
30212: ARRAY
30213: PPUSH
30214: CALL_OW 488
30218: PUSH
30219: LD_EXP 65
30223: PUSH
30224: LD_VAR 0 2
30228: ARRAY
30229: PUSH
30230: LD_VAR 0 3
30234: ARRAY
30235: PUSH
30236: LD_INT 2
30238: ARRAY
30239: PPUSH
30240: LD_EXP 65
30244: PUSH
30245: LD_VAR 0 2
30249: ARRAY
30250: PUSH
30251: LD_VAR 0 3
30255: ARRAY
30256: PUSH
30257: LD_INT 3
30259: ARRAY
30260: PPUSH
30261: CALL_OW 284
30265: PUSH
30266: LD_INT 0
30268: EQUAL
30269: AND
30270: IFFALSE 30325
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30272: LD_ADDR_VAR 0 5
30276: PUSH
30277: LD_EXP 65
30281: PUSH
30282: LD_VAR 0 2
30286: ARRAY
30287: PPUSH
30288: LD_VAR 0 3
30292: PPUSH
30293: CALL_OW 3
30297: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30298: LD_ADDR_EXP 65
30302: PUSH
30303: LD_EXP 65
30307: PPUSH
30308: LD_VAR 0 2
30312: PPUSH
30313: LD_VAR 0 5
30317: PPUSH
30318: CALL_OW 1
30322: ST_TO_ADDR
// continue ;
30323: GO 30169
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30325: LD_EXP 49
30329: PUSH
30330: LD_VAR 0 2
30334: ARRAY
30335: PUSH
30336: LD_INT 1
30338: ARRAY
30339: PPUSH
30340: CALL_OW 255
30344: PPUSH
30345: LD_EXP 65
30349: PUSH
30350: LD_VAR 0 2
30354: ARRAY
30355: PUSH
30356: LD_VAR 0 3
30360: ARRAY
30361: PUSH
30362: LD_INT 2
30364: ARRAY
30365: PPUSH
30366: LD_EXP 65
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PUSH
30377: LD_VAR 0 3
30381: ARRAY
30382: PUSH
30383: LD_INT 3
30385: ARRAY
30386: PPUSH
30387: LD_INT 30
30389: PPUSH
30390: CALL 55004 0 4
30394: PUSH
30395: LD_INT 4
30397: ARRAY
30398: PUSH
30399: LD_INT 0
30401: EQUAL
30402: IFFALSE 30428
// begin target := mc_crates [ i ] [ j ] ;
30404: LD_ADDR_VAR 0 6
30408: PUSH
30409: LD_EXP 65
30413: PUSH
30414: LD_VAR 0 2
30418: ARRAY
30419: PUSH
30420: LD_VAR 0 3
30424: ARRAY
30425: ST_TO_ADDR
// break ;
30426: GO 30430
// end ; end ;
30428: GO 30169
30430: POP
30431: POP
// if not target then
30432: LD_VAR 0 6
30436: NOT
30437: IFFALSE 30441
// continue ;
30439: GO 30050
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30441: LD_ADDR_VAR 0 7
30445: PUSH
30446: LD_EXP 68
30450: PUSH
30451: LD_VAR 0 2
30455: ARRAY
30456: PPUSH
30457: LD_INT 2
30459: PUSH
30460: LD_INT 3
30462: PUSH
30463: LD_INT 58
30465: PUSH
30466: EMPTY
30467: LIST
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 61
30475: PUSH
30476: EMPTY
30477: LIST
30478: PUSH
30479: LD_INT 33
30481: PUSH
30482: LD_INT 5
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 33
30491: PUSH
30492: LD_INT 3
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 34
30511: PUSH
30512: LD_INT 32
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 34
30521: PUSH
30522: LD_INT 51
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 34
30531: PUSH
30532: LD_INT 12
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: LIST
30543: LIST
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PPUSH
30549: CALL_OW 72
30553: ST_TO_ADDR
// if not cargo then
30554: LD_VAR 0 7
30558: NOT
30559: IFFALSE 31202
// begin if mc_crates_collector [ i ] < 5 then
30561: LD_EXP 66
30565: PUSH
30566: LD_VAR 0 2
30570: ARRAY
30571: PUSH
30572: LD_INT 5
30574: LESS
30575: IFFALSE 30941
// begin if mc_ape [ i ] then
30577: LD_EXP 78
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: IFFALSE 30634
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30589: LD_ADDR_VAR 0 5
30593: PUSH
30594: LD_EXP 78
30598: PUSH
30599: LD_VAR 0 2
30603: ARRAY
30604: PPUSH
30605: LD_INT 25
30607: PUSH
30608: LD_INT 16
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 24
30617: PUSH
30618: LD_INT 750
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PPUSH
30629: CALL_OW 72
30633: ST_TO_ADDR
// if not tmp then
30634: LD_VAR 0 5
30638: NOT
30639: IFFALSE 30686
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30641: LD_ADDR_VAR 0 5
30645: PUSH
30646: LD_EXP 49
30650: PUSH
30651: LD_VAR 0 2
30655: ARRAY
30656: PPUSH
30657: LD_INT 25
30659: PUSH
30660: LD_INT 2
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 24
30669: PUSH
30670: LD_INT 750
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PPUSH
30681: CALL_OW 72
30685: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
30686: LD_EXP 78
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: PUSH
30697: LD_EXP 49
30701: PUSH
30702: LD_VAR 0 2
30706: ARRAY
30707: PPUSH
30708: LD_INT 25
30710: PUSH
30711: LD_INT 2
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 24
30720: PUSH
30721: LD_INT 750
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PPUSH
30732: CALL_OW 72
30736: AND
30737: PUSH
30738: LD_VAR 0 5
30742: PUSH
30743: LD_INT 5
30745: LESS
30746: AND
30747: IFFALSE 30829
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
30749: LD_ADDR_VAR 0 3
30753: PUSH
30754: LD_EXP 49
30758: PUSH
30759: LD_VAR 0 2
30763: ARRAY
30764: PPUSH
30765: LD_INT 25
30767: PUSH
30768: LD_INT 2
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 24
30777: PUSH
30778: LD_INT 750
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PPUSH
30789: CALL_OW 72
30793: PUSH
30794: FOR_IN
30795: IFFALSE 30827
// begin tmp := tmp union j ;
30797: LD_ADDR_VAR 0 5
30801: PUSH
30802: LD_VAR 0 5
30806: PUSH
30807: LD_VAR 0 3
30811: UNION
30812: ST_TO_ADDR
// if tmp >= 5 then
30813: LD_VAR 0 5
30817: PUSH
30818: LD_INT 5
30820: GREATEREQUAL
30821: IFFALSE 30825
// break ;
30823: GO 30827
// end ;
30825: GO 30794
30827: POP
30828: POP
// end ; if not tmp then
30829: LD_VAR 0 5
30833: NOT
30834: IFFALSE 30838
// continue ;
30836: GO 30050
// for j in tmp do
30838: LD_ADDR_VAR 0 3
30842: PUSH
30843: LD_VAR 0 5
30847: PUSH
30848: FOR_IN
30849: IFFALSE 30939
// if not GetTag ( j ) then
30851: LD_VAR 0 3
30855: PPUSH
30856: CALL_OW 110
30860: NOT
30861: IFFALSE 30937
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
30863: LD_ADDR_EXP 66
30867: PUSH
30868: LD_EXP 66
30872: PPUSH
30873: LD_VAR 0 2
30877: PUSH
30878: LD_EXP 66
30882: PUSH
30883: LD_VAR 0 2
30887: ARRAY
30888: PUSH
30889: LD_INT 1
30891: PLUS
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PPUSH
30897: LD_VAR 0 3
30901: PPUSH
30902: CALL 54108 0 3
30906: ST_TO_ADDR
// SetTag ( j , 107 ) ;
30907: LD_VAR 0 3
30911: PPUSH
30912: LD_INT 107
30914: PPUSH
30915: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
30919: LD_EXP 66
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: PUSH
30930: LD_INT 5
30932: GREATEREQUAL
30933: IFFALSE 30937
// break ;
30935: GO 30939
// end ;
30937: GO 30848
30939: POP
30940: POP
// end ; if mc_crates_collector [ i ] and target then
30941: LD_EXP 66
30945: PUSH
30946: LD_VAR 0 2
30950: ARRAY
30951: PUSH
30952: LD_VAR 0 6
30956: AND
30957: IFFALSE 31200
// begin if mc_crates_collector [ i ] < target [ 1 ] then
30959: LD_EXP 66
30963: PUSH
30964: LD_VAR 0 2
30968: ARRAY
30969: PUSH
30970: LD_VAR 0 6
30974: PUSH
30975: LD_INT 1
30977: ARRAY
30978: LESS
30979: IFFALSE 30999
// tmp := mc_crates_collector [ i ] else
30981: LD_ADDR_VAR 0 5
30985: PUSH
30986: LD_EXP 66
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: ST_TO_ADDR
30997: GO 31013
// tmp := target [ 1 ] ;
30999: LD_ADDR_VAR 0 5
31003: PUSH
31004: LD_VAR 0 6
31008: PUSH
31009: LD_INT 1
31011: ARRAY
31012: ST_TO_ADDR
// k := 0 ;
31013: LD_ADDR_VAR 0 4
31017: PUSH
31018: LD_INT 0
31020: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31021: LD_ADDR_VAR 0 3
31025: PUSH
31026: LD_EXP 66
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: PUSH
31037: FOR_IN
31038: IFFALSE 31198
// begin k := k + 1 ;
31040: LD_ADDR_VAR 0 4
31044: PUSH
31045: LD_VAR 0 4
31049: PUSH
31050: LD_INT 1
31052: PLUS
31053: ST_TO_ADDR
// if k > tmp then
31054: LD_VAR 0 4
31058: PUSH
31059: LD_VAR 0 5
31063: GREATER
31064: IFFALSE 31068
// break ;
31066: GO 31198
// if not GetClass ( j ) in [ 2 , 16 ] then
31068: LD_VAR 0 3
31072: PPUSH
31073: CALL_OW 257
31077: PUSH
31078: LD_INT 2
31080: PUSH
31081: LD_INT 16
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: IN
31088: NOT
31089: IFFALSE 31142
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31091: LD_ADDR_EXP 66
31095: PUSH
31096: LD_EXP 66
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_EXP 66
31110: PUSH
31111: LD_VAR 0 2
31115: ARRAY
31116: PUSH
31117: LD_VAR 0 3
31121: DIFF
31122: PPUSH
31123: CALL_OW 1
31127: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31128: LD_VAR 0 3
31132: PPUSH
31133: LD_INT 0
31135: PPUSH
31136: CALL_OW 109
// continue ;
31140: GO 31037
// end ; if IsInUnit ( j ) then
31142: LD_VAR 0 3
31146: PPUSH
31147: CALL_OW 310
31151: IFFALSE 31162
// ComExitBuilding ( j ) ;
31153: LD_VAR 0 3
31157: PPUSH
31158: CALL_OW 122
// wait ( 3 ) ;
31162: LD_INT 3
31164: PPUSH
31165: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31169: LD_VAR 0 3
31173: PPUSH
31174: LD_VAR 0 6
31178: PUSH
31179: LD_INT 2
31181: ARRAY
31182: PPUSH
31183: LD_VAR 0 6
31187: PUSH
31188: LD_INT 3
31190: ARRAY
31191: PPUSH
31192: CALL_OW 117
// end ;
31196: GO 31037
31198: POP
31199: POP
// end ; end else
31200: GO 31781
// begin for j in cargo do
31202: LD_ADDR_VAR 0 3
31206: PUSH
31207: LD_VAR 0 7
31211: PUSH
31212: FOR_IN
31213: IFFALSE 31779
// begin if GetTag ( j ) <> 0 then
31215: LD_VAR 0 3
31219: PPUSH
31220: CALL_OW 110
31224: PUSH
31225: LD_INT 0
31227: NONEQUAL
31228: IFFALSE 31232
// continue ;
31230: GO 31212
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31232: LD_VAR 0 3
31236: PPUSH
31237: CALL_OW 256
31241: PUSH
31242: LD_INT 1000
31244: LESS
31245: PUSH
31246: LD_VAR 0 3
31250: PPUSH
31251: LD_EXP 73
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: PPUSH
31262: CALL_OW 308
31266: NOT
31267: AND
31268: IFFALSE 31290
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31270: LD_VAR 0 3
31274: PPUSH
31275: LD_EXP 73
31279: PUSH
31280: LD_VAR 0 2
31284: ARRAY
31285: PPUSH
31286: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31290: LD_VAR 0 3
31294: PPUSH
31295: CALL_OW 256
31299: PUSH
31300: LD_INT 1000
31302: LESS
31303: PUSH
31304: LD_VAR 0 3
31308: PPUSH
31309: LD_EXP 73
31313: PUSH
31314: LD_VAR 0 2
31318: ARRAY
31319: PPUSH
31320: CALL_OW 308
31324: AND
31325: IFFALSE 31329
// continue ;
31327: GO 31212
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31329: LD_VAR 0 3
31333: PPUSH
31334: CALL_OW 262
31338: PUSH
31339: LD_INT 2
31341: EQUAL
31342: PUSH
31343: LD_VAR 0 3
31347: PPUSH
31348: CALL_OW 261
31352: PUSH
31353: LD_INT 15
31355: LESS
31356: AND
31357: IFFALSE 31361
// continue ;
31359: GO 31212
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31361: LD_VAR 0 3
31365: PPUSH
31366: CALL_OW 262
31370: PUSH
31371: LD_INT 1
31373: EQUAL
31374: PUSH
31375: LD_VAR 0 3
31379: PPUSH
31380: CALL_OW 261
31384: PUSH
31385: LD_INT 10
31387: LESS
31388: AND
31389: IFFALSE 31718
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31391: LD_ADDR_VAR 0 8
31395: PUSH
31396: LD_EXP 49
31400: PUSH
31401: LD_VAR 0 2
31405: ARRAY
31406: PPUSH
31407: LD_INT 2
31409: PUSH
31410: LD_INT 30
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 30
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: LIST
31434: PPUSH
31435: CALL_OW 72
31439: ST_TO_ADDR
// if not depot then
31440: LD_VAR 0 8
31444: NOT
31445: IFFALSE 31449
// continue ;
31447: GO 31212
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31449: LD_VAR 0 3
31453: PPUSH
31454: LD_VAR 0 8
31458: PPUSH
31459: LD_VAR 0 3
31463: PPUSH
31464: CALL_OW 74
31468: PPUSH
31469: CALL_OW 296
31473: PUSH
31474: LD_INT 6
31476: LESS
31477: IFFALSE 31493
// SetFuel ( j , 100 ) else
31479: LD_VAR 0 3
31483: PPUSH
31484: LD_INT 100
31486: PPUSH
31487: CALL_OW 240
31491: GO 31718
// if GetFuel ( j ) = 0 then
31493: LD_VAR 0 3
31497: PPUSH
31498: CALL_OW 261
31502: PUSH
31503: LD_INT 0
31505: EQUAL
31506: IFFALSE 31718
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31508: LD_ADDR_EXP 68
31512: PUSH
31513: LD_EXP 68
31517: PPUSH
31518: LD_VAR 0 2
31522: PPUSH
31523: LD_EXP 68
31527: PUSH
31528: LD_VAR 0 2
31532: ARRAY
31533: PUSH
31534: LD_VAR 0 3
31538: DIFF
31539: PPUSH
31540: CALL_OW 1
31544: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31545: LD_VAR 0 3
31549: PPUSH
31550: CALL_OW 263
31554: PUSH
31555: LD_INT 1
31557: EQUAL
31558: IFFALSE 31574
// ComExitVehicle ( IsInUnit ( j ) ) ;
31560: LD_VAR 0 3
31564: PPUSH
31565: CALL_OW 310
31569: PPUSH
31570: CALL_OW 121
// if GetControl ( j ) = control_remote then
31574: LD_VAR 0 3
31578: PPUSH
31579: CALL_OW 263
31583: PUSH
31584: LD_INT 2
31586: EQUAL
31587: IFFALSE 31598
// ComUnlink ( j ) ;
31589: LD_VAR 0 3
31593: PPUSH
31594: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31598: LD_ADDR_VAR 0 9
31602: PUSH
31603: LD_VAR 0 2
31607: PPUSH
31608: LD_INT 3
31610: PPUSH
31611: CALL 41071 0 2
31615: ST_TO_ADDR
// if fac then
31616: LD_VAR 0 9
31620: IFFALSE 31716
// begin for k in fac do
31622: LD_ADDR_VAR 0 4
31626: PUSH
31627: LD_VAR 0 9
31631: PUSH
31632: FOR_IN
31633: IFFALSE 31714
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31635: LD_ADDR_VAR 0 10
31639: PUSH
31640: LD_VAR 0 9
31644: PPUSH
31645: LD_VAR 0 3
31649: PPUSH
31650: CALL_OW 265
31654: PPUSH
31655: LD_VAR 0 3
31659: PPUSH
31660: CALL_OW 262
31664: PPUSH
31665: LD_VAR 0 3
31669: PPUSH
31670: CALL_OW 263
31674: PPUSH
31675: LD_VAR 0 3
31679: PPUSH
31680: CALL_OW 264
31684: PPUSH
31685: CALL 51640 0 5
31689: ST_TO_ADDR
// if components then
31690: LD_VAR 0 10
31694: IFFALSE 31712
// begin MC_InsertProduceList ( i , components ) ;
31696: LD_VAR 0 2
31700: PPUSH
31701: LD_VAR 0 10
31705: PPUSH
31706: CALL 40616 0 2
// break ;
31710: GO 31714
// end ; end ;
31712: GO 31632
31714: POP
31715: POP
// end ; continue ;
31716: GO 31212
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
31718: LD_VAR 0 3
31722: PPUSH
31723: LD_INT 1
31725: PPUSH
31726: CALL_OW 289
31730: PUSH
31731: LD_INT 100
31733: LESS
31734: PUSH
31735: LD_VAR 0 3
31739: PPUSH
31740: CALL_OW 314
31744: NOT
31745: AND
31746: IFFALSE 31775
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31748: LD_VAR 0 3
31752: PPUSH
31753: LD_VAR 0 6
31757: PUSH
31758: LD_INT 2
31760: ARRAY
31761: PPUSH
31762: LD_VAR 0 6
31766: PUSH
31767: LD_INT 3
31769: ARRAY
31770: PPUSH
31771: CALL_OW 117
// break ;
31775: GO 31779
// end ;
31777: GO 31212
31779: POP
31780: POP
// end ; end ;
31781: GO 30050
31783: POP
31784: POP
// end ;
31785: LD_VAR 0 1
31789: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
31790: LD_INT 0
31792: PPUSH
31793: PPUSH
31794: PPUSH
31795: PPUSH
// if not mc_bases then
31796: LD_EXP 49
31800: NOT
31801: IFFALSE 31805
// exit ;
31803: GO 31966
// for i = 1 to mc_bases do
31805: LD_ADDR_VAR 0 2
31809: PUSH
31810: DOUBLE
31811: LD_INT 1
31813: DEC
31814: ST_TO_ADDR
31815: LD_EXP 49
31819: PUSH
31820: FOR_TO
31821: IFFALSE 31964
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
31823: LD_ADDR_VAR 0 4
31827: PUSH
31828: LD_EXP 68
31832: PUSH
31833: LD_VAR 0 2
31837: ARRAY
31838: PUSH
31839: LD_EXP 71
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: UNION
31850: PPUSH
31851: LD_INT 33
31853: PUSH
31854: LD_INT 2
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PPUSH
31861: CALL_OW 72
31865: ST_TO_ADDR
// if tmp then
31866: LD_VAR 0 4
31870: IFFALSE 31962
// for j in tmp do
31872: LD_ADDR_VAR 0 3
31876: PUSH
31877: LD_VAR 0 4
31881: PUSH
31882: FOR_IN
31883: IFFALSE 31960
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
31885: LD_VAR 0 3
31889: PPUSH
31890: CALL_OW 312
31894: NOT
31895: PUSH
31896: LD_VAR 0 3
31900: PPUSH
31901: CALL_OW 256
31905: PUSH
31906: LD_INT 250
31908: GREATEREQUAL
31909: AND
31910: IFFALSE 31923
// Connect ( j ) else
31912: LD_VAR 0 3
31916: PPUSH
31917: CALL 57041 0 1
31921: GO 31958
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
31923: LD_VAR 0 3
31927: PPUSH
31928: CALL_OW 256
31932: PUSH
31933: LD_INT 250
31935: LESS
31936: PUSH
31937: LD_VAR 0 3
31941: PPUSH
31942: CALL_OW 312
31946: AND
31947: IFFALSE 31958
// ComUnlink ( j ) ;
31949: LD_VAR 0 3
31953: PPUSH
31954: CALL_OW 136
31958: GO 31882
31960: POP
31961: POP
// end ;
31962: GO 31820
31964: POP
31965: POP
// end ;
31966: LD_VAR 0 1
31970: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
31971: LD_INT 0
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
31977: PPUSH
// if not mc_bases then
31978: LD_EXP 49
31982: NOT
31983: IFFALSE 31987
// exit ;
31985: GO 32432
// for i = 1 to mc_bases do
31987: LD_ADDR_VAR 0 2
31991: PUSH
31992: DOUBLE
31993: LD_INT 1
31995: DEC
31996: ST_TO_ADDR
31997: LD_EXP 49
32001: PUSH
32002: FOR_TO
32003: IFFALSE 32430
// begin if not mc_produce [ i ] then
32005: LD_EXP 70
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: NOT
32016: IFFALSE 32020
// continue ;
32018: GO 32002
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32020: LD_ADDR_VAR 0 5
32024: PUSH
32025: LD_EXP 49
32029: PUSH
32030: LD_VAR 0 2
32034: ARRAY
32035: PPUSH
32036: LD_INT 30
32038: PUSH
32039: LD_INT 3
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 72
32050: ST_TO_ADDR
// if not fac then
32051: LD_VAR 0 5
32055: NOT
32056: IFFALSE 32060
// continue ;
32058: GO 32002
// for j in fac do
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_VAR 0 5
32069: PUSH
32070: FOR_IN
32071: IFFALSE 32426
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32073: LD_VAR 0 3
32077: PPUSH
32078: CALL_OW 461
32082: PUSH
32083: LD_INT 2
32085: NONEQUAL
32086: PUSH
32087: LD_VAR 0 3
32091: PPUSH
32092: LD_INT 15
32094: PPUSH
32095: CALL 56701 0 2
32099: PUSH
32100: LD_INT 4
32102: ARRAY
32103: OR
32104: IFFALSE 32108
// continue ;
32106: GO 32070
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32108: LD_VAR 0 3
32112: PPUSH
32113: LD_EXP 70
32117: PUSH
32118: LD_VAR 0 2
32122: ARRAY
32123: PUSH
32124: LD_INT 1
32126: ARRAY
32127: PUSH
32128: LD_INT 1
32130: ARRAY
32131: PPUSH
32132: LD_EXP 70
32136: PUSH
32137: LD_VAR 0 2
32141: ARRAY
32142: PUSH
32143: LD_INT 1
32145: ARRAY
32146: PUSH
32147: LD_INT 2
32149: ARRAY
32150: PPUSH
32151: LD_EXP 70
32155: PUSH
32156: LD_VAR 0 2
32160: ARRAY
32161: PUSH
32162: LD_INT 1
32164: ARRAY
32165: PUSH
32166: LD_INT 3
32168: ARRAY
32169: PPUSH
32170: LD_EXP 70
32174: PUSH
32175: LD_VAR 0 2
32179: ARRAY
32180: PUSH
32181: LD_INT 1
32183: ARRAY
32184: PUSH
32185: LD_INT 4
32187: ARRAY
32188: PPUSH
32189: CALL_OW 448
32193: PUSH
32194: LD_VAR 0 3
32198: PPUSH
32199: LD_EXP 70
32203: PUSH
32204: LD_VAR 0 2
32208: ARRAY
32209: PUSH
32210: LD_INT 1
32212: ARRAY
32213: PUSH
32214: LD_INT 1
32216: ARRAY
32217: PUSH
32218: LD_EXP 70
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_INT 1
32231: ARRAY
32232: PUSH
32233: LD_INT 2
32235: ARRAY
32236: PUSH
32237: LD_EXP 70
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: LD_INT 1
32250: ARRAY
32251: PUSH
32252: LD_INT 3
32254: ARRAY
32255: PUSH
32256: LD_EXP 70
32260: PUSH
32261: LD_VAR 0 2
32265: ARRAY
32266: PUSH
32267: LD_INT 1
32269: ARRAY
32270: PUSH
32271: LD_INT 4
32273: ARRAY
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: PPUSH
32281: CALL 60372 0 2
32285: AND
32286: IFFALSE 32424
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32288: LD_VAR 0 3
32292: PPUSH
32293: LD_EXP 70
32297: PUSH
32298: LD_VAR 0 2
32302: ARRAY
32303: PUSH
32304: LD_INT 1
32306: ARRAY
32307: PUSH
32308: LD_INT 1
32310: ARRAY
32311: PPUSH
32312: LD_EXP 70
32316: PUSH
32317: LD_VAR 0 2
32321: ARRAY
32322: PUSH
32323: LD_INT 1
32325: ARRAY
32326: PUSH
32327: LD_INT 2
32329: ARRAY
32330: PPUSH
32331: LD_EXP 70
32335: PUSH
32336: LD_VAR 0 2
32340: ARRAY
32341: PUSH
32342: LD_INT 1
32344: ARRAY
32345: PUSH
32346: LD_INT 3
32348: ARRAY
32349: PPUSH
32350: LD_EXP 70
32354: PUSH
32355: LD_VAR 0 2
32359: ARRAY
32360: PUSH
32361: LD_INT 1
32363: ARRAY
32364: PUSH
32365: LD_INT 4
32367: ARRAY
32368: PPUSH
32369: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32373: LD_ADDR_VAR 0 4
32377: PUSH
32378: LD_EXP 70
32382: PUSH
32383: LD_VAR 0 2
32387: ARRAY
32388: PPUSH
32389: LD_INT 1
32391: PPUSH
32392: CALL_OW 3
32396: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32397: LD_ADDR_EXP 70
32401: PUSH
32402: LD_EXP 70
32406: PPUSH
32407: LD_VAR 0 2
32411: PPUSH
32412: LD_VAR 0 4
32416: PPUSH
32417: CALL_OW 1
32421: ST_TO_ADDR
// break ;
32422: GO 32426
// end ; end ;
32424: GO 32070
32426: POP
32427: POP
// end ;
32428: GO 32002
32430: POP
32431: POP
// end ;
32432: LD_VAR 0 1
32436: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32437: LD_INT 0
32439: PPUSH
32440: PPUSH
32441: PPUSH
// if not mc_bases then
32442: LD_EXP 49
32446: NOT
32447: IFFALSE 32451
// exit ;
32449: GO 32540
// for i = 1 to mc_bases do
32451: LD_ADDR_VAR 0 2
32455: PUSH
32456: DOUBLE
32457: LD_INT 1
32459: DEC
32460: ST_TO_ADDR
32461: LD_EXP 49
32465: PUSH
32466: FOR_TO
32467: IFFALSE 32538
// begin if mc_attack [ i ] then
32469: LD_EXP 69
32473: PUSH
32474: LD_VAR 0 2
32478: ARRAY
32479: IFFALSE 32536
// begin tmp := mc_attack [ i ] [ 1 ] ;
32481: LD_ADDR_VAR 0 3
32485: PUSH
32486: LD_EXP 69
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: PUSH
32497: LD_INT 1
32499: ARRAY
32500: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32501: LD_ADDR_EXP 69
32505: PUSH
32506: LD_EXP 69
32510: PPUSH
32511: LD_VAR 0 2
32515: PPUSH
32516: EMPTY
32517: PPUSH
32518: CALL_OW 1
32522: ST_TO_ADDR
// Attack ( tmp ) ;
32523: LD_VAR 0 3
32527: PPUSH
32528: CALL 82585 0 1
// exit ;
32532: POP
32533: POP
32534: GO 32540
// end ; end ;
32536: GO 32466
32538: POP
32539: POP
// end ;
32540: LD_VAR 0 1
32544: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32545: LD_INT 0
32547: PPUSH
32548: PPUSH
32549: PPUSH
32550: PPUSH
32551: PPUSH
32552: PPUSH
32553: PPUSH
// if not mc_bases then
32554: LD_EXP 49
32558: NOT
32559: IFFALSE 32563
// exit ;
32561: GO 33145
// for i = 1 to mc_bases do
32563: LD_ADDR_VAR 0 2
32567: PUSH
32568: DOUBLE
32569: LD_INT 1
32571: DEC
32572: ST_TO_ADDR
32573: LD_EXP 49
32577: PUSH
32578: FOR_TO
32579: IFFALSE 33143
// begin if not mc_bases [ i ] then
32581: LD_EXP 49
32585: PUSH
32586: LD_VAR 0 2
32590: ARRAY
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 32578
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32596: LD_ADDR_VAR 0 7
32600: PUSH
32601: LD_EXP 49
32605: PUSH
32606: LD_VAR 0 2
32610: ARRAY
32611: PUSH
32612: LD_INT 1
32614: ARRAY
32615: PPUSH
32616: CALL 50944 0 1
32620: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32621: LD_ADDR_EXP 72
32625: PUSH
32626: LD_EXP 72
32630: PPUSH
32631: LD_VAR 0 2
32635: PPUSH
32636: LD_EXP 49
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: ARRAY
32650: PPUSH
32651: CALL_OW 255
32655: PPUSH
32656: LD_EXP 74
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: PPUSH
32667: CALL 48587 0 2
32671: PPUSH
32672: CALL_OW 1
32676: ST_TO_ADDR
// if not mc_scan [ i ] then
32677: LD_EXP 72
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: NOT
32688: IFFALSE 32843
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32690: LD_ADDR_VAR 0 4
32694: PUSH
32695: LD_EXP 49
32699: PUSH
32700: LD_VAR 0 2
32704: ARRAY
32705: PPUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 25
32711: PUSH
32712: LD_INT 5
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 25
32721: PUSH
32722: LD_INT 8
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 25
32731: PUSH
32732: LD_INT 9
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: PPUSH
32745: CALL_OW 72
32749: ST_TO_ADDR
// if not tmp then
32750: LD_VAR 0 4
32754: NOT
32755: IFFALSE 32759
// continue ;
32757: GO 32578
// for j in tmp do
32759: LD_ADDR_VAR 0 3
32763: PUSH
32764: LD_VAR 0 4
32768: PUSH
32769: FOR_IN
32770: IFFALSE 32841
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
32772: LD_VAR 0 3
32776: PPUSH
32777: CALL_OW 310
32781: PPUSH
32782: CALL_OW 266
32786: PUSH
32787: LD_INT 5
32789: EQUAL
32790: PUSH
32791: LD_VAR 0 3
32795: PPUSH
32796: CALL_OW 257
32800: PUSH
32801: LD_INT 1
32803: EQUAL
32804: AND
32805: PUSH
32806: LD_VAR 0 3
32810: PPUSH
32811: CALL_OW 459
32815: NOT
32816: AND
32817: PUSH
32818: LD_VAR 0 7
32822: AND
32823: IFFALSE 32839
// ComChangeProfession ( j , class ) ;
32825: LD_VAR 0 3
32829: PPUSH
32830: LD_VAR 0 7
32834: PPUSH
32835: CALL_OW 123
32839: GO 32769
32841: POP
32842: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
32843: LD_EXP 72
32847: PUSH
32848: LD_VAR 0 2
32852: ARRAY
32853: PUSH
32854: LD_EXP 71
32858: PUSH
32859: LD_VAR 0 2
32863: ARRAY
32864: NOT
32865: AND
32866: PUSH
32867: LD_EXP 49
32871: PUSH
32872: LD_VAR 0 2
32876: ARRAY
32877: PPUSH
32878: LD_INT 30
32880: PUSH
32881: LD_INT 32
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PPUSH
32888: CALL_OW 72
32892: NOT
32893: AND
32894: PUSH
32895: LD_EXP 49
32899: PUSH
32900: LD_VAR 0 2
32904: ARRAY
32905: PPUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 30
32911: PUSH
32912: LD_INT 4
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 30
32921: PUSH
32922: LD_INT 5
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: LIST
32933: PPUSH
32934: CALL_OW 72
32938: NOT
32939: AND
32940: IFFALSE 33072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32942: LD_ADDR_VAR 0 4
32946: PUSH
32947: LD_EXP 49
32951: PUSH
32952: LD_VAR 0 2
32956: ARRAY
32957: PPUSH
32958: LD_INT 2
32960: PUSH
32961: LD_INT 25
32963: PUSH
32964: LD_INT 1
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 25
32973: PUSH
32974: LD_INT 5
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 25
32983: PUSH
32984: LD_INT 8
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 25
32993: PUSH
32994: LD_INT 9
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: PPUSH
33008: CALL_OW 72
33012: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33013: LD_ADDR_VAR 0 4
33017: PUSH
33018: LD_VAR 0 4
33022: PUSH
33023: LD_VAR 0 4
33027: PPUSH
33028: LD_INT 18
33030: PPUSH
33031: CALL 87368 0 2
33035: DIFF
33036: ST_TO_ADDR
// if tmp then
33037: LD_VAR 0 4
33041: IFFALSE 33072
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33043: LD_VAR 0 2
33047: PPUSH
33048: LD_VAR 0 4
33052: PPUSH
33053: LD_EXP 74
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PPUSH
33064: CALL 48622 0 3
// exit ;
33068: POP
33069: POP
33070: GO 33145
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33072: LD_EXP 72
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PUSH
33083: LD_EXP 71
33087: PUSH
33088: LD_VAR 0 2
33092: ARRAY
33093: AND
33094: IFFALSE 33141
// begin tmp := mc_defender [ i ] ;
33096: LD_ADDR_VAR 0 4
33100: PUSH
33101: LD_EXP 71
33105: PUSH
33106: LD_VAR 0 2
33110: ARRAY
33111: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33112: LD_VAR 0 2
33116: PPUSH
33117: LD_VAR 0 4
33121: PPUSH
33122: LD_EXP 72
33126: PUSH
33127: LD_VAR 0 2
33131: ARRAY
33132: PPUSH
33133: CALL 49183 0 3
// exit ;
33137: POP
33138: POP
33139: GO 33145
// end ; end ;
33141: GO 32578
33143: POP
33144: POP
// end ;
33145: LD_VAR 0 1
33149: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33150: LD_INT 0
33152: PPUSH
33153: PPUSH
33154: PPUSH
33155: PPUSH
33156: PPUSH
33157: PPUSH
33158: PPUSH
33159: PPUSH
33160: PPUSH
33161: PPUSH
33162: PPUSH
// if not mc_bases then
33163: LD_EXP 49
33167: NOT
33168: IFFALSE 33172
// exit ;
33170: GO 34259
// for i = 1 to mc_bases do
33172: LD_ADDR_VAR 0 2
33176: PUSH
33177: DOUBLE
33178: LD_INT 1
33180: DEC
33181: ST_TO_ADDR
33182: LD_EXP 49
33186: PUSH
33187: FOR_TO
33188: IFFALSE 34257
// begin tmp := mc_lab [ i ] ;
33190: LD_ADDR_VAR 0 6
33194: PUSH
33195: LD_EXP 82
33199: PUSH
33200: LD_VAR 0 2
33204: ARRAY
33205: ST_TO_ADDR
// if not tmp then
33206: LD_VAR 0 6
33210: NOT
33211: IFFALSE 33215
// continue ;
33213: GO 33187
// idle_lab := 0 ;
33215: LD_ADDR_VAR 0 11
33219: PUSH
33220: LD_INT 0
33222: ST_TO_ADDR
// for j in tmp do
33223: LD_ADDR_VAR 0 3
33227: PUSH
33228: LD_VAR 0 6
33232: PUSH
33233: FOR_IN
33234: IFFALSE 34253
// begin researching := false ;
33236: LD_ADDR_VAR 0 10
33240: PUSH
33241: LD_INT 0
33243: ST_TO_ADDR
// side := GetSide ( j ) ;
33244: LD_ADDR_VAR 0 4
33248: PUSH
33249: LD_VAR 0 3
33253: PPUSH
33254: CALL_OW 255
33258: ST_TO_ADDR
// if not mc_tech [ side ] then
33259: LD_EXP 76
33263: PUSH
33264: LD_VAR 0 4
33268: ARRAY
33269: NOT
33270: IFFALSE 33274
// continue ;
33272: GO 33233
// if BuildingStatus ( j ) = bs_idle then
33274: LD_VAR 0 3
33278: PPUSH
33279: CALL_OW 461
33283: PUSH
33284: LD_INT 2
33286: EQUAL
33287: IFFALSE 33475
// begin if idle_lab and UnitsInside ( j ) < 6 then
33289: LD_VAR 0 11
33293: PUSH
33294: LD_VAR 0 3
33298: PPUSH
33299: CALL_OW 313
33303: PUSH
33304: LD_INT 6
33306: LESS
33307: AND
33308: IFFALSE 33379
// begin tmp2 := UnitsInside ( idle_lab ) ;
33310: LD_ADDR_VAR 0 9
33314: PUSH
33315: LD_VAR 0 11
33319: PPUSH
33320: CALL_OW 313
33324: ST_TO_ADDR
// if tmp2 then
33325: LD_VAR 0 9
33329: IFFALSE 33371
// for x in tmp2 do
33331: LD_ADDR_VAR 0 7
33335: PUSH
33336: LD_VAR 0 9
33340: PUSH
33341: FOR_IN
33342: IFFALSE 33369
// begin ComExitBuilding ( x ) ;
33344: LD_VAR 0 7
33348: PPUSH
33349: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33353: LD_VAR 0 7
33357: PPUSH
33358: LD_VAR 0 3
33362: PPUSH
33363: CALL_OW 180
// end ;
33367: GO 33341
33369: POP
33370: POP
// idle_lab := 0 ;
33371: LD_ADDR_VAR 0 11
33375: PUSH
33376: LD_INT 0
33378: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33379: LD_ADDR_VAR 0 5
33383: PUSH
33384: LD_EXP 76
33388: PUSH
33389: LD_VAR 0 4
33393: ARRAY
33394: PUSH
33395: FOR_IN
33396: IFFALSE 33456
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33398: LD_VAR 0 3
33402: PPUSH
33403: LD_VAR 0 5
33407: PPUSH
33408: CALL_OW 430
33412: PUSH
33413: LD_VAR 0 4
33417: PPUSH
33418: LD_VAR 0 5
33422: PPUSH
33423: CALL 47692 0 2
33427: AND
33428: IFFALSE 33454
// begin researching := true ;
33430: LD_ADDR_VAR 0 10
33434: PUSH
33435: LD_INT 1
33437: ST_TO_ADDR
// ComResearch ( j , t ) ;
33438: LD_VAR 0 3
33442: PPUSH
33443: LD_VAR 0 5
33447: PPUSH
33448: CALL_OW 124
// break ;
33452: GO 33456
// end ;
33454: GO 33395
33456: POP
33457: POP
// if not researching then
33458: LD_VAR 0 10
33462: NOT
33463: IFFALSE 33475
// idle_lab := j ;
33465: LD_ADDR_VAR 0 11
33469: PUSH
33470: LD_VAR 0 3
33474: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33475: LD_VAR 0 3
33479: PPUSH
33480: CALL_OW 461
33484: PUSH
33485: LD_INT 10
33487: EQUAL
33488: IFFALSE 34076
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33490: LD_EXP 78
33494: PUSH
33495: LD_VAR 0 2
33499: ARRAY
33500: NOT
33501: PUSH
33502: LD_EXP 79
33506: PUSH
33507: LD_VAR 0 2
33511: ARRAY
33512: NOT
33513: AND
33514: PUSH
33515: LD_EXP 76
33519: PUSH
33520: LD_VAR 0 4
33524: ARRAY
33525: PUSH
33526: LD_INT 1
33528: GREATER
33529: AND
33530: IFFALSE 33661
// begin ComCancel ( j ) ;
33532: LD_VAR 0 3
33536: PPUSH
33537: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33541: LD_ADDR_EXP 76
33545: PUSH
33546: LD_EXP 76
33550: PPUSH
33551: LD_VAR 0 4
33555: PPUSH
33556: LD_EXP 76
33560: PUSH
33561: LD_VAR 0 4
33565: ARRAY
33566: PPUSH
33567: LD_EXP 76
33571: PUSH
33572: LD_VAR 0 4
33576: ARRAY
33577: PUSH
33578: LD_INT 1
33580: MINUS
33581: PPUSH
33582: LD_EXP 76
33586: PUSH
33587: LD_VAR 0 4
33591: ARRAY
33592: PPUSH
33593: LD_INT 0
33595: PPUSH
33596: CALL 53526 0 4
33600: PPUSH
33601: CALL_OW 1
33605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33606: LD_ADDR_EXP 76
33610: PUSH
33611: LD_EXP 76
33615: PPUSH
33616: LD_VAR 0 4
33620: PPUSH
33621: LD_EXP 76
33625: PUSH
33626: LD_VAR 0 4
33630: ARRAY
33631: PPUSH
33632: LD_EXP 76
33636: PUSH
33637: LD_VAR 0 4
33641: ARRAY
33642: PPUSH
33643: LD_INT 1
33645: PPUSH
33646: LD_INT 0
33648: PPUSH
33649: CALL 53526 0 4
33653: PPUSH
33654: CALL_OW 1
33658: ST_TO_ADDR
// continue ;
33659: GO 33233
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
33661: LD_EXP 78
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_EXP 79
33676: PUSH
33677: LD_VAR 0 2
33681: ARRAY
33682: NOT
33683: AND
33684: IFFALSE 33811
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
33686: LD_ADDR_EXP 79
33690: PUSH
33691: LD_EXP 79
33695: PPUSH
33696: LD_VAR 0 2
33700: PUSH
33701: LD_EXP 79
33705: PUSH
33706: LD_VAR 0 2
33710: ARRAY
33711: PUSH
33712: LD_INT 1
33714: PLUS
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PPUSH
33720: LD_EXP 78
33724: PUSH
33725: LD_VAR 0 2
33729: ARRAY
33730: PUSH
33731: LD_INT 1
33733: ARRAY
33734: PPUSH
33735: CALL 54108 0 3
33739: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
33740: LD_EXP 78
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: PUSH
33751: LD_INT 1
33753: ARRAY
33754: PPUSH
33755: LD_INT 112
33757: PPUSH
33758: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
33762: LD_ADDR_VAR 0 9
33766: PUSH
33767: LD_EXP 78
33771: PUSH
33772: LD_VAR 0 2
33776: ARRAY
33777: PPUSH
33778: LD_INT 1
33780: PPUSH
33781: CALL_OW 3
33785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
33786: LD_ADDR_EXP 78
33790: PUSH
33791: LD_EXP 78
33795: PPUSH
33796: LD_VAR 0 2
33800: PPUSH
33801: LD_VAR 0 9
33805: PPUSH
33806: CALL_OW 1
33810: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
33811: LD_EXP 78
33815: PUSH
33816: LD_VAR 0 2
33820: ARRAY
33821: PUSH
33822: LD_EXP 79
33826: PUSH
33827: LD_VAR 0 2
33831: ARRAY
33832: AND
33833: PUSH
33834: LD_EXP 79
33838: PUSH
33839: LD_VAR 0 2
33843: ARRAY
33844: PUSH
33845: LD_INT 1
33847: ARRAY
33848: PPUSH
33849: CALL_OW 310
33853: NOT
33854: AND
33855: PUSH
33856: LD_VAR 0 3
33860: PPUSH
33861: CALL_OW 313
33865: PUSH
33866: LD_INT 6
33868: EQUAL
33869: AND
33870: IFFALSE 33926
// begin tmp2 := UnitsInside ( j ) ;
33872: LD_ADDR_VAR 0 9
33876: PUSH
33877: LD_VAR 0 3
33881: PPUSH
33882: CALL_OW 313
33886: ST_TO_ADDR
// if tmp2 = 6 then
33887: LD_VAR 0 9
33891: PUSH
33892: LD_INT 6
33894: EQUAL
33895: IFFALSE 33926
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
33897: LD_VAR 0 9
33901: PUSH
33902: LD_INT 1
33904: ARRAY
33905: PPUSH
33906: LD_INT 112
33908: PPUSH
33909: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
33913: LD_VAR 0 9
33917: PUSH
33918: LD_INT 1
33920: ARRAY
33921: PPUSH
33922: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
33926: LD_EXP 79
33930: PUSH
33931: LD_VAR 0 2
33935: ARRAY
33936: PUSH
33937: LD_EXP 79
33941: PUSH
33942: LD_VAR 0 2
33946: ARRAY
33947: PUSH
33948: LD_INT 1
33950: ARRAY
33951: PPUSH
33952: CALL_OW 314
33956: NOT
33957: AND
33958: PUSH
33959: LD_EXP 79
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: PUSH
33970: LD_INT 1
33972: ARRAY
33973: PPUSH
33974: CALL_OW 310
33978: NOT
33979: AND
33980: IFFALSE 34006
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
33982: LD_EXP 79
33986: PUSH
33987: LD_VAR 0 2
33991: ARRAY
33992: PUSH
33993: LD_INT 1
33995: ARRAY
33996: PPUSH
33997: LD_VAR 0 3
34001: PPUSH
34002: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34006: LD_EXP 79
34010: PUSH
34011: LD_VAR 0 2
34015: ARRAY
34016: PUSH
34017: LD_INT 1
34019: ARRAY
34020: PPUSH
34021: CALL_OW 310
34025: PUSH
34026: LD_EXP 79
34030: PUSH
34031: LD_VAR 0 2
34035: ARRAY
34036: PUSH
34037: LD_INT 1
34039: ARRAY
34040: PPUSH
34041: CALL_OW 310
34045: PPUSH
34046: CALL_OW 461
34050: PUSH
34051: LD_INT 3
34053: NONEQUAL
34054: AND
34055: IFFALSE 34076
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34057: LD_EXP 79
34061: PUSH
34062: LD_VAR 0 2
34066: ARRAY
34067: PUSH
34068: LD_INT 1
34070: ARRAY
34071: PPUSH
34072: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 461
34085: PUSH
34086: LD_INT 6
34088: EQUAL
34089: PUSH
34090: LD_VAR 0 6
34094: PUSH
34095: LD_INT 1
34097: GREATER
34098: AND
34099: IFFALSE 34251
// begin sci := [ ] ;
34101: LD_ADDR_VAR 0 8
34105: PUSH
34106: EMPTY
34107: ST_TO_ADDR
// for x in ( tmp diff j ) do
34108: LD_ADDR_VAR 0 7
34112: PUSH
34113: LD_VAR 0 6
34117: PUSH
34118: LD_VAR 0 3
34122: DIFF
34123: PUSH
34124: FOR_IN
34125: IFFALSE 34177
// begin if sci = 6 then
34127: LD_VAR 0 8
34131: PUSH
34132: LD_INT 6
34134: EQUAL
34135: IFFALSE 34139
// break ;
34137: GO 34177
// if BuildingStatus ( x ) = bs_idle then
34139: LD_VAR 0 7
34143: PPUSH
34144: CALL_OW 461
34148: PUSH
34149: LD_INT 2
34151: EQUAL
34152: IFFALSE 34175
// sci := sci ^ UnitsInside ( x ) ;
34154: LD_ADDR_VAR 0 8
34158: PUSH
34159: LD_VAR 0 8
34163: PUSH
34164: LD_VAR 0 7
34168: PPUSH
34169: CALL_OW 313
34173: ADD
34174: ST_TO_ADDR
// end ;
34175: GO 34124
34177: POP
34178: POP
// if not sci then
34179: LD_VAR 0 8
34183: NOT
34184: IFFALSE 34188
// continue ;
34186: GO 33233
// for x in sci do
34188: LD_ADDR_VAR 0 7
34192: PUSH
34193: LD_VAR 0 8
34197: PUSH
34198: FOR_IN
34199: IFFALSE 34249
// if IsInUnit ( x ) and not HasTask ( x ) then
34201: LD_VAR 0 7
34205: PPUSH
34206: CALL_OW 310
34210: PUSH
34211: LD_VAR 0 7
34215: PPUSH
34216: CALL_OW 314
34220: NOT
34221: AND
34222: IFFALSE 34247
// begin ComExitBuilding ( x ) ;
34224: LD_VAR 0 7
34228: PPUSH
34229: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34233: LD_VAR 0 7
34237: PPUSH
34238: LD_VAR 0 3
34242: PPUSH
34243: CALL_OW 180
// end ;
34247: GO 34198
34249: POP
34250: POP
// end ; end ;
34251: GO 33233
34253: POP
34254: POP
// end ;
34255: GO 33187
34257: POP
34258: POP
// end ;
34259: LD_VAR 0 1
34263: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34264: LD_INT 0
34266: PPUSH
34267: PPUSH
// if not mc_bases then
34268: LD_EXP 49
34272: NOT
34273: IFFALSE 34277
// exit ;
34275: GO 34358
// for i = 1 to mc_bases do
34277: LD_ADDR_VAR 0 2
34281: PUSH
34282: DOUBLE
34283: LD_INT 1
34285: DEC
34286: ST_TO_ADDR
34287: LD_EXP 49
34291: PUSH
34292: FOR_TO
34293: IFFALSE 34356
// if mc_mines [ i ] and mc_miners [ i ] then
34295: LD_EXP 62
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_EXP 63
34310: PUSH
34311: LD_VAR 0 2
34315: ARRAY
34316: AND
34317: IFFALSE 34354
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34319: LD_EXP 63
34323: PUSH
34324: LD_VAR 0 2
34328: ARRAY
34329: PUSH
34330: LD_INT 1
34332: ARRAY
34333: PPUSH
34334: CALL_OW 255
34338: PPUSH
34339: LD_EXP 62
34343: PUSH
34344: LD_VAR 0 2
34348: ARRAY
34349: PPUSH
34350: CALL 51097 0 2
34354: GO 34292
34356: POP
34357: POP
// end ;
34358: LD_VAR 0 1
34362: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34363: LD_INT 0
34365: PPUSH
34366: PPUSH
34367: PPUSH
34368: PPUSH
34369: PPUSH
34370: PPUSH
34371: PPUSH
34372: PPUSH
// if not mc_bases or not mc_parking then
34373: LD_EXP 49
34377: NOT
34378: PUSH
34379: LD_EXP 73
34383: NOT
34384: OR
34385: IFFALSE 34389
// exit ;
34387: GO 35088
// for i = 1 to mc_bases do
34389: LD_ADDR_VAR 0 2
34393: PUSH
34394: DOUBLE
34395: LD_INT 1
34397: DEC
34398: ST_TO_ADDR
34399: LD_EXP 49
34403: PUSH
34404: FOR_TO
34405: IFFALSE 35086
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34407: LD_EXP 49
34411: PUSH
34412: LD_VAR 0 2
34416: ARRAY
34417: NOT
34418: PUSH
34419: LD_EXP 73
34423: PUSH
34424: LD_VAR 0 2
34428: ARRAY
34429: NOT
34430: OR
34431: IFFALSE 34435
// continue ;
34433: GO 34404
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34435: LD_ADDR_VAR 0 5
34439: PUSH
34440: LD_EXP 49
34444: PUSH
34445: LD_VAR 0 2
34449: ARRAY
34450: PUSH
34451: LD_INT 1
34453: ARRAY
34454: PPUSH
34455: CALL_OW 255
34459: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34460: LD_ADDR_VAR 0 6
34464: PUSH
34465: LD_EXP 49
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: PPUSH
34476: LD_INT 30
34478: PUSH
34479: LD_INT 3
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PPUSH
34486: CALL_OW 72
34490: ST_TO_ADDR
// if not fac then
34491: LD_VAR 0 6
34495: NOT
34496: IFFALSE 34547
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34498: LD_ADDR_VAR 0 6
34502: PUSH
34503: LD_EXP 49
34507: PUSH
34508: LD_VAR 0 2
34512: ARRAY
34513: PPUSH
34514: LD_INT 2
34516: PUSH
34517: LD_INT 30
34519: PUSH
34520: LD_INT 0
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 30
34529: PUSH
34530: LD_INT 1
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: LIST
34541: PPUSH
34542: CALL_OW 72
34546: ST_TO_ADDR
// if not fac then
34547: LD_VAR 0 6
34551: NOT
34552: IFFALSE 34556
// continue ;
34554: GO 34404
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34556: LD_ADDR_VAR 0 7
34560: PUSH
34561: LD_EXP 73
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 22
34574: PUSH
34575: LD_VAR 0 5
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 21
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 3
34596: PUSH
34597: LD_INT 24
34599: PUSH
34600: LD_INT 1000
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: LIST
34615: PPUSH
34616: CALL_OW 70
34620: ST_TO_ADDR
// for j in fac do
34621: LD_ADDR_VAR 0 3
34625: PUSH
34626: LD_VAR 0 6
34630: PUSH
34631: FOR_IN
34632: IFFALSE 34713
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34634: LD_ADDR_VAR 0 7
34638: PUSH
34639: LD_VAR 0 7
34643: PUSH
34644: LD_INT 22
34646: PUSH
34647: LD_VAR 0 5
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 91
34658: PUSH
34659: LD_VAR 0 3
34663: PUSH
34664: LD_INT 15
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 21
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 3
34684: PUSH
34685: LD_INT 24
34687: PUSH
34688: LD_INT 1000
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: PPUSH
34705: CALL_OW 69
34709: UNION
34710: ST_TO_ADDR
34711: GO 34631
34713: POP
34714: POP
// if not vehs then
34715: LD_VAR 0 7
34719: NOT
34720: IFFALSE 34746
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
34722: LD_ADDR_EXP 61
34726: PUSH
34727: LD_EXP 61
34731: PPUSH
34732: LD_VAR 0 2
34736: PPUSH
34737: EMPTY
34738: PPUSH
34739: CALL_OW 1
34743: ST_TO_ADDR
// continue ;
34744: GO 34404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34746: LD_ADDR_VAR 0 8
34750: PUSH
34751: LD_EXP 49
34755: PUSH
34756: LD_VAR 0 2
34760: ARRAY
34761: PPUSH
34762: LD_INT 30
34764: PUSH
34765: LD_INT 3
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PPUSH
34772: CALL_OW 72
34776: ST_TO_ADDR
// if tmp then
34777: LD_VAR 0 8
34781: IFFALSE 34884
// begin for j in tmp do
34783: LD_ADDR_VAR 0 3
34787: PUSH
34788: LD_VAR 0 8
34792: PUSH
34793: FOR_IN
34794: IFFALSE 34882
// for k in UnitsInside ( j ) do
34796: LD_ADDR_VAR 0 4
34800: PUSH
34801: LD_VAR 0 3
34805: PPUSH
34806: CALL_OW 313
34810: PUSH
34811: FOR_IN
34812: IFFALSE 34878
// if k then
34814: LD_VAR 0 4
34818: IFFALSE 34876
// if not k in mc_repair_vehicle [ i ] then
34820: LD_VAR 0 4
34824: PUSH
34825: LD_EXP 61
34829: PUSH
34830: LD_VAR 0 2
34834: ARRAY
34835: IN
34836: NOT
34837: IFFALSE 34876
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
34839: LD_ADDR_EXP 61
34843: PUSH
34844: LD_EXP 61
34848: PPUSH
34849: LD_VAR 0 2
34853: PPUSH
34854: LD_EXP 61
34858: PUSH
34859: LD_VAR 0 2
34863: ARRAY
34864: PUSH
34865: LD_VAR 0 4
34869: UNION
34870: PPUSH
34871: CALL_OW 1
34875: ST_TO_ADDR
34876: GO 34811
34878: POP
34879: POP
34880: GO 34793
34882: POP
34883: POP
// end ; if not mc_repair_vehicle [ i ] then
34884: LD_EXP 61
34888: PUSH
34889: LD_VAR 0 2
34893: ARRAY
34894: NOT
34895: IFFALSE 34899
// continue ;
34897: GO 34404
// for j in mc_repair_vehicle [ i ] do
34899: LD_ADDR_VAR 0 3
34903: PUSH
34904: LD_EXP 61
34908: PUSH
34909: LD_VAR 0 2
34913: ARRAY
34914: PUSH
34915: FOR_IN
34916: IFFALSE 35082
// begin if GetClass ( j ) <> 3 then
34918: LD_VAR 0 3
34922: PPUSH
34923: CALL_OW 257
34927: PUSH
34928: LD_INT 3
34930: NONEQUAL
34931: IFFALSE 34972
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
34933: LD_ADDR_EXP 61
34937: PUSH
34938: LD_EXP 61
34942: PPUSH
34943: LD_VAR 0 2
34947: PPUSH
34948: LD_EXP 61
34952: PUSH
34953: LD_VAR 0 2
34957: ARRAY
34958: PUSH
34959: LD_VAR 0 3
34963: DIFF
34964: PPUSH
34965: CALL_OW 1
34969: ST_TO_ADDR
// continue ;
34970: GO 34915
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
34972: LD_VAR 0 3
34976: PPUSH
34977: CALL_OW 311
34981: NOT
34982: PUSH
34983: LD_VAR 0 3
34987: PUSH
34988: LD_EXP 52
34992: PUSH
34993: LD_VAR 0 2
34997: ARRAY
34998: PUSH
34999: LD_INT 1
35001: ARRAY
35002: IN
35003: NOT
35004: AND
35005: PUSH
35006: LD_VAR 0 3
35010: PUSH
35011: LD_EXP 52
35015: PUSH
35016: LD_VAR 0 2
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: IN
35026: NOT
35027: AND
35028: IFFALSE 35080
// begin if IsInUnit ( j ) then
35030: LD_VAR 0 3
35034: PPUSH
35035: CALL_OW 310
35039: IFFALSE 35050
// ComExitBuilding ( j ) ;
35041: LD_VAR 0 3
35045: PPUSH
35046: CALL_OW 122
// if not HasTask ( j ) then
35050: LD_VAR 0 3
35054: PPUSH
35055: CALL_OW 314
35059: NOT
35060: IFFALSE 35080
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35062: LD_VAR 0 3
35066: PPUSH
35067: LD_VAR 0 7
35071: PUSH
35072: LD_INT 1
35074: ARRAY
35075: PPUSH
35076: CALL_OW 189
// end ; end ;
35080: GO 34915
35082: POP
35083: POP
// end ;
35084: GO 34404
35086: POP
35087: POP
// end ;
35088: LD_VAR 0 1
35092: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35093: LD_INT 0
35095: PPUSH
35096: PPUSH
35097: PPUSH
35098: PPUSH
35099: PPUSH
35100: PPUSH
35101: PPUSH
35102: PPUSH
35103: PPUSH
35104: PPUSH
35105: PPUSH
// if not mc_bases then
35106: LD_EXP 49
35110: NOT
35111: IFFALSE 35115
// exit ;
35113: GO 35917
// for i = 1 to mc_bases do
35115: LD_ADDR_VAR 0 2
35119: PUSH
35120: DOUBLE
35121: LD_INT 1
35123: DEC
35124: ST_TO_ADDR
35125: LD_EXP 49
35129: PUSH
35130: FOR_TO
35131: IFFALSE 35915
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35133: LD_EXP 77
35137: PUSH
35138: LD_VAR 0 2
35142: ARRAY
35143: NOT
35144: PUSH
35145: LD_EXP 52
35149: PUSH
35150: LD_VAR 0 2
35154: ARRAY
35155: PUSH
35156: LD_INT 1
35158: ARRAY
35159: OR
35160: PUSH
35161: LD_EXP 52
35165: PUSH
35166: LD_VAR 0 2
35170: ARRAY
35171: PUSH
35172: LD_INT 2
35174: ARRAY
35175: OR
35176: PUSH
35177: LD_EXP 75
35181: PUSH
35182: LD_VAR 0 2
35186: ARRAY
35187: PPUSH
35188: LD_INT 1
35190: PPUSH
35191: CALL_OW 325
35195: NOT
35196: OR
35197: PUSH
35198: LD_EXP 72
35202: PUSH
35203: LD_VAR 0 2
35207: ARRAY
35208: OR
35209: IFFALSE 35213
// continue ;
35211: GO 35130
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35213: LD_ADDR_VAR 0 8
35217: PUSH
35218: LD_EXP 49
35222: PUSH
35223: LD_VAR 0 2
35227: ARRAY
35228: PPUSH
35229: LD_INT 25
35231: PUSH
35232: LD_INT 4
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 50
35241: PUSH
35242: EMPTY
35243: LIST
35244: PUSH
35245: LD_INT 3
35247: PUSH
35248: LD_INT 60
35250: PUSH
35251: EMPTY
35252: LIST
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: LIST
35262: PPUSH
35263: CALL_OW 72
35267: PUSH
35268: LD_EXP 53
35272: PUSH
35273: LD_VAR 0 2
35277: ARRAY
35278: DIFF
35279: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35280: LD_ADDR_VAR 0 9
35284: PUSH
35285: LD_EXP 49
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: PPUSH
35296: LD_INT 2
35298: PUSH
35299: LD_INT 30
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 30
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: LIST
35323: PPUSH
35324: CALL_OW 72
35328: ST_TO_ADDR
// if not tmp or not dep then
35329: LD_VAR 0 8
35333: NOT
35334: PUSH
35335: LD_VAR 0 9
35339: NOT
35340: OR
35341: IFFALSE 35345
// continue ;
35343: GO 35130
// side := GetSide ( tmp [ 1 ] ) ;
35345: LD_ADDR_VAR 0 11
35349: PUSH
35350: LD_VAR 0 8
35354: PUSH
35355: LD_INT 1
35357: ARRAY
35358: PPUSH
35359: CALL_OW 255
35363: ST_TO_ADDR
// dep := dep [ 1 ] ;
35364: LD_ADDR_VAR 0 9
35368: PUSH
35369: LD_VAR 0 9
35373: PUSH
35374: LD_INT 1
35376: ARRAY
35377: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_EXP 77
35387: PUSH
35388: LD_VAR 0 2
35392: ARRAY
35393: PPUSH
35394: LD_INT 22
35396: PUSH
35397: LD_INT 0
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 25
35406: PUSH
35407: LD_INT 12
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PPUSH
35418: CALL_OW 70
35422: PUSH
35423: LD_INT 22
35425: PUSH
35426: LD_INT 0
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 25
35435: PUSH
35436: LD_INT 12
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 91
35445: PUSH
35446: LD_VAR 0 9
35450: PUSH
35451: LD_INT 20
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: LIST
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: LIST
35463: PPUSH
35464: CALL_OW 69
35468: UNION
35469: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35470: LD_ADDR_VAR 0 10
35474: PUSH
35475: LD_EXP 77
35479: PUSH
35480: LD_VAR 0 2
35484: ARRAY
35485: PPUSH
35486: LD_INT 81
35488: PUSH
35489: LD_VAR 0 11
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PPUSH
35498: CALL_OW 70
35502: ST_TO_ADDR
// if not apes or danger_at_area then
35503: LD_VAR 0 7
35507: NOT
35508: PUSH
35509: LD_VAR 0 10
35513: OR
35514: IFFALSE 35564
// begin if mc_taming [ i ] then
35516: LD_EXP 80
35520: PUSH
35521: LD_VAR 0 2
35525: ARRAY
35526: IFFALSE 35562
// begin MC_Reset ( i , 121 ) ;
35528: LD_VAR 0 2
35532: PPUSH
35533: LD_INT 121
35535: PPUSH
35536: CALL 20895 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35540: LD_ADDR_EXP 80
35544: PUSH
35545: LD_EXP 80
35549: PPUSH
35550: LD_VAR 0 2
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// end ; continue ;
35562: GO 35130
// end ; for j in tmp do
35564: LD_ADDR_VAR 0 3
35568: PUSH
35569: LD_VAR 0 8
35573: PUSH
35574: FOR_IN
35575: IFFALSE 35911
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35577: LD_VAR 0 3
35581: PUSH
35582: LD_EXP 80
35586: PUSH
35587: LD_VAR 0 2
35591: ARRAY
35592: IN
35593: NOT
35594: PUSH
35595: LD_EXP 80
35599: PUSH
35600: LD_VAR 0 2
35604: ARRAY
35605: PUSH
35606: LD_INT 3
35608: LESS
35609: AND
35610: IFFALSE 35668
// begin SetTag ( j , 121 ) ;
35612: LD_VAR 0 3
35616: PPUSH
35617: LD_INT 121
35619: PPUSH
35620: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35624: LD_ADDR_EXP 80
35628: PUSH
35629: LD_EXP 80
35633: PPUSH
35634: LD_VAR 0 2
35638: PUSH
35639: LD_EXP 80
35643: PUSH
35644: LD_VAR 0 2
35648: ARRAY
35649: PUSH
35650: LD_INT 1
35652: PLUS
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PPUSH
35658: LD_VAR 0 3
35662: PPUSH
35663: CALL 54108 0 3
35667: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
35668: LD_VAR 0 3
35672: PUSH
35673: LD_EXP 80
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: IN
35684: IFFALSE 35909
// begin if GetClass ( j ) <> 4 then
35686: LD_VAR 0 3
35690: PPUSH
35691: CALL_OW 257
35695: PUSH
35696: LD_INT 4
35698: NONEQUAL
35699: IFFALSE 35752
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
35701: LD_ADDR_EXP 80
35705: PUSH
35706: LD_EXP 80
35710: PPUSH
35711: LD_VAR 0 2
35715: PPUSH
35716: LD_EXP 80
35720: PUSH
35721: LD_VAR 0 2
35725: ARRAY
35726: PUSH
35727: LD_VAR 0 3
35731: DIFF
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35738: LD_VAR 0 3
35742: PPUSH
35743: LD_INT 0
35745: PPUSH
35746: CALL_OW 109
// continue ;
35750: GO 35574
// end ; if IsInUnit ( j ) then
35752: LD_VAR 0 3
35756: PPUSH
35757: CALL_OW 310
35761: IFFALSE 35772
// ComExitBuilding ( j ) ;
35763: LD_VAR 0 3
35767: PPUSH
35768: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
35772: LD_ADDR_VAR 0 6
35776: PUSH
35777: LD_VAR 0 7
35781: PPUSH
35782: LD_VAR 0 3
35786: PPUSH
35787: CALL_OW 74
35791: ST_TO_ADDR
// if not ape then
35792: LD_VAR 0 6
35796: NOT
35797: IFFALSE 35801
// break ;
35799: GO 35911
// x := GetX ( ape ) ;
35801: LD_ADDR_VAR 0 4
35805: PUSH
35806: LD_VAR 0 6
35810: PPUSH
35811: CALL_OW 250
35815: ST_TO_ADDR
// y := GetY ( ape ) ;
35816: LD_ADDR_VAR 0 5
35820: PUSH
35821: LD_VAR 0 6
35825: PPUSH
35826: CALL_OW 251
35830: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
35831: LD_VAR 0 4
35835: PPUSH
35836: LD_VAR 0 5
35840: PPUSH
35841: CALL_OW 488
35845: NOT
35846: PUSH
35847: LD_VAR 0 11
35851: PPUSH
35852: LD_VAR 0 4
35856: PPUSH
35857: LD_VAR 0 5
35861: PPUSH
35862: LD_INT 20
35864: PPUSH
35865: CALL 55004 0 4
35869: PUSH
35870: LD_INT 4
35872: ARRAY
35873: OR
35874: IFFALSE 35878
// break ;
35876: GO 35911
// if not HasTask ( j ) then
35878: LD_VAR 0 3
35882: PPUSH
35883: CALL_OW 314
35887: NOT
35888: IFFALSE 35909
// ComTameXY ( j , x , y ) ;
35890: LD_VAR 0 3
35894: PPUSH
35895: LD_VAR 0 4
35899: PPUSH
35900: LD_VAR 0 5
35904: PPUSH
35905: CALL_OW 131
// end ; end ;
35909: GO 35574
35911: POP
35912: POP
// end ;
35913: GO 35130
35915: POP
35916: POP
// end ;
35917: LD_VAR 0 1
35921: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
35922: LD_INT 0
35924: PPUSH
35925: PPUSH
35926: PPUSH
35927: PPUSH
35928: PPUSH
35929: PPUSH
35930: PPUSH
35931: PPUSH
// if not mc_bases then
35932: LD_EXP 49
35936: NOT
35937: IFFALSE 35941
// exit ;
35939: GO 36567
// for i = 1 to mc_bases do
35941: LD_ADDR_VAR 0 2
35945: PUSH
35946: DOUBLE
35947: LD_INT 1
35949: DEC
35950: ST_TO_ADDR
35951: LD_EXP 49
35955: PUSH
35956: FOR_TO
35957: IFFALSE 36565
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
35959: LD_EXP 78
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: NOT
35970: PUSH
35971: LD_EXP 78
35975: PUSH
35976: LD_VAR 0 2
35980: ARRAY
35981: PPUSH
35982: LD_INT 25
35984: PUSH
35985: LD_INT 12
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PPUSH
35992: CALL_OW 72
35996: NOT
35997: OR
35998: IFFALSE 36002
// continue ;
36000: GO 35956
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36002: LD_ADDR_VAR 0 5
36006: PUSH
36007: LD_EXP 78
36011: PUSH
36012: LD_VAR 0 2
36016: ARRAY
36017: PUSH
36018: LD_INT 1
36020: ARRAY
36021: PPUSH
36022: CALL_OW 255
36026: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36027: LD_VAR 0 5
36031: PPUSH
36032: LD_INT 2
36034: PPUSH
36035: CALL_OW 325
36039: IFFALSE 36292
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36041: LD_ADDR_VAR 0 4
36045: PUSH
36046: LD_EXP 78
36050: PUSH
36051: LD_VAR 0 2
36055: ARRAY
36056: PPUSH
36057: LD_INT 25
36059: PUSH
36060: LD_INT 16
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PPUSH
36067: CALL_OW 72
36071: ST_TO_ADDR
// if tmp < 6 then
36072: LD_VAR 0 4
36076: PUSH
36077: LD_INT 6
36079: LESS
36080: IFFALSE 36292
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36082: LD_ADDR_VAR 0 6
36086: PUSH
36087: LD_EXP 49
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PPUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 30
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 30
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: LIST
36125: PPUSH
36126: CALL_OW 72
36130: ST_TO_ADDR
// if depot then
36131: LD_VAR 0 6
36135: IFFALSE 36292
// begin selected := 0 ;
36137: LD_ADDR_VAR 0 7
36141: PUSH
36142: LD_INT 0
36144: ST_TO_ADDR
// for j in depot do
36145: LD_ADDR_VAR 0 3
36149: PUSH
36150: LD_VAR 0 6
36154: PUSH
36155: FOR_IN
36156: IFFALSE 36187
// begin if UnitsInside ( j ) < 6 then
36158: LD_VAR 0 3
36162: PPUSH
36163: CALL_OW 313
36167: PUSH
36168: LD_INT 6
36170: LESS
36171: IFFALSE 36185
// begin selected := j ;
36173: LD_ADDR_VAR 0 7
36177: PUSH
36178: LD_VAR 0 3
36182: ST_TO_ADDR
// break ;
36183: GO 36187
// end ; end ;
36185: GO 36155
36187: POP
36188: POP
// if selected then
36189: LD_VAR 0 7
36193: IFFALSE 36292
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36195: LD_ADDR_VAR 0 3
36199: PUSH
36200: LD_EXP 78
36204: PUSH
36205: LD_VAR 0 2
36209: ARRAY
36210: PPUSH
36211: LD_INT 25
36213: PUSH
36214: LD_INT 12
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PPUSH
36221: CALL_OW 72
36225: PUSH
36226: FOR_IN
36227: IFFALSE 36290
// if not HasTask ( j ) then
36229: LD_VAR 0 3
36233: PPUSH
36234: CALL_OW 314
36238: NOT
36239: IFFALSE 36288
// begin if not IsInUnit ( j ) then
36241: LD_VAR 0 3
36245: PPUSH
36246: CALL_OW 310
36250: NOT
36251: IFFALSE 36267
// ComEnterUnit ( j , selected ) ;
36253: LD_VAR 0 3
36257: PPUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36267: LD_VAR 0 3
36271: PPUSH
36272: LD_INT 16
36274: PPUSH
36275: CALL_OW 183
// AddComExitBuilding ( j ) ;
36279: LD_VAR 0 3
36283: PPUSH
36284: CALL_OW 182
// end ;
36288: GO 36226
36290: POP
36291: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36292: LD_VAR 0 5
36296: PPUSH
36297: LD_INT 11
36299: PPUSH
36300: CALL_OW 325
36304: IFFALSE 36563
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36306: LD_ADDR_VAR 0 4
36310: PUSH
36311: LD_EXP 78
36315: PUSH
36316: LD_VAR 0 2
36320: ARRAY
36321: PPUSH
36322: LD_INT 25
36324: PUSH
36325: LD_INT 16
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PPUSH
36332: CALL_OW 72
36336: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36337: LD_VAR 0 4
36341: PUSH
36342: LD_INT 6
36344: GREATEREQUAL
36345: PUSH
36346: LD_VAR 0 5
36350: PPUSH
36351: LD_INT 2
36353: PPUSH
36354: CALL_OW 325
36358: NOT
36359: OR
36360: IFFALSE 36563
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36362: LD_ADDR_VAR 0 8
36366: PUSH
36367: LD_EXP 49
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: PPUSH
36378: LD_INT 2
36380: PUSH
36381: LD_INT 30
36383: PUSH
36384: LD_INT 4
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 30
36393: PUSH
36394: LD_INT 5
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: LIST
36405: PPUSH
36406: CALL_OW 72
36410: ST_TO_ADDR
// if barracks then
36411: LD_VAR 0 8
36415: IFFALSE 36563
// begin selected := 0 ;
36417: LD_ADDR_VAR 0 7
36421: PUSH
36422: LD_INT 0
36424: ST_TO_ADDR
// for j in barracks do
36425: LD_ADDR_VAR 0 3
36429: PUSH
36430: LD_VAR 0 8
36434: PUSH
36435: FOR_IN
36436: IFFALSE 36467
// begin if UnitsInside ( j ) < 6 then
36438: LD_VAR 0 3
36442: PPUSH
36443: CALL_OW 313
36447: PUSH
36448: LD_INT 6
36450: LESS
36451: IFFALSE 36465
// begin selected := j ;
36453: LD_ADDR_VAR 0 7
36457: PUSH
36458: LD_VAR 0 3
36462: ST_TO_ADDR
// break ;
36463: GO 36467
// end ; end ;
36465: GO 36435
36467: POP
36468: POP
// if selected then
36469: LD_VAR 0 7
36473: IFFALSE 36563
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36475: LD_ADDR_VAR 0 3
36479: PUSH
36480: LD_EXP 78
36484: PUSH
36485: LD_VAR 0 2
36489: ARRAY
36490: PPUSH
36491: LD_INT 25
36493: PUSH
36494: LD_INT 12
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PPUSH
36501: CALL_OW 72
36505: PUSH
36506: FOR_IN
36507: IFFALSE 36561
// if not IsInUnit ( j ) and not HasTask ( j ) then
36509: LD_VAR 0 3
36513: PPUSH
36514: CALL_OW 310
36518: NOT
36519: PUSH
36520: LD_VAR 0 3
36524: PPUSH
36525: CALL_OW 314
36529: NOT
36530: AND
36531: IFFALSE 36559
// begin ComEnterUnit ( j , selected ) ;
36533: LD_VAR 0 3
36537: PPUSH
36538: LD_VAR 0 7
36542: PPUSH
36543: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36547: LD_VAR 0 3
36551: PPUSH
36552: LD_INT 15
36554: PPUSH
36555: CALL_OW 183
// end ;
36559: GO 36506
36561: POP
36562: POP
// end ; end ; end ; end ; end ;
36563: GO 35956
36565: POP
36566: POP
// end ;
36567: LD_VAR 0 1
36571: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36572: LD_INT 0
36574: PPUSH
36575: PPUSH
36576: PPUSH
36577: PPUSH
// if not mc_bases then
36578: LD_EXP 49
36582: NOT
36583: IFFALSE 36587
// exit ;
36585: GO 36765
// for i = 1 to mc_bases do
36587: LD_ADDR_VAR 0 2
36591: PUSH
36592: DOUBLE
36593: LD_INT 1
36595: DEC
36596: ST_TO_ADDR
36597: LD_EXP 49
36601: PUSH
36602: FOR_TO
36603: IFFALSE 36763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36605: LD_ADDR_VAR 0 4
36609: PUSH
36610: LD_EXP 49
36614: PUSH
36615: LD_VAR 0 2
36619: ARRAY
36620: PPUSH
36621: LD_INT 25
36623: PUSH
36624: LD_INT 9
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PPUSH
36631: CALL_OW 72
36635: ST_TO_ADDR
// if not tmp then
36636: LD_VAR 0 4
36640: NOT
36641: IFFALSE 36645
// continue ;
36643: GO 36602
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
36645: LD_EXP 75
36649: PUSH
36650: LD_VAR 0 2
36654: ARRAY
36655: PPUSH
36656: LD_INT 29
36658: PPUSH
36659: CALL_OW 325
36663: NOT
36664: PUSH
36665: LD_EXP 75
36669: PUSH
36670: LD_VAR 0 2
36674: ARRAY
36675: PPUSH
36676: LD_INT 28
36678: PPUSH
36679: CALL_OW 325
36683: NOT
36684: AND
36685: IFFALSE 36689
// continue ;
36687: GO 36602
// for j in tmp do
36689: LD_ADDR_VAR 0 3
36693: PUSH
36694: LD_VAR 0 4
36698: PUSH
36699: FOR_IN
36700: IFFALSE 36759
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36702: LD_VAR 0 3
36706: PUSH
36707: LD_EXP 52
36711: PUSH
36712: LD_VAR 0 2
36716: ARRAY
36717: PUSH
36718: LD_INT 1
36720: ARRAY
36721: IN
36722: NOT
36723: PUSH
36724: LD_VAR 0 3
36728: PUSH
36729: LD_EXP 52
36733: PUSH
36734: LD_VAR 0 2
36738: ARRAY
36739: PUSH
36740: LD_INT 2
36742: ARRAY
36743: IN
36744: NOT
36745: AND
36746: IFFALSE 36757
// ComSpaceTimeShoot ( j ) ;
36748: LD_VAR 0 3
36752: PPUSH
36753: CALL 47783 0 1
36757: GO 36699
36759: POP
36760: POP
// end ;
36761: GO 36602
36763: POP
36764: POP
// end ;
36765: LD_VAR 0 1
36769: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
36770: LD_INT 0
36772: PPUSH
36773: PPUSH
36774: PPUSH
36775: PPUSH
36776: PPUSH
36777: PPUSH
36778: PPUSH
36779: PPUSH
36780: PPUSH
// if not mc_bases then
36781: LD_EXP 49
36785: NOT
36786: IFFALSE 36790
// exit ;
36788: GO 37412
// for i = 1 to mc_bases do
36790: LD_ADDR_VAR 0 2
36794: PUSH
36795: DOUBLE
36796: LD_INT 1
36798: DEC
36799: ST_TO_ADDR
36800: LD_EXP 49
36804: PUSH
36805: FOR_TO
36806: IFFALSE 37410
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
36808: LD_EXP 84
36812: PUSH
36813: LD_VAR 0 2
36817: ARRAY
36818: NOT
36819: PUSH
36820: LD_INT 38
36822: PPUSH
36823: LD_EXP 75
36827: PUSH
36828: LD_VAR 0 2
36832: ARRAY
36833: PPUSH
36834: CALL_OW 321
36838: PUSH
36839: LD_INT 2
36841: NONEQUAL
36842: OR
36843: IFFALSE 36847
// continue ;
36845: GO 36805
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
36847: LD_ADDR_VAR 0 8
36851: PUSH
36852: LD_EXP 49
36856: PUSH
36857: LD_VAR 0 2
36861: ARRAY
36862: PPUSH
36863: LD_INT 30
36865: PUSH
36866: LD_INT 34
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PPUSH
36873: CALL_OW 72
36877: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
36878: LD_ADDR_VAR 0 9
36882: PUSH
36883: LD_EXP 49
36887: PUSH
36888: LD_VAR 0 2
36892: ARRAY
36893: PPUSH
36894: LD_INT 25
36896: PUSH
36897: LD_INT 4
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PPUSH
36904: CALL_OW 72
36908: PPUSH
36909: LD_INT 0
36911: PPUSH
36912: CALL 87368 0 2
36916: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
36917: LD_VAR 0 9
36921: NOT
36922: PUSH
36923: LD_VAR 0 8
36927: NOT
36928: OR
36929: PUSH
36930: LD_EXP 49
36934: PUSH
36935: LD_VAR 0 2
36939: ARRAY
36940: PPUSH
36941: LD_INT 124
36943: PPUSH
36944: CALL 87368 0 2
36948: OR
36949: IFFALSE 36953
// continue ;
36951: GO 36805
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
36953: LD_EXP 85
36957: PUSH
36958: LD_VAR 0 2
36962: ARRAY
36963: PUSH
36964: LD_EXP 84
36968: PUSH
36969: LD_VAR 0 2
36973: ARRAY
36974: LESS
36975: PUSH
36976: LD_EXP 85
36980: PUSH
36981: LD_VAR 0 2
36985: ARRAY
36986: PUSH
36987: LD_VAR 0 8
36991: LESS
36992: AND
36993: IFFALSE 37408
// begin tmp := sci [ 1 ] ;
36995: LD_ADDR_VAR 0 7
36999: PUSH
37000: LD_VAR 0 9
37004: PUSH
37005: LD_INT 1
37007: ARRAY
37008: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37009: LD_VAR 0 7
37013: PPUSH
37014: LD_INT 124
37016: PPUSH
37017: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37021: LD_ADDR_VAR 0 3
37025: PUSH
37026: DOUBLE
37027: LD_EXP 84
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: INC
37038: ST_TO_ADDR
37039: LD_EXP 84
37043: PUSH
37044: LD_VAR 0 2
37048: ARRAY
37049: PUSH
37050: FOR_DOWNTO
37051: IFFALSE 37394
// begin if IsInUnit ( tmp ) then
37053: LD_VAR 0 7
37057: PPUSH
37058: CALL_OW 310
37062: IFFALSE 37073
// ComExitBuilding ( tmp ) ;
37064: LD_VAR 0 7
37068: PPUSH
37069: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37073: LD_INT 35
37075: PPUSH
37076: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37080: LD_VAR 0 7
37084: PPUSH
37085: CALL_OW 310
37089: NOT
37090: PUSH
37091: LD_VAR 0 7
37095: PPUSH
37096: CALL_OW 314
37100: NOT
37101: AND
37102: IFFALSE 37073
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37104: LD_ADDR_VAR 0 6
37108: PUSH
37109: LD_VAR 0 7
37113: PPUSH
37114: CALL_OW 250
37118: PUSH
37119: LD_VAR 0 7
37123: PPUSH
37124: CALL_OW 251
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37133: LD_INT 35
37135: PPUSH
37136: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37140: LD_ADDR_VAR 0 4
37144: PUSH
37145: LD_EXP 84
37149: PUSH
37150: LD_VAR 0 2
37154: ARRAY
37155: PUSH
37156: LD_VAR 0 3
37160: ARRAY
37161: PUSH
37162: LD_INT 1
37164: ARRAY
37165: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37166: LD_ADDR_VAR 0 5
37170: PUSH
37171: LD_EXP 84
37175: PUSH
37176: LD_VAR 0 2
37180: ARRAY
37181: PUSH
37182: LD_VAR 0 3
37186: ARRAY
37187: PUSH
37188: LD_INT 2
37190: ARRAY
37191: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37192: LD_VAR 0 7
37196: PPUSH
37197: LD_INT 10
37199: PPUSH
37200: CALL 56701 0 2
37204: PUSH
37205: LD_INT 4
37207: ARRAY
37208: IFFALSE 37246
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37210: LD_VAR 0 7
37214: PPUSH
37215: LD_VAR 0 6
37219: PUSH
37220: LD_INT 1
37222: ARRAY
37223: PPUSH
37224: LD_VAR 0 6
37228: PUSH
37229: LD_INT 2
37231: ARRAY
37232: PPUSH
37233: CALL_OW 111
// wait ( 0 0$10 ) ;
37237: LD_INT 350
37239: PPUSH
37240: CALL_OW 67
// end else
37244: GO 37272
// begin ComMoveXY ( tmp , x , y ) ;
37246: LD_VAR 0 7
37250: PPUSH
37251: LD_VAR 0 4
37255: PPUSH
37256: LD_VAR 0 5
37260: PPUSH
37261: CALL_OW 111
// wait ( 0 0$3 ) ;
37265: LD_INT 105
37267: PPUSH
37268: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37272: LD_VAR 0 7
37276: PPUSH
37277: LD_VAR 0 4
37281: PPUSH
37282: LD_VAR 0 5
37286: PPUSH
37287: CALL_OW 307
37291: IFFALSE 37133
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37293: LD_VAR 0 7
37297: PPUSH
37298: LD_VAR 0 4
37302: PPUSH
37303: LD_VAR 0 5
37307: PPUSH
37308: LD_VAR 0 8
37312: PUSH
37313: LD_VAR 0 3
37317: ARRAY
37318: PPUSH
37319: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37323: LD_INT 35
37325: PPUSH
37326: CALL_OW 67
// until not HasTask ( tmp ) ;
37330: LD_VAR 0 7
37334: PPUSH
37335: CALL_OW 314
37339: NOT
37340: IFFALSE 37323
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37342: LD_ADDR_EXP 85
37346: PUSH
37347: LD_EXP 85
37351: PPUSH
37352: LD_VAR 0 2
37356: PUSH
37357: LD_EXP 85
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PUSH
37368: LD_INT 1
37370: PLUS
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PPUSH
37376: LD_VAR 0 8
37380: PUSH
37381: LD_VAR 0 3
37385: ARRAY
37386: PPUSH
37387: CALL 54108 0 3
37391: ST_TO_ADDR
// end ;
37392: GO 37050
37394: POP
37395: POP
// MC_Reset ( i , 124 ) ;
37396: LD_VAR 0 2
37400: PPUSH
37401: LD_INT 124
37403: PPUSH
37404: CALL 20895 0 2
// end ; end ;
37408: GO 36805
37410: POP
37411: POP
// end ;
37412: LD_VAR 0 1
37416: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37417: LD_INT 0
37419: PPUSH
37420: PPUSH
37421: PPUSH
// if not mc_bases then
37422: LD_EXP 49
37426: NOT
37427: IFFALSE 37431
// exit ;
37429: GO 38037
// for i = 1 to mc_bases do
37431: LD_ADDR_VAR 0 2
37435: PUSH
37436: DOUBLE
37437: LD_INT 1
37439: DEC
37440: ST_TO_ADDR
37441: LD_EXP 49
37445: PUSH
37446: FOR_TO
37447: IFFALSE 38035
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37449: LD_ADDR_VAR 0 3
37453: PUSH
37454: LD_EXP 49
37458: PUSH
37459: LD_VAR 0 2
37463: ARRAY
37464: PPUSH
37465: LD_INT 25
37467: PUSH
37468: LD_INT 4
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PPUSH
37475: CALL_OW 72
37479: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37480: LD_VAR 0 3
37484: NOT
37485: PUSH
37486: LD_EXP 86
37490: PUSH
37491: LD_VAR 0 2
37495: ARRAY
37496: NOT
37497: OR
37498: PUSH
37499: LD_EXP 49
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: PPUSH
37510: LD_INT 2
37512: PUSH
37513: LD_INT 30
37515: PUSH
37516: LD_INT 0
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 30
37525: PUSH
37526: LD_INT 1
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: LIST
37537: PPUSH
37538: CALL_OW 72
37542: NOT
37543: OR
37544: IFFALSE 37594
// begin if mc_deposits_finder [ i ] then
37546: LD_EXP 87
37550: PUSH
37551: LD_VAR 0 2
37555: ARRAY
37556: IFFALSE 37592
// begin MC_Reset ( i , 125 ) ;
37558: LD_VAR 0 2
37562: PPUSH
37563: LD_INT 125
37565: PPUSH
37566: CALL 20895 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37570: LD_ADDR_EXP 87
37574: PUSH
37575: LD_EXP 87
37579: PPUSH
37580: LD_VAR 0 2
37584: PPUSH
37585: EMPTY
37586: PPUSH
37587: CALL_OW 1
37591: ST_TO_ADDR
// end ; continue ;
37592: GO 37446
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37594: LD_EXP 86
37598: PUSH
37599: LD_VAR 0 2
37603: ARRAY
37604: PUSH
37605: LD_INT 1
37607: ARRAY
37608: PUSH
37609: LD_INT 3
37611: ARRAY
37612: PUSH
37613: LD_INT 1
37615: EQUAL
37616: PUSH
37617: LD_INT 20
37619: PPUSH
37620: LD_EXP 75
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: PPUSH
37631: CALL_OW 321
37635: PUSH
37636: LD_INT 2
37638: NONEQUAL
37639: AND
37640: IFFALSE 37690
// begin if mc_deposits_finder [ i ] then
37642: LD_EXP 87
37646: PUSH
37647: LD_VAR 0 2
37651: ARRAY
37652: IFFALSE 37688
// begin MC_Reset ( i , 125 ) ;
37654: LD_VAR 0 2
37658: PPUSH
37659: LD_INT 125
37661: PPUSH
37662: CALL 20895 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37666: LD_ADDR_EXP 87
37670: PUSH
37671: LD_EXP 87
37675: PPUSH
37676: LD_VAR 0 2
37680: PPUSH
37681: EMPTY
37682: PPUSH
37683: CALL_OW 1
37687: ST_TO_ADDR
// end ; continue ;
37688: GO 37446
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
37690: LD_EXP 86
37694: PUSH
37695: LD_VAR 0 2
37699: ARRAY
37700: PUSH
37701: LD_INT 1
37703: ARRAY
37704: PUSH
37705: LD_INT 1
37707: ARRAY
37708: PPUSH
37709: LD_EXP 86
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: PUSH
37720: LD_INT 1
37722: ARRAY
37723: PUSH
37724: LD_INT 2
37726: ARRAY
37727: PPUSH
37728: LD_EXP 75
37732: PUSH
37733: LD_VAR 0 2
37737: ARRAY
37738: PPUSH
37739: CALL_OW 440
37743: IFFALSE 37786
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
37745: LD_ADDR_EXP 86
37749: PUSH
37750: LD_EXP 86
37754: PPUSH
37755: LD_VAR 0 2
37759: PPUSH
37760: LD_EXP 86
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PPUSH
37771: LD_INT 1
37773: PPUSH
37774: CALL_OW 3
37778: PPUSH
37779: CALL_OW 1
37783: ST_TO_ADDR
37784: GO 38033
// begin if not mc_deposits_finder [ i ] then
37786: LD_EXP 87
37790: PUSH
37791: LD_VAR 0 2
37795: ARRAY
37796: NOT
37797: IFFALSE 37849
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
37799: LD_ADDR_EXP 87
37803: PUSH
37804: LD_EXP 87
37808: PPUSH
37809: LD_VAR 0 2
37813: PPUSH
37814: LD_VAR 0 3
37818: PUSH
37819: LD_INT 1
37821: ARRAY
37822: PUSH
37823: EMPTY
37824: LIST
37825: PPUSH
37826: CALL_OW 1
37830: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
37831: LD_VAR 0 3
37835: PUSH
37836: LD_INT 1
37838: ARRAY
37839: PPUSH
37840: LD_INT 125
37842: PPUSH
37843: CALL_OW 109
// end else
37847: GO 38033
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
37849: LD_EXP 87
37853: PUSH
37854: LD_VAR 0 2
37858: ARRAY
37859: PUSH
37860: LD_INT 1
37862: ARRAY
37863: PPUSH
37864: CALL_OW 310
37868: IFFALSE 37891
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
37870: LD_EXP 87
37874: PUSH
37875: LD_VAR 0 2
37879: ARRAY
37880: PUSH
37881: LD_INT 1
37883: ARRAY
37884: PPUSH
37885: CALL_OW 122
37889: GO 38033
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
37891: LD_EXP 87
37895: PUSH
37896: LD_VAR 0 2
37900: ARRAY
37901: PUSH
37902: LD_INT 1
37904: ARRAY
37905: PPUSH
37906: CALL_OW 314
37910: NOT
37911: PUSH
37912: LD_EXP 87
37916: PUSH
37917: LD_VAR 0 2
37921: ARRAY
37922: PUSH
37923: LD_INT 1
37925: ARRAY
37926: PPUSH
37927: LD_EXP 86
37931: PUSH
37932: LD_VAR 0 2
37936: ARRAY
37937: PUSH
37938: LD_INT 1
37940: ARRAY
37941: PUSH
37942: LD_INT 1
37944: ARRAY
37945: PPUSH
37946: LD_EXP 86
37950: PUSH
37951: LD_VAR 0 2
37955: ARRAY
37956: PUSH
37957: LD_INT 1
37959: ARRAY
37960: PUSH
37961: LD_INT 2
37963: ARRAY
37964: PPUSH
37965: CALL_OW 297
37969: PUSH
37970: LD_INT 6
37972: GREATER
37973: AND
37974: IFFALSE 38033
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
37976: LD_EXP 87
37980: PUSH
37981: LD_VAR 0 2
37985: ARRAY
37986: PUSH
37987: LD_INT 1
37989: ARRAY
37990: PPUSH
37991: LD_EXP 86
37995: PUSH
37996: LD_VAR 0 2
38000: ARRAY
38001: PUSH
38002: LD_INT 1
38004: ARRAY
38005: PUSH
38006: LD_INT 1
38008: ARRAY
38009: PPUSH
38010: LD_EXP 86
38014: PUSH
38015: LD_VAR 0 2
38019: ARRAY
38020: PUSH
38021: LD_INT 1
38023: ARRAY
38024: PUSH
38025: LD_INT 2
38027: ARRAY
38028: PPUSH
38029: CALL_OW 111
// end ; end ; end ;
38033: GO 37446
38035: POP
38036: POP
// end ;
38037: LD_VAR 0 1
38041: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38042: LD_INT 0
38044: PPUSH
38045: PPUSH
38046: PPUSH
38047: PPUSH
38048: PPUSH
38049: PPUSH
38050: PPUSH
38051: PPUSH
38052: PPUSH
38053: PPUSH
38054: PPUSH
// if not mc_bases then
38055: LD_EXP 49
38059: NOT
38060: IFFALSE 38064
// exit ;
38062: GO 39004
// for i = 1 to mc_bases do
38064: LD_ADDR_VAR 0 2
38068: PUSH
38069: DOUBLE
38070: LD_INT 1
38072: DEC
38073: ST_TO_ADDR
38074: LD_EXP 49
38078: PUSH
38079: FOR_TO
38080: IFFALSE 39002
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38082: LD_EXP 49
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: NOT
38093: PUSH
38094: LD_EXP 72
38098: PUSH
38099: LD_VAR 0 2
38103: ARRAY
38104: OR
38105: IFFALSE 38109
// continue ;
38107: GO 38079
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38109: LD_ADDR_VAR 0 7
38113: PUSH
38114: LD_EXP 49
38118: PUSH
38119: LD_VAR 0 2
38123: ARRAY
38124: PUSH
38125: LD_INT 1
38127: ARRAY
38128: PPUSH
38129: CALL_OW 248
38133: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38134: LD_VAR 0 7
38138: PUSH
38139: LD_INT 3
38141: EQUAL
38142: PUSH
38143: LD_EXP 68
38147: PUSH
38148: LD_VAR 0 2
38152: ARRAY
38153: PUSH
38154: LD_EXP 71
38158: PUSH
38159: LD_VAR 0 2
38163: ARRAY
38164: UNION
38165: PPUSH
38166: LD_INT 33
38168: PUSH
38169: LD_INT 2
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PPUSH
38176: CALL_OW 72
38180: NOT
38181: OR
38182: IFFALSE 38186
// continue ;
38184: GO 38079
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38186: LD_ADDR_VAR 0 9
38190: PUSH
38191: LD_EXP 49
38195: PUSH
38196: LD_VAR 0 2
38200: ARRAY
38201: PPUSH
38202: LD_INT 30
38204: PUSH
38205: LD_INT 36
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 72
38216: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38217: LD_ADDR_VAR 0 10
38221: PUSH
38222: LD_EXP 68
38226: PUSH
38227: LD_VAR 0 2
38231: ARRAY
38232: PPUSH
38233: LD_INT 34
38235: PUSH
38236: LD_INT 31
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PPUSH
38243: CALL_OW 72
38247: ST_TO_ADDR
// if not cts and not mcts then
38248: LD_VAR 0 9
38252: NOT
38253: PUSH
38254: LD_VAR 0 10
38258: NOT
38259: AND
38260: IFFALSE 38264
// continue ;
38262: GO 38079
// x := cts ;
38264: LD_ADDR_VAR 0 11
38268: PUSH
38269: LD_VAR 0 9
38273: ST_TO_ADDR
// if not x then
38274: LD_VAR 0 11
38278: NOT
38279: IFFALSE 38291
// x := mcts ;
38281: LD_ADDR_VAR 0 11
38285: PUSH
38286: LD_VAR 0 10
38290: ST_TO_ADDR
// if not x then
38291: LD_VAR 0 11
38295: NOT
38296: IFFALSE 38300
// continue ;
38298: GO 38079
// if mc_remote_driver [ i ] then
38300: LD_EXP 89
38304: PUSH
38305: LD_VAR 0 2
38309: ARRAY
38310: IFFALSE 38697
// for j in mc_remote_driver [ i ] do
38312: LD_ADDR_VAR 0 3
38316: PUSH
38317: LD_EXP 89
38321: PUSH
38322: LD_VAR 0 2
38326: ARRAY
38327: PUSH
38328: FOR_IN
38329: IFFALSE 38695
// begin if GetClass ( j ) <> 3 then
38331: LD_VAR 0 3
38335: PPUSH
38336: CALL_OW 257
38340: PUSH
38341: LD_INT 3
38343: NONEQUAL
38344: IFFALSE 38397
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38346: LD_ADDR_EXP 89
38350: PUSH
38351: LD_EXP 89
38355: PPUSH
38356: LD_VAR 0 2
38360: PPUSH
38361: LD_EXP 89
38365: PUSH
38366: LD_VAR 0 2
38370: ARRAY
38371: PUSH
38372: LD_VAR 0 3
38376: DIFF
38377: PPUSH
38378: CALL_OW 1
38382: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38383: LD_VAR 0 3
38387: PPUSH
38388: LD_INT 0
38390: PPUSH
38391: CALL_OW 109
// continue ;
38395: GO 38328
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38397: LD_EXP 68
38401: PUSH
38402: LD_VAR 0 2
38406: ARRAY
38407: PPUSH
38408: LD_INT 34
38410: PUSH
38411: LD_INT 31
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 58
38420: PUSH
38421: EMPTY
38422: LIST
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PPUSH
38428: CALL_OW 72
38432: PUSH
38433: LD_VAR 0 3
38437: PPUSH
38438: CALL 87456 0 1
38442: NOT
38443: AND
38444: IFFALSE 38515
// begin if IsInUnit ( j ) then
38446: LD_VAR 0 3
38450: PPUSH
38451: CALL_OW 310
38455: IFFALSE 38466
// ComExitBuilding ( j ) ;
38457: LD_VAR 0 3
38461: PPUSH
38462: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38466: LD_VAR 0 3
38470: PPUSH
38471: LD_EXP 68
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PPUSH
38482: LD_INT 34
38484: PUSH
38485: LD_INT 31
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 58
38494: PUSH
38495: EMPTY
38496: LIST
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PPUSH
38502: CALL_OW 72
38506: PUSH
38507: LD_INT 1
38509: ARRAY
38510: PPUSH
38511: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38515: LD_VAR 0 3
38519: PPUSH
38520: CALL_OW 310
38524: NOT
38525: PUSH
38526: LD_VAR 0 3
38530: PPUSH
38531: CALL_OW 310
38535: PPUSH
38536: CALL_OW 266
38540: PUSH
38541: LD_INT 36
38543: NONEQUAL
38544: PUSH
38545: LD_VAR 0 3
38549: PPUSH
38550: CALL 87456 0 1
38554: NOT
38555: AND
38556: OR
38557: IFFALSE 38693
// begin if IsInUnit ( j ) then
38559: LD_VAR 0 3
38563: PPUSH
38564: CALL_OW 310
38568: IFFALSE 38579
// ComExitBuilding ( j ) ;
38570: LD_VAR 0 3
38574: PPUSH
38575: CALL_OW 122
// ct := 0 ;
38579: LD_ADDR_VAR 0 8
38583: PUSH
38584: LD_INT 0
38586: ST_TO_ADDR
// for k in x do
38587: LD_ADDR_VAR 0 4
38591: PUSH
38592: LD_VAR 0 11
38596: PUSH
38597: FOR_IN
38598: IFFALSE 38671
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38600: LD_VAR 0 4
38604: PPUSH
38605: CALL_OW 264
38609: PUSH
38610: LD_INT 31
38612: EQUAL
38613: PUSH
38614: LD_VAR 0 4
38618: PPUSH
38619: CALL_OW 311
38623: NOT
38624: AND
38625: PUSH
38626: LD_VAR 0 4
38630: PPUSH
38631: CALL_OW 266
38635: PUSH
38636: LD_INT 36
38638: EQUAL
38639: PUSH
38640: LD_VAR 0 4
38644: PPUSH
38645: CALL_OW 313
38649: PUSH
38650: LD_INT 3
38652: LESS
38653: AND
38654: OR
38655: IFFALSE 38669
// begin ct := k ;
38657: LD_ADDR_VAR 0 8
38661: PUSH
38662: LD_VAR 0 4
38666: ST_TO_ADDR
// break ;
38667: GO 38671
// end ;
38669: GO 38597
38671: POP
38672: POP
// if ct then
38673: LD_VAR 0 8
38677: IFFALSE 38693
// ComEnterUnit ( j , ct ) ;
38679: LD_VAR 0 3
38683: PPUSH
38684: LD_VAR 0 8
38688: PPUSH
38689: CALL_OW 120
// end ; end ;
38693: GO 38328
38695: POP
38696: POP
// places := 0 ;
38697: LD_ADDR_VAR 0 5
38701: PUSH
38702: LD_INT 0
38704: ST_TO_ADDR
// for j = 1 to x do
38705: LD_ADDR_VAR 0 3
38709: PUSH
38710: DOUBLE
38711: LD_INT 1
38713: DEC
38714: ST_TO_ADDR
38715: LD_VAR 0 11
38719: PUSH
38720: FOR_TO
38721: IFFALSE 38797
// if GetWeapon ( x [ j ] ) = ar_control_tower then
38723: LD_VAR 0 11
38727: PUSH
38728: LD_VAR 0 3
38732: ARRAY
38733: PPUSH
38734: CALL_OW 264
38738: PUSH
38739: LD_INT 31
38741: EQUAL
38742: IFFALSE 38760
// places := places + 1 else
38744: LD_ADDR_VAR 0 5
38748: PUSH
38749: LD_VAR 0 5
38753: PUSH
38754: LD_INT 1
38756: PLUS
38757: ST_TO_ADDR
38758: GO 38795
// if GetBType ( x [ j ] ) = b_control_tower then
38760: LD_VAR 0 11
38764: PUSH
38765: LD_VAR 0 3
38769: ARRAY
38770: PPUSH
38771: CALL_OW 266
38775: PUSH
38776: LD_INT 36
38778: EQUAL
38779: IFFALSE 38795
// places := places + 3 ;
38781: LD_ADDR_VAR 0 5
38785: PUSH
38786: LD_VAR 0 5
38790: PUSH
38791: LD_INT 3
38793: PLUS
38794: ST_TO_ADDR
38795: GO 38720
38797: POP
38798: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
38799: LD_VAR 0 5
38803: PUSH
38804: LD_INT 0
38806: EQUAL
38807: PUSH
38808: LD_VAR 0 5
38812: PUSH
38813: LD_EXP 89
38817: PUSH
38818: LD_VAR 0 2
38822: ARRAY
38823: LESSEQUAL
38824: OR
38825: IFFALSE 38829
// continue ;
38827: GO 38079
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
38829: LD_ADDR_VAR 0 6
38833: PUSH
38834: LD_EXP 49
38838: PUSH
38839: LD_VAR 0 2
38843: ARRAY
38844: PPUSH
38845: LD_INT 25
38847: PUSH
38848: LD_INT 3
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PPUSH
38855: CALL_OW 72
38859: PUSH
38860: LD_EXP 89
38864: PUSH
38865: LD_VAR 0 2
38869: ARRAY
38870: DIFF
38871: PPUSH
38872: LD_INT 3
38874: PPUSH
38875: CALL 88356 0 2
38879: ST_TO_ADDR
// for j in tmp do
38880: LD_ADDR_VAR 0 3
38884: PUSH
38885: LD_VAR 0 6
38889: PUSH
38890: FOR_IN
38891: IFFALSE 38926
// if GetTag ( j ) > 0 then
38893: LD_VAR 0 3
38897: PPUSH
38898: CALL_OW 110
38902: PUSH
38903: LD_INT 0
38905: GREATER
38906: IFFALSE 38924
// tmp := tmp diff j ;
38908: LD_ADDR_VAR 0 6
38912: PUSH
38913: LD_VAR 0 6
38917: PUSH
38918: LD_VAR 0 3
38922: DIFF
38923: ST_TO_ADDR
38924: GO 38890
38926: POP
38927: POP
// if not tmp then
38928: LD_VAR 0 6
38932: NOT
38933: IFFALSE 38937
// continue ;
38935: GO 38079
// if places then
38937: LD_VAR 0 5
38941: IFFALSE 39000
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
38943: LD_ADDR_EXP 89
38947: PUSH
38948: LD_EXP 89
38952: PPUSH
38953: LD_VAR 0 2
38957: PPUSH
38958: LD_EXP 89
38962: PUSH
38963: LD_VAR 0 2
38967: ARRAY
38968: PUSH
38969: LD_VAR 0 6
38973: PUSH
38974: LD_INT 1
38976: ARRAY
38977: UNION
38978: PPUSH
38979: CALL_OW 1
38983: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
38984: LD_VAR 0 6
38988: PUSH
38989: LD_INT 1
38991: ARRAY
38992: PPUSH
38993: LD_INT 126
38995: PPUSH
38996: CALL_OW 109
// end ; end ;
39000: GO 38079
39002: POP
39003: POP
// end ;
39004: LD_VAR 0 1
39008: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39009: LD_INT 0
39011: PPUSH
39012: PPUSH
39013: PPUSH
39014: PPUSH
39015: PPUSH
39016: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39017: LD_VAR 0 1
39021: NOT
39022: PUSH
39023: LD_VAR 0 2
39027: NOT
39028: OR
39029: PUSH
39030: LD_VAR 0 3
39034: NOT
39035: OR
39036: PUSH
39037: LD_VAR 0 4
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: LD_INT 2
39047: PUSH
39048: LD_INT 3
39050: PUSH
39051: LD_INT 4
39053: PUSH
39054: LD_INT 5
39056: PUSH
39057: LD_INT 8
39059: PUSH
39060: LD_INT 9
39062: PUSH
39063: LD_INT 15
39065: PUSH
39066: LD_INT 16
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: IN
39080: NOT
39081: OR
39082: IFFALSE 39086
// exit ;
39084: GO 39986
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39086: LD_ADDR_VAR 0 2
39090: PUSH
39091: LD_VAR 0 2
39095: PPUSH
39096: LD_INT 21
39098: PUSH
39099: LD_INT 3
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 24
39108: PUSH
39109: LD_INT 250
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PPUSH
39120: CALL_OW 72
39124: ST_TO_ADDR
// case class of 1 , 15 :
39125: LD_VAR 0 4
39129: PUSH
39130: LD_INT 1
39132: DOUBLE
39133: EQUAL
39134: IFTRUE 39144
39136: LD_INT 15
39138: DOUBLE
39139: EQUAL
39140: IFTRUE 39144
39142: GO 39229
39144: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39145: LD_ADDR_VAR 0 8
39149: PUSH
39150: LD_VAR 0 2
39154: PPUSH
39155: LD_INT 2
39157: PUSH
39158: LD_INT 30
39160: PUSH
39161: LD_INT 32
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 30
39170: PUSH
39171: LD_INT 31
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: LIST
39182: PPUSH
39183: CALL_OW 72
39187: PUSH
39188: LD_VAR 0 2
39192: PPUSH
39193: LD_INT 2
39195: PUSH
39196: LD_INT 30
39198: PUSH
39199: LD_INT 4
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 30
39208: PUSH
39209: LD_INT 5
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: LIST
39220: PPUSH
39221: CALL_OW 72
39225: ADD
39226: ST_TO_ADDR
39227: GO 39475
39229: LD_INT 2
39231: DOUBLE
39232: EQUAL
39233: IFTRUE 39243
39235: LD_INT 16
39237: DOUBLE
39238: EQUAL
39239: IFTRUE 39243
39241: GO 39289
39243: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39244: LD_ADDR_VAR 0 8
39248: PUSH
39249: LD_VAR 0 2
39253: PPUSH
39254: LD_INT 2
39256: PUSH
39257: LD_INT 30
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 30
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: LIST
39281: PPUSH
39282: CALL_OW 72
39286: ST_TO_ADDR
39287: GO 39475
39289: LD_INT 3
39291: DOUBLE
39292: EQUAL
39293: IFTRUE 39297
39295: GO 39343
39297: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39298: LD_ADDR_VAR 0 8
39302: PUSH
39303: LD_VAR 0 2
39307: PPUSH
39308: LD_INT 2
39310: PUSH
39311: LD_INT 30
39313: PUSH
39314: LD_INT 2
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: LD_INT 30
39323: PUSH
39324: LD_INT 3
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: LIST
39335: PPUSH
39336: CALL_OW 72
39340: ST_TO_ADDR
39341: GO 39475
39343: LD_INT 4
39345: DOUBLE
39346: EQUAL
39347: IFTRUE 39351
39349: GO 39408
39351: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39352: LD_ADDR_VAR 0 8
39356: PUSH
39357: LD_VAR 0 2
39361: PPUSH
39362: LD_INT 2
39364: PUSH
39365: LD_INT 30
39367: PUSH
39368: LD_INT 6
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 30
39377: PUSH
39378: LD_INT 7
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 30
39387: PUSH
39388: LD_INT 8
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: PPUSH
39401: CALL_OW 72
39405: ST_TO_ADDR
39406: GO 39475
39408: LD_INT 5
39410: DOUBLE
39411: EQUAL
39412: IFTRUE 39428
39414: LD_INT 8
39416: DOUBLE
39417: EQUAL
39418: IFTRUE 39428
39420: LD_INT 9
39422: DOUBLE
39423: EQUAL
39424: IFTRUE 39428
39426: GO 39474
39428: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39429: LD_ADDR_VAR 0 8
39433: PUSH
39434: LD_VAR 0 2
39438: PPUSH
39439: LD_INT 2
39441: PUSH
39442: LD_INT 30
39444: PUSH
39445: LD_INT 4
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 30
39454: PUSH
39455: LD_INT 5
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: LIST
39466: PPUSH
39467: CALL_OW 72
39471: ST_TO_ADDR
39472: GO 39475
39474: POP
// if not tmp then
39475: LD_VAR 0 8
39479: NOT
39480: IFFALSE 39484
// exit ;
39482: GO 39986
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39484: LD_VAR 0 4
39488: PUSH
39489: LD_INT 1
39491: PUSH
39492: LD_INT 15
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: IN
39499: PUSH
39500: LD_EXP 58
39504: PUSH
39505: LD_VAR 0 1
39509: ARRAY
39510: AND
39511: IFFALSE 39667
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39513: LD_ADDR_VAR 0 9
39517: PUSH
39518: LD_EXP 58
39522: PUSH
39523: LD_VAR 0 1
39527: ARRAY
39528: PUSH
39529: LD_INT 1
39531: ARRAY
39532: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39533: LD_VAR 0 9
39537: PUSH
39538: LD_EXP 59
39542: PUSH
39543: LD_VAR 0 1
39547: ARRAY
39548: IN
39549: NOT
39550: IFFALSE 39665
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39552: LD_ADDR_EXP 59
39556: PUSH
39557: LD_EXP 59
39561: PPUSH
39562: LD_VAR 0 1
39566: PUSH
39567: LD_EXP 59
39571: PUSH
39572: LD_VAR 0 1
39576: ARRAY
39577: PUSH
39578: LD_INT 1
39580: PLUS
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PPUSH
39586: LD_VAR 0 9
39590: PPUSH
39591: CALL 54108 0 3
39595: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39596: LD_ADDR_EXP 58
39600: PUSH
39601: LD_EXP 58
39605: PPUSH
39606: LD_VAR 0 1
39610: PPUSH
39611: LD_EXP 58
39615: PUSH
39616: LD_VAR 0 1
39620: ARRAY
39621: PUSH
39622: LD_VAR 0 9
39626: DIFF
39627: PPUSH
39628: CALL_OW 1
39632: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39633: LD_VAR 0 3
39637: PPUSH
39638: LD_EXP 59
39642: PUSH
39643: LD_VAR 0 1
39647: ARRAY
39648: PUSH
39649: LD_EXP 59
39653: PUSH
39654: LD_VAR 0 1
39658: ARRAY
39659: ARRAY
39660: PPUSH
39661: CALL_OW 120
// end ; exit ;
39665: GO 39986
// end ; if tmp > 1 then
39667: LD_VAR 0 8
39671: PUSH
39672: LD_INT 1
39674: GREATER
39675: IFFALSE 39779
// for i = 2 to tmp do
39677: LD_ADDR_VAR 0 6
39681: PUSH
39682: DOUBLE
39683: LD_INT 2
39685: DEC
39686: ST_TO_ADDR
39687: LD_VAR 0 8
39691: PUSH
39692: FOR_TO
39693: IFFALSE 39777
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
39695: LD_VAR 0 8
39699: PUSH
39700: LD_VAR 0 6
39704: ARRAY
39705: PPUSH
39706: CALL_OW 461
39710: PUSH
39711: LD_INT 6
39713: EQUAL
39714: IFFALSE 39775
// begin x := tmp [ i ] ;
39716: LD_ADDR_VAR 0 9
39720: PUSH
39721: LD_VAR 0 8
39725: PUSH
39726: LD_VAR 0 6
39730: ARRAY
39731: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
39732: LD_ADDR_VAR 0 8
39736: PUSH
39737: LD_VAR 0 8
39741: PPUSH
39742: LD_VAR 0 6
39746: PPUSH
39747: CALL_OW 3
39751: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
39752: LD_ADDR_VAR 0 8
39756: PUSH
39757: LD_VAR 0 8
39761: PPUSH
39762: LD_INT 1
39764: PPUSH
39765: LD_VAR 0 9
39769: PPUSH
39770: CALL_OW 2
39774: ST_TO_ADDR
// end ;
39775: GO 39692
39777: POP
39778: POP
// for i in tmp do
39779: LD_ADDR_VAR 0 6
39783: PUSH
39784: LD_VAR 0 8
39788: PUSH
39789: FOR_IN
39790: IFFALSE 39859
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
39792: LD_VAR 0 6
39796: PPUSH
39797: CALL_OW 313
39801: PUSH
39802: LD_INT 6
39804: LESS
39805: PUSH
39806: LD_VAR 0 6
39810: PPUSH
39811: CALL_OW 266
39815: PUSH
39816: LD_INT 31
39818: PUSH
39819: LD_INT 32
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: IN
39826: NOT
39827: AND
39828: PUSH
39829: LD_VAR 0 6
39833: PPUSH
39834: CALL_OW 313
39838: PUSH
39839: LD_INT 0
39841: EQUAL
39842: OR
39843: IFFALSE 39857
// begin j := i ;
39845: LD_ADDR_VAR 0 7
39849: PUSH
39850: LD_VAR 0 6
39854: ST_TO_ADDR
// break ;
39855: GO 39859
// end ; end ;
39857: GO 39789
39859: POP
39860: POP
// if j then
39861: LD_VAR 0 7
39865: IFFALSE 39883
// ComEnterUnit ( unit , j ) else
39867: LD_VAR 0 3
39871: PPUSH
39872: LD_VAR 0 7
39876: PPUSH
39877: CALL_OW 120
39881: GO 39986
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39883: LD_ADDR_VAR 0 10
39887: PUSH
39888: LD_VAR 0 2
39892: PPUSH
39893: LD_INT 2
39895: PUSH
39896: LD_INT 30
39898: PUSH
39899: LD_INT 0
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 1
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: PPUSH
39921: CALL_OW 72
39925: ST_TO_ADDR
// if depot then
39926: LD_VAR 0 10
39930: IFFALSE 39986
// begin depot := NearestUnitToUnit ( depot , unit ) ;
39932: LD_ADDR_VAR 0 10
39936: PUSH
39937: LD_VAR 0 10
39941: PPUSH
39942: LD_VAR 0 3
39946: PPUSH
39947: CALL_OW 74
39951: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
39952: LD_VAR 0 3
39956: PPUSH
39957: LD_VAR 0 10
39961: PPUSH
39962: CALL_OW 296
39966: PUSH
39967: LD_INT 10
39969: GREATER
39970: IFFALSE 39986
// ComStandNearbyBuilding ( unit , depot ) ;
39972: LD_VAR 0 3
39976: PPUSH
39977: LD_VAR 0 10
39981: PPUSH
39982: CALL 48400 0 2
// end ; end ; end ;
39986: LD_VAR 0 5
39990: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
39991: LD_INT 0
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
// if not mc_bases then
39997: LD_EXP 49
40001: NOT
40002: IFFALSE 40006
// exit ;
40004: GO 40245
// for i = 1 to mc_bases do
40006: LD_ADDR_VAR 0 2
40010: PUSH
40011: DOUBLE
40012: LD_INT 1
40014: DEC
40015: ST_TO_ADDR
40016: LD_EXP 49
40020: PUSH
40021: FOR_TO
40022: IFFALSE 40243
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40024: LD_ADDR_VAR 0 4
40028: PUSH
40029: LD_EXP 49
40033: PUSH
40034: LD_VAR 0 2
40038: ARRAY
40039: PPUSH
40040: LD_INT 21
40042: PUSH
40043: LD_INT 1
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PPUSH
40050: CALL_OW 72
40054: PUSH
40055: LD_EXP 78
40059: PUSH
40060: LD_VAR 0 2
40064: ARRAY
40065: UNION
40066: ST_TO_ADDR
// if not tmp then
40067: LD_VAR 0 4
40071: NOT
40072: IFFALSE 40076
// continue ;
40074: GO 40021
// for j in tmp do
40076: LD_ADDR_VAR 0 3
40080: PUSH
40081: LD_VAR 0 4
40085: PUSH
40086: FOR_IN
40087: IFFALSE 40239
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40089: LD_VAR 0 3
40093: PPUSH
40094: CALL_OW 110
40098: NOT
40099: PUSH
40100: LD_VAR 0 3
40104: PPUSH
40105: CALL_OW 314
40109: NOT
40110: AND
40111: PUSH
40112: LD_VAR 0 3
40116: PPUSH
40117: CALL_OW 311
40121: NOT
40122: AND
40123: PUSH
40124: LD_VAR 0 3
40128: PPUSH
40129: CALL_OW 310
40133: NOT
40134: AND
40135: PUSH
40136: LD_VAR 0 3
40140: PUSH
40141: LD_EXP 52
40145: PUSH
40146: LD_VAR 0 2
40150: ARRAY
40151: PUSH
40152: LD_INT 1
40154: ARRAY
40155: IN
40156: NOT
40157: AND
40158: PUSH
40159: LD_VAR 0 3
40163: PUSH
40164: LD_EXP 52
40168: PUSH
40169: LD_VAR 0 2
40173: ARRAY
40174: PUSH
40175: LD_INT 2
40177: ARRAY
40178: IN
40179: NOT
40180: AND
40181: PUSH
40182: LD_VAR 0 3
40186: PUSH
40187: LD_EXP 61
40191: PUSH
40192: LD_VAR 0 2
40196: ARRAY
40197: IN
40198: NOT
40199: AND
40200: IFFALSE 40237
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40202: LD_VAR 0 2
40206: PPUSH
40207: LD_EXP 49
40211: PUSH
40212: LD_VAR 0 2
40216: ARRAY
40217: PPUSH
40218: LD_VAR 0 3
40222: PPUSH
40223: LD_VAR 0 3
40227: PPUSH
40228: CALL_OW 257
40232: PPUSH
40233: CALL 39009 0 4
// end ;
40237: GO 40086
40239: POP
40240: POP
// end ;
40241: GO 40021
40243: POP
40244: POP
// end ;
40245: LD_VAR 0 1
40249: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40250: LD_INT 0
40252: PPUSH
40253: PPUSH
40254: PPUSH
40255: PPUSH
40256: PPUSH
40257: PPUSH
// if not mc_bases [ base ] then
40258: LD_EXP 49
40262: PUSH
40263: LD_VAR 0 1
40267: ARRAY
40268: NOT
40269: IFFALSE 40273
// exit ;
40271: GO 40455
// tmp := [ ] ;
40273: LD_ADDR_VAR 0 6
40277: PUSH
40278: EMPTY
40279: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40280: LD_ADDR_VAR 0 7
40284: PUSH
40285: LD_VAR 0 3
40289: PPUSH
40290: LD_INT 0
40292: PPUSH
40293: CALL_OW 517
40297: ST_TO_ADDR
// if not list then
40298: LD_VAR 0 7
40302: NOT
40303: IFFALSE 40307
// exit ;
40305: GO 40455
// for i = 1 to amount do
40307: LD_ADDR_VAR 0 5
40311: PUSH
40312: DOUBLE
40313: LD_INT 1
40315: DEC
40316: ST_TO_ADDR
40317: LD_VAR 0 2
40321: PUSH
40322: FOR_TO
40323: IFFALSE 40403
// begin x := rand ( 1 , list [ 1 ] ) ;
40325: LD_ADDR_VAR 0 8
40329: PUSH
40330: LD_INT 1
40332: PPUSH
40333: LD_VAR 0 7
40337: PUSH
40338: LD_INT 1
40340: ARRAY
40341: PPUSH
40342: CALL_OW 12
40346: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40347: LD_ADDR_VAR 0 6
40351: PUSH
40352: LD_VAR 0 6
40356: PPUSH
40357: LD_VAR 0 5
40361: PPUSH
40362: LD_VAR 0 7
40366: PUSH
40367: LD_INT 1
40369: ARRAY
40370: PUSH
40371: LD_VAR 0 8
40375: ARRAY
40376: PUSH
40377: LD_VAR 0 7
40381: PUSH
40382: LD_INT 2
40384: ARRAY
40385: PUSH
40386: LD_VAR 0 8
40390: ARRAY
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PPUSH
40396: CALL_OW 1
40400: ST_TO_ADDR
// end ;
40401: GO 40322
40403: POP
40404: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40405: LD_ADDR_EXP 62
40409: PUSH
40410: LD_EXP 62
40414: PPUSH
40415: LD_VAR 0 1
40419: PPUSH
40420: LD_VAR 0 6
40424: PPUSH
40425: CALL_OW 1
40429: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40430: LD_ADDR_EXP 64
40434: PUSH
40435: LD_EXP 64
40439: PPUSH
40440: LD_VAR 0 1
40444: PPUSH
40445: LD_VAR 0 3
40449: PPUSH
40450: CALL_OW 1
40454: ST_TO_ADDR
// end ;
40455: LD_VAR 0 4
40459: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40460: LD_INT 0
40462: PPUSH
// if not mc_bases [ base ] then
40463: LD_EXP 49
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: NOT
40474: IFFALSE 40478
// exit ;
40476: GO 40503
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40478: LD_ADDR_EXP 54
40482: PUSH
40483: LD_EXP 54
40487: PPUSH
40488: LD_VAR 0 1
40492: PPUSH
40493: LD_VAR 0 2
40497: PPUSH
40498: CALL_OW 1
40502: ST_TO_ADDR
// end ;
40503: LD_VAR 0 3
40507: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40508: LD_INT 0
40510: PPUSH
// if not mc_bases [ base ] then
40511: LD_EXP 49
40515: PUSH
40516: LD_VAR 0 1
40520: ARRAY
40521: NOT
40522: IFFALSE 40526
// exit ;
40524: GO 40563
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40526: LD_ADDR_EXP 54
40530: PUSH
40531: LD_EXP 54
40535: PPUSH
40536: LD_VAR 0 1
40540: PPUSH
40541: LD_EXP 54
40545: PUSH
40546: LD_VAR 0 1
40550: ARRAY
40551: PUSH
40552: LD_VAR 0 2
40556: UNION
40557: PPUSH
40558: CALL_OW 1
40562: ST_TO_ADDR
// end ;
40563: LD_VAR 0 3
40567: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40568: LD_INT 0
40570: PPUSH
// if not mc_bases [ base ] then
40571: LD_EXP 49
40575: PUSH
40576: LD_VAR 0 1
40580: ARRAY
40581: NOT
40582: IFFALSE 40586
// exit ;
40584: GO 40611
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40586: LD_ADDR_EXP 70
40590: PUSH
40591: LD_EXP 70
40595: PPUSH
40596: LD_VAR 0 1
40600: PPUSH
40601: LD_VAR 0 2
40605: PPUSH
40606: CALL_OW 1
40610: ST_TO_ADDR
// end ;
40611: LD_VAR 0 3
40615: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40616: LD_INT 0
40618: PPUSH
// if not mc_bases [ base ] then
40619: LD_EXP 49
40623: PUSH
40624: LD_VAR 0 1
40628: ARRAY
40629: NOT
40630: IFFALSE 40634
// exit ;
40632: GO 40671
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40634: LD_ADDR_EXP 70
40638: PUSH
40639: LD_EXP 70
40643: PPUSH
40644: LD_VAR 0 1
40648: PPUSH
40649: LD_EXP 70
40653: PUSH
40654: LD_VAR 0 1
40658: ARRAY
40659: PUSH
40660: LD_VAR 0 2
40664: ADD
40665: PPUSH
40666: CALL_OW 1
40670: ST_TO_ADDR
// end ;
40671: LD_VAR 0 3
40675: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
40676: LD_INT 0
40678: PPUSH
// if not mc_bases [ base ] then
40679: LD_EXP 49
40683: PUSH
40684: LD_VAR 0 1
40688: ARRAY
40689: NOT
40690: IFFALSE 40694
// exit ;
40692: GO 40748
// mc_defender := Replace ( mc_defender , base , deflist ) ;
40694: LD_ADDR_EXP 71
40698: PUSH
40699: LD_EXP 71
40703: PPUSH
40704: LD_VAR 0 1
40708: PPUSH
40709: LD_VAR 0 2
40713: PPUSH
40714: CALL_OW 1
40718: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
40719: LD_ADDR_EXP 60
40723: PUSH
40724: LD_EXP 60
40728: PPUSH
40729: LD_VAR 0 1
40733: PPUSH
40734: LD_VAR 0 2
40738: PUSH
40739: LD_INT 0
40741: PLUS
40742: PPUSH
40743: CALL_OW 1
40747: ST_TO_ADDR
// end ;
40748: LD_VAR 0 3
40752: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
40753: LD_INT 0
40755: PPUSH
// if not mc_bases [ base ] then
40756: LD_EXP 49
40760: PUSH
40761: LD_VAR 0 1
40765: ARRAY
40766: NOT
40767: IFFALSE 40771
// exit ;
40769: GO 40796
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
40771: LD_ADDR_EXP 60
40775: PUSH
40776: LD_EXP 60
40780: PPUSH
40781: LD_VAR 0 1
40785: PPUSH
40786: LD_VAR 0 2
40790: PPUSH
40791: CALL_OW 1
40795: ST_TO_ADDR
// end ;
40796: LD_VAR 0 3
40800: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
40801: LD_INT 0
40803: PPUSH
40804: PPUSH
40805: PPUSH
40806: PPUSH
// if not mc_bases [ base ] then
40807: LD_EXP 49
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: NOT
40818: IFFALSE 40822
// exit ;
40820: GO 40887
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
40822: LD_ADDR_EXP 69
40826: PUSH
40827: LD_EXP 69
40831: PPUSH
40832: LD_VAR 0 1
40836: PUSH
40837: LD_EXP 69
40841: PUSH
40842: LD_VAR 0 1
40846: ARRAY
40847: PUSH
40848: LD_INT 1
40850: PLUS
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PPUSH
40856: LD_VAR 0 1
40860: PUSH
40861: LD_VAR 0 2
40865: PUSH
40866: LD_VAR 0 3
40870: PUSH
40871: LD_VAR 0 4
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: PPUSH
40882: CALL 54108 0 3
40886: ST_TO_ADDR
// end ;
40887: LD_VAR 0 5
40891: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
40892: LD_INT 0
40894: PPUSH
// if not mc_bases [ base ] then
40895: LD_EXP 49
40899: PUSH
40900: LD_VAR 0 1
40904: ARRAY
40905: NOT
40906: IFFALSE 40910
// exit ;
40908: GO 40935
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
40910: LD_ADDR_EXP 86
40914: PUSH
40915: LD_EXP 86
40919: PPUSH
40920: LD_VAR 0 1
40924: PPUSH
40925: LD_VAR 0 2
40929: PPUSH
40930: CALL_OW 1
40934: ST_TO_ADDR
// end ;
40935: LD_VAR 0 3
40939: RET
// export function MC_GetMinesField ( base ) ; begin
40940: LD_INT 0
40942: PPUSH
// result := mc_mines [ base ] ;
40943: LD_ADDR_VAR 0 2
40947: PUSH
40948: LD_EXP 62
40952: PUSH
40953: LD_VAR 0 1
40957: ARRAY
40958: ST_TO_ADDR
// end ;
40959: LD_VAR 0 2
40963: RET
// export function MC_GetProduceList ( base ) ; begin
40964: LD_INT 0
40966: PPUSH
// result := mc_produce [ base ] ;
40967: LD_ADDR_VAR 0 2
40971: PUSH
40972: LD_EXP 70
40976: PUSH
40977: LD_VAR 0 1
40981: ARRAY
40982: ST_TO_ADDR
// end ;
40983: LD_VAR 0 2
40987: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
40988: LD_INT 0
40990: PPUSH
40991: PPUSH
// if not mc_bases then
40992: LD_EXP 49
40996: NOT
40997: IFFALSE 41001
// exit ;
40999: GO 41066
// if mc_bases [ base ] then
41001: LD_EXP 49
41005: PUSH
41006: LD_VAR 0 1
41010: ARRAY
41011: IFFALSE 41066
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41013: LD_ADDR_VAR 0 3
41017: PUSH
41018: LD_EXP 49
41022: PUSH
41023: LD_VAR 0 1
41027: ARRAY
41028: PPUSH
41029: LD_INT 30
41031: PUSH
41032: LD_VAR 0 2
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PPUSH
41041: CALL_OW 72
41045: ST_TO_ADDR
// if result then
41046: LD_VAR 0 3
41050: IFFALSE 41066
// result := result [ 1 ] ;
41052: LD_ADDR_VAR 0 3
41056: PUSH
41057: LD_VAR 0 3
41061: PUSH
41062: LD_INT 1
41064: ARRAY
41065: ST_TO_ADDR
// end ; end ;
41066: LD_VAR 0 3
41070: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41071: LD_INT 0
41073: PPUSH
41074: PPUSH
// if not mc_bases then
41075: LD_EXP 49
41079: NOT
41080: IFFALSE 41084
// exit ;
41082: GO 41129
// if mc_bases [ base ] then
41084: LD_EXP 49
41088: PUSH
41089: LD_VAR 0 1
41093: ARRAY
41094: IFFALSE 41129
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41096: LD_ADDR_VAR 0 3
41100: PUSH
41101: LD_EXP 49
41105: PUSH
41106: LD_VAR 0 1
41110: ARRAY
41111: PPUSH
41112: LD_INT 30
41114: PUSH
41115: LD_VAR 0 2
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PPUSH
41124: CALL_OW 72
41128: ST_TO_ADDR
// end ;
41129: LD_VAR 0 3
41133: RET
// export function MC_SetTame ( base , area ) ; begin
41134: LD_INT 0
41136: PPUSH
// if not mc_bases or not base then
41137: LD_EXP 49
41141: NOT
41142: PUSH
41143: LD_VAR 0 1
41147: NOT
41148: OR
41149: IFFALSE 41153
// exit ;
41151: GO 41178
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41153: LD_ADDR_EXP 77
41157: PUSH
41158: LD_EXP 77
41162: PPUSH
41163: LD_VAR 0 1
41167: PPUSH
41168: LD_VAR 0 2
41172: PPUSH
41173: CALL_OW 1
41177: ST_TO_ADDR
// end ;
41178: LD_VAR 0 3
41182: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41183: LD_INT 0
41185: PPUSH
41186: PPUSH
// if not mc_bases or not base then
41187: LD_EXP 49
41191: NOT
41192: PUSH
41193: LD_VAR 0 1
41197: NOT
41198: OR
41199: IFFALSE 41203
// exit ;
41201: GO 41305
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41203: LD_ADDR_VAR 0 4
41207: PUSH
41208: LD_EXP 49
41212: PUSH
41213: LD_VAR 0 1
41217: ARRAY
41218: PPUSH
41219: LD_INT 30
41221: PUSH
41222: LD_VAR 0 2
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PPUSH
41231: CALL_OW 72
41235: ST_TO_ADDR
// if not tmp then
41236: LD_VAR 0 4
41240: NOT
41241: IFFALSE 41245
// exit ;
41243: GO 41305
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41245: LD_ADDR_EXP 81
41249: PUSH
41250: LD_EXP 81
41254: PPUSH
41255: LD_VAR 0 1
41259: PPUSH
41260: LD_EXP 81
41264: PUSH
41265: LD_VAR 0 1
41269: ARRAY
41270: PPUSH
41271: LD_EXP 81
41275: PUSH
41276: LD_VAR 0 1
41280: ARRAY
41281: PUSH
41282: LD_INT 1
41284: PLUS
41285: PPUSH
41286: LD_VAR 0 4
41290: PUSH
41291: LD_INT 1
41293: ARRAY
41294: PPUSH
41295: CALL_OW 2
41299: PPUSH
41300: CALL_OW 1
41304: ST_TO_ADDR
// end ;
41305: LD_VAR 0 3
41309: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41310: LD_INT 0
41312: PPUSH
41313: PPUSH
// if not mc_bases or not base or not kinds then
41314: LD_EXP 49
41318: NOT
41319: PUSH
41320: LD_VAR 0 1
41324: NOT
41325: OR
41326: PUSH
41327: LD_VAR 0 2
41331: NOT
41332: OR
41333: IFFALSE 41337
// exit ;
41335: GO 41398
// for i in kinds do
41337: LD_ADDR_VAR 0 4
41341: PUSH
41342: LD_VAR 0 2
41346: PUSH
41347: FOR_IN
41348: IFFALSE 41396
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41350: LD_ADDR_EXP 83
41354: PUSH
41355: LD_EXP 83
41359: PPUSH
41360: LD_VAR 0 1
41364: PUSH
41365: LD_EXP 83
41369: PUSH
41370: LD_VAR 0 1
41374: ARRAY
41375: PUSH
41376: LD_INT 1
41378: PLUS
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PPUSH
41384: LD_VAR 0 4
41388: PPUSH
41389: CALL 54108 0 3
41393: ST_TO_ADDR
41394: GO 41347
41396: POP
41397: POP
// end ;
41398: LD_VAR 0 3
41402: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41403: LD_INT 0
41405: PPUSH
// if not mc_bases or not base or not areas then
41406: LD_EXP 49
41410: NOT
41411: PUSH
41412: LD_VAR 0 1
41416: NOT
41417: OR
41418: PUSH
41419: LD_VAR 0 2
41423: NOT
41424: OR
41425: IFFALSE 41429
// exit ;
41427: GO 41454
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41429: LD_ADDR_EXP 67
41433: PUSH
41434: LD_EXP 67
41438: PPUSH
41439: LD_VAR 0 1
41443: PPUSH
41444: LD_VAR 0 2
41448: PPUSH
41449: CALL_OW 1
41453: ST_TO_ADDR
// end ;
41454: LD_VAR 0 3
41458: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41459: LD_INT 0
41461: PPUSH
// if not mc_bases or not base or not teleports_exit then
41462: LD_EXP 49
41466: NOT
41467: PUSH
41468: LD_VAR 0 1
41472: NOT
41473: OR
41474: PUSH
41475: LD_VAR 0 2
41479: NOT
41480: OR
41481: IFFALSE 41485
// exit ;
41483: GO 41510
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41485: LD_ADDR_EXP 84
41489: PUSH
41490: LD_EXP 84
41494: PPUSH
41495: LD_VAR 0 1
41499: PPUSH
41500: LD_VAR 0 2
41504: PPUSH
41505: CALL_OW 1
41509: ST_TO_ADDR
// end ;
41510: LD_VAR 0 3
41514: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41515: LD_INT 0
41517: PPUSH
41518: PPUSH
41519: PPUSH
// if not mc_bases or not base or not ext_list then
41520: LD_EXP 49
41524: NOT
41525: PUSH
41526: LD_VAR 0 1
41530: NOT
41531: OR
41532: PUSH
41533: LD_VAR 0 5
41537: NOT
41538: OR
41539: IFFALSE 41543
// exit ;
41541: GO 41716
// tmp := GetFacExtXYD ( x , y , d ) ;
41543: LD_ADDR_VAR 0 8
41547: PUSH
41548: LD_VAR 0 2
41552: PPUSH
41553: LD_VAR 0 3
41557: PPUSH
41558: LD_VAR 0 4
41562: PPUSH
41563: CALL 87486 0 3
41567: ST_TO_ADDR
// if not tmp then
41568: LD_VAR 0 8
41572: NOT
41573: IFFALSE 41577
// exit ;
41575: GO 41716
// for i in tmp do
41577: LD_ADDR_VAR 0 7
41581: PUSH
41582: LD_VAR 0 8
41586: PUSH
41587: FOR_IN
41588: IFFALSE 41714
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41590: LD_ADDR_EXP 54
41594: PUSH
41595: LD_EXP 54
41599: PPUSH
41600: LD_VAR 0 1
41604: PPUSH
41605: LD_EXP 54
41609: PUSH
41610: LD_VAR 0 1
41614: ARRAY
41615: PPUSH
41616: LD_EXP 54
41620: PUSH
41621: LD_VAR 0 1
41625: ARRAY
41626: PUSH
41627: LD_INT 1
41629: PLUS
41630: PPUSH
41631: LD_VAR 0 5
41635: PUSH
41636: LD_INT 1
41638: ARRAY
41639: PUSH
41640: LD_VAR 0 7
41644: PUSH
41645: LD_INT 1
41647: ARRAY
41648: PUSH
41649: LD_VAR 0 7
41653: PUSH
41654: LD_INT 2
41656: ARRAY
41657: PUSH
41658: LD_VAR 0 7
41662: PUSH
41663: LD_INT 3
41665: ARRAY
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: PPUSH
41673: CALL_OW 2
41677: PPUSH
41678: CALL_OW 1
41682: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
41683: LD_ADDR_VAR 0 5
41687: PUSH
41688: LD_VAR 0 5
41692: PPUSH
41693: LD_INT 1
41695: PPUSH
41696: CALL_OW 3
41700: ST_TO_ADDR
// if not ext_list then
41701: LD_VAR 0 5
41705: NOT
41706: IFFALSE 41712
// exit ;
41708: POP
41709: POP
41710: GO 41716
// end ;
41712: GO 41587
41714: POP
41715: POP
// end ;
41716: LD_VAR 0 6
41720: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
41721: LD_INT 0
41723: PPUSH
// if not mc_bases or not base or not weapon_list then
41724: LD_EXP 49
41728: NOT
41729: PUSH
41730: LD_VAR 0 1
41734: NOT
41735: OR
41736: PUSH
41737: LD_VAR 0 2
41741: NOT
41742: OR
41743: IFFALSE 41747
// exit ;
41745: GO 41772
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
41747: LD_ADDR_EXP 88
41751: PUSH
41752: LD_EXP 88
41756: PPUSH
41757: LD_VAR 0 1
41761: PPUSH
41762: LD_VAR 0 2
41766: PPUSH
41767: CALL_OW 1
41771: ST_TO_ADDR
// end ;
41772: LD_VAR 0 3
41776: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
41777: LD_INT 0
41779: PPUSH
// if not mc_bases or not base or not tech_list then
41780: LD_EXP 49
41784: NOT
41785: PUSH
41786: LD_VAR 0 1
41790: NOT
41791: OR
41792: PUSH
41793: LD_VAR 0 2
41797: NOT
41798: OR
41799: IFFALSE 41803
// exit ;
41801: GO 41828
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
41803: LD_ADDR_EXP 76
41807: PUSH
41808: LD_EXP 76
41812: PPUSH
41813: LD_VAR 0 1
41817: PPUSH
41818: LD_VAR 0 2
41822: PPUSH
41823: CALL_OW 1
41827: ST_TO_ADDR
// end ;
41828: LD_VAR 0 3
41832: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
41833: LD_INT 0
41835: PPUSH
// if not mc_bases or not parking_area or not base then
41836: LD_EXP 49
41840: NOT
41841: PUSH
41842: LD_VAR 0 2
41846: NOT
41847: OR
41848: PUSH
41849: LD_VAR 0 1
41853: NOT
41854: OR
41855: IFFALSE 41859
// exit ;
41857: GO 41884
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
41859: LD_ADDR_EXP 73
41863: PUSH
41864: LD_EXP 73
41868: PPUSH
41869: LD_VAR 0 1
41873: PPUSH
41874: LD_VAR 0 2
41878: PPUSH
41879: CALL_OW 1
41883: ST_TO_ADDR
// end ;
41884: LD_VAR 0 3
41888: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
41889: LD_INT 0
41891: PPUSH
// if not mc_bases or not base or not scan_area then
41892: LD_EXP 49
41896: NOT
41897: PUSH
41898: LD_VAR 0 1
41902: NOT
41903: OR
41904: PUSH
41905: LD_VAR 0 2
41909: NOT
41910: OR
41911: IFFALSE 41915
// exit ;
41913: GO 41940
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
41915: LD_ADDR_EXP 74
41919: PUSH
41920: LD_EXP 74
41924: PPUSH
41925: LD_VAR 0 1
41929: PPUSH
41930: LD_VAR 0 2
41934: PPUSH
41935: CALL_OW 1
41939: ST_TO_ADDR
// end ;
41940: LD_VAR 0 3
41944: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
41945: LD_INT 0
41947: PPUSH
41948: PPUSH
// if not mc_bases or not base then
41949: LD_EXP 49
41953: NOT
41954: PUSH
41955: LD_VAR 0 1
41959: NOT
41960: OR
41961: IFFALSE 41965
// exit ;
41963: GO 42029
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
41965: LD_ADDR_VAR 0 3
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: LD_INT 2
41975: PUSH
41976: LD_INT 3
41978: PUSH
41979: LD_INT 4
41981: PUSH
41982: LD_INT 11
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: LIST
41989: LIST
41990: LIST
41991: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
41992: LD_ADDR_EXP 76
41996: PUSH
41997: LD_EXP 76
42001: PPUSH
42002: LD_VAR 0 1
42006: PPUSH
42007: LD_EXP 76
42011: PUSH
42012: LD_VAR 0 1
42016: ARRAY
42017: PUSH
42018: LD_VAR 0 3
42022: DIFF
42023: PPUSH
42024: CALL_OW 1
42028: ST_TO_ADDR
// end ;
42029: LD_VAR 0 2
42033: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42034: LD_INT 0
42036: PPUSH
// result := mc_vehicles [ base ] ;
42037: LD_ADDR_VAR 0 3
42041: PUSH
42042: LD_EXP 68
42046: PUSH
42047: LD_VAR 0 1
42051: ARRAY
42052: ST_TO_ADDR
// if onlyCombat then
42053: LD_VAR 0 2
42057: IFFALSE 42222
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: LD_VAR 0 3
42068: PUSH
42069: LD_VAR 0 3
42073: PPUSH
42074: LD_INT 2
42076: PUSH
42077: LD_INT 34
42079: PUSH
42080: LD_INT 12
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 34
42089: PUSH
42090: LD_INT 51
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 34
42099: PUSH
42100: LD_EXP 93
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 34
42111: PUSH
42112: LD_INT 32
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 34
42121: PUSH
42122: LD_INT 13
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 34
42131: PUSH
42132: LD_INT 52
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 34
42141: PUSH
42142: LD_INT 14
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 34
42151: PUSH
42152: LD_INT 53
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 34
42161: PUSH
42162: LD_EXP 92
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 34
42173: PUSH
42174: LD_INT 31
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 34
42183: PUSH
42184: LD_INT 48
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 34
42193: PUSH
42194: LD_INT 8
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: PPUSH
42216: CALL_OW 72
42220: DIFF
42221: ST_TO_ADDR
// end ; end_of_file
42222: LD_VAR 0 3
42226: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42227: LD_INT 0
42229: PPUSH
42230: PPUSH
42231: PPUSH
// if not mc_bases or not skirmish then
42232: LD_EXP 49
42236: NOT
42237: PUSH
42238: LD_EXP 47
42242: NOT
42243: OR
42244: IFFALSE 42248
// exit ;
42246: GO 42413
// for i = 1 to mc_bases do
42248: LD_ADDR_VAR 0 4
42252: PUSH
42253: DOUBLE
42254: LD_INT 1
42256: DEC
42257: ST_TO_ADDR
42258: LD_EXP 49
42262: PUSH
42263: FOR_TO
42264: IFFALSE 42411
// begin if sci in mc_bases [ i ] then
42266: LD_VAR 0 2
42270: PUSH
42271: LD_EXP 49
42275: PUSH
42276: LD_VAR 0 4
42280: ARRAY
42281: IN
42282: IFFALSE 42409
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42284: LD_ADDR_EXP 78
42288: PUSH
42289: LD_EXP 78
42293: PPUSH
42294: LD_VAR 0 4
42298: PUSH
42299: LD_EXP 78
42303: PUSH
42304: LD_VAR 0 4
42308: ARRAY
42309: PUSH
42310: LD_INT 1
42312: PLUS
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: LD_VAR 0 1
42322: PPUSH
42323: CALL 54108 0 3
42327: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42328: LD_ADDR_VAR 0 5
42332: PUSH
42333: LD_EXP 49
42337: PUSH
42338: LD_VAR 0 4
42342: ARRAY
42343: PPUSH
42344: LD_INT 2
42346: PUSH
42347: LD_INT 30
42349: PUSH
42350: LD_INT 0
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 30
42359: PUSH
42360: LD_INT 1
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: LIST
42371: PPUSH
42372: CALL_OW 72
42376: PPUSH
42377: LD_VAR 0 1
42381: PPUSH
42382: CALL_OW 74
42386: ST_TO_ADDR
// if tmp then
42387: LD_VAR 0 5
42391: IFFALSE 42407
// ComStandNearbyBuilding ( ape , tmp ) ;
42393: LD_VAR 0 1
42397: PPUSH
42398: LD_VAR 0 5
42402: PPUSH
42403: CALL 48400 0 2
// break ;
42407: GO 42411
// end ; end ;
42409: GO 42263
42411: POP
42412: POP
// end ;
42413: LD_VAR 0 3
42417: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42418: LD_INT 0
42420: PPUSH
42421: PPUSH
42422: PPUSH
// if not mc_bases or not skirmish then
42423: LD_EXP 49
42427: NOT
42428: PUSH
42429: LD_EXP 47
42433: NOT
42434: OR
42435: IFFALSE 42439
// exit ;
42437: GO 42528
// for i = 1 to mc_bases do
42439: LD_ADDR_VAR 0 4
42443: PUSH
42444: DOUBLE
42445: LD_INT 1
42447: DEC
42448: ST_TO_ADDR
42449: LD_EXP 49
42453: PUSH
42454: FOR_TO
42455: IFFALSE 42526
// begin if building in mc_busy_turret_list [ i ] then
42457: LD_VAR 0 1
42461: PUSH
42462: LD_EXP 59
42466: PUSH
42467: LD_VAR 0 4
42471: ARRAY
42472: IN
42473: IFFALSE 42524
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42475: LD_ADDR_VAR 0 5
42479: PUSH
42480: LD_EXP 59
42484: PUSH
42485: LD_VAR 0 4
42489: ARRAY
42490: PUSH
42491: LD_VAR 0 1
42495: DIFF
42496: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42497: LD_ADDR_EXP 59
42501: PUSH
42502: LD_EXP 59
42506: PPUSH
42507: LD_VAR 0 4
42511: PPUSH
42512: LD_VAR 0 5
42516: PPUSH
42517: CALL_OW 1
42521: ST_TO_ADDR
// break ;
42522: GO 42526
// end ; end ;
42524: GO 42454
42526: POP
42527: POP
// end ;
42528: LD_VAR 0 3
42532: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42533: LD_INT 0
42535: PPUSH
42536: PPUSH
42537: PPUSH
// if not mc_bases or not skirmish then
42538: LD_EXP 49
42542: NOT
42543: PUSH
42544: LD_EXP 47
42548: NOT
42549: OR
42550: IFFALSE 42554
// exit ;
42552: GO 42753
// for i = 1 to mc_bases do
42554: LD_ADDR_VAR 0 5
42558: PUSH
42559: DOUBLE
42560: LD_INT 1
42562: DEC
42563: ST_TO_ADDR
42564: LD_EXP 49
42568: PUSH
42569: FOR_TO
42570: IFFALSE 42751
// if building in mc_bases [ i ] then
42572: LD_VAR 0 1
42576: PUSH
42577: LD_EXP 49
42581: PUSH
42582: LD_VAR 0 5
42586: ARRAY
42587: IN
42588: IFFALSE 42749
// begin tmp := mc_bases [ i ] diff building ;
42590: LD_ADDR_VAR 0 6
42594: PUSH
42595: LD_EXP 49
42599: PUSH
42600: LD_VAR 0 5
42604: ARRAY
42605: PUSH
42606: LD_VAR 0 1
42610: DIFF
42611: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42612: LD_ADDR_EXP 49
42616: PUSH
42617: LD_EXP 49
42621: PPUSH
42622: LD_VAR 0 5
42626: PPUSH
42627: LD_VAR 0 6
42631: PPUSH
42632: CALL_OW 1
42636: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42637: LD_VAR 0 1
42641: PUSH
42642: LD_EXP 57
42646: PUSH
42647: LD_VAR 0 5
42651: ARRAY
42652: IN
42653: IFFALSE 42692
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
42655: LD_ADDR_EXP 57
42659: PUSH
42660: LD_EXP 57
42664: PPUSH
42665: LD_VAR 0 5
42669: PPUSH
42670: LD_EXP 57
42674: PUSH
42675: LD_VAR 0 5
42679: ARRAY
42680: PUSH
42681: LD_VAR 0 1
42685: DIFF
42686: PPUSH
42687: CALL_OW 1
42691: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
42692: LD_VAR 0 1
42696: PUSH
42697: LD_EXP 58
42701: PUSH
42702: LD_VAR 0 5
42706: ARRAY
42707: IN
42708: IFFALSE 42747
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
42710: LD_ADDR_EXP 58
42714: PUSH
42715: LD_EXP 58
42719: PPUSH
42720: LD_VAR 0 5
42724: PPUSH
42725: LD_EXP 58
42729: PUSH
42730: LD_VAR 0 5
42734: ARRAY
42735: PUSH
42736: LD_VAR 0 1
42740: DIFF
42741: PPUSH
42742: CALL_OW 1
42746: ST_TO_ADDR
// break ;
42747: GO 42751
// end ;
42749: GO 42569
42751: POP
42752: POP
// end ;
42753: LD_VAR 0 4
42757: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
42758: LD_INT 0
42760: PPUSH
42761: PPUSH
42762: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
42763: LD_EXP 49
42767: NOT
42768: PUSH
42769: LD_EXP 47
42773: NOT
42774: OR
42775: PUSH
42776: LD_VAR 0 3
42780: PUSH
42781: LD_EXP 75
42785: IN
42786: NOT
42787: OR
42788: IFFALSE 42792
// exit ;
42790: GO 42915
// for i = 1 to mc_vehicles do
42792: LD_ADDR_VAR 0 6
42796: PUSH
42797: DOUBLE
42798: LD_INT 1
42800: DEC
42801: ST_TO_ADDR
42802: LD_EXP 68
42806: PUSH
42807: FOR_TO
42808: IFFALSE 42913
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
42810: LD_VAR 0 2
42814: PUSH
42815: LD_EXP 68
42819: PUSH
42820: LD_VAR 0 6
42824: ARRAY
42825: IN
42826: PUSH
42827: LD_VAR 0 1
42831: PUSH
42832: LD_EXP 68
42836: PUSH
42837: LD_VAR 0 6
42841: ARRAY
42842: IN
42843: OR
42844: IFFALSE 42911
// begin tmp := mc_vehicles [ i ] diff old ;
42846: LD_ADDR_VAR 0 7
42850: PUSH
42851: LD_EXP 68
42855: PUSH
42856: LD_VAR 0 6
42860: ARRAY
42861: PUSH
42862: LD_VAR 0 2
42866: DIFF
42867: ST_TO_ADDR
// tmp := tmp diff new ;
42868: LD_ADDR_VAR 0 7
42872: PUSH
42873: LD_VAR 0 7
42877: PUSH
42878: LD_VAR 0 1
42882: DIFF
42883: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
42884: LD_ADDR_EXP 68
42888: PUSH
42889: LD_EXP 68
42893: PPUSH
42894: LD_VAR 0 6
42898: PPUSH
42899: LD_VAR 0 7
42903: PPUSH
42904: CALL_OW 1
42908: ST_TO_ADDR
// break ;
42909: GO 42913
// end ;
42911: GO 42807
42913: POP
42914: POP
// end ;
42915: LD_VAR 0 5
42919: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
42920: LD_INT 0
42922: PPUSH
42923: PPUSH
42924: PPUSH
42925: PPUSH
// if not mc_bases or not skirmish then
42926: LD_EXP 49
42930: NOT
42931: PUSH
42932: LD_EXP 47
42936: NOT
42937: OR
42938: IFFALSE 42942
// exit ;
42940: GO 43319
// side := GetSide ( vehicle ) ;
42942: LD_ADDR_VAR 0 5
42946: PUSH
42947: LD_VAR 0 1
42951: PPUSH
42952: CALL_OW 255
42956: ST_TO_ADDR
// for i = 1 to mc_bases do
42957: LD_ADDR_VAR 0 4
42961: PUSH
42962: DOUBLE
42963: LD_INT 1
42965: DEC
42966: ST_TO_ADDR
42967: LD_EXP 49
42971: PUSH
42972: FOR_TO
42973: IFFALSE 43317
// begin if factory in mc_bases [ i ] then
42975: LD_VAR 0 2
42979: PUSH
42980: LD_EXP 49
42984: PUSH
42985: LD_VAR 0 4
42989: ARRAY
42990: IN
42991: IFFALSE 43315
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
42993: LD_EXP 71
42997: PUSH
42998: LD_VAR 0 4
43002: ARRAY
43003: PUSH
43004: LD_EXP 60
43008: PUSH
43009: LD_VAR 0 4
43013: ARRAY
43014: LESS
43015: PUSH
43016: LD_VAR 0 1
43020: PPUSH
43021: CALL_OW 264
43025: PUSH
43026: LD_INT 31
43028: PUSH
43029: LD_INT 32
43031: PUSH
43032: LD_INT 51
43034: PUSH
43035: LD_EXP 93
43039: PUSH
43040: LD_INT 12
43042: PUSH
43043: LD_INT 30
43045: PUSH
43046: LD_EXP 92
43050: PUSH
43051: LD_INT 11
43053: PUSH
43054: LD_INT 53
43056: PUSH
43057: LD_INT 14
43059: PUSH
43060: LD_EXP 96
43064: PUSH
43065: LD_INT 29
43067: PUSH
43068: LD_EXP 94
43072: PUSH
43073: LD_INT 13
43075: PUSH
43076: LD_INT 52
43078: PUSH
43079: LD_INT 48
43081: PUSH
43082: LD_INT 8
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: LIST
43089: LIST
43090: LIST
43091: LIST
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: IN
43104: NOT
43105: AND
43106: IFFALSE 43154
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43108: LD_ADDR_EXP 71
43112: PUSH
43113: LD_EXP 71
43117: PPUSH
43118: LD_VAR 0 4
43122: PUSH
43123: LD_EXP 71
43127: PUSH
43128: LD_VAR 0 4
43132: ARRAY
43133: PUSH
43134: LD_INT 1
43136: PLUS
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PPUSH
43142: LD_VAR 0 1
43146: PPUSH
43147: CALL 54108 0 3
43151: ST_TO_ADDR
43152: GO 43198
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43154: LD_ADDR_EXP 68
43158: PUSH
43159: LD_EXP 68
43163: PPUSH
43164: LD_VAR 0 4
43168: PUSH
43169: LD_EXP 68
43173: PUSH
43174: LD_VAR 0 4
43178: ARRAY
43179: PUSH
43180: LD_INT 1
43182: PLUS
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PPUSH
43188: LD_VAR 0 1
43192: PPUSH
43193: CALL 54108 0 3
43197: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43198: LD_VAR 0 1
43202: PPUSH
43203: CALL_OW 263
43207: PUSH
43208: LD_INT 2
43210: EQUAL
43211: IFFALSE 43231
// begin repeat wait ( 0 0$1 ) ;
43213: LD_INT 35
43215: PPUSH
43216: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43220: LD_VAR 0 1
43224: PPUSH
43225: CALL_OW 312
43229: IFFALSE 43213
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43231: LD_VAR 0 1
43235: PPUSH
43236: LD_EXP 73
43240: PUSH
43241: LD_VAR 0 4
43245: ARRAY
43246: PPUSH
43247: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43251: LD_VAR 0 1
43255: PPUSH
43256: CALL_OW 263
43260: PUSH
43261: LD_INT 1
43263: NONEQUAL
43264: IFFALSE 43268
// break ;
43266: GO 43317
// repeat wait ( 0 0$1 ) ;
43268: LD_INT 35
43270: PPUSH
43271: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43275: LD_VAR 0 1
43279: PPUSH
43280: LD_EXP 73
43284: PUSH
43285: LD_VAR 0 4
43289: ARRAY
43290: PPUSH
43291: CALL_OW 308
43295: IFFALSE 43268
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43297: LD_VAR 0 1
43301: PPUSH
43302: CALL_OW 311
43306: PPUSH
43307: CALL_OW 121
// exit ;
43311: POP
43312: POP
43313: GO 43319
// end ; end ;
43315: GO 42972
43317: POP
43318: POP
// end ;
43319: LD_VAR 0 3
43323: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43324: LD_INT 0
43326: PPUSH
43327: PPUSH
43328: PPUSH
43329: PPUSH
// if not mc_bases or not skirmish then
43330: LD_EXP 49
43334: NOT
43335: PUSH
43336: LD_EXP 47
43340: NOT
43341: OR
43342: IFFALSE 43346
// exit ;
43344: GO 43699
// repeat wait ( 0 0$1 ) ;
43346: LD_INT 35
43348: PPUSH
43349: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43353: LD_VAR 0 2
43357: PPUSH
43358: LD_VAR 0 3
43362: PPUSH
43363: CALL_OW 284
43367: IFFALSE 43346
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43369: LD_VAR 0 2
43373: PPUSH
43374: LD_VAR 0 3
43378: PPUSH
43379: CALL_OW 283
43383: PUSH
43384: LD_INT 4
43386: EQUAL
43387: IFFALSE 43391
// exit ;
43389: GO 43699
// for i = 1 to mc_bases do
43391: LD_ADDR_VAR 0 7
43395: PUSH
43396: DOUBLE
43397: LD_INT 1
43399: DEC
43400: ST_TO_ADDR
43401: LD_EXP 49
43405: PUSH
43406: FOR_TO
43407: IFFALSE 43697
// begin if mc_crates_area [ i ] then
43409: LD_EXP 67
43413: PUSH
43414: LD_VAR 0 7
43418: ARRAY
43419: IFFALSE 43530
// for j in mc_crates_area [ i ] do
43421: LD_ADDR_VAR 0 8
43425: PUSH
43426: LD_EXP 67
43430: PUSH
43431: LD_VAR 0 7
43435: ARRAY
43436: PUSH
43437: FOR_IN
43438: IFFALSE 43528
// if InArea ( x , y , j ) then
43440: LD_VAR 0 2
43444: PPUSH
43445: LD_VAR 0 3
43449: PPUSH
43450: LD_VAR 0 8
43454: PPUSH
43455: CALL_OW 309
43459: IFFALSE 43526
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43461: LD_ADDR_EXP 65
43465: PUSH
43466: LD_EXP 65
43470: PPUSH
43471: LD_VAR 0 7
43475: PUSH
43476: LD_EXP 65
43480: PUSH
43481: LD_VAR 0 7
43485: ARRAY
43486: PUSH
43487: LD_INT 1
43489: PLUS
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PPUSH
43495: LD_VAR 0 4
43499: PUSH
43500: LD_VAR 0 2
43504: PUSH
43505: LD_VAR 0 3
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: LIST
43514: PPUSH
43515: CALL 54108 0 3
43519: ST_TO_ADDR
// exit ;
43520: POP
43521: POP
43522: POP
43523: POP
43524: GO 43699
// end ;
43526: GO 43437
43528: POP
43529: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43530: LD_ADDR_VAR 0 9
43534: PUSH
43535: LD_EXP 49
43539: PUSH
43540: LD_VAR 0 7
43544: ARRAY
43545: PPUSH
43546: LD_INT 2
43548: PUSH
43549: LD_INT 30
43551: PUSH
43552: LD_INT 0
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 30
43561: PUSH
43562: LD_INT 1
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: LIST
43573: PPUSH
43574: CALL_OW 72
43578: ST_TO_ADDR
// if not depot then
43579: LD_VAR 0 9
43583: NOT
43584: IFFALSE 43588
// continue ;
43586: GO 43406
// for j in depot do
43588: LD_ADDR_VAR 0 8
43592: PUSH
43593: LD_VAR 0 9
43597: PUSH
43598: FOR_IN
43599: IFFALSE 43693
// if GetDistUnitXY ( j , x , y ) < 30 then
43601: LD_VAR 0 8
43605: PPUSH
43606: LD_VAR 0 2
43610: PPUSH
43611: LD_VAR 0 3
43615: PPUSH
43616: CALL_OW 297
43620: PUSH
43621: LD_INT 30
43623: LESS
43624: IFFALSE 43691
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43626: LD_ADDR_EXP 65
43630: PUSH
43631: LD_EXP 65
43635: PPUSH
43636: LD_VAR 0 7
43640: PUSH
43641: LD_EXP 65
43645: PUSH
43646: LD_VAR 0 7
43650: ARRAY
43651: PUSH
43652: LD_INT 1
43654: PLUS
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PPUSH
43660: LD_VAR 0 4
43664: PUSH
43665: LD_VAR 0 2
43669: PUSH
43670: LD_VAR 0 3
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: LIST
43679: PPUSH
43680: CALL 54108 0 3
43684: ST_TO_ADDR
// exit ;
43685: POP
43686: POP
43687: POP
43688: POP
43689: GO 43699
// end ;
43691: GO 43598
43693: POP
43694: POP
// end ;
43695: GO 43406
43697: POP
43698: POP
// end ;
43699: LD_VAR 0 6
43703: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
43704: LD_INT 0
43706: PPUSH
43707: PPUSH
43708: PPUSH
43709: PPUSH
// if not mc_bases or not skirmish then
43710: LD_EXP 49
43714: NOT
43715: PUSH
43716: LD_EXP 47
43720: NOT
43721: OR
43722: IFFALSE 43726
// exit ;
43724: GO 44003
// side := GetSide ( lab ) ;
43726: LD_ADDR_VAR 0 4
43730: PUSH
43731: LD_VAR 0 2
43735: PPUSH
43736: CALL_OW 255
43740: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
43741: LD_VAR 0 4
43745: PUSH
43746: LD_EXP 75
43750: IN
43751: NOT
43752: PUSH
43753: LD_EXP 76
43757: NOT
43758: OR
43759: PUSH
43760: LD_EXP 49
43764: NOT
43765: OR
43766: IFFALSE 43770
// exit ;
43768: GO 44003
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
43770: LD_ADDR_EXP 76
43774: PUSH
43775: LD_EXP 76
43779: PPUSH
43780: LD_VAR 0 4
43784: PPUSH
43785: LD_EXP 76
43789: PUSH
43790: LD_VAR 0 4
43794: ARRAY
43795: PUSH
43796: LD_VAR 0 1
43800: DIFF
43801: PPUSH
43802: CALL_OW 1
43806: ST_TO_ADDR
// for i = 1 to mc_bases do
43807: LD_ADDR_VAR 0 5
43811: PUSH
43812: DOUBLE
43813: LD_INT 1
43815: DEC
43816: ST_TO_ADDR
43817: LD_EXP 49
43821: PUSH
43822: FOR_TO
43823: IFFALSE 44001
// begin if lab in mc_bases [ i ] then
43825: LD_VAR 0 2
43829: PUSH
43830: LD_EXP 49
43834: PUSH
43835: LD_VAR 0 5
43839: ARRAY
43840: IN
43841: IFFALSE 43999
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
43843: LD_VAR 0 1
43847: PUSH
43848: LD_INT 11
43850: PUSH
43851: LD_INT 4
43853: PUSH
43854: LD_INT 3
43856: PUSH
43857: LD_INT 2
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: IN
43866: PUSH
43867: LD_EXP 79
43871: PUSH
43872: LD_VAR 0 5
43876: ARRAY
43877: AND
43878: IFFALSE 43999
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
43880: LD_ADDR_VAR 0 6
43884: PUSH
43885: LD_EXP 79
43889: PUSH
43890: LD_VAR 0 5
43894: ARRAY
43895: PUSH
43896: LD_INT 1
43898: ARRAY
43899: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
43900: LD_ADDR_EXP 79
43904: PUSH
43905: LD_EXP 79
43909: PPUSH
43910: LD_VAR 0 5
43914: PPUSH
43915: EMPTY
43916: PPUSH
43917: CALL_OW 1
43921: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
43922: LD_VAR 0 6
43926: PPUSH
43927: LD_INT 0
43929: PPUSH
43930: CALL_OW 109
// ComExitBuilding ( tmp ) ;
43934: LD_VAR 0 6
43938: PPUSH
43939: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
43943: LD_ADDR_EXP 78
43947: PUSH
43948: LD_EXP 78
43952: PPUSH
43953: LD_VAR 0 5
43957: PPUSH
43958: LD_EXP 78
43962: PUSH
43963: LD_VAR 0 5
43967: ARRAY
43968: PPUSH
43969: LD_INT 1
43971: PPUSH
43972: LD_VAR 0 6
43976: PPUSH
43977: CALL_OW 2
43981: PPUSH
43982: CALL_OW 1
43986: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
43987: LD_VAR 0 5
43991: PPUSH
43992: LD_INT 112
43994: PPUSH
43995: CALL 20895 0 2
// end ; end ; end ;
43999: GO 43822
44001: POP
44002: POP
// end ;
44003: LD_VAR 0 3
44007: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
44012: PPUSH
44013: PPUSH
44014: PPUSH
44015: PPUSH
44016: PPUSH
44017: PPUSH
// if not mc_bases or not skirmish then
44018: LD_EXP 49
44022: NOT
44023: PUSH
44024: LD_EXP 47
44028: NOT
44029: OR
44030: IFFALSE 44034
// exit ;
44032: GO 45405
// for i = 1 to mc_bases do
44034: LD_ADDR_VAR 0 3
44038: PUSH
44039: DOUBLE
44040: LD_INT 1
44042: DEC
44043: ST_TO_ADDR
44044: LD_EXP 49
44048: PUSH
44049: FOR_TO
44050: IFFALSE 45403
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44052: LD_VAR 0 1
44056: PUSH
44057: LD_EXP 49
44061: PUSH
44062: LD_VAR 0 3
44066: ARRAY
44067: IN
44068: PUSH
44069: LD_VAR 0 1
44073: PUSH
44074: LD_EXP 56
44078: PUSH
44079: LD_VAR 0 3
44083: ARRAY
44084: IN
44085: OR
44086: PUSH
44087: LD_VAR 0 1
44091: PUSH
44092: LD_EXP 71
44096: PUSH
44097: LD_VAR 0 3
44101: ARRAY
44102: IN
44103: OR
44104: PUSH
44105: LD_VAR 0 1
44109: PUSH
44110: LD_EXP 68
44114: PUSH
44115: LD_VAR 0 3
44119: ARRAY
44120: IN
44121: OR
44122: PUSH
44123: LD_VAR 0 1
44127: PUSH
44128: LD_EXP 78
44132: PUSH
44133: LD_VAR 0 3
44137: ARRAY
44138: IN
44139: OR
44140: PUSH
44141: LD_VAR 0 1
44145: PUSH
44146: LD_EXP 79
44150: PUSH
44151: LD_VAR 0 3
44155: ARRAY
44156: IN
44157: OR
44158: IFFALSE 45401
// begin if un in mc_ape [ i ] then
44160: LD_VAR 0 1
44164: PUSH
44165: LD_EXP 78
44169: PUSH
44170: LD_VAR 0 3
44174: ARRAY
44175: IN
44176: IFFALSE 44215
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44178: LD_ADDR_EXP 78
44182: PUSH
44183: LD_EXP 78
44187: PPUSH
44188: LD_VAR 0 3
44192: PPUSH
44193: LD_EXP 78
44197: PUSH
44198: LD_VAR 0 3
44202: ARRAY
44203: PUSH
44204: LD_VAR 0 1
44208: DIFF
44209: PPUSH
44210: CALL_OW 1
44214: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44215: LD_VAR 0 1
44219: PUSH
44220: LD_EXP 79
44224: PUSH
44225: LD_VAR 0 3
44229: ARRAY
44230: IN
44231: IFFALSE 44255
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44233: LD_ADDR_EXP 79
44237: PUSH
44238: LD_EXP 79
44242: PPUSH
44243: LD_VAR 0 3
44247: PPUSH
44248: EMPTY
44249: PPUSH
44250: CALL_OW 1
44254: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44255: LD_VAR 0 1
44259: PPUSH
44260: CALL_OW 247
44264: PUSH
44265: LD_INT 2
44267: EQUAL
44268: PUSH
44269: LD_VAR 0 1
44273: PPUSH
44274: CALL_OW 110
44278: PUSH
44279: LD_INT 20
44281: EQUAL
44282: PUSH
44283: LD_VAR 0 1
44287: PUSH
44288: LD_EXP 71
44292: PUSH
44293: LD_VAR 0 3
44297: ARRAY
44298: IN
44299: OR
44300: PUSH
44301: LD_VAR 0 1
44305: PPUSH
44306: CALL_OW 264
44310: PUSH
44311: LD_INT 12
44313: PUSH
44314: LD_INT 51
44316: PUSH
44317: LD_EXP 93
44321: PUSH
44322: LD_INT 32
44324: PUSH
44325: LD_INT 13
44327: PUSH
44328: LD_INT 52
44330: PUSH
44331: LD_INT 31
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: IN
44343: OR
44344: AND
44345: IFFALSE 44653
// begin if un in mc_defender [ i ] then
44347: LD_VAR 0 1
44351: PUSH
44352: LD_EXP 71
44356: PUSH
44357: LD_VAR 0 3
44361: ARRAY
44362: IN
44363: IFFALSE 44402
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44365: LD_ADDR_EXP 71
44369: PUSH
44370: LD_EXP 71
44374: PPUSH
44375: LD_VAR 0 3
44379: PPUSH
44380: LD_EXP 71
44384: PUSH
44385: LD_VAR 0 3
44389: ARRAY
44390: PUSH
44391: LD_VAR 0 1
44395: DIFF
44396: PPUSH
44397: CALL_OW 1
44401: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44402: LD_ADDR_VAR 0 8
44406: PUSH
44407: LD_VAR 0 3
44411: PPUSH
44412: LD_INT 3
44414: PPUSH
44415: CALL 41071 0 2
44419: ST_TO_ADDR
// if fac then
44420: LD_VAR 0 8
44424: IFFALSE 44653
// begin for j in fac do
44426: LD_ADDR_VAR 0 4
44430: PUSH
44431: LD_VAR 0 8
44435: PUSH
44436: FOR_IN
44437: IFFALSE 44651
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44439: LD_ADDR_VAR 0 9
44443: PUSH
44444: LD_VAR 0 8
44448: PPUSH
44449: LD_VAR 0 1
44453: PPUSH
44454: CALL_OW 265
44458: PPUSH
44459: LD_VAR 0 1
44463: PPUSH
44464: CALL_OW 262
44468: PPUSH
44469: LD_VAR 0 1
44473: PPUSH
44474: CALL_OW 263
44478: PPUSH
44479: LD_VAR 0 1
44483: PPUSH
44484: CALL_OW 264
44488: PPUSH
44489: CALL 51640 0 5
44493: ST_TO_ADDR
// if components then
44494: LD_VAR 0 9
44498: IFFALSE 44649
// begin if GetWeapon ( un ) = ar_control_tower then
44500: LD_VAR 0 1
44504: PPUSH
44505: CALL_OW 264
44509: PUSH
44510: LD_INT 31
44512: EQUAL
44513: IFFALSE 44630
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44515: LD_VAR 0 1
44519: PPUSH
44520: CALL_OW 311
44524: PPUSH
44525: LD_INT 0
44527: PPUSH
44528: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44532: LD_ADDR_EXP 89
44536: PUSH
44537: LD_EXP 89
44541: PPUSH
44542: LD_VAR 0 3
44546: PPUSH
44547: LD_EXP 89
44551: PUSH
44552: LD_VAR 0 3
44556: ARRAY
44557: PUSH
44558: LD_VAR 0 1
44562: PPUSH
44563: CALL_OW 311
44567: DIFF
44568: PPUSH
44569: CALL_OW 1
44573: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44574: LD_ADDR_VAR 0 7
44578: PUSH
44579: LD_EXP 70
44583: PUSH
44584: LD_VAR 0 3
44588: ARRAY
44589: PPUSH
44590: LD_INT 1
44592: PPUSH
44593: LD_VAR 0 9
44597: PPUSH
44598: CALL_OW 2
44602: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44603: LD_ADDR_EXP 70
44607: PUSH
44608: LD_EXP 70
44612: PPUSH
44613: LD_VAR 0 3
44617: PPUSH
44618: LD_VAR 0 7
44622: PPUSH
44623: CALL_OW 1
44627: ST_TO_ADDR
// end else
44628: GO 44647
// MC_InsertProduceList ( i , [ components ] ) ;
44630: LD_VAR 0 3
44634: PPUSH
44635: LD_VAR 0 9
44639: PUSH
44640: EMPTY
44641: LIST
44642: PPUSH
44643: CALL 40616 0 2
// break ;
44647: GO 44651
// end ; end ;
44649: GO 44436
44651: POP
44652: POP
// end ; end ; if GetType ( un ) = unit_building then
44653: LD_VAR 0 1
44657: PPUSH
44658: CALL_OW 247
44662: PUSH
44663: LD_INT 3
44665: EQUAL
44666: IFFALSE 45069
// begin btype := GetBType ( un ) ;
44668: LD_ADDR_VAR 0 5
44672: PUSH
44673: LD_VAR 0 1
44677: PPUSH
44678: CALL_OW 266
44682: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
44683: LD_VAR 0 5
44687: PUSH
44688: LD_INT 29
44690: PUSH
44691: LD_INT 30
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: IN
44698: IFFALSE 44771
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
44700: LD_VAR 0 1
44704: PPUSH
44705: CALL_OW 250
44709: PPUSH
44710: LD_VAR 0 1
44714: PPUSH
44715: CALL_OW 251
44719: PPUSH
44720: LD_VAR 0 1
44724: PPUSH
44725: CALL_OW 255
44729: PPUSH
44730: CALL_OW 440
44734: NOT
44735: IFFALSE 44771
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
44737: LD_VAR 0 1
44741: PPUSH
44742: CALL_OW 250
44746: PPUSH
44747: LD_VAR 0 1
44751: PPUSH
44752: CALL_OW 251
44756: PPUSH
44757: LD_VAR 0 1
44761: PPUSH
44762: CALL_OW 255
44766: PPUSH
44767: CALL_OW 441
// end ; if btype = b_warehouse then
44771: LD_VAR 0 5
44775: PUSH
44776: LD_INT 1
44778: EQUAL
44779: IFFALSE 44797
// begin btype := b_depot ;
44781: LD_ADDR_VAR 0 5
44785: PUSH
44786: LD_INT 0
44788: ST_TO_ADDR
// pos := 1 ;
44789: LD_ADDR_VAR 0 6
44793: PUSH
44794: LD_INT 1
44796: ST_TO_ADDR
// end ; if btype = b_factory then
44797: LD_VAR 0 5
44801: PUSH
44802: LD_INT 3
44804: EQUAL
44805: IFFALSE 44823
// begin btype := b_workshop ;
44807: LD_ADDR_VAR 0 5
44811: PUSH
44812: LD_INT 2
44814: ST_TO_ADDR
// pos := 1 ;
44815: LD_ADDR_VAR 0 6
44819: PUSH
44820: LD_INT 1
44822: ST_TO_ADDR
// end ; if btype = b_barracks then
44823: LD_VAR 0 5
44827: PUSH
44828: LD_INT 5
44830: EQUAL
44831: IFFALSE 44841
// btype := b_armoury ;
44833: LD_ADDR_VAR 0 5
44837: PUSH
44838: LD_INT 4
44840: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
44841: LD_VAR 0 5
44845: PUSH
44846: LD_INT 7
44848: PUSH
44849: LD_INT 8
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: IN
44856: IFFALSE 44866
// btype := b_lab ;
44858: LD_ADDR_VAR 0 5
44862: PUSH
44863: LD_INT 6
44865: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
44866: LD_ADDR_EXP 54
44870: PUSH
44871: LD_EXP 54
44875: PPUSH
44876: LD_VAR 0 3
44880: PUSH
44881: LD_EXP 54
44885: PUSH
44886: LD_VAR 0 3
44890: ARRAY
44891: PUSH
44892: LD_INT 1
44894: PLUS
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PPUSH
44900: LD_VAR 0 5
44904: PUSH
44905: LD_VAR 0 1
44909: PPUSH
44910: CALL_OW 250
44914: PUSH
44915: LD_VAR 0 1
44919: PPUSH
44920: CALL_OW 251
44924: PUSH
44925: LD_VAR 0 1
44929: PPUSH
44930: CALL_OW 254
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: PPUSH
44941: CALL 54108 0 3
44945: ST_TO_ADDR
// if pos = 1 then
44946: LD_VAR 0 6
44950: PUSH
44951: LD_INT 1
44953: EQUAL
44954: IFFALSE 45069
// begin tmp := mc_build_list [ i ] ;
44956: LD_ADDR_VAR 0 7
44960: PUSH
44961: LD_EXP 54
44965: PUSH
44966: LD_VAR 0 3
44970: ARRAY
44971: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44972: LD_VAR 0 7
44976: PPUSH
44977: LD_INT 2
44979: PUSH
44980: LD_INT 30
44982: PUSH
44983: LD_INT 0
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 30
44992: PUSH
44993: LD_INT 1
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: LIST
45004: PPUSH
45005: CALL_OW 72
45009: IFFALSE 45019
// pos := 2 ;
45011: LD_ADDR_VAR 0 6
45015: PUSH
45016: LD_INT 2
45018: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45019: LD_ADDR_VAR 0 7
45023: PUSH
45024: LD_VAR 0 7
45028: PPUSH
45029: LD_VAR 0 6
45033: PPUSH
45034: LD_VAR 0 7
45038: PPUSH
45039: CALL 54434 0 3
45043: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45044: LD_ADDR_EXP 54
45048: PUSH
45049: LD_EXP 54
45053: PPUSH
45054: LD_VAR 0 3
45058: PPUSH
45059: LD_VAR 0 7
45063: PPUSH
45064: CALL_OW 1
45068: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45069: LD_VAR 0 1
45073: PUSH
45074: LD_EXP 49
45078: PUSH
45079: LD_VAR 0 3
45083: ARRAY
45084: IN
45085: IFFALSE 45124
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45087: LD_ADDR_EXP 49
45091: PUSH
45092: LD_EXP 49
45096: PPUSH
45097: LD_VAR 0 3
45101: PPUSH
45102: LD_EXP 49
45106: PUSH
45107: LD_VAR 0 3
45111: ARRAY
45112: PUSH
45113: LD_VAR 0 1
45117: DIFF
45118: PPUSH
45119: CALL_OW 1
45123: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45124: LD_VAR 0 1
45128: PUSH
45129: LD_EXP 56
45133: PUSH
45134: LD_VAR 0 3
45138: ARRAY
45139: IN
45140: IFFALSE 45179
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45142: LD_ADDR_EXP 56
45146: PUSH
45147: LD_EXP 56
45151: PPUSH
45152: LD_VAR 0 3
45156: PPUSH
45157: LD_EXP 56
45161: PUSH
45162: LD_VAR 0 3
45166: ARRAY
45167: PUSH
45168: LD_VAR 0 1
45172: DIFF
45173: PPUSH
45174: CALL_OW 1
45178: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45179: LD_VAR 0 1
45183: PUSH
45184: LD_EXP 68
45188: PUSH
45189: LD_VAR 0 3
45193: ARRAY
45194: IN
45195: IFFALSE 45234
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45197: LD_ADDR_EXP 68
45201: PUSH
45202: LD_EXP 68
45206: PPUSH
45207: LD_VAR 0 3
45211: PPUSH
45212: LD_EXP 68
45216: PUSH
45217: LD_VAR 0 3
45221: ARRAY
45222: PUSH
45223: LD_VAR 0 1
45227: DIFF
45228: PPUSH
45229: CALL_OW 1
45233: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45234: LD_VAR 0 1
45238: PUSH
45239: LD_EXP 71
45243: PUSH
45244: LD_VAR 0 3
45248: ARRAY
45249: IN
45250: IFFALSE 45289
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45252: LD_ADDR_EXP 71
45256: PUSH
45257: LD_EXP 71
45261: PPUSH
45262: LD_VAR 0 3
45266: PPUSH
45267: LD_EXP 71
45271: PUSH
45272: LD_VAR 0 3
45276: ARRAY
45277: PUSH
45278: LD_VAR 0 1
45282: DIFF
45283: PPUSH
45284: CALL_OW 1
45288: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45289: LD_VAR 0 1
45293: PUSH
45294: LD_EXP 58
45298: PUSH
45299: LD_VAR 0 3
45303: ARRAY
45304: IN
45305: IFFALSE 45344
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45307: LD_ADDR_EXP 58
45311: PUSH
45312: LD_EXP 58
45316: PPUSH
45317: LD_VAR 0 3
45321: PPUSH
45322: LD_EXP 58
45326: PUSH
45327: LD_VAR 0 3
45331: ARRAY
45332: PUSH
45333: LD_VAR 0 1
45337: DIFF
45338: PPUSH
45339: CALL_OW 1
45343: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45344: LD_VAR 0 1
45348: PUSH
45349: LD_EXP 57
45353: PUSH
45354: LD_VAR 0 3
45358: ARRAY
45359: IN
45360: IFFALSE 45399
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45362: LD_ADDR_EXP 57
45366: PUSH
45367: LD_EXP 57
45371: PPUSH
45372: LD_VAR 0 3
45376: PPUSH
45377: LD_EXP 57
45381: PUSH
45382: LD_VAR 0 3
45386: ARRAY
45387: PUSH
45388: LD_VAR 0 1
45392: DIFF
45393: PPUSH
45394: CALL_OW 1
45398: ST_TO_ADDR
// end ; break ;
45399: GO 45403
// end ;
45401: GO 44049
45403: POP
45404: POP
// end ;
45405: LD_VAR 0 2
45409: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45410: LD_INT 0
45412: PPUSH
45413: PPUSH
45414: PPUSH
// if not mc_bases or not skirmish then
45415: LD_EXP 49
45419: NOT
45420: PUSH
45421: LD_EXP 47
45425: NOT
45426: OR
45427: IFFALSE 45431
// exit ;
45429: GO 45646
// for i = 1 to mc_bases do
45431: LD_ADDR_VAR 0 3
45435: PUSH
45436: DOUBLE
45437: LD_INT 1
45439: DEC
45440: ST_TO_ADDR
45441: LD_EXP 49
45445: PUSH
45446: FOR_TO
45447: IFFALSE 45644
// begin if building in mc_construct_list [ i ] then
45449: LD_VAR 0 1
45453: PUSH
45454: LD_EXP 56
45458: PUSH
45459: LD_VAR 0 3
45463: ARRAY
45464: IN
45465: IFFALSE 45642
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45467: LD_ADDR_EXP 56
45471: PUSH
45472: LD_EXP 56
45476: PPUSH
45477: LD_VAR 0 3
45481: PPUSH
45482: LD_EXP 56
45486: PUSH
45487: LD_VAR 0 3
45491: ARRAY
45492: PUSH
45493: LD_VAR 0 1
45497: DIFF
45498: PPUSH
45499: CALL_OW 1
45503: ST_TO_ADDR
// if building in mc_lab [ i ] then
45504: LD_VAR 0 1
45508: PUSH
45509: LD_EXP 82
45513: PUSH
45514: LD_VAR 0 3
45518: ARRAY
45519: IN
45520: IFFALSE 45575
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45522: LD_ADDR_EXP 83
45526: PUSH
45527: LD_EXP 83
45531: PPUSH
45532: LD_VAR 0 3
45536: PPUSH
45537: LD_EXP 83
45541: PUSH
45542: LD_VAR 0 3
45546: ARRAY
45547: PPUSH
45548: LD_INT 1
45550: PPUSH
45551: LD_EXP 83
45555: PUSH
45556: LD_VAR 0 3
45560: ARRAY
45561: PPUSH
45562: LD_INT 0
45564: PPUSH
45565: CALL 53526 0 4
45569: PPUSH
45570: CALL_OW 1
45574: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45575: LD_VAR 0 1
45579: PUSH
45580: LD_EXP 49
45584: PUSH
45585: LD_VAR 0 3
45589: ARRAY
45590: IN
45591: NOT
45592: IFFALSE 45638
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45594: LD_ADDR_EXP 49
45598: PUSH
45599: LD_EXP 49
45603: PPUSH
45604: LD_VAR 0 3
45608: PUSH
45609: LD_EXP 49
45613: PUSH
45614: LD_VAR 0 3
45618: ARRAY
45619: PUSH
45620: LD_INT 1
45622: PLUS
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PPUSH
45628: LD_VAR 0 1
45632: PPUSH
45633: CALL 54108 0 3
45637: ST_TO_ADDR
// exit ;
45638: POP
45639: POP
45640: GO 45646
// end ; end ;
45642: GO 45446
45644: POP
45645: POP
// end ;
45646: LD_VAR 0 2
45650: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
45651: LD_INT 0
45653: PPUSH
45654: PPUSH
45655: PPUSH
45656: PPUSH
45657: PPUSH
45658: PPUSH
45659: PPUSH
// if not mc_bases or not skirmish then
45660: LD_EXP 49
45664: NOT
45665: PUSH
45666: LD_EXP 47
45670: NOT
45671: OR
45672: IFFALSE 45676
// exit ;
45674: GO 46337
// for i = 1 to mc_bases do
45676: LD_ADDR_VAR 0 3
45680: PUSH
45681: DOUBLE
45682: LD_INT 1
45684: DEC
45685: ST_TO_ADDR
45686: LD_EXP 49
45690: PUSH
45691: FOR_TO
45692: IFFALSE 46335
// begin if building in mc_construct_list [ i ] then
45694: LD_VAR 0 1
45698: PUSH
45699: LD_EXP 56
45703: PUSH
45704: LD_VAR 0 3
45708: ARRAY
45709: IN
45710: IFFALSE 46333
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45712: LD_ADDR_EXP 56
45716: PUSH
45717: LD_EXP 56
45721: PPUSH
45722: LD_VAR 0 3
45726: PPUSH
45727: LD_EXP 56
45731: PUSH
45732: LD_VAR 0 3
45736: ARRAY
45737: PUSH
45738: LD_VAR 0 1
45742: DIFF
45743: PPUSH
45744: CALL_OW 1
45748: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45749: LD_ADDR_EXP 49
45753: PUSH
45754: LD_EXP 49
45758: PPUSH
45759: LD_VAR 0 3
45763: PUSH
45764: LD_EXP 49
45768: PUSH
45769: LD_VAR 0 3
45773: ARRAY
45774: PUSH
45775: LD_INT 1
45777: PLUS
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PPUSH
45783: LD_VAR 0 1
45787: PPUSH
45788: CALL 54108 0 3
45792: ST_TO_ADDR
// btype := GetBType ( building ) ;
45793: LD_ADDR_VAR 0 5
45797: PUSH
45798: LD_VAR 0 1
45802: PPUSH
45803: CALL_OW 266
45807: ST_TO_ADDR
// side := GetSide ( building ) ;
45808: LD_ADDR_VAR 0 8
45812: PUSH
45813: LD_VAR 0 1
45817: PPUSH
45818: CALL_OW 255
45822: ST_TO_ADDR
// if btype = b_lab then
45823: LD_VAR 0 5
45827: PUSH
45828: LD_INT 6
45830: EQUAL
45831: IFFALSE 45881
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
45833: LD_ADDR_EXP 82
45837: PUSH
45838: LD_EXP 82
45842: PPUSH
45843: LD_VAR 0 3
45847: PUSH
45848: LD_EXP 82
45852: PUSH
45853: LD_VAR 0 3
45857: ARRAY
45858: PUSH
45859: LD_INT 1
45861: PLUS
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PPUSH
45867: LD_VAR 0 1
45871: PPUSH
45872: CALL 54108 0 3
45876: ST_TO_ADDR
// exit ;
45877: POP
45878: POP
45879: GO 46337
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
45881: LD_VAR 0 5
45885: PUSH
45886: LD_INT 0
45888: PUSH
45889: LD_INT 2
45891: PUSH
45892: LD_INT 4
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: LIST
45899: IN
45900: IFFALSE 46024
// begin if btype = b_armoury then
45902: LD_VAR 0 5
45906: PUSH
45907: LD_INT 4
45909: EQUAL
45910: IFFALSE 45920
// btype := b_barracks ;
45912: LD_ADDR_VAR 0 5
45916: PUSH
45917: LD_INT 5
45919: ST_TO_ADDR
// if btype = b_depot then
45920: LD_VAR 0 5
45924: PUSH
45925: LD_INT 0
45927: EQUAL
45928: IFFALSE 45938
// btype := b_warehouse ;
45930: LD_ADDR_VAR 0 5
45934: PUSH
45935: LD_INT 1
45937: ST_TO_ADDR
// if btype = b_workshop then
45938: LD_VAR 0 5
45942: PUSH
45943: LD_INT 2
45945: EQUAL
45946: IFFALSE 45956
// btype := b_factory ;
45948: LD_ADDR_VAR 0 5
45952: PUSH
45953: LD_INT 3
45955: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
45956: LD_VAR 0 5
45960: PPUSH
45961: LD_VAR 0 8
45965: PPUSH
45966: CALL_OW 323
45970: PUSH
45971: LD_INT 1
45973: EQUAL
45974: IFFALSE 46020
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
45976: LD_ADDR_EXP 81
45980: PUSH
45981: LD_EXP 81
45985: PPUSH
45986: LD_VAR 0 3
45990: PUSH
45991: LD_EXP 81
45995: PUSH
45996: LD_VAR 0 3
46000: ARRAY
46001: PUSH
46002: LD_INT 1
46004: PLUS
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: PPUSH
46010: LD_VAR 0 1
46014: PPUSH
46015: CALL 54108 0 3
46019: ST_TO_ADDR
// exit ;
46020: POP
46021: POP
46022: GO 46337
// end ; if btype in [ b_bunker , b_turret ] then
46024: LD_VAR 0 5
46028: PUSH
46029: LD_INT 32
46031: PUSH
46032: LD_INT 33
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: IN
46039: IFFALSE 46329
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46041: LD_ADDR_EXP 57
46045: PUSH
46046: LD_EXP 57
46050: PPUSH
46051: LD_VAR 0 3
46055: PUSH
46056: LD_EXP 57
46060: PUSH
46061: LD_VAR 0 3
46065: ARRAY
46066: PUSH
46067: LD_INT 1
46069: PLUS
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PPUSH
46075: LD_VAR 0 1
46079: PPUSH
46080: CALL 54108 0 3
46084: ST_TO_ADDR
// if btype = b_bunker then
46085: LD_VAR 0 5
46089: PUSH
46090: LD_INT 32
46092: EQUAL
46093: IFFALSE 46329
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46095: LD_ADDR_EXP 58
46099: PUSH
46100: LD_EXP 58
46104: PPUSH
46105: LD_VAR 0 3
46109: PUSH
46110: LD_EXP 58
46114: PUSH
46115: LD_VAR 0 3
46119: ARRAY
46120: PUSH
46121: LD_INT 1
46123: PLUS
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: PPUSH
46129: LD_VAR 0 1
46133: PPUSH
46134: CALL 54108 0 3
46138: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46139: LD_ADDR_VAR 0 6
46143: PUSH
46144: LD_EXP 49
46148: PUSH
46149: LD_VAR 0 3
46153: ARRAY
46154: PPUSH
46155: LD_INT 25
46157: PUSH
46158: LD_INT 1
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 3
46167: PUSH
46168: LD_INT 54
46170: PUSH
46171: EMPTY
46172: LIST
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PPUSH
46182: CALL_OW 72
46186: ST_TO_ADDR
// if tmp then
46187: LD_VAR 0 6
46191: IFFALSE 46197
// exit ;
46193: POP
46194: POP
46195: GO 46337
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46197: LD_ADDR_VAR 0 6
46201: PUSH
46202: LD_EXP 49
46206: PUSH
46207: LD_VAR 0 3
46211: ARRAY
46212: PPUSH
46213: LD_INT 2
46215: PUSH
46216: LD_INT 30
46218: PUSH
46219: LD_INT 4
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 30
46228: PUSH
46229: LD_INT 5
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: LIST
46240: PPUSH
46241: CALL_OW 72
46245: ST_TO_ADDR
// if not tmp then
46246: LD_VAR 0 6
46250: NOT
46251: IFFALSE 46257
// exit ;
46253: POP
46254: POP
46255: GO 46337
// for j in tmp do
46257: LD_ADDR_VAR 0 4
46261: PUSH
46262: LD_VAR 0 6
46266: PUSH
46267: FOR_IN
46268: IFFALSE 46327
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46270: LD_ADDR_VAR 0 7
46274: PUSH
46275: LD_VAR 0 4
46279: PPUSH
46280: CALL_OW 313
46284: PPUSH
46285: LD_INT 25
46287: PUSH
46288: LD_INT 1
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PPUSH
46295: CALL_OW 72
46299: ST_TO_ADDR
// if units then
46300: LD_VAR 0 7
46304: IFFALSE 46325
// begin ComExitBuilding ( units [ 1 ] ) ;
46306: LD_VAR 0 7
46310: PUSH
46311: LD_INT 1
46313: ARRAY
46314: PPUSH
46315: CALL_OW 122
// exit ;
46319: POP
46320: POP
46321: POP
46322: POP
46323: GO 46337
// end ; end ;
46325: GO 46267
46327: POP
46328: POP
// end ; end ; exit ;
46329: POP
46330: POP
46331: GO 46337
// end ; end ;
46333: GO 45691
46335: POP
46336: POP
// end ;
46337: LD_VAR 0 2
46341: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46342: LD_INT 0
46344: PPUSH
46345: PPUSH
46346: PPUSH
46347: PPUSH
46348: PPUSH
46349: PPUSH
46350: PPUSH
// if not mc_bases or not skirmish then
46351: LD_EXP 49
46355: NOT
46356: PUSH
46357: LD_EXP 47
46361: NOT
46362: OR
46363: IFFALSE 46367
// exit ;
46365: GO 46598
// btype := GetBType ( building ) ;
46367: LD_ADDR_VAR 0 6
46371: PUSH
46372: LD_VAR 0 1
46376: PPUSH
46377: CALL_OW 266
46381: ST_TO_ADDR
// x := GetX ( building ) ;
46382: LD_ADDR_VAR 0 7
46386: PUSH
46387: LD_VAR 0 1
46391: PPUSH
46392: CALL_OW 250
46396: ST_TO_ADDR
// y := GetY ( building ) ;
46397: LD_ADDR_VAR 0 8
46401: PUSH
46402: LD_VAR 0 1
46406: PPUSH
46407: CALL_OW 251
46411: ST_TO_ADDR
// d := GetDir ( building ) ;
46412: LD_ADDR_VAR 0 9
46416: PUSH
46417: LD_VAR 0 1
46421: PPUSH
46422: CALL_OW 254
46426: ST_TO_ADDR
// for i = 1 to mc_bases do
46427: LD_ADDR_VAR 0 4
46431: PUSH
46432: DOUBLE
46433: LD_INT 1
46435: DEC
46436: ST_TO_ADDR
46437: LD_EXP 49
46441: PUSH
46442: FOR_TO
46443: IFFALSE 46596
// begin if not mc_build_list [ i ] then
46445: LD_EXP 54
46449: PUSH
46450: LD_VAR 0 4
46454: ARRAY
46455: NOT
46456: IFFALSE 46460
// continue ;
46458: GO 46442
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46460: LD_VAR 0 6
46464: PUSH
46465: LD_VAR 0 7
46469: PUSH
46470: LD_VAR 0 8
46474: PUSH
46475: LD_VAR 0 9
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: PPUSH
46486: LD_EXP 54
46490: PUSH
46491: LD_VAR 0 4
46495: ARRAY
46496: PUSH
46497: LD_INT 1
46499: ARRAY
46500: PPUSH
46501: CALL 60277 0 2
46505: IFFALSE 46594
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46507: LD_ADDR_EXP 54
46511: PUSH
46512: LD_EXP 54
46516: PPUSH
46517: LD_VAR 0 4
46521: PPUSH
46522: LD_EXP 54
46526: PUSH
46527: LD_VAR 0 4
46531: ARRAY
46532: PPUSH
46533: LD_INT 1
46535: PPUSH
46536: CALL_OW 3
46540: PPUSH
46541: CALL_OW 1
46545: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46546: LD_ADDR_EXP 56
46550: PUSH
46551: LD_EXP 56
46555: PPUSH
46556: LD_VAR 0 4
46560: PUSH
46561: LD_EXP 56
46565: PUSH
46566: LD_VAR 0 4
46570: ARRAY
46571: PUSH
46572: LD_INT 1
46574: PLUS
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL 54108 0 3
46589: ST_TO_ADDR
// exit ;
46590: POP
46591: POP
46592: GO 46598
// end ; end ;
46594: GO 46442
46596: POP
46597: POP
// end ;
46598: LD_VAR 0 3
46602: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46603: LD_INT 0
46605: PPUSH
46606: PPUSH
46607: PPUSH
// if not mc_bases or not skirmish then
46608: LD_EXP 49
46612: NOT
46613: PUSH
46614: LD_EXP 47
46618: NOT
46619: OR
46620: IFFALSE 46624
// exit ;
46622: GO 46814
// for i = 1 to mc_bases do
46624: LD_ADDR_VAR 0 4
46628: PUSH
46629: DOUBLE
46630: LD_INT 1
46632: DEC
46633: ST_TO_ADDR
46634: LD_EXP 49
46638: PUSH
46639: FOR_TO
46640: IFFALSE 46727
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
46642: LD_VAR 0 1
46646: PUSH
46647: LD_EXP 57
46651: PUSH
46652: LD_VAR 0 4
46656: ARRAY
46657: IN
46658: PUSH
46659: LD_VAR 0 1
46663: PUSH
46664: LD_EXP 58
46668: PUSH
46669: LD_VAR 0 4
46673: ARRAY
46674: IN
46675: NOT
46676: AND
46677: IFFALSE 46725
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46679: LD_ADDR_EXP 58
46683: PUSH
46684: LD_EXP 58
46688: PPUSH
46689: LD_VAR 0 4
46693: PUSH
46694: LD_EXP 58
46698: PUSH
46699: LD_VAR 0 4
46703: ARRAY
46704: PUSH
46705: LD_INT 1
46707: PLUS
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: PPUSH
46713: LD_VAR 0 1
46717: PPUSH
46718: CALL 54108 0 3
46722: ST_TO_ADDR
// break ;
46723: GO 46727
// end ; end ;
46725: GO 46639
46727: POP
46728: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
46729: LD_VAR 0 1
46733: PPUSH
46734: CALL_OW 257
46738: PUSH
46739: LD_EXP 75
46743: IN
46744: PUSH
46745: LD_VAR 0 1
46749: PPUSH
46750: CALL_OW 266
46754: PUSH
46755: LD_INT 5
46757: EQUAL
46758: AND
46759: PUSH
46760: LD_VAR 0 2
46764: PPUSH
46765: CALL_OW 110
46769: PUSH
46770: LD_INT 18
46772: NONEQUAL
46773: AND
46774: IFFALSE 46814
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
46776: LD_VAR 0 2
46780: PPUSH
46781: CALL_OW 257
46785: PUSH
46786: LD_INT 5
46788: PUSH
46789: LD_INT 8
46791: PUSH
46792: LD_INT 9
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: LIST
46799: IN
46800: IFFALSE 46814
// SetClass ( unit , 1 ) ;
46802: LD_VAR 0 2
46806: PPUSH
46807: LD_INT 1
46809: PPUSH
46810: CALL_OW 336
// end ;
46814: LD_VAR 0 3
46818: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
46819: LD_INT 0
46821: PPUSH
46822: PPUSH
// if not mc_bases or not skirmish then
46823: LD_EXP 49
46827: NOT
46828: PUSH
46829: LD_EXP 47
46833: NOT
46834: OR
46835: IFFALSE 46839
// exit ;
46837: GO 46955
// if GetLives ( abandoned_vehicle ) > 250 then
46839: LD_VAR 0 2
46843: PPUSH
46844: CALL_OW 256
46848: PUSH
46849: LD_INT 250
46851: GREATER
46852: IFFALSE 46856
// exit ;
46854: GO 46955
// for i = 1 to mc_bases do
46856: LD_ADDR_VAR 0 6
46860: PUSH
46861: DOUBLE
46862: LD_INT 1
46864: DEC
46865: ST_TO_ADDR
46866: LD_EXP 49
46870: PUSH
46871: FOR_TO
46872: IFFALSE 46953
// begin if driver in mc_bases [ i ] then
46874: LD_VAR 0 1
46878: PUSH
46879: LD_EXP 49
46883: PUSH
46884: LD_VAR 0 6
46888: ARRAY
46889: IN
46890: IFFALSE 46951
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
46892: LD_VAR 0 1
46896: PPUSH
46897: LD_EXP 49
46901: PUSH
46902: LD_VAR 0 6
46906: ARRAY
46907: PPUSH
46908: LD_INT 2
46910: PUSH
46911: LD_INT 30
46913: PUSH
46914: LD_INT 0
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 30
46923: PUSH
46924: LD_INT 1
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: LIST
46935: PPUSH
46936: CALL_OW 72
46940: PUSH
46941: LD_INT 1
46943: ARRAY
46944: PPUSH
46945: CALL_OW 112
// break ;
46949: GO 46953
// end ; end ;
46951: GO 46871
46953: POP
46954: POP
// end ; end_of_file
46955: LD_VAR 0 5
46959: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
46960: LD_INT 0
46962: PPUSH
46963: PPUSH
// if exist_mode then
46964: LD_VAR 0 2
46968: IFFALSE 46993
// unit := CreateCharacter ( prefix & ident ) else
46970: LD_ADDR_VAR 0 5
46974: PUSH
46975: LD_VAR 0 3
46979: PUSH
46980: LD_VAR 0 1
46984: STR
46985: PPUSH
46986: CALL_OW 34
46990: ST_TO_ADDR
46991: GO 47008
// unit := NewCharacter ( ident ) ;
46993: LD_ADDR_VAR 0 5
46997: PUSH
46998: LD_VAR 0 1
47002: PPUSH
47003: CALL_OW 25
47007: ST_TO_ADDR
// result := unit ;
47008: LD_ADDR_VAR 0 4
47012: PUSH
47013: LD_VAR 0 5
47017: ST_TO_ADDR
// end ;
47018: LD_VAR 0 4
47022: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47023: LD_INT 0
47025: PPUSH
47026: PPUSH
// if not side or not nation then
47027: LD_VAR 0 1
47031: NOT
47032: PUSH
47033: LD_VAR 0 2
47037: NOT
47038: OR
47039: IFFALSE 47043
// exit ;
47041: GO 47687
// case nation of nation_american :
47043: LD_VAR 0 2
47047: PUSH
47048: LD_INT 1
47050: DOUBLE
47051: EQUAL
47052: IFTRUE 47056
47054: GO 47230
47056: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47057: LD_ADDR_VAR 0 4
47061: PUSH
47062: LD_INT 35
47064: PUSH
47065: LD_INT 45
47067: PUSH
47068: LD_INT 46
47070: PUSH
47071: LD_INT 47
47073: PUSH
47074: LD_INT 1
47076: PUSH
47077: LD_INT 2
47079: PUSH
47080: LD_INT 6
47082: PUSH
47083: LD_INT 15
47085: PUSH
47086: LD_INT 16
47088: PUSH
47089: LD_INT 7
47091: PUSH
47092: LD_INT 12
47094: PUSH
47095: LD_INT 13
47097: PUSH
47098: LD_INT 10
47100: PUSH
47101: LD_INT 14
47103: PUSH
47104: LD_INT 20
47106: PUSH
47107: LD_INT 21
47109: PUSH
47110: LD_INT 22
47112: PUSH
47113: LD_INT 25
47115: PUSH
47116: LD_INT 32
47118: PUSH
47119: LD_INT 27
47121: PUSH
47122: LD_INT 36
47124: PUSH
47125: LD_INT 69
47127: PUSH
47128: LD_INT 39
47130: PUSH
47131: LD_INT 34
47133: PUSH
47134: LD_INT 40
47136: PUSH
47137: LD_INT 48
47139: PUSH
47140: LD_INT 49
47142: PUSH
47143: LD_INT 50
47145: PUSH
47146: LD_INT 51
47148: PUSH
47149: LD_INT 52
47151: PUSH
47152: LD_INT 53
47154: PUSH
47155: LD_INT 54
47157: PUSH
47158: LD_INT 55
47160: PUSH
47161: LD_INT 56
47163: PUSH
47164: LD_INT 57
47166: PUSH
47167: LD_INT 58
47169: PUSH
47170: LD_INT 59
47172: PUSH
47173: LD_INT 60
47175: PUSH
47176: LD_INT 61
47178: PUSH
47179: LD_INT 62
47181: PUSH
47182: LD_INT 80
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: ST_TO_ADDR
47228: GO 47611
47230: LD_INT 2
47232: DOUBLE
47233: EQUAL
47234: IFTRUE 47238
47236: GO 47420
47238: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47239: LD_ADDR_VAR 0 4
47243: PUSH
47244: LD_INT 35
47246: PUSH
47247: LD_INT 45
47249: PUSH
47250: LD_INT 46
47252: PUSH
47253: LD_INT 47
47255: PUSH
47256: LD_INT 70
47258: PUSH
47259: LD_INT 1
47261: PUSH
47262: LD_INT 11
47264: PUSH
47265: LD_INT 3
47267: PUSH
47268: LD_INT 4
47270: PUSH
47271: LD_INT 5
47273: PUSH
47274: LD_INT 6
47276: PUSH
47277: LD_INT 15
47279: PUSH
47280: LD_INT 18
47282: PUSH
47283: LD_INT 7
47285: PUSH
47286: LD_INT 17
47288: PUSH
47289: LD_INT 8
47291: PUSH
47292: LD_INT 20
47294: PUSH
47295: LD_INT 21
47297: PUSH
47298: LD_INT 22
47300: PUSH
47301: LD_INT 72
47303: PUSH
47304: LD_INT 26
47306: PUSH
47307: LD_INT 69
47309: PUSH
47310: LD_INT 39
47312: PUSH
47313: LD_INT 40
47315: PUSH
47316: LD_INT 41
47318: PUSH
47319: LD_INT 42
47321: PUSH
47322: LD_INT 43
47324: PUSH
47325: LD_INT 48
47327: PUSH
47328: LD_INT 49
47330: PUSH
47331: LD_INT 50
47333: PUSH
47334: LD_INT 51
47336: PUSH
47337: LD_INT 52
47339: PUSH
47340: LD_INT 53
47342: PUSH
47343: LD_INT 54
47345: PUSH
47346: LD_INT 55
47348: PUSH
47349: LD_INT 56
47351: PUSH
47352: LD_INT 60
47354: PUSH
47355: LD_INT 61
47357: PUSH
47358: LD_INT 62
47360: PUSH
47361: LD_INT 66
47363: PUSH
47364: LD_INT 67
47366: PUSH
47367: LD_INT 68
47369: PUSH
47370: LD_INT 81
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: ST_TO_ADDR
47418: GO 47611
47420: LD_INT 3
47422: DOUBLE
47423: EQUAL
47424: IFTRUE 47428
47426: GO 47610
47428: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47429: LD_ADDR_VAR 0 4
47433: PUSH
47434: LD_INT 46
47436: PUSH
47437: LD_INT 47
47439: PUSH
47440: LD_INT 1
47442: PUSH
47443: LD_INT 2
47445: PUSH
47446: LD_INT 11
47448: PUSH
47449: LD_INT 9
47451: PUSH
47452: LD_INT 20
47454: PUSH
47455: LD_INT 19
47457: PUSH
47458: LD_INT 21
47460: PUSH
47461: LD_INT 24
47463: PUSH
47464: LD_INT 22
47466: PUSH
47467: LD_INT 25
47469: PUSH
47470: LD_INT 28
47472: PUSH
47473: LD_INT 29
47475: PUSH
47476: LD_INT 30
47478: PUSH
47479: LD_INT 31
47481: PUSH
47482: LD_INT 37
47484: PUSH
47485: LD_INT 38
47487: PUSH
47488: LD_INT 32
47490: PUSH
47491: LD_INT 27
47493: PUSH
47494: LD_INT 33
47496: PUSH
47497: LD_INT 69
47499: PUSH
47500: LD_INT 39
47502: PUSH
47503: LD_INT 34
47505: PUSH
47506: LD_INT 40
47508: PUSH
47509: LD_INT 71
47511: PUSH
47512: LD_INT 23
47514: PUSH
47515: LD_INT 44
47517: PUSH
47518: LD_INT 48
47520: PUSH
47521: LD_INT 49
47523: PUSH
47524: LD_INT 50
47526: PUSH
47527: LD_INT 51
47529: PUSH
47530: LD_INT 52
47532: PUSH
47533: LD_INT 53
47535: PUSH
47536: LD_INT 54
47538: PUSH
47539: LD_INT 55
47541: PUSH
47542: LD_INT 56
47544: PUSH
47545: LD_INT 57
47547: PUSH
47548: LD_INT 58
47550: PUSH
47551: LD_INT 59
47553: PUSH
47554: LD_INT 63
47556: PUSH
47557: LD_INT 64
47559: PUSH
47560: LD_INT 65
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: LIST
47586: LIST
47587: LIST
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: ST_TO_ADDR
47608: GO 47611
47610: POP
// if state > - 1 and state < 3 then
47611: LD_VAR 0 3
47615: PUSH
47616: LD_INT 1
47618: NEG
47619: GREATER
47620: PUSH
47621: LD_VAR 0 3
47625: PUSH
47626: LD_INT 3
47628: LESS
47629: AND
47630: IFFALSE 47687
// for i in result do
47632: LD_ADDR_VAR 0 5
47636: PUSH
47637: LD_VAR 0 4
47641: PUSH
47642: FOR_IN
47643: IFFALSE 47685
// if GetTech ( i , side ) <> state then
47645: LD_VAR 0 5
47649: PPUSH
47650: LD_VAR 0 1
47654: PPUSH
47655: CALL_OW 321
47659: PUSH
47660: LD_VAR 0 3
47664: NONEQUAL
47665: IFFALSE 47683
// result := result diff i ;
47667: LD_ADDR_VAR 0 4
47671: PUSH
47672: LD_VAR 0 4
47676: PUSH
47677: LD_VAR 0 5
47681: DIFF
47682: ST_TO_ADDR
47683: GO 47642
47685: POP
47686: POP
// end ;
47687: LD_VAR 0 4
47691: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
47692: LD_INT 0
47694: PPUSH
47695: PPUSH
47696: PPUSH
// result := true ;
47697: LD_ADDR_VAR 0 3
47701: PUSH
47702: LD_INT 1
47704: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
47705: LD_ADDR_VAR 0 5
47709: PUSH
47710: LD_VAR 0 2
47714: PPUSH
47715: CALL_OW 480
47719: ST_TO_ADDR
// if not tmp then
47720: LD_VAR 0 5
47724: NOT
47725: IFFALSE 47729
// exit ;
47727: GO 47778
// for i in tmp do
47729: LD_ADDR_VAR 0 4
47733: PUSH
47734: LD_VAR 0 5
47738: PUSH
47739: FOR_IN
47740: IFFALSE 47776
// if GetTech ( i , side ) <> state_researched then
47742: LD_VAR 0 4
47746: PPUSH
47747: LD_VAR 0 1
47751: PPUSH
47752: CALL_OW 321
47756: PUSH
47757: LD_INT 2
47759: NONEQUAL
47760: IFFALSE 47774
// begin result := false ;
47762: LD_ADDR_VAR 0 3
47766: PUSH
47767: LD_INT 0
47769: ST_TO_ADDR
// exit ;
47770: POP
47771: POP
47772: GO 47778
// end ;
47774: GO 47739
47776: POP
47777: POP
// end ;
47778: LD_VAR 0 3
47782: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
47783: LD_INT 0
47785: PPUSH
47786: PPUSH
47787: PPUSH
47788: PPUSH
47789: PPUSH
47790: PPUSH
47791: PPUSH
47792: PPUSH
47793: PPUSH
47794: PPUSH
47795: PPUSH
47796: PPUSH
47797: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
47798: LD_VAR 0 1
47802: NOT
47803: PUSH
47804: LD_VAR 0 1
47808: PPUSH
47809: CALL_OW 257
47813: PUSH
47814: LD_INT 9
47816: NONEQUAL
47817: OR
47818: IFFALSE 47822
// exit ;
47820: GO 48395
// side := GetSide ( unit ) ;
47822: LD_ADDR_VAR 0 9
47826: PUSH
47827: LD_VAR 0 1
47831: PPUSH
47832: CALL_OW 255
47836: ST_TO_ADDR
// tech_space := tech_spacanom ;
47837: LD_ADDR_VAR 0 12
47841: PUSH
47842: LD_INT 29
47844: ST_TO_ADDR
// tech_time := tech_taurad ;
47845: LD_ADDR_VAR 0 13
47849: PUSH
47850: LD_INT 28
47852: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
47853: LD_ADDR_VAR 0 11
47857: PUSH
47858: LD_VAR 0 1
47862: PPUSH
47863: CALL_OW 310
47867: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
47868: LD_VAR 0 11
47872: PPUSH
47873: CALL_OW 247
47877: PUSH
47878: LD_INT 2
47880: EQUAL
47881: IFFALSE 47885
// exit ;
47883: GO 48395
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
47885: LD_ADDR_VAR 0 8
47889: PUSH
47890: LD_INT 81
47892: PUSH
47893: LD_VAR 0 9
47897: PUSH
47898: EMPTY
47899: LIST
47900: LIST
47901: PUSH
47902: LD_INT 3
47904: PUSH
47905: LD_INT 21
47907: PUSH
47908: LD_INT 3
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PUSH
47919: EMPTY
47920: LIST
47921: LIST
47922: PPUSH
47923: CALL_OW 69
47927: ST_TO_ADDR
// if not tmp then
47928: LD_VAR 0 8
47932: NOT
47933: IFFALSE 47937
// exit ;
47935: GO 48395
// if in_unit then
47937: LD_VAR 0 11
47941: IFFALSE 47965
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
47943: LD_ADDR_VAR 0 10
47947: PUSH
47948: LD_VAR 0 8
47952: PPUSH
47953: LD_VAR 0 11
47957: PPUSH
47958: CALL_OW 74
47962: ST_TO_ADDR
47963: GO 47985
// enemy := NearestUnitToUnit ( tmp , unit ) ;
47965: LD_ADDR_VAR 0 10
47969: PUSH
47970: LD_VAR 0 8
47974: PPUSH
47975: LD_VAR 0 1
47979: PPUSH
47980: CALL_OW 74
47984: ST_TO_ADDR
// if not enemy then
47985: LD_VAR 0 10
47989: NOT
47990: IFFALSE 47994
// exit ;
47992: GO 48395
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
47994: LD_VAR 0 11
47998: PUSH
47999: LD_VAR 0 11
48003: PPUSH
48004: LD_VAR 0 10
48008: PPUSH
48009: CALL_OW 296
48013: PUSH
48014: LD_INT 13
48016: GREATER
48017: AND
48018: PUSH
48019: LD_VAR 0 1
48023: PPUSH
48024: LD_VAR 0 10
48028: PPUSH
48029: CALL_OW 296
48033: PUSH
48034: LD_INT 12
48036: GREATER
48037: OR
48038: IFFALSE 48042
// exit ;
48040: GO 48395
// missile := [ 1 ] ;
48042: LD_ADDR_VAR 0 14
48046: PUSH
48047: LD_INT 1
48049: PUSH
48050: EMPTY
48051: LIST
48052: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48053: LD_VAR 0 9
48057: PPUSH
48058: LD_VAR 0 12
48062: PPUSH
48063: CALL_OW 325
48067: IFFALSE 48096
// missile := Insert ( missile , missile + 1 , 2 ) ;
48069: LD_ADDR_VAR 0 14
48073: PUSH
48074: LD_VAR 0 14
48078: PPUSH
48079: LD_VAR 0 14
48083: PUSH
48084: LD_INT 1
48086: PLUS
48087: PPUSH
48088: LD_INT 2
48090: PPUSH
48091: CALL_OW 2
48095: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48096: LD_VAR 0 9
48100: PPUSH
48101: LD_VAR 0 13
48105: PPUSH
48106: CALL_OW 325
48110: PUSH
48111: LD_VAR 0 10
48115: PPUSH
48116: CALL_OW 255
48120: PPUSH
48121: LD_VAR 0 13
48125: PPUSH
48126: CALL_OW 325
48130: NOT
48131: AND
48132: IFFALSE 48161
// missile := Insert ( missile , missile + 1 , 3 ) ;
48134: LD_ADDR_VAR 0 14
48138: PUSH
48139: LD_VAR 0 14
48143: PPUSH
48144: LD_VAR 0 14
48148: PUSH
48149: LD_INT 1
48151: PLUS
48152: PPUSH
48153: LD_INT 3
48155: PPUSH
48156: CALL_OW 2
48160: ST_TO_ADDR
// if missile < 2 then
48161: LD_VAR 0 14
48165: PUSH
48166: LD_INT 2
48168: LESS
48169: IFFALSE 48173
// exit ;
48171: GO 48395
// x := GetX ( enemy ) ;
48173: LD_ADDR_VAR 0 4
48177: PUSH
48178: LD_VAR 0 10
48182: PPUSH
48183: CALL_OW 250
48187: ST_TO_ADDR
// y := GetY ( enemy ) ;
48188: LD_ADDR_VAR 0 5
48192: PUSH
48193: LD_VAR 0 10
48197: PPUSH
48198: CALL_OW 251
48202: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48203: LD_ADDR_VAR 0 6
48207: PUSH
48208: LD_VAR 0 4
48212: PUSH
48213: LD_INT 1
48215: NEG
48216: PPUSH
48217: LD_INT 1
48219: PPUSH
48220: CALL_OW 12
48224: PLUS
48225: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48226: LD_ADDR_VAR 0 7
48230: PUSH
48231: LD_VAR 0 5
48235: PUSH
48236: LD_INT 1
48238: NEG
48239: PPUSH
48240: LD_INT 1
48242: PPUSH
48243: CALL_OW 12
48247: PLUS
48248: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48249: LD_VAR 0 6
48253: PPUSH
48254: LD_VAR 0 7
48258: PPUSH
48259: CALL_OW 488
48263: NOT
48264: IFFALSE 48286
// begin _x := x ;
48266: LD_ADDR_VAR 0 6
48270: PUSH
48271: LD_VAR 0 4
48275: ST_TO_ADDR
// _y := y ;
48276: LD_ADDR_VAR 0 7
48280: PUSH
48281: LD_VAR 0 5
48285: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48286: LD_ADDR_VAR 0 3
48290: PUSH
48291: LD_INT 1
48293: PPUSH
48294: LD_VAR 0 14
48298: PPUSH
48299: CALL_OW 12
48303: ST_TO_ADDR
// case i of 1 :
48304: LD_VAR 0 3
48308: PUSH
48309: LD_INT 1
48311: DOUBLE
48312: EQUAL
48313: IFTRUE 48317
48315: GO 48334
48317: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48318: LD_VAR 0 1
48322: PPUSH
48323: LD_VAR 0 10
48327: PPUSH
48328: CALL_OW 115
48332: GO 48395
48334: LD_INT 2
48336: DOUBLE
48337: EQUAL
48338: IFTRUE 48342
48340: GO 48364
48342: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48343: LD_VAR 0 1
48347: PPUSH
48348: LD_VAR 0 6
48352: PPUSH
48353: LD_VAR 0 7
48357: PPUSH
48358: CALL_OW 153
48362: GO 48395
48364: LD_INT 3
48366: DOUBLE
48367: EQUAL
48368: IFTRUE 48372
48370: GO 48394
48372: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48373: LD_VAR 0 1
48377: PPUSH
48378: LD_VAR 0 6
48382: PPUSH
48383: LD_VAR 0 7
48387: PPUSH
48388: CALL_OW 154
48392: GO 48395
48394: POP
// end ;
48395: LD_VAR 0 2
48399: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48400: LD_INT 0
48402: PPUSH
48403: PPUSH
48404: PPUSH
48405: PPUSH
48406: PPUSH
48407: PPUSH
// if not unit or not building then
48408: LD_VAR 0 1
48412: NOT
48413: PUSH
48414: LD_VAR 0 2
48418: NOT
48419: OR
48420: IFFALSE 48424
// exit ;
48422: GO 48582
// x := GetX ( building ) ;
48424: LD_ADDR_VAR 0 5
48428: PUSH
48429: LD_VAR 0 2
48433: PPUSH
48434: CALL_OW 250
48438: ST_TO_ADDR
// y := GetY ( building ) ;
48439: LD_ADDR_VAR 0 6
48443: PUSH
48444: LD_VAR 0 2
48448: PPUSH
48449: CALL_OW 251
48453: ST_TO_ADDR
// for i = 0 to 5 do
48454: LD_ADDR_VAR 0 4
48458: PUSH
48459: DOUBLE
48460: LD_INT 0
48462: DEC
48463: ST_TO_ADDR
48464: LD_INT 5
48466: PUSH
48467: FOR_TO
48468: IFFALSE 48580
// begin _x := ShiftX ( x , i , 3 ) ;
48470: LD_ADDR_VAR 0 7
48474: PUSH
48475: LD_VAR 0 5
48479: PPUSH
48480: LD_VAR 0 4
48484: PPUSH
48485: LD_INT 3
48487: PPUSH
48488: CALL_OW 272
48492: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48493: LD_ADDR_VAR 0 8
48497: PUSH
48498: LD_VAR 0 6
48502: PPUSH
48503: LD_VAR 0 4
48507: PPUSH
48508: LD_INT 3
48510: PPUSH
48511: CALL_OW 273
48515: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48516: LD_VAR 0 7
48520: PPUSH
48521: LD_VAR 0 8
48525: PPUSH
48526: CALL_OW 488
48530: NOT
48531: IFFALSE 48535
// continue ;
48533: GO 48467
// if HexInfo ( _x , _y ) = 0 then
48535: LD_VAR 0 7
48539: PPUSH
48540: LD_VAR 0 8
48544: PPUSH
48545: CALL_OW 428
48549: PUSH
48550: LD_INT 0
48552: EQUAL
48553: IFFALSE 48578
// begin ComMoveXY ( unit , _x , _y ) ;
48555: LD_VAR 0 1
48559: PPUSH
48560: LD_VAR 0 7
48564: PPUSH
48565: LD_VAR 0 8
48569: PPUSH
48570: CALL_OW 111
// exit ;
48574: POP
48575: POP
48576: GO 48582
// end ; end ;
48578: GO 48467
48580: POP
48581: POP
// end ;
48582: LD_VAR 0 3
48586: RET
// export function ScanBase ( side , base_area ) ; begin
48587: LD_INT 0
48589: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48590: LD_ADDR_VAR 0 3
48594: PUSH
48595: LD_VAR 0 2
48599: PPUSH
48600: LD_INT 81
48602: PUSH
48603: LD_VAR 0 1
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: PPUSH
48612: CALL_OW 70
48616: ST_TO_ADDR
// end ;
48617: LD_VAR 0 3
48621: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48622: LD_INT 0
48624: PPUSH
48625: PPUSH
48626: PPUSH
48627: PPUSH
48628: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48629: LD_VAR 0 1
48633: NOT
48634: PUSH
48635: LD_EXP 49
48639: PUSH
48640: LD_VAR 0 1
48644: ARRAY
48645: NOT
48646: OR
48647: PUSH
48648: LD_VAR 0 2
48652: NOT
48653: OR
48654: PUSH
48655: LD_VAR 0 3
48659: NOT
48660: OR
48661: IFFALSE 48665
// exit ;
48663: GO 49178
// side := mc_sides [ base ] ;
48665: LD_ADDR_VAR 0 6
48669: PUSH
48670: LD_EXP 75
48674: PUSH
48675: LD_VAR 0 1
48679: ARRAY
48680: ST_TO_ADDR
// if not side then
48681: LD_VAR 0 6
48685: NOT
48686: IFFALSE 48690
// exit ;
48688: GO 49178
// for i in solds do
48690: LD_ADDR_VAR 0 7
48694: PUSH
48695: LD_VAR 0 2
48699: PUSH
48700: FOR_IN
48701: IFFALSE 48762
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
48703: LD_VAR 0 7
48707: PPUSH
48708: CALL_OW 310
48712: PPUSH
48713: CALL_OW 266
48717: PUSH
48718: LD_INT 32
48720: PUSH
48721: LD_INT 31
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: IN
48728: IFFALSE 48748
// solds := solds diff i else
48730: LD_ADDR_VAR 0 2
48734: PUSH
48735: LD_VAR 0 2
48739: PUSH
48740: LD_VAR 0 7
48744: DIFF
48745: ST_TO_ADDR
48746: GO 48760
// SetTag ( i , 18 ) ;
48748: LD_VAR 0 7
48752: PPUSH
48753: LD_INT 18
48755: PPUSH
48756: CALL_OW 109
48760: GO 48700
48762: POP
48763: POP
// if not solds then
48764: LD_VAR 0 2
48768: NOT
48769: IFFALSE 48773
// exit ;
48771: GO 49178
// repeat wait ( 0 0$1 ) ;
48773: LD_INT 35
48775: PPUSH
48776: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
48780: LD_ADDR_VAR 0 5
48784: PUSH
48785: LD_VAR 0 6
48789: PPUSH
48790: LD_VAR 0 3
48794: PPUSH
48795: CALL 48587 0 2
48799: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
48800: LD_EXP 49
48804: PUSH
48805: LD_VAR 0 1
48809: ARRAY
48810: NOT
48811: PUSH
48812: LD_EXP 49
48816: PUSH
48817: LD_VAR 0 1
48821: ARRAY
48822: PUSH
48823: EMPTY
48824: EQUAL
48825: OR
48826: IFFALSE 48863
// begin for i in solds do
48828: LD_ADDR_VAR 0 7
48832: PUSH
48833: LD_VAR 0 2
48837: PUSH
48838: FOR_IN
48839: IFFALSE 48852
// ComStop ( i ) ;
48841: LD_VAR 0 7
48845: PPUSH
48846: CALL_OW 141
48850: GO 48838
48852: POP
48853: POP
// solds := [ ] ;
48854: LD_ADDR_VAR 0 2
48858: PUSH
48859: EMPTY
48860: ST_TO_ADDR
// exit ;
48861: GO 49178
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
48863: LD_VAR 0 5
48867: NOT
48868: PUSH
48869: LD_VAR 0 5
48873: PUSH
48874: LD_INT 3
48876: GREATER
48877: OR
48878: PUSH
48879: LD_EXP 71
48883: PUSH
48884: LD_VAR 0 1
48888: ARRAY
48889: OR
48890: IFFALSE 48931
// begin for i in solds do
48892: LD_ADDR_VAR 0 7
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: FOR_IN
48903: IFFALSE 48927
// if HasTask ( i ) then
48905: LD_VAR 0 7
48909: PPUSH
48910: CALL_OW 314
48914: IFFALSE 48925
// ComStop ( i ) ;
48916: LD_VAR 0 7
48920: PPUSH
48921: CALL_OW 141
48925: GO 48902
48927: POP
48928: POP
// break ;
48929: GO 49166
// end ; for i in solds do
48931: LD_ADDR_VAR 0 7
48935: PUSH
48936: LD_VAR 0 2
48940: PUSH
48941: FOR_IN
48942: IFFALSE 49158
// begin if IsInUnit ( i ) then
48944: LD_VAR 0 7
48948: PPUSH
48949: CALL_OW 310
48953: IFFALSE 48964
// ComExitBuilding ( i ) ;
48955: LD_VAR 0 7
48959: PPUSH
48960: CALL_OW 122
// if GetLives ( i ) > 333 then
48964: LD_VAR 0 7
48968: PPUSH
48969: CALL_OW 256
48973: PUSH
48974: LD_INT 333
48976: GREATER
48977: IFFALSE 49005
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
48979: LD_VAR 0 7
48983: PPUSH
48984: LD_VAR 0 5
48988: PPUSH
48989: LD_VAR 0 7
48993: PPUSH
48994: CALL_OW 74
48998: PPUSH
48999: CALL_OW 115
49003: GO 49156
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49005: LD_ADDR_VAR 0 8
49009: PUSH
49010: LD_EXP 49
49014: PUSH
49015: LD_VAR 0 1
49019: ARRAY
49020: PPUSH
49021: LD_INT 2
49023: PUSH
49024: LD_INT 30
49026: PUSH
49027: LD_INT 0
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: PUSH
49034: LD_INT 30
49036: PUSH
49037: LD_INT 1
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 30
49046: PUSH
49047: LD_INT 6
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: PPUSH
49060: CALL_OW 72
49064: PPUSH
49065: LD_VAR 0 7
49069: PPUSH
49070: CALL_OW 74
49074: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49075: LD_VAR 0 7
49079: PPUSH
49080: LD_VAR 0 8
49084: PPUSH
49085: CALL_OW 250
49089: PPUSH
49090: LD_INT 3
49092: PPUSH
49093: LD_INT 5
49095: PPUSH
49096: CALL_OW 272
49100: PPUSH
49101: LD_VAR 0 8
49105: PPUSH
49106: CALL_OW 251
49110: PPUSH
49111: LD_INT 3
49113: PPUSH
49114: LD_INT 5
49116: PPUSH
49117: CALL_OW 273
49121: PPUSH
49122: CALL_OW 111
// SetTag ( i , 0 ) ;
49126: LD_VAR 0 7
49130: PPUSH
49131: LD_INT 0
49133: PPUSH
49134: CALL_OW 109
// solds := solds diff i ;
49138: LD_ADDR_VAR 0 2
49142: PUSH
49143: LD_VAR 0 2
49147: PUSH
49148: LD_VAR 0 7
49152: DIFF
49153: ST_TO_ADDR
// continue ;
49154: GO 48941
// end ; end ;
49156: GO 48941
49158: POP
49159: POP
// until solds ;
49160: LD_VAR 0 2
49164: IFFALSE 48773
// MC_Reset ( base , 18 ) ;
49166: LD_VAR 0 1
49170: PPUSH
49171: LD_INT 18
49173: PPUSH
49174: CALL 20895 0 2
// end ;
49178: LD_VAR 0 4
49182: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49183: LD_INT 0
49185: PPUSH
49186: PPUSH
49187: PPUSH
49188: PPUSH
49189: PPUSH
49190: PPUSH
49191: PPUSH
49192: PPUSH
49193: PPUSH
49194: PPUSH
49195: PPUSH
49196: PPUSH
49197: PPUSH
49198: PPUSH
49199: PPUSH
49200: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49201: LD_ADDR_VAR 0 12
49205: PUSH
49206: LD_EXP 49
49210: PUSH
49211: LD_VAR 0 1
49215: ARRAY
49216: PPUSH
49217: LD_INT 25
49219: PUSH
49220: LD_INT 3
49222: PUSH
49223: EMPTY
49224: LIST
49225: LIST
49226: PPUSH
49227: CALL_OW 72
49231: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49232: LD_EXP 89
49236: PUSH
49237: LD_VAR 0 1
49241: ARRAY
49242: IFFALSE 49266
// mechs := mechs diff mc_remote_driver [ base ] ;
49244: LD_ADDR_VAR 0 12
49248: PUSH
49249: LD_VAR 0 12
49253: PUSH
49254: LD_EXP 89
49258: PUSH
49259: LD_VAR 0 1
49263: ARRAY
49264: DIFF
49265: ST_TO_ADDR
// for i in mechs do
49266: LD_ADDR_VAR 0 5
49270: PUSH
49271: LD_VAR 0 12
49275: PUSH
49276: FOR_IN
49277: IFFALSE 49312
// if GetTag ( i ) > 0 then
49279: LD_VAR 0 5
49283: PPUSH
49284: CALL_OW 110
49288: PUSH
49289: LD_INT 0
49291: GREATER
49292: IFFALSE 49310
// mechs := mechs diff i ;
49294: LD_ADDR_VAR 0 12
49298: PUSH
49299: LD_VAR 0 12
49303: PUSH
49304: LD_VAR 0 5
49308: DIFF
49309: ST_TO_ADDR
49310: GO 49276
49312: POP
49313: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49314: LD_ADDR_VAR 0 8
49318: PUSH
49319: LD_EXP 49
49323: PUSH
49324: LD_VAR 0 1
49328: ARRAY
49329: PPUSH
49330: LD_INT 2
49332: PUSH
49333: LD_INT 25
49335: PUSH
49336: LD_INT 1
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PUSH
49343: LD_INT 25
49345: PUSH
49346: LD_INT 5
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: PUSH
49353: LD_INT 25
49355: PUSH
49356: LD_INT 8
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: PUSH
49363: LD_INT 25
49365: PUSH
49366: LD_INT 9
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: EMPTY
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: PPUSH
49380: CALL_OW 72
49384: ST_TO_ADDR
// if not defenders and not solds then
49385: LD_VAR 0 2
49389: NOT
49390: PUSH
49391: LD_VAR 0 8
49395: NOT
49396: AND
49397: IFFALSE 49401
// exit ;
49399: GO 50939
// depot_under_attack := false ;
49401: LD_ADDR_VAR 0 16
49405: PUSH
49406: LD_INT 0
49408: ST_TO_ADDR
// sold_defenders := [ ] ;
49409: LD_ADDR_VAR 0 17
49413: PUSH
49414: EMPTY
49415: ST_TO_ADDR
// if mechs then
49416: LD_VAR 0 12
49420: IFFALSE 49549
// for i in defenders do
49422: LD_ADDR_VAR 0 5
49426: PUSH
49427: LD_VAR 0 2
49431: PUSH
49432: FOR_IN
49433: IFFALSE 49547
// begin SetTag ( i , 20 ) ;
49435: LD_VAR 0 5
49439: PPUSH
49440: LD_INT 20
49442: PPUSH
49443: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49447: LD_VAR 0 5
49451: PPUSH
49452: CALL_OW 263
49456: PUSH
49457: LD_INT 1
49459: EQUAL
49460: PUSH
49461: LD_VAR 0 5
49465: PPUSH
49466: CALL_OW 311
49470: NOT
49471: AND
49472: PUSH
49473: LD_VAR 0 12
49477: AND
49478: IFFALSE 49545
// begin un := mechs [ 1 ] ;
49480: LD_ADDR_VAR 0 10
49484: PUSH
49485: LD_VAR 0 12
49489: PUSH
49490: LD_INT 1
49492: ARRAY
49493: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49494: LD_VAR 0 10
49498: PPUSH
49499: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49503: LD_VAR 0 10
49507: PPUSH
49508: LD_VAR 0 5
49512: PPUSH
49513: CALL_OW 180
// SetTag ( un , 19 ) ;
49517: LD_VAR 0 10
49521: PPUSH
49522: LD_INT 19
49524: PPUSH
49525: CALL_OW 109
// mechs := mechs diff un ;
49529: LD_ADDR_VAR 0 12
49533: PUSH
49534: LD_VAR 0 12
49538: PUSH
49539: LD_VAR 0 10
49543: DIFF
49544: ST_TO_ADDR
// end ; end ;
49545: GO 49432
49547: POP
49548: POP
// if solds then
49549: LD_VAR 0 8
49553: IFFALSE 49612
// for i in solds do
49555: LD_ADDR_VAR 0 5
49559: PUSH
49560: LD_VAR 0 8
49564: PUSH
49565: FOR_IN
49566: IFFALSE 49610
// if not GetTag ( i ) then
49568: LD_VAR 0 5
49572: PPUSH
49573: CALL_OW 110
49577: NOT
49578: IFFALSE 49608
// begin defenders := defenders union i ;
49580: LD_ADDR_VAR 0 2
49584: PUSH
49585: LD_VAR 0 2
49589: PUSH
49590: LD_VAR 0 5
49594: UNION
49595: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49596: LD_VAR 0 5
49600: PPUSH
49601: LD_INT 18
49603: PPUSH
49604: CALL_OW 109
// end ;
49608: GO 49565
49610: POP
49611: POP
// repeat wait ( 0 0$1 ) ;
49612: LD_INT 35
49614: PPUSH
49615: CALL_OW 67
// enemy := mc_scan [ base ] ;
49619: LD_ADDR_VAR 0 3
49623: PUSH
49624: LD_EXP 72
49628: PUSH
49629: LD_VAR 0 1
49633: ARRAY
49634: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49635: LD_EXP 49
49639: PUSH
49640: LD_VAR 0 1
49644: ARRAY
49645: NOT
49646: PUSH
49647: LD_EXP 49
49651: PUSH
49652: LD_VAR 0 1
49656: ARRAY
49657: PUSH
49658: EMPTY
49659: EQUAL
49660: OR
49661: IFFALSE 49698
// begin for i in defenders do
49663: LD_ADDR_VAR 0 5
49667: PUSH
49668: LD_VAR 0 2
49672: PUSH
49673: FOR_IN
49674: IFFALSE 49687
// ComStop ( i ) ;
49676: LD_VAR 0 5
49680: PPUSH
49681: CALL_OW 141
49685: GO 49673
49687: POP
49688: POP
// defenders := [ ] ;
49689: LD_ADDR_VAR 0 2
49693: PUSH
49694: EMPTY
49695: ST_TO_ADDR
// exit ;
49696: GO 50939
// end ; for i in defenders do
49698: LD_ADDR_VAR 0 5
49702: PUSH
49703: LD_VAR 0 2
49707: PUSH
49708: FOR_IN
49709: IFFALSE 50439
// begin e := NearestUnitToUnit ( enemy , i ) ;
49711: LD_ADDR_VAR 0 13
49715: PUSH
49716: LD_VAR 0 3
49720: PPUSH
49721: LD_VAR 0 5
49725: PPUSH
49726: CALL_OW 74
49730: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
49731: LD_ADDR_VAR 0 16
49735: PUSH
49736: LD_EXP 49
49740: PUSH
49741: LD_VAR 0 1
49745: ARRAY
49746: PPUSH
49747: LD_INT 2
49749: PUSH
49750: LD_INT 30
49752: PUSH
49753: LD_INT 0
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: LD_INT 30
49762: PUSH
49763: LD_INT 1
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: LIST
49774: PPUSH
49775: CALL_OW 72
49779: NOT
49780: PUSH
49781: LD_EXP 49
49785: PUSH
49786: LD_VAR 0 1
49790: ARRAY
49791: PPUSH
49792: LD_INT 2
49794: PUSH
49795: LD_INT 30
49797: PUSH
49798: LD_INT 0
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 30
49807: PUSH
49808: LD_INT 1
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: LIST
49819: PPUSH
49820: CALL_OW 72
49824: PPUSH
49825: CALL_OW 256
49829: PUSH
49830: LD_INT 600
49832: LESS
49833: OR
49834: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
49835: LD_VAR 0 5
49839: PPUSH
49840: CALL_OW 247
49844: PUSH
49845: LD_INT 2
49847: DOUBLE
49848: EQUAL
49849: IFTRUE 49853
49851: GO 50145
49853: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
49854: LD_VAR 0 5
49858: PPUSH
49859: CALL_OW 256
49863: PUSH
49864: LD_INT 650
49866: GREATER
49867: PUSH
49868: LD_VAR 0 5
49872: PPUSH
49873: LD_VAR 0 13
49877: PPUSH
49878: CALL_OW 296
49882: PUSH
49883: LD_INT 40
49885: LESS
49886: PUSH
49887: LD_VAR 0 13
49891: PPUSH
49892: LD_EXP 74
49896: PUSH
49897: LD_VAR 0 1
49901: ARRAY
49902: PPUSH
49903: CALL_OW 308
49907: OR
49908: AND
49909: IFFALSE 49927
// ComAttackUnit ( i , e ) else
49911: LD_VAR 0 5
49915: PPUSH
49916: LD_VAR 0 13
49920: PPUSH
49921: CALL_OW 115
49925: GO 50028
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
49927: LD_VAR 0 13
49931: PPUSH
49932: LD_EXP 74
49936: PUSH
49937: LD_VAR 0 1
49941: ARRAY
49942: PPUSH
49943: CALL_OW 308
49947: NOT
49948: PUSH
49949: LD_VAR 0 5
49953: PPUSH
49954: LD_VAR 0 13
49958: PPUSH
49959: CALL_OW 296
49963: PUSH
49964: LD_INT 40
49966: GREATEREQUAL
49967: AND
49968: PUSH
49969: LD_VAR 0 5
49973: PPUSH
49974: CALL_OW 256
49978: PUSH
49979: LD_INT 650
49981: LESSEQUAL
49982: OR
49983: PUSH
49984: LD_VAR 0 5
49988: PPUSH
49989: LD_EXP 73
49993: PUSH
49994: LD_VAR 0 1
49998: ARRAY
49999: PPUSH
50000: CALL_OW 308
50004: NOT
50005: AND
50006: IFFALSE 50028
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50008: LD_VAR 0 5
50012: PPUSH
50013: LD_EXP 73
50017: PUSH
50018: LD_VAR 0 1
50022: ARRAY
50023: PPUSH
50024: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50028: LD_VAR 0 5
50032: PPUSH
50033: CALL_OW 256
50037: PUSH
50038: LD_INT 998
50040: LESS
50041: PUSH
50042: LD_VAR 0 5
50046: PPUSH
50047: CALL_OW 263
50051: PUSH
50052: LD_INT 1
50054: EQUAL
50055: AND
50056: PUSH
50057: LD_VAR 0 5
50061: PPUSH
50062: CALL_OW 311
50066: AND
50067: PUSH
50068: LD_VAR 0 5
50072: PPUSH
50073: LD_EXP 73
50077: PUSH
50078: LD_VAR 0 1
50082: ARRAY
50083: PPUSH
50084: CALL_OW 308
50088: AND
50089: IFFALSE 50143
// begin mech := IsDrivenBy ( i ) ;
50091: LD_ADDR_VAR 0 9
50095: PUSH
50096: LD_VAR 0 5
50100: PPUSH
50101: CALL_OW 311
50105: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50106: LD_VAR 0 9
50110: PPUSH
50111: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50115: LD_VAR 0 9
50119: PPUSH
50120: LD_VAR 0 5
50124: PPUSH
50125: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50129: LD_VAR 0 9
50133: PPUSH
50134: LD_VAR 0 5
50138: PPUSH
50139: CALL_OW 180
// end ; end ; unit_human :
50143: GO 50410
50145: LD_INT 1
50147: DOUBLE
50148: EQUAL
50149: IFTRUE 50153
50151: GO 50409
50153: POP
// begin b := IsInUnit ( i ) ;
50154: LD_ADDR_VAR 0 18
50158: PUSH
50159: LD_VAR 0 5
50163: PPUSH
50164: CALL_OW 310
50168: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50169: LD_ADDR_VAR 0 19
50173: PUSH
50174: LD_VAR 0 18
50178: NOT
50179: PUSH
50180: LD_VAR 0 18
50184: PPUSH
50185: CALL_OW 266
50189: PUSH
50190: LD_INT 32
50192: PUSH
50193: LD_INT 31
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: IN
50200: OR
50201: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50202: LD_VAR 0 16
50206: PUSH
50207: LD_VAR 0 2
50211: PPUSH
50212: LD_INT 21
50214: PUSH
50215: LD_INT 2
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: PPUSH
50222: CALL_OW 72
50226: PUSH
50227: LD_INT 1
50229: LESSEQUAL
50230: OR
50231: PUSH
50232: LD_VAR 0 19
50236: AND
50237: PUSH
50238: LD_VAR 0 5
50242: PUSH
50243: LD_VAR 0 17
50247: IN
50248: NOT
50249: AND
50250: IFFALSE 50343
// begin if b then
50252: LD_VAR 0 18
50256: IFFALSE 50305
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50258: LD_VAR 0 18
50262: PPUSH
50263: LD_VAR 0 3
50267: PPUSH
50268: LD_VAR 0 18
50272: PPUSH
50273: CALL_OW 74
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 10
50285: LESS
50286: PUSH
50287: LD_VAR 0 18
50291: PPUSH
50292: CALL_OW 461
50296: PUSH
50297: LD_INT 7
50299: NONEQUAL
50300: AND
50301: IFFALSE 50305
// continue ;
50303: GO 49708
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50305: LD_ADDR_VAR 0 17
50309: PUSH
50310: LD_VAR 0 17
50314: PPUSH
50315: LD_VAR 0 17
50319: PUSH
50320: LD_INT 1
50322: PLUS
50323: PPUSH
50324: LD_VAR 0 5
50328: PPUSH
50329: CALL_OW 1
50333: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50334: LD_VAR 0 5
50338: PPUSH
50339: CALL_OW 122
// end ; if sold_defenders then
50343: LD_VAR 0 17
50347: IFFALSE 50407
// if i in sold_defenders then
50349: LD_VAR 0 5
50353: PUSH
50354: LD_VAR 0 17
50358: IN
50359: IFFALSE 50407
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50361: LD_VAR 0 5
50365: PPUSH
50366: CALL_OW 314
50370: NOT
50371: PUSH
50372: LD_VAR 0 5
50376: PPUSH
50377: LD_VAR 0 13
50381: PPUSH
50382: CALL_OW 296
50386: PUSH
50387: LD_INT 30
50389: LESS
50390: AND
50391: IFFALSE 50407
// ComAttackUnit ( i , e ) ;
50393: LD_VAR 0 5
50397: PPUSH
50398: LD_VAR 0 13
50402: PPUSH
50403: CALL_OW 115
// end ; end ; end ;
50407: GO 50410
50409: POP
// if IsDead ( i ) then
50410: LD_VAR 0 5
50414: PPUSH
50415: CALL_OW 301
50419: IFFALSE 50437
// defenders := defenders diff i ;
50421: LD_ADDR_VAR 0 2
50425: PUSH
50426: LD_VAR 0 2
50430: PUSH
50431: LD_VAR 0 5
50435: DIFF
50436: ST_TO_ADDR
// end ;
50437: GO 49708
50439: POP
50440: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50441: LD_VAR 0 3
50445: NOT
50446: PUSH
50447: LD_VAR 0 2
50451: NOT
50452: OR
50453: PUSH
50454: LD_EXP 49
50458: PUSH
50459: LD_VAR 0 1
50463: ARRAY
50464: NOT
50465: OR
50466: IFFALSE 49612
// MC_Reset ( base , 18 ) ;
50468: LD_VAR 0 1
50472: PPUSH
50473: LD_INT 18
50475: PPUSH
50476: CALL 20895 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50480: LD_ADDR_VAR 0 2
50484: PUSH
50485: LD_VAR 0 2
50489: PUSH
50490: LD_VAR 0 2
50494: PPUSH
50495: LD_INT 2
50497: PUSH
50498: LD_INT 25
50500: PUSH
50501: LD_INT 1
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PUSH
50508: LD_INT 25
50510: PUSH
50511: LD_INT 5
50513: PUSH
50514: EMPTY
50515: LIST
50516: LIST
50517: PUSH
50518: LD_INT 25
50520: PUSH
50521: LD_INT 8
50523: PUSH
50524: EMPTY
50525: LIST
50526: LIST
50527: PUSH
50528: LD_INT 25
50530: PUSH
50531: LD_INT 9
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: PPUSH
50545: CALL_OW 72
50549: DIFF
50550: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50551: LD_VAR 0 3
50555: NOT
50556: PUSH
50557: LD_VAR 0 2
50561: PPUSH
50562: LD_INT 21
50564: PUSH
50565: LD_INT 2
50567: PUSH
50568: EMPTY
50569: LIST
50570: LIST
50571: PPUSH
50572: CALL_OW 72
50576: AND
50577: IFFALSE 50915
// begin tmp := FilterByTag ( defenders , 19 ) ;
50579: LD_ADDR_VAR 0 11
50583: PUSH
50584: LD_VAR 0 2
50588: PPUSH
50589: LD_INT 19
50591: PPUSH
50592: CALL 87368 0 2
50596: ST_TO_ADDR
// if tmp then
50597: LD_VAR 0 11
50601: IFFALSE 50671
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
50603: LD_ADDR_VAR 0 11
50607: PUSH
50608: LD_VAR 0 11
50612: PPUSH
50613: LD_INT 25
50615: PUSH
50616: LD_INT 3
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: CALL_OW 72
50627: ST_TO_ADDR
// if tmp then
50628: LD_VAR 0 11
50632: IFFALSE 50671
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
50634: LD_ADDR_EXP 61
50638: PUSH
50639: LD_EXP 61
50643: PPUSH
50644: LD_VAR 0 1
50648: PPUSH
50649: LD_EXP 61
50653: PUSH
50654: LD_VAR 0 1
50658: ARRAY
50659: PUSH
50660: LD_VAR 0 11
50664: UNION
50665: PPUSH
50666: CALL_OW 1
50670: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
50671: LD_VAR 0 1
50675: PPUSH
50676: LD_INT 19
50678: PPUSH
50679: CALL 20895 0 2
// repeat wait ( 0 0$1 ) ;
50683: LD_INT 35
50685: PPUSH
50686: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
50690: LD_EXP 49
50694: PUSH
50695: LD_VAR 0 1
50699: ARRAY
50700: NOT
50701: PUSH
50702: LD_EXP 49
50706: PUSH
50707: LD_VAR 0 1
50711: ARRAY
50712: PUSH
50713: EMPTY
50714: EQUAL
50715: OR
50716: IFFALSE 50753
// begin for i in defenders do
50718: LD_ADDR_VAR 0 5
50722: PUSH
50723: LD_VAR 0 2
50727: PUSH
50728: FOR_IN
50729: IFFALSE 50742
// ComStop ( i ) ;
50731: LD_VAR 0 5
50735: PPUSH
50736: CALL_OW 141
50740: GO 50728
50742: POP
50743: POP
// defenders := [ ] ;
50744: LD_ADDR_VAR 0 2
50748: PUSH
50749: EMPTY
50750: ST_TO_ADDR
// exit ;
50751: GO 50939
// end ; for i in defenders do
50753: LD_ADDR_VAR 0 5
50757: PUSH
50758: LD_VAR 0 2
50762: PUSH
50763: FOR_IN
50764: IFFALSE 50853
// begin if not IsInArea ( i , mc_parking [ base ] ) then
50766: LD_VAR 0 5
50770: PPUSH
50771: LD_EXP 73
50775: PUSH
50776: LD_VAR 0 1
50780: ARRAY
50781: PPUSH
50782: CALL_OW 308
50786: NOT
50787: IFFALSE 50811
// ComMoveToArea ( i , mc_parking [ base ] ) else
50789: LD_VAR 0 5
50793: PPUSH
50794: LD_EXP 73
50798: PUSH
50799: LD_VAR 0 1
50803: ARRAY
50804: PPUSH
50805: CALL_OW 113
50809: GO 50851
// if GetControl ( i ) = control_manual then
50811: LD_VAR 0 5
50815: PPUSH
50816: CALL_OW 263
50820: PUSH
50821: LD_INT 1
50823: EQUAL
50824: IFFALSE 50851
// if IsDrivenBy ( i ) then
50826: LD_VAR 0 5
50830: PPUSH
50831: CALL_OW 311
50835: IFFALSE 50851
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
50837: LD_VAR 0 5
50841: PPUSH
50842: CALL_OW 311
50846: PPUSH
50847: CALL_OW 121
// end ;
50851: GO 50763
50853: POP
50854: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
50855: LD_VAR 0 2
50859: PPUSH
50860: LD_INT 95
50862: PUSH
50863: LD_EXP 73
50867: PUSH
50868: LD_VAR 0 1
50872: ARRAY
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PPUSH
50878: CALL_OW 72
50882: PUSH
50883: LD_VAR 0 2
50887: EQUAL
50888: PUSH
50889: LD_EXP 72
50893: PUSH
50894: LD_VAR 0 1
50898: ARRAY
50899: OR
50900: PUSH
50901: LD_EXP 49
50905: PUSH
50906: LD_VAR 0 1
50910: ARRAY
50911: NOT
50912: OR
50913: IFFALSE 50683
// end ; MC_Reset ( base , 19 ) ;
50915: LD_VAR 0 1
50919: PPUSH
50920: LD_INT 19
50922: PPUSH
50923: CALL 20895 0 2
// MC_Reset ( base , 20 ) ;
50927: LD_VAR 0 1
50931: PPUSH
50932: LD_INT 20
50934: PPUSH
50935: CALL 20895 0 2
// end ;
50939: LD_VAR 0 4
50943: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50944: LD_INT 0
50946: PPUSH
50947: PPUSH
50948: PPUSH
50949: PPUSH
// result := false ;
50950: LD_ADDR_VAR 0 2
50954: PUSH
50955: LD_INT 0
50957: ST_TO_ADDR
// side := GetSide ( unit ) ;
50958: LD_ADDR_VAR 0 3
50962: PUSH
50963: LD_VAR 0 1
50967: PPUSH
50968: CALL_OW 255
50972: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50973: LD_ADDR_VAR 0 4
50977: PUSH
50978: LD_VAR 0 1
50982: PPUSH
50983: CALL_OW 248
50987: ST_TO_ADDR
// case nat of 1 :
50988: LD_VAR 0 4
50992: PUSH
50993: LD_INT 1
50995: DOUBLE
50996: EQUAL
50997: IFTRUE 51001
50999: GO 51012
51001: POP
// tech := tech_lassight ; 2 :
51002: LD_ADDR_VAR 0 5
51006: PUSH
51007: LD_INT 12
51009: ST_TO_ADDR
51010: GO 51051
51012: LD_INT 2
51014: DOUBLE
51015: EQUAL
51016: IFTRUE 51020
51018: GO 51031
51020: POP
// tech := tech_mortar ; 3 :
51021: LD_ADDR_VAR 0 5
51025: PUSH
51026: LD_INT 41
51028: ST_TO_ADDR
51029: GO 51051
51031: LD_INT 3
51033: DOUBLE
51034: EQUAL
51035: IFTRUE 51039
51037: GO 51050
51039: POP
// tech := tech_bazooka ; end ;
51040: LD_ADDR_VAR 0 5
51044: PUSH
51045: LD_INT 44
51047: ST_TO_ADDR
51048: GO 51051
51050: POP
// if Researched ( side , tech ) then
51051: LD_VAR 0 3
51055: PPUSH
51056: LD_VAR 0 5
51060: PPUSH
51061: CALL_OW 325
51065: IFFALSE 51092
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51067: LD_ADDR_VAR 0 2
51071: PUSH
51072: LD_INT 5
51074: PUSH
51075: LD_INT 8
51077: PUSH
51078: LD_INT 9
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: LIST
51085: PUSH
51086: LD_VAR 0 4
51090: ARRAY
51091: ST_TO_ADDR
// end ;
51092: LD_VAR 0 2
51096: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51097: LD_INT 0
51099: PPUSH
51100: PPUSH
51101: PPUSH
// if not mines then
51102: LD_VAR 0 2
51106: NOT
51107: IFFALSE 51111
// exit ;
51109: GO 51255
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51111: LD_ADDR_VAR 0 5
51115: PUSH
51116: LD_INT 81
51118: PUSH
51119: LD_VAR 0 1
51123: PUSH
51124: EMPTY
51125: LIST
51126: LIST
51127: PUSH
51128: LD_INT 3
51130: PUSH
51131: LD_INT 21
51133: PUSH
51134: LD_INT 3
51136: PUSH
51137: EMPTY
51138: LIST
51139: LIST
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: PPUSH
51149: CALL_OW 69
51153: ST_TO_ADDR
// for i in mines do
51154: LD_ADDR_VAR 0 4
51158: PUSH
51159: LD_VAR 0 2
51163: PUSH
51164: FOR_IN
51165: IFFALSE 51253
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51167: LD_VAR 0 4
51171: PUSH
51172: LD_INT 1
51174: ARRAY
51175: PPUSH
51176: LD_VAR 0 4
51180: PUSH
51181: LD_INT 2
51183: ARRAY
51184: PPUSH
51185: CALL_OW 458
51189: NOT
51190: IFFALSE 51194
// continue ;
51192: GO 51164
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51194: LD_VAR 0 4
51198: PUSH
51199: LD_INT 1
51201: ARRAY
51202: PPUSH
51203: LD_VAR 0 4
51207: PUSH
51208: LD_INT 2
51210: ARRAY
51211: PPUSH
51212: CALL_OW 428
51216: PUSH
51217: LD_VAR 0 5
51221: IN
51222: IFFALSE 51251
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51224: LD_VAR 0 4
51228: PUSH
51229: LD_INT 1
51231: ARRAY
51232: PPUSH
51233: LD_VAR 0 4
51237: PUSH
51238: LD_INT 2
51240: ARRAY
51241: PPUSH
51242: LD_VAR 0 1
51246: PPUSH
51247: CALL_OW 456
// end ;
51251: GO 51164
51253: POP
51254: POP
// end ;
51255: LD_VAR 0 3
51259: RET
// export function Count ( array ) ; var i ; begin
51260: LD_INT 0
51262: PPUSH
51263: PPUSH
// result := 0 ;
51264: LD_ADDR_VAR 0 2
51268: PUSH
51269: LD_INT 0
51271: ST_TO_ADDR
// for i in array do
51272: LD_ADDR_VAR 0 3
51276: PUSH
51277: LD_VAR 0 1
51281: PUSH
51282: FOR_IN
51283: IFFALSE 51307
// if i then
51285: LD_VAR 0 3
51289: IFFALSE 51305
// result := result + 1 ;
51291: LD_ADDR_VAR 0 2
51295: PUSH
51296: LD_VAR 0 2
51300: PUSH
51301: LD_INT 1
51303: PLUS
51304: ST_TO_ADDR
51305: GO 51282
51307: POP
51308: POP
// end ;
51309: LD_VAR 0 2
51313: RET
// export function IsEmpty ( building ) ; begin
51314: LD_INT 0
51316: PPUSH
// if not building then
51317: LD_VAR 0 1
51321: NOT
51322: IFFALSE 51326
// exit ;
51324: GO 51369
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51326: LD_ADDR_VAR 0 2
51330: PUSH
51331: LD_VAR 0 1
51335: PUSH
51336: LD_INT 22
51338: PUSH
51339: LD_VAR 0 1
51343: PPUSH
51344: CALL_OW 255
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: PUSH
51353: LD_INT 58
51355: PUSH
51356: EMPTY
51357: LIST
51358: PUSH
51359: EMPTY
51360: LIST
51361: LIST
51362: PPUSH
51363: CALL_OW 69
51367: IN
51368: ST_TO_ADDR
// end ;
51369: LD_VAR 0 2
51373: RET
// export function IsNotFull ( building ) ; begin
51374: LD_INT 0
51376: PPUSH
// if not building then
51377: LD_VAR 0 1
51381: NOT
51382: IFFALSE 51386
// exit ;
51384: GO 51405
// result := UnitsInside ( building ) < 6 ;
51386: LD_ADDR_VAR 0 2
51390: PUSH
51391: LD_VAR 0 1
51395: PPUSH
51396: CALL_OW 313
51400: PUSH
51401: LD_INT 6
51403: LESS
51404: ST_TO_ADDR
// end ;
51405: LD_VAR 0 2
51409: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51410: LD_INT 0
51412: PPUSH
51413: PPUSH
51414: PPUSH
51415: PPUSH
// tmp := [ ] ;
51416: LD_ADDR_VAR 0 3
51420: PUSH
51421: EMPTY
51422: ST_TO_ADDR
// list := [ ] ;
51423: LD_ADDR_VAR 0 5
51427: PUSH
51428: EMPTY
51429: ST_TO_ADDR
// for i = 16 to 25 do
51430: LD_ADDR_VAR 0 4
51434: PUSH
51435: DOUBLE
51436: LD_INT 16
51438: DEC
51439: ST_TO_ADDR
51440: LD_INT 25
51442: PUSH
51443: FOR_TO
51444: IFFALSE 51517
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51446: LD_ADDR_VAR 0 3
51450: PUSH
51451: LD_VAR 0 3
51455: PUSH
51456: LD_INT 22
51458: PUSH
51459: LD_VAR 0 1
51463: PPUSH
51464: CALL_OW 255
51468: PUSH
51469: EMPTY
51470: LIST
51471: LIST
51472: PUSH
51473: LD_INT 91
51475: PUSH
51476: LD_VAR 0 1
51480: PUSH
51481: LD_INT 6
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: LIST
51488: PUSH
51489: LD_INT 30
51491: PUSH
51492: LD_VAR 0 4
51496: PUSH
51497: EMPTY
51498: LIST
51499: LIST
51500: PUSH
51501: EMPTY
51502: LIST
51503: LIST
51504: LIST
51505: PUSH
51506: EMPTY
51507: LIST
51508: PPUSH
51509: CALL_OW 69
51513: ADD
51514: ST_TO_ADDR
51515: GO 51443
51517: POP
51518: POP
// for i = 1 to tmp do
51519: LD_ADDR_VAR 0 4
51523: PUSH
51524: DOUBLE
51525: LD_INT 1
51527: DEC
51528: ST_TO_ADDR
51529: LD_VAR 0 3
51533: PUSH
51534: FOR_TO
51535: IFFALSE 51623
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51537: LD_ADDR_VAR 0 5
51541: PUSH
51542: LD_VAR 0 5
51546: PUSH
51547: LD_VAR 0 3
51551: PUSH
51552: LD_VAR 0 4
51556: ARRAY
51557: PPUSH
51558: CALL_OW 266
51562: PUSH
51563: LD_VAR 0 3
51567: PUSH
51568: LD_VAR 0 4
51572: ARRAY
51573: PPUSH
51574: CALL_OW 250
51578: PUSH
51579: LD_VAR 0 3
51583: PUSH
51584: LD_VAR 0 4
51588: ARRAY
51589: PPUSH
51590: CALL_OW 251
51594: PUSH
51595: LD_VAR 0 3
51599: PUSH
51600: LD_VAR 0 4
51604: ARRAY
51605: PPUSH
51606: CALL_OW 254
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: PUSH
51617: EMPTY
51618: LIST
51619: ADD
51620: ST_TO_ADDR
51621: GO 51534
51623: POP
51624: POP
// result := list ;
51625: LD_ADDR_VAR 0 2
51629: PUSH
51630: LD_VAR 0 5
51634: ST_TO_ADDR
// end ;
51635: LD_VAR 0 2
51639: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51640: LD_INT 0
51642: PPUSH
51643: PPUSH
51644: PPUSH
51645: PPUSH
51646: PPUSH
51647: PPUSH
51648: PPUSH
// if not factory then
51649: LD_VAR 0 1
51653: NOT
51654: IFFALSE 51658
// exit ;
51656: GO 52251
// if control = control_apeman then
51658: LD_VAR 0 4
51662: PUSH
51663: LD_INT 5
51665: EQUAL
51666: IFFALSE 51775
// begin tmp := UnitsInside ( factory ) ;
51668: LD_ADDR_VAR 0 8
51672: PUSH
51673: LD_VAR 0 1
51677: PPUSH
51678: CALL_OW 313
51682: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51683: LD_VAR 0 8
51687: PPUSH
51688: LD_INT 25
51690: PUSH
51691: LD_INT 12
51693: PUSH
51694: EMPTY
51695: LIST
51696: LIST
51697: PPUSH
51698: CALL_OW 72
51702: NOT
51703: IFFALSE 51713
// control := control_manual ;
51705: LD_ADDR_VAR 0 4
51709: PUSH
51710: LD_INT 1
51712: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51713: LD_ADDR_VAR 0 8
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: CALL 51410 0 1
51727: ST_TO_ADDR
// if tmp then
51728: LD_VAR 0 8
51732: IFFALSE 51775
// begin for i in tmp do
51734: LD_ADDR_VAR 0 7
51738: PUSH
51739: LD_VAR 0 8
51743: PUSH
51744: FOR_IN
51745: IFFALSE 51773
// if i [ 1 ] = b_ext_radio then
51747: LD_VAR 0 7
51751: PUSH
51752: LD_INT 1
51754: ARRAY
51755: PUSH
51756: LD_INT 22
51758: EQUAL
51759: IFFALSE 51771
// begin control := control_remote ;
51761: LD_ADDR_VAR 0 4
51765: PUSH
51766: LD_INT 2
51768: ST_TO_ADDR
// break ;
51769: GO 51773
// end ;
51771: GO 51744
51773: POP
51774: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51775: LD_VAR 0 1
51779: PPUSH
51780: LD_VAR 0 2
51784: PPUSH
51785: LD_VAR 0 3
51789: PPUSH
51790: LD_VAR 0 4
51794: PPUSH
51795: LD_VAR 0 5
51799: PPUSH
51800: CALL_OW 448
51804: IFFALSE 51839
// begin result := [ chassis , engine , control , weapon ] ;
51806: LD_ADDR_VAR 0 6
51810: PUSH
51811: LD_VAR 0 2
51815: PUSH
51816: LD_VAR 0 3
51820: PUSH
51821: LD_VAR 0 4
51825: PUSH
51826: LD_VAR 0 5
51830: PUSH
51831: EMPTY
51832: LIST
51833: LIST
51834: LIST
51835: LIST
51836: ST_TO_ADDR
// exit ;
51837: GO 52251
// end ; _chassis := AvailableChassisList ( factory ) ;
51839: LD_ADDR_VAR 0 9
51843: PUSH
51844: LD_VAR 0 1
51848: PPUSH
51849: CALL_OW 475
51853: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51854: LD_ADDR_VAR 0 11
51858: PUSH
51859: LD_VAR 0 1
51863: PPUSH
51864: CALL_OW 476
51868: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51869: LD_ADDR_VAR 0 12
51873: PUSH
51874: LD_VAR 0 1
51878: PPUSH
51879: CALL_OW 477
51883: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51884: LD_ADDR_VAR 0 10
51888: PUSH
51889: LD_VAR 0 1
51893: PPUSH
51894: CALL_OW 478
51898: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51899: LD_VAR 0 9
51903: NOT
51904: PUSH
51905: LD_VAR 0 11
51909: NOT
51910: OR
51911: PUSH
51912: LD_VAR 0 12
51916: NOT
51917: OR
51918: PUSH
51919: LD_VAR 0 10
51923: NOT
51924: OR
51925: IFFALSE 51960
// begin result := [ chassis , engine , control , weapon ] ;
51927: LD_ADDR_VAR 0 6
51931: PUSH
51932: LD_VAR 0 2
51936: PUSH
51937: LD_VAR 0 3
51941: PUSH
51942: LD_VAR 0 4
51946: PUSH
51947: LD_VAR 0 5
51951: PUSH
51952: EMPTY
51953: LIST
51954: LIST
51955: LIST
51956: LIST
51957: ST_TO_ADDR
// exit ;
51958: GO 52251
// end ; if not chassis in _chassis then
51960: LD_VAR 0 2
51964: PUSH
51965: LD_VAR 0 9
51969: IN
51970: NOT
51971: IFFALSE 51997
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51973: LD_ADDR_VAR 0 2
51977: PUSH
51978: LD_VAR 0 9
51982: PUSH
51983: LD_INT 1
51985: PPUSH
51986: LD_VAR 0 9
51990: PPUSH
51991: CALL_OW 12
51995: ARRAY
51996: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51997: LD_VAR 0 2
52001: PPUSH
52002: LD_VAR 0 3
52006: PPUSH
52007: CALL 52256 0 2
52011: NOT
52012: IFFALSE 52071
// repeat engine := _engine [ 1 ] ;
52014: LD_ADDR_VAR 0 3
52018: PUSH
52019: LD_VAR 0 11
52023: PUSH
52024: LD_INT 1
52026: ARRAY
52027: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52028: LD_ADDR_VAR 0 11
52032: PUSH
52033: LD_VAR 0 11
52037: PPUSH
52038: LD_INT 1
52040: PPUSH
52041: CALL_OW 3
52045: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52046: LD_VAR 0 2
52050: PPUSH
52051: LD_VAR 0 3
52055: PPUSH
52056: CALL 52256 0 2
52060: PUSH
52061: LD_VAR 0 11
52065: PUSH
52066: EMPTY
52067: EQUAL
52068: OR
52069: IFFALSE 52014
// if not control in _control then
52071: LD_VAR 0 4
52075: PUSH
52076: LD_VAR 0 12
52080: IN
52081: NOT
52082: IFFALSE 52108
// control := _control [ rand ( 1 , _control ) ] ;
52084: LD_ADDR_VAR 0 4
52088: PUSH
52089: LD_VAR 0 12
52093: PUSH
52094: LD_INT 1
52096: PPUSH
52097: LD_VAR 0 12
52101: PPUSH
52102: CALL_OW 12
52106: ARRAY
52107: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52108: LD_VAR 0 2
52112: PPUSH
52113: LD_VAR 0 5
52117: PPUSH
52118: CALL 52476 0 2
52122: NOT
52123: IFFALSE 52182
// repeat weapon := _weapon [ 1 ] ;
52125: LD_ADDR_VAR 0 5
52129: PUSH
52130: LD_VAR 0 10
52134: PUSH
52135: LD_INT 1
52137: ARRAY
52138: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52139: LD_ADDR_VAR 0 10
52143: PUSH
52144: LD_VAR 0 10
52148: PPUSH
52149: LD_INT 1
52151: PPUSH
52152: CALL_OW 3
52156: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52157: LD_VAR 0 2
52161: PPUSH
52162: LD_VAR 0 5
52166: PPUSH
52167: CALL 52476 0 2
52171: PUSH
52172: LD_VAR 0 10
52176: PUSH
52177: EMPTY
52178: EQUAL
52179: OR
52180: IFFALSE 52125
// result := [ ] ;
52182: LD_ADDR_VAR 0 6
52186: PUSH
52187: EMPTY
52188: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52189: LD_VAR 0 1
52193: PPUSH
52194: LD_VAR 0 2
52198: PPUSH
52199: LD_VAR 0 3
52203: PPUSH
52204: LD_VAR 0 4
52208: PPUSH
52209: LD_VAR 0 5
52213: PPUSH
52214: CALL_OW 448
52218: IFFALSE 52251
// result := [ chassis , engine , control , weapon ] ;
52220: LD_ADDR_VAR 0 6
52224: PUSH
52225: LD_VAR 0 2
52229: PUSH
52230: LD_VAR 0 3
52234: PUSH
52235: LD_VAR 0 4
52239: PUSH
52240: LD_VAR 0 5
52244: PUSH
52245: EMPTY
52246: LIST
52247: LIST
52248: LIST
52249: LIST
52250: ST_TO_ADDR
// end ;
52251: LD_VAR 0 6
52255: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52256: LD_INT 0
52258: PPUSH
// if not chassis or not engine then
52259: LD_VAR 0 1
52263: NOT
52264: PUSH
52265: LD_VAR 0 2
52269: NOT
52270: OR
52271: IFFALSE 52275
// exit ;
52273: GO 52471
// case engine of engine_solar :
52275: LD_VAR 0 2
52279: PUSH
52280: LD_INT 2
52282: DOUBLE
52283: EQUAL
52284: IFTRUE 52288
52286: GO 52326
52288: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52289: LD_ADDR_VAR 0 3
52293: PUSH
52294: LD_INT 11
52296: PUSH
52297: LD_INT 12
52299: PUSH
52300: LD_INT 13
52302: PUSH
52303: LD_INT 14
52305: PUSH
52306: LD_INT 1
52308: PUSH
52309: LD_INT 2
52311: PUSH
52312: LD_INT 3
52314: PUSH
52315: EMPTY
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: ST_TO_ADDR
52324: GO 52455
52326: LD_INT 1
52328: DOUBLE
52329: EQUAL
52330: IFTRUE 52334
52332: GO 52396
52334: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52335: LD_ADDR_VAR 0 3
52339: PUSH
52340: LD_INT 11
52342: PUSH
52343: LD_INT 12
52345: PUSH
52346: LD_INT 13
52348: PUSH
52349: LD_INT 14
52351: PUSH
52352: LD_INT 1
52354: PUSH
52355: LD_INT 2
52357: PUSH
52358: LD_INT 3
52360: PUSH
52361: LD_INT 4
52363: PUSH
52364: LD_INT 5
52366: PUSH
52367: LD_INT 21
52369: PUSH
52370: LD_INT 23
52372: PUSH
52373: LD_INT 22
52375: PUSH
52376: LD_INT 24
52378: PUSH
52379: EMPTY
52380: LIST
52381: LIST
52382: LIST
52383: LIST
52384: LIST
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: LIST
52393: ST_TO_ADDR
52394: GO 52455
52396: LD_INT 3
52398: DOUBLE
52399: EQUAL
52400: IFTRUE 52404
52402: GO 52454
52404: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52405: LD_ADDR_VAR 0 3
52409: PUSH
52410: LD_INT 13
52412: PUSH
52413: LD_INT 14
52415: PUSH
52416: LD_INT 2
52418: PUSH
52419: LD_INT 3
52421: PUSH
52422: LD_INT 4
52424: PUSH
52425: LD_INT 5
52427: PUSH
52428: LD_INT 21
52430: PUSH
52431: LD_INT 22
52433: PUSH
52434: LD_INT 23
52436: PUSH
52437: LD_INT 24
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: LIST
52451: ST_TO_ADDR
52452: GO 52455
52454: POP
// result := ( chassis in result ) ;
52455: LD_ADDR_VAR 0 3
52459: PUSH
52460: LD_VAR 0 1
52464: PUSH
52465: LD_VAR 0 3
52469: IN
52470: ST_TO_ADDR
// end ;
52471: LD_VAR 0 3
52475: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52476: LD_INT 0
52478: PPUSH
// if not chassis or not weapon then
52479: LD_VAR 0 1
52483: NOT
52484: PUSH
52485: LD_VAR 0 2
52489: NOT
52490: OR
52491: IFFALSE 52495
// exit ;
52493: GO 53521
// case weapon of us_machine_gun :
52495: LD_VAR 0 2
52499: PUSH
52500: LD_INT 2
52502: DOUBLE
52503: EQUAL
52504: IFTRUE 52508
52506: GO 52538
52508: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52509: LD_ADDR_VAR 0 3
52513: PUSH
52514: LD_INT 1
52516: PUSH
52517: LD_INT 2
52519: PUSH
52520: LD_INT 3
52522: PUSH
52523: LD_INT 4
52525: PUSH
52526: LD_INT 5
52528: PUSH
52529: EMPTY
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: ST_TO_ADDR
52536: GO 53505
52538: LD_INT 3
52540: DOUBLE
52541: EQUAL
52542: IFTRUE 52546
52544: GO 52576
52546: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52547: LD_ADDR_VAR 0 3
52551: PUSH
52552: LD_INT 1
52554: PUSH
52555: LD_INT 2
52557: PUSH
52558: LD_INT 3
52560: PUSH
52561: LD_INT 4
52563: PUSH
52564: LD_INT 5
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: ST_TO_ADDR
52574: GO 53505
52576: LD_INT 11
52578: DOUBLE
52579: EQUAL
52580: IFTRUE 52584
52582: GO 52614
52584: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52585: LD_ADDR_VAR 0 3
52589: PUSH
52590: LD_INT 1
52592: PUSH
52593: LD_INT 2
52595: PUSH
52596: LD_INT 3
52598: PUSH
52599: LD_INT 4
52601: PUSH
52602: LD_INT 5
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: ST_TO_ADDR
52612: GO 53505
52614: LD_INT 4
52616: DOUBLE
52617: EQUAL
52618: IFTRUE 52622
52620: GO 52648
52622: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52623: LD_ADDR_VAR 0 3
52627: PUSH
52628: LD_INT 2
52630: PUSH
52631: LD_INT 3
52633: PUSH
52634: LD_INT 4
52636: PUSH
52637: LD_INT 5
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: ST_TO_ADDR
52646: GO 53505
52648: LD_INT 5
52650: DOUBLE
52651: EQUAL
52652: IFTRUE 52656
52654: GO 52682
52656: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52657: LD_ADDR_VAR 0 3
52661: PUSH
52662: LD_INT 2
52664: PUSH
52665: LD_INT 3
52667: PUSH
52668: LD_INT 4
52670: PUSH
52671: LD_INT 5
52673: PUSH
52674: EMPTY
52675: LIST
52676: LIST
52677: LIST
52678: LIST
52679: ST_TO_ADDR
52680: GO 53505
52682: LD_INT 9
52684: DOUBLE
52685: EQUAL
52686: IFTRUE 52690
52688: GO 52716
52690: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52691: LD_ADDR_VAR 0 3
52695: PUSH
52696: LD_INT 2
52698: PUSH
52699: LD_INT 3
52701: PUSH
52702: LD_INT 4
52704: PUSH
52705: LD_INT 5
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: LIST
52712: LIST
52713: ST_TO_ADDR
52714: GO 53505
52716: LD_INT 7
52718: DOUBLE
52719: EQUAL
52720: IFTRUE 52724
52722: GO 52750
52724: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52725: LD_ADDR_VAR 0 3
52729: PUSH
52730: LD_INT 2
52732: PUSH
52733: LD_INT 3
52735: PUSH
52736: LD_INT 4
52738: PUSH
52739: LD_INT 5
52741: PUSH
52742: EMPTY
52743: LIST
52744: LIST
52745: LIST
52746: LIST
52747: ST_TO_ADDR
52748: GO 53505
52750: LD_INT 12
52752: DOUBLE
52753: EQUAL
52754: IFTRUE 52758
52756: GO 52784
52758: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52759: LD_ADDR_VAR 0 3
52763: PUSH
52764: LD_INT 2
52766: PUSH
52767: LD_INT 3
52769: PUSH
52770: LD_INT 4
52772: PUSH
52773: LD_INT 5
52775: PUSH
52776: EMPTY
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: ST_TO_ADDR
52782: GO 53505
52784: LD_INT 13
52786: DOUBLE
52787: EQUAL
52788: IFTRUE 52792
52790: GO 52818
52792: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52793: LD_ADDR_VAR 0 3
52797: PUSH
52798: LD_INT 2
52800: PUSH
52801: LD_INT 3
52803: PUSH
52804: LD_INT 4
52806: PUSH
52807: LD_INT 5
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: LIST
52814: LIST
52815: ST_TO_ADDR
52816: GO 53505
52818: LD_INT 14
52820: DOUBLE
52821: EQUAL
52822: IFTRUE 52826
52824: GO 52844
52826: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52827: LD_ADDR_VAR 0 3
52831: PUSH
52832: LD_INT 4
52834: PUSH
52835: LD_INT 5
52837: PUSH
52838: EMPTY
52839: LIST
52840: LIST
52841: ST_TO_ADDR
52842: GO 53505
52844: LD_INT 6
52846: DOUBLE
52847: EQUAL
52848: IFTRUE 52852
52850: GO 52870
52852: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52853: LD_ADDR_VAR 0 3
52857: PUSH
52858: LD_INT 4
52860: PUSH
52861: LD_INT 5
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: ST_TO_ADDR
52868: GO 53505
52870: LD_INT 10
52872: DOUBLE
52873: EQUAL
52874: IFTRUE 52878
52876: GO 52896
52878: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52879: LD_ADDR_VAR 0 3
52883: PUSH
52884: LD_INT 4
52886: PUSH
52887: LD_INT 5
52889: PUSH
52890: EMPTY
52891: LIST
52892: LIST
52893: ST_TO_ADDR
52894: GO 53505
52896: LD_INT 22
52898: DOUBLE
52899: EQUAL
52900: IFTRUE 52904
52902: GO 52930
52904: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52905: LD_ADDR_VAR 0 3
52909: PUSH
52910: LD_INT 11
52912: PUSH
52913: LD_INT 12
52915: PUSH
52916: LD_INT 13
52918: PUSH
52919: LD_INT 14
52921: PUSH
52922: EMPTY
52923: LIST
52924: LIST
52925: LIST
52926: LIST
52927: ST_TO_ADDR
52928: GO 53505
52930: LD_INT 23
52932: DOUBLE
52933: EQUAL
52934: IFTRUE 52938
52936: GO 52964
52938: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52939: LD_ADDR_VAR 0 3
52943: PUSH
52944: LD_INT 11
52946: PUSH
52947: LD_INT 12
52949: PUSH
52950: LD_INT 13
52952: PUSH
52953: LD_INT 14
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: LIST
52960: LIST
52961: ST_TO_ADDR
52962: GO 53505
52964: LD_INT 24
52966: DOUBLE
52967: EQUAL
52968: IFTRUE 52972
52970: GO 52998
52972: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52973: LD_ADDR_VAR 0 3
52977: PUSH
52978: LD_INT 11
52980: PUSH
52981: LD_INT 12
52983: PUSH
52984: LD_INT 13
52986: PUSH
52987: LD_INT 14
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: LIST
52994: LIST
52995: ST_TO_ADDR
52996: GO 53505
52998: LD_INT 30
53000: DOUBLE
53001: EQUAL
53002: IFTRUE 53006
53004: GO 53032
53006: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53007: LD_ADDR_VAR 0 3
53011: PUSH
53012: LD_INT 11
53014: PUSH
53015: LD_INT 12
53017: PUSH
53018: LD_INT 13
53020: PUSH
53021: LD_INT 14
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: LIST
53028: LIST
53029: ST_TO_ADDR
53030: GO 53505
53032: LD_INT 25
53034: DOUBLE
53035: EQUAL
53036: IFTRUE 53040
53038: GO 53058
53040: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53041: LD_ADDR_VAR 0 3
53045: PUSH
53046: LD_INT 13
53048: PUSH
53049: LD_INT 14
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: ST_TO_ADDR
53056: GO 53505
53058: LD_INT 27
53060: DOUBLE
53061: EQUAL
53062: IFTRUE 53066
53064: GO 53084
53066: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53067: LD_ADDR_VAR 0 3
53071: PUSH
53072: LD_INT 13
53074: PUSH
53075: LD_INT 14
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: ST_TO_ADDR
53082: GO 53505
53084: LD_INT 28
53086: DOUBLE
53087: EQUAL
53088: IFTRUE 53092
53090: GO 53110
53092: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53093: LD_ADDR_VAR 0 3
53097: PUSH
53098: LD_INT 13
53100: PUSH
53101: LD_INT 14
53103: PUSH
53104: EMPTY
53105: LIST
53106: LIST
53107: ST_TO_ADDR
53108: GO 53505
53110: LD_INT 29
53112: DOUBLE
53113: EQUAL
53114: IFTRUE 53118
53116: GO 53136
53118: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53119: LD_ADDR_VAR 0 3
53123: PUSH
53124: LD_INT 13
53126: PUSH
53127: LD_INT 14
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: ST_TO_ADDR
53134: GO 53505
53136: LD_INT 31
53138: DOUBLE
53139: EQUAL
53140: IFTRUE 53144
53142: GO 53162
53144: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53145: LD_ADDR_VAR 0 3
53149: PUSH
53150: LD_INT 13
53152: PUSH
53153: LD_INT 14
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: ST_TO_ADDR
53160: GO 53505
53162: LD_INT 26
53164: DOUBLE
53165: EQUAL
53166: IFTRUE 53170
53168: GO 53188
53170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53171: LD_ADDR_VAR 0 3
53175: PUSH
53176: LD_INT 13
53178: PUSH
53179: LD_INT 14
53181: PUSH
53182: EMPTY
53183: LIST
53184: LIST
53185: ST_TO_ADDR
53186: GO 53505
53188: LD_INT 42
53190: DOUBLE
53191: EQUAL
53192: IFTRUE 53196
53194: GO 53222
53196: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53197: LD_ADDR_VAR 0 3
53201: PUSH
53202: LD_INT 21
53204: PUSH
53205: LD_INT 22
53207: PUSH
53208: LD_INT 23
53210: PUSH
53211: LD_INT 24
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: LIST
53218: LIST
53219: ST_TO_ADDR
53220: GO 53505
53222: LD_INT 43
53224: DOUBLE
53225: EQUAL
53226: IFTRUE 53230
53228: GO 53256
53230: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53231: LD_ADDR_VAR 0 3
53235: PUSH
53236: LD_INT 21
53238: PUSH
53239: LD_INT 22
53241: PUSH
53242: LD_INT 23
53244: PUSH
53245: LD_INT 24
53247: PUSH
53248: EMPTY
53249: LIST
53250: LIST
53251: LIST
53252: LIST
53253: ST_TO_ADDR
53254: GO 53505
53256: LD_INT 44
53258: DOUBLE
53259: EQUAL
53260: IFTRUE 53264
53262: GO 53290
53264: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53265: LD_ADDR_VAR 0 3
53269: PUSH
53270: LD_INT 21
53272: PUSH
53273: LD_INT 22
53275: PUSH
53276: LD_INT 23
53278: PUSH
53279: LD_INT 24
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: LIST
53286: LIST
53287: ST_TO_ADDR
53288: GO 53505
53290: LD_INT 45
53292: DOUBLE
53293: EQUAL
53294: IFTRUE 53298
53296: GO 53324
53298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53299: LD_ADDR_VAR 0 3
53303: PUSH
53304: LD_INT 21
53306: PUSH
53307: LD_INT 22
53309: PUSH
53310: LD_INT 23
53312: PUSH
53313: LD_INT 24
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: LIST
53320: LIST
53321: ST_TO_ADDR
53322: GO 53505
53324: LD_INT 49
53326: DOUBLE
53327: EQUAL
53328: IFTRUE 53332
53330: GO 53358
53332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53333: LD_ADDR_VAR 0 3
53337: PUSH
53338: LD_INT 21
53340: PUSH
53341: LD_INT 22
53343: PUSH
53344: LD_INT 23
53346: PUSH
53347: LD_INT 24
53349: PUSH
53350: EMPTY
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: ST_TO_ADDR
53356: GO 53505
53358: LD_INT 51
53360: DOUBLE
53361: EQUAL
53362: IFTRUE 53366
53364: GO 53392
53366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53367: LD_ADDR_VAR 0 3
53371: PUSH
53372: LD_INT 21
53374: PUSH
53375: LD_INT 22
53377: PUSH
53378: LD_INT 23
53380: PUSH
53381: LD_INT 24
53383: PUSH
53384: EMPTY
53385: LIST
53386: LIST
53387: LIST
53388: LIST
53389: ST_TO_ADDR
53390: GO 53505
53392: LD_INT 52
53394: DOUBLE
53395: EQUAL
53396: IFTRUE 53400
53398: GO 53426
53400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53401: LD_ADDR_VAR 0 3
53405: PUSH
53406: LD_INT 21
53408: PUSH
53409: LD_INT 22
53411: PUSH
53412: LD_INT 23
53414: PUSH
53415: LD_INT 24
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: LIST
53422: LIST
53423: ST_TO_ADDR
53424: GO 53505
53426: LD_INT 53
53428: DOUBLE
53429: EQUAL
53430: IFTRUE 53434
53432: GO 53452
53434: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53435: LD_ADDR_VAR 0 3
53439: PUSH
53440: LD_INT 23
53442: PUSH
53443: LD_INT 24
53445: PUSH
53446: EMPTY
53447: LIST
53448: LIST
53449: ST_TO_ADDR
53450: GO 53505
53452: LD_INT 46
53454: DOUBLE
53455: EQUAL
53456: IFTRUE 53460
53458: GO 53478
53460: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53461: LD_ADDR_VAR 0 3
53465: PUSH
53466: LD_INT 23
53468: PUSH
53469: LD_INT 24
53471: PUSH
53472: EMPTY
53473: LIST
53474: LIST
53475: ST_TO_ADDR
53476: GO 53505
53478: LD_INT 47
53480: DOUBLE
53481: EQUAL
53482: IFTRUE 53486
53484: GO 53504
53486: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53487: LD_ADDR_VAR 0 3
53491: PUSH
53492: LD_INT 23
53494: PUSH
53495: LD_INT 24
53497: PUSH
53498: EMPTY
53499: LIST
53500: LIST
53501: ST_TO_ADDR
53502: GO 53505
53504: POP
// result := ( chassis in result ) ;
53505: LD_ADDR_VAR 0 3
53509: PUSH
53510: LD_VAR 0 1
53514: PUSH
53515: LD_VAR 0 3
53519: IN
53520: ST_TO_ADDR
// end ;
53521: LD_VAR 0 3
53525: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53526: LD_INT 0
53528: PPUSH
53529: PPUSH
53530: PPUSH
53531: PPUSH
53532: PPUSH
53533: PPUSH
53534: PPUSH
// result := array ;
53535: LD_ADDR_VAR 0 5
53539: PUSH
53540: LD_VAR 0 1
53544: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53545: LD_VAR 0 1
53549: NOT
53550: PUSH
53551: LD_VAR 0 2
53555: NOT
53556: OR
53557: PUSH
53558: LD_VAR 0 3
53562: NOT
53563: OR
53564: PUSH
53565: LD_VAR 0 2
53569: PUSH
53570: LD_VAR 0 1
53574: GREATER
53575: OR
53576: PUSH
53577: LD_VAR 0 3
53581: PUSH
53582: LD_VAR 0 1
53586: GREATER
53587: OR
53588: IFFALSE 53592
// exit ;
53590: GO 53888
// if direction then
53592: LD_VAR 0 4
53596: IFFALSE 53660
// begin d := 1 ;
53598: LD_ADDR_VAR 0 9
53602: PUSH
53603: LD_INT 1
53605: ST_TO_ADDR
// if i_from > i_to then
53606: LD_VAR 0 2
53610: PUSH
53611: LD_VAR 0 3
53615: GREATER
53616: IFFALSE 53642
// length := ( array - i_from ) + i_to else
53618: LD_ADDR_VAR 0 11
53622: PUSH
53623: LD_VAR 0 1
53627: PUSH
53628: LD_VAR 0 2
53632: MINUS
53633: PUSH
53634: LD_VAR 0 3
53638: PLUS
53639: ST_TO_ADDR
53640: GO 53658
// length := i_to - i_from ;
53642: LD_ADDR_VAR 0 11
53646: PUSH
53647: LD_VAR 0 3
53651: PUSH
53652: LD_VAR 0 2
53656: MINUS
53657: ST_TO_ADDR
// end else
53658: GO 53721
// begin d := - 1 ;
53660: LD_ADDR_VAR 0 9
53664: PUSH
53665: LD_INT 1
53667: NEG
53668: ST_TO_ADDR
// if i_from > i_to then
53669: LD_VAR 0 2
53673: PUSH
53674: LD_VAR 0 3
53678: GREATER
53679: IFFALSE 53699
// length := i_from - i_to else
53681: LD_ADDR_VAR 0 11
53685: PUSH
53686: LD_VAR 0 2
53690: PUSH
53691: LD_VAR 0 3
53695: MINUS
53696: ST_TO_ADDR
53697: GO 53721
// length := ( array - i_to ) + i_from ;
53699: LD_ADDR_VAR 0 11
53703: PUSH
53704: LD_VAR 0 1
53708: PUSH
53709: LD_VAR 0 3
53713: MINUS
53714: PUSH
53715: LD_VAR 0 2
53719: PLUS
53720: ST_TO_ADDR
// end ; if not length then
53721: LD_VAR 0 11
53725: NOT
53726: IFFALSE 53730
// exit ;
53728: GO 53888
// tmp := array ;
53730: LD_ADDR_VAR 0 10
53734: PUSH
53735: LD_VAR 0 1
53739: ST_TO_ADDR
// for i = 1 to length do
53740: LD_ADDR_VAR 0 6
53744: PUSH
53745: DOUBLE
53746: LD_INT 1
53748: DEC
53749: ST_TO_ADDR
53750: LD_VAR 0 11
53754: PUSH
53755: FOR_TO
53756: IFFALSE 53876
// begin for j = 1 to array do
53758: LD_ADDR_VAR 0 7
53762: PUSH
53763: DOUBLE
53764: LD_INT 1
53766: DEC
53767: ST_TO_ADDR
53768: LD_VAR 0 1
53772: PUSH
53773: FOR_TO
53774: IFFALSE 53862
// begin k := j + d ;
53776: LD_ADDR_VAR 0 8
53780: PUSH
53781: LD_VAR 0 7
53785: PUSH
53786: LD_VAR 0 9
53790: PLUS
53791: ST_TO_ADDR
// if k > array then
53792: LD_VAR 0 8
53796: PUSH
53797: LD_VAR 0 1
53801: GREATER
53802: IFFALSE 53812
// k := 1 ;
53804: LD_ADDR_VAR 0 8
53808: PUSH
53809: LD_INT 1
53811: ST_TO_ADDR
// if not k then
53812: LD_VAR 0 8
53816: NOT
53817: IFFALSE 53829
// k := array ;
53819: LD_ADDR_VAR 0 8
53823: PUSH
53824: LD_VAR 0 1
53828: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53829: LD_ADDR_VAR 0 10
53833: PUSH
53834: LD_VAR 0 10
53838: PPUSH
53839: LD_VAR 0 8
53843: PPUSH
53844: LD_VAR 0 1
53848: PUSH
53849: LD_VAR 0 7
53853: ARRAY
53854: PPUSH
53855: CALL_OW 1
53859: ST_TO_ADDR
// end ;
53860: GO 53773
53862: POP
53863: POP
// array := tmp ;
53864: LD_ADDR_VAR 0 1
53868: PUSH
53869: LD_VAR 0 10
53873: ST_TO_ADDR
// end ;
53874: GO 53755
53876: POP
53877: POP
// result := array ;
53878: LD_ADDR_VAR 0 5
53882: PUSH
53883: LD_VAR 0 1
53887: ST_TO_ADDR
// end ;
53888: LD_VAR 0 5
53892: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53893: LD_INT 0
53895: PPUSH
53896: PPUSH
// result := 0 ;
53897: LD_ADDR_VAR 0 3
53901: PUSH
53902: LD_INT 0
53904: ST_TO_ADDR
// if not array or not value in array then
53905: LD_VAR 0 1
53909: NOT
53910: PUSH
53911: LD_VAR 0 2
53915: PUSH
53916: LD_VAR 0 1
53920: IN
53921: NOT
53922: OR
53923: IFFALSE 53927
// exit ;
53925: GO 53981
// for i = 1 to array do
53927: LD_ADDR_VAR 0 4
53931: PUSH
53932: DOUBLE
53933: LD_INT 1
53935: DEC
53936: ST_TO_ADDR
53937: LD_VAR 0 1
53941: PUSH
53942: FOR_TO
53943: IFFALSE 53979
// if value = array [ i ] then
53945: LD_VAR 0 2
53949: PUSH
53950: LD_VAR 0 1
53954: PUSH
53955: LD_VAR 0 4
53959: ARRAY
53960: EQUAL
53961: IFFALSE 53977
// begin result := i ;
53963: LD_ADDR_VAR 0 3
53967: PUSH
53968: LD_VAR 0 4
53972: ST_TO_ADDR
// exit ;
53973: POP
53974: POP
53975: GO 53981
// end ;
53977: GO 53942
53979: POP
53980: POP
// end ;
53981: LD_VAR 0 3
53985: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53986: LD_INT 0
53988: PPUSH
// vc_chassis := chassis ;
53989: LD_ADDR_OWVAR 37
53993: PUSH
53994: LD_VAR 0 1
53998: ST_TO_ADDR
// vc_engine := engine ;
53999: LD_ADDR_OWVAR 39
54003: PUSH
54004: LD_VAR 0 2
54008: ST_TO_ADDR
// vc_control := control ;
54009: LD_ADDR_OWVAR 38
54013: PUSH
54014: LD_VAR 0 3
54018: ST_TO_ADDR
// vc_weapon := weapon ;
54019: LD_ADDR_OWVAR 40
54023: PUSH
54024: LD_VAR 0 4
54028: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54029: LD_ADDR_OWVAR 41
54033: PUSH
54034: LD_VAR 0 5
54038: ST_TO_ADDR
// end ;
54039: LD_VAR 0 6
54043: RET
// export function WantPlant ( unit ) ; var task ; begin
54044: LD_INT 0
54046: PPUSH
54047: PPUSH
// result := false ;
54048: LD_ADDR_VAR 0 2
54052: PUSH
54053: LD_INT 0
54055: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54056: LD_ADDR_VAR 0 3
54060: PUSH
54061: LD_VAR 0 1
54065: PPUSH
54066: CALL_OW 437
54070: ST_TO_ADDR
// if task then
54071: LD_VAR 0 3
54075: IFFALSE 54103
// if task [ 1 ] [ 1 ] = p then
54077: LD_VAR 0 3
54081: PUSH
54082: LD_INT 1
54084: ARRAY
54085: PUSH
54086: LD_INT 1
54088: ARRAY
54089: PUSH
54090: LD_STRING p
54092: EQUAL
54093: IFFALSE 54103
// result := true ;
54095: LD_ADDR_VAR 0 2
54099: PUSH
54100: LD_INT 1
54102: ST_TO_ADDR
// end ;
54103: LD_VAR 0 2
54107: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54108: LD_INT 0
54110: PPUSH
54111: PPUSH
54112: PPUSH
54113: PPUSH
// if pos < 1 then
54114: LD_VAR 0 2
54118: PUSH
54119: LD_INT 1
54121: LESS
54122: IFFALSE 54126
// exit ;
54124: GO 54429
// if pos = 1 then
54126: LD_VAR 0 2
54130: PUSH
54131: LD_INT 1
54133: EQUAL
54134: IFFALSE 54167
// result := Replace ( arr , pos [ 1 ] , value ) else
54136: LD_ADDR_VAR 0 4
54140: PUSH
54141: LD_VAR 0 1
54145: PPUSH
54146: LD_VAR 0 2
54150: PUSH
54151: LD_INT 1
54153: ARRAY
54154: PPUSH
54155: LD_VAR 0 3
54159: PPUSH
54160: CALL_OW 1
54164: ST_TO_ADDR
54165: GO 54429
// begin tmp := arr ;
54167: LD_ADDR_VAR 0 6
54171: PUSH
54172: LD_VAR 0 1
54176: ST_TO_ADDR
// s_arr := [ tmp ] ;
54177: LD_ADDR_VAR 0 7
54181: PUSH
54182: LD_VAR 0 6
54186: PUSH
54187: EMPTY
54188: LIST
54189: ST_TO_ADDR
// for i = 1 to pos - 1 do
54190: LD_ADDR_VAR 0 5
54194: PUSH
54195: DOUBLE
54196: LD_INT 1
54198: DEC
54199: ST_TO_ADDR
54200: LD_VAR 0 2
54204: PUSH
54205: LD_INT 1
54207: MINUS
54208: PUSH
54209: FOR_TO
54210: IFFALSE 54255
// begin tmp := tmp [ pos [ i ] ] ;
54212: LD_ADDR_VAR 0 6
54216: PUSH
54217: LD_VAR 0 6
54221: PUSH
54222: LD_VAR 0 2
54226: PUSH
54227: LD_VAR 0 5
54231: ARRAY
54232: ARRAY
54233: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54234: LD_ADDR_VAR 0 7
54238: PUSH
54239: LD_VAR 0 7
54243: PUSH
54244: LD_VAR 0 6
54248: PUSH
54249: EMPTY
54250: LIST
54251: ADD
54252: ST_TO_ADDR
// end ;
54253: GO 54209
54255: POP
54256: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54257: LD_ADDR_VAR 0 6
54261: PUSH
54262: LD_VAR 0 6
54266: PPUSH
54267: LD_VAR 0 2
54271: PUSH
54272: LD_VAR 0 2
54276: ARRAY
54277: PPUSH
54278: LD_VAR 0 3
54282: PPUSH
54283: CALL_OW 1
54287: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54288: LD_ADDR_VAR 0 7
54292: PUSH
54293: LD_VAR 0 7
54297: PPUSH
54298: LD_VAR 0 7
54302: PPUSH
54303: LD_VAR 0 6
54307: PPUSH
54308: CALL_OW 1
54312: ST_TO_ADDR
// for i = s_arr downto 2 do
54313: LD_ADDR_VAR 0 5
54317: PUSH
54318: DOUBLE
54319: LD_VAR 0 7
54323: INC
54324: ST_TO_ADDR
54325: LD_INT 2
54327: PUSH
54328: FOR_DOWNTO
54329: IFFALSE 54413
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54331: LD_ADDR_VAR 0 6
54335: PUSH
54336: LD_VAR 0 7
54340: PUSH
54341: LD_VAR 0 5
54345: PUSH
54346: LD_INT 1
54348: MINUS
54349: ARRAY
54350: PPUSH
54351: LD_VAR 0 2
54355: PUSH
54356: LD_VAR 0 5
54360: PUSH
54361: LD_INT 1
54363: MINUS
54364: ARRAY
54365: PPUSH
54366: LD_VAR 0 7
54370: PUSH
54371: LD_VAR 0 5
54375: ARRAY
54376: PPUSH
54377: CALL_OW 1
54381: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54382: LD_ADDR_VAR 0 7
54386: PUSH
54387: LD_VAR 0 7
54391: PPUSH
54392: LD_VAR 0 5
54396: PUSH
54397: LD_INT 1
54399: MINUS
54400: PPUSH
54401: LD_VAR 0 6
54405: PPUSH
54406: CALL_OW 1
54410: ST_TO_ADDR
// end ;
54411: GO 54328
54413: POP
54414: POP
// result := s_arr [ 1 ] ;
54415: LD_ADDR_VAR 0 4
54419: PUSH
54420: LD_VAR 0 7
54424: PUSH
54425: LD_INT 1
54427: ARRAY
54428: ST_TO_ADDR
// end ; end ;
54429: LD_VAR 0 4
54433: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54434: LD_INT 0
54436: PPUSH
54437: PPUSH
// if not list then
54438: LD_VAR 0 1
54442: NOT
54443: IFFALSE 54447
// exit ;
54445: GO 54538
// i := list [ pos1 ] ;
54447: LD_ADDR_VAR 0 5
54451: PUSH
54452: LD_VAR 0 1
54456: PUSH
54457: LD_VAR 0 2
54461: ARRAY
54462: ST_TO_ADDR
// if not i then
54463: LD_VAR 0 5
54467: NOT
54468: IFFALSE 54472
// exit ;
54470: GO 54538
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54472: LD_ADDR_VAR 0 1
54476: PUSH
54477: LD_VAR 0 1
54481: PPUSH
54482: LD_VAR 0 2
54486: PPUSH
54487: LD_VAR 0 1
54491: PUSH
54492: LD_VAR 0 3
54496: ARRAY
54497: PPUSH
54498: CALL_OW 1
54502: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54503: LD_ADDR_VAR 0 1
54507: PUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: LD_VAR 0 3
54517: PPUSH
54518: LD_VAR 0 5
54522: PPUSH
54523: CALL_OW 1
54527: ST_TO_ADDR
// result := list ;
54528: LD_ADDR_VAR 0 4
54532: PUSH
54533: LD_VAR 0 1
54537: ST_TO_ADDR
// end ;
54538: LD_VAR 0 4
54542: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54543: LD_INT 0
54545: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54546: LD_ADDR_VAR 0 5
54550: PUSH
54551: LD_VAR 0 1
54555: PPUSH
54556: CALL_OW 250
54560: PPUSH
54561: LD_VAR 0 1
54565: PPUSH
54566: CALL_OW 251
54570: PPUSH
54571: LD_VAR 0 2
54575: PPUSH
54576: LD_VAR 0 3
54580: PPUSH
54581: LD_VAR 0 4
54585: PPUSH
54586: CALL 54596 0 5
54590: ST_TO_ADDR
// end ;
54591: LD_VAR 0 5
54595: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54596: LD_INT 0
54598: PPUSH
54599: PPUSH
54600: PPUSH
54601: PPUSH
// if not list then
54602: LD_VAR 0 3
54606: NOT
54607: IFFALSE 54611
// exit ;
54609: GO 54999
// result := [ ] ;
54611: LD_ADDR_VAR 0 6
54615: PUSH
54616: EMPTY
54617: ST_TO_ADDR
// for i in list do
54618: LD_ADDR_VAR 0 7
54622: PUSH
54623: LD_VAR 0 3
54627: PUSH
54628: FOR_IN
54629: IFFALSE 54831
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54631: LD_ADDR_VAR 0 9
54635: PUSH
54636: LD_VAR 0 7
54640: PPUSH
54641: LD_VAR 0 1
54645: PPUSH
54646: LD_VAR 0 2
54650: PPUSH
54651: CALL_OW 297
54655: ST_TO_ADDR
// if not result then
54656: LD_VAR 0 6
54660: NOT
54661: IFFALSE 54687
// result := [ [ i , tmp ] ] else
54663: LD_ADDR_VAR 0 6
54667: PUSH
54668: LD_VAR 0 7
54672: PUSH
54673: LD_VAR 0 9
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: EMPTY
54683: LIST
54684: ST_TO_ADDR
54685: GO 54829
// begin if result [ result ] [ 2 ] < tmp then
54687: LD_VAR 0 6
54691: PUSH
54692: LD_VAR 0 6
54696: ARRAY
54697: PUSH
54698: LD_INT 2
54700: ARRAY
54701: PUSH
54702: LD_VAR 0 9
54706: LESS
54707: IFFALSE 54749
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54709: LD_ADDR_VAR 0 6
54713: PUSH
54714: LD_VAR 0 6
54718: PPUSH
54719: LD_VAR 0 6
54723: PUSH
54724: LD_INT 1
54726: PLUS
54727: PPUSH
54728: LD_VAR 0 7
54732: PUSH
54733: LD_VAR 0 9
54737: PUSH
54738: EMPTY
54739: LIST
54740: LIST
54741: PPUSH
54742: CALL_OW 2
54746: ST_TO_ADDR
54747: GO 54829
// for j = 1 to result do
54749: LD_ADDR_VAR 0 8
54753: PUSH
54754: DOUBLE
54755: LD_INT 1
54757: DEC
54758: ST_TO_ADDR
54759: LD_VAR 0 6
54763: PUSH
54764: FOR_TO
54765: IFFALSE 54827
// begin if tmp < result [ j ] [ 2 ] then
54767: LD_VAR 0 9
54771: PUSH
54772: LD_VAR 0 6
54776: PUSH
54777: LD_VAR 0 8
54781: ARRAY
54782: PUSH
54783: LD_INT 2
54785: ARRAY
54786: LESS
54787: IFFALSE 54825
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54789: LD_ADDR_VAR 0 6
54793: PUSH
54794: LD_VAR 0 6
54798: PPUSH
54799: LD_VAR 0 8
54803: PPUSH
54804: LD_VAR 0 7
54808: PUSH
54809: LD_VAR 0 9
54813: PUSH
54814: EMPTY
54815: LIST
54816: LIST
54817: PPUSH
54818: CALL_OW 2
54822: ST_TO_ADDR
// break ;
54823: GO 54827
// end ; end ;
54825: GO 54764
54827: POP
54828: POP
// end ; end ;
54829: GO 54628
54831: POP
54832: POP
// if result and not asc then
54833: LD_VAR 0 6
54837: PUSH
54838: LD_VAR 0 4
54842: NOT
54843: AND
54844: IFFALSE 54919
// begin tmp := result ;
54846: LD_ADDR_VAR 0 9
54850: PUSH
54851: LD_VAR 0 6
54855: ST_TO_ADDR
// for i = tmp downto 1 do
54856: LD_ADDR_VAR 0 7
54860: PUSH
54861: DOUBLE
54862: LD_VAR 0 9
54866: INC
54867: ST_TO_ADDR
54868: LD_INT 1
54870: PUSH
54871: FOR_DOWNTO
54872: IFFALSE 54917
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54874: LD_ADDR_VAR 0 6
54878: PUSH
54879: LD_VAR 0 6
54883: PPUSH
54884: LD_VAR 0 9
54888: PUSH
54889: LD_VAR 0 7
54893: MINUS
54894: PUSH
54895: LD_INT 1
54897: PLUS
54898: PPUSH
54899: LD_VAR 0 9
54903: PUSH
54904: LD_VAR 0 7
54908: ARRAY
54909: PPUSH
54910: CALL_OW 1
54914: ST_TO_ADDR
54915: GO 54871
54917: POP
54918: POP
// end ; tmp := [ ] ;
54919: LD_ADDR_VAR 0 9
54923: PUSH
54924: EMPTY
54925: ST_TO_ADDR
// if mode then
54926: LD_VAR 0 5
54930: IFFALSE 54999
// begin for i = 1 to result do
54932: LD_ADDR_VAR 0 7
54936: PUSH
54937: DOUBLE
54938: LD_INT 1
54940: DEC
54941: ST_TO_ADDR
54942: LD_VAR 0 6
54946: PUSH
54947: FOR_TO
54948: IFFALSE 54987
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54950: LD_ADDR_VAR 0 9
54954: PUSH
54955: LD_VAR 0 9
54959: PPUSH
54960: LD_VAR 0 7
54964: PPUSH
54965: LD_VAR 0 6
54969: PUSH
54970: LD_VAR 0 7
54974: ARRAY
54975: PUSH
54976: LD_INT 1
54978: ARRAY
54979: PPUSH
54980: CALL_OW 1
54984: ST_TO_ADDR
54985: GO 54947
54987: POP
54988: POP
// result := tmp ;
54989: LD_ADDR_VAR 0 6
54993: PUSH
54994: LD_VAR 0 9
54998: ST_TO_ADDR
// end ; end ;
54999: LD_VAR 0 6
55003: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55004: LD_INT 0
55006: PPUSH
55007: PPUSH
55008: PPUSH
55009: PPUSH
55010: PPUSH
55011: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55012: LD_ADDR_VAR 0 5
55016: PUSH
55017: LD_INT 0
55019: PUSH
55020: LD_INT 0
55022: PUSH
55023: LD_INT 0
55025: PUSH
55026: EMPTY
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: LIST
55033: ST_TO_ADDR
// if not x or not y then
55034: LD_VAR 0 2
55038: NOT
55039: PUSH
55040: LD_VAR 0 3
55044: NOT
55045: OR
55046: IFFALSE 55050
// exit ;
55048: GO 56696
// if not range then
55050: LD_VAR 0 4
55054: NOT
55055: IFFALSE 55065
// range := 10 ;
55057: LD_ADDR_VAR 0 4
55061: PUSH
55062: LD_INT 10
55064: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55065: LD_ADDR_VAR 0 8
55069: PUSH
55070: LD_INT 81
55072: PUSH
55073: LD_VAR 0 1
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: PUSH
55082: LD_INT 92
55084: PUSH
55085: LD_VAR 0 2
55089: PUSH
55090: LD_VAR 0 3
55094: PUSH
55095: LD_VAR 0 4
55099: PUSH
55100: EMPTY
55101: LIST
55102: LIST
55103: LIST
55104: LIST
55105: PUSH
55106: LD_INT 3
55108: PUSH
55109: LD_INT 21
55111: PUSH
55112: LD_INT 3
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: PUSH
55123: EMPTY
55124: LIST
55125: LIST
55126: LIST
55127: PPUSH
55128: CALL_OW 69
55132: ST_TO_ADDR
// if not tmp then
55133: LD_VAR 0 8
55137: NOT
55138: IFFALSE 55142
// exit ;
55140: GO 56696
// for i in tmp do
55142: LD_ADDR_VAR 0 6
55146: PUSH
55147: LD_VAR 0 8
55151: PUSH
55152: FOR_IN
55153: IFFALSE 56671
// begin points := [ 0 , 0 , 0 ] ;
55155: LD_ADDR_VAR 0 9
55159: PUSH
55160: LD_INT 0
55162: PUSH
55163: LD_INT 0
55165: PUSH
55166: LD_INT 0
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: ST_TO_ADDR
// bpoints := 1 ;
55174: LD_ADDR_VAR 0 10
55178: PUSH
55179: LD_INT 1
55181: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55182: LD_VAR 0 6
55186: PPUSH
55187: CALL_OW 247
55191: PUSH
55192: LD_INT 1
55194: DOUBLE
55195: EQUAL
55196: IFTRUE 55200
55198: GO 55778
55200: POP
// begin if GetClass ( i ) = 1 then
55201: LD_VAR 0 6
55205: PPUSH
55206: CALL_OW 257
55210: PUSH
55211: LD_INT 1
55213: EQUAL
55214: IFFALSE 55235
// points := [ 10 , 5 , 3 ] ;
55216: LD_ADDR_VAR 0 9
55220: PUSH
55221: LD_INT 10
55223: PUSH
55224: LD_INT 5
55226: PUSH
55227: LD_INT 3
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: LIST
55234: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55235: LD_VAR 0 6
55239: PPUSH
55240: CALL_OW 257
55244: PUSH
55245: LD_INT 2
55247: PUSH
55248: LD_INT 3
55250: PUSH
55251: LD_INT 4
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: LIST
55258: IN
55259: IFFALSE 55280
// points := [ 3 , 2 , 1 ] ;
55261: LD_ADDR_VAR 0 9
55265: PUSH
55266: LD_INT 3
55268: PUSH
55269: LD_INT 2
55271: PUSH
55272: LD_INT 1
55274: PUSH
55275: EMPTY
55276: LIST
55277: LIST
55278: LIST
55279: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55280: LD_VAR 0 6
55284: PPUSH
55285: CALL_OW 257
55289: PUSH
55290: LD_INT 5
55292: EQUAL
55293: IFFALSE 55314
// points := [ 130 , 5 , 2 ] ;
55295: LD_ADDR_VAR 0 9
55299: PUSH
55300: LD_INT 130
55302: PUSH
55303: LD_INT 5
55305: PUSH
55306: LD_INT 2
55308: PUSH
55309: EMPTY
55310: LIST
55311: LIST
55312: LIST
55313: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55314: LD_VAR 0 6
55318: PPUSH
55319: CALL_OW 257
55323: PUSH
55324: LD_INT 8
55326: EQUAL
55327: IFFALSE 55348
// points := [ 35 , 35 , 30 ] ;
55329: LD_ADDR_VAR 0 9
55333: PUSH
55334: LD_INT 35
55336: PUSH
55337: LD_INT 35
55339: PUSH
55340: LD_INT 30
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: LIST
55347: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55348: LD_VAR 0 6
55352: PPUSH
55353: CALL_OW 257
55357: PUSH
55358: LD_INT 9
55360: EQUAL
55361: IFFALSE 55382
// points := [ 20 , 55 , 40 ] ;
55363: LD_ADDR_VAR 0 9
55367: PUSH
55368: LD_INT 20
55370: PUSH
55371: LD_INT 55
55373: PUSH
55374: LD_INT 40
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: LIST
55381: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55382: LD_VAR 0 6
55386: PPUSH
55387: CALL_OW 257
55391: PUSH
55392: LD_INT 12
55394: PUSH
55395: LD_INT 16
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: IN
55402: IFFALSE 55423
// points := [ 5 , 3 , 2 ] ;
55404: LD_ADDR_VAR 0 9
55408: PUSH
55409: LD_INT 5
55411: PUSH
55412: LD_INT 3
55414: PUSH
55415: LD_INT 2
55417: PUSH
55418: EMPTY
55419: LIST
55420: LIST
55421: LIST
55422: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55423: LD_VAR 0 6
55427: PPUSH
55428: CALL_OW 257
55432: PUSH
55433: LD_INT 17
55435: EQUAL
55436: IFFALSE 55457
// points := [ 100 , 50 , 75 ] ;
55438: LD_ADDR_VAR 0 9
55442: PUSH
55443: LD_INT 100
55445: PUSH
55446: LD_INT 50
55448: PUSH
55449: LD_INT 75
55451: PUSH
55452: EMPTY
55453: LIST
55454: LIST
55455: LIST
55456: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55457: LD_VAR 0 6
55461: PPUSH
55462: CALL_OW 257
55466: PUSH
55467: LD_INT 15
55469: EQUAL
55470: IFFALSE 55491
// points := [ 10 , 5 , 3 ] ;
55472: LD_ADDR_VAR 0 9
55476: PUSH
55477: LD_INT 10
55479: PUSH
55480: LD_INT 5
55482: PUSH
55483: LD_INT 3
55485: PUSH
55486: EMPTY
55487: LIST
55488: LIST
55489: LIST
55490: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55491: LD_VAR 0 6
55495: PPUSH
55496: CALL_OW 257
55500: PUSH
55501: LD_INT 14
55503: EQUAL
55504: IFFALSE 55525
// points := [ 10 , 0 , 0 ] ;
55506: LD_ADDR_VAR 0 9
55510: PUSH
55511: LD_INT 10
55513: PUSH
55514: LD_INT 0
55516: PUSH
55517: LD_INT 0
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: LIST
55524: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55525: LD_VAR 0 6
55529: PPUSH
55530: CALL_OW 257
55534: PUSH
55535: LD_INT 11
55537: EQUAL
55538: IFFALSE 55559
// points := [ 30 , 10 , 5 ] ;
55540: LD_ADDR_VAR 0 9
55544: PUSH
55545: LD_INT 30
55547: PUSH
55548: LD_INT 10
55550: PUSH
55551: LD_INT 5
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: LIST
55558: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55559: LD_VAR 0 1
55563: PPUSH
55564: LD_INT 5
55566: PPUSH
55567: CALL_OW 321
55571: PUSH
55572: LD_INT 2
55574: EQUAL
55575: IFFALSE 55592
// bpoints := bpoints * 1.8 ;
55577: LD_ADDR_VAR 0 10
55581: PUSH
55582: LD_VAR 0 10
55586: PUSH
55587: LD_REAL  1.80000000000000E+0000
55590: MUL
55591: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55592: LD_VAR 0 6
55596: PPUSH
55597: CALL_OW 257
55601: PUSH
55602: LD_INT 1
55604: PUSH
55605: LD_INT 2
55607: PUSH
55608: LD_INT 3
55610: PUSH
55611: LD_INT 4
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: LIST
55619: IN
55620: PUSH
55621: LD_VAR 0 1
55625: PPUSH
55626: LD_INT 51
55628: PPUSH
55629: CALL_OW 321
55633: PUSH
55634: LD_INT 2
55636: EQUAL
55637: AND
55638: IFFALSE 55655
// bpoints := bpoints * 1.2 ;
55640: LD_ADDR_VAR 0 10
55644: PUSH
55645: LD_VAR 0 10
55649: PUSH
55650: LD_REAL  1.20000000000000E+0000
55653: MUL
55654: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55655: LD_VAR 0 6
55659: PPUSH
55660: CALL_OW 257
55664: PUSH
55665: LD_INT 5
55667: PUSH
55668: LD_INT 7
55670: PUSH
55671: LD_INT 9
55673: PUSH
55674: EMPTY
55675: LIST
55676: LIST
55677: LIST
55678: IN
55679: PUSH
55680: LD_VAR 0 1
55684: PPUSH
55685: LD_INT 52
55687: PPUSH
55688: CALL_OW 321
55692: PUSH
55693: LD_INT 2
55695: EQUAL
55696: AND
55697: IFFALSE 55714
// bpoints := bpoints * 1.5 ;
55699: LD_ADDR_VAR 0 10
55703: PUSH
55704: LD_VAR 0 10
55708: PUSH
55709: LD_REAL  1.50000000000000E+0000
55712: MUL
55713: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55714: LD_VAR 0 1
55718: PPUSH
55719: LD_INT 66
55721: PPUSH
55722: CALL_OW 321
55726: PUSH
55727: LD_INT 2
55729: EQUAL
55730: IFFALSE 55747
// bpoints := bpoints * 1.1 ;
55732: LD_ADDR_VAR 0 10
55736: PUSH
55737: LD_VAR 0 10
55741: PUSH
55742: LD_REAL  1.10000000000000E+0000
55745: MUL
55746: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55747: LD_ADDR_VAR 0 10
55751: PUSH
55752: LD_VAR 0 10
55756: PUSH
55757: LD_VAR 0 6
55761: PPUSH
55762: LD_INT 1
55764: PPUSH
55765: CALL_OW 259
55769: PUSH
55770: LD_REAL  1.15000000000000E+0000
55773: MUL
55774: MUL
55775: ST_TO_ADDR
// end ; unit_vehicle :
55776: GO 56600
55778: LD_INT 2
55780: DOUBLE
55781: EQUAL
55782: IFTRUE 55786
55784: GO 56588
55786: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55787: LD_VAR 0 6
55791: PPUSH
55792: CALL_OW 264
55796: PUSH
55797: LD_INT 2
55799: PUSH
55800: LD_INT 42
55802: PUSH
55803: LD_INT 24
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: LIST
55810: IN
55811: IFFALSE 55832
// points := [ 25 , 5 , 3 ] ;
55813: LD_ADDR_VAR 0 9
55817: PUSH
55818: LD_INT 25
55820: PUSH
55821: LD_INT 5
55823: PUSH
55824: LD_INT 3
55826: PUSH
55827: EMPTY
55828: LIST
55829: LIST
55830: LIST
55831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55832: LD_VAR 0 6
55836: PPUSH
55837: CALL_OW 264
55841: PUSH
55842: LD_INT 4
55844: PUSH
55845: LD_INT 43
55847: PUSH
55848: LD_INT 25
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: IN
55856: IFFALSE 55877
// points := [ 40 , 15 , 5 ] ;
55858: LD_ADDR_VAR 0 9
55862: PUSH
55863: LD_INT 40
55865: PUSH
55866: LD_INT 15
55868: PUSH
55869: LD_INT 5
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: LIST
55876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55877: LD_VAR 0 6
55881: PPUSH
55882: CALL_OW 264
55886: PUSH
55887: LD_INT 3
55889: PUSH
55890: LD_INT 23
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: IN
55897: IFFALSE 55918
// points := [ 7 , 25 , 8 ] ;
55899: LD_ADDR_VAR 0 9
55903: PUSH
55904: LD_INT 7
55906: PUSH
55907: LD_INT 25
55909: PUSH
55910: LD_INT 8
55912: PUSH
55913: EMPTY
55914: LIST
55915: LIST
55916: LIST
55917: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55918: LD_VAR 0 6
55922: PPUSH
55923: CALL_OW 264
55927: PUSH
55928: LD_INT 5
55930: PUSH
55931: LD_INT 27
55933: PUSH
55934: LD_INT 44
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: LIST
55941: IN
55942: IFFALSE 55963
// points := [ 14 , 50 , 16 ] ;
55944: LD_ADDR_VAR 0 9
55948: PUSH
55949: LD_INT 14
55951: PUSH
55952: LD_INT 50
55954: PUSH
55955: LD_INT 16
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: LIST
55962: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55963: LD_VAR 0 6
55967: PPUSH
55968: CALL_OW 264
55972: PUSH
55973: LD_INT 6
55975: PUSH
55976: LD_INT 46
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: IN
55983: IFFALSE 56004
// points := [ 32 , 120 , 70 ] ;
55985: LD_ADDR_VAR 0 9
55989: PUSH
55990: LD_INT 32
55992: PUSH
55993: LD_INT 120
55995: PUSH
55996: LD_INT 70
55998: PUSH
55999: EMPTY
56000: LIST
56001: LIST
56002: LIST
56003: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56004: LD_VAR 0 6
56008: PPUSH
56009: CALL_OW 264
56013: PUSH
56014: LD_INT 7
56016: PUSH
56017: LD_INT 28
56019: PUSH
56020: LD_INT 45
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: LIST
56027: IN
56028: IFFALSE 56049
// points := [ 35 , 20 , 45 ] ;
56030: LD_ADDR_VAR 0 9
56034: PUSH
56035: LD_INT 35
56037: PUSH
56038: LD_INT 20
56040: PUSH
56041: LD_INT 45
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56049: LD_VAR 0 6
56053: PPUSH
56054: CALL_OW 264
56058: PUSH
56059: LD_INT 47
56061: PUSH
56062: EMPTY
56063: LIST
56064: IN
56065: IFFALSE 56086
// points := [ 67 , 45 , 75 ] ;
56067: LD_ADDR_VAR 0 9
56071: PUSH
56072: LD_INT 67
56074: PUSH
56075: LD_INT 45
56077: PUSH
56078: LD_INT 75
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56086: LD_VAR 0 6
56090: PPUSH
56091: CALL_OW 264
56095: PUSH
56096: LD_INT 26
56098: PUSH
56099: EMPTY
56100: LIST
56101: IN
56102: IFFALSE 56123
// points := [ 120 , 30 , 80 ] ;
56104: LD_ADDR_VAR 0 9
56108: PUSH
56109: LD_INT 120
56111: PUSH
56112: LD_INT 30
56114: PUSH
56115: LD_INT 80
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56123: LD_VAR 0 6
56127: PPUSH
56128: CALL_OW 264
56132: PUSH
56133: LD_INT 22
56135: PUSH
56136: EMPTY
56137: LIST
56138: IN
56139: IFFALSE 56160
// points := [ 40 , 1 , 1 ] ;
56141: LD_ADDR_VAR 0 9
56145: PUSH
56146: LD_INT 40
56148: PUSH
56149: LD_INT 1
56151: PUSH
56152: LD_INT 1
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: LIST
56159: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56160: LD_VAR 0 6
56164: PPUSH
56165: CALL_OW 264
56169: PUSH
56170: LD_INT 29
56172: PUSH
56173: EMPTY
56174: LIST
56175: IN
56176: IFFALSE 56197
// points := [ 70 , 200 , 400 ] ;
56178: LD_ADDR_VAR 0 9
56182: PUSH
56183: LD_INT 70
56185: PUSH
56186: LD_INT 200
56188: PUSH
56189: LD_INT 400
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: LIST
56196: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56197: LD_VAR 0 6
56201: PPUSH
56202: CALL_OW 264
56206: PUSH
56207: LD_INT 14
56209: PUSH
56210: LD_INT 53
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: IN
56217: IFFALSE 56238
// points := [ 40 , 10 , 20 ] ;
56219: LD_ADDR_VAR 0 9
56223: PUSH
56224: LD_INT 40
56226: PUSH
56227: LD_INT 10
56229: PUSH
56230: LD_INT 20
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: LIST
56237: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56238: LD_VAR 0 6
56242: PPUSH
56243: CALL_OW 264
56247: PUSH
56248: LD_INT 9
56250: PUSH
56251: EMPTY
56252: LIST
56253: IN
56254: IFFALSE 56275
// points := [ 5 , 70 , 20 ] ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_INT 5
56263: PUSH
56264: LD_INT 70
56266: PUSH
56267: LD_INT 20
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56275: LD_VAR 0 6
56279: PPUSH
56280: CALL_OW 264
56284: PUSH
56285: LD_INT 10
56287: PUSH
56288: EMPTY
56289: LIST
56290: IN
56291: IFFALSE 56312
// points := [ 35 , 110 , 70 ] ;
56293: LD_ADDR_VAR 0 9
56297: PUSH
56298: LD_INT 35
56300: PUSH
56301: LD_INT 110
56303: PUSH
56304: LD_INT 70
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: LIST
56311: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56312: LD_VAR 0 6
56316: PPUSH
56317: CALL_OW 265
56321: PUSH
56322: LD_INT 25
56324: EQUAL
56325: IFFALSE 56346
// points := [ 80 , 65 , 100 ] ;
56327: LD_ADDR_VAR 0 9
56331: PUSH
56332: LD_INT 80
56334: PUSH
56335: LD_INT 65
56337: PUSH
56338: LD_INT 100
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: LIST
56345: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56346: LD_VAR 0 6
56350: PPUSH
56351: CALL_OW 263
56355: PUSH
56356: LD_INT 1
56358: EQUAL
56359: IFFALSE 56394
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56361: LD_ADDR_VAR 0 10
56365: PUSH
56366: LD_VAR 0 10
56370: PUSH
56371: LD_VAR 0 6
56375: PPUSH
56376: CALL_OW 311
56380: PPUSH
56381: LD_INT 3
56383: PPUSH
56384: CALL_OW 259
56388: PUSH
56389: LD_INT 4
56391: MUL
56392: MUL
56393: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56394: LD_VAR 0 6
56398: PPUSH
56399: CALL_OW 263
56403: PUSH
56404: LD_INT 2
56406: EQUAL
56407: IFFALSE 56458
// begin j := IsControledBy ( i ) ;
56409: LD_ADDR_VAR 0 7
56413: PUSH
56414: LD_VAR 0 6
56418: PPUSH
56419: CALL_OW 312
56423: ST_TO_ADDR
// if j then
56424: LD_VAR 0 7
56428: IFFALSE 56458
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56430: LD_ADDR_VAR 0 10
56434: PUSH
56435: LD_VAR 0 10
56439: PUSH
56440: LD_VAR 0 7
56444: PPUSH
56445: LD_INT 3
56447: PPUSH
56448: CALL_OW 259
56452: PUSH
56453: LD_INT 3
56455: MUL
56456: MUL
56457: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56458: LD_VAR 0 6
56462: PPUSH
56463: CALL_OW 264
56467: PUSH
56468: LD_INT 5
56470: PUSH
56471: LD_INT 6
56473: PUSH
56474: LD_INT 46
56476: PUSH
56477: LD_INT 44
56479: PUSH
56480: LD_INT 47
56482: PUSH
56483: LD_INT 45
56485: PUSH
56486: LD_INT 28
56488: PUSH
56489: LD_INT 7
56491: PUSH
56492: LD_INT 27
56494: PUSH
56495: LD_INT 29
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: LIST
56502: LIST
56503: LIST
56504: LIST
56505: LIST
56506: LIST
56507: LIST
56508: LIST
56509: IN
56510: PUSH
56511: LD_VAR 0 1
56515: PPUSH
56516: LD_INT 52
56518: PPUSH
56519: CALL_OW 321
56523: PUSH
56524: LD_INT 2
56526: EQUAL
56527: AND
56528: IFFALSE 56545
// bpoints := bpoints * 1.2 ;
56530: LD_ADDR_VAR 0 10
56534: PUSH
56535: LD_VAR 0 10
56539: PUSH
56540: LD_REAL  1.20000000000000E+0000
56543: MUL
56544: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56545: LD_VAR 0 6
56549: PPUSH
56550: CALL_OW 264
56554: PUSH
56555: LD_INT 6
56557: PUSH
56558: LD_INT 46
56560: PUSH
56561: LD_INT 47
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: LIST
56568: IN
56569: IFFALSE 56586
// bpoints := bpoints * 1.2 ;
56571: LD_ADDR_VAR 0 10
56575: PUSH
56576: LD_VAR 0 10
56580: PUSH
56581: LD_REAL  1.20000000000000E+0000
56584: MUL
56585: ST_TO_ADDR
// end ; unit_building :
56586: GO 56600
56588: LD_INT 3
56590: DOUBLE
56591: EQUAL
56592: IFTRUE 56596
56594: GO 56599
56596: POP
// ; end ;
56597: GO 56600
56599: POP
// for j = 1 to 3 do
56600: LD_ADDR_VAR 0 7
56604: PUSH
56605: DOUBLE
56606: LD_INT 1
56608: DEC
56609: ST_TO_ADDR
56610: LD_INT 3
56612: PUSH
56613: FOR_TO
56614: IFFALSE 56667
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56616: LD_ADDR_VAR 0 5
56620: PUSH
56621: LD_VAR 0 5
56625: PPUSH
56626: LD_VAR 0 7
56630: PPUSH
56631: LD_VAR 0 5
56635: PUSH
56636: LD_VAR 0 7
56640: ARRAY
56641: PUSH
56642: LD_VAR 0 9
56646: PUSH
56647: LD_VAR 0 7
56651: ARRAY
56652: PUSH
56653: LD_VAR 0 10
56657: MUL
56658: PLUS
56659: PPUSH
56660: CALL_OW 1
56664: ST_TO_ADDR
56665: GO 56613
56667: POP
56668: POP
// end ;
56669: GO 55152
56671: POP
56672: POP
// result := Replace ( result , 4 , tmp ) ;
56673: LD_ADDR_VAR 0 5
56677: PUSH
56678: LD_VAR 0 5
56682: PPUSH
56683: LD_INT 4
56685: PPUSH
56686: LD_VAR 0 8
56690: PPUSH
56691: CALL_OW 1
56695: ST_TO_ADDR
// end ;
56696: LD_VAR 0 5
56700: RET
// export function DangerAtRange ( unit , range ) ; begin
56701: LD_INT 0
56703: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56704: LD_ADDR_VAR 0 3
56708: PUSH
56709: LD_VAR 0 1
56713: PPUSH
56714: CALL_OW 255
56718: PPUSH
56719: LD_VAR 0 1
56723: PPUSH
56724: CALL_OW 250
56728: PPUSH
56729: LD_VAR 0 1
56733: PPUSH
56734: CALL_OW 251
56738: PPUSH
56739: LD_VAR 0 2
56743: PPUSH
56744: CALL 55004 0 4
56748: ST_TO_ADDR
// end ;
56749: LD_VAR 0 3
56753: RET
// export function DangerInArea ( side , area ) ; begin
56754: LD_INT 0
56756: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56757: LD_ADDR_VAR 0 3
56761: PUSH
56762: LD_VAR 0 2
56766: PPUSH
56767: LD_INT 81
56769: PUSH
56770: LD_VAR 0 1
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PPUSH
56779: CALL_OW 70
56783: ST_TO_ADDR
// end ;
56784: LD_VAR 0 3
56788: RET
// export function IsExtension ( b ) ; begin
56789: LD_INT 0
56791: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56792: LD_ADDR_VAR 0 2
56796: PUSH
56797: LD_VAR 0 1
56801: PUSH
56802: LD_INT 23
56804: PUSH
56805: LD_INT 20
56807: PUSH
56808: LD_INT 22
56810: PUSH
56811: LD_INT 17
56813: PUSH
56814: LD_INT 24
56816: PUSH
56817: LD_INT 21
56819: PUSH
56820: LD_INT 19
56822: PUSH
56823: LD_INT 16
56825: PUSH
56826: LD_INT 25
56828: PUSH
56829: LD_INT 18
56831: PUSH
56832: EMPTY
56833: LIST
56834: LIST
56835: LIST
56836: LIST
56837: LIST
56838: LIST
56839: LIST
56840: LIST
56841: LIST
56842: LIST
56843: IN
56844: ST_TO_ADDR
// end ;
56845: LD_VAR 0 2
56849: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
56850: LD_INT 0
56852: PPUSH
56853: PPUSH
56854: PPUSH
// result := [ ] ;
56855: LD_ADDR_VAR 0 3
56859: PUSH
56860: EMPTY
56861: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56862: LD_ADDR_VAR 0 4
56866: PUSH
56867: LD_VAR 0 2
56871: PPUSH
56872: LD_INT 21
56874: PUSH
56875: LD_INT 3
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: PPUSH
56882: CALL_OW 70
56886: ST_TO_ADDR
// if not tmp then
56887: LD_VAR 0 4
56891: NOT
56892: IFFALSE 56896
// exit ;
56894: GO 56954
// for i in tmp do
56896: LD_ADDR_VAR 0 5
56900: PUSH
56901: LD_VAR 0 4
56905: PUSH
56906: FOR_IN
56907: IFFALSE 56942
// if GetBase ( i ) <> base then
56909: LD_VAR 0 5
56913: PPUSH
56914: CALL_OW 274
56918: PUSH
56919: LD_VAR 0 1
56923: NONEQUAL
56924: IFFALSE 56940
// ComLinkToBase ( base , i ) ;
56926: LD_VAR 0 1
56930: PPUSH
56931: LD_VAR 0 5
56935: PPUSH
56936: CALL_OW 169
56940: GO 56906
56942: POP
56943: POP
// result := tmp ;
56944: LD_ADDR_VAR 0 3
56948: PUSH
56949: LD_VAR 0 4
56953: ST_TO_ADDR
// end ;
56954: LD_VAR 0 3
56958: RET
// export function ComComplete ( unit , b ) ; var i ; begin
56959: LD_INT 0
56961: PPUSH
56962: PPUSH
// if BuildingStatus ( b ) = bs_build then
56963: LD_VAR 0 2
56967: PPUSH
56968: CALL_OW 461
56972: PUSH
56973: LD_INT 1
56975: EQUAL
56976: IFFALSE 57036
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56978: LD_VAR 0 1
56982: PPUSH
56983: LD_STRING h
56985: PUSH
56986: LD_VAR 0 2
56990: PPUSH
56991: CALL_OW 250
56995: PUSH
56996: LD_VAR 0 2
57000: PPUSH
57001: CALL_OW 251
57005: PUSH
57006: LD_VAR 0 2
57010: PUSH
57011: LD_INT 0
57013: PUSH
57014: LD_INT 0
57016: PUSH
57017: LD_INT 0
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: LIST
57025: LIST
57026: LIST
57027: LIST
57028: PUSH
57029: EMPTY
57030: LIST
57031: PPUSH
57032: CALL_OW 446
// end ;
57036: LD_VAR 0 3
57040: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57041: LD_INT 0
57043: PPUSH
57044: PPUSH
57045: PPUSH
57046: PPUSH
57047: PPUSH
57048: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57049: LD_VAR 0 1
57053: NOT
57054: PUSH
57055: LD_VAR 0 1
57059: PPUSH
57060: CALL_OW 263
57064: PUSH
57065: LD_INT 2
57067: EQUAL
57068: NOT
57069: OR
57070: IFFALSE 57074
// exit ;
57072: GO 57390
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57074: LD_ADDR_VAR 0 6
57078: PUSH
57079: LD_INT 22
57081: PUSH
57082: LD_VAR 0 1
57086: PPUSH
57087: CALL_OW 255
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: PUSH
57096: LD_INT 2
57098: PUSH
57099: LD_INT 30
57101: PUSH
57102: LD_INT 36
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: PUSH
57109: LD_INT 34
57111: PUSH
57112: LD_INT 31
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PUSH
57119: EMPTY
57120: LIST
57121: LIST
57122: LIST
57123: PUSH
57124: EMPTY
57125: LIST
57126: LIST
57127: PPUSH
57128: CALL_OW 69
57132: ST_TO_ADDR
// if not tmp then
57133: LD_VAR 0 6
57137: NOT
57138: IFFALSE 57142
// exit ;
57140: GO 57390
// result := [ ] ;
57142: LD_ADDR_VAR 0 2
57146: PUSH
57147: EMPTY
57148: ST_TO_ADDR
// for i in tmp do
57149: LD_ADDR_VAR 0 3
57153: PUSH
57154: LD_VAR 0 6
57158: PUSH
57159: FOR_IN
57160: IFFALSE 57231
// begin t := UnitsInside ( i ) ;
57162: LD_ADDR_VAR 0 4
57166: PUSH
57167: LD_VAR 0 3
57171: PPUSH
57172: CALL_OW 313
57176: ST_TO_ADDR
// if t then
57177: LD_VAR 0 4
57181: IFFALSE 57229
// for j in t do
57183: LD_ADDR_VAR 0 7
57187: PUSH
57188: LD_VAR 0 4
57192: PUSH
57193: FOR_IN
57194: IFFALSE 57227
// result := Insert ( result , result + 1 , j ) ;
57196: LD_ADDR_VAR 0 2
57200: PUSH
57201: LD_VAR 0 2
57205: PPUSH
57206: LD_VAR 0 2
57210: PUSH
57211: LD_INT 1
57213: PLUS
57214: PPUSH
57215: LD_VAR 0 7
57219: PPUSH
57220: CALL_OW 2
57224: ST_TO_ADDR
57225: GO 57193
57227: POP
57228: POP
// end ;
57229: GO 57159
57231: POP
57232: POP
// if not result then
57233: LD_VAR 0 2
57237: NOT
57238: IFFALSE 57242
// exit ;
57240: GO 57390
// mech := result [ 1 ] ;
57242: LD_ADDR_VAR 0 5
57246: PUSH
57247: LD_VAR 0 2
57251: PUSH
57252: LD_INT 1
57254: ARRAY
57255: ST_TO_ADDR
// if result > 1 then
57256: LD_VAR 0 2
57260: PUSH
57261: LD_INT 1
57263: GREATER
57264: IFFALSE 57376
// for i = 2 to result do
57266: LD_ADDR_VAR 0 3
57270: PUSH
57271: DOUBLE
57272: LD_INT 2
57274: DEC
57275: ST_TO_ADDR
57276: LD_VAR 0 2
57280: PUSH
57281: FOR_TO
57282: IFFALSE 57374
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57284: LD_ADDR_VAR 0 4
57288: PUSH
57289: LD_VAR 0 2
57293: PUSH
57294: LD_VAR 0 3
57298: ARRAY
57299: PPUSH
57300: LD_INT 3
57302: PPUSH
57303: CALL_OW 259
57307: PUSH
57308: LD_VAR 0 2
57312: PUSH
57313: LD_VAR 0 3
57317: ARRAY
57318: PPUSH
57319: CALL_OW 432
57323: MINUS
57324: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57325: LD_VAR 0 4
57329: PUSH
57330: LD_VAR 0 5
57334: PPUSH
57335: LD_INT 3
57337: PPUSH
57338: CALL_OW 259
57342: PUSH
57343: LD_VAR 0 5
57347: PPUSH
57348: CALL_OW 432
57352: MINUS
57353: GREATEREQUAL
57354: IFFALSE 57372
// mech := result [ i ] ;
57356: LD_ADDR_VAR 0 5
57360: PUSH
57361: LD_VAR 0 2
57365: PUSH
57366: LD_VAR 0 3
57370: ARRAY
57371: ST_TO_ADDR
// end ;
57372: GO 57281
57374: POP
57375: POP
// ComLinkTo ( vehicle , mech ) ;
57376: LD_VAR 0 1
57380: PPUSH
57381: LD_VAR 0 5
57385: PPUSH
57386: CALL_OW 135
// end ;
57390: LD_VAR 0 2
57394: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57395: LD_INT 0
57397: PPUSH
57398: PPUSH
57399: PPUSH
57400: PPUSH
57401: PPUSH
57402: PPUSH
57403: PPUSH
57404: PPUSH
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
57409: PPUSH
// result := [ ] ;
57410: LD_ADDR_VAR 0 7
57414: PUSH
57415: EMPTY
57416: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57417: LD_VAR 0 1
57421: PPUSH
57422: CALL_OW 266
57426: PUSH
57427: LD_INT 0
57429: PUSH
57430: LD_INT 1
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: IN
57437: NOT
57438: IFFALSE 57442
// exit ;
57440: GO 59073
// if name then
57442: LD_VAR 0 3
57446: IFFALSE 57462
// SetBName ( base_dep , name ) ;
57448: LD_VAR 0 1
57452: PPUSH
57453: LD_VAR 0 3
57457: PPUSH
57458: CALL_OW 500
// base := GetBase ( base_dep ) ;
57462: LD_ADDR_VAR 0 15
57466: PUSH
57467: LD_VAR 0 1
57471: PPUSH
57472: CALL_OW 274
57476: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57477: LD_ADDR_VAR 0 16
57481: PUSH
57482: LD_VAR 0 1
57486: PPUSH
57487: CALL_OW 255
57491: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57492: LD_ADDR_VAR 0 17
57496: PUSH
57497: LD_VAR 0 1
57501: PPUSH
57502: CALL_OW 248
57506: ST_TO_ADDR
// if sources then
57507: LD_VAR 0 5
57511: IFFALSE 57558
// for i = 1 to 3 do
57513: LD_ADDR_VAR 0 8
57517: PUSH
57518: DOUBLE
57519: LD_INT 1
57521: DEC
57522: ST_TO_ADDR
57523: LD_INT 3
57525: PUSH
57526: FOR_TO
57527: IFFALSE 57556
// AddResourceType ( base , i , sources [ i ] ) ;
57529: LD_VAR 0 15
57533: PPUSH
57534: LD_VAR 0 8
57538: PPUSH
57539: LD_VAR 0 5
57543: PUSH
57544: LD_VAR 0 8
57548: ARRAY
57549: PPUSH
57550: CALL_OW 276
57554: GO 57526
57556: POP
57557: POP
// buildings := GetBaseBuildings ( base , area ) ;
57558: LD_ADDR_VAR 0 18
57562: PUSH
57563: LD_VAR 0 15
57567: PPUSH
57568: LD_VAR 0 2
57572: PPUSH
57573: CALL 56850 0 2
57577: ST_TO_ADDR
// InitHc ;
57578: CALL_OW 19
// InitUc ;
57582: CALL_OW 18
// uc_side := side ;
57586: LD_ADDR_OWVAR 20
57590: PUSH
57591: LD_VAR 0 16
57595: ST_TO_ADDR
// uc_nation := nation ;
57596: LD_ADDR_OWVAR 21
57600: PUSH
57601: LD_VAR 0 17
57605: ST_TO_ADDR
// if buildings then
57606: LD_VAR 0 18
57610: IFFALSE 58932
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57612: LD_ADDR_VAR 0 19
57616: PUSH
57617: LD_VAR 0 18
57621: PPUSH
57622: LD_INT 2
57624: PUSH
57625: LD_INT 30
57627: PUSH
57628: LD_INT 29
57630: PUSH
57631: EMPTY
57632: LIST
57633: LIST
57634: PUSH
57635: LD_INT 30
57637: PUSH
57638: LD_INT 30
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: LIST
57649: PPUSH
57650: CALL_OW 72
57654: ST_TO_ADDR
// if tmp then
57655: LD_VAR 0 19
57659: IFFALSE 57707
// for i in tmp do
57661: LD_ADDR_VAR 0 8
57665: PUSH
57666: LD_VAR 0 19
57670: PUSH
57671: FOR_IN
57672: IFFALSE 57705
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57674: LD_VAR 0 8
57678: PPUSH
57679: CALL_OW 250
57683: PPUSH
57684: LD_VAR 0 8
57688: PPUSH
57689: CALL_OW 251
57693: PPUSH
57694: LD_VAR 0 16
57698: PPUSH
57699: CALL_OW 441
57703: GO 57671
57705: POP
57706: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57707: LD_VAR 0 18
57711: PPUSH
57712: LD_INT 2
57714: PUSH
57715: LD_INT 30
57717: PUSH
57718: LD_INT 32
57720: PUSH
57721: EMPTY
57722: LIST
57723: LIST
57724: PUSH
57725: LD_INT 30
57727: PUSH
57728: LD_INT 33
57730: PUSH
57731: EMPTY
57732: LIST
57733: LIST
57734: PUSH
57735: EMPTY
57736: LIST
57737: LIST
57738: LIST
57739: PPUSH
57740: CALL_OW 72
57744: IFFALSE 57832
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57746: LD_ADDR_VAR 0 8
57750: PUSH
57751: LD_VAR 0 18
57755: PPUSH
57756: LD_INT 2
57758: PUSH
57759: LD_INT 30
57761: PUSH
57762: LD_INT 32
57764: PUSH
57765: EMPTY
57766: LIST
57767: LIST
57768: PUSH
57769: LD_INT 30
57771: PUSH
57772: LD_INT 33
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: PUSH
57779: EMPTY
57780: LIST
57781: LIST
57782: LIST
57783: PPUSH
57784: CALL_OW 72
57788: PUSH
57789: FOR_IN
57790: IFFALSE 57830
// begin if not GetBWeapon ( i ) then
57792: LD_VAR 0 8
57796: PPUSH
57797: CALL_OW 269
57801: NOT
57802: IFFALSE 57828
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57804: LD_VAR 0 8
57808: PPUSH
57809: LD_VAR 0 8
57813: PPUSH
57814: LD_VAR 0 2
57818: PPUSH
57819: CALL 59078 0 2
57823: PPUSH
57824: CALL_OW 431
// end ;
57828: GO 57789
57830: POP
57831: POP
// end ; for i = 1 to personel do
57832: LD_ADDR_VAR 0 8
57836: PUSH
57837: DOUBLE
57838: LD_INT 1
57840: DEC
57841: ST_TO_ADDR
57842: LD_VAR 0 6
57846: PUSH
57847: FOR_TO
57848: IFFALSE 58912
// begin if i > 4 then
57850: LD_VAR 0 8
57854: PUSH
57855: LD_INT 4
57857: GREATER
57858: IFFALSE 57862
// break ;
57860: GO 58912
// case i of 1 :
57862: LD_VAR 0 8
57866: PUSH
57867: LD_INT 1
57869: DOUBLE
57870: EQUAL
57871: IFTRUE 57875
57873: GO 57955
57875: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57876: LD_ADDR_VAR 0 12
57880: PUSH
57881: LD_VAR 0 18
57885: PPUSH
57886: LD_INT 22
57888: PUSH
57889: LD_VAR 0 16
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: PUSH
57898: LD_INT 58
57900: PUSH
57901: EMPTY
57902: LIST
57903: PUSH
57904: LD_INT 2
57906: PUSH
57907: LD_INT 30
57909: PUSH
57910: LD_INT 32
57912: PUSH
57913: EMPTY
57914: LIST
57915: LIST
57916: PUSH
57917: LD_INT 30
57919: PUSH
57920: LD_INT 4
57922: PUSH
57923: EMPTY
57924: LIST
57925: LIST
57926: PUSH
57927: LD_INT 30
57929: PUSH
57930: LD_INT 5
57932: PUSH
57933: EMPTY
57934: LIST
57935: LIST
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: LIST
57941: LIST
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: LIST
57947: PPUSH
57948: CALL_OW 72
57952: ST_TO_ADDR
57953: GO 58177
57955: LD_INT 2
57957: DOUBLE
57958: EQUAL
57959: IFTRUE 57963
57961: GO 58025
57963: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57964: LD_ADDR_VAR 0 12
57968: PUSH
57969: LD_VAR 0 18
57973: PPUSH
57974: LD_INT 22
57976: PUSH
57977: LD_VAR 0 16
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PUSH
57986: LD_INT 2
57988: PUSH
57989: LD_INT 30
57991: PUSH
57992: LD_INT 0
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: PUSH
57999: LD_INT 30
58001: PUSH
58002: LD_INT 1
58004: PUSH
58005: EMPTY
58006: LIST
58007: LIST
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: LIST
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: PPUSH
58018: CALL_OW 72
58022: ST_TO_ADDR
58023: GO 58177
58025: LD_INT 3
58027: DOUBLE
58028: EQUAL
58029: IFTRUE 58033
58031: GO 58095
58033: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58034: LD_ADDR_VAR 0 12
58038: PUSH
58039: LD_VAR 0 18
58043: PPUSH
58044: LD_INT 22
58046: PUSH
58047: LD_VAR 0 16
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: PUSH
58056: LD_INT 2
58058: PUSH
58059: LD_INT 30
58061: PUSH
58062: LD_INT 2
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: PUSH
58069: LD_INT 30
58071: PUSH
58072: LD_INT 3
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: PUSH
58084: EMPTY
58085: LIST
58086: LIST
58087: PPUSH
58088: CALL_OW 72
58092: ST_TO_ADDR
58093: GO 58177
58095: LD_INT 4
58097: DOUBLE
58098: EQUAL
58099: IFTRUE 58103
58101: GO 58176
58103: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58104: LD_ADDR_VAR 0 12
58108: PUSH
58109: LD_VAR 0 18
58113: PPUSH
58114: LD_INT 22
58116: PUSH
58117: LD_VAR 0 16
58121: PUSH
58122: EMPTY
58123: LIST
58124: LIST
58125: PUSH
58126: LD_INT 2
58128: PUSH
58129: LD_INT 30
58131: PUSH
58132: LD_INT 6
58134: PUSH
58135: EMPTY
58136: LIST
58137: LIST
58138: PUSH
58139: LD_INT 30
58141: PUSH
58142: LD_INT 7
58144: PUSH
58145: EMPTY
58146: LIST
58147: LIST
58148: PUSH
58149: LD_INT 30
58151: PUSH
58152: LD_INT 8
58154: PUSH
58155: EMPTY
58156: LIST
58157: LIST
58158: PUSH
58159: EMPTY
58160: LIST
58161: LIST
58162: LIST
58163: LIST
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: PPUSH
58169: CALL_OW 72
58173: ST_TO_ADDR
58174: GO 58177
58176: POP
// if i = 1 then
58177: LD_VAR 0 8
58181: PUSH
58182: LD_INT 1
58184: EQUAL
58185: IFFALSE 58296
// begin tmp := [ ] ;
58187: LD_ADDR_VAR 0 19
58191: PUSH
58192: EMPTY
58193: ST_TO_ADDR
// for j in f do
58194: LD_ADDR_VAR 0 9
58198: PUSH
58199: LD_VAR 0 12
58203: PUSH
58204: FOR_IN
58205: IFFALSE 58278
// if GetBType ( j ) = b_bunker then
58207: LD_VAR 0 9
58211: PPUSH
58212: CALL_OW 266
58216: PUSH
58217: LD_INT 32
58219: EQUAL
58220: IFFALSE 58247
// tmp := Insert ( tmp , 1 , j ) else
58222: LD_ADDR_VAR 0 19
58226: PUSH
58227: LD_VAR 0 19
58231: PPUSH
58232: LD_INT 1
58234: PPUSH
58235: LD_VAR 0 9
58239: PPUSH
58240: CALL_OW 2
58244: ST_TO_ADDR
58245: GO 58276
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58247: LD_ADDR_VAR 0 19
58251: PUSH
58252: LD_VAR 0 19
58256: PPUSH
58257: LD_VAR 0 19
58261: PUSH
58262: LD_INT 1
58264: PLUS
58265: PPUSH
58266: LD_VAR 0 9
58270: PPUSH
58271: CALL_OW 2
58275: ST_TO_ADDR
58276: GO 58204
58278: POP
58279: POP
// if tmp then
58280: LD_VAR 0 19
58284: IFFALSE 58296
// f := tmp ;
58286: LD_ADDR_VAR 0 12
58290: PUSH
58291: LD_VAR 0 19
58295: ST_TO_ADDR
// end ; x := personel [ i ] ;
58296: LD_ADDR_VAR 0 13
58300: PUSH
58301: LD_VAR 0 6
58305: PUSH
58306: LD_VAR 0 8
58310: ARRAY
58311: ST_TO_ADDR
// if x = - 1 then
58312: LD_VAR 0 13
58316: PUSH
58317: LD_INT 1
58319: NEG
58320: EQUAL
58321: IFFALSE 58530
// begin for j in f do
58323: LD_ADDR_VAR 0 9
58327: PUSH
58328: LD_VAR 0 12
58332: PUSH
58333: FOR_IN
58334: IFFALSE 58526
// repeat InitHc ;
58336: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58340: LD_VAR 0 9
58344: PPUSH
58345: CALL_OW 266
58349: PUSH
58350: LD_INT 5
58352: EQUAL
58353: IFFALSE 58423
// begin if UnitsInside ( j ) < 3 then
58355: LD_VAR 0 9
58359: PPUSH
58360: CALL_OW 313
58364: PUSH
58365: LD_INT 3
58367: LESS
58368: IFFALSE 58404
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58370: LD_INT 0
58372: PPUSH
58373: LD_INT 5
58375: PUSH
58376: LD_INT 8
58378: PUSH
58379: LD_INT 9
58381: PUSH
58382: EMPTY
58383: LIST
58384: LIST
58385: LIST
58386: PUSH
58387: LD_VAR 0 17
58391: ARRAY
58392: PPUSH
58393: LD_VAR 0 4
58397: PPUSH
58398: CALL_OW 380
58402: GO 58421
// PrepareHuman ( false , i , skill ) ;
58404: LD_INT 0
58406: PPUSH
58407: LD_VAR 0 8
58411: PPUSH
58412: LD_VAR 0 4
58416: PPUSH
58417: CALL_OW 380
// end else
58421: GO 58440
// PrepareHuman ( false , i , skill ) ;
58423: LD_INT 0
58425: PPUSH
58426: LD_VAR 0 8
58430: PPUSH
58431: LD_VAR 0 4
58435: PPUSH
58436: CALL_OW 380
// un := CreateHuman ;
58440: LD_ADDR_VAR 0 14
58444: PUSH
58445: CALL_OW 44
58449: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58450: LD_ADDR_VAR 0 7
58454: PUSH
58455: LD_VAR 0 7
58459: PPUSH
58460: LD_INT 1
58462: PPUSH
58463: LD_VAR 0 14
58467: PPUSH
58468: CALL_OW 2
58472: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58473: LD_VAR 0 14
58477: PPUSH
58478: LD_VAR 0 9
58482: PPUSH
58483: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58487: LD_VAR 0 9
58491: PPUSH
58492: CALL_OW 313
58496: PUSH
58497: LD_INT 6
58499: EQUAL
58500: PUSH
58501: LD_VAR 0 9
58505: PPUSH
58506: CALL_OW 266
58510: PUSH
58511: LD_INT 32
58513: PUSH
58514: LD_INT 31
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: IN
58521: OR
58522: IFFALSE 58336
58524: GO 58333
58526: POP
58527: POP
// end else
58528: GO 58910
// for j = 1 to x do
58530: LD_ADDR_VAR 0 9
58534: PUSH
58535: DOUBLE
58536: LD_INT 1
58538: DEC
58539: ST_TO_ADDR
58540: LD_VAR 0 13
58544: PUSH
58545: FOR_TO
58546: IFFALSE 58908
// begin InitHc ;
58548: CALL_OW 19
// if not f then
58552: LD_VAR 0 12
58556: NOT
58557: IFFALSE 58646
// begin PrepareHuman ( false , i , skill ) ;
58559: LD_INT 0
58561: PPUSH
58562: LD_VAR 0 8
58566: PPUSH
58567: LD_VAR 0 4
58571: PPUSH
58572: CALL_OW 380
// un := CreateHuman ;
58576: LD_ADDR_VAR 0 14
58580: PUSH
58581: CALL_OW 44
58585: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58586: LD_ADDR_VAR 0 7
58590: PUSH
58591: LD_VAR 0 7
58595: PPUSH
58596: LD_INT 1
58598: PPUSH
58599: LD_VAR 0 14
58603: PPUSH
58604: CALL_OW 2
58608: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58609: LD_VAR 0 14
58613: PPUSH
58614: LD_VAR 0 1
58618: PPUSH
58619: CALL_OW 250
58623: PPUSH
58624: LD_VAR 0 1
58628: PPUSH
58629: CALL_OW 251
58633: PPUSH
58634: LD_INT 10
58636: PPUSH
58637: LD_INT 0
58639: PPUSH
58640: CALL_OW 50
// continue ;
58644: GO 58545
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58646: LD_VAR 0 12
58650: PUSH
58651: LD_INT 1
58653: ARRAY
58654: PPUSH
58655: CALL_OW 313
58659: PUSH
58660: LD_VAR 0 12
58664: PUSH
58665: LD_INT 1
58667: ARRAY
58668: PPUSH
58669: CALL_OW 266
58673: PUSH
58674: LD_INT 32
58676: PUSH
58677: LD_INT 31
58679: PUSH
58680: EMPTY
58681: LIST
58682: LIST
58683: IN
58684: AND
58685: PUSH
58686: LD_VAR 0 12
58690: PUSH
58691: LD_INT 1
58693: ARRAY
58694: PPUSH
58695: CALL_OW 313
58699: PUSH
58700: LD_INT 6
58702: EQUAL
58703: OR
58704: IFFALSE 58724
// f := Delete ( f , 1 ) ;
58706: LD_ADDR_VAR 0 12
58710: PUSH
58711: LD_VAR 0 12
58715: PPUSH
58716: LD_INT 1
58718: PPUSH
58719: CALL_OW 3
58723: ST_TO_ADDR
// if not f then
58724: LD_VAR 0 12
58728: NOT
58729: IFFALSE 58747
// begin x := x + 2 ;
58731: LD_ADDR_VAR 0 13
58735: PUSH
58736: LD_VAR 0 13
58740: PUSH
58741: LD_INT 2
58743: PLUS
58744: ST_TO_ADDR
// continue ;
58745: GO 58545
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58747: LD_VAR 0 12
58751: PUSH
58752: LD_INT 1
58754: ARRAY
58755: PPUSH
58756: CALL_OW 266
58760: PUSH
58761: LD_INT 5
58763: EQUAL
58764: IFFALSE 58838
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58766: LD_VAR 0 12
58770: PUSH
58771: LD_INT 1
58773: ARRAY
58774: PPUSH
58775: CALL_OW 313
58779: PUSH
58780: LD_INT 3
58782: LESS
58783: IFFALSE 58819
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58785: LD_INT 0
58787: PPUSH
58788: LD_INT 5
58790: PUSH
58791: LD_INT 8
58793: PUSH
58794: LD_INT 9
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: LIST
58801: PUSH
58802: LD_VAR 0 17
58806: ARRAY
58807: PPUSH
58808: LD_VAR 0 4
58812: PPUSH
58813: CALL_OW 380
58817: GO 58836
// PrepareHuman ( false , i , skill ) ;
58819: LD_INT 0
58821: PPUSH
58822: LD_VAR 0 8
58826: PPUSH
58827: LD_VAR 0 4
58831: PPUSH
58832: CALL_OW 380
// end else
58836: GO 58855
// PrepareHuman ( false , i , skill ) ;
58838: LD_INT 0
58840: PPUSH
58841: LD_VAR 0 8
58845: PPUSH
58846: LD_VAR 0 4
58850: PPUSH
58851: CALL_OW 380
// un := CreateHuman ;
58855: LD_ADDR_VAR 0 14
58859: PUSH
58860: CALL_OW 44
58864: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58865: LD_ADDR_VAR 0 7
58869: PUSH
58870: LD_VAR 0 7
58874: PPUSH
58875: LD_INT 1
58877: PPUSH
58878: LD_VAR 0 14
58882: PPUSH
58883: CALL_OW 2
58887: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58888: LD_VAR 0 14
58892: PPUSH
58893: LD_VAR 0 12
58897: PUSH
58898: LD_INT 1
58900: ARRAY
58901: PPUSH
58902: CALL_OW 52
// end ;
58906: GO 58545
58908: POP
58909: POP
// end ;
58910: GO 57847
58912: POP
58913: POP
// result := result ^ buildings ;
58914: LD_ADDR_VAR 0 7
58918: PUSH
58919: LD_VAR 0 7
58923: PUSH
58924: LD_VAR 0 18
58928: ADD
58929: ST_TO_ADDR
// end else
58930: GO 59073
// begin for i = 1 to personel do
58932: LD_ADDR_VAR 0 8
58936: PUSH
58937: DOUBLE
58938: LD_INT 1
58940: DEC
58941: ST_TO_ADDR
58942: LD_VAR 0 6
58946: PUSH
58947: FOR_TO
58948: IFFALSE 59071
// begin if i > 4 then
58950: LD_VAR 0 8
58954: PUSH
58955: LD_INT 4
58957: GREATER
58958: IFFALSE 58962
// break ;
58960: GO 59071
// x := personel [ i ] ;
58962: LD_ADDR_VAR 0 13
58966: PUSH
58967: LD_VAR 0 6
58971: PUSH
58972: LD_VAR 0 8
58976: ARRAY
58977: ST_TO_ADDR
// if x = - 1 then
58978: LD_VAR 0 13
58982: PUSH
58983: LD_INT 1
58985: NEG
58986: EQUAL
58987: IFFALSE 58991
// continue ;
58989: GO 58947
// PrepareHuman ( false , i , skill ) ;
58991: LD_INT 0
58993: PPUSH
58994: LD_VAR 0 8
58998: PPUSH
58999: LD_VAR 0 4
59003: PPUSH
59004: CALL_OW 380
// un := CreateHuman ;
59008: LD_ADDR_VAR 0 14
59012: PUSH
59013: CALL_OW 44
59017: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59018: LD_VAR 0 14
59022: PPUSH
59023: LD_VAR 0 1
59027: PPUSH
59028: CALL_OW 250
59032: PPUSH
59033: LD_VAR 0 1
59037: PPUSH
59038: CALL_OW 251
59042: PPUSH
59043: LD_INT 10
59045: PPUSH
59046: LD_INT 0
59048: PPUSH
59049: CALL_OW 50
// result := result ^ un ;
59053: LD_ADDR_VAR 0 7
59057: PUSH
59058: LD_VAR 0 7
59062: PUSH
59063: LD_VAR 0 14
59067: ADD
59068: ST_TO_ADDR
// end ;
59069: GO 58947
59071: POP
59072: POP
// end ; end ;
59073: LD_VAR 0 7
59077: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59078: LD_INT 0
59080: PPUSH
59081: PPUSH
59082: PPUSH
59083: PPUSH
59084: PPUSH
59085: PPUSH
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
// result := false ;
59096: LD_ADDR_VAR 0 3
59100: PUSH
59101: LD_INT 0
59103: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59104: LD_VAR 0 1
59108: NOT
59109: PUSH
59110: LD_VAR 0 1
59114: PPUSH
59115: CALL_OW 266
59119: PUSH
59120: LD_INT 32
59122: PUSH
59123: LD_INT 33
59125: PUSH
59126: EMPTY
59127: LIST
59128: LIST
59129: IN
59130: NOT
59131: OR
59132: IFFALSE 59136
// exit ;
59134: GO 60272
// nat := GetNation ( tower ) ;
59136: LD_ADDR_VAR 0 12
59140: PUSH
59141: LD_VAR 0 1
59145: PPUSH
59146: CALL_OW 248
59150: ST_TO_ADDR
// side := GetSide ( tower ) ;
59151: LD_ADDR_VAR 0 16
59155: PUSH
59156: LD_VAR 0 1
59160: PPUSH
59161: CALL_OW 255
59165: ST_TO_ADDR
// x := GetX ( tower ) ;
59166: LD_ADDR_VAR 0 10
59170: PUSH
59171: LD_VAR 0 1
59175: PPUSH
59176: CALL_OW 250
59180: ST_TO_ADDR
// y := GetY ( tower ) ;
59181: LD_ADDR_VAR 0 11
59185: PUSH
59186: LD_VAR 0 1
59190: PPUSH
59191: CALL_OW 251
59195: ST_TO_ADDR
// if not x or not y then
59196: LD_VAR 0 10
59200: NOT
59201: PUSH
59202: LD_VAR 0 11
59206: NOT
59207: OR
59208: IFFALSE 59212
// exit ;
59210: GO 60272
// weapon := 0 ;
59212: LD_ADDR_VAR 0 18
59216: PUSH
59217: LD_INT 0
59219: ST_TO_ADDR
// fac_list := [ ] ;
59220: LD_ADDR_VAR 0 17
59224: PUSH
59225: EMPTY
59226: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59227: LD_ADDR_VAR 0 6
59231: PUSH
59232: LD_VAR 0 1
59236: PPUSH
59237: CALL_OW 274
59241: PPUSH
59242: LD_VAR 0 2
59246: PPUSH
59247: CALL 56850 0 2
59251: PPUSH
59252: LD_INT 30
59254: PUSH
59255: LD_INT 3
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PPUSH
59262: CALL_OW 72
59266: ST_TO_ADDR
// if not factories then
59267: LD_VAR 0 6
59271: NOT
59272: IFFALSE 59276
// exit ;
59274: GO 60272
// for i in factories do
59276: LD_ADDR_VAR 0 8
59280: PUSH
59281: LD_VAR 0 6
59285: PUSH
59286: FOR_IN
59287: IFFALSE 59312
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59289: LD_ADDR_VAR 0 17
59293: PUSH
59294: LD_VAR 0 17
59298: PUSH
59299: LD_VAR 0 8
59303: PPUSH
59304: CALL_OW 478
59308: UNION
59309: ST_TO_ADDR
59310: GO 59286
59312: POP
59313: POP
// if not fac_list then
59314: LD_VAR 0 17
59318: NOT
59319: IFFALSE 59323
// exit ;
59321: GO 60272
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59323: LD_ADDR_VAR 0 5
59327: PUSH
59328: LD_INT 4
59330: PUSH
59331: LD_INT 5
59333: PUSH
59334: LD_INT 9
59336: PUSH
59337: LD_INT 10
59339: PUSH
59340: LD_INT 6
59342: PUSH
59343: LD_INT 7
59345: PUSH
59346: LD_INT 11
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: LIST
59353: LIST
59354: LIST
59355: LIST
59356: LIST
59357: PUSH
59358: LD_INT 27
59360: PUSH
59361: LD_INT 28
59363: PUSH
59364: LD_INT 26
59366: PUSH
59367: LD_INT 30
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: LIST
59374: LIST
59375: PUSH
59376: LD_INT 43
59378: PUSH
59379: LD_INT 44
59381: PUSH
59382: LD_INT 46
59384: PUSH
59385: LD_INT 45
59387: PUSH
59388: LD_INT 47
59390: PUSH
59391: LD_INT 49
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: LIST
59398: LIST
59399: LIST
59400: LIST
59401: PUSH
59402: EMPTY
59403: LIST
59404: LIST
59405: LIST
59406: PUSH
59407: LD_VAR 0 12
59411: ARRAY
59412: ST_TO_ADDR
// for i in list do
59413: LD_ADDR_VAR 0 8
59417: PUSH
59418: LD_VAR 0 5
59422: PUSH
59423: FOR_IN
59424: IFFALSE 59457
// if not i in fac_list then
59426: LD_VAR 0 8
59430: PUSH
59431: LD_VAR 0 17
59435: IN
59436: NOT
59437: IFFALSE 59455
// list := list diff i ;
59439: LD_ADDR_VAR 0 5
59443: PUSH
59444: LD_VAR 0 5
59448: PUSH
59449: LD_VAR 0 8
59453: DIFF
59454: ST_TO_ADDR
59455: GO 59423
59457: POP
59458: POP
// if not list then
59459: LD_VAR 0 5
59463: NOT
59464: IFFALSE 59468
// exit ;
59466: GO 60272
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59468: LD_VAR 0 12
59472: PUSH
59473: LD_INT 3
59475: EQUAL
59476: PUSH
59477: LD_INT 49
59479: PUSH
59480: LD_VAR 0 5
59484: IN
59485: AND
59486: PUSH
59487: LD_INT 31
59489: PPUSH
59490: LD_VAR 0 16
59494: PPUSH
59495: CALL_OW 321
59499: PUSH
59500: LD_INT 2
59502: EQUAL
59503: AND
59504: IFFALSE 59564
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59506: LD_INT 22
59508: PUSH
59509: LD_VAR 0 16
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PUSH
59518: LD_INT 35
59520: PUSH
59521: LD_INT 49
59523: PUSH
59524: EMPTY
59525: LIST
59526: LIST
59527: PUSH
59528: LD_INT 91
59530: PUSH
59531: LD_VAR 0 1
59535: PUSH
59536: LD_INT 10
59538: PUSH
59539: EMPTY
59540: LIST
59541: LIST
59542: LIST
59543: PUSH
59544: EMPTY
59545: LIST
59546: LIST
59547: LIST
59548: PPUSH
59549: CALL_OW 69
59553: NOT
59554: IFFALSE 59564
// weapon := ru_time_lapser ;
59556: LD_ADDR_VAR 0 18
59560: PUSH
59561: LD_INT 49
59563: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59564: LD_VAR 0 12
59568: PUSH
59569: LD_INT 1
59571: PUSH
59572: LD_INT 2
59574: PUSH
59575: EMPTY
59576: LIST
59577: LIST
59578: IN
59579: PUSH
59580: LD_INT 11
59582: PUSH
59583: LD_VAR 0 5
59587: IN
59588: PUSH
59589: LD_INT 30
59591: PUSH
59592: LD_VAR 0 5
59596: IN
59597: OR
59598: AND
59599: PUSH
59600: LD_INT 6
59602: PPUSH
59603: LD_VAR 0 16
59607: PPUSH
59608: CALL_OW 321
59612: PUSH
59613: LD_INT 2
59615: EQUAL
59616: AND
59617: IFFALSE 59782
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59619: LD_INT 22
59621: PUSH
59622: LD_VAR 0 16
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PUSH
59631: LD_INT 2
59633: PUSH
59634: LD_INT 35
59636: PUSH
59637: LD_INT 11
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: PUSH
59644: LD_INT 35
59646: PUSH
59647: LD_INT 30
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PUSH
59659: LD_INT 91
59661: PUSH
59662: LD_VAR 0 1
59666: PUSH
59667: LD_INT 18
59669: PUSH
59670: EMPTY
59671: LIST
59672: LIST
59673: LIST
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: LIST
59679: PPUSH
59680: CALL_OW 69
59684: NOT
59685: PUSH
59686: LD_INT 22
59688: PUSH
59689: LD_VAR 0 16
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: PUSH
59698: LD_INT 2
59700: PUSH
59701: LD_INT 30
59703: PUSH
59704: LD_INT 32
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 30
59713: PUSH
59714: LD_INT 33
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: LIST
59725: PUSH
59726: LD_INT 91
59728: PUSH
59729: LD_VAR 0 1
59733: PUSH
59734: LD_INT 12
59736: PUSH
59737: EMPTY
59738: LIST
59739: LIST
59740: LIST
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: LIST
59746: PUSH
59747: EMPTY
59748: LIST
59749: PPUSH
59750: CALL_OW 69
59754: PUSH
59755: LD_INT 2
59757: GREATER
59758: AND
59759: IFFALSE 59782
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59761: LD_ADDR_VAR 0 18
59765: PUSH
59766: LD_INT 11
59768: PUSH
59769: LD_INT 30
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_VAR 0 12
59780: ARRAY
59781: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59782: LD_VAR 0 18
59786: NOT
59787: PUSH
59788: LD_INT 40
59790: PPUSH
59791: LD_VAR 0 16
59795: PPUSH
59796: CALL_OW 321
59800: PUSH
59801: LD_INT 2
59803: EQUAL
59804: AND
59805: PUSH
59806: LD_INT 7
59808: PUSH
59809: LD_VAR 0 5
59813: IN
59814: PUSH
59815: LD_INT 28
59817: PUSH
59818: LD_VAR 0 5
59822: IN
59823: OR
59824: PUSH
59825: LD_INT 45
59827: PUSH
59828: LD_VAR 0 5
59832: IN
59833: OR
59834: AND
59835: IFFALSE 60089
// begin hex := GetHexInfo ( x , y ) ;
59837: LD_ADDR_VAR 0 4
59841: PUSH
59842: LD_VAR 0 10
59846: PPUSH
59847: LD_VAR 0 11
59851: PPUSH
59852: CALL_OW 546
59856: ST_TO_ADDR
// if hex [ 1 ] then
59857: LD_VAR 0 4
59861: PUSH
59862: LD_INT 1
59864: ARRAY
59865: IFFALSE 59869
// exit ;
59867: GO 60272
// height := hex [ 2 ] ;
59869: LD_ADDR_VAR 0 15
59873: PUSH
59874: LD_VAR 0 4
59878: PUSH
59879: LD_INT 2
59881: ARRAY
59882: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59883: LD_ADDR_VAR 0 14
59887: PUSH
59888: LD_INT 0
59890: PUSH
59891: LD_INT 2
59893: PUSH
59894: LD_INT 3
59896: PUSH
59897: LD_INT 5
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: LIST
59904: LIST
59905: ST_TO_ADDR
// for i in tmp do
59906: LD_ADDR_VAR 0 8
59910: PUSH
59911: LD_VAR 0 14
59915: PUSH
59916: FOR_IN
59917: IFFALSE 60087
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59919: LD_ADDR_VAR 0 9
59923: PUSH
59924: LD_VAR 0 10
59928: PPUSH
59929: LD_VAR 0 8
59933: PPUSH
59934: LD_INT 5
59936: PPUSH
59937: CALL_OW 272
59941: PUSH
59942: LD_VAR 0 11
59946: PPUSH
59947: LD_VAR 0 8
59951: PPUSH
59952: LD_INT 5
59954: PPUSH
59955: CALL_OW 273
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59964: LD_VAR 0 9
59968: PUSH
59969: LD_INT 1
59971: ARRAY
59972: PPUSH
59973: LD_VAR 0 9
59977: PUSH
59978: LD_INT 2
59980: ARRAY
59981: PPUSH
59982: CALL_OW 488
59986: IFFALSE 60085
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59988: LD_ADDR_VAR 0 4
59992: PUSH
59993: LD_VAR 0 9
59997: PUSH
59998: LD_INT 1
60000: ARRAY
60001: PPUSH
60002: LD_VAR 0 9
60006: PUSH
60007: LD_INT 2
60009: ARRAY
60010: PPUSH
60011: CALL_OW 546
60015: ST_TO_ADDR
// if hex [ 1 ] then
60016: LD_VAR 0 4
60020: PUSH
60021: LD_INT 1
60023: ARRAY
60024: IFFALSE 60028
// continue ;
60026: GO 59916
// h := hex [ 2 ] ;
60028: LD_ADDR_VAR 0 13
60032: PUSH
60033: LD_VAR 0 4
60037: PUSH
60038: LD_INT 2
60040: ARRAY
60041: ST_TO_ADDR
// if h + 7 < height then
60042: LD_VAR 0 13
60046: PUSH
60047: LD_INT 7
60049: PLUS
60050: PUSH
60051: LD_VAR 0 15
60055: LESS
60056: IFFALSE 60085
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60058: LD_ADDR_VAR 0 18
60062: PUSH
60063: LD_INT 7
60065: PUSH
60066: LD_INT 28
60068: PUSH
60069: LD_INT 45
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: LIST
60076: PUSH
60077: LD_VAR 0 12
60081: ARRAY
60082: ST_TO_ADDR
// break ;
60083: GO 60087
// end ; end ; end ;
60085: GO 59916
60087: POP
60088: POP
// end ; if not weapon then
60089: LD_VAR 0 18
60093: NOT
60094: IFFALSE 60154
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60096: LD_ADDR_VAR 0 5
60100: PUSH
60101: LD_VAR 0 5
60105: PUSH
60106: LD_INT 11
60108: PUSH
60109: LD_INT 30
60111: PUSH
60112: LD_INT 49
60114: PUSH
60115: EMPTY
60116: LIST
60117: LIST
60118: LIST
60119: DIFF
60120: ST_TO_ADDR
// if not list then
60121: LD_VAR 0 5
60125: NOT
60126: IFFALSE 60130
// exit ;
60128: GO 60272
// weapon := list [ rand ( 1 , list ) ] ;
60130: LD_ADDR_VAR 0 18
60134: PUSH
60135: LD_VAR 0 5
60139: PUSH
60140: LD_INT 1
60142: PPUSH
60143: LD_VAR 0 5
60147: PPUSH
60148: CALL_OW 12
60152: ARRAY
60153: ST_TO_ADDR
// end ; if weapon then
60154: LD_VAR 0 18
60158: IFFALSE 60272
// begin tmp := CostOfWeapon ( weapon ) ;
60160: LD_ADDR_VAR 0 14
60164: PUSH
60165: LD_VAR 0 18
60169: PPUSH
60170: CALL_OW 451
60174: ST_TO_ADDR
// j := GetBase ( tower ) ;
60175: LD_ADDR_VAR 0 9
60179: PUSH
60180: LD_VAR 0 1
60184: PPUSH
60185: CALL_OW 274
60189: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60190: LD_VAR 0 9
60194: PPUSH
60195: LD_INT 1
60197: PPUSH
60198: CALL_OW 275
60202: PUSH
60203: LD_VAR 0 14
60207: PUSH
60208: LD_INT 1
60210: ARRAY
60211: GREATEREQUAL
60212: PUSH
60213: LD_VAR 0 9
60217: PPUSH
60218: LD_INT 2
60220: PPUSH
60221: CALL_OW 275
60225: PUSH
60226: LD_VAR 0 14
60230: PUSH
60231: LD_INT 2
60233: ARRAY
60234: GREATEREQUAL
60235: AND
60236: PUSH
60237: LD_VAR 0 9
60241: PPUSH
60242: LD_INT 3
60244: PPUSH
60245: CALL_OW 275
60249: PUSH
60250: LD_VAR 0 14
60254: PUSH
60255: LD_INT 3
60257: ARRAY
60258: GREATEREQUAL
60259: AND
60260: IFFALSE 60272
// result := weapon ;
60262: LD_ADDR_VAR 0 3
60266: PUSH
60267: LD_VAR 0 18
60271: ST_TO_ADDR
// end ; end ;
60272: LD_VAR 0 3
60276: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60277: LD_INT 0
60279: PPUSH
60280: PPUSH
// result := true ;
60281: LD_ADDR_VAR 0 3
60285: PUSH
60286: LD_INT 1
60288: ST_TO_ADDR
// if array1 = array2 then
60289: LD_VAR 0 1
60293: PUSH
60294: LD_VAR 0 2
60298: EQUAL
60299: IFFALSE 60359
// begin for i = 1 to array1 do
60301: LD_ADDR_VAR 0 4
60305: PUSH
60306: DOUBLE
60307: LD_INT 1
60309: DEC
60310: ST_TO_ADDR
60311: LD_VAR 0 1
60315: PUSH
60316: FOR_TO
60317: IFFALSE 60355
// if array1 [ i ] <> array2 [ i ] then
60319: LD_VAR 0 1
60323: PUSH
60324: LD_VAR 0 4
60328: ARRAY
60329: PUSH
60330: LD_VAR 0 2
60334: PUSH
60335: LD_VAR 0 4
60339: ARRAY
60340: NONEQUAL
60341: IFFALSE 60353
// begin result := false ;
60343: LD_ADDR_VAR 0 3
60347: PUSH
60348: LD_INT 0
60350: ST_TO_ADDR
// break ;
60351: GO 60355
// end ;
60353: GO 60316
60355: POP
60356: POP
// end else
60357: GO 60367
// result := false ;
60359: LD_ADDR_VAR 0 3
60363: PUSH
60364: LD_INT 0
60366: ST_TO_ADDR
// end ;
60367: LD_VAR 0 3
60371: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60372: LD_INT 0
60374: PPUSH
60375: PPUSH
60376: PPUSH
// pom := GetBase ( fac ) ;
60377: LD_ADDR_VAR 0 5
60381: PUSH
60382: LD_VAR 0 1
60386: PPUSH
60387: CALL_OW 274
60391: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60392: LD_ADDR_VAR 0 4
60396: PUSH
60397: LD_VAR 0 2
60401: PUSH
60402: LD_INT 1
60404: ARRAY
60405: PPUSH
60406: LD_VAR 0 2
60410: PUSH
60411: LD_INT 2
60413: ARRAY
60414: PPUSH
60415: LD_VAR 0 2
60419: PUSH
60420: LD_INT 3
60422: ARRAY
60423: PPUSH
60424: LD_VAR 0 2
60428: PUSH
60429: LD_INT 4
60431: ARRAY
60432: PPUSH
60433: CALL_OW 449
60437: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60438: LD_ADDR_VAR 0 3
60442: PUSH
60443: LD_VAR 0 5
60447: PPUSH
60448: LD_INT 1
60450: PPUSH
60451: CALL_OW 275
60455: PUSH
60456: LD_VAR 0 4
60460: PUSH
60461: LD_INT 1
60463: ARRAY
60464: GREATEREQUAL
60465: PUSH
60466: LD_VAR 0 5
60470: PPUSH
60471: LD_INT 2
60473: PPUSH
60474: CALL_OW 275
60478: PUSH
60479: LD_VAR 0 4
60483: PUSH
60484: LD_INT 2
60486: ARRAY
60487: GREATEREQUAL
60488: AND
60489: PUSH
60490: LD_VAR 0 5
60494: PPUSH
60495: LD_INT 3
60497: PPUSH
60498: CALL_OW 275
60502: PUSH
60503: LD_VAR 0 4
60507: PUSH
60508: LD_INT 3
60510: ARRAY
60511: GREATEREQUAL
60512: AND
60513: ST_TO_ADDR
// end ;
60514: LD_VAR 0 3
60518: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60519: LD_INT 0
60521: PPUSH
60522: PPUSH
60523: PPUSH
60524: PPUSH
// pom := GetBase ( building ) ;
60525: LD_ADDR_VAR 0 3
60529: PUSH
60530: LD_VAR 0 1
60534: PPUSH
60535: CALL_OW 274
60539: ST_TO_ADDR
// if not pom then
60540: LD_VAR 0 3
60544: NOT
60545: IFFALSE 60549
// exit ;
60547: GO 60719
// btype := GetBType ( building ) ;
60549: LD_ADDR_VAR 0 5
60553: PUSH
60554: LD_VAR 0 1
60558: PPUSH
60559: CALL_OW 266
60563: ST_TO_ADDR
// if btype = b_armoury then
60564: LD_VAR 0 5
60568: PUSH
60569: LD_INT 4
60571: EQUAL
60572: IFFALSE 60582
// btype := b_barracks ;
60574: LD_ADDR_VAR 0 5
60578: PUSH
60579: LD_INT 5
60581: ST_TO_ADDR
// if btype = b_depot then
60582: LD_VAR 0 5
60586: PUSH
60587: LD_INT 0
60589: EQUAL
60590: IFFALSE 60600
// btype := b_warehouse ;
60592: LD_ADDR_VAR 0 5
60596: PUSH
60597: LD_INT 1
60599: ST_TO_ADDR
// if btype = b_workshop then
60600: LD_VAR 0 5
60604: PUSH
60605: LD_INT 2
60607: EQUAL
60608: IFFALSE 60618
// btype := b_factory ;
60610: LD_ADDR_VAR 0 5
60614: PUSH
60615: LD_INT 3
60617: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60618: LD_ADDR_VAR 0 4
60622: PUSH
60623: LD_VAR 0 5
60627: PPUSH
60628: LD_VAR 0 1
60632: PPUSH
60633: CALL_OW 248
60637: PPUSH
60638: CALL_OW 450
60642: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60643: LD_ADDR_VAR 0 2
60647: PUSH
60648: LD_VAR 0 3
60652: PPUSH
60653: LD_INT 1
60655: PPUSH
60656: CALL_OW 275
60660: PUSH
60661: LD_VAR 0 4
60665: PUSH
60666: LD_INT 1
60668: ARRAY
60669: GREATEREQUAL
60670: PUSH
60671: LD_VAR 0 3
60675: PPUSH
60676: LD_INT 2
60678: PPUSH
60679: CALL_OW 275
60683: PUSH
60684: LD_VAR 0 4
60688: PUSH
60689: LD_INT 2
60691: ARRAY
60692: GREATEREQUAL
60693: AND
60694: PUSH
60695: LD_VAR 0 3
60699: PPUSH
60700: LD_INT 3
60702: PPUSH
60703: CALL_OW 275
60707: PUSH
60708: LD_VAR 0 4
60712: PUSH
60713: LD_INT 3
60715: ARRAY
60716: GREATEREQUAL
60717: AND
60718: ST_TO_ADDR
// end ;
60719: LD_VAR 0 2
60723: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60724: LD_INT 0
60726: PPUSH
60727: PPUSH
60728: PPUSH
// pom := GetBase ( building ) ;
60729: LD_ADDR_VAR 0 4
60733: PUSH
60734: LD_VAR 0 1
60738: PPUSH
60739: CALL_OW 274
60743: ST_TO_ADDR
// if not pom then
60744: LD_VAR 0 4
60748: NOT
60749: IFFALSE 60753
// exit ;
60751: GO 60854
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60753: LD_ADDR_VAR 0 5
60757: PUSH
60758: LD_VAR 0 2
60762: PPUSH
60763: LD_VAR 0 1
60767: PPUSH
60768: CALL_OW 248
60772: PPUSH
60773: CALL_OW 450
60777: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60778: LD_ADDR_VAR 0 3
60782: PUSH
60783: LD_VAR 0 4
60787: PPUSH
60788: LD_INT 1
60790: PPUSH
60791: CALL_OW 275
60795: PUSH
60796: LD_VAR 0 5
60800: PUSH
60801: LD_INT 1
60803: ARRAY
60804: GREATEREQUAL
60805: PUSH
60806: LD_VAR 0 4
60810: PPUSH
60811: LD_INT 2
60813: PPUSH
60814: CALL_OW 275
60818: PUSH
60819: LD_VAR 0 5
60823: PUSH
60824: LD_INT 2
60826: ARRAY
60827: GREATEREQUAL
60828: AND
60829: PUSH
60830: LD_VAR 0 4
60834: PPUSH
60835: LD_INT 3
60837: PPUSH
60838: CALL_OW 275
60842: PUSH
60843: LD_VAR 0 5
60847: PUSH
60848: LD_INT 3
60850: ARRAY
60851: GREATEREQUAL
60852: AND
60853: ST_TO_ADDR
// end ;
60854: LD_VAR 0 3
60858: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
60859: LD_INT 0
60861: PPUSH
60862: PPUSH
60863: PPUSH
60864: PPUSH
60865: PPUSH
60866: PPUSH
60867: PPUSH
60868: PPUSH
60869: PPUSH
60870: PPUSH
// result := false ;
60871: LD_ADDR_VAR 0 6
60875: PUSH
60876: LD_INT 0
60878: ST_TO_ADDR
// if not base or not btype or not x or not y then
60879: LD_VAR 0 1
60883: NOT
60884: PUSH
60885: LD_VAR 0 2
60889: NOT
60890: OR
60891: PUSH
60892: LD_VAR 0 3
60896: NOT
60897: OR
60898: PUSH
60899: LD_VAR 0 4
60903: NOT
60904: OR
60905: IFFALSE 60909
// exit ;
60907: GO 61518
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
60909: LD_ADDR_VAR 0 12
60913: PUSH
60914: LD_VAR 0 2
60918: PPUSH
60919: LD_VAR 0 3
60923: PPUSH
60924: LD_VAR 0 4
60928: PPUSH
60929: LD_VAR 0 5
60933: PPUSH
60934: LD_VAR 0 1
60938: PUSH
60939: LD_INT 1
60941: ARRAY
60942: PPUSH
60943: CALL_OW 248
60947: PPUSH
60948: LD_INT 0
60950: PPUSH
60951: CALL 62355 0 6
60955: ST_TO_ADDR
// if not hexes then
60956: LD_VAR 0 12
60960: NOT
60961: IFFALSE 60965
// exit ;
60963: GO 61518
// for i = 1 to hexes do
60965: LD_ADDR_VAR 0 7
60969: PUSH
60970: DOUBLE
60971: LD_INT 1
60973: DEC
60974: ST_TO_ADDR
60975: LD_VAR 0 12
60979: PUSH
60980: FOR_TO
60981: IFFALSE 61516
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60983: LD_ADDR_VAR 0 11
60987: PUSH
60988: LD_VAR 0 12
60992: PUSH
60993: LD_VAR 0 7
60997: ARRAY
60998: PUSH
60999: LD_INT 1
61001: ARRAY
61002: PPUSH
61003: LD_VAR 0 12
61007: PUSH
61008: LD_VAR 0 7
61012: ARRAY
61013: PUSH
61014: LD_INT 2
61016: ARRAY
61017: PPUSH
61018: CALL_OW 428
61022: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61023: LD_VAR 0 12
61027: PUSH
61028: LD_VAR 0 7
61032: ARRAY
61033: PUSH
61034: LD_INT 1
61036: ARRAY
61037: PPUSH
61038: LD_VAR 0 12
61042: PUSH
61043: LD_VAR 0 7
61047: ARRAY
61048: PUSH
61049: LD_INT 2
61051: ARRAY
61052: PPUSH
61053: CALL_OW 351
61057: PUSH
61058: LD_VAR 0 12
61062: PUSH
61063: LD_VAR 0 7
61067: ARRAY
61068: PUSH
61069: LD_INT 1
61071: ARRAY
61072: PPUSH
61073: LD_VAR 0 12
61077: PUSH
61078: LD_VAR 0 7
61082: ARRAY
61083: PUSH
61084: LD_INT 2
61086: ARRAY
61087: PPUSH
61088: CALL_OW 488
61092: NOT
61093: OR
61094: PUSH
61095: LD_VAR 0 11
61099: PPUSH
61100: CALL_OW 247
61104: PUSH
61105: LD_INT 3
61107: EQUAL
61108: OR
61109: IFFALSE 61115
// exit ;
61111: POP
61112: POP
61113: GO 61518
// if not tmp or not tmp in base then
61115: LD_VAR 0 11
61119: NOT
61120: PUSH
61121: LD_VAR 0 11
61125: PUSH
61126: LD_VAR 0 1
61130: IN
61131: NOT
61132: OR
61133: IFFALSE 61137
// continue ;
61135: GO 60980
// result := true ;
61137: LD_ADDR_VAR 0 6
61141: PUSH
61142: LD_INT 1
61144: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61145: LD_ADDR_VAR 0 15
61149: PUSH
61150: LD_VAR 0 1
61154: PPUSH
61155: LD_INT 22
61157: PUSH
61158: LD_VAR 0 11
61162: PPUSH
61163: CALL_OW 255
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: PUSH
61172: LD_INT 2
61174: PUSH
61175: LD_INT 30
61177: PUSH
61178: LD_INT 0
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PUSH
61185: LD_INT 30
61187: PUSH
61188: LD_INT 1
61190: PUSH
61191: EMPTY
61192: LIST
61193: LIST
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: LIST
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PPUSH
61204: CALL_OW 72
61208: ST_TO_ADDR
// if dep then
61209: LD_VAR 0 15
61213: IFFALSE 61349
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61215: LD_ADDR_VAR 0 14
61219: PUSH
61220: LD_VAR 0 15
61224: PUSH
61225: LD_INT 1
61227: ARRAY
61228: PPUSH
61229: CALL_OW 250
61233: PPUSH
61234: LD_VAR 0 15
61238: PUSH
61239: LD_INT 1
61241: ARRAY
61242: PPUSH
61243: CALL_OW 254
61247: PPUSH
61248: LD_INT 5
61250: PPUSH
61251: CALL_OW 272
61255: PUSH
61256: LD_VAR 0 15
61260: PUSH
61261: LD_INT 1
61263: ARRAY
61264: PPUSH
61265: CALL_OW 251
61269: PPUSH
61270: LD_VAR 0 15
61274: PUSH
61275: LD_INT 1
61277: ARRAY
61278: PPUSH
61279: CALL_OW 254
61283: PPUSH
61284: LD_INT 5
61286: PPUSH
61287: CALL_OW 273
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61296: LD_VAR 0 14
61300: PUSH
61301: LD_INT 1
61303: ARRAY
61304: PPUSH
61305: LD_VAR 0 14
61309: PUSH
61310: LD_INT 2
61312: ARRAY
61313: PPUSH
61314: CALL_OW 488
61318: IFFALSE 61349
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61320: LD_VAR 0 11
61324: PPUSH
61325: LD_VAR 0 14
61329: PUSH
61330: LD_INT 1
61332: ARRAY
61333: PPUSH
61334: LD_VAR 0 14
61338: PUSH
61339: LD_INT 2
61341: ARRAY
61342: PPUSH
61343: CALL_OW 111
// continue ;
61347: GO 60980
// end ; end ; r := GetDir ( tmp ) ;
61349: LD_ADDR_VAR 0 13
61353: PUSH
61354: LD_VAR 0 11
61358: PPUSH
61359: CALL_OW 254
61363: ST_TO_ADDR
// if r = 5 then
61364: LD_VAR 0 13
61368: PUSH
61369: LD_INT 5
61371: EQUAL
61372: IFFALSE 61382
// r := 0 ;
61374: LD_ADDR_VAR 0 13
61378: PUSH
61379: LD_INT 0
61381: ST_TO_ADDR
// for j = r to 5 do
61382: LD_ADDR_VAR 0 8
61386: PUSH
61387: DOUBLE
61388: LD_VAR 0 13
61392: DEC
61393: ST_TO_ADDR
61394: LD_INT 5
61396: PUSH
61397: FOR_TO
61398: IFFALSE 61512
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61400: LD_ADDR_VAR 0 9
61404: PUSH
61405: LD_VAR 0 11
61409: PPUSH
61410: CALL_OW 250
61414: PPUSH
61415: LD_VAR 0 8
61419: PPUSH
61420: LD_INT 2
61422: PPUSH
61423: CALL_OW 272
61427: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61428: LD_ADDR_VAR 0 10
61432: PUSH
61433: LD_VAR 0 11
61437: PPUSH
61438: CALL_OW 251
61442: PPUSH
61443: LD_VAR 0 8
61447: PPUSH
61448: LD_INT 2
61450: PPUSH
61451: CALL_OW 273
61455: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61456: LD_VAR 0 9
61460: PPUSH
61461: LD_VAR 0 10
61465: PPUSH
61466: CALL_OW 488
61470: PUSH
61471: LD_VAR 0 9
61475: PPUSH
61476: LD_VAR 0 10
61480: PPUSH
61481: CALL_OW 428
61485: NOT
61486: AND
61487: IFFALSE 61510
// begin ComMoveXY ( tmp , _x , _y ) ;
61489: LD_VAR 0 11
61493: PPUSH
61494: LD_VAR 0 9
61498: PPUSH
61499: LD_VAR 0 10
61503: PPUSH
61504: CALL_OW 111
// break ;
61508: GO 61512
// end ; end ;
61510: GO 61397
61512: POP
61513: POP
// end ;
61514: GO 60980
61516: POP
61517: POP
// end ;
61518: LD_VAR 0 6
61522: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61523: LD_INT 0
61525: PPUSH
61526: PPUSH
61527: PPUSH
61528: PPUSH
61529: PPUSH
61530: PPUSH
61531: PPUSH
61532: PPUSH
61533: PPUSH
61534: PPUSH
// result := false ;
61535: LD_ADDR_VAR 0 6
61539: PUSH
61540: LD_INT 0
61542: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61543: LD_VAR 0 1
61547: NOT
61548: PUSH
61549: LD_VAR 0 1
61553: PPUSH
61554: CALL_OW 266
61558: PUSH
61559: LD_INT 0
61561: PUSH
61562: LD_INT 1
61564: PUSH
61565: EMPTY
61566: LIST
61567: LIST
61568: IN
61569: NOT
61570: OR
61571: PUSH
61572: LD_VAR 0 2
61576: NOT
61577: OR
61578: PUSH
61579: LD_VAR 0 5
61583: PUSH
61584: LD_INT 0
61586: PUSH
61587: LD_INT 1
61589: PUSH
61590: LD_INT 2
61592: PUSH
61593: LD_INT 3
61595: PUSH
61596: LD_INT 4
61598: PUSH
61599: LD_INT 5
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: LIST
61606: LIST
61607: LIST
61608: LIST
61609: IN
61610: NOT
61611: OR
61612: PUSH
61613: LD_VAR 0 3
61617: PPUSH
61618: LD_VAR 0 4
61622: PPUSH
61623: CALL_OW 488
61627: NOT
61628: OR
61629: IFFALSE 61633
// exit ;
61631: GO 62350
// pom := GetBase ( depot ) ;
61633: LD_ADDR_VAR 0 10
61637: PUSH
61638: LD_VAR 0 1
61642: PPUSH
61643: CALL_OW 274
61647: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61648: LD_ADDR_VAR 0 11
61652: PUSH
61653: LD_VAR 0 2
61657: PPUSH
61658: LD_VAR 0 1
61662: PPUSH
61663: CALL_OW 248
61667: PPUSH
61668: CALL_OW 450
61672: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61673: LD_VAR 0 10
61677: PPUSH
61678: LD_INT 1
61680: PPUSH
61681: CALL_OW 275
61685: PUSH
61686: LD_VAR 0 11
61690: PUSH
61691: LD_INT 1
61693: ARRAY
61694: GREATEREQUAL
61695: PUSH
61696: LD_VAR 0 10
61700: PPUSH
61701: LD_INT 2
61703: PPUSH
61704: CALL_OW 275
61708: PUSH
61709: LD_VAR 0 11
61713: PUSH
61714: LD_INT 2
61716: ARRAY
61717: GREATEREQUAL
61718: AND
61719: PUSH
61720: LD_VAR 0 10
61724: PPUSH
61725: LD_INT 3
61727: PPUSH
61728: CALL_OW 275
61732: PUSH
61733: LD_VAR 0 11
61737: PUSH
61738: LD_INT 3
61740: ARRAY
61741: GREATEREQUAL
61742: AND
61743: NOT
61744: IFFALSE 61748
// exit ;
61746: GO 62350
// if GetBType ( depot ) = b_depot then
61748: LD_VAR 0 1
61752: PPUSH
61753: CALL_OW 266
61757: PUSH
61758: LD_INT 0
61760: EQUAL
61761: IFFALSE 61773
// dist := 28 else
61763: LD_ADDR_VAR 0 14
61767: PUSH
61768: LD_INT 28
61770: ST_TO_ADDR
61771: GO 61781
// dist := 36 ;
61773: LD_ADDR_VAR 0 14
61777: PUSH
61778: LD_INT 36
61780: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61781: LD_VAR 0 1
61785: PPUSH
61786: LD_VAR 0 3
61790: PPUSH
61791: LD_VAR 0 4
61795: PPUSH
61796: CALL_OW 297
61800: PUSH
61801: LD_VAR 0 14
61805: GREATER
61806: IFFALSE 61810
// exit ;
61808: GO 62350
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61810: LD_ADDR_VAR 0 12
61814: PUSH
61815: LD_VAR 0 2
61819: PPUSH
61820: LD_VAR 0 3
61824: PPUSH
61825: LD_VAR 0 4
61829: PPUSH
61830: LD_VAR 0 5
61834: PPUSH
61835: LD_VAR 0 1
61839: PPUSH
61840: CALL_OW 248
61844: PPUSH
61845: LD_INT 0
61847: PPUSH
61848: CALL 62355 0 6
61852: ST_TO_ADDR
// if not hexes then
61853: LD_VAR 0 12
61857: NOT
61858: IFFALSE 61862
// exit ;
61860: GO 62350
// hex := GetHexInfo ( x , y ) ;
61862: LD_ADDR_VAR 0 15
61866: PUSH
61867: LD_VAR 0 3
61871: PPUSH
61872: LD_VAR 0 4
61876: PPUSH
61877: CALL_OW 546
61881: ST_TO_ADDR
// if hex [ 1 ] then
61882: LD_VAR 0 15
61886: PUSH
61887: LD_INT 1
61889: ARRAY
61890: IFFALSE 61894
// exit ;
61892: GO 62350
// height := hex [ 2 ] ;
61894: LD_ADDR_VAR 0 13
61898: PUSH
61899: LD_VAR 0 15
61903: PUSH
61904: LD_INT 2
61906: ARRAY
61907: ST_TO_ADDR
// for i = 1 to hexes do
61908: LD_ADDR_VAR 0 7
61912: PUSH
61913: DOUBLE
61914: LD_INT 1
61916: DEC
61917: ST_TO_ADDR
61918: LD_VAR 0 12
61922: PUSH
61923: FOR_TO
61924: IFFALSE 62254
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61926: LD_VAR 0 12
61930: PUSH
61931: LD_VAR 0 7
61935: ARRAY
61936: PUSH
61937: LD_INT 1
61939: ARRAY
61940: PPUSH
61941: LD_VAR 0 12
61945: PUSH
61946: LD_VAR 0 7
61950: ARRAY
61951: PUSH
61952: LD_INT 2
61954: ARRAY
61955: PPUSH
61956: CALL_OW 488
61960: NOT
61961: PUSH
61962: LD_VAR 0 12
61966: PUSH
61967: LD_VAR 0 7
61971: ARRAY
61972: PUSH
61973: LD_INT 1
61975: ARRAY
61976: PPUSH
61977: LD_VAR 0 12
61981: PUSH
61982: LD_VAR 0 7
61986: ARRAY
61987: PUSH
61988: LD_INT 2
61990: ARRAY
61991: PPUSH
61992: CALL_OW 428
61996: PUSH
61997: LD_INT 0
61999: GREATER
62000: OR
62001: PUSH
62002: LD_VAR 0 12
62006: PUSH
62007: LD_VAR 0 7
62011: ARRAY
62012: PUSH
62013: LD_INT 1
62015: ARRAY
62016: PPUSH
62017: LD_VAR 0 12
62021: PUSH
62022: LD_VAR 0 7
62026: ARRAY
62027: PUSH
62028: LD_INT 2
62030: ARRAY
62031: PPUSH
62032: CALL_OW 351
62036: OR
62037: IFFALSE 62043
// exit ;
62039: POP
62040: POP
62041: GO 62350
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62043: LD_ADDR_VAR 0 8
62047: PUSH
62048: LD_VAR 0 12
62052: PUSH
62053: LD_VAR 0 7
62057: ARRAY
62058: PUSH
62059: LD_INT 1
62061: ARRAY
62062: PPUSH
62063: LD_VAR 0 12
62067: PUSH
62068: LD_VAR 0 7
62072: ARRAY
62073: PUSH
62074: LD_INT 2
62076: ARRAY
62077: PPUSH
62078: CALL_OW 546
62082: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62083: LD_VAR 0 8
62087: PUSH
62088: LD_INT 1
62090: ARRAY
62091: PUSH
62092: LD_VAR 0 8
62096: PUSH
62097: LD_INT 2
62099: ARRAY
62100: PUSH
62101: LD_VAR 0 13
62105: PUSH
62106: LD_INT 2
62108: PLUS
62109: GREATER
62110: OR
62111: PUSH
62112: LD_VAR 0 8
62116: PUSH
62117: LD_INT 2
62119: ARRAY
62120: PUSH
62121: LD_VAR 0 13
62125: PUSH
62126: LD_INT 2
62128: MINUS
62129: LESS
62130: OR
62131: PUSH
62132: LD_VAR 0 8
62136: PUSH
62137: LD_INT 3
62139: ARRAY
62140: PUSH
62141: LD_INT 0
62143: PUSH
62144: LD_INT 8
62146: PUSH
62147: LD_INT 9
62149: PUSH
62150: LD_INT 10
62152: PUSH
62153: LD_INT 11
62155: PUSH
62156: LD_INT 12
62158: PUSH
62159: LD_INT 13
62161: PUSH
62162: LD_INT 16
62164: PUSH
62165: LD_INT 17
62167: PUSH
62168: LD_INT 18
62170: PUSH
62171: LD_INT 19
62173: PUSH
62174: LD_INT 20
62176: PUSH
62177: LD_INT 21
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: LIST
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: LIST
62192: LIST
62193: LIST
62194: IN
62195: NOT
62196: OR
62197: PUSH
62198: LD_VAR 0 8
62202: PUSH
62203: LD_INT 5
62205: ARRAY
62206: NOT
62207: OR
62208: PUSH
62209: LD_VAR 0 8
62213: PUSH
62214: LD_INT 6
62216: ARRAY
62217: PUSH
62218: LD_INT 1
62220: PUSH
62221: LD_INT 2
62223: PUSH
62224: LD_INT 7
62226: PUSH
62227: LD_INT 9
62229: PUSH
62230: LD_INT 10
62232: PUSH
62233: LD_INT 11
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: LIST
62240: LIST
62241: LIST
62242: LIST
62243: IN
62244: NOT
62245: OR
62246: IFFALSE 62252
// exit ;
62248: POP
62249: POP
62250: GO 62350
// end ;
62252: GO 61923
62254: POP
62255: POP
// side := GetSide ( depot ) ;
62256: LD_ADDR_VAR 0 9
62260: PUSH
62261: LD_VAR 0 1
62265: PPUSH
62266: CALL_OW 255
62270: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62271: LD_VAR 0 9
62275: PPUSH
62276: LD_VAR 0 3
62280: PPUSH
62281: LD_VAR 0 4
62285: PPUSH
62286: LD_INT 20
62288: PPUSH
62289: CALL 55004 0 4
62293: PUSH
62294: LD_INT 4
62296: ARRAY
62297: IFFALSE 62301
// exit ;
62299: GO 62350
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62301: LD_VAR 0 2
62305: PUSH
62306: LD_INT 29
62308: PUSH
62309: LD_INT 30
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: IN
62316: PUSH
62317: LD_VAR 0 3
62321: PPUSH
62322: LD_VAR 0 4
62326: PPUSH
62327: LD_VAR 0 9
62331: PPUSH
62332: CALL_OW 440
62336: NOT
62337: AND
62338: IFFALSE 62342
// exit ;
62340: GO 62350
// result := true ;
62342: LD_ADDR_VAR 0 6
62346: PUSH
62347: LD_INT 1
62349: ST_TO_ADDR
// end ;
62350: LD_VAR 0 6
62354: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62355: LD_INT 0
62357: PPUSH
62358: PPUSH
62359: PPUSH
62360: PPUSH
62361: PPUSH
62362: PPUSH
62363: PPUSH
62364: PPUSH
62365: PPUSH
62366: PPUSH
62367: PPUSH
62368: PPUSH
62369: PPUSH
62370: PPUSH
62371: PPUSH
62372: PPUSH
62373: PPUSH
62374: PPUSH
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
62383: PPUSH
62384: PPUSH
62385: PPUSH
62386: PPUSH
62387: PPUSH
62388: PPUSH
62389: PPUSH
62390: PPUSH
62391: PPUSH
62392: PPUSH
62393: PPUSH
62394: PPUSH
62395: PPUSH
62396: PPUSH
62397: PPUSH
62398: PPUSH
62399: PPUSH
62400: PPUSH
62401: PPUSH
62402: PPUSH
62403: PPUSH
62404: PPUSH
62405: PPUSH
62406: PPUSH
62407: PPUSH
62408: PPUSH
62409: PPUSH
62410: PPUSH
62411: PPUSH
62412: PPUSH
62413: PPUSH
62414: PPUSH
// result = [ ] ;
62415: LD_ADDR_VAR 0 7
62419: PUSH
62420: EMPTY
62421: ST_TO_ADDR
// temp_list = [ ] ;
62422: LD_ADDR_VAR 0 9
62426: PUSH
62427: EMPTY
62428: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62429: LD_VAR 0 4
62433: PUSH
62434: LD_INT 0
62436: PUSH
62437: LD_INT 1
62439: PUSH
62440: LD_INT 2
62442: PUSH
62443: LD_INT 3
62445: PUSH
62446: LD_INT 4
62448: PUSH
62449: LD_INT 5
62451: PUSH
62452: EMPTY
62453: LIST
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: LIST
62459: IN
62460: NOT
62461: PUSH
62462: LD_VAR 0 1
62466: PUSH
62467: LD_INT 0
62469: PUSH
62470: LD_INT 1
62472: PUSH
62473: EMPTY
62474: LIST
62475: LIST
62476: IN
62477: PUSH
62478: LD_VAR 0 5
62482: PUSH
62483: LD_INT 1
62485: PUSH
62486: LD_INT 2
62488: PUSH
62489: LD_INT 3
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: LIST
62496: IN
62497: NOT
62498: AND
62499: OR
62500: IFFALSE 62504
// exit ;
62502: GO 80895
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62504: LD_VAR 0 1
62508: PUSH
62509: LD_INT 6
62511: PUSH
62512: LD_INT 7
62514: PUSH
62515: LD_INT 8
62517: PUSH
62518: LD_INT 13
62520: PUSH
62521: LD_INT 12
62523: PUSH
62524: LD_INT 15
62526: PUSH
62527: LD_INT 11
62529: PUSH
62530: LD_INT 14
62532: PUSH
62533: LD_INT 10
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: LIST
62546: IN
62547: IFFALSE 62557
// btype = b_lab ;
62549: LD_ADDR_VAR 0 1
62553: PUSH
62554: LD_INT 6
62556: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62557: LD_VAR 0 6
62561: PUSH
62562: LD_INT 0
62564: PUSH
62565: LD_INT 1
62567: PUSH
62568: LD_INT 2
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: LIST
62575: IN
62576: NOT
62577: PUSH
62578: LD_VAR 0 1
62582: PUSH
62583: LD_INT 0
62585: PUSH
62586: LD_INT 1
62588: PUSH
62589: LD_INT 2
62591: PUSH
62592: LD_INT 3
62594: PUSH
62595: LD_INT 6
62597: PUSH
62598: LD_INT 36
62600: PUSH
62601: LD_INT 4
62603: PUSH
62604: LD_INT 5
62606: PUSH
62607: LD_INT 31
62609: PUSH
62610: LD_INT 32
62612: PUSH
62613: LD_INT 33
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: LIST
62620: LIST
62621: LIST
62622: LIST
62623: LIST
62624: LIST
62625: LIST
62626: LIST
62627: LIST
62628: IN
62629: NOT
62630: PUSH
62631: LD_VAR 0 6
62635: PUSH
62636: LD_INT 1
62638: EQUAL
62639: AND
62640: OR
62641: PUSH
62642: LD_VAR 0 1
62646: PUSH
62647: LD_INT 2
62649: PUSH
62650: LD_INT 3
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: IN
62657: NOT
62658: PUSH
62659: LD_VAR 0 6
62663: PUSH
62664: LD_INT 2
62666: EQUAL
62667: AND
62668: OR
62669: IFFALSE 62679
// mode = 0 ;
62671: LD_ADDR_VAR 0 6
62675: PUSH
62676: LD_INT 0
62678: ST_TO_ADDR
// case mode of 0 :
62679: LD_VAR 0 6
62683: PUSH
62684: LD_INT 0
62686: DOUBLE
62687: EQUAL
62688: IFTRUE 62692
62690: GO 74145
62692: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62693: LD_ADDR_VAR 0 11
62697: PUSH
62698: LD_INT 0
62700: PUSH
62701: LD_INT 0
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 0
62710: PUSH
62711: LD_INT 1
62713: NEG
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 1
62721: PUSH
62722: LD_INT 0
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 1
62731: PUSH
62732: LD_INT 1
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: LD_INT 0
62741: PUSH
62742: LD_INT 1
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: PUSH
62749: LD_INT 1
62751: NEG
62752: PUSH
62753: LD_INT 0
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: PUSH
62760: LD_INT 1
62762: NEG
62763: PUSH
62764: LD_INT 1
62766: NEG
62767: PUSH
62768: EMPTY
62769: LIST
62770: LIST
62771: PUSH
62772: LD_INT 1
62774: NEG
62775: PUSH
62776: LD_INT 2
62778: NEG
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PUSH
62784: LD_INT 0
62786: PUSH
62787: LD_INT 2
62789: NEG
62790: PUSH
62791: EMPTY
62792: LIST
62793: LIST
62794: PUSH
62795: LD_INT 1
62797: PUSH
62798: LD_INT 1
62800: NEG
62801: PUSH
62802: EMPTY
62803: LIST
62804: LIST
62805: PUSH
62806: LD_INT 1
62808: PUSH
62809: LD_INT 2
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: LD_INT 0
62818: PUSH
62819: LD_INT 2
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: LD_INT 1
62828: NEG
62829: PUSH
62830: LD_INT 1
62832: PUSH
62833: EMPTY
62834: LIST
62835: LIST
62836: PUSH
62837: LD_INT 1
62839: PUSH
62840: LD_INT 3
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: PUSH
62847: LD_INT 0
62849: PUSH
62850: LD_INT 3
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: PUSH
62857: LD_INT 1
62859: NEG
62860: PUSH
62861: LD_INT 2
62863: PUSH
62864: EMPTY
62865: LIST
62866: LIST
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: LIST
62872: LIST
62873: LIST
62874: LIST
62875: LIST
62876: LIST
62877: LIST
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62886: LD_ADDR_VAR 0 12
62890: PUSH
62891: LD_INT 0
62893: PUSH
62894: LD_INT 0
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 0
62903: PUSH
62904: LD_INT 1
62906: NEG
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 1
62914: PUSH
62915: LD_INT 0
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: PUSH
62922: LD_INT 1
62924: PUSH
62925: LD_INT 1
62927: PUSH
62928: EMPTY
62929: LIST
62930: LIST
62931: PUSH
62932: LD_INT 0
62934: PUSH
62935: LD_INT 1
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: PUSH
62942: LD_INT 1
62944: NEG
62945: PUSH
62946: LD_INT 0
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: PUSH
62953: LD_INT 1
62955: NEG
62956: PUSH
62957: LD_INT 1
62959: NEG
62960: PUSH
62961: EMPTY
62962: LIST
62963: LIST
62964: PUSH
62965: LD_INT 1
62967: PUSH
62968: LD_INT 1
62970: NEG
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 2
62978: PUSH
62979: LD_INT 0
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: LD_INT 2
62988: PUSH
62989: LD_INT 1
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: PUSH
62996: LD_INT 1
62998: NEG
62999: PUSH
63000: LD_INT 1
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: LD_INT 2
63009: NEG
63010: PUSH
63011: LD_INT 0
63013: PUSH
63014: EMPTY
63015: LIST
63016: LIST
63017: PUSH
63018: LD_INT 2
63020: NEG
63021: PUSH
63022: LD_INT 1
63024: NEG
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: PUSH
63030: LD_INT 2
63032: NEG
63033: PUSH
63034: LD_INT 1
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 3
63043: NEG
63044: PUSH
63045: LD_INT 0
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PUSH
63052: LD_INT 3
63054: NEG
63055: PUSH
63056: LD_INT 1
63058: NEG
63059: PUSH
63060: EMPTY
63061: LIST
63062: LIST
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: LIST
63076: LIST
63077: LIST
63078: LIST
63079: LIST
63080: LIST
63081: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63082: LD_ADDR_VAR 0 13
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: LD_INT 0
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 0
63099: PUSH
63100: LD_INT 1
63102: NEG
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: LD_INT 0
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 1
63120: PUSH
63121: LD_INT 1
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 0
63130: PUSH
63131: LD_INT 1
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 1
63140: NEG
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 1
63151: NEG
63152: PUSH
63153: LD_INT 1
63155: NEG
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 1
63163: NEG
63164: PUSH
63165: LD_INT 2
63167: NEG
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 2
63175: PUSH
63176: LD_INT 1
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 2
63185: PUSH
63186: LD_INT 2
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 1
63195: PUSH
63196: LD_INT 2
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 2
63205: NEG
63206: PUSH
63207: LD_INT 1
63209: NEG
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 2
63217: NEG
63218: PUSH
63219: LD_INT 2
63221: NEG
63222: PUSH
63223: EMPTY
63224: LIST
63225: LIST
63226: PUSH
63227: LD_INT 2
63229: NEG
63230: PUSH
63231: LD_INT 3
63233: NEG
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 3
63241: NEG
63242: PUSH
63243: LD_INT 2
63245: NEG
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: LD_INT 3
63253: NEG
63254: PUSH
63255: LD_INT 3
63257: NEG
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: LIST
63275: LIST
63276: LIST
63277: LIST
63278: LIST
63279: LIST
63280: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63281: LD_ADDR_VAR 0 14
63285: PUSH
63286: LD_INT 0
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 0
63298: PUSH
63299: LD_INT 1
63301: NEG
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: PUSH
63307: LD_INT 1
63309: PUSH
63310: LD_INT 0
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PUSH
63317: LD_INT 1
63319: PUSH
63320: LD_INT 1
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 0
63329: PUSH
63330: LD_INT 1
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 1
63339: NEG
63340: PUSH
63341: LD_INT 0
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 1
63350: NEG
63351: PUSH
63352: LD_INT 1
63354: NEG
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: PUSH
63360: LD_INT 1
63362: NEG
63363: PUSH
63364: LD_INT 2
63366: NEG
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PUSH
63372: LD_INT 0
63374: PUSH
63375: LD_INT 2
63377: NEG
63378: PUSH
63379: EMPTY
63380: LIST
63381: LIST
63382: PUSH
63383: LD_INT 1
63385: PUSH
63386: LD_INT 1
63388: NEG
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: PUSH
63394: LD_INT 1
63396: PUSH
63397: LD_INT 2
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: LD_INT 0
63406: PUSH
63407: LD_INT 2
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: PUSH
63414: LD_INT 1
63416: NEG
63417: PUSH
63418: LD_INT 1
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 1
63427: NEG
63428: PUSH
63429: LD_INT 3
63431: NEG
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 0
63439: PUSH
63440: LD_INT 3
63442: NEG
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: LD_INT 2
63453: NEG
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PUSH
63459: EMPTY
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63477: LD_ADDR_VAR 0 15
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: LD_INT 0
63487: PUSH
63488: EMPTY
63489: LIST
63490: LIST
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: LD_INT 1
63497: NEG
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 1
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 1
63515: PUSH
63516: LD_INT 1
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 0
63525: PUSH
63526: LD_INT 1
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: NEG
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 1
63546: NEG
63547: PUSH
63548: LD_INT 1
63550: NEG
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 1
63558: PUSH
63559: LD_INT 1
63561: NEG
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 2
63569: PUSH
63570: LD_INT 0
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 2
63579: PUSH
63580: LD_INT 1
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 1
63589: NEG
63590: PUSH
63591: LD_INT 1
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: LD_INT 0
63604: PUSH
63605: EMPTY
63606: LIST
63607: LIST
63608: PUSH
63609: LD_INT 2
63611: NEG
63612: PUSH
63613: LD_INT 1
63615: NEG
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: PUSH
63621: LD_INT 2
63623: PUSH
63624: LD_INT 1
63626: NEG
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 3
63634: PUSH
63635: LD_INT 0
63637: PUSH
63638: EMPTY
63639: LIST
63640: LIST
63641: PUSH
63642: LD_INT 3
63644: PUSH
63645: LD_INT 1
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PUSH
63652: EMPTY
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63670: LD_ADDR_VAR 0 16
63674: PUSH
63675: LD_INT 0
63677: PUSH
63678: LD_INT 0
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PUSH
63685: LD_INT 0
63687: PUSH
63688: LD_INT 1
63690: NEG
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: PUSH
63696: LD_INT 1
63698: PUSH
63699: LD_INT 0
63701: PUSH
63702: EMPTY
63703: LIST
63704: LIST
63705: PUSH
63706: LD_INT 1
63708: PUSH
63709: LD_INT 1
63711: PUSH
63712: EMPTY
63713: LIST
63714: LIST
63715: PUSH
63716: LD_INT 0
63718: PUSH
63719: LD_INT 1
63721: PUSH
63722: EMPTY
63723: LIST
63724: LIST
63725: PUSH
63726: LD_INT 1
63728: NEG
63729: PUSH
63730: LD_INT 0
63732: PUSH
63733: EMPTY
63734: LIST
63735: LIST
63736: PUSH
63737: LD_INT 1
63739: NEG
63740: PUSH
63741: LD_INT 1
63743: NEG
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: PUSH
63749: LD_INT 1
63751: NEG
63752: PUSH
63753: LD_INT 2
63755: NEG
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: PUSH
63761: LD_INT 2
63763: PUSH
63764: LD_INT 1
63766: PUSH
63767: EMPTY
63768: LIST
63769: LIST
63770: PUSH
63771: LD_INT 2
63773: PUSH
63774: LD_INT 2
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: PUSH
63781: LD_INT 1
63783: PUSH
63784: LD_INT 2
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: LD_INT 2
63793: NEG
63794: PUSH
63795: LD_INT 1
63797: NEG
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PUSH
63803: LD_INT 2
63805: NEG
63806: PUSH
63807: LD_INT 2
63809: NEG
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: PUSH
63815: LD_INT 3
63817: PUSH
63818: LD_INT 2
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: PUSH
63825: LD_INT 3
63827: PUSH
63828: LD_INT 3
63830: PUSH
63831: EMPTY
63832: LIST
63833: LIST
63834: PUSH
63835: LD_INT 2
63837: PUSH
63838: LD_INT 3
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63863: LD_ADDR_VAR 0 17
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 0
63880: PUSH
63881: LD_INT 1
63883: NEG
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: LD_INT 1
63891: PUSH
63892: LD_INT 0
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: LD_INT 1
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 0
63911: PUSH
63912: LD_INT 1
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 1
63921: NEG
63922: PUSH
63923: LD_INT 0
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: LD_INT 1
63932: NEG
63933: PUSH
63934: LD_INT 1
63936: NEG
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: LD_INT 2
63948: NEG
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 0
63956: PUSH
63957: LD_INT 2
63959: NEG
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: PUSH
63965: LD_INT 1
63967: PUSH
63968: LD_INT 1
63970: NEG
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: PUSH
63976: LD_INT 2
63978: PUSH
63979: LD_INT 0
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 2
63988: PUSH
63989: LD_INT 1
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: PUSH
63996: LD_INT 2
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 1
64008: PUSH
64009: LD_INT 2
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 0
64018: PUSH
64019: LD_INT 2
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PUSH
64026: LD_INT 1
64028: NEG
64029: PUSH
64030: LD_INT 1
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 2
64039: NEG
64040: PUSH
64041: LD_INT 0
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: PUSH
64048: LD_INT 2
64050: NEG
64051: PUSH
64052: LD_INT 1
64054: NEG
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 2
64062: NEG
64063: PUSH
64064: LD_INT 2
64066: NEG
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64093: LD_ADDR_VAR 0 18
64097: PUSH
64098: LD_INT 0
64100: PUSH
64101: LD_INT 0
64103: PUSH
64104: EMPTY
64105: LIST
64106: LIST
64107: PUSH
64108: LD_INT 0
64110: PUSH
64111: LD_INT 1
64113: NEG
64114: PUSH
64115: EMPTY
64116: LIST
64117: LIST
64118: PUSH
64119: LD_INT 1
64121: PUSH
64122: LD_INT 0
64124: PUSH
64125: EMPTY
64126: LIST
64127: LIST
64128: PUSH
64129: LD_INT 1
64131: PUSH
64132: LD_INT 1
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: PUSH
64139: LD_INT 0
64141: PUSH
64142: LD_INT 1
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: LD_INT 1
64151: NEG
64152: PUSH
64153: LD_INT 0
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 1
64162: NEG
64163: PUSH
64164: LD_INT 1
64166: NEG
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PUSH
64172: LD_INT 1
64174: NEG
64175: PUSH
64176: LD_INT 2
64178: NEG
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 0
64186: PUSH
64187: LD_INT 2
64189: NEG
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PUSH
64195: LD_INT 1
64197: PUSH
64198: LD_INT 1
64200: NEG
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: PUSH
64206: LD_INT 2
64208: PUSH
64209: LD_INT 0
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PUSH
64216: LD_INT 2
64218: PUSH
64219: LD_INT 1
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 2
64228: PUSH
64229: LD_INT 2
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 1
64238: PUSH
64239: LD_INT 2
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 0
64248: PUSH
64249: LD_INT 2
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: LD_INT 1
64258: NEG
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 2
64269: NEG
64270: PUSH
64271: LD_INT 0
64273: PUSH
64274: EMPTY
64275: LIST
64276: LIST
64277: PUSH
64278: LD_INT 2
64280: NEG
64281: PUSH
64282: LD_INT 1
64284: NEG
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: LD_INT 2
64292: NEG
64293: PUSH
64294: LD_INT 2
64296: NEG
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: EMPTY
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64323: LD_ADDR_VAR 0 19
64327: PUSH
64328: LD_INT 0
64330: PUSH
64331: LD_INT 0
64333: PUSH
64334: EMPTY
64335: LIST
64336: LIST
64337: PUSH
64338: LD_INT 0
64340: PUSH
64341: LD_INT 1
64343: NEG
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: LD_INT 1
64351: PUSH
64352: LD_INT 0
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: LD_INT 1
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 0
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 1
64381: NEG
64382: PUSH
64383: LD_INT 0
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 1
64392: NEG
64393: PUSH
64394: LD_INT 1
64396: NEG
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: PUSH
64402: LD_INT 1
64404: NEG
64405: PUSH
64406: LD_INT 2
64408: NEG
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: PUSH
64414: LD_INT 0
64416: PUSH
64417: LD_INT 2
64419: NEG
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 1
64427: PUSH
64428: LD_INT 1
64430: NEG
64431: PUSH
64432: EMPTY
64433: LIST
64434: LIST
64435: PUSH
64436: LD_INT 2
64438: PUSH
64439: LD_INT 0
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: PUSH
64446: LD_INT 2
64448: PUSH
64449: LD_INT 1
64451: PUSH
64452: EMPTY
64453: LIST
64454: LIST
64455: PUSH
64456: LD_INT 2
64458: PUSH
64459: LD_INT 2
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: LD_INT 2
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 0
64478: PUSH
64479: LD_INT 2
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 1
64488: NEG
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 2
64499: NEG
64500: PUSH
64501: LD_INT 0
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 2
64510: NEG
64511: PUSH
64512: LD_INT 1
64514: NEG
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 2
64522: NEG
64523: PUSH
64524: LD_INT 2
64526: NEG
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64553: LD_ADDR_VAR 0 20
64557: PUSH
64558: LD_INT 0
64560: PUSH
64561: LD_INT 0
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: LD_INT 1
64573: NEG
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 1
64581: PUSH
64582: LD_INT 0
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: LD_INT 1
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 0
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 1
64611: NEG
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: LD_INT 1
64626: NEG
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 1
64634: NEG
64635: PUSH
64636: LD_INT 2
64638: NEG
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: LD_INT 2
64649: NEG
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: LD_INT 1
64660: NEG
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: LD_INT 2
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 2
64678: PUSH
64679: LD_INT 1
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: LD_INT 2
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 1
64698: PUSH
64699: LD_INT 2
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: LD_INT 2
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 1
64718: NEG
64719: PUSH
64720: LD_INT 1
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PUSH
64727: LD_INT 2
64729: NEG
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 2
64740: NEG
64741: PUSH
64742: LD_INT 1
64744: NEG
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 2
64752: NEG
64753: PUSH
64754: LD_INT 2
64756: NEG
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64783: LD_ADDR_VAR 0 21
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: LD_INT 0
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: LD_INT 0
64800: PUSH
64801: LD_INT 1
64803: NEG
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 1
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 0
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 1
64841: NEG
64842: PUSH
64843: LD_INT 0
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 1
64852: NEG
64853: PUSH
64854: LD_INT 1
64856: NEG
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 1
64864: NEG
64865: PUSH
64866: LD_INT 2
64868: NEG
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: LD_INT 2
64879: NEG
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: LD_INT 1
64890: NEG
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PUSH
64896: LD_INT 2
64898: PUSH
64899: LD_INT 0
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: LD_INT 1
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: LD_INT 2
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: LD_INT 1
64928: PUSH
64929: LD_INT 2
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 2
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 1
64948: NEG
64949: PUSH
64950: LD_INT 1
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 2
64959: NEG
64960: PUSH
64961: LD_INT 0
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 2
64970: NEG
64971: PUSH
64972: LD_INT 1
64974: NEG
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 2
64982: NEG
64983: PUSH
64984: LD_INT 2
64986: NEG
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65013: LD_ADDR_VAR 0 22
65017: PUSH
65018: LD_INT 0
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 0
65030: PUSH
65031: LD_INT 1
65033: NEG
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: LD_INT 0
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: LD_INT 1
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: LD_INT 1
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 1
65071: NEG
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 1
65094: NEG
65095: PUSH
65096: LD_INT 2
65098: NEG
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: LD_INT 2
65109: NEG
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: LD_INT 1
65120: NEG
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 2
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 2
65138: PUSH
65139: LD_INT 1
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: LD_INT 2
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: LD_INT 1
65158: PUSH
65159: LD_INT 2
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 2
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 1
65178: NEG
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 2
65189: NEG
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 2
65200: NEG
65201: PUSH
65202: LD_INT 1
65204: NEG
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 2
65212: NEG
65213: PUSH
65214: LD_INT 2
65216: NEG
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65243: LD_ADDR_VAR 0 23
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: LD_INT 0
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 0
65260: PUSH
65261: LD_INT 1
65263: NEG
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 0
65291: PUSH
65292: LD_INT 1
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 1
65301: NEG
65302: PUSH
65303: LD_INT 0
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 1
65312: NEG
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 1
65324: NEG
65325: PUSH
65326: LD_INT 2
65328: NEG
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 2
65339: NEG
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: LD_INT 1
65350: NEG
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 2
65358: PUSH
65359: LD_INT 0
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: PUSH
65369: LD_INT 1
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: LD_INT 2
65381: PUSH
65382: EMPTY
65383: LIST
65384: LIST
65385: PUSH
65386: LD_INT 1
65388: PUSH
65389: LD_INT 2
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 2
65401: PUSH
65402: EMPTY
65403: LIST
65404: LIST
65405: PUSH
65406: LD_INT 1
65408: NEG
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 2
65419: NEG
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: NEG
65431: PUSH
65432: LD_INT 1
65434: NEG
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 2
65442: NEG
65443: PUSH
65444: LD_INT 2
65446: NEG
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 2
65454: NEG
65455: PUSH
65456: LD_INT 3
65458: NEG
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 1
65466: NEG
65467: PUSH
65468: LD_INT 3
65470: NEG
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: PUSH
65476: LD_INT 1
65478: PUSH
65479: LD_INT 2
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 2
65489: PUSH
65490: LD_INT 1
65492: NEG
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65523: LD_ADDR_VAR 0 24
65527: PUSH
65528: LD_INT 0
65530: PUSH
65531: LD_INT 0
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 0
65540: PUSH
65541: LD_INT 1
65543: NEG
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 1
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 1
65561: PUSH
65562: LD_INT 1
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 0
65571: PUSH
65572: LD_INT 1
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PUSH
65579: LD_INT 1
65581: NEG
65582: PUSH
65583: LD_INT 0
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 1
65592: NEG
65593: PUSH
65594: LD_INT 1
65596: NEG
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 1
65604: NEG
65605: PUSH
65606: LD_INT 2
65608: NEG
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: LD_INT 0
65616: PUSH
65617: LD_INT 2
65619: NEG
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PUSH
65625: LD_INT 1
65627: PUSH
65628: LD_INT 1
65630: NEG
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 2
65638: PUSH
65639: LD_INT 0
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 2
65648: PUSH
65649: LD_INT 1
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 2
65658: PUSH
65659: LD_INT 2
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: PUSH
65666: LD_INT 1
65668: PUSH
65669: LD_INT 2
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 0
65678: PUSH
65679: LD_INT 2
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: LD_INT 1
65688: NEG
65689: PUSH
65690: LD_INT 1
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: PUSH
65697: LD_INT 2
65699: NEG
65700: PUSH
65701: LD_INT 0
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 2
65710: NEG
65711: PUSH
65712: LD_INT 1
65714: NEG
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 2
65722: NEG
65723: PUSH
65724: LD_INT 2
65726: NEG
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 1
65734: PUSH
65735: LD_INT 2
65737: NEG
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 2
65745: PUSH
65746: LD_INT 1
65748: NEG
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 3
65756: PUSH
65757: LD_INT 1
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 3
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65799: LD_ADDR_VAR 0 25
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 0
65816: PUSH
65817: LD_INT 1
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 1
65827: PUSH
65828: LD_INT 0
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: LD_INT 1
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 0
65847: PUSH
65848: LD_INT 1
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 1
65857: NEG
65858: PUSH
65859: LD_INT 0
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: LD_INT 1
65872: NEG
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 1
65880: NEG
65881: PUSH
65882: LD_INT 2
65884: NEG
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 2
65895: NEG
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: LD_INT 1
65906: NEG
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 2
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 2
65924: PUSH
65925: LD_INT 1
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 2
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 2
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: LD_INT 2
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 1
65964: NEG
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 2
65975: NEG
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 2
65986: NEG
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 2
65998: NEG
65999: PUSH
66000: LD_INT 2
66002: NEG
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 3
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 3
66020: PUSH
66021: LD_INT 2
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 2
66030: PUSH
66031: LD_INT 3
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 1
66040: PUSH
66041: LD_INT 3
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66073: LD_ADDR_VAR 0 26
66077: PUSH
66078: LD_INT 0
66080: PUSH
66081: LD_INT 0
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 0
66090: PUSH
66091: LD_INT 1
66093: NEG
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 1
66101: PUSH
66102: LD_INT 0
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 1
66111: PUSH
66112: LD_INT 1
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: LD_INT 0
66121: PUSH
66122: LD_INT 1
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: LD_INT 0
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: LD_INT 1
66142: NEG
66143: PUSH
66144: LD_INT 1
66146: NEG
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: LD_INT 2
66158: NEG
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 0
66166: PUSH
66167: LD_INT 2
66169: NEG
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PUSH
66175: LD_INT 1
66177: PUSH
66178: LD_INT 1
66180: NEG
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: PUSH
66186: LD_INT 2
66188: PUSH
66189: LD_INT 0
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 2
66198: PUSH
66199: LD_INT 1
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: LD_INT 2
66208: PUSH
66209: LD_INT 2
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: PUSH
66219: LD_INT 2
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 0
66228: PUSH
66229: LD_INT 2
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 1
66238: NEG
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 2
66249: NEG
66250: PUSH
66251: LD_INT 0
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: LD_INT 2
66260: NEG
66261: PUSH
66262: LD_INT 1
66264: NEG
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 2
66272: NEG
66273: PUSH
66274: LD_INT 2
66276: NEG
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: LD_INT 3
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: PUSH
66295: LD_INT 3
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 1
66304: NEG
66305: PUSH
66306: LD_INT 2
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 2
66315: NEG
66316: PUSH
66317: LD_INT 1
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66349: LD_ADDR_VAR 0 27
66353: PUSH
66354: LD_INT 0
66356: PUSH
66357: LD_INT 0
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 0
66366: PUSH
66367: LD_INT 1
66369: NEG
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 1
66377: PUSH
66378: LD_INT 0
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PUSH
66385: LD_INT 1
66387: PUSH
66388: LD_INT 1
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 1
66407: NEG
66408: PUSH
66409: LD_INT 0
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: LD_INT 1
66418: NEG
66419: PUSH
66420: LD_INT 1
66422: NEG
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 1
66430: NEG
66431: PUSH
66432: LD_INT 2
66434: NEG
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 0
66442: PUSH
66443: LD_INT 2
66445: NEG
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PUSH
66451: LD_INT 1
66453: PUSH
66454: LD_INT 1
66456: NEG
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: PUSH
66462: LD_INT 2
66464: PUSH
66465: LD_INT 0
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 2
66474: PUSH
66475: LD_INT 1
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 2
66484: PUSH
66485: LD_INT 2
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: LD_INT 2
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 0
66504: PUSH
66505: LD_INT 2
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: NEG
66515: PUSH
66516: LD_INT 1
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 2
66525: NEG
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 2
66536: NEG
66537: PUSH
66538: LD_INT 1
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: LD_INT 2
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 1
66560: NEG
66561: PUSH
66562: LD_INT 2
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 2
66571: NEG
66572: PUSH
66573: LD_INT 1
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 3
66582: NEG
66583: PUSH
66584: LD_INT 1
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 3
66594: NEG
66595: PUSH
66596: LD_INT 2
66598: NEG
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66629: LD_ADDR_VAR 0 28
66633: PUSH
66634: LD_INT 0
66636: PUSH
66637: LD_INT 0
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 0
66646: PUSH
66647: LD_INT 1
66649: NEG
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 1
66657: PUSH
66658: LD_INT 0
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: LD_INT 1
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 0
66677: PUSH
66678: LD_INT 1
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 0
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 1
66698: NEG
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 1
66710: NEG
66711: PUSH
66712: LD_INT 2
66714: NEG
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: LD_INT 2
66725: NEG
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 1
66733: PUSH
66734: LD_INT 1
66736: NEG
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 2
66744: PUSH
66745: LD_INT 0
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: LD_INT 1
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 2
66764: PUSH
66765: LD_INT 2
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 1
66774: PUSH
66775: LD_INT 2
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 2
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 1
66794: NEG
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 2
66805: NEG
66806: PUSH
66807: LD_INT 0
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 2
66816: NEG
66817: PUSH
66818: LD_INT 1
66820: NEG
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 2
66828: NEG
66829: PUSH
66830: LD_INT 2
66832: NEG
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 2
66840: NEG
66841: PUSH
66842: LD_INT 3
66844: NEG
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 1
66852: NEG
66853: PUSH
66854: LD_INT 3
66856: NEG
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 3
66864: NEG
66865: PUSH
66866: LD_INT 1
66868: NEG
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: LD_INT 3
66876: NEG
66877: PUSH
66878: LD_INT 2
66880: NEG
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66911: LD_ADDR_VAR 0 29
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 0
66928: PUSH
66929: LD_INT 1
66931: NEG
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: LD_INT 1
66949: PUSH
66950: LD_INT 1
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 0
66959: PUSH
66960: LD_INT 1
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 1
66980: NEG
66981: PUSH
66982: LD_INT 1
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 1
66992: NEG
66993: PUSH
66994: LD_INT 2
66996: NEG
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 0
67004: PUSH
67005: LD_INT 2
67007: NEG
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PUSH
67013: LD_INT 1
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 2
67026: PUSH
67027: LD_INT 0
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 2
67036: PUSH
67037: LD_INT 1
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: PUSH
67047: LD_INT 2
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 2
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 1
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 2
67077: NEG
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 2
67089: NEG
67090: PUSH
67091: LD_INT 2
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 2
67101: NEG
67102: PUSH
67103: LD_INT 3
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 3
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 1
67134: PUSH
67135: LD_INT 3
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: LD_INT 1
67144: NEG
67145: PUSH
67146: LD_INT 2
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 3
67155: NEG
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67190: LD_ADDR_VAR 0 30
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 1
67210: NEG
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: PUSH
67229: LD_INT 1
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 0
67238: PUSH
67239: LD_INT 1
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: NEG
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 1
67259: NEG
67260: PUSH
67261: LD_INT 1
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 0
67283: PUSH
67284: LD_INT 2
67286: NEG
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 1
67294: PUSH
67295: LD_INT 1
67297: NEG
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 2
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 2
67325: PUSH
67326: LD_INT 2
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 2
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 1
67345: NEG
67346: PUSH
67347: LD_INT 1
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: NEG
67357: PUSH
67358: LD_INT 0
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 2
67367: NEG
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 1
67379: NEG
67380: PUSH
67381: LD_INT 3
67383: NEG
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 1
67391: PUSH
67392: LD_INT 2
67394: NEG
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 3
67402: PUSH
67403: LD_INT 2
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 2
67412: PUSH
67413: LD_INT 3
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 2
67422: NEG
67423: PUSH
67424: LD_INT 1
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 3
67433: NEG
67434: PUSH
67435: LD_INT 1
67437: NEG
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67468: LD_ADDR_VAR 0 31
67472: PUSH
67473: LD_INT 0
67475: PUSH
67476: LD_INT 0
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: LD_INT 1
67488: NEG
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 1
67496: PUSH
67497: LD_INT 0
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 1
67506: PUSH
67507: LD_INT 1
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 0
67516: PUSH
67517: LD_INT 1
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: NEG
67527: PUSH
67528: LD_INT 0
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: PUSH
67535: LD_INT 1
67537: NEG
67538: PUSH
67539: LD_INT 1
67541: NEG
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: LD_INT 2
67553: NEG
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 1
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 2
67572: PUSH
67573: LD_INT 0
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 2
67582: PUSH
67583: LD_INT 1
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 2
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 0
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 1
67622: NEG
67623: PUSH
67624: LD_INT 1
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: NEG
67634: PUSH
67635: LD_INT 1
67637: NEG
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 2
67645: NEG
67646: PUSH
67647: LD_INT 2
67649: NEG
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 2
67657: NEG
67658: PUSH
67659: LD_INT 3
67661: NEG
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 2
67669: PUSH
67670: LD_INT 1
67672: NEG
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 3
67680: PUSH
67681: LD_INT 1
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: PUSH
67691: LD_INT 3
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: NEG
67701: PUSH
67702: LD_INT 2
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 3
67711: NEG
67712: PUSH
67713: LD_INT 2
67715: NEG
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67746: LD_ADDR_VAR 0 32
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 0
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: LD_INT 1
67766: NEG
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: LD_INT 0
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: LD_INT 1
67784: PUSH
67785: LD_INT 1
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 0
67794: PUSH
67795: LD_INT 1
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 1
67804: NEG
67805: PUSH
67806: LD_INT 0
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 1
67815: NEG
67816: PUSH
67817: LD_INT 1
67819: NEG
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 1
67827: NEG
67828: PUSH
67829: LD_INT 2
67831: NEG
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: PUSH
67837: LD_INT 0
67839: PUSH
67840: LD_INT 2
67842: NEG
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: LD_INT 1
67853: NEG
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 2
67861: PUSH
67862: LD_INT 1
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 2
67871: PUSH
67872: LD_INT 2
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 1
67881: PUSH
67882: LD_INT 2
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: LD_INT 2
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: LD_INT 1
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 2
67912: NEG
67913: PUSH
67914: LD_INT 0
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 2
67923: NEG
67924: PUSH
67925: LD_INT 1
67927: NEG
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: LD_INT 3
67939: NEG
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: PUSH
67945: LD_INT 1
67947: PUSH
67948: LD_INT 2
67950: NEG
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 3
67958: PUSH
67959: LD_INT 2
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: PUSH
67969: LD_INT 3
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: LD_INT 1
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 3
67989: NEG
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: LIST
68023: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68024: LD_ADDR_VAR 0 33
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: LD_INT 0
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: LD_INT 1
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 1
68052: PUSH
68053: LD_INT 0
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 1
68062: PUSH
68063: LD_INT 1
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 0
68072: PUSH
68073: LD_INT 1
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 1
68082: NEG
68083: PUSH
68084: LD_INT 0
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 1
68093: NEG
68094: PUSH
68095: LD_INT 1
68097: NEG
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: LD_INT 2
68109: NEG
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 1
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: PUSH
68129: LD_INT 0
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 2
68138: PUSH
68139: LD_INT 1
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 1
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: LD_INT 2
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: LD_INT 1
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 2
68179: NEG
68180: PUSH
68181: LD_INT 0
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 2
68190: NEG
68191: PUSH
68192: LD_INT 1
68194: NEG
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 2
68202: NEG
68203: PUSH
68204: LD_INT 2
68206: NEG
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 2
68214: NEG
68215: PUSH
68216: LD_INT 3
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 2
68226: PUSH
68227: LD_INT 1
68229: NEG
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PUSH
68235: LD_INT 3
68237: PUSH
68238: LD_INT 1
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 1
68247: PUSH
68248: LD_INT 3
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 1
68257: NEG
68258: PUSH
68259: LD_INT 2
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PUSH
68266: LD_INT 3
68268: NEG
68269: PUSH
68270: LD_INT 2
68272: NEG
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68303: LD_ADDR_VAR 0 34
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 0
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 1
68323: NEG
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: LD_INT 1
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 0
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 1
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: LD_INT 2
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 0
68396: PUSH
68397: LD_INT 2
68399: NEG
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: LD_INT 1
68410: NEG
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 2
68418: PUSH
68419: LD_INT 1
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: PUSH
68429: LD_INT 2
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: LD_INT 2
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 1
68448: NEG
68449: PUSH
68450: LD_INT 1
68452: PUSH
68453: EMPTY
68454: LIST
68455: LIST
68456: PUSH
68457: LD_INT 2
68459: NEG
68460: PUSH
68461: LD_INT 0
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 2
68470: NEG
68471: PUSH
68472: LD_INT 1
68474: NEG
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 2
68482: NEG
68483: PUSH
68484: LD_INT 2
68486: NEG
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: NEG
68495: PUSH
68496: LD_INT 3
68498: NEG
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 1
68506: PUSH
68507: LD_INT 2
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 3
68517: PUSH
68518: LD_INT 2
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 2
68527: PUSH
68528: LD_INT 3
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 2
68537: NEG
68538: PUSH
68539: LD_INT 1
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 3
68548: NEG
68549: PUSH
68550: LD_INT 1
68552: NEG
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68583: LD_ADDR_VAR 0 35
68587: PUSH
68588: LD_INT 0
68590: PUSH
68591: LD_INT 0
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 0
68600: PUSH
68601: LD_INT 1
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 1
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 1
68621: PUSH
68622: LD_INT 1
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 0
68631: PUSH
68632: LD_INT 1
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: LD_INT 0
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 1
68652: NEG
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 2
68664: PUSH
68665: LD_INT 1
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: LD_INT 2
68674: NEG
68675: PUSH
68676: LD_INT 1
68678: NEG
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68695: LD_ADDR_VAR 0 36
68699: PUSH
68700: LD_INT 0
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 0
68712: PUSH
68713: LD_INT 1
68715: NEG
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: LD_INT 0
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 1
68733: PUSH
68734: LD_INT 1
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: LD_INT 1
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: LD_INT 1
68768: NEG
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: NEG
68777: PUSH
68778: LD_INT 2
68780: NEG
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: LD_INT 2
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68807: LD_ADDR_VAR 0 37
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: LD_INT 0
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 0
68824: PUSH
68825: LD_INT 1
68827: NEG
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: LD_INT 0
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: LD_INT 1
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 0
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 1
68865: NEG
68866: PUSH
68867: LD_INT 0
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 1
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 1
68899: NEG
68900: PUSH
68901: LD_INT 1
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68919: LD_ADDR_VAR 0 38
68923: PUSH
68924: LD_INT 0
68926: PUSH
68927: LD_INT 0
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: LD_INT 1
68939: NEG
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 1
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 1
68957: PUSH
68958: LD_INT 1
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: LD_INT 1
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 0
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 1
68988: NEG
68989: PUSH
68990: LD_INT 1
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 2
69000: PUSH
69001: LD_INT 1
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 2
69010: NEG
69011: PUSH
69012: LD_INT 1
69014: NEG
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69031: LD_ADDR_VAR 0 39
69035: PUSH
69036: LD_INT 0
69038: PUSH
69039: LD_INT 0
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 0
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 1
69059: PUSH
69060: LD_INT 0
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 1
69069: PUSH
69070: LD_INT 1
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PUSH
69077: LD_INT 0
69079: PUSH
69080: LD_INT 1
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: NEG
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PUSH
69098: LD_INT 1
69100: NEG
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 2
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69143: LD_ADDR_VAR 0 40
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: LD_INT 0
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: PUSH
69172: LD_INT 0
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 1
69181: PUSH
69182: LD_INT 1
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: LD_INT 1
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 1
69212: NEG
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 1
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 1
69235: NEG
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69255: LD_ADDR_VAR 0 41
69259: PUSH
69260: LD_INT 0
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 0
69272: PUSH
69273: LD_INT 1
69275: NEG
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 0
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 1
69293: PUSH
69294: LD_INT 1
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 0
69303: PUSH
69304: LD_INT 1
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: NEG
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 1
69324: NEG
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 1
69336: NEG
69337: PUSH
69338: LD_INT 2
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: LD_INT 1
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 2
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 2
69369: PUSH
69370: LD_INT 1
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 2
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: LD_INT 2
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 1
69399: NEG
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 2
69410: NEG
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 2
69421: NEG
69422: PUSH
69423: LD_INT 1
69425: NEG
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 2
69433: NEG
69434: PUSH
69435: LD_INT 2
69437: NEG
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 2
69445: NEG
69446: PUSH
69447: LD_INT 3
69449: NEG
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 2
69457: PUSH
69458: LD_INT 1
69460: NEG
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 3
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 3
69478: PUSH
69479: LD_INT 1
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 3
69488: PUSH
69489: LD_INT 2
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 3
69498: PUSH
69499: LD_INT 3
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 2
69508: PUSH
69509: LD_INT 3
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 2
69518: NEG
69519: PUSH
69520: LD_INT 1
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 3
69529: NEG
69530: PUSH
69531: LD_INT 0
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 3
69540: NEG
69541: PUSH
69542: LD_INT 1
69544: NEG
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 3
69552: NEG
69553: PUSH
69554: LD_INT 2
69556: NEG
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 3
69564: NEG
69565: PUSH
69566: LD_INT 3
69568: NEG
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69605: LD_ADDR_VAR 0 42
69609: PUSH
69610: LD_INT 0
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 1
69633: PUSH
69634: LD_INT 0
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 1
69643: PUSH
69644: LD_INT 1
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 0
69653: PUSH
69654: LD_INT 1
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: LD_INT 0
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 1
69686: NEG
69687: PUSH
69688: LD_INT 2
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 0
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 1
69709: PUSH
69710: LD_INT 1
69712: NEG
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 2
69720: PUSH
69721: LD_INT 1
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: PUSH
69728: LD_INT 2
69730: PUSH
69731: LD_INT 2
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 1
69740: PUSH
69741: LD_INT 2
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: LD_INT 2
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 1
69760: NEG
69761: PUSH
69762: LD_INT 1
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 2
69771: NEG
69772: PUSH
69773: LD_INT 1
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 2
69783: NEG
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 2
69795: NEG
69796: PUSH
69797: LD_INT 3
69799: NEG
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 1
69807: NEG
69808: PUSH
69809: LD_INT 3
69811: NEG
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: LD_INT 3
69822: NEG
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 3
69841: PUSH
69842: LD_INT 2
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 3
69851: PUSH
69852: LD_INT 3
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: PUSH
69862: LD_INT 3
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: LD_INT 3
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 3
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: LD_INT 2
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 3
69902: NEG
69903: PUSH
69904: LD_INT 2
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 3
69914: NEG
69915: PUSH
69916: LD_INT 3
69918: NEG
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69955: LD_ADDR_VAR 0 43
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 0
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 0
69972: PUSH
69973: LD_INT 1
69975: NEG
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: LD_INT 0
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 1
69993: PUSH
69994: LD_INT 1
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: LD_INT 1
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 1
70013: NEG
70014: PUSH
70015: LD_INT 0
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: NEG
70025: PUSH
70026: LD_INT 1
70028: NEG
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: NEG
70037: PUSH
70038: LD_INT 2
70040: NEG
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 0
70048: PUSH
70049: LD_INT 2
70051: NEG
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 1
70059: PUSH
70060: LD_INT 1
70062: NEG
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 2
70070: PUSH
70071: LD_INT 0
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 2
70080: PUSH
70081: LD_INT 1
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: PUSH
70091: LD_INT 2
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 0
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 1
70110: NEG
70111: PUSH
70112: LD_INT 1
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 2
70121: NEG
70122: PUSH
70123: LD_INT 0
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 2
70132: NEG
70133: PUSH
70134: LD_INT 1
70136: NEG
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 1
70144: NEG
70145: PUSH
70146: LD_INT 3
70148: NEG
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 0
70156: PUSH
70157: LD_INT 3
70159: NEG
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 1
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 2
70178: PUSH
70179: LD_INT 1
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 3
70189: PUSH
70190: LD_INT 0
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 3
70199: PUSH
70200: LD_INT 1
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 1
70209: PUSH
70210: LD_INT 3
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 0
70219: PUSH
70220: LD_INT 3
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 1
70229: NEG
70230: PUSH
70231: LD_INT 2
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: PUSH
70238: LD_INT 2
70240: NEG
70241: PUSH
70242: LD_INT 1
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 3
70251: NEG
70252: PUSH
70253: LD_INT 0
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 3
70262: NEG
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70303: LD_ADDR_VAR 0 44
70307: PUSH
70308: LD_INT 0
70310: PUSH
70311: LD_INT 0
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 1
70323: NEG
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 1
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: NEG
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 1
70384: NEG
70385: PUSH
70386: LD_INT 2
70388: NEG
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 2
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: PUSH
70418: LD_INT 1
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 2
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 1
70437: PUSH
70438: LD_INT 2
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 1
70447: NEG
70448: PUSH
70449: LD_INT 1
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 2
70458: NEG
70459: PUSH
70460: LD_INT 0
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 2
70469: NEG
70470: PUSH
70471: LD_INT 1
70473: NEG
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 2
70481: NEG
70482: PUSH
70483: LD_INT 2
70485: NEG
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 2
70493: NEG
70494: PUSH
70495: LD_INT 3
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 3
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 3
70536: PUSH
70537: LD_INT 2
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 3
70546: PUSH
70547: LD_INT 3
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 2
70556: PUSH
70557: LD_INT 3
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: NEG
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 3
70577: NEG
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 3
70588: NEG
70589: PUSH
70590: LD_INT 1
70592: NEG
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 3
70600: NEG
70601: PUSH
70602: LD_INT 2
70604: NEG
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 3
70612: NEG
70613: PUSH
70614: LD_INT 3
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: EMPTY
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70653: LD_ADDR_VAR 0 45
70657: PUSH
70658: LD_INT 0
70660: PUSH
70661: LD_INT 0
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 0
70670: PUSH
70671: LD_INT 1
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: LD_INT 1
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 0
70701: PUSH
70702: LD_INT 1
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 1
70722: NEG
70723: PUSH
70724: LD_INT 1
70726: NEG
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 1
70734: NEG
70735: PUSH
70736: LD_INT 2
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: LD_INT 2
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 1
70757: PUSH
70758: LD_INT 1
70760: NEG
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 2
70768: PUSH
70769: LD_INT 1
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 2
70778: PUSH
70779: LD_INT 2
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 1
70788: PUSH
70789: LD_INT 2
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: LD_INT 2
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: NEG
70809: PUSH
70810: LD_INT 1
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 2
70819: NEG
70820: PUSH
70821: LD_INT 1
70823: NEG
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 2
70831: NEG
70832: PUSH
70833: LD_INT 2
70835: NEG
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 2
70843: NEG
70844: PUSH
70845: LD_INT 3
70847: NEG
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: NEG
70856: PUSH
70857: LD_INT 3
70859: NEG
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 0
70867: PUSH
70868: LD_INT 3
70870: NEG
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 1
70878: PUSH
70879: LD_INT 2
70881: NEG
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 3
70889: PUSH
70890: LD_INT 2
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: LD_INT 3
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 0
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 1
70939: NEG
70940: PUSH
70941: LD_INT 2
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 3
70950: NEG
70951: PUSH
70952: LD_INT 2
70954: NEG
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 3
70962: NEG
70963: PUSH
70964: LD_INT 3
70966: NEG
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71003: LD_ADDR_VAR 0 46
71007: PUSH
71008: LD_INT 0
71010: PUSH
71011: LD_INT 0
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: LD_INT 1
71023: NEG
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: LD_INT 0
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 1
71041: PUSH
71042: LD_INT 1
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: LD_INT 1
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: LD_INT 0
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 1
71072: NEG
71073: PUSH
71074: LD_INT 1
71076: NEG
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 1
71084: NEG
71085: PUSH
71086: LD_INT 2
71088: NEG
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 0
71096: PUSH
71097: LD_INT 2
71099: NEG
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 1
71107: PUSH
71108: LD_INT 1
71110: NEG
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: LD_INT 0
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: PUSH
71139: LD_INT 2
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 0
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: LD_INT 1
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 2
71169: NEG
71170: PUSH
71171: LD_INT 0
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 2
71180: NEG
71181: PUSH
71182: LD_INT 1
71184: NEG
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 1
71192: NEG
71193: PUSH
71194: LD_INT 3
71196: NEG
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 0
71204: PUSH
71205: LD_INT 3
71207: NEG
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 1
71215: PUSH
71216: LD_INT 2
71218: NEG
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 2
71226: PUSH
71227: LD_INT 1
71229: NEG
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 3
71237: PUSH
71238: LD_INT 0
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 3
71247: PUSH
71248: LD_INT 1
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: PUSH
71258: LD_INT 3
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: LD_INT 3
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 1
71277: NEG
71278: PUSH
71279: LD_INT 2
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: LD_INT 1
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 3
71299: NEG
71300: PUSH
71301: LD_INT 0
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 3
71310: NEG
71311: PUSH
71312: LD_INT 1
71314: NEG
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71351: LD_ADDR_VAR 0 47
71355: PUSH
71356: LD_INT 0
71358: PUSH
71359: LD_INT 0
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 1
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: LD_INT 0
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 1
71389: PUSH
71390: LD_INT 1
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: LD_INT 1
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 1
71409: NEG
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 1
71420: NEG
71421: PUSH
71422: LD_INT 1
71424: NEG
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 1
71432: NEG
71433: PUSH
71434: LD_INT 2
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: LD_INT 2
71447: NEG
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 1
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 2
71466: NEG
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 2
71478: NEG
71479: PUSH
71480: LD_INT 2
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71502: LD_ADDR_VAR 0 48
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 0
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 1
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 0
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 1
71560: NEG
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 1
71571: NEG
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 2
71587: NEG
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: LD_INT 2
71598: NEG
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 1
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 2
71627: PUSH
71628: LD_INT 1
71630: PUSH
71631: EMPTY
71632: LIST
71633: LIST
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71649: LD_ADDR_VAR 0 49
71653: PUSH
71654: LD_INT 0
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 0
71666: PUSH
71667: LD_INT 1
71669: NEG
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: LD_INT 0
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: LD_INT 1
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 0
71697: PUSH
71698: LD_INT 1
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: NEG
71708: PUSH
71709: LD_INT 0
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 1
71718: NEG
71719: PUSH
71720: LD_INT 1
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 1
71730: PUSH
71731: LD_INT 1
71733: NEG
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 2
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 2
71751: PUSH
71752: LD_INT 1
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 2
71761: PUSH
71762: LD_INT 2
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: LD_INT 2
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71793: LD_ADDR_VAR 0 50
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: LD_INT 0
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PUSH
71808: LD_INT 0
71810: PUSH
71811: LD_INT 1
71813: NEG
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: LD_INT 1
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: LD_INT 1
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 0
71841: PUSH
71842: LD_INT 1
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 1
71851: NEG
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: LD_INT 1
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 2
71874: PUSH
71875: LD_INT 1
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 2
71884: PUSH
71885: LD_INT 2
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: PUSH
71895: LD_INT 2
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 0
71904: PUSH
71905: LD_INT 2
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 1
71914: NEG
71915: PUSH
71916: LD_INT 1
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: LIST
71934: LIST
71935: LIST
71936: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71937: LD_ADDR_VAR 0 51
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: LD_INT 0
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 0
71954: PUSH
71955: LD_INT 1
71957: NEG
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 1
71975: PUSH
71976: LD_INT 1
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 0
71985: PUSH
71986: LD_INT 1
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: NEG
71996: PUSH
71997: LD_INT 0
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 1
72006: NEG
72007: PUSH
72008: LD_INT 1
72010: NEG
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: LD_INT 2
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: PUSH
72026: LD_INT 0
72028: PUSH
72029: LD_INT 2
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 1
72038: NEG
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: LD_INT 0
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 2
72060: NEG
72061: PUSH
72062: LD_INT 1
72064: NEG
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72084: LD_ADDR_VAR 0 52
72088: PUSH
72089: LD_INT 0
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 0
72101: PUSH
72102: LD_INT 1
72104: NEG
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: LD_INT 0
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 1
72122: PUSH
72123: LD_INT 1
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: LD_INT 1
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: LD_INT 0
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: LD_INT 1
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 2
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: LD_INT 1
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 2
72188: NEG
72189: PUSH
72190: LD_INT 0
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 2
72199: NEG
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 2
72211: NEG
72212: PUSH
72213: LD_INT 2
72215: NEG
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72235: LD_ADDR_VAR 0 53
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: LD_INT 0
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 0
72252: PUSH
72253: LD_INT 1
72255: NEG
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 0
72283: PUSH
72284: LD_INT 1
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 1
72293: NEG
72294: PUSH
72295: LD_INT 0
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: LD_INT 1
72308: NEG
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: NEG
72317: PUSH
72318: LD_INT 2
72320: NEG
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 0
72328: PUSH
72329: LD_INT 2
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: PUSH
72340: LD_INT 1
72342: NEG
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 2
72350: PUSH
72351: LD_INT 0
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 2
72360: PUSH
72361: LD_INT 1
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: LD_INT 2
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: LD_INT 2
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: LD_INT 2
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: NEG
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 2
72411: NEG
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 2
72422: NEG
72423: PUSH
72424: LD_INT 1
72426: NEG
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 2
72434: NEG
72435: PUSH
72436: LD_INT 2
72438: NEG
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72465: LD_ADDR_VAR 0 54
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 0
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: LD_INT 1
72485: NEG
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: LD_INT 1
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 0
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 1
72523: NEG
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: LD_INT 1
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: NEG
72547: PUSH
72548: LD_INT 2
72550: NEG
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: LD_INT 2
72561: NEG
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: NEG
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 2
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 2
72590: PUSH
72591: LD_INT 1
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: LD_INT 2
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 1
72610: PUSH
72611: LD_INT 2
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: LD_INT 2
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 1
72630: NEG
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 2
72641: NEG
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 2
72652: NEG
72653: PUSH
72654: LD_INT 1
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 2
72664: NEG
72665: PUSH
72666: LD_INT 2
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72695: LD_ADDR_VAR 0 55
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 0
72712: PUSH
72713: LD_INT 1
72715: NEG
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 1
72723: PUSH
72724: LD_INT 0
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 1
72733: PUSH
72734: LD_INT 1
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: LD_INT 1
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 1
72753: NEG
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 1
72764: NEG
72765: PUSH
72766: LD_INT 1
72768: NEG
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 2
72780: NEG
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 0
72788: PUSH
72789: LD_INT 2
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 1
72799: PUSH
72800: LD_INT 1
72802: NEG
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 2
72810: PUSH
72811: LD_INT 0
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 2
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 2
72830: PUSH
72831: LD_INT 2
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: LD_INT 1
72840: PUSH
72841: LD_INT 2
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 0
72850: PUSH
72851: LD_INT 2
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: LD_INT 1
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 2
72871: NEG
72872: PUSH
72873: LD_INT 0
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 2
72882: NEG
72883: PUSH
72884: LD_INT 1
72886: NEG
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 2
72894: NEG
72895: PUSH
72896: LD_INT 2
72898: NEG
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72925: LD_ADDR_VAR 0 56
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: LD_INT 0
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: LD_INT 1
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: NEG
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 1
73006: NEG
73007: PUSH
73008: LD_INT 2
73010: NEG
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 2
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 2
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 2
73060: PUSH
73061: LD_INT 2
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: LD_INT 2
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 2
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 2
73101: NEG
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 2
73112: NEG
73113: PUSH
73114: LD_INT 1
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 2
73124: NEG
73125: PUSH
73126: LD_INT 2
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73155: LD_ADDR_VAR 0 57
73159: PUSH
73160: LD_INT 0
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: LD_INT 1
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 1
73213: NEG
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: NEG
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 1
73236: NEG
73237: PUSH
73238: LD_INT 2
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 2
73251: NEG
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 1
73262: NEG
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: LD_INT 2
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 1
73300: PUSH
73301: LD_INT 2
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 2
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 1
73320: NEG
73321: PUSH
73322: LD_INT 1
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 2
73331: NEG
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: NEG
73343: PUSH
73344: LD_INT 1
73346: NEG
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: NEG
73355: PUSH
73356: LD_INT 2
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73385: LD_ADDR_VAR 0 58
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 0
73402: PUSH
73403: LD_INT 1
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: LD_INT 0
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 1
73443: NEG
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 1
73466: NEG
73467: PUSH
73468: LD_INT 2
73470: NEG
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 2
73481: NEG
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: LD_INT 1
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 1
73530: PUSH
73531: LD_INT 2
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 2
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 2
73561: NEG
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 2
73572: NEG
73573: PUSH
73574: LD_INT 1
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 2
73584: NEG
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73615: LD_ADDR_VAR 0 59
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 0
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 0
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 0
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 1
73673: NEG
73674: PUSH
73675: LD_INT 0
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73703: LD_ADDR_VAR 0 60
73707: PUSH
73708: LD_INT 0
73710: PUSH
73711: LD_INT 0
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 0
73720: PUSH
73721: LD_INT 1
73723: NEG
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: LD_INT 1
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: LD_INT 1
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 0
73751: PUSH
73752: LD_INT 1
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 1
73761: NEG
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: NEG
73773: PUSH
73774: LD_INT 1
73776: NEG
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73791: LD_ADDR_VAR 0 61
73795: PUSH
73796: LD_INT 0
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 0
73808: PUSH
73809: LD_INT 1
73811: NEG
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: LD_INT 0
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: PUSH
73830: LD_INT 1
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: PUSH
73837: LD_INT 0
73839: PUSH
73840: LD_INT 1
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 0
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73879: LD_ADDR_VAR 0 62
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: LD_INT 0
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 0
73896: PUSH
73897: LD_INT 1
73899: NEG
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 1
73907: PUSH
73908: LD_INT 0
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 1
73917: PUSH
73918: LD_INT 1
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 0
73927: PUSH
73928: LD_INT 1
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: NEG
73938: PUSH
73939: LD_INT 0
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 1
73948: NEG
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73967: LD_ADDR_VAR 0 63
73971: PUSH
73972: LD_INT 0
73974: PUSH
73975: LD_INT 0
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 0
73984: PUSH
73985: LD_INT 1
73987: NEG
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 1
73995: PUSH
73996: LD_INT 0
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 1
74005: PUSH
74006: LD_INT 1
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 0
74015: PUSH
74016: LD_INT 1
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 1
74025: NEG
74026: PUSH
74027: LD_INT 0
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: LD_INT 1
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74055: LD_ADDR_VAR 0 64
74059: PUSH
74060: LD_INT 0
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 0
74072: PUSH
74073: LD_INT 1
74075: NEG
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: LD_INT 0
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 1
74093: PUSH
74094: LD_INT 1
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: LD_INT 1
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: NEG
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: ST_TO_ADDR
// end ; 1 :
74143: GO 80040
74145: LD_INT 1
74147: DOUBLE
74148: EQUAL
74149: IFTRUE 74153
74151: GO 76776
74153: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74154: LD_ADDR_VAR 0 11
74158: PUSH
74159: LD_INT 1
74161: NEG
74162: PUSH
74163: LD_INT 3
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 0
74173: PUSH
74174: LD_INT 3
74176: NEG
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 1
74184: PUSH
74185: LD_INT 2
74187: NEG
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: LIST
74197: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74198: LD_ADDR_VAR 0 12
74202: PUSH
74203: LD_INT 2
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PUSH
74214: LD_INT 3
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 3
74226: PUSH
74227: LD_INT 1
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: LIST
74238: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74239: LD_ADDR_VAR 0 13
74243: PUSH
74244: LD_INT 3
74246: PUSH
74247: LD_INT 2
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 3
74256: PUSH
74257: LD_INT 3
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 2
74266: PUSH
74267: LD_INT 3
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: LIST
74278: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74279: LD_ADDR_VAR 0 14
74283: PUSH
74284: LD_INT 1
74286: PUSH
74287: LD_INT 3
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: LD_INT 3
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 1
74306: NEG
74307: PUSH
74308: LD_INT 2
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: LIST
74319: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74320: LD_ADDR_VAR 0 15
74324: PUSH
74325: LD_INT 2
74327: NEG
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 3
74338: NEG
74339: PUSH
74340: LD_INT 0
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 3
74349: NEG
74350: PUSH
74351: LD_INT 1
74353: NEG
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: LIST
74363: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74364: LD_ADDR_VAR 0 16
74368: PUSH
74369: LD_INT 2
74371: NEG
74372: PUSH
74373: LD_INT 3
74375: NEG
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 3
74383: NEG
74384: PUSH
74385: LD_INT 2
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 3
74395: NEG
74396: PUSH
74397: LD_INT 3
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74410: LD_ADDR_VAR 0 17
74414: PUSH
74415: LD_INT 1
74417: NEG
74418: PUSH
74419: LD_INT 3
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 0
74429: PUSH
74430: LD_INT 3
74432: NEG
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: PUSH
74441: LD_INT 2
74443: NEG
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: LIST
74453: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74454: LD_ADDR_VAR 0 18
74458: PUSH
74459: LD_INT 2
74461: PUSH
74462: LD_INT 1
74464: NEG
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 3
74472: PUSH
74473: LD_INT 0
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 3
74482: PUSH
74483: LD_INT 1
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: LIST
74494: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74495: LD_ADDR_VAR 0 19
74499: PUSH
74500: LD_INT 3
74502: PUSH
74503: LD_INT 2
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 3
74512: PUSH
74513: LD_INT 3
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 2
74522: PUSH
74523: LD_INT 3
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: LIST
74534: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74535: LD_ADDR_VAR 0 20
74539: PUSH
74540: LD_INT 1
74542: PUSH
74543: LD_INT 3
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: LD_INT 3
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 1
74562: NEG
74563: PUSH
74564: LD_INT 2
74566: PUSH
74567: EMPTY
74568: LIST
74569: LIST
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: LIST
74575: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74576: LD_ADDR_VAR 0 21
74580: PUSH
74581: LD_INT 2
74583: NEG
74584: PUSH
74585: LD_INT 1
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 3
74594: NEG
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 3
74605: NEG
74606: PUSH
74607: LD_INT 1
74609: NEG
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: LIST
74619: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74620: LD_ADDR_VAR 0 22
74624: PUSH
74625: LD_INT 2
74627: NEG
74628: PUSH
74629: LD_INT 3
74631: NEG
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 3
74639: NEG
74640: PUSH
74641: LD_INT 2
74643: NEG
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 3
74651: NEG
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: LIST
74665: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74666: LD_ADDR_VAR 0 23
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: LD_INT 3
74676: NEG
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: LD_INT 4
74688: NEG
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: PUSH
74697: LD_INT 3
74699: NEG
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: LIST
74709: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74710: LD_ADDR_VAR 0 24
74714: PUSH
74715: LD_INT 3
74717: PUSH
74718: LD_INT 0
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 3
74727: PUSH
74728: LD_INT 1
74730: NEG
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 4
74738: PUSH
74739: LD_INT 1
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: LIST
74750: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74751: LD_ADDR_VAR 0 25
74755: PUSH
74756: LD_INT 3
74758: PUSH
74759: LD_INT 3
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 4
74768: PUSH
74769: LD_INT 3
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 3
74778: PUSH
74779: LD_INT 4
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: LIST
74790: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74791: LD_ADDR_VAR 0 26
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: LD_INT 3
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: PUSH
74809: LD_INT 4
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 1
74818: NEG
74819: PUSH
74820: LD_INT 3
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: LIST
74831: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74832: LD_ADDR_VAR 0 27
74836: PUSH
74837: LD_INT 3
74839: NEG
74840: PUSH
74841: LD_INT 0
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 3
74850: NEG
74851: PUSH
74852: LD_INT 1
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 4
74861: NEG
74862: PUSH
74863: LD_INT 1
74865: NEG
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: LIST
74875: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74876: LD_ADDR_VAR 0 28
74880: PUSH
74881: LD_INT 3
74883: NEG
74884: PUSH
74885: LD_INT 3
74887: NEG
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 3
74895: NEG
74896: PUSH
74897: LD_INT 4
74899: NEG
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 4
74907: NEG
74908: PUSH
74909: LD_INT 3
74911: NEG
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: LIST
74921: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74922: LD_ADDR_VAR 0 29
74926: PUSH
74927: LD_INT 1
74929: NEG
74930: PUSH
74931: LD_INT 3
74933: NEG
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: LD_INT 3
74944: NEG
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 1
74952: PUSH
74953: LD_INT 2
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: NEG
74964: PUSH
74965: LD_INT 4
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: LD_INT 4
74978: NEG
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 1
74986: PUSH
74987: LD_INT 3
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: NEG
74998: PUSH
74999: LD_INT 5
75001: NEG
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 0
75009: PUSH
75010: LD_INT 5
75012: NEG
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: LD_INT 4
75023: NEG
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: LD_INT 6
75035: NEG
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: LD_INT 6
75046: NEG
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: PUSH
75055: LD_INT 5
75057: NEG
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75077: LD_ADDR_VAR 0 30
75081: PUSH
75082: LD_INT 2
75084: PUSH
75085: LD_INT 1
75087: NEG
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 3
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 3
75105: PUSH
75106: LD_INT 1
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 3
75115: PUSH
75116: LD_INT 1
75118: NEG
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 4
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 4
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 4
75146: PUSH
75147: LD_INT 1
75149: NEG
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 5
75157: PUSH
75158: LD_INT 0
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 5
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 5
75177: PUSH
75178: LD_INT 1
75180: NEG
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 6
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 6
75198: PUSH
75199: LD_INT 1
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75220: LD_ADDR_VAR 0 31
75224: PUSH
75225: LD_INT 3
75227: PUSH
75228: LD_INT 2
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 3
75237: PUSH
75238: LD_INT 3
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 2
75247: PUSH
75248: LD_INT 3
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 4
75257: PUSH
75258: LD_INT 3
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 4
75267: PUSH
75268: LD_INT 4
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 3
75277: PUSH
75278: LD_INT 4
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 5
75287: PUSH
75288: LD_INT 4
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 5
75297: PUSH
75298: LD_INT 5
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 4
75307: PUSH
75308: LD_INT 5
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 6
75317: PUSH
75318: LD_INT 5
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 6
75327: PUSH
75328: LD_INT 6
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 5
75337: PUSH
75338: LD_INT 6
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75359: LD_ADDR_VAR 0 32
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: LD_INT 3
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 0
75376: PUSH
75377: LD_INT 3
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 1
75386: NEG
75387: PUSH
75388: LD_INT 2
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 1
75397: PUSH
75398: LD_INT 4
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 0
75407: PUSH
75408: LD_INT 4
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 1
75417: NEG
75418: PUSH
75419: LD_INT 3
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 1
75428: PUSH
75429: LD_INT 5
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: LD_INT 5
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: LD_INT 4
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PUSH
75457: LD_INT 1
75459: PUSH
75460: LD_INT 6
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: PUSH
75467: LD_INT 0
75469: PUSH
75470: LD_INT 6
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 1
75479: NEG
75480: PUSH
75481: LD_INT 5
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75502: LD_ADDR_VAR 0 33
75506: PUSH
75507: LD_INT 2
75509: NEG
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 3
75520: NEG
75521: PUSH
75522: LD_INT 0
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 3
75531: NEG
75532: PUSH
75533: LD_INT 1
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 3
75543: NEG
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 4
75554: NEG
75555: PUSH
75556: LD_INT 0
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 4
75565: NEG
75566: PUSH
75567: LD_INT 1
75569: NEG
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 4
75577: NEG
75578: PUSH
75579: LD_INT 1
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 5
75588: NEG
75589: PUSH
75590: LD_INT 0
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 5
75599: NEG
75600: PUSH
75601: LD_INT 1
75603: NEG
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: PUSH
75609: LD_INT 5
75611: NEG
75612: PUSH
75613: LD_INT 1
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 6
75622: NEG
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 6
75633: NEG
75634: PUSH
75635: LD_INT 1
75637: NEG
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: LIST
75655: LIST
75656: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75657: LD_ADDR_VAR 0 34
75661: PUSH
75662: LD_INT 2
75664: NEG
75665: PUSH
75666: LD_INT 3
75668: NEG
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 3
75676: NEG
75677: PUSH
75678: LD_INT 2
75680: NEG
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 3
75688: NEG
75689: PUSH
75690: LD_INT 3
75692: NEG
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 3
75700: NEG
75701: PUSH
75702: LD_INT 4
75704: NEG
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 4
75712: NEG
75713: PUSH
75714: LD_INT 3
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 4
75724: NEG
75725: PUSH
75726: LD_INT 4
75728: NEG
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 4
75736: NEG
75737: PUSH
75738: LD_INT 5
75740: NEG
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 5
75748: NEG
75749: PUSH
75750: LD_INT 4
75752: NEG
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PUSH
75758: LD_INT 5
75760: NEG
75761: PUSH
75762: LD_INT 5
75764: NEG
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 5
75772: NEG
75773: PUSH
75774: LD_INT 6
75776: NEG
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 6
75784: NEG
75785: PUSH
75786: LD_INT 5
75788: NEG
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 6
75796: NEG
75797: PUSH
75798: LD_INT 6
75800: NEG
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75820: LD_ADDR_VAR 0 41
75824: PUSH
75825: LD_INT 0
75827: PUSH
75828: LD_INT 2
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: LD_INT 3
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: LD_INT 2
75853: NEG
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: LIST
75863: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75864: LD_ADDR_VAR 0 42
75868: PUSH
75869: LD_INT 2
75871: PUSH
75872: LD_INT 0
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 2
75881: PUSH
75882: LD_INT 1
75884: NEG
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 3
75892: PUSH
75893: LD_INT 1
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: LIST
75904: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75905: LD_ADDR_VAR 0 43
75909: PUSH
75910: LD_INT 2
75912: PUSH
75913: LD_INT 2
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: PUSH
75923: LD_INT 2
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 2
75932: PUSH
75933: LD_INT 3
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: LIST
75944: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75945: LD_ADDR_VAR 0 44
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: LD_INT 2
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: LD_INT 3
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 1
75972: NEG
75973: PUSH
75974: LD_INT 2
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: LIST
75985: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75986: LD_ADDR_VAR 0 45
75990: PUSH
75991: LD_INT 2
75993: NEG
75994: PUSH
75995: LD_INT 0
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 2
76004: NEG
76005: PUSH
76006: LD_INT 1
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 3
76015: NEG
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: LIST
76029: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76030: LD_ADDR_VAR 0 46
76034: PUSH
76035: LD_INT 2
76037: NEG
76038: PUSH
76039: LD_INT 2
76041: NEG
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 2
76049: NEG
76050: PUSH
76051: LD_INT 3
76053: NEG
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 3
76061: NEG
76062: PUSH
76063: LD_INT 2
76065: NEG
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: LIST
76075: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76076: LD_ADDR_VAR 0 47
76080: PUSH
76081: LD_INT 2
76083: NEG
76084: PUSH
76085: LD_INT 3
76087: NEG
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 1
76095: NEG
76096: PUSH
76097: LD_INT 3
76099: NEG
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76109: LD_ADDR_VAR 0 48
76113: PUSH
76114: LD_INT 1
76116: PUSH
76117: LD_INT 2
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 2
76127: PUSH
76128: LD_INT 1
76130: NEG
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76140: LD_ADDR_VAR 0 49
76144: PUSH
76145: LD_INT 3
76147: PUSH
76148: LD_INT 1
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 3
76157: PUSH
76158: LD_INT 2
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76169: LD_ADDR_VAR 0 50
76173: PUSH
76174: LD_INT 2
76176: PUSH
76177: LD_INT 3
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 1
76186: PUSH
76187: LD_INT 3
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76198: LD_ADDR_VAR 0 51
76202: PUSH
76203: LD_INT 1
76205: NEG
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 2
76216: NEG
76217: PUSH
76218: LD_INT 1
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76229: LD_ADDR_VAR 0 52
76233: PUSH
76234: LD_INT 3
76236: NEG
76237: PUSH
76238: LD_INT 1
76240: NEG
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 3
76248: NEG
76249: PUSH
76250: LD_INT 2
76252: NEG
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76262: LD_ADDR_VAR 0 53
76266: PUSH
76267: LD_INT 1
76269: NEG
76270: PUSH
76271: LD_INT 3
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 0
76281: PUSH
76282: LD_INT 3
76284: NEG
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 1
76292: PUSH
76293: LD_INT 2
76295: NEG
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: LIST
76305: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76306: LD_ADDR_VAR 0 54
76310: PUSH
76311: LD_INT 2
76313: PUSH
76314: LD_INT 1
76316: NEG
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 3
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 3
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: LIST
76346: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76347: LD_ADDR_VAR 0 55
76351: PUSH
76352: LD_INT 3
76354: PUSH
76355: LD_INT 2
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: PUSH
76362: LD_INT 3
76364: PUSH
76365: LD_INT 3
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 2
76374: PUSH
76375: LD_INT 3
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: LIST
76386: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76387: LD_ADDR_VAR 0 56
76391: PUSH
76392: LD_INT 1
76394: PUSH
76395: LD_INT 3
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: LD_INT 0
76404: PUSH
76405: LD_INT 3
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: LD_INT 2
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: LIST
76427: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76428: LD_ADDR_VAR 0 57
76432: PUSH
76433: LD_INT 2
76435: NEG
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 3
76446: NEG
76447: PUSH
76448: LD_INT 0
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 3
76457: NEG
76458: PUSH
76459: LD_INT 1
76461: NEG
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: LIST
76471: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76472: LD_ADDR_VAR 0 58
76476: PUSH
76477: LD_INT 2
76479: NEG
76480: PUSH
76481: LD_INT 3
76483: NEG
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 3
76491: NEG
76492: PUSH
76493: LD_INT 2
76495: NEG
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 3
76503: NEG
76504: PUSH
76505: LD_INT 3
76507: NEG
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: LIST
76517: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76518: LD_ADDR_VAR 0 59
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: LD_INT 2
76529: NEG
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 0
76537: PUSH
76538: LD_INT 2
76540: NEG
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 1
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: LIST
76561: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76562: LD_ADDR_VAR 0 60
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 1
76572: NEG
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 2
76580: PUSH
76581: LD_INT 0
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 2
76590: PUSH
76591: LD_INT 1
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: LIST
76602: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76603: LD_ADDR_VAR 0 61
76607: PUSH
76608: LD_INT 2
76610: PUSH
76611: LD_INT 1
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 2
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: PUSH
76628: LD_INT 1
76630: PUSH
76631: LD_INT 2
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: LIST
76642: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76643: LD_ADDR_VAR 0 62
76647: PUSH
76648: LD_INT 1
76650: PUSH
76651: LD_INT 2
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 0
76660: PUSH
76661: LD_INT 2
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: LD_INT 1
76670: NEG
76671: PUSH
76672: LD_INT 1
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: LIST
76683: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76684: LD_ADDR_VAR 0 63
76688: PUSH
76689: LD_INT 1
76691: NEG
76692: PUSH
76693: LD_INT 1
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 2
76702: NEG
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: LD_INT 1
76717: NEG
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: LIST
76727: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76728: LD_ADDR_VAR 0 64
76732: PUSH
76733: LD_INT 1
76735: NEG
76736: PUSH
76737: LD_INT 2
76739: NEG
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 2
76747: NEG
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 2
76759: NEG
76760: PUSH
76761: LD_INT 2
76763: NEG
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: LIST
76773: ST_TO_ADDR
// end ; 2 :
76774: GO 80040
76776: LD_INT 2
76778: DOUBLE
76779: EQUAL
76780: IFTRUE 76784
76782: GO 80039
76784: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76785: LD_ADDR_VAR 0 29
76789: PUSH
76790: LD_INT 4
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 4
76802: PUSH
76803: LD_INT 1
76805: NEG
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 5
76813: PUSH
76814: LD_INT 0
76816: PUSH
76817: EMPTY
76818: LIST
76819: LIST
76820: PUSH
76821: LD_INT 5
76823: PUSH
76824: LD_INT 1
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 4
76833: PUSH
76834: LD_INT 1
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 3
76843: PUSH
76844: LD_INT 0
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 3
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 3
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 5
76875: PUSH
76876: LD_INT 2
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 3
76885: PUSH
76886: LD_INT 3
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 3
76895: PUSH
76896: LD_INT 2
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 4
76905: PUSH
76906: LD_INT 3
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: PUSH
76913: LD_INT 4
76915: PUSH
76916: LD_INT 4
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: PUSH
76923: LD_INT 3
76925: PUSH
76926: LD_INT 4
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: LD_INT 2
76935: PUSH
76936: LD_INT 3
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: LD_INT 2
76945: PUSH
76946: LD_INT 2
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 4
76955: PUSH
76956: LD_INT 2
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: PUSH
76966: LD_INT 4
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 0
76975: PUSH
76976: LD_INT 4
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: LD_INT 3
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: PUSH
76996: LD_INT 4
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 1
77005: PUSH
77006: LD_INT 5
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 0
77015: PUSH
77016: LD_INT 5
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: NEG
77026: PUSH
77027: LD_INT 4
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 1
77036: NEG
77037: PUSH
77038: LD_INT 3
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: PUSH
77045: LD_INT 2
77047: PUSH
77048: LD_INT 5
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 2
77057: NEG
77058: PUSH
77059: LD_INT 3
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 3
77068: NEG
77069: PUSH
77070: LD_INT 0
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 3
77079: NEG
77080: PUSH
77081: LD_INT 1
77083: NEG
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 2
77091: NEG
77092: PUSH
77093: LD_INT 0
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 2
77102: NEG
77103: PUSH
77104: LD_INT 1
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 3
77113: NEG
77114: PUSH
77115: LD_INT 1
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 4
77124: NEG
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 4
77135: NEG
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 4
77147: NEG
77148: PUSH
77149: LD_INT 2
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 2
77159: NEG
77160: PUSH
77161: LD_INT 2
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 4
77170: NEG
77171: PUSH
77172: LD_INT 4
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 4
77182: NEG
77183: PUSH
77184: LD_INT 5
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 3
77194: NEG
77195: PUSH
77196: LD_INT 4
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 3
77206: NEG
77207: PUSH
77208: LD_INT 3
77210: NEG
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 4
77218: NEG
77219: PUSH
77220: LD_INT 3
77222: NEG
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PUSH
77228: LD_INT 5
77230: NEG
77231: PUSH
77232: LD_INT 4
77234: NEG
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: PUSH
77240: LD_INT 5
77242: NEG
77243: PUSH
77244: LD_INT 5
77246: NEG
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 3
77254: NEG
77255: PUSH
77256: LD_INT 5
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 5
77266: NEG
77267: PUSH
77268: LD_INT 3
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77323: LD_ADDR_VAR 0 30
77327: PUSH
77328: LD_INT 4
77330: PUSH
77331: LD_INT 4
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 4
77340: PUSH
77341: LD_INT 3
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 5
77350: PUSH
77351: LD_INT 4
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 5
77360: PUSH
77361: LD_INT 5
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 4
77370: PUSH
77371: LD_INT 5
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 3
77380: PUSH
77381: LD_INT 4
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 3
77390: PUSH
77391: LD_INT 3
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 5
77400: PUSH
77401: LD_INT 3
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 3
77410: PUSH
77411: LD_INT 5
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 0
77420: PUSH
77421: LD_INT 3
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 0
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 1
77440: PUSH
77441: LD_INT 3
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 1
77450: PUSH
77451: LD_INT 4
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 0
77460: PUSH
77461: LD_INT 4
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 1
77470: NEG
77471: PUSH
77472: LD_INT 3
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: LD_INT 2
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 2
77492: PUSH
77493: LD_INT 4
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 2
77502: NEG
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 4
77513: NEG
77514: PUSH
77515: LD_INT 0
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 4
77524: NEG
77525: PUSH
77526: LD_INT 1
77528: NEG
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 3
77536: NEG
77537: PUSH
77538: LD_INT 0
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 3
77547: NEG
77548: PUSH
77549: LD_INT 1
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 4
77558: NEG
77559: PUSH
77560: LD_INT 1
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 5
77569: NEG
77570: PUSH
77571: LD_INT 0
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 5
77580: NEG
77581: PUSH
77582: LD_INT 1
77584: NEG
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 5
77592: NEG
77593: PUSH
77594: LD_INT 2
77596: NEG
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 3
77604: NEG
77605: PUSH
77606: LD_INT 2
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: LD_INT 3
77615: NEG
77616: PUSH
77617: LD_INT 3
77619: NEG
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 3
77627: NEG
77628: PUSH
77629: LD_INT 4
77631: NEG
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 2
77639: NEG
77640: PUSH
77641: LD_INT 3
77643: NEG
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 2
77651: NEG
77652: PUSH
77653: LD_INT 2
77655: NEG
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 3
77663: NEG
77664: PUSH
77665: LD_INT 2
77667: NEG
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 4
77675: NEG
77676: PUSH
77677: LD_INT 3
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 4
77687: NEG
77688: PUSH
77689: LD_INT 4
77691: NEG
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: LD_INT 4
77703: NEG
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 4
77711: NEG
77712: PUSH
77713: LD_INT 2
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 0
77723: PUSH
77724: LD_INT 4
77726: NEG
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 0
77734: PUSH
77735: LD_INT 5
77737: NEG
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 1
77745: PUSH
77746: LD_INT 4
77748: NEG
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 1
77756: PUSH
77757: LD_INT 3
77759: NEG
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 0
77767: PUSH
77768: LD_INT 3
77770: NEG
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 1
77778: NEG
77779: PUSH
77780: LD_INT 4
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 1
77790: NEG
77791: PUSH
77792: LD_INT 5
77794: NEG
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 2
77802: PUSH
77803: LD_INT 3
77805: NEG
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: LD_INT 5
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: LIST
77861: LIST
77862: LIST
77863: LIST
77864: LIST
77865: LIST
77866: LIST
77867: LIST
77868: LIST
77869: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77870: LD_ADDR_VAR 0 31
77874: PUSH
77875: LD_INT 0
77877: PUSH
77878: LD_INT 4
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 0
77887: PUSH
77888: LD_INT 3
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 4
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 1
77907: PUSH
77908: LD_INT 5
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 0
77917: PUSH
77918: LD_INT 5
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 1
77927: NEG
77928: PUSH
77929: LD_INT 4
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 1
77938: NEG
77939: PUSH
77940: LD_INT 3
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 2
77949: PUSH
77950: LD_INT 5
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 2
77959: NEG
77960: PUSH
77961: LD_INT 3
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 3
77970: NEG
77971: PUSH
77972: LD_INT 0
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 3
77981: NEG
77982: PUSH
77983: LD_INT 1
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 2
77993: NEG
77994: PUSH
77995: LD_INT 0
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: PUSH
78002: LD_INT 2
78004: NEG
78005: PUSH
78006: LD_INT 1
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 3
78015: NEG
78016: PUSH
78017: LD_INT 1
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PUSH
78024: LD_INT 4
78026: NEG
78027: PUSH
78028: LD_INT 0
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: LD_INT 4
78037: NEG
78038: PUSH
78039: LD_INT 1
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 4
78049: NEG
78050: PUSH
78051: LD_INT 2
78053: NEG
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 2
78061: NEG
78062: PUSH
78063: LD_INT 2
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 4
78072: NEG
78073: PUSH
78074: LD_INT 4
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 4
78084: NEG
78085: PUSH
78086: LD_INT 5
78088: NEG
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 3
78096: NEG
78097: PUSH
78098: LD_INT 4
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 3
78108: NEG
78109: PUSH
78110: LD_INT 3
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 4
78120: NEG
78121: PUSH
78122: LD_INT 3
78124: NEG
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 5
78132: NEG
78133: PUSH
78134: LD_INT 4
78136: NEG
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 5
78144: NEG
78145: PUSH
78146: LD_INT 5
78148: NEG
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 3
78156: NEG
78157: PUSH
78158: LD_INT 5
78160: NEG
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 5
78168: NEG
78169: PUSH
78170: LD_INT 3
78172: NEG
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PUSH
78178: LD_INT 0
78180: PUSH
78181: LD_INT 3
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 0
78191: PUSH
78192: LD_INT 4
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 1
78202: PUSH
78203: LD_INT 3
78205: NEG
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 1
78213: PUSH
78214: LD_INT 2
78216: NEG
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 0
78224: PUSH
78225: LD_INT 2
78227: NEG
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: LD_INT 1
78235: NEG
78236: PUSH
78237: LD_INT 3
78239: NEG
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 1
78247: NEG
78248: PUSH
78249: LD_INT 4
78251: NEG
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 2
78259: PUSH
78260: LD_INT 2
78262: NEG
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 2
78270: NEG
78271: PUSH
78272: LD_INT 4
78274: NEG
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 4
78282: PUSH
78283: LD_INT 0
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 4
78292: PUSH
78293: LD_INT 1
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 5
78303: PUSH
78304: LD_INT 0
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 5
78313: PUSH
78314: LD_INT 1
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 4
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 3
78333: PUSH
78334: LD_INT 0
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 3
78343: PUSH
78344: LD_INT 1
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 3
78354: PUSH
78355: LD_INT 2
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 5
78365: PUSH
78366: LD_INT 2
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: LIST
78390: LIST
78391: LIST
78392: LIST
78393: LIST
78394: LIST
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78420: LD_ADDR_VAR 0 32
78424: PUSH
78425: LD_INT 4
78427: NEG
78428: PUSH
78429: LD_INT 0
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 4
78438: NEG
78439: PUSH
78440: LD_INT 1
78442: NEG
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 3
78450: NEG
78451: PUSH
78452: LD_INT 0
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: PUSH
78459: LD_INT 3
78461: NEG
78462: PUSH
78463: LD_INT 1
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 4
78472: NEG
78473: PUSH
78474: LD_INT 1
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 5
78483: NEG
78484: PUSH
78485: LD_INT 0
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 5
78494: NEG
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 5
78506: NEG
78507: PUSH
78508: LD_INT 2
78510: NEG
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 3
78518: NEG
78519: PUSH
78520: LD_INT 2
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 3
78529: NEG
78530: PUSH
78531: LD_INT 3
78533: NEG
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 3
78541: NEG
78542: PUSH
78543: LD_INT 4
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 2
78553: NEG
78554: PUSH
78555: LD_INT 3
78557: NEG
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 2
78565: NEG
78566: PUSH
78567: LD_INT 2
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 3
78577: NEG
78578: PUSH
78579: LD_INT 2
78581: NEG
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 4
78589: NEG
78590: PUSH
78591: LD_INT 3
78593: NEG
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 4
78601: NEG
78602: PUSH
78603: LD_INT 4
78605: NEG
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 2
78613: NEG
78614: PUSH
78615: LD_INT 4
78617: NEG
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 4
78625: NEG
78626: PUSH
78627: LD_INT 2
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 0
78637: PUSH
78638: LD_INT 4
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 0
78648: PUSH
78649: LD_INT 5
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 1
78659: PUSH
78660: LD_INT 4
78662: NEG
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 1
78670: PUSH
78671: LD_INT 3
78673: NEG
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: LD_INT 3
78684: NEG
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: LD_INT 4
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: LD_INT 5
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 2
78716: PUSH
78717: LD_INT 3
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 2
78727: NEG
78728: PUSH
78729: LD_INT 5
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 3
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 3
78749: PUSH
78750: LD_INT 1
78752: NEG
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 4
78760: PUSH
78761: LD_INT 0
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 4
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 2
78790: PUSH
78791: LD_INT 0
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: LD_INT 1
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 2
78811: PUSH
78812: LD_INT 2
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 4
78822: PUSH
78823: LD_INT 2
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 4
78832: PUSH
78833: LD_INT 4
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 4
78842: PUSH
78843: LD_INT 3
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 5
78852: PUSH
78853: LD_INT 4
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 5
78862: PUSH
78863: LD_INT 5
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 4
78872: PUSH
78873: LD_INT 5
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 3
78882: PUSH
78883: LD_INT 4
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 3
78892: PUSH
78893: LD_INT 3
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 5
78902: PUSH
78903: LD_INT 3
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: PUSH
78913: LD_INT 5
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: LIST
78946: LIST
78947: LIST
78948: LIST
78949: LIST
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78967: LD_ADDR_VAR 0 33
78971: PUSH
78972: LD_INT 4
78974: NEG
78975: PUSH
78976: LD_INT 4
78978: NEG
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 4
78986: NEG
78987: PUSH
78988: LD_INT 5
78990: NEG
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 3
78998: NEG
78999: PUSH
79000: LD_INT 4
79002: NEG
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 3
79010: NEG
79011: PUSH
79012: LD_INT 3
79014: NEG
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 4
79022: NEG
79023: PUSH
79024: LD_INT 3
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 5
79034: NEG
79035: PUSH
79036: LD_INT 4
79038: NEG
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 5
79046: NEG
79047: PUSH
79048: LD_INT 5
79050: NEG
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: LD_INT 3
79058: NEG
79059: PUSH
79060: LD_INT 5
79062: NEG
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 5
79070: NEG
79071: PUSH
79072: LD_INT 3
79074: NEG
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: LD_INT 3
79085: NEG
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 0
79093: PUSH
79094: LD_INT 4
79096: NEG
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 1
79104: PUSH
79105: LD_INT 3
79107: NEG
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 1
79115: PUSH
79116: LD_INT 2
79118: NEG
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: LD_INT 2
79129: NEG
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: NEG
79138: PUSH
79139: LD_INT 3
79141: NEG
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 1
79149: NEG
79150: PUSH
79151: LD_INT 4
79153: NEG
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 2
79161: PUSH
79162: LD_INT 2
79164: NEG
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 2
79172: NEG
79173: PUSH
79174: LD_INT 4
79176: NEG
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 4
79184: PUSH
79185: LD_INT 0
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 4
79194: PUSH
79195: LD_INT 1
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 5
79205: PUSH
79206: LD_INT 0
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 5
79215: PUSH
79216: LD_INT 1
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 4
79225: PUSH
79226: LD_INT 1
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 3
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 3
79245: PUSH
79246: LD_INT 1
79248: NEG
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 3
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 5
79267: PUSH
79268: LD_INT 2
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 3
79277: PUSH
79278: LD_INT 3
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 3
79287: PUSH
79288: LD_INT 2
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 4
79297: PUSH
79298: LD_INT 3
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 4
79307: PUSH
79308: LD_INT 4
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 3
79317: PUSH
79318: LD_INT 4
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 2
79327: PUSH
79328: LD_INT 3
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 2
79337: PUSH
79338: LD_INT 2
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 4
79347: PUSH
79348: LD_INT 2
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 2
79357: PUSH
79358: LD_INT 4
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 0
79367: PUSH
79368: LD_INT 4
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 0
79377: PUSH
79378: LD_INT 3
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 1
79387: PUSH
79388: LD_INT 4
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 1
79397: PUSH
79398: LD_INT 5
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 0
79407: PUSH
79408: LD_INT 5
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: NEG
79418: PUSH
79419: LD_INT 4
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 1
79428: NEG
79429: PUSH
79430: LD_INT 3
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 2
79439: PUSH
79440: LD_INT 5
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 2
79449: NEG
79450: PUSH
79451: LD_INT 3
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79505: LD_ADDR_VAR 0 34
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: LD_INT 4
79515: NEG
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 0
79523: PUSH
79524: LD_INT 5
79526: NEG
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: LD_INT 4
79537: NEG
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 1
79545: PUSH
79546: LD_INT 3
79548: NEG
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: LD_INT 3
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 1
79567: NEG
79568: PUSH
79569: LD_INT 4
79571: NEG
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 1
79579: NEG
79580: PUSH
79581: LD_INT 5
79583: NEG
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: PUSH
79592: LD_INT 3
79594: NEG
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 2
79602: NEG
79603: PUSH
79604: LD_INT 5
79606: NEG
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 3
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 3
79624: PUSH
79625: LD_INT 1
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 4
79635: PUSH
79636: LD_INT 0
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 4
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 3
79655: PUSH
79656: LD_INT 1
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 2
79665: PUSH
79666: LD_INT 0
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 2
79675: PUSH
79676: LD_INT 1
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 2
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 4
79697: PUSH
79698: LD_INT 2
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 4
79707: PUSH
79708: LD_INT 4
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 4
79717: PUSH
79718: LD_INT 3
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: LD_INT 5
79727: PUSH
79728: LD_INT 4
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 5
79737: PUSH
79738: LD_INT 5
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 4
79747: PUSH
79748: LD_INT 5
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 3
79757: PUSH
79758: LD_INT 4
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 3
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 5
79777: PUSH
79778: LD_INT 3
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 3
79787: PUSH
79788: LD_INT 5
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 0
79797: PUSH
79798: LD_INT 3
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 0
79807: PUSH
79808: LD_INT 2
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 1
79817: PUSH
79818: LD_INT 3
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 1
79827: PUSH
79828: LD_INT 4
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 0
79837: PUSH
79838: LD_INT 4
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 1
79847: NEG
79848: PUSH
79849: LD_INT 3
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: LD_INT 4
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PUSH
79877: LD_INT 2
79879: NEG
79880: PUSH
79881: LD_INT 2
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 4
79890: NEG
79891: PUSH
79892: LD_INT 0
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: LD_INT 4
79901: NEG
79902: PUSH
79903: LD_INT 1
79905: NEG
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 3
79913: NEG
79914: PUSH
79915: LD_INT 0
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 3
79924: NEG
79925: PUSH
79926: LD_INT 1
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 4
79935: NEG
79936: PUSH
79937: LD_INT 1
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 5
79946: NEG
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 5
79957: NEG
79958: PUSH
79959: LD_INT 1
79961: NEG
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 5
79969: NEG
79970: PUSH
79971: LD_INT 2
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 3
79981: NEG
79982: PUSH
79983: LD_INT 2
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: ST_TO_ADDR
// end ; end ;
80037: GO 80040
80039: POP
// case btype of b_depot , b_warehouse :
80040: LD_VAR 0 1
80044: PUSH
80045: LD_INT 0
80047: DOUBLE
80048: EQUAL
80049: IFTRUE 80059
80051: LD_INT 1
80053: DOUBLE
80054: EQUAL
80055: IFTRUE 80059
80057: GO 80260
80059: POP
// case nation of nation_american :
80060: LD_VAR 0 5
80064: PUSH
80065: LD_INT 1
80067: DOUBLE
80068: EQUAL
80069: IFTRUE 80073
80071: GO 80129
80073: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80074: LD_ADDR_VAR 0 9
80078: PUSH
80079: LD_VAR 0 11
80083: PUSH
80084: LD_VAR 0 12
80088: PUSH
80089: LD_VAR 0 13
80093: PUSH
80094: LD_VAR 0 14
80098: PUSH
80099: LD_VAR 0 15
80103: PUSH
80104: LD_VAR 0 16
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: PUSH
80117: LD_VAR 0 4
80121: PUSH
80122: LD_INT 1
80124: PLUS
80125: ARRAY
80126: ST_TO_ADDR
80127: GO 80258
80129: LD_INT 2
80131: DOUBLE
80132: EQUAL
80133: IFTRUE 80137
80135: GO 80193
80137: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80138: LD_ADDR_VAR 0 9
80142: PUSH
80143: LD_VAR 0 17
80147: PUSH
80148: LD_VAR 0 18
80152: PUSH
80153: LD_VAR 0 19
80157: PUSH
80158: LD_VAR 0 20
80162: PUSH
80163: LD_VAR 0 21
80167: PUSH
80168: LD_VAR 0 22
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: PUSH
80181: LD_VAR 0 4
80185: PUSH
80186: LD_INT 1
80188: PLUS
80189: ARRAY
80190: ST_TO_ADDR
80191: GO 80258
80193: LD_INT 3
80195: DOUBLE
80196: EQUAL
80197: IFTRUE 80201
80199: GO 80257
80201: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80202: LD_ADDR_VAR 0 9
80206: PUSH
80207: LD_VAR 0 23
80211: PUSH
80212: LD_VAR 0 24
80216: PUSH
80217: LD_VAR 0 25
80221: PUSH
80222: LD_VAR 0 26
80226: PUSH
80227: LD_VAR 0 27
80231: PUSH
80232: LD_VAR 0 28
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: PUSH
80245: LD_VAR 0 4
80249: PUSH
80250: LD_INT 1
80252: PLUS
80253: ARRAY
80254: ST_TO_ADDR
80255: GO 80258
80257: POP
80258: GO 80813
80260: LD_INT 2
80262: DOUBLE
80263: EQUAL
80264: IFTRUE 80274
80266: LD_INT 3
80268: DOUBLE
80269: EQUAL
80270: IFTRUE 80274
80272: GO 80330
80274: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80275: LD_ADDR_VAR 0 9
80279: PUSH
80280: LD_VAR 0 29
80284: PUSH
80285: LD_VAR 0 30
80289: PUSH
80290: LD_VAR 0 31
80294: PUSH
80295: LD_VAR 0 32
80299: PUSH
80300: LD_VAR 0 33
80304: PUSH
80305: LD_VAR 0 34
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: PUSH
80318: LD_VAR 0 4
80322: PUSH
80323: LD_INT 1
80325: PLUS
80326: ARRAY
80327: ST_TO_ADDR
80328: GO 80813
80330: LD_INT 16
80332: DOUBLE
80333: EQUAL
80334: IFTRUE 80392
80336: LD_INT 17
80338: DOUBLE
80339: EQUAL
80340: IFTRUE 80392
80342: LD_INT 18
80344: DOUBLE
80345: EQUAL
80346: IFTRUE 80392
80348: LD_INT 19
80350: DOUBLE
80351: EQUAL
80352: IFTRUE 80392
80354: LD_INT 22
80356: DOUBLE
80357: EQUAL
80358: IFTRUE 80392
80360: LD_INT 20
80362: DOUBLE
80363: EQUAL
80364: IFTRUE 80392
80366: LD_INT 21
80368: DOUBLE
80369: EQUAL
80370: IFTRUE 80392
80372: LD_INT 23
80374: DOUBLE
80375: EQUAL
80376: IFTRUE 80392
80378: LD_INT 24
80380: DOUBLE
80381: EQUAL
80382: IFTRUE 80392
80384: LD_INT 25
80386: DOUBLE
80387: EQUAL
80388: IFTRUE 80392
80390: GO 80448
80392: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80393: LD_ADDR_VAR 0 9
80397: PUSH
80398: LD_VAR 0 35
80402: PUSH
80403: LD_VAR 0 36
80407: PUSH
80408: LD_VAR 0 37
80412: PUSH
80413: LD_VAR 0 38
80417: PUSH
80418: LD_VAR 0 39
80422: PUSH
80423: LD_VAR 0 40
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: PUSH
80436: LD_VAR 0 4
80440: PUSH
80441: LD_INT 1
80443: PLUS
80444: ARRAY
80445: ST_TO_ADDR
80446: GO 80813
80448: LD_INT 6
80450: DOUBLE
80451: EQUAL
80452: IFTRUE 80504
80454: LD_INT 7
80456: DOUBLE
80457: EQUAL
80458: IFTRUE 80504
80460: LD_INT 8
80462: DOUBLE
80463: EQUAL
80464: IFTRUE 80504
80466: LD_INT 13
80468: DOUBLE
80469: EQUAL
80470: IFTRUE 80504
80472: LD_INT 12
80474: DOUBLE
80475: EQUAL
80476: IFTRUE 80504
80478: LD_INT 15
80480: DOUBLE
80481: EQUAL
80482: IFTRUE 80504
80484: LD_INT 11
80486: DOUBLE
80487: EQUAL
80488: IFTRUE 80504
80490: LD_INT 14
80492: DOUBLE
80493: EQUAL
80494: IFTRUE 80504
80496: LD_INT 10
80498: DOUBLE
80499: EQUAL
80500: IFTRUE 80504
80502: GO 80560
80504: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80505: LD_ADDR_VAR 0 9
80509: PUSH
80510: LD_VAR 0 41
80514: PUSH
80515: LD_VAR 0 42
80519: PUSH
80520: LD_VAR 0 43
80524: PUSH
80525: LD_VAR 0 44
80529: PUSH
80530: LD_VAR 0 45
80534: PUSH
80535: LD_VAR 0 46
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: PUSH
80548: LD_VAR 0 4
80552: PUSH
80553: LD_INT 1
80555: PLUS
80556: ARRAY
80557: ST_TO_ADDR
80558: GO 80813
80560: LD_INT 36
80562: DOUBLE
80563: EQUAL
80564: IFTRUE 80568
80566: GO 80624
80568: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80569: LD_ADDR_VAR 0 9
80573: PUSH
80574: LD_VAR 0 47
80578: PUSH
80579: LD_VAR 0 48
80583: PUSH
80584: LD_VAR 0 49
80588: PUSH
80589: LD_VAR 0 50
80593: PUSH
80594: LD_VAR 0 51
80598: PUSH
80599: LD_VAR 0 52
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: PUSH
80612: LD_VAR 0 4
80616: PUSH
80617: LD_INT 1
80619: PLUS
80620: ARRAY
80621: ST_TO_ADDR
80622: GO 80813
80624: LD_INT 4
80626: DOUBLE
80627: EQUAL
80628: IFTRUE 80650
80630: LD_INT 5
80632: DOUBLE
80633: EQUAL
80634: IFTRUE 80650
80636: LD_INT 34
80638: DOUBLE
80639: EQUAL
80640: IFTRUE 80650
80642: LD_INT 37
80644: DOUBLE
80645: EQUAL
80646: IFTRUE 80650
80648: GO 80706
80650: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80651: LD_ADDR_VAR 0 9
80655: PUSH
80656: LD_VAR 0 53
80660: PUSH
80661: LD_VAR 0 54
80665: PUSH
80666: LD_VAR 0 55
80670: PUSH
80671: LD_VAR 0 56
80675: PUSH
80676: LD_VAR 0 57
80680: PUSH
80681: LD_VAR 0 58
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: PUSH
80694: LD_VAR 0 4
80698: PUSH
80699: LD_INT 1
80701: PLUS
80702: ARRAY
80703: ST_TO_ADDR
80704: GO 80813
80706: LD_INT 31
80708: DOUBLE
80709: EQUAL
80710: IFTRUE 80756
80712: LD_INT 32
80714: DOUBLE
80715: EQUAL
80716: IFTRUE 80756
80718: LD_INT 33
80720: DOUBLE
80721: EQUAL
80722: IFTRUE 80756
80724: LD_INT 27
80726: DOUBLE
80727: EQUAL
80728: IFTRUE 80756
80730: LD_INT 26
80732: DOUBLE
80733: EQUAL
80734: IFTRUE 80756
80736: LD_INT 28
80738: DOUBLE
80739: EQUAL
80740: IFTRUE 80756
80742: LD_INT 29
80744: DOUBLE
80745: EQUAL
80746: IFTRUE 80756
80748: LD_INT 30
80750: DOUBLE
80751: EQUAL
80752: IFTRUE 80756
80754: GO 80812
80756: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
80757: LD_ADDR_VAR 0 9
80761: PUSH
80762: LD_VAR 0 59
80766: PUSH
80767: LD_VAR 0 60
80771: PUSH
80772: LD_VAR 0 61
80776: PUSH
80777: LD_VAR 0 62
80781: PUSH
80782: LD_VAR 0 63
80786: PUSH
80787: LD_VAR 0 64
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: PUSH
80800: LD_VAR 0 4
80804: PUSH
80805: LD_INT 1
80807: PLUS
80808: ARRAY
80809: ST_TO_ADDR
80810: GO 80813
80812: POP
// temp_list2 = [ ] ;
80813: LD_ADDR_VAR 0 10
80817: PUSH
80818: EMPTY
80819: ST_TO_ADDR
// for i in temp_list do
80820: LD_ADDR_VAR 0 8
80824: PUSH
80825: LD_VAR 0 9
80829: PUSH
80830: FOR_IN
80831: IFFALSE 80883
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80833: LD_ADDR_VAR 0 10
80837: PUSH
80838: LD_VAR 0 10
80842: PUSH
80843: LD_VAR 0 8
80847: PUSH
80848: LD_INT 1
80850: ARRAY
80851: PUSH
80852: LD_VAR 0 2
80856: PLUS
80857: PUSH
80858: LD_VAR 0 8
80862: PUSH
80863: LD_INT 2
80865: ARRAY
80866: PUSH
80867: LD_VAR 0 3
80871: PLUS
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: EMPTY
80878: LIST
80879: ADD
80880: ST_TO_ADDR
80881: GO 80830
80883: POP
80884: POP
// result = temp_list2 ;
80885: LD_ADDR_VAR 0 7
80889: PUSH
80890: LD_VAR 0 10
80894: ST_TO_ADDR
// end ;
80895: LD_VAR 0 7
80899: RET
// export function EnemyInRange ( unit , dist ) ; begin
80900: LD_INT 0
80902: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80903: LD_ADDR_VAR 0 3
80907: PUSH
80908: LD_VAR 0 1
80912: PPUSH
80913: CALL_OW 255
80917: PPUSH
80918: LD_VAR 0 1
80922: PPUSH
80923: CALL_OW 250
80927: PPUSH
80928: LD_VAR 0 1
80932: PPUSH
80933: CALL_OW 251
80937: PPUSH
80938: LD_VAR 0 2
80942: PPUSH
80943: CALL 55004 0 4
80947: PUSH
80948: LD_INT 4
80950: ARRAY
80951: ST_TO_ADDR
// end ;
80952: LD_VAR 0 3
80956: RET
// export function PlayerSeeMe ( unit ) ; begin
80957: LD_INT 0
80959: PPUSH
// result := See ( your_side , unit ) ;
80960: LD_ADDR_VAR 0 2
80964: PUSH
80965: LD_OWVAR 2
80969: PPUSH
80970: LD_VAR 0 1
80974: PPUSH
80975: CALL_OW 292
80979: ST_TO_ADDR
// end ;
80980: LD_VAR 0 2
80984: RET
// export function ReverseDir ( unit ) ; begin
80985: LD_INT 0
80987: PPUSH
// if not unit then
80988: LD_VAR 0 1
80992: NOT
80993: IFFALSE 80997
// exit ;
80995: GO 81043
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
80997: LD_ADDR_VAR 0 2
81001: PUSH
81002: LD_INT 3
81004: PUSH
81005: LD_INT 4
81007: PUSH
81008: LD_INT 5
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: LD_INT 1
81016: PUSH
81017: LD_INT 2
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: PUSH
81028: LD_VAR 0 1
81032: PPUSH
81033: CALL_OW 254
81037: PUSH
81038: LD_INT 1
81040: PLUS
81041: ARRAY
81042: ST_TO_ADDR
// end ;
81043: LD_VAR 0 2
81047: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81048: LD_INT 0
81050: PPUSH
81051: PPUSH
81052: PPUSH
81053: PPUSH
81054: PPUSH
// if not hexes then
81055: LD_VAR 0 2
81059: NOT
81060: IFFALSE 81064
// exit ;
81062: GO 81212
// dist := 9999 ;
81064: LD_ADDR_VAR 0 5
81068: PUSH
81069: LD_INT 9999
81071: ST_TO_ADDR
// for i = 1 to hexes do
81072: LD_ADDR_VAR 0 4
81076: PUSH
81077: DOUBLE
81078: LD_INT 1
81080: DEC
81081: ST_TO_ADDR
81082: LD_VAR 0 2
81086: PUSH
81087: FOR_TO
81088: IFFALSE 81200
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81090: LD_VAR 0 1
81094: PPUSH
81095: LD_VAR 0 2
81099: PUSH
81100: LD_VAR 0 4
81104: ARRAY
81105: PUSH
81106: LD_INT 1
81108: ARRAY
81109: PPUSH
81110: LD_VAR 0 2
81114: PUSH
81115: LD_VAR 0 4
81119: ARRAY
81120: PUSH
81121: LD_INT 2
81123: ARRAY
81124: PPUSH
81125: CALL_OW 297
81129: PUSH
81130: LD_VAR 0 5
81134: LESS
81135: IFFALSE 81198
// begin hex := hexes [ i ] ;
81137: LD_ADDR_VAR 0 7
81141: PUSH
81142: LD_VAR 0 2
81146: PUSH
81147: LD_VAR 0 4
81151: ARRAY
81152: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81153: LD_ADDR_VAR 0 5
81157: PUSH
81158: LD_VAR 0 1
81162: PPUSH
81163: LD_VAR 0 2
81167: PUSH
81168: LD_VAR 0 4
81172: ARRAY
81173: PUSH
81174: LD_INT 1
81176: ARRAY
81177: PPUSH
81178: LD_VAR 0 2
81182: PUSH
81183: LD_VAR 0 4
81187: ARRAY
81188: PUSH
81189: LD_INT 2
81191: ARRAY
81192: PPUSH
81193: CALL_OW 297
81197: ST_TO_ADDR
// end ; end ;
81198: GO 81087
81200: POP
81201: POP
// result := hex ;
81202: LD_ADDR_VAR 0 3
81206: PUSH
81207: LD_VAR 0 7
81211: ST_TO_ADDR
// end ;
81212: LD_VAR 0 3
81216: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81217: LD_INT 0
81219: PPUSH
81220: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81221: LD_VAR 0 1
81225: NOT
81226: PUSH
81227: LD_VAR 0 1
81231: PUSH
81232: LD_INT 21
81234: PUSH
81235: LD_INT 2
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 23
81244: PUSH
81245: LD_INT 2
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PPUSH
81256: CALL_OW 69
81260: IN
81261: NOT
81262: OR
81263: IFFALSE 81267
// exit ;
81265: GO 81314
// for i = 1 to 3 do
81267: LD_ADDR_VAR 0 3
81271: PUSH
81272: DOUBLE
81273: LD_INT 1
81275: DEC
81276: ST_TO_ADDR
81277: LD_INT 3
81279: PUSH
81280: FOR_TO
81281: IFFALSE 81312
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81283: LD_VAR 0 1
81287: PPUSH
81288: CALL_OW 250
81292: PPUSH
81293: LD_VAR 0 1
81297: PPUSH
81298: CALL_OW 251
81302: PPUSH
81303: LD_INT 1
81305: PPUSH
81306: CALL_OW 453
81310: GO 81280
81312: POP
81313: POP
// end ;
81314: LD_VAR 0 2
81318: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81319: LD_INT 0
81321: PPUSH
81322: PPUSH
81323: PPUSH
81324: PPUSH
81325: PPUSH
81326: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81327: LD_VAR 0 1
81331: NOT
81332: PUSH
81333: LD_VAR 0 2
81337: NOT
81338: OR
81339: PUSH
81340: LD_VAR 0 1
81344: PPUSH
81345: CALL_OW 314
81349: OR
81350: IFFALSE 81354
// exit ;
81352: GO 81795
// x := GetX ( enemy_unit ) ;
81354: LD_ADDR_VAR 0 7
81358: PUSH
81359: LD_VAR 0 2
81363: PPUSH
81364: CALL_OW 250
81368: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81369: LD_ADDR_VAR 0 8
81373: PUSH
81374: LD_VAR 0 2
81378: PPUSH
81379: CALL_OW 251
81383: ST_TO_ADDR
// if not x or not y then
81384: LD_VAR 0 7
81388: NOT
81389: PUSH
81390: LD_VAR 0 8
81394: NOT
81395: OR
81396: IFFALSE 81400
// exit ;
81398: GO 81795
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81400: LD_ADDR_VAR 0 6
81404: PUSH
81405: LD_VAR 0 7
81409: PPUSH
81410: LD_INT 0
81412: PPUSH
81413: LD_INT 4
81415: PPUSH
81416: CALL_OW 272
81420: PUSH
81421: LD_VAR 0 8
81425: PPUSH
81426: LD_INT 0
81428: PPUSH
81429: LD_INT 4
81431: PPUSH
81432: CALL_OW 273
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_VAR 0 7
81445: PPUSH
81446: LD_INT 1
81448: PPUSH
81449: LD_INT 4
81451: PPUSH
81452: CALL_OW 272
81456: PUSH
81457: LD_VAR 0 8
81461: PPUSH
81462: LD_INT 1
81464: PPUSH
81465: LD_INT 4
81467: PPUSH
81468: CALL_OW 273
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_VAR 0 7
81481: PPUSH
81482: LD_INT 2
81484: PPUSH
81485: LD_INT 4
81487: PPUSH
81488: CALL_OW 272
81492: PUSH
81493: LD_VAR 0 8
81497: PPUSH
81498: LD_INT 2
81500: PPUSH
81501: LD_INT 4
81503: PPUSH
81504: CALL_OW 273
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_VAR 0 7
81517: PPUSH
81518: LD_INT 3
81520: PPUSH
81521: LD_INT 4
81523: PPUSH
81524: CALL_OW 272
81528: PUSH
81529: LD_VAR 0 8
81533: PPUSH
81534: LD_INT 3
81536: PPUSH
81537: LD_INT 4
81539: PPUSH
81540: CALL_OW 273
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_VAR 0 7
81553: PPUSH
81554: LD_INT 4
81556: PPUSH
81557: LD_INT 4
81559: PPUSH
81560: CALL_OW 272
81564: PUSH
81565: LD_VAR 0 8
81569: PPUSH
81570: LD_INT 4
81572: PPUSH
81573: LD_INT 4
81575: PPUSH
81576: CALL_OW 273
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_VAR 0 7
81589: PPUSH
81590: LD_INT 5
81592: PPUSH
81593: LD_INT 4
81595: PPUSH
81596: CALL_OW 272
81600: PUSH
81601: LD_VAR 0 8
81605: PPUSH
81606: LD_INT 5
81608: PPUSH
81609: LD_INT 4
81611: PPUSH
81612: CALL_OW 273
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: ST_TO_ADDR
// for i = tmp downto 1 do
81629: LD_ADDR_VAR 0 4
81633: PUSH
81634: DOUBLE
81635: LD_VAR 0 6
81639: INC
81640: ST_TO_ADDR
81641: LD_INT 1
81643: PUSH
81644: FOR_DOWNTO
81645: IFFALSE 81746
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81647: LD_VAR 0 6
81651: PUSH
81652: LD_VAR 0 4
81656: ARRAY
81657: PUSH
81658: LD_INT 1
81660: ARRAY
81661: PPUSH
81662: LD_VAR 0 6
81666: PUSH
81667: LD_VAR 0 4
81671: ARRAY
81672: PUSH
81673: LD_INT 2
81675: ARRAY
81676: PPUSH
81677: CALL_OW 488
81681: NOT
81682: PUSH
81683: LD_VAR 0 6
81687: PUSH
81688: LD_VAR 0 4
81692: ARRAY
81693: PUSH
81694: LD_INT 1
81696: ARRAY
81697: PPUSH
81698: LD_VAR 0 6
81702: PUSH
81703: LD_VAR 0 4
81707: ARRAY
81708: PUSH
81709: LD_INT 2
81711: ARRAY
81712: PPUSH
81713: CALL_OW 428
81717: PUSH
81718: LD_INT 0
81720: NONEQUAL
81721: OR
81722: IFFALSE 81744
// tmp := Delete ( tmp , i ) ;
81724: LD_ADDR_VAR 0 6
81728: PUSH
81729: LD_VAR 0 6
81733: PPUSH
81734: LD_VAR 0 4
81738: PPUSH
81739: CALL_OW 3
81743: ST_TO_ADDR
81744: GO 81644
81746: POP
81747: POP
// j := GetClosestHex ( unit , tmp ) ;
81748: LD_ADDR_VAR 0 5
81752: PUSH
81753: LD_VAR 0 1
81757: PPUSH
81758: LD_VAR 0 6
81762: PPUSH
81763: CALL 81048 0 2
81767: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81768: LD_VAR 0 1
81772: PPUSH
81773: LD_VAR 0 5
81777: PUSH
81778: LD_INT 1
81780: ARRAY
81781: PPUSH
81782: LD_VAR 0 5
81786: PUSH
81787: LD_INT 2
81789: ARRAY
81790: PPUSH
81791: CALL_OW 111
// end ;
81795: LD_VAR 0 3
81799: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81800: LD_INT 0
81802: PPUSH
81803: PPUSH
81804: PPUSH
// uc_side = 0 ;
81805: LD_ADDR_OWVAR 20
81809: PUSH
81810: LD_INT 0
81812: ST_TO_ADDR
// uc_nation = 0 ;
81813: LD_ADDR_OWVAR 21
81817: PUSH
81818: LD_INT 0
81820: ST_TO_ADDR
// InitHc ;
81821: CALL_OW 19
// InitVc ;
81825: CALL_OW 20
// if mastodonts then
81829: LD_VAR 0 6
81833: IFFALSE 81900
// for i = 1 to mastodonts do
81835: LD_ADDR_VAR 0 11
81839: PUSH
81840: DOUBLE
81841: LD_INT 1
81843: DEC
81844: ST_TO_ADDR
81845: LD_VAR 0 6
81849: PUSH
81850: FOR_TO
81851: IFFALSE 81898
// begin vc_chassis := 31 ;
81853: LD_ADDR_OWVAR 37
81857: PUSH
81858: LD_INT 31
81860: ST_TO_ADDR
// vc_control := control_rider ;
81861: LD_ADDR_OWVAR 38
81865: PUSH
81866: LD_INT 4
81868: ST_TO_ADDR
// animal := CreateVehicle ;
81869: LD_ADDR_VAR 0 12
81873: PUSH
81874: CALL_OW 45
81878: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81879: LD_VAR 0 12
81883: PPUSH
81884: LD_VAR 0 8
81888: PPUSH
81889: LD_INT 0
81891: PPUSH
81892: CALL 88645 0 3
// end ;
81896: GO 81850
81898: POP
81899: POP
// if horses then
81900: LD_VAR 0 5
81904: IFFALSE 81971
// for i = 1 to horses do
81906: LD_ADDR_VAR 0 11
81910: PUSH
81911: DOUBLE
81912: LD_INT 1
81914: DEC
81915: ST_TO_ADDR
81916: LD_VAR 0 5
81920: PUSH
81921: FOR_TO
81922: IFFALSE 81969
// begin hc_class := 21 ;
81924: LD_ADDR_OWVAR 28
81928: PUSH
81929: LD_INT 21
81931: ST_TO_ADDR
// hc_gallery :=  ;
81932: LD_ADDR_OWVAR 33
81936: PUSH
81937: LD_STRING 
81939: ST_TO_ADDR
// animal := CreateHuman ;
81940: LD_ADDR_VAR 0 12
81944: PUSH
81945: CALL_OW 44
81949: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81950: LD_VAR 0 12
81954: PPUSH
81955: LD_VAR 0 8
81959: PPUSH
81960: LD_INT 0
81962: PPUSH
81963: CALL 88645 0 3
// end ;
81967: GO 81921
81969: POP
81970: POP
// if birds then
81971: LD_VAR 0 1
81975: IFFALSE 82042
// for i = 1 to birds do
81977: LD_ADDR_VAR 0 11
81981: PUSH
81982: DOUBLE
81983: LD_INT 1
81985: DEC
81986: ST_TO_ADDR
81987: LD_VAR 0 1
81991: PUSH
81992: FOR_TO
81993: IFFALSE 82040
// begin hc_class = 18 ;
81995: LD_ADDR_OWVAR 28
81999: PUSH
82000: LD_INT 18
82002: ST_TO_ADDR
// hc_gallery =  ;
82003: LD_ADDR_OWVAR 33
82007: PUSH
82008: LD_STRING 
82010: ST_TO_ADDR
// animal := CreateHuman ;
82011: LD_ADDR_VAR 0 12
82015: PUSH
82016: CALL_OW 44
82020: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82021: LD_VAR 0 12
82025: PPUSH
82026: LD_VAR 0 8
82030: PPUSH
82031: LD_INT 0
82033: PPUSH
82034: CALL 88645 0 3
// end ;
82038: GO 81992
82040: POP
82041: POP
// if tigers then
82042: LD_VAR 0 2
82046: IFFALSE 82130
// for i = 1 to tigers do
82048: LD_ADDR_VAR 0 11
82052: PUSH
82053: DOUBLE
82054: LD_INT 1
82056: DEC
82057: ST_TO_ADDR
82058: LD_VAR 0 2
82062: PUSH
82063: FOR_TO
82064: IFFALSE 82128
// begin hc_class = class_tiger ;
82066: LD_ADDR_OWVAR 28
82070: PUSH
82071: LD_INT 14
82073: ST_TO_ADDR
// hc_gallery =  ;
82074: LD_ADDR_OWVAR 33
82078: PUSH
82079: LD_STRING 
82081: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82082: LD_ADDR_OWVAR 35
82086: PUSH
82087: LD_INT 7
82089: NEG
82090: PPUSH
82091: LD_INT 7
82093: PPUSH
82094: CALL_OW 12
82098: ST_TO_ADDR
// animal := CreateHuman ;
82099: LD_ADDR_VAR 0 12
82103: PUSH
82104: CALL_OW 44
82108: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82109: LD_VAR 0 12
82113: PPUSH
82114: LD_VAR 0 8
82118: PPUSH
82119: LD_INT 0
82121: PPUSH
82122: CALL 88645 0 3
// end ;
82126: GO 82063
82128: POP
82129: POP
// if apemans then
82130: LD_VAR 0 3
82134: IFFALSE 82257
// for i = 1 to apemans do
82136: LD_ADDR_VAR 0 11
82140: PUSH
82141: DOUBLE
82142: LD_INT 1
82144: DEC
82145: ST_TO_ADDR
82146: LD_VAR 0 3
82150: PUSH
82151: FOR_TO
82152: IFFALSE 82255
// begin hc_class = class_apeman ;
82154: LD_ADDR_OWVAR 28
82158: PUSH
82159: LD_INT 12
82161: ST_TO_ADDR
// hc_gallery =  ;
82162: LD_ADDR_OWVAR 33
82166: PUSH
82167: LD_STRING 
82169: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82170: LD_ADDR_OWVAR 35
82174: PUSH
82175: LD_INT 5
82177: NEG
82178: PPUSH
82179: LD_INT 5
82181: PPUSH
82182: CALL_OW 12
82186: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82187: LD_ADDR_OWVAR 31
82191: PUSH
82192: LD_INT 1
82194: PPUSH
82195: LD_INT 3
82197: PPUSH
82198: CALL_OW 12
82202: PUSH
82203: LD_INT 1
82205: PPUSH
82206: LD_INT 3
82208: PPUSH
82209: CALL_OW 12
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: LD_INT 0
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: ST_TO_ADDR
// animal := CreateHuman ;
82226: LD_ADDR_VAR 0 12
82230: PUSH
82231: CALL_OW 44
82235: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82236: LD_VAR 0 12
82240: PPUSH
82241: LD_VAR 0 8
82245: PPUSH
82246: LD_INT 0
82248: PPUSH
82249: CALL 88645 0 3
// end ;
82253: GO 82151
82255: POP
82256: POP
// if enchidnas then
82257: LD_VAR 0 4
82261: IFFALSE 82328
// for i = 1 to enchidnas do
82263: LD_ADDR_VAR 0 11
82267: PUSH
82268: DOUBLE
82269: LD_INT 1
82271: DEC
82272: ST_TO_ADDR
82273: LD_VAR 0 4
82277: PUSH
82278: FOR_TO
82279: IFFALSE 82326
// begin hc_class = 13 ;
82281: LD_ADDR_OWVAR 28
82285: PUSH
82286: LD_INT 13
82288: ST_TO_ADDR
// hc_gallery =  ;
82289: LD_ADDR_OWVAR 33
82293: PUSH
82294: LD_STRING 
82296: ST_TO_ADDR
// animal := CreateHuman ;
82297: LD_ADDR_VAR 0 12
82301: PUSH
82302: CALL_OW 44
82306: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82307: LD_VAR 0 12
82311: PPUSH
82312: LD_VAR 0 8
82316: PPUSH
82317: LD_INT 0
82319: PPUSH
82320: CALL 88645 0 3
// end ;
82324: GO 82278
82326: POP
82327: POP
// if fishes then
82328: LD_VAR 0 7
82332: IFFALSE 82399
// for i = 1 to fishes do
82334: LD_ADDR_VAR 0 11
82338: PUSH
82339: DOUBLE
82340: LD_INT 1
82342: DEC
82343: ST_TO_ADDR
82344: LD_VAR 0 7
82348: PUSH
82349: FOR_TO
82350: IFFALSE 82397
// begin hc_class = 20 ;
82352: LD_ADDR_OWVAR 28
82356: PUSH
82357: LD_INT 20
82359: ST_TO_ADDR
// hc_gallery =  ;
82360: LD_ADDR_OWVAR 33
82364: PUSH
82365: LD_STRING 
82367: ST_TO_ADDR
// animal := CreateHuman ;
82368: LD_ADDR_VAR 0 12
82372: PUSH
82373: CALL_OW 44
82377: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82378: LD_VAR 0 12
82382: PPUSH
82383: LD_VAR 0 9
82387: PPUSH
82388: LD_INT 0
82390: PPUSH
82391: CALL 88645 0 3
// end ;
82395: GO 82349
82397: POP
82398: POP
// end ;
82399: LD_VAR 0 10
82403: RET
// export function WantHeal ( sci , unit ) ; begin
82404: LD_INT 0
82406: PPUSH
// if GetTaskList ( sci ) > 0 then
82407: LD_VAR 0 1
82411: PPUSH
82412: CALL_OW 437
82416: PUSH
82417: LD_INT 0
82419: GREATER
82420: IFFALSE 82490
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82422: LD_VAR 0 1
82426: PPUSH
82427: CALL_OW 437
82431: PUSH
82432: LD_INT 1
82434: ARRAY
82435: PUSH
82436: LD_INT 1
82438: ARRAY
82439: PUSH
82440: LD_STRING l
82442: EQUAL
82443: PUSH
82444: LD_VAR 0 1
82448: PPUSH
82449: CALL_OW 437
82453: PUSH
82454: LD_INT 1
82456: ARRAY
82457: PUSH
82458: LD_INT 4
82460: ARRAY
82461: PUSH
82462: LD_VAR 0 2
82466: EQUAL
82467: AND
82468: IFFALSE 82480
// result := true else
82470: LD_ADDR_VAR 0 3
82474: PUSH
82475: LD_INT 1
82477: ST_TO_ADDR
82478: GO 82488
// result := false ;
82480: LD_ADDR_VAR 0 3
82484: PUSH
82485: LD_INT 0
82487: ST_TO_ADDR
// end else
82488: GO 82498
// result := false ;
82490: LD_ADDR_VAR 0 3
82494: PUSH
82495: LD_INT 0
82497: ST_TO_ADDR
// end ;
82498: LD_VAR 0 3
82502: RET
// export function HealTarget ( sci ) ; begin
82503: LD_INT 0
82505: PPUSH
// if not sci then
82506: LD_VAR 0 1
82510: NOT
82511: IFFALSE 82515
// exit ;
82513: GO 82580
// result := 0 ;
82515: LD_ADDR_VAR 0 2
82519: PUSH
82520: LD_INT 0
82522: ST_TO_ADDR
// if GetTaskList ( sci ) then
82523: LD_VAR 0 1
82527: PPUSH
82528: CALL_OW 437
82532: IFFALSE 82580
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82534: LD_VAR 0 1
82538: PPUSH
82539: CALL_OW 437
82543: PUSH
82544: LD_INT 1
82546: ARRAY
82547: PUSH
82548: LD_INT 1
82550: ARRAY
82551: PUSH
82552: LD_STRING l
82554: EQUAL
82555: IFFALSE 82580
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82557: LD_ADDR_VAR 0 2
82561: PUSH
82562: LD_VAR 0 1
82566: PPUSH
82567: CALL_OW 437
82571: PUSH
82572: LD_INT 1
82574: ARRAY
82575: PUSH
82576: LD_INT 4
82578: ARRAY
82579: ST_TO_ADDR
// end ;
82580: LD_VAR 0 2
82584: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82585: LD_INT 0
82587: PPUSH
82588: PPUSH
82589: PPUSH
82590: PPUSH
82591: PPUSH
82592: PPUSH
82593: PPUSH
82594: PPUSH
82595: PPUSH
82596: PPUSH
82597: PPUSH
82598: PPUSH
82599: PPUSH
82600: PPUSH
82601: PPUSH
82602: PPUSH
82603: PPUSH
82604: PPUSH
82605: PPUSH
82606: PPUSH
82607: PPUSH
82608: PPUSH
82609: PPUSH
82610: PPUSH
82611: PPUSH
82612: PPUSH
82613: PPUSH
82614: PPUSH
82615: PPUSH
82616: PPUSH
82617: PPUSH
82618: PPUSH
82619: PPUSH
82620: PPUSH
// if not list then
82621: LD_VAR 0 1
82625: NOT
82626: IFFALSE 82630
// exit ;
82628: GO 87256
// base := list [ 1 ] ;
82630: LD_ADDR_VAR 0 3
82634: PUSH
82635: LD_VAR 0 1
82639: PUSH
82640: LD_INT 1
82642: ARRAY
82643: ST_TO_ADDR
// group := list [ 2 ] ;
82644: LD_ADDR_VAR 0 4
82648: PUSH
82649: LD_VAR 0 1
82653: PUSH
82654: LD_INT 2
82656: ARRAY
82657: ST_TO_ADDR
// path := list [ 3 ] ;
82658: LD_ADDR_VAR 0 5
82662: PUSH
82663: LD_VAR 0 1
82667: PUSH
82668: LD_INT 3
82670: ARRAY
82671: ST_TO_ADDR
// flags := list [ 4 ] ;
82672: LD_ADDR_VAR 0 6
82676: PUSH
82677: LD_VAR 0 1
82681: PUSH
82682: LD_INT 4
82684: ARRAY
82685: ST_TO_ADDR
// mined := [ ] ;
82686: LD_ADDR_VAR 0 27
82690: PUSH
82691: EMPTY
82692: ST_TO_ADDR
// bombed := [ ] ;
82693: LD_ADDR_VAR 0 28
82697: PUSH
82698: EMPTY
82699: ST_TO_ADDR
// healers := [ ] ;
82700: LD_ADDR_VAR 0 31
82704: PUSH
82705: EMPTY
82706: ST_TO_ADDR
// to_heal := [ ] ;
82707: LD_ADDR_VAR 0 30
82711: PUSH
82712: EMPTY
82713: ST_TO_ADDR
// repairs := [ ] ;
82714: LD_ADDR_VAR 0 33
82718: PUSH
82719: EMPTY
82720: ST_TO_ADDR
// to_repair := [ ] ;
82721: LD_ADDR_VAR 0 32
82725: PUSH
82726: EMPTY
82727: ST_TO_ADDR
// if not group or not path then
82728: LD_VAR 0 4
82732: NOT
82733: PUSH
82734: LD_VAR 0 5
82738: NOT
82739: OR
82740: IFFALSE 82744
// exit ;
82742: GO 87256
// side := GetSide ( group [ 1 ] ) ;
82744: LD_ADDR_VAR 0 35
82748: PUSH
82749: LD_VAR 0 4
82753: PUSH
82754: LD_INT 1
82756: ARRAY
82757: PPUSH
82758: CALL_OW 255
82762: ST_TO_ADDR
// if flags then
82763: LD_VAR 0 6
82767: IFFALSE 82911
// begin f_ignore_area := flags [ 1 ] ;
82769: LD_ADDR_VAR 0 17
82773: PUSH
82774: LD_VAR 0 6
82778: PUSH
82779: LD_INT 1
82781: ARRAY
82782: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82783: LD_ADDR_VAR 0 18
82787: PUSH
82788: LD_VAR 0 6
82792: PUSH
82793: LD_INT 2
82795: ARRAY
82796: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82797: LD_ADDR_VAR 0 19
82801: PUSH
82802: LD_VAR 0 6
82806: PUSH
82807: LD_INT 3
82809: ARRAY
82810: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82811: LD_ADDR_VAR 0 20
82815: PUSH
82816: LD_VAR 0 6
82820: PUSH
82821: LD_INT 4
82823: ARRAY
82824: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82825: LD_ADDR_VAR 0 21
82829: PUSH
82830: LD_VAR 0 6
82834: PUSH
82835: LD_INT 5
82837: ARRAY
82838: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82839: LD_ADDR_VAR 0 22
82843: PUSH
82844: LD_VAR 0 6
82848: PUSH
82849: LD_INT 6
82851: ARRAY
82852: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82853: LD_ADDR_VAR 0 23
82857: PUSH
82858: LD_VAR 0 6
82862: PUSH
82863: LD_INT 7
82865: ARRAY
82866: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82867: LD_ADDR_VAR 0 24
82871: PUSH
82872: LD_VAR 0 6
82876: PUSH
82877: LD_INT 8
82879: ARRAY
82880: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82881: LD_ADDR_VAR 0 25
82885: PUSH
82886: LD_VAR 0 6
82890: PUSH
82891: LD_INT 9
82893: ARRAY
82894: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82895: LD_ADDR_VAR 0 26
82899: PUSH
82900: LD_VAR 0 6
82904: PUSH
82905: LD_INT 10
82907: ARRAY
82908: ST_TO_ADDR
// end else
82909: GO 82991
// begin f_ignore_area := false ;
82911: LD_ADDR_VAR 0 17
82915: PUSH
82916: LD_INT 0
82918: ST_TO_ADDR
// f_capture := false ;
82919: LD_ADDR_VAR 0 18
82923: PUSH
82924: LD_INT 0
82926: ST_TO_ADDR
// f_ignore_civ := false ;
82927: LD_ADDR_VAR 0 19
82931: PUSH
82932: LD_INT 0
82934: ST_TO_ADDR
// f_murder := false ;
82935: LD_ADDR_VAR 0 20
82939: PUSH
82940: LD_INT 0
82942: ST_TO_ADDR
// f_mines := false ;
82943: LD_ADDR_VAR 0 21
82947: PUSH
82948: LD_INT 0
82950: ST_TO_ADDR
// f_repair := false ;
82951: LD_ADDR_VAR 0 22
82955: PUSH
82956: LD_INT 0
82958: ST_TO_ADDR
// f_heal := false ;
82959: LD_ADDR_VAR 0 23
82963: PUSH
82964: LD_INT 0
82966: ST_TO_ADDR
// f_spacetime := false ;
82967: LD_ADDR_VAR 0 24
82971: PUSH
82972: LD_INT 0
82974: ST_TO_ADDR
// f_attack_depot := false ;
82975: LD_ADDR_VAR 0 25
82979: PUSH
82980: LD_INT 0
82982: ST_TO_ADDR
// f_crawl := false ;
82983: LD_ADDR_VAR 0 26
82987: PUSH
82988: LD_INT 0
82990: ST_TO_ADDR
// end ; if f_heal then
82991: LD_VAR 0 23
82995: IFFALSE 83022
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82997: LD_ADDR_VAR 0 31
83001: PUSH
83002: LD_VAR 0 4
83006: PPUSH
83007: LD_INT 25
83009: PUSH
83010: LD_INT 4
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PPUSH
83017: CALL_OW 72
83021: ST_TO_ADDR
// if f_repair then
83022: LD_VAR 0 22
83026: IFFALSE 83053
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83028: LD_ADDR_VAR 0 33
83032: PUSH
83033: LD_VAR 0 4
83037: PPUSH
83038: LD_INT 25
83040: PUSH
83041: LD_INT 3
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PPUSH
83048: CALL_OW 72
83052: ST_TO_ADDR
// units_path := [ ] ;
83053: LD_ADDR_VAR 0 16
83057: PUSH
83058: EMPTY
83059: ST_TO_ADDR
// for i = 1 to group do
83060: LD_ADDR_VAR 0 7
83064: PUSH
83065: DOUBLE
83066: LD_INT 1
83068: DEC
83069: ST_TO_ADDR
83070: LD_VAR 0 4
83074: PUSH
83075: FOR_TO
83076: IFFALSE 83105
// units_path := Replace ( units_path , i , path ) ;
83078: LD_ADDR_VAR 0 16
83082: PUSH
83083: LD_VAR 0 16
83087: PPUSH
83088: LD_VAR 0 7
83092: PPUSH
83093: LD_VAR 0 5
83097: PPUSH
83098: CALL_OW 1
83102: ST_TO_ADDR
83103: GO 83075
83105: POP
83106: POP
// repeat for i = group downto 1 do
83107: LD_ADDR_VAR 0 7
83111: PUSH
83112: DOUBLE
83113: LD_VAR 0 4
83117: INC
83118: ST_TO_ADDR
83119: LD_INT 1
83121: PUSH
83122: FOR_DOWNTO
83123: IFFALSE 87219
// begin wait ( 5 ) ;
83125: LD_INT 5
83127: PPUSH
83128: CALL_OW 67
// tmp := [ ] ;
83132: LD_ADDR_VAR 0 14
83136: PUSH
83137: EMPTY
83138: ST_TO_ADDR
// attacking := false ;
83139: LD_ADDR_VAR 0 29
83143: PUSH
83144: LD_INT 0
83146: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83147: LD_VAR 0 4
83151: PUSH
83152: LD_VAR 0 7
83156: ARRAY
83157: PPUSH
83158: CALL_OW 301
83162: PUSH
83163: LD_VAR 0 4
83167: PUSH
83168: LD_VAR 0 7
83172: ARRAY
83173: NOT
83174: OR
83175: IFFALSE 83284
// begin if GetType ( group [ i ] ) = unit_human then
83177: LD_VAR 0 4
83181: PUSH
83182: LD_VAR 0 7
83186: ARRAY
83187: PPUSH
83188: CALL_OW 247
83192: PUSH
83193: LD_INT 1
83195: EQUAL
83196: IFFALSE 83242
// begin to_heal := to_heal diff group [ i ] ;
83198: LD_ADDR_VAR 0 30
83202: PUSH
83203: LD_VAR 0 30
83207: PUSH
83208: LD_VAR 0 4
83212: PUSH
83213: LD_VAR 0 7
83217: ARRAY
83218: DIFF
83219: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83220: LD_ADDR_VAR 0 31
83224: PUSH
83225: LD_VAR 0 31
83229: PUSH
83230: LD_VAR 0 4
83234: PUSH
83235: LD_VAR 0 7
83239: ARRAY
83240: DIFF
83241: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83242: LD_ADDR_VAR 0 4
83246: PUSH
83247: LD_VAR 0 4
83251: PPUSH
83252: LD_VAR 0 7
83256: PPUSH
83257: CALL_OW 3
83261: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83262: LD_ADDR_VAR 0 16
83266: PUSH
83267: LD_VAR 0 16
83271: PPUSH
83272: LD_VAR 0 7
83276: PPUSH
83277: CALL_OW 3
83281: ST_TO_ADDR
// continue ;
83282: GO 83122
// end ; if f_repair then
83284: LD_VAR 0 22
83288: IFFALSE 83777
// begin if GetType ( group [ i ] ) = unit_vehicle then
83290: LD_VAR 0 4
83294: PUSH
83295: LD_VAR 0 7
83299: ARRAY
83300: PPUSH
83301: CALL_OW 247
83305: PUSH
83306: LD_INT 2
83308: EQUAL
83309: IFFALSE 83499
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83311: LD_VAR 0 4
83315: PUSH
83316: LD_VAR 0 7
83320: ARRAY
83321: PPUSH
83322: CALL_OW 256
83326: PUSH
83327: LD_INT 700
83329: LESS
83330: PUSH
83331: LD_VAR 0 4
83335: PUSH
83336: LD_VAR 0 7
83340: ARRAY
83341: PUSH
83342: LD_VAR 0 32
83346: IN
83347: NOT
83348: AND
83349: IFFALSE 83373
// to_repair := to_repair union group [ i ] ;
83351: LD_ADDR_VAR 0 32
83355: PUSH
83356: LD_VAR 0 32
83360: PUSH
83361: LD_VAR 0 4
83365: PUSH
83366: LD_VAR 0 7
83370: ARRAY
83371: UNION
83372: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83373: LD_VAR 0 4
83377: PUSH
83378: LD_VAR 0 7
83382: ARRAY
83383: PPUSH
83384: CALL_OW 256
83388: PUSH
83389: LD_INT 1000
83391: EQUAL
83392: PUSH
83393: LD_VAR 0 4
83397: PUSH
83398: LD_VAR 0 7
83402: ARRAY
83403: PUSH
83404: LD_VAR 0 32
83408: IN
83409: AND
83410: IFFALSE 83434
// to_repair := to_repair diff group [ i ] ;
83412: LD_ADDR_VAR 0 32
83416: PUSH
83417: LD_VAR 0 32
83421: PUSH
83422: LD_VAR 0 4
83426: PUSH
83427: LD_VAR 0 7
83431: ARRAY
83432: DIFF
83433: ST_TO_ADDR
// if group [ i ] in to_repair then
83434: LD_VAR 0 4
83438: PUSH
83439: LD_VAR 0 7
83443: ARRAY
83444: PUSH
83445: LD_VAR 0 32
83449: IN
83450: IFFALSE 83497
// begin if not IsInArea ( group [ i ] , f_repair ) then
83452: LD_VAR 0 4
83456: PUSH
83457: LD_VAR 0 7
83461: ARRAY
83462: PPUSH
83463: LD_VAR 0 22
83467: PPUSH
83468: CALL_OW 308
83472: NOT
83473: IFFALSE 83495
// ComMoveToArea ( group [ i ] , f_repair ) ;
83475: LD_VAR 0 4
83479: PUSH
83480: LD_VAR 0 7
83484: ARRAY
83485: PPUSH
83486: LD_VAR 0 22
83490: PPUSH
83491: CALL_OW 113
// continue ;
83495: GO 83122
// end ; end else
83497: GO 83777
// if group [ i ] in repairs then
83499: LD_VAR 0 4
83503: PUSH
83504: LD_VAR 0 7
83508: ARRAY
83509: PUSH
83510: LD_VAR 0 33
83514: IN
83515: IFFALSE 83777
// begin if IsInUnit ( group [ i ] ) then
83517: LD_VAR 0 4
83521: PUSH
83522: LD_VAR 0 7
83526: ARRAY
83527: PPUSH
83528: CALL_OW 310
83532: IFFALSE 83600
// begin z := IsInUnit ( group [ i ] ) ;
83534: LD_ADDR_VAR 0 13
83538: PUSH
83539: LD_VAR 0 4
83543: PUSH
83544: LD_VAR 0 7
83548: ARRAY
83549: PPUSH
83550: CALL_OW 310
83554: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83555: LD_VAR 0 13
83559: PUSH
83560: LD_VAR 0 32
83564: IN
83565: PUSH
83566: LD_VAR 0 13
83570: PPUSH
83571: LD_VAR 0 22
83575: PPUSH
83576: CALL_OW 308
83580: AND
83581: IFFALSE 83598
// ComExitVehicle ( group [ i ] ) ;
83583: LD_VAR 0 4
83587: PUSH
83588: LD_VAR 0 7
83592: ARRAY
83593: PPUSH
83594: CALL_OW 121
// end else
83598: GO 83777
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83600: LD_ADDR_VAR 0 13
83604: PUSH
83605: LD_VAR 0 4
83609: PPUSH
83610: LD_INT 95
83612: PUSH
83613: LD_VAR 0 22
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 58
83624: PUSH
83625: EMPTY
83626: LIST
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PPUSH
83632: CALL_OW 72
83636: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83637: LD_VAR 0 4
83641: PUSH
83642: LD_VAR 0 7
83646: ARRAY
83647: PPUSH
83648: CALL_OW 314
83652: NOT
83653: IFFALSE 83775
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83655: LD_ADDR_VAR 0 10
83659: PUSH
83660: LD_VAR 0 13
83664: PPUSH
83665: LD_VAR 0 4
83669: PUSH
83670: LD_VAR 0 7
83674: ARRAY
83675: PPUSH
83676: CALL_OW 74
83680: ST_TO_ADDR
// if not x then
83681: LD_VAR 0 10
83685: NOT
83686: IFFALSE 83690
// continue ;
83688: GO 83122
// if GetLives ( x ) < 1000 then
83690: LD_VAR 0 10
83694: PPUSH
83695: CALL_OW 256
83699: PUSH
83700: LD_INT 1000
83702: LESS
83703: IFFALSE 83727
// ComRepairVehicle ( group [ i ] , x ) else
83705: LD_VAR 0 4
83709: PUSH
83710: LD_VAR 0 7
83714: ARRAY
83715: PPUSH
83716: LD_VAR 0 10
83720: PPUSH
83721: CALL_OW 129
83725: GO 83775
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83727: LD_VAR 0 23
83731: PUSH
83732: LD_VAR 0 4
83736: PUSH
83737: LD_VAR 0 7
83741: ARRAY
83742: PPUSH
83743: CALL_OW 256
83747: PUSH
83748: LD_INT 1000
83750: LESS
83751: AND
83752: NOT
83753: IFFALSE 83775
// ComEnterUnit ( group [ i ] , x ) ;
83755: LD_VAR 0 4
83759: PUSH
83760: LD_VAR 0 7
83764: ARRAY
83765: PPUSH
83766: LD_VAR 0 10
83770: PPUSH
83771: CALL_OW 120
// end ; continue ;
83775: GO 83122
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83777: LD_VAR 0 23
83781: PUSH
83782: LD_VAR 0 4
83786: PUSH
83787: LD_VAR 0 7
83791: ARRAY
83792: PPUSH
83793: CALL_OW 247
83797: PUSH
83798: LD_INT 1
83800: EQUAL
83801: AND
83802: IFFALSE 84280
// begin if group [ i ] in healers then
83804: LD_VAR 0 4
83808: PUSH
83809: LD_VAR 0 7
83813: ARRAY
83814: PUSH
83815: LD_VAR 0 31
83819: IN
83820: IFFALSE 84093
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83822: LD_VAR 0 4
83826: PUSH
83827: LD_VAR 0 7
83831: ARRAY
83832: PPUSH
83833: LD_VAR 0 23
83837: PPUSH
83838: CALL_OW 308
83842: NOT
83843: PUSH
83844: LD_VAR 0 4
83848: PUSH
83849: LD_VAR 0 7
83853: ARRAY
83854: PPUSH
83855: CALL_OW 314
83859: NOT
83860: AND
83861: IFFALSE 83885
// ComMoveToArea ( group [ i ] , f_heal ) else
83863: LD_VAR 0 4
83867: PUSH
83868: LD_VAR 0 7
83872: ARRAY
83873: PPUSH
83874: LD_VAR 0 23
83878: PPUSH
83879: CALL_OW 113
83883: GO 84091
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83885: LD_VAR 0 4
83889: PUSH
83890: LD_VAR 0 7
83894: ARRAY
83895: PPUSH
83896: CALL 82503 0 1
83900: PPUSH
83901: CALL_OW 256
83905: PUSH
83906: LD_INT 1000
83908: EQUAL
83909: IFFALSE 83928
// ComStop ( group [ i ] ) else
83911: LD_VAR 0 4
83915: PUSH
83916: LD_VAR 0 7
83920: ARRAY
83921: PPUSH
83922: CALL_OW 141
83926: GO 84091
// if not HasTask ( group [ i ] ) and to_heal then
83928: LD_VAR 0 4
83932: PUSH
83933: LD_VAR 0 7
83937: ARRAY
83938: PPUSH
83939: CALL_OW 314
83943: NOT
83944: PUSH
83945: LD_VAR 0 30
83949: AND
83950: IFFALSE 84091
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83952: LD_ADDR_VAR 0 13
83956: PUSH
83957: LD_VAR 0 30
83961: PPUSH
83962: LD_INT 3
83964: PUSH
83965: LD_INT 54
83967: PUSH
83968: EMPTY
83969: LIST
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PPUSH
83975: CALL_OW 72
83979: PPUSH
83980: LD_VAR 0 4
83984: PUSH
83985: LD_VAR 0 7
83989: ARRAY
83990: PPUSH
83991: CALL_OW 74
83995: ST_TO_ADDR
// if z then
83996: LD_VAR 0 13
84000: IFFALSE 84091
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84002: LD_INT 91
84004: PUSH
84005: LD_VAR 0 13
84009: PUSH
84010: LD_INT 10
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 81
84020: PUSH
84021: LD_VAR 0 13
84025: PPUSH
84026: CALL_OW 255
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PPUSH
84039: CALL_OW 69
84043: PUSH
84044: LD_INT 0
84046: EQUAL
84047: IFFALSE 84071
// ComHeal ( group [ i ] , z ) else
84049: LD_VAR 0 4
84053: PUSH
84054: LD_VAR 0 7
84058: ARRAY
84059: PPUSH
84060: LD_VAR 0 13
84064: PPUSH
84065: CALL_OW 128
84069: GO 84091
// ComMoveToArea ( group [ i ] , f_heal ) ;
84071: LD_VAR 0 4
84075: PUSH
84076: LD_VAR 0 7
84080: ARRAY
84081: PPUSH
84082: LD_VAR 0 23
84086: PPUSH
84087: CALL_OW 113
// end ; continue ;
84091: GO 83122
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84093: LD_VAR 0 4
84097: PUSH
84098: LD_VAR 0 7
84102: ARRAY
84103: PPUSH
84104: CALL_OW 256
84108: PUSH
84109: LD_INT 700
84111: LESS
84112: PUSH
84113: LD_VAR 0 4
84117: PUSH
84118: LD_VAR 0 7
84122: ARRAY
84123: PUSH
84124: LD_VAR 0 30
84128: IN
84129: NOT
84130: AND
84131: IFFALSE 84155
// to_heal := to_heal union group [ i ] ;
84133: LD_ADDR_VAR 0 30
84137: PUSH
84138: LD_VAR 0 30
84142: PUSH
84143: LD_VAR 0 4
84147: PUSH
84148: LD_VAR 0 7
84152: ARRAY
84153: UNION
84154: ST_TO_ADDR
// if group [ i ] in to_heal then
84155: LD_VAR 0 4
84159: PUSH
84160: LD_VAR 0 7
84164: ARRAY
84165: PUSH
84166: LD_VAR 0 30
84170: IN
84171: IFFALSE 84280
// begin if GetLives ( group [ i ] ) = 1000 then
84173: LD_VAR 0 4
84177: PUSH
84178: LD_VAR 0 7
84182: ARRAY
84183: PPUSH
84184: CALL_OW 256
84188: PUSH
84189: LD_INT 1000
84191: EQUAL
84192: IFFALSE 84218
// to_heal := to_heal diff group [ i ] else
84194: LD_ADDR_VAR 0 30
84198: PUSH
84199: LD_VAR 0 30
84203: PUSH
84204: LD_VAR 0 4
84208: PUSH
84209: LD_VAR 0 7
84213: ARRAY
84214: DIFF
84215: ST_TO_ADDR
84216: GO 84280
// begin if not IsInArea ( group [ i ] , to_heal ) then
84218: LD_VAR 0 4
84222: PUSH
84223: LD_VAR 0 7
84227: ARRAY
84228: PPUSH
84229: LD_VAR 0 30
84233: PPUSH
84234: CALL_OW 308
84238: NOT
84239: IFFALSE 84263
// ComMoveToArea ( group [ i ] , f_heal ) else
84241: LD_VAR 0 4
84245: PUSH
84246: LD_VAR 0 7
84250: ARRAY
84251: PPUSH
84252: LD_VAR 0 23
84256: PPUSH
84257: CALL_OW 113
84261: GO 84278
// ComHold ( group [ i ] ) ;
84263: LD_VAR 0 4
84267: PUSH
84268: LD_VAR 0 7
84272: ARRAY
84273: PPUSH
84274: CALL_OW 140
// continue ;
84278: GO 83122
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84280: LD_VAR 0 4
84284: PUSH
84285: LD_VAR 0 7
84289: ARRAY
84290: PPUSH
84291: LD_INT 10
84293: PPUSH
84294: CALL 80900 0 2
84298: NOT
84299: PUSH
84300: LD_VAR 0 16
84304: PUSH
84305: LD_VAR 0 7
84309: ARRAY
84310: PUSH
84311: EMPTY
84312: EQUAL
84313: NOT
84314: AND
84315: IFFALSE 84581
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84317: LD_VAR 0 4
84321: PUSH
84322: LD_VAR 0 7
84326: ARRAY
84327: PPUSH
84328: CALL_OW 262
84332: PUSH
84333: LD_INT 1
84335: PUSH
84336: LD_INT 2
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: IN
84343: IFFALSE 84384
// if GetFuel ( group [ i ] ) < 10 then
84345: LD_VAR 0 4
84349: PUSH
84350: LD_VAR 0 7
84354: ARRAY
84355: PPUSH
84356: CALL_OW 261
84360: PUSH
84361: LD_INT 10
84363: LESS
84364: IFFALSE 84384
// SetFuel ( group [ i ] , 12 ) ;
84366: LD_VAR 0 4
84370: PUSH
84371: LD_VAR 0 7
84375: ARRAY
84376: PPUSH
84377: LD_INT 12
84379: PPUSH
84380: CALL_OW 240
// if units_path [ i ] then
84384: LD_VAR 0 16
84388: PUSH
84389: LD_VAR 0 7
84393: ARRAY
84394: IFFALSE 84579
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84396: LD_VAR 0 4
84400: PUSH
84401: LD_VAR 0 7
84405: ARRAY
84406: PPUSH
84407: LD_VAR 0 16
84411: PUSH
84412: LD_VAR 0 7
84416: ARRAY
84417: PUSH
84418: LD_INT 1
84420: ARRAY
84421: PUSH
84422: LD_INT 1
84424: ARRAY
84425: PPUSH
84426: LD_VAR 0 16
84430: PUSH
84431: LD_VAR 0 7
84435: ARRAY
84436: PUSH
84437: LD_INT 1
84439: ARRAY
84440: PUSH
84441: LD_INT 2
84443: ARRAY
84444: PPUSH
84445: CALL_OW 297
84449: PUSH
84450: LD_INT 6
84452: GREATER
84453: IFFALSE 84528
// begin if not HasTask ( group [ i ] ) then
84455: LD_VAR 0 4
84459: PUSH
84460: LD_VAR 0 7
84464: ARRAY
84465: PPUSH
84466: CALL_OW 314
84470: NOT
84471: IFFALSE 84526
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84473: LD_VAR 0 4
84477: PUSH
84478: LD_VAR 0 7
84482: ARRAY
84483: PPUSH
84484: LD_VAR 0 16
84488: PUSH
84489: LD_VAR 0 7
84493: ARRAY
84494: PUSH
84495: LD_INT 1
84497: ARRAY
84498: PUSH
84499: LD_INT 1
84501: ARRAY
84502: PPUSH
84503: LD_VAR 0 16
84507: PUSH
84508: LD_VAR 0 7
84512: ARRAY
84513: PUSH
84514: LD_INT 1
84516: ARRAY
84517: PUSH
84518: LD_INT 2
84520: ARRAY
84521: PPUSH
84522: CALL_OW 114
// end else
84526: GO 84579
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84528: LD_ADDR_VAR 0 15
84532: PUSH
84533: LD_VAR 0 16
84537: PUSH
84538: LD_VAR 0 7
84542: ARRAY
84543: PPUSH
84544: LD_INT 1
84546: PPUSH
84547: CALL_OW 3
84551: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84552: LD_ADDR_VAR 0 16
84556: PUSH
84557: LD_VAR 0 16
84561: PPUSH
84562: LD_VAR 0 7
84566: PPUSH
84567: LD_VAR 0 15
84571: PPUSH
84572: CALL_OW 1
84576: ST_TO_ADDR
// continue ;
84577: GO 83122
// end ; end ; end else
84579: GO 87217
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84581: LD_ADDR_VAR 0 14
84585: PUSH
84586: LD_INT 81
84588: PUSH
84589: LD_VAR 0 4
84593: PUSH
84594: LD_VAR 0 7
84598: ARRAY
84599: PPUSH
84600: CALL_OW 255
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: PPUSH
84609: CALL_OW 69
84613: ST_TO_ADDR
// if not tmp then
84614: LD_VAR 0 14
84618: NOT
84619: IFFALSE 84623
// continue ;
84621: GO 83122
// if f_ignore_area then
84623: LD_VAR 0 17
84627: IFFALSE 84715
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84629: LD_ADDR_VAR 0 15
84633: PUSH
84634: LD_VAR 0 14
84638: PPUSH
84639: LD_INT 3
84641: PUSH
84642: LD_INT 92
84644: PUSH
84645: LD_VAR 0 17
84649: PUSH
84650: LD_INT 1
84652: ARRAY
84653: PUSH
84654: LD_VAR 0 17
84658: PUSH
84659: LD_INT 2
84661: ARRAY
84662: PUSH
84663: LD_VAR 0 17
84667: PUSH
84668: LD_INT 3
84670: ARRAY
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PPUSH
84682: CALL_OW 72
84686: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84687: LD_VAR 0 14
84691: PUSH
84692: LD_VAR 0 15
84696: DIFF
84697: IFFALSE 84715
// tmp := tmp diff tmp2 ;
84699: LD_ADDR_VAR 0 14
84703: PUSH
84704: LD_VAR 0 14
84708: PUSH
84709: LD_VAR 0 15
84713: DIFF
84714: ST_TO_ADDR
// end ; if not f_murder then
84715: LD_VAR 0 20
84719: NOT
84720: IFFALSE 84778
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84722: LD_ADDR_VAR 0 15
84726: PUSH
84727: LD_VAR 0 14
84731: PPUSH
84732: LD_INT 3
84734: PUSH
84735: LD_INT 50
84737: PUSH
84738: EMPTY
84739: LIST
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PPUSH
84745: CALL_OW 72
84749: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84750: LD_VAR 0 14
84754: PUSH
84755: LD_VAR 0 15
84759: DIFF
84760: IFFALSE 84778
// tmp := tmp diff tmp2 ;
84762: LD_ADDR_VAR 0 14
84766: PUSH
84767: LD_VAR 0 14
84771: PUSH
84772: LD_VAR 0 15
84776: DIFF
84777: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84778: LD_ADDR_VAR 0 14
84782: PUSH
84783: LD_VAR 0 4
84787: PUSH
84788: LD_VAR 0 7
84792: ARRAY
84793: PPUSH
84794: LD_VAR 0 14
84798: PPUSH
84799: LD_INT 1
84801: PPUSH
84802: LD_INT 1
84804: PPUSH
84805: CALL 54543 0 4
84809: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84810: LD_VAR 0 4
84814: PUSH
84815: LD_VAR 0 7
84819: ARRAY
84820: PPUSH
84821: CALL_OW 257
84825: PUSH
84826: LD_INT 1
84828: EQUAL
84829: IFFALSE 85277
// begin if WantPlant ( group [ i ] ) then
84831: LD_VAR 0 4
84835: PUSH
84836: LD_VAR 0 7
84840: ARRAY
84841: PPUSH
84842: CALL 54044 0 1
84846: IFFALSE 84850
// continue ;
84848: GO 83122
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84850: LD_VAR 0 18
84854: PUSH
84855: LD_VAR 0 4
84859: PUSH
84860: LD_VAR 0 7
84864: ARRAY
84865: PPUSH
84866: CALL_OW 310
84870: NOT
84871: AND
84872: PUSH
84873: LD_VAR 0 14
84877: PUSH
84878: LD_INT 1
84880: ARRAY
84881: PUSH
84882: LD_VAR 0 14
84886: PPUSH
84887: LD_INT 21
84889: PUSH
84890: LD_INT 2
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 58
84899: PUSH
84900: EMPTY
84901: LIST
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PPUSH
84907: CALL_OW 72
84911: IN
84912: AND
84913: IFFALSE 84949
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84915: LD_VAR 0 4
84919: PUSH
84920: LD_VAR 0 7
84924: ARRAY
84925: PPUSH
84926: LD_VAR 0 14
84930: PUSH
84931: LD_INT 1
84933: ARRAY
84934: PPUSH
84935: CALL_OW 120
// attacking := true ;
84939: LD_ADDR_VAR 0 29
84943: PUSH
84944: LD_INT 1
84946: ST_TO_ADDR
// continue ;
84947: GO 83122
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84949: LD_VAR 0 26
84953: PUSH
84954: LD_VAR 0 4
84958: PUSH
84959: LD_VAR 0 7
84963: ARRAY
84964: PPUSH
84965: CALL_OW 257
84969: PUSH
84970: LD_INT 1
84972: EQUAL
84973: AND
84974: PUSH
84975: LD_VAR 0 4
84979: PUSH
84980: LD_VAR 0 7
84984: ARRAY
84985: PPUSH
84986: CALL_OW 256
84990: PUSH
84991: LD_INT 800
84993: LESS
84994: AND
84995: PUSH
84996: LD_VAR 0 4
85000: PUSH
85001: LD_VAR 0 7
85005: ARRAY
85006: PPUSH
85007: CALL_OW 318
85011: NOT
85012: AND
85013: IFFALSE 85030
// ComCrawl ( group [ i ] ) ;
85015: LD_VAR 0 4
85019: PUSH
85020: LD_VAR 0 7
85024: ARRAY
85025: PPUSH
85026: CALL_OW 137
// if f_mines then
85030: LD_VAR 0 21
85034: IFFALSE 85277
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85036: LD_VAR 0 14
85040: PUSH
85041: LD_INT 1
85043: ARRAY
85044: PPUSH
85045: CALL_OW 247
85049: PUSH
85050: LD_INT 3
85052: EQUAL
85053: PUSH
85054: LD_VAR 0 14
85058: PUSH
85059: LD_INT 1
85061: ARRAY
85062: PUSH
85063: LD_VAR 0 27
85067: IN
85068: NOT
85069: AND
85070: IFFALSE 85277
// begin x := GetX ( tmp [ 1 ] ) ;
85072: LD_ADDR_VAR 0 10
85076: PUSH
85077: LD_VAR 0 14
85081: PUSH
85082: LD_INT 1
85084: ARRAY
85085: PPUSH
85086: CALL_OW 250
85090: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85091: LD_ADDR_VAR 0 11
85095: PUSH
85096: LD_VAR 0 14
85100: PUSH
85101: LD_INT 1
85103: ARRAY
85104: PPUSH
85105: CALL_OW 251
85109: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85110: LD_ADDR_VAR 0 12
85114: PUSH
85115: LD_VAR 0 4
85119: PUSH
85120: LD_VAR 0 7
85124: ARRAY
85125: PPUSH
85126: CALL 80985 0 1
85130: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85131: LD_VAR 0 4
85135: PUSH
85136: LD_VAR 0 7
85140: ARRAY
85141: PPUSH
85142: LD_VAR 0 10
85146: PPUSH
85147: LD_VAR 0 11
85151: PPUSH
85152: LD_VAR 0 14
85156: PUSH
85157: LD_INT 1
85159: ARRAY
85160: PPUSH
85161: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85165: LD_VAR 0 4
85169: PUSH
85170: LD_VAR 0 7
85174: ARRAY
85175: PPUSH
85176: LD_VAR 0 10
85180: PPUSH
85181: LD_VAR 0 12
85185: PPUSH
85186: LD_INT 7
85188: PPUSH
85189: CALL_OW 272
85193: PPUSH
85194: LD_VAR 0 11
85198: PPUSH
85199: LD_VAR 0 12
85203: PPUSH
85204: LD_INT 7
85206: PPUSH
85207: CALL_OW 273
85211: PPUSH
85212: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85216: LD_VAR 0 4
85220: PUSH
85221: LD_VAR 0 7
85225: ARRAY
85226: PPUSH
85227: LD_INT 71
85229: PPUSH
85230: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85234: LD_ADDR_VAR 0 27
85238: PUSH
85239: LD_VAR 0 27
85243: PPUSH
85244: LD_VAR 0 27
85248: PUSH
85249: LD_INT 1
85251: PLUS
85252: PPUSH
85253: LD_VAR 0 14
85257: PUSH
85258: LD_INT 1
85260: ARRAY
85261: PPUSH
85262: CALL_OW 1
85266: ST_TO_ADDR
// attacking := true ;
85267: LD_ADDR_VAR 0 29
85271: PUSH
85272: LD_INT 1
85274: ST_TO_ADDR
// continue ;
85275: GO 83122
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85277: LD_VAR 0 4
85281: PUSH
85282: LD_VAR 0 7
85286: ARRAY
85287: PPUSH
85288: CALL_OW 257
85292: PUSH
85293: LD_INT 17
85295: EQUAL
85296: PUSH
85297: LD_VAR 0 4
85301: PUSH
85302: LD_VAR 0 7
85306: ARRAY
85307: PPUSH
85308: CALL_OW 110
85312: PUSH
85313: LD_INT 71
85315: EQUAL
85316: NOT
85317: AND
85318: IFFALSE 85464
// begin attacking := false ;
85320: LD_ADDR_VAR 0 29
85324: PUSH
85325: LD_INT 0
85327: ST_TO_ADDR
// k := 5 ;
85328: LD_ADDR_VAR 0 9
85332: PUSH
85333: LD_INT 5
85335: ST_TO_ADDR
// if tmp < k then
85336: LD_VAR 0 14
85340: PUSH
85341: LD_VAR 0 9
85345: LESS
85346: IFFALSE 85358
// k := tmp ;
85348: LD_ADDR_VAR 0 9
85352: PUSH
85353: LD_VAR 0 14
85357: ST_TO_ADDR
// for j = 1 to k do
85358: LD_ADDR_VAR 0 8
85362: PUSH
85363: DOUBLE
85364: LD_INT 1
85366: DEC
85367: ST_TO_ADDR
85368: LD_VAR 0 9
85372: PUSH
85373: FOR_TO
85374: IFFALSE 85462
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85376: LD_VAR 0 14
85380: PUSH
85381: LD_VAR 0 8
85385: ARRAY
85386: PUSH
85387: LD_VAR 0 14
85391: PPUSH
85392: LD_INT 58
85394: PUSH
85395: EMPTY
85396: LIST
85397: PPUSH
85398: CALL_OW 72
85402: IN
85403: NOT
85404: IFFALSE 85460
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85406: LD_VAR 0 4
85410: PUSH
85411: LD_VAR 0 7
85415: ARRAY
85416: PPUSH
85417: LD_VAR 0 14
85421: PUSH
85422: LD_VAR 0 8
85426: ARRAY
85427: PPUSH
85428: CALL_OW 115
// attacking := true ;
85432: LD_ADDR_VAR 0 29
85436: PUSH
85437: LD_INT 1
85439: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85440: LD_VAR 0 4
85444: PUSH
85445: LD_VAR 0 7
85449: ARRAY
85450: PPUSH
85451: LD_INT 71
85453: PPUSH
85454: CALL_OW 109
// continue ;
85458: GO 85373
// end ; end ;
85460: GO 85373
85462: POP
85463: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85464: LD_VAR 0 4
85468: PUSH
85469: LD_VAR 0 7
85473: ARRAY
85474: PPUSH
85475: CALL_OW 257
85479: PUSH
85480: LD_INT 8
85482: EQUAL
85483: PUSH
85484: LD_VAR 0 4
85488: PUSH
85489: LD_VAR 0 7
85493: ARRAY
85494: PPUSH
85495: CALL_OW 264
85499: PUSH
85500: LD_INT 28
85502: PUSH
85503: LD_INT 45
85505: PUSH
85506: LD_INT 7
85508: PUSH
85509: LD_INT 47
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: IN
85518: OR
85519: IFFALSE 85749
// begin attacking := false ;
85521: LD_ADDR_VAR 0 29
85525: PUSH
85526: LD_INT 0
85528: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85529: LD_VAR 0 14
85533: PUSH
85534: LD_INT 1
85536: ARRAY
85537: PPUSH
85538: CALL_OW 266
85542: PUSH
85543: LD_INT 32
85545: PUSH
85546: LD_INT 31
85548: PUSH
85549: LD_INT 33
85551: PUSH
85552: LD_INT 4
85554: PUSH
85555: LD_INT 5
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: IN
85565: IFFALSE 85749
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85567: LD_ADDR_VAR 0 9
85571: PUSH
85572: LD_VAR 0 14
85576: PUSH
85577: LD_INT 1
85579: ARRAY
85580: PPUSH
85581: CALL_OW 266
85585: PPUSH
85586: LD_VAR 0 14
85590: PUSH
85591: LD_INT 1
85593: ARRAY
85594: PPUSH
85595: CALL_OW 250
85599: PPUSH
85600: LD_VAR 0 14
85604: PUSH
85605: LD_INT 1
85607: ARRAY
85608: PPUSH
85609: CALL_OW 251
85613: PPUSH
85614: LD_VAR 0 14
85618: PUSH
85619: LD_INT 1
85621: ARRAY
85622: PPUSH
85623: CALL_OW 254
85627: PPUSH
85628: LD_VAR 0 14
85632: PUSH
85633: LD_INT 1
85635: ARRAY
85636: PPUSH
85637: CALL_OW 248
85641: PPUSH
85642: LD_INT 0
85644: PPUSH
85645: CALL 62355 0 6
85649: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85650: LD_ADDR_VAR 0 8
85654: PUSH
85655: LD_VAR 0 4
85659: PUSH
85660: LD_VAR 0 7
85664: ARRAY
85665: PPUSH
85666: LD_VAR 0 9
85670: PPUSH
85671: CALL 81048 0 2
85675: ST_TO_ADDR
// if j then
85676: LD_VAR 0 8
85680: IFFALSE 85749
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85682: LD_VAR 0 8
85686: PUSH
85687: LD_INT 1
85689: ARRAY
85690: PPUSH
85691: LD_VAR 0 8
85695: PUSH
85696: LD_INT 2
85698: ARRAY
85699: PPUSH
85700: CALL_OW 488
85704: IFFALSE 85749
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85706: LD_VAR 0 4
85710: PUSH
85711: LD_VAR 0 7
85715: ARRAY
85716: PPUSH
85717: LD_VAR 0 8
85721: PUSH
85722: LD_INT 1
85724: ARRAY
85725: PPUSH
85726: LD_VAR 0 8
85730: PUSH
85731: LD_INT 2
85733: ARRAY
85734: PPUSH
85735: CALL_OW 116
// attacking := true ;
85739: LD_ADDR_VAR 0 29
85743: PUSH
85744: LD_INT 1
85746: ST_TO_ADDR
// continue ;
85747: GO 83122
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85749: LD_VAR 0 4
85753: PUSH
85754: LD_VAR 0 7
85758: ARRAY
85759: PPUSH
85760: CALL_OW 265
85764: PUSH
85765: LD_INT 11
85767: EQUAL
85768: IFFALSE 86046
// begin k := 10 ;
85770: LD_ADDR_VAR 0 9
85774: PUSH
85775: LD_INT 10
85777: ST_TO_ADDR
// x := 0 ;
85778: LD_ADDR_VAR 0 10
85782: PUSH
85783: LD_INT 0
85785: ST_TO_ADDR
// if tmp < k then
85786: LD_VAR 0 14
85790: PUSH
85791: LD_VAR 0 9
85795: LESS
85796: IFFALSE 85808
// k := tmp ;
85798: LD_ADDR_VAR 0 9
85802: PUSH
85803: LD_VAR 0 14
85807: ST_TO_ADDR
// for j = k downto 1 do
85808: LD_ADDR_VAR 0 8
85812: PUSH
85813: DOUBLE
85814: LD_VAR 0 9
85818: INC
85819: ST_TO_ADDR
85820: LD_INT 1
85822: PUSH
85823: FOR_DOWNTO
85824: IFFALSE 85899
// begin if GetType ( tmp [ j ] ) = unit_human then
85826: LD_VAR 0 14
85830: PUSH
85831: LD_VAR 0 8
85835: ARRAY
85836: PPUSH
85837: CALL_OW 247
85841: PUSH
85842: LD_INT 1
85844: EQUAL
85845: IFFALSE 85897
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85847: LD_VAR 0 4
85851: PUSH
85852: LD_VAR 0 7
85856: ARRAY
85857: PPUSH
85858: LD_VAR 0 14
85862: PUSH
85863: LD_VAR 0 8
85867: ARRAY
85868: PPUSH
85869: CALL 81319 0 2
// x := tmp [ j ] ;
85873: LD_ADDR_VAR 0 10
85877: PUSH
85878: LD_VAR 0 14
85882: PUSH
85883: LD_VAR 0 8
85887: ARRAY
85888: ST_TO_ADDR
// attacking := true ;
85889: LD_ADDR_VAR 0 29
85893: PUSH
85894: LD_INT 1
85896: ST_TO_ADDR
// end ; end ;
85897: GO 85823
85899: POP
85900: POP
// if not x then
85901: LD_VAR 0 10
85905: NOT
85906: IFFALSE 86046
// begin attacking := true ;
85908: LD_ADDR_VAR 0 29
85912: PUSH
85913: LD_INT 1
85915: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85916: LD_VAR 0 4
85920: PUSH
85921: LD_VAR 0 7
85925: ARRAY
85926: PPUSH
85927: CALL_OW 250
85931: PPUSH
85932: LD_VAR 0 4
85936: PUSH
85937: LD_VAR 0 7
85941: ARRAY
85942: PPUSH
85943: CALL_OW 251
85947: PPUSH
85948: CALL_OW 546
85952: PUSH
85953: LD_INT 2
85955: ARRAY
85956: PUSH
85957: LD_VAR 0 14
85961: PUSH
85962: LD_INT 1
85964: ARRAY
85965: PPUSH
85966: CALL_OW 250
85970: PPUSH
85971: LD_VAR 0 14
85975: PUSH
85976: LD_INT 1
85978: ARRAY
85979: PPUSH
85980: CALL_OW 251
85984: PPUSH
85985: CALL_OW 546
85989: PUSH
85990: LD_INT 2
85992: ARRAY
85993: EQUAL
85994: IFFALSE 86022
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85996: LD_VAR 0 4
86000: PUSH
86001: LD_VAR 0 7
86005: ARRAY
86006: PPUSH
86007: LD_VAR 0 14
86011: PUSH
86012: LD_INT 1
86014: ARRAY
86015: PPUSH
86016: CALL 81319 0 2
86020: GO 86046
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86022: LD_VAR 0 4
86026: PUSH
86027: LD_VAR 0 7
86031: ARRAY
86032: PPUSH
86033: LD_VAR 0 14
86037: PUSH
86038: LD_INT 1
86040: ARRAY
86041: PPUSH
86042: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86046: LD_VAR 0 4
86050: PUSH
86051: LD_VAR 0 7
86055: ARRAY
86056: PPUSH
86057: CALL_OW 264
86061: PUSH
86062: LD_INT 29
86064: EQUAL
86065: IFFALSE 86431
// begin if WantsToAttack ( group [ i ] ) in bombed then
86067: LD_VAR 0 4
86071: PUSH
86072: LD_VAR 0 7
86076: ARRAY
86077: PPUSH
86078: CALL_OW 319
86082: PUSH
86083: LD_VAR 0 28
86087: IN
86088: IFFALSE 86092
// continue ;
86090: GO 83122
// k := 8 ;
86092: LD_ADDR_VAR 0 9
86096: PUSH
86097: LD_INT 8
86099: ST_TO_ADDR
// x := 0 ;
86100: LD_ADDR_VAR 0 10
86104: PUSH
86105: LD_INT 0
86107: ST_TO_ADDR
// if tmp < k then
86108: LD_VAR 0 14
86112: PUSH
86113: LD_VAR 0 9
86117: LESS
86118: IFFALSE 86130
// k := tmp ;
86120: LD_ADDR_VAR 0 9
86124: PUSH
86125: LD_VAR 0 14
86129: ST_TO_ADDR
// for j = 1 to k do
86130: LD_ADDR_VAR 0 8
86134: PUSH
86135: DOUBLE
86136: LD_INT 1
86138: DEC
86139: ST_TO_ADDR
86140: LD_VAR 0 9
86144: PUSH
86145: FOR_TO
86146: IFFALSE 86278
// begin if GetType ( tmp [ j ] ) = unit_building then
86148: LD_VAR 0 14
86152: PUSH
86153: LD_VAR 0 8
86157: ARRAY
86158: PPUSH
86159: CALL_OW 247
86163: PUSH
86164: LD_INT 3
86166: EQUAL
86167: IFFALSE 86276
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86169: LD_VAR 0 14
86173: PUSH
86174: LD_VAR 0 8
86178: ARRAY
86179: PUSH
86180: LD_VAR 0 28
86184: IN
86185: NOT
86186: PUSH
86187: LD_VAR 0 14
86191: PUSH
86192: LD_VAR 0 8
86196: ARRAY
86197: PPUSH
86198: CALL_OW 313
86202: AND
86203: IFFALSE 86276
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86205: LD_VAR 0 4
86209: PUSH
86210: LD_VAR 0 7
86214: ARRAY
86215: PPUSH
86216: LD_VAR 0 14
86220: PUSH
86221: LD_VAR 0 8
86225: ARRAY
86226: PPUSH
86227: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86231: LD_ADDR_VAR 0 28
86235: PUSH
86236: LD_VAR 0 28
86240: PPUSH
86241: LD_VAR 0 28
86245: PUSH
86246: LD_INT 1
86248: PLUS
86249: PPUSH
86250: LD_VAR 0 14
86254: PUSH
86255: LD_VAR 0 8
86259: ARRAY
86260: PPUSH
86261: CALL_OW 1
86265: ST_TO_ADDR
// attacking := true ;
86266: LD_ADDR_VAR 0 29
86270: PUSH
86271: LD_INT 1
86273: ST_TO_ADDR
// break ;
86274: GO 86278
// end ; end ;
86276: GO 86145
86278: POP
86279: POP
// if not attacking and f_attack_depot then
86280: LD_VAR 0 29
86284: NOT
86285: PUSH
86286: LD_VAR 0 25
86290: AND
86291: IFFALSE 86386
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86293: LD_ADDR_VAR 0 13
86297: PUSH
86298: LD_VAR 0 14
86302: PPUSH
86303: LD_INT 2
86305: PUSH
86306: LD_INT 30
86308: PUSH
86309: LD_INT 0
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 30
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: LIST
86330: PPUSH
86331: CALL_OW 72
86335: ST_TO_ADDR
// if z then
86336: LD_VAR 0 13
86340: IFFALSE 86386
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86342: LD_VAR 0 4
86346: PUSH
86347: LD_VAR 0 7
86351: ARRAY
86352: PPUSH
86353: LD_VAR 0 13
86357: PPUSH
86358: LD_VAR 0 4
86362: PUSH
86363: LD_VAR 0 7
86367: ARRAY
86368: PPUSH
86369: CALL_OW 74
86373: PPUSH
86374: CALL_OW 115
// attacking := true ;
86378: LD_ADDR_VAR 0 29
86382: PUSH
86383: LD_INT 1
86385: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86386: LD_VAR 0 4
86390: PUSH
86391: LD_VAR 0 7
86395: ARRAY
86396: PPUSH
86397: CALL_OW 256
86401: PUSH
86402: LD_INT 500
86404: LESS
86405: IFFALSE 86431
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86407: LD_VAR 0 4
86411: PUSH
86412: LD_VAR 0 7
86416: ARRAY
86417: PPUSH
86418: LD_VAR 0 14
86422: PUSH
86423: LD_INT 1
86425: ARRAY
86426: PPUSH
86427: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86431: LD_VAR 0 4
86435: PUSH
86436: LD_VAR 0 7
86440: ARRAY
86441: PPUSH
86442: CALL_OW 264
86446: PUSH
86447: LD_INT 49
86449: EQUAL
86450: IFFALSE 86571
// begin if not HasTask ( group [ i ] ) then
86452: LD_VAR 0 4
86456: PUSH
86457: LD_VAR 0 7
86461: ARRAY
86462: PPUSH
86463: CALL_OW 314
86467: NOT
86468: IFFALSE 86571
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86470: LD_ADDR_VAR 0 9
86474: PUSH
86475: LD_INT 81
86477: PUSH
86478: LD_VAR 0 4
86482: PUSH
86483: LD_VAR 0 7
86487: ARRAY
86488: PPUSH
86489: CALL_OW 255
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PPUSH
86498: CALL_OW 69
86502: PPUSH
86503: LD_VAR 0 4
86507: PUSH
86508: LD_VAR 0 7
86512: ARRAY
86513: PPUSH
86514: CALL_OW 74
86518: ST_TO_ADDR
// if k then
86519: LD_VAR 0 9
86523: IFFALSE 86571
// if GetDistUnits ( group [ i ] , k ) > 10 then
86525: LD_VAR 0 4
86529: PUSH
86530: LD_VAR 0 7
86534: ARRAY
86535: PPUSH
86536: LD_VAR 0 9
86540: PPUSH
86541: CALL_OW 296
86545: PUSH
86546: LD_INT 10
86548: GREATER
86549: IFFALSE 86571
// ComMoveUnit ( group [ i ] , k ) ;
86551: LD_VAR 0 4
86555: PUSH
86556: LD_VAR 0 7
86560: ARRAY
86561: PPUSH
86562: LD_VAR 0 9
86566: PPUSH
86567: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86571: LD_VAR 0 4
86575: PUSH
86576: LD_VAR 0 7
86580: ARRAY
86581: PPUSH
86582: CALL_OW 256
86586: PUSH
86587: LD_INT 250
86589: LESS
86590: PUSH
86591: LD_VAR 0 4
86595: PUSH
86596: LD_VAR 0 7
86600: ARRAY
86601: PUSH
86602: LD_INT 21
86604: PUSH
86605: LD_INT 2
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 23
86614: PUSH
86615: LD_INT 2
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PPUSH
86626: CALL_OW 69
86630: IN
86631: AND
86632: IFFALSE 86757
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86634: LD_ADDR_VAR 0 9
86638: PUSH
86639: LD_OWVAR 3
86643: PUSH
86644: LD_VAR 0 4
86648: PUSH
86649: LD_VAR 0 7
86653: ARRAY
86654: DIFF
86655: PPUSH
86656: LD_VAR 0 4
86660: PUSH
86661: LD_VAR 0 7
86665: ARRAY
86666: PPUSH
86667: CALL_OW 74
86671: ST_TO_ADDR
// if not k then
86672: LD_VAR 0 9
86676: NOT
86677: IFFALSE 86681
// continue ;
86679: GO 83122
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86681: LD_VAR 0 9
86685: PUSH
86686: LD_INT 81
86688: PUSH
86689: LD_VAR 0 4
86693: PUSH
86694: LD_VAR 0 7
86698: ARRAY
86699: PPUSH
86700: CALL_OW 255
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PPUSH
86709: CALL_OW 69
86713: IN
86714: PUSH
86715: LD_VAR 0 9
86719: PPUSH
86720: LD_VAR 0 4
86724: PUSH
86725: LD_VAR 0 7
86729: ARRAY
86730: PPUSH
86731: CALL_OW 296
86735: PUSH
86736: LD_INT 5
86738: LESS
86739: AND
86740: IFFALSE 86757
// ComAutodestruct ( group [ i ] ) ;
86742: LD_VAR 0 4
86746: PUSH
86747: LD_VAR 0 7
86751: ARRAY
86752: PPUSH
86753: CALL 81217 0 1
// end ; if f_attack_depot then
86757: LD_VAR 0 25
86761: IFFALSE 86873
// begin k := 6 ;
86763: LD_ADDR_VAR 0 9
86767: PUSH
86768: LD_INT 6
86770: ST_TO_ADDR
// if tmp < k then
86771: LD_VAR 0 14
86775: PUSH
86776: LD_VAR 0 9
86780: LESS
86781: IFFALSE 86793
// k := tmp ;
86783: LD_ADDR_VAR 0 9
86787: PUSH
86788: LD_VAR 0 14
86792: ST_TO_ADDR
// for j = 1 to k do
86793: LD_ADDR_VAR 0 8
86797: PUSH
86798: DOUBLE
86799: LD_INT 1
86801: DEC
86802: ST_TO_ADDR
86803: LD_VAR 0 9
86807: PUSH
86808: FOR_TO
86809: IFFALSE 86871
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86811: LD_VAR 0 8
86815: PPUSH
86816: CALL_OW 266
86820: PUSH
86821: LD_INT 0
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: IN
86831: IFFALSE 86869
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86833: LD_VAR 0 4
86837: PUSH
86838: LD_VAR 0 7
86842: ARRAY
86843: PPUSH
86844: LD_VAR 0 14
86848: PUSH
86849: LD_VAR 0 8
86853: ARRAY
86854: PPUSH
86855: CALL_OW 115
// attacking := true ;
86859: LD_ADDR_VAR 0 29
86863: PUSH
86864: LD_INT 1
86866: ST_TO_ADDR
// break ;
86867: GO 86871
// end ;
86869: GO 86808
86871: POP
86872: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86873: LD_VAR 0 4
86877: PUSH
86878: LD_VAR 0 7
86882: ARRAY
86883: PPUSH
86884: CALL_OW 302
86888: PUSH
86889: LD_VAR 0 29
86893: NOT
86894: AND
86895: IFFALSE 87217
// begin if GetTag ( group [ i ] ) = 71 then
86897: LD_VAR 0 4
86901: PUSH
86902: LD_VAR 0 7
86906: ARRAY
86907: PPUSH
86908: CALL_OW 110
86912: PUSH
86913: LD_INT 71
86915: EQUAL
86916: IFFALSE 86957
// begin if HasTask ( group [ i ] ) then
86918: LD_VAR 0 4
86922: PUSH
86923: LD_VAR 0 7
86927: ARRAY
86928: PPUSH
86929: CALL_OW 314
86933: IFFALSE 86939
// continue else
86935: GO 83122
86937: GO 86957
// SetTag ( group [ i ] , 0 ) ;
86939: LD_VAR 0 4
86943: PUSH
86944: LD_VAR 0 7
86948: ARRAY
86949: PPUSH
86950: LD_INT 0
86952: PPUSH
86953: CALL_OW 109
// end ; k := 8 ;
86957: LD_ADDR_VAR 0 9
86961: PUSH
86962: LD_INT 8
86964: ST_TO_ADDR
// x := 0 ;
86965: LD_ADDR_VAR 0 10
86969: PUSH
86970: LD_INT 0
86972: ST_TO_ADDR
// if tmp < k then
86973: LD_VAR 0 14
86977: PUSH
86978: LD_VAR 0 9
86982: LESS
86983: IFFALSE 86995
// k := tmp ;
86985: LD_ADDR_VAR 0 9
86989: PUSH
86990: LD_VAR 0 14
86994: ST_TO_ADDR
// for j = 1 to k do
86995: LD_ADDR_VAR 0 8
86999: PUSH
87000: DOUBLE
87001: LD_INT 1
87003: DEC
87004: ST_TO_ADDR
87005: LD_VAR 0 9
87009: PUSH
87010: FOR_TO
87011: IFFALSE 87109
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87013: LD_VAR 0 14
87017: PUSH
87018: LD_VAR 0 8
87022: ARRAY
87023: PPUSH
87024: CALL_OW 247
87028: PUSH
87029: LD_INT 1
87031: EQUAL
87032: PUSH
87033: LD_VAR 0 14
87037: PUSH
87038: LD_VAR 0 8
87042: ARRAY
87043: PPUSH
87044: CALL_OW 256
87048: PUSH
87049: LD_INT 250
87051: LESS
87052: PUSH
87053: LD_VAR 0 20
87057: AND
87058: PUSH
87059: LD_VAR 0 20
87063: NOT
87064: PUSH
87065: LD_VAR 0 14
87069: PUSH
87070: LD_VAR 0 8
87074: ARRAY
87075: PPUSH
87076: CALL_OW 256
87080: PUSH
87081: LD_INT 250
87083: GREATEREQUAL
87084: AND
87085: OR
87086: AND
87087: IFFALSE 87107
// begin x := tmp [ j ] ;
87089: LD_ADDR_VAR 0 10
87093: PUSH
87094: LD_VAR 0 14
87098: PUSH
87099: LD_VAR 0 8
87103: ARRAY
87104: ST_TO_ADDR
// break ;
87105: GO 87109
// end ;
87107: GO 87010
87109: POP
87110: POP
// if x then
87111: LD_VAR 0 10
87115: IFFALSE 87139
// ComAttackUnit ( group [ i ] , x ) else
87117: LD_VAR 0 4
87121: PUSH
87122: LD_VAR 0 7
87126: ARRAY
87127: PPUSH
87128: LD_VAR 0 10
87132: PPUSH
87133: CALL_OW 115
87137: GO 87163
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87139: LD_VAR 0 4
87143: PUSH
87144: LD_VAR 0 7
87148: ARRAY
87149: PPUSH
87150: LD_VAR 0 14
87154: PUSH
87155: LD_INT 1
87157: ARRAY
87158: PPUSH
87159: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87163: LD_VAR 0 4
87167: PUSH
87168: LD_VAR 0 7
87172: ARRAY
87173: PPUSH
87174: CALL_OW 314
87178: NOT
87179: IFFALSE 87217
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87181: LD_VAR 0 4
87185: PUSH
87186: LD_VAR 0 7
87190: ARRAY
87191: PPUSH
87192: LD_VAR 0 14
87196: PPUSH
87197: LD_VAR 0 4
87201: PUSH
87202: LD_VAR 0 7
87206: ARRAY
87207: PPUSH
87208: CALL_OW 74
87212: PPUSH
87213: CALL_OW 115
// end ; end ; end ;
87217: GO 83122
87219: POP
87220: POP
// wait ( 0 0$1 ) ;
87221: LD_INT 35
87223: PPUSH
87224: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87228: LD_VAR 0 4
87232: PUSH
87233: EMPTY
87234: EQUAL
87235: PUSH
87236: LD_INT 81
87238: PUSH
87239: LD_VAR 0 35
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PPUSH
87248: CALL_OW 69
87252: NOT
87253: OR
87254: IFFALSE 83107
// end ;
87256: LD_VAR 0 2
87260: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87261: LD_INT 0
87263: PPUSH
87264: PPUSH
87265: PPUSH
87266: PPUSH
// if not base_units then
87267: LD_VAR 0 1
87271: NOT
87272: IFFALSE 87276
// exit ;
87274: GO 87363
// result := false ;
87276: LD_ADDR_VAR 0 2
87280: PUSH
87281: LD_INT 0
87283: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87284: LD_ADDR_VAR 0 5
87288: PUSH
87289: LD_VAR 0 1
87293: PPUSH
87294: LD_INT 21
87296: PUSH
87297: LD_INT 3
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PPUSH
87304: CALL_OW 72
87308: ST_TO_ADDR
// if not tmp then
87309: LD_VAR 0 5
87313: NOT
87314: IFFALSE 87318
// exit ;
87316: GO 87363
// for i in tmp do
87318: LD_ADDR_VAR 0 3
87322: PUSH
87323: LD_VAR 0 5
87327: PUSH
87328: FOR_IN
87329: IFFALSE 87361
// begin result := EnemyInRange ( i , 22 ) ;
87331: LD_ADDR_VAR 0 2
87335: PUSH
87336: LD_VAR 0 3
87340: PPUSH
87341: LD_INT 22
87343: PPUSH
87344: CALL 80900 0 2
87348: ST_TO_ADDR
// if result then
87349: LD_VAR 0 2
87353: IFFALSE 87359
// exit ;
87355: POP
87356: POP
87357: GO 87363
// end ;
87359: GO 87328
87361: POP
87362: POP
// end ;
87363: LD_VAR 0 2
87367: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87368: LD_INT 0
87370: PPUSH
87371: PPUSH
// if not units then
87372: LD_VAR 0 1
87376: NOT
87377: IFFALSE 87381
// exit ;
87379: GO 87451
// result := [ ] ;
87381: LD_ADDR_VAR 0 3
87385: PUSH
87386: EMPTY
87387: ST_TO_ADDR
// for i in units do
87388: LD_ADDR_VAR 0 4
87392: PUSH
87393: LD_VAR 0 1
87397: PUSH
87398: FOR_IN
87399: IFFALSE 87449
// if GetTag ( i ) = tag then
87401: LD_VAR 0 4
87405: PPUSH
87406: CALL_OW 110
87410: PUSH
87411: LD_VAR 0 2
87415: EQUAL
87416: IFFALSE 87447
// result := Insert ( result , result + 1 , i ) ;
87418: LD_ADDR_VAR 0 3
87422: PUSH
87423: LD_VAR 0 3
87427: PPUSH
87428: LD_VAR 0 3
87432: PUSH
87433: LD_INT 1
87435: PLUS
87436: PPUSH
87437: LD_VAR 0 4
87441: PPUSH
87442: CALL_OW 2
87446: ST_TO_ADDR
87447: GO 87398
87449: POP
87450: POP
// end ;
87451: LD_VAR 0 3
87455: RET
// export function IsDriver ( un ) ; begin
87456: LD_INT 0
87458: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87459: LD_ADDR_VAR 0 2
87463: PUSH
87464: LD_VAR 0 1
87468: PUSH
87469: LD_INT 55
87471: PUSH
87472: EMPTY
87473: LIST
87474: PPUSH
87475: CALL_OW 69
87479: IN
87480: ST_TO_ADDR
// end ;
87481: LD_VAR 0 2
87485: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87486: LD_INT 0
87488: PPUSH
87489: PPUSH
// list := [ ] ;
87490: LD_ADDR_VAR 0 5
87494: PUSH
87495: EMPTY
87496: ST_TO_ADDR
// case d of 0 :
87497: LD_VAR 0 3
87501: PUSH
87502: LD_INT 0
87504: DOUBLE
87505: EQUAL
87506: IFTRUE 87510
87508: GO 87643
87510: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87511: LD_ADDR_VAR 0 5
87515: PUSH
87516: LD_VAR 0 1
87520: PUSH
87521: LD_INT 4
87523: MINUS
87524: PUSH
87525: LD_VAR 0 2
87529: PUSH
87530: LD_INT 4
87532: MINUS
87533: PUSH
87534: LD_INT 2
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: LIST
87541: PUSH
87542: LD_VAR 0 1
87546: PUSH
87547: LD_INT 3
87549: MINUS
87550: PUSH
87551: LD_VAR 0 2
87555: PUSH
87556: LD_INT 1
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: LIST
87563: PUSH
87564: LD_VAR 0 1
87568: PUSH
87569: LD_INT 4
87571: PLUS
87572: PUSH
87573: LD_VAR 0 2
87577: PUSH
87578: LD_INT 4
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: LIST
87585: PUSH
87586: LD_VAR 0 1
87590: PUSH
87591: LD_INT 3
87593: PLUS
87594: PUSH
87595: LD_VAR 0 2
87599: PUSH
87600: LD_INT 3
87602: PLUS
87603: PUSH
87604: LD_INT 5
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: LIST
87611: PUSH
87612: LD_VAR 0 1
87616: PUSH
87617: LD_VAR 0 2
87621: PUSH
87622: LD_INT 4
87624: PLUS
87625: PUSH
87626: LD_INT 0
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: LIST
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: ST_TO_ADDR
// end ; 1 :
87641: GO 88341
87643: LD_INT 1
87645: DOUBLE
87646: EQUAL
87647: IFTRUE 87651
87649: GO 87784
87651: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87652: LD_ADDR_VAR 0 5
87656: PUSH
87657: LD_VAR 0 1
87661: PUSH
87662: LD_VAR 0 2
87666: PUSH
87667: LD_INT 4
87669: MINUS
87670: PUSH
87671: LD_INT 3
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: LIST
87678: PUSH
87679: LD_VAR 0 1
87683: PUSH
87684: LD_INT 3
87686: MINUS
87687: PUSH
87688: LD_VAR 0 2
87692: PUSH
87693: LD_INT 3
87695: MINUS
87696: PUSH
87697: LD_INT 2
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: LIST
87704: PUSH
87705: LD_VAR 0 1
87709: PUSH
87710: LD_INT 4
87712: MINUS
87713: PUSH
87714: LD_VAR 0 2
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: LIST
87726: PUSH
87727: LD_VAR 0 1
87731: PUSH
87732: LD_VAR 0 2
87736: PUSH
87737: LD_INT 3
87739: PLUS
87740: PUSH
87741: LD_INT 0
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: LIST
87748: PUSH
87749: LD_VAR 0 1
87753: PUSH
87754: LD_INT 4
87756: PLUS
87757: PUSH
87758: LD_VAR 0 2
87762: PUSH
87763: LD_INT 4
87765: PLUS
87766: PUSH
87767: LD_INT 5
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: LIST
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: ST_TO_ADDR
// end ; 2 :
87782: GO 88341
87784: LD_INT 2
87786: DOUBLE
87787: EQUAL
87788: IFTRUE 87792
87790: GO 87921
87792: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87793: LD_ADDR_VAR 0 5
87797: PUSH
87798: LD_VAR 0 1
87802: PUSH
87803: LD_VAR 0 2
87807: PUSH
87808: LD_INT 3
87810: MINUS
87811: PUSH
87812: LD_INT 3
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: LIST
87819: PUSH
87820: LD_VAR 0 1
87824: PUSH
87825: LD_INT 4
87827: PLUS
87828: PUSH
87829: LD_VAR 0 2
87833: PUSH
87834: LD_INT 4
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: LIST
87841: PUSH
87842: LD_VAR 0 1
87846: PUSH
87847: LD_VAR 0 2
87851: PUSH
87852: LD_INT 4
87854: PLUS
87855: PUSH
87856: LD_INT 0
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: LIST
87863: PUSH
87864: LD_VAR 0 1
87868: PUSH
87869: LD_INT 3
87871: MINUS
87872: PUSH
87873: LD_VAR 0 2
87877: PUSH
87878: LD_INT 1
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: LIST
87885: PUSH
87886: LD_VAR 0 1
87890: PUSH
87891: LD_INT 4
87893: MINUS
87894: PUSH
87895: LD_VAR 0 2
87899: PUSH
87900: LD_INT 4
87902: MINUS
87903: PUSH
87904: LD_INT 2
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: LIST
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: ST_TO_ADDR
// end ; 3 :
87919: GO 88341
87921: LD_INT 3
87923: DOUBLE
87924: EQUAL
87925: IFTRUE 87929
87927: GO 88062
87929: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87930: LD_ADDR_VAR 0 5
87934: PUSH
87935: LD_VAR 0 1
87939: PUSH
87940: LD_INT 3
87942: PLUS
87943: PUSH
87944: LD_VAR 0 2
87948: PUSH
87949: LD_INT 4
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: LIST
87956: PUSH
87957: LD_VAR 0 1
87961: PUSH
87962: LD_INT 4
87964: PLUS
87965: PUSH
87966: LD_VAR 0 2
87970: PUSH
87971: LD_INT 4
87973: PLUS
87974: PUSH
87975: LD_INT 5
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: LIST
87982: PUSH
87983: LD_VAR 0 1
87987: PUSH
87988: LD_INT 4
87990: MINUS
87991: PUSH
87992: LD_VAR 0 2
87996: PUSH
87997: LD_INT 1
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: LIST
88004: PUSH
88005: LD_VAR 0 1
88009: PUSH
88010: LD_VAR 0 2
88014: PUSH
88015: LD_INT 4
88017: MINUS
88018: PUSH
88019: LD_INT 3
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: LIST
88026: PUSH
88027: LD_VAR 0 1
88031: PUSH
88032: LD_INT 3
88034: MINUS
88035: PUSH
88036: LD_VAR 0 2
88040: PUSH
88041: LD_INT 3
88043: MINUS
88044: PUSH
88045: LD_INT 2
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: LIST
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: ST_TO_ADDR
// end ; 4 :
88060: GO 88341
88062: LD_INT 4
88064: DOUBLE
88065: EQUAL
88066: IFTRUE 88070
88068: GO 88203
88070: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88071: LD_ADDR_VAR 0 5
88075: PUSH
88076: LD_VAR 0 1
88080: PUSH
88081: LD_VAR 0 2
88085: PUSH
88086: LD_INT 4
88088: PLUS
88089: PUSH
88090: LD_INT 0
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: LIST
88097: PUSH
88098: LD_VAR 0 1
88102: PUSH
88103: LD_INT 3
88105: PLUS
88106: PUSH
88107: LD_VAR 0 2
88111: PUSH
88112: LD_INT 3
88114: PLUS
88115: PUSH
88116: LD_INT 5
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: LIST
88123: PUSH
88124: LD_VAR 0 1
88128: PUSH
88129: LD_INT 4
88131: PLUS
88132: PUSH
88133: LD_VAR 0 2
88137: PUSH
88138: LD_INT 4
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: LIST
88145: PUSH
88146: LD_VAR 0 1
88150: PUSH
88151: LD_VAR 0 2
88155: PUSH
88156: LD_INT 3
88158: MINUS
88159: PUSH
88160: LD_INT 3
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: LIST
88167: PUSH
88168: LD_VAR 0 1
88172: PUSH
88173: LD_INT 4
88175: MINUS
88176: PUSH
88177: LD_VAR 0 2
88181: PUSH
88182: LD_INT 4
88184: MINUS
88185: PUSH
88186: LD_INT 2
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: LIST
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: ST_TO_ADDR
// end ; 5 :
88201: GO 88341
88203: LD_INT 5
88205: DOUBLE
88206: EQUAL
88207: IFTRUE 88211
88209: GO 88340
88211: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88212: LD_ADDR_VAR 0 5
88216: PUSH
88217: LD_VAR 0 1
88221: PUSH
88222: LD_INT 4
88224: MINUS
88225: PUSH
88226: LD_VAR 0 2
88230: PUSH
88231: LD_INT 1
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: LIST
88238: PUSH
88239: LD_VAR 0 1
88243: PUSH
88244: LD_VAR 0 2
88248: PUSH
88249: LD_INT 4
88251: MINUS
88252: PUSH
88253: LD_INT 3
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: LIST
88260: PUSH
88261: LD_VAR 0 1
88265: PUSH
88266: LD_INT 4
88268: PLUS
88269: PUSH
88270: LD_VAR 0 2
88274: PUSH
88275: LD_INT 4
88277: PLUS
88278: PUSH
88279: LD_INT 5
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: LIST
88286: PUSH
88287: LD_VAR 0 1
88291: PUSH
88292: LD_INT 3
88294: PLUS
88295: PUSH
88296: LD_VAR 0 2
88300: PUSH
88301: LD_INT 4
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: PUSH
88309: LD_VAR 0 1
88313: PUSH
88314: LD_VAR 0 2
88318: PUSH
88319: LD_INT 3
88321: PLUS
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: LIST
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: ST_TO_ADDR
// end ; end ;
88338: GO 88341
88340: POP
// result := list ;
88341: LD_ADDR_VAR 0 4
88345: PUSH
88346: LD_VAR 0 5
88350: ST_TO_ADDR
// end ;
88351: LD_VAR 0 4
88355: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88356: LD_INT 0
88358: PPUSH
88359: PPUSH
88360: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88361: LD_VAR 0 1
88365: NOT
88366: PUSH
88367: LD_VAR 0 2
88371: PUSH
88372: LD_INT 1
88374: PUSH
88375: LD_INT 2
88377: PUSH
88378: LD_INT 3
88380: PUSH
88381: LD_INT 4
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: IN
88390: NOT
88391: OR
88392: IFFALSE 88396
// exit ;
88394: GO 88488
// tmp := [ ] ;
88396: LD_ADDR_VAR 0 5
88400: PUSH
88401: EMPTY
88402: ST_TO_ADDR
// for i in units do
88403: LD_ADDR_VAR 0 4
88407: PUSH
88408: LD_VAR 0 1
88412: PUSH
88413: FOR_IN
88414: IFFALSE 88457
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88416: LD_ADDR_VAR 0 5
88420: PUSH
88421: LD_VAR 0 5
88425: PPUSH
88426: LD_VAR 0 5
88430: PUSH
88431: LD_INT 1
88433: PLUS
88434: PPUSH
88435: LD_VAR 0 4
88439: PPUSH
88440: LD_VAR 0 2
88444: PPUSH
88445: CALL_OW 259
88449: PPUSH
88450: CALL_OW 2
88454: ST_TO_ADDR
88455: GO 88413
88457: POP
88458: POP
// if not tmp then
88459: LD_VAR 0 5
88463: NOT
88464: IFFALSE 88468
// exit ;
88466: GO 88488
// result := SortListByListDesc ( units , tmp ) ;
88468: LD_ADDR_VAR 0 3
88472: PUSH
88473: LD_VAR 0 1
88477: PPUSH
88478: LD_VAR 0 5
88482: PPUSH
88483: CALL_OW 77
88487: ST_TO_ADDR
// end ;
88488: LD_VAR 0 3
88492: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88493: LD_INT 0
88495: PPUSH
88496: PPUSH
88497: PPUSH
// x := GetX ( building ) ;
88498: LD_ADDR_VAR 0 4
88502: PUSH
88503: LD_VAR 0 2
88507: PPUSH
88508: CALL_OW 250
88512: ST_TO_ADDR
// y := GetY ( building ) ;
88513: LD_ADDR_VAR 0 5
88517: PUSH
88518: LD_VAR 0 2
88522: PPUSH
88523: CALL_OW 251
88527: ST_TO_ADDR
// if GetTaskList ( unit ) then
88528: LD_VAR 0 1
88532: PPUSH
88533: CALL_OW 437
88537: IFFALSE 88632
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88539: LD_STRING e
88541: PUSH
88542: LD_VAR 0 1
88546: PPUSH
88547: CALL_OW 437
88551: PUSH
88552: LD_INT 1
88554: ARRAY
88555: PUSH
88556: LD_INT 1
88558: ARRAY
88559: EQUAL
88560: PUSH
88561: LD_VAR 0 4
88565: PUSH
88566: LD_VAR 0 1
88570: PPUSH
88571: CALL_OW 437
88575: PUSH
88576: LD_INT 1
88578: ARRAY
88579: PUSH
88580: LD_INT 2
88582: ARRAY
88583: EQUAL
88584: AND
88585: PUSH
88586: LD_VAR 0 5
88590: PUSH
88591: LD_VAR 0 1
88595: PPUSH
88596: CALL_OW 437
88600: PUSH
88601: LD_INT 1
88603: ARRAY
88604: PUSH
88605: LD_INT 3
88607: ARRAY
88608: EQUAL
88609: AND
88610: IFFALSE 88622
// result := true else
88612: LD_ADDR_VAR 0 3
88616: PUSH
88617: LD_INT 1
88619: ST_TO_ADDR
88620: GO 88630
// result := false ;
88622: LD_ADDR_VAR 0 3
88626: PUSH
88627: LD_INT 0
88629: ST_TO_ADDR
// end else
88630: GO 88640
// result := false ;
88632: LD_ADDR_VAR 0 3
88636: PUSH
88637: LD_INT 0
88639: ST_TO_ADDR
// end ;
88640: LD_VAR 0 3
88644: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88645: LD_INT 0
88647: PPUSH
88648: PPUSH
88649: PPUSH
88650: PPUSH
// if not unit or not area then
88651: LD_VAR 0 1
88655: NOT
88656: PUSH
88657: LD_VAR 0 2
88661: NOT
88662: OR
88663: IFFALSE 88667
// exit ;
88665: GO 88831
// tmp := AreaToList ( area , i ) ;
88667: LD_ADDR_VAR 0 6
88671: PUSH
88672: LD_VAR 0 2
88676: PPUSH
88677: LD_VAR 0 5
88681: PPUSH
88682: CALL_OW 517
88686: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88687: LD_ADDR_VAR 0 5
88691: PUSH
88692: DOUBLE
88693: LD_INT 1
88695: DEC
88696: ST_TO_ADDR
88697: LD_VAR 0 6
88701: PUSH
88702: LD_INT 1
88704: ARRAY
88705: PUSH
88706: FOR_TO
88707: IFFALSE 88829
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88709: LD_ADDR_VAR 0 7
88713: PUSH
88714: LD_VAR 0 6
88718: PUSH
88719: LD_INT 1
88721: ARRAY
88722: PUSH
88723: LD_VAR 0 5
88727: ARRAY
88728: PUSH
88729: LD_VAR 0 6
88733: PUSH
88734: LD_INT 2
88736: ARRAY
88737: PUSH
88738: LD_VAR 0 5
88742: ARRAY
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88748: LD_VAR 0 7
88752: PUSH
88753: LD_INT 1
88755: ARRAY
88756: PPUSH
88757: LD_VAR 0 7
88761: PUSH
88762: LD_INT 2
88764: ARRAY
88765: PPUSH
88766: CALL_OW 428
88770: PUSH
88771: LD_INT 0
88773: EQUAL
88774: IFFALSE 88827
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88776: LD_VAR 0 1
88780: PPUSH
88781: LD_VAR 0 7
88785: PUSH
88786: LD_INT 1
88788: ARRAY
88789: PPUSH
88790: LD_VAR 0 7
88794: PUSH
88795: LD_INT 2
88797: ARRAY
88798: PPUSH
88799: LD_VAR 0 3
88803: PPUSH
88804: CALL_OW 48
// result := IsPlaced ( unit ) ;
88808: LD_ADDR_VAR 0 4
88812: PUSH
88813: LD_VAR 0 1
88817: PPUSH
88818: CALL_OW 305
88822: ST_TO_ADDR
// exit ;
88823: POP
88824: POP
88825: GO 88831
// end ; end ;
88827: GO 88706
88829: POP
88830: POP
// end ;
88831: LD_VAR 0 4
88835: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88836: LD_INT 0
88838: PPUSH
88839: PPUSH
88840: PPUSH
// if not side or side > 8 then
88841: LD_VAR 0 1
88845: NOT
88846: PUSH
88847: LD_VAR 0 1
88851: PUSH
88852: LD_INT 8
88854: GREATER
88855: OR
88856: IFFALSE 88860
// exit ;
88858: GO 89047
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88860: LD_ADDR_VAR 0 4
88864: PUSH
88865: LD_INT 22
88867: PUSH
88868: LD_VAR 0 1
88872: PUSH
88873: EMPTY
88874: LIST
88875: LIST
88876: PUSH
88877: LD_INT 21
88879: PUSH
88880: LD_INT 3
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PPUSH
88891: CALL_OW 69
88895: ST_TO_ADDR
// if not tmp then
88896: LD_VAR 0 4
88900: NOT
88901: IFFALSE 88905
// exit ;
88903: GO 89047
// enable_addtolog := true ;
88905: LD_ADDR_OWVAR 81
88909: PUSH
88910: LD_INT 1
88912: ST_TO_ADDR
// AddToLog ( [ ) ;
88913: LD_STRING [
88915: PPUSH
88916: CALL_OW 561
// for i in tmp do
88920: LD_ADDR_VAR 0 3
88924: PUSH
88925: LD_VAR 0 4
88929: PUSH
88930: FOR_IN
88931: IFFALSE 89038
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88933: LD_STRING [
88935: PUSH
88936: LD_VAR 0 3
88940: PPUSH
88941: CALL_OW 266
88945: STR
88946: PUSH
88947: LD_STRING , 
88949: STR
88950: PUSH
88951: LD_VAR 0 3
88955: PPUSH
88956: CALL_OW 250
88960: STR
88961: PUSH
88962: LD_STRING , 
88964: STR
88965: PUSH
88966: LD_VAR 0 3
88970: PPUSH
88971: CALL_OW 251
88975: STR
88976: PUSH
88977: LD_STRING , 
88979: STR
88980: PUSH
88981: LD_VAR 0 3
88985: PPUSH
88986: CALL_OW 254
88990: STR
88991: PUSH
88992: LD_STRING , 
88994: STR
88995: PUSH
88996: LD_VAR 0 3
89000: PPUSH
89001: LD_INT 1
89003: PPUSH
89004: CALL_OW 268
89008: STR
89009: PUSH
89010: LD_STRING , 
89012: STR
89013: PUSH
89014: LD_VAR 0 3
89018: PPUSH
89019: LD_INT 2
89021: PPUSH
89022: CALL_OW 268
89026: STR
89027: PUSH
89028: LD_STRING ],
89030: STR
89031: PPUSH
89032: CALL_OW 561
// end ;
89036: GO 88930
89038: POP
89039: POP
// AddToLog ( ]; ) ;
89040: LD_STRING ];
89042: PPUSH
89043: CALL_OW 561
// end ;
89047: LD_VAR 0 2
89051: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89052: LD_INT 0
89054: PPUSH
89055: PPUSH
89056: PPUSH
89057: PPUSH
89058: PPUSH
// if not area or not rate or not max then
89059: LD_VAR 0 1
89063: NOT
89064: PUSH
89065: LD_VAR 0 2
89069: NOT
89070: OR
89071: PUSH
89072: LD_VAR 0 4
89076: NOT
89077: OR
89078: IFFALSE 89082
// exit ;
89080: GO 89274
// while 1 do
89082: LD_INT 1
89084: IFFALSE 89274
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89086: LD_ADDR_VAR 0 9
89090: PUSH
89091: LD_VAR 0 1
89095: PPUSH
89096: LD_INT 1
89098: PPUSH
89099: CALL_OW 287
89103: PUSH
89104: LD_INT 10
89106: MUL
89107: ST_TO_ADDR
// r := rate / 10 ;
89108: LD_ADDR_VAR 0 7
89112: PUSH
89113: LD_VAR 0 2
89117: PUSH
89118: LD_INT 10
89120: DIVREAL
89121: ST_TO_ADDR
// time := 1 1$00 ;
89122: LD_ADDR_VAR 0 8
89126: PUSH
89127: LD_INT 2100
89129: ST_TO_ADDR
// if amount < min then
89130: LD_VAR 0 9
89134: PUSH
89135: LD_VAR 0 3
89139: LESS
89140: IFFALSE 89158
// r := r * 2 else
89142: LD_ADDR_VAR 0 7
89146: PUSH
89147: LD_VAR 0 7
89151: PUSH
89152: LD_INT 2
89154: MUL
89155: ST_TO_ADDR
89156: GO 89184
// if amount > max then
89158: LD_VAR 0 9
89162: PUSH
89163: LD_VAR 0 4
89167: GREATER
89168: IFFALSE 89184
// r := r / 2 ;
89170: LD_ADDR_VAR 0 7
89174: PUSH
89175: LD_VAR 0 7
89179: PUSH
89180: LD_INT 2
89182: DIVREAL
89183: ST_TO_ADDR
// time := time / r ;
89184: LD_ADDR_VAR 0 8
89188: PUSH
89189: LD_VAR 0 8
89193: PUSH
89194: LD_VAR 0 7
89198: DIVREAL
89199: ST_TO_ADDR
// if time < 0 then
89200: LD_VAR 0 8
89204: PUSH
89205: LD_INT 0
89207: LESS
89208: IFFALSE 89225
// time := time * - 1 ;
89210: LD_ADDR_VAR 0 8
89214: PUSH
89215: LD_VAR 0 8
89219: PUSH
89220: LD_INT 1
89222: NEG
89223: MUL
89224: ST_TO_ADDR
// wait ( time ) ;
89225: LD_VAR 0 8
89229: PPUSH
89230: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89234: LD_INT 35
89236: PPUSH
89237: LD_INT 875
89239: PPUSH
89240: CALL_OW 12
89244: PPUSH
89245: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89249: LD_INT 1
89251: PPUSH
89252: LD_INT 5
89254: PPUSH
89255: CALL_OW 12
89259: PPUSH
89260: LD_VAR 0 1
89264: PPUSH
89265: LD_INT 1
89267: PPUSH
89268: CALL_OW 55
// end ;
89272: GO 89082
// end ;
89274: LD_VAR 0 5
89278: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89279: LD_INT 0
89281: PPUSH
89282: PPUSH
89283: PPUSH
89284: PPUSH
89285: PPUSH
89286: PPUSH
89287: PPUSH
89288: PPUSH
// if not turrets or not factories then
89289: LD_VAR 0 1
89293: NOT
89294: PUSH
89295: LD_VAR 0 2
89299: NOT
89300: OR
89301: IFFALSE 89305
// exit ;
89303: GO 89612
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89305: LD_ADDR_VAR 0 10
89309: PUSH
89310: LD_INT 5
89312: PUSH
89313: LD_INT 6
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 2
89322: PUSH
89323: LD_INT 4
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 3
89332: PUSH
89333: LD_INT 5
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 24
89347: PUSH
89348: LD_INT 25
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 23
89357: PUSH
89358: LD_INT 27
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 42
89371: PUSH
89372: LD_INT 43
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 44
89381: PUSH
89382: LD_INT 46
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 45
89391: PUSH
89392: LD_INT 47
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: LIST
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: LIST
89408: ST_TO_ADDR
// result := [ ] ;
89409: LD_ADDR_VAR 0 3
89413: PUSH
89414: EMPTY
89415: ST_TO_ADDR
// for i in turrets do
89416: LD_ADDR_VAR 0 4
89420: PUSH
89421: LD_VAR 0 1
89425: PUSH
89426: FOR_IN
89427: IFFALSE 89610
// begin nat := GetNation ( i ) ;
89429: LD_ADDR_VAR 0 7
89433: PUSH
89434: LD_VAR 0 4
89438: PPUSH
89439: CALL_OW 248
89443: ST_TO_ADDR
// weapon := 0 ;
89444: LD_ADDR_VAR 0 8
89448: PUSH
89449: LD_INT 0
89451: ST_TO_ADDR
// if not nat then
89452: LD_VAR 0 7
89456: NOT
89457: IFFALSE 89461
// continue ;
89459: GO 89426
// for j in list [ nat ] do
89461: LD_ADDR_VAR 0 5
89465: PUSH
89466: LD_VAR 0 10
89470: PUSH
89471: LD_VAR 0 7
89475: ARRAY
89476: PUSH
89477: FOR_IN
89478: IFFALSE 89519
// if GetBWeapon ( i ) = j [ 1 ] then
89480: LD_VAR 0 4
89484: PPUSH
89485: CALL_OW 269
89489: PUSH
89490: LD_VAR 0 5
89494: PUSH
89495: LD_INT 1
89497: ARRAY
89498: EQUAL
89499: IFFALSE 89517
// begin weapon := j [ 2 ] ;
89501: LD_ADDR_VAR 0 8
89505: PUSH
89506: LD_VAR 0 5
89510: PUSH
89511: LD_INT 2
89513: ARRAY
89514: ST_TO_ADDR
// break ;
89515: GO 89519
// end ;
89517: GO 89477
89519: POP
89520: POP
// if not weapon then
89521: LD_VAR 0 8
89525: NOT
89526: IFFALSE 89530
// continue ;
89528: GO 89426
// for k in factories do
89530: LD_ADDR_VAR 0 6
89534: PUSH
89535: LD_VAR 0 2
89539: PUSH
89540: FOR_IN
89541: IFFALSE 89606
// begin weapons := AvailableWeaponList ( k ) ;
89543: LD_ADDR_VAR 0 9
89547: PUSH
89548: LD_VAR 0 6
89552: PPUSH
89553: CALL_OW 478
89557: ST_TO_ADDR
// if not weapons then
89558: LD_VAR 0 9
89562: NOT
89563: IFFALSE 89567
// continue ;
89565: GO 89540
// if weapon in weapons then
89567: LD_VAR 0 8
89571: PUSH
89572: LD_VAR 0 9
89576: IN
89577: IFFALSE 89604
// begin result := [ i , weapon ] ;
89579: LD_ADDR_VAR 0 3
89583: PUSH
89584: LD_VAR 0 4
89588: PUSH
89589: LD_VAR 0 8
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: ST_TO_ADDR
// exit ;
89598: POP
89599: POP
89600: POP
89601: POP
89602: GO 89612
// end ; end ;
89604: GO 89540
89606: POP
89607: POP
// end ;
89608: GO 89426
89610: POP
89611: POP
// end ;
89612: LD_VAR 0 3
89616: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89617: LD_INT 0
89619: PPUSH
// if not side or side > 8 then
89620: LD_VAR 0 3
89624: NOT
89625: PUSH
89626: LD_VAR 0 3
89630: PUSH
89631: LD_INT 8
89633: GREATER
89634: OR
89635: IFFALSE 89639
// exit ;
89637: GO 89698
// if not range then
89639: LD_VAR 0 4
89643: NOT
89644: IFFALSE 89655
// range := - 12 ;
89646: LD_ADDR_VAR 0 4
89650: PUSH
89651: LD_INT 12
89653: NEG
89654: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89655: LD_VAR 0 1
89659: PPUSH
89660: LD_VAR 0 2
89664: PPUSH
89665: LD_VAR 0 3
89669: PPUSH
89670: LD_VAR 0 4
89674: PPUSH
89675: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89679: LD_VAR 0 1
89683: PPUSH
89684: LD_VAR 0 2
89688: PPUSH
89689: LD_VAR 0 3
89693: PPUSH
89694: CALL_OW 331
// end ;
89698: LD_VAR 0 5
89702: RET
// export function Video ( mode ) ; begin
89703: LD_INT 0
89705: PPUSH
// ingame_video = mode ;
89706: LD_ADDR_OWVAR 52
89710: PUSH
89711: LD_VAR 0 1
89715: ST_TO_ADDR
// interface_hidden = mode ;
89716: LD_ADDR_OWVAR 54
89720: PUSH
89721: LD_VAR 0 1
89725: ST_TO_ADDR
// end ;
89726: LD_VAR 0 2
89730: RET
// export function Join ( array , element ) ; begin
89731: LD_INT 0
89733: PPUSH
// result := array ^ element ;
89734: LD_ADDR_VAR 0 3
89738: PUSH
89739: LD_VAR 0 1
89743: PUSH
89744: LD_VAR 0 2
89748: ADD
89749: ST_TO_ADDR
// end ;
89750: LD_VAR 0 3
89754: RET
// export function JoinUnion ( array , element ) ; begin
89755: LD_INT 0
89757: PPUSH
// result := array union element ;
89758: LD_ADDR_VAR 0 3
89762: PUSH
89763: LD_VAR 0 1
89767: PUSH
89768: LD_VAR 0 2
89772: UNION
89773: ST_TO_ADDR
// end ;
89774: LD_VAR 0 3
89778: RET
// export function GetBehemoths ( side ) ; begin
89779: LD_INT 0
89781: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
89782: LD_ADDR_VAR 0 2
89786: PUSH
89787: LD_INT 22
89789: PUSH
89790: LD_VAR 0 1
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 31
89801: PUSH
89802: LD_INT 25
89804: PUSH
89805: EMPTY
89806: LIST
89807: LIST
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PPUSH
89813: CALL_OW 69
89817: ST_TO_ADDR
// end ;
89818: LD_VAR 0 2
89822: RET
// export function Shuffle ( array ) ; var i , index ; begin
89823: LD_INT 0
89825: PPUSH
89826: PPUSH
89827: PPUSH
// result := [ ] ;
89828: LD_ADDR_VAR 0 2
89832: PUSH
89833: EMPTY
89834: ST_TO_ADDR
// if not array then
89835: LD_VAR 0 1
89839: NOT
89840: IFFALSE 89844
// exit ;
89842: GO 89943
// Randomize ;
89844: CALL_OW 10
// for i = array downto 1 do
89848: LD_ADDR_VAR 0 3
89852: PUSH
89853: DOUBLE
89854: LD_VAR 0 1
89858: INC
89859: ST_TO_ADDR
89860: LD_INT 1
89862: PUSH
89863: FOR_DOWNTO
89864: IFFALSE 89941
// begin index := rand ( 1 , array ) ;
89866: LD_ADDR_VAR 0 4
89870: PUSH
89871: LD_INT 1
89873: PPUSH
89874: LD_VAR 0 1
89878: PPUSH
89879: CALL_OW 12
89883: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89884: LD_ADDR_VAR 0 2
89888: PUSH
89889: LD_VAR 0 2
89893: PPUSH
89894: LD_VAR 0 2
89898: PUSH
89899: LD_INT 1
89901: PLUS
89902: PPUSH
89903: LD_VAR 0 1
89907: PUSH
89908: LD_VAR 0 4
89912: ARRAY
89913: PPUSH
89914: CALL_OW 2
89918: ST_TO_ADDR
// array := Delete ( array , index ) ;
89919: LD_ADDR_VAR 0 1
89923: PUSH
89924: LD_VAR 0 1
89928: PPUSH
89929: LD_VAR 0 4
89933: PPUSH
89934: CALL_OW 3
89938: ST_TO_ADDR
// end ;
89939: GO 89863
89941: POP
89942: POP
// end ;
89943: LD_VAR 0 2
89947: RET
// export function GetBaseMaterials ( base ) ; begin
89948: LD_INT 0
89950: PPUSH
// result := [ 0 , 0 , 0 ] ;
89951: LD_ADDR_VAR 0 2
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: LIST
89969: ST_TO_ADDR
// if not base then
89970: LD_VAR 0 1
89974: NOT
89975: IFFALSE 89979
// exit ;
89977: GO 90028
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89979: LD_ADDR_VAR 0 2
89983: PUSH
89984: LD_VAR 0 1
89988: PPUSH
89989: LD_INT 1
89991: PPUSH
89992: CALL_OW 275
89996: PUSH
89997: LD_VAR 0 1
90001: PPUSH
90002: LD_INT 2
90004: PPUSH
90005: CALL_OW 275
90009: PUSH
90010: LD_VAR 0 1
90014: PPUSH
90015: LD_INT 3
90017: PPUSH
90018: CALL_OW 275
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: LIST
90027: ST_TO_ADDR
// end ; end_of_file
90028: LD_VAR 0 2
90032: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90033: GO 90035
90035: DISABLE
// begin ru_radar := 98 ;
90036: LD_ADDR_EXP 92
90040: PUSH
90041: LD_INT 98
90043: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90044: LD_ADDR_EXP 93
90048: PUSH
90049: LD_INT 89
90051: ST_TO_ADDR
// us_hack := 99 ;
90052: LD_ADDR_EXP 94
90056: PUSH
90057: LD_INT 99
90059: ST_TO_ADDR
// us_artillery := 97 ;
90060: LD_ADDR_EXP 95
90064: PUSH
90065: LD_INT 97
90067: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90068: LD_ADDR_EXP 96
90072: PUSH
90073: LD_INT 91
90075: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
90076: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
90077: LD_INT 0
90079: PPUSH
90080: PPUSH
90081: PPUSH
90082: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90083: LD_VAR 0 1
90087: PPUSH
90088: CALL_OW 264
90092: PUSH
90093: LD_EXP 96
90097: EQUAL
90098: IFFALSE 90170
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90100: LD_INT 68
90102: PPUSH
90103: LD_VAR 0 1
90107: PPUSH
90108: CALL_OW 255
90112: PPUSH
90113: CALL_OW 321
90117: PUSH
90118: LD_INT 2
90120: EQUAL
90121: IFFALSE 90133
// eff := 70 else
90123: LD_ADDR_VAR 0 6
90127: PUSH
90128: LD_INT 70
90130: ST_TO_ADDR
90131: GO 90141
// eff := 30 ;
90133: LD_ADDR_VAR 0 6
90137: PUSH
90138: LD_INT 30
90140: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90141: LD_VAR 0 1
90145: PPUSH
90146: CALL_OW 250
90150: PPUSH
90151: LD_VAR 0 1
90155: PPUSH
90156: CALL_OW 251
90160: PPUSH
90161: LD_VAR 0 6
90165: PPUSH
90166: CALL_OW 495
// end ; end ;
90170: LD_VAR 0 4
90174: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
90175: LD_INT 0
90177: PPUSH
90178: PPUSH
90179: PPUSH
90180: PPUSH
90181: PPUSH
90182: PPUSH
// if cmd = 124 then
90183: LD_VAR 0 1
90187: PUSH
90188: LD_INT 124
90190: EQUAL
90191: IFFALSE 90397
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
90193: LD_ADDR_VAR 0 5
90197: PUSH
90198: LD_INT 2
90200: PUSH
90201: LD_INT 34
90203: PUSH
90204: LD_INT 53
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 34
90213: PUSH
90214: LD_INT 14
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: LIST
90225: PPUSH
90226: CALL_OW 69
90230: ST_TO_ADDR
// if not tmp then
90231: LD_VAR 0 5
90235: NOT
90236: IFFALSE 90240
// exit ;
90238: GO 90397
// for i in tmp do
90240: LD_ADDR_VAR 0 3
90244: PUSH
90245: LD_VAR 0 5
90249: PUSH
90250: FOR_IN
90251: IFFALSE 90395
// begin taskList := GetTaskList ( i ) ;
90253: LD_ADDR_VAR 0 6
90257: PUSH
90258: LD_VAR 0 3
90262: PPUSH
90263: CALL_OW 437
90267: ST_TO_ADDR
// if not taskList then
90268: LD_VAR 0 6
90272: NOT
90273: IFFALSE 90277
// continue ;
90275: GO 90250
// for j = 1 to taskList do
90277: LD_ADDR_VAR 0 4
90281: PUSH
90282: DOUBLE
90283: LD_INT 1
90285: DEC
90286: ST_TO_ADDR
90287: LD_VAR 0 6
90291: PUSH
90292: FOR_TO
90293: IFFALSE 90391
// if taskList [ j ] [ 1 ] = | then
90295: LD_VAR 0 6
90299: PUSH
90300: LD_VAR 0 4
90304: ARRAY
90305: PUSH
90306: LD_INT 1
90308: ARRAY
90309: PUSH
90310: LD_STRING |
90312: EQUAL
90313: IFFALSE 90389
// begin _taskList := Delete ( taskList , 1 ) ;
90315: LD_ADDR_VAR 0 7
90319: PUSH
90320: LD_VAR 0 6
90324: PPUSH
90325: LD_INT 1
90327: PPUSH
90328: CALL_OW 3
90332: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
90333: LD_VAR 0 3
90337: PPUSH
90338: LD_VAR 0 7
90342: PPUSH
90343: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
90347: LD_VAR 0 3
90351: PPUSH
90352: LD_VAR 0 6
90356: PUSH
90357: LD_VAR 0 4
90361: ARRAY
90362: PUSH
90363: LD_INT 2
90365: ARRAY
90366: PPUSH
90367: LD_VAR 0 6
90371: PUSH
90372: LD_VAR 0 4
90376: ARRAY
90377: PUSH
90378: LD_INT 3
90380: ARRAY
90381: PPUSH
90382: LD_INT 8
90384: PPUSH
90385: CALL 90402 0 4
// end ;
90389: GO 90292
90391: POP
90392: POP
// end ;
90393: GO 90250
90395: POP
90396: POP
// end ; end ;
90397: LD_VAR 0 2
90401: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90402: LD_INT 0
90404: PPUSH
90405: PPUSH
90406: PPUSH
90407: PPUSH
90408: PPUSH
90409: PPUSH
90410: PPUSH
90411: PPUSH
90412: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90413: LD_VAR 0 1
90417: NOT
90418: PUSH
90419: LD_VAR 0 2
90423: PPUSH
90424: LD_VAR 0 3
90428: PPUSH
90429: CALL_OW 488
90433: NOT
90434: OR
90435: PUSH
90436: LD_VAR 0 4
90440: NOT
90441: OR
90442: IFFALSE 90446
// exit ;
90444: GO 90786
// list := [ ] ;
90446: LD_ADDR_VAR 0 13
90450: PUSH
90451: EMPTY
90452: ST_TO_ADDR
// if x - r < 0 then
90453: LD_VAR 0 2
90457: PUSH
90458: LD_VAR 0 4
90462: MINUS
90463: PUSH
90464: LD_INT 0
90466: LESS
90467: IFFALSE 90479
// min_x := 0 else
90469: LD_ADDR_VAR 0 7
90473: PUSH
90474: LD_INT 0
90476: ST_TO_ADDR
90477: GO 90495
// min_x := x - r ;
90479: LD_ADDR_VAR 0 7
90483: PUSH
90484: LD_VAR 0 2
90488: PUSH
90489: LD_VAR 0 4
90493: MINUS
90494: ST_TO_ADDR
// if y - r < 0 then
90495: LD_VAR 0 3
90499: PUSH
90500: LD_VAR 0 4
90504: MINUS
90505: PUSH
90506: LD_INT 0
90508: LESS
90509: IFFALSE 90521
// min_y := 0 else
90511: LD_ADDR_VAR 0 8
90515: PUSH
90516: LD_INT 0
90518: ST_TO_ADDR
90519: GO 90537
// min_y := y - r ;
90521: LD_ADDR_VAR 0 8
90525: PUSH
90526: LD_VAR 0 3
90530: PUSH
90531: LD_VAR 0 4
90535: MINUS
90536: ST_TO_ADDR
// max_x := x + r ;
90537: LD_ADDR_VAR 0 9
90541: PUSH
90542: LD_VAR 0 2
90546: PUSH
90547: LD_VAR 0 4
90551: PLUS
90552: ST_TO_ADDR
// max_y := y + r ;
90553: LD_ADDR_VAR 0 10
90557: PUSH
90558: LD_VAR 0 3
90562: PUSH
90563: LD_VAR 0 4
90567: PLUS
90568: ST_TO_ADDR
// for _x = min_x to max_x do
90569: LD_ADDR_VAR 0 11
90573: PUSH
90574: DOUBLE
90575: LD_VAR 0 7
90579: DEC
90580: ST_TO_ADDR
90581: LD_VAR 0 9
90585: PUSH
90586: FOR_TO
90587: IFFALSE 90704
// for _y = min_y to max_y do
90589: LD_ADDR_VAR 0 12
90593: PUSH
90594: DOUBLE
90595: LD_VAR 0 8
90599: DEC
90600: ST_TO_ADDR
90601: LD_VAR 0 10
90605: PUSH
90606: FOR_TO
90607: IFFALSE 90700
// begin if not ValidHex ( _x , _y ) then
90609: LD_VAR 0 11
90613: PPUSH
90614: LD_VAR 0 12
90618: PPUSH
90619: CALL_OW 488
90623: NOT
90624: IFFALSE 90628
// continue ;
90626: GO 90606
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90628: LD_VAR 0 11
90632: PPUSH
90633: LD_VAR 0 12
90637: PPUSH
90638: CALL_OW 351
90642: PUSH
90643: LD_VAR 0 11
90647: PPUSH
90648: LD_VAR 0 12
90652: PPUSH
90653: CALL_OW 554
90657: AND
90658: IFFALSE 90698
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90660: LD_ADDR_VAR 0 13
90664: PUSH
90665: LD_VAR 0 13
90669: PPUSH
90670: LD_VAR 0 13
90674: PUSH
90675: LD_INT 1
90677: PLUS
90678: PPUSH
90679: LD_VAR 0 11
90683: PUSH
90684: LD_VAR 0 12
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PPUSH
90693: CALL_OW 2
90697: ST_TO_ADDR
// end ;
90698: GO 90606
90700: POP
90701: POP
90702: GO 90586
90704: POP
90705: POP
// if not list then
90706: LD_VAR 0 13
90710: NOT
90711: IFFALSE 90715
// exit ;
90713: GO 90786
// for i in list do
90715: LD_ADDR_VAR 0 6
90719: PUSH
90720: LD_VAR 0 13
90724: PUSH
90725: FOR_IN
90726: IFFALSE 90784
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90728: LD_VAR 0 1
90732: PPUSH
90733: LD_STRING M
90735: PUSH
90736: LD_VAR 0 6
90740: PUSH
90741: LD_INT 1
90743: ARRAY
90744: PUSH
90745: LD_VAR 0 6
90749: PUSH
90750: LD_INT 2
90752: ARRAY
90753: PUSH
90754: LD_INT 0
90756: PUSH
90757: LD_INT 0
90759: PUSH
90760: LD_INT 0
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: PUSH
90775: EMPTY
90776: LIST
90777: PPUSH
90778: CALL_OW 447
90782: GO 90725
90784: POP
90785: POP
// end ;
90786: LD_VAR 0 5
90790: RET
