// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18397 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83116 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20577 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42294 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42294 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42294 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42739 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42631 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42631 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49105 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49105 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49105 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49105 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49105 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49105 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49105 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49105 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49105 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49105 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49105 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49105 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49105 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49105 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49105 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57398 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57398 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57398 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57398 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57398 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 53945 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 53945 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54067 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43027 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42631 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 54963 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42631 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 53945 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54067 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42864 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54067 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54067 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42864 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54067 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42864 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 53945 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54067 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54067 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54067 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42864 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 53945 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54067 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 53945 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54067 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42864 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54067 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42631 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42631 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 87809 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: PUSH
7569: LD_INT 4
7571: GREATEREQUAL
7572: PUSH
7573: LD_VAR 0 7
7577: PUSH
7578: LD_INT 0
7580: LESSEQUAL
7581: OR
7582: IFFALSE 7498
// wait ( 0 0$10 ) ;
7584: LD_INT 350
7586: PPUSH
7587: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7591: LD_ADDR_VAR 0 2
7595: PUSH
7596: LD_EXP 69
7600: PUSH
7601: LD_INT 1
7603: ARRAY
7604: PPUSH
7605: LD_INT 3
7607: PUSH
7608: LD_INT 2
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 32
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 34
7623: PUSH
7624: LD_INT 88
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 72
7644: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7645: LD_ADDR_VAR 0 3
7649: PUSH
7650: LD_EXP 69
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 2
7664: PUSH
7665: LD_INT 34
7667: PUSH
7668: LD_INT 32
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 34
7677: PUSH
7678: LD_INT 88
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 72
7698: ST_TO_ADDR
// if tmp2 then
7699: LD_VAR 0 3
7703: IFFALSE 7721
// tmp := tmp union tmp2 ;
7705: LD_ADDR_VAR 0 2
7709: PUSH
7710: LD_VAR 0 2
7714: PUSH
7715: LD_VAR 0 3
7719: UNION
7720: ST_TO_ADDR
// if not tmp then
7721: LD_VAR 0 2
7725: NOT
7726: IFFALSE 7730
// exit ;
7728: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL 51207 0 1
7739: PUSH
7740: LD_INT 50
7742: PPUSH
7743: CALL_OW 13
7747: OR
7748: IFFALSE 7781
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7750: LD_ADDR_VAR 0 4
7754: PUSH
7755: LD_INT 48
7757: PUSH
7758: LD_INT 33
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 71
7767: PUSH
7768: LD_INT 88
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: ST_TO_ADDR
7779: GO 7810
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7781: LD_ADDR_VAR 0 4
7785: PUSH
7786: LD_INT 128
7788: PUSH
7789: LD_INT 94
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 180
7798: PUSH
7799: LD_INT 135
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: ST_TO_ADDR
// if w = 3 then
7810: LD_VAR 0 5
7814: PUSH
7815: LD_INT 3
7817: EQUAL
7818: IFFALSE 7849
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7820: LD_ADDR_VAR 0 4
7824: PUSH
7825: LD_INT 91
7827: PUSH
7828: LD_INT 58
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 117
7837: PUSH
7838: LD_INT 107
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7849: LD_INT 28
7851: PPUSH
7852: LD_INT 22
7854: PUSH
7855: LD_INT 1
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 70
7866: IFFALSE 7886
// coords := [ [ 163 , 41 ] ] ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 163
7875: PUSH
7876: LD_INT 41
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7886: LD_VAR 0 2
7890: PPUSH
7891: LD_VAR 0 4
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PPUSH
7900: LD_VAR 0 4
7904: PUSH
7905: LD_INT 2
7907: ARRAY
7908: PPUSH
7909: CALL_OW 114
// p := 90 ;
7913: LD_ADDR_VAR 0 7
7917: PUSH
7918: LD_INT 90
7920: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// p := Dec ( p ) ;
7928: LD_ADDR_VAR 0 7
7932: PUSH
7933: LD_VAR 0 7
7937: PPUSH
7938: CALL 87809 0 1
7942: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7943: LD_VAR 0 2
7947: PPUSH
7948: LD_INT 60
7950: PUSH
7951: EMPTY
7952: LIST
7953: PPUSH
7954: CALL_OW 72
7958: PUSH
7959: LD_INT 0
7961: EQUAL
7962: PUSH
7963: LD_VAR 0 7
7967: PUSH
7968: LD_INT 0
7970: LESSEQUAL
7971: OR
7972: IFFALSE 7921
// repeat wait ( 0 0$2 ) ;
7974: LD_INT 70
7976: PPUSH
7977: CALL_OW 67
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82042 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7974
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 53945 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 53945 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54067 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 86824 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 16947 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16769 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 16947 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 16947 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16769 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 16947 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 16947 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17173 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17173 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16769 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 16947 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 16947 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16769 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 16947 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 16947 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16769 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 16947 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 16947 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 16947 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 16947 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 16947 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 54963 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15851 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15844: CALL 15851 0 0
// end ;
15848: PPOPN 1
15850: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15851: LD_INT 0
15853: PPUSH
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// m1 := false ;
15858: LD_ADDR_VAR 0 3
15862: PUSH
15863: LD_INT 0
15865: ST_TO_ADDR
// m2 := false ;
15866: LD_ADDR_VAR 0 4
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// m3 := false ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_INT 0
15881: ST_TO_ADDR
// if not am_veh_consturcted then
15882: LD_EXP 20
15886: NOT
15887: IFFALSE 15896
// SetAchievement ( ACH_ARABTECH ) ;
15889: LD_STRING ACH_ARABTECH
15891: PPUSH
15892: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15896: LD_OWVAR 1
15900: PUSH
15901: LD_INT 252000
15903: PUSH
15904: LD_INT 210000
15906: PUSH
15907: LD_INT 199500
15909: PUSH
15910: LD_INT 193200
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: LIST
15917: LIST
15918: PUSH
15919: LD_OWVAR 67
15923: ARRAY
15924: LESS
15925: IFFALSE 15947
// begin m3 := true ;
15927: LD_ADDR_VAR 0 5
15931: PUSH
15932: LD_INT 1
15934: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: PPUSH
15941: CALL_OW 101
// end else
15945: GO 15978
// if not powell_warn then
15947: LD_EXP 16
15951: NOT
15952: IFFALSE 15967
// AddMedal ( Time1 , - 1 ) else
15954: LD_STRING Time1
15956: PPUSH
15957: LD_INT 1
15959: NEG
15960: PPUSH
15961: CALL_OW 101
15965: GO 15978
// AddMedal ( Time1 , - 2 ) ;
15967: LD_STRING Time1
15969: PPUSH
15970: LD_INT 2
15972: NEG
15973: PPUSH
15974: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15978: LD_EXP 17
15982: PUSH
15983: LD_INT 5
15985: PUSH
15986: LD_INT 4
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: PUSH
16001: LD_OWVAR 67
16005: ARRAY
16006: GREATEREQUAL
16007: IFFALSE 16022
// AddMedal ( Destroy , - 2 ) else
16009: LD_STRING Destroy
16011: PPUSH
16012: LD_INT 2
16014: NEG
16015: PPUSH
16016: CALL_OW 101
16020: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16022: LD_INT 22
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: LD_INT 21
16034: PUSH
16035: LD_INT 3
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 50
16044: PUSH
16045: EMPTY
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: PUSH
16058: LD_INT 25
16060: GREATEREQUAL
16061: IFFALSE 16076
// AddMedal ( Destroy , - 1 ) else
16063: LD_STRING Destroy
16065: PPUSH
16066: LD_INT 1
16068: NEG
16069: PPUSH
16070: CALL_OW 101
16074: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16076: LD_INT 22
16078: PUSH
16079: LD_INT 2
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 21
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 50
16098: PUSH
16099: EMPTY
16100: LIST
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: PPUSH
16107: CALL_OW 69
16111: PUSH
16112: LD_INT 15
16114: GREATEREQUAL
16115: IFFALSE 16137
// begin m1 := true ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16125: LD_STRING Destroy
16127: PPUSH
16128: LD_INT 1
16130: PPUSH
16131: CALL_OW 101
// end else
16135: GO 16155
// begin m1 := true ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16145: LD_STRING Destroy
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16155: LD_EXP 13
16159: PPUSH
16160: LD_STRING 11_artifact_captured
16162: PPUSH
16163: CALL_OW 39
// if artifact_get then
16167: LD_EXP 13
16171: IFFALSE 16193
// begin m2 := true ;
16173: LD_ADDR_VAR 0 4
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16181: LD_STRING Artefact
16183: PPUSH
16184: LD_INT 1
16186: PPUSH
16187: CALL_OW 101
// end else
16191: GO 16204
// AddMedal ( Artefact , - 1 ) ;
16193: LD_STRING Artefact
16195: PPUSH
16196: LD_INT 1
16198: NEG
16199: PPUSH
16200: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16204: LD_VAR 0 3
16208: PUSH
16209: LD_VAR 0 4
16213: AND
16214: PUSH
16215: LD_VAR 0 5
16219: AND
16220: PUSH
16221: LD_OWVAR 67
16225: PUSH
16226: LD_INT 3
16228: GREATEREQUAL
16229: AND
16230: IFFALSE 16242
// SetAchievementEX ( ACH_AMER , 11 ) ;
16232: LD_STRING ACH_AMER
16234: PPUSH
16235: LD_INT 11
16237: PPUSH
16238: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16242: LD_VAR 0 3
16246: PUSH
16247: LD_VAR 0 4
16251: AND
16252: PUSH
16253: LD_VAR 0 5
16257: AND
16258: PUSH
16259: LD_EXP 17
16263: PUSH
16264: LD_INT 0
16266: EQUAL
16267: AND
16268: IFFALSE 16284
// begin wait ( 3 ) ;
16270: LD_INT 3
16272: PPUSH
16273: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16277: LD_STRING ACH_GENERAL
16279: PPUSH
16280: CALL_OW 543
// end ; if tick <= 100 100$00 then
16284: LD_OWVAR 1
16288: PUSH
16289: LD_INT 210000
16291: LESSEQUAL
16292: IFFALSE 16308
// begin wait ( 3 ) ;
16294: LD_INT 3
16296: PPUSH
16297: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16301: LD_STRING ACH_ASPEED_11
16303: PPUSH
16304: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16308: LD_STRING MAIN
16310: PPUSH
16311: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16315: LD_ADDR_EXP 19
16319: PUSH
16320: LD_EXP 19
16324: PPUSH
16325: LD_INT 51
16327: PUSH
16328: EMPTY
16329: LIST
16330: PPUSH
16331: CALL_OW 72
16335: ST_TO_ADDR
// tmp := JMM ^ selected ;
16336: LD_ADDR_VAR 0 2
16340: PUSH
16341: LD_EXP 21
16345: PUSH
16346: LD_EXP 19
16350: ADD
16351: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16361: LD_VAR 0 2
16365: PUSH
16366: LD_EXP 21
16370: PUSH
16371: LD_EXP 22
16375: PUSH
16376: LD_EXP 23
16380: PUSH
16381: LD_EXP 24
16385: PUSH
16386: LD_EXP 25
16390: PUSH
16391: LD_EXP 26
16395: PUSH
16396: LD_EXP 27
16400: PUSH
16401: LD_EXP 28
16405: PUSH
16406: LD_EXP 29
16410: PUSH
16411: LD_EXP 31
16415: PUSH
16416: LD_EXP 32
16420: PUSH
16421: LD_EXP 33
16425: PUSH
16426: LD_EXP 34
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: DIFF
16446: PPUSH
16447: LD_STRING 11c_others
16449: PPUSH
16450: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16454: LD_EXP 21
16458: PPUSH
16459: LD_EXP 3
16463: PUSH
16464: LD_STRING JMM
16466: STR
16467: PPUSH
16468: CALL_OW 38
// if Lisa then
16472: LD_EXP 22
16476: IFFALSE 16496
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16478: LD_EXP 22
16482: PPUSH
16483: LD_EXP 3
16487: PUSH
16488: LD_STRING Lisa
16490: STR
16491: PPUSH
16492: CALL_OW 38
// if Donaldson then
16496: LD_EXP 23
16500: IFFALSE 16520
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16502: LD_EXP 23
16506: PPUSH
16507: LD_EXP 3
16511: PUSH
16512: LD_STRING Donaldson
16514: STR
16515: PPUSH
16516: CALL_OW 38
// if Bobby then
16520: LD_EXP 24
16524: IFFALSE 16544
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16526: LD_EXP 24
16530: PPUSH
16531: LD_EXP 3
16535: PUSH
16536: LD_STRING Bobby
16538: STR
16539: PPUSH
16540: CALL_OW 38
// if Cyrus then
16544: LD_EXP 25
16548: IFFALSE 16568
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16550: LD_EXP 25
16554: PPUSH
16555: LD_EXP 3
16559: PUSH
16560: LD_STRING Cyrus
16562: STR
16563: PPUSH
16564: CALL_OW 38
// if Denis then
16568: LD_EXP 26
16572: IFFALSE 16592
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16574: LD_EXP 26
16578: PPUSH
16579: LD_EXP 3
16583: PUSH
16584: LD_STRING Denis
16586: STR
16587: PPUSH
16588: CALL_OW 38
// if Brown then
16592: LD_EXP 27
16596: IFFALSE 16616
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16598: LD_EXP 27
16602: PPUSH
16603: LD_EXP 3
16607: PUSH
16608: LD_STRING Brown
16610: STR
16611: PPUSH
16612: CALL_OW 38
// if Gladstone then
16616: LD_EXP 28
16620: IFFALSE 16640
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16622: LD_EXP 28
16626: PPUSH
16627: LD_EXP 3
16631: PUSH
16632: LD_STRING Gladstone
16634: STR
16635: PPUSH
16636: CALL_OW 38
// if Houten then
16640: LD_EXP 29
16644: IFFALSE 16664
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16646: LD_EXP 29
16650: PPUSH
16651: LD_EXP 3
16655: PUSH
16656: LD_STRING Houten
16658: STR
16659: PPUSH
16660: CALL_OW 38
// if Cornel then
16664: LD_EXP 31
16668: IFFALSE 16688
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16670: LD_EXP 31
16674: PPUSH
16675: LD_EXP 3
16679: PUSH
16680: LD_STRING Cornell
16682: STR
16683: PPUSH
16684: CALL_OW 38
// if Gary then
16688: LD_EXP 32
16692: IFFALSE 16712
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16694: LD_EXP 32
16698: PPUSH
16699: LD_EXP 3
16703: PUSH
16704: LD_STRING Gary
16706: STR
16707: PPUSH
16708: CALL_OW 38
// if Frank then
16712: LD_EXP 33
16716: IFFALSE 16736
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16718: LD_EXP 33
16722: PPUSH
16723: LD_EXP 3
16727: PUSH
16728: LD_STRING Frank
16730: STR
16731: PPUSH
16732: CALL_OW 38
// if Kikuchi then
16736: LD_EXP 34
16740: IFFALSE 16760
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16742: LD_EXP 34
16746: PPUSH
16747: LD_EXP 3
16751: PUSH
16752: LD_STRING Kikuchi
16754: STR
16755: PPUSH
16756: CALL_OW 38
// YouWin ;
16760: CALL_OW 103
// end ;
16764: LD_VAR 0 1
16768: RET
// export function CanSayRand ( side ) ; begin
16769: LD_INT 0
16771: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_INT 52
16779: PUSH
16780: EMPTY
16781: LIST
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_VAR 0 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 25
16800: PUSH
16801: LD_INT 1
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 25
16810: PUSH
16811: LD_INT 2
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 3
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 25
16830: PUSH
16831: LD_INT 4
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: PUSH
16855: LD_EXP 21
16859: PUSH
16860: LD_EXP 33
16864: PUSH
16865: LD_EXP 22
16869: PUSH
16870: LD_EXP 23
16874: PUSH
16875: LD_EXP 24
16879: PUSH
16880: LD_EXP 25
16884: PUSH
16885: LD_EXP 26
16889: PUSH
16890: LD_EXP 27
16894: PUSH
16895: LD_EXP 28
16899: PUSH
16900: LD_EXP 29
16904: PUSH
16905: LD_EXP 30
16909: PUSH
16910: LD_EXP 31
16914: PUSH
16915: LD_EXP 32
16919: PUSH
16920: LD_EXP 34
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: DIFF
16941: ST_TO_ADDR
// end ;
16942: LD_VAR 0 2
16946: RET
// export function SayRand ( sex , dial ) ; begin
16947: LD_INT 0
16949: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16950: LD_ADDR_VAR 0 3
16954: PUSH
16955: LD_INT 52
16957: PUSH
16958: EMPTY
16959: LIST
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 1
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 26
16973: PUSH
16974: LD_VAR 0 1
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 25
16988: PUSH
16989: LD_INT 1
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: PUSH
16996: LD_INT 25
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 25
17008: PUSH
17009: LD_INT 3
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: LD_INT 25
17018: PUSH
17019: LD_INT 4
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: PUSH
17044: LD_EXP 21
17048: PUSH
17049: LD_EXP 33
17053: PUSH
17054: LD_EXP 22
17058: PUSH
17059: LD_EXP 23
17063: PUSH
17064: LD_EXP 24
17068: PUSH
17069: LD_EXP 25
17073: PUSH
17074: LD_EXP 26
17078: PUSH
17079: LD_EXP 27
17083: PUSH
17084: LD_EXP 28
17088: PUSH
17089: LD_EXP 29
17093: PUSH
17094: LD_EXP 30
17098: PUSH
17099: LD_EXP 31
17103: PUSH
17104: LD_EXP 32
17108: PUSH
17109: LD_EXP 34
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: DIFF
17130: ST_TO_ADDR
// if not result then
17131: LD_VAR 0 3
17135: NOT
17136: IFFALSE 17140
// exit ;
17138: GO 17168
// result := result [ 1 ] ;
17140: LD_ADDR_VAR 0 3
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: ST_TO_ADDR
// Say ( result , dial ) ;
17154: LD_VAR 0 3
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 88
// end ;
17168: LD_VAR 0 3
17172: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17173: LD_INT 0
17175: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 26
17193: PUSH
17194: LD_VAR 0 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 2
17205: PUSH
17206: LD_INT 25
17208: PUSH
17209: LD_INT 1
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: LD_INT 25
17218: PUSH
17219: LD_INT 2
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 25
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 25
17238: PUSH
17239: LD_INT 4
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: PUSH
17263: LD_EXP 21
17267: PUSH
17268: LD_EXP 33
17272: PUSH
17273: LD_EXP 22
17277: PUSH
17278: LD_EXP 23
17282: PUSH
17283: LD_EXP 24
17287: PUSH
17288: LD_EXP 25
17292: PUSH
17293: LD_EXP 26
17297: PUSH
17298: LD_EXP 27
17302: PUSH
17303: LD_EXP 28
17307: PUSH
17308: LD_EXP 29
17312: PUSH
17313: LD_EXP 30
17317: PUSH
17318: LD_EXP 31
17322: PUSH
17323: LD_EXP 32
17327: PUSH
17328: LD_EXP 34
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PUSH
17349: LD_VAR 0 3
17353: ADD
17354: DIFF
17355: ST_TO_ADDR
// if not result then
17356: LD_VAR 0 4
17360: NOT
17361: IFFALSE 17365
// exit ;
17363: GO 17393
// result := result [ 1 ] ;
17365: LD_ADDR_VAR 0 4
17369: PUSH
17370: LD_VAR 0 4
17374: PUSH
17375: LD_INT 1
17377: ARRAY
17378: ST_TO_ADDR
// Say ( result , dial ) ;
17379: LD_VAR 0 4
17383: PPUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: CALL_OW 88
// end ; end_of_file
17393: LD_VAR 0 4
17397: RET
// export function CustomEvent ( event ) ; begin
17398: LD_INT 0
17400: PPUSH
// end ;
17401: LD_VAR 0 2
17405: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL_OW 255
17415: PUSH
17416: LD_INT 1
17418: EQUAL
17419: IFFALSE 17429
// artifact_get := true ;
17421: LD_ADDR_EXP 13
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17429: LD_VAR 0 1
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 2
17441: EQUAL
17442: IFFALSE 17460
// begin artifact_get := false ;
17444: LD_ADDR_EXP 13
17448: PUSH
17449: LD_INT 0
17451: ST_TO_ADDR
// artifact_stolen := true ;
17452: LD_ADDR_EXP 12
17456: PUSH
17457: LD_INT 1
17459: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17460: LD_ADDR_EXP 14
17464: PUSH
17465: LD_INT 1
17467: ST_TO_ADDR
// end ;
17468: PPOPN 2
17470: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17471: LD_ADDR_EXP 14
17475: PUSH
17476: LD_INT 0
17478: ST_TO_ADDR
// end ;
17479: PPOPN 2
17481: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17482: LD_VAR 0 1
17486: PPUSH
17487: CALL 106443 0 1
// if un = JMM then
17491: LD_VAR 0 1
17495: PUSH
17496: LD_EXP 21
17500: EQUAL
17501: IFFALSE 17512
// begin YouLost ( JMM ) ;
17503: LD_STRING JMM
17505: PPUSH
17506: CALL_OW 104
// exit ;
17510: GO 17644
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17512: LD_VAR 0 1
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 21
17529: PUSH
17530: LD_INT 1
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: PUSH
17537: LD_INT 2
17539: PUSH
17540: LD_INT 25
17542: PUSH
17543: LD_INT 1
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 2
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PUSH
17560: LD_INT 25
17562: PUSH
17563: LD_INT 3
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PUSH
17570: LD_INT 25
17572: PUSH
17573: LD_INT 4
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: PUSH
17580: LD_INT 25
17582: PUSH
17583: LD_INT 5
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: PUSH
17590: LD_INT 25
17592: PUSH
17593: LD_INT 8
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PPUSH
17614: CALL_OW 69
17618: IN
17619: IFFALSE 17635
// loses_counter := loses_counter + 1 ;
17621: LD_ADDR_EXP 17
17625: PUSH
17626: LD_EXP 17
17630: PUSH
17631: LD_INT 1
17633: PLUS
17634: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL 46121 0 1
// end ;
17644: PPOPN 1
17646: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17647: LD_VAR 0 1
17651: PPUSH
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL 48453 0 2
// end ;
17661: PPOPN 2
17663: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17664: LD_VAR 0 1
17668: PPUSH
17669: CALL 47762 0 1
// end ;
17673: PPOPN 1
17675: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: LD_VAR 0 2
17685: PPUSH
17686: LD_VAR 0 3
17690: PPUSH
17691: LD_VAR 0 4
17695: PPUSH
17696: LD_VAR 0 5
17700: PPUSH
17701: CALL 45437 0 5
// end ;
17705: PPOPN 5
17707: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL 106563 0 2
// if GetNation ( vehicle ) = nation_american then
17722: LD_VAR 0 1
17726: PPUSH
17727: CALL_OW 248
17731: PUSH
17732: LD_INT 1
17734: EQUAL
17735: IFFALSE 17745
// am_veh_consturcted := true ;
17737: LD_ADDR_EXP 20
17741: PUSH
17742: LD_INT 1
17744: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 2
17754: PPUSH
17755: CALL 44990 0 2
// end ;
17759: PPOPN 2
17761: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17762: LD_VAR 0 1
17766: PPUSH
17767: CALL_OW 247
17771: PUSH
17772: LD_INT 2
17774: EQUAL
17775: IFFALSE 17779
// exit ;
17777: GO 17796
// if not kamikazed then
17779: LD_EXP 11
17783: NOT
17784: IFFALSE 17796
// kamikazed := unit ;
17786: LD_ADDR_EXP 11
17790: PUSH
17791: LD_VAR 0 1
17795: ST_TO_ADDR
// end ;
17796: PPOPN 1
17798: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17799: LD_INT 0
17801: PPUSH
17802: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17803: LD_VAR 0 1
17807: PPUSH
17808: LD_VAR 0 2
17812: PPUSH
17813: LD_VAR 0 3
17817: PPUSH
17818: LD_VAR 0 4
17822: PPUSH
17823: CALL 44828 0 4
// end ;
17827: PPOPN 6
17829: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17830: LD_INT 0
17832: PPUSH
// begin if building = ar_dep_n then
17833: LD_VAR 0 1
17837: PUSH
17838: LD_INT 94
17840: EQUAL
17841: IFFALSE 17893
// begin for i := 1 to 3 do
17843: LD_ADDR_VAR 0 4
17847: PUSH
17848: DOUBLE
17849: LD_INT 1
17851: DEC
17852: ST_TO_ADDR
17853: LD_INT 3
17855: PUSH
17856: FOR_TO
17857: IFFALSE 17891
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17859: LD_INT 115
17861: PUSH
17862: LD_VAR 0 4
17866: PUSH
17867: LD_INT 2
17869: MUL
17870: PLUS
17871: PPUSH
17872: LD_INT 6
17874: PPUSH
17875: LD_INT 1
17877: PPUSH
17878: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17882: LD_INT 10
17884: PPUSH
17885: CALL_OW 67
// end ;
17889: GO 17856
17891: POP
17892: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17893: LD_VAR 0 1
17897: PPUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_VAR 0 3
17907: PPUSH
17908: CALL 44603 0 3
// end ;
17912: PPOPN 4
17914: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17915: LD_VAR 0 1
17919: PPUSH
17920: LD_VAR 0 2
17924: PPUSH
17925: CALL 45817 0 2
// end ;
17929: PPOPN 2
17931: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17932: LD_VAR 0 1
17936: PPUSH
17937: LD_VAR 0 2
17941: PPUSH
17942: CALL 44297 0 2
// end ;
17946: PPOPN 2
17948: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17949: LD_VAR 0 1
17953: PPUSH
17954: LD_VAR 0 2
17958: PPUSH
17959: CALL 44488 0 2
// end ;
17963: PPOPN 2
17965: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17966: LD_VAR 0 1
17970: PPUSH
17971: CALL 47521 0 1
// end ;
17975: PPOPN 1
17977: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17978: LD_VAR 0 1
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: CALL 48748 0 2
// end ;
17992: PPOPN 2
17994: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: LD_VAR 0 3
18009: PPUSH
18010: LD_VAR 0 4
18014: PPUSH
18015: CALL 48964 0 4
// end ;
18019: PPOPN 4
18021: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: CALL 106547 0 1
// end ;
18031: PPOPN 1
18033: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18034: LD_INT 22
18036: PUSH
18037: LD_INT 2
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PUSH
18044: LD_INT 50
18046: PUSH
18047: EMPTY
18048: LIST
18049: PUSH
18050: LD_INT 21
18052: PUSH
18053: LD_INT 1
18055: PUSH
18056: EMPTY
18057: LIST
18058: LIST
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PPUSH
18065: CALL_OW 69
18069: IFFALSE 18153
18071: GO 18073
18073: DISABLE
18074: LD_INT 0
18076: PPUSH
// begin enable ;
18077: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18078: LD_ADDR_VAR 0 1
18082: PUSH
18083: LD_INT 22
18085: PUSH
18086: LD_INT 2
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 50
18095: PUSH
18096: EMPTY
18097: LIST
18098: PUSH
18099: LD_INT 21
18101: PUSH
18102: LD_INT 1
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PPUSH
18114: CALL_OW 69
18118: PUSH
18119: FOR_IN
18120: IFFALSE 18151
// if GetFuel ( i ) < 3 then
18122: LD_VAR 0 1
18126: PPUSH
18127: CALL_OW 261
18131: PUSH
18132: LD_INT 3
18134: LESS
18135: IFFALSE 18149
// SetFuel ( i , 5 ) ;
18137: LD_VAR 0 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 240
18149: GO 18119
18151: POP
18152: POP
// end ; end_of_file
18153: PPOPN 1
18155: END
// every 0 0$1 trigger game do
18156: LD_EXP 2
18160: IFFALSE 18190
18162: GO 18164
18164: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18165: LD_INT 7
18167: PUSH
18168: LD_INT 6
18170: PUSH
18171: LD_INT 4
18173: PUSH
18174: LD_INT 6
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PPUSH
18183: LD_INT 1750
18185: PPUSH
18186: CALL 18191 0 2
18190: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18191: LD_INT 0
18193: PPUSH
18194: PPUSH
18195: PPUSH
// if not areas then
18196: LD_VAR 0 1
18200: NOT
18201: IFFALSE 18205
// exit ;
18203: GO 18335
// repeat wait ( time ) ;
18205: LD_VAR 0 2
18209: PPUSH
18210: CALL_OW 67
// for i in areas do
18214: LD_ADDR_VAR 0 4
18218: PUSH
18219: LD_VAR 0 1
18223: PUSH
18224: FOR_IN
18225: IFFALSE 18294
// begin p := rand ( 1 , 90 ) ;
18227: LD_ADDR_VAR 0 5
18231: PUSH
18232: LD_INT 1
18234: PPUSH
18235: LD_INT 90
18237: PPUSH
18238: CALL_OW 12
18242: ST_TO_ADDR
// if Prob ( p ) then
18243: LD_VAR 0 5
18247: PPUSH
18248: CALL_OW 13
18252: IFFALSE 18292
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18254: LD_INT 2
18256: PPUSH
18257: LD_INT 5
18259: PPUSH
18260: CALL_OW 12
18264: PPUSH
18265: LD_VAR 0 4
18269: PPUSH
18270: LD_INT 1
18272: PPUSH
18273: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18277: LD_INT 735
18279: PPUSH
18280: LD_INT 1295
18282: PPUSH
18283: CALL_OW 12
18287: PPUSH
18288: CALL_OW 67
// end ; end ;
18292: GO 18224
18294: POP
18295: POP
// time := time + 0 0$3 ;
18296: LD_ADDR_VAR 0 2
18300: PUSH
18301: LD_VAR 0 2
18305: PUSH
18306: LD_INT 105
18308: PLUS
18309: ST_TO_ADDR
// if time > 3 3$00 then
18310: LD_VAR 0 2
18314: PUSH
18315: LD_INT 6300
18317: GREATER
18318: IFFALSE 18328
// time := 0 0$40 ;
18320: LD_ADDR_VAR 0 2
18324: PUSH
18325: LD_INT 1400
18327: ST_TO_ADDR
// until not game ;
18328: LD_EXP 2
18332: NOT
18333: IFFALSE 18205
// end ;
18335: LD_VAR 0 3
18339: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18340: LD_OWVAR 1
18344: PUSH
18345: LD_INT 84000
18347: PUSH
18348: LD_INT 73500
18350: PUSH
18351: LD_INT 63000
18353: PUSH
18354: LD_INT 52500
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_OWVAR 67
18367: ARRAY
18368: LESS
18369: IFFALSE 18396
18371: GO 18373
18373: DISABLE
// begin enable ;
18374: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18375: LD_INT 1
18377: PPUSH
18378: LD_INT 5
18380: PPUSH
18381: CALL_OW 12
18385: PPUSH
18386: LD_INT 7
18388: PPUSH
18389: LD_INT 1
18391: PPUSH
18392: CALL_OW 55
// end ; end_of_file
18396: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18397: LD_INT 0
18399: PPUSH
18400: PPUSH
// skirmish := false ;
18401: LD_ADDR_EXP 48
18405: PUSH
18406: LD_INT 0
18408: ST_TO_ADDR
// debug_mc := false ;
18409: LD_ADDR_EXP 49
18413: PUSH
18414: LD_INT 0
18416: ST_TO_ADDR
// mc_bases := [ ] ;
18417: LD_ADDR_EXP 50
18421: PUSH
18422: EMPTY
18423: ST_TO_ADDR
// mc_sides := [ ] ;
18424: LD_ADDR_EXP 76
18428: PUSH
18429: EMPTY
18430: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18431: LD_ADDR_EXP 51
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18438: LD_ADDR_EXP 52
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_need_heal := [ ] ;
18445: LD_ADDR_EXP 53
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_healers := [ ] ;
18452: LD_ADDR_EXP 54
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_build_list := [ ] ;
18459: LD_ADDR_EXP 55
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18466: LD_ADDR_EXP 82
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_builders := [ ] ;
18473: LD_ADDR_EXP 56
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_construct_list := [ ] ;
18480: LD_ADDR_EXP 57
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_turret_list := [ ] ;
18487: LD_ADDR_EXP 58
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18494: LD_ADDR_EXP 59
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_miners := [ ] ;
18501: LD_ADDR_EXP 64
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// mc_mines := [ ] ;
18508: LD_ADDR_EXP 63
18512: PUSH
18513: EMPTY
18514: ST_TO_ADDR
// mc_minefields := [ ] ;
18515: LD_ADDR_EXP 65
18519: PUSH
18520: EMPTY
18521: ST_TO_ADDR
// mc_crates := [ ] ;
18522: LD_ADDR_EXP 66
18526: PUSH
18527: EMPTY
18528: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18529: LD_ADDR_EXP 67
18533: PUSH
18534: EMPTY
18535: ST_TO_ADDR
// mc_crates_area := [ ] ;
18536: LD_ADDR_EXP 68
18540: PUSH
18541: EMPTY
18542: ST_TO_ADDR
// mc_vehicles := [ ] ;
18543: LD_ADDR_EXP 69
18547: PUSH
18548: EMPTY
18549: ST_TO_ADDR
// mc_attack := [ ] ;
18550: LD_ADDR_EXP 70
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// mc_produce := [ ] ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: EMPTY
18563: ST_TO_ADDR
// mc_defender := [ ] ;
18564: LD_ADDR_EXP 72
18568: PUSH
18569: EMPTY
18570: ST_TO_ADDR
// mc_parking := [ ] ;
18571: LD_ADDR_EXP 74
18575: PUSH
18576: EMPTY
18577: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18578: LD_ADDR_EXP 60
18582: PUSH
18583: EMPTY
18584: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18585: LD_ADDR_EXP 62
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// mc_scan := [ ] ;
18592: LD_ADDR_EXP 73
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// mc_scan_area := [ ] ;
18599: LD_ADDR_EXP 75
18603: PUSH
18604: EMPTY
18605: ST_TO_ADDR
// mc_tech := [ ] ;
18606: LD_ADDR_EXP 77
18610: PUSH
18611: EMPTY
18612: ST_TO_ADDR
// mc_class := [ ] ;
18613: LD_ADDR_EXP 91
18617: PUSH
18618: EMPTY
18619: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18620: LD_ADDR_EXP 92
18624: PUSH
18625: EMPTY
18626: ST_TO_ADDR
// mc_is_defending := [ ] ;
18627: LD_ADDR_EXP 93
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18634: LD_ADDR_EXP 84
18638: PUSH
18639: EMPTY
18640: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18641: LD_ADDR_EXP 94
18645: PUSH
18646: LD_INT 0
18648: ST_TO_ADDR
// end ;
18649: LD_VAR 0 1
18653: RET
// export function MC_Kill ( base ) ; begin
18654: LD_INT 0
18656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18657: LD_ADDR_EXP 50
18661: PUSH
18662: LD_EXP 50
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: EMPTY
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18679: LD_ADDR_EXP 51
18683: PUSH
18684: LD_EXP 51
18688: PPUSH
18689: LD_VAR 0 1
18693: PPUSH
18694: EMPTY
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18701: LD_ADDR_EXP 52
18705: PUSH
18706: LD_EXP 52
18710: PPUSH
18711: LD_VAR 0 1
18715: PPUSH
18716: EMPTY
18717: PPUSH
18718: CALL_OW 1
18722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18723: LD_ADDR_EXP 53
18727: PUSH
18728: LD_EXP 53
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: EMPTY
18739: PPUSH
18740: CALL_OW 1
18744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18745: LD_ADDR_EXP 54
18749: PUSH
18750: LD_EXP 54
18754: PPUSH
18755: LD_VAR 0 1
18759: PPUSH
18760: EMPTY
18761: PPUSH
18762: CALL_OW 1
18766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18767: LD_ADDR_EXP 55
18771: PUSH
18772: LD_EXP 55
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: EMPTY
18783: PPUSH
18784: CALL_OW 1
18788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18789: LD_ADDR_EXP 56
18793: PUSH
18794: LD_EXP 56
18798: PPUSH
18799: LD_VAR 0 1
18803: PPUSH
18804: EMPTY
18805: PPUSH
18806: CALL_OW 1
18810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18811: LD_ADDR_EXP 57
18815: PUSH
18816: LD_EXP 57
18820: PPUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: EMPTY
18827: PPUSH
18828: CALL_OW 1
18832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18833: LD_ADDR_EXP 58
18837: PUSH
18838: LD_EXP 58
18842: PPUSH
18843: LD_VAR 0 1
18847: PPUSH
18848: EMPTY
18849: PPUSH
18850: CALL_OW 1
18854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18855: LD_ADDR_EXP 59
18859: PUSH
18860: LD_EXP 59
18864: PPUSH
18865: LD_VAR 0 1
18869: PPUSH
18870: EMPTY
18871: PPUSH
18872: CALL_OW 1
18876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18877: LD_ADDR_EXP 60
18881: PUSH
18882: LD_EXP 60
18886: PPUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: EMPTY
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18899: LD_ADDR_EXP 61
18903: PUSH
18904: LD_EXP 61
18908: PPUSH
18909: LD_VAR 0 1
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: CALL_OW 1
18921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18922: LD_ADDR_EXP 62
18926: PUSH
18927: LD_EXP 62
18931: PPUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: EMPTY
18938: PPUSH
18939: CALL_OW 1
18943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18944: LD_ADDR_EXP 63
18948: PUSH
18949: LD_EXP 63
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: EMPTY
18960: PPUSH
18961: CALL_OW 1
18965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18966: LD_ADDR_EXP 64
18970: PUSH
18971: LD_EXP 64
18975: PPUSH
18976: LD_VAR 0 1
18980: PPUSH
18981: EMPTY
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18988: LD_ADDR_EXP 65
18992: PUSH
18993: LD_EXP 65
18997: PPUSH
18998: LD_VAR 0 1
19002: PPUSH
19003: EMPTY
19004: PPUSH
19005: CALL_OW 1
19009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19010: LD_ADDR_EXP 66
19014: PUSH
19015: LD_EXP 66
19019: PPUSH
19020: LD_VAR 0 1
19024: PPUSH
19025: EMPTY
19026: PPUSH
19027: CALL_OW 1
19031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19032: LD_ADDR_EXP 67
19036: PUSH
19037: LD_EXP 67
19041: PPUSH
19042: LD_VAR 0 1
19046: PPUSH
19047: EMPTY
19048: PPUSH
19049: CALL_OW 1
19053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19054: LD_ADDR_EXP 68
19058: PUSH
19059: LD_EXP 68
19063: PPUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: EMPTY
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19076: LD_ADDR_EXP 69
19080: PUSH
19081: LD_EXP 69
19085: PPUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: EMPTY
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19098: LD_ADDR_EXP 70
19102: PUSH
19103: LD_EXP 70
19107: PPUSH
19108: LD_VAR 0 1
19112: PPUSH
19113: EMPTY
19114: PPUSH
19115: CALL_OW 1
19119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19120: LD_ADDR_EXP 71
19124: PUSH
19125: LD_EXP 71
19129: PPUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: EMPTY
19136: PPUSH
19137: CALL_OW 1
19141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19142: LD_ADDR_EXP 72
19146: PUSH
19147: LD_EXP 72
19151: PPUSH
19152: LD_VAR 0 1
19156: PPUSH
19157: EMPTY
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19164: LD_ADDR_EXP 73
19168: PUSH
19169: LD_EXP 73
19173: PPUSH
19174: LD_VAR 0 1
19178: PPUSH
19179: EMPTY
19180: PPUSH
19181: CALL_OW 1
19185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19186: LD_ADDR_EXP 74
19190: PUSH
19191: LD_EXP 74
19195: PPUSH
19196: LD_VAR 0 1
19200: PPUSH
19201: EMPTY
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19208: LD_ADDR_EXP 75
19212: PUSH
19213: LD_EXP 75
19217: PPUSH
19218: LD_VAR 0 1
19222: PPUSH
19223: EMPTY
19224: PPUSH
19225: CALL_OW 1
19229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19230: LD_ADDR_EXP 77
19234: PUSH
19235: LD_EXP 77
19239: PPUSH
19240: LD_VAR 0 1
19244: PPUSH
19245: EMPTY
19246: PPUSH
19247: CALL_OW 1
19251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19252: LD_ADDR_EXP 79
19256: PUSH
19257: LD_EXP 79
19261: PPUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: EMPTY
19268: PPUSH
19269: CALL_OW 1
19273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19274: LD_ADDR_EXP 80
19278: PUSH
19279: LD_EXP 80
19283: PPUSH
19284: LD_VAR 0 1
19288: PPUSH
19289: EMPTY
19290: PPUSH
19291: CALL_OW 1
19295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19296: LD_ADDR_EXP 81
19300: PUSH
19301: LD_EXP 81
19305: PPUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: EMPTY
19312: PPUSH
19313: CALL_OW 1
19317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19318: LD_ADDR_EXP 82
19322: PUSH
19323: LD_EXP 82
19327: PPUSH
19328: LD_VAR 0 1
19332: PPUSH
19333: EMPTY
19334: PPUSH
19335: CALL_OW 1
19339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19340: LD_ADDR_EXP 83
19344: PUSH
19345: LD_EXP 83
19349: PPUSH
19350: LD_VAR 0 1
19354: PPUSH
19355: EMPTY
19356: PPUSH
19357: CALL_OW 1
19361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19362: LD_ADDR_EXP 84
19366: PUSH
19367: LD_EXP 84
19371: PPUSH
19372: LD_VAR 0 1
19376: PPUSH
19377: EMPTY
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19384: LD_ADDR_EXP 85
19388: PUSH
19389: LD_EXP 85
19393: PPUSH
19394: LD_VAR 0 1
19398: PPUSH
19399: EMPTY
19400: PPUSH
19401: CALL_OW 1
19405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19406: LD_ADDR_EXP 86
19410: PUSH
19411: LD_EXP 86
19415: PPUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: EMPTY
19422: PPUSH
19423: CALL_OW 1
19427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19428: LD_ADDR_EXP 87
19432: PUSH
19433: LD_EXP 87
19437: PPUSH
19438: LD_VAR 0 1
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL_OW 1
19449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19450: LD_ADDR_EXP 88
19454: PUSH
19455: LD_EXP 88
19459: PPUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: EMPTY
19466: PPUSH
19467: CALL_OW 1
19471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19472: LD_ADDR_EXP 89
19476: PUSH
19477: LD_EXP 89
19481: PPUSH
19482: LD_VAR 0 1
19486: PPUSH
19487: EMPTY
19488: PPUSH
19489: CALL_OW 1
19493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19494: LD_ADDR_EXP 90
19498: PUSH
19499: LD_EXP 90
19503: PPUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: EMPTY
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19516: LD_ADDR_EXP 91
19520: PUSH
19521: LD_EXP 91
19525: PPUSH
19526: LD_VAR 0 1
19530: PPUSH
19531: EMPTY
19532: PPUSH
19533: CALL_OW 1
19537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19538: LD_ADDR_EXP 92
19542: PUSH
19543: LD_EXP 92
19547: PPUSH
19548: LD_VAR 0 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 1
19560: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19561: LD_ADDR_EXP 93
19565: PUSH
19566: LD_EXP 93
19570: PPUSH
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_INT 0
19578: PPUSH
19579: CALL_OW 1
19583: ST_TO_ADDR
// end ;
19584: LD_VAR 0 2
19588: RET
// export function MC_Add ( side , units ) ; var base ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// base := mc_bases + 1 ;
19593: LD_ADDR_VAR 0 4
19597: PUSH
19598: LD_EXP 50
19602: PUSH
19603: LD_INT 1
19605: PLUS
19606: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19607: LD_ADDR_EXP 76
19611: PUSH
19612: LD_EXP 76
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 1
19631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19632: LD_ADDR_EXP 50
19636: PUSH
19637: LD_EXP 50
19641: PPUSH
19642: LD_VAR 0 4
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: CALL_OW 1
19656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19657: LD_ADDR_EXP 51
19661: PUSH
19662: LD_EXP 51
19666: PPUSH
19667: LD_VAR 0 4
19671: PPUSH
19672: EMPTY
19673: PPUSH
19674: CALL_OW 1
19678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19679: LD_ADDR_EXP 52
19683: PUSH
19684: LD_EXP 52
19688: PPUSH
19689: LD_VAR 0 4
19693: PPUSH
19694: EMPTY
19695: PPUSH
19696: CALL_OW 1
19700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19701: LD_ADDR_EXP 53
19705: PUSH
19706: LD_EXP 53
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: EMPTY
19717: PPUSH
19718: CALL_OW 1
19722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19723: LD_ADDR_EXP 54
19727: PUSH
19728: LD_EXP 54
19732: PPUSH
19733: LD_VAR 0 4
19737: PPUSH
19738: EMPTY
19739: PPUSH
19740: CALL_OW 1
19744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19745: LD_ADDR_EXP 55
19749: PUSH
19750: LD_EXP 55
19754: PPUSH
19755: LD_VAR 0 4
19759: PPUSH
19760: EMPTY
19761: PPUSH
19762: CALL_OW 1
19766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19767: LD_ADDR_EXP 56
19771: PUSH
19772: LD_EXP 56
19776: PPUSH
19777: LD_VAR 0 4
19781: PPUSH
19782: EMPTY
19783: PPUSH
19784: CALL_OW 1
19788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19789: LD_ADDR_EXP 57
19793: PUSH
19794: LD_EXP 57
19798: PPUSH
19799: LD_VAR 0 4
19803: PPUSH
19804: EMPTY
19805: PPUSH
19806: CALL_OW 1
19810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19811: LD_ADDR_EXP 58
19815: PUSH
19816: LD_EXP 58
19820: PPUSH
19821: LD_VAR 0 4
19825: PPUSH
19826: EMPTY
19827: PPUSH
19828: CALL_OW 1
19832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19833: LD_ADDR_EXP 59
19837: PUSH
19838: LD_EXP 59
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: EMPTY
19849: PPUSH
19850: CALL_OW 1
19854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19855: LD_ADDR_EXP 60
19859: PUSH
19860: LD_EXP 60
19864: PPUSH
19865: LD_VAR 0 4
19869: PPUSH
19870: EMPTY
19871: PPUSH
19872: CALL_OW 1
19876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19877: LD_ADDR_EXP 61
19881: PUSH
19882: LD_EXP 61
19886: PPUSH
19887: LD_VAR 0 4
19891: PPUSH
19892: LD_INT 0
19894: PPUSH
19895: CALL_OW 1
19899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19900: LD_ADDR_EXP 62
19904: PUSH
19905: LD_EXP 62
19909: PPUSH
19910: LD_VAR 0 4
19914: PPUSH
19915: EMPTY
19916: PPUSH
19917: CALL_OW 1
19921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19922: LD_ADDR_EXP 63
19926: PUSH
19927: LD_EXP 63
19931: PPUSH
19932: LD_VAR 0 4
19936: PPUSH
19937: EMPTY
19938: PPUSH
19939: CALL_OW 1
19943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19944: LD_ADDR_EXP 64
19948: PUSH
19949: LD_EXP 64
19953: PPUSH
19954: LD_VAR 0 4
19958: PPUSH
19959: EMPTY
19960: PPUSH
19961: CALL_OW 1
19965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19966: LD_ADDR_EXP 65
19970: PUSH
19971: LD_EXP 65
19975: PPUSH
19976: LD_VAR 0 4
19980: PPUSH
19981: EMPTY
19982: PPUSH
19983: CALL_OW 1
19987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19988: LD_ADDR_EXP 66
19992: PUSH
19993: LD_EXP 66
19997: PPUSH
19998: LD_VAR 0 4
20002: PPUSH
20003: EMPTY
20004: PPUSH
20005: CALL_OW 1
20009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20010: LD_ADDR_EXP 67
20014: PUSH
20015: LD_EXP 67
20019: PPUSH
20020: LD_VAR 0 4
20024: PPUSH
20025: EMPTY
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20032: LD_ADDR_EXP 68
20036: PUSH
20037: LD_EXP 68
20041: PPUSH
20042: LD_VAR 0 4
20046: PPUSH
20047: EMPTY
20048: PPUSH
20049: CALL_OW 1
20053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20054: LD_ADDR_EXP 69
20058: PUSH
20059: LD_EXP 69
20063: PPUSH
20064: LD_VAR 0 4
20068: PPUSH
20069: EMPTY
20070: PPUSH
20071: CALL_OW 1
20075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20076: LD_ADDR_EXP 70
20080: PUSH
20081: LD_EXP 70
20085: PPUSH
20086: LD_VAR 0 4
20090: PPUSH
20091: EMPTY
20092: PPUSH
20093: CALL_OW 1
20097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_EXP 71
20107: PPUSH
20108: LD_VAR 0 4
20112: PPUSH
20113: EMPTY
20114: PPUSH
20115: CALL_OW 1
20119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20120: LD_ADDR_EXP 72
20124: PUSH
20125: LD_EXP 72
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: EMPTY
20136: PPUSH
20137: CALL_OW 1
20141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20142: LD_ADDR_EXP 73
20146: PUSH
20147: LD_EXP 73
20151: PPUSH
20152: LD_VAR 0 4
20156: PPUSH
20157: EMPTY
20158: PPUSH
20159: CALL_OW 1
20163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20164: LD_ADDR_EXP 74
20168: PUSH
20169: LD_EXP 74
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: EMPTY
20180: PPUSH
20181: CALL_OW 1
20185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20186: LD_ADDR_EXP 75
20190: PUSH
20191: LD_EXP 75
20195: PPUSH
20196: LD_VAR 0 4
20200: PPUSH
20201: EMPTY
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20208: LD_ADDR_EXP 77
20212: PUSH
20213: LD_EXP 77
20217: PPUSH
20218: LD_VAR 0 4
20222: PPUSH
20223: EMPTY
20224: PPUSH
20225: CALL_OW 1
20229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20230: LD_ADDR_EXP 79
20234: PUSH
20235: LD_EXP 79
20239: PPUSH
20240: LD_VAR 0 4
20244: PPUSH
20245: EMPTY
20246: PPUSH
20247: CALL_OW 1
20251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20252: LD_ADDR_EXP 80
20256: PUSH
20257: LD_EXP 80
20261: PPUSH
20262: LD_VAR 0 4
20266: PPUSH
20267: EMPTY
20268: PPUSH
20269: CALL_OW 1
20273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20274: LD_ADDR_EXP 81
20278: PUSH
20279: LD_EXP 81
20283: PPUSH
20284: LD_VAR 0 4
20288: PPUSH
20289: EMPTY
20290: PPUSH
20291: CALL_OW 1
20295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20296: LD_ADDR_EXP 82
20300: PUSH
20301: LD_EXP 82
20305: PPUSH
20306: LD_VAR 0 4
20310: PPUSH
20311: EMPTY
20312: PPUSH
20313: CALL_OW 1
20317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20318: LD_ADDR_EXP 83
20322: PUSH
20323: LD_EXP 83
20327: PPUSH
20328: LD_VAR 0 4
20332: PPUSH
20333: EMPTY
20334: PPUSH
20335: CALL_OW 1
20339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20340: LD_ADDR_EXP 84
20344: PUSH
20345: LD_EXP 84
20349: PPUSH
20350: LD_VAR 0 4
20354: PPUSH
20355: EMPTY
20356: PPUSH
20357: CALL_OW 1
20361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20362: LD_ADDR_EXP 85
20366: PUSH
20367: LD_EXP 85
20371: PPUSH
20372: LD_VAR 0 4
20376: PPUSH
20377: EMPTY
20378: PPUSH
20379: CALL_OW 1
20383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20384: LD_ADDR_EXP 86
20388: PUSH
20389: LD_EXP 86
20393: PPUSH
20394: LD_VAR 0 4
20398: PPUSH
20399: EMPTY
20400: PPUSH
20401: CALL_OW 1
20405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20406: LD_ADDR_EXP 87
20410: PUSH
20411: LD_EXP 87
20415: PPUSH
20416: LD_VAR 0 4
20420: PPUSH
20421: EMPTY
20422: PPUSH
20423: CALL_OW 1
20427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20428: LD_ADDR_EXP 88
20432: PUSH
20433: LD_EXP 88
20437: PPUSH
20438: LD_VAR 0 4
20442: PPUSH
20443: EMPTY
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20450: LD_ADDR_EXP 89
20454: PUSH
20455: LD_EXP 89
20459: PPUSH
20460: LD_VAR 0 4
20464: PPUSH
20465: EMPTY
20466: PPUSH
20467: CALL_OW 1
20471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20472: LD_ADDR_EXP 90
20476: PUSH
20477: LD_EXP 90
20481: PPUSH
20482: LD_VAR 0 4
20486: PPUSH
20487: EMPTY
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20494: LD_ADDR_EXP 91
20498: PUSH
20499: LD_EXP 91
20503: PPUSH
20504: LD_VAR 0 4
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20516: LD_ADDR_EXP 92
20520: PUSH
20521: LD_EXP 92
20525: PPUSH
20526: LD_VAR 0 4
20530: PPUSH
20531: LD_INT 0
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20539: LD_ADDR_EXP 93
20543: PUSH
20544: LD_EXP 93
20548: PPUSH
20549: LD_VAR 0 4
20553: PPUSH
20554: LD_INT 0
20556: PPUSH
20557: CALL_OW 1
20561: ST_TO_ADDR
// result := base ;
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_VAR 0 4
20571: ST_TO_ADDR
// end ;
20572: LD_VAR 0 3
20576: RET
// export function MC_Start ( ) ; var i ; begin
20577: LD_INT 0
20579: PPUSH
20580: PPUSH
// for i = 1 to mc_bases do
20581: LD_ADDR_VAR 0 2
20585: PUSH
20586: DOUBLE
20587: LD_INT 1
20589: DEC
20590: ST_TO_ADDR
20591: LD_EXP 50
20595: PUSH
20596: FOR_TO
20597: IFFALSE 21697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20599: LD_ADDR_EXP 50
20603: PUSH
20604: LD_EXP 50
20608: PPUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_EXP 50
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: PUSH
20625: LD_INT 0
20627: DIFF
20628: PPUSH
20629: CALL_OW 1
20633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20634: LD_ADDR_EXP 51
20638: PUSH
20639: LD_EXP 51
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: EMPTY
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20656: LD_ADDR_EXP 52
20660: PUSH
20661: LD_EXP 52
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20678: LD_ADDR_EXP 53
20682: PUSH
20683: LD_EXP 53
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20700: LD_ADDR_EXP 54
20704: PUSH
20705: LD_EXP 54
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PUSH
20717: EMPTY
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: PPUSH
20723: CALL_OW 1
20727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20728: LD_ADDR_EXP 55
20732: PUSH
20733: LD_EXP 55
20737: PPUSH
20738: LD_VAR 0 2
20742: PPUSH
20743: EMPTY
20744: PPUSH
20745: CALL_OW 1
20749: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20750: LD_ADDR_EXP 82
20754: PUSH
20755: LD_EXP 82
20759: PPUSH
20760: LD_VAR 0 2
20764: PPUSH
20765: EMPTY
20766: PPUSH
20767: CALL_OW 1
20771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20772: LD_ADDR_EXP 56
20776: PUSH
20777: LD_EXP 56
20781: PPUSH
20782: LD_VAR 0 2
20786: PPUSH
20787: EMPTY
20788: PPUSH
20789: CALL_OW 1
20793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20794: LD_ADDR_EXP 57
20798: PUSH
20799: LD_EXP 57
20803: PPUSH
20804: LD_VAR 0 2
20808: PPUSH
20809: EMPTY
20810: PPUSH
20811: CALL_OW 1
20815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20816: LD_ADDR_EXP 58
20820: PUSH
20821: LD_EXP 58
20825: PPUSH
20826: LD_VAR 0 2
20830: PPUSH
20831: LD_EXP 50
20835: PUSH
20836: LD_VAR 0 2
20840: ARRAY
20841: PPUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 30
20847: PUSH
20848: LD_INT 32
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PUSH
20855: LD_INT 30
20857: PUSH
20858: LD_INT 33
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20880: LD_ADDR_EXP 59
20884: PUSH
20885: LD_EXP 59
20889: PPUSH
20890: LD_VAR 0 2
20894: PPUSH
20895: LD_EXP 50
20899: PUSH
20900: LD_VAR 0 2
20904: ARRAY
20905: PPUSH
20906: LD_INT 2
20908: PUSH
20909: LD_INT 30
20911: PUSH
20912: LD_INT 32
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 30
20921: PUSH
20922: LD_INT 31
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: LIST
20933: PUSH
20934: LD_INT 58
20936: PUSH
20937: EMPTY
20938: LIST
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PPUSH
20944: CALL_OW 72
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20954: LD_ADDR_EXP 60
20958: PUSH
20959: LD_EXP 60
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20976: LD_ADDR_EXP 64
20980: PUSH
20981: LD_EXP 64
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20998: LD_ADDR_EXP 63
21002: PUSH
21003: LD_EXP 63
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21020: LD_ADDR_EXP 65
21024: PUSH
21025: LD_EXP 65
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21042: LD_ADDR_EXP 66
21046: PUSH
21047: LD_EXP 66
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21064: LD_ADDR_EXP 67
21068: PUSH
21069: LD_EXP 67
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21086: LD_ADDR_EXP 68
21090: PUSH
21091: LD_EXP 68
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21108: LD_ADDR_EXP 69
21112: PUSH
21113: LD_EXP 69
21117: PPUSH
21118: LD_VAR 0 2
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21130: LD_ADDR_EXP 70
21134: PUSH
21135: LD_EXP 70
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21152: LD_ADDR_EXP 71
21156: PUSH
21157: LD_EXP 71
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21174: LD_ADDR_EXP 72
21178: PUSH
21179: LD_EXP 72
21183: PPUSH
21184: LD_VAR 0 2
21188: PPUSH
21189: EMPTY
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21196: LD_ADDR_EXP 61
21200: PUSH
21201: LD_EXP 61
21205: PPUSH
21206: LD_VAR 0 2
21210: PPUSH
21211: LD_INT 0
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21219: LD_ADDR_EXP 74
21223: PUSH
21224: LD_EXP 74
21228: PPUSH
21229: LD_VAR 0 2
21233: PPUSH
21234: LD_INT 0
21236: PPUSH
21237: CALL_OW 1
21241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21242: LD_ADDR_EXP 62
21246: PUSH
21247: LD_EXP 62
21251: PPUSH
21252: LD_VAR 0 2
21256: PPUSH
21257: EMPTY
21258: PPUSH
21259: CALL_OW 1
21263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21264: LD_ADDR_EXP 73
21268: PUSH
21269: LD_EXP 73
21273: PPUSH
21274: LD_VAR 0 2
21278: PPUSH
21279: LD_INT 0
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21287: LD_ADDR_EXP 75
21291: PUSH
21292: LD_EXP 75
21296: PPUSH
21297: LD_VAR 0 2
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21309: LD_ADDR_EXP 78
21313: PUSH
21314: LD_EXP 78
21318: PPUSH
21319: LD_VAR 0 2
21323: PPUSH
21324: LD_INT 0
21326: PPUSH
21327: CALL_OW 1
21331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21332: LD_ADDR_EXP 79
21336: PUSH
21337: LD_EXP 79
21341: PPUSH
21342: LD_VAR 0 2
21346: PPUSH
21347: EMPTY
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21354: LD_ADDR_EXP 80
21358: PUSH
21359: LD_EXP 80
21363: PPUSH
21364: LD_VAR 0 2
21368: PPUSH
21369: EMPTY
21370: PPUSH
21371: CALL_OW 1
21375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21376: LD_ADDR_EXP 81
21380: PUSH
21381: LD_EXP 81
21385: PPUSH
21386: LD_VAR 0 2
21390: PPUSH
21391: EMPTY
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21398: LD_ADDR_EXP 83
21402: PUSH
21403: LD_EXP 83
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: LD_EXP 50
21417: PUSH
21418: LD_VAR 0 2
21422: ARRAY
21423: PPUSH
21424: LD_INT 2
21426: PUSH
21427: LD_INT 30
21429: PUSH
21430: LD_INT 6
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 30
21439: PUSH
21440: LD_INT 7
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PUSH
21447: LD_INT 30
21449: PUSH
21450: LD_INT 8
21452: PUSH
21453: EMPTY
21454: LIST
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: PPUSH
21463: CALL_OW 72
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21473: LD_ADDR_EXP 84
21477: PUSH
21478: LD_EXP 84
21482: PPUSH
21483: LD_VAR 0 2
21487: PPUSH
21488: EMPTY
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21495: LD_ADDR_EXP 85
21499: PUSH
21500: LD_EXP 85
21504: PPUSH
21505: LD_VAR 0 2
21509: PPUSH
21510: EMPTY
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21517: LD_ADDR_EXP 86
21521: PUSH
21522: LD_EXP 86
21526: PPUSH
21527: LD_VAR 0 2
21531: PPUSH
21532: EMPTY
21533: PPUSH
21534: CALL_OW 1
21538: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21539: LD_ADDR_EXP 87
21543: PUSH
21544: LD_EXP 87
21548: PPUSH
21549: LD_VAR 0 2
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21561: LD_ADDR_EXP 88
21565: PUSH
21566: LD_EXP 88
21570: PPUSH
21571: LD_VAR 0 2
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21583: LD_ADDR_EXP 89
21587: PUSH
21588: LD_EXP 89
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21605: LD_ADDR_EXP 90
21609: PUSH
21610: LD_EXP 90
21614: PPUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21627: LD_ADDR_EXP 91
21631: PUSH
21632: LD_EXP 91
21636: PPUSH
21637: LD_VAR 0 2
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21649: LD_ADDR_EXP 92
21653: PUSH
21654: LD_EXP 92
21658: PPUSH
21659: LD_VAR 0 2
21663: PPUSH
21664: LD_INT 0
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21672: LD_ADDR_EXP 93
21676: PUSH
21677: LD_EXP 93
21681: PPUSH
21682: LD_VAR 0 2
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// end ;
21695: GO 20596
21697: POP
21698: POP
// MC_InitSides ( ) ;
21699: CALL 21985 0 0
// MC_InitResearch ( ) ;
21703: CALL 21724 0 0
// CustomInitMacro ( ) ;
21707: CALL 304 0 0
// skirmish := true ;
21711: LD_ADDR_EXP 48
21715: PUSH
21716: LD_INT 1
21718: ST_TO_ADDR
// end ;
21719: LD_VAR 0 1
21723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21724: LD_INT 0
21726: PPUSH
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
// if not mc_bases then
21732: LD_EXP 50
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 21980
// for i = 1 to 8 do
21741: LD_ADDR_VAR 0 2
21745: PUSH
21746: DOUBLE
21747: LD_INT 1
21749: DEC
21750: ST_TO_ADDR
21751: LD_INT 8
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21757: LD_ADDR_EXP 77
21761: PUSH
21762: LD_EXP 77
21766: PPUSH
21767: LD_VAR 0 2
21771: PPUSH
21772: EMPTY
21773: PPUSH
21774: CALL_OW 1
21778: ST_TO_ADDR
21779: GO 21754
21781: POP
21782: POP
// tmp := [ ] ;
21783: LD_ADDR_VAR 0 5
21787: PUSH
21788: EMPTY
21789: ST_TO_ADDR
// for i = 1 to mc_sides do
21790: LD_ADDR_VAR 0 2
21794: PUSH
21795: DOUBLE
21796: LD_INT 1
21798: DEC
21799: ST_TO_ADDR
21800: LD_EXP 76
21804: PUSH
21805: FOR_TO
21806: IFFALSE 21864
// if not mc_sides [ i ] in tmp then
21808: LD_EXP 76
21812: PUSH
21813: LD_VAR 0 2
21817: ARRAY
21818: PUSH
21819: LD_VAR 0 5
21823: IN
21824: NOT
21825: IFFALSE 21862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21827: LD_ADDR_VAR 0 5
21831: PUSH
21832: LD_VAR 0 5
21836: PPUSH
21837: LD_VAR 0 5
21841: PUSH
21842: LD_INT 1
21844: PLUS
21845: PPUSH
21846: LD_EXP 76
21850: PUSH
21851: LD_VAR 0 2
21855: ARRAY
21856: PPUSH
21857: CALL_OW 2
21861: ST_TO_ADDR
21862: GO 21805
21864: POP
21865: POP
// if not tmp then
21866: LD_VAR 0 5
21870: NOT
21871: IFFALSE 21875
// exit ;
21873: GO 21980
// for j in tmp do
21875: LD_ADDR_VAR 0 3
21879: PUSH
21880: LD_VAR 0 5
21884: PUSH
21885: FOR_IN
21886: IFFALSE 21978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21888: LD_ADDR_VAR 0 6
21892: PUSH
21893: LD_INT 22
21895: PUSH
21896: LD_VAR 0 3
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: ST_TO_ADDR
// if not un then
21910: LD_VAR 0 6
21914: NOT
21915: IFFALSE 21919
// continue ;
21917: GO 21885
// nation := GetNation ( un [ 1 ] ) ;
21919: LD_ADDR_VAR 0 4
21923: PUSH
21924: LD_VAR 0 6
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 248
21937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21938: LD_ADDR_EXP 77
21942: PUSH
21943: LD_EXP 77
21947: PPUSH
21948: LD_VAR 0 3
21952: PPUSH
21953: LD_VAR 0 3
21957: PPUSH
21958: LD_VAR 0 4
21962: PPUSH
21963: LD_INT 1
21965: PPUSH
21966: CALL 49168 0 3
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// end ;
21976: GO 21885
21978: POP
21979: POP
// end ;
21980: LD_VAR 0 1
21984: RET
// export function MC_InitSides ( ) ; var i ; begin
21985: LD_INT 0
21987: PPUSH
21988: PPUSH
// if not mc_bases then
21989: LD_EXP 50
21993: NOT
21994: IFFALSE 21998
// exit ;
21996: GO 22072
// for i = 1 to mc_bases do
21998: LD_ADDR_VAR 0 2
22002: PUSH
22003: DOUBLE
22004: LD_INT 1
22006: DEC
22007: ST_TO_ADDR
22008: LD_EXP 50
22012: PUSH
22013: FOR_TO
22014: IFFALSE 22070
// if mc_bases [ i ] then
22016: LD_EXP 50
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: IFFALSE 22068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22028: LD_ADDR_EXP 76
22032: PUSH
22033: LD_EXP 76
22037: PPUSH
22038: LD_VAR 0 2
22042: PPUSH
22043: LD_EXP 50
22047: PUSH
22048: LD_VAR 0 2
22052: ARRAY
22053: PUSH
22054: LD_INT 1
22056: ARRAY
22057: PPUSH
22058: CALL_OW 255
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
22068: GO 22013
22070: POP
22071: POP
// end ;
22072: LD_VAR 0 1
22076: RET
// every 0 0$03 trigger skirmish do
22077: LD_EXP 48
22081: IFFALSE 22235
22083: GO 22085
22085: DISABLE
// begin enable ;
22086: ENABLE
// MC_CheckBuildings ( ) ;
22087: CALL 26747 0 0
// MC_CheckPeopleLife ( ) ;
22091: CALL 26908 0 0
// RaiseSailEvent ( 100 ) ;
22095: LD_INT 100
22097: PPUSH
22098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22102: LD_INT 103
22104: PPUSH
22105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22109: LD_INT 104
22111: PPUSH
22112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22116: LD_INT 105
22118: PPUSH
22119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22123: LD_INT 106
22125: PPUSH
22126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22130: LD_INT 107
22132: PPUSH
22133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22137: LD_INT 108
22139: PPUSH
22140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22144: LD_INT 109
22146: PPUSH
22147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22151: LD_INT 110
22153: PPUSH
22154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22158: LD_INT 111
22160: PPUSH
22161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22165: LD_INT 112
22167: PPUSH
22168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22172: LD_INT 113
22174: PPUSH
22175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22179: LD_INT 120
22181: PPUSH
22182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22186: LD_INT 121
22188: PPUSH
22189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22193: LD_INT 122
22195: PPUSH
22196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22200: LD_INT 123
22202: PPUSH
22203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22207: LD_INT 124
22209: PPUSH
22210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22214: LD_INT 125
22216: PPUSH
22217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22221: LD_INT 126
22223: PPUSH
22224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22228: LD_INT 200
22230: PPUSH
22231: CALL_OW 427
// end ;
22235: END
// on SailEvent ( event ) do begin if event < 100 then
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 100
22243: LESS
22244: IFFALSE 22255
// CustomEvent ( event ) ;
22246: LD_VAR 0 1
22250: PPUSH
22251: CALL 17398 0 1
// if event = 100 then
22255: LD_VAR 0 1
22259: PUSH
22260: LD_INT 100
22262: EQUAL
22263: IFFALSE 22269
// MC_ClassManager ( ) ;
22265: CALL 22661 0 0
// if event = 101 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 101
22276: EQUAL
22277: IFFALSE 22283
// MC_RepairBuildings ( ) ;
22279: CALL 27493 0 0
// if event = 102 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 102
22290: EQUAL
22291: IFFALSE 22297
// MC_Heal ( ) ;
22293: CALL 28428 0 0
// if event = 103 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 103
22304: EQUAL
22305: IFFALSE 22311
// MC_Build ( ) ;
22307: CALL 28850 0 0
// if event = 104 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 104
22318: EQUAL
22319: IFFALSE 22325
// MC_TurretWeapon ( ) ;
22321: CALL 30484 0 0
// if event = 105 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 105
22332: EQUAL
22333: IFFALSE 22339
// MC_BuildUpgrade ( ) ;
22335: CALL 30035 0 0
// if event = 106 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 106
22346: EQUAL
22347: IFFALSE 22353
// MC_PlantMines ( ) ;
22349: CALL 30914 0 0
// if event = 107 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 107
22360: EQUAL
22361: IFFALSE 22367
// MC_CollectCrates ( ) ;
22363: CALL 31712 0 0
// if event = 108 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 108
22374: EQUAL
22375: IFFALSE 22381
// MC_LinkRemoteControl ( ) ;
22377: CALL 33562 0 0
// if event = 109 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 109
22388: EQUAL
22389: IFFALSE 22395
// MC_ProduceVehicle ( ) ;
22391: CALL 33743 0 0
// if event = 110 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 110
22402: EQUAL
22403: IFFALSE 22409
// MC_SendAttack ( ) ;
22405: CALL 34209 0 0
// if event = 111 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 111
22416: EQUAL
22417: IFFALSE 22423
// MC_Defend ( ) ;
22419: CALL 34317 0 0
// if event = 112 then
22423: LD_VAR 0 1
22427: PUSH
22428: LD_INT 112
22430: EQUAL
22431: IFFALSE 22437
// MC_Research ( ) ;
22433: CALL 35197 0 0
// if event = 113 then
22437: LD_VAR 0 1
22441: PUSH
22442: LD_INT 113
22444: EQUAL
22445: IFFALSE 22451
// MC_MinesTrigger ( ) ;
22447: CALL 36311 0 0
// if event = 120 then
22451: LD_VAR 0 1
22455: PUSH
22456: LD_INT 120
22458: EQUAL
22459: IFFALSE 22465
// MC_RepairVehicle ( ) ;
22461: CALL 36410 0 0
// if event = 121 then
22465: LD_VAR 0 1
22469: PUSH
22470: LD_INT 121
22472: EQUAL
22473: IFFALSE 22479
// MC_TameApe ( ) ;
22475: CALL 37179 0 0
// if event = 122 then
22479: LD_VAR 0 1
22483: PUSH
22484: LD_INT 122
22486: EQUAL
22487: IFFALSE 22493
// MC_ChangeApeClass ( ) ;
22489: CALL 38008 0 0
// if event = 123 then
22493: LD_VAR 0 1
22497: PUSH
22498: LD_INT 123
22500: EQUAL
22501: IFFALSE 22507
// MC_Bazooka ( ) ;
22503: CALL 38658 0 0
// if event = 124 then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 124
22514: EQUAL
22515: IFFALSE 22521
// MC_TeleportExit ( ) ;
22517: CALL 38856 0 0
// if event = 125 then
22521: LD_VAR 0 1
22525: PUSH
22526: LD_INT 125
22528: EQUAL
22529: IFFALSE 22535
// MC_Deposits ( ) ;
22531: CALL 39503 0 0
// if event = 126 then
22535: LD_VAR 0 1
22539: PUSH
22540: LD_INT 126
22542: EQUAL
22543: IFFALSE 22549
// MC_RemoteDriver ( ) ;
22545: CALL 40128 0 0
// if event = 200 then
22549: LD_VAR 0 1
22553: PUSH
22554: LD_INT 200
22556: EQUAL
22557: IFFALSE 22563
// MC_Idle ( ) ;
22559: CALL 42035 0 0
// end ;
22563: PPOPN 1
22565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22566: LD_INT 0
22568: PPUSH
22569: PPUSH
// if not mc_bases [ base ] or not tag then
22570: LD_EXP 50
22574: PUSH
22575: LD_VAR 0 1
22579: ARRAY
22580: NOT
22581: PUSH
22582: LD_VAR 0 2
22586: NOT
22587: OR
22588: IFFALSE 22592
// exit ;
22590: GO 22656
// for i in mc_bases [ base ] union mc_ape [ base ] do
22592: LD_ADDR_VAR 0 4
22596: PUSH
22597: LD_EXP 50
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PUSH
22608: LD_EXP 79
22612: PUSH
22613: LD_VAR 0 1
22617: ARRAY
22618: UNION
22619: PUSH
22620: FOR_IN
22621: IFFALSE 22654
// if GetTag ( i ) = tag then
22623: LD_VAR 0 4
22627: PPUSH
22628: CALL_OW 110
22632: PUSH
22633: LD_VAR 0 2
22637: EQUAL
22638: IFFALSE 22652
// SetTag ( i , 0 ) ;
22640: LD_VAR 0 4
22644: PPUSH
22645: LD_INT 0
22647: PPUSH
22648: CALL_OW 109
22652: GO 22620
22654: POP
22655: POP
// end ;
22656: LD_VAR 0 3
22660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
// if not mc_bases then
22671: LD_EXP 50
22675: NOT
22676: IFFALSE 22680
// exit ;
22678: GO 23129
// for i = 1 to mc_bases do
22680: LD_ADDR_VAR 0 2
22684: PUSH
22685: DOUBLE
22686: LD_INT 1
22688: DEC
22689: ST_TO_ADDR
22690: LD_EXP 50
22694: PUSH
22695: FOR_TO
22696: IFFALSE 23127
// begin tmp := MC_ClassCheckReq ( i ) ;
22698: LD_ADDR_VAR 0 4
22702: PUSH
22703: LD_VAR 0 2
22707: PPUSH
22708: CALL 23134 0 1
22712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22713: LD_ADDR_EXP 91
22717: PUSH
22718: LD_EXP 91
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: LD_VAR 0 4
22732: PPUSH
22733: CALL_OW 1
22737: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22738: LD_ADDR_VAR 0 6
22742: PUSH
22743: LD_EXP 50
22747: PUSH
22748: LD_VAR 0 2
22752: ARRAY
22753: PPUSH
22754: LD_INT 2
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: PUSH
22767: LD_INT 30
22769: PUSH
22770: LD_INT 5
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 72
22786: PUSH
22787: LD_EXP 50
22791: PUSH
22792: LD_VAR 0 2
22796: ARRAY
22797: PPUSH
22798: LD_INT 2
22800: PUSH
22801: LD_INT 30
22803: PUSH
22804: LD_INT 0
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 1
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: LIST
22825: PPUSH
22826: CALL_OW 72
22830: PUSH
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PPUSH
22852: CALL_OW 72
22856: PUSH
22857: LD_EXP 50
22861: PUSH
22862: LD_VAR 0 2
22866: ARRAY
22867: PPUSH
22868: LD_INT 2
22870: PUSH
22871: LD_INT 30
22873: PUSH
22874: LD_INT 6
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 7
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 8
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: ST_TO_ADDR
// for j := 1 to 4 do
22918: LD_ADDR_VAR 0 3
22922: PUSH
22923: DOUBLE
22924: LD_INT 1
22926: DEC
22927: ST_TO_ADDR
22928: LD_INT 4
22930: PUSH
22931: FOR_TO
22932: IFFALSE 23123
// begin if not tmp [ j ] then
22934: LD_VAR 0 4
22938: PUSH
22939: LD_VAR 0 3
22943: ARRAY
22944: NOT
22945: IFFALSE 22949
// continue ;
22947: GO 22931
// for p in tmp [ j ] do
22949: LD_ADDR_VAR 0 5
22953: PUSH
22954: LD_VAR 0 4
22958: PUSH
22959: LD_VAR 0 3
22963: ARRAY
22964: PUSH
22965: FOR_IN
22966: IFFALSE 23119
// begin if not b [ j ] then
22968: LD_VAR 0 6
22972: PUSH
22973: LD_VAR 0 3
22977: ARRAY
22978: NOT
22979: IFFALSE 22983
// break ;
22981: GO 23119
// e := 0 ;
22983: LD_ADDR_VAR 0 7
22987: PUSH
22988: LD_INT 0
22990: ST_TO_ADDR
// for k in b [ j ] do
22991: LD_ADDR_VAR 0 8
22995: PUSH
22996: LD_VAR 0 6
23000: PUSH
23001: LD_VAR 0 3
23005: ARRAY
23006: PUSH
23007: FOR_IN
23008: IFFALSE 23035
// if IsNotFull ( k ) then
23010: LD_VAR 0 8
23014: PPUSH
23015: CALL 51289 0 1
23019: IFFALSE 23033
// begin e := k ;
23021: LD_ADDR_VAR 0 7
23025: PUSH
23026: LD_VAR 0 8
23030: ST_TO_ADDR
// break ;
23031: GO 23035
// end ;
23033: GO 23007
23035: POP
23036: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23037: LD_VAR 0 7
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 7
23051: PPUSH
23052: CALL 85071 0 2
23056: NOT
23057: AND
23058: IFFALSE 23117
// begin if IsInUnit ( p ) then
23060: LD_VAR 0 5
23064: PPUSH
23065: CALL_OW 310
23069: IFFALSE 23080
// ComExitBuilding ( p ) ;
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23080: LD_VAR 0 5
23084: PPUSH
23085: LD_VAR 0 7
23089: PPUSH
23090: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 183
// AddComExitBuilding ( p ) ;
23108: LD_VAR 0 5
23112: PPUSH
23113: CALL_OW 182
// end ; end ;
23117: GO 22965
23119: POP
23120: POP
// end ;
23121: GO 22931
23123: POP
23124: POP
// end ;
23125: GO 22695
23127: POP
23128: POP
// end ;
23129: LD_VAR 0 1
23133: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23134: LD_INT 0
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
23144: PPUSH
23145: PPUSH
23146: PPUSH
23147: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23148: LD_ADDR_VAR 0 2
23152: PUSH
23153: LD_INT 0
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 0
23161: PUSH
23162: LD_INT 0
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23171: LD_VAR 0 1
23175: NOT
23176: PUSH
23177: LD_EXP 50
23181: PUSH
23182: LD_VAR 0 1
23186: ARRAY
23187: NOT
23188: OR
23189: PUSH
23190: LD_EXP 50
23194: PUSH
23195: LD_VAR 0 1
23199: ARRAY
23200: PPUSH
23201: LD_INT 2
23203: PUSH
23204: LD_INT 30
23206: PUSH
23207: LD_INT 0
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: PPUSH
23229: CALL_OW 72
23233: NOT
23234: OR
23235: IFFALSE 23239
// exit ;
23237: GO 26742
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23239: LD_ADDR_VAR 0 4
23243: PUSH
23244: LD_EXP 50
23248: PUSH
23249: LD_VAR 0 1
23253: ARRAY
23254: PPUSH
23255: LD_INT 2
23257: PUSH
23258: LD_INT 25
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: LD_INT 25
23270: PUSH
23271: LD_INT 2
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PUSH
23278: LD_INT 25
23280: PUSH
23281: LD_INT 3
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 25
23290: PUSH
23291: LD_INT 4
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: LD_INT 25
23300: PUSH
23301: LD_INT 5
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 25
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: LD_INT 25
23320: PUSH
23321: LD_INT 9
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: ST_TO_ADDR
// if not tmp then
23343: LD_VAR 0 4
23347: NOT
23348: IFFALSE 23352
// exit ;
23350: GO 26742
// for i in tmp do
23352: LD_ADDR_VAR 0 3
23356: PUSH
23357: LD_VAR 0 4
23361: PUSH
23362: FOR_IN
23363: IFFALSE 23394
// if GetTag ( i ) then
23365: LD_VAR 0 3
23369: PPUSH
23370: CALL_OW 110
23374: IFFALSE 23392
// tmp := tmp diff i ;
23376: LD_ADDR_VAR 0 4
23380: PUSH
23381: LD_VAR 0 4
23385: PUSH
23386: LD_VAR 0 3
23390: DIFF
23391: ST_TO_ADDR
23392: GO 23362
23394: POP
23395: POP
// if not tmp then
23396: LD_VAR 0 4
23400: NOT
23401: IFFALSE 23405
// exit ;
23403: GO 26742
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23405: LD_ADDR_VAR 0 5
23409: PUSH
23410: LD_EXP 50
23414: PUSH
23415: LD_VAR 0 1
23419: ARRAY
23420: PPUSH
23421: LD_INT 2
23423: PUSH
23424: LD_INT 25
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 25
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 25
23446: PUSH
23447: LD_INT 8
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 25
23456: PUSH
23457: LD_INT 9
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23476: LD_ADDR_VAR 0 6
23480: PUSH
23481: LD_EXP 50
23485: PUSH
23486: LD_VAR 0 1
23490: ARRAY
23491: PPUSH
23492: LD_INT 25
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PPUSH
23502: CALL_OW 72
23506: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23507: LD_ADDR_VAR 0 7
23511: PUSH
23512: LD_EXP 50
23516: PUSH
23517: LD_VAR 0 1
23521: ARRAY
23522: PPUSH
23523: LD_INT 25
23525: PUSH
23526: LD_INT 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PPUSH
23533: CALL_OW 72
23537: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23538: LD_ADDR_VAR 0 8
23542: PUSH
23543: LD_EXP 50
23547: PUSH
23548: LD_VAR 0 1
23552: ARRAY
23553: PPUSH
23554: LD_INT 25
23556: PUSH
23557: LD_INT 4
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 24
23566: PUSH
23567: LD_INT 251
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PPUSH
23578: CALL_OW 72
23582: ST_TO_ADDR
// if mc_is_defending [ base ] then
23583: LD_EXP 93
23587: PUSH
23588: LD_VAR 0 1
23592: ARRAY
23593: IFFALSE 24054
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23595: LD_ADDR_EXP 92
23599: PUSH
23600: LD_EXP 92
23604: PPUSH
23605: LD_VAR 0 1
23609: PPUSH
23610: LD_INT 4
23612: PPUSH
23613: CALL_OW 1
23617: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 4
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 72
23666: ST_TO_ADDR
// if not b then
23667: LD_VAR 0 12
23671: NOT
23672: IFFALSE 23676
// exit ;
23674: GO 26742
// p := [ ] ;
23676: LD_ADDR_VAR 0 11
23680: PUSH
23681: EMPTY
23682: ST_TO_ADDR
// if sci >= 2 then
23683: LD_VAR 0 8
23687: PUSH
23688: LD_INT 2
23690: GREATEREQUAL
23691: IFFALSE 23722
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23693: LD_ADDR_VAR 0 8
23697: PUSH
23698: LD_VAR 0 8
23702: PUSH
23703: LD_INT 1
23705: ARRAY
23706: PUSH
23707: LD_VAR 0 8
23711: PUSH
23712: LD_INT 2
23714: ARRAY
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: ST_TO_ADDR
23720: GO 23783
// if sci = 1 then
23722: LD_VAR 0 8
23726: PUSH
23727: LD_INT 1
23729: EQUAL
23730: IFFALSE 23751
// sci := [ sci [ 1 ] ] else
23732: LD_ADDR_VAR 0 8
23736: PUSH
23737: LD_VAR 0 8
23741: PUSH
23742: LD_INT 1
23744: ARRAY
23745: PUSH
23746: EMPTY
23747: LIST
23748: ST_TO_ADDR
23749: GO 23783
// if sci = 0 then
23751: LD_VAR 0 8
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23783
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23761: LD_ADDR_VAR 0 11
23765: PUSH
23766: LD_VAR 0 4
23770: PPUSH
23771: LD_INT 4
23773: PPUSH
23774: CALL 84943 0 2
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// if eng > 4 then
23783: LD_VAR 0 6
23787: PUSH
23788: LD_INT 4
23790: GREATER
23791: IFFALSE 23837
// for i = eng downto 4 do
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: DOUBLE
23799: LD_VAR 0 6
23803: INC
23804: ST_TO_ADDR
23805: LD_INT 4
23807: PUSH
23808: FOR_DOWNTO
23809: IFFALSE 23835
// eng := eng diff eng [ i ] ;
23811: LD_ADDR_VAR 0 6
23815: PUSH
23816: LD_VAR 0 6
23820: PUSH
23821: LD_VAR 0 6
23825: PUSH
23826: LD_VAR 0 3
23830: ARRAY
23831: DIFF
23832: ST_TO_ADDR
23833: GO 23808
23835: POP
23836: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23837: LD_ADDR_VAR 0 4
23841: PUSH
23842: LD_VAR 0 4
23846: PUSH
23847: LD_VAR 0 5
23851: PUSH
23852: LD_VAR 0 6
23856: UNION
23857: PUSH
23858: LD_VAR 0 7
23862: UNION
23863: PUSH
23864: LD_VAR 0 8
23868: UNION
23869: DIFF
23870: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23871: LD_ADDR_VAR 0 13
23875: PUSH
23876: LD_EXP 50
23880: PUSH
23881: LD_VAR 0 1
23885: ARRAY
23886: PPUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: LD_INT 32
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_INT 31
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: LIST
23914: PPUSH
23915: CALL_OW 72
23919: PUSH
23920: LD_EXP 50
23924: PUSH
23925: LD_VAR 0 1
23929: ARRAY
23930: PPUSH
23931: LD_INT 2
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 4
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 30
23946: PUSH
23947: LD_INT 5
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: LIST
23958: PPUSH
23959: CALL_OW 72
23963: PUSH
23964: LD_INT 6
23966: MUL
23967: PLUS
23968: ST_TO_ADDR
// if bcount < tmp then
23969: LD_VAR 0 13
23973: PUSH
23974: LD_VAR 0 4
23978: LESS
23979: IFFALSE 24025
// for i = tmp downto bcount do
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: DOUBLE
23987: LD_VAR 0 4
23991: INC
23992: ST_TO_ADDR
23993: LD_VAR 0 13
23997: PUSH
23998: FOR_DOWNTO
23999: IFFALSE 24023
// tmp := Delete ( tmp , tmp ) ;
24001: LD_ADDR_VAR 0 4
24005: PUSH
24006: LD_VAR 0 4
24010: PPUSH
24011: LD_VAR 0 4
24015: PPUSH
24016: CALL_OW 3
24020: ST_TO_ADDR
24021: GO 23998
24023: POP
24024: POP
// result := [ tmp , 0 , 0 , p ] ;
24025: LD_ADDR_VAR 0 2
24029: PUSH
24030: LD_VAR 0 4
24034: PUSH
24035: LD_INT 0
24037: PUSH
24038: LD_INT 0
24040: PUSH
24041: LD_VAR 0 11
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: LIST
24051: ST_TO_ADDR
// exit ;
24052: GO 26742
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24054: LD_EXP 50
24058: PUSH
24059: LD_VAR 0 1
24063: ARRAY
24064: PPUSH
24065: LD_INT 2
24067: PUSH
24068: LD_INT 30
24070: PUSH
24071: LD_INT 6
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 30
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 30
24090: PUSH
24091: LD_INT 8
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: NOT
24109: PUSH
24110: LD_EXP 50
24114: PUSH
24115: LD_VAR 0 1
24119: ARRAY
24120: PPUSH
24121: LD_INT 30
24123: PUSH
24124: LD_INT 3
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PPUSH
24131: CALL_OW 72
24135: NOT
24136: AND
24137: IFFALSE 24209
// begin if eng = tmp then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_VAR 0 4
24148: EQUAL
24149: IFFALSE 24153
// exit ;
24151: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24153: LD_ADDR_EXP 92
24157: PUSH
24158: LD_EXP 92
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: CALL_OW 1
24175: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24176: LD_ADDR_VAR 0 2
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 6
24193: DIFF
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: LD_INT 0
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: ST_TO_ADDR
// exit ;
24207: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24209: LD_EXP 77
24213: PUSH
24214: LD_EXP 76
24218: PUSH
24219: LD_VAR 0 1
24223: ARRAY
24224: ARRAY
24225: PUSH
24226: LD_EXP 50
24230: PUSH
24231: LD_VAR 0 1
24235: ARRAY
24236: PPUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: LD_INT 6
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 30
24252: PUSH
24253: LD_INT 7
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 8
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: PPUSH
24276: CALL_OW 72
24280: AND
24281: PUSH
24282: LD_EXP 50
24286: PUSH
24287: LD_VAR 0 1
24291: ARRAY
24292: PPUSH
24293: LD_INT 30
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 72
24307: NOT
24308: AND
24309: IFFALSE 24523
// begin if sci >= 6 then
24311: LD_VAR 0 8
24315: PUSH
24316: LD_INT 6
24318: GREATEREQUAL
24319: IFFALSE 24323
// exit ;
24321: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24323: LD_ADDR_EXP 92
24327: PUSH
24328: LD_EXP 92
24332: PPUSH
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_INT 2
24340: PPUSH
24341: CALL_OW 1
24345: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24346: LD_ADDR_VAR 0 9
24350: PUSH
24351: LD_VAR 0 4
24355: PUSH
24356: LD_VAR 0 8
24360: DIFF
24361: PPUSH
24362: LD_INT 4
24364: PPUSH
24365: CALL 84943 0 2
24369: ST_TO_ADDR
// p := [ ] ;
24370: LD_ADDR_VAR 0 11
24374: PUSH
24375: EMPTY
24376: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24377: LD_VAR 0 8
24381: PUSH
24382: LD_INT 6
24384: LESS
24385: PUSH
24386: LD_VAR 0 9
24390: PUSH
24391: LD_INT 6
24393: GREATER
24394: AND
24395: IFFALSE 24476
// begin for i = 1 to 6 - sci do
24397: LD_ADDR_VAR 0 3
24401: PUSH
24402: DOUBLE
24403: LD_INT 1
24405: DEC
24406: ST_TO_ADDR
24407: LD_INT 6
24409: PUSH
24410: LD_VAR 0 8
24414: MINUS
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24472
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_INT 1
24445: ARRAY
24446: PPUSH
24447: CALL_OW 2
24451: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24452: LD_ADDR_VAR 0 9
24456: PUSH
24457: LD_VAR 0 9
24461: PPUSH
24462: LD_INT 1
24464: PPUSH
24465: CALL_OW 3
24469: ST_TO_ADDR
// end ;
24470: GO 24416
24472: POP
24473: POP
// end else
24474: GO 24496
// if sort then
24476: LD_VAR 0 9
24480: IFFALSE 24496
// p := sort [ 1 ] ;
24482: LD_ADDR_VAR 0 11
24486: PUSH
24487: LD_VAR 0 9
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_INT 0
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: LD_VAR 0 11
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: ST_TO_ADDR
// exit ;
24521: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24523: LD_EXP 77
24527: PUSH
24528: LD_EXP 76
24532: PUSH
24533: LD_VAR 0 1
24537: ARRAY
24538: ARRAY
24539: PUSH
24540: LD_EXP 50
24544: PUSH
24545: LD_VAR 0 1
24549: ARRAY
24550: PPUSH
24551: LD_INT 2
24553: PUSH
24554: LD_INT 30
24556: PUSH
24557: LD_INT 6
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 30
24566: PUSH
24567: LD_INT 7
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 8
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 72
24594: AND
24595: PUSH
24596: LD_EXP 50
24600: PUSH
24601: LD_VAR 0 1
24605: ARRAY
24606: PPUSH
24607: LD_INT 30
24609: PUSH
24610: LD_INT 3
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 72
24621: AND
24622: IFFALSE 25356
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24624: LD_ADDR_EXP 92
24628: PUSH
24629: LD_EXP 92
24633: PPUSH
24634: LD_VAR 0 1
24638: PPUSH
24639: LD_INT 3
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24647: LD_ADDR_VAR 0 2
24651: PUSH
24652: LD_INT 0
24654: PUSH
24655: LD_INT 0
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: ST_TO_ADDR
// if not eng then
24670: LD_VAR 0 6
24674: NOT
24675: IFFALSE 24738
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24677: LD_ADDR_VAR 0 11
24681: PUSH
24682: LD_VAR 0 4
24686: PPUSH
24687: LD_INT 2
24689: PPUSH
24690: CALL 84943 0 2
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24699: LD_ADDR_VAR 0 2
24703: PUSH
24704: LD_VAR 0 2
24708: PPUSH
24709: LD_INT 2
24711: PPUSH
24712: LD_VAR 0 11
24716: PPUSH
24717: CALL_OW 1
24721: ST_TO_ADDR
// tmp := tmp diff p ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 11
24736: DIFF
24737: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 8
24747: PUSH
24748: LD_INT 6
24750: LESS
24751: AND
24752: IFFALSE 24940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24754: LD_ADDR_VAR 0 9
24758: PUSH
24759: LD_VAR 0 4
24763: PUSH
24764: LD_VAR 0 8
24768: PUSH
24769: LD_VAR 0 7
24773: UNION
24774: DIFF
24775: PPUSH
24776: LD_INT 4
24778: PPUSH
24779: CALL 84943 0 2
24783: ST_TO_ADDR
// p := [ ] ;
24784: LD_ADDR_VAR 0 11
24788: PUSH
24789: EMPTY
24790: ST_TO_ADDR
// if sort then
24791: LD_VAR 0 9
24795: IFFALSE 24911
// for i = 1 to 6 - sci do
24797: LD_ADDR_VAR 0 3
24801: PUSH
24802: DOUBLE
24803: LD_INT 1
24805: DEC
24806: ST_TO_ADDR
24807: LD_INT 6
24809: PUSH
24810: LD_VAR 0 8
24814: MINUS
24815: PUSH
24816: FOR_TO
24817: IFFALSE 24909
// begin if i = sort then
24819: LD_VAR 0 3
24823: PUSH
24824: LD_VAR 0 9
24828: EQUAL
24829: IFFALSE 24833
// break ;
24831: GO 24909
// if GetClass ( i ) = 4 then
24833: LD_VAR 0 3
24837: PPUSH
24838: CALL_OW 257
24842: PUSH
24843: LD_INT 4
24845: EQUAL
24846: IFFALSE 24850
// continue ;
24848: GO 24816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24850: LD_ADDR_VAR 0 11
24854: PUSH
24855: LD_VAR 0 11
24859: PPUSH
24860: LD_VAR 0 11
24864: PUSH
24865: LD_INT 1
24867: PLUS
24868: PPUSH
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 3
24878: ARRAY
24879: PPUSH
24880: CALL_OW 2
24884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24885: LD_ADDR_VAR 0 4
24889: PUSH
24890: LD_VAR 0 4
24894: PUSH
24895: LD_VAR 0 9
24899: PUSH
24900: LD_VAR 0 3
24904: ARRAY
24905: DIFF
24906: ST_TO_ADDR
// end ;
24907: GO 24816
24909: POP
24910: POP
// if p then
24911: LD_VAR 0 11
24915: IFFALSE 24940
// result := Replace ( result , 4 , p ) ;
24917: LD_ADDR_VAR 0 2
24921: PUSH
24922: LD_VAR 0 2
24926: PPUSH
24927: LD_INT 4
24929: PPUSH
24930: LD_VAR 0 11
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24940: LD_VAR 0 4
24944: PUSH
24945: LD_VAR 0 7
24949: PUSH
24950: LD_INT 6
24952: LESS
24953: AND
24954: IFFALSE 25142
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24956: LD_ADDR_VAR 0 9
24960: PUSH
24961: LD_VAR 0 4
24965: PUSH
24966: LD_VAR 0 8
24970: PUSH
24971: LD_VAR 0 7
24975: UNION
24976: DIFF
24977: PPUSH
24978: LD_INT 3
24980: PPUSH
24981: CALL 84943 0 2
24985: ST_TO_ADDR
// p := [ ] ;
24986: LD_ADDR_VAR 0 11
24990: PUSH
24991: EMPTY
24992: ST_TO_ADDR
// if sort then
24993: LD_VAR 0 9
24997: IFFALSE 25113
// for i = 1 to 6 - mech do
24999: LD_ADDR_VAR 0 3
25003: PUSH
25004: DOUBLE
25005: LD_INT 1
25007: DEC
25008: ST_TO_ADDR
25009: LD_INT 6
25011: PUSH
25012: LD_VAR 0 7
25016: MINUS
25017: PUSH
25018: FOR_TO
25019: IFFALSE 25111
// begin if i = sort then
25021: LD_VAR 0 3
25025: PUSH
25026: LD_VAR 0 9
25030: EQUAL
25031: IFFALSE 25035
// break ;
25033: GO 25111
// if GetClass ( i ) = 3 then
25035: LD_VAR 0 3
25039: PPUSH
25040: CALL_OW 257
25044: PUSH
25045: LD_INT 3
25047: EQUAL
25048: IFFALSE 25052
// continue ;
25050: GO 25018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25052: LD_ADDR_VAR 0 11
25056: PUSH
25057: LD_VAR 0 11
25061: PPUSH
25062: LD_VAR 0 11
25066: PUSH
25067: LD_INT 1
25069: PLUS
25070: PPUSH
25071: LD_VAR 0 9
25075: PUSH
25076: LD_VAR 0 3
25080: ARRAY
25081: PPUSH
25082: CALL_OW 2
25086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_VAR 0 4
25096: PUSH
25097: LD_VAR 0 9
25101: PUSH
25102: LD_VAR 0 3
25106: ARRAY
25107: DIFF
25108: ST_TO_ADDR
// end ;
25109: GO 25018
25111: POP
25112: POP
// if p then
25113: LD_VAR 0 11
25117: IFFALSE 25142
// result := Replace ( result , 3 , p ) ;
25119: LD_ADDR_VAR 0 2
25123: PUSH
25124: LD_VAR 0 2
25128: PPUSH
25129: LD_INT 3
25131: PPUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: CALL_OW 1
25141: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25142: LD_VAR 0 4
25146: PUSH
25147: LD_INT 6
25149: GREATER
25150: PUSH
25151: LD_VAR 0 6
25155: PUSH
25156: LD_INT 6
25158: LESS
25159: AND
25160: IFFALSE 25354
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25162: LD_ADDR_VAR 0 9
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 8
25176: PUSH
25177: LD_VAR 0 7
25181: UNION
25182: PUSH
25183: LD_VAR 0 6
25187: UNION
25188: DIFF
25189: PPUSH
25190: LD_INT 2
25192: PPUSH
25193: CALL 84943 0 2
25197: ST_TO_ADDR
// p := [ ] ;
25198: LD_ADDR_VAR 0 11
25202: PUSH
25203: EMPTY
25204: ST_TO_ADDR
// if sort then
25205: LD_VAR 0 9
25209: IFFALSE 25325
// for i = 1 to 6 - eng do
25211: LD_ADDR_VAR 0 3
25215: PUSH
25216: DOUBLE
25217: LD_INT 1
25219: DEC
25220: ST_TO_ADDR
25221: LD_INT 6
25223: PUSH
25224: LD_VAR 0 6
25228: MINUS
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25323
// begin if i = sort then
25233: LD_VAR 0 3
25237: PUSH
25238: LD_VAR 0 9
25242: EQUAL
25243: IFFALSE 25247
// break ;
25245: GO 25323
// if GetClass ( i ) = 2 then
25247: LD_VAR 0 3
25251: PPUSH
25252: CALL_OW 257
25256: PUSH
25257: LD_INT 2
25259: EQUAL
25260: IFFALSE 25264
// continue ;
25262: GO 25230
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25264: LD_ADDR_VAR 0 11
25268: PUSH
25269: LD_VAR 0 11
25273: PPUSH
25274: LD_VAR 0 11
25278: PUSH
25279: LD_INT 1
25281: PLUS
25282: PPUSH
25283: LD_VAR 0 9
25287: PUSH
25288: LD_VAR 0 3
25292: ARRAY
25293: PPUSH
25294: CALL_OW 2
25298: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25299: LD_ADDR_VAR 0 4
25303: PUSH
25304: LD_VAR 0 4
25308: PUSH
25309: LD_VAR 0 9
25313: PUSH
25314: LD_VAR 0 3
25318: ARRAY
25319: DIFF
25320: ST_TO_ADDR
// end ;
25321: GO 25230
25323: POP
25324: POP
// if p then
25325: LD_VAR 0 11
25329: IFFALSE 25354
// result := Replace ( result , 2 , p ) ;
25331: LD_ADDR_VAR 0 2
25335: PUSH
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_INT 2
25343: PPUSH
25344: LD_VAR 0 11
25348: PPUSH
25349: CALL_OW 1
25353: ST_TO_ADDR
// end ; exit ;
25354: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25356: LD_EXP 77
25360: PUSH
25361: LD_EXP 76
25365: PUSH
25366: LD_VAR 0 1
25370: ARRAY
25371: ARRAY
25372: NOT
25373: PUSH
25374: LD_EXP 50
25378: PUSH
25379: LD_VAR 0 1
25383: ARRAY
25384: PPUSH
25385: LD_INT 30
25387: PUSH
25388: LD_INT 3
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PPUSH
25395: CALL_OW 72
25399: AND
25400: PUSH
25401: LD_EXP 55
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: AND
25412: IFFALSE 26020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25414: LD_ADDR_EXP 92
25418: PUSH
25419: LD_EXP 92
25423: PPUSH
25424: LD_VAR 0 1
25428: PPUSH
25429: LD_INT 5
25431: PPUSH
25432: CALL_OW 1
25436: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25437: LD_ADDR_VAR 0 2
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: LD_INT 0
25447: PUSH
25448: LD_INT 0
25450: PUSH
25451: LD_INT 0
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: ST_TO_ADDR
// if sci > 1 then
25460: LD_VAR 0 8
25464: PUSH
25465: LD_INT 1
25467: GREATER
25468: IFFALSE 25496
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25470: LD_ADDR_VAR 0 4
25474: PUSH
25475: LD_VAR 0 4
25479: PUSH
25480: LD_VAR 0 8
25484: PUSH
25485: LD_VAR 0 8
25489: PUSH
25490: LD_INT 1
25492: ARRAY
25493: DIFF
25494: DIFF
25495: ST_TO_ADDR
// if tmp and not sci then
25496: LD_VAR 0 4
25500: PUSH
25501: LD_VAR 0 8
25505: NOT
25506: AND
25507: IFFALSE 25576
// begin sort := SortBySkill ( tmp , 4 ) ;
25509: LD_ADDR_VAR 0 9
25513: PUSH
25514: LD_VAR 0 4
25518: PPUSH
25519: LD_INT 4
25521: PPUSH
25522: CALL 84943 0 2
25526: ST_TO_ADDR
// if sort then
25527: LD_VAR 0 9
25531: IFFALSE 25547
// p := sort [ 1 ] ;
25533: LD_ADDR_VAR 0 11
25537: PUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_INT 1
25545: ARRAY
25546: ST_TO_ADDR
// if p then
25547: LD_VAR 0 11
25551: IFFALSE 25576
// result := Replace ( result , 4 , p ) ;
25553: LD_ADDR_VAR 0 2
25557: PUSH
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 4
25565: PPUSH
25566: LD_VAR 0 11
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_VAR 0 4
25585: PUSH
25586: LD_VAR 0 7
25590: DIFF
25591: ST_TO_ADDR
// if tmp and mech < 6 then
25592: LD_VAR 0 4
25596: PUSH
25597: LD_VAR 0 7
25601: PUSH
25602: LD_INT 6
25604: LESS
25605: AND
25606: IFFALSE 25794
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_VAR 0 4
25617: PUSH
25618: LD_VAR 0 8
25622: PUSH
25623: LD_VAR 0 7
25627: UNION
25628: DIFF
25629: PPUSH
25630: LD_INT 3
25632: PPUSH
25633: CALL 84943 0 2
25637: ST_TO_ADDR
// p := [ ] ;
25638: LD_ADDR_VAR 0 11
25642: PUSH
25643: EMPTY
25644: ST_TO_ADDR
// if sort then
25645: LD_VAR 0 9
25649: IFFALSE 25765
// for i = 1 to 6 - mech do
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: DOUBLE
25657: LD_INT 1
25659: DEC
25660: ST_TO_ADDR
25661: LD_INT 6
25663: PUSH
25664: LD_VAR 0 7
25668: MINUS
25669: PUSH
25670: FOR_TO
25671: IFFALSE 25763
// begin if i = sort then
25673: LD_VAR 0 3
25677: PUSH
25678: LD_VAR 0 9
25682: EQUAL
25683: IFFALSE 25687
// break ;
25685: GO 25763
// if GetClass ( i ) = 3 then
25687: LD_VAR 0 3
25691: PPUSH
25692: CALL_OW 257
25696: PUSH
25697: LD_INT 3
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25704: LD_ADDR_VAR 0 11
25708: PUSH
25709: LD_VAR 0 11
25713: PPUSH
25714: LD_VAR 0 11
25718: PUSH
25719: LD_INT 1
25721: PLUS
25722: PPUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: PPUSH
25734: CALL_OW 2
25738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25739: LD_ADDR_VAR 0 4
25743: PUSH
25744: LD_VAR 0 4
25748: PUSH
25749: LD_VAR 0 9
25753: PUSH
25754: LD_VAR 0 3
25758: ARRAY
25759: DIFF
25760: ST_TO_ADDR
// end ;
25761: GO 25670
25763: POP
25764: POP
// if p then
25765: LD_VAR 0 11
25769: IFFALSE 25794
// result := Replace ( result , 3 , p ) ;
25771: LD_ADDR_VAR 0 2
25775: PUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: LD_INT 3
25783: PPUSH
25784: LD_VAR 0 11
25788: PPUSH
25789: CALL_OW 1
25793: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25794: LD_ADDR_VAR 0 4
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 6
25808: DIFF
25809: ST_TO_ADDR
// if tmp and eng < 6 then
25810: LD_VAR 0 4
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: LD_INT 6
25822: LESS
25823: AND
25824: IFFALSE 26018
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25826: LD_ADDR_VAR 0 9
25830: PUSH
25831: LD_VAR 0 4
25835: PUSH
25836: LD_VAR 0 8
25840: PUSH
25841: LD_VAR 0 7
25845: UNION
25846: PUSH
25847: LD_VAR 0 6
25851: UNION
25852: DIFF
25853: PPUSH
25854: LD_INT 2
25856: PPUSH
25857: CALL 84943 0 2
25861: ST_TO_ADDR
// p := [ ] ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: EMPTY
25868: ST_TO_ADDR
// if sort then
25869: LD_VAR 0 9
25873: IFFALSE 25989
// for i = 1 to 6 - eng do
25875: LD_ADDR_VAR 0 3
25879: PUSH
25880: DOUBLE
25881: LD_INT 1
25883: DEC
25884: ST_TO_ADDR
25885: LD_INT 6
25887: PUSH
25888: LD_VAR 0 6
25892: MINUS
25893: PUSH
25894: FOR_TO
25895: IFFALSE 25987
// begin if i = sort then
25897: LD_VAR 0 3
25901: PUSH
25902: LD_VAR 0 9
25906: EQUAL
25907: IFFALSE 25911
// break ;
25909: GO 25987
// if GetClass ( i ) = 2 then
25911: LD_VAR 0 3
25915: PPUSH
25916: CALL_OW 257
25920: PUSH
25921: LD_INT 2
25923: EQUAL
25924: IFFALSE 25928
// continue ;
25926: GO 25894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25928: LD_ADDR_VAR 0 11
25932: PUSH
25933: LD_VAR 0 11
25937: PPUSH
25938: LD_VAR 0 11
25942: PUSH
25943: LD_INT 1
25945: PLUS
25946: PPUSH
25947: LD_VAR 0 9
25951: PUSH
25952: LD_VAR 0 3
25956: ARRAY
25957: PPUSH
25958: CALL_OW 2
25962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25963: LD_ADDR_VAR 0 4
25967: PUSH
25968: LD_VAR 0 4
25972: PUSH
25973: LD_VAR 0 9
25977: PUSH
25978: LD_VAR 0 3
25982: ARRAY
25983: DIFF
25984: ST_TO_ADDR
// end ;
25985: GO 25894
25987: POP
25988: POP
// if p then
25989: LD_VAR 0 11
25993: IFFALSE 26018
// result := Replace ( result , 2 , p ) ;
25995: LD_ADDR_VAR 0 2
25999: PUSH
26000: LD_VAR 0 2
26004: PPUSH
26005: LD_INT 2
26007: PPUSH
26008: LD_VAR 0 11
26012: PPUSH
26013: CALL_OW 1
26017: ST_TO_ADDR
// end ; exit ;
26018: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26020: LD_EXP 77
26024: PUSH
26025: LD_EXP 76
26029: PUSH
26030: LD_VAR 0 1
26034: ARRAY
26035: ARRAY
26036: NOT
26037: PUSH
26038: LD_EXP 50
26042: PUSH
26043: LD_VAR 0 1
26047: ARRAY
26048: PPUSH
26049: LD_INT 30
26051: PUSH
26052: LD_INT 3
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PPUSH
26059: CALL_OW 72
26063: AND
26064: PUSH
26065: LD_EXP 55
26069: PUSH
26070: LD_VAR 0 1
26074: ARRAY
26075: NOT
26076: AND
26077: IFFALSE 26742
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26079: LD_ADDR_EXP 92
26083: PUSH
26084: LD_EXP 92
26088: PPUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: LD_INT 6
26096: PPUSH
26097: CALL_OW 1
26101: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26102: LD_ADDR_VAR 0 2
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 0
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: ST_TO_ADDR
// if sci >= 1 then
26125: LD_VAR 0 8
26129: PUSH
26130: LD_INT 1
26132: GREATEREQUAL
26133: IFFALSE 26155
// tmp := tmp diff sci [ 1 ] ;
26135: LD_ADDR_VAR 0 4
26139: PUSH
26140: LD_VAR 0 4
26144: PUSH
26145: LD_VAR 0 8
26149: PUSH
26150: LD_INT 1
26152: ARRAY
26153: DIFF
26154: ST_TO_ADDR
// if tmp and not sci then
26155: LD_VAR 0 4
26159: PUSH
26160: LD_VAR 0 8
26164: NOT
26165: AND
26166: IFFALSE 26235
// begin sort := SortBySkill ( tmp , 4 ) ;
26168: LD_ADDR_VAR 0 9
26172: PUSH
26173: LD_VAR 0 4
26177: PPUSH
26178: LD_INT 4
26180: PPUSH
26181: CALL 84943 0 2
26185: ST_TO_ADDR
// if sort then
26186: LD_VAR 0 9
26190: IFFALSE 26206
// p := sort [ 1 ] ;
26192: LD_ADDR_VAR 0 11
26196: PUSH
26197: LD_VAR 0 9
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: ST_TO_ADDR
// if p then
26206: LD_VAR 0 11
26210: IFFALSE 26235
// result := Replace ( result , 4 , p ) ;
26212: LD_ADDR_VAR 0 2
26216: PUSH
26217: LD_VAR 0 2
26221: PPUSH
26222: LD_INT 4
26224: PPUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 1
26234: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26235: LD_ADDR_VAR 0 4
26239: PUSH
26240: LD_VAR 0 4
26244: PUSH
26245: LD_VAR 0 7
26249: DIFF
26250: ST_TO_ADDR
// if tmp and mech < 6 then
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 7
26260: PUSH
26261: LD_INT 6
26263: LESS
26264: AND
26265: IFFALSE 26447
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26267: LD_ADDR_VAR 0 9
26271: PUSH
26272: LD_VAR 0 4
26276: PUSH
26277: LD_VAR 0 7
26281: DIFF
26282: PPUSH
26283: LD_INT 3
26285: PPUSH
26286: CALL 84943 0 2
26290: ST_TO_ADDR
// p := [ ] ;
26291: LD_ADDR_VAR 0 11
26295: PUSH
26296: EMPTY
26297: ST_TO_ADDR
// if sort then
26298: LD_VAR 0 9
26302: IFFALSE 26418
// for i = 1 to 6 - mech do
26304: LD_ADDR_VAR 0 3
26308: PUSH
26309: DOUBLE
26310: LD_INT 1
26312: DEC
26313: ST_TO_ADDR
26314: LD_INT 6
26316: PUSH
26317: LD_VAR 0 7
26321: MINUS
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26416
// begin if i = sort then
26326: LD_VAR 0 3
26330: PUSH
26331: LD_VAR 0 9
26335: EQUAL
26336: IFFALSE 26340
// break ;
26338: GO 26416
// if GetClass ( i ) = 3 then
26340: LD_VAR 0 3
26344: PPUSH
26345: CALL_OW 257
26349: PUSH
26350: LD_INT 3
26352: EQUAL
26353: IFFALSE 26357
// continue ;
26355: GO 26323
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26357: LD_ADDR_VAR 0 11
26361: PUSH
26362: LD_VAR 0 11
26366: PPUSH
26367: LD_VAR 0 11
26371: PUSH
26372: LD_INT 1
26374: PLUS
26375: PPUSH
26376: LD_VAR 0 9
26380: PUSH
26381: LD_VAR 0 3
26385: ARRAY
26386: PPUSH
26387: CALL_OW 2
26391: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26392: LD_ADDR_VAR 0 4
26396: PUSH
26397: LD_VAR 0 4
26401: PUSH
26402: LD_VAR 0 9
26406: PUSH
26407: LD_VAR 0 3
26411: ARRAY
26412: DIFF
26413: ST_TO_ADDR
// end ;
26414: GO 26323
26416: POP
26417: POP
// if p then
26418: LD_VAR 0 11
26422: IFFALSE 26447
// result := Replace ( result , 3 , p ) ;
26424: LD_ADDR_VAR 0 2
26428: PUSH
26429: LD_VAR 0 2
26433: PPUSH
26434: LD_INT 3
26436: PPUSH
26437: LD_VAR 0 11
26441: PPUSH
26442: CALL_OW 1
26446: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26447: LD_ADDR_VAR 0 4
26451: PUSH
26452: LD_VAR 0 4
26456: PUSH
26457: LD_VAR 0 6
26461: DIFF
26462: ST_TO_ADDR
// if tmp and eng < 4 then
26463: LD_VAR 0 4
26467: PUSH
26468: LD_VAR 0 6
26472: PUSH
26473: LD_INT 4
26475: LESS
26476: AND
26477: IFFALSE 26667
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26479: LD_ADDR_VAR 0 9
26483: PUSH
26484: LD_VAR 0 4
26488: PUSH
26489: LD_VAR 0 7
26493: PUSH
26494: LD_VAR 0 6
26498: UNION
26499: DIFF
26500: PPUSH
26501: LD_INT 2
26503: PPUSH
26504: CALL 84943 0 2
26508: ST_TO_ADDR
// p := [ ] ;
26509: LD_ADDR_VAR 0 11
26513: PUSH
26514: EMPTY
26515: ST_TO_ADDR
// if sort then
26516: LD_VAR 0 9
26520: IFFALSE 26636
// for i = 1 to 4 - eng do
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: DOUBLE
26528: LD_INT 1
26530: DEC
26531: ST_TO_ADDR
26532: LD_INT 4
26534: PUSH
26535: LD_VAR 0 6
26539: MINUS
26540: PUSH
26541: FOR_TO
26542: IFFALSE 26634
// begin if i = sort then
26544: LD_VAR 0 3
26548: PUSH
26549: LD_VAR 0 9
26553: EQUAL
26554: IFFALSE 26558
// break ;
26556: GO 26634
// if GetClass ( i ) = 2 then
26558: LD_VAR 0 3
26562: PPUSH
26563: CALL_OW 257
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26575
// continue ;
26573: GO 26541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26575: LD_ADDR_VAR 0 11
26579: PUSH
26580: LD_VAR 0 11
26584: PPUSH
26585: LD_VAR 0 11
26589: PUSH
26590: LD_INT 1
26592: PLUS
26593: PPUSH
26594: LD_VAR 0 9
26598: PUSH
26599: LD_VAR 0 3
26603: ARRAY
26604: PPUSH
26605: CALL_OW 2
26609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26610: LD_ADDR_VAR 0 4
26614: PUSH
26615: LD_VAR 0 4
26619: PUSH
26620: LD_VAR 0 9
26624: PUSH
26625: LD_VAR 0 3
26629: ARRAY
26630: DIFF
26631: ST_TO_ADDR
// end ;
26632: GO 26541
26634: POP
26635: POP
// if p then
26636: LD_VAR 0 11
26640: IFFALSE 26665
// result := Replace ( result , 2 , p ) ;
26642: LD_ADDR_VAR 0 2
26646: PUSH
26647: LD_VAR 0 2
26651: PPUSH
26652: LD_INT 2
26654: PPUSH
26655: LD_VAR 0 11
26659: PPUSH
26660: CALL_OW 1
26664: ST_TO_ADDR
// end else
26665: GO 26711
// for i = eng downto 5 do
26667: LD_ADDR_VAR 0 3
26671: PUSH
26672: DOUBLE
26673: LD_VAR 0 6
26677: INC
26678: ST_TO_ADDR
26679: LD_INT 5
26681: PUSH
26682: FOR_DOWNTO
26683: IFFALSE 26709
// tmp := tmp union eng [ i ] ;
26685: LD_ADDR_VAR 0 4
26689: PUSH
26690: LD_VAR 0 4
26694: PUSH
26695: LD_VAR 0 6
26699: PUSH
26700: LD_VAR 0 3
26704: ARRAY
26705: UNION
26706: ST_TO_ADDR
26707: GO 26682
26709: POP
26710: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26711: LD_ADDR_VAR 0 2
26715: PUSH
26716: LD_VAR 0 2
26720: PPUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_VAR 0 4
26728: PUSH
26729: LD_VAR 0 5
26733: DIFF
26734: PPUSH
26735: CALL_OW 1
26739: ST_TO_ADDR
// exit ;
26740: GO 26742
// end ; end ;
26742: LD_VAR 0 2
26746: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
26751: PPUSH
// if not mc_bases then
26752: LD_EXP 50
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 26903
// for i = 1 to mc_bases do
26761: LD_ADDR_VAR 0 2
26765: PUSH
26766: DOUBLE
26767: LD_INT 1
26769: DEC
26770: ST_TO_ADDR
26771: LD_EXP 50
26775: PUSH
26776: FOR_TO
26777: IFFALSE 26894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26779: LD_ADDR_VAR 0 3
26783: PUSH
26784: LD_EXP 50
26788: PUSH
26789: LD_VAR 0 2
26793: ARRAY
26794: PPUSH
26795: LD_INT 21
26797: PUSH
26798: LD_INT 3
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 3
26807: PUSH
26808: LD_INT 2
26810: PUSH
26811: LD_INT 30
26813: PUSH
26814: LD_INT 29
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 30
26823: PUSH
26824: LD_INT 30
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: LD_INT 24
26845: PUSH
26846: LD_INT 1000
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: LIST
26861: PPUSH
26862: CALL_OW 72
26866: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26867: LD_ADDR_EXP 51
26871: PUSH
26872: LD_EXP 51
26876: PPUSH
26877: LD_VAR 0 2
26881: PPUSH
26882: LD_VAR 0 3
26886: PPUSH
26887: CALL_OW 1
26891: ST_TO_ADDR
// end ;
26892: GO 26776
26894: POP
26895: POP
// RaiseSailEvent ( 101 ) ;
26896: LD_INT 101
26898: PPUSH
26899: CALL_OW 427
// end ;
26903: LD_VAR 0 1
26907: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26908: LD_INT 0
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
26914: PPUSH
26915: PPUSH
26916: PPUSH
// if not mc_bases then
26917: LD_EXP 50
26921: NOT
26922: IFFALSE 26926
// exit ;
26924: GO 27488
// for i = 1 to mc_bases do
26926: LD_ADDR_VAR 0 2
26930: PUSH
26931: DOUBLE
26932: LD_INT 1
26934: DEC
26935: ST_TO_ADDR
26936: LD_EXP 50
26940: PUSH
26941: FOR_TO
26942: IFFALSE 27479
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26944: LD_ADDR_VAR 0 5
26948: PUSH
26949: LD_EXP 50
26953: PUSH
26954: LD_VAR 0 2
26958: ARRAY
26959: PUSH
26960: LD_EXP 79
26964: PUSH
26965: LD_VAR 0 2
26969: ARRAY
26970: UNION
26971: PPUSH
26972: LD_INT 21
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 54
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: LD_INT 24
27003: PUSH
27004: LD_INT 1000
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 72
27028: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27029: LD_ADDR_VAR 0 6
27033: PUSH
27034: LD_EXP 50
27038: PUSH
27039: LD_VAR 0 2
27043: ARRAY
27044: PPUSH
27045: LD_INT 21
27047: PUSH
27048: LD_INT 1
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: LD_INT 3
27060: PUSH
27061: LD_INT 54
27063: PUSH
27064: EMPTY
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: LD_INT 24
27076: PUSH
27077: LD_INT 250
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27102: LD_ADDR_VAR 0 7
27106: PUSH
27107: LD_VAR 0 5
27111: PUSH
27112: LD_VAR 0 6
27116: DIFF
27117: ST_TO_ADDR
// if not need_heal_1 then
27118: LD_VAR 0 6
27122: NOT
27123: IFFALSE 27156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27125: LD_ADDR_EXP 53
27129: PUSH
27130: LD_EXP 53
27134: PPUSH
27135: LD_VAR 0 2
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PPUSH
27147: EMPTY
27148: PPUSH
27149: CALL 54067 0 3
27153: ST_TO_ADDR
27154: GO 27226
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27156: LD_ADDR_EXP 53
27160: PUSH
27161: LD_EXP 53
27165: PPUSH
27166: LD_VAR 0 2
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: LD_EXP 53
27182: PUSH
27183: LD_VAR 0 2
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_INT 3
27195: PUSH
27196: LD_INT 24
27198: PUSH
27199: LD_INT 1000
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PPUSH
27210: CALL_OW 72
27214: PUSH
27215: LD_VAR 0 6
27219: UNION
27220: PPUSH
27221: CALL 54067 0 3
27225: ST_TO_ADDR
// if not need_heal_2 then
27226: LD_VAR 0 7
27230: NOT
27231: IFFALSE 27264
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27233: LD_ADDR_EXP 53
27237: PUSH
27238: LD_EXP 53
27242: PPUSH
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PPUSH
27255: EMPTY
27256: PPUSH
27257: CALL 54067 0 3
27261: ST_TO_ADDR
27262: GO 27296
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27264: LD_ADDR_EXP 53
27268: PUSH
27269: LD_EXP 53
27273: PPUSH
27274: LD_VAR 0 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PPUSH
27286: LD_VAR 0 7
27290: PPUSH
27291: CALL 54067 0 3
27295: ST_TO_ADDR
// if need_heal_2 then
27296: LD_VAR 0 7
27300: IFFALSE 27461
// for j in need_heal_2 do
27302: LD_ADDR_VAR 0 3
27306: PUSH
27307: LD_VAR 0 7
27311: PUSH
27312: FOR_IN
27313: IFFALSE 27459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27315: LD_ADDR_VAR 0 5
27319: PUSH
27320: LD_EXP 50
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PPUSH
27331: LD_INT 2
27333: PUSH
27334: LD_INT 30
27336: PUSH
27337: LD_INT 6
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 30
27346: PUSH
27347: LD_INT 7
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 30
27356: PUSH
27357: LD_INT 8
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 30
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 30
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: PPUSH
27392: CALL_OW 72
27396: ST_TO_ADDR
// if tmp then
27397: LD_VAR 0 5
27401: IFFALSE 27457
// begin k := NearestUnitToUnit ( tmp , j ) ;
27403: LD_ADDR_VAR 0 4
27407: PUSH
27408: LD_VAR 0 5
27412: PPUSH
27413: LD_VAR 0 3
27417: PPUSH
27418: CALL_OW 74
27422: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27423: LD_VAR 0 3
27427: PPUSH
27428: LD_VAR 0 4
27432: PPUSH
27433: CALL_OW 296
27437: PUSH
27438: LD_INT 5
27440: GREATER
27441: IFFALSE 27457
// ComMoveToNearbyEntrance ( j , k ) ;
27443: LD_VAR 0 3
27447: PPUSH
27448: LD_VAR 0 4
27452: PPUSH
27453: CALL 87303 0 2
// end ; end ;
27457: GO 27312
27459: POP
27460: POP
// if not need_heal_1 and not need_heal_2 then
27461: LD_VAR 0 6
27465: NOT
27466: PUSH
27467: LD_VAR 0 7
27471: NOT
27472: AND
27473: IFFALSE 27477
// continue ;
27475: GO 26941
// end ;
27477: GO 26941
27479: POP
27480: POP
// RaiseSailEvent ( 102 ) ;
27481: LD_INT 102
27483: PPUSH
27484: CALL_OW 427
// end ;
27488: LD_VAR 0 1
27492: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27493: LD_INT 0
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
// if not mc_bases then
27503: LD_EXP 50
27507: NOT
27508: IFFALSE 27512
// exit ;
27510: GO 28423
// for i = 1 to mc_bases do
27512: LD_ADDR_VAR 0 2
27516: PUSH
27517: DOUBLE
27518: LD_INT 1
27520: DEC
27521: ST_TO_ADDR
27522: LD_EXP 50
27526: PUSH
27527: FOR_TO
27528: IFFALSE 28421
// begin if not mc_building_need_repair [ i ] then
27530: LD_EXP 51
27534: PUSH
27535: LD_VAR 0 2
27539: ARRAY
27540: NOT
27541: IFFALSE 27726
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27543: LD_ADDR_VAR 0 6
27547: PUSH
27548: LD_EXP 69
27552: PUSH
27553: LD_VAR 0 2
27557: ARRAY
27558: PPUSH
27559: LD_INT 3
27561: PUSH
27562: LD_INT 24
27564: PUSH
27565: LD_INT 1000
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: PUSH
27579: LD_INT 34
27581: PUSH
27582: LD_INT 13
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 34
27591: PUSH
27592: LD_INT 52
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 34
27601: PUSH
27602: LD_INT 88
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PPUSH
27619: CALL_OW 72
27623: ST_TO_ADDR
// if cranes then
27624: LD_VAR 0 6
27628: IFFALSE 27690
// for j in cranes do
27630: LD_ADDR_VAR 0 3
27634: PUSH
27635: LD_VAR 0 6
27639: PUSH
27640: FOR_IN
27641: IFFALSE 27688
// if not IsInArea ( j , mc_parking [ i ] ) then
27643: LD_VAR 0 3
27647: PPUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 308
27663: NOT
27664: IFFALSE 27686
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27666: LD_VAR 0 3
27670: PPUSH
27671: LD_EXP 74
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: PPUSH
27682: CALL_OW 113
27686: GO 27640
27688: POP
27689: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27690: LD_ADDR_EXP 52
27694: PUSH
27695: LD_EXP 52
27699: PPUSH
27700: LD_VAR 0 2
27704: PPUSH
27705: EMPTY
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 101
27719: PPUSH
27720: CALL 22566 0 2
// continue ;
27724: GO 27527
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27726: LD_ADDR_EXP 56
27730: PUSH
27731: LD_EXP 56
27735: PPUSH
27736: LD_VAR 0 2
27740: PPUSH
27741: EMPTY
27742: PPUSH
27743: CALL_OW 1
27747: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27748: LD_VAR 0 2
27752: PPUSH
27753: LD_INT 103
27755: PPUSH
27756: CALL 22566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27760: LD_ADDR_VAR 0 5
27764: PUSH
27765: LD_EXP 50
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: PUSH
27776: LD_EXP 79
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: UNION
27787: PPUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 2
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 25
27803: PUSH
27804: LD_INT 16
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PUSH
27816: EMPTY
27817: LIST
27818: PPUSH
27819: CALL_OW 72
27823: ST_TO_ADDR
// if mc_need_heal [ i ] then
27824: LD_EXP 53
27828: PUSH
27829: LD_VAR 0 2
27833: ARRAY
27834: IFFALSE 27878
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27836: LD_ADDR_VAR 0 5
27840: PUSH
27841: LD_VAR 0 5
27845: PUSH
27846: LD_EXP 53
27850: PUSH
27851: LD_VAR 0 2
27855: ARRAY
27856: PUSH
27857: LD_INT 1
27859: ARRAY
27860: PUSH
27861: LD_EXP 53
27865: PUSH
27866: LD_VAR 0 2
27870: ARRAY
27871: PUSH
27872: LD_INT 2
27874: ARRAY
27875: UNION
27876: DIFF
27877: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27878: LD_ADDR_VAR 0 6
27882: PUSH
27883: LD_EXP 69
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PPUSH
27894: LD_INT 2
27896: PUSH
27897: LD_INT 34
27899: PUSH
27900: LD_INT 13
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 34
27909: PUSH
27910: LD_INT 52
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 34
27919: PUSH
27920: LD_INT 88
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: PPUSH
27933: CALL_OW 72
27937: ST_TO_ADDR
// if cranes then
27938: LD_VAR 0 6
27942: IFFALSE 28110
// begin for j in cranes do
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: LD_VAR 0 6
27953: PUSH
27954: FOR_IN
27955: IFFALSE 28108
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27957: LD_VAR 0 3
27961: PPUSH
27962: CALL_OW 256
27966: PUSH
27967: LD_INT 1000
27969: EQUAL
27970: PUSH
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 314
27980: NOT
27981: AND
27982: IFFALSE 28048
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27984: LD_ADDR_VAR 0 8
27988: PUSH
27989: LD_EXP 51
27993: PUSH
27994: LD_VAR 0 2
27998: ARRAY
27999: PPUSH
28000: LD_VAR 0 3
28004: PPUSH
28005: CALL_OW 74
28009: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28010: LD_VAR 0 8
28014: PPUSH
28015: LD_INT 16
28017: PPUSH
28018: CALL 56664 0 2
28022: PUSH
28023: LD_INT 4
28025: ARRAY
28026: PUSH
28027: LD_INT 10
28029: LESS
28030: IFFALSE 28046
// ComRepairBuilding ( j , to_repair ) ;
28032: LD_VAR 0 3
28036: PPUSH
28037: LD_VAR 0 8
28041: PPUSH
28042: CALL_OW 130
// end else
28046: GO 28106
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28048: LD_VAR 0 3
28052: PPUSH
28053: CALL_OW 256
28057: PUSH
28058: LD_INT 500
28060: LESS
28061: PUSH
28062: LD_VAR 0 3
28066: PPUSH
28067: LD_EXP 74
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PPUSH
28078: CALL_OW 308
28082: NOT
28083: AND
28084: IFFALSE 28106
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28086: LD_VAR 0 3
28090: PPUSH
28091: LD_EXP 74
28095: PUSH
28096: LD_VAR 0 2
28100: ARRAY
28101: PPUSH
28102: CALL_OW 113
// end ;
28106: GO 27954
28108: POP
28109: POP
// end ; if tmp > 3 then
28110: LD_VAR 0 5
28114: PUSH
28115: LD_INT 3
28117: GREATER
28118: IFFALSE 28138
// tmp := ShrinkArray ( tmp , 4 ) ;
28120: LD_ADDR_VAR 0 5
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: LD_INT 4
28132: PPUSH
28133: CALL 86741 0 2
28137: ST_TO_ADDR
// if not tmp then
28138: LD_VAR 0 5
28142: NOT
28143: IFFALSE 28147
// continue ;
28145: GO 27527
// for j in tmp do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: LD_VAR 0 5
28156: PUSH
28157: FOR_IN
28158: IFFALSE 28417
// begin if IsInUnit ( j ) then
28160: LD_VAR 0 3
28164: PPUSH
28165: CALL_OW 310
28169: IFFALSE 28180
// ComExitBuilding ( j ) ;
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28180: LD_VAR 0 3
28184: PUSH
28185: LD_EXP 52
28189: PUSH
28190: LD_VAR 0 2
28194: ARRAY
28195: IN
28196: NOT
28197: IFFALSE 28255
// begin SetTag ( j , 101 ) ;
28199: LD_VAR 0 3
28203: PPUSH
28204: LD_INT 101
28206: PPUSH
28207: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28211: LD_ADDR_EXP 52
28215: PUSH
28216: LD_EXP 52
28220: PPUSH
28221: LD_VAR 0 2
28225: PUSH
28226: LD_EXP 52
28230: PUSH
28231: LD_VAR 0 2
28235: ARRAY
28236: PUSH
28237: LD_INT 1
28239: PLUS
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PPUSH
28245: LD_VAR 0 3
28249: PPUSH
28250: CALL 54067 0 3
28254: ST_TO_ADDR
// end ; wait ( 1 ) ;
28255: LD_INT 1
28257: PPUSH
28258: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28262: LD_ADDR_VAR 0 7
28266: PUSH
28267: LD_EXP 51
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: ST_TO_ADDR
// if mc_scan [ i ] then
28278: LD_EXP 73
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: IFFALSE 28350
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28290: LD_ADDR_VAR 0 7
28294: PUSH
28295: LD_EXP 51
28299: PUSH
28300: LD_VAR 0 2
28304: ARRAY
28305: PPUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 30
28311: PUSH
28312: LD_INT 32
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 30
28321: PUSH
28322: LD_INT 33
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 30
28331: PUSH
28332: LD_INT 31
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: PPUSH
28345: CALL_OW 72
28349: ST_TO_ADDR
// if not to_repair_tmp then
28350: LD_VAR 0 7
28354: NOT
28355: IFFALSE 28359
// continue ;
28357: GO 28157
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28359: LD_ADDR_VAR 0 8
28363: PUSH
28364: LD_VAR 0 7
28368: PPUSH
28369: LD_VAR 0 3
28373: PPUSH
28374: CALL_OW 74
28378: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28379: LD_VAR 0 8
28383: PPUSH
28384: LD_INT 16
28386: PPUSH
28387: CALL 56664 0 2
28391: PUSH
28392: LD_INT 4
28394: ARRAY
28395: PUSH
28396: LD_INT 14
28398: LESS
28399: IFFALSE 28415
// ComRepairBuilding ( j , to_repair ) ;
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_VAR 0 8
28410: PPUSH
28411: CALL_OW 130
// end ;
28415: GO 28157
28417: POP
28418: POP
// end ;
28419: GO 27527
28421: POP
28422: POP
// end ;
28423: LD_VAR 0 1
28427: RET
// export function MC_Heal ; var i , j , tmp ; begin
28428: LD_INT 0
28430: PPUSH
28431: PPUSH
28432: PPUSH
28433: PPUSH
// if not mc_bases then
28434: LD_EXP 50
28438: NOT
28439: IFFALSE 28443
// exit ;
28441: GO 28845
// for i = 1 to mc_bases do
28443: LD_ADDR_VAR 0 2
28447: PUSH
28448: DOUBLE
28449: LD_INT 1
28451: DEC
28452: ST_TO_ADDR
28453: LD_EXP 50
28457: PUSH
28458: FOR_TO
28459: IFFALSE 28843
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28461: LD_EXP 53
28465: PUSH
28466: LD_VAR 0 2
28470: ARRAY
28471: PUSH
28472: LD_INT 1
28474: ARRAY
28475: NOT
28476: PUSH
28477: LD_EXP 53
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: PUSH
28488: LD_INT 2
28490: ARRAY
28491: NOT
28492: AND
28493: IFFALSE 28531
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28495: LD_ADDR_EXP 54
28499: PUSH
28500: LD_EXP 54
28504: PPUSH
28505: LD_VAR 0 2
28509: PPUSH
28510: EMPTY
28511: PPUSH
28512: CALL_OW 1
28516: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28517: LD_VAR 0 2
28521: PPUSH
28522: LD_INT 102
28524: PPUSH
28525: CALL 22566 0 2
// continue ;
28529: GO 28458
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28531: LD_ADDR_VAR 0 4
28535: PUSH
28536: LD_EXP 50
28540: PUSH
28541: LD_VAR 0 2
28545: ARRAY
28546: PPUSH
28547: LD_INT 25
28549: PUSH
28550: LD_INT 4
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: ST_TO_ADDR
// if not tmp then
28562: LD_VAR 0 4
28566: NOT
28567: IFFALSE 28571
// continue ;
28569: GO 28458
// if mc_taming [ i ] then
28571: LD_EXP 81
28575: PUSH
28576: LD_VAR 0 2
28580: ARRAY
28581: IFFALSE 28605
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28583: LD_ADDR_EXP 81
28587: PUSH
28588: LD_EXP 81
28592: PPUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: EMPTY
28599: PPUSH
28600: CALL_OW 1
28604: ST_TO_ADDR
// for j in tmp do
28605: LD_ADDR_VAR 0 3
28609: PUSH
28610: LD_VAR 0 4
28614: PUSH
28615: FOR_IN
28616: IFFALSE 28839
// begin if IsInUnit ( j ) then
28618: LD_VAR 0 3
28622: PPUSH
28623: CALL_OW 310
28627: IFFALSE 28638
// ComExitBuilding ( j ) ;
28629: LD_VAR 0 3
28633: PPUSH
28634: CALL_OW 122
// if not j in mc_healers [ i ] then
28638: LD_VAR 0 3
28642: PUSH
28643: LD_EXP 54
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: IN
28654: NOT
28655: IFFALSE 28701
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28657: LD_ADDR_EXP 54
28661: PUSH
28662: LD_EXP 54
28666: PPUSH
28667: LD_VAR 0 2
28671: PUSH
28672: LD_EXP 54
28676: PUSH
28677: LD_VAR 0 2
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: PLUS
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL 54067 0 3
28700: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28701: LD_VAR 0 3
28705: PPUSH
28706: CALL_OW 110
28710: PUSH
28711: LD_INT 102
28713: NONEQUAL
28714: IFFALSE 28728
// SetTag ( j , 102 ) ;
28716: LD_VAR 0 3
28720: PPUSH
28721: LD_INT 102
28723: PPUSH
28724: CALL_OW 109
// Wait ( 3 ) ;
28728: LD_INT 3
28730: PPUSH
28731: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28735: LD_EXP 53
28739: PUSH
28740: LD_VAR 0 2
28744: ARRAY
28745: PUSH
28746: LD_INT 1
28748: ARRAY
28749: IFFALSE 28781
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28751: LD_VAR 0 3
28755: PPUSH
28756: LD_EXP 53
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: CALL_OW 128
28779: GO 28837
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 314
28790: NOT
28791: PUSH
28792: LD_EXP 53
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 2
28805: ARRAY
28806: AND
28807: IFFALSE 28837
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28809: LD_VAR 0 3
28813: PPUSH
28814: LD_EXP 53
28818: PUSH
28819: LD_VAR 0 2
28823: ARRAY
28824: PUSH
28825: LD_INT 2
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PPUSH
28833: CALL_OW 128
// end ;
28837: GO 28615
28839: POP
28840: POP
// end ;
28841: GO 28458
28843: POP
28844: POP
// end ;
28845: LD_VAR 0 1
28849: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28850: LD_INT 0
28852: PPUSH
28853: PPUSH
28854: PPUSH
28855: PPUSH
28856: PPUSH
28857: PPUSH
// if not mc_bases then
28858: LD_EXP 50
28862: NOT
28863: IFFALSE 28867
// exit ;
28865: GO 30030
// for i = 1 to mc_bases do
28867: LD_ADDR_VAR 0 2
28871: PUSH
28872: DOUBLE
28873: LD_INT 1
28875: DEC
28876: ST_TO_ADDR
28877: LD_EXP 50
28881: PUSH
28882: FOR_TO
28883: IFFALSE 30028
// begin if mc_scan [ i ] then
28885: LD_EXP 73
28889: PUSH
28890: LD_VAR 0 2
28894: ARRAY
28895: IFFALSE 28899
// continue ;
28897: GO 28882
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28899: LD_EXP 55
28903: PUSH
28904: LD_VAR 0 2
28908: ARRAY
28909: NOT
28910: PUSH
28911: LD_EXP 57
28915: PUSH
28916: LD_VAR 0 2
28920: ARRAY
28921: NOT
28922: AND
28923: PUSH
28924: LD_EXP 56
28928: PUSH
28929: LD_VAR 0 2
28933: ARRAY
28934: AND
28935: IFFALSE 28973
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28937: LD_ADDR_EXP 56
28941: PUSH
28942: LD_EXP 56
28946: PPUSH
28947: LD_VAR 0 2
28951: PPUSH
28952: EMPTY
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28959: LD_VAR 0 2
28963: PPUSH
28964: LD_INT 103
28966: PPUSH
28967: CALL 22566 0 2
// continue ;
28971: GO 28882
// end ; if mc_construct_list [ i ] then
28973: LD_EXP 57
28977: PUSH
28978: LD_VAR 0 2
28982: ARRAY
28983: IFFALSE 29203
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28985: LD_ADDR_VAR 0 5
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_VAR 0 2
28999: ARRAY
29000: PPUSH
29001: LD_INT 25
29003: PUSH
29004: LD_INT 2
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PPUSH
29011: CALL_OW 72
29015: PUSH
29016: LD_EXP 52
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: DIFF
29027: ST_TO_ADDR
// if not tmp then
29028: LD_VAR 0 5
29032: NOT
29033: IFFALSE 29037
// continue ;
29035: GO 28882
// for j in tmp do
29037: LD_ADDR_VAR 0 3
29041: PUSH
29042: LD_VAR 0 5
29046: PUSH
29047: FOR_IN
29048: IFFALSE 29199
// begin if not mc_builders [ i ] then
29050: LD_EXP 56
29054: PUSH
29055: LD_VAR 0 2
29059: ARRAY
29060: NOT
29061: IFFALSE 29119
// begin SetTag ( j , 103 ) ;
29063: LD_VAR 0 3
29067: PPUSH
29068: LD_INT 103
29070: PPUSH
29071: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29075: LD_ADDR_EXP 56
29079: PUSH
29080: LD_EXP 56
29084: PPUSH
29085: LD_VAR 0 2
29089: PUSH
29090: LD_EXP 56
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: PUSH
29101: LD_INT 1
29103: PLUS
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: LD_VAR 0 3
29113: PPUSH
29114: CALL 54067 0 3
29118: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL_OW 310
29128: IFFALSE 29139
// ComExitBuilding ( j ) ;
29130: LD_VAR 0 3
29134: PPUSH
29135: CALL_OW 122
// wait ( 3 ) ;
29139: LD_INT 3
29141: PPUSH
29142: CALL_OW 67
// if not mc_construct_list [ i ] then
29146: LD_EXP 57
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: NOT
29157: IFFALSE 29161
// break ;
29159: GO 29199
// if not HasTask ( j ) then
29161: LD_VAR 0 3
29165: PPUSH
29166: CALL_OW 314
29170: NOT
29171: IFFALSE 29197
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29173: LD_VAR 0 3
29177: PPUSH
29178: LD_EXP 57
29182: PUSH
29183: LD_VAR 0 2
29187: ARRAY
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL 56937 0 2
// end ;
29197: GO 29047
29199: POP
29200: POP
// end else
29201: GO 30026
// if mc_build_list [ i ] then
29203: LD_EXP 55
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: IFFALSE 30026
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29215: LD_EXP 55
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PUSH
29226: LD_INT 1
29228: ARRAY
29229: PUSH
29230: LD_INT 1
29232: ARRAY
29233: PPUSH
29234: CALL 56761 0 1
29238: PUSH
29239: LD_EXP 50
29243: PUSH
29244: LD_VAR 0 2
29248: ARRAY
29249: PPUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 30
29255: PUSH
29256: LD_INT 2
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 30
29265: PUSH
29266: LD_INT 3
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: LIST
29277: PPUSH
29278: CALL_OW 72
29282: NOT
29283: AND
29284: IFFALSE 29389
// begin for j = 1 to mc_build_list [ i ] do
29286: LD_ADDR_VAR 0 3
29290: PUSH
29291: DOUBLE
29292: LD_INT 1
29294: DEC
29295: ST_TO_ADDR
29296: LD_EXP 55
29300: PUSH
29301: LD_VAR 0 2
29305: ARRAY
29306: PUSH
29307: FOR_TO
29308: IFFALSE 29387
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29310: LD_EXP 55
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: LD_VAR 0 3
29325: ARRAY
29326: PUSH
29327: LD_INT 1
29329: ARRAY
29330: PUSH
29331: LD_INT 2
29333: EQUAL
29334: IFFALSE 29385
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29336: LD_ADDR_EXP 55
29340: PUSH
29341: LD_EXP 55
29345: PPUSH
29346: LD_VAR 0 2
29350: PPUSH
29351: LD_EXP 55
29355: PUSH
29356: LD_VAR 0 2
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 1
29369: PPUSH
29370: LD_INT 0
29372: PPUSH
29373: CALL 53485 0 4
29377: PPUSH
29378: CALL_OW 1
29382: ST_TO_ADDR
// break ;
29383: GO 29387
// end ;
29385: GO 29307
29387: POP
29388: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29389: LD_ADDR_VAR 0 6
29393: PUSH
29394: LD_EXP 50
29398: PUSH
29399: LD_VAR 0 2
29403: ARRAY
29404: PPUSH
29405: LD_INT 2
29407: PUSH
29408: LD_INT 30
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 30
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PPUSH
29433: CALL_OW 72
29437: ST_TO_ADDR
// for k := 1 to depot do
29438: LD_ADDR_VAR 0 4
29442: PUSH
29443: DOUBLE
29444: LD_INT 1
29446: DEC
29447: ST_TO_ADDR
29448: LD_VAR 0 6
29452: PUSH
29453: FOR_TO
29454: IFFALSE 30024
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29456: LD_EXP 55
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PUSH
29467: LD_INT 1
29469: ARRAY
29470: PUSH
29471: LD_INT 1
29473: ARRAY
29474: PUSH
29475: LD_INT 0
29477: EQUAL
29478: PUSH
29479: LD_VAR 0 6
29483: PUSH
29484: LD_VAR 0 4
29488: ARRAY
29489: PPUSH
29490: LD_EXP 55
29494: PUSH
29495: LD_VAR 0 2
29499: ARRAY
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: LD_EXP 55
29513: PUSH
29514: LD_VAR 0 2
29518: ARRAY
29519: PUSH
29520: LD_INT 1
29522: ARRAY
29523: PUSH
29524: LD_INT 2
29526: ARRAY
29527: PPUSH
29528: LD_EXP 55
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PUSH
29543: LD_INT 3
29545: ARRAY
29546: PPUSH
29547: LD_EXP 55
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: PUSH
29558: LD_INT 1
29560: ARRAY
29561: PUSH
29562: LD_INT 4
29564: ARRAY
29565: PPUSH
29566: CALL 62173 0 5
29570: OR
29571: IFFALSE 29852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29573: LD_ADDR_VAR 0 5
29577: PUSH
29578: LD_EXP 50
29582: PUSH
29583: LD_VAR 0 2
29587: ARRAY
29588: PPUSH
29589: LD_INT 25
29591: PUSH
29592: LD_INT 2
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PPUSH
29599: CALL_OW 72
29603: PUSH
29604: LD_EXP 52
29608: PUSH
29609: LD_VAR 0 2
29613: ARRAY
29614: DIFF
29615: ST_TO_ADDR
// if not tmp then
29616: LD_VAR 0 5
29620: NOT
29621: IFFALSE 29625
// continue ;
29623: GO 29453
// for j in tmp do
29625: LD_ADDR_VAR 0 3
29629: PUSH
29630: LD_VAR 0 5
29634: PUSH
29635: FOR_IN
29636: IFFALSE 29848
// begin if not mc_builders [ i ] then
29638: LD_EXP 56
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: NOT
29649: IFFALSE 29707
// begin SetTag ( j , 103 ) ;
29651: LD_VAR 0 3
29655: PPUSH
29656: LD_INT 103
29658: PPUSH
29659: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29663: LD_ADDR_EXP 56
29667: PUSH
29668: LD_EXP 56
29672: PPUSH
29673: LD_VAR 0 2
29677: PUSH
29678: LD_EXP 56
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: PUSH
29689: LD_INT 1
29691: PLUS
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: CALL 54067 0 3
29706: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29707: LD_VAR 0 3
29711: PPUSH
29712: CALL_OW 310
29716: IFFALSE 29727
// ComExitBuilding ( j ) ;
29718: LD_VAR 0 3
29722: PPUSH
29723: CALL_OW 122
// wait ( 3 ) ;
29727: LD_INT 3
29729: PPUSH
29730: CALL_OW 67
// if not mc_build_list [ i ] then
29734: LD_EXP 55
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: NOT
29745: IFFALSE 29749
// break ;
29747: GO 29848
// if not HasTask ( j ) then
29749: LD_VAR 0 3
29753: PPUSH
29754: CALL_OW 314
29758: NOT
29759: IFFALSE 29846
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29761: LD_VAR 0 3
29765: PPUSH
29766: LD_EXP 55
29770: PUSH
29771: LD_VAR 0 2
29775: ARRAY
29776: PUSH
29777: LD_INT 1
29779: ARRAY
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: PPUSH
29785: LD_EXP 55
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: PUSH
29796: LD_INT 1
29798: ARRAY
29799: PUSH
29800: LD_INT 2
29802: ARRAY
29803: PPUSH
29804: LD_EXP 55
29808: PUSH
29809: LD_VAR 0 2
29813: ARRAY
29814: PUSH
29815: LD_INT 1
29817: ARRAY
29818: PUSH
29819: LD_INT 3
29821: ARRAY
29822: PPUSH
29823: LD_EXP 55
29827: PUSH
29828: LD_VAR 0 2
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: ARRAY
29837: PUSH
29838: LD_INT 4
29840: ARRAY
29841: PPUSH
29842: CALL_OW 145
// end ;
29846: GO 29635
29848: POP
29849: POP
// end else
29850: GO 30022
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29852: LD_EXP 50
29856: PUSH
29857: LD_VAR 0 2
29861: ARRAY
29862: PPUSH
29863: LD_EXP 55
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: ARRAY
29881: PPUSH
29882: LD_EXP 55
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: PUSH
29897: LD_INT 2
29899: ARRAY
29900: PPUSH
29901: LD_EXP 55
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: ARRAY
29915: PUSH
29916: LD_INT 3
29918: ARRAY
29919: PPUSH
29920: LD_EXP 55
29924: PUSH
29925: LD_VAR 0 2
29929: ARRAY
29930: PUSH
29931: LD_INT 1
29933: ARRAY
29934: PUSH
29935: LD_INT 4
29937: ARRAY
29938: PPUSH
29939: LD_EXP 50
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PPUSH
29950: LD_INT 21
29952: PUSH
29953: LD_INT 3
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PPUSH
29960: CALL_OW 72
29964: PPUSH
29965: EMPTY
29966: PPUSH
29967: CALL 60927 0 7
29971: NOT
29972: IFFALSE 30022
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29974: LD_ADDR_EXP 55
29978: PUSH
29979: LD_EXP 55
29983: PPUSH
29984: LD_VAR 0 2
29988: PPUSH
29989: LD_EXP 55
29993: PUSH
29994: LD_VAR 0 2
29998: ARRAY
29999: PPUSH
30000: LD_INT 1
30002: PPUSH
30003: LD_INT 1
30005: NEG
30006: PPUSH
30007: LD_INT 0
30009: PPUSH
30010: CALL 53485 0 4
30014: PPUSH
30015: CALL_OW 1
30019: ST_TO_ADDR
// continue ;
30020: GO 29453
// end ; end ;
30022: GO 29453
30024: POP
30025: POP
// end ; end ;
30026: GO 28882
30028: POP
30029: POP
// end ;
30030: LD_VAR 0 1
30034: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
// if not mc_bases then
30043: LD_EXP 50
30047: NOT
30048: IFFALSE 30052
// exit ;
30050: GO 30479
// for i = 1 to mc_bases do
30052: LD_ADDR_VAR 0 2
30056: PUSH
30057: DOUBLE
30058: LD_INT 1
30060: DEC
30061: ST_TO_ADDR
30062: LD_EXP 50
30066: PUSH
30067: FOR_TO
30068: IFFALSE 30477
// begin tmp := mc_build_upgrade [ i ] ;
30070: LD_ADDR_VAR 0 4
30074: PUSH
30075: LD_EXP 82
30079: PUSH
30080: LD_VAR 0 2
30084: ARRAY
30085: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 83
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 7
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not tmp and not lab then
30135: LD_VAR 0 4
30139: NOT
30140: PUSH
30141: LD_VAR 0 6
30145: NOT
30146: AND
30147: IFFALSE 30151
// continue ;
30149: GO 30067
// if tmp then
30151: LD_VAR 0 4
30155: IFFALSE 30275
// for j in tmp do
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_VAR 0 4
30166: PUSH
30167: FOR_IN
30168: IFFALSE 30273
// begin if UpgradeCost ( j ) then
30170: LD_VAR 0 3
30174: PPUSH
30175: CALL 60587 0 1
30179: IFFALSE 30271
// begin ComUpgrade ( j ) ;
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30190: LD_ADDR_EXP 82
30194: PUSH
30195: LD_EXP 82
30199: PPUSH
30200: LD_VAR 0 2
30204: PPUSH
30205: LD_EXP 82
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: PUSH
30216: LD_VAR 0 3
30220: DIFF
30221: PPUSH
30222: CALL_OW 1
30226: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30227: LD_ADDR_EXP 57
30231: PUSH
30232: LD_EXP 57
30236: PPUSH
30237: LD_VAR 0 2
30241: PUSH
30242: LD_EXP 57
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PUSH
30253: LD_INT 1
30255: PLUS
30256: PUSH
30257: EMPTY
30258: LIST
30259: LIST
30260: PPUSH
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL 54067 0 3
30270: ST_TO_ADDR
// end ; end ;
30271: GO 30167
30273: POP
30274: POP
// if not lab or not mc_lab_upgrade [ i ] then
30275: LD_VAR 0 6
30279: NOT
30280: PUSH
30281: LD_EXP 84
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: NOT
30292: OR
30293: IFFALSE 30297
// continue ;
30295: GO 30067
// for j in lab do
30297: LD_ADDR_VAR 0 3
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: FOR_IN
30308: IFFALSE 30473
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30310: LD_VAR 0 3
30314: PPUSH
30315: CALL_OW 266
30319: PUSH
30320: LD_INT 6
30322: PUSH
30323: LD_INT 7
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: IN
30330: PUSH
30331: LD_VAR 0 3
30335: PPUSH
30336: CALL_OW 461
30340: PUSH
30341: LD_INT 1
30343: NONEQUAL
30344: AND
30345: IFFALSE 30471
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30347: LD_VAR 0 3
30351: PPUSH
30352: LD_EXP 84
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PPUSH
30367: CALL 60792 0 2
30371: IFFALSE 30471
// begin ComCancel ( j ) ;
30373: LD_VAR 0 3
30377: PPUSH
30378: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30382: LD_VAR 0 3
30386: PPUSH
30387: LD_EXP 84
30391: PUSH
30392: LD_VAR 0 2
30396: ARRAY
30397: PUSH
30398: LD_INT 1
30400: ARRAY
30401: PPUSH
30402: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30406: LD_VAR 0 3
30410: PUSH
30411: LD_EXP 57
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: IN
30422: NOT
30423: IFFALSE 30469
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30425: LD_ADDR_EXP 57
30429: PUSH
30430: LD_EXP 57
30434: PPUSH
30435: LD_VAR 0 2
30439: PUSH
30440: LD_EXP 57
30444: PUSH
30445: LD_VAR 0 2
30449: ARRAY
30450: PUSH
30451: LD_INT 1
30453: PLUS
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: LD_VAR 0 3
30463: PPUSH
30464: CALL 54067 0 3
30468: ST_TO_ADDR
// break ;
30469: GO 30473
// end ; end ; end ;
30471: GO 30307
30473: POP
30474: POP
// end ;
30475: GO 30067
30477: POP
30478: POP
// end ;
30479: LD_VAR 0 1
30483: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30484: LD_INT 0
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 50
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 30909
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 50
30518: PUSH
30519: FOR_TO
30520: IFFALSE 30907
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30522: LD_EXP 58
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: PUSH
30534: LD_EXP 50
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PPUSH
30545: LD_INT 30
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PPUSH
30555: CALL_OW 72
30559: NOT
30560: OR
30561: IFFALSE 30565
// continue ;
30563: GO 30519
// busy := false ;
30565: LD_ADDR_VAR 0 8
30569: PUSH
30570: LD_INT 0
30572: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30573: LD_ADDR_VAR 0 4
30577: PUSH
30578: LD_EXP 50
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: PPUSH
30589: LD_INT 30
30591: PUSH
30592: LD_INT 3
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PPUSH
30599: CALL_OW 72
30603: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30604: LD_ADDR_VAR 0 6
30608: PUSH
30609: LD_EXP 58
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PPUSH
30620: LD_INT 2
30622: PUSH
30623: LD_INT 30
30625: PUSH
30626: LD_INT 32
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 30
30635: PUSH
30636: LD_INT 33
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: PPUSH
30648: CALL_OW 72
30652: ST_TO_ADDR
// if not t then
30653: LD_VAR 0 6
30657: NOT
30658: IFFALSE 30662
// continue ;
30660: GO 30519
// for j in tmp do
30662: LD_ADDR_VAR 0 3
30666: PUSH
30667: LD_VAR 0 4
30671: PUSH
30672: FOR_IN
30673: IFFALSE 30703
// if not BuildingStatus ( j ) = bs_idle then
30675: LD_VAR 0 3
30679: PPUSH
30680: CALL_OW 461
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: NOT
30689: IFFALSE 30701
// begin busy := true ;
30691: LD_ADDR_VAR 0 8
30695: PUSH
30696: LD_INT 1
30698: ST_TO_ADDR
// break ;
30699: GO 30703
// end ;
30701: GO 30672
30703: POP
30704: POP
// if busy then
30705: LD_VAR 0 8
30709: IFFALSE 30713
// continue ;
30711: GO 30519
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30713: LD_ADDR_VAR 0 7
30717: PUSH
30718: LD_VAR 0 6
30722: PPUSH
30723: LD_INT 35
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: ST_TO_ADDR
// if tw then
30738: LD_VAR 0 7
30742: IFFALSE 30819
// begin tw := tw [ 1 ] ;
30744: LD_ADDR_VAR 0 7
30748: PUSH
30749: LD_VAR 0 7
30753: PUSH
30754: LD_INT 1
30756: ARRAY
30757: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30758: LD_ADDR_VAR 0 9
30762: PUSH
30763: LD_VAR 0 7
30767: PPUSH
30768: LD_EXP 75
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: PPUSH
30779: CALL 59084 0 2
30783: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30784: LD_EXP 89
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: IFFALSE 30817
// if not weapon in mc_allowed_tower_weapons [ i ] then
30796: LD_VAR 0 9
30800: PUSH
30801: LD_EXP 89
30805: PUSH
30806: LD_VAR 0 2
30810: ARRAY
30811: IN
30812: NOT
30813: IFFALSE 30817
// continue ;
30815: GO 30519
// end else
30817: GO 30882
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30819: LD_ADDR_VAR 0 5
30823: PUSH
30824: LD_EXP 58
30828: PUSH
30829: LD_VAR 0 2
30833: ARRAY
30834: PPUSH
30835: LD_VAR 0 4
30839: PPUSH
30840: CALL 85974 0 2
30844: ST_TO_ADDR
// if not tmp2 then
30845: LD_VAR 0 5
30849: NOT
30850: IFFALSE 30854
// continue ;
30852: GO 30519
// tw := tmp2 [ 1 ] ;
30854: LD_ADDR_VAR 0 7
30858: PUSH
30859: LD_VAR 0 5
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30868: LD_ADDR_VAR 0 9
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 2
30880: ARRAY
30881: ST_TO_ADDR
// end ; if not weapon then
30882: LD_VAR 0 9
30886: NOT
30887: IFFALSE 30891
// continue ;
30889: GO 30519
// ComPlaceWeapon ( tw , weapon ) ;
30891: LD_VAR 0 7
30895: PPUSH
30896: LD_VAR 0 9
30900: PPUSH
30901: CALL_OW 148
// end ;
30905: GO 30519
30907: POP
30908: POP
// end ;
30909: LD_VAR 0 1
30913: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30914: LD_INT 0
30916: PPUSH
30917: PPUSH
30918: PPUSH
30919: PPUSH
30920: PPUSH
30921: PPUSH
30922: PPUSH
// if not mc_bases then
30923: LD_EXP 50
30927: NOT
30928: IFFALSE 30932
// exit ;
30930: GO 31707
// for i = 1 to mc_bases do
30932: LD_ADDR_VAR 0 2
30936: PUSH
30937: DOUBLE
30938: LD_INT 1
30940: DEC
30941: ST_TO_ADDR
30942: LD_EXP 50
30946: PUSH
30947: FOR_TO
30948: IFFALSE 31705
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30950: LD_EXP 63
30954: PUSH
30955: LD_VAR 0 2
30959: ARRAY
30960: NOT
30961: PUSH
30962: LD_EXP 63
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_EXP 64
30977: PUSH
30978: LD_VAR 0 2
30982: ARRAY
30983: EQUAL
30984: OR
30985: PUSH
30986: LD_EXP 73
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: OR
30997: IFFALSE 31001
// continue ;
30999: GO 30947
// if mc_miners [ i ] then
31001: LD_EXP 64
31005: PUSH
31006: LD_VAR 0 2
31010: ARRAY
31011: IFFALSE 31392
// begin for j = mc_miners [ i ] downto 1 do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: DOUBLE
31019: LD_EXP 64
31023: PUSH
31024: LD_VAR 0 2
31028: ARRAY
31029: INC
31030: ST_TO_ADDR
31031: LD_INT 1
31033: PUSH
31034: FOR_DOWNTO
31035: IFFALSE 31390
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31037: LD_EXP 64
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PUSH
31048: LD_VAR 0 3
31052: ARRAY
31053: PPUSH
31054: CALL_OW 301
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_VAR 0 3
31074: ARRAY
31075: PPUSH
31076: CALL_OW 257
31080: PUSH
31081: LD_INT 1
31083: NONEQUAL
31084: OR
31085: IFFALSE 31148
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31087: LD_ADDR_VAR 0 5
31091: PUSH
31092: LD_EXP 64
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: PUSH
31103: LD_EXP 64
31107: PUSH
31108: LD_VAR 0 2
31112: ARRAY
31113: PUSH
31114: LD_VAR 0 3
31118: ARRAY
31119: DIFF
31120: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31121: LD_ADDR_EXP 64
31125: PUSH
31126: LD_EXP 64
31130: PPUSH
31131: LD_VAR 0 2
31135: PPUSH
31136: LD_VAR 0 5
31140: PPUSH
31141: CALL_OW 1
31145: ST_TO_ADDR
// continue ;
31146: GO 31034
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31148: LD_EXP 64
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_VAR 0 3
31163: ARRAY
31164: PPUSH
31165: CALL_OW 257
31169: PUSH
31170: LD_INT 1
31172: EQUAL
31173: PUSH
31174: LD_EXP 64
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: PUSH
31185: LD_VAR 0 3
31189: ARRAY
31190: PPUSH
31191: CALL_OW 459
31195: NOT
31196: AND
31197: PUSH
31198: LD_EXP 64
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PUSH
31209: LD_VAR 0 3
31213: ARRAY
31214: PPUSH
31215: CALL_OW 314
31219: NOT
31220: AND
31221: IFFALSE 31388
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31223: LD_EXP 64
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PPUSH
31240: CALL_OW 310
31244: IFFALSE 31267
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31246: LD_EXP 64
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: PUSH
31257: LD_VAR 0 3
31261: ARRAY
31262: PPUSH
31263: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31267: LD_EXP 64
31271: PUSH
31272: LD_VAR 0 2
31276: ARRAY
31277: PUSH
31278: LD_VAR 0 3
31282: ARRAY
31283: PPUSH
31284: CALL_OW 314
31288: NOT
31289: IFFALSE 31388
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31291: LD_ADDR_VAR 0 7
31295: PUSH
31296: LD_VAR 0 3
31300: PUSH
31301: LD_EXP 63
31305: PUSH
31306: LD_VAR 0 2
31310: ARRAY
31311: PPUSH
31312: CALL 51207 0 1
31316: MOD
31317: PUSH
31318: LD_INT 1
31320: PLUS
31321: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31322: LD_EXP 64
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_VAR 0 3
31337: ARRAY
31338: PPUSH
31339: LD_EXP 63
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PUSH
31350: LD_VAR 0 7
31354: ARRAY
31355: PUSH
31356: LD_INT 1
31358: ARRAY
31359: PPUSH
31360: LD_EXP 63
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_VAR 0 7
31375: ARRAY
31376: PUSH
31377: LD_INT 2
31379: ARRAY
31380: PPUSH
31381: LD_INT 0
31383: PPUSH
31384: CALL_OW 193
// end ; end ; end ;
31388: GO 31034
31390: POP
31391: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31392: LD_ADDR_VAR 0 5
31396: PUSH
31397: LD_EXP 50
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 30
31413: PUSH
31414: LD_INT 4
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 30
31423: PUSH
31424: LD_INT 5
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 30
31433: PUSH
31434: LD_INT 32
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: PPUSH
31447: CALL_OW 72
31451: ST_TO_ADDR
// if not tmp then
31452: LD_VAR 0 5
31456: NOT
31457: IFFALSE 31461
// continue ;
31459: GO 30947
// list := [ ] ;
31461: LD_ADDR_VAR 0 6
31465: PUSH
31466: EMPTY
31467: ST_TO_ADDR
// for j in tmp do
31468: LD_ADDR_VAR 0 3
31472: PUSH
31473: LD_VAR 0 5
31477: PUSH
31478: FOR_IN
31479: IFFALSE 31548
// begin for k in UnitsInside ( j ) do
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: LD_VAR 0 3
31490: PPUSH
31491: CALL_OW 313
31495: PUSH
31496: FOR_IN
31497: IFFALSE 31544
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31499: LD_VAR 0 4
31503: PPUSH
31504: CALL_OW 257
31508: PUSH
31509: LD_INT 1
31511: EQUAL
31512: PUSH
31513: LD_VAR 0 4
31517: PPUSH
31518: CALL_OW 459
31522: NOT
31523: AND
31524: IFFALSE 31542
// list := list ^ k ;
31526: LD_ADDR_VAR 0 6
31530: PUSH
31531: LD_VAR 0 6
31535: PUSH
31536: LD_VAR 0 4
31540: ADD
31541: ST_TO_ADDR
31542: GO 31496
31544: POP
31545: POP
// end ;
31546: GO 31478
31548: POP
31549: POP
// list := list diff mc_miners [ i ] ;
31550: LD_ADDR_VAR 0 6
31554: PUSH
31555: LD_VAR 0 6
31559: PUSH
31560: LD_EXP 64
31564: PUSH
31565: LD_VAR 0 2
31569: ARRAY
31570: DIFF
31571: ST_TO_ADDR
// if not list then
31572: LD_VAR 0 6
31576: NOT
31577: IFFALSE 31581
// continue ;
31579: GO 30947
// k := mc_mines [ i ] - mc_miners [ i ] ;
31581: LD_ADDR_VAR 0 4
31585: PUSH
31586: LD_EXP 63
31590: PUSH
31591: LD_VAR 0 2
31595: ARRAY
31596: PUSH
31597: LD_EXP 64
31601: PUSH
31602: LD_VAR 0 2
31606: ARRAY
31607: MINUS
31608: ST_TO_ADDR
// if k > list then
31609: LD_VAR 0 4
31613: PUSH
31614: LD_VAR 0 6
31618: GREATER
31619: IFFALSE 31631
// k := list ;
31621: LD_ADDR_VAR 0 4
31625: PUSH
31626: LD_VAR 0 6
31630: ST_TO_ADDR
// for j = 1 to k do
31631: LD_ADDR_VAR 0 3
31635: PUSH
31636: DOUBLE
31637: LD_INT 1
31639: DEC
31640: ST_TO_ADDR
31641: LD_VAR 0 4
31645: PUSH
31646: FOR_TO
31647: IFFALSE 31701
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31649: LD_ADDR_EXP 64
31653: PUSH
31654: LD_EXP 64
31658: PPUSH
31659: LD_VAR 0 2
31663: PUSH
31664: LD_EXP 64
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_INT 1
31677: PLUS
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PPUSH
31683: LD_VAR 0 6
31687: PUSH
31688: LD_VAR 0 3
31692: ARRAY
31693: PPUSH
31694: CALL 54067 0 3
31698: ST_TO_ADDR
31699: GO 31646
31701: POP
31702: POP
// end ;
31703: GO 30947
31705: POP
31706: POP
// end ;
31707: LD_VAR 0 1
31711: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31712: LD_INT 0
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
// if not mc_bases then
31725: LD_EXP 50
31729: NOT
31730: IFFALSE 31734
// exit ;
31732: GO 33557
// for i = 1 to mc_bases do
31734: LD_ADDR_VAR 0 2
31738: PUSH
31739: DOUBLE
31740: LD_INT 1
31742: DEC
31743: ST_TO_ADDR
31744: LD_EXP 50
31748: PUSH
31749: FOR_TO
31750: IFFALSE 33555
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31752: LD_EXP 50
31756: PUSH
31757: LD_VAR 0 2
31761: ARRAY
31762: NOT
31763: PUSH
31764: LD_EXP 57
31768: PUSH
31769: LD_VAR 0 2
31773: ARRAY
31774: OR
31775: IFFALSE 31779
// continue ;
31777: GO 31749
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31779: LD_EXP 66
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: PUSH
31791: LD_EXP 67
31795: PUSH
31796: LD_VAR 0 2
31800: ARRAY
31801: AND
31802: IFFALSE 31840
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31804: LD_ADDR_EXP 67
31808: PUSH
31809: LD_EXP 67
31813: PPUSH
31814: LD_VAR 0 2
31818: PPUSH
31819: EMPTY
31820: PPUSH
31821: CALL_OW 1
31825: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31826: LD_VAR 0 2
31830: PPUSH
31831: LD_INT 107
31833: PPUSH
31834: CALL 22566 0 2
// continue ;
31838: GO 31749
// end ; target := [ ] ;
31840: LD_ADDR_VAR 0 7
31844: PUSH
31845: EMPTY
31846: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31847: LD_ADDR_VAR 0 6
31851: PUSH
31852: LD_EXP 50
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: PUSH
31863: LD_INT 1
31865: ARRAY
31866: PPUSH
31867: CALL_OW 255
31871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31872: LD_ADDR_VAR 0 9
31876: PUSH
31877: LD_EXP 50
31881: PUSH
31882: LD_VAR 0 2
31886: ARRAY
31887: PPUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 30
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: DOUBLE
31927: LD_EXP 66
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: INC
31938: ST_TO_ADDR
31939: LD_INT 1
31941: PUSH
31942: FOR_DOWNTO
31943: IFFALSE 32188
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31945: LD_EXP 66
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PUSH
31956: LD_VAR 0 3
31960: ARRAY
31961: PUSH
31962: LD_INT 2
31964: ARRAY
31965: PPUSH
31966: LD_EXP 66
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PUSH
31977: LD_VAR 0 3
31981: ARRAY
31982: PUSH
31983: LD_INT 3
31985: ARRAY
31986: PPUSH
31987: CALL_OW 488
31991: PUSH
31992: LD_EXP 66
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: PUSH
32003: LD_VAR 0 3
32007: ARRAY
32008: PUSH
32009: LD_INT 2
32011: ARRAY
32012: PPUSH
32013: LD_EXP 66
32017: PUSH
32018: LD_VAR 0 2
32022: ARRAY
32023: PUSH
32024: LD_VAR 0 3
32028: ARRAY
32029: PUSH
32030: LD_INT 3
32032: ARRAY
32033: PPUSH
32034: CALL_OW 284
32038: PUSH
32039: LD_INT 0
32041: EQUAL
32042: AND
32043: IFFALSE 32098
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32045: LD_ADDR_VAR 0 5
32049: PUSH
32050: LD_EXP 66
32054: PUSH
32055: LD_VAR 0 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 3
32065: PPUSH
32066: CALL_OW 3
32070: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32071: LD_ADDR_EXP 66
32075: PUSH
32076: LD_EXP 66
32080: PPUSH
32081: LD_VAR 0 2
32085: PPUSH
32086: LD_VAR 0 5
32090: PPUSH
32091: CALL_OW 1
32095: ST_TO_ADDR
// continue ;
32096: GO 31942
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32098: LD_VAR 0 6
32102: PPUSH
32103: LD_EXP 66
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PUSH
32114: LD_VAR 0 3
32118: ARRAY
32119: PUSH
32120: LD_INT 2
32122: ARRAY
32123: PPUSH
32124: LD_EXP 66
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_VAR 0 3
32139: ARRAY
32140: PUSH
32141: LD_INT 3
32143: ARRAY
32144: PPUSH
32145: LD_INT 30
32147: PPUSH
32148: CALL 54963 0 4
32152: PUSH
32153: LD_INT 4
32155: ARRAY
32156: PUSH
32157: LD_INT 0
32159: EQUAL
32160: IFFALSE 32186
// begin target := mc_crates [ i ] [ j ] ;
32162: LD_ADDR_VAR 0 7
32166: PUSH
32167: LD_EXP 66
32171: PUSH
32172: LD_VAR 0 2
32176: ARRAY
32177: PUSH
32178: LD_VAR 0 3
32182: ARRAY
32183: ST_TO_ADDR
// break ;
32184: GO 32188
// end ; end ;
32186: GO 31942
32188: POP
32189: POP
// if not target then
32190: LD_VAR 0 7
32194: NOT
32195: IFFALSE 32199
// continue ;
32197: GO 31749
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32199: LD_ADDR_VAR 0 8
32203: PUSH
32204: LD_EXP 69
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PPUSH
32215: LD_INT 2
32217: PUSH
32218: LD_INT 3
32220: PUSH
32221: LD_INT 58
32223: PUSH
32224: EMPTY
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 61
32233: PUSH
32234: EMPTY
32235: LIST
32236: PUSH
32237: LD_INT 33
32239: PUSH
32240: LD_INT 5
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 33
32249: PUSH
32250: LD_INT 3
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 34
32269: PUSH
32270: LD_INT 32
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 34
32279: PUSH
32280: LD_INT 51
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 34
32289: PUSH
32290: LD_INT 12
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PPUSH
32307: CALL_OW 72
32311: ST_TO_ADDR
// if not cargo then
32312: LD_VAR 0 8
32316: NOT
32317: IFFALSE 33023
// begin if mc_crates_collector [ i ] < 5 then
32319: LD_EXP 67
32323: PUSH
32324: LD_VAR 0 2
32328: ARRAY
32329: PUSH
32330: LD_INT 5
32332: LESS
32333: IFFALSE 32699
// begin if mc_ape [ i ] then
32335: LD_EXP 79
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: IFFALSE 32392
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_EXP 79
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 25
32365: PUSH
32366: LD_INT 16
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 24
32375: PUSH
32376: LD_INT 750
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not tmp then
32392: LD_VAR 0 5
32396: NOT
32397: IFFALSE 32444
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32399: LD_ADDR_VAR 0 5
32403: PUSH
32404: LD_EXP 50
32408: PUSH
32409: LD_VAR 0 2
32413: ARRAY
32414: PPUSH
32415: LD_INT 25
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 24
32427: PUSH
32428: LD_INT 750
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PPUSH
32439: CALL_OW 72
32443: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32444: LD_EXP 79
32448: PUSH
32449: LD_VAR 0 2
32453: ARRAY
32454: PUSH
32455: LD_EXP 50
32459: PUSH
32460: LD_VAR 0 2
32464: ARRAY
32465: PPUSH
32466: LD_INT 25
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 24
32478: PUSH
32479: LD_INT 750
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PPUSH
32490: CALL_OW 72
32494: AND
32495: PUSH
32496: LD_VAR 0 5
32500: PUSH
32501: LD_INT 5
32503: LESS
32504: AND
32505: IFFALSE 32587
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32507: LD_ADDR_VAR 0 3
32511: PUSH
32512: LD_EXP 50
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PPUSH
32523: LD_INT 25
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 24
32535: PUSH
32536: LD_INT 750
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PPUSH
32547: CALL_OW 72
32551: PUSH
32552: FOR_IN
32553: IFFALSE 32585
// begin tmp := tmp union j ;
32555: LD_ADDR_VAR 0 5
32559: PUSH
32560: LD_VAR 0 5
32564: PUSH
32565: LD_VAR 0 3
32569: UNION
32570: ST_TO_ADDR
// if tmp >= 5 then
32571: LD_VAR 0 5
32575: PUSH
32576: LD_INT 5
32578: GREATEREQUAL
32579: IFFALSE 32583
// break ;
32581: GO 32585
// end ;
32583: GO 32552
32585: POP
32586: POP
// end ; if not tmp then
32587: LD_VAR 0 5
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 31749
// for j in tmp do
32596: LD_ADDR_VAR 0 3
32600: PUSH
32601: LD_VAR 0 5
32605: PUSH
32606: FOR_IN
32607: IFFALSE 32697
// if not GetTag ( j ) then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 110
32618: NOT
32619: IFFALSE 32695
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32621: LD_ADDR_EXP 67
32625: PUSH
32626: LD_EXP 67
32630: PPUSH
32631: LD_VAR 0 2
32635: PUSH
32636: LD_EXP 67
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: PLUS
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PPUSH
32655: LD_VAR 0 3
32659: PPUSH
32660: CALL 54067 0 3
32664: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32665: LD_VAR 0 3
32669: PPUSH
32670: LD_INT 107
32672: PPUSH
32673: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32677: LD_EXP 67
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: PUSH
32688: LD_INT 5
32690: GREATEREQUAL
32691: IFFALSE 32695
// break ;
32693: GO 32697
// end ;
32695: GO 32606
32697: POP
32698: POP
// end ; if mc_crates_collector [ i ] and target then
32699: LD_EXP 67
32703: PUSH
32704: LD_VAR 0 2
32708: ARRAY
32709: PUSH
32710: LD_VAR 0 7
32714: AND
32715: IFFALSE 33021
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32717: LD_EXP 67
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_VAR 0 7
32732: PUSH
32733: LD_INT 1
32735: ARRAY
32736: LESS
32737: IFFALSE 32757
// tmp := mc_crates_collector [ i ] else
32739: LD_ADDR_VAR 0 5
32743: PUSH
32744: LD_EXP 67
32748: PUSH
32749: LD_VAR 0 2
32753: ARRAY
32754: ST_TO_ADDR
32755: GO 32771
// tmp := target [ 1 ] ;
32757: LD_ADDR_VAR 0 5
32761: PUSH
32762: LD_VAR 0 7
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: ST_TO_ADDR
// k := 0 ;
32771: LD_ADDR_VAR 0 4
32775: PUSH
32776: LD_INT 0
32778: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32779: LD_ADDR_VAR 0 3
32783: PUSH
32784: LD_EXP 67
32788: PUSH
32789: LD_VAR 0 2
32793: ARRAY
32794: PUSH
32795: FOR_IN
32796: IFFALSE 33019
// begin k := k + 1 ;
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: LD_VAR 0 4
32807: PUSH
32808: LD_INT 1
32810: PLUS
32811: ST_TO_ADDR
// if k > tmp then
32812: LD_VAR 0 4
32816: PUSH
32817: LD_VAR 0 5
32821: GREATER
32822: IFFALSE 32826
// break ;
32824: GO 33019
// if not GetClass ( j ) in [ 2 , 16 ] then
32826: LD_VAR 0 3
32830: PPUSH
32831: CALL_OW 257
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: LD_INT 16
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: IN
32846: NOT
32847: IFFALSE 32900
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32849: LD_ADDR_EXP 67
32853: PUSH
32854: LD_EXP 67
32858: PPUSH
32859: LD_VAR 0 2
32863: PPUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: LD_VAR 0 3
32879: DIFF
32880: PPUSH
32881: CALL_OW 1
32885: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32886: LD_VAR 0 3
32890: PPUSH
32891: LD_INT 0
32893: PPUSH
32894: CALL_OW 109
// continue ;
32898: GO 32795
// end ; if IsInUnit ( j ) then
32900: LD_VAR 0 3
32904: PPUSH
32905: CALL_OW 310
32909: IFFALSE 32920
// ComExitBuilding ( j ) ;
32911: LD_VAR 0 3
32915: PPUSH
32916: CALL_OW 122
// wait ( 3 ) ;
32920: LD_INT 3
32922: PPUSH
32923: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32927: LD_VAR 0 3
32931: PPUSH
32932: CALL_OW 314
32936: PUSH
32937: LD_VAR 0 6
32941: PPUSH
32942: LD_VAR 0 7
32946: PUSH
32947: LD_INT 2
32949: ARRAY
32950: PPUSH
32951: LD_VAR 0 7
32955: PUSH
32956: LD_INT 3
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PPUSH
32963: CALL 54963 0 4
32967: PUSH
32968: LD_INT 4
32970: ARRAY
32971: AND
32972: IFFALSE 32990
// ComStandNearbyBuilding ( j , depot ) else
32974: LD_VAR 0 3
32978: PPUSH
32979: LD_VAR 0 9
32983: PPUSH
32984: CALL 50669 0 2
32988: GO 33017
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32990: LD_VAR 0 3
32994: PPUSH
32995: LD_VAR 0 7
32999: PUSH
33000: LD_INT 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 7
33008: PUSH
33009: LD_INT 3
33011: ARRAY
33012: PPUSH
33013: CALL_OW 117
// end ;
33017: GO 32795
33019: POP
33020: POP
// end ; end else
33021: GO 33553
// begin for j in cargo do
33023: LD_ADDR_VAR 0 3
33027: PUSH
33028: LD_VAR 0 8
33032: PUSH
33033: FOR_IN
33034: IFFALSE 33551
// begin if GetTag ( j ) <> 0 then
33036: LD_VAR 0 3
33040: PPUSH
33041: CALL_OW 110
33045: PUSH
33046: LD_INT 0
33048: NONEQUAL
33049: IFFALSE 33053
// continue ;
33051: GO 33033
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33053: LD_VAR 0 3
33057: PPUSH
33058: CALL_OW 256
33062: PUSH
33063: LD_INT 1000
33065: LESS
33066: PUSH
33067: LD_VAR 0 3
33071: PPUSH
33072: LD_EXP 74
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PPUSH
33083: CALL_OW 308
33087: NOT
33088: AND
33089: IFFALSE 33111
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33091: LD_VAR 0 3
33095: PPUSH
33096: LD_EXP 74
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PPUSH
33107: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33111: LD_VAR 0 3
33115: PPUSH
33116: CALL_OW 256
33120: PUSH
33121: LD_INT 1000
33123: LESS
33124: PUSH
33125: LD_VAR 0 3
33129: PPUSH
33130: LD_EXP 74
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PPUSH
33141: CALL_OW 308
33145: AND
33146: IFFALSE 33150
// continue ;
33148: GO 33033
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33150: LD_VAR 0 3
33154: PPUSH
33155: CALL_OW 262
33159: PUSH
33160: LD_INT 2
33162: EQUAL
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 261
33173: PUSH
33174: LD_INT 15
33176: LESS
33177: AND
33178: IFFALSE 33182
// continue ;
33180: GO 33033
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33182: LD_VAR 0 3
33186: PPUSH
33187: CALL_OW 262
33191: PUSH
33192: LD_INT 1
33194: EQUAL
33195: PUSH
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 261
33205: PUSH
33206: LD_INT 10
33208: LESS
33209: AND
33210: IFFALSE 33490
// begin if not depot then
33212: LD_VAR 0 9
33216: NOT
33217: IFFALSE 33221
// continue ;
33219: GO 33033
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33221: LD_VAR 0 3
33225: PPUSH
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: CALL_OW 74
33240: PPUSH
33241: CALL_OW 296
33245: PUSH
33246: LD_INT 6
33248: LESS
33249: IFFALSE 33265
// SetFuel ( j , 100 ) else
33251: LD_VAR 0 3
33255: PPUSH
33256: LD_INT 100
33258: PPUSH
33259: CALL_OW 240
33263: GO 33490
// if GetFuel ( j ) = 0 then
33265: LD_VAR 0 3
33269: PPUSH
33270: CALL_OW 261
33274: PUSH
33275: LD_INT 0
33277: EQUAL
33278: IFFALSE 33490
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33280: LD_ADDR_EXP 69
33284: PUSH
33285: LD_EXP 69
33289: PPUSH
33290: LD_VAR 0 2
33294: PPUSH
33295: LD_EXP 69
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_VAR 0 3
33310: DIFF
33311: PPUSH
33312: CALL_OW 1
33316: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33317: LD_VAR 0 3
33321: PPUSH
33322: CALL_OW 263
33326: PUSH
33327: LD_INT 1
33329: EQUAL
33330: IFFALSE 33346
// ComExitVehicle ( IsInUnit ( j ) ) ;
33332: LD_VAR 0 3
33336: PPUSH
33337: CALL_OW 310
33341: PPUSH
33342: CALL_OW 121
// if GetControl ( j ) = control_remote then
33346: LD_VAR 0 3
33350: PPUSH
33351: CALL_OW 263
33355: PUSH
33356: LD_INT 2
33358: EQUAL
33359: IFFALSE 33370
// ComUnlink ( j ) ;
33361: LD_VAR 0 3
33365: PPUSH
33366: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33370: LD_ADDR_VAR 0 10
33374: PUSH
33375: LD_VAR 0 2
33379: PPUSH
33380: LD_INT 3
33382: PPUSH
33383: CALL 43134 0 2
33387: ST_TO_ADDR
// if fac then
33388: LD_VAR 0 10
33392: IFFALSE 33488
// begin for k in fac do
33394: LD_ADDR_VAR 0 4
33398: PUSH
33399: LD_VAR 0 10
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33486
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33407: LD_ADDR_VAR 0 11
33411: PUSH
33412: LD_VAR 0 10
33416: PPUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL_OW 265
33426: PPUSH
33427: LD_VAR 0 3
33431: PPUSH
33432: CALL_OW 262
33436: PPUSH
33437: LD_VAR 0 3
33441: PPUSH
33442: CALL_OW 263
33446: PPUSH
33447: LD_VAR 0 3
33451: PPUSH
33452: CALL_OW 264
33456: PPUSH
33457: CALL 51565 0 5
33461: ST_TO_ADDR
// if components then
33462: LD_VAR 0 11
33466: IFFALSE 33484
// begin MC_InsertProduceList ( i , components ) ;
33468: LD_VAR 0 2
33472: PPUSH
33473: LD_VAR 0 11
33477: PPUSH
33478: CALL 42679 0 2
// break ;
33482: GO 33486
// end ; end ;
33484: GO 33404
33486: POP
33487: POP
// end ; continue ;
33488: GO 33033
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33490: LD_VAR 0 3
33494: PPUSH
33495: LD_INT 1
33497: PPUSH
33498: CALL_OW 289
33502: PUSH
33503: LD_INT 100
33505: LESS
33506: PUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33547
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33520: LD_VAR 0 3
33524: PPUSH
33525: LD_VAR 0 7
33529: PUSH
33530: LD_INT 2
33532: ARRAY
33533: PPUSH
33534: LD_VAR 0 7
33538: PUSH
33539: LD_INT 3
33541: ARRAY
33542: PPUSH
33543: CALL_OW 117
// break ;
33547: GO 33551
// end ;
33549: GO 33033
33551: POP
33552: POP
// end ; end ;
33553: GO 31749
33555: POP
33556: POP
// end ;
33557: LD_VAR 0 1
33561: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33562: LD_INT 0
33564: PPUSH
33565: PPUSH
33566: PPUSH
33567: PPUSH
// if not mc_bases then
33568: LD_EXP 50
33572: NOT
33573: IFFALSE 33577
// exit ;
33575: GO 33738
// for i = 1 to mc_bases do
33577: LD_ADDR_VAR 0 2
33581: PUSH
33582: DOUBLE
33583: LD_INT 1
33585: DEC
33586: ST_TO_ADDR
33587: LD_EXP 50
33591: PUSH
33592: FOR_TO
33593: IFFALSE 33736
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33595: LD_ADDR_VAR 0 4
33599: PUSH
33600: LD_EXP 69
33604: PUSH
33605: LD_VAR 0 2
33609: ARRAY
33610: PUSH
33611: LD_EXP 72
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: UNION
33622: PPUSH
33623: LD_INT 33
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PPUSH
33633: CALL_OW 72
33637: ST_TO_ADDR
// if tmp then
33638: LD_VAR 0 4
33642: IFFALSE 33734
// for j in tmp do
33644: LD_ADDR_VAR 0 3
33648: PUSH
33649: LD_VAR 0 4
33653: PUSH
33654: FOR_IN
33655: IFFALSE 33732
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33657: LD_VAR 0 3
33661: PPUSH
33662: CALL_OW 312
33666: NOT
33667: PUSH
33668: LD_VAR 0 3
33672: PPUSH
33673: CALL_OW 256
33677: PUSH
33678: LD_INT 250
33680: GREATEREQUAL
33681: AND
33682: IFFALSE 33695
// Connect ( j ) else
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL 57045 0 1
33693: GO 33730
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33695: LD_VAR 0 3
33699: PPUSH
33700: CALL_OW 256
33704: PUSH
33705: LD_INT 250
33707: LESS
33708: PUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: CALL_OW 312
33718: AND
33719: IFFALSE 33730
// ComUnlink ( j ) ;
33721: LD_VAR 0 3
33725: PPUSH
33726: CALL_OW 136
33730: GO 33654
33732: POP
33733: POP
// end ;
33734: GO 33592
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 1
33742: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
33749: PPUSH
// if not mc_bases then
33750: LD_EXP 50
33754: NOT
33755: IFFALSE 33759
// exit ;
33757: GO 34204
// for i = 1 to mc_bases do
33759: LD_ADDR_VAR 0 2
33763: PUSH
33764: DOUBLE
33765: LD_INT 1
33767: DEC
33768: ST_TO_ADDR
33769: LD_EXP 50
33773: PUSH
33774: FOR_TO
33775: IFFALSE 34202
// begin if not mc_produce [ i ] then
33777: LD_EXP 71
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: NOT
33788: IFFALSE 33792
// continue ;
33790: GO 33774
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33792: LD_ADDR_VAR 0 5
33796: PUSH
33797: LD_EXP 50
33801: PUSH
33802: LD_VAR 0 2
33806: ARRAY
33807: PPUSH
33808: LD_INT 30
33810: PUSH
33811: LD_INT 3
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 72
33822: ST_TO_ADDR
// if not fac then
33823: LD_VAR 0 5
33827: NOT
33828: IFFALSE 33832
// continue ;
33830: GO 33774
// for j in fac do
33832: LD_ADDR_VAR 0 3
33836: PUSH
33837: LD_VAR 0 5
33841: PUSH
33842: FOR_IN
33843: IFFALSE 34198
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33845: LD_VAR 0 3
33849: PPUSH
33850: CALL_OW 461
33854: PUSH
33855: LD_INT 2
33857: NONEQUAL
33858: PUSH
33859: LD_VAR 0 3
33863: PPUSH
33864: LD_INT 15
33866: PPUSH
33867: CALL 56664 0 2
33871: PUSH
33872: LD_INT 4
33874: ARRAY
33875: OR
33876: IFFALSE 33880
// continue ;
33878: GO 33842
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33880: LD_VAR 0 3
33884: PPUSH
33885: LD_EXP 71
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PUSH
33896: LD_INT 1
33898: ARRAY
33899: PUSH
33900: LD_INT 1
33902: ARRAY
33903: PPUSH
33904: LD_EXP 71
33908: PUSH
33909: LD_VAR 0 2
33913: ARRAY
33914: PUSH
33915: LD_INT 1
33917: ARRAY
33918: PUSH
33919: LD_INT 2
33921: ARRAY
33922: PPUSH
33923: LD_EXP 71
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PUSH
33938: LD_INT 3
33940: ARRAY
33941: PPUSH
33942: LD_EXP 71
33946: PUSH
33947: LD_VAR 0 2
33951: ARRAY
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_INT 4
33959: ARRAY
33960: PPUSH
33961: CALL_OW 448
33965: PUSH
33966: LD_VAR 0 3
33970: PPUSH
33971: LD_EXP 71
33975: PUSH
33976: LD_VAR 0 2
33980: ARRAY
33981: PUSH
33982: LD_INT 1
33984: ARRAY
33985: PUSH
33986: LD_INT 1
33988: ARRAY
33989: PUSH
33990: LD_EXP 71
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_INT 1
34003: ARRAY
34004: PUSH
34005: LD_INT 2
34007: ARRAY
34008: PUSH
34009: LD_EXP 71
34013: PUSH
34014: LD_VAR 0 2
34018: ARRAY
34019: PUSH
34020: LD_INT 1
34022: ARRAY
34023: PUSH
34024: LD_INT 3
34026: ARRAY
34027: PUSH
34028: LD_EXP 71
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: ARRAY
34042: PUSH
34043: LD_INT 4
34045: ARRAY
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: PPUSH
34053: CALL 60440 0 2
34057: AND
34058: IFFALSE 34196
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34060: LD_VAR 0 3
34064: PPUSH
34065: LD_EXP 71
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PUSH
34076: LD_INT 1
34078: ARRAY
34079: PUSH
34080: LD_INT 1
34082: ARRAY
34083: PPUSH
34084: LD_EXP 71
34088: PUSH
34089: LD_VAR 0 2
34093: ARRAY
34094: PUSH
34095: LD_INT 1
34097: ARRAY
34098: PUSH
34099: LD_INT 2
34101: ARRAY
34102: PPUSH
34103: LD_EXP 71
34107: PUSH
34108: LD_VAR 0 2
34112: ARRAY
34113: PUSH
34114: LD_INT 1
34116: ARRAY
34117: PUSH
34118: LD_INT 3
34120: ARRAY
34121: PPUSH
34122: LD_EXP 71
34126: PUSH
34127: LD_VAR 0 2
34131: ARRAY
34132: PUSH
34133: LD_INT 1
34135: ARRAY
34136: PUSH
34137: LD_INT 4
34139: ARRAY
34140: PPUSH
34141: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34145: LD_ADDR_VAR 0 4
34149: PUSH
34150: LD_EXP 71
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 1
34163: PPUSH
34164: CALL_OW 3
34168: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34169: LD_ADDR_EXP 71
34173: PUSH
34174: LD_EXP 71
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: LD_VAR 0 4
34188: PPUSH
34189: CALL_OW 1
34193: ST_TO_ADDR
// break ;
34194: GO 34198
// end ; end ;
34196: GO 33842
34198: POP
34199: POP
// end ;
34200: GO 33774
34202: POP
34203: POP
// end ;
34204: LD_VAR 0 1
34208: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34209: LD_INT 0
34211: PPUSH
34212: PPUSH
34213: PPUSH
// if not mc_bases then
34214: LD_EXP 50
34218: NOT
34219: IFFALSE 34223
// exit ;
34221: GO 34312
// for i = 1 to mc_bases do
34223: LD_ADDR_VAR 0 2
34227: PUSH
34228: DOUBLE
34229: LD_INT 1
34231: DEC
34232: ST_TO_ADDR
34233: LD_EXP 50
34237: PUSH
34238: FOR_TO
34239: IFFALSE 34310
// begin if mc_attack [ i ] then
34241: LD_EXP 70
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: IFFALSE 34308
// begin tmp := mc_attack [ i ] [ 1 ] ;
34253: LD_ADDR_VAR 0 3
34257: PUSH
34258: LD_EXP 70
34262: PUSH
34263: LD_VAR 0 2
34267: ARRAY
34268: PUSH
34269: LD_INT 1
34271: ARRAY
34272: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34273: LD_ADDR_EXP 70
34277: PUSH
34278: LD_EXP 70
34282: PPUSH
34283: LD_VAR 0 2
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// Attack ( tmp ) ;
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 110732 0 1
// exit ;
34304: POP
34305: POP
34306: GO 34312
// end ; end ;
34308: GO 34238
34310: POP
34311: POP
// end ;
34312: LD_VAR 0 1
34316: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34317: LD_INT 0
34319: PPUSH
34320: PPUSH
34321: PPUSH
34322: PPUSH
34323: PPUSH
34324: PPUSH
34325: PPUSH
// if not mc_bases then
34326: LD_EXP 50
34330: NOT
34331: IFFALSE 34335
// exit ;
34333: GO 35192
// for i = 1 to mc_bases do
34335: LD_ADDR_VAR 0 2
34339: PUSH
34340: DOUBLE
34341: LD_INT 1
34343: DEC
34344: ST_TO_ADDR
34345: LD_EXP 50
34349: PUSH
34350: FOR_TO
34351: IFFALSE 35190
// begin if not mc_bases [ i ] then
34353: LD_EXP 50
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: NOT
34364: IFFALSE 34368
// continue ;
34366: GO 34350
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34368: LD_ADDR_VAR 0 7
34372: PUSH
34373: LD_EXP 50
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PPUSH
34388: CALL 50891 0 1
34392: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34393: LD_ADDR_EXP 73
34397: PUSH
34398: LD_EXP 73
34402: PPUSH
34403: LD_VAR 0 2
34407: PPUSH
34408: LD_EXP 50
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PUSH
34419: LD_INT 1
34421: ARRAY
34422: PPUSH
34423: CALL_OW 255
34427: PPUSH
34428: LD_EXP 75
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PPUSH
34439: CALL 50856 0 2
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// if not mc_scan [ i ] then
34449: LD_EXP 73
34453: PUSH
34454: LD_VAR 0 2
34458: ARRAY
34459: NOT
34460: IFFALSE 34638
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34462: LD_ADDR_EXP 93
34466: PUSH
34467: LD_EXP 93
34471: PPUSH
34472: LD_VAR 0 2
34476: PPUSH
34477: LD_INT 0
34479: PPUSH
34480: CALL_OW 1
34484: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34485: LD_ADDR_VAR 0 4
34489: PUSH
34490: LD_EXP 50
34494: PUSH
34495: LD_VAR 0 2
34499: ARRAY
34500: PPUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 25
34506: PUSH
34507: LD_INT 5
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 25
34516: PUSH
34517: LD_INT 8
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 9
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: PPUSH
34540: CALL_OW 72
34544: ST_TO_ADDR
// if not tmp then
34545: LD_VAR 0 4
34549: NOT
34550: IFFALSE 34554
// continue ;
34552: GO 34350
// for j in tmp do
34554: LD_ADDR_VAR 0 3
34558: PUSH
34559: LD_VAR 0 4
34563: PUSH
34564: FOR_IN
34565: IFFALSE 34636
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34567: LD_VAR 0 3
34571: PPUSH
34572: CALL_OW 310
34576: PPUSH
34577: CALL_OW 266
34581: PUSH
34582: LD_INT 5
34584: EQUAL
34585: PUSH
34586: LD_VAR 0 3
34590: PPUSH
34591: CALL_OW 257
34595: PUSH
34596: LD_INT 1
34598: EQUAL
34599: AND
34600: PUSH
34601: LD_VAR 0 3
34605: PPUSH
34606: CALL_OW 459
34610: NOT
34611: AND
34612: PUSH
34613: LD_VAR 0 7
34617: AND
34618: IFFALSE 34634
// ComChangeProfession ( j , class ) ;
34620: LD_VAR 0 3
34624: PPUSH
34625: LD_VAR 0 7
34629: PPUSH
34630: CALL_OW 123
34634: GO 34564
34636: POP
34637: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34638: LD_EXP 73
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_EXP 93
34653: PUSH
34654: LD_VAR 0 2
34658: ARRAY
34659: NOT
34660: AND
34661: PUSH
34662: LD_EXP 72
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: NOT
34673: AND
34674: PUSH
34675: LD_EXP 50
34679: PUSH
34680: LD_VAR 0 2
34684: ARRAY
34685: PPUSH
34686: LD_INT 50
34688: PUSH
34689: EMPTY
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: LD_INT 30
34697: PUSH
34698: LD_INT 32
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 33
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 4
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 30
34727: PUSH
34728: LD_INT 5
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PPUSH
34746: CALL_OW 72
34750: PUSH
34751: LD_INT 4
34753: LESS
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 3
34768: PUSH
34769: LD_INT 24
34771: PUSH
34772: LD_INT 1000
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 2
34785: PUSH
34786: LD_INT 30
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 30
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PPUSH
34815: CALL_OW 72
34819: OR
34820: AND
34821: IFFALSE 35072
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34823: LD_ADDR_EXP 93
34827: PUSH
34828: LD_EXP 93
34832: PPUSH
34833: LD_VAR 0 2
34837: PPUSH
34838: LD_INT 1
34840: PPUSH
34841: CALL_OW 1
34845: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34846: LD_ADDR_VAR 0 4
34850: PUSH
34851: LD_EXP 50
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 25
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 25
34877: PUSH
34878: LD_INT 5
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 25
34887: PUSH
34888: LD_INT 8
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 25
34897: PUSH
34898: LD_INT 9
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: PPUSH
34912: CALL_OW 72
34916: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 4
34926: PUSH
34927: LD_VAR 0 4
34931: PPUSH
34932: LD_INT 18
34934: PPUSH
34935: CALL 84008 0 2
34939: DIFF
34940: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34941: LD_VAR 0 4
34945: NOT
34946: PUSH
34947: LD_EXP 50
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PPUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 30
34963: PUSH
34964: LD_INT 4
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 30
34973: PUSH
34974: LD_INT 5
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: LIST
34985: PPUSH
34986: CALL_OW 72
34990: NOT
34991: AND
34992: IFFALSE 35054
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34994: LD_ADDR_VAR 0 4
34998: PUSH
34999: LD_EXP 50
35003: PUSH
35004: LD_VAR 0 2
35008: ARRAY
35009: PPUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 25
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 25
35025: PUSH
35026: LD_INT 3
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 25
35035: PUSH
35036: LD_INT 4
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: PPUSH
35049: CALL_OW 72
35053: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35054: LD_VAR 0 2
35058: PPUSH
35059: LD_VAR 0 4
35063: PPUSH
35064: CALL 115441 0 2
// exit ;
35068: POP
35069: POP
35070: GO 35192
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35072: LD_EXP 73
35076: PUSH
35077: LD_VAR 0 2
35081: ARRAY
35082: PUSH
35083: LD_EXP 93
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: NOT
35094: AND
35095: PUSH
35096: LD_EXP 72
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: AND
35107: IFFALSE 35188
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35109: LD_ADDR_EXP 93
35113: PUSH
35114: LD_EXP 93
35118: PPUSH
35119: LD_VAR 0 2
35123: PPUSH
35124: LD_INT 1
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35132: LD_ADDR_VAR 0 4
35136: PUSH
35137: LD_EXP 72
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35148: LD_ADDR_EXP 72
35152: PUSH
35153: LD_EXP 72
35157: PPUSH
35158: LD_VAR 0 2
35162: PPUSH
35163: EMPTY
35164: PPUSH
35165: CALL_OW 1
35169: ST_TO_ADDR
// Defend ( i , tmp ) ;
35170: LD_VAR 0 2
35174: PPUSH
35175: LD_VAR 0 4
35179: PPUSH
35180: CALL 116037 0 2
// exit ;
35184: POP
35185: POP
35186: GO 35192
// end ; end ;
35188: GO 34350
35190: POP
35191: POP
// end ;
35192: LD_VAR 0 1
35196: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35197: LD_INT 0
35199: PPUSH
35200: PPUSH
35201: PPUSH
35202: PPUSH
35203: PPUSH
35204: PPUSH
35205: PPUSH
35206: PPUSH
35207: PPUSH
35208: PPUSH
35209: PPUSH
// if not mc_bases then
35210: LD_EXP 50
35214: NOT
35215: IFFALSE 35219
// exit ;
35217: GO 36306
// for i = 1 to mc_bases do
35219: LD_ADDR_VAR 0 2
35223: PUSH
35224: DOUBLE
35225: LD_INT 1
35227: DEC
35228: ST_TO_ADDR
35229: LD_EXP 50
35233: PUSH
35234: FOR_TO
35235: IFFALSE 36304
// begin tmp := mc_lab [ i ] ;
35237: LD_ADDR_VAR 0 6
35241: PUSH
35242: LD_EXP 83
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: ST_TO_ADDR
// if not tmp then
35253: LD_VAR 0 6
35257: NOT
35258: IFFALSE 35262
// continue ;
35260: GO 35234
// idle_lab := 0 ;
35262: LD_ADDR_VAR 0 11
35266: PUSH
35267: LD_INT 0
35269: ST_TO_ADDR
// for j in tmp do
35270: LD_ADDR_VAR 0 3
35274: PUSH
35275: LD_VAR 0 6
35279: PUSH
35280: FOR_IN
35281: IFFALSE 36300
// begin researching := false ;
35283: LD_ADDR_VAR 0 10
35287: PUSH
35288: LD_INT 0
35290: ST_TO_ADDR
// side := GetSide ( j ) ;
35291: LD_ADDR_VAR 0 4
35295: PUSH
35296: LD_VAR 0 3
35300: PPUSH
35301: CALL_OW 255
35305: ST_TO_ADDR
// if not mc_tech [ side ] then
35306: LD_EXP 77
35310: PUSH
35311: LD_VAR 0 4
35315: ARRAY
35316: NOT
35317: IFFALSE 35321
// continue ;
35319: GO 35280
// if BuildingStatus ( j ) = bs_idle then
35321: LD_VAR 0 3
35325: PPUSH
35326: CALL_OW 461
35330: PUSH
35331: LD_INT 2
35333: EQUAL
35334: IFFALSE 35522
// begin if idle_lab and UnitsInside ( j ) < 6 then
35336: LD_VAR 0 11
35340: PUSH
35341: LD_VAR 0 3
35345: PPUSH
35346: CALL_OW 313
35350: PUSH
35351: LD_INT 6
35353: LESS
35354: AND
35355: IFFALSE 35426
// begin tmp2 := UnitsInside ( idle_lab ) ;
35357: LD_ADDR_VAR 0 9
35361: PUSH
35362: LD_VAR 0 11
35366: PPUSH
35367: CALL_OW 313
35371: ST_TO_ADDR
// if tmp2 then
35372: LD_VAR 0 9
35376: IFFALSE 35418
// for x in tmp2 do
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_VAR 0 9
35387: PUSH
35388: FOR_IN
35389: IFFALSE 35416
// begin ComExitBuilding ( x ) ;
35391: LD_VAR 0 7
35395: PPUSH
35396: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35400: LD_VAR 0 7
35404: PPUSH
35405: LD_VAR 0 3
35409: PPUSH
35410: CALL_OW 180
// end ;
35414: GO 35388
35416: POP
35417: POP
// idle_lab := 0 ;
35418: LD_ADDR_VAR 0 11
35422: PUSH
35423: LD_INT 0
35425: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35426: LD_ADDR_VAR 0 5
35430: PUSH
35431: LD_EXP 77
35435: PUSH
35436: LD_VAR 0 4
35440: ARRAY
35441: PUSH
35442: FOR_IN
35443: IFFALSE 35503
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35445: LD_VAR 0 3
35449: PPUSH
35450: LD_VAR 0 5
35454: PPUSH
35455: CALL_OW 430
35459: PUSH
35460: LD_VAR 0 4
35464: PPUSH
35465: LD_VAR 0 5
35469: PPUSH
35470: CALL 49961 0 2
35474: AND
35475: IFFALSE 35501
// begin researching := true ;
35477: LD_ADDR_VAR 0 10
35481: PUSH
35482: LD_INT 1
35484: ST_TO_ADDR
// ComResearch ( j , t ) ;
35485: LD_VAR 0 3
35489: PPUSH
35490: LD_VAR 0 5
35494: PPUSH
35495: CALL_OW 124
// break ;
35499: GO 35503
// end ;
35501: GO 35442
35503: POP
35504: POP
// if not researching then
35505: LD_VAR 0 10
35509: NOT
35510: IFFALSE 35522
// idle_lab := j ;
35512: LD_ADDR_VAR 0 11
35516: PUSH
35517: LD_VAR 0 3
35521: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 461
35531: PUSH
35532: LD_INT 10
35534: EQUAL
35535: IFFALSE 36123
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35537: LD_EXP 79
35541: PUSH
35542: LD_VAR 0 2
35546: ARRAY
35547: NOT
35548: PUSH
35549: LD_EXP 80
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: NOT
35560: AND
35561: PUSH
35562: LD_EXP 77
35566: PUSH
35567: LD_VAR 0 4
35571: ARRAY
35572: PUSH
35573: LD_INT 1
35575: GREATER
35576: AND
35577: IFFALSE 35708
// begin ComCancel ( j ) ;
35579: LD_VAR 0 3
35583: PPUSH
35584: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35588: LD_ADDR_EXP 77
35592: PUSH
35593: LD_EXP 77
35597: PPUSH
35598: LD_VAR 0 4
35602: PPUSH
35603: LD_EXP 77
35607: PUSH
35608: LD_VAR 0 4
35612: ARRAY
35613: PPUSH
35614: LD_EXP 77
35618: PUSH
35619: LD_VAR 0 4
35623: ARRAY
35624: PUSH
35625: LD_INT 1
35627: MINUS
35628: PPUSH
35629: LD_EXP 77
35633: PUSH
35634: LD_VAR 0 4
35638: ARRAY
35639: PPUSH
35640: LD_INT 0
35642: PPUSH
35643: CALL 53485 0 4
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35653: LD_ADDR_EXP 77
35657: PUSH
35658: LD_EXP 77
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: LD_EXP 77
35672: PUSH
35673: LD_VAR 0 4
35677: ARRAY
35678: PPUSH
35679: LD_EXP 77
35683: PUSH
35684: LD_VAR 0 4
35688: ARRAY
35689: PPUSH
35690: LD_INT 1
35692: PPUSH
35693: LD_INT 0
35695: PPUSH
35696: CALL 53485 0 4
35700: PPUSH
35701: CALL_OW 1
35705: ST_TO_ADDR
// continue ;
35706: GO 35280
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35708: LD_EXP 79
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: PUSH
35719: LD_EXP 80
35723: PUSH
35724: LD_VAR 0 2
35728: ARRAY
35729: NOT
35730: AND
35731: IFFALSE 35858
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35733: LD_ADDR_EXP 80
35737: PUSH
35738: LD_EXP 80
35742: PPUSH
35743: LD_VAR 0 2
35747: PUSH
35748: LD_EXP 80
35752: PUSH
35753: LD_VAR 0 2
35757: ARRAY
35758: PUSH
35759: LD_INT 1
35761: PLUS
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PPUSH
35767: LD_EXP 79
35771: PUSH
35772: LD_VAR 0 2
35776: ARRAY
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: CALL 54067 0 3
35786: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35787: LD_EXP 79
35791: PUSH
35792: LD_VAR 0 2
35796: ARRAY
35797: PUSH
35798: LD_INT 1
35800: ARRAY
35801: PPUSH
35802: LD_INT 112
35804: PPUSH
35805: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35809: LD_ADDR_VAR 0 9
35813: PUSH
35814: LD_EXP 79
35818: PUSH
35819: LD_VAR 0 2
35823: ARRAY
35824: PPUSH
35825: LD_INT 1
35827: PPUSH
35828: CALL_OW 3
35832: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35833: LD_ADDR_EXP 79
35837: PUSH
35838: LD_EXP 79
35842: PPUSH
35843: LD_VAR 0 2
35847: PPUSH
35848: LD_VAR 0 9
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35858: LD_EXP 79
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: AND
35880: PUSH
35881: LD_EXP 80
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PPUSH
35896: CALL_OW 310
35900: NOT
35901: AND
35902: PUSH
35903: LD_VAR 0 3
35907: PPUSH
35908: CALL_OW 313
35912: PUSH
35913: LD_INT 6
35915: EQUAL
35916: AND
35917: IFFALSE 35973
// begin tmp2 := UnitsInside ( j ) ;
35919: LD_ADDR_VAR 0 9
35923: PUSH
35924: LD_VAR 0 3
35928: PPUSH
35929: CALL_OW 313
35933: ST_TO_ADDR
// if tmp2 = 6 then
35934: LD_VAR 0 9
35938: PUSH
35939: LD_INT 6
35941: EQUAL
35942: IFFALSE 35973
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35944: LD_VAR 0 9
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PPUSH
35953: LD_INT 112
35955: PPUSH
35956: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35960: LD_VAR 0 9
35964: PUSH
35965: LD_INT 1
35967: ARRAY
35968: PPUSH
35969: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35973: LD_EXP 80
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: PUSH
35984: LD_EXP 80
35988: PUSH
35989: LD_VAR 0 2
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: CALL_OW 314
36003: NOT
36004: AND
36005: PUSH
36006: LD_EXP 80
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 1
36019: ARRAY
36020: PPUSH
36021: CALL_OW 310
36025: NOT
36026: AND
36027: IFFALSE 36053
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36029: LD_EXP 80
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: PUSH
36040: LD_INT 1
36042: ARRAY
36043: PPUSH
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PPUSH
36068: CALL_OW 310
36072: PUSH
36073: LD_EXP 80
36077: PUSH
36078: LD_VAR 0 2
36082: ARRAY
36083: PUSH
36084: LD_INT 1
36086: ARRAY
36087: PPUSH
36088: CALL_OW 310
36092: PPUSH
36093: CALL_OW 461
36097: PUSH
36098: LD_INT 3
36100: NONEQUAL
36101: AND
36102: IFFALSE 36123
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36104: LD_EXP 80
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PPUSH
36119: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36123: LD_VAR 0 3
36127: PPUSH
36128: CALL_OW 461
36132: PUSH
36133: LD_INT 6
36135: EQUAL
36136: PUSH
36137: LD_VAR 0 6
36141: PUSH
36142: LD_INT 1
36144: GREATER
36145: AND
36146: IFFALSE 36298
// begin sci := [ ] ;
36148: LD_ADDR_VAR 0 8
36152: PUSH
36153: EMPTY
36154: ST_TO_ADDR
// for x in ( tmp diff j ) do
36155: LD_ADDR_VAR 0 7
36159: PUSH
36160: LD_VAR 0 6
36164: PUSH
36165: LD_VAR 0 3
36169: DIFF
36170: PUSH
36171: FOR_IN
36172: IFFALSE 36224
// begin if sci = 6 then
36174: LD_VAR 0 8
36178: PUSH
36179: LD_INT 6
36181: EQUAL
36182: IFFALSE 36186
// break ;
36184: GO 36224
// if BuildingStatus ( x ) = bs_idle then
36186: LD_VAR 0 7
36190: PPUSH
36191: CALL_OW 461
36195: PUSH
36196: LD_INT 2
36198: EQUAL
36199: IFFALSE 36222
// sci := sci ^ UnitsInside ( x ) ;
36201: LD_ADDR_VAR 0 8
36205: PUSH
36206: LD_VAR 0 8
36210: PUSH
36211: LD_VAR 0 7
36215: PPUSH
36216: CALL_OW 313
36220: ADD
36221: ST_TO_ADDR
// end ;
36222: GO 36171
36224: POP
36225: POP
// if not sci then
36226: LD_VAR 0 8
36230: NOT
36231: IFFALSE 36235
// continue ;
36233: GO 35280
// for x in sci do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 8
36244: PUSH
36245: FOR_IN
36246: IFFALSE 36296
// if IsInUnit ( x ) and not HasTask ( x ) then
36248: LD_VAR 0 7
36252: PPUSH
36253: CALL_OW 310
36257: PUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 314
36267: NOT
36268: AND
36269: IFFALSE 36294
// begin ComExitBuilding ( x ) ;
36271: LD_VAR 0 7
36275: PPUSH
36276: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36280: LD_VAR 0 7
36284: PPUSH
36285: LD_VAR 0 3
36289: PPUSH
36290: CALL_OW 180
// end ;
36294: GO 36245
36296: POP
36297: POP
// end ; end ;
36298: GO 35280
36300: POP
36301: POP
// end ;
36302: GO 35234
36304: POP
36305: POP
// end ;
36306: LD_VAR 0 1
36310: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36311: LD_INT 0
36313: PPUSH
36314: PPUSH
// if not mc_bases then
36315: LD_EXP 50
36319: NOT
36320: IFFALSE 36324
// exit ;
36322: GO 36405
// for i = 1 to mc_bases do
36324: LD_ADDR_VAR 0 2
36328: PUSH
36329: DOUBLE
36330: LD_INT 1
36332: DEC
36333: ST_TO_ADDR
36334: LD_EXP 50
36338: PUSH
36339: FOR_TO
36340: IFFALSE 36403
// if mc_mines [ i ] and mc_miners [ i ] then
36342: LD_EXP 63
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_EXP 64
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: AND
36364: IFFALSE 36401
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36366: LD_EXP 64
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PUSH
36377: LD_INT 1
36379: ARRAY
36380: PPUSH
36381: CALL_OW 255
36385: PPUSH
36386: LD_EXP 63
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PPUSH
36397: CALL 51044 0 2
36401: GO 36339
36403: POP
36404: POP
// end ;
36405: LD_VAR 0 1
36409: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36410: LD_INT 0
36412: PPUSH
36413: PPUSH
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
// if not mc_bases or not mc_parking then
36420: LD_EXP 50
36424: NOT
36425: PUSH
36426: LD_EXP 74
36430: NOT
36431: OR
36432: IFFALSE 36436
// exit ;
36434: GO 37174
// for i = 1 to mc_bases do
36436: LD_ADDR_VAR 0 2
36440: PUSH
36441: DOUBLE
36442: LD_INT 1
36444: DEC
36445: ST_TO_ADDR
36446: LD_EXP 50
36450: PUSH
36451: FOR_TO
36452: IFFALSE 37172
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36454: LD_EXP 50
36458: PUSH
36459: LD_VAR 0 2
36463: ARRAY
36464: NOT
36465: PUSH
36466: LD_EXP 74
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: NOT
36477: OR
36478: IFFALSE 36482
// continue ;
36480: GO 36451
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36482: LD_ADDR_VAR 0 5
36486: PUSH
36487: LD_EXP 50
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: PUSH
36498: LD_INT 1
36500: ARRAY
36501: PPUSH
36502: CALL_OW 255
36506: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36507: LD_ADDR_VAR 0 6
36511: PUSH
36512: LD_EXP 50
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 30
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PPUSH
36533: CALL_OW 72
36537: ST_TO_ADDR
// if not fac then
36538: LD_VAR 0 6
36542: NOT
36543: IFFALSE 36594
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36545: LD_ADDR_VAR 0 6
36549: PUSH
36550: LD_EXP 50
36554: PUSH
36555: LD_VAR 0 2
36559: ARRAY
36560: PPUSH
36561: LD_INT 2
36563: PUSH
36564: LD_INT 30
36566: PUSH
36567: LD_INT 0
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 30
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: PPUSH
36589: CALL_OW 72
36593: ST_TO_ADDR
// if not fac then
36594: LD_VAR 0 6
36598: NOT
36599: IFFALSE 36603
// continue ;
36601: GO 36451
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36603: LD_ADDR_VAR 0 7
36607: PUSH
36608: LD_EXP 74
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PPUSH
36619: LD_INT 22
36621: PUSH
36622: LD_VAR 0 5
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 21
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 3
36643: PUSH
36644: LD_INT 60
36646: PUSH
36647: EMPTY
36648: LIST
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: PUSH
36657: LD_INT 24
36659: PUSH
36660: LD_INT 1000
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: PPUSH
36677: CALL_OW 70
36681: ST_TO_ADDR
// for j in fac do
36682: LD_ADDR_VAR 0 3
36686: PUSH
36687: LD_VAR 0 6
36691: PUSH
36692: FOR_IN
36693: IFFALSE 36788
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36695: LD_ADDR_VAR 0 7
36699: PUSH
36700: LD_VAR 0 7
36704: PUSH
36705: LD_INT 22
36707: PUSH
36708: LD_VAR 0 5
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 91
36719: PUSH
36720: LD_VAR 0 3
36724: PUSH
36725: LD_INT 15
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 60
36748: PUSH
36749: EMPTY
36750: LIST
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: LD_INT 24
36761: PUSH
36762: LD_INT 1000
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: PPUSH
36780: CALL_OW 69
36784: UNION
36785: ST_TO_ADDR
36786: GO 36692
36788: POP
36789: POP
// if not vehs then
36790: LD_VAR 0 7
36794: NOT
36795: IFFALSE 36821
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36797: LD_ADDR_EXP 62
36801: PUSH
36802: LD_EXP 62
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// continue ;
36819: GO 36451
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36821: LD_ADDR_VAR 0 8
36825: PUSH
36826: LD_EXP 50
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PPUSH
36837: LD_INT 30
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PPUSH
36847: CALL_OW 72
36851: ST_TO_ADDR
// if tmp then
36852: LD_VAR 0 8
36856: IFFALSE 36959
// begin for j in tmp do
36858: LD_ADDR_VAR 0 3
36862: PUSH
36863: LD_VAR 0 8
36867: PUSH
36868: FOR_IN
36869: IFFALSE 36957
// for k in UnitsInside ( j ) do
36871: LD_ADDR_VAR 0 4
36875: PUSH
36876: LD_VAR 0 3
36880: PPUSH
36881: CALL_OW 313
36885: PUSH
36886: FOR_IN
36887: IFFALSE 36953
// if k then
36889: LD_VAR 0 4
36893: IFFALSE 36951
// if not k in mc_repair_vehicle [ i ] then
36895: LD_VAR 0 4
36899: PUSH
36900: LD_EXP 62
36904: PUSH
36905: LD_VAR 0 2
36909: ARRAY
36910: IN
36911: NOT
36912: IFFALSE 36951
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36914: LD_ADDR_EXP 62
36918: PUSH
36919: LD_EXP 62
36923: PPUSH
36924: LD_VAR 0 2
36928: PPUSH
36929: LD_EXP 62
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PUSH
36940: LD_VAR 0 4
36944: UNION
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
36951: GO 36886
36953: POP
36954: POP
36955: GO 36868
36957: POP
36958: POP
// end ; if not mc_repair_vehicle [ i ] then
36959: LD_EXP 62
36963: PUSH
36964: LD_VAR 0 2
36968: ARRAY
36969: NOT
36970: IFFALSE 36974
// continue ;
36972: GO 36451
// for j in mc_repair_vehicle [ i ] do
36974: LD_ADDR_VAR 0 3
36978: PUSH
36979: LD_EXP 62
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PUSH
36990: FOR_IN
36991: IFFALSE 37168
// begin if GetClass ( j ) <> 3 then
36993: LD_VAR 0 3
36997: PPUSH
36998: CALL_OW 257
37002: PUSH
37003: LD_INT 3
37005: NONEQUAL
37006: IFFALSE 37047
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37008: LD_ADDR_EXP 62
37012: PUSH
37013: LD_EXP 62
37017: PPUSH
37018: LD_VAR 0 2
37022: PPUSH
37023: LD_EXP 62
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PUSH
37034: LD_VAR 0 3
37038: DIFF
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// continue ;
37045: GO 36990
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37047: LD_VAR 0 3
37051: PPUSH
37052: CALL_OW 311
37056: NOT
37057: PUSH
37058: LD_VAR 0 3
37062: PUSH
37063: LD_EXP 53
37067: PUSH
37068: LD_VAR 0 2
37072: ARRAY
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: IN
37078: NOT
37079: AND
37080: PUSH
37081: LD_VAR 0 3
37085: PUSH
37086: LD_EXP 53
37090: PUSH
37091: LD_VAR 0 2
37095: ARRAY
37096: PUSH
37097: LD_INT 2
37099: ARRAY
37100: IN
37101: NOT
37102: AND
37103: IFFALSE 37166
// begin if IsInUnit ( j ) then
37105: LD_VAR 0 3
37109: PPUSH
37110: CALL_OW 310
37114: IFFALSE 37127
// ComExitBuilding ( j ) else
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 122
37125: GO 37166
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37127: LD_VAR 0 3
37131: PPUSH
37132: LD_VAR 0 7
37136: PUSH
37137: LD_INT 1
37139: ARRAY
37140: PPUSH
37141: CALL 88491 0 2
37145: NOT
37146: IFFALSE 37166
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37148: LD_VAR 0 3
37152: PPUSH
37153: LD_VAR 0 7
37157: PUSH
37158: LD_INT 1
37160: ARRAY
37161: PPUSH
37162: CALL_OW 129
// end ; end ;
37166: GO 36990
37168: POP
37169: POP
// end ;
37170: GO 36451
37172: POP
37173: POP
// end ;
37174: LD_VAR 0 1
37178: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37179: LD_INT 0
37181: PPUSH
37182: PPUSH
37183: PPUSH
37184: PPUSH
37185: PPUSH
37186: PPUSH
37187: PPUSH
37188: PPUSH
37189: PPUSH
37190: PPUSH
37191: PPUSH
// if not mc_bases then
37192: LD_EXP 50
37196: NOT
37197: IFFALSE 37201
// exit ;
37199: GO 38003
// for i = 1 to mc_bases do
37201: LD_ADDR_VAR 0 2
37205: PUSH
37206: DOUBLE
37207: LD_INT 1
37209: DEC
37210: ST_TO_ADDR
37211: LD_EXP 50
37215: PUSH
37216: FOR_TO
37217: IFFALSE 38001
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37219: LD_EXP 78
37223: PUSH
37224: LD_VAR 0 2
37228: ARRAY
37229: NOT
37230: PUSH
37231: LD_EXP 53
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PUSH
37242: LD_INT 1
37244: ARRAY
37245: OR
37246: PUSH
37247: LD_EXP 53
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 2
37260: ARRAY
37261: OR
37262: PUSH
37263: LD_EXP 76
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PPUSH
37274: LD_INT 1
37276: PPUSH
37277: CALL_OW 325
37281: NOT
37282: OR
37283: PUSH
37284: LD_EXP 73
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: OR
37295: IFFALSE 37299
// continue ;
37297: GO 37216
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37299: LD_ADDR_VAR 0 8
37303: PUSH
37304: LD_EXP 50
37308: PUSH
37309: LD_VAR 0 2
37313: ARRAY
37314: PPUSH
37315: LD_INT 25
37317: PUSH
37318: LD_INT 4
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 50
37327: PUSH
37328: EMPTY
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: LD_INT 60
37336: PUSH
37337: EMPTY
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: PUSH
37354: LD_EXP 54
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: DIFF
37365: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37366: LD_ADDR_VAR 0 9
37370: PUSH
37371: LD_EXP 50
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PPUSH
37410: CALL_OW 72
37414: ST_TO_ADDR
// if not tmp or not dep then
37415: LD_VAR 0 8
37419: NOT
37420: PUSH
37421: LD_VAR 0 9
37425: NOT
37426: OR
37427: IFFALSE 37431
// continue ;
37429: GO 37216
// side := GetSide ( tmp [ 1 ] ) ;
37431: LD_ADDR_VAR 0 11
37435: PUSH
37436: LD_VAR 0 8
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: PPUSH
37445: CALL_OW 255
37449: ST_TO_ADDR
// dep := dep [ 1 ] ;
37450: LD_ADDR_VAR 0 9
37454: PUSH
37455: LD_VAR 0 9
37459: PUSH
37460: LD_INT 1
37462: ARRAY
37463: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37464: LD_ADDR_VAR 0 7
37468: PUSH
37469: LD_EXP 78
37473: PUSH
37474: LD_VAR 0 2
37478: ARRAY
37479: PPUSH
37480: LD_INT 22
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 25
37492: PUSH
37493: LD_INT 12
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PPUSH
37504: CALL_OW 70
37508: PUSH
37509: LD_INT 22
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 12
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 91
37531: PUSH
37532: LD_VAR 0 9
37536: PUSH
37537: LD_INT 20
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: LIST
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: LIST
37549: PPUSH
37550: CALL_OW 69
37554: UNION
37555: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37556: LD_ADDR_VAR 0 10
37560: PUSH
37561: LD_EXP 78
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: PPUSH
37572: LD_INT 81
37574: PUSH
37575: LD_VAR 0 11
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: ST_TO_ADDR
// if not apes or danger_at_area then
37589: LD_VAR 0 7
37593: NOT
37594: PUSH
37595: LD_VAR 0 10
37599: OR
37600: IFFALSE 37650
// begin if mc_taming [ i ] then
37602: LD_EXP 81
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: IFFALSE 37648
// begin MC_Reset ( i , 121 ) ;
37614: LD_VAR 0 2
37618: PPUSH
37619: LD_INT 121
37621: PPUSH
37622: CALL 22566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37626: LD_ADDR_EXP 81
37630: PUSH
37631: LD_EXP 81
37635: PPUSH
37636: LD_VAR 0 2
37640: PPUSH
37641: EMPTY
37642: PPUSH
37643: CALL_OW 1
37647: ST_TO_ADDR
// end ; continue ;
37648: GO 37216
// end ; for j in tmp do
37650: LD_ADDR_VAR 0 3
37654: PUSH
37655: LD_VAR 0 8
37659: PUSH
37660: FOR_IN
37661: IFFALSE 37997
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37663: LD_VAR 0 3
37667: PUSH
37668: LD_EXP 81
37672: PUSH
37673: LD_VAR 0 2
37677: ARRAY
37678: IN
37679: NOT
37680: PUSH
37681: LD_EXP 81
37685: PUSH
37686: LD_VAR 0 2
37690: ARRAY
37691: PUSH
37692: LD_INT 3
37694: LESS
37695: AND
37696: IFFALSE 37754
// begin SetTag ( j , 121 ) ;
37698: LD_VAR 0 3
37702: PPUSH
37703: LD_INT 121
37705: PPUSH
37706: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37710: LD_ADDR_EXP 81
37714: PUSH
37715: LD_EXP 81
37719: PPUSH
37720: LD_VAR 0 2
37724: PUSH
37725: LD_EXP 81
37729: PUSH
37730: LD_VAR 0 2
37734: ARRAY
37735: PUSH
37736: LD_INT 1
37738: PLUS
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PPUSH
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL 54067 0 3
37753: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37754: LD_VAR 0 3
37758: PUSH
37759: LD_EXP 81
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: IN
37770: IFFALSE 37995
// begin if GetClass ( j ) <> 4 then
37772: LD_VAR 0 3
37776: PPUSH
37777: CALL_OW 257
37781: PUSH
37782: LD_INT 4
37784: NONEQUAL
37785: IFFALSE 37838
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37787: LD_ADDR_EXP 81
37791: PUSH
37792: LD_EXP 81
37796: PPUSH
37797: LD_VAR 0 2
37801: PPUSH
37802: LD_EXP 81
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_VAR 0 3
37817: DIFF
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 0
37831: PPUSH
37832: CALL_OW 109
// continue ;
37836: GO 37660
// end ; if IsInUnit ( j ) then
37838: LD_VAR 0 3
37842: PPUSH
37843: CALL_OW 310
37847: IFFALSE 37858
// ComExitBuilding ( j ) ;
37849: LD_VAR 0 3
37853: PPUSH
37854: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37858: LD_ADDR_VAR 0 6
37862: PUSH
37863: LD_VAR 0 7
37867: PPUSH
37868: LD_VAR 0 3
37872: PPUSH
37873: CALL_OW 74
37877: ST_TO_ADDR
// if not ape then
37878: LD_VAR 0 6
37882: NOT
37883: IFFALSE 37887
// break ;
37885: GO 37997
// x := GetX ( ape ) ;
37887: LD_ADDR_VAR 0 4
37891: PUSH
37892: LD_VAR 0 6
37896: PPUSH
37897: CALL_OW 250
37901: ST_TO_ADDR
// y := GetY ( ape ) ;
37902: LD_ADDR_VAR 0 5
37906: PUSH
37907: LD_VAR 0 6
37911: PPUSH
37912: CALL_OW 251
37916: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37917: LD_VAR 0 4
37921: PPUSH
37922: LD_VAR 0 5
37926: PPUSH
37927: CALL_OW 488
37931: NOT
37932: PUSH
37933: LD_VAR 0 11
37937: PPUSH
37938: LD_VAR 0 4
37942: PPUSH
37943: LD_VAR 0 5
37947: PPUSH
37948: LD_INT 20
37950: PPUSH
37951: CALL 54963 0 4
37955: PUSH
37956: LD_INT 4
37958: ARRAY
37959: OR
37960: IFFALSE 37964
// break ;
37962: GO 37997
// if not HasTask ( j ) then
37964: LD_VAR 0 3
37968: PPUSH
37969: CALL_OW 314
37973: NOT
37974: IFFALSE 37995
// ComTameXY ( j , x , y ) ;
37976: LD_VAR 0 3
37980: PPUSH
37981: LD_VAR 0 4
37985: PPUSH
37986: LD_VAR 0 5
37990: PPUSH
37991: CALL_OW 131
// end ; end ;
37995: GO 37660
37997: POP
37998: POP
// end ;
37999: GO 37216
38001: POP
38002: POP
// end ;
38003: LD_VAR 0 1
38007: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38008: LD_INT 0
38010: PPUSH
38011: PPUSH
38012: PPUSH
38013: PPUSH
38014: PPUSH
38015: PPUSH
38016: PPUSH
38017: PPUSH
// if not mc_bases then
38018: LD_EXP 50
38022: NOT
38023: IFFALSE 38027
// exit ;
38025: GO 38653
// for i = 1 to mc_bases do
38027: LD_ADDR_VAR 0 2
38031: PUSH
38032: DOUBLE
38033: LD_INT 1
38035: DEC
38036: ST_TO_ADDR
38037: LD_EXP 50
38041: PUSH
38042: FOR_TO
38043: IFFALSE 38651
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38045: LD_EXP 79
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: NOT
38056: PUSH
38057: LD_EXP 79
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: PPUSH
38068: LD_INT 25
38070: PUSH
38071: LD_INT 12
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PPUSH
38078: CALL_OW 72
38082: NOT
38083: OR
38084: IFFALSE 38088
// continue ;
38086: GO 38042
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38088: LD_ADDR_VAR 0 5
38092: PUSH
38093: LD_EXP 79
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: PUSH
38104: LD_INT 1
38106: ARRAY
38107: PPUSH
38108: CALL_OW 255
38112: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38113: LD_VAR 0 5
38117: PPUSH
38118: LD_INT 2
38120: PPUSH
38121: CALL_OW 325
38125: IFFALSE 38378
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38127: LD_ADDR_VAR 0 4
38131: PUSH
38132: LD_EXP 79
38136: PUSH
38137: LD_VAR 0 2
38141: ARRAY
38142: PPUSH
38143: LD_INT 25
38145: PUSH
38146: LD_INT 16
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PPUSH
38153: CALL_OW 72
38157: ST_TO_ADDR
// if tmp < 6 then
38158: LD_VAR 0 4
38162: PUSH
38163: LD_INT 6
38165: LESS
38166: IFFALSE 38378
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38168: LD_ADDR_VAR 0 6
38172: PUSH
38173: LD_EXP 50
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PPUSH
38184: LD_INT 2
38186: PUSH
38187: LD_INT 30
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 30
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 72
38216: ST_TO_ADDR
// if depot then
38217: LD_VAR 0 6
38221: IFFALSE 38378
// begin selected := 0 ;
38223: LD_ADDR_VAR 0 7
38227: PUSH
38228: LD_INT 0
38230: ST_TO_ADDR
// for j in depot do
38231: LD_ADDR_VAR 0 3
38235: PUSH
38236: LD_VAR 0 6
38240: PUSH
38241: FOR_IN
38242: IFFALSE 38273
// begin if UnitsInside ( j ) < 6 then
38244: LD_VAR 0 3
38248: PPUSH
38249: CALL_OW 313
38253: PUSH
38254: LD_INT 6
38256: LESS
38257: IFFALSE 38271
// begin selected := j ;
38259: LD_ADDR_VAR 0 7
38263: PUSH
38264: LD_VAR 0 3
38268: ST_TO_ADDR
// break ;
38269: GO 38273
// end ; end ;
38271: GO 38241
38273: POP
38274: POP
// if selected then
38275: LD_VAR 0 7
38279: IFFALSE 38378
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38281: LD_ADDR_VAR 0 3
38285: PUSH
38286: LD_EXP 79
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 25
38299: PUSH
38300: LD_INT 12
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PPUSH
38307: CALL_OW 72
38311: PUSH
38312: FOR_IN
38313: IFFALSE 38376
// if not HasTask ( j ) then
38315: LD_VAR 0 3
38319: PPUSH
38320: CALL_OW 314
38324: NOT
38325: IFFALSE 38374
// begin if not IsInUnit ( j ) then
38327: LD_VAR 0 3
38331: PPUSH
38332: CALL_OW 310
38336: NOT
38337: IFFALSE 38353
// ComEnterUnit ( j , selected ) ;
38339: LD_VAR 0 3
38343: PPUSH
38344: LD_VAR 0 7
38348: PPUSH
38349: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_INT 16
38360: PPUSH
38361: CALL_OW 183
// AddComExitBuilding ( j ) ;
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 182
// end ;
38374: GO 38312
38376: POP
38377: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38378: LD_VAR 0 5
38382: PPUSH
38383: LD_INT 11
38385: PPUSH
38386: CALL_OW 325
38390: IFFALSE 38649
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38392: LD_ADDR_VAR 0 4
38396: PUSH
38397: LD_EXP 79
38401: PUSH
38402: LD_VAR 0 2
38406: ARRAY
38407: PPUSH
38408: LD_INT 25
38410: PUSH
38411: LD_INT 16
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PPUSH
38418: CALL_OW 72
38422: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38423: LD_VAR 0 4
38427: PUSH
38428: LD_INT 6
38430: GREATEREQUAL
38431: PUSH
38432: LD_VAR 0 5
38436: PPUSH
38437: LD_INT 2
38439: PPUSH
38440: CALL_OW 325
38444: NOT
38445: OR
38446: IFFALSE 38649
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38448: LD_ADDR_VAR 0 8
38452: PUSH
38453: LD_EXP 50
38457: PUSH
38458: LD_VAR 0 2
38462: ARRAY
38463: PPUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 30
38469: PUSH
38470: LD_INT 4
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 30
38479: PUSH
38480: LD_INT 5
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: LIST
38491: PPUSH
38492: CALL_OW 72
38496: ST_TO_ADDR
// if barracks then
38497: LD_VAR 0 8
38501: IFFALSE 38649
// begin selected := 0 ;
38503: LD_ADDR_VAR 0 7
38507: PUSH
38508: LD_INT 0
38510: ST_TO_ADDR
// for j in barracks do
38511: LD_ADDR_VAR 0 3
38515: PUSH
38516: LD_VAR 0 8
38520: PUSH
38521: FOR_IN
38522: IFFALSE 38553
// begin if UnitsInside ( j ) < 6 then
38524: LD_VAR 0 3
38528: PPUSH
38529: CALL_OW 313
38533: PUSH
38534: LD_INT 6
38536: LESS
38537: IFFALSE 38551
// begin selected := j ;
38539: LD_ADDR_VAR 0 7
38543: PUSH
38544: LD_VAR 0 3
38548: ST_TO_ADDR
// break ;
38549: GO 38553
// end ; end ;
38551: GO 38521
38553: POP
38554: POP
// if selected then
38555: LD_VAR 0 7
38559: IFFALSE 38649
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38561: LD_ADDR_VAR 0 3
38565: PUSH
38566: LD_EXP 79
38570: PUSH
38571: LD_VAR 0 2
38575: ARRAY
38576: PPUSH
38577: LD_INT 25
38579: PUSH
38580: LD_INT 12
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PPUSH
38587: CALL_OW 72
38591: PUSH
38592: FOR_IN
38593: IFFALSE 38647
// if not IsInUnit ( j ) and not HasTask ( j ) then
38595: LD_VAR 0 3
38599: PPUSH
38600: CALL_OW 310
38604: NOT
38605: PUSH
38606: LD_VAR 0 3
38610: PPUSH
38611: CALL_OW 314
38615: NOT
38616: AND
38617: IFFALSE 38645
// begin ComEnterUnit ( j , selected ) ;
38619: LD_VAR 0 3
38623: PPUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38633: LD_VAR 0 3
38637: PPUSH
38638: LD_INT 15
38640: PPUSH
38641: CALL_OW 183
// end ;
38645: GO 38592
38647: POP
38648: POP
// end ; end ; end ; end ; end ;
38649: GO 38042
38651: POP
38652: POP
// end ;
38653: LD_VAR 0 1
38657: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38658: LD_INT 0
38660: PPUSH
38661: PPUSH
38662: PPUSH
38663: PPUSH
// if not mc_bases then
38664: LD_EXP 50
38668: NOT
38669: IFFALSE 38673
// exit ;
38671: GO 38851
// for i = 1 to mc_bases do
38673: LD_ADDR_VAR 0 2
38677: PUSH
38678: DOUBLE
38679: LD_INT 1
38681: DEC
38682: ST_TO_ADDR
38683: LD_EXP 50
38687: PUSH
38688: FOR_TO
38689: IFFALSE 38849
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38691: LD_ADDR_VAR 0 4
38695: PUSH
38696: LD_EXP 50
38700: PUSH
38701: LD_VAR 0 2
38705: ARRAY
38706: PPUSH
38707: LD_INT 25
38709: PUSH
38710: LD_INT 9
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PPUSH
38717: CALL_OW 72
38721: ST_TO_ADDR
// if not tmp then
38722: LD_VAR 0 4
38726: NOT
38727: IFFALSE 38731
// continue ;
38729: GO 38688
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38731: LD_EXP 76
38735: PUSH
38736: LD_VAR 0 2
38740: ARRAY
38741: PPUSH
38742: LD_INT 29
38744: PPUSH
38745: CALL_OW 325
38749: NOT
38750: PUSH
38751: LD_EXP 76
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: PPUSH
38762: LD_INT 28
38764: PPUSH
38765: CALL_OW 325
38769: NOT
38770: AND
38771: IFFALSE 38775
// continue ;
38773: GO 38688
// for j in tmp do
38775: LD_ADDR_VAR 0 3
38779: PUSH
38780: LD_VAR 0 4
38784: PUSH
38785: FOR_IN
38786: IFFALSE 38845
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38788: LD_VAR 0 3
38792: PUSH
38793: LD_EXP 53
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_INT 1
38806: ARRAY
38807: IN
38808: NOT
38809: PUSH
38810: LD_VAR 0 3
38814: PUSH
38815: LD_EXP 53
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 2
38828: ARRAY
38829: IN
38830: NOT
38831: AND
38832: IFFALSE 38843
// ComSpaceTimeShoot ( j ) ;
38834: LD_VAR 0 3
38838: PPUSH
38839: CALL 50052 0 1
38843: GO 38785
38845: POP
38846: POP
// end ;
38847: GO 38688
38849: POP
38850: POP
// end ;
38851: LD_VAR 0 1
38855: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38856: LD_INT 0
38858: PPUSH
38859: PPUSH
38860: PPUSH
38861: PPUSH
38862: PPUSH
38863: PPUSH
38864: PPUSH
38865: PPUSH
38866: PPUSH
// if not mc_bases then
38867: LD_EXP 50
38871: NOT
38872: IFFALSE 38876
// exit ;
38874: GO 39498
// for i = 1 to mc_bases do
38876: LD_ADDR_VAR 0 2
38880: PUSH
38881: DOUBLE
38882: LD_INT 1
38884: DEC
38885: ST_TO_ADDR
38886: LD_EXP 50
38890: PUSH
38891: FOR_TO
38892: IFFALSE 39496
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38894: LD_EXP 85
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: NOT
38905: PUSH
38906: LD_INT 38
38908: PPUSH
38909: LD_EXP 76
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: PPUSH
38920: CALL_OW 321
38924: PUSH
38925: LD_INT 2
38927: NONEQUAL
38928: OR
38929: IFFALSE 38933
// continue ;
38931: GO 38891
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38933: LD_ADDR_VAR 0 8
38937: PUSH
38938: LD_EXP 50
38942: PUSH
38943: LD_VAR 0 2
38947: ARRAY
38948: PPUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 34
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PPUSH
38959: CALL_OW 72
38963: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38964: LD_ADDR_VAR 0 9
38968: PUSH
38969: LD_EXP 50
38973: PUSH
38974: LD_VAR 0 2
38978: ARRAY
38979: PPUSH
38980: LD_INT 25
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PPUSH
38990: CALL_OW 72
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: CALL 84008 0 2
39002: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39003: LD_VAR 0 9
39007: NOT
39008: PUSH
39009: LD_VAR 0 8
39013: NOT
39014: OR
39015: PUSH
39016: LD_EXP 50
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 124
39029: PPUSH
39030: CALL 84008 0 2
39034: OR
39035: IFFALSE 39039
// continue ;
39037: GO 38891
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39039: LD_EXP 86
39043: PUSH
39044: LD_VAR 0 2
39048: ARRAY
39049: PUSH
39050: LD_EXP 85
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: LESS
39061: PUSH
39062: LD_EXP 86
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_VAR 0 8
39077: LESS
39078: AND
39079: IFFALSE 39494
// begin tmp := sci [ 1 ] ;
39081: LD_ADDR_VAR 0 7
39085: PUSH
39086: LD_VAR 0 9
39090: PUSH
39091: LD_INT 1
39093: ARRAY
39094: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39095: LD_VAR 0 7
39099: PPUSH
39100: LD_INT 124
39102: PPUSH
39103: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39107: LD_ADDR_VAR 0 3
39111: PUSH
39112: DOUBLE
39113: LD_EXP 85
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: INC
39124: ST_TO_ADDR
39125: LD_EXP 85
39129: PUSH
39130: LD_VAR 0 2
39134: ARRAY
39135: PUSH
39136: FOR_DOWNTO
39137: IFFALSE 39480
// begin if IsInUnit ( tmp ) then
39139: LD_VAR 0 7
39143: PPUSH
39144: CALL_OW 310
39148: IFFALSE 39159
// ComExitBuilding ( tmp ) ;
39150: LD_VAR 0 7
39154: PPUSH
39155: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39159: LD_INT 35
39161: PPUSH
39162: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39166: LD_VAR 0 7
39170: PPUSH
39171: CALL_OW 310
39175: NOT
39176: PUSH
39177: LD_VAR 0 7
39181: PPUSH
39182: CALL_OW 314
39186: NOT
39187: AND
39188: IFFALSE 39159
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39190: LD_ADDR_VAR 0 6
39194: PUSH
39195: LD_VAR 0 7
39199: PPUSH
39200: CALL_OW 250
39204: PUSH
39205: LD_VAR 0 7
39209: PPUSH
39210: CALL_OW 251
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39219: LD_INT 35
39221: PPUSH
39222: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39226: LD_ADDR_VAR 0 4
39230: PUSH
39231: LD_EXP 85
39235: PUSH
39236: LD_VAR 0 2
39240: ARRAY
39241: PUSH
39242: LD_VAR 0 3
39246: ARRAY
39247: PUSH
39248: LD_INT 1
39250: ARRAY
39251: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39252: LD_ADDR_VAR 0 5
39256: PUSH
39257: LD_EXP 85
39261: PUSH
39262: LD_VAR 0 2
39266: ARRAY
39267: PUSH
39268: LD_VAR 0 3
39272: ARRAY
39273: PUSH
39274: LD_INT 2
39276: ARRAY
39277: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39278: LD_VAR 0 7
39282: PPUSH
39283: LD_INT 10
39285: PPUSH
39286: CALL 56664 0 2
39290: PUSH
39291: LD_INT 4
39293: ARRAY
39294: IFFALSE 39332
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39296: LD_VAR 0 7
39300: PPUSH
39301: LD_VAR 0 6
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: LD_VAR 0 6
39314: PUSH
39315: LD_INT 2
39317: ARRAY
39318: PPUSH
39319: CALL_OW 111
// wait ( 0 0$10 ) ;
39323: LD_INT 350
39325: PPUSH
39326: CALL_OW 67
// end else
39330: GO 39358
// begin ComMoveXY ( tmp , x , y ) ;
39332: LD_VAR 0 7
39336: PPUSH
39337: LD_VAR 0 4
39341: PPUSH
39342: LD_VAR 0 5
39346: PPUSH
39347: CALL_OW 111
// wait ( 0 0$3 ) ;
39351: LD_INT 105
39353: PPUSH
39354: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_VAR 0 4
39367: PPUSH
39368: LD_VAR 0 5
39372: PPUSH
39373: CALL_OW 307
39377: IFFALSE 39219
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39379: LD_VAR 0 7
39383: PPUSH
39384: LD_VAR 0 4
39388: PPUSH
39389: LD_VAR 0 5
39393: PPUSH
39394: LD_VAR 0 8
39398: PUSH
39399: LD_VAR 0 3
39403: ARRAY
39404: PPUSH
39405: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39409: LD_INT 35
39411: PPUSH
39412: CALL_OW 67
// until not HasTask ( tmp ) ;
39416: LD_VAR 0 7
39420: PPUSH
39421: CALL_OW 314
39425: NOT
39426: IFFALSE 39409
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39428: LD_ADDR_EXP 86
39432: PUSH
39433: LD_EXP 86
39437: PPUSH
39438: LD_VAR 0 2
39442: PUSH
39443: LD_EXP 86
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: PLUS
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PPUSH
39462: LD_VAR 0 8
39466: PUSH
39467: LD_VAR 0 3
39471: ARRAY
39472: PPUSH
39473: CALL 54067 0 3
39477: ST_TO_ADDR
// end ;
39478: GO 39136
39480: POP
39481: POP
// MC_Reset ( i , 124 ) ;
39482: LD_VAR 0 2
39486: PPUSH
39487: LD_INT 124
39489: PPUSH
39490: CALL 22566 0 2
// end ; end ;
39494: GO 38891
39496: POP
39497: POP
// end ;
39498: LD_VAR 0 1
39502: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39503: LD_INT 0
39505: PPUSH
39506: PPUSH
39507: PPUSH
// if not mc_bases then
39508: LD_EXP 50
39512: NOT
39513: IFFALSE 39517
// exit ;
39515: GO 40123
// for i = 1 to mc_bases do
39517: LD_ADDR_VAR 0 2
39521: PUSH
39522: DOUBLE
39523: LD_INT 1
39525: DEC
39526: ST_TO_ADDR
39527: LD_EXP 50
39531: PUSH
39532: FOR_TO
39533: IFFALSE 40121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39535: LD_ADDR_VAR 0 3
39539: PUSH
39540: LD_EXP 50
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PPUSH
39551: LD_INT 25
39553: PUSH
39554: LD_INT 4
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL_OW 72
39565: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39566: LD_VAR 0 3
39570: NOT
39571: PUSH
39572: LD_EXP 87
39576: PUSH
39577: LD_VAR 0 2
39581: ARRAY
39582: NOT
39583: OR
39584: PUSH
39585: LD_EXP 50
39589: PUSH
39590: LD_VAR 0 2
39594: ARRAY
39595: PPUSH
39596: LD_INT 2
39598: PUSH
39599: LD_INT 30
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 30
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: LIST
39623: PPUSH
39624: CALL_OW 72
39628: NOT
39629: OR
39630: IFFALSE 39680
// begin if mc_deposits_finder [ i ] then
39632: LD_EXP 88
39636: PUSH
39637: LD_VAR 0 2
39641: ARRAY
39642: IFFALSE 39678
// begin MC_Reset ( i , 125 ) ;
39644: LD_VAR 0 2
39648: PPUSH
39649: LD_INT 125
39651: PPUSH
39652: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39656: LD_ADDR_EXP 88
39660: PUSH
39661: LD_EXP 88
39665: PPUSH
39666: LD_VAR 0 2
39670: PPUSH
39671: EMPTY
39672: PPUSH
39673: CALL_OW 1
39677: ST_TO_ADDR
// end ; continue ;
39678: GO 39532
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39680: LD_EXP 87
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_INT 1
39693: ARRAY
39694: PUSH
39695: LD_INT 3
39697: ARRAY
39698: PUSH
39699: LD_INT 1
39701: EQUAL
39702: PUSH
39703: LD_INT 20
39705: PPUSH
39706: LD_EXP 76
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: CALL_OW 321
39721: PUSH
39722: LD_INT 2
39724: NONEQUAL
39725: AND
39726: IFFALSE 39776
// begin if mc_deposits_finder [ i ] then
39728: LD_EXP 88
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: IFFALSE 39774
// begin MC_Reset ( i , 125 ) ;
39740: LD_VAR 0 2
39744: PPUSH
39745: LD_INT 125
39747: PPUSH
39748: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39752: LD_ADDR_EXP 88
39756: PUSH
39757: LD_EXP 88
39761: PPUSH
39762: LD_VAR 0 2
39766: PPUSH
39767: EMPTY
39768: PPUSH
39769: CALL_OW 1
39773: ST_TO_ADDR
// end ; continue ;
39774: GO 39532
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39776: LD_EXP 87
39780: PUSH
39781: LD_VAR 0 2
39785: ARRAY
39786: PUSH
39787: LD_INT 1
39789: ARRAY
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PPUSH
39795: LD_EXP 87
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_INT 1
39808: ARRAY
39809: PUSH
39810: LD_INT 2
39812: ARRAY
39813: PPUSH
39814: LD_EXP 76
39818: PUSH
39819: LD_VAR 0 2
39823: ARRAY
39824: PPUSH
39825: CALL_OW 440
39829: IFFALSE 39872
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39831: LD_ADDR_EXP 87
39835: PUSH
39836: LD_EXP 87
39840: PPUSH
39841: LD_VAR 0 2
39845: PPUSH
39846: LD_EXP 87
39850: PUSH
39851: LD_VAR 0 2
39855: ARRAY
39856: PPUSH
39857: LD_INT 1
39859: PPUSH
39860: CALL_OW 3
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
39870: GO 40119
// begin if not mc_deposits_finder [ i ] then
39872: LD_EXP 88
39876: PUSH
39877: LD_VAR 0 2
39881: ARRAY
39882: NOT
39883: IFFALSE 39935
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39885: LD_ADDR_EXP 88
39889: PUSH
39890: LD_EXP 88
39894: PPUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: LD_VAR 0 3
39904: PUSH
39905: LD_INT 1
39907: ARRAY
39908: PUSH
39909: EMPTY
39910: LIST
39911: PPUSH
39912: CALL_OW 1
39916: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39917: LD_VAR 0 3
39921: PUSH
39922: LD_INT 1
39924: ARRAY
39925: PPUSH
39926: LD_INT 125
39928: PPUSH
39929: CALL_OW 109
// end else
39933: GO 40119
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39935: LD_EXP 88
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: ARRAY
39949: PPUSH
39950: CALL_OW 310
39954: IFFALSE 39977
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39956: LD_EXP 88
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PUSH
39967: LD_INT 1
39969: ARRAY
39970: PPUSH
39971: CALL_OW 122
39975: GO 40119
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39977: LD_EXP 88
39981: PUSH
39982: LD_VAR 0 2
39986: ARRAY
39987: PUSH
39988: LD_INT 1
39990: ARRAY
39991: PPUSH
39992: CALL_OW 314
39996: NOT
39997: PUSH
39998: LD_EXP 88
40002: PUSH
40003: LD_VAR 0 2
40007: ARRAY
40008: PUSH
40009: LD_INT 1
40011: ARRAY
40012: PPUSH
40013: LD_EXP 87
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_INT 1
40026: ARRAY
40027: PUSH
40028: LD_INT 1
40030: ARRAY
40031: PPUSH
40032: LD_EXP 87
40036: PUSH
40037: LD_VAR 0 2
40041: ARRAY
40042: PUSH
40043: LD_INT 1
40045: ARRAY
40046: PUSH
40047: LD_INT 2
40049: ARRAY
40050: PPUSH
40051: CALL_OW 297
40055: PUSH
40056: LD_INT 6
40058: GREATER
40059: AND
40060: IFFALSE 40119
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40062: LD_EXP 88
40066: PUSH
40067: LD_VAR 0 2
40071: ARRAY
40072: PUSH
40073: LD_INT 1
40075: ARRAY
40076: PPUSH
40077: LD_EXP 87
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: PUSH
40088: LD_INT 1
40090: ARRAY
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: LD_EXP 87
40100: PUSH
40101: LD_VAR 0 2
40105: ARRAY
40106: PUSH
40107: LD_INT 1
40109: ARRAY
40110: PUSH
40111: LD_INT 2
40113: ARRAY
40114: PPUSH
40115: CALL_OW 111
// end ; end ; end ;
40119: GO 39532
40121: POP
40122: POP
// end ;
40123: LD_VAR 0 1
40127: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40128: LD_INT 0
40130: PPUSH
40131: PPUSH
40132: PPUSH
40133: PPUSH
40134: PPUSH
40135: PPUSH
40136: PPUSH
40137: PPUSH
40138: PPUSH
40139: PPUSH
40140: PPUSH
// if not mc_bases then
40141: LD_EXP 50
40145: NOT
40146: IFFALSE 40150
// exit ;
40148: GO 41090
// for i = 1 to mc_bases do
40150: LD_ADDR_VAR 0 2
40154: PUSH
40155: DOUBLE
40156: LD_INT 1
40158: DEC
40159: ST_TO_ADDR
40160: LD_EXP 50
40164: PUSH
40165: FOR_TO
40166: IFFALSE 41088
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40168: LD_EXP 50
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: NOT
40179: PUSH
40180: LD_EXP 73
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: OR
40191: IFFALSE 40195
// continue ;
40193: GO 40165
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40195: LD_ADDR_VAR 0 7
40199: PUSH
40200: LD_EXP 50
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PUSH
40211: LD_INT 1
40213: ARRAY
40214: PPUSH
40215: CALL_OW 248
40219: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40220: LD_VAR 0 7
40224: PUSH
40225: LD_INT 3
40227: EQUAL
40228: PUSH
40229: LD_EXP 69
40233: PUSH
40234: LD_VAR 0 2
40238: ARRAY
40239: PUSH
40240: LD_EXP 72
40244: PUSH
40245: LD_VAR 0 2
40249: ARRAY
40250: UNION
40251: PPUSH
40252: LD_INT 33
40254: PUSH
40255: LD_INT 2
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PPUSH
40262: CALL_OW 72
40266: NOT
40267: OR
40268: IFFALSE 40272
// continue ;
40270: GO 40165
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40272: LD_ADDR_VAR 0 9
40276: PUSH
40277: LD_EXP 50
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 30
40290: PUSH
40291: LD_INT 36
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PPUSH
40298: CALL_OW 72
40302: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40303: LD_ADDR_VAR 0 10
40307: PUSH
40308: LD_EXP 69
40312: PUSH
40313: LD_VAR 0 2
40317: ARRAY
40318: PPUSH
40319: LD_INT 34
40321: PUSH
40322: LD_INT 31
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL_OW 72
40333: ST_TO_ADDR
// if not cts and not mcts then
40334: LD_VAR 0 9
40338: NOT
40339: PUSH
40340: LD_VAR 0 10
40344: NOT
40345: AND
40346: IFFALSE 40350
// continue ;
40348: GO 40165
// x := cts ;
40350: LD_ADDR_VAR 0 11
40354: PUSH
40355: LD_VAR 0 9
40359: ST_TO_ADDR
// if not x then
40360: LD_VAR 0 11
40364: NOT
40365: IFFALSE 40377
// x := mcts ;
40367: LD_ADDR_VAR 0 11
40371: PUSH
40372: LD_VAR 0 10
40376: ST_TO_ADDR
// if not x then
40377: LD_VAR 0 11
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40165
// if mc_remote_driver [ i ] then
40386: LD_EXP 90
40390: PUSH
40391: LD_VAR 0 2
40395: ARRAY
40396: IFFALSE 40783
// for j in mc_remote_driver [ i ] do
40398: LD_ADDR_VAR 0 3
40402: PUSH
40403: LD_EXP 90
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: PUSH
40414: FOR_IN
40415: IFFALSE 40781
// begin if GetClass ( j ) <> 3 then
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 257
40426: PUSH
40427: LD_INT 3
40429: NONEQUAL
40430: IFFALSE 40483
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40432: LD_ADDR_EXP 90
40436: PUSH
40437: LD_EXP 90
40441: PPUSH
40442: LD_VAR 0 2
40446: PPUSH
40447: LD_EXP 90
40451: PUSH
40452: LD_VAR 0 2
40456: ARRAY
40457: PUSH
40458: LD_VAR 0 3
40462: DIFF
40463: PPUSH
40464: CALL_OW 1
40468: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40469: LD_VAR 0 3
40473: PPUSH
40474: LD_INT 0
40476: PPUSH
40477: CALL_OW 109
// continue ;
40481: GO 40414
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40483: LD_EXP 69
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PPUSH
40494: LD_INT 34
40496: PUSH
40497: LD_INT 31
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 58
40506: PUSH
40507: EMPTY
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 72
40518: PUSH
40519: LD_VAR 0 3
40523: PPUSH
40524: CALL 84043 0 1
40528: NOT
40529: AND
40530: IFFALSE 40601
// begin if IsInUnit ( j ) then
40532: LD_VAR 0 3
40536: PPUSH
40537: CALL_OW 310
40541: IFFALSE 40552
// ComExitBuilding ( j ) ;
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40552: LD_VAR 0 3
40556: PPUSH
40557: LD_EXP 69
40561: PUSH
40562: LD_VAR 0 2
40566: ARRAY
40567: PPUSH
40568: LD_INT 34
40570: PUSH
40571: LD_INT 31
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 58
40580: PUSH
40581: EMPTY
40582: LIST
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PPUSH
40588: CALL_OW 72
40592: PUSH
40593: LD_INT 1
40595: ARRAY
40596: PPUSH
40597: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40601: LD_VAR 0 3
40605: PPUSH
40606: CALL_OW 310
40610: NOT
40611: PUSH
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: PPUSH
40622: CALL_OW 266
40626: PUSH
40627: LD_INT 36
40629: NONEQUAL
40630: PUSH
40631: LD_VAR 0 3
40635: PPUSH
40636: CALL 84043 0 1
40640: NOT
40641: AND
40642: OR
40643: IFFALSE 40779
// begin if IsInUnit ( j ) then
40645: LD_VAR 0 3
40649: PPUSH
40650: CALL_OW 310
40654: IFFALSE 40665
// ComExitBuilding ( j ) ;
40656: LD_VAR 0 3
40660: PPUSH
40661: CALL_OW 122
// ct := 0 ;
40665: LD_ADDR_VAR 0 8
40669: PUSH
40670: LD_INT 0
40672: ST_TO_ADDR
// for k in x do
40673: LD_ADDR_VAR 0 4
40677: PUSH
40678: LD_VAR 0 11
40682: PUSH
40683: FOR_IN
40684: IFFALSE 40757
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40686: LD_VAR 0 4
40690: PPUSH
40691: CALL_OW 264
40695: PUSH
40696: LD_INT 31
40698: EQUAL
40699: PUSH
40700: LD_VAR 0 4
40704: PPUSH
40705: CALL_OW 311
40709: NOT
40710: AND
40711: PUSH
40712: LD_VAR 0 4
40716: PPUSH
40717: CALL_OW 266
40721: PUSH
40722: LD_INT 36
40724: EQUAL
40725: PUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: CALL_OW 313
40735: PUSH
40736: LD_INT 3
40738: LESS
40739: AND
40740: OR
40741: IFFALSE 40755
// begin ct := k ;
40743: LD_ADDR_VAR 0 8
40747: PUSH
40748: LD_VAR 0 4
40752: ST_TO_ADDR
// break ;
40753: GO 40757
// end ;
40755: GO 40683
40757: POP
40758: POP
// if ct then
40759: LD_VAR 0 8
40763: IFFALSE 40779
// ComEnterUnit ( j , ct ) ;
40765: LD_VAR 0 3
40769: PPUSH
40770: LD_VAR 0 8
40774: PPUSH
40775: CALL_OW 120
// end ; end ;
40779: GO 40414
40781: POP
40782: POP
// places := 0 ;
40783: LD_ADDR_VAR 0 5
40787: PUSH
40788: LD_INT 0
40790: ST_TO_ADDR
// for j = 1 to x do
40791: LD_ADDR_VAR 0 3
40795: PUSH
40796: DOUBLE
40797: LD_INT 1
40799: DEC
40800: ST_TO_ADDR
40801: LD_VAR 0 11
40805: PUSH
40806: FOR_TO
40807: IFFALSE 40883
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40809: LD_VAR 0 11
40813: PUSH
40814: LD_VAR 0 3
40818: ARRAY
40819: PPUSH
40820: CALL_OW 264
40824: PUSH
40825: LD_INT 31
40827: EQUAL
40828: IFFALSE 40846
// places := places + 1 else
40830: LD_ADDR_VAR 0 5
40834: PUSH
40835: LD_VAR 0 5
40839: PUSH
40840: LD_INT 1
40842: PLUS
40843: ST_TO_ADDR
40844: GO 40881
// if GetBType ( x [ j ] ) = b_control_tower then
40846: LD_VAR 0 11
40850: PUSH
40851: LD_VAR 0 3
40855: ARRAY
40856: PPUSH
40857: CALL_OW 266
40861: PUSH
40862: LD_INT 36
40864: EQUAL
40865: IFFALSE 40881
// places := places + 3 ;
40867: LD_ADDR_VAR 0 5
40871: PUSH
40872: LD_VAR 0 5
40876: PUSH
40877: LD_INT 3
40879: PLUS
40880: ST_TO_ADDR
40881: GO 40806
40883: POP
40884: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40885: LD_VAR 0 5
40889: PUSH
40890: LD_INT 0
40892: EQUAL
40893: PUSH
40894: LD_VAR 0 5
40898: PUSH
40899: LD_EXP 90
40903: PUSH
40904: LD_VAR 0 2
40908: ARRAY
40909: LESSEQUAL
40910: OR
40911: IFFALSE 40915
// continue ;
40913: GO 40165
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40915: LD_ADDR_VAR 0 6
40919: PUSH
40920: LD_EXP 50
40924: PUSH
40925: LD_VAR 0 2
40929: ARRAY
40930: PPUSH
40931: LD_INT 25
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PPUSH
40941: CALL_OW 72
40945: PUSH
40946: LD_EXP 90
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: DIFF
40957: PPUSH
40958: LD_INT 3
40960: PPUSH
40961: CALL 84943 0 2
40965: ST_TO_ADDR
// for j in tmp do
40966: LD_ADDR_VAR 0 3
40970: PUSH
40971: LD_VAR 0 6
40975: PUSH
40976: FOR_IN
40977: IFFALSE 41012
// if GetTag ( j ) > 0 then
40979: LD_VAR 0 3
40983: PPUSH
40984: CALL_OW 110
40988: PUSH
40989: LD_INT 0
40991: GREATER
40992: IFFALSE 41010
// tmp := tmp diff j ;
40994: LD_ADDR_VAR 0 6
40998: PUSH
40999: LD_VAR 0 6
41003: PUSH
41004: LD_VAR 0 3
41008: DIFF
41009: ST_TO_ADDR
41010: GO 40976
41012: POP
41013: POP
// if not tmp then
41014: LD_VAR 0 6
41018: NOT
41019: IFFALSE 41023
// continue ;
41021: GO 40165
// if places then
41023: LD_VAR 0 5
41027: IFFALSE 41086
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41029: LD_ADDR_EXP 90
41033: PUSH
41034: LD_EXP 90
41038: PPUSH
41039: LD_VAR 0 2
41043: PPUSH
41044: LD_EXP 90
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PUSH
41055: LD_VAR 0 6
41059: PUSH
41060: LD_INT 1
41062: ARRAY
41063: UNION
41064: PPUSH
41065: CALL_OW 1
41069: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41070: LD_VAR 0 6
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: LD_INT 126
41081: PPUSH
41082: CALL_OW 109
// end ; end ;
41086: GO 40165
41088: POP
41089: POP
// end ;
41090: LD_VAR 0 1
41094: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41095: LD_INT 0
41097: PPUSH
41098: PPUSH
41099: PPUSH
41100: PPUSH
41101: PPUSH
41102: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41103: LD_VAR 0 1
41107: NOT
41108: PUSH
41109: LD_VAR 0 2
41113: NOT
41114: OR
41115: PUSH
41116: LD_VAR 0 3
41120: NOT
41121: OR
41122: PUSH
41123: LD_VAR 0 4
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 5
41142: PUSH
41143: LD_INT 8
41145: PUSH
41146: LD_INT 9
41148: PUSH
41149: LD_INT 15
41151: PUSH
41152: LD_INT 16
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: IN
41166: NOT
41167: OR
41168: IFFALSE 41172
// exit ;
41170: GO 42030
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41172: LD_ADDR_VAR 0 2
41176: PUSH
41177: LD_VAR 0 2
41181: PPUSH
41182: LD_INT 21
41184: PUSH
41185: LD_INT 3
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 24
41194: PUSH
41195: LD_INT 250
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PPUSH
41206: CALL_OW 72
41210: ST_TO_ADDR
// case class of 1 , 15 :
41211: LD_VAR 0 4
41215: PUSH
41216: LD_INT 1
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41230
41222: LD_INT 15
41224: DOUBLE
41225: EQUAL
41226: IFTRUE 41230
41228: GO 41315
41230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41231: LD_ADDR_VAR 0 8
41235: PUSH
41236: LD_VAR 0 2
41240: PPUSH
41241: LD_INT 2
41243: PUSH
41244: LD_INT 30
41246: PUSH
41247: LD_INT 32
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 30
41256: PUSH
41257: LD_INT 31
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL_OW 72
41273: PUSH
41274: LD_VAR 0 2
41278: PPUSH
41279: LD_INT 2
41281: PUSH
41282: LD_INT 30
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 5
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: ADD
41312: ST_TO_ADDR
41313: GO 41561
41315: LD_INT 2
41317: DOUBLE
41318: EQUAL
41319: IFTRUE 41329
41321: LD_INT 16
41323: DOUBLE
41324: EQUAL
41325: IFTRUE 41329
41327: GO 41375
41329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41330: LD_ADDR_VAR 0 8
41334: PUSH
41335: LD_VAR 0 2
41339: PPUSH
41340: LD_INT 2
41342: PUSH
41343: LD_INT 30
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 30
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: LIST
41367: PPUSH
41368: CALL_OW 72
41372: ST_TO_ADDR
41373: GO 41561
41375: LD_INT 3
41377: DOUBLE
41378: EQUAL
41379: IFTRUE 41383
41381: GO 41429
41383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41384: LD_ADDR_VAR 0 8
41388: PUSH
41389: LD_VAR 0 2
41393: PPUSH
41394: LD_INT 2
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 2
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 3
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL_OW 72
41426: ST_TO_ADDR
41427: GO 41561
41429: LD_INT 4
41431: DOUBLE
41432: EQUAL
41433: IFTRUE 41437
41435: GO 41494
41437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41438: LD_ADDR_VAR 0 8
41442: PUSH
41443: LD_VAR 0 2
41447: PPUSH
41448: LD_INT 2
41450: PUSH
41451: LD_INT 30
41453: PUSH
41454: LD_INT 6
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 30
41463: PUSH
41464: LD_INT 7
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 8
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: PPUSH
41487: CALL_OW 72
41491: ST_TO_ADDR
41492: GO 41561
41494: LD_INT 5
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41514
41500: LD_INT 8
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41514
41506: LD_INT 9
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41514
41512: GO 41560
41514: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41515: LD_ADDR_VAR 0 8
41519: PUSH
41520: LD_VAR 0 2
41524: PPUSH
41525: LD_INT 2
41527: PUSH
41528: LD_INT 30
41530: PUSH
41531: LD_INT 4
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 30
41540: PUSH
41541: LD_INT 5
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: LIST
41552: PPUSH
41553: CALL_OW 72
41557: ST_TO_ADDR
41558: GO 41561
41560: POP
// if not tmp then
41561: LD_VAR 0 8
41565: NOT
41566: IFFALSE 41570
// exit ;
41568: GO 42030
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41570: LD_VAR 0 4
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 15
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: IN
41585: PUSH
41586: LD_EXP 59
41590: PUSH
41591: LD_VAR 0 1
41595: ARRAY
41596: AND
41597: IFFALSE 41753
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41599: LD_ADDR_VAR 0 9
41603: PUSH
41604: LD_EXP 59
41608: PUSH
41609: LD_VAR 0 1
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41619: LD_VAR 0 9
41623: PUSH
41624: LD_EXP 60
41628: PUSH
41629: LD_VAR 0 1
41633: ARRAY
41634: IN
41635: NOT
41636: IFFALSE 41751
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41638: LD_ADDR_EXP 60
41642: PUSH
41643: LD_EXP 60
41647: PPUSH
41648: LD_VAR 0 1
41652: PUSH
41653: LD_EXP 60
41657: PUSH
41658: LD_VAR 0 1
41662: ARRAY
41663: PUSH
41664: LD_INT 1
41666: PLUS
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PPUSH
41672: LD_VAR 0 9
41676: PPUSH
41677: CALL 54067 0 3
41681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41682: LD_ADDR_EXP 59
41686: PUSH
41687: LD_EXP 59
41691: PPUSH
41692: LD_VAR 0 1
41696: PPUSH
41697: LD_EXP 59
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PUSH
41708: LD_VAR 0 9
41712: DIFF
41713: PPUSH
41714: CALL_OW 1
41718: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41719: LD_VAR 0 3
41723: PPUSH
41724: LD_EXP 60
41728: PUSH
41729: LD_VAR 0 1
41733: ARRAY
41734: PUSH
41735: LD_EXP 60
41739: PUSH
41740: LD_VAR 0 1
41744: ARRAY
41745: ARRAY
41746: PPUSH
41747: CALL_OW 120
// end ; exit ;
41751: GO 42030
// end ; if tmp > 1 then
41753: LD_VAR 0 8
41757: PUSH
41758: LD_INT 1
41760: GREATER
41761: IFFALSE 41865
// for i = 2 to tmp do
41763: LD_ADDR_VAR 0 6
41767: PUSH
41768: DOUBLE
41769: LD_INT 2
41771: DEC
41772: ST_TO_ADDR
41773: LD_VAR 0 8
41777: PUSH
41778: FOR_TO
41779: IFFALSE 41863
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41781: LD_VAR 0 8
41785: PUSH
41786: LD_VAR 0 6
41790: ARRAY
41791: PPUSH
41792: CALL_OW 461
41796: PUSH
41797: LD_INT 6
41799: EQUAL
41800: IFFALSE 41861
// begin x := tmp [ i ] ;
41802: LD_ADDR_VAR 0 9
41806: PUSH
41807: LD_VAR 0 8
41811: PUSH
41812: LD_VAR 0 6
41816: ARRAY
41817: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41818: LD_ADDR_VAR 0 8
41822: PUSH
41823: LD_VAR 0 8
41827: PPUSH
41828: LD_VAR 0 6
41832: PPUSH
41833: CALL_OW 3
41837: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41838: LD_ADDR_VAR 0 8
41842: PUSH
41843: LD_VAR 0 8
41847: PPUSH
41848: LD_INT 1
41850: PPUSH
41851: LD_VAR 0 9
41855: PPUSH
41856: CALL_OW 2
41860: ST_TO_ADDR
// end ;
41861: GO 41778
41863: POP
41864: POP
// for i in tmp do
41865: LD_ADDR_VAR 0 6
41869: PUSH
41870: LD_VAR 0 8
41874: PUSH
41875: FOR_IN
41876: IFFALSE 41903
// begin if IsNotFull ( i ) then
41878: LD_VAR 0 6
41882: PPUSH
41883: CALL 51289 0 1
41887: IFFALSE 41901
// begin j := i ;
41889: LD_ADDR_VAR 0 7
41893: PUSH
41894: LD_VAR 0 6
41898: ST_TO_ADDR
// break ;
41899: GO 41903
// end ; end ;
41901: GO 41875
41903: POP
41904: POP
// if j then
41905: LD_VAR 0 7
41909: IFFALSE 41927
// ComEnterUnit ( unit , j ) else
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 7
41920: PPUSH
41921: CALL_OW 120
41925: GO 42030
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41927: LD_ADDR_VAR 0 10
41931: PUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: LD_INT 2
41939: PUSH
41940: LD_INT 30
41942: PUSH
41943: LD_INT 0
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 30
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: LIST
41964: PPUSH
41965: CALL_OW 72
41969: ST_TO_ADDR
// if depot then
41970: LD_VAR 0 10
41974: IFFALSE 42030
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41976: LD_ADDR_VAR 0 10
41980: PUSH
41981: LD_VAR 0 10
41985: PPUSH
41986: LD_VAR 0 3
41990: PPUSH
41991: CALL_OW 74
41995: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41996: LD_VAR 0 3
42000: PPUSH
42001: LD_VAR 0 10
42005: PPUSH
42006: CALL_OW 296
42010: PUSH
42011: LD_INT 10
42013: GREATER
42014: IFFALSE 42030
// ComStandNearbyBuilding ( unit , depot ) ;
42016: LD_VAR 0 3
42020: PPUSH
42021: LD_VAR 0 10
42025: PPUSH
42026: CALL 50669 0 2
// end ; end ; end ;
42030: LD_VAR 0 5
42034: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42035: LD_INT 0
42037: PPUSH
42038: PPUSH
42039: PPUSH
42040: PPUSH
// if not mc_bases then
42041: LD_EXP 50
42045: NOT
42046: IFFALSE 42050
// exit ;
42048: GO 42289
// for i = 1 to mc_bases do
42050: LD_ADDR_VAR 0 2
42054: PUSH
42055: DOUBLE
42056: LD_INT 1
42058: DEC
42059: ST_TO_ADDR
42060: LD_EXP 50
42064: PUSH
42065: FOR_TO
42066: IFFALSE 42287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42068: LD_ADDR_VAR 0 4
42072: PUSH
42073: LD_EXP 50
42077: PUSH
42078: LD_VAR 0 2
42082: ARRAY
42083: PPUSH
42084: LD_INT 21
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PPUSH
42094: CALL_OW 72
42098: PUSH
42099: LD_EXP 79
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: UNION
42110: ST_TO_ADDR
// if not tmp then
42111: LD_VAR 0 4
42115: NOT
42116: IFFALSE 42120
// continue ;
42118: GO 42065
// for j in tmp do
42120: LD_ADDR_VAR 0 3
42124: PUSH
42125: LD_VAR 0 4
42129: PUSH
42130: FOR_IN
42131: IFFALSE 42283
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42133: LD_VAR 0 3
42137: PPUSH
42138: CALL_OW 110
42142: NOT
42143: PUSH
42144: LD_VAR 0 3
42148: PPUSH
42149: CALL_OW 314
42153: NOT
42154: AND
42155: PUSH
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 311
42165: NOT
42166: AND
42167: PUSH
42168: LD_VAR 0 3
42172: PPUSH
42173: CALL_OW 310
42177: NOT
42178: AND
42179: PUSH
42180: LD_VAR 0 3
42184: PUSH
42185: LD_EXP 53
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: IN
42200: NOT
42201: AND
42202: PUSH
42203: LD_VAR 0 3
42207: PUSH
42208: LD_EXP 53
42212: PUSH
42213: LD_VAR 0 2
42217: ARRAY
42218: PUSH
42219: LD_INT 2
42221: ARRAY
42222: IN
42223: NOT
42224: AND
42225: PUSH
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 62
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: NOT
42243: AND
42244: IFFALSE 42281
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42246: LD_VAR 0 2
42250: PPUSH
42251: LD_EXP 50
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PPUSH
42262: LD_VAR 0 3
42266: PPUSH
42267: LD_VAR 0 3
42271: PPUSH
42272: CALL_OW 257
42276: PPUSH
42277: CALL 41095 0 4
// end ;
42281: GO 42130
42283: POP
42284: POP
// end ;
42285: GO 42065
42287: POP
42288: POP
// end ;
42289: LD_VAR 0 1
42293: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
42298: PPUSH
42299: PPUSH
42300: PPUSH
42301: PPUSH
// if not mc_bases [ base ] then
42302: LD_EXP 50
42306: PUSH
42307: LD_VAR 0 1
42311: ARRAY
42312: NOT
42313: IFFALSE 42317
// exit ;
42315: GO 42518
// tmp := [ ] ;
42317: LD_ADDR_VAR 0 6
42321: PUSH
42322: EMPTY
42323: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42324: LD_ADDR_VAR 0 7
42328: PUSH
42329: LD_VAR 0 3
42333: PPUSH
42334: LD_INT 0
42336: PPUSH
42337: CALL_OW 517
42341: ST_TO_ADDR
// if not list then
42342: LD_VAR 0 7
42346: NOT
42347: IFFALSE 42351
// exit ;
42349: GO 42518
// c := Count ( list [ 1 ] ) ;
42351: LD_ADDR_VAR 0 9
42355: PUSH
42356: LD_VAR 0 7
42360: PUSH
42361: LD_INT 1
42363: ARRAY
42364: PPUSH
42365: CALL 51207 0 1
42369: ST_TO_ADDR
// if amount > c then
42370: LD_VAR 0 2
42374: PUSH
42375: LD_VAR 0 9
42379: GREATER
42380: IFFALSE 42392
// amount := c ;
42382: LD_ADDR_VAR 0 2
42386: PUSH
42387: LD_VAR 0 9
42391: ST_TO_ADDR
// for i := 1 to amount do
42392: LD_ADDR_VAR 0 5
42396: PUSH
42397: DOUBLE
42398: LD_INT 1
42400: DEC
42401: ST_TO_ADDR
42402: LD_VAR 0 2
42406: PUSH
42407: FOR_TO
42408: IFFALSE 42466
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42410: LD_ADDR_VAR 0 6
42414: PUSH
42415: LD_VAR 0 6
42419: PPUSH
42420: LD_VAR 0 5
42424: PPUSH
42425: LD_VAR 0 7
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 5
42438: ARRAY
42439: PUSH
42440: LD_VAR 0 7
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 5
42453: ARRAY
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PPUSH
42459: CALL_OW 1
42463: ST_TO_ADDR
42464: GO 42407
42466: POP
42467: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42468: LD_ADDR_EXP 63
42472: PUSH
42473: LD_EXP 63
42477: PPUSH
42478: LD_VAR 0 1
42482: PPUSH
42483: LD_VAR 0 6
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42493: LD_ADDR_EXP 65
42497: PUSH
42498: LD_EXP 65
42502: PPUSH
42503: LD_VAR 0 1
42507: PPUSH
42508: LD_VAR 0 3
42512: PPUSH
42513: CALL_OW 1
42517: ST_TO_ADDR
// end ;
42518: LD_VAR 0 4
42522: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42523: LD_INT 0
42525: PPUSH
// if not mc_bases [ base ] then
42526: LD_EXP 50
42530: PUSH
42531: LD_VAR 0 1
42535: ARRAY
42536: NOT
42537: IFFALSE 42541
// exit ;
42539: GO 42566
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42541: LD_ADDR_EXP 55
42545: PUSH
42546: LD_EXP 55
42550: PPUSH
42551: LD_VAR 0 1
42555: PPUSH
42556: LD_VAR 0 2
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// end ;
42566: LD_VAR 0 3
42570: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42571: LD_INT 0
42573: PPUSH
// if not mc_bases [ base ] then
42574: LD_EXP 50
42578: PUSH
42579: LD_VAR 0 1
42583: ARRAY
42584: NOT
42585: IFFALSE 42589
// exit ;
42587: GO 42626
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42589: LD_ADDR_EXP 55
42593: PUSH
42594: LD_EXP 55
42598: PPUSH
42599: LD_VAR 0 1
42603: PPUSH
42604: LD_EXP 55
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: PUSH
42615: LD_VAR 0 2
42619: UNION
42620: PPUSH
42621: CALL_OW 1
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42631: LD_INT 0
42633: PPUSH
// if not mc_bases [ base ] then
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42674
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42649: LD_ADDR_EXP 71
42653: PUSH
42654: LD_EXP 71
42658: PPUSH
42659: LD_VAR 0 1
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ;
42674: LD_VAR 0 3
42678: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42679: LD_INT 0
42681: PPUSH
// if not mc_bases [ base ] then
42682: LD_EXP 50
42686: PUSH
42687: LD_VAR 0 1
42691: ARRAY
42692: NOT
42693: IFFALSE 42697
// exit ;
42695: GO 42734
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42697: LD_ADDR_EXP 71
42701: PUSH
42702: LD_EXP 71
42706: PPUSH
42707: LD_VAR 0 1
42711: PPUSH
42712: LD_EXP 71
42716: PUSH
42717: LD_VAR 0 1
42721: ARRAY
42722: PUSH
42723: LD_VAR 0 2
42727: ADD
42728: PPUSH
42729: CALL_OW 1
42733: ST_TO_ADDR
// end ;
42734: LD_VAR 0 3
42738: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42739: LD_INT 0
42741: PPUSH
// if not mc_bases [ base ] then
42742: LD_EXP 50
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: NOT
42753: IFFALSE 42757
// exit ;
42755: GO 42811
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42757: LD_ADDR_EXP 72
42761: PUSH
42762: LD_EXP 72
42766: PPUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: LD_VAR 0 2
42776: PPUSH
42777: CALL_OW 1
42781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42782: LD_ADDR_EXP 61
42786: PUSH
42787: LD_EXP 61
42791: PPUSH
42792: LD_VAR 0 1
42796: PPUSH
42797: LD_VAR 0 2
42801: PUSH
42802: LD_INT 0
42804: PLUS
42805: PPUSH
42806: CALL_OW 1
42810: ST_TO_ADDR
// end ;
42811: LD_VAR 0 3
42815: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42816: LD_INT 0
42818: PPUSH
// if not mc_bases [ base ] then
42819: LD_EXP 50
42823: PUSH
42824: LD_VAR 0 1
42828: ARRAY
42829: NOT
42830: IFFALSE 42834
// exit ;
42832: GO 42859
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42834: LD_ADDR_EXP 61
42838: PUSH
42839: LD_EXP 61
42843: PPUSH
42844: LD_VAR 0 1
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: CALL_OW 1
42858: ST_TO_ADDR
// end ;
42859: LD_VAR 0 3
42863: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42864: LD_INT 0
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
// if not mc_bases [ base ] then
42870: LD_EXP 50
42874: PUSH
42875: LD_VAR 0 1
42879: ARRAY
42880: NOT
42881: IFFALSE 42885
// exit ;
42883: GO 42950
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42885: LD_ADDR_EXP 70
42889: PUSH
42890: LD_EXP 70
42894: PPUSH
42895: LD_VAR 0 1
42899: PUSH
42900: LD_EXP 70
42904: PUSH
42905: LD_VAR 0 1
42909: ARRAY
42910: PUSH
42911: LD_INT 1
42913: PLUS
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PPUSH
42919: LD_VAR 0 1
42923: PUSH
42924: LD_VAR 0 2
42928: PUSH
42929: LD_VAR 0 3
42933: PUSH
42934: LD_VAR 0 4
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: PPUSH
42945: CALL 54067 0 3
42949: ST_TO_ADDR
// end ;
42950: LD_VAR 0 5
42954: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42955: LD_INT 0
42957: PPUSH
// if not mc_bases [ base ] then
42958: LD_EXP 50
42962: PUSH
42963: LD_VAR 0 1
42967: ARRAY
42968: NOT
42969: IFFALSE 42973
// exit ;
42971: GO 42998
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42973: LD_ADDR_EXP 87
42977: PUSH
42978: LD_EXP 87
42982: PPUSH
42983: LD_VAR 0 1
42987: PPUSH
42988: LD_VAR 0 2
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MC_GetMinesField ( base ) ; begin
43003: LD_INT 0
43005: PPUSH
// result := mc_mines [ base ] ;
43006: LD_ADDR_VAR 0 2
43010: PUSH
43011: LD_EXP 63
43015: PUSH
43016: LD_VAR 0 1
43020: ARRAY
43021: ST_TO_ADDR
// end ;
43022: LD_VAR 0 2
43026: RET
// export function MC_GetProduceList ( base ) ; begin
43027: LD_INT 0
43029: PPUSH
// result := mc_produce [ base ] ;
43030: LD_ADDR_VAR 0 2
43034: PUSH
43035: LD_EXP 71
43039: PUSH
43040: LD_VAR 0 1
43044: ARRAY
43045: ST_TO_ADDR
// end ;
43046: LD_VAR 0 2
43050: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43051: LD_INT 0
43053: PPUSH
43054: PPUSH
// if not mc_bases then
43055: LD_EXP 50
43059: NOT
43060: IFFALSE 43064
// exit ;
43062: GO 43129
// if mc_bases [ base ] then
43064: LD_EXP 50
43068: PUSH
43069: LD_VAR 0 1
43073: ARRAY
43074: IFFALSE 43129
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43076: LD_ADDR_VAR 0 3
43080: PUSH
43081: LD_EXP 50
43085: PUSH
43086: LD_VAR 0 1
43090: ARRAY
43091: PPUSH
43092: LD_INT 30
43094: PUSH
43095: LD_VAR 0 2
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PPUSH
43104: CALL_OW 72
43108: ST_TO_ADDR
// if result then
43109: LD_VAR 0 3
43113: IFFALSE 43129
// result := result [ 1 ] ;
43115: LD_ADDR_VAR 0 3
43119: PUSH
43120: LD_VAR 0 3
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: ST_TO_ADDR
// end ; end ;
43129: LD_VAR 0 3
43133: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43134: LD_INT 0
43136: PPUSH
43137: PPUSH
// if not mc_bases then
43138: LD_EXP 50
43142: NOT
43143: IFFALSE 43147
// exit ;
43145: GO 43192
// if mc_bases [ base ] then
43147: LD_EXP 50
43151: PUSH
43152: LD_VAR 0 1
43156: ARRAY
43157: IFFALSE 43192
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43159: LD_ADDR_VAR 0 3
43163: PUSH
43164: LD_EXP 50
43168: PUSH
43169: LD_VAR 0 1
43173: ARRAY
43174: PPUSH
43175: LD_INT 30
43177: PUSH
43178: LD_VAR 0 2
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// end ;
43192: LD_VAR 0 3
43196: RET
// export function MC_SetTame ( base , area ) ; begin
43197: LD_INT 0
43199: PPUSH
// if not mc_bases or not base then
43200: LD_EXP 50
43204: NOT
43205: PUSH
43206: LD_VAR 0 1
43210: NOT
43211: OR
43212: IFFALSE 43216
// exit ;
43214: GO 43241
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43216: LD_ADDR_EXP 78
43220: PUSH
43221: LD_EXP 78
43225: PPUSH
43226: LD_VAR 0 1
43230: PPUSH
43231: LD_VAR 0 2
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// end ;
43241: LD_VAR 0 3
43245: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
// if not mc_bases or not base then
43250: LD_EXP 50
43254: NOT
43255: PUSH
43256: LD_VAR 0 1
43260: NOT
43261: OR
43262: IFFALSE 43266
// exit ;
43264: GO 43368
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43266: LD_ADDR_VAR 0 4
43270: PUSH
43271: LD_EXP 50
43275: PUSH
43276: LD_VAR 0 1
43280: ARRAY
43281: PPUSH
43282: LD_INT 30
43284: PUSH
43285: LD_VAR 0 2
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PPUSH
43294: CALL_OW 72
43298: ST_TO_ADDR
// if not tmp then
43299: LD_VAR 0 4
43303: NOT
43304: IFFALSE 43308
// exit ;
43306: GO 43368
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43308: LD_ADDR_EXP 82
43312: PUSH
43313: LD_EXP 82
43317: PPUSH
43318: LD_VAR 0 1
43322: PPUSH
43323: LD_EXP 82
43327: PUSH
43328: LD_VAR 0 1
43332: ARRAY
43333: PPUSH
43334: LD_EXP 82
43338: PUSH
43339: LD_VAR 0 1
43343: ARRAY
43344: PUSH
43345: LD_INT 1
43347: PLUS
43348: PPUSH
43349: LD_VAR 0 4
43353: PUSH
43354: LD_INT 1
43356: ARRAY
43357: PPUSH
43358: CALL_OW 2
43362: PPUSH
43363: CALL_OW 1
43367: ST_TO_ADDR
// end ;
43368: LD_VAR 0 3
43372: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43373: LD_INT 0
43375: PPUSH
43376: PPUSH
// if not mc_bases or not base or not kinds then
43377: LD_EXP 50
43381: NOT
43382: PUSH
43383: LD_VAR 0 1
43387: NOT
43388: OR
43389: PUSH
43390: LD_VAR 0 2
43394: NOT
43395: OR
43396: IFFALSE 43400
// exit ;
43398: GO 43461
// for i in kinds do
43400: LD_ADDR_VAR 0 4
43404: PUSH
43405: LD_VAR 0 2
43409: PUSH
43410: FOR_IN
43411: IFFALSE 43459
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43413: LD_ADDR_EXP 84
43417: PUSH
43418: LD_EXP 84
43422: PPUSH
43423: LD_VAR 0 1
43427: PUSH
43428: LD_EXP 84
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: PUSH
43439: LD_INT 1
43441: PLUS
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PPUSH
43447: LD_VAR 0 4
43451: PPUSH
43452: CALL 54067 0 3
43456: ST_TO_ADDR
43457: GO 43410
43459: POP
43460: POP
// end ;
43461: LD_VAR 0 3
43465: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43466: LD_INT 0
43468: PPUSH
// if not mc_bases or not base or not areas then
43469: LD_EXP 50
43473: NOT
43474: PUSH
43475: LD_VAR 0 1
43479: NOT
43480: OR
43481: PUSH
43482: LD_VAR 0 2
43486: NOT
43487: OR
43488: IFFALSE 43492
// exit ;
43490: GO 43517
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43492: LD_ADDR_EXP 68
43496: PUSH
43497: LD_EXP 68
43501: PPUSH
43502: LD_VAR 0 1
43506: PPUSH
43507: LD_VAR 0 2
43511: PPUSH
43512: CALL_OW 1
43516: ST_TO_ADDR
// end ;
43517: LD_VAR 0 3
43521: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43522: LD_INT 0
43524: PPUSH
// if not mc_bases or not base or not teleports_exit then
43525: LD_EXP 50
43529: NOT
43530: PUSH
43531: LD_VAR 0 1
43535: NOT
43536: OR
43537: PUSH
43538: LD_VAR 0 2
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43573
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43548: LD_ADDR_EXP 85
43552: PUSH
43553: LD_EXP 85
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_VAR 0 2
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// end ;
43573: LD_VAR 0 3
43577: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43578: LD_INT 0
43580: PPUSH
43581: PPUSH
43582: PPUSH
// if not mc_bases or not base or not ext_list then
43583: LD_EXP 50
43587: NOT
43588: PUSH
43589: LD_VAR 0 1
43593: NOT
43594: OR
43595: PUSH
43596: LD_VAR 0 5
43600: NOT
43601: OR
43602: IFFALSE 43606
// exit ;
43604: GO 43779
// tmp := GetFacExtXYD ( x , y , d ) ;
43606: LD_ADDR_VAR 0 8
43610: PUSH
43611: LD_VAR 0 2
43615: PPUSH
43616: LD_VAR 0 3
43620: PPUSH
43621: LD_VAR 0 4
43625: PPUSH
43626: CALL 84073 0 3
43630: ST_TO_ADDR
// if not tmp then
43631: LD_VAR 0 8
43635: NOT
43636: IFFALSE 43640
// exit ;
43638: GO 43779
// for i in tmp do
43640: LD_ADDR_VAR 0 7
43644: PUSH
43645: LD_VAR 0 8
43649: PUSH
43650: FOR_IN
43651: IFFALSE 43777
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43653: LD_ADDR_EXP 55
43657: PUSH
43658: LD_EXP 55
43662: PPUSH
43663: LD_VAR 0 1
43667: PPUSH
43668: LD_EXP 55
43672: PUSH
43673: LD_VAR 0 1
43677: ARRAY
43678: PPUSH
43679: LD_EXP 55
43683: PUSH
43684: LD_VAR 0 1
43688: ARRAY
43689: PUSH
43690: LD_INT 1
43692: PLUS
43693: PPUSH
43694: LD_VAR 0 5
43698: PUSH
43699: LD_INT 1
43701: ARRAY
43702: PUSH
43703: LD_VAR 0 7
43707: PUSH
43708: LD_INT 1
43710: ARRAY
43711: PUSH
43712: LD_VAR 0 7
43716: PUSH
43717: LD_INT 2
43719: ARRAY
43720: PUSH
43721: LD_VAR 0 7
43725: PUSH
43726: LD_INT 3
43728: ARRAY
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: PPUSH
43736: CALL_OW 2
43740: PPUSH
43741: CALL_OW 1
43745: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43746: LD_ADDR_VAR 0 5
43750: PUSH
43751: LD_VAR 0 5
43755: PPUSH
43756: LD_INT 1
43758: PPUSH
43759: CALL_OW 3
43763: ST_TO_ADDR
// if not ext_list then
43764: LD_VAR 0 5
43768: NOT
43769: IFFALSE 43775
// exit ;
43771: POP
43772: POP
43773: GO 43779
// end ;
43775: GO 43650
43777: POP
43778: POP
// end ;
43779: LD_VAR 0 6
43783: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43784: LD_INT 0
43786: PPUSH
// if not mc_bases or not base or not weapon_list then
43787: LD_EXP 50
43791: NOT
43792: PUSH
43793: LD_VAR 0 1
43797: NOT
43798: OR
43799: PUSH
43800: LD_VAR 0 2
43804: NOT
43805: OR
43806: IFFALSE 43810
// exit ;
43808: GO 43835
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43810: LD_ADDR_EXP 89
43814: PUSH
43815: LD_EXP 89
43819: PPUSH
43820: LD_VAR 0 1
43824: PPUSH
43825: LD_VAR 0 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43840: LD_INT 0
43842: PPUSH
// if not mc_bases or not base or not tech_list then
43843: LD_EXP 50
43847: NOT
43848: PUSH
43849: LD_VAR 0 1
43853: NOT
43854: OR
43855: PUSH
43856: LD_VAR 0 2
43860: NOT
43861: OR
43862: IFFALSE 43866
// exit ;
43864: GO 43891
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43866: LD_ADDR_EXP 77
43870: PUSH
43871: LD_EXP 77
43875: PPUSH
43876: LD_VAR 0 1
43880: PPUSH
43881: LD_VAR 0 2
43885: PPUSH
43886: CALL_OW 1
43890: ST_TO_ADDR
// end ;
43891: LD_VAR 0 3
43895: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43896: LD_INT 0
43898: PPUSH
// if not mc_bases or not parking_area or not base then
43899: LD_EXP 50
43903: NOT
43904: PUSH
43905: LD_VAR 0 2
43909: NOT
43910: OR
43911: PUSH
43912: LD_VAR 0 1
43916: NOT
43917: OR
43918: IFFALSE 43922
// exit ;
43920: GO 43947
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43922: LD_ADDR_EXP 74
43926: PUSH
43927: LD_EXP 74
43931: PPUSH
43932: LD_VAR 0 1
43936: PPUSH
43937: LD_VAR 0 2
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// end ;
43947: LD_VAR 0 3
43951: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43952: LD_INT 0
43954: PPUSH
// if not mc_bases or not base or not scan_area then
43955: LD_EXP 50
43959: NOT
43960: PUSH
43961: LD_VAR 0 1
43965: NOT
43966: OR
43967: PUSH
43968: LD_VAR 0 2
43972: NOT
43973: OR
43974: IFFALSE 43978
// exit ;
43976: GO 44003
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43978: LD_ADDR_EXP 75
43982: PUSH
43983: LD_EXP 75
43987: PPUSH
43988: LD_VAR 0 1
43992: PPUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: CALL_OW 1
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 3
44007: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
// if not mc_bases or not base then
44012: LD_EXP 50
44016: NOT
44017: PUSH
44018: LD_VAR 0 1
44022: NOT
44023: OR
44024: IFFALSE 44028
// exit ;
44026: GO 44092
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44028: LD_ADDR_VAR 0 3
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: LD_INT 11
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44055: LD_ADDR_EXP 77
44059: PUSH
44060: LD_EXP 77
44064: PPUSH
44065: LD_VAR 0 1
44069: PPUSH
44070: LD_EXP 77
44074: PUSH
44075: LD_VAR 0 1
44079: ARRAY
44080: PUSH
44081: LD_VAR 0 3
44085: DIFF
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// end ;
44092: LD_VAR 0 2
44096: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44097: LD_INT 0
44099: PPUSH
// result := mc_vehicles [ base ] ;
44100: LD_ADDR_VAR 0 3
44104: PUSH
44105: LD_EXP 69
44109: PUSH
44110: LD_VAR 0 1
44114: ARRAY
44115: ST_TO_ADDR
// if onlyCombat then
44116: LD_VAR 0 2
44120: IFFALSE 44292
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44122: LD_ADDR_VAR 0 3
44126: PUSH
44127: LD_VAR 0 3
44131: PUSH
44132: LD_VAR 0 3
44136: PPUSH
44137: LD_INT 2
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 12
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 34
44152: PUSH
44153: LD_INT 51
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 89
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 32
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 34
44182: PUSH
44183: LD_INT 13
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 34
44192: PUSH
44193: LD_INT 52
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 34
44202: PUSH
44203: LD_INT 88
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 34
44212: PUSH
44213: LD_INT 14
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 53
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 98
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 31
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 48
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 8
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: DIFF
44291: ST_TO_ADDR
// end ; end_of_file
44292: LD_VAR 0 3
44296: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44297: LD_INT 0
44299: PPUSH
44300: PPUSH
44301: PPUSH
// if not mc_bases or not skirmish then
44302: LD_EXP 50
44306: NOT
44307: PUSH
44308: LD_EXP 48
44312: NOT
44313: OR
44314: IFFALSE 44318
// exit ;
44316: GO 44483
// for i = 1 to mc_bases do
44318: LD_ADDR_VAR 0 4
44322: PUSH
44323: DOUBLE
44324: LD_INT 1
44326: DEC
44327: ST_TO_ADDR
44328: LD_EXP 50
44332: PUSH
44333: FOR_TO
44334: IFFALSE 44481
// begin if sci in mc_bases [ i ] then
44336: LD_VAR 0 2
44340: PUSH
44341: LD_EXP 50
44345: PUSH
44346: LD_VAR 0 4
44350: ARRAY
44351: IN
44352: IFFALSE 44479
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44354: LD_ADDR_EXP 79
44358: PUSH
44359: LD_EXP 79
44363: PPUSH
44364: LD_VAR 0 4
44368: PUSH
44369: LD_EXP 79
44373: PUSH
44374: LD_VAR 0 4
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PPUSH
44388: LD_VAR 0 1
44392: PPUSH
44393: CALL 54067 0 3
44397: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44398: LD_ADDR_VAR 0 5
44402: PUSH
44403: LD_EXP 50
44407: PUSH
44408: LD_VAR 0 4
44412: ARRAY
44413: PPUSH
44414: LD_INT 2
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 0
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: PPUSH
44442: CALL_OW 72
44446: PPUSH
44447: LD_VAR 0 1
44451: PPUSH
44452: CALL_OW 74
44456: ST_TO_ADDR
// if tmp then
44457: LD_VAR 0 5
44461: IFFALSE 44477
// ComStandNearbyBuilding ( ape , tmp ) ;
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 5
44472: PPUSH
44473: CALL 50669 0 2
// break ;
44477: GO 44481
// end ; end ;
44479: GO 44333
44481: POP
44482: POP
// end ;
44483: LD_VAR 0 3
44487: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44488: LD_INT 0
44490: PPUSH
44491: PPUSH
44492: PPUSH
// if not mc_bases or not skirmish then
44493: LD_EXP 50
44497: NOT
44498: PUSH
44499: LD_EXP 48
44503: NOT
44504: OR
44505: IFFALSE 44509
// exit ;
44507: GO 44598
// for i = 1 to mc_bases do
44509: LD_ADDR_VAR 0 4
44513: PUSH
44514: DOUBLE
44515: LD_INT 1
44517: DEC
44518: ST_TO_ADDR
44519: LD_EXP 50
44523: PUSH
44524: FOR_TO
44525: IFFALSE 44596
// begin if building in mc_busy_turret_list [ i ] then
44527: LD_VAR 0 1
44531: PUSH
44532: LD_EXP 60
44536: PUSH
44537: LD_VAR 0 4
44541: ARRAY
44542: IN
44543: IFFALSE 44594
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44545: LD_ADDR_VAR 0 5
44549: PUSH
44550: LD_EXP 60
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: PUSH
44561: LD_VAR 0 1
44565: DIFF
44566: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44567: LD_ADDR_EXP 60
44571: PUSH
44572: LD_EXP 60
44576: PPUSH
44577: LD_VAR 0 4
44581: PPUSH
44582: LD_VAR 0 5
44586: PPUSH
44587: CALL_OW 1
44591: ST_TO_ADDR
// break ;
44592: GO 44596
// end ; end ;
44594: GO 44524
44596: POP
44597: POP
// end ;
44598: LD_VAR 0 3
44602: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44603: LD_INT 0
44605: PPUSH
44606: PPUSH
44607: PPUSH
// if not mc_bases or not skirmish then
44608: LD_EXP 50
44612: NOT
44613: PUSH
44614: LD_EXP 48
44618: NOT
44619: OR
44620: IFFALSE 44624
// exit ;
44622: GO 44823
// for i = 1 to mc_bases do
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: DOUBLE
44630: LD_INT 1
44632: DEC
44633: ST_TO_ADDR
44634: LD_EXP 50
44638: PUSH
44639: FOR_TO
44640: IFFALSE 44821
// if building in mc_bases [ i ] then
44642: LD_VAR 0 1
44646: PUSH
44647: LD_EXP 50
44651: PUSH
44652: LD_VAR 0 5
44656: ARRAY
44657: IN
44658: IFFALSE 44819
// begin tmp := mc_bases [ i ] diff building ;
44660: LD_ADDR_VAR 0 6
44664: PUSH
44665: LD_EXP 50
44669: PUSH
44670: LD_VAR 0 5
44674: ARRAY
44675: PUSH
44676: LD_VAR 0 1
44680: DIFF
44681: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44682: LD_ADDR_EXP 50
44686: PUSH
44687: LD_EXP 50
44691: PPUSH
44692: LD_VAR 0 5
44696: PPUSH
44697: LD_VAR 0 6
44701: PPUSH
44702: CALL_OW 1
44706: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44707: LD_VAR 0 1
44711: PUSH
44712: LD_EXP 58
44716: PUSH
44717: LD_VAR 0 5
44721: ARRAY
44722: IN
44723: IFFALSE 44762
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44725: LD_ADDR_EXP 58
44729: PUSH
44730: LD_EXP 58
44734: PPUSH
44735: LD_VAR 0 5
44739: PPUSH
44740: LD_EXP 58
44744: PUSH
44745: LD_VAR 0 5
44749: ARRAY
44750: PUSH
44751: LD_VAR 0 1
44755: DIFF
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44762: LD_VAR 0 1
44766: PUSH
44767: LD_EXP 59
44771: PUSH
44772: LD_VAR 0 5
44776: ARRAY
44777: IN
44778: IFFALSE 44817
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44780: LD_ADDR_EXP 59
44784: PUSH
44785: LD_EXP 59
44789: PPUSH
44790: LD_VAR 0 5
44794: PPUSH
44795: LD_EXP 59
44799: PUSH
44800: LD_VAR 0 5
44804: ARRAY
44805: PUSH
44806: LD_VAR 0 1
44810: DIFF
44811: PPUSH
44812: CALL_OW 1
44816: ST_TO_ADDR
// break ;
44817: GO 44821
// end ;
44819: GO 44639
44821: POP
44822: POP
// end ;
44823: LD_VAR 0 4
44827: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44828: LD_INT 0
44830: PPUSH
44831: PPUSH
44832: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44833: LD_EXP 50
44837: NOT
44838: PUSH
44839: LD_EXP 48
44843: NOT
44844: OR
44845: PUSH
44846: LD_VAR 0 3
44850: PUSH
44851: LD_EXP 76
44855: IN
44856: NOT
44857: OR
44858: IFFALSE 44862
// exit ;
44860: GO 44985
// for i = 1 to mc_vehicles do
44862: LD_ADDR_VAR 0 6
44866: PUSH
44867: DOUBLE
44868: LD_INT 1
44870: DEC
44871: ST_TO_ADDR
44872: LD_EXP 69
44876: PUSH
44877: FOR_TO
44878: IFFALSE 44983
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44880: LD_VAR 0 2
44884: PUSH
44885: LD_EXP 69
44889: PUSH
44890: LD_VAR 0 6
44894: ARRAY
44895: IN
44896: PUSH
44897: LD_VAR 0 1
44901: PUSH
44902: LD_EXP 69
44906: PUSH
44907: LD_VAR 0 6
44911: ARRAY
44912: IN
44913: OR
44914: IFFALSE 44981
// begin tmp := mc_vehicles [ i ] diff old ;
44916: LD_ADDR_VAR 0 7
44920: PUSH
44921: LD_EXP 69
44925: PUSH
44926: LD_VAR 0 6
44930: ARRAY
44931: PUSH
44932: LD_VAR 0 2
44936: DIFF
44937: ST_TO_ADDR
// tmp := tmp diff new ;
44938: LD_ADDR_VAR 0 7
44942: PUSH
44943: LD_VAR 0 7
44947: PUSH
44948: LD_VAR 0 1
44952: DIFF
44953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44954: LD_ADDR_EXP 69
44958: PUSH
44959: LD_EXP 69
44963: PPUSH
44964: LD_VAR 0 6
44968: PPUSH
44969: LD_VAR 0 7
44973: PPUSH
44974: CALL_OW 1
44978: ST_TO_ADDR
// break ;
44979: GO 44983
// end ;
44981: GO 44877
44983: POP
44984: POP
// end ;
44985: LD_VAR 0 5
44989: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44990: LD_INT 0
44992: PPUSH
44993: PPUSH
44994: PPUSH
44995: PPUSH
// if not mc_bases or not skirmish then
44996: LD_EXP 50
45000: NOT
45001: PUSH
45002: LD_EXP 48
45006: NOT
45007: OR
45008: IFFALSE 45012
// exit ;
45010: GO 45432
// repeat wait ( 0 0$1 ) ;
45012: LD_INT 35
45014: PPUSH
45015: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45019: LD_EXP 94
45023: NOT
45024: IFFALSE 45012
// mc_block_vehicle_constructed_thread := true ;
45026: LD_ADDR_EXP 94
45030: PUSH
45031: LD_INT 1
45033: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45034: LD_ADDR_VAR 0 5
45038: PUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 255
45048: ST_TO_ADDR
// for i = 1 to mc_bases do
45049: LD_ADDR_VAR 0 4
45053: PUSH
45054: DOUBLE
45055: LD_INT 1
45057: DEC
45058: ST_TO_ADDR
45059: LD_EXP 50
45063: PUSH
45064: FOR_TO
45065: IFFALSE 45422
// begin if factory in mc_bases [ i ] then
45067: LD_VAR 0 2
45071: PUSH
45072: LD_EXP 50
45076: PUSH
45077: LD_VAR 0 4
45081: ARRAY
45082: IN
45083: IFFALSE 45420
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45085: LD_EXP 72
45089: PUSH
45090: LD_VAR 0 4
45094: ARRAY
45095: PUSH
45096: LD_EXP 61
45100: PUSH
45101: LD_VAR 0 4
45105: ARRAY
45106: LESS
45107: PUSH
45108: LD_VAR 0 1
45112: PPUSH
45113: CALL_OW 264
45117: PUSH
45118: LD_INT 31
45120: PUSH
45121: LD_INT 32
45123: PUSH
45124: LD_INT 51
45126: PUSH
45127: LD_INT 89
45129: PUSH
45130: LD_INT 12
45132: PUSH
45133: LD_INT 30
45135: PUSH
45136: LD_INT 98
45138: PUSH
45139: LD_INT 11
45141: PUSH
45142: LD_INT 53
45144: PUSH
45145: LD_INT 14
45147: PUSH
45148: LD_INT 91
45150: PUSH
45151: LD_INT 29
45153: PUSH
45154: LD_INT 99
45156: PUSH
45157: LD_INT 13
45159: PUSH
45160: LD_INT 52
45162: PUSH
45163: LD_INT 88
45165: PUSH
45166: LD_INT 48
45168: PUSH
45169: LD_INT 8
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: IN
45192: NOT
45193: AND
45194: IFFALSE 45242
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45196: LD_ADDR_EXP 72
45200: PUSH
45201: LD_EXP 72
45205: PPUSH
45206: LD_VAR 0 4
45210: PUSH
45211: LD_EXP 72
45215: PUSH
45216: LD_VAR 0 4
45220: ARRAY
45221: PUSH
45222: LD_INT 1
45224: PLUS
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PPUSH
45230: LD_VAR 0 1
45234: PPUSH
45235: CALL 54067 0 3
45239: ST_TO_ADDR
45240: GO 45286
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45242: LD_ADDR_EXP 69
45246: PUSH
45247: LD_EXP 69
45251: PPUSH
45252: LD_VAR 0 4
45256: PUSH
45257: LD_EXP 69
45261: PUSH
45262: LD_VAR 0 4
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: PLUS
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PPUSH
45276: LD_VAR 0 1
45280: PPUSH
45281: CALL 54067 0 3
45285: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45286: LD_ADDR_EXP 94
45290: PUSH
45291: LD_INT 0
45293: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45294: LD_VAR 0 1
45298: PPUSH
45299: CALL_OW 263
45303: PUSH
45304: LD_INT 2
45306: EQUAL
45307: IFFALSE 45336
// begin repeat wait ( 0 0$3 ) ;
45309: LD_INT 105
45311: PPUSH
45312: CALL_OW 67
// Connect ( vehicle ) ;
45316: LD_VAR 0 1
45320: PPUSH
45321: CALL 57045 0 1
// until IsControledBy ( vehicle ) ;
45325: LD_VAR 0 1
45329: PPUSH
45330: CALL_OW 312
45334: IFFALSE 45309
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45336: LD_VAR 0 1
45340: PPUSH
45341: LD_EXP 74
45345: PUSH
45346: LD_VAR 0 4
45350: ARRAY
45351: PPUSH
45352: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL_OW 263
45365: PUSH
45366: LD_INT 1
45368: NONEQUAL
45369: IFFALSE 45373
// break ;
45371: GO 45422
// repeat wait ( 0 0$1 ) ;
45373: LD_INT 35
45375: PPUSH
45376: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45380: LD_VAR 0 1
45384: PPUSH
45385: LD_EXP 74
45389: PUSH
45390: LD_VAR 0 4
45394: ARRAY
45395: PPUSH
45396: CALL_OW 308
45400: IFFALSE 45373
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45402: LD_VAR 0 1
45406: PPUSH
45407: CALL_OW 311
45411: PPUSH
45412: CALL_OW 121
// exit ;
45416: POP
45417: POP
45418: GO 45432
// end ; end ;
45420: GO 45064
45422: POP
45423: POP
// mc_block_vehicle_constructed_thread := false ;
45424: LD_ADDR_EXP 94
45428: PUSH
45429: LD_INT 0
45431: ST_TO_ADDR
// end ;
45432: LD_VAR 0 3
45436: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45437: LD_INT 0
45439: PPUSH
45440: PPUSH
45441: PPUSH
45442: PPUSH
// if not mc_bases or not skirmish then
45443: LD_EXP 50
45447: NOT
45448: PUSH
45449: LD_EXP 48
45453: NOT
45454: OR
45455: IFFALSE 45459
// exit ;
45457: GO 45812
// repeat wait ( 0 0$1 ) ;
45459: LD_INT 35
45461: PPUSH
45462: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_VAR 0 3
45475: PPUSH
45476: CALL_OW 284
45480: IFFALSE 45459
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45482: LD_VAR 0 2
45486: PPUSH
45487: LD_VAR 0 3
45491: PPUSH
45492: CALL_OW 283
45496: PUSH
45497: LD_INT 4
45499: EQUAL
45500: IFFALSE 45504
// exit ;
45502: GO 45812
// for i = 1 to mc_bases do
45504: LD_ADDR_VAR 0 7
45508: PUSH
45509: DOUBLE
45510: LD_INT 1
45512: DEC
45513: ST_TO_ADDR
45514: LD_EXP 50
45518: PUSH
45519: FOR_TO
45520: IFFALSE 45810
// begin if mc_crates_area [ i ] then
45522: LD_EXP 68
45526: PUSH
45527: LD_VAR 0 7
45531: ARRAY
45532: IFFALSE 45643
// for j in mc_crates_area [ i ] do
45534: LD_ADDR_VAR 0 8
45538: PUSH
45539: LD_EXP 68
45543: PUSH
45544: LD_VAR 0 7
45548: ARRAY
45549: PUSH
45550: FOR_IN
45551: IFFALSE 45641
// if InArea ( x , y , j ) then
45553: LD_VAR 0 2
45557: PPUSH
45558: LD_VAR 0 3
45562: PPUSH
45563: LD_VAR 0 8
45567: PPUSH
45568: CALL_OW 309
45572: IFFALSE 45639
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45574: LD_ADDR_EXP 66
45578: PUSH
45579: LD_EXP 66
45583: PPUSH
45584: LD_VAR 0 7
45588: PUSH
45589: LD_EXP 66
45593: PUSH
45594: LD_VAR 0 7
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 4
45612: PUSH
45613: LD_VAR 0 2
45617: PUSH
45618: LD_VAR 0 3
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: LIST
45627: PPUSH
45628: CALL 54067 0 3
45632: ST_TO_ADDR
// exit ;
45633: POP
45634: POP
45635: POP
45636: POP
45637: GO 45812
// end ;
45639: GO 45550
45641: POP
45642: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45643: LD_ADDR_VAR 0 9
45647: PUSH
45648: LD_EXP 50
45652: PUSH
45653: LD_VAR 0 7
45657: ARRAY
45658: PPUSH
45659: LD_INT 2
45661: PUSH
45662: LD_INT 30
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 30
45674: PUSH
45675: LD_INT 1
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: PPUSH
45687: CALL_OW 72
45691: ST_TO_ADDR
// if not depot then
45692: LD_VAR 0 9
45696: NOT
45697: IFFALSE 45701
// continue ;
45699: GO 45519
// for j in depot do
45701: LD_ADDR_VAR 0 8
45705: PUSH
45706: LD_VAR 0 9
45710: PUSH
45711: FOR_IN
45712: IFFALSE 45806
// if GetDistUnitXY ( j , x , y ) < 30 then
45714: LD_VAR 0 8
45718: PPUSH
45719: LD_VAR 0 2
45723: PPUSH
45724: LD_VAR 0 3
45728: PPUSH
45729: CALL_OW 297
45733: PUSH
45734: LD_INT 30
45736: LESS
45737: IFFALSE 45804
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45739: LD_ADDR_EXP 66
45743: PUSH
45744: LD_EXP 66
45748: PPUSH
45749: LD_VAR 0 7
45753: PUSH
45754: LD_EXP 66
45758: PUSH
45759: LD_VAR 0 7
45763: ARRAY
45764: PUSH
45765: LD_INT 1
45767: PLUS
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PPUSH
45773: LD_VAR 0 4
45777: PUSH
45778: LD_VAR 0 2
45782: PUSH
45783: LD_VAR 0 3
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: PPUSH
45793: CALL 54067 0 3
45797: ST_TO_ADDR
// exit ;
45798: POP
45799: POP
45800: POP
45801: POP
45802: GO 45812
// end ;
45804: GO 45711
45806: POP
45807: POP
// end ;
45808: GO 45519
45810: POP
45811: POP
// end ;
45812: LD_VAR 0 6
45816: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45817: LD_INT 0
45819: PPUSH
45820: PPUSH
45821: PPUSH
45822: PPUSH
// if not mc_bases or not skirmish then
45823: LD_EXP 50
45827: NOT
45828: PUSH
45829: LD_EXP 48
45833: NOT
45834: OR
45835: IFFALSE 45839
// exit ;
45837: GO 46116
// side := GetSide ( lab ) ;
45839: LD_ADDR_VAR 0 4
45843: PUSH
45844: LD_VAR 0 2
45848: PPUSH
45849: CALL_OW 255
45853: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45854: LD_VAR 0 4
45858: PUSH
45859: LD_EXP 76
45863: IN
45864: NOT
45865: PUSH
45866: LD_EXP 77
45870: NOT
45871: OR
45872: PUSH
45873: LD_EXP 50
45877: NOT
45878: OR
45879: IFFALSE 45883
// exit ;
45881: GO 46116
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45883: LD_ADDR_EXP 77
45887: PUSH
45888: LD_EXP 77
45892: PPUSH
45893: LD_VAR 0 4
45897: PPUSH
45898: LD_EXP 77
45902: PUSH
45903: LD_VAR 0 4
45907: ARRAY
45908: PUSH
45909: LD_VAR 0 1
45913: DIFF
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// for i = 1 to mc_bases do
45920: LD_ADDR_VAR 0 5
45924: PUSH
45925: DOUBLE
45926: LD_INT 1
45928: DEC
45929: ST_TO_ADDR
45930: LD_EXP 50
45934: PUSH
45935: FOR_TO
45936: IFFALSE 46114
// begin if lab in mc_bases [ i ] then
45938: LD_VAR 0 2
45942: PUSH
45943: LD_EXP 50
45947: PUSH
45948: LD_VAR 0 5
45952: ARRAY
45953: IN
45954: IFFALSE 46112
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45956: LD_VAR 0 1
45960: PUSH
45961: LD_INT 11
45963: PUSH
45964: LD_INT 4
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: LD_INT 2
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: IN
45979: PUSH
45980: LD_EXP 80
45984: PUSH
45985: LD_VAR 0 5
45989: ARRAY
45990: AND
45991: IFFALSE 46112
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45993: LD_ADDR_VAR 0 6
45997: PUSH
45998: LD_EXP 80
46002: PUSH
46003: LD_VAR 0 5
46007: ARRAY
46008: PUSH
46009: LD_INT 1
46011: ARRAY
46012: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46013: LD_ADDR_EXP 80
46017: PUSH
46018: LD_EXP 80
46022: PPUSH
46023: LD_VAR 0 5
46027: PPUSH
46028: EMPTY
46029: PPUSH
46030: CALL_OW 1
46034: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46035: LD_VAR 0 6
46039: PPUSH
46040: LD_INT 0
46042: PPUSH
46043: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46047: LD_VAR 0 6
46051: PPUSH
46052: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46056: LD_ADDR_EXP 79
46060: PUSH
46061: LD_EXP 79
46065: PPUSH
46066: LD_VAR 0 5
46070: PPUSH
46071: LD_EXP 79
46075: PUSH
46076: LD_VAR 0 5
46080: ARRAY
46081: PPUSH
46082: LD_INT 1
46084: PPUSH
46085: LD_VAR 0 6
46089: PPUSH
46090: CALL_OW 2
46094: PPUSH
46095: CALL_OW 1
46099: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46100: LD_VAR 0 5
46104: PPUSH
46105: LD_INT 112
46107: PPUSH
46108: CALL 22566 0 2
// end ; end ; end ;
46112: GO 45935
46114: POP
46115: POP
// end ;
46116: LD_VAR 0 3
46120: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46121: LD_INT 0
46123: PPUSH
46124: PPUSH
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
// if not mc_bases or not skirmish then
46131: LD_EXP 50
46135: NOT
46136: PUSH
46137: LD_EXP 48
46141: NOT
46142: OR
46143: IFFALSE 46147
// exit ;
46145: GO 47516
// for i = 1 to mc_bases do
46147: LD_ADDR_VAR 0 3
46151: PUSH
46152: DOUBLE
46153: LD_INT 1
46155: DEC
46156: ST_TO_ADDR
46157: LD_EXP 50
46161: PUSH
46162: FOR_TO
46163: IFFALSE 47514
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46165: LD_VAR 0 1
46169: PUSH
46170: LD_EXP 50
46174: PUSH
46175: LD_VAR 0 3
46179: ARRAY
46180: IN
46181: PUSH
46182: LD_VAR 0 1
46186: PUSH
46187: LD_EXP 57
46191: PUSH
46192: LD_VAR 0 3
46196: ARRAY
46197: IN
46198: OR
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_EXP 72
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: IN
46216: OR
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_EXP 69
46227: PUSH
46228: LD_VAR 0 3
46232: ARRAY
46233: IN
46234: OR
46235: PUSH
46236: LD_VAR 0 1
46240: PUSH
46241: LD_EXP 79
46245: PUSH
46246: LD_VAR 0 3
46250: ARRAY
46251: IN
46252: OR
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_EXP 80
46263: PUSH
46264: LD_VAR 0 3
46268: ARRAY
46269: IN
46270: OR
46271: IFFALSE 47512
// begin if un in mc_ape [ i ] then
46273: LD_VAR 0 1
46277: PUSH
46278: LD_EXP 79
46282: PUSH
46283: LD_VAR 0 3
46287: ARRAY
46288: IN
46289: IFFALSE 46328
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46291: LD_ADDR_EXP 79
46295: PUSH
46296: LD_EXP 79
46300: PPUSH
46301: LD_VAR 0 3
46305: PPUSH
46306: LD_EXP 79
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: PPUSH
46323: CALL_OW 1
46327: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46328: LD_VAR 0 1
46332: PUSH
46333: LD_EXP 80
46337: PUSH
46338: LD_VAR 0 3
46342: ARRAY
46343: IN
46344: IFFALSE 46368
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46346: LD_ADDR_EXP 80
46350: PUSH
46351: LD_EXP 80
46355: PPUSH
46356: LD_VAR 0 3
46360: PPUSH
46361: EMPTY
46362: PPUSH
46363: CALL_OW 1
46367: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 247
46377: PUSH
46378: LD_INT 2
46380: EQUAL
46381: PUSH
46382: LD_VAR 0 1
46386: PPUSH
46387: CALL_OW 110
46391: PUSH
46392: LD_INT 20
46394: EQUAL
46395: PUSH
46396: LD_VAR 0 1
46400: PUSH
46401: LD_EXP 72
46405: PUSH
46406: LD_VAR 0 3
46410: ARRAY
46411: IN
46412: OR
46413: PUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: CALL_OW 264
46423: PUSH
46424: LD_INT 12
46426: PUSH
46427: LD_INT 51
46429: PUSH
46430: LD_INT 89
46432: PUSH
46433: LD_INT 32
46435: PUSH
46436: LD_INT 13
46438: PUSH
46439: LD_INT 52
46441: PUSH
46442: LD_INT 31
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: IN
46454: OR
46455: AND
46456: IFFALSE 46764
// begin if un in mc_defender [ i ] then
46458: LD_VAR 0 1
46462: PUSH
46463: LD_EXP 72
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: IN
46474: IFFALSE 46513
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46476: LD_ADDR_EXP 72
46480: PUSH
46481: LD_EXP 72
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: LD_EXP 72
46495: PUSH
46496: LD_VAR 0 3
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 1
46506: DIFF
46507: PPUSH
46508: CALL_OW 1
46512: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46513: LD_ADDR_VAR 0 8
46517: PUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: LD_INT 3
46525: PPUSH
46526: CALL 43134 0 2
46530: ST_TO_ADDR
// if fac then
46531: LD_VAR 0 8
46535: IFFALSE 46764
// begin for j in fac do
46537: LD_ADDR_VAR 0 4
46541: PUSH
46542: LD_VAR 0 8
46546: PUSH
46547: FOR_IN
46548: IFFALSE 46762
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46550: LD_ADDR_VAR 0 9
46554: PUSH
46555: LD_VAR 0 8
46559: PPUSH
46560: LD_VAR 0 1
46564: PPUSH
46565: CALL_OW 265
46569: PPUSH
46570: LD_VAR 0 1
46574: PPUSH
46575: CALL_OW 262
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 263
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL_OW 264
46599: PPUSH
46600: CALL 51565 0 5
46604: ST_TO_ADDR
// if components then
46605: LD_VAR 0 9
46609: IFFALSE 46760
// begin if GetWeapon ( un ) = ar_control_tower then
46611: LD_VAR 0 1
46615: PPUSH
46616: CALL_OW 264
46620: PUSH
46621: LD_INT 31
46623: EQUAL
46624: IFFALSE 46741
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46626: LD_VAR 0 1
46630: PPUSH
46631: CALL_OW 311
46635: PPUSH
46636: LD_INT 0
46638: PPUSH
46639: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46643: LD_ADDR_EXP 90
46647: PUSH
46648: LD_EXP 90
46652: PPUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: LD_EXP 90
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 1
46673: PPUSH
46674: CALL_OW 311
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46685: LD_ADDR_VAR 0 7
46689: PUSH
46690: LD_EXP 71
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: PPUSH
46701: LD_INT 1
46703: PPUSH
46704: LD_VAR 0 9
46708: PPUSH
46709: CALL_OW 2
46713: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46714: LD_ADDR_EXP 71
46718: PUSH
46719: LD_EXP 71
46723: PPUSH
46724: LD_VAR 0 3
46728: PPUSH
46729: LD_VAR 0 7
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// end else
46739: GO 46758
// MC_InsertProduceList ( i , [ components ] ) ;
46741: LD_VAR 0 3
46745: PPUSH
46746: LD_VAR 0 9
46750: PUSH
46751: EMPTY
46752: LIST
46753: PPUSH
46754: CALL 42679 0 2
// break ;
46758: GO 46762
// end ; end ;
46760: GO 46547
46762: POP
46763: POP
// end ; end ; if GetType ( un ) = unit_building then
46764: LD_VAR 0 1
46768: PPUSH
46769: CALL_OW 247
46773: PUSH
46774: LD_INT 3
46776: EQUAL
46777: IFFALSE 47180
// begin btype := GetBType ( un ) ;
46779: LD_ADDR_VAR 0 5
46783: PUSH
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL_OW 266
46793: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46794: LD_VAR 0 5
46798: PUSH
46799: LD_INT 29
46801: PUSH
46802: LD_INT 30
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: IN
46809: IFFALSE 46882
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 250
46820: PPUSH
46821: LD_VAR 0 1
46825: PPUSH
46826: CALL_OW 251
46830: PPUSH
46831: LD_VAR 0 1
46835: PPUSH
46836: CALL_OW 255
46840: PPUSH
46841: CALL_OW 440
46845: NOT
46846: IFFALSE 46882
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 250
46857: PPUSH
46858: LD_VAR 0 1
46862: PPUSH
46863: CALL_OW 251
46867: PPUSH
46868: LD_VAR 0 1
46872: PPUSH
46873: CALL_OW 255
46877: PPUSH
46878: CALL_OW 441
// end ; if btype = b_warehouse then
46882: LD_VAR 0 5
46886: PUSH
46887: LD_INT 1
46889: EQUAL
46890: IFFALSE 46908
// begin btype := b_depot ;
46892: LD_ADDR_VAR 0 5
46896: PUSH
46897: LD_INT 0
46899: ST_TO_ADDR
// pos := 1 ;
46900: LD_ADDR_VAR 0 6
46904: PUSH
46905: LD_INT 1
46907: ST_TO_ADDR
// end ; if btype = b_factory then
46908: LD_VAR 0 5
46912: PUSH
46913: LD_INT 3
46915: EQUAL
46916: IFFALSE 46934
// begin btype := b_workshop ;
46918: LD_ADDR_VAR 0 5
46922: PUSH
46923: LD_INT 2
46925: ST_TO_ADDR
// pos := 1 ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_INT 1
46933: ST_TO_ADDR
// end ; if btype = b_barracks then
46934: LD_VAR 0 5
46938: PUSH
46939: LD_INT 5
46941: EQUAL
46942: IFFALSE 46952
// btype := b_armoury ;
46944: LD_ADDR_VAR 0 5
46948: PUSH
46949: LD_INT 4
46951: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46952: LD_VAR 0 5
46956: PUSH
46957: LD_INT 7
46959: PUSH
46960: LD_INT 8
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: IN
46967: IFFALSE 46977
// btype := b_lab ;
46969: LD_ADDR_VAR 0 5
46973: PUSH
46974: LD_INT 6
46976: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46977: LD_ADDR_EXP 55
46981: PUSH
46982: LD_EXP 55
46986: PPUSH
46987: LD_VAR 0 3
46991: PUSH
46992: LD_EXP 55
46996: PUSH
46997: LD_VAR 0 3
47001: ARRAY
47002: PUSH
47003: LD_INT 1
47005: PLUS
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PPUSH
47011: LD_VAR 0 5
47015: PUSH
47016: LD_VAR 0 1
47020: PPUSH
47021: CALL_OW 250
47025: PUSH
47026: LD_VAR 0 1
47030: PPUSH
47031: CALL_OW 251
47035: PUSH
47036: LD_VAR 0 1
47040: PPUSH
47041: CALL_OW 254
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: PPUSH
47052: CALL 54067 0 3
47056: ST_TO_ADDR
// if pos = 1 then
47057: LD_VAR 0 6
47061: PUSH
47062: LD_INT 1
47064: EQUAL
47065: IFFALSE 47180
// begin tmp := mc_build_list [ i ] ;
47067: LD_ADDR_VAR 0 7
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47083: LD_VAR 0 7
47087: PPUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 30
47093: PUSH
47094: LD_INT 0
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 1
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: PPUSH
47116: CALL_OW 72
47120: IFFALSE 47130
// pos := 2 ;
47122: LD_ADDR_VAR 0 6
47126: PUSH
47127: LD_INT 2
47129: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47130: LD_ADDR_VAR 0 7
47134: PUSH
47135: LD_VAR 0 7
47139: PPUSH
47140: LD_VAR 0 6
47144: PPUSH
47145: LD_VAR 0 7
47149: PPUSH
47150: CALL 54393 0 3
47154: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47155: LD_ADDR_EXP 55
47159: PUSH
47160: LD_EXP 55
47164: PPUSH
47165: LD_VAR 0 3
47169: PPUSH
47170: LD_VAR 0 7
47174: PPUSH
47175: CALL_OW 1
47179: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 50
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: IN
47196: IFFALSE 47235
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47198: LD_ADDR_EXP 50
47202: PUSH
47203: LD_EXP 50
47207: PPUSH
47208: LD_VAR 0 3
47212: PPUSH
47213: LD_EXP 50
47217: PUSH
47218: LD_VAR 0 3
47222: ARRAY
47223: PUSH
47224: LD_VAR 0 1
47228: DIFF
47229: PPUSH
47230: CALL_OW 1
47234: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47235: LD_VAR 0 1
47239: PUSH
47240: LD_EXP 57
47244: PUSH
47245: LD_VAR 0 3
47249: ARRAY
47250: IN
47251: IFFALSE 47290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47253: LD_ADDR_EXP 57
47257: PUSH
47258: LD_EXP 57
47262: PPUSH
47263: LD_VAR 0 3
47267: PPUSH
47268: LD_EXP 57
47272: PUSH
47273: LD_VAR 0 3
47277: ARRAY
47278: PUSH
47279: LD_VAR 0 1
47283: DIFF
47284: PPUSH
47285: CALL_OW 1
47289: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47290: LD_VAR 0 1
47294: PUSH
47295: LD_EXP 69
47299: PUSH
47300: LD_VAR 0 3
47304: ARRAY
47305: IN
47306: IFFALSE 47345
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47308: LD_ADDR_EXP 69
47312: PUSH
47313: LD_EXP 69
47317: PPUSH
47318: LD_VAR 0 3
47322: PPUSH
47323: LD_EXP 69
47327: PUSH
47328: LD_VAR 0 3
47332: ARRAY
47333: PUSH
47334: LD_VAR 0 1
47338: DIFF
47339: PPUSH
47340: CALL_OW 1
47344: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47345: LD_VAR 0 1
47349: PUSH
47350: LD_EXP 72
47354: PUSH
47355: LD_VAR 0 3
47359: ARRAY
47360: IN
47361: IFFALSE 47400
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47363: LD_ADDR_EXP 72
47367: PUSH
47368: LD_EXP 72
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_EXP 72
47382: PUSH
47383: LD_VAR 0 3
47387: ARRAY
47388: PUSH
47389: LD_VAR 0 1
47393: DIFF
47394: PPUSH
47395: CALL_OW 1
47399: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47400: LD_VAR 0 1
47404: PUSH
47405: LD_EXP 59
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: IN
47416: IFFALSE 47455
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47418: LD_ADDR_EXP 59
47422: PUSH
47423: LD_EXP 59
47427: PPUSH
47428: LD_VAR 0 3
47432: PPUSH
47433: LD_EXP 59
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 1
47448: DIFF
47449: PPUSH
47450: CALL_OW 1
47454: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47455: LD_VAR 0 1
47459: PUSH
47460: LD_EXP 58
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: IN
47471: IFFALSE 47510
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47473: LD_ADDR_EXP 58
47477: PUSH
47478: LD_EXP 58
47482: PPUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: LD_EXP 58
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// end ; break ;
47510: GO 47514
// end ;
47512: GO 46162
47514: POP
47515: POP
// end ;
47516: LD_VAR 0 2
47520: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
// if not mc_bases or not skirmish then
47526: LD_EXP 50
47530: NOT
47531: PUSH
47532: LD_EXP 48
47536: NOT
47537: OR
47538: IFFALSE 47542
// exit ;
47540: GO 47757
// for i = 1 to mc_bases do
47542: LD_ADDR_VAR 0 3
47546: PUSH
47547: DOUBLE
47548: LD_INT 1
47550: DEC
47551: ST_TO_ADDR
47552: LD_EXP 50
47556: PUSH
47557: FOR_TO
47558: IFFALSE 47755
// begin if building in mc_construct_list [ i ] then
47560: LD_VAR 0 1
47564: PUSH
47565: LD_EXP 57
47569: PUSH
47570: LD_VAR 0 3
47574: ARRAY
47575: IN
47576: IFFALSE 47753
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47578: LD_ADDR_EXP 57
47582: PUSH
47583: LD_EXP 57
47587: PPUSH
47588: LD_VAR 0 3
47592: PPUSH
47593: LD_EXP 57
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: PUSH
47604: LD_VAR 0 1
47608: DIFF
47609: PPUSH
47610: CALL_OW 1
47614: ST_TO_ADDR
// if building in mc_lab [ i ] then
47615: LD_VAR 0 1
47619: PUSH
47620: LD_EXP 83
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: IN
47631: IFFALSE 47686
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47633: LD_ADDR_EXP 84
47637: PUSH
47638: LD_EXP 84
47642: PPUSH
47643: LD_VAR 0 3
47647: PPUSH
47648: LD_EXP 84
47652: PUSH
47653: LD_VAR 0 3
47657: ARRAY
47658: PPUSH
47659: LD_INT 1
47661: PPUSH
47662: LD_EXP 84
47666: PUSH
47667: LD_VAR 0 3
47671: ARRAY
47672: PPUSH
47673: LD_INT 0
47675: PPUSH
47676: CALL 53485 0 4
47680: PPUSH
47681: CALL_OW 1
47685: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47686: LD_VAR 0 1
47690: PUSH
47691: LD_EXP 50
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: IN
47702: NOT
47703: IFFALSE 47749
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47705: LD_ADDR_EXP 50
47709: PUSH
47710: LD_EXP 50
47714: PPUSH
47715: LD_VAR 0 3
47719: PUSH
47720: LD_EXP 50
47724: PUSH
47725: LD_VAR 0 3
47729: ARRAY
47730: PUSH
47731: LD_INT 1
47733: PLUS
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL 54067 0 3
47748: ST_TO_ADDR
// exit ;
47749: POP
47750: POP
47751: GO 47757
// end ; end ;
47753: GO 47557
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
47770: PPUSH
// if not mc_bases or not skirmish then
47771: LD_EXP 50
47775: NOT
47776: PUSH
47777: LD_EXP 48
47781: NOT
47782: OR
47783: IFFALSE 47787
// exit ;
47785: GO 48448
// for i = 1 to mc_bases do
47787: LD_ADDR_VAR 0 3
47791: PUSH
47792: DOUBLE
47793: LD_INT 1
47795: DEC
47796: ST_TO_ADDR
47797: LD_EXP 50
47801: PUSH
47802: FOR_TO
47803: IFFALSE 48446
// begin if building in mc_construct_list [ i ] then
47805: LD_VAR 0 1
47809: PUSH
47810: LD_EXP 57
47814: PUSH
47815: LD_VAR 0 3
47819: ARRAY
47820: IN
47821: IFFALSE 48444
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47823: LD_ADDR_EXP 57
47827: PUSH
47828: LD_EXP 57
47832: PPUSH
47833: LD_VAR 0 3
47837: PPUSH
47838: LD_EXP 57
47842: PUSH
47843: LD_VAR 0 3
47847: ARRAY
47848: PUSH
47849: LD_VAR 0 1
47853: DIFF
47854: PPUSH
47855: CALL_OW 1
47859: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47860: LD_ADDR_EXP 50
47864: PUSH
47865: LD_EXP 50
47869: PPUSH
47870: LD_VAR 0 3
47874: PUSH
47875: LD_EXP 50
47879: PUSH
47880: LD_VAR 0 3
47884: ARRAY
47885: PUSH
47886: LD_INT 1
47888: PLUS
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PPUSH
47894: LD_VAR 0 1
47898: PPUSH
47899: CALL 54067 0 3
47903: ST_TO_ADDR
// btype := GetBType ( building ) ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_VAR 0 1
47913: PPUSH
47914: CALL_OW 266
47918: ST_TO_ADDR
// side := GetSide ( building ) ;
47919: LD_ADDR_VAR 0 8
47923: PUSH
47924: LD_VAR 0 1
47928: PPUSH
47929: CALL_OW 255
47933: ST_TO_ADDR
// if btype = b_lab then
47934: LD_VAR 0 5
47938: PUSH
47939: LD_INT 6
47941: EQUAL
47942: IFFALSE 47992
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47944: LD_ADDR_EXP 83
47948: PUSH
47949: LD_EXP 83
47953: PPUSH
47954: LD_VAR 0 3
47958: PUSH
47959: LD_EXP 83
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PPUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL 54067 0 3
47987: ST_TO_ADDR
// exit ;
47988: POP
47989: POP
47990: GO 48448
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47992: LD_VAR 0 5
47996: PUSH
47997: LD_INT 0
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 4
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: LIST
48010: IN
48011: IFFALSE 48135
// begin if btype = b_armoury then
48013: LD_VAR 0 5
48017: PUSH
48018: LD_INT 4
48020: EQUAL
48021: IFFALSE 48031
// btype := b_barracks ;
48023: LD_ADDR_VAR 0 5
48027: PUSH
48028: LD_INT 5
48030: ST_TO_ADDR
// if btype = b_depot then
48031: LD_VAR 0 5
48035: PUSH
48036: LD_INT 0
48038: EQUAL
48039: IFFALSE 48049
// btype := b_warehouse ;
48041: LD_ADDR_VAR 0 5
48045: PUSH
48046: LD_INT 1
48048: ST_TO_ADDR
// if btype = b_workshop then
48049: LD_VAR 0 5
48053: PUSH
48054: LD_INT 2
48056: EQUAL
48057: IFFALSE 48067
// btype := b_factory ;
48059: LD_ADDR_VAR 0 5
48063: PUSH
48064: LD_INT 3
48066: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48067: LD_VAR 0 5
48071: PPUSH
48072: LD_VAR 0 8
48076: PPUSH
48077: CALL_OW 323
48081: PUSH
48082: LD_INT 1
48084: EQUAL
48085: IFFALSE 48131
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48087: LD_ADDR_EXP 82
48091: PUSH
48092: LD_EXP 82
48096: PPUSH
48097: LD_VAR 0 3
48101: PUSH
48102: LD_EXP 82
48106: PUSH
48107: LD_VAR 0 3
48111: ARRAY
48112: PUSH
48113: LD_INT 1
48115: PLUS
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: PPUSH
48121: LD_VAR 0 1
48125: PPUSH
48126: CALL 54067 0 3
48130: ST_TO_ADDR
// exit ;
48131: POP
48132: POP
48133: GO 48448
// end ; if btype in [ b_bunker , b_turret ] then
48135: LD_VAR 0 5
48139: PUSH
48140: LD_INT 32
48142: PUSH
48143: LD_INT 33
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: IN
48150: IFFALSE 48440
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48152: LD_ADDR_EXP 58
48156: PUSH
48157: LD_EXP 58
48161: PPUSH
48162: LD_VAR 0 3
48166: PUSH
48167: LD_EXP 58
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: PUSH
48178: LD_INT 1
48180: PLUS
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL 54067 0 3
48195: ST_TO_ADDR
// if btype = b_bunker then
48196: LD_VAR 0 5
48200: PUSH
48201: LD_INT 32
48203: EQUAL
48204: IFFALSE 48440
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48206: LD_ADDR_EXP 59
48210: PUSH
48211: LD_EXP 59
48215: PPUSH
48216: LD_VAR 0 3
48220: PUSH
48221: LD_EXP 59
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: PUSH
48232: LD_INT 1
48234: PLUS
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PPUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: CALL 54067 0 3
48249: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48250: LD_ADDR_VAR 0 6
48254: PUSH
48255: LD_EXP 50
48259: PUSH
48260: LD_VAR 0 3
48264: ARRAY
48265: PPUSH
48266: LD_INT 25
48268: PUSH
48269: LD_INT 1
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 3
48278: PUSH
48279: LD_INT 54
48281: PUSH
48282: EMPTY
48283: LIST
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PPUSH
48293: CALL_OW 72
48297: ST_TO_ADDR
// if tmp then
48298: LD_VAR 0 6
48302: IFFALSE 48308
// exit ;
48304: POP
48305: POP
48306: GO 48448
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48308: LD_ADDR_VAR 0 6
48312: PUSH
48313: LD_EXP 50
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: PPUSH
48324: LD_INT 2
48326: PUSH
48327: LD_INT 30
48329: PUSH
48330: LD_INT 4
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 5
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: LIST
48351: PPUSH
48352: CALL_OW 72
48356: ST_TO_ADDR
// if not tmp then
48357: LD_VAR 0 6
48361: NOT
48362: IFFALSE 48368
// exit ;
48364: POP
48365: POP
48366: GO 48448
// for j in tmp do
48368: LD_ADDR_VAR 0 4
48372: PUSH
48373: LD_VAR 0 6
48377: PUSH
48378: FOR_IN
48379: IFFALSE 48438
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48381: LD_ADDR_VAR 0 7
48385: PUSH
48386: LD_VAR 0 4
48390: PPUSH
48391: CALL_OW 313
48395: PPUSH
48396: LD_INT 25
48398: PUSH
48399: LD_INT 1
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PPUSH
48406: CALL_OW 72
48410: ST_TO_ADDR
// if units then
48411: LD_VAR 0 7
48415: IFFALSE 48436
// begin ComExitBuilding ( units [ 1 ] ) ;
48417: LD_VAR 0 7
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PPUSH
48426: CALL_OW 122
// exit ;
48430: POP
48431: POP
48432: POP
48433: POP
48434: GO 48448
// end ; end ;
48436: GO 48378
48438: POP
48439: POP
// end ; end ; exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 47802
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 2
48452: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
48458: PPUSH
48459: PPUSH
48460: PPUSH
48461: PPUSH
// if not mc_bases or not skirmish then
48462: LD_EXP 50
48466: NOT
48467: PUSH
48468: LD_EXP 48
48472: NOT
48473: OR
48474: IFFALSE 48478
// exit ;
48476: GO 48743
// btype := GetBType ( building ) ;
48478: LD_ADDR_VAR 0 6
48482: PUSH
48483: LD_VAR 0 1
48487: PPUSH
48488: CALL_OW 266
48492: ST_TO_ADDR
// x := GetX ( building ) ;
48493: LD_ADDR_VAR 0 7
48497: PUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: CALL_OW 250
48507: ST_TO_ADDR
// y := GetY ( building ) ;
48508: LD_ADDR_VAR 0 8
48512: PUSH
48513: LD_VAR 0 1
48517: PPUSH
48518: CALL_OW 251
48522: ST_TO_ADDR
// d := GetDir ( building ) ;
48523: LD_ADDR_VAR 0 9
48527: PUSH
48528: LD_VAR 0 1
48532: PPUSH
48533: CALL_OW 254
48537: ST_TO_ADDR
// for i = 1 to mc_bases do
48538: LD_ADDR_VAR 0 4
48542: PUSH
48543: DOUBLE
48544: LD_INT 1
48546: DEC
48547: ST_TO_ADDR
48548: LD_EXP 50
48552: PUSH
48553: FOR_TO
48554: IFFALSE 48741
// begin if not mc_build_list [ i ] then
48556: LD_EXP 55
48560: PUSH
48561: LD_VAR 0 4
48565: ARRAY
48566: NOT
48567: IFFALSE 48571
// continue ;
48569: GO 48553
// for j := 1 to mc_build_list [ i ] do
48571: LD_ADDR_VAR 0 5
48575: PUSH
48576: DOUBLE
48577: LD_INT 1
48579: DEC
48580: ST_TO_ADDR
48581: LD_EXP 55
48585: PUSH
48586: LD_VAR 0 4
48590: ARRAY
48591: PUSH
48592: FOR_TO
48593: IFFALSE 48737
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48595: LD_VAR 0 6
48599: PUSH
48600: LD_VAR 0 7
48604: PUSH
48605: LD_VAR 0 8
48609: PUSH
48610: LD_VAR 0 9
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: PPUSH
48621: LD_EXP 55
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PUSH
48632: LD_VAR 0 5
48636: ARRAY
48637: PPUSH
48638: CALL 60256 0 2
48642: IFFALSE 48735
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48644: LD_ADDR_EXP 55
48648: PUSH
48649: LD_EXP 55
48653: PPUSH
48654: LD_VAR 0 4
48658: PPUSH
48659: LD_EXP 55
48663: PUSH
48664: LD_VAR 0 4
48668: ARRAY
48669: PPUSH
48670: LD_VAR 0 5
48674: PPUSH
48675: CALL_OW 3
48679: PPUSH
48680: CALL_OW 1
48684: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48685: LD_ADDR_EXP 57
48689: PUSH
48690: LD_EXP 57
48694: PPUSH
48695: LD_VAR 0 4
48699: PUSH
48700: LD_EXP 57
48704: PUSH
48705: LD_VAR 0 4
48709: ARRAY
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PPUSH
48719: LD_VAR 0 1
48723: PPUSH
48724: CALL 54067 0 3
48728: ST_TO_ADDR
// exit ;
48729: POP
48730: POP
48731: POP
48732: POP
48733: GO 48743
// end ;
48735: GO 48592
48737: POP
48738: POP
// end ;
48739: GO 48553
48741: POP
48742: POP
// end ;
48743: LD_VAR 0 3
48747: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48748: LD_INT 0
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 50
48757: NOT
48758: PUSH
48759: LD_EXP 48
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 48959
// for i = 1 to mc_bases do
48769: LD_ADDR_VAR 0 4
48773: PUSH
48774: DOUBLE
48775: LD_INT 1
48777: DEC
48778: ST_TO_ADDR
48779: LD_EXP 50
48783: PUSH
48784: FOR_TO
48785: IFFALSE 48872
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48787: LD_VAR 0 1
48791: PUSH
48792: LD_EXP 58
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: IN
48803: PUSH
48804: LD_VAR 0 1
48808: PUSH
48809: LD_EXP 59
48813: PUSH
48814: LD_VAR 0 4
48818: ARRAY
48819: IN
48820: NOT
48821: AND
48822: IFFALSE 48870
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48824: LD_ADDR_EXP 59
48828: PUSH
48829: LD_EXP 59
48833: PPUSH
48834: LD_VAR 0 4
48838: PUSH
48839: LD_EXP 59
48843: PUSH
48844: LD_VAR 0 4
48848: ARRAY
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PPUSH
48858: LD_VAR 0 1
48862: PPUSH
48863: CALL 54067 0 3
48867: ST_TO_ADDR
// break ;
48868: GO 48872
// end ; end ;
48870: GO 48784
48872: POP
48873: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48874: LD_VAR 0 1
48878: PPUSH
48879: CALL_OW 257
48883: PUSH
48884: LD_EXP 76
48888: IN
48889: PUSH
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 266
48899: PUSH
48900: LD_INT 5
48902: EQUAL
48903: AND
48904: PUSH
48905: LD_VAR 0 2
48909: PPUSH
48910: CALL_OW 110
48914: PUSH
48915: LD_INT 18
48917: NONEQUAL
48918: AND
48919: IFFALSE 48959
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48921: LD_VAR 0 2
48925: PPUSH
48926: CALL_OW 257
48930: PUSH
48931: LD_INT 5
48933: PUSH
48934: LD_INT 8
48936: PUSH
48937: LD_INT 9
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: IN
48945: IFFALSE 48959
// SetClass ( unit , 1 ) ;
48947: LD_VAR 0 2
48951: PPUSH
48952: LD_INT 1
48954: PPUSH
48955: CALL_OW 336
// end ;
48959: LD_VAR 0 3
48963: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48964: LD_INT 0
48966: PPUSH
48967: PPUSH
// if not mc_bases or not skirmish then
48968: LD_EXP 50
48972: NOT
48973: PUSH
48974: LD_EXP 48
48978: NOT
48979: OR
48980: IFFALSE 48984
// exit ;
48982: GO 49100
// if GetLives ( abandoned_vehicle ) > 250 then
48984: LD_VAR 0 2
48988: PPUSH
48989: CALL_OW 256
48993: PUSH
48994: LD_INT 250
48996: GREATER
48997: IFFALSE 49001
// exit ;
48999: GO 49100
// for i = 1 to mc_bases do
49001: LD_ADDR_VAR 0 6
49005: PUSH
49006: DOUBLE
49007: LD_INT 1
49009: DEC
49010: ST_TO_ADDR
49011: LD_EXP 50
49015: PUSH
49016: FOR_TO
49017: IFFALSE 49098
// begin if driver in mc_bases [ i ] then
49019: LD_VAR 0 1
49023: PUSH
49024: LD_EXP 50
49028: PUSH
49029: LD_VAR 0 6
49033: ARRAY
49034: IN
49035: IFFALSE 49096
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49037: LD_VAR 0 1
49041: PPUSH
49042: LD_EXP 50
49046: PUSH
49047: LD_VAR 0 6
49051: ARRAY
49052: PPUSH
49053: LD_INT 2
49055: PUSH
49056: LD_INT 30
49058: PUSH
49059: LD_INT 0
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 30
49068: PUSH
49069: LD_INT 1
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: LIST
49080: PPUSH
49081: CALL_OW 72
49085: PUSH
49086: LD_INT 1
49088: ARRAY
49089: PPUSH
49090: CALL 87303 0 2
// break ;
49094: GO 49098
// end ; end ;
49096: GO 49016
49098: POP
49099: POP
// end ; end_of_file
49100: LD_VAR 0 5
49104: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
// if exist_mode then
49109: LD_VAR 0 2
49113: IFFALSE 49138
// unit := CreateCharacter ( prefix & ident ) else
49115: LD_ADDR_VAR 0 5
49119: PUSH
49120: LD_VAR 0 3
49124: PUSH
49125: LD_VAR 0 1
49129: STR
49130: PPUSH
49131: CALL_OW 34
49135: ST_TO_ADDR
49136: GO 49153
// unit := NewCharacter ( ident ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: CALL_OW 25
49152: ST_TO_ADDR
// result := unit ;
49153: LD_ADDR_VAR 0 4
49157: PUSH
49158: LD_VAR 0 5
49162: ST_TO_ADDR
// end ;
49163: LD_VAR 0 4
49167: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49168: LD_INT 0
49170: PPUSH
49171: PPUSH
// if not side or not nation then
49172: LD_VAR 0 1
49176: NOT
49177: PUSH
49178: LD_VAR 0 2
49182: NOT
49183: OR
49184: IFFALSE 49188
// exit ;
49186: GO 49956
// case nation of nation_american :
49188: LD_VAR 0 2
49192: PUSH
49193: LD_INT 1
49195: DOUBLE
49196: EQUAL
49197: IFTRUE 49201
49199: GO 49415
49201: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_INT 35
49209: PUSH
49210: LD_INT 45
49212: PUSH
49213: LD_INT 46
49215: PUSH
49216: LD_INT 47
49218: PUSH
49219: LD_INT 82
49221: PUSH
49222: LD_INT 83
49224: PUSH
49225: LD_INT 84
49227: PUSH
49228: LD_INT 85
49230: PUSH
49231: LD_INT 86
49233: PUSH
49234: LD_INT 1
49236: PUSH
49237: LD_INT 2
49239: PUSH
49240: LD_INT 6
49242: PUSH
49243: LD_INT 15
49245: PUSH
49246: LD_INT 16
49248: PUSH
49249: LD_INT 7
49251: PUSH
49252: LD_INT 12
49254: PUSH
49255: LD_INT 13
49257: PUSH
49258: LD_INT 10
49260: PUSH
49261: LD_INT 14
49263: PUSH
49264: LD_INT 20
49266: PUSH
49267: LD_INT 21
49269: PUSH
49270: LD_INT 22
49272: PUSH
49273: LD_INT 25
49275: PUSH
49276: LD_INT 32
49278: PUSH
49279: LD_INT 27
49281: PUSH
49282: LD_INT 36
49284: PUSH
49285: LD_INT 69
49287: PUSH
49288: LD_INT 39
49290: PUSH
49291: LD_INT 34
49293: PUSH
49294: LD_INT 40
49296: PUSH
49297: LD_INT 48
49299: PUSH
49300: LD_INT 49
49302: PUSH
49303: LD_INT 50
49305: PUSH
49306: LD_INT 51
49308: PUSH
49309: LD_INT 52
49311: PUSH
49312: LD_INT 53
49314: PUSH
49315: LD_INT 54
49317: PUSH
49318: LD_INT 55
49320: PUSH
49321: LD_INT 56
49323: PUSH
49324: LD_INT 57
49326: PUSH
49327: LD_INT 58
49329: PUSH
49330: LD_INT 59
49332: PUSH
49333: LD_INT 60
49335: PUSH
49336: LD_INT 61
49338: PUSH
49339: LD_INT 62
49341: PUSH
49342: LD_INT 80
49344: PUSH
49345: LD_INT 82
49347: PUSH
49348: LD_INT 83
49350: PUSH
49351: LD_INT 84
49353: PUSH
49354: LD_INT 85
49356: PUSH
49357: LD_INT 86
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: ST_TO_ADDR
49413: GO 49880
49415: LD_INT 2
49417: DOUBLE
49418: EQUAL
49419: IFTRUE 49423
49421: GO 49649
49423: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49424: LD_ADDR_VAR 0 4
49428: PUSH
49429: LD_INT 35
49431: PUSH
49432: LD_INT 45
49434: PUSH
49435: LD_INT 46
49437: PUSH
49438: LD_INT 47
49440: PUSH
49441: LD_INT 82
49443: PUSH
49444: LD_INT 83
49446: PUSH
49447: LD_INT 84
49449: PUSH
49450: LD_INT 85
49452: PUSH
49453: LD_INT 87
49455: PUSH
49456: LD_INT 70
49458: PUSH
49459: LD_INT 1
49461: PUSH
49462: LD_INT 11
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: LD_INT 4
49470: PUSH
49471: LD_INT 5
49473: PUSH
49474: LD_INT 6
49476: PUSH
49477: LD_INT 15
49479: PUSH
49480: LD_INT 18
49482: PUSH
49483: LD_INT 7
49485: PUSH
49486: LD_INT 17
49488: PUSH
49489: LD_INT 8
49491: PUSH
49492: LD_INT 20
49494: PUSH
49495: LD_INT 21
49497: PUSH
49498: LD_INT 22
49500: PUSH
49501: LD_INT 72
49503: PUSH
49504: LD_INT 26
49506: PUSH
49507: LD_INT 69
49509: PUSH
49510: LD_INT 39
49512: PUSH
49513: LD_INT 40
49515: PUSH
49516: LD_INT 41
49518: PUSH
49519: LD_INT 42
49521: PUSH
49522: LD_INT 43
49524: PUSH
49525: LD_INT 48
49527: PUSH
49528: LD_INT 49
49530: PUSH
49531: LD_INT 50
49533: PUSH
49534: LD_INT 51
49536: PUSH
49537: LD_INT 52
49539: PUSH
49540: LD_INT 53
49542: PUSH
49543: LD_INT 54
49545: PUSH
49546: LD_INT 55
49548: PUSH
49549: LD_INT 56
49551: PUSH
49552: LD_INT 60
49554: PUSH
49555: LD_INT 61
49557: PUSH
49558: LD_INT 62
49560: PUSH
49561: LD_INT 66
49563: PUSH
49564: LD_INT 67
49566: PUSH
49567: LD_INT 68
49569: PUSH
49570: LD_INT 81
49572: PUSH
49573: LD_INT 82
49575: PUSH
49576: LD_INT 83
49578: PUSH
49579: LD_INT 84
49581: PUSH
49582: LD_INT 85
49584: PUSH
49585: LD_INT 87
49587: PUSH
49588: LD_INT 88
49590: PUSH
49591: EMPTY
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: ST_TO_ADDR
49647: GO 49880
49649: LD_INT 3
49651: DOUBLE
49652: EQUAL
49653: IFTRUE 49657
49655: GO 49879
49657: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49658: LD_ADDR_VAR 0 4
49662: PUSH
49663: LD_INT 46
49665: PUSH
49666: LD_INT 47
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 82
49677: PUSH
49678: LD_INT 83
49680: PUSH
49681: LD_INT 84
49683: PUSH
49684: LD_INT 85
49686: PUSH
49687: LD_INT 86
49689: PUSH
49690: LD_INT 11
49692: PUSH
49693: LD_INT 9
49695: PUSH
49696: LD_INT 20
49698: PUSH
49699: LD_INT 19
49701: PUSH
49702: LD_INT 21
49704: PUSH
49705: LD_INT 24
49707: PUSH
49708: LD_INT 22
49710: PUSH
49711: LD_INT 25
49713: PUSH
49714: LD_INT 28
49716: PUSH
49717: LD_INT 29
49719: PUSH
49720: LD_INT 30
49722: PUSH
49723: LD_INT 31
49725: PUSH
49726: LD_INT 37
49728: PUSH
49729: LD_INT 38
49731: PUSH
49732: LD_INT 32
49734: PUSH
49735: LD_INT 27
49737: PUSH
49738: LD_INT 33
49740: PUSH
49741: LD_INT 69
49743: PUSH
49744: LD_INT 39
49746: PUSH
49747: LD_INT 34
49749: PUSH
49750: LD_INT 40
49752: PUSH
49753: LD_INT 71
49755: PUSH
49756: LD_INT 23
49758: PUSH
49759: LD_INT 44
49761: PUSH
49762: LD_INT 48
49764: PUSH
49765: LD_INT 49
49767: PUSH
49768: LD_INT 50
49770: PUSH
49771: LD_INT 51
49773: PUSH
49774: LD_INT 52
49776: PUSH
49777: LD_INT 53
49779: PUSH
49780: LD_INT 54
49782: PUSH
49783: LD_INT 55
49785: PUSH
49786: LD_INT 56
49788: PUSH
49789: LD_INT 57
49791: PUSH
49792: LD_INT 58
49794: PUSH
49795: LD_INT 59
49797: PUSH
49798: LD_INT 63
49800: PUSH
49801: LD_INT 64
49803: PUSH
49804: LD_INT 65
49806: PUSH
49807: LD_INT 82
49809: PUSH
49810: LD_INT 83
49812: PUSH
49813: LD_INT 84
49815: PUSH
49816: LD_INT 85
49818: PUSH
49819: LD_INT 86
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: ST_TO_ADDR
49877: GO 49880
49879: POP
// if state > - 1 and state < 3 then
49880: LD_VAR 0 3
49884: PUSH
49885: LD_INT 1
49887: NEG
49888: GREATER
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_INT 3
49897: LESS
49898: AND
49899: IFFALSE 49956
// for i in result do
49901: LD_ADDR_VAR 0 5
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: FOR_IN
49912: IFFALSE 49954
// if GetTech ( i , side ) <> state then
49914: LD_VAR 0 5
49918: PPUSH
49919: LD_VAR 0 1
49923: PPUSH
49924: CALL_OW 321
49928: PUSH
49929: LD_VAR 0 3
49933: NONEQUAL
49934: IFFALSE 49952
// result := result diff i ;
49936: LD_ADDR_VAR 0 4
49940: PUSH
49941: LD_VAR 0 4
49945: PUSH
49946: LD_VAR 0 5
49950: DIFF
49951: ST_TO_ADDR
49952: GO 49911
49954: POP
49955: POP
// end ;
49956: LD_VAR 0 4
49960: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49961: LD_INT 0
49963: PPUSH
49964: PPUSH
49965: PPUSH
// result := true ;
49966: LD_ADDR_VAR 0 3
49970: PUSH
49971: LD_INT 1
49973: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49974: LD_ADDR_VAR 0 5
49978: PUSH
49979: LD_VAR 0 2
49983: PPUSH
49984: CALL_OW 480
49988: ST_TO_ADDR
// if not tmp then
49989: LD_VAR 0 5
49993: NOT
49994: IFFALSE 49998
// exit ;
49996: GO 50047
// for i in tmp do
49998: LD_ADDR_VAR 0 4
50002: PUSH
50003: LD_VAR 0 5
50007: PUSH
50008: FOR_IN
50009: IFFALSE 50045
// if GetTech ( i , side ) <> state_researched then
50011: LD_VAR 0 4
50015: PPUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 321
50025: PUSH
50026: LD_INT 2
50028: NONEQUAL
50029: IFFALSE 50043
// begin result := false ;
50031: LD_ADDR_VAR 0 3
50035: PUSH
50036: LD_INT 0
50038: ST_TO_ADDR
// exit ;
50039: POP
50040: POP
50041: GO 50047
// end ;
50043: GO 50008
50045: POP
50046: POP
// end ;
50047: LD_VAR 0 3
50051: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50052: LD_INT 0
50054: PPUSH
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
50066: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50067: LD_VAR 0 1
50071: NOT
50072: PUSH
50073: LD_VAR 0 1
50077: PPUSH
50078: CALL_OW 257
50082: PUSH
50083: LD_INT 9
50085: NONEQUAL
50086: OR
50087: IFFALSE 50091
// exit ;
50089: GO 50664
// side := GetSide ( unit ) ;
50091: LD_ADDR_VAR 0 9
50095: PUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 255
50105: ST_TO_ADDR
// tech_space := tech_spacanom ;
50106: LD_ADDR_VAR 0 12
50110: PUSH
50111: LD_INT 29
50113: ST_TO_ADDR
// tech_time := tech_taurad ;
50114: LD_ADDR_VAR 0 13
50118: PUSH
50119: LD_INT 28
50121: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50122: LD_ADDR_VAR 0 11
50126: PUSH
50127: LD_VAR 0 1
50131: PPUSH
50132: CALL_OW 310
50136: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50137: LD_VAR 0 11
50141: PPUSH
50142: CALL_OW 247
50146: PUSH
50147: LD_INT 2
50149: EQUAL
50150: IFFALSE 50154
// exit ;
50152: GO 50664
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50154: LD_ADDR_VAR 0 8
50158: PUSH
50159: LD_INT 81
50161: PUSH
50162: LD_VAR 0 9
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 3
50173: PUSH
50174: LD_INT 21
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PPUSH
50192: CALL_OW 69
50196: ST_TO_ADDR
// if not tmp then
50197: LD_VAR 0 8
50201: NOT
50202: IFFALSE 50206
// exit ;
50204: GO 50664
// if in_unit then
50206: LD_VAR 0 11
50210: IFFALSE 50234
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50212: LD_ADDR_VAR 0 10
50216: PUSH
50217: LD_VAR 0 8
50221: PPUSH
50222: LD_VAR 0 11
50226: PPUSH
50227: CALL_OW 74
50231: ST_TO_ADDR
50232: GO 50254
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50234: LD_ADDR_VAR 0 10
50238: PUSH
50239: LD_VAR 0 8
50243: PPUSH
50244: LD_VAR 0 1
50248: PPUSH
50249: CALL_OW 74
50253: ST_TO_ADDR
// if not enemy then
50254: LD_VAR 0 10
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 50664
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50263: LD_VAR 0 11
50267: PUSH
50268: LD_VAR 0 11
50272: PPUSH
50273: LD_VAR 0 10
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 13
50285: GREATER
50286: AND
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: LD_VAR 0 10
50297: PPUSH
50298: CALL_OW 296
50302: PUSH
50303: LD_INT 12
50305: GREATER
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50664
// missile := [ 1 ] ;
50311: LD_ADDR_VAR 0 14
50315: PUSH
50316: LD_INT 1
50318: PUSH
50319: EMPTY
50320: LIST
50321: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50322: LD_VAR 0 9
50326: PPUSH
50327: LD_VAR 0 12
50331: PPUSH
50332: CALL_OW 325
50336: IFFALSE 50365
// missile := Replace ( missile , missile + 1 , 2 ) ;
50338: LD_ADDR_VAR 0 14
50342: PUSH
50343: LD_VAR 0 14
50347: PPUSH
50348: LD_VAR 0 14
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PPUSH
50357: LD_INT 2
50359: PPUSH
50360: CALL_OW 1
50364: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50365: LD_VAR 0 9
50369: PPUSH
50370: LD_VAR 0 13
50374: PPUSH
50375: CALL_OW 325
50379: PUSH
50380: LD_VAR 0 10
50384: PPUSH
50385: CALL_OW 255
50389: PPUSH
50390: LD_VAR 0 13
50394: PPUSH
50395: CALL_OW 325
50399: NOT
50400: AND
50401: IFFALSE 50430
// missile := Replace ( missile , missile + 1 , 3 ) ;
50403: LD_ADDR_VAR 0 14
50407: PUSH
50408: LD_VAR 0 14
50412: PPUSH
50413: LD_VAR 0 14
50417: PUSH
50418: LD_INT 1
50420: PLUS
50421: PPUSH
50422: LD_INT 3
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// if missile < 2 then
50430: LD_VAR 0 14
50434: PUSH
50435: LD_INT 2
50437: LESS
50438: IFFALSE 50442
// exit ;
50440: GO 50664
// x := GetX ( enemy ) ;
50442: LD_ADDR_VAR 0 4
50446: PUSH
50447: LD_VAR 0 10
50451: PPUSH
50452: CALL_OW 250
50456: ST_TO_ADDR
// y := GetY ( enemy ) ;
50457: LD_ADDR_VAR 0 5
50461: PUSH
50462: LD_VAR 0 10
50466: PPUSH
50467: CALL_OW 251
50471: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50472: LD_ADDR_VAR 0 6
50476: PUSH
50477: LD_VAR 0 4
50481: PUSH
50482: LD_INT 1
50484: NEG
50485: PPUSH
50486: LD_INT 1
50488: PPUSH
50489: CALL_OW 12
50493: PLUS
50494: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50495: LD_ADDR_VAR 0 7
50499: PUSH
50500: LD_VAR 0 5
50504: PUSH
50505: LD_INT 1
50507: NEG
50508: PPUSH
50509: LD_INT 1
50511: PPUSH
50512: CALL_OW 12
50516: PLUS
50517: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50518: LD_VAR 0 6
50522: PPUSH
50523: LD_VAR 0 7
50527: PPUSH
50528: CALL_OW 488
50532: NOT
50533: IFFALSE 50555
// begin _x := x ;
50535: LD_ADDR_VAR 0 6
50539: PUSH
50540: LD_VAR 0 4
50544: ST_TO_ADDR
// _y := y ;
50545: LD_ADDR_VAR 0 7
50549: PUSH
50550: LD_VAR 0 5
50554: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50555: LD_ADDR_VAR 0 3
50559: PUSH
50560: LD_INT 1
50562: PPUSH
50563: LD_VAR 0 14
50567: PPUSH
50568: CALL_OW 12
50572: ST_TO_ADDR
// case i of 1 :
50573: LD_VAR 0 3
50577: PUSH
50578: LD_INT 1
50580: DOUBLE
50581: EQUAL
50582: IFTRUE 50586
50584: GO 50603
50586: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 10
50596: PPUSH
50597: CALL_OW 115
50601: GO 50664
50603: LD_INT 2
50605: DOUBLE
50606: EQUAL
50607: IFTRUE 50611
50609: GO 50633
50611: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50612: LD_VAR 0 1
50616: PPUSH
50617: LD_VAR 0 6
50621: PPUSH
50622: LD_VAR 0 7
50626: PPUSH
50627: CALL_OW 153
50631: GO 50664
50633: LD_INT 3
50635: DOUBLE
50636: EQUAL
50637: IFTRUE 50641
50639: GO 50663
50641: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50642: LD_VAR 0 1
50646: PPUSH
50647: LD_VAR 0 6
50651: PPUSH
50652: LD_VAR 0 7
50656: PPUSH
50657: CALL_OW 154
50661: GO 50664
50663: POP
// end ;
50664: LD_VAR 0 2
50668: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
// if not unit or not building then
50677: LD_VAR 0 1
50681: NOT
50682: PUSH
50683: LD_VAR 0 2
50687: NOT
50688: OR
50689: IFFALSE 50693
// exit ;
50691: GO 50851
// x := GetX ( building ) ;
50693: LD_ADDR_VAR 0 5
50697: PUSH
50698: LD_VAR 0 2
50702: PPUSH
50703: CALL_OW 250
50707: ST_TO_ADDR
// y := GetY ( building ) ;
50708: LD_ADDR_VAR 0 6
50712: PUSH
50713: LD_VAR 0 2
50717: PPUSH
50718: CALL_OW 251
50722: ST_TO_ADDR
// for i = 0 to 5 do
50723: LD_ADDR_VAR 0 4
50727: PUSH
50728: DOUBLE
50729: LD_INT 0
50731: DEC
50732: ST_TO_ADDR
50733: LD_INT 5
50735: PUSH
50736: FOR_TO
50737: IFFALSE 50849
// begin _x := ShiftX ( x , i , 3 ) ;
50739: LD_ADDR_VAR 0 7
50743: PUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: LD_VAR 0 4
50753: PPUSH
50754: LD_INT 3
50756: PPUSH
50757: CALL_OW 272
50761: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50762: LD_ADDR_VAR 0 8
50766: PUSH
50767: LD_VAR 0 6
50771: PPUSH
50772: LD_VAR 0 4
50776: PPUSH
50777: LD_INT 3
50779: PPUSH
50780: CALL_OW 273
50784: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50785: LD_VAR 0 7
50789: PPUSH
50790: LD_VAR 0 8
50794: PPUSH
50795: CALL_OW 488
50799: NOT
50800: IFFALSE 50804
// continue ;
50802: GO 50736
// if HexInfo ( _x , _y ) = 0 then
50804: LD_VAR 0 7
50808: PPUSH
50809: LD_VAR 0 8
50813: PPUSH
50814: CALL_OW 428
50818: PUSH
50819: LD_INT 0
50821: EQUAL
50822: IFFALSE 50847
// begin ComMoveXY ( unit , _x , _y ) ;
50824: LD_VAR 0 1
50828: PPUSH
50829: LD_VAR 0 7
50833: PPUSH
50834: LD_VAR 0 8
50838: PPUSH
50839: CALL_OW 111
// exit ;
50843: POP
50844: POP
50845: GO 50851
// end ; end ;
50847: GO 50736
50849: POP
50850: POP
// end ;
50851: LD_VAR 0 3
50855: RET
// export function ScanBase ( side , base_area ) ; begin
50856: LD_INT 0
50858: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50859: LD_ADDR_VAR 0 3
50863: PUSH
50864: LD_VAR 0 2
50868: PPUSH
50869: LD_INT 81
50871: PUSH
50872: LD_VAR 0 1
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PPUSH
50881: CALL_OW 70
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 3
50890: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
// result := false ;
50897: LD_ADDR_VAR 0 2
50901: PUSH
50902: LD_INT 0
50904: ST_TO_ADDR
// side := GetSide ( unit ) ;
50905: LD_ADDR_VAR 0 3
50909: PUSH
50910: LD_VAR 0 1
50914: PPUSH
50915: CALL_OW 255
50919: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50920: LD_ADDR_VAR 0 4
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 248
50934: ST_TO_ADDR
// case nat of 1 :
50935: LD_VAR 0 4
50939: PUSH
50940: LD_INT 1
50942: DOUBLE
50943: EQUAL
50944: IFTRUE 50948
50946: GO 50959
50948: POP
// tech := tech_lassight ; 2 :
50949: LD_ADDR_VAR 0 5
50953: PUSH
50954: LD_INT 12
50956: ST_TO_ADDR
50957: GO 50998
50959: LD_INT 2
50961: DOUBLE
50962: EQUAL
50963: IFTRUE 50967
50965: GO 50978
50967: POP
// tech := tech_mortar ; 3 :
50968: LD_ADDR_VAR 0 5
50972: PUSH
50973: LD_INT 41
50975: ST_TO_ADDR
50976: GO 50998
50978: LD_INT 3
50980: DOUBLE
50981: EQUAL
50982: IFTRUE 50986
50984: GO 50997
50986: POP
// tech := tech_bazooka ; end ;
50987: LD_ADDR_VAR 0 5
50991: PUSH
50992: LD_INT 44
50994: ST_TO_ADDR
50995: GO 50998
50997: POP
// if Researched ( side , tech ) then
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 5
51007: PPUSH
51008: CALL_OW 325
51012: IFFALSE 51039
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51014: LD_ADDR_VAR 0 2
51018: PUSH
51019: LD_INT 5
51021: PUSH
51022: LD_INT 8
51024: PUSH
51025: LD_INT 9
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: LIST
51032: PUSH
51033: LD_VAR 0 4
51037: ARRAY
51038: ST_TO_ADDR
// end ;
51039: LD_VAR 0 2
51043: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51044: LD_INT 0
51046: PPUSH
51047: PPUSH
51048: PPUSH
// if not mines then
51049: LD_VAR 0 2
51053: NOT
51054: IFFALSE 51058
// exit ;
51056: GO 51202
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51058: LD_ADDR_VAR 0 5
51062: PUSH
51063: LD_INT 81
51065: PUSH
51066: LD_VAR 0 1
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: LD_INT 21
51080: PUSH
51081: LD_INT 3
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PPUSH
51096: CALL_OW 69
51100: ST_TO_ADDR
// for i in mines do
51101: LD_ADDR_VAR 0 4
51105: PUSH
51106: LD_VAR 0 2
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51200
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51114: LD_VAR 0 4
51118: PUSH
51119: LD_INT 1
51121: ARRAY
51122: PPUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_INT 2
51130: ARRAY
51131: PPUSH
51132: CALL_OW 458
51136: NOT
51137: IFFALSE 51141
// continue ;
51139: GO 51111
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51141: LD_VAR 0 4
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PPUSH
51150: LD_VAR 0 4
51154: PUSH
51155: LD_INT 2
51157: ARRAY
51158: PPUSH
51159: CALL_OW 428
51163: PUSH
51164: LD_VAR 0 5
51168: IN
51169: IFFALSE 51198
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51171: LD_VAR 0 4
51175: PUSH
51176: LD_INT 1
51178: ARRAY
51179: PPUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_INT 2
51187: ARRAY
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL_OW 456
// end ;
51198: GO 51111
51200: POP
51201: POP
// end ;
51202: LD_VAR 0 3
51206: RET
// export function Count ( array ) ; begin
51207: LD_INT 0
51209: PPUSH
// result := array + 0 ;
51210: LD_ADDR_VAR 0 2
51214: PUSH
51215: LD_VAR 0 1
51219: PUSH
51220: LD_INT 0
51222: PLUS
51223: ST_TO_ADDR
// end ;
51224: LD_VAR 0 2
51228: RET
// export function IsEmpty ( building ) ; begin
51229: LD_INT 0
51231: PPUSH
// if not building then
51232: LD_VAR 0 1
51236: NOT
51237: IFFALSE 51241
// exit ;
51239: GO 51284
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51241: LD_ADDR_VAR 0 2
51245: PUSH
51246: LD_VAR 0 1
51250: PUSH
51251: LD_INT 22
51253: PUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL_OW 255
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 58
51270: PUSH
51271: EMPTY
51272: LIST
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 69
51282: IN
51283: ST_TO_ADDR
// end ;
51284: LD_VAR 0 2
51288: RET
// export function IsNotFull ( building ) ; var places ; begin
51289: LD_INT 0
51291: PPUSH
51292: PPUSH
// if not building then
51293: LD_VAR 0 1
51297: NOT
51298: IFFALSE 51302
// exit ;
51300: GO 51330
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51302: LD_ADDR_VAR 0 2
51306: PUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: LD_INT 3
51314: PUSH
51315: LD_INT 62
51317: PUSH
51318: EMPTY
51319: LIST
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: ST_TO_ADDR
// end ;
51330: LD_VAR 0 2
51334: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// tmp := [ ] ;
51341: LD_ADDR_VAR 0 3
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// list := [ ] ;
51348: LD_ADDR_VAR 0 5
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// for i = 16 to 25 do
51355: LD_ADDR_VAR 0 4
51359: PUSH
51360: DOUBLE
51361: LD_INT 16
51363: DEC
51364: ST_TO_ADDR
51365: LD_INT 25
51367: PUSH
51368: FOR_TO
51369: IFFALSE 51442
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51371: LD_ADDR_VAR 0 3
51375: PUSH
51376: LD_VAR 0 3
51380: PUSH
51381: LD_INT 22
51383: PUSH
51384: LD_VAR 0 1
51388: PPUSH
51389: CALL_OW 255
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: PUSH
51398: LD_INT 91
51400: PUSH
51401: LD_VAR 0 1
51405: PUSH
51406: LD_INT 6
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 30
51416: PUSH
51417: LD_VAR 0 4
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: LIST
51430: PUSH
51431: EMPTY
51432: LIST
51433: PPUSH
51434: CALL_OW 69
51438: ADD
51439: ST_TO_ADDR
51440: GO 51368
51442: POP
51443: POP
// for i = 1 to tmp do
51444: LD_ADDR_VAR 0 4
51448: PUSH
51449: DOUBLE
51450: LD_INT 1
51452: DEC
51453: ST_TO_ADDR
51454: LD_VAR 0 3
51458: PUSH
51459: FOR_TO
51460: IFFALSE 51548
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51462: LD_ADDR_VAR 0 5
51466: PUSH
51467: LD_VAR 0 5
51471: PUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_VAR 0 4
51481: ARRAY
51482: PPUSH
51483: CALL_OW 266
51487: PUSH
51488: LD_VAR 0 3
51492: PUSH
51493: LD_VAR 0 4
51497: ARRAY
51498: PPUSH
51499: CALL_OW 250
51503: PUSH
51504: LD_VAR 0 3
51508: PUSH
51509: LD_VAR 0 4
51513: ARRAY
51514: PPUSH
51515: CALL_OW 251
51519: PUSH
51520: LD_VAR 0 3
51524: PUSH
51525: LD_VAR 0 4
51529: ARRAY
51530: PPUSH
51531: CALL_OW 254
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PUSH
51542: EMPTY
51543: LIST
51544: ADD
51545: ST_TO_ADDR
51546: GO 51459
51548: POP
51549: POP
// result := list ;
51550: LD_ADDR_VAR 0 2
51554: PUSH
51555: LD_VAR 0 5
51559: ST_TO_ADDR
// end ;
51560: LD_VAR 0 2
51564: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
51573: PPUSH
// if not factory then
51574: LD_VAR 0 1
51578: NOT
51579: IFFALSE 51583
// exit ;
51581: GO 52176
// if control = control_apeman then
51583: LD_VAR 0 4
51587: PUSH
51588: LD_INT 5
51590: EQUAL
51591: IFFALSE 51700
// begin tmp := UnitsInside ( factory ) ;
51593: LD_ADDR_VAR 0 8
51597: PUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: CALL_OW 313
51607: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51608: LD_VAR 0 8
51612: PPUSH
51613: LD_INT 25
51615: PUSH
51616: LD_INT 12
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PPUSH
51623: CALL_OW 72
51627: NOT
51628: IFFALSE 51638
// control := control_manual ;
51630: LD_ADDR_VAR 0 4
51634: PUSH
51635: LD_INT 1
51637: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51638: LD_ADDR_VAR 0 8
51642: PUSH
51643: LD_VAR 0 1
51647: PPUSH
51648: CALL 51335 0 1
51652: ST_TO_ADDR
// if tmp then
51653: LD_VAR 0 8
51657: IFFALSE 51700
// begin for i in tmp do
51659: LD_ADDR_VAR 0 7
51663: PUSH
51664: LD_VAR 0 8
51668: PUSH
51669: FOR_IN
51670: IFFALSE 51698
// if i [ 1 ] = b_ext_radio then
51672: LD_VAR 0 7
51676: PUSH
51677: LD_INT 1
51679: ARRAY
51680: PUSH
51681: LD_INT 22
51683: EQUAL
51684: IFFALSE 51696
// begin control := control_remote ;
51686: LD_ADDR_VAR 0 4
51690: PUSH
51691: LD_INT 2
51693: ST_TO_ADDR
// break ;
51694: GO 51698
// end ;
51696: GO 51669
51698: POP
51699: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51700: LD_VAR 0 1
51704: PPUSH
51705: LD_VAR 0 2
51709: PPUSH
51710: LD_VAR 0 3
51714: PPUSH
51715: LD_VAR 0 4
51719: PPUSH
51720: LD_VAR 0 5
51724: PPUSH
51725: CALL_OW 448
51729: IFFALSE 51764
// begin result := [ chassis , engine , control , weapon ] ;
51731: LD_ADDR_VAR 0 6
51735: PUSH
51736: LD_VAR 0 2
51740: PUSH
51741: LD_VAR 0 3
51745: PUSH
51746: LD_VAR 0 4
51750: PUSH
51751: LD_VAR 0 5
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: ST_TO_ADDR
// exit ;
51762: GO 52176
// end ; _chassis := AvailableChassisList ( factory ) ;
51764: LD_ADDR_VAR 0 9
51768: PUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: CALL_OW 475
51778: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51779: LD_ADDR_VAR 0 11
51783: PUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: CALL_OW 476
51793: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51794: LD_ADDR_VAR 0 12
51798: PUSH
51799: LD_VAR 0 1
51803: PPUSH
51804: CALL_OW 477
51808: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51809: LD_ADDR_VAR 0 10
51813: PUSH
51814: LD_VAR 0 1
51818: PPUSH
51819: CALL_OW 478
51823: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51824: LD_VAR 0 9
51828: NOT
51829: PUSH
51830: LD_VAR 0 11
51834: NOT
51835: OR
51836: PUSH
51837: LD_VAR 0 12
51841: NOT
51842: OR
51843: PUSH
51844: LD_VAR 0 10
51848: NOT
51849: OR
51850: IFFALSE 51885
// begin result := [ chassis , engine , control , weapon ] ;
51852: LD_ADDR_VAR 0 6
51856: PUSH
51857: LD_VAR 0 2
51861: PUSH
51862: LD_VAR 0 3
51866: PUSH
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 5
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: ST_TO_ADDR
// exit ;
51883: GO 52176
// end ; if not chassis in _chassis then
51885: LD_VAR 0 2
51889: PUSH
51890: LD_VAR 0 9
51894: IN
51895: NOT
51896: IFFALSE 51922
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51898: LD_ADDR_VAR 0 2
51902: PUSH
51903: LD_VAR 0 9
51907: PUSH
51908: LD_INT 1
51910: PPUSH
51911: LD_VAR 0 9
51915: PPUSH
51916: CALL_OW 12
51920: ARRAY
51921: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51922: LD_VAR 0 2
51926: PPUSH
51927: LD_VAR 0 3
51931: PPUSH
51932: CALL 52181 0 2
51936: NOT
51937: IFFALSE 51996
// repeat engine := _engine [ 1 ] ;
51939: LD_ADDR_VAR 0 3
51943: PUSH
51944: LD_VAR 0 11
51948: PUSH
51949: LD_INT 1
51951: ARRAY
51952: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51953: LD_ADDR_VAR 0 11
51957: PUSH
51958: LD_VAR 0 11
51962: PPUSH
51963: LD_INT 1
51965: PPUSH
51966: CALL_OW 3
51970: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51971: LD_VAR 0 2
51975: PPUSH
51976: LD_VAR 0 3
51980: PPUSH
51981: CALL 52181 0 2
51985: PUSH
51986: LD_VAR 0 11
51990: PUSH
51991: EMPTY
51992: EQUAL
51993: OR
51994: IFFALSE 51939
// if not control in _control then
51996: LD_VAR 0 4
52000: PUSH
52001: LD_VAR 0 12
52005: IN
52006: NOT
52007: IFFALSE 52033
// control := _control [ rand ( 1 , _control ) ] ;
52009: LD_ADDR_VAR 0 4
52013: PUSH
52014: LD_VAR 0 12
52018: PUSH
52019: LD_INT 1
52021: PPUSH
52022: LD_VAR 0 12
52026: PPUSH
52027: CALL_OW 12
52031: ARRAY
52032: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52033: LD_VAR 0 2
52037: PPUSH
52038: LD_VAR 0 5
52042: PPUSH
52043: CALL 52401 0 2
52047: NOT
52048: IFFALSE 52107
// repeat weapon := _weapon [ 1 ] ;
52050: LD_ADDR_VAR 0 5
52054: PUSH
52055: LD_VAR 0 10
52059: PUSH
52060: LD_INT 1
52062: ARRAY
52063: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52064: LD_ADDR_VAR 0 10
52068: PUSH
52069: LD_VAR 0 10
52073: PPUSH
52074: LD_INT 1
52076: PPUSH
52077: CALL_OW 3
52081: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52082: LD_VAR 0 2
52086: PPUSH
52087: LD_VAR 0 5
52091: PPUSH
52092: CALL 52401 0 2
52096: PUSH
52097: LD_VAR 0 10
52101: PUSH
52102: EMPTY
52103: EQUAL
52104: OR
52105: IFFALSE 52050
// result := [ ] ;
52107: LD_ADDR_VAR 0 6
52111: PUSH
52112: EMPTY
52113: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52114: LD_VAR 0 1
52118: PPUSH
52119: LD_VAR 0 2
52123: PPUSH
52124: LD_VAR 0 3
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: LD_VAR 0 5
52138: PPUSH
52139: CALL_OW 448
52143: IFFALSE 52176
// result := [ chassis , engine , control , weapon ] ;
52145: LD_ADDR_VAR 0 6
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: LD_VAR 0 3
52159: PUSH
52160: LD_VAR 0 4
52164: PUSH
52165: LD_VAR 0 5
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: ST_TO_ADDR
// end ;
52176: LD_VAR 0 6
52180: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52181: LD_INT 0
52183: PPUSH
// if not chassis or not engine then
52184: LD_VAR 0 1
52188: NOT
52189: PUSH
52190: LD_VAR 0 2
52194: NOT
52195: OR
52196: IFFALSE 52200
// exit ;
52198: GO 52396
// case engine of engine_solar :
52200: LD_VAR 0 2
52204: PUSH
52205: LD_INT 2
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52251
52213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 11
52221: PUSH
52222: LD_INT 12
52224: PUSH
52225: LD_INT 13
52227: PUSH
52228: LD_INT 14
52230: PUSH
52231: LD_INT 1
52233: PUSH
52234: LD_INT 2
52236: PUSH
52237: LD_INT 3
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: ST_TO_ADDR
52249: GO 52380
52251: LD_INT 1
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52259
52257: GO 52321
52259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52260: LD_ADDR_VAR 0 3
52264: PUSH
52265: LD_INT 11
52267: PUSH
52268: LD_INT 12
52270: PUSH
52271: LD_INT 13
52273: PUSH
52274: LD_INT 14
52276: PUSH
52277: LD_INT 1
52279: PUSH
52280: LD_INT 2
52282: PUSH
52283: LD_INT 3
52285: PUSH
52286: LD_INT 4
52288: PUSH
52289: LD_INT 5
52291: PUSH
52292: LD_INT 21
52294: PUSH
52295: LD_INT 23
52297: PUSH
52298: LD_INT 22
52300: PUSH
52301: LD_INT 24
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: ST_TO_ADDR
52319: GO 52380
52321: LD_INT 3
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52329
52327: GO 52379
52329: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52330: LD_ADDR_VAR 0 3
52334: PUSH
52335: LD_INT 13
52337: PUSH
52338: LD_INT 14
52340: PUSH
52341: LD_INT 2
52343: PUSH
52344: LD_INT 3
52346: PUSH
52347: LD_INT 4
52349: PUSH
52350: LD_INT 5
52352: PUSH
52353: LD_INT 21
52355: PUSH
52356: LD_INT 22
52358: PUSH
52359: LD_INT 23
52361: PUSH
52362: LD_INT 24
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: LIST
52372: LIST
52373: LIST
52374: LIST
52375: LIST
52376: ST_TO_ADDR
52377: GO 52380
52379: POP
// result := ( chassis in result ) ;
52380: LD_ADDR_VAR 0 3
52384: PUSH
52385: LD_VAR 0 1
52389: PUSH
52390: LD_VAR 0 3
52394: IN
52395: ST_TO_ADDR
// end ;
52396: LD_VAR 0 3
52400: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52401: LD_INT 0
52403: PPUSH
// if not chassis or not weapon then
52404: LD_VAR 0 1
52408: NOT
52409: PUSH
52410: LD_VAR 0 2
52414: NOT
52415: OR
52416: IFFALSE 52420
// exit ;
52418: GO 53480
// case weapon of us_machine_gun :
52420: LD_VAR 0 2
52424: PUSH
52425: LD_INT 2
52427: DOUBLE
52428: EQUAL
52429: IFTRUE 52433
52431: GO 52463
52433: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52434: LD_ADDR_VAR 0 3
52438: PUSH
52439: LD_INT 1
52441: PUSH
52442: LD_INT 2
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: LIST
52460: ST_TO_ADDR
52461: GO 53464
52463: LD_INT 3
52465: DOUBLE
52466: EQUAL
52467: IFTRUE 52471
52469: GO 52501
52471: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52472: LD_ADDR_VAR 0 3
52476: PUSH
52477: LD_INT 1
52479: PUSH
52480: LD_INT 2
52482: PUSH
52483: LD_INT 3
52485: PUSH
52486: LD_INT 4
52488: PUSH
52489: LD_INT 5
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: ST_TO_ADDR
52499: GO 53464
52501: LD_INT 11
52503: DOUBLE
52504: EQUAL
52505: IFTRUE 52509
52507: GO 52539
52509: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52510: LD_ADDR_VAR 0 3
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: LD_INT 2
52520: PUSH
52521: LD_INT 3
52523: PUSH
52524: LD_INT 4
52526: PUSH
52527: LD_INT 5
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: ST_TO_ADDR
52537: GO 53464
52539: LD_INT 4
52541: DOUBLE
52542: EQUAL
52543: IFTRUE 52547
52545: GO 52573
52547: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_INT 2
52555: PUSH
52556: LD_INT 3
52558: PUSH
52559: LD_INT 4
52561: PUSH
52562: LD_INT 5
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: ST_TO_ADDR
52571: GO 53464
52573: LD_INT 5
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52581
52579: GO 52607
52581: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52582: LD_ADDR_VAR 0 3
52586: PUSH
52587: LD_INT 2
52589: PUSH
52590: LD_INT 3
52592: PUSH
52593: LD_INT 4
52595: PUSH
52596: LD_INT 5
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
52605: GO 53464
52607: LD_INT 9
52609: DOUBLE
52610: EQUAL
52611: IFTRUE 52615
52613: GO 52641
52615: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52616: LD_ADDR_VAR 0 3
52620: PUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 3
52626: PUSH
52627: LD_INT 4
52629: PUSH
52630: LD_INT 5
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: ST_TO_ADDR
52639: GO 53464
52641: LD_INT 7
52643: DOUBLE
52644: EQUAL
52645: IFTRUE 52649
52647: GO 52675
52649: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_INT 2
52657: PUSH
52658: LD_INT 3
52660: PUSH
52661: LD_INT 4
52663: PUSH
52664: LD_INT 5
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 53464
52675: LD_INT 12
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52709
52683: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 2
52691: PUSH
52692: LD_INT 3
52694: PUSH
52695: LD_INT 4
52697: PUSH
52698: LD_INT 5
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: ST_TO_ADDR
52707: GO 53464
52709: LD_INT 13
52711: DOUBLE
52712: EQUAL
52713: IFTRUE 52717
52715: GO 52743
52717: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52718: LD_ADDR_VAR 0 3
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: LD_INT 3
52728: PUSH
52729: LD_INT 4
52731: PUSH
52732: LD_INT 5
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: ST_TO_ADDR
52741: GO 53464
52743: LD_INT 14
52745: DOUBLE
52746: EQUAL
52747: IFTRUE 52751
52749: GO 52769
52751: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52752: LD_ADDR_VAR 0 3
52756: PUSH
52757: LD_INT 4
52759: PUSH
52760: LD_INT 5
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: ST_TO_ADDR
52767: GO 53464
52769: LD_INT 6
52771: DOUBLE
52772: EQUAL
52773: IFTRUE 52777
52775: GO 52795
52777: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52778: LD_ADDR_VAR 0 3
52782: PUSH
52783: LD_INT 4
52785: PUSH
52786: LD_INT 5
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: ST_TO_ADDR
52793: GO 53464
52795: LD_INT 10
52797: DOUBLE
52798: EQUAL
52799: IFTRUE 52803
52801: GO 52821
52803: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_INT 4
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: ST_TO_ADDR
52819: GO 53464
52821: LD_INT 22
52823: DOUBLE
52824: EQUAL
52825: IFTRUE 52829
52827: GO 52855
52829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52830: LD_ADDR_VAR 0 3
52834: PUSH
52835: LD_INT 11
52837: PUSH
52838: LD_INT 12
52840: PUSH
52841: LD_INT 13
52843: PUSH
52844: LD_INT 14
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: ST_TO_ADDR
52853: GO 53464
52855: LD_INT 23
52857: DOUBLE
52858: EQUAL
52859: IFTRUE 52863
52861: GO 52889
52863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52864: LD_ADDR_VAR 0 3
52868: PUSH
52869: LD_INT 11
52871: PUSH
52872: LD_INT 12
52874: PUSH
52875: LD_INT 13
52877: PUSH
52878: LD_INT 14
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: LIST
52885: LIST
52886: ST_TO_ADDR
52887: GO 53464
52889: LD_INT 24
52891: DOUBLE
52892: EQUAL
52893: IFTRUE 52897
52895: GO 52923
52897: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52898: LD_ADDR_VAR 0 3
52902: PUSH
52903: LD_INT 11
52905: PUSH
52906: LD_INT 12
52908: PUSH
52909: LD_INT 13
52911: PUSH
52912: LD_INT 14
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: LIST
52920: ST_TO_ADDR
52921: GO 53464
52923: LD_INT 30
52925: DOUBLE
52926: EQUAL
52927: IFTRUE 52931
52929: GO 52957
52931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52932: LD_ADDR_VAR 0 3
52936: PUSH
52937: LD_INT 11
52939: PUSH
52940: LD_INT 12
52942: PUSH
52943: LD_INT 13
52945: PUSH
52946: LD_INT 14
52948: PUSH
52949: EMPTY
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: ST_TO_ADDR
52955: GO 53464
52957: LD_INT 25
52959: DOUBLE
52960: EQUAL
52961: IFTRUE 52965
52963: GO 52983
52965: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: LD_INT 13
52973: PUSH
52974: LD_INT 14
52976: PUSH
52977: EMPTY
52978: LIST
52979: LIST
52980: ST_TO_ADDR
52981: GO 53464
52983: LD_INT 27
52985: DOUBLE
52986: EQUAL
52987: IFTRUE 52991
52989: GO 53009
52991: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52992: LD_ADDR_VAR 0 3
52996: PUSH
52997: LD_INT 13
52999: PUSH
53000: LD_INT 14
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: ST_TO_ADDR
53007: GO 53464
53009: LD_INT 92
53011: DOUBLE
53012: EQUAL
53013: IFTRUE 53017
53015: GO 53043
53017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53018: LD_ADDR_VAR 0 3
53022: PUSH
53023: LD_INT 11
53025: PUSH
53026: LD_INT 12
53028: PUSH
53029: LD_INT 13
53031: PUSH
53032: LD_INT 14
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: ST_TO_ADDR
53041: GO 53464
53043: LD_INT 28
53045: DOUBLE
53046: EQUAL
53047: IFTRUE 53051
53049: GO 53069
53051: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53052: LD_ADDR_VAR 0 3
53056: PUSH
53057: LD_INT 13
53059: PUSH
53060: LD_INT 14
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: ST_TO_ADDR
53067: GO 53464
53069: LD_INT 29
53071: DOUBLE
53072: EQUAL
53073: IFTRUE 53077
53075: GO 53095
53077: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_INT 13
53085: PUSH
53086: LD_INT 14
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53464
53095: LD_INT 31
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53121
53103: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 13
53111: PUSH
53112: LD_INT 14
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: ST_TO_ADDR
53119: GO 53464
53121: LD_INT 26
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53147
53129: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_INT 13
53137: PUSH
53138: LD_INT 14
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
53145: GO 53464
53147: LD_INT 42
53149: DOUBLE
53150: EQUAL
53151: IFTRUE 53155
53153: GO 53181
53155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: LD_INT 21
53163: PUSH
53164: LD_INT 22
53166: PUSH
53167: LD_INT 23
53169: PUSH
53170: LD_INT 24
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: ST_TO_ADDR
53179: GO 53464
53181: LD_INT 43
53183: DOUBLE
53184: EQUAL
53185: IFTRUE 53189
53187: GO 53215
53189: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53190: LD_ADDR_VAR 0 3
53194: PUSH
53195: LD_INT 21
53197: PUSH
53198: LD_INT 22
53200: PUSH
53201: LD_INT 23
53203: PUSH
53204: LD_INT 24
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: LIST
53211: LIST
53212: ST_TO_ADDR
53213: GO 53464
53215: LD_INT 44
53217: DOUBLE
53218: EQUAL
53219: IFTRUE 53223
53221: GO 53249
53223: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53224: LD_ADDR_VAR 0 3
53228: PUSH
53229: LD_INT 21
53231: PUSH
53232: LD_INT 22
53234: PUSH
53235: LD_INT 23
53237: PUSH
53238: LD_INT 24
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: LIST
53246: ST_TO_ADDR
53247: GO 53464
53249: LD_INT 45
53251: DOUBLE
53252: EQUAL
53253: IFTRUE 53257
53255: GO 53283
53257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_INT 21
53265: PUSH
53266: LD_INT 22
53268: PUSH
53269: LD_INT 23
53271: PUSH
53272: LD_INT 24
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: LIST
53280: ST_TO_ADDR
53281: GO 53464
53283: LD_INT 49
53285: DOUBLE
53286: EQUAL
53287: IFTRUE 53291
53289: GO 53317
53291: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53292: LD_ADDR_VAR 0 3
53296: PUSH
53297: LD_INT 21
53299: PUSH
53300: LD_INT 22
53302: PUSH
53303: LD_INT 23
53305: PUSH
53306: LD_INT 24
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53464
53317: LD_INT 51
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53351
53325: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 21
53333: PUSH
53334: LD_INT 22
53336: PUSH
53337: LD_INT 23
53339: PUSH
53340: LD_INT 24
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: ST_TO_ADDR
53349: GO 53464
53351: LD_INT 52
53353: DOUBLE
53354: EQUAL
53355: IFTRUE 53359
53357: GO 53385
53359: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53360: LD_ADDR_VAR 0 3
53364: PUSH
53365: LD_INT 21
53367: PUSH
53368: LD_INT 22
53370: PUSH
53371: LD_INT 23
53373: PUSH
53374: LD_INT 24
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: ST_TO_ADDR
53383: GO 53464
53385: LD_INT 53
53387: DOUBLE
53388: EQUAL
53389: IFTRUE 53393
53391: GO 53411
53393: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53394: LD_ADDR_VAR 0 3
53398: PUSH
53399: LD_INT 23
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53464
53411: LD_INT 46
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53437
53419: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 23
53427: PUSH
53428: LD_INT 24
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: ST_TO_ADDR
53435: GO 53464
53437: LD_INT 47
53439: DOUBLE
53440: EQUAL
53441: IFTRUE 53445
53443: GO 53463
53445: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 24
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: ST_TO_ADDR
53461: GO 53464
53463: POP
// result := ( chassis in result ) ;
53464: LD_ADDR_VAR 0 3
53468: PUSH
53469: LD_VAR 0 1
53473: PUSH
53474: LD_VAR 0 3
53478: IN
53479: ST_TO_ADDR
// end ;
53480: LD_VAR 0 3
53484: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53485: LD_INT 0
53487: PPUSH
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
53492: PPUSH
53493: PPUSH
// result := array ;
53494: LD_ADDR_VAR 0 5
53498: PUSH
53499: LD_VAR 0 1
53503: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53504: LD_VAR 0 1
53508: NOT
53509: PUSH
53510: LD_VAR 0 2
53514: NOT
53515: OR
53516: PUSH
53517: LD_VAR 0 3
53521: NOT
53522: OR
53523: PUSH
53524: LD_VAR 0 2
53528: PUSH
53529: LD_VAR 0 1
53533: GREATER
53534: OR
53535: PUSH
53536: LD_VAR 0 3
53540: PUSH
53541: LD_VAR 0 1
53545: GREATER
53546: OR
53547: IFFALSE 53551
// exit ;
53549: GO 53847
// if direction then
53551: LD_VAR 0 4
53555: IFFALSE 53619
// begin d := 1 ;
53557: LD_ADDR_VAR 0 9
53561: PUSH
53562: LD_INT 1
53564: ST_TO_ADDR
// if i_from > i_to then
53565: LD_VAR 0 2
53569: PUSH
53570: LD_VAR 0 3
53574: GREATER
53575: IFFALSE 53601
// length := ( array - i_from ) + i_to else
53577: LD_ADDR_VAR 0 11
53581: PUSH
53582: LD_VAR 0 1
53586: PUSH
53587: LD_VAR 0 2
53591: MINUS
53592: PUSH
53593: LD_VAR 0 3
53597: PLUS
53598: ST_TO_ADDR
53599: GO 53617
// length := i_to - i_from ;
53601: LD_ADDR_VAR 0 11
53605: PUSH
53606: LD_VAR 0 3
53610: PUSH
53611: LD_VAR 0 2
53615: MINUS
53616: ST_TO_ADDR
// end else
53617: GO 53680
// begin d := - 1 ;
53619: LD_ADDR_VAR 0 9
53623: PUSH
53624: LD_INT 1
53626: NEG
53627: ST_TO_ADDR
// if i_from > i_to then
53628: LD_VAR 0 2
53632: PUSH
53633: LD_VAR 0 3
53637: GREATER
53638: IFFALSE 53658
// length := i_from - i_to else
53640: LD_ADDR_VAR 0 11
53644: PUSH
53645: LD_VAR 0 2
53649: PUSH
53650: LD_VAR 0 3
53654: MINUS
53655: ST_TO_ADDR
53656: GO 53680
// length := ( array - i_to ) + i_from ;
53658: LD_ADDR_VAR 0 11
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_VAR 0 3
53672: MINUS
53673: PUSH
53674: LD_VAR 0 2
53678: PLUS
53679: ST_TO_ADDR
// end ; if not length then
53680: LD_VAR 0 11
53684: NOT
53685: IFFALSE 53689
// exit ;
53687: GO 53847
// tmp := array ;
53689: LD_ADDR_VAR 0 10
53693: PUSH
53694: LD_VAR 0 1
53698: ST_TO_ADDR
// for i = 1 to length do
53699: LD_ADDR_VAR 0 6
53703: PUSH
53704: DOUBLE
53705: LD_INT 1
53707: DEC
53708: ST_TO_ADDR
53709: LD_VAR 0 11
53713: PUSH
53714: FOR_TO
53715: IFFALSE 53835
// begin for j = 1 to array do
53717: LD_ADDR_VAR 0 7
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 1
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53821
// begin k := j + d ;
53735: LD_ADDR_VAR 0 8
53739: PUSH
53740: LD_VAR 0 7
53744: PUSH
53745: LD_VAR 0 9
53749: PLUS
53750: ST_TO_ADDR
// if k > array then
53751: LD_VAR 0 8
53755: PUSH
53756: LD_VAR 0 1
53760: GREATER
53761: IFFALSE 53771
// k := 1 ;
53763: LD_ADDR_VAR 0 8
53767: PUSH
53768: LD_INT 1
53770: ST_TO_ADDR
// if not k then
53771: LD_VAR 0 8
53775: NOT
53776: IFFALSE 53788
// k := array ;
53778: LD_ADDR_VAR 0 8
53782: PUSH
53783: LD_VAR 0 1
53787: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53788: LD_ADDR_VAR 0 10
53792: PUSH
53793: LD_VAR 0 10
53797: PPUSH
53798: LD_VAR 0 8
53802: PPUSH
53803: LD_VAR 0 1
53807: PUSH
53808: LD_VAR 0 7
53812: ARRAY
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// end ;
53819: GO 53732
53821: POP
53822: POP
// array := tmp ;
53823: LD_ADDR_VAR 0 1
53827: PUSH
53828: LD_VAR 0 10
53832: ST_TO_ADDR
// end ;
53833: GO 53714
53835: POP
53836: POP
// result := array ;
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 1
53846: ST_TO_ADDR
// end ;
53847: LD_VAR 0 5
53851: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53852: LD_INT 0
53854: PPUSH
53855: PPUSH
// result := 0 ;
53856: LD_ADDR_VAR 0 3
53860: PUSH
53861: LD_INT 0
53863: ST_TO_ADDR
// if not array or not value in array then
53864: LD_VAR 0 1
53868: NOT
53869: PUSH
53870: LD_VAR 0 2
53874: PUSH
53875: LD_VAR 0 1
53879: IN
53880: NOT
53881: OR
53882: IFFALSE 53886
// exit ;
53884: GO 53940
// for i = 1 to array do
53886: LD_ADDR_VAR 0 4
53890: PUSH
53891: DOUBLE
53892: LD_INT 1
53894: DEC
53895: ST_TO_ADDR
53896: LD_VAR 0 1
53900: PUSH
53901: FOR_TO
53902: IFFALSE 53938
// if value = array [ i ] then
53904: LD_VAR 0 2
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: EQUAL
53920: IFFALSE 53936
// begin result := i ;
53922: LD_ADDR_VAR 0 3
53926: PUSH
53927: LD_VAR 0 4
53931: ST_TO_ADDR
// exit ;
53932: POP
53933: POP
53934: GO 53940
// end ;
53936: GO 53901
53938: POP
53939: POP
// end ;
53940: LD_VAR 0 3
53944: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53945: LD_INT 0
53947: PPUSH
// vc_chassis := chassis ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_VAR 0 1
53957: ST_TO_ADDR
// vc_engine := engine ;
53958: LD_ADDR_OWVAR 39
53962: PUSH
53963: LD_VAR 0 2
53967: ST_TO_ADDR
// vc_control := control ;
53968: LD_ADDR_OWVAR 38
53972: PUSH
53973: LD_VAR 0 3
53977: ST_TO_ADDR
// vc_weapon := weapon ;
53978: LD_ADDR_OWVAR 40
53982: PUSH
53983: LD_VAR 0 4
53987: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53988: LD_ADDR_OWVAR 41
53992: PUSH
53993: LD_VAR 0 5
53997: ST_TO_ADDR
// end ;
53998: LD_VAR 0 6
54002: RET
// export function WantPlant ( unit ) ; var task ; begin
54003: LD_INT 0
54005: PPUSH
54006: PPUSH
// result := false ;
54007: LD_ADDR_VAR 0 2
54011: PUSH
54012: LD_INT 0
54014: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: CALL_OW 437
54029: ST_TO_ADDR
// if task then
54030: LD_VAR 0 3
54034: IFFALSE 54062
// if task [ 1 ] [ 1 ] = p then
54036: LD_VAR 0 3
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: PUSH
54045: LD_INT 1
54047: ARRAY
54048: PUSH
54049: LD_STRING p
54051: EQUAL
54052: IFFALSE 54062
// result := true ;
54054: LD_ADDR_VAR 0 2
54058: PUSH
54059: LD_INT 1
54061: ST_TO_ADDR
// end ;
54062: LD_VAR 0 2
54066: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54067: LD_INT 0
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
// if pos < 1 then
54073: LD_VAR 0 2
54077: PUSH
54078: LD_INT 1
54080: LESS
54081: IFFALSE 54085
// exit ;
54083: GO 54388
// if pos = 1 then
54085: LD_VAR 0 2
54089: PUSH
54090: LD_INT 1
54092: EQUAL
54093: IFFALSE 54126
// result := Replace ( arr , pos [ 1 ] , value ) else
54095: LD_ADDR_VAR 0 4
54099: PUSH
54100: LD_VAR 0 1
54104: PPUSH
54105: LD_VAR 0 2
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PPUSH
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 1
54123: ST_TO_ADDR
54124: GO 54388
// begin tmp := arr ;
54126: LD_ADDR_VAR 0 6
54130: PUSH
54131: LD_VAR 0 1
54135: ST_TO_ADDR
// s_arr := [ tmp ] ;
54136: LD_ADDR_VAR 0 7
54140: PUSH
54141: LD_VAR 0 6
54145: PUSH
54146: EMPTY
54147: LIST
54148: ST_TO_ADDR
// for i = 1 to pos - 1 do
54149: LD_ADDR_VAR 0 5
54153: PUSH
54154: DOUBLE
54155: LD_INT 1
54157: DEC
54158: ST_TO_ADDR
54159: LD_VAR 0 2
54163: PUSH
54164: LD_INT 1
54166: MINUS
54167: PUSH
54168: FOR_TO
54169: IFFALSE 54214
// begin tmp := tmp [ pos [ i ] ] ;
54171: LD_ADDR_VAR 0 6
54175: PUSH
54176: LD_VAR 0 6
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_VAR 0 5
54190: ARRAY
54191: ARRAY
54192: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 7
54202: PUSH
54203: LD_VAR 0 6
54207: PUSH
54208: EMPTY
54209: LIST
54210: ADD
54211: ST_TO_ADDR
// end ;
54212: GO 54168
54214: POP
54215: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54216: LD_ADDR_VAR 0 6
54220: PUSH
54221: LD_VAR 0 6
54225: PPUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_VAR 0 2
54235: ARRAY
54236: PPUSH
54237: LD_VAR 0 3
54241: PPUSH
54242: CALL_OW 1
54246: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54247: LD_ADDR_VAR 0 7
54251: PUSH
54252: LD_VAR 0 7
54256: PPUSH
54257: LD_VAR 0 7
54261: PPUSH
54262: LD_VAR 0 6
54266: PPUSH
54267: CALL_OW 1
54271: ST_TO_ADDR
// for i = s_arr downto 2 do
54272: LD_ADDR_VAR 0 5
54276: PUSH
54277: DOUBLE
54278: LD_VAR 0 7
54282: INC
54283: ST_TO_ADDR
54284: LD_INT 2
54286: PUSH
54287: FOR_DOWNTO
54288: IFFALSE 54372
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54290: LD_ADDR_VAR 0 6
54294: PUSH
54295: LD_VAR 0 7
54299: PUSH
54300: LD_VAR 0 5
54304: PUSH
54305: LD_INT 1
54307: MINUS
54308: ARRAY
54309: PPUSH
54310: LD_VAR 0 2
54314: PUSH
54315: LD_VAR 0 5
54319: PUSH
54320: LD_INT 1
54322: MINUS
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 7
54329: PUSH
54330: LD_VAR 0 5
54334: ARRAY
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54341: LD_ADDR_VAR 0 7
54345: PUSH
54346: LD_VAR 0 7
54350: PPUSH
54351: LD_VAR 0 5
54355: PUSH
54356: LD_INT 1
54358: MINUS
54359: PPUSH
54360: LD_VAR 0 6
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// end ;
54370: GO 54287
54372: POP
54373: POP
// result := s_arr [ 1 ] ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 7
54383: PUSH
54384: LD_INT 1
54386: ARRAY
54387: ST_TO_ADDR
// end ; end ;
54388: LD_VAR 0 4
54392: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54393: LD_INT 0
54395: PPUSH
54396: PPUSH
// if not list then
54397: LD_VAR 0 1
54401: NOT
54402: IFFALSE 54406
// exit ;
54404: GO 54497
// i := list [ pos1 ] ;
54406: LD_ADDR_VAR 0 5
54410: PUSH
54411: LD_VAR 0 1
54415: PUSH
54416: LD_VAR 0 2
54420: ARRAY
54421: ST_TO_ADDR
// if not i then
54422: LD_VAR 0 5
54426: NOT
54427: IFFALSE 54431
// exit ;
54429: GO 54497
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54431: LD_ADDR_VAR 0 1
54435: PUSH
54436: LD_VAR 0 1
54440: PPUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: LD_VAR 0 1
54450: PUSH
54451: LD_VAR 0 3
54455: ARRAY
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54462: LD_ADDR_VAR 0 1
54466: PUSH
54467: LD_VAR 0 1
54471: PPUSH
54472: LD_VAR 0 3
54476: PPUSH
54477: LD_VAR 0 5
54481: PPUSH
54482: CALL_OW 1
54486: ST_TO_ADDR
// result := list ;
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: LD_VAR 0 1
54496: ST_TO_ADDR
// end ;
54497: LD_VAR 0 4
54501: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54502: LD_INT 0
54504: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54505: LD_ADDR_VAR 0 5
54509: PUSH
54510: LD_VAR 0 1
54514: PPUSH
54515: CALL_OW 250
54519: PPUSH
54520: LD_VAR 0 1
54524: PPUSH
54525: CALL_OW 251
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_VAR 0 3
54539: PPUSH
54540: LD_VAR 0 4
54544: PPUSH
54545: CALL 54555 0 5
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 5
54554: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if not list then
54561: LD_VAR 0 3
54565: NOT
54566: IFFALSE 54570
// exit ;
54568: GO 54958
// result := [ ] ;
54570: LD_ADDR_VAR 0 6
54574: PUSH
54575: EMPTY
54576: ST_TO_ADDR
// for i in list do
54577: LD_ADDR_VAR 0 7
54581: PUSH
54582: LD_VAR 0 3
54586: PUSH
54587: FOR_IN
54588: IFFALSE 54790
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54590: LD_ADDR_VAR 0 9
54594: PUSH
54595: LD_VAR 0 7
54599: PPUSH
54600: LD_VAR 0 1
54604: PPUSH
54605: LD_VAR 0 2
54609: PPUSH
54610: CALL_OW 297
54614: ST_TO_ADDR
// if not result then
54615: LD_VAR 0 6
54619: NOT
54620: IFFALSE 54646
// result := [ [ i , tmp ] ] else
54622: LD_ADDR_VAR 0 6
54626: PUSH
54627: LD_VAR 0 7
54631: PUSH
54632: LD_VAR 0 9
54636: PUSH
54637: EMPTY
54638: LIST
54639: LIST
54640: PUSH
54641: EMPTY
54642: LIST
54643: ST_TO_ADDR
54644: GO 54788
// begin if result [ result ] [ 2 ] < tmp then
54646: LD_VAR 0 6
54650: PUSH
54651: LD_VAR 0 6
54655: ARRAY
54656: PUSH
54657: LD_INT 2
54659: ARRAY
54660: PUSH
54661: LD_VAR 0 9
54665: LESS
54666: IFFALSE 54708
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54668: LD_ADDR_VAR 0 6
54672: PUSH
54673: LD_VAR 0 6
54677: PPUSH
54678: LD_VAR 0 6
54682: PUSH
54683: LD_INT 1
54685: PLUS
54686: PPUSH
54687: LD_VAR 0 7
54691: PUSH
54692: LD_VAR 0 9
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: PPUSH
54701: CALL_OW 2
54705: ST_TO_ADDR
54706: GO 54788
// for j = 1 to result do
54708: LD_ADDR_VAR 0 8
54712: PUSH
54713: DOUBLE
54714: LD_INT 1
54716: DEC
54717: ST_TO_ADDR
54718: LD_VAR 0 6
54722: PUSH
54723: FOR_TO
54724: IFFALSE 54786
// begin if tmp < result [ j ] [ 2 ] then
54726: LD_VAR 0 9
54730: PUSH
54731: LD_VAR 0 6
54735: PUSH
54736: LD_VAR 0 8
54740: ARRAY
54741: PUSH
54742: LD_INT 2
54744: ARRAY
54745: LESS
54746: IFFALSE 54784
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54748: LD_ADDR_VAR 0 6
54752: PUSH
54753: LD_VAR 0 6
54757: PPUSH
54758: LD_VAR 0 8
54762: PPUSH
54763: LD_VAR 0 7
54767: PUSH
54768: LD_VAR 0 9
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PPUSH
54777: CALL_OW 2
54781: ST_TO_ADDR
// break ;
54782: GO 54786
// end ; end ;
54784: GO 54723
54786: POP
54787: POP
// end ; end ;
54788: GO 54587
54790: POP
54791: POP
// if result and not asc then
54792: LD_VAR 0 6
54796: PUSH
54797: LD_VAR 0 4
54801: NOT
54802: AND
54803: IFFALSE 54878
// begin tmp := result ;
54805: LD_ADDR_VAR 0 9
54809: PUSH
54810: LD_VAR 0 6
54814: ST_TO_ADDR
// for i = tmp downto 1 do
54815: LD_ADDR_VAR 0 7
54819: PUSH
54820: DOUBLE
54821: LD_VAR 0 9
54825: INC
54826: ST_TO_ADDR
54827: LD_INT 1
54829: PUSH
54830: FOR_DOWNTO
54831: IFFALSE 54876
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54833: LD_ADDR_VAR 0 6
54837: PUSH
54838: LD_VAR 0 6
54842: PPUSH
54843: LD_VAR 0 9
54847: PUSH
54848: LD_VAR 0 7
54852: MINUS
54853: PUSH
54854: LD_INT 1
54856: PLUS
54857: PPUSH
54858: LD_VAR 0 9
54862: PUSH
54863: LD_VAR 0 7
54867: ARRAY
54868: PPUSH
54869: CALL_OW 1
54873: ST_TO_ADDR
54874: GO 54830
54876: POP
54877: POP
// end ; tmp := [ ] ;
54878: LD_ADDR_VAR 0 9
54882: PUSH
54883: EMPTY
54884: ST_TO_ADDR
// if mode then
54885: LD_VAR 0 5
54889: IFFALSE 54958
// begin for i = 1 to result do
54891: LD_ADDR_VAR 0 7
54895: PUSH
54896: DOUBLE
54897: LD_INT 1
54899: DEC
54900: ST_TO_ADDR
54901: LD_VAR 0 6
54905: PUSH
54906: FOR_TO
54907: IFFALSE 54946
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54909: LD_ADDR_VAR 0 9
54913: PUSH
54914: LD_VAR 0 9
54918: PPUSH
54919: LD_VAR 0 7
54923: PPUSH
54924: LD_VAR 0 6
54928: PUSH
54929: LD_VAR 0 7
54933: ARRAY
54934: PUSH
54935: LD_INT 1
54937: ARRAY
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
54944: GO 54906
54946: POP
54947: POP
// result := tmp ;
54948: LD_ADDR_VAR 0 6
54952: PUSH
54953: LD_VAR 0 9
54957: ST_TO_ADDR
// end ; end ;
54958: LD_VAR 0 6
54962: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54963: LD_INT 0
54965: PPUSH
54966: PPUSH
54967: PPUSH
54968: PPUSH
54969: PPUSH
54970: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54971: LD_ADDR_VAR 0 5
54975: PUSH
54976: LD_INT 0
54978: PUSH
54979: LD_INT 0
54981: PUSH
54982: LD_INT 0
54984: PUSH
54985: EMPTY
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: LIST
54992: ST_TO_ADDR
// if not x or not y then
54993: LD_VAR 0 2
54997: NOT
54998: PUSH
54999: LD_VAR 0 3
55003: NOT
55004: OR
55005: IFFALSE 55009
// exit ;
55007: GO 56659
// if not range then
55009: LD_VAR 0 4
55013: NOT
55014: IFFALSE 55024
// range := 10 ;
55016: LD_ADDR_VAR 0 4
55020: PUSH
55021: LD_INT 10
55023: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55024: LD_ADDR_VAR 0 8
55028: PUSH
55029: LD_INT 81
55031: PUSH
55032: LD_VAR 0 1
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: PUSH
55041: LD_INT 92
55043: PUSH
55044: LD_VAR 0 2
55048: PUSH
55049: LD_VAR 0 3
55053: PUSH
55054: LD_VAR 0 4
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: LD_INT 3
55067: PUSH
55068: LD_INT 21
55070: PUSH
55071: LD_INT 3
55073: PUSH
55074: EMPTY
55075: LIST
55076: LIST
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: LIST
55086: PPUSH
55087: CALL_OW 69
55091: ST_TO_ADDR
// if not tmp then
55092: LD_VAR 0 8
55096: NOT
55097: IFFALSE 55101
// exit ;
55099: GO 56659
// for i in tmp do
55101: LD_ADDR_VAR 0 6
55105: PUSH
55106: LD_VAR 0 8
55110: PUSH
55111: FOR_IN
55112: IFFALSE 56634
// begin points := [ 0 , 0 , 0 ] ;
55114: LD_ADDR_VAR 0 9
55118: PUSH
55119: LD_INT 0
55121: PUSH
55122: LD_INT 0
55124: PUSH
55125: LD_INT 0
55127: PUSH
55128: EMPTY
55129: LIST
55130: LIST
55131: LIST
55132: ST_TO_ADDR
// bpoints := 1 ;
55133: LD_ADDR_VAR 0 10
55137: PUSH
55138: LD_INT 1
55140: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55141: LD_VAR 0 6
55145: PPUSH
55146: CALL_OW 247
55150: PUSH
55151: LD_INT 1
55153: DOUBLE
55154: EQUAL
55155: IFTRUE 55159
55157: GO 55737
55159: POP
// begin if GetClass ( i ) = 1 then
55160: LD_VAR 0 6
55164: PPUSH
55165: CALL_OW 257
55169: PUSH
55170: LD_INT 1
55172: EQUAL
55173: IFFALSE 55194
// points := [ 10 , 5 , 3 ] ;
55175: LD_ADDR_VAR 0 9
55179: PUSH
55180: LD_INT 10
55182: PUSH
55183: LD_INT 5
55185: PUSH
55186: LD_INT 3
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: LIST
55193: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55194: LD_VAR 0 6
55198: PPUSH
55199: CALL_OW 257
55203: PUSH
55204: LD_INT 2
55206: PUSH
55207: LD_INT 3
55209: PUSH
55210: LD_INT 4
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: LIST
55217: IN
55218: IFFALSE 55239
// points := [ 3 , 2 , 1 ] ;
55220: LD_ADDR_VAR 0 9
55224: PUSH
55225: LD_INT 3
55227: PUSH
55228: LD_INT 2
55230: PUSH
55231: LD_INT 1
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55239: LD_VAR 0 6
55243: PPUSH
55244: CALL_OW 257
55248: PUSH
55249: LD_INT 5
55251: EQUAL
55252: IFFALSE 55273
// points := [ 130 , 5 , 2 ] ;
55254: LD_ADDR_VAR 0 9
55258: PUSH
55259: LD_INT 130
55261: PUSH
55262: LD_INT 5
55264: PUSH
55265: LD_INT 2
55267: PUSH
55268: EMPTY
55269: LIST
55270: LIST
55271: LIST
55272: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55273: LD_VAR 0 6
55277: PPUSH
55278: CALL_OW 257
55282: PUSH
55283: LD_INT 8
55285: EQUAL
55286: IFFALSE 55307
// points := [ 35 , 35 , 30 ] ;
55288: LD_ADDR_VAR 0 9
55292: PUSH
55293: LD_INT 35
55295: PUSH
55296: LD_INT 35
55298: PUSH
55299: LD_INT 30
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: LIST
55306: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55307: LD_VAR 0 6
55311: PPUSH
55312: CALL_OW 257
55316: PUSH
55317: LD_INT 9
55319: EQUAL
55320: IFFALSE 55341
// points := [ 20 , 55 , 40 ] ;
55322: LD_ADDR_VAR 0 9
55326: PUSH
55327: LD_INT 20
55329: PUSH
55330: LD_INT 55
55332: PUSH
55333: LD_INT 40
55335: PUSH
55336: EMPTY
55337: LIST
55338: LIST
55339: LIST
55340: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55341: LD_VAR 0 6
55345: PPUSH
55346: CALL_OW 257
55350: PUSH
55351: LD_INT 12
55353: PUSH
55354: LD_INT 16
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: IN
55361: IFFALSE 55382
// points := [ 5 , 3 , 2 ] ;
55363: LD_ADDR_VAR 0 9
55367: PUSH
55368: LD_INT 5
55370: PUSH
55371: LD_INT 3
55373: PUSH
55374: LD_INT 2
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: LIST
55381: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55382: LD_VAR 0 6
55386: PPUSH
55387: CALL_OW 257
55391: PUSH
55392: LD_INT 17
55394: EQUAL
55395: IFFALSE 55416
// points := [ 100 , 50 , 75 ] ;
55397: LD_ADDR_VAR 0 9
55401: PUSH
55402: LD_INT 100
55404: PUSH
55405: LD_INT 50
55407: PUSH
55408: LD_INT 75
55410: PUSH
55411: EMPTY
55412: LIST
55413: LIST
55414: LIST
55415: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55416: LD_VAR 0 6
55420: PPUSH
55421: CALL_OW 257
55425: PUSH
55426: LD_INT 15
55428: EQUAL
55429: IFFALSE 55450
// points := [ 10 , 5 , 3 ] ;
55431: LD_ADDR_VAR 0 9
55435: PUSH
55436: LD_INT 10
55438: PUSH
55439: LD_INT 5
55441: PUSH
55442: LD_INT 3
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: LIST
55449: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55450: LD_VAR 0 6
55454: PPUSH
55455: CALL_OW 257
55459: PUSH
55460: LD_INT 14
55462: EQUAL
55463: IFFALSE 55484
// points := [ 10 , 0 , 0 ] ;
55465: LD_ADDR_VAR 0 9
55469: PUSH
55470: LD_INT 10
55472: PUSH
55473: LD_INT 0
55475: PUSH
55476: LD_INT 0
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: LIST
55483: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55484: LD_VAR 0 6
55488: PPUSH
55489: CALL_OW 257
55493: PUSH
55494: LD_INT 11
55496: EQUAL
55497: IFFALSE 55518
// points := [ 30 , 10 , 5 ] ;
55499: LD_ADDR_VAR 0 9
55503: PUSH
55504: LD_INT 30
55506: PUSH
55507: LD_INT 10
55509: PUSH
55510: LD_INT 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55518: LD_VAR 0 1
55522: PPUSH
55523: LD_INT 5
55525: PPUSH
55526: CALL_OW 321
55530: PUSH
55531: LD_INT 2
55533: EQUAL
55534: IFFALSE 55551
// bpoints := bpoints * 1.8 ;
55536: LD_ADDR_VAR 0 10
55540: PUSH
55541: LD_VAR 0 10
55545: PUSH
55546: LD_REAL  1.80000000000000E+0000
55549: MUL
55550: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55551: LD_VAR 0 6
55555: PPUSH
55556: CALL_OW 257
55560: PUSH
55561: LD_INT 1
55563: PUSH
55564: LD_INT 2
55566: PUSH
55567: LD_INT 3
55569: PUSH
55570: LD_INT 4
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: LIST
55577: LIST
55578: IN
55579: PUSH
55580: LD_VAR 0 1
55584: PPUSH
55585: LD_INT 51
55587: PPUSH
55588: CALL_OW 321
55592: PUSH
55593: LD_INT 2
55595: EQUAL
55596: AND
55597: IFFALSE 55614
// bpoints := bpoints * 1.2 ;
55599: LD_ADDR_VAR 0 10
55603: PUSH
55604: LD_VAR 0 10
55608: PUSH
55609: LD_REAL  1.20000000000000E+0000
55612: MUL
55613: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55614: LD_VAR 0 6
55618: PPUSH
55619: CALL_OW 257
55623: PUSH
55624: LD_INT 5
55626: PUSH
55627: LD_INT 7
55629: PUSH
55630: LD_INT 9
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: LIST
55637: IN
55638: PUSH
55639: LD_VAR 0 1
55643: PPUSH
55644: LD_INT 52
55646: PPUSH
55647: CALL_OW 321
55651: PUSH
55652: LD_INT 2
55654: EQUAL
55655: AND
55656: IFFALSE 55673
// bpoints := bpoints * 1.5 ;
55658: LD_ADDR_VAR 0 10
55662: PUSH
55663: LD_VAR 0 10
55667: PUSH
55668: LD_REAL  1.50000000000000E+0000
55671: MUL
55672: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55673: LD_VAR 0 1
55677: PPUSH
55678: LD_INT 66
55680: PPUSH
55681: CALL_OW 321
55685: PUSH
55686: LD_INT 2
55688: EQUAL
55689: IFFALSE 55706
// bpoints := bpoints * 1.1 ;
55691: LD_ADDR_VAR 0 10
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_REAL  1.10000000000000E+0000
55704: MUL
55705: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55706: LD_ADDR_VAR 0 10
55710: PUSH
55711: LD_VAR 0 10
55715: PUSH
55716: LD_VAR 0 6
55720: PPUSH
55721: LD_INT 1
55723: PPUSH
55724: CALL_OW 259
55728: PUSH
55729: LD_REAL  1.15000000000000E+0000
55732: MUL
55733: MUL
55734: ST_TO_ADDR
// end ; unit_vehicle :
55735: GO 56563
55737: LD_INT 2
55739: DOUBLE
55740: EQUAL
55741: IFTRUE 55745
55743: GO 56551
55745: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55746: LD_VAR 0 6
55750: PPUSH
55751: CALL_OW 264
55755: PUSH
55756: LD_INT 2
55758: PUSH
55759: LD_INT 42
55761: PUSH
55762: LD_INT 24
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: IN
55770: IFFALSE 55791
// points := [ 25 , 5 , 3 ] ;
55772: LD_ADDR_VAR 0 9
55776: PUSH
55777: LD_INT 25
55779: PUSH
55780: LD_INT 5
55782: PUSH
55783: LD_INT 3
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55791: LD_VAR 0 6
55795: PPUSH
55796: CALL_OW 264
55800: PUSH
55801: LD_INT 4
55803: PUSH
55804: LD_INT 43
55806: PUSH
55807: LD_INT 25
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: LIST
55814: IN
55815: IFFALSE 55836
// points := [ 40 , 15 , 5 ] ;
55817: LD_ADDR_VAR 0 9
55821: PUSH
55822: LD_INT 40
55824: PUSH
55825: LD_INT 15
55827: PUSH
55828: LD_INT 5
55830: PUSH
55831: EMPTY
55832: LIST
55833: LIST
55834: LIST
55835: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55836: LD_VAR 0 6
55840: PPUSH
55841: CALL_OW 264
55845: PUSH
55846: LD_INT 3
55848: PUSH
55849: LD_INT 23
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: IN
55856: IFFALSE 55877
// points := [ 7 , 25 , 8 ] ;
55858: LD_ADDR_VAR 0 9
55862: PUSH
55863: LD_INT 7
55865: PUSH
55866: LD_INT 25
55868: PUSH
55869: LD_INT 8
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: LIST
55876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55877: LD_VAR 0 6
55881: PPUSH
55882: CALL_OW 264
55886: PUSH
55887: LD_INT 5
55889: PUSH
55890: LD_INT 27
55892: PUSH
55893: LD_INT 44
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: LIST
55900: IN
55901: IFFALSE 55922
// points := [ 14 , 50 , 16 ] ;
55903: LD_ADDR_VAR 0 9
55907: PUSH
55908: LD_INT 14
55910: PUSH
55911: LD_INT 50
55913: PUSH
55914: LD_INT 16
55916: PUSH
55917: EMPTY
55918: LIST
55919: LIST
55920: LIST
55921: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55922: LD_VAR 0 6
55926: PPUSH
55927: CALL_OW 264
55931: PUSH
55932: LD_INT 6
55934: PUSH
55935: LD_INT 46
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: IN
55942: IFFALSE 55963
// points := [ 32 , 120 , 70 ] ;
55944: LD_ADDR_VAR 0 9
55948: PUSH
55949: LD_INT 32
55951: PUSH
55952: LD_INT 120
55954: PUSH
55955: LD_INT 70
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: LIST
55962: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55963: LD_VAR 0 6
55967: PPUSH
55968: CALL_OW 264
55972: PUSH
55973: LD_INT 7
55975: PUSH
55976: LD_INT 28
55978: PUSH
55979: LD_INT 45
55981: PUSH
55982: LD_INT 92
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: IN
55991: IFFALSE 56012
// points := [ 35 , 20 , 45 ] ;
55993: LD_ADDR_VAR 0 9
55997: PUSH
55998: LD_INT 35
56000: PUSH
56001: LD_INT 20
56003: PUSH
56004: LD_INT 45
56006: PUSH
56007: EMPTY
56008: LIST
56009: LIST
56010: LIST
56011: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56012: LD_VAR 0 6
56016: PPUSH
56017: CALL_OW 264
56021: PUSH
56022: LD_INT 47
56024: PUSH
56025: EMPTY
56026: LIST
56027: IN
56028: IFFALSE 56049
// points := [ 67 , 45 , 75 ] ;
56030: LD_ADDR_VAR 0 9
56034: PUSH
56035: LD_INT 67
56037: PUSH
56038: LD_INT 45
56040: PUSH
56041: LD_INT 75
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56049: LD_VAR 0 6
56053: PPUSH
56054: CALL_OW 264
56058: PUSH
56059: LD_INT 26
56061: PUSH
56062: EMPTY
56063: LIST
56064: IN
56065: IFFALSE 56086
// points := [ 120 , 30 , 80 ] ;
56067: LD_ADDR_VAR 0 9
56071: PUSH
56072: LD_INT 120
56074: PUSH
56075: LD_INT 30
56077: PUSH
56078: LD_INT 80
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56086: LD_VAR 0 6
56090: PPUSH
56091: CALL_OW 264
56095: PUSH
56096: LD_INT 22
56098: PUSH
56099: EMPTY
56100: LIST
56101: IN
56102: IFFALSE 56123
// points := [ 40 , 1 , 1 ] ;
56104: LD_ADDR_VAR 0 9
56108: PUSH
56109: LD_INT 40
56111: PUSH
56112: LD_INT 1
56114: PUSH
56115: LD_INT 1
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56123: LD_VAR 0 6
56127: PPUSH
56128: CALL_OW 264
56132: PUSH
56133: LD_INT 29
56135: PUSH
56136: EMPTY
56137: LIST
56138: IN
56139: IFFALSE 56160
// points := [ 70 , 200 , 400 ] ;
56141: LD_ADDR_VAR 0 9
56145: PUSH
56146: LD_INT 70
56148: PUSH
56149: LD_INT 200
56151: PUSH
56152: LD_INT 400
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: LIST
56159: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56160: LD_VAR 0 6
56164: PPUSH
56165: CALL_OW 264
56169: PUSH
56170: LD_INT 14
56172: PUSH
56173: LD_INT 53
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: IN
56180: IFFALSE 56201
// points := [ 40 , 10 , 20 ] ;
56182: LD_ADDR_VAR 0 9
56186: PUSH
56187: LD_INT 40
56189: PUSH
56190: LD_INT 10
56192: PUSH
56193: LD_INT 20
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: LIST
56200: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56201: LD_VAR 0 6
56205: PPUSH
56206: CALL_OW 264
56210: PUSH
56211: LD_INT 9
56213: PUSH
56214: EMPTY
56215: LIST
56216: IN
56217: IFFALSE 56238
// points := [ 5 , 70 , 20 ] ;
56219: LD_ADDR_VAR 0 9
56223: PUSH
56224: LD_INT 5
56226: PUSH
56227: LD_INT 70
56229: PUSH
56230: LD_INT 20
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: LIST
56237: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56238: LD_VAR 0 6
56242: PPUSH
56243: CALL_OW 264
56247: PUSH
56248: LD_INT 10
56250: PUSH
56251: EMPTY
56252: LIST
56253: IN
56254: IFFALSE 56275
// points := [ 35 , 110 , 70 ] ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_INT 35
56263: PUSH
56264: LD_INT 110
56266: PUSH
56267: LD_INT 70
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56275: LD_VAR 0 6
56279: PPUSH
56280: CALL_OW 265
56284: PUSH
56285: LD_INT 25
56287: EQUAL
56288: IFFALSE 56309
// points := [ 80 , 65 , 100 ] ;
56290: LD_ADDR_VAR 0 9
56294: PUSH
56295: LD_INT 80
56297: PUSH
56298: LD_INT 65
56300: PUSH
56301: LD_INT 100
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: LIST
56308: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56309: LD_VAR 0 6
56313: PPUSH
56314: CALL_OW 263
56318: PUSH
56319: LD_INT 1
56321: EQUAL
56322: IFFALSE 56357
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56324: LD_ADDR_VAR 0 10
56328: PUSH
56329: LD_VAR 0 10
56333: PUSH
56334: LD_VAR 0 6
56338: PPUSH
56339: CALL_OW 311
56343: PPUSH
56344: LD_INT 3
56346: PPUSH
56347: CALL_OW 259
56351: PUSH
56352: LD_INT 4
56354: MUL
56355: MUL
56356: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56357: LD_VAR 0 6
56361: PPUSH
56362: CALL_OW 263
56366: PUSH
56367: LD_INT 2
56369: EQUAL
56370: IFFALSE 56421
// begin j := IsControledBy ( i ) ;
56372: LD_ADDR_VAR 0 7
56376: PUSH
56377: LD_VAR 0 6
56381: PPUSH
56382: CALL_OW 312
56386: ST_TO_ADDR
// if j then
56387: LD_VAR 0 7
56391: IFFALSE 56421
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56393: LD_ADDR_VAR 0 10
56397: PUSH
56398: LD_VAR 0 10
56402: PUSH
56403: LD_VAR 0 7
56407: PPUSH
56408: LD_INT 3
56410: PPUSH
56411: CALL_OW 259
56415: PUSH
56416: LD_INT 3
56418: MUL
56419: MUL
56420: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56421: LD_VAR 0 6
56425: PPUSH
56426: CALL_OW 264
56430: PUSH
56431: LD_INT 5
56433: PUSH
56434: LD_INT 6
56436: PUSH
56437: LD_INT 46
56439: PUSH
56440: LD_INT 44
56442: PUSH
56443: LD_INT 47
56445: PUSH
56446: LD_INT 45
56448: PUSH
56449: LD_INT 28
56451: PUSH
56452: LD_INT 7
56454: PUSH
56455: LD_INT 27
56457: PUSH
56458: LD_INT 29
56460: PUSH
56461: EMPTY
56462: LIST
56463: LIST
56464: LIST
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: LIST
56470: LIST
56471: LIST
56472: IN
56473: PUSH
56474: LD_VAR 0 1
56478: PPUSH
56479: LD_INT 52
56481: PPUSH
56482: CALL_OW 321
56486: PUSH
56487: LD_INT 2
56489: EQUAL
56490: AND
56491: IFFALSE 56508
// bpoints := bpoints * 1.2 ;
56493: LD_ADDR_VAR 0 10
56497: PUSH
56498: LD_VAR 0 10
56502: PUSH
56503: LD_REAL  1.20000000000000E+0000
56506: MUL
56507: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56508: LD_VAR 0 6
56512: PPUSH
56513: CALL_OW 264
56517: PUSH
56518: LD_INT 6
56520: PUSH
56521: LD_INT 46
56523: PUSH
56524: LD_INT 47
56526: PUSH
56527: EMPTY
56528: LIST
56529: LIST
56530: LIST
56531: IN
56532: IFFALSE 56549
// bpoints := bpoints * 1.2 ;
56534: LD_ADDR_VAR 0 10
56538: PUSH
56539: LD_VAR 0 10
56543: PUSH
56544: LD_REAL  1.20000000000000E+0000
56547: MUL
56548: ST_TO_ADDR
// end ; unit_building :
56549: GO 56563
56551: LD_INT 3
56553: DOUBLE
56554: EQUAL
56555: IFTRUE 56559
56557: GO 56562
56559: POP
// ; end ;
56560: GO 56563
56562: POP
// for j = 1 to 3 do
56563: LD_ADDR_VAR 0 7
56567: PUSH
56568: DOUBLE
56569: LD_INT 1
56571: DEC
56572: ST_TO_ADDR
56573: LD_INT 3
56575: PUSH
56576: FOR_TO
56577: IFFALSE 56630
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56579: LD_ADDR_VAR 0 5
56583: PUSH
56584: LD_VAR 0 5
56588: PPUSH
56589: LD_VAR 0 7
56593: PPUSH
56594: LD_VAR 0 5
56598: PUSH
56599: LD_VAR 0 7
56603: ARRAY
56604: PUSH
56605: LD_VAR 0 9
56609: PUSH
56610: LD_VAR 0 7
56614: ARRAY
56615: PUSH
56616: LD_VAR 0 10
56620: MUL
56621: PLUS
56622: PPUSH
56623: CALL_OW 1
56627: ST_TO_ADDR
56628: GO 56576
56630: POP
56631: POP
// end ;
56632: GO 55111
56634: POP
56635: POP
// result := Replace ( result , 4 , tmp ) ;
56636: LD_ADDR_VAR 0 5
56640: PUSH
56641: LD_VAR 0 5
56645: PPUSH
56646: LD_INT 4
56648: PPUSH
56649: LD_VAR 0 8
56653: PPUSH
56654: CALL_OW 1
56658: ST_TO_ADDR
// end ;
56659: LD_VAR 0 5
56663: RET
// export function DangerAtRange ( unit , range ) ; begin
56664: LD_INT 0
56666: PPUSH
// if not unit then
56667: LD_VAR 0 1
56671: NOT
56672: IFFALSE 56676
// exit ;
56674: GO 56721
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56676: LD_ADDR_VAR 0 3
56680: PUSH
56681: LD_VAR 0 1
56685: PPUSH
56686: CALL_OW 255
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: CALL_OW 250
56700: PPUSH
56701: LD_VAR 0 1
56705: PPUSH
56706: CALL_OW 251
56710: PPUSH
56711: LD_VAR 0 2
56715: PPUSH
56716: CALL 54963 0 4
56720: ST_TO_ADDR
// end ;
56721: LD_VAR 0 3
56725: RET
// export function DangerInArea ( side , area ) ; begin
56726: LD_INT 0
56728: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56729: LD_ADDR_VAR 0 3
56733: PUSH
56734: LD_VAR 0 2
56738: PPUSH
56739: LD_INT 81
56741: PUSH
56742: LD_VAR 0 1
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PPUSH
56751: CALL_OW 70
56755: ST_TO_ADDR
// end ;
56756: LD_VAR 0 3
56760: RET
// export function IsExtension ( b ) ; begin
56761: LD_INT 0
56763: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56764: LD_ADDR_VAR 0 2
56768: PUSH
56769: LD_VAR 0 1
56773: PUSH
56774: LD_INT 23
56776: PUSH
56777: LD_INT 20
56779: PUSH
56780: LD_INT 22
56782: PUSH
56783: LD_INT 17
56785: PUSH
56786: LD_INT 24
56788: PUSH
56789: LD_INT 21
56791: PUSH
56792: LD_INT 19
56794: PUSH
56795: LD_INT 16
56797: PUSH
56798: LD_INT 25
56800: PUSH
56801: LD_INT 18
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: LIST
56812: LIST
56813: LIST
56814: LIST
56815: IN
56816: ST_TO_ADDR
// end ;
56817: LD_VAR 0 2
56821: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56822: LD_INT 0
56824: PPUSH
56825: PPUSH
56826: PPUSH
// result := [ ] ;
56827: LD_ADDR_VAR 0 4
56831: PUSH
56832: EMPTY
56833: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56834: LD_ADDR_VAR 0 5
56838: PUSH
56839: LD_VAR 0 2
56843: PPUSH
56844: LD_INT 21
56846: PUSH
56847: LD_INT 3
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PPUSH
56854: CALL_OW 70
56858: ST_TO_ADDR
// if not tmp then
56859: LD_VAR 0 5
56863: NOT
56864: IFFALSE 56868
// exit ;
56866: GO 56932
// if checkLink then
56868: LD_VAR 0 3
56872: IFFALSE 56922
// begin for i in tmp do
56874: LD_ADDR_VAR 0 6
56878: PUSH
56879: LD_VAR 0 5
56883: PUSH
56884: FOR_IN
56885: IFFALSE 56920
// if GetBase ( i ) <> base then
56887: LD_VAR 0 6
56891: PPUSH
56892: CALL_OW 274
56896: PUSH
56897: LD_VAR 0 1
56901: NONEQUAL
56902: IFFALSE 56918
// ComLinkToBase ( base , i ) ;
56904: LD_VAR 0 1
56908: PPUSH
56909: LD_VAR 0 6
56913: PPUSH
56914: CALL_OW 169
56918: GO 56884
56920: POP
56921: POP
// end ; result := tmp ;
56922: LD_ADDR_VAR 0 4
56926: PUSH
56927: LD_VAR 0 5
56931: ST_TO_ADDR
// end ;
56932: LD_VAR 0 4
56936: RET
// export function ComComplete ( units , b ) ; var i ; begin
56937: LD_INT 0
56939: PPUSH
56940: PPUSH
// if not units then
56941: LD_VAR 0 1
56945: NOT
56946: IFFALSE 56950
// exit ;
56948: GO 57040
// for i in units do
56950: LD_ADDR_VAR 0 4
56954: PUSH
56955: LD_VAR 0 1
56959: PUSH
56960: FOR_IN
56961: IFFALSE 57038
// if BuildingStatus ( b ) = bs_build then
56963: LD_VAR 0 2
56967: PPUSH
56968: CALL_OW 461
56972: PUSH
56973: LD_INT 1
56975: EQUAL
56976: IFFALSE 57036
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56978: LD_VAR 0 4
56982: PPUSH
56983: LD_STRING h
56985: PUSH
56986: LD_VAR 0 2
56990: PPUSH
56991: CALL_OW 250
56995: PUSH
56996: LD_VAR 0 2
57000: PPUSH
57001: CALL_OW 251
57005: PUSH
57006: LD_VAR 0 2
57010: PUSH
57011: LD_INT 0
57013: PUSH
57014: LD_INT 0
57016: PUSH
57017: LD_INT 0
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: LIST
57025: LIST
57026: LIST
57027: LIST
57028: PUSH
57029: EMPTY
57030: LIST
57031: PPUSH
57032: CALL_OW 446
57036: GO 56960
57038: POP
57039: POP
// end ;
57040: LD_VAR 0 3
57044: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57045: LD_INT 0
57047: PPUSH
57048: PPUSH
57049: PPUSH
57050: PPUSH
57051: PPUSH
57052: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57053: LD_VAR 0 1
57057: NOT
57058: PUSH
57059: LD_VAR 0 1
57063: PPUSH
57064: CALL_OW 263
57068: PUSH
57069: LD_INT 2
57071: NONEQUAL
57072: OR
57073: IFFALSE 57077
// exit ;
57075: GO 57393
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57077: LD_ADDR_VAR 0 6
57081: PUSH
57082: LD_INT 22
57084: PUSH
57085: LD_VAR 0 1
57089: PPUSH
57090: CALL_OW 255
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: PUSH
57099: LD_INT 2
57101: PUSH
57102: LD_INT 30
57104: PUSH
57105: LD_INT 36
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: LD_INT 34
57114: PUSH
57115: LD_INT 31
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: PUSH
57122: EMPTY
57123: LIST
57124: LIST
57125: LIST
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PPUSH
57131: CALL_OW 69
57135: ST_TO_ADDR
// if not tmp then
57136: LD_VAR 0 6
57140: NOT
57141: IFFALSE 57145
// exit ;
57143: GO 57393
// result := [ ] ;
57145: LD_ADDR_VAR 0 2
57149: PUSH
57150: EMPTY
57151: ST_TO_ADDR
// for i in tmp do
57152: LD_ADDR_VAR 0 3
57156: PUSH
57157: LD_VAR 0 6
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57234
// begin t := UnitsInside ( i ) ;
57165: LD_ADDR_VAR 0 4
57169: PUSH
57170: LD_VAR 0 3
57174: PPUSH
57175: CALL_OW 313
57179: ST_TO_ADDR
// if t then
57180: LD_VAR 0 4
57184: IFFALSE 57232
// for j in t do
57186: LD_ADDR_VAR 0 7
57190: PUSH
57191: LD_VAR 0 4
57195: PUSH
57196: FOR_IN
57197: IFFALSE 57230
// result := Replace ( result , result + 1 , j ) ;
57199: LD_ADDR_VAR 0 2
57203: PUSH
57204: LD_VAR 0 2
57208: PPUSH
57209: LD_VAR 0 2
57213: PUSH
57214: LD_INT 1
57216: PLUS
57217: PPUSH
57218: LD_VAR 0 7
57222: PPUSH
57223: CALL_OW 1
57227: ST_TO_ADDR
57228: GO 57196
57230: POP
57231: POP
// end ;
57232: GO 57162
57234: POP
57235: POP
// if not result then
57236: LD_VAR 0 2
57240: NOT
57241: IFFALSE 57245
// exit ;
57243: GO 57393
// mech := result [ 1 ] ;
57245: LD_ADDR_VAR 0 5
57249: PUSH
57250: LD_VAR 0 2
57254: PUSH
57255: LD_INT 1
57257: ARRAY
57258: ST_TO_ADDR
// if result > 1 then
57259: LD_VAR 0 2
57263: PUSH
57264: LD_INT 1
57266: GREATER
57267: IFFALSE 57379
// begin for i = 2 to result do
57269: LD_ADDR_VAR 0 3
57273: PUSH
57274: DOUBLE
57275: LD_INT 2
57277: DEC
57278: ST_TO_ADDR
57279: LD_VAR 0 2
57283: PUSH
57284: FOR_TO
57285: IFFALSE 57377
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57287: LD_ADDR_VAR 0 4
57291: PUSH
57292: LD_VAR 0 2
57296: PUSH
57297: LD_VAR 0 3
57301: ARRAY
57302: PPUSH
57303: LD_INT 3
57305: PPUSH
57306: CALL_OW 259
57310: PUSH
57311: LD_VAR 0 2
57315: PUSH
57316: LD_VAR 0 3
57320: ARRAY
57321: PPUSH
57322: CALL_OW 432
57326: MINUS
57327: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57328: LD_VAR 0 4
57332: PUSH
57333: LD_VAR 0 5
57337: PPUSH
57338: LD_INT 3
57340: PPUSH
57341: CALL_OW 259
57345: PUSH
57346: LD_VAR 0 5
57350: PPUSH
57351: CALL_OW 432
57355: MINUS
57356: GREATEREQUAL
57357: IFFALSE 57375
// mech := result [ i ] ;
57359: LD_ADDR_VAR 0 5
57363: PUSH
57364: LD_VAR 0 2
57368: PUSH
57369: LD_VAR 0 3
57373: ARRAY
57374: ST_TO_ADDR
// end ;
57375: GO 57284
57377: POP
57378: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57379: LD_VAR 0 1
57383: PPUSH
57384: LD_VAR 0 5
57388: PPUSH
57389: CALL_OW 135
// end ;
57393: LD_VAR 0 2
57397: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57398: LD_INT 0
57400: PPUSH
57401: PPUSH
57402: PPUSH
57403: PPUSH
57404: PPUSH
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
57409: PPUSH
57410: PPUSH
57411: PPUSH
57412: PPUSH
// result := [ ] ;
57413: LD_ADDR_VAR 0 7
57417: PUSH
57418: EMPTY
57419: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57420: LD_VAR 0 1
57424: PPUSH
57425: CALL_OW 266
57429: PUSH
57430: LD_INT 0
57432: PUSH
57433: LD_INT 1
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: IN
57440: NOT
57441: IFFALSE 57445
// exit ;
57443: GO 59079
// if name then
57445: LD_VAR 0 3
57449: IFFALSE 57465
// SetBName ( base_dep , name ) ;
57451: LD_VAR 0 1
57455: PPUSH
57456: LD_VAR 0 3
57460: PPUSH
57461: CALL_OW 500
// base := GetBase ( base_dep ) ;
57465: LD_ADDR_VAR 0 15
57469: PUSH
57470: LD_VAR 0 1
57474: PPUSH
57475: CALL_OW 274
57479: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57480: LD_ADDR_VAR 0 16
57484: PUSH
57485: LD_VAR 0 1
57489: PPUSH
57490: CALL_OW 255
57494: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57495: LD_ADDR_VAR 0 17
57499: PUSH
57500: LD_VAR 0 1
57504: PPUSH
57505: CALL_OW 248
57509: ST_TO_ADDR
// if sources then
57510: LD_VAR 0 5
57514: IFFALSE 57561
// for i = 1 to 3 do
57516: LD_ADDR_VAR 0 8
57520: PUSH
57521: DOUBLE
57522: LD_INT 1
57524: DEC
57525: ST_TO_ADDR
57526: LD_INT 3
57528: PUSH
57529: FOR_TO
57530: IFFALSE 57559
// AddResourceType ( base , i , sources [ i ] ) ;
57532: LD_VAR 0 15
57536: PPUSH
57537: LD_VAR 0 8
57541: PPUSH
57542: LD_VAR 0 5
57546: PUSH
57547: LD_VAR 0 8
57551: ARRAY
57552: PPUSH
57553: CALL_OW 276
57557: GO 57529
57559: POP
57560: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57561: LD_ADDR_VAR 0 18
57565: PUSH
57566: LD_VAR 0 15
57570: PPUSH
57571: LD_VAR 0 2
57575: PPUSH
57576: LD_INT 1
57578: PPUSH
57579: CALL 56822 0 3
57583: ST_TO_ADDR
// InitHc ;
57584: CALL_OW 19
// InitUc ;
57588: CALL_OW 18
// uc_side := side ;
57592: LD_ADDR_OWVAR 20
57596: PUSH
57597: LD_VAR 0 16
57601: ST_TO_ADDR
// uc_nation := nation ;
57602: LD_ADDR_OWVAR 21
57606: PUSH
57607: LD_VAR 0 17
57611: ST_TO_ADDR
// if buildings then
57612: LD_VAR 0 18
57616: IFFALSE 58938
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57618: LD_ADDR_VAR 0 19
57622: PUSH
57623: LD_VAR 0 18
57627: PPUSH
57628: LD_INT 2
57630: PUSH
57631: LD_INT 30
57633: PUSH
57634: LD_INT 29
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: PUSH
57641: LD_INT 30
57643: PUSH
57644: LD_INT 30
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: PUSH
57651: EMPTY
57652: LIST
57653: LIST
57654: LIST
57655: PPUSH
57656: CALL_OW 72
57660: ST_TO_ADDR
// if tmp then
57661: LD_VAR 0 19
57665: IFFALSE 57713
// for i in tmp do
57667: LD_ADDR_VAR 0 8
57671: PUSH
57672: LD_VAR 0 19
57676: PUSH
57677: FOR_IN
57678: IFFALSE 57711
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57680: LD_VAR 0 8
57684: PPUSH
57685: CALL_OW 250
57689: PPUSH
57690: LD_VAR 0 8
57694: PPUSH
57695: CALL_OW 251
57699: PPUSH
57700: LD_VAR 0 16
57704: PPUSH
57705: CALL_OW 441
57709: GO 57677
57711: POP
57712: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57713: LD_VAR 0 18
57717: PPUSH
57718: LD_INT 2
57720: PUSH
57721: LD_INT 30
57723: PUSH
57724: LD_INT 32
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 33
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: EMPTY
57742: LIST
57743: LIST
57744: LIST
57745: PPUSH
57746: CALL_OW 72
57750: IFFALSE 57838
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57752: LD_ADDR_VAR 0 8
57756: PUSH
57757: LD_VAR 0 18
57761: PPUSH
57762: LD_INT 2
57764: PUSH
57765: LD_INT 30
57767: PUSH
57768: LD_INT 32
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: PUSH
57775: LD_INT 30
57777: PUSH
57778: LD_INT 33
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: LIST
57789: PPUSH
57790: CALL_OW 72
57794: PUSH
57795: FOR_IN
57796: IFFALSE 57836
// begin if not GetBWeapon ( i ) then
57798: LD_VAR 0 8
57802: PPUSH
57803: CALL_OW 269
57807: NOT
57808: IFFALSE 57834
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57810: LD_VAR 0 8
57814: PPUSH
57815: LD_VAR 0 8
57819: PPUSH
57820: LD_VAR 0 2
57824: PPUSH
57825: CALL 59084 0 2
57829: PPUSH
57830: CALL_OW 431
// end ;
57834: GO 57795
57836: POP
57837: POP
// end ; for i = 1 to personel do
57838: LD_ADDR_VAR 0 8
57842: PUSH
57843: DOUBLE
57844: LD_INT 1
57846: DEC
57847: ST_TO_ADDR
57848: LD_VAR 0 6
57852: PUSH
57853: FOR_TO
57854: IFFALSE 58918
// begin if i > 4 then
57856: LD_VAR 0 8
57860: PUSH
57861: LD_INT 4
57863: GREATER
57864: IFFALSE 57868
// break ;
57866: GO 58918
// case i of 1 :
57868: LD_VAR 0 8
57872: PUSH
57873: LD_INT 1
57875: DOUBLE
57876: EQUAL
57877: IFTRUE 57881
57879: GO 57961
57881: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57882: LD_ADDR_VAR 0 12
57886: PUSH
57887: LD_VAR 0 18
57891: PPUSH
57892: LD_INT 22
57894: PUSH
57895: LD_VAR 0 16
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: PUSH
57904: LD_INT 58
57906: PUSH
57907: EMPTY
57908: LIST
57909: PUSH
57910: LD_INT 2
57912: PUSH
57913: LD_INT 30
57915: PUSH
57916: LD_INT 32
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 30
57925: PUSH
57926: LD_INT 4
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: PUSH
57933: LD_INT 30
57935: PUSH
57936: LD_INT 5
57938: PUSH
57939: EMPTY
57940: LIST
57941: LIST
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: LIST
57947: LIST
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: LIST
57953: PPUSH
57954: CALL_OW 72
57958: ST_TO_ADDR
57959: GO 58183
57961: LD_INT 2
57963: DOUBLE
57964: EQUAL
57965: IFTRUE 57969
57967: GO 58031
57969: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57970: LD_ADDR_VAR 0 12
57974: PUSH
57975: LD_VAR 0 18
57979: PPUSH
57980: LD_INT 22
57982: PUSH
57983: LD_VAR 0 16
57987: PUSH
57988: EMPTY
57989: LIST
57990: LIST
57991: PUSH
57992: LD_INT 2
57994: PUSH
57995: LD_INT 30
57997: PUSH
57998: LD_INT 0
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: LD_INT 30
58007: PUSH
58008: LD_INT 1
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: LIST
58019: PUSH
58020: EMPTY
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
58029: GO 58183
58031: LD_INT 3
58033: DOUBLE
58034: EQUAL
58035: IFTRUE 58039
58037: GO 58101
58039: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58040: LD_ADDR_VAR 0 12
58044: PUSH
58045: LD_VAR 0 18
58049: PPUSH
58050: LD_INT 22
58052: PUSH
58053: LD_VAR 0 16
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: LD_INT 2
58064: PUSH
58065: LD_INT 30
58067: PUSH
58068: LD_INT 2
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: PUSH
58075: LD_INT 30
58077: PUSH
58078: LD_INT 3
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: PUSH
58085: EMPTY
58086: LIST
58087: LIST
58088: LIST
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: PPUSH
58094: CALL_OW 72
58098: ST_TO_ADDR
58099: GO 58183
58101: LD_INT 4
58103: DOUBLE
58104: EQUAL
58105: IFTRUE 58109
58107: GO 58182
58109: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58110: LD_ADDR_VAR 0 12
58114: PUSH
58115: LD_VAR 0 18
58119: PPUSH
58120: LD_INT 22
58122: PUSH
58123: LD_VAR 0 16
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: LD_INT 2
58134: PUSH
58135: LD_INT 30
58137: PUSH
58138: LD_INT 6
58140: PUSH
58141: EMPTY
58142: LIST
58143: LIST
58144: PUSH
58145: LD_INT 30
58147: PUSH
58148: LD_INT 7
58150: PUSH
58151: EMPTY
58152: LIST
58153: LIST
58154: PUSH
58155: LD_INT 30
58157: PUSH
58158: LD_INT 8
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: LIST
58169: LIST
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PPUSH
58175: CALL_OW 72
58179: ST_TO_ADDR
58180: GO 58183
58182: POP
// if i = 1 then
58183: LD_VAR 0 8
58187: PUSH
58188: LD_INT 1
58190: EQUAL
58191: IFFALSE 58302
// begin tmp := [ ] ;
58193: LD_ADDR_VAR 0 19
58197: PUSH
58198: EMPTY
58199: ST_TO_ADDR
// for j in f do
58200: LD_ADDR_VAR 0 9
58204: PUSH
58205: LD_VAR 0 12
58209: PUSH
58210: FOR_IN
58211: IFFALSE 58284
// if GetBType ( j ) = b_bunker then
58213: LD_VAR 0 9
58217: PPUSH
58218: CALL_OW 266
58222: PUSH
58223: LD_INT 32
58225: EQUAL
58226: IFFALSE 58253
// tmp := Insert ( tmp , 1 , j ) else
58228: LD_ADDR_VAR 0 19
58232: PUSH
58233: LD_VAR 0 19
58237: PPUSH
58238: LD_INT 1
58240: PPUSH
58241: LD_VAR 0 9
58245: PPUSH
58246: CALL_OW 2
58250: ST_TO_ADDR
58251: GO 58282
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58253: LD_ADDR_VAR 0 19
58257: PUSH
58258: LD_VAR 0 19
58262: PPUSH
58263: LD_VAR 0 19
58267: PUSH
58268: LD_INT 1
58270: PLUS
58271: PPUSH
58272: LD_VAR 0 9
58276: PPUSH
58277: CALL_OW 2
58281: ST_TO_ADDR
58282: GO 58210
58284: POP
58285: POP
// if tmp then
58286: LD_VAR 0 19
58290: IFFALSE 58302
// f := tmp ;
58292: LD_ADDR_VAR 0 12
58296: PUSH
58297: LD_VAR 0 19
58301: ST_TO_ADDR
// end ; x := personel [ i ] ;
58302: LD_ADDR_VAR 0 13
58306: PUSH
58307: LD_VAR 0 6
58311: PUSH
58312: LD_VAR 0 8
58316: ARRAY
58317: ST_TO_ADDR
// if x = - 1 then
58318: LD_VAR 0 13
58322: PUSH
58323: LD_INT 1
58325: NEG
58326: EQUAL
58327: IFFALSE 58536
// begin for j in f do
58329: LD_ADDR_VAR 0 9
58333: PUSH
58334: LD_VAR 0 12
58338: PUSH
58339: FOR_IN
58340: IFFALSE 58532
// repeat InitHc ;
58342: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58346: LD_VAR 0 9
58350: PPUSH
58351: CALL_OW 266
58355: PUSH
58356: LD_INT 5
58358: EQUAL
58359: IFFALSE 58429
// begin if UnitsInside ( j ) < 3 then
58361: LD_VAR 0 9
58365: PPUSH
58366: CALL_OW 313
58370: PUSH
58371: LD_INT 3
58373: LESS
58374: IFFALSE 58410
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58376: LD_INT 0
58378: PPUSH
58379: LD_INT 5
58381: PUSH
58382: LD_INT 8
58384: PUSH
58385: LD_INT 9
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: LIST
58392: PUSH
58393: LD_VAR 0 17
58397: ARRAY
58398: PPUSH
58399: LD_VAR 0 4
58403: PPUSH
58404: CALL_OW 380
58408: GO 58427
// PrepareHuman ( false , i , skill ) ;
58410: LD_INT 0
58412: PPUSH
58413: LD_VAR 0 8
58417: PPUSH
58418: LD_VAR 0 4
58422: PPUSH
58423: CALL_OW 380
// end else
58427: GO 58446
// PrepareHuman ( false , i , skill ) ;
58429: LD_INT 0
58431: PPUSH
58432: LD_VAR 0 8
58436: PPUSH
58437: LD_VAR 0 4
58441: PPUSH
58442: CALL_OW 380
// un := CreateHuman ;
58446: LD_ADDR_VAR 0 14
58450: PUSH
58451: CALL_OW 44
58455: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58456: LD_ADDR_VAR 0 7
58460: PUSH
58461: LD_VAR 0 7
58465: PPUSH
58466: LD_INT 1
58468: PPUSH
58469: LD_VAR 0 14
58473: PPUSH
58474: CALL_OW 2
58478: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58479: LD_VAR 0 14
58483: PPUSH
58484: LD_VAR 0 9
58488: PPUSH
58489: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58493: LD_VAR 0 9
58497: PPUSH
58498: CALL_OW 313
58502: PUSH
58503: LD_INT 6
58505: EQUAL
58506: PUSH
58507: LD_VAR 0 9
58511: PPUSH
58512: CALL_OW 266
58516: PUSH
58517: LD_INT 32
58519: PUSH
58520: LD_INT 31
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: IN
58527: OR
58528: IFFALSE 58342
58530: GO 58339
58532: POP
58533: POP
// end else
58534: GO 58916
// for j = 1 to x do
58536: LD_ADDR_VAR 0 9
58540: PUSH
58541: DOUBLE
58542: LD_INT 1
58544: DEC
58545: ST_TO_ADDR
58546: LD_VAR 0 13
58550: PUSH
58551: FOR_TO
58552: IFFALSE 58914
// begin InitHc ;
58554: CALL_OW 19
// if not f then
58558: LD_VAR 0 12
58562: NOT
58563: IFFALSE 58652
// begin PrepareHuman ( false , i , skill ) ;
58565: LD_INT 0
58567: PPUSH
58568: LD_VAR 0 8
58572: PPUSH
58573: LD_VAR 0 4
58577: PPUSH
58578: CALL_OW 380
// un := CreateHuman ;
58582: LD_ADDR_VAR 0 14
58586: PUSH
58587: CALL_OW 44
58591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58592: LD_ADDR_VAR 0 7
58596: PUSH
58597: LD_VAR 0 7
58601: PPUSH
58602: LD_INT 1
58604: PPUSH
58605: LD_VAR 0 14
58609: PPUSH
58610: CALL_OW 2
58614: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58615: LD_VAR 0 14
58619: PPUSH
58620: LD_VAR 0 1
58624: PPUSH
58625: CALL_OW 250
58629: PPUSH
58630: LD_VAR 0 1
58634: PPUSH
58635: CALL_OW 251
58639: PPUSH
58640: LD_INT 10
58642: PPUSH
58643: LD_INT 0
58645: PPUSH
58646: CALL_OW 50
// continue ;
58650: GO 58551
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58652: LD_VAR 0 12
58656: PUSH
58657: LD_INT 1
58659: ARRAY
58660: PPUSH
58661: CALL_OW 313
58665: PUSH
58666: LD_VAR 0 12
58670: PUSH
58671: LD_INT 1
58673: ARRAY
58674: PPUSH
58675: CALL_OW 266
58679: PUSH
58680: LD_INT 32
58682: PUSH
58683: LD_INT 31
58685: PUSH
58686: EMPTY
58687: LIST
58688: LIST
58689: IN
58690: AND
58691: PUSH
58692: LD_VAR 0 12
58696: PUSH
58697: LD_INT 1
58699: ARRAY
58700: PPUSH
58701: CALL_OW 313
58705: PUSH
58706: LD_INT 6
58708: EQUAL
58709: OR
58710: IFFALSE 58730
// f := Delete ( f , 1 ) ;
58712: LD_ADDR_VAR 0 12
58716: PUSH
58717: LD_VAR 0 12
58721: PPUSH
58722: LD_INT 1
58724: PPUSH
58725: CALL_OW 3
58729: ST_TO_ADDR
// if not f then
58730: LD_VAR 0 12
58734: NOT
58735: IFFALSE 58753
// begin x := x + 2 ;
58737: LD_ADDR_VAR 0 13
58741: PUSH
58742: LD_VAR 0 13
58746: PUSH
58747: LD_INT 2
58749: PLUS
58750: ST_TO_ADDR
// continue ;
58751: GO 58551
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58753: LD_VAR 0 12
58757: PUSH
58758: LD_INT 1
58760: ARRAY
58761: PPUSH
58762: CALL_OW 266
58766: PUSH
58767: LD_INT 5
58769: EQUAL
58770: IFFALSE 58844
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58772: LD_VAR 0 12
58776: PUSH
58777: LD_INT 1
58779: ARRAY
58780: PPUSH
58781: CALL_OW 313
58785: PUSH
58786: LD_INT 3
58788: LESS
58789: IFFALSE 58825
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58791: LD_INT 0
58793: PPUSH
58794: LD_INT 5
58796: PUSH
58797: LD_INT 8
58799: PUSH
58800: LD_INT 9
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: PUSH
58808: LD_VAR 0 17
58812: ARRAY
58813: PPUSH
58814: LD_VAR 0 4
58818: PPUSH
58819: CALL_OW 380
58823: GO 58842
// PrepareHuman ( false , i , skill ) ;
58825: LD_INT 0
58827: PPUSH
58828: LD_VAR 0 8
58832: PPUSH
58833: LD_VAR 0 4
58837: PPUSH
58838: CALL_OW 380
// end else
58842: GO 58861
// PrepareHuman ( false , i , skill ) ;
58844: LD_INT 0
58846: PPUSH
58847: LD_VAR 0 8
58851: PPUSH
58852: LD_VAR 0 4
58856: PPUSH
58857: CALL_OW 380
// un := CreateHuman ;
58861: LD_ADDR_VAR 0 14
58865: PUSH
58866: CALL_OW 44
58870: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58871: LD_ADDR_VAR 0 7
58875: PUSH
58876: LD_VAR 0 7
58880: PPUSH
58881: LD_INT 1
58883: PPUSH
58884: LD_VAR 0 14
58888: PPUSH
58889: CALL_OW 2
58893: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58894: LD_VAR 0 14
58898: PPUSH
58899: LD_VAR 0 12
58903: PUSH
58904: LD_INT 1
58906: ARRAY
58907: PPUSH
58908: CALL_OW 52
// end ;
58912: GO 58551
58914: POP
58915: POP
// end ;
58916: GO 57853
58918: POP
58919: POP
// result := result ^ buildings ;
58920: LD_ADDR_VAR 0 7
58924: PUSH
58925: LD_VAR 0 7
58929: PUSH
58930: LD_VAR 0 18
58934: ADD
58935: ST_TO_ADDR
// end else
58936: GO 59079
// begin for i = 1 to personel do
58938: LD_ADDR_VAR 0 8
58942: PUSH
58943: DOUBLE
58944: LD_INT 1
58946: DEC
58947: ST_TO_ADDR
58948: LD_VAR 0 6
58952: PUSH
58953: FOR_TO
58954: IFFALSE 59077
// begin if i > 4 then
58956: LD_VAR 0 8
58960: PUSH
58961: LD_INT 4
58963: GREATER
58964: IFFALSE 58968
// break ;
58966: GO 59077
// x := personel [ i ] ;
58968: LD_ADDR_VAR 0 13
58972: PUSH
58973: LD_VAR 0 6
58977: PUSH
58978: LD_VAR 0 8
58982: ARRAY
58983: ST_TO_ADDR
// if x = - 1 then
58984: LD_VAR 0 13
58988: PUSH
58989: LD_INT 1
58991: NEG
58992: EQUAL
58993: IFFALSE 58997
// continue ;
58995: GO 58953
// PrepareHuman ( false , i , skill ) ;
58997: LD_INT 0
58999: PPUSH
59000: LD_VAR 0 8
59004: PPUSH
59005: LD_VAR 0 4
59009: PPUSH
59010: CALL_OW 380
// un := CreateHuman ;
59014: LD_ADDR_VAR 0 14
59018: PUSH
59019: CALL_OW 44
59023: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59024: LD_VAR 0 14
59028: PPUSH
59029: LD_VAR 0 1
59033: PPUSH
59034: CALL_OW 250
59038: PPUSH
59039: LD_VAR 0 1
59043: PPUSH
59044: CALL_OW 251
59048: PPUSH
59049: LD_INT 10
59051: PPUSH
59052: LD_INT 0
59054: PPUSH
59055: CALL_OW 50
// result := result ^ un ;
59059: LD_ADDR_VAR 0 7
59063: PUSH
59064: LD_VAR 0 7
59068: PUSH
59069: LD_VAR 0 14
59073: ADD
59074: ST_TO_ADDR
// end ;
59075: GO 58953
59077: POP
59078: POP
// end ; end ;
59079: LD_VAR 0 7
59083: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59084: LD_INT 0
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
59097: PPUSH
59098: PPUSH
59099: PPUSH
59100: PPUSH
59101: PPUSH
// result := false ;
59102: LD_ADDR_VAR 0 3
59106: PUSH
59107: LD_INT 0
59109: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59110: LD_VAR 0 1
59114: NOT
59115: PUSH
59116: LD_VAR 0 1
59120: PPUSH
59121: CALL_OW 266
59125: PUSH
59126: LD_INT 32
59128: PUSH
59129: LD_INT 33
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: IN
59136: NOT
59137: OR
59138: IFFALSE 59142
// exit ;
59140: GO 60251
// nat := GetNation ( tower ) ;
59142: LD_ADDR_VAR 0 12
59146: PUSH
59147: LD_VAR 0 1
59151: PPUSH
59152: CALL_OW 248
59156: ST_TO_ADDR
// side := GetSide ( tower ) ;
59157: LD_ADDR_VAR 0 16
59161: PUSH
59162: LD_VAR 0 1
59166: PPUSH
59167: CALL_OW 255
59171: ST_TO_ADDR
// x := GetX ( tower ) ;
59172: LD_ADDR_VAR 0 10
59176: PUSH
59177: LD_VAR 0 1
59181: PPUSH
59182: CALL_OW 250
59186: ST_TO_ADDR
// y := GetY ( tower ) ;
59187: LD_ADDR_VAR 0 11
59191: PUSH
59192: LD_VAR 0 1
59196: PPUSH
59197: CALL_OW 251
59201: ST_TO_ADDR
// if not x or not y then
59202: LD_VAR 0 10
59206: NOT
59207: PUSH
59208: LD_VAR 0 11
59212: NOT
59213: OR
59214: IFFALSE 59218
// exit ;
59216: GO 60251
// weapon := 0 ;
59218: LD_ADDR_VAR 0 18
59222: PUSH
59223: LD_INT 0
59225: ST_TO_ADDR
// fac_list := [ ] ;
59226: LD_ADDR_VAR 0 17
59230: PUSH
59231: EMPTY
59232: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59233: LD_ADDR_VAR 0 6
59237: PUSH
59238: LD_VAR 0 1
59242: PPUSH
59243: CALL_OW 274
59247: PPUSH
59248: LD_VAR 0 2
59252: PPUSH
59253: LD_INT 0
59255: PPUSH
59256: CALL 56822 0 3
59260: PPUSH
59261: LD_INT 30
59263: PUSH
59264: LD_INT 3
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: PPUSH
59271: CALL_OW 72
59275: ST_TO_ADDR
// if not factories then
59276: LD_VAR 0 6
59280: NOT
59281: IFFALSE 59285
// exit ;
59283: GO 60251
// for i in factories do
59285: LD_ADDR_VAR 0 8
59289: PUSH
59290: LD_VAR 0 6
59294: PUSH
59295: FOR_IN
59296: IFFALSE 59321
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59298: LD_ADDR_VAR 0 17
59302: PUSH
59303: LD_VAR 0 17
59307: PUSH
59308: LD_VAR 0 8
59312: PPUSH
59313: CALL_OW 478
59317: UNION
59318: ST_TO_ADDR
59319: GO 59295
59321: POP
59322: POP
// if not fac_list then
59323: LD_VAR 0 17
59327: NOT
59328: IFFALSE 59332
// exit ;
59330: GO 60251
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59332: LD_ADDR_VAR 0 5
59336: PUSH
59337: LD_INT 4
59339: PUSH
59340: LD_INT 5
59342: PUSH
59343: LD_INT 9
59345: PUSH
59346: LD_INT 10
59348: PUSH
59349: LD_INT 6
59351: PUSH
59352: LD_INT 7
59354: PUSH
59355: LD_INT 11
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 27
59369: PUSH
59370: LD_INT 28
59372: PUSH
59373: LD_INT 26
59375: PUSH
59376: LD_INT 30
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: PUSH
59385: LD_INT 43
59387: PUSH
59388: LD_INT 44
59390: PUSH
59391: LD_INT 46
59393: PUSH
59394: LD_INT 45
59396: PUSH
59397: LD_INT 47
59399: PUSH
59400: LD_INT 49
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: LIST
59415: PUSH
59416: LD_VAR 0 12
59420: ARRAY
59421: ST_TO_ADDR
// list := list isect fac_list ;
59422: LD_ADDR_VAR 0 5
59426: PUSH
59427: LD_VAR 0 5
59431: PUSH
59432: LD_VAR 0 17
59436: ISECT
59437: ST_TO_ADDR
// if not list then
59438: LD_VAR 0 5
59442: NOT
59443: IFFALSE 59447
// exit ;
59445: GO 60251
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59447: LD_VAR 0 12
59451: PUSH
59452: LD_INT 3
59454: EQUAL
59455: PUSH
59456: LD_INT 49
59458: PUSH
59459: LD_VAR 0 5
59463: IN
59464: AND
59465: PUSH
59466: LD_INT 31
59468: PPUSH
59469: LD_VAR 0 16
59473: PPUSH
59474: CALL_OW 321
59478: PUSH
59479: LD_INT 2
59481: EQUAL
59482: AND
59483: IFFALSE 59543
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59485: LD_INT 22
59487: PUSH
59488: LD_VAR 0 16
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 35
59499: PUSH
59500: LD_INT 49
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: LD_INT 91
59509: PUSH
59510: LD_VAR 0 1
59514: PUSH
59515: LD_INT 10
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: LIST
59527: PPUSH
59528: CALL_OW 69
59532: NOT
59533: IFFALSE 59543
// weapon := ru_time_lapser ;
59535: LD_ADDR_VAR 0 18
59539: PUSH
59540: LD_INT 49
59542: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59543: LD_VAR 0 12
59547: PUSH
59548: LD_INT 1
59550: PUSH
59551: LD_INT 2
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: IN
59558: PUSH
59559: LD_INT 11
59561: PUSH
59562: LD_VAR 0 5
59566: IN
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_VAR 0 5
59575: IN
59576: OR
59577: AND
59578: PUSH
59579: LD_INT 6
59581: PPUSH
59582: LD_VAR 0 16
59586: PPUSH
59587: CALL_OW 321
59591: PUSH
59592: LD_INT 2
59594: EQUAL
59595: AND
59596: IFFALSE 59761
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59598: LD_INT 22
59600: PUSH
59601: LD_VAR 0 16
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: PUSH
59610: LD_INT 2
59612: PUSH
59613: LD_INT 35
59615: PUSH
59616: LD_INT 11
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: PUSH
59623: LD_INT 35
59625: PUSH
59626: LD_INT 30
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: PUSH
59633: EMPTY
59634: LIST
59635: LIST
59636: LIST
59637: PUSH
59638: LD_INT 91
59640: PUSH
59641: LD_VAR 0 1
59645: PUSH
59646: LD_INT 18
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 69
59663: NOT
59664: PUSH
59665: LD_INT 22
59667: PUSH
59668: LD_VAR 0 16
59672: PUSH
59673: EMPTY
59674: LIST
59675: LIST
59676: PUSH
59677: LD_INT 2
59679: PUSH
59680: LD_INT 30
59682: PUSH
59683: LD_INT 32
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 33
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: LIST
59704: PUSH
59705: LD_INT 91
59707: PUSH
59708: LD_VAR 0 1
59712: PUSH
59713: LD_INT 12
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: LIST
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: LIST
59725: PUSH
59726: EMPTY
59727: LIST
59728: PPUSH
59729: CALL_OW 69
59733: PUSH
59734: LD_INT 2
59736: GREATER
59737: AND
59738: IFFALSE 59761
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59740: LD_ADDR_VAR 0 18
59744: PUSH
59745: LD_INT 11
59747: PUSH
59748: LD_INT 30
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: LD_VAR 0 12
59759: ARRAY
59760: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59761: LD_VAR 0 18
59765: NOT
59766: PUSH
59767: LD_INT 40
59769: PPUSH
59770: LD_VAR 0 16
59774: PPUSH
59775: CALL_OW 321
59779: PUSH
59780: LD_INT 2
59782: EQUAL
59783: AND
59784: PUSH
59785: LD_INT 7
59787: PUSH
59788: LD_VAR 0 5
59792: IN
59793: PUSH
59794: LD_INT 28
59796: PUSH
59797: LD_VAR 0 5
59801: IN
59802: OR
59803: PUSH
59804: LD_INT 45
59806: PUSH
59807: LD_VAR 0 5
59811: IN
59812: OR
59813: AND
59814: IFFALSE 60068
// begin hex := GetHexInfo ( x , y ) ;
59816: LD_ADDR_VAR 0 4
59820: PUSH
59821: LD_VAR 0 10
59825: PPUSH
59826: LD_VAR 0 11
59830: PPUSH
59831: CALL_OW 546
59835: ST_TO_ADDR
// if hex [ 1 ] then
59836: LD_VAR 0 4
59840: PUSH
59841: LD_INT 1
59843: ARRAY
59844: IFFALSE 59848
// exit ;
59846: GO 60251
// height := hex [ 2 ] ;
59848: LD_ADDR_VAR 0 15
59852: PUSH
59853: LD_VAR 0 4
59857: PUSH
59858: LD_INT 2
59860: ARRAY
59861: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59862: LD_ADDR_VAR 0 14
59866: PUSH
59867: LD_INT 0
59869: PUSH
59870: LD_INT 2
59872: PUSH
59873: LD_INT 3
59875: PUSH
59876: LD_INT 5
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: LIST
59883: LIST
59884: ST_TO_ADDR
// for i in tmp do
59885: LD_ADDR_VAR 0 8
59889: PUSH
59890: LD_VAR 0 14
59894: PUSH
59895: FOR_IN
59896: IFFALSE 60066
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59898: LD_ADDR_VAR 0 9
59902: PUSH
59903: LD_VAR 0 10
59907: PPUSH
59908: LD_VAR 0 8
59912: PPUSH
59913: LD_INT 5
59915: PPUSH
59916: CALL_OW 272
59920: PUSH
59921: LD_VAR 0 11
59925: PPUSH
59926: LD_VAR 0 8
59930: PPUSH
59931: LD_INT 5
59933: PPUSH
59934: CALL_OW 273
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59943: LD_VAR 0 9
59947: PUSH
59948: LD_INT 1
59950: ARRAY
59951: PPUSH
59952: LD_VAR 0 9
59956: PUSH
59957: LD_INT 2
59959: ARRAY
59960: PPUSH
59961: CALL_OW 488
59965: IFFALSE 60064
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59967: LD_ADDR_VAR 0 4
59971: PUSH
59972: LD_VAR 0 9
59976: PUSH
59977: LD_INT 1
59979: ARRAY
59980: PPUSH
59981: LD_VAR 0 9
59985: PUSH
59986: LD_INT 2
59988: ARRAY
59989: PPUSH
59990: CALL_OW 546
59994: ST_TO_ADDR
// if hex [ 1 ] then
59995: LD_VAR 0 4
59999: PUSH
60000: LD_INT 1
60002: ARRAY
60003: IFFALSE 60007
// continue ;
60005: GO 59895
// h := hex [ 2 ] ;
60007: LD_ADDR_VAR 0 13
60011: PUSH
60012: LD_VAR 0 4
60016: PUSH
60017: LD_INT 2
60019: ARRAY
60020: ST_TO_ADDR
// if h + 7 < height then
60021: LD_VAR 0 13
60025: PUSH
60026: LD_INT 7
60028: PLUS
60029: PUSH
60030: LD_VAR 0 15
60034: LESS
60035: IFFALSE 60064
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60037: LD_ADDR_VAR 0 18
60041: PUSH
60042: LD_INT 7
60044: PUSH
60045: LD_INT 28
60047: PUSH
60048: LD_INT 45
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: PUSH
60056: LD_VAR 0 12
60060: ARRAY
60061: ST_TO_ADDR
// break ;
60062: GO 60066
// end ; end ; end ;
60064: GO 59895
60066: POP
60067: POP
// end ; if not weapon then
60068: LD_VAR 0 18
60072: NOT
60073: IFFALSE 60133
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60075: LD_ADDR_VAR 0 5
60079: PUSH
60080: LD_VAR 0 5
60084: PUSH
60085: LD_INT 11
60087: PUSH
60088: LD_INT 30
60090: PUSH
60091: LD_INT 49
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: LIST
60098: DIFF
60099: ST_TO_ADDR
// if not list then
60100: LD_VAR 0 5
60104: NOT
60105: IFFALSE 60109
// exit ;
60107: GO 60251
// weapon := list [ rand ( 1 , list ) ] ;
60109: LD_ADDR_VAR 0 18
60113: PUSH
60114: LD_VAR 0 5
60118: PUSH
60119: LD_INT 1
60121: PPUSH
60122: LD_VAR 0 5
60126: PPUSH
60127: CALL_OW 12
60131: ARRAY
60132: ST_TO_ADDR
// end ; if weapon then
60133: LD_VAR 0 18
60137: IFFALSE 60251
// begin tmp := CostOfWeapon ( weapon ) ;
60139: LD_ADDR_VAR 0 14
60143: PUSH
60144: LD_VAR 0 18
60148: PPUSH
60149: CALL_OW 451
60153: ST_TO_ADDR
// j := GetBase ( tower ) ;
60154: LD_ADDR_VAR 0 9
60158: PUSH
60159: LD_VAR 0 1
60163: PPUSH
60164: CALL_OW 274
60168: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60169: LD_VAR 0 9
60173: PPUSH
60174: LD_INT 1
60176: PPUSH
60177: CALL_OW 275
60181: PUSH
60182: LD_VAR 0 14
60186: PUSH
60187: LD_INT 1
60189: ARRAY
60190: GREATEREQUAL
60191: PUSH
60192: LD_VAR 0 9
60196: PPUSH
60197: LD_INT 2
60199: PPUSH
60200: CALL_OW 275
60204: PUSH
60205: LD_VAR 0 14
60209: PUSH
60210: LD_INT 2
60212: ARRAY
60213: GREATEREQUAL
60214: AND
60215: PUSH
60216: LD_VAR 0 9
60220: PPUSH
60221: LD_INT 3
60223: PPUSH
60224: CALL_OW 275
60228: PUSH
60229: LD_VAR 0 14
60233: PUSH
60234: LD_INT 3
60236: ARRAY
60237: GREATEREQUAL
60238: AND
60239: IFFALSE 60251
// result := weapon ;
60241: LD_ADDR_VAR 0 3
60245: PUSH
60246: LD_VAR 0 18
60250: ST_TO_ADDR
// end ; end ;
60251: LD_VAR 0 3
60255: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60256: LD_INT 0
60258: PPUSH
60259: PPUSH
// result := true ;
60260: LD_ADDR_VAR 0 3
60264: PUSH
60265: LD_INT 1
60267: ST_TO_ADDR
// if array1 = array2 then
60268: LD_VAR 0 1
60272: PUSH
60273: LD_VAR 0 2
60277: EQUAL
60278: IFFALSE 60338
// begin for i = 1 to array1 do
60280: LD_ADDR_VAR 0 4
60284: PUSH
60285: DOUBLE
60286: LD_INT 1
60288: DEC
60289: ST_TO_ADDR
60290: LD_VAR 0 1
60294: PUSH
60295: FOR_TO
60296: IFFALSE 60334
// if array1 [ i ] <> array2 [ i ] then
60298: LD_VAR 0 1
60302: PUSH
60303: LD_VAR 0 4
60307: ARRAY
60308: PUSH
60309: LD_VAR 0 2
60313: PUSH
60314: LD_VAR 0 4
60318: ARRAY
60319: NONEQUAL
60320: IFFALSE 60332
// begin result := false ;
60322: LD_ADDR_VAR 0 3
60326: PUSH
60327: LD_INT 0
60329: ST_TO_ADDR
// break ;
60330: GO 60334
// end ;
60332: GO 60295
60334: POP
60335: POP
// end else
60336: GO 60346
// result := false ;
60338: LD_ADDR_VAR 0 3
60342: PUSH
60343: LD_INT 0
60345: ST_TO_ADDR
// end ;
60346: LD_VAR 0 3
60350: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60351: LD_INT 0
60353: PPUSH
60354: PPUSH
// if not array1 or not array2 then
60355: LD_VAR 0 1
60359: NOT
60360: PUSH
60361: LD_VAR 0 2
60365: NOT
60366: OR
60367: IFFALSE 60371
// exit ;
60369: GO 60435
// result := true ;
60371: LD_ADDR_VAR 0 3
60375: PUSH
60376: LD_INT 1
60378: ST_TO_ADDR
// for i = 1 to array1 do
60379: LD_ADDR_VAR 0 4
60383: PUSH
60384: DOUBLE
60385: LD_INT 1
60387: DEC
60388: ST_TO_ADDR
60389: LD_VAR 0 1
60393: PUSH
60394: FOR_TO
60395: IFFALSE 60433
// if array1 [ i ] <> array2 [ i ] then
60397: LD_VAR 0 1
60401: PUSH
60402: LD_VAR 0 4
60406: ARRAY
60407: PUSH
60408: LD_VAR 0 2
60412: PUSH
60413: LD_VAR 0 4
60417: ARRAY
60418: NONEQUAL
60419: IFFALSE 60431
// begin result := false ;
60421: LD_ADDR_VAR 0 3
60425: PUSH
60426: LD_INT 0
60428: ST_TO_ADDR
// break ;
60429: GO 60433
// end ;
60431: GO 60394
60433: POP
60434: POP
// end ;
60435: LD_VAR 0 3
60439: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60440: LD_INT 0
60442: PPUSH
60443: PPUSH
60444: PPUSH
// pom := GetBase ( fac ) ;
60445: LD_ADDR_VAR 0 5
60449: PUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: CALL_OW 274
60459: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60460: LD_ADDR_VAR 0 4
60464: PUSH
60465: LD_VAR 0 2
60469: PUSH
60470: LD_INT 1
60472: ARRAY
60473: PPUSH
60474: LD_VAR 0 2
60478: PUSH
60479: LD_INT 2
60481: ARRAY
60482: PPUSH
60483: LD_VAR 0 2
60487: PUSH
60488: LD_INT 3
60490: ARRAY
60491: PPUSH
60492: LD_VAR 0 2
60496: PUSH
60497: LD_INT 4
60499: ARRAY
60500: PPUSH
60501: CALL_OW 449
60505: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60506: LD_ADDR_VAR 0 3
60510: PUSH
60511: LD_VAR 0 5
60515: PPUSH
60516: LD_INT 1
60518: PPUSH
60519: CALL_OW 275
60523: PUSH
60524: LD_VAR 0 4
60528: PUSH
60529: LD_INT 1
60531: ARRAY
60532: GREATEREQUAL
60533: PUSH
60534: LD_VAR 0 5
60538: PPUSH
60539: LD_INT 2
60541: PPUSH
60542: CALL_OW 275
60546: PUSH
60547: LD_VAR 0 4
60551: PUSH
60552: LD_INT 2
60554: ARRAY
60555: GREATEREQUAL
60556: AND
60557: PUSH
60558: LD_VAR 0 5
60562: PPUSH
60563: LD_INT 3
60565: PPUSH
60566: CALL_OW 275
60570: PUSH
60571: LD_VAR 0 4
60575: PUSH
60576: LD_INT 3
60578: ARRAY
60579: GREATEREQUAL
60580: AND
60581: ST_TO_ADDR
// end ;
60582: LD_VAR 0 3
60586: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60587: LD_INT 0
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
// pom := GetBase ( building ) ;
60593: LD_ADDR_VAR 0 3
60597: PUSH
60598: LD_VAR 0 1
60602: PPUSH
60603: CALL_OW 274
60607: ST_TO_ADDR
// if not pom then
60608: LD_VAR 0 3
60612: NOT
60613: IFFALSE 60617
// exit ;
60615: GO 60787
// btype := GetBType ( building ) ;
60617: LD_ADDR_VAR 0 5
60621: PUSH
60622: LD_VAR 0 1
60626: PPUSH
60627: CALL_OW 266
60631: ST_TO_ADDR
// if btype = b_armoury then
60632: LD_VAR 0 5
60636: PUSH
60637: LD_INT 4
60639: EQUAL
60640: IFFALSE 60650
// btype := b_barracks ;
60642: LD_ADDR_VAR 0 5
60646: PUSH
60647: LD_INT 5
60649: ST_TO_ADDR
// if btype = b_depot then
60650: LD_VAR 0 5
60654: PUSH
60655: LD_INT 0
60657: EQUAL
60658: IFFALSE 60668
// btype := b_warehouse ;
60660: LD_ADDR_VAR 0 5
60664: PUSH
60665: LD_INT 1
60667: ST_TO_ADDR
// if btype = b_workshop then
60668: LD_VAR 0 5
60672: PUSH
60673: LD_INT 2
60675: EQUAL
60676: IFFALSE 60686
// btype := b_factory ;
60678: LD_ADDR_VAR 0 5
60682: PUSH
60683: LD_INT 3
60685: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60686: LD_ADDR_VAR 0 4
60690: PUSH
60691: LD_VAR 0 5
60695: PPUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: CALL_OW 248
60705: PPUSH
60706: CALL_OW 450
60710: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60711: LD_ADDR_VAR 0 2
60715: PUSH
60716: LD_VAR 0 3
60720: PPUSH
60721: LD_INT 1
60723: PPUSH
60724: CALL_OW 275
60728: PUSH
60729: LD_VAR 0 4
60733: PUSH
60734: LD_INT 1
60736: ARRAY
60737: GREATEREQUAL
60738: PUSH
60739: LD_VAR 0 3
60743: PPUSH
60744: LD_INT 2
60746: PPUSH
60747: CALL_OW 275
60751: PUSH
60752: LD_VAR 0 4
60756: PUSH
60757: LD_INT 2
60759: ARRAY
60760: GREATEREQUAL
60761: AND
60762: PUSH
60763: LD_VAR 0 3
60767: PPUSH
60768: LD_INT 3
60770: PPUSH
60771: CALL_OW 275
60775: PUSH
60776: LD_VAR 0 4
60780: PUSH
60781: LD_INT 3
60783: ARRAY
60784: GREATEREQUAL
60785: AND
60786: ST_TO_ADDR
// end ;
60787: LD_VAR 0 2
60791: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60792: LD_INT 0
60794: PPUSH
60795: PPUSH
60796: PPUSH
// pom := GetBase ( building ) ;
60797: LD_ADDR_VAR 0 4
60801: PUSH
60802: LD_VAR 0 1
60806: PPUSH
60807: CALL_OW 274
60811: ST_TO_ADDR
// if not pom then
60812: LD_VAR 0 4
60816: NOT
60817: IFFALSE 60821
// exit ;
60819: GO 60922
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60821: LD_ADDR_VAR 0 5
60825: PUSH
60826: LD_VAR 0 2
60830: PPUSH
60831: LD_VAR 0 1
60835: PPUSH
60836: CALL_OW 248
60840: PPUSH
60841: CALL_OW 450
60845: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60846: LD_ADDR_VAR 0 3
60850: PUSH
60851: LD_VAR 0 4
60855: PPUSH
60856: LD_INT 1
60858: PPUSH
60859: CALL_OW 275
60863: PUSH
60864: LD_VAR 0 5
60868: PUSH
60869: LD_INT 1
60871: ARRAY
60872: GREATEREQUAL
60873: PUSH
60874: LD_VAR 0 4
60878: PPUSH
60879: LD_INT 2
60881: PPUSH
60882: CALL_OW 275
60886: PUSH
60887: LD_VAR 0 5
60891: PUSH
60892: LD_INT 2
60894: ARRAY
60895: GREATEREQUAL
60896: AND
60897: PUSH
60898: LD_VAR 0 4
60902: PPUSH
60903: LD_INT 3
60905: PPUSH
60906: CALL_OW 275
60910: PUSH
60911: LD_VAR 0 5
60915: PUSH
60916: LD_INT 3
60918: ARRAY
60919: GREATEREQUAL
60920: AND
60921: ST_TO_ADDR
// end ;
60922: LD_VAR 0 3
60926: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60927: LD_INT 0
60929: PPUSH
60930: PPUSH
60931: PPUSH
60932: PPUSH
60933: PPUSH
60934: PPUSH
60935: PPUSH
60936: PPUSH
60937: PPUSH
60938: PPUSH
60939: PPUSH
// result := false ;
60940: LD_ADDR_VAR 0 8
60944: PUSH
60945: LD_INT 0
60947: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60948: LD_VAR 0 5
60952: NOT
60953: PUSH
60954: LD_VAR 0 1
60958: NOT
60959: OR
60960: PUSH
60961: LD_VAR 0 2
60965: NOT
60966: OR
60967: PUSH
60968: LD_VAR 0 3
60972: NOT
60973: OR
60974: IFFALSE 60978
// exit ;
60976: GO 61792
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60978: LD_ADDR_VAR 0 14
60982: PUSH
60983: LD_VAR 0 1
60987: PPUSH
60988: LD_VAR 0 2
60992: PPUSH
60993: LD_VAR 0 3
60997: PPUSH
60998: LD_VAR 0 4
61002: PPUSH
61003: LD_VAR 0 5
61007: PUSH
61008: LD_INT 1
61010: ARRAY
61011: PPUSH
61012: CALL_OW 248
61016: PPUSH
61017: LD_INT 0
61019: PPUSH
61020: CALL 63045 0 6
61024: ST_TO_ADDR
// if not hexes then
61025: LD_VAR 0 14
61029: NOT
61030: IFFALSE 61034
// exit ;
61032: GO 61792
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61034: LD_ADDR_VAR 0 17
61038: PUSH
61039: LD_VAR 0 5
61043: PPUSH
61044: LD_INT 22
61046: PUSH
61047: LD_VAR 0 13
61051: PPUSH
61052: CALL_OW 255
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: PUSH
61061: LD_INT 2
61063: PUSH
61064: LD_INT 30
61066: PUSH
61067: LD_INT 0
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 30
61076: PUSH
61077: LD_INT 1
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: LIST
61088: PUSH
61089: EMPTY
61090: LIST
61091: LIST
61092: PPUSH
61093: CALL_OW 72
61097: ST_TO_ADDR
// for i = 1 to hexes do
61098: LD_ADDR_VAR 0 9
61102: PUSH
61103: DOUBLE
61104: LD_INT 1
61106: DEC
61107: ST_TO_ADDR
61108: LD_VAR 0 14
61112: PUSH
61113: FOR_TO
61114: IFFALSE 61790
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61116: LD_ADDR_VAR 0 13
61120: PUSH
61121: LD_VAR 0 14
61125: PUSH
61126: LD_VAR 0 9
61130: ARRAY
61131: PUSH
61132: LD_INT 1
61134: ARRAY
61135: PPUSH
61136: LD_VAR 0 14
61140: PUSH
61141: LD_VAR 0 9
61145: ARRAY
61146: PUSH
61147: LD_INT 2
61149: ARRAY
61150: PPUSH
61151: CALL_OW 428
61155: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61156: LD_VAR 0 14
61160: PUSH
61161: LD_VAR 0 9
61165: ARRAY
61166: PUSH
61167: LD_INT 1
61169: ARRAY
61170: PPUSH
61171: LD_VAR 0 14
61175: PUSH
61176: LD_VAR 0 9
61180: ARRAY
61181: PUSH
61182: LD_INT 2
61184: ARRAY
61185: PPUSH
61186: CALL_OW 351
61190: PUSH
61191: LD_VAR 0 14
61195: PUSH
61196: LD_VAR 0 9
61200: ARRAY
61201: PUSH
61202: LD_INT 1
61204: ARRAY
61205: PPUSH
61206: LD_VAR 0 14
61210: PUSH
61211: LD_VAR 0 9
61215: ARRAY
61216: PUSH
61217: LD_INT 2
61219: ARRAY
61220: PPUSH
61221: CALL_OW 488
61225: NOT
61226: OR
61227: PUSH
61228: LD_VAR 0 13
61232: PPUSH
61233: CALL_OW 247
61237: PUSH
61238: LD_INT 3
61240: EQUAL
61241: OR
61242: IFFALSE 61248
// exit ;
61244: POP
61245: POP
61246: GO 61792
// if not tmp then
61248: LD_VAR 0 13
61252: NOT
61253: IFFALSE 61257
// continue ;
61255: GO 61113
// result := true ;
61257: LD_ADDR_VAR 0 8
61261: PUSH
61262: LD_INT 1
61264: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61265: LD_VAR 0 6
61269: PUSH
61270: LD_VAR 0 13
61274: PPUSH
61275: CALL_OW 247
61279: PUSH
61280: LD_INT 2
61282: EQUAL
61283: AND
61284: PUSH
61285: LD_VAR 0 13
61289: PPUSH
61290: CALL_OW 263
61294: PUSH
61295: LD_INT 1
61297: EQUAL
61298: AND
61299: IFFALSE 61463
// begin if IsDrivenBy ( tmp ) then
61301: LD_VAR 0 13
61305: PPUSH
61306: CALL_OW 311
61310: IFFALSE 61314
// continue ;
61312: GO 61113
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61314: LD_VAR 0 6
61318: PPUSH
61319: LD_INT 3
61321: PUSH
61322: LD_INT 60
61324: PUSH
61325: EMPTY
61326: LIST
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: PUSH
61332: LD_INT 3
61334: PUSH
61335: LD_INT 55
61337: PUSH
61338: EMPTY
61339: LIST
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PPUSH
61349: CALL_OW 72
61353: IFFALSE 61461
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61355: LD_ADDR_VAR 0 18
61359: PUSH
61360: LD_VAR 0 6
61364: PPUSH
61365: LD_INT 3
61367: PUSH
61368: LD_INT 60
61370: PUSH
61371: EMPTY
61372: LIST
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: PUSH
61378: LD_INT 3
61380: PUSH
61381: LD_INT 55
61383: PUSH
61384: EMPTY
61385: LIST
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: PUSH
61400: LD_INT 1
61402: ARRAY
61403: ST_TO_ADDR
// if IsInUnit ( driver ) then
61404: LD_VAR 0 18
61408: PPUSH
61409: CALL_OW 310
61413: IFFALSE 61424
// ComExit ( driver ) ;
61415: LD_VAR 0 18
61419: PPUSH
61420: CALL 86824 0 1
// AddComEnterUnit ( driver , tmp ) ;
61424: LD_VAR 0 18
61428: PPUSH
61429: LD_VAR 0 13
61433: PPUSH
61434: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61438: LD_VAR 0 18
61442: PPUSH
61443: LD_VAR 0 7
61447: PPUSH
61448: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61452: LD_VAR 0 18
61456: PPUSH
61457: CALL_OW 181
// end ; continue ;
61461: GO 61113
// end ; if not cleaners or not tmp in cleaners then
61463: LD_VAR 0 6
61467: NOT
61468: PUSH
61469: LD_VAR 0 13
61473: PUSH
61474: LD_VAR 0 6
61478: IN
61479: NOT
61480: OR
61481: IFFALSE 61788
// begin if dep then
61483: LD_VAR 0 17
61487: IFFALSE 61623
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61489: LD_ADDR_VAR 0 16
61493: PUSH
61494: LD_VAR 0 17
61498: PUSH
61499: LD_INT 1
61501: ARRAY
61502: PPUSH
61503: CALL_OW 250
61507: PPUSH
61508: LD_VAR 0 17
61512: PUSH
61513: LD_INT 1
61515: ARRAY
61516: PPUSH
61517: CALL_OW 254
61521: PPUSH
61522: LD_INT 5
61524: PPUSH
61525: CALL_OW 272
61529: PUSH
61530: LD_VAR 0 17
61534: PUSH
61535: LD_INT 1
61537: ARRAY
61538: PPUSH
61539: CALL_OW 251
61543: PPUSH
61544: LD_VAR 0 17
61548: PUSH
61549: LD_INT 1
61551: ARRAY
61552: PPUSH
61553: CALL_OW 254
61557: PPUSH
61558: LD_INT 5
61560: PPUSH
61561: CALL_OW 273
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61570: LD_VAR 0 16
61574: PUSH
61575: LD_INT 1
61577: ARRAY
61578: PPUSH
61579: LD_VAR 0 16
61583: PUSH
61584: LD_INT 2
61586: ARRAY
61587: PPUSH
61588: CALL_OW 488
61592: IFFALSE 61623
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61594: LD_VAR 0 13
61598: PPUSH
61599: LD_VAR 0 16
61603: PUSH
61604: LD_INT 1
61606: ARRAY
61607: PPUSH
61608: LD_VAR 0 16
61612: PUSH
61613: LD_INT 2
61615: ARRAY
61616: PPUSH
61617: CALL_OW 111
// continue ;
61621: GO 61113
// end ; end ; r := GetDir ( tmp ) ;
61623: LD_ADDR_VAR 0 15
61627: PUSH
61628: LD_VAR 0 13
61632: PPUSH
61633: CALL_OW 254
61637: ST_TO_ADDR
// if r = 5 then
61638: LD_VAR 0 15
61642: PUSH
61643: LD_INT 5
61645: EQUAL
61646: IFFALSE 61656
// r := 0 ;
61648: LD_ADDR_VAR 0 15
61652: PUSH
61653: LD_INT 0
61655: ST_TO_ADDR
// for j = r to 5 do
61656: LD_ADDR_VAR 0 10
61660: PUSH
61661: DOUBLE
61662: LD_VAR 0 15
61666: DEC
61667: ST_TO_ADDR
61668: LD_INT 5
61670: PUSH
61671: FOR_TO
61672: IFFALSE 61786
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61674: LD_ADDR_VAR 0 11
61678: PUSH
61679: LD_VAR 0 13
61683: PPUSH
61684: CALL_OW 250
61688: PPUSH
61689: LD_VAR 0 10
61693: PPUSH
61694: LD_INT 2
61696: PPUSH
61697: CALL_OW 272
61701: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61702: LD_ADDR_VAR 0 12
61706: PUSH
61707: LD_VAR 0 13
61711: PPUSH
61712: CALL_OW 251
61716: PPUSH
61717: LD_VAR 0 10
61721: PPUSH
61722: LD_INT 2
61724: PPUSH
61725: CALL_OW 273
61729: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61730: LD_VAR 0 11
61734: PPUSH
61735: LD_VAR 0 12
61739: PPUSH
61740: CALL_OW 488
61744: PUSH
61745: LD_VAR 0 11
61749: PPUSH
61750: LD_VAR 0 12
61754: PPUSH
61755: CALL_OW 428
61759: NOT
61760: AND
61761: IFFALSE 61784
// begin ComMoveXY ( tmp , _x , _y ) ;
61763: LD_VAR 0 13
61767: PPUSH
61768: LD_VAR 0 11
61772: PPUSH
61773: LD_VAR 0 12
61777: PPUSH
61778: CALL_OW 111
// break ;
61782: GO 61786
// end ; end ;
61784: GO 61671
61786: POP
61787: POP
// end ; end ;
61788: GO 61113
61790: POP
61791: POP
// end ;
61792: LD_VAR 0 8
61796: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61797: LD_INT 0
61799: PPUSH
// result := true ;
61800: LD_ADDR_VAR 0 3
61804: PUSH
61805: LD_INT 1
61807: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61808: LD_VAR 0 2
61812: PUSH
61813: LD_INT 24
61815: DOUBLE
61816: EQUAL
61817: IFTRUE 61827
61819: LD_INT 33
61821: DOUBLE
61822: EQUAL
61823: IFTRUE 61827
61825: GO 61852
61827: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61828: LD_ADDR_VAR 0 3
61832: PUSH
61833: LD_INT 32
61835: PPUSH
61836: LD_VAR 0 1
61840: PPUSH
61841: CALL_OW 321
61845: PUSH
61846: LD_INT 2
61848: EQUAL
61849: ST_TO_ADDR
61850: GO 62168
61852: LD_INT 20
61854: DOUBLE
61855: EQUAL
61856: IFTRUE 61860
61858: GO 61885
61860: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61861: LD_ADDR_VAR 0 3
61865: PUSH
61866: LD_INT 6
61868: PPUSH
61869: LD_VAR 0 1
61873: PPUSH
61874: CALL_OW 321
61878: PUSH
61879: LD_INT 2
61881: EQUAL
61882: ST_TO_ADDR
61883: GO 62168
61885: LD_INT 22
61887: DOUBLE
61888: EQUAL
61889: IFTRUE 61899
61891: LD_INT 36
61893: DOUBLE
61894: EQUAL
61895: IFTRUE 61899
61897: GO 61924
61899: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61900: LD_ADDR_VAR 0 3
61904: PUSH
61905: LD_INT 15
61907: PPUSH
61908: LD_VAR 0 1
61912: PPUSH
61913: CALL_OW 321
61917: PUSH
61918: LD_INT 2
61920: EQUAL
61921: ST_TO_ADDR
61922: GO 62168
61924: LD_INT 30
61926: DOUBLE
61927: EQUAL
61928: IFTRUE 61932
61930: GO 61957
61932: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61933: LD_ADDR_VAR 0 3
61937: PUSH
61938: LD_INT 20
61940: PPUSH
61941: LD_VAR 0 1
61945: PPUSH
61946: CALL_OW 321
61950: PUSH
61951: LD_INT 2
61953: EQUAL
61954: ST_TO_ADDR
61955: GO 62168
61957: LD_INT 28
61959: DOUBLE
61960: EQUAL
61961: IFTRUE 61971
61963: LD_INT 21
61965: DOUBLE
61966: EQUAL
61967: IFTRUE 61971
61969: GO 61996
61971: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61972: LD_ADDR_VAR 0 3
61976: PUSH
61977: LD_INT 21
61979: PPUSH
61980: LD_VAR 0 1
61984: PPUSH
61985: CALL_OW 321
61989: PUSH
61990: LD_INT 2
61992: EQUAL
61993: ST_TO_ADDR
61994: GO 62168
61996: LD_INT 16
61998: DOUBLE
61999: EQUAL
62000: IFTRUE 62004
62002: GO 62029
62004: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62005: LD_ADDR_VAR 0 3
62009: PUSH
62010: LD_INT 84
62012: PPUSH
62013: LD_VAR 0 1
62017: PPUSH
62018: CALL_OW 321
62022: PUSH
62023: LD_INT 2
62025: EQUAL
62026: ST_TO_ADDR
62027: GO 62168
62029: LD_INT 19
62031: DOUBLE
62032: EQUAL
62033: IFTRUE 62043
62035: LD_INT 23
62037: DOUBLE
62038: EQUAL
62039: IFTRUE 62043
62041: GO 62068
62043: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62044: LD_ADDR_VAR 0 3
62048: PUSH
62049: LD_INT 83
62051: PPUSH
62052: LD_VAR 0 1
62056: PPUSH
62057: CALL_OW 321
62061: PUSH
62062: LD_INT 2
62064: EQUAL
62065: ST_TO_ADDR
62066: GO 62168
62068: LD_INT 17
62070: DOUBLE
62071: EQUAL
62072: IFTRUE 62076
62074: GO 62101
62076: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62077: LD_ADDR_VAR 0 3
62081: PUSH
62082: LD_INT 39
62084: PPUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 321
62094: PUSH
62095: LD_INT 2
62097: EQUAL
62098: ST_TO_ADDR
62099: GO 62168
62101: LD_INT 18
62103: DOUBLE
62104: EQUAL
62105: IFTRUE 62109
62107: GO 62134
62109: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62110: LD_ADDR_VAR 0 3
62114: PUSH
62115: LD_INT 40
62117: PPUSH
62118: LD_VAR 0 1
62122: PPUSH
62123: CALL_OW 321
62127: PUSH
62128: LD_INT 2
62130: EQUAL
62131: ST_TO_ADDR
62132: GO 62168
62134: LD_INT 27
62136: DOUBLE
62137: EQUAL
62138: IFTRUE 62142
62140: GO 62167
62142: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62143: LD_ADDR_VAR 0 3
62147: PUSH
62148: LD_INT 35
62150: PPUSH
62151: LD_VAR 0 1
62155: PPUSH
62156: CALL_OW 321
62160: PUSH
62161: LD_INT 2
62163: EQUAL
62164: ST_TO_ADDR
62165: GO 62168
62167: POP
// end ;
62168: LD_VAR 0 3
62172: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62173: LD_INT 0
62175: PPUSH
62176: PPUSH
62177: PPUSH
62178: PPUSH
62179: PPUSH
62180: PPUSH
62181: PPUSH
62182: PPUSH
62183: PPUSH
62184: PPUSH
62185: PPUSH
// result := false ;
62186: LD_ADDR_VAR 0 6
62190: PUSH
62191: LD_INT 0
62193: ST_TO_ADDR
// if btype = b_depot then
62194: LD_VAR 0 2
62198: PUSH
62199: LD_INT 0
62201: EQUAL
62202: IFFALSE 62214
// begin result := true ;
62204: LD_ADDR_VAR 0 6
62208: PUSH
62209: LD_INT 1
62211: ST_TO_ADDR
// exit ;
62212: GO 63040
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62214: LD_VAR 0 1
62218: NOT
62219: PUSH
62220: LD_VAR 0 1
62224: PPUSH
62225: CALL_OW 266
62229: PUSH
62230: LD_INT 0
62232: PUSH
62233: LD_INT 1
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: IN
62240: NOT
62241: OR
62242: PUSH
62243: LD_VAR 0 2
62247: NOT
62248: OR
62249: PUSH
62250: LD_VAR 0 5
62254: PUSH
62255: LD_INT 0
62257: PUSH
62258: LD_INT 1
62260: PUSH
62261: LD_INT 2
62263: PUSH
62264: LD_INT 3
62266: PUSH
62267: LD_INT 4
62269: PUSH
62270: LD_INT 5
62272: PUSH
62273: EMPTY
62274: LIST
62275: LIST
62276: LIST
62277: LIST
62278: LIST
62279: LIST
62280: IN
62281: NOT
62282: OR
62283: PUSH
62284: LD_VAR 0 3
62288: PPUSH
62289: LD_VAR 0 4
62293: PPUSH
62294: CALL_OW 488
62298: NOT
62299: OR
62300: IFFALSE 62304
// exit ;
62302: GO 63040
// side := GetSide ( depot ) ;
62304: LD_ADDR_VAR 0 9
62308: PUSH
62309: LD_VAR 0 1
62313: PPUSH
62314: CALL_OW 255
62318: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62319: LD_VAR 0 9
62323: PPUSH
62324: LD_VAR 0 2
62328: PPUSH
62329: CALL 61797 0 2
62333: NOT
62334: IFFALSE 62338
// exit ;
62336: GO 63040
// pom := GetBase ( depot ) ;
62338: LD_ADDR_VAR 0 10
62342: PUSH
62343: LD_VAR 0 1
62347: PPUSH
62348: CALL_OW 274
62352: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62353: LD_ADDR_VAR 0 11
62357: PUSH
62358: LD_VAR 0 2
62362: PPUSH
62363: LD_VAR 0 1
62367: PPUSH
62368: CALL_OW 248
62372: PPUSH
62373: CALL_OW 450
62377: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62378: LD_VAR 0 10
62382: PPUSH
62383: LD_INT 1
62385: PPUSH
62386: CALL_OW 275
62390: PUSH
62391: LD_VAR 0 11
62395: PUSH
62396: LD_INT 1
62398: ARRAY
62399: GREATEREQUAL
62400: PUSH
62401: LD_VAR 0 10
62405: PPUSH
62406: LD_INT 2
62408: PPUSH
62409: CALL_OW 275
62413: PUSH
62414: LD_VAR 0 11
62418: PUSH
62419: LD_INT 2
62421: ARRAY
62422: GREATEREQUAL
62423: AND
62424: PUSH
62425: LD_VAR 0 10
62429: PPUSH
62430: LD_INT 3
62432: PPUSH
62433: CALL_OW 275
62437: PUSH
62438: LD_VAR 0 11
62442: PUSH
62443: LD_INT 3
62445: ARRAY
62446: GREATEREQUAL
62447: AND
62448: NOT
62449: IFFALSE 62453
// exit ;
62451: GO 63040
// if GetBType ( depot ) = b_depot then
62453: LD_VAR 0 1
62457: PPUSH
62458: CALL_OW 266
62462: PUSH
62463: LD_INT 0
62465: EQUAL
62466: IFFALSE 62478
// dist := 28 else
62468: LD_ADDR_VAR 0 14
62472: PUSH
62473: LD_INT 28
62475: ST_TO_ADDR
62476: GO 62486
// dist := 36 ;
62478: LD_ADDR_VAR 0 14
62482: PUSH
62483: LD_INT 36
62485: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62486: LD_VAR 0 1
62490: PPUSH
62491: LD_VAR 0 3
62495: PPUSH
62496: LD_VAR 0 4
62500: PPUSH
62501: CALL_OW 297
62505: PUSH
62506: LD_VAR 0 14
62510: GREATER
62511: IFFALSE 62515
// exit ;
62513: GO 63040
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62515: LD_ADDR_VAR 0 12
62519: PUSH
62520: LD_VAR 0 2
62524: PPUSH
62525: LD_VAR 0 3
62529: PPUSH
62530: LD_VAR 0 4
62534: PPUSH
62535: LD_VAR 0 5
62539: PPUSH
62540: LD_VAR 0 1
62544: PPUSH
62545: CALL_OW 248
62549: PPUSH
62550: LD_INT 0
62552: PPUSH
62553: CALL 63045 0 6
62557: ST_TO_ADDR
// if not hexes then
62558: LD_VAR 0 12
62562: NOT
62563: IFFALSE 62567
// exit ;
62565: GO 63040
// hex := GetHexInfo ( x , y ) ;
62567: LD_ADDR_VAR 0 15
62571: PUSH
62572: LD_VAR 0 3
62576: PPUSH
62577: LD_VAR 0 4
62581: PPUSH
62582: CALL_OW 546
62586: ST_TO_ADDR
// if hex [ 1 ] then
62587: LD_VAR 0 15
62591: PUSH
62592: LD_INT 1
62594: ARRAY
62595: IFFALSE 62599
// exit ;
62597: GO 63040
// height := hex [ 2 ] ;
62599: LD_ADDR_VAR 0 13
62603: PUSH
62604: LD_VAR 0 15
62608: PUSH
62609: LD_INT 2
62611: ARRAY
62612: ST_TO_ADDR
// for i = 1 to hexes do
62613: LD_ADDR_VAR 0 7
62617: PUSH
62618: DOUBLE
62619: LD_INT 1
62621: DEC
62622: ST_TO_ADDR
62623: LD_VAR 0 12
62627: PUSH
62628: FOR_TO
62629: IFFALSE 62959
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62631: LD_VAR 0 12
62635: PUSH
62636: LD_VAR 0 7
62640: ARRAY
62641: PUSH
62642: LD_INT 1
62644: ARRAY
62645: PPUSH
62646: LD_VAR 0 12
62650: PUSH
62651: LD_VAR 0 7
62655: ARRAY
62656: PUSH
62657: LD_INT 2
62659: ARRAY
62660: PPUSH
62661: CALL_OW 488
62665: NOT
62666: PUSH
62667: LD_VAR 0 12
62671: PUSH
62672: LD_VAR 0 7
62676: ARRAY
62677: PUSH
62678: LD_INT 1
62680: ARRAY
62681: PPUSH
62682: LD_VAR 0 12
62686: PUSH
62687: LD_VAR 0 7
62691: ARRAY
62692: PUSH
62693: LD_INT 2
62695: ARRAY
62696: PPUSH
62697: CALL_OW 428
62701: PUSH
62702: LD_INT 0
62704: GREATER
62705: OR
62706: PUSH
62707: LD_VAR 0 12
62711: PUSH
62712: LD_VAR 0 7
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PPUSH
62722: LD_VAR 0 12
62726: PUSH
62727: LD_VAR 0 7
62731: ARRAY
62732: PUSH
62733: LD_INT 2
62735: ARRAY
62736: PPUSH
62737: CALL_OW 351
62741: OR
62742: IFFALSE 62748
// exit ;
62744: POP
62745: POP
62746: GO 63040
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62748: LD_ADDR_VAR 0 8
62752: PUSH
62753: LD_VAR 0 12
62757: PUSH
62758: LD_VAR 0 7
62762: ARRAY
62763: PUSH
62764: LD_INT 1
62766: ARRAY
62767: PPUSH
62768: LD_VAR 0 12
62772: PUSH
62773: LD_VAR 0 7
62777: ARRAY
62778: PUSH
62779: LD_INT 2
62781: ARRAY
62782: PPUSH
62783: CALL_OW 546
62787: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62788: LD_VAR 0 8
62792: PUSH
62793: LD_INT 1
62795: ARRAY
62796: PUSH
62797: LD_VAR 0 8
62801: PUSH
62802: LD_INT 2
62804: ARRAY
62805: PUSH
62806: LD_VAR 0 13
62810: PUSH
62811: LD_INT 2
62813: PLUS
62814: GREATER
62815: OR
62816: PUSH
62817: LD_VAR 0 8
62821: PUSH
62822: LD_INT 2
62824: ARRAY
62825: PUSH
62826: LD_VAR 0 13
62830: PUSH
62831: LD_INT 2
62833: MINUS
62834: LESS
62835: OR
62836: PUSH
62837: LD_VAR 0 8
62841: PUSH
62842: LD_INT 3
62844: ARRAY
62845: PUSH
62846: LD_INT 0
62848: PUSH
62849: LD_INT 8
62851: PUSH
62852: LD_INT 9
62854: PUSH
62855: LD_INT 10
62857: PUSH
62858: LD_INT 11
62860: PUSH
62861: LD_INT 12
62863: PUSH
62864: LD_INT 13
62866: PUSH
62867: LD_INT 16
62869: PUSH
62870: LD_INT 17
62872: PUSH
62873: LD_INT 18
62875: PUSH
62876: LD_INT 19
62878: PUSH
62879: LD_INT 20
62881: PUSH
62882: LD_INT 21
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: LIST
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: IN
62900: NOT
62901: OR
62902: PUSH
62903: LD_VAR 0 8
62907: PUSH
62908: LD_INT 5
62910: ARRAY
62911: NOT
62912: OR
62913: PUSH
62914: LD_VAR 0 8
62918: PUSH
62919: LD_INT 6
62921: ARRAY
62922: PUSH
62923: LD_INT 1
62925: PUSH
62926: LD_INT 2
62928: PUSH
62929: LD_INT 7
62931: PUSH
62932: LD_INT 9
62934: PUSH
62935: LD_INT 10
62937: PUSH
62938: LD_INT 11
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: LIST
62947: LIST
62948: IN
62949: NOT
62950: OR
62951: IFFALSE 62957
// exit ;
62953: POP
62954: POP
62955: GO 63040
// end ;
62957: GO 62628
62959: POP
62960: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62961: LD_VAR 0 9
62965: PPUSH
62966: LD_VAR 0 3
62970: PPUSH
62971: LD_VAR 0 4
62975: PPUSH
62976: LD_INT 20
62978: PPUSH
62979: CALL 54963 0 4
62983: PUSH
62984: LD_INT 4
62986: ARRAY
62987: IFFALSE 62991
// exit ;
62989: GO 63040
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62991: LD_VAR 0 2
62995: PUSH
62996: LD_INT 29
62998: PUSH
62999: LD_INT 30
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: IN
63006: PUSH
63007: LD_VAR 0 3
63011: PPUSH
63012: LD_VAR 0 4
63016: PPUSH
63017: LD_VAR 0 9
63021: PPUSH
63022: CALL_OW 440
63026: NOT
63027: AND
63028: IFFALSE 63032
// exit ;
63030: GO 63040
// result := true ;
63032: LD_ADDR_VAR 0 6
63036: PUSH
63037: LD_INT 1
63039: ST_TO_ADDR
// end ;
63040: LD_VAR 0 6
63044: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63045: LD_INT 0
63047: PPUSH
63048: PPUSH
63049: PPUSH
63050: PPUSH
63051: PPUSH
63052: PPUSH
63053: PPUSH
63054: PPUSH
63055: PPUSH
63056: PPUSH
63057: PPUSH
63058: PPUSH
63059: PPUSH
63060: PPUSH
63061: PPUSH
63062: PPUSH
63063: PPUSH
63064: PPUSH
63065: PPUSH
63066: PPUSH
63067: PPUSH
63068: PPUSH
63069: PPUSH
63070: PPUSH
63071: PPUSH
63072: PPUSH
63073: PPUSH
63074: PPUSH
63075: PPUSH
63076: PPUSH
63077: PPUSH
63078: PPUSH
63079: PPUSH
63080: PPUSH
63081: PPUSH
63082: PPUSH
63083: PPUSH
63084: PPUSH
63085: PPUSH
63086: PPUSH
63087: PPUSH
63088: PPUSH
63089: PPUSH
63090: PPUSH
63091: PPUSH
63092: PPUSH
63093: PPUSH
63094: PPUSH
63095: PPUSH
63096: PPUSH
63097: PPUSH
63098: PPUSH
63099: PPUSH
63100: PPUSH
63101: PPUSH
63102: PPUSH
63103: PPUSH
63104: PPUSH
// result = [ ] ;
63105: LD_ADDR_VAR 0 7
63109: PUSH
63110: EMPTY
63111: ST_TO_ADDR
// temp_list = [ ] ;
63112: LD_ADDR_VAR 0 9
63116: PUSH
63117: EMPTY
63118: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63119: LD_VAR 0 4
63123: PUSH
63124: LD_INT 0
63126: PUSH
63127: LD_INT 1
63129: PUSH
63130: LD_INT 2
63132: PUSH
63133: LD_INT 3
63135: PUSH
63136: LD_INT 4
63138: PUSH
63139: LD_INT 5
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: IN
63150: NOT
63151: PUSH
63152: LD_VAR 0 1
63156: PUSH
63157: LD_INT 0
63159: PUSH
63160: LD_INT 1
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: IN
63167: PUSH
63168: LD_VAR 0 5
63172: PUSH
63173: LD_INT 1
63175: PUSH
63176: LD_INT 2
63178: PUSH
63179: LD_INT 3
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: IN
63187: NOT
63188: AND
63189: OR
63190: IFFALSE 63194
// exit ;
63192: GO 81585
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63194: LD_VAR 0 1
63198: PUSH
63199: LD_INT 6
63201: PUSH
63202: LD_INT 7
63204: PUSH
63205: LD_INT 8
63207: PUSH
63208: LD_INT 13
63210: PUSH
63211: LD_INT 12
63213: PUSH
63214: LD_INT 15
63216: PUSH
63217: LD_INT 11
63219: PUSH
63220: LD_INT 14
63222: PUSH
63223: LD_INT 10
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: IN
63237: IFFALSE 63247
// btype = b_lab ;
63239: LD_ADDR_VAR 0 1
63243: PUSH
63244: LD_INT 6
63246: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63247: LD_VAR 0 6
63251: PUSH
63252: LD_INT 0
63254: PUSH
63255: LD_INT 1
63257: PUSH
63258: LD_INT 2
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: LIST
63265: IN
63266: NOT
63267: PUSH
63268: LD_VAR 0 1
63272: PUSH
63273: LD_INT 0
63275: PUSH
63276: LD_INT 1
63278: PUSH
63279: LD_INT 2
63281: PUSH
63282: LD_INT 3
63284: PUSH
63285: LD_INT 6
63287: PUSH
63288: LD_INT 36
63290: PUSH
63291: LD_INT 4
63293: PUSH
63294: LD_INT 5
63296: PUSH
63297: LD_INT 31
63299: PUSH
63300: LD_INT 32
63302: PUSH
63303: LD_INT 33
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: LIST
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: LIST
63317: LIST
63318: IN
63319: NOT
63320: PUSH
63321: LD_VAR 0 6
63325: PUSH
63326: LD_INT 1
63328: EQUAL
63329: AND
63330: OR
63331: PUSH
63332: LD_VAR 0 1
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: LD_INT 3
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: IN
63347: NOT
63348: PUSH
63349: LD_VAR 0 6
63353: PUSH
63354: LD_INT 2
63356: EQUAL
63357: AND
63358: OR
63359: IFFALSE 63369
// mode = 0 ;
63361: LD_ADDR_VAR 0 6
63365: PUSH
63366: LD_INT 0
63368: ST_TO_ADDR
// case mode of 0 :
63369: LD_VAR 0 6
63373: PUSH
63374: LD_INT 0
63376: DOUBLE
63377: EQUAL
63378: IFTRUE 63382
63380: GO 74835
63382: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63383: LD_ADDR_VAR 0 11
63387: PUSH
63388: LD_INT 0
63390: PUSH
63391: LD_INT 0
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 0
63400: PUSH
63401: LD_INT 1
63403: NEG
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 1
63411: PUSH
63412: LD_INT 0
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 1
63421: PUSH
63422: LD_INT 1
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PUSH
63429: LD_INT 0
63431: PUSH
63432: LD_INT 1
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: PUSH
63439: LD_INT 1
63441: NEG
63442: PUSH
63443: LD_INT 0
63445: PUSH
63446: EMPTY
63447: LIST
63448: LIST
63449: PUSH
63450: LD_INT 1
63452: NEG
63453: PUSH
63454: LD_INT 1
63456: NEG
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 1
63464: NEG
63465: PUSH
63466: LD_INT 2
63468: NEG
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: LD_INT 2
63479: NEG
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: LD_INT 1
63490: NEG
63491: PUSH
63492: EMPTY
63493: LIST
63494: LIST
63495: PUSH
63496: LD_INT 1
63498: PUSH
63499: LD_INT 2
63501: PUSH
63502: EMPTY
63503: LIST
63504: LIST
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: LD_INT 2
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PUSH
63516: LD_INT 1
63518: NEG
63519: PUSH
63520: LD_INT 1
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: PUSH
63527: LD_INT 1
63529: PUSH
63530: LD_INT 3
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: LD_INT 3
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: LD_INT 2
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: LIST
63567: LIST
63568: LIST
63569: LIST
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: LIST
63575: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63576: LD_ADDR_VAR 0 12
63580: PUSH
63581: LD_INT 0
63583: PUSH
63584: LD_INT 0
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 0
63593: PUSH
63594: LD_INT 1
63596: NEG
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 1
63604: PUSH
63605: LD_INT 0
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 1
63614: PUSH
63615: LD_INT 1
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 0
63624: PUSH
63625: LD_INT 1
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 1
63634: NEG
63635: PUSH
63636: LD_INT 0
63638: PUSH
63639: EMPTY
63640: LIST
63641: LIST
63642: PUSH
63643: LD_INT 1
63645: NEG
63646: PUSH
63647: LD_INT 1
63649: NEG
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 1
63657: PUSH
63658: LD_INT 1
63660: NEG
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: LD_INT 2
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 2
63678: PUSH
63679: LD_INT 1
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 1
63688: NEG
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 2
63699: NEG
63700: PUSH
63701: LD_INT 0
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 2
63710: NEG
63711: PUSH
63712: LD_INT 1
63714: NEG
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 2
63722: NEG
63723: PUSH
63724: LD_INT 1
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 3
63733: NEG
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 3
63744: NEG
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63772: LD_ADDR_VAR 0 13
63776: PUSH
63777: LD_INT 0
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 0
63789: PUSH
63790: LD_INT 1
63792: NEG
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PUSH
63798: LD_INT 1
63800: PUSH
63801: LD_INT 0
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 0
63820: PUSH
63821: LD_INT 1
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: NEG
63831: PUSH
63832: LD_INT 0
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: NEG
63842: PUSH
63843: LD_INT 1
63845: NEG
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 1
63853: NEG
63854: PUSH
63855: LD_INT 2
63857: NEG
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PUSH
63863: LD_INT 2
63865: PUSH
63866: LD_INT 1
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 2
63875: PUSH
63876: LD_INT 2
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: LD_INT 1
63885: PUSH
63886: LD_INT 2
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 2
63895: NEG
63896: PUSH
63897: LD_INT 1
63899: NEG
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 2
63907: NEG
63908: PUSH
63909: LD_INT 2
63911: NEG
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 2
63919: NEG
63920: PUSH
63921: LD_INT 3
63923: NEG
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 3
63931: NEG
63932: PUSH
63933: LD_INT 2
63935: NEG
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 3
63943: NEG
63944: PUSH
63945: LD_INT 3
63947: NEG
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: LIST
63970: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63971: LD_ADDR_VAR 0 14
63975: PUSH
63976: LD_INT 0
63978: PUSH
63979: LD_INT 0
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 0
63988: PUSH
63989: LD_INT 1
63991: NEG
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PUSH
63997: LD_INT 1
63999: PUSH
64000: LD_INT 0
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 1
64009: PUSH
64010: LD_INT 1
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 0
64019: PUSH
64020: LD_INT 1
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 1
64029: NEG
64030: PUSH
64031: LD_INT 0
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: LD_INT 1
64040: NEG
64041: PUSH
64042: LD_INT 1
64044: NEG
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 1
64052: NEG
64053: PUSH
64054: LD_INT 2
64056: NEG
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 0
64064: PUSH
64065: LD_INT 2
64067: NEG
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 1
64075: PUSH
64076: LD_INT 1
64078: NEG
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 1
64086: PUSH
64087: LD_INT 2
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 0
64096: PUSH
64097: LD_INT 2
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 1
64106: NEG
64107: PUSH
64108: LD_INT 1
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PUSH
64115: LD_INT 1
64117: NEG
64118: PUSH
64119: LD_INT 3
64121: NEG
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 0
64129: PUSH
64130: LD_INT 3
64132: NEG
64133: PUSH
64134: EMPTY
64135: LIST
64136: LIST
64137: PUSH
64138: LD_INT 1
64140: PUSH
64141: LD_INT 2
64143: NEG
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: LIST
64158: LIST
64159: LIST
64160: LIST
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: LIST
64166: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64167: LD_ADDR_VAR 0 15
64171: PUSH
64172: LD_INT 0
64174: PUSH
64175: LD_INT 0
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 0
64184: PUSH
64185: LD_INT 1
64187: NEG
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: LD_INT 0
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 1
64205: PUSH
64206: LD_INT 1
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: LD_INT 0
64215: PUSH
64216: LD_INT 1
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: LD_INT 1
64225: NEG
64226: PUSH
64227: LD_INT 0
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 1
64236: NEG
64237: PUSH
64238: LD_INT 1
64240: NEG
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 1
64248: PUSH
64249: LD_INT 1
64251: NEG
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 2
64259: PUSH
64260: LD_INT 0
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 2
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 1
64279: NEG
64280: PUSH
64281: LD_INT 1
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 2
64290: NEG
64291: PUSH
64292: LD_INT 0
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: PUSH
64299: LD_INT 2
64301: NEG
64302: PUSH
64303: LD_INT 1
64305: NEG
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: LD_INT 3
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 3
64334: PUSH
64335: LD_INT 1
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: LIST
64349: LIST
64350: LIST
64351: LIST
64352: LIST
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64360: LD_ADDR_VAR 0 16
64364: PUSH
64365: LD_INT 0
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 0
64377: PUSH
64378: LD_INT 1
64380: NEG
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: LD_INT 1
64388: PUSH
64389: LD_INT 0
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 1
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 0
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PUSH
64416: LD_INT 1
64418: NEG
64419: PUSH
64420: LD_INT 0
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: LD_INT 1
64429: NEG
64430: PUSH
64431: LD_INT 1
64433: NEG
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 1
64441: NEG
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 2
64453: PUSH
64454: LD_INT 1
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PUSH
64461: LD_INT 2
64463: PUSH
64464: LD_INT 2
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 1
64473: PUSH
64474: LD_INT 2
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 2
64483: NEG
64484: PUSH
64485: LD_INT 1
64487: NEG
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PUSH
64493: LD_INT 2
64495: NEG
64496: PUSH
64497: LD_INT 2
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 3
64507: PUSH
64508: LD_INT 2
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 3
64517: PUSH
64518: LD_INT 3
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 2
64527: PUSH
64528: LD_INT 3
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64553: LD_ADDR_VAR 0 17
64557: PUSH
64558: LD_INT 0
64560: PUSH
64561: LD_INT 0
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: LD_INT 1
64573: NEG
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 1
64581: PUSH
64582: LD_INT 0
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: LD_INT 1
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 0
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 1
64611: NEG
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: LD_INT 1
64626: NEG
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 1
64634: NEG
64635: PUSH
64636: LD_INT 2
64638: NEG
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: LD_INT 2
64649: NEG
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: LD_INT 1
64660: NEG
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: LD_INT 2
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 2
64678: PUSH
64679: LD_INT 1
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: LD_INT 2
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 1
64698: PUSH
64699: LD_INT 2
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: LD_INT 2
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 1
64718: NEG
64719: PUSH
64720: LD_INT 1
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PUSH
64727: LD_INT 2
64729: NEG
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 2
64740: NEG
64741: PUSH
64742: LD_INT 1
64744: NEG
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 2
64752: NEG
64753: PUSH
64754: LD_INT 2
64756: NEG
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64783: LD_ADDR_VAR 0 18
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: LD_INT 0
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: LD_INT 0
64800: PUSH
64801: LD_INT 1
64803: NEG
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 1
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 0
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 1
64841: NEG
64842: PUSH
64843: LD_INT 0
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 1
64852: NEG
64853: PUSH
64854: LD_INT 1
64856: NEG
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 1
64864: NEG
64865: PUSH
64866: LD_INT 2
64868: NEG
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: LD_INT 2
64879: NEG
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: LD_INT 1
64890: NEG
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PUSH
64896: LD_INT 2
64898: PUSH
64899: LD_INT 0
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: LD_INT 1
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: LD_INT 2
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: LD_INT 1
64928: PUSH
64929: LD_INT 2
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 2
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 1
64948: NEG
64949: PUSH
64950: LD_INT 1
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 2
64959: NEG
64960: PUSH
64961: LD_INT 0
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 2
64970: NEG
64971: PUSH
64972: LD_INT 1
64974: NEG
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 2
64982: NEG
64983: PUSH
64984: LD_INT 2
64986: NEG
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65013: LD_ADDR_VAR 0 19
65017: PUSH
65018: LD_INT 0
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 0
65030: PUSH
65031: LD_INT 1
65033: NEG
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: LD_INT 0
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: LD_INT 1
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: LD_INT 1
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 1
65071: NEG
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 1
65094: NEG
65095: PUSH
65096: LD_INT 2
65098: NEG
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: LD_INT 2
65109: NEG
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: LD_INT 1
65120: NEG
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 2
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 2
65138: PUSH
65139: LD_INT 1
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: LD_INT 2
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: LD_INT 1
65158: PUSH
65159: LD_INT 2
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 2
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 1
65178: NEG
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 2
65189: NEG
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 2
65200: NEG
65201: PUSH
65202: LD_INT 1
65204: NEG
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 2
65212: NEG
65213: PUSH
65214: LD_INT 2
65216: NEG
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65243: LD_ADDR_VAR 0 20
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: LD_INT 0
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 0
65260: PUSH
65261: LD_INT 1
65263: NEG
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 0
65291: PUSH
65292: LD_INT 1
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 1
65301: NEG
65302: PUSH
65303: LD_INT 0
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 1
65312: NEG
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 1
65324: NEG
65325: PUSH
65326: LD_INT 2
65328: NEG
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 2
65339: NEG
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: LD_INT 1
65350: NEG
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 2
65358: PUSH
65359: LD_INT 0
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: PUSH
65369: LD_INT 1
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: LD_INT 2
65381: PUSH
65382: EMPTY
65383: LIST
65384: LIST
65385: PUSH
65386: LD_INT 1
65388: PUSH
65389: LD_INT 2
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 2
65401: PUSH
65402: EMPTY
65403: LIST
65404: LIST
65405: PUSH
65406: LD_INT 1
65408: NEG
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 2
65419: NEG
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: NEG
65431: PUSH
65432: LD_INT 1
65434: NEG
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 2
65442: NEG
65443: PUSH
65444: LD_INT 2
65446: NEG
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65473: LD_ADDR_VAR 0 21
65477: PUSH
65478: LD_INT 0
65480: PUSH
65481: LD_INT 0
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PUSH
65488: LD_INT 0
65490: PUSH
65491: LD_INT 1
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 1
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: LD_INT 1
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 0
65521: PUSH
65522: LD_INT 1
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 1
65531: NEG
65532: PUSH
65533: LD_INT 0
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 1
65542: NEG
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 1
65554: NEG
65555: PUSH
65556: LD_INT 2
65558: NEG
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: LD_INT 0
65566: PUSH
65567: LD_INT 2
65569: NEG
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 2
65588: PUSH
65589: LD_INT 0
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 2
65598: PUSH
65599: LD_INT 1
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 2
65608: PUSH
65609: LD_INT 2
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 1
65618: PUSH
65619: LD_INT 2
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 0
65628: PUSH
65629: LD_INT 2
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 1
65638: NEG
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 2
65649: NEG
65650: PUSH
65651: LD_INT 0
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 2
65660: NEG
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 2
65672: NEG
65673: PUSH
65674: LD_INT 2
65676: NEG
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65703: LD_ADDR_VAR 0 22
65707: PUSH
65708: LD_INT 0
65710: PUSH
65711: LD_INT 0
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: LD_INT 1
65723: NEG
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: LD_INT 1
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 0
65751: PUSH
65752: LD_INT 1
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 1
65761: NEG
65762: PUSH
65763: LD_INT 0
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 1
65772: NEG
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 1
65784: NEG
65785: PUSH
65786: LD_INT 2
65788: NEG
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 0
65796: PUSH
65797: LD_INT 2
65799: NEG
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 1
65807: PUSH
65808: LD_INT 1
65810: NEG
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: LD_INT 2
65818: PUSH
65819: LD_INT 0
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: LD_INT 1
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: LD_INT 2
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 1
65848: PUSH
65849: LD_INT 2
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: LD_INT 2
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: LD_INT 1
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 2
65879: NEG
65880: PUSH
65881: LD_INT 0
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 2
65890: NEG
65891: PUSH
65892: LD_INT 1
65894: NEG
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 2
65902: NEG
65903: PUSH
65904: LD_INT 2
65906: NEG
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65933: LD_ADDR_VAR 0 23
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: LD_INT 1
65953: NEG
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 1
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 1
65971: PUSH
65972: LD_INT 1
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 0
65981: PUSH
65982: LD_INT 1
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: PUSH
65989: LD_INT 1
65991: NEG
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 1
66002: NEG
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 1
66014: NEG
66015: PUSH
66016: LD_INT 2
66018: NEG
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: LD_INT 2
66029: NEG
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: LD_INT 1
66040: NEG
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 2
66048: PUSH
66049: LD_INT 0
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 2
66058: PUSH
66059: LD_INT 1
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 2
66068: PUSH
66069: LD_INT 2
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 1
66078: PUSH
66079: LD_INT 2
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 2
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: LD_INT 1
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 2
66109: NEG
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 2
66120: NEG
66121: PUSH
66122: LD_INT 1
66124: NEG
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 2
66132: NEG
66133: PUSH
66134: LD_INT 2
66136: NEG
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 2
66144: NEG
66145: PUSH
66146: LD_INT 3
66148: NEG
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 1
66156: NEG
66157: PUSH
66158: LD_INT 3
66160: NEG
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 1
66168: PUSH
66169: LD_INT 2
66171: NEG
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 2
66179: PUSH
66180: LD_INT 1
66182: NEG
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66213: LD_ADDR_VAR 0 24
66217: PUSH
66218: LD_INT 0
66220: PUSH
66221: LD_INT 0
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 1
66233: NEG
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: PUSH
66252: LD_INT 1
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 0
66261: PUSH
66262: LD_INT 1
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 1
66271: NEG
66272: PUSH
66273: LD_INT 0
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: NEG
66283: PUSH
66284: LD_INT 1
66286: NEG
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: LD_INT 2
66298: NEG
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: LD_INT 2
66309: NEG
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: LD_INT 1
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: LD_INT 1
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: PUSH
66349: LD_INT 2
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 0
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 2
66389: NEG
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 2
66400: NEG
66401: PUSH
66402: LD_INT 1
66404: NEG
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 2
66412: NEG
66413: PUSH
66414: LD_INT 2
66416: NEG
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: PUSH
66425: LD_INT 2
66427: NEG
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 2
66435: PUSH
66436: LD_INT 1
66438: NEG
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 3
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 3
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66489: LD_ADDR_VAR 0 25
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 0
66506: PUSH
66507: LD_INT 1
66509: NEG
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 1
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 1
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 1
66547: NEG
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 1
66558: NEG
66559: PUSH
66560: LD_INT 1
66562: NEG
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: LD_INT 2
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: LD_INT 2
66585: NEG
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: LD_INT 1
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 2
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: LD_INT 1
66634: PUSH
66635: LD_INT 2
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: LD_INT 2
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: LD_INT 1
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 2
66665: NEG
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 2
66676: NEG
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 2
66688: NEG
66689: PUSH
66690: LD_INT 2
66692: NEG
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 3
66700: PUSH
66701: LD_INT 1
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 3
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 2
66720: PUSH
66721: LD_INT 3
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: LD_INT 3
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66763: LD_ADDR_VAR 0 26
66767: PUSH
66768: LD_INT 0
66770: PUSH
66771: LD_INT 0
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: LD_INT 1
66783: NEG
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 1
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 1
66801: PUSH
66802: LD_INT 1
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 0
66811: PUSH
66812: LD_INT 1
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: NEG
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 1
66844: NEG
66845: PUSH
66846: LD_INT 2
66848: NEG
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: LD_INT 2
66859: NEG
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 1
66867: PUSH
66868: LD_INT 1
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 2
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 2
66888: PUSH
66889: LD_INT 1
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 2
66898: PUSH
66899: LD_INT 2
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 2
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 1
66928: NEG
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 2
66939: NEG
66940: PUSH
66941: LD_INT 0
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 2
66950: NEG
66951: PUSH
66952: LD_INT 1
66954: NEG
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 2
66962: NEG
66963: PUSH
66964: LD_INT 2
66966: NEG
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 2
66974: PUSH
66975: LD_INT 3
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 1
66984: PUSH
66985: LD_INT 3
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: NEG
66995: PUSH
66996: LD_INT 2
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 2
67005: NEG
67006: PUSH
67007: LD_INT 1
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67039: LD_ADDR_VAR 0 27
67043: PUSH
67044: LD_INT 0
67046: PUSH
67047: LD_INT 0
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 1
67059: NEG
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 1
67067: PUSH
67068: LD_INT 0
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: LD_INT 1
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 0
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 1
67108: NEG
67109: PUSH
67110: LD_INT 1
67112: NEG
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 1
67120: NEG
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 0
67132: PUSH
67133: LD_INT 2
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: LD_INT 1
67146: NEG
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 2
67154: PUSH
67155: LD_INT 0
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 2
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 2
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: LD_INT 2
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: LD_INT 2
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: LD_INT 1
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 2
67215: NEG
67216: PUSH
67217: LD_INT 0
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: LD_INT 1
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 2
67238: NEG
67239: PUSH
67240: LD_INT 2
67242: NEG
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PUSH
67248: LD_INT 1
67250: NEG
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 2
67261: NEG
67262: PUSH
67263: LD_INT 1
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 3
67272: NEG
67273: PUSH
67274: LD_INT 1
67276: NEG
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: LD_INT 3
67284: NEG
67285: PUSH
67286: LD_INT 2
67288: NEG
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67319: LD_ADDR_VAR 0 28
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: LD_INT 0
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 0
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: LD_INT 1
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: LD_INT 1
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 1
67377: NEG
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 1
67388: NEG
67389: PUSH
67390: LD_INT 1
67392: NEG
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 1
67400: NEG
67401: PUSH
67402: LD_INT 2
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: LD_INT 2
67415: NEG
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: PUSH
67424: LD_INT 1
67426: NEG
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 2
67434: PUSH
67435: LD_INT 0
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: LD_INT 1
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: LD_INT 2
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 1
67464: PUSH
67465: LD_INT 2
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 0
67474: PUSH
67475: LD_INT 2
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 1
67484: NEG
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 2
67495: NEG
67496: PUSH
67497: LD_INT 0
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 2
67506: NEG
67507: PUSH
67508: LD_INT 1
67510: NEG
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 2
67518: NEG
67519: PUSH
67520: LD_INT 2
67522: NEG
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 2
67530: NEG
67531: PUSH
67532: LD_INT 3
67534: NEG
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: NEG
67543: PUSH
67544: LD_INT 3
67546: NEG
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: LD_INT 3
67554: NEG
67555: PUSH
67556: LD_INT 1
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 3
67566: NEG
67567: PUSH
67568: LD_INT 2
67570: NEG
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67601: LD_ADDR_VAR 0 29
67605: PUSH
67606: LD_INT 0
67608: PUSH
67609: LD_INT 0
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 0
67618: PUSH
67619: LD_INT 1
67621: NEG
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 1
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 1
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 0
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 1
67659: NEG
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 1
67670: NEG
67671: PUSH
67672: LD_INT 1
67674: NEG
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: LD_INT 2
67686: NEG
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: LD_INT 2
67697: NEG
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 2
67716: PUSH
67717: LD_INT 0
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 2
67726: PUSH
67727: LD_INT 1
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: PUSH
67737: LD_INT 2
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: LD_INT 2
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: NEG
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: LD_INT 2
67767: NEG
67768: PUSH
67769: LD_INT 1
67771: NEG
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 2
67779: NEG
67780: PUSH
67781: LD_INT 2
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: NEG
67792: PUSH
67793: LD_INT 3
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 1
67806: NEG
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 3
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: LD_INT 3
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 1
67834: NEG
67835: PUSH
67836: LD_INT 2
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 3
67845: NEG
67846: PUSH
67847: LD_INT 2
67849: NEG
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67880: LD_ADDR_VAR 0 30
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: LD_INT 1
67900: NEG
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 1
67949: NEG
67950: PUSH
67951: LD_INT 1
67953: NEG
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 1
67961: NEG
67962: PUSH
67963: LD_INT 2
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: LD_INT 2
67976: NEG
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: PUSH
67985: LD_INT 1
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: LD_INT 2
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 1
68035: NEG
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: LD_INT 1
68061: NEG
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: LD_INT 3
68073: NEG
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 1
68081: PUSH
68082: LD_INT 2
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 3
68092: PUSH
68093: LD_INT 2
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 2
68102: PUSH
68103: LD_INT 3
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 2
68112: NEG
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 3
68123: NEG
68124: PUSH
68125: LD_INT 1
68127: NEG
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68158: LD_ADDR_VAR 0 31
68162: PUSH
68163: LD_INT 0
68165: PUSH
68166: LD_INT 0
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: LD_INT 1
68178: NEG
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 1
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 1
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 0
68206: PUSH
68207: LD_INT 1
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: NEG
68217: PUSH
68218: LD_INT 0
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 1
68227: NEG
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: LD_INT 2
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: PUSH
68252: LD_INT 1
68254: NEG
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 2
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 2
68272: PUSH
68273: LD_INT 1
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 2
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 0
68302: PUSH
68303: LD_INT 2
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 1
68312: NEG
68313: PUSH
68314: LD_INT 1
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 2
68323: NEG
68324: PUSH
68325: LD_INT 1
68327: NEG
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 2
68335: NEG
68336: PUSH
68337: LD_INT 2
68339: NEG
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 2
68347: NEG
68348: PUSH
68349: LD_INT 3
68351: NEG
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 2
68359: PUSH
68360: LD_INT 1
68362: NEG
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 3
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: PUSH
68381: LD_INT 3
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: LD_INT 2
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 3
68401: NEG
68402: PUSH
68403: LD_INT 2
68405: NEG
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68436: LD_ADDR_VAR 0 32
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 0
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 0
68453: PUSH
68454: LD_INT 1
68456: NEG
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 1
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 1
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 0
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: NEG
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 1
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: LD_INT 2
68521: NEG
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 0
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 1
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 2
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 2
68561: PUSH
68562: LD_INT 2
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 0
68581: PUSH
68582: LD_INT 2
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: LD_INT 1
68591: NEG
68592: PUSH
68593: LD_INT 1
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 2
68602: NEG
68603: PUSH
68604: LD_INT 0
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 2
68613: NEG
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 1
68625: NEG
68626: PUSH
68627: LD_INT 3
68629: NEG
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 2
68640: NEG
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 3
68648: PUSH
68649: LD_INT 2
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 2
68658: PUSH
68659: LD_INT 3
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 3
68679: NEG
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68714: LD_ADDR_VAR 0 33
68718: PUSH
68719: LD_INT 0
68721: PUSH
68722: LD_INT 0
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 1
68734: NEG
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: LD_INT 0
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: LD_INT 1
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 0
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 1
68783: NEG
68784: PUSH
68785: LD_INT 1
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: LD_INT 2
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 2
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 2
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 1
68838: PUSH
68839: LD_INT 2
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 0
68848: PUSH
68849: LD_INT 2
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: PUSH
68856: LD_INT 1
68858: NEG
68859: PUSH
68860: LD_INT 1
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: PUSH
68867: LD_INT 2
68869: NEG
68870: PUSH
68871: LD_INT 0
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 2
68880: NEG
68881: PUSH
68882: LD_INT 1
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 2
68892: NEG
68893: PUSH
68894: LD_INT 2
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 2
68904: NEG
68905: PUSH
68906: LD_INT 3
68908: NEG
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 2
68916: PUSH
68917: LD_INT 1
68919: NEG
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 3
68927: PUSH
68928: LD_INT 1
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: LD_INT 3
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 1
68947: NEG
68948: PUSH
68949: LD_INT 2
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 3
68958: NEG
68959: PUSH
68960: LD_INT 2
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68993: LD_ADDR_VAR 0 34
68997: PUSH
68998: LD_INT 0
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 1
69013: NEG
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 1
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 1
69031: PUSH
69032: LD_INT 1
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 0
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 1
69062: NEG
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: NEG
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 0
69086: PUSH
69087: LD_INT 2
69089: NEG
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 1
69100: NEG
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 2
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 2
69118: PUSH
69119: LD_INT 2
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: LD_INT 2
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 1
69138: NEG
69139: PUSH
69140: LD_INT 1
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 2
69149: NEG
69150: PUSH
69151: LD_INT 0
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 2
69160: NEG
69161: PUSH
69162: LD_INT 1
69164: NEG
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: LD_INT 2
69172: NEG
69173: PUSH
69174: LD_INT 2
69176: NEG
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 1
69184: NEG
69185: PUSH
69186: LD_INT 3
69188: NEG
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: PUSH
69197: LD_INT 2
69199: NEG
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 3
69207: PUSH
69208: LD_INT 2
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 2
69227: NEG
69228: PUSH
69229: LD_INT 1
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 3
69238: NEG
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69273: LD_ADDR_VAR 0 35
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: LD_INT 0
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 1
69301: PUSH
69302: LD_INT 0
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 1
69311: PUSH
69312: LD_INT 1
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: LD_INT 1
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: LD_INT 0
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 2
69354: PUSH
69355: LD_INT 1
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 2
69364: NEG
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: LIST
69381: LIST
69382: LIST
69383: LIST
69384: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69385: LD_ADDR_VAR 0 36
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: LD_INT 0
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 0
69402: PUSH
69403: LD_INT 1
69405: NEG
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 1
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: LD_INT 1
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: LD_INT 1
69458: NEG
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: NEG
69467: PUSH
69468: LD_INT 2
69470: NEG
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 1
69478: PUSH
69479: LD_INT 2
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69497: LD_ADDR_VAR 0 37
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: LD_INT 1
69517: NEG
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: LD_INT 0
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 1
69535: PUSH
69536: LD_INT 1
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 1
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: NEG
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: LD_INT 1
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 1
69589: NEG
69590: PUSH
69591: LD_INT 1
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69609: LD_ADDR_VAR 0 38
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 0
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 1
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 0
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 2
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 2
69700: NEG
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69721: LD_ADDR_VAR 0 39
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: LD_INT 0
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: LD_INT 1
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 0
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 1
69790: NEG
69791: PUSH
69792: LD_INT 1
69794: NEG
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 1
69802: NEG
69803: PUSH
69804: LD_INT 2
69806: NEG
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: LD_INT 2
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69833: LD_ADDR_VAR 0 40
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 0
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: LD_INT 1
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 1
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 1
69902: NEG
69903: PUSH
69904: LD_INT 1
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 1
69914: PUSH
69915: LD_INT 1
69917: NEG
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 1
69925: NEG
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69945: LD_ADDR_VAR 0 41
69949: PUSH
69950: LD_INT 0
69952: PUSH
69953: LD_INT 0
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 0
69993: PUSH
69994: LD_INT 1
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: LD_INT 0
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: NEG
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: NEG
70027: PUSH
70028: LD_INT 2
70030: NEG
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 1
70038: PUSH
70039: LD_INT 1
70041: NEG
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 2
70049: PUSH
70050: LD_INT 0
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 2
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 2
70069: PUSH
70070: LD_INT 2
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 1
70079: PUSH
70080: LD_INT 2
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 2
70100: NEG
70101: PUSH
70102: LD_INT 0
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 2
70111: NEG
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 2
70123: NEG
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 2
70135: NEG
70136: PUSH
70137: LD_INT 3
70139: NEG
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 2
70147: PUSH
70148: LD_INT 1
70150: NEG
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 3
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 3
70168: PUSH
70169: LD_INT 1
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 3
70178: PUSH
70179: LD_INT 2
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 3
70188: PUSH
70189: LD_INT 3
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 2
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 2
70208: NEG
70209: PUSH
70210: LD_INT 1
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 3
70219: NEG
70220: PUSH
70221: LD_INT 0
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 3
70230: NEG
70231: PUSH
70232: LD_INT 1
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 3
70242: NEG
70243: PUSH
70244: LD_INT 2
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 3
70254: NEG
70255: PUSH
70256: LD_INT 3
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70295: LD_ADDR_VAR 0 42
70299: PUSH
70300: LD_INT 0
70302: PUSH
70303: LD_INT 0
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 1
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 1
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 0
70343: PUSH
70344: LD_INT 1
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 1
70364: NEG
70365: PUSH
70366: LD_INT 1
70368: NEG
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: LD_INT 2
70380: NEG
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 0
70388: PUSH
70389: LD_INT 2
70391: NEG
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: LD_INT 1
70402: NEG
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: LD_INT 2
70410: PUSH
70411: LD_INT 1
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 2
70420: PUSH
70421: LD_INT 2
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: LD_INT 2
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 0
70440: PUSH
70441: LD_INT 2
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: NEG
70451: PUSH
70452: LD_INT 1
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 2
70461: NEG
70462: PUSH
70463: LD_INT 1
70465: NEG
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 2
70473: NEG
70474: PUSH
70475: LD_INT 2
70477: NEG
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 2
70485: NEG
70486: PUSH
70487: LD_INT 3
70489: NEG
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: LD_INT 3
70501: NEG
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: LD_INT 3
70512: NEG
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 1
70520: PUSH
70521: LD_INT 2
70523: NEG
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: LD_INT 3
70531: PUSH
70532: LD_INT 2
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 3
70541: PUSH
70542: LD_INT 3
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 2
70551: PUSH
70552: LD_INT 3
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: LD_INT 3
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 3
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: NEG
70582: PUSH
70583: LD_INT 2
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 3
70592: NEG
70593: PUSH
70594: LD_INT 2
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 3
70604: NEG
70605: PUSH
70606: LD_INT 3
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70645: LD_ADDR_VAR 0 43
70649: PUSH
70650: LD_INT 0
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 1
70665: NEG
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 1
70673: PUSH
70674: LD_INT 0
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: PUSH
70684: LD_INT 1
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 0
70693: PUSH
70694: LD_INT 1
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: LD_INT 1
70718: NEG
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: NEG
70727: PUSH
70728: LD_INT 2
70730: NEG
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: LD_INT 2
70741: NEG
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 2
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 2
70770: PUSH
70771: LD_INT 1
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 1
70780: PUSH
70781: LD_INT 2
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: LD_INT 2
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 1
70800: NEG
70801: PUSH
70802: LD_INT 1
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 2
70811: NEG
70812: PUSH
70813: LD_INT 0
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 2
70822: NEG
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 1
70834: NEG
70835: PUSH
70836: LD_INT 3
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 0
70846: PUSH
70847: LD_INT 3
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 3
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 3
70889: PUSH
70890: LD_INT 1
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: PUSH
70900: LD_INT 3
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: LD_INT 2
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: LD_INT 1
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 3
70941: NEG
70942: PUSH
70943: LD_INT 0
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 3
70952: NEG
70953: PUSH
70954: LD_INT 1
70956: NEG
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70993: LD_ADDR_VAR 0 44
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: LD_INT 0
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 0
71010: PUSH
71011: LD_INT 1
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 0
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 0
71041: PUSH
71042: LD_INT 1
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 1
71051: NEG
71052: PUSH
71053: LD_INT 0
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 1
71062: NEG
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: NEG
71075: PUSH
71076: LD_INT 2
71078: NEG
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: LD_INT 1
71086: PUSH
71087: LD_INT 1
71089: NEG
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 2
71097: PUSH
71098: LD_INT 0
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 2
71107: PUSH
71108: LD_INT 1
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: PUSH
71118: LD_INT 2
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 1
71127: PUSH
71128: LD_INT 2
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 1
71137: NEG
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 2
71148: NEG
71149: PUSH
71150: LD_INT 0
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 2
71159: NEG
71160: PUSH
71161: LD_INT 1
71163: NEG
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 2
71171: NEG
71172: PUSH
71173: LD_INT 2
71175: NEG
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 2
71183: NEG
71184: PUSH
71185: LD_INT 3
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: LD_INT 1
71198: NEG
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 3
71206: PUSH
71207: LD_INT 0
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 3
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 3
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 3
71236: PUSH
71237: LD_INT 3
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 2
71246: PUSH
71247: LD_INT 3
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 2
71256: NEG
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 3
71267: NEG
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 3
71278: NEG
71279: PUSH
71280: LD_INT 1
71282: NEG
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: NEG
71291: PUSH
71292: LD_INT 2
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 3
71302: NEG
71303: PUSH
71304: LD_INT 3
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71343: LD_ADDR_VAR 0 45
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: LD_INT 0
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: LD_INT 1
71363: NEG
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 1
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 1
71381: PUSH
71382: LD_INT 1
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: LD_INT 1
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 1
71412: NEG
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: NEG
71425: PUSH
71426: LD_INT 2
71428: NEG
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 0
71436: PUSH
71437: LD_INT 2
71439: NEG
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: PUSH
71448: LD_INT 1
71450: NEG
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 2
71458: PUSH
71459: LD_INT 1
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 2
71468: PUSH
71469: LD_INT 2
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 2
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 0
71488: PUSH
71489: LD_INT 2
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 1
71498: NEG
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: NEG
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 2
71521: NEG
71522: PUSH
71523: LD_INT 2
71525: NEG
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 2
71533: NEG
71534: PUSH
71535: LD_INT 3
71537: NEG
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 1
71545: NEG
71546: PUSH
71547: LD_INT 3
71549: NEG
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 3
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: LD_INT 2
71571: NEG
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 3
71579: PUSH
71580: LD_INT 2
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: PUSH
71590: LD_INT 3
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 2
71599: PUSH
71600: LD_INT 3
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 1
71609: PUSH
71610: LD_INT 3
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 0
71619: PUSH
71620: LD_INT 3
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: LD_INT 2
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 3
71640: NEG
71641: PUSH
71642: LD_INT 2
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 3
71652: NEG
71653: PUSH
71654: LD_INT 3
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71693: LD_ADDR_VAR 0 46
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: LD_INT 0
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 0
71710: PUSH
71711: LD_INT 1
71713: NEG
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 1
71721: PUSH
71722: LD_INT 0
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: PUSH
71729: LD_INT 1
71731: PUSH
71732: LD_INT 1
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: LD_INT 0
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: LD_INT 1
71766: NEG
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 1
71774: NEG
71775: PUSH
71776: LD_INT 2
71778: NEG
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: LD_INT 2
71789: NEG
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 2
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 2
71818: PUSH
71819: LD_INT 1
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: PUSH
71829: LD_INT 2
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 2
71859: NEG
71860: PUSH
71861: LD_INT 0
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 2
71870: NEG
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: NEG
71883: PUSH
71884: LD_INT 3
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 0
71894: PUSH
71895: LD_INT 3
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 3
71927: PUSH
71928: LD_INT 0
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 3
71937: PUSH
71938: LD_INT 1
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: LD_INT 3
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 0
71957: PUSH
71958: LD_INT 3
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 1
71967: NEG
71968: PUSH
71969: LD_INT 2
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: LD_INT 1
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 3
71989: NEG
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 3
72000: NEG
72001: PUSH
72002: LD_INT 1
72004: NEG
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: LIST
72014: LIST
72015: LIST
72016: LIST
72017: LIST
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72041: LD_ADDR_VAR 0 47
72045: PUSH
72046: LD_INT 0
72048: PUSH
72049: LD_INT 0
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 0
72058: PUSH
72059: LD_INT 1
72061: NEG
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 1
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 0
72089: PUSH
72090: LD_INT 1
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: NEG
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 1
72110: NEG
72111: PUSH
72112: LD_INT 1
72114: NEG
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: LD_INT 2
72126: NEG
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 0
72134: PUSH
72135: LD_INT 2
72137: NEG
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: LD_INT 1
72148: NEG
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 2
72156: NEG
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 2
72168: NEG
72169: PUSH
72170: LD_INT 2
72172: NEG
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72192: LD_ADDR_VAR 0 48
72196: PUSH
72197: LD_INT 0
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 0
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: LD_INT 0
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: LD_INT 1
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 1
72250: NEG
72251: PUSH
72252: LD_INT 0
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: LD_INT 1
72265: NEG
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: NEG
72274: PUSH
72275: LD_INT 2
72277: NEG
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 0
72285: PUSH
72286: LD_INT 2
72288: NEG
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: LD_INT 1
72299: NEG
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 2
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 2
72317: PUSH
72318: LD_INT 1
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72339: LD_ADDR_VAR 0 49
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 0
72356: PUSH
72357: LD_INT 1
72359: NEG
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 1
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: LD_INT 1
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 1
72408: NEG
72409: PUSH
72410: LD_INT 1
72412: NEG
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: LD_INT 1
72423: NEG
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 2
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 2
72441: PUSH
72442: LD_INT 1
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 2
72451: PUSH
72452: LD_INT 2
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: LD_INT 2
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72483: LD_ADDR_VAR 0 50
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: LD_INT 0
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: LD_INT 1
72503: NEG
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 1
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: LD_INT 1
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 1
72552: NEG
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 2
72564: PUSH
72565: LD_INT 1
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 2
72574: PUSH
72575: LD_INT 2
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 1
72584: PUSH
72585: LD_INT 2
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 0
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72627: LD_ADDR_VAR 0 51
72631: PUSH
72632: LD_INT 0
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 0
72644: PUSH
72645: LD_INT 1
72647: NEG
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 1
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 0
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 1
72685: NEG
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 1
72696: NEG
72697: PUSH
72698: LD_INT 1
72700: NEG
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 1
72708: PUSH
72709: LD_INT 2
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 1
72728: NEG
72729: PUSH
72730: LD_INT 1
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 2
72739: NEG
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 2
72750: NEG
72751: PUSH
72752: LD_INT 1
72754: NEG
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72774: LD_ADDR_VAR 0 52
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 0
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 1
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 1
72832: NEG
72833: PUSH
72834: LD_INT 0
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: NEG
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: PUSH
72853: LD_INT 1
72855: NEG
72856: PUSH
72857: LD_INT 2
72859: NEG
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: NEG
72868: PUSH
72869: LD_INT 1
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 2
72878: NEG
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 2
72889: NEG
72890: PUSH
72891: LD_INT 1
72893: NEG
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 2
72901: NEG
72902: PUSH
72903: LD_INT 2
72905: NEG
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72925: LD_ADDR_VAR 0 53
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: LD_INT 0
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: LD_INT 1
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: NEG
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 1
73006: NEG
73007: PUSH
73008: LD_INT 2
73010: NEG
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 2
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 2
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 2
73060: PUSH
73061: LD_INT 2
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: LD_INT 2
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 2
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 2
73101: NEG
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 2
73112: NEG
73113: PUSH
73114: LD_INT 1
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 2
73124: NEG
73125: PUSH
73126: LD_INT 2
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73155: LD_ADDR_VAR 0 54
73159: PUSH
73160: LD_INT 0
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: LD_INT 1
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 1
73213: NEG
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: NEG
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 1
73236: NEG
73237: PUSH
73238: LD_INT 2
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 2
73251: NEG
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 1
73262: NEG
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: LD_INT 2
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 1
73300: PUSH
73301: LD_INT 2
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 2
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 1
73320: NEG
73321: PUSH
73322: LD_INT 1
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 2
73331: NEG
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: NEG
73343: PUSH
73344: LD_INT 1
73346: NEG
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: NEG
73355: PUSH
73356: LD_INT 2
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73385: LD_ADDR_VAR 0 55
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 0
73402: PUSH
73403: LD_INT 1
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: LD_INT 0
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 1
73443: NEG
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 1
73466: NEG
73467: PUSH
73468: LD_INT 2
73470: NEG
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 2
73481: NEG
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: LD_INT 1
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 1
73530: PUSH
73531: LD_INT 2
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 2
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 2
73561: NEG
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 2
73572: NEG
73573: PUSH
73574: LD_INT 1
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 2
73584: NEG
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73615: LD_ADDR_VAR 0 56
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 0
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 0
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 0
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 1
73673: NEG
73674: PUSH
73675: LD_INT 0
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: LD_INT 1
73696: NEG
73697: PUSH
73698: LD_INT 2
73700: NEG
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: LD_INT 2
73711: NEG
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 2
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 2
73750: PUSH
73751: LD_INT 2
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: LD_INT 2
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 0
73770: PUSH
73771: LD_INT 2
73773: PUSH
73774: EMPTY
73775: LIST
73776: LIST
73777: PUSH
73778: LD_INT 1
73780: NEG
73781: PUSH
73782: LD_INT 1
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 2
73791: NEG
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 2
73802: NEG
73803: PUSH
73804: LD_INT 1
73806: NEG
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 2
73818: NEG
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73845: LD_ADDR_VAR 0 57
73849: PUSH
73850: LD_INT 0
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: LD_INT 1
73865: NEG
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 1
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 1
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 1
73903: NEG
73904: PUSH
73905: LD_INT 0
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 1
73918: NEG
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 1
73926: NEG
73927: PUSH
73928: LD_INT 2
73930: NEG
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: LD_INT 2
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 2
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: LD_INT 2
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 1
73990: PUSH
73991: LD_INT 2
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: LD_INT 2
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 1
74010: NEG
74011: PUSH
74012: LD_INT 1
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 2
74021: NEG
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 2
74032: NEG
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 2
74044: NEG
74045: PUSH
74046: LD_INT 2
74048: NEG
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74075: LD_ADDR_VAR 0 58
74079: PUSH
74080: LD_INT 0
74082: PUSH
74083: LD_INT 0
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: LD_INT 1
74095: NEG
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: LD_INT 1
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: LD_INT 0
74123: PUSH
74124: LD_INT 1
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 1
74133: NEG
74134: PUSH
74135: LD_INT 0
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 1
74156: NEG
74157: PUSH
74158: LD_INT 2
74160: NEG
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: LD_INT 2
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 1
74179: PUSH
74180: LD_INT 1
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 2
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 2
74210: PUSH
74211: LD_INT 2
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 1
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: LD_INT 2
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74305: LD_ADDR_VAR 0 59
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: LD_INT 0
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 1
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 1
74343: PUSH
74344: LD_INT 1
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: LD_INT 1
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 1
74363: NEG
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74393: LD_ADDR_VAR 0 60
74397: PUSH
74398: LD_INT 0
74400: PUSH
74401: LD_INT 0
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: LD_INT 1
74413: NEG
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 1
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 1
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: LD_INT 1
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 1
74451: NEG
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 1
74462: NEG
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: LIST
74476: LIST
74477: LIST
74478: LIST
74479: LIST
74480: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74481: LD_ADDR_VAR 0 61
74485: PUSH
74486: LD_INT 0
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 0
74498: PUSH
74499: LD_INT 1
74501: NEG
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 1
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 1
74519: PUSH
74520: LD_INT 1
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 0
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 1
74539: NEG
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 1
74550: NEG
74551: PUSH
74552: LD_INT 1
74554: NEG
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74569: LD_ADDR_VAR 0 62
74573: PUSH
74574: LD_INT 0
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: LD_INT 1
74589: NEG
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 1
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 0
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 1
74627: NEG
74628: PUSH
74629: LD_INT 0
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 1
74638: NEG
74639: PUSH
74640: LD_INT 1
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74657: LD_ADDR_VAR 0 63
74661: PUSH
74662: LD_INT 0
74664: PUSH
74665: LD_INT 0
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 0
74674: PUSH
74675: LD_INT 1
74677: NEG
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: LD_INT 1
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 1
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: LD_INT 1
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: LD_INT 0
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 1
74726: NEG
74727: PUSH
74728: LD_INT 1
74730: NEG
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74745: LD_ADDR_VAR 0 64
74749: PUSH
74750: LD_INT 0
74752: PUSH
74753: LD_INT 0
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 1
74773: PUSH
74774: LD_INT 0
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 1
74783: PUSH
74784: LD_INT 1
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: LD_INT 1
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: LD_INT 0
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 1
74814: NEG
74815: PUSH
74816: LD_INT 1
74818: NEG
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: LIST
74828: LIST
74829: LIST
74830: LIST
74831: LIST
74832: ST_TO_ADDR
// end ; 1 :
74833: GO 80730
74835: LD_INT 1
74837: DOUBLE
74838: EQUAL
74839: IFTRUE 74843
74841: GO 77466
74843: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74844: LD_ADDR_VAR 0 11
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 3
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 0
74863: PUSH
74864: LD_INT 3
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: PUSH
74875: LD_INT 2
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: LIST
74887: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74888: LD_ADDR_VAR 0 12
74892: PUSH
74893: LD_INT 2
74895: PUSH
74896: LD_INT 1
74898: NEG
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 3
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 3
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: LIST
74928: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74929: LD_ADDR_VAR 0 13
74933: PUSH
74934: LD_INT 3
74936: PUSH
74937: LD_INT 2
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 3
74946: PUSH
74947: LD_INT 3
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 2
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: LIST
74968: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74969: LD_ADDR_VAR 0 14
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: LD_INT 3
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 0
74986: PUSH
74987: LD_INT 3
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: LD_INT 2
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75010: LD_ADDR_VAR 0 15
75014: PUSH
75015: LD_INT 2
75017: NEG
75018: PUSH
75019: LD_INT 1
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 3
75028: NEG
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 3
75039: NEG
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: LIST
75053: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75054: LD_ADDR_VAR 0 16
75058: PUSH
75059: LD_INT 2
75061: NEG
75062: PUSH
75063: LD_INT 3
75065: NEG
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 3
75073: NEG
75074: PUSH
75075: LD_INT 2
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 3
75085: NEG
75086: PUSH
75087: LD_INT 3
75089: NEG
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: LIST
75099: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75100: LD_ADDR_VAR 0 17
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: LD_INT 3
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: LD_INT 3
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 1
75130: PUSH
75131: LD_INT 2
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75144: LD_ADDR_VAR 0 18
75148: PUSH
75149: LD_INT 2
75151: PUSH
75152: LD_INT 1
75154: NEG
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 3
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 3
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: LIST
75184: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75185: LD_ADDR_VAR 0 19
75189: PUSH
75190: LD_INT 3
75192: PUSH
75193: LD_INT 2
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 3
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 2
75212: PUSH
75213: LD_INT 3
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: LIST
75224: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75225: LD_ADDR_VAR 0 20
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: LD_INT 3
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: LD_INT 3
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: NEG
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: LIST
75265: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75266: LD_ADDR_VAR 0 21
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: LD_INT 1
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 3
75284: NEG
75285: PUSH
75286: LD_INT 0
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 3
75295: NEG
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: LIST
75309: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75310: LD_ADDR_VAR 0 22
75314: PUSH
75315: LD_INT 2
75317: NEG
75318: PUSH
75319: LD_INT 3
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 3
75329: NEG
75330: PUSH
75331: LD_INT 2
75333: NEG
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 3
75341: NEG
75342: PUSH
75343: LD_INT 3
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: LIST
75355: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75356: LD_ADDR_VAR 0 23
75360: PUSH
75361: LD_INT 0
75363: PUSH
75364: LD_INT 3
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 1
75374: NEG
75375: PUSH
75376: LD_INT 4
75378: NEG
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 1
75386: PUSH
75387: LD_INT 3
75389: NEG
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: LIST
75399: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75400: LD_ADDR_VAR 0 24
75404: PUSH
75405: LD_INT 3
75407: PUSH
75408: LD_INT 0
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 3
75417: PUSH
75418: LD_INT 1
75420: NEG
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 4
75428: PUSH
75429: LD_INT 1
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: LIST
75440: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75441: LD_ADDR_VAR 0 25
75445: PUSH
75446: LD_INT 3
75448: PUSH
75449: LD_INT 3
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 4
75458: PUSH
75459: LD_INT 3
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 3
75468: PUSH
75469: LD_INT 4
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: LIST
75480: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75481: LD_ADDR_VAR 0 26
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: LD_INT 3
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: LD_INT 4
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 1
75508: NEG
75509: PUSH
75510: LD_INT 3
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: LIST
75521: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75522: LD_ADDR_VAR 0 27
75526: PUSH
75527: LD_INT 3
75529: NEG
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: NEG
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 4
75551: NEG
75552: PUSH
75553: LD_INT 1
75555: NEG
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: LIST
75565: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75566: LD_ADDR_VAR 0 28
75570: PUSH
75571: LD_INT 3
75573: NEG
75574: PUSH
75575: LD_INT 3
75577: NEG
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 3
75585: NEG
75586: PUSH
75587: LD_INT 4
75589: NEG
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 4
75597: NEG
75598: PUSH
75599: LD_INT 3
75601: NEG
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75612: LD_ADDR_VAR 0 29
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: LD_INT 3
75623: NEG
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 0
75631: PUSH
75632: LD_INT 3
75634: NEG
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 1
75642: PUSH
75643: LD_INT 2
75645: NEG
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 1
75653: NEG
75654: PUSH
75655: LD_INT 4
75657: NEG
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: LD_INT 4
75668: NEG
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 1
75676: PUSH
75677: LD_INT 3
75679: NEG
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: LD_INT 5
75691: NEG
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 0
75699: PUSH
75700: LD_INT 5
75702: NEG
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 1
75710: PUSH
75711: LD_INT 4
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: LD_INT 6
75725: NEG
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: LD_INT 6
75736: NEG
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 1
75744: PUSH
75745: LD_INT 5
75747: NEG
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75767: LD_ADDR_VAR 0 30
75771: PUSH
75772: LD_INT 2
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 3
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 3
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 3
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 4
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 4
75826: PUSH
75827: LD_INT 1
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 4
75836: PUSH
75837: LD_INT 1
75839: NEG
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 5
75847: PUSH
75848: LD_INT 0
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 5
75857: PUSH
75858: LD_INT 1
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 5
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 6
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 6
75888: PUSH
75889: LD_INT 1
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75910: LD_ADDR_VAR 0 31
75914: PUSH
75915: LD_INT 3
75917: PUSH
75918: LD_INT 2
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 3
75927: PUSH
75928: LD_INT 3
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 2
75937: PUSH
75938: LD_INT 3
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 4
75947: PUSH
75948: LD_INT 3
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 4
75957: PUSH
75958: LD_INT 4
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: PUSH
75968: LD_INT 4
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 5
75977: PUSH
75978: LD_INT 4
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 5
75987: PUSH
75988: LD_INT 5
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 4
75997: PUSH
75998: LD_INT 5
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 6
76007: PUSH
76008: LD_INT 5
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 6
76017: PUSH
76018: LD_INT 6
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 5
76027: PUSH
76028: LD_INT 6
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: LIST
76048: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76049: LD_ADDR_VAR 0 32
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 3
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 0
76066: PUSH
76067: LD_INT 3
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: LD_INT 2
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 1
76087: PUSH
76088: LD_INT 4
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 0
76097: PUSH
76098: LD_INT 4
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 1
76107: NEG
76108: PUSH
76109: LD_INT 3
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: LD_INT 5
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 0
76128: PUSH
76129: LD_INT 5
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: NEG
76139: PUSH
76140: LD_INT 4
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 1
76149: PUSH
76150: LD_INT 6
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: LD_INT 6
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: LD_INT 5
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76192: LD_ADDR_VAR 0 33
76196: PUSH
76197: LD_INT 2
76199: NEG
76200: PUSH
76201: LD_INT 1
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 3
76210: NEG
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 3
76221: NEG
76222: PUSH
76223: LD_INT 1
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 3
76233: NEG
76234: PUSH
76235: LD_INT 1
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 4
76244: NEG
76245: PUSH
76246: LD_INT 0
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 4
76255: NEG
76256: PUSH
76257: LD_INT 1
76259: NEG
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 4
76267: NEG
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 5
76278: NEG
76279: PUSH
76280: LD_INT 0
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 5
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: NEG
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 5
76301: NEG
76302: PUSH
76303: LD_INT 1
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 6
76312: NEG
76313: PUSH
76314: LD_INT 0
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 6
76323: NEG
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: LIST
76339: LIST
76340: LIST
76341: LIST
76342: LIST
76343: LIST
76344: LIST
76345: LIST
76346: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76347: LD_ADDR_VAR 0 34
76351: PUSH
76352: LD_INT 2
76354: NEG
76355: PUSH
76356: LD_INT 3
76358: NEG
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 3
76366: NEG
76367: PUSH
76368: LD_INT 2
76370: NEG
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 3
76378: NEG
76379: PUSH
76380: LD_INT 3
76382: NEG
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 3
76390: NEG
76391: PUSH
76392: LD_INT 4
76394: NEG
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 4
76402: NEG
76403: PUSH
76404: LD_INT 3
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 4
76414: NEG
76415: PUSH
76416: LD_INT 4
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 4
76426: NEG
76427: PUSH
76428: LD_INT 5
76430: NEG
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 5
76438: NEG
76439: PUSH
76440: LD_INT 4
76442: NEG
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 5
76450: NEG
76451: PUSH
76452: LD_INT 5
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 5
76462: NEG
76463: PUSH
76464: LD_INT 6
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 6
76474: NEG
76475: PUSH
76476: LD_INT 5
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 6
76486: NEG
76487: PUSH
76488: LD_INT 6
76490: NEG
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: LIST
76504: LIST
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76510: LD_ADDR_VAR 0 41
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: LD_INT 2
76520: NEG
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 1
76528: NEG
76529: PUSH
76530: LD_INT 3
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: PUSH
76541: LD_INT 2
76543: NEG
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: LIST
76553: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76554: LD_ADDR_VAR 0 42
76558: PUSH
76559: LD_INT 2
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 2
76571: PUSH
76572: LD_INT 1
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 3
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76595: LD_ADDR_VAR 0 43
76599: PUSH
76600: LD_INT 2
76602: PUSH
76603: LD_INT 2
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 3
76612: PUSH
76613: LD_INT 2
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 3
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: LIST
76634: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76635: LD_ADDR_VAR 0 44
76639: PUSH
76640: LD_INT 0
76642: PUSH
76643: LD_INT 2
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 1
76652: PUSH
76653: LD_INT 3
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 1
76662: NEG
76663: PUSH
76664: LD_INT 2
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76676: LD_ADDR_VAR 0 45
76680: PUSH
76681: LD_INT 2
76683: NEG
76684: PUSH
76685: LD_INT 0
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 2
76694: NEG
76695: PUSH
76696: LD_INT 1
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 3
76705: NEG
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76720: LD_ADDR_VAR 0 46
76724: PUSH
76725: LD_INT 2
76727: NEG
76728: PUSH
76729: LD_INT 2
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 2
76739: NEG
76740: PUSH
76741: LD_INT 3
76743: NEG
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 3
76751: NEG
76752: PUSH
76753: LD_INT 2
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: LIST
76765: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76766: LD_ADDR_VAR 0 47
76770: PUSH
76771: LD_INT 2
76773: NEG
76774: PUSH
76775: LD_INT 3
76777: NEG
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 1
76785: NEG
76786: PUSH
76787: LD_INT 3
76789: NEG
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76799: LD_ADDR_VAR 0 48
76803: PUSH
76804: LD_INT 1
76806: PUSH
76807: LD_INT 2
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 2
76817: PUSH
76818: LD_INT 1
76820: NEG
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76830: LD_ADDR_VAR 0 49
76834: PUSH
76835: LD_INT 3
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 3
76847: PUSH
76848: LD_INT 2
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76859: LD_ADDR_VAR 0 50
76863: PUSH
76864: LD_INT 2
76866: PUSH
76867: LD_INT 3
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: LD_INT 3
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76888: LD_ADDR_VAR 0 51
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 2
76906: NEG
76907: PUSH
76908: LD_INT 1
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76919: LD_ADDR_VAR 0 52
76923: PUSH
76924: LD_INT 3
76926: NEG
76927: PUSH
76928: LD_INT 1
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 3
76938: NEG
76939: PUSH
76940: LD_INT 2
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76952: LD_ADDR_VAR 0 53
76956: PUSH
76957: LD_INT 1
76959: NEG
76960: PUSH
76961: LD_INT 3
76963: NEG
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: LD_INT 3
76974: NEG
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: LD_INT 2
76985: NEG
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: LIST
76995: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76996: LD_ADDR_VAR 0 54
77000: PUSH
77001: LD_INT 2
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 3
77014: PUSH
77015: LD_INT 0
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 3
77024: PUSH
77025: LD_INT 1
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: LIST
77036: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77037: LD_ADDR_VAR 0 55
77041: PUSH
77042: LD_INT 3
77044: PUSH
77045: LD_INT 2
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PUSH
77052: LD_INT 3
77054: PUSH
77055: LD_INT 3
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 2
77064: PUSH
77065: LD_INT 3
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: LIST
77076: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77077: LD_ADDR_VAR 0 56
77081: PUSH
77082: LD_INT 1
77084: PUSH
77085: LD_INT 3
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: LD_INT 3
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: LD_INT 2
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: LIST
77117: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77118: LD_ADDR_VAR 0 57
77122: PUSH
77123: LD_INT 2
77125: NEG
77126: PUSH
77127: LD_INT 1
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 3
77136: NEG
77137: PUSH
77138: LD_INT 0
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 3
77147: NEG
77148: PUSH
77149: LD_INT 1
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77162: LD_ADDR_VAR 0 58
77166: PUSH
77167: LD_INT 2
77169: NEG
77170: PUSH
77171: LD_INT 3
77173: NEG
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 3
77181: NEG
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 3
77193: NEG
77194: PUSH
77195: LD_INT 3
77197: NEG
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: LIST
77207: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77208: LD_ADDR_VAR 0 59
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: LD_INT 2
77219: NEG
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 0
77227: PUSH
77228: LD_INT 2
77230: NEG
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 1
77238: PUSH
77239: LD_INT 1
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: LIST
77251: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77252: LD_ADDR_VAR 0 60
77256: PUSH
77257: LD_INT 1
77259: PUSH
77260: LD_INT 1
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 2
77270: PUSH
77271: LD_INT 0
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 2
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: LIST
77292: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77293: LD_ADDR_VAR 0 61
77297: PUSH
77298: LD_INT 2
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 2
77310: PUSH
77311: LD_INT 2
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 1
77320: PUSH
77321: LD_INT 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: LIST
77332: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77333: LD_ADDR_VAR 0 62
77337: PUSH
77338: LD_INT 1
77340: PUSH
77341: LD_INT 2
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 0
77350: PUSH
77351: LD_INT 2
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 1
77360: NEG
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: LIST
77373: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77374: LD_ADDR_VAR 0 63
77378: PUSH
77379: LD_INT 1
77381: NEG
77382: PUSH
77383: LD_INT 1
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: NEG
77393: PUSH
77394: LD_INT 0
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 2
77403: NEG
77404: PUSH
77405: LD_INT 1
77407: NEG
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: LIST
77417: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77418: LD_ADDR_VAR 0 64
77422: PUSH
77423: LD_INT 1
77425: NEG
77426: PUSH
77427: LD_INT 2
77429: NEG
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 2
77437: NEG
77438: PUSH
77439: LD_INT 1
77441: NEG
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 2
77449: NEG
77450: PUSH
77451: LD_INT 2
77453: NEG
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: LIST
77463: ST_TO_ADDR
// end ; 2 :
77464: GO 80730
77466: LD_INT 2
77468: DOUBLE
77469: EQUAL
77470: IFTRUE 77474
77472: GO 80729
77474: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77475: LD_ADDR_VAR 0 29
77479: PUSH
77480: LD_INT 4
77482: PUSH
77483: LD_INT 0
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 4
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 5
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 5
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 4
77523: PUSH
77524: LD_INT 1
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 3
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 3
77543: PUSH
77544: LD_INT 1
77546: NEG
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: LD_INT 2
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 5
77565: PUSH
77566: LD_INT 2
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 3
77575: PUSH
77576: LD_INT 3
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 3
77585: PUSH
77586: LD_INT 2
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 4
77595: PUSH
77596: LD_INT 3
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 4
77605: PUSH
77606: LD_INT 4
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: LD_INT 4
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 2
77625: PUSH
77626: LD_INT 3
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 2
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 4
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 2
77655: PUSH
77656: LD_INT 4
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 0
77665: PUSH
77666: LD_INT 4
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 0
77675: PUSH
77676: LD_INT 3
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 1
77685: PUSH
77686: LD_INT 4
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: PUSH
77696: LD_INT 5
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 0
77705: PUSH
77706: LD_INT 5
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 1
77715: NEG
77716: PUSH
77717: LD_INT 4
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 1
77726: NEG
77727: PUSH
77728: LD_INT 3
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: LD_INT 2
77737: PUSH
77738: LD_INT 5
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 2
77747: NEG
77748: PUSH
77749: LD_INT 3
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 3
77758: NEG
77759: PUSH
77760: LD_INT 0
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 3
77769: NEG
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 2
77781: NEG
77782: PUSH
77783: LD_INT 0
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 2
77792: NEG
77793: PUSH
77794: LD_INT 1
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 3
77803: NEG
77804: PUSH
77805: LD_INT 1
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 4
77814: NEG
77815: PUSH
77816: LD_INT 0
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 4
77825: NEG
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 4
77837: NEG
77838: PUSH
77839: LD_INT 2
77841: NEG
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 2
77849: NEG
77850: PUSH
77851: LD_INT 2
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 4
77860: NEG
77861: PUSH
77862: LD_INT 4
77864: NEG
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 4
77872: NEG
77873: PUSH
77874: LD_INT 5
77876: NEG
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 3
77884: NEG
77885: PUSH
77886: LD_INT 4
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 3
77896: NEG
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 4
77908: NEG
77909: PUSH
77910: LD_INT 3
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 5
77920: NEG
77921: PUSH
77922: LD_INT 4
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 5
77932: NEG
77933: PUSH
77934: LD_INT 5
77936: NEG
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 3
77944: NEG
77945: PUSH
77946: LD_INT 5
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 5
77956: NEG
77957: PUSH
77958: LD_INT 3
77960: NEG
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78013: LD_ADDR_VAR 0 30
78017: PUSH
78018: LD_INT 4
78020: PUSH
78021: LD_INT 4
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 4
78030: PUSH
78031: LD_INT 3
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 5
78040: PUSH
78041: LD_INT 4
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 5
78050: PUSH
78051: LD_INT 5
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 4
78060: PUSH
78061: LD_INT 5
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 3
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 5
78090: PUSH
78091: LD_INT 3
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 3
78100: PUSH
78101: LD_INT 5
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: LD_INT 3
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 0
78120: PUSH
78121: LD_INT 2
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 1
78130: PUSH
78131: LD_INT 3
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: PUSH
78141: LD_INT 4
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: LD_INT 4
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: LD_INT 3
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 1
78171: NEG
78172: PUSH
78173: LD_INT 2
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 2
78182: PUSH
78183: LD_INT 4
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 2
78192: NEG
78193: PUSH
78194: LD_INT 2
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 4
78203: NEG
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 4
78214: NEG
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 3
78226: NEG
78227: PUSH
78228: LD_INT 0
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 3
78237: NEG
78238: PUSH
78239: LD_INT 1
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 4
78248: NEG
78249: PUSH
78250: LD_INT 1
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 5
78259: NEG
78260: PUSH
78261: LD_INT 0
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 5
78270: NEG
78271: PUSH
78272: LD_INT 1
78274: NEG
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 5
78282: NEG
78283: PUSH
78284: LD_INT 2
78286: NEG
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: LD_INT 2
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 3
78305: NEG
78306: PUSH
78307: LD_INT 3
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 3
78317: NEG
78318: PUSH
78319: LD_INT 4
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 2
78329: NEG
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 2
78341: NEG
78342: PUSH
78343: LD_INT 2
78345: NEG
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: LD_INT 2
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 4
78365: NEG
78366: PUSH
78367: LD_INT 3
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 4
78377: NEG
78378: PUSH
78379: LD_INT 4
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 2
78389: NEG
78390: PUSH
78391: LD_INT 4
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 4
78401: NEG
78402: PUSH
78403: LD_INT 2
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: LD_INT 4
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: LD_INT 5
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: PUSH
78436: LD_INT 4
78438: NEG
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 1
78446: PUSH
78447: LD_INT 3
78449: NEG
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: LD_INT 3
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 4
78472: NEG
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 1
78480: NEG
78481: PUSH
78482: LD_INT 5
78484: NEG
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 2
78503: NEG
78504: PUSH
78505: LD_INT 5
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78560: LD_ADDR_VAR 0 31
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: LD_INT 4
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: LD_INT 3
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: LD_INT 4
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: LD_INT 5
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 5
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 1
78617: NEG
78618: PUSH
78619: LD_INT 4
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 1
78628: NEG
78629: PUSH
78630: LD_INT 3
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 2
78639: PUSH
78640: LD_INT 5
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 2
78649: NEG
78650: PUSH
78651: LD_INT 3
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 3
78660: NEG
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 3
78671: NEG
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 2
78683: NEG
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 3
78705: NEG
78706: PUSH
78707: LD_INT 1
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 4
78716: NEG
78717: PUSH
78718: LD_INT 0
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 4
78727: NEG
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 4
78739: NEG
78740: PUSH
78741: LD_INT 2
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 2
78751: NEG
78752: PUSH
78753: LD_INT 2
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 4
78762: NEG
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 4
78774: NEG
78775: PUSH
78776: LD_INT 5
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 3
78786: NEG
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 3
78798: NEG
78799: PUSH
78800: LD_INT 3
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 3
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 5
78822: NEG
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 5
78834: NEG
78835: PUSH
78836: LD_INT 5
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 3
78846: NEG
78847: PUSH
78848: LD_INT 5
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 5
78858: NEG
78859: PUSH
78860: LD_INT 3
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: LD_INT 3
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 0
78881: PUSH
78882: LD_INT 4
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 1
78892: PUSH
78893: LD_INT 3
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 1
78903: PUSH
78904: LD_INT 2
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 0
78914: PUSH
78915: LD_INT 2
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 1
78925: NEG
78926: PUSH
78927: LD_INT 3
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 1
78937: NEG
78938: PUSH
78939: LD_INT 4
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 2
78949: PUSH
78950: LD_INT 2
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 2
78960: NEG
78961: PUSH
78962: LD_INT 4
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 4
78972: PUSH
78973: LD_INT 0
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 4
78982: PUSH
78983: LD_INT 1
78985: NEG
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 0
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 5
79003: PUSH
79004: LD_INT 1
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 4
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 3
79023: PUSH
79024: LD_INT 0
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: LD_INT 1
79036: NEG
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 3
79044: PUSH
79045: LD_INT 2
79047: NEG
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 5
79055: PUSH
79056: LD_INT 2
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79110: LD_ADDR_VAR 0 32
79114: PUSH
79115: LD_INT 4
79117: NEG
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 4
79128: NEG
79129: PUSH
79130: LD_INT 1
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 1
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 4
79162: NEG
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 5
79173: NEG
79174: PUSH
79175: LD_INT 0
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 5
79184: NEG
79185: PUSH
79186: LD_INT 1
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 5
79196: NEG
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 3
79208: NEG
79209: PUSH
79210: LD_INT 2
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 3
79219: NEG
79220: PUSH
79221: LD_INT 3
79223: NEG
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: NEG
79232: PUSH
79233: LD_INT 4
79235: NEG
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 2
79243: NEG
79244: PUSH
79245: LD_INT 3
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 2
79255: NEG
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 3
79267: NEG
79268: PUSH
79269: LD_INT 2
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 4
79279: NEG
79280: PUSH
79281: LD_INT 3
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 4
79291: NEG
79292: PUSH
79293: LD_INT 4
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 2
79303: NEG
79304: PUSH
79305: LD_INT 4
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 4
79315: NEG
79316: PUSH
79317: LD_INT 2
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 4
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 0
79338: PUSH
79339: LD_INT 5
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: LD_INT 4
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 1
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: LD_INT 3
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 1
79382: NEG
79383: PUSH
79384: LD_INT 4
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: LD_INT 5
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 2
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: NEG
79418: PUSH
79419: LD_INT 5
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 3
79429: PUSH
79430: LD_INT 0
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 3
79439: PUSH
79440: LD_INT 1
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 4
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 4
79460: PUSH
79461: LD_INT 1
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 3
79470: PUSH
79471: LD_INT 1
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 2
79480: PUSH
79481: LD_INT 0
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 2
79490: PUSH
79491: LD_INT 1
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 2
79501: PUSH
79502: LD_INT 2
79504: NEG
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 4
79512: PUSH
79513: LD_INT 2
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 4
79522: PUSH
79523: LD_INT 4
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 4
79532: PUSH
79533: LD_INT 3
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 5
79542: PUSH
79543: LD_INT 4
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 5
79552: PUSH
79553: LD_INT 5
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 4
79562: PUSH
79563: LD_INT 5
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 3
79572: PUSH
79573: LD_INT 4
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 3
79582: PUSH
79583: LD_INT 3
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 5
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 3
79602: PUSH
79603: LD_INT 5
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79657: LD_ADDR_VAR 0 33
79661: PUSH
79662: LD_INT 4
79664: NEG
79665: PUSH
79666: LD_INT 4
79668: NEG
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 4
79676: NEG
79677: PUSH
79678: LD_INT 5
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 3
79688: NEG
79689: PUSH
79690: LD_INT 4
79692: NEG
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: LD_INT 3
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 4
79712: NEG
79713: PUSH
79714: LD_INT 3
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 5
79724: NEG
79725: PUSH
79726: LD_INT 4
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 5
79736: NEG
79737: PUSH
79738: LD_INT 5
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: LD_INT 5
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 5
79760: NEG
79761: PUSH
79762: LD_INT 3
79764: NEG
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: LD_INT 3
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: LD_INT 4
79786: NEG
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: LD_INT 3
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 1
79805: PUSH
79806: LD_INT 2
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: LD_INT 2
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 1
79827: NEG
79828: PUSH
79829: LD_INT 3
79831: NEG
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: LD_INT 4
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 2
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: LD_INT 4
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 4
79874: PUSH
79875: LD_INT 0
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 4
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 5
79895: PUSH
79896: LD_INT 0
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 5
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 4
79915: PUSH
79916: LD_INT 1
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 3
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 3
79935: PUSH
79936: LD_INT 1
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: LD_INT 2
79949: NEG
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 5
79957: PUSH
79958: LD_INT 2
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 3
79967: PUSH
79968: LD_INT 3
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: LD_INT 2
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 4
79987: PUSH
79988: LD_INT 3
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 4
79997: PUSH
79998: LD_INT 4
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 3
80007: PUSH
80008: LD_INT 4
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 2
80017: PUSH
80018: LD_INT 3
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 4
80037: PUSH
80038: LD_INT 2
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: LD_INT 4
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: LD_INT 4
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: LD_INT 3
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: LD_INT 4
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 1
80087: PUSH
80088: LD_INT 5
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: LD_INT 5
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 1
80107: NEG
80108: PUSH
80109: LD_INT 4
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 1
80118: NEG
80119: PUSH
80120: LD_INT 3
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 2
80129: PUSH
80130: LD_INT 5
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 2
80139: NEG
80140: PUSH
80141: LD_INT 3
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80195: LD_ADDR_VAR 0 34
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 4
80205: NEG
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 0
80213: PUSH
80214: LD_INT 5
80216: NEG
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: LD_INT 4
80227: NEG
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: PUSH
80236: LD_INT 3
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 0
80246: PUSH
80247: LD_INT 3
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: LD_INT 4
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: LD_INT 5
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 5
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 3
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 3
80314: PUSH
80315: LD_INT 1
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 4
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 4
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 3
80345: PUSH
80346: LD_INT 1
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 2
80355: PUSH
80356: LD_INT 0
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 2
80365: PUSH
80366: LD_INT 1
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 2
80376: PUSH
80377: LD_INT 2
80379: NEG
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 4
80387: PUSH
80388: LD_INT 2
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 4
80397: PUSH
80398: LD_INT 4
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: LD_INT 3
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 5
80417: PUSH
80418: LD_INT 4
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 5
80427: PUSH
80428: LD_INT 5
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 4
80437: PUSH
80438: LD_INT 5
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 3
80447: PUSH
80448: LD_INT 4
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 3
80457: PUSH
80458: LD_INT 3
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 5
80467: PUSH
80468: LD_INT 3
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 3
80477: PUSH
80478: LD_INT 5
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 0
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: LD_INT 3
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: PUSH
80518: LD_INT 4
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 0
80527: PUSH
80528: LD_INT 4
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: LD_INT 3
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 2
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 2
80559: PUSH
80560: LD_INT 4
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 2
80569: NEG
80570: PUSH
80571: LD_INT 2
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 4
80580: NEG
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 4
80591: NEG
80592: PUSH
80593: LD_INT 1
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 3
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 3
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 4
80625: NEG
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 5
80636: NEG
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 5
80647: NEG
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 5
80659: NEG
80660: PUSH
80661: LD_INT 2
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 3
80671: NEG
80672: PUSH
80673: LD_INT 2
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: ST_TO_ADDR
// end ; end ;
80727: GO 80730
80729: POP
// case btype of b_depot , b_warehouse :
80730: LD_VAR 0 1
80734: PUSH
80735: LD_INT 0
80737: DOUBLE
80738: EQUAL
80739: IFTRUE 80749
80741: LD_INT 1
80743: DOUBLE
80744: EQUAL
80745: IFTRUE 80749
80747: GO 80950
80749: POP
// case nation of nation_american :
80750: LD_VAR 0 5
80754: PUSH
80755: LD_INT 1
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80763
80761: GO 80819
80763: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80764: LD_ADDR_VAR 0 9
80768: PUSH
80769: LD_VAR 0 11
80773: PUSH
80774: LD_VAR 0 12
80778: PUSH
80779: LD_VAR 0 13
80783: PUSH
80784: LD_VAR 0 14
80788: PUSH
80789: LD_VAR 0 15
80793: PUSH
80794: LD_VAR 0 16
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: PUSH
80807: LD_VAR 0 4
80811: PUSH
80812: LD_INT 1
80814: PLUS
80815: ARRAY
80816: ST_TO_ADDR
80817: GO 80948
80819: LD_INT 2
80821: DOUBLE
80822: EQUAL
80823: IFTRUE 80827
80825: GO 80883
80827: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80828: LD_ADDR_VAR 0 9
80832: PUSH
80833: LD_VAR 0 17
80837: PUSH
80838: LD_VAR 0 18
80842: PUSH
80843: LD_VAR 0 19
80847: PUSH
80848: LD_VAR 0 20
80852: PUSH
80853: LD_VAR 0 21
80857: PUSH
80858: LD_VAR 0 22
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: PUSH
80871: LD_VAR 0 4
80875: PUSH
80876: LD_INT 1
80878: PLUS
80879: ARRAY
80880: ST_TO_ADDR
80881: GO 80948
80883: LD_INT 3
80885: DOUBLE
80886: EQUAL
80887: IFTRUE 80891
80889: GO 80947
80891: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80892: LD_ADDR_VAR 0 9
80896: PUSH
80897: LD_VAR 0 23
80901: PUSH
80902: LD_VAR 0 24
80906: PUSH
80907: LD_VAR 0 25
80911: PUSH
80912: LD_VAR 0 26
80916: PUSH
80917: LD_VAR 0 27
80921: PUSH
80922: LD_VAR 0 28
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: PUSH
80935: LD_VAR 0 4
80939: PUSH
80940: LD_INT 1
80942: PLUS
80943: ARRAY
80944: ST_TO_ADDR
80945: GO 80948
80947: POP
80948: GO 81503
80950: LD_INT 2
80952: DOUBLE
80953: EQUAL
80954: IFTRUE 80964
80956: LD_INT 3
80958: DOUBLE
80959: EQUAL
80960: IFTRUE 80964
80962: GO 81020
80964: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80965: LD_ADDR_VAR 0 9
80969: PUSH
80970: LD_VAR 0 29
80974: PUSH
80975: LD_VAR 0 30
80979: PUSH
80980: LD_VAR 0 31
80984: PUSH
80985: LD_VAR 0 32
80989: PUSH
80990: LD_VAR 0 33
80994: PUSH
80995: LD_VAR 0 34
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: PUSH
81008: LD_VAR 0 4
81012: PUSH
81013: LD_INT 1
81015: PLUS
81016: ARRAY
81017: ST_TO_ADDR
81018: GO 81503
81020: LD_INT 16
81022: DOUBLE
81023: EQUAL
81024: IFTRUE 81082
81026: LD_INT 17
81028: DOUBLE
81029: EQUAL
81030: IFTRUE 81082
81032: LD_INT 18
81034: DOUBLE
81035: EQUAL
81036: IFTRUE 81082
81038: LD_INT 19
81040: DOUBLE
81041: EQUAL
81042: IFTRUE 81082
81044: LD_INT 22
81046: DOUBLE
81047: EQUAL
81048: IFTRUE 81082
81050: LD_INT 20
81052: DOUBLE
81053: EQUAL
81054: IFTRUE 81082
81056: LD_INT 21
81058: DOUBLE
81059: EQUAL
81060: IFTRUE 81082
81062: LD_INT 23
81064: DOUBLE
81065: EQUAL
81066: IFTRUE 81082
81068: LD_INT 24
81070: DOUBLE
81071: EQUAL
81072: IFTRUE 81082
81074: LD_INT 25
81076: DOUBLE
81077: EQUAL
81078: IFTRUE 81082
81080: GO 81138
81082: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81083: LD_ADDR_VAR 0 9
81087: PUSH
81088: LD_VAR 0 35
81092: PUSH
81093: LD_VAR 0 36
81097: PUSH
81098: LD_VAR 0 37
81102: PUSH
81103: LD_VAR 0 38
81107: PUSH
81108: LD_VAR 0 39
81112: PUSH
81113: LD_VAR 0 40
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: PUSH
81126: LD_VAR 0 4
81130: PUSH
81131: LD_INT 1
81133: PLUS
81134: ARRAY
81135: ST_TO_ADDR
81136: GO 81503
81138: LD_INT 6
81140: DOUBLE
81141: EQUAL
81142: IFTRUE 81194
81144: LD_INT 7
81146: DOUBLE
81147: EQUAL
81148: IFTRUE 81194
81150: LD_INT 8
81152: DOUBLE
81153: EQUAL
81154: IFTRUE 81194
81156: LD_INT 13
81158: DOUBLE
81159: EQUAL
81160: IFTRUE 81194
81162: LD_INT 12
81164: DOUBLE
81165: EQUAL
81166: IFTRUE 81194
81168: LD_INT 15
81170: DOUBLE
81171: EQUAL
81172: IFTRUE 81194
81174: LD_INT 11
81176: DOUBLE
81177: EQUAL
81178: IFTRUE 81194
81180: LD_INT 14
81182: DOUBLE
81183: EQUAL
81184: IFTRUE 81194
81186: LD_INT 10
81188: DOUBLE
81189: EQUAL
81190: IFTRUE 81194
81192: GO 81250
81194: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81195: LD_ADDR_VAR 0 9
81199: PUSH
81200: LD_VAR 0 41
81204: PUSH
81205: LD_VAR 0 42
81209: PUSH
81210: LD_VAR 0 43
81214: PUSH
81215: LD_VAR 0 44
81219: PUSH
81220: LD_VAR 0 45
81224: PUSH
81225: LD_VAR 0 46
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: PUSH
81238: LD_VAR 0 4
81242: PUSH
81243: LD_INT 1
81245: PLUS
81246: ARRAY
81247: ST_TO_ADDR
81248: GO 81503
81250: LD_INT 36
81252: DOUBLE
81253: EQUAL
81254: IFTRUE 81258
81256: GO 81314
81258: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81259: LD_ADDR_VAR 0 9
81263: PUSH
81264: LD_VAR 0 47
81268: PUSH
81269: LD_VAR 0 48
81273: PUSH
81274: LD_VAR 0 49
81278: PUSH
81279: LD_VAR 0 50
81283: PUSH
81284: LD_VAR 0 51
81288: PUSH
81289: LD_VAR 0 52
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: PUSH
81302: LD_VAR 0 4
81306: PUSH
81307: LD_INT 1
81309: PLUS
81310: ARRAY
81311: ST_TO_ADDR
81312: GO 81503
81314: LD_INT 4
81316: DOUBLE
81317: EQUAL
81318: IFTRUE 81340
81320: LD_INT 5
81322: DOUBLE
81323: EQUAL
81324: IFTRUE 81340
81326: LD_INT 34
81328: DOUBLE
81329: EQUAL
81330: IFTRUE 81340
81332: LD_INT 37
81334: DOUBLE
81335: EQUAL
81336: IFTRUE 81340
81338: GO 81396
81340: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81341: LD_ADDR_VAR 0 9
81345: PUSH
81346: LD_VAR 0 53
81350: PUSH
81351: LD_VAR 0 54
81355: PUSH
81356: LD_VAR 0 55
81360: PUSH
81361: LD_VAR 0 56
81365: PUSH
81366: LD_VAR 0 57
81370: PUSH
81371: LD_VAR 0 58
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: PUSH
81384: LD_VAR 0 4
81388: PUSH
81389: LD_INT 1
81391: PLUS
81392: ARRAY
81393: ST_TO_ADDR
81394: GO 81503
81396: LD_INT 31
81398: DOUBLE
81399: EQUAL
81400: IFTRUE 81446
81402: LD_INT 32
81404: DOUBLE
81405: EQUAL
81406: IFTRUE 81446
81408: LD_INT 33
81410: DOUBLE
81411: EQUAL
81412: IFTRUE 81446
81414: LD_INT 27
81416: DOUBLE
81417: EQUAL
81418: IFTRUE 81446
81420: LD_INT 26
81422: DOUBLE
81423: EQUAL
81424: IFTRUE 81446
81426: LD_INT 28
81428: DOUBLE
81429: EQUAL
81430: IFTRUE 81446
81432: LD_INT 29
81434: DOUBLE
81435: EQUAL
81436: IFTRUE 81446
81438: LD_INT 30
81440: DOUBLE
81441: EQUAL
81442: IFTRUE 81446
81444: GO 81502
81446: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81447: LD_ADDR_VAR 0 9
81451: PUSH
81452: LD_VAR 0 59
81456: PUSH
81457: LD_VAR 0 60
81461: PUSH
81462: LD_VAR 0 61
81466: PUSH
81467: LD_VAR 0 62
81471: PUSH
81472: LD_VAR 0 63
81476: PUSH
81477: LD_VAR 0 64
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: PUSH
81490: LD_VAR 0 4
81494: PUSH
81495: LD_INT 1
81497: PLUS
81498: ARRAY
81499: ST_TO_ADDR
81500: GO 81503
81502: POP
// temp_list2 = [ ] ;
81503: LD_ADDR_VAR 0 10
81507: PUSH
81508: EMPTY
81509: ST_TO_ADDR
// for i in temp_list do
81510: LD_ADDR_VAR 0 8
81514: PUSH
81515: LD_VAR 0 9
81519: PUSH
81520: FOR_IN
81521: IFFALSE 81573
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81523: LD_ADDR_VAR 0 10
81527: PUSH
81528: LD_VAR 0 10
81532: PUSH
81533: LD_VAR 0 8
81537: PUSH
81538: LD_INT 1
81540: ARRAY
81541: PUSH
81542: LD_VAR 0 2
81546: PLUS
81547: PUSH
81548: LD_VAR 0 8
81552: PUSH
81553: LD_INT 2
81555: ARRAY
81556: PUSH
81557: LD_VAR 0 3
81561: PLUS
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: EMPTY
81568: LIST
81569: ADD
81570: ST_TO_ADDR
81571: GO 81520
81573: POP
81574: POP
// result = temp_list2 ;
81575: LD_ADDR_VAR 0 7
81579: PUSH
81580: LD_VAR 0 10
81584: ST_TO_ADDR
// end ;
81585: LD_VAR 0 7
81589: RET
// export function EnemyInRange ( unit , dist ) ; begin
81590: LD_INT 0
81592: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81593: LD_ADDR_VAR 0 3
81597: PUSH
81598: LD_VAR 0 1
81602: PPUSH
81603: CALL_OW 255
81607: PPUSH
81608: LD_VAR 0 1
81612: PPUSH
81613: CALL_OW 250
81617: PPUSH
81618: LD_VAR 0 1
81622: PPUSH
81623: CALL_OW 251
81627: PPUSH
81628: LD_VAR 0 2
81632: PPUSH
81633: CALL 54963 0 4
81637: PUSH
81638: LD_INT 4
81640: ARRAY
81641: ST_TO_ADDR
// end ;
81642: LD_VAR 0 3
81646: RET
// export function PlayerSeeMe ( unit ) ; begin
81647: LD_INT 0
81649: PPUSH
// result := See ( your_side , unit ) ;
81650: LD_ADDR_VAR 0 2
81654: PUSH
81655: LD_OWVAR 2
81659: PPUSH
81660: LD_VAR 0 1
81664: PPUSH
81665: CALL_OW 292
81669: ST_TO_ADDR
// end ;
81670: LD_VAR 0 2
81674: RET
// export function ReverseDir ( unit ) ; begin
81675: LD_INT 0
81677: PPUSH
// if not unit then
81678: LD_VAR 0 1
81682: NOT
81683: IFFALSE 81687
// exit ;
81685: GO 81710
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81687: LD_ADDR_VAR 0 2
81691: PUSH
81692: LD_VAR 0 1
81696: PPUSH
81697: CALL_OW 254
81701: PUSH
81702: LD_INT 3
81704: PLUS
81705: PUSH
81706: LD_INT 6
81708: MOD
81709: ST_TO_ADDR
// end ;
81710: LD_VAR 0 2
81714: RET
// export function ReverseArray ( array ) ; var i ; begin
81715: LD_INT 0
81717: PPUSH
81718: PPUSH
// if not array then
81719: LD_VAR 0 1
81723: NOT
81724: IFFALSE 81728
// exit ;
81726: GO 81783
// result := [ ] ;
81728: LD_ADDR_VAR 0 2
81732: PUSH
81733: EMPTY
81734: ST_TO_ADDR
// for i := array downto 1 do
81735: LD_ADDR_VAR 0 3
81739: PUSH
81740: DOUBLE
81741: LD_VAR 0 1
81745: INC
81746: ST_TO_ADDR
81747: LD_INT 1
81749: PUSH
81750: FOR_DOWNTO
81751: IFFALSE 81781
// result := Join ( result , array [ i ] ) ;
81753: LD_ADDR_VAR 0 2
81757: PUSH
81758: LD_VAR 0 2
81762: PPUSH
81763: LD_VAR 0 1
81767: PUSH
81768: LD_VAR 0 3
81772: ARRAY
81773: PPUSH
81774: CALL 86426 0 2
81778: ST_TO_ADDR
81779: GO 81750
81781: POP
81782: POP
// end ;
81783: LD_VAR 0 2
81787: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81788: LD_INT 0
81790: PPUSH
81791: PPUSH
81792: PPUSH
81793: PPUSH
81794: PPUSH
81795: PPUSH
// if not unit or not hexes then
81796: LD_VAR 0 1
81800: NOT
81801: PUSH
81802: LD_VAR 0 2
81806: NOT
81807: OR
81808: IFFALSE 81812
// exit ;
81810: GO 81935
// dist := 9999 ;
81812: LD_ADDR_VAR 0 5
81816: PUSH
81817: LD_INT 9999
81819: ST_TO_ADDR
// for i = 1 to hexes do
81820: LD_ADDR_VAR 0 4
81824: PUSH
81825: DOUBLE
81826: LD_INT 1
81828: DEC
81829: ST_TO_ADDR
81830: LD_VAR 0 2
81834: PUSH
81835: FOR_TO
81836: IFFALSE 81923
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81838: LD_ADDR_VAR 0 6
81842: PUSH
81843: LD_VAR 0 1
81847: PPUSH
81848: LD_VAR 0 2
81852: PUSH
81853: LD_VAR 0 4
81857: ARRAY
81858: PUSH
81859: LD_INT 1
81861: ARRAY
81862: PPUSH
81863: LD_VAR 0 2
81867: PUSH
81868: LD_VAR 0 4
81872: ARRAY
81873: PUSH
81874: LD_INT 2
81876: ARRAY
81877: PPUSH
81878: CALL_OW 297
81882: ST_TO_ADDR
// if tdist < dist then
81883: LD_VAR 0 6
81887: PUSH
81888: LD_VAR 0 5
81892: LESS
81893: IFFALSE 81921
// begin hex := hexes [ i ] ;
81895: LD_ADDR_VAR 0 8
81899: PUSH
81900: LD_VAR 0 2
81904: PUSH
81905: LD_VAR 0 4
81909: ARRAY
81910: ST_TO_ADDR
// dist := tdist ;
81911: LD_ADDR_VAR 0 5
81915: PUSH
81916: LD_VAR 0 6
81920: ST_TO_ADDR
// end ; end ;
81921: GO 81835
81923: POP
81924: POP
// result := hex ;
81925: LD_ADDR_VAR 0 3
81929: PUSH
81930: LD_VAR 0 8
81934: ST_TO_ADDR
// end ;
81935: LD_VAR 0 3
81939: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81940: LD_INT 0
81942: PPUSH
81943: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81944: LD_VAR 0 1
81948: NOT
81949: PUSH
81950: LD_VAR 0 1
81954: PUSH
81955: LD_INT 21
81957: PUSH
81958: LD_INT 2
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 23
81967: PUSH
81968: LD_INT 2
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PPUSH
81979: CALL_OW 69
81983: IN
81984: NOT
81985: OR
81986: IFFALSE 81990
// exit ;
81988: GO 82037
// for i = 1 to 3 do
81990: LD_ADDR_VAR 0 3
81994: PUSH
81995: DOUBLE
81996: LD_INT 1
81998: DEC
81999: ST_TO_ADDR
82000: LD_INT 3
82002: PUSH
82003: FOR_TO
82004: IFFALSE 82035
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82006: LD_VAR 0 1
82010: PPUSH
82011: CALL_OW 250
82015: PPUSH
82016: LD_VAR 0 1
82020: PPUSH
82021: CALL_OW 251
82025: PPUSH
82026: LD_INT 1
82028: PPUSH
82029: CALL_OW 453
82033: GO 82003
82035: POP
82036: POP
// end ;
82037: LD_VAR 0 2
82041: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82042: LD_INT 0
82044: PPUSH
82045: PPUSH
82046: PPUSH
82047: PPUSH
82048: PPUSH
82049: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82050: LD_VAR 0 1
82054: NOT
82055: PUSH
82056: LD_VAR 0 2
82060: NOT
82061: OR
82062: PUSH
82063: LD_VAR 0 1
82067: PPUSH
82068: CALL_OW 314
82072: OR
82073: IFFALSE 82077
// exit ;
82075: GO 82544
// if GetLives ( i ) < 250 then
82077: LD_VAR 0 4
82081: PPUSH
82082: CALL_OW 256
82086: PUSH
82087: LD_INT 250
82089: LESS
82090: IFFALSE 82103
// begin ComAutodestruct ( i ) ;
82092: LD_VAR 0 4
82096: PPUSH
82097: CALL 81940 0 1
// exit ;
82101: GO 82544
// end ; x := GetX ( enemy_unit ) ;
82103: LD_ADDR_VAR 0 7
82107: PUSH
82108: LD_VAR 0 2
82112: PPUSH
82113: CALL_OW 250
82117: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82118: LD_ADDR_VAR 0 8
82122: PUSH
82123: LD_VAR 0 2
82127: PPUSH
82128: CALL_OW 251
82132: ST_TO_ADDR
// if not x or not y then
82133: LD_VAR 0 7
82137: NOT
82138: PUSH
82139: LD_VAR 0 8
82143: NOT
82144: OR
82145: IFFALSE 82149
// exit ;
82147: GO 82544
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82149: LD_ADDR_VAR 0 6
82153: PUSH
82154: LD_VAR 0 7
82158: PPUSH
82159: LD_INT 0
82161: PPUSH
82162: LD_INT 4
82164: PPUSH
82165: CALL_OW 272
82169: PUSH
82170: LD_VAR 0 8
82174: PPUSH
82175: LD_INT 0
82177: PPUSH
82178: LD_INT 4
82180: PPUSH
82181: CALL_OW 273
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_VAR 0 7
82194: PPUSH
82195: LD_INT 1
82197: PPUSH
82198: LD_INT 4
82200: PPUSH
82201: CALL_OW 272
82205: PUSH
82206: LD_VAR 0 8
82210: PPUSH
82211: LD_INT 1
82213: PPUSH
82214: LD_INT 4
82216: PPUSH
82217: CALL_OW 273
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_VAR 0 7
82230: PPUSH
82231: LD_INT 2
82233: PPUSH
82234: LD_INT 4
82236: PPUSH
82237: CALL_OW 272
82241: PUSH
82242: LD_VAR 0 8
82246: PPUSH
82247: LD_INT 2
82249: PPUSH
82250: LD_INT 4
82252: PPUSH
82253: CALL_OW 273
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_VAR 0 7
82266: PPUSH
82267: LD_INT 3
82269: PPUSH
82270: LD_INT 4
82272: PPUSH
82273: CALL_OW 272
82277: PUSH
82278: LD_VAR 0 8
82282: PPUSH
82283: LD_INT 3
82285: PPUSH
82286: LD_INT 4
82288: PPUSH
82289: CALL_OW 273
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_VAR 0 7
82302: PPUSH
82303: LD_INT 4
82305: PPUSH
82306: LD_INT 4
82308: PPUSH
82309: CALL_OW 272
82313: PUSH
82314: LD_VAR 0 8
82318: PPUSH
82319: LD_INT 4
82321: PPUSH
82322: LD_INT 4
82324: PPUSH
82325: CALL_OW 273
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_VAR 0 7
82338: PPUSH
82339: LD_INT 5
82341: PPUSH
82342: LD_INT 4
82344: PPUSH
82345: CALL_OW 272
82349: PUSH
82350: LD_VAR 0 8
82354: PPUSH
82355: LD_INT 5
82357: PPUSH
82358: LD_INT 4
82360: PPUSH
82361: CALL_OW 273
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: ST_TO_ADDR
// for i = tmp downto 1 do
82378: LD_ADDR_VAR 0 4
82382: PUSH
82383: DOUBLE
82384: LD_VAR 0 6
82388: INC
82389: ST_TO_ADDR
82390: LD_INT 1
82392: PUSH
82393: FOR_DOWNTO
82394: IFFALSE 82495
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82396: LD_VAR 0 6
82400: PUSH
82401: LD_VAR 0 4
82405: ARRAY
82406: PUSH
82407: LD_INT 1
82409: ARRAY
82410: PPUSH
82411: LD_VAR 0 6
82415: PUSH
82416: LD_VAR 0 4
82420: ARRAY
82421: PUSH
82422: LD_INT 2
82424: ARRAY
82425: PPUSH
82426: CALL_OW 488
82430: NOT
82431: PUSH
82432: LD_VAR 0 6
82436: PUSH
82437: LD_VAR 0 4
82441: ARRAY
82442: PUSH
82443: LD_INT 1
82445: ARRAY
82446: PPUSH
82447: LD_VAR 0 6
82451: PUSH
82452: LD_VAR 0 4
82456: ARRAY
82457: PUSH
82458: LD_INT 2
82460: ARRAY
82461: PPUSH
82462: CALL_OW 428
82466: PUSH
82467: LD_INT 0
82469: NONEQUAL
82470: OR
82471: IFFALSE 82493
// tmp := Delete ( tmp , i ) ;
82473: LD_ADDR_VAR 0 6
82477: PUSH
82478: LD_VAR 0 6
82482: PPUSH
82483: LD_VAR 0 4
82487: PPUSH
82488: CALL_OW 3
82492: ST_TO_ADDR
82493: GO 82393
82495: POP
82496: POP
// j := GetClosestHex ( unit , tmp ) ;
82497: LD_ADDR_VAR 0 5
82501: PUSH
82502: LD_VAR 0 1
82506: PPUSH
82507: LD_VAR 0 6
82511: PPUSH
82512: CALL 81788 0 2
82516: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82517: LD_VAR 0 1
82521: PPUSH
82522: LD_VAR 0 5
82526: PUSH
82527: LD_INT 1
82529: ARRAY
82530: PPUSH
82531: LD_VAR 0 5
82535: PUSH
82536: LD_INT 2
82538: ARRAY
82539: PPUSH
82540: CALL_OW 111
// end ;
82544: LD_VAR 0 3
82548: RET
// export function PrepareApemanSoldier ( ) ; begin
82549: LD_INT 0
82551: PPUSH
// uc_nation := 0 ;
82552: LD_ADDR_OWVAR 21
82556: PUSH
82557: LD_INT 0
82559: ST_TO_ADDR
// hc_sex := sex_male ;
82560: LD_ADDR_OWVAR 27
82564: PUSH
82565: LD_INT 1
82567: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82568: LD_ADDR_OWVAR 28
82572: PUSH
82573: LD_INT 15
82575: ST_TO_ADDR
// hc_gallery :=  ;
82576: LD_ADDR_OWVAR 33
82580: PUSH
82581: LD_STRING 
82583: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82584: LD_ADDR_OWVAR 31
82588: PUSH
82589: LD_INT 0
82591: PPUSH
82592: LD_INT 3
82594: PPUSH
82595: CALL_OW 12
82599: PUSH
82600: LD_INT 0
82602: PPUSH
82603: LD_INT 3
82605: PPUSH
82606: CALL_OW 12
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: LD_INT 0
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: ST_TO_ADDR
// end ;
82623: LD_VAR 0 1
82627: RET
// export function PrepareApemanEngineer ( ) ; begin
82628: LD_INT 0
82630: PPUSH
// uc_nation := 0 ;
82631: LD_ADDR_OWVAR 21
82635: PUSH
82636: LD_INT 0
82638: ST_TO_ADDR
// hc_sex := sex_male ;
82639: LD_ADDR_OWVAR 27
82643: PUSH
82644: LD_INT 1
82646: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82647: LD_ADDR_OWVAR 28
82651: PUSH
82652: LD_INT 16
82654: ST_TO_ADDR
// hc_gallery :=  ;
82655: LD_ADDR_OWVAR 33
82659: PUSH
82660: LD_STRING 
82662: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82663: LD_ADDR_OWVAR 31
82667: PUSH
82668: LD_INT 0
82670: PPUSH
82671: LD_INT 3
82673: PPUSH
82674: CALL_OW 12
82678: PUSH
82679: LD_INT 0
82681: PPUSH
82682: LD_INT 3
82684: PPUSH
82685: CALL_OW 12
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: ST_TO_ADDR
// end ;
82702: LD_VAR 0 1
82706: RET
// export function PrepareApeman ( agressivity ) ; begin
82707: LD_INT 0
82709: PPUSH
// uc_side := 0 ;
82710: LD_ADDR_OWVAR 20
82714: PUSH
82715: LD_INT 0
82717: ST_TO_ADDR
// uc_nation := 0 ;
82718: LD_ADDR_OWVAR 21
82722: PUSH
82723: LD_INT 0
82725: ST_TO_ADDR
// hc_sex := sex_male ;
82726: LD_ADDR_OWVAR 27
82730: PUSH
82731: LD_INT 1
82733: ST_TO_ADDR
// hc_class := class_apeman ;
82734: LD_ADDR_OWVAR 28
82738: PUSH
82739: LD_INT 12
82741: ST_TO_ADDR
// hc_gallery :=  ;
82742: LD_ADDR_OWVAR 33
82746: PUSH
82747: LD_STRING 
82749: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82750: LD_ADDR_OWVAR 35
82754: PUSH
82755: LD_VAR 0 1
82759: NEG
82760: PPUSH
82761: LD_VAR 0 1
82765: PPUSH
82766: CALL_OW 12
82770: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82771: LD_ADDR_OWVAR 31
82775: PUSH
82776: LD_INT 0
82778: PPUSH
82779: LD_INT 3
82781: PPUSH
82782: CALL_OW 12
82786: PUSH
82787: LD_INT 0
82789: PPUSH
82790: LD_INT 3
82792: PPUSH
82793: CALL_OW 12
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: LD_INT 0
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: ST_TO_ADDR
// end ;
82810: LD_VAR 0 2
82814: RET
// export function PrepareTiger ( agressivity ) ; begin
82815: LD_INT 0
82817: PPUSH
// uc_side := 0 ;
82818: LD_ADDR_OWVAR 20
82822: PUSH
82823: LD_INT 0
82825: ST_TO_ADDR
// uc_nation := 0 ;
82826: LD_ADDR_OWVAR 21
82830: PUSH
82831: LD_INT 0
82833: ST_TO_ADDR
// hc_class := class_tiger ;
82834: LD_ADDR_OWVAR 28
82838: PUSH
82839: LD_INT 14
82841: ST_TO_ADDR
// hc_gallery :=  ;
82842: LD_ADDR_OWVAR 33
82846: PUSH
82847: LD_STRING 
82849: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82850: LD_ADDR_OWVAR 35
82854: PUSH
82855: LD_VAR 0 1
82859: NEG
82860: PPUSH
82861: LD_VAR 0 1
82865: PPUSH
82866: CALL_OW 12
82870: ST_TO_ADDR
// end ;
82871: LD_VAR 0 2
82875: RET
// export function PrepareEnchidna ( ) ; begin
82876: LD_INT 0
82878: PPUSH
// uc_side := 0 ;
82879: LD_ADDR_OWVAR 20
82883: PUSH
82884: LD_INT 0
82886: ST_TO_ADDR
// uc_nation := 0 ;
82887: LD_ADDR_OWVAR 21
82891: PUSH
82892: LD_INT 0
82894: ST_TO_ADDR
// hc_class := class_baggie ;
82895: LD_ADDR_OWVAR 28
82899: PUSH
82900: LD_INT 13
82902: ST_TO_ADDR
// hc_gallery :=  ;
82903: LD_ADDR_OWVAR 33
82907: PUSH
82908: LD_STRING 
82910: ST_TO_ADDR
// end ;
82911: LD_VAR 0 1
82915: RET
// export function PrepareFrog ( ) ; begin
82916: LD_INT 0
82918: PPUSH
// uc_side := 0 ;
82919: LD_ADDR_OWVAR 20
82923: PUSH
82924: LD_INT 0
82926: ST_TO_ADDR
// uc_nation := 0 ;
82927: LD_ADDR_OWVAR 21
82931: PUSH
82932: LD_INT 0
82934: ST_TO_ADDR
// hc_class := class_frog ;
82935: LD_ADDR_OWVAR 28
82939: PUSH
82940: LD_INT 19
82942: ST_TO_ADDR
// hc_gallery :=  ;
82943: LD_ADDR_OWVAR 33
82947: PUSH
82948: LD_STRING 
82950: ST_TO_ADDR
// end ;
82951: LD_VAR 0 1
82955: RET
// export function PrepareFish ( ) ; begin
82956: LD_INT 0
82958: PPUSH
// uc_side := 0 ;
82959: LD_ADDR_OWVAR 20
82963: PUSH
82964: LD_INT 0
82966: ST_TO_ADDR
// uc_nation := 0 ;
82967: LD_ADDR_OWVAR 21
82971: PUSH
82972: LD_INT 0
82974: ST_TO_ADDR
// hc_class := class_fish ;
82975: LD_ADDR_OWVAR 28
82979: PUSH
82980: LD_INT 20
82982: ST_TO_ADDR
// hc_gallery :=  ;
82983: LD_ADDR_OWVAR 33
82987: PUSH
82988: LD_STRING 
82990: ST_TO_ADDR
// end ;
82991: LD_VAR 0 1
82995: RET
// export function PrepareBird ( ) ; begin
82996: LD_INT 0
82998: PPUSH
// uc_side := 0 ;
82999: LD_ADDR_OWVAR 20
83003: PUSH
83004: LD_INT 0
83006: ST_TO_ADDR
// uc_nation := 0 ;
83007: LD_ADDR_OWVAR 21
83011: PUSH
83012: LD_INT 0
83014: ST_TO_ADDR
// hc_class := class_phororhacos ;
83015: LD_ADDR_OWVAR 28
83019: PUSH
83020: LD_INT 18
83022: ST_TO_ADDR
// hc_gallery :=  ;
83023: LD_ADDR_OWVAR 33
83027: PUSH
83028: LD_STRING 
83030: ST_TO_ADDR
// end ;
83031: LD_VAR 0 1
83035: RET
// export function PrepareHorse ( ) ; begin
83036: LD_INT 0
83038: PPUSH
// uc_side := 0 ;
83039: LD_ADDR_OWVAR 20
83043: PUSH
83044: LD_INT 0
83046: ST_TO_ADDR
// uc_nation := 0 ;
83047: LD_ADDR_OWVAR 21
83051: PUSH
83052: LD_INT 0
83054: ST_TO_ADDR
// hc_class := class_horse ;
83055: LD_ADDR_OWVAR 28
83059: PUSH
83060: LD_INT 21
83062: ST_TO_ADDR
// hc_gallery :=  ;
83063: LD_ADDR_OWVAR 33
83067: PUSH
83068: LD_STRING 
83070: ST_TO_ADDR
// end ;
83071: LD_VAR 0 1
83075: RET
// export function PrepareMastodont ( ) ; begin
83076: LD_INT 0
83078: PPUSH
// uc_side := 0 ;
83079: LD_ADDR_OWVAR 20
83083: PUSH
83084: LD_INT 0
83086: ST_TO_ADDR
// uc_nation := 0 ;
83087: LD_ADDR_OWVAR 21
83091: PUSH
83092: LD_INT 0
83094: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83095: LD_ADDR_OWVAR 37
83099: PUSH
83100: LD_INT 31
83102: ST_TO_ADDR
// vc_control := control_rider ;
83103: LD_ADDR_OWVAR 38
83107: PUSH
83108: LD_INT 4
83110: ST_TO_ADDR
// end ;
83111: LD_VAR 0 1
83115: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83116: LD_INT 0
83118: PPUSH
83119: PPUSH
83120: PPUSH
// uc_side = 0 ;
83121: LD_ADDR_OWVAR 20
83125: PUSH
83126: LD_INT 0
83128: ST_TO_ADDR
// uc_nation = 0 ;
83129: LD_ADDR_OWVAR 21
83133: PUSH
83134: LD_INT 0
83136: ST_TO_ADDR
// InitHc_All ( ) ;
83137: CALL_OW 584
// InitVc ;
83141: CALL_OW 20
// if mastodonts then
83145: LD_VAR 0 6
83149: IFFALSE 83216
// for i = 1 to mastodonts do
83151: LD_ADDR_VAR 0 11
83155: PUSH
83156: DOUBLE
83157: LD_INT 1
83159: DEC
83160: ST_TO_ADDR
83161: LD_VAR 0 6
83165: PUSH
83166: FOR_TO
83167: IFFALSE 83214
// begin vc_chassis := 31 ;
83169: LD_ADDR_OWVAR 37
83173: PUSH
83174: LD_INT 31
83176: ST_TO_ADDR
// vc_control := control_rider ;
83177: LD_ADDR_OWVAR 38
83181: PUSH
83182: LD_INT 4
83184: ST_TO_ADDR
// animal := CreateVehicle ;
83185: LD_ADDR_VAR 0 12
83189: PUSH
83190: CALL_OW 45
83194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83195: LD_VAR 0 12
83199: PPUSH
83200: LD_VAR 0 8
83204: PPUSH
83205: LD_INT 0
83207: PPUSH
83208: CALL 85344 0 3
// end ;
83212: GO 83166
83214: POP
83215: POP
// if horses then
83216: LD_VAR 0 5
83220: IFFALSE 83287
// for i = 1 to horses do
83222: LD_ADDR_VAR 0 11
83226: PUSH
83227: DOUBLE
83228: LD_INT 1
83230: DEC
83231: ST_TO_ADDR
83232: LD_VAR 0 5
83236: PUSH
83237: FOR_TO
83238: IFFALSE 83285
// begin hc_class := 21 ;
83240: LD_ADDR_OWVAR 28
83244: PUSH
83245: LD_INT 21
83247: ST_TO_ADDR
// hc_gallery :=  ;
83248: LD_ADDR_OWVAR 33
83252: PUSH
83253: LD_STRING 
83255: ST_TO_ADDR
// animal := CreateHuman ;
83256: LD_ADDR_VAR 0 12
83260: PUSH
83261: CALL_OW 44
83265: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83266: LD_VAR 0 12
83270: PPUSH
83271: LD_VAR 0 8
83275: PPUSH
83276: LD_INT 0
83278: PPUSH
83279: CALL 85344 0 3
// end ;
83283: GO 83237
83285: POP
83286: POP
// if birds then
83287: LD_VAR 0 1
83291: IFFALSE 83358
// for i = 1 to birds do
83293: LD_ADDR_VAR 0 11
83297: PUSH
83298: DOUBLE
83299: LD_INT 1
83301: DEC
83302: ST_TO_ADDR
83303: LD_VAR 0 1
83307: PUSH
83308: FOR_TO
83309: IFFALSE 83356
// begin hc_class := 18 ;
83311: LD_ADDR_OWVAR 28
83315: PUSH
83316: LD_INT 18
83318: ST_TO_ADDR
// hc_gallery =  ;
83319: LD_ADDR_OWVAR 33
83323: PUSH
83324: LD_STRING 
83326: ST_TO_ADDR
// animal := CreateHuman ;
83327: LD_ADDR_VAR 0 12
83331: PUSH
83332: CALL_OW 44
83336: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83337: LD_VAR 0 12
83341: PPUSH
83342: LD_VAR 0 8
83346: PPUSH
83347: LD_INT 0
83349: PPUSH
83350: CALL 85344 0 3
// end ;
83354: GO 83308
83356: POP
83357: POP
// if tigers then
83358: LD_VAR 0 2
83362: IFFALSE 83446
// for i = 1 to tigers do
83364: LD_ADDR_VAR 0 11
83368: PUSH
83369: DOUBLE
83370: LD_INT 1
83372: DEC
83373: ST_TO_ADDR
83374: LD_VAR 0 2
83378: PUSH
83379: FOR_TO
83380: IFFALSE 83444
// begin hc_class = class_tiger ;
83382: LD_ADDR_OWVAR 28
83386: PUSH
83387: LD_INT 14
83389: ST_TO_ADDR
// hc_gallery =  ;
83390: LD_ADDR_OWVAR 33
83394: PUSH
83395: LD_STRING 
83397: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83398: LD_ADDR_OWVAR 35
83402: PUSH
83403: LD_INT 7
83405: NEG
83406: PPUSH
83407: LD_INT 7
83409: PPUSH
83410: CALL_OW 12
83414: ST_TO_ADDR
// animal := CreateHuman ;
83415: LD_ADDR_VAR 0 12
83419: PUSH
83420: CALL_OW 44
83424: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83425: LD_VAR 0 12
83429: PPUSH
83430: LD_VAR 0 8
83434: PPUSH
83435: LD_INT 0
83437: PPUSH
83438: CALL 85344 0 3
// end ;
83442: GO 83379
83444: POP
83445: POP
// if apemans then
83446: LD_VAR 0 3
83450: IFFALSE 83573
// for i = 1 to apemans do
83452: LD_ADDR_VAR 0 11
83456: PUSH
83457: DOUBLE
83458: LD_INT 1
83460: DEC
83461: ST_TO_ADDR
83462: LD_VAR 0 3
83466: PUSH
83467: FOR_TO
83468: IFFALSE 83571
// begin hc_class = class_apeman ;
83470: LD_ADDR_OWVAR 28
83474: PUSH
83475: LD_INT 12
83477: ST_TO_ADDR
// hc_gallery =  ;
83478: LD_ADDR_OWVAR 33
83482: PUSH
83483: LD_STRING 
83485: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83486: LD_ADDR_OWVAR 35
83490: PUSH
83491: LD_INT 2
83493: NEG
83494: PPUSH
83495: LD_INT 2
83497: PPUSH
83498: CALL_OW 12
83502: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83503: LD_ADDR_OWVAR 31
83507: PUSH
83508: LD_INT 1
83510: PPUSH
83511: LD_INT 3
83513: PPUSH
83514: CALL_OW 12
83518: PUSH
83519: LD_INT 1
83521: PPUSH
83522: LD_INT 3
83524: PPUSH
83525: CALL_OW 12
83529: PUSH
83530: LD_INT 0
83532: PUSH
83533: LD_INT 0
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: ST_TO_ADDR
// animal := CreateHuman ;
83542: LD_ADDR_VAR 0 12
83546: PUSH
83547: CALL_OW 44
83551: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83552: LD_VAR 0 12
83556: PPUSH
83557: LD_VAR 0 8
83561: PPUSH
83562: LD_INT 0
83564: PPUSH
83565: CALL 85344 0 3
// end ;
83569: GO 83467
83571: POP
83572: POP
// if enchidnas then
83573: LD_VAR 0 4
83577: IFFALSE 83644
// for i = 1 to enchidnas do
83579: LD_ADDR_VAR 0 11
83583: PUSH
83584: DOUBLE
83585: LD_INT 1
83587: DEC
83588: ST_TO_ADDR
83589: LD_VAR 0 4
83593: PUSH
83594: FOR_TO
83595: IFFALSE 83642
// begin hc_class = 13 ;
83597: LD_ADDR_OWVAR 28
83601: PUSH
83602: LD_INT 13
83604: ST_TO_ADDR
// hc_gallery =  ;
83605: LD_ADDR_OWVAR 33
83609: PUSH
83610: LD_STRING 
83612: ST_TO_ADDR
// animal := CreateHuman ;
83613: LD_ADDR_VAR 0 12
83617: PUSH
83618: CALL_OW 44
83622: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83623: LD_VAR 0 12
83627: PPUSH
83628: LD_VAR 0 8
83632: PPUSH
83633: LD_INT 0
83635: PPUSH
83636: CALL 85344 0 3
// end ;
83640: GO 83594
83642: POP
83643: POP
// if fishes then
83644: LD_VAR 0 7
83648: IFFALSE 83715
// for i = 1 to fishes do
83650: LD_ADDR_VAR 0 11
83654: PUSH
83655: DOUBLE
83656: LD_INT 1
83658: DEC
83659: ST_TO_ADDR
83660: LD_VAR 0 7
83664: PUSH
83665: FOR_TO
83666: IFFALSE 83713
// begin hc_class = 20 ;
83668: LD_ADDR_OWVAR 28
83672: PUSH
83673: LD_INT 20
83675: ST_TO_ADDR
// hc_gallery =  ;
83676: LD_ADDR_OWVAR 33
83680: PUSH
83681: LD_STRING 
83683: ST_TO_ADDR
// animal := CreateHuman ;
83684: LD_ADDR_VAR 0 12
83688: PUSH
83689: CALL_OW 44
83693: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83694: LD_VAR 0 12
83698: PPUSH
83699: LD_VAR 0 9
83703: PPUSH
83704: LD_INT 0
83706: PPUSH
83707: CALL 85344 0 3
// end ;
83711: GO 83665
83713: POP
83714: POP
// end ;
83715: LD_VAR 0 10
83719: RET
// export function WantHeal ( sci , unit ) ; begin
83720: LD_INT 0
83722: PPUSH
// if GetTaskList ( sci ) > 0 then
83723: LD_VAR 0 1
83727: PPUSH
83728: CALL_OW 437
83732: PUSH
83733: LD_INT 0
83735: GREATER
83736: IFFALSE 83806
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83738: LD_VAR 0 1
83742: PPUSH
83743: CALL_OW 437
83747: PUSH
83748: LD_INT 1
83750: ARRAY
83751: PUSH
83752: LD_INT 1
83754: ARRAY
83755: PUSH
83756: LD_STRING l
83758: EQUAL
83759: PUSH
83760: LD_VAR 0 1
83764: PPUSH
83765: CALL_OW 437
83769: PUSH
83770: LD_INT 1
83772: ARRAY
83773: PUSH
83774: LD_INT 4
83776: ARRAY
83777: PUSH
83778: LD_VAR 0 2
83782: EQUAL
83783: AND
83784: IFFALSE 83796
// result := true else
83786: LD_ADDR_VAR 0 3
83790: PUSH
83791: LD_INT 1
83793: ST_TO_ADDR
83794: GO 83804
// result := false ;
83796: LD_ADDR_VAR 0 3
83800: PUSH
83801: LD_INT 0
83803: ST_TO_ADDR
// end else
83804: GO 83814
// result := false ;
83806: LD_ADDR_VAR 0 3
83810: PUSH
83811: LD_INT 0
83813: ST_TO_ADDR
// end ;
83814: LD_VAR 0 3
83818: RET
// export function HealTarget ( sci ) ; begin
83819: LD_INT 0
83821: PPUSH
// if not sci then
83822: LD_VAR 0 1
83826: NOT
83827: IFFALSE 83831
// exit ;
83829: GO 83896
// result := 0 ;
83831: LD_ADDR_VAR 0 2
83835: PUSH
83836: LD_INT 0
83838: ST_TO_ADDR
// if GetTaskList ( sci ) then
83839: LD_VAR 0 1
83843: PPUSH
83844: CALL_OW 437
83848: IFFALSE 83896
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83850: LD_VAR 0 1
83854: PPUSH
83855: CALL_OW 437
83859: PUSH
83860: LD_INT 1
83862: ARRAY
83863: PUSH
83864: LD_INT 1
83866: ARRAY
83867: PUSH
83868: LD_STRING l
83870: EQUAL
83871: IFFALSE 83896
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83873: LD_ADDR_VAR 0 2
83877: PUSH
83878: LD_VAR 0 1
83882: PPUSH
83883: CALL_OW 437
83887: PUSH
83888: LD_INT 1
83890: ARRAY
83891: PUSH
83892: LD_INT 4
83894: ARRAY
83895: ST_TO_ADDR
// end ;
83896: LD_VAR 0 2
83900: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83901: LD_INT 0
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
// if not base_units then
83907: LD_VAR 0 1
83911: NOT
83912: IFFALSE 83916
// exit ;
83914: GO 84003
// result := false ;
83916: LD_ADDR_VAR 0 2
83920: PUSH
83921: LD_INT 0
83923: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83924: LD_ADDR_VAR 0 5
83928: PUSH
83929: LD_VAR 0 1
83933: PPUSH
83934: LD_INT 21
83936: PUSH
83937: LD_INT 3
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PPUSH
83944: CALL_OW 72
83948: ST_TO_ADDR
// if not tmp then
83949: LD_VAR 0 5
83953: NOT
83954: IFFALSE 83958
// exit ;
83956: GO 84003
// for i in tmp do
83958: LD_ADDR_VAR 0 3
83962: PUSH
83963: LD_VAR 0 5
83967: PUSH
83968: FOR_IN
83969: IFFALSE 84001
// begin result := EnemyInRange ( i , 22 ) ;
83971: LD_ADDR_VAR 0 2
83975: PUSH
83976: LD_VAR 0 3
83980: PPUSH
83981: LD_INT 22
83983: PPUSH
83984: CALL 81590 0 2
83988: ST_TO_ADDR
// if result then
83989: LD_VAR 0 2
83993: IFFALSE 83999
// exit ;
83995: POP
83996: POP
83997: GO 84003
// end ;
83999: GO 83968
84001: POP
84002: POP
// end ;
84003: LD_VAR 0 2
84007: RET
// export function FilterByTag ( units , tag ) ; begin
84008: LD_INT 0
84010: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84011: LD_ADDR_VAR 0 3
84015: PUSH
84016: LD_VAR 0 1
84020: PPUSH
84021: LD_INT 120
84023: PUSH
84024: LD_VAR 0 2
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PPUSH
84033: CALL_OW 72
84037: ST_TO_ADDR
// end ;
84038: LD_VAR 0 3
84042: RET
// export function IsDriver ( un ) ; begin
84043: LD_INT 0
84045: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84046: LD_ADDR_VAR 0 2
84050: PUSH
84051: LD_VAR 0 1
84055: PUSH
84056: LD_INT 55
84058: PUSH
84059: EMPTY
84060: LIST
84061: PPUSH
84062: CALL_OW 69
84066: IN
84067: ST_TO_ADDR
// end ;
84068: LD_VAR 0 2
84072: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84073: LD_INT 0
84075: PPUSH
84076: PPUSH
// list := [ ] ;
84077: LD_ADDR_VAR 0 5
84081: PUSH
84082: EMPTY
84083: ST_TO_ADDR
// case d of 0 :
84084: LD_VAR 0 3
84088: PUSH
84089: LD_INT 0
84091: DOUBLE
84092: EQUAL
84093: IFTRUE 84097
84095: GO 84230
84097: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84098: LD_ADDR_VAR 0 5
84102: PUSH
84103: LD_VAR 0 1
84107: PUSH
84108: LD_INT 4
84110: MINUS
84111: PUSH
84112: LD_VAR 0 2
84116: PUSH
84117: LD_INT 4
84119: MINUS
84120: PUSH
84121: LD_INT 2
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: LIST
84128: PUSH
84129: LD_VAR 0 1
84133: PUSH
84134: LD_INT 3
84136: MINUS
84137: PUSH
84138: LD_VAR 0 2
84142: PUSH
84143: LD_INT 1
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: LIST
84150: PUSH
84151: LD_VAR 0 1
84155: PUSH
84156: LD_INT 4
84158: PLUS
84159: PUSH
84160: LD_VAR 0 2
84164: PUSH
84165: LD_INT 4
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: LIST
84172: PUSH
84173: LD_VAR 0 1
84177: PUSH
84178: LD_INT 3
84180: PLUS
84181: PUSH
84182: LD_VAR 0 2
84186: PUSH
84187: LD_INT 3
84189: PLUS
84190: PUSH
84191: LD_INT 5
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: LIST
84198: PUSH
84199: LD_VAR 0 1
84203: PUSH
84204: LD_VAR 0 2
84208: PUSH
84209: LD_INT 4
84211: PLUS
84212: PUSH
84213: LD_INT 0
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: ST_TO_ADDR
// end ; 1 :
84228: GO 84928
84230: LD_INT 1
84232: DOUBLE
84233: EQUAL
84234: IFTRUE 84238
84236: GO 84371
84238: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84239: LD_ADDR_VAR 0 5
84243: PUSH
84244: LD_VAR 0 1
84248: PUSH
84249: LD_VAR 0 2
84253: PUSH
84254: LD_INT 4
84256: MINUS
84257: PUSH
84258: LD_INT 3
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: LIST
84265: PUSH
84266: LD_VAR 0 1
84270: PUSH
84271: LD_INT 3
84273: MINUS
84274: PUSH
84275: LD_VAR 0 2
84279: PUSH
84280: LD_INT 3
84282: MINUS
84283: PUSH
84284: LD_INT 2
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: PUSH
84292: LD_VAR 0 1
84296: PUSH
84297: LD_INT 4
84299: MINUS
84300: PUSH
84301: LD_VAR 0 2
84305: PUSH
84306: LD_INT 1
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: LIST
84313: PUSH
84314: LD_VAR 0 1
84318: PUSH
84319: LD_VAR 0 2
84323: PUSH
84324: LD_INT 3
84326: PLUS
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: LIST
84335: PUSH
84336: LD_VAR 0 1
84340: PUSH
84341: LD_INT 4
84343: PLUS
84344: PUSH
84345: LD_VAR 0 2
84349: PUSH
84350: LD_INT 4
84352: PLUS
84353: PUSH
84354: LD_INT 5
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: ST_TO_ADDR
// end ; 2 :
84369: GO 84928
84371: LD_INT 2
84373: DOUBLE
84374: EQUAL
84375: IFTRUE 84379
84377: GO 84508
84379: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84380: LD_ADDR_VAR 0 5
84384: PUSH
84385: LD_VAR 0 1
84389: PUSH
84390: LD_VAR 0 2
84394: PUSH
84395: LD_INT 3
84397: MINUS
84398: PUSH
84399: LD_INT 3
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: LIST
84406: PUSH
84407: LD_VAR 0 1
84411: PUSH
84412: LD_INT 4
84414: PLUS
84415: PUSH
84416: LD_VAR 0 2
84420: PUSH
84421: LD_INT 4
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: LIST
84428: PUSH
84429: LD_VAR 0 1
84433: PUSH
84434: LD_VAR 0 2
84438: PUSH
84439: LD_INT 4
84441: PLUS
84442: PUSH
84443: LD_INT 0
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: LIST
84450: PUSH
84451: LD_VAR 0 1
84455: PUSH
84456: LD_INT 3
84458: MINUS
84459: PUSH
84460: LD_VAR 0 2
84464: PUSH
84465: LD_INT 1
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: LIST
84472: PUSH
84473: LD_VAR 0 1
84477: PUSH
84478: LD_INT 4
84480: MINUS
84481: PUSH
84482: LD_VAR 0 2
84486: PUSH
84487: LD_INT 4
84489: MINUS
84490: PUSH
84491: LD_INT 2
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: LIST
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: ST_TO_ADDR
// end ; 3 :
84506: GO 84928
84508: LD_INT 3
84510: DOUBLE
84511: EQUAL
84512: IFTRUE 84516
84514: GO 84649
84516: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84517: LD_ADDR_VAR 0 5
84521: PUSH
84522: LD_VAR 0 1
84526: PUSH
84527: LD_INT 3
84529: PLUS
84530: PUSH
84531: LD_VAR 0 2
84535: PUSH
84536: LD_INT 4
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: LIST
84543: PUSH
84544: LD_VAR 0 1
84548: PUSH
84549: LD_INT 4
84551: PLUS
84552: PUSH
84553: LD_VAR 0 2
84557: PUSH
84558: LD_INT 4
84560: PLUS
84561: PUSH
84562: LD_INT 5
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: LIST
84569: PUSH
84570: LD_VAR 0 1
84574: PUSH
84575: LD_INT 4
84577: MINUS
84578: PUSH
84579: LD_VAR 0 2
84583: PUSH
84584: LD_INT 1
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: LIST
84591: PUSH
84592: LD_VAR 0 1
84596: PUSH
84597: LD_VAR 0 2
84601: PUSH
84602: LD_INT 4
84604: MINUS
84605: PUSH
84606: LD_INT 3
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: LIST
84613: PUSH
84614: LD_VAR 0 1
84618: PUSH
84619: LD_INT 3
84621: MINUS
84622: PUSH
84623: LD_VAR 0 2
84627: PUSH
84628: LD_INT 3
84630: MINUS
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: LIST
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: ST_TO_ADDR
// end ; 4 :
84647: GO 84928
84649: LD_INT 4
84651: DOUBLE
84652: EQUAL
84653: IFTRUE 84657
84655: GO 84790
84657: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84658: LD_ADDR_VAR 0 5
84662: PUSH
84663: LD_VAR 0 1
84667: PUSH
84668: LD_VAR 0 2
84672: PUSH
84673: LD_INT 4
84675: PLUS
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: LIST
84684: PUSH
84685: LD_VAR 0 1
84689: PUSH
84690: LD_INT 3
84692: PLUS
84693: PUSH
84694: LD_VAR 0 2
84698: PUSH
84699: LD_INT 3
84701: PLUS
84702: PUSH
84703: LD_INT 5
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: LIST
84710: PUSH
84711: LD_VAR 0 1
84715: PUSH
84716: LD_INT 4
84718: PLUS
84719: PUSH
84720: LD_VAR 0 2
84724: PUSH
84725: LD_INT 4
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: LIST
84732: PUSH
84733: LD_VAR 0 1
84737: PUSH
84738: LD_VAR 0 2
84742: PUSH
84743: LD_INT 3
84745: MINUS
84746: PUSH
84747: LD_INT 3
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: LIST
84754: PUSH
84755: LD_VAR 0 1
84759: PUSH
84760: LD_INT 4
84762: MINUS
84763: PUSH
84764: LD_VAR 0 2
84768: PUSH
84769: LD_INT 4
84771: MINUS
84772: PUSH
84773: LD_INT 2
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: LIST
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: ST_TO_ADDR
// end ; 5 :
84788: GO 84928
84790: LD_INT 5
84792: DOUBLE
84793: EQUAL
84794: IFTRUE 84798
84796: GO 84927
84798: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84799: LD_ADDR_VAR 0 5
84803: PUSH
84804: LD_VAR 0 1
84808: PUSH
84809: LD_INT 4
84811: MINUS
84812: PUSH
84813: LD_VAR 0 2
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: LIST
84825: PUSH
84826: LD_VAR 0 1
84830: PUSH
84831: LD_VAR 0 2
84835: PUSH
84836: LD_INT 4
84838: MINUS
84839: PUSH
84840: LD_INT 3
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: LIST
84847: PUSH
84848: LD_VAR 0 1
84852: PUSH
84853: LD_INT 4
84855: PLUS
84856: PUSH
84857: LD_VAR 0 2
84861: PUSH
84862: LD_INT 4
84864: PLUS
84865: PUSH
84866: LD_INT 5
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: LIST
84873: PUSH
84874: LD_VAR 0 1
84878: PUSH
84879: LD_INT 3
84881: PLUS
84882: PUSH
84883: LD_VAR 0 2
84887: PUSH
84888: LD_INT 4
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: LIST
84895: PUSH
84896: LD_VAR 0 1
84900: PUSH
84901: LD_VAR 0 2
84905: PUSH
84906: LD_INT 3
84908: PLUS
84909: PUSH
84910: LD_INT 0
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: LIST
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: ST_TO_ADDR
// end ; end ;
84925: GO 84928
84927: POP
// result := list ;
84928: LD_ADDR_VAR 0 4
84932: PUSH
84933: LD_VAR 0 5
84937: ST_TO_ADDR
// end ;
84938: LD_VAR 0 4
84942: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84943: LD_INT 0
84945: PPUSH
84946: PPUSH
84947: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84948: LD_VAR 0 1
84952: NOT
84953: PUSH
84954: LD_VAR 0 2
84958: PUSH
84959: LD_INT 1
84961: PUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 3
84967: PUSH
84968: LD_INT 4
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: IN
84977: NOT
84978: OR
84979: IFFALSE 84983
// exit ;
84981: GO 85066
// tmp := [ ] ;
84983: LD_ADDR_VAR 0 5
84987: PUSH
84988: EMPTY
84989: ST_TO_ADDR
// for i in units do
84990: LD_ADDR_VAR 0 4
84994: PUSH
84995: LD_VAR 0 1
84999: PUSH
85000: FOR_IN
85001: IFFALSE 85035
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85003: LD_ADDR_VAR 0 5
85007: PUSH
85008: LD_VAR 0 5
85012: PPUSH
85013: LD_VAR 0 4
85017: PPUSH
85018: LD_VAR 0 2
85022: PPUSH
85023: CALL_OW 259
85027: PPUSH
85028: CALL 86426 0 2
85032: ST_TO_ADDR
85033: GO 85000
85035: POP
85036: POP
// if not tmp then
85037: LD_VAR 0 5
85041: NOT
85042: IFFALSE 85046
// exit ;
85044: GO 85066
// result := SortListByListDesc ( units , tmp ) ;
85046: LD_ADDR_VAR 0 3
85050: PUSH
85051: LD_VAR 0 1
85055: PPUSH
85056: LD_VAR 0 5
85060: PPUSH
85061: CALL_OW 77
85065: ST_TO_ADDR
// end ;
85066: LD_VAR 0 3
85070: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85071: LD_INT 0
85073: PPUSH
85074: PPUSH
85075: PPUSH
// result := false ;
85076: LD_ADDR_VAR 0 3
85080: PUSH
85081: LD_INT 0
85083: ST_TO_ADDR
// if not building then
85084: LD_VAR 0 2
85088: NOT
85089: IFFALSE 85093
// exit ;
85091: GO 85231
// x := GetX ( building ) ;
85093: LD_ADDR_VAR 0 4
85097: PUSH
85098: LD_VAR 0 2
85102: PPUSH
85103: CALL_OW 250
85107: ST_TO_ADDR
// y := GetY ( building ) ;
85108: LD_ADDR_VAR 0 5
85112: PUSH
85113: LD_VAR 0 2
85117: PPUSH
85118: CALL_OW 251
85122: ST_TO_ADDR
// if not x or not y then
85123: LD_VAR 0 4
85127: NOT
85128: PUSH
85129: LD_VAR 0 5
85133: NOT
85134: OR
85135: IFFALSE 85139
// exit ;
85137: GO 85231
// if GetTaskList ( unit ) then
85139: LD_VAR 0 1
85143: PPUSH
85144: CALL_OW 437
85148: IFFALSE 85231
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85150: LD_STRING e
85152: PUSH
85153: LD_VAR 0 1
85157: PPUSH
85158: CALL_OW 437
85162: PUSH
85163: LD_INT 1
85165: ARRAY
85166: PUSH
85167: LD_INT 1
85169: ARRAY
85170: EQUAL
85171: PUSH
85172: LD_VAR 0 4
85176: PUSH
85177: LD_VAR 0 1
85181: PPUSH
85182: CALL_OW 437
85186: PUSH
85187: LD_INT 1
85189: ARRAY
85190: PUSH
85191: LD_INT 2
85193: ARRAY
85194: EQUAL
85195: AND
85196: PUSH
85197: LD_VAR 0 5
85201: PUSH
85202: LD_VAR 0 1
85206: PPUSH
85207: CALL_OW 437
85211: PUSH
85212: LD_INT 1
85214: ARRAY
85215: PUSH
85216: LD_INT 3
85218: ARRAY
85219: EQUAL
85220: AND
85221: IFFALSE 85231
// result := true end ;
85223: LD_ADDR_VAR 0 3
85227: PUSH
85228: LD_INT 1
85230: ST_TO_ADDR
// end ;
85231: LD_VAR 0 3
85235: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85236: LD_INT 0
85238: PPUSH
// result := false ;
85239: LD_ADDR_VAR 0 4
85243: PUSH
85244: LD_INT 0
85246: ST_TO_ADDR
// if GetTaskList ( unit ) then
85247: LD_VAR 0 1
85251: PPUSH
85252: CALL_OW 437
85256: IFFALSE 85339
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85258: LD_STRING M
85260: PUSH
85261: LD_VAR 0 1
85265: PPUSH
85266: CALL_OW 437
85270: PUSH
85271: LD_INT 1
85273: ARRAY
85274: PUSH
85275: LD_INT 1
85277: ARRAY
85278: EQUAL
85279: PUSH
85280: LD_VAR 0 2
85284: PUSH
85285: LD_VAR 0 1
85289: PPUSH
85290: CALL_OW 437
85294: PUSH
85295: LD_INT 1
85297: ARRAY
85298: PUSH
85299: LD_INT 2
85301: ARRAY
85302: EQUAL
85303: AND
85304: PUSH
85305: LD_VAR 0 3
85309: PUSH
85310: LD_VAR 0 1
85314: PPUSH
85315: CALL_OW 437
85319: PUSH
85320: LD_INT 1
85322: ARRAY
85323: PUSH
85324: LD_INT 3
85326: ARRAY
85327: EQUAL
85328: AND
85329: IFFALSE 85339
// result := true ;
85331: LD_ADDR_VAR 0 4
85335: PUSH
85336: LD_INT 1
85338: ST_TO_ADDR
// end ; end ;
85339: LD_VAR 0 4
85343: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85344: LD_INT 0
85346: PPUSH
85347: PPUSH
85348: PPUSH
85349: PPUSH
// if not unit or not area then
85350: LD_VAR 0 1
85354: NOT
85355: PUSH
85356: LD_VAR 0 2
85360: NOT
85361: OR
85362: IFFALSE 85366
// exit ;
85364: GO 85529
// tmp := AreaToList ( area , i ) ;
85366: LD_ADDR_VAR 0 6
85370: PUSH
85371: LD_VAR 0 2
85375: PPUSH
85376: LD_VAR 0 5
85380: PPUSH
85381: CALL_OW 517
85385: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85386: LD_ADDR_VAR 0 5
85390: PUSH
85391: DOUBLE
85392: LD_INT 1
85394: DEC
85395: ST_TO_ADDR
85396: LD_VAR 0 6
85400: PUSH
85401: LD_INT 1
85403: ARRAY
85404: PUSH
85405: FOR_TO
85406: IFFALSE 85527
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85408: LD_ADDR_VAR 0 7
85412: PUSH
85413: LD_VAR 0 6
85417: PUSH
85418: LD_INT 1
85420: ARRAY
85421: PUSH
85422: LD_VAR 0 5
85426: ARRAY
85427: PUSH
85428: LD_VAR 0 6
85432: PUSH
85433: LD_INT 2
85435: ARRAY
85436: PUSH
85437: LD_VAR 0 5
85441: ARRAY
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
85447: LD_INT 92
85449: PUSH
85450: LD_VAR 0 7
85454: PUSH
85455: LD_INT 1
85457: ARRAY
85458: PUSH
85459: LD_VAR 0 7
85463: PUSH
85464: LD_INT 2
85466: ARRAY
85467: PUSH
85468: LD_INT 3
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: PPUSH
85477: CALL_OW 69
85481: PUSH
85482: LD_INT 0
85484: EQUAL
85485: IFFALSE 85525
// begin PlaceUnitArea ( unit , area , mode ) ;
85487: LD_VAR 0 1
85491: PPUSH
85492: LD_VAR 0 2
85496: PPUSH
85497: LD_VAR 0 3
85501: PPUSH
85502: CALL_OW 49
// result := IsPlaced ( unit ) ;
85506: LD_ADDR_VAR 0 4
85510: PUSH
85511: LD_VAR 0 1
85515: PPUSH
85516: CALL_OW 305
85520: ST_TO_ADDR
// exit ;
85521: POP
85522: POP
85523: GO 85529
// end ; end ;
85525: GO 85405
85527: POP
85528: POP
// end ;
85529: LD_VAR 0 4
85533: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85534: LD_INT 0
85536: PPUSH
85537: PPUSH
85538: PPUSH
// if not side or side > 8 then
85539: LD_VAR 0 1
85543: NOT
85544: PUSH
85545: LD_VAR 0 1
85549: PUSH
85550: LD_INT 8
85552: GREATER
85553: OR
85554: IFFALSE 85558
// exit ;
85556: GO 85745
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85558: LD_ADDR_VAR 0 4
85562: PUSH
85563: LD_INT 22
85565: PUSH
85566: LD_VAR 0 1
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 21
85577: PUSH
85578: LD_INT 3
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PPUSH
85589: CALL_OW 69
85593: ST_TO_ADDR
// if not tmp then
85594: LD_VAR 0 4
85598: NOT
85599: IFFALSE 85603
// exit ;
85601: GO 85745
// enable_addtolog := true ;
85603: LD_ADDR_OWVAR 81
85607: PUSH
85608: LD_INT 1
85610: ST_TO_ADDR
// AddToLog ( [ ) ;
85611: LD_STRING [
85613: PPUSH
85614: CALL_OW 561
// for i in tmp do
85618: LD_ADDR_VAR 0 3
85622: PUSH
85623: LD_VAR 0 4
85627: PUSH
85628: FOR_IN
85629: IFFALSE 85736
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85631: LD_STRING [
85633: PUSH
85634: LD_VAR 0 3
85638: PPUSH
85639: CALL_OW 266
85643: STR
85644: PUSH
85645: LD_STRING , 
85647: STR
85648: PUSH
85649: LD_VAR 0 3
85653: PPUSH
85654: CALL_OW 250
85658: STR
85659: PUSH
85660: LD_STRING , 
85662: STR
85663: PUSH
85664: LD_VAR 0 3
85668: PPUSH
85669: CALL_OW 251
85673: STR
85674: PUSH
85675: LD_STRING , 
85677: STR
85678: PUSH
85679: LD_VAR 0 3
85683: PPUSH
85684: CALL_OW 254
85688: STR
85689: PUSH
85690: LD_STRING , 
85692: STR
85693: PUSH
85694: LD_VAR 0 3
85698: PPUSH
85699: LD_INT 1
85701: PPUSH
85702: CALL_OW 268
85706: STR
85707: PUSH
85708: LD_STRING , 
85710: STR
85711: PUSH
85712: LD_VAR 0 3
85716: PPUSH
85717: LD_INT 2
85719: PPUSH
85720: CALL_OW 268
85724: STR
85725: PUSH
85726: LD_STRING ],
85728: STR
85729: PPUSH
85730: CALL_OW 561
// end ;
85734: GO 85628
85736: POP
85737: POP
// AddToLog ( ]; ) ;
85738: LD_STRING ];
85740: PPUSH
85741: CALL_OW 561
// end ;
85745: LD_VAR 0 2
85749: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85750: LD_INT 0
85752: PPUSH
85753: PPUSH
85754: PPUSH
85755: PPUSH
85756: PPUSH
// if not area or not rate or not max then
85757: LD_VAR 0 1
85761: NOT
85762: PUSH
85763: LD_VAR 0 2
85767: NOT
85768: OR
85769: PUSH
85770: LD_VAR 0 4
85774: NOT
85775: OR
85776: IFFALSE 85780
// exit ;
85778: GO 85969
// while 1 do
85780: LD_INT 1
85782: IFFALSE 85969
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85784: LD_ADDR_VAR 0 9
85788: PUSH
85789: LD_VAR 0 1
85793: PPUSH
85794: LD_INT 1
85796: PPUSH
85797: CALL_OW 287
85801: PUSH
85802: LD_INT 10
85804: MUL
85805: ST_TO_ADDR
// r := rate / 10 ;
85806: LD_ADDR_VAR 0 7
85810: PUSH
85811: LD_VAR 0 2
85815: PUSH
85816: LD_INT 10
85818: DIVREAL
85819: ST_TO_ADDR
// time := 1 1$00 ;
85820: LD_ADDR_VAR 0 8
85824: PUSH
85825: LD_INT 2100
85827: ST_TO_ADDR
// if amount < min then
85828: LD_VAR 0 9
85832: PUSH
85833: LD_VAR 0 3
85837: LESS
85838: IFFALSE 85856
// r := r * 2 else
85840: LD_ADDR_VAR 0 7
85844: PUSH
85845: LD_VAR 0 7
85849: PUSH
85850: LD_INT 2
85852: MUL
85853: ST_TO_ADDR
85854: GO 85882
// if amount > max then
85856: LD_VAR 0 9
85860: PUSH
85861: LD_VAR 0 4
85865: GREATER
85866: IFFALSE 85882
// r := r / 2 ;
85868: LD_ADDR_VAR 0 7
85872: PUSH
85873: LD_VAR 0 7
85877: PUSH
85878: LD_INT 2
85880: DIVREAL
85881: ST_TO_ADDR
// time := time / r ;
85882: LD_ADDR_VAR 0 8
85886: PUSH
85887: LD_VAR 0 8
85891: PUSH
85892: LD_VAR 0 7
85896: DIVREAL
85897: ST_TO_ADDR
// if time < 0 then
85898: LD_VAR 0 8
85902: PUSH
85903: LD_INT 0
85905: LESS
85906: IFFALSE 85923
// time := time * - 1 ;
85908: LD_ADDR_VAR 0 8
85912: PUSH
85913: LD_VAR 0 8
85917: PUSH
85918: LD_INT 1
85920: NEG
85921: MUL
85922: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85923: LD_VAR 0 8
85927: PUSH
85928: LD_INT 35
85930: PPUSH
85931: LD_INT 875
85933: PPUSH
85934: CALL_OW 12
85938: PLUS
85939: PPUSH
85940: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85944: LD_INT 1
85946: PPUSH
85947: LD_INT 5
85949: PPUSH
85950: CALL_OW 12
85954: PPUSH
85955: LD_VAR 0 1
85959: PPUSH
85960: LD_INT 1
85962: PPUSH
85963: CALL_OW 55
// end ;
85967: GO 85780
// end ;
85969: LD_VAR 0 5
85973: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85974: LD_INT 0
85976: PPUSH
85977: PPUSH
85978: PPUSH
85979: PPUSH
85980: PPUSH
85981: PPUSH
85982: PPUSH
85983: PPUSH
// if not turrets or not factories then
85984: LD_VAR 0 1
85988: NOT
85989: PUSH
85990: LD_VAR 0 2
85994: NOT
85995: OR
85996: IFFALSE 86000
// exit ;
85998: GO 86307
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86000: LD_ADDR_VAR 0 10
86004: PUSH
86005: LD_INT 5
86007: PUSH
86008: LD_INT 6
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: LD_INT 4
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 3
86027: PUSH
86028: LD_INT 5
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 24
86042: PUSH
86043: LD_INT 25
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 23
86052: PUSH
86053: LD_INT 27
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 42
86066: PUSH
86067: LD_INT 43
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 44
86076: PUSH
86077: LD_INT 46
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 45
86086: PUSH
86087: LD_INT 47
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: LIST
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: LIST
86103: ST_TO_ADDR
// result := [ ] ;
86104: LD_ADDR_VAR 0 3
86108: PUSH
86109: EMPTY
86110: ST_TO_ADDR
// for i in turrets do
86111: LD_ADDR_VAR 0 4
86115: PUSH
86116: LD_VAR 0 1
86120: PUSH
86121: FOR_IN
86122: IFFALSE 86305
// begin nat := GetNation ( i ) ;
86124: LD_ADDR_VAR 0 7
86128: PUSH
86129: LD_VAR 0 4
86133: PPUSH
86134: CALL_OW 248
86138: ST_TO_ADDR
// weapon := 0 ;
86139: LD_ADDR_VAR 0 8
86143: PUSH
86144: LD_INT 0
86146: ST_TO_ADDR
// if not nat then
86147: LD_VAR 0 7
86151: NOT
86152: IFFALSE 86156
// continue ;
86154: GO 86121
// for j in list [ nat ] do
86156: LD_ADDR_VAR 0 5
86160: PUSH
86161: LD_VAR 0 10
86165: PUSH
86166: LD_VAR 0 7
86170: ARRAY
86171: PUSH
86172: FOR_IN
86173: IFFALSE 86214
// if GetBWeapon ( i ) = j [ 1 ] then
86175: LD_VAR 0 4
86179: PPUSH
86180: CALL_OW 269
86184: PUSH
86185: LD_VAR 0 5
86189: PUSH
86190: LD_INT 1
86192: ARRAY
86193: EQUAL
86194: IFFALSE 86212
// begin weapon := j [ 2 ] ;
86196: LD_ADDR_VAR 0 8
86200: PUSH
86201: LD_VAR 0 5
86205: PUSH
86206: LD_INT 2
86208: ARRAY
86209: ST_TO_ADDR
// break ;
86210: GO 86214
// end ;
86212: GO 86172
86214: POP
86215: POP
// if not weapon then
86216: LD_VAR 0 8
86220: NOT
86221: IFFALSE 86225
// continue ;
86223: GO 86121
// for k in factories do
86225: LD_ADDR_VAR 0 6
86229: PUSH
86230: LD_VAR 0 2
86234: PUSH
86235: FOR_IN
86236: IFFALSE 86301
// begin weapons := AvailableWeaponList ( k ) ;
86238: LD_ADDR_VAR 0 9
86242: PUSH
86243: LD_VAR 0 6
86247: PPUSH
86248: CALL_OW 478
86252: ST_TO_ADDR
// if not weapons then
86253: LD_VAR 0 9
86257: NOT
86258: IFFALSE 86262
// continue ;
86260: GO 86235
// if weapon in weapons then
86262: LD_VAR 0 8
86266: PUSH
86267: LD_VAR 0 9
86271: IN
86272: IFFALSE 86299
// begin result := [ i , weapon ] ;
86274: LD_ADDR_VAR 0 3
86278: PUSH
86279: LD_VAR 0 4
86283: PUSH
86284: LD_VAR 0 8
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: ST_TO_ADDR
// exit ;
86293: POP
86294: POP
86295: POP
86296: POP
86297: GO 86307
// end ; end ;
86299: GO 86235
86301: POP
86302: POP
// end ;
86303: GO 86121
86305: POP
86306: POP
// end ;
86307: LD_VAR 0 3
86311: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86312: LD_INT 0
86314: PPUSH
// if not side or side > 8 then
86315: LD_VAR 0 3
86319: NOT
86320: PUSH
86321: LD_VAR 0 3
86325: PUSH
86326: LD_INT 8
86328: GREATER
86329: OR
86330: IFFALSE 86334
// exit ;
86332: GO 86393
// if not range then
86334: LD_VAR 0 4
86338: NOT
86339: IFFALSE 86350
// range := - 12 ;
86341: LD_ADDR_VAR 0 4
86345: PUSH
86346: LD_INT 12
86348: NEG
86349: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86350: LD_VAR 0 1
86354: PPUSH
86355: LD_VAR 0 2
86359: PPUSH
86360: LD_VAR 0 3
86364: PPUSH
86365: LD_VAR 0 4
86369: PPUSH
86370: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86374: LD_VAR 0 1
86378: PPUSH
86379: LD_VAR 0 2
86383: PPUSH
86384: LD_VAR 0 3
86388: PPUSH
86389: CALL_OW 331
// end ;
86393: LD_VAR 0 5
86397: RET
// export function Video ( mode ) ; begin
86398: LD_INT 0
86400: PPUSH
// ingame_video = mode ;
86401: LD_ADDR_OWVAR 52
86405: PUSH
86406: LD_VAR 0 1
86410: ST_TO_ADDR
// interface_hidden = mode ;
86411: LD_ADDR_OWVAR 54
86415: PUSH
86416: LD_VAR 0 1
86420: ST_TO_ADDR
// end ;
86421: LD_VAR 0 2
86425: RET
// export function Join ( array , element ) ; begin
86426: LD_INT 0
86428: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86429: LD_ADDR_VAR 0 3
86433: PUSH
86434: LD_VAR 0 1
86438: PPUSH
86439: LD_VAR 0 1
86443: PUSH
86444: LD_INT 1
86446: PLUS
86447: PPUSH
86448: LD_VAR 0 2
86452: PPUSH
86453: CALL_OW 1
86457: ST_TO_ADDR
// end ;
86458: LD_VAR 0 3
86462: RET
// export function JoinUnion ( array , element ) ; begin
86463: LD_INT 0
86465: PPUSH
// result := array union element ;
86466: LD_ADDR_VAR 0 3
86470: PUSH
86471: LD_VAR 0 1
86475: PUSH
86476: LD_VAR 0 2
86480: UNION
86481: ST_TO_ADDR
// end ;
86482: LD_VAR 0 3
86486: RET
// export function GetBehemoths ( side ) ; begin
86487: LD_INT 0
86489: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86490: LD_ADDR_VAR 0 2
86494: PUSH
86495: LD_INT 22
86497: PUSH
86498: LD_VAR 0 1
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 31
86509: PUSH
86510: LD_INT 25
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PPUSH
86521: CALL_OW 69
86525: ST_TO_ADDR
// end ;
86526: LD_VAR 0 2
86530: RET
// export function Shuffle ( array ) ; var i , index ; begin
86531: LD_INT 0
86533: PPUSH
86534: PPUSH
86535: PPUSH
// result := [ ] ;
86536: LD_ADDR_VAR 0 2
86540: PUSH
86541: EMPTY
86542: ST_TO_ADDR
// if not array then
86543: LD_VAR 0 1
86547: NOT
86548: IFFALSE 86552
// exit ;
86550: GO 86651
// Randomize ;
86552: CALL_OW 10
// for i = array downto 1 do
86556: LD_ADDR_VAR 0 3
86560: PUSH
86561: DOUBLE
86562: LD_VAR 0 1
86566: INC
86567: ST_TO_ADDR
86568: LD_INT 1
86570: PUSH
86571: FOR_DOWNTO
86572: IFFALSE 86649
// begin index := rand ( 1 , array ) ;
86574: LD_ADDR_VAR 0 4
86578: PUSH
86579: LD_INT 1
86581: PPUSH
86582: LD_VAR 0 1
86586: PPUSH
86587: CALL_OW 12
86591: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86592: LD_ADDR_VAR 0 2
86596: PUSH
86597: LD_VAR 0 2
86601: PPUSH
86602: LD_VAR 0 2
86606: PUSH
86607: LD_INT 1
86609: PLUS
86610: PPUSH
86611: LD_VAR 0 1
86615: PUSH
86616: LD_VAR 0 4
86620: ARRAY
86621: PPUSH
86622: CALL_OW 2
86626: ST_TO_ADDR
// array := Delete ( array , index ) ;
86627: LD_ADDR_VAR 0 1
86631: PUSH
86632: LD_VAR 0 1
86636: PPUSH
86637: LD_VAR 0 4
86641: PPUSH
86642: CALL_OW 3
86646: ST_TO_ADDR
// end ;
86647: GO 86571
86649: POP
86650: POP
// end ;
86651: LD_VAR 0 2
86655: RET
// export function GetBaseMaterials ( base ) ; begin
86656: LD_INT 0
86658: PPUSH
// result := [ 0 , 0 , 0 ] ;
86659: LD_ADDR_VAR 0 2
86663: PUSH
86664: LD_INT 0
86666: PUSH
86667: LD_INT 0
86669: PUSH
86670: LD_INT 0
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: LIST
86677: ST_TO_ADDR
// if not base then
86678: LD_VAR 0 1
86682: NOT
86683: IFFALSE 86687
// exit ;
86685: GO 86736
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86687: LD_ADDR_VAR 0 2
86691: PUSH
86692: LD_VAR 0 1
86696: PPUSH
86697: LD_INT 1
86699: PPUSH
86700: CALL_OW 275
86704: PUSH
86705: LD_VAR 0 1
86709: PPUSH
86710: LD_INT 2
86712: PPUSH
86713: CALL_OW 275
86717: PUSH
86718: LD_VAR 0 1
86722: PPUSH
86723: LD_INT 3
86725: PPUSH
86726: CALL_OW 275
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: LIST
86735: ST_TO_ADDR
// end ;
86736: LD_VAR 0 2
86740: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86741: LD_INT 0
86743: PPUSH
86744: PPUSH
// result := array ;
86745: LD_ADDR_VAR 0 3
86749: PUSH
86750: LD_VAR 0 1
86754: ST_TO_ADDR
// if size >= result then
86755: LD_VAR 0 2
86759: PUSH
86760: LD_VAR 0 3
86764: GREATEREQUAL
86765: IFFALSE 86769
// exit ;
86767: GO 86819
// if size then
86769: LD_VAR 0 2
86773: IFFALSE 86819
// for i := array downto size do
86775: LD_ADDR_VAR 0 4
86779: PUSH
86780: DOUBLE
86781: LD_VAR 0 1
86785: INC
86786: ST_TO_ADDR
86787: LD_VAR 0 2
86791: PUSH
86792: FOR_DOWNTO
86793: IFFALSE 86817
// result := Delete ( result , result ) ;
86795: LD_ADDR_VAR 0 3
86799: PUSH
86800: LD_VAR 0 3
86804: PPUSH
86805: LD_VAR 0 3
86809: PPUSH
86810: CALL_OW 3
86814: ST_TO_ADDR
86815: GO 86792
86817: POP
86818: POP
// end ;
86819: LD_VAR 0 3
86823: RET
// export function ComExit ( unit ) ; var tmp ; begin
86824: LD_INT 0
86826: PPUSH
86827: PPUSH
// if not IsInUnit ( unit ) then
86828: LD_VAR 0 1
86832: PPUSH
86833: CALL_OW 310
86837: NOT
86838: IFFALSE 86842
// exit ;
86840: GO 86902
// tmp := IsInUnit ( unit ) ;
86842: LD_ADDR_VAR 0 3
86846: PUSH
86847: LD_VAR 0 1
86851: PPUSH
86852: CALL_OW 310
86856: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86857: LD_VAR 0 3
86861: PPUSH
86862: CALL_OW 247
86866: PUSH
86867: LD_INT 2
86869: EQUAL
86870: IFFALSE 86883
// ComExitVehicle ( unit ) else
86872: LD_VAR 0 1
86876: PPUSH
86877: CALL_OW 121
86881: GO 86892
// ComExitBuilding ( unit ) ;
86883: LD_VAR 0 1
86887: PPUSH
86888: CALL_OW 122
// result := tmp ;
86892: LD_ADDR_VAR 0 2
86896: PUSH
86897: LD_VAR 0 3
86901: ST_TO_ADDR
// end ;
86902: LD_VAR 0 2
86906: RET
// export function ComExitAll ( units ) ; var i ; begin
86907: LD_INT 0
86909: PPUSH
86910: PPUSH
// if not units then
86911: LD_VAR 0 1
86915: NOT
86916: IFFALSE 86920
// exit ;
86918: GO 86946
// for i in units do
86920: LD_ADDR_VAR 0 3
86924: PUSH
86925: LD_VAR 0 1
86929: PUSH
86930: FOR_IN
86931: IFFALSE 86944
// ComExit ( i ) ;
86933: LD_VAR 0 3
86937: PPUSH
86938: CALL 86824 0 1
86942: GO 86930
86944: POP
86945: POP
// end ;
86946: LD_VAR 0 2
86950: RET
// export function ResetHc ; begin
86951: LD_INT 0
86953: PPUSH
// InitHc ;
86954: CALL_OW 19
// hc_importance := 0 ;
86958: LD_ADDR_OWVAR 32
86962: PUSH
86963: LD_INT 0
86965: ST_TO_ADDR
// end ;
86966: LD_VAR 0 1
86970: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86971: LD_INT 0
86973: PPUSH
86974: PPUSH
86975: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86976: LD_ADDR_VAR 0 6
86980: PUSH
86981: LD_VAR 0 1
86985: PUSH
86986: LD_VAR 0 3
86990: PLUS
86991: PUSH
86992: LD_INT 2
86994: DIV
86995: ST_TO_ADDR
// if _x < 0 then
86996: LD_VAR 0 6
87000: PUSH
87001: LD_INT 0
87003: LESS
87004: IFFALSE 87021
// _x := _x * - 1 ;
87006: LD_ADDR_VAR 0 6
87010: PUSH
87011: LD_VAR 0 6
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: MUL
87020: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87021: LD_ADDR_VAR 0 7
87025: PUSH
87026: LD_VAR 0 2
87030: PUSH
87031: LD_VAR 0 4
87035: PLUS
87036: PUSH
87037: LD_INT 2
87039: DIV
87040: ST_TO_ADDR
// if _y < 0 then
87041: LD_VAR 0 7
87045: PUSH
87046: LD_INT 0
87048: LESS
87049: IFFALSE 87066
// _y := _y * - 1 ;
87051: LD_ADDR_VAR 0 7
87055: PUSH
87056: LD_VAR 0 7
87060: PUSH
87061: LD_INT 1
87063: NEG
87064: MUL
87065: ST_TO_ADDR
// result := [ _x , _y ] ;
87066: LD_ADDR_VAR 0 5
87070: PUSH
87071: LD_VAR 0 6
87075: PUSH
87076: LD_VAR 0 7
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: ST_TO_ADDR
// end ;
87085: LD_VAR 0 5
87089: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87090: LD_INT 0
87092: PPUSH
87093: PPUSH
87094: PPUSH
87095: PPUSH
// task := GetTaskList ( unit ) ;
87096: LD_ADDR_VAR 0 7
87100: PUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: CALL_OW 437
87110: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87111: LD_VAR 0 7
87115: NOT
87116: PUSH
87117: LD_VAR 0 1
87121: PPUSH
87122: LD_VAR 0 2
87126: PPUSH
87127: CALL_OW 308
87131: NOT
87132: AND
87133: IFFALSE 87137
// exit ;
87135: GO 87255
// if IsInArea ( unit , area ) then
87137: LD_VAR 0 1
87141: PPUSH
87142: LD_VAR 0 2
87146: PPUSH
87147: CALL_OW 308
87151: IFFALSE 87169
// begin ComMoveToArea ( unit , goAway ) ;
87153: LD_VAR 0 1
87157: PPUSH
87158: LD_VAR 0 3
87162: PPUSH
87163: CALL_OW 113
// exit ;
87167: GO 87255
// end ; if task [ 1 ] [ 1 ] <> M then
87169: LD_VAR 0 7
87173: PUSH
87174: LD_INT 1
87176: ARRAY
87177: PUSH
87178: LD_INT 1
87180: ARRAY
87181: PUSH
87182: LD_STRING M
87184: NONEQUAL
87185: IFFALSE 87189
// exit ;
87187: GO 87255
// x := task [ 1 ] [ 2 ] ;
87189: LD_ADDR_VAR 0 5
87193: PUSH
87194: LD_VAR 0 7
87198: PUSH
87199: LD_INT 1
87201: ARRAY
87202: PUSH
87203: LD_INT 2
87205: ARRAY
87206: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87207: LD_ADDR_VAR 0 6
87211: PUSH
87212: LD_VAR 0 7
87216: PUSH
87217: LD_INT 1
87219: ARRAY
87220: PUSH
87221: LD_INT 3
87223: ARRAY
87224: ST_TO_ADDR
// if InArea ( x , y , area ) then
87225: LD_VAR 0 5
87229: PPUSH
87230: LD_VAR 0 6
87234: PPUSH
87235: LD_VAR 0 2
87239: PPUSH
87240: CALL_OW 309
87244: IFFALSE 87255
// ComStop ( unit ) ;
87246: LD_VAR 0 1
87250: PPUSH
87251: CALL_OW 141
// end ;
87255: LD_VAR 0 4
87259: RET
// export function Abs ( value ) ; begin
87260: LD_INT 0
87262: PPUSH
// result := value ;
87263: LD_ADDR_VAR 0 2
87267: PUSH
87268: LD_VAR 0 1
87272: ST_TO_ADDR
// if value < 0 then
87273: LD_VAR 0 1
87277: PUSH
87278: LD_INT 0
87280: LESS
87281: IFFALSE 87298
// result := value * - 1 ;
87283: LD_ADDR_VAR 0 2
87287: PUSH
87288: LD_VAR 0 1
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: MUL
87297: ST_TO_ADDR
// end ;
87298: LD_VAR 0 2
87302: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87303: LD_INT 0
87305: PPUSH
87306: PPUSH
87307: PPUSH
87308: PPUSH
87309: PPUSH
87310: PPUSH
87311: PPUSH
87312: PPUSH
// if not unit or not building then
87313: LD_VAR 0 1
87317: NOT
87318: PUSH
87319: LD_VAR 0 2
87323: NOT
87324: OR
87325: IFFALSE 87329
// exit ;
87327: GO 87555
// x := GetX ( building ) ;
87329: LD_ADDR_VAR 0 4
87333: PUSH
87334: LD_VAR 0 2
87338: PPUSH
87339: CALL_OW 250
87343: ST_TO_ADDR
// y := GetY ( building ) ;
87344: LD_ADDR_VAR 0 6
87348: PUSH
87349: LD_VAR 0 2
87353: PPUSH
87354: CALL_OW 251
87358: ST_TO_ADDR
// d := GetDir ( building ) ;
87359: LD_ADDR_VAR 0 8
87363: PUSH
87364: LD_VAR 0 2
87368: PPUSH
87369: CALL_OW 254
87373: ST_TO_ADDR
// r := 4 ;
87374: LD_ADDR_VAR 0 9
87378: PUSH
87379: LD_INT 4
87381: ST_TO_ADDR
// for i := 1 to 5 do
87382: LD_ADDR_VAR 0 10
87386: PUSH
87387: DOUBLE
87388: LD_INT 1
87390: DEC
87391: ST_TO_ADDR
87392: LD_INT 5
87394: PUSH
87395: FOR_TO
87396: IFFALSE 87553
// begin _x := ShiftX ( x , d , r + i ) ;
87398: LD_ADDR_VAR 0 5
87402: PUSH
87403: LD_VAR 0 4
87407: PPUSH
87408: LD_VAR 0 8
87412: PPUSH
87413: LD_VAR 0 9
87417: PUSH
87418: LD_VAR 0 10
87422: PLUS
87423: PPUSH
87424: CALL_OW 272
87428: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87429: LD_ADDR_VAR 0 7
87433: PUSH
87434: LD_VAR 0 6
87438: PPUSH
87439: LD_VAR 0 8
87443: PPUSH
87444: LD_VAR 0 9
87448: PUSH
87449: LD_VAR 0 10
87453: PLUS
87454: PPUSH
87455: CALL_OW 273
87459: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87460: LD_VAR 0 5
87464: PPUSH
87465: LD_VAR 0 7
87469: PPUSH
87470: CALL_OW 488
87474: PUSH
87475: LD_VAR 0 5
87479: PPUSH
87480: LD_VAR 0 7
87484: PPUSH
87485: CALL_OW 428
87489: PPUSH
87490: CALL_OW 247
87494: PUSH
87495: LD_INT 3
87497: PUSH
87498: LD_INT 2
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: IN
87505: NOT
87506: AND
87507: IFFALSE 87551
// begin ComMoveXY ( unit , _x , _y ) ;
87509: LD_VAR 0 1
87513: PPUSH
87514: LD_VAR 0 5
87518: PPUSH
87519: LD_VAR 0 7
87523: PPUSH
87524: CALL_OW 111
// result := [ _x , _y ] ;
87528: LD_ADDR_VAR 0 3
87532: PUSH
87533: LD_VAR 0 5
87537: PUSH
87538: LD_VAR 0 7
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: ST_TO_ADDR
// exit ;
87547: POP
87548: POP
87549: GO 87555
// end ; end ;
87551: GO 87395
87553: POP
87554: POP
// end ;
87555: LD_VAR 0 3
87559: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87560: LD_INT 0
87562: PPUSH
87563: PPUSH
87564: PPUSH
// result := 0 ;
87565: LD_ADDR_VAR 0 3
87569: PUSH
87570: LD_INT 0
87572: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87573: LD_VAR 0 1
87577: PUSH
87578: LD_INT 0
87580: LESS
87581: PUSH
87582: LD_VAR 0 1
87586: PUSH
87587: LD_INT 8
87589: GREATER
87590: OR
87591: PUSH
87592: LD_VAR 0 2
87596: PUSH
87597: LD_INT 0
87599: LESS
87600: OR
87601: PUSH
87602: LD_VAR 0 2
87606: PUSH
87607: LD_INT 8
87609: GREATER
87610: OR
87611: IFFALSE 87615
// exit ;
87613: GO 87690
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87615: LD_ADDR_VAR 0 4
87619: PUSH
87620: LD_INT 22
87622: PUSH
87623: LD_VAR 0 2
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PPUSH
87632: CALL_OW 69
87636: PUSH
87637: FOR_IN
87638: IFFALSE 87688
// begin un := UnitShoot ( i ) ;
87640: LD_ADDR_VAR 0 5
87644: PUSH
87645: LD_VAR 0 4
87649: PPUSH
87650: CALL_OW 504
87654: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87655: LD_VAR 0 5
87659: PPUSH
87660: CALL_OW 255
87664: PUSH
87665: LD_VAR 0 1
87669: EQUAL
87670: IFFALSE 87686
// begin result := un ;
87672: LD_ADDR_VAR 0 3
87676: PUSH
87677: LD_VAR 0 5
87681: ST_TO_ADDR
// exit ;
87682: POP
87683: POP
87684: GO 87690
// end ; end ;
87686: GO 87637
87688: POP
87689: POP
// end ;
87690: LD_VAR 0 3
87694: RET
// export function GetCargoBay ( units ) ; begin
87695: LD_INT 0
87697: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87698: LD_ADDR_VAR 0 2
87702: PUSH
87703: LD_VAR 0 1
87707: PPUSH
87708: LD_INT 2
87710: PUSH
87711: LD_INT 34
87713: PUSH
87714: LD_INT 12
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 34
87723: PUSH
87724: LD_INT 51
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 34
87733: PUSH
87734: LD_INT 32
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 34
87743: PUSH
87744: LD_INT 89
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: PPUSH
87758: CALL_OW 72
87762: ST_TO_ADDR
// end ;
87763: LD_VAR 0 2
87767: RET
// export function Negate ( value ) ; begin
87768: LD_INT 0
87770: PPUSH
// result := not value ;
87771: LD_ADDR_VAR 0 2
87775: PUSH
87776: LD_VAR 0 1
87780: NOT
87781: ST_TO_ADDR
// end ;
87782: LD_VAR 0 2
87786: RET
// export function Inc ( value ) ; begin
87787: LD_INT 0
87789: PPUSH
// result := value + 1 ;
87790: LD_ADDR_VAR 0 2
87794: PUSH
87795: LD_VAR 0 1
87799: PUSH
87800: LD_INT 1
87802: PLUS
87803: ST_TO_ADDR
// end ;
87804: LD_VAR 0 2
87808: RET
// export function Dec ( value ) ; begin
87809: LD_INT 0
87811: PPUSH
// result := value - 1 ;
87812: LD_ADDR_VAR 0 2
87816: PUSH
87817: LD_VAR 0 1
87821: PUSH
87822: LD_INT 1
87824: MINUS
87825: ST_TO_ADDR
// end ;
87826: LD_VAR 0 2
87830: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87831: LD_INT 0
87833: PPUSH
87834: PPUSH
87835: PPUSH
87836: PPUSH
87837: PPUSH
87838: PPUSH
87839: PPUSH
87840: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87841: LD_VAR 0 1
87845: PPUSH
87846: LD_VAR 0 2
87850: PPUSH
87851: CALL_OW 488
87855: NOT
87856: PUSH
87857: LD_VAR 0 3
87861: PPUSH
87862: LD_VAR 0 4
87866: PPUSH
87867: CALL_OW 488
87871: NOT
87872: OR
87873: IFFALSE 87886
// begin result := - 1 ;
87875: LD_ADDR_VAR 0 5
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: ST_TO_ADDR
// exit ;
87884: GO 88121
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87886: LD_ADDR_VAR 0 12
87890: PUSH
87891: LD_VAR 0 1
87895: PPUSH
87896: LD_VAR 0 2
87900: PPUSH
87901: LD_VAR 0 3
87905: PPUSH
87906: LD_VAR 0 4
87910: PPUSH
87911: CALL 86971 0 4
87915: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87916: LD_ADDR_VAR 0 11
87920: PUSH
87921: LD_VAR 0 1
87925: PPUSH
87926: LD_VAR 0 2
87930: PPUSH
87931: LD_VAR 0 12
87935: PUSH
87936: LD_INT 1
87938: ARRAY
87939: PPUSH
87940: LD_VAR 0 12
87944: PUSH
87945: LD_INT 2
87947: ARRAY
87948: PPUSH
87949: CALL_OW 298
87953: ST_TO_ADDR
// distance := 9999 ;
87954: LD_ADDR_VAR 0 10
87958: PUSH
87959: LD_INT 9999
87961: ST_TO_ADDR
// for i := 0 to 5 do
87962: LD_ADDR_VAR 0 6
87966: PUSH
87967: DOUBLE
87968: LD_INT 0
87970: DEC
87971: ST_TO_ADDR
87972: LD_INT 5
87974: PUSH
87975: FOR_TO
87976: IFFALSE 88119
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87978: LD_ADDR_VAR 0 7
87982: PUSH
87983: LD_VAR 0 1
87987: PPUSH
87988: LD_VAR 0 6
87992: PPUSH
87993: LD_VAR 0 11
87997: PPUSH
87998: CALL_OW 272
88002: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88003: LD_ADDR_VAR 0 8
88007: PUSH
88008: LD_VAR 0 2
88012: PPUSH
88013: LD_VAR 0 6
88017: PPUSH
88018: LD_VAR 0 11
88022: PPUSH
88023: CALL_OW 273
88027: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88028: LD_VAR 0 7
88032: PPUSH
88033: LD_VAR 0 8
88037: PPUSH
88038: CALL_OW 488
88042: NOT
88043: IFFALSE 88047
// continue ;
88045: GO 87975
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88047: LD_ADDR_VAR 0 9
88051: PUSH
88052: LD_VAR 0 12
88056: PUSH
88057: LD_INT 1
88059: ARRAY
88060: PPUSH
88061: LD_VAR 0 12
88065: PUSH
88066: LD_INT 2
88068: ARRAY
88069: PPUSH
88070: LD_VAR 0 7
88074: PPUSH
88075: LD_VAR 0 8
88079: PPUSH
88080: CALL_OW 298
88084: ST_TO_ADDR
// if tmp < distance then
88085: LD_VAR 0 9
88089: PUSH
88090: LD_VAR 0 10
88094: LESS
88095: IFFALSE 88117
// begin result := i ;
88097: LD_ADDR_VAR 0 5
88101: PUSH
88102: LD_VAR 0 6
88106: ST_TO_ADDR
// distance := tmp ;
88107: LD_ADDR_VAR 0 10
88111: PUSH
88112: LD_VAR 0 9
88116: ST_TO_ADDR
// end ; end ;
88117: GO 87975
88119: POP
88120: POP
// end ;
88121: LD_VAR 0 5
88125: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88126: LD_INT 0
88128: PPUSH
88129: PPUSH
// if not driver or not IsInUnit ( driver ) then
88130: LD_VAR 0 1
88134: NOT
88135: PUSH
88136: LD_VAR 0 1
88140: PPUSH
88141: CALL_OW 310
88145: NOT
88146: OR
88147: IFFALSE 88151
// exit ;
88149: GO 88241
// vehicle := IsInUnit ( driver ) ;
88151: LD_ADDR_VAR 0 3
88155: PUSH
88156: LD_VAR 0 1
88160: PPUSH
88161: CALL_OW 310
88165: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88166: LD_VAR 0 1
88170: PPUSH
88171: LD_STRING \
88173: PUSH
88174: LD_INT 0
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 0
88182: PUSH
88183: LD_INT 0
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: PUSH
88201: LD_STRING E
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_VAR 0 3
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 0
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PPUSH
88237: CALL_OW 446
// end ;
88241: LD_VAR 0 2
88245: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88246: LD_INT 0
88248: PPUSH
88249: PPUSH
// if not driver or not IsInUnit ( driver ) then
88250: LD_VAR 0 1
88254: NOT
88255: PUSH
88256: LD_VAR 0 1
88260: PPUSH
88261: CALL_OW 310
88265: NOT
88266: OR
88267: IFFALSE 88271
// exit ;
88269: GO 88361
// vehicle := IsInUnit ( driver ) ;
88271: LD_ADDR_VAR 0 3
88275: PUSH
88276: LD_VAR 0 1
88280: PPUSH
88281: CALL_OW 310
88285: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88286: LD_VAR 0 1
88290: PPUSH
88291: LD_STRING \
88293: PUSH
88294: LD_INT 0
88296: PUSH
88297: LD_INT 0
88299: PUSH
88300: LD_INT 0
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: LD_INT 0
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: PUSH
88321: LD_STRING E
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: LD_VAR 0 3
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PPUSH
88357: CALL_OW 447
// end ;
88361: LD_VAR 0 2
88365: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88366: LD_INT 0
88368: PPUSH
88369: PPUSH
88370: PPUSH
// tmp := [ ] ;
88371: LD_ADDR_VAR 0 5
88375: PUSH
88376: EMPTY
88377: ST_TO_ADDR
// for i in units do
88378: LD_ADDR_VAR 0 4
88382: PUSH
88383: LD_VAR 0 1
88387: PUSH
88388: FOR_IN
88389: IFFALSE 88427
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88391: LD_ADDR_VAR 0 5
88395: PUSH
88396: LD_VAR 0 5
88400: PPUSH
88401: LD_VAR 0 5
88405: PUSH
88406: LD_INT 1
88408: PLUS
88409: PPUSH
88410: LD_VAR 0 4
88414: PPUSH
88415: CALL_OW 256
88419: PPUSH
88420: CALL_OW 2
88424: ST_TO_ADDR
88425: GO 88388
88427: POP
88428: POP
// if not tmp then
88429: LD_VAR 0 5
88433: NOT
88434: IFFALSE 88438
// exit ;
88436: GO 88486
// if asc then
88438: LD_VAR 0 2
88442: IFFALSE 88466
// result := SortListByListAsc ( units , tmp ) else
88444: LD_ADDR_VAR 0 3
88448: PUSH
88449: LD_VAR 0 1
88453: PPUSH
88454: LD_VAR 0 5
88458: PPUSH
88459: CALL_OW 76
88463: ST_TO_ADDR
88464: GO 88486
// result := SortListByListDesc ( units , tmp ) ;
88466: LD_ADDR_VAR 0 3
88470: PUSH
88471: LD_VAR 0 1
88475: PPUSH
88476: LD_VAR 0 5
88480: PPUSH
88481: CALL_OW 77
88485: ST_TO_ADDR
// end ;
88486: LD_VAR 0 3
88490: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88491: LD_INT 0
88493: PPUSH
88494: PPUSH
// task := GetTaskList ( mech ) ;
88495: LD_ADDR_VAR 0 4
88499: PUSH
88500: LD_VAR 0 1
88504: PPUSH
88505: CALL_OW 437
88509: ST_TO_ADDR
// if not task then
88510: LD_VAR 0 4
88514: NOT
88515: IFFALSE 88519
// exit ;
88517: GO 88561
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88519: LD_ADDR_VAR 0 3
88523: PUSH
88524: LD_VAR 0 4
88528: PUSH
88529: LD_INT 1
88531: ARRAY
88532: PUSH
88533: LD_INT 1
88535: ARRAY
88536: PUSH
88537: LD_STRING r
88539: EQUAL
88540: PUSH
88541: LD_VAR 0 4
88545: PUSH
88546: LD_INT 1
88548: ARRAY
88549: PUSH
88550: LD_INT 4
88552: ARRAY
88553: PUSH
88554: LD_VAR 0 2
88558: EQUAL
88559: AND
88560: ST_TO_ADDR
// end ;
88561: LD_VAR 0 3
88565: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88566: LD_INT 0
88568: PPUSH
// SetDir ( unit , d ) ;
88569: LD_VAR 0 1
88573: PPUSH
88574: LD_VAR 0 4
88578: PPUSH
88579: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88583: LD_VAR 0 1
88587: PPUSH
88588: LD_VAR 0 2
88592: PPUSH
88593: LD_VAR 0 3
88597: PPUSH
88598: LD_VAR 0 5
88602: PPUSH
88603: CALL_OW 48
// end ;
88607: LD_VAR 0 6
88611: RET
// export function ToNaturalNumber ( number ) ; begin
88612: LD_INT 0
88614: PPUSH
// result := number div 1 ;
88615: LD_ADDR_VAR 0 2
88619: PUSH
88620: LD_VAR 0 1
88624: PUSH
88625: LD_INT 1
88627: DIV
88628: ST_TO_ADDR
// if number < 0 then
88629: LD_VAR 0 1
88633: PUSH
88634: LD_INT 0
88636: LESS
88637: IFFALSE 88647
// result := 0 ;
88639: LD_ADDR_VAR 0 2
88643: PUSH
88644: LD_INT 0
88646: ST_TO_ADDR
// end ;
88647: LD_VAR 0 2
88651: RET
// export function SortByClass ( units , class ) ; var un ; begin
88652: LD_INT 0
88654: PPUSH
88655: PPUSH
// if not units or not class then
88656: LD_VAR 0 1
88660: NOT
88661: PUSH
88662: LD_VAR 0 2
88666: NOT
88667: OR
88668: IFFALSE 88672
// exit ;
88670: GO 88767
// result := [ ] ;
88672: LD_ADDR_VAR 0 3
88676: PUSH
88677: EMPTY
88678: ST_TO_ADDR
// for un in units do
88679: LD_ADDR_VAR 0 4
88683: PUSH
88684: LD_VAR 0 1
88688: PUSH
88689: FOR_IN
88690: IFFALSE 88765
// if GetClass ( un ) = class then
88692: LD_VAR 0 4
88696: PPUSH
88697: CALL_OW 257
88701: PUSH
88702: LD_VAR 0 2
88706: EQUAL
88707: IFFALSE 88734
// result := Insert ( result , 1 , un ) else
88709: LD_ADDR_VAR 0 3
88713: PUSH
88714: LD_VAR 0 3
88718: PPUSH
88719: LD_INT 1
88721: PPUSH
88722: LD_VAR 0 4
88726: PPUSH
88727: CALL_OW 2
88731: ST_TO_ADDR
88732: GO 88763
// result := Replace ( result , result + 1 , un ) ;
88734: LD_ADDR_VAR 0 3
88738: PUSH
88739: LD_VAR 0 3
88743: PPUSH
88744: LD_VAR 0 3
88748: PUSH
88749: LD_INT 1
88751: PLUS
88752: PPUSH
88753: LD_VAR 0 4
88757: PPUSH
88758: CALL_OW 1
88762: ST_TO_ADDR
88763: GO 88689
88765: POP
88766: POP
// end ;
88767: LD_VAR 0 3
88771: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88772: LD_INT 0
88774: PPUSH
88775: PPUSH
88776: PPUSH
88777: PPUSH
88778: PPUSH
88779: PPUSH
88780: PPUSH
// result := [ ] ;
88781: LD_ADDR_VAR 0 4
88785: PUSH
88786: EMPTY
88787: ST_TO_ADDR
// if x - r < 0 then
88788: LD_VAR 0 1
88792: PUSH
88793: LD_VAR 0 3
88797: MINUS
88798: PUSH
88799: LD_INT 0
88801: LESS
88802: IFFALSE 88814
// min_x := 0 else
88804: LD_ADDR_VAR 0 8
88808: PUSH
88809: LD_INT 0
88811: ST_TO_ADDR
88812: GO 88830
// min_x := x - r ;
88814: LD_ADDR_VAR 0 8
88818: PUSH
88819: LD_VAR 0 1
88823: PUSH
88824: LD_VAR 0 3
88828: MINUS
88829: ST_TO_ADDR
// if y - r < 0 then
88830: LD_VAR 0 2
88834: PUSH
88835: LD_VAR 0 3
88839: MINUS
88840: PUSH
88841: LD_INT 0
88843: LESS
88844: IFFALSE 88856
// min_y := 0 else
88846: LD_ADDR_VAR 0 7
88850: PUSH
88851: LD_INT 0
88853: ST_TO_ADDR
88854: GO 88872
// min_y := y - r ;
88856: LD_ADDR_VAR 0 7
88860: PUSH
88861: LD_VAR 0 2
88865: PUSH
88866: LD_VAR 0 3
88870: MINUS
88871: ST_TO_ADDR
// max_x := x + r ;
88872: LD_ADDR_VAR 0 9
88876: PUSH
88877: LD_VAR 0 1
88881: PUSH
88882: LD_VAR 0 3
88886: PLUS
88887: ST_TO_ADDR
// max_y := y + r ;
88888: LD_ADDR_VAR 0 10
88892: PUSH
88893: LD_VAR 0 2
88897: PUSH
88898: LD_VAR 0 3
88902: PLUS
88903: ST_TO_ADDR
// for _x = min_x to max_x do
88904: LD_ADDR_VAR 0 5
88908: PUSH
88909: DOUBLE
88910: LD_VAR 0 8
88914: DEC
88915: ST_TO_ADDR
88916: LD_VAR 0 9
88920: PUSH
88921: FOR_TO
88922: IFFALSE 89023
// for _y = min_y to max_y do
88924: LD_ADDR_VAR 0 6
88928: PUSH
88929: DOUBLE
88930: LD_VAR 0 7
88934: DEC
88935: ST_TO_ADDR
88936: LD_VAR 0 10
88940: PUSH
88941: FOR_TO
88942: IFFALSE 89019
// begin if not ValidHex ( _x , _y ) then
88944: LD_VAR 0 5
88948: PPUSH
88949: LD_VAR 0 6
88953: PPUSH
88954: CALL_OW 488
88958: NOT
88959: IFFALSE 88963
// continue ;
88961: GO 88941
// if GetResourceTypeXY ( _x , _y ) then
88963: LD_VAR 0 5
88967: PPUSH
88968: LD_VAR 0 6
88972: PPUSH
88973: CALL_OW 283
88977: IFFALSE 89017
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88979: LD_ADDR_VAR 0 4
88983: PUSH
88984: LD_VAR 0 4
88988: PPUSH
88989: LD_VAR 0 4
88993: PUSH
88994: LD_INT 1
88996: PLUS
88997: PPUSH
88998: LD_VAR 0 5
89002: PUSH
89003: LD_VAR 0 6
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PPUSH
89012: CALL_OW 1
89016: ST_TO_ADDR
// end ;
89017: GO 88941
89019: POP
89020: POP
89021: GO 88921
89023: POP
89024: POP
// end ;
89025: LD_VAR 0 4
89029: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89030: LD_INT 0
89032: PPUSH
89033: PPUSH
89034: PPUSH
89035: PPUSH
89036: PPUSH
89037: PPUSH
89038: PPUSH
89039: PPUSH
// if not units then
89040: LD_VAR 0 1
89044: NOT
89045: IFFALSE 89049
// exit ;
89047: GO 89573
// result := UnitFilter ( units , [ f_ok ] ) ;
89049: LD_ADDR_VAR 0 3
89053: PUSH
89054: LD_VAR 0 1
89058: PPUSH
89059: LD_INT 50
89061: PUSH
89062: EMPTY
89063: LIST
89064: PPUSH
89065: CALL_OW 72
89069: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89070: LD_ADDR_VAR 0 8
89074: PUSH
89075: LD_VAR 0 1
89079: PUSH
89080: LD_INT 1
89082: ARRAY
89083: PPUSH
89084: CALL_OW 255
89088: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89089: LD_ADDR_VAR 0 10
89093: PUSH
89094: LD_INT 29
89096: PUSH
89097: LD_INT 91
89099: PUSH
89100: LD_INT 49
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: LIST
89107: ST_TO_ADDR
// if not result then
89108: LD_VAR 0 3
89112: NOT
89113: IFFALSE 89117
// exit ;
89115: GO 89573
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89117: LD_ADDR_VAR 0 5
89121: PUSH
89122: LD_INT 81
89124: PUSH
89125: LD_VAR 0 8
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PPUSH
89134: CALL_OW 69
89138: ST_TO_ADDR
// for i in result do
89139: LD_ADDR_VAR 0 4
89143: PUSH
89144: LD_VAR 0 3
89148: PUSH
89149: FOR_IN
89150: IFFALSE 89571
// begin tag := GetTag ( i ) + 1 ;
89152: LD_ADDR_VAR 0 9
89156: PUSH
89157: LD_VAR 0 4
89161: PPUSH
89162: CALL_OW 110
89166: PUSH
89167: LD_INT 1
89169: PLUS
89170: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89171: LD_ADDR_VAR 0 7
89175: PUSH
89176: LD_VAR 0 4
89180: PPUSH
89181: CALL_OW 250
89185: PPUSH
89186: LD_VAR 0 4
89190: PPUSH
89191: CALL_OW 251
89195: PPUSH
89196: LD_INT 6
89198: PPUSH
89199: CALL 88772 0 3
89203: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89204: LD_VAR 0 4
89208: PPUSH
89209: CALL_OW 247
89213: PUSH
89214: LD_INT 2
89216: EQUAL
89217: PUSH
89218: LD_VAR 0 7
89222: AND
89223: PUSH
89224: LD_VAR 0 4
89228: PPUSH
89229: CALL_OW 264
89233: PUSH
89234: LD_VAR 0 10
89238: IN
89239: NOT
89240: AND
89241: IFFALSE 89280
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89243: LD_VAR 0 4
89247: PPUSH
89248: LD_VAR 0 7
89252: PUSH
89253: LD_INT 1
89255: ARRAY
89256: PUSH
89257: LD_INT 1
89259: ARRAY
89260: PPUSH
89261: LD_VAR 0 7
89265: PUSH
89266: LD_INT 1
89268: ARRAY
89269: PUSH
89270: LD_INT 2
89272: ARRAY
89273: PPUSH
89274: CALL_OW 116
89278: GO 89569
// if path > tag then
89280: LD_VAR 0 2
89284: PUSH
89285: LD_VAR 0 9
89289: GREATER
89290: IFFALSE 89498
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89292: LD_ADDR_VAR 0 6
89296: PUSH
89297: LD_VAR 0 5
89301: PPUSH
89302: LD_INT 91
89304: PUSH
89305: LD_VAR 0 4
89309: PUSH
89310: LD_INT 8
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: LIST
89317: PPUSH
89318: CALL_OW 72
89322: ST_TO_ADDR
// if nearEnemy then
89323: LD_VAR 0 6
89327: IFFALSE 89396
// begin if GetWeapon ( i ) = ru_time_lapser then
89329: LD_VAR 0 4
89333: PPUSH
89334: CALL_OW 264
89338: PUSH
89339: LD_INT 49
89341: EQUAL
89342: IFFALSE 89370
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89344: LD_VAR 0 4
89348: PPUSH
89349: LD_VAR 0 6
89353: PPUSH
89354: LD_VAR 0 4
89358: PPUSH
89359: CALL_OW 74
89363: PPUSH
89364: CALL_OW 112
89368: GO 89394
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89370: LD_VAR 0 4
89374: PPUSH
89375: LD_VAR 0 6
89379: PPUSH
89380: LD_VAR 0 4
89384: PPUSH
89385: CALL_OW 74
89389: PPUSH
89390: CALL 90498 0 2
// end else
89394: GO 89496
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89396: LD_VAR 0 4
89400: PPUSH
89401: LD_VAR 0 2
89405: PUSH
89406: LD_VAR 0 9
89410: ARRAY
89411: PUSH
89412: LD_INT 1
89414: ARRAY
89415: PPUSH
89416: LD_VAR 0 2
89420: PUSH
89421: LD_VAR 0 9
89425: ARRAY
89426: PUSH
89427: LD_INT 2
89429: ARRAY
89430: PPUSH
89431: CALL_OW 297
89435: PUSH
89436: LD_INT 6
89438: GREATER
89439: IFFALSE 89482
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89441: LD_VAR 0 4
89445: PPUSH
89446: LD_VAR 0 2
89450: PUSH
89451: LD_VAR 0 9
89455: ARRAY
89456: PUSH
89457: LD_INT 1
89459: ARRAY
89460: PPUSH
89461: LD_VAR 0 2
89465: PUSH
89466: LD_VAR 0 9
89470: ARRAY
89471: PUSH
89472: LD_INT 2
89474: ARRAY
89475: PPUSH
89476: CALL_OW 114
89480: GO 89496
// SetTag ( i , tag ) ;
89482: LD_VAR 0 4
89486: PPUSH
89487: LD_VAR 0 9
89491: PPUSH
89492: CALL_OW 109
// end else
89496: GO 89569
// if enemy then
89498: LD_VAR 0 5
89502: IFFALSE 89569
// begin if GetWeapon ( i ) = ru_time_lapser then
89504: LD_VAR 0 4
89508: PPUSH
89509: CALL_OW 264
89513: PUSH
89514: LD_INT 49
89516: EQUAL
89517: IFFALSE 89545
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89519: LD_VAR 0 4
89523: PPUSH
89524: LD_VAR 0 5
89528: PPUSH
89529: LD_VAR 0 4
89533: PPUSH
89534: CALL_OW 74
89538: PPUSH
89539: CALL_OW 112
89543: GO 89569
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89545: LD_VAR 0 4
89549: PPUSH
89550: LD_VAR 0 5
89554: PPUSH
89555: LD_VAR 0 4
89559: PPUSH
89560: CALL_OW 74
89564: PPUSH
89565: CALL 90498 0 2
// end ; end ;
89569: GO 89149
89571: POP
89572: POP
// end ;
89573: LD_VAR 0 3
89577: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89578: LD_INT 0
89580: PPUSH
89581: PPUSH
89582: PPUSH
// if not unit or IsInUnit ( unit ) then
89583: LD_VAR 0 1
89587: NOT
89588: PUSH
89589: LD_VAR 0 1
89593: PPUSH
89594: CALL_OW 310
89598: OR
89599: IFFALSE 89603
// exit ;
89601: GO 89694
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89603: LD_ADDR_VAR 0 4
89607: PUSH
89608: LD_VAR 0 1
89612: PPUSH
89613: CALL_OW 250
89617: PPUSH
89618: LD_VAR 0 2
89622: PPUSH
89623: LD_INT 1
89625: PPUSH
89626: CALL_OW 272
89630: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89631: LD_ADDR_VAR 0 5
89635: PUSH
89636: LD_VAR 0 1
89640: PPUSH
89641: CALL_OW 251
89645: PPUSH
89646: LD_VAR 0 2
89650: PPUSH
89651: LD_INT 1
89653: PPUSH
89654: CALL_OW 273
89658: ST_TO_ADDR
// if ValidHex ( x , y ) then
89659: LD_VAR 0 4
89663: PPUSH
89664: LD_VAR 0 5
89668: PPUSH
89669: CALL_OW 488
89673: IFFALSE 89694
// ComTurnXY ( unit , x , y ) ;
89675: LD_VAR 0 1
89679: PPUSH
89680: LD_VAR 0 4
89684: PPUSH
89685: LD_VAR 0 5
89689: PPUSH
89690: CALL_OW 118
// end ;
89694: LD_VAR 0 3
89698: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89699: LD_INT 0
89701: PPUSH
89702: PPUSH
// result := false ;
89703: LD_ADDR_VAR 0 3
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
// if not units then
89711: LD_VAR 0 2
89715: NOT
89716: IFFALSE 89720
// exit ;
89718: GO 89765
// for i in units do
89720: LD_ADDR_VAR 0 4
89724: PUSH
89725: LD_VAR 0 2
89729: PUSH
89730: FOR_IN
89731: IFFALSE 89763
// if See ( side , i ) then
89733: LD_VAR 0 1
89737: PPUSH
89738: LD_VAR 0 4
89742: PPUSH
89743: CALL_OW 292
89747: IFFALSE 89761
// begin result := true ;
89749: LD_ADDR_VAR 0 3
89753: PUSH
89754: LD_INT 1
89756: ST_TO_ADDR
// exit ;
89757: POP
89758: POP
89759: GO 89765
// end ;
89761: GO 89730
89763: POP
89764: POP
// end ;
89765: LD_VAR 0 3
89769: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89770: LD_INT 0
89772: PPUSH
89773: PPUSH
89774: PPUSH
89775: PPUSH
// if not unit or not points then
89776: LD_VAR 0 1
89780: NOT
89781: PUSH
89782: LD_VAR 0 2
89786: NOT
89787: OR
89788: IFFALSE 89792
// exit ;
89790: GO 89882
// dist := 99999 ;
89792: LD_ADDR_VAR 0 5
89796: PUSH
89797: LD_INT 99999
89799: ST_TO_ADDR
// for i in points do
89800: LD_ADDR_VAR 0 4
89804: PUSH
89805: LD_VAR 0 2
89809: PUSH
89810: FOR_IN
89811: IFFALSE 89880
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89813: LD_ADDR_VAR 0 6
89817: PUSH
89818: LD_VAR 0 1
89822: PPUSH
89823: LD_VAR 0 4
89827: PUSH
89828: LD_INT 1
89830: ARRAY
89831: PPUSH
89832: LD_VAR 0 4
89836: PUSH
89837: LD_INT 2
89839: ARRAY
89840: PPUSH
89841: CALL_OW 297
89845: ST_TO_ADDR
// if tmpDist < dist then
89846: LD_VAR 0 6
89850: PUSH
89851: LD_VAR 0 5
89855: LESS
89856: IFFALSE 89878
// begin result := i ;
89858: LD_ADDR_VAR 0 3
89862: PUSH
89863: LD_VAR 0 4
89867: ST_TO_ADDR
// dist := tmpDist ;
89868: LD_ADDR_VAR 0 5
89872: PUSH
89873: LD_VAR 0 6
89877: ST_TO_ADDR
// end ; end ;
89878: GO 89810
89880: POP
89881: POP
// end ;
89882: LD_VAR 0 3
89886: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89887: LD_INT 0
89889: PPUSH
// uc_side := side ;
89890: LD_ADDR_OWVAR 20
89894: PUSH
89895: LD_VAR 0 1
89899: ST_TO_ADDR
// uc_nation := 3 ;
89900: LD_ADDR_OWVAR 21
89904: PUSH
89905: LD_INT 3
89907: ST_TO_ADDR
// vc_chassis := 25 ;
89908: LD_ADDR_OWVAR 37
89912: PUSH
89913: LD_INT 25
89915: ST_TO_ADDR
// vc_engine := engine_siberite ;
89916: LD_ADDR_OWVAR 39
89920: PUSH
89921: LD_INT 3
89923: ST_TO_ADDR
// vc_control := control_computer ;
89924: LD_ADDR_OWVAR 38
89928: PUSH
89929: LD_INT 3
89931: ST_TO_ADDR
// vc_weapon := 59 ;
89932: LD_ADDR_OWVAR 40
89936: PUSH
89937: LD_INT 59
89939: ST_TO_ADDR
// result := CreateVehicle ;
89940: LD_ADDR_VAR 0 5
89944: PUSH
89945: CALL_OW 45
89949: ST_TO_ADDR
// SetDir ( result , d ) ;
89950: LD_VAR 0 5
89954: PPUSH
89955: LD_VAR 0 4
89959: PPUSH
89960: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89964: LD_VAR 0 5
89968: PPUSH
89969: LD_VAR 0 2
89973: PPUSH
89974: LD_VAR 0 3
89978: PPUSH
89979: LD_INT 0
89981: PPUSH
89982: CALL_OW 48
// end ;
89986: LD_VAR 0 5
89990: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89991: LD_INT 0
89993: PPUSH
89994: PPUSH
89995: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89996: LD_ADDR_VAR 0 2
90000: PUSH
90001: LD_INT 0
90003: PUSH
90004: LD_INT 0
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90019: LD_VAR 0 1
90023: NOT
90024: PUSH
90025: LD_VAR 0 1
90029: PPUSH
90030: CALL_OW 264
90034: PUSH
90035: LD_INT 12
90037: PUSH
90038: LD_INT 51
90040: PUSH
90041: LD_INT 32
90043: PUSH
90044: LD_INT 89
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: IN
90053: NOT
90054: OR
90055: IFFALSE 90059
// exit ;
90057: GO 90157
// for i := 1 to 3 do
90059: LD_ADDR_VAR 0 3
90063: PUSH
90064: DOUBLE
90065: LD_INT 1
90067: DEC
90068: ST_TO_ADDR
90069: LD_INT 3
90071: PUSH
90072: FOR_TO
90073: IFFALSE 90155
// begin tmp := GetCargo ( cargo , i ) ;
90075: LD_ADDR_VAR 0 4
90079: PUSH
90080: LD_VAR 0 1
90084: PPUSH
90085: LD_VAR 0 3
90089: PPUSH
90090: CALL_OW 289
90094: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90095: LD_ADDR_VAR 0 2
90099: PUSH
90100: LD_VAR 0 2
90104: PPUSH
90105: LD_VAR 0 3
90109: PPUSH
90110: LD_VAR 0 4
90114: PPUSH
90115: CALL_OW 1
90119: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90120: LD_ADDR_VAR 0 2
90124: PUSH
90125: LD_VAR 0 2
90129: PPUSH
90130: LD_INT 4
90132: PPUSH
90133: LD_VAR 0 2
90137: PUSH
90138: LD_INT 4
90140: ARRAY
90141: PUSH
90142: LD_VAR 0 4
90146: PLUS
90147: PPUSH
90148: CALL_OW 1
90152: ST_TO_ADDR
// end ;
90153: GO 90072
90155: POP
90156: POP
// end ;
90157: LD_VAR 0 2
90161: RET
// export function Length ( array ) ; begin
90162: LD_INT 0
90164: PPUSH
// result := array + 0 ;
90165: LD_ADDR_VAR 0 2
90169: PUSH
90170: LD_VAR 0 1
90174: PUSH
90175: LD_INT 0
90177: PLUS
90178: ST_TO_ADDR
// end ;
90179: LD_VAR 0 2
90183: RET
// export function PrepareArray ( array ) ; begin
90184: LD_INT 0
90186: PPUSH
// result := array diff 0 ;
90187: LD_ADDR_VAR 0 2
90191: PUSH
90192: LD_VAR 0 1
90196: PUSH
90197: LD_INT 0
90199: DIFF
90200: ST_TO_ADDR
// if not result [ 1 ] then
90201: LD_VAR 0 2
90205: PUSH
90206: LD_INT 1
90208: ARRAY
90209: NOT
90210: IFFALSE 90230
// result := Delete ( result , 1 ) ;
90212: LD_ADDR_VAR 0 2
90216: PUSH
90217: LD_VAR 0 2
90221: PPUSH
90222: LD_INT 1
90224: PPUSH
90225: CALL_OW 3
90229: ST_TO_ADDR
// end ;
90230: LD_VAR 0 2
90234: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90235: LD_INT 0
90237: PPUSH
90238: PPUSH
90239: PPUSH
90240: PPUSH
// sibRocketRange := 25 ;
90241: LD_ADDR_VAR 0 6
90245: PUSH
90246: LD_INT 25
90248: ST_TO_ADDR
// result := false ;
90249: LD_ADDR_VAR 0 4
90253: PUSH
90254: LD_INT 0
90256: ST_TO_ADDR
// for i := 0 to 5 do
90257: LD_ADDR_VAR 0 5
90261: PUSH
90262: DOUBLE
90263: LD_INT 0
90265: DEC
90266: ST_TO_ADDR
90267: LD_INT 5
90269: PUSH
90270: FOR_TO
90271: IFFALSE 90338
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90273: LD_VAR 0 1
90277: PPUSH
90278: LD_VAR 0 5
90282: PPUSH
90283: LD_VAR 0 6
90287: PPUSH
90288: CALL_OW 272
90292: PPUSH
90293: LD_VAR 0 2
90297: PPUSH
90298: LD_VAR 0 5
90302: PPUSH
90303: LD_VAR 0 6
90307: PPUSH
90308: CALL_OW 273
90312: PPUSH
90313: LD_VAR 0 3
90317: PPUSH
90318: CALL_OW 309
90322: IFFALSE 90336
// begin result := true ;
90324: LD_ADDR_VAR 0 4
90328: PUSH
90329: LD_INT 1
90331: ST_TO_ADDR
// exit ;
90332: POP
90333: POP
90334: GO 90340
// end ;
90336: GO 90270
90338: POP
90339: POP
// end ;
90340: LD_VAR 0 4
90344: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90345: LD_INT 0
90347: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90348: LD_VAR 0 1
90352: PPUSH
90353: LD_VAR 0 2
90357: PPUSH
90358: LD_INT 0
90360: PPUSH
90361: LD_INT 0
90363: PPUSH
90364: LD_INT 1
90366: PPUSH
90367: LD_INT 0
90369: PPUSH
90370: CALL_OW 587
// end ;
90374: LD_VAR 0 3
90378: RET
// export function CenterOnNow ( unit ) ; begin
90379: LD_INT 0
90381: PPUSH
// result := IsInUnit ( unit ) ;
90382: LD_ADDR_VAR 0 2
90386: PUSH
90387: LD_VAR 0 1
90391: PPUSH
90392: CALL_OW 310
90396: ST_TO_ADDR
// if not result then
90397: LD_VAR 0 2
90401: NOT
90402: IFFALSE 90414
// result := unit ;
90404: LD_ADDR_VAR 0 2
90408: PUSH
90409: LD_VAR 0 1
90413: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90414: LD_VAR 0 1
90418: PPUSH
90419: CALL_OW 87
// end ;
90423: LD_VAR 0 2
90427: RET
// export function ComMoveHex ( unit , hex ) ; begin
90428: LD_INT 0
90430: PPUSH
// if not hex then
90431: LD_VAR 0 2
90435: NOT
90436: IFFALSE 90440
// exit ;
90438: GO 90493
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90440: LD_VAR 0 2
90444: PUSH
90445: LD_INT 1
90447: ARRAY
90448: PPUSH
90449: LD_VAR 0 2
90453: PUSH
90454: LD_INT 2
90456: ARRAY
90457: PPUSH
90458: CALL_OW 428
90462: IFFALSE 90466
// exit ;
90464: GO 90493
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90466: LD_VAR 0 1
90470: PPUSH
90471: LD_VAR 0 2
90475: PUSH
90476: LD_INT 1
90478: ARRAY
90479: PPUSH
90480: LD_VAR 0 2
90484: PUSH
90485: LD_INT 2
90487: ARRAY
90488: PPUSH
90489: CALL_OW 111
// end ;
90493: LD_VAR 0 3
90497: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90498: LD_INT 0
90500: PPUSH
90501: PPUSH
90502: PPUSH
// if not unit or not enemy then
90503: LD_VAR 0 1
90507: NOT
90508: PUSH
90509: LD_VAR 0 2
90513: NOT
90514: OR
90515: IFFALSE 90519
// exit ;
90517: GO 90636
// x := GetX ( enemy ) ;
90519: LD_ADDR_VAR 0 4
90523: PUSH
90524: LD_VAR 0 2
90528: PPUSH
90529: CALL_OW 250
90533: ST_TO_ADDR
// y := GetY ( enemy ) ;
90534: LD_ADDR_VAR 0 5
90538: PUSH
90539: LD_VAR 0 2
90543: PPUSH
90544: CALL_OW 251
90548: ST_TO_ADDR
// if ValidHex ( x , y ) then
90549: LD_VAR 0 4
90553: PPUSH
90554: LD_VAR 0 5
90558: PPUSH
90559: CALL_OW 488
90563: IFFALSE 90636
// if GetType ( enemy ) = unit_building and See ( GetSide ( unit ) , enemy ) then
90565: LD_VAR 0 2
90569: PPUSH
90570: CALL_OW 247
90574: PUSH
90575: LD_INT 3
90577: EQUAL
90578: PUSH
90579: LD_VAR 0 1
90583: PPUSH
90584: CALL_OW 255
90588: PPUSH
90589: LD_VAR 0 2
90593: PPUSH
90594: CALL_OW 292
90598: AND
90599: IFFALSE 90617
// ComAttackUnit ( unit , enemy ) else
90601: LD_VAR 0 1
90605: PPUSH
90606: LD_VAR 0 2
90610: PPUSH
90611: CALL_OW 115
90615: GO 90636
// ComAgressiveMove ( unit , x , y ) ;
90617: LD_VAR 0 1
90621: PPUSH
90622: LD_VAR 0 4
90626: PPUSH
90627: LD_VAR 0 5
90631: PPUSH
90632: CALL_OW 114
// end ; end_of_file end_of_file
90636: LD_VAR 0 3
90640: RET
// export globalGameSaveCounter ; every 0 0$1 do
90641: GO 90643
90643: DISABLE
// begin enable ;
90644: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90645: LD_STRING updateTimer(
90647: PUSH
90648: LD_OWVAR 1
90652: STR
90653: PUSH
90654: LD_STRING );
90656: STR
90657: PPUSH
90658: CALL_OW 559
// end ;
90662: END
// every 0 0$1 do
90663: GO 90665
90665: DISABLE
// begin globalGameSaveCounter := 0 ;
90666: LD_ADDR_EXP 95
90670: PUSH
90671: LD_INT 0
90673: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90674: LD_STRING setGameSaveCounter(0)
90676: PPUSH
90677: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90681: LD_STRING initStreamRollete();
90683: PPUSH
90684: CALL_OW 559
// InitStreamMode ;
90688: CALL 92014 0 0
// DefineStreamItems ( false ) ;
90692: LD_INT 0
90694: PPUSH
90695: CALL 92478 0 1
// end ;
90699: END
// export function SOS_MapStart ( ) ; begin
90700: LD_INT 0
90702: PPUSH
// if streamModeActive then
90703: LD_EXP 96
90707: IFFALSE 90716
// DefineStreamItems ( true ) ;
90709: LD_INT 1
90711: PPUSH
90712: CALL 92478 0 1
// UpdateLuaVariables ( ) ;
90716: CALL 90733 0 0
// UpdateFactoryWaypoints ( ) ;
90720: CALL 105347 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90724: CALL 105604 0 0
// end ;
90728: LD_VAR 0 1
90732: RET
// function UpdateLuaVariables ( ) ; begin
90733: LD_INT 0
90735: PPUSH
// if globalGameSaveCounter then
90736: LD_EXP 95
90740: IFFALSE 90774
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90742: LD_ADDR_EXP 95
90746: PUSH
90747: LD_EXP 95
90751: PPUSH
90752: CALL 87787 0 1
90756: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90757: LD_STRING setGameSaveCounter(
90759: PUSH
90760: LD_EXP 95
90764: STR
90765: PUSH
90766: LD_STRING )
90768: STR
90769: PPUSH
90770: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90774: LD_STRING setGameDifficulty(
90776: PUSH
90777: LD_OWVAR 67
90781: STR
90782: PUSH
90783: LD_STRING )
90785: STR
90786: PPUSH
90787: CALL_OW 559
// end ;
90791: LD_VAR 0 1
90795: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90796: LD_INT 0
90798: PPUSH
// if p2 = stream_mode then
90799: LD_VAR 0 2
90803: PUSH
90804: LD_INT 100
90806: EQUAL
90807: IFFALSE 91810
// begin if not StreamModeActive then
90809: LD_EXP 96
90813: NOT
90814: IFFALSE 90824
// StreamModeActive := true ;
90816: LD_ADDR_EXP 96
90820: PUSH
90821: LD_INT 1
90823: ST_TO_ADDR
// if p3 = 0 then
90824: LD_VAR 0 3
90828: PUSH
90829: LD_INT 0
90831: EQUAL
90832: IFFALSE 90838
// InitStreamMode ;
90834: CALL 92014 0 0
// if p3 = 1 then
90838: LD_VAR 0 3
90842: PUSH
90843: LD_INT 1
90845: EQUAL
90846: IFFALSE 90856
// sRocket := true ;
90848: LD_ADDR_EXP 101
90852: PUSH
90853: LD_INT 1
90855: ST_TO_ADDR
// if p3 = 2 then
90856: LD_VAR 0 3
90860: PUSH
90861: LD_INT 2
90863: EQUAL
90864: IFFALSE 90874
// sSpeed := true ;
90866: LD_ADDR_EXP 100
90870: PUSH
90871: LD_INT 1
90873: ST_TO_ADDR
// if p3 = 3 then
90874: LD_VAR 0 3
90878: PUSH
90879: LD_INT 3
90881: EQUAL
90882: IFFALSE 90892
// sEngine := true ;
90884: LD_ADDR_EXP 102
90888: PUSH
90889: LD_INT 1
90891: ST_TO_ADDR
// if p3 = 4 then
90892: LD_VAR 0 3
90896: PUSH
90897: LD_INT 4
90899: EQUAL
90900: IFFALSE 90910
// sSpec := true ;
90902: LD_ADDR_EXP 99
90906: PUSH
90907: LD_INT 1
90909: ST_TO_ADDR
// if p3 = 5 then
90910: LD_VAR 0 3
90914: PUSH
90915: LD_INT 5
90917: EQUAL
90918: IFFALSE 90928
// sLevel := true ;
90920: LD_ADDR_EXP 103
90924: PUSH
90925: LD_INT 1
90927: ST_TO_ADDR
// if p3 = 6 then
90928: LD_VAR 0 3
90932: PUSH
90933: LD_INT 6
90935: EQUAL
90936: IFFALSE 90946
// sArmoury := true ;
90938: LD_ADDR_EXP 104
90942: PUSH
90943: LD_INT 1
90945: ST_TO_ADDR
// if p3 = 7 then
90946: LD_VAR 0 3
90950: PUSH
90951: LD_INT 7
90953: EQUAL
90954: IFFALSE 90964
// sRadar := true ;
90956: LD_ADDR_EXP 105
90960: PUSH
90961: LD_INT 1
90963: ST_TO_ADDR
// if p3 = 8 then
90964: LD_VAR 0 3
90968: PUSH
90969: LD_INT 8
90971: EQUAL
90972: IFFALSE 90982
// sBunker := true ;
90974: LD_ADDR_EXP 106
90978: PUSH
90979: LD_INT 1
90981: ST_TO_ADDR
// if p3 = 9 then
90982: LD_VAR 0 3
90986: PUSH
90987: LD_INT 9
90989: EQUAL
90990: IFFALSE 91000
// sHack := true ;
90992: LD_ADDR_EXP 107
90996: PUSH
90997: LD_INT 1
90999: ST_TO_ADDR
// if p3 = 10 then
91000: LD_VAR 0 3
91004: PUSH
91005: LD_INT 10
91007: EQUAL
91008: IFFALSE 91018
// sFire := true ;
91010: LD_ADDR_EXP 108
91014: PUSH
91015: LD_INT 1
91017: ST_TO_ADDR
// if p3 = 11 then
91018: LD_VAR 0 3
91022: PUSH
91023: LD_INT 11
91025: EQUAL
91026: IFFALSE 91036
// sRefresh := true ;
91028: LD_ADDR_EXP 109
91032: PUSH
91033: LD_INT 1
91035: ST_TO_ADDR
// if p3 = 12 then
91036: LD_VAR 0 3
91040: PUSH
91041: LD_INT 12
91043: EQUAL
91044: IFFALSE 91054
// sExp := true ;
91046: LD_ADDR_EXP 110
91050: PUSH
91051: LD_INT 1
91053: ST_TO_ADDR
// if p3 = 13 then
91054: LD_VAR 0 3
91058: PUSH
91059: LD_INT 13
91061: EQUAL
91062: IFFALSE 91072
// sDepot := true ;
91064: LD_ADDR_EXP 111
91068: PUSH
91069: LD_INT 1
91071: ST_TO_ADDR
// if p3 = 14 then
91072: LD_VAR 0 3
91076: PUSH
91077: LD_INT 14
91079: EQUAL
91080: IFFALSE 91090
// sFlag := true ;
91082: LD_ADDR_EXP 112
91086: PUSH
91087: LD_INT 1
91089: ST_TO_ADDR
// if p3 = 15 then
91090: LD_VAR 0 3
91094: PUSH
91095: LD_INT 15
91097: EQUAL
91098: IFFALSE 91108
// sKamikadze := true ;
91100: LD_ADDR_EXP 120
91104: PUSH
91105: LD_INT 1
91107: ST_TO_ADDR
// if p3 = 16 then
91108: LD_VAR 0 3
91112: PUSH
91113: LD_INT 16
91115: EQUAL
91116: IFFALSE 91126
// sTroll := true ;
91118: LD_ADDR_EXP 121
91122: PUSH
91123: LD_INT 1
91125: ST_TO_ADDR
// if p3 = 17 then
91126: LD_VAR 0 3
91130: PUSH
91131: LD_INT 17
91133: EQUAL
91134: IFFALSE 91144
// sSlow := true ;
91136: LD_ADDR_EXP 122
91140: PUSH
91141: LD_INT 1
91143: ST_TO_ADDR
// if p3 = 18 then
91144: LD_VAR 0 3
91148: PUSH
91149: LD_INT 18
91151: EQUAL
91152: IFFALSE 91162
// sLack := true ;
91154: LD_ADDR_EXP 123
91158: PUSH
91159: LD_INT 1
91161: ST_TO_ADDR
// if p3 = 19 then
91162: LD_VAR 0 3
91166: PUSH
91167: LD_INT 19
91169: EQUAL
91170: IFFALSE 91180
// sTank := true ;
91172: LD_ADDR_EXP 125
91176: PUSH
91177: LD_INT 1
91179: ST_TO_ADDR
// if p3 = 20 then
91180: LD_VAR 0 3
91184: PUSH
91185: LD_INT 20
91187: EQUAL
91188: IFFALSE 91198
// sRemote := true ;
91190: LD_ADDR_EXP 126
91194: PUSH
91195: LD_INT 1
91197: ST_TO_ADDR
// if p3 = 21 then
91198: LD_VAR 0 3
91202: PUSH
91203: LD_INT 21
91205: EQUAL
91206: IFFALSE 91216
// sPowell := true ;
91208: LD_ADDR_EXP 127
91212: PUSH
91213: LD_INT 1
91215: ST_TO_ADDR
// if p3 = 22 then
91216: LD_VAR 0 3
91220: PUSH
91221: LD_INT 22
91223: EQUAL
91224: IFFALSE 91234
// sTeleport := true ;
91226: LD_ADDR_EXP 130
91230: PUSH
91231: LD_INT 1
91233: ST_TO_ADDR
// if p3 = 23 then
91234: LD_VAR 0 3
91238: PUSH
91239: LD_INT 23
91241: EQUAL
91242: IFFALSE 91252
// sOilTower := true ;
91244: LD_ADDR_EXP 132
91248: PUSH
91249: LD_INT 1
91251: ST_TO_ADDR
// if p3 = 24 then
91252: LD_VAR 0 3
91256: PUSH
91257: LD_INT 24
91259: EQUAL
91260: IFFALSE 91270
// sShovel := true ;
91262: LD_ADDR_EXP 133
91266: PUSH
91267: LD_INT 1
91269: ST_TO_ADDR
// if p3 = 25 then
91270: LD_VAR 0 3
91274: PUSH
91275: LD_INT 25
91277: EQUAL
91278: IFFALSE 91288
// sSheik := true ;
91280: LD_ADDR_EXP 134
91284: PUSH
91285: LD_INT 1
91287: ST_TO_ADDR
// if p3 = 26 then
91288: LD_VAR 0 3
91292: PUSH
91293: LD_INT 26
91295: EQUAL
91296: IFFALSE 91306
// sEarthquake := true ;
91298: LD_ADDR_EXP 136
91302: PUSH
91303: LD_INT 1
91305: ST_TO_ADDR
// if p3 = 27 then
91306: LD_VAR 0 3
91310: PUSH
91311: LD_INT 27
91313: EQUAL
91314: IFFALSE 91324
// sAI := true ;
91316: LD_ADDR_EXP 137
91320: PUSH
91321: LD_INT 1
91323: ST_TO_ADDR
// if p3 = 28 then
91324: LD_VAR 0 3
91328: PUSH
91329: LD_INT 28
91331: EQUAL
91332: IFFALSE 91342
// sCargo := true ;
91334: LD_ADDR_EXP 140
91338: PUSH
91339: LD_INT 1
91341: ST_TO_ADDR
// if p3 = 29 then
91342: LD_VAR 0 3
91346: PUSH
91347: LD_INT 29
91349: EQUAL
91350: IFFALSE 91360
// sDLaser := true ;
91352: LD_ADDR_EXP 141
91356: PUSH
91357: LD_INT 1
91359: ST_TO_ADDR
// if p3 = 30 then
91360: LD_VAR 0 3
91364: PUSH
91365: LD_INT 30
91367: EQUAL
91368: IFFALSE 91378
// sExchange := true ;
91370: LD_ADDR_EXP 142
91374: PUSH
91375: LD_INT 1
91377: ST_TO_ADDR
// if p3 = 31 then
91378: LD_VAR 0 3
91382: PUSH
91383: LD_INT 31
91385: EQUAL
91386: IFFALSE 91396
// sFac := true ;
91388: LD_ADDR_EXP 143
91392: PUSH
91393: LD_INT 1
91395: ST_TO_ADDR
// if p3 = 32 then
91396: LD_VAR 0 3
91400: PUSH
91401: LD_INT 32
91403: EQUAL
91404: IFFALSE 91414
// sPower := true ;
91406: LD_ADDR_EXP 144
91410: PUSH
91411: LD_INT 1
91413: ST_TO_ADDR
// if p3 = 33 then
91414: LD_VAR 0 3
91418: PUSH
91419: LD_INT 33
91421: EQUAL
91422: IFFALSE 91432
// sRandom := true ;
91424: LD_ADDR_EXP 145
91428: PUSH
91429: LD_INT 1
91431: ST_TO_ADDR
// if p3 = 34 then
91432: LD_VAR 0 3
91436: PUSH
91437: LD_INT 34
91439: EQUAL
91440: IFFALSE 91450
// sShield := true ;
91442: LD_ADDR_EXP 146
91446: PUSH
91447: LD_INT 1
91449: ST_TO_ADDR
// if p3 = 35 then
91450: LD_VAR 0 3
91454: PUSH
91455: LD_INT 35
91457: EQUAL
91458: IFFALSE 91468
// sTime := true ;
91460: LD_ADDR_EXP 147
91464: PUSH
91465: LD_INT 1
91467: ST_TO_ADDR
// if p3 = 36 then
91468: LD_VAR 0 3
91472: PUSH
91473: LD_INT 36
91475: EQUAL
91476: IFFALSE 91486
// sTools := true ;
91478: LD_ADDR_EXP 148
91482: PUSH
91483: LD_INT 1
91485: ST_TO_ADDR
// if p3 = 101 then
91486: LD_VAR 0 3
91490: PUSH
91491: LD_INT 101
91493: EQUAL
91494: IFFALSE 91504
// sSold := true ;
91496: LD_ADDR_EXP 113
91500: PUSH
91501: LD_INT 1
91503: ST_TO_ADDR
// if p3 = 102 then
91504: LD_VAR 0 3
91508: PUSH
91509: LD_INT 102
91511: EQUAL
91512: IFFALSE 91522
// sDiff := true ;
91514: LD_ADDR_EXP 114
91518: PUSH
91519: LD_INT 1
91521: ST_TO_ADDR
// if p3 = 103 then
91522: LD_VAR 0 3
91526: PUSH
91527: LD_INT 103
91529: EQUAL
91530: IFFALSE 91540
// sFog := true ;
91532: LD_ADDR_EXP 117
91536: PUSH
91537: LD_INT 1
91539: ST_TO_ADDR
// if p3 = 104 then
91540: LD_VAR 0 3
91544: PUSH
91545: LD_INT 104
91547: EQUAL
91548: IFFALSE 91558
// sReset := true ;
91550: LD_ADDR_EXP 118
91554: PUSH
91555: LD_INT 1
91557: ST_TO_ADDR
// if p3 = 105 then
91558: LD_VAR 0 3
91562: PUSH
91563: LD_INT 105
91565: EQUAL
91566: IFFALSE 91576
// sSun := true ;
91568: LD_ADDR_EXP 119
91572: PUSH
91573: LD_INT 1
91575: ST_TO_ADDR
// if p3 = 106 then
91576: LD_VAR 0 3
91580: PUSH
91581: LD_INT 106
91583: EQUAL
91584: IFFALSE 91594
// sTiger := true ;
91586: LD_ADDR_EXP 115
91590: PUSH
91591: LD_INT 1
91593: ST_TO_ADDR
// if p3 = 107 then
91594: LD_VAR 0 3
91598: PUSH
91599: LD_INT 107
91601: EQUAL
91602: IFFALSE 91612
// sBomb := true ;
91604: LD_ADDR_EXP 116
91608: PUSH
91609: LD_INT 1
91611: ST_TO_ADDR
// if p3 = 108 then
91612: LD_VAR 0 3
91616: PUSH
91617: LD_INT 108
91619: EQUAL
91620: IFFALSE 91630
// sWound := true ;
91622: LD_ADDR_EXP 124
91626: PUSH
91627: LD_INT 1
91629: ST_TO_ADDR
// if p3 = 109 then
91630: LD_VAR 0 3
91634: PUSH
91635: LD_INT 109
91637: EQUAL
91638: IFFALSE 91648
// sBetray := true ;
91640: LD_ADDR_EXP 128
91644: PUSH
91645: LD_INT 1
91647: ST_TO_ADDR
// if p3 = 110 then
91648: LD_VAR 0 3
91652: PUSH
91653: LD_INT 110
91655: EQUAL
91656: IFFALSE 91666
// sContamin := true ;
91658: LD_ADDR_EXP 129
91662: PUSH
91663: LD_INT 1
91665: ST_TO_ADDR
// if p3 = 111 then
91666: LD_VAR 0 3
91670: PUSH
91671: LD_INT 111
91673: EQUAL
91674: IFFALSE 91684
// sOil := true ;
91676: LD_ADDR_EXP 131
91680: PUSH
91681: LD_INT 1
91683: ST_TO_ADDR
// if p3 = 112 then
91684: LD_VAR 0 3
91688: PUSH
91689: LD_INT 112
91691: EQUAL
91692: IFFALSE 91702
// sStu := true ;
91694: LD_ADDR_EXP 135
91698: PUSH
91699: LD_INT 1
91701: ST_TO_ADDR
// if p3 = 113 then
91702: LD_VAR 0 3
91706: PUSH
91707: LD_INT 113
91709: EQUAL
91710: IFFALSE 91720
// sBazooka := true ;
91712: LD_ADDR_EXP 138
91716: PUSH
91717: LD_INT 1
91719: ST_TO_ADDR
// if p3 = 114 then
91720: LD_VAR 0 3
91724: PUSH
91725: LD_INT 114
91727: EQUAL
91728: IFFALSE 91738
// sMortar := true ;
91730: LD_ADDR_EXP 139
91734: PUSH
91735: LD_INT 1
91737: ST_TO_ADDR
// if p3 = 115 then
91738: LD_VAR 0 3
91742: PUSH
91743: LD_INT 115
91745: EQUAL
91746: IFFALSE 91756
// sRanger := true ;
91748: LD_ADDR_EXP 149
91752: PUSH
91753: LD_INT 1
91755: ST_TO_ADDR
// if p3 = 116 then
91756: LD_VAR 0 3
91760: PUSH
91761: LD_INT 116
91763: EQUAL
91764: IFFALSE 91774
// sComputer := true ;
91766: LD_ADDR_EXP 150
91770: PUSH
91771: LD_INT 1
91773: ST_TO_ADDR
// if p3 = 117 then
91774: LD_VAR 0 3
91778: PUSH
91779: LD_INT 117
91781: EQUAL
91782: IFFALSE 91792
// s30 := true ;
91784: LD_ADDR_EXP 151
91788: PUSH
91789: LD_INT 1
91791: ST_TO_ADDR
// if p3 = 118 then
91792: LD_VAR 0 3
91796: PUSH
91797: LD_INT 118
91799: EQUAL
91800: IFFALSE 91810
// s60 := true ;
91802: LD_ADDR_EXP 152
91806: PUSH
91807: LD_INT 1
91809: ST_TO_ADDR
// end ; if p2 = hack_mode then
91810: LD_VAR 0 2
91814: PUSH
91815: LD_INT 101
91817: EQUAL
91818: IFFALSE 91946
// begin case p3 of 1 :
91820: LD_VAR 0 3
91824: PUSH
91825: LD_INT 1
91827: DOUBLE
91828: EQUAL
91829: IFTRUE 91833
91831: GO 91840
91833: POP
// hHackUnlimitedResources ; 2 :
91834: CALL 104093 0 0
91838: GO 91946
91840: LD_INT 2
91842: DOUBLE
91843: EQUAL
91844: IFTRUE 91848
91846: GO 91855
91848: POP
// hHackSetLevel10 ; 3 :
91849: CALL 104226 0 0
91853: GO 91946
91855: LD_INT 3
91857: DOUBLE
91858: EQUAL
91859: IFTRUE 91863
91861: GO 91870
91863: POP
// hHackSetLevel10YourUnits ; 4 :
91864: CALL 104311 0 0
91868: GO 91946
91870: LD_INT 4
91872: DOUBLE
91873: EQUAL
91874: IFTRUE 91878
91876: GO 91885
91878: POP
// hHackInvincible ; 5 :
91879: CALL 104759 0 0
91883: GO 91946
91885: LD_INT 5
91887: DOUBLE
91888: EQUAL
91889: IFTRUE 91893
91891: GO 91900
91893: POP
// hHackInvisible ; 6 :
91894: CALL 104870 0 0
91898: GO 91946
91900: LD_INT 6
91902: DOUBLE
91903: EQUAL
91904: IFTRUE 91908
91906: GO 91915
91908: POP
// hHackChangeYourSide ; 7 :
91909: CALL 104927 0 0
91913: GO 91946
91915: LD_INT 7
91917: DOUBLE
91918: EQUAL
91919: IFTRUE 91923
91921: GO 91930
91923: POP
// hHackChangeUnitSide ; 8 :
91924: CALL 104969 0 0
91928: GO 91946
91930: LD_INT 8
91932: DOUBLE
91933: EQUAL
91934: IFTRUE 91938
91936: GO 91945
91938: POP
// hHackFog ; end ;
91939: CALL 105070 0 0
91943: GO 91946
91945: POP
// end ; if p2 = game_save_mode then
91946: LD_VAR 0 2
91950: PUSH
91951: LD_INT 102
91953: EQUAL
91954: IFFALSE 92009
// begin if p3 = 1 then
91956: LD_VAR 0 3
91960: PUSH
91961: LD_INT 1
91963: EQUAL
91964: IFFALSE 91976
// globalGameSaveCounter := p4 ;
91966: LD_ADDR_EXP 95
91970: PUSH
91971: LD_VAR 0 4
91975: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91976: LD_VAR 0 3
91980: PUSH
91981: LD_INT 2
91983: EQUAL
91984: PUSH
91985: LD_EXP 95
91989: AND
91990: IFFALSE 92009
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91992: LD_STRING setGameSaveCounter(
91994: PUSH
91995: LD_EXP 95
91999: STR
92000: PUSH
92001: LD_STRING )
92003: STR
92004: PPUSH
92005: CALL_OW 559
// end ; end ;
92009: LD_VAR 0 7
92013: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92014: LD_INT 0
92016: PPUSH
// streamModeActive := false ;
92017: LD_ADDR_EXP 96
92021: PUSH
92022: LD_INT 0
92024: ST_TO_ADDR
// normalCounter := 36 ;
92025: LD_ADDR_EXP 97
92029: PUSH
92030: LD_INT 36
92032: ST_TO_ADDR
// hardcoreCounter := 18 ;
92033: LD_ADDR_EXP 98
92037: PUSH
92038: LD_INT 18
92040: ST_TO_ADDR
// sRocket := false ;
92041: LD_ADDR_EXP 101
92045: PUSH
92046: LD_INT 0
92048: ST_TO_ADDR
// sSpeed := false ;
92049: LD_ADDR_EXP 100
92053: PUSH
92054: LD_INT 0
92056: ST_TO_ADDR
// sEngine := false ;
92057: LD_ADDR_EXP 102
92061: PUSH
92062: LD_INT 0
92064: ST_TO_ADDR
// sSpec := false ;
92065: LD_ADDR_EXP 99
92069: PUSH
92070: LD_INT 0
92072: ST_TO_ADDR
// sLevel := false ;
92073: LD_ADDR_EXP 103
92077: PUSH
92078: LD_INT 0
92080: ST_TO_ADDR
// sArmoury := false ;
92081: LD_ADDR_EXP 104
92085: PUSH
92086: LD_INT 0
92088: ST_TO_ADDR
// sRadar := false ;
92089: LD_ADDR_EXP 105
92093: PUSH
92094: LD_INT 0
92096: ST_TO_ADDR
// sBunker := false ;
92097: LD_ADDR_EXP 106
92101: PUSH
92102: LD_INT 0
92104: ST_TO_ADDR
// sHack := false ;
92105: LD_ADDR_EXP 107
92109: PUSH
92110: LD_INT 0
92112: ST_TO_ADDR
// sFire := false ;
92113: LD_ADDR_EXP 108
92117: PUSH
92118: LD_INT 0
92120: ST_TO_ADDR
// sRefresh := false ;
92121: LD_ADDR_EXP 109
92125: PUSH
92126: LD_INT 0
92128: ST_TO_ADDR
// sExp := false ;
92129: LD_ADDR_EXP 110
92133: PUSH
92134: LD_INT 0
92136: ST_TO_ADDR
// sDepot := false ;
92137: LD_ADDR_EXP 111
92141: PUSH
92142: LD_INT 0
92144: ST_TO_ADDR
// sFlag := false ;
92145: LD_ADDR_EXP 112
92149: PUSH
92150: LD_INT 0
92152: ST_TO_ADDR
// sKamikadze := false ;
92153: LD_ADDR_EXP 120
92157: PUSH
92158: LD_INT 0
92160: ST_TO_ADDR
// sTroll := false ;
92161: LD_ADDR_EXP 121
92165: PUSH
92166: LD_INT 0
92168: ST_TO_ADDR
// sSlow := false ;
92169: LD_ADDR_EXP 122
92173: PUSH
92174: LD_INT 0
92176: ST_TO_ADDR
// sLack := false ;
92177: LD_ADDR_EXP 123
92181: PUSH
92182: LD_INT 0
92184: ST_TO_ADDR
// sTank := false ;
92185: LD_ADDR_EXP 125
92189: PUSH
92190: LD_INT 0
92192: ST_TO_ADDR
// sRemote := false ;
92193: LD_ADDR_EXP 126
92197: PUSH
92198: LD_INT 0
92200: ST_TO_ADDR
// sPowell := false ;
92201: LD_ADDR_EXP 127
92205: PUSH
92206: LD_INT 0
92208: ST_TO_ADDR
// sTeleport := false ;
92209: LD_ADDR_EXP 130
92213: PUSH
92214: LD_INT 0
92216: ST_TO_ADDR
// sOilTower := false ;
92217: LD_ADDR_EXP 132
92221: PUSH
92222: LD_INT 0
92224: ST_TO_ADDR
// sShovel := false ;
92225: LD_ADDR_EXP 133
92229: PUSH
92230: LD_INT 0
92232: ST_TO_ADDR
// sSheik := false ;
92233: LD_ADDR_EXP 134
92237: PUSH
92238: LD_INT 0
92240: ST_TO_ADDR
// sEarthquake := false ;
92241: LD_ADDR_EXP 136
92245: PUSH
92246: LD_INT 0
92248: ST_TO_ADDR
// sAI := false ;
92249: LD_ADDR_EXP 137
92253: PUSH
92254: LD_INT 0
92256: ST_TO_ADDR
// sCargo := false ;
92257: LD_ADDR_EXP 140
92261: PUSH
92262: LD_INT 0
92264: ST_TO_ADDR
// sDLaser := false ;
92265: LD_ADDR_EXP 141
92269: PUSH
92270: LD_INT 0
92272: ST_TO_ADDR
// sExchange := false ;
92273: LD_ADDR_EXP 142
92277: PUSH
92278: LD_INT 0
92280: ST_TO_ADDR
// sFac := false ;
92281: LD_ADDR_EXP 143
92285: PUSH
92286: LD_INT 0
92288: ST_TO_ADDR
// sPower := false ;
92289: LD_ADDR_EXP 144
92293: PUSH
92294: LD_INT 0
92296: ST_TO_ADDR
// sRandom := false ;
92297: LD_ADDR_EXP 145
92301: PUSH
92302: LD_INT 0
92304: ST_TO_ADDR
// sShield := false ;
92305: LD_ADDR_EXP 146
92309: PUSH
92310: LD_INT 0
92312: ST_TO_ADDR
// sTime := false ;
92313: LD_ADDR_EXP 147
92317: PUSH
92318: LD_INT 0
92320: ST_TO_ADDR
// sTools := false ;
92321: LD_ADDR_EXP 148
92325: PUSH
92326: LD_INT 0
92328: ST_TO_ADDR
// sSold := false ;
92329: LD_ADDR_EXP 113
92333: PUSH
92334: LD_INT 0
92336: ST_TO_ADDR
// sDiff := false ;
92337: LD_ADDR_EXP 114
92341: PUSH
92342: LD_INT 0
92344: ST_TO_ADDR
// sFog := false ;
92345: LD_ADDR_EXP 117
92349: PUSH
92350: LD_INT 0
92352: ST_TO_ADDR
// sReset := false ;
92353: LD_ADDR_EXP 118
92357: PUSH
92358: LD_INT 0
92360: ST_TO_ADDR
// sSun := false ;
92361: LD_ADDR_EXP 119
92365: PUSH
92366: LD_INT 0
92368: ST_TO_ADDR
// sTiger := false ;
92369: LD_ADDR_EXP 115
92373: PUSH
92374: LD_INT 0
92376: ST_TO_ADDR
// sBomb := false ;
92377: LD_ADDR_EXP 116
92381: PUSH
92382: LD_INT 0
92384: ST_TO_ADDR
// sWound := false ;
92385: LD_ADDR_EXP 124
92389: PUSH
92390: LD_INT 0
92392: ST_TO_ADDR
// sBetray := false ;
92393: LD_ADDR_EXP 128
92397: PUSH
92398: LD_INT 0
92400: ST_TO_ADDR
// sContamin := false ;
92401: LD_ADDR_EXP 129
92405: PUSH
92406: LD_INT 0
92408: ST_TO_ADDR
// sOil := false ;
92409: LD_ADDR_EXP 131
92413: PUSH
92414: LD_INT 0
92416: ST_TO_ADDR
// sStu := false ;
92417: LD_ADDR_EXP 135
92421: PUSH
92422: LD_INT 0
92424: ST_TO_ADDR
// sBazooka := false ;
92425: LD_ADDR_EXP 138
92429: PUSH
92430: LD_INT 0
92432: ST_TO_ADDR
// sMortar := false ;
92433: LD_ADDR_EXP 139
92437: PUSH
92438: LD_INT 0
92440: ST_TO_ADDR
// sRanger := false ;
92441: LD_ADDR_EXP 149
92445: PUSH
92446: LD_INT 0
92448: ST_TO_ADDR
// sComputer := false ;
92449: LD_ADDR_EXP 150
92453: PUSH
92454: LD_INT 0
92456: ST_TO_ADDR
// s30 := false ;
92457: LD_ADDR_EXP 151
92461: PUSH
92462: LD_INT 0
92464: ST_TO_ADDR
// s60 := false ;
92465: LD_ADDR_EXP 152
92469: PUSH
92470: LD_INT 0
92472: ST_TO_ADDR
// end ;
92473: LD_VAR 0 1
92477: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92478: LD_INT 0
92480: PPUSH
92481: PPUSH
92482: PPUSH
92483: PPUSH
92484: PPUSH
92485: PPUSH
92486: PPUSH
// result := [ ] ;
92487: LD_ADDR_VAR 0 2
92491: PUSH
92492: EMPTY
92493: ST_TO_ADDR
// if campaign_id = 1 then
92494: LD_OWVAR 69
92498: PUSH
92499: LD_INT 1
92501: EQUAL
92502: IFFALSE 95668
// begin case mission_number of 1 :
92504: LD_OWVAR 70
92508: PUSH
92509: LD_INT 1
92511: DOUBLE
92512: EQUAL
92513: IFTRUE 92517
92515: GO 92593
92517: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92518: LD_ADDR_VAR 0 2
92522: PUSH
92523: LD_INT 2
92525: PUSH
92526: LD_INT 4
92528: PUSH
92529: LD_INT 11
92531: PUSH
92532: LD_INT 12
92534: PUSH
92535: LD_INT 15
92537: PUSH
92538: LD_INT 16
92540: PUSH
92541: LD_INT 22
92543: PUSH
92544: LD_INT 23
92546: PUSH
92547: LD_INT 26
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: PUSH
92561: LD_INT 101
92563: PUSH
92564: LD_INT 102
92566: PUSH
92567: LD_INT 106
92569: PUSH
92570: LD_INT 116
92572: PUSH
92573: LD_INT 117
92575: PUSH
92576: LD_INT 118
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: ST_TO_ADDR
92591: GO 95666
92593: LD_INT 2
92595: DOUBLE
92596: EQUAL
92597: IFTRUE 92601
92599: GO 92685
92601: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92602: LD_ADDR_VAR 0 2
92606: PUSH
92607: LD_INT 2
92609: PUSH
92610: LD_INT 4
92612: PUSH
92613: LD_INT 11
92615: PUSH
92616: LD_INT 12
92618: PUSH
92619: LD_INT 15
92621: PUSH
92622: LD_INT 16
92624: PUSH
92625: LD_INT 22
92627: PUSH
92628: LD_INT 23
92630: PUSH
92631: LD_INT 26
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 101
92647: PUSH
92648: LD_INT 102
92650: PUSH
92651: LD_INT 105
92653: PUSH
92654: LD_INT 106
92656: PUSH
92657: LD_INT 108
92659: PUSH
92660: LD_INT 116
92662: PUSH
92663: LD_INT 117
92665: PUSH
92666: LD_INT 118
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: ST_TO_ADDR
92683: GO 95666
92685: LD_INT 3
92687: DOUBLE
92688: EQUAL
92689: IFTRUE 92693
92691: GO 92781
92693: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92694: LD_ADDR_VAR 0 2
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 4
92704: PUSH
92705: LD_INT 5
92707: PUSH
92708: LD_INT 11
92710: PUSH
92711: LD_INT 12
92713: PUSH
92714: LD_INT 15
92716: PUSH
92717: LD_INT 16
92719: PUSH
92720: LD_INT 22
92722: PUSH
92723: LD_INT 26
92725: PUSH
92726: LD_INT 36
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 101
92743: PUSH
92744: LD_INT 102
92746: PUSH
92747: LD_INT 105
92749: PUSH
92750: LD_INT 106
92752: PUSH
92753: LD_INT 108
92755: PUSH
92756: LD_INT 116
92758: PUSH
92759: LD_INT 117
92761: PUSH
92762: LD_INT 118
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: ST_TO_ADDR
92779: GO 95666
92781: LD_INT 4
92783: DOUBLE
92784: EQUAL
92785: IFTRUE 92789
92787: GO 92885
92789: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92790: LD_ADDR_VAR 0 2
92794: PUSH
92795: LD_INT 2
92797: PUSH
92798: LD_INT 4
92800: PUSH
92801: LD_INT 5
92803: PUSH
92804: LD_INT 8
92806: PUSH
92807: LD_INT 11
92809: PUSH
92810: LD_INT 12
92812: PUSH
92813: LD_INT 15
92815: PUSH
92816: LD_INT 16
92818: PUSH
92819: LD_INT 22
92821: PUSH
92822: LD_INT 23
92824: PUSH
92825: LD_INT 26
92827: PUSH
92828: LD_INT 36
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 101
92847: PUSH
92848: LD_INT 102
92850: PUSH
92851: LD_INT 105
92853: PUSH
92854: LD_INT 106
92856: PUSH
92857: LD_INT 108
92859: PUSH
92860: LD_INT 116
92862: PUSH
92863: LD_INT 117
92865: PUSH
92866: LD_INT 118
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: ST_TO_ADDR
92883: GO 95666
92885: LD_INT 5
92887: DOUBLE
92888: EQUAL
92889: IFTRUE 92893
92891: GO 93005
92893: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92894: LD_ADDR_VAR 0 2
92898: PUSH
92899: LD_INT 2
92901: PUSH
92902: LD_INT 4
92904: PUSH
92905: LD_INT 5
92907: PUSH
92908: LD_INT 6
92910: PUSH
92911: LD_INT 8
92913: PUSH
92914: LD_INT 11
92916: PUSH
92917: LD_INT 12
92919: PUSH
92920: LD_INT 15
92922: PUSH
92923: LD_INT 16
92925: PUSH
92926: LD_INT 22
92928: PUSH
92929: LD_INT 23
92931: PUSH
92932: LD_INT 25
92934: PUSH
92935: LD_INT 26
92937: PUSH
92938: LD_INT 36
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 101
92959: PUSH
92960: LD_INT 102
92962: PUSH
92963: LD_INT 105
92965: PUSH
92966: LD_INT 106
92968: PUSH
92969: LD_INT 108
92971: PUSH
92972: LD_INT 109
92974: PUSH
92975: LD_INT 112
92977: PUSH
92978: LD_INT 116
92980: PUSH
92981: LD_INT 117
92983: PUSH
92984: LD_INT 118
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: ST_TO_ADDR
93003: GO 95666
93005: LD_INT 6
93007: DOUBLE
93008: EQUAL
93009: IFTRUE 93013
93011: GO 93145
93013: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93014: LD_ADDR_VAR 0 2
93018: PUSH
93019: LD_INT 2
93021: PUSH
93022: LD_INT 4
93024: PUSH
93025: LD_INT 5
93027: PUSH
93028: LD_INT 6
93030: PUSH
93031: LD_INT 8
93033: PUSH
93034: LD_INT 11
93036: PUSH
93037: LD_INT 12
93039: PUSH
93040: LD_INT 15
93042: PUSH
93043: LD_INT 16
93045: PUSH
93046: LD_INT 20
93048: PUSH
93049: LD_INT 21
93051: PUSH
93052: LD_INT 22
93054: PUSH
93055: LD_INT 23
93057: PUSH
93058: LD_INT 25
93060: PUSH
93061: LD_INT 26
93063: PUSH
93064: LD_INT 30
93066: PUSH
93067: LD_INT 31
93069: PUSH
93070: LD_INT 32
93072: PUSH
93073: LD_INT 36
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 101
93099: PUSH
93100: LD_INT 102
93102: PUSH
93103: LD_INT 105
93105: PUSH
93106: LD_INT 106
93108: PUSH
93109: LD_INT 108
93111: PUSH
93112: LD_INT 109
93114: PUSH
93115: LD_INT 112
93117: PUSH
93118: LD_INT 116
93120: PUSH
93121: LD_INT 117
93123: PUSH
93124: LD_INT 118
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: ST_TO_ADDR
93143: GO 95666
93145: LD_INT 7
93147: DOUBLE
93148: EQUAL
93149: IFTRUE 93153
93151: GO 93265
93153: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93154: LD_ADDR_VAR 0 2
93158: PUSH
93159: LD_INT 2
93161: PUSH
93162: LD_INT 4
93164: PUSH
93165: LD_INT 5
93167: PUSH
93168: LD_INT 7
93170: PUSH
93171: LD_INT 11
93173: PUSH
93174: LD_INT 12
93176: PUSH
93177: LD_INT 15
93179: PUSH
93180: LD_INT 16
93182: PUSH
93183: LD_INT 20
93185: PUSH
93186: LD_INT 21
93188: PUSH
93189: LD_INT 22
93191: PUSH
93192: LD_INT 23
93194: PUSH
93195: LD_INT 25
93197: PUSH
93198: LD_INT 26
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 101
93219: PUSH
93220: LD_INT 102
93222: PUSH
93223: LD_INT 103
93225: PUSH
93226: LD_INT 105
93228: PUSH
93229: LD_INT 106
93231: PUSH
93232: LD_INT 108
93234: PUSH
93235: LD_INT 112
93237: PUSH
93238: LD_INT 116
93240: PUSH
93241: LD_INT 117
93243: PUSH
93244: LD_INT 118
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: ST_TO_ADDR
93263: GO 95666
93265: LD_INT 8
93267: DOUBLE
93268: EQUAL
93269: IFTRUE 93273
93271: GO 93413
93273: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93274: LD_ADDR_VAR 0 2
93278: PUSH
93279: LD_INT 2
93281: PUSH
93282: LD_INT 4
93284: PUSH
93285: LD_INT 5
93287: PUSH
93288: LD_INT 6
93290: PUSH
93291: LD_INT 7
93293: PUSH
93294: LD_INT 8
93296: PUSH
93297: LD_INT 11
93299: PUSH
93300: LD_INT 12
93302: PUSH
93303: LD_INT 15
93305: PUSH
93306: LD_INT 16
93308: PUSH
93309: LD_INT 20
93311: PUSH
93312: LD_INT 21
93314: PUSH
93315: LD_INT 22
93317: PUSH
93318: LD_INT 23
93320: PUSH
93321: LD_INT 25
93323: PUSH
93324: LD_INT 26
93326: PUSH
93327: LD_INT 30
93329: PUSH
93330: LD_INT 31
93332: PUSH
93333: LD_INT 32
93335: PUSH
93336: LD_INT 36
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 101
93363: PUSH
93364: LD_INT 102
93366: PUSH
93367: LD_INT 103
93369: PUSH
93370: LD_INT 105
93372: PUSH
93373: LD_INT 106
93375: PUSH
93376: LD_INT 108
93378: PUSH
93379: LD_INT 109
93381: PUSH
93382: LD_INT 112
93384: PUSH
93385: LD_INT 116
93387: PUSH
93388: LD_INT 117
93390: PUSH
93391: LD_INT 118
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: ST_TO_ADDR
93411: GO 95666
93413: LD_INT 9
93415: DOUBLE
93416: EQUAL
93417: IFTRUE 93421
93419: GO 93569
93421: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93422: LD_ADDR_VAR 0 2
93426: PUSH
93427: LD_INT 2
93429: PUSH
93430: LD_INT 4
93432: PUSH
93433: LD_INT 5
93435: PUSH
93436: LD_INT 6
93438: PUSH
93439: LD_INT 7
93441: PUSH
93442: LD_INT 8
93444: PUSH
93445: LD_INT 11
93447: PUSH
93448: LD_INT 12
93450: PUSH
93451: LD_INT 15
93453: PUSH
93454: LD_INT 16
93456: PUSH
93457: LD_INT 20
93459: PUSH
93460: LD_INT 21
93462: PUSH
93463: LD_INT 22
93465: PUSH
93466: LD_INT 23
93468: PUSH
93469: LD_INT 25
93471: PUSH
93472: LD_INT 26
93474: PUSH
93475: LD_INT 28
93477: PUSH
93478: LD_INT 30
93480: PUSH
93481: LD_INT 31
93483: PUSH
93484: LD_INT 32
93486: PUSH
93487: LD_INT 36
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: PUSH
93513: LD_INT 101
93515: PUSH
93516: LD_INT 102
93518: PUSH
93519: LD_INT 103
93521: PUSH
93522: LD_INT 105
93524: PUSH
93525: LD_INT 106
93527: PUSH
93528: LD_INT 108
93530: PUSH
93531: LD_INT 109
93533: PUSH
93534: LD_INT 112
93536: PUSH
93537: LD_INT 114
93539: PUSH
93540: LD_INT 116
93542: PUSH
93543: LD_INT 117
93545: PUSH
93546: LD_INT 118
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: ST_TO_ADDR
93567: GO 95666
93569: LD_INT 10
93571: DOUBLE
93572: EQUAL
93573: IFTRUE 93577
93575: GO 93773
93577: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93578: LD_ADDR_VAR 0 2
93582: PUSH
93583: LD_INT 2
93585: PUSH
93586: LD_INT 4
93588: PUSH
93589: LD_INT 5
93591: PUSH
93592: LD_INT 6
93594: PUSH
93595: LD_INT 7
93597: PUSH
93598: LD_INT 8
93600: PUSH
93601: LD_INT 9
93603: PUSH
93604: LD_INT 10
93606: PUSH
93607: LD_INT 11
93609: PUSH
93610: LD_INT 12
93612: PUSH
93613: LD_INT 13
93615: PUSH
93616: LD_INT 14
93618: PUSH
93619: LD_INT 15
93621: PUSH
93622: LD_INT 16
93624: PUSH
93625: LD_INT 17
93627: PUSH
93628: LD_INT 18
93630: PUSH
93631: LD_INT 19
93633: PUSH
93634: LD_INT 20
93636: PUSH
93637: LD_INT 21
93639: PUSH
93640: LD_INT 22
93642: PUSH
93643: LD_INT 23
93645: PUSH
93646: LD_INT 24
93648: PUSH
93649: LD_INT 25
93651: PUSH
93652: LD_INT 26
93654: PUSH
93655: LD_INT 28
93657: PUSH
93658: LD_INT 30
93660: PUSH
93661: LD_INT 31
93663: PUSH
93664: LD_INT 32
93666: PUSH
93667: LD_INT 36
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 101
93703: PUSH
93704: LD_INT 102
93706: PUSH
93707: LD_INT 103
93709: PUSH
93710: LD_INT 104
93712: PUSH
93713: LD_INT 105
93715: PUSH
93716: LD_INT 106
93718: PUSH
93719: LD_INT 107
93721: PUSH
93722: LD_INT 108
93724: PUSH
93725: LD_INT 109
93727: PUSH
93728: LD_INT 110
93730: PUSH
93731: LD_INT 111
93733: PUSH
93734: LD_INT 112
93736: PUSH
93737: LD_INT 114
93739: PUSH
93740: LD_INT 116
93742: PUSH
93743: LD_INT 117
93745: PUSH
93746: LD_INT 118
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: ST_TO_ADDR
93771: GO 95666
93773: LD_INT 11
93775: DOUBLE
93776: EQUAL
93777: IFTRUE 93781
93779: GO 93985
93781: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93782: LD_ADDR_VAR 0 2
93786: PUSH
93787: LD_INT 2
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: LD_INT 4
93795: PUSH
93796: LD_INT 5
93798: PUSH
93799: LD_INT 6
93801: PUSH
93802: LD_INT 7
93804: PUSH
93805: LD_INT 8
93807: PUSH
93808: LD_INT 9
93810: PUSH
93811: LD_INT 10
93813: PUSH
93814: LD_INT 11
93816: PUSH
93817: LD_INT 12
93819: PUSH
93820: LD_INT 13
93822: PUSH
93823: LD_INT 14
93825: PUSH
93826: LD_INT 15
93828: PUSH
93829: LD_INT 16
93831: PUSH
93832: LD_INT 17
93834: PUSH
93835: LD_INT 18
93837: PUSH
93838: LD_INT 19
93840: PUSH
93841: LD_INT 20
93843: PUSH
93844: LD_INT 21
93846: PUSH
93847: LD_INT 22
93849: PUSH
93850: LD_INT 23
93852: PUSH
93853: LD_INT 24
93855: PUSH
93856: LD_INT 25
93858: PUSH
93859: LD_INT 26
93861: PUSH
93862: LD_INT 28
93864: PUSH
93865: LD_INT 30
93867: PUSH
93868: LD_INT 31
93870: PUSH
93871: LD_INT 32
93873: PUSH
93874: LD_INT 34
93876: PUSH
93877: LD_INT 36
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 101
93915: PUSH
93916: LD_INT 102
93918: PUSH
93919: LD_INT 103
93921: PUSH
93922: LD_INT 104
93924: PUSH
93925: LD_INT 105
93927: PUSH
93928: LD_INT 106
93930: PUSH
93931: LD_INT 107
93933: PUSH
93934: LD_INT 108
93936: PUSH
93937: LD_INT 109
93939: PUSH
93940: LD_INT 110
93942: PUSH
93943: LD_INT 111
93945: PUSH
93946: LD_INT 112
93948: PUSH
93949: LD_INT 114
93951: PUSH
93952: LD_INT 116
93954: PUSH
93955: LD_INT 117
93957: PUSH
93958: LD_INT 118
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: ST_TO_ADDR
93983: GO 95666
93985: LD_INT 12
93987: DOUBLE
93988: EQUAL
93989: IFTRUE 93993
93991: GO 94213
93993: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93994: LD_ADDR_VAR 0 2
93998: PUSH
93999: LD_INT 1
94001: PUSH
94002: LD_INT 2
94004: PUSH
94005: LD_INT 3
94007: PUSH
94008: LD_INT 4
94010: PUSH
94011: LD_INT 5
94013: PUSH
94014: LD_INT 6
94016: PUSH
94017: LD_INT 7
94019: PUSH
94020: LD_INT 8
94022: PUSH
94023: LD_INT 9
94025: PUSH
94026: LD_INT 10
94028: PUSH
94029: LD_INT 11
94031: PUSH
94032: LD_INT 12
94034: PUSH
94035: LD_INT 13
94037: PUSH
94038: LD_INT 14
94040: PUSH
94041: LD_INT 15
94043: PUSH
94044: LD_INT 16
94046: PUSH
94047: LD_INT 17
94049: PUSH
94050: LD_INT 18
94052: PUSH
94053: LD_INT 19
94055: PUSH
94056: LD_INT 20
94058: PUSH
94059: LD_INT 21
94061: PUSH
94062: LD_INT 22
94064: PUSH
94065: LD_INT 23
94067: PUSH
94068: LD_INT 24
94070: PUSH
94071: LD_INT 25
94073: PUSH
94074: LD_INT 26
94076: PUSH
94077: LD_INT 27
94079: PUSH
94080: LD_INT 28
94082: PUSH
94083: LD_INT 30
94085: PUSH
94086: LD_INT 31
94088: PUSH
94089: LD_INT 32
94091: PUSH
94092: LD_INT 33
94094: PUSH
94095: LD_INT 34
94097: PUSH
94098: LD_INT 36
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 101
94139: PUSH
94140: LD_INT 102
94142: PUSH
94143: LD_INT 103
94145: PUSH
94146: LD_INT 104
94148: PUSH
94149: LD_INT 105
94151: PUSH
94152: LD_INT 106
94154: PUSH
94155: LD_INT 107
94157: PUSH
94158: LD_INT 108
94160: PUSH
94161: LD_INT 109
94163: PUSH
94164: LD_INT 110
94166: PUSH
94167: LD_INT 111
94169: PUSH
94170: LD_INT 112
94172: PUSH
94173: LD_INT 113
94175: PUSH
94176: LD_INT 114
94178: PUSH
94179: LD_INT 116
94181: PUSH
94182: LD_INT 117
94184: PUSH
94185: LD_INT 118
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: ST_TO_ADDR
94211: GO 95666
94213: LD_INT 13
94215: DOUBLE
94216: EQUAL
94217: IFTRUE 94221
94219: GO 94429
94221: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94222: LD_ADDR_VAR 0 2
94226: PUSH
94227: LD_INT 1
94229: PUSH
94230: LD_INT 2
94232: PUSH
94233: LD_INT 3
94235: PUSH
94236: LD_INT 4
94238: PUSH
94239: LD_INT 5
94241: PUSH
94242: LD_INT 8
94244: PUSH
94245: LD_INT 9
94247: PUSH
94248: LD_INT 10
94250: PUSH
94251: LD_INT 11
94253: PUSH
94254: LD_INT 12
94256: PUSH
94257: LD_INT 14
94259: PUSH
94260: LD_INT 15
94262: PUSH
94263: LD_INT 16
94265: PUSH
94266: LD_INT 17
94268: PUSH
94269: LD_INT 18
94271: PUSH
94272: LD_INT 19
94274: PUSH
94275: LD_INT 20
94277: PUSH
94278: LD_INT 21
94280: PUSH
94281: LD_INT 22
94283: PUSH
94284: LD_INT 23
94286: PUSH
94287: LD_INT 24
94289: PUSH
94290: LD_INT 25
94292: PUSH
94293: LD_INT 26
94295: PUSH
94296: LD_INT 27
94298: PUSH
94299: LD_INT 28
94301: PUSH
94302: LD_INT 30
94304: PUSH
94305: LD_INT 31
94307: PUSH
94308: LD_INT 32
94310: PUSH
94311: LD_INT 33
94313: PUSH
94314: LD_INT 34
94316: PUSH
94317: LD_INT 36
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 101
94355: PUSH
94356: LD_INT 102
94358: PUSH
94359: LD_INT 103
94361: PUSH
94362: LD_INT 104
94364: PUSH
94365: LD_INT 105
94367: PUSH
94368: LD_INT 106
94370: PUSH
94371: LD_INT 107
94373: PUSH
94374: LD_INT 108
94376: PUSH
94377: LD_INT 109
94379: PUSH
94380: LD_INT 110
94382: PUSH
94383: LD_INT 111
94385: PUSH
94386: LD_INT 112
94388: PUSH
94389: LD_INT 113
94391: PUSH
94392: LD_INT 114
94394: PUSH
94395: LD_INT 116
94397: PUSH
94398: LD_INT 117
94400: PUSH
94401: LD_INT 118
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: ST_TO_ADDR
94427: GO 95666
94429: LD_INT 14
94431: DOUBLE
94432: EQUAL
94433: IFTRUE 94437
94435: GO 94661
94437: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94438: LD_ADDR_VAR 0 2
94442: PUSH
94443: LD_INT 1
94445: PUSH
94446: LD_INT 2
94448: PUSH
94449: LD_INT 3
94451: PUSH
94452: LD_INT 4
94454: PUSH
94455: LD_INT 5
94457: PUSH
94458: LD_INT 6
94460: PUSH
94461: LD_INT 7
94463: PUSH
94464: LD_INT 8
94466: PUSH
94467: LD_INT 9
94469: PUSH
94470: LD_INT 10
94472: PUSH
94473: LD_INT 11
94475: PUSH
94476: LD_INT 12
94478: PUSH
94479: LD_INT 13
94481: PUSH
94482: LD_INT 14
94484: PUSH
94485: LD_INT 15
94487: PUSH
94488: LD_INT 16
94490: PUSH
94491: LD_INT 17
94493: PUSH
94494: LD_INT 18
94496: PUSH
94497: LD_INT 19
94499: PUSH
94500: LD_INT 20
94502: PUSH
94503: LD_INT 21
94505: PUSH
94506: LD_INT 22
94508: PUSH
94509: LD_INT 23
94511: PUSH
94512: LD_INT 24
94514: PUSH
94515: LD_INT 25
94517: PUSH
94518: LD_INT 26
94520: PUSH
94521: LD_INT 27
94523: PUSH
94524: LD_INT 28
94526: PUSH
94527: LD_INT 29
94529: PUSH
94530: LD_INT 30
94532: PUSH
94533: LD_INT 31
94535: PUSH
94536: LD_INT 32
94538: PUSH
94539: LD_INT 33
94541: PUSH
94542: LD_INT 34
94544: PUSH
94545: LD_INT 36
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 101
94587: PUSH
94588: LD_INT 102
94590: PUSH
94591: LD_INT 103
94593: PUSH
94594: LD_INT 104
94596: PUSH
94597: LD_INT 105
94599: PUSH
94600: LD_INT 106
94602: PUSH
94603: LD_INT 107
94605: PUSH
94606: LD_INT 108
94608: PUSH
94609: LD_INT 109
94611: PUSH
94612: LD_INT 110
94614: PUSH
94615: LD_INT 111
94617: PUSH
94618: LD_INT 112
94620: PUSH
94621: LD_INT 113
94623: PUSH
94624: LD_INT 114
94626: PUSH
94627: LD_INT 116
94629: PUSH
94630: LD_INT 117
94632: PUSH
94633: LD_INT 118
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: ST_TO_ADDR
94659: GO 95666
94661: LD_INT 15
94663: DOUBLE
94664: EQUAL
94665: IFTRUE 94669
94667: GO 94893
94669: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94670: LD_ADDR_VAR 0 2
94674: PUSH
94675: LD_INT 1
94677: PUSH
94678: LD_INT 2
94680: PUSH
94681: LD_INT 3
94683: PUSH
94684: LD_INT 4
94686: PUSH
94687: LD_INT 5
94689: PUSH
94690: LD_INT 6
94692: PUSH
94693: LD_INT 7
94695: PUSH
94696: LD_INT 8
94698: PUSH
94699: LD_INT 9
94701: PUSH
94702: LD_INT 10
94704: PUSH
94705: LD_INT 11
94707: PUSH
94708: LD_INT 12
94710: PUSH
94711: LD_INT 13
94713: PUSH
94714: LD_INT 14
94716: PUSH
94717: LD_INT 15
94719: PUSH
94720: LD_INT 16
94722: PUSH
94723: LD_INT 17
94725: PUSH
94726: LD_INT 18
94728: PUSH
94729: LD_INT 19
94731: PUSH
94732: LD_INT 20
94734: PUSH
94735: LD_INT 21
94737: PUSH
94738: LD_INT 22
94740: PUSH
94741: LD_INT 23
94743: PUSH
94744: LD_INT 24
94746: PUSH
94747: LD_INT 25
94749: PUSH
94750: LD_INT 26
94752: PUSH
94753: LD_INT 27
94755: PUSH
94756: LD_INT 28
94758: PUSH
94759: LD_INT 29
94761: PUSH
94762: LD_INT 30
94764: PUSH
94765: LD_INT 31
94767: PUSH
94768: LD_INT 32
94770: PUSH
94771: LD_INT 33
94773: PUSH
94774: LD_INT 34
94776: PUSH
94777: LD_INT 36
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 101
94819: PUSH
94820: LD_INT 102
94822: PUSH
94823: LD_INT 103
94825: PUSH
94826: LD_INT 104
94828: PUSH
94829: LD_INT 105
94831: PUSH
94832: LD_INT 106
94834: PUSH
94835: LD_INT 107
94837: PUSH
94838: LD_INT 108
94840: PUSH
94841: LD_INT 109
94843: PUSH
94844: LD_INT 110
94846: PUSH
94847: LD_INT 111
94849: PUSH
94850: LD_INT 112
94852: PUSH
94853: LD_INT 113
94855: PUSH
94856: LD_INT 114
94858: PUSH
94859: LD_INT 116
94861: PUSH
94862: LD_INT 117
94864: PUSH
94865: LD_INT 118
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: ST_TO_ADDR
94891: GO 95666
94893: LD_INT 16
94895: DOUBLE
94896: EQUAL
94897: IFTRUE 94901
94899: GO 95037
94901: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94902: LD_ADDR_VAR 0 2
94906: PUSH
94907: LD_INT 2
94909: PUSH
94910: LD_INT 4
94912: PUSH
94913: LD_INT 5
94915: PUSH
94916: LD_INT 7
94918: PUSH
94919: LD_INT 11
94921: PUSH
94922: LD_INT 12
94924: PUSH
94925: LD_INT 15
94927: PUSH
94928: LD_INT 16
94930: PUSH
94931: LD_INT 20
94933: PUSH
94934: LD_INT 21
94936: PUSH
94937: LD_INT 22
94939: PUSH
94940: LD_INT 23
94942: PUSH
94943: LD_INT 25
94945: PUSH
94946: LD_INT 26
94948: PUSH
94949: LD_INT 30
94951: PUSH
94952: LD_INT 31
94954: PUSH
94955: LD_INT 32
94957: PUSH
94958: LD_INT 33
94960: PUSH
94961: LD_INT 34
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 101
94987: PUSH
94988: LD_INT 102
94990: PUSH
94991: LD_INT 103
94993: PUSH
94994: LD_INT 106
94996: PUSH
94997: LD_INT 108
94999: PUSH
95000: LD_INT 112
95002: PUSH
95003: LD_INT 113
95005: PUSH
95006: LD_INT 114
95008: PUSH
95009: LD_INT 116
95011: PUSH
95012: LD_INT 117
95014: PUSH
95015: LD_INT 118
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: ST_TO_ADDR
95035: GO 95666
95037: LD_INT 17
95039: DOUBLE
95040: EQUAL
95041: IFTRUE 95045
95043: GO 95269
95045: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95046: LD_ADDR_VAR 0 2
95050: PUSH
95051: LD_INT 1
95053: PUSH
95054: LD_INT 2
95056: PUSH
95057: LD_INT 3
95059: PUSH
95060: LD_INT 4
95062: PUSH
95063: LD_INT 5
95065: PUSH
95066: LD_INT 6
95068: PUSH
95069: LD_INT 7
95071: PUSH
95072: LD_INT 8
95074: PUSH
95075: LD_INT 9
95077: PUSH
95078: LD_INT 10
95080: PUSH
95081: LD_INT 11
95083: PUSH
95084: LD_INT 12
95086: PUSH
95087: LD_INT 13
95089: PUSH
95090: LD_INT 14
95092: PUSH
95093: LD_INT 15
95095: PUSH
95096: LD_INT 16
95098: PUSH
95099: LD_INT 17
95101: PUSH
95102: LD_INT 18
95104: PUSH
95105: LD_INT 19
95107: PUSH
95108: LD_INT 20
95110: PUSH
95111: LD_INT 21
95113: PUSH
95114: LD_INT 22
95116: PUSH
95117: LD_INT 23
95119: PUSH
95120: LD_INT 24
95122: PUSH
95123: LD_INT 25
95125: PUSH
95126: LD_INT 26
95128: PUSH
95129: LD_INT 27
95131: PUSH
95132: LD_INT 28
95134: PUSH
95135: LD_INT 29
95137: PUSH
95138: LD_INT 30
95140: PUSH
95141: LD_INT 31
95143: PUSH
95144: LD_INT 32
95146: PUSH
95147: LD_INT 33
95149: PUSH
95150: LD_INT 34
95152: PUSH
95153: LD_INT 36
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 101
95195: PUSH
95196: LD_INT 102
95198: PUSH
95199: LD_INT 103
95201: PUSH
95202: LD_INT 104
95204: PUSH
95205: LD_INT 105
95207: PUSH
95208: LD_INT 106
95210: PUSH
95211: LD_INT 107
95213: PUSH
95214: LD_INT 108
95216: PUSH
95217: LD_INT 109
95219: PUSH
95220: LD_INT 110
95222: PUSH
95223: LD_INT 111
95225: PUSH
95226: LD_INT 112
95228: PUSH
95229: LD_INT 113
95231: PUSH
95232: LD_INT 114
95234: PUSH
95235: LD_INT 116
95237: PUSH
95238: LD_INT 117
95240: PUSH
95241: LD_INT 118
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: ST_TO_ADDR
95267: GO 95666
95269: LD_INT 18
95271: DOUBLE
95272: EQUAL
95273: IFTRUE 95277
95275: GO 95425
95277: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95278: LD_ADDR_VAR 0 2
95282: PUSH
95283: LD_INT 2
95285: PUSH
95286: LD_INT 4
95288: PUSH
95289: LD_INT 5
95291: PUSH
95292: LD_INT 7
95294: PUSH
95295: LD_INT 11
95297: PUSH
95298: LD_INT 12
95300: PUSH
95301: LD_INT 15
95303: PUSH
95304: LD_INT 16
95306: PUSH
95307: LD_INT 20
95309: PUSH
95310: LD_INT 21
95312: PUSH
95313: LD_INT 22
95315: PUSH
95316: LD_INT 23
95318: PUSH
95319: LD_INT 25
95321: PUSH
95322: LD_INT 26
95324: PUSH
95325: LD_INT 30
95327: PUSH
95328: LD_INT 31
95330: PUSH
95331: LD_INT 32
95333: PUSH
95334: LD_INT 33
95336: PUSH
95337: LD_INT 34
95339: PUSH
95340: LD_INT 35
95342: PUSH
95343: LD_INT 36
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 101
95371: PUSH
95372: LD_INT 102
95374: PUSH
95375: LD_INT 103
95377: PUSH
95378: LD_INT 106
95380: PUSH
95381: LD_INT 108
95383: PUSH
95384: LD_INT 112
95386: PUSH
95387: LD_INT 113
95389: PUSH
95390: LD_INT 114
95392: PUSH
95393: LD_INT 115
95395: PUSH
95396: LD_INT 116
95398: PUSH
95399: LD_INT 117
95401: PUSH
95402: LD_INT 118
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: PUSH
95419: EMPTY
95420: LIST
95421: LIST
95422: ST_TO_ADDR
95423: GO 95666
95425: LD_INT 19
95427: DOUBLE
95428: EQUAL
95429: IFTRUE 95433
95431: GO 95665
95433: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95434: LD_ADDR_VAR 0 2
95438: PUSH
95439: LD_INT 1
95441: PUSH
95442: LD_INT 2
95444: PUSH
95445: LD_INT 3
95447: PUSH
95448: LD_INT 4
95450: PUSH
95451: LD_INT 5
95453: PUSH
95454: LD_INT 6
95456: PUSH
95457: LD_INT 7
95459: PUSH
95460: LD_INT 8
95462: PUSH
95463: LD_INT 9
95465: PUSH
95466: LD_INT 10
95468: PUSH
95469: LD_INT 11
95471: PUSH
95472: LD_INT 12
95474: PUSH
95475: LD_INT 13
95477: PUSH
95478: LD_INT 14
95480: PUSH
95481: LD_INT 15
95483: PUSH
95484: LD_INT 16
95486: PUSH
95487: LD_INT 17
95489: PUSH
95490: LD_INT 18
95492: PUSH
95493: LD_INT 19
95495: PUSH
95496: LD_INT 20
95498: PUSH
95499: LD_INT 21
95501: PUSH
95502: LD_INT 22
95504: PUSH
95505: LD_INT 23
95507: PUSH
95508: LD_INT 24
95510: PUSH
95511: LD_INT 25
95513: PUSH
95514: LD_INT 26
95516: PUSH
95517: LD_INT 27
95519: PUSH
95520: LD_INT 28
95522: PUSH
95523: LD_INT 29
95525: PUSH
95526: LD_INT 30
95528: PUSH
95529: LD_INT 31
95531: PUSH
95532: LD_INT 32
95534: PUSH
95535: LD_INT 33
95537: PUSH
95538: LD_INT 34
95540: PUSH
95541: LD_INT 35
95543: PUSH
95544: LD_INT 36
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 101
95587: PUSH
95588: LD_INT 102
95590: PUSH
95591: LD_INT 103
95593: PUSH
95594: LD_INT 104
95596: PUSH
95597: LD_INT 105
95599: PUSH
95600: LD_INT 106
95602: PUSH
95603: LD_INT 107
95605: PUSH
95606: LD_INT 108
95608: PUSH
95609: LD_INT 109
95611: PUSH
95612: LD_INT 110
95614: PUSH
95615: LD_INT 111
95617: PUSH
95618: LD_INT 112
95620: PUSH
95621: LD_INT 113
95623: PUSH
95624: LD_INT 114
95626: PUSH
95627: LD_INT 115
95629: PUSH
95630: LD_INT 116
95632: PUSH
95633: LD_INT 117
95635: PUSH
95636: LD_INT 118
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: ST_TO_ADDR
95663: GO 95666
95665: POP
// end else
95666: GO 95897
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95668: LD_ADDR_VAR 0 2
95672: PUSH
95673: LD_INT 1
95675: PUSH
95676: LD_INT 2
95678: PUSH
95679: LD_INT 3
95681: PUSH
95682: LD_INT 4
95684: PUSH
95685: LD_INT 5
95687: PUSH
95688: LD_INT 6
95690: PUSH
95691: LD_INT 7
95693: PUSH
95694: LD_INT 8
95696: PUSH
95697: LD_INT 9
95699: PUSH
95700: LD_INT 10
95702: PUSH
95703: LD_INT 11
95705: PUSH
95706: LD_INT 12
95708: PUSH
95709: LD_INT 13
95711: PUSH
95712: LD_INT 14
95714: PUSH
95715: LD_INT 15
95717: PUSH
95718: LD_INT 16
95720: PUSH
95721: LD_INT 17
95723: PUSH
95724: LD_INT 18
95726: PUSH
95727: LD_INT 19
95729: PUSH
95730: LD_INT 20
95732: PUSH
95733: LD_INT 21
95735: PUSH
95736: LD_INT 22
95738: PUSH
95739: LD_INT 23
95741: PUSH
95742: LD_INT 24
95744: PUSH
95745: LD_INT 25
95747: PUSH
95748: LD_INT 26
95750: PUSH
95751: LD_INT 27
95753: PUSH
95754: LD_INT 28
95756: PUSH
95757: LD_INT 29
95759: PUSH
95760: LD_INT 30
95762: PUSH
95763: LD_INT 31
95765: PUSH
95766: LD_INT 32
95768: PUSH
95769: LD_INT 33
95771: PUSH
95772: LD_INT 34
95774: PUSH
95775: LD_INT 35
95777: PUSH
95778: LD_INT 36
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 101
95821: PUSH
95822: LD_INT 102
95824: PUSH
95825: LD_INT 103
95827: PUSH
95828: LD_INT 104
95830: PUSH
95831: LD_INT 105
95833: PUSH
95834: LD_INT 106
95836: PUSH
95837: LD_INT 107
95839: PUSH
95840: LD_INT 108
95842: PUSH
95843: LD_INT 109
95845: PUSH
95846: LD_INT 110
95848: PUSH
95849: LD_INT 111
95851: PUSH
95852: LD_INT 112
95854: PUSH
95855: LD_INT 113
95857: PUSH
95858: LD_INT 114
95860: PUSH
95861: LD_INT 115
95863: PUSH
95864: LD_INT 116
95866: PUSH
95867: LD_INT 117
95869: PUSH
95870: LD_INT 118
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: ST_TO_ADDR
// if result then
95897: LD_VAR 0 2
95901: IFFALSE 96687
// begin normal :=  ;
95903: LD_ADDR_VAR 0 5
95907: PUSH
95908: LD_STRING 
95910: ST_TO_ADDR
// hardcore :=  ;
95911: LD_ADDR_VAR 0 6
95915: PUSH
95916: LD_STRING 
95918: ST_TO_ADDR
// active :=  ;
95919: LD_ADDR_VAR 0 7
95923: PUSH
95924: LD_STRING 
95926: ST_TO_ADDR
// for i = 1 to normalCounter do
95927: LD_ADDR_VAR 0 8
95931: PUSH
95932: DOUBLE
95933: LD_INT 1
95935: DEC
95936: ST_TO_ADDR
95937: LD_EXP 97
95941: PUSH
95942: FOR_TO
95943: IFFALSE 96044
// begin tmp := 0 ;
95945: LD_ADDR_VAR 0 3
95949: PUSH
95950: LD_STRING 0
95952: ST_TO_ADDR
// if result [ 1 ] then
95953: LD_VAR 0 2
95957: PUSH
95958: LD_INT 1
95960: ARRAY
95961: IFFALSE 96026
// if result [ 1 ] [ 1 ] = i then
95963: LD_VAR 0 2
95967: PUSH
95968: LD_INT 1
95970: ARRAY
95971: PUSH
95972: LD_INT 1
95974: ARRAY
95975: PUSH
95976: LD_VAR 0 8
95980: EQUAL
95981: IFFALSE 96026
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95983: LD_ADDR_VAR 0 2
95987: PUSH
95988: LD_VAR 0 2
95992: PPUSH
95993: LD_INT 1
95995: PPUSH
95996: LD_VAR 0 2
96000: PUSH
96001: LD_INT 1
96003: ARRAY
96004: PPUSH
96005: LD_INT 1
96007: PPUSH
96008: CALL_OW 3
96012: PPUSH
96013: CALL_OW 1
96017: ST_TO_ADDR
// tmp := 1 ;
96018: LD_ADDR_VAR 0 3
96022: PUSH
96023: LD_STRING 1
96025: ST_TO_ADDR
// end ; normal := normal & tmp ;
96026: LD_ADDR_VAR 0 5
96030: PUSH
96031: LD_VAR 0 5
96035: PUSH
96036: LD_VAR 0 3
96040: STR
96041: ST_TO_ADDR
// end ;
96042: GO 95942
96044: POP
96045: POP
// for i = 1 to hardcoreCounter do
96046: LD_ADDR_VAR 0 8
96050: PUSH
96051: DOUBLE
96052: LD_INT 1
96054: DEC
96055: ST_TO_ADDR
96056: LD_EXP 98
96060: PUSH
96061: FOR_TO
96062: IFFALSE 96167
// begin tmp := 0 ;
96064: LD_ADDR_VAR 0 3
96068: PUSH
96069: LD_STRING 0
96071: ST_TO_ADDR
// if result [ 2 ] then
96072: LD_VAR 0 2
96076: PUSH
96077: LD_INT 2
96079: ARRAY
96080: IFFALSE 96149
// if result [ 2 ] [ 1 ] = 100 + i then
96082: LD_VAR 0 2
96086: PUSH
96087: LD_INT 2
96089: ARRAY
96090: PUSH
96091: LD_INT 1
96093: ARRAY
96094: PUSH
96095: LD_INT 100
96097: PUSH
96098: LD_VAR 0 8
96102: PLUS
96103: EQUAL
96104: IFFALSE 96149
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96106: LD_ADDR_VAR 0 2
96110: PUSH
96111: LD_VAR 0 2
96115: PPUSH
96116: LD_INT 2
96118: PPUSH
96119: LD_VAR 0 2
96123: PUSH
96124: LD_INT 2
96126: ARRAY
96127: PPUSH
96128: LD_INT 1
96130: PPUSH
96131: CALL_OW 3
96135: PPUSH
96136: CALL_OW 1
96140: ST_TO_ADDR
// tmp := 1 ;
96141: LD_ADDR_VAR 0 3
96145: PUSH
96146: LD_STRING 1
96148: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96149: LD_ADDR_VAR 0 6
96153: PUSH
96154: LD_VAR 0 6
96158: PUSH
96159: LD_VAR 0 3
96163: STR
96164: ST_TO_ADDR
// end ;
96165: GO 96061
96167: POP
96168: POP
// if isGameLoad then
96169: LD_VAR 0 1
96173: IFFALSE 96648
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96175: LD_ADDR_VAR 0 4
96179: PUSH
96180: LD_EXP 101
96184: PUSH
96185: LD_EXP 100
96189: PUSH
96190: LD_EXP 102
96194: PUSH
96195: LD_EXP 99
96199: PUSH
96200: LD_EXP 103
96204: PUSH
96205: LD_EXP 104
96209: PUSH
96210: LD_EXP 105
96214: PUSH
96215: LD_EXP 106
96219: PUSH
96220: LD_EXP 107
96224: PUSH
96225: LD_EXP 108
96229: PUSH
96230: LD_EXP 109
96234: PUSH
96235: LD_EXP 110
96239: PUSH
96240: LD_EXP 111
96244: PUSH
96245: LD_EXP 112
96249: PUSH
96250: LD_EXP 120
96254: PUSH
96255: LD_EXP 121
96259: PUSH
96260: LD_EXP 122
96264: PUSH
96265: LD_EXP 123
96269: PUSH
96270: LD_EXP 125
96274: PUSH
96275: LD_EXP 126
96279: PUSH
96280: LD_EXP 127
96284: PUSH
96285: LD_EXP 130
96289: PUSH
96290: LD_EXP 132
96294: PUSH
96295: LD_EXP 133
96299: PUSH
96300: LD_EXP 134
96304: PUSH
96305: LD_EXP 136
96309: PUSH
96310: LD_EXP 137
96314: PUSH
96315: LD_EXP 140
96319: PUSH
96320: LD_EXP 141
96324: PUSH
96325: LD_EXP 142
96329: PUSH
96330: LD_EXP 143
96334: PUSH
96335: LD_EXP 144
96339: PUSH
96340: LD_EXP 145
96344: PUSH
96345: LD_EXP 146
96349: PUSH
96350: LD_EXP 147
96354: PUSH
96355: LD_EXP 148
96359: PUSH
96360: LD_EXP 113
96364: PUSH
96365: LD_EXP 114
96369: PUSH
96370: LD_EXP 117
96374: PUSH
96375: LD_EXP 118
96379: PUSH
96380: LD_EXP 119
96384: PUSH
96385: LD_EXP 115
96389: PUSH
96390: LD_EXP 116
96394: PUSH
96395: LD_EXP 124
96399: PUSH
96400: LD_EXP 128
96404: PUSH
96405: LD_EXP 129
96409: PUSH
96410: LD_EXP 131
96414: PUSH
96415: LD_EXP 135
96419: PUSH
96420: LD_EXP 138
96424: PUSH
96425: LD_EXP 139
96429: PUSH
96430: LD_EXP 149
96434: PUSH
96435: LD_EXP 150
96439: PUSH
96440: LD_EXP 151
96444: PUSH
96445: LD_EXP 152
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: ST_TO_ADDR
// tmp :=  ;
96506: LD_ADDR_VAR 0 3
96510: PUSH
96511: LD_STRING 
96513: ST_TO_ADDR
// for i = 1 to normalCounter do
96514: LD_ADDR_VAR 0 8
96518: PUSH
96519: DOUBLE
96520: LD_INT 1
96522: DEC
96523: ST_TO_ADDR
96524: LD_EXP 97
96528: PUSH
96529: FOR_TO
96530: IFFALSE 96566
// begin if flags [ i ] then
96532: LD_VAR 0 4
96536: PUSH
96537: LD_VAR 0 8
96541: ARRAY
96542: IFFALSE 96564
// tmp := tmp & i & ; ;
96544: LD_ADDR_VAR 0 3
96548: PUSH
96549: LD_VAR 0 3
96553: PUSH
96554: LD_VAR 0 8
96558: STR
96559: PUSH
96560: LD_STRING ;
96562: STR
96563: ST_TO_ADDR
// end ;
96564: GO 96529
96566: POP
96567: POP
// for i = 1 to hardcoreCounter do
96568: LD_ADDR_VAR 0 8
96572: PUSH
96573: DOUBLE
96574: LD_INT 1
96576: DEC
96577: ST_TO_ADDR
96578: LD_EXP 98
96582: PUSH
96583: FOR_TO
96584: IFFALSE 96630
// begin if flags [ normalCounter + i ] then
96586: LD_VAR 0 4
96590: PUSH
96591: LD_EXP 97
96595: PUSH
96596: LD_VAR 0 8
96600: PLUS
96601: ARRAY
96602: IFFALSE 96628
// tmp := tmp & ( 100 + i ) & ; ;
96604: LD_ADDR_VAR 0 3
96608: PUSH
96609: LD_VAR 0 3
96613: PUSH
96614: LD_INT 100
96616: PUSH
96617: LD_VAR 0 8
96621: PLUS
96622: STR
96623: PUSH
96624: LD_STRING ;
96626: STR
96627: ST_TO_ADDR
// end ;
96628: GO 96583
96630: POP
96631: POP
// if tmp then
96632: LD_VAR 0 3
96636: IFFALSE 96648
// active := tmp ;
96638: LD_ADDR_VAR 0 7
96642: PUSH
96643: LD_VAR 0 3
96647: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96648: LD_STRING getStreamItemsFromMission("
96650: PUSH
96651: LD_VAR 0 5
96655: STR
96656: PUSH
96657: LD_STRING ","
96659: STR
96660: PUSH
96661: LD_VAR 0 6
96665: STR
96666: PUSH
96667: LD_STRING ","
96669: STR
96670: PUSH
96671: LD_VAR 0 7
96675: STR
96676: PUSH
96677: LD_STRING ")
96679: STR
96680: PPUSH
96681: CALL_OW 559
// end else
96685: GO 96694
// ToLua ( getStreamItemsFromMission("","","") ) ;
96687: LD_STRING getStreamItemsFromMission("","","")
96689: PPUSH
96690: CALL_OW 559
// end ;
96694: LD_VAR 0 2
96698: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96699: LD_EXP 96
96703: PUSH
96704: LD_EXP 101
96708: AND
96709: IFFALSE 96833
96711: GO 96713
96713: DISABLE
96714: LD_INT 0
96716: PPUSH
96717: PPUSH
// begin enable ;
96718: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96719: LD_ADDR_VAR 0 2
96723: PUSH
96724: LD_INT 22
96726: PUSH
96727: LD_OWVAR 2
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 2
96738: PUSH
96739: LD_INT 34
96741: PUSH
96742: LD_INT 7
96744: PUSH
96745: EMPTY
96746: LIST
96747: LIST
96748: PUSH
96749: LD_INT 34
96751: PUSH
96752: LD_INT 45
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: PUSH
96759: LD_INT 34
96761: PUSH
96762: LD_INT 28
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 34
96771: PUSH
96772: LD_INT 47
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PPUSH
96790: CALL_OW 69
96794: ST_TO_ADDR
// if not tmp then
96795: LD_VAR 0 2
96799: NOT
96800: IFFALSE 96804
// exit ;
96802: GO 96833
// for i in tmp do
96804: LD_ADDR_VAR 0 1
96808: PUSH
96809: LD_VAR 0 2
96813: PUSH
96814: FOR_IN
96815: IFFALSE 96831
// begin SetLives ( i , 0 ) ;
96817: LD_VAR 0 1
96821: PPUSH
96822: LD_INT 0
96824: PPUSH
96825: CALL_OW 234
// end ;
96829: GO 96814
96831: POP
96832: POP
// end ;
96833: PPOPN 2
96835: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96836: LD_EXP 96
96840: PUSH
96841: LD_EXP 102
96845: AND
96846: IFFALSE 96930
96848: GO 96850
96850: DISABLE
96851: LD_INT 0
96853: PPUSH
96854: PPUSH
// begin enable ;
96855: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96856: LD_ADDR_VAR 0 2
96860: PUSH
96861: LD_INT 22
96863: PUSH
96864: LD_OWVAR 2
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 32
96875: PUSH
96876: LD_INT 3
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: PPUSH
96887: CALL_OW 69
96891: ST_TO_ADDR
// if not tmp then
96892: LD_VAR 0 2
96896: NOT
96897: IFFALSE 96901
// exit ;
96899: GO 96930
// for i in tmp do
96901: LD_ADDR_VAR 0 1
96905: PUSH
96906: LD_VAR 0 2
96910: PUSH
96911: FOR_IN
96912: IFFALSE 96928
// begin SetLives ( i , 0 ) ;
96914: LD_VAR 0 1
96918: PPUSH
96919: LD_INT 0
96921: PPUSH
96922: CALL_OW 234
// end ;
96926: GO 96911
96928: POP
96929: POP
// end ;
96930: PPOPN 2
96932: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96933: LD_EXP 96
96937: PUSH
96938: LD_EXP 99
96942: AND
96943: IFFALSE 97036
96945: GO 96947
96947: DISABLE
96948: LD_INT 0
96950: PPUSH
// begin enable ;
96951: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96952: LD_ADDR_VAR 0 1
96956: PUSH
96957: LD_INT 22
96959: PUSH
96960: LD_OWVAR 2
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 2
96971: PUSH
96972: LD_INT 25
96974: PUSH
96975: LD_INT 5
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_INT 25
96984: PUSH
96985: LD_INT 9
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 25
96994: PUSH
96995: LD_INT 8
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: LIST
97006: LIST
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PPUSH
97012: CALL_OW 69
97016: PUSH
97017: FOR_IN
97018: IFFALSE 97034
// begin SetClass ( i , 1 ) ;
97020: LD_VAR 0 1
97024: PPUSH
97025: LD_INT 1
97027: PPUSH
97028: CALL_OW 336
// end ;
97032: GO 97017
97034: POP
97035: POP
// end ;
97036: PPOPN 1
97038: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97039: LD_EXP 96
97043: PUSH
97044: LD_EXP 100
97048: AND
97049: PUSH
97050: LD_OWVAR 65
97054: PUSH
97055: LD_INT 7
97057: LESS
97058: AND
97059: IFFALSE 97073
97061: GO 97063
97063: DISABLE
// begin enable ;
97064: ENABLE
// game_speed := 7 ;
97065: LD_ADDR_OWVAR 65
97069: PUSH
97070: LD_INT 7
97072: ST_TO_ADDR
// end ;
97073: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97074: LD_EXP 96
97078: PUSH
97079: LD_EXP 103
97083: AND
97084: IFFALSE 97286
97086: GO 97088
97088: DISABLE
97089: LD_INT 0
97091: PPUSH
97092: PPUSH
97093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97094: LD_ADDR_VAR 0 3
97098: PUSH
97099: LD_INT 81
97101: PUSH
97102: LD_OWVAR 2
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PUSH
97111: LD_INT 21
97113: PUSH
97114: LD_INT 1
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PPUSH
97125: CALL_OW 69
97129: ST_TO_ADDR
// if not tmp then
97130: LD_VAR 0 3
97134: NOT
97135: IFFALSE 97139
// exit ;
97137: GO 97286
// if tmp > 5 then
97139: LD_VAR 0 3
97143: PUSH
97144: LD_INT 5
97146: GREATER
97147: IFFALSE 97159
// k := 5 else
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: LD_INT 5
97156: ST_TO_ADDR
97157: GO 97169
// k := tmp ;
97159: LD_ADDR_VAR 0 2
97163: PUSH
97164: LD_VAR 0 3
97168: ST_TO_ADDR
// for i := 1 to k do
97169: LD_ADDR_VAR 0 1
97173: PUSH
97174: DOUBLE
97175: LD_INT 1
97177: DEC
97178: ST_TO_ADDR
97179: LD_VAR 0 2
97183: PUSH
97184: FOR_TO
97185: IFFALSE 97284
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97187: LD_VAR 0 3
97191: PUSH
97192: LD_VAR 0 1
97196: ARRAY
97197: PPUSH
97198: LD_VAR 0 1
97202: PUSH
97203: LD_INT 4
97205: MOD
97206: PUSH
97207: LD_INT 1
97209: PLUS
97210: PPUSH
97211: CALL_OW 259
97215: PUSH
97216: LD_INT 10
97218: LESS
97219: IFFALSE 97282
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97221: LD_VAR 0 3
97225: PUSH
97226: LD_VAR 0 1
97230: ARRAY
97231: PPUSH
97232: LD_VAR 0 1
97236: PUSH
97237: LD_INT 4
97239: MOD
97240: PUSH
97241: LD_INT 1
97243: PLUS
97244: PPUSH
97245: LD_VAR 0 3
97249: PUSH
97250: LD_VAR 0 1
97254: ARRAY
97255: PPUSH
97256: LD_VAR 0 1
97260: PUSH
97261: LD_INT 4
97263: MOD
97264: PUSH
97265: LD_INT 1
97267: PLUS
97268: PPUSH
97269: CALL_OW 259
97273: PUSH
97274: LD_INT 1
97276: PLUS
97277: PPUSH
97278: CALL_OW 237
97282: GO 97184
97284: POP
97285: POP
// end ;
97286: PPOPN 3
97288: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97289: LD_EXP 96
97293: PUSH
97294: LD_EXP 104
97298: AND
97299: IFFALSE 97319
97301: GO 97303
97303: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97304: LD_INT 4
97306: PPUSH
97307: LD_OWVAR 2
97311: PPUSH
97312: LD_INT 0
97314: PPUSH
97315: CALL_OW 324
97319: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97320: LD_EXP 96
97324: PUSH
97325: LD_EXP 133
97329: AND
97330: IFFALSE 97350
97332: GO 97334
97334: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97335: LD_INT 19
97337: PPUSH
97338: LD_OWVAR 2
97342: PPUSH
97343: LD_INT 0
97345: PPUSH
97346: CALL_OW 324
97350: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97351: LD_EXP 96
97355: PUSH
97356: LD_EXP 105
97360: AND
97361: IFFALSE 97463
97363: GO 97365
97365: DISABLE
97366: LD_INT 0
97368: PPUSH
97369: PPUSH
// begin enable ;
97370: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97371: LD_ADDR_VAR 0 2
97375: PUSH
97376: LD_INT 22
97378: PUSH
97379: LD_OWVAR 2
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 2
97390: PUSH
97391: LD_INT 34
97393: PUSH
97394: LD_INT 11
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PUSH
97401: LD_INT 34
97403: PUSH
97404: LD_INT 30
97406: PUSH
97407: EMPTY
97408: LIST
97409: LIST
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: PPUSH
97420: CALL_OW 69
97424: ST_TO_ADDR
// if not tmp then
97425: LD_VAR 0 2
97429: NOT
97430: IFFALSE 97434
// exit ;
97432: GO 97463
// for i in tmp do
97434: LD_ADDR_VAR 0 1
97438: PUSH
97439: LD_VAR 0 2
97443: PUSH
97444: FOR_IN
97445: IFFALSE 97461
// begin SetLives ( i , 0 ) ;
97447: LD_VAR 0 1
97451: PPUSH
97452: LD_INT 0
97454: PPUSH
97455: CALL_OW 234
// end ;
97459: GO 97444
97461: POP
97462: POP
// end ;
97463: PPOPN 2
97465: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97466: LD_EXP 96
97470: PUSH
97471: LD_EXP 106
97475: AND
97476: IFFALSE 97496
97478: GO 97480
97480: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97481: LD_INT 32
97483: PPUSH
97484: LD_OWVAR 2
97488: PPUSH
97489: LD_INT 0
97491: PPUSH
97492: CALL_OW 324
97496: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97497: LD_EXP 96
97501: PUSH
97502: LD_EXP 107
97506: AND
97507: IFFALSE 97688
97509: GO 97511
97511: DISABLE
97512: LD_INT 0
97514: PPUSH
97515: PPUSH
97516: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97517: LD_ADDR_VAR 0 2
97521: PUSH
97522: LD_INT 22
97524: PUSH
97525: LD_OWVAR 2
97529: PUSH
97530: EMPTY
97531: LIST
97532: LIST
97533: PUSH
97534: LD_INT 33
97536: PUSH
97537: LD_INT 3
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PPUSH
97548: CALL_OW 69
97552: ST_TO_ADDR
// if not tmp then
97553: LD_VAR 0 2
97557: NOT
97558: IFFALSE 97562
// exit ;
97560: GO 97688
// side := 0 ;
97562: LD_ADDR_VAR 0 3
97566: PUSH
97567: LD_INT 0
97569: ST_TO_ADDR
// for i := 1 to 8 do
97570: LD_ADDR_VAR 0 1
97574: PUSH
97575: DOUBLE
97576: LD_INT 1
97578: DEC
97579: ST_TO_ADDR
97580: LD_INT 8
97582: PUSH
97583: FOR_TO
97584: IFFALSE 97632
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97586: LD_OWVAR 2
97590: PUSH
97591: LD_VAR 0 1
97595: NONEQUAL
97596: PUSH
97597: LD_OWVAR 2
97601: PPUSH
97602: LD_VAR 0 1
97606: PPUSH
97607: CALL_OW 81
97611: PUSH
97612: LD_INT 2
97614: EQUAL
97615: AND
97616: IFFALSE 97630
// begin side := i ;
97618: LD_ADDR_VAR 0 3
97622: PUSH
97623: LD_VAR 0 1
97627: ST_TO_ADDR
// break ;
97628: GO 97632
// end ;
97630: GO 97583
97632: POP
97633: POP
// if not side then
97634: LD_VAR 0 3
97638: NOT
97639: IFFALSE 97643
// exit ;
97641: GO 97688
// for i := 1 to tmp do
97643: LD_ADDR_VAR 0 1
97647: PUSH
97648: DOUBLE
97649: LD_INT 1
97651: DEC
97652: ST_TO_ADDR
97653: LD_VAR 0 2
97657: PUSH
97658: FOR_TO
97659: IFFALSE 97686
// if Prob ( 60 ) then
97661: LD_INT 60
97663: PPUSH
97664: CALL_OW 13
97668: IFFALSE 97684
// SetSide ( i , side ) ;
97670: LD_VAR 0 1
97674: PPUSH
97675: LD_VAR 0 3
97679: PPUSH
97680: CALL_OW 235
97684: GO 97658
97686: POP
97687: POP
// end ;
97688: PPOPN 3
97690: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97691: LD_EXP 96
97695: PUSH
97696: LD_EXP 109
97700: AND
97701: IFFALSE 97820
97703: GO 97705
97705: DISABLE
97706: LD_INT 0
97708: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97709: LD_ADDR_VAR 0 1
97713: PUSH
97714: LD_INT 22
97716: PUSH
97717: LD_OWVAR 2
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 21
97728: PUSH
97729: LD_INT 1
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: PUSH
97736: LD_INT 3
97738: PUSH
97739: LD_INT 23
97741: PUSH
97742: LD_INT 0
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: LIST
97757: PPUSH
97758: CALL_OW 69
97762: PUSH
97763: FOR_IN
97764: IFFALSE 97818
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97766: LD_VAR 0 1
97770: PPUSH
97771: CALL_OW 257
97775: PUSH
97776: LD_INT 1
97778: PUSH
97779: LD_INT 2
97781: PUSH
97782: LD_INT 3
97784: PUSH
97785: LD_INT 4
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: IN
97794: IFFALSE 97816
// SetClass ( un , rand ( 1 , 4 ) ) ;
97796: LD_VAR 0 1
97800: PPUSH
97801: LD_INT 1
97803: PPUSH
97804: LD_INT 4
97806: PPUSH
97807: CALL_OW 12
97811: PPUSH
97812: CALL_OW 336
97816: GO 97763
97818: POP
97819: POP
// end ;
97820: PPOPN 1
97822: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97823: LD_EXP 96
97827: PUSH
97828: LD_EXP 108
97832: AND
97833: IFFALSE 97912
97835: GO 97837
97837: DISABLE
97838: LD_INT 0
97840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97841: LD_ADDR_VAR 0 1
97845: PUSH
97846: LD_INT 22
97848: PUSH
97849: LD_OWVAR 2
97853: PUSH
97854: EMPTY
97855: LIST
97856: LIST
97857: PUSH
97858: LD_INT 21
97860: PUSH
97861: LD_INT 3
97863: PUSH
97864: EMPTY
97865: LIST
97866: LIST
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PPUSH
97872: CALL_OW 69
97876: ST_TO_ADDR
// if not tmp then
97877: LD_VAR 0 1
97881: NOT
97882: IFFALSE 97886
// exit ;
97884: GO 97912
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97886: LD_VAR 0 1
97890: PUSH
97891: LD_INT 1
97893: PPUSH
97894: LD_VAR 0 1
97898: PPUSH
97899: CALL_OW 12
97903: ARRAY
97904: PPUSH
97905: LD_INT 100
97907: PPUSH
97908: CALL_OW 234
// end ;
97912: PPOPN 1
97914: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97915: LD_EXP 96
97919: PUSH
97920: LD_EXP 110
97924: AND
97925: IFFALSE 98023
97927: GO 97929
97929: DISABLE
97930: LD_INT 0
97932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97933: LD_ADDR_VAR 0 1
97937: PUSH
97938: LD_INT 22
97940: PUSH
97941: LD_OWVAR 2
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 21
97952: PUSH
97953: LD_INT 1
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PPUSH
97964: CALL_OW 69
97968: ST_TO_ADDR
// if not tmp then
97969: LD_VAR 0 1
97973: NOT
97974: IFFALSE 97978
// exit ;
97976: GO 98023
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97978: LD_VAR 0 1
97982: PUSH
97983: LD_INT 1
97985: PPUSH
97986: LD_VAR 0 1
97990: PPUSH
97991: CALL_OW 12
97995: ARRAY
97996: PPUSH
97997: LD_INT 1
97999: PPUSH
98000: LD_INT 4
98002: PPUSH
98003: CALL_OW 12
98007: PPUSH
98008: LD_INT 3000
98010: PPUSH
98011: LD_INT 9000
98013: PPUSH
98014: CALL_OW 12
98018: PPUSH
98019: CALL_OW 492
// end ;
98023: PPOPN 1
98025: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98026: LD_EXP 96
98030: PUSH
98031: LD_EXP 111
98035: AND
98036: IFFALSE 98056
98038: GO 98040
98040: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98041: LD_INT 1
98043: PPUSH
98044: LD_OWVAR 2
98048: PPUSH
98049: LD_INT 0
98051: PPUSH
98052: CALL_OW 324
98056: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98057: LD_EXP 96
98061: PUSH
98062: LD_EXP 112
98066: AND
98067: IFFALSE 98150
98069: GO 98071
98071: DISABLE
98072: LD_INT 0
98074: PPUSH
98075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98076: LD_ADDR_VAR 0 2
98080: PUSH
98081: LD_INT 22
98083: PUSH
98084: LD_OWVAR 2
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: PUSH
98093: LD_INT 21
98095: PUSH
98096: LD_INT 3
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: PUSH
98103: EMPTY
98104: LIST
98105: LIST
98106: PPUSH
98107: CALL_OW 69
98111: ST_TO_ADDR
// if not tmp then
98112: LD_VAR 0 2
98116: NOT
98117: IFFALSE 98121
// exit ;
98119: GO 98150
// for i in tmp do
98121: LD_ADDR_VAR 0 1
98125: PUSH
98126: LD_VAR 0 2
98130: PUSH
98131: FOR_IN
98132: IFFALSE 98148
// SetBLevel ( i , 10 ) ;
98134: LD_VAR 0 1
98138: PPUSH
98139: LD_INT 10
98141: PPUSH
98142: CALL_OW 241
98146: GO 98131
98148: POP
98149: POP
// end ;
98150: PPOPN 2
98152: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98153: LD_EXP 96
98157: PUSH
98158: LD_EXP 113
98162: AND
98163: IFFALSE 98274
98165: GO 98167
98167: DISABLE
98168: LD_INT 0
98170: PPUSH
98171: PPUSH
98172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98173: LD_ADDR_VAR 0 3
98177: PUSH
98178: LD_INT 22
98180: PUSH
98181: LD_OWVAR 2
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: PUSH
98190: LD_INT 25
98192: PUSH
98193: LD_INT 1
98195: PUSH
98196: EMPTY
98197: LIST
98198: LIST
98199: PUSH
98200: EMPTY
98201: LIST
98202: LIST
98203: PPUSH
98204: CALL_OW 69
98208: ST_TO_ADDR
// if not tmp then
98209: LD_VAR 0 3
98213: NOT
98214: IFFALSE 98218
// exit ;
98216: GO 98274
// un := tmp [ rand ( 1 , tmp ) ] ;
98218: LD_ADDR_VAR 0 2
98222: PUSH
98223: LD_VAR 0 3
98227: PUSH
98228: LD_INT 1
98230: PPUSH
98231: LD_VAR 0 3
98235: PPUSH
98236: CALL_OW 12
98240: ARRAY
98241: ST_TO_ADDR
// if Crawls ( un ) then
98242: LD_VAR 0 2
98246: PPUSH
98247: CALL_OW 318
98251: IFFALSE 98262
// ComWalk ( un ) ;
98253: LD_VAR 0 2
98257: PPUSH
98258: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98262: LD_VAR 0 2
98266: PPUSH
98267: LD_INT 5
98269: PPUSH
98270: CALL_OW 336
// end ;
98274: PPOPN 3
98276: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98277: LD_EXP 96
98281: PUSH
98282: LD_EXP 114
98286: AND
98287: PUSH
98288: LD_OWVAR 67
98292: PUSH
98293: LD_INT 4
98295: LESS
98296: AND
98297: IFFALSE 98316
98299: GO 98301
98301: DISABLE
// begin Difficulty := Difficulty + 1 ;
98302: LD_ADDR_OWVAR 67
98306: PUSH
98307: LD_OWVAR 67
98311: PUSH
98312: LD_INT 1
98314: PLUS
98315: ST_TO_ADDR
// end ;
98316: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98317: LD_EXP 96
98321: PUSH
98322: LD_EXP 115
98326: AND
98327: IFFALSE 98430
98329: GO 98331
98331: DISABLE
98332: LD_INT 0
98334: PPUSH
// begin for i := 1 to 5 do
98335: LD_ADDR_VAR 0 1
98339: PUSH
98340: DOUBLE
98341: LD_INT 1
98343: DEC
98344: ST_TO_ADDR
98345: LD_INT 5
98347: PUSH
98348: FOR_TO
98349: IFFALSE 98428
// begin uc_nation := nation_nature ;
98351: LD_ADDR_OWVAR 21
98355: PUSH
98356: LD_INT 0
98358: ST_TO_ADDR
// uc_side := 0 ;
98359: LD_ADDR_OWVAR 20
98363: PUSH
98364: LD_INT 0
98366: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98367: LD_ADDR_OWVAR 29
98371: PUSH
98372: LD_INT 12
98374: PUSH
98375: LD_INT 12
98377: PUSH
98378: EMPTY
98379: LIST
98380: LIST
98381: ST_TO_ADDR
// hc_agressivity := 20 ;
98382: LD_ADDR_OWVAR 35
98386: PUSH
98387: LD_INT 20
98389: ST_TO_ADDR
// hc_class := class_tiger ;
98390: LD_ADDR_OWVAR 28
98394: PUSH
98395: LD_INT 14
98397: ST_TO_ADDR
// hc_gallery :=  ;
98398: LD_ADDR_OWVAR 33
98402: PUSH
98403: LD_STRING 
98405: ST_TO_ADDR
// hc_name :=  ;
98406: LD_ADDR_OWVAR 26
98410: PUSH
98411: LD_STRING 
98413: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98414: CALL_OW 44
98418: PPUSH
98419: LD_INT 0
98421: PPUSH
98422: CALL_OW 51
// end ;
98426: GO 98348
98428: POP
98429: POP
// end ;
98430: PPOPN 1
98432: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98433: LD_EXP 96
98437: PUSH
98438: LD_EXP 116
98442: AND
98443: IFFALSE 98452
98445: GO 98447
98447: DISABLE
// StreamSibBomb ;
98448: CALL 98453 0 0
98452: END
// export function StreamSibBomb ; var i , x , y ; begin
98453: LD_INT 0
98455: PPUSH
98456: PPUSH
98457: PPUSH
98458: PPUSH
// result := false ;
98459: LD_ADDR_VAR 0 1
98463: PUSH
98464: LD_INT 0
98466: ST_TO_ADDR
// for i := 1 to 16 do
98467: LD_ADDR_VAR 0 2
98471: PUSH
98472: DOUBLE
98473: LD_INT 1
98475: DEC
98476: ST_TO_ADDR
98477: LD_INT 16
98479: PUSH
98480: FOR_TO
98481: IFFALSE 98680
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98483: LD_ADDR_VAR 0 3
98487: PUSH
98488: LD_INT 10
98490: PUSH
98491: LD_INT 20
98493: PUSH
98494: LD_INT 30
98496: PUSH
98497: LD_INT 40
98499: PUSH
98500: LD_INT 50
98502: PUSH
98503: LD_INT 60
98505: PUSH
98506: LD_INT 70
98508: PUSH
98509: LD_INT 80
98511: PUSH
98512: LD_INT 90
98514: PUSH
98515: LD_INT 100
98517: PUSH
98518: LD_INT 110
98520: PUSH
98521: LD_INT 120
98523: PUSH
98524: LD_INT 130
98526: PUSH
98527: LD_INT 140
98529: PUSH
98530: LD_INT 150
98532: PUSH
98533: EMPTY
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 1
98552: PPUSH
98553: LD_INT 15
98555: PPUSH
98556: CALL_OW 12
98560: ARRAY
98561: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98562: LD_ADDR_VAR 0 4
98566: PUSH
98567: LD_INT 10
98569: PUSH
98570: LD_INT 20
98572: PUSH
98573: LD_INT 30
98575: PUSH
98576: LD_INT 40
98578: PUSH
98579: LD_INT 50
98581: PUSH
98582: LD_INT 60
98584: PUSH
98585: LD_INT 70
98587: PUSH
98588: LD_INT 80
98590: PUSH
98591: LD_INT 90
98593: PUSH
98594: LD_INT 100
98596: PUSH
98597: LD_INT 110
98599: PUSH
98600: LD_INT 120
98602: PUSH
98603: LD_INT 130
98605: PUSH
98606: LD_INT 140
98608: PUSH
98609: LD_INT 150
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: LIST
98616: LIST
98617: LIST
98618: LIST
98619: LIST
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: PUSH
98629: LD_INT 1
98631: PPUSH
98632: LD_INT 15
98634: PPUSH
98635: CALL_OW 12
98639: ARRAY
98640: ST_TO_ADDR
// if ValidHex ( x , y ) then
98641: LD_VAR 0 3
98645: PPUSH
98646: LD_VAR 0 4
98650: PPUSH
98651: CALL_OW 488
98655: IFFALSE 98678
// begin result := [ x , y ] ;
98657: LD_ADDR_VAR 0 1
98661: PUSH
98662: LD_VAR 0 3
98666: PUSH
98667: LD_VAR 0 4
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: ST_TO_ADDR
// break ;
98676: GO 98680
// end ; end ;
98678: GO 98480
98680: POP
98681: POP
// if result then
98682: LD_VAR 0 1
98686: IFFALSE 98746
// begin ToLua ( playSibBomb() ) ;
98688: LD_STRING playSibBomb()
98690: PPUSH
98691: CALL_OW 559
// wait ( 0 0$14 ) ;
98695: LD_INT 490
98697: PPUSH
98698: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98702: LD_VAR 0 1
98706: PUSH
98707: LD_INT 1
98709: ARRAY
98710: PPUSH
98711: LD_VAR 0 1
98715: PUSH
98716: LD_INT 2
98718: ARRAY
98719: PPUSH
98720: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98724: LD_VAR 0 1
98728: PUSH
98729: LD_INT 1
98731: ARRAY
98732: PPUSH
98733: LD_VAR 0 1
98737: PUSH
98738: LD_INT 2
98740: ARRAY
98741: PPUSH
98742: CALL_OW 429
// end ; end ;
98746: LD_VAR 0 1
98750: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98751: LD_EXP 96
98755: PUSH
98756: LD_EXP 118
98760: AND
98761: IFFALSE 98773
98763: GO 98765
98765: DISABLE
// YouLost (  ) ;
98766: LD_STRING 
98768: PPUSH
98769: CALL_OW 104
98773: END
// every 0 0$1 trigger StreamModeActive and sFog do
98774: LD_EXP 96
98778: PUSH
98779: LD_EXP 117
98783: AND
98784: IFFALSE 98798
98786: GO 98788
98788: DISABLE
// FogOff ( your_side ) ;
98789: LD_OWVAR 2
98793: PPUSH
98794: CALL_OW 344
98798: END
// every 0 0$1 trigger StreamModeActive and sSun do
98799: LD_EXP 96
98803: PUSH
98804: LD_EXP 119
98808: AND
98809: IFFALSE 98837
98811: GO 98813
98813: DISABLE
// begin solar_recharge_percent := 0 ;
98814: LD_ADDR_OWVAR 79
98818: PUSH
98819: LD_INT 0
98821: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98822: LD_INT 10500
98824: PPUSH
98825: CALL_OW 67
// solar_recharge_percent := 100 ;
98829: LD_ADDR_OWVAR 79
98833: PUSH
98834: LD_INT 100
98836: ST_TO_ADDR
// end ;
98837: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98838: LD_EXP 96
98842: PUSH
98843: LD_EXP 120
98847: AND
98848: IFFALSE 99087
98850: GO 98852
98852: DISABLE
98853: LD_INT 0
98855: PPUSH
98856: PPUSH
98857: PPUSH
// begin tmp := [ ] ;
98858: LD_ADDR_VAR 0 3
98862: PUSH
98863: EMPTY
98864: ST_TO_ADDR
// for i := 1 to 6 do
98865: LD_ADDR_VAR 0 1
98869: PUSH
98870: DOUBLE
98871: LD_INT 1
98873: DEC
98874: ST_TO_ADDR
98875: LD_INT 6
98877: PUSH
98878: FOR_TO
98879: IFFALSE 98984
// begin uc_nation := nation_nature ;
98881: LD_ADDR_OWVAR 21
98885: PUSH
98886: LD_INT 0
98888: ST_TO_ADDR
// uc_side := 0 ;
98889: LD_ADDR_OWVAR 20
98893: PUSH
98894: LD_INT 0
98896: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98897: LD_ADDR_OWVAR 29
98901: PUSH
98902: LD_INT 12
98904: PUSH
98905: LD_INT 12
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: ST_TO_ADDR
// hc_agressivity := 20 ;
98912: LD_ADDR_OWVAR 35
98916: PUSH
98917: LD_INT 20
98919: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98920: LD_ADDR_OWVAR 28
98924: PUSH
98925: LD_INT 17
98927: ST_TO_ADDR
// hc_gallery :=  ;
98928: LD_ADDR_OWVAR 33
98932: PUSH
98933: LD_STRING 
98935: ST_TO_ADDR
// hc_name :=  ;
98936: LD_ADDR_OWVAR 26
98940: PUSH
98941: LD_STRING 
98943: ST_TO_ADDR
// un := CreateHuman ;
98944: LD_ADDR_VAR 0 2
98948: PUSH
98949: CALL_OW 44
98953: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98954: LD_VAR 0 2
98958: PPUSH
98959: LD_INT 1
98961: PPUSH
98962: CALL_OW 51
// tmp := tmp ^ un ;
98966: LD_ADDR_VAR 0 3
98970: PUSH
98971: LD_VAR 0 3
98975: PUSH
98976: LD_VAR 0 2
98980: ADD
98981: ST_TO_ADDR
// end ;
98982: GO 98878
98984: POP
98985: POP
// repeat wait ( 0 0$1 ) ;
98986: LD_INT 35
98988: PPUSH
98989: CALL_OW 67
// for un in tmp do
98993: LD_ADDR_VAR 0 2
98997: PUSH
98998: LD_VAR 0 3
99002: PUSH
99003: FOR_IN
99004: IFFALSE 99078
// begin if IsDead ( un ) then
99006: LD_VAR 0 2
99010: PPUSH
99011: CALL_OW 301
99015: IFFALSE 99035
// begin tmp := tmp diff un ;
99017: LD_ADDR_VAR 0 3
99021: PUSH
99022: LD_VAR 0 3
99026: PUSH
99027: LD_VAR 0 2
99031: DIFF
99032: ST_TO_ADDR
// continue ;
99033: GO 99003
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99035: LD_VAR 0 2
99039: PPUSH
99040: LD_INT 3
99042: PUSH
99043: LD_INT 22
99045: PUSH
99046: LD_INT 0
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: PPUSH
99057: CALL_OW 69
99061: PPUSH
99062: LD_VAR 0 2
99066: PPUSH
99067: CALL_OW 74
99071: PPUSH
99072: CALL_OW 115
// end ;
99076: GO 99003
99078: POP
99079: POP
// until not tmp ;
99080: LD_VAR 0 3
99084: NOT
99085: IFFALSE 98986
// end ;
99087: PPOPN 3
99089: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99090: LD_EXP 96
99094: PUSH
99095: LD_EXP 121
99099: AND
99100: IFFALSE 99154
99102: GO 99104
99104: DISABLE
// begin ToLua ( displayTroll(); ) ;
99105: LD_STRING displayTroll();
99107: PPUSH
99108: CALL_OW 559
// wait ( 3 3$00 ) ;
99112: LD_INT 6300
99114: PPUSH
99115: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99119: LD_STRING hideTroll();
99121: PPUSH
99122: CALL_OW 559
// wait ( 1 1$00 ) ;
99126: LD_INT 2100
99128: PPUSH
99129: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99133: LD_STRING displayTroll();
99135: PPUSH
99136: CALL_OW 559
// wait ( 1 1$00 ) ;
99140: LD_INT 2100
99142: PPUSH
99143: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99147: LD_STRING hideTroll();
99149: PPUSH
99150: CALL_OW 559
// end ;
99154: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99155: LD_EXP 96
99159: PUSH
99160: LD_EXP 122
99164: AND
99165: IFFALSE 99228
99167: GO 99169
99169: DISABLE
99170: LD_INT 0
99172: PPUSH
// begin p := 0 ;
99173: LD_ADDR_VAR 0 1
99177: PUSH
99178: LD_INT 0
99180: ST_TO_ADDR
// repeat game_speed := 1 ;
99181: LD_ADDR_OWVAR 65
99185: PUSH
99186: LD_INT 1
99188: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99189: LD_INT 35
99191: PPUSH
99192: CALL_OW 67
// p := p + 1 ;
99196: LD_ADDR_VAR 0 1
99200: PUSH
99201: LD_VAR 0 1
99205: PUSH
99206: LD_INT 1
99208: PLUS
99209: ST_TO_ADDR
// until p >= 60 ;
99210: LD_VAR 0 1
99214: PUSH
99215: LD_INT 60
99217: GREATEREQUAL
99218: IFFALSE 99181
// game_speed := 4 ;
99220: LD_ADDR_OWVAR 65
99224: PUSH
99225: LD_INT 4
99227: ST_TO_ADDR
// end ;
99228: PPOPN 1
99230: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99231: LD_EXP 96
99235: PUSH
99236: LD_EXP 123
99240: AND
99241: IFFALSE 99387
99243: GO 99245
99245: DISABLE
99246: LD_INT 0
99248: PPUSH
99249: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99250: LD_ADDR_VAR 0 1
99254: PUSH
99255: LD_INT 22
99257: PUSH
99258: LD_OWVAR 2
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: PUSH
99267: LD_INT 2
99269: PUSH
99270: LD_INT 30
99272: PUSH
99273: LD_INT 0
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 30
99282: PUSH
99283: LD_INT 1
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: PUSH
99290: EMPTY
99291: LIST
99292: LIST
99293: LIST
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: PPUSH
99299: CALL_OW 69
99303: ST_TO_ADDR
// if not depot then
99304: LD_VAR 0 1
99308: NOT
99309: IFFALSE 99313
// exit ;
99311: GO 99387
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99313: LD_ADDR_VAR 0 2
99317: PUSH
99318: LD_VAR 0 1
99322: PUSH
99323: LD_INT 1
99325: PPUSH
99326: LD_VAR 0 1
99330: PPUSH
99331: CALL_OW 12
99335: ARRAY
99336: PPUSH
99337: CALL_OW 274
99341: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99342: LD_VAR 0 2
99346: PPUSH
99347: LD_INT 1
99349: PPUSH
99350: LD_INT 0
99352: PPUSH
99353: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99357: LD_VAR 0 2
99361: PPUSH
99362: LD_INT 2
99364: PPUSH
99365: LD_INT 0
99367: PPUSH
99368: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99372: LD_VAR 0 2
99376: PPUSH
99377: LD_INT 3
99379: PPUSH
99380: LD_INT 0
99382: PPUSH
99383: CALL_OW 277
// end ;
99387: PPOPN 2
99389: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99390: LD_EXP 96
99394: PUSH
99395: LD_EXP 124
99399: AND
99400: IFFALSE 99497
99402: GO 99404
99404: DISABLE
99405: LD_INT 0
99407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99408: LD_ADDR_VAR 0 1
99412: PUSH
99413: LD_INT 22
99415: PUSH
99416: LD_OWVAR 2
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: LD_INT 21
99427: PUSH
99428: LD_INT 1
99430: PUSH
99431: EMPTY
99432: LIST
99433: LIST
99434: PUSH
99435: LD_INT 3
99437: PUSH
99438: LD_INT 23
99440: PUSH
99441: LD_INT 0
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PUSH
99448: EMPTY
99449: LIST
99450: LIST
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: LIST
99456: PPUSH
99457: CALL_OW 69
99461: ST_TO_ADDR
// if not tmp then
99462: LD_VAR 0 1
99466: NOT
99467: IFFALSE 99471
// exit ;
99469: GO 99497
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99471: LD_VAR 0 1
99475: PUSH
99476: LD_INT 1
99478: PPUSH
99479: LD_VAR 0 1
99483: PPUSH
99484: CALL_OW 12
99488: ARRAY
99489: PPUSH
99490: LD_INT 200
99492: PPUSH
99493: CALL_OW 234
// end ;
99497: PPOPN 1
99499: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99500: LD_EXP 96
99504: PUSH
99505: LD_EXP 125
99509: AND
99510: IFFALSE 99589
99512: GO 99514
99514: DISABLE
99515: LD_INT 0
99517: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99518: LD_ADDR_VAR 0 1
99522: PUSH
99523: LD_INT 22
99525: PUSH
99526: LD_OWVAR 2
99530: PUSH
99531: EMPTY
99532: LIST
99533: LIST
99534: PUSH
99535: LD_INT 21
99537: PUSH
99538: LD_INT 2
99540: PUSH
99541: EMPTY
99542: LIST
99543: LIST
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PPUSH
99549: CALL_OW 69
99553: ST_TO_ADDR
// if not tmp then
99554: LD_VAR 0 1
99558: NOT
99559: IFFALSE 99563
// exit ;
99561: GO 99589
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99563: LD_VAR 0 1
99567: PUSH
99568: LD_INT 1
99570: PPUSH
99571: LD_VAR 0 1
99575: PPUSH
99576: CALL_OW 12
99580: ARRAY
99581: PPUSH
99582: LD_INT 60
99584: PPUSH
99585: CALL_OW 234
// end ;
99589: PPOPN 1
99591: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99592: LD_EXP 96
99596: PUSH
99597: LD_EXP 126
99601: AND
99602: IFFALSE 99701
99604: GO 99606
99606: DISABLE
99607: LD_INT 0
99609: PPUSH
99610: PPUSH
// begin enable ;
99611: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99612: LD_ADDR_VAR 0 1
99616: PUSH
99617: LD_INT 22
99619: PUSH
99620: LD_OWVAR 2
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: PUSH
99629: LD_INT 61
99631: PUSH
99632: EMPTY
99633: LIST
99634: PUSH
99635: LD_INT 33
99637: PUSH
99638: LD_INT 2
99640: PUSH
99641: EMPTY
99642: LIST
99643: LIST
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: LIST
99649: PPUSH
99650: CALL_OW 69
99654: ST_TO_ADDR
// if not tmp then
99655: LD_VAR 0 1
99659: NOT
99660: IFFALSE 99664
// exit ;
99662: GO 99701
// for i in tmp do
99664: LD_ADDR_VAR 0 2
99668: PUSH
99669: LD_VAR 0 1
99673: PUSH
99674: FOR_IN
99675: IFFALSE 99699
// if IsControledBy ( i ) then
99677: LD_VAR 0 2
99681: PPUSH
99682: CALL_OW 312
99686: IFFALSE 99697
// ComUnlink ( i ) ;
99688: LD_VAR 0 2
99692: PPUSH
99693: CALL_OW 136
99697: GO 99674
99699: POP
99700: POP
// end ;
99701: PPOPN 2
99703: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99704: LD_EXP 96
99708: PUSH
99709: LD_EXP 127
99713: AND
99714: IFFALSE 99854
99716: GO 99718
99718: DISABLE
99719: LD_INT 0
99721: PPUSH
99722: PPUSH
// begin ToLua ( displayPowell(); ) ;
99723: LD_STRING displayPowell();
99725: PPUSH
99726: CALL_OW 559
// uc_side := 0 ;
99730: LD_ADDR_OWVAR 20
99734: PUSH
99735: LD_INT 0
99737: ST_TO_ADDR
// uc_nation := 2 ;
99738: LD_ADDR_OWVAR 21
99742: PUSH
99743: LD_INT 2
99745: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99746: LD_ADDR_OWVAR 37
99750: PUSH
99751: LD_INT 14
99753: ST_TO_ADDR
// vc_engine := engine_siberite ;
99754: LD_ADDR_OWVAR 39
99758: PUSH
99759: LD_INT 3
99761: ST_TO_ADDR
// vc_control := control_apeman ;
99762: LD_ADDR_OWVAR 38
99766: PUSH
99767: LD_INT 5
99769: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99770: LD_ADDR_OWVAR 40
99774: PUSH
99775: LD_INT 29
99777: ST_TO_ADDR
// un := CreateVehicle ;
99778: LD_ADDR_VAR 0 2
99782: PUSH
99783: CALL_OW 45
99787: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99788: LD_VAR 0 2
99792: PPUSH
99793: LD_INT 1
99795: PPUSH
99796: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99800: LD_INT 35
99802: PPUSH
99803: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99807: LD_VAR 0 2
99811: PPUSH
99812: LD_INT 22
99814: PUSH
99815: LD_OWVAR 2
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PPUSH
99824: CALL_OW 69
99828: PPUSH
99829: LD_VAR 0 2
99833: PPUSH
99834: CALL_OW 74
99838: PPUSH
99839: CALL_OW 115
// until IsDead ( un ) ;
99843: LD_VAR 0 2
99847: PPUSH
99848: CALL_OW 301
99852: IFFALSE 99800
// end ;
99854: PPOPN 2
99856: END
// every 0 0$1 trigger StreamModeActive and sStu do
99857: LD_EXP 96
99861: PUSH
99862: LD_EXP 135
99866: AND
99867: IFFALSE 99883
99869: GO 99871
99871: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99872: LD_STRING displayStucuk();
99874: PPUSH
99875: CALL_OW 559
// ResetFog ;
99879: CALL_OW 335
// end ;
99883: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99884: LD_EXP 96
99888: PUSH
99889: LD_EXP 128
99893: AND
99894: IFFALSE 100035
99896: GO 99898
99898: DISABLE
99899: LD_INT 0
99901: PPUSH
99902: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99903: LD_ADDR_VAR 0 2
99907: PUSH
99908: LD_INT 22
99910: PUSH
99911: LD_OWVAR 2
99915: PUSH
99916: EMPTY
99917: LIST
99918: LIST
99919: PUSH
99920: LD_INT 21
99922: PUSH
99923: LD_INT 1
99925: PUSH
99926: EMPTY
99927: LIST
99928: LIST
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PPUSH
99934: CALL_OW 69
99938: ST_TO_ADDR
// if not tmp then
99939: LD_VAR 0 2
99943: NOT
99944: IFFALSE 99948
// exit ;
99946: GO 100035
// un := tmp [ rand ( 1 , tmp ) ] ;
99948: LD_ADDR_VAR 0 1
99952: PUSH
99953: LD_VAR 0 2
99957: PUSH
99958: LD_INT 1
99960: PPUSH
99961: LD_VAR 0 2
99965: PPUSH
99966: CALL_OW 12
99970: ARRAY
99971: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99972: LD_VAR 0 1
99976: PPUSH
99977: LD_INT 0
99979: PPUSH
99980: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99984: LD_VAR 0 1
99988: PPUSH
99989: LD_OWVAR 3
99993: PUSH
99994: LD_VAR 0 1
99998: DIFF
99999: PPUSH
100000: LD_VAR 0 1
100004: PPUSH
100005: CALL_OW 74
100009: PPUSH
100010: CALL_OW 115
// wait ( 0 0$20 ) ;
100014: LD_INT 700
100016: PPUSH
100017: CALL_OW 67
// SetSide ( un , your_side ) ;
100021: LD_VAR 0 1
100025: PPUSH
100026: LD_OWVAR 2
100030: PPUSH
100031: CALL_OW 235
// end ;
100035: PPOPN 2
100037: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100038: LD_EXP 96
100042: PUSH
100043: LD_EXP 129
100047: AND
100048: IFFALSE 100154
100050: GO 100052
100052: DISABLE
100053: LD_INT 0
100055: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100056: LD_ADDR_VAR 0 1
100060: PUSH
100061: LD_INT 22
100063: PUSH
100064: LD_OWVAR 2
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: PUSH
100073: LD_INT 2
100075: PUSH
100076: LD_INT 30
100078: PUSH
100079: LD_INT 0
100081: PUSH
100082: EMPTY
100083: LIST
100084: LIST
100085: PUSH
100086: LD_INT 30
100088: PUSH
100089: LD_INT 1
100091: PUSH
100092: EMPTY
100093: LIST
100094: LIST
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: LIST
100100: PUSH
100101: EMPTY
100102: LIST
100103: LIST
100104: PPUSH
100105: CALL_OW 69
100109: ST_TO_ADDR
// if not depot then
100110: LD_VAR 0 1
100114: NOT
100115: IFFALSE 100119
// exit ;
100117: GO 100154
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100119: LD_VAR 0 1
100123: PUSH
100124: LD_INT 1
100126: ARRAY
100127: PPUSH
100128: CALL_OW 250
100132: PPUSH
100133: LD_VAR 0 1
100137: PUSH
100138: LD_INT 1
100140: ARRAY
100141: PPUSH
100142: CALL_OW 251
100146: PPUSH
100147: LD_INT 70
100149: PPUSH
100150: CALL_OW 495
// end ;
100154: PPOPN 1
100156: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100157: LD_EXP 96
100161: PUSH
100162: LD_EXP 130
100166: AND
100167: IFFALSE 100378
100169: GO 100171
100171: DISABLE
100172: LD_INT 0
100174: PPUSH
100175: PPUSH
100176: PPUSH
100177: PPUSH
100178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100179: LD_ADDR_VAR 0 5
100183: PUSH
100184: LD_INT 22
100186: PUSH
100187: LD_OWVAR 2
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PUSH
100196: LD_INT 21
100198: PUSH
100199: LD_INT 1
100201: PUSH
100202: EMPTY
100203: LIST
100204: LIST
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PPUSH
100210: CALL_OW 69
100214: ST_TO_ADDR
// if not tmp then
100215: LD_VAR 0 5
100219: NOT
100220: IFFALSE 100224
// exit ;
100222: GO 100378
// for i in tmp do
100224: LD_ADDR_VAR 0 1
100228: PUSH
100229: LD_VAR 0 5
100233: PUSH
100234: FOR_IN
100235: IFFALSE 100376
// begin d := rand ( 0 , 5 ) ;
100237: LD_ADDR_VAR 0 4
100241: PUSH
100242: LD_INT 0
100244: PPUSH
100245: LD_INT 5
100247: PPUSH
100248: CALL_OW 12
100252: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100253: LD_ADDR_VAR 0 2
100257: PUSH
100258: LD_VAR 0 1
100262: PPUSH
100263: CALL_OW 250
100267: PPUSH
100268: LD_VAR 0 4
100272: PPUSH
100273: LD_INT 3
100275: PPUSH
100276: LD_INT 12
100278: PPUSH
100279: CALL_OW 12
100283: PPUSH
100284: CALL_OW 272
100288: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100289: LD_ADDR_VAR 0 3
100293: PUSH
100294: LD_VAR 0 1
100298: PPUSH
100299: CALL_OW 251
100303: PPUSH
100304: LD_VAR 0 4
100308: PPUSH
100309: LD_INT 3
100311: PPUSH
100312: LD_INT 12
100314: PPUSH
100315: CALL_OW 12
100319: PPUSH
100320: CALL_OW 273
100324: ST_TO_ADDR
// if ValidHex ( x , y ) then
100325: LD_VAR 0 2
100329: PPUSH
100330: LD_VAR 0 3
100334: PPUSH
100335: CALL_OW 488
100339: IFFALSE 100374
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100341: LD_VAR 0 1
100345: PPUSH
100346: LD_VAR 0 2
100350: PPUSH
100351: LD_VAR 0 3
100355: PPUSH
100356: LD_INT 3
100358: PPUSH
100359: LD_INT 6
100361: PPUSH
100362: CALL_OW 12
100366: PPUSH
100367: LD_INT 1
100369: PPUSH
100370: CALL_OW 483
// end ;
100374: GO 100234
100376: POP
100377: POP
// end ;
100378: PPOPN 5
100380: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100381: LD_EXP 96
100385: PUSH
100386: LD_EXP 131
100390: AND
100391: IFFALSE 100485
100393: GO 100395
100395: DISABLE
100396: LD_INT 0
100398: PPUSH
100399: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100400: LD_ADDR_VAR 0 2
100404: PUSH
100405: LD_INT 22
100407: PUSH
100408: LD_OWVAR 2
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PUSH
100417: LD_INT 32
100419: PUSH
100420: LD_INT 1
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: LD_INT 21
100429: PUSH
100430: LD_INT 2
100432: PUSH
100433: EMPTY
100434: LIST
100435: LIST
100436: PUSH
100437: EMPTY
100438: LIST
100439: LIST
100440: LIST
100441: PPUSH
100442: CALL_OW 69
100446: ST_TO_ADDR
// if not tmp then
100447: LD_VAR 0 2
100451: NOT
100452: IFFALSE 100456
// exit ;
100454: GO 100485
// for i in tmp do
100456: LD_ADDR_VAR 0 1
100460: PUSH
100461: LD_VAR 0 2
100465: PUSH
100466: FOR_IN
100467: IFFALSE 100483
// SetFuel ( i , 0 ) ;
100469: LD_VAR 0 1
100473: PPUSH
100474: LD_INT 0
100476: PPUSH
100477: CALL_OW 240
100481: GO 100466
100483: POP
100484: POP
// end ;
100485: PPOPN 2
100487: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100488: LD_EXP 96
100492: PUSH
100493: LD_EXP 132
100497: AND
100498: IFFALSE 100564
100500: GO 100502
100502: DISABLE
100503: LD_INT 0
100505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100506: LD_ADDR_VAR 0 1
100510: PUSH
100511: LD_INT 22
100513: PUSH
100514: LD_OWVAR 2
100518: PUSH
100519: EMPTY
100520: LIST
100521: LIST
100522: PUSH
100523: LD_INT 30
100525: PUSH
100526: LD_INT 29
100528: PUSH
100529: EMPTY
100530: LIST
100531: LIST
100532: PUSH
100533: EMPTY
100534: LIST
100535: LIST
100536: PPUSH
100537: CALL_OW 69
100541: ST_TO_ADDR
// if not tmp then
100542: LD_VAR 0 1
100546: NOT
100547: IFFALSE 100551
// exit ;
100549: GO 100564
// DestroyUnit ( tmp [ 1 ] ) ;
100551: LD_VAR 0 1
100555: PUSH
100556: LD_INT 1
100558: ARRAY
100559: PPUSH
100560: CALL_OW 65
// end ;
100564: PPOPN 1
100566: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100567: LD_EXP 96
100571: PUSH
100572: LD_EXP 134
100576: AND
100577: IFFALSE 100706
100579: GO 100581
100581: DISABLE
100582: LD_INT 0
100584: PPUSH
// begin uc_side := 0 ;
100585: LD_ADDR_OWVAR 20
100589: PUSH
100590: LD_INT 0
100592: ST_TO_ADDR
// uc_nation := nation_arabian ;
100593: LD_ADDR_OWVAR 21
100597: PUSH
100598: LD_INT 2
100600: ST_TO_ADDR
// hc_gallery :=  ;
100601: LD_ADDR_OWVAR 33
100605: PUSH
100606: LD_STRING 
100608: ST_TO_ADDR
// hc_name :=  ;
100609: LD_ADDR_OWVAR 26
100613: PUSH
100614: LD_STRING 
100616: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100617: LD_INT 1
100619: PPUSH
100620: LD_INT 11
100622: PPUSH
100623: LD_INT 10
100625: PPUSH
100626: CALL_OW 380
// un := CreateHuman ;
100630: LD_ADDR_VAR 0 1
100634: PUSH
100635: CALL_OW 44
100639: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100640: LD_VAR 0 1
100644: PPUSH
100645: LD_INT 1
100647: PPUSH
100648: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100652: LD_INT 35
100654: PPUSH
100655: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100659: LD_VAR 0 1
100663: PPUSH
100664: LD_INT 22
100666: PUSH
100667: LD_OWVAR 2
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: PPUSH
100676: CALL_OW 69
100680: PPUSH
100681: LD_VAR 0 1
100685: PPUSH
100686: CALL_OW 74
100690: PPUSH
100691: CALL_OW 115
// until IsDead ( un ) ;
100695: LD_VAR 0 1
100699: PPUSH
100700: CALL_OW 301
100704: IFFALSE 100652
// end ;
100706: PPOPN 1
100708: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100709: LD_EXP 96
100713: PUSH
100714: LD_EXP 136
100718: AND
100719: IFFALSE 100731
100721: GO 100723
100723: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100724: LD_STRING earthquake(getX(game), 0, 32)
100726: PPUSH
100727: CALL_OW 559
100731: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100732: LD_EXP 96
100736: PUSH
100737: LD_EXP 137
100741: AND
100742: IFFALSE 100833
100744: GO 100746
100746: DISABLE
100747: LD_INT 0
100749: PPUSH
// begin enable ;
100750: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100751: LD_ADDR_VAR 0 1
100755: PUSH
100756: LD_INT 22
100758: PUSH
100759: LD_OWVAR 2
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: PUSH
100768: LD_INT 21
100770: PUSH
100771: LD_INT 2
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: PUSH
100778: LD_INT 33
100780: PUSH
100781: LD_INT 3
100783: PUSH
100784: EMPTY
100785: LIST
100786: LIST
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: LIST
100792: PPUSH
100793: CALL_OW 69
100797: ST_TO_ADDR
// if not tmp then
100798: LD_VAR 0 1
100802: NOT
100803: IFFALSE 100807
// exit ;
100805: GO 100833
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100807: LD_VAR 0 1
100811: PUSH
100812: LD_INT 1
100814: PPUSH
100815: LD_VAR 0 1
100819: PPUSH
100820: CALL_OW 12
100824: ARRAY
100825: PPUSH
100826: LD_INT 1
100828: PPUSH
100829: CALL_OW 234
// end ;
100833: PPOPN 1
100835: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100836: LD_EXP 96
100840: PUSH
100841: LD_EXP 138
100845: AND
100846: IFFALSE 100987
100848: GO 100850
100850: DISABLE
100851: LD_INT 0
100853: PPUSH
100854: PPUSH
100855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100856: LD_ADDR_VAR 0 3
100860: PUSH
100861: LD_INT 22
100863: PUSH
100864: LD_OWVAR 2
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: PUSH
100873: LD_INT 25
100875: PUSH
100876: LD_INT 1
100878: PUSH
100879: EMPTY
100880: LIST
100881: LIST
100882: PUSH
100883: EMPTY
100884: LIST
100885: LIST
100886: PPUSH
100887: CALL_OW 69
100891: ST_TO_ADDR
// if not tmp then
100892: LD_VAR 0 3
100896: NOT
100897: IFFALSE 100901
// exit ;
100899: GO 100987
// un := tmp [ rand ( 1 , tmp ) ] ;
100901: LD_ADDR_VAR 0 2
100905: PUSH
100906: LD_VAR 0 3
100910: PUSH
100911: LD_INT 1
100913: PPUSH
100914: LD_VAR 0 3
100918: PPUSH
100919: CALL_OW 12
100923: ARRAY
100924: ST_TO_ADDR
// if Crawls ( un ) then
100925: LD_VAR 0 2
100929: PPUSH
100930: CALL_OW 318
100934: IFFALSE 100945
// ComWalk ( un ) ;
100936: LD_VAR 0 2
100940: PPUSH
100941: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100945: LD_VAR 0 2
100949: PPUSH
100950: LD_INT 9
100952: PPUSH
100953: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100957: LD_INT 28
100959: PPUSH
100960: LD_OWVAR 2
100964: PPUSH
100965: LD_INT 2
100967: PPUSH
100968: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100972: LD_INT 29
100974: PPUSH
100975: LD_OWVAR 2
100979: PPUSH
100980: LD_INT 2
100982: PPUSH
100983: CALL_OW 322
// end ;
100987: PPOPN 3
100989: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100990: LD_EXP 96
100994: PUSH
100995: LD_EXP 139
100999: AND
101000: IFFALSE 101111
101002: GO 101004
101004: DISABLE
101005: LD_INT 0
101007: PPUSH
101008: PPUSH
101009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101010: LD_ADDR_VAR 0 3
101014: PUSH
101015: LD_INT 22
101017: PUSH
101018: LD_OWVAR 2
101022: PUSH
101023: EMPTY
101024: LIST
101025: LIST
101026: PUSH
101027: LD_INT 25
101029: PUSH
101030: LD_INT 1
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PPUSH
101041: CALL_OW 69
101045: ST_TO_ADDR
// if not tmp then
101046: LD_VAR 0 3
101050: NOT
101051: IFFALSE 101055
// exit ;
101053: GO 101111
// un := tmp [ rand ( 1 , tmp ) ] ;
101055: LD_ADDR_VAR 0 2
101059: PUSH
101060: LD_VAR 0 3
101064: PUSH
101065: LD_INT 1
101067: PPUSH
101068: LD_VAR 0 3
101072: PPUSH
101073: CALL_OW 12
101077: ARRAY
101078: ST_TO_ADDR
// if Crawls ( un ) then
101079: LD_VAR 0 2
101083: PPUSH
101084: CALL_OW 318
101088: IFFALSE 101099
// ComWalk ( un ) ;
101090: LD_VAR 0 2
101094: PPUSH
101095: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101099: LD_VAR 0 2
101103: PPUSH
101104: LD_INT 8
101106: PPUSH
101107: CALL_OW 336
// end ;
101111: PPOPN 3
101113: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101114: LD_EXP 96
101118: PUSH
101119: LD_EXP 140
101123: AND
101124: IFFALSE 101268
101126: GO 101128
101128: DISABLE
101129: LD_INT 0
101131: PPUSH
101132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101133: LD_ADDR_VAR 0 2
101137: PUSH
101138: LD_INT 22
101140: PUSH
101141: LD_OWVAR 2
101145: PUSH
101146: EMPTY
101147: LIST
101148: LIST
101149: PUSH
101150: LD_INT 21
101152: PUSH
101153: LD_INT 2
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PUSH
101160: LD_INT 2
101162: PUSH
101163: LD_INT 34
101165: PUSH
101166: LD_INT 12
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: LD_INT 34
101175: PUSH
101176: LD_INT 51
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: PUSH
101183: LD_INT 34
101185: PUSH
101186: LD_INT 32
101188: PUSH
101189: EMPTY
101190: LIST
101191: LIST
101192: PUSH
101193: EMPTY
101194: LIST
101195: LIST
101196: LIST
101197: LIST
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: LIST
101203: PPUSH
101204: CALL_OW 69
101208: ST_TO_ADDR
// if not tmp then
101209: LD_VAR 0 2
101213: NOT
101214: IFFALSE 101218
// exit ;
101216: GO 101268
// for i in tmp do
101218: LD_ADDR_VAR 0 1
101222: PUSH
101223: LD_VAR 0 2
101227: PUSH
101228: FOR_IN
101229: IFFALSE 101266
// if GetCargo ( i , mat_artifact ) = 0 then
101231: LD_VAR 0 1
101235: PPUSH
101236: LD_INT 4
101238: PPUSH
101239: CALL_OW 289
101243: PUSH
101244: LD_INT 0
101246: EQUAL
101247: IFFALSE 101264
// SetCargo ( i , mat_siberit , 100 ) ;
101249: LD_VAR 0 1
101253: PPUSH
101254: LD_INT 3
101256: PPUSH
101257: LD_INT 100
101259: PPUSH
101260: CALL_OW 290
101264: GO 101228
101266: POP
101267: POP
// end ;
101268: PPOPN 2
101270: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101271: LD_EXP 96
101275: PUSH
101276: LD_EXP 141
101280: AND
101281: IFFALSE 101464
101283: GO 101285
101285: DISABLE
101286: LD_INT 0
101288: PPUSH
101289: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101290: LD_ADDR_VAR 0 2
101294: PUSH
101295: LD_INT 22
101297: PUSH
101298: LD_OWVAR 2
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PPUSH
101307: CALL_OW 69
101311: ST_TO_ADDR
// if not tmp then
101312: LD_VAR 0 2
101316: NOT
101317: IFFALSE 101321
// exit ;
101319: GO 101464
// for i := 1 to 2 do
101321: LD_ADDR_VAR 0 1
101325: PUSH
101326: DOUBLE
101327: LD_INT 1
101329: DEC
101330: ST_TO_ADDR
101331: LD_INT 2
101333: PUSH
101334: FOR_TO
101335: IFFALSE 101462
// begin uc_side := your_side ;
101337: LD_ADDR_OWVAR 20
101341: PUSH
101342: LD_OWVAR 2
101346: ST_TO_ADDR
// uc_nation := nation_american ;
101347: LD_ADDR_OWVAR 21
101351: PUSH
101352: LD_INT 1
101354: ST_TO_ADDR
// vc_chassis := us_morphling ;
101355: LD_ADDR_OWVAR 37
101359: PUSH
101360: LD_INT 5
101362: ST_TO_ADDR
// vc_engine := engine_siberite ;
101363: LD_ADDR_OWVAR 39
101367: PUSH
101368: LD_INT 3
101370: ST_TO_ADDR
// vc_control := control_computer ;
101371: LD_ADDR_OWVAR 38
101375: PUSH
101376: LD_INT 3
101378: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101379: LD_ADDR_OWVAR 40
101383: PUSH
101384: LD_INT 10
101386: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101387: LD_VAR 0 2
101391: PUSH
101392: LD_INT 1
101394: ARRAY
101395: PPUSH
101396: CALL_OW 310
101400: NOT
101401: IFFALSE 101448
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101403: CALL_OW 45
101407: PPUSH
101408: LD_VAR 0 2
101412: PUSH
101413: LD_INT 1
101415: ARRAY
101416: PPUSH
101417: CALL_OW 250
101421: PPUSH
101422: LD_VAR 0 2
101426: PUSH
101427: LD_INT 1
101429: ARRAY
101430: PPUSH
101431: CALL_OW 251
101435: PPUSH
101436: LD_INT 12
101438: PPUSH
101439: LD_INT 1
101441: PPUSH
101442: CALL_OW 50
101446: GO 101460
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101448: CALL_OW 45
101452: PPUSH
101453: LD_INT 1
101455: PPUSH
101456: CALL_OW 51
// end ;
101460: GO 101334
101462: POP
101463: POP
// end ;
101464: PPOPN 2
101466: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101467: LD_EXP 96
101471: PUSH
101472: LD_EXP 142
101476: AND
101477: IFFALSE 101699
101479: GO 101481
101481: DISABLE
101482: LD_INT 0
101484: PPUSH
101485: PPUSH
101486: PPUSH
101487: PPUSH
101488: PPUSH
101489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101490: LD_ADDR_VAR 0 6
101494: PUSH
101495: LD_INT 22
101497: PUSH
101498: LD_OWVAR 2
101502: PUSH
101503: EMPTY
101504: LIST
101505: LIST
101506: PUSH
101507: LD_INT 21
101509: PUSH
101510: LD_INT 1
101512: PUSH
101513: EMPTY
101514: LIST
101515: LIST
101516: PUSH
101517: LD_INT 3
101519: PUSH
101520: LD_INT 23
101522: PUSH
101523: LD_INT 0
101525: PUSH
101526: EMPTY
101527: LIST
101528: LIST
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: LIST
101538: PPUSH
101539: CALL_OW 69
101543: ST_TO_ADDR
// if not tmp then
101544: LD_VAR 0 6
101548: NOT
101549: IFFALSE 101553
// exit ;
101551: GO 101699
// s1 := rand ( 1 , 4 ) ;
101553: LD_ADDR_VAR 0 2
101557: PUSH
101558: LD_INT 1
101560: PPUSH
101561: LD_INT 4
101563: PPUSH
101564: CALL_OW 12
101568: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101569: LD_ADDR_VAR 0 4
101573: PUSH
101574: LD_VAR 0 6
101578: PUSH
101579: LD_INT 1
101581: ARRAY
101582: PPUSH
101583: LD_VAR 0 2
101587: PPUSH
101588: CALL_OW 259
101592: ST_TO_ADDR
// if s1 = 1 then
101593: LD_VAR 0 2
101597: PUSH
101598: LD_INT 1
101600: EQUAL
101601: IFFALSE 101621
// s2 := rand ( 2 , 4 ) else
101603: LD_ADDR_VAR 0 3
101607: PUSH
101608: LD_INT 2
101610: PPUSH
101611: LD_INT 4
101613: PPUSH
101614: CALL_OW 12
101618: ST_TO_ADDR
101619: GO 101629
// s2 := 1 ;
101621: LD_ADDR_VAR 0 3
101625: PUSH
101626: LD_INT 1
101628: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101629: LD_ADDR_VAR 0 5
101633: PUSH
101634: LD_VAR 0 6
101638: PUSH
101639: LD_INT 1
101641: ARRAY
101642: PPUSH
101643: LD_VAR 0 3
101647: PPUSH
101648: CALL_OW 259
101652: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101653: LD_VAR 0 6
101657: PUSH
101658: LD_INT 1
101660: ARRAY
101661: PPUSH
101662: LD_VAR 0 2
101666: PPUSH
101667: LD_VAR 0 5
101671: PPUSH
101672: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101676: LD_VAR 0 6
101680: PUSH
101681: LD_INT 1
101683: ARRAY
101684: PPUSH
101685: LD_VAR 0 3
101689: PPUSH
101690: LD_VAR 0 4
101694: PPUSH
101695: CALL_OW 237
// end ;
101699: PPOPN 6
101701: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101702: LD_EXP 96
101706: PUSH
101707: LD_EXP 143
101711: AND
101712: IFFALSE 101791
101714: GO 101716
101716: DISABLE
101717: LD_INT 0
101719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101720: LD_ADDR_VAR 0 1
101724: PUSH
101725: LD_INT 22
101727: PUSH
101728: LD_OWVAR 2
101732: PUSH
101733: EMPTY
101734: LIST
101735: LIST
101736: PUSH
101737: LD_INT 30
101739: PUSH
101740: LD_INT 3
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: PPUSH
101751: CALL_OW 69
101755: ST_TO_ADDR
// if not tmp then
101756: LD_VAR 0 1
101760: NOT
101761: IFFALSE 101765
// exit ;
101763: GO 101791
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101765: LD_VAR 0 1
101769: PUSH
101770: LD_INT 1
101772: PPUSH
101773: LD_VAR 0 1
101777: PPUSH
101778: CALL_OW 12
101782: ARRAY
101783: PPUSH
101784: LD_INT 1
101786: PPUSH
101787: CALL_OW 234
// end ;
101791: PPOPN 1
101793: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101794: LD_EXP 96
101798: PUSH
101799: LD_EXP 144
101803: AND
101804: IFFALSE 101916
101806: GO 101808
101808: DISABLE
101809: LD_INT 0
101811: PPUSH
101812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101813: LD_ADDR_VAR 0 2
101817: PUSH
101818: LD_INT 22
101820: PUSH
101821: LD_OWVAR 2
101825: PUSH
101826: EMPTY
101827: LIST
101828: LIST
101829: PUSH
101830: LD_INT 2
101832: PUSH
101833: LD_INT 30
101835: PUSH
101836: LD_INT 27
101838: PUSH
101839: EMPTY
101840: LIST
101841: LIST
101842: PUSH
101843: LD_INT 30
101845: PUSH
101846: LD_INT 26
101848: PUSH
101849: EMPTY
101850: LIST
101851: LIST
101852: PUSH
101853: LD_INT 30
101855: PUSH
101856: LD_INT 28
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: LIST
101867: LIST
101868: PUSH
101869: EMPTY
101870: LIST
101871: LIST
101872: PPUSH
101873: CALL_OW 69
101877: ST_TO_ADDR
// if not tmp then
101878: LD_VAR 0 2
101882: NOT
101883: IFFALSE 101887
// exit ;
101885: GO 101916
// for i in tmp do
101887: LD_ADDR_VAR 0 1
101891: PUSH
101892: LD_VAR 0 2
101896: PUSH
101897: FOR_IN
101898: IFFALSE 101914
// SetLives ( i , 1 ) ;
101900: LD_VAR 0 1
101904: PPUSH
101905: LD_INT 1
101907: PPUSH
101908: CALL_OW 234
101912: GO 101897
101914: POP
101915: POP
// end ;
101916: PPOPN 2
101918: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101919: LD_EXP 96
101923: PUSH
101924: LD_EXP 145
101928: AND
101929: IFFALSE 102216
101931: GO 101933
101933: DISABLE
101934: LD_INT 0
101936: PPUSH
101937: PPUSH
101938: PPUSH
// begin i := rand ( 1 , 7 ) ;
101939: LD_ADDR_VAR 0 1
101943: PUSH
101944: LD_INT 1
101946: PPUSH
101947: LD_INT 7
101949: PPUSH
101950: CALL_OW 12
101954: ST_TO_ADDR
// case i of 1 :
101955: LD_VAR 0 1
101959: PUSH
101960: LD_INT 1
101962: DOUBLE
101963: EQUAL
101964: IFTRUE 101968
101966: GO 101978
101968: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101969: LD_STRING earthquake(getX(game), 0, 32)
101971: PPUSH
101972: CALL_OW 559
101976: GO 102216
101978: LD_INT 2
101980: DOUBLE
101981: EQUAL
101982: IFTRUE 101986
101984: GO 102000
101986: POP
// begin ToLua ( displayStucuk(); ) ;
101987: LD_STRING displayStucuk();
101989: PPUSH
101990: CALL_OW 559
// ResetFog ;
101994: CALL_OW 335
// end ; 3 :
101998: GO 102216
102000: LD_INT 3
102002: DOUBLE
102003: EQUAL
102004: IFTRUE 102008
102006: GO 102112
102008: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102009: LD_ADDR_VAR 0 2
102013: PUSH
102014: LD_INT 22
102016: PUSH
102017: LD_OWVAR 2
102021: PUSH
102022: EMPTY
102023: LIST
102024: LIST
102025: PUSH
102026: LD_INT 25
102028: PUSH
102029: LD_INT 1
102031: PUSH
102032: EMPTY
102033: LIST
102034: LIST
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: PPUSH
102040: CALL_OW 69
102044: ST_TO_ADDR
// if not tmp then
102045: LD_VAR 0 2
102049: NOT
102050: IFFALSE 102054
// exit ;
102052: GO 102216
// un := tmp [ rand ( 1 , tmp ) ] ;
102054: LD_ADDR_VAR 0 3
102058: PUSH
102059: LD_VAR 0 2
102063: PUSH
102064: LD_INT 1
102066: PPUSH
102067: LD_VAR 0 2
102071: PPUSH
102072: CALL_OW 12
102076: ARRAY
102077: ST_TO_ADDR
// if Crawls ( un ) then
102078: LD_VAR 0 3
102082: PPUSH
102083: CALL_OW 318
102087: IFFALSE 102098
// ComWalk ( un ) ;
102089: LD_VAR 0 3
102093: PPUSH
102094: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102098: LD_VAR 0 3
102102: PPUSH
102103: LD_INT 8
102105: PPUSH
102106: CALL_OW 336
// end ; 4 :
102110: GO 102216
102112: LD_INT 4
102114: DOUBLE
102115: EQUAL
102116: IFTRUE 102120
102118: GO 102194
102120: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102121: LD_ADDR_VAR 0 2
102125: PUSH
102126: LD_INT 22
102128: PUSH
102129: LD_OWVAR 2
102133: PUSH
102134: EMPTY
102135: LIST
102136: LIST
102137: PUSH
102138: LD_INT 30
102140: PUSH
102141: LD_INT 29
102143: PUSH
102144: EMPTY
102145: LIST
102146: LIST
102147: PUSH
102148: EMPTY
102149: LIST
102150: LIST
102151: PPUSH
102152: CALL_OW 69
102156: ST_TO_ADDR
// if not tmp then
102157: LD_VAR 0 2
102161: NOT
102162: IFFALSE 102166
// exit ;
102164: GO 102216
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102166: LD_VAR 0 2
102170: PUSH
102171: LD_INT 1
102173: ARRAY
102174: PPUSH
102175: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102179: LD_VAR 0 2
102183: PUSH
102184: LD_INT 1
102186: ARRAY
102187: PPUSH
102188: CALL_OW 65
// end ; 5 .. 7 :
102192: GO 102216
102194: LD_INT 5
102196: DOUBLE
102197: GREATEREQUAL
102198: IFFALSE 102206
102200: LD_INT 7
102202: DOUBLE
102203: LESSEQUAL
102204: IFTRUE 102208
102206: GO 102215
102208: POP
// StreamSibBomb ; end ;
102209: CALL 98453 0 0
102213: GO 102216
102215: POP
// end ;
102216: PPOPN 3
102218: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102219: LD_EXP 96
102223: PUSH
102224: LD_EXP 146
102228: AND
102229: IFFALSE 102385
102231: GO 102233
102233: DISABLE
102234: LD_INT 0
102236: PPUSH
102237: PPUSH
102238: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102239: LD_ADDR_VAR 0 2
102243: PUSH
102244: LD_INT 81
102246: PUSH
102247: LD_OWVAR 2
102251: PUSH
102252: EMPTY
102253: LIST
102254: LIST
102255: PUSH
102256: LD_INT 2
102258: PUSH
102259: LD_INT 21
102261: PUSH
102262: LD_INT 1
102264: PUSH
102265: EMPTY
102266: LIST
102267: LIST
102268: PUSH
102269: LD_INT 21
102271: PUSH
102272: LD_INT 2
102274: PUSH
102275: EMPTY
102276: LIST
102277: LIST
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: LIST
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: PPUSH
102288: CALL_OW 69
102292: ST_TO_ADDR
// if not tmp then
102293: LD_VAR 0 2
102297: NOT
102298: IFFALSE 102302
// exit ;
102300: GO 102385
// p := 0 ;
102302: LD_ADDR_VAR 0 3
102306: PUSH
102307: LD_INT 0
102309: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102310: LD_INT 35
102312: PPUSH
102313: CALL_OW 67
// p := p + 1 ;
102317: LD_ADDR_VAR 0 3
102321: PUSH
102322: LD_VAR 0 3
102326: PUSH
102327: LD_INT 1
102329: PLUS
102330: ST_TO_ADDR
// for i in tmp do
102331: LD_ADDR_VAR 0 1
102335: PUSH
102336: LD_VAR 0 2
102340: PUSH
102341: FOR_IN
102342: IFFALSE 102373
// if GetLives ( i ) < 1000 then
102344: LD_VAR 0 1
102348: PPUSH
102349: CALL_OW 256
102353: PUSH
102354: LD_INT 1000
102356: LESS
102357: IFFALSE 102371
// SetLives ( i , 1000 ) ;
102359: LD_VAR 0 1
102363: PPUSH
102364: LD_INT 1000
102366: PPUSH
102367: CALL_OW 234
102371: GO 102341
102373: POP
102374: POP
// until p > 20 ;
102375: LD_VAR 0 3
102379: PUSH
102380: LD_INT 20
102382: GREATER
102383: IFFALSE 102310
// end ;
102385: PPOPN 3
102387: END
// every 0 0$1 trigger StreamModeActive and sTime do
102388: LD_EXP 96
102392: PUSH
102393: LD_EXP 147
102397: AND
102398: IFFALSE 102433
102400: GO 102402
102402: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102403: LD_INT 28
102405: PPUSH
102406: LD_OWVAR 2
102410: PPUSH
102411: LD_INT 2
102413: PPUSH
102414: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102418: LD_INT 30
102420: PPUSH
102421: LD_OWVAR 2
102425: PPUSH
102426: LD_INT 2
102428: PPUSH
102429: CALL_OW 322
// end ;
102433: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102434: LD_EXP 96
102438: PUSH
102439: LD_EXP 148
102443: AND
102444: IFFALSE 102565
102446: GO 102448
102448: DISABLE
102449: LD_INT 0
102451: PPUSH
102452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102453: LD_ADDR_VAR 0 2
102457: PUSH
102458: LD_INT 22
102460: PUSH
102461: LD_OWVAR 2
102465: PUSH
102466: EMPTY
102467: LIST
102468: LIST
102469: PUSH
102470: LD_INT 21
102472: PUSH
102473: LD_INT 1
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: LD_INT 3
102482: PUSH
102483: LD_INT 23
102485: PUSH
102486: LD_INT 0
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PUSH
102497: EMPTY
102498: LIST
102499: LIST
102500: LIST
102501: PPUSH
102502: CALL_OW 69
102506: ST_TO_ADDR
// if not tmp then
102507: LD_VAR 0 2
102511: NOT
102512: IFFALSE 102516
// exit ;
102514: GO 102565
// for i in tmp do
102516: LD_ADDR_VAR 0 1
102520: PUSH
102521: LD_VAR 0 2
102525: PUSH
102526: FOR_IN
102527: IFFALSE 102563
// begin if Crawls ( i ) then
102529: LD_VAR 0 1
102533: PPUSH
102534: CALL_OW 318
102538: IFFALSE 102549
// ComWalk ( i ) ;
102540: LD_VAR 0 1
102544: PPUSH
102545: CALL_OW 138
// SetClass ( i , 2 ) ;
102549: LD_VAR 0 1
102553: PPUSH
102554: LD_INT 2
102556: PPUSH
102557: CALL_OW 336
// end ;
102561: GO 102526
102563: POP
102564: POP
// end ;
102565: PPOPN 2
102567: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102568: LD_EXP 96
102572: PUSH
102573: LD_EXP 149
102577: AND
102578: IFFALSE 102866
102580: GO 102582
102582: DISABLE
102583: LD_INT 0
102585: PPUSH
102586: PPUSH
102587: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102588: LD_OWVAR 2
102592: PPUSH
102593: LD_INT 9
102595: PPUSH
102596: LD_INT 1
102598: PPUSH
102599: LD_INT 1
102601: PPUSH
102602: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102606: LD_INT 9
102608: PPUSH
102609: LD_OWVAR 2
102613: PPUSH
102614: CALL_OW 343
// uc_side := 9 ;
102618: LD_ADDR_OWVAR 20
102622: PUSH
102623: LD_INT 9
102625: ST_TO_ADDR
// uc_nation := 2 ;
102626: LD_ADDR_OWVAR 21
102630: PUSH
102631: LD_INT 2
102633: ST_TO_ADDR
// hc_name := Dark Warrior ;
102634: LD_ADDR_OWVAR 26
102638: PUSH
102639: LD_STRING Dark Warrior
102641: ST_TO_ADDR
// hc_gallery :=  ;
102642: LD_ADDR_OWVAR 33
102646: PUSH
102647: LD_STRING 
102649: ST_TO_ADDR
// hc_noskilllimit := true ;
102650: LD_ADDR_OWVAR 76
102654: PUSH
102655: LD_INT 1
102657: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102658: LD_ADDR_OWVAR 31
102662: PUSH
102663: LD_INT 30
102665: PUSH
102666: LD_INT 30
102668: PUSH
102669: LD_INT 30
102671: PUSH
102672: LD_INT 30
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: LIST
102679: LIST
102680: ST_TO_ADDR
// un := CreateHuman ;
102681: LD_ADDR_VAR 0 3
102685: PUSH
102686: CALL_OW 44
102690: ST_TO_ADDR
// hc_noskilllimit := false ;
102691: LD_ADDR_OWVAR 76
102695: PUSH
102696: LD_INT 0
102698: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102699: LD_VAR 0 3
102703: PPUSH
102704: LD_INT 1
102706: PPUSH
102707: CALL_OW 51
// ToLua ( playRanger() ) ;
102711: LD_STRING playRanger()
102713: PPUSH
102714: CALL_OW 559
// p := 0 ;
102718: LD_ADDR_VAR 0 2
102722: PUSH
102723: LD_INT 0
102725: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102726: LD_INT 35
102728: PPUSH
102729: CALL_OW 67
// p := p + 1 ;
102733: LD_ADDR_VAR 0 2
102737: PUSH
102738: LD_VAR 0 2
102742: PUSH
102743: LD_INT 1
102745: PLUS
102746: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102747: LD_VAR 0 3
102751: PPUSH
102752: CALL_OW 256
102756: PUSH
102757: LD_INT 1000
102759: LESS
102760: IFFALSE 102774
// SetLives ( un , 1000 ) ;
102762: LD_VAR 0 3
102766: PPUSH
102767: LD_INT 1000
102769: PPUSH
102770: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102774: LD_VAR 0 3
102778: PPUSH
102779: LD_INT 81
102781: PUSH
102782: LD_OWVAR 2
102786: PUSH
102787: EMPTY
102788: LIST
102789: LIST
102790: PUSH
102791: LD_INT 91
102793: PUSH
102794: LD_VAR 0 3
102798: PUSH
102799: LD_INT 30
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: LIST
102806: PUSH
102807: EMPTY
102808: LIST
102809: LIST
102810: PPUSH
102811: CALL_OW 69
102815: PPUSH
102816: LD_VAR 0 3
102820: PPUSH
102821: CALL_OW 74
102825: PPUSH
102826: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102830: LD_VAR 0 2
102834: PUSH
102835: LD_INT 80
102837: GREATER
102838: PUSH
102839: LD_VAR 0 3
102843: PPUSH
102844: CALL_OW 301
102848: OR
102849: IFFALSE 102726
// if un then
102851: LD_VAR 0 3
102855: IFFALSE 102866
// RemoveUnit ( un ) ;
102857: LD_VAR 0 3
102861: PPUSH
102862: CALL_OW 64
// end ;
102866: PPOPN 3
102868: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102869: LD_EXP 150
102873: IFFALSE 102989
102875: GO 102877
102877: DISABLE
102878: LD_INT 0
102880: PPUSH
102881: PPUSH
102882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102883: LD_ADDR_VAR 0 2
102887: PUSH
102888: LD_INT 81
102890: PUSH
102891: LD_OWVAR 2
102895: PUSH
102896: EMPTY
102897: LIST
102898: LIST
102899: PUSH
102900: LD_INT 21
102902: PUSH
102903: LD_INT 1
102905: PUSH
102906: EMPTY
102907: LIST
102908: LIST
102909: PUSH
102910: EMPTY
102911: LIST
102912: LIST
102913: PPUSH
102914: CALL_OW 69
102918: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102919: LD_STRING playComputer()
102921: PPUSH
102922: CALL_OW 559
// if not tmp then
102926: LD_VAR 0 2
102930: NOT
102931: IFFALSE 102935
// exit ;
102933: GO 102989
// for i in tmp do
102935: LD_ADDR_VAR 0 1
102939: PUSH
102940: LD_VAR 0 2
102944: PUSH
102945: FOR_IN
102946: IFFALSE 102987
// for j := 1 to 4 do
102948: LD_ADDR_VAR 0 3
102952: PUSH
102953: DOUBLE
102954: LD_INT 1
102956: DEC
102957: ST_TO_ADDR
102958: LD_INT 4
102960: PUSH
102961: FOR_TO
102962: IFFALSE 102983
// SetSkill ( i , j , 10 ) ;
102964: LD_VAR 0 1
102968: PPUSH
102969: LD_VAR 0 3
102973: PPUSH
102974: LD_INT 10
102976: PPUSH
102977: CALL_OW 237
102981: GO 102961
102983: POP
102984: POP
102985: GO 102945
102987: POP
102988: POP
// end ;
102989: PPOPN 3
102991: END
// every 0 0$1 trigger s30 do var i , tmp ;
102992: LD_EXP 151
102996: IFFALSE 103065
102998: GO 103000
103000: DISABLE
103001: LD_INT 0
103003: PPUSH
103004: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103005: LD_ADDR_VAR 0 2
103009: PUSH
103010: LD_INT 22
103012: PUSH
103013: LD_OWVAR 2
103017: PUSH
103018: EMPTY
103019: LIST
103020: LIST
103021: PPUSH
103022: CALL_OW 69
103026: ST_TO_ADDR
// if not tmp then
103027: LD_VAR 0 2
103031: NOT
103032: IFFALSE 103036
// exit ;
103034: GO 103065
// for i in tmp do
103036: LD_ADDR_VAR 0 1
103040: PUSH
103041: LD_VAR 0 2
103045: PUSH
103046: FOR_IN
103047: IFFALSE 103063
// SetLives ( i , 300 ) ;
103049: LD_VAR 0 1
103053: PPUSH
103054: LD_INT 300
103056: PPUSH
103057: CALL_OW 234
103061: GO 103046
103063: POP
103064: POP
// end ;
103065: PPOPN 2
103067: END
// every 0 0$1 trigger s60 do var i , tmp ;
103068: LD_EXP 152
103072: IFFALSE 103141
103074: GO 103076
103076: DISABLE
103077: LD_INT 0
103079: PPUSH
103080: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103081: LD_ADDR_VAR 0 2
103085: PUSH
103086: LD_INT 22
103088: PUSH
103089: LD_OWVAR 2
103093: PUSH
103094: EMPTY
103095: LIST
103096: LIST
103097: PPUSH
103098: CALL_OW 69
103102: ST_TO_ADDR
// if not tmp then
103103: LD_VAR 0 2
103107: NOT
103108: IFFALSE 103112
// exit ;
103110: GO 103141
// for i in tmp do
103112: LD_ADDR_VAR 0 1
103116: PUSH
103117: LD_VAR 0 2
103121: PUSH
103122: FOR_IN
103123: IFFALSE 103139
// SetLives ( i , 600 ) ;
103125: LD_VAR 0 1
103129: PPUSH
103130: LD_INT 600
103132: PPUSH
103133: CALL_OW 234
103137: GO 103122
103139: POP
103140: POP
// end ;
103141: PPOPN 2
103143: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103144: LD_INT 0
103146: PPUSH
// case cmd of 301 :
103147: LD_VAR 0 1
103151: PUSH
103152: LD_INT 301
103154: DOUBLE
103155: EQUAL
103156: IFTRUE 103160
103158: GO 103192
103160: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103161: LD_VAR 0 6
103165: PPUSH
103166: LD_VAR 0 7
103170: PPUSH
103171: LD_VAR 0 8
103175: PPUSH
103176: LD_VAR 0 4
103180: PPUSH
103181: LD_VAR 0 5
103185: PPUSH
103186: CALL 104401 0 5
103190: GO 103313
103192: LD_INT 302
103194: DOUBLE
103195: EQUAL
103196: IFTRUE 103200
103198: GO 103237
103200: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103201: LD_VAR 0 6
103205: PPUSH
103206: LD_VAR 0 7
103210: PPUSH
103211: LD_VAR 0 8
103215: PPUSH
103216: LD_VAR 0 9
103220: PPUSH
103221: LD_VAR 0 4
103225: PPUSH
103226: LD_VAR 0 5
103230: PPUSH
103231: CALL 104492 0 6
103235: GO 103313
103237: LD_INT 303
103239: DOUBLE
103240: EQUAL
103241: IFTRUE 103245
103243: GO 103282
103245: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103246: LD_VAR 0 6
103250: PPUSH
103251: LD_VAR 0 7
103255: PPUSH
103256: LD_VAR 0 8
103260: PPUSH
103261: LD_VAR 0 9
103265: PPUSH
103266: LD_VAR 0 4
103270: PPUSH
103271: LD_VAR 0 5
103275: PPUSH
103276: CALL 103318 0 6
103280: GO 103313
103282: LD_INT 304
103284: DOUBLE
103285: EQUAL
103286: IFTRUE 103290
103288: GO 103312
103290: POP
// hHackTeleport ( unit , x , y ) ; end ;
103291: LD_VAR 0 2
103295: PPUSH
103296: LD_VAR 0 4
103300: PPUSH
103301: LD_VAR 0 5
103305: PPUSH
103306: CALL 105085 0 3
103310: GO 103313
103312: POP
// end ;
103313: LD_VAR 0 12
103317: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103318: LD_INT 0
103320: PPUSH
103321: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103322: LD_VAR 0 1
103326: PUSH
103327: LD_INT 1
103329: LESS
103330: PUSH
103331: LD_VAR 0 1
103335: PUSH
103336: LD_INT 3
103338: GREATER
103339: OR
103340: PUSH
103341: LD_VAR 0 5
103345: PPUSH
103346: LD_VAR 0 6
103350: PPUSH
103351: CALL_OW 428
103355: OR
103356: IFFALSE 103360
// exit ;
103358: GO 104088
// uc_side := your_side ;
103360: LD_ADDR_OWVAR 20
103364: PUSH
103365: LD_OWVAR 2
103369: ST_TO_ADDR
// uc_nation := nation ;
103370: LD_ADDR_OWVAR 21
103374: PUSH
103375: LD_VAR 0 1
103379: ST_TO_ADDR
// bc_level = 1 ;
103380: LD_ADDR_OWVAR 43
103384: PUSH
103385: LD_INT 1
103387: ST_TO_ADDR
// case btype of 1 :
103388: LD_VAR 0 2
103392: PUSH
103393: LD_INT 1
103395: DOUBLE
103396: EQUAL
103397: IFTRUE 103401
103399: GO 103412
103401: POP
// bc_type := b_depot ; 2 :
103402: LD_ADDR_OWVAR 42
103406: PUSH
103407: LD_INT 0
103409: ST_TO_ADDR
103410: GO 104032
103412: LD_INT 2
103414: DOUBLE
103415: EQUAL
103416: IFTRUE 103420
103418: GO 103431
103420: POP
// bc_type := b_warehouse ; 3 :
103421: LD_ADDR_OWVAR 42
103425: PUSH
103426: LD_INT 1
103428: ST_TO_ADDR
103429: GO 104032
103431: LD_INT 3
103433: DOUBLE
103434: EQUAL
103435: IFTRUE 103439
103437: GO 103450
103439: POP
// bc_type := b_lab ; 4 .. 9 :
103440: LD_ADDR_OWVAR 42
103444: PUSH
103445: LD_INT 6
103447: ST_TO_ADDR
103448: GO 104032
103450: LD_INT 4
103452: DOUBLE
103453: GREATEREQUAL
103454: IFFALSE 103462
103456: LD_INT 9
103458: DOUBLE
103459: LESSEQUAL
103460: IFTRUE 103464
103462: GO 103524
103464: POP
// begin bc_type := b_lab_half ;
103465: LD_ADDR_OWVAR 42
103469: PUSH
103470: LD_INT 7
103472: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103473: LD_ADDR_OWVAR 44
103477: PUSH
103478: LD_INT 10
103480: PUSH
103481: LD_INT 11
103483: PUSH
103484: LD_INT 12
103486: PUSH
103487: LD_INT 15
103489: PUSH
103490: LD_INT 14
103492: PUSH
103493: LD_INT 13
103495: PUSH
103496: EMPTY
103497: LIST
103498: LIST
103499: LIST
103500: LIST
103501: LIST
103502: LIST
103503: PUSH
103504: LD_VAR 0 2
103508: PUSH
103509: LD_INT 3
103511: MINUS
103512: ARRAY
103513: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103514: LD_ADDR_OWVAR 45
103518: PUSH
103519: LD_INT 9
103521: ST_TO_ADDR
// end ; 10 .. 13 :
103522: GO 104032
103524: LD_INT 10
103526: DOUBLE
103527: GREATEREQUAL
103528: IFFALSE 103536
103530: LD_INT 13
103532: DOUBLE
103533: LESSEQUAL
103534: IFTRUE 103538
103536: GO 103615
103538: POP
// begin bc_type := b_lab_full ;
103539: LD_ADDR_OWVAR 42
103543: PUSH
103544: LD_INT 8
103546: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103547: LD_ADDR_OWVAR 44
103551: PUSH
103552: LD_INT 10
103554: PUSH
103555: LD_INT 12
103557: PUSH
103558: LD_INT 14
103560: PUSH
103561: LD_INT 13
103563: PUSH
103564: EMPTY
103565: LIST
103566: LIST
103567: LIST
103568: LIST
103569: PUSH
103570: LD_VAR 0 2
103574: PUSH
103575: LD_INT 9
103577: MINUS
103578: ARRAY
103579: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103580: LD_ADDR_OWVAR 45
103584: PUSH
103585: LD_INT 11
103587: PUSH
103588: LD_INT 15
103590: PUSH
103591: LD_INT 12
103593: PUSH
103594: LD_INT 15
103596: PUSH
103597: EMPTY
103598: LIST
103599: LIST
103600: LIST
103601: LIST
103602: PUSH
103603: LD_VAR 0 2
103607: PUSH
103608: LD_INT 9
103610: MINUS
103611: ARRAY
103612: ST_TO_ADDR
// end ; 14 :
103613: GO 104032
103615: LD_INT 14
103617: DOUBLE
103618: EQUAL
103619: IFTRUE 103623
103621: GO 103634
103623: POP
// bc_type := b_workshop ; 15 :
103624: LD_ADDR_OWVAR 42
103628: PUSH
103629: LD_INT 2
103631: ST_TO_ADDR
103632: GO 104032
103634: LD_INT 15
103636: DOUBLE
103637: EQUAL
103638: IFTRUE 103642
103640: GO 103653
103642: POP
// bc_type := b_factory ; 16 :
103643: LD_ADDR_OWVAR 42
103647: PUSH
103648: LD_INT 3
103650: ST_TO_ADDR
103651: GO 104032
103653: LD_INT 16
103655: DOUBLE
103656: EQUAL
103657: IFTRUE 103661
103659: GO 103672
103661: POP
// bc_type := b_ext_gun ; 17 :
103662: LD_ADDR_OWVAR 42
103666: PUSH
103667: LD_INT 17
103669: ST_TO_ADDR
103670: GO 104032
103672: LD_INT 17
103674: DOUBLE
103675: EQUAL
103676: IFTRUE 103680
103678: GO 103708
103680: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103681: LD_ADDR_OWVAR 42
103685: PUSH
103686: LD_INT 19
103688: PUSH
103689: LD_INT 23
103691: PUSH
103692: LD_INT 19
103694: PUSH
103695: EMPTY
103696: LIST
103697: LIST
103698: LIST
103699: PUSH
103700: LD_VAR 0 1
103704: ARRAY
103705: ST_TO_ADDR
103706: GO 104032
103708: LD_INT 18
103710: DOUBLE
103711: EQUAL
103712: IFTRUE 103716
103714: GO 103727
103716: POP
// bc_type := b_ext_radar ; 19 :
103717: LD_ADDR_OWVAR 42
103721: PUSH
103722: LD_INT 20
103724: ST_TO_ADDR
103725: GO 104032
103727: LD_INT 19
103729: DOUBLE
103730: EQUAL
103731: IFTRUE 103735
103733: GO 103746
103735: POP
// bc_type := b_ext_radio ; 20 :
103736: LD_ADDR_OWVAR 42
103740: PUSH
103741: LD_INT 22
103743: ST_TO_ADDR
103744: GO 104032
103746: LD_INT 20
103748: DOUBLE
103749: EQUAL
103750: IFTRUE 103754
103752: GO 103765
103754: POP
// bc_type := b_ext_siberium ; 21 :
103755: LD_ADDR_OWVAR 42
103759: PUSH
103760: LD_INT 21
103762: ST_TO_ADDR
103763: GO 104032
103765: LD_INT 21
103767: DOUBLE
103768: EQUAL
103769: IFTRUE 103773
103771: GO 103784
103773: POP
// bc_type := b_ext_computer ; 22 :
103774: LD_ADDR_OWVAR 42
103778: PUSH
103779: LD_INT 24
103781: ST_TO_ADDR
103782: GO 104032
103784: LD_INT 22
103786: DOUBLE
103787: EQUAL
103788: IFTRUE 103792
103790: GO 103803
103792: POP
// bc_type := b_ext_track ; 23 :
103793: LD_ADDR_OWVAR 42
103797: PUSH
103798: LD_INT 16
103800: ST_TO_ADDR
103801: GO 104032
103803: LD_INT 23
103805: DOUBLE
103806: EQUAL
103807: IFTRUE 103811
103809: GO 103822
103811: POP
// bc_type := b_ext_laser ; 24 :
103812: LD_ADDR_OWVAR 42
103816: PUSH
103817: LD_INT 25
103819: ST_TO_ADDR
103820: GO 104032
103822: LD_INT 24
103824: DOUBLE
103825: EQUAL
103826: IFTRUE 103830
103828: GO 103841
103830: POP
// bc_type := b_control_tower ; 25 :
103831: LD_ADDR_OWVAR 42
103835: PUSH
103836: LD_INT 36
103838: ST_TO_ADDR
103839: GO 104032
103841: LD_INT 25
103843: DOUBLE
103844: EQUAL
103845: IFTRUE 103849
103847: GO 103860
103849: POP
// bc_type := b_breastwork ; 26 :
103850: LD_ADDR_OWVAR 42
103854: PUSH
103855: LD_INT 31
103857: ST_TO_ADDR
103858: GO 104032
103860: LD_INT 26
103862: DOUBLE
103863: EQUAL
103864: IFTRUE 103868
103866: GO 103879
103868: POP
// bc_type := b_bunker ; 27 :
103869: LD_ADDR_OWVAR 42
103873: PUSH
103874: LD_INT 32
103876: ST_TO_ADDR
103877: GO 104032
103879: LD_INT 27
103881: DOUBLE
103882: EQUAL
103883: IFTRUE 103887
103885: GO 103898
103887: POP
// bc_type := b_turret ; 28 :
103888: LD_ADDR_OWVAR 42
103892: PUSH
103893: LD_INT 33
103895: ST_TO_ADDR
103896: GO 104032
103898: LD_INT 28
103900: DOUBLE
103901: EQUAL
103902: IFTRUE 103906
103904: GO 103917
103906: POP
// bc_type := b_armoury ; 29 :
103907: LD_ADDR_OWVAR 42
103911: PUSH
103912: LD_INT 4
103914: ST_TO_ADDR
103915: GO 104032
103917: LD_INT 29
103919: DOUBLE
103920: EQUAL
103921: IFTRUE 103925
103923: GO 103936
103925: POP
// bc_type := b_barracks ; 30 :
103926: LD_ADDR_OWVAR 42
103930: PUSH
103931: LD_INT 5
103933: ST_TO_ADDR
103934: GO 104032
103936: LD_INT 30
103938: DOUBLE
103939: EQUAL
103940: IFTRUE 103944
103942: GO 103955
103944: POP
// bc_type := b_solar_power ; 31 :
103945: LD_ADDR_OWVAR 42
103949: PUSH
103950: LD_INT 27
103952: ST_TO_ADDR
103953: GO 104032
103955: LD_INT 31
103957: DOUBLE
103958: EQUAL
103959: IFTRUE 103963
103961: GO 103974
103963: POP
// bc_type := b_oil_power ; 32 :
103964: LD_ADDR_OWVAR 42
103968: PUSH
103969: LD_INT 26
103971: ST_TO_ADDR
103972: GO 104032
103974: LD_INT 32
103976: DOUBLE
103977: EQUAL
103978: IFTRUE 103982
103980: GO 103993
103982: POP
// bc_type := b_siberite_power ; 33 :
103983: LD_ADDR_OWVAR 42
103987: PUSH
103988: LD_INT 28
103990: ST_TO_ADDR
103991: GO 104032
103993: LD_INT 33
103995: DOUBLE
103996: EQUAL
103997: IFTRUE 104001
103999: GO 104012
104001: POP
// bc_type := b_oil_mine ; 34 :
104002: LD_ADDR_OWVAR 42
104006: PUSH
104007: LD_INT 29
104009: ST_TO_ADDR
104010: GO 104032
104012: LD_INT 34
104014: DOUBLE
104015: EQUAL
104016: IFTRUE 104020
104018: GO 104031
104020: POP
// bc_type := b_siberite_mine ; end ;
104021: LD_ADDR_OWVAR 42
104025: PUSH
104026: LD_INT 30
104028: ST_TO_ADDR
104029: GO 104032
104031: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104032: LD_ADDR_VAR 0 8
104036: PUSH
104037: LD_VAR 0 5
104041: PPUSH
104042: LD_VAR 0 6
104046: PPUSH
104047: LD_VAR 0 3
104051: PPUSH
104052: CALL_OW 47
104056: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104057: LD_OWVAR 42
104061: PUSH
104062: LD_INT 32
104064: PUSH
104065: LD_INT 33
104067: PUSH
104068: EMPTY
104069: LIST
104070: LIST
104071: IN
104072: IFFALSE 104088
// PlaceWeaponTurret ( b , weapon ) ;
104074: LD_VAR 0 8
104078: PPUSH
104079: LD_VAR 0 4
104083: PPUSH
104084: CALL_OW 431
// end ;
104088: LD_VAR 0 7
104092: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104093: LD_INT 0
104095: PPUSH
104096: PPUSH
104097: PPUSH
104098: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104099: LD_ADDR_VAR 0 4
104103: PUSH
104104: LD_INT 22
104106: PUSH
104107: LD_OWVAR 2
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: PUSH
104116: LD_INT 2
104118: PUSH
104119: LD_INT 30
104121: PUSH
104122: LD_INT 0
104124: PUSH
104125: EMPTY
104126: LIST
104127: LIST
104128: PUSH
104129: LD_INT 30
104131: PUSH
104132: LD_INT 1
104134: PUSH
104135: EMPTY
104136: LIST
104137: LIST
104138: PUSH
104139: EMPTY
104140: LIST
104141: LIST
104142: LIST
104143: PUSH
104144: EMPTY
104145: LIST
104146: LIST
104147: PPUSH
104148: CALL_OW 69
104152: ST_TO_ADDR
// if not tmp then
104153: LD_VAR 0 4
104157: NOT
104158: IFFALSE 104162
// exit ;
104160: GO 104221
// for i in tmp do
104162: LD_ADDR_VAR 0 2
104166: PUSH
104167: LD_VAR 0 4
104171: PUSH
104172: FOR_IN
104173: IFFALSE 104219
// for j = 1 to 3 do
104175: LD_ADDR_VAR 0 3
104179: PUSH
104180: DOUBLE
104181: LD_INT 1
104183: DEC
104184: ST_TO_ADDR
104185: LD_INT 3
104187: PUSH
104188: FOR_TO
104189: IFFALSE 104215
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104191: LD_VAR 0 2
104195: PPUSH
104196: CALL_OW 274
104200: PPUSH
104201: LD_VAR 0 3
104205: PPUSH
104206: LD_INT 99999
104208: PPUSH
104209: CALL_OW 277
104213: GO 104188
104215: POP
104216: POP
104217: GO 104172
104219: POP
104220: POP
// end ;
104221: LD_VAR 0 1
104225: RET
// export function hHackSetLevel10 ; var i , j ; begin
104226: LD_INT 0
104228: PPUSH
104229: PPUSH
104230: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104231: LD_ADDR_VAR 0 2
104235: PUSH
104236: LD_INT 21
104238: PUSH
104239: LD_INT 1
104241: PUSH
104242: EMPTY
104243: LIST
104244: LIST
104245: PPUSH
104246: CALL_OW 69
104250: PUSH
104251: FOR_IN
104252: IFFALSE 104304
// if IsSelected ( i ) then
104254: LD_VAR 0 2
104258: PPUSH
104259: CALL_OW 306
104263: IFFALSE 104302
// begin for j := 1 to 4 do
104265: LD_ADDR_VAR 0 3
104269: PUSH
104270: DOUBLE
104271: LD_INT 1
104273: DEC
104274: ST_TO_ADDR
104275: LD_INT 4
104277: PUSH
104278: FOR_TO
104279: IFFALSE 104300
// SetSkill ( i , j , 10 ) ;
104281: LD_VAR 0 2
104285: PPUSH
104286: LD_VAR 0 3
104290: PPUSH
104291: LD_INT 10
104293: PPUSH
104294: CALL_OW 237
104298: GO 104278
104300: POP
104301: POP
// end ;
104302: GO 104251
104304: POP
104305: POP
// end ;
104306: LD_VAR 0 1
104310: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104311: LD_INT 0
104313: PPUSH
104314: PPUSH
104315: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104316: LD_ADDR_VAR 0 2
104320: PUSH
104321: LD_INT 22
104323: PUSH
104324: LD_OWVAR 2
104328: PUSH
104329: EMPTY
104330: LIST
104331: LIST
104332: PUSH
104333: LD_INT 21
104335: PUSH
104336: LD_INT 1
104338: PUSH
104339: EMPTY
104340: LIST
104341: LIST
104342: PUSH
104343: EMPTY
104344: LIST
104345: LIST
104346: PPUSH
104347: CALL_OW 69
104351: PUSH
104352: FOR_IN
104353: IFFALSE 104394
// begin for j := 1 to 4 do
104355: LD_ADDR_VAR 0 3
104359: PUSH
104360: DOUBLE
104361: LD_INT 1
104363: DEC
104364: ST_TO_ADDR
104365: LD_INT 4
104367: PUSH
104368: FOR_TO
104369: IFFALSE 104390
// SetSkill ( i , j , 10 ) ;
104371: LD_VAR 0 2
104375: PPUSH
104376: LD_VAR 0 3
104380: PPUSH
104381: LD_INT 10
104383: PPUSH
104384: CALL_OW 237
104388: GO 104368
104390: POP
104391: POP
// end ;
104392: GO 104352
104394: POP
104395: POP
// end ;
104396: LD_VAR 0 1
104400: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104401: LD_INT 0
104403: PPUSH
// uc_side := your_side ;
104404: LD_ADDR_OWVAR 20
104408: PUSH
104409: LD_OWVAR 2
104413: ST_TO_ADDR
// uc_nation := nation ;
104414: LD_ADDR_OWVAR 21
104418: PUSH
104419: LD_VAR 0 1
104423: ST_TO_ADDR
// InitHc ;
104424: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104428: LD_INT 0
104430: PPUSH
104431: LD_VAR 0 2
104435: PPUSH
104436: LD_VAR 0 3
104440: PPUSH
104441: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104445: LD_VAR 0 4
104449: PPUSH
104450: LD_VAR 0 5
104454: PPUSH
104455: CALL_OW 428
104459: PUSH
104460: LD_INT 0
104462: EQUAL
104463: IFFALSE 104487
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104465: CALL_OW 44
104469: PPUSH
104470: LD_VAR 0 4
104474: PPUSH
104475: LD_VAR 0 5
104479: PPUSH
104480: LD_INT 1
104482: PPUSH
104483: CALL_OW 48
// end ;
104487: LD_VAR 0 6
104491: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104492: LD_INT 0
104494: PPUSH
104495: PPUSH
// uc_side := your_side ;
104496: LD_ADDR_OWVAR 20
104500: PUSH
104501: LD_OWVAR 2
104505: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104506: LD_VAR 0 1
104510: PUSH
104511: LD_INT 1
104513: PUSH
104514: LD_INT 2
104516: PUSH
104517: LD_INT 3
104519: PUSH
104520: LD_INT 4
104522: PUSH
104523: LD_INT 5
104525: PUSH
104526: EMPTY
104527: LIST
104528: LIST
104529: LIST
104530: LIST
104531: LIST
104532: IN
104533: IFFALSE 104545
// uc_nation := nation_american else
104535: LD_ADDR_OWVAR 21
104539: PUSH
104540: LD_INT 1
104542: ST_TO_ADDR
104543: GO 104588
// if chassis in [ 11 , 12 , 13 , 14 ] then
104545: LD_VAR 0 1
104549: PUSH
104550: LD_INT 11
104552: PUSH
104553: LD_INT 12
104555: PUSH
104556: LD_INT 13
104558: PUSH
104559: LD_INT 14
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: IN
104568: IFFALSE 104580
// uc_nation := nation_arabian else
104570: LD_ADDR_OWVAR 21
104574: PUSH
104575: LD_INT 2
104577: ST_TO_ADDR
104578: GO 104588
// uc_nation := nation_russian ;
104580: LD_ADDR_OWVAR 21
104584: PUSH
104585: LD_INT 3
104587: ST_TO_ADDR
// vc_chassis := chassis ;
104588: LD_ADDR_OWVAR 37
104592: PUSH
104593: LD_VAR 0 1
104597: ST_TO_ADDR
// vc_engine := engine ;
104598: LD_ADDR_OWVAR 39
104602: PUSH
104603: LD_VAR 0 2
104607: ST_TO_ADDR
// vc_control := control ;
104608: LD_ADDR_OWVAR 38
104612: PUSH
104613: LD_VAR 0 3
104617: ST_TO_ADDR
// vc_weapon := weapon ;
104618: LD_ADDR_OWVAR 40
104622: PUSH
104623: LD_VAR 0 4
104627: ST_TO_ADDR
// un := CreateVehicle ;
104628: LD_ADDR_VAR 0 8
104632: PUSH
104633: CALL_OW 45
104637: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104638: LD_VAR 0 8
104642: PPUSH
104643: LD_INT 0
104645: PPUSH
104646: LD_INT 5
104648: PPUSH
104649: CALL_OW 12
104653: PPUSH
104654: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104658: LD_VAR 0 8
104662: PPUSH
104663: LD_VAR 0 5
104667: PPUSH
104668: LD_VAR 0 6
104672: PPUSH
104673: LD_INT 1
104675: PPUSH
104676: CALL_OW 48
// end ;
104680: LD_VAR 0 7
104684: RET
// export hInvincible ; every 1 do
104685: GO 104687
104687: DISABLE
// hInvincible := [ ] ;
104688: LD_ADDR_EXP 153
104692: PUSH
104693: EMPTY
104694: ST_TO_ADDR
104695: END
// every 10 do var i ;
104696: GO 104698
104698: DISABLE
104699: LD_INT 0
104701: PPUSH
// begin enable ;
104702: ENABLE
// if not hInvincible then
104703: LD_EXP 153
104707: NOT
104708: IFFALSE 104712
// exit ;
104710: GO 104756
// for i in hInvincible do
104712: LD_ADDR_VAR 0 1
104716: PUSH
104717: LD_EXP 153
104721: PUSH
104722: FOR_IN
104723: IFFALSE 104754
// if GetLives ( i ) < 1000 then
104725: LD_VAR 0 1
104729: PPUSH
104730: CALL_OW 256
104734: PUSH
104735: LD_INT 1000
104737: LESS
104738: IFFALSE 104752
// SetLives ( i , 1000 ) ;
104740: LD_VAR 0 1
104744: PPUSH
104745: LD_INT 1000
104747: PPUSH
104748: CALL_OW 234
104752: GO 104722
104754: POP
104755: POP
// end ;
104756: PPOPN 1
104758: END
// export function hHackInvincible ; var i ; begin
104759: LD_INT 0
104761: PPUSH
104762: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104763: LD_ADDR_VAR 0 2
104767: PUSH
104768: LD_INT 2
104770: PUSH
104771: LD_INT 21
104773: PUSH
104774: LD_INT 1
104776: PUSH
104777: EMPTY
104778: LIST
104779: LIST
104780: PUSH
104781: LD_INT 21
104783: PUSH
104784: LD_INT 2
104786: PUSH
104787: EMPTY
104788: LIST
104789: LIST
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: LIST
104795: PPUSH
104796: CALL_OW 69
104800: PUSH
104801: FOR_IN
104802: IFFALSE 104863
// if IsSelected ( i ) then
104804: LD_VAR 0 2
104808: PPUSH
104809: CALL_OW 306
104813: IFFALSE 104861
// begin if i in hInvincible then
104815: LD_VAR 0 2
104819: PUSH
104820: LD_EXP 153
104824: IN
104825: IFFALSE 104845
// hInvincible := hInvincible diff i else
104827: LD_ADDR_EXP 153
104831: PUSH
104832: LD_EXP 153
104836: PUSH
104837: LD_VAR 0 2
104841: DIFF
104842: ST_TO_ADDR
104843: GO 104861
// hInvincible := hInvincible union i ;
104845: LD_ADDR_EXP 153
104849: PUSH
104850: LD_EXP 153
104854: PUSH
104855: LD_VAR 0 2
104859: UNION
104860: ST_TO_ADDR
// end ;
104861: GO 104801
104863: POP
104864: POP
// end ;
104865: LD_VAR 0 1
104869: RET
// export function hHackInvisible ; var i , j ; begin
104870: LD_INT 0
104872: PPUSH
104873: PPUSH
104874: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104875: LD_ADDR_VAR 0 2
104879: PUSH
104880: LD_INT 21
104882: PUSH
104883: LD_INT 1
104885: PUSH
104886: EMPTY
104887: LIST
104888: LIST
104889: PPUSH
104890: CALL_OW 69
104894: PUSH
104895: FOR_IN
104896: IFFALSE 104920
// if IsSelected ( i ) then
104898: LD_VAR 0 2
104902: PPUSH
104903: CALL_OW 306
104907: IFFALSE 104918
// ComForceInvisible ( i ) ;
104909: LD_VAR 0 2
104913: PPUSH
104914: CALL_OW 496
104918: GO 104895
104920: POP
104921: POP
// end ;
104922: LD_VAR 0 1
104926: RET
// export function hHackChangeYourSide ; begin
104927: LD_INT 0
104929: PPUSH
// if your_side = 8 then
104930: LD_OWVAR 2
104934: PUSH
104935: LD_INT 8
104937: EQUAL
104938: IFFALSE 104950
// your_side := 0 else
104940: LD_ADDR_OWVAR 2
104944: PUSH
104945: LD_INT 0
104947: ST_TO_ADDR
104948: GO 104964
// your_side := your_side + 1 ;
104950: LD_ADDR_OWVAR 2
104954: PUSH
104955: LD_OWVAR 2
104959: PUSH
104960: LD_INT 1
104962: PLUS
104963: ST_TO_ADDR
// end ;
104964: LD_VAR 0 1
104968: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104969: LD_INT 0
104971: PPUSH
104972: PPUSH
104973: PPUSH
// for i in all_units do
104974: LD_ADDR_VAR 0 2
104978: PUSH
104979: LD_OWVAR 3
104983: PUSH
104984: FOR_IN
104985: IFFALSE 105063
// if IsSelected ( i ) then
104987: LD_VAR 0 2
104991: PPUSH
104992: CALL_OW 306
104996: IFFALSE 105061
// begin j := GetSide ( i ) ;
104998: LD_ADDR_VAR 0 3
105002: PUSH
105003: LD_VAR 0 2
105007: PPUSH
105008: CALL_OW 255
105012: ST_TO_ADDR
// if j = 8 then
105013: LD_VAR 0 3
105017: PUSH
105018: LD_INT 8
105020: EQUAL
105021: IFFALSE 105033
// j := 0 else
105023: LD_ADDR_VAR 0 3
105027: PUSH
105028: LD_INT 0
105030: ST_TO_ADDR
105031: GO 105047
// j := j + 1 ;
105033: LD_ADDR_VAR 0 3
105037: PUSH
105038: LD_VAR 0 3
105042: PUSH
105043: LD_INT 1
105045: PLUS
105046: ST_TO_ADDR
// SetSide ( i , j ) ;
105047: LD_VAR 0 2
105051: PPUSH
105052: LD_VAR 0 3
105056: PPUSH
105057: CALL_OW 235
// end ;
105061: GO 104984
105063: POP
105064: POP
// end ;
105065: LD_VAR 0 1
105069: RET
// export function hHackFog ; begin
105070: LD_INT 0
105072: PPUSH
// FogOff ( true ) ;
105073: LD_INT 1
105075: PPUSH
105076: CALL_OW 344
// end ;
105080: LD_VAR 0 1
105084: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105085: LD_INT 0
105087: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105088: LD_VAR 0 1
105092: PPUSH
105093: LD_VAR 0 2
105097: PPUSH
105098: LD_VAR 0 3
105102: PPUSH
105103: LD_INT 1
105105: PPUSH
105106: LD_INT 1
105108: PPUSH
105109: CALL_OW 483
// CenterOnXY ( x , y ) ;
105113: LD_VAR 0 2
105117: PPUSH
105118: LD_VAR 0 3
105122: PPUSH
105123: CALL_OW 84
// end ;
105127: LD_VAR 0 4
105131: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105132: LD_INT 0
105134: PPUSH
105135: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105136: LD_VAR 0 1
105140: NOT
105141: PUSH
105142: LD_VAR 0 2
105146: PPUSH
105147: LD_VAR 0 3
105151: PPUSH
105152: CALL_OW 488
105156: NOT
105157: OR
105158: PUSH
105159: LD_VAR 0 1
105163: PPUSH
105164: CALL_OW 266
105168: PUSH
105169: LD_INT 3
105171: NONEQUAL
105172: PUSH
105173: LD_VAR 0 1
105177: PPUSH
105178: CALL_OW 247
105182: PUSH
105183: LD_INT 1
105185: EQUAL
105186: NOT
105187: AND
105188: OR
105189: IFFALSE 105193
// exit ;
105191: GO 105342
// if GetType ( factory ) = unit_human then
105193: LD_VAR 0 1
105197: PPUSH
105198: CALL_OW 247
105202: PUSH
105203: LD_INT 1
105205: EQUAL
105206: IFFALSE 105223
// factory := IsInUnit ( factory ) ;
105208: LD_ADDR_VAR 0 1
105212: PUSH
105213: LD_VAR 0 1
105217: PPUSH
105218: CALL_OW 310
105222: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105223: LD_VAR 0 1
105227: PPUSH
105228: CALL_OW 266
105232: PUSH
105233: LD_INT 3
105235: NONEQUAL
105236: IFFALSE 105240
// exit ;
105238: GO 105342
// if HexInfo ( x , y ) = factory then
105240: LD_VAR 0 2
105244: PPUSH
105245: LD_VAR 0 3
105249: PPUSH
105250: CALL_OW 428
105254: PUSH
105255: LD_VAR 0 1
105259: EQUAL
105260: IFFALSE 105287
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105262: LD_ADDR_EXP 154
105266: PUSH
105267: LD_EXP 154
105271: PPUSH
105272: LD_VAR 0 1
105276: PPUSH
105277: LD_INT 0
105279: PPUSH
105280: CALL_OW 1
105284: ST_TO_ADDR
105285: GO 105338
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105287: LD_ADDR_EXP 154
105291: PUSH
105292: LD_EXP 154
105296: PPUSH
105297: LD_VAR 0 1
105301: PPUSH
105302: LD_VAR 0 1
105306: PPUSH
105307: CALL_OW 255
105311: PUSH
105312: LD_VAR 0 1
105316: PUSH
105317: LD_VAR 0 2
105321: PUSH
105322: LD_VAR 0 3
105326: PUSH
105327: EMPTY
105328: LIST
105329: LIST
105330: LIST
105331: LIST
105332: PPUSH
105333: CALL_OW 1
105337: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105338: CALL 105347 0 0
// end ;
105342: LD_VAR 0 4
105346: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105347: LD_INT 0
105349: PPUSH
105350: PPUSH
105351: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105352: LD_STRING resetFactoryWaypoint();
105354: PPUSH
105355: CALL_OW 559
// if factoryWaypoints then
105359: LD_EXP 154
105363: IFFALSE 105489
// begin list := PrepareArray ( factoryWaypoints ) ;
105365: LD_ADDR_VAR 0 3
105369: PUSH
105370: LD_EXP 154
105374: PPUSH
105375: CALL 90184 0 1
105379: ST_TO_ADDR
// for i := 1 to list do
105380: LD_ADDR_VAR 0 2
105384: PUSH
105385: DOUBLE
105386: LD_INT 1
105388: DEC
105389: ST_TO_ADDR
105390: LD_VAR 0 3
105394: PUSH
105395: FOR_TO
105396: IFFALSE 105487
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105398: LD_STRING setFactoryWaypointXY(
105400: PUSH
105401: LD_VAR 0 3
105405: PUSH
105406: LD_VAR 0 2
105410: ARRAY
105411: PUSH
105412: LD_INT 1
105414: ARRAY
105415: STR
105416: PUSH
105417: LD_STRING ,
105419: STR
105420: PUSH
105421: LD_VAR 0 3
105425: PUSH
105426: LD_VAR 0 2
105430: ARRAY
105431: PUSH
105432: LD_INT 2
105434: ARRAY
105435: STR
105436: PUSH
105437: LD_STRING ,
105439: STR
105440: PUSH
105441: LD_VAR 0 3
105445: PUSH
105446: LD_VAR 0 2
105450: ARRAY
105451: PUSH
105452: LD_INT 3
105454: ARRAY
105455: STR
105456: PUSH
105457: LD_STRING ,
105459: STR
105460: PUSH
105461: LD_VAR 0 3
105465: PUSH
105466: LD_VAR 0 2
105470: ARRAY
105471: PUSH
105472: LD_INT 4
105474: ARRAY
105475: STR
105476: PUSH
105477: LD_STRING )
105479: STR
105480: PPUSH
105481: CALL_OW 559
105485: GO 105395
105487: POP
105488: POP
// end ; end ;
105489: LD_VAR 0 1
105493: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105494: LD_INT 0
105496: PPUSH
// if HexInfo ( x , y ) = warehouse then
105497: LD_VAR 0 2
105501: PPUSH
105502: LD_VAR 0 3
105506: PPUSH
105507: CALL_OW 428
105511: PUSH
105512: LD_VAR 0 1
105516: EQUAL
105517: IFFALSE 105544
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105519: LD_ADDR_EXP 155
105523: PUSH
105524: LD_EXP 155
105528: PPUSH
105529: LD_VAR 0 1
105533: PPUSH
105534: LD_INT 0
105536: PPUSH
105537: CALL_OW 1
105541: ST_TO_ADDR
105542: GO 105595
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105544: LD_ADDR_EXP 155
105548: PUSH
105549: LD_EXP 155
105553: PPUSH
105554: LD_VAR 0 1
105558: PPUSH
105559: LD_VAR 0 1
105563: PPUSH
105564: CALL_OW 255
105568: PUSH
105569: LD_VAR 0 1
105573: PUSH
105574: LD_VAR 0 2
105578: PUSH
105579: LD_VAR 0 3
105583: PUSH
105584: EMPTY
105585: LIST
105586: LIST
105587: LIST
105588: LIST
105589: PPUSH
105590: CALL_OW 1
105594: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105595: CALL 105604 0 0
// end ;
105599: LD_VAR 0 4
105603: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105604: LD_INT 0
105606: PPUSH
105607: PPUSH
105608: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105609: LD_STRING resetWarehouseGatheringPoints();
105611: PPUSH
105612: CALL_OW 559
// if warehouseGatheringPoints then
105616: LD_EXP 155
105620: IFFALSE 105746
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105622: LD_ADDR_VAR 0 3
105626: PUSH
105627: LD_EXP 155
105631: PPUSH
105632: CALL 90184 0 1
105636: ST_TO_ADDR
// for i := 1 to list do
105637: LD_ADDR_VAR 0 2
105641: PUSH
105642: DOUBLE
105643: LD_INT 1
105645: DEC
105646: ST_TO_ADDR
105647: LD_VAR 0 3
105651: PUSH
105652: FOR_TO
105653: IFFALSE 105744
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105655: LD_STRING setWarehouseGatheringPointXY(
105657: PUSH
105658: LD_VAR 0 3
105662: PUSH
105663: LD_VAR 0 2
105667: ARRAY
105668: PUSH
105669: LD_INT 1
105671: ARRAY
105672: STR
105673: PUSH
105674: LD_STRING ,
105676: STR
105677: PUSH
105678: LD_VAR 0 3
105682: PUSH
105683: LD_VAR 0 2
105687: ARRAY
105688: PUSH
105689: LD_INT 2
105691: ARRAY
105692: STR
105693: PUSH
105694: LD_STRING ,
105696: STR
105697: PUSH
105698: LD_VAR 0 3
105702: PUSH
105703: LD_VAR 0 2
105707: ARRAY
105708: PUSH
105709: LD_INT 3
105711: ARRAY
105712: STR
105713: PUSH
105714: LD_STRING ,
105716: STR
105717: PUSH
105718: LD_VAR 0 3
105722: PUSH
105723: LD_VAR 0 2
105727: ARRAY
105728: PUSH
105729: LD_INT 4
105731: ARRAY
105732: STR
105733: PUSH
105734: LD_STRING )
105736: STR
105737: PPUSH
105738: CALL_OW 559
105742: GO 105652
105744: POP
105745: POP
// end ; end ;
105746: LD_VAR 0 1
105750: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105751: LD_EXP 155
105755: IFFALSE 106440
105757: GO 105759
105759: DISABLE
105760: LD_INT 0
105762: PPUSH
105763: PPUSH
105764: PPUSH
105765: PPUSH
105766: PPUSH
105767: PPUSH
105768: PPUSH
105769: PPUSH
105770: PPUSH
// begin enable ;
105771: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105772: LD_ADDR_VAR 0 3
105776: PUSH
105777: LD_EXP 155
105781: PPUSH
105782: CALL 90184 0 1
105786: ST_TO_ADDR
// if not list then
105787: LD_VAR 0 3
105791: NOT
105792: IFFALSE 105796
// exit ;
105794: GO 106440
// for i := 1 to list do
105796: LD_ADDR_VAR 0 1
105800: PUSH
105801: DOUBLE
105802: LD_INT 1
105804: DEC
105805: ST_TO_ADDR
105806: LD_VAR 0 3
105810: PUSH
105811: FOR_TO
105812: IFFALSE 106438
// begin depot := list [ i ] [ 2 ] ;
105814: LD_ADDR_VAR 0 8
105818: PUSH
105819: LD_VAR 0 3
105823: PUSH
105824: LD_VAR 0 1
105828: ARRAY
105829: PUSH
105830: LD_INT 2
105832: ARRAY
105833: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105834: LD_ADDR_VAR 0 5
105838: PUSH
105839: LD_VAR 0 3
105843: PUSH
105844: LD_VAR 0 1
105848: ARRAY
105849: PUSH
105850: LD_INT 1
105852: ARRAY
105853: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105854: LD_VAR 0 8
105858: PPUSH
105859: CALL_OW 301
105863: PUSH
105864: LD_VAR 0 5
105868: PUSH
105869: LD_VAR 0 8
105873: PPUSH
105874: CALL_OW 255
105878: NONEQUAL
105879: OR
105880: IFFALSE 105909
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105882: LD_ADDR_EXP 155
105886: PUSH
105887: LD_EXP 155
105891: PPUSH
105892: LD_VAR 0 8
105896: PPUSH
105897: LD_INT 0
105899: PPUSH
105900: CALL_OW 1
105904: ST_TO_ADDR
// exit ;
105905: POP
105906: POP
105907: GO 106440
// end ; x := list [ i ] [ 3 ] ;
105909: LD_ADDR_VAR 0 6
105913: PUSH
105914: LD_VAR 0 3
105918: PUSH
105919: LD_VAR 0 1
105923: ARRAY
105924: PUSH
105925: LD_INT 3
105927: ARRAY
105928: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105929: LD_ADDR_VAR 0 7
105933: PUSH
105934: LD_VAR 0 3
105938: PUSH
105939: LD_VAR 0 1
105943: ARRAY
105944: PUSH
105945: LD_INT 4
105947: ARRAY
105948: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105949: LD_ADDR_VAR 0 9
105953: PUSH
105954: LD_VAR 0 6
105958: PPUSH
105959: LD_VAR 0 7
105963: PPUSH
105964: LD_INT 16
105966: PPUSH
105967: CALL 88772 0 3
105971: ST_TO_ADDR
// if not cratesNearbyPoint then
105972: LD_VAR 0 9
105976: NOT
105977: IFFALSE 105983
// exit ;
105979: POP
105980: POP
105981: GO 106440
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105983: LD_ADDR_VAR 0 4
105987: PUSH
105988: LD_INT 22
105990: PUSH
105991: LD_VAR 0 5
105995: PUSH
105996: EMPTY
105997: LIST
105998: LIST
105999: PUSH
106000: LD_INT 3
106002: PUSH
106003: LD_INT 60
106005: PUSH
106006: EMPTY
106007: LIST
106008: PUSH
106009: EMPTY
106010: LIST
106011: LIST
106012: PUSH
106013: LD_INT 91
106015: PUSH
106016: LD_VAR 0 8
106020: PUSH
106021: LD_INT 6
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: LIST
106028: PUSH
106029: LD_INT 2
106031: PUSH
106032: LD_INT 25
106034: PUSH
106035: LD_INT 2
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: PUSH
106042: LD_INT 25
106044: PUSH
106045: LD_INT 16
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: PUSH
106052: EMPTY
106053: LIST
106054: LIST
106055: LIST
106056: PUSH
106057: EMPTY
106058: LIST
106059: LIST
106060: LIST
106061: LIST
106062: PPUSH
106063: CALL_OW 69
106067: PUSH
106068: LD_VAR 0 8
106072: PPUSH
106073: CALL_OW 313
106077: PPUSH
106078: LD_INT 3
106080: PUSH
106081: LD_INT 60
106083: PUSH
106084: EMPTY
106085: LIST
106086: PUSH
106087: EMPTY
106088: LIST
106089: LIST
106090: PUSH
106091: LD_INT 2
106093: PUSH
106094: LD_INT 25
106096: PUSH
106097: LD_INT 2
106099: PUSH
106100: EMPTY
106101: LIST
106102: LIST
106103: PUSH
106104: LD_INT 25
106106: PUSH
106107: LD_INT 16
106109: PUSH
106110: EMPTY
106111: LIST
106112: LIST
106113: PUSH
106114: EMPTY
106115: LIST
106116: LIST
106117: LIST
106118: PUSH
106119: EMPTY
106120: LIST
106121: LIST
106122: PPUSH
106123: CALL_OW 72
106127: UNION
106128: ST_TO_ADDR
// if tmp then
106129: LD_VAR 0 4
106133: IFFALSE 106213
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106135: LD_ADDR_VAR 0 4
106139: PUSH
106140: LD_VAR 0 4
106144: PPUSH
106145: LD_INT 3
106147: PPUSH
106148: CALL 86741 0 2
106152: ST_TO_ADDR
// for j in tmp do
106153: LD_ADDR_VAR 0 2
106157: PUSH
106158: LD_VAR 0 4
106162: PUSH
106163: FOR_IN
106164: IFFALSE 106207
// begin if IsInUnit ( j ) then
106166: LD_VAR 0 2
106170: PPUSH
106171: CALL_OW 310
106175: IFFALSE 106186
// ComExit ( j ) ;
106177: LD_VAR 0 2
106181: PPUSH
106182: CALL 86824 0 1
// AddComCollect ( j , x , y ) ;
106186: LD_VAR 0 2
106190: PPUSH
106191: LD_VAR 0 6
106195: PPUSH
106196: LD_VAR 0 7
106200: PPUSH
106201: CALL_OW 177
// end ;
106205: GO 106163
106207: POP
106208: POP
// exit ;
106209: POP
106210: POP
106211: GO 106440
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106213: LD_ADDR_VAR 0 4
106217: PUSH
106218: LD_INT 22
106220: PUSH
106221: LD_VAR 0 5
106225: PUSH
106226: EMPTY
106227: LIST
106228: LIST
106229: PUSH
106230: LD_INT 91
106232: PUSH
106233: LD_VAR 0 8
106237: PUSH
106238: LD_INT 8
106240: PUSH
106241: EMPTY
106242: LIST
106243: LIST
106244: LIST
106245: PUSH
106246: LD_INT 2
106248: PUSH
106249: LD_INT 34
106251: PUSH
106252: LD_INT 12
106254: PUSH
106255: EMPTY
106256: LIST
106257: LIST
106258: PUSH
106259: LD_INT 34
106261: PUSH
106262: LD_INT 51
106264: PUSH
106265: EMPTY
106266: LIST
106267: LIST
106268: PUSH
106269: LD_INT 34
106271: PUSH
106272: LD_INT 32
106274: PUSH
106275: EMPTY
106276: LIST
106277: LIST
106278: PUSH
106279: LD_INT 34
106281: PUSH
106282: LD_INT 89
106284: PUSH
106285: EMPTY
106286: LIST
106287: LIST
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: LIST
106293: LIST
106294: LIST
106295: PUSH
106296: EMPTY
106297: LIST
106298: LIST
106299: LIST
106300: PPUSH
106301: CALL_OW 69
106305: ST_TO_ADDR
// if tmp then
106306: LD_VAR 0 4
106310: IFFALSE 106436
// begin for j in tmp do
106312: LD_ADDR_VAR 0 2
106316: PUSH
106317: LD_VAR 0 4
106321: PUSH
106322: FOR_IN
106323: IFFALSE 106434
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106325: LD_VAR 0 2
106329: PPUSH
106330: CALL_OW 262
106334: PUSH
106335: LD_INT 3
106337: EQUAL
106338: PUSH
106339: LD_VAR 0 2
106343: PPUSH
106344: CALL_OW 261
106348: PUSH
106349: LD_INT 20
106351: GREATER
106352: OR
106353: PUSH
106354: LD_VAR 0 2
106358: PPUSH
106359: CALL_OW 314
106363: NOT
106364: AND
106365: PUSH
106366: LD_VAR 0 2
106370: PPUSH
106371: CALL_OW 263
106375: PUSH
106376: LD_INT 1
106378: NONEQUAL
106379: PUSH
106380: LD_VAR 0 2
106384: PPUSH
106385: CALL_OW 311
106389: OR
106390: AND
106391: IFFALSE 106432
// begin ComCollect ( j , x , y ) ;
106393: LD_VAR 0 2
106397: PPUSH
106398: LD_VAR 0 6
106402: PPUSH
106403: LD_VAR 0 7
106407: PPUSH
106408: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106412: LD_VAR 0 2
106416: PPUSH
106417: LD_VAR 0 8
106421: PPUSH
106422: CALL_OW 172
// exit ;
106426: POP
106427: POP
106428: POP
106429: POP
106430: GO 106440
// end ;
106432: GO 106322
106434: POP
106435: POP
// end ; end ;
106436: GO 105811
106438: POP
106439: POP
// end ; end_of_file
106440: PPOPN 9
106442: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106443: LD_INT 0
106445: PPUSH
106446: PPUSH
106447: PPUSH
106448: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106449: LD_VAR 0 1
106453: PPUSH
106454: CALL_OW 264
106458: PUSH
106459: LD_INT 91
106461: EQUAL
106462: IFFALSE 106534
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106464: LD_INT 68
106466: PPUSH
106467: LD_VAR 0 1
106471: PPUSH
106472: CALL_OW 255
106476: PPUSH
106477: CALL_OW 321
106481: PUSH
106482: LD_INT 2
106484: EQUAL
106485: IFFALSE 106497
// eff := 70 else
106487: LD_ADDR_VAR 0 4
106491: PUSH
106492: LD_INT 70
106494: ST_TO_ADDR
106495: GO 106505
// eff := 30 ;
106497: LD_ADDR_VAR 0 4
106501: PUSH
106502: LD_INT 30
106504: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106505: LD_VAR 0 1
106509: PPUSH
106510: CALL_OW 250
106514: PPUSH
106515: LD_VAR 0 1
106519: PPUSH
106520: CALL_OW 251
106524: PPUSH
106525: LD_VAR 0 4
106529: PPUSH
106530: CALL_OW 495
// end ; end ;
106534: LD_VAR 0 2
106538: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106539: LD_INT 0
106541: PPUSH
// end ;
106542: LD_VAR 0 4
106546: RET
// export function SOS_Command ( cmd ) ; begin
106547: LD_INT 0
106549: PPUSH
// end ;
106550: LD_VAR 0 2
106554: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106555: LD_INT 0
106557: PPUSH
// end ;
106558: LD_VAR 0 6
106562: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106563: LD_INT 0
106565: PPUSH
106566: PPUSH
// if not vehicle or not factory then
106567: LD_VAR 0 1
106571: NOT
106572: PUSH
106573: LD_VAR 0 2
106577: NOT
106578: OR
106579: IFFALSE 106583
// exit ;
106581: GO 106814
// if factoryWaypoints >= factory then
106583: LD_EXP 154
106587: PUSH
106588: LD_VAR 0 2
106592: GREATEREQUAL
106593: IFFALSE 106814
// if factoryWaypoints [ factory ] then
106595: LD_EXP 154
106599: PUSH
106600: LD_VAR 0 2
106604: ARRAY
106605: IFFALSE 106814
// begin if GetControl ( vehicle ) = control_manual then
106607: LD_VAR 0 1
106611: PPUSH
106612: CALL_OW 263
106616: PUSH
106617: LD_INT 1
106619: EQUAL
106620: IFFALSE 106701
// begin driver := IsDrivenBy ( vehicle ) ;
106622: LD_ADDR_VAR 0 4
106626: PUSH
106627: LD_VAR 0 1
106631: PPUSH
106632: CALL_OW 311
106636: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106637: LD_VAR 0 4
106641: PPUSH
106642: LD_EXP 154
106646: PUSH
106647: LD_VAR 0 2
106651: ARRAY
106652: PUSH
106653: LD_INT 3
106655: ARRAY
106656: PPUSH
106657: LD_EXP 154
106661: PUSH
106662: LD_VAR 0 2
106666: ARRAY
106667: PUSH
106668: LD_INT 4
106670: ARRAY
106671: PPUSH
106672: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106676: LD_VAR 0 4
106680: PPUSH
106681: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106685: LD_VAR 0 4
106689: PPUSH
106690: LD_VAR 0 2
106694: PPUSH
106695: CALL_OW 180
// end else
106699: GO 106814
// if GetControl ( vehicle ) = control_remote then
106701: LD_VAR 0 1
106705: PPUSH
106706: CALL_OW 263
106710: PUSH
106711: LD_INT 2
106713: EQUAL
106714: IFFALSE 106775
// begin wait ( 0 0$2 ) ;
106716: LD_INT 70
106718: PPUSH
106719: CALL_OW 67
// if Connect ( vehicle ) then
106723: LD_VAR 0 1
106727: PPUSH
106728: CALL 57045 0 1
106732: IFFALSE 106773
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106734: LD_VAR 0 1
106738: PPUSH
106739: LD_EXP 154
106743: PUSH
106744: LD_VAR 0 2
106748: ARRAY
106749: PUSH
106750: LD_INT 3
106752: ARRAY
106753: PPUSH
106754: LD_EXP 154
106758: PUSH
106759: LD_VAR 0 2
106763: ARRAY
106764: PUSH
106765: LD_INT 4
106767: ARRAY
106768: PPUSH
106769: CALL_OW 171
// end else
106773: GO 106814
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106775: LD_VAR 0 1
106779: PPUSH
106780: LD_EXP 154
106784: PUSH
106785: LD_VAR 0 2
106789: ARRAY
106790: PUSH
106791: LD_INT 3
106793: ARRAY
106794: PPUSH
106795: LD_EXP 154
106799: PUSH
106800: LD_VAR 0 2
106804: ARRAY
106805: PUSH
106806: LD_INT 4
106808: ARRAY
106809: PPUSH
106810: CALL_OW 171
// end ; end ;
106814: LD_VAR 0 3
106818: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106819: LD_INT 0
106821: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106822: LD_VAR 0 1
106826: PUSH
106827: LD_INT 250
106829: EQUAL
106830: PUSH
106831: LD_VAR 0 2
106835: PPUSH
106836: CALL_OW 264
106840: PUSH
106841: LD_INT 81
106843: EQUAL
106844: AND
106845: IFFALSE 106866
// MinerPlaceMine ( unit , x , y ) ;
106847: LD_VAR 0 2
106851: PPUSH
106852: LD_VAR 0 4
106856: PPUSH
106857: LD_VAR 0 5
106861: PPUSH
106862: CALL 109251 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106866: LD_VAR 0 1
106870: PUSH
106871: LD_INT 251
106873: EQUAL
106874: PUSH
106875: LD_VAR 0 2
106879: PPUSH
106880: CALL_OW 264
106884: PUSH
106885: LD_INT 81
106887: EQUAL
106888: AND
106889: IFFALSE 106910
// MinerDetonateMine ( unit , x , y ) ;
106891: LD_VAR 0 2
106895: PPUSH
106896: LD_VAR 0 4
106900: PPUSH
106901: LD_VAR 0 5
106905: PPUSH
106906: CALL 109526 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106910: LD_VAR 0 1
106914: PUSH
106915: LD_INT 252
106917: EQUAL
106918: PUSH
106919: LD_VAR 0 2
106923: PPUSH
106924: CALL_OW 264
106928: PUSH
106929: LD_INT 81
106931: EQUAL
106932: AND
106933: IFFALSE 106954
// MinerCreateMinefield ( unit , x , y ) ;
106935: LD_VAR 0 2
106939: PPUSH
106940: LD_VAR 0 4
106944: PPUSH
106945: LD_VAR 0 5
106949: PPUSH
106950: CALL 109943 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106954: LD_VAR 0 1
106958: PUSH
106959: LD_INT 253
106961: EQUAL
106962: PUSH
106963: LD_VAR 0 2
106967: PPUSH
106968: CALL_OW 257
106972: PUSH
106973: LD_INT 5
106975: EQUAL
106976: AND
106977: IFFALSE 106998
// ComBinocular ( unit , x , y ) ;
106979: LD_VAR 0 2
106983: PPUSH
106984: LD_VAR 0 4
106988: PPUSH
106989: LD_VAR 0 5
106993: PPUSH
106994: CALL 110312 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106998: LD_VAR 0 1
107002: PUSH
107003: LD_INT 254
107005: EQUAL
107006: PUSH
107007: LD_VAR 0 2
107011: PPUSH
107012: CALL_OW 264
107016: PUSH
107017: LD_INT 99
107019: EQUAL
107020: AND
107021: PUSH
107022: LD_VAR 0 3
107026: PPUSH
107027: CALL_OW 263
107031: PUSH
107032: LD_INT 3
107034: EQUAL
107035: AND
107036: IFFALSE 107052
// HackDestroyVehicle ( unit , selectedUnit ) ;
107038: LD_VAR 0 2
107042: PPUSH
107043: LD_VAR 0 3
107047: PPUSH
107048: CALL 108615 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107052: LD_VAR 0 1
107056: PUSH
107057: LD_INT 255
107059: EQUAL
107060: PUSH
107061: LD_VAR 0 2
107065: PPUSH
107066: CALL_OW 264
107070: PUSH
107071: LD_INT 14
107073: PUSH
107074: LD_INT 53
107076: PUSH
107077: EMPTY
107078: LIST
107079: LIST
107080: IN
107081: AND
107082: PUSH
107083: LD_VAR 0 4
107087: PPUSH
107088: LD_VAR 0 5
107092: PPUSH
107093: CALL_OW 488
107097: AND
107098: IFFALSE 107122
// CutTreeXYR ( unit , x , y , 12 ) ;
107100: LD_VAR 0 2
107104: PPUSH
107105: LD_VAR 0 4
107109: PPUSH
107110: LD_VAR 0 5
107114: PPUSH
107115: LD_INT 12
107117: PPUSH
107118: CALL 107185 0 4
// if cmd = 256 then
107122: LD_VAR 0 1
107126: PUSH
107127: LD_INT 256
107129: EQUAL
107130: IFFALSE 107151
// SetFactoryWaypoint ( unit , x , y ) ;
107132: LD_VAR 0 2
107136: PPUSH
107137: LD_VAR 0 4
107141: PPUSH
107142: LD_VAR 0 5
107146: PPUSH
107147: CALL 105132 0 3
// if cmd = 257 then
107151: LD_VAR 0 1
107155: PUSH
107156: LD_INT 257
107158: EQUAL
107159: IFFALSE 107180
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107161: LD_VAR 0 2
107165: PPUSH
107166: LD_VAR 0 4
107170: PPUSH
107171: LD_VAR 0 5
107175: PPUSH
107176: CALL 105494 0 3
// end ;
107180: LD_VAR 0 6
107184: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107185: LD_INT 0
107187: PPUSH
107188: PPUSH
107189: PPUSH
107190: PPUSH
107191: PPUSH
107192: PPUSH
107193: PPUSH
107194: PPUSH
107195: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107196: LD_VAR 0 1
107200: NOT
107201: PUSH
107202: LD_VAR 0 2
107206: PPUSH
107207: LD_VAR 0 3
107211: PPUSH
107212: CALL_OW 488
107216: NOT
107217: OR
107218: PUSH
107219: LD_VAR 0 4
107223: NOT
107224: OR
107225: IFFALSE 107229
// exit ;
107227: GO 107569
// list := [ ] ;
107229: LD_ADDR_VAR 0 13
107233: PUSH
107234: EMPTY
107235: ST_TO_ADDR
// if x - r < 0 then
107236: LD_VAR 0 2
107240: PUSH
107241: LD_VAR 0 4
107245: MINUS
107246: PUSH
107247: LD_INT 0
107249: LESS
107250: IFFALSE 107262
// min_x := 0 else
107252: LD_ADDR_VAR 0 7
107256: PUSH
107257: LD_INT 0
107259: ST_TO_ADDR
107260: GO 107278
// min_x := x - r ;
107262: LD_ADDR_VAR 0 7
107266: PUSH
107267: LD_VAR 0 2
107271: PUSH
107272: LD_VAR 0 4
107276: MINUS
107277: ST_TO_ADDR
// if y - r < 0 then
107278: LD_VAR 0 3
107282: PUSH
107283: LD_VAR 0 4
107287: MINUS
107288: PUSH
107289: LD_INT 0
107291: LESS
107292: IFFALSE 107304
// min_y := 0 else
107294: LD_ADDR_VAR 0 8
107298: PUSH
107299: LD_INT 0
107301: ST_TO_ADDR
107302: GO 107320
// min_y := y - r ;
107304: LD_ADDR_VAR 0 8
107308: PUSH
107309: LD_VAR 0 3
107313: PUSH
107314: LD_VAR 0 4
107318: MINUS
107319: ST_TO_ADDR
// max_x := x + r ;
107320: LD_ADDR_VAR 0 9
107324: PUSH
107325: LD_VAR 0 2
107329: PUSH
107330: LD_VAR 0 4
107334: PLUS
107335: ST_TO_ADDR
// max_y := y + r ;
107336: LD_ADDR_VAR 0 10
107340: PUSH
107341: LD_VAR 0 3
107345: PUSH
107346: LD_VAR 0 4
107350: PLUS
107351: ST_TO_ADDR
// for _x = min_x to max_x do
107352: LD_ADDR_VAR 0 11
107356: PUSH
107357: DOUBLE
107358: LD_VAR 0 7
107362: DEC
107363: ST_TO_ADDR
107364: LD_VAR 0 9
107368: PUSH
107369: FOR_TO
107370: IFFALSE 107487
// for _y = min_y to max_y do
107372: LD_ADDR_VAR 0 12
107376: PUSH
107377: DOUBLE
107378: LD_VAR 0 8
107382: DEC
107383: ST_TO_ADDR
107384: LD_VAR 0 10
107388: PUSH
107389: FOR_TO
107390: IFFALSE 107483
// begin if not ValidHex ( _x , _y ) then
107392: LD_VAR 0 11
107396: PPUSH
107397: LD_VAR 0 12
107401: PPUSH
107402: CALL_OW 488
107406: NOT
107407: IFFALSE 107411
// continue ;
107409: GO 107389
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107411: LD_VAR 0 11
107415: PPUSH
107416: LD_VAR 0 12
107420: PPUSH
107421: CALL_OW 351
107425: PUSH
107426: LD_VAR 0 11
107430: PPUSH
107431: LD_VAR 0 12
107435: PPUSH
107436: CALL_OW 554
107440: AND
107441: IFFALSE 107481
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107443: LD_ADDR_VAR 0 13
107447: PUSH
107448: LD_VAR 0 13
107452: PPUSH
107453: LD_VAR 0 13
107457: PUSH
107458: LD_INT 1
107460: PLUS
107461: PPUSH
107462: LD_VAR 0 11
107466: PUSH
107467: LD_VAR 0 12
107471: PUSH
107472: EMPTY
107473: LIST
107474: LIST
107475: PPUSH
107476: CALL_OW 2
107480: ST_TO_ADDR
// end ;
107481: GO 107389
107483: POP
107484: POP
107485: GO 107369
107487: POP
107488: POP
// if not list then
107489: LD_VAR 0 13
107493: NOT
107494: IFFALSE 107498
// exit ;
107496: GO 107569
// for i in list do
107498: LD_ADDR_VAR 0 6
107502: PUSH
107503: LD_VAR 0 13
107507: PUSH
107508: FOR_IN
107509: IFFALSE 107567
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107511: LD_VAR 0 1
107515: PPUSH
107516: LD_STRING M
107518: PUSH
107519: LD_VAR 0 6
107523: PUSH
107524: LD_INT 1
107526: ARRAY
107527: PUSH
107528: LD_VAR 0 6
107532: PUSH
107533: LD_INT 2
107535: ARRAY
107536: PUSH
107537: LD_INT 0
107539: PUSH
107540: LD_INT 0
107542: PUSH
107543: LD_INT 0
107545: PUSH
107546: LD_INT 0
107548: PUSH
107549: EMPTY
107550: LIST
107551: LIST
107552: LIST
107553: LIST
107554: LIST
107555: LIST
107556: LIST
107557: PUSH
107558: EMPTY
107559: LIST
107560: PPUSH
107561: CALL_OW 447
107565: GO 107508
107567: POP
107568: POP
// end ;
107569: LD_VAR 0 5
107573: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107574: LD_EXP 157
107578: NOT
107579: IFFALSE 107629
107581: GO 107583
107583: DISABLE
// begin initHack := true ;
107584: LD_ADDR_EXP 157
107588: PUSH
107589: LD_INT 1
107591: ST_TO_ADDR
// hackTanks := [ ] ;
107592: LD_ADDR_EXP 158
107596: PUSH
107597: EMPTY
107598: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107599: LD_ADDR_EXP 159
107603: PUSH
107604: EMPTY
107605: ST_TO_ADDR
// hackLimit := 3 ;
107606: LD_ADDR_EXP 160
107610: PUSH
107611: LD_INT 3
107613: ST_TO_ADDR
// hackDist := 12 ;
107614: LD_ADDR_EXP 161
107618: PUSH
107619: LD_INT 12
107621: ST_TO_ADDR
// hackCounter := [ ] ;
107622: LD_ADDR_EXP 162
107626: PUSH
107627: EMPTY
107628: ST_TO_ADDR
// end ;
107629: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107630: LD_EXP 157
107634: PUSH
107635: LD_INT 34
107637: PUSH
107638: LD_INT 99
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: PPUSH
107645: CALL_OW 69
107649: AND
107650: IFFALSE 107903
107652: GO 107654
107654: DISABLE
107655: LD_INT 0
107657: PPUSH
107658: PPUSH
// begin enable ;
107659: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107660: LD_ADDR_VAR 0 1
107664: PUSH
107665: LD_INT 34
107667: PUSH
107668: LD_INT 99
107670: PUSH
107671: EMPTY
107672: LIST
107673: LIST
107674: PPUSH
107675: CALL_OW 69
107679: PUSH
107680: FOR_IN
107681: IFFALSE 107901
// begin if not i in hackTanks then
107683: LD_VAR 0 1
107687: PUSH
107688: LD_EXP 158
107692: IN
107693: NOT
107694: IFFALSE 107777
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107696: LD_ADDR_EXP 158
107700: PUSH
107701: LD_EXP 158
107705: PPUSH
107706: LD_EXP 158
107710: PUSH
107711: LD_INT 1
107713: PLUS
107714: PPUSH
107715: LD_VAR 0 1
107719: PPUSH
107720: CALL_OW 1
107724: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107725: LD_ADDR_EXP 159
107729: PUSH
107730: LD_EXP 159
107734: PPUSH
107735: LD_EXP 159
107739: PUSH
107740: LD_INT 1
107742: PLUS
107743: PPUSH
107744: EMPTY
107745: PPUSH
107746: CALL_OW 1
107750: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107751: LD_ADDR_EXP 162
107755: PUSH
107756: LD_EXP 162
107760: PPUSH
107761: LD_EXP 162
107765: PUSH
107766: LD_INT 1
107768: PLUS
107769: PPUSH
107770: EMPTY
107771: PPUSH
107772: CALL_OW 1
107776: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107777: LD_VAR 0 1
107781: PPUSH
107782: CALL_OW 302
107786: NOT
107787: IFFALSE 107800
// begin HackUnlinkAll ( i ) ;
107789: LD_VAR 0 1
107793: PPUSH
107794: CALL 107906 0 1
// continue ;
107798: GO 107680
// end ; HackCheckCapturedStatus ( i ) ;
107800: LD_VAR 0 1
107804: PPUSH
107805: CALL 108349 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107809: LD_ADDR_VAR 0 2
107813: PUSH
107814: LD_INT 81
107816: PUSH
107817: LD_VAR 0 1
107821: PPUSH
107822: CALL_OW 255
107826: PUSH
107827: EMPTY
107828: LIST
107829: LIST
107830: PUSH
107831: LD_INT 33
107833: PUSH
107834: LD_INT 3
107836: PUSH
107837: EMPTY
107838: LIST
107839: LIST
107840: PUSH
107841: LD_INT 91
107843: PUSH
107844: LD_VAR 0 1
107848: PUSH
107849: LD_EXP 161
107853: PUSH
107854: EMPTY
107855: LIST
107856: LIST
107857: LIST
107858: PUSH
107859: LD_INT 50
107861: PUSH
107862: EMPTY
107863: LIST
107864: PUSH
107865: EMPTY
107866: LIST
107867: LIST
107868: LIST
107869: LIST
107870: PPUSH
107871: CALL_OW 69
107875: ST_TO_ADDR
// if not tmp then
107876: LD_VAR 0 2
107880: NOT
107881: IFFALSE 107885
// continue ;
107883: GO 107680
// HackLink ( i , tmp ) ;
107885: LD_VAR 0 1
107889: PPUSH
107890: LD_VAR 0 2
107894: PPUSH
107895: CALL 108042 0 2
// end ;
107899: GO 107680
107901: POP
107902: POP
// end ;
107903: PPOPN 2
107905: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107906: LD_INT 0
107908: PPUSH
107909: PPUSH
107910: PPUSH
// if not hack in hackTanks then
107911: LD_VAR 0 1
107915: PUSH
107916: LD_EXP 158
107920: IN
107921: NOT
107922: IFFALSE 107926
// exit ;
107924: GO 108037
// index := GetElementIndex ( hackTanks , hack ) ;
107926: LD_ADDR_VAR 0 4
107930: PUSH
107931: LD_EXP 158
107935: PPUSH
107936: LD_VAR 0 1
107940: PPUSH
107941: CALL 53852 0 2
107945: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107946: LD_EXP 159
107950: PUSH
107951: LD_VAR 0 4
107955: ARRAY
107956: IFFALSE 108037
// begin for i in hackTanksCaptured [ index ] do
107958: LD_ADDR_VAR 0 3
107962: PUSH
107963: LD_EXP 159
107967: PUSH
107968: LD_VAR 0 4
107972: ARRAY
107973: PUSH
107974: FOR_IN
107975: IFFALSE 108001
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107977: LD_VAR 0 3
107981: PUSH
107982: LD_INT 1
107984: ARRAY
107985: PPUSH
107986: LD_VAR 0 3
107990: PUSH
107991: LD_INT 2
107993: ARRAY
107994: PPUSH
107995: CALL_OW 235
107999: GO 107974
108001: POP
108002: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108003: LD_ADDR_EXP 159
108007: PUSH
108008: LD_EXP 159
108012: PPUSH
108013: LD_VAR 0 4
108017: PPUSH
108018: EMPTY
108019: PPUSH
108020: CALL_OW 1
108024: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108025: LD_VAR 0 1
108029: PPUSH
108030: LD_INT 0
108032: PPUSH
108033: CALL_OW 505
// end ; end ;
108037: LD_VAR 0 2
108041: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108042: LD_INT 0
108044: PPUSH
108045: PPUSH
108046: PPUSH
// if not hack in hackTanks or not vehicles then
108047: LD_VAR 0 1
108051: PUSH
108052: LD_EXP 158
108056: IN
108057: NOT
108058: PUSH
108059: LD_VAR 0 2
108063: NOT
108064: OR
108065: IFFALSE 108069
// exit ;
108067: GO 108344
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108069: LD_ADDR_VAR 0 2
108073: PUSH
108074: LD_VAR 0 1
108078: PPUSH
108079: LD_VAR 0 2
108083: PPUSH
108084: LD_INT 1
108086: PPUSH
108087: LD_INT 1
108089: PPUSH
108090: CALL 54502 0 4
108094: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108095: LD_ADDR_VAR 0 5
108099: PUSH
108100: LD_EXP 158
108104: PPUSH
108105: LD_VAR 0 1
108109: PPUSH
108110: CALL 53852 0 2
108114: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108115: LD_EXP 159
108119: PUSH
108120: LD_VAR 0 5
108124: ARRAY
108125: PUSH
108126: LD_EXP 160
108130: LESS
108131: IFFALSE 108320
// begin for i := 1 to vehicles do
108133: LD_ADDR_VAR 0 4
108137: PUSH
108138: DOUBLE
108139: LD_INT 1
108141: DEC
108142: ST_TO_ADDR
108143: LD_VAR 0 2
108147: PUSH
108148: FOR_TO
108149: IFFALSE 108318
// begin if hackTanksCaptured [ index ] = hackLimit then
108151: LD_EXP 159
108155: PUSH
108156: LD_VAR 0 5
108160: ARRAY
108161: PUSH
108162: LD_EXP 160
108166: EQUAL
108167: IFFALSE 108171
// break ;
108169: GO 108318
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108171: LD_ADDR_EXP 162
108175: PUSH
108176: LD_EXP 162
108180: PPUSH
108181: LD_VAR 0 5
108185: PPUSH
108186: LD_EXP 162
108190: PUSH
108191: LD_VAR 0 5
108195: ARRAY
108196: PUSH
108197: LD_INT 1
108199: PLUS
108200: PPUSH
108201: CALL_OW 1
108205: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108206: LD_ADDR_EXP 159
108210: PUSH
108211: LD_EXP 159
108215: PPUSH
108216: LD_VAR 0 5
108220: PUSH
108221: LD_EXP 159
108225: PUSH
108226: LD_VAR 0 5
108230: ARRAY
108231: PUSH
108232: LD_INT 1
108234: PLUS
108235: PUSH
108236: EMPTY
108237: LIST
108238: LIST
108239: PPUSH
108240: LD_VAR 0 2
108244: PUSH
108245: LD_VAR 0 4
108249: ARRAY
108250: PUSH
108251: LD_VAR 0 2
108255: PUSH
108256: LD_VAR 0 4
108260: ARRAY
108261: PPUSH
108262: CALL_OW 255
108266: PUSH
108267: EMPTY
108268: LIST
108269: LIST
108270: PPUSH
108271: CALL 54067 0 3
108275: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108276: LD_VAR 0 2
108280: PUSH
108281: LD_VAR 0 4
108285: ARRAY
108286: PPUSH
108287: LD_VAR 0 1
108291: PPUSH
108292: CALL_OW 255
108296: PPUSH
108297: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108301: LD_VAR 0 2
108305: PUSH
108306: LD_VAR 0 4
108310: ARRAY
108311: PPUSH
108312: CALL_OW 141
// end ;
108316: GO 108148
108318: POP
108319: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108320: LD_VAR 0 1
108324: PPUSH
108325: LD_EXP 159
108329: PUSH
108330: LD_VAR 0 5
108334: ARRAY
108335: PUSH
108336: LD_INT 0
108338: PLUS
108339: PPUSH
108340: CALL_OW 505
// end ;
108344: LD_VAR 0 3
108348: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108349: LD_INT 0
108351: PPUSH
108352: PPUSH
108353: PPUSH
108354: PPUSH
// if not hack in hackTanks then
108355: LD_VAR 0 1
108359: PUSH
108360: LD_EXP 158
108364: IN
108365: NOT
108366: IFFALSE 108370
// exit ;
108368: GO 108610
// index := GetElementIndex ( hackTanks , hack ) ;
108370: LD_ADDR_VAR 0 4
108374: PUSH
108375: LD_EXP 158
108379: PPUSH
108380: LD_VAR 0 1
108384: PPUSH
108385: CALL 53852 0 2
108389: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108390: LD_ADDR_VAR 0 3
108394: PUSH
108395: DOUBLE
108396: LD_EXP 159
108400: PUSH
108401: LD_VAR 0 4
108405: ARRAY
108406: INC
108407: ST_TO_ADDR
108408: LD_INT 1
108410: PUSH
108411: FOR_DOWNTO
108412: IFFALSE 108584
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108414: LD_ADDR_VAR 0 5
108418: PUSH
108419: LD_EXP 159
108423: PUSH
108424: LD_VAR 0 4
108428: ARRAY
108429: PUSH
108430: LD_VAR 0 3
108434: ARRAY
108435: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108436: LD_VAR 0 5
108440: PUSH
108441: LD_INT 1
108443: ARRAY
108444: PPUSH
108445: CALL_OW 302
108449: NOT
108450: PUSH
108451: LD_VAR 0 5
108455: PUSH
108456: LD_INT 1
108458: ARRAY
108459: PPUSH
108460: CALL_OW 255
108464: PUSH
108465: LD_VAR 0 1
108469: PPUSH
108470: CALL_OW 255
108474: NONEQUAL
108475: OR
108476: IFFALSE 108582
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108478: LD_VAR 0 5
108482: PUSH
108483: LD_INT 1
108485: ARRAY
108486: PPUSH
108487: CALL_OW 305
108491: PUSH
108492: LD_VAR 0 5
108496: PUSH
108497: LD_INT 1
108499: ARRAY
108500: PPUSH
108501: CALL_OW 255
108505: PUSH
108506: LD_VAR 0 1
108510: PPUSH
108511: CALL_OW 255
108515: EQUAL
108516: AND
108517: IFFALSE 108541
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108519: LD_VAR 0 5
108523: PUSH
108524: LD_INT 1
108526: ARRAY
108527: PPUSH
108528: LD_VAR 0 5
108532: PUSH
108533: LD_INT 2
108535: ARRAY
108536: PPUSH
108537: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108541: LD_ADDR_EXP 159
108545: PUSH
108546: LD_EXP 159
108550: PPUSH
108551: LD_VAR 0 4
108555: PPUSH
108556: LD_EXP 159
108560: PUSH
108561: LD_VAR 0 4
108565: ARRAY
108566: PPUSH
108567: LD_VAR 0 3
108571: PPUSH
108572: CALL_OW 3
108576: PPUSH
108577: CALL_OW 1
108581: ST_TO_ADDR
// end ; end ;
108582: GO 108411
108584: POP
108585: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108586: LD_VAR 0 1
108590: PPUSH
108591: LD_EXP 159
108595: PUSH
108596: LD_VAR 0 4
108600: ARRAY
108601: PUSH
108602: LD_INT 0
108604: PLUS
108605: PPUSH
108606: CALL_OW 505
// end ;
108610: LD_VAR 0 2
108614: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108615: LD_INT 0
108617: PPUSH
108618: PPUSH
108619: PPUSH
108620: PPUSH
// if not hack in hackTanks then
108621: LD_VAR 0 1
108625: PUSH
108626: LD_EXP 158
108630: IN
108631: NOT
108632: IFFALSE 108636
// exit ;
108634: GO 108721
// index := GetElementIndex ( hackTanks , hack ) ;
108636: LD_ADDR_VAR 0 5
108640: PUSH
108641: LD_EXP 158
108645: PPUSH
108646: LD_VAR 0 1
108650: PPUSH
108651: CALL 53852 0 2
108655: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108656: LD_ADDR_VAR 0 4
108660: PUSH
108661: DOUBLE
108662: LD_INT 1
108664: DEC
108665: ST_TO_ADDR
108666: LD_EXP 159
108670: PUSH
108671: LD_VAR 0 5
108675: ARRAY
108676: PUSH
108677: FOR_TO
108678: IFFALSE 108719
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108680: LD_EXP 159
108684: PUSH
108685: LD_VAR 0 5
108689: ARRAY
108690: PUSH
108691: LD_VAR 0 4
108695: ARRAY
108696: PUSH
108697: LD_INT 1
108699: ARRAY
108700: PUSH
108701: LD_VAR 0 2
108705: EQUAL
108706: IFFALSE 108717
// KillUnit ( vehicle ) ;
108708: LD_VAR 0 2
108712: PPUSH
108713: CALL_OW 66
108717: GO 108677
108719: POP
108720: POP
// end ;
108721: LD_VAR 0 3
108725: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108726: LD_EXP 163
108730: NOT
108731: IFFALSE 108766
108733: GO 108735
108735: DISABLE
// begin initMiner := true ;
108736: LD_ADDR_EXP 163
108740: PUSH
108741: LD_INT 1
108743: ST_TO_ADDR
// minersList := [ ] ;
108744: LD_ADDR_EXP 164
108748: PUSH
108749: EMPTY
108750: ST_TO_ADDR
// minerMinesList := [ ] ;
108751: LD_ADDR_EXP 165
108755: PUSH
108756: EMPTY
108757: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108758: LD_ADDR_EXP 166
108762: PUSH
108763: LD_INT 5
108765: ST_TO_ADDR
// end ;
108766: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108767: LD_EXP 163
108771: PUSH
108772: LD_INT 34
108774: PUSH
108775: LD_INT 81
108777: PUSH
108778: EMPTY
108779: LIST
108780: LIST
108781: PPUSH
108782: CALL_OW 69
108786: AND
108787: IFFALSE 109248
108789: GO 108791
108791: DISABLE
108792: LD_INT 0
108794: PPUSH
108795: PPUSH
108796: PPUSH
108797: PPUSH
// begin enable ;
108798: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108799: LD_ADDR_VAR 0 1
108803: PUSH
108804: LD_INT 34
108806: PUSH
108807: LD_INT 81
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: PPUSH
108814: CALL_OW 69
108818: PUSH
108819: FOR_IN
108820: IFFALSE 108892
// begin if not i in minersList then
108822: LD_VAR 0 1
108826: PUSH
108827: LD_EXP 164
108831: IN
108832: NOT
108833: IFFALSE 108890
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108835: LD_ADDR_EXP 164
108839: PUSH
108840: LD_EXP 164
108844: PPUSH
108845: LD_EXP 164
108849: PUSH
108850: LD_INT 1
108852: PLUS
108853: PPUSH
108854: LD_VAR 0 1
108858: PPUSH
108859: CALL_OW 1
108863: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108864: LD_ADDR_EXP 165
108868: PUSH
108869: LD_EXP 165
108873: PPUSH
108874: LD_EXP 165
108878: PUSH
108879: LD_INT 1
108881: PLUS
108882: PPUSH
108883: EMPTY
108884: PPUSH
108885: CALL_OW 1
108889: ST_TO_ADDR
// end end ;
108890: GO 108819
108892: POP
108893: POP
// for i := minerMinesList downto 1 do
108894: LD_ADDR_VAR 0 1
108898: PUSH
108899: DOUBLE
108900: LD_EXP 165
108904: INC
108905: ST_TO_ADDR
108906: LD_INT 1
108908: PUSH
108909: FOR_DOWNTO
108910: IFFALSE 109246
// begin if IsLive ( minersList [ i ] ) then
108912: LD_EXP 164
108916: PUSH
108917: LD_VAR 0 1
108921: ARRAY
108922: PPUSH
108923: CALL_OW 300
108927: IFFALSE 108955
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108929: LD_EXP 164
108933: PUSH
108934: LD_VAR 0 1
108938: ARRAY
108939: PPUSH
108940: LD_EXP 165
108944: PUSH
108945: LD_VAR 0 1
108949: ARRAY
108950: PPUSH
108951: CALL_OW 505
// if not minerMinesList [ i ] then
108955: LD_EXP 165
108959: PUSH
108960: LD_VAR 0 1
108964: ARRAY
108965: NOT
108966: IFFALSE 108970
// continue ;
108968: GO 108909
// for j := minerMinesList [ i ] downto 1 do
108970: LD_ADDR_VAR 0 2
108974: PUSH
108975: DOUBLE
108976: LD_EXP 165
108980: PUSH
108981: LD_VAR 0 1
108985: ARRAY
108986: INC
108987: ST_TO_ADDR
108988: LD_INT 1
108990: PUSH
108991: FOR_DOWNTO
108992: IFFALSE 109242
// begin side := GetSide ( minersList [ i ] ) ;
108994: LD_ADDR_VAR 0 3
108998: PUSH
108999: LD_EXP 164
109003: PUSH
109004: LD_VAR 0 1
109008: ARRAY
109009: PPUSH
109010: CALL_OW 255
109014: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109015: LD_ADDR_VAR 0 4
109019: PUSH
109020: LD_EXP 165
109024: PUSH
109025: LD_VAR 0 1
109029: ARRAY
109030: PUSH
109031: LD_VAR 0 2
109035: ARRAY
109036: PUSH
109037: LD_INT 1
109039: ARRAY
109040: PPUSH
109041: LD_EXP 165
109045: PUSH
109046: LD_VAR 0 1
109050: ARRAY
109051: PUSH
109052: LD_VAR 0 2
109056: ARRAY
109057: PUSH
109058: LD_INT 2
109060: ARRAY
109061: PPUSH
109062: CALL_OW 428
109066: ST_TO_ADDR
// if not tmp then
109067: LD_VAR 0 4
109071: NOT
109072: IFFALSE 109076
// continue ;
109074: GO 108991
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109076: LD_VAR 0 4
109080: PUSH
109081: LD_INT 81
109083: PUSH
109084: LD_VAR 0 3
109088: PUSH
109089: EMPTY
109090: LIST
109091: LIST
109092: PPUSH
109093: CALL_OW 69
109097: IN
109098: PUSH
109099: LD_EXP 165
109103: PUSH
109104: LD_VAR 0 1
109108: ARRAY
109109: PUSH
109110: LD_VAR 0 2
109114: ARRAY
109115: PUSH
109116: LD_INT 1
109118: ARRAY
109119: PPUSH
109120: LD_EXP 165
109124: PUSH
109125: LD_VAR 0 1
109129: ARRAY
109130: PUSH
109131: LD_VAR 0 2
109135: ARRAY
109136: PUSH
109137: LD_INT 2
109139: ARRAY
109140: PPUSH
109141: CALL_OW 458
109145: AND
109146: IFFALSE 109240
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109148: LD_EXP 165
109152: PUSH
109153: LD_VAR 0 1
109157: ARRAY
109158: PUSH
109159: LD_VAR 0 2
109163: ARRAY
109164: PUSH
109165: LD_INT 1
109167: ARRAY
109168: PPUSH
109169: LD_EXP 165
109173: PUSH
109174: LD_VAR 0 1
109178: ARRAY
109179: PUSH
109180: LD_VAR 0 2
109184: ARRAY
109185: PUSH
109186: LD_INT 2
109188: ARRAY
109189: PPUSH
109190: LD_VAR 0 3
109194: PPUSH
109195: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109199: LD_ADDR_EXP 165
109203: PUSH
109204: LD_EXP 165
109208: PPUSH
109209: LD_VAR 0 1
109213: PPUSH
109214: LD_EXP 165
109218: PUSH
109219: LD_VAR 0 1
109223: ARRAY
109224: PPUSH
109225: LD_VAR 0 2
109229: PPUSH
109230: CALL_OW 3
109234: PPUSH
109235: CALL_OW 1
109239: ST_TO_ADDR
// end ; end ;
109240: GO 108991
109242: POP
109243: POP
// end ;
109244: GO 108909
109246: POP
109247: POP
// end ;
109248: PPOPN 4
109250: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109251: LD_INT 0
109253: PPUSH
109254: PPUSH
// result := false ;
109255: LD_ADDR_VAR 0 4
109259: PUSH
109260: LD_INT 0
109262: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109263: LD_VAR 0 1
109267: PPUSH
109268: CALL_OW 264
109272: PUSH
109273: LD_INT 81
109275: EQUAL
109276: NOT
109277: IFFALSE 109281
// exit ;
109279: GO 109521
// index := GetElementIndex ( minersList , unit ) ;
109281: LD_ADDR_VAR 0 5
109285: PUSH
109286: LD_EXP 164
109290: PPUSH
109291: LD_VAR 0 1
109295: PPUSH
109296: CALL 53852 0 2
109300: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109301: LD_EXP 165
109305: PUSH
109306: LD_VAR 0 5
109310: ARRAY
109311: PUSH
109312: LD_EXP 166
109316: GREATEREQUAL
109317: IFFALSE 109321
// exit ;
109319: GO 109521
// ComMoveXY ( unit , x , y ) ;
109321: LD_VAR 0 1
109325: PPUSH
109326: LD_VAR 0 2
109330: PPUSH
109331: LD_VAR 0 3
109335: PPUSH
109336: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109340: LD_INT 35
109342: PPUSH
109343: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109347: LD_VAR 0 1
109351: PPUSH
109352: LD_VAR 0 2
109356: PPUSH
109357: LD_VAR 0 3
109361: PPUSH
109362: CALL 85236 0 3
109366: NOT
109367: PUSH
109368: LD_VAR 0 1
109372: PPUSH
109373: CALL_OW 314
109377: AND
109378: IFFALSE 109382
// exit ;
109380: GO 109521
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109382: LD_VAR 0 2
109386: PPUSH
109387: LD_VAR 0 3
109391: PPUSH
109392: CALL_OW 428
109396: PUSH
109397: LD_VAR 0 1
109401: EQUAL
109402: PUSH
109403: LD_VAR 0 1
109407: PPUSH
109408: CALL_OW 314
109412: NOT
109413: AND
109414: IFFALSE 109340
// PlaySoundXY ( x , y , PlantMine ) ;
109416: LD_VAR 0 2
109420: PPUSH
109421: LD_VAR 0 3
109425: PPUSH
109426: LD_STRING PlantMine
109428: PPUSH
109429: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109433: LD_VAR 0 2
109437: PPUSH
109438: LD_VAR 0 3
109442: PPUSH
109443: LD_VAR 0 1
109447: PPUSH
109448: CALL_OW 255
109452: PPUSH
109453: LD_INT 0
109455: PPUSH
109456: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109460: LD_ADDR_EXP 165
109464: PUSH
109465: LD_EXP 165
109469: PPUSH
109470: LD_VAR 0 5
109474: PUSH
109475: LD_EXP 165
109479: PUSH
109480: LD_VAR 0 5
109484: ARRAY
109485: PUSH
109486: LD_INT 1
109488: PLUS
109489: PUSH
109490: EMPTY
109491: LIST
109492: LIST
109493: PPUSH
109494: LD_VAR 0 2
109498: PUSH
109499: LD_VAR 0 3
109503: PUSH
109504: EMPTY
109505: LIST
109506: LIST
109507: PPUSH
109508: CALL 54067 0 3
109512: ST_TO_ADDR
// result := true ;
109513: LD_ADDR_VAR 0 4
109517: PUSH
109518: LD_INT 1
109520: ST_TO_ADDR
// end ;
109521: LD_VAR 0 4
109525: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109526: LD_INT 0
109528: PPUSH
109529: PPUSH
109530: PPUSH
// if not unit in minersList then
109531: LD_VAR 0 1
109535: PUSH
109536: LD_EXP 164
109540: IN
109541: NOT
109542: IFFALSE 109546
// exit ;
109544: GO 109938
// index := GetElementIndex ( minersList , unit ) ;
109546: LD_ADDR_VAR 0 6
109550: PUSH
109551: LD_EXP 164
109555: PPUSH
109556: LD_VAR 0 1
109560: PPUSH
109561: CALL 53852 0 2
109565: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109566: LD_ADDR_VAR 0 5
109570: PUSH
109571: DOUBLE
109572: LD_EXP 165
109576: PUSH
109577: LD_VAR 0 6
109581: ARRAY
109582: INC
109583: ST_TO_ADDR
109584: LD_INT 1
109586: PUSH
109587: FOR_DOWNTO
109588: IFFALSE 109749
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109590: LD_EXP 165
109594: PUSH
109595: LD_VAR 0 6
109599: ARRAY
109600: PUSH
109601: LD_VAR 0 5
109605: ARRAY
109606: PUSH
109607: LD_INT 1
109609: ARRAY
109610: PUSH
109611: LD_VAR 0 2
109615: EQUAL
109616: PUSH
109617: LD_EXP 165
109621: PUSH
109622: LD_VAR 0 6
109626: ARRAY
109627: PUSH
109628: LD_VAR 0 5
109632: ARRAY
109633: PUSH
109634: LD_INT 2
109636: ARRAY
109637: PUSH
109638: LD_VAR 0 3
109642: EQUAL
109643: AND
109644: IFFALSE 109747
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109646: LD_EXP 165
109650: PUSH
109651: LD_VAR 0 6
109655: ARRAY
109656: PUSH
109657: LD_VAR 0 5
109661: ARRAY
109662: PUSH
109663: LD_INT 1
109665: ARRAY
109666: PPUSH
109667: LD_EXP 165
109671: PUSH
109672: LD_VAR 0 6
109676: ARRAY
109677: PUSH
109678: LD_VAR 0 5
109682: ARRAY
109683: PUSH
109684: LD_INT 2
109686: ARRAY
109687: PPUSH
109688: LD_VAR 0 1
109692: PPUSH
109693: CALL_OW 255
109697: PPUSH
109698: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109702: LD_ADDR_EXP 165
109706: PUSH
109707: LD_EXP 165
109711: PPUSH
109712: LD_VAR 0 6
109716: PPUSH
109717: LD_EXP 165
109721: PUSH
109722: LD_VAR 0 6
109726: ARRAY
109727: PPUSH
109728: LD_VAR 0 5
109732: PPUSH
109733: CALL_OW 3
109737: PPUSH
109738: CALL_OW 1
109742: ST_TO_ADDR
// exit ;
109743: POP
109744: POP
109745: GO 109938
// end ; end ;
109747: GO 109587
109749: POP
109750: POP
// for i := minerMinesList [ index ] downto 1 do
109751: LD_ADDR_VAR 0 5
109755: PUSH
109756: DOUBLE
109757: LD_EXP 165
109761: PUSH
109762: LD_VAR 0 6
109766: ARRAY
109767: INC
109768: ST_TO_ADDR
109769: LD_INT 1
109771: PUSH
109772: FOR_DOWNTO
109773: IFFALSE 109936
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109775: LD_EXP 165
109779: PUSH
109780: LD_VAR 0 6
109784: ARRAY
109785: PUSH
109786: LD_VAR 0 5
109790: ARRAY
109791: PUSH
109792: LD_INT 1
109794: ARRAY
109795: PPUSH
109796: LD_EXP 165
109800: PUSH
109801: LD_VAR 0 6
109805: ARRAY
109806: PUSH
109807: LD_VAR 0 5
109811: ARRAY
109812: PUSH
109813: LD_INT 2
109815: ARRAY
109816: PPUSH
109817: LD_VAR 0 2
109821: PPUSH
109822: LD_VAR 0 3
109826: PPUSH
109827: CALL_OW 298
109831: PUSH
109832: LD_INT 6
109834: LESS
109835: IFFALSE 109934
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109837: LD_EXP 165
109841: PUSH
109842: LD_VAR 0 6
109846: ARRAY
109847: PUSH
109848: LD_VAR 0 5
109852: ARRAY
109853: PUSH
109854: LD_INT 1
109856: ARRAY
109857: PPUSH
109858: LD_EXP 165
109862: PUSH
109863: LD_VAR 0 6
109867: ARRAY
109868: PUSH
109869: LD_VAR 0 5
109873: ARRAY
109874: PUSH
109875: LD_INT 2
109877: ARRAY
109878: PPUSH
109879: LD_VAR 0 1
109883: PPUSH
109884: CALL_OW 255
109888: PPUSH
109889: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109893: LD_ADDR_EXP 165
109897: PUSH
109898: LD_EXP 165
109902: PPUSH
109903: LD_VAR 0 6
109907: PPUSH
109908: LD_EXP 165
109912: PUSH
109913: LD_VAR 0 6
109917: ARRAY
109918: PPUSH
109919: LD_VAR 0 5
109923: PPUSH
109924: CALL_OW 3
109928: PPUSH
109929: CALL_OW 1
109933: ST_TO_ADDR
// end ; end ;
109934: GO 109772
109936: POP
109937: POP
// end ;
109938: LD_VAR 0 4
109942: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109943: LD_INT 0
109945: PPUSH
109946: PPUSH
109947: PPUSH
109948: PPUSH
109949: PPUSH
109950: PPUSH
109951: PPUSH
109952: PPUSH
109953: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109954: LD_VAR 0 1
109958: PPUSH
109959: CALL_OW 264
109963: PUSH
109964: LD_INT 81
109966: EQUAL
109967: NOT
109968: PUSH
109969: LD_VAR 0 1
109973: PUSH
109974: LD_EXP 164
109978: IN
109979: NOT
109980: OR
109981: IFFALSE 109985
// exit ;
109983: GO 110307
// index := GetElementIndex ( minersList , unit ) ;
109985: LD_ADDR_VAR 0 6
109989: PUSH
109990: LD_EXP 164
109994: PPUSH
109995: LD_VAR 0 1
109999: PPUSH
110000: CALL 53852 0 2
110004: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110005: LD_ADDR_VAR 0 8
110009: PUSH
110010: LD_EXP 166
110014: PUSH
110015: LD_EXP 165
110019: PUSH
110020: LD_VAR 0 6
110024: ARRAY
110025: MINUS
110026: ST_TO_ADDR
// if not minesFreeAmount then
110027: LD_VAR 0 8
110031: NOT
110032: IFFALSE 110036
// exit ;
110034: GO 110307
// tmp := [ ] ;
110036: LD_ADDR_VAR 0 7
110040: PUSH
110041: EMPTY
110042: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110043: LD_ADDR_VAR 0 5
110047: PUSH
110048: DOUBLE
110049: LD_INT 1
110051: DEC
110052: ST_TO_ADDR
110053: LD_VAR 0 8
110057: PUSH
110058: FOR_TO
110059: IFFALSE 110254
// begin _d := rand ( 0 , 5 ) ;
110061: LD_ADDR_VAR 0 11
110065: PUSH
110066: LD_INT 0
110068: PPUSH
110069: LD_INT 5
110071: PPUSH
110072: CALL_OW 12
110076: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110077: LD_ADDR_VAR 0 12
110081: PUSH
110082: LD_INT 2
110084: PPUSH
110085: LD_INT 6
110087: PPUSH
110088: CALL_OW 12
110092: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110093: LD_ADDR_VAR 0 9
110097: PUSH
110098: LD_VAR 0 2
110102: PPUSH
110103: LD_VAR 0 11
110107: PPUSH
110108: LD_VAR 0 12
110112: PPUSH
110113: CALL_OW 272
110117: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110118: LD_ADDR_VAR 0 10
110122: PUSH
110123: LD_VAR 0 3
110127: PPUSH
110128: LD_VAR 0 11
110132: PPUSH
110133: LD_VAR 0 12
110137: PPUSH
110138: CALL_OW 273
110142: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110143: LD_VAR 0 9
110147: PPUSH
110148: LD_VAR 0 10
110152: PPUSH
110153: CALL_OW 488
110157: PUSH
110158: LD_VAR 0 9
110162: PUSH
110163: LD_VAR 0 10
110167: PUSH
110168: EMPTY
110169: LIST
110170: LIST
110171: PUSH
110172: LD_VAR 0 7
110176: IN
110177: NOT
110178: AND
110179: PUSH
110180: LD_VAR 0 9
110184: PPUSH
110185: LD_VAR 0 10
110189: PPUSH
110190: CALL_OW 458
110194: NOT
110195: AND
110196: IFFALSE 110238
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110198: LD_ADDR_VAR 0 7
110202: PUSH
110203: LD_VAR 0 7
110207: PPUSH
110208: LD_VAR 0 7
110212: PUSH
110213: LD_INT 1
110215: PLUS
110216: PPUSH
110217: LD_VAR 0 9
110221: PUSH
110222: LD_VAR 0 10
110226: PUSH
110227: EMPTY
110228: LIST
110229: LIST
110230: PPUSH
110231: CALL_OW 1
110235: ST_TO_ADDR
110236: GO 110252
// i := i - 1 ;
110238: LD_ADDR_VAR 0 5
110242: PUSH
110243: LD_VAR 0 5
110247: PUSH
110248: LD_INT 1
110250: MINUS
110251: ST_TO_ADDR
// end ;
110252: GO 110058
110254: POP
110255: POP
// for i in tmp do
110256: LD_ADDR_VAR 0 5
110260: PUSH
110261: LD_VAR 0 7
110265: PUSH
110266: FOR_IN
110267: IFFALSE 110305
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110269: LD_VAR 0 1
110273: PPUSH
110274: LD_VAR 0 5
110278: PUSH
110279: LD_INT 1
110281: ARRAY
110282: PPUSH
110283: LD_VAR 0 5
110287: PUSH
110288: LD_INT 2
110290: ARRAY
110291: PPUSH
110292: CALL 109251 0 3
110296: NOT
110297: IFFALSE 110303
// exit ;
110299: POP
110300: POP
110301: GO 110307
110303: GO 110266
110305: POP
110306: POP
// end ;
110307: LD_VAR 0 4
110311: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110312: LD_INT 0
110314: PPUSH
110315: PPUSH
110316: PPUSH
110317: PPUSH
110318: PPUSH
110319: PPUSH
110320: PPUSH
// if not GetClass ( unit ) = class_sniper then
110321: LD_VAR 0 1
110325: PPUSH
110326: CALL_OW 257
110330: PUSH
110331: LD_INT 5
110333: EQUAL
110334: NOT
110335: IFFALSE 110339
// exit ;
110337: GO 110727
// dist := 8 ;
110339: LD_ADDR_VAR 0 5
110343: PUSH
110344: LD_INT 8
110346: ST_TO_ADDR
// viewRange := 12 ;
110347: LD_ADDR_VAR 0 7
110351: PUSH
110352: LD_INT 12
110354: ST_TO_ADDR
// side := GetSide ( unit ) ;
110355: LD_ADDR_VAR 0 6
110359: PUSH
110360: LD_VAR 0 1
110364: PPUSH
110365: CALL_OW 255
110369: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110370: LD_INT 61
110372: PPUSH
110373: LD_VAR 0 6
110377: PPUSH
110378: CALL_OW 321
110382: PUSH
110383: LD_INT 2
110385: EQUAL
110386: IFFALSE 110396
// viewRange := 16 ;
110388: LD_ADDR_VAR 0 7
110392: PUSH
110393: LD_INT 16
110395: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110396: LD_VAR 0 1
110400: PPUSH
110401: LD_VAR 0 2
110405: PPUSH
110406: LD_VAR 0 3
110410: PPUSH
110411: CALL_OW 297
110415: PUSH
110416: LD_VAR 0 5
110420: GREATER
110421: IFFALSE 110500
// begin ComMoveXY ( unit , x , y ) ;
110423: LD_VAR 0 1
110427: PPUSH
110428: LD_VAR 0 2
110432: PPUSH
110433: LD_VAR 0 3
110437: PPUSH
110438: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110442: LD_INT 35
110444: PPUSH
110445: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110449: LD_VAR 0 1
110453: PPUSH
110454: LD_VAR 0 2
110458: PPUSH
110459: LD_VAR 0 3
110463: PPUSH
110464: CALL 85236 0 3
110468: NOT
110469: IFFALSE 110473
// exit ;
110471: GO 110727
// until GetDistUnitXY ( unit , x , y ) < dist ;
110473: LD_VAR 0 1
110477: PPUSH
110478: LD_VAR 0 2
110482: PPUSH
110483: LD_VAR 0 3
110487: PPUSH
110488: CALL_OW 297
110492: PUSH
110493: LD_VAR 0 5
110497: LESS
110498: IFFALSE 110442
// end ; ComTurnXY ( unit , x , y ) ;
110500: LD_VAR 0 1
110504: PPUSH
110505: LD_VAR 0 2
110509: PPUSH
110510: LD_VAR 0 3
110514: PPUSH
110515: CALL_OW 118
// wait ( 5 ) ;
110519: LD_INT 5
110521: PPUSH
110522: CALL_OW 67
// _d := GetDir ( unit ) ;
110526: LD_ADDR_VAR 0 10
110530: PUSH
110531: LD_VAR 0 1
110535: PPUSH
110536: CALL_OW 254
110540: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110541: LD_ADDR_VAR 0 8
110545: PUSH
110546: LD_VAR 0 1
110550: PPUSH
110551: CALL_OW 250
110555: PPUSH
110556: LD_VAR 0 10
110560: PPUSH
110561: LD_VAR 0 5
110565: PPUSH
110566: CALL_OW 272
110570: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110571: LD_ADDR_VAR 0 9
110575: PUSH
110576: LD_VAR 0 1
110580: PPUSH
110581: CALL_OW 251
110585: PPUSH
110586: LD_VAR 0 10
110590: PPUSH
110591: LD_VAR 0 5
110595: PPUSH
110596: CALL_OW 273
110600: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110601: LD_VAR 0 8
110605: PPUSH
110606: LD_VAR 0 9
110610: PPUSH
110611: CALL_OW 488
110615: NOT
110616: IFFALSE 110620
// exit ;
110618: GO 110727
// ComAnimCustom ( unit , 1 ) ;
110620: LD_VAR 0 1
110624: PPUSH
110625: LD_INT 1
110627: PPUSH
110628: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110632: LD_VAR 0 8
110636: PPUSH
110637: LD_VAR 0 9
110641: PPUSH
110642: LD_VAR 0 6
110646: PPUSH
110647: LD_VAR 0 7
110651: PPUSH
110652: CALL_OW 330
// repeat wait ( 1 ) ;
110656: LD_INT 1
110658: PPUSH
110659: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110663: LD_VAR 0 1
110667: PPUSH
110668: CALL_OW 316
110672: PUSH
110673: LD_VAR 0 1
110677: PPUSH
110678: CALL_OW 314
110682: OR
110683: PUSH
110684: LD_VAR 0 1
110688: PPUSH
110689: CALL_OW 302
110693: NOT
110694: OR
110695: PUSH
110696: LD_VAR 0 1
110700: PPUSH
110701: CALL_OW 301
110705: OR
110706: IFFALSE 110656
// RemoveSeeing ( _x , _y , side ) ;
110708: LD_VAR 0 8
110712: PPUSH
110713: LD_VAR 0 9
110717: PPUSH
110718: LD_VAR 0 6
110722: PPUSH
110723: CALL_OW 331
// end ; end_of_file
110727: LD_VAR 0 4
110731: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110732: LD_INT 0
110734: PPUSH
110735: PPUSH
110736: PPUSH
110737: PPUSH
110738: PPUSH
110739: PPUSH
110740: PPUSH
110741: PPUSH
110742: PPUSH
110743: PPUSH
110744: PPUSH
110745: PPUSH
110746: PPUSH
110747: PPUSH
110748: PPUSH
110749: PPUSH
110750: PPUSH
110751: PPUSH
110752: PPUSH
110753: PPUSH
110754: PPUSH
110755: PPUSH
110756: PPUSH
110757: PPUSH
110758: PPUSH
110759: PPUSH
110760: PPUSH
110761: PPUSH
110762: PPUSH
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
110767: PPUSH
// if not list then
110768: LD_VAR 0 1
110772: NOT
110773: IFFALSE 110777
// exit ;
110775: GO 115436
// base := list [ 1 ] ;
110777: LD_ADDR_VAR 0 3
110781: PUSH
110782: LD_VAR 0 1
110786: PUSH
110787: LD_INT 1
110789: ARRAY
110790: ST_TO_ADDR
// group := list [ 2 ] ;
110791: LD_ADDR_VAR 0 4
110795: PUSH
110796: LD_VAR 0 1
110800: PUSH
110801: LD_INT 2
110803: ARRAY
110804: ST_TO_ADDR
// path := list [ 3 ] ;
110805: LD_ADDR_VAR 0 5
110809: PUSH
110810: LD_VAR 0 1
110814: PUSH
110815: LD_INT 3
110817: ARRAY
110818: ST_TO_ADDR
// flags := list [ 4 ] ;
110819: LD_ADDR_VAR 0 6
110823: PUSH
110824: LD_VAR 0 1
110828: PUSH
110829: LD_INT 4
110831: ARRAY
110832: ST_TO_ADDR
// mined := [ ] ;
110833: LD_ADDR_VAR 0 27
110837: PUSH
110838: EMPTY
110839: ST_TO_ADDR
// bombed := [ ] ;
110840: LD_ADDR_VAR 0 28
110844: PUSH
110845: EMPTY
110846: ST_TO_ADDR
// healers := [ ] ;
110847: LD_ADDR_VAR 0 31
110851: PUSH
110852: EMPTY
110853: ST_TO_ADDR
// to_heal := [ ] ;
110854: LD_ADDR_VAR 0 30
110858: PUSH
110859: EMPTY
110860: ST_TO_ADDR
// repairs := [ ] ;
110861: LD_ADDR_VAR 0 33
110865: PUSH
110866: EMPTY
110867: ST_TO_ADDR
// to_repair := [ ] ;
110868: LD_ADDR_VAR 0 32
110872: PUSH
110873: EMPTY
110874: ST_TO_ADDR
// if not group or not path then
110875: LD_VAR 0 4
110879: NOT
110880: PUSH
110881: LD_VAR 0 5
110885: NOT
110886: OR
110887: IFFALSE 110891
// exit ;
110889: GO 115436
// side := GetSide ( group [ 1 ] ) ;
110891: LD_ADDR_VAR 0 35
110895: PUSH
110896: LD_VAR 0 4
110900: PUSH
110901: LD_INT 1
110903: ARRAY
110904: PPUSH
110905: CALL_OW 255
110909: ST_TO_ADDR
// if flags then
110910: LD_VAR 0 6
110914: IFFALSE 111058
// begin f_ignore_area := flags [ 1 ] ;
110916: LD_ADDR_VAR 0 17
110920: PUSH
110921: LD_VAR 0 6
110925: PUSH
110926: LD_INT 1
110928: ARRAY
110929: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110930: LD_ADDR_VAR 0 18
110934: PUSH
110935: LD_VAR 0 6
110939: PUSH
110940: LD_INT 2
110942: ARRAY
110943: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110944: LD_ADDR_VAR 0 19
110948: PUSH
110949: LD_VAR 0 6
110953: PUSH
110954: LD_INT 3
110956: ARRAY
110957: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110958: LD_ADDR_VAR 0 20
110962: PUSH
110963: LD_VAR 0 6
110967: PUSH
110968: LD_INT 4
110970: ARRAY
110971: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110972: LD_ADDR_VAR 0 21
110976: PUSH
110977: LD_VAR 0 6
110981: PUSH
110982: LD_INT 5
110984: ARRAY
110985: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110986: LD_ADDR_VAR 0 22
110990: PUSH
110991: LD_VAR 0 6
110995: PUSH
110996: LD_INT 6
110998: ARRAY
110999: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111000: LD_ADDR_VAR 0 23
111004: PUSH
111005: LD_VAR 0 6
111009: PUSH
111010: LD_INT 7
111012: ARRAY
111013: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111014: LD_ADDR_VAR 0 24
111018: PUSH
111019: LD_VAR 0 6
111023: PUSH
111024: LD_INT 8
111026: ARRAY
111027: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111028: LD_ADDR_VAR 0 25
111032: PUSH
111033: LD_VAR 0 6
111037: PUSH
111038: LD_INT 9
111040: ARRAY
111041: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111042: LD_ADDR_VAR 0 26
111046: PUSH
111047: LD_VAR 0 6
111051: PUSH
111052: LD_INT 10
111054: ARRAY
111055: ST_TO_ADDR
// end else
111056: GO 111138
// begin f_ignore_area := false ;
111058: LD_ADDR_VAR 0 17
111062: PUSH
111063: LD_INT 0
111065: ST_TO_ADDR
// f_capture := false ;
111066: LD_ADDR_VAR 0 18
111070: PUSH
111071: LD_INT 0
111073: ST_TO_ADDR
// f_ignore_civ := false ;
111074: LD_ADDR_VAR 0 19
111078: PUSH
111079: LD_INT 0
111081: ST_TO_ADDR
// f_murder := false ;
111082: LD_ADDR_VAR 0 20
111086: PUSH
111087: LD_INT 0
111089: ST_TO_ADDR
// f_mines := false ;
111090: LD_ADDR_VAR 0 21
111094: PUSH
111095: LD_INT 0
111097: ST_TO_ADDR
// f_repair := false ;
111098: LD_ADDR_VAR 0 22
111102: PUSH
111103: LD_INT 0
111105: ST_TO_ADDR
// f_heal := false ;
111106: LD_ADDR_VAR 0 23
111110: PUSH
111111: LD_INT 0
111113: ST_TO_ADDR
// f_spacetime := false ;
111114: LD_ADDR_VAR 0 24
111118: PUSH
111119: LD_INT 0
111121: ST_TO_ADDR
// f_attack_depot := false ;
111122: LD_ADDR_VAR 0 25
111126: PUSH
111127: LD_INT 0
111129: ST_TO_ADDR
// f_crawl := false ;
111130: LD_ADDR_VAR 0 26
111134: PUSH
111135: LD_INT 0
111137: ST_TO_ADDR
// end ; if f_heal then
111138: LD_VAR 0 23
111142: IFFALSE 111169
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111144: LD_ADDR_VAR 0 31
111148: PUSH
111149: LD_VAR 0 4
111153: PPUSH
111154: LD_INT 25
111156: PUSH
111157: LD_INT 4
111159: PUSH
111160: EMPTY
111161: LIST
111162: LIST
111163: PPUSH
111164: CALL_OW 72
111168: ST_TO_ADDR
// if f_repair then
111169: LD_VAR 0 22
111173: IFFALSE 111200
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111175: LD_ADDR_VAR 0 33
111179: PUSH
111180: LD_VAR 0 4
111184: PPUSH
111185: LD_INT 25
111187: PUSH
111188: LD_INT 3
111190: PUSH
111191: EMPTY
111192: LIST
111193: LIST
111194: PPUSH
111195: CALL_OW 72
111199: ST_TO_ADDR
// units_path := [ ] ;
111200: LD_ADDR_VAR 0 16
111204: PUSH
111205: EMPTY
111206: ST_TO_ADDR
// for i = 1 to group do
111207: LD_ADDR_VAR 0 7
111211: PUSH
111212: DOUBLE
111213: LD_INT 1
111215: DEC
111216: ST_TO_ADDR
111217: LD_VAR 0 4
111221: PUSH
111222: FOR_TO
111223: IFFALSE 111252
// units_path := Replace ( units_path , i , path ) ;
111225: LD_ADDR_VAR 0 16
111229: PUSH
111230: LD_VAR 0 16
111234: PPUSH
111235: LD_VAR 0 7
111239: PPUSH
111240: LD_VAR 0 5
111244: PPUSH
111245: CALL_OW 1
111249: ST_TO_ADDR
111250: GO 111222
111252: POP
111253: POP
// repeat for i = group downto 1 do
111254: LD_ADDR_VAR 0 7
111258: PUSH
111259: DOUBLE
111260: LD_VAR 0 4
111264: INC
111265: ST_TO_ADDR
111266: LD_INT 1
111268: PUSH
111269: FOR_DOWNTO
111270: IFFALSE 115392
// begin wait ( 5 ) ;
111272: LD_INT 5
111274: PPUSH
111275: CALL_OW 67
// tmp := [ ] ;
111279: LD_ADDR_VAR 0 14
111283: PUSH
111284: EMPTY
111285: ST_TO_ADDR
// attacking := false ;
111286: LD_ADDR_VAR 0 29
111290: PUSH
111291: LD_INT 0
111293: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111294: LD_VAR 0 4
111298: PUSH
111299: LD_VAR 0 7
111303: ARRAY
111304: PPUSH
111305: CALL_OW 301
111309: PUSH
111310: LD_VAR 0 4
111314: PUSH
111315: LD_VAR 0 7
111319: ARRAY
111320: NOT
111321: OR
111322: IFFALSE 111431
// begin if GetType ( group [ i ] ) = unit_human then
111324: LD_VAR 0 4
111328: PUSH
111329: LD_VAR 0 7
111333: ARRAY
111334: PPUSH
111335: CALL_OW 247
111339: PUSH
111340: LD_INT 1
111342: EQUAL
111343: IFFALSE 111389
// begin to_heal := to_heal diff group [ i ] ;
111345: LD_ADDR_VAR 0 30
111349: PUSH
111350: LD_VAR 0 30
111354: PUSH
111355: LD_VAR 0 4
111359: PUSH
111360: LD_VAR 0 7
111364: ARRAY
111365: DIFF
111366: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111367: LD_ADDR_VAR 0 31
111371: PUSH
111372: LD_VAR 0 31
111376: PUSH
111377: LD_VAR 0 4
111381: PUSH
111382: LD_VAR 0 7
111386: ARRAY
111387: DIFF
111388: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111389: LD_ADDR_VAR 0 4
111393: PUSH
111394: LD_VAR 0 4
111398: PPUSH
111399: LD_VAR 0 7
111403: PPUSH
111404: CALL_OW 3
111408: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111409: LD_ADDR_VAR 0 16
111413: PUSH
111414: LD_VAR 0 16
111418: PPUSH
111419: LD_VAR 0 7
111423: PPUSH
111424: CALL_OW 3
111428: ST_TO_ADDR
// continue ;
111429: GO 111269
// end ; if f_repair then
111431: LD_VAR 0 22
111435: IFFALSE 111924
// begin if GetType ( group [ i ] ) = unit_vehicle then
111437: LD_VAR 0 4
111441: PUSH
111442: LD_VAR 0 7
111446: ARRAY
111447: PPUSH
111448: CALL_OW 247
111452: PUSH
111453: LD_INT 2
111455: EQUAL
111456: IFFALSE 111646
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111458: LD_VAR 0 4
111462: PUSH
111463: LD_VAR 0 7
111467: ARRAY
111468: PPUSH
111469: CALL_OW 256
111473: PUSH
111474: LD_INT 700
111476: LESS
111477: PUSH
111478: LD_VAR 0 4
111482: PUSH
111483: LD_VAR 0 7
111487: ARRAY
111488: PUSH
111489: LD_VAR 0 32
111493: IN
111494: NOT
111495: AND
111496: IFFALSE 111520
// to_repair := to_repair union group [ i ] ;
111498: LD_ADDR_VAR 0 32
111502: PUSH
111503: LD_VAR 0 32
111507: PUSH
111508: LD_VAR 0 4
111512: PUSH
111513: LD_VAR 0 7
111517: ARRAY
111518: UNION
111519: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111520: LD_VAR 0 4
111524: PUSH
111525: LD_VAR 0 7
111529: ARRAY
111530: PPUSH
111531: CALL_OW 256
111535: PUSH
111536: LD_INT 1000
111538: EQUAL
111539: PUSH
111540: LD_VAR 0 4
111544: PUSH
111545: LD_VAR 0 7
111549: ARRAY
111550: PUSH
111551: LD_VAR 0 32
111555: IN
111556: AND
111557: IFFALSE 111581
// to_repair := to_repair diff group [ i ] ;
111559: LD_ADDR_VAR 0 32
111563: PUSH
111564: LD_VAR 0 32
111568: PUSH
111569: LD_VAR 0 4
111573: PUSH
111574: LD_VAR 0 7
111578: ARRAY
111579: DIFF
111580: ST_TO_ADDR
// if group [ i ] in to_repair then
111581: LD_VAR 0 4
111585: PUSH
111586: LD_VAR 0 7
111590: ARRAY
111591: PUSH
111592: LD_VAR 0 32
111596: IN
111597: IFFALSE 111644
// begin if not IsInArea ( group [ i ] , f_repair ) then
111599: LD_VAR 0 4
111603: PUSH
111604: LD_VAR 0 7
111608: ARRAY
111609: PPUSH
111610: LD_VAR 0 22
111614: PPUSH
111615: CALL_OW 308
111619: NOT
111620: IFFALSE 111642
// ComMoveToArea ( group [ i ] , f_repair ) ;
111622: LD_VAR 0 4
111626: PUSH
111627: LD_VAR 0 7
111631: ARRAY
111632: PPUSH
111633: LD_VAR 0 22
111637: PPUSH
111638: CALL_OW 113
// continue ;
111642: GO 111269
// end ; end else
111644: GO 111924
// if group [ i ] in repairs then
111646: LD_VAR 0 4
111650: PUSH
111651: LD_VAR 0 7
111655: ARRAY
111656: PUSH
111657: LD_VAR 0 33
111661: IN
111662: IFFALSE 111924
// begin if IsInUnit ( group [ i ] ) then
111664: LD_VAR 0 4
111668: PUSH
111669: LD_VAR 0 7
111673: ARRAY
111674: PPUSH
111675: CALL_OW 310
111679: IFFALSE 111747
// begin z := IsInUnit ( group [ i ] ) ;
111681: LD_ADDR_VAR 0 13
111685: PUSH
111686: LD_VAR 0 4
111690: PUSH
111691: LD_VAR 0 7
111695: ARRAY
111696: PPUSH
111697: CALL_OW 310
111701: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111702: LD_VAR 0 13
111706: PUSH
111707: LD_VAR 0 32
111711: IN
111712: PUSH
111713: LD_VAR 0 13
111717: PPUSH
111718: LD_VAR 0 22
111722: PPUSH
111723: CALL_OW 308
111727: AND
111728: IFFALSE 111745
// ComExitVehicle ( group [ i ] ) ;
111730: LD_VAR 0 4
111734: PUSH
111735: LD_VAR 0 7
111739: ARRAY
111740: PPUSH
111741: CALL_OW 121
// end else
111745: GO 111924
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111747: LD_ADDR_VAR 0 13
111751: PUSH
111752: LD_VAR 0 4
111756: PPUSH
111757: LD_INT 95
111759: PUSH
111760: LD_VAR 0 22
111764: PUSH
111765: EMPTY
111766: LIST
111767: LIST
111768: PUSH
111769: LD_INT 58
111771: PUSH
111772: EMPTY
111773: LIST
111774: PUSH
111775: EMPTY
111776: LIST
111777: LIST
111778: PPUSH
111779: CALL_OW 72
111783: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111784: LD_VAR 0 4
111788: PUSH
111789: LD_VAR 0 7
111793: ARRAY
111794: PPUSH
111795: CALL_OW 314
111799: NOT
111800: IFFALSE 111922
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111802: LD_ADDR_VAR 0 10
111806: PUSH
111807: LD_VAR 0 13
111811: PPUSH
111812: LD_VAR 0 4
111816: PUSH
111817: LD_VAR 0 7
111821: ARRAY
111822: PPUSH
111823: CALL_OW 74
111827: ST_TO_ADDR
// if not x then
111828: LD_VAR 0 10
111832: NOT
111833: IFFALSE 111837
// continue ;
111835: GO 111269
// if GetLives ( x ) < 1000 then
111837: LD_VAR 0 10
111841: PPUSH
111842: CALL_OW 256
111846: PUSH
111847: LD_INT 1000
111849: LESS
111850: IFFALSE 111874
// ComRepairVehicle ( group [ i ] , x ) else
111852: LD_VAR 0 4
111856: PUSH
111857: LD_VAR 0 7
111861: ARRAY
111862: PPUSH
111863: LD_VAR 0 10
111867: PPUSH
111868: CALL_OW 129
111872: GO 111922
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111874: LD_VAR 0 23
111878: PUSH
111879: LD_VAR 0 4
111883: PUSH
111884: LD_VAR 0 7
111888: ARRAY
111889: PPUSH
111890: CALL_OW 256
111894: PUSH
111895: LD_INT 1000
111897: LESS
111898: AND
111899: NOT
111900: IFFALSE 111922
// ComEnterUnit ( group [ i ] , x ) ;
111902: LD_VAR 0 4
111906: PUSH
111907: LD_VAR 0 7
111911: ARRAY
111912: PPUSH
111913: LD_VAR 0 10
111917: PPUSH
111918: CALL_OW 120
// end ; continue ;
111922: GO 111269
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111924: LD_VAR 0 23
111928: PUSH
111929: LD_VAR 0 4
111933: PUSH
111934: LD_VAR 0 7
111938: ARRAY
111939: PPUSH
111940: CALL_OW 247
111944: PUSH
111945: LD_INT 1
111947: EQUAL
111948: AND
111949: IFFALSE 112427
// begin if group [ i ] in healers then
111951: LD_VAR 0 4
111955: PUSH
111956: LD_VAR 0 7
111960: ARRAY
111961: PUSH
111962: LD_VAR 0 31
111966: IN
111967: IFFALSE 112240
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111969: LD_VAR 0 4
111973: PUSH
111974: LD_VAR 0 7
111978: ARRAY
111979: PPUSH
111980: LD_VAR 0 23
111984: PPUSH
111985: CALL_OW 308
111989: NOT
111990: PUSH
111991: LD_VAR 0 4
111995: PUSH
111996: LD_VAR 0 7
112000: ARRAY
112001: PPUSH
112002: CALL_OW 314
112006: NOT
112007: AND
112008: IFFALSE 112032
// ComMoveToArea ( group [ i ] , f_heal ) else
112010: LD_VAR 0 4
112014: PUSH
112015: LD_VAR 0 7
112019: ARRAY
112020: PPUSH
112021: LD_VAR 0 23
112025: PPUSH
112026: CALL_OW 113
112030: GO 112238
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112032: LD_VAR 0 4
112036: PUSH
112037: LD_VAR 0 7
112041: ARRAY
112042: PPUSH
112043: CALL 83819 0 1
112047: PPUSH
112048: CALL_OW 256
112052: PUSH
112053: LD_INT 1000
112055: EQUAL
112056: IFFALSE 112075
// ComStop ( group [ i ] ) else
112058: LD_VAR 0 4
112062: PUSH
112063: LD_VAR 0 7
112067: ARRAY
112068: PPUSH
112069: CALL_OW 141
112073: GO 112238
// if not HasTask ( group [ i ] ) and to_heal then
112075: LD_VAR 0 4
112079: PUSH
112080: LD_VAR 0 7
112084: ARRAY
112085: PPUSH
112086: CALL_OW 314
112090: NOT
112091: PUSH
112092: LD_VAR 0 30
112096: AND
112097: IFFALSE 112238
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112099: LD_ADDR_VAR 0 13
112103: PUSH
112104: LD_VAR 0 30
112108: PPUSH
112109: LD_INT 3
112111: PUSH
112112: LD_INT 54
112114: PUSH
112115: EMPTY
112116: LIST
112117: PUSH
112118: EMPTY
112119: LIST
112120: LIST
112121: PPUSH
112122: CALL_OW 72
112126: PPUSH
112127: LD_VAR 0 4
112131: PUSH
112132: LD_VAR 0 7
112136: ARRAY
112137: PPUSH
112138: CALL_OW 74
112142: ST_TO_ADDR
// if z then
112143: LD_VAR 0 13
112147: IFFALSE 112238
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112149: LD_INT 91
112151: PUSH
112152: LD_VAR 0 13
112156: PUSH
112157: LD_INT 10
112159: PUSH
112160: EMPTY
112161: LIST
112162: LIST
112163: LIST
112164: PUSH
112165: LD_INT 81
112167: PUSH
112168: LD_VAR 0 13
112172: PPUSH
112173: CALL_OW 255
112177: PUSH
112178: EMPTY
112179: LIST
112180: LIST
112181: PUSH
112182: EMPTY
112183: LIST
112184: LIST
112185: PPUSH
112186: CALL_OW 69
112190: PUSH
112191: LD_INT 0
112193: EQUAL
112194: IFFALSE 112218
// ComHeal ( group [ i ] , z ) else
112196: LD_VAR 0 4
112200: PUSH
112201: LD_VAR 0 7
112205: ARRAY
112206: PPUSH
112207: LD_VAR 0 13
112211: PPUSH
112212: CALL_OW 128
112216: GO 112238
// ComMoveToArea ( group [ i ] , f_heal ) ;
112218: LD_VAR 0 4
112222: PUSH
112223: LD_VAR 0 7
112227: ARRAY
112228: PPUSH
112229: LD_VAR 0 23
112233: PPUSH
112234: CALL_OW 113
// end ; continue ;
112238: GO 111269
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112240: LD_VAR 0 4
112244: PUSH
112245: LD_VAR 0 7
112249: ARRAY
112250: PPUSH
112251: CALL_OW 256
112255: PUSH
112256: LD_INT 700
112258: LESS
112259: PUSH
112260: LD_VAR 0 4
112264: PUSH
112265: LD_VAR 0 7
112269: ARRAY
112270: PUSH
112271: LD_VAR 0 30
112275: IN
112276: NOT
112277: AND
112278: IFFALSE 112302
// to_heal := to_heal union group [ i ] ;
112280: LD_ADDR_VAR 0 30
112284: PUSH
112285: LD_VAR 0 30
112289: PUSH
112290: LD_VAR 0 4
112294: PUSH
112295: LD_VAR 0 7
112299: ARRAY
112300: UNION
112301: ST_TO_ADDR
// if group [ i ] in to_heal then
112302: LD_VAR 0 4
112306: PUSH
112307: LD_VAR 0 7
112311: ARRAY
112312: PUSH
112313: LD_VAR 0 30
112317: IN
112318: IFFALSE 112427
// begin if GetLives ( group [ i ] ) = 1000 then
112320: LD_VAR 0 4
112324: PUSH
112325: LD_VAR 0 7
112329: ARRAY
112330: PPUSH
112331: CALL_OW 256
112335: PUSH
112336: LD_INT 1000
112338: EQUAL
112339: IFFALSE 112365
// to_heal := to_heal diff group [ i ] else
112341: LD_ADDR_VAR 0 30
112345: PUSH
112346: LD_VAR 0 30
112350: PUSH
112351: LD_VAR 0 4
112355: PUSH
112356: LD_VAR 0 7
112360: ARRAY
112361: DIFF
112362: ST_TO_ADDR
112363: GO 112427
// begin if not IsInArea ( group [ i ] , to_heal ) then
112365: LD_VAR 0 4
112369: PUSH
112370: LD_VAR 0 7
112374: ARRAY
112375: PPUSH
112376: LD_VAR 0 30
112380: PPUSH
112381: CALL_OW 308
112385: NOT
112386: IFFALSE 112410
// ComMoveToArea ( group [ i ] , f_heal ) else
112388: LD_VAR 0 4
112392: PUSH
112393: LD_VAR 0 7
112397: ARRAY
112398: PPUSH
112399: LD_VAR 0 23
112403: PPUSH
112404: CALL_OW 113
112408: GO 112425
// ComHold ( group [ i ] ) ;
112410: LD_VAR 0 4
112414: PUSH
112415: LD_VAR 0 7
112419: ARRAY
112420: PPUSH
112421: CALL_OW 140
// continue ;
112425: GO 111269
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112427: LD_VAR 0 4
112431: PUSH
112432: LD_VAR 0 7
112436: ARRAY
112437: PPUSH
112438: LD_INT 10
112440: PPUSH
112441: CALL 81590 0 2
112445: NOT
112446: PUSH
112447: LD_VAR 0 16
112451: PUSH
112452: LD_VAR 0 7
112456: ARRAY
112457: PUSH
112458: EMPTY
112459: EQUAL
112460: NOT
112461: AND
112462: IFFALSE 112728
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112464: LD_VAR 0 4
112468: PUSH
112469: LD_VAR 0 7
112473: ARRAY
112474: PPUSH
112475: CALL_OW 262
112479: PUSH
112480: LD_INT 1
112482: PUSH
112483: LD_INT 2
112485: PUSH
112486: EMPTY
112487: LIST
112488: LIST
112489: IN
112490: IFFALSE 112531
// if GetFuel ( group [ i ] ) < 10 then
112492: LD_VAR 0 4
112496: PUSH
112497: LD_VAR 0 7
112501: ARRAY
112502: PPUSH
112503: CALL_OW 261
112507: PUSH
112508: LD_INT 10
112510: LESS
112511: IFFALSE 112531
// SetFuel ( group [ i ] , 12 ) ;
112513: LD_VAR 0 4
112517: PUSH
112518: LD_VAR 0 7
112522: ARRAY
112523: PPUSH
112524: LD_INT 12
112526: PPUSH
112527: CALL_OW 240
// if units_path [ i ] then
112531: LD_VAR 0 16
112535: PUSH
112536: LD_VAR 0 7
112540: ARRAY
112541: IFFALSE 112726
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112543: LD_VAR 0 4
112547: PUSH
112548: LD_VAR 0 7
112552: ARRAY
112553: PPUSH
112554: LD_VAR 0 16
112558: PUSH
112559: LD_VAR 0 7
112563: ARRAY
112564: PUSH
112565: LD_INT 1
112567: ARRAY
112568: PUSH
112569: LD_INT 1
112571: ARRAY
112572: PPUSH
112573: LD_VAR 0 16
112577: PUSH
112578: LD_VAR 0 7
112582: ARRAY
112583: PUSH
112584: LD_INT 1
112586: ARRAY
112587: PUSH
112588: LD_INT 2
112590: ARRAY
112591: PPUSH
112592: CALL_OW 297
112596: PUSH
112597: LD_INT 6
112599: GREATER
112600: IFFALSE 112675
// begin if not HasTask ( group [ i ] ) then
112602: LD_VAR 0 4
112606: PUSH
112607: LD_VAR 0 7
112611: ARRAY
112612: PPUSH
112613: CALL_OW 314
112617: NOT
112618: IFFALSE 112673
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112620: LD_VAR 0 4
112624: PUSH
112625: LD_VAR 0 7
112629: ARRAY
112630: PPUSH
112631: LD_VAR 0 16
112635: PUSH
112636: LD_VAR 0 7
112640: ARRAY
112641: PUSH
112642: LD_INT 1
112644: ARRAY
112645: PUSH
112646: LD_INT 1
112648: ARRAY
112649: PPUSH
112650: LD_VAR 0 16
112654: PUSH
112655: LD_VAR 0 7
112659: ARRAY
112660: PUSH
112661: LD_INT 1
112663: ARRAY
112664: PUSH
112665: LD_INT 2
112667: ARRAY
112668: PPUSH
112669: CALL_OW 114
// end else
112673: GO 112726
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112675: LD_ADDR_VAR 0 15
112679: PUSH
112680: LD_VAR 0 16
112684: PUSH
112685: LD_VAR 0 7
112689: ARRAY
112690: PPUSH
112691: LD_INT 1
112693: PPUSH
112694: CALL_OW 3
112698: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112699: LD_ADDR_VAR 0 16
112703: PUSH
112704: LD_VAR 0 16
112708: PPUSH
112709: LD_VAR 0 7
112713: PPUSH
112714: LD_VAR 0 15
112718: PPUSH
112719: CALL_OW 1
112723: ST_TO_ADDR
// continue ;
112724: GO 111269
// end ; end ; end else
112726: GO 115390
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112728: LD_ADDR_VAR 0 14
112732: PUSH
112733: LD_INT 81
112735: PUSH
112736: LD_VAR 0 4
112740: PUSH
112741: LD_VAR 0 7
112745: ARRAY
112746: PPUSH
112747: CALL_OW 255
112751: PUSH
112752: EMPTY
112753: LIST
112754: LIST
112755: PPUSH
112756: CALL_OW 69
112760: ST_TO_ADDR
// if not tmp then
112761: LD_VAR 0 14
112765: NOT
112766: IFFALSE 112770
// continue ;
112768: GO 111269
// if f_ignore_area then
112770: LD_VAR 0 17
112774: IFFALSE 112862
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112776: LD_ADDR_VAR 0 15
112780: PUSH
112781: LD_VAR 0 14
112785: PPUSH
112786: LD_INT 3
112788: PUSH
112789: LD_INT 92
112791: PUSH
112792: LD_VAR 0 17
112796: PUSH
112797: LD_INT 1
112799: ARRAY
112800: PUSH
112801: LD_VAR 0 17
112805: PUSH
112806: LD_INT 2
112808: ARRAY
112809: PUSH
112810: LD_VAR 0 17
112814: PUSH
112815: LD_INT 3
112817: ARRAY
112818: PUSH
112819: EMPTY
112820: LIST
112821: LIST
112822: LIST
112823: LIST
112824: PUSH
112825: EMPTY
112826: LIST
112827: LIST
112828: PPUSH
112829: CALL_OW 72
112833: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112834: LD_VAR 0 14
112838: PUSH
112839: LD_VAR 0 15
112843: DIFF
112844: IFFALSE 112862
// tmp := tmp diff tmp2 ;
112846: LD_ADDR_VAR 0 14
112850: PUSH
112851: LD_VAR 0 14
112855: PUSH
112856: LD_VAR 0 15
112860: DIFF
112861: ST_TO_ADDR
// end ; if not f_murder then
112862: LD_VAR 0 20
112866: NOT
112867: IFFALSE 112925
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112869: LD_ADDR_VAR 0 15
112873: PUSH
112874: LD_VAR 0 14
112878: PPUSH
112879: LD_INT 3
112881: PUSH
112882: LD_INT 50
112884: PUSH
112885: EMPTY
112886: LIST
112887: PUSH
112888: EMPTY
112889: LIST
112890: LIST
112891: PPUSH
112892: CALL_OW 72
112896: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112897: LD_VAR 0 14
112901: PUSH
112902: LD_VAR 0 15
112906: DIFF
112907: IFFALSE 112925
// tmp := tmp diff tmp2 ;
112909: LD_ADDR_VAR 0 14
112913: PUSH
112914: LD_VAR 0 14
112918: PUSH
112919: LD_VAR 0 15
112923: DIFF
112924: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112925: LD_ADDR_VAR 0 14
112929: PUSH
112930: LD_VAR 0 4
112934: PUSH
112935: LD_VAR 0 7
112939: ARRAY
112940: PPUSH
112941: LD_VAR 0 14
112945: PPUSH
112946: LD_INT 1
112948: PPUSH
112949: LD_INT 1
112951: PPUSH
112952: CALL 54502 0 4
112956: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112957: LD_VAR 0 4
112961: PUSH
112962: LD_VAR 0 7
112966: ARRAY
112967: PPUSH
112968: CALL_OW 257
112972: PUSH
112973: LD_INT 1
112975: EQUAL
112976: IFFALSE 113424
// begin if WantPlant ( group [ i ] ) then
112978: LD_VAR 0 4
112982: PUSH
112983: LD_VAR 0 7
112987: ARRAY
112988: PPUSH
112989: CALL 54003 0 1
112993: IFFALSE 112997
// continue ;
112995: GO 111269
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112997: LD_VAR 0 18
113001: PUSH
113002: LD_VAR 0 4
113006: PUSH
113007: LD_VAR 0 7
113011: ARRAY
113012: PPUSH
113013: CALL_OW 310
113017: NOT
113018: AND
113019: PUSH
113020: LD_VAR 0 14
113024: PUSH
113025: LD_INT 1
113027: ARRAY
113028: PUSH
113029: LD_VAR 0 14
113033: PPUSH
113034: LD_INT 21
113036: PUSH
113037: LD_INT 2
113039: PUSH
113040: EMPTY
113041: LIST
113042: LIST
113043: PUSH
113044: LD_INT 58
113046: PUSH
113047: EMPTY
113048: LIST
113049: PUSH
113050: EMPTY
113051: LIST
113052: LIST
113053: PPUSH
113054: CALL_OW 72
113058: IN
113059: AND
113060: IFFALSE 113096
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113062: LD_VAR 0 4
113066: PUSH
113067: LD_VAR 0 7
113071: ARRAY
113072: PPUSH
113073: LD_VAR 0 14
113077: PUSH
113078: LD_INT 1
113080: ARRAY
113081: PPUSH
113082: CALL_OW 120
// attacking := true ;
113086: LD_ADDR_VAR 0 29
113090: PUSH
113091: LD_INT 1
113093: ST_TO_ADDR
// continue ;
113094: GO 111269
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113096: LD_VAR 0 26
113100: PUSH
113101: LD_VAR 0 4
113105: PUSH
113106: LD_VAR 0 7
113110: ARRAY
113111: PPUSH
113112: CALL_OW 257
113116: PUSH
113117: LD_INT 1
113119: EQUAL
113120: AND
113121: PUSH
113122: LD_VAR 0 4
113126: PUSH
113127: LD_VAR 0 7
113131: ARRAY
113132: PPUSH
113133: CALL_OW 256
113137: PUSH
113138: LD_INT 800
113140: LESS
113141: AND
113142: PUSH
113143: LD_VAR 0 4
113147: PUSH
113148: LD_VAR 0 7
113152: ARRAY
113153: PPUSH
113154: CALL_OW 318
113158: NOT
113159: AND
113160: IFFALSE 113177
// ComCrawl ( group [ i ] ) ;
113162: LD_VAR 0 4
113166: PUSH
113167: LD_VAR 0 7
113171: ARRAY
113172: PPUSH
113173: CALL_OW 137
// if f_mines then
113177: LD_VAR 0 21
113181: IFFALSE 113424
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113183: LD_VAR 0 14
113187: PUSH
113188: LD_INT 1
113190: ARRAY
113191: PPUSH
113192: CALL_OW 247
113196: PUSH
113197: LD_INT 3
113199: EQUAL
113200: PUSH
113201: LD_VAR 0 14
113205: PUSH
113206: LD_INT 1
113208: ARRAY
113209: PUSH
113210: LD_VAR 0 27
113214: IN
113215: NOT
113216: AND
113217: IFFALSE 113424
// begin x := GetX ( tmp [ 1 ] ) ;
113219: LD_ADDR_VAR 0 10
113223: PUSH
113224: LD_VAR 0 14
113228: PUSH
113229: LD_INT 1
113231: ARRAY
113232: PPUSH
113233: CALL_OW 250
113237: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113238: LD_ADDR_VAR 0 11
113242: PUSH
113243: LD_VAR 0 14
113247: PUSH
113248: LD_INT 1
113250: ARRAY
113251: PPUSH
113252: CALL_OW 251
113256: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113257: LD_ADDR_VAR 0 12
113261: PUSH
113262: LD_VAR 0 4
113266: PUSH
113267: LD_VAR 0 7
113271: ARRAY
113272: PPUSH
113273: CALL 81675 0 1
113277: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113278: LD_VAR 0 4
113282: PUSH
113283: LD_VAR 0 7
113287: ARRAY
113288: PPUSH
113289: LD_VAR 0 10
113293: PPUSH
113294: LD_VAR 0 11
113298: PPUSH
113299: LD_VAR 0 14
113303: PUSH
113304: LD_INT 1
113306: ARRAY
113307: PPUSH
113308: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113312: LD_VAR 0 4
113316: PUSH
113317: LD_VAR 0 7
113321: ARRAY
113322: PPUSH
113323: LD_VAR 0 10
113327: PPUSH
113328: LD_VAR 0 12
113332: PPUSH
113333: LD_INT 7
113335: PPUSH
113336: CALL_OW 272
113340: PPUSH
113341: LD_VAR 0 11
113345: PPUSH
113346: LD_VAR 0 12
113350: PPUSH
113351: LD_INT 7
113353: PPUSH
113354: CALL_OW 273
113358: PPUSH
113359: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113363: LD_VAR 0 4
113367: PUSH
113368: LD_VAR 0 7
113372: ARRAY
113373: PPUSH
113374: LD_INT 71
113376: PPUSH
113377: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113381: LD_ADDR_VAR 0 27
113385: PUSH
113386: LD_VAR 0 27
113390: PPUSH
113391: LD_VAR 0 27
113395: PUSH
113396: LD_INT 1
113398: PLUS
113399: PPUSH
113400: LD_VAR 0 14
113404: PUSH
113405: LD_INT 1
113407: ARRAY
113408: PPUSH
113409: CALL_OW 1
113413: ST_TO_ADDR
// attacking := true ;
113414: LD_ADDR_VAR 0 29
113418: PUSH
113419: LD_INT 1
113421: ST_TO_ADDR
// continue ;
113422: GO 111269
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113424: LD_VAR 0 4
113428: PUSH
113429: LD_VAR 0 7
113433: ARRAY
113434: PPUSH
113435: CALL_OW 257
113439: PUSH
113440: LD_INT 17
113442: EQUAL
113443: PUSH
113444: LD_VAR 0 4
113448: PUSH
113449: LD_VAR 0 7
113453: ARRAY
113454: PPUSH
113455: CALL_OW 110
113459: PUSH
113460: LD_INT 71
113462: EQUAL
113463: NOT
113464: AND
113465: IFFALSE 113611
// begin attacking := false ;
113467: LD_ADDR_VAR 0 29
113471: PUSH
113472: LD_INT 0
113474: ST_TO_ADDR
// k := 5 ;
113475: LD_ADDR_VAR 0 9
113479: PUSH
113480: LD_INT 5
113482: ST_TO_ADDR
// if tmp < k then
113483: LD_VAR 0 14
113487: PUSH
113488: LD_VAR 0 9
113492: LESS
113493: IFFALSE 113505
// k := tmp ;
113495: LD_ADDR_VAR 0 9
113499: PUSH
113500: LD_VAR 0 14
113504: ST_TO_ADDR
// for j = 1 to k do
113505: LD_ADDR_VAR 0 8
113509: PUSH
113510: DOUBLE
113511: LD_INT 1
113513: DEC
113514: ST_TO_ADDR
113515: LD_VAR 0 9
113519: PUSH
113520: FOR_TO
113521: IFFALSE 113609
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113523: LD_VAR 0 14
113527: PUSH
113528: LD_VAR 0 8
113532: ARRAY
113533: PUSH
113534: LD_VAR 0 14
113538: PPUSH
113539: LD_INT 58
113541: PUSH
113542: EMPTY
113543: LIST
113544: PPUSH
113545: CALL_OW 72
113549: IN
113550: NOT
113551: IFFALSE 113607
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113553: LD_VAR 0 4
113557: PUSH
113558: LD_VAR 0 7
113562: ARRAY
113563: PPUSH
113564: LD_VAR 0 14
113568: PUSH
113569: LD_VAR 0 8
113573: ARRAY
113574: PPUSH
113575: CALL_OW 115
// attacking := true ;
113579: LD_ADDR_VAR 0 29
113583: PUSH
113584: LD_INT 1
113586: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113587: LD_VAR 0 4
113591: PUSH
113592: LD_VAR 0 7
113596: ARRAY
113597: PPUSH
113598: LD_INT 71
113600: PPUSH
113601: CALL_OW 109
// continue ;
113605: GO 113520
// end ; end ;
113607: GO 113520
113609: POP
113610: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113611: LD_VAR 0 4
113615: PUSH
113616: LD_VAR 0 7
113620: ARRAY
113621: PPUSH
113622: CALL_OW 257
113626: PUSH
113627: LD_INT 8
113629: EQUAL
113630: PUSH
113631: LD_VAR 0 4
113635: PUSH
113636: LD_VAR 0 7
113640: ARRAY
113641: PPUSH
113642: CALL_OW 264
113646: PUSH
113647: LD_INT 28
113649: PUSH
113650: LD_INT 45
113652: PUSH
113653: LD_INT 7
113655: PUSH
113656: LD_INT 47
113658: PUSH
113659: EMPTY
113660: LIST
113661: LIST
113662: LIST
113663: LIST
113664: IN
113665: OR
113666: IFFALSE 113922
// begin attacking := false ;
113668: LD_ADDR_VAR 0 29
113672: PUSH
113673: LD_INT 0
113675: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113676: LD_VAR 0 14
113680: PUSH
113681: LD_INT 1
113683: ARRAY
113684: PPUSH
113685: CALL_OW 266
113689: PUSH
113690: LD_INT 32
113692: PUSH
113693: LD_INT 31
113695: PUSH
113696: LD_INT 33
113698: PUSH
113699: LD_INT 4
113701: PUSH
113702: LD_INT 5
113704: PUSH
113705: EMPTY
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: IN
113712: IFFALSE 113898
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113714: LD_ADDR_VAR 0 9
113718: PUSH
113719: LD_VAR 0 14
113723: PUSH
113724: LD_INT 1
113726: ARRAY
113727: PPUSH
113728: CALL_OW 266
113732: PPUSH
113733: LD_VAR 0 14
113737: PUSH
113738: LD_INT 1
113740: ARRAY
113741: PPUSH
113742: CALL_OW 250
113746: PPUSH
113747: LD_VAR 0 14
113751: PUSH
113752: LD_INT 1
113754: ARRAY
113755: PPUSH
113756: CALL_OW 251
113760: PPUSH
113761: LD_VAR 0 14
113765: PUSH
113766: LD_INT 1
113768: ARRAY
113769: PPUSH
113770: CALL_OW 254
113774: PPUSH
113775: LD_VAR 0 14
113779: PUSH
113780: LD_INT 1
113782: ARRAY
113783: PPUSH
113784: CALL_OW 248
113788: PPUSH
113789: LD_INT 0
113791: PPUSH
113792: CALL 63045 0 6
113796: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113797: LD_ADDR_VAR 0 8
113801: PUSH
113802: LD_VAR 0 4
113806: PUSH
113807: LD_VAR 0 7
113811: ARRAY
113812: PPUSH
113813: LD_VAR 0 9
113817: PPUSH
113818: CALL 81788 0 2
113822: ST_TO_ADDR
// if j then
113823: LD_VAR 0 8
113827: IFFALSE 113896
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113829: LD_VAR 0 8
113833: PUSH
113834: LD_INT 1
113836: ARRAY
113837: PPUSH
113838: LD_VAR 0 8
113842: PUSH
113843: LD_INT 2
113845: ARRAY
113846: PPUSH
113847: CALL_OW 488
113851: IFFALSE 113896
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113853: LD_VAR 0 4
113857: PUSH
113858: LD_VAR 0 7
113862: ARRAY
113863: PPUSH
113864: LD_VAR 0 8
113868: PUSH
113869: LD_INT 1
113871: ARRAY
113872: PPUSH
113873: LD_VAR 0 8
113877: PUSH
113878: LD_INT 2
113880: ARRAY
113881: PPUSH
113882: CALL_OW 116
// attacking := true ;
113886: LD_ADDR_VAR 0 29
113890: PUSH
113891: LD_INT 1
113893: ST_TO_ADDR
// continue ;
113894: GO 111269
// end ; end else
113896: GO 113922
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113898: LD_VAR 0 4
113902: PUSH
113903: LD_VAR 0 7
113907: ARRAY
113908: PPUSH
113909: LD_VAR 0 14
113913: PUSH
113914: LD_INT 1
113916: ARRAY
113917: PPUSH
113918: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113922: LD_VAR 0 4
113926: PUSH
113927: LD_VAR 0 7
113931: ARRAY
113932: PPUSH
113933: CALL_OW 265
113937: PUSH
113938: LD_INT 11
113940: EQUAL
113941: IFFALSE 114219
// begin k := 10 ;
113943: LD_ADDR_VAR 0 9
113947: PUSH
113948: LD_INT 10
113950: ST_TO_ADDR
// x := 0 ;
113951: LD_ADDR_VAR 0 10
113955: PUSH
113956: LD_INT 0
113958: ST_TO_ADDR
// if tmp < k then
113959: LD_VAR 0 14
113963: PUSH
113964: LD_VAR 0 9
113968: LESS
113969: IFFALSE 113981
// k := tmp ;
113971: LD_ADDR_VAR 0 9
113975: PUSH
113976: LD_VAR 0 14
113980: ST_TO_ADDR
// for j = k downto 1 do
113981: LD_ADDR_VAR 0 8
113985: PUSH
113986: DOUBLE
113987: LD_VAR 0 9
113991: INC
113992: ST_TO_ADDR
113993: LD_INT 1
113995: PUSH
113996: FOR_DOWNTO
113997: IFFALSE 114072
// begin if GetType ( tmp [ j ] ) = unit_human then
113999: LD_VAR 0 14
114003: PUSH
114004: LD_VAR 0 8
114008: ARRAY
114009: PPUSH
114010: CALL_OW 247
114014: PUSH
114015: LD_INT 1
114017: EQUAL
114018: IFFALSE 114070
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114020: LD_VAR 0 4
114024: PUSH
114025: LD_VAR 0 7
114029: ARRAY
114030: PPUSH
114031: LD_VAR 0 14
114035: PUSH
114036: LD_VAR 0 8
114040: ARRAY
114041: PPUSH
114042: CALL 82042 0 2
// x := tmp [ j ] ;
114046: LD_ADDR_VAR 0 10
114050: PUSH
114051: LD_VAR 0 14
114055: PUSH
114056: LD_VAR 0 8
114060: ARRAY
114061: ST_TO_ADDR
// attacking := true ;
114062: LD_ADDR_VAR 0 29
114066: PUSH
114067: LD_INT 1
114069: ST_TO_ADDR
// end ; end ;
114070: GO 113996
114072: POP
114073: POP
// if not x then
114074: LD_VAR 0 10
114078: NOT
114079: IFFALSE 114219
// begin attacking := true ;
114081: LD_ADDR_VAR 0 29
114085: PUSH
114086: LD_INT 1
114088: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114089: LD_VAR 0 4
114093: PUSH
114094: LD_VAR 0 7
114098: ARRAY
114099: PPUSH
114100: CALL_OW 250
114104: PPUSH
114105: LD_VAR 0 4
114109: PUSH
114110: LD_VAR 0 7
114114: ARRAY
114115: PPUSH
114116: CALL_OW 251
114120: PPUSH
114121: CALL_OW 546
114125: PUSH
114126: LD_INT 2
114128: ARRAY
114129: PUSH
114130: LD_VAR 0 14
114134: PUSH
114135: LD_INT 1
114137: ARRAY
114138: PPUSH
114139: CALL_OW 250
114143: PPUSH
114144: LD_VAR 0 14
114148: PUSH
114149: LD_INT 1
114151: ARRAY
114152: PPUSH
114153: CALL_OW 251
114157: PPUSH
114158: CALL_OW 546
114162: PUSH
114163: LD_INT 2
114165: ARRAY
114166: EQUAL
114167: IFFALSE 114195
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114169: LD_VAR 0 4
114173: PUSH
114174: LD_VAR 0 7
114178: ARRAY
114179: PPUSH
114180: LD_VAR 0 14
114184: PUSH
114185: LD_INT 1
114187: ARRAY
114188: PPUSH
114189: CALL 82042 0 2
114193: GO 114219
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114195: LD_VAR 0 4
114199: PUSH
114200: LD_VAR 0 7
114204: ARRAY
114205: PPUSH
114206: LD_VAR 0 14
114210: PUSH
114211: LD_INT 1
114213: ARRAY
114214: PPUSH
114215: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114219: LD_VAR 0 4
114223: PUSH
114224: LD_VAR 0 7
114228: ARRAY
114229: PPUSH
114230: CALL_OW 264
114234: PUSH
114235: LD_INT 29
114237: EQUAL
114238: IFFALSE 114604
// begin if WantsToAttack ( group [ i ] ) in bombed then
114240: LD_VAR 0 4
114244: PUSH
114245: LD_VAR 0 7
114249: ARRAY
114250: PPUSH
114251: CALL_OW 319
114255: PUSH
114256: LD_VAR 0 28
114260: IN
114261: IFFALSE 114265
// continue ;
114263: GO 111269
// k := 8 ;
114265: LD_ADDR_VAR 0 9
114269: PUSH
114270: LD_INT 8
114272: ST_TO_ADDR
// x := 0 ;
114273: LD_ADDR_VAR 0 10
114277: PUSH
114278: LD_INT 0
114280: ST_TO_ADDR
// if tmp < k then
114281: LD_VAR 0 14
114285: PUSH
114286: LD_VAR 0 9
114290: LESS
114291: IFFALSE 114303
// k := tmp ;
114293: LD_ADDR_VAR 0 9
114297: PUSH
114298: LD_VAR 0 14
114302: ST_TO_ADDR
// for j = 1 to k do
114303: LD_ADDR_VAR 0 8
114307: PUSH
114308: DOUBLE
114309: LD_INT 1
114311: DEC
114312: ST_TO_ADDR
114313: LD_VAR 0 9
114317: PUSH
114318: FOR_TO
114319: IFFALSE 114451
// begin if GetType ( tmp [ j ] ) = unit_building then
114321: LD_VAR 0 14
114325: PUSH
114326: LD_VAR 0 8
114330: ARRAY
114331: PPUSH
114332: CALL_OW 247
114336: PUSH
114337: LD_INT 3
114339: EQUAL
114340: IFFALSE 114449
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114342: LD_VAR 0 14
114346: PUSH
114347: LD_VAR 0 8
114351: ARRAY
114352: PUSH
114353: LD_VAR 0 28
114357: IN
114358: NOT
114359: PUSH
114360: LD_VAR 0 14
114364: PUSH
114365: LD_VAR 0 8
114369: ARRAY
114370: PPUSH
114371: CALL_OW 313
114375: AND
114376: IFFALSE 114449
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114378: LD_VAR 0 4
114382: PUSH
114383: LD_VAR 0 7
114387: ARRAY
114388: PPUSH
114389: LD_VAR 0 14
114393: PUSH
114394: LD_VAR 0 8
114398: ARRAY
114399: PPUSH
114400: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114404: LD_ADDR_VAR 0 28
114408: PUSH
114409: LD_VAR 0 28
114413: PPUSH
114414: LD_VAR 0 28
114418: PUSH
114419: LD_INT 1
114421: PLUS
114422: PPUSH
114423: LD_VAR 0 14
114427: PUSH
114428: LD_VAR 0 8
114432: ARRAY
114433: PPUSH
114434: CALL_OW 1
114438: ST_TO_ADDR
// attacking := true ;
114439: LD_ADDR_VAR 0 29
114443: PUSH
114444: LD_INT 1
114446: ST_TO_ADDR
// break ;
114447: GO 114451
// end ; end ;
114449: GO 114318
114451: POP
114452: POP
// if not attacking and f_attack_depot then
114453: LD_VAR 0 29
114457: NOT
114458: PUSH
114459: LD_VAR 0 25
114463: AND
114464: IFFALSE 114559
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114466: LD_ADDR_VAR 0 13
114470: PUSH
114471: LD_VAR 0 14
114475: PPUSH
114476: LD_INT 2
114478: PUSH
114479: LD_INT 30
114481: PUSH
114482: LD_INT 0
114484: PUSH
114485: EMPTY
114486: LIST
114487: LIST
114488: PUSH
114489: LD_INT 30
114491: PUSH
114492: LD_INT 1
114494: PUSH
114495: EMPTY
114496: LIST
114497: LIST
114498: PUSH
114499: EMPTY
114500: LIST
114501: LIST
114502: LIST
114503: PPUSH
114504: CALL_OW 72
114508: ST_TO_ADDR
// if z then
114509: LD_VAR 0 13
114513: IFFALSE 114559
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114515: LD_VAR 0 4
114519: PUSH
114520: LD_VAR 0 7
114524: ARRAY
114525: PPUSH
114526: LD_VAR 0 13
114530: PPUSH
114531: LD_VAR 0 4
114535: PUSH
114536: LD_VAR 0 7
114540: ARRAY
114541: PPUSH
114542: CALL_OW 74
114546: PPUSH
114547: CALL_OW 115
// attacking := true ;
114551: LD_ADDR_VAR 0 29
114555: PUSH
114556: LD_INT 1
114558: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114559: LD_VAR 0 4
114563: PUSH
114564: LD_VAR 0 7
114568: ARRAY
114569: PPUSH
114570: CALL_OW 256
114574: PUSH
114575: LD_INT 500
114577: LESS
114578: IFFALSE 114604
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114580: LD_VAR 0 4
114584: PUSH
114585: LD_VAR 0 7
114589: ARRAY
114590: PPUSH
114591: LD_VAR 0 14
114595: PUSH
114596: LD_INT 1
114598: ARRAY
114599: PPUSH
114600: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114604: LD_VAR 0 4
114608: PUSH
114609: LD_VAR 0 7
114613: ARRAY
114614: PPUSH
114615: CALL_OW 264
114619: PUSH
114620: LD_INT 49
114622: EQUAL
114623: IFFALSE 114744
// begin if not HasTask ( group [ i ] ) then
114625: LD_VAR 0 4
114629: PUSH
114630: LD_VAR 0 7
114634: ARRAY
114635: PPUSH
114636: CALL_OW 314
114640: NOT
114641: IFFALSE 114744
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114643: LD_ADDR_VAR 0 9
114647: PUSH
114648: LD_INT 81
114650: PUSH
114651: LD_VAR 0 4
114655: PUSH
114656: LD_VAR 0 7
114660: ARRAY
114661: PPUSH
114662: CALL_OW 255
114666: PUSH
114667: EMPTY
114668: LIST
114669: LIST
114670: PPUSH
114671: CALL_OW 69
114675: PPUSH
114676: LD_VAR 0 4
114680: PUSH
114681: LD_VAR 0 7
114685: ARRAY
114686: PPUSH
114687: CALL_OW 74
114691: ST_TO_ADDR
// if k then
114692: LD_VAR 0 9
114696: IFFALSE 114744
// if GetDistUnits ( group [ i ] , k ) > 10 then
114698: LD_VAR 0 4
114702: PUSH
114703: LD_VAR 0 7
114707: ARRAY
114708: PPUSH
114709: LD_VAR 0 9
114713: PPUSH
114714: CALL_OW 296
114718: PUSH
114719: LD_INT 10
114721: GREATER
114722: IFFALSE 114744
// ComMoveUnit ( group [ i ] , k ) ;
114724: LD_VAR 0 4
114728: PUSH
114729: LD_VAR 0 7
114733: ARRAY
114734: PPUSH
114735: LD_VAR 0 9
114739: PPUSH
114740: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114744: LD_VAR 0 4
114748: PUSH
114749: LD_VAR 0 7
114753: ARRAY
114754: PPUSH
114755: CALL_OW 256
114759: PUSH
114760: LD_INT 250
114762: LESS
114763: PUSH
114764: LD_VAR 0 4
114768: PUSH
114769: LD_VAR 0 7
114773: ARRAY
114774: PUSH
114775: LD_INT 21
114777: PUSH
114778: LD_INT 2
114780: PUSH
114781: EMPTY
114782: LIST
114783: LIST
114784: PUSH
114785: LD_INT 23
114787: PUSH
114788: LD_INT 2
114790: PUSH
114791: EMPTY
114792: LIST
114793: LIST
114794: PUSH
114795: EMPTY
114796: LIST
114797: LIST
114798: PPUSH
114799: CALL_OW 69
114803: IN
114804: AND
114805: IFFALSE 114930
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114807: LD_ADDR_VAR 0 9
114811: PUSH
114812: LD_OWVAR 3
114816: PUSH
114817: LD_VAR 0 4
114821: PUSH
114822: LD_VAR 0 7
114826: ARRAY
114827: DIFF
114828: PPUSH
114829: LD_VAR 0 4
114833: PUSH
114834: LD_VAR 0 7
114838: ARRAY
114839: PPUSH
114840: CALL_OW 74
114844: ST_TO_ADDR
// if not k then
114845: LD_VAR 0 9
114849: NOT
114850: IFFALSE 114854
// continue ;
114852: GO 111269
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114854: LD_VAR 0 9
114858: PUSH
114859: LD_INT 81
114861: PUSH
114862: LD_VAR 0 4
114866: PUSH
114867: LD_VAR 0 7
114871: ARRAY
114872: PPUSH
114873: CALL_OW 255
114877: PUSH
114878: EMPTY
114879: LIST
114880: LIST
114881: PPUSH
114882: CALL_OW 69
114886: IN
114887: PUSH
114888: LD_VAR 0 9
114892: PPUSH
114893: LD_VAR 0 4
114897: PUSH
114898: LD_VAR 0 7
114902: ARRAY
114903: PPUSH
114904: CALL_OW 296
114908: PUSH
114909: LD_INT 5
114911: LESS
114912: AND
114913: IFFALSE 114930
// ComAutodestruct ( group [ i ] ) ;
114915: LD_VAR 0 4
114919: PUSH
114920: LD_VAR 0 7
114924: ARRAY
114925: PPUSH
114926: CALL 81940 0 1
// end ; if f_attack_depot then
114930: LD_VAR 0 25
114934: IFFALSE 115046
// begin k := 6 ;
114936: LD_ADDR_VAR 0 9
114940: PUSH
114941: LD_INT 6
114943: ST_TO_ADDR
// if tmp < k then
114944: LD_VAR 0 14
114948: PUSH
114949: LD_VAR 0 9
114953: LESS
114954: IFFALSE 114966
// k := tmp ;
114956: LD_ADDR_VAR 0 9
114960: PUSH
114961: LD_VAR 0 14
114965: ST_TO_ADDR
// for j = 1 to k do
114966: LD_ADDR_VAR 0 8
114970: PUSH
114971: DOUBLE
114972: LD_INT 1
114974: DEC
114975: ST_TO_ADDR
114976: LD_VAR 0 9
114980: PUSH
114981: FOR_TO
114982: IFFALSE 115044
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114984: LD_VAR 0 8
114988: PPUSH
114989: CALL_OW 266
114993: PUSH
114994: LD_INT 0
114996: PUSH
114997: LD_INT 1
114999: PUSH
115000: EMPTY
115001: LIST
115002: LIST
115003: IN
115004: IFFALSE 115042
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115006: LD_VAR 0 4
115010: PUSH
115011: LD_VAR 0 7
115015: ARRAY
115016: PPUSH
115017: LD_VAR 0 14
115021: PUSH
115022: LD_VAR 0 8
115026: ARRAY
115027: PPUSH
115028: CALL_OW 115
// attacking := true ;
115032: LD_ADDR_VAR 0 29
115036: PUSH
115037: LD_INT 1
115039: ST_TO_ADDR
// break ;
115040: GO 115044
// end ;
115042: GO 114981
115044: POP
115045: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115046: LD_VAR 0 4
115050: PUSH
115051: LD_VAR 0 7
115055: ARRAY
115056: PPUSH
115057: CALL_OW 302
115061: PUSH
115062: LD_VAR 0 29
115066: NOT
115067: AND
115068: IFFALSE 115390
// begin if GetTag ( group [ i ] ) = 71 then
115070: LD_VAR 0 4
115074: PUSH
115075: LD_VAR 0 7
115079: ARRAY
115080: PPUSH
115081: CALL_OW 110
115085: PUSH
115086: LD_INT 71
115088: EQUAL
115089: IFFALSE 115130
// begin if HasTask ( group [ i ] ) then
115091: LD_VAR 0 4
115095: PUSH
115096: LD_VAR 0 7
115100: ARRAY
115101: PPUSH
115102: CALL_OW 314
115106: IFFALSE 115112
// continue else
115108: GO 111269
115110: GO 115130
// SetTag ( group [ i ] , 0 ) ;
115112: LD_VAR 0 4
115116: PUSH
115117: LD_VAR 0 7
115121: ARRAY
115122: PPUSH
115123: LD_INT 0
115125: PPUSH
115126: CALL_OW 109
// end ; k := 8 ;
115130: LD_ADDR_VAR 0 9
115134: PUSH
115135: LD_INT 8
115137: ST_TO_ADDR
// x := 0 ;
115138: LD_ADDR_VAR 0 10
115142: PUSH
115143: LD_INT 0
115145: ST_TO_ADDR
// if tmp < k then
115146: LD_VAR 0 14
115150: PUSH
115151: LD_VAR 0 9
115155: LESS
115156: IFFALSE 115168
// k := tmp ;
115158: LD_ADDR_VAR 0 9
115162: PUSH
115163: LD_VAR 0 14
115167: ST_TO_ADDR
// for j = 1 to k do
115168: LD_ADDR_VAR 0 8
115172: PUSH
115173: DOUBLE
115174: LD_INT 1
115176: DEC
115177: ST_TO_ADDR
115178: LD_VAR 0 9
115182: PUSH
115183: FOR_TO
115184: IFFALSE 115282
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115186: LD_VAR 0 14
115190: PUSH
115191: LD_VAR 0 8
115195: ARRAY
115196: PPUSH
115197: CALL_OW 247
115201: PUSH
115202: LD_INT 1
115204: EQUAL
115205: PUSH
115206: LD_VAR 0 14
115210: PUSH
115211: LD_VAR 0 8
115215: ARRAY
115216: PPUSH
115217: CALL_OW 256
115221: PUSH
115222: LD_INT 250
115224: LESS
115225: PUSH
115226: LD_VAR 0 20
115230: AND
115231: PUSH
115232: LD_VAR 0 20
115236: NOT
115237: PUSH
115238: LD_VAR 0 14
115242: PUSH
115243: LD_VAR 0 8
115247: ARRAY
115248: PPUSH
115249: CALL_OW 256
115253: PUSH
115254: LD_INT 250
115256: GREATEREQUAL
115257: AND
115258: OR
115259: AND
115260: IFFALSE 115280
// begin x := tmp [ j ] ;
115262: LD_ADDR_VAR 0 10
115266: PUSH
115267: LD_VAR 0 14
115271: PUSH
115272: LD_VAR 0 8
115276: ARRAY
115277: ST_TO_ADDR
// break ;
115278: GO 115282
// end ;
115280: GO 115183
115282: POP
115283: POP
// if x then
115284: LD_VAR 0 10
115288: IFFALSE 115312
// ComAttackUnit ( group [ i ] , x ) else
115290: LD_VAR 0 4
115294: PUSH
115295: LD_VAR 0 7
115299: ARRAY
115300: PPUSH
115301: LD_VAR 0 10
115305: PPUSH
115306: CALL_OW 115
115310: GO 115336
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115312: LD_VAR 0 4
115316: PUSH
115317: LD_VAR 0 7
115321: ARRAY
115322: PPUSH
115323: LD_VAR 0 14
115327: PUSH
115328: LD_INT 1
115330: ARRAY
115331: PPUSH
115332: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115336: LD_VAR 0 4
115340: PUSH
115341: LD_VAR 0 7
115345: ARRAY
115346: PPUSH
115347: CALL_OW 314
115351: NOT
115352: IFFALSE 115390
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115354: LD_VAR 0 4
115358: PUSH
115359: LD_VAR 0 7
115363: ARRAY
115364: PPUSH
115365: LD_VAR 0 14
115369: PPUSH
115370: LD_VAR 0 4
115374: PUSH
115375: LD_VAR 0 7
115379: ARRAY
115380: PPUSH
115381: CALL_OW 74
115385: PPUSH
115386: CALL_OW 115
// end ; end ; end ;
115390: GO 111269
115392: POP
115393: POP
// wait ( 0 0$2 ) ;
115394: LD_INT 70
115396: PPUSH
115397: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115401: LD_VAR 0 4
115405: NOT
115406: PUSH
115407: LD_VAR 0 4
115411: PUSH
115412: EMPTY
115413: EQUAL
115414: OR
115415: PUSH
115416: LD_INT 81
115418: PUSH
115419: LD_VAR 0 35
115423: PUSH
115424: EMPTY
115425: LIST
115426: LIST
115427: PPUSH
115428: CALL_OW 69
115432: NOT
115433: OR
115434: IFFALSE 111254
// end ;
115436: LD_VAR 0 2
115440: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115441: LD_INT 0
115443: PPUSH
115444: PPUSH
115445: PPUSH
115446: PPUSH
115447: PPUSH
115448: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115449: LD_VAR 0 1
115453: NOT
115454: PUSH
115455: LD_EXP 50
115459: PUSH
115460: LD_VAR 0 1
115464: ARRAY
115465: NOT
115466: OR
115467: PUSH
115468: LD_VAR 0 2
115472: NOT
115473: OR
115474: IFFALSE 115478
// exit ;
115476: GO 116032
// side := mc_sides [ base ] ;
115478: LD_ADDR_VAR 0 6
115482: PUSH
115483: LD_EXP 76
115487: PUSH
115488: LD_VAR 0 1
115492: ARRAY
115493: ST_TO_ADDR
// if not side then
115494: LD_VAR 0 6
115498: NOT
115499: IFFALSE 115503
// exit ;
115501: GO 116032
// for i in solds do
115503: LD_ADDR_VAR 0 7
115507: PUSH
115508: LD_VAR 0 2
115512: PUSH
115513: FOR_IN
115514: IFFALSE 115575
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115516: LD_VAR 0 7
115520: PPUSH
115521: CALL_OW 310
115525: PPUSH
115526: CALL_OW 266
115530: PUSH
115531: LD_INT 32
115533: PUSH
115534: LD_INT 31
115536: PUSH
115537: EMPTY
115538: LIST
115539: LIST
115540: IN
115541: IFFALSE 115561
// solds := solds diff i else
115543: LD_ADDR_VAR 0 2
115547: PUSH
115548: LD_VAR 0 2
115552: PUSH
115553: LD_VAR 0 7
115557: DIFF
115558: ST_TO_ADDR
115559: GO 115573
// SetTag ( i , 18 ) ;
115561: LD_VAR 0 7
115565: PPUSH
115566: LD_INT 18
115568: PPUSH
115569: CALL_OW 109
115573: GO 115513
115575: POP
115576: POP
// if not solds then
115577: LD_VAR 0 2
115581: NOT
115582: IFFALSE 115586
// exit ;
115584: GO 116032
// repeat wait ( 0 0$2 ) ;
115586: LD_INT 70
115588: PPUSH
115589: CALL_OW 67
// enemy := mc_scan [ base ] ;
115593: LD_ADDR_VAR 0 4
115597: PUSH
115598: LD_EXP 73
115602: PUSH
115603: LD_VAR 0 1
115607: ARRAY
115608: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115609: LD_EXP 50
115613: PUSH
115614: LD_VAR 0 1
115618: ARRAY
115619: NOT
115620: PUSH
115621: LD_EXP 50
115625: PUSH
115626: LD_VAR 0 1
115630: ARRAY
115631: PUSH
115632: EMPTY
115633: EQUAL
115634: OR
115635: IFFALSE 115672
// begin for i in solds do
115637: LD_ADDR_VAR 0 7
115641: PUSH
115642: LD_VAR 0 2
115646: PUSH
115647: FOR_IN
115648: IFFALSE 115661
// ComStop ( i ) ;
115650: LD_VAR 0 7
115654: PPUSH
115655: CALL_OW 141
115659: GO 115647
115661: POP
115662: POP
// solds := [ ] ;
115663: LD_ADDR_VAR 0 2
115667: PUSH
115668: EMPTY
115669: ST_TO_ADDR
// exit ;
115670: GO 116032
// end ; for i in solds do
115672: LD_ADDR_VAR 0 7
115676: PUSH
115677: LD_VAR 0 2
115681: PUSH
115682: FOR_IN
115683: IFFALSE 116004
// begin if IsInUnit ( i ) then
115685: LD_VAR 0 7
115689: PPUSH
115690: CALL_OW 310
115694: IFFALSE 115705
// ComExitBuilding ( i ) ;
115696: LD_VAR 0 7
115700: PPUSH
115701: CALL_OW 122
// if GetLives ( i ) > 500 then
115705: LD_VAR 0 7
115709: PPUSH
115710: CALL_OW 256
115714: PUSH
115715: LD_INT 500
115717: GREATER
115718: IFFALSE 115771
// begin e := NearestUnitToUnit ( enemy , i ) ;
115720: LD_ADDR_VAR 0 5
115724: PUSH
115725: LD_VAR 0 4
115729: PPUSH
115730: LD_VAR 0 7
115734: PPUSH
115735: CALL_OW 74
115739: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115740: LD_VAR 0 7
115744: PPUSH
115745: LD_VAR 0 5
115749: PPUSH
115750: CALL_OW 250
115754: PPUSH
115755: LD_VAR 0 5
115759: PPUSH
115760: CALL_OW 251
115764: PPUSH
115765: CALL_OW 114
// end else
115769: GO 116002
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115771: LD_VAR 0 7
115775: PPUSH
115776: LD_EXP 50
115780: PUSH
115781: LD_VAR 0 1
115785: ARRAY
115786: PPUSH
115787: LD_INT 2
115789: PUSH
115790: LD_INT 30
115792: PUSH
115793: LD_INT 0
115795: PUSH
115796: EMPTY
115797: LIST
115798: LIST
115799: PUSH
115800: LD_INT 30
115802: PUSH
115803: LD_INT 1
115805: PUSH
115806: EMPTY
115807: LIST
115808: LIST
115809: PUSH
115810: LD_INT 30
115812: PUSH
115813: LD_INT 6
115815: PUSH
115816: EMPTY
115817: LIST
115818: LIST
115819: PUSH
115820: EMPTY
115821: LIST
115822: LIST
115823: LIST
115824: LIST
115825: PPUSH
115826: CALL_OW 72
115830: PPUSH
115831: LD_VAR 0 7
115835: PPUSH
115836: CALL_OW 74
115840: PPUSH
115841: CALL_OW 296
115845: PUSH
115846: LD_INT 10
115848: GREATER
115849: IFFALSE 116002
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115851: LD_ADDR_VAR 0 8
115855: PUSH
115856: LD_EXP 50
115860: PUSH
115861: LD_VAR 0 1
115865: ARRAY
115866: PPUSH
115867: LD_INT 2
115869: PUSH
115870: LD_INT 30
115872: PUSH
115873: LD_INT 0
115875: PUSH
115876: EMPTY
115877: LIST
115878: LIST
115879: PUSH
115880: LD_INT 30
115882: PUSH
115883: LD_INT 1
115885: PUSH
115886: EMPTY
115887: LIST
115888: LIST
115889: PUSH
115890: LD_INT 30
115892: PUSH
115893: LD_INT 6
115895: PUSH
115896: EMPTY
115897: LIST
115898: LIST
115899: PUSH
115900: EMPTY
115901: LIST
115902: LIST
115903: LIST
115904: LIST
115905: PPUSH
115906: CALL_OW 72
115910: PPUSH
115911: LD_VAR 0 7
115915: PPUSH
115916: CALL_OW 74
115920: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115921: LD_VAR 0 7
115925: PPUSH
115926: LD_VAR 0 8
115930: PPUSH
115931: CALL_OW 250
115935: PPUSH
115936: LD_INT 3
115938: PPUSH
115939: LD_INT 5
115941: PPUSH
115942: CALL_OW 272
115946: PPUSH
115947: LD_VAR 0 8
115951: PPUSH
115952: CALL_OW 251
115956: PPUSH
115957: LD_INT 3
115959: PPUSH
115960: LD_INT 5
115962: PPUSH
115963: CALL_OW 273
115967: PPUSH
115968: CALL_OW 111
// SetTag ( i , 0 ) ;
115972: LD_VAR 0 7
115976: PPUSH
115977: LD_INT 0
115979: PPUSH
115980: CALL_OW 109
// solds := solds diff i ;
115984: LD_ADDR_VAR 0 2
115988: PUSH
115989: LD_VAR 0 2
115993: PUSH
115994: LD_VAR 0 7
115998: DIFF
115999: ST_TO_ADDR
// continue ;
116000: GO 115682
// end ; end ;
116002: GO 115682
116004: POP
116005: POP
// until not solds or not enemy ;
116006: LD_VAR 0 2
116010: NOT
116011: PUSH
116012: LD_VAR 0 4
116016: NOT
116017: OR
116018: IFFALSE 115586
// MC_Reset ( base , 18 ) ;
116020: LD_VAR 0 1
116024: PPUSH
116025: LD_INT 18
116027: PPUSH
116028: CALL 22566 0 2
// end ;
116032: LD_VAR 0 3
116036: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116037: LD_INT 0
116039: PPUSH
116040: PPUSH
116041: PPUSH
116042: PPUSH
116043: PPUSH
116044: PPUSH
116045: PPUSH
116046: PPUSH
116047: PPUSH
116048: PPUSH
116049: PPUSH
116050: PPUSH
116051: PPUSH
116052: PPUSH
116053: PPUSH
116054: PPUSH
116055: PPUSH
116056: PPUSH
116057: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116058: LD_ADDR_VAR 0 12
116062: PUSH
116063: LD_EXP 50
116067: PUSH
116068: LD_VAR 0 1
116072: ARRAY
116073: PPUSH
116074: LD_INT 25
116076: PUSH
116077: LD_INT 3
116079: PUSH
116080: EMPTY
116081: LIST
116082: LIST
116083: PPUSH
116084: CALL_OW 72
116088: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116089: LD_EXP 90
116093: PUSH
116094: LD_VAR 0 1
116098: ARRAY
116099: IFFALSE 116123
// mechs := mechs diff mc_remote_driver [ base ] ;
116101: LD_ADDR_VAR 0 12
116105: PUSH
116106: LD_VAR 0 12
116110: PUSH
116111: LD_EXP 90
116115: PUSH
116116: LD_VAR 0 1
116120: ARRAY
116121: DIFF
116122: ST_TO_ADDR
// for i in mechs do
116123: LD_ADDR_VAR 0 4
116127: PUSH
116128: LD_VAR 0 12
116132: PUSH
116133: FOR_IN
116134: IFFALSE 116169
// if GetTag ( i ) > 0 then
116136: LD_VAR 0 4
116140: PPUSH
116141: CALL_OW 110
116145: PUSH
116146: LD_INT 0
116148: GREATER
116149: IFFALSE 116167
// mechs := mechs diff i ;
116151: LD_ADDR_VAR 0 12
116155: PUSH
116156: LD_VAR 0 12
116160: PUSH
116161: LD_VAR 0 4
116165: DIFF
116166: ST_TO_ADDR
116167: GO 116133
116169: POP
116170: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116171: LD_ADDR_VAR 0 8
116175: PUSH
116176: LD_EXP 50
116180: PUSH
116181: LD_VAR 0 1
116185: ARRAY
116186: PPUSH
116187: LD_INT 2
116189: PUSH
116190: LD_INT 25
116192: PUSH
116193: LD_INT 1
116195: PUSH
116196: EMPTY
116197: LIST
116198: LIST
116199: PUSH
116200: LD_INT 25
116202: PUSH
116203: LD_INT 5
116205: PUSH
116206: EMPTY
116207: LIST
116208: LIST
116209: PUSH
116210: LD_INT 25
116212: PUSH
116213: LD_INT 8
116215: PUSH
116216: EMPTY
116217: LIST
116218: LIST
116219: PUSH
116220: LD_INT 25
116222: PUSH
116223: LD_INT 9
116225: PUSH
116226: EMPTY
116227: LIST
116228: LIST
116229: PUSH
116230: EMPTY
116231: LIST
116232: LIST
116233: LIST
116234: LIST
116235: LIST
116236: PPUSH
116237: CALL_OW 72
116241: ST_TO_ADDR
// if not defenders and not solds then
116242: LD_VAR 0 2
116246: NOT
116247: PUSH
116248: LD_VAR 0 8
116252: NOT
116253: AND
116254: IFFALSE 116258
// exit ;
116256: GO 118028
// depot_under_attack := false ;
116258: LD_ADDR_VAR 0 16
116262: PUSH
116263: LD_INT 0
116265: ST_TO_ADDR
// sold_defenders := [ ] ;
116266: LD_ADDR_VAR 0 17
116270: PUSH
116271: EMPTY
116272: ST_TO_ADDR
// if mechs then
116273: LD_VAR 0 12
116277: IFFALSE 116430
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116279: LD_ADDR_VAR 0 4
116283: PUSH
116284: LD_VAR 0 2
116288: PPUSH
116289: LD_INT 21
116291: PUSH
116292: LD_INT 2
116294: PUSH
116295: EMPTY
116296: LIST
116297: LIST
116298: PPUSH
116299: CALL_OW 72
116303: PUSH
116304: FOR_IN
116305: IFFALSE 116428
// begin if GetTag ( i ) <> 20 then
116307: LD_VAR 0 4
116311: PPUSH
116312: CALL_OW 110
116316: PUSH
116317: LD_INT 20
116319: NONEQUAL
116320: IFFALSE 116334
// SetTag ( i , 20 ) ;
116322: LD_VAR 0 4
116326: PPUSH
116327: LD_INT 20
116329: PPUSH
116330: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116334: LD_VAR 0 4
116338: PPUSH
116339: CALL_OW 263
116343: PUSH
116344: LD_INT 1
116346: EQUAL
116347: PUSH
116348: LD_VAR 0 4
116352: PPUSH
116353: CALL_OW 311
116357: NOT
116358: AND
116359: IFFALSE 116426
// begin un := mechs [ 1 ] ;
116361: LD_ADDR_VAR 0 10
116365: PUSH
116366: LD_VAR 0 12
116370: PUSH
116371: LD_INT 1
116373: ARRAY
116374: ST_TO_ADDR
// ComExit ( un ) ;
116375: LD_VAR 0 10
116379: PPUSH
116380: CALL 86824 0 1
// AddComEnterUnit ( un , i ) ;
116384: LD_VAR 0 10
116388: PPUSH
116389: LD_VAR 0 4
116393: PPUSH
116394: CALL_OW 180
// SetTag ( un , 19 ) ;
116398: LD_VAR 0 10
116402: PPUSH
116403: LD_INT 19
116405: PPUSH
116406: CALL_OW 109
// mechs := mechs diff un ;
116410: LD_ADDR_VAR 0 12
116414: PUSH
116415: LD_VAR 0 12
116419: PUSH
116420: LD_VAR 0 10
116424: DIFF
116425: ST_TO_ADDR
// end ; end ;
116426: GO 116304
116428: POP
116429: POP
// if solds then
116430: LD_VAR 0 8
116434: IFFALSE 116493
// for i in solds do
116436: LD_ADDR_VAR 0 4
116440: PUSH
116441: LD_VAR 0 8
116445: PUSH
116446: FOR_IN
116447: IFFALSE 116491
// if not GetTag ( i ) then
116449: LD_VAR 0 4
116453: PPUSH
116454: CALL_OW 110
116458: NOT
116459: IFFALSE 116489
// begin defenders := defenders union i ;
116461: LD_ADDR_VAR 0 2
116465: PUSH
116466: LD_VAR 0 2
116470: PUSH
116471: LD_VAR 0 4
116475: UNION
116476: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116477: LD_VAR 0 4
116481: PPUSH
116482: LD_INT 18
116484: PPUSH
116485: CALL_OW 109
// end ;
116489: GO 116446
116491: POP
116492: POP
// repeat wait ( 0 0$2 ) ;
116493: LD_INT 70
116495: PPUSH
116496: CALL_OW 67
// enemy := mc_scan [ base ] ;
116500: LD_ADDR_VAR 0 21
116504: PUSH
116505: LD_EXP 73
116509: PUSH
116510: LD_VAR 0 1
116514: ARRAY
116515: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116516: LD_EXP 50
116520: PUSH
116521: LD_VAR 0 1
116525: ARRAY
116526: NOT
116527: PUSH
116528: LD_EXP 50
116532: PUSH
116533: LD_VAR 0 1
116537: ARRAY
116538: PUSH
116539: EMPTY
116540: EQUAL
116541: OR
116542: IFFALSE 116579
// begin for i in defenders do
116544: LD_ADDR_VAR 0 4
116548: PUSH
116549: LD_VAR 0 2
116553: PUSH
116554: FOR_IN
116555: IFFALSE 116568
// ComStop ( i ) ;
116557: LD_VAR 0 4
116561: PPUSH
116562: CALL_OW 141
116566: GO 116554
116568: POP
116569: POP
// defenders := [ ] ;
116570: LD_ADDR_VAR 0 2
116574: PUSH
116575: EMPTY
116576: ST_TO_ADDR
// exit ;
116577: GO 118028
// end ; for i in defenders do
116579: LD_ADDR_VAR 0 4
116583: PUSH
116584: LD_VAR 0 2
116588: PUSH
116589: FOR_IN
116590: IFFALSE 117488
// begin e := NearestUnitToUnit ( enemy , i ) ;
116592: LD_ADDR_VAR 0 13
116596: PUSH
116597: LD_VAR 0 21
116601: PPUSH
116602: LD_VAR 0 4
116606: PPUSH
116607: CALL_OW 74
116611: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116612: LD_ADDR_VAR 0 7
116616: PUSH
116617: LD_EXP 50
116621: PUSH
116622: LD_VAR 0 1
116626: ARRAY
116627: PPUSH
116628: LD_INT 2
116630: PUSH
116631: LD_INT 30
116633: PUSH
116634: LD_INT 0
116636: PUSH
116637: EMPTY
116638: LIST
116639: LIST
116640: PUSH
116641: LD_INT 30
116643: PUSH
116644: LD_INT 1
116646: PUSH
116647: EMPTY
116648: LIST
116649: LIST
116650: PUSH
116651: EMPTY
116652: LIST
116653: LIST
116654: LIST
116655: PPUSH
116656: CALL_OW 72
116660: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116661: LD_ADDR_VAR 0 16
116665: PUSH
116666: LD_VAR 0 7
116670: NOT
116671: PUSH
116672: LD_VAR 0 7
116676: PPUSH
116677: LD_INT 3
116679: PUSH
116680: LD_INT 24
116682: PUSH
116683: LD_INT 600
116685: PUSH
116686: EMPTY
116687: LIST
116688: LIST
116689: PUSH
116690: EMPTY
116691: LIST
116692: LIST
116693: PPUSH
116694: CALL_OW 72
116698: OR
116699: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116700: LD_VAR 0 4
116704: PPUSH
116705: CALL_OW 247
116709: PUSH
116710: LD_INT 2
116712: DOUBLE
116713: EQUAL
116714: IFTRUE 116718
116716: GO 117114
116718: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116719: LD_VAR 0 4
116723: PPUSH
116724: CALL_OW 256
116728: PUSH
116729: LD_INT 1000
116731: EQUAL
116732: PUSH
116733: LD_VAR 0 4
116737: PPUSH
116738: LD_VAR 0 13
116742: PPUSH
116743: CALL_OW 296
116747: PUSH
116748: LD_INT 40
116750: LESS
116751: PUSH
116752: LD_VAR 0 13
116756: PPUSH
116757: LD_EXP 75
116761: PUSH
116762: LD_VAR 0 1
116766: ARRAY
116767: PPUSH
116768: CALL_OW 308
116772: OR
116773: AND
116774: IFFALSE 116896
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116776: LD_VAR 0 4
116780: PPUSH
116781: CALL_OW 262
116785: PUSH
116786: LD_INT 1
116788: EQUAL
116789: PUSH
116790: LD_VAR 0 4
116794: PPUSH
116795: CALL_OW 261
116799: PUSH
116800: LD_INT 30
116802: LESS
116803: AND
116804: PUSH
116805: LD_VAR 0 7
116809: AND
116810: IFFALSE 116880
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116812: LD_VAR 0 4
116816: PPUSH
116817: LD_VAR 0 7
116821: PPUSH
116822: LD_VAR 0 4
116826: PPUSH
116827: CALL_OW 74
116831: PPUSH
116832: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116836: LD_VAR 0 4
116840: PPUSH
116841: LD_VAR 0 7
116845: PPUSH
116846: LD_VAR 0 4
116850: PPUSH
116851: CALL_OW 74
116855: PPUSH
116856: CALL_OW 296
116860: PUSH
116861: LD_INT 6
116863: LESS
116864: IFFALSE 116878
// SetFuel ( i , 100 ) ;
116866: LD_VAR 0 4
116870: PPUSH
116871: LD_INT 100
116873: PPUSH
116874: CALL_OW 240
// end else
116878: GO 116894
// ComAttackUnit ( i , e ) ;
116880: LD_VAR 0 4
116884: PPUSH
116885: LD_VAR 0 13
116889: PPUSH
116890: CALL_OW 115
// end else
116894: GO 116997
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116896: LD_VAR 0 13
116900: PPUSH
116901: LD_EXP 75
116905: PUSH
116906: LD_VAR 0 1
116910: ARRAY
116911: PPUSH
116912: CALL_OW 308
116916: NOT
116917: PUSH
116918: LD_VAR 0 4
116922: PPUSH
116923: LD_VAR 0 13
116927: PPUSH
116928: CALL_OW 296
116932: PUSH
116933: LD_INT 40
116935: GREATEREQUAL
116936: AND
116937: PUSH
116938: LD_VAR 0 4
116942: PPUSH
116943: CALL_OW 256
116947: PUSH
116948: LD_INT 650
116950: LESSEQUAL
116951: OR
116952: PUSH
116953: LD_VAR 0 4
116957: PPUSH
116958: LD_EXP 74
116962: PUSH
116963: LD_VAR 0 1
116967: ARRAY
116968: PPUSH
116969: CALL_OW 308
116973: NOT
116974: AND
116975: IFFALSE 116997
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116977: LD_VAR 0 4
116981: PPUSH
116982: LD_EXP 74
116986: PUSH
116987: LD_VAR 0 1
116991: ARRAY
116992: PPUSH
116993: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116997: LD_VAR 0 4
117001: PPUSH
117002: CALL_OW 256
117006: PUSH
117007: LD_INT 1000
117009: LESS
117010: PUSH
117011: LD_VAR 0 4
117015: PPUSH
117016: CALL_OW 263
117020: PUSH
117021: LD_INT 1
117023: EQUAL
117024: AND
117025: PUSH
117026: LD_VAR 0 4
117030: PPUSH
117031: CALL_OW 311
117035: AND
117036: PUSH
117037: LD_VAR 0 4
117041: PPUSH
117042: LD_EXP 74
117046: PUSH
117047: LD_VAR 0 1
117051: ARRAY
117052: PPUSH
117053: CALL_OW 308
117057: AND
117058: IFFALSE 117112
// begin mech := IsDrivenBy ( i ) ;
117060: LD_ADDR_VAR 0 9
117064: PUSH
117065: LD_VAR 0 4
117069: PPUSH
117070: CALL_OW 311
117074: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117075: LD_VAR 0 9
117079: PPUSH
117080: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117084: LD_VAR 0 9
117088: PPUSH
117089: LD_VAR 0 4
117093: PPUSH
117094: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117098: LD_VAR 0 9
117102: PPUSH
117103: LD_VAR 0 4
117107: PPUSH
117108: CALL_OW 180
// end ; end ; unit_human :
117112: GO 117459
117114: LD_INT 1
117116: DOUBLE
117117: EQUAL
117118: IFTRUE 117122
117120: GO 117458
117122: POP
// begin b := IsInUnit ( i ) ;
117123: LD_ADDR_VAR 0 18
117127: PUSH
117128: LD_VAR 0 4
117132: PPUSH
117133: CALL_OW 310
117137: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117138: LD_ADDR_VAR 0 19
117142: PUSH
117143: LD_VAR 0 18
117147: NOT
117148: PUSH
117149: LD_VAR 0 18
117153: PPUSH
117154: CALL_OW 266
117158: PUSH
117159: LD_INT 32
117161: PUSH
117162: LD_INT 31
117164: PUSH
117165: EMPTY
117166: LIST
117167: LIST
117168: IN
117169: OR
117170: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117171: LD_VAR 0 18
117175: PPUSH
117176: CALL_OW 266
117180: PUSH
117181: LD_INT 5
117183: EQUAL
117184: PUSH
117185: LD_VAR 0 4
117189: PPUSH
117190: CALL_OW 257
117194: PUSH
117195: LD_INT 1
117197: PUSH
117198: LD_INT 2
117200: PUSH
117201: LD_INT 3
117203: PUSH
117204: LD_INT 4
117206: PUSH
117207: EMPTY
117208: LIST
117209: LIST
117210: LIST
117211: LIST
117212: IN
117213: AND
117214: IFFALSE 117251
// begin class := AllowSpecClass ( i ) ;
117216: LD_ADDR_VAR 0 20
117220: PUSH
117221: LD_VAR 0 4
117225: PPUSH
117226: CALL 50891 0 1
117230: ST_TO_ADDR
// if class then
117231: LD_VAR 0 20
117235: IFFALSE 117251
// ComChangeProfession ( i , class ) ;
117237: LD_VAR 0 4
117241: PPUSH
117242: LD_VAR 0 20
117246: PPUSH
117247: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117251: LD_VAR 0 16
117255: PUSH
117256: LD_VAR 0 2
117260: PPUSH
117261: LD_INT 21
117263: PUSH
117264: LD_INT 2
117266: PUSH
117267: EMPTY
117268: LIST
117269: LIST
117270: PPUSH
117271: CALL_OW 72
117275: PUSH
117276: LD_INT 1
117278: LESSEQUAL
117279: OR
117280: PUSH
117281: LD_VAR 0 19
117285: AND
117286: PUSH
117287: LD_VAR 0 4
117291: PUSH
117292: LD_VAR 0 17
117296: IN
117297: NOT
117298: AND
117299: IFFALSE 117392
// begin if b then
117301: LD_VAR 0 18
117305: IFFALSE 117354
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117307: LD_VAR 0 18
117311: PPUSH
117312: LD_VAR 0 21
117316: PPUSH
117317: LD_VAR 0 18
117321: PPUSH
117322: CALL_OW 74
117326: PPUSH
117327: CALL_OW 296
117331: PUSH
117332: LD_INT 10
117334: LESS
117335: PUSH
117336: LD_VAR 0 18
117340: PPUSH
117341: CALL_OW 461
117345: PUSH
117346: LD_INT 7
117348: NONEQUAL
117349: AND
117350: IFFALSE 117354
// continue ;
117352: GO 116589
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117354: LD_ADDR_VAR 0 17
117358: PUSH
117359: LD_VAR 0 17
117363: PPUSH
117364: LD_VAR 0 17
117368: PUSH
117369: LD_INT 1
117371: PLUS
117372: PPUSH
117373: LD_VAR 0 4
117377: PPUSH
117378: CALL_OW 1
117382: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117383: LD_VAR 0 4
117387: PPUSH
117388: CALL_OW 122
// end ; if sold_defenders then
117392: LD_VAR 0 17
117396: IFFALSE 117456
// if i in sold_defenders then
117398: LD_VAR 0 4
117402: PUSH
117403: LD_VAR 0 17
117407: IN
117408: IFFALSE 117456
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117410: LD_VAR 0 4
117414: PPUSH
117415: CALL_OW 314
117419: NOT
117420: PUSH
117421: LD_VAR 0 4
117425: PPUSH
117426: LD_VAR 0 13
117430: PPUSH
117431: CALL_OW 296
117435: PUSH
117436: LD_INT 30
117438: LESS
117439: AND
117440: IFFALSE 117456
// ComAttackUnit ( i , e ) ;
117442: LD_VAR 0 4
117446: PPUSH
117447: LD_VAR 0 13
117451: PPUSH
117452: CALL_OW 115
// end ; end ; end ;
117456: GO 117459
117458: POP
// if IsDead ( i ) then
117459: LD_VAR 0 4
117463: PPUSH
117464: CALL_OW 301
117468: IFFALSE 117486
// defenders := defenders diff i ;
117470: LD_ADDR_VAR 0 2
117474: PUSH
117475: LD_VAR 0 2
117479: PUSH
117480: LD_VAR 0 4
117484: DIFF
117485: ST_TO_ADDR
// end ;
117486: GO 116589
117488: POP
117489: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117490: LD_VAR 0 21
117494: NOT
117495: PUSH
117496: LD_VAR 0 2
117500: NOT
117501: OR
117502: PUSH
117503: LD_EXP 50
117507: PUSH
117508: LD_VAR 0 1
117512: ARRAY
117513: NOT
117514: OR
117515: IFFALSE 116493
// MC_Reset ( base , 18 ) ;
117517: LD_VAR 0 1
117521: PPUSH
117522: LD_INT 18
117524: PPUSH
117525: CALL 22566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117529: LD_ADDR_VAR 0 2
117533: PUSH
117534: LD_VAR 0 2
117538: PUSH
117539: LD_VAR 0 2
117543: PPUSH
117544: LD_INT 2
117546: PUSH
117547: LD_INT 25
117549: PUSH
117550: LD_INT 1
117552: PUSH
117553: EMPTY
117554: LIST
117555: LIST
117556: PUSH
117557: LD_INT 25
117559: PUSH
117560: LD_INT 5
117562: PUSH
117563: EMPTY
117564: LIST
117565: LIST
117566: PUSH
117567: LD_INT 25
117569: PUSH
117570: LD_INT 8
117572: PUSH
117573: EMPTY
117574: LIST
117575: LIST
117576: PUSH
117577: LD_INT 25
117579: PUSH
117580: LD_INT 9
117582: PUSH
117583: EMPTY
117584: LIST
117585: LIST
117586: PUSH
117587: EMPTY
117588: LIST
117589: LIST
117590: LIST
117591: LIST
117592: LIST
117593: PPUSH
117594: CALL_OW 72
117598: DIFF
117599: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117600: LD_VAR 0 21
117604: NOT
117605: PUSH
117606: LD_VAR 0 2
117610: PPUSH
117611: LD_INT 21
117613: PUSH
117614: LD_INT 2
117616: PUSH
117617: EMPTY
117618: LIST
117619: LIST
117620: PPUSH
117621: CALL_OW 72
117625: AND
117626: IFFALSE 117964
// begin tmp := FilterByTag ( defenders , 19 ) ;
117628: LD_ADDR_VAR 0 11
117632: PUSH
117633: LD_VAR 0 2
117637: PPUSH
117638: LD_INT 19
117640: PPUSH
117641: CALL 84008 0 2
117645: ST_TO_ADDR
// if tmp then
117646: LD_VAR 0 11
117650: IFFALSE 117720
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117652: LD_ADDR_VAR 0 11
117656: PUSH
117657: LD_VAR 0 11
117661: PPUSH
117662: LD_INT 25
117664: PUSH
117665: LD_INT 3
117667: PUSH
117668: EMPTY
117669: LIST
117670: LIST
117671: PPUSH
117672: CALL_OW 72
117676: ST_TO_ADDR
// if tmp then
117677: LD_VAR 0 11
117681: IFFALSE 117720
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117683: LD_ADDR_EXP 62
117687: PUSH
117688: LD_EXP 62
117692: PPUSH
117693: LD_VAR 0 1
117697: PPUSH
117698: LD_EXP 62
117702: PUSH
117703: LD_VAR 0 1
117707: ARRAY
117708: PUSH
117709: LD_VAR 0 11
117713: UNION
117714: PPUSH
117715: CALL_OW 1
117719: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117720: LD_VAR 0 1
117724: PPUSH
117725: LD_INT 19
117727: PPUSH
117728: CALL 22566 0 2
// repeat wait ( 0 0$1 ) ;
117732: LD_INT 35
117734: PPUSH
117735: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117739: LD_EXP 50
117743: PUSH
117744: LD_VAR 0 1
117748: ARRAY
117749: NOT
117750: PUSH
117751: LD_EXP 50
117755: PUSH
117756: LD_VAR 0 1
117760: ARRAY
117761: PUSH
117762: EMPTY
117763: EQUAL
117764: OR
117765: IFFALSE 117802
// begin for i in defenders do
117767: LD_ADDR_VAR 0 4
117771: PUSH
117772: LD_VAR 0 2
117776: PUSH
117777: FOR_IN
117778: IFFALSE 117791
// ComStop ( i ) ;
117780: LD_VAR 0 4
117784: PPUSH
117785: CALL_OW 141
117789: GO 117777
117791: POP
117792: POP
// defenders := [ ] ;
117793: LD_ADDR_VAR 0 2
117797: PUSH
117798: EMPTY
117799: ST_TO_ADDR
// exit ;
117800: GO 118028
// end ; for i in defenders do
117802: LD_ADDR_VAR 0 4
117806: PUSH
117807: LD_VAR 0 2
117811: PUSH
117812: FOR_IN
117813: IFFALSE 117902
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117815: LD_VAR 0 4
117819: PPUSH
117820: LD_EXP 74
117824: PUSH
117825: LD_VAR 0 1
117829: ARRAY
117830: PPUSH
117831: CALL_OW 308
117835: NOT
117836: IFFALSE 117860
// ComMoveToArea ( i , mc_parking [ base ] ) else
117838: LD_VAR 0 4
117842: PPUSH
117843: LD_EXP 74
117847: PUSH
117848: LD_VAR 0 1
117852: ARRAY
117853: PPUSH
117854: CALL_OW 113
117858: GO 117900
// if GetControl ( i ) = control_manual then
117860: LD_VAR 0 4
117864: PPUSH
117865: CALL_OW 263
117869: PUSH
117870: LD_INT 1
117872: EQUAL
117873: IFFALSE 117900
// if IsDrivenBy ( i ) then
117875: LD_VAR 0 4
117879: PPUSH
117880: CALL_OW 311
117884: IFFALSE 117900
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117886: LD_VAR 0 4
117890: PPUSH
117891: CALL_OW 311
117895: PPUSH
117896: CALL_OW 121
// end ;
117900: GO 117812
117902: POP
117903: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117904: LD_VAR 0 2
117908: PPUSH
117909: LD_INT 95
117911: PUSH
117912: LD_EXP 74
117916: PUSH
117917: LD_VAR 0 1
117921: ARRAY
117922: PUSH
117923: EMPTY
117924: LIST
117925: LIST
117926: PPUSH
117927: CALL_OW 72
117931: PUSH
117932: LD_VAR 0 2
117936: EQUAL
117937: PUSH
117938: LD_EXP 73
117942: PUSH
117943: LD_VAR 0 1
117947: ARRAY
117948: OR
117949: PUSH
117950: LD_EXP 50
117954: PUSH
117955: LD_VAR 0 1
117959: ARRAY
117960: NOT
117961: OR
117962: IFFALSE 117732
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117964: LD_ADDR_EXP 72
117968: PUSH
117969: LD_EXP 72
117973: PPUSH
117974: LD_VAR 0 1
117978: PPUSH
117979: LD_VAR 0 2
117983: PPUSH
117984: LD_INT 21
117986: PUSH
117987: LD_INT 2
117989: PUSH
117990: EMPTY
117991: LIST
117992: LIST
117993: PPUSH
117994: CALL_OW 72
117998: PPUSH
117999: CALL_OW 1
118003: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118004: LD_VAR 0 1
118008: PPUSH
118009: LD_INT 19
118011: PPUSH
118012: CALL 22566 0 2
// MC_Reset ( base , 20 ) ;
118016: LD_VAR 0 1
118020: PPUSH
118021: LD_INT 20
118023: PPUSH
118024: CALL 22566 0 2
// end ; end_of_file
118028: LD_VAR 0 3
118032: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118033: LD_VAR 0 1
118037: PUSH
118038: LD_INT 200
118040: DOUBLE
118041: GREATEREQUAL
118042: IFFALSE 118050
118044: LD_INT 299
118046: DOUBLE
118047: LESSEQUAL
118048: IFTRUE 118052
118050: GO 118084
118052: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118053: LD_VAR 0 1
118057: PPUSH
118058: LD_VAR 0 2
118062: PPUSH
118063: LD_VAR 0 3
118067: PPUSH
118068: LD_VAR 0 4
118072: PPUSH
118073: LD_VAR 0 5
118077: PPUSH
118078: CALL 106819 0 5
118082: GO 118161
118084: LD_INT 300
118086: DOUBLE
118087: GREATEREQUAL
118088: IFFALSE 118096
118090: LD_INT 399
118092: DOUBLE
118093: LESSEQUAL
118094: IFTRUE 118098
118096: GO 118160
118098: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118099: LD_VAR 0 1
118103: PPUSH
118104: LD_VAR 0 2
118108: PPUSH
118109: LD_VAR 0 3
118113: PPUSH
118114: LD_VAR 0 4
118118: PPUSH
118119: LD_VAR 0 5
118123: PPUSH
118124: LD_VAR 0 6
118128: PPUSH
118129: LD_VAR 0 7
118133: PPUSH
118134: LD_VAR 0 8
118138: PPUSH
118139: LD_VAR 0 9
118143: PPUSH
118144: LD_VAR 0 10
118148: PPUSH
118149: LD_VAR 0 11
118153: PPUSH
118154: CALL 103144 0 11
118158: GO 118161
118160: POP
// end ;
118161: PPOPN 11
118163: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118164: LD_VAR 0 1
118168: PPUSH
118169: LD_VAR 0 2
118173: PPUSH
118174: LD_VAR 0 3
118178: PPUSH
118179: LD_VAR 0 4
118183: PPUSH
118184: LD_VAR 0 5
118188: PPUSH
118189: CALL 106555 0 5
// end ; end_of_file
118193: PPOPN 5
118195: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118196: LD_VAR 0 1
118200: PPUSH
118201: LD_VAR 0 2
118205: PPUSH
118206: LD_VAR 0 3
118210: PPUSH
118211: LD_VAR 0 4
118215: PPUSH
118216: LD_VAR 0 5
118220: PPUSH
118221: LD_VAR 0 6
118225: PPUSH
118226: CALL 90796 0 6
// end ;
118230: PPOPN 6
118232: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118233: LD_INT 0
118235: PPUSH
// begin if not units then
118236: LD_VAR 0 1
118240: NOT
118241: IFFALSE 118245
// exit ;
118243: GO 118245
// end ;
118245: PPOPN 7
118247: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118248: CALL 90700 0 0
// end ;
118252: PPOPN 1
118254: END
