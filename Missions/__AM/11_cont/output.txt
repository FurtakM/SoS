// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18257 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83437 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2404 0 0
// MC_Start ( ) ;
  85: CALL 20437 0 0
// Action ;
  89: CALL 8548 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42154 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42154 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42154 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42599 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42491 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42491 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48965 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48965 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48965 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 801: LD_ADDR_EXP 31
 805: PUSH
 806: LD_STRING Cornel
 808: PPUSH
 809: LD_EXP 1
 813: NOT
 814: PPUSH
 815: LD_EXP 4
 819: PPUSH
 820: CALL 48965 0 3
 824: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 825: LD_ADDR_EXP 23
 829: PUSH
 830: LD_STRING Donaldson
 832: PPUSH
 833: LD_EXP 1
 837: NOT
 838: PPUSH
 839: LD_EXP 4
 843: PPUSH
 844: CALL 48965 0 3
 848: ST_TO_ADDR
// if not Donaldson then
 849: LD_EXP 23
 853: NOT
 854: IFFALSE 869
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 856: LD_ADDR_EXP 23
 860: PUSH
 861: LD_STRING 10_Donaldson
 863: PPUSH
 864: CALL_OW 34
 868: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING Bobby
 876: PPUSH
 877: LD_EXP 1
 881: NOT
 882: PPUSH
 883: LD_EXP 4
 887: PPUSH
 888: CALL 48965 0 3
 892: ST_TO_ADDR
// if not Bobby then
 893: LD_EXP 24
 897: NOT
 898: IFFALSE 913
// Bobby := CreateCharacter ( 10_Bobby ) ;
 900: LD_ADDR_EXP 24
 904: PUSH
 905: LD_STRING 10_Bobby
 907: PPUSH
 908: CALL_OW 34
 912: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING Cyrus
 920: PPUSH
 921: LD_EXP 1
 925: NOT
 926: PPUSH
 927: LD_EXP 4
 931: PPUSH
 932: CALL 48965 0 3
 936: ST_TO_ADDR
// if not Cyrus then
 937: LD_EXP 25
 941: NOT
 942: IFFALSE 957
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 944: LD_ADDR_EXP 25
 948: PUSH
 949: LD_STRING 10_Cyrus
 951: PPUSH
 952: CALL_OW 34
 956: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 957: LD_ADDR_EXP 26
 961: PUSH
 962: LD_STRING Denis
 964: PPUSH
 965: LD_EXP 1
 969: NOT
 970: PPUSH
 971: LD_EXP 4
 975: PPUSH
 976: CALL 48965 0 3
 980: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 981: LD_ADDR_EXP 27
 985: PUSH
 986: LD_STRING Brown
 988: PPUSH
 989: LD_EXP 1
 993: NOT
 994: PPUSH
 995: LD_EXP 4
 999: PPUSH
1000: CALL 48965 0 3
1004: ST_TO_ADDR
// if not Brown then
1005: LD_EXP 27
1009: NOT
1010: IFFALSE 1025
// Brown := CreateCharacter ( 10_Brown ) ;
1012: LD_ADDR_EXP 27
1016: PUSH
1017: LD_STRING 10_Brown
1019: PPUSH
1020: CALL_OW 34
1024: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1025: LD_ADDR_EXP 28
1029: PUSH
1030: LD_STRING Gladstone
1032: PPUSH
1033: LD_EXP 1
1037: NOT
1038: PPUSH
1039: LD_EXP 4
1043: PPUSH
1044: CALL 48965 0 3
1048: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1049: LD_ADDR_EXP 29
1053: PUSH
1054: LD_STRING Houten
1056: PPUSH
1057: LD_EXP 1
1061: NOT
1062: PPUSH
1063: LD_EXP 4
1067: PPUSH
1068: CALL 48965 0 3
1072: ST_TO_ADDR
// if not Houten then
1073: LD_EXP 29
1077: NOT
1078: IFFALSE 1093
// Houten := CreateCharacter ( 10_Houten ) ;
1080: LD_ADDR_EXP 29
1084: PUSH
1085: LD_STRING 10_Houten
1087: PPUSH
1088: CALL_OW 34
1092: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1093: LD_ADDR_EXP 31
1097: PUSH
1098: LD_STRING Cornell
1100: PPUSH
1101: LD_EXP 1
1105: NOT
1106: PPUSH
1107: LD_EXP 4
1111: PPUSH
1112: CALL 48965 0 3
1116: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1117: LD_ADDR_EXP 32
1121: PUSH
1122: LD_STRING Gary
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_EXP 4
1135: PPUSH
1136: CALL 48965 0 3
1140: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1141: LD_ADDR_EXP 33
1145: PUSH
1146: LD_STRING Frank
1148: PPUSH
1149: LD_EXP 1
1153: NOT
1154: PPUSH
1155: LD_EXP 4
1159: PPUSH
1160: CALL 48965 0 3
1164: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1165: LD_ADDR_EXP 34
1169: PUSH
1170: LD_STRING Kikuchi
1172: PPUSH
1173: LD_EXP 1
1177: NOT
1178: PPUSH
1179: LD_EXP 4
1183: PPUSH
1184: CALL 48965 0 3
1188: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1189: LD_ADDR_VAR 0 5
1193: PUSH
1194: LD_EXP 22
1198: PUSH
1199: LD_EXP 23
1203: PUSH
1204: LD_EXP 24
1208: PUSH
1209: LD_EXP 25
1213: PUSH
1214: LD_EXP 26
1218: PUSH
1219: LD_EXP 27
1223: PUSH
1224: LD_EXP 28
1228: PUSH
1229: LD_EXP 29
1233: PUSH
1234: LD_EXP 31
1238: PUSH
1239: LD_EXP 32
1243: PUSH
1244: LD_EXP 33
1248: PUSH
1249: LD_EXP 34
1253: PUSH
1254: EMPTY
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: ST_TO_ADDR
// tmp := tmp diff 0 ;
1268: LD_ADDR_VAR 0 5
1272: PUSH
1273: LD_VAR 0 5
1277: PUSH
1278: LD_INT 0
1280: DIFF
1281: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1282: LD_ADDR_VAR 0 5
1286: PUSH
1287: LD_VAR 0 5
1291: PUSH
1292: LD_STRING 10_other_survivors
1294: PPUSH
1295: CALL_OW 31
1299: UNION
1300: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1301: LD_ADDR_VAR 0 5
1305: PUSH
1306: LD_VAR 0 5
1310: PUSH
1311: LD_STRING 10_lock
1313: PPUSH
1314: CALL_OW 31
1318: UNION
1319: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1320: LD_ADDR_VAR 0 5
1324: PUSH
1325: LD_VAR 0 5
1329: PUSH
1330: LD_STRING 10c_lock
1332: PPUSH
1333: CALL_OW 31
1337: UNION
1338: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1339: LD_STRING 10_lock
1341: PPUSH
1342: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1346: LD_STRING 10c_lock
1348: PPUSH
1349: CALL_OW 40
// for i in tmp do
1353: LD_ADDR_VAR 0 2
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: FOR_IN
1364: IFFALSE 1402
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1366: LD_VAR 0 2
1370: PPUSH
1371: CALL_OW 257
1375: PUSH
1376: LD_INT 8
1378: PUSH
1379: LD_INT 2
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: IN
1386: IFFALSE 1400
// SetClass ( i , class_soldier ) ;
1388: LD_VAR 0 2
1392: PPUSH
1393: LD_INT 1
1395: PPUSH
1396: CALL_OW 336
1400: GO 1363
1402: POP
1403: POP
// if tmp < 12 then
1404: LD_VAR 0 5
1408: PUSH
1409: LD_INT 12
1411: LESS
1412: IFFALSE 1506
// begin k := 16 - tmp ;
1414: LD_ADDR_VAR 0 3
1418: PUSH
1419: LD_INT 16
1421: PUSH
1422: LD_VAR 0 5
1426: MINUS
1427: ST_TO_ADDR
// for i = 1 to k do
1428: LD_ADDR_VAR 0 2
1432: PUSH
1433: DOUBLE
1434: LD_INT 1
1436: DEC
1437: ST_TO_ADDR
1438: LD_VAR 0 3
1442: PUSH
1443: FOR_TO
1444: IFFALSE 1504
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1446: LD_INT 0
1448: PPUSH
1449: LD_INT 1
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 3
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: EMPTY
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: PUSH
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 4
1472: PPUSH
1473: CALL_OW 12
1477: ARRAY
1478: PPUSH
1479: LD_INT 6
1481: PPUSH
1482: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1486: LD_ADDR_VAR 0 5
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: CALL_OW 44
1500: ADD
1501: ST_TO_ADDR
// end ;
1502: GO 1443
1504: POP
1505: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1506: LD_ADDR_EXP 19
1510: PUSH
1511: LD_STRING 1
1513: PPUSH
1514: LD_INT 12
1516: PPUSH
1517: LD_INT 12
1519: PPUSH
1520: LD_INT -5
1522: PUSH
1523: LD_EXP 21
1527: PUSH
1528: LD_INT -2
1530: PUSH
1531: LD_INT -3
1533: PUSH
1534: LD_INT -5
1536: PUSH
1537: EMPTY
1538: LIST
1539: LIST
1540: LIST
1541: LIST
1542: LIST
1543: PUSH
1544: LD_VAR 0 5
1548: ADD
1549: PUSH
1550: LD_INT -6
1552: PUSH
1553: LD_INT -4
1555: PUSH
1556: LD_EXP 30
1560: PUSH
1561: EMPTY
1562: LIST
1563: LIST
1564: LIST
1565: ADD
1566: PPUSH
1567: LD_INT 1
1569: PUSH
1570: LD_INT 4
1572: PUSH
1573: EMPTY
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: LD_INT 0
1582: PUSH
1583: LD_INT 5
1585: PUSH
1586: EMPTY
1587: LIST
1588: LIST
1589: LIST
1590: PUSH
1591: LD_INT 4
1593: PUSH
1594: LD_INT 0
1596: PUSH
1597: LD_INT 3
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 5
1607: PUSH
1608: LD_INT 0
1610: PUSH
1611: LD_INT 2
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: LIST
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: PPUSH
1625: CALL_OW 42
1629: ST_TO_ADDR
// others := tmp diff selected ;
1630: LD_ADDR_VAR 0 8
1634: PUSH
1635: LD_VAR 0 5
1639: PUSH
1640: LD_EXP 19
1644: DIFF
1645: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1646: LD_ADDR_VAR 0 8
1650: PUSH
1651: LD_VAR 0 8
1655: PUSH
1656: LD_EXP 22
1660: PUSH
1661: LD_EXP 23
1665: PUSH
1666: LD_EXP 24
1670: PUSH
1671: LD_EXP 25
1675: PUSH
1676: LD_EXP 26
1680: PUSH
1681: LD_EXP 27
1685: PUSH
1686: LD_EXP 28
1690: PUSH
1691: LD_EXP 29
1695: PUSH
1696: LD_EXP 31
1700: PUSH
1701: LD_EXP 32
1705: PUSH
1706: LD_EXP 33
1710: PUSH
1711: LD_EXP 34
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: DIFF
1730: ST_TO_ADDR
// if others then
1731: LD_VAR 0 8
1735: IFFALSE 1749
// SaveCharacters ( others , 11_others ) ;
1737: LD_VAR 0 8
1741: PPUSH
1742: LD_STRING 11_others
1744: PPUSH
1745: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1749: LD_ADDR_VAR 0 6
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: LD_INT 1
1762: PUSH
1763: LD_INT 4
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 2
1774: PUSH
1775: LD_INT 3
1777: PUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 5
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: LD_INT 1
1795: PUSH
1796: LD_INT 1
1798: PUSH
1799: LD_INT 5
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: PUSH
1808: LD_INT 2
1810: PUSH
1811: LD_INT 1
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 7
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 3
1831: PUSH
1832: LD_INT 1
1834: PUSH
1835: LD_INT 7
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: ST_TO_ADDR
// for i in JMM ^ selected do
1851: LD_ADDR_VAR 0 2
1855: PUSH
1856: LD_EXP 21
1860: PUSH
1861: LD_EXP 19
1865: ADD
1866: PUSH
1867: FOR_IN
1868: IFFALSE 2058
// begin if GetClass ( i ) = 3 then
1870: LD_VAR 0 2
1874: PPUSH
1875: CALL_OW 257
1879: PUSH
1880: LD_INT 3
1882: EQUAL
1883: IFFALSE 2041
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1885: LD_ADDR_OWVAR 37
1889: PUSH
1890: LD_VAR 0 6
1894: PUSH
1895: LD_INT 1
1897: ARRAY
1898: PUSH
1899: LD_INT 1
1901: ARRAY
1902: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1903: LD_ADDR_OWVAR 39
1907: PUSH
1908: LD_VAR 0 6
1912: PUSH
1913: LD_INT 1
1915: ARRAY
1916: PUSH
1917: LD_INT 2
1919: ARRAY
1920: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1921: LD_ADDR_OWVAR 38
1925: PUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_INT 1
1933: ARRAY
1934: PUSH
1935: LD_INT 3
1937: ARRAY
1938: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
1939: LD_ADDR_OWVAR 40
1943: PUSH
1944: LD_VAR 0 6
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PUSH
1953: LD_INT 4
1955: ARRAY
1956: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
1957: LD_ADDR_VAR 0 6
1961: PUSH
1962: LD_VAR 0 6
1966: PPUSH
1967: LD_INT 1
1969: PPUSH
1970: CALL_OW 3
1974: ST_TO_ADDR
// veh := CreateVehicle ;
1975: LD_ADDR_VAR 0 7
1979: PUSH
1980: CALL_OW 45
1984: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
1985: LD_VAR 0 7
1989: PPUSH
1990: LD_INT 8
1992: PPUSH
1993: LD_INT 0
1995: PPUSH
1996: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2000: LD_VAR 0 2
2004: PPUSH
2005: LD_VAR 0 7
2009: PPUSH
2010: CALL_OW 52
// if i = JMM then
2014: LD_VAR 0 2
2018: PUSH
2019: LD_EXP 21
2023: EQUAL
2024: IFFALSE 2039
// SetMark ( veh , - 1 ) ;
2026: LD_VAR 0 7
2030: PPUSH
2031: LD_INT 1
2033: NEG
2034: PPUSH
2035: CALL_OW 242
// end else
2039: GO 2056
// PlaceUnitArea ( i , am_hum_start , false ) ;
2041: LD_VAR 0 2
2045: PPUSH
2046: LD_INT 9
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 49
// end ;
2056: GO 1867
2058: POP
2059: POP
// vc_chassis := us_medium_tracked ;
2060: LD_ADDR_OWVAR 37
2064: PUSH
2065: LD_INT 3
2067: ST_TO_ADDR
// vc_engine := engine_solar ;
2068: LD_ADDR_OWVAR 39
2072: PUSH
2073: LD_INT 2
2075: ST_TO_ADDR
// vc_control := control_computer ;
2076: LD_ADDR_OWVAR 38
2080: PUSH
2081: LD_INT 3
2083: ST_TO_ADDR
// vc_weapon := us_radar ;
2084: LD_ADDR_OWVAR 40
2088: PUSH
2089: LD_INT 11
2091: ST_TO_ADDR
// veh := CreateVehicle ;
2092: LD_ADDR_VAR 0 7
2096: PUSH
2097: CALL_OW 45
2101: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2102: LD_VAR 0 7
2106: PPUSH
2107: LD_INT 87
2109: PPUSH
2110: LD_INT 142
2112: PPUSH
2113: LD_INT 0
2115: PPUSH
2116: CALL_OW 48
// end ;
2120: LD_VAR 0 1
2124: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2125: LD_INT 0
2127: PPUSH
2128: PPUSH
2129: PPUSH
2130: PPUSH
// uc_side := 1 ;
2131: LD_ADDR_OWVAR 20
2135: PUSH
2136: LD_INT 1
2138: ST_TO_ADDR
// uc_nation := 1 ;
2139: LD_ADDR_OWVAR 21
2143: PUSH
2144: LD_INT 1
2146: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2147: LD_ADDR_VAR 0 3
2151: PUSH
2152: LD_INT 3
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 3
2160: PUSH
2161: LD_INT 5
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_INT 3
2172: PUSH
2173: LD_INT 1
2175: PUSH
2176: LD_INT 3
2178: PUSH
2179: LD_INT 7
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 3
2190: PUSH
2191: LD_INT 1
2193: PUSH
2194: LD_INT 3
2196: PUSH
2197: LD_INT 7
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 3
2208: PUSH
2209: LD_INT 1
2211: PUSH
2212: LD_INT 3
2214: PUSH
2215: LD_INT 11
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 4
2226: PUSH
2227: LD_INT 1
2229: PUSH
2230: LD_INT 3
2232: PUSH
2233: LD_INT 6
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: LD_INT 4
2244: PUSH
2245: LD_INT 1
2247: PUSH
2248: LD_INT 3
2250: PUSH
2251: LD_INT 5
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2268: LD_ADDR_VAR 0 2
2272: PUSH
2273: DOUBLE
2274: LD_INT 1
2276: DEC
2277: ST_TO_ADDR
2278: LD_INT 7
2280: PUSH
2281: LD_OWVAR 67
2285: MINUS
2286: PUSH
2287: FOR_TO
2288: IFFALSE 2397
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2290: LD_ADDR_OWVAR 37
2294: PUSH
2295: LD_VAR 0 3
2299: PUSH
2300: LD_VAR 0 2
2304: ARRAY
2305: PUSH
2306: LD_INT 1
2308: ARRAY
2309: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2310: LD_ADDR_OWVAR 39
2314: PUSH
2315: LD_VAR 0 3
2319: PUSH
2320: LD_VAR 0 2
2324: ARRAY
2325: PUSH
2326: LD_INT 2
2328: ARRAY
2329: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2330: LD_ADDR_OWVAR 38
2334: PUSH
2335: LD_VAR 0 3
2339: PUSH
2340: LD_VAR 0 2
2344: ARRAY
2345: PUSH
2346: LD_INT 3
2348: ARRAY
2349: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2350: LD_ADDR_OWVAR 40
2354: PUSH
2355: LD_VAR 0 3
2359: PUSH
2360: LD_VAR 0 2
2364: ARRAY
2365: PUSH
2366: LD_INT 4
2368: ARRAY
2369: ST_TO_ADDR
// veh := CreateVehicle ;
2370: LD_ADDR_VAR 0 4
2374: PUSH
2375: CALL_OW 45
2379: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2380: LD_VAR 0 4
2384: PPUSH
2385: LD_INT 8
2387: PPUSH
2388: LD_INT 0
2390: PPUSH
2391: CALL_OW 49
// end ;
2395: GO 2287
2397: POP
2398: POP
// end ; end_of_file
2399: LD_VAR 0 1
2403: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2404: LD_INT 0
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
2410: PPUSH
2411: PPUSH
// if Difficulty = 1 then
2412: LD_OWVAR 67
2416: PUSH
2417: LD_INT 1
2419: EQUAL
2420: IFFALSE 2517
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2422: LD_ADDR_VAR 0 6
2426: PUSH
2427: LD_INT 129
2429: PUSH
2430: LD_INT 45
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: LD_INT 143
2439: PUSH
2440: LD_INT 58
2442: PUSH
2443: EMPTY
2444: LIST
2445: LIST
2446: PUSH
2447: LD_INT 184
2449: PUSH
2450: LD_INT 113
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: PUSH
2457: LD_INT 163
2459: PUSH
2460: LD_INT 107
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: LIST
2471: LIST
2472: ST_TO_ADDR
// for i in tmp do
2473: LD_ADDR_VAR 0 2
2477: PUSH
2478: LD_VAR 0 6
2482: PUSH
2483: FOR_IN
2484: IFFALSE 2515
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2486: LD_VAR 0 2
2490: PUSH
2491: LD_INT 1
2493: ARRAY
2494: PPUSH
2495: LD_VAR 0 2
2499: PUSH
2500: LD_INT 2
2502: ARRAY
2503: PPUSH
2504: CALL_OW 428
2508: PPUSH
2509: CALL_OW 64
2513: GO 2483
2515: POP
2516: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2517: LD_ADDR_VAR 0 2
2521: PUSH
2522: LD_INT 21
2524: PUSH
2525: LD_INT 3
2527: PUSH
2528: EMPTY
2529: LIST
2530: LIST
2531: PPUSH
2532: CALL_OW 69
2536: PUSH
2537: FOR_IN
2538: IFFALSE 2575
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2540: LD_VAR 0 2
2544: PPUSH
2545: LD_INT 5
2547: PUSH
2548: LD_INT 6
2550: PUSH
2551: LD_INT 7
2553: PUSH
2554: LD_INT 8
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: LIST
2561: LIST
2562: PUSH
2563: LD_OWVAR 67
2567: ARRAY
2568: PPUSH
2569: CALL_OW 241
2573: GO 2537
2575: POP
2576: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2577: LD_ADDR_VAR 0 5
2581: PUSH
2582: LD_INT 5
2584: PUSH
2585: LD_INT 6
2587: PUSH
2588: LD_INT 7
2590: PUSH
2591: LD_INT 8
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: PUSH
2600: LD_OWVAR 67
2604: ARRAY
2605: ST_TO_ADDR
// uc_side := 2 ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_INT 2
2613: ST_TO_ADDR
// uc_nation := 2 ;
2614: LD_ADDR_OWVAR 21
2618: PUSH
2619: LD_INT 2
2621: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2622: LD_ADDR_OWVAR 37
2626: PUSH
2627: LD_INT 14
2629: ST_TO_ADDR
// vc_engine := engine_siberite ;
2630: LD_ADDR_OWVAR 39
2634: PUSH
2635: LD_INT 3
2637: ST_TO_ADDR
// vc_control := control_manual ;
2638: LD_ADDR_OWVAR 38
2642: PUSH
2643: LD_INT 1
2645: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2646: LD_ADDR_OWVAR 40
2650: PUSH
2651: LD_INT 31
2653: ST_TO_ADDR
// for i = 1 to 3 do
2654: LD_ADDR_VAR 0 2
2658: PUSH
2659: DOUBLE
2660: LD_INT 1
2662: DEC
2663: ST_TO_ADDR
2664: LD_INT 3
2666: PUSH
2667: FOR_TO
2668: IFFALSE 2752
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2670: LD_INT 0
2672: PPUSH
2673: LD_INT 3
2675: PPUSH
2676: LD_VAR 0 5
2680: PPUSH
2681: CALL_OW 380
// un := CreateVehicle ;
2685: LD_ADDR_VAR 0 4
2689: PUSH
2690: CALL_OW 45
2694: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2695: LD_VAR 0 4
2699: PPUSH
2700: LD_INT 0
2702: PPUSH
2703: LD_INT 5
2705: PPUSH
2706: CALL_OW 12
2710: PPUSH
2711: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2715: LD_VAR 0 4
2719: PPUSH
2720: LD_INT 156
2722: PPUSH
2723: LD_INT 15
2725: PPUSH
2726: LD_INT 6
2728: PPUSH
2729: LD_INT 0
2731: PPUSH
2732: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2736: CALL_OW 44
2740: PPUSH
2741: LD_VAR 0 4
2745: PPUSH
2746: CALL_OW 52
// end ;
2750: GO 2667
2752: POP
2753: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2754: LD_ADDR_EXP 37
2758: PUSH
2759: LD_INT 94
2761: PPUSH
2762: LD_INT 28
2764: PPUSH
2765: LD_STRING dammam
2767: PPUSH
2768: LD_VAR 0 5
2772: PPUSH
2773: LD_INT 10000
2775: PUSH
2776: LD_INT 1000
2778: PUSH
2779: LD_INT 300
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: PPUSH
2787: LD_INT 12
2789: PUSH
2790: LD_INT 2
2792: PUSH
2793: LD_INT 3
2795: PUSH
2796: LD_INT 4
2798: PUSH
2799: LD_INT 4
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: PUSH
2808: LD_OWVAR 67
2812: ARRAY
2813: PUSH
2814: LD_INT 1
2816: NEG
2817: PUSH
2818: LD_INT 4
2820: PUSH
2821: EMPTY
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: PPUSH
2827: CALL 57710 0 6
2831: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
2832: LD_ADDR_EXP 37
2836: PUSH
2837: LD_EXP 37
2841: PUSH
2842: LD_INT 122
2844: PPUSH
2845: LD_INT 25
2847: PPUSH
2848: LD_STRING 
2850: PPUSH
2851: LD_VAR 0 5
2855: PPUSH
2856: LD_INT 500
2858: PUSH
2859: LD_INT 60
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: LIST
2869: PPUSH
2870: LD_INT 8
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 3
2878: PUSH
2879: LD_INT 4
2881: PUSH
2882: LD_INT 5
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: PUSH
2891: LD_OWVAR 67
2895: ARRAY
2896: PUSH
2897: LD_INT 2
2899: PUSH
2900: LD_INT 0
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: LIST
2907: LIST
2908: PPUSH
2909: CALL 57710 0 6
2913: UNION
2914: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
2915: LD_ADDR_EXP 35
2919: PUSH
2920: LD_INT 45
2922: PPUSH
2923: LD_INT 24
2925: PPUSH
2926: LD_STRING jeddah
2928: PPUSH
2929: LD_VAR 0 5
2933: PPUSH
2934: LD_INT 700
2936: PUSH
2937: LD_INT 300
2939: PUSH
2940: LD_INT 10
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: LIST
2947: PPUSH
2948: LD_INT 9
2950: PUSH
2951: LD_INT 4
2953: PUSH
2954: LD_INT 3
2956: PUSH
2957: LD_INT 2
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: PPUSH
2966: CALL 57710 0 6
2970: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2971: LD_ADDR_EXP 36
2975: PUSH
2976: LD_INT 7
2978: PPUSH
2979: LD_INT 27
2981: PPUSH
2982: LD_STRING riyadh
2984: PPUSH
2985: LD_VAR 0 5
2989: PPUSH
2990: LD_INT 500
2992: PUSH
2993: LD_INT 60
2995: PUSH
2996: LD_INT 0
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: PPUSH
3004: LD_INT 4
3006: PUSH
3007: LD_INT 2
3009: PUSH
3010: LD_INT 3
3012: PUSH
3013: LD_INT 1
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: PPUSH
3022: CALL 57710 0 6
3026: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3027: LD_ADDR_EXP 39
3031: PUSH
3032: LD_INT 204
3034: PPUSH
3035: LD_INT 26
3037: PPUSH
3038: LD_STRING 
3040: PPUSH
3041: LD_VAR 0 5
3045: PPUSH
3046: LD_INT 500
3048: PUSH
3049: LD_INT 50
3051: PUSH
3052: LD_INT 0
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: LD_INT 9
3062: PUSH
3063: LD_INT 2
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: LD_INT 1
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PPUSH
3078: CALL 57710 0 6
3082: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3083: LD_ADDR_EXP 50
3087: PUSH
3088: LD_EXP 37
3092: PUSH
3093: LD_EXP 35
3097: PUSH
3098: LD_EXP 39
3102: PUSH
3103: EMPTY
3104: LIST
3105: LIST
3106: LIST
3107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3108: LD_ADDR_VAR 0 2
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 2
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 30
3125: PUSH
3126: LD_INT 31
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 58
3135: PUSH
3136: EMPTY
3137: LIST
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL_OW 69
3148: PUSH
3149: FOR_IN
3150: IFFALSE 3275
// begin if GetBase ( i ) then
3152: LD_VAR 0 2
3156: PPUSH
3157: CALL_OW 274
3161: IFFALSE 3165
// continue ;
3163: GO 3149
// d := GetDir ( i ) ;
3165: LD_ADDR_VAR 0 3
3169: PUSH
3170: LD_VAR 0 2
3174: PPUSH
3175: CALL_OW 254
3179: ST_TO_ADDR
// if d < 3 then
3180: LD_VAR 0 3
3184: PUSH
3185: LD_INT 3
3187: LESS
3188: IFFALSE 3206
// d := d + 3 else
3190: LD_ADDR_VAR 0 3
3194: PUSH
3195: LD_VAR 0 3
3199: PUSH
3200: LD_INT 3
3202: PLUS
3203: ST_TO_ADDR
3204: GO 3220
// d := d - 3 ;
3206: LD_ADDR_VAR 0 3
3210: PUSH
3211: LD_VAR 0 3
3215: PUSH
3216: LD_INT 3
3218: MINUS
3219: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3220: LD_INT 0
3222: PPUSH
3223: LD_INT 8
3225: PPUSH
3226: LD_VAR 0 5
3230: PPUSH
3231: CALL_OW 380
// un := CreateHuman ;
3235: LD_ADDR_VAR 0 4
3239: PUSH
3240: CALL_OW 44
3244: ST_TO_ADDR
// SetDir ( un , d ) ;
3245: LD_VAR 0 4
3249: PPUSH
3250: LD_VAR 0 3
3254: PPUSH
3255: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: LD_VAR 0 2
3268: PPUSH
3269: CALL_OW 52
// end ;
3273: GO 3149
3275: POP
3276: POP
// if Difficulty > 1 then
3277: LD_OWVAR 67
3281: PUSH
3282: LD_INT 1
3284: GREATER
3285: IFFALSE 3656
// begin ar_kamikadze := [ ] ;
3287: LD_ADDR_EXP 42
3291: PUSH
3292: EMPTY
3293: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3294: LD_INT 0
3296: PPUSH
3297: LD_INT 1
3299: PPUSH
3300: LD_VAR 0 5
3304: PPUSH
3305: CALL_OW 380
// un := CreateHuman ;
3309: LD_ADDR_VAR 0 4
3313: PUSH
3314: CALL_OW 44
3318: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3319: LD_VAR 0 4
3323: PPUSH
3324: LD_INT 3
3326: PPUSH
3327: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3331: LD_VAR 0 4
3335: PPUSH
3336: LD_INT 23
3338: PPUSH
3339: LD_INT 44
3341: PPUSH
3342: LD_INT 0
3344: PPUSH
3345: CALL_OW 48
// ComCrawl ( un ) ;
3349: LD_VAR 0 4
3353: PPUSH
3354: CALL_OW 137
// un := CreateHuman ;
3358: LD_ADDR_VAR 0 4
3362: PUSH
3363: CALL_OW 44
3367: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3368: LD_VAR 0 4
3372: PPUSH
3373: LD_INT 3
3375: PPUSH
3376: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3380: LD_VAR 0 4
3384: PPUSH
3385: LD_INT 30
3387: PPUSH
3388: LD_INT 39
3390: PPUSH
3391: LD_INT 0
3393: PPUSH
3394: CALL_OW 48
// ComCrawl ( un ) ;
3398: LD_VAR 0 4
3402: PPUSH
3403: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3407: LD_INT 0
3409: PPUSH
3410: LD_INT 17
3412: PPUSH
3413: LD_VAR 0 5
3417: PPUSH
3418: CALL_OW 380
// un := CreateHuman ;
3422: LD_ADDR_VAR 0 4
3426: PUSH
3427: CALL_OW 44
3431: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3432: LD_VAR 0 4
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3444: LD_VAR 0 4
3448: PPUSH
3449: LD_INT 45
3451: PPUSH
3452: LD_INT 86
3454: PPUSH
3455: LD_INT 0
3457: PPUSH
3458: CALL_OW 48
// ComHold ( un ) ;
3462: LD_VAR 0 4
3466: PPUSH
3467: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3471: LD_ADDR_EXP 42
3475: PUSH
3476: LD_EXP 42
3480: PPUSH
3481: LD_EXP 42
3485: PUSH
3486: LD_INT 1
3488: PLUS
3489: PPUSH
3490: LD_VAR 0 4
3494: PPUSH
3495: CALL_OW 1
3499: ST_TO_ADDR
// un := CreateHuman ;
3500: LD_ADDR_VAR 0 4
3504: PUSH
3505: CALL_OW 44
3509: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3510: LD_VAR 0 4
3514: PPUSH
3515: LD_INT 3
3517: PPUSH
3518: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3522: LD_VAR 0 4
3526: PPUSH
3527: LD_INT 60
3529: PPUSH
3530: LD_INT 85
3532: PPUSH
3533: LD_INT 0
3535: PPUSH
3536: CALL_OW 48
// ComHold ( un ) ;
3540: LD_VAR 0 4
3544: PPUSH
3545: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3549: LD_ADDR_EXP 42
3553: PUSH
3554: LD_EXP 42
3558: PPUSH
3559: LD_EXP 42
3563: PUSH
3564: LD_INT 1
3566: PLUS
3567: PPUSH
3568: LD_VAR 0 4
3572: PPUSH
3573: CALL_OW 1
3577: ST_TO_ADDR
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 222
3607: PPUSH
3608: LD_INT 166
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComHold ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3627: LD_ADDR_EXP 42
3631: PUSH
3632: LD_EXP 42
3636: PPUSH
3637: LD_EXP 42
3641: PUSH
3642: LD_INT 1
3644: PLUS
3645: PPUSH
3646: LD_VAR 0 4
3650: PPUSH
3651: CALL_OW 1
3655: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3656: LD_ADDR_EXP 40
3660: PUSH
3661: EMPTY
3662: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3663: LD_INT 1
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: LD_VAR 0 5
3673: PPUSH
3674: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3678: LD_ADDR_OWVAR 26
3682: PUSH
3683: LD_STRING Pavel Grigorovic
3685: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3686: LD_ADDR_OWVAR 33
3690: PUSH
3691: LD_STRING SecondCharsGal
3693: ST_TO_ADDR
// hc_face_number := 4 ;
3694: LD_ADDR_OWVAR 34
3698: PUSH
3699: LD_INT 4
3701: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3702: LD_ADDR_EXP 40
3706: PUSH
3707: LD_EXP 40
3711: PPUSH
3712: LD_INT 1
3714: PPUSH
3715: CALL_OW 44
3719: PPUSH
3720: CALL_OW 1
3724: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3725: LD_INT 2
3727: PPUSH
3728: LD_INT 4
3730: PPUSH
3731: LD_INT 2
3733: PPUSH
3734: CALL_OW 380
// hc_name := Lucy Sebel ;
3738: LD_ADDR_OWVAR 26
3742: PUSH
3743: LD_STRING Lucy Sebel
3745: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3746: LD_ADDR_OWVAR 33
3750: PUSH
3751: LD_STRING SecondCharsGal
3753: ST_TO_ADDR
// hc_face_number := 15 ;
3754: LD_ADDR_OWVAR 34
3758: PUSH
3759: LD_INT 15
3761: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3762: LD_ADDR_EXP 40
3766: PUSH
3767: LD_EXP 40
3771: PPUSH
3772: LD_INT 2
3774: PPUSH
3775: CALL_OW 44
3779: PPUSH
3780: CALL_OW 1
3784: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3785: LD_INT 2
3787: PPUSH
3788: LD_INT 4
3790: PPUSH
3791: LD_INT 2
3793: PPUSH
3794: CALL_OW 380
// hc_gallery :=  ;
3798: LD_ADDR_OWVAR 33
3802: PUSH
3803: LD_STRING 
3805: ST_TO_ADDR
// hc_name :=  ;
3806: LD_ADDR_OWVAR 26
3810: PUSH
3811: LD_STRING 
3813: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3814: LD_ADDR_EXP 40
3818: PUSH
3819: LD_EXP 40
3823: PPUSH
3824: LD_INT 3
3826: PPUSH
3827: CALL_OW 44
3831: PPUSH
3832: CALL_OW 1
3836: ST_TO_ADDR
// hc_sex := sex_male ;
3837: LD_ADDR_OWVAR 27
3841: PUSH
3842: LD_INT 1
3844: ST_TO_ADDR
// hc_class = 11 ;
3845: LD_ADDR_OWVAR 28
3849: PUSH
3850: LD_INT 11
3852: ST_TO_ADDR
// hc_gallery = sandar ;
3853: LD_ADDR_OWVAR 33
3857: PUSH
3858: LD_STRING sandar
3860: ST_TO_ADDR
// hc_face_number = 33 ;
3861: LD_ADDR_OWVAR 34
3865: PUSH
3866: LD_INT 33
3868: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3869: LD_ADDR_OWVAR 26
3873: PUSH
3874: LD_STRING Thabit Muhair Saliba
3876: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3877: LD_ADDR_OWVAR 31
3881: PUSH
3882: LD_INT 0
3884: PUSH
3885: LD_INT 0
3887: PUSH
3888: LD_INT 0
3890: PUSH
3891: LD_INT 0
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: ST_TO_ADDR
// Saliba = CreateHuman ;
3900: LD_ADDR_EXP 44
3904: PUSH
3905: CALL_OW 44
3909: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3910: LD_EXP 44
3914: PPUSH
3915: LD_INT 7
3917: PPUSH
3918: CALL_OW 52
// if gensher_active then
3922: LD_EXP 18
3926: IFFALSE 3953
// begin Gensher = NewCharacter ( Dietrich ) ;
3928: LD_ADDR_EXP 45
3932: PUSH
3933: LD_STRING Dietrich
3935: PPUSH
3936: CALL_OW 25
3940: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3941: LD_EXP 45
3945: PPUSH
3946: LD_INT 94
3948: PPUSH
3949: CALL_OW 52
// end ; InitHc ;
3953: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3957: LD_ADDR_EXP 41
3961: PUSH
3962: EMPTY
3963: ST_TO_ADDR
// for i = 1 to 5 do
3964: LD_ADDR_VAR 0 2
3968: PUSH
3969: DOUBLE
3970: LD_INT 1
3972: DEC
3973: ST_TO_ADDR
3974: LD_INT 5
3976: PUSH
3977: FOR_TO
3978: IFFALSE 4150
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3980: LD_INT 13
3982: PUSH
3983: LD_INT 14
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 2
3995: PPUSH
3996: CALL_OW 12
4000: ARRAY
4001: PPUSH
4002: LD_INT 1
4004: PUSH
4005: LD_INT 2
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: PUSH
4012: LD_INT 1
4014: PPUSH
4015: LD_INT 2
4017: PPUSH
4018: CALL_OW 12
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 25
4029: PUSH
4030: LD_INT 27
4032: PUSH
4033: LD_INT 26
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: LIST
4040: PUSH
4041: LD_INT 1
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 12
4051: ARRAY
4052: PPUSH
4053: LD_INT 60
4055: PPUSH
4056: LD_INT 100
4058: PPUSH
4059: CALL_OW 12
4063: PPUSH
4064: CALL 53889 0 5
// un := CreateVehicle ;
4068: LD_ADDR_VAR 0 4
4072: PUSH
4073: CALL_OW 45
4077: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4078: LD_ADDR_EXP 41
4082: PUSH
4083: LD_EXP 41
4087: PPUSH
4088: LD_EXP 41
4092: PUSH
4093: LD_INT 1
4095: PLUS
4096: PPUSH
4097: LD_VAR 0 4
4101: PPUSH
4102: CALL_OW 1
4106: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4107: LD_VAR 0 4
4111: PPUSH
4112: LD_INT 0
4114: PPUSH
4115: LD_INT 5
4117: PPUSH
4118: CALL_OW 12
4122: PPUSH
4123: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4127: LD_VAR 0 4
4131: PPUSH
4132: LD_INT 124
4134: PPUSH
4135: LD_INT 141
4137: PPUSH
4138: LD_INT 8
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 50
// end ;
4148: GO 3977
4150: POP
4151: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4152: LD_ADDR_EXP 43
4156: PUSH
4157: EMPTY
4158: PUSH
4159: EMPTY
4160: PUSH
4161: EMPTY
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: LIST
4167: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4168: LD_ADDR_VAR 0 3
4172: PUSH
4173: DOUBLE
4174: LD_INT 1
4176: DEC
4177: ST_TO_ADDR
4178: LD_INT 3
4180: PUSH
4181: LD_INT 3
4183: PUSH
4184: LD_INT 4
4186: PUSH
4187: LD_INT 4
4189: PUSH
4190: EMPTY
4191: LIST
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_OWVAR 67
4200: ARRAY
4201: PUSH
4202: FOR_TO
4203: IFFALSE 4417
// for i = 1 to 3 do
4205: LD_ADDR_VAR 0 2
4209: PUSH
4210: DOUBLE
4211: LD_INT 1
4213: DEC
4214: ST_TO_ADDR
4215: LD_INT 3
4217: PUSH
4218: FOR_TO
4219: IFFALSE 4413
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4221: LD_INT 14
4223: PPUSH
4224: LD_INT 3
4226: PUSH
4227: LD_INT 2
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_INT 2
4239: PPUSH
4240: CALL_OW 12
4244: ARRAY
4245: PPUSH
4246: LD_INT 1
4248: PUSH
4249: LD_INT 5
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 1
4258: PPUSH
4259: LD_INT 2
4261: PPUSH
4262: CALL_OW 12
4266: ARRAY
4267: PPUSH
4268: LD_INT 25
4270: PUSH
4271: LD_INT 27
4273: PUSH
4274: LD_INT 26
4276: PUSH
4277: LD_INT 28
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: PUSH
4286: LD_INT 1
4288: PPUSH
4289: LD_INT 4
4291: PPUSH
4292: CALL_OW 12
4296: ARRAY
4297: PPUSH
4298: LD_INT 100
4300: PPUSH
4301: CALL 53889 0 5
// un := CreateVehicle ;
4305: LD_ADDR_VAR 0 4
4309: PUSH
4310: CALL_OW 45
4314: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4315: LD_ADDR_EXP 43
4319: PUSH
4320: LD_EXP 43
4324: PPUSH
4325: LD_VAR 0 2
4329: PUSH
4330: LD_EXP 43
4334: PUSH
4335: LD_VAR 0 2
4339: ARRAY
4340: PUSH
4341: LD_INT 1
4343: PLUS
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PPUSH
4349: LD_VAR 0 4
4353: PPUSH
4354: CALL 54011 0 3
4358: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4359: LD_VAR 0 4
4363: PPUSH
4364: LD_INT 0
4366: PPUSH
4367: LD_INT 5
4369: PPUSH
4370: CALL_OW 12
4374: PPUSH
4375: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4379: LD_VAR 0 4
4383: PPUSH
4384: LD_INT 20
4386: PUSH
4387: LD_INT 21
4389: PUSH
4390: LD_INT 22
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: LIST
4397: PUSH
4398: LD_VAR 0 2
4402: ARRAY
4403: PPUSH
4404: LD_INT 0
4406: PPUSH
4407: CALL_OW 49
// end ;
4411: GO 4218
4413: POP
4414: POP
4415: GO 4202
4417: POP
4418: POP
// InitHc ;
4419: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4423: LD_INT 4
4425: PPUSH
4426: LD_INT 5
4428: PPUSH
4429: LD_INT 10
4431: PPUSH
4432: LD_INT 5
4434: PPUSH
4435: LD_INT 0
4437: PPUSH
4438: CALL_OW 58
// end ;
4442: LD_VAR 0 1
4446: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4447: LD_EXP 42
4451: IFFALSE 4525
4453: GO 4455
4455: DISABLE
4456: LD_INT 0
4458: PPUSH
// begin enable ;
4459: ENABLE
// for i in ar_kamikadze do
4460: LD_ADDR_VAR 0 1
4464: PUSH
4465: LD_EXP 42
4469: PUSH
4470: FOR_IN
4471: IFFALSE 4523
// if See ( 1 , i ) then
4473: LD_INT 1
4475: PPUSH
4476: LD_VAR 0 1
4480: PPUSH
4481: CALL_OW 292
4485: IFFALSE 4521
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4487: LD_VAR 0 1
4491: PPUSH
4492: LD_INT 81
4494: PUSH
4495: LD_INT 2
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: PPUSH
4502: CALL_OW 69
4506: PPUSH
4507: LD_VAR 0 1
4511: PPUSH
4512: CALL_OW 74
4516: PPUSH
4517: CALL_OW 115
4521: GO 4470
4523: POP
4524: POP
// end ;
4525: PPOPN 1
4527: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4528: LD_EXP 13
4532: IFFALSE 4849
4534: GO 4536
4536: DISABLE
4537: LD_INT 0
4539: PPUSH
4540: PPUSH
4541: PPUSH
4542: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4543: LD_INT 35
4545: PPUSH
4546: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4550: LD_INT 1
4552: PPUSH
4553: CALL 42887 0 1
4557: PUSH
4558: LD_INT 0
4560: EQUAL
4561: IFFALSE 4543
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4563: LD_INT 1
4565: PPUSH
4566: LD_INT 14
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: LD_INT 2
4574: PUSH
4575: LD_INT 32
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: PUSH
4584: EMPTY
4585: LIST
4586: PPUSH
4587: CALL 42491 0 2
// repeat wait ( 0 0$1 ) ;
4591: LD_INT 35
4593: PPUSH
4594: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4598: LD_EXP 69
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PPUSH
4607: LD_INT 33
4609: PUSH
4610: LD_INT 2
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PUSH
4617: LD_INT 34
4619: PUSH
4620: LD_INT 32
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PUSH
4627: EMPTY
4628: LIST
4629: LIST
4630: PPUSH
4631: CALL_OW 72
4635: IFFALSE 4591
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4637: LD_ADDR_VAR 0 2
4641: PUSH
4642: LD_EXP 69
4646: PUSH
4647: LD_INT 1
4649: ARRAY
4650: PPUSH
4651: LD_INT 33
4653: PUSH
4654: LD_INT 2
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: PUSH
4661: LD_INT 34
4663: PUSH
4664: LD_INT 32
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: EMPTY
4672: LIST
4673: LIST
4674: PPUSH
4675: CALL_OW 72
4679: PUSH
4680: LD_INT 1
4682: ARRAY
4683: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4684: LD_ADDR_VAR 0 4
4688: PUSH
4689: LD_INT 5
4691: PPUSH
4692: CALL_OW 469
4696: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4697: LD_INT 35
4699: PPUSH
4700: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4704: LD_ADDR_VAR 0 4
4708: PUSH
4709: LD_INT 5
4711: PPUSH
4712: CALL_OW 469
4716: ST_TO_ADDR
// tmp := 100 ;
4717: LD_ADDR_VAR 0 3
4721: PUSH
4722: LD_INT 100
4724: ST_TO_ADDR
// if pos then
4725: LD_VAR 0 4
4729: IFFALSE 4769
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4731: LD_ADDR_VAR 0 3
4735: PUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_VAR 0 4
4743: PUSH
4744: LD_INT 1
4746: ARRAY
4747: PPUSH
4748: LD_VAR 0 4
4752: PUSH
4753: LD_INT 2
4755: ARRAY
4756: PPUSH
4757: LD_INT 20
4759: PPUSH
4760: CALL 55275 0 4
4764: PUSH
4765: LD_INT 4
4767: ARRAY
4768: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4769: LD_VAR 0 4
4773: PUSH
4774: LD_EXP 14
4778: NOT
4779: AND
4780: PUSH
4781: LD_VAR 0 3
4785: PUSH
4786: LD_INT 10
4788: LESS
4789: AND
4790: IFFALSE 4697
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4792: LD_VAR 0 2
4796: PPUSH
4797: LD_VAR 0 4
4801: PUSH
4802: LD_INT 1
4804: ARRAY
4805: PPUSH
4806: LD_VAR 0 4
4810: PUSH
4811: LD_INT 2
4813: ARRAY
4814: PPUSH
4815: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4819: LD_VAR 0 2
4823: PPUSH
4824: LD_INT 198
4826: PPUSH
4827: LD_INT 113
4829: PPUSH
4830: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4834: LD_VAR 0 2
4838: PPUSH
4839: LD_INT 124
4841: PPUSH
4842: LD_INT 7
4844: PPUSH
4845: CALL_OW 171
// end ;
4849: PPOPN 4
4851: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
4852: LD_EXP 6
4856: IFFALSE 6819
4858: GO 4860
4860: DISABLE
4861: LD_INT 0
4863: PPUSH
4864: PPUSH
4865: PPUSH
4866: PPUSH
4867: PPUSH
4868: PPUSH
4869: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
4870: LD_ADDR_VAR 0 4
4874: PUSH
4875: LD_INT 5
4877: PUSH
4878: LD_INT 6
4880: PUSH
4881: LD_INT 7
4883: PUSH
4884: LD_INT 8
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: PUSH
4893: LD_OWVAR 67
4897: ARRAY
4898: ST_TO_ADDR
// coords := [ ] ;
4899: LD_ADDR_VAR 0 5
4903: PUSH
4904: EMPTY
4905: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4906: LD_ADDR_VAR 0 6
4910: PUSH
4911: LD_INT 0
4913: PUSH
4914: LD_INT 0
4916: PUSH
4917: LD_INT 0
4919: PUSH
4920: LD_INT 0
4922: PUSH
4923: LD_INT 1
4925: PUSH
4926: LD_INT 0
4928: PUSH
4929: LD_INT 0
4931: PUSH
4932: LD_INT 0
4934: PUSH
4935: LD_INT 1
4937: PUSH
4938: LD_INT 0
4940: PUSH
4941: EMPTY
4942: LIST
4943: LIST
4944: LIST
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: LIST
4952: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4953: LD_INT 1
4955: PPUSH
4956: LD_INT 14
4958: PUSH
4959: LD_INT 1
4961: PUSH
4962: LD_INT 2
4964: PUSH
4965: LD_INT 28
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: PUSH
4974: LD_INT 14
4976: PUSH
4977: LD_INT 1
4979: PUSH
4980: LD_INT 2
4982: PUSH
4983: LD_INT 25
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: PUSH
4992: LD_INT 14
4994: PUSH
4995: LD_INT 1
4997: PUSH
4998: LD_INT 2
5000: PUSH
5001: LD_INT 28
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: PUSH
5010: LD_INT 14
5012: PUSH
5013: LD_INT 1
5015: PUSH
5016: LD_INT 2
5018: PUSH
5019: LD_INT 29
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: LIST
5026: LIST
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: PPUSH
5034: CALL 42491 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5038: LD_INT 21000
5040: PUSH
5041: LD_INT 19950
5043: PUSH
5044: LD_INT 18900
5046: PUSH
5047: LD_INT 18200
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: PUSH
5056: LD_OWVAR 67
5060: ARRAY
5061: PPUSH
5062: CALL_OW 67
// InitHc ;
5066: CALL_OW 19
// InitUc ;
5070: CALL_OW 18
// uc_side := 2 ;
5074: LD_ADDR_OWVAR 20
5078: PUSH
5079: LD_INT 2
5081: ST_TO_ADDR
// uc_nation := 2 ;
5082: LD_ADDR_OWVAR 21
5086: PUSH
5087: LD_INT 2
5089: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5090: LD_ADDR_VAR 0 3
5094: PUSH
5095: EMPTY
5096: PUSH
5097: EMPTY
5098: PUSH
5099: EMPTY
5100: PUSH
5101: EMPTY
5102: PUSH
5103: EMPTY
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5112: LD_ADDR_VAR 0 3
5116: PUSH
5117: LD_VAR 0 3
5121: PPUSH
5122: LD_INT 1
5124: PPUSH
5125: LD_EXP 69
5129: PUSH
5130: LD_INT 1
5132: ARRAY
5133: PUSH
5134: LD_INT 2
5136: PUSH
5137: LD_INT 34
5139: PUSH
5140: LD_INT 88
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 34
5149: PUSH
5150: LD_INT 32
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: PPUSH
5162: CALL_OW 69
5166: DIFF
5167: PPUSH
5168: CALL_OW 1
5172: ST_TO_ADDR
// for i = 1 to Difficulty do
5173: LD_ADDR_VAR 0 1
5177: PUSH
5178: DOUBLE
5179: LD_INT 1
5181: DEC
5182: ST_TO_ADDR
5183: LD_OWVAR 67
5187: PUSH
5188: FOR_TO
5189: IFFALSE 5327
// begin uc_side := 2 ;
5191: LD_ADDR_OWVAR 20
5195: PUSH
5196: LD_INT 2
5198: ST_TO_ADDR
// uc_nation := 2 ;
5199: LD_ADDR_OWVAR 21
5203: PUSH
5204: LD_INT 2
5206: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5207: LD_INT 13
5209: PPUSH
5210: LD_INT 3
5212: PPUSH
5213: LD_INT 5
5215: PPUSH
5216: LD_INT 29
5218: PPUSH
5219: LD_INT 100
5221: PPUSH
5222: CALL 53889 0 5
// un := CreateVehicle ;
5226: LD_ADDR_VAR 0 2
5230: PUSH
5231: CALL_OW 45
5235: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5236: LD_ADDR_VAR 0 3
5240: PUSH
5241: LD_VAR 0 3
5245: PPUSH
5246: LD_INT 1
5248: PUSH
5249: LD_VAR 0 3
5253: PUSH
5254: LD_INT 1
5256: ARRAY
5257: PUSH
5258: LD_INT 1
5260: PLUS
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PPUSH
5266: LD_VAR 0 2
5270: PPUSH
5271: CALL 54011 0 3
5275: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5276: LD_VAR 0 2
5280: PPUSH
5281: LD_INT 3
5283: PPUSH
5284: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5288: LD_VAR 0 2
5292: PPUSH
5293: LD_INT 16
5295: PPUSH
5296: LD_INT 0
5298: PPUSH
5299: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5303: LD_VAR 0 2
5307: PPUSH
5308: LD_INT 51
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 111
// wait ( 0 0$2 ) ;
5318: LD_INT 70
5320: PPUSH
5321: CALL_OW 67
// end ;
5325: GO 5188
5327: POP
5328: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5329: LD_ADDR_VAR 0 5
5333: PUSH
5334: LD_INT 51
5336: PUSH
5337: LD_INT 24
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: PUSH
5344: LD_INT 75
5346: PUSH
5347: LD_INT 90
5349: PUSH
5350: EMPTY
5351: LIST
5352: LIST
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PUSH
5366: LD_INT 1
5368: ARRAY
5369: PPUSH
5370: LD_VAR 0 5
5374: PPUSH
5375: LD_VAR 0 6
5379: PPUSH
5380: CALL 42724 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5384: LD_ADDR_VAR 0 1
5388: PUSH
5389: DOUBLE
5390: LD_INT 1
5392: DEC
5393: ST_TO_ADDR
5394: LD_INT 1
5396: PUSH
5397: LD_INT 3
5399: PUSH
5400: LD_INT 4
5402: PUSH
5403: LD_INT 5
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_OWVAR 67
5416: ARRAY
5417: PUSH
5418: FOR_TO
5419: IFFALSE 5519
// begin uc_side := 2 ;
5421: LD_ADDR_OWVAR 20
5425: PUSH
5426: LD_INT 2
5428: ST_TO_ADDR
// uc_nation := 2 ;
5429: LD_ADDR_OWVAR 21
5433: PUSH
5434: LD_INT 2
5436: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5437: LD_INT 0
5439: PPUSH
5440: LD_INT 17
5442: PPUSH
5443: LD_VAR 0 4
5447: PPUSH
5448: CALL_OW 380
// un := CreateHuman ;
5452: LD_ADDR_VAR 0 2
5456: PUSH
5457: CALL_OW 44
5461: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5462: LD_ADDR_VAR 0 3
5466: PUSH
5467: LD_VAR 0 3
5471: PPUSH
5472: LD_INT 2
5474: PUSH
5475: LD_VAR 0 3
5479: PUSH
5480: LD_INT 2
5482: ARRAY
5483: PUSH
5484: LD_INT 1
5486: PLUS
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: PPUSH
5492: LD_VAR 0 2
5496: PPUSH
5497: CALL 54011 0 3
5501: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5502: LD_VAR 0 2
5506: PPUSH
5507: LD_INT 13
5509: PPUSH
5510: LD_INT 0
5512: PPUSH
5513: CALL_OW 49
// end ;
5517: GO 5418
5519: POP
5520: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5521: LD_ADDR_VAR 0 1
5525: PUSH
5526: DOUBLE
5527: LD_INT 1
5529: DEC
5530: ST_TO_ADDR
5531: LD_INT 3
5533: PUSH
5534: LD_INT 4
5536: PUSH
5537: LD_INT 5
5539: PUSH
5540: LD_INT 6
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_OWVAR 67
5553: ARRAY
5554: PUSH
5555: FOR_TO
5556: IFFALSE 5677
// begin uc_side := 2 ;
5558: LD_ADDR_OWVAR 20
5562: PUSH
5563: LD_INT 2
5565: ST_TO_ADDR
// uc_nation := 2 ;
5566: LD_ADDR_OWVAR 21
5570: PUSH
5571: LD_INT 2
5573: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5574: LD_INT 0
5576: PPUSH
5577: LD_INT 1
5579: PUSH
5580: LD_INT 8
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: PUSH
5587: LD_VAR 0 1
5591: PUSH
5592: LD_INT 2
5594: MOD
5595: PUSH
5596: LD_INT 1
5598: PLUS
5599: ARRAY
5600: PPUSH
5601: LD_VAR 0 4
5605: PPUSH
5606: CALL_OW 380
// un := CreateHuman ;
5610: LD_ADDR_VAR 0 2
5614: PUSH
5615: CALL_OW 44
5619: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5620: LD_ADDR_VAR 0 3
5624: PUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: LD_INT 2
5632: PUSH
5633: LD_VAR 0 3
5637: PUSH
5638: LD_INT 2
5640: ARRAY
5641: PUSH
5642: LD_INT 1
5644: PLUS
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: PPUSH
5650: LD_VAR 0 2
5654: PPUSH
5655: CALL 54011 0 3
5659: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5660: LD_VAR 0 2
5664: PPUSH
5665: LD_INT 13
5667: PPUSH
5668: LD_INT 0
5670: PPUSH
5671: CALL_OW 49
// end ;
5675: GO 5555
5677: POP
5678: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5679: LD_ADDR_VAR 0 5
5683: PUSH
5684: LD_INT 67
5686: PUSH
5687: LD_INT 112
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PUSH
5694: LD_INT 85
5696: PUSH
5697: LD_INT 130
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5708: LD_INT 2
5710: PPUSH
5711: LD_VAR 0 3
5715: PUSH
5716: LD_INT 2
5718: ARRAY
5719: PPUSH
5720: LD_VAR 0 5
5724: PPUSH
5725: LD_VAR 0 6
5729: PPUSH
5730: CALL 42724 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 1
5746: PUSH
5747: LD_INT 2
5749: PUSH
5750: LD_INT 3
5752: PUSH
5753: LD_INT 5
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_OWVAR 67
5766: ARRAY
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5869
// begin uc_side := 2 ;
5771: LD_ADDR_OWVAR 20
5775: PUSH
5776: LD_INT 2
5778: ST_TO_ADDR
// uc_nation := 2 ;
5779: LD_ADDR_OWVAR 21
5783: PUSH
5784: LD_INT 2
5786: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5787: LD_INT 0
5789: PPUSH
5790: LD_INT 17
5792: PPUSH
5793: LD_VAR 0 4
5797: PPUSH
5798: CALL_OW 380
// un := CreateHuman ;
5802: LD_ADDR_VAR 0 2
5806: PUSH
5807: CALL_OW 44
5811: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5812: LD_ADDR_VAR 0 3
5816: PUSH
5817: LD_VAR 0 3
5821: PPUSH
5822: LD_INT 3
5824: PUSH
5825: LD_VAR 0 3
5829: PUSH
5830: LD_INT 3
5832: ARRAY
5833: PUSH
5834: LD_INT 1
5836: PLUS
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: PPUSH
5842: LD_VAR 0 2
5846: PPUSH
5847: CALL 54011 0 3
5851: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5852: LD_VAR 0 2
5856: PPUSH
5857: LD_INT 14
5859: PPUSH
5860: LD_INT 0
5862: PPUSH
5863: CALL_OW 49
// end ;
5867: GO 5768
5869: POP
5870: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5871: LD_ADDR_VAR 0 5
5875: PUSH
5876: LD_INT 148
5878: PUSH
5879: LD_INT 158
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 148
5888: PUSH
5889: LD_INT 158
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5900: LD_INT 3
5902: PPUSH
5903: LD_VAR 0 3
5907: PUSH
5908: LD_INT 3
5910: ARRAY
5911: PPUSH
5912: LD_VAR 0 5
5916: PPUSH
5917: LD_VAR 0 6
5921: PPUSH
5922: CALL 42724 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
5926: LD_ADDR_VAR 0 1
5930: PUSH
5931: DOUBLE
5932: LD_INT 1
5934: DEC
5935: ST_TO_ADDR
5936: LD_INT 2
5938: PUSH
5939: LD_INT 3
5941: PUSH
5942: LD_INT 4
5944: PUSH
5945: LD_INT 5
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: LIST
5952: LIST
5953: PUSH
5954: LD_OWVAR 67
5958: ARRAY
5959: PUSH
5960: FOR_TO
5961: IFFALSE 6185
// begin uc_side := 2 ;
5963: LD_ADDR_OWVAR 20
5967: PUSH
5968: LD_INT 2
5970: ST_TO_ADDR
// uc_nation := 2 ;
5971: LD_ADDR_OWVAR 21
5975: PUSH
5976: LD_INT 2
5978: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5979: LD_INT 14
5981: PPUSH
5982: LD_INT 3
5984: PPUSH
5985: LD_INT 1
5987: PUSH
5988: LD_INT 5
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 1
5997: PPUSH
5998: LD_INT 2
6000: PPUSH
6001: CALL_OW 12
6005: ARRAY
6006: PPUSH
6007: LD_INT 27
6009: PUSH
6010: LD_INT 26
6012: PUSH
6013: LD_INT 28
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: PUSH
6021: LD_INT 1
6023: PPUSH
6024: LD_INT 3
6026: PPUSH
6027: CALL_OW 12
6031: ARRAY
6032: PPUSH
6033: LD_INT 100
6035: PPUSH
6036: CALL 53889 0 5
// un := CreateVehicle ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: CALL_OW 45
6049: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6050: LD_ADDR_VAR 0 3
6054: PUSH
6055: LD_VAR 0 3
6059: PPUSH
6060: LD_INT 4
6062: PUSH
6063: LD_VAR 0 3
6067: PUSH
6068: LD_INT 4
6070: ARRAY
6071: PUSH
6072: LD_INT 1
6074: PLUS
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PPUSH
6080: LD_VAR 0 2
6084: PPUSH
6085: CALL 54011 0 3
6089: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6090: LD_VAR 0 2
6094: PPUSH
6095: LD_INT 5
6097: PPUSH
6098: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6102: LD_VAR 0 2
6106: PPUSH
6107: LD_INT 15
6109: PPUSH
6110: LD_INT 0
6112: PPUSH
6113: CALL_OW 49
// if GetControl ( un ) = control_manual then
6117: LD_VAR 0 2
6121: PPUSH
6122: CALL_OW 263
6126: PUSH
6127: LD_INT 1
6129: EQUAL
6130: IFFALSE 6161
// begin PrepareHuman ( false , 3 , skill ) ;
6132: LD_INT 0
6134: PPUSH
6135: LD_INT 3
6137: PPUSH
6138: LD_VAR 0 4
6142: PPUSH
6143: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6147: CALL_OW 44
6151: PPUSH
6152: LD_VAR 0 2
6156: PPUSH
6157: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6161: LD_VAR 0 2
6165: PPUSH
6166: LD_INT 179
6168: PPUSH
6169: LD_INT 135
6171: PPUSH
6172: CALL_OW 111
// wait ( 0 0$2 ) ;
6176: LD_INT 70
6178: PPUSH
6179: CALL_OW 67
// end ;
6183: GO 5960
6185: POP
6186: POP
// vc_chassis := 15 ;
6187: LD_ADDR_OWVAR 37
6191: PUSH
6192: LD_INT 15
6194: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6195: LD_ADDR_VAR 0 3
6199: PUSH
6200: LD_VAR 0 3
6204: PPUSH
6205: LD_INT 4
6207: PUSH
6208: LD_VAR 0 3
6212: PUSH
6213: LD_INT 4
6215: ARRAY
6216: PUSH
6217: LD_INT 1
6219: PLUS
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 45
6229: PPUSH
6230: CALL 54011 0 3
6234: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6235: LD_VAR 0 3
6239: PUSH
6240: LD_INT 4
6242: ARRAY
6243: PUSH
6244: LD_VAR 0 3
6248: PUSH
6249: LD_INT 4
6251: ARRAY
6252: ARRAY
6253: PPUSH
6254: LD_INT 15
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6264: LD_INT 0
6266: PPUSH
6267: LD_INT 11
6269: PPUSH
6270: LD_VAR 0 4
6274: PPUSH
6275: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6279: LD_ADDR_VAR 0 3
6283: PUSH
6284: LD_VAR 0 3
6288: PPUSH
6289: LD_INT 4
6291: PUSH
6292: LD_VAR 0 3
6296: PUSH
6297: LD_INT 4
6299: ARRAY
6300: PUSH
6301: LD_INT 1
6303: PLUS
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PPUSH
6309: CALL_OW 44
6313: PPUSH
6314: CALL 54011 0 3
6318: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6319: LD_VAR 0 3
6323: PUSH
6324: LD_INT 4
6326: ARRAY
6327: PUSH
6328: LD_VAR 0 3
6332: PUSH
6333: LD_INT 4
6335: ARRAY
6336: ARRAY
6337: PPUSH
6338: LD_VAR 0 3
6342: PUSH
6343: LD_INT 4
6345: ARRAY
6346: PUSH
6347: LD_VAR 0 3
6351: PUSH
6352: LD_INT 4
6354: ARRAY
6355: PUSH
6356: LD_INT 1
6358: MINUS
6359: ARRAY
6360: PPUSH
6361: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6365: LD_ADDR_VAR 0 5
6369: PUSH
6370: LD_INT 148
6372: PUSH
6373: LD_INT 140
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: PUSH
6380: EMPTY
6381: LIST
6382: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6383: LD_INT 1
6385: PPUSH
6386: LD_VAR 0 3
6390: PUSH
6391: LD_INT 4
6393: ARRAY
6394: PPUSH
6395: LD_VAR 0 5
6399: PPUSH
6400: LD_VAR 0 6
6404: PPUSH
6405: CALL 42724 0 4
// if gensher_active then
6409: LD_EXP 18
6413: IFFALSE 6819
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6415: LD_EXP 45
6419: PPUSH
6420: LD_STRING D10-Diet-1
6422: PPUSH
6423: CALL_OW 94
// for i = 1 to 2 do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: DOUBLE
6433: LD_INT 1
6435: DEC
6436: ST_TO_ADDR
6437: LD_INT 2
6439: PUSH
6440: FOR_TO
6441: IFFALSE 6579
// begin uc_side := 2 ;
6443: LD_ADDR_OWVAR 20
6447: PUSH
6448: LD_INT 2
6450: ST_TO_ADDR
// uc_nation := 2 ;
6451: LD_ADDR_OWVAR 21
6455: PUSH
6456: LD_INT 2
6458: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6459: LD_INT 13
6461: PPUSH
6462: LD_INT 3
6464: PPUSH
6465: LD_INT 5
6467: PPUSH
6468: LD_INT 29
6470: PPUSH
6471: LD_INT 100
6473: PPUSH
6474: CALL 53889 0 5
// un := CreateVehicle ;
6478: LD_ADDR_VAR 0 2
6482: PUSH
6483: CALL_OW 45
6487: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6488: LD_ADDR_VAR 0 3
6492: PUSH
6493: LD_VAR 0 3
6497: PPUSH
6498: LD_INT 5
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_INT 5
6508: ARRAY
6509: PUSH
6510: LD_INT 1
6512: PLUS
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: PPUSH
6518: LD_VAR 0 2
6522: PPUSH
6523: CALL 54011 0 3
6527: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6528: LD_VAR 0 2
6532: PPUSH
6533: LD_INT 0
6535: PPUSH
6536: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6540: LD_VAR 0 2
6544: PPUSH
6545: LD_INT 23
6547: PPUSH
6548: LD_INT 0
6550: PPUSH
6551: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6555: LD_VAR 0 2
6559: PPUSH
6560: LD_INT 85
6562: PPUSH
6563: LD_INT 152
6565: PPUSH
6566: CALL_OW 111
// wait ( 0 0$2 ) ;
6570: LD_INT 70
6572: PPUSH
6573: CALL_OW 67
// end ;
6577: GO 6440
6579: POP
6580: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6581: LD_ADDR_VAR 0 1
6585: PUSH
6586: DOUBLE
6587: LD_INT 1
6589: DEC
6590: ST_TO_ADDR
6591: LD_INT 2
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: LD_INT 3
6599: PUSH
6600: LD_INT 4
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: PUSH
6609: LD_OWVAR 67
6613: ARRAY
6614: PUSH
6615: FOR_TO
6616: IFFALSE 6773
// begin uc_side := 2 ;
6618: LD_ADDR_OWVAR 20
6622: PUSH
6623: LD_INT 2
6625: ST_TO_ADDR
// uc_nation := 2 ;
6626: LD_ADDR_OWVAR 21
6630: PUSH
6631: LD_INT 2
6633: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6634: LD_INT 14
6636: PPUSH
6637: LD_INT 3
6639: PPUSH
6640: LD_INT 5
6642: PPUSH
6643: LD_INT 27
6645: PUSH
6646: LD_INT 28
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 2
6658: PPUSH
6659: CALL_OW 12
6663: ARRAY
6664: PPUSH
6665: LD_INT 100
6667: PPUSH
6668: CALL 53889 0 5
// un := CreateVehicle ;
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: CALL_OW 45
6681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6682: LD_ADDR_VAR 0 3
6686: PUSH
6687: LD_VAR 0 3
6691: PPUSH
6692: LD_INT 5
6694: PUSH
6695: LD_VAR 0 3
6699: PUSH
6700: LD_INT 5
6702: ARRAY
6703: PUSH
6704: LD_INT 1
6706: PLUS
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PPUSH
6712: LD_VAR 0 2
6716: PPUSH
6717: CALL 54011 0 3
6721: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 0
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 23
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 85
6756: PPUSH
6757: LD_INT 152
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6615
6773: POP
6774: POP
// coords := [ [ 97 , 143 ] ] ;
6775: LD_ADDR_VAR 0 5
6779: PUSH
6780: LD_INT 97
6782: PUSH
6783: LD_INT 143
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PUSH
6790: EMPTY
6791: LIST
6792: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6793: LD_INT 1
6795: PPUSH
6796: LD_VAR 0 3
6800: PUSH
6801: LD_INT 5
6803: ARRAY
6804: PPUSH
6805: LD_VAR 0 5
6809: PPUSH
6810: LD_VAR 0 6
6814: PPUSH
6815: CALL 42724 0 4
// end ; end ;
6819: PPOPN 7
6821: END
// every 5 5$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
6822: GO 6824
6824: DISABLE
6825: LD_INT 0
6827: PPUSH
6828: PPUSH
6829: PPUSH
6830: PPUSH
6831: PPUSH
6832: PPUSH
6833: PPUSH
// begin enable ;
6834: ENABLE
// tmp := [ ] ;
6835: LD_ADDR_VAR 0 2
6839: PUSH
6840: EMPTY
6841: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
6842: LD_ADDR_VAR 0 5
6846: PUSH
6847: LD_INT 1
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: CALL_OW 12
6857: ST_TO_ADDR
// if w = 3 then
6858: LD_VAR 0 5
6862: PUSH
6863: LD_INT 3
6865: EQUAL
6866: IFFALSE 6953
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6868: LD_ADDR_VAR 0 6
6872: PUSH
6873: LD_INT 11
6875: PUSH
6876: LD_INT 1
6878: PUSH
6879: LD_INT 2
6881: PUSH
6882: LD_INT 24
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 11
6893: PUSH
6894: LD_INT 1
6896: PUSH
6897: LD_INT 2
6899: PUSH
6900: LD_INT 24
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: LIST
6907: LIST
6908: PUSH
6909: LD_INT 11
6911: PUSH
6912: LD_INT 1
6914: PUSH
6915: LD_INT 2
6917: PUSH
6918: LD_INT 24
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: PUSH
6927: LD_INT 11
6929: PUSH
6930: LD_INT 1
6932: PUSH
6933: LD_INT 2
6935: PUSH
6936: LD_INT 24
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: ST_TO_ADDR
6951: GO 7055
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
6953: LD_ADDR_VAR 0 6
6957: PUSH
6958: LD_INT 14
6960: PUSH
6961: LD_INT 1
6963: PUSH
6964: LD_INT 2
6966: PUSH
6967: LD_INT 28
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: PUSH
6976: LD_INT 14
6978: PUSH
6979: LD_INT 1
6981: PUSH
6982: LD_INT 2
6984: PUSH
6985: LD_INT 25
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 14
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: LD_INT 2
7002: PUSH
7003: LD_INT 28
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 14
7014: PUSH
7015: LD_INT 1
7017: PUSH
7018: LD_INT 2
7020: PUSH
7021: LD_INT 29
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 14
7032: PUSH
7033: LD_INT 1
7035: PUSH
7036: LD_INT 2
7038: PUSH
7039: LD_INT 29
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: LIST
7052: LIST
7053: LIST
7054: ST_TO_ADDR
// if w < 3 then
7055: LD_VAR 0 5
7059: PUSH
7060: LD_INT 3
7062: LESS
7063: IFFALSE 7143
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7065: LD_ADDR_VAR 0 6
7069: PUSH
7070: LD_VAR 0 6
7074: PPUSH
7075: LD_INT 1
7077: PUSH
7078: LD_VAR 0 6
7082: PUSH
7083: LD_VAR 0 1
7087: ARRAY
7088: PUSH
7089: LD_INT 1
7091: PLUS
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: PPUSH
7097: LD_INT 14
7099: PUSH
7100: LD_INT 1
7102: PUSH
7103: LD_INT 2
7105: PUSH
7106: LD_INT 25
7108: PUSH
7109: LD_INT 28
7111: PUSH
7112: LD_INT 29
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_INT 1
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: CALL_OW 12
7130: ARRAY
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: PPUSH
7138: CALL 54011 0 3
7142: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7143: LD_INT 1
7145: PPUSH
7146: LD_VAR 0 6
7150: PPUSH
7151: CALL 42491 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7155: LD_INT 45
7157: PPUSH
7158: CALL_OW 255
7162: PUSH
7163: LD_INT 2
7165: EQUAL
7166: PUSH
7167: LD_INT 45
7169: PPUSH
7170: CALL_OW 302
7174: AND
7175: PUSH
7176: LD_VAR 0 5
7180: PUSH
7181: LD_INT 3
7183: LESS
7184: AND
7185: IFFALSE 7270
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7187: LD_ADDR_VAR 0 6
7191: PUSH
7192: LD_INT 14
7194: PUSH
7195: LD_INT 1
7197: PUSH
7198: LD_INT 2
7200: PUSH
7201: LD_INT 28
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: LIST
7208: LIST
7209: PUSH
7210: LD_INT 14
7212: PUSH
7213: LD_INT 1
7215: PUSH
7216: LD_INT 2
7218: PUSH
7219: LD_INT 27
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: PUSH
7228: LD_INT 14
7230: PUSH
7231: LD_INT 1
7233: PUSH
7234: LD_INT 2
7236: PUSH
7237: LD_INT 27
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: LIST
7244: LIST
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7251: LD_INT 2
7253: PPUSH
7254: LD_VAR 0 6
7258: PPUSH
7259: CALL 42491 0 2
// wait ( 0 0$20 ) ;
7263: LD_INT 700
7265: PPUSH
7266: CALL_OW 67
// end ; p := 60 ;
7270: LD_ADDR_VAR 0 7
7274: PUSH
7275: LD_INT 60
7277: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7278: LD_INT 35
7280: PPUSH
7281: CALL_OW 67
// p := Dec ( p ) ;
7285: LD_ADDR_VAR 0 7
7289: PUSH
7290: LD_VAR 0 7
7294: PPUSH
7295: CALL 88143 0 1
7299: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) >= 4 or p <= 0 ;
7300: LD_EXP 69
7304: PUSH
7305: LD_INT 1
7307: ARRAY
7308: PPUSH
7309: LD_INT 3
7311: PUSH
7312: LD_INT 34
7314: PUSH
7315: LD_INT 32
7317: PUSH
7318: EMPTY
7319: LIST
7320: LIST
7321: PUSH
7322: LD_INT 34
7324: PUSH
7325: LD_INT 88
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: LIST
7336: PPUSH
7337: CALL_OW 72
7341: PUSH
7342: LD_INT 4
7344: GREATEREQUAL
7345: PUSH
7346: LD_VAR 0 7
7350: PUSH
7351: LD_INT 0
7353: LESSEQUAL
7354: OR
7355: IFFALSE 7278
// wait ( 0 0$10 ) ;
7357: LD_INT 350
7359: PPUSH
7360: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7364: LD_ADDR_VAR 0 2
7368: PUSH
7369: LD_EXP 69
7373: PUSH
7374: LD_INT 1
7376: ARRAY
7377: PPUSH
7378: LD_INT 3
7380: PUSH
7381: LD_INT 34
7383: PUSH
7384: LD_INT 32
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: PUSH
7391: LD_INT 34
7393: PUSH
7394: LD_INT 88
7396: PUSH
7397: EMPTY
7398: LIST
7399: LIST
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: LIST
7405: PPUSH
7406: CALL_OW 72
7410: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7411: LD_ADDR_VAR 0 3
7415: PUSH
7416: LD_EXP 69
7420: PUSH
7421: LD_INT 2
7423: ARRAY
7424: PPUSH
7425: LD_INT 3
7427: PUSH
7428: LD_INT 34
7430: PUSH
7431: LD_INT 32
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: LD_INT 34
7440: PUSH
7441: LD_INT 88
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PPUSH
7453: CALL_OW 72
7457: ST_TO_ADDR
// if tmp2 then
7458: LD_VAR 0 3
7462: IFFALSE 7480
// tmp := tmp union tmp2 ;
7464: LD_ADDR_VAR 0 2
7468: PUSH
7469: LD_VAR 0 2
7473: PUSH
7474: LD_VAR 0 3
7478: UNION
7479: ST_TO_ADDR
// if not tmp then
7480: LD_VAR 0 2
7484: NOT
7485: IFFALSE 7489
// exit ;
7487: GO 7870
// if Count ( tmp2 ) or Prob ( 50 ) then
7489: LD_VAR 0 3
7493: PPUSH
7494: CALL 51151 0 1
7498: PUSH
7499: LD_INT 50
7501: PPUSH
7502: CALL_OW 13
7506: OR
7507: IFFALSE 7540
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7509: LD_ADDR_VAR 0 4
7513: PUSH
7514: LD_INT 48
7516: PUSH
7517: LD_INT 33
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PUSH
7524: LD_INT 71
7526: PUSH
7527: LD_INT 88
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: ST_TO_ADDR
7538: GO 7569
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7540: LD_ADDR_VAR 0 4
7544: PUSH
7545: LD_INT 128
7547: PUSH
7548: LD_INT 94
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: LD_INT 180
7557: PUSH
7558: LD_INT 135
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: ST_TO_ADDR
// if w = 3 then
7569: LD_VAR 0 5
7573: PUSH
7574: LD_INT 3
7576: EQUAL
7577: IFFALSE 7608
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7579: LD_ADDR_VAR 0 4
7583: PUSH
7584: LD_INT 91
7586: PUSH
7587: LD_INT 58
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: PUSH
7594: LD_INT 117
7596: PUSH
7597: LD_INT 107
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7608: LD_INT 28
7610: PPUSH
7611: LD_INT 22
7613: PUSH
7614: LD_INT 1
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PPUSH
7621: CALL_OW 70
7625: IFFALSE 7645
// coords := [ [ 163 , 41 ] ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 163
7634: PUSH
7635: LD_INT 41
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: EMPTY
7643: LIST
7644: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7645: LD_VAR 0 2
7649: PPUSH
7650: LD_VAR 0 4
7654: PUSH
7655: LD_INT 1
7657: ARRAY
7658: PPUSH
7659: LD_VAR 0 4
7663: PUSH
7664: LD_INT 2
7666: ARRAY
7667: PPUSH
7668: CALL_OW 114
// p := 30 ;
7672: LD_ADDR_VAR 0 7
7676: PUSH
7677: LD_INT 30
7679: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7680: LD_INT 35
7682: PPUSH
7683: CALL_OW 67
// p := Dec ( p ) ;
7687: LD_ADDR_VAR 0 7
7691: PUSH
7692: LD_VAR 0 7
7696: PPUSH
7697: CALL 88143 0 1
7701: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7702: LD_VAR 0 2
7706: PPUSH
7707: LD_INT 60
7709: PUSH
7710: EMPTY
7711: LIST
7712: PPUSH
7713: CALL_OW 72
7717: PUSH
7718: LD_INT 0
7720: EQUAL
7721: PUSH
7722: LD_VAR 0 7
7726: PUSH
7727: LD_INT 0
7729: LESSEQUAL
7730: OR
7731: IFFALSE 7680
// repeat wait ( 0 0$2 ) ;
7733: LD_INT 70
7735: PPUSH
7736: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7740: LD_ADDR_VAR 0 2
7744: PUSH
7745: LD_VAR 0 2
7749: PPUSH
7750: LD_INT 50
7752: PUSH
7753: EMPTY
7754: LIST
7755: PPUSH
7756: CALL_OW 72
7760: ST_TO_ADDR
// for i in tmp do
7761: LD_ADDR_VAR 0 1
7765: PUSH
7766: LD_VAR 0 2
7770: PUSH
7771: FOR_IN
7772: IFFALSE 7861
// if GetChassis ( i ) = ar_hovercraft then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 265
7783: PUSH
7784: LD_INT 11
7786: EQUAL
7787: IFFALSE 7825
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7789: LD_VAR 0 1
7793: PPUSH
7794: LD_INT 22
7796: PUSH
7797: LD_INT 1
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: PPUSH
7804: CALL_OW 69
7808: PPUSH
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 74
7818: PPUSH
7819: CALL 82354 0 2
7823: GO 7859
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7825: LD_VAR 0 1
7829: PPUSH
7830: LD_INT 22
7832: PUSH
7833: LD_INT 1
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PPUSH
7840: CALL_OW 69
7844: PPUSH
7845: LD_VAR 0 1
7849: PPUSH
7850: CALL_OW 74
7854: PPUSH
7855: CALL_OW 115
7859: GO 7771
7861: POP
7862: POP
// until not tmp ;
7863: LD_VAR 0 2
7867: NOT
7868: IFFALSE 7733
// end ;
7870: PPOPN 7
7872: END
// every 28 28$00 do var i , tmp , un , x , p ;
7873: GO 7875
7875: DISABLE
7876: LD_INT 0
7878: PPUSH
7879: PPUSH
7880: PPUSH
7881: PPUSH
7882: PPUSH
// begin enable ;
7883: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7884: LD_INT 35
7886: PPUSH
7887: LD_INT 1190
7889: PPUSH
7890: CALL_OW 12
7894: PPUSH
7895: CALL_OW 67
// tmp := [ ] ;
7899: LD_ADDR_VAR 0 2
7903: PUSH
7904: EMPTY
7905: ST_TO_ADDR
// InitHc ;
7906: CALL_OW 19
// for i = 1 to 3 do
7910: LD_ADDR_VAR 0 1
7914: PUSH
7915: DOUBLE
7916: LD_INT 1
7918: DEC
7919: ST_TO_ADDR
7920: LD_INT 3
7922: PUSH
7923: FOR_TO
7924: IFFALSE 8067
// begin uc_side := 8 ;
7926: LD_ADDR_OWVAR 20
7930: PUSH
7931: LD_INT 8
7933: ST_TO_ADDR
// uc_nation := 2 ;
7934: LD_ADDR_OWVAR 21
7938: PUSH
7939: LD_INT 2
7941: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7942: LD_INT 13
7944: PUSH
7945: LD_INT 14
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 1
7954: PPUSH
7955: LD_INT 2
7957: PPUSH
7958: CALL_OW 12
7962: ARRAY
7963: PPUSH
7964: LD_INT 3
7966: PPUSH
7967: LD_INT 5
7969: PPUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 28
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 1
7982: PPUSH
7983: LD_INT 2
7985: PPUSH
7986: CALL_OW 12
7990: ARRAY
7991: PPUSH
7992: LD_INT 100
7994: PPUSH
7995: CALL 53889 0 5
// un := CreateVehicle ;
7999: LD_ADDR_VAR 0 3
8003: PUSH
8004: CALL_OW 45
8008: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8009: LD_VAR 0 3
8013: PPUSH
8014: LD_INT 4
8016: PPUSH
8017: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8021: LD_VAR 0 3
8025: PPUSH
8026: LD_INT 15
8028: PPUSH
8029: LD_INT 0
8031: PPUSH
8032: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8036: LD_ADDR_VAR 0 2
8040: PUSH
8041: LD_VAR 0 2
8045: PPUSH
8046: LD_VAR 0 2
8050: PUSH
8051: LD_INT 1
8053: PLUS
8054: PPUSH
8055: LD_VAR 0 3
8059: PPUSH
8060: CALL_OW 1
8064: ST_TO_ADDR
// end ;
8065: GO 7923
8067: POP
8068: POP
// for i = 1 to 3 do
8069: LD_ADDR_VAR 0 1
8073: PUSH
8074: DOUBLE
8075: LD_INT 1
8077: DEC
8078: ST_TO_ADDR
8079: LD_INT 3
8081: PUSH
8082: FOR_TO
8083: IFFALSE 8191
// begin uc_side := 8 ;
8085: LD_ADDR_OWVAR 20
8089: PUSH
8090: LD_INT 8
8092: ST_TO_ADDR
// uc_nation := 2 ;
8093: LD_ADDR_OWVAR 21
8097: PUSH
8098: LD_INT 2
8100: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8101: LD_INT 0
8103: PPUSH
8104: LD_INT 1
8106: PPUSH
8107: LD_INT 6
8109: PPUSH
8110: CALL_OW 380
// un := CreateHuman ;
8114: LD_ADDR_VAR 0 3
8118: PUSH
8119: CALL_OW 44
8123: ST_TO_ADDR
// if Prob ( 50 ) then
8124: LD_INT 50
8126: PPUSH
8127: CALL_OW 13
8131: IFFALSE 8145
// SetClass ( un , class_mortar ) ;
8133: LD_VAR 0 3
8137: PPUSH
8138: LD_INT 8
8140: PPUSH
8141: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8145: LD_VAR 0 3
8149: PPUSH
8150: LD_INT 15
8152: PPUSH
8153: LD_INT 0
8155: PPUSH
8156: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8160: LD_ADDR_VAR 0 2
8164: PUSH
8165: LD_VAR 0 2
8169: PPUSH
8170: LD_VAR 0 2
8174: PUSH
8175: LD_INT 1
8177: PLUS
8178: PPUSH
8179: LD_VAR 0 3
8183: PPUSH
8184: CALL_OW 1
8188: ST_TO_ADDR
// end ;
8189: GO 8082
8191: POP
8192: POP
// wait ( 0 0$3 ) ;
8193: LD_INT 105
8195: PPUSH
8196: CALL_OW 67
// p := 0 ;
8200: LD_ADDR_VAR 0 5
8204: PUSH
8205: LD_INT 0
8207: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8208: LD_INT 105
8210: PPUSH
8211: CALL_OW 67
// p := p + 3 ;
8215: LD_ADDR_VAR 0 5
8219: PUSH
8220: LD_VAR 0 5
8224: PUSH
8225: LD_INT 3
8227: PLUS
8228: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8229: LD_ADDR_VAR 0 1
8233: PUSH
8234: LD_VAR 0 2
8238: PPUSH
8239: LD_INT 50
8241: PUSH
8242: EMPTY
8243: LIST
8244: PPUSH
8245: CALL_OW 72
8249: PUSH
8250: FOR_IN
8251: IFFALSE 8289
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8253: LD_VAR 0 1
8257: PPUSH
8258: LD_INT 81
8260: PUSH
8261: LD_INT 8
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: PPUSH
8268: CALL_OW 69
8272: PPUSH
8273: LD_VAR 0 1
8277: PPUSH
8278: CALL_OW 74
8282: PPUSH
8283: CALL_OW 115
8287: GO 8250
8289: POP
8290: POP
// until p >= 120 ;
8291: LD_VAR 0 5
8295: PUSH
8296: LD_INT 120
8298: GREATEREQUAL
8299: IFFALSE 8208
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8301: LD_VAR 0 2
8305: PPUSH
8306: LD_INT 210
8308: PPUSH
8309: LD_INT 178
8311: PPUSH
8312: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8316: LD_ADDR_VAR 0 4
8320: PUSH
8321: LD_INT 10
8323: PPUSH
8324: LD_INT 22
8326: PUSH
8327: LD_INT 8
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 70
8338: ST_TO_ADDR
// if x then
8339: LD_VAR 0 4
8343: IFFALSE 8371
// for i in x do
8345: LD_ADDR_VAR 0 1
8349: PUSH
8350: LD_VAR 0 4
8354: PUSH
8355: FOR_IN
8356: IFFALSE 8369
// RemoveUnit ( i ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: CALL_OW 64
8367: GO 8355
8369: POP
8370: POP
// wait ( 0 0$1 ) ;
8371: LD_INT 35
8373: PPUSH
8374: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8378: LD_INT 22
8380: PUSH
8381: LD_INT 8
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PPUSH
8388: CALL_OW 69
8392: NOT
8393: IFFALSE 8301
// end ;
8395: PPOPN 5
8397: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8398: LD_INT 22
8400: PUSH
8401: LD_INT 2
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: LD_INT 34
8410: PUSH
8411: LD_INT 31
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 3
8420: PUSH
8421: LD_INT 24
8423: PUSH
8424: LD_INT 1000
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: PUSH
8435: EMPTY
8436: LIST
8437: LIST
8438: LIST
8439: PPUSH
8440: CALL_OW 69
8444: IFFALSE 8547
8446: GO 8448
8448: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8449: LD_INT 45
8451: PPUSH
8452: CALL_OW 302
8456: PUSH
8457: LD_INT 45
8459: PPUSH
8460: CALL_OW 255
8464: AND
8465: IFFALSE 8508
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8467: LD_INT 22
8469: PUSH
8470: LD_INT 2
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 34
8479: PUSH
8480: LD_INT 31
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 69
8495: PPUSH
8496: LD_INT 18
8498: PPUSH
8499: LD_INT 8
8501: PPUSH
8502: CALL_OW 111
8506: GO 8547
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8508: LD_INT 22
8510: PUSH
8511: LD_INT 2
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PUSH
8518: LD_INT 34
8520: PUSH
8521: LD_INT 31
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PPUSH
8532: CALL_OW 69
8536: PPUSH
8537: LD_INT 106
8539: PPUSH
8540: LD_INT 14
8542: PPUSH
8543: CALL_OW 111
// end ; end_of_file
8547: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8548: LD_INT 0
8550: PPUSH
8551: PPUSH
8552: PPUSH
8553: PPUSH
8554: PPUSH
8555: PPUSH
// InGameOn ;
8556: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8560: LD_EXP 21
8564: PPUSH
8565: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8569: LD_INT 2
8571: PPUSH
8572: LD_INT 1
8574: PPUSH
8575: LD_INT 1
8577: PPUSH
8578: LD_INT 1
8580: PPUSH
8581: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_INT 22
8592: PUSH
8593: LD_INT 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 25
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: PPUSH
8614: CALL_OW 69
8618: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8619: LD_ADDR_VAR 0 4
8623: PUSH
8624: LD_INT 22
8626: PUSH
8627: LD_INT 1
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PUSH
8634: LD_INT 34
8636: PUSH
8637: LD_INT 11
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: PPUSH
8648: CALL_OW 69
8652: PUSH
8653: LD_INT 1
8655: ARRAY
8656: ST_TO_ADDR
// for i = 1 to tmp do
8657: LD_ADDR_VAR 0 6
8661: PUSH
8662: DOUBLE
8663: LD_INT 1
8665: DEC
8666: ST_TO_ADDR
8667: LD_VAR 0 2
8671: PUSH
8672: FOR_TO
8673: IFFALSE 8720
// begin if i = 5 then
8675: LD_VAR 0 6
8679: PUSH
8680: LD_INT 5
8682: EQUAL
8683: IFFALSE 8687
// break ;
8685: GO 8720
// sols := Replace ( sols , i , tmp [ i ] ) ;
8687: LD_ADDR_VAR 0 5
8691: PUSH
8692: LD_VAR 0 5
8696: PPUSH
8697: LD_VAR 0 6
8701: PPUSH
8702: LD_VAR 0 2
8706: PUSH
8707: LD_VAR 0 6
8711: ARRAY
8712: PPUSH
8713: CALL_OW 1
8717: ST_TO_ADDR
// end ;
8718: GO 8672
8720: POP
8721: POP
// tmp := ar_force_tmp ;
8722: LD_ADDR_VAR 0 2
8726: PUSH
8727: LD_EXP 40
8731: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8732: LD_VAR 0 2
8736: PUSH
8737: LD_INT 1
8739: ARRAY
8740: PPUSH
8741: LD_INT 108
8743: PPUSH
8744: LD_INT 139
8746: PPUSH
8747: LD_INT 0
8749: PPUSH
8750: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8754: LD_VAR 0 2
8758: PUSH
8759: LD_INT 1
8761: ARRAY
8762: PPUSH
8763: LD_EXP 21
8767: PPUSH
8768: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 2
8779: ARRAY
8780: PPUSH
8781: LD_INT 114
8783: PPUSH
8784: LD_INT 132
8786: PPUSH
8787: LD_INT 0
8789: PPUSH
8790: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8794: LD_VAR 0 2
8798: PUSH
8799: LD_INT 3
8801: ARRAY
8802: PPUSH
8803: LD_INT 115
8805: PPUSH
8806: LD_INT 132
8808: PPUSH
8809: LD_INT 0
8811: PPUSH
8812: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8816: LD_VAR 0 2
8820: PUSH
8821: LD_INT 2
8823: ARRAY
8824: PUSH
8825: LD_VAR 0 2
8829: PUSH
8830: LD_INT 3
8832: ARRAY
8833: PUSH
8834: EMPTY
8835: LIST
8836: LIST
8837: PPUSH
8838: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8842: LD_VAR 0 4
8846: PPUSH
8847: LD_INT 83
8849: PPUSH
8850: LD_INT 123
8852: PPUSH
8853: CALL_OW 111
// Wait ( 0 0$01 ) ;
8857: LD_INT 35
8859: PPUSH
8860: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8864: LD_INT 90
8866: PPUSH
8867: LD_INT 144
8869: PPUSH
8870: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8874: LD_VAR 0 5
8878: PPUSH
8879: LD_INT 88
8881: PPUSH
8882: LD_INT 129
8884: PPUSH
8885: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8889: LD_ADDR_VAR 0 3
8893: PUSH
8894: LD_INT 92
8896: PUSH
8897: LD_INT 131
8899: PUSH
8900: EMPTY
8901: LIST
8902: LIST
8903: PUSH
8904: LD_INT 88
8906: PUSH
8907: LD_INT 127
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: PUSH
8914: LD_INT 91
8916: PUSH
8917: LD_INT 132
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PUSH
8924: LD_INT 92
8926: PUSH
8927: LD_INT 134
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: PUSH
8934: EMPTY
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: ST_TO_ADDR
// for i = 1 to sols do
8940: LD_ADDR_VAR 0 6
8944: PUSH
8945: DOUBLE
8946: LD_INT 1
8948: DEC
8949: ST_TO_ADDR
8950: LD_VAR 0 5
8954: PUSH
8955: FOR_TO
8956: IFFALSE 9029
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8958: LD_VAR 0 5
8962: PUSH
8963: LD_VAR 0 6
8967: ARRAY
8968: PPUSH
8969: LD_VAR 0 3
8973: PUSH
8974: LD_VAR 0 6
8978: ARRAY
8979: PUSH
8980: LD_INT 1
8982: ARRAY
8983: PPUSH
8984: LD_VAR 0 3
8988: PUSH
8989: LD_VAR 0 6
8993: ARRAY
8994: PUSH
8995: LD_INT 2
8997: ARRAY
8998: PPUSH
8999: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9003: LD_VAR 0 5
9007: PUSH
9008: LD_VAR 0 6
9012: ARRAY
9013: PPUSH
9014: CALL_OW 197
// AddComHold ( sols ) ;
9018: LD_VAR 0 5
9022: PPUSH
9023: CALL_OW 200
// end ;
9027: GO 8955
9029: POP
9030: POP
// repeat wait ( 0 0$1 ) ;
9031: LD_INT 35
9033: PPUSH
9034: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9038: LD_VAR 0 5
9042: PUSH
9043: LD_INT 1
9045: ARRAY
9046: PPUSH
9047: LD_INT 92
9049: PPUSH
9050: LD_INT 131
9052: PPUSH
9053: CALL_OW 297
9057: PUSH
9058: LD_INT 4
9060: LESS
9061: IFFALSE 9031
// CenterOnXY ( 96 , 139 ) ;
9063: LD_INT 96
9065: PPUSH
9066: LD_INT 139
9068: PPUSH
9069: CALL_OW 84
// wait ( 0 0$3 ) ;
9073: LD_INT 105
9075: PPUSH
9076: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9080: LD_INT 111
9082: PPUSH
9083: LD_INT 135
9085: PPUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 25
9091: NEG
9092: PPUSH
9093: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9097: LD_VAR 0 2
9101: PUSH
9102: LD_INT 2
9104: ARRAY
9105: PPUSH
9106: LD_VAR 0 2
9110: PUSH
9111: LD_INT 1
9113: ARRAY
9114: PPUSH
9115: CALL_OW 250
9119: PUSH
9120: LD_INT 3
9122: PLUS
9123: PPUSH
9124: LD_VAR 0 2
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: CALL_OW 251
9137: PPUSH
9138: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9142: LD_VAR 0 2
9146: PUSH
9147: LD_INT 3
9149: ARRAY
9150: PPUSH
9151: LD_INT 7
9153: PPUSH
9154: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9158: LD_VAR 0 2
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PPUSH
9167: LD_VAR 0 2
9171: PUSH
9172: LD_INT 1
9174: ARRAY
9175: PPUSH
9176: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9180: LD_INT 35
9182: PPUSH
9183: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9187: LD_VAR 0 2
9191: PUSH
9192: LD_INT 1
9194: ARRAY
9195: PPUSH
9196: LD_VAR 0 2
9200: PUSH
9201: LD_INT 2
9203: ARRAY
9204: PPUSH
9205: CALL_OW 296
9209: PUSH
9210: LD_INT 5
9212: LESS
9213: IFFALSE 9180
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9215: LD_VAR 0 2
9219: PUSH
9220: LD_INT 1
9222: ARRAY
9223: PPUSH
9224: LD_VAR 0 2
9228: PUSH
9229: LD_INT 2
9231: ARRAY
9232: PPUSH
9233: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9237: LD_VAR 0 2
9241: PUSH
9242: LD_INT 1
9244: ARRAY
9245: PPUSH
9246: LD_STRING D1a-Merc1-1
9248: PPUSH
9249: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9253: LD_VAR 0 2
9257: PUSH
9258: LD_INT 2
9260: ARRAY
9261: PPUSH
9262: LD_STRING D1a-FMerc2-1
9264: PPUSH
9265: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9269: LD_VAR 0 2
9273: PUSH
9274: LD_INT 2
9276: ARRAY
9277: PPUSH
9278: LD_VAR 0 2
9282: PUSH
9283: LD_INT 1
9285: ARRAY
9286: PPUSH
9287: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9291: LD_VAR 0 2
9295: PUSH
9296: LD_INT 1
9298: ARRAY
9299: PPUSH
9300: LD_INT 500
9302: PPUSH
9303: CALL_OW 234
// wait ( 0 0$2 ) ;
9307: LD_INT 70
9309: PPUSH
9310: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9314: LD_VAR 0 2
9318: PUSH
9319: LD_INT 1
9321: ARRAY
9322: PPUSH
9323: LD_INT 2
9325: PPUSH
9326: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9330: LD_INT 10
9332: PPUSH
9333: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9337: LD_VAR 0 2
9341: PUSH
9342: LD_INT 1
9344: ARRAY
9345: PPUSH
9346: LD_STRING D1a-Merc1-2
9348: PPUSH
9349: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9353: LD_INT 7
9355: PPUSH
9356: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9360: LD_VAR 0 2
9364: PUSH
9365: LD_INT 1
9367: ARRAY
9368: PPUSH
9369: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 2
9380: ARRAY
9381: PPUSH
9382: LD_INT 10
9384: PPUSH
9385: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 2
9396: ARRAY
9397: PPUSH
9398: LD_STRING D1a-FMerc2-2
9400: PPUSH
9401: CALL_OW 88
// wait ( 0 0$1 ) ;
9405: LD_INT 35
9407: PPUSH
9408: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9412: LD_INT 7
9414: PPUSH
9415: CALL_OW 85
// wait ( 0 0$2 ) ;
9419: LD_INT 70
9421: PPUSH
9422: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9426: LD_EXP 44
9430: PPUSH
9431: LD_STRING D1a-Saliba-1
9433: PPUSH
9434: CALL_OW 91
// KillUnit ( Saliba ) ;
9438: LD_EXP 44
9442: PPUSH
9443: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9447: LD_VAR 0 2
9451: PUSH
9452: LD_INT 3
9454: ARRAY
9455: PPUSH
9456: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9460: LD_EXP 21
9464: PPUSH
9465: CALL_OW 85
// wait ( 0 0$1 ) ;
9469: LD_INT 35
9471: PPUSH
9472: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9476: LD_VAR 0 5
9480: PPUSH
9481: LD_INT 88
9483: PPUSH
9484: LD_INT 141
9486: PPUSH
9487: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9491: LD_VAR 0 5
9495: PPUSH
9496: LD_INT 70
9498: PPUSH
9499: CALL_OW 202
// wait ( 0 0$2 ) ;
9503: LD_INT 70
9505: PPUSH
9506: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9510: LD_INT 2
9512: PPUSH
9513: LD_INT 1
9515: PPUSH
9516: LD_INT 2
9518: PPUSH
9519: LD_INT 1
9521: PPUSH
9522: CALL_OW 80
// InGameOff ;
9526: CALL_OW 9
// ComWalk ( sols ) ;
9530: LD_VAR 0 5
9534: PPUSH
9535: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9539: LD_STRING M1
9541: PPUSH
9542: CALL_OW 337
// game_speed := 4 ;
9546: LD_ADDR_OWVAR 65
9550: PUSH
9551: LD_INT 4
9553: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9554: LD_INT 111
9556: PPUSH
9557: LD_INT 135
9559: PPUSH
9560: LD_INT 1
9562: PPUSH
9563: CALL_OW 331
// SaveForQuickRestart ;
9567: CALL_OW 22
// ar_run := true ;
9571: LD_ADDR_EXP 5
9575: PUSH
9576: LD_INT 1
9578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9579: LD_INT 35
9581: PPUSH
9582: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9586: LD_INT 22
9588: PUSH
9589: LD_INT 1
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: LD_INT 91
9598: PUSH
9599: LD_INT 7
9601: PUSH
9602: LD_INT 10
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PPUSH
9614: CALL_OW 69
9618: PUSH
9619: LD_INT 7
9621: PPUSH
9622: CALL_OW 256
9626: PUSH
9627: LD_INT 999
9629: LESS
9630: OR
9631: IFFALSE 9579
// if GetSide ( ar_dep_s ) = 2 then
9633: LD_INT 7
9635: PPUSH
9636: CALL_OW 255
9640: PUSH
9641: LD_INT 2
9643: EQUAL
9644: IFFALSE 9656
// SetSide ( ar_dep_s , 1 ) ;
9646: LD_INT 7
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL_OW 235
// end ;
9656: LD_VAR 0 1
9660: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9661: LD_EXP 5
9665: IFFALSE 10025
9667: GO 9669
9669: DISABLE
9670: LD_INT 0
9672: PPUSH
9673: PPUSH
9674: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9675: LD_ADDR_VAR 0 2
9679: PUSH
9680: LD_EXP 40
9684: PUSH
9685: LD_EXP 36
9689: PPUSH
9690: LD_INT 2
9692: PUSH
9693: LD_INT 21
9695: PUSH
9696: LD_INT 2
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: PUSH
9703: LD_INT 21
9705: PUSH
9706: LD_INT 1
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: LIST
9717: PPUSH
9718: CALL_OW 72
9722: ADD
9723: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9724: LD_VAR 0 2
9728: PPUSH
9729: LD_INT 5
9731: PPUSH
9732: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9736: LD_INT 5
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 343
// k := 1 ;
9746: LD_ADDR_VAR 0 3
9750: PUSH
9751: LD_INT 1
9753: ST_TO_ADDR
// for i in tmp do
9754: LD_ADDR_VAR 0 1
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: FOR_IN
9765: IFFALSE 9850
// begin if IsInUnit ( i ) then
9767: LD_VAR 0 1
9771: PPUSH
9772: CALL_OW 310
9776: IFFALSE 9787
// ComExitBuilding ( i ) ;
9778: LD_VAR 0 1
9782: PPUSH
9783: CALL_OW 122
// if GetClass ( i ) = 3 then
9787: LD_VAR 0 1
9791: PPUSH
9792: CALL_OW 257
9796: PUSH
9797: LD_INT 3
9799: EQUAL
9800: IFFALSE 9836
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9802: LD_VAR 0 1
9806: PPUSH
9807: LD_EXP 41
9811: PUSH
9812: LD_VAR 0 3
9816: ARRAY
9817: PPUSH
9818: CALL_OW 180
// k := k + 1 ;
9822: LD_ADDR_VAR 0 3
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_INT 1
9834: PLUS
9835: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9836: LD_VAR 0 1
9840: PPUSH
9841: LD_INT 10
9843: PPUSH
9844: CALL_OW 173
// end ;
9848: GO 9764
9850: POP
9851: POP
// ar_patrol := true ;
9852: LD_ADDR_EXP 7
9856: PUSH
9857: LD_INT 1
9859: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9860: LD_INT 10
9862: PPUSH
9863: CALL_OW 67
// for i in tmp do
9867: LD_ADDR_VAR 0 1
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: FOR_IN
9878: IFFALSE 9906
// if not HasTask ( i ) then
9880: LD_VAR 0 1
9884: PPUSH
9885: CALL_OW 314
9889: NOT
9890: IFFALSE 9904
// ComMoveToArea ( i , escape_area ) ;
9892: LD_VAR 0 1
9896: PPUSH
9897: LD_INT 10
9899: PPUSH
9900: CALL_OW 113
9904: GO 9877
9906: POP
9907: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_VAR 0 2
9917: PPUSH
9918: LD_INT 95
9920: PUSH
9921: LD_INT 10
9923: PUSH
9924: EMPTY
9925: LIST
9926: LIST
9927: PPUSH
9928: CALL_OW 72
9932: ST_TO_ADDR
// if k then
9933: LD_VAR 0 3
9937: IFFALSE 10006
// for i in k do
9939: LD_ADDR_VAR 0 1
9943: PUSH
9944: LD_VAR 0 3
9948: PUSH
9949: FOR_IN
9950: IFFALSE 10004
// begin if IsInUnit ( i ) then
9952: LD_VAR 0 1
9956: PPUSH
9957: CALL_OW 310
9961: IFFALSE 9977
// RemoveUnit ( IsInUnit ( i ) ) ;
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 310
9972: PPUSH
9973: CALL_OW 64
// RemoveUnit ( i ) ;
9977: LD_VAR 0 1
9981: PPUSH
9982: CALL_OW 64
// tmp := tmp diff i ;
9986: LD_ADDR_VAR 0 2
9990: PUSH
9991: LD_VAR 0 2
9995: PUSH
9996: LD_VAR 0 1
10000: DIFF
10001: ST_TO_ADDR
// end ;
10002: GO 9949
10004: POP
10005: POP
// until tmp = [ ] ;
10006: LD_VAR 0 2
10010: PUSH
10011: EMPTY
10012: EQUAL
10013: IFFALSE 9860
// ChangeSideFog ( 5 , 5 ) ;
10015: LD_INT 5
10017: PPUSH
10018: LD_INT 5
10020: PPUSH
10021: CALL_OW 343
// end ;
10025: PPOPN 3
10027: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10028: LD_EXP 7
10032: IFFALSE 10322
10034: GO 10036
10036: DISABLE
10037: LD_INT 0
10039: PPUSH
10040: PPUSH
10041: PPUSH
// begin uc_side := 2 ;
10042: LD_ADDR_OWVAR 20
10046: PUSH
10047: LD_INT 2
10049: ST_TO_ADDR
// uc_nation := 2 ;
10050: LD_ADDR_OWVAR 21
10054: PUSH
10055: LD_INT 2
10057: ST_TO_ADDR
// InitHc ;
10058: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10062: LD_INT 1
10064: PPUSH
10065: LD_INT 1
10067: PPUSH
10068: LD_INT 6
10070: PPUSH
10071: CALL_OW 380
// un := CreateHuman ;
10075: LD_ADDR_VAR 0 2
10079: PUSH
10080: CALL_OW 44
10084: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10085: LD_INT 14
10087: PPUSH
10088: LD_INT 1
10090: PPUSH
10091: LD_INT 1
10093: PPUSH
10094: LD_INT 27
10096: PPUSH
10097: LD_INT 98
10099: PPUSH
10100: CALL 53889 0 5
// veh := CreateVehicle ;
10104: LD_ADDR_VAR 0 3
10108: PUSH
10109: CALL_OW 45
10113: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10114: LD_VAR 0 3
10118: PPUSH
10119: LD_INT 4
10121: PPUSH
10122: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10126: LD_VAR 0 3
10130: PPUSH
10131: LD_INT 179
10133: PPUSH
10134: LD_INT 135
10136: PPUSH
10137: LD_INT 0
10139: PPUSH
10140: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_VAR 0 3
10153: PPUSH
10154: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10158: LD_VAR 0 2
10162: PPUSH
10163: LD_INT 126
10165: PPUSH
10166: LD_INT 133
10168: PPUSH
10169: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10173: LD_INT 10
10175: PPUSH
10176: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10180: LD_INT 1
10182: PPUSH
10183: LD_VAR 0 3
10187: PPUSH
10188: CALL_OW 292
10192: PUSH
10193: LD_VAR 0 3
10197: PPUSH
10198: LD_INT 7
10200: PPUSH
10201: CALL_OW 296
10205: PUSH
10206: LD_INT 9
10208: LESS
10209: OR
10210: IFFALSE 10173
// ComHold ( veh ) ;
10212: LD_VAR 0 3
10216: PPUSH
10217: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10221: LD_VAR 0 2
10225: PPUSH
10226: LD_STRING D2aa-Ar1-1
10228: PPUSH
10229: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10233: LD_VAR 0 2
10237: PPUSH
10238: LD_INT 177
10240: PPUSH
10241: LD_INT 96
10243: PPUSH
10244: CALL_OW 111
// AddComExitVehicle ( un ) ;
10248: LD_VAR 0 2
10252: PPUSH
10253: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10257: LD_INT 35
10259: PPUSH
10260: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10264: LD_VAR 0 2
10268: PPUSH
10269: LD_INT 204
10271: PPUSH
10272: CALL_OW 296
10276: PUSH
10277: LD_INT 15
10279: LESS
10280: IFFALSE 10257
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10282: LD_ADDR_EXP 50
10286: PUSH
10287: LD_EXP 50
10291: PPUSH
10292: LD_INT 3
10294: PUSH
10295: LD_EXP 50
10299: PUSH
10300: LD_INT 3
10302: ARRAY
10303: PUSH
10304: LD_INT 1
10306: PLUS
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PPUSH
10312: LD_VAR 0 2
10316: PPUSH
10317: CALL 54011 0 3
10321: ST_TO_ADDR
// end ;
10322: PPOPN 3
10324: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10325: LD_INT 7
10327: PPUSH
10328: CALL_OW 255
10332: PUSH
10333: LD_INT 1
10335: EQUAL
10336: PUSH
10337: LD_INT 7
10339: PPUSH
10340: CALL_OW 301
10344: OR
10345: IFFALSE 12750
10347: GO 10349
10349: DISABLE
10350: LD_INT 0
10352: PPUSH
10353: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10354: LD_ADDR_VAR 0 1
10358: PUSH
10359: LD_EXP 36
10363: PPUSH
10364: LD_INT 21
10366: PUSH
10367: LD_INT 3
10369: PUSH
10370: EMPTY
10371: LIST
10372: LIST
10373: PPUSH
10374: CALL_OW 72
10378: PUSH
10379: FOR_IN
10380: IFFALSE 10396
// SetSide ( i , 1 ) ;
10382: LD_VAR 0 1
10386: PPUSH
10387: LD_INT 1
10389: PPUSH
10390: CALL_OW 235
10394: GO 10379
10396: POP
10397: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10398: LD_ADDR_VAR 0 2
10402: PUSH
10403: LD_INT 46
10405: PUSH
10406: LD_INT 41
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PUSH
10413: LD_INT 50
10415: PUSH
10416: LD_INT 25
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: PUSH
10423: LD_INT 57
10425: PUSH
10426: LD_INT 75
10428: PUSH
10429: EMPTY
10430: LIST
10431: LIST
10432: PUSH
10433: LD_INT 75
10435: PUSH
10436: LD_INT 89
10438: PUSH
10439: EMPTY
10440: LIST
10441: LIST
10442: PUSH
10443: LD_INT 51
10445: PUSH
10446: LD_INT 45
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: PUSH
10453: LD_INT 95
10455: PUSH
10456: LD_INT 95
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PUSH
10463: LD_INT 84
10465: PUSH
10466: LD_INT 77
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: PUSH
10473: LD_INT 101
10475: PUSH
10476: LD_INT 76
10478: PUSH
10479: EMPTY
10480: LIST
10481: LIST
10482: PUSH
10483: LD_INT 118
10485: PUSH
10486: LD_INT 81
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PUSH
10493: LD_INT 139
10495: PUSH
10496: LD_INT 97
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: PUSH
10503: LD_INT 129
10505: PUSH
10506: LD_INT 114
10508: PUSH
10509: EMPTY
10510: LIST
10511: LIST
10512: PUSH
10513: LD_INT 154
10515: PUSH
10516: LD_INT 111
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: PUSH
10523: EMPTY
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: ST_TO_ADDR
// base_captured := true ;
10537: LD_ADDR_EXP 6
10541: PUSH
10542: LD_INT 1
10544: ST_TO_ADDR
// DialogueOn ;
10545: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10549: LD_EXP 21
10553: PPUSH
10554: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10558: LD_EXP 21
10562: PPUSH
10563: LD_STRING D2-JMM-1
10565: PPUSH
10566: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10570: LD_EXP 30
10574: PPUSH
10575: LD_STRING D2-Pow-1
10577: PPUSH
10578: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10582: LD_EXP 21
10586: PPUSH
10587: LD_STRING D2-JMM-2
10589: PPUSH
10590: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10594: LD_EXP 30
10598: PPUSH
10599: LD_STRING D2-Pow-2
10601: PPUSH
10602: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10606: LD_EXP 21
10610: PPUSH
10611: LD_STRING D2-JMM-3
10613: PPUSH
10614: CALL_OW 88
// DialogueOff ;
10618: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10622: LD_STRING M2
10624: PPUSH
10625: CALL_OW 337
// Wait ( 0 0$2 ) ;
10629: LD_INT 70
10631: PPUSH
10632: CALL_OW 67
// if IsOk ( Gary ) then
10636: LD_EXP 32
10640: PPUSH
10641: CALL_OW 302
10645: IFFALSE 10659
// Say ( Gary , D2a-Gary-1 ) ;
10647: LD_EXP 32
10651: PPUSH
10652: LD_STRING D2a-Gary-1
10654: PPUSH
10655: CALL_OW 88
// if IsOk ( Bobby ) then
10659: LD_EXP 24
10663: PPUSH
10664: CALL_OW 302
10668: IFFALSE 10682
// Say ( Bobby , D2a-Bobby-1 ) ;
10670: LD_EXP 24
10674: PPUSH
10675: LD_STRING D2a-Bobby-1
10677: PPUSH
10678: CALL_OW 88
// if IsOk ( Cyrus ) then
10682: LD_EXP 25
10686: PPUSH
10687: CALL_OW 302
10691: IFFALSE 10705
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10693: LD_EXP 25
10697: PPUSH
10698: LD_STRING D2a-Cyrus-1
10700: PPUSH
10701: CALL_OW 88
// if IsOk ( Lisa ) then
10705: LD_EXP 22
10709: PPUSH
10710: CALL_OW 302
10714: IFFALSE 10728
// Say ( Lisa , D2a-Lisa-1 ) ;
10716: LD_EXP 22
10720: PPUSH
10721: LD_STRING D2a-Lisa-1
10723: PPUSH
10724: CALL_OW 88
// if IsOk ( Frank ) then
10728: LD_EXP 33
10732: PPUSH
10733: CALL_OW 302
10737: IFFALSE 10751
// Say ( Frank , D2a-Frank-1 ) ;
10739: LD_EXP 33
10743: PPUSH
10744: LD_STRING D2a-Frank-1
10746: PPUSH
10747: CALL_OW 88
// if IsOk ( Cornel ) then
10751: LD_EXP 31
10755: PPUSH
10756: CALL_OW 302
10760: IFFALSE 10774
// Say ( Cornel , D2a-Corn-1 ) ;
10762: LD_EXP 31
10766: PPUSH
10767: LD_STRING D2a-Corn-1
10769: PPUSH
10770: CALL_OW 88
// if IsOk ( Donaldson ) then
10774: LD_EXP 23
10778: PPUSH
10779: CALL_OW 302
10783: IFFALSE 10797
// Say ( Donaldson , D2a-Don-1 ) ;
10785: LD_EXP 23
10789: PPUSH
10790: LD_STRING D2a-Don-1
10792: PPUSH
10793: CALL_OW 88
// if IsOk ( Brown ) then
10797: LD_EXP 27
10801: PPUSH
10802: CALL_OW 302
10806: IFFALSE 10820
// Say ( Brown , D2a-Brown-1 ) ;
10808: LD_EXP 27
10812: PPUSH
10813: LD_STRING D2a-Brown-1
10815: PPUSH
10816: CALL_OW 88
// Wait ( 0 0$30 ) ;
10820: LD_INT 1050
10822: PPUSH
10823: CALL_OW 67
// if IsOk ( Frank ) then
10827: LD_EXP 33
10831: PPUSH
10832: CALL_OW 302
10836: IFFALSE 11816
// begin DialogueOn ;
10838: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10842: LD_EXP 21
10846: PUSH
10847: LD_EXP 33
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PPUSH
10856: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10860: LD_EXP 33
10864: PPUSH
10865: LD_STRING D3F-Frank-1
10867: PPUSH
10868: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10872: LD_EXP 21
10876: PPUSH
10877: LD_STRING D3F-JMM-1
10879: PPUSH
10880: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10884: LD_EXP 33
10888: PPUSH
10889: LD_STRING D3F-Frank-2
10891: PPUSH
10892: CALL_OW 88
// case Query ( QFrank ) of 1 :
10896: LD_STRING QFrank
10898: PPUSH
10899: CALL_OW 97
10903: PUSH
10904: LD_INT 1
10906: DOUBLE
10907: EQUAL
10908: IFTRUE 10912
10910: GO 10935
10912: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10913: LD_EXP 21
10917: PPUSH
10918: LD_STRING D3Fa-JMM-1
10920: PPUSH
10921: CALL_OW 88
// us_scout := 1 ;
10925: LD_ADDR_EXP 8
10929: PUSH
10930: LD_INT 1
10932: ST_TO_ADDR
// end ; 2 :
10933: GO 11098
10935: LD_INT 2
10937: DOUBLE
10938: EQUAL
10939: IFTRUE 10943
10941: GO 11065
10943: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10944: LD_EXP 21
10948: PPUSH
10949: LD_STRING D3Fb-JMM-1
10951: PPUSH
10952: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10956: LD_EXP 33
10960: PPUSH
10961: LD_STRING D3Fb-Frank-1
10963: PPUSH
10964: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10968: LD_STRING QFrank2
10970: PPUSH
10971: CALL_OW 97
10975: PUSH
10976: LD_INT 1
10978: DOUBLE
10979: EQUAL
10980: IFTRUE 10984
10982: GO 11031
10984: POP
// begin us_scout := 2 ;
10985: LD_ADDR_EXP 8
10989: PUSH
10990: LD_INT 2
10992: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10993: LD_EXP 21
10997: PPUSH
10998: LD_STRING D3Fba-JMM-1
11000: PPUSH
11001: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11005: LD_EXP 33
11009: PPUSH
11010: LD_STRING D3Fba-Frank-1
11012: PPUSH
11013: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11017: LD_EXP 21
11021: PPUSH
11022: LD_STRING D3Fba-JMM-2
11024: PPUSH
11025: CALL_OW 88
// end ; 2 :
11029: GO 11063
11031: LD_INT 2
11033: DOUBLE
11034: EQUAL
11035: IFTRUE 11039
11037: GO 11062
11039: POP
// begin us_scout := 0 ;
11040: LD_ADDR_EXP 8
11044: PUSH
11045: LD_INT 0
11047: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11048: LD_EXP 21
11052: PPUSH
11053: LD_STRING D3Fbb-JMM-1
11055: PPUSH
11056: CALL_OW 88
// end ; end ;
11060: GO 11063
11062: POP
// end ; 3 :
11063: GO 11098
11065: LD_INT 3
11067: DOUBLE
11068: EQUAL
11069: IFTRUE 11073
11071: GO 11097
11073: POP
// begin us_scout := - 1 ;
11074: LD_ADDR_EXP 8
11078: PUSH
11079: LD_INT 1
11081: NEG
11082: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11083: LD_EXP 21
11087: PPUSH
11088: LD_STRING D3Fc-JMM-1
11090: PPUSH
11091: CALL_OW 88
// end ; end ;
11095: GO 11098
11097: POP
// DialogueOff ;
11098: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11102: LD_EXP 8
11106: PUSH
11107: LD_INT 1
11109: NEG
11110: PUSH
11111: LD_INT 0
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: IN
11118: IFFALSE 11122
// exit ;
11120: GO 12750
// if us_scout in [ 1 , 2 ] then
11122: LD_EXP 8
11126: PUSH
11127: LD_INT 1
11129: PUSH
11130: LD_INT 2
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: IN
11137: IFFALSE 11816
// begin if IsInUnit ( Frank ) then
11139: LD_EXP 33
11143: PPUSH
11144: CALL_OW 310
11148: IFFALSE 11159
// ComExit ( Frank ) ;
11150: LD_EXP 33
11154: PPUSH
11155: CALL 87158 0 1
// SetSide ( Frank , 4 ) ;
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 4
11166: PPUSH
11167: CALL_OW 235
// wait ( 0 0$1 ) ;
11171: LD_INT 35
11173: PPUSH
11174: CALL_OW 67
// if us_scout = 2 then
11178: LD_EXP 8
11182: PUSH
11183: LD_INT 2
11185: EQUAL
11186: IFFALSE 11554
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11188: LD_EXP 33
11192: PPUSH
11193: LD_INT 75
11195: PPUSH
11196: LD_INT 63
11198: PPUSH
11199: CALL_OW 111
// AddComHold ( Frank ) ;
11203: LD_EXP 33
11207: PPUSH
11208: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11212: LD_EXP 33
11216: PPUSH
11217: LD_INT 770
11219: PPUSH
11220: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11224: LD_EXP 33
11228: PPUSH
11229: LD_INT 100
11231: PPUSH
11232: LD_INT 75
11234: PPUSH
11235: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11239: LD_EXP 33
11243: PPUSH
11244: LD_INT 123
11246: PPUSH
11247: LD_INT 103
11249: PPUSH
11250: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11254: LD_EXP 33
11258: PPUSH
11259: LD_INT 138
11261: PPUSH
11262: LD_INT 108
11264: PPUSH
11265: CALL_OW 171
// AddComHold ( Frank ) ;
11269: LD_EXP 33
11273: PPUSH
11274: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11278: LD_INT 35
11280: PPUSH
11281: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11285: LD_EXP 33
11289: PPUSH
11290: LD_INT 138
11292: PPUSH
11293: LD_INT 108
11295: PPUSH
11296: CALL_OW 307
11300: IFFALSE 11278
// AddComMoveXY ( Frank , 125 , 132 ) ;
11302: LD_EXP 33
11306: PPUSH
11307: LD_INT 125
11309: PPUSH
11310: LD_INT 132
11312: PPUSH
11313: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11317: LD_INT 35
11319: PPUSH
11320: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11324: LD_INT 1
11326: PPUSH
11327: LD_EXP 33
11331: PPUSH
11332: CALL_OW 292
11336: PUSH
11337: LD_EXP 33
11341: PPUSH
11342: LD_INT 7
11344: PPUSH
11345: CALL_OW 296
11349: PUSH
11350: LD_INT 7
11352: LESS
11353: OR
11354: IFFALSE 11317
// DialogueOn ;
11356: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11360: LD_EXP 33
11364: PPUSH
11365: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11369: LD_INT 10
11371: PPUSH
11372: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11376: LD_EXP 21
11380: PPUSH
11381: LD_STRING D4Fa-JMM-1
11383: PPUSH
11384: CALL_OW 88
// for i in points do
11388: LD_ADDR_VAR 0 1
11392: PUSH
11393: LD_VAR 0 2
11397: PUSH
11398: FOR_IN
11399: IFFALSE 11457
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11401: LD_VAR 0 1
11405: PUSH
11406: LD_INT 1
11408: ARRAY
11409: PPUSH
11410: LD_VAR 0 1
11414: PUSH
11415: LD_INT 2
11417: ARRAY
11418: PPUSH
11419: LD_INT 1
11421: PPUSH
11422: LD_INT 20
11424: NEG
11425: PPUSH
11426: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11430: LD_VAR 0 1
11434: PUSH
11435: LD_INT 1
11437: ARRAY
11438: PPUSH
11439: LD_VAR 0 1
11443: PUSH
11444: LD_INT 2
11446: ARRAY
11447: PPUSH
11448: LD_INT 1
11450: PPUSH
11451: CALL_OW 331
// end ;
11455: GO 11398
11457: POP
11458: POP
// dwait ( 0 0$0.5 ) ;
11459: LD_INT 18
11461: PPUSH
11462: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11466: LD_INT 42
11468: PPUSH
11469: LD_INT 27
11471: PPUSH
11472: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11476: LD_EXP 33
11480: PPUSH
11481: LD_STRING D4Fa-Frank-1
11483: PPUSH
11484: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11488: LD_INT 18
11490: PPUSH
11491: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11495: LD_EXP 21
11499: PPUSH
11500: LD_STRING D4Fa-JMM-2
11502: PPUSH
11503: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11507: LD_INT 118
11509: PPUSH
11510: LD_INT 80
11512: PPUSH
11513: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11517: LD_EXP 33
11521: PPUSH
11522: LD_STRING D4Fa-Frank-2
11524: PPUSH
11525: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11529: LD_INT 10
11531: PPUSH
11532: CALL_OW 68
// DialogueOff ;
11536: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11540: LD_EXP 33
11544: PPUSH
11545: LD_INT 1
11547: PPUSH
11548: CALL_OW 235
// end else
11552: GO 11816
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11554: LD_INT 2
11556: PPUSH
11557: LD_INT 4
11559: PPUSH
11560: LD_INT 2
11562: PPUSH
11563: LD_INT 1
11565: PPUSH
11566: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11570: LD_EXP 33
11574: PPUSH
11575: LD_INT 75
11577: PPUSH
11578: LD_INT 63
11580: PPUSH
11581: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11585: LD_EXP 33
11589: PPUSH
11590: LD_INT 175
11592: PPUSH
11593: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11597: LD_EXP 33
11601: PPUSH
11602: LD_INT 102
11604: PPUSH
11605: LD_INT 76
11607: PPUSH
11608: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11612: LD_EXP 33
11616: PPUSH
11617: LD_INT 108
11619: PPUSH
11620: LD_INT 70
11622: PPUSH
11623: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// until See ( 2 , Frank ) ;
11634: LD_INT 2
11636: PPUSH
11637: LD_EXP 33
11641: PPUSH
11642: CALL_OW 292
11646: IFFALSE 11627
// ComMoveXY ( Frank , 112 , 118 ) ;
11648: LD_EXP 33
11652: PPUSH
11653: LD_INT 112
11655: PPUSH
11656: LD_INT 118
11658: PPUSH
11659: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11663: LD_EXP 33
11667: PPUSH
11668: CALL_OW 256
11672: PUSH
11673: LD_INT 750
11675: GREATEREQUAL
11676: IFFALSE 11690
// SetLives ( Frank , 700 ) ;
11678: LD_EXP 33
11682: PPUSH
11683: LD_INT 700
11685: PPUSH
11686: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11690: LD_INT 35
11692: PPUSH
11693: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11697: LD_INT 1
11699: PPUSH
11700: LD_EXP 33
11704: PPUSH
11705: CALL_OW 292
11709: PUSH
11710: LD_EXP 33
11714: PPUSH
11715: LD_INT 7
11717: PPUSH
11718: CALL_OW 296
11722: PUSH
11723: LD_INT 17
11725: LESS
11726: OR
11727: IFFALSE 11690
// DialogueOn ;
11729: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11733: LD_EXP 33
11737: PPUSH
11738: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11742: LD_EXP 33
11746: PPUSH
11747: LD_STRING D4Fb-Frank-1
11749: PPUSH
11750: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11754: LD_EXP 21
11758: PPUSH
11759: LD_STRING D4Fb-JMM-1
11761: PPUSH
11762: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11766: LD_INT 2
11768: PPUSH
11769: LD_STRING D4Fb-FSci1-1
11771: PPUSH
11772: CALL 16807 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11776: LD_EXP 33
11780: PPUSH
11781: LD_STRING D4Fb-Frank-2
11783: PPUSH
11784: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11788: LD_EXP 21
11792: PPUSH
11793: LD_STRING D4Fb-JMM-2
11795: PPUSH
11796: CALL_OW 88
// DialogueOff ;
11800: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11804: LD_EXP 33
11808: PPUSH
11809: LD_INT 1
11811: PPUSH
11812: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
11816: LD_EXP 34
11820: PPUSH
11821: CALL_OW 302
11825: PUSH
11826: LD_EXP 33
11830: PPUSH
11831: CALL_OW 302
11835: NOT
11836: AND
11837: IFFALSE 12750
// begin DialogueOn ;
11839: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11843: LD_EXP 21
11847: PUSH
11848: LD_EXP 34
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11861: LD_EXP 34
11865: PPUSH
11866: LD_STRING D3Y-Yam-1
11868: PPUSH
11869: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11873: LD_EXP 21
11877: PPUSH
11878: LD_STRING D3Y-JMM-1
11880: PPUSH
11881: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11885: LD_EXP 34
11889: PPUSH
11890: LD_STRING D3Y-Yam-2
11892: PPUSH
11893: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11897: LD_STRING QYamoko
11899: PPUSH
11900: CALL_OW 97
11904: PUSH
11905: LD_INT 1
11907: DOUBLE
11908: EQUAL
11909: IFTRUE 11913
11911: GO 11948
11913: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11914: LD_EXP 21
11918: PPUSH
11919: LD_STRING D3Ya-JMM-1
11921: PPUSH
11922: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11926: LD_EXP 34
11930: PPUSH
11931: LD_STRING D3Ya-Yam-1
11933: PPUSH
11934: CALL_OW 88
// us_scout := 1 ;
11938: LD_ADDR_EXP 8
11942: PUSH
11943: LD_INT 1
11945: ST_TO_ADDR
// end ; 2 :
11946: GO 11981
11948: LD_INT 2
11950: DOUBLE
11951: EQUAL
11952: IFTRUE 11956
11954: GO 11980
11956: POP
// begin us_scout := - 1 ;
11957: LD_ADDR_EXP 8
11961: PUSH
11962: LD_INT 1
11964: NEG
11965: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11966: LD_EXP 21
11970: PPUSH
11971: LD_STRING D3Yb-JMM-1
11973: PPUSH
11974: CALL_OW 88
// end ; end ;
11978: GO 11981
11980: POP
// DialogueOff ;
11981: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11985: LD_EXP 8
11989: PUSH
11990: LD_INT 1
11992: NEG
11993: PUSH
11994: LD_INT 0
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: IN
12001: IFFALSE 12005
// exit ;
12003: GO 12750
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12005: LD_ADDR_EXP 8
12009: PUSH
12010: LD_INT 2
12012: PUSH
12013: LD_INT 2
12015: PUSH
12016: LD_INT 1
12018: PUSH
12019: LD_INT 1
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: PUSH
12028: LD_OWVAR 67
12032: ARRAY
12033: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12034: LD_EXP 8
12038: PUSH
12039: LD_INT 1
12041: PUSH
12042: LD_INT 2
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: IN
12049: IFFALSE 12750
// begin if IsInUnit ( Kikuchi ) then
12051: LD_EXP 34
12055: PPUSH
12056: CALL_OW 310
12060: IFFALSE 12071
// ComExitBuilding ( Kikuchi ) ;
12062: LD_EXP 34
12066: PPUSH
12067: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12071: LD_EXP 34
12075: PPUSH
12076: CALL_OW 311
12080: IFFALSE 12091
// ComExitVehicle ( Kikuchi ) ;
12082: LD_EXP 34
12086: PPUSH
12087: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12091: LD_EXP 34
12095: PPUSH
12096: LD_INT 4
12098: PPUSH
12099: CALL_OW 235
// wait ( 0 0$1 ) ;
12103: LD_INT 35
12105: PPUSH
12106: CALL_OW 67
// if us_scout = 2 then
12110: LD_EXP 8
12114: PUSH
12115: LD_INT 2
12117: EQUAL
12118: IFFALSE 12498
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12120: LD_EXP 34
12124: PPUSH
12125: LD_INT 75
12127: PPUSH
12128: LD_INT 63
12130: PPUSH
12131: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12135: LD_EXP 34
12139: PPUSH
12140: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12144: LD_EXP 34
12148: PPUSH
12149: LD_INT 770
12151: PPUSH
12152: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12156: LD_EXP 34
12160: PPUSH
12161: LD_INT 100
12163: PPUSH
12164: LD_INT 75
12166: PPUSH
12167: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12171: LD_EXP 34
12175: PPUSH
12176: LD_INT 123
12178: PPUSH
12179: LD_INT 103
12181: PPUSH
12182: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12186: LD_EXP 34
12190: PPUSH
12191: LD_INT 138
12193: PPUSH
12194: LD_INT 108
12196: PPUSH
12197: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12201: LD_EXP 34
12205: PPUSH
12206: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12210: LD_INT 35
12212: PPUSH
12213: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12217: LD_EXP 34
12221: PPUSH
12222: LD_INT 138
12224: PPUSH
12225: LD_INT 108
12227: PPUSH
12228: CALL_OW 307
12232: IFFALSE 12210
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12234: LD_EXP 34
12238: PPUSH
12239: LD_INT 125
12241: PPUSH
12242: LD_INT 132
12244: PPUSH
12245: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12249: LD_INT 35
12251: PPUSH
12252: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12256: LD_INT 1
12258: PPUSH
12259: LD_EXP 34
12263: PPUSH
12264: CALL_OW 292
12268: PUSH
12269: LD_EXP 34
12273: PPUSH
12274: LD_INT 7
12276: PPUSH
12277: CALL_OW 296
12281: PUSH
12282: LD_INT 7
12284: LESS
12285: OR
12286: IFFALSE 12249
// DialogueOn ;
12288: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12292: LD_EXP 34
12296: PPUSH
12297: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12301: LD_INT 10
12303: PPUSH
12304: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12308: LD_EXP 34
12312: PPUSH
12313: LD_STRING D4Ya-Yam-1
12315: PPUSH
12316: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12320: LD_EXP 21
12324: PPUSH
12325: LD_STRING D4Ya-JMM-1
12327: PPUSH
12328: CALL_OW 88
// for i in points do
12332: LD_ADDR_VAR 0 1
12336: PUSH
12337: LD_VAR 0 2
12341: PUSH
12342: FOR_IN
12343: IFFALSE 12401
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12345: LD_VAR 0 1
12349: PUSH
12350: LD_INT 1
12352: ARRAY
12353: PPUSH
12354: LD_VAR 0 1
12358: PUSH
12359: LD_INT 2
12361: ARRAY
12362: PPUSH
12363: LD_INT 1
12365: PPUSH
12366: LD_INT 20
12368: NEG
12369: PPUSH
12370: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12374: LD_VAR 0 1
12378: PUSH
12379: LD_INT 1
12381: ARRAY
12382: PPUSH
12383: LD_VAR 0 1
12387: PUSH
12388: LD_INT 2
12390: ARRAY
12391: PPUSH
12392: LD_INT 1
12394: PPUSH
12395: CALL_OW 331
// end ;
12399: GO 12342
12401: POP
12402: POP
// dwait ( 0 0$0.5 ) ;
12403: LD_INT 18
12405: PPUSH
12406: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12410: LD_INT 42
12412: PPUSH
12413: LD_INT 27
12415: PPUSH
12416: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12420: LD_EXP 34
12424: PPUSH
12425: LD_STRING D4Ya-Yam-2
12427: PPUSH
12428: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12432: LD_INT 18
12434: PPUSH
12435: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12439: LD_INT 118
12441: PPUSH
12442: LD_INT 80
12444: PPUSH
12445: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12449: LD_EXP 21
12453: PPUSH
12454: LD_STRING D4Ya-JMM-2
12456: PPUSH
12457: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12461: LD_EXP 34
12465: PPUSH
12466: LD_STRING D4Ya-Yam-3
12468: PPUSH
12469: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12473: LD_INT 10
12475: PPUSH
12476: CALL_OW 68
// DialogueOff ;
12480: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12484: LD_EXP 34
12488: PPUSH
12489: LD_INT 1
12491: PPUSH
12492: CALL_OW 235
// end else
12496: GO 12750
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12498: LD_INT 2
12500: PPUSH
12501: LD_INT 4
12503: PPUSH
12504: LD_INT 2
12506: PPUSH
12507: LD_INT 1
12509: PPUSH
12510: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12514: LD_EXP 34
12518: PPUSH
12519: LD_INT 75
12521: PPUSH
12522: LD_INT 63
12524: PPUSH
12525: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12529: LD_EXP 34
12533: PPUSH
12534: LD_INT 175
12536: PPUSH
12537: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12541: LD_EXP 34
12545: PPUSH
12546: LD_INT 102
12548: PPUSH
12549: LD_INT 76
12551: PPUSH
12552: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12556: LD_EXP 34
12560: PPUSH
12561: LD_INT 108
12563: PPUSH
12564: LD_INT 70
12566: PPUSH
12567: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12571: LD_INT 35
12573: PPUSH
12574: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12578: LD_INT 2
12580: PPUSH
12581: LD_EXP 34
12585: PPUSH
12586: CALL_OW 292
12590: IFFALSE 12571
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12592: LD_EXP 34
12596: PPUSH
12597: LD_INT 112
12599: PPUSH
12600: LD_INT 118
12602: PPUSH
12603: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12607: LD_EXP 34
12611: PPUSH
12612: CALL_OW 256
12616: PUSH
12617: LD_INT 750
12619: GREATEREQUAL
12620: IFFALSE 12634
// SetLives ( Kikuchi , 700 ) ;
12622: LD_EXP 34
12626: PPUSH
12627: LD_INT 700
12629: PPUSH
12630: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12634: LD_INT 35
12636: PPUSH
12637: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12641: LD_INT 1
12643: PPUSH
12644: LD_EXP 34
12648: PPUSH
12649: CALL_OW 292
12653: PUSH
12654: LD_EXP 34
12658: PPUSH
12659: LD_INT 7
12661: PPUSH
12662: CALL_OW 296
12666: PUSH
12667: LD_INT 17
12669: LESS
12670: OR
12671: IFFALSE 12634
// DialogueOn ;
12673: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12677: LD_EXP 34
12681: PPUSH
12682: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12686: LD_EXP 34
12690: PPUSH
12691: LD_STRING D4Yb-Yam-1
12693: PPUSH
12694: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12698: LD_EXP 21
12702: PPUSH
12703: LD_STRING D4Yb-JMM-1
12705: PPUSH
12706: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12710: LD_EXP 34
12714: PPUSH
12715: LD_STRING D4Yb-Yam-2
12717: PPUSH
12718: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12722: LD_EXP 21
12726: PPUSH
12727: LD_STRING D4Yb-JMM-2
12729: PPUSH
12730: CALL_OW 88
// DialogueOff ;
12734: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12738: LD_EXP 34
12742: PPUSH
12743: LD_INT 1
12745: PPUSH
12746: CALL_OW 235
// end ; end ; end ; end ;
12750: PPOPN 2
12752: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12753: LD_EXP 6
12757: IFFALSE 13790
12759: GO 12761
12761: DISABLE
12762: LD_INT 0
12764: PPUSH
12765: PPUSH
12766: PPUSH
12767: PPUSH
// begin enable ;
12768: ENABLE
// if not seen [ 1 ] then
12769: LD_EXP 9
12773: PUSH
12774: LD_INT 1
12776: ARRAY
12777: NOT
12778: IFFALSE 12958
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12780: LD_ADDR_VAR 0 2
12784: PUSH
12785: LD_INT 22
12787: PUSH
12788: LD_INT 2
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 2
12797: PUSH
12798: LD_INT 25
12800: PUSH
12801: LD_INT 11
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 33
12810: PUSH
12811: LD_INT 4
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: ST_TO_ADDR
// if tmp then
12832: LD_VAR 0 2
12836: IFFALSE 12958
// for i in tmp do
12838: LD_ADDR_VAR 0 1
12842: PUSH
12843: LD_VAR 0 2
12847: PUSH
12848: FOR_IN
12849: IFFALSE 12956
// if See ( 1 , i ) then
12851: LD_INT 1
12853: PPUSH
12854: LD_VAR 0 1
12858: PPUSH
12859: CALL_OW 292
12863: IFFALSE 12954
// begin seen := Replace ( seen , 1 , true ) ;
12865: LD_ADDR_EXP 9
12869: PUSH
12870: LD_EXP 9
12874: PPUSH
12875: LD_INT 1
12877: PPUSH
12878: LD_INT 1
12880: PPUSH
12881: CALL_OW 1
12885: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12886: LD_INT 1
12888: PPUSH
12889: CALL 16629 0 1
12893: IFFALSE 12954
// begin DialogueOn ;
12895: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12899: LD_VAR 0 1
12903: PPUSH
12904: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12908: LD_INT 10
12910: PPUSH
12911: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_INT 1
12922: PPUSH
12923: LD_STRING D5a-Sol2-1
12925: PPUSH
12926: CALL 16807 0 2
12930: ST_TO_ADDR
// if not un then
12931: LD_VAR 0 3
12935: NOT
12936: IFFALSE 12948
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12938: LD_INT 2
12940: PPUSH
12941: LD_STRING D5a-FSol2-1
12943: PPUSH
12944: CALL 16807 0 2
// DialogueOff ;
12948: CALL_OW 7
// break ;
12952: GO 12956
// end ; end ;
12954: GO 12848
12956: POP
12957: POP
// end ; if not seen [ 2 ] then
12958: LD_EXP 9
12962: PUSH
12963: LD_INT 2
12965: ARRAY
12966: NOT
12967: IFFALSE 13192
// begin can_kamikazed := true ;
12969: LD_ADDR_EXP 10
12973: PUSH
12974: LD_INT 1
12976: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12977: LD_ADDR_VAR 0 2
12981: PUSH
12982: LD_INT 22
12984: PUSH
12985: LD_INT 2
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 25
12994: PUSH
12995: LD_INT 17
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PPUSH
13006: CALL_OW 69
13010: ST_TO_ADDR
// if tmp then
13011: LD_VAR 0 2
13015: IFFALSE 13192
// for i in tmp do
13017: LD_ADDR_VAR 0 1
13021: PUSH
13022: LD_VAR 0 2
13026: PUSH
13027: FOR_IN
13028: IFFALSE 13190
// if See ( 1 , i ) then
13030: LD_INT 1
13032: PPUSH
13033: LD_VAR 0 1
13037: PPUSH
13038: CALL_OW 292
13042: IFFALSE 13188
// begin seen := Replace ( seen , 2 , true ) ;
13044: LD_ADDR_EXP 9
13048: PUSH
13049: LD_EXP 9
13053: PPUSH
13054: LD_INT 2
13056: PPUSH
13057: LD_INT 1
13059: PPUSH
13060: CALL_OW 1
13064: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13065: LD_INT 1
13067: PPUSH
13068: CALL 16629 0 1
13072: IFFALSE 13188
// begin DialogueOn ;
13074: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13078: LD_VAR 0 1
13082: PPUSH
13083: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13087: LD_INT 10
13089: PPUSH
13090: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13094: LD_ADDR_VAR 0 3
13098: PUSH
13099: LD_INT 1
13101: PPUSH
13102: LD_STRING D5b-Sol1-1
13104: PPUSH
13105: CALL 16807 0 2
13109: ST_TO_ADDR
// if not un then
13110: LD_VAR 0 3
13114: NOT
13115: IFFALSE 13133
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13117: LD_ADDR_VAR 0 3
13121: PUSH
13122: LD_INT 2
13124: PPUSH
13125: LD_STRING D5b-FSol1-1
13127: PPUSH
13128: CALL 16807 0 2
13132: ST_TO_ADDR
// if un then
13133: LD_VAR 0 3
13137: IFFALSE 13182
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13139: LD_ADDR_VAR 0 4
13143: PUSH
13144: LD_INT 1
13146: PPUSH
13147: LD_STRING D5b-Sol2-1
13149: PPUSH
13150: LD_VAR 0 3
13154: PPUSH
13155: CALL 17033 0 3
13159: ST_TO_ADDR
// if not un2 then
13160: LD_VAR 0 4
13164: NOT
13165: IFFALSE 13182
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13167: LD_INT 2
13169: PPUSH
13170: LD_STRING D5b-FSol2-1
13172: PPUSH
13173: LD_VAR 0 3
13177: PPUSH
13178: CALL 17033 0 3
// end ; DialogueOff ;
13182: CALL_OW 7
// break ;
13186: GO 13190
// end ; end ;
13188: GO 13027
13190: POP
13191: POP
// end ; if not seen [ 3 ] then
13192: LD_EXP 9
13196: PUSH
13197: LD_INT 3
13199: ARRAY
13200: NOT
13201: IFFALSE 13375
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13203: LD_ADDR_VAR 0 2
13207: PUSH
13208: LD_INT 22
13210: PUSH
13211: LD_INT 2
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PUSH
13218: LD_INT 33
13220: PUSH
13221: LD_INT 2
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PPUSH
13232: CALL_OW 69
13236: ST_TO_ADDR
// if tmp then
13237: LD_VAR 0 2
13241: IFFALSE 13375
// for i in tmp do
13243: LD_ADDR_VAR 0 1
13247: PUSH
13248: LD_VAR 0 2
13252: PUSH
13253: FOR_IN
13254: IFFALSE 13373
// if See ( 1 , i ) then
13256: LD_INT 1
13258: PPUSH
13259: LD_VAR 0 1
13263: PPUSH
13264: CALL_OW 292
13268: IFFALSE 13371
// begin seen := Replace ( seen , 3 , true ) ;
13270: LD_ADDR_EXP 9
13274: PUSH
13275: LD_EXP 9
13279: PPUSH
13280: LD_INT 3
13282: PPUSH
13283: LD_INT 1
13285: PPUSH
13286: CALL_OW 1
13290: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13291: LD_INT 1
13293: PPUSH
13294: CALL 16629 0 1
13298: IFFALSE 13371
// begin DialogueOn ;
13300: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13304: LD_VAR 0 1
13308: PPUSH
13309: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13313: LD_INT 10
13315: PPUSH
13316: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13320: LD_ADDR_VAR 0 3
13324: PUSH
13325: LD_INT 1
13327: PPUSH
13328: LD_STRING D8-Sol1-1
13330: PPUSH
13331: CALL 16807 0 2
13335: ST_TO_ADDR
// if not un then
13336: LD_VAR 0 3
13340: NOT
13341: IFFALSE 13353
// SayRand ( sex_female , D8-FSol1-1 ) ;
13343: LD_INT 2
13345: PPUSH
13346: LD_STRING D8-FSol1-1
13348: PPUSH
13349: CALL 16807 0 2
// Say ( JMM , D8-JMM-1 ) ;
13353: LD_EXP 21
13357: PPUSH
13358: LD_STRING D8-JMM-1
13360: PPUSH
13361: CALL_OW 88
// DialogueOff ;
13365: CALL_OW 7
// break ;
13369: GO 13373
// end ; end ;
13371: GO 13253
13373: POP
13374: POP
// end ; if not seen [ 4 ] then
13375: LD_EXP 9
13379: PUSH
13380: LD_INT 4
13382: ARRAY
13383: NOT
13384: IFFALSE 13546
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_INT 2
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 33
13403: PUSH
13404: LD_INT 5
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PPUSH
13415: CALL_OW 69
13419: ST_TO_ADDR
// if tmp then
13420: LD_VAR 0 2
13424: IFFALSE 13546
// for i in tmp do
13426: LD_ADDR_VAR 0 1
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: FOR_IN
13437: IFFALSE 13544
// if See ( 1 , i ) then
13439: LD_INT 1
13441: PPUSH
13442: LD_VAR 0 1
13446: PPUSH
13447: CALL_OW 292
13451: IFFALSE 13542
// begin seen := Replace ( seen , 4 , true ) ;
13453: LD_ADDR_EXP 9
13457: PUSH
13458: LD_EXP 9
13462: PPUSH
13463: LD_INT 4
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 1
13473: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13474: LD_INT 1
13476: PPUSH
13477: CALL 16629 0 1
13481: IFFALSE 13542
// begin DialogueOn ;
13483: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13487: LD_VAR 0 1
13491: PPUSH
13492: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13496: LD_INT 10
13498: PPUSH
13499: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13503: LD_ADDR_VAR 0 3
13507: PUSH
13508: LD_INT 1
13510: PPUSH
13511: LD_STRING D5a-Sol1-1
13513: PPUSH
13514: CALL 16807 0 2
13518: ST_TO_ADDR
// if not un then
13519: LD_VAR 0 3
13523: NOT
13524: IFFALSE 13536
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13526: LD_INT 2
13528: PPUSH
13529: LD_STRING D5a-FSol1-1
13531: PPUSH
13532: CALL 16807 0 2
// DialogueOff ;
13536: CALL_OW 7
// break ;
13540: GO 13544
// end ; end ;
13542: GO 13436
13544: POP
13545: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13546: LD_EXP 9
13550: PUSH
13551: LD_INT 5
13553: ARRAY
13554: NOT
13555: PUSH
13556: LD_EXP 9
13560: PUSH
13561: LD_INT 3
13563: ARRAY
13564: AND
13565: IFFALSE 13739
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13567: LD_ADDR_VAR 0 2
13571: PUSH
13572: LD_INT 22
13574: PUSH
13575: LD_INT 2
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 34
13584: PUSH
13585: LD_INT 31
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PPUSH
13596: CALL_OW 69
13600: ST_TO_ADDR
// if tmp then
13601: LD_VAR 0 2
13605: IFFALSE 13739
// for i in tmp do
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: LD_VAR 0 2
13616: PUSH
13617: FOR_IN
13618: IFFALSE 13737
// if See ( 1 , i ) then
13620: LD_INT 1
13622: PPUSH
13623: LD_VAR 0 1
13627: PPUSH
13628: CALL_OW 292
13632: IFFALSE 13735
// begin seen := Replace ( seen , 5 , true ) ;
13634: LD_ADDR_EXP 9
13638: PUSH
13639: LD_EXP 9
13643: PPUSH
13644: LD_INT 5
13646: PPUSH
13647: LD_INT 1
13649: PPUSH
13650: CALL_OW 1
13654: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13655: LD_INT 1
13657: PPUSH
13658: CALL 16629 0 1
13662: IFFALSE 13735
// begin DialogueOn ;
13664: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13668: LD_VAR 0 1
13672: PPUSH
13673: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13677: LD_INT 10
13679: PPUSH
13680: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13684: LD_ADDR_VAR 0 3
13688: PUSH
13689: LD_INT 1
13691: PPUSH
13692: LD_STRING D8a-Sol2-1
13694: PPUSH
13695: CALL 16807 0 2
13699: ST_TO_ADDR
// if not un then
13700: LD_VAR 0 3
13704: NOT
13705: IFFALSE 13717
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13707: LD_INT 2
13709: PPUSH
13710: LD_STRING D8a-FSol2-1
13712: PPUSH
13713: CALL 16807 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13717: LD_EXP 21
13721: PPUSH
13722: LD_STRING D8a-JMM-1
13724: PPUSH
13725: CALL_OW 88
// DialogueOff ;
13729: CALL_OW 7
// break ;
13733: GO 13737
// end ; end ;
13735: GO 13617
13737: POP
13738: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13739: LD_EXP 9
13743: PUSH
13744: LD_INT 1
13746: ARRAY
13747: PUSH
13748: LD_EXP 9
13752: PUSH
13753: LD_INT 2
13755: ARRAY
13756: AND
13757: PUSH
13758: LD_EXP 9
13762: PUSH
13763: LD_INT 3
13765: ARRAY
13766: AND
13767: PUSH
13768: LD_EXP 9
13772: PUSH
13773: LD_INT 4
13775: ARRAY
13776: AND
13777: PUSH
13778: LD_EXP 9
13782: PUSH
13783: LD_INT 5
13785: ARRAY
13786: AND
13787: IFFALSE 13790
// disable ;
13789: DISABLE
// end ;
13790: PPOPN 4
13792: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13793: LD_EXP 10
13797: PUSH
13798: LD_EXP 11
13802: AND
13803: IFFALSE 14001
13805: GO 13807
13807: DISABLE
13808: LD_INT 0
13810: PPUSH
// begin DialogueOn ;
13811: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13815: LD_EXP 11
13819: PPUSH
13820: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13824: LD_ADDR_VAR 0 1
13828: PUSH
13829: LD_INT 1
13831: PPUSH
13832: LD_STRING D5c-Sol1-1
13834: PPUSH
13835: CALL 16807 0 2
13839: ST_TO_ADDR
// if not un then
13840: LD_VAR 0 1
13844: NOT
13845: IFFALSE 13863
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13847: LD_ADDR_VAR 0 1
13851: PUSH
13852: LD_INT 2
13854: PPUSH
13855: LD_STRING D5c-FSol1-1
13857: PPUSH
13858: CALL 16807 0 2
13862: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13863: LD_EXP 21
13867: PPUSH
13868: LD_STRING D5c-JMM-1
13870: PPUSH
13871: CALL_OW 88
// if IsOk ( Lisa ) then
13875: LD_EXP 22
13879: PPUSH
13880: CALL_OW 302
13884: IFFALSE 13900
// Say ( Lisa , D5d-Lisa-1 ) else
13886: LD_EXP 22
13890: PPUSH
13891: LD_STRING D5d-Lisa-1
13893: PPUSH
13894: CALL_OW 88
13898: GO 13985
// if IsOk ( Cyrus ) then
13900: LD_EXP 25
13904: PPUSH
13905: CALL_OW 302
13909: IFFALSE 13925
// Say ( Cyrus , D5d-Cyrus-1 ) else
13911: LD_EXP 25
13915: PPUSH
13916: LD_STRING D5d-Cyrus-1
13918: PPUSH
13919: CALL_OW 88
13923: GO 13985
// if IsOk ( Gary ) then
13925: LD_EXP 32
13929: PPUSH
13930: CALL_OW 302
13934: IFFALSE 13950
// Say ( Gary , D5d-Gary-1 ) else
13936: LD_EXP 32
13940: PPUSH
13941: LD_STRING D5d-Gary-1
13943: PPUSH
13944: CALL_OW 88
13948: GO 13985
// if GetSex ( un ) = sex_male then
13950: LD_VAR 0 1
13954: PPUSH
13955: CALL_OW 258
13959: PUSH
13960: LD_INT 1
13962: EQUAL
13963: IFFALSE 13979
// Say ( un , D5d-Sol1-1 ) else
13965: LD_VAR 0 1
13969: PPUSH
13970: LD_STRING D5d-Sol1-1
13972: PPUSH
13973: CALL_OW 88
13977: GO 13985
// begin DialogueOff ;
13979: CALL_OW 7
// exit ;
13983: GO 14001
// end ; Say ( JMM , D5d-JMM-1 ) ;
13985: LD_EXP 21
13989: PPUSH
13990: LD_STRING D5d-JMM-1
13992: PPUSH
13993: CALL_OW 88
// DialogueOff ;
13997: CALL_OW 7
// end ;
14001: PPOPN 1
14003: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14004: LD_INT 1
14006: PPUSH
14007: LD_INT 17
14009: PPUSH
14010: CALL_OW 294
14014: PUSH
14015: LD_INT 2
14017: GREATEREQUAL
14018: IFFALSE 14150
14020: GO 14022
14022: DISABLE
14023: LD_INT 0
14025: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14026: LD_INT 10
14028: PPUSH
14029: LD_INT 5
14031: PPUSH
14032: LD_INT 1
14034: PPUSH
14035: LD_INT 10
14037: NEG
14038: PPUSH
14039: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14043: LD_INT 10
14045: PPUSH
14046: LD_INT 5
14048: PPUSH
14049: LD_INT 1
14051: PPUSH
14052: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14056: LD_INT 10
14058: PPUSH
14059: LD_INT 5
14061: PPUSH
14062: CALL_OW 86
// DialogueOn ;
14066: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14070: LD_ADDR_VAR 0 1
14074: PUSH
14075: LD_INT 1
14077: PPUSH
14078: LD_STRING D6-Sci1-1
14080: PPUSH
14081: CALL 16807 0 2
14085: ST_TO_ADDR
// if un then
14086: LD_VAR 0 1
14090: IFFALSE 14128
// begin Say ( JMM , D6-JMM-1 ) ;
14092: LD_EXP 21
14096: PPUSH
14097: LD_STRING D6-JMM-1
14099: PPUSH
14100: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14104: LD_VAR 0 1
14108: PPUSH
14109: LD_STRING D6-Sci1-2
14111: PPUSH
14112: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14116: LD_EXP 21
14120: PPUSH
14121: LD_STRING D6-JMM-2
14123: PPUSH
14124: CALL_OW 88
// end ; DialogueOff ;
14128: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14132: LD_STRING M3
14134: PPUSH
14135: CALL_OW 337
// wait ( 0 0$30 ) ;
14139: LD_INT 1050
14141: PPUSH
14142: CALL_OW 67
// AmericanReinforcements ;
14146: CALL 2125 0 0
// end ;
14150: PPOPN 1
14152: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14153: LD_OWVAR 1
14157: PUSH
14158: LD_INT 42000
14160: GREATEREQUAL
14161: PUSH
14162: LD_INT 2
14164: PPUSH
14165: LD_INT 169
14167: PPUSH
14168: LD_INT 90
14170: PPUSH
14171: LD_INT 10
14173: PPUSH
14174: CALL 55275 0 4
14178: PUSH
14179: LD_INT 4
14181: ARRAY
14182: PUSH
14183: LD_INT 0
14185: EQUAL
14186: PUSH
14187: LD_INT 45
14189: PPUSH
14190: CALL_OW 301
14194: OR
14195: PUSH
14196: LD_INT 45
14198: PPUSH
14199: CALL_OW 255
14203: PUSH
14204: LD_INT 1
14206: EQUAL
14207: OR
14208: AND
14209: PUSH
14210: LD_INT 94
14212: PPUSH
14213: CALL_OW 301
14217: NOT
14218: AND
14219: IFFALSE 15424
14221: GO 14223
14223: DISABLE
14224: LD_INT 0
14226: PPUSH
14227: PPUSH
14228: PPUSH
14229: PPUSH
14230: PPUSH
// begin uc_side := 5 ;
14231: LD_ADDR_OWVAR 20
14235: PUSH
14236: LD_INT 5
14238: ST_TO_ADDR
// uc_nation := 2 ;
14239: LD_ADDR_OWVAR 21
14243: PUSH
14244: LD_INT 2
14246: ST_TO_ADDR
// InitHc ;
14247: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14251: LD_INT 1
14253: PPUSH
14254: LD_INT 3
14256: PPUSH
14257: LD_INT 8
14259: PPUSH
14260: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14264: LD_ADDR_OWVAR 29
14268: PUSH
14269: LD_INT 12
14271: PUSH
14272: LD_INT 12
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: ST_TO_ADDR
// hc_name := Hans Fliege ;
14279: LD_ADDR_OWVAR 26
14283: PUSH
14284: LD_STRING Hans Fliege
14286: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14287: LD_ADDR_OWVAR 33
14291: PUSH
14292: LD_STRING SecondCharsGal
14294: ST_TO_ADDR
// hc_face_number := 7 ;
14295: LD_ADDR_OWVAR 34
14299: PUSH
14300: LD_INT 7
14302: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14303: LD_ADDR_EXP 46
14307: PUSH
14308: CALL_OW 44
14312: ST_TO_ADDR
// InitHc ;
14313: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14317: LD_INT 1
14319: PPUSH
14320: LD_INT 16
14322: PPUSH
14323: LD_INT 2
14325: PPUSH
14326: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14330: LD_ADDR_OWVAR 29
14334: PUSH
14335: LD_INT 12
14337: PUSH
14338: LD_INT 12
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: ST_TO_ADDR
// hc_name :=  ;
14345: LD_ADDR_OWVAR 26
14349: PUSH
14350: LD_STRING 
14352: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14353: LD_ADDR_EXP 47
14357: PUSH
14358: CALL_OW 44
14362: ST_TO_ADDR
// InitHc ;
14363: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14367: LD_INT 35
14369: PPUSH
14370: CALL_OW 67
// until not InBattle ( 1 ) ;
14374: LD_INT 1
14376: PPUSH
14377: CALL_OW 463
14381: NOT
14382: IFFALSE 14367
// wait ( 0 0$5 ) ;
14384: LD_INT 175
14386: PPUSH
14387: CALL_OW 67
// DialogueOn ;
14391: CALL_OW 6
// InGameOn ;
14395: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14399: LD_ADDR_VAR 0 1
14403: PUSH
14404: LD_INT 22
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: LD_INT 2
14416: PUSH
14417: LD_INT 25
14419: PUSH
14420: LD_INT 1
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: PUSH
14427: LD_INT 25
14429: PUSH
14430: LD_INT 2
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: PUSH
14437: LD_INT 25
14439: PUSH
14440: LD_INT 3
14442: PUSH
14443: EMPTY
14444: LIST
14445: LIST
14446: PUSH
14447: LD_INT 25
14449: PUSH
14450: LD_INT 4
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: PUSH
14457: LD_INT 25
14459: PUSH
14460: LD_INT 5
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: LD_INT 8
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: PPUSH
14490: CALL_OW 69
14494: PUSH
14495: LD_EXP 21
14499: PUSH
14500: LD_EXP 22
14504: PUSH
14505: LD_EXP 23
14509: PUSH
14510: LD_EXP 24
14514: PUSH
14515: LD_EXP 25
14519: PUSH
14520: LD_EXP 26
14524: PUSH
14525: LD_EXP 27
14529: PUSH
14530: LD_EXP 28
14534: PUSH
14535: LD_EXP 29
14539: PUSH
14540: LD_EXP 31
14544: PUSH
14545: LD_EXP 32
14549: PUSH
14550: LD_EXP 33
14554: PUSH
14555: LD_EXP 34
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: DIFF
14575: PPUSH
14576: LD_INT 26
14578: PUSH
14579: LD_INT 1
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: PPUSH
14586: CALL_OW 72
14590: PUSH
14591: LD_INT 1
14593: ARRAY
14594: ST_TO_ADDR
// if Brown then
14595: LD_EXP 27
14599: IFFALSE 14611
// un := Brown ;
14601: LD_ADDR_VAR 0 1
14605: PUSH
14606: LD_EXP 27
14610: ST_TO_ADDR
// if un then
14611: LD_VAR 0 1
14615: IFFALSE 14641
// begin Say ( un , D7-Sol1-1 ) ;
14617: LD_VAR 0 1
14621: PPUSH
14622: LD_STRING D7-Sol1-1
14624: PPUSH
14625: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14629: LD_EXP 21
14633: PPUSH
14634: LD_STRING D7-JMM-1
14636: PPUSH
14637: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14641: LD_EXP 46
14645: PPUSH
14646: LD_STRING D7-Ar1-1
14648: PPUSH
14649: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14653: LD_EXP 21
14657: PPUSH
14658: LD_STRING D7-JMM-2
14660: PPUSH
14661: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14665: LD_EXP 46
14669: PPUSH
14670: LD_STRING D7-Ar1-2
14672: PPUSH
14673: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14677: LD_EXP 21
14681: PPUSH
14682: LD_STRING D7-JMM-3
14684: PPUSH
14685: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14689: LD_EXP 46
14693: PPUSH
14694: LD_STRING D7-Ar1-3
14696: PPUSH
14697: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14701: LD_EXP 21
14705: PPUSH
14706: LD_STRING D7-JMM-4
14708: PPUSH
14709: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14713: LD_EXP 46
14717: PPUSH
14718: LD_STRING D7-Ar1-4
14720: PPUSH
14721: CALL_OW 94
// InGameOff ;
14725: CALL_OW 9
// DialogueOff ;
14729: CALL_OW 7
// case Query ( QCameras ) of 1 :
14733: LD_STRING QCameras
14735: PPUSH
14736: CALL_OW 97
14740: PUSH
14741: LD_INT 1
14743: DOUBLE
14744: EQUAL
14745: IFTRUE 14749
14747: GO 14752
14749: POP
// ; 2 :
14750: GO 14766
14752: LD_INT 2
14754: DOUBLE
14755: EQUAL
14756: IFTRUE 14760
14758: GO 14765
14760: POP
// exit ; end ;
14761: GO 15424
14763: GO 14766
14765: POP
// ChangeMissionObjectives ( MCar ) ;
14766: LD_STRING MCar
14768: PPUSH
14769: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14773: LD_INT 124
14775: PPUSH
14776: LD_INT 90
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: LD_INT 6
14784: NEG
14785: PPUSH
14786: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14790: LD_INT 124
14792: PPUSH
14793: LD_INT 90
14795: PPUSH
14796: LD_INT 1
14798: PPUSH
14799: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14803: LD_INT 12
14805: PPUSH
14806: LD_INT 1
14808: PPUSH
14809: CALL_OW 424
// wait ( 3 ) ;
14813: LD_INT 3
14815: PPUSH
14816: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14820: LD_INT 124
14822: PPUSH
14823: LD_INT 90
14825: PPUSH
14826: CALL_OW 86
// cargo := false ;
14830: LD_ADDR_VAR 0 3
14834: PUSH
14835: LD_INT 0
14837: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14838: LD_INT 35
14840: PPUSH
14841: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14845: LD_ADDR_VAR 0 3
14849: PUSH
14850: LD_INT 12
14852: PPUSH
14853: LD_INT 32
14855: PUSH
14856: LD_INT 3
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 34
14865: PUSH
14866: LD_INT 32
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PUSH
14873: LD_INT 58
14875: PUSH
14876: EMPTY
14877: LIST
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: PPUSH
14884: CALL_OW 70
14888: ST_TO_ADDR
// until cargo ;
14889: LD_VAR 0 3
14893: IFFALSE 14838
// cargo := cargo [ 1 ] ;
14895: LD_ADDR_VAR 0 3
14899: PUSH
14900: LD_VAR 0 3
14904: PUSH
14905: LD_INT 1
14907: ARRAY
14908: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14909: LD_VAR 0 3
14913: PPUSH
14914: LD_INT 5
14916: PPUSH
14917: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14921: LD_INT 12
14923: PPUSH
14924: LD_INT 0
14926: PPUSH
14927: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14931: LD_EXP 46
14935: PPUSH
14936: LD_INT 11
14938: PPUSH
14939: LD_INT 0
14941: PPUSH
14942: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14946: LD_EXP 47
14950: PPUSH
14951: LD_INT 11
14953: PPUSH
14954: LD_INT 0
14956: PPUSH
14957: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14961: LD_EXP 46
14965: PUSH
14966: LD_EXP 47
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PPUSH
14975: LD_INT 12
14977: PPUSH
14978: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14982: LD_EXP 46
14986: PPUSH
14987: LD_VAR 0 3
14991: PPUSH
14992: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14996: LD_EXP 46
15000: PUSH
15001: LD_EXP 47
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PPUSH
15010: LD_INT 209
15012: PPUSH
15013: LD_INT 178
15015: PPUSH
15016: CALL_OW 171
// escaped := 0 ;
15020: LD_ADDR_VAR 0 5
15024: PUSH
15025: LD_INT 0
15027: ST_TO_ADDR
// while ( true ) do
15028: LD_INT 1
15030: IFFALSE 15246
// begin wait ( 0 0$1 ) ;
15032: LD_INT 35
15034: PPUSH
15035: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15039: LD_EXP 46
15043: PPUSH
15044: CALL_OW 314
15048: NOT
15049: PUSH
15050: LD_EXP 47
15054: PPUSH
15055: CALL_OW 314
15059: NOT
15060: OR
15061: IFFALSE 15087
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15063: LD_EXP 46
15067: PUSH
15068: LD_EXP 47
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PPUSH
15077: LD_INT 209
15079: PPUSH
15080: LD_INT 178
15082: PPUSH
15083: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15087: LD_EXP 46
15091: PPUSH
15092: LD_INT 10
15094: PPUSH
15095: CALL_OW 308
15099: IFFALSE 15124
// begin RemoveUnit ( ar_mechanic ) ;
15101: LD_EXP 46
15105: PPUSH
15106: CALL_OW 64
// escaped := escaped + 1 ;
15110: LD_ADDR_VAR 0 5
15114: PUSH
15115: LD_VAR 0 5
15119: PUSH
15120: LD_INT 1
15122: PLUS
15123: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15124: LD_EXP 47
15128: PPUSH
15129: LD_INT 10
15131: PPUSH
15132: CALL_OW 308
15136: IFFALSE 15161
// begin RemoveUnit ( ar_mechanic_friend ) ;
15138: LD_EXP 47
15142: PPUSH
15143: CALL_OW 64
// escaped := escaped + 1 ;
15147: LD_ADDR_VAR 0 5
15151: PUSH
15152: LD_VAR 0 5
15156: PUSH
15157: LD_INT 1
15159: PLUS
15160: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15161: LD_VAR 0 3
15165: PPUSH
15166: LD_INT 10
15168: PPUSH
15169: CALL_OW 308
15173: IFFALSE 15184
// RemoveUnit ( cargo ) ;
15175: LD_VAR 0 3
15179: PPUSH
15180: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15184: LD_EXP 46
15188: PPUSH
15189: CALL_OW 305
15193: NOT
15194: PUSH
15195: LD_VAR 0 5
15199: PUSH
15200: LD_INT 2
15202: GREATEREQUAL
15203: AND
15204: IFFALSE 15208
// break ;
15206: GO 15246
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15208: LD_EXP 46
15212: PPUSH
15213: CALL_OW 305
15217: NOT
15218: PUSH
15219: LD_EXP 47
15223: PPUSH
15224: CALL_OW 305
15228: NOT
15229: AND
15230: PUSH
15231: LD_VAR 0 5
15235: PUSH
15236: LD_INT 2
15238: LESS
15239: AND
15240: IFFALSE 15244
// exit ;
15242: GO 15424
// end ;
15244: GO 15028
// wait ( 0 0$2 ) ;
15246: LD_INT 70
15248: PPUSH
15249: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15253: LD_EXP 46
15257: PPUSH
15258: LD_STRING D7a-Ar1-1
15260: PPUSH
15261: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15265: LD_ADDR_VAR 0 4
15269: PUSH
15270: LD_INT 129
15272: PUSH
15273: LD_INT 10
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: PUSH
15280: LD_INT 103
15282: PUSH
15283: LD_INT 6
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: PUSH
15290: LD_INT 148
15292: PUSH
15293: LD_INT 47
15295: PUSH
15296: EMPTY
15297: LIST
15298: LIST
15299: PUSH
15300: LD_INT 155
15302: PUSH
15303: LD_INT 16
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: LIST
15314: LIST
15315: ST_TO_ADDR
// if Difficulty = 1 then
15316: LD_OWVAR 67
15320: PUSH
15321: LD_INT 1
15323: EQUAL
15324: IFFALSE 15361
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15326: LD_ADDR_VAR 0 4
15330: PUSH
15331: LD_VAR 0 4
15335: PUSH
15336: LD_INT 78
15338: PUSH
15339: LD_INT 7
15341: PUSH
15342: EMPTY
15343: LIST
15344: LIST
15345: PUSH
15346: LD_INT 104
15348: PUSH
15349: LD_INT 43
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: ADD
15360: ST_TO_ADDR
// for i in tmp do
15361: LD_ADDR_VAR 0 2
15365: PUSH
15366: LD_VAR 0 4
15370: PUSH
15371: FOR_IN
15372: IFFALSE 15405
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15374: LD_VAR 0 2
15378: PUSH
15379: LD_INT 1
15381: ARRAY
15382: PPUSH
15383: LD_VAR 0 2
15387: PUSH
15388: LD_INT 2
15390: ARRAY
15391: PPUSH
15392: LD_INT 1
15394: PPUSH
15395: LD_INT 9
15397: NEG
15398: PPUSH
15399: CALL_OW 330
15403: GO 15371
15405: POP
15406: POP
// SetAchievement ( ACH_FRIEND ) ;
15407: LD_STRING ACH_FRIEND
15409: PPUSH
15410: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15414: LD_INT 129
15416: PPUSH
15417: LD_INT 10
15419: PPUSH
15420: CALL_OW 84
// end ;
15424: PPOPN 5
15426: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15427: LD_EXP 15
15431: PUSH
15432: LD_INT 21000
15434: MINUS
15435: PUSH
15436: LD_OWVAR 1
15440: LESSEQUAL
15441: IFFALSE 15481
15443: GO 15445
15445: DISABLE
// begin powell_warn := true ;
15446: LD_ADDR_EXP 16
15450: PUSH
15451: LD_INT 1
15453: ST_TO_ADDR
// DialogueOn ;
15454: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15458: LD_EXP 30
15462: PPUSH
15463: LD_STRING D9-Pow-1
15465: PPUSH
15466: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15470: LD_INT 10
15472: PPUSH
15473: CALL_OW 68
// DialogueOff ;
15477: CALL_OW 7
// end ;
15481: END
// every 0 0$1 trigger game_time <= tick do
15482: LD_EXP 15
15486: PUSH
15487: LD_OWVAR 1
15491: LESSEQUAL
15492: IFFALSE 15531
15494: GO 15496
15496: DISABLE
// begin DialogueOn ;
15497: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15501: LD_EXP 30
15505: PPUSH
15506: LD_STRING D9a-Pow-1
15508: PPUSH
15509: CALL_OW 94
// dwait ( 0 0$2 ) ;
15513: LD_INT 70
15515: PPUSH
15516: CALL_OW 68
// DialogueOff ;
15520: CALL_OW 7
// YouLost ( Command ) ;
15524: LD_STRING Command
15526: PPUSH
15527: CALL_OW 104
// end ;
15531: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15532: LD_INT 22
15534: PUSH
15535: LD_INT 2
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: PUSH
15542: LD_INT 30
15544: PUSH
15545: LD_INT 1
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PPUSH
15556: CALL_OW 69
15560: PUSH
15561: LD_INT 0
15563: EQUAL
15564: PUSH
15565: LD_EXP 21
15569: PPUSH
15570: CALL_OW 302
15574: AND
15575: IFFALSE 15623
15577: GO 15579
15579: DISABLE
// begin case Query ( QEndMission ) of 1 :
15580: LD_STRING QEndMission
15582: PPUSH
15583: CALL_OW 97
15587: PUSH
15588: LD_INT 1
15590: DOUBLE
15591: EQUAL
15592: IFTRUE 15596
15594: GO 15607
15596: POP
// end_the_mission_allowed := true ; 2 :
15597: LD_ADDR_OWVAR 57
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
15605: GO 15623
15607: LD_INT 2
15609: DOUBLE
15610: EQUAL
15611: IFTRUE 15615
15613: GO 15622
15615: POP
// EndMission ; end ;
15616: CALL 15645 0 0
15620: GO 15623
15622: POP
// end ;
15623: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
15624: LD_OWVAR 57
15628: IFFALSE 15642
// begin end_the_mission_allowed := false ;
15630: LD_ADDR_OWVAR 57
15634: PUSH
15635: LD_INT 0
15637: ST_TO_ADDR
// EndMission ;
15638: CALL 15645 0 0
// end ; end ;
15642: PPOPN 1
15644: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15645: LD_INT 0
15647: PPUSH
15648: PPUSH
15649: PPUSH
15650: PPUSH
15651: PPUSH
// m1 := false ;
15652: LD_ADDR_VAR 0 3
15656: PUSH
15657: LD_INT 0
15659: ST_TO_ADDR
// m2 := false ;
15660: LD_ADDR_VAR 0 4
15664: PUSH
15665: LD_INT 0
15667: ST_TO_ADDR
// m3 := false ;
15668: LD_ADDR_VAR 0 5
15672: PUSH
15673: LD_INT 0
15675: ST_TO_ADDR
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 9 then
15676: LD_INT 22
15678: PUSH
15679: LD_INT 1
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PUSH
15686: LD_INT 21
15688: PUSH
15689: LD_INT 1
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PUSH
15696: LD_INT 23
15698: PUSH
15699: LD_INT 1
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PUSH
15706: LD_INT 50
15708: PUSH
15709: EMPTY
15710: LIST
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: LIST
15716: LIST
15717: PPUSH
15718: CALL_OW 69
15722: PPUSH
15723: CALL 51151 0 1
15727: PUSH
15728: LD_INT 9
15730: LESS
15731: IFFALSE 15742
// begin YouLost ( LostVictory ) ;
15733: LD_STRING LostVictory
15735: PPUSH
15736: CALL_OW 104
// exit ;
15740: GO 16624
// end ; if not am_veh_consturcted then
15742: LD_EXP 20
15746: NOT
15747: IFFALSE 15756
// SetAchievement ( ACH_ARABTECH ) ;
15749: LD_STRING ACH_ARABTECH
15751: PPUSH
15752: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15756: LD_OWVAR 1
15760: PUSH
15761: LD_INT 252000
15763: PUSH
15764: LD_INT 210000
15766: PUSH
15767: LD_INT 199500
15769: PUSH
15770: LD_INT 193200
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: PUSH
15779: LD_OWVAR 67
15783: ARRAY
15784: LESS
15785: IFFALSE 15807
// begin m3 := true ;
15787: LD_ADDR_VAR 0 5
15791: PUSH
15792: LD_INT 1
15794: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15795: LD_STRING Time1
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: CALL_OW 101
// end else
15805: GO 15838
// if not powell_warn then
15807: LD_EXP 16
15811: NOT
15812: IFFALSE 15827
// AddMedal ( Time1 , - 1 ) else
15814: LD_STRING Time1
15816: PPUSH
15817: LD_INT 1
15819: NEG
15820: PPUSH
15821: CALL_OW 101
15825: GO 15838
// AddMedal ( Time1 , - 2 ) ;
15827: LD_STRING Time1
15829: PPUSH
15830: LD_INT 2
15832: NEG
15833: PPUSH
15834: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15838: LD_EXP 17
15842: PUSH
15843: LD_INT 5
15845: PUSH
15846: LD_INT 4
15848: PUSH
15849: LD_INT 3
15851: PUSH
15852: LD_INT 3
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: LIST
15859: LIST
15860: PUSH
15861: LD_OWVAR 67
15865: ARRAY
15866: GREATEREQUAL
15867: IFFALSE 15882
// AddMedal ( Destroy , - 2 ) else
15869: LD_STRING Destroy
15871: PPUSH
15872: LD_INT 2
15874: NEG
15875: PPUSH
15876: CALL_OW 101
15880: GO 16015
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15882: LD_INT 22
15884: PUSH
15885: LD_INT 2
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: PUSH
15892: LD_INT 21
15894: PUSH
15895: LD_INT 3
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PUSH
15902: LD_INT 50
15904: PUSH
15905: EMPTY
15906: LIST
15907: PUSH
15908: EMPTY
15909: LIST
15910: LIST
15911: LIST
15912: PPUSH
15913: CALL_OW 69
15917: PUSH
15918: LD_INT 25
15920: GREATEREQUAL
15921: IFFALSE 15936
// AddMedal ( Destroy , - 1 ) else
15923: LD_STRING Destroy
15925: PPUSH
15926: LD_INT 1
15928: NEG
15929: PPUSH
15930: CALL_OW 101
15934: GO 16015
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15936: LD_INT 22
15938: PUSH
15939: LD_INT 2
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PUSH
15946: LD_INT 21
15948: PUSH
15949: LD_INT 3
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: PUSH
15956: LD_INT 50
15958: PUSH
15959: EMPTY
15960: LIST
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: LIST
15966: PPUSH
15967: CALL_OW 69
15971: PUSH
15972: LD_INT 15
15974: GREATEREQUAL
15975: IFFALSE 15997
// begin m1 := true ;
15977: LD_ADDR_VAR 0 3
15981: PUSH
15982: LD_INT 1
15984: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15985: LD_STRING Destroy
15987: PPUSH
15988: LD_INT 1
15990: PPUSH
15991: CALL_OW 101
// end else
15995: GO 16015
// begin m1 := true ;
15997: LD_ADDR_VAR 0 3
16001: PUSH
16002: LD_INT 1
16004: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16005: LD_STRING Destroy
16007: PPUSH
16008: LD_INT 2
16010: PPUSH
16011: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16015: LD_EXP 13
16019: PPUSH
16020: LD_STRING 11_artifact_captured
16022: PPUSH
16023: CALL_OW 39
// if artifact_get then
16027: LD_EXP 13
16031: IFFALSE 16053
// begin m2 := true ;
16033: LD_ADDR_VAR 0 4
16037: PUSH
16038: LD_INT 1
16040: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16041: LD_STRING Artefact
16043: PPUSH
16044: LD_INT 1
16046: PPUSH
16047: CALL_OW 101
// end else
16051: GO 16064
// AddMedal ( Artefact , - 1 ) ;
16053: LD_STRING Artefact
16055: PPUSH
16056: LD_INT 1
16058: NEG
16059: PPUSH
16060: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16064: LD_VAR 0 3
16068: PUSH
16069: LD_VAR 0 4
16073: AND
16074: PUSH
16075: LD_VAR 0 5
16079: AND
16080: PUSH
16081: LD_OWVAR 67
16085: PUSH
16086: LD_INT 3
16088: GREATEREQUAL
16089: AND
16090: IFFALSE 16102
// SetAchievementEX ( ACH_AMER , 11 ) ;
16092: LD_STRING ACH_AMER
16094: PPUSH
16095: LD_INT 11
16097: PPUSH
16098: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16102: LD_VAR 0 3
16106: PUSH
16107: LD_VAR 0 4
16111: AND
16112: PUSH
16113: LD_VAR 0 5
16117: AND
16118: PUSH
16119: LD_EXP 17
16123: PUSH
16124: LD_INT 0
16126: EQUAL
16127: AND
16128: IFFALSE 16144
// begin wait ( 3 ) ;
16130: LD_INT 3
16132: PPUSH
16133: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16137: LD_STRING ACH_GENERAL
16139: PPUSH
16140: CALL_OW 543
// end ; if tick <= 100 100$00 then
16144: LD_OWVAR 1
16148: PUSH
16149: LD_INT 210000
16151: LESSEQUAL
16152: IFFALSE 16168
// begin wait ( 3 ) ;
16154: LD_INT 3
16156: PPUSH
16157: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16161: LD_STRING ACH_ASPEED_11
16163: PPUSH
16164: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16168: LD_STRING MAIN
16170: PPUSH
16171: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16175: LD_ADDR_EXP 19
16179: PUSH
16180: LD_EXP 19
16184: PPUSH
16185: LD_INT 51
16187: PUSH
16188: EMPTY
16189: LIST
16190: PPUSH
16191: CALL_OW 72
16195: ST_TO_ADDR
// tmp := JMM ^ selected ;
16196: LD_ADDR_VAR 0 2
16200: PUSH
16201: LD_EXP 21
16205: PUSH
16206: LD_EXP 19
16210: ADD
16211: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16212: LD_VAR 0 2
16216: PPUSH
16217: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16221: LD_VAR 0 2
16225: PUSH
16226: LD_EXP 21
16230: PUSH
16231: LD_EXP 22
16235: PUSH
16236: LD_EXP 23
16240: PUSH
16241: LD_EXP 24
16245: PUSH
16246: LD_EXP 25
16250: PUSH
16251: LD_EXP 26
16255: PUSH
16256: LD_EXP 27
16260: PUSH
16261: LD_EXP 28
16265: PUSH
16266: LD_EXP 29
16270: PUSH
16271: LD_EXP 31
16275: PUSH
16276: LD_EXP 32
16280: PUSH
16281: LD_EXP 33
16285: PUSH
16286: LD_EXP 34
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: LIST
16295: LIST
16296: LIST
16297: LIST
16298: LIST
16299: LIST
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: DIFF
16306: PPUSH
16307: LD_STRING 11c_others
16309: PPUSH
16310: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16314: LD_EXP 21
16318: PPUSH
16319: LD_EXP 3
16323: PUSH
16324: LD_STRING JMM
16326: STR
16327: PPUSH
16328: CALL_OW 38
// if Lisa then
16332: LD_EXP 22
16336: IFFALSE 16356
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16338: LD_EXP 22
16342: PPUSH
16343: LD_EXP 3
16347: PUSH
16348: LD_STRING Lisa
16350: STR
16351: PPUSH
16352: CALL_OW 38
// if Donaldson then
16356: LD_EXP 23
16360: IFFALSE 16380
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16362: LD_EXP 23
16366: PPUSH
16367: LD_EXP 3
16371: PUSH
16372: LD_STRING Donaldson
16374: STR
16375: PPUSH
16376: CALL_OW 38
// if Bobby then
16380: LD_EXP 24
16384: IFFALSE 16404
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16386: LD_EXP 24
16390: PPUSH
16391: LD_EXP 3
16395: PUSH
16396: LD_STRING Bobby
16398: STR
16399: PPUSH
16400: CALL_OW 38
// if Cyrus then
16404: LD_EXP 25
16408: IFFALSE 16428
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16410: LD_EXP 25
16414: PPUSH
16415: LD_EXP 3
16419: PUSH
16420: LD_STRING Cyrus
16422: STR
16423: PPUSH
16424: CALL_OW 38
// if Denis then
16428: LD_EXP 26
16432: IFFALSE 16452
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16434: LD_EXP 26
16438: PPUSH
16439: LD_EXP 3
16443: PUSH
16444: LD_STRING Denis
16446: STR
16447: PPUSH
16448: CALL_OW 38
// if Brown then
16452: LD_EXP 27
16456: IFFALSE 16476
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16458: LD_EXP 27
16462: PPUSH
16463: LD_EXP 3
16467: PUSH
16468: LD_STRING Brown
16470: STR
16471: PPUSH
16472: CALL_OW 38
// if Gladstone then
16476: LD_EXP 28
16480: IFFALSE 16500
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16482: LD_EXP 28
16486: PPUSH
16487: LD_EXP 3
16491: PUSH
16492: LD_STRING Gladstone
16494: STR
16495: PPUSH
16496: CALL_OW 38
// if Houten then
16500: LD_EXP 29
16504: IFFALSE 16524
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16506: LD_EXP 29
16510: PPUSH
16511: LD_EXP 3
16515: PUSH
16516: LD_STRING Houten
16518: STR
16519: PPUSH
16520: CALL_OW 38
// if Cornel then
16524: LD_EXP 31
16528: IFFALSE 16548
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16530: LD_EXP 31
16534: PPUSH
16535: LD_EXP 3
16539: PUSH
16540: LD_STRING Cornell
16542: STR
16543: PPUSH
16544: CALL_OW 38
// if Gary then
16548: LD_EXP 32
16552: IFFALSE 16572
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16554: LD_EXP 32
16558: PPUSH
16559: LD_EXP 3
16563: PUSH
16564: LD_STRING Gary
16566: STR
16567: PPUSH
16568: CALL_OW 38
// if Frank then
16572: LD_EXP 33
16576: IFFALSE 16596
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16578: LD_EXP 33
16582: PPUSH
16583: LD_EXP 3
16587: PUSH
16588: LD_STRING Frank
16590: STR
16591: PPUSH
16592: CALL_OW 38
// if Kikuchi then
16596: LD_EXP 34
16600: IFFALSE 16620
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16602: LD_EXP 34
16606: PPUSH
16607: LD_EXP 3
16611: PUSH
16612: LD_STRING Kikuchi
16614: STR
16615: PPUSH
16616: CALL_OW 38
// YouWin ;
16620: CALL_OW 103
// end ;
16624: LD_VAR 0 1
16628: RET
// export function CanSayRand ( side ) ; begin
16629: LD_INT 0
16631: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16632: LD_ADDR_VAR 0 2
16636: PUSH
16637: LD_INT 52
16639: PUSH
16640: EMPTY
16641: LIST
16642: PUSH
16643: LD_INT 22
16645: PUSH
16646: LD_VAR 0 1
16650: PUSH
16651: EMPTY
16652: LIST
16653: LIST
16654: PUSH
16655: LD_INT 2
16657: PUSH
16658: LD_INT 25
16660: PUSH
16661: LD_INT 1
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: LD_INT 25
16670: PUSH
16671: LD_INT 2
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 25
16680: PUSH
16681: LD_INT 3
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 25
16690: PUSH
16691: LD_INT 4
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: LIST
16709: PPUSH
16710: CALL_OW 69
16714: PUSH
16715: LD_EXP 21
16719: PUSH
16720: LD_EXP 33
16724: PUSH
16725: LD_EXP 22
16729: PUSH
16730: LD_EXP 23
16734: PUSH
16735: LD_EXP 24
16739: PUSH
16740: LD_EXP 25
16744: PUSH
16745: LD_EXP 26
16749: PUSH
16750: LD_EXP 27
16754: PUSH
16755: LD_EXP 28
16759: PUSH
16760: LD_EXP 29
16764: PUSH
16765: LD_EXP 30
16769: PUSH
16770: LD_EXP 31
16774: PUSH
16775: LD_EXP 32
16779: PUSH
16780: LD_EXP 34
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: LIST
16797: LIST
16798: LIST
16799: LIST
16800: DIFF
16801: ST_TO_ADDR
// end ;
16802: LD_VAR 0 2
16806: RET
// export function SayRand ( sex , dial ) ; begin
16807: LD_INT 0
16809: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16810: LD_ADDR_VAR 0 3
16814: PUSH
16815: LD_INT 52
16817: PUSH
16818: EMPTY
16819: LIST
16820: PUSH
16821: LD_INT 22
16823: PUSH
16824: LD_INT 1
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 26
16833: PUSH
16834: LD_VAR 0 1
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 2
16845: PUSH
16846: LD_INT 25
16848: PUSH
16849: LD_INT 1
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 25
16858: PUSH
16859: LD_INT 2
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: LD_INT 25
16868: PUSH
16869: LD_INT 3
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: PUSH
16876: LD_INT 25
16878: PUSH
16879: LD_INT 4
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: PPUSH
16899: CALL_OW 69
16903: PUSH
16904: LD_EXP 21
16908: PUSH
16909: LD_EXP 33
16913: PUSH
16914: LD_EXP 22
16918: PUSH
16919: LD_EXP 23
16923: PUSH
16924: LD_EXP 24
16928: PUSH
16929: LD_EXP 25
16933: PUSH
16934: LD_EXP 26
16938: PUSH
16939: LD_EXP 27
16943: PUSH
16944: LD_EXP 28
16948: PUSH
16949: LD_EXP 29
16953: PUSH
16954: LD_EXP 30
16958: PUSH
16959: LD_EXP 31
16963: PUSH
16964: LD_EXP 32
16968: PUSH
16969: LD_EXP 34
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: LIST
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: DIFF
16990: ST_TO_ADDR
// if not result then
16991: LD_VAR 0 3
16995: NOT
16996: IFFALSE 17000
// exit ;
16998: GO 17028
// result := result [ 1 ] ;
17000: LD_ADDR_VAR 0 3
17004: PUSH
17005: LD_VAR 0 3
17009: PUSH
17010: LD_INT 1
17012: ARRAY
17013: ST_TO_ADDR
// Say ( result , dial ) ;
17014: LD_VAR 0 3
17018: PPUSH
17019: LD_VAR 0 2
17023: PPUSH
17024: CALL_OW 88
// end ;
17028: LD_VAR 0 3
17032: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17033: LD_INT 0
17035: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17036: LD_ADDR_VAR 0 4
17040: PUSH
17041: LD_INT 22
17043: PUSH
17044: LD_INT 1
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 26
17053: PUSH
17054: LD_VAR 0 1
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: LD_INT 2
17065: PUSH
17066: LD_INT 25
17068: PUSH
17069: LD_INT 1
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 25
17078: PUSH
17079: LD_INT 2
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: LD_INT 25
17088: PUSH
17089: LD_INT 3
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 25
17098: PUSH
17099: LD_INT 4
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: PPUSH
17118: CALL_OW 69
17122: PUSH
17123: LD_EXP 21
17127: PUSH
17128: LD_EXP 33
17132: PUSH
17133: LD_EXP 22
17137: PUSH
17138: LD_EXP 23
17142: PUSH
17143: LD_EXP 24
17147: PUSH
17148: LD_EXP 25
17152: PUSH
17153: LD_EXP 26
17157: PUSH
17158: LD_EXP 27
17162: PUSH
17163: LD_EXP 28
17167: PUSH
17168: LD_EXP 29
17172: PUSH
17173: LD_EXP 30
17177: PUSH
17178: LD_EXP 31
17182: PUSH
17183: LD_EXP 32
17187: PUSH
17188: LD_EXP 34
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: PUSH
17209: LD_VAR 0 3
17213: ADD
17214: DIFF
17215: ST_TO_ADDR
// if not result then
17216: LD_VAR 0 4
17220: NOT
17221: IFFALSE 17225
// exit ;
17223: GO 17253
// result := result [ 1 ] ;
17225: LD_ADDR_VAR 0 4
17229: PUSH
17230: LD_VAR 0 4
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: ST_TO_ADDR
// Say ( result , dial ) ;
17239: LD_VAR 0 4
17243: PPUSH
17244: LD_VAR 0 2
17248: PPUSH
17249: CALL_OW 88
// end ; end_of_file
17253: LD_VAR 0 4
17257: RET
// export function CustomEvent ( event ) ; begin
17258: LD_INT 0
17260: PPUSH
// end ;
17261: LD_VAR 0 2
17265: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17266: LD_VAR 0 1
17270: PPUSH
17271: CALL_OW 255
17275: PUSH
17276: LD_INT 1
17278: EQUAL
17279: IFFALSE 17289
// artifact_get := true ;
17281: LD_ADDR_EXP 13
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17289: LD_VAR 0 1
17293: PPUSH
17294: CALL_OW 255
17298: PUSH
17299: LD_INT 2
17301: EQUAL
17302: IFFALSE 17320
// begin artifact_get := false ;
17304: LD_ADDR_EXP 13
17308: PUSH
17309: LD_INT 0
17311: ST_TO_ADDR
// artifact_stolen := true ;
17312: LD_ADDR_EXP 12
17316: PUSH
17317: LD_INT 1
17319: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17320: LD_ADDR_EXP 14
17324: PUSH
17325: LD_INT 1
17327: ST_TO_ADDR
// end ;
17328: PPOPN 2
17330: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17331: LD_ADDR_EXP 14
17335: PUSH
17336: LD_INT 0
17338: ST_TO_ADDR
// end ;
17339: PPOPN 2
17341: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17342: LD_VAR 0 1
17346: PPUSH
17347: CALL 107797 0 1
// if un = JMM then
17351: LD_VAR 0 1
17355: PUSH
17356: LD_EXP 21
17360: EQUAL
17361: IFFALSE 17372
// begin YouLost ( JMM ) ;
17363: LD_STRING JMM
17365: PPUSH
17366: CALL_OW 104
// exit ;
17370: GO 17504
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17372: LD_VAR 0 1
17376: PUSH
17377: LD_INT 22
17379: PUSH
17380: LD_INT 1
17382: PUSH
17383: EMPTY
17384: LIST
17385: LIST
17386: PUSH
17387: LD_INT 21
17389: PUSH
17390: LD_INT 1
17392: PUSH
17393: EMPTY
17394: LIST
17395: LIST
17396: PUSH
17397: LD_INT 2
17399: PUSH
17400: LD_INT 25
17402: PUSH
17403: LD_INT 1
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PUSH
17410: LD_INT 25
17412: PUSH
17413: LD_INT 2
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: PUSH
17420: LD_INT 25
17422: PUSH
17423: LD_INT 3
17425: PUSH
17426: EMPTY
17427: LIST
17428: LIST
17429: PUSH
17430: LD_INT 25
17432: PUSH
17433: LD_INT 4
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: PUSH
17440: LD_INT 25
17442: PUSH
17443: LD_INT 5
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: PUSH
17450: LD_INT 25
17452: PUSH
17453: LD_INT 8
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: LIST
17465: LIST
17466: LIST
17467: LIST
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: LIST
17473: PPUSH
17474: CALL_OW 69
17478: IN
17479: IFFALSE 17495
// loses_counter := loses_counter + 1 ;
17481: LD_ADDR_EXP 17
17485: PUSH
17486: LD_EXP 17
17490: PUSH
17491: LD_INT 1
17493: PLUS
17494: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17495: LD_VAR 0 1
17499: PPUSH
17500: CALL 45981 0 1
// end ;
17504: PPOPN 1
17506: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17507: LD_VAR 0 1
17511: PPUSH
17512: LD_VAR 0 2
17516: PPUSH
17517: CALL 48313 0 2
// end ;
17521: PPOPN 2
17523: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17524: LD_VAR 0 1
17528: PPUSH
17529: CALL 47622 0 1
// end ;
17533: PPOPN 1
17535: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17536: LD_VAR 0 1
17540: PPUSH
17541: LD_VAR 0 2
17545: PPUSH
17546: LD_VAR 0 3
17550: PPUSH
17551: LD_VAR 0 4
17555: PPUSH
17556: LD_VAR 0 5
17560: PPUSH
17561: CALL 45297 0 5
// end ;
17565: PPOPN 5
17567: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17568: LD_VAR 0 1
17572: PPUSH
17573: LD_VAR 0 2
17577: PPUSH
17578: CALL 107855 0 2
// if GetNation ( vehicle ) = nation_american then
17582: LD_VAR 0 1
17586: PPUSH
17587: CALL_OW 248
17591: PUSH
17592: LD_INT 1
17594: EQUAL
17595: IFFALSE 17605
// am_veh_consturcted := true ;
17597: LD_ADDR_EXP 20
17601: PUSH
17602: LD_INT 1
17604: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17605: LD_VAR 0 1
17609: PPUSH
17610: LD_VAR 0 2
17614: PPUSH
17615: CALL 44850 0 2
// end ;
17619: PPOPN 2
17621: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17622: LD_VAR 0 1
17626: PPUSH
17627: CALL_OW 247
17631: PUSH
17632: LD_INT 2
17634: EQUAL
17635: IFFALSE 17639
// exit ;
17637: GO 17656
// if not kamikazed then
17639: LD_EXP 11
17643: NOT
17644: IFFALSE 17656
// kamikazed := unit ;
17646: LD_ADDR_EXP 11
17650: PUSH
17651: LD_VAR 0 1
17655: ST_TO_ADDR
// end ;
17656: PPOPN 1
17658: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17663: LD_VAR 0 1
17667: PPUSH
17668: LD_VAR 0 2
17672: PPUSH
17673: LD_VAR 0 3
17677: PPUSH
17678: LD_VAR 0 4
17682: PPUSH
17683: CALL 44688 0 4
// end ;
17687: PPOPN 6
17689: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17690: LD_INT 0
17692: PPUSH
// begin if building = ar_dep_n then
17693: LD_VAR 0 1
17697: PUSH
17698: LD_INT 94
17700: EQUAL
17701: IFFALSE 17753
// begin for i := 1 to 3 do
17703: LD_ADDR_VAR 0 4
17707: PUSH
17708: DOUBLE
17709: LD_INT 1
17711: DEC
17712: ST_TO_ADDR
17713: LD_INT 3
17715: PUSH
17716: FOR_TO
17717: IFFALSE 17751
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17719: LD_INT 115
17721: PUSH
17722: LD_VAR 0 4
17726: PUSH
17727: LD_INT 2
17729: MUL
17730: PLUS
17731: PPUSH
17732: LD_INT 6
17734: PPUSH
17735: LD_INT 1
17737: PPUSH
17738: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17742: LD_INT 10
17744: PPUSH
17745: CALL_OW 67
// end ;
17749: GO 17716
17751: POP
17752: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17753: LD_VAR 0 1
17757: PPUSH
17758: LD_VAR 0 2
17762: PPUSH
17763: LD_VAR 0 3
17767: PPUSH
17768: CALL 44463 0 3
// end ;
17772: PPOPN 4
17774: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17775: LD_VAR 0 1
17779: PPUSH
17780: LD_VAR 0 2
17784: PPUSH
17785: CALL 45677 0 2
// end ;
17789: PPOPN 2
17791: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17792: LD_VAR 0 1
17796: PPUSH
17797: LD_VAR 0 2
17801: PPUSH
17802: CALL 44157 0 2
// end ;
17806: PPOPN 2
17808: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17809: LD_VAR 0 1
17813: PPUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL 44348 0 2
// end ;
17823: PPOPN 2
17825: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17826: LD_VAR 0 1
17830: PPUSH
17831: CALL 47381 0 1
// end ;
17835: PPOPN 1
17837: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17838: LD_VAR 0 1
17842: PPUSH
17843: LD_VAR 0 2
17847: PPUSH
17848: CALL 48608 0 2
// end ;
17852: PPOPN 2
17854: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17855: LD_VAR 0 1
17859: PPUSH
17860: LD_VAR 0 2
17864: PPUSH
17865: LD_VAR 0 3
17869: PPUSH
17870: LD_VAR 0 4
17874: PPUSH
17875: CALL 48824 0 4
// end ;
17879: PPOPN 4
17881: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17882: LD_VAR 0 1
17886: PPUSH
17887: CALL 107839 0 1
// end ;
17891: PPOPN 1
17893: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
17894: LD_INT 22
17896: PUSH
17897: LD_INT 2
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: PUSH
17904: LD_INT 50
17906: PUSH
17907: EMPTY
17908: LIST
17909: PUSH
17910: LD_INT 21
17912: PUSH
17913: LD_INT 1
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: LIST
17924: PPUSH
17925: CALL_OW 69
17929: IFFALSE 18013
17931: GO 17933
17933: DISABLE
17934: LD_INT 0
17936: PPUSH
// begin enable ;
17937: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
17938: LD_ADDR_VAR 0 1
17942: PUSH
17943: LD_INT 22
17945: PUSH
17946: LD_INT 2
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: PUSH
17953: LD_INT 50
17955: PUSH
17956: EMPTY
17957: LIST
17958: PUSH
17959: LD_INT 21
17961: PUSH
17962: LD_INT 1
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: PPUSH
17974: CALL_OW 69
17978: PUSH
17979: FOR_IN
17980: IFFALSE 18011
// if GetFuel ( i ) < 3 then
17982: LD_VAR 0 1
17986: PPUSH
17987: CALL_OW 261
17991: PUSH
17992: LD_INT 3
17994: LESS
17995: IFFALSE 18009
// SetFuel ( i , 5 ) ;
17997: LD_VAR 0 1
18001: PPUSH
18002: LD_INT 5
18004: PPUSH
18005: CALL_OW 240
18009: GO 17979
18011: POP
18012: POP
// end ; end_of_file
18013: PPOPN 1
18015: END
// every 0 0$1 trigger game do
18016: LD_EXP 2
18020: IFFALSE 18050
18022: GO 18024
18024: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18025: LD_INT 7
18027: PUSH
18028: LD_INT 6
18030: PUSH
18031: LD_INT 4
18033: PUSH
18034: LD_INT 6
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: PPUSH
18043: LD_INT 1750
18045: PPUSH
18046: CALL 18051 0 2
18050: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18051: LD_INT 0
18053: PPUSH
18054: PPUSH
18055: PPUSH
// if not areas then
18056: LD_VAR 0 1
18060: NOT
18061: IFFALSE 18065
// exit ;
18063: GO 18195
// repeat wait ( time ) ;
18065: LD_VAR 0 2
18069: PPUSH
18070: CALL_OW 67
// for i in areas do
18074: LD_ADDR_VAR 0 4
18078: PUSH
18079: LD_VAR 0 1
18083: PUSH
18084: FOR_IN
18085: IFFALSE 18154
// begin p := rand ( 1 , 90 ) ;
18087: LD_ADDR_VAR 0 5
18091: PUSH
18092: LD_INT 1
18094: PPUSH
18095: LD_INT 90
18097: PPUSH
18098: CALL_OW 12
18102: ST_TO_ADDR
// if Prob ( p ) then
18103: LD_VAR 0 5
18107: PPUSH
18108: CALL_OW 13
18112: IFFALSE 18152
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18114: LD_INT 2
18116: PPUSH
18117: LD_INT 5
18119: PPUSH
18120: CALL_OW 12
18124: PPUSH
18125: LD_VAR 0 4
18129: PPUSH
18130: LD_INT 1
18132: PPUSH
18133: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18137: LD_INT 735
18139: PPUSH
18140: LD_INT 1295
18142: PPUSH
18143: CALL_OW 12
18147: PPUSH
18148: CALL_OW 67
// end ; end ;
18152: GO 18084
18154: POP
18155: POP
// time := time + 0 0$3 ;
18156: LD_ADDR_VAR 0 2
18160: PUSH
18161: LD_VAR 0 2
18165: PUSH
18166: LD_INT 105
18168: PLUS
18169: ST_TO_ADDR
// if time > 3 3$00 then
18170: LD_VAR 0 2
18174: PUSH
18175: LD_INT 6300
18177: GREATER
18178: IFFALSE 18188
// time := 0 0$40 ;
18180: LD_ADDR_VAR 0 2
18184: PUSH
18185: LD_INT 1400
18187: ST_TO_ADDR
// until not game ;
18188: LD_EXP 2
18192: NOT
18193: IFFALSE 18065
// end ;
18195: LD_VAR 0 3
18199: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18200: LD_OWVAR 1
18204: PUSH
18205: LD_INT 84000
18207: PUSH
18208: LD_INT 73500
18210: PUSH
18211: LD_INT 63000
18213: PUSH
18214: LD_INT 52500
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: PUSH
18223: LD_OWVAR 67
18227: ARRAY
18228: LESS
18229: IFFALSE 18256
18231: GO 18233
18233: DISABLE
// begin enable ;
18234: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18235: LD_INT 1
18237: PPUSH
18238: LD_INT 5
18240: PPUSH
18241: CALL_OW 12
18245: PPUSH
18246: LD_INT 7
18248: PPUSH
18249: LD_INT 1
18251: PPUSH
18252: CALL_OW 55
// end ; end_of_file
18256: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18257: LD_INT 0
18259: PPUSH
18260: PPUSH
// skirmish := false ;
18261: LD_ADDR_EXP 48
18265: PUSH
18266: LD_INT 0
18268: ST_TO_ADDR
// debug_mc := false ;
18269: LD_ADDR_EXP 49
18273: PUSH
18274: LD_INT 0
18276: ST_TO_ADDR
// mc_bases := [ ] ;
18277: LD_ADDR_EXP 50
18281: PUSH
18282: EMPTY
18283: ST_TO_ADDR
// mc_sides := [ ] ;
18284: LD_ADDR_EXP 76
18288: PUSH
18289: EMPTY
18290: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18291: LD_ADDR_EXP 51
18295: PUSH
18296: EMPTY
18297: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18298: LD_ADDR_EXP 52
18302: PUSH
18303: EMPTY
18304: ST_TO_ADDR
// mc_need_heal := [ ] ;
18305: LD_ADDR_EXP 53
18309: PUSH
18310: EMPTY
18311: ST_TO_ADDR
// mc_healers := [ ] ;
18312: LD_ADDR_EXP 54
18316: PUSH
18317: EMPTY
18318: ST_TO_ADDR
// mc_build_list := [ ] ;
18319: LD_ADDR_EXP 55
18323: PUSH
18324: EMPTY
18325: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18326: LD_ADDR_EXP 82
18330: PUSH
18331: EMPTY
18332: ST_TO_ADDR
// mc_builders := [ ] ;
18333: LD_ADDR_EXP 56
18337: PUSH
18338: EMPTY
18339: ST_TO_ADDR
// mc_construct_list := [ ] ;
18340: LD_ADDR_EXP 57
18344: PUSH
18345: EMPTY
18346: ST_TO_ADDR
// mc_turret_list := [ ] ;
18347: LD_ADDR_EXP 58
18351: PUSH
18352: EMPTY
18353: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18354: LD_ADDR_EXP 59
18358: PUSH
18359: EMPTY
18360: ST_TO_ADDR
// mc_miners := [ ] ;
18361: LD_ADDR_EXP 64
18365: PUSH
18366: EMPTY
18367: ST_TO_ADDR
// mc_mines := [ ] ;
18368: LD_ADDR_EXP 63
18372: PUSH
18373: EMPTY
18374: ST_TO_ADDR
// mc_minefields := [ ] ;
18375: LD_ADDR_EXP 65
18379: PUSH
18380: EMPTY
18381: ST_TO_ADDR
// mc_crates := [ ] ;
18382: LD_ADDR_EXP 66
18386: PUSH
18387: EMPTY
18388: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18389: LD_ADDR_EXP 67
18393: PUSH
18394: EMPTY
18395: ST_TO_ADDR
// mc_crates_area := [ ] ;
18396: LD_ADDR_EXP 68
18400: PUSH
18401: EMPTY
18402: ST_TO_ADDR
// mc_vehicles := [ ] ;
18403: LD_ADDR_EXP 69
18407: PUSH
18408: EMPTY
18409: ST_TO_ADDR
// mc_attack := [ ] ;
18410: LD_ADDR_EXP 70
18414: PUSH
18415: EMPTY
18416: ST_TO_ADDR
// mc_produce := [ ] ;
18417: LD_ADDR_EXP 71
18421: PUSH
18422: EMPTY
18423: ST_TO_ADDR
// mc_defender := [ ] ;
18424: LD_ADDR_EXP 72
18428: PUSH
18429: EMPTY
18430: ST_TO_ADDR
// mc_parking := [ ] ;
18431: LD_ADDR_EXP 74
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18438: LD_ADDR_EXP 60
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18445: LD_ADDR_EXP 62
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_scan := [ ] ;
18452: LD_ADDR_EXP 73
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_scan_area := [ ] ;
18459: LD_ADDR_EXP 75
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_tech := [ ] ;
18466: LD_ADDR_EXP 77
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_class := [ ] ;
18473: LD_ADDR_EXP 91
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18480: LD_ADDR_EXP 92
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_is_defending := [ ] ;
18487: LD_ADDR_EXP 93
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18494: LD_ADDR_EXP 84
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18501: LD_ADDR_EXP 94
18505: PUSH
18506: LD_INT 0
18508: ST_TO_ADDR
// end ;
18509: LD_VAR 0 1
18513: RET
// export function MC_Kill ( base ) ; begin
18514: LD_INT 0
18516: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18517: LD_ADDR_EXP 50
18521: PUSH
18522: LD_EXP 50
18526: PPUSH
18527: LD_VAR 0 1
18531: PPUSH
18532: EMPTY
18533: PPUSH
18534: CALL_OW 1
18538: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18539: LD_ADDR_EXP 51
18543: PUSH
18544: LD_EXP 51
18548: PPUSH
18549: LD_VAR 0 1
18553: PPUSH
18554: EMPTY
18555: PPUSH
18556: CALL_OW 1
18560: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18561: LD_ADDR_EXP 52
18565: PUSH
18566: LD_EXP 52
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: EMPTY
18577: PPUSH
18578: CALL_OW 1
18582: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18583: LD_ADDR_EXP 53
18587: PUSH
18588: LD_EXP 53
18592: PPUSH
18593: LD_VAR 0 1
18597: PPUSH
18598: EMPTY
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18605: LD_ADDR_EXP 54
18609: PUSH
18610: LD_EXP 54
18614: PPUSH
18615: LD_VAR 0 1
18619: PPUSH
18620: EMPTY
18621: PPUSH
18622: CALL_OW 1
18626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18627: LD_ADDR_EXP 55
18631: PUSH
18632: LD_EXP 55
18636: PPUSH
18637: LD_VAR 0 1
18641: PPUSH
18642: EMPTY
18643: PPUSH
18644: CALL_OW 1
18648: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18649: LD_ADDR_EXP 56
18653: PUSH
18654: LD_EXP 56
18658: PPUSH
18659: LD_VAR 0 1
18663: PPUSH
18664: EMPTY
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18671: LD_ADDR_EXP 57
18675: PUSH
18676: LD_EXP 57
18680: PPUSH
18681: LD_VAR 0 1
18685: PPUSH
18686: EMPTY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18693: LD_ADDR_EXP 58
18697: PUSH
18698: LD_EXP 58
18702: PPUSH
18703: LD_VAR 0 1
18707: PPUSH
18708: EMPTY
18709: PPUSH
18710: CALL_OW 1
18714: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18715: LD_ADDR_EXP 59
18719: PUSH
18720: LD_EXP 59
18724: PPUSH
18725: LD_VAR 0 1
18729: PPUSH
18730: EMPTY
18731: PPUSH
18732: CALL_OW 1
18736: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18737: LD_ADDR_EXP 60
18741: PUSH
18742: LD_EXP 60
18746: PPUSH
18747: LD_VAR 0 1
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18759: LD_ADDR_EXP 61
18763: PUSH
18764: LD_EXP 61
18768: PPUSH
18769: LD_VAR 0 1
18773: PPUSH
18774: LD_INT 0
18776: PPUSH
18777: CALL_OW 1
18781: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18782: LD_ADDR_EXP 62
18786: PUSH
18787: LD_EXP 62
18791: PPUSH
18792: LD_VAR 0 1
18796: PPUSH
18797: EMPTY
18798: PPUSH
18799: CALL_OW 1
18803: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18804: LD_ADDR_EXP 63
18808: PUSH
18809: LD_EXP 63
18813: PPUSH
18814: LD_VAR 0 1
18818: PPUSH
18819: EMPTY
18820: PPUSH
18821: CALL_OW 1
18825: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18826: LD_ADDR_EXP 64
18830: PUSH
18831: LD_EXP 64
18835: PPUSH
18836: LD_VAR 0 1
18840: PPUSH
18841: EMPTY
18842: PPUSH
18843: CALL_OW 1
18847: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18848: LD_ADDR_EXP 65
18852: PUSH
18853: LD_EXP 65
18857: PPUSH
18858: LD_VAR 0 1
18862: PPUSH
18863: EMPTY
18864: PPUSH
18865: CALL_OW 1
18869: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18870: LD_ADDR_EXP 66
18874: PUSH
18875: LD_EXP 66
18879: PPUSH
18880: LD_VAR 0 1
18884: PPUSH
18885: EMPTY
18886: PPUSH
18887: CALL_OW 1
18891: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18892: LD_ADDR_EXP 67
18896: PUSH
18897: LD_EXP 67
18901: PPUSH
18902: LD_VAR 0 1
18906: PPUSH
18907: EMPTY
18908: PPUSH
18909: CALL_OW 1
18913: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18914: LD_ADDR_EXP 68
18918: PUSH
18919: LD_EXP 68
18923: PPUSH
18924: LD_VAR 0 1
18928: PPUSH
18929: EMPTY
18930: PPUSH
18931: CALL_OW 1
18935: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18936: LD_ADDR_EXP 69
18940: PUSH
18941: LD_EXP 69
18945: PPUSH
18946: LD_VAR 0 1
18950: PPUSH
18951: EMPTY
18952: PPUSH
18953: CALL_OW 1
18957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18958: LD_ADDR_EXP 70
18962: PUSH
18963: LD_EXP 70
18967: PPUSH
18968: LD_VAR 0 1
18972: PPUSH
18973: EMPTY
18974: PPUSH
18975: CALL_OW 1
18979: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18980: LD_ADDR_EXP 71
18984: PUSH
18985: LD_EXP 71
18989: PPUSH
18990: LD_VAR 0 1
18994: PPUSH
18995: EMPTY
18996: PPUSH
18997: CALL_OW 1
19001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19002: LD_ADDR_EXP 72
19006: PUSH
19007: LD_EXP 72
19011: PPUSH
19012: LD_VAR 0 1
19016: PPUSH
19017: EMPTY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19024: LD_ADDR_EXP 73
19028: PUSH
19029: LD_EXP 73
19033: PPUSH
19034: LD_VAR 0 1
19038: PPUSH
19039: EMPTY
19040: PPUSH
19041: CALL_OW 1
19045: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19046: LD_ADDR_EXP 74
19050: PUSH
19051: LD_EXP 74
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: EMPTY
19062: PPUSH
19063: CALL_OW 1
19067: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19068: LD_ADDR_EXP 75
19072: PUSH
19073: LD_EXP 75
19077: PPUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: EMPTY
19084: PPUSH
19085: CALL_OW 1
19089: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19090: LD_ADDR_EXP 77
19094: PUSH
19095: LD_EXP 77
19099: PPUSH
19100: LD_VAR 0 1
19104: PPUSH
19105: EMPTY
19106: PPUSH
19107: CALL_OW 1
19111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19112: LD_ADDR_EXP 79
19116: PUSH
19117: LD_EXP 79
19121: PPUSH
19122: LD_VAR 0 1
19126: PPUSH
19127: EMPTY
19128: PPUSH
19129: CALL_OW 1
19133: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19134: LD_ADDR_EXP 80
19138: PUSH
19139: LD_EXP 80
19143: PPUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: EMPTY
19150: PPUSH
19151: CALL_OW 1
19155: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19156: LD_ADDR_EXP 81
19160: PUSH
19161: LD_EXP 81
19165: PPUSH
19166: LD_VAR 0 1
19170: PPUSH
19171: EMPTY
19172: PPUSH
19173: CALL_OW 1
19177: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19178: LD_ADDR_EXP 82
19182: PUSH
19183: LD_EXP 82
19187: PPUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: EMPTY
19194: PPUSH
19195: CALL_OW 1
19199: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19200: LD_ADDR_EXP 83
19204: PUSH
19205: LD_EXP 83
19209: PPUSH
19210: LD_VAR 0 1
19214: PPUSH
19215: EMPTY
19216: PPUSH
19217: CALL_OW 1
19221: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19222: LD_ADDR_EXP 84
19226: PUSH
19227: LD_EXP 84
19231: PPUSH
19232: LD_VAR 0 1
19236: PPUSH
19237: EMPTY
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19244: LD_ADDR_EXP 85
19248: PUSH
19249: LD_EXP 85
19253: PPUSH
19254: LD_VAR 0 1
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL_OW 1
19265: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19266: LD_ADDR_EXP 86
19270: PUSH
19271: LD_EXP 86
19275: PPUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: EMPTY
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19288: LD_ADDR_EXP 87
19292: PUSH
19293: LD_EXP 87
19297: PPUSH
19298: LD_VAR 0 1
19302: PPUSH
19303: EMPTY
19304: PPUSH
19305: CALL_OW 1
19309: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19310: LD_ADDR_EXP 88
19314: PUSH
19315: LD_EXP 88
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: EMPTY
19326: PPUSH
19327: CALL_OW 1
19331: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19332: LD_ADDR_EXP 89
19336: PUSH
19337: LD_EXP 89
19341: PPUSH
19342: LD_VAR 0 1
19346: PPUSH
19347: EMPTY
19348: PPUSH
19349: CALL_OW 1
19353: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19354: LD_ADDR_EXP 90
19358: PUSH
19359: LD_EXP 90
19363: PPUSH
19364: LD_VAR 0 1
19368: PPUSH
19369: EMPTY
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19376: LD_ADDR_EXP 91
19380: PUSH
19381: LD_EXP 91
19385: PPUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: EMPTY
19392: PPUSH
19393: CALL_OW 1
19397: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19398: LD_ADDR_EXP 92
19402: PUSH
19403: LD_EXP 92
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: LD_INT 0
19415: PPUSH
19416: CALL_OW 1
19420: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19421: LD_ADDR_EXP 93
19425: PUSH
19426: LD_EXP 93
19430: PPUSH
19431: LD_VAR 0 1
19435: PPUSH
19436: LD_INT 0
19438: PPUSH
19439: CALL_OW 1
19443: ST_TO_ADDR
// end ;
19444: LD_VAR 0 2
19448: RET
// export function MC_Add ( side , units ) ; var base ; begin
19449: LD_INT 0
19451: PPUSH
19452: PPUSH
// base := mc_bases + 1 ;
19453: LD_ADDR_VAR 0 4
19457: PUSH
19458: LD_EXP 50
19462: PUSH
19463: LD_INT 1
19465: PLUS
19466: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19467: LD_ADDR_EXP 76
19471: PUSH
19472: LD_EXP 76
19476: PPUSH
19477: LD_VAR 0 4
19481: PPUSH
19482: LD_VAR 0 1
19486: PPUSH
19487: CALL_OW 1
19491: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19492: LD_ADDR_EXP 50
19496: PUSH
19497: LD_EXP 50
19501: PPUSH
19502: LD_VAR 0 4
19506: PPUSH
19507: LD_VAR 0 2
19511: PPUSH
19512: CALL_OW 1
19516: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19517: LD_ADDR_EXP 51
19521: PUSH
19522: LD_EXP 51
19526: PPUSH
19527: LD_VAR 0 4
19531: PPUSH
19532: EMPTY
19533: PPUSH
19534: CALL_OW 1
19538: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19539: LD_ADDR_EXP 52
19543: PUSH
19544: LD_EXP 52
19548: PPUSH
19549: LD_VAR 0 4
19553: PPUSH
19554: EMPTY
19555: PPUSH
19556: CALL_OW 1
19560: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19561: LD_ADDR_EXP 53
19565: PUSH
19566: LD_EXP 53
19570: PPUSH
19571: LD_VAR 0 4
19575: PPUSH
19576: EMPTY
19577: PPUSH
19578: CALL_OW 1
19582: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19583: LD_ADDR_EXP 54
19587: PUSH
19588: LD_EXP 54
19592: PPUSH
19593: LD_VAR 0 4
19597: PPUSH
19598: EMPTY
19599: PPUSH
19600: CALL_OW 1
19604: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19605: LD_ADDR_EXP 55
19609: PUSH
19610: LD_EXP 55
19614: PPUSH
19615: LD_VAR 0 4
19619: PPUSH
19620: EMPTY
19621: PPUSH
19622: CALL_OW 1
19626: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19627: LD_ADDR_EXP 56
19631: PUSH
19632: LD_EXP 56
19636: PPUSH
19637: LD_VAR 0 4
19641: PPUSH
19642: EMPTY
19643: PPUSH
19644: CALL_OW 1
19648: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19649: LD_ADDR_EXP 57
19653: PUSH
19654: LD_EXP 57
19658: PPUSH
19659: LD_VAR 0 4
19663: PPUSH
19664: EMPTY
19665: PPUSH
19666: CALL_OW 1
19670: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19671: LD_ADDR_EXP 58
19675: PUSH
19676: LD_EXP 58
19680: PPUSH
19681: LD_VAR 0 4
19685: PPUSH
19686: EMPTY
19687: PPUSH
19688: CALL_OW 1
19692: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19693: LD_ADDR_EXP 59
19697: PUSH
19698: LD_EXP 59
19702: PPUSH
19703: LD_VAR 0 4
19707: PPUSH
19708: EMPTY
19709: PPUSH
19710: CALL_OW 1
19714: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19715: LD_ADDR_EXP 60
19719: PUSH
19720: LD_EXP 60
19724: PPUSH
19725: LD_VAR 0 4
19729: PPUSH
19730: EMPTY
19731: PPUSH
19732: CALL_OW 1
19736: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19737: LD_ADDR_EXP 61
19741: PUSH
19742: LD_EXP 61
19746: PPUSH
19747: LD_VAR 0 4
19751: PPUSH
19752: LD_INT 0
19754: PPUSH
19755: CALL_OW 1
19759: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19760: LD_ADDR_EXP 62
19764: PUSH
19765: LD_EXP 62
19769: PPUSH
19770: LD_VAR 0 4
19774: PPUSH
19775: EMPTY
19776: PPUSH
19777: CALL_OW 1
19781: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19782: LD_ADDR_EXP 63
19786: PUSH
19787: LD_EXP 63
19791: PPUSH
19792: LD_VAR 0 4
19796: PPUSH
19797: EMPTY
19798: PPUSH
19799: CALL_OW 1
19803: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19804: LD_ADDR_EXP 64
19808: PUSH
19809: LD_EXP 64
19813: PPUSH
19814: LD_VAR 0 4
19818: PPUSH
19819: EMPTY
19820: PPUSH
19821: CALL_OW 1
19825: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19826: LD_ADDR_EXP 65
19830: PUSH
19831: LD_EXP 65
19835: PPUSH
19836: LD_VAR 0 4
19840: PPUSH
19841: EMPTY
19842: PPUSH
19843: CALL_OW 1
19847: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19848: LD_ADDR_EXP 66
19852: PUSH
19853: LD_EXP 66
19857: PPUSH
19858: LD_VAR 0 4
19862: PPUSH
19863: EMPTY
19864: PPUSH
19865: CALL_OW 1
19869: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19870: LD_ADDR_EXP 67
19874: PUSH
19875: LD_EXP 67
19879: PPUSH
19880: LD_VAR 0 4
19884: PPUSH
19885: EMPTY
19886: PPUSH
19887: CALL_OW 1
19891: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19892: LD_ADDR_EXP 68
19896: PUSH
19897: LD_EXP 68
19901: PPUSH
19902: LD_VAR 0 4
19906: PPUSH
19907: EMPTY
19908: PPUSH
19909: CALL_OW 1
19913: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19914: LD_ADDR_EXP 69
19918: PUSH
19919: LD_EXP 69
19923: PPUSH
19924: LD_VAR 0 4
19928: PPUSH
19929: EMPTY
19930: PPUSH
19931: CALL_OW 1
19935: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19936: LD_ADDR_EXP 70
19940: PUSH
19941: LD_EXP 70
19945: PPUSH
19946: LD_VAR 0 4
19950: PPUSH
19951: EMPTY
19952: PPUSH
19953: CALL_OW 1
19957: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19958: LD_ADDR_EXP 71
19962: PUSH
19963: LD_EXP 71
19967: PPUSH
19968: LD_VAR 0 4
19972: PPUSH
19973: EMPTY
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19980: LD_ADDR_EXP 72
19984: PUSH
19985: LD_EXP 72
19989: PPUSH
19990: LD_VAR 0 4
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20002: LD_ADDR_EXP 73
20006: PUSH
20007: LD_EXP 73
20011: PPUSH
20012: LD_VAR 0 4
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20024: LD_ADDR_EXP 74
20028: PUSH
20029: LD_EXP 74
20033: PPUSH
20034: LD_VAR 0 4
20038: PPUSH
20039: EMPTY
20040: PPUSH
20041: CALL_OW 1
20045: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20046: LD_ADDR_EXP 75
20050: PUSH
20051: LD_EXP 75
20055: PPUSH
20056: LD_VAR 0 4
20060: PPUSH
20061: EMPTY
20062: PPUSH
20063: CALL_OW 1
20067: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20068: LD_ADDR_EXP 77
20072: PUSH
20073: LD_EXP 77
20077: PPUSH
20078: LD_VAR 0 4
20082: PPUSH
20083: EMPTY
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20090: LD_ADDR_EXP 79
20094: PUSH
20095: LD_EXP 79
20099: PPUSH
20100: LD_VAR 0 4
20104: PPUSH
20105: EMPTY
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20112: LD_ADDR_EXP 80
20116: PUSH
20117: LD_EXP 80
20121: PPUSH
20122: LD_VAR 0 4
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20134: LD_ADDR_EXP 81
20138: PUSH
20139: LD_EXP 81
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20156: LD_ADDR_EXP 82
20160: PUSH
20161: LD_EXP 82
20165: PPUSH
20166: LD_VAR 0 4
20170: PPUSH
20171: EMPTY
20172: PPUSH
20173: CALL_OW 1
20177: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20178: LD_ADDR_EXP 83
20182: PUSH
20183: LD_EXP 83
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: EMPTY
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20200: LD_ADDR_EXP 84
20204: PUSH
20205: LD_EXP 84
20209: PPUSH
20210: LD_VAR 0 4
20214: PPUSH
20215: EMPTY
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20222: LD_ADDR_EXP 85
20226: PUSH
20227: LD_EXP 85
20231: PPUSH
20232: LD_VAR 0 4
20236: PPUSH
20237: EMPTY
20238: PPUSH
20239: CALL_OW 1
20243: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20244: LD_ADDR_EXP 86
20248: PUSH
20249: LD_EXP 86
20253: PPUSH
20254: LD_VAR 0 4
20258: PPUSH
20259: EMPTY
20260: PPUSH
20261: CALL_OW 1
20265: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20266: LD_ADDR_EXP 87
20270: PUSH
20271: LD_EXP 87
20275: PPUSH
20276: LD_VAR 0 4
20280: PPUSH
20281: EMPTY
20282: PPUSH
20283: CALL_OW 1
20287: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20288: LD_ADDR_EXP 88
20292: PUSH
20293: LD_EXP 88
20297: PPUSH
20298: LD_VAR 0 4
20302: PPUSH
20303: EMPTY
20304: PPUSH
20305: CALL_OW 1
20309: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20310: LD_ADDR_EXP 89
20314: PUSH
20315: LD_EXP 89
20319: PPUSH
20320: LD_VAR 0 4
20324: PPUSH
20325: EMPTY
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20332: LD_ADDR_EXP 90
20336: PUSH
20337: LD_EXP 90
20341: PPUSH
20342: LD_VAR 0 4
20346: PPUSH
20347: EMPTY
20348: PPUSH
20349: CALL_OW 1
20353: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20354: LD_ADDR_EXP 91
20358: PUSH
20359: LD_EXP 91
20363: PPUSH
20364: LD_VAR 0 4
20368: PPUSH
20369: EMPTY
20370: PPUSH
20371: CALL_OW 1
20375: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20376: LD_ADDR_EXP 92
20380: PUSH
20381: LD_EXP 92
20385: PPUSH
20386: LD_VAR 0 4
20390: PPUSH
20391: LD_INT 0
20393: PPUSH
20394: CALL_OW 1
20398: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20399: LD_ADDR_EXP 93
20403: PUSH
20404: LD_EXP 93
20408: PPUSH
20409: LD_VAR 0 4
20413: PPUSH
20414: LD_INT 0
20416: PPUSH
20417: CALL_OW 1
20421: ST_TO_ADDR
// result := base ;
20422: LD_ADDR_VAR 0 3
20426: PUSH
20427: LD_VAR 0 4
20431: ST_TO_ADDR
// end ;
20432: LD_VAR 0 3
20436: RET
// export function MC_Start ( ) ; var i ; begin
20437: LD_INT 0
20439: PPUSH
20440: PPUSH
// for i = 1 to mc_bases do
20441: LD_ADDR_VAR 0 2
20445: PUSH
20446: DOUBLE
20447: LD_INT 1
20449: DEC
20450: ST_TO_ADDR
20451: LD_EXP 50
20455: PUSH
20456: FOR_TO
20457: IFFALSE 21557
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20459: LD_ADDR_EXP 50
20463: PUSH
20464: LD_EXP 50
20468: PPUSH
20469: LD_VAR 0 2
20473: PPUSH
20474: LD_EXP 50
20478: PUSH
20479: LD_VAR 0 2
20483: ARRAY
20484: PUSH
20485: LD_INT 0
20487: DIFF
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20494: LD_ADDR_EXP 51
20498: PUSH
20499: LD_EXP 51
20503: PPUSH
20504: LD_VAR 0 2
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20516: LD_ADDR_EXP 52
20520: PUSH
20521: LD_EXP 52
20525: PPUSH
20526: LD_VAR 0 2
20530: PPUSH
20531: EMPTY
20532: PPUSH
20533: CALL_OW 1
20537: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20538: LD_ADDR_EXP 53
20542: PUSH
20543: LD_EXP 53
20547: PPUSH
20548: LD_VAR 0 2
20552: PPUSH
20553: EMPTY
20554: PPUSH
20555: CALL_OW 1
20559: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20560: LD_ADDR_EXP 54
20564: PUSH
20565: LD_EXP 54
20569: PPUSH
20570: LD_VAR 0 2
20574: PPUSH
20575: EMPTY
20576: PUSH
20577: EMPTY
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: PPUSH
20583: CALL_OW 1
20587: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20588: LD_ADDR_EXP 55
20592: PUSH
20593: LD_EXP 55
20597: PPUSH
20598: LD_VAR 0 2
20602: PPUSH
20603: EMPTY
20604: PPUSH
20605: CALL_OW 1
20609: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20610: LD_ADDR_EXP 82
20614: PUSH
20615: LD_EXP 82
20619: PPUSH
20620: LD_VAR 0 2
20624: PPUSH
20625: EMPTY
20626: PPUSH
20627: CALL_OW 1
20631: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20632: LD_ADDR_EXP 56
20636: PUSH
20637: LD_EXP 56
20641: PPUSH
20642: LD_VAR 0 2
20646: PPUSH
20647: EMPTY
20648: PPUSH
20649: CALL_OW 1
20653: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20654: LD_ADDR_EXP 57
20658: PUSH
20659: LD_EXP 57
20663: PPUSH
20664: LD_VAR 0 2
20668: PPUSH
20669: EMPTY
20670: PPUSH
20671: CALL_OW 1
20675: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20676: LD_ADDR_EXP 58
20680: PUSH
20681: LD_EXP 58
20685: PPUSH
20686: LD_VAR 0 2
20690: PPUSH
20691: LD_EXP 50
20695: PUSH
20696: LD_VAR 0 2
20700: ARRAY
20701: PPUSH
20702: LD_INT 2
20704: PUSH
20705: LD_INT 30
20707: PUSH
20708: LD_INT 32
20710: PUSH
20711: EMPTY
20712: LIST
20713: LIST
20714: PUSH
20715: LD_INT 30
20717: PUSH
20718: LD_INT 33
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL_OW 72
20734: PPUSH
20735: CALL_OW 1
20739: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20740: LD_ADDR_EXP 59
20744: PUSH
20745: LD_EXP 59
20749: PPUSH
20750: LD_VAR 0 2
20754: PPUSH
20755: LD_EXP 50
20759: PUSH
20760: LD_VAR 0 2
20764: ARRAY
20765: PPUSH
20766: LD_INT 2
20768: PUSH
20769: LD_INT 30
20771: PUSH
20772: LD_INT 32
20774: PUSH
20775: EMPTY
20776: LIST
20777: LIST
20778: PUSH
20779: LD_INT 30
20781: PUSH
20782: LD_INT 31
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PUSH
20794: LD_INT 58
20796: PUSH
20797: EMPTY
20798: LIST
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: PPUSH
20804: CALL_OW 72
20808: PPUSH
20809: CALL_OW 1
20813: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20814: LD_ADDR_EXP 60
20818: PUSH
20819: LD_EXP 60
20823: PPUSH
20824: LD_VAR 0 2
20828: PPUSH
20829: EMPTY
20830: PPUSH
20831: CALL_OW 1
20835: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20836: LD_ADDR_EXP 64
20840: PUSH
20841: LD_EXP 64
20845: PPUSH
20846: LD_VAR 0 2
20850: PPUSH
20851: EMPTY
20852: PPUSH
20853: CALL_OW 1
20857: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20858: LD_ADDR_EXP 63
20862: PUSH
20863: LD_EXP 63
20867: PPUSH
20868: LD_VAR 0 2
20872: PPUSH
20873: EMPTY
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20880: LD_ADDR_EXP 65
20884: PUSH
20885: LD_EXP 65
20889: PPUSH
20890: LD_VAR 0 2
20894: PPUSH
20895: EMPTY
20896: PPUSH
20897: CALL_OW 1
20901: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20902: LD_ADDR_EXP 66
20906: PUSH
20907: LD_EXP 66
20911: PPUSH
20912: LD_VAR 0 2
20916: PPUSH
20917: EMPTY
20918: PPUSH
20919: CALL_OW 1
20923: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20924: LD_ADDR_EXP 67
20928: PUSH
20929: LD_EXP 67
20933: PPUSH
20934: LD_VAR 0 2
20938: PPUSH
20939: EMPTY
20940: PPUSH
20941: CALL_OW 1
20945: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20946: LD_ADDR_EXP 68
20950: PUSH
20951: LD_EXP 68
20955: PPUSH
20956: LD_VAR 0 2
20960: PPUSH
20961: EMPTY
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20968: LD_ADDR_EXP 69
20972: PUSH
20973: LD_EXP 69
20977: PPUSH
20978: LD_VAR 0 2
20982: PPUSH
20983: EMPTY
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20990: LD_ADDR_EXP 70
20994: PUSH
20995: LD_EXP 70
20999: PPUSH
21000: LD_VAR 0 2
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21012: LD_ADDR_EXP 71
21016: PUSH
21017: LD_EXP 71
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21034: LD_ADDR_EXP 72
21038: PUSH
21039: LD_EXP 72
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21056: LD_ADDR_EXP 61
21060: PUSH
21061: LD_EXP 61
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: LD_INT 0
21073: PPUSH
21074: CALL_OW 1
21078: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21079: LD_ADDR_EXP 74
21083: PUSH
21084: LD_EXP 74
21088: PPUSH
21089: LD_VAR 0 2
21093: PPUSH
21094: LD_INT 0
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21102: LD_ADDR_EXP 62
21106: PUSH
21107: LD_EXP 62
21111: PPUSH
21112: LD_VAR 0 2
21116: PPUSH
21117: EMPTY
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21124: LD_ADDR_EXP 73
21128: PUSH
21129: LD_EXP 73
21133: PPUSH
21134: LD_VAR 0 2
21138: PPUSH
21139: LD_INT 0
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21147: LD_ADDR_EXP 75
21151: PUSH
21152: LD_EXP 75
21156: PPUSH
21157: LD_VAR 0 2
21161: PPUSH
21162: EMPTY
21163: PPUSH
21164: CALL_OW 1
21168: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21169: LD_ADDR_EXP 78
21173: PUSH
21174: LD_EXP 78
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: LD_INT 0
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21192: LD_ADDR_EXP 79
21196: PUSH
21197: LD_EXP 79
21201: PPUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: EMPTY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21214: LD_ADDR_EXP 80
21218: PUSH
21219: LD_EXP 80
21223: PPUSH
21224: LD_VAR 0 2
21228: PPUSH
21229: EMPTY
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21236: LD_ADDR_EXP 81
21240: PUSH
21241: LD_EXP 81
21245: PPUSH
21246: LD_VAR 0 2
21250: PPUSH
21251: EMPTY
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21258: LD_ADDR_EXP 83
21262: PUSH
21263: LD_EXP 83
21267: PPUSH
21268: LD_VAR 0 2
21272: PPUSH
21273: LD_EXP 50
21277: PUSH
21278: LD_VAR 0 2
21282: ARRAY
21283: PPUSH
21284: LD_INT 2
21286: PUSH
21287: LD_INT 30
21289: PUSH
21290: LD_INT 6
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: PUSH
21297: LD_INT 30
21299: PUSH
21300: LD_INT 7
21302: PUSH
21303: EMPTY
21304: LIST
21305: LIST
21306: PUSH
21307: LD_INT 30
21309: PUSH
21310: LD_INT 8
21312: PUSH
21313: EMPTY
21314: LIST
21315: LIST
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: LIST
21321: LIST
21322: PPUSH
21323: CALL_OW 72
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21333: LD_ADDR_EXP 84
21337: PUSH
21338: LD_EXP 84
21342: PPUSH
21343: LD_VAR 0 2
21347: PPUSH
21348: EMPTY
21349: PPUSH
21350: CALL_OW 1
21354: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21355: LD_ADDR_EXP 85
21359: PUSH
21360: LD_EXP 85
21364: PPUSH
21365: LD_VAR 0 2
21369: PPUSH
21370: EMPTY
21371: PPUSH
21372: CALL_OW 1
21376: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21377: LD_ADDR_EXP 86
21381: PUSH
21382: LD_EXP 86
21386: PPUSH
21387: LD_VAR 0 2
21391: PPUSH
21392: EMPTY
21393: PPUSH
21394: CALL_OW 1
21398: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21399: LD_ADDR_EXP 87
21403: PUSH
21404: LD_EXP 87
21408: PPUSH
21409: LD_VAR 0 2
21413: PPUSH
21414: EMPTY
21415: PPUSH
21416: CALL_OW 1
21420: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21421: LD_ADDR_EXP 88
21425: PUSH
21426: LD_EXP 88
21430: PPUSH
21431: LD_VAR 0 2
21435: PPUSH
21436: EMPTY
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21443: LD_ADDR_EXP 89
21447: PUSH
21448: LD_EXP 89
21452: PPUSH
21453: LD_VAR 0 2
21457: PPUSH
21458: EMPTY
21459: PPUSH
21460: CALL_OW 1
21464: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21465: LD_ADDR_EXP 90
21469: PUSH
21470: LD_EXP 90
21474: PPUSH
21475: LD_VAR 0 2
21479: PPUSH
21480: EMPTY
21481: PPUSH
21482: CALL_OW 1
21486: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21487: LD_ADDR_EXP 91
21491: PUSH
21492: LD_EXP 91
21496: PPUSH
21497: LD_VAR 0 2
21501: PPUSH
21502: EMPTY
21503: PPUSH
21504: CALL_OW 1
21508: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21509: LD_ADDR_EXP 92
21513: PUSH
21514: LD_EXP 92
21518: PPUSH
21519: LD_VAR 0 2
21523: PPUSH
21524: LD_INT 0
21526: PPUSH
21527: CALL_OW 1
21531: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21532: LD_ADDR_EXP 93
21536: PUSH
21537: LD_EXP 93
21541: PPUSH
21542: LD_VAR 0 2
21546: PPUSH
21547: LD_INT 0
21549: PPUSH
21550: CALL_OW 1
21554: ST_TO_ADDR
// end ;
21555: GO 20456
21557: POP
21558: POP
// MC_InitSides ( ) ;
21559: CALL 21845 0 0
// MC_InitResearch ( ) ;
21563: CALL 21584 0 0
// CustomInitMacro ( ) ;
21567: CALL 304 0 0
// skirmish := true ;
21571: LD_ADDR_EXP 48
21575: PUSH
21576: LD_INT 1
21578: ST_TO_ADDR
// end ;
21579: LD_VAR 0 1
21583: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21584: LD_INT 0
21586: PPUSH
21587: PPUSH
21588: PPUSH
21589: PPUSH
21590: PPUSH
21591: PPUSH
// if not mc_bases then
21592: LD_EXP 50
21596: NOT
21597: IFFALSE 21601
// exit ;
21599: GO 21840
// for i = 1 to 8 do
21601: LD_ADDR_VAR 0 2
21605: PUSH
21606: DOUBLE
21607: LD_INT 1
21609: DEC
21610: ST_TO_ADDR
21611: LD_INT 8
21613: PUSH
21614: FOR_TO
21615: IFFALSE 21641
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21617: LD_ADDR_EXP 77
21621: PUSH
21622: LD_EXP 77
21626: PPUSH
21627: LD_VAR 0 2
21631: PPUSH
21632: EMPTY
21633: PPUSH
21634: CALL_OW 1
21638: ST_TO_ADDR
21639: GO 21614
21641: POP
21642: POP
// tmp := [ ] ;
21643: LD_ADDR_VAR 0 5
21647: PUSH
21648: EMPTY
21649: ST_TO_ADDR
// for i = 1 to mc_sides do
21650: LD_ADDR_VAR 0 2
21654: PUSH
21655: DOUBLE
21656: LD_INT 1
21658: DEC
21659: ST_TO_ADDR
21660: LD_EXP 76
21664: PUSH
21665: FOR_TO
21666: IFFALSE 21724
// if not mc_sides [ i ] in tmp then
21668: LD_EXP 76
21672: PUSH
21673: LD_VAR 0 2
21677: ARRAY
21678: PUSH
21679: LD_VAR 0 5
21683: IN
21684: NOT
21685: IFFALSE 21722
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21687: LD_ADDR_VAR 0 5
21691: PUSH
21692: LD_VAR 0 5
21696: PPUSH
21697: LD_VAR 0 5
21701: PUSH
21702: LD_INT 1
21704: PLUS
21705: PPUSH
21706: LD_EXP 76
21710: PUSH
21711: LD_VAR 0 2
21715: ARRAY
21716: PPUSH
21717: CALL_OW 2
21721: ST_TO_ADDR
21722: GO 21665
21724: POP
21725: POP
// if not tmp then
21726: LD_VAR 0 5
21730: NOT
21731: IFFALSE 21735
// exit ;
21733: GO 21840
// for j in tmp do
21735: LD_ADDR_VAR 0 3
21739: PUSH
21740: LD_VAR 0 5
21744: PUSH
21745: FOR_IN
21746: IFFALSE 21838
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21748: LD_ADDR_VAR 0 6
21752: PUSH
21753: LD_INT 22
21755: PUSH
21756: LD_VAR 0 3
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PPUSH
21765: CALL_OW 69
21769: ST_TO_ADDR
// if not un then
21770: LD_VAR 0 6
21774: NOT
21775: IFFALSE 21779
// continue ;
21777: GO 21745
// nation := GetNation ( un [ 1 ] ) ;
21779: LD_ADDR_VAR 0 4
21783: PUSH
21784: LD_VAR 0 6
21788: PUSH
21789: LD_INT 1
21791: ARRAY
21792: PPUSH
21793: CALL_OW 248
21797: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21798: LD_ADDR_EXP 77
21802: PUSH
21803: LD_EXP 77
21807: PPUSH
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_VAR 0 3
21817: PPUSH
21818: LD_VAR 0 4
21822: PPUSH
21823: LD_INT 1
21825: PPUSH
21826: CALL 49112 0 3
21830: PPUSH
21831: CALL_OW 1
21835: ST_TO_ADDR
// end ;
21836: GO 21745
21838: POP
21839: POP
// end ;
21840: LD_VAR 0 1
21844: RET
// export function MC_InitSides ( ) ; var i ; begin
21845: LD_INT 0
21847: PPUSH
21848: PPUSH
// if not mc_bases then
21849: LD_EXP 50
21853: NOT
21854: IFFALSE 21858
// exit ;
21856: GO 21932
// for i = 1 to mc_bases do
21858: LD_ADDR_VAR 0 2
21862: PUSH
21863: DOUBLE
21864: LD_INT 1
21866: DEC
21867: ST_TO_ADDR
21868: LD_EXP 50
21872: PUSH
21873: FOR_TO
21874: IFFALSE 21930
// if mc_bases [ i ] then
21876: LD_EXP 50
21880: PUSH
21881: LD_VAR 0 2
21885: ARRAY
21886: IFFALSE 21928
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21888: LD_ADDR_EXP 76
21892: PUSH
21893: LD_EXP 76
21897: PPUSH
21898: LD_VAR 0 2
21902: PPUSH
21903: LD_EXP 50
21907: PUSH
21908: LD_VAR 0 2
21912: ARRAY
21913: PUSH
21914: LD_INT 1
21916: ARRAY
21917: PPUSH
21918: CALL_OW 255
21922: PPUSH
21923: CALL_OW 1
21927: ST_TO_ADDR
21928: GO 21873
21930: POP
21931: POP
// end ;
21932: LD_VAR 0 1
21936: RET
// every 0 0$03 trigger skirmish do
21937: LD_EXP 48
21941: IFFALSE 22095
21943: GO 21945
21945: DISABLE
// begin enable ;
21946: ENABLE
// MC_CheckBuildings ( ) ;
21947: CALL 26607 0 0
// MC_CheckPeopleLife ( ) ;
21951: CALL 26768 0 0
// RaiseSailEvent ( 100 ) ;
21955: LD_INT 100
21957: PPUSH
21958: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21962: LD_INT 103
21964: PPUSH
21965: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21969: LD_INT 104
21971: PPUSH
21972: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21976: LD_INT 105
21978: PPUSH
21979: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21983: LD_INT 106
21985: PPUSH
21986: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21990: LD_INT 107
21992: PPUSH
21993: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21997: LD_INT 108
21999: PPUSH
22000: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22004: LD_INT 109
22006: PPUSH
22007: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22011: LD_INT 110
22013: PPUSH
22014: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22018: LD_INT 111
22020: PPUSH
22021: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22025: LD_INT 112
22027: PPUSH
22028: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22032: LD_INT 113
22034: PPUSH
22035: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22039: LD_INT 120
22041: PPUSH
22042: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22046: LD_INT 121
22048: PPUSH
22049: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22053: LD_INT 122
22055: PPUSH
22056: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22060: LD_INT 123
22062: PPUSH
22063: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22067: LD_INT 124
22069: PPUSH
22070: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22074: LD_INT 125
22076: PPUSH
22077: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22081: LD_INT 126
22083: PPUSH
22084: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22088: LD_INT 200
22090: PPUSH
22091: CALL_OW 427
// end ;
22095: END
// on SailEvent ( event ) do begin if event < 100 then
22096: LD_VAR 0 1
22100: PUSH
22101: LD_INT 100
22103: LESS
22104: IFFALSE 22115
// CustomEvent ( event ) ;
22106: LD_VAR 0 1
22110: PPUSH
22111: CALL 17258 0 1
// if event = 100 then
22115: LD_VAR 0 1
22119: PUSH
22120: LD_INT 100
22122: EQUAL
22123: IFFALSE 22129
// MC_ClassManager ( ) ;
22125: CALL 22521 0 0
// if event = 101 then
22129: LD_VAR 0 1
22133: PUSH
22134: LD_INT 101
22136: EQUAL
22137: IFFALSE 22143
// MC_RepairBuildings ( ) ;
22139: CALL 27353 0 0
// if event = 102 then
22143: LD_VAR 0 1
22147: PUSH
22148: LD_INT 102
22150: EQUAL
22151: IFFALSE 22157
// MC_Heal ( ) ;
22153: CALL 28288 0 0
// if event = 103 then
22157: LD_VAR 0 1
22161: PUSH
22162: LD_INT 103
22164: EQUAL
22165: IFFALSE 22171
// MC_Build ( ) ;
22167: CALL 28710 0 0
// if event = 104 then
22171: LD_VAR 0 1
22175: PUSH
22176: LD_INT 104
22178: EQUAL
22179: IFFALSE 22185
// MC_TurretWeapon ( ) ;
22181: CALL 30344 0 0
// if event = 105 then
22185: LD_VAR 0 1
22189: PUSH
22190: LD_INT 105
22192: EQUAL
22193: IFFALSE 22199
// MC_BuildUpgrade ( ) ;
22195: CALL 29895 0 0
// if event = 106 then
22199: LD_VAR 0 1
22203: PUSH
22204: LD_INT 106
22206: EQUAL
22207: IFFALSE 22213
// MC_PlantMines ( ) ;
22209: CALL 30774 0 0
// if event = 107 then
22213: LD_VAR 0 1
22217: PUSH
22218: LD_INT 107
22220: EQUAL
22221: IFFALSE 22227
// MC_CollectCrates ( ) ;
22223: CALL 31572 0 0
// if event = 108 then
22227: LD_VAR 0 1
22231: PUSH
22232: LD_INT 108
22234: EQUAL
22235: IFFALSE 22241
// MC_LinkRemoteControl ( ) ;
22237: CALL 33422 0 0
// if event = 109 then
22241: LD_VAR 0 1
22245: PUSH
22246: LD_INT 109
22248: EQUAL
22249: IFFALSE 22255
// MC_ProduceVehicle ( ) ;
22251: CALL 33603 0 0
// if event = 110 then
22255: LD_VAR 0 1
22259: PUSH
22260: LD_INT 110
22262: EQUAL
22263: IFFALSE 22269
// MC_SendAttack ( ) ;
22265: CALL 34069 0 0
// if event = 111 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 111
22276: EQUAL
22277: IFFALSE 22283
// MC_Defend ( ) ;
22279: CALL 34177 0 0
// if event = 112 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 112
22290: EQUAL
22291: IFFALSE 22297
// MC_Research ( ) ;
22293: CALL 35057 0 0
// if event = 113 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 113
22304: EQUAL
22305: IFFALSE 22311
// MC_MinesTrigger ( ) ;
22307: CALL 36171 0 0
// if event = 120 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 120
22318: EQUAL
22319: IFFALSE 22325
// MC_RepairVehicle ( ) ;
22321: CALL 36270 0 0
// if event = 121 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 121
22332: EQUAL
22333: IFFALSE 22339
// MC_TameApe ( ) ;
22335: CALL 37039 0 0
// if event = 122 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 122
22346: EQUAL
22347: IFFALSE 22353
// MC_ChangeApeClass ( ) ;
22349: CALL 37868 0 0
// if event = 123 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 123
22360: EQUAL
22361: IFFALSE 22367
// MC_Bazooka ( ) ;
22363: CALL 38518 0 0
// if event = 124 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 124
22374: EQUAL
22375: IFFALSE 22381
// MC_TeleportExit ( ) ;
22377: CALL 38716 0 0
// if event = 125 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 125
22388: EQUAL
22389: IFFALSE 22395
// MC_Deposits ( ) ;
22391: CALL 39363 0 0
// if event = 126 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 126
22402: EQUAL
22403: IFFALSE 22409
// MC_RemoteDriver ( ) ;
22405: CALL 39988 0 0
// if event = 200 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 200
22416: EQUAL
22417: IFFALSE 22423
// MC_Idle ( ) ;
22419: CALL 41895 0 0
// end ;
22423: PPOPN 1
22425: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22426: LD_INT 0
22428: PPUSH
22429: PPUSH
// if not mc_bases [ base ] or not tag then
22430: LD_EXP 50
22434: PUSH
22435: LD_VAR 0 1
22439: ARRAY
22440: NOT
22441: PUSH
22442: LD_VAR 0 2
22446: NOT
22447: OR
22448: IFFALSE 22452
// exit ;
22450: GO 22516
// for i in mc_bases [ base ] union mc_ape [ base ] do
22452: LD_ADDR_VAR 0 4
22456: PUSH
22457: LD_EXP 50
22461: PUSH
22462: LD_VAR 0 1
22466: ARRAY
22467: PUSH
22468: LD_EXP 79
22472: PUSH
22473: LD_VAR 0 1
22477: ARRAY
22478: UNION
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22514
// if GetTag ( i ) = tag then
22483: LD_VAR 0 4
22487: PPUSH
22488: CALL_OW 110
22492: PUSH
22493: LD_VAR 0 2
22497: EQUAL
22498: IFFALSE 22512
// SetTag ( i , 0 ) ;
22500: LD_VAR 0 4
22504: PPUSH
22505: LD_INT 0
22507: PPUSH
22508: CALL_OW 109
22512: GO 22480
22514: POP
22515: POP
// end ;
22516: LD_VAR 0 3
22520: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22521: LD_INT 0
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
22528: PPUSH
22529: PPUSH
22530: PPUSH
// if not mc_bases then
22531: LD_EXP 50
22535: NOT
22536: IFFALSE 22540
// exit ;
22538: GO 22989
// for i = 1 to mc_bases do
22540: LD_ADDR_VAR 0 2
22544: PUSH
22545: DOUBLE
22546: LD_INT 1
22548: DEC
22549: ST_TO_ADDR
22550: LD_EXP 50
22554: PUSH
22555: FOR_TO
22556: IFFALSE 22987
// begin tmp := MC_ClassCheckReq ( i ) ;
22558: LD_ADDR_VAR 0 4
22562: PUSH
22563: LD_VAR 0 2
22567: PPUSH
22568: CALL 22994 0 1
22572: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22573: LD_ADDR_EXP 91
22577: PUSH
22578: LD_EXP 91
22582: PPUSH
22583: LD_VAR 0 2
22587: PPUSH
22588: LD_VAR 0 4
22592: PPUSH
22593: CALL_OW 1
22597: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22598: LD_ADDR_VAR 0 6
22602: PUSH
22603: LD_EXP 50
22607: PUSH
22608: LD_VAR 0 2
22612: ARRAY
22613: PPUSH
22614: LD_INT 2
22616: PUSH
22617: LD_INT 30
22619: PUSH
22620: LD_INT 4
22622: PUSH
22623: EMPTY
22624: LIST
22625: LIST
22626: PUSH
22627: LD_INT 30
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: PUSH
22637: EMPTY
22638: LIST
22639: LIST
22640: LIST
22641: PPUSH
22642: CALL_OW 72
22646: PUSH
22647: LD_EXP 50
22651: PUSH
22652: LD_VAR 0 2
22656: ARRAY
22657: PPUSH
22658: LD_INT 2
22660: PUSH
22661: LD_INT 30
22663: PUSH
22664: LD_INT 0
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: PUSH
22671: LD_INT 30
22673: PUSH
22674: LD_INT 1
22676: PUSH
22677: EMPTY
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: LIST
22685: PPUSH
22686: CALL_OW 72
22690: PUSH
22691: LD_EXP 50
22695: PUSH
22696: LD_VAR 0 2
22700: ARRAY
22701: PPUSH
22702: LD_INT 30
22704: PUSH
22705: LD_INT 3
22707: PUSH
22708: EMPTY
22709: LIST
22710: LIST
22711: PPUSH
22712: CALL_OW 72
22716: PUSH
22717: LD_EXP 50
22721: PUSH
22722: LD_VAR 0 2
22726: ARRAY
22727: PPUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 30
22733: PUSH
22734: LD_INT 6
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 7
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 30
22753: PUSH
22754: LD_INT 8
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: LIST
22765: LIST
22766: PPUSH
22767: CALL_OW 72
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: ST_TO_ADDR
// for j := 1 to 4 do
22778: LD_ADDR_VAR 0 3
22782: PUSH
22783: DOUBLE
22784: LD_INT 1
22786: DEC
22787: ST_TO_ADDR
22788: LD_INT 4
22790: PUSH
22791: FOR_TO
22792: IFFALSE 22983
// begin if not tmp [ j ] then
22794: LD_VAR 0 4
22798: PUSH
22799: LD_VAR 0 3
22803: ARRAY
22804: NOT
22805: IFFALSE 22809
// continue ;
22807: GO 22791
// for p in tmp [ j ] do
22809: LD_ADDR_VAR 0 5
22813: PUSH
22814: LD_VAR 0 4
22818: PUSH
22819: LD_VAR 0 3
22823: ARRAY
22824: PUSH
22825: FOR_IN
22826: IFFALSE 22979
// begin if not b [ j ] then
22828: LD_VAR 0 6
22832: PUSH
22833: LD_VAR 0 3
22837: ARRAY
22838: NOT
22839: IFFALSE 22843
// break ;
22841: GO 22979
// e := 0 ;
22843: LD_ADDR_VAR 0 7
22847: PUSH
22848: LD_INT 0
22850: ST_TO_ADDR
// for k in b [ j ] do
22851: LD_ADDR_VAR 0 8
22855: PUSH
22856: LD_VAR 0 6
22860: PUSH
22861: LD_VAR 0 3
22865: ARRAY
22866: PUSH
22867: FOR_IN
22868: IFFALSE 22895
// if IsNotFull ( k ) then
22870: LD_VAR 0 8
22874: PPUSH
22875: CALL 51233 0 1
22879: IFFALSE 22893
// begin e := k ;
22881: LD_ADDR_VAR 0 7
22885: PUSH
22886: LD_VAR 0 8
22890: ST_TO_ADDR
// break ;
22891: GO 22895
// end ;
22893: GO 22867
22895: POP
22896: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22897: LD_VAR 0 7
22901: PUSH
22902: LD_VAR 0 5
22906: PPUSH
22907: LD_VAR 0 7
22911: PPUSH
22912: CALL 85392 0 2
22916: NOT
22917: AND
22918: IFFALSE 22977
// begin if IsInUnit ( p ) then
22920: LD_VAR 0 5
22924: PPUSH
22925: CALL_OW 310
22929: IFFALSE 22940
// ComExitBuilding ( p ) ;
22931: LD_VAR 0 5
22935: PPUSH
22936: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22940: LD_VAR 0 5
22944: PPUSH
22945: LD_VAR 0 7
22949: PPUSH
22950: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22954: LD_VAR 0 5
22958: PPUSH
22959: LD_VAR 0 3
22963: PPUSH
22964: CALL_OW 183
// AddComExitBuilding ( p ) ;
22968: LD_VAR 0 5
22972: PPUSH
22973: CALL_OW 182
// end ; end ;
22977: GO 22825
22979: POP
22980: POP
// end ;
22981: GO 22791
22983: POP
22984: POP
// end ;
22985: GO 22555
22987: POP
22988: POP
// end ;
22989: LD_VAR 0 1
22993: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22994: LD_INT 0
22996: PPUSH
22997: PPUSH
22998: PPUSH
22999: PPUSH
23000: PPUSH
23001: PPUSH
23002: PPUSH
23003: PPUSH
23004: PPUSH
23005: PPUSH
23006: PPUSH
23007: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23008: LD_ADDR_VAR 0 2
23012: PUSH
23013: LD_INT 0
23015: PUSH
23016: LD_INT 0
23018: PUSH
23019: LD_INT 0
23021: PUSH
23022: LD_INT 0
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: LIST
23029: LIST
23030: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23031: LD_VAR 0 1
23035: NOT
23036: PUSH
23037: LD_EXP 50
23041: PUSH
23042: LD_VAR 0 1
23046: ARRAY
23047: NOT
23048: OR
23049: PUSH
23050: LD_EXP 50
23054: PUSH
23055: LD_VAR 0 1
23059: ARRAY
23060: PPUSH
23061: LD_INT 2
23063: PUSH
23064: LD_INT 30
23066: PUSH
23067: LD_INT 0
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: PUSH
23074: LD_INT 30
23076: PUSH
23077: LD_INT 1
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: PUSH
23084: EMPTY
23085: LIST
23086: LIST
23087: LIST
23088: PPUSH
23089: CALL_OW 72
23093: NOT
23094: OR
23095: IFFALSE 23099
// exit ;
23097: GO 26602
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23099: LD_ADDR_VAR 0 4
23103: PUSH
23104: LD_EXP 50
23108: PUSH
23109: LD_VAR 0 1
23113: ARRAY
23114: PPUSH
23115: LD_INT 2
23117: PUSH
23118: LD_INT 25
23120: PUSH
23121: LD_INT 1
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: PUSH
23128: LD_INT 25
23130: PUSH
23131: LD_INT 2
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: PUSH
23138: LD_INT 25
23140: PUSH
23141: LD_INT 3
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PUSH
23148: LD_INT 25
23150: PUSH
23151: LD_INT 4
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: PUSH
23158: LD_INT 25
23160: PUSH
23161: LD_INT 5
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: LD_INT 25
23170: PUSH
23171: LD_INT 8
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: LD_INT 25
23180: PUSH
23181: LD_INT 9
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: LIST
23194: LIST
23195: LIST
23196: LIST
23197: PPUSH
23198: CALL_OW 72
23202: ST_TO_ADDR
// if not tmp then
23203: LD_VAR 0 4
23207: NOT
23208: IFFALSE 23212
// exit ;
23210: GO 26602
// for i in tmp do
23212: LD_ADDR_VAR 0 3
23216: PUSH
23217: LD_VAR 0 4
23221: PUSH
23222: FOR_IN
23223: IFFALSE 23254
// if GetTag ( i ) then
23225: LD_VAR 0 3
23229: PPUSH
23230: CALL_OW 110
23234: IFFALSE 23252
// tmp := tmp diff i ;
23236: LD_ADDR_VAR 0 4
23240: PUSH
23241: LD_VAR 0 4
23245: PUSH
23246: LD_VAR 0 3
23250: DIFF
23251: ST_TO_ADDR
23252: GO 23222
23254: POP
23255: POP
// if not tmp then
23256: LD_VAR 0 4
23260: NOT
23261: IFFALSE 23265
// exit ;
23263: GO 26602
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23265: LD_ADDR_VAR 0 5
23269: PUSH
23270: LD_EXP 50
23274: PUSH
23275: LD_VAR 0 1
23279: ARRAY
23280: PPUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 25
23286: PUSH
23287: LD_INT 1
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 25
23296: PUSH
23297: LD_INT 5
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: LD_INT 25
23306: PUSH
23307: LD_INT 8
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: PUSH
23314: LD_INT 25
23316: PUSH
23317: LD_INT 9
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: PPUSH
23331: CALL_OW 72
23335: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23336: LD_ADDR_VAR 0 6
23340: PUSH
23341: LD_EXP 50
23345: PUSH
23346: LD_VAR 0 1
23350: ARRAY
23351: PPUSH
23352: LD_INT 25
23354: PUSH
23355: LD_INT 2
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: PPUSH
23362: CALL_OW 72
23366: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23367: LD_ADDR_VAR 0 7
23371: PUSH
23372: LD_EXP 50
23376: PUSH
23377: LD_VAR 0 1
23381: ARRAY
23382: PPUSH
23383: LD_INT 25
23385: PUSH
23386: LD_INT 3
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PPUSH
23393: CALL_OW 72
23397: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23398: LD_ADDR_VAR 0 8
23402: PUSH
23403: LD_EXP 50
23407: PUSH
23408: LD_VAR 0 1
23412: ARRAY
23413: PPUSH
23414: LD_INT 25
23416: PUSH
23417: LD_INT 4
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PUSH
23424: LD_INT 24
23426: PUSH
23427: LD_INT 251
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: PPUSH
23438: CALL_OW 72
23442: ST_TO_ADDR
// if mc_is_defending [ base ] then
23443: LD_EXP 93
23447: PUSH
23448: LD_VAR 0 1
23452: ARRAY
23453: IFFALSE 23914
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23455: LD_ADDR_EXP 92
23459: PUSH
23460: LD_EXP 92
23464: PPUSH
23465: LD_VAR 0 1
23469: PPUSH
23470: LD_INT 4
23472: PPUSH
23473: CALL_OW 1
23477: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23478: LD_ADDR_VAR 0 12
23482: PUSH
23483: LD_EXP 50
23487: PUSH
23488: LD_VAR 0 1
23492: ARRAY
23493: PPUSH
23494: LD_INT 2
23496: PUSH
23497: LD_INT 30
23499: PUSH
23500: LD_INT 4
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: PUSH
23507: LD_INT 30
23509: PUSH
23510: LD_INT 5
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: LIST
23521: PPUSH
23522: CALL_OW 72
23526: ST_TO_ADDR
// if not b then
23527: LD_VAR 0 12
23531: NOT
23532: IFFALSE 23536
// exit ;
23534: GO 26602
// p := [ ] ;
23536: LD_ADDR_VAR 0 11
23540: PUSH
23541: EMPTY
23542: ST_TO_ADDR
// if sci >= 2 then
23543: LD_VAR 0 8
23547: PUSH
23548: LD_INT 2
23550: GREATEREQUAL
23551: IFFALSE 23582
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23553: LD_ADDR_VAR 0 8
23557: PUSH
23558: LD_VAR 0 8
23562: PUSH
23563: LD_INT 1
23565: ARRAY
23566: PUSH
23567: LD_VAR 0 8
23571: PUSH
23572: LD_INT 2
23574: ARRAY
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: ST_TO_ADDR
23580: GO 23643
// if sci = 1 then
23582: LD_VAR 0 8
23586: PUSH
23587: LD_INT 1
23589: EQUAL
23590: IFFALSE 23611
// sci := [ sci [ 1 ] ] else
23592: LD_ADDR_VAR 0 8
23596: PUSH
23597: LD_VAR 0 8
23601: PUSH
23602: LD_INT 1
23604: ARRAY
23605: PUSH
23606: EMPTY
23607: LIST
23608: ST_TO_ADDR
23609: GO 23643
// if sci = 0 then
23611: LD_VAR 0 8
23615: PUSH
23616: LD_INT 0
23618: EQUAL
23619: IFFALSE 23643
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23621: LD_ADDR_VAR 0 11
23625: PUSH
23626: LD_VAR 0 4
23630: PPUSH
23631: LD_INT 4
23633: PPUSH
23634: CALL 85264 0 2
23638: PUSH
23639: LD_INT 1
23641: ARRAY
23642: ST_TO_ADDR
// if eng > 4 then
23643: LD_VAR 0 6
23647: PUSH
23648: LD_INT 4
23650: GREATER
23651: IFFALSE 23697
// for i = eng downto 4 do
23653: LD_ADDR_VAR 0 3
23657: PUSH
23658: DOUBLE
23659: LD_VAR 0 6
23663: INC
23664: ST_TO_ADDR
23665: LD_INT 4
23667: PUSH
23668: FOR_DOWNTO
23669: IFFALSE 23695
// eng := eng diff eng [ i ] ;
23671: LD_ADDR_VAR 0 6
23675: PUSH
23676: LD_VAR 0 6
23680: PUSH
23681: LD_VAR 0 6
23685: PUSH
23686: LD_VAR 0 3
23690: ARRAY
23691: DIFF
23692: ST_TO_ADDR
23693: GO 23668
23695: POP
23696: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23697: LD_ADDR_VAR 0 4
23701: PUSH
23702: LD_VAR 0 4
23706: PUSH
23707: LD_VAR 0 5
23711: PUSH
23712: LD_VAR 0 6
23716: UNION
23717: PUSH
23718: LD_VAR 0 7
23722: UNION
23723: PUSH
23724: LD_VAR 0 8
23728: UNION
23729: DIFF
23730: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23731: LD_ADDR_VAR 0 13
23735: PUSH
23736: LD_EXP 50
23740: PUSH
23741: LD_VAR 0 1
23745: ARRAY
23746: PPUSH
23747: LD_INT 2
23749: PUSH
23750: LD_INT 30
23752: PUSH
23753: LD_INT 32
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: LD_INT 30
23762: PUSH
23763: LD_INT 31
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: PPUSH
23775: CALL_OW 72
23779: PUSH
23780: LD_EXP 50
23784: PUSH
23785: LD_VAR 0 1
23789: ARRAY
23790: PPUSH
23791: LD_INT 2
23793: PUSH
23794: LD_INT 30
23796: PUSH
23797: LD_INT 4
23799: PUSH
23800: EMPTY
23801: LIST
23802: LIST
23803: PUSH
23804: LD_INT 30
23806: PUSH
23807: LD_INT 5
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: LIST
23818: PPUSH
23819: CALL_OW 72
23823: PUSH
23824: LD_INT 6
23826: MUL
23827: PLUS
23828: ST_TO_ADDR
// if bcount < tmp then
23829: LD_VAR 0 13
23833: PUSH
23834: LD_VAR 0 4
23838: LESS
23839: IFFALSE 23885
// for i = tmp downto bcount do
23841: LD_ADDR_VAR 0 3
23845: PUSH
23846: DOUBLE
23847: LD_VAR 0 4
23851: INC
23852: ST_TO_ADDR
23853: LD_VAR 0 13
23857: PUSH
23858: FOR_DOWNTO
23859: IFFALSE 23883
// tmp := Delete ( tmp , tmp ) ;
23861: LD_ADDR_VAR 0 4
23865: PUSH
23866: LD_VAR 0 4
23870: PPUSH
23871: LD_VAR 0 4
23875: PPUSH
23876: CALL_OW 3
23880: ST_TO_ADDR
23881: GO 23858
23883: POP
23884: POP
// result := [ tmp , 0 , 0 , p ] ;
23885: LD_ADDR_VAR 0 2
23889: PUSH
23890: LD_VAR 0 4
23894: PUSH
23895: LD_INT 0
23897: PUSH
23898: LD_INT 0
23900: PUSH
23901: LD_VAR 0 11
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: LIST
23910: LIST
23911: ST_TO_ADDR
// exit ;
23912: GO 26602
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23914: LD_EXP 50
23918: PUSH
23919: LD_VAR 0 1
23923: ARRAY
23924: PPUSH
23925: LD_INT 2
23927: PUSH
23928: LD_INT 30
23930: PUSH
23931: LD_INT 6
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: PUSH
23938: LD_INT 30
23940: PUSH
23941: LD_INT 7
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 30
23950: PUSH
23951: LD_INT 8
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: EMPTY
23959: LIST
23960: LIST
23961: LIST
23962: LIST
23963: PPUSH
23964: CALL_OW 72
23968: NOT
23969: PUSH
23970: LD_EXP 50
23974: PUSH
23975: LD_VAR 0 1
23979: ARRAY
23980: PPUSH
23981: LD_INT 30
23983: PUSH
23984: LD_INT 3
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 72
23995: NOT
23996: AND
23997: IFFALSE 24069
// begin if eng = tmp then
23999: LD_VAR 0 6
24003: PUSH
24004: LD_VAR 0 4
24008: EQUAL
24009: IFFALSE 24013
// exit ;
24011: GO 26602
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24013: LD_ADDR_EXP 92
24017: PUSH
24018: LD_EXP 92
24022: PPUSH
24023: LD_VAR 0 1
24027: PPUSH
24028: LD_INT 1
24030: PPUSH
24031: CALL_OW 1
24035: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24036: LD_ADDR_VAR 0 2
24040: PUSH
24041: LD_INT 0
24043: PUSH
24044: LD_VAR 0 4
24048: PUSH
24049: LD_VAR 0 6
24053: DIFF
24054: PUSH
24055: LD_INT 0
24057: PUSH
24058: LD_INT 0
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: LIST
24065: LIST
24066: ST_TO_ADDR
// exit ;
24067: GO 26602
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24069: LD_EXP 77
24073: PUSH
24074: LD_EXP 76
24078: PUSH
24079: LD_VAR 0 1
24083: ARRAY
24084: ARRAY
24085: PUSH
24086: LD_EXP 50
24090: PUSH
24091: LD_VAR 0 1
24095: ARRAY
24096: PPUSH
24097: LD_INT 2
24099: PUSH
24100: LD_INT 30
24102: PUSH
24103: LD_INT 6
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: PUSH
24110: LD_INT 30
24112: PUSH
24113: LD_INT 7
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: LD_INT 30
24122: PUSH
24123: LD_INT 8
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: PPUSH
24136: CALL_OW 72
24140: AND
24141: PUSH
24142: LD_EXP 50
24146: PUSH
24147: LD_VAR 0 1
24151: ARRAY
24152: PPUSH
24153: LD_INT 30
24155: PUSH
24156: LD_INT 3
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: PPUSH
24163: CALL_OW 72
24167: NOT
24168: AND
24169: IFFALSE 24383
// begin if sci >= 6 then
24171: LD_VAR 0 8
24175: PUSH
24176: LD_INT 6
24178: GREATEREQUAL
24179: IFFALSE 24183
// exit ;
24181: GO 26602
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24183: LD_ADDR_EXP 92
24187: PUSH
24188: LD_EXP 92
24192: PPUSH
24193: LD_VAR 0 1
24197: PPUSH
24198: LD_INT 2
24200: PPUSH
24201: CALL_OW 1
24205: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24206: LD_ADDR_VAR 0 9
24210: PUSH
24211: LD_VAR 0 4
24215: PUSH
24216: LD_VAR 0 8
24220: DIFF
24221: PPUSH
24222: LD_INT 4
24224: PPUSH
24225: CALL 85264 0 2
24229: ST_TO_ADDR
// p := [ ] ;
24230: LD_ADDR_VAR 0 11
24234: PUSH
24235: EMPTY
24236: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24237: LD_VAR 0 8
24241: PUSH
24242: LD_INT 6
24244: LESS
24245: PUSH
24246: LD_VAR 0 9
24250: PUSH
24251: LD_INT 6
24253: GREATER
24254: AND
24255: IFFALSE 24336
// begin for i = 1 to 6 - sci do
24257: LD_ADDR_VAR 0 3
24261: PUSH
24262: DOUBLE
24263: LD_INT 1
24265: DEC
24266: ST_TO_ADDR
24267: LD_INT 6
24269: PUSH
24270: LD_VAR 0 8
24274: MINUS
24275: PUSH
24276: FOR_TO
24277: IFFALSE 24332
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24279: LD_ADDR_VAR 0 11
24283: PUSH
24284: LD_VAR 0 11
24288: PPUSH
24289: LD_VAR 0 11
24293: PUSH
24294: LD_INT 1
24296: PLUS
24297: PPUSH
24298: LD_VAR 0 9
24302: PUSH
24303: LD_INT 1
24305: ARRAY
24306: PPUSH
24307: CALL_OW 2
24311: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24312: LD_ADDR_VAR 0 9
24316: PUSH
24317: LD_VAR 0 9
24321: PPUSH
24322: LD_INT 1
24324: PPUSH
24325: CALL_OW 3
24329: ST_TO_ADDR
// end ;
24330: GO 24276
24332: POP
24333: POP
// end else
24334: GO 24356
// if sort then
24336: LD_VAR 0 9
24340: IFFALSE 24356
// p := sort [ 1 ] ;
24342: LD_ADDR_VAR 0 11
24346: PUSH
24347: LD_VAR 0 9
24351: PUSH
24352: LD_INT 1
24354: ARRAY
24355: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24356: LD_ADDR_VAR 0 2
24360: PUSH
24361: LD_INT 0
24363: PUSH
24364: LD_INT 0
24366: PUSH
24367: LD_INT 0
24369: PUSH
24370: LD_VAR 0 11
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: LIST
24379: LIST
24380: ST_TO_ADDR
// exit ;
24381: GO 26602
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24383: LD_EXP 77
24387: PUSH
24388: LD_EXP 76
24392: PUSH
24393: LD_VAR 0 1
24397: ARRAY
24398: ARRAY
24399: PUSH
24400: LD_EXP 50
24404: PUSH
24405: LD_VAR 0 1
24409: ARRAY
24410: PPUSH
24411: LD_INT 2
24413: PUSH
24414: LD_INT 30
24416: PUSH
24417: LD_INT 6
24419: PUSH
24420: EMPTY
24421: LIST
24422: LIST
24423: PUSH
24424: LD_INT 30
24426: PUSH
24427: LD_INT 7
24429: PUSH
24430: EMPTY
24431: LIST
24432: LIST
24433: PUSH
24434: LD_INT 30
24436: PUSH
24437: LD_INT 8
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: PPUSH
24450: CALL_OW 72
24454: AND
24455: PUSH
24456: LD_EXP 50
24460: PUSH
24461: LD_VAR 0 1
24465: ARRAY
24466: PPUSH
24467: LD_INT 30
24469: PUSH
24470: LD_INT 3
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 72
24481: AND
24482: IFFALSE 25216
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24484: LD_ADDR_EXP 92
24488: PUSH
24489: LD_EXP 92
24493: PPUSH
24494: LD_VAR 0 1
24498: PPUSH
24499: LD_INT 3
24501: PPUSH
24502: CALL_OW 1
24506: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24507: LD_ADDR_VAR 0 2
24511: PUSH
24512: LD_INT 0
24514: PUSH
24515: LD_INT 0
24517: PUSH
24518: LD_INT 0
24520: PUSH
24521: LD_INT 0
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: ST_TO_ADDR
// if not eng then
24530: LD_VAR 0 6
24534: NOT
24535: IFFALSE 24598
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24537: LD_ADDR_VAR 0 11
24541: PUSH
24542: LD_VAR 0 4
24546: PPUSH
24547: LD_INT 2
24549: PPUSH
24550: CALL 85264 0 2
24554: PUSH
24555: LD_INT 1
24557: ARRAY
24558: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24559: LD_ADDR_VAR 0 2
24563: PUSH
24564: LD_VAR 0 2
24568: PPUSH
24569: LD_INT 2
24571: PPUSH
24572: LD_VAR 0 11
24576: PPUSH
24577: CALL_OW 1
24581: ST_TO_ADDR
// tmp := tmp diff p ;
24582: LD_ADDR_VAR 0 4
24586: PUSH
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 11
24596: DIFF
24597: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24598: LD_VAR 0 4
24602: PUSH
24603: LD_VAR 0 8
24607: PUSH
24608: LD_INT 6
24610: LESS
24611: AND
24612: IFFALSE 24800
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24614: LD_ADDR_VAR 0 9
24618: PUSH
24619: LD_VAR 0 4
24623: PUSH
24624: LD_VAR 0 8
24628: PUSH
24629: LD_VAR 0 7
24633: UNION
24634: DIFF
24635: PPUSH
24636: LD_INT 4
24638: PPUSH
24639: CALL 85264 0 2
24643: ST_TO_ADDR
// p := [ ] ;
24644: LD_ADDR_VAR 0 11
24648: PUSH
24649: EMPTY
24650: ST_TO_ADDR
// if sort then
24651: LD_VAR 0 9
24655: IFFALSE 24771
// for i = 1 to 6 - sci do
24657: LD_ADDR_VAR 0 3
24661: PUSH
24662: DOUBLE
24663: LD_INT 1
24665: DEC
24666: ST_TO_ADDR
24667: LD_INT 6
24669: PUSH
24670: LD_VAR 0 8
24674: MINUS
24675: PUSH
24676: FOR_TO
24677: IFFALSE 24769
// begin if i = sort then
24679: LD_VAR 0 3
24683: PUSH
24684: LD_VAR 0 9
24688: EQUAL
24689: IFFALSE 24693
// break ;
24691: GO 24769
// if GetClass ( i ) = 4 then
24693: LD_VAR 0 3
24697: PPUSH
24698: CALL_OW 257
24702: PUSH
24703: LD_INT 4
24705: EQUAL
24706: IFFALSE 24710
// continue ;
24708: GO 24676
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24710: LD_ADDR_VAR 0 11
24714: PUSH
24715: LD_VAR 0 11
24719: PPUSH
24720: LD_VAR 0 11
24724: PUSH
24725: LD_INT 1
24727: PLUS
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_VAR 0 3
24738: ARRAY
24739: PPUSH
24740: CALL_OW 2
24744: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24745: LD_ADDR_VAR 0 4
24749: PUSH
24750: LD_VAR 0 4
24754: PUSH
24755: LD_VAR 0 9
24759: PUSH
24760: LD_VAR 0 3
24764: ARRAY
24765: DIFF
24766: ST_TO_ADDR
// end ;
24767: GO 24676
24769: POP
24770: POP
// if p then
24771: LD_VAR 0 11
24775: IFFALSE 24800
// result := Replace ( result , 4 , p ) ;
24777: LD_ADDR_VAR 0 2
24781: PUSH
24782: LD_VAR 0 2
24786: PPUSH
24787: LD_INT 4
24789: PPUSH
24790: LD_VAR 0 11
24794: PPUSH
24795: CALL_OW 1
24799: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24800: LD_VAR 0 4
24804: PUSH
24805: LD_VAR 0 7
24809: PUSH
24810: LD_INT 6
24812: LESS
24813: AND
24814: IFFALSE 25002
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24816: LD_ADDR_VAR 0 9
24820: PUSH
24821: LD_VAR 0 4
24825: PUSH
24826: LD_VAR 0 8
24830: PUSH
24831: LD_VAR 0 7
24835: UNION
24836: DIFF
24837: PPUSH
24838: LD_INT 3
24840: PPUSH
24841: CALL 85264 0 2
24845: ST_TO_ADDR
// p := [ ] ;
24846: LD_ADDR_VAR 0 11
24850: PUSH
24851: EMPTY
24852: ST_TO_ADDR
// if sort then
24853: LD_VAR 0 9
24857: IFFALSE 24973
// for i = 1 to 6 - mech do
24859: LD_ADDR_VAR 0 3
24863: PUSH
24864: DOUBLE
24865: LD_INT 1
24867: DEC
24868: ST_TO_ADDR
24869: LD_INT 6
24871: PUSH
24872: LD_VAR 0 7
24876: MINUS
24877: PUSH
24878: FOR_TO
24879: IFFALSE 24971
// begin if i = sort then
24881: LD_VAR 0 3
24885: PUSH
24886: LD_VAR 0 9
24890: EQUAL
24891: IFFALSE 24895
// break ;
24893: GO 24971
// if GetClass ( i ) = 3 then
24895: LD_VAR 0 3
24899: PPUSH
24900: CALL_OW 257
24904: PUSH
24905: LD_INT 3
24907: EQUAL
24908: IFFALSE 24912
// continue ;
24910: GO 24878
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24912: LD_ADDR_VAR 0 11
24916: PUSH
24917: LD_VAR 0 11
24921: PPUSH
24922: LD_VAR 0 11
24926: PUSH
24927: LD_INT 1
24929: PLUS
24930: PPUSH
24931: LD_VAR 0 9
24935: PUSH
24936: LD_VAR 0 3
24940: ARRAY
24941: PPUSH
24942: CALL_OW 2
24946: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24947: LD_ADDR_VAR 0 4
24951: PUSH
24952: LD_VAR 0 4
24956: PUSH
24957: LD_VAR 0 9
24961: PUSH
24962: LD_VAR 0 3
24966: ARRAY
24967: DIFF
24968: ST_TO_ADDR
// end ;
24969: GO 24878
24971: POP
24972: POP
// if p then
24973: LD_VAR 0 11
24977: IFFALSE 25002
// result := Replace ( result , 3 , p ) ;
24979: LD_ADDR_VAR 0 2
24983: PUSH
24984: LD_VAR 0 2
24988: PPUSH
24989: LD_INT 3
24991: PPUSH
24992: LD_VAR 0 11
24996: PPUSH
24997: CALL_OW 1
25001: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25002: LD_VAR 0 4
25006: PUSH
25007: LD_INT 6
25009: GREATER
25010: PUSH
25011: LD_VAR 0 6
25015: PUSH
25016: LD_INT 6
25018: LESS
25019: AND
25020: IFFALSE 25214
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25022: LD_ADDR_VAR 0 9
25026: PUSH
25027: LD_VAR 0 4
25031: PUSH
25032: LD_VAR 0 8
25036: PUSH
25037: LD_VAR 0 7
25041: UNION
25042: PUSH
25043: LD_VAR 0 6
25047: UNION
25048: DIFF
25049: PPUSH
25050: LD_INT 2
25052: PPUSH
25053: CALL 85264 0 2
25057: ST_TO_ADDR
// p := [ ] ;
25058: LD_ADDR_VAR 0 11
25062: PUSH
25063: EMPTY
25064: ST_TO_ADDR
// if sort then
25065: LD_VAR 0 9
25069: IFFALSE 25185
// for i = 1 to 6 - eng do
25071: LD_ADDR_VAR 0 3
25075: PUSH
25076: DOUBLE
25077: LD_INT 1
25079: DEC
25080: ST_TO_ADDR
25081: LD_INT 6
25083: PUSH
25084: LD_VAR 0 6
25088: MINUS
25089: PUSH
25090: FOR_TO
25091: IFFALSE 25183
// begin if i = sort then
25093: LD_VAR 0 3
25097: PUSH
25098: LD_VAR 0 9
25102: EQUAL
25103: IFFALSE 25107
// break ;
25105: GO 25183
// if GetClass ( i ) = 2 then
25107: LD_VAR 0 3
25111: PPUSH
25112: CALL_OW 257
25116: PUSH
25117: LD_INT 2
25119: EQUAL
25120: IFFALSE 25124
// continue ;
25122: GO 25090
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25124: LD_ADDR_VAR 0 11
25128: PUSH
25129: LD_VAR 0 11
25133: PPUSH
25134: LD_VAR 0 11
25138: PUSH
25139: LD_INT 1
25141: PLUS
25142: PPUSH
25143: LD_VAR 0 9
25147: PUSH
25148: LD_VAR 0 3
25152: ARRAY
25153: PPUSH
25154: CALL_OW 2
25158: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25159: LD_ADDR_VAR 0 4
25163: PUSH
25164: LD_VAR 0 4
25168: PUSH
25169: LD_VAR 0 9
25173: PUSH
25174: LD_VAR 0 3
25178: ARRAY
25179: DIFF
25180: ST_TO_ADDR
// end ;
25181: GO 25090
25183: POP
25184: POP
// if p then
25185: LD_VAR 0 11
25189: IFFALSE 25214
// result := Replace ( result , 2 , p ) ;
25191: LD_ADDR_VAR 0 2
25195: PUSH
25196: LD_VAR 0 2
25200: PPUSH
25201: LD_INT 2
25203: PPUSH
25204: LD_VAR 0 11
25208: PPUSH
25209: CALL_OW 1
25213: ST_TO_ADDR
// end ; exit ;
25214: GO 26602
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25216: LD_EXP 77
25220: PUSH
25221: LD_EXP 76
25225: PUSH
25226: LD_VAR 0 1
25230: ARRAY
25231: ARRAY
25232: NOT
25233: PUSH
25234: LD_EXP 50
25238: PUSH
25239: LD_VAR 0 1
25243: ARRAY
25244: PPUSH
25245: LD_INT 30
25247: PUSH
25248: LD_INT 3
25250: PUSH
25251: EMPTY
25252: LIST
25253: LIST
25254: PPUSH
25255: CALL_OW 72
25259: AND
25260: PUSH
25261: LD_EXP 55
25265: PUSH
25266: LD_VAR 0 1
25270: ARRAY
25271: AND
25272: IFFALSE 25880
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25274: LD_ADDR_EXP 92
25278: PUSH
25279: LD_EXP 92
25283: PPUSH
25284: LD_VAR 0 1
25288: PPUSH
25289: LD_INT 5
25291: PPUSH
25292: CALL_OW 1
25296: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25297: LD_ADDR_VAR 0 2
25301: PUSH
25302: LD_INT 0
25304: PUSH
25305: LD_INT 0
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: LD_INT 0
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: LIST
25318: LIST
25319: ST_TO_ADDR
// if sci > 1 then
25320: LD_VAR 0 8
25324: PUSH
25325: LD_INT 1
25327: GREATER
25328: IFFALSE 25356
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25330: LD_ADDR_VAR 0 4
25334: PUSH
25335: LD_VAR 0 4
25339: PUSH
25340: LD_VAR 0 8
25344: PUSH
25345: LD_VAR 0 8
25349: PUSH
25350: LD_INT 1
25352: ARRAY
25353: DIFF
25354: DIFF
25355: ST_TO_ADDR
// if tmp and not sci then
25356: LD_VAR 0 4
25360: PUSH
25361: LD_VAR 0 8
25365: NOT
25366: AND
25367: IFFALSE 25436
// begin sort := SortBySkill ( tmp , 4 ) ;
25369: LD_ADDR_VAR 0 9
25373: PUSH
25374: LD_VAR 0 4
25378: PPUSH
25379: LD_INT 4
25381: PPUSH
25382: CALL 85264 0 2
25386: ST_TO_ADDR
// if sort then
25387: LD_VAR 0 9
25391: IFFALSE 25407
// p := sort [ 1 ] ;
25393: LD_ADDR_VAR 0 11
25397: PUSH
25398: LD_VAR 0 9
25402: PUSH
25403: LD_INT 1
25405: ARRAY
25406: ST_TO_ADDR
// if p then
25407: LD_VAR 0 11
25411: IFFALSE 25436
// result := Replace ( result , 4 , p ) ;
25413: LD_ADDR_VAR 0 2
25417: PUSH
25418: LD_VAR 0 2
25422: PPUSH
25423: LD_INT 4
25425: PPUSH
25426: LD_VAR 0 11
25430: PPUSH
25431: CALL_OW 1
25435: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25436: LD_ADDR_VAR 0 4
25440: PUSH
25441: LD_VAR 0 4
25445: PUSH
25446: LD_VAR 0 7
25450: DIFF
25451: ST_TO_ADDR
// if tmp and mech < 6 then
25452: LD_VAR 0 4
25456: PUSH
25457: LD_VAR 0 7
25461: PUSH
25462: LD_INT 6
25464: LESS
25465: AND
25466: IFFALSE 25654
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25468: LD_ADDR_VAR 0 9
25472: PUSH
25473: LD_VAR 0 4
25477: PUSH
25478: LD_VAR 0 8
25482: PUSH
25483: LD_VAR 0 7
25487: UNION
25488: DIFF
25489: PPUSH
25490: LD_INT 3
25492: PPUSH
25493: CALL 85264 0 2
25497: ST_TO_ADDR
// p := [ ] ;
25498: LD_ADDR_VAR 0 11
25502: PUSH
25503: EMPTY
25504: ST_TO_ADDR
// if sort then
25505: LD_VAR 0 9
25509: IFFALSE 25625
// for i = 1 to 6 - mech do
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: DOUBLE
25517: LD_INT 1
25519: DEC
25520: ST_TO_ADDR
25521: LD_INT 6
25523: PUSH
25524: LD_VAR 0 7
25528: MINUS
25529: PUSH
25530: FOR_TO
25531: IFFALSE 25623
// begin if i = sort then
25533: LD_VAR 0 3
25537: PUSH
25538: LD_VAR 0 9
25542: EQUAL
25543: IFFALSE 25547
// break ;
25545: GO 25623
// if GetClass ( i ) = 3 then
25547: LD_VAR 0 3
25551: PPUSH
25552: CALL_OW 257
25556: PUSH
25557: LD_INT 3
25559: EQUAL
25560: IFFALSE 25564
// continue ;
25562: GO 25530
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25564: LD_ADDR_VAR 0 11
25568: PUSH
25569: LD_VAR 0 11
25573: PPUSH
25574: LD_VAR 0 11
25578: PUSH
25579: LD_INT 1
25581: PLUS
25582: PPUSH
25583: LD_VAR 0 9
25587: PUSH
25588: LD_VAR 0 3
25592: ARRAY
25593: PPUSH
25594: CALL_OW 2
25598: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25599: LD_ADDR_VAR 0 4
25603: PUSH
25604: LD_VAR 0 4
25608: PUSH
25609: LD_VAR 0 9
25613: PUSH
25614: LD_VAR 0 3
25618: ARRAY
25619: DIFF
25620: ST_TO_ADDR
// end ;
25621: GO 25530
25623: POP
25624: POP
// if p then
25625: LD_VAR 0 11
25629: IFFALSE 25654
// result := Replace ( result , 3 , p ) ;
25631: LD_ADDR_VAR 0 2
25635: PUSH
25636: LD_VAR 0 2
25640: PPUSH
25641: LD_INT 3
25643: PPUSH
25644: LD_VAR 0 11
25648: PPUSH
25649: CALL_OW 1
25653: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25654: LD_ADDR_VAR 0 4
25658: PUSH
25659: LD_VAR 0 4
25663: PUSH
25664: LD_VAR 0 6
25668: DIFF
25669: ST_TO_ADDR
// if tmp and eng < 6 then
25670: LD_VAR 0 4
25674: PUSH
25675: LD_VAR 0 6
25679: PUSH
25680: LD_INT 6
25682: LESS
25683: AND
25684: IFFALSE 25878
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25686: LD_ADDR_VAR 0 9
25690: PUSH
25691: LD_VAR 0 4
25695: PUSH
25696: LD_VAR 0 8
25700: PUSH
25701: LD_VAR 0 7
25705: UNION
25706: PUSH
25707: LD_VAR 0 6
25711: UNION
25712: DIFF
25713: PPUSH
25714: LD_INT 2
25716: PPUSH
25717: CALL 85264 0 2
25721: ST_TO_ADDR
// p := [ ] ;
25722: LD_ADDR_VAR 0 11
25726: PUSH
25727: EMPTY
25728: ST_TO_ADDR
// if sort then
25729: LD_VAR 0 9
25733: IFFALSE 25849
// for i = 1 to 6 - eng do
25735: LD_ADDR_VAR 0 3
25739: PUSH
25740: DOUBLE
25741: LD_INT 1
25743: DEC
25744: ST_TO_ADDR
25745: LD_INT 6
25747: PUSH
25748: LD_VAR 0 6
25752: MINUS
25753: PUSH
25754: FOR_TO
25755: IFFALSE 25847
// begin if i = sort then
25757: LD_VAR 0 3
25761: PUSH
25762: LD_VAR 0 9
25766: EQUAL
25767: IFFALSE 25771
// break ;
25769: GO 25847
// if GetClass ( i ) = 2 then
25771: LD_VAR 0 3
25775: PPUSH
25776: CALL_OW 257
25780: PUSH
25781: LD_INT 2
25783: EQUAL
25784: IFFALSE 25788
// continue ;
25786: GO 25754
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25788: LD_ADDR_VAR 0 11
25792: PUSH
25793: LD_VAR 0 11
25797: PPUSH
25798: LD_VAR 0 11
25802: PUSH
25803: LD_INT 1
25805: PLUS
25806: PPUSH
25807: LD_VAR 0 9
25811: PUSH
25812: LD_VAR 0 3
25816: ARRAY
25817: PPUSH
25818: CALL_OW 2
25822: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25823: LD_ADDR_VAR 0 4
25827: PUSH
25828: LD_VAR 0 4
25832: PUSH
25833: LD_VAR 0 9
25837: PUSH
25838: LD_VAR 0 3
25842: ARRAY
25843: DIFF
25844: ST_TO_ADDR
// end ;
25845: GO 25754
25847: POP
25848: POP
// if p then
25849: LD_VAR 0 11
25853: IFFALSE 25878
// result := Replace ( result , 2 , p ) ;
25855: LD_ADDR_VAR 0 2
25859: PUSH
25860: LD_VAR 0 2
25864: PPUSH
25865: LD_INT 2
25867: PPUSH
25868: LD_VAR 0 11
25872: PPUSH
25873: CALL_OW 1
25877: ST_TO_ADDR
// end ; exit ;
25878: GO 26602
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25880: LD_EXP 77
25884: PUSH
25885: LD_EXP 76
25889: PUSH
25890: LD_VAR 0 1
25894: ARRAY
25895: ARRAY
25896: NOT
25897: PUSH
25898: LD_EXP 50
25902: PUSH
25903: LD_VAR 0 1
25907: ARRAY
25908: PPUSH
25909: LD_INT 30
25911: PUSH
25912: LD_INT 3
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PPUSH
25919: CALL_OW 72
25923: AND
25924: PUSH
25925: LD_EXP 55
25929: PUSH
25930: LD_VAR 0 1
25934: ARRAY
25935: NOT
25936: AND
25937: IFFALSE 26602
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25939: LD_ADDR_EXP 92
25943: PUSH
25944: LD_EXP 92
25948: PPUSH
25949: LD_VAR 0 1
25953: PPUSH
25954: LD_INT 6
25956: PPUSH
25957: CALL_OW 1
25961: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25962: LD_ADDR_VAR 0 2
25966: PUSH
25967: LD_INT 0
25969: PUSH
25970: LD_INT 0
25972: PUSH
25973: LD_INT 0
25975: PUSH
25976: LD_INT 0
25978: PUSH
25979: EMPTY
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: ST_TO_ADDR
// if sci >= 1 then
25985: LD_VAR 0 8
25989: PUSH
25990: LD_INT 1
25992: GREATEREQUAL
25993: IFFALSE 26015
// tmp := tmp diff sci [ 1 ] ;
25995: LD_ADDR_VAR 0 4
25999: PUSH
26000: LD_VAR 0 4
26004: PUSH
26005: LD_VAR 0 8
26009: PUSH
26010: LD_INT 1
26012: ARRAY
26013: DIFF
26014: ST_TO_ADDR
// if tmp and not sci then
26015: LD_VAR 0 4
26019: PUSH
26020: LD_VAR 0 8
26024: NOT
26025: AND
26026: IFFALSE 26095
// begin sort := SortBySkill ( tmp , 4 ) ;
26028: LD_ADDR_VAR 0 9
26032: PUSH
26033: LD_VAR 0 4
26037: PPUSH
26038: LD_INT 4
26040: PPUSH
26041: CALL 85264 0 2
26045: ST_TO_ADDR
// if sort then
26046: LD_VAR 0 9
26050: IFFALSE 26066
// p := sort [ 1 ] ;
26052: LD_ADDR_VAR 0 11
26056: PUSH
26057: LD_VAR 0 9
26061: PUSH
26062: LD_INT 1
26064: ARRAY
26065: ST_TO_ADDR
// if p then
26066: LD_VAR 0 11
26070: IFFALSE 26095
// result := Replace ( result , 4 , p ) ;
26072: LD_ADDR_VAR 0 2
26076: PUSH
26077: LD_VAR 0 2
26081: PPUSH
26082: LD_INT 4
26084: PPUSH
26085: LD_VAR 0 11
26089: PPUSH
26090: CALL_OW 1
26094: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26095: LD_ADDR_VAR 0 4
26099: PUSH
26100: LD_VAR 0 4
26104: PUSH
26105: LD_VAR 0 7
26109: DIFF
26110: ST_TO_ADDR
// if tmp and mech < 6 then
26111: LD_VAR 0 4
26115: PUSH
26116: LD_VAR 0 7
26120: PUSH
26121: LD_INT 6
26123: LESS
26124: AND
26125: IFFALSE 26307
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26127: LD_ADDR_VAR 0 9
26131: PUSH
26132: LD_VAR 0 4
26136: PUSH
26137: LD_VAR 0 7
26141: DIFF
26142: PPUSH
26143: LD_INT 3
26145: PPUSH
26146: CALL 85264 0 2
26150: ST_TO_ADDR
// p := [ ] ;
26151: LD_ADDR_VAR 0 11
26155: PUSH
26156: EMPTY
26157: ST_TO_ADDR
// if sort then
26158: LD_VAR 0 9
26162: IFFALSE 26278
// for i = 1 to 6 - mech do
26164: LD_ADDR_VAR 0 3
26168: PUSH
26169: DOUBLE
26170: LD_INT 1
26172: DEC
26173: ST_TO_ADDR
26174: LD_INT 6
26176: PUSH
26177: LD_VAR 0 7
26181: MINUS
26182: PUSH
26183: FOR_TO
26184: IFFALSE 26276
// begin if i = sort then
26186: LD_VAR 0 3
26190: PUSH
26191: LD_VAR 0 9
26195: EQUAL
26196: IFFALSE 26200
// break ;
26198: GO 26276
// if GetClass ( i ) = 3 then
26200: LD_VAR 0 3
26204: PPUSH
26205: CALL_OW 257
26209: PUSH
26210: LD_INT 3
26212: EQUAL
26213: IFFALSE 26217
// continue ;
26215: GO 26183
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26217: LD_ADDR_VAR 0 11
26221: PUSH
26222: LD_VAR 0 11
26226: PPUSH
26227: LD_VAR 0 11
26231: PUSH
26232: LD_INT 1
26234: PLUS
26235: PPUSH
26236: LD_VAR 0 9
26240: PUSH
26241: LD_VAR 0 3
26245: ARRAY
26246: PPUSH
26247: CALL_OW 2
26251: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26252: LD_ADDR_VAR 0 4
26256: PUSH
26257: LD_VAR 0 4
26261: PUSH
26262: LD_VAR 0 9
26266: PUSH
26267: LD_VAR 0 3
26271: ARRAY
26272: DIFF
26273: ST_TO_ADDR
// end ;
26274: GO 26183
26276: POP
26277: POP
// if p then
26278: LD_VAR 0 11
26282: IFFALSE 26307
// result := Replace ( result , 3 , p ) ;
26284: LD_ADDR_VAR 0 2
26288: PUSH
26289: LD_VAR 0 2
26293: PPUSH
26294: LD_INT 3
26296: PPUSH
26297: LD_VAR 0 11
26301: PPUSH
26302: CALL_OW 1
26306: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26307: LD_ADDR_VAR 0 4
26311: PUSH
26312: LD_VAR 0 4
26316: PUSH
26317: LD_VAR 0 6
26321: DIFF
26322: ST_TO_ADDR
// if tmp and eng < 4 then
26323: LD_VAR 0 4
26327: PUSH
26328: LD_VAR 0 6
26332: PUSH
26333: LD_INT 4
26335: LESS
26336: AND
26337: IFFALSE 26527
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26339: LD_ADDR_VAR 0 9
26343: PUSH
26344: LD_VAR 0 4
26348: PUSH
26349: LD_VAR 0 7
26353: PUSH
26354: LD_VAR 0 6
26358: UNION
26359: DIFF
26360: PPUSH
26361: LD_INT 2
26363: PPUSH
26364: CALL 85264 0 2
26368: ST_TO_ADDR
// p := [ ] ;
26369: LD_ADDR_VAR 0 11
26373: PUSH
26374: EMPTY
26375: ST_TO_ADDR
// if sort then
26376: LD_VAR 0 9
26380: IFFALSE 26496
// for i = 1 to 4 - eng do
26382: LD_ADDR_VAR 0 3
26386: PUSH
26387: DOUBLE
26388: LD_INT 1
26390: DEC
26391: ST_TO_ADDR
26392: LD_INT 4
26394: PUSH
26395: LD_VAR 0 6
26399: MINUS
26400: PUSH
26401: FOR_TO
26402: IFFALSE 26494
// begin if i = sort then
26404: LD_VAR 0 3
26408: PUSH
26409: LD_VAR 0 9
26413: EQUAL
26414: IFFALSE 26418
// break ;
26416: GO 26494
// if GetClass ( i ) = 2 then
26418: LD_VAR 0 3
26422: PPUSH
26423: CALL_OW 257
26427: PUSH
26428: LD_INT 2
26430: EQUAL
26431: IFFALSE 26435
// continue ;
26433: GO 26401
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26435: LD_ADDR_VAR 0 11
26439: PUSH
26440: LD_VAR 0 11
26444: PPUSH
26445: LD_VAR 0 11
26449: PUSH
26450: LD_INT 1
26452: PLUS
26453: PPUSH
26454: LD_VAR 0 9
26458: PUSH
26459: LD_VAR 0 3
26463: ARRAY
26464: PPUSH
26465: CALL_OW 2
26469: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26470: LD_ADDR_VAR 0 4
26474: PUSH
26475: LD_VAR 0 4
26479: PUSH
26480: LD_VAR 0 9
26484: PUSH
26485: LD_VAR 0 3
26489: ARRAY
26490: DIFF
26491: ST_TO_ADDR
// end ;
26492: GO 26401
26494: POP
26495: POP
// if p then
26496: LD_VAR 0 11
26500: IFFALSE 26525
// result := Replace ( result , 2 , p ) ;
26502: LD_ADDR_VAR 0 2
26506: PUSH
26507: LD_VAR 0 2
26511: PPUSH
26512: LD_INT 2
26514: PPUSH
26515: LD_VAR 0 11
26519: PPUSH
26520: CALL_OW 1
26524: ST_TO_ADDR
// end else
26525: GO 26571
// for i = eng downto 5 do
26527: LD_ADDR_VAR 0 3
26531: PUSH
26532: DOUBLE
26533: LD_VAR 0 6
26537: INC
26538: ST_TO_ADDR
26539: LD_INT 5
26541: PUSH
26542: FOR_DOWNTO
26543: IFFALSE 26569
// tmp := tmp union eng [ i ] ;
26545: LD_ADDR_VAR 0 4
26549: PUSH
26550: LD_VAR 0 4
26554: PUSH
26555: LD_VAR 0 6
26559: PUSH
26560: LD_VAR 0 3
26564: ARRAY
26565: UNION
26566: ST_TO_ADDR
26567: GO 26542
26569: POP
26570: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26571: LD_ADDR_VAR 0 2
26575: PUSH
26576: LD_VAR 0 2
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_VAR 0 4
26588: PUSH
26589: LD_VAR 0 5
26593: DIFF
26594: PPUSH
26595: CALL_OW 1
26599: ST_TO_ADDR
// exit ;
26600: GO 26602
// end ; end ;
26602: LD_VAR 0 2
26606: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26607: LD_INT 0
26609: PPUSH
26610: PPUSH
26611: PPUSH
// if not mc_bases then
26612: LD_EXP 50
26616: NOT
26617: IFFALSE 26621
// exit ;
26619: GO 26763
// for i = 1 to mc_bases do
26621: LD_ADDR_VAR 0 2
26625: PUSH
26626: DOUBLE
26627: LD_INT 1
26629: DEC
26630: ST_TO_ADDR
26631: LD_EXP 50
26635: PUSH
26636: FOR_TO
26637: IFFALSE 26754
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26639: LD_ADDR_VAR 0 3
26643: PUSH
26644: LD_EXP 50
26648: PUSH
26649: LD_VAR 0 2
26653: ARRAY
26654: PPUSH
26655: LD_INT 21
26657: PUSH
26658: LD_INT 3
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 3
26667: PUSH
26668: LD_INT 2
26670: PUSH
26671: LD_INT 30
26673: PUSH
26674: LD_INT 29
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 30
26683: PUSH
26684: LD_INT 30
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: LIST
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 3
26702: PUSH
26703: LD_INT 24
26705: PUSH
26706: LD_INT 1000
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: LIST
26721: PPUSH
26722: CALL_OW 72
26726: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26727: LD_ADDR_EXP 51
26731: PUSH
26732: LD_EXP 51
26736: PPUSH
26737: LD_VAR 0 2
26741: PPUSH
26742: LD_VAR 0 3
26746: PPUSH
26747: CALL_OW 1
26751: ST_TO_ADDR
// end ;
26752: GO 26636
26754: POP
26755: POP
// RaiseSailEvent ( 101 ) ;
26756: LD_INT 101
26758: PPUSH
26759: CALL_OW 427
// end ;
26763: LD_VAR 0 1
26767: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26768: LD_INT 0
26770: PPUSH
26771: PPUSH
26772: PPUSH
26773: PPUSH
26774: PPUSH
26775: PPUSH
26776: PPUSH
// if not mc_bases then
26777: LD_EXP 50
26781: NOT
26782: IFFALSE 26786
// exit ;
26784: GO 27348
// for i = 1 to mc_bases do
26786: LD_ADDR_VAR 0 2
26790: PUSH
26791: DOUBLE
26792: LD_INT 1
26794: DEC
26795: ST_TO_ADDR
26796: LD_EXP 50
26800: PUSH
26801: FOR_TO
26802: IFFALSE 27339
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26804: LD_ADDR_VAR 0 5
26808: PUSH
26809: LD_EXP 50
26813: PUSH
26814: LD_VAR 0 2
26818: ARRAY
26819: PUSH
26820: LD_EXP 79
26824: PUSH
26825: LD_VAR 0 2
26829: ARRAY
26830: UNION
26831: PPUSH
26832: LD_INT 21
26834: PUSH
26835: LD_INT 1
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 1
26844: PUSH
26845: LD_INT 3
26847: PUSH
26848: LD_INT 54
26850: PUSH
26851: EMPTY
26852: LIST
26853: PUSH
26854: EMPTY
26855: LIST
26856: LIST
26857: PUSH
26858: LD_INT 3
26860: PUSH
26861: LD_INT 24
26863: PUSH
26864: LD_INT 1000
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: LIST
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PPUSH
26884: CALL_OW 72
26888: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26889: LD_ADDR_VAR 0 6
26893: PUSH
26894: LD_EXP 50
26898: PUSH
26899: LD_VAR 0 2
26903: ARRAY
26904: PPUSH
26905: LD_INT 21
26907: PUSH
26908: LD_INT 1
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: LD_INT 1
26917: PUSH
26918: LD_INT 3
26920: PUSH
26921: LD_INT 54
26923: PUSH
26924: EMPTY
26925: LIST
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 3
26933: PUSH
26934: LD_INT 24
26936: PUSH
26937: LD_INT 250
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: LIST
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PPUSH
26957: CALL_OW 72
26961: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26962: LD_ADDR_VAR 0 7
26966: PUSH
26967: LD_VAR 0 5
26971: PUSH
26972: LD_VAR 0 6
26976: DIFF
26977: ST_TO_ADDR
// if not need_heal_1 then
26978: LD_VAR 0 6
26982: NOT
26983: IFFALSE 27016
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26985: LD_ADDR_EXP 53
26989: PUSH
26990: LD_EXP 53
26994: PPUSH
26995: LD_VAR 0 2
26999: PUSH
27000: LD_INT 1
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PPUSH
27007: EMPTY
27008: PPUSH
27009: CALL 54011 0 3
27013: ST_TO_ADDR
27014: GO 27086
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27016: LD_ADDR_EXP 53
27020: PUSH
27021: LD_EXP 53
27025: PPUSH
27026: LD_VAR 0 2
27030: PUSH
27031: LD_INT 1
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PPUSH
27038: LD_EXP 53
27042: PUSH
27043: LD_VAR 0 2
27047: ARRAY
27048: PUSH
27049: LD_INT 1
27051: ARRAY
27052: PPUSH
27053: LD_INT 3
27055: PUSH
27056: LD_INT 24
27058: PUSH
27059: LD_INT 1000
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PPUSH
27070: CALL_OW 72
27074: PUSH
27075: LD_VAR 0 6
27079: UNION
27080: PPUSH
27081: CALL 54011 0 3
27085: ST_TO_ADDR
// if not need_heal_2 then
27086: LD_VAR 0 7
27090: NOT
27091: IFFALSE 27124
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27093: LD_ADDR_EXP 53
27097: PUSH
27098: LD_EXP 53
27102: PPUSH
27103: LD_VAR 0 2
27107: PUSH
27108: LD_INT 2
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PPUSH
27115: EMPTY
27116: PPUSH
27117: CALL 54011 0 3
27121: ST_TO_ADDR
27122: GO 27156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27124: LD_ADDR_EXP 53
27128: PUSH
27129: LD_EXP 53
27133: PPUSH
27134: LD_VAR 0 2
27138: PUSH
27139: LD_INT 2
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: PPUSH
27146: LD_VAR 0 7
27150: PPUSH
27151: CALL 54011 0 3
27155: ST_TO_ADDR
// if need_heal_2 then
27156: LD_VAR 0 7
27160: IFFALSE 27321
// for j in need_heal_2 do
27162: LD_ADDR_VAR 0 3
27166: PUSH
27167: LD_VAR 0 7
27171: PUSH
27172: FOR_IN
27173: IFFALSE 27319
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27175: LD_ADDR_VAR 0 5
27179: PUSH
27180: LD_EXP 50
27184: PUSH
27185: LD_VAR 0 2
27189: ARRAY
27190: PPUSH
27191: LD_INT 2
27193: PUSH
27194: LD_INT 30
27196: PUSH
27197: LD_INT 6
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: PUSH
27204: LD_INT 30
27206: PUSH
27207: LD_INT 7
27209: PUSH
27210: EMPTY
27211: LIST
27212: LIST
27213: PUSH
27214: LD_INT 30
27216: PUSH
27217: LD_INT 8
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 30
27226: PUSH
27227: LD_INT 0
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 30
27236: PUSH
27237: LD_INT 1
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: PPUSH
27252: CALL_OW 72
27256: ST_TO_ADDR
// if tmp then
27257: LD_VAR 0 5
27261: IFFALSE 27317
// begin k := NearestUnitToUnit ( tmp , j ) ;
27263: LD_ADDR_VAR 0 4
27267: PUSH
27268: LD_VAR 0 5
27272: PPUSH
27273: LD_VAR 0 3
27277: PPUSH
27278: CALL_OW 74
27282: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27283: LD_VAR 0 3
27287: PPUSH
27288: LD_VAR 0 4
27292: PPUSH
27293: CALL_OW 296
27297: PUSH
27298: LD_INT 5
27300: GREATER
27301: IFFALSE 27317
// ComMoveToNearbyEntrance ( j , k ) ;
27303: LD_VAR 0 3
27307: PPUSH
27308: LD_VAR 0 4
27312: PPUSH
27313: CALL 87637 0 2
// end ; end ;
27317: GO 27172
27319: POP
27320: POP
// if not need_heal_1 and not need_heal_2 then
27321: LD_VAR 0 6
27325: NOT
27326: PUSH
27327: LD_VAR 0 7
27331: NOT
27332: AND
27333: IFFALSE 27337
// continue ;
27335: GO 26801
// end ;
27337: GO 26801
27339: POP
27340: POP
// RaiseSailEvent ( 102 ) ;
27341: LD_INT 102
27343: PPUSH
27344: CALL_OW 427
// end ;
27348: LD_VAR 0 1
27352: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27353: LD_INT 0
27355: PPUSH
27356: PPUSH
27357: PPUSH
27358: PPUSH
27359: PPUSH
27360: PPUSH
27361: PPUSH
27362: PPUSH
// if not mc_bases then
27363: LD_EXP 50
27367: NOT
27368: IFFALSE 27372
// exit ;
27370: GO 28283
// for i = 1 to mc_bases do
27372: LD_ADDR_VAR 0 2
27376: PUSH
27377: DOUBLE
27378: LD_INT 1
27380: DEC
27381: ST_TO_ADDR
27382: LD_EXP 50
27386: PUSH
27387: FOR_TO
27388: IFFALSE 28281
// begin if not mc_building_need_repair [ i ] then
27390: LD_EXP 51
27394: PUSH
27395: LD_VAR 0 2
27399: ARRAY
27400: NOT
27401: IFFALSE 27586
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27403: LD_ADDR_VAR 0 6
27407: PUSH
27408: LD_EXP 69
27412: PUSH
27413: LD_VAR 0 2
27417: ARRAY
27418: PPUSH
27419: LD_INT 3
27421: PUSH
27422: LD_INT 24
27424: PUSH
27425: LD_INT 1000
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 2
27438: PUSH
27439: LD_INT 34
27441: PUSH
27442: LD_INT 13
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 34
27451: PUSH
27452: LD_INT 52
27454: PUSH
27455: EMPTY
27456: LIST
27457: LIST
27458: PUSH
27459: LD_INT 34
27461: PUSH
27462: LD_INT 88
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: PPUSH
27479: CALL_OW 72
27483: ST_TO_ADDR
// if cranes then
27484: LD_VAR 0 6
27488: IFFALSE 27550
// for j in cranes do
27490: LD_ADDR_VAR 0 3
27494: PUSH
27495: LD_VAR 0 6
27499: PUSH
27500: FOR_IN
27501: IFFALSE 27548
// if not IsInArea ( j , mc_parking [ i ] ) then
27503: LD_VAR 0 3
27507: PPUSH
27508: LD_EXP 74
27512: PUSH
27513: LD_VAR 0 2
27517: ARRAY
27518: PPUSH
27519: CALL_OW 308
27523: NOT
27524: IFFALSE 27546
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27526: LD_VAR 0 3
27530: PPUSH
27531: LD_EXP 74
27535: PUSH
27536: LD_VAR 0 2
27540: ARRAY
27541: PPUSH
27542: CALL_OW 113
27546: GO 27500
27548: POP
27549: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27550: LD_ADDR_EXP 52
27554: PUSH
27555: LD_EXP 52
27559: PPUSH
27560: LD_VAR 0 2
27564: PPUSH
27565: EMPTY
27566: PPUSH
27567: CALL_OW 1
27571: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27572: LD_VAR 0 2
27576: PPUSH
27577: LD_INT 101
27579: PPUSH
27580: CALL 22426 0 2
// continue ;
27584: GO 27387
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27586: LD_ADDR_EXP 56
27590: PUSH
27591: LD_EXP 56
27595: PPUSH
27596: LD_VAR 0 2
27600: PPUSH
27601: EMPTY
27602: PPUSH
27603: CALL_OW 1
27607: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27608: LD_VAR 0 2
27612: PPUSH
27613: LD_INT 103
27615: PPUSH
27616: CALL 22426 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27620: LD_ADDR_VAR 0 5
27624: PUSH
27625: LD_EXP 50
27629: PUSH
27630: LD_VAR 0 2
27634: ARRAY
27635: PUSH
27636: LD_EXP 79
27640: PUSH
27641: LD_VAR 0 2
27645: ARRAY
27646: UNION
27647: PPUSH
27648: LD_INT 2
27650: PUSH
27651: LD_INT 25
27653: PUSH
27654: LD_INT 2
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: PUSH
27661: LD_INT 25
27663: PUSH
27664: LD_INT 16
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: LIST
27675: PUSH
27676: EMPTY
27677: LIST
27678: PPUSH
27679: CALL_OW 72
27683: ST_TO_ADDR
// if mc_need_heal [ i ] then
27684: LD_EXP 53
27688: PUSH
27689: LD_VAR 0 2
27693: ARRAY
27694: IFFALSE 27738
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27696: LD_ADDR_VAR 0 5
27700: PUSH
27701: LD_VAR 0 5
27705: PUSH
27706: LD_EXP 53
27710: PUSH
27711: LD_VAR 0 2
27715: ARRAY
27716: PUSH
27717: LD_INT 1
27719: ARRAY
27720: PUSH
27721: LD_EXP 53
27725: PUSH
27726: LD_VAR 0 2
27730: ARRAY
27731: PUSH
27732: LD_INT 2
27734: ARRAY
27735: UNION
27736: DIFF
27737: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27738: LD_ADDR_VAR 0 6
27742: PUSH
27743: LD_EXP 69
27747: PUSH
27748: LD_VAR 0 2
27752: ARRAY
27753: PPUSH
27754: LD_INT 2
27756: PUSH
27757: LD_INT 34
27759: PUSH
27760: LD_INT 13
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: LD_INT 34
27769: PUSH
27770: LD_INT 52
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 34
27779: PUSH
27780: LD_INT 88
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: LIST
27791: LIST
27792: PPUSH
27793: CALL_OW 72
27797: ST_TO_ADDR
// if cranes then
27798: LD_VAR 0 6
27802: IFFALSE 27970
// begin for j in cranes do
27804: LD_ADDR_VAR 0 3
27808: PUSH
27809: LD_VAR 0 6
27813: PUSH
27814: FOR_IN
27815: IFFALSE 27968
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27817: LD_VAR 0 3
27821: PPUSH
27822: CALL_OW 256
27826: PUSH
27827: LD_INT 1000
27829: EQUAL
27830: PUSH
27831: LD_VAR 0 3
27835: PPUSH
27836: CALL_OW 314
27840: NOT
27841: AND
27842: IFFALSE 27908
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27844: LD_ADDR_VAR 0 8
27848: PUSH
27849: LD_EXP 51
27853: PUSH
27854: LD_VAR 0 2
27858: ARRAY
27859: PPUSH
27860: LD_VAR 0 3
27864: PPUSH
27865: CALL_OW 74
27869: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27870: LD_VAR 0 8
27874: PPUSH
27875: LD_INT 16
27877: PPUSH
27878: CALL 56976 0 2
27882: PUSH
27883: LD_INT 4
27885: ARRAY
27886: PUSH
27887: LD_INT 10
27889: LESS
27890: IFFALSE 27906
// ComRepairBuilding ( j , to_repair ) ;
27892: LD_VAR 0 3
27896: PPUSH
27897: LD_VAR 0 8
27901: PPUSH
27902: CALL_OW 130
// end else
27906: GO 27966
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27908: LD_VAR 0 3
27912: PPUSH
27913: CALL_OW 256
27917: PUSH
27918: LD_INT 500
27920: LESS
27921: PUSH
27922: LD_VAR 0 3
27926: PPUSH
27927: LD_EXP 74
27931: PUSH
27932: LD_VAR 0 2
27936: ARRAY
27937: PPUSH
27938: CALL_OW 308
27942: NOT
27943: AND
27944: IFFALSE 27966
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27946: LD_VAR 0 3
27950: PPUSH
27951: LD_EXP 74
27955: PUSH
27956: LD_VAR 0 2
27960: ARRAY
27961: PPUSH
27962: CALL_OW 113
// end ;
27966: GO 27814
27968: POP
27969: POP
// end ; if tmp > 3 then
27970: LD_VAR 0 5
27974: PUSH
27975: LD_INT 3
27977: GREATER
27978: IFFALSE 27998
// tmp := ShrinkArray ( tmp , 4 ) ;
27980: LD_ADDR_VAR 0 5
27984: PUSH
27985: LD_VAR 0 5
27989: PPUSH
27990: LD_INT 4
27992: PPUSH
27993: CALL 87075 0 2
27997: ST_TO_ADDR
// if not tmp then
27998: LD_VAR 0 5
28002: NOT
28003: IFFALSE 28007
// continue ;
28005: GO 27387
// for j in tmp do
28007: LD_ADDR_VAR 0 3
28011: PUSH
28012: LD_VAR 0 5
28016: PUSH
28017: FOR_IN
28018: IFFALSE 28277
// begin if IsInUnit ( j ) then
28020: LD_VAR 0 3
28024: PPUSH
28025: CALL_OW 310
28029: IFFALSE 28040
// ComExitBuilding ( j ) ;
28031: LD_VAR 0 3
28035: PPUSH
28036: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28040: LD_VAR 0 3
28044: PUSH
28045: LD_EXP 52
28049: PUSH
28050: LD_VAR 0 2
28054: ARRAY
28055: IN
28056: NOT
28057: IFFALSE 28115
// begin SetTag ( j , 101 ) ;
28059: LD_VAR 0 3
28063: PPUSH
28064: LD_INT 101
28066: PPUSH
28067: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28071: LD_ADDR_EXP 52
28075: PUSH
28076: LD_EXP 52
28080: PPUSH
28081: LD_VAR 0 2
28085: PUSH
28086: LD_EXP 52
28090: PUSH
28091: LD_VAR 0 2
28095: ARRAY
28096: PUSH
28097: LD_INT 1
28099: PLUS
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: LD_VAR 0 3
28109: PPUSH
28110: CALL 54011 0 3
28114: ST_TO_ADDR
// end ; wait ( 1 ) ;
28115: LD_INT 1
28117: PPUSH
28118: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28122: LD_ADDR_VAR 0 7
28126: PUSH
28127: LD_EXP 51
28131: PUSH
28132: LD_VAR 0 2
28136: ARRAY
28137: ST_TO_ADDR
// if mc_scan [ i ] then
28138: LD_EXP 73
28142: PUSH
28143: LD_VAR 0 2
28147: ARRAY
28148: IFFALSE 28210
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28150: LD_ADDR_VAR 0 7
28154: PUSH
28155: LD_EXP 51
28159: PUSH
28160: LD_VAR 0 2
28164: ARRAY
28165: PPUSH
28166: LD_INT 3
28168: PUSH
28169: LD_INT 30
28171: PUSH
28172: LD_INT 32
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 30
28181: PUSH
28182: LD_INT 33
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 30
28191: PUSH
28192: LD_INT 31
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: PPUSH
28205: CALL_OW 72
28209: ST_TO_ADDR
// if not to_repair_tmp then
28210: LD_VAR 0 7
28214: NOT
28215: IFFALSE 28219
// continue ;
28217: GO 28017
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28219: LD_ADDR_VAR 0 8
28223: PUSH
28224: LD_VAR 0 7
28228: PPUSH
28229: LD_VAR 0 3
28233: PPUSH
28234: CALL_OW 74
28238: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28239: LD_VAR 0 8
28243: PPUSH
28244: LD_INT 16
28246: PPUSH
28247: CALL 56976 0 2
28251: PUSH
28252: LD_INT 4
28254: ARRAY
28255: PUSH
28256: LD_INT 14
28258: LESS
28259: IFFALSE 28275
// ComRepairBuilding ( j , to_repair ) ;
28261: LD_VAR 0 3
28265: PPUSH
28266: LD_VAR 0 8
28270: PPUSH
28271: CALL_OW 130
// end ;
28275: GO 28017
28277: POP
28278: POP
// end ;
28279: GO 27387
28281: POP
28282: POP
// end ;
28283: LD_VAR 0 1
28287: RET
// export function MC_Heal ; var i , j , tmp ; begin
28288: LD_INT 0
28290: PPUSH
28291: PPUSH
28292: PPUSH
28293: PPUSH
// if not mc_bases then
28294: LD_EXP 50
28298: NOT
28299: IFFALSE 28303
// exit ;
28301: GO 28705
// for i = 1 to mc_bases do
28303: LD_ADDR_VAR 0 2
28307: PUSH
28308: DOUBLE
28309: LD_INT 1
28311: DEC
28312: ST_TO_ADDR
28313: LD_EXP 50
28317: PUSH
28318: FOR_TO
28319: IFFALSE 28703
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28321: LD_EXP 53
28325: PUSH
28326: LD_VAR 0 2
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: NOT
28336: PUSH
28337: LD_EXP 53
28341: PUSH
28342: LD_VAR 0 2
28346: ARRAY
28347: PUSH
28348: LD_INT 2
28350: ARRAY
28351: NOT
28352: AND
28353: IFFALSE 28391
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28355: LD_ADDR_EXP 54
28359: PUSH
28360: LD_EXP 54
28364: PPUSH
28365: LD_VAR 0 2
28369: PPUSH
28370: EMPTY
28371: PPUSH
28372: CALL_OW 1
28376: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28377: LD_VAR 0 2
28381: PPUSH
28382: LD_INT 102
28384: PPUSH
28385: CALL 22426 0 2
// continue ;
28389: GO 28318
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28391: LD_ADDR_VAR 0 4
28395: PUSH
28396: LD_EXP 50
28400: PUSH
28401: LD_VAR 0 2
28405: ARRAY
28406: PPUSH
28407: LD_INT 25
28409: PUSH
28410: LD_INT 4
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PPUSH
28417: CALL_OW 72
28421: ST_TO_ADDR
// if not tmp then
28422: LD_VAR 0 4
28426: NOT
28427: IFFALSE 28431
// continue ;
28429: GO 28318
// if mc_taming [ i ] then
28431: LD_EXP 81
28435: PUSH
28436: LD_VAR 0 2
28440: ARRAY
28441: IFFALSE 28465
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28443: LD_ADDR_EXP 81
28447: PUSH
28448: LD_EXP 81
28452: PPUSH
28453: LD_VAR 0 2
28457: PPUSH
28458: EMPTY
28459: PPUSH
28460: CALL_OW 1
28464: ST_TO_ADDR
// for j in tmp do
28465: LD_ADDR_VAR 0 3
28469: PUSH
28470: LD_VAR 0 4
28474: PUSH
28475: FOR_IN
28476: IFFALSE 28699
// begin if IsInUnit ( j ) then
28478: LD_VAR 0 3
28482: PPUSH
28483: CALL_OW 310
28487: IFFALSE 28498
// ComExitBuilding ( j ) ;
28489: LD_VAR 0 3
28493: PPUSH
28494: CALL_OW 122
// if not j in mc_healers [ i ] then
28498: LD_VAR 0 3
28502: PUSH
28503: LD_EXP 54
28507: PUSH
28508: LD_VAR 0 2
28512: ARRAY
28513: IN
28514: NOT
28515: IFFALSE 28561
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28517: LD_ADDR_EXP 54
28521: PUSH
28522: LD_EXP 54
28526: PPUSH
28527: LD_VAR 0 2
28531: PUSH
28532: LD_EXP 54
28536: PUSH
28537: LD_VAR 0 2
28541: ARRAY
28542: PUSH
28543: LD_INT 1
28545: PLUS
28546: PUSH
28547: EMPTY
28548: LIST
28549: LIST
28550: PPUSH
28551: LD_VAR 0 3
28555: PPUSH
28556: CALL 54011 0 3
28560: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28561: LD_VAR 0 3
28565: PPUSH
28566: CALL_OW 110
28570: PUSH
28571: LD_INT 102
28573: NONEQUAL
28574: IFFALSE 28588
// SetTag ( j , 102 ) ;
28576: LD_VAR 0 3
28580: PPUSH
28581: LD_INT 102
28583: PPUSH
28584: CALL_OW 109
// Wait ( 3 ) ;
28588: LD_INT 3
28590: PPUSH
28591: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28595: LD_EXP 53
28599: PUSH
28600: LD_VAR 0 2
28604: ARRAY
28605: PUSH
28606: LD_INT 1
28608: ARRAY
28609: IFFALSE 28641
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28611: LD_VAR 0 3
28615: PPUSH
28616: LD_EXP 53
28620: PUSH
28621: LD_VAR 0 2
28625: ARRAY
28626: PUSH
28627: LD_INT 1
28629: ARRAY
28630: PUSH
28631: LD_INT 1
28633: ARRAY
28634: PPUSH
28635: CALL_OW 128
28639: GO 28697
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28641: LD_VAR 0 3
28645: PPUSH
28646: CALL_OW 314
28650: NOT
28651: PUSH
28652: LD_EXP 53
28656: PUSH
28657: LD_VAR 0 2
28661: ARRAY
28662: PUSH
28663: LD_INT 2
28665: ARRAY
28666: AND
28667: IFFALSE 28697
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28669: LD_VAR 0 3
28673: PPUSH
28674: LD_EXP 53
28678: PUSH
28679: LD_VAR 0 2
28683: ARRAY
28684: PUSH
28685: LD_INT 2
28687: ARRAY
28688: PUSH
28689: LD_INT 1
28691: ARRAY
28692: PPUSH
28693: CALL_OW 128
// end ;
28697: GO 28475
28699: POP
28700: POP
// end ;
28701: GO 28318
28703: POP
28704: POP
// end ;
28705: LD_VAR 0 1
28709: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28710: LD_INT 0
28712: PPUSH
28713: PPUSH
28714: PPUSH
28715: PPUSH
28716: PPUSH
28717: PPUSH
// if not mc_bases then
28718: LD_EXP 50
28722: NOT
28723: IFFALSE 28727
// exit ;
28725: GO 29890
// for i = 1 to mc_bases do
28727: LD_ADDR_VAR 0 2
28731: PUSH
28732: DOUBLE
28733: LD_INT 1
28735: DEC
28736: ST_TO_ADDR
28737: LD_EXP 50
28741: PUSH
28742: FOR_TO
28743: IFFALSE 29888
// begin if mc_scan [ i ] then
28745: LD_EXP 73
28749: PUSH
28750: LD_VAR 0 2
28754: ARRAY
28755: IFFALSE 28759
// continue ;
28757: GO 28742
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28759: LD_EXP 55
28763: PUSH
28764: LD_VAR 0 2
28768: ARRAY
28769: NOT
28770: PUSH
28771: LD_EXP 57
28775: PUSH
28776: LD_VAR 0 2
28780: ARRAY
28781: NOT
28782: AND
28783: PUSH
28784: LD_EXP 56
28788: PUSH
28789: LD_VAR 0 2
28793: ARRAY
28794: AND
28795: IFFALSE 28833
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28797: LD_ADDR_EXP 56
28801: PUSH
28802: LD_EXP 56
28806: PPUSH
28807: LD_VAR 0 2
28811: PPUSH
28812: EMPTY
28813: PPUSH
28814: CALL_OW 1
28818: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28819: LD_VAR 0 2
28823: PPUSH
28824: LD_INT 103
28826: PPUSH
28827: CALL 22426 0 2
// continue ;
28831: GO 28742
// end ; if mc_construct_list [ i ] then
28833: LD_EXP 57
28837: PUSH
28838: LD_VAR 0 2
28842: ARRAY
28843: IFFALSE 29063
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28845: LD_ADDR_VAR 0 5
28849: PUSH
28850: LD_EXP 50
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: PPUSH
28861: LD_INT 25
28863: PUSH
28864: LD_INT 2
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PPUSH
28871: CALL_OW 72
28875: PUSH
28876: LD_EXP 52
28880: PUSH
28881: LD_VAR 0 2
28885: ARRAY
28886: DIFF
28887: ST_TO_ADDR
// if not tmp then
28888: LD_VAR 0 5
28892: NOT
28893: IFFALSE 28897
// continue ;
28895: GO 28742
// for j in tmp do
28897: LD_ADDR_VAR 0 3
28901: PUSH
28902: LD_VAR 0 5
28906: PUSH
28907: FOR_IN
28908: IFFALSE 29059
// begin if not mc_builders [ i ] then
28910: LD_EXP 56
28914: PUSH
28915: LD_VAR 0 2
28919: ARRAY
28920: NOT
28921: IFFALSE 28979
// begin SetTag ( j , 103 ) ;
28923: LD_VAR 0 3
28927: PPUSH
28928: LD_INT 103
28930: PPUSH
28931: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28935: LD_ADDR_EXP 56
28939: PUSH
28940: LD_EXP 56
28944: PPUSH
28945: LD_VAR 0 2
28949: PUSH
28950: LD_EXP 56
28954: PUSH
28955: LD_VAR 0 2
28959: ARRAY
28960: PUSH
28961: LD_INT 1
28963: PLUS
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: LD_VAR 0 3
28973: PPUSH
28974: CALL 54011 0 3
28978: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28979: LD_VAR 0 3
28983: PPUSH
28984: CALL_OW 310
28988: IFFALSE 28999
// ComExitBuilding ( j ) ;
28990: LD_VAR 0 3
28994: PPUSH
28995: CALL_OW 122
// wait ( 3 ) ;
28999: LD_INT 3
29001: PPUSH
29002: CALL_OW 67
// if not mc_construct_list [ i ] then
29006: LD_EXP 57
29010: PUSH
29011: LD_VAR 0 2
29015: ARRAY
29016: NOT
29017: IFFALSE 29021
// break ;
29019: GO 29059
// if not HasTask ( j ) then
29021: LD_VAR 0 3
29025: PPUSH
29026: CALL_OW 314
29030: NOT
29031: IFFALSE 29057
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29033: LD_VAR 0 3
29037: PPUSH
29038: LD_EXP 57
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: PUSH
29049: LD_INT 1
29051: ARRAY
29052: PPUSH
29053: CALL 57249 0 2
// end ;
29057: GO 28907
29059: POP
29060: POP
// end else
29061: GO 29886
// if mc_build_list [ i ] then
29063: LD_EXP 55
29067: PUSH
29068: LD_VAR 0 2
29072: ARRAY
29073: IFFALSE 29886
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29075: LD_EXP 55
29079: PUSH
29080: LD_VAR 0 2
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: PUSH
29090: LD_INT 1
29092: ARRAY
29093: PPUSH
29094: CALL 57073 0 1
29098: PUSH
29099: LD_EXP 50
29103: PUSH
29104: LD_VAR 0 2
29108: ARRAY
29109: PPUSH
29110: LD_INT 2
29112: PUSH
29113: LD_INT 30
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: PUSH
29123: LD_INT 30
29125: PUSH
29126: LD_INT 3
29128: PUSH
29129: EMPTY
29130: LIST
29131: LIST
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: LIST
29137: PPUSH
29138: CALL_OW 72
29142: NOT
29143: AND
29144: IFFALSE 29249
// begin for j = 1 to mc_build_list [ i ] do
29146: LD_ADDR_VAR 0 3
29150: PUSH
29151: DOUBLE
29152: LD_INT 1
29154: DEC
29155: ST_TO_ADDR
29156: LD_EXP 55
29160: PUSH
29161: LD_VAR 0 2
29165: ARRAY
29166: PUSH
29167: FOR_TO
29168: IFFALSE 29247
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29170: LD_EXP 55
29174: PUSH
29175: LD_VAR 0 2
29179: ARRAY
29180: PUSH
29181: LD_VAR 0 3
29185: ARRAY
29186: PUSH
29187: LD_INT 1
29189: ARRAY
29190: PUSH
29191: LD_INT 2
29193: EQUAL
29194: IFFALSE 29245
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29196: LD_ADDR_EXP 55
29200: PUSH
29201: LD_EXP 55
29205: PPUSH
29206: LD_VAR 0 2
29210: PPUSH
29211: LD_EXP 55
29215: PUSH
29216: LD_VAR 0 2
29220: ARRAY
29221: PPUSH
29222: LD_VAR 0 3
29226: PPUSH
29227: LD_INT 1
29229: PPUSH
29230: LD_INT 0
29232: PPUSH
29233: CALL 53429 0 4
29237: PPUSH
29238: CALL_OW 1
29242: ST_TO_ADDR
// break ;
29243: GO 29247
// end ;
29245: GO 29167
29247: POP
29248: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29249: LD_ADDR_VAR 0 6
29253: PUSH
29254: LD_EXP 50
29258: PUSH
29259: LD_VAR 0 2
29263: ARRAY
29264: PPUSH
29265: LD_INT 2
29267: PUSH
29268: LD_INT 30
29270: PUSH
29271: LD_INT 0
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 30
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: LIST
29292: PPUSH
29293: CALL_OW 72
29297: ST_TO_ADDR
// for k := 1 to depot do
29298: LD_ADDR_VAR 0 4
29302: PUSH
29303: DOUBLE
29304: LD_INT 1
29306: DEC
29307: ST_TO_ADDR
29308: LD_VAR 0 6
29312: PUSH
29313: FOR_TO
29314: IFFALSE 29884
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29316: LD_EXP 55
29320: PUSH
29321: LD_VAR 0 2
29325: ARRAY
29326: PUSH
29327: LD_INT 1
29329: ARRAY
29330: PUSH
29331: LD_INT 1
29333: ARRAY
29334: PUSH
29335: LD_INT 0
29337: EQUAL
29338: PUSH
29339: LD_VAR 0 6
29343: PUSH
29344: LD_VAR 0 4
29348: ARRAY
29349: PPUSH
29350: LD_EXP 55
29354: PUSH
29355: LD_VAR 0 2
29359: ARRAY
29360: PUSH
29361: LD_INT 1
29363: ARRAY
29364: PUSH
29365: LD_INT 1
29367: ARRAY
29368: PPUSH
29369: LD_EXP 55
29373: PUSH
29374: LD_VAR 0 2
29378: ARRAY
29379: PUSH
29380: LD_INT 1
29382: ARRAY
29383: PUSH
29384: LD_INT 2
29386: ARRAY
29387: PPUSH
29388: LD_EXP 55
29392: PUSH
29393: LD_VAR 0 2
29397: ARRAY
29398: PUSH
29399: LD_INT 1
29401: ARRAY
29402: PUSH
29403: LD_INT 3
29405: ARRAY
29406: PPUSH
29407: LD_EXP 55
29411: PUSH
29412: LD_VAR 0 2
29416: ARRAY
29417: PUSH
29418: LD_INT 1
29420: ARRAY
29421: PUSH
29422: LD_INT 4
29424: ARRAY
29425: PPUSH
29426: CALL 62485 0 5
29430: OR
29431: IFFALSE 29712
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29433: LD_ADDR_VAR 0 5
29437: PUSH
29438: LD_EXP 50
29442: PUSH
29443: LD_VAR 0 2
29447: ARRAY
29448: PPUSH
29449: LD_INT 25
29451: PUSH
29452: LD_INT 2
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PPUSH
29459: CALL_OW 72
29463: PUSH
29464: LD_EXP 52
29468: PUSH
29469: LD_VAR 0 2
29473: ARRAY
29474: DIFF
29475: ST_TO_ADDR
// if not tmp then
29476: LD_VAR 0 5
29480: NOT
29481: IFFALSE 29485
// continue ;
29483: GO 29313
// for j in tmp do
29485: LD_ADDR_VAR 0 3
29489: PUSH
29490: LD_VAR 0 5
29494: PUSH
29495: FOR_IN
29496: IFFALSE 29708
// begin if not mc_builders [ i ] then
29498: LD_EXP 56
29502: PUSH
29503: LD_VAR 0 2
29507: ARRAY
29508: NOT
29509: IFFALSE 29567
// begin SetTag ( j , 103 ) ;
29511: LD_VAR 0 3
29515: PPUSH
29516: LD_INT 103
29518: PPUSH
29519: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29523: LD_ADDR_EXP 56
29527: PUSH
29528: LD_EXP 56
29532: PPUSH
29533: LD_VAR 0 2
29537: PUSH
29538: LD_EXP 56
29542: PUSH
29543: LD_VAR 0 2
29547: ARRAY
29548: PUSH
29549: LD_INT 1
29551: PLUS
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PPUSH
29557: LD_VAR 0 3
29561: PPUSH
29562: CALL 54011 0 3
29566: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29567: LD_VAR 0 3
29571: PPUSH
29572: CALL_OW 310
29576: IFFALSE 29587
// ComExitBuilding ( j ) ;
29578: LD_VAR 0 3
29582: PPUSH
29583: CALL_OW 122
// wait ( 3 ) ;
29587: LD_INT 3
29589: PPUSH
29590: CALL_OW 67
// if not mc_build_list [ i ] then
29594: LD_EXP 55
29598: PUSH
29599: LD_VAR 0 2
29603: ARRAY
29604: NOT
29605: IFFALSE 29609
// break ;
29607: GO 29708
// if not HasTask ( j ) then
29609: LD_VAR 0 3
29613: PPUSH
29614: CALL_OW 314
29618: NOT
29619: IFFALSE 29706
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29621: LD_VAR 0 3
29625: PPUSH
29626: LD_EXP 55
29630: PUSH
29631: LD_VAR 0 2
29635: ARRAY
29636: PUSH
29637: LD_INT 1
29639: ARRAY
29640: PUSH
29641: LD_INT 1
29643: ARRAY
29644: PPUSH
29645: LD_EXP 55
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: PUSH
29656: LD_INT 1
29658: ARRAY
29659: PUSH
29660: LD_INT 2
29662: ARRAY
29663: PPUSH
29664: LD_EXP 55
29668: PUSH
29669: LD_VAR 0 2
29673: ARRAY
29674: PUSH
29675: LD_INT 1
29677: ARRAY
29678: PUSH
29679: LD_INT 3
29681: ARRAY
29682: PPUSH
29683: LD_EXP 55
29687: PUSH
29688: LD_VAR 0 2
29692: ARRAY
29693: PUSH
29694: LD_INT 1
29696: ARRAY
29697: PUSH
29698: LD_INT 4
29700: ARRAY
29701: PPUSH
29702: CALL_OW 145
// end ;
29706: GO 29495
29708: POP
29709: POP
// end else
29710: GO 29882
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29712: LD_EXP 50
29716: PUSH
29717: LD_VAR 0 2
29721: ARRAY
29722: PPUSH
29723: LD_EXP 55
29727: PUSH
29728: LD_VAR 0 2
29732: ARRAY
29733: PUSH
29734: LD_INT 1
29736: ARRAY
29737: PUSH
29738: LD_INT 1
29740: ARRAY
29741: PPUSH
29742: LD_EXP 55
29746: PUSH
29747: LD_VAR 0 2
29751: ARRAY
29752: PUSH
29753: LD_INT 1
29755: ARRAY
29756: PUSH
29757: LD_INT 2
29759: ARRAY
29760: PPUSH
29761: LD_EXP 55
29765: PUSH
29766: LD_VAR 0 2
29770: ARRAY
29771: PUSH
29772: LD_INT 1
29774: ARRAY
29775: PUSH
29776: LD_INT 3
29778: ARRAY
29779: PPUSH
29780: LD_EXP 55
29784: PUSH
29785: LD_VAR 0 2
29789: ARRAY
29790: PUSH
29791: LD_INT 1
29793: ARRAY
29794: PUSH
29795: LD_INT 4
29797: ARRAY
29798: PPUSH
29799: LD_EXP 50
29803: PUSH
29804: LD_VAR 0 2
29808: ARRAY
29809: PPUSH
29810: LD_INT 21
29812: PUSH
29813: LD_INT 3
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PPUSH
29820: CALL_OW 72
29824: PPUSH
29825: EMPTY
29826: PPUSH
29827: CALL 61239 0 7
29831: NOT
29832: IFFALSE 29882
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29834: LD_ADDR_EXP 55
29838: PUSH
29839: LD_EXP 55
29843: PPUSH
29844: LD_VAR 0 2
29848: PPUSH
29849: LD_EXP 55
29853: PUSH
29854: LD_VAR 0 2
29858: ARRAY
29859: PPUSH
29860: LD_INT 1
29862: PPUSH
29863: LD_INT 1
29865: NEG
29866: PPUSH
29867: LD_INT 0
29869: PPUSH
29870: CALL 53429 0 4
29874: PPUSH
29875: CALL_OW 1
29879: ST_TO_ADDR
// continue ;
29880: GO 29313
// end ; end ;
29882: GO 29313
29884: POP
29885: POP
// end ; end ;
29886: GO 28742
29888: POP
29889: POP
// end ;
29890: LD_VAR 0 1
29894: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29895: LD_INT 0
29897: PPUSH
29898: PPUSH
29899: PPUSH
29900: PPUSH
29901: PPUSH
29902: PPUSH
// if not mc_bases then
29903: LD_EXP 50
29907: NOT
29908: IFFALSE 29912
// exit ;
29910: GO 30339
// for i = 1 to mc_bases do
29912: LD_ADDR_VAR 0 2
29916: PUSH
29917: DOUBLE
29918: LD_INT 1
29920: DEC
29921: ST_TO_ADDR
29922: LD_EXP 50
29926: PUSH
29927: FOR_TO
29928: IFFALSE 30337
// begin tmp := mc_build_upgrade [ i ] ;
29930: LD_ADDR_VAR 0 4
29934: PUSH
29935: LD_EXP 82
29939: PUSH
29940: LD_VAR 0 2
29944: ARRAY
29945: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29946: LD_ADDR_VAR 0 6
29950: PUSH
29951: LD_EXP 83
29955: PUSH
29956: LD_VAR 0 2
29960: ARRAY
29961: PPUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 30
29967: PUSH
29968: LD_INT 6
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 30
29977: PUSH
29978: LD_INT 7
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 72
29994: ST_TO_ADDR
// if not tmp and not lab then
29995: LD_VAR 0 4
29999: NOT
30000: PUSH
30001: LD_VAR 0 6
30005: NOT
30006: AND
30007: IFFALSE 30011
// continue ;
30009: GO 29927
// if tmp then
30011: LD_VAR 0 4
30015: IFFALSE 30135
// for j in tmp do
30017: LD_ADDR_VAR 0 3
30021: PUSH
30022: LD_VAR 0 4
30026: PUSH
30027: FOR_IN
30028: IFFALSE 30133
// begin if UpgradeCost ( j ) then
30030: LD_VAR 0 3
30034: PPUSH
30035: CALL 60899 0 1
30039: IFFALSE 30131
// begin ComUpgrade ( j ) ;
30041: LD_VAR 0 3
30045: PPUSH
30046: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30050: LD_ADDR_EXP 82
30054: PUSH
30055: LD_EXP 82
30059: PPUSH
30060: LD_VAR 0 2
30064: PPUSH
30065: LD_EXP 82
30069: PUSH
30070: LD_VAR 0 2
30074: ARRAY
30075: PUSH
30076: LD_VAR 0 3
30080: DIFF
30081: PPUSH
30082: CALL_OW 1
30086: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30087: LD_ADDR_EXP 57
30091: PUSH
30092: LD_EXP 57
30096: PPUSH
30097: LD_VAR 0 2
30101: PUSH
30102: LD_EXP 57
30106: PUSH
30107: LD_VAR 0 2
30111: ARRAY
30112: PUSH
30113: LD_INT 1
30115: PLUS
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PPUSH
30121: LD_VAR 0 3
30125: PPUSH
30126: CALL 54011 0 3
30130: ST_TO_ADDR
// end ; end ;
30131: GO 30027
30133: POP
30134: POP
// if not lab or not mc_lab_upgrade [ i ] then
30135: LD_VAR 0 6
30139: NOT
30140: PUSH
30141: LD_EXP 84
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: NOT
30152: OR
30153: IFFALSE 30157
// continue ;
30155: GO 29927
// for j in lab do
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_VAR 0 6
30166: PUSH
30167: FOR_IN
30168: IFFALSE 30333
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30170: LD_VAR 0 3
30174: PPUSH
30175: CALL_OW 266
30179: PUSH
30180: LD_INT 6
30182: PUSH
30183: LD_INT 7
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: IN
30190: PUSH
30191: LD_VAR 0 3
30195: PPUSH
30196: CALL_OW 461
30200: PUSH
30201: LD_INT 1
30203: NONEQUAL
30204: AND
30205: IFFALSE 30331
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30207: LD_VAR 0 3
30211: PPUSH
30212: LD_EXP 84
30216: PUSH
30217: LD_VAR 0 2
30221: ARRAY
30222: PUSH
30223: LD_INT 1
30225: ARRAY
30226: PPUSH
30227: CALL 61104 0 2
30231: IFFALSE 30331
// begin ComCancel ( j ) ;
30233: LD_VAR 0 3
30237: PPUSH
30238: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30242: LD_VAR 0 3
30246: PPUSH
30247: LD_EXP 84
30251: PUSH
30252: LD_VAR 0 2
30256: ARRAY
30257: PUSH
30258: LD_INT 1
30260: ARRAY
30261: PPUSH
30262: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30266: LD_VAR 0 3
30270: PUSH
30271: LD_EXP 57
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: IN
30282: NOT
30283: IFFALSE 30329
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30285: LD_ADDR_EXP 57
30289: PUSH
30290: LD_EXP 57
30294: PPUSH
30295: LD_VAR 0 2
30299: PUSH
30300: LD_EXP 57
30304: PUSH
30305: LD_VAR 0 2
30309: ARRAY
30310: PUSH
30311: LD_INT 1
30313: PLUS
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PPUSH
30319: LD_VAR 0 3
30323: PPUSH
30324: CALL 54011 0 3
30328: ST_TO_ADDR
// break ;
30329: GO 30333
// end ; end ; end ;
30331: GO 30167
30333: POP
30334: POP
// end ;
30335: GO 29927
30337: POP
30338: POP
// end ;
30339: LD_VAR 0 1
30343: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30344: LD_INT 0
30346: PPUSH
30347: PPUSH
30348: PPUSH
30349: PPUSH
30350: PPUSH
30351: PPUSH
30352: PPUSH
30353: PPUSH
30354: PPUSH
// if not mc_bases then
30355: LD_EXP 50
30359: NOT
30360: IFFALSE 30364
// exit ;
30362: GO 30769
// for i = 1 to mc_bases do
30364: LD_ADDR_VAR 0 2
30368: PUSH
30369: DOUBLE
30370: LD_INT 1
30372: DEC
30373: ST_TO_ADDR
30374: LD_EXP 50
30378: PUSH
30379: FOR_TO
30380: IFFALSE 30767
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30382: LD_EXP 58
30386: PUSH
30387: LD_VAR 0 2
30391: ARRAY
30392: NOT
30393: PUSH
30394: LD_EXP 50
30398: PUSH
30399: LD_VAR 0 2
30403: ARRAY
30404: PPUSH
30405: LD_INT 30
30407: PUSH
30408: LD_INT 3
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PPUSH
30415: CALL_OW 72
30419: NOT
30420: OR
30421: IFFALSE 30425
// continue ;
30423: GO 30379
// busy := false ;
30425: LD_ADDR_VAR 0 8
30429: PUSH
30430: LD_INT 0
30432: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30433: LD_ADDR_VAR 0 4
30437: PUSH
30438: LD_EXP 50
30442: PUSH
30443: LD_VAR 0 2
30447: ARRAY
30448: PPUSH
30449: LD_INT 30
30451: PUSH
30452: LD_INT 3
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: CALL_OW 72
30463: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30464: LD_ADDR_VAR 0 6
30468: PUSH
30469: LD_EXP 58
30473: PUSH
30474: LD_VAR 0 2
30478: ARRAY
30479: PPUSH
30480: LD_INT 2
30482: PUSH
30483: LD_INT 30
30485: PUSH
30486: LD_INT 32
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 30
30495: PUSH
30496: LD_INT 33
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: LIST
30507: PPUSH
30508: CALL_OW 72
30512: ST_TO_ADDR
// if not t then
30513: LD_VAR 0 6
30517: NOT
30518: IFFALSE 30522
// continue ;
30520: GO 30379
// for j in tmp do
30522: LD_ADDR_VAR 0 3
30526: PUSH
30527: LD_VAR 0 4
30531: PUSH
30532: FOR_IN
30533: IFFALSE 30563
// if not BuildingStatus ( j ) = bs_idle then
30535: LD_VAR 0 3
30539: PPUSH
30540: CALL_OW 461
30544: PUSH
30545: LD_INT 2
30547: EQUAL
30548: NOT
30549: IFFALSE 30561
// begin busy := true ;
30551: LD_ADDR_VAR 0 8
30555: PUSH
30556: LD_INT 1
30558: ST_TO_ADDR
// break ;
30559: GO 30563
// end ;
30561: GO 30532
30563: POP
30564: POP
// if busy then
30565: LD_VAR 0 8
30569: IFFALSE 30573
// continue ;
30571: GO 30379
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30573: LD_ADDR_VAR 0 7
30577: PUSH
30578: LD_VAR 0 6
30582: PPUSH
30583: LD_INT 35
30585: PUSH
30586: LD_INT 0
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PPUSH
30593: CALL_OW 72
30597: ST_TO_ADDR
// if tw then
30598: LD_VAR 0 7
30602: IFFALSE 30679
// begin tw := tw [ 1 ] ;
30604: LD_ADDR_VAR 0 7
30608: PUSH
30609: LD_VAR 0 7
30613: PUSH
30614: LD_INT 1
30616: ARRAY
30617: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30618: LD_ADDR_VAR 0 9
30622: PUSH
30623: LD_VAR 0 7
30627: PPUSH
30628: LD_EXP 75
30632: PUSH
30633: LD_VAR 0 2
30637: ARRAY
30638: PPUSH
30639: CALL 59396 0 2
30643: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30644: LD_EXP 89
30648: PUSH
30649: LD_VAR 0 2
30653: ARRAY
30654: IFFALSE 30677
// if not weapon in mc_allowed_tower_weapons [ i ] then
30656: LD_VAR 0 9
30660: PUSH
30661: LD_EXP 89
30665: PUSH
30666: LD_VAR 0 2
30670: ARRAY
30671: IN
30672: NOT
30673: IFFALSE 30677
// continue ;
30675: GO 30379
// end else
30677: GO 30742
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30679: LD_ADDR_VAR 0 5
30683: PUSH
30684: LD_EXP 58
30688: PUSH
30689: LD_VAR 0 2
30693: ARRAY
30694: PPUSH
30695: LD_VAR 0 4
30699: PPUSH
30700: CALL 86308 0 2
30704: ST_TO_ADDR
// if not tmp2 then
30705: LD_VAR 0 5
30709: NOT
30710: IFFALSE 30714
// continue ;
30712: GO 30379
// tw := tmp2 [ 1 ] ;
30714: LD_ADDR_VAR 0 7
30718: PUSH
30719: LD_VAR 0 5
30723: PUSH
30724: LD_INT 1
30726: ARRAY
30727: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30728: LD_ADDR_VAR 0 9
30732: PUSH
30733: LD_VAR 0 5
30737: PUSH
30738: LD_INT 2
30740: ARRAY
30741: ST_TO_ADDR
// end ; if not weapon then
30742: LD_VAR 0 9
30746: NOT
30747: IFFALSE 30751
// continue ;
30749: GO 30379
// ComPlaceWeapon ( tw , weapon ) ;
30751: LD_VAR 0 7
30755: PPUSH
30756: LD_VAR 0 9
30760: PPUSH
30761: CALL_OW 148
// end ;
30765: GO 30379
30767: POP
30768: POP
// end ;
30769: LD_VAR 0 1
30773: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30774: LD_INT 0
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
// if not mc_bases then
30783: LD_EXP 50
30787: NOT
30788: IFFALSE 30792
// exit ;
30790: GO 31567
// for i = 1 to mc_bases do
30792: LD_ADDR_VAR 0 2
30796: PUSH
30797: DOUBLE
30798: LD_INT 1
30800: DEC
30801: ST_TO_ADDR
30802: LD_EXP 50
30806: PUSH
30807: FOR_TO
30808: IFFALSE 31565
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30810: LD_EXP 63
30814: PUSH
30815: LD_VAR 0 2
30819: ARRAY
30820: NOT
30821: PUSH
30822: LD_EXP 63
30826: PUSH
30827: LD_VAR 0 2
30831: ARRAY
30832: PUSH
30833: LD_EXP 64
30837: PUSH
30838: LD_VAR 0 2
30842: ARRAY
30843: EQUAL
30844: OR
30845: PUSH
30846: LD_EXP 73
30850: PUSH
30851: LD_VAR 0 2
30855: ARRAY
30856: OR
30857: IFFALSE 30861
// continue ;
30859: GO 30807
// if mc_miners [ i ] then
30861: LD_EXP 64
30865: PUSH
30866: LD_VAR 0 2
30870: ARRAY
30871: IFFALSE 31252
// begin for j = mc_miners [ i ] downto 1 do
30873: LD_ADDR_VAR 0 3
30877: PUSH
30878: DOUBLE
30879: LD_EXP 64
30883: PUSH
30884: LD_VAR 0 2
30888: ARRAY
30889: INC
30890: ST_TO_ADDR
30891: LD_INT 1
30893: PUSH
30894: FOR_DOWNTO
30895: IFFALSE 31250
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30897: LD_EXP 64
30901: PUSH
30902: LD_VAR 0 2
30906: ARRAY
30907: PUSH
30908: LD_VAR 0 3
30912: ARRAY
30913: PPUSH
30914: CALL_OW 301
30918: PUSH
30919: LD_EXP 64
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: PUSH
30930: LD_VAR 0 3
30934: ARRAY
30935: PPUSH
30936: CALL_OW 257
30940: PUSH
30941: LD_INT 1
30943: NONEQUAL
30944: OR
30945: IFFALSE 31008
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30947: LD_ADDR_VAR 0 5
30951: PUSH
30952: LD_EXP 64
30956: PUSH
30957: LD_VAR 0 2
30961: ARRAY
30962: PUSH
30963: LD_EXP 64
30967: PUSH
30968: LD_VAR 0 2
30972: ARRAY
30973: PUSH
30974: LD_VAR 0 3
30978: ARRAY
30979: DIFF
30980: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30981: LD_ADDR_EXP 64
30985: PUSH
30986: LD_EXP 64
30990: PPUSH
30991: LD_VAR 0 2
30995: PPUSH
30996: LD_VAR 0 5
31000: PPUSH
31001: CALL_OW 1
31005: ST_TO_ADDR
// continue ;
31006: GO 30894
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31008: LD_EXP 64
31012: PUSH
31013: LD_VAR 0 2
31017: ARRAY
31018: PUSH
31019: LD_VAR 0 3
31023: ARRAY
31024: PPUSH
31025: CALL_OW 257
31029: PUSH
31030: LD_INT 1
31032: EQUAL
31033: PUSH
31034: LD_EXP 64
31038: PUSH
31039: LD_VAR 0 2
31043: ARRAY
31044: PUSH
31045: LD_VAR 0 3
31049: ARRAY
31050: PPUSH
31051: CALL_OW 459
31055: NOT
31056: AND
31057: PUSH
31058: LD_EXP 64
31062: PUSH
31063: LD_VAR 0 2
31067: ARRAY
31068: PUSH
31069: LD_VAR 0 3
31073: ARRAY
31074: PPUSH
31075: CALL_OW 314
31079: NOT
31080: AND
31081: IFFALSE 31248
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31083: LD_EXP 64
31087: PUSH
31088: LD_VAR 0 2
31092: ARRAY
31093: PUSH
31094: LD_VAR 0 3
31098: ARRAY
31099: PPUSH
31100: CALL_OW 310
31104: IFFALSE 31127
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31106: LD_EXP 64
31110: PUSH
31111: LD_VAR 0 2
31115: ARRAY
31116: PUSH
31117: LD_VAR 0 3
31121: ARRAY
31122: PPUSH
31123: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31127: LD_EXP 64
31131: PUSH
31132: LD_VAR 0 2
31136: ARRAY
31137: PUSH
31138: LD_VAR 0 3
31142: ARRAY
31143: PPUSH
31144: CALL_OW 314
31148: NOT
31149: IFFALSE 31248
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31151: LD_ADDR_VAR 0 7
31155: PUSH
31156: LD_VAR 0 3
31160: PUSH
31161: LD_EXP 63
31165: PUSH
31166: LD_VAR 0 2
31170: ARRAY
31171: PPUSH
31172: CALL 51151 0 1
31176: MOD
31177: PUSH
31178: LD_INT 1
31180: PLUS
31181: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31182: LD_EXP 64
31186: PUSH
31187: LD_VAR 0 2
31191: ARRAY
31192: PUSH
31193: LD_VAR 0 3
31197: ARRAY
31198: PPUSH
31199: LD_EXP 63
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PUSH
31210: LD_VAR 0 7
31214: ARRAY
31215: PUSH
31216: LD_INT 1
31218: ARRAY
31219: PPUSH
31220: LD_EXP 63
31224: PUSH
31225: LD_VAR 0 2
31229: ARRAY
31230: PUSH
31231: LD_VAR 0 7
31235: ARRAY
31236: PUSH
31237: LD_INT 2
31239: ARRAY
31240: PPUSH
31241: LD_INT 0
31243: PPUSH
31244: CALL_OW 193
// end ; end ; end ;
31248: GO 30894
31250: POP
31251: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31252: LD_ADDR_VAR 0 5
31256: PUSH
31257: LD_EXP 50
31261: PUSH
31262: LD_VAR 0 2
31266: ARRAY
31267: PPUSH
31268: LD_INT 2
31270: PUSH
31271: LD_INT 30
31273: PUSH
31274: LD_INT 4
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 30
31283: PUSH
31284: LD_INT 5
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 30
31293: PUSH
31294: LD_INT 32
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: PPUSH
31307: CALL_OW 72
31311: ST_TO_ADDR
// if not tmp then
31312: LD_VAR 0 5
31316: NOT
31317: IFFALSE 31321
// continue ;
31319: GO 30807
// list := [ ] ;
31321: LD_ADDR_VAR 0 6
31325: PUSH
31326: EMPTY
31327: ST_TO_ADDR
// for j in tmp do
31328: LD_ADDR_VAR 0 3
31332: PUSH
31333: LD_VAR 0 5
31337: PUSH
31338: FOR_IN
31339: IFFALSE 31408
// begin for k in UnitsInside ( j ) do
31341: LD_ADDR_VAR 0 4
31345: PUSH
31346: LD_VAR 0 3
31350: PPUSH
31351: CALL_OW 313
31355: PUSH
31356: FOR_IN
31357: IFFALSE 31404
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31359: LD_VAR 0 4
31363: PPUSH
31364: CALL_OW 257
31368: PUSH
31369: LD_INT 1
31371: EQUAL
31372: PUSH
31373: LD_VAR 0 4
31377: PPUSH
31378: CALL_OW 459
31382: NOT
31383: AND
31384: IFFALSE 31402
// list := list ^ k ;
31386: LD_ADDR_VAR 0 6
31390: PUSH
31391: LD_VAR 0 6
31395: PUSH
31396: LD_VAR 0 4
31400: ADD
31401: ST_TO_ADDR
31402: GO 31356
31404: POP
31405: POP
// end ;
31406: GO 31338
31408: POP
31409: POP
// list := list diff mc_miners [ i ] ;
31410: LD_ADDR_VAR 0 6
31414: PUSH
31415: LD_VAR 0 6
31419: PUSH
31420: LD_EXP 64
31424: PUSH
31425: LD_VAR 0 2
31429: ARRAY
31430: DIFF
31431: ST_TO_ADDR
// if not list then
31432: LD_VAR 0 6
31436: NOT
31437: IFFALSE 31441
// continue ;
31439: GO 30807
// k := mc_mines [ i ] - mc_miners [ i ] ;
31441: LD_ADDR_VAR 0 4
31445: PUSH
31446: LD_EXP 63
31450: PUSH
31451: LD_VAR 0 2
31455: ARRAY
31456: PUSH
31457: LD_EXP 64
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: MINUS
31468: ST_TO_ADDR
// if k > list then
31469: LD_VAR 0 4
31473: PUSH
31474: LD_VAR 0 6
31478: GREATER
31479: IFFALSE 31491
// k := list ;
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: LD_VAR 0 6
31490: ST_TO_ADDR
// for j = 1 to k do
31491: LD_ADDR_VAR 0 3
31495: PUSH
31496: DOUBLE
31497: LD_INT 1
31499: DEC
31500: ST_TO_ADDR
31501: LD_VAR 0 4
31505: PUSH
31506: FOR_TO
31507: IFFALSE 31561
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31509: LD_ADDR_EXP 64
31513: PUSH
31514: LD_EXP 64
31518: PPUSH
31519: LD_VAR 0 2
31523: PUSH
31524: LD_EXP 64
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: PUSH
31535: LD_INT 1
31537: PLUS
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PPUSH
31543: LD_VAR 0 6
31547: PUSH
31548: LD_VAR 0 3
31552: ARRAY
31553: PPUSH
31554: CALL 54011 0 3
31558: ST_TO_ADDR
31559: GO 31506
31561: POP
31562: POP
// end ;
31563: GO 30807
31565: POP
31566: POP
// end ;
31567: LD_VAR 0 1
31571: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31572: LD_INT 0
31574: PPUSH
31575: PPUSH
31576: PPUSH
31577: PPUSH
31578: PPUSH
31579: PPUSH
31580: PPUSH
31581: PPUSH
31582: PPUSH
31583: PPUSH
31584: PPUSH
// if not mc_bases then
31585: LD_EXP 50
31589: NOT
31590: IFFALSE 31594
// exit ;
31592: GO 33417
// for i = 1 to mc_bases do
31594: LD_ADDR_VAR 0 2
31598: PUSH
31599: DOUBLE
31600: LD_INT 1
31602: DEC
31603: ST_TO_ADDR
31604: LD_EXP 50
31608: PUSH
31609: FOR_TO
31610: IFFALSE 33415
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31612: LD_EXP 50
31616: PUSH
31617: LD_VAR 0 2
31621: ARRAY
31622: NOT
31623: PUSH
31624: LD_EXP 57
31628: PUSH
31629: LD_VAR 0 2
31633: ARRAY
31634: OR
31635: IFFALSE 31639
// continue ;
31637: GO 31609
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31639: LD_EXP 66
31643: PUSH
31644: LD_VAR 0 2
31648: ARRAY
31649: NOT
31650: PUSH
31651: LD_EXP 67
31655: PUSH
31656: LD_VAR 0 2
31660: ARRAY
31661: AND
31662: IFFALSE 31700
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31664: LD_ADDR_EXP 67
31668: PUSH
31669: LD_EXP 67
31673: PPUSH
31674: LD_VAR 0 2
31678: PPUSH
31679: EMPTY
31680: PPUSH
31681: CALL_OW 1
31685: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31686: LD_VAR 0 2
31690: PPUSH
31691: LD_INT 107
31693: PPUSH
31694: CALL 22426 0 2
// continue ;
31698: GO 31609
// end ; target := [ ] ;
31700: LD_ADDR_VAR 0 7
31704: PUSH
31705: EMPTY
31706: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31707: LD_ADDR_VAR 0 6
31711: PUSH
31712: LD_EXP 50
31716: PUSH
31717: LD_VAR 0 2
31721: ARRAY
31722: PUSH
31723: LD_INT 1
31725: ARRAY
31726: PPUSH
31727: CALL_OW 255
31731: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31732: LD_ADDR_VAR 0 9
31736: PUSH
31737: LD_EXP 50
31741: PUSH
31742: LD_VAR 0 2
31746: ARRAY
31747: PPUSH
31748: LD_INT 2
31750: PUSH
31751: LD_INT 30
31753: PUSH
31754: LD_INT 0
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 30
31763: PUSH
31764: LD_INT 1
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: LIST
31775: PPUSH
31776: CALL_OW 72
31780: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31781: LD_ADDR_VAR 0 3
31785: PUSH
31786: DOUBLE
31787: LD_EXP 66
31791: PUSH
31792: LD_VAR 0 2
31796: ARRAY
31797: INC
31798: ST_TO_ADDR
31799: LD_INT 1
31801: PUSH
31802: FOR_DOWNTO
31803: IFFALSE 32048
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31805: LD_EXP 66
31809: PUSH
31810: LD_VAR 0 2
31814: ARRAY
31815: PUSH
31816: LD_VAR 0 3
31820: ARRAY
31821: PUSH
31822: LD_INT 2
31824: ARRAY
31825: PPUSH
31826: LD_EXP 66
31830: PUSH
31831: LD_VAR 0 2
31835: ARRAY
31836: PUSH
31837: LD_VAR 0 3
31841: ARRAY
31842: PUSH
31843: LD_INT 3
31845: ARRAY
31846: PPUSH
31847: CALL_OW 488
31851: PUSH
31852: LD_EXP 66
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: PUSH
31863: LD_VAR 0 3
31867: ARRAY
31868: PUSH
31869: LD_INT 2
31871: ARRAY
31872: PPUSH
31873: LD_EXP 66
31877: PUSH
31878: LD_VAR 0 2
31882: ARRAY
31883: PUSH
31884: LD_VAR 0 3
31888: ARRAY
31889: PUSH
31890: LD_INT 3
31892: ARRAY
31893: PPUSH
31894: CALL_OW 284
31898: PUSH
31899: LD_INT 0
31901: EQUAL
31902: AND
31903: IFFALSE 31958
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31905: LD_ADDR_VAR 0 5
31909: PUSH
31910: LD_EXP 66
31914: PUSH
31915: LD_VAR 0 2
31919: ARRAY
31920: PPUSH
31921: LD_VAR 0 3
31925: PPUSH
31926: CALL_OW 3
31930: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31931: LD_ADDR_EXP 66
31935: PUSH
31936: LD_EXP 66
31940: PPUSH
31941: LD_VAR 0 2
31945: PPUSH
31946: LD_VAR 0 5
31950: PPUSH
31951: CALL_OW 1
31955: ST_TO_ADDR
// continue ;
31956: GO 31802
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31958: LD_VAR 0 6
31962: PPUSH
31963: LD_EXP 66
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: PUSH
31974: LD_VAR 0 3
31978: ARRAY
31979: PUSH
31980: LD_INT 2
31982: ARRAY
31983: PPUSH
31984: LD_EXP 66
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_VAR 0 3
31999: ARRAY
32000: PUSH
32001: LD_INT 3
32003: ARRAY
32004: PPUSH
32005: LD_INT 30
32007: PPUSH
32008: CALL 55275 0 4
32012: PUSH
32013: LD_INT 4
32015: ARRAY
32016: PUSH
32017: LD_INT 0
32019: EQUAL
32020: IFFALSE 32046
// begin target := mc_crates [ i ] [ j ] ;
32022: LD_ADDR_VAR 0 7
32026: PUSH
32027: LD_EXP 66
32031: PUSH
32032: LD_VAR 0 2
32036: ARRAY
32037: PUSH
32038: LD_VAR 0 3
32042: ARRAY
32043: ST_TO_ADDR
// break ;
32044: GO 32048
// end ; end ;
32046: GO 31802
32048: POP
32049: POP
// if not target then
32050: LD_VAR 0 7
32054: NOT
32055: IFFALSE 32059
// continue ;
32057: GO 31609
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32059: LD_ADDR_VAR 0 8
32063: PUSH
32064: LD_EXP 69
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PPUSH
32075: LD_INT 2
32077: PUSH
32078: LD_INT 3
32080: PUSH
32081: LD_INT 58
32083: PUSH
32084: EMPTY
32085: LIST
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 61
32093: PUSH
32094: EMPTY
32095: LIST
32096: PUSH
32097: LD_INT 33
32099: PUSH
32100: LD_INT 5
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 33
32109: PUSH
32110: LD_INT 3
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 2
32126: PUSH
32127: LD_INT 34
32129: PUSH
32130: LD_INT 32
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 34
32139: PUSH
32140: LD_INT 51
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 34
32149: PUSH
32150: LD_INT 12
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PPUSH
32167: CALL_OW 72
32171: ST_TO_ADDR
// if not cargo then
32172: LD_VAR 0 8
32176: NOT
32177: IFFALSE 32883
// begin if mc_crates_collector [ i ] < 5 then
32179: LD_EXP 67
32183: PUSH
32184: LD_VAR 0 2
32188: ARRAY
32189: PUSH
32190: LD_INT 5
32192: LESS
32193: IFFALSE 32559
// begin if mc_ape [ i ] then
32195: LD_EXP 79
32199: PUSH
32200: LD_VAR 0 2
32204: ARRAY
32205: IFFALSE 32252
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32207: LD_ADDR_VAR 0 5
32211: PUSH
32212: LD_EXP 79
32216: PUSH
32217: LD_VAR 0 2
32221: ARRAY
32222: PPUSH
32223: LD_INT 25
32225: PUSH
32226: LD_INT 16
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 24
32235: PUSH
32236: LD_INT 750
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PPUSH
32247: CALL_OW 72
32251: ST_TO_ADDR
// if not tmp then
32252: LD_VAR 0 5
32256: NOT
32257: IFFALSE 32304
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32259: LD_ADDR_VAR 0 5
32263: PUSH
32264: LD_EXP 50
32268: PUSH
32269: LD_VAR 0 2
32273: ARRAY
32274: PPUSH
32275: LD_INT 25
32277: PUSH
32278: LD_INT 2
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 24
32287: PUSH
32288: LD_INT 750
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PPUSH
32299: CALL_OW 72
32303: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32304: LD_EXP 79
32308: PUSH
32309: LD_VAR 0 2
32313: ARRAY
32314: PUSH
32315: LD_EXP 50
32319: PUSH
32320: LD_VAR 0 2
32324: ARRAY
32325: PPUSH
32326: LD_INT 25
32328: PUSH
32329: LD_INT 2
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: LD_INT 24
32338: PUSH
32339: LD_INT 750
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PPUSH
32350: CALL_OW 72
32354: AND
32355: PUSH
32356: LD_VAR 0 5
32360: PUSH
32361: LD_INT 5
32363: LESS
32364: AND
32365: IFFALSE 32447
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32367: LD_ADDR_VAR 0 3
32371: PUSH
32372: LD_EXP 50
32376: PUSH
32377: LD_VAR 0 2
32381: ARRAY
32382: PPUSH
32383: LD_INT 25
32385: PUSH
32386: LD_INT 2
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 24
32395: PUSH
32396: LD_INT 750
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PPUSH
32407: CALL_OW 72
32411: PUSH
32412: FOR_IN
32413: IFFALSE 32445
// begin tmp := tmp union j ;
32415: LD_ADDR_VAR 0 5
32419: PUSH
32420: LD_VAR 0 5
32424: PUSH
32425: LD_VAR 0 3
32429: UNION
32430: ST_TO_ADDR
// if tmp >= 5 then
32431: LD_VAR 0 5
32435: PUSH
32436: LD_INT 5
32438: GREATEREQUAL
32439: IFFALSE 32443
// break ;
32441: GO 32445
// end ;
32443: GO 32412
32445: POP
32446: POP
// end ; if not tmp then
32447: LD_VAR 0 5
32451: NOT
32452: IFFALSE 32456
// continue ;
32454: GO 31609
// for j in tmp do
32456: LD_ADDR_VAR 0 3
32460: PUSH
32461: LD_VAR 0 5
32465: PUSH
32466: FOR_IN
32467: IFFALSE 32557
// if not GetTag ( j ) then
32469: LD_VAR 0 3
32473: PPUSH
32474: CALL_OW 110
32478: NOT
32479: IFFALSE 32555
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32481: LD_ADDR_EXP 67
32485: PUSH
32486: LD_EXP 67
32490: PPUSH
32491: LD_VAR 0 2
32495: PUSH
32496: LD_EXP 67
32500: PUSH
32501: LD_VAR 0 2
32505: ARRAY
32506: PUSH
32507: LD_INT 1
32509: PLUS
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PPUSH
32515: LD_VAR 0 3
32519: PPUSH
32520: CALL 54011 0 3
32524: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32525: LD_VAR 0 3
32529: PPUSH
32530: LD_INT 107
32532: PPUSH
32533: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32537: LD_EXP 67
32541: PUSH
32542: LD_VAR 0 2
32546: ARRAY
32547: PUSH
32548: LD_INT 5
32550: GREATEREQUAL
32551: IFFALSE 32555
// break ;
32553: GO 32557
// end ;
32555: GO 32466
32557: POP
32558: POP
// end ; if mc_crates_collector [ i ] and target then
32559: LD_EXP 67
32563: PUSH
32564: LD_VAR 0 2
32568: ARRAY
32569: PUSH
32570: LD_VAR 0 7
32574: AND
32575: IFFALSE 32881
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32577: LD_EXP 67
32581: PUSH
32582: LD_VAR 0 2
32586: ARRAY
32587: PUSH
32588: LD_VAR 0 7
32592: PUSH
32593: LD_INT 1
32595: ARRAY
32596: LESS
32597: IFFALSE 32617
// tmp := mc_crates_collector [ i ] else
32599: LD_ADDR_VAR 0 5
32603: PUSH
32604: LD_EXP 67
32608: PUSH
32609: LD_VAR 0 2
32613: ARRAY
32614: ST_TO_ADDR
32615: GO 32631
// tmp := target [ 1 ] ;
32617: LD_ADDR_VAR 0 5
32621: PUSH
32622: LD_VAR 0 7
32626: PUSH
32627: LD_INT 1
32629: ARRAY
32630: ST_TO_ADDR
// k := 0 ;
32631: LD_ADDR_VAR 0 4
32635: PUSH
32636: LD_INT 0
32638: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32639: LD_ADDR_VAR 0 3
32643: PUSH
32644: LD_EXP 67
32648: PUSH
32649: LD_VAR 0 2
32653: ARRAY
32654: PUSH
32655: FOR_IN
32656: IFFALSE 32879
// begin k := k + 1 ;
32658: LD_ADDR_VAR 0 4
32662: PUSH
32663: LD_VAR 0 4
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: ST_TO_ADDR
// if k > tmp then
32672: LD_VAR 0 4
32676: PUSH
32677: LD_VAR 0 5
32681: GREATER
32682: IFFALSE 32686
// break ;
32684: GO 32879
// if not GetClass ( j ) in [ 2 , 16 ] then
32686: LD_VAR 0 3
32690: PPUSH
32691: CALL_OW 257
32695: PUSH
32696: LD_INT 2
32698: PUSH
32699: LD_INT 16
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: IN
32706: NOT
32707: IFFALSE 32760
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32709: LD_ADDR_EXP 67
32713: PUSH
32714: LD_EXP 67
32718: PPUSH
32719: LD_VAR 0 2
32723: PPUSH
32724: LD_EXP 67
32728: PUSH
32729: LD_VAR 0 2
32733: ARRAY
32734: PUSH
32735: LD_VAR 0 3
32739: DIFF
32740: PPUSH
32741: CALL_OW 1
32745: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32746: LD_VAR 0 3
32750: PPUSH
32751: LD_INT 0
32753: PPUSH
32754: CALL_OW 109
// continue ;
32758: GO 32655
// end ; if IsInUnit ( j ) then
32760: LD_VAR 0 3
32764: PPUSH
32765: CALL_OW 310
32769: IFFALSE 32780
// ComExitBuilding ( j ) ;
32771: LD_VAR 0 3
32775: PPUSH
32776: CALL_OW 122
// wait ( 3 ) ;
32780: LD_INT 3
32782: PPUSH
32783: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32787: LD_VAR 0 3
32791: PPUSH
32792: CALL_OW 314
32796: PUSH
32797: LD_VAR 0 6
32801: PPUSH
32802: LD_VAR 0 7
32806: PUSH
32807: LD_INT 2
32809: ARRAY
32810: PPUSH
32811: LD_VAR 0 7
32815: PUSH
32816: LD_INT 3
32818: ARRAY
32819: PPUSH
32820: LD_INT 30
32822: PPUSH
32823: CALL 55275 0 4
32827: PUSH
32828: LD_INT 4
32830: ARRAY
32831: AND
32832: IFFALSE 32850
// ComStandNearbyBuilding ( j , depot ) else
32834: LD_VAR 0 3
32838: PPUSH
32839: LD_VAR 0 9
32843: PPUSH
32844: CALL 50613 0 2
32848: GO 32877
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32850: LD_VAR 0 3
32854: PPUSH
32855: LD_VAR 0 7
32859: PUSH
32860: LD_INT 2
32862: ARRAY
32863: PPUSH
32864: LD_VAR 0 7
32868: PUSH
32869: LD_INT 3
32871: ARRAY
32872: PPUSH
32873: CALL_OW 117
// end ;
32877: GO 32655
32879: POP
32880: POP
// end ; end else
32881: GO 33413
// begin for j in cargo do
32883: LD_ADDR_VAR 0 3
32887: PUSH
32888: LD_VAR 0 8
32892: PUSH
32893: FOR_IN
32894: IFFALSE 33411
// begin if GetTag ( j ) <> 0 then
32896: LD_VAR 0 3
32900: PPUSH
32901: CALL_OW 110
32905: PUSH
32906: LD_INT 0
32908: NONEQUAL
32909: IFFALSE 32913
// continue ;
32911: GO 32893
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32913: LD_VAR 0 3
32917: PPUSH
32918: CALL_OW 256
32922: PUSH
32923: LD_INT 1000
32925: LESS
32926: PUSH
32927: LD_VAR 0 3
32931: PPUSH
32932: LD_EXP 74
32936: PUSH
32937: LD_VAR 0 2
32941: ARRAY
32942: PPUSH
32943: CALL_OW 308
32947: NOT
32948: AND
32949: IFFALSE 32971
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32951: LD_VAR 0 3
32955: PPUSH
32956: LD_EXP 74
32960: PUSH
32961: LD_VAR 0 2
32965: ARRAY
32966: PPUSH
32967: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32971: LD_VAR 0 3
32975: PPUSH
32976: CALL_OW 256
32980: PUSH
32981: LD_INT 1000
32983: LESS
32984: PUSH
32985: LD_VAR 0 3
32989: PPUSH
32990: LD_EXP 74
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: PPUSH
33001: CALL_OW 308
33005: AND
33006: IFFALSE 33010
// continue ;
33008: GO 32893
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33010: LD_VAR 0 3
33014: PPUSH
33015: CALL_OW 262
33019: PUSH
33020: LD_INT 2
33022: EQUAL
33023: PUSH
33024: LD_VAR 0 3
33028: PPUSH
33029: CALL_OW 261
33033: PUSH
33034: LD_INT 15
33036: LESS
33037: AND
33038: IFFALSE 33042
// continue ;
33040: GO 32893
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33042: LD_VAR 0 3
33046: PPUSH
33047: CALL_OW 262
33051: PUSH
33052: LD_INT 1
33054: EQUAL
33055: PUSH
33056: LD_VAR 0 3
33060: PPUSH
33061: CALL_OW 261
33065: PUSH
33066: LD_INT 10
33068: LESS
33069: AND
33070: IFFALSE 33350
// begin if not depot then
33072: LD_VAR 0 9
33076: NOT
33077: IFFALSE 33081
// continue ;
33079: GO 32893
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33081: LD_VAR 0 3
33085: PPUSH
33086: LD_VAR 0 9
33090: PPUSH
33091: LD_VAR 0 3
33095: PPUSH
33096: CALL_OW 74
33100: PPUSH
33101: CALL_OW 296
33105: PUSH
33106: LD_INT 6
33108: LESS
33109: IFFALSE 33125
// SetFuel ( j , 100 ) else
33111: LD_VAR 0 3
33115: PPUSH
33116: LD_INT 100
33118: PPUSH
33119: CALL_OW 240
33123: GO 33350
// if GetFuel ( j ) = 0 then
33125: LD_VAR 0 3
33129: PPUSH
33130: CALL_OW 261
33134: PUSH
33135: LD_INT 0
33137: EQUAL
33138: IFFALSE 33350
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33140: LD_ADDR_EXP 69
33144: PUSH
33145: LD_EXP 69
33149: PPUSH
33150: LD_VAR 0 2
33154: PPUSH
33155: LD_EXP 69
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: LD_VAR 0 3
33170: DIFF
33171: PPUSH
33172: CALL_OW 1
33176: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33177: LD_VAR 0 3
33181: PPUSH
33182: CALL_OW 263
33186: PUSH
33187: LD_INT 1
33189: EQUAL
33190: IFFALSE 33206
// ComExitVehicle ( IsInUnit ( j ) ) ;
33192: LD_VAR 0 3
33196: PPUSH
33197: CALL_OW 310
33201: PPUSH
33202: CALL_OW 121
// if GetControl ( j ) = control_remote then
33206: LD_VAR 0 3
33210: PPUSH
33211: CALL_OW 263
33215: PUSH
33216: LD_INT 2
33218: EQUAL
33219: IFFALSE 33230
// ComUnlink ( j ) ;
33221: LD_VAR 0 3
33225: PPUSH
33226: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33230: LD_ADDR_VAR 0 10
33234: PUSH
33235: LD_VAR 0 2
33239: PPUSH
33240: LD_INT 3
33242: PPUSH
33243: CALL 42994 0 2
33247: ST_TO_ADDR
// if fac then
33248: LD_VAR 0 10
33252: IFFALSE 33348
// begin for k in fac do
33254: LD_ADDR_VAR 0 4
33258: PUSH
33259: LD_VAR 0 10
33263: PUSH
33264: FOR_IN
33265: IFFALSE 33346
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33267: LD_ADDR_VAR 0 11
33271: PUSH
33272: LD_VAR 0 10
33276: PPUSH
33277: LD_VAR 0 3
33281: PPUSH
33282: CALL_OW 265
33286: PPUSH
33287: LD_VAR 0 3
33291: PPUSH
33292: CALL_OW 262
33296: PPUSH
33297: LD_VAR 0 3
33301: PPUSH
33302: CALL_OW 263
33306: PPUSH
33307: LD_VAR 0 3
33311: PPUSH
33312: CALL_OW 264
33316: PPUSH
33317: CALL 51509 0 5
33321: ST_TO_ADDR
// if components then
33322: LD_VAR 0 11
33326: IFFALSE 33344
// begin MC_InsertProduceList ( i , components ) ;
33328: LD_VAR 0 2
33332: PPUSH
33333: LD_VAR 0 11
33337: PPUSH
33338: CALL 42539 0 2
// break ;
33342: GO 33346
// end ; end ;
33344: GO 33264
33346: POP
33347: POP
// end ; continue ;
33348: GO 32893
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33350: LD_VAR 0 3
33354: PPUSH
33355: LD_INT 1
33357: PPUSH
33358: CALL_OW 289
33362: PUSH
33363: LD_INT 100
33365: LESS
33366: PUSH
33367: LD_VAR 0 3
33371: PPUSH
33372: CALL_OW 314
33376: NOT
33377: AND
33378: IFFALSE 33407
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33380: LD_VAR 0 3
33384: PPUSH
33385: LD_VAR 0 7
33389: PUSH
33390: LD_INT 2
33392: ARRAY
33393: PPUSH
33394: LD_VAR 0 7
33398: PUSH
33399: LD_INT 3
33401: ARRAY
33402: PPUSH
33403: CALL_OW 117
// break ;
33407: GO 33411
// end ;
33409: GO 32893
33411: POP
33412: POP
// end ; end ;
33413: GO 31609
33415: POP
33416: POP
// end ;
33417: LD_VAR 0 1
33421: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33422: LD_INT 0
33424: PPUSH
33425: PPUSH
33426: PPUSH
33427: PPUSH
// if not mc_bases then
33428: LD_EXP 50
33432: NOT
33433: IFFALSE 33437
// exit ;
33435: GO 33598
// for i = 1 to mc_bases do
33437: LD_ADDR_VAR 0 2
33441: PUSH
33442: DOUBLE
33443: LD_INT 1
33445: DEC
33446: ST_TO_ADDR
33447: LD_EXP 50
33451: PUSH
33452: FOR_TO
33453: IFFALSE 33596
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33455: LD_ADDR_VAR 0 4
33459: PUSH
33460: LD_EXP 69
33464: PUSH
33465: LD_VAR 0 2
33469: ARRAY
33470: PUSH
33471: LD_EXP 72
33475: PUSH
33476: LD_VAR 0 2
33480: ARRAY
33481: UNION
33482: PPUSH
33483: LD_INT 33
33485: PUSH
33486: LD_INT 2
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PPUSH
33493: CALL_OW 72
33497: ST_TO_ADDR
// if tmp then
33498: LD_VAR 0 4
33502: IFFALSE 33594
// for j in tmp do
33504: LD_ADDR_VAR 0 3
33508: PUSH
33509: LD_VAR 0 4
33513: PUSH
33514: FOR_IN
33515: IFFALSE 33592
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33517: LD_VAR 0 3
33521: PPUSH
33522: CALL_OW 312
33526: NOT
33527: PUSH
33528: LD_VAR 0 3
33532: PPUSH
33533: CALL_OW 256
33537: PUSH
33538: LD_INT 250
33540: GREATEREQUAL
33541: AND
33542: IFFALSE 33555
// Connect ( j ) else
33544: LD_VAR 0 3
33548: PPUSH
33549: CALL 57357 0 1
33553: GO 33590
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33555: LD_VAR 0 3
33559: PPUSH
33560: CALL_OW 256
33564: PUSH
33565: LD_INT 250
33567: LESS
33568: PUSH
33569: LD_VAR 0 3
33573: PPUSH
33574: CALL_OW 312
33578: AND
33579: IFFALSE 33590
// ComUnlink ( j ) ;
33581: LD_VAR 0 3
33585: PPUSH
33586: CALL_OW 136
33590: GO 33514
33592: POP
33593: POP
// end ;
33594: GO 33452
33596: POP
33597: POP
// end ;
33598: LD_VAR 0 1
33602: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33603: LD_INT 0
33605: PPUSH
33606: PPUSH
33607: PPUSH
33608: PPUSH
33609: PPUSH
// if not mc_bases then
33610: LD_EXP 50
33614: NOT
33615: IFFALSE 33619
// exit ;
33617: GO 34064
// for i = 1 to mc_bases do
33619: LD_ADDR_VAR 0 2
33623: PUSH
33624: DOUBLE
33625: LD_INT 1
33627: DEC
33628: ST_TO_ADDR
33629: LD_EXP 50
33633: PUSH
33634: FOR_TO
33635: IFFALSE 34062
// begin if not mc_produce [ i ] then
33637: LD_EXP 71
33641: PUSH
33642: LD_VAR 0 2
33646: ARRAY
33647: NOT
33648: IFFALSE 33652
// continue ;
33650: GO 33634
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33652: LD_ADDR_VAR 0 5
33656: PUSH
33657: LD_EXP 50
33661: PUSH
33662: LD_VAR 0 2
33666: ARRAY
33667: PPUSH
33668: LD_INT 30
33670: PUSH
33671: LD_INT 3
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PPUSH
33678: CALL_OW 72
33682: ST_TO_ADDR
// if not fac then
33683: LD_VAR 0 5
33687: NOT
33688: IFFALSE 33692
// continue ;
33690: GO 33634
// for j in fac do
33692: LD_ADDR_VAR 0 3
33696: PUSH
33697: LD_VAR 0 5
33701: PUSH
33702: FOR_IN
33703: IFFALSE 34058
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33705: LD_VAR 0 3
33709: PPUSH
33710: CALL_OW 461
33714: PUSH
33715: LD_INT 2
33717: NONEQUAL
33718: PUSH
33719: LD_VAR 0 3
33723: PPUSH
33724: LD_INT 15
33726: PPUSH
33727: CALL 56976 0 2
33731: PUSH
33732: LD_INT 4
33734: ARRAY
33735: OR
33736: IFFALSE 33740
// continue ;
33738: GO 33702
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33740: LD_VAR 0 3
33744: PPUSH
33745: LD_EXP 71
33749: PUSH
33750: LD_VAR 0 2
33754: ARRAY
33755: PUSH
33756: LD_INT 1
33758: ARRAY
33759: PUSH
33760: LD_INT 1
33762: ARRAY
33763: PPUSH
33764: LD_EXP 71
33768: PUSH
33769: LD_VAR 0 2
33773: ARRAY
33774: PUSH
33775: LD_INT 1
33777: ARRAY
33778: PUSH
33779: LD_INT 2
33781: ARRAY
33782: PPUSH
33783: LD_EXP 71
33787: PUSH
33788: LD_VAR 0 2
33792: ARRAY
33793: PUSH
33794: LD_INT 1
33796: ARRAY
33797: PUSH
33798: LD_INT 3
33800: ARRAY
33801: PPUSH
33802: LD_EXP 71
33806: PUSH
33807: LD_VAR 0 2
33811: ARRAY
33812: PUSH
33813: LD_INT 1
33815: ARRAY
33816: PUSH
33817: LD_INT 4
33819: ARRAY
33820: PPUSH
33821: CALL_OW 448
33825: PUSH
33826: LD_VAR 0 3
33830: PPUSH
33831: LD_EXP 71
33835: PUSH
33836: LD_VAR 0 2
33840: ARRAY
33841: PUSH
33842: LD_INT 1
33844: ARRAY
33845: PUSH
33846: LD_INT 1
33848: ARRAY
33849: PUSH
33850: LD_EXP 71
33854: PUSH
33855: LD_VAR 0 2
33859: ARRAY
33860: PUSH
33861: LD_INT 1
33863: ARRAY
33864: PUSH
33865: LD_INT 2
33867: ARRAY
33868: PUSH
33869: LD_EXP 71
33873: PUSH
33874: LD_VAR 0 2
33878: ARRAY
33879: PUSH
33880: LD_INT 1
33882: ARRAY
33883: PUSH
33884: LD_INT 3
33886: ARRAY
33887: PUSH
33888: LD_EXP 71
33892: PUSH
33893: LD_VAR 0 2
33897: ARRAY
33898: PUSH
33899: LD_INT 1
33901: ARRAY
33902: PUSH
33903: LD_INT 4
33905: ARRAY
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: PPUSH
33913: CALL 60752 0 2
33917: AND
33918: IFFALSE 34056
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33920: LD_VAR 0 3
33924: PPUSH
33925: LD_EXP 71
33929: PUSH
33930: LD_VAR 0 2
33934: ARRAY
33935: PUSH
33936: LD_INT 1
33938: ARRAY
33939: PUSH
33940: LD_INT 1
33942: ARRAY
33943: PPUSH
33944: LD_EXP 71
33948: PUSH
33949: LD_VAR 0 2
33953: ARRAY
33954: PUSH
33955: LD_INT 1
33957: ARRAY
33958: PUSH
33959: LD_INT 2
33961: ARRAY
33962: PPUSH
33963: LD_EXP 71
33967: PUSH
33968: LD_VAR 0 2
33972: ARRAY
33973: PUSH
33974: LD_INT 1
33976: ARRAY
33977: PUSH
33978: LD_INT 3
33980: ARRAY
33981: PPUSH
33982: LD_EXP 71
33986: PUSH
33987: LD_VAR 0 2
33991: ARRAY
33992: PUSH
33993: LD_INT 1
33995: ARRAY
33996: PUSH
33997: LD_INT 4
33999: ARRAY
34000: PPUSH
34001: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34005: LD_ADDR_VAR 0 4
34009: PUSH
34010: LD_EXP 71
34014: PUSH
34015: LD_VAR 0 2
34019: ARRAY
34020: PPUSH
34021: LD_INT 1
34023: PPUSH
34024: CALL_OW 3
34028: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34029: LD_ADDR_EXP 71
34033: PUSH
34034: LD_EXP 71
34038: PPUSH
34039: LD_VAR 0 2
34043: PPUSH
34044: LD_VAR 0 4
34048: PPUSH
34049: CALL_OW 1
34053: ST_TO_ADDR
// break ;
34054: GO 34058
// end ; end ;
34056: GO 33702
34058: POP
34059: POP
// end ;
34060: GO 33634
34062: POP
34063: POP
// end ;
34064: LD_VAR 0 1
34068: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34069: LD_INT 0
34071: PPUSH
34072: PPUSH
34073: PPUSH
// if not mc_bases then
34074: LD_EXP 50
34078: NOT
34079: IFFALSE 34083
// exit ;
34081: GO 34172
// for i = 1 to mc_bases do
34083: LD_ADDR_VAR 0 2
34087: PUSH
34088: DOUBLE
34089: LD_INT 1
34091: DEC
34092: ST_TO_ADDR
34093: LD_EXP 50
34097: PUSH
34098: FOR_TO
34099: IFFALSE 34170
// begin if mc_attack [ i ] then
34101: LD_EXP 70
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: IFFALSE 34168
// begin tmp := mc_attack [ i ] [ 1 ] ;
34113: LD_ADDR_VAR 0 3
34117: PUSH
34118: LD_EXP 70
34122: PUSH
34123: LD_VAR 0 2
34127: ARRAY
34128: PUSH
34129: LD_INT 1
34131: ARRAY
34132: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34133: LD_ADDR_EXP 70
34137: PUSH
34138: LD_EXP 70
34142: PPUSH
34143: LD_VAR 0 2
34147: PPUSH
34148: EMPTY
34149: PPUSH
34150: CALL_OW 1
34154: ST_TO_ADDR
// Attack ( tmp ) ;
34155: LD_VAR 0 3
34159: PPUSH
34160: CALL 113081 0 1
// exit ;
34164: POP
34165: POP
34166: GO 34172
// end ; end ;
34168: GO 34098
34170: POP
34171: POP
// end ;
34172: LD_VAR 0 1
34176: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34177: LD_INT 0
34179: PPUSH
34180: PPUSH
34181: PPUSH
34182: PPUSH
34183: PPUSH
34184: PPUSH
34185: PPUSH
// if not mc_bases then
34186: LD_EXP 50
34190: NOT
34191: IFFALSE 34195
// exit ;
34193: GO 35052
// for i = 1 to mc_bases do
34195: LD_ADDR_VAR 0 2
34199: PUSH
34200: DOUBLE
34201: LD_INT 1
34203: DEC
34204: ST_TO_ADDR
34205: LD_EXP 50
34209: PUSH
34210: FOR_TO
34211: IFFALSE 35050
// begin if not mc_bases [ i ] then
34213: LD_EXP 50
34217: PUSH
34218: LD_VAR 0 2
34222: ARRAY
34223: NOT
34224: IFFALSE 34228
// continue ;
34226: GO 34210
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34228: LD_ADDR_VAR 0 7
34232: PUSH
34233: LD_EXP 50
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PUSH
34244: LD_INT 1
34246: ARRAY
34247: PPUSH
34248: CALL 50835 0 1
34252: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34253: LD_ADDR_EXP 73
34257: PUSH
34258: LD_EXP 73
34262: PPUSH
34263: LD_VAR 0 2
34267: PPUSH
34268: LD_EXP 50
34272: PUSH
34273: LD_VAR 0 2
34277: ARRAY
34278: PUSH
34279: LD_INT 1
34281: ARRAY
34282: PPUSH
34283: CALL_OW 255
34287: PPUSH
34288: LD_EXP 75
34292: PUSH
34293: LD_VAR 0 2
34297: ARRAY
34298: PPUSH
34299: CALL 50800 0 2
34303: PPUSH
34304: CALL_OW 1
34308: ST_TO_ADDR
// if not mc_scan [ i ] then
34309: LD_EXP 73
34313: PUSH
34314: LD_VAR 0 2
34318: ARRAY
34319: NOT
34320: IFFALSE 34498
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34322: LD_ADDR_EXP 93
34326: PUSH
34327: LD_EXP 93
34331: PPUSH
34332: LD_VAR 0 2
34336: PPUSH
34337: LD_INT 0
34339: PPUSH
34340: CALL_OW 1
34344: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34345: LD_ADDR_VAR 0 4
34349: PUSH
34350: LD_EXP 50
34354: PUSH
34355: LD_VAR 0 2
34359: ARRAY
34360: PPUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 25
34366: PUSH
34367: LD_INT 5
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 25
34376: PUSH
34377: LD_INT 8
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 25
34386: PUSH
34387: LD_INT 9
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: PPUSH
34400: CALL_OW 72
34404: ST_TO_ADDR
// if not tmp then
34405: LD_VAR 0 4
34409: NOT
34410: IFFALSE 34414
// continue ;
34412: GO 34210
// for j in tmp do
34414: LD_ADDR_VAR 0 3
34418: PUSH
34419: LD_VAR 0 4
34423: PUSH
34424: FOR_IN
34425: IFFALSE 34496
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34427: LD_VAR 0 3
34431: PPUSH
34432: CALL_OW 310
34436: PPUSH
34437: CALL_OW 266
34441: PUSH
34442: LD_INT 5
34444: EQUAL
34445: PUSH
34446: LD_VAR 0 3
34450: PPUSH
34451: CALL_OW 257
34455: PUSH
34456: LD_INT 1
34458: EQUAL
34459: AND
34460: PUSH
34461: LD_VAR 0 3
34465: PPUSH
34466: CALL_OW 459
34470: NOT
34471: AND
34472: PUSH
34473: LD_VAR 0 7
34477: AND
34478: IFFALSE 34494
// ComChangeProfession ( j , class ) ;
34480: LD_VAR 0 3
34484: PPUSH
34485: LD_VAR 0 7
34489: PPUSH
34490: CALL_OW 123
34494: GO 34424
34496: POP
34497: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34498: LD_EXP 73
34502: PUSH
34503: LD_VAR 0 2
34507: ARRAY
34508: PUSH
34509: LD_EXP 93
34513: PUSH
34514: LD_VAR 0 2
34518: ARRAY
34519: NOT
34520: AND
34521: PUSH
34522: LD_EXP 72
34526: PUSH
34527: LD_VAR 0 2
34531: ARRAY
34532: NOT
34533: AND
34534: PUSH
34535: LD_EXP 50
34539: PUSH
34540: LD_VAR 0 2
34544: ARRAY
34545: PPUSH
34546: LD_INT 50
34548: PUSH
34549: EMPTY
34550: LIST
34551: PUSH
34552: LD_INT 2
34554: PUSH
34555: LD_INT 30
34557: PUSH
34558: LD_INT 32
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 30
34567: PUSH
34568: LD_INT 33
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 30
34577: PUSH
34578: LD_INT 4
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 30
34587: PUSH
34588: LD_INT 5
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PPUSH
34606: CALL_OW 72
34610: PUSH
34611: LD_INT 4
34613: LESS
34614: PUSH
34615: LD_EXP 50
34619: PUSH
34620: LD_VAR 0 2
34624: ARRAY
34625: PPUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 24
34631: PUSH
34632: LD_INT 1000
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: LD_INT 30
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 30
34658: PUSH
34659: LD_INT 1
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: LIST
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PPUSH
34675: CALL_OW 72
34679: OR
34680: AND
34681: IFFALSE 34932
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34683: LD_ADDR_EXP 93
34687: PUSH
34688: LD_EXP 93
34692: PPUSH
34693: LD_VAR 0 2
34697: PPUSH
34698: LD_INT 1
34700: PPUSH
34701: CALL_OW 1
34705: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34706: LD_ADDR_VAR 0 4
34710: PUSH
34711: LD_EXP 50
34715: PUSH
34716: LD_VAR 0 2
34720: ARRAY
34721: PPUSH
34722: LD_INT 2
34724: PUSH
34725: LD_INT 25
34727: PUSH
34728: LD_INT 1
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 25
34737: PUSH
34738: LD_INT 5
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 25
34747: PUSH
34748: LD_INT 8
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 25
34757: PUSH
34758: LD_INT 9
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: PPUSH
34772: CALL_OW 72
34776: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34777: LD_ADDR_VAR 0 4
34781: PUSH
34782: LD_VAR 0 4
34786: PUSH
34787: LD_VAR 0 4
34791: PPUSH
34792: LD_INT 18
34794: PPUSH
34795: CALL 84329 0 2
34799: DIFF
34800: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34801: LD_VAR 0 4
34805: NOT
34806: PUSH
34807: LD_EXP 50
34811: PUSH
34812: LD_VAR 0 2
34816: ARRAY
34817: PPUSH
34818: LD_INT 2
34820: PUSH
34821: LD_INT 30
34823: PUSH
34824: LD_INT 4
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 30
34833: PUSH
34834: LD_INT 5
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: LIST
34845: PPUSH
34846: CALL_OW 72
34850: NOT
34851: AND
34852: IFFALSE 34914
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34854: LD_ADDR_VAR 0 4
34858: PUSH
34859: LD_EXP 50
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: PPUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 25
34875: PUSH
34876: LD_INT 2
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 25
34885: PUSH
34886: LD_INT 3
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 25
34895: PUSH
34896: LD_INT 4
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: PPUSH
34909: CALL_OW 72
34913: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34914: LD_VAR 0 2
34918: PPUSH
34919: LD_VAR 0 4
34923: PPUSH
34924: CALL 117790 0 2
// exit ;
34928: POP
34929: POP
34930: GO 35052
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34932: LD_EXP 73
34936: PUSH
34937: LD_VAR 0 2
34941: ARRAY
34942: PUSH
34943: LD_EXP 93
34947: PUSH
34948: LD_VAR 0 2
34952: ARRAY
34953: NOT
34954: AND
34955: PUSH
34956: LD_EXP 72
34960: PUSH
34961: LD_VAR 0 2
34965: ARRAY
34966: AND
34967: IFFALSE 35048
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34969: LD_ADDR_EXP 93
34973: PUSH
34974: LD_EXP 93
34978: PPUSH
34979: LD_VAR 0 2
34983: PPUSH
34984: LD_INT 1
34986: PPUSH
34987: CALL_OW 1
34991: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34992: LD_ADDR_VAR 0 4
34996: PUSH
34997: LD_EXP 72
35001: PUSH
35002: LD_VAR 0 2
35006: ARRAY
35007: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35008: LD_ADDR_EXP 72
35012: PUSH
35013: LD_EXP 72
35017: PPUSH
35018: LD_VAR 0 2
35022: PPUSH
35023: EMPTY
35024: PPUSH
35025: CALL_OW 1
35029: ST_TO_ADDR
// Defend ( i , tmp ) ;
35030: LD_VAR 0 2
35034: PPUSH
35035: LD_VAR 0 4
35039: PPUSH
35040: CALL 118386 0 2
// exit ;
35044: POP
35045: POP
35046: GO 35052
// end ; end ;
35048: GO 34210
35050: POP
35051: POP
// end ;
35052: LD_VAR 0 1
35056: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35057: LD_INT 0
35059: PPUSH
35060: PPUSH
35061: PPUSH
35062: PPUSH
35063: PPUSH
35064: PPUSH
35065: PPUSH
35066: PPUSH
35067: PPUSH
35068: PPUSH
35069: PPUSH
// if not mc_bases then
35070: LD_EXP 50
35074: NOT
35075: IFFALSE 35079
// exit ;
35077: GO 36166
// for i = 1 to mc_bases do
35079: LD_ADDR_VAR 0 2
35083: PUSH
35084: DOUBLE
35085: LD_INT 1
35087: DEC
35088: ST_TO_ADDR
35089: LD_EXP 50
35093: PUSH
35094: FOR_TO
35095: IFFALSE 36164
// begin tmp := mc_lab [ i ] ;
35097: LD_ADDR_VAR 0 6
35101: PUSH
35102: LD_EXP 83
35106: PUSH
35107: LD_VAR 0 2
35111: ARRAY
35112: ST_TO_ADDR
// if not tmp then
35113: LD_VAR 0 6
35117: NOT
35118: IFFALSE 35122
// continue ;
35120: GO 35094
// idle_lab := 0 ;
35122: LD_ADDR_VAR 0 11
35126: PUSH
35127: LD_INT 0
35129: ST_TO_ADDR
// for j in tmp do
35130: LD_ADDR_VAR 0 3
35134: PUSH
35135: LD_VAR 0 6
35139: PUSH
35140: FOR_IN
35141: IFFALSE 36160
// begin researching := false ;
35143: LD_ADDR_VAR 0 10
35147: PUSH
35148: LD_INT 0
35150: ST_TO_ADDR
// side := GetSide ( j ) ;
35151: LD_ADDR_VAR 0 4
35155: PUSH
35156: LD_VAR 0 3
35160: PPUSH
35161: CALL_OW 255
35165: ST_TO_ADDR
// if not mc_tech [ side ] then
35166: LD_EXP 77
35170: PUSH
35171: LD_VAR 0 4
35175: ARRAY
35176: NOT
35177: IFFALSE 35181
// continue ;
35179: GO 35140
// if BuildingStatus ( j ) = bs_idle then
35181: LD_VAR 0 3
35185: PPUSH
35186: CALL_OW 461
35190: PUSH
35191: LD_INT 2
35193: EQUAL
35194: IFFALSE 35382
// begin if idle_lab and UnitsInside ( j ) < 6 then
35196: LD_VAR 0 11
35200: PUSH
35201: LD_VAR 0 3
35205: PPUSH
35206: CALL_OW 313
35210: PUSH
35211: LD_INT 6
35213: LESS
35214: AND
35215: IFFALSE 35286
// begin tmp2 := UnitsInside ( idle_lab ) ;
35217: LD_ADDR_VAR 0 9
35221: PUSH
35222: LD_VAR 0 11
35226: PPUSH
35227: CALL_OW 313
35231: ST_TO_ADDR
// if tmp2 then
35232: LD_VAR 0 9
35236: IFFALSE 35278
// for x in tmp2 do
35238: LD_ADDR_VAR 0 7
35242: PUSH
35243: LD_VAR 0 9
35247: PUSH
35248: FOR_IN
35249: IFFALSE 35276
// begin ComExitBuilding ( x ) ;
35251: LD_VAR 0 7
35255: PPUSH
35256: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35260: LD_VAR 0 7
35264: PPUSH
35265: LD_VAR 0 3
35269: PPUSH
35270: CALL_OW 180
// end ;
35274: GO 35248
35276: POP
35277: POP
// idle_lab := 0 ;
35278: LD_ADDR_VAR 0 11
35282: PUSH
35283: LD_INT 0
35285: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35286: LD_ADDR_VAR 0 5
35290: PUSH
35291: LD_EXP 77
35295: PUSH
35296: LD_VAR 0 4
35300: ARRAY
35301: PUSH
35302: FOR_IN
35303: IFFALSE 35363
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35305: LD_VAR 0 3
35309: PPUSH
35310: LD_VAR 0 5
35314: PPUSH
35315: CALL_OW 430
35319: PUSH
35320: LD_VAR 0 4
35324: PPUSH
35325: LD_VAR 0 5
35329: PPUSH
35330: CALL 49905 0 2
35334: AND
35335: IFFALSE 35361
// begin researching := true ;
35337: LD_ADDR_VAR 0 10
35341: PUSH
35342: LD_INT 1
35344: ST_TO_ADDR
// ComResearch ( j , t ) ;
35345: LD_VAR 0 3
35349: PPUSH
35350: LD_VAR 0 5
35354: PPUSH
35355: CALL_OW 124
// break ;
35359: GO 35363
// end ;
35361: GO 35302
35363: POP
35364: POP
// if not researching then
35365: LD_VAR 0 10
35369: NOT
35370: IFFALSE 35382
// idle_lab := j ;
35372: LD_ADDR_VAR 0 11
35376: PUSH
35377: LD_VAR 0 3
35381: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35382: LD_VAR 0 3
35386: PPUSH
35387: CALL_OW 461
35391: PUSH
35392: LD_INT 10
35394: EQUAL
35395: IFFALSE 35983
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35397: LD_EXP 79
35401: PUSH
35402: LD_VAR 0 2
35406: ARRAY
35407: NOT
35408: PUSH
35409: LD_EXP 80
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: NOT
35420: AND
35421: PUSH
35422: LD_EXP 77
35426: PUSH
35427: LD_VAR 0 4
35431: ARRAY
35432: PUSH
35433: LD_INT 1
35435: GREATER
35436: AND
35437: IFFALSE 35568
// begin ComCancel ( j ) ;
35439: LD_VAR 0 3
35443: PPUSH
35444: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35448: LD_ADDR_EXP 77
35452: PUSH
35453: LD_EXP 77
35457: PPUSH
35458: LD_VAR 0 4
35462: PPUSH
35463: LD_EXP 77
35467: PUSH
35468: LD_VAR 0 4
35472: ARRAY
35473: PPUSH
35474: LD_EXP 77
35478: PUSH
35479: LD_VAR 0 4
35483: ARRAY
35484: PUSH
35485: LD_INT 1
35487: MINUS
35488: PPUSH
35489: LD_EXP 77
35493: PUSH
35494: LD_VAR 0 4
35498: ARRAY
35499: PPUSH
35500: LD_INT 0
35502: PPUSH
35503: CALL 53429 0 4
35507: PPUSH
35508: CALL_OW 1
35512: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35513: LD_ADDR_EXP 77
35517: PUSH
35518: LD_EXP 77
35522: PPUSH
35523: LD_VAR 0 4
35527: PPUSH
35528: LD_EXP 77
35532: PUSH
35533: LD_VAR 0 4
35537: ARRAY
35538: PPUSH
35539: LD_EXP 77
35543: PUSH
35544: LD_VAR 0 4
35548: ARRAY
35549: PPUSH
35550: LD_INT 1
35552: PPUSH
35553: LD_INT 0
35555: PPUSH
35556: CALL 53429 0 4
35560: PPUSH
35561: CALL_OW 1
35565: ST_TO_ADDR
// continue ;
35566: GO 35140
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35568: LD_EXP 79
35572: PUSH
35573: LD_VAR 0 2
35577: ARRAY
35578: PUSH
35579: LD_EXP 80
35583: PUSH
35584: LD_VAR 0 2
35588: ARRAY
35589: NOT
35590: AND
35591: IFFALSE 35718
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35593: LD_ADDR_EXP 80
35597: PUSH
35598: LD_EXP 80
35602: PPUSH
35603: LD_VAR 0 2
35607: PUSH
35608: LD_EXP 80
35612: PUSH
35613: LD_VAR 0 2
35617: ARRAY
35618: PUSH
35619: LD_INT 1
35621: PLUS
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PPUSH
35627: LD_EXP 79
35631: PUSH
35632: LD_VAR 0 2
35636: ARRAY
35637: PUSH
35638: LD_INT 1
35640: ARRAY
35641: PPUSH
35642: CALL 54011 0 3
35646: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35647: LD_EXP 79
35651: PUSH
35652: LD_VAR 0 2
35656: ARRAY
35657: PUSH
35658: LD_INT 1
35660: ARRAY
35661: PPUSH
35662: LD_INT 112
35664: PPUSH
35665: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35669: LD_ADDR_VAR 0 9
35673: PUSH
35674: LD_EXP 79
35678: PUSH
35679: LD_VAR 0 2
35683: ARRAY
35684: PPUSH
35685: LD_INT 1
35687: PPUSH
35688: CALL_OW 3
35692: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35693: LD_ADDR_EXP 79
35697: PUSH
35698: LD_EXP 79
35702: PPUSH
35703: LD_VAR 0 2
35707: PPUSH
35708: LD_VAR 0 9
35712: PPUSH
35713: CALL_OW 1
35717: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35718: LD_EXP 79
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: PUSH
35729: LD_EXP 80
35733: PUSH
35734: LD_VAR 0 2
35738: ARRAY
35739: AND
35740: PUSH
35741: LD_EXP 80
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 1
35754: ARRAY
35755: PPUSH
35756: CALL_OW 310
35760: NOT
35761: AND
35762: PUSH
35763: LD_VAR 0 3
35767: PPUSH
35768: CALL_OW 313
35772: PUSH
35773: LD_INT 6
35775: EQUAL
35776: AND
35777: IFFALSE 35833
// begin tmp2 := UnitsInside ( j ) ;
35779: LD_ADDR_VAR 0 9
35783: PUSH
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 313
35793: ST_TO_ADDR
// if tmp2 = 6 then
35794: LD_VAR 0 9
35798: PUSH
35799: LD_INT 6
35801: EQUAL
35802: IFFALSE 35833
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35804: LD_VAR 0 9
35808: PUSH
35809: LD_INT 1
35811: ARRAY
35812: PPUSH
35813: LD_INT 112
35815: PPUSH
35816: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35820: LD_VAR 0 9
35824: PUSH
35825: LD_INT 1
35827: ARRAY
35828: PPUSH
35829: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35833: LD_EXP 80
35837: PUSH
35838: LD_VAR 0 2
35842: ARRAY
35843: PUSH
35844: LD_EXP 80
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 1
35857: ARRAY
35858: PPUSH
35859: CALL_OW 314
35863: NOT
35864: AND
35865: PUSH
35866: LD_EXP 80
35870: PUSH
35871: LD_VAR 0 2
35875: ARRAY
35876: PUSH
35877: LD_INT 1
35879: ARRAY
35880: PPUSH
35881: CALL_OW 310
35885: NOT
35886: AND
35887: IFFALSE 35913
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35889: LD_EXP 80
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 1
35902: ARRAY
35903: PPUSH
35904: LD_VAR 0 3
35908: PPUSH
35909: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35913: LD_EXP 80
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 1
35926: ARRAY
35927: PPUSH
35928: CALL_OW 310
35932: PUSH
35933: LD_EXP 80
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: PUSH
35944: LD_INT 1
35946: ARRAY
35947: PPUSH
35948: CALL_OW 310
35952: PPUSH
35953: CALL_OW 461
35957: PUSH
35958: LD_INT 3
35960: NONEQUAL
35961: AND
35962: IFFALSE 35983
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35964: LD_EXP 80
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 1
35977: ARRAY
35978: PPUSH
35979: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL_OW 461
35992: PUSH
35993: LD_INT 6
35995: EQUAL
35996: PUSH
35997: LD_VAR 0 6
36001: PUSH
36002: LD_INT 1
36004: GREATER
36005: AND
36006: IFFALSE 36158
// begin sci := [ ] ;
36008: LD_ADDR_VAR 0 8
36012: PUSH
36013: EMPTY
36014: ST_TO_ADDR
// for x in ( tmp diff j ) do
36015: LD_ADDR_VAR 0 7
36019: PUSH
36020: LD_VAR 0 6
36024: PUSH
36025: LD_VAR 0 3
36029: DIFF
36030: PUSH
36031: FOR_IN
36032: IFFALSE 36084
// begin if sci = 6 then
36034: LD_VAR 0 8
36038: PUSH
36039: LD_INT 6
36041: EQUAL
36042: IFFALSE 36046
// break ;
36044: GO 36084
// if BuildingStatus ( x ) = bs_idle then
36046: LD_VAR 0 7
36050: PPUSH
36051: CALL_OW 461
36055: PUSH
36056: LD_INT 2
36058: EQUAL
36059: IFFALSE 36082
// sci := sci ^ UnitsInside ( x ) ;
36061: LD_ADDR_VAR 0 8
36065: PUSH
36066: LD_VAR 0 8
36070: PUSH
36071: LD_VAR 0 7
36075: PPUSH
36076: CALL_OW 313
36080: ADD
36081: ST_TO_ADDR
// end ;
36082: GO 36031
36084: POP
36085: POP
// if not sci then
36086: LD_VAR 0 8
36090: NOT
36091: IFFALSE 36095
// continue ;
36093: GO 35140
// for x in sci do
36095: LD_ADDR_VAR 0 7
36099: PUSH
36100: LD_VAR 0 8
36104: PUSH
36105: FOR_IN
36106: IFFALSE 36156
// if IsInUnit ( x ) and not HasTask ( x ) then
36108: LD_VAR 0 7
36112: PPUSH
36113: CALL_OW 310
36117: PUSH
36118: LD_VAR 0 7
36122: PPUSH
36123: CALL_OW 314
36127: NOT
36128: AND
36129: IFFALSE 36154
// begin ComExitBuilding ( x ) ;
36131: LD_VAR 0 7
36135: PPUSH
36136: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36140: LD_VAR 0 7
36144: PPUSH
36145: LD_VAR 0 3
36149: PPUSH
36150: CALL_OW 180
// end ;
36154: GO 36105
36156: POP
36157: POP
// end ; end ;
36158: GO 35140
36160: POP
36161: POP
// end ;
36162: GO 35094
36164: POP
36165: POP
// end ;
36166: LD_VAR 0 1
36170: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36171: LD_INT 0
36173: PPUSH
36174: PPUSH
// if not mc_bases then
36175: LD_EXP 50
36179: NOT
36180: IFFALSE 36184
// exit ;
36182: GO 36265
// for i = 1 to mc_bases do
36184: LD_ADDR_VAR 0 2
36188: PUSH
36189: DOUBLE
36190: LD_INT 1
36192: DEC
36193: ST_TO_ADDR
36194: LD_EXP 50
36198: PUSH
36199: FOR_TO
36200: IFFALSE 36263
// if mc_mines [ i ] and mc_miners [ i ] then
36202: LD_EXP 63
36206: PUSH
36207: LD_VAR 0 2
36211: ARRAY
36212: PUSH
36213: LD_EXP 64
36217: PUSH
36218: LD_VAR 0 2
36222: ARRAY
36223: AND
36224: IFFALSE 36261
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36226: LD_EXP 64
36230: PUSH
36231: LD_VAR 0 2
36235: ARRAY
36236: PUSH
36237: LD_INT 1
36239: ARRAY
36240: PPUSH
36241: CALL_OW 255
36245: PPUSH
36246: LD_EXP 63
36250: PUSH
36251: LD_VAR 0 2
36255: ARRAY
36256: PPUSH
36257: CALL 50988 0 2
36261: GO 36199
36263: POP
36264: POP
// end ;
36265: LD_VAR 0 1
36269: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36270: LD_INT 0
36272: PPUSH
36273: PPUSH
36274: PPUSH
36275: PPUSH
36276: PPUSH
36277: PPUSH
36278: PPUSH
36279: PPUSH
// if not mc_bases or not mc_parking then
36280: LD_EXP 50
36284: NOT
36285: PUSH
36286: LD_EXP 74
36290: NOT
36291: OR
36292: IFFALSE 36296
// exit ;
36294: GO 37034
// for i = 1 to mc_bases do
36296: LD_ADDR_VAR 0 2
36300: PUSH
36301: DOUBLE
36302: LD_INT 1
36304: DEC
36305: ST_TO_ADDR
36306: LD_EXP 50
36310: PUSH
36311: FOR_TO
36312: IFFALSE 37032
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36314: LD_EXP 50
36318: PUSH
36319: LD_VAR 0 2
36323: ARRAY
36324: NOT
36325: PUSH
36326: LD_EXP 74
36330: PUSH
36331: LD_VAR 0 2
36335: ARRAY
36336: NOT
36337: OR
36338: IFFALSE 36342
// continue ;
36340: GO 36311
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36342: LD_ADDR_VAR 0 5
36346: PUSH
36347: LD_EXP 50
36351: PUSH
36352: LD_VAR 0 2
36356: ARRAY
36357: PUSH
36358: LD_INT 1
36360: ARRAY
36361: PPUSH
36362: CALL_OW 255
36366: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36367: LD_ADDR_VAR 0 6
36371: PUSH
36372: LD_EXP 50
36376: PUSH
36377: LD_VAR 0 2
36381: ARRAY
36382: PPUSH
36383: LD_INT 30
36385: PUSH
36386: LD_INT 3
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PPUSH
36393: CALL_OW 72
36397: ST_TO_ADDR
// if not fac then
36398: LD_VAR 0 6
36402: NOT
36403: IFFALSE 36454
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36405: LD_ADDR_VAR 0 6
36409: PUSH
36410: LD_EXP 50
36414: PUSH
36415: LD_VAR 0 2
36419: ARRAY
36420: PPUSH
36421: LD_INT 2
36423: PUSH
36424: LD_INT 30
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 30
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: LIST
36448: PPUSH
36449: CALL_OW 72
36453: ST_TO_ADDR
// if not fac then
36454: LD_VAR 0 6
36458: NOT
36459: IFFALSE 36463
// continue ;
36461: GO 36311
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36463: LD_ADDR_VAR 0 7
36467: PUSH
36468: LD_EXP 74
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: PPUSH
36479: LD_INT 22
36481: PUSH
36482: LD_VAR 0 5
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 21
36493: PUSH
36494: LD_INT 2
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 3
36503: PUSH
36504: LD_INT 60
36506: PUSH
36507: EMPTY
36508: LIST
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 3
36516: PUSH
36517: LD_INT 24
36519: PUSH
36520: LD_INT 1000
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: PPUSH
36537: CALL_OW 70
36541: ST_TO_ADDR
// for j in fac do
36542: LD_ADDR_VAR 0 3
36546: PUSH
36547: LD_VAR 0 6
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36648
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36555: LD_ADDR_VAR 0 7
36559: PUSH
36560: LD_VAR 0 7
36564: PUSH
36565: LD_INT 22
36567: PUSH
36568: LD_VAR 0 5
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 91
36579: PUSH
36580: LD_VAR 0 3
36584: PUSH
36585: LD_INT 15
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 21
36595: PUSH
36596: LD_INT 2
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 3
36605: PUSH
36606: LD_INT 60
36608: PUSH
36609: EMPTY
36610: LIST
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 3
36618: PUSH
36619: LD_INT 24
36621: PUSH
36622: LD_INT 1000
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: PPUSH
36640: CALL_OW 69
36644: UNION
36645: ST_TO_ADDR
36646: GO 36552
36648: POP
36649: POP
// if not vehs then
36650: LD_VAR 0 7
36654: NOT
36655: IFFALSE 36681
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36657: LD_ADDR_EXP 62
36661: PUSH
36662: LD_EXP 62
36666: PPUSH
36667: LD_VAR 0 2
36671: PPUSH
36672: EMPTY
36673: PPUSH
36674: CALL_OW 1
36678: ST_TO_ADDR
// continue ;
36679: GO 36311
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36681: LD_ADDR_VAR 0 8
36685: PUSH
36686: LD_EXP 50
36690: PUSH
36691: LD_VAR 0 2
36695: ARRAY
36696: PPUSH
36697: LD_INT 30
36699: PUSH
36700: LD_INT 3
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PPUSH
36707: CALL_OW 72
36711: ST_TO_ADDR
// if tmp then
36712: LD_VAR 0 8
36716: IFFALSE 36819
// begin for j in tmp do
36718: LD_ADDR_VAR 0 3
36722: PUSH
36723: LD_VAR 0 8
36727: PUSH
36728: FOR_IN
36729: IFFALSE 36817
// for k in UnitsInside ( j ) do
36731: LD_ADDR_VAR 0 4
36735: PUSH
36736: LD_VAR 0 3
36740: PPUSH
36741: CALL_OW 313
36745: PUSH
36746: FOR_IN
36747: IFFALSE 36813
// if k then
36749: LD_VAR 0 4
36753: IFFALSE 36811
// if not k in mc_repair_vehicle [ i ] then
36755: LD_VAR 0 4
36759: PUSH
36760: LD_EXP 62
36764: PUSH
36765: LD_VAR 0 2
36769: ARRAY
36770: IN
36771: NOT
36772: IFFALSE 36811
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36774: LD_ADDR_EXP 62
36778: PUSH
36779: LD_EXP 62
36783: PPUSH
36784: LD_VAR 0 2
36788: PPUSH
36789: LD_EXP 62
36793: PUSH
36794: LD_VAR 0 2
36798: ARRAY
36799: PUSH
36800: LD_VAR 0 4
36804: UNION
36805: PPUSH
36806: CALL_OW 1
36810: ST_TO_ADDR
36811: GO 36746
36813: POP
36814: POP
36815: GO 36728
36817: POP
36818: POP
// end ; if not mc_repair_vehicle [ i ] then
36819: LD_EXP 62
36823: PUSH
36824: LD_VAR 0 2
36828: ARRAY
36829: NOT
36830: IFFALSE 36834
// continue ;
36832: GO 36311
// for j in mc_repair_vehicle [ i ] do
36834: LD_ADDR_VAR 0 3
36838: PUSH
36839: LD_EXP 62
36843: PUSH
36844: LD_VAR 0 2
36848: ARRAY
36849: PUSH
36850: FOR_IN
36851: IFFALSE 37028
// begin if GetClass ( j ) <> 3 then
36853: LD_VAR 0 3
36857: PPUSH
36858: CALL_OW 257
36862: PUSH
36863: LD_INT 3
36865: NONEQUAL
36866: IFFALSE 36907
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36868: LD_ADDR_EXP 62
36872: PUSH
36873: LD_EXP 62
36877: PPUSH
36878: LD_VAR 0 2
36882: PPUSH
36883: LD_EXP 62
36887: PUSH
36888: LD_VAR 0 2
36892: ARRAY
36893: PUSH
36894: LD_VAR 0 3
36898: DIFF
36899: PPUSH
36900: CALL_OW 1
36904: ST_TO_ADDR
// continue ;
36905: GO 36850
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36907: LD_VAR 0 3
36911: PPUSH
36912: CALL_OW 311
36916: NOT
36917: PUSH
36918: LD_VAR 0 3
36922: PUSH
36923: LD_EXP 53
36927: PUSH
36928: LD_VAR 0 2
36932: ARRAY
36933: PUSH
36934: LD_INT 1
36936: ARRAY
36937: IN
36938: NOT
36939: AND
36940: PUSH
36941: LD_VAR 0 3
36945: PUSH
36946: LD_EXP 53
36950: PUSH
36951: LD_VAR 0 2
36955: ARRAY
36956: PUSH
36957: LD_INT 2
36959: ARRAY
36960: IN
36961: NOT
36962: AND
36963: IFFALSE 37026
// begin if IsInUnit ( j ) then
36965: LD_VAR 0 3
36969: PPUSH
36970: CALL_OW 310
36974: IFFALSE 36987
// ComExitBuilding ( j ) else
36976: LD_VAR 0 3
36980: PPUSH
36981: CALL_OW 122
36985: GO 37026
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36987: LD_VAR 0 3
36991: PPUSH
36992: LD_VAR 0 7
36996: PUSH
36997: LD_INT 1
36999: ARRAY
37000: PPUSH
37001: CALL 88825 0 2
37005: NOT
37006: IFFALSE 37026
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37008: LD_VAR 0 3
37012: PPUSH
37013: LD_VAR 0 7
37017: PUSH
37018: LD_INT 1
37020: ARRAY
37021: PPUSH
37022: CALL_OW 129
// end ; end ;
37026: GO 36850
37028: POP
37029: POP
// end ;
37030: GO 36311
37032: POP
37033: POP
// end ;
37034: LD_VAR 0 1
37038: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37039: LD_INT 0
37041: PPUSH
37042: PPUSH
37043: PPUSH
37044: PPUSH
37045: PPUSH
37046: PPUSH
37047: PPUSH
37048: PPUSH
37049: PPUSH
37050: PPUSH
37051: PPUSH
// if not mc_bases then
37052: LD_EXP 50
37056: NOT
37057: IFFALSE 37061
// exit ;
37059: GO 37863
// for i = 1 to mc_bases do
37061: LD_ADDR_VAR 0 2
37065: PUSH
37066: DOUBLE
37067: LD_INT 1
37069: DEC
37070: ST_TO_ADDR
37071: LD_EXP 50
37075: PUSH
37076: FOR_TO
37077: IFFALSE 37861
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37079: LD_EXP 78
37083: PUSH
37084: LD_VAR 0 2
37088: ARRAY
37089: NOT
37090: PUSH
37091: LD_EXP 53
37095: PUSH
37096: LD_VAR 0 2
37100: ARRAY
37101: PUSH
37102: LD_INT 1
37104: ARRAY
37105: OR
37106: PUSH
37107: LD_EXP 53
37111: PUSH
37112: LD_VAR 0 2
37116: ARRAY
37117: PUSH
37118: LD_INT 2
37120: ARRAY
37121: OR
37122: PUSH
37123: LD_EXP 76
37127: PUSH
37128: LD_VAR 0 2
37132: ARRAY
37133: PPUSH
37134: LD_INT 1
37136: PPUSH
37137: CALL_OW 325
37141: NOT
37142: OR
37143: PUSH
37144: LD_EXP 73
37148: PUSH
37149: LD_VAR 0 2
37153: ARRAY
37154: OR
37155: IFFALSE 37159
// continue ;
37157: GO 37076
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37159: LD_ADDR_VAR 0 8
37163: PUSH
37164: LD_EXP 50
37168: PUSH
37169: LD_VAR 0 2
37173: ARRAY
37174: PPUSH
37175: LD_INT 25
37177: PUSH
37178: LD_INT 4
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 50
37187: PUSH
37188: EMPTY
37189: LIST
37190: PUSH
37191: LD_INT 3
37193: PUSH
37194: LD_INT 60
37196: PUSH
37197: EMPTY
37198: LIST
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: LIST
37208: PPUSH
37209: CALL_OW 72
37213: PUSH
37214: LD_EXP 54
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: DIFF
37225: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37226: LD_ADDR_VAR 0 9
37230: PUSH
37231: LD_EXP 50
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PPUSH
37242: LD_INT 2
37244: PUSH
37245: LD_INT 30
37247: PUSH
37248: LD_INT 0
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 30
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: LIST
37269: PPUSH
37270: CALL_OW 72
37274: ST_TO_ADDR
// if not tmp or not dep then
37275: LD_VAR 0 8
37279: NOT
37280: PUSH
37281: LD_VAR 0 9
37285: NOT
37286: OR
37287: IFFALSE 37291
// continue ;
37289: GO 37076
// side := GetSide ( tmp [ 1 ] ) ;
37291: LD_ADDR_VAR 0 11
37295: PUSH
37296: LD_VAR 0 8
37300: PUSH
37301: LD_INT 1
37303: ARRAY
37304: PPUSH
37305: CALL_OW 255
37309: ST_TO_ADDR
// dep := dep [ 1 ] ;
37310: LD_ADDR_VAR 0 9
37314: PUSH
37315: LD_VAR 0 9
37319: PUSH
37320: LD_INT 1
37322: ARRAY
37323: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37324: LD_ADDR_VAR 0 7
37328: PUSH
37329: LD_EXP 78
37333: PUSH
37334: LD_VAR 0 2
37338: ARRAY
37339: PPUSH
37340: LD_INT 22
37342: PUSH
37343: LD_INT 0
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 25
37352: PUSH
37353: LD_INT 12
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PPUSH
37364: CALL_OW 70
37368: PUSH
37369: LD_INT 22
37371: PUSH
37372: LD_INT 0
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 25
37381: PUSH
37382: LD_INT 12
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 91
37391: PUSH
37392: LD_VAR 0 9
37396: PUSH
37397: LD_INT 20
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PPUSH
37410: CALL_OW 69
37414: UNION
37415: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37416: LD_ADDR_VAR 0 10
37420: PUSH
37421: LD_EXP 78
37425: PUSH
37426: LD_VAR 0 2
37430: ARRAY
37431: PPUSH
37432: LD_INT 81
37434: PUSH
37435: LD_VAR 0 11
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PPUSH
37444: CALL_OW 70
37448: ST_TO_ADDR
// if not apes or danger_at_area then
37449: LD_VAR 0 7
37453: NOT
37454: PUSH
37455: LD_VAR 0 10
37459: OR
37460: IFFALSE 37510
// begin if mc_taming [ i ] then
37462: LD_EXP 81
37466: PUSH
37467: LD_VAR 0 2
37471: ARRAY
37472: IFFALSE 37508
// begin MC_Reset ( i , 121 ) ;
37474: LD_VAR 0 2
37478: PPUSH
37479: LD_INT 121
37481: PPUSH
37482: CALL 22426 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37486: LD_ADDR_EXP 81
37490: PUSH
37491: LD_EXP 81
37495: PPUSH
37496: LD_VAR 0 2
37500: PPUSH
37501: EMPTY
37502: PPUSH
37503: CALL_OW 1
37507: ST_TO_ADDR
// end ; continue ;
37508: GO 37076
// end ; for j in tmp do
37510: LD_ADDR_VAR 0 3
37514: PUSH
37515: LD_VAR 0 8
37519: PUSH
37520: FOR_IN
37521: IFFALSE 37857
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37523: LD_VAR 0 3
37527: PUSH
37528: LD_EXP 81
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: IN
37539: NOT
37540: PUSH
37541: LD_EXP 81
37545: PUSH
37546: LD_VAR 0 2
37550: ARRAY
37551: PUSH
37552: LD_INT 3
37554: LESS
37555: AND
37556: IFFALSE 37614
// begin SetTag ( j , 121 ) ;
37558: LD_VAR 0 3
37562: PPUSH
37563: LD_INT 121
37565: PPUSH
37566: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37570: LD_ADDR_EXP 81
37574: PUSH
37575: LD_EXP 81
37579: PPUSH
37580: LD_VAR 0 2
37584: PUSH
37585: LD_EXP 81
37589: PUSH
37590: LD_VAR 0 2
37594: ARRAY
37595: PUSH
37596: LD_INT 1
37598: PLUS
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PPUSH
37604: LD_VAR 0 3
37608: PPUSH
37609: CALL 54011 0 3
37613: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37614: LD_VAR 0 3
37618: PUSH
37619: LD_EXP 81
37623: PUSH
37624: LD_VAR 0 2
37628: ARRAY
37629: IN
37630: IFFALSE 37855
// begin if GetClass ( j ) <> 4 then
37632: LD_VAR 0 3
37636: PPUSH
37637: CALL_OW 257
37641: PUSH
37642: LD_INT 4
37644: NONEQUAL
37645: IFFALSE 37698
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37647: LD_ADDR_EXP 81
37651: PUSH
37652: LD_EXP 81
37656: PPUSH
37657: LD_VAR 0 2
37661: PPUSH
37662: LD_EXP 81
37666: PUSH
37667: LD_VAR 0 2
37671: ARRAY
37672: PUSH
37673: LD_VAR 0 3
37677: DIFF
37678: PPUSH
37679: CALL_OW 1
37683: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37684: LD_VAR 0 3
37688: PPUSH
37689: LD_INT 0
37691: PPUSH
37692: CALL_OW 109
// continue ;
37696: GO 37520
// end ; if IsInUnit ( j ) then
37698: LD_VAR 0 3
37702: PPUSH
37703: CALL_OW 310
37707: IFFALSE 37718
// ComExitBuilding ( j ) ;
37709: LD_VAR 0 3
37713: PPUSH
37714: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37718: LD_ADDR_VAR 0 6
37722: PUSH
37723: LD_VAR 0 7
37727: PPUSH
37728: LD_VAR 0 3
37732: PPUSH
37733: CALL_OW 74
37737: ST_TO_ADDR
// if not ape then
37738: LD_VAR 0 6
37742: NOT
37743: IFFALSE 37747
// break ;
37745: GO 37857
// x := GetX ( ape ) ;
37747: LD_ADDR_VAR 0 4
37751: PUSH
37752: LD_VAR 0 6
37756: PPUSH
37757: CALL_OW 250
37761: ST_TO_ADDR
// y := GetY ( ape ) ;
37762: LD_ADDR_VAR 0 5
37766: PUSH
37767: LD_VAR 0 6
37771: PPUSH
37772: CALL_OW 251
37776: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37777: LD_VAR 0 4
37781: PPUSH
37782: LD_VAR 0 5
37786: PPUSH
37787: CALL_OW 488
37791: NOT
37792: PUSH
37793: LD_VAR 0 11
37797: PPUSH
37798: LD_VAR 0 4
37802: PPUSH
37803: LD_VAR 0 5
37807: PPUSH
37808: LD_INT 20
37810: PPUSH
37811: CALL 55275 0 4
37815: PUSH
37816: LD_INT 4
37818: ARRAY
37819: OR
37820: IFFALSE 37824
// break ;
37822: GO 37857
// if not HasTask ( j ) then
37824: LD_VAR 0 3
37828: PPUSH
37829: CALL_OW 314
37833: NOT
37834: IFFALSE 37855
// ComTameXY ( j , x , y ) ;
37836: LD_VAR 0 3
37840: PPUSH
37841: LD_VAR 0 4
37845: PPUSH
37846: LD_VAR 0 5
37850: PPUSH
37851: CALL_OW 131
// end ; end ;
37855: GO 37520
37857: POP
37858: POP
// end ;
37859: GO 37076
37861: POP
37862: POP
// end ;
37863: LD_VAR 0 1
37867: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37868: LD_INT 0
37870: PPUSH
37871: PPUSH
37872: PPUSH
37873: PPUSH
37874: PPUSH
37875: PPUSH
37876: PPUSH
37877: PPUSH
// if not mc_bases then
37878: LD_EXP 50
37882: NOT
37883: IFFALSE 37887
// exit ;
37885: GO 38513
// for i = 1 to mc_bases do
37887: LD_ADDR_VAR 0 2
37891: PUSH
37892: DOUBLE
37893: LD_INT 1
37895: DEC
37896: ST_TO_ADDR
37897: LD_EXP 50
37901: PUSH
37902: FOR_TO
37903: IFFALSE 38511
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37905: LD_EXP 79
37909: PUSH
37910: LD_VAR 0 2
37914: ARRAY
37915: NOT
37916: PUSH
37917: LD_EXP 79
37921: PUSH
37922: LD_VAR 0 2
37926: ARRAY
37927: PPUSH
37928: LD_INT 25
37930: PUSH
37931: LD_INT 12
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PPUSH
37938: CALL_OW 72
37942: NOT
37943: OR
37944: IFFALSE 37948
// continue ;
37946: GO 37902
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37948: LD_ADDR_VAR 0 5
37952: PUSH
37953: LD_EXP 79
37957: PUSH
37958: LD_VAR 0 2
37962: ARRAY
37963: PUSH
37964: LD_INT 1
37966: ARRAY
37967: PPUSH
37968: CALL_OW 255
37972: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37973: LD_VAR 0 5
37977: PPUSH
37978: LD_INT 2
37980: PPUSH
37981: CALL_OW 325
37985: IFFALSE 38238
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37987: LD_ADDR_VAR 0 4
37991: PUSH
37992: LD_EXP 79
37996: PUSH
37997: LD_VAR 0 2
38001: ARRAY
38002: PPUSH
38003: LD_INT 25
38005: PUSH
38006: LD_INT 16
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PPUSH
38013: CALL_OW 72
38017: ST_TO_ADDR
// if tmp < 6 then
38018: LD_VAR 0 4
38022: PUSH
38023: LD_INT 6
38025: LESS
38026: IFFALSE 38238
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38028: LD_ADDR_VAR 0 6
38032: PUSH
38033: LD_EXP 50
38037: PUSH
38038: LD_VAR 0 2
38042: ARRAY
38043: PPUSH
38044: LD_INT 2
38046: PUSH
38047: LD_INT 30
38049: PUSH
38050: LD_INT 0
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 30
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: LIST
38071: PPUSH
38072: CALL_OW 72
38076: ST_TO_ADDR
// if depot then
38077: LD_VAR 0 6
38081: IFFALSE 38238
// begin selected := 0 ;
38083: LD_ADDR_VAR 0 7
38087: PUSH
38088: LD_INT 0
38090: ST_TO_ADDR
// for j in depot do
38091: LD_ADDR_VAR 0 3
38095: PUSH
38096: LD_VAR 0 6
38100: PUSH
38101: FOR_IN
38102: IFFALSE 38133
// begin if UnitsInside ( j ) < 6 then
38104: LD_VAR 0 3
38108: PPUSH
38109: CALL_OW 313
38113: PUSH
38114: LD_INT 6
38116: LESS
38117: IFFALSE 38131
// begin selected := j ;
38119: LD_ADDR_VAR 0 7
38123: PUSH
38124: LD_VAR 0 3
38128: ST_TO_ADDR
// break ;
38129: GO 38133
// end ; end ;
38131: GO 38101
38133: POP
38134: POP
// if selected then
38135: LD_VAR 0 7
38139: IFFALSE 38238
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38141: LD_ADDR_VAR 0 3
38145: PUSH
38146: LD_EXP 79
38150: PUSH
38151: LD_VAR 0 2
38155: ARRAY
38156: PPUSH
38157: LD_INT 25
38159: PUSH
38160: LD_INT 12
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PPUSH
38167: CALL_OW 72
38171: PUSH
38172: FOR_IN
38173: IFFALSE 38236
// if not HasTask ( j ) then
38175: LD_VAR 0 3
38179: PPUSH
38180: CALL_OW 314
38184: NOT
38185: IFFALSE 38234
// begin if not IsInUnit ( j ) then
38187: LD_VAR 0 3
38191: PPUSH
38192: CALL_OW 310
38196: NOT
38197: IFFALSE 38213
// ComEnterUnit ( j , selected ) ;
38199: LD_VAR 0 3
38203: PPUSH
38204: LD_VAR 0 7
38208: PPUSH
38209: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38213: LD_VAR 0 3
38217: PPUSH
38218: LD_INT 16
38220: PPUSH
38221: CALL_OW 183
// AddComExitBuilding ( j ) ;
38225: LD_VAR 0 3
38229: PPUSH
38230: CALL_OW 182
// end ;
38234: GO 38172
38236: POP
38237: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38238: LD_VAR 0 5
38242: PPUSH
38243: LD_INT 11
38245: PPUSH
38246: CALL_OW 325
38250: IFFALSE 38509
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38252: LD_ADDR_VAR 0 4
38256: PUSH
38257: LD_EXP 79
38261: PUSH
38262: LD_VAR 0 2
38266: ARRAY
38267: PPUSH
38268: LD_INT 25
38270: PUSH
38271: LD_INT 16
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PPUSH
38278: CALL_OW 72
38282: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38283: LD_VAR 0 4
38287: PUSH
38288: LD_INT 6
38290: GREATEREQUAL
38291: PUSH
38292: LD_VAR 0 5
38296: PPUSH
38297: LD_INT 2
38299: PPUSH
38300: CALL_OW 325
38304: NOT
38305: OR
38306: IFFALSE 38509
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38308: LD_ADDR_VAR 0 8
38312: PUSH
38313: LD_EXP 50
38317: PUSH
38318: LD_VAR 0 2
38322: ARRAY
38323: PPUSH
38324: LD_INT 2
38326: PUSH
38327: LD_INT 30
38329: PUSH
38330: LD_INT 4
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 30
38339: PUSH
38340: LD_INT 5
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: LIST
38351: PPUSH
38352: CALL_OW 72
38356: ST_TO_ADDR
// if barracks then
38357: LD_VAR 0 8
38361: IFFALSE 38509
// begin selected := 0 ;
38363: LD_ADDR_VAR 0 7
38367: PUSH
38368: LD_INT 0
38370: ST_TO_ADDR
// for j in barracks do
38371: LD_ADDR_VAR 0 3
38375: PUSH
38376: LD_VAR 0 8
38380: PUSH
38381: FOR_IN
38382: IFFALSE 38413
// begin if UnitsInside ( j ) < 6 then
38384: LD_VAR 0 3
38388: PPUSH
38389: CALL_OW 313
38393: PUSH
38394: LD_INT 6
38396: LESS
38397: IFFALSE 38411
// begin selected := j ;
38399: LD_ADDR_VAR 0 7
38403: PUSH
38404: LD_VAR 0 3
38408: ST_TO_ADDR
// break ;
38409: GO 38413
// end ; end ;
38411: GO 38381
38413: POP
38414: POP
// if selected then
38415: LD_VAR 0 7
38419: IFFALSE 38509
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38421: LD_ADDR_VAR 0 3
38425: PUSH
38426: LD_EXP 79
38430: PUSH
38431: LD_VAR 0 2
38435: ARRAY
38436: PPUSH
38437: LD_INT 25
38439: PUSH
38440: LD_INT 12
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PPUSH
38447: CALL_OW 72
38451: PUSH
38452: FOR_IN
38453: IFFALSE 38507
// if not IsInUnit ( j ) and not HasTask ( j ) then
38455: LD_VAR 0 3
38459: PPUSH
38460: CALL_OW 310
38464: NOT
38465: PUSH
38466: LD_VAR 0 3
38470: PPUSH
38471: CALL_OW 314
38475: NOT
38476: AND
38477: IFFALSE 38505
// begin ComEnterUnit ( j , selected ) ;
38479: LD_VAR 0 3
38483: PPUSH
38484: LD_VAR 0 7
38488: PPUSH
38489: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38493: LD_VAR 0 3
38497: PPUSH
38498: LD_INT 15
38500: PPUSH
38501: CALL_OW 183
// end ;
38505: GO 38452
38507: POP
38508: POP
// end ; end ; end ; end ; end ;
38509: GO 37902
38511: POP
38512: POP
// end ;
38513: LD_VAR 0 1
38517: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38518: LD_INT 0
38520: PPUSH
38521: PPUSH
38522: PPUSH
38523: PPUSH
// if not mc_bases then
38524: LD_EXP 50
38528: NOT
38529: IFFALSE 38533
// exit ;
38531: GO 38711
// for i = 1 to mc_bases do
38533: LD_ADDR_VAR 0 2
38537: PUSH
38538: DOUBLE
38539: LD_INT 1
38541: DEC
38542: ST_TO_ADDR
38543: LD_EXP 50
38547: PUSH
38548: FOR_TO
38549: IFFALSE 38709
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38551: LD_ADDR_VAR 0 4
38555: PUSH
38556: LD_EXP 50
38560: PUSH
38561: LD_VAR 0 2
38565: ARRAY
38566: PPUSH
38567: LD_INT 25
38569: PUSH
38570: LD_INT 9
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PPUSH
38577: CALL_OW 72
38581: ST_TO_ADDR
// if not tmp then
38582: LD_VAR 0 4
38586: NOT
38587: IFFALSE 38591
// continue ;
38589: GO 38548
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38591: LD_EXP 76
38595: PUSH
38596: LD_VAR 0 2
38600: ARRAY
38601: PPUSH
38602: LD_INT 29
38604: PPUSH
38605: CALL_OW 325
38609: NOT
38610: PUSH
38611: LD_EXP 76
38615: PUSH
38616: LD_VAR 0 2
38620: ARRAY
38621: PPUSH
38622: LD_INT 28
38624: PPUSH
38625: CALL_OW 325
38629: NOT
38630: AND
38631: IFFALSE 38635
// continue ;
38633: GO 38548
// for j in tmp do
38635: LD_ADDR_VAR 0 3
38639: PUSH
38640: LD_VAR 0 4
38644: PUSH
38645: FOR_IN
38646: IFFALSE 38705
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38648: LD_VAR 0 3
38652: PUSH
38653: LD_EXP 53
38657: PUSH
38658: LD_VAR 0 2
38662: ARRAY
38663: PUSH
38664: LD_INT 1
38666: ARRAY
38667: IN
38668: NOT
38669: PUSH
38670: LD_VAR 0 3
38674: PUSH
38675: LD_EXP 53
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: PUSH
38686: LD_INT 2
38688: ARRAY
38689: IN
38690: NOT
38691: AND
38692: IFFALSE 38703
// ComSpaceTimeShoot ( j ) ;
38694: LD_VAR 0 3
38698: PPUSH
38699: CALL 49996 0 1
38703: GO 38645
38705: POP
38706: POP
// end ;
38707: GO 38548
38709: POP
38710: POP
// end ;
38711: LD_VAR 0 1
38715: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38716: LD_INT 0
38718: PPUSH
38719: PPUSH
38720: PPUSH
38721: PPUSH
38722: PPUSH
38723: PPUSH
38724: PPUSH
38725: PPUSH
38726: PPUSH
// if not mc_bases then
38727: LD_EXP 50
38731: NOT
38732: IFFALSE 38736
// exit ;
38734: GO 39358
// for i = 1 to mc_bases do
38736: LD_ADDR_VAR 0 2
38740: PUSH
38741: DOUBLE
38742: LD_INT 1
38744: DEC
38745: ST_TO_ADDR
38746: LD_EXP 50
38750: PUSH
38751: FOR_TO
38752: IFFALSE 39356
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38754: LD_EXP 85
38758: PUSH
38759: LD_VAR 0 2
38763: ARRAY
38764: NOT
38765: PUSH
38766: LD_INT 38
38768: PPUSH
38769: LD_EXP 76
38773: PUSH
38774: LD_VAR 0 2
38778: ARRAY
38779: PPUSH
38780: CALL_OW 321
38784: PUSH
38785: LD_INT 2
38787: NONEQUAL
38788: OR
38789: IFFALSE 38793
// continue ;
38791: GO 38751
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38793: LD_ADDR_VAR 0 8
38797: PUSH
38798: LD_EXP 50
38802: PUSH
38803: LD_VAR 0 2
38807: ARRAY
38808: PPUSH
38809: LD_INT 30
38811: PUSH
38812: LD_INT 34
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PPUSH
38819: CALL_OW 72
38823: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38824: LD_ADDR_VAR 0 9
38828: PUSH
38829: LD_EXP 50
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PPUSH
38840: LD_INT 25
38842: PUSH
38843: LD_INT 4
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PPUSH
38850: CALL_OW 72
38854: PPUSH
38855: LD_INT 0
38857: PPUSH
38858: CALL 84329 0 2
38862: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38863: LD_VAR 0 9
38867: NOT
38868: PUSH
38869: LD_VAR 0 8
38873: NOT
38874: OR
38875: PUSH
38876: LD_EXP 50
38880: PUSH
38881: LD_VAR 0 2
38885: ARRAY
38886: PPUSH
38887: LD_INT 124
38889: PPUSH
38890: CALL 84329 0 2
38894: OR
38895: IFFALSE 38899
// continue ;
38897: GO 38751
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38899: LD_EXP 86
38903: PUSH
38904: LD_VAR 0 2
38908: ARRAY
38909: PUSH
38910: LD_EXP 85
38914: PUSH
38915: LD_VAR 0 2
38919: ARRAY
38920: LESS
38921: PUSH
38922: LD_EXP 86
38926: PUSH
38927: LD_VAR 0 2
38931: ARRAY
38932: PUSH
38933: LD_VAR 0 8
38937: LESS
38938: AND
38939: IFFALSE 39354
// begin tmp := sci [ 1 ] ;
38941: LD_ADDR_VAR 0 7
38945: PUSH
38946: LD_VAR 0 9
38950: PUSH
38951: LD_INT 1
38953: ARRAY
38954: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38955: LD_VAR 0 7
38959: PPUSH
38960: LD_INT 124
38962: PPUSH
38963: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38967: LD_ADDR_VAR 0 3
38971: PUSH
38972: DOUBLE
38973: LD_EXP 85
38977: PUSH
38978: LD_VAR 0 2
38982: ARRAY
38983: INC
38984: ST_TO_ADDR
38985: LD_EXP 85
38989: PUSH
38990: LD_VAR 0 2
38994: ARRAY
38995: PUSH
38996: FOR_DOWNTO
38997: IFFALSE 39340
// begin if IsInUnit ( tmp ) then
38999: LD_VAR 0 7
39003: PPUSH
39004: CALL_OW 310
39008: IFFALSE 39019
// ComExitBuilding ( tmp ) ;
39010: LD_VAR 0 7
39014: PPUSH
39015: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39019: LD_INT 35
39021: PPUSH
39022: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39026: LD_VAR 0 7
39030: PPUSH
39031: CALL_OW 310
39035: NOT
39036: PUSH
39037: LD_VAR 0 7
39041: PPUSH
39042: CALL_OW 314
39046: NOT
39047: AND
39048: IFFALSE 39019
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39050: LD_ADDR_VAR 0 6
39054: PUSH
39055: LD_VAR 0 7
39059: PPUSH
39060: CALL_OW 250
39064: PUSH
39065: LD_VAR 0 7
39069: PPUSH
39070: CALL_OW 251
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39079: LD_INT 35
39081: PPUSH
39082: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39086: LD_ADDR_VAR 0 4
39090: PUSH
39091: LD_EXP 85
39095: PUSH
39096: LD_VAR 0 2
39100: ARRAY
39101: PUSH
39102: LD_VAR 0 3
39106: ARRAY
39107: PUSH
39108: LD_INT 1
39110: ARRAY
39111: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39112: LD_ADDR_VAR 0 5
39116: PUSH
39117: LD_EXP 85
39121: PUSH
39122: LD_VAR 0 2
39126: ARRAY
39127: PUSH
39128: LD_VAR 0 3
39132: ARRAY
39133: PUSH
39134: LD_INT 2
39136: ARRAY
39137: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39138: LD_VAR 0 7
39142: PPUSH
39143: LD_INT 10
39145: PPUSH
39146: CALL 56976 0 2
39150: PUSH
39151: LD_INT 4
39153: ARRAY
39154: IFFALSE 39192
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39156: LD_VAR 0 7
39160: PPUSH
39161: LD_VAR 0 6
39165: PUSH
39166: LD_INT 1
39168: ARRAY
39169: PPUSH
39170: LD_VAR 0 6
39174: PUSH
39175: LD_INT 2
39177: ARRAY
39178: PPUSH
39179: CALL_OW 111
// wait ( 0 0$10 ) ;
39183: LD_INT 350
39185: PPUSH
39186: CALL_OW 67
// end else
39190: GO 39218
// begin ComMoveXY ( tmp , x , y ) ;
39192: LD_VAR 0 7
39196: PPUSH
39197: LD_VAR 0 4
39201: PPUSH
39202: LD_VAR 0 5
39206: PPUSH
39207: CALL_OW 111
// wait ( 0 0$3 ) ;
39211: LD_INT 105
39213: PPUSH
39214: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39218: LD_VAR 0 7
39222: PPUSH
39223: LD_VAR 0 4
39227: PPUSH
39228: LD_VAR 0 5
39232: PPUSH
39233: CALL_OW 307
39237: IFFALSE 39079
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39239: LD_VAR 0 7
39243: PPUSH
39244: LD_VAR 0 4
39248: PPUSH
39249: LD_VAR 0 5
39253: PPUSH
39254: LD_VAR 0 8
39258: PUSH
39259: LD_VAR 0 3
39263: ARRAY
39264: PPUSH
39265: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39269: LD_INT 35
39271: PPUSH
39272: CALL_OW 67
// until not HasTask ( tmp ) ;
39276: LD_VAR 0 7
39280: PPUSH
39281: CALL_OW 314
39285: NOT
39286: IFFALSE 39269
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39288: LD_ADDR_EXP 86
39292: PUSH
39293: LD_EXP 86
39297: PPUSH
39298: LD_VAR 0 2
39302: PUSH
39303: LD_EXP 86
39307: PUSH
39308: LD_VAR 0 2
39312: ARRAY
39313: PUSH
39314: LD_INT 1
39316: PLUS
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PPUSH
39322: LD_VAR 0 8
39326: PUSH
39327: LD_VAR 0 3
39331: ARRAY
39332: PPUSH
39333: CALL 54011 0 3
39337: ST_TO_ADDR
// end ;
39338: GO 38996
39340: POP
39341: POP
// MC_Reset ( i , 124 ) ;
39342: LD_VAR 0 2
39346: PPUSH
39347: LD_INT 124
39349: PPUSH
39350: CALL 22426 0 2
// end ; end ;
39354: GO 38751
39356: POP
39357: POP
// end ;
39358: LD_VAR 0 1
39362: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39363: LD_INT 0
39365: PPUSH
39366: PPUSH
39367: PPUSH
// if not mc_bases then
39368: LD_EXP 50
39372: NOT
39373: IFFALSE 39377
// exit ;
39375: GO 39983
// for i = 1 to mc_bases do
39377: LD_ADDR_VAR 0 2
39381: PUSH
39382: DOUBLE
39383: LD_INT 1
39385: DEC
39386: ST_TO_ADDR
39387: LD_EXP 50
39391: PUSH
39392: FOR_TO
39393: IFFALSE 39981
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39395: LD_ADDR_VAR 0 3
39399: PUSH
39400: LD_EXP 50
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: PPUSH
39411: LD_INT 25
39413: PUSH
39414: LD_INT 4
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PPUSH
39421: CALL_OW 72
39425: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39426: LD_VAR 0 3
39430: NOT
39431: PUSH
39432: LD_EXP 87
39436: PUSH
39437: LD_VAR 0 2
39441: ARRAY
39442: NOT
39443: OR
39444: PUSH
39445: LD_EXP 50
39449: PUSH
39450: LD_VAR 0 2
39454: ARRAY
39455: PPUSH
39456: LD_INT 2
39458: PUSH
39459: LD_INT 30
39461: PUSH
39462: LD_INT 0
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 30
39471: PUSH
39472: LD_INT 1
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: LIST
39483: PPUSH
39484: CALL_OW 72
39488: NOT
39489: OR
39490: IFFALSE 39540
// begin if mc_deposits_finder [ i ] then
39492: LD_EXP 88
39496: PUSH
39497: LD_VAR 0 2
39501: ARRAY
39502: IFFALSE 39538
// begin MC_Reset ( i , 125 ) ;
39504: LD_VAR 0 2
39508: PPUSH
39509: LD_INT 125
39511: PPUSH
39512: CALL 22426 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39516: LD_ADDR_EXP 88
39520: PUSH
39521: LD_EXP 88
39525: PPUSH
39526: LD_VAR 0 2
39530: PPUSH
39531: EMPTY
39532: PPUSH
39533: CALL_OW 1
39537: ST_TO_ADDR
// end ; continue ;
39538: GO 39392
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39540: LD_EXP 87
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PUSH
39551: LD_INT 1
39553: ARRAY
39554: PUSH
39555: LD_INT 3
39557: ARRAY
39558: PUSH
39559: LD_INT 1
39561: EQUAL
39562: PUSH
39563: LD_INT 20
39565: PPUSH
39566: LD_EXP 76
39570: PUSH
39571: LD_VAR 0 2
39575: ARRAY
39576: PPUSH
39577: CALL_OW 321
39581: PUSH
39582: LD_INT 2
39584: NONEQUAL
39585: AND
39586: IFFALSE 39636
// begin if mc_deposits_finder [ i ] then
39588: LD_EXP 88
39592: PUSH
39593: LD_VAR 0 2
39597: ARRAY
39598: IFFALSE 39634
// begin MC_Reset ( i , 125 ) ;
39600: LD_VAR 0 2
39604: PPUSH
39605: LD_INT 125
39607: PPUSH
39608: CALL 22426 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39612: LD_ADDR_EXP 88
39616: PUSH
39617: LD_EXP 88
39621: PPUSH
39622: LD_VAR 0 2
39626: PPUSH
39627: EMPTY
39628: PPUSH
39629: CALL_OW 1
39633: ST_TO_ADDR
// end ; continue ;
39634: GO 39392
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39636: LD_EXP 87
39640: PUSH
39641: LD_VAR 0 2
39645: ARRAY
39646: PUSH
39647: LD_INT 1
39649: ARRAY
39650: PUSH
39651: LD_INT 1
39653: ARRAY
39654: PPUSH
39655: LD_EXP 87
39659: PUSH
39660: LD_VAR 0 2
39664: ARRAY
39665: PUSH
39666: LD_INT 1
39668: ARRAY
39669: PUSH
39670: LD_INT 2
39672: ARRAY
39673: PPUSH
39674: LD_EXP 76
39678: PUSH
39679: LD_VAR 0 2
39683: ARRAY
39684: PPUSH
39685: CALL_OW 440
39689: IFFALSE 39732
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39691: LD_ADDR_EXP 87
39695: PUSH
39696: LD_EXP 87
39700: PPUSH
39701: LD_VAR 0 2
39705: PPUSH
39706: LD_EXP 87
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: LD_INT 1
39719: PPUSH
39720: CALL_OW 3
39724: PPUSH
39725: CALL_OW 1
39729: ST_TO_ADDR
39730: GO 39979
// begin if not mc_deposits_finder [ i ] then
39732: LD_EXP 88
39736: PUSH
39737: LD_VAR 0 2
39741: ARRAY
39742: NOT
39743: IFFALSE 39795
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39745: LD_ADDR_EXP 88
39749: PUSH
39750: LD_EXP 88
39754: PPUSH
39755: LD_VAR 0 2
39759: PPUSH
39760: LD_VAR 0 3
39764: PUSH
39765: LD_INT 1
39767: ARRAY
39768: PUSH
39769: EMPTY
39770: LIST
39771: PPUSH
39772: CALL_OW 1
39776: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39777: LD_VAR 0 3
39781: PUSH
39782: LD_INT 1
39784: ARRAY
39785: PPUSH
39786: LD_INT 125
39788: PPUSH
39789: CALL_OW 109
// end else
39793: GO 39979
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39795: LD_EXP 88
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_INT 1
39808: ARRAY
39809: PPUSH
39810: CALL_OW 310
39814: IFFALSE 39837
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39816: LD_EXP 88
39820: PUSH
39821: LD_VAR 0 2
39825: ARRAY
39826: PUSH
39827: LD_INT 1
39829: ARRAY
39830: PPUSH
39831: CALL_OW 122
39835: GO 39979
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39837: LD_EXP 88
39841: PUSH
39842: LD_VAR 0 2
39846: ARRAY
39847: PUSH
39848: LD_INT 1
39850: ARRAY
39851: PPUSH
39852: CALL_OW 314
39856: NOT
39857: PUSH
39858: LD_EXP 88
39862: PUSH
39863: LD_VAR 0 2
39867: ARRAY
39868: PUSH
39869: LD_INT 1
39871: ARRAY
39872: PPUSH
39873: LD_EXP 87
39877: PUSH
39878: LD_VAR 0 2
39882: ARRAY
39883: PUSH
39884: LD_INT 1
39886: ARRAY
39887: PUSH
39888: LD_INT 1
39890: ARRAY
39891: PPUSH
39892: LD_EXP 87
39896: PUSH
39897: LD_VAR 0 2
39901: ARRAY
39902: PUSH
39903: LD_INT 1
39905: ARRAY
39906: PUSH
39907: LD_INT 2
39909: ARRAY
39910: PPUSH
39911: CALL_OW 297
39915: PUSH
39916: LD_INT 6
39918: GREATER
39919: AND
39920: IFFALSE 39979
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39922: LD_EXP 88
39926: PUSH
39927: LD_VAR 0 2
39931: ARRAY
39932: PUSH
39933: LD_INT 1
39935: ARRAY
39936: PPUSH
39937: LD_EXP 87
39941: PUSH
39942: LD_VAR 0 2
39946: ARRAY
39947: PUSH
39948: LD_INT 1
39950: ARRAY
39951: PUSH
39952: LD_INT 1
39954: ARRAY
39955: PPUSH
39956: LD_EXP 87
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PUSH
39967: LD_INT 1
39969: ARRAY
39970: PUSH
39971: LD_INT 2
39973: ARRAY
39974: PPUSH
39975: CALL_OW 111
// end ; end ; end ;
39979: GO 39392
39981: POP
39982: POP
// end ;
39983: LD_VAR 0 1
39987: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39988: LD_INT 0
39990: PPUSH
39991: PPUSH
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
39997: PPUSH
39998: PPUSH
39999: PPUSH
40000: PPUSH
// if not mc_bases then
40001: LD_EXP 50
40005: NOT
40006: IFFALSE 40010
// exit ;
40008: GO 40950
// for i = 1 to mc_bases do
40010: LD_ADDR_VAR 0 2
40014: PUSH
40015: DOUBLE
40016: LD_INT 1
40018: DEC
40019: ST_TO_ADDR
40020: LD_EXP 50
40024: PUSH
40025: FOR_TO
40026: IFFALSE 40948
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40028: LD_EXP 50
40032: PUSH
40033: LD_VAR 0 2
40037: ARRAY
40038: NOT
40039: PUSH
40040: LD_EXP 73
40044: PUSH
40045: LD_VAR 0 2
40049: ARRAY
40050: OR
40051: IFFALSE 40055
// continue ;
40053: GO 40025
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40055: LD_ADDR_VAR 0 7
40059: PUSH
40060: LD_EXP 50
40064: PUSH
40065: LD_VAR 0 2
40069: ARRAY
40070: PUSH
40071: LD_INT 1
40073: ARRAY
40074: PPUSH
40075: CALL_OW 248
40079: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40080: LD_VAR 0 7
40084: PUSH
40085: LD_INT 3
40087: EQUAL
40088: PUSH
40089: LD_EXP 69
40093: PUSH
40094: LD_VAR 0 2
40098: ARRAY
40099: PUSH
40100: LD_EXP 72
40104: PUSH
40105: LD_VAR 0 2
40109: ARRAY
40110: UNION
40111: PPUSH
40112: LD_INT 33
40114: PUSH
40115: LD_INT 2
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PPUSH
40122: CALL_OW 72
40126: NOT
40127: OR
40128: IFFALSE 40132
// continue ;
40130: GO 40025
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40132: LD_ADDR_VAR 0 9
40136: PUSH
40137: LD_EXP 50
40141: PUSH
40142: LD_VAR 0 2
40146: ARRAY
40147: PPUSH
40148: LD_INT 30
40150: PUSH
40151: LD_INT 36
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PPUSH
40158: CALL_OW 72
40162: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40163: LD_ADDR_VAR 0 10
40167: PUSH
40168: LD_EXP 69
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: PPUSH
40179: LD_INT 34
40181: PUSH
40182: LD_INT 31
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PPUSH
40189: CALL_OW 72
40193: ST_TO_ADDR
// if not cts and not mcts then
40194: LD_VAR 0 9
40198: NOT
40199: PUSH
40200: LD_VAR 0 10
40204: NOT
40205: AND
40206: IFFALSE 40210
// continue ;
40208: GO 40025
// x := cts ;
40210: LD_ADDR_VAR 0 11
40214: PUSH
40215: LD_VAR 0 9
40219: ST_TO_ADDR
// if not x then
40220: LD_VAR 0 11
40224: NOT
40225: IFFALSE 40237
// x := mcts ;
40227: LD_ADDR_VAR 0 11
40231: PUSH
40232: LD_VAR 0 10
40236: ST_TO_ADDR
// if not x then
40237: LD_VAR 0 11
40241: NOT
40242: IFFALSE 40246
// continue ;
40244: GO 40025
// if mc_remote_driver [ i ] then
40246: LD_EXP 90
40250: PUSH
40251: LD_VAR 0 2
40255: ARRAY
40256: IFFALSE 40643
// for j in mc_remote_driver [ i ] do
40258: LD_ADDR_VAR 0 3
40262: PUSH
40263: LD_EXP 90
40267: PUSH
40268: LD_VAR 0 2
40272: ARRAY
40273: PUSH
40274: FOR_IN
40275: IFFALSE 40641
// begin if GetClass ( j ) <> 3 then
40277: LD_VAR 0 3
40281: PPUSH
40282: CALL_OW 257
40286: PUSH
40287: LD_INT 3
40289: NONEQUAL
40290: IFFALSE 40343
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40292: LD_ADDR_EXP 90
40296: PUSH
40297: LD_EXP 90
40301: PPUSH
40302: LD_VAR 0 2
40306: PPUSH
40307: LD_EXP 90
40311: PUSH
40312: LD_VAR 0 2
40316: ARRAY
40317: PUSH
40318: LD_VAR 0 3
40322: DIFF
40323: PPUSH
40324: CALL_OW 1
40328: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40329: LD_VAR 0 3
40333: PPUSH
40334: LD_INT 0
40336: PPUSH
40337: CALL_OW 109
// continue ;
40341: GO 40274
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40343: LD_EXP 69
40347: PUSH
40348: LD_VAR 0 2
40352: ARRAY
40353: PPUSH
40354: LD_INT 34
40356: PUSH
40357: LD_INT 31
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 58
40366: PUSH
40367: EMPTY
40368: LIST
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PPUSH
40374: CALL_OW 72
40378: PUSH
40379: LD_VAR 0 3
40383: PPUSH
40384: CALL 84364 0 1
40388: NOT
40389: AND
40390: IFFALSE 40461
// begin if IsInUnit ( j ) then
40392: LD_VAR 0 3
40396: PPUSH
40397: CALL_OW 310
40401: IFFALSE 40412
// ComExitBuilding ( j ) ;
40403: LD_VAR 0 3
40407: PPUSH
40408: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40412: LD_VAR 0 3
40416: PPUSH
40417: LD_EXP 69
40421: PUSH
40422: LD_VAR 0 2
40426: ARRAY
40427: PPUSH
40428: LD_INT 34
40430: PUSH
40431: LD_INT 31
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 58
40440: PUSH
40441: EMPTY
40442: LIST
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PPUSH
40448: CALL_OW 72
40452: PUSH
40453: LD_INT 1
40455: ARRAY
40456: PPUSH
40457: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40461: LD_VAR 0 3
40465: PPUSH
40466: CALL_OW 310
40470: NOT
40471: PUSH
40472: LD_VAR 0 3
40476: PPUSH
40477: CALL_OW 310
40481: PPUSH
40482: CALL_OW 266
40486: PUSH
40487: LD_INT 36
40489: NONEQUAL
40490: PUSH
40491: LD_VAR 0 3
40495: PPUSH
40496: CALL 84364 0 1
40500: NOT
40501: AND
40502: OR
40503: IFFALSE 40639
// begin if IsInUnit ( j ) then
40505: LD_VAR 0 3
40509: PPUSH
40510: CALL_OW 310
40514: IFFALSE 40525
// ComExitBuilding ( j ) ;
40516: LD_VAR 0 3
40520: PPUSH
40521: CALL_OW 122
// ct := 0 ;
40525: LD_ADDR_VAR 0 8
40529: PUSH
40530: LD_INT 0
40532: ST_TO_ADDR
// for k in x do
40533: LD_ADDR_VAR 0 4
40537: PUSH
40538: LD_VAR 0 11
40542: PUSH
40543: FOR_IN
40544: IFFALSE 40617
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40546: LD_VAR 0 4
40550: PPUSH
40551: CALL_OW 264
40555: PUSH
40556: LD_INT 31
40558: EQUAL
40559: PUSH
40560: LD_VAR 0 4
40564: PPUSH
40565: CALL_OW 311
40569: NOT
40570: AND
40571: PUSH
40572: LD_VAR 0 4
40576: PPUSH
40577: CALL_OW 266
40581: PUSH
40582: LD_INT 36
40584: EQUAL
40585: PUSH
40586: LD_VAR 0 4
40590: PPUSH
40591: CALL_OW 313
40595: PUSH
40596: LD_INT 3
40598: LESS
40599: AND
40600: OR
40601: IFFALSE 40615
// begin ct := k ;
40603: LD_ADDR_VAR 0 8
40607: PUSH
40608: LD_VAR 0 4
40612: ST_TO_ADDR
// break ;
40613: GO 40617
// end ;
40615: GO 40543
40617: POP
40618: POP
// if ct then
40619: LD_VAR 0 8
40623: IFFALSE 40639
// ComEnterUnit ( j , ct ) ;
40625: LD_VAR 0 3
40629: PPUSH
40630: LD_VAR 0 8
40634: PPUSH
40635: CALL_OW 120
// end ; end ;
40639: GO 40274
40641: POP
40642: POP
// places := 0 ;
40643: LD_ADDR_VAR 0 5
40647: PUSH
40648: LD_INT 0
40650: ST_TO_ADDR
// for j = 1 to x do
40651: LD_ADDR_VAR 0 3
40655: PUSH
40656: DOUBLE
40657: LD_INT 1
40659: DEC
40660: ST_TO_ADDR
40661: LD_VAR 0 11
40665: PUSH
40666: FOR_TO
40667: IFFALSE 40743
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40669: LD_VAR 0 11
40673: PUSH
40674: LD_VAR 0 3
40678: ARRAY
40679: PPUSH
40680: CALL_OW 264
40684: PUSH
40685: LD_INT 31
40687: EQUAL
40688: IFFALSE 40706
// places := places + 1 else
40690: LD_ADDR_VAR 0 5
40694: PUSH
40695: LD_VAR 0 5
40699: PUSH
40700: LD_INT 1
40702: PLUS
40703: ST_TO_ADDR
40704: GO 40741
// if GetBType ( x [ j ] ) = b_control_tower then
40706: LD_VAR 0 11
40710: PUSH
40711: LD_VAR 0 3
40715: ARRAY
40716: PPUSH
40717: CALL_OW 266
40721: PUSH
40722: LD_INT 36
40724: EQUAL
40725: IFFALSE 40741
// places := places + 3 ;
40727: LD_ADDR_VAR 0 5
40731: PUSH
40732: LD_VAR 0 5
40736: PUSH
40737: LD_INT 3
40739: PLUS
40740: ST_TO_ADDR
40741: GO 40666
40743: POP
40744: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40745: LD_VAR 0 5
40749: PUSH
40750: LD_INT 0
40752: EQUAL
40753: PUSH
40754: LD_VAR 0 5
40758: PUSH
40759: LD_EXP 90
40763: PUSH
40764: LD_VAR 0 2
40768: ARRAY
40769: LESSEQUAL
40770: OR
40771: IFFALSE 40775
// continue ;
40773: GO 40025
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40775: LD_ADDR_VAR 0 6
40779: PUSH
40780: LD_EXP 50
40784: PUSH
40785: LD_VAR 0 2
40789: ARRAY
40790: PPUSH
40791: LD_INT 25
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PPUSH
40801: CALL_OW 72
40805: PUSH
40806: LD_EXP 90
40810: PUSH
40811: LD_VAR 0 2
40815: ARRAY
40816: DIFF
40817: PPUSH
40818: LD_INT 3
40820: PPUSH
40821: CALL 85264 0 2
40825: ST_TO_ADDR
// for j in tmp do
40826: LD_ADDR_VAR 0 3
40830: PUSH
40831: LD_VAR 0 6
40835: PUSH
40836: FOR_IN
40837: IFFALSE 40872
// if GetTag ( j ) > 0 then
40839: LD_VAR 0 3
40843: PPUSH
40844: CALL_OW 110
40848: PUSH
40849: LD_INT 0
40851: GREATER
40852: IFFALSE 40870
// tmp := tmp diff j ;
40854: LD_ADDR_VAR 0 6
40858: PUSH
40859: LD_VAR 0 6
40863: PUSH
40864: LD_VAR 0 3
40868: DIFF
40869: ST_TO_ADDR
40870: GO 40836
40872: POP
40873: POP
// if not tmp then
40874: LD_VAR 0 6
40878: NOT
40879: IFFALSE 40883
// continue ;
40881: GO 40025
// if places then
40883: LD_VAR 0 5
40887: IFFALSE 40946
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40889: LD_ADDR_EXP 90
40893: PUSH
40894: LD_EXP 90
40898: PPUSH
40899: LD_VAR 0 2
40903: PPUSH
40904: LD_EXP 90
40908: PUSH
40909: LD_VAR 0 2
40913: ARRAY
40914: PUSH
40915: LD_VAR 0 6
40919: PUSH
40920: LD_INT 1
40922: ARRAY
40923: UNION
40924: PPUSH
40925: CALL_OW 1
40929: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40930: LD_VAR 0 6
40934: PUSH
40935: LD_INT 1
40937: ARRAY
40938: PPUSH
40939: LD_INT 126
40941: PPUSH
40942: CALL_OW 109
// end ; end ;
40946: GO 40025
40948: POP
40949: POP
// end ;
40950: LD_VAR 0 1
40954: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40955: LD_INT 0
40957: PPUSH
40958: PPUSH
40959: PPUSH
40960: PPUSH
40961: PPUSH
40962: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40963: LD_VAR 0 1
40967: NOT
40968: PUSH
40969: LD_VAR 0 2
40973: NOT
40974: OR
40975: PUSH
40976: LD_VAR 0 3
40980: NOT
40981: OR
40982: PUSH
40983: LD_VAR 0 4
40987: PUSH
40988: LD_INT 1
40990: PUSH
40991: LD_INT 2
40993: PUSH
40994: LD_INT 3
40996: PUSH
40997: LD_INT 4
40999: PUSH
41000: LD_INT 5
41002: PUSH
41003: LD_INT 8
41005: PUSH
41006: LD_INT 9
41008: PUSH
41009: LD_INT 15
41011: PUSH
41012: LD_INT 16
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: IN
41026: NOT
41027: OR
41028: IFFALSE 41032
// exit ;
41030: GO 41890
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41032: LD_ADDR_VAR 0 2
41036: PUSH
41037: LD_VAR 0 2
41041: PPUSH
41042: LD_INT 21
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 24
41054: PUSH
41055: LD_INT 250
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PPUSH
41066: CALL_OW 72
41070: ST_TO_ADDR
// case class of 1 , 15 :
41071: LD_VAR 0 4
41075: PUSH
41076: LD_INT 1
41078: DOUBLE
41079: EQUAL
41080: IFTRUE 41090
41082: LD_INT 15
41084: DOUBLE
41085: EQUAL
41086: IFTRUE 41090
41088: GO 41175
41090: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41091: LD_ADDR_VAR 0 8
41095: PUSH
41096: LD_VAR 0 2
41100: PPUSH
41101: LD_INT 2
41103: PUSH
41104: LD_INT 30
41106: PUSH
41107: LD_INT 32
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 30
41116: PUSH
41117: LD_INT 31
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: LIST
41128: PPUSH
41129: CALL_OW 72
41133: PUSH
41134: LD_VAR 0 2
41138: PPUSH
41139: LD_INT 2
41141: PUSH
41142: LD_INT 30
41144: PUSH
41145: LD_INT 4
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 30
41154: PUSH
41155: LD_INT 5
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: ADD
41172: ST_TO_ADDR
41173: GO 41421
41175: LD_INT 2
41177: DOUBLE
41178: EQUAL
41179: IFTRUE 41189
41181: LD_INT 16
41183: DOUBLE
41184: EQUAL
41185: IFTRUE 41189
41187: GO 41235
41189: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41190: LD_ADDR_VAR 0 8
41194: PUSH
41195: LD_VAR 0 2
41199: PPUSH
41200: LD_INT 2
41202: PUSH
41203: LD_INT 30
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 30
41215: PUSH
41216: LD_INT 1
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: LIST
41227: PPUSH
41228: CALL_OW 72
41232: ST_TO_ADDR
41233: GO 41421
41235: LD_INT 3
41237: DOUBLE
41238: EQUAL
41239: IFTRUE 41243
41241: GO 41289
41243: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41244: LD_ADDR_VAR 0 8
41248: PUSH
41249: LD_VAR 0 2
41253: PPUSH
41254: LD_INT 2
41256: PUSH
41257: LD_INT 30
41259: PUSH
41260: LD_INT 2
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 30
41269: PUSH
41270: LD_INT 3
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: LIST
41281: PPUSH
41282: CALL_OW 72
41286: ST_TO_ADDR
41287: GO 41421
41289: LD_INT 4
41291: DOUBLE
41292: EQUAL
41293: IFTRUE 41297
41295: GO 41354
41297: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41298: LD_ADDR_VAR 0 8
41302: PUSH
41303: LD_VAR 0 2
41307: PPUSH
41308: LD_INT 2
41310: PUSH
41311: LD_INT 30
41313: PUSH
41314: LD_INT 6
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 30
41323: PUSH
41324: LD_INT 7
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: LD_INT 30
41333: PUSH
41334: LD_INT 8
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: LIST
41345: LIST
41346: PPUSH
41347: CALL_OW 72
41351: ST_TO_ADDR
41352: GO 41421
41354: LD_INT 5
41356: DOUBLE
41357: EQUAL
41358: IFTRUE 41374
41360: LD_INT 8
41362: DOUBLE
41363: EQUAL
41364: IFTRUE 41374
41366: LD_INT 9
41368: DOUBLE
41369: EQUAL
41370: IFTRUE 41374
41372: GO 41420
41374: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41375: LD_ADDR_VAR 0 8
41379: PUSH
41380: LD_VAR 0 2
41384: PPUSH
41385: LD_INT 2
41387: PUSH
41388: LD_INT 30
41390: PUSH
41391: LD_INT 4
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 30
41400: PUSH
41401: LD_INT 5
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: LIST
41412: PPUSH
41413: CALL_OW 72
41417: ST_TO_ADDR
41418: GO 41421
41420: POP
// if not tmp then
41421: LD_VAR 0 8
41425: NOT
41426: IFFALSE 41430
// exit ;
41428: GO 41890
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41430: LD_VAR 0 4
41434: PUSH
41435: LD_INT 1
41437: PUSH
41438: LD_INT 15
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: IN
41445: PUSH
41446: LD_EXP 59
41450: PUSH
41451: LD_VAR 0 1
41455: ARRAY
41456: AND
41457: IFFALSE 41613
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41459: LD_ADDR_VAR 0 9
41463: PUSH
41464: LD_EXP 59
41468: PUSH
41469: LD_VAR 0 1
41473: ARRAY
41474: PUSH
41475: LD_INT 1
41477: ARRAY
41478: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41479: LD_VAR 0 9
41483: PUSH
41484: LD_EXP 60
41488: PUSH
41489: LD_VAR 0 1
41493: ARRAY
41494: IN
41495: NOT
41496: IFFALSE 41611
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41498: LD_ADDR_EXP 60
41502: PUSH
41503: LD_EXP 60
41507: PPUSH
41508: LD_VAR 0 1
41512: PUSH
41513: LD_EXP 60
41517: PUSH
41518: LD_VAR 0 1
41522: ARRAY
41523: PUSH
41524: LD_INT 1
41526: PLUS
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PPUSH
41532: LD_VAR 0 9
41536: PPUSH
41537: CALL 54011 0 3
41541: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41542: LD_ADDR_EXP 59
41546: PUSH
41547: LD_EXP 59
41551: PPUSH
41552: LD_VAR 0 1
41556: PPUSH
41557: LD_EXP 59
41561: PUSH
41562: LD_VAR 0 1
41566: ARRAY
41567: PUSH
41568: LD_VAR 0 9
41572: DIFF
41573: PPUSH
41574: CALL_OW 1
41578: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41579: LD_VAR 0 3
41583: PPUSH
41584: LD_EXP 60
41588: PUSH
41589: LD_VAR 0 1
41593: ARRAY
41594: PUSH
41595: LD_EXP 60
41599: PUSH
41600: LD_VAR 0 1
41604: ARRAY
41605: ARRAY
41606: PPUSH
41607: CALL_OW 120
// end ; exit ;
41611: GO 41890
// end ; if tmp > 1 then
41613: LD_VAR 0 8
41617: PUSH
41618: LD_INT 1
41620: GREATER
41621: IFFALSE 41725
// for i = 2 to tmp do
41623: LD_ADDR_VAR 0 6
41627: PUSH
41628: DOUBLE
41629: LD_INT 2
41631: DEC
41632: ST_TO_ADDR
41633: LD_VAR 0 8
41637: PUSH
41638: FOR_TO
41639: IFFALSE 41723
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41641: LD_VAR 0 8
41645: PUSH
41646: LD_VAR 0 6
41650: ARRAY
41651: PPUSH
41652: CALL_OW 461
41656: PUSH
41657: LD_INT 6
41659: EQUAL
41660: IFFALSE 41721
// begin x := tmp [ i ] ;
41662: LD_ADDR_VAR 0 9
41666: PUSH
41667: LD_VAR 0 8
41671: PUSH
41672: LD_VAR 0 6
41676: ARRAY
41677: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41678: LD_ADDR_VAR 0 8
41682: PUSH
41683: LD_VAR 0 8
41687: PPUSH
41688: LD_VAR 0 6
41692: PPUSH
41693: CALL_OW 3
41697: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41698: LD_ADDR_VAR 0 8
41702: PUSH
41703: LD_VAR 0 8
41707: PPUSH
41708: LD_INT 1
41710: PPUSH
41711: LD_VAR 0 9
41715: PPUSH
41716: CALL_OW 2
41720: ST_TO_ADDR
// end ;
41721: GO 41638
41723: POP
41724: POP
// for i in tmp do
41725: LD_ADDR_VAR 0 6
41729: PUSH
41730: LD_VAR 0 8
41734: PUSH
41735: FOR_IN
41736: IFFALSE 41763
// begin if IsNotFull ( i ) then
41738: LD_VAR 0 6
41742: PPUSH
41743: CALL 51233 0 1
41747: IFFALSE 41761
// begin j := i ;
41749: LD_ADDR_VAR 0 7
41753: PUSH
41754: LD_VAR 0 6
41758: ST_TO_ADDR
// break ;
41759: GO 41763
// end ; end ;
41761: GO 41735
41763: POP
41764: POP
// if j then
41765: LD_VAR 0 7
41769: IFFALSE 41787
// ComEnterUnit ( unit , j ) else
41771: LD_VAR 0 3
41775: PPUSH
41776: LD_VAR 0 7
41780: PPUSH
41781: CALL_OW 120
41785: GO 41890
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41787: LD_ADDR_VAR 0 10
41791: PUSH
41792: LD_VAR 0 2
41796: PPUSH
41797: LD_INT 2
41799: PUSH
41800: LD_INT 30
41802: PUSH
41803: LD_INT 0
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 30
41812: PUSH
41813: LD_INT 1
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: LIST
41824: PPUSH
41825: CALL_OW 72
41829: ST_TO_ADDR
// if depot then
41830: LD_VAR 0 10
41834: IFFALSE 41890
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41836: LD_ADDR_VAR 0 10
41840: PUSH
41841: LD_VAR 0 10
41845: PPUSH
41846: LD_VAR 0 3
41850: PPUSH
41851: CALL_OW 74
41855: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41856: LD_VAR 0 3
41860: PPUSH
41861: LD_VAR 0 10
41865: PPUSH
41866: CALL_OW 296
41870: PUSH
41871: LD_INT 10
41873: GREATER
41874: IFFALSE 41890
// ComStandNearbyBuilding ( unit , depot ) ;
41876: LD_VAR 0 3
41880: PPUSH
41881: LD_VAR 0 10
41885: PPUSH
41886: CALL 50613 0 2
// end ; end ; end ;
41890: LD_VAR 0 5
41894: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41895: LD_INT 0
41897: PPUSH
41898: PPUSH
41899: PPUSH
41900: PPUSH
// if not mc_bases then
41901: LD_EXP 50
41905: NOT
41906: IFFALSE 41910
// exit ;
41908: GO 42149
// for i = 1 to mc_bases do
41910: LD_ADDR_VAR 0 2
41914: PUSH
41915: DOUBLE
41916: LD_INT 1
41918: DEC
41919: ST_TO_ADDR
41920: LD_EXP 50
41924: PUSH
41925: FOR_TO
41926: IFFALSE 42147
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41928: LD_ADDR_VAR 0 4
41932: PUSH
41933: LD_EXP 50
41937: PUSH
41938: LD_VAR 0 2
41942: ARRAY
41943: PPUSH
41944: LD_INT 21
41946: PUSH
41947: LD_INT 1
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PPUSH
41954: CALL_OW 72
41958: PUSH
41959: LD_EXP 79
41963: PUSH
41964: LD_VAR 0 2
41968: ARRAY
41969: UNION
41970: ST_TO_ADDR
// if not tmp then
41971: LD_VAR 0 4
41975: NOT
41976: IFFALSE 41980
// continue ;
41978: GO 41925
// for j in tmp do
41980: LD_ADDR_VAR 0 3
41984: PUSH
41985: LD_VAR 0 4
41989: PUSH
41990: FOR_IN
41991: IFFALSE 42143
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41993: LD_VAR 0 3
41997: PPUSH
41998: CALL_OW 110
42002: NOT
42003: PUSH
42004: LD_VAR 0 3
42008: PPUSH
42009: CALL_OW 314
42013: NOT
42014: AND
42015: PUSH
42016: LD_VAR 0 3
42020: PPUSH
42021: CALL_OW 311
42025: NOT
42026: AND
42027: PUSH
42028: LD_VAR 0 3
42032: PPUSH
42033: CALL_OW 310
42037: NOT
42038: AND
42039: PUSH
42040: LD_VAR 0 3
42044: PUSH
42045: LD_EXP 53
42049: PUSH
42050: LD_VAR 0 2
42054: ARRAY
42055: PUSH
42056: LD_INT 1
42058: ARRAY
42059: IN
42060: NOT
42061: AND
42062: PUSH
42063: LD_VAR 0 3
42067: PUSH
42068: LD_EXP 53
42072: PUSH
42073: LD_VAR 0 2
42077: ARRAY
42078: PUSH
42079: LD_INT 2
42081: ARRAY
42082: IN
42083: NOT
42084: AND
42085: PUSH
42086: LD_VAR 0 3
42090: PUSH
42091: LD_EXP 62
42095: PUSH
42096: LD_VAR 0 2
42100: ARRAY
42101: IN
42102: NOT
42103: AND
42104: IFFALSE 42141
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42106: LD_VAR 0 2
42110: PPUSH
42111: LD_EXP 50
42115: PUSH
42116: LD_VAR 0 2
42120: ARRAY
42121: PPUSH
42122: LD_VAR 0 3
42126: PPUSH
42127: LD_VAR 0 3
42131: PPUSH
42132: CALL_OW 257
42136: PPUSH
42137: CALL 40955 0 4
// end ;
42141: GO 41990
42143: POP
42144: POP
// end ;
42145: GO 41925
42147: POP
42148: POP
// end ;
42149: LD_VAR 0 1
42153: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42154: LD_INT 0
42156: PPUSH
42157: PPUSH
42158: PPUSH
42159: PPUSH
42160: PPUSH
42161: PPUSH
// if not mc_bases [ base ] then
42162: LD_EXP 50
42166: PUSH
42167: LD_VAR 0 1
42171: ARRAY
42172: NOT
42173: IFFALSE 42177
// exit ;
42175: GO 42378
// tmp := [ ] ;
42177: LD_ADDR_VAR 0 6
42181: PUSH
42182: EMPTY
42183: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42184: LD_ADDR_VAR 0 7
42188: PUSH
42189: LD_VAR 0 3
42193: PPUSH
42194: LD_INT 0
42196: PPUSH
42197: CALL_OW 517
42201: ST_TO_ADDR
// if not list then
42202: LD_VAR 0 7
42206: NOT
42207: IFFALSE 42211
// exit ;
42209: GO 42378
// c := Count ( list [ 1 ] ) ;
42211: LD_ADDR_VAR 0 9
42215: PUSH
42216: LD_VAR 0 7
42220: PUSH
42221: LD_INT 1
42223: ARRAY
42224: PPUSH
42225: CALL 51151 0 1
42229: ST_TO_ADDR
// if amount > c then
42230: LD_VAR 0 2
42234: PUSH
42235: LD_VAR 0 9
42239: GREATER
42240: IFFALSE 42252
// amount := c ;
42242: LD_ADDR_VAR 0 2
42246: PUSH
42247: LD_VAR 0 9
42251: ST_TO_ADDR
// for i := 1 to amount do
42252: LD_ADDR_VAR 0 5
42256: PUSH
42257: DOUBLE
42258: LD_INT 1
42260: DEC
42261: ST_TO_ADDR
42262: LD_VAR 0 2
42266: PUSH
42267: FOR_TO
42268: IFFALSE 42326
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42270: LD_ADDR_VAR 0 6
42274: PUSH
42275: LD_VAR 0 6
42279: PPUSH
42280: LD_VAR 0 5
42284: PPUSH
42285: LD_VAR 0 7
42289: PUSH
42290: LD_INT 1
42292: ARRAY
42293: PUSH
42294: LD_VAR 0 5
42298: ARRAY
42299: PUSH
42300: LD_VAR 0 7
42304: PUSH
42305: LD_INT 2
42307: ARRAY
42308: PUSH
42309: LD_VAR 0 5
42313: ARRAY
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PPUSH
42319: CALL_OW 1
42323: ST_TO_ADDR
42324: GO 42267
42326: POP
42327: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42328: LD_ADDR_EXP 63
42332: PUSH
42333: LD_EXP 63
42337: PPUSH
42338: LD_VAR 0 1
42342: PPUSH
42343: LD_VAR 0 6
42347: PPUSH
42348: CALL_OW 1
42352: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42353: LD_ADDR_EXP 65
42357: PUSH
42358: LD_EXP 65
42362: PPUSH
42363: LD_VAR 0 1
42367: PPUSH
42368: LD_VAR 0 3
42372: PPUSH
42373: CALL_OW 1
42377: ST_TO_ADDR
// end ;
42378: LD_VAR 0 4
42382: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42383: LD_INT 0
42385: PPUSH
// if not mc_bases [ base ] then
42386: LD_EXP 50
42390: PUSH
42391: LD_VAR 0 1
42395: ARRAY
42396: NOT
42397: IFFALSE 42401
// exit ;
42399: GO 42426
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42401: LD_ADDR_EXP 55
42405: PUSH
42406: LD_EXP 55
42410: PPUSH
42411: LD_VAR 0 1
42415: PPUSH
42416: LD_VAR 0 2
42420: PPUSH
42421: CALL_OW 1
42425: ST_TO_ADDR
// end ;
42426: LD_VAR 0 3
42430: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42431: LD_INT 0
42433: PPUSH
// if not mc_bases [ base ] then
42434: LD_EXP 50
42438: PUSH
42439: LD_VAR 0 1
42443: ARRAY
42444: NOT
42445: IFFALSE 42449
// exit ;
42447: GO 42486
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42449: LD_ADDR_EXP 55
42453: PUSH
42454: LD_EXP 55
42458: PPUSH
42459: LD_VAR 0 1
42463: PPUSH
42464: LD_EXP 55
42468: PUSH
42469: LD_VAR 0 1
42473: ARRAY
42474: PUSH
42475: LD_VAR 0 2
42479: UNION
42480: PPUSH
42481: CALL_OW 1
42485: ST_TO_ADDR
// end ;
42486: LD_VAR 0 3
42490: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42491: LD_INT 0
42493: PPUSH
// if not mc_bases [ base ] then
42494: LD_EXP 50
42498: PUSH
42499: LD_VAR 0 1
42503: ARRAY
42504: NOT
42505: IFFALSE 42509
// exit ;
42507: GO 42534
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42509: LD_ADDR_EXP 71
42513: PUSH
42514: LD_EXP 71
42518: PPUSH
42519: LD_VAR 0 1
42523: PPUSH
42524: LD_VAR 0 2
42528: PPUSH
42529: CALL_OW 1
42533: ST_TO_ADDR
// end ;
42534: LD_VAR 0 3
42538: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42539: LD_INT 0
42541: PPUSH
// if not mc_bases [ base ] then
42542: LD_EXP 50
42546: PUSH
42547: LD_VAR 0 1
42551: ARRAY
42552: NOT
42553: IFFALSE 42557
// exit ;
42555: GO 42594
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42557: LD_ADDR_EXP 71
42561: PUSH
42562: LD_EXP 71
42566: PPUSH
42567: LD_VAR 0 1
42571: PPUSH
42572: LD_EXP 71
42576: PUSH
42577: LD_VAR 0 1
42581: ARRAY
42582: PUSH
42583: LD_VAR 0 2
42587: ADD
42588: PPUSH
42589: CALL_OW 1
42593: ST_TO_ADDR
// end ;
42594: LD_VAR 0 3
42598: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42599: LD_INT 0
42601: PPUSH
// if not mc_bases [ base ] then
42602: LD_EXP 50
42606: PUSH
42607: LD_VAR 0 1
42611: ARRAY
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 42671
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42617: LD_ADDR_EXP 72
42621: PUSH
42622: LD_EXP 72
42626: PPUSH
42627: LD_VAR 0 1
42631: PPUSH
42632: LD_VAR 0 2
42636: PPUSH
42637: CALL_OW 1
42641: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42642: LD_ADDR_EXP 61
42646: PUSH
42647: LD_EXP 61
42651: PPUSH
42652: LD_VAR 0 1
42656: PPUSH
42657: LD_VAR 0 2
42661: PUSH
42662: LD_INT 0
42664: PLUS
42665: PPUSH
42666: CALL_OW 1
42670: ST_TO_ADDR
// end ;
42671: LD_VAR 0 3
42675: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42676: LD_INT 0
42678: PPUSH
// if not mc_bases [ base ] then
42679: LD_EXP 50
42683: PUSH
42684: LD_VAR 0 1
42688: ARRAY
42689: NOT
42690: IFFALSE 42694
// exit ;
42692: GO 42719
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42694: LD_ADDR_EXP 61
42698: PUSH
42699: LD_EXP 61
42703: PPUSH
42704: LD_VAR 0 1
42708: PPUSH
42709: LD_VAR 0 2
42713: PPUSH
42714: CALL_OW 1
42718: ST_TO_ADDR
// end ;
42719: LD_VAR 0 3
42723: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42724: LD_INT 0
42726: PPUSH
42727: PPUSH
42728: PPUSH
42729: PPUSH
// if not mc_bases [ base ] then
42730: LD_EXP 50
42734: PUSH
42735: LD_VAR 0 1
42739: ARRAY
42740: NOT
42741: IFFALSE 42745
// exit ;
42743: GO 42810
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42745: LD_ADDR_EXP 70
42749: PUSH
42750: LD_EXP 70
42754: PPUSH
42755: LD_VAR 0 1
42759: PUSH
42760: LD_EXP 70
42764: PUSH
42765: LD_VAR 0 1
42769: ARRAY
42770: PUSH
42771: LD_INT 1
42773: PLUS
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PPUSH
42779: LD_VAR 0 1
42783: PUSH
42784: LD_VAR 0 2
42788: PUSH
42789: LD_VAR 0 3
42793: PUSH
42794: LD_VAR 0 4
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: PPUSH
42805: CALL 54011 0 3
42809: ST_TO_ADDR
// end ;
42810: LD_VAR 0 5
42814: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42815: LD_INT 0
42817: PPUSH
// if not mc_bases [ base ] then
42818: LD_EXP 50
42822: PUSH
42823: LD_VAR 0 1
42827: ARRAY
42828: NOT
42829: IFFALSE 42833
// exit ;
42831: GO 42858
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42833: LD_ADDR_EXP 87
42837: PUSH
42838: LD_EXP 87
42842: PPUSH
42843: LD_VAR 0 1
42847: PPUSH
42848: LD_VAR 0 2
42852: PPUSH
42853: CALL_OW 1
42857: ST_TO_ADDR
// end ;
42858: LD_VAR 0 3
42862: RET
// export function MC_GetMinesField ( base ) ; begin
42863: LD_INT 0
42865: PPUSH
// result := mc_mines [ base ] ;
42866: LD_ADDR_VAR 0 2
42870: PUSH
42871: LD_EXP 63
42875: PUSH
42876: LD_VAR 0 1
42880: ARRAY
42881: ST_TO_ADDR
// end ;
42882: LD_VAR 0 2
42886: RET
// export function MC_GetProduceList ( base ) ; begin
42887: LD_INT 0
42889: PPUSH
// result := mc_produce [ base ] ;
42890: LD_ADDR_VAR 0 2
42894: PUSH
42895: LD_EXP 71
42899: PUSH
42900: LD_VAR 0 1
42904: ARRAY
42905: ST_TO_ADDR
// end ;
42906: LD_VAR 0 2
42910: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42911: LD_INT 0
42913: PPUSH
42914: PPUSH
// if not mc_bases then
42915: LD_EXP 50
42919: NOT
42920: IFFALSE 42924
// exit ;
42922: GO 42989
// if mc_bases [ base ] then
42924: LD_EXP 50
42928: PUSH
42929: LD_VAR 0 1
42933: ARRAY
42934: IFFALSE 42989
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42936: LD_ADDR_VAR 0 3
42940: PUSH
42941: LD_EXP 50
42945: PUSH
42946: LD_VAR 0 1
42950: ARRAY
42951: PPUSH
42952: LD_INT 30
42954: PUSH
42955: LD_VAR 0 2
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PPUSH
42964: CALL_OW 72
42968: ST_TO_ADDR
// if result then
42969: LD_VAR 0 3
42973: IFFALSE 42989
// result := result [ 1 ] ;
42975: LD_ADDR_VAR 0 3
42979: PUSH
42980: LD_VAR 0 3
42984: PUSH
42985: LD_INT 1
42987: ARRAY
42988: ST_TO_ADDR
// end ; end ;
42989: LD_VAR 0 3
42993: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42994: LD_INT 0
42996: PPUSH
42997: PPUSH
// if not mc_bases then
42998: LD_EXP 50
43002: NOT
43003: IFFALSE 43007
// exit ;
43005: GO 43052
// if mc_bases [ base ] then
43007: LD_EXP 50
43011: PUSH
43012: LD_VAR 0 1
43016: ARRAY
43017: IFFALSE 43052
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43019: LD_ADDR_VAR 0 3
43023: PUSH
43024: LD_EXP 50
43028: PUSH
43029: LD_VAR 0 1
43033: ARRAY
43034: PPUSH
43035: LD_INT 30
43037: PUSH
43038: LD_VAR 0 2
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PPUSH
43047: CALL_OW 72
43051: ST_TO_ADDR
// end ;
43052: LD_VAR 0 3
43056: RET
// export function MC_SetTame ( base , area ) ; begin
43057: LD_INT 0
43059: PPUSH
// if not mc_bases or not base then
43060: LD_EXP 50
43064: NOT
43065: PUSH
43066: LD_VAR 0 1
43070: NOT
43071: OR
43072: IFFALSE 43076
// exit ;
43074: GO 43101
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43076: LD_ADDR_EXP 78
43080: PUSH
43081: LD_EXP 78
43085: PPUSH
43086: LD_VAR 0 1
43090: PPUSH
43091: LD_VAR 0 2
43095: PPUSH
43096: CALL_OW 1
43100: ST_TO_ADDR
// end ;
43101: LD_VAR 0 3
43105: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43106: LD_INT 0
43108: PPUSH
43109: PPUSH
// if not mc_bases or not base then
43110: LD_EXP 50
43114: NOT
43115: PUSH
43116: LD_VAR 0 1
43120: NOT
43121: OR
43122: IFFALSE 43126
// exit ;
43124: GO 43228
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43126: LD_ADDR_VAR 0 4
43130: PUSH
43131: LD_EXP 50
43135: PUSH
43136: LD_VAR 0 1
43140: ARRAY
43141: PPUSH
43142: LD_INT 30
43144: PUSH
43145: LD_VAR 0 2
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PPUSH
43154: CALL_OW 72
43158: ST_TO_ADDR
// if not tmp then
43159: LD_VAR 0 4
43163: NOT
43164: IFFALSE 43168
// exit ;
43166: GO 43228
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43168: LD_ADDR_EXP 82
43172: PUSH
43173: LD_EXP 82
43177: PPUSH
43178: LD_VAR 0 1
43182: PPUSH
43183: LD_EXP 82
43187: PUSH
43188: LD_VAR 0 1
43192: ARRAY
43193: PPUSH
43194: LD_EXP 82
43198: PUSH
43199: LD_VAR 0 1
43203: ARRAY
43204: PUSH
43205: LD_INT 1
43207: PLUS
43208: PPUSH
43209: LD_VAR 0 4
43213: PUSH
43214: LD_INT 1
43216: ARRAY
43217: PPUSH
43218: CALL_OW 2
43222: PPUSH
43223: CALL_OW 1
43227: ST_TO_ADDR
// end ;
43228: LD_VAR 0 3
43232: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43233: LD_INT 0
43235: PPUSH
43236: PPUSH
// if not mc_bases or not base or not kinds then
43237: LD_EXP 50
43241: NOT
43242: PUSH
43243: LD_VAR 0 1
43247: NOT
43248: OR
43249: PUSH
43250: LD_VAR 0 2
43254: NOT
43255: OR
43256: IFFALSE 43260
// exit ;
43258: GO 43321
// for i in kinds do
43260: LD_ADDR_VAR 0 4
43264: PUSH
43265: LD_VAR 0 2
43269: PUSH
43270: FOR_IN
43271: IFFALSE 43319
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43273: LD_ADDR_EXP 84
43277: PUSH
43278: LD_EXP 84
43282: PPUSH
43283: LD_VAR 0 1
43287: PUSH
43288: LD_EXP 84
43292: PUSH
43293: LD_VAR 0 1
43297: ARRAY
43298: PUSH
43299: LD_INT 1
43301: PLUS
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PPUSH
43307: LD_VAR 0 4
43311: PPUSH
43312: CALL 54011 0 3
43316: ST_TO_ADDR
43317: GO 43270
43319: POP
43320: POP
// end ;
43321: LD_VAR 0 3
43325: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43326: LD_INT 0
43328: PPUSH
// if not mc_bases or not base or not areas then
43329: LD_EXP 50
43333: NOT
43334: PUSH
43335: LD_VAR 0 1
43339: NOT
43340: OR
43341: PUSH
43342: LD_VAR 0 2
43346: NOT
43347: OR
43348: IFFALSE 43352
// exit ;
43350: GO 43377
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43352: LD_ADDR_EXP 68
43356: PUSH
43357: LD_EXP 68
43361: PPUSH
43362: LD_VAR 0 1
43366: PPUSH
43367: LD_VAR 0 2
43371: PPUSH
43372: CALL_OW 1
43376: ST_TO_ADDR
// end ;
43377: LD_VAR 0 3
43381: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43382: LD_INT 0
43384: PPUSH
// if not mc_bases or not base or not teleports_exit then
43385: LD_EXP 50
43389: NOT
43390: PUSH
43391: LD_VAR 0 1
43395: NOT
43396: OR
43397: PUSH
43398: LD_VAR 0 2
43402: NOT
43403: OR
43404: IFFALSE 43408
// exit ;
43406: GO 43433
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43408: LD_ADDR_EXP 85
43412: PUSH
43413: LD_EXP 85
43417: PPUSH
43418: LD_VAR 0 1
43422: PPUSH
43423: LD_VAR 0 2
43427: PPUSH
43428: CALL_OW 1
43432: ST_TO_ADDR
// end ;
43433: LD_VAR 0 3
43437: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43438: LD_INT 0
43440: PPUSH
43441: PPUSH
43442: PPUSH
// if not mc_bases or not base or not ext_list then
43443: LD_EXP 50
43447: NOT
43448: PUSH
43449: LD_VAR 0 1
43453: NOT
43454: OR
43455: PUSH
43456: LD_VAR 0 5
43460: NOT
43461: OR
43462: IFFALSE 43466
// exit ;
43464: GO 43639
// tmp := GetFacExtXYD ( x , y , d ) ;
43466: LD_ADDR_VAR 0 8
43470: PUSH
43471: LD_VAR 0 2
43475: PPUSH
43476: LD_VAR 0 3
43480: PPUSH
43481: LD_VAR 0 4
43485: PPUSH
43486: CALL 84394 0 3
43490: ST_TO_ADDR
// if not tmp then
43491: LD_VAR 0 8
43495: NOT
43496: IFFALSE 43500
// exit ;
43498: GO 43639
// for i in tmp do
43500: LD_ADDR_VAR 0 7
43504: PUSH
43505: LD_VAR 0 8
43509: PUSH
43510: FOR_IN
43511: IFFALSE 43637
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43513: LD_ADDR_EXP 55
43517: PUSH
43518: LD_EXP 55
43522: PPUSH
43523: LD_VAR 0 1
43527: PPUSH
43528: LD_EXP 55
43532: PUSH
43533: LD_VAR 0 1
43537: ARRAY
43538: PPUSH
43539: LD_EXP 55
43543: PUSH
43544: LD_VAR 0 1
43548: ARRAY
43549: PUSH
43550: LD_INT 1
43552: PLUS
43553: PPUSH
43554: LD_VAR 0 5
43558: PUSH
43559: LD_INT 1
43561: ARRAY
43562: PUSH
43563: LD_VAR 0 7
43567: PUSH
43568: LD_INT 1
43570: ARRAY
43571: PUSH
43572: LD_VAR 0 7
43576: PUSH
43577: LD_INT 2
43579: ARRAY
43580: PUSH
43581: LD_VAR 0 7
43585: PUSH
43586: LD_INT 3
43588: ARRAY
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: PPUSH
43596: CALL_OW 2
43600: PPUSH
43601: CALL_OW 1
43605: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43606: LD_ADDR_VAR 0 5
43610: PUSH
43611: LD_VAR 0 5
43615: PPUSH
43616: LD_INT 1
43618: PPUSH
43619: CALL_OW 3
43623: ST_TO_ADDR
// if not ext_list then
43624: LD_VAR 0 5
43628: NOT
43629: IFFALSE 43635
// exit ;
43631: POP
43632: POP
43633: GO 43639
// end ;
43635: GO 43510
43637: POP
43638: POP
// end ;
43639: LD_VAR 0 6
43643: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43644: LD_INT 0
43646: PPUSH
// if not mc_bases or not base or not weapon_list then
43647: LD_EXP 50
43651: NOT
43652: PUSH
43653: LD_VAR 0 1
43657: NOT
43658: OR
43659: PUSH
43660: LD_VAR 0 2
43664: NOT
43665: OR
43666: IFFALSE 43670
// exit ;
43668: GO 43695
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43670: LD_ADDR_EXP 89
43674: PUSH
43675: LD_EXP 89
43679: PPUSH
43680: LD_VAR 0 1
43684: PPUSH
43685: LD_VAR 0 2
43689: PPUSH
43690: CALL_OW 1
43694: ST_TO_ADDR
// end ;
43695: LD_VAR 0 3
43699: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43700: LD_INT 0
43702: PPUSH
// if not mc_bases or not base or not tech_list then
43703: LD_EXP 50
43707: NOT
43708: PUSH
43709: LD_VAR 0 1
43713: NOT
43714: OR
43715: PUSH
43716: LD_VAR 0 2
43720: NOT
43721: OR
43722: IFFALSE 43726
// exit ;
43724: GO 43751
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43726: LD_ADDR_EXP 77
43730: PUSH
43731: LD_EXP 77
43735: PPUSH
43736: LD_VAR 0 1
43740: PPUSH
43741: LD_VAR 0 2
43745: PPUSH
43746: CALL_OW 1
43750: ST_TO_ADDR
// end ;
43751: LD_VAR 0 3
43755: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43756: LD_INT 0
43758: PPUSH
// if not mc_bases or not parking_area or not base then
43759: LD_EXP 50
43763: NOT
43764: PUSH
43765: LD_VAR 0 2
43769: NOT
43770: OR
43771: PUSH
43772: LD_VAR 0 1
43776: NOT
43777: OR
43778: IFFALSE 43782
// exit ;
43780: GO 43807
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43782: LD_ADDR_EXP 74
43786: PUSH
43787: LD_EXP 74
43791: PPUSH
43792: LD_VAR 0 1
43796: PPUSH
43797: LD_VAR 0 2
43801: PPUSH
43802: CALL_OW 1
43806: ST_TO_ADDR
// end ;
43807: LD_VAR 0 3
43811: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43812: LD_INT 0
43814: PPUSH
// if not mc_bases or not base or not scan_area then
43815: LD_EXP 50
43819: NOT
43820: PUSH
43821: LD_VAR 0 1
43825: NOT
43826: OR
43827: PUSH
43828: LD_VAR 0 2
43832: NOT
43833: OR
43834: IFFALSE 43838
// exit ;
43836: GO 43863
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43838: LD_ADDR_EXP 75
43842: PUSH
43843: LD_EXP 75
43847: PPUSH
43848: LD_VAR 0 1
43852: PPUSH
43853: LD_VAR 0 2
43857: PPUSH
43858: CALL_OW 1
43862: ST_TO_ADDR
// end ;
43863: LD_VAR 0 3
43867: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43868: LD_INT 0
43870: PPUSH
43871: PPUSH
// if not mc_bases or not base then
43872: LD_EXP 50
43876: NOT
43877: PUSH
43878: LD_VAR 0 1
43882: NOT
43883: OR
43884: IFFALSE 43888
// exit ;
43886: GO 43952
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43888: LD_ADDR_VAR 0 3
43892: PUSH
43893: LD_INT 1
43895: PUSH
43896: LD_INT 2
43898: PUSH
43899: LD_INT 3
43901: PUSH
43902: LD_INT 4
43904: PUSH
43905: LD_INT 11
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43915: LD_ADDR_EXP 77
43919: PUSH
43920: LD_EXP 77
43924: PPUSH
43925: LD_VAR 0 1
43929: PPUSH
43930: LD_EXP 77
43934: PUSH
43935: LD_VAR 0 1
43939: ARRAY
43940: PUSH
43941: LD_VAR 0 3
43945: DIFF
43946: PPUSH
43947: CALL_OW 1
43951: ST_TO_ADDR
// end ;
43952: LD_VAR 0 2
43956: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43957: LD_INT 0
43959: PPUSH
// result := mc_vehicles [ base ] ;
43960: LD_ADDR_VAR 0 3
43964: PUSH
43965: LD_EXP 69
43969: PUSH
43970: LD_VAR 0 1
43974: ARRAY
43975: ST_TO_ADDR
// if onlyCombat then
43976: LD_VAR 0 2
43980: IFFALSE 44152
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43982: LD_ADDR_VAR 0 3
43986: PUSH
43987: LD_VAR 0 3
43991: PUSH
43992: LD_VAR 0 3
43996: PPUSH
43997: LD_INT 2
43999: PUSH
44000: LD_INT 34
44002: PUSH
44003: LD_INT 12
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 34
44012: PUSH
44013: LD_INT 51
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 34
44022: PUSH
44023: LD_INT 89
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 34
44032: PUSH
44033: LD_INT 32
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 34
44042: PUSH
44043: LD_INT 13
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 34
44052: PUSH
44053: LD_INT 52
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 34
44062: PUSH
44063: LD_INT 88
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 34
44072: PUSH
44073: LD_INT 14
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 34
44082: PUSH
44083: LD_INT 53
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PUSH
44090: LD_INT 34
44092: PUSH
44093: LD_INT 98
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 34
44102: PUSH
44103: LD_INT 31
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 34
44112: PUSH
44113: LD_INT 48
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 34
44122: PUSH
44123: LD_INT 8
44125: PUSH
44126: EMPTY
44127: LIST
44128: LIST
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: PPUSH
44146: CALL_OW 72
44150: DIFF
44151: ST_TO_ADDR
// end ; end_of_file
44152: LD_VAR 0 3
44156: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44157: LD_INT 0
44159: PPUSH
44160: PPUSH
44161: PPUSH
// if not mc_bases or not skirmish then
44162: LD_EXP 50
44166: NOT
44167: PUSH
44168: LD_EXP 48
44172: NOT
44173: OR
44174: IFFALSE 44178
// exit ;
44176: GO 44343
// for i = 1 to mc_bases do
44178: LD_ADDR_VAR 0 4
44182: PUSH
44183: DOUBLE
44184: LD_INT 1
44186: DEC
44187: ST_TO_ADDR
44188: LD_EXP 50
44192: PUSH
44193: FOR_TO
44194: IFFALSE 44341
// begin if sci in mc_bases [ i ] then
44196: LD_VAR 0 2
44200: PUSH
44201: LD_EXP 50
44205: PUSH
44206: LD_VAR 0 4
44210: ARRAY
44211: IN
44212: IFFALSE 44339
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44214: LD_ADDR_EXP 79
44218: PUSH
44219: LD_EXP 79
44223: PPUSH
44224: LD_VAR 0 4
44228: PUSH
44229: LD_EXP 79
44233: PUSH
44234: LD_VAR 0 4
44238: ARRAY
44239: PUSH
44240: LD_INT 1
44242: PLUS
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PPUSH
44248: LD_VAR 0 1
44252: PPUSH
44253: CALL 54011 0 3
44257: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44258: LD_ADDR_VAR 0 5
44262: PUSH
44263: LD_EXP 50
44267: PUSH
44268: LD_VAR 0 4
44272: ARRAY
44273: PPUSH
44274: LD_INT 2
44276: PUSH
44277: LD_INT 30
44279: PUSH
44280: LD_INT 0
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 30
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: LIST
44301: PPUSH
44302: CALL_OW 72
44306: PPUSH
44307: LD_VAR 0 1
44311: PPUSH
44312: CALL_OW 74
44316: ST_TO_ADDR
// if tmp then
44317: LD_VAR 0 5
44321: IFFALSE 44337
// ComStandNearbyBuilding ( ape , tmp ) ;
44323: LD_VAR 0 1
44327: PPUSH
44328: LD_VAR 0 5
44332: PPUSH
44333: CALL 50613 0 2
// break ;
44337: GO 44341
// end ; end ;
44339: GO 44193
44341: POP
44342: POP
// end ;
44343: LD_VAR 0 3
44347: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44348: LD_INT 0
44350: PPUSH
44351: PPUSH
44352: PPUSH
// if not mc_bases or not skirmish then
44353: LD_EXP 50
44357: NOT
44358: PUSH
44359: LD_EXP 48
44363: NOT
44364: OR
44365: IFFALSE 44369
// exit ;
44367: GO 44458
// for i = 1 to mc_bases do
44369: LD_ADDR_VAR 0 4
44373: PUSH
44374: DOUBLE
44375: LD_INT 1
44377: DEC
44378: ST_TO_ADDR
44379: LD_EXP 50
44383: PUSH
44384: FOR_TO
44385: IFFALSE 44456
// begin if building in mc_busy_turret_list [ i ] then
44387: LD_VAR 0 1
44391: PUSH
44392: LD_EXP 60
44396: PUSH
44397: LD_VAR 0 4
44401: ARRAY
44402: IN
44403: IFFALSE 44454
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44405: LD_ADDR_VAR 0 5
44409: PUSH
44410: LD_EXP 60
44414: PUSH
44415: LD_VAR 0 4
44419: ARRAY
44420: PUSH
44421: LD_VAR 0 1
44425: DIFF
44426: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44427: LD_ADDR_EXP 60
44431: PUSH
44432: LD_EXP 60
44436: PPUSH
44437: LD_VAR 0 4
44441: PPUSH
44442: LD_VAR 0 5
44446: PPUSH
44447: CALL_OW 1
44451: ST_TO_ADDR
// break ;
44452: GO 44456
// end ; end ;
44454: GO 44384
44456: POP
44457: POP
// end ;
44458: LD_VAR 0 3
44462: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44463: LD_INT 0
44465: PPUSH
44466: PPUSH
44467: PPUSH
// if not mc_bases or not skirmish then
44468: LD_EXP 50
44472: NOT
44473: PUSH
44474: LD_EXP 48
44478: NOT
44479: OR
44480: IFFALSE 44484
// exit ;
44482: GO 44683
// for i = 1 to mc_bases do
44484: LD_ADDR_VAR 0 5
44488: PUSH
44489: DOUBLE
44490: LD_INT 1
44492: DEC
44493: ST_TO_ADDR
44494: LD_EXP 50
44498: PUSH
44499: FOR_TO
44500: IFFALSE 44681
// if building in mc_bases [ i ] then
44502: LD_VAR 0 1
44506: PUSH
44507: LD_EXP 50
44511: PUSH
44512: LD_VAR 0 5
44516: ARRAY
44517: IN
44518: IFFALSE 44679
// begin tmp := mc_bases [ i ] diff building ;
44520: LD_ADDR_VAR 0 6
44524: PUSH
44525: LD_EXP 50
44529: PUSH
44530: LD_VAR 0 5
44534: ARRAY
44535: PUSH
44536: LD_VAR 0 1
44540: DIFF
44541: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44542: LD_ADDR_EXP 50
44546: PUSH
44547: LD_EXP 50
44551: PPUSH
44552: LD_VAR 0 5
44556: PPUSH
44557: LD_VAR 0 6
44561: PPUSH
44562: CALL_OW 1
44566: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44567: LD_VAR 0 1
44571: PUSH
44572: LD_EXP 58
44576: PUSH
44577: LD_VAR 0 5
44581: ARRAY
44582: IN
44583: IFFALSE 44622
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44585: LD_ADDR_EXP 58
44589: PUSH
44590: LD_EXP 58
44594: PPUSH
44595: LD_VAR 0 5
44599: PPUSH
44600: LD_EXP 58
44604: PUSH
44605: LD_VAR 0 5
44609: ARRAY
44610: PUSH
44611: LD_VAR 0 1
44615: DIFF
44616: PPUSH
44617: CALL_OW 1
44621: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44622: LD_VAR 0 1
44626: PUSH
44627: LD_EXP 59
44631: PUSH
44632: LD_VAR 0 5
44636: ARRAY
44637: IN
44638: IFFALSE 44677
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44640: LD_ADDR_EXP 59
44644: PUSH
44645: LD_EXP 59
44649: PPUSH
44650: LD_VAR 0 5
44654: PPUSH
44655: LD_EXP 59
44659: PUSH
44660: LD_VAR 0 5
44664: ARRAY
44665: PUSH
44666: LD_VAR 0 1
44670: DIFF
44671: PPUSH
44672: CALL_OW 1
44676: ST_TO_ADDR
// break ;
44677: GO 44681
// end ;
44679: GO 44499
44681: POP
44682: POP
// end ;
44683: LD_VAR 0 4
44687: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44688: LD_INT 0
44690: PPUSH
44691: PPUSH
44692: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44693: LD_EXP 50
44697: NOT
44698: PUSH
44699: LD_EXP 48
44703: NOT
44704: OR
44705: PUSH
44706: LD_VAR 0 3
44710: PUSH
44711: LD_EXP 76
44715: IN
44716: NOT
44717: OR
44718: IFFALSE 44722
// exit ;
44720: GO 44845
// for i = 1 to mc_vehicles do
44722: LD_ADDR_VAR 0 6
44726: PUSH
44727: DOUBLE
44728: LD_INT 1
44730: DEC
44731: ST_TO_ADDR
44732: LD_EXP 69
44736: PUSH
44737: FOR_TO
44738: IFFALSE 44843
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44740: LD_VAR 0 2
44744: PUSH
44745: LD_EXP 69
44749: PUSH
44750: LD_VAR 0 6
44754: ARRAY
44755: IN
44756: PUSH
44757: LD_VAR 0 1
44761: PUSH
44762: LD_EXP 69
44766: PUSH
44767: LD_VAR 0 6
44771: ARRAY
44772: IN
44773: OR
44774: IFFALSE 44841
// begin tmp := mc_vehicles [ i ] diff old ;
44776: LD_ADDR_VAR 0 7
44780: PUSH
44781: LD_EXP 69
44785: PUSH
44786: LD_VAR 0 6
44790: ARRAY
44791: PUSH
44792: LD_VAR 0 2
44796: DIFF
44797: ST_TO_ADDR
// tmp := tmp diff new ;
44798: LD_ADDR_VAR 0 7
44802: PUSH
44803: LD_VAR 0 7
44807: PUSH
44808: LD_VAR 0 1
44812: DIFF
44813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44814: LD_ADDR_EXP 69
44818: PUSH
44819: LD_EXP 69
44823: PPUSH
44824: LD_VAR 0 6
44828: PPUSH
44829: LD_VAR 0 7
44833: PPUSH
44834: CALL_OW 1
44838: ST_TO_ADDR
// break ;
44839: GO 44843
// end ;
44841: GO 44737
44843: POP
44844: POP
// end ;
44845: LD_VAR 0 5
44849: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44850: LD_INT 0
44852: PPUSH
44853: PPUSH
44854: PPUSH
44855: PPUSH
// if not mc_bases or not skirmish then
44856: LD_EXP 50
44860: NOT
44861: PUSH
44862: LD_EXP 48
44866: NOT
44867: OR
44868: IFFALSE 44872
// exit ;
44870: GO 45292
// repeat wait ( 0 0$1 ) ;
44872: LD_INT 35
44874: PPUSH
44875: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
44879: LD_EXP 94
44883: NOT
44884: IFFALSE 44872
// mc_block_vehicle_constructed_thread := true ;
44886: LD_ADDR_EXP 94
44890: PUSH
44891: LD_INT 1
44893: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
44894: LD_ADDR_VAR 0 5
44898: PUSH
44899: LD_VAR 0 1
44903: PPUSH
44904: CALL_OW 255
44908: ST_TO_ADDR
// for i = 1 to mc_bases do
44909: LD_ADDR_VAR 0 4
44913: PUSH
44914: DOUBLE
44915: LD_INT 1
44917: DEC
44918: ST_TO_ADDR
44919: LD_EXP 50
44923: PUSH
44924: FOR_TO
44925: IFFALSE 45282
// begin if factory in mc_bases [ i ] then
44927: LD_VAR 0 2
44931: PUSH
44932: LD_EXP 50
44936: PUSH
44937: LD_VAR 0 4
44941: ARRAY
44942: IN
44943: IFFALSE 45280
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44945: LD_EXP 72
44949: PUSH
44950: LD_VAR 0 4
44954: ARRAY
44955: PUSH
44956: LD_EXP 61
44960: PUSH
44961: LD_VAR 0 4
44965: ARRAY
44966: LESS
44967: PUSH
44968: LD_VAR 0 1
44972: PPUSH
44973: CALL_OW 264
44977: PUSH
44978: LD_INT 31
44980: PUSH
44981: LD_INT 32
44983: PUSH
44984: LD_INT 51
44986: PUSH
44987: LD_INT 89
44989: PUSH
44990: LD_INT 12
44992: PUSH
44993: LD_INT 30
44995: PUSH
44996: LD_INT 98
44998: PUSH
44999: LD_INT 11
45001: PUSH
45002: LD_INT 53
45004: PUSH
45005: LD_INT 14
45007: PUSH
45008: LD_INT 91
45010: PUSH
45011: LD_INT 29
45013: PUSH
45014: LD_INT 99
45016: PUSH
45017: LD_INT 13
45019: PUSH
45020: LD_INT 52
45022: PUSH
45023: LD_INT 88
45025: PUSH
45026: LD_INT 48
45028: PUSH
45029: LD_INT 8
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: IN
45052: NOT
45053: AND
45054: IFFALSE 45102
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45056: LD_ADDR_EXP 72
45060: PUSH
45061: LD_EXP 72
45065: PPUSH
45066: LD_VAR 0 4
45070: PUSH
45071: LD_EXP 72
45075: PUSH
45076: LD_VAR 0 4
45080: ARRAY
45081: PUSH
45082: LD_INT 1
45084: PLUS
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PPUSH
45090: LD_VAR 0 1
45094: PPUSH
45095: CALL 54011 0 3
45099: ST_TO_ADDR
45100: GO 45146
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45102: LD_ADDR_EXP 69
45106: PUSH
45107: LD_EXP 69
45111: PPUSH
45112: LD_VAR 0 4
45116: PUSH
45117: LD_EXP 69
45121: PUSH
45122: LD_VAR 0 4
45126: ARRAY
45127: PUSH
45128: LD_INT 1
45130: PLUS
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PPUSH
45136: LD_VAR 0 1
45140: PPUSH
45141: CALL 54011 0 3
45145: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45146: LD_ADDR_EXP 94
45150: PUSH
45151: LD_INT 0
45153: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45154: LD_VAR 0 1
45158: PPUSH
45159: CALL_OW 263
45163: PUSH
45164: LD_INT 2
45166: EQUAL
45167: IFFALSE 45196
// begin repeat wait ( 0 0$3 ) ;
45169: LD_INT 105
45171: PPUSH
45172: CALL_OW 67
// Connect ( vehicle ) ;
45176: LD_VAR 0 1
45180: PPUSH
45181: CALL 57357 0 1
// until IsControledBy ( vehicle ) ;
45185: LD_VAR 0 1
45189: PPUSH
45190: CALL_OW 312
45194: IFFALSE 45169
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45196: LD_VAR 0 1
45200: PPUSH
45201: LD_EXP 74
45205: PUSH
45206: LD_VAR 0 4
45210: ARRAY
45211: PPUSH
45212: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45216: LD_VAR 0 1
45220: PPUSH
45221: CALL_OW 263
45225: PUSH
45226: LD_INT 1
45228: NONEQUAL
45229: IFFALSE 45233
// break ;
45231: GO 45282
// repeat wait ( 0 0$1 ) ;
45233: LD_INT 35
45235: PPUSH
45236: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45240: LD_VAR 0 1
45244: PPUSH
45245: LD_EXP 74
45249: PUSH
45250: LD_VAR 0 4
45254: ARRAY
45255: PPUSH
45256: CALL_OW 308
45260: IFFALSE 45233
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45262: LD_VAR 0 1
45266: PPUSH
45267: CALL_OW 311
45271: PPUSH
45272: CALL_OW 121
// exit ;
45276: POP
45277: POP
45278: GO 45292
// end ; end ;
45280: GO 44924
45282: POP
45283: POP
// mc_block_vehicle_constructed_thread := false ;
45284: LD_ADDR_EXP 94
45288: PUSH
45289: LD_INT 0
45291: ST_TO_ADDR
// end ;
45292: LD_VAR 0 3
45296: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45297: LD_INT 0
45299: PPUSH
45300: PPUSH
45301: PPUSH
45302: PPUSH
// if not mc_bases or not skirmish then
45303: LD_EXP 50
45307: NOT
45308: PUSH
45309: LD_EXP 48
45313: NOT
45314: OR
45315: IFFALSE 45319
// exit ;
45317: GO 45672
// repeat wait ( 0 0$1 ) ;
45319: LD_INT 35
45321: PPUSH
45322: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45326: LD_VAR 0 2
45330: PPUSH
45331: LD_VAR 0 3
45335: PPUSH
45336: CALL_OW 284
45340: IFFALSE 45319
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45342: LD_VAR 0 2
45346: PPUSH
45347: LD_VAR 0 3
45351: PPUSH
45352: CALL_OW 283
45356: PUSH
45357: LD_INT 4
45359: EQUAL
45360: IFFALSE 45364
// exit ;
45362: GO 45672
// for i = 1 to mc_bases do
45364: LD_ADDR_VAR 0 7
45368: PUSH
45369: DOUBLE
45370: LD_INT 1
45372: DEC
45373: ST_TO_ADDR
45374: LD_EXP 50
45378: PUSH
45379: FOR_TO
45380: IFFALSE 45670
// begin if mc_crates_area [ i ] then
45382: LD_EXP 68
45386: PUSH
45387: LD_VAR 0 7
45391: ARRAY
45392: IFFALSE 45503
// for j in mc_crates_area [ i ] do
45394: LD_ADDR_VAR 0 8
45398: PUSH
45399: LD_EXP 68
45403: PUSH
45404: LD_VAR 0 7
45408: ARRAY
45409: PUSH
45410: FOR_IN
45411: IFFALSE 45501
// if InArea ( x , y , j ) then
45413: LD_VAR 0 2
45417: PPUSH
45418: LD_VAR 0 3
45422: PPUSH
45423: LD_VAR 0 8
45427: PPUSH
45428: CALL_OW 309
45432: IFFALSE 45499
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45434: LD_ADDR_EXP 66
45438: PUSH
45439: LD_EXP 66
45443: PPUSH
45444: LD_VAR 0 7
45448: PUSH
45449: LD_EXP 66
45453: PUSH
45454: LD_VAR 0 7
45458: ARRAY
45459: PUSH
45460: LD_INT 1
45462: PLUS
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PPUSH
45468: LD_VAR 0 4
45472: PUSH
45473: LD_VAR 0 2
45477: PUSH
45478: LD_VAR 0 3
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: LIST
45487: PPUSH
45488: CALL 54011 0 3
45492: ST_TO_ADDR
// exit ;
45493: POP
45494: POP
45495: POP
45496: POP
45497: GO 45672
// end ;
45499: GO 45410
45501: POP
45502: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45503: LD_ADDR_VAR 0 9
45507: PUSH
45508: LD_EXP 50
45512: PUSH
45513: LD_VAR 0 7
45517: ARRAY
45518: PPUSH
45519: LD_INT 2
45521: PUSH
45522: LD_INT 30
45524: PUSH
45525: LD_INT 0
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: LD_INT 30
45534: PUSH
45535: LD_INT 1
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: LIST
45546: PPUSH
45547: CALL_OW 72
45551: ST_TO_ADDR
// if not depot then
45552: LD_VAR 0 9
45556: NOT
45557: IFFALSE 45561
// continue ;
45559: GO 45379
// for j in depot do
45561: LD_ADDR_VAR 0 8
45565: PUSH
45566: LD_VAR 0 9
45570: PUSH
45571: FOR_IN
45572: IFFALSE 45666
// if GetDistUnitXY ( j , x , y ) < 30 then
45574: LD_VAR 0 8
45578: PPUSH
45579: LD_VAR 0 2
45583: PPUSH
45584: LD_VAR 0 3
45588: PPUSH
45589: CALL_OW 297
45593: PUSH
45594: LD_INT 30
45596: LESS
45597: IFFALSE 45664
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45599: LD_ADDR_EXP 66
45603: PUSH
45604: LD_EXP 66
45608: PPUSH
45609: LD_VAR 0 7
45613: PUSH
45614: LD_EXP 66
45618: PUSH
45619: LD_VAR 0 7
45623: ARRAY
45624: PUSH
45625: LD_INT 1
45627: PLUS
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PPUSH
45633: LD_VAR 0 4
45637: PUSH
45638: LD_VAR 0 2
45642: PUSH
45643: LD_VAR 0 3
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: LIST
45652: PPUSH
45653: CALL 54011 0 3
45657: ST_TO_ADDR
// exit ;
45658: POP
45659: POP
45660: POP
45661: POP
45662: GO 45672
// end ;
45664: GO 45571
45666: POP
45667: POP
// end ;
45668: GO 45379
45670: POP
45671: POP
// end ;
45672: LD_VAR 0 6
45676: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45677: LD_INT 0
45679: PPUSH
45680: PPUSH
45681: PPUSH
45682: PPUSH
// if not mc_bases or not skirmish then
45683: LD_EXP 50
45687: NOT
45688: PUSH
45689: LD_EXP 48
45693: NOT
45694: OR
45695: IFFALSE 45699
// exit ;
45697: GO 45976
// side := GetSide ( lab ) ;
45699: LD_ADDR_VAR 0 4
45703: PUSH
45704: LD_VAR 0 2
45708: PPUSH
45709: CALL_OW 255
45713: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45714: LD_VAR 0 4
45718: PUSH
45719: LD_EXP 76
45723: IN
45724: NOT
45725: PUSH
45726: LD_EXP 77
45730: NOT
45731: OR
45732: PUSH
45733: LD_EXP 50
45737: NOT
45738: OR
45739: IFFALSE 45743
// exit ;
45741: GO 45976
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45743: LD_ADDR_EXP 77
45747: PUSH
45748: LD_EXP 77
45752: PPUSH
45753: LD_VAR 0 4
45757: PPUSH
45758: LD_EXP 77
45762: PUSH
45763: LD_VAR 0 4
45767: ARRAY
45768: PUSH
45769: LD_VAR 0 1
45773: DIFF
45774: PPUSH
45775: CALL_OW 1
45779: ST_TO_ADDR
// for i = 1 to mc_bases do
45780: LD_ADDR_VAR 0 5
45784: PUSH
45785: DOUBLE
45786: LD_INT 1
45788: DEC
45789: ST_TO_ADDR
45790: LD_EXP 50
45794: PUSH
45795: FOR_TO
45796: IFFALSE 45974
// begin if lab in mc_bases [ i ] then
45798: LD_VAR 0 2
45802: PUSH
45803: LD_EXP 50
45807: PUSH
45808: LD_VAR 0 5
45812: ARRAY
45813: IN
45814: IFFALSE 45972
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45816: LD_VAR 0 1
45820: PUSH
45821: LD_INT 11
45823: PUSH
45824: LD_INT 4
45826: PUSH
45827: LD_INT 3
45829: PUSH
45830: LD_INT 2
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: IN
45839: PUSH
45840: LD_EXP 80
45844: PUSH
45845: LD_VAR 0 5
45849: ARRAY
45850: AND
45851: IFFALSE 45972
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45853: LD_ADDR_VAR 0 6
45857: PUSH
45858: LD_EXP 80
45862: PUSH
45863: LD_VAR 0 5
45867: ARRAY
45868: PUSH
45869: LD_INT 1
45871: ARRAY
45872: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45873: LD_ADDR_EXP 80
45877: PUSH
45878: LD_EXP 80
45882: PPUSH
45883: LD_VAR 0 5
45887: PPUSH
45888: EMPTY
45889: PPUSH
45890: CALL_OW 1
45894: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45895: LD_VAR 0 6
45899: PPUSH
45900: LD_INT 0
45902: PPUSH
45903: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45907: LD_VAR 0 6
45911: PPUSH
45912: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45916: LD_ADDR_EXP 79
45920: PUSH
45921: LD_EXP 79
45925: PPUSH
45926: LD_VAR 0 5
45930: PPUSH
45931: LD_EXP 79
45935: PUSH
45936: LD_VAR 0 5
45940: ARRAY
45941: PPUSH
45942: LD_INT 1
45944: PPUSH
45945: LD_VAR 0 6
45949: PPUSH
45950: CALL_OW 2
45954: PPUSH
45955: CALL_OW 1
45959: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45960: LD_VAR 0 5
45964: PPUSH
45965: LD_INT 112
45967: PPUSH
45968: CALL 22426 0 2
// end ; end ; end ;
45972: GO 45795
45974: POP
45975: POP
// end ;
45976: LD_VAR 0 3
45980: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45981: LD_INT 0
45983: PPUSH
45984: PPUSH
45985: PPUSH
45986: PPUSH
45987: PPUSH
45988: PPUSH
45989: PPUSH
45990: PPUSH
// if not mc_bases or not skirmish then
45991: LD_EXP 50
45995: NOT
45996: PUSH
45997: LD_EXP 48
46001: NOT
46002: OR
46003: IFFALSE 46007
// exit ;
46005: GO 47376
// for i = 1 to mc_bases do
46007: LD_ADDR_VAR 0 3
46011: PUSH
46012: DOUBLE
46013: LD_INT 1
46015: DEC
46016: ST_TO_ADDR
46017: LD_EXP 50
46021: PUSH
46022: FOR_TO
46023: IFFALSE 47374
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46025: LD_VAR 0 1
46029: PUSH
46030: LD_EXP 50
46034: PUSH
46035: LD_VAR 0 3
46039: ARRAY
46040: IN
46041: PUSH
46042: LD_VAR 0 1
46046: PUSH
46047: LD_EXP 57
46051: PUSH
46052: LD_VAR 0 3
46056: ARRAY
46057: IN
46058: OR
46059: PUSH
46060: LD_VAR 0 1
46064: PUSH
46065: LD_EXP 72
46069: PUSH
46070: LD_VAR 0 3
46074: ARRAY
46075: IN
46076: OR
46077: PUSH
46078: LD_VAR 0 1
46082: PUSH
46083: LD_EXP 69
46087: PUSH
46088: LD_VAR 0 3
46092: ARRAY
46093: IN
46094: OR
46095: PUSH
46096: LD_VAR 0 1
46100: PUSH
46101: LD_EXP 79
46105: PUSH
46106: LD_VAR 0 3
46110: ARRAY
46111: IN
46112: OR
46113: PUSH
46114: LD_VAR 0 1
46118: PUSH
46119: LD_EXP 80
46123: PUSH
46124: LD_VAR 0 3
46128: ARRAY
46129: IN
46130: OR
46131: IFFALSE 47372
// begin if un in mc_ape [ i ] then
46133: LD_VAR 0 1
46137: PUSH
46138: LD_EXP 79
46142: PUSH
46143: LD_VAR 0 3
46147: ARRAY
46148: IN
46149: IFFALSE 46188
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46151: LD_ADDR_EXP 79
46155: PUSH
46156: LD_EXP 79
46160: PPUSH
46161: LD_VAR 0 3
46165: PPUSH
46166: LD_EXP 79
46170: PUSH
46171: LD_VAR 0 3
46175: ARRAY
46176: PUSH
46177: LD_VAR 0 1
46181: DIFF
46182: PPUSH
46183: CALL_OW 1
46187: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46188: LD_VAR 0 1
46192: PUSH
46193: LD_EXP 80
46197: PUSH
46198: LD_VAR 0 3
46202: ARRAY
46203: IN
46204: IFFALSE 46228
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46206: LD_ADDR_EXP 80
46210: PUSH
46211: LD_EXP 80
46215: PPUSH
46216: LD_VAR 0 3
46220: PPUSH
46221: EMPTY
46222: PPUSH
46223: CALL_OW 1
46227: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46228: LD_VAR 0 1
46232: PPUSH
46233: CALL_OW 247
46237: PUSH
46238: LD_INT 2
46240: EQUAL
46241: PUSH
46242: LD_VAR 0 1
46246: PPUSH
46247: CALL_OW 110
46251: PUSH
46252: LD_INT 20
46254: EQUAL
46255: PUSH
46256: LD_VAR 0 1
46260: PUSH
46261: LD_EXP 72
46265: PUSH
46266: LD_VAR 0 3
46270: ARRAY
46271: IN
46272: OR
46273: PUSH
46274: LD_VAR 0 1
46278: PPUSH
46279: CALL_OW 264
46283: PUSH
46284: LD_INT 12
46286: PUSH
46287: LD_INT 51
46289: PUSH
46290: LD_INT 89
46292: PUSH
46293: LD_INT 32
46295: PUSH
46296: LD_INT 13
46298: PUSH
46299: LD_INT 52
46301: PUSH
46302: LD_INT 31
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: IN
46314: OR
46315: AND
46316: IFFALSE 46624
// begin if un in mc_defender [ i ] then
46318: LD_VAR 0 1
46322: PUSH
46323: LD_EXP 72
46327: PUSH
46328: LD_VAR 0 3
46332: ARRAY
46333: IN
46334: IFFALSE 46373
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46336: LD_ADDR_EXP 72
46340: PUSH
46341: LD_EXP 72
46345: PPUSH
46346: LD_VAR 0 3
46350: PPUSH
46351: LD_EXP 72
46355: PUSH
46356: LD_VAR 0 3
46360: ARRAY
46361: PUSH
46362: LD_VAR 0 1
46366: DIFF
46367: PPUSH
46368: CALL_OW 1
46372: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46373: LD_ADDR_VAR 0 8
46377: PUSH
46378: LD_VAR 0 3
46382: PPUSH
46383: LD_INT 3
46385: PPUSH
46386: CALL 42994 0 2
46390: ST_TO_ADDR
// if fac then
46391: LD_VAR 0 8
46395: IFFALSE 46624
// begin for j in fac do
46397: LD_ADDR_VAR 0 4
46401: PUSH
46402: LD_VAR 0 8
46406: PUSH
46407: FOR_IN
46408: IFFALSE 46622
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46410: LD_ADDR_VAR 0 9
46414: PUSH
46415: LD_VAR 0 8
46419: PPUSH
46420: LD_VAR 0 1
46424: PPUSH
46425: CALL_OW 265
46429: PPUSH
46430: LD_VAR 0 1
46434: PPUSH
46435: CALL_OW 262
46439: PPUSH
46440: LD_VAR 0 1
46444: PPUSH
46445: CALL_OW 263
46449: PPUSH
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 264
46459: PPUSH
46460: CALL 51509 0 5
46464: ST_TO_ADDR
// if components then
46465: LD_VAR 0 9
46469: IFFALSE 46620
// begin if GetWeapon ( un ) = ar_control_tower then
46471: LD_VAR 0 1
46475: PPUSH
46476: CALL_OW 264
46480: PUSH
46481: LD_INT 31
46483: EQUAL
46484: IFFALSE 46601
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46486: LD_VAR 0 1
46490: PPUSH
46491: CALL_OW 311
46495: PPUSH
46496: LD_INT 0
46498: PPUSH
46499: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46503: LD_ADDR_EXP 90
46507: PUSH
46508: LD_EXP 90
46512: PPUSH
46513: LD_VAR 0 3
46517: PPUSH
46518: LD_EXP 90
46522: PUSH
46523: LD_VAR 0 3
46527: ARRAY
46528: PUSH
46529: LD_VAR 0 1
46533: PPUSH
46534: CALL_OW 311
46538: DIFF
46539: PPUSH
46540: CALL_OW 1
46544: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46545: LD_ADDR_VAR 0 7
46549: PUSH
46550: LD_EXP 71
46554: PUSH
46555: LD_VAR 0 3
46559: ARRAY
46560: PPUSH
46561: LD_INT 1
46563: PPUSH
46564: LD_VAR 0 9
46568: PPUSH
46569: CALL_OW 2
46573: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46574: LD_ADDR_EXP 71
46578: PUSH
46579: LD_EXP 71
46583: PPUSH
46584: LD_VAR 0 3
46588: PPUSH
46589: LD_VAR 0 7
46593: PPUSH
46594: CALL_OW 1
46598: ST_TO_ADDR
// end else
46599: GO 46618
// MC_InsertProduceList ( i , [ components ] ) ;
46601: LD_VAR 0 3
46605: PPUSH
46606: LD_VAR 0 9
46610: PUSH
46611: EMPTY
46612: LIST
46613: PPUSH
46614: CALL 42539 0 2
// break ;
46618: GO 46622
// end ; end ;
46620: GO 46407
46622: POP
46623: POP
// end ; end ; if GetType ( un ) = unit_building then
46624: LD_VAR 0 1
46628: PPUSH
46629: CALL_OW 247
46633: PUSH
46634: LD_INT 3
46636: EQUAL
46637: IFFALSE 47040
// begin btype := GetBType ( un ) ;
46639: LD_ADDR_VAR 0 5
46643: PUSH
46644: LD_VAR 0 1
46648: PPUSH
46649: CALL_OW 266
46653: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46654: LD_VAR 0 5
46658: PUSH
46659: LD_INT 29
46661: PUSH
46662: LD_INT 30
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: IN
46669: IFFALSE 46742
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46671: LD_VAR 0 1
46675: PPUSH
46676: CALL_OW 250
46680: PPUSH
46681: LD_VAR 0 1
46685: PPUSH
46686: CALL_OW 251
46690: PPUSH
46691: LD_VAR 0 1
46695: PPUSH
46696: CALL_OW 255
46700: PPUSH
46701: CALL_OW 440
46705: NOT
46706: IFFALSE 46742
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46708: LD_VAR 0 1
46712: PPUSH
46713: CALL_OW 250
46717: PPUSH
46718: LD_VAR 0 1
46722: PPUSH
46723: CALL_OW 251
46727: PPUSH
46728: LD_VAR 0 1
46732: PPUSH
46733: CALL_OW 255
46737: PPUSH
46738: CALL_OW 441
// end ; if btype = b_warehouse then
46742: LD_VAR 0 5
46746: PUSH
46747: LD_INT 1
46749: EQUAL
46750: IFFALSE 46768
// begin btype := b_depot ;
46752: LD_ADDR_VAR 0 5
46756: PUSH
46757: LD_INT 0
46759: ST_TO_ADDR
// pos := 1 ;
46760: LD_ADDR_VAR 0 6
46764: PUSH
46765: LD_INT 1
46767: ST_TO_ADDR
// end ; if btype = b_factory then
46768: LD_VAR 0 5
46772: PUSH
46773: LD_INT 3
46775: EQUAL
46776: IFFALSE 46794
// begin btype := b_workshop ;
46778: LD_ADDR_VAR 0 5
46782: PUSH
46783: LD_INT 2
46785: ST_TO_ADDR
// pos := 1 ;
46786: LD_ADDR_VAR 0 6
46790: PUSH
46791: LD_INT 1
46793: ST_TO_ADDR
// end ; if btype = b_barracks then
46794: LD_VAR 0 5
46798: PUSH
46799: LD_INT 5
46801: EQUAL
46802: IFFALSE 46812
// btype := b_armoury ;
46804: LD_ADDR_VAR 0 5
46808: PUSH
46809: LD_INT 4
46811: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46812: LD_VAR 0 5
46816: PUSH
46817: LD_INT 7
46819: PUSH
46820: LD_INT 8
46822: PUSH
46823: EMPTY
46824: LIST
46825: LIST
46826: IN
46827: IFFALSE 46837
// btype := b_lab ;
46829: LD_ADDR_VAR 0 5
46833: PUSH
46834: LD_INT 6
46836: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46837: LD_ADDR_EXP 55
46841: PUSH
46842: LD_EXP 55
46846: PPUSH
46847: LD_VAR 0 3
46851: PUSH
46852: LD_EXP 55
46856: PUSH
46857: LD_VAR 0 3
46861: ARRAY
46862: PUSH
46863: LD_INT 1
46865: PLUS
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PPUSH
46871: LD_VAR 0 5
46875: PUSH
46876: LD_VAR 0 1
46880: PPUSH
46881: CALL_OW 250
46885: PUSH
46886: LD_VAR 0 1
46890: PPUSH
46891: CALL_OW 251
46895: PUSH
46896: LD_VAR 0 1
46900: PPUSH
46901: CALL_OW 254
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: PPUSH
46912: CALL 54011 0 3
46916: ST_TO_ADDR
// if pos = 1 then
46917: LD_VAR 0 6
46921: PUSH
46922: LD_INT 1
46924: EQUAL
46925: IFFALSE 47040
// begin tmp := mc_build_list [ i ] ;
46927: LD_ADDR_VAR 0 7
46931: PUSH
46932: LD_EXP 55
46936: PUSH
46937: LD_VAR 0 3
46941: ARRAY
46942: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46943: LD_VAR 0 7
46947: PPUSH
46948: LD_INT 2
46950: PUSH
46951: LD_INT 30
46953: PUSH
46954: LD_INT 0
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 30
46963: PUSH
46964: LD_INT 1
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: LIST
46975: PPUSH
46976: CALL_OW 72
46980: IFFALSE 46990
// pos := 2 ;
46982: LD_ADDR_VAR 0 6
46986: PUSH
46987: LD_INT 2
46989: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46990: LD_ADDR_VAR 0 7
46994: PUSH
46995: LD_VAR 0 7
46999: PPUSH
47000: LD_VAR 0 6
47004: PPUSH
47005: LD_VAR 0 7
47009: PPUSH
47010: CALL 54337 0 3
47014: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47015: LD_ADDR_EXP 55
47019: PUSH
47020: LD_EXP 55
47024: PPUSH
47025: LD_VAR 0 3
47029: PPUSH
47030: LD_VAR 0 7
47034: PPUSH
47035: CALL_OW 1
47039: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47040: LD_VAR 0 1
47044: PUSH
47045: LD_EXP 50
47049: PUSH
47050: LD_VAR 0 3
47054: ARRAY
47055: IN
47056: IFFALSE 47095
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47058: LD_ADDR_EXP 50
47062: PUSH
47063: LD_EXP 50
47067: PPUSH
47068: LD_VAR 0 3
47072: PPUSH
47073: LD_EXP 50
47077: PUSH
47078: LD_VAR 0 3
47082: ARRAY
47083: PUSH
47084: LD_VAR 0 1
47088: DIFF
47089: PPUSH
47090: CALL_OW 1
47094: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47095: LD_VAR 0 1
47099: PUSH
47100: LD_EXP 57
47104: PUSH
47105: LD_VAR 0 3
47109: ARRAY
47110: IN
47111: IFFALSE 47150
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47113: LD_ADDR_EXP 57
47117: PUSH
47118: LD_EXP 57
47122: PPUSH
47123: LD_VAR 0 3
47127: PPUSH
47128: LD_EXP 57
47132: PUSH
47133: LD_VAR 0 3
47137: ARRAY
47138: PUSH
47139: LD_VAR 0 1
47143: DIFF
47144: PPUSH
47145: CALL_OW 1
47149: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47150: LD_VAR 0 1
47154: PUSH
47155: LD_EXP 69
47159: PUSH
47160: LD_VAR 0 3
47164: ARRAY
47165: IN
47166: IFFALSE 47205
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47168: LD_ADDR_EXP 69
47172: PUSH
47173: LD_EXP 69
47177: PPUSH
47178: LD_VAR 0 3
47182: PPUSH
47183: LD_EXP 69
47187: PUSH
47188: LD_VAR 0 3
47192: ARRAY
47193: PUSH
47194: LD_VAR 0 1
47198: DIFF
47199: PPUSH
47200: CALL_OW 1
47204: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47205: LD_VAR 0 1
47209: PUSH
47210: LD_EXP 72
47214: PUSH
47215: LD_VAR 0 3
47219: ARRAY
47220: IN
47221: IFFALSE 47260
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47223: LD_ADDR_EXP 72
47227: PUSH
47228: LD_EXP 72
47232: PPUSH
47233: LD_VAR 0 3
47237: PPUSH
47238: LD_EXP 72
47242: PUSH
47243: LD_VAR 0 3
47247: ARRAY
47248: PUSH
47249: LD_VAR 0 1
47253: DIFF
47254: PPUSH
47255: CALL_OW 1
47259: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47260: LD_VAR 0 1
47264: PUSH
47265: LD_EXP 59
47269: PUSH
47270: LD_VAR 0 3
47274: ARRAY
47275: IN
47276: IFFALSE 47315
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47278: LD_ADDR_EXP 59
47282: PUSH
47283: LD_EXP 59
47287: PPUSH
47288: LD_VAR 0 3
47292: PPUSH
47293: LD_EXP 59
47297: PUSH
47298: LD_VAR 0 3
47302: ARRAY
47303: PUSH
47304: LD_VAR 0 1
47308: DIFF
47309: PPUSH
47310: CALL_OW 1
47314: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47315: LD_VAR 0 1
47319: PUSH
47320: LD_EXP 58
47324: PUSH
47325: LD_VAR 0 3
47329: ARRAY
47330: IN
47331: IFFALSE 47370
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47333: LD_ADDR_EXP 58
47337: PUSH
47338: LD_EXP 58
47342: PPUSH
47343: LD_VAR 0 3
47347: PPUSH
47348: LD_EXP 58
47352: PUSH
47353: LD_VAR 0 3
47357: ARRAY
47358: PUSH
47359: LD_VAR 0 1
47363: DIFF
47364: PPUSH
47365: CALL_OW 1
47369: ST_TO_ADDR
// end ; break ;
47370: GO 47374
// end ;
47372: GO 46022
47374: POP
47375: POP
// end ;
47376: LD_VAR 0 2
47380: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47381: LD_INT 0
47383: PPUSH
47384: PPUSH
47385: PPUSH
// if not mc_bases or not skirmish then
47386: LD_EXP 50
47390: NOT
47391: PUSH
47392: LD_EXP 48
47396: NOT
47397: OR
47398: IFFALSE 47402
// exit ;
47400: GO 47617
// for i = 1 to mc_bases do
47402: LD_ADDR_VAR 0 3
47406: PUSH
47407: DOUBLE
47408: LD_INT 1
47410: DEC
47411: ST_TO_ADDR
47412: LD_EXP 50
47416: PUSH
47417: FOR_TO
47418: IFFALSE 47615
// begin if building in mc_construct_list [ i ] then
47420: LD_VAR 0 1
47424: PUSH
47425: LD_EXP 57
47429: PUSH
47430: LD_VAR 0 3
47434: ARRAY
47435: IN
47436: IFFALSE 47613
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47438: LD_ADDR_EXP 57
47442: PUSH
47443: LD_EXP 57
47447: PPUSH
47448: LD_VAR 0 3
47452: PPUSH
47453: LD_EXP 57
47457: PUSH
47458: LD_VAR 0 3
47462: ARRAY
47463: PUSH
47464: LD_VAR 0 1
47468: DIFF
47469: PPUSH
47470: CALL_OW 1
47474: ST_TO_ADDR
// if building in mc_lab [ i ] then
47475: LD_VAR 0 1
47479: PUSH
47480: LD_EXP 83
47484: PUSH
47485: LD_VAR 0 3
47489: ARRAY
47490: IN
47491: IFFALSE 47546
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47493: LD_ADDR_EXP 84
47497: PUSH
47498: LD_EXP 84
47502: PPUSH
47503: LD_VAR 0 3
47507: PPUSH
47508: LD_EXP 84
47512: PUSH
47513: LD_VAR 0 3
47517: ARRAY
47518: PPUSH
47519: LD_INT 1
47521: PPUSH
47522: LD_EXP 84
47526: PUSH
47527: LD_VAR 0 3
47531: ARRAY
47532: PPUSH
47533: LD_INT 0
47535: PPUSH
47536: CALL 53429 0 4
47540: PPUSH
47541: CALL_OW 1
47545: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47546: LD_VAR 0 1
47550: PUSH
47551: LD_EXP 50
47555: PUSH
47556: LD_VAR 0 3
47560: ARRAY
47561: IN
47562: NOT
47563: IFFALSE 47609
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47565: LD_ADDR_EXP 50
47569: PUSH
47570: LD_EXP 50
47574: PPUSH
47575: LD_VAR 0 3
47579: PUSH
47580: LD_EXP 50
47584: PUSH
47585: LD_VAR 0 3
47589: ARRAY
47590: PUSH
47591: LD_INT 1
47593: PLUS
47594: PUSH
47595: EMPTY
47596: LIST
47597: LIST
47598: PPUSH
47599: LD_VAR 0 1
47603: PPUSH
47604: CALL 54011 0 3
47608: ST_TO_ADDR
// exit ;
47609: POP
47610: POP
47611: GO 47617
// end ; end ;
47613: GO 47417
47615: POP
47616: POP
// end ;
47617: LD_VAR 0 2
47621: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47622: LD_INT 0
47624: PPUSH
47625: PPUSH
47626: PPUSH
47627: PPUSH
47628: PPUSH
47629: PPUSH
47630: PPUSH
// if not mc_bases or not skirmish then
47631: LD_EXP 50
47635: NOT
47636: PUSH
47637: LD_EXP 48
47641: NOT
47642: OR
47643: IFFALSE 47647
// exit ;
47645: GO 48308
// for i = 1 to mc_bases do
47647: LD_ADDR_VAR 0 3
47651: PUSH
47652: DOUBLE
47653: LD_INT 1
47655: DEC
47656: ST_TO_ADDR
47657: LD_EXP 50
47661: PUSH
47662: FOR_TO
47663: IFFALSE 48306
// begin if building in mc_construct_list [ i ] then
47665: LD_VAR 0 1
47669: PUSH
47670: LD_EXP 57
47674: PUSH
47675: LD_VAR 0 3
47679: ARRAY
47680: IN
47681: IFFALSE 48304
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47683: LD_ADDR_EXP 57
47687: PUSH
47688: LD_EXP 57
47692: PPUSH
47693: LD_VAR 0 3
47697: PPUSH
47698: LD_EXP 57
47702: PUSH
47703: LD_VAR 0 3
47707: ARRAY
47708: PUSH
47709: LD_VAR 0 1
47713: DIFF
47714: PPUSH
47715: CALL_OW 1
47719: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47720: LD_ADDR_EXP 50
47724: PUSH
47725: LD_EXP 50
47729: PPUSH
47730: LD_VAR 0 3
47734: PUSH
47735: LD_EXP 50
47739: PUSH
47740: LD_VAR 0 3
47744: ARRAY
47745: PUSH
47746: LD_INT 1
47748: PLUS
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PPUSH
47754: LD_VAR 0 1
47758: PPUSH
47759: CALL 54011 0 3
47763: ST_TO_ADDR
// btype := GetBType ( building ) ;
47764: LD_ADDR_VAR 0 5
47768: PUSH
47769: LD_VAR 0 1
47773: PPUSH
47774: CALL_OW 266
47778: ST_TO_ADDR
// side := GetSide ( building ) ;
47779: LD_ADDR_VAR 0 8
47783: PUSH
47784: LD_VAR 0 1
47788: PPUSH
47789: CALL_OW 255
47793: ST_TO_ADDR
// if btype = b_lab then
47794: LD_VAR 0 5
47798: PUSH
47799: LD_INT 6
47801: EQUAL
47802: IFFALSE 47852
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47804: LD_ADDR_EXP 83
47808: PUSH
47809: LD_EXP 83
47813: PPUSH
47814: LD_VAR 0 3
47818: PUSH
47819: LD_EXP 83
47823: PUSH
47824: LD_VAR 0 3
47828: ARRAY
47829: PUSH
47830: LD_INT 1
47832: PLUS
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: PPUSH
47838: LD_VAR 0 1
47842: PPUSH
47843: CALL 54011 0 3
47847: ST_TO_ADDR
// exit ;
47848: POP
47849: POP
47850: GO 48308
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47852: LD_VAR 0 5
47856: PUSH
47857: LD_INT 0
47859: PUSH
47860: LD_INT 2
47862: PUSH
47863: LD_INT 4
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: LIST
47870: IN
47871: IFFALSE 47995
// begin if btype = b_armoury then
47873: LD_VAR 0 5
47877: PUSH
47878: LD_INT 4
47880: EQUAL
47881: IFFALSE 47891
// btype := b_barracks ;
47883: LD_ADDR_VAR 0 5
47887: PUSH
47888: LD_INT 5
47890: ST_TO_ADDR
// if btype = b_depot then
47891: LD_VAR 0 5
47895: PUSH
47896: LD_INT 0
47898: EQUAL
47899: IFFALSE 47909
// btype := b_warehouse ;
47901: LD_ADDR_VAR 0 5
47905: PUSH
47906: LD_INT 1
47908: ST_TO_ADDR
// if btype = b_workshop then
47909: LD_VAR 0 5
47913: PUSH
47914: LD_INT 2
47916: EQUAL
47917: IFFALSE 47927
// btype := b_factory ;
47919: LD_ADDR_VAR 0 5
47923: PUSH
47924: LD_INT 3
47926: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47927: LD_VAR 0 5
47931: PPUSH
47932: LD_VAR 0 8
47936: PPUSH
47937: CALL_OW 323
47941: PUSH
47942: LD_INT 1
47944: EQUAL
47945: IFFALSE 47991
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47947: LD_ADDR_EXP 82
47951: PUSH
47952: LD_EXP 82
47956: PPUSH
47957: LD_VAR 0 3
47961: PUSH
47962: LD_EXP 82
47966: PUSH
47967: LD_VAR 0 3
47971: ARRAY
47972: PUSH
47973: LD_INT 1
47975: PLUS
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: PPUSH
47981: LD_VAR 0 1
47985: PPUSH
47986: CALL 54011 0 3
47990: ST_TO_ADDR
// exit ;
47991: POP
47992: POP
47993: GO 48308
// end ; if btype in [ b_bunker , b_turret ] then
47995: LD_VAR 0 5
47999: PUSH
48000: LD_INT 32
48002: PUSH
48003: LD_INT 33
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: IN
48010: IFFALSE 48300
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48012: LD_ADDR_EXP 58
48016: PUSH
48017: LD_EXP 58
48021: PPUSH
48022: LD_VAR 0 3
48026: PUSH
48027: LD_EXP 58
48031: PUSH
48032: LD_VAR 0 3
48036: ARRAY
48037: PUSH
48038: LD_INT 1
48040: PLUS
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PPUSH
48046: LD_VAR 0 1
48050: PPUSH
48051: CALL 54011 0 3
48055: ST_TO_ADDR
// if btype = b_bunker then
48056: LD_VAR 0 5
48060: PUSH
48061: LD_INT 32
48063: EQUAL
48064: IFFALSE 48300
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48066: LD_ADDR_EXP 59
48070: PUSH
48071: LD_EXP 59
48075: PPUSH
48076: LD_VAR 0 3
48080: PUSH
48081: LD_EXP 59
48085: PUSH
48086: LD_VAR 0 3
48090: ARRAY
48091: PUSH
48092: LD_INT 1
48094: PLUS
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PPUSH
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL 54011 0 3
48109: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48110: LD_ADDR_VAR 0 6
48114: PUSH
48115: LD_EXP 50
48119: PUSH
48120: LD_VAR 0 3
48124: ARRAY
48125: PPUSH
48126: LD_INT 25
48128: PUSH
48129: LD_INT 1
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: PUSH
48136: LD_INT 3
48138: PUSH
48139: LD_INT 54
48141: PUSH
48142: EMPTY
48143: LIST
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PPUSH
48153: CALL_OW 72
48157: ST_TO_ADDR
// if tmp then
48158: LD_VAR 0 6
48162: IFFALSE 48168
// exit ;
48164: POP
48165: POP
48166: GO 48308
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48168: LD_ADDR_VAR 0 6
48172: PUSH
48173: LD_EXP 50
48177: PUSH
48178: LD_VAR 0 3
48182: ARRAY
48183: PPUSH
48184: LD_INT 2
48186: PUSH
48187: LD_INT 30
48189: PUSH
48190: LD_INT 4
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: PUSH
48197: LD_INT 30
48199: PUSH
48200: LD_INT 5
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PUSH
48207: EMPTY
48208: LIST
48209: LIST
48210: LIST
48211: PPUSH
48212: CALL_OW 72
48216: ST_TO_ADDR
// if not tmp then
48217: LD_VAR 0 6
48221: NOT
48222: IFFALSE 48228
// exit ;
48224: POP
48225: POP
48226: GO 48308
// for j in tmp do
48228: LD_ADDR_VAR 0 4
48232: PUSH
48233: LD_VAR 0 6
48237: PUSH
48238: FOR_IN
48239: IFFALSE 48298
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48241: LD_ADDR_VAR 0 7
48245: PUSH
48246: LD_VAR 0 4
48250: PPUSH
48251: CALL_OW 313
48255: PPUSH
48256: LD_INT 25
48258: PUSH
48259: LD_INT 1
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PPUSH
48266: CALL_OW 72
48270: ST_TO_ADDR
// if units then
48271: LD_VAR 0 7
48275: IFFALSE 48296
// begin ComExitBuilding ( units [ 1 ] ) ;
48277: LD_VAR 0 7
48281: PUSH
48282: LD_INT 1
48284: ARRAY
48285: PPUSH
48286: CALL_OW 122
// exit ;
48290: POP
48291: POP
48292: POP
48293: POP
48294: GO 48308
// end ; end ;
48296: GO 48238
48298: POP
48299: POP
// end ; end ; exit ;
48300: POP
48301: POP
48302: GO 48308
// end ; end ;
48304: GO 47662
48306: POP
48307: POP
// end ;
48308: LD_VAR 0 2
48312: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48313: LD_INT 0
48315: PPUSH
48316: PPUSH
48317: PPUSH
48318: PPUSH
48319: PPUSH
48320: PPUSH
48321: PPUSH
// if not mc_bases or not skirmish then
48322: LD_EXP 50
48326: NOT
48327: PUSH
48328: LD_EXP 48
48332: NOT
48333: OR
48334: IFFALSE 48338
// exit ;
48336: GO 48603
// btype := GetBType ( building ) ;
48338: LD_ADDR_VAR 0 6
48342: PUSH
48343: LD_VAR 0 1
48347: PPUSH
48348: CALL_OW 266
48352: ST_TO_ADDR
// x := GetX ( building ) ;
48353: LD_ADDR_VAR 0 7
48357: PUSH
48358: LD_VAR 0 1
48362: PPUSH
48363: CALL_OW 250
48367: ST_TO_ADDR
// y := GetY ( building ) ;
48368: LD_ADDR_VAR 0 8
48372: PUSH
48373: LD_VAR 0 1
48377: PPUSH
48378: CALL_OW 251
48382: ST_TO_ADDR
// d := GetDir ( building ) ;
48383: LD_ADDR_VAR 0 9
48387: PUSH
48388: LD_VAR 0 1
48392: PPUSH
48393: CALL_OW 254
48397: ST_TO_ADDR
// for i = 1 to mc_bases do
48398: LD_ADDR_VAR 0 4
48402: PUSH
48403: DOUBLE
48404: LD_INT 1
48406: DEC
48407: ST_TO_ADDR
48408: LD_EXP 50
48412: PUSH
48413: FOR_TO
48414: IFFALSE 48601
// begin if not mc_build_list [ i ] then
48416: LD_EXP 55
48420: PUSH
48421: LD_VAR 0 4
48425: ARRAY
48426: NOT
48427: IFFALSE 48431
// continue ;
48429: GO 48413
// for j := 1 to mc_build_list [ i ] do
48431: LD_ADDR_VAR 0 5
48435: PUSH
48436: DOUBLE
48437: LD_INT 1
48439: DEC
48440: ST_TO_ADDR
48441: LD_EXP 55
48445: PUSH
48446: LD_VAR 0 4
48450: ARRAY
48451: PUSH
48452: FOR_TO
48453: IFFALSE 48597
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48455: LD_VAR 0 6
48459: PUSH
48460: LD_VAR 0 7
48464: PUSH
48465: LD_VAR 0 8
48469: PUSH
48470: LD_VAR 0 9
48474: PUSH
48475: EMPTY
48476: LIST
48477: LIST
48478: LIST
48479: LIST
48480: PPUSH
48481: LD_EXP 55
48485: PUSH
48486: LD_VAR 0 4
48490: ARRAY
48491: PUSH
48492: LD_VAR 0 5
48496: ARRAY
48497: PPUSH
48498: CALL 60568 0 2
48502: IFFALSE 48595
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48504: LD_ADDR_EXP 55
48508: PUSH
48509: LD_EXP 55
48513: PPUSH
48514: LD_VAR 0 4
48518: PPUSH
48519: LD_EXP 55
48523: PUSH
48524: LD_VAR 0 4
48528: ARRAY
48529: PPUSH
48530: LD_VAR 0 5
48534: PPUSH
48535: CALL_OW 3
48539: PPUSH
48540: CALL_OW 1
48544: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48545: LD_ADDR_EXP 57
48549: PUSH
48550: LD_EXP 57
48554: PPUSH
48555: LD_VAR 0 4
48559: PUSH
48560: LD_EXP 57
48564: PUSH
48565: LD_VAR 0 4
48569: ARRAY
48570: PUSH
48571: LD_INT 1
48573: PLUS
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: PPUSH
48579: LD_VAR 0 1
48583: PPUSH
48584: CALL 54011 0 3
48588: ST_TO_ADDR
// exit ;
48589: POP
48590: POP
48591: POP
48592: POP
48593: GO 48603
// end ;
48595: GO 48452
48597: POP
48598: POP
// end ;
48599: GO 48413
48601: POP
48602: POP
// end ;
48603: LD_VAR 0 3
48607: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
// if not mc_bases or not skirmish then
48613: LD_EXP 50
48617: NOT
48618: PUSH
48619: LD_EXP 48
48623: NOT
48624: OR
48625: IFFALSE 48629
// exit ;
48627: GO 48819
// for i = 1 to mc_bases do
48629: LD_ADDR_VAR 0 4
48633: PUSH
48634: DOUBLE
48635: LD_INT 1
48637: DEC
48638: ST_TO_ADDR
48639: LD_EXP 50
48643: PUSH
48644: FOR_TO
48645: IFFALSE 48732
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48647: LD_VAR 0 1
48651: PUSH
48652: LD_EXP 58
48656: PUSH
48657: LD_VAR 0 4
48661: ARRAY
48662: IN
48663: PUSH
48664: LD_VAR 0 1
48668: PUSH
48669: LD_EXP 59
48673: PUSH
48674: LD_VAR 0 4
48678: ARRAY
48679: IN
48680: NOT
48681: AND
48682: IFFALSE 48730
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48684: LD_ADDR_EXP 59
48688: PUSH
48689: LD_EXP 59
48693: PPUSH
48694: LD_VAR 0 4
48698: PUSH
48699: LD_EXP 59
48703: PUSH
48704: LD_VAR 0 4
48708: ARRAY
48709: PUSH
48710: LD_INT 1
48712: PLUS
48713: PUSH
48714: EMPTY
48715: LIST
48716: LIST
48717: PPUSH
48718: LD_VAR 0 1
48722: PPUSH
48723: CALL 54011 0 3
48727: ST_TO_ADDR
// break ;
48728: GO 48732
// end ; end ;
48730: GO 48644
48732: POP
48733: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48734: LD_VAR 0 1
48738: PPUSH
48739: CALL_OW 257
48743: PUSH
48744: LD_EXP 76
48748: IN
48749: PUSH
48750: LD_VAR 0 1
48754: PPUSH
48755: CALL_OW 266
48759: PUSH
48760: LD_INT 5
48762: EQUAL
48763: AND
48764: PUSH
48765: LD_VAR 0 2
48769: PPUSH
48770: CALL_OW 110
48774: PUSH
48775: LD_INT 18
48777: NONEQUAL
48778: AND
48779: IFFALSE 48819
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48781: LD_VAR 0 2
48785: PPUSH
48786: CALL_OW 257
48790: PUSH
48791: LD_INT 5
48793: PUSH
48794: LD_INT 8
48796: PUSH
48797: LD_INT 9
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: LIST
48804: IN
48805: IFFALSE 48819
// SetClass ( unit , 1 ) ;
48807: LD_VAR 0 2
48811: PPUSH
48812: LD_INT 1
48814: PPUSH
48815: CALL_OW 336
// end ;
48819: LD_VAR 0 3
48823: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48824: LD_INT 0
48826: PPUSH
48827: PPUSH
// if not mc_bases or not skirmish then
48828: LD_EXP 50
48832: NOT
48833: PUSH
48834: LD_EXP 48
48838: NOT
48839: OR
48840: IFFALSE 48844
// exit ;
48842: GO 48960
// if GetLives ( abandoned_vehicle ) > 250 then
48844: LD_VAR 0 2
48848: PPUSH
48849: CALL_OW 256
48853: PUSH
48854: LD_INT 250
48856: GREATER
48857: IFFALSE 48861
// exit ;
48859: GO 48960
// for i = 1 to mc_bases do
48861: LD_ADDR_VAR 0 6
48865: PUSH
48866: DOUBLE
48867: LD_INT 1
48869: DEC
48870: ST_TO_ADDR
48871: LD_EXP 50
48875: PUSH
48876: FOR_TO
48877: IFFALSE 48958
// begin if driver in mc_bases [ i ] then
48879: LD_VAR 0 1
48883: PUSH
48884: LD_EXP 50
48888: PUSH
48889: LD_VAR 0 6
48893: ARRAY
48894: IN
48895: IFFALSE 48956
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48897: LD_VAR 0 1
48901: PPUSH
48902: LD_EXP 50
48906: PUSH
48907: LD_VAR 0 6
48911: ARRAY
48912: PPUSH
48913: LD_INT 2
48915: PUSH
48916: LD_INT 30
48918: PUSH
48919: LD_INT 0
48921: PUSH
48922: EMPTY
48923: LIST
48924: LIST
48925: PUSH
48926: LD_INT 30
48928: PUSH
48929: LD_INT 1
48931: PUSH
48932: EMPTY
48933: LIST
48934: LIST
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: LIST
48940: PPUSH
48941: CALL_OW 72
48945: PUSH
48946: LD_INT 1
48948: ARRAY
48949: PPUSH
48950: CALL 87637 0 2
// break ;
48954: GO 48958
// end ; end ;
48956: GO 48876
48958: POP
48959: POP
// end ; end_of_file
48960: LD_VAR 0 5
48964: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48965: LD_INT 0
48967: PPUSH
48968: PPUSH
// if exist_mode then
48969: LD_VAR 0 2
48973: IFFALSE 49019
// begin unit := CreateCharacter ( prefix & ident ) ;
48975: LD_ADDR_VAR 0 5
48979: PUSH
48980: LD_VAR 0 3
48984: PUSH
48985: LD_VAR 0 1
48989: STR
48990: PPUSH
48991: CALL_OW 34
48995: ST_TO_ADDR
// if unit then
48996: LD_VAR 0 5
49000: IFFALSE 49017
// DeleteCharacters ( prefix & ident ) ;
49002: LD_VAR 0 3
49006: PUSH
49007: LD_VAR 0 1
49011: STR
49012: PPUSH
49013: CALL_OW 40
// end else
49017: GO 49034
// unit := NewCharacter ( ident ) ;
49019: LD_ADDR_VAR 0 5
49023: PUSH
49024: LD_VAR 0 1
49028: PPUSH
49029: CALL_OW 25
49033: ST_TO_ADDR
// result := unit ;
49034: LD_ADDR_VAR 0 4
49038: PUSH
49039: LD_VAR 0 5
49043: ST_TO_ADDR
// end ;
49044: LD_VAR 0 4
49048: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
49049: LD_INT 0
49051: PPUSH
49052: PPUSH
// if exist_mode then
49053: LD_VAR 0 2
49057: IFFALSE 49082
// unit := CreateCharacter ( prefix & ident ) else
49059: LD_ADDR_VAR 0 5
49063: PUSH
49064: LD_VAR 0 3
49068: PUSH
49069: LD_VAR 0 1
49073: STR
49074: PPUSH
49075: CALL_OW 34
49079: ST_TO_ADDR
49080: GO 49097
// unit := NewCharacter ( ident ) ;
49082: LD_ADDR_VAR 0 5
49086: PUSH
49087: LD_VAR 0 1
49091: PPUSH
49092: CALL_OW 25
49096: ST_TO_ADDR
// result := unit ;
49097: LD_ADDR_VAR 0 4
49101: PUSH
49102: LD_VAR 0 5
49106: ST_TO_ADDR
// end ;
49107: LD_VAR 0 4
49111: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49112: LD_INT 0
49114: PPUSH
49115: PPUSH
// if not side or not nation then
49116: LD_VAR 0 1
49120: NOT
49121: PUSH
49122: LD_VAR 0 2
49126: NOT
49127: OR
49128: IFFALSE 49132
// exit ;
49130: GO 49900
// case nation of nation_american :
49132: LD_VAR 0 2
49136: PUSH
49137: LD_INT 1
49139: DOUBLE
49140: EQUAL
49141: IFTRUE 49145
49143: GO 49359
49145: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49146: LD_ADDR_VAR 0 4
49150: PUSH
49151: LD_INT 35
49153: PUSH
49154: LD_INT 45
49156: PUSH
49157: LD_INT 46
49159: PUSH
49160: LD_INT 47
49162: PUSH
49163: LD_INT 82
49165: PUSH
49166: LD_INT 83
49168: PUSH
49169: LD_INT 84
49171: PUSH
49172: LD_INT 85
49174: PUSH
49175: LD_INT 86
49177: PUSH
49178: LD_INT 1
49180: PUSH
49181: LD_INT 2
49183: PUSH
49184: LD_INT 6
49186: PUSH
49187: LD_INT 15
49189: PUSH
49190: LD_INT 16
49192: PUSH
49193: LD_INT 7
49195: PUSH
49196: LD_INT 12
49198: PUSH
49199: LD_INT 13
49201: PUSH
49202: LD_INT 10
49204: PUSH
49205: LD_INT 14
49207: PUSH
49208: LD_INT 20
49210: PUSH
49211: LD_INT 21
49213: PUSH
49214: LD_INT 22
49216: PUSH
49217: LD_INT 25
49219: PUSH
49220: LD_INT 32
49222: PUSH
49223: LD_INT 27
49225: PUSH
49226: LD_INT 36
49228: PUSH
49229: LD_INT 69
49231: PUSH
49232: LD_INT 39
49234: PUSH
49235: LD_INT 34
49237: PUSH
49238: LD_INT 40
49240: PUSH
49241: LD_INT 48
49243: PUSH
49244: LD_INT 49
49246: PUSH
49247: LD_INT 50
49249: PUSH
49250: LD_INT 51
49252: PUSH
49253: LD_INT 52
49255: PUSH
49256: LD_INT 53
49258: PUSH
49259: LD_INT 54
49261: PUSH
49262: LD_INT 55
49264: PUSH
49265: LD_INT 56
49267: PUSH
49268: LD_INT 57
49270: PUSH
49271: LD_INT 58
49273: PUSH
49274: LD_INT 59
49276: PUSH
49277: LD_INT 60
49279: PUSH
49280: LD_INT 61
49282: PUSH
49283: LD_INT 62
49285: PUSH
49286: LD_INT 80
49288: PUSH
49289: LD_INT 82
49291: PUSH
49292: LD_INT 83
49294: PUSH
49295: LD_INT 84
49297: PUSH
49298: LD_INT 85
49300: PUSH
49301: LD_INT 86
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: ST_TO_ADDR
49357: GO 49824
49359: LD_INT 2
49361: DOUBLE
49362: EQUAL
49363: IFTRUE 49367
49365: GO 49593
49367: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49368: LD_ADDR_VAR 0 4
49372: PUSH
49373: LD_INT 35
49375: PUSH
49376: LD_INT 45
49378: PUSH
49379: LD_INT 46
49381: PUSH
49382: LD_INT 47
49384: PUSH
49385: LD_INT 82
49387: PUSH
49388: LD_INT 83
49390: PUSH
49391: LD_INT 84
49393: PUSH
49394: LD_INT 85
49396: PUSH
49397: LD_INT 87
49399: PUSH
49400: LD_INT 70
49402: PUSH
49403: LD_INT 1
49405: PUSH
49406: LD_INT 11
49408: PUSH
49409: LD_INT 3
49411: PUSH
49412: LD_INT 4
49414: PUSH
49415: LD_INT 5
49417: PUSH
49418: LD_INT 6
49420: PUSH
49421: LD_INT 15
49423: PUSH
49424: LD_INT 18
49426: PUSH
49427: LD_INT 7
49429: PUSH
49430: LD_INT 17
49432: PUSH
49433: LD_INT 8
49435: PUSH
49436: LD_INT 20
49438: PUSH
49439: LD_INT 21
49441: PUSH
49442: LD_INT 22
49444: PUSH
49445: LD_INT 72
49447: PUSH
49448: LD_INT 26
49450: PUSH
49451: LD_INT 69
49453: PUSH
49454: LD_INT 39
49456: PUSH
49457: LD_INT 40
49459: PUSH
49460: LD_INT 41
49462: PUSH
49463: LD_INT 42
49465: PUSH
49466: LD_INT 43
49468: PUSH
49469: LD_INT 48
49471: PUSH
49472: LD_INT 49
49474: PUSH
49475: LD_INT 50
49477: PUSH
49478: LD_INT 51
49480: PUSH
49481: LD_INT 52
49483: PUSH
49484: LD_INT 53
49486: PUSH
49487: LD_INT 54
49489: PUSH
49490: LD_INT 55
49492: PUSH
49493: LD_INT 56
49495: PUSH
49496: LD_INT 60
49498: PUSH
49499: LD_INT 61
49501: PUSH
49502: LD_INT 62
49504: PUSH
49505: LD_INT 66
49507: PUSH
49508: LD_INT 67
49510: PUSH
49511: LD_INT 68
49513: PUSH
49514: LD_INT 81
49516: PUSH
49517: LD_INT 82
49519: PUSH
49520: LD_INT 83
49522: PUSH
49523: LD_INT 84
49525: PUSH
49526: LD_INT 85
49528: PUSH
49529: LD_INT 87
49531: PUSH
49532: LD_INT 88
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: LIST
49539: LIST
49540: LIST
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: LIST
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: LIST
49555: LIST
49556: LIST
49557: LIST
49558: LIST
49559: LIST
49560: LIST
49561: LIST
49562: LIST
49563: LIST
49564: LIST
49565: LIST
49566: LIST
49567: LIST
49568: LIST
49569: LIST
49570: LIST
49571: LIST
49572: LIST
49573: LIST
49574: LIST
49575: LIST
49576: LIST
49577: LIST
49578: LIST
49579: LIST
49580: LIST
49581: LIST
49582: LIST
49583: LIST
49584: LIST
49585: LIST
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: ST_TO_ADDR
49591: GO 49824
49593: LD_INT 3
49595: DOUBLE
49596: EQUAL
49597: IFTRUE 49601
49599: GO 49823
49601: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49602: LD_ADDR_VAR 0 4
49606: PUSH
49607: LD_INT 46
49609: PUSH
49610: LD_INT 47
49612: PUSH
49613: LD_INT 1
49615: PUSH
49616: LD_INT 2
49618: PUSH
49619: LD_INT 82
49621: PUSH
49622: LD_INT 83
49624: PUSH
49625: LD_INT 84
49627: PUSH
49628: LD_INT 85
49630: PUSH
49631: LD_INT 86
49633: PUSH
49634: LD_INT 11
49636: PUSH
49637: LD_INT 9
49639: PUSH
49640: LD_INT 20
49642: PUSH
49643: LD_INT 19
49645: PUSH
49646: LD_INT 21
49648: PUSH
49649: LD_INT 24
49651: PUSH
49652: LD_INT 22
49654: PUSH
49655: LD_INT 25
49657: PUSH
49658: LD_INT 28
49660: PUSH
49661: LD_INT 29
49663: PUSH
49664: LD_INT 30
49666: PUSH
49667: LD_INT 31
49669: PUSH
49670: LD_INT 37
49672: PUSH
49673: LD_INT 38
49675: PUSH
49676: LD_INT 32
49678: PUSH
49679: LD_INT 27
49681: PUSH
49682: LD_INT 33
49684: PUSH
49685: LD_INT 69
49687: PUSH
49688: LD_INT 39
49690: PUSH
49691: LD_INT 34
49693: PUSH
49694: LD_INT 40
49696: PUSH
49697: LD_INT 71
49699: PUSH
49700: LD_INT 23
49702: PUSH
49703: LD_INT 44
49705: PUSH
49706: LD_INT 48
49708: PUSH
49709: LD_INT 49
49711: PUSH
49712: LD_INT 50
49714: PUSH
49715: LD_INT 51
49717: PUSH
49718: LD_INT 52
49720: PUSH
49721: LD_INT 53
49723: PUSH
49724: LD_INT 54
49726: PUSH
49727: LD_INT 55
49729: PUSH
49730: LD_INT 56
49732: PUSH
49733: LD_INT 57
49735: PUSH
49736: LD_INT 58
49738: PUSH
49739: LD_INT 59
49741: PUSH
49742: LD_INT 63
49744: PUSH
49745: LD_INT 64
49747: PUSH
49748: LD_INT 65
49750: PUSH
49751: LD_INT 82
49753: PUSH
49754: LD_INT 83
49756: PUSH
49757: LD_INT 84
49759: PUSH
49760: LD_INT 85
49762: PUSH
49763: LD_INT 86
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: ST_TO_ADDR
49821: GO 49824
49823: POP
// if state > - 1 and state < 3 then
49824: LD_VAR 0 3
49828: PUSH
49829: LD_INT 1
49831: NEG
49832: GREATER
49833: PUSH
49834: LD_VAR 0 3
49838: PUSH
49839: LD_INT 3
49841: LESS
49842: AND
49843: IFFALSE 49900
// for i in result do
49845: LD_ADDR_VAR 0 5
49849: PUSH
49850: LD_VAR 0 4
49854: PUSH
49855: FOR_IN
49856: IFFALSE 49898
// if GetTech ( i , side ) <> state then
49858: LD_VAR 0 5
49862: PPUSH
49863: LD_VAR 0 1
49867: PPUSH
49868: CALL_OW 321
49872: PUSH
49873: LD_VAR 0 3
49877: NONEQUAL
49878: IFFALSE 49896
// result := result diff i ;
49880: LD_ADDR_VAR 0 4
49884: PUSH
49885: LD_VAR 0 4
49889: PUSH
49890: LD_VAR 0 5
49894: DIFF
49895: ST_TO_ADDR
49896: GO 49855
49898: POP
49899: POP
// end ;
49900: LD_VAR 0 4
49904: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49905: LD_INT 0
49907: PPUSH
49908: PPUSH
49909: PPUSH
// result := true ;
49910: LD_ADDR_VAR 0 3
49914: PUSH
49915: LD_INT 1
49917: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49918: LD_ADDR_VAR 0 5
49922: PUSH
49923: LD_VAR 0 2
49927: PPUSH
49928: CALL_OW 480
49932: ST_TO_ADDR
// if not tmp then
49933: LD_VAR 0 5
49937: NOT
49938: IFFALSE 49942
// exit ;
49940: GO 49991
// for i in tmp do
49942: LD_ADDR_VAR 0 4
49946: PUSH
49947: LD_VAR 0 5
49951: PUSH
49952: FOR_IN
49953: IFFALSE 49989
// if GetTech ( i , side ) <> state_researched then
49955: LD_VAR 0 4
49959: PPUSH
49960: LD_VAR 0 1
49964: PPUSH
49965: CALL_OW 321
49969: PUSH
49970: LD_INT 2
49972: NONEQUAL
49973: IFFALSE 49987
// begin result := false ;
49975: LD_ADDR_VAR 0 3
49979: PUSH
49980: LD_INT 0
49982: ST_TO_ADDR
// exit ;
49983: POP
49984: POP
49985: GO 49991
// end ;
49987: GO 49952
49989: POP
49990: POP
// end ;
49991: LD_VAR 0 3
49995: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49996: LD_INT 0
49998: PPUSH
49999: PPUSH
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50011: LD_VAR 0 1
50015: NOT
50016: PUSH
50017: LD_VAR 0 1
50021: PPUSH
50022: CALL_OW 257
50026: PUSH
50027: LD_INT 9
50029: NONEQUAL
50030: OR
50031: IFFALSE 50035
// exit ;
50033: GO 50608
// side := GetSide ( unit ) ;
50035: LD_ADDR_VAR 0 9
50039: PUSH
50040: LD_VAR 0 1
50044: PPUSH
50045: CALL_OW 255
50049: ST_TO_ADDR
// tech_space := tech_spacanom ;
50050: LD_ADDR_VAR 0 12
50054: PUSH
50055: LD_INT 29
50057: ST_TO_ADDR
// tech_time := tech_taurad ;
50058: LD_ADDR_VAR 0 13
50062: PUSH
50063: LD_INT 28
50065: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50066: LD_ADDR_VAR 0 11
50070: PUSH
50071: LD_VAR 0 1
50075: PPUSH
50076: CALL_OW 310
50080: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50081: LD_VAR 0 11
50085: PPUSH
50086: CALL_OW 247
50090: PUSH
50091: LD_INT 2
50093: EQUAL
50094: IFFALSE 50098
// exit ;
50096: GO 50608
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50098: LD_ADDR_VAR 0 8
50102: PUSH
50103: LD_INT 81
50105: PUSH
50106: LD_VAR 0 9
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 3
50117: PUSH
50118: LD_INT 21
50120: PUSH
50121: LD_INT 3
50123: PUSH
50124: EMPTY
50125: LIST
50126: LIST
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: PUSH
50132: EMPTY
50133: LIST
50134: LIST
50135: PPUSH
50136: CALL_OW 69
50140: ST_TO_ADDR
// if not tmp then
50141: LD_VAR 0 8
50145: NOT
50146: IFFALSE 50150
// exit ;
50148: GO 50608
// if in_unit then
50150: LD_VAR 0 11
50154: IFFALSE 50178
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50156: LD_ADDR_VAR 0 10
50160: PUSH
50161: LD_VAR 0 8
50165: PPUSH
50166: LD_VAR 0 11
50170: PPUSH
50171: CALL_OW 74
50175: ST_TO_ADDR
50176: GO 50198
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50178: LD_ADDR_VAR 0 10
50182: PUSH
50183: LD_VAR 0 8
50187: PPUSH
50188: LD_VAR 0 1
50192: PPUSH
50193: CALL_OW 74
50197: ST_TO_ADDR
// if not enemy then
50198: LD_VAR 0 10
50202: NOT
50203: IFFALSE 50207
// exit ;
50205: GO 50608
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50207: LD_VAR 0 11
50211: PUSH
50212: LD_VAR 0 11
50216: PPUSH
50217: LD_VAR 0 10
50221: PPUSH
50222: CALL_OW 296
50226: PUSH
50227: LD_INT 13
50229: GREATER
50230: AND
50231: PUSH
50232: LD_VAR 0 1
50236: PPUSH
50237: LD_VAR 0 10
50241: PPUSH
50242: CALL_OW 296
50246: PUSH
50247: LD_INT 12
50249: GREATER
50250: OR
50251: IFFALSE 50255
// exit ;
50253: GO 50608
// missile := [ 1 ] ;
50255: LD_ADDR_VAR 0 14
50259: PUSH
50260: LD_INT 1
50262: PUSH
50263: EMPTY
50264: LIST
50265: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50266: LD_VAR 0 9
50270: PPUSH
50271: LD_VAR 0 12
50275: PPUSH
50276: CALL_OW 325
50280: IFFALSE 50309
// missile := Replace ( missile , missile + 1 , 2 ) ;
50282: LD_ADDR_VAR 0 14
50286: PUSH
50287: LD_VAR 0 14
50291: PPUSH
50292: LD_VAR 0 14
50296: PUSH
50297: LD_INT 1
50299: PLUS
50300: PPUSH
50301: LD_INT 2
50303: PPUSH
50304: CALL_OW 1
50308: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50309: LD_VAR 0 9
50313: PPUSH
50314: LD_VAR 0 13
50318: PPUSH
50319: CALL_OW 325
50323: PUSH
50324: LD_VAR 0 10
50328: PPUSH
50329: CALL_OW 255
50333: PPUSH
50334: LD_VAR 0 13
50338: PPUSH
50339: CALL_OW 325
50343: NOT
50344: AND
50345: IFFALSE 50374
// missile := Replace ( missile , missile + 1 , 3 ) ;
50347: LD_ADDR_VAR 0 14
50351: PUSH
50352: LD_VAR 0 14
50356: PPUSH
50357: LD_VAR 0 14
50361: PUSH
50362: LD_INT 1
50364: PLUS
50365: PPUSH
50366: LD_INT 3
50368: PPUSH
50369: CALL_OW 1
50373: ST_TO_ADDR
// if missile < 2 then
50374: LD_VAR 0 14
50378: PUSH
50379: LD_INT 2
50381: LESS
50382: IFFALSE 50386
// exit ;
50384: GO 50608
// x := GetX ( enemy ) ;
50386: LD_ADDR_VAR 0 4
50390: PUSH
50391: LD_VAR 0 10
50395: PPUSH
50396: CALL_OW 250
50400: ST_TO_ADDR
// y := GetY ( enemy ) ;
50401: LD_ADDR_VAR 0 5
50405: PUSH
50406: LD_VAR 0 10
50410: PPUSH
50411: CALL_OW 251
50415: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50416: LD_ADDR_VAR 0 6
50420: PUSH
50421: LD_VAR 0 4
50425: PUSH
50426: LD_INT 1
50428: NEG
50429: PPUSH
50430: LD_INT 1
50432: PPUSH
50433: CALL_OW 12
50437: PLUS
50438: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50439: LD_ADDR_VAR 0 7
50443: PUSH
50444: LD_VAR 0 5
50448: PUSH
50449: LD_INT 1
50451: NEG
50452: PPUSH
50453: LD_INT 1
50455: PPUSH
50456: CALL_OW 12
50460: PLUS
50461: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50462: LD_VAR 0 6
50466: PPUSH
50467: LD_VAR 0 7
50471: PPUSH
50472: CALL_OW 488
50476: NOT
50477: IFFALSE 50499
// begin _x := x ;
50479: LD_ADDR_VAR 0 6
50483: PUSH
50484: LD_VAR 0 4
50488: ST_TO_ADDR
// _y := y ;
50489: LD_ADDR_VAR 0 7
50493: PUSH
50494: LD_VAR 0 5
50498: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50499: LD_ADDR_VAR 0 3
50503: PUSH
50504: LD_INT 1
50506: PPUSH
50507: LD_VAR 0 14
50511: PPUSH
50512: CALL_OW 12
50516: ST_TO_ADDR
// case i of 1 :
50517: LD_VAR 0 3
50521: PUSH
50522: LD_INT 1
50524: DOUBLE
50525: EQUAL
50526: IFTRUE 50530
50528: GO 50547
50530: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50531: LD_VAR 0 1
50535: PPUSH
50536: LD_VAR 0 10
50540: PPUSH
50541: CALL_OW 115
50545: GO 50608
50547: LD_INT 2
50549: DOUBLE
50550: EQUAL
50551: IFTRUE 50555
50553: GO 50577
50555: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50556: LD_VAR 0 1
50560: PPUSH
50561: LD_VAR 0 6
50565: PPUSH
50566: LD_VAR 0 7
50570: PPUSH
50571: CALL_OW 153
50575: GO 50608
50577: LD_INT 3
50579: DOUBLE
50580: EQUAL
50581: IFTRUE 50585
50583: GO 50607
50585: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50586: LD_VAR 0 1
50590: PPUSH
50591: LD_VAR 0 6
50595: PPUSH
50596: LD_VAR 0 7
50600: PPUSH
50601: CALL_OW 154
50605: GO 50608
50607: POP
// end ;
50608: LD_VAR 0 2
50612: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50613: LD_INT 0
50615: PPUSH
50616: PPUSH
50617: PPUSH
50618: PPUSH
50619: PPUSH
50620: PPUSH
// if not unit or not building then
50621: LD_VAR 0 1
50625: NOT
50626: PUSH
50627: LD_VAR 0 2
50631: NOT
50632: OR
50633: IFFALSE 50637
// exit ;
50635: GO 50795
// x := GetX ( building ) ;
50637: LD_ADDR_VAR 0 5
50641: PUSH
50642: LD_VAR 0 2
50646: PPUSH
50647: CALL_OW 250
50651: ST_TO_ADDR
// y := GetY ( building ) ;
50652: LD_ADDR_VAR 0 6
50656: PUSH
50657: LD_VAR 0 2
50661: PPUSH
50662: CALL_OW 251
50666: ST_TO_ADDR
// for i = 0 to 5 do
50667: LD_ADDR_VAR 0 4
50671: PUSH
50672: DOUBLE
50673: LD_INT 0
50675: DEC
50676: ST_TO_ADDR
50677: LD_INT 5
50679: PUSH
50680: FOR_TO
50681: IFFALSE 50793
// begin _x := ShiftX ( x , i , 3 ) ;
50683: LD_ADDR_VAR 0 7
50687: PUSH
50688: LD_VAR 0 5
50692: PPUSH
50693: LD_VAR 0 4
50697: PPUSH
50698: LD_INT 3
50700: PPUSH
50701: CALL_OW 272
50705: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50706: LD_ADDR_VAR 0 8
50710: PUSH
50711: LD_VAR 0 6
50715: PPUSH
50716: LD_VAR 0 4
50720: PPUSH
50721: LD_INT 3
50723: PPUSH
50724: CALL_OW 273
50728: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50729: LD_VAR 0 7
50733: PPUSH
50734: LD_VAR 0 8
50738: PPUSH
50739: CALL_OW 488
50743: NOT
50744: IFFALSE 50748
// continue ;
50746: GO 50680
// if HexInfo ( _x , _y ) = 0 then
50748: LD_VAR 0 7
50752: PPUSH
50753: LD_VAR 0 8
50757: PPUSH
50758: CALL_OW 428
50762: PUSH
50763: LD_INT 0
50765: EQUAL
50766: IFFALSE 50791
// begin ComMoveXY ( unit , _x , _y ) ;
50768: LD_VAR 0 1
50772: PPUSH
50773: LD_VAR 0 7
50777: PPUSH
50778: LD_VAR 0 8
50782: PPUSH
50783: CALL_OW 111
// exit ;
50787: POP
50788: POP
50789: GO 50795
// end ; end ;
50791: GO 50680
50793: POP
50794: POP
// end ;
50795: LD_VAR 0 3
50799: RET
// export function ScanBase ( side , base_area ) ; begin
50800: LD_INT 0
50802: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50803: LD_ADDR_VAR 0 3
50807: PUSH
50808: LD_VAR 0 2
50812: PPUSH
50813: LD_INT 81
50815: PUSH
50816: LD_VAR 0 1
50820: PUSH
50821: EMPTY
50822: LIST
50823: LIST
50824: PPUSH
50825: CALL_OW 70
50829: ST_TO_ADDR
// end ;
50830: LD_VAR 0 3
50834: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50835: LD_INT 0
50837: PPUSH
50838: PPUSH
50839: PPUSH
50840: PPUSH
// result := false ;
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: LD_INT 0
50848: ST_TO_ADDR
// side := GetSide ( unit ) ;
50849: LD_ADDR_VAR 0 3
50853: PUSH
50854: LD_VAR 0 1
50858: PPUSH
50859: CALL_OW 255
50863: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50864: LD_ADDR_VAR 0 4
50868: PUSH
50869: LD_VAR 0 1
50873: PPUSH
50874: CALL_OW 248
50878: ST_TO_ADDR
// case nat of 1 :
50879: LD_VAR 0 4
50883: PUSH
50884: LD_INT 1
50886: DOUBLE
50887: EQUAL
50888: IFTRUE 50892
50890: GO 50903
50892: POP
// tech := tech_lassight ; 2 :
50893: LD_ADDR_VAR 0 5
50897: PUSH
50898: LD_INT 12
50900: ST_TO_ADDR
50901: GO 50942
50903: LD_INT 2
50905: DOUBLE
50906: EQUAL
50907: IFTRUE 50911
50909: GO 50922
50911: POP
// tech := tech_mortar ; 3 :
50912: LD_ADDR_VAR 0 5
50916: PUSH
50917: LD_INT 41
50919: ST_TO_ADDR
50920: GO 50942
50922: LD_INT 3
50924: DOUBLE
50925: EQUAL
50926: IFTRUE 50930
50928: GO 50941
50930: POP
// tech := tech_bazooka ; end ;
50931: LD_ADDR_VAR 0 5
50935: PUSH
50936: LD_INT 44
50938: ST_TO_ADDR
50939: GO 50942
50941: POP
// if Researched ( side , tech ) then
50942: LD_VAR 0 3
50946: PPUSH
50947: LD_VAR 0 5
50951: PPUSH
50952: CALL_OW 325
50956: IFFALSE 50983
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50958: LD_ADDR_VAR 0 2
50962: PUSH
50963: LD_INT 5
50965: PUSH
50966: LD_INT 8
50968: PUSH
50969: LD_INT 9
50971: PUSH
50972: EMPTY
50973: LIST
50974: LIST
50975: LIST
50976: PUSH
50977: LD_VAR 0 4
50981: ARRAY
50982: ST_TO_ADDR
// end ;
50983: LD_VAR 0 2
50987: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50988: LD_INT 0
50990: PPUSH
50991: PPUSH
50992: PPUSH
// if not mines then
50993: LD_VAR 0 2
50997: NOT
50998: IFFALSE 51002
// exit ;
51000: GO 51146
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51002: LD_ADDR_VAR 0 5
51006: PUSH
51007: LD_INT 81
51009: PUSH
51010: LD_VAR 0 1
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PUSH
51019: LD_INT 3
51021: PUSH
51022: LD_INT 21
51024: PUSH
51025: LD_INT 3
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PPUSH
51040: CALL_OW 69
51044: ST_TO_ADDR
// for i in mines do
51045: LD_ADDR_VAR 0 4
51049: PUSH
51050: LD_VAR 0 2
51054: PUSH
51055: FOR_IN
51056: IFFALSE 51144
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51058: LD_VAR 0 4
51062: PUSH
51063: LD_INT 1
51065: ARRAY
51066: PPUSH
51067: LD_VAR 0 4
51071: PUSH
51072: LD_INT 2
51074: ARRAY
51075: PPUSH
51076: CALL_OW 458
51080: NOT
51081: IFFALSE 51085
// continue ;
51083: GO 51055
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51085: LD_VAR 0 4
51089: PUSH
51090: LD_INT 1
51092: ARRAY
51093: PPUSH
51094: LD_VAR 0 4
51098: PUSH
51099: LD_INT 2
51101: ARRAY
51102: PPUSH
51103: CALL_OW 428
51107: PUSH
51108: LD_VAR 0 5
51112: IN
51113: IFFALSE 51142
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51115: LD_VAR 0 4
51119: PUSH
51120: LD_INT 1
51122: ARRAY
51123: PPUSH
51124: LD_VAR 0 4
51128: PUSH
51129: LD_INT 2
51131: ARRAY
51132: PPUSH
51133: LD_VAR 0 1
51137: PPUSH
51138: CALL_OW 456
// end ;
51142: GO 51055
51144: POP
51145: POP
// end ;
51146: LD_VAR 0 3
51150: RET
// export function Count ( array ) ; begin
51151: LD_INT 0
51153: PPUSH
// result := array + 0 ;
51154: LD_ADDR_VAR 0 2
51158: PUSH
51159: LD_VAR 0 1
51163: PUSH
51164: LD_INT 0
51166: PLUS
51167: ST_TO_ADDR
// end ;
51168: LD_VAR 0 2
51172: RET
// export function IsEmpty ( building ) ; begin
51173: LD_INT 0
51175: PPUSH
// if not building then
51176: LD_VAR 0 1
51180: NOT
51181: IFFALSE 51185
// exit ;
51183: GO 51228
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51185: LD_ADDR_VAR 0 2
51189: PUSH
51190: LD_VAR 0 1
51194: PUSH
51195: LD_INT 22
51197: PUSH
51198: LD_VAR 0 1
51202: PPUSH
51203: CALL_OW 255
51207: PUSH
51208: EMPTY
51209: LIST
51210: LIST
51211: PUSH
51212: LD_INT 58
51214: PUSH
51215: EMPTY
51216: LIST
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PPUSH
51222: CALL_OW 69
51226: IN
51227: ST_TO_ADDR
// end ;
51228: LD_VAR 0 2
51232: RET
// export function IsNotFull ( building ) ; var places ; begin
51233: LD_INT 0
51235: PPUSH
51236: PPUSH
// if not building then
51237: LD_VAR 0 1
51241: NOT
51242: IFFALSE 51246
// exit ;
51244: GO 51274
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51246: LD_ADDR_VAR 0 2
51250: PUSH
51251: LD_VAR 0 1
51255: PPUSH
51256: LD_INT 3
51258: PUSH
51259: LD_INT 62
51261: PUSH
51262: EMPTY
51263: LIST
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: PPUSH
51269: CALL_OW 72
51273: ST_TO_ADDR
// end ;
51274: LD_VAR 0 2
51278: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51279: LD_INT 0
51281: PPUSH
51282: PPUSH
51283: PPUSH
51284: PPUSH
// tmp := [ ] ;
51285: LD_ADDR_VAR 0 3
51289: PUSH
51290: EMPTY
51291: ST_TO_ADDR
// list := [ ] ;
51292: LD_ADDR_VAR 0 5
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// for i = 16 to 25 do
51299: LD_ADDR_VAR 0 4
51303: PUSH
51304: DOUBLE
51305: LD_INT 16
51307: DEC
51308: ST_TO_ADDR
51309: LD_INT 25
51311: PUSH
51312: FOR_TO
51313: IFFALSE 51386
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51315: LD_ADDR_VAR 0 3
51319: PUSH
51320: LD_VAR 0 3
51324: PUSH
51325: LD_INT 22
51327: PUSH
51328: LD_VAR 0 1
51332: PPUSH
51333: CALL_OW 255
51337: PUSH
51338: EMPTY
51339: LIST
51340: LIST
51341: PUSH
51342: LD_INT 91
51344: PUSH
51345: LD_VAR 0 1
51349: PUSH
51350: LD_INT 6
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: LIST
51357: PUSH
51358: LD_INT 30
51360: PUSH
51361: LD_VAR 0 4
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: EMPTY
51371: LIST
51372: LIST
51373: LIST
51374: PUSH
51375: EMPTY
51376: LIST
51377: PPUSH
51378: CALL_OW 69
51382: ADD
51383: ST_TO_ADDR
51384: GO 51312
51386: POP
51387: POP
// for i = 1 to tmp do
51388: LD_ADDR_VAR 0 4
51392: PUSH
51393: DOUBLE
51394: LD_INT 1
51396: DEC
51397: ST_TO_ADDR
51398: LD_VAR 0 3
51402: PUSH
51403: FOR_TO
51404: IFFALSE 51492
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51406: LD_ADDR_VAR 0 5
51410: PUSH
51411: LD_VAR 0 5
51415: PUSH
51416: LD_VAR 0 3
51420: PUSH
51421: LD_VAR 0 4
51425: ARRAY
51426: PPUSH
51427: CALL_OW 266
51431: PUSH
51432: LD_VAR 0 3
51436: PUSH
51437: LD_VAR 0 4
51441: ARRAY
51442: PPUSH
51443: CALL_OW 250
51447: PUSH
51448: LD_VAR 0 3
51452: PUSH
51453: LD_VAR 0 4
51457: ARRAY
51458: PPUSH
51459: CALL_OW 251
51463: PUSH
51464: LD_VAR 0 3
51468: PUSH
51469: LD_VAR 0 4
51473: ARRAY
51474: PPUSH
51475: CALL_OW 254
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: PUSH
51486: EMPTY
51487: LIST
51488: ADD
51489: ST_TO_ADDR
51490: GO 51403
51492: POP
51493: POP
// result := list ;
51494: LD_ADDR_VAR 0 2
51498: PUSH
51499: LD_VAR 0 5
51503: ST_TO_ADDR
// end ;
51504: LD_VAR 0 2
51508: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51509: LD_INT 0
51511: PPUSH
51512: PPUSH
51513: PPUSH
51514: PPUSH
51515: PPUSH
51516: PPUSH
51517: PPUSH
// if not factory then
51518: LD_VAR 0 1
51522: NOT
51523: IFFALSE 51527
// exit ;
51525: GO 52120
// if control = control_apeman then
51527: LD_VAR 0 4
51531: PUSH
51532: LD_INT 5
51534: EQUAL
51535: IFFALSE 51644
// begin tmp := UnitsInside ( factory ) ;
51537: LD_ADDR_VAR 0 8
51541: PUSH
51542: LD_VAR 0 1
51546: PPUSH
51547: CALL_OW 313
51551: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51552: LD_VAR 0 8
51556: PPUSH
51557: LD_INT 25
51559: PUSH
51560: LD_INT 12
51562: PUSH
51563: EMPTY
51564: LIST
51565: LIST
51566: PPUSH
51567: CALL_OW 72
51571: NOT
51572: IFFALSE 51582
// control := control_manual ;
51574: LD_ADDR_VAR 0 4
51578: PUSH
51579: LD_INT 1
51581: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51582: LD_ADDR_VAR 0 8
51586: PUSH
51587: LD_VAR 0 1
51591: PPUSH
51592: CALL 51279 0 1
51596: ST_TO_ADDR
// if tmp then
51597: LD_VAR 0 8
51601: IFFALSE 51644
// begin for i in tmp do
51603: LD_ADDR_VAR 0 7
51607: PUSH
51608: LD_VAR 0 8
51612: PUSH
51613: FOR_IN
51614: IFFALSE 51642
// if i [ 1 ] = b_ext_radio then
51616: LD_VAR 0 7
51620: PUSH
51621: LD_INT 1
51623: ARRAY
51624: PUSH
51625: LD_INT 22
51627: EQUAL
51628: IFFALSE 51640
// begin control := control_remote ;
51630: LD_ADDR_VAR 0 4
51634: PUSH
51635: LD_INT 2
51637: ST_TO_ADDR
// break ;
51638: GO 51642
// end ;
51640: GO 51613
51642: POP
51643: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51644: LD_VAR 0 1
51648: PPUSH
51649: LD_VAR 0 2
51653: PPUSH
51654: LD_VAR 0 3
51658: PPUSH
51659: LD_VAR 0 4
51663: PPUSH
51664: LD_VAR 0 5
51668: PPUSH
51669: CALL_OW 448
51673: IFFALSE 51708
// begin result := [ chassis , engine , control , weapon ] ;
51675: LD_ADDR_VAR 0 6
51679: PUSH
51680: LD_VAR 0 2
51684: PUSH
51685: LD_VAR 0 3
51689: PUSH
51690: LD_VAR 0 4
51694: PUSH
51695: LD_VAR 0 5
51699: PUSH
51700: EMPTY
51701: LIST
51702: LIST
51703: LIST
51704: LIST
51705: ST_TO_ADDR
// exit ;
51706: GO 52120
// end ; _chassis := AvailableChassisList ( factory ) ;
51708: LD_ADDR_VAR 0 9
51712: PUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: CALL_OW 475
51722: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51723: LD_ADDR_VAR 0 11
51727: PUSH
51728: LD_VAR 0 1
51732: PPUSH
51733: CALL_OW 476
51737: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51738: LD_ADDR_VAR 0 12
51742: PUSH
51743: LD_VAR 0 1
51747: PPUSH
51748: CALL_OW 477
51752: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51753: LD_ADDR_VAR 0 10
51757: PUSH
51758: LD_VAR 0 1
51762: PPUSH
51763: CALL_OW 478
51767: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51768: LD_VAR 0 9
51772: NOT
51773: PUSH
51774: LD_VAR 0 11
51778: NOT
51779: OR
51780: PUSH
51781: LD_VAR 0 12
51785: NOT
51786: OR
51787: PUSH
51788: LD_VAR 0 10
51792: NOT
51793: OR
51794: IFFALSE 51829
// begin result := [ chassis , engine , control , weapon ] ;
51796: LD_ADDR_VAR 0 6
51800: PUSH
51801: LD_VAR 0 2
51805: PUSH
51806: LD_VAR 0 3
51810: PUSH
51811: LD_VAR 0 4
51815: PUSH
51816: LD_VAR 0 5
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: LIST
51825: LIST
51826: ST_TO_ADDR
// exit ;
51827: GO 52120
// end ; if not chassis in _chassis then
51829: LD_VAR 0 2
51833: PUSH
51834: LD_VAR 0 9
51838: IN
51839: NOT
51840: IFFALSE 51866
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51842: LD_ADDR_VAR 0 2
51846: PUSH
51847: LD_VAR 0 9
51851: PUSH
51852: LD_INT 1
51854: PPUSH
51855: LD_VAR 0 9
51859: PPUSH
51860: CALL_OW 12
51864: ARRAY
51865: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51866: LD_VAR 0 2
51870: PPUSH
51871: LD_VAR 0 3
51875: PPUSH
51876: CALL 52125 0 2
51880: NOT
51881: IFFALSE 51940
// repeat engine := _engine [ 1 ] ;
51883: LD_ADDR_VAR 0 3
51887: PUSH
51888: LD_VAR 0 11
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51897: LD_ADDR_VAR 0 11
51901: PUSH
51902: LD_VAR 0 11
51906: PPUSH
51907: LD_INT 1
51909: PPUSH
51910: CALL_OW 3
51914: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51915: LD_VAR 0 2
51919: PPUSH
51920: LD_VAR 0 3
51924: PPUSH
51925: CALL 52125 0 2
51929: PUSH
51930: LD_VAR 0 11
51934: PUSH
51935: EMPTY
51936: EQUAL
51937: OR
51938: IFFALSE 51883
// if not control in _control then
51940: LD_VAR 0 4
51944: PUSH
51945: LD_VAR 0 12
51949: IN
51950: NOT
51951: IFFALSE 51977
// control := _control [ rand ( 1 , _control ) ] ;
51953: LD_ADDR_VAR 0 4
51957: PUSH
51958: LD_VAR 0 12
51962: PUSH
51963: LD_INT 1
51965: PPUSH
51966: LD_VAR 0 12
51970: PPUSH
51971: CALL_OW 12
51975: ARRAY
51976: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51977: LD_VAR 0 2
51981: PPUSH
51982: LD_VAR 0 5
51986: PPUSH
51987: CALL 52345 0 2
51991: NOT
51992: IFFALSE 52051
// repeat weapon := _weapon [ 1 ] ;
51994: LD_ADDR_VAR 0 5
51998: PUSH
51999: LD_VAR 0 10
52003: PUSH
52004: LD_INT 1
52006: ARRAY
52007: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52008: LD_ADDR_VAR 0 10
52012: PUSH
52013: LD_VAR 0 10
52017: PPUSH
52018: LD_INT 1
52020: PPUSH
52021: CALL_OW 3
52025: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52026: LD_VAR 0 2
52030: PPUSH
52031: LD_VAR 0 5
52035: PPUSH
52036: CALL 52345 0 2
52040: PUSH
52041: LD_VAR 0 10
52045: PUSH
52046: EMPTY
52047: EQUAL
52048: OR
52049: IFFALSE 51994
// result := [ ] ;
52051: LD_ADDR_VAR 0 6
52055: PUSH
52056: EMPTY
52057: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52058: LD_VAR 0 1
52062: PPUSH
52063: LD_VAR 0 2
52067: PPUSH
52068: LD_VAR 0 3
52072: PPUSH
52073: LD_VAR 0 4
52077: PPUSH
52078: LD_VAR 0 5
52082: PPUSH
52083: CALL_OW 448
52087: IFFALSE 52120
// result := [ chassis , engine , control , weapon ] ;
52089: LD_ADDR_VAR 0 6
52093: PUSH
52094: LD_VAR 0 2
52098: PUSH
52099: LD_VAR 0 3
52103: PUSH
52104: LD_VAR 0 4
52108: PUSH
52109: LD_VAR 0 5
52113: PUSH
52114: EMPTY
52115: LIST
52116: LIST
52117: LIST
52118: LIST
52119: ST_TO_ADDR
// end ;
52120: LD_VAR 0 6
52124: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52125: LD_INT 0
52127: PPUSH
// if not chassis or not engine then
52128: LD_VAR 0 1
52132: NOT
52133: PUSH
52134: LD_VAR 0 2
52138: NOT
52139: OR
52140: IFFALSE 52144
// exit ;
52142: GO 52340
// case engine of engine_solar :
52144: LD_VAR 0 2
52148: PUSH
52149: LD_INT 2
52151: DOUBLE
52152: EQUAL
52153: IFTRUE 52157
52155: GO 52195
52157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52158: LD_ADDR_VAR 0 3
52162: PUSH
52163: LD_INT 11
52165: PUSH
52166: LD_INT 12
52168: PUSH
52169: LD_INT 13
52171: PUSH
52172: LD_INT 14
52174: PUSH
52175: LD_INT 1
52177: PUSH
52178: LD_INT 2
52180: PUSH
52181: LD_INT 3
52183: PUSH
52184: EMPTY
52185: LIST
52186: LIST
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: LIST
52192: ST_TO_ADDR
52193: GO 52324
52195: LD_INT 1
52197: DOUBLE
52198: EQUAL
52199: IFTRUE 52203
52201: GO 52265
52203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52204: LD_ADDR_VAR 0 3
52208: PUSH
52209: LD_INT 11
52211: PUSH
52212: LD_INT 12
52214: PUSH
52215: LD_INT 13
52217: PUSH
52218: LD_INT 14
52220: PUSH
52221: LD_INT 1
52223: PUSH
52224: LD_INT 2
52226: PUSH
52227: LD_INT 3
52229: PUSH
52230: LD_INT 4
52232: PUSH
52233: LD_INT 5
52235: PUSH
52236: LD_INT 21
52238: PUSH
52239: LD_INT 23
52241: PUSH
52242: LD_INT 22
52244: PUSH
52245: LD_INT 24
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: ST_TO_ADDR
52263: GO 52324
52265: LD_INT 3
52267: DOUBLE
52268: EQUAL
52269: IFTRUE 52273
52271: GO 52323
52273: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52274: LD_ADDR_VAR 0 3
52278: PUSH
52279: LD_INT 13
52281: PUSH
52282: LD_INT 14
52284: PUSH
52285: LD_INT 2
52287: PUSH
52288: LD_INT 3
52290: PUSH
52291: LD_INT 4
52293: PUSH
52294: LD_INT 5
52296: PUSH
52297: LD_INT 21
52299: PUSH
52300: LD_INT 22
52302: PUSH
52303: LD_INT 23
52305: PUSH
52306: LD_INT 24
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: ST_TO_ADDR
52321: GO 52324
52323: POP
// result := ( chassis in result ) ;
52324: LD_ADDR_VAR 0 3
52328: PUSH
52329: LD_VAR 0 1
52333: PUSH
52334: LD_VAR 0 3
52338: IN
52339: ST_TO_ADDR
// end ;
52340: LD_VAR 0 3
52344: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52345: LD_INT 0
52347: PPUSH
// if not chassis or not weapon then
52348: LD_VAR 0 1
52352: NOT
52353: PUSH
52354: LD_VAR 0 2
52358: NOT
52359: OR
52360: IFFALSE 52364
// exit ;
52362: GO 53424
// case weapon of us_machine_gun :
52364: LD_VAR 0 2
52368: PUSH
52369: LD_INT 2
52371: DOUBLE
52372: EQUAL
52373: IFTRUE 52377
52375: GO 52407
52377: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52378: LD_ADDR_VAR 0 3
52382: PUSH
52383: LD_INT 1
52385: PUSH
52386: LD_INT 2
52388: PUSH
52389: LD_INT 3
52391: PUSH
52392: LD_INT 4
52394: PUSH
52395: LD_INT 5
52397: PUSH
52398: EMPTY
52399: LIST
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: ST_TO_ADDR
52405: GO 53408
52407: LD_INT 3
52409: DOUBLE
52410: EQUAL
52411: IFTRUE 52415
52413: GO 52445
52415: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52416: LD_ADDR_VAR 0 3
52420: PUSH
52421: LD_INT 1
52423: PUSH
52424: LD_INT 2
52426: PUSH
52427: LD_INT 3
52429: PUSH
52430: LD_INT 4
52432: PUSH
52433: LD_INT 5
52435: PUSH
52436: EMPTY
52437: LIST
52438: LIST
52439: LIST
52440: LIST
52441: LIST
52442: ST_TO_ADDR
52443: GO 53408
52445: LD_INT 11
52447: DOUBLE
52448: EQUAL
52449: IFTRUE 52453
52451: GO 52483
52453: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52454: LD_ADDR_VAR 0 3
52458: PUSH
52459: LD_INT 1
52461: PUSH
52462: LD_INT 2
52464: PUSH
52465: LD_INT 3
52467: PUSH
52468: LD_INT 4
52470: PUSH
52471: LD_INT 5
52473: PUSH
52474: EMPTY
52475: LIST
52476: LIST
52477: LIST
52478: LIST
52479: LIST
52480: ST_TO_ADDR
52481: GO 53408
52483: LD_INT 4
52485: DOUBLE
52486: EQUAL
52487: IFTRUE 52491
52489: GO 52517
52491: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52492: LD_ADDR_VAR 0 3
52496: PUSH
52497: LD_INT 2
52499: PUSH
52500: LD_INT 3
52502: PUSH
52503: LD_INT 4
52505: PUSH
52506: LD_INT 5
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: ST_TO_ADDR
52515: GO 53408
52517: LD_INT 5
52519: DOUBLE
52520: EQUAL
52521: IFTRUE 52525
52523: GO 52551
52525: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52526: LD_ADDR_VAR 0 3
52530: PUSH
52531: LD_INT 2
52533: PUSH
52534: LD_INT 3
52536: PUSH
52537: LD_INT 4
52539: PUSH
52540: LD_INT 5
52542: PUSH
52543: EMPTY
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: ST_TO_ADDR
52549: GO 53408
52551: LD_INT 9
52553: DOUBLE
52554: EQUAL
52555: IFTRUE 52559
52557: GO 52585
52559: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52560: LD_ADDR_VAR 0 3
52564: PUSH
52565: LD_INT 2
52567: PUSH
52568: LD_INT 3
52570: PUSH
52571: LD_INT 4
52573: PUSH
52574: LD_INT 5
52576: PUSH
52577: EMPTY
52578: LIST
52579: LIST
52580: LIST
52581: LIST
52582: ST_TO_ADDR
52583: GO 53408
52585: LD_INT 7
52587: DOUBLE
52588: EQUAL
52589: IFTRUE 52593
52591: GO 52619
52593: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52594: LD_ADDR_VAR 0 3
52598: PUSH
52599: LD_INT 2
52601: PUSH
52602: LD_INT 3
52604: PUSH
52605: LD_INT 4
52607: PUSH
52608: LD_INT 5
52610: PUSH
52611: EMPTY
52612: LIST
52613: LIST
52614: LIST
52615: LIST
52616: ST_TO_ADDR
52617: GO 53408
52619: LD_INT 12
52621: DOUBLE
52622: EQUAL
52623: IFTRUE 52627
52625: GO 52653
52627: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52628: LD_ADDR_VAR 0 3
52632: PUSH
52633: LD_INT 2
52635: PUSH
52636: LD_INT 3
52638: PUSH
52639: LD_INT 4
52641: PUSH
52642: LD_INT 5
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: LIST
52649: LIST
52650: ST_TO_ADDR
52651: GO 53408
52653: LD_INT 13
52655: DOUBLE
52656: EQUAL
52657: IFTRUE 52661
52659: GO 52687
52661: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52662: LD_ADDR_VAR 0 3
52666: PUSH
52667: LD_INT 2
52669: PUSH
52670: LD_INT 3
52672: PUSH
52673: LD_INT 4
52675: PUSH
52676: LD_INT 5
52678: PUSH
52679: EMPTY
52680: LIST
52681: LIST
52682: LIST
52683: LIST
52684: ST_TO_ADDR
52685: GO 53408
52687: LD_INT 14
52689: DOUBLE
52690: EQUAL
52691: IFTRUE 52695
52693: GO 52713
52695: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52696: LD_ADDR_VAR 0 3
52700: PUSH
52701: LD_INT 4
52703: PUSH
52704: LD_INT 5
52706: PUSH
52707: EMPTY
52708: LIST
52709: LIST
52710: ST_TO_ADDR
52711: GO 53408
52713: LD_INT 6
52715: DOUBLE
52716: EQUAL
52717: IFTRUE 52721
52719: GO 52739
52721: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52722: LD_ADDR_VAR 0 3
52726: PUSH
52727: LD_INT 4
52729: PUSH
52730: LD_INT 5
52732: PUSH
52733: EMPTY
52734: LIST
52735: LIST
52736: ST_TO_ADDR
52737: GO 53408
52739: LD_INT 10
52741: DOUBLE
52742: EQUAL
52743: IFTRUE 52747
52745: GO 52765
52747: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52748: LD_ADDR_VAR 0 3
52752: PUSH
52753: LD_INT 4
52755: PUSH
52756: LD_INT 5
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: ST_TO_ADDR
52763: GO 53408
52765: LD_INT 22
52767: DOUBLE
52768: EQUAL
52769: IFTRUE 52773
52771: GO 52799
52773: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_INT 11
52781: PUSH
52782: LD_INT 12
52784: PUSH
52785: LD_INT 13
52787: PUSH
52788: LD_INT 14
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: ST_TO_ADDR
52797: GO 53408
52799: LD_INT 23
52801: DOUBLE
52802: EQUAL
52803: IFTRUE 52807
52805: GO 52833
52807: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52808: LD_ADDR_VAR 0 3
52812: PUSH
52813: LD_INT 11
52815: PUSH
52816: LD_INT 12
52818: PUSH
52819: LD_INT 13
52821: PUSH
52822: LD_INT 14
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: LIST
52829: LIST
52830: ST_TO_ADDR
52831: GO 53408
52833: LD_INT 24
52835: DOUBLE
52836: EQUAL
52837: IFTRUE 52841
52839: GO 52867
52841: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: LD_INT 11
52849: PUSH
52850: LD_INT 12
52852: PUSH
52853: LD_INT 13
52855: PUSH
52856: LD_INT 14
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: LIST
52863: LIST
52864: ST_TO_ADDR
52865: GO 53408
52867: LD_INT 30
52869: DOUBLE
52870: EQUAL
52871: IFTRUE 52875
52873: GO 52901
52875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52876: LD_ADDR_VAR 0 3
52880: PUSH
52881: LD_INT 11
52883: PUSH
52884: LD_INT 12
52886: PUSH
52887: LD_INT 13
52889: PUSH
52890: LD_INT 14
52892: PUSH
52893: EMPTY
52894: LIST
52895: LIST
52896: LIST
52897: LIST
52898: ST_TO_ADDR
52899: GO 53408
52901: LD_INT 25
52903: DOUBLE
52904: EQUAL
52905: IFTRUE 52909
52907: GO 52927
52909: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52910: LD_ADDR_VAR 0 3
52914: PUSH
52915: LD_INT 13
52917: PUSH
52918: LD_INT 14
52920: PUSH
52921: EMPTY
52922: LIST
52923: LIST
52924: ST_TO_ADDR
52925: GO 53408
52927: LD_INT 27
52929: DOUBLE
52930: EQUAL
52931: IFTRUE 52935
52933: GO 52953
52935: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52936: LD_ADDR_VAR 0 3
52940: PUSH
52941: LD_INT 13
52943: PUSH
52944: LD_INT 14
52946: PUSH
52947: EMPTY
52948: LIST
52949: LIST
52950: ST_TO_ADDR
52951: GO 53408
52953: LD_INT 92
52955: DOUBLE
52956: EQUAL
52957: IFTRUE 52961
52959: GO 52987
52961: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52962: LD_ADDR_VAR 0 3
52966: PUSH
52967: LD_INT 11
52969: PUSH
52970: LD_INT 12
52972: PUSH
52973: LD_INT 13
52975: PUSH
52976: LD_INT 14
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: LIST
52983: LIST
52984: ST_TO_ADDR
52985: GO 53408
52987: LD_INT 28
52989: DOUBLE
52990: EQUAL
52991: IFTRUE 52995
52993: GO 53013
52995: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52996: LD_ADDR_VAR 0 3
53000: PUSH
53001: LD_INT 13
53003: PUSH
53004: LD_INT 14
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: ST_TO_ADDR
53011: GO 53408
53013: LD_INT 29
53015: DOUBLE
53016: EQUAL
53017: IFTRUE 53021
53019: GO 53039
53021: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53022: LD_ADDR_VAR 0 3
53026: PUSH
53027: LD_INT 13
53029: PUSH
53030: LD_INT 14
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: ST_TO_ADDR
53037: GO 53408
53039: LD_INT 31
53041: DOUBLE
53042: EQUAL
53043: IFTRUE 53047
53045: GO 53065
53047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53048: LD_ADDR_VAR 0 3
53052: PUSH
53053: LD_INT 13
53055: PUSH
53056: LD_INT 14
53058: PUSH
53059: EMPTY
53060: LIST
53061: LIST
53062: ST_TO_ADDR
53063: GO 53408
53065: LD_INT 26
53067: DOUBLE
53068: EQUAL
53069: IFTRUE 53073
53071: GO 53091
53073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53074: LD_ADDR_VAR 0 3
53078: PUSH
53079: LD_INT 13
53081: PUSH
53082: LD_INT 14
53084: PUSH
53085: EMPTY
53086: LIST
53087: LIST
53088: ST_TO_ADDR
53089: GO 53408
53091: LD_INT 42
53093: DOUBLE
53094: EQUAL
53095: IFTRUE 53099
53097: GO 53125
53099: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53100: LD_ADDR_VAR 0 3
53104: PUSH
53105: LD_INT 21
53107: PUSH
53108: LD_INT 22
53110: PUSH
53111: LD_INT 23
53113: PUSH
53114: LD_INT 24
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: LIST
53121: LIST
53122: ST_TO_ADDR
53123: GO 53408
53125: LD_INT 43
53127: DOUBLE
53128: EQUAL
53129: IFTRUE 53133
53131: GO 53159
53133: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53134: LD_ADDR_VAR 0 3
53138: PUSH
53139: LD_INT 21
53141: PUSH
53142: LD_INT 22
53144: PUSH
53145: LD_INT 23
53147: PUSH
53148: LD_INT 24
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: ST_TO_ADDR
53157: GO 53408
53159: LD_INT 44
53161: DOUBLE
53162: EQUAL
53163: IFTRUE 53167
53165: GO 53193
53167: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53168: LD_ADDR_VAR 0 3
53172: PUSH
53173: LD_INT 21
53175: PUSH
53176: LD_INT 22
53178: PUSH
53179: LD_INT 23
53181: PUSH
53182: LD_INT 24
53184: PUSH
53185: EMPTY
53186: LIST
53187: LIST
53188: LIST
53189: LIST
53190: ST_TO_ADDR
53191: GO 53408
53193: LD_INT 45
53195: DOUBLE
53196: EQUAL
53197: IFTRUE 53201
53199: GO 53227
53201: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53202: LD_ADDR_VAR 0 3
53206: PUSH
53207: LD_INT 21
53209: PUSH
53210: LD_INT 22
53212: PUSH
53213: LD_INT 23
53215: PUSH
53216: LD_INT 24
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: LIST
53223: LIST
53224: ST_TO_ADDR
53225: GO 53408
53227: LD_INT 49
53229: DOUBLE
53230: EQUAL
53231: IFTRUE 53235
53233: GO 53261
53235: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53236: LD_ADDR_VAR 0 3
53240: PUSH
53241: LD_INT 21
53243: PUSH
53244: LD_INT 22
53246: PUSH
53247: LD_INT 23
53249: PUSH
53250: LD_INT 24
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: LIST
53257: LIST
53258: ST_TO_ADDR
53259: GO 53408
53261: LD_INT 51
53263: DOUBLE
53264: EQUAL
53265: IFTRUE 53269
53267: GO 53295
53269: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53270: LD_ADDR_VAR 0 3
53274: PUSH
53275: LD_INT 21
53277: PUSH
53278: LD_INT 22
53280: PUSH
53281: LD_INT 23
53283: PUSH
53284: LD_INT 24
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: LIST
53291: LIST
53292: ST_TO_ADDR
53293: GO 53408
53295: LD_INT 52
53297: DOUBLE
53298: EQUAL
53299: IFTRUE 53303
53301: GO 53329
53303: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53304: LD_ADDR_VAR 0 3
53308: PUSH
53309: LD_INT 21
53311: PUSH
53312: LD_INT 22
53314: PUSH
53315: LD_INT 23
53317: PUSH
53318: LD_INT 24
53320: PUSH
53321: EMPTY
53322: LIST
53323: LIST
53324: LIST
53325: LIST
53326: ST_TO_ADDR
53327: GO 53408
53329: LD_INT 53
53331: DOUBLE
53332: EQUAL
53333: IFTRUE 53337
53335: GO 53355
53337: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53338: LD_ADDR_VAR 0 3
53342: PUSH
53343: LD_INT 23
53345: PUSH
53346: LD_INT 24
53348: PUSH
53349: EMPTY
53350: LIST
53351: LIST
53352: ST_TO_ADDR
53353: GO 53408
53355: LD_INT 46
53357: DOUBLE
53358: EQUAL
53359: IFTRUE 53363
53361: GO 53381
53363: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53364: LD_ADDR_VAR 0 3
53368: PUSH
53369: LD_INT 23
53371: PUSH
53372: LD_INT 24
53374: PUSH
53375: EMPTY
53376: LIST
53377: LIST
53378: ST_TO_ADDR
53379: GO 53408
53381: LD_INT 47
53383: DOUBLE
53384: EQUAL
53385: IFTRUE 53389
53387: GO 53407
53389: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53390: LD_ADDR_VAR 0 3
53394: PUSH
53395: LD_INT 23
53397: PUSH
53398: LD_INT 24
53400: PUSH
53401: EMPTY
53402: LIST
53403: LIST
53404: ST_TO_ADDR
53405: GO 53408
53407: POP
// result := ( chassis in result ) ;
53408: LD_ADDR_VAR 0 3
53412: PUSH
53413: LD_VAR 0 1
53417: PUSH
53418: LD_VAR 0 3
53422: IN
53423: ST_TO_ADDR
// end ;
53424: LD_VAR 0 3
53428: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53429: LD_INT 0
53431: PPUSH
53432: PPUSH
53433: PPUSH
53434: PPUSH
53435: PPUSH
53436: PPUSH
53437: PPUSH
// result := array ;
53438: LD_ADDR_VAR 0 5
53442: PUSH
53443: LD_VAR 0 1
53447: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53448: LD_VAR 0 1
53452: NOT
53453: PUSH
53454: LD_VAR 0 2
53458: NOT
53459: OR
53460: PUSH
53461: LD_VAR 0 3
53465: NOT
53466: OR
53467: PUSH
53468: LD_VAR 0 2
53472: PUSH
53473: LD_VAR 0 1
53477: GREATER
53478: OR
53479: PUSH
53480: LD_VAR 0 3
53484: PUSH
53485: LD_VAR 0 1
53489: GREATER
53490: OR
53491: IFFALSE 53495
// exit ;
53493: GO 53791
// if direction then
53495: LD_VAR 0 4
53499: IFFALSE 53563
// begin d := 1 ;
53501: LD_ADDR_VAR 0 9
53505: PUSH
53506: LD_INT 1
53508: ST_TO_ADDR
// if i_from > i_to then
53509: LD_VAR 0 2
53513: PUSH
53514: LD_VAR 0 3
53518: GREATER
53519: IFFALSE 53545
// length := ( array - i_from ) + i_to else
53521: LD_ADDR_VAR 0 11
53525: PUSH
53526: LD_VAR 0 1
53530: PUSH
53531: LD_VAR 0 2
53535: MINUS
53536: PUSH
53537: LD_VAR 0 3
53541: PLUS
53542: ST_TO_ADDR
53543: GO 53561
// length := i_to - i_from ;
53545: LD_ADDR_VAR 0 11
53549: PUSH
53550: LD_VAR 0 3
53554: PUSH
53555: LD_VAR 0 2
53559: MINUS
53560: ST_TO_ADDR
// end else
53561: GO 53624
// begin d := - 1 ;
53563: LD_ADDR_VAR 0 9
53567: PUSH
53568: LD_INT 1
53570: NEG
53571: ST_TO_ADDR
// if i_from > i_to then
53572: LD_VAR 0 2
53576: PUSH
53577: LD_VAR 0 3
53581: GREATER
53582: IFFALSE 53602
// length := i_from - i_to else
53584: LD_ADDR_VAR 0 11
53588: PUSH
53589: LD_VAR 0 2
53593: PUSH
53594: LD_VAR 0 3
53598: MINUS
53599: ST_TO_ADDR
53600: GO 53624
// length := ( array - i_to ) + i_from ;
53602: LD_ADDR_VAR 0 11
53606: PUSH
53607: LD_VAR 0 1
53611: PUSH
53612: LD_VAR 0 3
53616: MINUS
53617: PUSH
53618: LD_VAR 0 2
53622: PLUS
53623: ST_TO_ADDR
// end ; if not length then
53624: LD_VAR 0 11
53628: NOT
53629: IFFALSE 53633
// exit ;
53631: GO 53791
// tmp := array ;
53633: LD_ADDR_VAR 0 10
53637: PUSH
53638: LD_VAR 0 1
53642: ST_TO_ADDR
// for i = 1 to length do
53643: LD_ADDR_VAR 0 6
53647: PUSH
53648: DOUBLE
53649: LD_INT 1
53651: DEC
53652: ST_TO_ADDR
53653: LD_VAR 0 11
53657: PUSH
53658: FOR_TO
53659: IFFALSE 53779
// begin for j = 1 to array do
53661: LD_ADDR_VAR 0 7
53665: PUSH
53666: DOUBLE
53667: LD_INT 1
53669: DEC
53670: ST_TO_ADDR
53671: LD_VAR 0 1
53675: PUSH
53676: FOR_TO
53677: IFFALSE 53765
// begin k := j + d ;
53679: LD_ADDR_VAR 0 8
53683: PUSH
53684: LD_VAR 0 7
53688: PUSH
53689: LD_VAR 0 9
53693: PLUS
53694: ST_TO_ADDR
// if k > array then
53695: LD_VAR 0 8
53699: PUSH
53700: LD_VAR 0 1
53704: GREATER
53705: IFFALSE 53715
// k := 1 ;
53707: LD_ADDR_VAR 0 8
53711: PUSH
53712: LD_INT 1
53714: ST_TO_ADDR
// if not k then
53715: LD_VAR 0 8
53719: NOT
53720: IFFALSE 53732
// k := array ;
53722: LD_ADDR_VAR 0 8
53726: PUSH
53727: LD_VAR 0 1
53731: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53732: LD_ADDR_VAR 0 10
53736: PUSH
53737: LD_VAR 0 10
53741: PPUSH
53742: LD_VAR 0 8
53746: PPUSH
53747: LD_VAR 0 1
53751: PUSH
53752: LD_VAR 0 7
53756: ARRAY
53757: PPUSH
53758: CALL_OW 1
53762: ST_TO_ADDR
// end ;
53763: GO 53676
53765: POP
53766: POP
// array := tmp ;
53767: LD_ADDR_VAR 0 1
53771: PUSH
53772: LD_VAR 0 10
53776: ST_TO_ADDR
// end ;
53777: GO 53658
53779: POP
53780: POP
// result := array ;
53781: LD_ADDR_VAR 0 5
53785: PUSH
53786: LD_VAR 0 1
53790: ST_TO_ADDR
// end ;
53791: LD_VAR 0 5
53795: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53796: LD_INT 0
53798: PPUSH
53799: PPUSH
// result := 0 ;
53800: LD_ADDR_VAR 0 3
53804: PUSH
53805: LD_INT 0
53807: ST_TO_ADDR
// if not array or not value in array then
53808: LD_VAR 0 1
53812: NOT
53813: PUSH
53814: LD_VAR 0 2
53818: PUSH
53819: LD_VAR 0 1
53823: IN
53824: NOT
53825: OR
53826: IFFALSE 53830
// exit ;
53828: GO 53884
// for i = 1 to array do
53830: LD_ADDR_VAR 0 4
53834: PUSH
53835: DOUBLE
53836: LD_INT 1
53838: DEC
53839: ST_TO_ADDR
53840: LD_VAR 0 1
53844: PUSH
53845: FOR_TO
53846: IFFALSE 53882
// if value = array [ i ] then
53848: LD_VAR 0 2
53852: PUSH
53853: LD_VAR 0 1
53857: PUSH
53858: LD_VAR 0 4
53862: ARRAY
53863: EQUAL
53864: IFFALSE 53880
// begin result := i ;
53866: LD_ADDR_VAR 0 3
53870: PUSH
53871: LD_VAR 0 4
53875: ST_TO_ADDR
// exit ;
53876: POP
53877: POP
53878: GO 53884
// end ;
53880: GO 53845
53882: POP
53883: POP
// end ;
53884: LD_VAR 0 3
53888: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53889: LD_INT 0
53891: PPUSH
// vc_chassis := chassis ;
53892: LD_ADDR_OWVAR 37
53896: PUSH
53897: LD_VAR 0 1
53901: ST_TO_ADDR
// vc_engine := engine ;
53902: LD_ADDR_OWVAR 39
53906: PUSH
53907: LD_VAR 0 2
53911: ST_TO_ADDR
// vc_control := control ;
53912: LD_ADDR_OWVAR 38
53916: PUSH
53917: LD_VAR 0 3
53921: ST_TO_ADDR
// vc_weapon := weapon ;
53922: LD_ADDR_OWVAR 40
53926: PUSH
53927: LD_VAR 0 4
53931: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53932: LD_ADDR_OWVAR 41
53936: PUSH
53937: LD_VAR 0 5
53941: ST_TO_ADDR
// end ;
53942: LD_VAR 0 6
53946: RET
// export function WantPlant ( unit ) ; var task ; begin
53947: LD_INT 0
53949: PPUSH
53950: PPUSH
// result := false ;
53951: LD_ADDR_VAR 0 2
53955: PUSH
53956: LD_INT 0
53958: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53959: LD_ADDR_VAR 0 3
53963: PUSH
53964: LD_VAR 0 1
53968: PPUSH
53969: CALL_OW 437
53973: ST_TO_ADDR
// if task then
53974: LD_VAR 0 3
53978: IFFALSE 54006
// if task [ 1 ] [ 1 ] = p then
53980: LD_VAR 0 3
53984: PUSH
53985: LD_INT 1
53987: ARRAY
53988: PUSH
53989: LD_INT 1
53991: ARRAY
53992: PUSH
53993: LD_STRING p
53995: EQUAL
53996: IFFALSE 54006
// result := true ;
53998: LD_ADDR_VAR 0 2
54002: PUSH
54003: LD_INT 1
54005: ST_TO_ADDR
// end ;
54006: LD_VAR 0 2
54010: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54011: LD_INT 0
54013: PPUSH
54014: PPUSH
54015: PPUSH
54016: PPUSH
// if pos < 1 then
54017: LD_VAR 0 2
54021: PUSH
54022: LD_INT 1
54024: LESS
54025: IFFALSE 54029
// exit ;
54027: GO 54332
// if pos = 1 then
54029: LD_VAR 0 2
54033: PUSH
54034: LD_INT 1
54036: EQUAL
54037: IFFALSE 54070
// result := Replace ( arr , pos [ 1 ] , value ) else
54039: LD_ADDR_VAR 0 4
54043: PUSH
54044: LD_VAR 0 1
54048: PPUSH
54049: LD_VAR 0 2
54053: PUSH
54054: LD_INT 1
54056: ARRAY
54057: PPUSH
54058: LD_VAR 0 3
54062: PPUSH
54063: CALL_OW 1
54067: ST_TO_ADDR
54068: GO 54332
// begin tmp := arr ;
54070: LD_ADDR_VAR 0 6
54074: PUSH
54075: LD_VAR 0 1
54079: ST_TO_ADDR
// s_arr := [ tmp ] ;
54080: LD_ADDR_VAR 0 7
54084: PUSH
54085: LD_VAR 0 6
54089: PUSH
54090: EMPTY
54091: LIST
54092: ST_TO_ADDR
// for i = 1 to pos - 1 do
54093: LD_ADDR_VAR 0 5
54097: PUSH
54098: DOUBLE
54099: LD_INT 1
54101: DEC
54102: ST_TO_ADDR
54103: LD_VAR 0 2
54107: PUSH
54108: LD_INT 1
54110: MINUS
54111: PUSH
54112: FOR_TO
54113: IFFALSE 54158
// begin tmp := tmp [ pos [ i ] ] ;
54115: LD_ADDR_VAR 0 6
54119: PUSH
54120: LD_VAR 0 6
54124: PUSH
54125: LD_VAR 0 2
54129: PUSH
54130: LD_VAR 0 5
54134: ARRAY
54135: ARRAY
54136: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54137: LD_ADDR_VAR 0 7
54141: PUSH
54142: LD_VAR 0 7
54146: PUSH
54147: LD_VAR 0 6
54151: PUSH
54152: EMPTY
54153: LIST
54154: ADD
54155: ST_TO_ADDR
// end ;
54156: GO 54112
54158: POP
54159: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54160: LD_ADDR_VAR 0 6
54164: PUSH
54165: LD_VAR 0 6
54169: PPUSH
54170: LD_VAR 0 2
54174: PUSH
54175: LD_VAR 0 2
54179: ARRAY
54180: PPUSH
54181: LD_VAR 0 3
54185: PPUSH
54186: CALL_OW 1
54190: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54191: LD_ADDR_VAR 0 7
54195: PUSH
54196: LD_VAR 0 7
54200: PPUSH
54201: LD_VAR 0 7
54205: PPUSH
54206: LD_VAR 0 6
54210: PPUSH
54211: CALL_OW 1
54215: ST_TO_ADDR
// for i = s_arr downto 2 do
54216: LD_ADDR_VAR 0 5
54220: PUSH
54221: DOUBLE
54222: LD_VAR 0 7
54226: INC
54227: ST_TO_ADDR
54228: LD_INT 2
54230: PUSH
54231: FOR_DOWNTO
54232: IFFALSE 54316
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54234: LD_ADDR_VAR 0 6
54238: PUSH
54239: LD_VAR 0 7
54243: PUSH
54244: LD_VAR 0 5
54248: PUSH
54249: LD_INT 1
54251: MINUS
54252: ARRAY
54253: PPUSH
54254: LD_VAR 0 2
54258: PUSH
54259: LD_VAR 0 5
54263: PUSH
54264: LD_INT 1
54266: MINUS
54267: ARRAY
54268: PPUSH
54269: LD_VAR 0 7
54273: PUSH
54274: LD_VAR 0 5
54278: ARRAY
54279: PPUSH
54280: CALL_OW 1
54284: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54285: LD_ADDR_VAR 0 7
54289: PUSH
54290: LD_VAR 0 7
54294: PPUSH
54295: LD_VAR 0 5
54299: PUSH
54300: LD_INT 1
54302: MINUS
54303: PPUSH
54304: LD_VAR 0 6
54308: PPUSH
54309: CALL_OW 1
54313: ST_TO_ADDR
// end ;
54314: GO 54231
54316: POP
54317: POP
// result := s_arr [ 1 ] ;
54318: LD_ADDR_VAR 0 4
54322: PUSH
54323: LD_VAR 0 7
54327: PUSH
54328: LD_INT 1
54330: ARRAY
54331: ST_TO_ADDR
// end ; end ;
54332: LD_VAR 0 4
54336: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54337: LD_INT 0
54339: PPUSH
54340: PPUSH
// if not list then
54341: LD_VAR 0 1
54345: NOT
54346: IFFALSE 54350
// exit ;
54348: GO 54441
// i := list [ pos1 ] ;
54350: LD_ADDR_VAR 0 5
54354: PUSH
54355: LD_VAR 0 1
54359: PUSH
54360: LD_VAR 0 2
54364: ARRAY
54365: ST_TO_ADDR
// if not i then
54366: LD_VAR 0 5
54370: NOT
54371: IFFALSE 54375
// exit ;
54373: GO 54441
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54375: LD_ADDR_VAR 0 1
54379: PUSH
54380: LD_VAR 0 1
54384: PPUSH
54385: LD_VAR 0 2
54389: PPUSH
54390: LD_VAR 0 1
54394: PUSH
54395: LD_VAR 0 3
54399: ARRAY
54400: PPUSH
54401: CALL_OW 1
54405: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54406: LD_ADDR_VAR 0 1
54410: PUSH
54411: LD_VAR 0 1
54415: PPUSH
54416: LD_VAR 0 3
54420: PPUSH
54421: LD_VAR 0 5
54425: PPUSH
54426: CALL_OW 1
54430: ST_TO_ADDR
// result := list ;
54431: LD_ADDR_VAR 0 4
54435: PUSH
54436: LD_VAR 0 1
54440: ST_TO_ADDR
// end ;
54441: LD_VAR 0 4
54445: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54446: LD_INT 0
54448: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54449: LD_ADDR_VAR 0 5
54453: PUSH
54454: LD_VAR 0 1
54458: PPUSH
54459: CALL_OW 250
54463: PPUSH
54464: LD_VAR 0 1
54468: PPUSH
54469: CALL_OW 251
54473: PPUSH
54474: LD_VAR 0 2
54478: PPUSH
54479: LD_VAR 0 3
54483: PPUSH
54484: LD_VAR 0 4
54488: PPUSH
54489: CALL 54867 0 5
54493: ST_TO_ADDR
// end ;
54494: LD_VAR 0 5
54498: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54499: LD_INT 0
54501: PPUSH
54502: PPUSH
54503: PPUSH
54504: PPUSH
// if not list or not unit then
54505: LD_VAR 0 2
54509: NOT
54510: PUSH
54511: LD_VAR 0 1
54515: NOT
54516: OR
54517: IFFALSE 54521
// exit ;
54519: GO 54862
// result := [ ] ;
54521: LD_ADDR_VAR 0 5
54525: PUSH
54526: EMPTY
54527: ST_TO_ADDR
// for i in list do
54528: LD_ADDR_VAR 0 6
54532: PUSH
54533: LD_VAR 0 2
54537: PUSH
54538: FOR_IN
54539: IFFALSE 54757
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54541: LD_ADDR_VAR 0 8
54545: PUSH
54546: LD_VAR 0 1
54550: PPUSH
54551: LD_VAR 0 6
54555: PUSH
54556: LD_INT 1
54558: ARRAY
54559: PPUSH
54560: LD_VAR 0 6
54564: PUSH
54565: LD_INT 2
54567: ARRAY
54568: PPUSH
54569: CALL_OW 297
54573: ST_TO_ADDR
// if not Count ( result ) then
54574: LD_VAR 0 5
54578: PPUSH
54579: CALL 51151 0 1
54583: NOT
54584: IFFALSE 54617
// begin result := Join ( result , [ i , tmp ] ) ;
54586: LD_ADDR_VAR 0 5
54590: PUSH
54591: LD_VAR 0 5
54595: PPUSH
54596: LD_VAR 0 6
54600: PUSH
54601: LD_VAR 0 8
54605: PUSH
54606: EMPTY
54607: LIST
54608: LIST
54609: PPUSH
54610: CALL 86760 0 2
54614: ST_TO_ADDR
// continue ;
54615: GO 54538
// end ; if result [ result ] [ 2 ] <= tmp then
54617: LD_VAR 0 5
54621: PUSH
54622: LD_VAR 0 5
54626: ARRAY
54627: PUSH
54628: LD_INT 2
54630: ARRAY
54631: PUSH
54632: LD_VAR 0 8
54636: LESSEQUAL
54637: IFFALSE 54670
// result := Join ( result , [ i , tmp ] ) else
54639: LD_ADDR_VAR 0 5
54643: PUSH
54644: LD_VAR 0 5
54648: PPUSH
54649: LD_VAR 0 6
54653: PUSH
54654: LD_VAR 0 8
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: PPUSH
54663: CALL 86760 0 2
54667: ST_TO_ADDR
54668: GO 54755
// begin for j := 1 to Count ( result ) do
54670: LD_ADDR_VAR 0 7
54674: PUSH
54675: DOUBLE
54676: LD_INT 1
54678: DEC
54679: ST_TO_ADDR
54680: LD_VAR 0 5
54684: PPUSH
54685: CALL 51151 0 1
54689: PUSH
54690: FOR_TO
54691: IFFALSE 54753
// begin if tmp < result [ j ] [ 2 ] then
54693: LD_VAR 0 8
54697: PUSH
54698: LD_VAR 0 5
54702: PUSH
54703: LD_VAR 0 7
54707: ARRAY
54708: PUSH
54709: LD_INT 2
54711: ARRAY
54712: LESS
54713: IFFALSE 54751
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54715: LD_ADDR_VAR 0 5
54719: PUSH
54720: LD_VAR 0 5
54724: PPUSH
54725: LD_VAR 0 7
54729: PPUSH
54730: LD_VAR 0 6
54734: PUSH
54735: LD_VAR 0 8
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: PPUSH
54744: CALL_OW 2
54748: ST_TO_ADDR
// break ;
54749: GO 54753
// end ; end ;
54751: GO 54690
54753: POP
54754: POP
// end ; end ;
54755: GO 54538
54757: POP
54758: POP
// if result and not asc then
54759: LD_VAR 0 5
54763: PUSH
54764: LD_VAR 0 3
54768: NOT
54769: AND
54770: IFFALSE 54787
// result := ReverseArray ( result ) ;
54772: LD_ADDR_VAR 0 5
54776: PUSH
54777: LD_VAR 0 5
54781: PPUSH
54782: CALL 82027 0 1
54786: ST_TO_ADDR
// tmp := [ ] ;
54787: LD_ADDR_VAR 0 8
54791: PUSH
54792: EMPTY
54793: ST_TO_ADDR
// if mode then
54794: LD_VAR 0 4
54798: IFFALSE 54862
// begin for i := 1 to result do
54800: LD_ADDR_VAR 0 6
54804: PUSH
54805: DOUBLE
54806: LD_INT 1
54808: DEC
54809: ST_TO_ADDR
54810: LD_VAR 0 5
54814: PUSH
54815: FOR_TO
54816: IFFALSE 54850
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54818: LD_ADDR_VAR 0 8
54822: PUSH
54823: LD_VAR 0 8
54827: PPUSH
54828: LD_VAR 0 5
54832: PUSH
54833: LD_VAR 0 6
54837: ARRAY
54838: PUSH
54839: LD_INT 1
54841: ARRAY
54842: PPUSH
54843: CALL 86760 0 2
54847: ST_TO_ADDR
54848: GO 54815
54850: POP
54851: POP
// result := tmp ;
54852: LD_ADDR_VAR 0 5
54856: PUSH
54857: LD_VAR 0 8
54861: ST_TO_ADDR
// end ; end ;
54862: LD_VAR 0 5
54866: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54867: LD_INT 0
54869: PPUSH
54870: PPUSH
54871: PPUSH
54872: PPUSH
// if not list then
54873: LD_VAR 0 3
54877: NOT
54878: IFFALSE 54882
// exit ;
54880: GO 55270
// result := [ ] ;
54882: LD_ADDR_VAR 0 6
54886: PUSH
54887: EMPTY
54888: ST_TO_ADDR
// for i in list do
54889: LD_ADDR_VAR 0 7
54893: PUSH
54894: LD_VAR 0 3
54898: PUSH
54899: FOR_IN
54900: IFFALSE 55102
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54902: LD_ADDR_VAR 0 9
54906: PUSH
54907: LD_VAR 0 7
54911: PPUSH
54912: LD_VAR 0 1
54916: PPUSH
54917: LD_VAR 0 2
54921: PPUSH
54922: CALL_OW 297
54926: ST_TO_ADDR
// if not result then
54927: LD_VAR 0 6
54931: NOT
54932: IFFALSE 54958
// result := [ [ i , tmp ] ] else
54934: LD_ADDR_VAR 0 6
54938: PUSH
54939: LD_VAR 0 7
54943: PUSH
54944: LD_VAR 0 9
54948: PUSH
54949: EMPTY
54950: LIST
54951: LIST
54952: PUSH
54953: EMPTY
54954: LIST
54955: ST_TO_ADDR
54956: GO 55100
// begin if result [ result ] [ 2 ] <= tmp then
54958: LD_VAR 0 6
54962: PUSH
54963: LD_VAR 0 6
54967: ARRAY
54968: PUSH
54969: LD_INT 2
54971: ARRAY
54972: PUSH
54973: LD_VAR 0 9
54977: LESSEQUAL
54978: IFFALSE 55020
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54980: LD_ADDR_VAR 0 6
54984: PUSH
54985: LD_VAR 0 6
54989: PPUSH
54990: LD_VAR 0 6
54994: PUSH
54995: LD_INT 1
54997: PLUS
54998: PPUSH
54999: LD_VAR 0 7
55003: PUSH
55004: LD_VAR 0 9
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: PPUSH
55013: CALL_OW 2
55017: ST_TO_ADDR
55018: GO 55100
// for j := 1 to result do
55020: LD_ADDR_VAR 0 8
55024: PUSH
55025: DOUBLE
55026: LD_INT 1
55028: DEC
55029: ST_TO_ADDR
55030: LD_VAR 0 6
55034: PUSH
55035: FOR_TO
55036: IFFALSE 55098
// begin if tmp < result [ j ] [ 2 ] then
55038: LD_VAR 0 9
55042: PUSH
55043: LD_VAR 0 6
55047: PUSH
55048: LD_VAR 0 8
55052: ARRAY
55053: PUSH
55054: LD_INT 2
55056: ARRAY
55057: LESS
55058: IFFALSE 55096
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55060: LD_ADDR_VAR 0 6
55064: PUSH
55065: LD_VAR 0 6
55069: PPUSH
55070: LD_VAR 0 8
55074: PPUSH
55075: LD_VAR 0 7
55079: PUSH
55080: LD_VAR 0 9
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: PPUSH
55089: CALL_OW 2
55093: ST_TO_ADDR
// break ;
55094: GO 55098
// end ; end ;
55096: GO 55035
55098: POP
55099: POP
// end ; end ;
55100: GO 54899
55102: POP
55103: POP
// if result and not asc then
55104: LD_VAR 0 6
55108: PUSH
55109: LD_VAR 0 4
55113: NOT
55114: AND
55115: IFFALSE 55190
// begin tmp := result ;
55117: LD_ADDR_VAR 0 9
55121: PUSH
55122: LD_VAR 0 6
55126: ST_TO_ADDR
// for i = tmp downto 1 do
55127: LD_ADDR_VAR 0 7
55131: PUSH
55132: DOUBLE
55133: LD_VAR 0 9
55137: INC
55138: ST_TO_ADDR
55139: LD_INT 1
55141: PUSH
55142: FOR_DOWNTO
55143: IFFALSE 55188
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55145: LD_ADDR_VAR 0 6
55149: PUSH
55150: LD_VAR 0 6
55154: PPUSH
55155: LD_VAR 0 9
55159: PUSH
55160: LD_VAR 0 7
55164: MINUS
55165: PUSH
55166: LD_INT 1
55168: PLUS
55169: PPUSH
55170: LD_VAR 0 9
55174: PUSH
55175: LD_VAR 0 7
55179: ARRAY
55180: PPUSH
55181: CALL_OW 1
55185: ST_TO_ADDR
55186: GO 55142
55188: POP
55189: POP
// end ; tmp := [ ] ;
55190: LD_ADDR_VAR 0 9
55194: PUSH
55195: EMPTY
55196: ST_TO_ADDR
// if mode then
55197: LD_VAR 0 5
55201: IFFALSE 55270
// begin for i = 1 to result do
55203: LD_ADDR_VAR 0 7
55207: PUSH
55208: DOUBLE
55209: LD_INT 1
55211: DEC
55212: ST_TO_ADDR
55213: LD_VAR 0 6
55217: PUSH
55218: FOR_TO
55219: IFFALSE 55258
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55221: LD_ADDR_VAR 0 9
55225: PUSH
55226: LD_VAR 0 9
55230: PPUSH
55231: LD_VAR 0 7
55235: PPUSH
55236: LD_VAR 0 6
55240: PUSH
55241: LD_VAR 0 7
55245: ARRAY
55246: PUSH
55247: LD_INT 1
55249: ARRAY
55250: PPUSH
55251: CALL_OW 1
55255: ST_TO_ADDR
55256: GO 55218
55258: POP
55259: POP
// result := tmp ;
55260: LD_ADDR_VAR 0 6
55264: PUSH
55265: LD_VAR 0 9
55269: ST_TO_ADDR
// end ; end ;
55270: LD_VAR 0 6
55274: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55275: LD_INT 0
55277: PPUSH
55278: PPUSH
55279: PPUSH
55280: PPUSH
55281: PPUSH
55282: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55283: LD_ADDR_VAR 0 5
55287: PUSH
55288: LD_INT 0
55290: PUSH
55291: LD_INT 0
55293: PUSH
55294: LD_INT 0
55296: PUSH
55297: EMPTY
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: LIST
55303: LIST
55304: ST_TO_ADDR
// if not x or not y then
55305: LD_VAR 0 2
55309: NOT
55310: PUSH
55311: LD_VAR 0 3
55315: NOT
55316: OR
55317: IFFALSE 55321
// exit ;
55319: GO 56971
// if not range then
55321: LD_VAR 0 4
55325: NOT
55326: IFFALSE 55336
// range := 10 ;
55328: LD_ADDR_VAR 0 4
55332: PUSH
55333: LD_INT 10
55335: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55336: LD_ADDR_VAR 0 8
55340: PUSH
55341: LD_INT 81
55343: PUSH
55344: LD_VAR 0 1
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: PUSH
55353: LD_INT 92
55355: PUSH
55356: LD_VAR 0 2
55360: PUSH
55361: LD_VAR 0 3
55365: PUSH
55366: LD_VAR 0 4
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: LIST
55375: LIST
55376: PUSH
55377: LD_INT 3
55379: PUSH
55380: LD_INT 21
55382: PUSH
55383: LD_INT 3
55385: PUSH
55386: EMPTY
55387: LIST
55388: LIST
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: LIST
55398: PPUSH
55399: CALL_OW 69
55403: ST_TO_ADDR
// if not tmp then
55404: LD_VAR 0 8
55408: NOT
55409: IFFALSE 55413
// exit ;
55411: GO 56971
// for i in tmp do
55413: LD_ADDR_VAR 0 6
55417: PUSH
55418: LD_VAR 0 8
55422: PUSH
55423: FOR_IN
55424: IFFALSE 56946
// begin points := [ 0 , 0 , 0 ] ;
55426: LD_ADDR_VAR 0 9
55430: PUSH
55431: LD_INT 0
55433: PUSH
55434: LD_INT 0
55436: PUSH
55437: LD_INT 0
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: ST_TO_ADDR
// bpoints := 1 ;
55445: LD_ADDR_VAR 0 10
55449: PUSH
55450: LD_INT 1
55452: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55453: LD_VAR 0 6
55457: PPUSH
55458: CALL_OW 247
55462: PUSH
55463: LD_INT 1
55465: DOUBLE
55466: EQUAL
55467: IFTRUE 55471
55469: GO 56049
55471: POP
// begin if GetClass ( i ) = 1 then
55472: LD_VAR 0 6
55476: PPUSH
55477: CALL_OW 257
55481: PUSH
55482: LD_INT 1
55484: EQUAL
55485: IFFALSE 55506
// points := [ 10 , 5 , 3 ] ;
55487: LD_ADDR_VAR 0 9
55491: PUSH
55492: LD_INT 10
55494: PUSH
55495: LD_INT 5
55497: PUSH
55498: LD_INT 3
55500: PUSH
55501: EMPTY
55502: LIST
55503: LIST
55504: LIST
55505: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55506: LD_VAR 0 6
55510: PPUSH
55511: CALL_OW 257
55515: PUSH
55516: LD_INT 2
55518: PUSH
55519: LD_INT 3
55521: PUSH
55522: LD_INT 4
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: LIST
55529: IN
55530: IFFALSE 55551
// points := [ 3 , 2 , 1 ] ;
55532: LD_ADDR_VAR 0 9
55536: PUSH
55537: LD_INT 3
55539: PUSH
55540: LD_INT 2
55542: PUSH
55543: LD_INT 1
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: LIST
55550: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55551: LD_VAR 0 6
55555: PPUSH
55556: CALL_OW 257
55560: PUSH
55561: LD_INT 5
55563: EQUAL
55564: IFFALSE 55585
// points := [ 130 , 5 , 2 ] ;
55566: LD_ADDR_VAR 0 9
55570: PUSH
55571: LD_INT 130
55573: PUSH
55574: LD_INT 5
55576: PUSH
55577: LD_INT 2
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55585: LD_VAR 0 6
55589: PPUSH
55590: CALL_OW 257
55594: PUSH
55595: LD_INT 8
55597: EQUAL
55598: IFFALSE 55619
// points := [ 35 , 35 , 30 ] ;
55600: LD_ADDR_VAR 0 9
55604: PUSH
55605: LD_INT 35
55607: PUSH
55608: LD_INT 35
55610: PUSH
55611: LD_INT 30
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55619: LD_VAR 0 6
55623: PPUSH
55624: CALL_OW 257
55628: PUSH
55629: LD_INT 9
55631: EQUAL
55632: IFFALSE 55653
// points := [ 20 , 55 , 40 ] ;
55634: LD_ADDR_VAR 0 9
55638: PUSH
55639: LD_INT 20
55641: PUSH
55642: LD_INT 55
55644: PUSH
55645: LD_INT 40
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: LIST
55652: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55653: LD_VAR 0 6
55657: PPUSH
55658: CALL_OW 257
55662: PUSH
55663: LD_INT 12
55665: PUSH
55666: LD_INT 16
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: IN
55673: IFFALSE 55694
// points := [ 5 , 3 , 2 ] ;
55675: LD_ADDR_VAR 0 9
55679: PUSH
55680: LD_INT 5
55682: PUSH
55683: LD_INT 3
55685: PUSH
55686: LD_INT 2
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55694: LD_VAR 0 6
55698: PPUSH
55699: CALL_OW 257
55703: PUSH
55704: LD_INT 17
55706: EQUAL
55707: IFFALSE 55728
// points := [ 100 , 50 , 75 ] ;
55709: LD_ADDR_VAR 0 9
55713: PUSH
55714: LD_INT 100
55716: PUSH
55717: LD_INT 50
55719: PUSH
55720: LD_INT 75
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: LIST
55727: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55728: LD_VAR 0 6
55732: PPUSH
55733: CALL_OW 257
55737: PUSH
55738: LD_INT 15
55740: EQUAL
55741: IFFALSE 55762
// points := [ 10 , 5 , 3 ] ;
55743: LD_ADDR_VAR 0 9
55747: PUSH
55748: LD_INT 10
55750: PUSH
55751: LD_INT 5
55753: PUSH
55754: LD_INT 3
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: LIST
55761: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55762: LD_VAR 0 6
55766: PPUSH
55767: CALL_OW 257
55771: PUSH
55772: LD_INT 14
55774: EQUAL
55775: IFFALSE 55796
// points := [ 10 , 0 , 0 ] ;
55777: LD_ADDR_VAR 0 9
55781: PUSH
55782: LD_INT 10
55784: PUSH
55785: LD_INT 0
55787: PUSH
55788: LD_INT 0
55790: PUSH
55791: EMPTY
55792: LIST
55793: LIST
55794: LIST
55795: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55796: LD_VAR 0 6
55800: PPUSH
55801: CALL_OW 257
55805: PUSH
55806: LD_INT 11
55808: EQUAL
55809: IFFALSE 55830
// points := [ 30 , 10 , 5 ] ;
55811: LD_ADDR_VAR 0 9
55815: PUSH
55816: LD_INT 30
55818: PUSH
55819: LD_INT 10
55821: PUSH
55822: LD_INT 5
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: LIST
55829: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55830: LD_VAR 0 1
55834: PPUSH
55835: LD_INT 5
55837: PPUSH
55838: CALL_OW 321
55842: PUSH
55843: LD_INT 2
55845: EQUAL
55846: IFFALSE 55863
// bpoints := bpoints * 1.8 ;
55848: LD_ADDR_VAR 0 10
55852: PUSH
55853: LD_VAR 0 10
55857: PUSH
55858: LD_REAL  1.80000000000000E+0000
55861: MUL
55862: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55863: LD_VAR 0 6
55867: PPUSH
55868: CALL_OW 257
55872: PUSH
55873: LD_INT 1
55875: PUSH
55876: LD_INT 2
55878: PUSH
55879: LD_INT 3
55881: PUSH
55882: LD_INT 4
55884: PUSH
55885: EMPTY
55886: LIST
55887: LIST
55888: LIST
55889: LIST
55890: IN
55891: PUSH
55892: LD_VAR 0 1
55896: PPUSH
55897: LD_INT 51
55899: PPUSH
55900: CALL_OW 321
55904: PUSH
55905: LD_INT 2
55907: EQUAL
55908: AND
55909: IFFALSE 55926
// bpoints := bpoints * 1.2 ;
55911: LD_ADDR_VAR 0 10
55915: PUSH
55916: LD_VAR 0 10
55920: PUSH
55921: LD_REAL  1.20000000000000E+0000
55924: MUL
55925: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55926: LD_VAR 0 6
55930: PPUSH
55931: CALL_OW 257
55935: PUSH
55936: LD_INT 5
55938: PUSH
55939: LD_INT 7
55941: PUSH
55942: LD_INT 9
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: LIST
55949: IN
55950: PUSH
55951: LD_VAR 0 1
55955: PPUSH
55956: LD_INT 52
55958: PPUSH
55959: CALL_OW 321
55963: PUSH
55964: LD_INT 2
55966: EQUAL
55967: AND
55968: IFFALSE 55985
// bpoints := bpoints * 1.5 ;
55970: LD_ADDR_VAR 0 10
55974: PUSH
55975: LD_VAR 0 10
55979: PUSH
55980: LD_REAL  1.50000000000000E+0000
55983: MUL
55984: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55985: LD_VAR 0 1
55989: PPUSH
55990: LD_INT 66
55992: PPUSH
55993: CALL_OW 321
55997: PUSH
55998: LD_INT 2
56000: EQUAL
56001: IFFALSE 56018
// bpoints := bpoints * 1.1 ;
56003: LD_ADDR_VAR 0 10
56007: PUSH
56008: LD_VAR 0 10
56012: PUSH
56013: LD_REAL  1.10000000000000E+0000
56016: MUL
56017: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56018: LD_ADDR_VAR 0 10
56022: PUSH
56023: LD_VAR 0 10
56027: PUSH
56028: LD_VAR 0 6
56032: PPUSH
56033: LD_INT 1
56035: PPUSH
56036: CALL_OW 259
56040: PUSH
56041: LD_REAL  1.15000000000000E+0000
56044: MUL
56045: MUL
56046: ST_TO_ADDR
// end ; unit_vehicle :
56047: GO 56875
56049: LD_INT 2
56051: DOUBLE
56052: EQUAL
56053: IFTRUE 56057
56055: GO 56863
56057: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56058: LD_VAR 0 6
56062: PPUSH
56063: CALL_OW 264
56067: PUSH
56068: LD_INT 2
56070: PUSH
56071: LD_INT 42
56073: PUSH
56074: LD_INT 24
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: LIST
56081: IN
56082: IFFALSE 56103
// points := [ 25 , 5 , 3 ] ;
56084: LD_ADDR_VAR 0 9
56088: PUSH
56089: LD_INT 25
56091: PUSH
56092: LD_INT 5
56094: PUSH
56095: LD_INT 3
56097: PUSH
56098: EMPTY
56099: LIST
56100: LIST
56101: LIST
56102: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56103: LD_VAR 0 6
56107: PPUSH
56108: CALL_OW 264
56112: PUSH
56113: LD_INT 4
56115: PUSH
56116: LD_INT 43
56118: PUSH
56119: LD_INT 25
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: LIST
56126: IN
56127: IFFALSE 56148
// points := [ 40 , 15 , 5 ] ;
56129: LD_ADDR_VAR 0 9
56133: PUSH
56134: LD_INT 40
56136: PUSH
56137: LD_INT 15
56139: PUSH
56140: LD_INT 5
56142: PUSH
56143: EMPTY
56144: LIST
56145: LIST
56146: LIST
56147: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56148: LD_VAR 0 6
56152: PPUSH
56153: CALL_OW 264
56157: PUSH
56158: LD_INT 3
56160: PUSH
56161: LD_INT 23
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: IN
56168: IFFALSE 56189
// points := [ 7 , 25 , 8 ] ;
56170: LD_ADDR_VAR 0 9
56174: PUSH
56175: LD_INT 7
56177: PUSH
56178: LD_INT 25
56180: PUSH
56181: LD_INT 8
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: LIST
56188: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56189: LD_VAR 0 6
56193: PPUSH
56194: CALL_OW 264
56198: PUSH
56199: LD_INT 5
56201: PUSH
56202: LD_INT 27
56204: PUSH
56205: LD_INT 44
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: LIST
56212: IN
56213: IFFALSE 56234
// points := [ 14 , 50 , 16 ] ;
56215: LD_ADDR_VAR 0 9
56219: PUSH
56220: LD_INT 14
56222: PUSH
56223: LD_INT 50
56225: PUSH
56226: LD_INT 16
56228: PUSH
56229: EMPTY
56230: LIST
56231: LIST
56232: LIST
56233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56234: LD_VAR 0 6
56238: PPUSH
56239: CALL_OW 264
56243: PUSH
56244: LD_INT 6
56246: PUSH
56247: LD_INT 46
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: IN
56254: IFFALSE 56275
// points := [ 32 , 120 , 70 ] ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_INT 32
56263: PUSH
56264: LD_INT 120
56266: PUSH
56267: LD_INT 70
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56275: LD_VAR 0 6
56279: PPUSH
56280: CALL_OW 264
56284: PUSH
56285: LD_INT 7
56287: PUSH
56288: LD_INT 28
56290: PUSH
56291: LD_INT 45
56293: PUSH
56294: LD_INT 92
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: LIST
56301: LIST
56302: IN
56303: IFFALSE 56324
// points := [ 35 , 20 , 45 ] ;
56305: LD_ADDR_VAR 0 9
56309: PUSH
56310: LD_INT 35
56312: PUSH
56313: LD_INT 20
56315: PUSH
56316: LD_INT 45
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: LIST
56323: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56324: LD_VAR 0 6
56328: PPUSH
56329: CALL_OW 264
56333: PUSH
56334: LD_INT 47
56336: PUSH
56337: EMPTY
56338: LIST
56339: IN
56340: IFFALSE 56361
// points := [ 67 , 45 , 75 ] ;
56342: LD_ADDR_VAR 0 9
56346: PUSH
56347: LD_INT 67
56349: PUSH
56350: LD_INT 45
56352: PUSH
56353: LD_INT 75
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: LIST
56360: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56361: LD_VAR 0 6
56365: PPUSH
56366: CALL_OW 264
56370: PUSH
56371: LD_INT 26
56373: PUSH
56374: EMPTY
56375: LIST
56376: IN
56377: IFFALSE 56398
// points := [ 120 , 30 , 80 ] ;
56379: LD_ADDR_VAR 0 9
56383: PUSH
56384: LD_INT 120
56386: PUSH
56387: LD_INT 30
56389: PUSH
56390: LD_INT 80
56392: PUSH
56393: EMPTY
56394: LIST
56395: LIST
56396: LIST
56397: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56398: LD_VAR 0 6
56402: PPUSH
56403: CALL_OW 264
56407: PUSH
56408: LD_INT 22
56410: PUSH
56411: EMPTY
56412: LIST
56413: IN
56414: IFFALSE 56435
// points := [ 40 , 1 , 1 ] ;
56416: LD_ADDR_VAR 0 9
56420: PUSH
56421: LD_INT 40
56423: PUSH
56424: LD_INT 1
56426: PUSH
56427: LD_INT 1
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: LIST
56434: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56435: LD_VAR 0 6
56439: PPUSH
56440: CALL_OW 264
56444: PUSH
56445: LD_INT 29
56447: PUSH
56448: EMPTY
56449: LIST
56450: IN
56451: IFFALSE 56472
// points := [ 70 , 200 , 400 ] ;
56453: LD_ADDR_VAR 0 9
56457: PUSH
56458: LD_INT 70
56460: PUSH
56461: LD_INT 200
56463: PUSH
56464: LD_INT 400
56466: PUSH
56467: EMPTY
56468: LIST
56469: LIST
56470: LIST
56471: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56472: LD_VAR 0 6
56476: PPUSH
56477: CALL_OW 264
56481: PUSH
56482: LD_INT 14
56484: PUSH
56485: LD_INT 53
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: IN
56492: IFFALSE 56513
// points := [ 40 , 10 , 20 ] ;
56494: LD_ADDR_VAR 0 9
56498: PUSH
56499: LD_INT 40
56501: PUSH
56502: LD_INT 10
56504: PUSH
56505: LD_INT 20
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: LIST
56512: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56513: LD_VAR 0 6
56517: PPUSH
56518: CALL_OW 264
56522: PUSH
56523: LD_INT 9
56525: PUSH
56526: EMPTY
56527: LIST
56528: IN
56529: IFFALSE 56550
// points := [ 5 , 70 , 20 ] ;
56531: LD_ADDR_VAR 0 9
56535: PUSH
56536: LD_INT 5
56538: PUSH
56539: LD_INT 70
56541: PUSH
56542: LD_INT 20
56544: PUSH
56545: EMPTY
56546: LIST
56547: LIST
56548: LIST
56549: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56550: LD_VAR 0 6
56554: PPUSH
56555: CALL_OW 264
56559: PUSH
56560: LD_INT 10
56562: PUSH
56563: EMPTY
56564: LIST
56565: IN
56566: IFFALSE 56587
// points := [ 35 , 110 , 70 ] ;
56568: LD_ADDR_VAR 0 9
56572: PUSH
56573: LD_INT 35
56575: PUSH
56576: LD_INT 110
56578: PUSH
56579: LD_INT 70
56581: PUSH
56582: EMPTY
56583: LIST
56584: LIST
56585: LIST
56586: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56587: LD_VAR 0 6
56591: PPUSH
56592: CALL_OW 265
56596: PUSH
56597: LD_INT 25
56599: EQUAL
56600: IFFALSE 56621
// points := [ 80 , 65 , 100 ] ;
56602: LD_ADDR_VAR 0 9
56606: PUSH
56607: LD_INT 80
56609: PUSH
56610: LD_INT 65
56612: PUSH
56613: LD_INT 100
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: LIST
56620: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56621: LD_VAR 0 6
56625: PPUSH
56626: CALL_OW 263
56630: PUSH
56631: LD_INT 1
56633: EQUAL
56634: IFFALSE 56669
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56636: LD_ADDR_VAR 0 10
56640: PUSH
56641: LD_VAR 0 10
56645: PUSH
56646: LD_VAR 0 6
56650: PPUSH
56651: CALL_OW 311
56655: PPUSH
56656: LD_INT 3
56658: PPUSH
56659: CALL_OW 259
56663: PUSH
56664: LD_INT 4
56666: MUL
56667: MUL
56668: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56669: LD_VAR 0 6
56673: PPUSH
56674: CALL_OW 263
56678: PUSH
56679: LD_INT 2
56681: EQUAL
56682: IFFALSE 56733
// begin j := IsControledBy ( i ) ;
56684: LD_ADDR_VAR 0 7
56688: PUSH
56689: LD_VAR 0 6
56693: PPUSH
56694: CALL_OW 312
56698: ST_TO_ADDR
// if j then
56699: LD_VAR 0 7
56703: IFFALSE 56733
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56705: LD_ADDR_VAR 0 10
56709: PUSH
56710: LD_VAR 0 10
56714: PUSH
56715: LD_VAR 0 7
56719: PPUSH
56720: LD_INT 3
56722: PPUSH
56723: CALL_OW 259
56727: PUSH
56728: LD_INT 3
56730: MUL
56731: MUL
56732: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56733: LD_VAR 0 6
56737: PPUSH
56738: CALL_OW 264
56742: PUSH
56743: LD_INT 5
56745: PUSH
56746: LD_INT 6
56748: PUSH
56749: LD_INT 46
56751: PUSH
56752: LD_INT 44
56754: PUSH
56755: LD_INT 47
56757: PUSH
56758: LD_INT 45
56760: PUSH
56761: LD_INT 28
56763: PUSH
56764: LD_INT 7
56766: PUSH
56767: LD_INT 27
56769: PUSH
56770: LD_INT 29
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: LIST
56777: LIST
56778: LIST
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: LIST
56784: IN
56785: PUSH
56786: LD_VAR 0 1
56790: PPUSH
56791: LD_INT 52
56793: PPUSH
56794: CALL_OW 321
56798: PUSH
56799: LD_INT 2
56801: EQUAL
56802: AND
56803: IFFALSE 56820
// bpoints := bpoints * 1.2 ;
56805: LD_ADDR_VAR 0 10
56809: PUSH
56810: LD_VAR 0 10
56814: PUSH
56815: LD_REAL  1.20000000000000E+0000
56818: MUL
56819: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56820: LD_VAR 0 6
56824: PPUSH
56825: CALL_OW 264
56829: PUSH
56830: LD_INT 6
56832: PUSH
56833: LD_INT 46
56835: PUSH
56836: LD_INT 47
56838: PUSH
56839: EMPTY
56840: LIST
56841: LIST
56842: LIST
56843: IN
56844: IFFALSE 56861
// bpoints := bpoints * 1.2 ;
56846: LD_ADDR_VAR 0 10
56850: PUSH
56851: LD_VAR 0 10
56855: PUSH
56856: LD_REAL  1.20000000000000E+0000
56859: MUL
56860: ST_TO_ADDR
// end ; unit_building :
56861: GO 56875
56863: LD_INT 3
56865: DOUBLE
56866: EQUAL
56867: IFTRUE 56871
56869: GO 56874
56871: POP
// ; end ;
56872: GO 56875
56874: POP
// for j = 1 to 3 do
56875: LD_ADDR_VAR 0 7
56879: PUSH
56880: DOUBLE
56881: LD_INT 1
56883: DEC
56884: ST_TO_ADDR
56885: LD_INT 3
56887: PUSH
56888: FOR_TO
56889: IFFALSE 56942
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56891: LD_ADDR_VAR 0 5
56895: PUSH
56896: LD_VAR 0 5
56900: PPUSH
56901: LD_VAR 0 7
56905: PPUSH
56906: LD_VAR 0 5
56910: PUSH
56911: LD_VAR 0 7
56915: ARRAY
56916: PUSH
56917: LD_VAR 0 9
56921: PUSH
56922: LD_VAR 0 7
56926: ARRAY
56927: PUSH
56928: LD_VAR 0 10
56932: MUL
56933: PLUS
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
56940: GO 56888
56942: POP
56943: POP
// end ;
56944: GO 55423
56946: POP
56947: POP
// result := Replace ( result , 4 , tmp ) ;
56948: LD_ADDR_VAR 0 5
56952: PUSH
56953: LD_VAR 0 5
56957: PPUSH
56958: LD_INT 4
56960: PPUSH
56961: LD_VAR 0 8
56965: PPUSH
56966: CALL_OW 1
56970: ST_TO_ADDR
// end ;
56971: LD_VAR 0 5
56975: RET
// export function DangerAtRange ( unit , range ) ; begin
56976: LD_INT 0
56978: PPUSH
// if not unit then
56979: LD_VAR 0 1
56983: NOT
56984: IFFALSE 56988
// exit ;
56986: GO 57033
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56988: LD_ADDR_VAR 0 3
56992: PUSH
56993: LD_VAR 0 1
56997: PPUSH
56998: CALL_OW 255
57002: PPUSH
57003: LD_VAR 0 1
57007: PPUSH
57008: CALL_OW 250
57012: PPUSH
57013: LD_VAR 0 1
57017: PPUSH
57018: CALL_OW 251
57022: PPUSH
57023: LD_VAR 0 2
57027: PPUSH
57028: CALL 55275 0 4
57032: ST_TO_ADDR
// end ;
57033: LD_VAR 0 3
57037: RET
// export function DangerInArea ( side , area ) ; begin
57038: LD_INT 0
57040: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57041: LD_ADDR_VAR 0 3
57045: PUSH
57046: LD_VAR 0 2
57050: PPUSH
57051: LD_INT 81
57053: PUSH
57054: LD_VAR 0 1
57058: PUSH
57059: EMPTY
57060: LIST
57061: LIST
57062: PPUSH
57063: CALL_OW 70
57067: ST_TO_ADDR
// end ;
57068: LD_VAR 0 3
57072: RET
// export function IsExtension ( b ) ; begin
57073: LD_INT 0
57075: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57076: LD_ADDR_VAR 0 2
57080: PUSH
57081: LD_VAR 0 1
57085: PUSH
57086: LD_INT 23
57088: PUSH
57089: LD_INT 20
57091: PUSH
57092: LD_INT 22
57094: PUSH
57095: LD_INT 17
57097: PUSH
57098: LD_INT 24
57100: PUSH
57101: LD_INT 21
57103: PUSH
57104: LD_INT 19
57106: PUSH
57107: LD_INT 16
57109: PUSH
57110: LD_INT 25
57112: PUSH
57113: LD_INT 18
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: LIST
57120: LIST
57121: LIST
57122: LIST
57123: LIST
57124: LIST
57125: LIST
57126: LIST
57127: IN
57128: ST_TO_ADDR
// end ;
57129: LD_VAR 0 2
57133: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57134: LD_INT 0
57136: PPUSH
57137: PPUSH
57138: PPUSH
// result := [ ] ;
57139: LD_ADDR_VAR 0 4
57143: PUSH
57144: EMPTY
57145: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57146: LD_ADDR_VAR 0 5
57150: PUSH
57151: LD_VAR 0 2
57155: PPUSH
57156: LD_INT 21
57158: PUSH
57159: LD_INT 3
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: PPUSH
57166: CALL_OW 70
57170: ST_TO_ADDR
// if not tmp then
57171: LD_VAR 0 5
57175: NOT
57176: IFFALSE 57180
// exit ;
57178: GO 57244
// if checkLink then
57180: LD_VAR 0 3
57184: IFFALSE 57234
// begin for i in tmp do
57186: LD_ADDR_VAR 0 6
57190: PUSH
57191: LD_VAR 0 5
57195: PUSH
57196: FOR_IN
57197: IFFALSE 57232
// if GetBase ( i ) <> base then
57199: LD_VAR 0 6
57203: PPUSH
57204: CALL_OW 274
57208: PUSH
57209: LD_VAR 0 1
57213: NONEQUAL
57214: IFFALSE 57230
// ComLinkToBase ( base , i ) ;
57216: LD_VAR 0 1
57220: PPUSH
57221: LD_VAR 0 6
57225: PPUSH
57226: CALL_OW 169
57230: GO 57196
57232: POP
57233: POP
// end ; result := tmp ;
57234: LD_ADDR_VAR 0 4
57238: PUSH
57239: LD_VAR 0 5
57243: ST_TO_ADDR
// end ;
57244: LD_VAR 0 4
57248: RET
// export function ComComplete ( units , b ) ; var i ; begin
57249: LD_INT 0
57251: PPUSH
57252: PPUSH
// if not units then
57253: LD_VAR 0 1
57257: NOT
57258: IFFALSE 57262
// exit ;
57260: GO 57352
// for i in units do
57262: LD_ADDR_VAR 0 4
57266: PUSH
57267: LD_VAR 0 1
57271: PUSH
57272: FOR_IN
57273: IFFALSE 57350
// if BuildingStatus ( b ) = bs_build then
57275: LD_VAR 0 2
57279: PPUSH
57280: CALL_OW 461
57284: PUSH
57285: LD_INT 1
57287: EQUAL
57288: IFFALSE 57348
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57290: LD_VAR 0 4
57294: PPUSH
57295: LD_STRING h
57297: PUSH
57298: LD_VAR 0 2
57302: PPUSH
57303: CALL_OW 250
57307: PUSH
57308: LD_VAR 0 2
57312: PPUSH
57313: CALL_OW 251
57317: PUSH
57318: LD_VAR 0 2
57322: PUSH
57323: LD_INT 0
57325: PUSH
57326: LD_INT 0
57328: PUSH
57329: LD_INT 0
57331: PUSH
57332: EMPTY
57333: LIST
57334: LIST
57335: LIST
57336: LIST
57337: LIST
57338: LIST
57339: LIST
57340: PUSH
57341: EMPTY
57342: LIST
57343: PPUSH
57344: CALL_OW 446
57348: GO 57272
57350: POP
57351: POP
// end ;
57352: LD_VAR 0 3
57356: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57357: LD_INT 0
57359: PPUSH
57360: PPUSH
57361: PPUSH
57362: PPUSH
57363: PPUSH
57364: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57365: LD_VAR 0 1
57369: NOT
57370: PUSH
57371: LD_VAR 0 1
57375: PPUSH
57376: CALL_OW 263
57380: PUSH
57381: LD_INT 2
57383: NONEQUAL
57384: OR
57385: IFFALSE 57389
// exit ;
57387: GO 57705
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57389: LD_ADDR_VAR 0 6
57393: PUSH
57394: LD_INT 22
57396: PUSH
57397: LD_VAR 0 1
57401: PPUSH
57402: CALL_OW 255
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: LD_INT 2
57413: PUSH
57414: LD_INT 30
57416: PUSH
57417: LD_INT 36
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: PUSH
57424: LD_INT 34
57426: PUSH
57427: LD_INT 31
57429: PUSH
57430: EMPTY
57431: LIST
57432: LIST
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: LIST
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PPUSH
57443: CALL_OW 69
57447: ST_TO_ADDR
// if not tmp then
57448: LD_VAR 0 6
57452: NOT
57453: IFFALSE 57457
// exit ;
57455: GO 57705
// result := [ ] ;
57457: LD_ADDR_VAR 0 2
57461: PUSH
57462: EMPTY
57463: ST_TO_ADDR
// for i in tmp do
57464: LD_ADDR_VAR 0 3
57468: PUSH
57469: LD_VAR 0 6
57473: PUSH
57474: FOR_IN
57475: IFFALSE 57546
// begin t := UnitsInside ( i ) ;
57477: LD_ADDR_VAR 0 4
57481: PUSH
57482: LD_VAR 0 3
57486: PPUSH
57487: CALL_OW 313
57491: ST_TO_ADDR
// if t then
57492: LD_VAR 0 4
57496: IFFALSE 57544
// for j in t do
57498: LD_ADDR_VAR 0 7
57502: PUSH
57503: LD_VAR 0 4
57507: PUSH
57508: FOR_IN
57509: IFFALSE 57542
// result := Replace ( result , result + 1 , j ) ;
57511: LD_ADDR_VAR 0 2
57515: PUSH
57516: LD_VAR 0 2
57520: PPUSH
57521: LD_VAR 0 2
57525: PUSH
57526: LD_INT 1
57528: PLUS
57529: PPUSH
57530: LD_VAR 0 7
57534: PPUSH
57535: CALL_OW 1
57539: ST_TO_ADDR
57540: GO 57508
57542: POP
57543: POP
// end ;
57544: GO 57474
57546: POP
57547: POP
// if not result then
57548: LD_VAR 0 2
57552: NOT
57553: IFFALSE 57557
// exit ;
57555: GO 57705
// mech := result [ 1 ] ;
57557: LD_ADDR_VAR 0 5
57561: PUSH
57562: LD_VAR 0 2
57566: PUSH
57567: LD_INT 1
57569: ARRAY
57570: ST_TO_ADDR
// if result > 1 then
57571: LD_VAR 0 2
57575: PUSH
57576: LD_INT 1
57578: GREATER
57579: IFFALSE 57691
// begin for i = 2 to result do
57581: LD_ADDR_VAR 0 3
57585: PUSH
57586: DOUBLE
57587: LD_INT 2
57589: DEC
57590: ST_TO_ADDR
57591: LD_VAR 0 2
57595: PUSH
57596: FOR_TO
57597: IFFALSE 57689
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57599: LD_ADDR_VAR 0 4
57603: PUSH
57604: LD_VAR 0 2
57608: PUSH
57609: LD_VAR 0 3
57613: ARRAY
57614: PPUSH
57615: LD_INT 3
57617: PPUSH
57618: CALL_OW 259
57622: PUSH
57623: LD_VAR 0 2
57627: PUSH
57628: LD_VAR 0 3
57632: ARRAY
57633: PPUSH
57634: CALL_OW 432
57638: MINUS
57639: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57640: LD_VAR 0 4
57644: PUSH
57645: LD_VAR 0 5
57649: PPUSH
57650: LD_INT 3
57652: PPUSH
57653: CALL_OW 259
57657: PUSH
57658: LD_VAR 0 5
57662: PPUSH
57663: CALL_OW 432
57667: MINUS
57668: GREATEREQUAL
57669: IFFALSE 57687
// mech := result [ i ] ;
57671: LD_ADDR_VAR 0 5
57675: PUSH
57676: LD_VAR 0 2
57680: PUSH
57681: LD_VAR 0 3
57685: ARRAY
57686: ST_TO_ADDR
// end ;
57687: GO 57596
57689: POP
57690: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57691: LD_VAR 0 1
57695: PPUSH
57696: LD_VAR 0 5
57700: PPUSH
57701: CALL_OW 135
// end ;
57705: LD_VAR 0 2
57709: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57710: LD_INT 0
57712: PPUSH
57713: PPUSH
57714: PPUSH
57715: PPUSH
57716: PPUSH
57717: PPUSH
57718: PPUSH
57719: PPUSH
57720: PPUSH
57721: PPUSH
57722: PPUSH
57723: PPUSH
57724: PPUSH
// result := [ ] ;
57725: LD_ADDR_VAR 0 7
57729: PUSH
57730: EMPTY
57731: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57732: LD_VAR 0 1
57736: PPUSH
57737: CALL_OW 266
57741: PUSH
57742: LD_INT 0
57744: PUSH
57745: LD_INT 1
57747: PUSH
57748: EMPTY
57749: LIST
57750: LIST
57751: IN
57752: NOT
57753: IFFALSE 57757
// exit ;
57755: GO 59391
// if name then
57757: LD_VAR 0 3
57761: IFFALSE 57777
// SetBName ( base_dep , name ) ;
57763: LD_VAR 0 1
57767: PPUSH
57768: LD_VAR 0 3
57772: PPUSH
57773: CALL_OW 500
// base := GetBase ( base_dep ) ;
57777: LD_ADDR_VAR 0 15
57781: PUSH
57782: LD_VAR 0 1
57786: PPUSH
57787: CALL_OW 274
57791: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57792: LD_ADDR_VAR 0 16
57796: PUSH
57797: LD_VAR 0 1
57801: PPUSH
57802: CALL_OW 255
57806: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57807: LD_ADDR_VAR 0 17
57811: PUSH
57812: LD_VAR 0 1
57816: PPUSH
57817: CALL_OW 248
57821: ST_TO_ADDR
// if sources then
57822: LD_VAR 0 5
57826: IFFALSE 57873
// for i = 1 to 3 do
57828: LD_ADDR_VAR 0 8
57832: PUSH
57833: DOUBLE
57834: LD_INT 1
57836: DEC
57837: ST_TO_ADDR
57838: LD_INT 3
57840: PUSH
57841: FOR_TO
57842: IFFALSE 57871
// AddResourceType ( base , i , sources [ i ] ) ;
57844: LD_VAR 0 15
57848: PPUSH
57849: LD_VAR 0 8
57853: PPUSH
57854: LD_VAR 0 5
57858: PUSH
57859: LD_VAR 0 8
57863: ARRAY
57864: PPUSH
57865: CALL_OW 276
57869: GO 57841
57871: POP
57872: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57873: LD_ADDR_VAR 0 18
57877: PUSH
57878: LD_VAR 0 15
57882: PPUSH
57883: LD_VAR 0 2
57887: PPUSH
57888: LD_INT 1
57890: PPUSH
57891: CALL 57134 0 3
57895: ST_TO_ADDR
// InitHc ;
57896: CALL_OW 19
// InitUc ;
57900: CALL_OW 18
// uc_side := side ;
57904: LD_ADDR_OWVAR 20
57908: PUSH
57909: LD_VAR 0 16
57913: ST_TO_ADDR
// uc_nation := nation ;
57914: LD_ADDR_OWVAR 21
57918: PUSH
57919: LD_VAR 0 17
57923: ST_TO_ADDR
// if buildings then
57924: LD_VAR 0 18
57928: IFFALSE 59250
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57930: LD_ADDR_VAR 0 19
57934: PUSH
57935: LD_VAR 0 18
57939: PPUSH
57940: LD_INT 2
57942: PUSH
57943: LD_INT 30
57945: PUSH
57946: LD_INT 29
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: PUSH
57953: LD_INT 30
57955: PUSH
57956: LD_INT 30
57958: PUSH
57959: EMPTY
57960: LIST
57961: LIST
57962: PUSH
57963: EMPTY
57964: LIST
57965: LIST
57966: LIST
57967: PPUSH
57968: CALL_OW 72
57972: ST_TO_ADDR
// if tmp then
57973: LD_VAR 0 19
57977: IFFALSE 58025
// for i in tmp do
57979: LD_ADDR_VAR 0 8
57983: PUSH
57984: LD_VAR 0 19
57988: PUSH
57989: FOR_IN
57990: IFFALSE 58023
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57992: LD_VAR 0 8
57996: PPUSH
57997: CALL_OW 250
58001: PPUSH
58002: LD_VAR 0 8
58006: PPUSH
58007: CALL_OW 251
58011: PPUSH
58012: LD_VAR 0 16
58016: PPUSH
58017: CALL_OW 441
58021: GO 57989
58023: POP
58024: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58025: LD_VAR 0 18
58029: PPUSH
58030: LD_INT 2
58032: PUSH
58033: LD_INT 30
58035: PUSH
58036: LD_INT 32
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: PUSH
58043: LD_INT 30
58045: PUSH
58046: LD_INT 33
58048: PUSH
58049: EMPTY
58050: LIST
58051: LIST
58052: PUSH
58053: EMPTY
58054: LIST
58055: LIST
58056: LIST
58057: PPUSH
58058: CALL_OW 72
58062: IFFALSE 58150
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58064: LD_ADDR_VAR 0 8
58068: PUSH
58069: LD_VAR 0 18
58073: PPUSH
58074: LD_INT 2
58076: PUSH
58077: LD_INT 30
58079: PUSH
58080: LD_INT 32
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: PUSH
58087: LD_INT 30
58089: PUSH
58090: LD_INT 33
58092: PUSH
58093: EMPTY
58094: LIST
58095: LIST
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: LIST
58101: PPUSH
58102: CALL_OW 72
58106: PUSH
58107: FOR_IN
58108: IFFALSE 58148
// begin if not GetBWeapon ( i ) then
58110: LD_VAR 0 8
58114: PPUSH
58115: CALL_OW 269
58119: NOT
58120: IFFALSE 58146
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58122: LD_VAR 0 8
58126: PPUSH
58127: LD_VAR 0 8
58131: PPUSH
58132: LD_VAR 0 2
58136: PPUSH
58137: CALL 59396 0 2
58141: PPUSH
58142: CALL_OW 431
// end ;
58146: GO 58107
58148: POP
58149: POP
// end ; for i = 1 to personel do
58150: LD_ADDR_VAR 0 8
58154: PUSH
58155: DOUBLE
58156: LD_INT 1
58158: DEC
58159: ST_TO_ADDR
58160: LD_VAR 0 6
58164: PUSH
58165: FOR_TO
58166: IFFALSE 59230
// begin if i > 4 then
58168: LD_VAR 0 8
58172: PUSH
58173: LD_INT 4
58175: GREATER
58176: IFFALSE 58180
// break ;
58178: GO 59230
// case i of 1 :
58180: LD_VAR 0 8
58184: PUSH
58185: LD_INT 1
58187: DOUBLE
58188: EQUAL
58189: IFTRUE 58193
58191: GO 58273
58193: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58194: LD_ADDR_VAR 0 12
58198: PUSH
58199: LD_VAR 0 18
58203: PPUSH
58204: LD_INT 22
58206: PUSH
58207: LD_VAR 0 16
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: LD_INT 58
58218: PUSH
58219: EMPTY
58220: LIST
58221: PUSH
58222: LD_INT 2
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: LD_INT 32
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: LD_INT 30
58237: PUSH
58238: LD_INT 4
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: PUSH
58245: LD_INT 30
58247: PUSH
58248: LD_INT 5
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: PUSH
58255: EMPTY
58256: LIST
58257: LIST
58258: LIST
58259: LIST
58260: PUSH
58261: EMPTY
58262: LIST
58263: LIST
58264: LIST
58265: PPUSH
58266: CALL_OW 72
58270: ST_TO_ADDR
58271: GO 58495
58273: LD_INT 2
58275: DOUBLE
58276: EQUAL
58277: IFTRUE 58281
58279: GO 58343
58281: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58282: LD_ADDR_VAR 0 12
58286: PUSH
58287: LD_VAR 0 18
58291: PPUSH
58292: LD_INT 22
58294: PUSH
58295: LD_VAR 0 16
58299: PUSH
58300: EMPTY
58301: LIST
58302: LIST
58303: PUSH
58304: LD_INT 2
58306: PUSH
58307: LD_INT 30
58309: PUSH
58310: LD_INT 0
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: LD_INT 30
58319: PUSH
58320: LD_INT 1
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: PUSH
58327: EMPTY
58328: LIST
58329: LIST
58330: LIST
58331: PUSH
58332: EMPTY
58333: LIST
58334: LIST
58335: PPUSH
58336: CALL_OW 72
58340: ST_TO_ADDR
58341: GO 58495
58343: LD_INT 3
58345: DOUBLE
58346: EQUAL
58347: IFTRUE 58351
58349: GO 58413
58351: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58352: LD_ADDR_VAR 0 12
58356: PUSH
58357: LD_VAR 0 18
58361: PPUSH
58362: LD_INT 22
58364: PUSH
58365: LD_VAR 0 16
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 2
58376: PUSH
58377: LD_INT 30
58379: PUSH
58380: LD_INT 2
58382: PUSH
58383: EMPTY
58384: LIST
58385: LIST
58386: PUSH
58387: LD_INT 30
58389: PUSH
58390: LD_INT 3
58392: PUSH
58393: EMPTY
58394: LIST
58395: LIST
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: LIST
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: PPUSH
58406: CALL_OW 72
58410: ST_TO_ADDR
58411: GO 58495
58413: LD_INT 4
58415: DOUBLE
58416: EQUAL
58417: IFTRUE 58421
58419: GO 58494
58421: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58422: LD_ADDR_VAR 0 12
58426: PUSH
58427: LD_VAR 0 18
58431: PPUSH
58432: LD_INT 22
58434: PUSH
58435: LD_VAR 0 16
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: PUSH
58444: LD_INT 2
58446: PUSH
58447: LD_INT 30
58449: PUSH
58450: LD_INT 6
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: PUSH
58457: LD_INT 30
58459: PUSH
58460: LD_INT 7
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PUSH
58467: LD_INT 30
58469: PUSH
58470: LD_INT 8
58472: PUSH
58473: EMPTY
58474: LIST
58475: LIST
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: LIST
58481: LIST
58482: PUSH
58483: EMPTY
58484: LIST
58485: LIST
58486: PPUSH
58487: CALL_OW 72
58491: ST_TO_ADDR
58492: GO 58495
58494: POP
// if i = 1 then
58495: LD_VAR 0 8
58499: PUSH
58500: LD_INT 1
58502: EQUAL
58503: IFFALSE 58614
// begin tmp := [ ] ;
58505: LD_ADDR_VAR 0 19
58509: PUSH
58510: EMPTY
58511: ST_TO_ADDR
// for j in f do
58512: LD_ADDR_VAR 0 9
58516: PUSH
58517: LD_VAR 0 12
58521: PUSH
58522: FOR_IN
58523: IFFALSE 58596
// if GetBType ( j ) = b_bunker then
58525: LD_VAR 0 9
58529: PPUSH
58530: CALL_OW 266
58534: PUSH
58535: LD_INT 32
58537: EQUAL
58538: IFFALSE 58565
// tmp := Insert ( tmp , 1 , j ) else
58540: LD_ADDR_VAR 0 19
58544: PUSH
58545: LD_VAR 0 19
58549: PPUSH
58550: LD_INT 1
58552: PPUSH
58553: LD_VAR 0 9
58557: PPUSH
58558: CALL_OW 2
58562: ST_TO_ADDR
58563: GO 58594
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58565: LD_ADDR_VAR 0 19
58569: PUSH
58570: LD_VAR 0 19
58574: PPUSH
58575: LD_VAR 0 19
58579: PUSH
58580: LD_INT 1
58582: PLUS
58583: PPUSH
58584: LD_VAR 0 9
58588: PPUSH
58589: CALL_OW 2
58593: ST_TO_ADDR
58594: GO 58522
58596: POP
58597: POP
// if tmp then
58598: LD_VAR 0 19
58602: IFFALSE 58614
// f := tmp ;
58604: LD_ADDR_VAR 0 12
58608: PUSH
58609: LD_VAR 0 19
58613: ST_TO_ADDR
// end ; x := personel [ i ] ;
58614: LD_ADDR_VAR 0 13
58618: PUSH
58619: LD_VAR 0 6
58623: PUSH
58624: LD_VAR 0 8
58628: ARRAY
58629: ST_TO_ADDR
// if x = - 1 then
58630: LD_VAR 0 13
58634: PUSH
58635: LD_INT 1
58637: NEG
58638: EQUAL
58639: IFFALSE 58848
// begin for j in f do
58641: LD_ADDR_VAR 0 9
58645: PUSH
58646: LD_VAR 0 12
58650: PUSH
58651: FOR_IN
58652: IFFALSE 58844
// repeat InitHc ;
58654: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58658: LD_VAR 0 9
58662: PPUSH
58663: CALL_OW 266
58667: PUSH
58668: LD_INT 5
58670: EQUAL
58671: IFFALSE 58741
// begin if UnitsInside ( j ) < 3 then
58673: LD_VAR 0 9
58677: PPUSH
58678: CALL_OW 313
58682: PUSH
58683: LD_INT 3
58685: LESS
58686: IFFALSE 58722
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58688: LD_INT 0
58690: PPUSH
58691: LD_INT 5
58693: PUSH
58694: LD_INT 8
58696: PUSH
58697: LD_INT 9
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: LIST
58704: PUSH
58705: LD_VAR 0 17
58709: ARRAY
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: CALL_OW 380
58720: GO 58739
// PrepareHuman ( false , i , skill ) ;
58722: LD_INT 0
58724: PPUSH
58725: LD_VAR 0 8
58729: PPUSH
58730: LD_VAR 0 4
58734: PPUSH
58735: CALL_OW 380
// end else
58739: GO 58758
// PrepareHuman ( false , i , skill ) ;
58741: LD_INT 0
58743: PPUSH
58744: LD_VAR 0 8
58748: PPUSH
58749: LD_VAR 0 4
58753: PPUSH
58754: CALL_OW 380
// un := CreateHuman ;
58758: LD_ADDR_VAR 0 14
58762: PUSH
58763: CALL_OW 44
58767: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58768: LD_ADDR_VAR 0 7
58772: PUSH
58773: LD_VAR 0 7
58777: PPUSH
58778: LD_INT 1
58780: PPUSH
58781: LD_VAR 0 14
58785: PPUSH
58786: CALL_OW 2
58790: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58791: LD_VAR 0 14
58795: PPUSH
58796: LD_VAR 0 9
58800: PPUSH
58801: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58805: LD_VAR 0 9
58809: PPUSH
58810: CALL_OW 313
58814: PUSH
58815: LD_INT 6
58817: EQUAL
58818: PUSH
58819: LD_VAR 0 9
58823: PPUSH
58824: CALL_OW 266
58828: PUSH
58829: LD_INT 32
58831: PUSH
58832: LD_INT 31
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: IN
58839: OR
58840: IFFALSE 58654
58842: GO 58651
58844: POP
58845: POP
// end else
58846: GO 59228
// for j = 1 to x do
58848: LD_ADDR_VAR 0 9
58852: PUSH
58853: DOUBLE
58854: LD_INT 1
58856: DEC
58857: ST_TO_ADDR
58858: LD_VAR 0 13
58862: PUSH
58863: FOR_TO
58864: IFFALSE 59226
// begin InitHc ;
58866: CALL_OW 19
// if not f then
58870: LD_VAR 0 12
58874: NOT
58875: IFFALSE 58964
// begin PrepareHuman ( false , i , skill ) ;
58877: LD_INT 0
58879: PPUSH
58880: LD_VAR 0 8
58884: PPUSH
58885: LD_VAR 0 4
58889: PPUSH
58890: CALL_OW 380
// un := CreateHuman ;
58894: LD_ADDR_VAR 0 14
58898: PUSH
58899: CALL_OW 44
58903: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58904: LD_ADDR_VAR 0 7
58908: PUSH
58909: LD_VAR 0 7
58913: PPUSH
58914: LD_INT 1
58916: PPUSH
58917: LD_VAR 0 14
58921: PPUSH
58922: CALL_OW 2
58926: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58927: LD_VAR 0 14
58931: PPUSH
58932: LD_VAR 0 1
58936: PPUSH
58937: CALL_OW 250
58941: PPUSH
58942: LD_VAR 0 1
58946: PPUSH
58947: CALL_OW 251
58951: PPUSH
58952: LD_INT 10
58954: PPUSH
58955: LD_INT 0
58957: PPUSH
58958: CALL_OW 50
// continue ;
58962: GO 58863
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58964: LD_VAR 0 12
58968: PUSH
58969: LD_INT 1
58971: ARRAY
58972: PPUSH
58973: CALL_OW 313
58977: PUSH
58978: LD_VAR 0 12
58982: PUSH
58983: LD_INT 1
58985: ARRAY
58986: PPUSH
58987: CALL_OW 266
58991: PUSH
58992: LD_INT 32
58994: PUSH
58995: LD_INT 31
58997: PUSH
58998: EMPTY
58999: LIST
59000: LIST
59001: IN
59002: AND
59003: PUSH
59004: LD_VAR 0 12
59008: PUSH
59009: LD_INT 1
59011: ARRAY
59012: PPUSH
59013: CALL_OW 313
59017: PUSH
59018: LD_INT 6
59020: EQUAL
59021: OR
59022: IFFALSE 59042
// f := Delete ( f , 1 ) ;
59024: LD_ADDR_VAR 0 12
59028: PUSH
59029: LD_VAR 0 12
59033: PPUSH
59034: LD_INT 1
59036: PPUSH
59037: CALL_OW 3
59041: ST_TO_ADDR
// if not f then
59042: LD_VAR 0 12
59046: NOT
59047: IFFALSE 59065
// begin x := x + 2 ;
59049: LD_ADDR_VAR 0 13
59053: PUSH
59054: LD_VAR 0 13
59058: PUSH
59059: LD_INT 2
59061: PLUS
59062: ST_TO_ADDR
// continue ;
59063: GO 58863
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59065: LD_VAR 0 12
59069: PUSH
59070: LD_INT 1
59072: ARRAY
59073: PPUSH
59074: CALL_OW 266
59078: PUSH
59079: LD_INT 5
59081: EQUAL
59082: IFFALSE 59156
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59084: LD_VAR 0 12
59088: PUSH
59089: LD_INT 1
59091: ARRAY
59092: PPUSH
59093: CALL_OW 313
59097: PUSH
59098: LD_INT 3
59100: LESS
59101: IFFALSE 59137
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59103: LD_INT 0
59105: PPUSH
59106: LD_INT 5
59108: PUSH
59109: LD_INT 8
59111: PUSH
59112: LD_INT 9
59114: PUSH
59115: EMPTY
59116: LIST
59117: LIST
59118: LIST
59119: PUSH
59120: LD_VAR 0 17
59124: ARRAY
59125: PPUSH
59126: LD_VAR 0 4
59130: PPUSH
59131: CALL_OW 380
59135: GO 59154
// PrepareHuman ( false , i , skill ) ;
59137: LD_INT 0
59139: PPUSH
59140: LD_VAR 0 8
59144: PPUSH
59145: LD_VAR 0 4
59149: PPUSH
59150: CALL_OW 380
// end else
59154: GO 59173
// PrepareHuman ( false , i , skill ) ;
59156: LD_INT 0
59158: PPUSH
59159: LD_VAR 0 8
59163: PPUSH
59164: LD_VAR 0 4
59168: PPUSH
59169: CALL_OW 380
// un := CreateHuman ;
59173: LD_ADDR_VAR 0 14
59177: PUSH
59178: CALL_OW 44
59182: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59183: LD_ADDR_VAR 0 7
59187: PUSH
59188: LD_VAR 0 7
59192: PPUSH
59193: LD_INT 1
59195: PPUSH
59196: LD_VAR 0 14
59200: PPUSH
59201: CALL_OW 2
59205: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59206: LD_VAR 0 14
59210: PPUSH
59211: LD_VAR 0 12
59215: PUSH
59216: LD_INT 1
59218: ARRAY
59219: PPUSH
59220: CALL_OW 52
// end ;
59224: GO 58863
59226: POP
59227: POP
// end ;
59228: GO 58165
59230: POP
59231: POP
// result := result ^ buildings ;
59232: LD_ADDR_VAR 0 7
59236: PUSH
59237: LD_VAR 0 7
59241: PUSH
59242: LD_VAR 0 18
59246: ADD
59247: ST_TO_ADDR
// end else
59248: GO 59391
// begin for i = 1 to personel do
59250: LD_ADDR_VAR 0 8
59254: PUSH
59255: DOUBLE
59256: LD_INT 1
59258: DEC
59259: ST_TO_ADDR
59260: LD_VAR 0 6
59264: PUSH
59265: FOR_TO
59266: IFFALSE 59389
// begin if i > 4 then
59268: LD_VAR 0 8
59272: PUSH
59273: LD_INT 4
59275: GREATER
59276: IFFALSE 59280
// break ;
59278: GO 59389
// x := personel [ i ] ;
59280: LD_ADDR_VAR 0 13
59284: PUSH
59285: LD_VAR 0 6
59289: PUSH
59290: LD_VAR 0 8
59294: ARRAY
59295: ST_TO_ADDR
// if x = - 1 then
59296: LD_VAR 0 13
59300: PUSH
59301: LD_INT 1
59303: NEG
59304: EQUAL
59305: IFFALSE 59309
// continue ;
59307: GO 59265
// PrepareHuman ( false , i , skill ) ;
59309: LD_INT 0
59311: PPUSH
59312: LD_VAR 0 8
59316: PPUSH
59317: LD_VAR 0 4
59321: PPUSH
59322: CALL_OW 380
// un := CreateHuman ;
59326: LD_ADDR_VAR 0 14
59330: PUSH
59331: CALL_OW 44
59335: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59336: LD_VAR 0 14
59340: PPUSH
59341: LD_VAR 0 1
59345: PPUSH
59346: CALL_OW 250
59350: PPUSH
59351: LD_VAR 0 1
59355: PPUSH
59356: CALL_OW 251
59360: PPUSH
59361: LD_INT 10
59363: PPUSH
59364: LD_INT 0
59366: PPUSH
59367: CALL_OW 50
// result := result ^ un ;
59371: LD_ADDR_VAR 0 7
59375: PUSH
59376: LD_VAR 0 7
59380: PUSH
59381: LD_VAR 0 14
59385: ADD
59386: ST_TO_ADDR
// end ;
59387: GO 59265
59389: POP
59390: POP
// end ; end ;
59391: LD_VAR 0 7
59395: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59396: LD_INT 0
59398: PPUSH
59399: PPUSH
59400: PPUSH
59401: PPUSH
59402: PPUSH
59403: PPUSH
59404: PPUSH
59405: PPUSH
59406: PPUSH
59407: PPUSH
59408: PPUSH
59409: PPUSH
59410: PPUSH
59411: PPUSH
59412: PPUSH
59413: PPUSH
// result := false ;
59414: LD_ADDR_VAR 0 3
59418: PUSH
59419: LD_INT 0
59421: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59422: LD_VAR 0 1
59426: NOT
59427: PUSH
59428: LD_VAR 0 1
59432: PPUSH
59433: CALL_OW 266
59437: PUSH
59438: LD_INT 32
59440: PUSH
59441: LD_INT 33
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: IN
59448: NOT
59449: OR
59450: IFFALSE 59454
// exit ;
59452: GO 60563
// nat := GetNation ( tower ) ;
59454: LD_ADDR_VAR 0 12
59458: PUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: CALL_OW 248
59468: ST_TO_ADDR
// side := GetSide ( tower ) ;
59469: LD_ADDR_VAR 0 16
59473: PUSH
59474: LD_VAR 0 1
59478: PPUSH
59479: CALL_OW 255
59483: ST_TO_ADDR
// x := GetX ( tower ) ;
59484: LD_ADDR_VAR 0 10
59488: PUSH
59489: LD_VAR 0 1
59493: PPUSH
59494: CALL_OW 250
59498: ST_TO_ADDR
// y := GetY ( tower ) ;
59499: LD_ADDR_VAR 0 11
59503: PUSH
59504: LD_VAR 0 1
59508: PPUSH
59509: CALL_OW 251
59513: ST_TO_ADDR
// if not x or not y then
59514: LD_VAR 0 10
59518: NOT
59519: PUSH
59520: LD_VAR 0 11
59524: NOT
59525: OR
59526: IFFALSE 59530
// exit ;
59528: GO 60563
// weapon := 0 ;
59530: LD_ADDR_VAR 0 18
59534: PUSH
59535: LD_INT 0
59537: ST_TO_ADDR
// fac_list := [ ] ;
59538: LD_ADDR_VAR 0 17
59542: PUSH
59543: EMPTY
59544: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59545: LD_ADDR_VAR 0 6
59549: PUSH
59550: LD_VAR 0 1
59554: PPUSH
59555: CALL_OW 274
59559: PPUSH
59560: LD_VAR 0 2
59564: PPUSH
59565: LD_INT 0
59567: PPUSH
59568: CALL 57134 0 3
59572: PPUSH
59573: LD_INT 30
59575: PUSH
59576: LD_INT 3
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: PPUSH
59583: CALL_OW 72
59587: ST_TO_ADDR
// if not factories then
59588: LD_VAR 0 6
59592: NOT
59593: IFFALSE 59597
// exit ;
59595: GO 60563
// for i in factories do
59597: LD_ADDR_VAR 0 8
59601: PUSH
59602: LD_VAR 0 6
59606: PUSH
59607: FOR_IN
59608: IFFALSE 59633
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59610: LD_ADDR_VAR 0 17
59614: PUSH
59615: LD_VAR 0 17
59619: PUSH
59620: LD_VAR 0 8
59624: PPUSH
59625: CALL_OW 478
59629: UNION
59630: ST_TO_ADDR
59631: GO 59607
59633: POP
59634: POP
// if not fac_list then
59635: LD_VAR 0 17
59639: NOT
59640: IFFALSE 59644
// exit ;
59642: GO 60563
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59644: LD_ADDR_VAR 0 5
59648: PUSH
59649: LD_INT 4
59651: PUSH
59652: LD_INT 5
59654: PUSH
59655: LD_INT 9
59657: PUSH
59658: LD_INT 10
59660: PUSH
59661: LD_INT 6
59663: PUSH
59664: LD_INT 7
59666: PUSH
59667: LD_INT 11
59669: PUSH
59670: EMPTY
59671: LIST
59672: LIST
59673: LIST
59674: LIST
59675: LIST
59676: LIST
59677: LIST
59678: PUSH
59679: LD_INT 27
59681: PUSH
59682: LD_INT 28
59684: PUSH
59685: LD_INT 26
59687: PUSH
59688: LD_INT 30
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: LIST
59695: LIST
59696: PUSH
59697: LD_INT 43
59699: PUSH
59700: LD_INT 44
59702: PUSH
59703: LD_INT 46
59705: PUSH
59706: LD_INT 45
59708: PUSH
59709: LD_INT 47
59711: PUSH
59712: LD_INT 49
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: LIST
59719: LIST
59720: LIST
59721: LIST
59722: PUSH
59723: EMPTY
59724: LIST
59725: LIST
59726: LIST
59727: PUSH
59728: LD_VAR 0 12
59732: ARRAY
59733: ST_TO_ADDR
// list := list isect fac_list ;
59734: LD_ADDR_VAR 0 5
59738: PUSH
59739: LD_VAR 0 5
59743: PUSH
59744: LD_VAR 0 17
59748: ISECT
59749: ST_TO_ADDR
// if not list then
59750: LD_VAR 0 5
59754: NOT
59755: IFFALSE 59759
// exit ;
59757: GO 60563
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59759: LD_VAR 0 12
59763: PUSH
59764: LD_INT 3
59766: EQUAL
59767: PUSH
59768: LD_INT 49
59770: PUSH
59771: LD_VAR 0 5
59775: IN
59776: AND
59777: PUSH
59778: LD_INT 31
59780: PPUSH
59781: LD_VAR 0 16
59785: PPUSH
59786: CALL_OW 321
59790: PUSH
59791: LD_INT 2
59793: EQUAL
59794: AND
59795: IFFALSE 59855
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59797: LD_INT 22
59799: PUSH
59800: LD_VAR 0 16
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: PUSH
59809: LD_INT 35
59811: PUSH
59812: LD_INT 49
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: PUSH
59819: LD_INT 91
59821: PUSH
59822: LD_VAR 0 1
59826: PUSH
59827: LD_INT 10
59829: PUSH
59830: EMPTY
59831: LIST
59832: LIST
59833: LIST
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: LIST
59839: PPUSH
59840: CALL_OW 69
59844: NOT
59845: IFFALSE 59855
// weapon := ru_time_lapser ;
59847: LD_ADDR_VAR 0 18
59851: PUSH
59852: LD_INT 49
59854: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59855: LD_VAR 0 12
59859: PUSH
59860: LD_INT 1
59862: PUSH
59863: LD_INT 2
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: IN
59870: PUSH
59871: LD_INT 11
59873: PUSH
59874: LD_VAR 0 5
59878: IN
59879: PUSH
59880: LD_INT 30
59882: PUSH
59883: LD_VAR 0 5
59887: IN
59888: OR
59889: AND
59890: PUSH
59891: LD_INT 6
59893: PPUSH
59894: LD_VAR 0 16
59898: PPUSH
59899: CALL_OW 321
59903: PUSH
59904: LD_INT 2
59906: EQUAL
59907: AND
59908: IFFALSE 60073
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59910: LD_INT 22
59912: PUSH
59913: LD_VAR 0 16
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: PUSH
59922: LD_INT 2
59924: PUSH
59925: LD_INT 35
59927: PUSH
59928: LD_INT 11
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 35
59937: PUSH
59938: LD_INT 30
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: LIST
59949: PUSH
59950: LD_INT 91
59952: PUSH
59953: LD_VAR 0 1
59957: PUSH
59958: LD_INT 18
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: LIST
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: LIST
59970: PPUSH
59971: CALL_OW 69
59975: NOT
59976: PUSH
59977: LD_INT 22
59979: PUSH
59980: LD_VAR 0 16
59984: PUSH
59985: EMPTY
59986: LIST
59987: LIST
59988: PUSH
59989: LD_INT 2
59991: PUSH
59992: LD_INT 30
59994: PUSH
59995: LD_INT 32
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: PUSH
60002: LD_INT 30
60004: PUSH
60005: LD_INT 33
60007: PUSH
60008: EMPTY
60009: LIST
60010: LIST
60011: PUSH
60012: EMPTY
60013: LIST
60014: LIST
60015: LIST
60016: PUSH
60017: LD_INT 91
60019: PUSH
60020: LD_VAR 0 1
60024: PUSH
60025: LD_INT 12
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: LIST
60032: PUSH
60033: EMPTY
60034: LIST
60035: LIST
60036: LIST
60037: PUSH
60038: EMPTY
60039: LIST
60040: PPUSH
60041: CALL_OW 69
60045: PUSH
60046: LD_INT 2
60048: GREATER
60049: AND
60050: IFFALSE 60073
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60052: LD_ADDR_VAR 0 18
60056: PUSH
60057: LD_INT 11
60059: PUSH
60060: LD_INT 30
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: LD_VAR 0 12
60071: ARRAY
60072: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60073: LD_VAR 0 18
60077: NOT
60078: PUSH
60079: LD_INT 40
60081: PPUSH
60082: LD_VAR 0 16
60086: PPUSH
60087: CALL_OW 321
60091: PUSH
60092: LD_INT 2
60094: EQUAL
60095: AND
60096: PUSH
60097: LD_INT 7
60099: PUSH
60100: LD_VAR 0 5
60104: IN
60105: PUSH
60106: LD_INT 28
60108: PUSH
60109: LD_VAR 0 5
60113: IN
60114: OR
60115: PUSH
60116: LD_INT 45
60118: PUSH
60119: LD_VAR 0 5
60123: IN
60124: OR
60125: AND
60126: IFFALSE 60380
// begin hex := GetHexInfo ( x , y ) ;
60128: LD_ADDR_VAR 0 4
60132: PUSH
60133: LD_VAR 0 10
60137: PPUSH
60138: LD_VAR 0 11
60142: PPUSH
60143: CALL_OW 546
60147: ST_TO_ADDR
// if hex [ 1 ] then
60148: LD_VAR 0 4
60152: PUSH
60153: LD_INT 1
60155: ARRAY
60156: IFFALSE 60160
// exit ;
60158: GO 60563
// height := hex [ 2 ] ;
60160: LD_ADDR_VAR 0 15
60164: PUSH
60165: LD_VAR 0 4
60169: PUSH
60170: LD_INT 2
60172: ARRAY
60173: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60174: LD_ADDR_VAR 0 14
60178: PUSH
60179: LD_INT 0
60181: PUSH
60182: LD_INT 2
60184: PUSH
60185: LD_INT 3
60187: PUSH
60188: LD_INT 5
60190: PUSH
60191: EMPTY
60192: LIST
60193: LIST
60194: LIST
60195: LIST
60196: ST_TO_ADDR
// for i in tmp do
60197: LD_ADDR_VAR 0 8
60201: PUSH
60202: LD_VAR 0 14
60206: PUSH
60207: FOR_IN
60208: IFFALSE 60378
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60210: LD_ADDR_VAR 0 9
60214: PUSH
60215: LD_VAR 0 10
60219: PPUSH
60220: LD_VAR 0 8
60224: PPUSH
60225: LD_INT 5
60227: PPUSH
60228: CALL_OW 272
60232: PUSH
60233: LD_VAR 0 11
60237: PPUSH
60238: LD_VAR 0 8
60242: PPUSH
60243: LD_INT 5
60245: PPUSH
60246: CALL_OW 273
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60255: LD_VAR 0 9
60259: PUSH
60260: LD_INT 1
60262: ARRAY
60263: PPUSH
60264: LD_VAR 0 9
60268: PUSH
60269: LD_INT 2
60271: ARRAY
60272: PPUSH
60273: CALL_OW 488
60277: IFFALSE 60376
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60279: LD_ADDR_VAR 0 4
60283: PUSH
60284: LD_VAR 0 9
60288: PUSH
60289: LD_INT 1
60291: ARRAY
60292: PPUSH
60293: LD_VAR 0 9
60297: PUSH
60298: LD_INT 2
60300: ARRAY
60301: PPUSH
60302: CALL_OW 546
60306: ST_TO_ADDR
// if hex [ 1 ] then
60307: LD_VAR 0 4
60311: PUSH
60312: LD_INT 1
60314: ARRAY
60315: IFFALSE 60319
// continue ;
60317: GO 60207
// h := hex [ 2 ] ;
60319: LD_ADDR_VAR 0 13
60323: PUSH
60324: LD_VAR 0 4
60328: PUSH
60329: LD_INT 2
60331: ARRAY
60332: ST_TO_ADDR
// if h + 7 < height then
60333: LD_VAR 0 13
60337: PUSH
60338: LD_INT 7
60340: PLUS
60341: PUSH
60342: LD_VAR 0 15
60346: LESS
60347: IFFALSE 60376
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60349: LD_ADDR_VAR 0 18
60353: PUSH
60354: LD_INT 7
60356: PUSH
60357: LD_INT 28
60359: PUSH
60360: LD_INT 45
60362: PUSH
60363: EMPTY
60364: LIST
60365: LIST
60366: LIST
60367: PUSH
60368: LD_VAR 0 12
60372: ARRAY
60373: ST_TO_ADDR
// break ;
60374: GO 60378
// end ; end ; end ;
60376: GO 60207
60378: POP
60379: POP
// end ; if not weapon then
60380: LD_VAR 0 18
60384: NOT
60385: IFFALSE 60445
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60387: LD_ADDR_VAR 0 5
60391: PUSH
60392: LD_VAR 0 5
60396: PUSH
60397: LD_INT 11
60399: PUSH
60400: LD_INT 30
60402: PUSH
60403: LD_INT 49
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: LIST
60410: DIFF
60411: ST_TO_ADDR
// if not list then
60412: LD_VAR 0 5
60416: NOT
60417: IFFALSE 60421
// exit ;
60419: GO 60563
// weapon := list [ rand ( 1 , list ) ] ;
60421: LD_ADDR_VAR 0 18
60425: PUSH
60426: LD_VAR 0 5
60430: PUSH
60431: LD_INT 1
60433: PPUSH
60434: LD_VAR 0 5
60438: PPUSH
60439: CALL_OW 12
60443: ARRAY
60444: ST_TO_ADDR
// end ; if weapon then
60445: LD_VAR 0 18
60449: IFFALSE 60563
// begin tmp := CostOfWeapon ( weapon ) ;
60451: LD_ADDR_VAR 0 14
60455: PUSH
60456: LD_VAR 0 18
60460: PPUSH
60461: CALL_OW 451
60465: ST_TO_ADDR
// j := GetBase ( tower ) ;
60466: LD_ADDR_VAR 0 9
60470: PUSH
60471: LD_VAR 0 1
60475: PPUSH
60476: CALL_OW 274
60480: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60481: LD_VAR 0 9
60485: PPUSH
60486: LD_INT 1
60488: PPUSH
60489: CALL_OW 275
60493: PUSH
60494: LD_VAR 0 14
60498: PUSH
60499: LD_INT 1
60501: ARRAY
60502: GREATEREQUAL
60503: PUSH
60504: LD_VAR 0 9
60508: PPUSH
60509: LD_INT 2
60511: PPUSH
60512: CALL_OW 275
60516: PUSH
60517: LD_VAR 0 14
60521: PUSH
60522: LD_INT 2
60524: ARRAY
60525: GREATEREQUAL
60526: AND
60527: PUSH
60528: LD_VAR 0 9
60532: PPUSH
60533: LD_INT 3
60535: PPUSH
60536: CALL_OW 275
60540: PUSH
60541: LD_VAR 0 14
60545: PUSH
60546: LD_INT 3
60548: ARRAY
60549: GREATEREQUAL
60550: AND
60551: IFFALSE 60563
// result := weapon ;
60553: LD_ADDR_VAR 0 3
60557: PUSH
60558: LD_VAR 0 18
60562: ST_TO_ADDR
// end ; end ;
60563: LD_VAR 0 3
60567: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60568: LD_INT 0
60570: PPUSH
60571: PPUSH
// result := true ;
60572: LD_ADDR_VAR 0 3
60576: PUSH
60577: LD_INT 1
60579: ST_TO_ADDR
// if array1 = array2 then
60580: LD_VAR 0 1
60584: PUSH
60585: LD_VAR 0 2
60589: EQUAL
60590: IFFALSE 60650
// begin for i = 1 to array1 do
60592: LD_ADDR_VAR 0 4
60596: PUSH
60597: DOUBLE
60598: LD_INT 1
60600: DEC
60601: ST_TO_ADDR
60602: LD_VAR 0 1
60606: PUSH
60607: FOR_TO
60608: IFFALSE 60646
// if array1 [ i ] <> array2 [ i ] then
60610: LD_VAR 0 1
60614: PUSH
60615: LD_VAR 0 4
60619: ARRAY
60620: PUSH
60621: LD_VAR 0 2
60625: PUSH
60626: LD_VAR 0 4
60630: ARRAY
60631: NONEQUAL
60632: IFFALSE 60644
// begin result := false ;
60634: LD_ADDR_VAR 0 3
60638: PUSH
60639: LD_INT 0
60641: ST_TO_ADDR
// break ;
60642: GO 60646
// end ;
60644: GO 60607
60646: POP
60647: POP
// end else
60648: GO 60658
// result := false ;
60650: LD_ADDR_VAR 0 3
60654: PUSH
60655: LD_INT 0
60657: ST_TO_ADDR
// end ;
60658: LD_VAR 0 3
60662: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60663: LD_INT 0
60665: PPUSH
60666: PPUSH
// if not array1 or not array2 then
60667: LD_VAR 0 1
60671: NOT
60672: PUSH
60673: LD_VAR 0 2
60677: NOT
60678: OR
60679: IFFALSE 60683
// exit ;
60681: GO 60747
// result := true ;
60683: LD_ADDR_VAR 0 3
60687: PUSH
60688: LD_INT 1
60690: ST_TO_ADDR
// for i = 1 to array1 do
60691: LD_ADDR_VAR 0 4
60695: PUSH
60696: DOUBLE
60697: LD_INT 1
60699: DEC
60700: ST_TO_ADDR
60701: LD_VAR 0 1
60705: PUSH
60706: FOR_TO
60707: IFFALSE 60745
// if array1 [ i ] <> array2 [ i ] then
60709: LD_VAR 0 1
60713: PUSH
60714: LD_VAR 0 4
60718: ARRAY
60719: PUSH
60720: LD_VAR 0 2
60724: PUSH
60725: LD_VAR 0 4
60729: ARRAY
60730: NONEQUAL
60731: IFFALSE 60743
// begin result := false ;
60733: LD_ADDR_VAR 0 3
60737: PUSH
60738: LD_INT 0
60740: ST_TO_ADDR
// break ;
60741: GO 60745
// end ;
60743: GO 60706
60745: POP
60746: POP
// end ;
60747: LD_VAR 0 3
60751: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60752: LD_INT 0
60754: PPUSH
60755: PPUSH
60756: PPUSH
// pom := GetBase ( fac ) ;
60757: LD_ADDR_VAR 0 5
60761: PUSH
60762: LD_VAR 0 1
60766: PPUSH
60767: CALL_OW 274
60771: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60772: LD_ADDR_VAR 0 4
60776: PUSH
60777: LD_VAR 0 2
60781: PUSH
60782: LD_INT 1
60784: ARRAY
60785: PPUSH
60786: LD_VAR 0 2
60790: PUSH
60791: LD_INT 2
60793: ARRAY
60794: PPUSH
60795: LD_VAR 0 2
60799: PUSH
60800: LD_INT 3
60802: ARRAY
60803: PPUSH
60804: LD_VAR 0 2
60808: PUSH
60809: LD_INT 4
60811: ARRAY
60812: PPUSH
60813: CALL_OW 449
60817: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60818: LD_ADDR_VAR 0 3
60822: PUSH
60823: LD_VAR 0 5
60827: PPUSH
60828: LD_INT 1
60830: PPUSH
60831: CALL_OW 275
60835: PUSH
60836: LD_VAR 0 4
60840: PUSH
60841: LD_INT 1
60843: ARRAY
60844: GREATEREQUAL
60845: PUSH
60846: LD_VAR 0 5
60850: PPUSH
60851: LD_INT 2
60853: PPUSH
60854: CALL_OW 275
60858: PUSH
60859: LD_VAR 0 4
60863: PUSH
60864: LD_INT 2
60866: ARRAY
60867: GREATEREQUAL
60868: AND
60869: PUSH
60870: LD_VAR 0 5
60874: PPUSH
60875: LD_INT 3
60877: PPUSH
60878: CALL_OW 275
60882: PUSH
60883: LD_VAR 0 4
60887: PUSH
60888: LD_INT 3
60890: ARRAY
60891: GREATEREQUAL
60892: AND
60893: ST_TO_ADDR
// end ;
60894: LD_VAR 0 3
60898: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60899: LD_INT 0
60901: PPUSH
60902: PPUSH
60903: PPUSH
60904: PPUSH
// pom := GetBase ( building ) ;
60905: LD_ADDR_VAR 0 3
60909: PUSH
60910: LD_VAR 0 1
60914: PPUSH
60915: CALL_OW 274
60919: ST_TO_ADDR
// if not pom then
60920: LD_VAR 0 3
60924: NOT
60925: IFFALSE 60929
// exit ;
60927: GO 61099
// btype := GetBType ( building ) ;
60929: LD_ADDR_VAR 0 5
60933: PUSH
60934: LD_VAR 0 1
60938: PPUSH
60939: CALL_OW 266
60943: ST_TO_ADDR
// if btype = b_armoury then
60944: LD_VAR 0 5
60948: PUSH
60949: LD_INT 4
60951: EQUAL
60952: IFFALSE 60962
// btype := b_barracks ;
60954: LD_ADDR_VAR 0 5
60958: PUSH
60959: LD_INT 5
60961: ST_TO_ADDR
// if btype = b_depot then
60962: LD_VAR 0 5
60966: PUSH
60967: LD_INT 0
60969: EQUAL
60970: IFFALSE 60980
// btype := b_warehouse ;
60972: LD_ADDR_VAR 0 5
60976: PUSH
60977: LD_INT 1
60979: ST_TO_ADDR
// if btype = b_workshop then
60980: LD_VAR 0 5
60984: PUSH
60985: LD_INT 2
60987: EQUAL
60988: IFFALSE 60998
// btype := b_factory ;
60990: LD_ADDR_VAR 0 5
60994: PUSH
60995: LD_INT 3
60997: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60998: LD_ADDR_VAR 0 4
61002: PUSH
61003: LD_VAR 0 5
61007: PPUSH
61008: LD_VAR 0 1
61012: PPUSH
61013: CALL_OW 248
61017: PPUSH
61018: CALL_OW 450
61022: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61023: LD_ADDR_VAR 0 2
61027: PUSH
61028: LD_VAR 0 3
61032: PPUSH
61033: LD_INT 1
61035: PPUSH
61036: CALL_OW 275
61040: PUSH
61041: LD_VAR 0 4
61045: PUSH
61046: LD_INT 1
61048: ARRAY
61049: GREATEREQUAL
61050: PUSH
61051: LD_VAR 0 3
61055: PPUSH
61056: LD_INT 2
61058: PPUSH
61059: CALL_OW 275
61063: PUSH
61064: LD_VAR 0 4
61068: PUSH
61069: LD_INT 2
61071: ARRAY
61072: GREATEREQUAL
61073: AND
61074: PUSH
61075: LD_VAR 0 3
61079: PPUSH
61080: LD_INT 3
61082: PPUSH
61083: CALL_OW 275
61087: PUSH
61088: LD_VAR 0 4
61092: PUSH
61093: LD_INT 3
61095: ARRAY
61096: GREATEREQUAL
61097: AND
61098: ST_TO_ADDR
// end ;
61099: LD_VAR 0 2
61103: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61104: LD_INT 0
61106: PPUSH
61107: PPUSH
61108: PPUSH
// pom := GetBase ( building ) ;
61109: LD_ADDR_VAR 0 4
61113: PUSH
61114: LD_VAR 0 1
61118: PPUSH
61119: CALL_OW 274
61123: ST_TO_ADDR
// if not pom then
61124: LD_VAR 0 4
61128: NOT
61129: IFFALSE 61133
// exit ;
61131: GO 61234
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61133: LD_ADDR_VAR 0 5
61137: PUSH
61138: LD_VAR 0 2
61142: PPUSH
61143: LD_VAR 0 1
61147: PPUSH
61148: CALL_OW 248
61152: PPUSH
61153: CALL_OW 450
61157: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61158: LD_ADDR_VAR 0 3
61162: PUSH
61163: LD_VAR 0 4
61167: PPUSH
61168: LD_INT 1
61170: PPUSH
61171: CALL_OW 275
61175: PUSH
61176: LD_VAR 0 5
61180: PUSH
61181: LD_INT 1
61183: ARRAY
61184: GREATEREQUAL
61185: PUSH
61186: LD_VAR 0 4
61190: PPUSH
61191: LD_INT 2
61193: PPUSH
61194: CALL_OW 275
61198: PUSH
61199: LD_VAR 0 5
61203: PUSH
61204: LD_INT 2
61206: ARRAY
61207: GREATEREQUAL
61208: AND
61209: PUSH
61210: LD_VAR 0 4
61214: PPUSH
61215: LD_INT 3
61217: PPUSH
61218: CALL_OW 275
61222: PUSH
61223: LD_VAR 0 5
61227: PUSH
61228: LD_INT 3
61230: ARRAY
61231: GREATEREQUAL
61232: AND
61233: ST_TO_ADDR
// end ;
61234: LD_VAR 0 3
61238: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61239: LD_INT 0
61241: PPUSH
61242: PPUSH
61243: PPUSH
61244: PPUSH
61245: PPUSH
61246: PPUSH
61247: PPUSH
61248: PPUSH
61249: PPUSH
61250: PPUSH
61251: PPUSH
// result := false ;
61252: LD_ADDR_VAR 0 8
61256: PUSH
61257: LD_INT 0
61259: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61260: LD_VAR 0 5
61264: NOT
61265: PUSH
61266: LD_VAR 0 1
61270: NOT
61271: OR
61272: PUSH
61273: LD_VAR 0 2
61277: NOT
61278: OR
61279: PUSH
61280: LD_VAR 0 3
61284: NOT
61285: OR
61286: IFFALSE 61290
// exit ;
61288: GO 62104
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61290: LD_ADDR_VAR 0 14
61294: PUSH
61295: LD_VAR 0 1
61299: PPUSH
61300: LD_VAR 0 2
61304: PPUSH
61305: LD_VAR 0 3
61309: PPUSH
61310: LD_VAR 0 4
61314: PPUSH
61315: LD_VAR 0 5
61319: PUSH
61320: LD_INT 1
61322: ARRAY
61323: PPUSH
61324: CALL_OW 248
61328: PPUSH
61329: LD_INT 0
61331: PPUSH
61332: CALL 63357 0 6
61336: ST_TO_ADDR
// if not hexes then
61337: LD_VAR 0 14
61341: NOT
61342: IFFALSE 61346
// exit ;
61344: GO 62104
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61346: LD_ADDR_VAR 0 17
61350: PUSH
61351: LD_VAR 0 5
61355: PPUSH
61356: LD_INT 22
61358: PUSH
61359: LD_VAR 0 13
61363: PPUSH
61364: CALL_OW 255
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: PUSH
61373: LD_INT 2
61375: PUSH
61376: LD_INT 30
61378: PUSH
61379: LD_INT 0
61381: PUSH
61382: EMPTY
61383: LIST
61384: LIST
61385: PUSH
61386: LD_INT 30
61388: PUSH
61389: LD_INT 1
61391: PUSH
61392: EMPTY
61393: LIST
61394: LIST
61395: PUSH
61396: EMPTY
61397: LIST
61398: LIST
61399: LIST
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PPUSH
61405: CALL_OW 72
61409: ST_TO_ADDR
// for i = 1 to hexes do
61410: LD_ADDR_VAR 0 9
61414: PUSH
61415: DOUBLE
61416: LD_INT 1
61418: DEC
61419: ST_TO_ADDR
61420: LD_VAR 0 14
61424: PUSH
61425: FOR_TO
61426: IFFALSE 62102
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61428: LD_ADDR_VAR 0 13
61432: PUSH
61433: LD_VAR 0 14
61437: PUSH
61438: LD_VAR 0 9
61442: ARRAY
61443: PUSH
61444: LD_INT 1
61446: ARRAY
61447: PPUSH
61448: LD_VAR 0 14
61452: PUSH
61453: LD_VAR 0 9
61457: ARRAY
61458: PUSH
61459: LD_INT 2
61461: ARRAY
61462: PPUSH
61463: CALL_OW 428
61467: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61468: LD_VAR 0 14
61472: PUSH
61473: LD_VAR 0 9
61477: ARRAY
61478: PUSH
61479: LD_INT 1
61481: ARRAY
61482: PPUSH
61483: LD_VAR 0 14
61487: PUSH
61488: LD_VAR 0 9
61492: ARRAY
61493: PUSH
61494: LD_INT 2
61496: ARRAY
61497: PPUSH
61498: CALL_OW 351
61502: PUSH
61503: LD_VAR 0 14
61507: PUSH
61508: LD_VAR 0 9
61512: ARRAY
61513: PUSH
61514: LD_INT 1
61516: ARRAY
61517: PPUSH
61518: LD_VAR 0 14
61522: PUSH
61523: LD_VAR 0 9
61527: ARRAY
61528: PUSH
61529: LD_INT 2
61531: ARRAY
61532: PPUSH
61533: CALL_OW 488
61537: NOT
61538: OR
61539: PUSH
61540: LD_VAR 0 13
61544: PPUSH
61545: CALL_OW 247
61549: PUSH
61550: LD_INT 3
61552: EQUAL
61553: OR
61554: IFFALSE 61560
// exit ;
61556: POP
61557: POP
61558: GO 62104
// if not tmp then
61560: LD_VAR 0 13
61564: NOT
61565: IFFALSE 61569
// continue ;
61567: GO 61425
// result := true ;
61569: LD_ADDR_VAR 0 8
61573: PUSH
61574: LD_INT 1
61576: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61577: LD_VAR 0 6
61581: PUSH
61582: LD_VAR 0 13
61586: PPUSH
61587: CALL_OW 247
61591: PUSH
61592: LD_INT 2
61594: EQUAL
61595: AND
61596: PUSH
61597: LD_VAR 0 13
61601: PPUSH
61602: CALL_OW 263
61606: PUSH
61607: LD_INT 1
61609: EQUAL
61610: AND
61611: IFFALSE 61775
// begin if IsDrivenBy ( tmp ) then
61613: LD_VAR 0 13
61617: PPUSH
61618: CALL_OW 311
61622: IFFALSE 61626
// continue ;
61624: GO 61425
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61626: LD_VAR 0 6
61630: PPUSH
61631: LD_INT 3
61633: PUSH
61634: LD_INT 60
61636: PUSH
61637: EMPTY
61638: LIST
61639: PUSH
61640: EMPTY
61641: LIST
61642: LIST
61643: PUSH
61644: LD_INT 3
61646: PUSH
61647: LD_INT 55
61649: PUSH
61650: EMPTY
61651: LIST
61652: PUSH
61653: EMPTY
61654: LIST
61655: LIST
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PPUSH
61661: CALL_OW 72
61665: IFFALSE 61773
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61667: LD_ADDR_VAR 0 18
61671: PUSH
61672: LD_VAR 0 6
61676: PPUSH
61677: LD_INT 3
61679: PUSH
61680: LD_INT 60
61682: PUSH
61683: EMPTY
61684: LIST
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: PUSH
61690: LD_INT 3
61692: PUSH
61693: LD_INT 55
61695: PUSH
61696: EMPTY
61697: LIST
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: PPUSH
61707: CALL_OW 72
61711: PUSH
61712: LD_INT 1
61714: ARRAY
61715: ST_TO_ADDR
// if IsInUnit ( driver ) then
61716: LD_VAR 0 18
61720: PPUSH
61721: CALL_OW 310
61725: IFFALSE 61736
// ComExit ( driver ) ;
61727: LD_VAR 0 18
61731: PPUSH
61732: CALL 87158 0 1
// AddComEnterUnit ( driver , tmp ) ;
61736: LD_VAR 0 18
61740: PPUSH
61741: LD_VAR 0 13
61745: PPUSH
61746: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61750: LD_VAR 0 18
61754: PPUSH
61755: LD_VAR 0 7
61759: PPUSH
61760: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61764: LD_VAR 0 18
61768: PPUSH
61769: CALL_OW 181
// end ; continue ;
61773: GO 61425
// end ; if not cleaners or not tmp in cleaners then
61775: LD_VAR 0 6
61779: NOT
61780: PUSH
61781: LD_VAR 0 13
61785: PUSH
61786: LD_VAR 0 6
61790: IN
61791: NOT
61792: OR
61793: IFFALSE 62100
// begin if dep then
61795: LD_VAR 0 17
61799: IFFALSE 61935
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61801: LD_ADDR_VAR 0 16
61805: PUSH
61806: LD_VAR 0 17
61810: PUSH
61811: LD_INT 1
61813: ARRAY
61814: PPUSH
61815: CALL_OW 250
61819: PPUSH
61820: LD_VAR 0 17
61824: PUSH
61825: LD_INT 1
61827: ARRAY
61828: PPUSH
61829: CALL_OW 254
61833: PPUSH
61834: LD_INT 5
61836: PPUSH
61837: CALL_OW 272
61841: PUSH
61842: LD_VAR 0 17
61846: PUSH
61847: LD_INT 1
61849: ARRAY
61850: PPUSH
61851: CALL_OW 251
61855: PPUSH
61856: LD_VAR 0 17
61860: PUSH
61861: LD_INT 1
61863: ARRAY
61864: PPUSH
61865: CALL_OW 254
61869: PPUSH
61870: LD_INT 5
61872: PPUSH
61873: CALL_OW 273
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61882: LD_VAR 0 16
61886: PUSH
61887: LD_INT 1
61889: ARRAY
61890: PPUSH
61891: LD_VAR 0 16
61895: PUSH
61896: LD_INT 2
61898: ARRAY
61899: PPUSH
61900: CALL_OW 488
61904: IFFALSE 61935
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61906: LD_VAR 0 13
61910: PPUSH
61911: LD_VAR 0 16
61915: PUSH
61916: LD_INT 1
61918: ARRAY
61919: PPUSH
61920: LD_VAR 0 16
61924: PUSH
61925: LD_INT 2
61927: ARRAY
61928: PPUSH
61929: CALL_OW 111
// continue ;
61933: GO 61425
// end ; end ; r := GetDir ( tmp ) ;
61935: LD_ADDR_VAR 0 15
61939: PUSH
61940: LD_VAR 0 13
61944: PPUSH
61945: CALL_OW 254
61949: ST_TO_ADDR
// if r = 5 then
61950: LD_VAR 0 15
61954: PUSH
61955: LD_INT 5
61957: EQUAL
61958: IFFALSE 61968
// r := 0 ;
61960: LD_ADDR_VAR 0 15
61964: PUSH
61965: LD_INT 0
61967: ST_TO_ADDR
// for j = r to 5 do
61968: LD_ADDR_VAR 0 10
61972: PUSH
61973: DOUBLE
61974: LD_VAR 0 15
61978: DEC
61979: ST_TO_ADDR
61980: LD_INT 5
61982: PUSH
61983: FOR_TO
61984: IFFALSE 62098
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61986: LD_ADDR_VAR 0 11
61990: PUSH
61991: LD_VAR 0 13
61995: PPUSH
61996: CALL_OW 250
62000: PPUSH
62001: LD_VAR 0 10
62005: PPUSH
62006: LD_INT 2
62008: PPUSH
62009: CALL_OW 272
62013: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62014: LD_ADDR_VAR 0 12
62018: PUSH
62019: LD_VAR 0 13
62023: PPUSH
62024: CALL_OW 251
62028: PPUSH
62029: LD_VAR 0 10
62033: PPUSH
62034: LD_INT 2
62036: PPUSH
62037: CALL_OW 273
62041: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62042: LD_VAR 0 11
62046: PPUSH
62047: LD_VAR 0 12
62051: PPUSH
62052: CALL_OW 488
62056: PUSH
62057: LD_VAR 0 11
62061: PPUSH
62062: LD_VAR 0 12
62066: PPUSH
62067: CALL_OW 428
62071: NOT
62072: AND
62073: IFFALSE 62096
// begin ComMoveXY ( tmp , _x , _y ) ;
62075: LD_VAR 0 13
62079: PPUSH
62080: LD_VAR 0 11
62084: PPUSH
62085: LD_VAR 0 12
62089: PPUSH
62090: CALL_OW 111
// break ;
62094: GO 62098
// end ; end ;
62096: GO 61983
62098: POP
62099: POP
// end ; end ;
62100: GO 61425
62102: POP
62103: POP
// end ;
62104: LD_VAR 0 8
62108: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62109: LD_INT 0
62111: PPUSH
// result := true ;
62112: LD_ADDR_VAR 0 3
62116: PUSH
62117: LD_INT 1
62119: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62120: LD_VAR 0 2
62124: PUSH
62125: LD_INT 24
62127: DOUBLE
62128: EQUAL
62129: IFTRUE 62139
62131: LD_INT 33
62133: DOUBLE
62134: EQUAL
62135: IFTRUE 62139
62137: GO 62164
62139: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62140: LD_ADDR_VAR 0 3
62144: PUSH
62145: LD_INT 32
62147: PPUSH
62148: LD_VAR 0 1
62152: PPUSH
62153: CALL_OW 321
62157: PUSH
62158: LD_INT 2
62160: EQUAL
62161: ST_TO_ADDR
62162: GO 62480
62164: LD_INT 20
62166: DOUBLE
62167: EQUAL
62168: IFTRUE 62172
62170: GO 62197
62172: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62173: LD_ADDR_VAR 0 3
62177: PUSH
62178: LD_INT 6
62180: PPUSH
62181: LD_VAR 0 1
62185: PPUSH
62186: CALL_OW 321
62190: PUSH
62191: LD_INT 2
62193: EQUAL
62194: ST_TO_ADDR
62195: GO 62480
62197: LD_INT 22
62199: DOUBLE
62200: EQUAL
62201: IFTRUE 62211
62203: LD_INT 36
62205: DOUBLE
62206: EQUAL
62207: IFTRUE 62211
62209: GO 62236
62211: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62212: LD_ADDR_VAR 0 3
62216: PUSH
62217: LD_INT 15
62219: PPUSH
62220: LD_VAR 0 1
62224: PPUSH
62225: CALL_OW 321
62229: PUSH
62230: LD_INT 2
62232: EQUAL
62233: ST_TO_ADDR
62234: GO 62480
62236: LD_INT 30
62238: DOUBLE
62239: EQUAL
62240: IFTRUE 62244
62242: GO 62269
62244: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62245: LD_ADDR_VAR 0 3
62249: PUSH
62250: LD_INT 20
62252: PPUSH
62253: LD_VAR 0 1
62257: PPUSH
62258: CALL_OW 321
62262: PUSH
62263: LD_INT 2
62265: EQUAL
62266: ST_TO_ADDR
62267: GO 62480
62269: LD_INT 28
62271: DOUBLE
62272: EQUAL
62273: IFTRUE 62283
62275: LD_INT 21
62277: DOUBLE
62278: EQUAL
62279: IFTRUE 62283
62281: GO 62308
62283: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62284: LD_ADDR_VAR 0 3
62288: PUSH
62289: LD_INT 21
62291: PPUSH
62292: LD_VAR 0 1
62296: PPUSH
62297: CALL_OW 321
62301: PUSH
62302: LD_INT 2
62304: EQUAL
62305: ST_TO_ADDR
62306: GO 62480
62308: LD_INT 16
62310: DOUBLE
62311: EQUAL
62312: IFTRUE 62316
62314: GO 62341
62316: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62317: LD_ADDR_VAR 0 3
62321: PUSH
62322: LD_INT 84
62324: PPUSH
62325: LD_VAR 0 1
62329: PPUSH
62330: CALL_OW 321
62334: PUSH
62335: LD_INT 2
62337: EQUAL
62338: ST_TO_ADDR
62339: GO 62480
62341: LD_INT 19
62343: DOUBLE
62344: EQUAL
62345: IFTRUE 62355
62347: LD_INT 23
62349: DOUBLE
62350: EQUAL
62351: IFTRUE 62355
62353: GO 62380
62355: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62356: LD_ADDR_VAR 0 3
62360: PUSH
62361: LD_INT 83
62363: PPUSH
62364: LD_VAR 0 1
62368: PPUSH
62369: CALL_OW 321
62373: PUSH
62374: LD_INT 2
62376: EQUAL
62377: ST_TO_ADDR
62378: GO 62480
62380: LD_INT 17
62382: DOUBLE
62383: EQUAL
62384: IFTRUE 62388
62386: GO 62413
62388: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62389: LD_ADDR_VAR 0 3
62393: PUSH
62394: LD_INT 39
62396: PPUSH
62397: LD_VAR 0 1
62401: PPUSH
62402: CALL_OW 321
62406: PUSH
62407: LD_INT 2
62409: EQUAL
62410: ST_TO_ADDR
62411: GO 62480
62413: LD_INT 18
62415: DOUBLE
62416: EQUAL
62417: IFTRUE 62421
62419: GO 62446
62421: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62422: LD_ADDR_VAR 0 3
62426: PUSH
62427: LD_INT 40
62429: PPUSH
62430: LD_VAR 0 1
62434: PPUSH
62435: CALL_OW 321
62439: PUSH
62440: LD_INT 2
62442: EQUAL
62443: ST_TO_ADDR
62444: GO 62480
62446: LD_INT 27
62448: DOUBLE
62449: EQUAL
62450: IFTRUE 62454
62452: GO 62479
62454: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62455: LD_ADDR_VAR 0 3
62459: PUSH
62460: LD_INT 35
62462: PPUSH
62463: LD_VAR 0 1
62467: PPUSH
62468: CALL_OW 321
62472: PUSH
62473: LD_INT 2
62475: EQUAL
62476: ST_TO_ADDR
62477: GO 62480
62479: POP
// end ;
62480: LD_VAR 0 3
62484: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62485: LD_INT 0
62487: PPUSH
62488: PPUSH
62489: PPUSH
62490: PPUSH
62491: PPUSH
62492: PPUSH
62493: PPUSH
62494: PPUSH
62495: PPUSH
62496: PPUSH
62497: PPUSH
// result := false ;
62498: LD_ADDR_VAR 0 6
62502: PUSH
62503: LD_INT 0
62505: ST_TO_ADDR
// if btype = b_depot then
62506: LD_VAR 0 2
62510: PUSH
62511: LD_INT 0
62513: EQUAL
62514: IFFALSE 62526
// begin result := true ;
62516: LD_ADDR_VAR 0 6
62520: PUSH
62521: LD_INT 1
62523: ST_TO_ADDR
// exit ;
62524: GO 63352
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62526: LD_VAR 0 1
62530: NOT
62531: PUSH
62532: LD_VAR 0 1
62536: PPUSH
62537: CALL_OW 266
62541: PUSH
62542: LD_INT 0
62544: PUSH
62545: LD_INT 1
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: IN
62552: NOT
62553: OR
62554: PUSH
62555: LD_VAR 0 2
62559: NOT
62560: OR
62561: PUSH
62562: LD_VAR 0 5
62566: PUSH
62567: LD_INT 0
62569: PUSH
62570: LD_INT 1
62572: PUSH
62573: LD_INT 2
62575: PUSH
62576: LD_INT 3
62578: PUSH
62579: LD_INT 4
62581: PUSH
62582: LD_INT 5
62584: PUSH
62585: EMPTY
62586: LIST
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: IN
62593: NOT
62594: OR
62595: PUSH
62596: LD_VAR 0 3
62600: PPUSH
62601: LD_VAR 0 4
62605: PPUSH
62606: CALL_OW 488
62610: NOT
62611: OR
62612: IFFALSE 62616
// exit ;
62614: GO 63352
// side := GetSide ( depot ) ;
62616: LD_ADDR_VAR 0 9
62620: PUSH
62621: LD_VAR 0 1
62625: PPUSH
62626: CALL_OW 255
62630: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62631: LD_VAR 0 9
62635: PPUSH
62636: LD_VAR 0 2
62640: PPUSH
62641: CALL 62109 0 2
62645: NOT
62646: IFFALSE 62650
// exit ;
62648: GO 63352
// pom := GetBase ( depot ) ;
62650: LD_ADDR_VAR 0 10
62654: PUSH
62655: LD_VAR 0 1
62659: PPUSH
62660: CALL_OW 274
62664: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62665: LD_ADDR_VAR 0 11
62669: PUSH
62670: LD_VAR 0 2
62674: PPUSH
62675: LD_VAR 0 1
62679: PPUSH
62680: CALL_OW 248
62684: PPUSH
62685: CALL_OW 450
62689: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62690: LD_VAR 0 10
62694: PPUSH
62695: LD_INT 1
62697: PPUSH
62698: CALL_OW 275
62702: PUSH
62703: LD_VAR 0 11
62707: PUSH
62708: LD_INT 1
62710: ARRAY
62711: GREATEREQUAL
62712: PUSH
62713: LD_VAR 0 10
62717: PPUSH
62718: LD_INT 2
62720: PPUSH
62721: CALL_OW 275
62725: PUSH
62726: LD_VAR 0 11
62730: PUSH
62731: LD_INT 2
62733: ARRAY
62734: GREATEREQUAL
62735: AND
62736: PUSH
62737: LD_VAR 0 10
62741: PPUSH
62742: LD_INT 3
62744: PPUSH
62745: CALL_OW 275
62749: PUSH
62750: LD_VAR 0 11
62754: PUSH
62755: LD_INT 3
62757: ARRAY
62758: GREATEREQUAL
62759: AND
62760: NOT
62761: IFFALSE 62765
// exit ;
62763: GO 63352
// if GetBType ( depot ) = b_depot then
62765: LD_VAR 0 1
62769: PPUSH
62770: CALL_OW 266
62774: PUSH
62775: LD_INT 0
62777: EQUAL
62778: IFFALSE 62790
// dist := 28 else
62780: LD_ADDR_VAR 0 14
62784: PUSH
62785: LD_INT 28
62787: ST_TO_ADDR
62788: GO 62798
// dist := 36 ;
62790: LD_ADDR_VAR 0 14
62794: PUSH
62795: LD_INT 36
62797: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62798: LD_VAR 0 1
62802: PPUSH
62803: LD_VAR 0 3
62807: PPUSH
62808: LD_VAR 0 4
62812: PPUSH
62813: CALL_OW 297
62817: PUSH
62818: LD_VAR 0 14
62822: GREATER
62823: IFFALSE 62827
// exit ;
62825: GO 63352
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62827: LD_ADDR_VAR 0 12
62831: PUSH
62832: LD_VAR 0 2
62836: PPUSH
62837: LD_VAR 0 3
62841: PPUSH
62842: LD_VAR 0 4
62846: PPUSH
62847: LD_VAR 0 5
62851: PPUSH
62852: LD_VAR 0 1
62856: PPUSH
62857: CALL_OW 248
62861: PPUSH
62862: LD_INT 0
62864: PPUSH
62865: CALL 63357 0 6
62869: ST_TO_ADDR
// if not hexes then
62870: LD_VAR 0 12
62874: NOT
62875: IFFALSE 62879
// exit ;
62877: GO 63352
// hex := GetHexInfo ( x , y ) ;
62879: LD_ADDR_VAR 0 15
62883: PUSH
62884: LD_VAR 0 3
62888: PPUSH
62889: LD_VAR 0 4
62893: PPUSH
62894: CALL_OW 546
62898: ST_TO_ADDR
// if hex [ 1 ] then
62899: LD_VAR 0 15
62903: PUSH
62904: LD_INT 1
62906: ARRAY
62907: IFFALSE 62911
// exit ;
62909: GO 63352
// height := hex [ 2 ] ;
62911: LD_ADDR_VAR 0 13
62915: PUSH
62916: LD_VAR 0 15
62920: PUSH
62921: LD_INT 2
62923: ARRAY
62924: ST_TO_ADDR
// for i = 1 to hexes do
62925: LD_ADDR_VAR 0 7
62929: PUSH
62930: DOUBLE
62931: LD_INT 1
62933: DEC
62934: ST_TO_ADDR
62935: LD_VAR 0 12
62939: PUSH
62940: FOR_TO
62941: IFFALSE 63271
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62943: LD_VAR 0 12
62947: PUSH
62948: LD_VAR 0 7
62952: ARRAY
62953: PUSH
62954: LD_INT 1
62956: ARRAY
62957: PPUSH
62958: LD_VAR 0 12
62962: PUSH
62963: LD_VAR 0 7
62967: ARRAY
62968: PUSH
62969: LD_INT 2
62971: ARRAY
62972: PPUSH
62973: CALL_OW 488
62977: NOT
62978: PUSH
62979: LD_VAR 0 12
62983: PUSH
62984: LD_VAR 0 7
62988: ARRAY
62989: PUSH
62990: LD_INT 1
62992: ARRAY
62993: PPUSH
62994: LD_VAR 0 12
62998: PUSH
62999: LD_VAR 0 7
63003: ARRAY
63004: PUSH
63005: LD_INT 2
63007: ARRAY
63008: PPUSH
63009: CALL_OW 428
63013: PUSH
63014: LD_INT 0
63016: GREATER
63017: OR
63018: PUSH
63019: LD_VAR 0 12
63023: PUSH
63024: LD_VAR 0 7
63028: ARRAY
63029: PUSH
63030: LD_INT 1
63032: ARRAY
63033: PPUSH
63034: LD_VAR 0 12
63038: PUSH
63039: LD_VAR 0 7
63043: ARRAY
63044: PUSH
63045: LD_INT 2
63047: ARRAY
63048: PPUSH
63049: CALL_OW 351
63053: OR
63054: IFFALSE 63060
// exit ;
63056: POP
63057: POP
63058: GO 63352
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63060: LD_ADDR_VAR 0 8
63064: PUSH
63065: LD_VAR 0 12
63069: PUSH
63070: LD_VAR 0 7
63074: ARRAY
63075: PUSH
63076: LD_INT 1
63078: ARRAY
63079: PPUSH
63080: LD_VAR 0 12
63084: PUSH
63085: LD_VAR 0 7
63089: ARRAY
63090: PUSH
63091: LD_INT 2
63093: ARRAY
63094: PPUSH
63095: CALL_OW 546
63099: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63100: LD_VAR 0 8
63104: PUSH
63105: LD_INT 1
63107: ARRAY
63108: PUSH
63109: LD_VAR 0 8
63113: PUSH
63114: LD_INT 2
63116: ARRAY
63117: PUSH
63118: LD_VAR 0 13
63122: PUSH
63123: LD_INT 2
63125: PLUS
63126: GREATER
63127: OR
63128: PUSH
63129: LD_VAR 0 8
63133: PUSH
63134: LD_INT 2
63136: ARRAY
63137: PUSH
63138: LD_VAR 0 13
63142: PUSH
63143: LD_INT 2
63145: MINUS
63146: LESS
63147: OR
63148: PUSH
63149: LD_VAR 0 8
63153: PUSH
63154: LD_INT 3
63156: ARRAY
63157: PUSH
63158: LD_INT 0
63160: PUSH
63161: LD_INT 8
63163: PUSH
63164: LD_INT 9
63166: PUSH
63167: LD_INT 10
63169: PUSH
63170: LD_INT 11
63172: PUSH
63173: LD_INT 12
63175: PUSH
63176: LD_INT 13
63178: PUSH
63179: LD_INT 16
63181: PUSH
63182: LD_INT 17
63184: PUSH
63185: LD_INT 18
63187: PUSH
63188: LD_INT 19
63190: PUSH
63191: LD_INT 20
63193: PUSH
63194: LD_INT 21
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: IN
63212: NOT
63213: OR
63214: PUSH
63215: LD_VAR 0 8
63219: PUSH
63220: LD_INT 5
63222: ARRAY
63223: NOT
63224: OR
63225: PUSH
63226: LD_VAR 0 8
63230: PUSH
63231: LD_INT 6
63233: ARRAY
63234: PUSH
63235: LD_INT 1
63237: PUSH
63238: LD_INT 2
63240: PUSH
63241: LD_INT 7
63243: PUSH
63244: LD_INT 9
63246: PUSH
63247: LD_INT 10
63249: PUSH
63250: LD_INT 11
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: IN
63261: NOT
63262: OR
63263: IFFALSE 63269
// exit ;
63265: POP
63266: POP
63267: GO 63352
// end ;
63269: GO 62940
63271: POP
63272: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63273: LD_VAR 0 9
63277: PPUSH
63278: LD_VAR 0 3
63282: PPUSH
63283: LD_VAR 0 4
63287: PPUSH
63288: LD_INT 20
63290: PPUSH
63291: CALL 55275 0 4
63295: PUSH
63296: LD_INT 4
63298: ARRAY
63299: IFFALSE 63303
// exit ;
63301: GO 63352
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63303: LD_VAR 0 2
63307: PUSH
63308: LD_INT 29
63310: PUSH
63311: LD_INT 30
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: IN
63318: PUSH
63319: LD_VAR 0 3
63323: PPUSH
63324: LD_VAR 0 4
63328: PPUSH
63329: LD_VAR 0 9
63333: PPUSH
63334: CALL_OW 440
63338: NOT
63339: AND
63340: IFFALSE 63344
// exit ;
63342: GO 63352
// result := true ;
63344: LD_ADDR_VAR 0 6
63348: PUSH
63349: LD_INT 1
63351: ST_TO_ADDR
// end ;
63352: LD_VAR 0 6
63356: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63357: LD_INT 0
63359: PPUSH
63360: PPUSH
63361: PPUSH
63362: PPUSH
63363: PPUSH
63364: PPUSH
63365: PPUSH
63366: PPUSH
63367: PPUSH
63368: PPUSH
63369: PPUSH
63370: PPUSH
63371: PPUSH
63372: PPUSH
63373: PPUSH
63374: PPUSH
63375: PPUSH
63376: PPUSH
63377: PPUSH
63378: PPUSH
63379: PPUSH
63380: PPUSH
63381: PPUSH
63382: PPUSH
63383: PPUSH
63384: PPUSH
63385: PPUSH
63386: PPUSH
63387: PPUSH
63388: PPUSH
63389: PPUSH
63390: PPUSH
63391: PPUSH
63392: PPUSH
63393: PPUSH
63394: PPUSH
63395: PPUSH
63396: PPUSH
63397: PPUSH
63398: PPUSH
63399: PPUSH
63400: PPUSH
63401: PPUSH
63402: PPUSH
63403: PPUSH
63404: PPUSH
63405: PPUSH
63406: PPUSH
63407: PPUSH
63408: PPUSH
63409: PPUSH
63410: PPUSH
63411: PPUSH
63412: PPUSH
63413: PPUSH
63414: PPUSH
63415: PPUSH
63416: PPUSH
// result = [ ] ;
63417: LD_ADDR_VAR 0 7
63421: PUSH
63422: EMPTY
63423: ST_TO_ADDR
// temp_list = [ ] ;
63424: LD_ADDR_VAR 0 9
63428: PUSH
63429: EMPTY
63430: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63431: LD_VAR 0 4
63435: PUSH
63436: LD_INT 0
63438: PUSH
63439: LD_INT 1
63441: PUSH
63442: LD_INT 2
63444: PUSH
63445: LD_INT 3
63447: PUSH
63448: LD_INT 4
63450: PUSH
63451: LD_INT 5
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: IN
63462: NOT
63463: PUSH
63464: LD_VAR 0 1
63468: PUSH
63469: LD_INT 0
63471: PUSH
63472: LD_INT 1
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: IN
63479: PUSH
63480: LD_VAR 0 5
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: LD_INT 2
63490: PUSH
63491: LD_INT 3
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: LIST
63498: IN
63499: NOT
63500: AND
63501: OR
63502: IFFALSE 63506
// exit ;
63504: GO 81897
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63506: LD_VAR 0 1
63510: PUSH
63511: LD_INT 6
63513: PUSH
63514: LD_INT 7
63516: PUSH
63517: LD_INT 8
63519: PUSH
63520: LD_INT 13
63522: PUSH
63523: LD_INT 12
63525: PUSH
63526: LD_INT 15
63528: PUSH
63529: LD_INT 11
63531: PUSH
63532: LD_INT 14
63534: PUSH
63535: LD_INT 10
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: IN
63549: IFFALSE 63559
// btype = b_lab ;
63551: LD_ADDR_VAR 0 1
63555: PUSH
63556: LD_INT 6
63558: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63559: LD_VAR 0 6
63563: PUSH
63564: LD_INT 0
63566: PUSH
63567: LD_INT 1
63569: PUSH
63570: LD_INT 2
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: LIST
63577: IN
63578: NOT
63579: PUSH
63580: LD_VAR 0 1
63584: PUSH
63585: LD_INT 0
63587: PUSH
63588: LD_INT 1
63590: PUSH
63591: LD_INT 2
63593: PUSH
63594: LD_INT 3
63596: PUSH
63597: LD_INT 6
63599: PUSH
63600: LD_INT 36
63602: PUSH
63603: LD_INT 4
63605: PUSH
63606: LD_INT 5
63608: PUSH
63609: LD_INT 31
63611: PUSH
63612: LD_INT 32
63614: PUSH
63615: LD_INT 33
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: IN
63631: NOT
63632: PUSH
63633: LD_VAR 0 6
63637: PUSH
63638: LD_INT 1
63640: EQUAL
63641: AND
63642: OR
63643: PUSH
63644: LD_VAR 0 1
63648: PUSH
63649: LD_INT 2
63651: PUSH
63652: LD_INT 3
63654: PUSH
63655: EMPTY
63656: LIST
63657: LIST
63658: IN
63659: NOT
63660: PUSH
63661: LD_VAR 0 6
63665: PUSH
63666: LD_INT 2
63668: EQUAL
63669: AND
63670: OR
63671: IFFALSE 63681
// mode = 0 ;
63673: LD_ADDR_VAR 0 6
63677: PUSH
63678: LD_INT 0
63680: ST_TO_ADDR
// case mode of 0 :
63681: LD_VAR 0 6
63685: PUSH
63686: LD_INT 0
63688: DOUBLE
63689: EQUAL
63690: IFTRUE 63694
63692: GO 75147
63694: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63695: LD_ADDR_VAR 0 11
63699: PUSH
63700: LD_INT 0
63702: PUSH
63703: LD_INT 0
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 1
63715: NEG
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: LD_INT 0
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 1
63733: PUSH
63734: LD_INT 1
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: PUSH
63741: LD_INT 0
63743: PUSH
63744: LD_INT 1
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: LD_INT 1
63753: NEG
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 1
63764: NEG
63765: PUSH
63766: LD_INT 1
63768: NEG
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 1
63776: NEG
63777: PUSH
63778: LD_INT 2
63780: NEG
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PUSH
63786: LD_INT 0
63788: PUSH
63789: LD_INT 2
63791: NEG
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 1
63799: PUSH
63800: LD_INT 1
63802: NEG
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: PUSH
63811: LD_INT 2
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 0
63820: PUSH
63821: LD_INT 2
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: NEG
63831: PUSH
63832: LD_INT 1
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: PUSH
63842: LD_INT 3
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: PUSH
63849: LD_INT 0
63851: PUSH
63852: LD_INT 3
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: LD_INT 1
63861: NEG
63862: PUSH
63863: LD_INT 2
63865: PUSH
63866: EMPTY
63867: LIST
63868: LIST
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63888: LD_ADDR_VAR 0 12
63892: PUSH
63893: LD_INT 0
63895: PUSH
63896: LD_INT 0
63898: PUSH
63899: EMPTY
63900: LIST
63901: LIST
63902: PUSH
63903: LD_INT 0
63905: PUSH
63906: LD_INT 1
63908: NEG
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: PUSH
63914: LD_INT 1
63916: PUSH
63917: LD_INT 0
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 1
63926: PUSH
63927: LD_INT 1
63929: PUSH
63930: EMPTY
63931: LIST
63932: LIST
63933: PUSH
63934: LD_INT 0
63936: PUSH
63937: LD_INT 1
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: LD_INT 1
63946: NEG
63947: PUSH
63948: LD_INT 0
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 1
63957: NEG
63958: PUSH
63959: LD_INT 1
63961: NEG
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PUSH
63967: LD_INT 1
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: PUSH
63978: LD_INT 2
63980: PUSH
63981: LD_INT 0
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 2
63990: PUSH
63991: LD_INT 1
63993: PUSH
63994: EMPTY
63995: LIST
63996: LIST
63997: PUSH
63998: LD_INT 1
64000: NEG
64001: PUSH
64002: LD_INT 1
64004: PUSH
64005: EMPTY
64006: LIST
64007: LIST
64008: PUSH
64009: LD_INT 2
64011: NEG
64012: PUSH
64013: LD_INT 0
64015: PUSH
64016: EMPTY
64017: LIST
64018: LIST
64019: PUSH
64020: LD_INT 2
64022: NEG
64023: PUSH
64024: LD_INT 1
64026: NEG
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: PUSH
64032: LD_INT 2
64034: NEG
64035: PUSH
64036: LD_INT 1
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 3
64045: NEG
64046: PUSH
64047: LD_INT 0
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: LD_INT 3
64056: NEG
64057: PUSH
64058: LD_INT 1
64060: NEG
64061: PUSH
64062: EMPTY
64063: LIST
64064: LIST
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64084: LD_ADDR_VAR 0 13
64088: PUSH
64089: LD_INT 0
64091: PUSH
64092: LD_INT 0
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 0
64101: PUSH
64102: LD_INT 1
64104: NEG
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 1
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 1
64122: PUSH
64123: LD_INT 1
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: PUSH
64130: LD_INT 0
64132: PUSH
64133: LD_INT 1
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 1
64142: NEG
64143: PUSH
64144: LD_INT 0
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: PUSH
64151: LD_INT 1
64153: NEG
64154: PUSH
64155: LD_INT 1
64157: NEG
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 1
64165: NEG
64166: PUSH
64167: LD_INT 2
64169: NEG
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: PUSH
64175: LD_INT 2
64177: PUSH
64178: LD_INT 1
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 2
64187: PUSH
64188: LD_INT 2
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PUSH
64195: LD_INT 1
64197: PUSH
64198: LD_INT 2
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 2
64207: NEG
64208: PUSH
64209: LD_INT 1
64211: NEG
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: PUSH
64217: LD_INT 2
64219: NEG
64220: PUSH
64221: LD_INT 2
64223: NEG
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: PUSH
64229: LD_INT 2
64231: NEG
64232: PUSH
64233: LD_INT 3
64235: NEG
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PUSH
64241: LD_INT 3
64243: NEG
64244: PUSH
64245: LD_INT 2
64247: NEG
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PUSH
64253: LD_INT 3
64255: NEG
64256: PUSH
64257: LD_INT 3
64259: NEG
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: LIST
64269: LIST
64270: LIST
64271: LIST
64272: LIST
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64283: LD_ADDR_VAR 0 14
64287: PUSH
64288: LD_INT 0
64290: PUSH
64291: LD_INT 0
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 0
64300: PUSH
64301: LD_INT 1
64303: NEG
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 1
64311: PUSH
64312: LD_INT 0
64314: PUSH
64315: EMPTY
64316: LIST
64317: LIST
64318: PUSH
64319: LD_INT 1
64321: PUSH
64322: LD_INT 1
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: LD_INT 0
64331: PUSH
64332: LD_INT 1
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 1
64341: NEG
64342: PUSH
64343: LD_INT 0
64345: PUSH
64346: EMPTY
64347: LIST
64348: LIST
64349: PUSH
64350: LD_INT 1
64352: NEG
64353: PUSH
64354: LD_INT 1
64356: NEG
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: LD_INT 1
64364: NEG
64365: PUSH
64366: LD_INT 2
64368: NEG
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: LD_INT 0
64376: PUSH
64377: LD_INT 2
64379: NEG
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 1
64387: PUSH
64388: LD_INT 1
64390: NEG
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 1
64398: PUSH
64399: LD_INT 2
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 0
64408: PUSH
64409: LD_INT 2
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PUSH
64416: LD_INT 1
64418: NEG
64419: PUSH
64420: LD_INT 1
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: LD_INT 1
64429: NEG
64430: PUSH
64431: LD_INT 3
64433: NEG
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 0
64441: PUSH
64442: LD_INT 3
64444: NEG
64445: PUSH
64446: EMPTY
64447: LIST
64448: LIST
64449: PUSH
64450: LD_INT 1
64452: PUSH
64453: LD_INT 2
64455: NEG
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64479: LD_ADDR_VAR 0 15
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: LD_INT 0
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: LD_INT 0
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 1
64507: PUSH
64508: LD_INT 0
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 1
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 0
64527: PUSH
64528: LD_INT 1
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: LD_INT 0
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 1
64548: NEG
64549: PUSH
64550: LD_INT 1
64552: NEG
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 1
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 2
64571: PUSH
64572: LD_INT 0
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 2
64581: PUSH
64582: LD_INT 1
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: NEG
64592: PUSH
64593: LD_INT 1
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 2
64602: NEG
64603: PUSH
64604: LD_INT 0
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: PUSH
64611: LD_INT 2
64613: NEG
64614: PUSH
64615: LD_INT 1
64617: NEG
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: PUSH
64623: LD_INT 2
64625: PUSH
64626: LD_INT 1
64628: NEG
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 3
64636: PUSH
64637: LD_INT 0
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 3
64646: PUSH
64647: LD_INT 1
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64672: LD_ADDR_VAR 0 16
64676: PUSH
64677: LD_INT 0
64679: PUSH
64680: LD_INT 0
64682: PUSH
64683: EMPTY
64684: LIST
64685: LIST
64686: PUSH
64687: LD_INT 0
64689: PUSH
64690: LD_INT 1
64692: NEG
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: PUSH
64698: LD_INT 1
64700: PUSH
64701: LD_INT 0
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 1
64710: PUSH
64711: LD_INT 1
64713: PUSH
64714: EMPTY
64715: LIST
64716: LIST
64717: PUSH
64718: LD_INT 0
64720: PUSH
64721: LD_INT 1
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 1
64730: NEG
64731: PUSH
64732: LD_INT 0
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 1
64741: NEG
64742: PUSH
64743: LD_INT 1
64745: NEG
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: PUSH
64751: LD_INT 1
64753: NEG
64754: PUSH
64755: LD_INT 2
64757: NEG
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: LD_INT 2
64765: PUSH
64766: LD_INT 1
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 2
64775: PUSH
64776: LD_INT 2
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: PUSH
64783: LD_INT 1
64785: PUSH
64786: LD_INT 2
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 2
64795: NEG
64796: PUSH
64797: LD_INT 1
64799: NEG
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 2
64807: NEG
64808: PUSH
64809: LD_INT 2
64811: NEG
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 3
64819: PUSH
64820: LD_INT 2
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 3
64829: PUSH
64830: LD_INT 3
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 2
64839: PUSH
64840: LD_INT 3
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: LIST
64851: LIST
64852: LIST
64853: LIST
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64865: LD_ADDR_VAR 0 17
64869: PUSH
64870: LD_INT 0
64872: PUSH
64873: LD_INT 0
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: PUSH
64880: LD_INT 0
64882: PUSH
64883: LD_INT 1
64885: NEG
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 1
64893: PUSH
64894: LD_INT 0
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PUSH
64901: LD_INT 1
64903: PUSH
64904: LD_INT 1
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 0
64913: PUSH
64914: LD_INT 1
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: PUSH
64921: LD_INT 1
64923: NEG
64924: PUSH
64925: LD_INT 0
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 1
64934: NEG
64935: PUSH
64936: LD_INT 1
64938: NEG
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: PUSH
64944: LD_INT 1
64946: NEG
64947: PUSH
64948: LD_INT 2
64950: NEG
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: LD_INT 2
64961: NEG
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 1
64969: PUSH
64970: LD_INT 1
64972: NEG
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 2
64980: PUSH
64981: LD_INT 0
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 2
64990: PUSH
64991: LD_INT 1
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: PUSH
64998: LD_INT 2
65000: PUSH
65001: LD_INT 2
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: PUSH
65008: LD_INT 1
65010: PUSH
65011: LD_INT 2
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 0
65020: PUSH
65021: LD_INT 2
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 1
65030: NEG
65031: PUSH
65032: LD_INT 1
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 2
65041: NEG
65042: PUSH
65043: LD_INT 0
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 2
65052: NEG
65053: PUSH
65054: LD_INT 1
65056: NEG
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 2
65064: NEG
65065: PUSH
65066: LD_INT 2
65068: NEG
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: LIST
65078: LIST
65079: LIST
65080: LIST
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: LIST
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65095: LD_ADDR_VAR 0 18
65099: PUSH
65100: LD_INT 0
65102: PUSH
65103: LD_INT 0
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 0
65112: PUSH
65113: LD_INT 1
65115: NEG
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 1
65123: PUSH
65124: LD_INT 0
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PUSH
65131: LD_INT 1
65133: PUSH
65134: LD_INT 1
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 0
65143: PUSH
65144: LD_INT 1
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: LD_INT 1
65153: NEG
65154: PUSH
65155: LD_INT 0
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: LD_INT 1
65164: NEG
65165: PUSH
65166: LD_INT 1
65168: NEG
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 1
65176: NEG
65177: PUSH
65178: LD_INT 2
65180: NEG
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: LD_INT 2
65191: NEG
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 1
65199: PUSH
65200: LD_INT 1
65202: NEG
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 2
65210: PUSH
65211: LD_INT 0
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 2
65220: PUSH
65221: LD_INT 1
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: LD_INT 2
65230: PUSH
65231: LD_INT 2
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PUSH
65238: LD_INT 1
65240: PUSH
65241: LD_INT 2
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: LD_INT 2
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 1
65260: NEG
65261: PUSH
65262: LD_INT 1
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 2
65271: NEG
65272: PUSH
65273: LD_INT 0
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 2
65282: NEG
65283: PUSH
65284: LD_INT 1
65286: NEG
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: PUSH
65292: LD_INT 2
65294: NEG
65295: PUSH
65296: LD_INT 2
65298: NEG
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: LIST
65308: LIST
65309: LIST
65310: LIST
65311: LIST
65312: LIST
65313: LIST
65314: LIST
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65325: LD_ADDR_VAR 0 19
65329: PUSH
65330: LD_INT 0
65332: PUSH
65333: LD_INT 0
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: LD_INT 0
65342: PUSH
65343: LD_INT 1
65345: NEG
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 1
65353: PUSH
65354: LD_INT 0
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 1
65363: PUSH
65364: LD_INT 1
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 0
65373: PUSH
65374: LD_INT 1
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 1
65383: NEG
65384: PUSH
65385: LD_INT 0
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: PUSH
65392: LD_INT 1
65394: NEG
65395: PUSH
65396: LD_INT 1
65398: NEG
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 1
65406: NEG
65407: PUSH
65408: LD_INT 2
65410: NEG
65411: PUSH
65412: EMPTY
65413: LIST
65414: LIST
65415: PUSH
65416: LD_INT 0
65418: PUSH
65419: LD_INT 2
65421: NEG
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 1
65429: PUSH
65430: LD_INT 1
65432: NEG
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 2
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 2
65450: PUSH
65451: LD_INT 1
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 2
65460: PUSH
65461: LD_INT 2
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: PUSH
65468: LD_INT 1
65470: PUSH
65471: LD_INT 2
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: LD_INT 0
65480: PUSH
65481: LD_INT 2
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PUSH
65488: LD_INT 1
65490: NEG
65491: PUSH
65492: LD_INT 1
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 2
65501: NEG
65502: PUSH
65503: LD_INT 0
65505: PUSH
65506: EMPTY
65507: LIST
65508: LIST
65509: PUSH
65510: LD_INT 2
65512: NEG
65513: PUSH
65514: LD_INT 1
65516: NEG
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: LD_INT 2
65524: NEG
65525: PUSH
65526: LD_INT 2
65528: NEG
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: LIST
65549: LIST
65550: LIST
65551: LIST
65552: LIST
65553: LIST
65554: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65555: LD_ADDR_VAR 0 20
65559: PUSH
65560: LD_INT 0
65562: PUSH
65563: LD_INT 0
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 0
65572: PUSH
65573: LD_INT 1
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: LD_INT 0
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PUSH
65591: LD_INT 1
65593: PUSH
65594: LD_INT 1
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 0
65603: PUSH
65604: LD_INT 1
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: LD_INT 1
65613: NEG
65614: PUSH
65615: LD_INT 0
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 1
65624: NEG
65625: PUSH
65626: LD_INT 1
65628: NEG
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 1
65636: NEG
65637: PUSH
65638: LD_INT 2
65640: NEG
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 0
65648: PUSH
65649: LD_INT 2
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 1
65659: PUSH
65660: LD_INT 1
65662: NEG
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: LD_INT 2
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 2
65680: PUSH
65681: LD_INT 1
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: LD_INT 2
65690: PUSH
65691: LD_INT 2
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: PUSH
65698: LD_INT 1
65700: PUSH
65701: LD_INT 2
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 0
65710: PUSH
65711: LD_INT 2
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: LD_INT 1
65720: NEG
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 2
65731: NEG
65732: PUSH
65733: LD_INT 0
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PUSH
65740: LD_INT 2
65742: NEG
65743: PUSH
65744: LD_INT 1
65746: NEG
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 2
65754: NEG
65755: PUSH
65756: LD_INT 2
65758: NEG
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: LIST
65768: LIST
65769: LIST
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65785: LD_ADDR_VAR 0 21
65789: PUSH
65790: LD_INT 0
65792: PUSH
65793: LD_INT 0
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 0
65802: PUSH
65803: LD_INT 1
65805: NEG
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 1
65813: PUSH
65814: LD_INT 0
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 1
65823: PUSH
65824: LD_INT 1
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 0
65833: PUSH
65834: LD_INT 1
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 1
65843: NEG
65844: PUSH
65845: LD_INT 0
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 1
65854: NEG
65855: PUSH
65856: LD_INT 1
65858: NEG
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: PUSH
65864: LD_INT 1
65866: NEG
65867: PUSH
65868: LD_INT 2
65870: NEG
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 0
65878: PUSH
65879: LD_INT 2
65881: NEG
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 1
65889: PUSH
65890: LD_INT 1
65892: NEG
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 2
65900: PUSH
65901: LD_INT 0
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 2
65920: PUSH
65921: LD_INT 2
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: PUSH
65928: LD_INT 1
65930: PUSH
65931: LD_INT 2
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: LD_INT 2
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 1
65950: NEG
65951: PUSH
65952: LD_INT 1
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 2
65961: NEG
65962: PUSH
65963: LD_INT 0
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: PUSH
65970: LD_INT 2
65972: NEG
65973: PUSH
65974: LD_INT 1
65976: NEG
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PUSH
65982: LD_INT 2
65984: NEG
65985: PUSH
65986: LD_INT 2
65988: NEG
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: LIST
66014: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66015: LD_ADDR_VAR 0 22
66019: PUSH
66020: LD_INT 0
66022: PUSH
66023: LD_INT 0
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: LD_INT 1
66035: NEG
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: LD_INT 0
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 1
66053: PUSH
66054: LD_INT 1
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 0
66063: PUSH
66064: LD_INT 1
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 1
66073: NEG
66074: PUSH
66075: LD_INT 0
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 1
66084: NEG
66085: PUSH
66086: LD_INT 1
66088: NEG
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 1
66096: NEG
66097: PUSH
66098: LD_INT 2
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: LD_INT 2
66111: NEG
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: LD_INT 1
66122: NEG
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: LD_INT 2
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 2
66140: PUSH
66141: LD_INT 1
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 2
66150: PUSH
66151: LD_INT 2
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 1
66160: PUSH
66161: LD_INT 2
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 0
66170: PUSH
66171: LD_INT 2
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 1
66180: NEG
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 2
66191: NEG
66192: PUSH
66193: LD_INT 0
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 2
66202: NEG
66203: PUSH
66204: LD_INT 1
66206: NEG
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 2
66214: NEG
66215: PUSH
66216: LD_INT 2
66218: NEG
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66245: LD_ADDR_VAR 0 23
66249: PUSH
66250: LD_INT 0
66252: PUSH
66253: LD_INT 0
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: NEG
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 1
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: PUSH
66284: LD_INT 1
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 0
66293: PUSH
66294: LD_INT 1
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 1
66303: NEG
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: LD_INT 1
66314: NEG
66315: PUSH
66316: LD_INT 1
66318: NEG
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: PUSH
66324: LD_INT 1
66326: NEG
66327: PUSH
66328: LD_INT 2
66330: NEG
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 0
66338: PUSH
66339: LD_INT 2
66341: NEG
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 1
66349: PUSH
66350: LD_INT 1
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 2
66360: PUSH
66361: LD_INT 0
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 2
66370: PUSH
66371: LD_INT 1
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PUSH
66378: LD_INT 2
66380: PUSH
66381: LD_INT 2
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 1
66390: PUSH
66391: LD_INT 2
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 0
66400: PUSH
66401: LD_INT 2
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 1
66410: NEG
66411: PUSH
66412: LD_INT 1
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 2
66421: NEG
66422: PUSH
66423: LD_INT 0
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 2
66432: NEG
66433: PUSH
66434: LD_INT 1
66436: NEG
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 2
66444: NEG
66445: PUSH
66446: LD_INT 2
66448: NEG
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: NEG
66457: PUSH
66458: LD_INT 3
66460: NEG
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 1
66468: NEG
66469: PUSH
66470: LD_INT 3
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: LD_INT 2
66483: NEG
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 2
66491: PUSH
66492: LD_INT 1
66494: NEG
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66525: LD_ADDR_VAR 0 24
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: LD_INT 0
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 0
66542: PUSH
66543: LD_INT 1
66545: NEG
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: LD_INT 1
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 1
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 0
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: LD_INT 0
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 1
66594: NEG
66595: PUSH
66596: LD_INT 1
66598: NEG
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: NEG
66607: PUSH
66608: LD_INT 2
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 0
66618: PUSH
66619: LD_INT 2
66621: NEG
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 1
66629: PUSH
66630: LD_INT 1
66632: NEG
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 2
66640: PUSH
66641: LD_INT 0
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 2
66650: PUSH
66651: LD_INT 1
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: PUSH
66658: LD_INT 2
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 1
66670: PUSH
66671: LD_INT 2
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: LD_INT 2
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 1
66690: NEG
66691: PUSH
66692: LD_INT 1
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: LD_INT 0
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 2
66712: NEG
66713: PUSH
66714: LD_INT 1
66716: NEG
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: LD_INT 2
66724: NEG
66725: PUSH
66726: LD_INT 2
66728: NEG
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 1
66736: PUSH
66737: LD_INT 2
66739: NEG
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 2
66747: PUSH
66748: LD_INT 1
66750: NEG
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 3
66758: PUSH
66759: LD_INT 1
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 3
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: LIST
66796: LIST
66797: LIST
66798: LIST
66799: LIST
66800: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66801: LD_ADDR_VAR 0 25
66805: PUSH
66806: LD_INT 0
66808: PUSH
66809: LD_INT 0
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 0
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: LD_INT 0
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: PUSH
66840: LD_INT 1
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PUSH
66847: LD_INT 0
66849: PUSH
66850: LD_INT 1
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 1
66859: NEG
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 1
66870: NEG
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: LD_INT 1
66882: NEG
66883: PUSH
66884: LD_INT 2
66886: NEG
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 0
66894: PUSH
66895: LD_INT 2
66897: NEG
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 1
66905: PUSH
66906: LD_INT 1
66908: NEG
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PUSH
66914: LD_INT 2
66916: PUSH
66917: LD_INT 0
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 2
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 2
66936: PUSH
66937: LD_INT 2
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: LD_INT 2
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 0
66956: PUSH
66957: LD_INT 2
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 1
66966: NEG
66967: PUSH
66968: LD_INT 1
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 2
66977: NEG
66978: PUSH
66979: LD_INT 0
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 2
66988: NEG
66989: PUSH
66990: LD_INT 1
66992: NEG
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: PUSH
66998: LD_INT 2
67000: NEG
67001: PUSH
67002: LD_INT 2
67004: NEG
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 3
67012: PUSH
67013: LD_INT 1
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 3
67022: PUSH
67023: LD_INT 2
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 2
67032: PUSH
67033: LD_INT 3
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 1
67042: PUSH
67043: LD_INT 3
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67075: LD_ADDR_VAR 0 26
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: LD_INT 0
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: LD_INT 1
67095: NEG
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 1
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 0
67123: PUSH
67124: LD_INT 1
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: NEG
67134: PUSH
67135: LD_INT 0
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: LD_INT 1
67144: NEG
67145: PUSH
67146: LD_INT 1
67148: NEG
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 1
67156: NEG
67157: PUSH
67158: LD_INT 2
67160: NEG
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 0
67168: PUSH
67169: LD_INT 2
67171: NEG
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 1
67179: PUSH
67180: LD_INT 1
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 2
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 2
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 2
67210: PUSH
67211: LD_INT 2
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: PUSH
67221: LD_INT 2
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 0
67230: PUSH
67231: LD_INT 2
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: PUSH
67238: LD_INT 1
67240: NEG
67241: PUSH
67242: LD_INT 1
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 2
67251: NEG
67252: PUSH
67253: LD_INT 0
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 2
67262: NEG
67263: PUSH
67264: LD_INT 1
67266: NEG
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: LD_INT 2
67274: NEG
67275: PUSH
67276: LD_INT 2
67278: NEG
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 2
67286: PUSH
67287: LD_INT 3
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: PUSH
67297: LD_INT 3
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 1
67306: NEG
67307: PUSH
67308: LD_INT 2
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: PUSH
67315: LD_INT 2
67317: NEG
67318: PUSH
67319: LD_INT 1
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67351: LD_ADDR_VAR 0 27
67355: PUSH
67356: LD_INT 0
67358: PUSH
67359: LD_INT 0
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 1
67379: PUSH
67380: LD_INT 0
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 1
67389: PUSH
67390: LD_INT 1
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: PUSH
67397: LD_INT 0
67399: PUSH
67400: LD_INT 1
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: LD_INT 0
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 1
67420: NEG
67421: PUSH
67422: LD_INT 1
67424: NEG
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 1
67432: NEG
67433: PUSH
67434: LD_INT 2
67436: NEG
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 0
67444: PUSH
67445: LD_INT 2
67447: NEG
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 1
67455: PUSH
67456: LD_INT 1
67458: NEG
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 2
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 2
67476: PUSH
67477: LD_INT 1
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 2
67486: PUSH
67487: LD_INT 2
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 1
67496: PUSH
67497: LD_INT 2
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 0
67506: PUSH
67507: LD_INT 2
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 1
67516: NEG
67517: PUSH
67518: LD_INT 1
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 2
67527: NEG
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 2
67538: NEG
67539: PUSH
67540: LD_INT 1
67542: NEG
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 2
67550: NEG
67551: PUSH
67552: LD_INT 2
67554: NEG
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 1
67562: NEG
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: LD_INT 1
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 3
67584: NEG
67585: PUSH
67586: LD_INT 1
67588: NEG
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 3
67596: NEG
67597: PUSH
67598: LD_INT 2
67600: NEG
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67631: LD_ADDR_VAR 0 28
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: LD_INT 0
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 0
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 1
67659: PUSH
67660: LD_INT 0
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 1
67669: PUSH
67670: LD_INT 1
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 0
67679: PUSH
67680: LD_INT 1
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: LD_INT 0
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: NEG
67701: PUSH
67702: LD_INT 1
67704: NEG
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: PUSH
67710: LD_INT 1
67712: NEG
67713: PUSH
67714: LD_INT 2
67716: NEG
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 0
67724: PUSH
67725: LD_INT 2
67727: NEG
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 1
67735: PUSH
67736: LD_INT 1
67738: NEG
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: LD_INT 1
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 2
67766: PUSH
67767: LD_INT 2
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 1
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: LD_INT 2
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 1
67796: NEG
67797: PUSH
67798: LD_INT 1
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 2
67807: NEG
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: LD_INT 2
67818: NEG
67819: PUSH
67820: LD_INT 1
67822: NEG
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 2
67830: NEG
67831: PUSH
67832: LD_INT 2
67834: NEG
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 2
67842: NEG
67843: PUSH
67844: LD_INT 3
67846: NEG
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: NEG
67855: PUSH
67856: LD_INT 3
67858: NEG
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 3
67866: NEG
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 3
67878: NEG
67879: PUSH
67880: LD_INT 2
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67913: LD_ADDR_VAR 0 29
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: LD_INT 0
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: LD_INT 1
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 1
67941: PUSH
67942: LD_INT 0
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 1
67951: PUSH
67952: LD_INT 1
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 0
67961: PUSH
67962: LD_INT 1
67964: PUSH
67965: EMPTY
67966: LIST
67967: LIST
67968: PUSH
67969: LD_INT 1
67971: NEG
67972: PUSH
67973: LD_INT 0
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 1
67982: NEG
67983: PUSH
67984: LD_INT 1
67986: NEG
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 1
67994: NEG
67995: PUSH
67996: LD_INT 2
67998: NEG
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 0
68006: PUSH
68007: LD_INT 2
68009: NEG
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 1
68017: PUSH
68018: LD_INT 1
68020: NEG
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 2
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 2
68038: PUSH
68039: LD_INT 1
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 1
68048: PUSH
68049: LD_INT 2
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 0
68058: PUSH
68059: LD_INT 2
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: LD_INT 1
68068: NEG
68069: PUSH
68070: LD_INT 1
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 2
68079: NEG
68080: PUSH
68081: LD_INT 1
68083: NEG
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 2
68091: NEG
68092: PUSH
68093: LD_INT 2
68095: NEG
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 2
68103: NEG
68104: PUSH
68105: LD_INT 3
68107: NEG
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 2
68115: PUSH
68116: LD_INT 1
68118: NEG
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 3
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 1
68136: PUSH
68137: LD_INT 3
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 1
68146: NEG
68147: PUSH
68148: LD_INT 2
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 3
68157: NEG
68158: PUSH
68159: LD_INT 2
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68192: LD_ADDR_VAR 0 30
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: LD_INT 0
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: LD_INT 1
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: PUSH
68221: LD_INT 0
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: LD_INT 1
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 1
68250: NEG
68251: PUSH
68252: LD_INT 0
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 1
68273: NEG
68274: PUSH
68275: LD_INT 2
68277: NEG
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: LD_INT 2
68288: NEG
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 1
68296: PUSH
68297: LD_INT 1
68299: NEG
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 2
68317: PUSH
68318: LD_INT 1
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 2
68327: PUSH
68328: LD_INT 2
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 1
68347: NEG
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 2
68358: NEG
68359: PUSH
68360: LD_INT 0
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 2
68369: NEG
68370: PUSH
68371: LD_INT 1
68373: NEG
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 1
68381: NEG
68382: PUSH
68383: LD_INT 3
68385: NEG
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: PUSH
68394: LD_INT 2
68396: NEG
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 3
68404: PUSH
68405: LD_INT 2
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 2
68414: PUSH
68415: LD_INT 3
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 2
68424: NEG
68425: PUSH
68426: LD_INT 1
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 3
68435: NEG
68436: PUSH
68437: LD_INT 1
68439: NEG
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68470: LD_ADDR_VAR 0 31
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 0
68487: PUSH
68488: LD_INT 1
68490: NEG
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 1
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 1
68508: PUSH
68509: LD_INT 1
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 0
68518: PUSH
68519: LD_INT 1
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 1
68528: NEG
68529: PUSH
68530: LD_INT 0
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 1
68539: NEG
68540: PUSH
68541: LD_INT 1
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: LD_INT 2
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 1
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: LD_INT 0
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 2
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 2
68594: PUSH
68595: LD_INT 2
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 1
68604: PUSH
68605: LD_INT 2
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: LD_INT 2
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 1
68624: NEG
68625: PUSH
68626: LD_INT 1
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 2
68635: NEG
68636: PUSH
68637: LD_INT 1
68639: NEG
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 2
68647: NEG
68648: PUSH
68649: LD_INT 2
68651: NEG
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 2
68659: NEG
68660: PUSH
68661: LD_INT 3
68663: NEG
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 2
68671: PUSH
68672: LD_INT 1
68674: NEG
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PUSH
68680: LD_INT 3
68682: PUSH
68683: LD_INT 1
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 1
68692: PUSH
68693: LD_INT 3
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: LD_INT 2
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: PUSH
68711: LD_INT 3
68713: NEG
68714: PUSH
68715: LD_INT 2
68717: NEG
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68748: LD_ADDR_VAR 0 32
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: LD_INT 0
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 0
68765: PUSH
68766: LD_INT 1
68768: NEG
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: LD_INT 0
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 1
68786: PUSH
68787: LD_INT 1
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 0
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 1
68806: NEG
68807: PUSH
68808: LD_INT 0
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: LD_INT 1
68821: NEG
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 1
68829: NEG
68830: PUSH
68831: LD_INT 2
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 0
68841: PUSH
68842: LD_INT 2
68844: NEG
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 1
68852: PUSH
68853: LD_INT 1
68855: NEG
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 2
68863: PUSH
68864: LD_INT 1
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 2
68873: PUSH
68874: LD_INT 2
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 2
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: LD_INT 2
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 1
68903: NEG
68904: PUSH
68905: LD_INT 1
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 2
68914: NEG
68915: PUSH
68916: LD_INT 0
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 2
68925: NEG
68926: PUSH
68927: LD_INT 1
68929: NEG
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 1
68937: NEG
68938: PUSH
68939: LD_INT 3
68941: NEG
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: LD_INT 2
68952: NEG
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 3
68960: PUSH
68961: LD_INT 2
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: PUSH
68971: LD_INT 3
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 2
68980: NEG
68981: PUSH
68982: LD_INT 1
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 3
68991: NEG
68992: PUSH
68993: LD_INT 1
68995: NEG
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69026: LD_ADDR_VAR 0 33
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 0
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 1
69054: PUSH
69055: LD_INT 0
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: LD_INT 1
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 0
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 1
69084: NEG
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 1
69095: NEG
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 1
69107: NEG
69108: PUSH
69109: LD_INT 2
69111: NEG
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 1
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 2
69130: PUSH
69131: LD_INT 0
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 2
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 1
69150: PUSH
69151: LD_INT 2
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: LD_INT 2
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: LD_INT 1
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 2
69181: NEG
69182: PUSH
69183: LD_INT 0
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: PUSH
69190: LD_INT 2
69192: NEG
69193: PUSH
69194: LD_INT 1
69196: NEG
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 2
69204: NEG
69205: PUSH
69206: LD_INT 2
69208: NEG
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 2
69216: NEG
69217: PUSH
69218: LD_INT 3
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 2
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 3
69239: PUSH
69240: LD_INT 1
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: LD_INT 3
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 2
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 3
69270: NEG
69271: PUSH
69272: LD_INT 2
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69305: LD_ADDR_VAR 0 34
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 0
69322: PUSH
69323: LD_INT 1
69325: NEG
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 1
69333: PUSH
69334: LD_INT 0
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 0
69353: PUSH
69354: LD_INT 1
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 1
69363: NEG
69364: PUSH
69365: LD_INT 0
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 1
69386: NEG
69387: PUSH
69388: LD_INT 2
69390: NEG
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 0
69398: PUSH
69399: LD_INT 2
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: LD_INT 1
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 2
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 2
69430: PUSH
69431: LD_INT 2
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 1
69440: PUSH
69441: LD_INT 2
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 1
69450: NEG
69451: PUSH
69452: LD_INT 1
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 2
69461: NEG
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 2
69472: NEG
69473: PUSH
69474: LD_INT 1
69476: NEG
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 2
69484: NEG
69485: PUSH
69486: LD_INT 2
69488: NEG
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: LD_INT 3
69500: NEG
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 1
69508: PUSH
69509: LD_INT 2
69511: NEG
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 3
69519: PUSH
69520: LD_INT 2
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: LD_INT 3
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 2
69539: NEG
69540: PUSH
69541: LD_INT 1
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 3
69550: NEG
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69585: LD_ADDR_VAR 0 35
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: LD_INT 1
69605: NEG
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PUSH
69611: LD_INT 1
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: LD_INT 1
69623: PUSH
69624: LD_INT 1
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 0
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: PUSH
69645: LD_INT 0
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 1
69654: NEG
69655: PUSH
69656: LD_INT 1
69658: NEG
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 2
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 2
69676: NEG
69677: PUSH
69678: LD_INT 1
69680: NEG
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69697: LD_ADDR_VAR 0 36
69701: PUSH
69702: LD_INT 0
69704: PUSH
69705: LD_INT 0
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: PUSH
69712: LD_INT 0
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 1
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: LD_INT 1
69735: PUSH
69736: LD_INT 1
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 1
69755: NEG
69756: PUSH
69757: LD_INT 0
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 1
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 1
69778: NEG
69779: PUSH
69780: LD_INT 2
69782: NEG
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 1
69790: PUSH
69791: LD_INT 2
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69809: LD_ADDR_VAR 0 37
69813: PUSH
69814: LD_INT 0
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 0
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 1
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 1
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 0
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 1
69867: NEG
69868: PUSH
69869: LD_INT 0
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 1
69878: NEG
69879: PUSH
69880: LD_INT 1
69882: NEG
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 1
69890: PUSH
69891: LD_INT 1
69893: NEG
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69921: LD_ADDR_VAR 0 38
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 0
69938: PUSH
69939: LD_INT 1
69941: NEG
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 1
69949: PUSH
69950: LD_INT 0
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 1
69959: PUSH
69960: LD_INT 1
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 0
69969: PUSH
69970: LD_INT 1
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 1
69979: NEG
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: PUSH
69988: LD_INT 1
69990: NEG
69991: PUSH
69992: LD_INT 1
69994: NEG
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: LD_INT 1
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 2
70012: NEG
70013: PUSH
70014: LD_INT 1
70016: NEG
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70033: LD_ADDR_VAR 0 39
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: LD_INT 0
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 0
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 1
70061: PUSH
70062: LD_INT 0
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 1
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 0
70081: PUSH
70082: LD_INT 1
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 1
70091: NEG
70092: PUSH
70093: LD_INT 0
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 1
70102: NEG
70103: PUSH
70104: LD_INT 1
70106: NEG
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 1
70114: NEG
70115: PUSH
70116: LD_INT 2
70118: NEG
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: PUSH
70127: LD_INT 2
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70145: LD_ADDR_VAR 0 40
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: LD_INT 0
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 0
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: LD_INT 1
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 1
70214: NEG
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 1
70226: PUSH
70227: LD_INT 1
70229: NEG
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PUSH
70235: LD_INT 1
70237: NEG
70238: PUSH
70239: LD_INT 1
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70257: LD_ADDR_VAR 0 41
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: LD_INT 0
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 1
70285: PUSH
70286: LD_INT 0
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: LD_INT 1
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 0
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: LD_INT 0
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: LD_INT 1
70326: NEG
70327: PUSH
70328: LD_INT 1
70330: NEG
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: LD_INT 2
70342: NEG
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: LD_INT 2
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 1
70401: NEG
70402: PUSH
70403: LD_INT 1
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 2
70412: NEG
70413: PUSH
70414: LD_INT 0
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: LD_INT 1
70427: NEG
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 2
70435: NEG
70436: PUSH
70437: LD_INT 2
70439: NEG
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 2
70447: NEG
70448: PUSH
70449: LD_INT 3
70451: NEG
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: LD_INT 1
70462: NEG
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 3
70470: PUSH
70471: LD_INT 0
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 3
70480: PUSH
70481: LD_INT 1
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 3
70490: PUSH
70491: LD_INT 2
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 3
70500: PUSH
70501: LD_INT 3
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 2
70510: PUSH
70511: LD_INT 3
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 2
70520: NEG
70521: PUSH
70522: LD_INT 1
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: LD_INT 3
70531: NEG
70532: PUSH
70533: LD_INT 0
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 3
70542: NEG
70543: PUSH
70544: LD_INT 1
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 3
70554: NEG
70555: PUSH
70556: LD_INT 2
70558: NEG
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 3
70566: NEG
70567: PUSH
70568: LD_INT 3
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70607: LD_ADDR_VAR 0 42
70611: PUSH
70612: LD_INT 0
70614: PUSH
70615: LD_INT 0
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 1
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: PUSH
70646: LD_INT 1
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: LD_INT 1
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 1
70665: NEG
70666: PUSH
70667: LD_INT 0
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: LD_INT 1
70680: NEG
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 1
70688: NEG
70689: PUSH
70690: LD_INT 2
70692: NEG
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 0
70700: PUSH
70701: LD_INT 2
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 2
70722: PUSH
70723: LD_INT 1
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 2
70732: PUSH
70733: LD_INT 2
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: LD_INT 2
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 0
70752: PUSH
70753: LD_INT 2
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 2
70773: NEG
70774: PUSH
70775: LD_INT 1
70777: NEG
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 2
70785: NEG
70786: PUSH
70787: LD_INT 2
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 2
70797: NEG
70798: PUSH
70799: LD_INT 3
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 1
70809: NEG
70810: PUSH
70811: LD_INT 3
70813: NEG
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: LD_INT 0
70821: PUSH
70822: LD_INT 3
70824: NEG
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 2
70835: NEG
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 3
70843: PUSH
70844: LD_INT 2
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 3
70853: PUSH
70854: LD_INT 3
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 2
70863: PUSH
70864: LD_INT 3
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 1
70873: PUSH
70874: LD_INT 3
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 0
70883: PUSH
70884: LD_INT 3
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 1
70893: NEG
70894: PUSH
70895: LD_INT 2
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 3
70904: NEG
70905: PUSH
70906: LD_INT 2
70908: NEG
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 3
70916: NEG
70917: PUSH
70918: LD_INT 3
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70957: LD_ADDR_VAR 0 43
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: LD_INT 0
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 0
70974: PUSH
70975: LD_INT 1
70977: NEG
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 1
70985: PUSH
70986: LD_INT 0
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: LD_INT 1
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 0
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: LD_INT 1
71015: NEG
71016: PUSH
71017: LD_INT 0
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 1
71026: NEG
71027: PUSH
71028: LD_INT 1
71030: NEG
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 1
71038: NEG
71039: PUSH
71040: LD_INT 2
71042: NEG
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 0
71050: PUSH
71051: LD_INT 2
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 1
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 2
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 2
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: LD_INT 2
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 0
71102: PUSH
71103: LD_INT 2
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: NEG
71113: PUSH
71114: LD_INT 1
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 2
71123: NEG
71124: PUSH
71125: LD_INT 0
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 2
71134: NEG
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 1
71146: NEG
71147: PUSH
71148: LD_INT 3
71150: NEG
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: LD_INT 3
71161: NEG
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 1
71169: PUSH
71170: LD_INT 2
71172: NEG
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 2
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 3
71191: PUSH
71192: LD_INT 0
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 3
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: LD_INT 3
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 0
71221: PUSH
71222: LD_INT 3
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 1
71231: NEG
71232: PUSH
71233: LD_INT 2
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 2
71242: NEG
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 3
71253: NEG
71254: PUSH
71255: LD_INT 0
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 3
71264: NEG
71265: PUSH
71266: LD_INT 1
71268: NEG
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71305: LD_ADDR_VAR 0 44
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 0
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: LD_INT 1
71343: PUSH
71344: LD_INT 1
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 0
71353: PUSH
71354: LD_INT 1
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 1
71363: NEG
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: LD_INT 1
71374: NEG
71375: PUSH
71376: LD_INT 1
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: NEG
71387: PUSH
71388: LD_INT 2
71390: NEG
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 1
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 2
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 2
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 2
71429: PUSH
71430: LD_INT 2
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: PUSH
71440: LD_INT 2
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 1
71449: NEG
71450: PUSH
71451: LD_INT 1
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 2
71460: NEG
71461: PUSH
71462: LD_INT 0
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: LD_INT 1
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 2
71483: NEG
71484: PUSH
71485: LD_INT 2
71487: NEG
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 2
71495: NEG
71496: PUSH
71497: LD_INT 3
71499: NEG
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 2
71507: PUSH
71508: LD_INT 1
71510: NEG
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 3
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 3
71528: PUSH
71529: LD_INT 1
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 3
71538: PUSH
71539: LD_INT 2
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 3
71548: PUSH
71549: LD_INT 3
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 2
71558: PUSH
71559: LD_INT 3
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 2
71568: NEG
71569: PUSH
71570: LD_INT 1
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 3
71579: NEG
71580: PUSH
71581: LD_INT 0
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 3
71590: NEG
71591: PUSH
71592: LD_INT 1
71594: NEG
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: LD_INT 3
71602: NEG
71603: PUSH
71604: LD_INT 2
71606: NEG
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 3
71614: NEG
71615: PUSH
71616: LD_INT 3
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71655: LD_ADDR_VAR 0 45
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: LD_INT 1
71675: NEG
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 1
71693: PUSH
71694: LD_INT 1
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 0
71703: PUSH
71704: LD_INT 1
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 1
71713: NEG
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 1
71728: NEG
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 1
71736: NEG
71737: PUSH
71738: LD_INT 2
71740: NEG
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 0
71748: PUSH
71749: LD_INT 2
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 1
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 2
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 2
71780: PUSH
71781: LD_INT 2
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 1
71790: PUSH
71791: LD_INT 2
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: LD_INT 2
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: LD_INT 1
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: LD_INT 2
71821: NEG
71822: PUSH
71823: LD_INT 1
71825: NEG
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: LD_INT 2
71833: NEG
71834: PUSH
71835: LD_INT 2
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 2
71845: NEG
71846: PUSH
71847: LD_INT 3
71849: NEG
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 1
71857: NEG
71858: PUSH
71859: LD_INT 3
71861: NEG
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 0
71869: PUSH
71870: LD_INT 3
71872: NEG
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 1
71880: PUSH
71881: LD_INT 2
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 3
71891: PUSH
71892: LD_INT 2
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 3
71901: PUSH
71902: LD_INT 3
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 2
71911: PUSH
71912: LD_INT 3
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 1
71921: PUSH
71922: LD_INT 3
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: LD_INT 3
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: LD_INT 2
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: LD_INT 3
71952: NEG
71953: PUSH
71954: LD_INT 2
71956: NEG
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 3
71964: NEG
71965: PUSH
71966: LD_INT 3
71968: NEG
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72005: LD_ADDR_VAR 0 46
72009: PUSH
72010: LD_INT 0
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: PUSH
72044: LD_INT 1
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 0
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 1
72063: NEG
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 1
72074: NEG
72075: PUSH
72076: LD_INT 1
72078: NEG
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: LD_INT 2
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 0
72098: PUSH
72099: LD_INT 2
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 2
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 2
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 2
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 1
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 2
72171: NEG
72172: PUSH
72173: LD_INT 0
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 2
72182: NEG
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: PUSH
72192: LD_INT 1
72194: NEG
72195: PUSH
72196: LD_INT 3
72198: NEG
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 0
72206: PUSH
72207: LD_INT 3
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: LD_INT 2
72220: NEG
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 2
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: PUSH
72237: LD_INT 3
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 3
72249: PUSH
72250: LD_INT 1
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: LD_INT 3
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 0
72269: PUSH
72270: LD_INT 3
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 1
72279: NEG
72280: PUSH
72281: LD_INT 2
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 2
72290: NEG
72291: PUSH
72292: LD_INT 1
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PUSH
72299: LD_INT 3
72301: NEG
72302: PUSH
72303: LD_INT 0
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 3
72312: NEG
72313: PUSH
72314: LD_INT 1
72316: NEG
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: LIST
72351: LIST
72352: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72353: LD_ADDR_VAR 0 47
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: LD_INT 1
72373: NEG
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: LD_INT 0
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 1
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 1
72411: NEG
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: NEG
72423: PUSH
72424: LD_INT 1
72426: NEG
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 1
72434: NEG
72435: PUSH
72436: LD_INT 2
72438: NEG
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 0
72446: PUSH
72447: LD_INT 2
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: PUSH
72458: LD_INT 1
72460: NEG
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 2
72468: NEG
72469: PUSH
72470: LD_INT 1
72472: NEG
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 2
72480: NEG
72481: PUSH
72482: LD_INT 2
72484: NEG
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72504: LD_ADDR_VAR 0 48
72508: PUSH
72509: LD_INT 0
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 0
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 1
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 1
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: LD_INT 0
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: NEG
72574: PUSH
72575: LD_INT 1
72577: NEG
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: LD_INT 2
72589: NEG
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 0
72597: PUSH
72598: LD_INT 2
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: LD_INT 1
72611: NEG
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 2
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 2
72629: PUSH
72630: LD_INT 1
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72651: LD_ADDR_VAR 0 49
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: LD_INT 0
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 0
72668: PUSH
72669: LD_INT 1
72671: NEG
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: PUSH
72680: LD_INT 0
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: LD_INT 1
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: LD_INT 1
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 1
72709: NEG
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 1
72720: NEG
72721: PUSH
72722: LD_INT 1
72724: NEG
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: LD_INT 1
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 2
72743: PUSH
72744: LD_INT 0
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 2
72753: PUSH
72754: LD_INT 1
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 2
72763: PUSH
72764: LD_INT 2
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 1
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: LIST
72794: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72795: LD_ADDR_VAR 0 50
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 0
72812: PUSH
72813: LD_INT 1
72815: NEG
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: LD_INT 0
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 1
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 0
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 1
72853: NEG
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 2
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 2
72886: PUSH
72887: LD_INT 2
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: LD_INT 1
72896: PUSH
72897: LD_INT 2
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: LD_INT 0
72906: PUSH
72907: LD_INT 2
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 1
72916: NEG
72917: PUSH
72918: LD_INT 1
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72939: LD_ADDR_VAR 0 51
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: LD_INT 0
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 1
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: LD_INT 1
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: LD_INT 1
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 1
72997: NEG
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 1
73008: NEG
73009: PUSH
73010: LD_INT 1
73012: NEG
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 1
73020: PUSH
73021: LD_INT 2
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 2
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: NEG
73041: PUSH
73042: LD_INT 1
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 2
73051: NEG
73052: PUSH
73053: LD_INT 0
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 2
73062: NEG
73063: PUSH
73064: LD_INT 1
73066: NEG
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73086: LD_ADDR_VAR 0 52
73090: PUSH
73091: LD_INT 0
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 0
73103: PUSH
73104: LD_INT 1
73106: NEG
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: LD_INT 0
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 1
73124: PUSH
73125: LD_INT 1
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 0
73134: PUSH
73135: LD_INT 1
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 0
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 1
73155: NEG
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 1
73167: NEG
73168: PUSH
73169: LD_INT 2
73171: NEG
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 1
73179: NEG
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 2
73190: NEG
73191: PUSH
73192: LD_INT 0
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 2
73201: NEG
73202: PUSH
73203: LD_INT 1
73205: NEG
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 2
73213: NEG
73214: PUSH
73215: LD_INT 2
73217: NEG
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73237: LD_ADDR_VAR 0 53
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: LD_INT 0
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 0
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 1
73265: PUSH
73266: LD_INT 0
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 1
73275: PUSH
73276: LD_INT 1
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 0
73285: PUSH
73286: LD_INT 1
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: LD_INT 1
73295: NEG
73296: PUSH
73297: LD_INT 0
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: PUSH
73304: LD_INT 1
73306: NEG
73307: PUSH
73308: LD_INT 1
73310: NEG
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 1
73318: NEG
73319: PUSH
73320: LD_INT 2
73322: NEG
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: LD_INT 2
73333: NEG
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 1
73341: PUSH
73342: LD_INT 1
73344: NEG
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 2
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 2
73362: PUSH
73363: LD_INT 1
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: LD_INT 2
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 1
73382: PUSH
73383: LD_INT 2
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: LD_INT 2
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 1
73402: NEG
73403: PUSH
73404: LD_INT 1
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 2
73413: NEG
73414: PUSH
73415: LD_INT 0
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 2
73424: NEG
73425: PUSH
73426: LD_INT 1
73428: NEG
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 2
73436: NEG
73437: PUSH
73438: LD_INT 2
73440: NEG
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73467: LD_ADDR_VAR 0 54
73471: PUSH
73472: LD_INT 0
73474: PUSH
73475: LD_INT 0
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: LD_INT 1
73487: NEG
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 1
73495: PUSH
73496: LD_INT 0
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: LD_INT 1
73505: PUSH
73506: LD_INT 1
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 0
73515: PUSH
73516: LD_INT 1
73518: PUSH
73519: EMPTY
73520: LIST
73521: LIST
73522: PUSH
73523: LD_INT 1
73525: NEG
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 1
73536: NEG
73537: PUSH
73538: LD_INT 1
73540: NEG
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 1
73548: NEG
73549: PUSH
73550: LD_INT 2
73552: NEG
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: LD_INT 2
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: LD_INT 1
73574: NEG
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: LD_INT 2
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 2
73602: PUSH
73603: LD_INT 2
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 1
73612: PUSH
73613: LD_INT 2
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 2
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 1
73632: NEG
73633: PUSH
73634: LD_INT 1
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 2
73643: NEG
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: NEG
73655: PUSH
73656: LD_INT 1
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 2
73666: NEG
73667: PUSH
73668: LD_INT 2
73670: NEG
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: LIST
73680: LIST
73681: LIST
73682: LIST
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: LIST
73688: LIST
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: LIST
73694: LIST
73695: LIST
73696: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73697: LD_ADDR_VAR 0 55
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 0
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 1
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 1
73735: PUSH
73736: LD_INT 1
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 0
73745: PUSH
73746: LD_INT 1
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 1
73766: NEG
73767: PUSH
73768: LD_INT 1
73770: NEG
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 1
73778: NEG
73779: PUSH
73780: LD_INT 2
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 0
73790: PUSH
73791: LD_INT 2
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 1
73801: PUSH
73802: LD_INT 1
73804: NEG
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 2
73822: PUSH
73823: LD_INT 1
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 2
73832: PUSH
73833: LD_INT 2
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 1
73842: PUSH
73843: LD_INT 2
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 0
73852: PUSH
73853: LD_INT 2
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 1
73862: NEG
73863: PUSH
73864: LD_INT 1
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 2
73873: NEG
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 2
73884: NEG
73885: PUSH
73886: LD_INT 1
73888: NEG
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 2
73896: NEG
73897: PUSH
73898: LD_INT 2
73900: NEG
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73927: LD_ADDR_VAR 0 56
73931: PUSH
73932: LD_INT 0
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 0
73944: PUSH
73945: LD_INT 1
73947: NEG
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 1
73955: PUSH
73956: LD_INT 0
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 1
73965: PUSH
73966: LD_INT 1
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 0
73975: PUSH
73976: LD_INT 1
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 1
73985: NEG
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: LD_INT 1
74000: NEG
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 1
74008: NEG
74009: PUSH
74010: LD_INT 2
74012: NEG
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_INT 0
74020: PUSH
74021: LD_INT 2
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 1
74031: PUSH
74032: LD_INT 1
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 2
74052: PUSH
74053: LD_INT 1
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 2
74062: PUSH
74063: LD_INT 2
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 1
74072: PUSH
74073: LD_INT 2
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 0
74082: PUSH
74083: LD_INT 2
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 1
74092: NEG
74093: PUSH
74094: LD_INT 1
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 2
74103: NEG
74104: PUSH
74105: LD_INT 0
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 2
74114: NEG
74115: PUSH
74116: LD_INT 1
74118: NEG
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 2
74126: NEG
74127: PUSH
74128: LD_INT 2
74130: NEG
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: LIST
74150: LIST
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74157: LD_ADDR_VAR 0 57
74161: PUSH
74162: LD_INT 0
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 0
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 1
74195: PUSH
74196: LD_INT 1
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 0
74205: PUSH
74206: LD_INT 1
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 1
74226: NEG
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 1
74238: NEG
74239: PUSH
74240: LD_INT 2
74242: NEG
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 0
74250: PUSH
74251: LD_INT 2
74253: NEG
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 1
74261: PUSH
74262: LD_INT 1
74264: NEG
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 2
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 2
74282: PUSH
74283: LD_INT 1
74285: PUSH
74286: EMPTY
74287: LIST
74288: LIST
74289: PUSH
74290: LD_INT 2
74292: PUSH
74293: LD_INT 2
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 1
74302: PUSH
74303: LD_INT 2
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: LD_INT 2
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 1
74322: NEG
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: LD_INT 0
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 2
74344: NEG
74345: PUSH
74346: LD_INT 1
74348: NEG
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 2
74356: NEG
74357: PUSH
74358: LD_INT 2
74360: NEG
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: LIST
74380: LIST
74381: LIST
74382: LIST
74383: LIST
74384: LIST
74385: LIST
74386: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74387: LD_ADDR_VAR 0 58
74391: PUSH
74392: LD_INT 0
74394: PUSH
74395: LD_INT 0
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 0
74404: PUSH
74405: LD_INT 1
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 1
74415: PUSH
74416: LD_INT 0
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: PUSH
74426: LD_INT 1
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: LD_INT 1
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: LD_INT 0
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 1
74456: NEG
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 1
74468: NEG
74469: PUSH
74470: LD_INT 2
74472: NEG
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: LD_INT 2
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 2
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 2
74512: PUSH
74513: LD_INT 1
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 2
74522: PUSH
74523: LD_INT 2
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: LD_INT 2
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: LD_INT 2
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 1
74552: NEG
74553: PUSH
74554: LD_INT 1
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 2
74563: NEG
74564: PUSH
74565: LD_INT 0
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 2
74574: NEG
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: NEG
74587: PUSH
74588: LD_INT 2
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74617: LD_ADDR_VAR 0 59
74621: PUSH
74622: LD_INT 0
74624: PUSH
74625: LD_INT 0
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: LD_INT 1
74637: NEG
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 1
74655: PUSH
74656: LD_INT 1
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: PUSH
74663: LD_INT 0
74665: PUSH
74666: LD_INT 1
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 1
74675: NEG
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: NEG
74687: PUSH
74688: LD_INT 1
74690: NEG
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: LIST
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74705: LD_ADDR_VAR 0 60
74709: PUSH
74710: LD_INT 0
74712: PUSH
74713: LD_INT 0
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: LD_INT 1
74725: NEG
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 1
74733: PUSH
74734: LD_INT 0
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: LD_INT 1
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 0
74753: PUSH
74754: LD_INT 1
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: LD_INT 0
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74793: LD_ADDR_VAR 0 61
74797: PUSH
74798: LD_INT 0
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 0
74810: PUSH
74811: LD_INT 1
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: LD_INT 0
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 1
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 0
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 1
74862: NEG
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74881: LD_ADDR_VAR 0 62
74885: PUSH
74886: LD_INT 0
74888: PUSH
74889: LD_INT 0
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: LD_INT 1
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: LD_INT 0
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: LD_INT 1
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: LD_INT 1
74954: NEG
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74969: LD_ADDR_VAR 0 63
74973: PUSH
74974: LD_INT 0
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 0
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: PUSH
74998: LD_INT 0
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 1
75007: PUSH
75008: LD_INT 1
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 0
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 1
75027: NEG
75028: PUSH
75029: LD_INT 0
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 1
75038: NEG
75039: PUSH
75040: LD_INT 1
75042: NEG
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: LIST
75055: LIST
75056: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75057: LD_ADDR_VAR 0 64
75061: PUSH
75062: LD_INT 0
75064: PUSH
75065: LD_INT 0
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: LD_INT 1
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: LD_INT 0
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: LD_INT 1
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: LD_INT 1
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 1
75115: NEG
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 1
75126: NEG
75127: PUSH
75128: LD_INT 1
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: ST_TO_ADDR
// end ; 1 :
75145: GO 81042
75147: LD_INT 1
75149: DOUBLE
75150: EQUAL
75151: IFTRUE 75155
75153: GO 77778
75155: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75156: LD_ADDR_VAR 0 11
75160: PUSH
75161: LD_INT 1
75163: NEG
75164: PUSH
75165: LD_INT 3
75167: NEG
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: LD_INT 3
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: PUSH
75187: LD_INT 2
75189: NEG
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: LIST
75199: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75200: LD_ADDR_VAR 0 12
75204: PUSH
75205: LD_INT 2
75207: PUSH
75208: LD_INT 1
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 3
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 3
75228: PUSH
75229: LD_INT 1
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: LIST
75240: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75241: LD_ADDR_VAR 0 13
75245: PUSH
75246: LD_INT 3
75248: PUSH
75249: LD_INT 2
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 3
75258: PUSH
75259: LD_INT 3
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 2
75268: PUSH
75269: LD_INT 3
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: LIST
75280: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75281: LD_ADDR_VAR 0 14
75285: PUSH
75286: LD_INT 1
75288: PUSH
75289: LD_INT 3
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 0
75298: PUSH
75299: LD_INT 3
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 1
75308: NEG
75309: PUSH
75310: LD_INT 2
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: LIST
75321: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75322: LD_ADDR_VAR 0 15
75326: PUSH
75327: LD_INT 2
75329: NEG
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 3
75340: NEG
75341: PUSH
75342: LD_INT 0
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: LD_INT 3
75351: NEG
75352: PUSH
75353: LD_INT 1
75355: NEG
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: LIST
75365: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75366: LD_ADDR_VAR 0 16
75370: PUSH
75371: LD_INT 2
75373: NEG
75374: PUSH
75375: LD_INT 3
75377: NEG
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 3
75385: NEG
75386: PUSH
75387: LD_INT 2
75389: NEG
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 3
75397: NEG
75398: PUSH
75399: LD_INT 3
75401: NEG
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: LIST
75411: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75412: LD_ADDR_VAR 0 17
75416: PUSH
75417: LD_INT 1
75419: NEG
75420: PUSH
75421: LD_INT 3
75423: NEG
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 0
75431: PUSH
75432: LD_INT 3
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: PUSH
75443: LD_INT 2
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: LIST
75455: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75456: LD_ADDR_VAR 0 18
75460: PUSH
75461: LD_INT 2
75463: PUSH
75464: LD_INT 1
75466: NEG
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 3
75474: PUSH
75475: LD_INT 0
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 3
75484: PUSH
75485: LD_INT 1
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: LIST
75496: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75497: LD_ADDR_VAR 0 19
75501: PUSH
75502: LD_INT 3
75504: PUSH
75505: LD_INT 2
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 3
75514: PUSH
75515: LD_INT 3
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PUSH
75522: LD_INT 2
75524: PUSH
75525: LD_INT 3
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: LIST
75536: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75537: LD_ADDR_VAR 0 20
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: LD_INT 3
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 0
75554: PUSH
75555: LD_INT 3
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: NEG
75565: PUSH
75566: LD_INT 2
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: LIST
75577: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75578: LD_ADDR_VAR 0 21
75582: PUSH
75583: LD_INT 2
75585: NEG
75586: PUSH
75587: LD_INT 1
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 3
75596: NEG
75597: PUSH
75598: LD_INT 0
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 3
75607: NEG
75608: PUSH
75609: LD_INT 1
75611: NEG
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: LIST
75621: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75622: LD_ADDR_VAR 0 22
75626: PUSH
75627: LD_INT 2
75629: NEG
75630: PUSH
75631: LD_INT 3
75633: NEG
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 3
75641: NEG
75642: PUSH
75643: LD_INT 2
75645: NEG
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 3
75653: NEG
75654: PUSH
75655: LD_INT 3
75657: NEG
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: LIST
75667: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75668: LD_ADDR_VAR 0 23
75672: PUSH
75673: LD_INT 0
75675: PUSH
75676: LD_INT 3
75678: NEG
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 1
75686: NEG
75687: PUSH
75688: LD_INT 4
75690: NEG
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 1
75698: PUSH
75699: LD_INT 3
75701: NEG
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: LIST
75711: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75712: LD_ADDR_VAR 0 24
75716: PUSH
75717: LD_INT 3
75719: PUSH
75720: LD_INT 0
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 3
75729: PUSH
75730: LD_INT 1
75732: NEG
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 4
75740: PUSH
75741: LD_INT 1
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75753: LD_ADDR_VAR 0 25
75757: PUSH
75758: LD_INT 3
75760: PUSH
75761: LD_INT 3
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 4
75770: PUSH
75771: LD_INT 3
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 3
75780: PUSH
75781: LD_INT 4
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: LIST
75792: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75793: LD_ADDR_VAR 0 26
75797: PUSH
75798: LD_INT 0
75800: PUSH
75801: LD_INT 3
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: LD_INT 4
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 1
75820: NEG
75821: PUSH
75822: LD_INT 3
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: LIST
75833: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75834: LD_ADDR_VAR 0 27
75838: PUSH
75839: LD_INT 3
75841: NEG
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 3
75852: NEG
75853: PUSH
75854: LD_INT 1
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 4
75863: NEG
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: LIST
75877: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75878: LD_ADDR_VAR 0 28
75882: PUSH
75883: LD_INT 3
75885: NEG
75886: PUSH
75887: LD_INT 3
75889: NEG
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 3
75897: NEG
75898: PUSH
75899: LD_INT 4
75901: NEG
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 4
75909: NEG
75910: PUSH
75911: LD_INT 3
75913: NEG
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: LIST
75923: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75924: LD_ADDR_VAR 0 29
75928: PUSH
75929: LD_INT 1
75931: NEG
75932: PUSH
75933: LD_INT 3
75935: NEG
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PUSH
75941: LD_INT 0
75943: PUSH
75944: LD_INT 3
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 1
75954: PUSH
75955: LD_INT 2
75957: NEG
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 1
75965: NEG
75966: PUSH
75967: LD_INT 4
75969: NEG
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 0
75977: PUSH
75978: LD_INT 4
75980: NEG
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: LD_INT 3
75991: NEG
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 1
75999: NEG
76000: PUSH
76001: LD_INT 5
76003: NEG
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 0
76011: PUSH
76012: LD_INT 5
76014: NEG
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 1
76022: PUSH
76023: LD_INT 4
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 1
76033: NEG
76034: PUSH
76035: LD_INT 6
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 0
76045: PUSH
76046: LD_INT 6
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 5
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76079: LD_ADDR_VAR 0 30
76083: PUSH
76084: LD_INT 2
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 3
76097: PUSH
76098: LD_INT 0
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 3
76107: PUSH
76108: LD_INT 1
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 3
76117: PUSH
76118: LD_INT 1
76120: NEG
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 4
76128: PUSH
76129: LD_INT 0
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 4
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 4
76148: PUSH
76149: LD_INT 1
76151: NEG
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 5
76159: PUSH
76160: LD_INT 0
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 5
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 5
76179: PUSH
76180: LD_INT 1
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 6
76190: PUSH
76191: LD_INT 0
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: PUSH
76198: LD_INT 6
76200: PUSH
76201: LD_INT 1
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76222: LD_ADDR_VAR 0 31
76226: PUSH
76227: LD_INT 3
76229: PUSH
76230: LD_INT 2
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 3
76239: PUSH
76240: LD_INT 3
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 2
76249: PUSH
76250: LD_INT 3
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 4
76259: PUSH
76260: LD_INT 3
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 4
76269: PUSH
76270: LD_INT 4
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 3
76279: PUSH
76280: LD_INT 4
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 5
76289: PUSH
76290: LD_INT 4
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 5
76299: PUSH
76300: LD_INT 5
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 4
76309: PUSH
76310: LD_INT 5
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 6
76319: PUSH
76320: LD_INT 5
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 6
76329: PUSH
76330: LD_INT 6
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 5
76339: PUSH
76340: LD_INT 6
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: LIST
76351: LIST
76352: LIST
76353: LIST
76354: LIST
76355: LIST
76356: LIST
76357: LIST
76358: LIST
76359: LIST
76360: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76361: LD_ADDR_VAR 0 32
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: LD_INT 3
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 0
76378: PUSH
76379: LD_INT 3
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 1
76388: NEG
76389: PUSH
76390: LD_INT 2
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 1
76399: PUSH
76400: LD_INT 4
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 0
76409: PUSH
76410: LD_INT 4
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 1
76419: NEG
76420: PUSH
76421: LD_INT 3
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 1
76430: PUSH
76431: LD_INT 5
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 0
76440: PUSH
76441: LD_INT 5
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 1
76450: NEG
76451: PUSH
76452: LD_INT 4
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: LD_INT 6
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: PUSH
76469: LD_INT 0
76471: PUSH
76472: LD_INT 6
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 1
76481: NEG
76482: PUSH
76483: LD_INT 5
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76504: LD_ADDR_VAR 0 33
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 1
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 3
76522: NEG
76523: PUSH
76524: LD_INT 0
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 3
76533: NEG
76534: PUSH
76535: LD_INT 1
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 3
76545: NEG
76546: PUSH
76547: LD_INT 1
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 4
76556: NEG
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 4
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 4
76579: NEG
76580: PUSH
76581: LD_INT 1
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 5
76590: NEG
76591: PUSH
76592: LD_INT 0
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 5
76601: NEG
76602: PUSH
76603: LD_INT 1
76605: NEG
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 5
76613: NEG
76614: PUSH
76615: LD_INT 1
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 6
76624: NEG
76625: PUSH
76626: LD_INT 0
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 6
76635: NEG
76636: PUSH
76637: LD_INT 1
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76659: LD_ADDR_VAR 0 34
76663: PUSH
76664: LD_INT 2
76666: NEG
76667: PUSH
76668: LD_INT 3
76670: NEG
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 3
76678: NEG
76679: PUSH
76680: LD_INT 2
76682: NEG
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 3
76690: NEG
76691: PUSH
76692: LD_INT 3
76694: NEG
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 3
76702: NEG
76703: PUSH
76704: LD_INT 4
76706: NEG
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 4
76714: NEG
76715: PUSH
76716: LD_INT 3
76718: NEG
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 4
76726: NEG
76727: PUSH
76728: LD_INT 4
76730: NEG
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 4
76738: NEG
76739: PUSH
76740: LD_INT 5
76742: NEG
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 5
76750: NEG
76751: PUSH
76752: LD_INT 4
76754: NEG
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 5
76762: NEG
76763: PUSH
76764: LD_INT 5
76766: NEG
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 5
76774: NEG
76775: PUSH
76776: LD_INT 6
76778: NEG
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 6
76786: NEG
76787: PUSH
76788: LD_INT 5
76790: NEG
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 6
76798: NEG
76799: PUSH
76800: LD_INT 6
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76822: LD_ADDR_VAR 0 41
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: LD_INT 2
76832: NEG
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: LD_INT 3
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 1
76852: PUSH
76853: LD_INT 2
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: LIST
76865: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76866: LD_ADDR_VAR 0 42
76870: PUSH
76871: LD_INT 2
76873: PUSH
76874: LD_INT 0
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 2
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 3
76894: PUSH
76895: LD_INT 1
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: LIST
76906: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76907: LD_ADDR_VAR 0 43
76911: PUSH
76912: LD_INT 2
76914: PUSH
76915: LD_INT 2
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 3
76924: PUSH
76925: LD_INT 2
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 2
76934: PUSH
76935: LD_INT 3
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: LIST
76946: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76947: LD_ADDR_VAR 0 44
76951: PUSH
76952: LD_INT 0
76954: PUSH
76955: LD_INT 2
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: LD_INT 3
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 1
76974: NEG
76975: PUSH
76976: LD_INT 2
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: LIST
76987: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76988: LD_ADDR_VAR 0 45
76992: PUSH
76993: LD_INT 2
76995: NEG
76996: PUSH
76997: LD_INT 0
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 2
77006: NEG
77007: PUSH
77008: LD_INT 1
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 3
77017: NEG
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: LIST
77031: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77032: LD_ADDR_VAR 0 46
77036: PUSH
77037: LD_INT 2
77039: NEG
77040: PUSH
77041: LD_INT 2
77043: NEG
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 2
77051: NEG
77052: PUSH
77053: LD_INT 3
77055: NEG
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 3
77063: NEG
77064: PUSH
77065: LD_INT 2
77067: NEG
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: LIST
77077: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77078: LD_ADDR_VAR 0 47
77082: PUSH
77083: LD_INT 2
77085: NEG
77086: PUSH
77087: LD_INT 3
77089: NEG
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: LD_INT 3
77101: NEG
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77111: LD_ADDR_VAR 0 48
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 2
77121: NEG
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 2
77129: PUSH
77130: LD_INT 1
77132: NEG
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77142: LD_ADDR_VAR 0 49
77146: PUSH
77147: LD_INT 3
77149: PUSH
77150: LD_INT 1
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 3
77159: PUSH
77160: LD_INT 2
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77171: LD_ADDR_VAR 0 50
77175: PUSH
77176: LD_INT 2
77178: PUSH
77179: LD_INT 3
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 1
77188: PUSH
77189: LD_INT 3
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77200: LD_ADDR_VAR 0 51
77204: PUSH
77205: LD_INT 1
77207: NEG
77208: PUSH
77209: LD_INT 2
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 2
77218: NEG
77219: PUSH
77220: LD_INT 1
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77231: LD_ADDR_VAR 0 52
77235: PUSH
77236: LD_INT 3
77238: NEG
77239: PUSH
77240: LD_INT 1
77242: NEG
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 3
77250: NEG
77251: PUSH
77252: LD_INT 2
77254: NEG
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77264: LD_ADDR_VAR 0 53
77268: PUSH
77269: LD_INT 1
77271: NEG
77272: PUSH
77273: LD_INT 3
77275: NEG
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 0
77283: PUSH
77284: LD_INT 3
77286: NEG
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 1
77294: PUSH
77295: LD_INT 2
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: LIST
77307: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77308: LD_ADDR_VAR 0 54
77312: PUSH
77313: LD_INT 2
77315: PUSH
77316: LD_INT 1
77318: NEG
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 3
77326: PUSH
77327: LD_INT 0
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 3
77336: PUSH
77337: LD_INT 1
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: LIST
77348: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77349: LD_ADDR_VAR 0 55
77353: PUSH
77354: LD_INT 3
77356: PUSH
77357: LD_INT 2
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 3
77366: PUSH
77367: LD_INT 3
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 2
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: LIST
77388: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77389: LD_ADDR_VAR 0 56
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: LD_INT 3
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 0
77406: PUSH
77407: LD_INT 3
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: NEG
77417: PUSH
77418: LD_INT 2
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: LIST
77429: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77430: LD_ADDR_VAR 0 57
77434: PUSH
77435: LD_INT 2
77437: NEG
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 3
77448: NEG
77449: PUSH
77450: LD_INT 0
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: LD_INT 3
77459: NEG
77460: PUSH
77461: LD_INT 1
77463: NEG
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: LIST
77473: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77474: LD_ADDR_VAR 0 58
77478: PUSH
77479: LD_INT 2
77481: NEG
77482: PUSH
77483: LD_INT 3
77485: NEG
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: LD_INT 3
77493: NEG
77494: PUSH
77495: LD_INT 2
77497: NEG
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 3
77505: NEG
77506: PUSH
77507: LD_INT 3
77509: NEG
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: LIST
77519: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77520: LD_ADDR_VAR 0 59
77524: PUSH
77525: LD_INT 1
77527: NEG
77528: PUSH
77529: LD_INT 2
77531: NEG
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 0
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 1
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: LIST
77563: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77564: LD_ADDR_VAR 0 60
77568: PUSH
77569: LD_INT 1
77571: PUSH
77572: LD_INT 1
77574: NEG
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 2
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 2
77592: PUSH
77593: LD_INT 1
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77605: LD_ADDR_VAR 0 61
77609: PUSH
77610: LD_INT 2
77612: PUSH
77613: LD_INT 1
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 2
77622: PUSH
77623: LD_INT 2
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 1
77632: PUSH
77633: LD_INT 2
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: LIST
77644: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77645: LD_ADDR_VAR 0 62
77649: PUSH
77650: LD_INT 1
77652: PUSH
77653: LD_INT 2
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: LD_INT 2
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 1
77672: NEG
77673: PUSH
77674: LD_INT 1
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: LIST
77685: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77686: LD_ADDR_VAR 0 63
77690: PUSH
77691: LD_INT 1
77693: NEG
77694: PUSH
77695: LD_INT 1
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 2
77704: NEG
77705: PUSH
77706: LD_INT 0
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 2
77715: NEG
77716: PUSH
77717: LD_INT 1
77719: NEG
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: LIST
77729: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77730: LD_ADDR_VAR 0 64
77734: PUSH
77735: LD_INT 1
77737: NEG
77738: PUSH
77739: LD_INT 2
77741: NEG
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 2
77749: NEG
77750: PUSH
77751: LD_INT 1
77753: NEG
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 2
77761: NEG
77762: PUSH
77763: LD_INT 2
77765: NEG
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: LIST
77775: ST_TO_ADDR
// end ; 2 :
77776: GO 81042
77778: LD_INT 2
77780: DOUBLE
77781: EQUAL
77782: IFTRUE 77786
77784: GO 81041
77786: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77787: LD_ADDR_VAR 0 29
77791: PUSH
77792: LD_INT 4
77794: PUSH
77795: LD_INT 0
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 4
77804: PUSH
77805: LD_INT 1
77807: NEG
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 5
77815: PUSH
77816: LD_INT 0
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 5
77825: PUSH
77826: LD_INT 1
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 4
77835: PUSH
77836: LD_INT 1
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 3
77845: PUSH
77846: LD_INT 0
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 3
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 3
77866: PUSH
77867: LD_INT 2
77869: NEG
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 5
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 3
77887: PUSH
77888: LD_INT 3
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 3
77897: PUSH
77898: LD_INT 2
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 4
77907: PUSH
77908: LD_INT 3
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 4
77917: PUSH
77918: LD_INT 4
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 3
77927: PUSH
77928: LD_INT 4
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 2
77937: PUSH
77938: LD_INT 3
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 2
77947: PUSH
77948: LD_INT 2
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 4
77957: PUSH
77958: LD_INT 2
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 4
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 0
77977: PUSH
77978: LD_INT 4
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: LD_INT 3
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 1
77997: PUSH
77998: LD_INT 4
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 1
78007: PUSH
78008: LD_INT 5
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 0
78017: PUSH
78018: LD_INT 5
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 1
78027: NEG
78028: PUSH
78029: LD_INT 4
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 1
78038: NEG
78039: PUSH
78040: LD_INT 3
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 2
78049: PUSH
78050: LD_INT 5
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: NEG
78060: PUSH
78061: LD_INT 3
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: NEG
78071: PUSH
78072: LD_INT 0
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 3
78081: NEG
78082: PUSH
78083: LD_INT 1
78085: NEG
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: LD_INT 2
78093: NEG
78094: PUSH
78095: LD_INT 0
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 2
78104: NEG
78105: PUSH
78106: LD_INT 1
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 3
78115: NEG
78116: PUSH
78117: LD_INT 1
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 4
78126: NEG
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 4
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 4
78149: NEG
78150: PUSH
78151: LD_INT 2
78153: NEG
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 2
78161: NEG
78162: PUSH
78163: LD_INT 2
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 4
78172: NEG
78173: PUSH
78174: LD_INT 4
78176: NEG
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 4
78184: NEG
78185: PUSH
78186: LD_INT 5
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 3
78196: NEG
78197: PUSH
78198: LD_INT 4
78200: NEG
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 3
78208: NEG
78209: PUSH
78210: LD_INT 3
78212: NEG
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 4
78220: NEG
78221: PUSH
78222: LD_INT 3
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 5
78232: NEG
78233: PUSH
78234: LD_INT 4
78236: NEG
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 5
78244: NEG
78245: PUSH
78246: LD_INT 5
78248: NEG
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 3
78256: NEG
78257: PUSH
78258: LD_INT 5
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 5
78268: NEG
78269: PUSH
78270: LD_INT 3
78272: NEG
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: LIST
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78325: LD_ADDR_VAR 0 30
78329: PUSH
78330: LD_INT 4
78332: PUSH
78333: LD_INT 4
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 4
78342: PUSH
78343: LD_INT 3
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 5
78352: PUSH
78353: LD_INT 4
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 5
78362: PUSH
78363: LD_INT 5
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 4
78372: PUSH
78373: LD_INT 5
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 3
78382: PUSH
78383: LD_INT 4
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 3
78392: PUSH
78393: LD_INT 3
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 5
78402: PUSH
78403: LD_INT 3
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 3
78412: PUSH
78413: LD_INT 5
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: LD_INT 3
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 0
78432: PUSH
78433: LD_INT 2
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 1
78442: PUSH
78443: LD_INT 3
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 1
78452: PUSH
78453: LD_INT 4
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 0
78462: PUSH
78463: LD_INT 4
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 1
78472: NEG
78473: PUSH
78474: LD_INT 3
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 1
78483: NEG
78484: PUSH
78485: LD_INT 2
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 2
78494: PUSH
78495: LD_INT 4
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 2
78504: NEG
78505: PUSH
78506: LD_INT 2
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 4
78515: NEG
78516: PUSH
78517: LD_INT 0
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 4
78526: NEG
78527: PUSH
78528: LD_INT 1
78530: NEG
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 3
78538: NEG
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 3
78549: NEG
78550: PUSH
78551: LD_INT 1
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 4
78560: NEG
78561: PUSH
78562: LD_INT 1
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 5
78571: NEG
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 5
78582: NEG
78583: PUSH
78584: LD_INT 1
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 5
78594: NEG
78595: PUSH
78596: LD_INT 2
78598: NEG
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 3
78606: NEG
78607: PUSH
78608: LD_INT 2
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 3
78617: NEG
78618: PUSH
78619: LD_INT 3
78621: NEG
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 3
78629: NEG
78630: PUSH
78631: LD_INT 4
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 2
78641: NEG
78642: PUSH
78643: LD_INT 3
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 2
78653: NEG
78654: PUSH
78655: LD_INT 2
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 3
78665: NEG
78666: PUSH
78667: LD_INT 2
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 4
78677: NEG
78678: PUSH
78679: LD_INT 3
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 4
78689: NEG
78690: PUSH
78691: LD_INT 4
78693: NEG
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 2
78701: NEG
78702: PUSH
78703: LD_INT 4
78705: NEG
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 4
78713: NEG
78714: PUSH
78715: LD_INT 2
78717: NEG
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: LD_INT 0
78725: PUSH
78726: LD_INT 4
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 0
78736: PUSH
78737: LD_INT 5
78739: NEG
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: LD_INT 1
78747: PUSH
78748: LD_INT 4
78750: NEG
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 1
78758: PUSH
78759: LD_INT 3
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 0
78769: PUSH
78770: LD_INT 3
78772: NEG
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 1
78780: NEG
78781: PUSH
78782: LD_INT 4
78784: NEG
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: LD_INT 5
78796: NEG
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 2
78804: PUSH
78805: LD_INT 3
78807: NEG
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 2
78815: NEG
78816: PUSH
78817: LD_INT 5
78819: NEG
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78872: LD_ADDR_VAR 0 31
78876: PUSH
78877: LD_INT 0
78879: PUSH
78880: LD_INT 4
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 0
78889: PUSH
78890: LD_INT 3
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 1
78899: PUSH
78900: LD_INT 4
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 1
78909: PUSH
78910: LD_INT 5
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 0
78919: PUSH
78920: LD_INT 5
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 1
78929: NEG
78930: PUSH
78931: LD_INT 4
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 1
78940: NEG
78941: PUSH
78942: LD_INT 3
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 2
78951: PUSH
78952: LD_INT 5
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 2
78961: NEG
78962: PUSH
78963: LD_INT 3
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 3
78983: NEG
78984: PUSH
78985: LD_INT 1
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 2
78995: NEG
78996: PUSH
78997: LD_INT 0
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 2
79006: NEG
79007: PUSH
79008: LD_INT 1
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 3
79017: NEG
79018: PUSH
79019: LD_INT 1
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 4
79028: NEG
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 4
79039: NEG
79040: PUSH
79041: LD_INT 1
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 4
79051: NEG
79052: PUSH
79053: LD_INT 2
79055: NEG
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 2
79063: NEG
79064: PUSH
79065: LD_INT 2
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 4
79074: NEG
79075: PUSH
79076: LD_INT 4
79078: NEG
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 4
79086: NEG
79087: PUSH
79088: LD_INT 5
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 3
79098: NEG
79099: PUSH
79100: LD_INT 4
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 3
79110: NEG
79111: PUSH
79112: LD_INT 3
79114: NEG
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 4
79122: NEG
79123: PUSH
79124: LD_INT 3
79126: NEG
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 5
79134: NEG
79135: PUSH
79136: LD_INT 4
79138: NEG
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 5
79146: NEG
79147: PUSH
79148: LD_INT 5
79150: NEG
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 3
79158: NEG
79159: PUSH
79160: LD_INT 5
79162: NEG
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 5
79170: NEG
79171: PUSH
79172: LD_INT 3
79174: NEG
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 0
79182: PUSH
79183: LD_INT 3
79185: NEG
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: LD_INT 4
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 1
79204: PUSH
79205: LD_INT 3
79207: NEG
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 1
79215: PUSH
79216: LD_INT 2
79218: NEG
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 0
79226: PUSH
79227: LD_INT 2
79229: NEG
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 1
79237: NEG
79238: PUSH
79239: LD_INT 3
79241: NEG
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 1
79249: NEG
79250: PUSH
79251: LD_INT 4
79253: NEG
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 2
79261: PUSH
79262: LD_INT 2
79264: NEG
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 2
79272: NEG
79273: PUSH
79274: LD_INT 4
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 4
79284: PUSH
79285: LD_INT 0
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 4
79294: PUSH
79295: LD_INT 1
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 5
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 5
79315: PUSH
79316: LD_INT 1
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 4
79325: PUSH
79326: LD_INT 1
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 3
79335: PUSH
79336: LD_INT 0
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 3
79345: PUSH
79346: LD_INT 1
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 3
79356: PUSH
79357: LD_INT 2
79359: NEG
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 5
79367: PUSH
79368: LD_INT 2
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79422: LD_ADDR_VAR 0 32
79426: PUSH
79427: LD_INT 4
79429: NEG
79430: PUSH
79431: LD_INT 0
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 4
79440: NEG
79441: PUSH
79442: LD_INT 1
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 3
79452: NEG
79453: PUSH
79454: LD_INT 0
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 3
79463: NEG
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: LD_INT 4
79474: NEG
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 5
79485: NEG
79486: PUSH
79487: LD_INT 0
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 5
79496: NEG
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 5
79508: NEG
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: NEG
79521: PUSH
79522: LD_INT 2
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 3
79531: NEG
79532: PUSH
79533: LD_INT 3
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 3
79543: NEG
79544: PUSH
79545: LD_INT 4
79547: NEG
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 2
79555: NEG
79556: PUSH
79557: LD_INT 3
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 2
79567: NEG
79568: PUSH
79569: LD_INT 2
79571: NEG
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 3
79579: NEG
79580: PUSH
79581: LD_INT 2
79583: NEG
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 4
79591: NEG
79592: PUSH
79593: LD_INT 3
79595: NEG
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 4
79603: NEG
79604: PUSH
79605: LD_INT 4
79607: NEG
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 2
79615: NEG
79616: PUSH
79617: LD_INT 4
79619: NEG
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 4
79627: NEG
79628: PUSH
79629: LD_INT 2
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: LD_INT 4
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 0
79650: PUSH
79651: LD_INT 5
79653: NEG
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 1
79661: PUSH
79662: LD_INT 4
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: LD_INT 3
79675: NEG
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 0
79683: PUSH
79684: LD_INT 3
79686: NEG
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 1
79694: NEG
79695: PUSH
79696: LD_INT 4
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 1
79706: NEG
79707: PUSH
79708: LD_INT 5
79710: NEG
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: LD_INT 3
79721: NEG
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 2
79729: NEG
79730: PUSH
79731: LD_INT 5
79733: NEG
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: PUSH
79742: LD_INT 0
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 3
79751: PUSH
79752: LD_INT 1
79754: NEG
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 4
79762: PUSH
79763: LD_INT 0
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 4
79772: PUSH
79773: LD_INT 1
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 3
79782: PUSH
79783: LD_INT 1
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 2
79792: PUSH
79793: LD_INT 0
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 2
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 2
79813: PUSH
79814: LD_INT 2
79816: NEG
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 4
79824: PUSH
79825: LD_INT 2
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 4
79834: PUSH
79835: LD_INT 4
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 4
79844: PUSH
79845: LD_INT 3
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 5
79854: PUSH
79855: LD_INT 4
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 5
79864: PUSH
79865: LD_INT 5
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 4
79874: PUSH
79875: LD_INT 5
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 3
79884: PUSH
79885: LD_INT 4
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 3
79894: PUSH
79895: LD_INT 3
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 5
79904: PUSH
79905: LD_INT 3
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 3
79914: PUSH
79915: LD_INT 5
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79969: LD_ADDR_VAR 0 33
79973: PUSH
79974: LD_INT 4
79976: NEG
79977: PUSH
79978: LD_INT 4
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 4
79988: NEG
79989: PUSH
79990: LD_INT 5
79992: NEG
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 3
80000: NEG
80001: PUSH
80002: LD_INT 4
80004: NEG
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 3
80012: NEG
80013: PUSH
80014: LD_INT 3
80016: NEG
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 4
80024: NEG
80025: PUSH
80026: LD_INT 3
80028: NEG
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 5
80036: NEG
80037: PUSH
80038: LD_INT 4
80040: NEG
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 5
80048: NEG
80049: PUSH
80050: LD_INT 5
80052: NEG
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 3
80060: NEG
80061: PUSH
80062: LD_INT 5
80064: NEG
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: LD_INT 5
80072: NEG
80073: PUSH
80074: LD_INT 3
80076: NEG
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 0
80084: PUSH
80085: LD_INT 3
80087: NEG
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 0
80095: PUSH
80096: LD_INT 4
80098: NEG
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 1
80106: PUSH
80107: LD_INT 3
80109: NEG
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 1
80117: PUSH
80118: LD_INT 2
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: LD_INT 2
80131: NEG
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: NEG
80140: PUSH
80141: LD_INT 3
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 4
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 2
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 2
80174: NEG
80175: PUSH
80176: LD_INT 4
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 4
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 4
80196: PUSH
80197: LD_INT 1
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 5
80207: PUSH
80208: LD_INT 0
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 5
80217: PUSH
80218: LD_INT 1
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 4
80227: PUSH
80228: LD_INT 1
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 3
80237: PUSH
80238: LD_INT 0
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: LD_INT 1
80250: NEG
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 3
80258: PUSH
80259: LD_INT 2
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 5
80269: PUSH
80270: LD_INT 2
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 3
80279: PUSH
80280: LD_INT 3
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 3
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 4
80299: PUSH
80300: LD_INT 3
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 4
80309: PUSH
80310: LD_INT 4
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 3
80319: PUSH
80320: LD_INT 4
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 2
80329: PUSH
80330: LD_INT 3
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 2
80339: PUSH
80340: LD_INT 2
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 4
80349: PUSH
80350: LD_INT 2
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: LD_INT 4
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 0
80369: PUSH
80370: LD_INT 4
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 0
80379: PUSH
80380: LD_INT 3
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 1
80389: PUSH
80390: LD_INT 4
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 1
80399: PUSH
80400: LD_INT 5
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: LD_INT 5
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: LD_INT 4
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: LD_INT 3
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: PUSH
80442: LD_INT 5
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 2
80451: NEG
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80507: LD_ADDR_VAR 0 34
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: LD_INT 4
80517: NEG
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 0
80525: PUSH
80526: LD_INT 5
80528: NEG
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 1
80536: PUSH
80537: LD_INT 4
80539: NEG
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 1
80547: PUSH
80548: LD_INT 3
80550: NEG
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 0
80558: PUSH
80559: LD_INT 3
80561: NEG
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 1
80569: NEG
80570: PUSH
80571: LD_INT 4
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 1
80581: NEG
80582: PUSH
80583: LD_INT 5
80585: NEG
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 2
80593: PUSH
80594: LD_INT 3
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 2
80604: NEG
80605: PUSH
80606: LD_INT 5
80608: NEG
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 3
80616: PUSH
80617: LD_INT 0
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 3
80626: PUSH
80627: LD_INT 1
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 4
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 4
80647: PUSH
80648: LD_INT 1
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 3
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 0
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 2
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 4
80699: PUSH
80700: LD_INT 2
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 4
80709: PUSH
80710: LD_INT 4
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 4
80719: PUSH
80720: LD_INT 3
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 5
80729: PUSH
80730: LD_INT 4
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 5
80739: PUSH
80740: LD_INT 5
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 4
80749: PUSH
80750: LD_INT 5
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 3
80759: PUSH
80760: LD_INT 4
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 3
80769: PUSH
80770: LD_INT 3
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 5
80779: PUSH
80780: LD_INT 3
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 3
80789: PUSH
80790: LD_INT 5
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: LD_INT 3
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 2
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 3
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: PUSH
80830: LD_INT 4
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 4
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 1
80849: NEG
80850: PUSH
80851: LD_INT 3
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: NEG
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: LD_INT 4
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 2
80881: NEG
80882: PUSH
80883: LD_INT 2
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 4
80892: NEG
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 4
80903: NEG
80904: PUSH
80905: LD_INT 1
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 3
80915: NEG
80916: PUSH
80917: LD_INT 0
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 3
80926: NEG
80927: PUSH
80928: LD_INT 1
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 4
80937: NEG
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 5
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 5
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 5
80971: NEG
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 3
80983: NEG
80984: PUSH
80985: LD_INT 2
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: LIST
81014: LIST
81015: LIST
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: ST_TO_ADDR
// end ; end ;
81039: GO 81042
81041: POP
// case btype of b_depot , b_warehouse :
81042: LD_VAR 0 1
81046: PUSH
81047: LD_INT 0
81049: DOUBLE
81050: EQUAL
81051: IFTRUE 81061
81053: LD_INT 1
81055: DOUBLE
81056: EQUAL
81057: IFTRUE 81061
81059: GO 81262
81061: POP
// case nation of nation_american :
81062: LD_VAR 0 5
81066: PUSH
81067: LD_INT 1
81069: DOUBLE
81070: EQUAL
81071: IFTRUE 81075
81073: GO 81131
81075: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81076: LD_ADDR_VAR 0 9
81080: PUSH
81081: LD_VAR 0 11
81085: PUSH
81086: LD_VAR 0 12
81090: PUSH
81091: LD_VAR 0 13
81095: PUSH
81096: LD_VAR 0 14
81100: PUSH
81101: LD_VAR 0 15
81105: PUSH
81106: LD_VAR 0 16
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: PUSH
81119: LD_VAR 0 4
81123: PUSH
81124: LD_INT 1
81126: PLUS
81127: ARRAY
81128: ST_TO_ADDR
81129: GO 81260
81131: LD_INT 2
81133: DOUBLE
81134: EQUAL
81135: IFTRUE 81139
81137: GO 81195
81139: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81140: LD_ADDR_VAR 0 9
81144: PUSH
81145: LD_VAR 0 17
81149: PUSH
81150: LD_VAR 0 18
81154: PUSH
81155: LD_VAR 0 19
81159: PUSH
81160: LD_VAR 0 20
81164: PUSH
81165: LD_VAR 0 21
81169: PUSH
81170: LD_VAR 0 22
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: PUSH
81183: LD_VAR 0 4
81187: PUSH
81188: LD_INT 1
81190: PLUS
81191: ARRAY
81192: ST_TO_ADDR
81193: GO 81260
81195: LD_INT 3
81197: DOUBLE
81198: EQUAL
81199: IFTRUE 81203
81201: GO 81259
81203: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81204: LD_ADDR_VAR 0 9
81208: PUSH
81209: LD_VAR 0 23
81213: PUSH
81214: LD_VAR 0 24
81218: PUSH
81219: LD_VAR 0 25
81223: PUSH
81224: LD_VAR 0 26
81228: PUSH
81229: LD_VAR 0 27
81233: PUSH
81234: LD_VAR 0 28
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: PUSH
81247: LD_VAR 0 4
81251: PUSH
81252: LD_INT 1
81254: PLUS
81255: ARRAY
81256: ST_TO_ADDR
81257: GO 81260
81259: POP
81260: GO 81815
81262: LD_INT 2
81264: DOUBLE
81265: EQUAL
81266: IFTRUE 81276
81268: LD_INT 3
81270: DOUBLE
81271: EQUAL
81272: IFTRUE 81276
81274: GO 81332
81276: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81277: LD_ADDR_VAR 0 9
81281: PUSH
81282: LD_VAR 0 29
81286: PUSH
81287: LD_VAR 0 30
81291: PUSH
81292: LD_VAR 0 31
81296: PUSH
81297: LD_VAR 0 32
81301: PUSH
81302: LD_VAR 0 33
81306: PUSH
81307: LD_VAR 0 34
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: PUSH
81320: LD_VAR 0 4
81324: PUSH
81325: LD_INT 1
81327: PLUS
81328: ARRAY
81329: ST_TO_ADDR
81330: GO 81815
81332: LD_INT 16
81334: DOUBLE
81335: EQUAL
81336: IFTRUE 81394
81338: LD_INT 17
81340: DOUBLE
81341: EQUAL
81342: IFTRUE 81394
81344: LD_INT 18
81346: DOUBLE
81347: EQUAL
81348: IFTRUE 81394
81350: LD_INT 19
81352: DOUBLE
81353: EQUAL
81354: IFTRUE 81394
81356: LD_INT 22
81358: DOUBLE
81359: EQUAL
81360: IFTRUE 81394
81362: LD_INT 20
81364: DOUBLE
81365: EQUAL
81366: IFTRUE 81394
81368: LD_INT 21
81370: DOUBLE
81371: EQUAL
81372: IFTRUE 81394
81374: LD_INT 23
81376: DOUBLE
81377: EQUAL
81378: IFTRUE 81394
81380: LD_INT 24
81382: DOUBLE
81383: EQUAL
81384: IFTRUE 81394
81386: LD_INT 25
81388: DOUBLE
81389: EQUAL
81390: IFTRUE 81394
81392: GO 81450
81394: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81395: LD_ADDR_VAR 0 9
81399: PUSH
81400: LD_VAR 0 35
81404: PUSH
81405: LD_VAR 0 36
81409: PUSH
81410: LD_VAR 0 37
81414: PUSH
81415: LD_VAR 0 38
81419: PUSH
81420: LD_VAR 0 39
81424: PUSH
81425: LD_VAR 0 40
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: PUSH
81438: LD_VAR 0 4
81442: PUSH
81443: LD_INT 1
81445: PLUS
81446: ARRAY
81447: ST_TO_ADDR
81448: GO 81815
81450: LD_INT 6
81452: DOUBLE
81453: EQUAL
81454: IFTRUE 81506
81456: LD_INT 7
81458: DOUBLE
81459: EQUAL
81460: IFTRUE 81506
81462: LD_INT 8
81464: DOUBLE
81465: EQUAL
81466: IFTRUE 81506
81468: LD_INT 13
81470: DOUBLE
81471: EQUAL
81472: IFTRUE 81506
81474: LD_INT 12
81476: DOUBLE
81477: EQUAL
81478: IFTRUE 81506
81480: LD_INT 15
81482: DOUBLE
81483: EQUAL
81484: IFTRUE 81506
81486: LD_INT 11
81488: DOUBLE
81489: EQUAL
81490: IFTRUE 81506
81492: LD_INT 14
81494: DOUBLE
81495: EQUAL
81496: IFTRUE 81506
81498: LD_INT 10
81500: DOUBLE
81501: EQUAL
81502: IFTRUE 81506
81504: GO 81562
81506: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81507: LD_ADDR_VAR 0 9
81511: PUSH
81512: LD_VAR 0 41
81516: PUSH
81517: LD_VAR 0 42
81521: PUSH
81522: LD_VAR 0 43
81526: PUSH
81527: LD_VAR 0 44
81531: PUSH
81532: LD_VAR 0 45
81536: PUSH
81537: LD_VAR 0 46
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: PUSH
81550: LD_VAR 0 4
81554: PUSH
81555: LD_INT 1
81557: PLUS
81558: ARRAY
81559: ST_TO_ADDR
81560: GO 81815
81562: LD_INT 36
81564: DOUBLE
81565: EQUAL
81566: IFTRUE 81570
81568: GO 81626
81570: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81571: LD_ADDR_VAR 0 9
81575: PUSH
81576: LD_VAR 0 47
81580: PUSH
81581: LD_VAR 0 48
81585: PUSH
81586: LD_VAR 0 49
81590: PUSH
81591: LD_VAR 0 50
81595: PUSH
81596: LD_VAR 0 51
81600: PUSH
81601: LD_VAR 0 52
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: PUSH
81614: LD_VAR 0 4
81618: PUSH
81619: LD_INT 1
81621: PLUS
81622: ARRAY
81623: ST_TO_ADDR
81624: GO 81815
81626: LD_INT 4
81628: DOUBLE
81629: EQUAL
81630: IFTRUE 81652
81632: LD_INT 5
81634: DOUBLE
81635: EQUAL
81636: IFTRUE 81652
81638: LD_INT 34
81640: DOUBLE
81641: EQUAL
81642: IFTRUE 81652
81644: LD_INT 37
81646: DOUBLE
81647: EQUAL
81648: IFTRUE 81652
81650: GO 81708
81652: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81653: LD_ADDR_VAR 0 9
81657: PUSH
81658: LD_VAR 0 53
81662: PUSH
81663: LD_VAR 0 54
81667: PUSH
81668: LD_VAR 0 55
81672: PUSH
81673: LD_VAR 0 56
81677: PUSH
81678: LD_VAR 0 57
81682: PUSH
81683: LD_VAR 0 58
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: PUSH
81696: LD_VAR 0 4
81700: PUSH
81701: LD_INT 1
81703: PLUS
81704: ARRAY
81705: ST_TO_ADDR
81706: GO 81815
81708: LD_INT 31
81710: DOUBLE
81711: EQUAL
81712: IFTRUE 81758
81714: LD_INT 32
81716: DOUBLE
81717: EQUAL
81718: IFTRUE 81758
81720: LD_INT 33
81722: DOUBLE
81723: EQUAL
81724: IFTRUE 81758
81726: LD_INT 27
81728: DOUBLE
81729: EQUAL
81730: IFTRUE 81758
81732: LD_INT 26
81734: DOUBLE
81735: EQUAL
81736: IFTRUE 81758
81738: LD_INT 28
81740: DOUBLE
81741: EQUAL
81742: IFTRUE 81758
81744: LD_INT 29
81746: DOUBLE
81747: EQUAL
81748: IFTRUE 81758
81750: LD_INT 30
81752: DOUBLE
81753: EQUAL
81754: IFTRUE 81758
81756: GO 81814
81758: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81759: LD_ADDR_VAR 0 9
81763: PUSH
81764: LD_VAR 0 59
81768: PUSH
81769: LD_VAR 0 60
81773: PUSH
81774: LD_VAR 0 61
81778: PUSH
81779: LD_VAR 0 62
81783: PUSH
81784: LD_VAR 0 63
81788: PUSH
81789: LD_VAR 0 64
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: PUSH
81802: LD_VAR 0 4
81806: PUSH
81807: LD_INT 1
81809: PLUS
81810: ARRAY
81811: ST_TO_ADDR
81812: GO 81815
81814: POP
// temp_list2 = [ ] ;
81815: LD_ADDR_VAR 0 10
81819: PUSH
81820: EMPTY
81821: ST_TO_ADDR
// for i in temp_list do
81822: LD_ADDR_VAR 0 8
81826: PUSH
81827: LD_VAR 0 9
81831: PUSH
81832: FOR_IN
81833: IFFALSE 81885
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81835: LD_ADDR_VAR 0 10
81839: PUSH
81840: LD_VAR 0 10
81844: PUSH
81845: LD_VAR 0 8
81849: PUSH
81850: LD_INT 1
81852: ARRAY
81853: PUSH
81854: LD_VAR 0 2
81858: PLUS
81859: PUSH
81860: LD_VAR 0 8
81864: PUSH
81865: LD_INT 2
81867: ARRAY
81868: PUSH
81869: LD_VAR 0 3
81873: PLUS
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: EMPTY
81880: LIST
81881: ADD
81882: ST_TO_ADDR
81883: GO 81832
81885: POP
81886: POP
// result = temp_list2 ;
81887: LD_ADDR_VAR 0 7
81891: PUSH
81892: LD_VAR 0 10
81896: ST_TO_ADDR
// end ;
81897: LD_VAR 0 7
81901: RET
// export function EnemyInRange ( unit , dist ) ; begin
81902: LD_INT 0
81904: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81905: LD_ADDR_VAR 0 3
81909: PUSH
81910: LD_VAR 0 1
81914: PPUSH
81915: CALL_OW 255
81919: PPUSH
81920: LD_VAR 0 1
81924: PPUSH
81925: CALL_OW 250
81929: PPUSH
81930: LD_VAR 0 1
81934: PPUSH
81935: CALL_OW 251
81939: PPUSH
81940: LD_VAR 0 2
81944: PPUSH
81945: CALL 55275 0 4
81949: PUSH
81950: LD_INT 4
81952: ARRAY
81953: ST_TO_ADDR
// end ;
81954: LD_VAR 0 3
81958: RET
// export function PlayerSeeMe ( unit ) ; begin
81959: LD_INT 0
81961: PPUSH
// result := See ( your_side , unit ) ;
81962: LD_ADDR_VAR 0 2
81966: PUSH
81967: LD_OWVAR 2
81971: PPUSH
81972: LD_VAR 0 1
81976: PPUSH
81977: CALL_OW 292
81981: ST_TO_ADDR
// end ;
81982: LD_VAR 0 2
81986: RET
// export function ReverseDir ( unit ) ; begin
81987: LD_INT 0
81989: PPUSH
// if not unit then
81990: LD_VAR 0 1
81994: NOT
81995: IFFALSE 81999
// exit ;
81997: GO 82022
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81999: LD_ADDR_VAR 0 2
82003: PUSH
82004: LD_VAR 0 1
82008: PPUSH
82009: CALL_OW 254
82013: PUSH
82014: LD_INT 3
82016: PLUS
82017: PUSH
82018: LD_INT 6
82020: MOD
82021: ST_TO_ADDR
// end ;
82022: LD_VAR 0 2
82026: RET
// export function ReverseArray ( array ) ; var i ; begin
82027: LD_INT 0
82029: PPUSH
82030: PPUSH
// if not array then
82031: LD_VAR 0 1
82035: NOT
82036: IFFALSE 82040
// exit ;
82038: GO 82095
// result := [ ] ;
82040: LD_ADDR_VAR 0 2
82044: PUSH
82045: EMPTY
82046: ST_TO_ADDR
// for i := array downto 1 do
82047: LD_ADDR_VAR 0 3
82051: PUSH
82052: DOUBLE
82053: LD_VAR 0 1
82057: INC
82058: ST_TO_ADDR
82059: LD_INT 1
82061: PUSH
82062: FOR_DOWNTO
82063: IFFALSE 82093
// result := Join ( result , array [ i ] ) ;
82065: LD_ADDR_VAR 0 2
82069: PUSH
82070: LD_VAR 0 2
82074: PPUSH
82075: LD_VAR 0 1
82079: PUSH
82080: LD_VAR 0 3
82084: ARRAY
82085: PPUSH
82086: CALL 86760 0 2
82090: ST_TO_ADDR
82091: GO 82062
82093: POP
82094: POP
// end ;
82095: LD_VAR 0 2
82099: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82100: LD_INT 0
82102: PPUSH
82103: PPUSH
82104: PPUSH
82105: PPUSH
82106: PPUSH
82107: PPUSH
// if not unit or not hexes then
82108: LD_VAR 0 1
82112: NOT
82113: PUSH
82114: LD_VAR 0 2
82118: NOT
82119: OR
82120: IFFALSE 82124
// exit ;
82122: GO 82247
// dist := 9999 ;
82124: LD_ADDR_VAR 0 5
82128: PUSH
82129: LD_INT 9999
82131: ST_TO_ADDR
// for i = 1 to hexes do
82132: LD_ADDR_VAR 0 4
82136: PUSH
82137: DOUBLE
82138: LD_INT 1
82140: DEC
82141: ST_TO_ADDR
82142: LD_VAR 0 2
82146: PUSH
82147: FOR_TO
82148: IFFALSE 82235
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82150: LD_ADDR_VAR 0 6
82154: PUSH
82155: LD_VAR 0 1
82159: PPUSH
82160: LD_VAR 0 2
82164: PUSH
82165: LD_VAR 0 4
82169: ARRAY
82170: PUSH
82171: LD_INT 1
82173: ARRAY
82174: PPUSH
82175: LD_VAR 0 2
82179: PUSH
82180: LD_VAR 0 4
82184: ARRAY
82185: PUSH
82186: LD_INT 2
82188: ARRAY
82189: PPUSH
82190: CALL_OW 297
82194: ST_TO_ADDR
// if tdist < dist then
82195: LD_VAR 0 6
82199: PUSH
82200: LD_VAR 0 5
82204: LESS
82205: IFFALSE 82233
// begin hex := hexes [ i ] ;
82207: LD_ADDR_VAR 0 8
82211: PUSH
82212: LD_VAR 0 2
82216: PUSH
82217: LD_VAR 0 4
82221: ARRAY
82222: ST_TO_ADDR
// dist := tdist ;
82223: LD_ADDR_VAR 0 5
82227: PUSH
82228: LD_VAR 0 6
82232: ST_TO_ADDR
// end ; end ;
82233: GO 82147
82235: POP
82236: POP
// result := hex ;
82237: LD_ADDR_VAR 0 3
82241: PUSH
82242: LD_VAR 0 8
82246: ST_TO_ADDR
// end ;
82247: LD_VAR 0 3
82251: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82252: LD_INT 0
82254: PPUSH
82255: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82256: LD_VAR 0 1
82260: NOT
82261: PUSH
82262: LD_VAR 0 1
82266: PUSH
82267: LD_INT 21
82269: PUSH
82270: LD_INT 2
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 23
82279: PUSH
82280: LD_INT 2
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PPUSH
82291: CALL_OW 69
82295: IN
82296: NOT
82297: OR
82298: IFFALSE 82302
// exit ;
82300: GO 82349
// for i = 1 to 3 do
82302: LD_ADDR_VAR 0 3
82306: PUSH
82307: DOUBLE
82308: LD_INT 1
82310: DEC
82311: ST_TO_ADDR
82312: LD_INT 3
82314: PUSH
82315: FOR_TO
82316: IFFALSE 82347
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82318: LD_VAR 0 1
82322: PPUSH
82323: CALL_OW 250
82327: PPUSH
82328: LD_VAR 0 1
82332: PPUSH
82333: CALL_OW 251
82337: PPUSH
82338: LD_INT 1
82340: PPUSH
82341: CALL_OW 453
82345: GO 82315
82347: POP
82348: POP
// end ;
82349: LD_VAR 0 2
82353: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82354: LD_INT 0
82356: PPUSH
82357: PPUSH
82358: PPUSH
82359: PPUSH
82360: PPUSH
82361: PPUSH
// if not unit or not enemy_unit then
82362: LD_VAR 0 1
82366: NOT
82367: PUSH
82368: LD_VAR 0 2
82372: NOT
82373: OR
82374: IFFALSE 82378
// exit ;
82376: GO 82845
// if GetLives ( i ) < 250 then
82378: LD_VAR 0 4
82382: PPUSH
82383: CALL_OW 256
82387: PUSH
82388: LD_INT 250
82390: LESS
82391: IFFALSE 82404
// begin ComAutodestruct ( i ) ;
82393: LD_VAR 0 4
82397: PPUSH
82398: CALL 82252 0 1
// exit ;
82402: GO 82845
// end ; x := GetX ( enemy_unit ) ;
82404: LD_ADDR_VAR 0 7
82408: PUSH
82409: LD_VAR 0 2
82413: PPUSH
82414: CALL_OW 250
82418: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82419: LD_ADDR_VAR 0 8
82423: PUSH
82424: LD_VAR 0 2
82428: PPUSH
82429: CALL_OW 251
82433: ST_TO_ADDR
// if not x or not y then
82434: LD_VAR 0 7
82438: NOT
82439: PUSH
82440: LD_VAR 0 8
82444: NOT
82445: OR
82446: IFFALSE 82450
// exit ;
82448: GO 82845
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82450: LD_ADDR_VAR 0 6
82454: PUSH
82455: LD_VAR 0 7
82459: PPUSH
82460: LD_INT 0
82462: PPUSH
82463: LD_INT 4
82465: PPUSH
82466: CALL_OW 272
82470: PUSH
82471: LD_VAR 0 8
82475: PPUSH
82476: LD_INT 0
82478: PPUSH
82479: LD_INT 4
82481: PPUSH
82482: CALL_OW 273
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_VAR 0 7
82495: PPUSH
82496: LD_INT 1
82498: PPUSH
82499: LD_INT 4
82501: PPUSH
82502: CALL_OW 272
82506: PUSH
82507: LD_VAR 0 8
82511: PPUSH
82512: LD_INT 1
82514: PPUSH
82515: LD_INT 4
82517: PPUSH
82518: CALL_OW 273
82522: PUSH
82523: EMPTY
82524: LIST
82525: LIST
82526: PUSH
82527: LD_VAR 0 7
82531: PPUSH
82532: LD_INT 2
82534: PPUSH
82535: LD_INT 4
82537: PPUSH
82538: CALL_OW 272
82542: PUSH
82543: LD_VAR 0 8
82547: PPUSH
82548: LD_INT 2
82550: PPUSH
82551: LD_INT 4
82553: PPUSH
82554: CALL_OW 273
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_VAR 0 7
82567: PPUSH
82568: LD_INT 3
82570: PPUSH
82571: LD_INT 4
82573: PPUSH
82574: CALL_OW 272
82578: PUSH
82579: LD_VAR 0 8
82583: PPUSH
82584: LD_INT 3
82586: PPUSH
82587: LD_INT 4
82589: PPUSH
82590: CALL_OW 273
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_VAR 0 7
82603: PPUSH
82604: LD_INT 4
82606: PPUSH
82607: LD_INT 4
82609: PPUSH
82610: CALL_OW 272
82614: PUSH
82615: LD_VAR 0 8
82619: PPUSH
82620: LD_INT 4
82622: PPUSH
82623: LD_INT 4
82625: PPUSH
82626: CALL_OW 273
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_VAR 0 7
82639: PPUSH
82640: LD_INT 5
82642: PPUSH
82643: LD_INT 4
82645: PPUSH
82646: CALL_OW 272
82650: PUSH
82651: LD_VAR 0 8
82655: PPUSH
82656: LD_INT 5
82658: PPUSH
82659: LD_INT 4
82661: PPUSH
82662: CALL_OW 273
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: ST_TO_ADDR
// for i = tmp downto 1 do
82679: LD_ADDR_VAR 0 4
82683: PUSH
82684: DOUBLE
82685: LD_VAR 0 6
82689: INC
82690: ST_TO_ADDR
82691: LD_INT 1
82693: PUSH
82694: FOR_DOWNTO
82695: IFFALSE 82796
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82697: LD_VAR 0 6
82701: PUSH
82702: LD_VAR 0 4
82706: ARRAY
82707: PUSH
82708: LD_INT 1
82710: ARRAY
82711: PPUSH
82712: LD_VAR 0 6
82716: PUSH
82717: LD_VAR 0 4
82721: ARRAY
82722: PUSH
82723: LD_INT 2
82725: ARRAY
82726: PPUSH
82727: CALL_OW 488
82731: NOT
82732: PUSH
82733: LD_VAR 0 6
82737: PUSH
82738: LD_VAR 0 4
82742: ARRAY
82743: PUSH
82744: LD_INT 1
82746: ARRAY
82747: PPUSH
82748: LD_VAR 0 6
82752: PUSH
82753: LD_VAR 0 4
82757: ARRAY
82758: PUSH
82759: LD_INT 2
82761: ARRAY
82762: PPUSH
82763: CALL_OW 428
82767: PUSH
82768: LD_INT 0
82770: NONEQUAL
82771: OR
82772: IFFALSE 82794
// tmp := Delete ( tmp , i ) ;
82774: LD_ADDR_VAR 0 6
82778: PUSH
82779: LD_VAR 0 6
82783: PPUSH
82784: LD_VAR 0 4
82788: PPUSH
82789: CALL_OW 3
82793: ST_TO_ADDR
82794: GO 82694
82796: POP
82797: POP
// j := GetClosestHex ( unit , tmp ) ;
82798: LD_ADDR_VAR 0 5
82802: PUSH
82803: LD_VAR 0 1
82807: PPUSH
82808: LD_VAR 0 6
82812: PPUSH
82813: CALL 82100 0 2
82817: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82818: LD_VAR 0 1
82822: PPUSH
82823: LD_VAR 0 5
82827: PUSH
82828: LD_INT 1
82830: ARRAY
82831: PPUSH
82832: LD_VAR 0 5
82836: PUSH
82837: LD_INT 2
82839: ARRAY
82840: PPUSH
82841: CALL_OW 111
// end ;
82845: LD_VAR 0 3
82849: RET
// export function PrepareApemanSoldier ( ) ; begin
82850: LD_INT 0
82852: PPUSH
// uc_nation := 0 ;
82853: LD_ADDR_OWVAR 21
82857: PUSH
82858: LD_INT 0
82860: ST_TO_ADDR
// hc_sex := sex_male ;
82861: LD_ADDR_OWVAR 27
82865: PUSH
82866: LD_INT 1
82868: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82869: LD_ADDR_OWVAR 28
82873: PUSH
82874: LD_INT 15
82876: ST_TO_ADDR
// hc_gallery :=  ;
82877: LD_ADDR_OWVAR 33
82881: PUSH
82882: LD_STRING 
82884: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82885: LD_ADDR_OWVAR 31
82889: PUSH
82890: LD_INT 0
82892: PPUSH
82893: LD_INT 3
82895: PPUSH
82896: CALL_OW 12
82900: PUSH
82901: LD_INT 0
82903: PPUSH
82904: LD_INT 3
82906: PPUSH
82907: CALL_OW 12
82911: PUSH
82912: LD_INT 0
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: ST_TO_ADDR
// end ;
82924: LD_VAR 0 1
82928: RET
// export function PrepareApemanEngineer ( ) ; begin
82929: LD_INT 0
82931: PPUSH
// uc_nation := 0 ;
82932: LD_ADDR_OWVAR 21
82936: PUSH
82937: LD_INT 0
82939: ST_TO_ADDR
// hc_sex := sex_male ;
82940: LD_ADDR_OWVAR 27
82944: PUSH
82945: LD_INT 1
82947: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82948: LD_ADDR_OWVAR 28
82952: PUSH
82953: LD_INT 16
82955: ST_TO_ADDR
// hc_gallery :=  ;
82956: LD_ADDR_OWVAR 33
82960: PUSH
82961: LD_STRING 
82963: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82964: LD_ADDR_OWVAR 31
82968: PUSH
82969: LD_INT 0
82971: PPUSH
82972: LD_INT 3
82974: PPUSH
82975: CALL_OW 12
82979: PUSH
82980: LD_INT 0
82982: PPUSH
82983: LD_INT 3
82985: PPUSH
82986: CALL_OW 12
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: LD_INT 0
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: ST_TO_ADDR
// end ;
83003: LD_VAR 0 1
83007: RET
// export function PrepareApeman ( agressivity ) ; begin
83008: LD_INT 0
83010: PPUSH
// uc_side := 0 ;
83011: LD_ADDR_OWVAR 20
83015: PUSH
83016: LD_INT 0
83018: ST_TO_ADDR
// uc_nation := 0 ;
83019: LD_ADDR_OWVAR 21
83023: PUSH
83024: LD_INT 0
83026: ST_TO_ADDR
// hc_sex := sex_male ;
83027: LD_ADDR_OWVAR 27
83031: PUSH
83032: LD_INT 1
83034: ST_TO_ADDR
// hc_class := class_apeman ;
83035: LD_ADDR_OWVAR 28
83039: PUSH
83040: LD_INT 12
83042: ST_TO_ADDR
// hc_gallery :=  ;
83043: LD_ADDR_OWVAR 33
83047: PUSH
83048: LD_STRING 
83050: ST_TO_ADDR
// if agressivity = 0 then
83051: LD_VAR 0 1
83055: PUSH
83056: LD_INT 0
83058: EQUAL
83059: IFFALSE 83071
// hc_agressivity := 0 else
83061: LD_ADDR_OWVAR 35
83065: PUSH
83066: LD_INT 0
83068: ST_TO_ADDR
83069: GO 83092
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83071: LD_ADDR_OWVAR 35
83075: PUSH
83076: LD_VAR 0 1
83080: NEG
83081: PPUSH
83082: LD_VAR 0 1
83086: PPUSH
83087: CALL_OW 12
83091: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83092: LD_ADDR_OWVAR 31
83096: PUSH
83097: LD_INT 0
83099: PPUSH
83100: LD_INT 3
83102: PPUSH
83103: CALL_OW 12
83107: PUSH
83108: LD_INT 0
83110: PPUSH
83111: LD_INT 3
83113: PPUSH
83114: CALL_OW 12
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: ST_TO_ADDR
// end ;
83131: LD_VAR 0 2
83135: RET
// export function PrepareTiger ( agressivity ) ; begin
83136: LD_INT 0
83138: PPUSH
// uc_side := 0 ;
83139: LD_ADDR_OWVAR 20
83143: PUSH
83144: LD_INT 0
83146: ST_TO_ADDR
// uc_nation := 0 ;
83147: LD_ADDR_OWVAR 21
83151: PUSH
83152: LD_INT 0
83154: ST_TO_ADDR
// hc_class := class_tiger ;
83155: LD_ADDR_OWVAR 28
83159: PUSH
83160: LD_INT 14
83162: ST_TO_ADDR
// hc_gallery :=  ;
83163: LD_ADDR_OWVAR 33
83167: PUSH
83168: LD_STRING 
83170: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83171: LD_ADDR_OWVAR 35
83175: PUSH
83176: LD_VAR 0 1
83180: NEG
83181: PPUSH
83182: LD_VAR 0 1
83186: PPUSH
83187: CALL_OW 12
83191: ST_TO_ADDR
// end ;
83192: LD_VAR 0 2
83196: RET
// export function PrepareEnchidna ( ) ; begin
83197: LD_INT 0
83199: PPUSH
// uc_side := 0 ;
83200: LD_ADDR_OWVAR 20
83204: PUSH
83205: LD_INT 0
83207: ST_TO_ADDR
// uc_nation := 0 ;
83208: LD_ADDR_OWVAR 21
83212: PUSH
83213: LD_INT 0
83215: ST_TO_ADDR
// hc_class := class_baggie ;
83216: LD_ADDR_OWVAR 28
83220: PUSH
83221: LD_INT 13
83223: ST_TO_ADDR
// hc_gallery :=  ;
83224: LD_ADDR_OWVAR 33
83228: PUSH
83229: LD_STRING 
83231: ST_TO_ADDR
// end ;
83232: LD_VAR 0 1
83236: RET
// export function PrepareFrog ( ) ; begin
83237: LD_INT 0
83239: PPUSH
// uc_side := 0 ;
83240: LD_ADDR_OWVAR 20
83244: PUSH
83245: LD_INT 0
83247: ST_TO_ADDR
// uc_nation := 0 ;
83248: LD_ADDR_OWVAR 21
83252: PUSH
83253: LD_INT 0
83255: ST_TO_ADDR
// hc_class := class_frog ;
83256: LD_ADDR_OWVAR 28
83260: PUSH
83261: LD_INT 19
83263: ST_TO_ADDR
// hc_gallery :=  ;
83264: LD_ADDR_OWVAR 33
83268: PUSH
83269: LD_STRING 
83271: ST_TO_ADDR
// end ;
83272: LD_VAR 0 1
83276: RET
// export function PrepareFish ( ) ; begin
83277: LD_INT 0
83279: PPUSH
// uc_side := 0 ;
83280: LD_ADDR_OWVAR 20
83284: PUSH
83285: LD_INT 0
83287: ST_TO_ADDR
// uc_nation := 0 ;
83288: LD_ADDR_OWVAR 21
83292: PUSH
83293: LD_INT 0
83295: ST_TO_ADDR
// hc_class := class_fish ;
83296: LD_ADDR_OWVAR 28
83300: PUSH
83301: LD_INT 20
83303: ST_TO_ADDR
// hc_gallery :=  ;
83304: LD_ADDR_OWVAR 33
83308: PUSH
83309: LD_STRING 
83311: ST_TO_ADDR
// end ;
83312: LD_VAR 0 1
83316: RET
// export function PrepareBird ( ) ; begin
83317: LD_INT 0
83319: PPUSH
// uc_side := 0 ;
83320: LD_ADDR_OWVAR 20
83324: PUSH
83325: LD_INT 0
83327: ST_TO_ADDR
// uc_nation := 0 ;
83328: LD_ADDR_OWVAR 21
83332: PUSH
83333: LD_INT 0
83335: ST_TO_ADDR
// hc_class := class_phororhacos ;
83336: LD_ADDR_OWVAR 28
83340: PUSH
83341: LD_INT 18
83343: ST_TO_ADDR
// hc_gallery :=  ;
83344: LD_ADDR_OWVAR 33
83348: PUSH
83349: LD_STRING 
83351: ST_TO_ADDR
// end ;
83352: LD_VAR 0 1
83356: RET
// export function PrepareHorse ( ) ; begin
83357: LD_INT 0
83359: PPUSH
// uc_side := 0 ;
83360: LD_ADDR_OWVAR 20
83364: PUSH
83365: LD_INT 0
83367: ST_TO_ADDR
// uc_nation := 0 ;
83368: LD_ADDR_OWVAR 21
83372: PUSH
83373: LD_INT 0
83375: ST_TO_ADDR
// hc_class := class_horse ;
83376: LD_ADDR_OWVAR 28
83380: PUSH
83381: LD_INT 21
83383: ST_TO_ADDR
// hc_gallery :=  ;
83384: LD_ADDR_OWVAR 33
83388: PUSH
83389: LD_STRING 
83391: ST_TO_ADDR
// end ;
83392: LD_VAR 0 1
83396: RET
// export function PrepareMastodont ( ) ; begin
83397: LD_INT 0
83399: PPUSH
// uc_side := 0 ;
83400: LD_ADDR_OWVAR 20
83404: PUSH
83405: LD_INT 0
83407: ST_TO_ADDR
// uc_nation := 0 ;
83408: LD_ADDR_OWVAR 21
83412: PUSH
83413: LD_INT 0
83415: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83416: LD_ADDR_OWVAR 37
83420: PUSH
83421: LD_INT 31
83423: ST_TO_ADDR
// vc_control := control_rider ;
83424: LD_ADDR_OWVAR 38
83428: PUSH
83429: LD_INT 4
83431: ST_TO_ADDR
// end ;
83432: LD_VAR 0 1
83436: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83437: LD_INT 0
83439: PPUSH
83440: PPUSH
83441: PPUSH
// uc_side = 0 ;
83442: LD_ADDR_OWVAR 20
83446: PUSH
83447: LD_INT 0
83449: ST_TO_ADDR
// uc_nation = 0 ;
83450: LD_ADDR_OWVAR 21
83454: PUSH
83455: LD_INT 0
83457: ST_TO_ADDR
// InitHc_All ( ) ;
83458: CALL_OW 584
// InitVc ;
83462: CALL_OW 20
// if mastodonts then
83466: LD_VAR 0 6
83470: IFFALSE 83537
// for i = 1 to mastodonts do
83472: LD_ADDR_VAR 0 11
83476: PUSH
83477: DOUBLE
83478: LD_INT 1
83480: DEC
83481: ST_TO_ADDR
83482: LD_VAR 0 6
83486: PUSH
83487: FOR_TO
83488: IFFALSE 83535
// begin vc_chassis := 31 ;
83490: LD_ADDR_OWVAR 37
83494: PUSH
83495: LD_INT 31
83497: ST_TO_ADDR
// vc_control := control_rider ;
83498: LD_ADDR_OWVAR 38
83502: PUSH
83503: LD_INT 4
83505: ST_TO_ADDR
// animal := CreateVehicle ;
83506: LD_ADDR_VAR 0 12
83510: PUSH
83511: CALL_OW 45
83515: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83516: LD_VAR 0 12
83520: PPUSH
83521: LD_VAR 0 8
83525: PPUSH
83526: LD_INT 0
83528: PPUSH
83529: CALL 85665 0 3
// end ;
83533: GO 83487
83535: POP
83536: POP
// if horses then
83537: LD_VAR 0 5
83541: IFFALSE 83608
// for i = 1 to horses do
83543: LD_ADDR_VAR 0 11
83547: PUSH
83548: DOUBLE
83549: LD_INT 1
83551: DEC
83552: ST_TO_ADDR
83553: LD_VAR 0 5
83557: PUSH
83558: FOR_TO
83559: IFFALSE 83606
// begin hc_class := 21 ;
83561: LD_ADDR_OWVAR 28
83565: PUSH
83566: LD_INT 21
83568: ST_TO_ADDR
// hc_gallery :=  ;
83569: LD_ADDR_OWVAR 33
83573: PUSH
83574: LD_STRING 
83576: ST_TO_ADDR
// animal := CreateHuman ;
83577: LD_ADDR_VAR 0 12
83581: PUSH
83582: CALL_OW 44
83586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83587: LD_VAR 0 12
83591: PPUSH
83592: LD_VAR 0 8
83596: PPUSH
83597: LD_INT 0
83599: PPUSH
83600: CALL 85665 0 3
// end ;
83604: GO 83558
83606: POP
83607: POP
// if birds then
83608: LD_VAR 0 1
83612: IFFALSE 83679
// for i = 1 to birds do
83614: LD_ADDR_VAR 0 11
83618: PUSH
83619: DOUBLE
83620: LD_INT 1
83622: DEC
83623: ST_TO_ADDR
83624: LD_VAR 0 1
83628: PUSH
83629: FOR_TO
83630: IFFALSE 83677
// begin hc_class := 18 ;
83632: LD_ADDR_OWVAR 28
83636: PUSH
83637: LD_INT 18
83639: ST_TO_ADDR
// hc_gallery =  ;
83640: LD_ADDR_OWVAR 33
83644: PUSH
83645: LD_STRING 
83647: ST_TO_ADDR
// animal := CreateHuman ;
83648: LD_ADDR_VAR 0 12
83652: PUSH
83653: CALL_OW 44
83657: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83658: LD_VAR 0 12
83662: PPUSH
83663: LD_VAR 0 8
83667: PPUSH
83668: LD_INT 0
83670: PPUSH
83671: CALL 85665 0 3
// end ;
83675: GO 83629
83677: POP
83678: POP
// if tigers then
83679: LD_VAR 0 2
83683: IFFALSE 83767
// for i = 1 to tigers do
83685: LD_ADDR_VAR 0 11
83689: PUSH
83690: DOUBLE
83691: LD_INT 1
83693: DEC
83694: ST_TO_ADDR
83695: LD_VAR 0 2
83699: PUSH
83700: FOR_TO
83701: IFFALSE 83765
// begin hc_class = class_tiger ;
83703: LD_ADDR_OWVAR 28
83707: PUSH
83708: LD_INT 14
83710: ST_TO_ADDR
// hc_gallery =  ;
83711: LD_ADDR_OWVAR 33
83715: PUSH
83716: LD_STRING 
83718: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83719: LD_ADDR_OWVAR 35
83723: PUSH
83724: LD_INT 7
83726: NEG
83727: PPUSH
83728: LD_INT 7
83730: PPUSH
83731: CALL_OW 12
83735: ST_TO_ADDR
// animal := CreateHuman ;
83736: LD_ADDR_VAR 0 12
83740: PUSH
83741: CALL_OW 44
83745: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83746: LD_VAR 0 12
83750: PPUSH
83751: LD_VAR 0 8
83755: PPUSH
83756: LD_INT 0
83758: PPUSH
83759: CALL 85665 0 3
// end ;
83763: GO 83700
83765: POP
83766: POP
// if apemans then
83767: LD_VAR 0 3
83771: IFFALSE 83894
// for i = 1 to apemans do
83773: LD_ADDR_VAR 0 11
83777: PUSH
83778: DOUBLE
83779: LD_INT 1
83781: DEC
83782: ST_TO_ADDR
83783: LD_VAR 0 3
83787: PUSH
83788: FOR_TO
83789: IFFALSE 83892
// begin hc_class = class_apeman ;
83791: LD_ADDR_OWVAR 28
83795: PUSH
83796: LD_INT 12
83798: ST_TO_ADDR
// hc_gallery =  ;
83799: LD_ADDR_OWVAR 33
83803: PUSH
83804: LD_STRING 
83806: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83807: LD_ADDR_OWVAR 35
83811: PUSH
83812: LD_INT 2
83814: NEG
83815: PPUSH
83816: LD_INT 2
83818: PPUSH
83819: CALL_OW 12
83823: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83824: LD_ADDR_OWVAR 31
83828: PUSH
83829: LD_INT 1
83831: PPUSH
83832: LD_INT 3
83834: PPUSH
83835: CALL_OW 12
83839: PUSH
83840: LD_INT 1
83842: PPUSH
83843: LD_INT 3
83845: PPUSH
83846: CALL_OW 12
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: LD_INT 0
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: ST_TO_ADDR
// animal := CreateHuman ;
83863: LD_ADDR_VAR 0 12
83867: PUSH
83868: CALL_OW 44
83872: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83873: LD_VAR 0 12
83877: PPUSH
83878: LD_VAR 0 8
83882: PPUSH
83883: LD_INT 0
83885: PPUSH
83886: CALL 85665 0 3
// end ;
83890: GO 83788
83892: POP
83893: POP
// if enchidnas then
83894: LD_VAR 0 4
83898: IFFALSE 83965
// for i = 1 to enchidnas do
83900: LD_ADDR_VAR 0 11
83904: PUSH
83905: DOUBLE
83906: LD_INT 1
83908: DEC
83909: ST_TO_ADDR
83910: LD_VAR 0 4
83914: PUSH
83915: FOR_TO
83916: IFFALSE 83963
// begin hc_class = 13 ;
83918: LD_ADDR_OWVAR 28
83922: PUSH
83923: LD_INT 13
83925: ST_TO_ADDR
// hc_gallery =  ;
83926: LD_ADDR_OWVAR 33
83930: PUSH
83931: LD_STRING 
83933: ST_TO_ADDR
// animal := CreateHuman ;
83934: LD_ADDR_VAR 0 12
83938: PUSH
83939: CALL_OW 44
83943: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83944: LD_VAR 0 12
83948: PPUSH
83949: LD_VAR 0 8
83953: PPUSH
83954: LD_INT 0
83956: PPUSH
83957: CALL 85665 0 3
// end ;
83961: GO 83915
83963: POP
83964: POP
// if fishes then
83965: LD_VAR 0 7
83969: IFFALSE 84036
// for i = 1 to fishes do
83971: LD_ADDR_VAR 0 11
83975: PUSH
83976: DOUBLE
83977: LD_INT 1
83979: DEC
83980: ST_TO_ADDR
83981: LD_VAR 0 7
83985: PUSH
83986: FOR_TO
83987: IFFALSE 84034
// begin hc_class = 20 ;
83989: LD_ADDR_OWVAR 28
83993: PUSH
83994: LD_INT 20
83996: ST_TO_ADDR
// hc_gallery =  ;
83997: LD_ADDR_OWVAR 33
84001: PUSH
84002: LD_STRING 
84004: ST_TO_ADDR
// animal := CreateHuman ;
84005: LD_ADDR_VAR 0 12
84009: PUSH
84010: CALL_OW 44
84014: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84015: LD_VAR 0 12
84019: PPUSH
84020: LD_VAR 0 9
84024: PPUSH
84025: LD_INT 0
84027: PPUSH
84028: CALL 85665 0 3
// end ;
84032: GO 83986
84034: POP
84035: POP
// end ;
84036: LD_VAR 0 10
84040: RET
// export function WantHeal ( sci , unit ) ; begin
84041: LD_INT 0
84043: PPUSH
// if GetTaskList ( sci ) > 0 then
84044: LD_VAR 0 1
84048: PPUSH
84049: CALL_OW 437
84053: PUSH
84054: LD_INT 0
84056: GREATER
84057: IFFALSE 84127
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84059: LD_VAR 0 1
84063: PPUSH
84064: CALL_OW 437
84068: PUSH
84069: LD_INT 1
84071: ARRAY
84072: PUSH
84073: LD_INT 1
84075: ARRAY
84076: PUSH
84077: LD_STRING l
84079: EQUAL
84080: PUSH
84081: LD_VAR 0 1
84085: PPUSH
84086: CALL_OW 437
84090: PUSH
84091: LD_INT 1
84093: ARRAY
84094: PUSH
84095: LD_INT 4
84097: ARRAY
84098: PUSH
84099: LD_VAR 0 2
84103: EQUAL
84104: AND
84105: IFFALSE 84117
// result := true else
84107: LD_ADDR_VAR 0 3
84111: PUSH
84112: LD_INT 1
84114: ST_TO_ADDR
84115: GO 84125
// result := false ;
84117: LD_ADDR_VAR 0 3
84121: PUSH
84122: LD_INT 0
84124: ST_TO_ADDR
// end else
84125: GO 84135
// result := false ;
84127: LD_ADDR_VAR 0 3
84131: PUSH
84132: LD_INT 0
84134: ST_TO_ADDR
// end ;
84135: LD_VAR 0 3
84139: RET
// export function HealTarget ( sci ) ; begin
84140: LD_INT 0
84142: PPUSH
// if not sci then
84143: LD_VAR 0 1
84147: NOT
84148: IFFALSE 84152
// exit ;
84150: GO 84217
// result := 0 ;
84152: LD_ADDR_VAR 0 2
84156: PUSH
84157: LD_INT 0
84159: ST_TO_ADDR
// if GetTaskList ( sci ) then
84160: LD_VAR 0 1
84164: PPUSH
84165: CALL_OW 437
84169: IFFALSE 84217
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84171: LD_VAR 0 1
84175: PPUSH
84176: CALL_OW 437
84180: PUSH
84181: LD_INT 1
84183: ARRAY
84184: PUSH
84185: LD_INT 1
84187: ARRAY
84188: PUSH
84189: LD_STRING l
84191: EQUAL
84192: IFFALSE 84217
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84194: LD_ADDR_VAR 0 2
84198: PUSH
84199: LD_VAR 0 1
84203: PPUSH
84204: CALL_OW 437
84208: PUSH
84209: LD_INT 1
84211: ARRAY
84212: PUSH
84213: LD_INT 4
84215: ARRAY
84216: ST_TO_ADDR
// end ;
84217: LD_VAR 0 2
84221: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84222: LD_INT 0
84224: PPUSH
84225: PPUSH
84226: PPUSH
84227: PPUSH
// if not base_units then
84228: LD_VAR 0 1
84232: NOT
84233: IFFALSE 84237
// exit ;
84235: GO 84324
// result := false ;
84237: LD_ADDR_VAR 0 2
84241: PUSH
84242: LD_INT 0
84244: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84245: LD_ADDR_VAR 0 5
84249: PUSH
84250: LD_VAR 0 1
84254: PPUSH
84255: LD_INT 21
84257: PUSH
84258: LD_INT 3
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PPUSH
84265: CALL_OW 72
84269: ST_TO_ADDR
// if not tmp then
84270: LD_VAR 0 5
84274: NOT
84275: IFFALSE 84279
// exit ;
84277: GO 84324
// for i in tmp do
84279: LD_ADDR_VAR 0 3
84283: PUSH
84284: LD_VAR 0 5
84288: PUSH
84289: FOR_IN
84290: IFFALSE 84322
// begin result := EnemyInRange ( i , 22 ) ;
84292: LD_ADDR_VAR 0 2
84296: PUSH
84297: LD_VAR 0 3
84301: PPUSH
84302: LD_INT 22
84304: PPUSH
84305: CALL 81902 0 2
84309: ST_TO_ADDR
// if result then
84310: LD_VAR 0 2
84314: IFFALSE 84320
// exit ;
84316: POP
84317: POP
84318: GO 84324
// end ;
84320: GO 84289
84322: POP
84323: POP
// end ;
84324: LD_VAR 0 2
84328: RET
// export function FilterByTag ( units , tag ) ; begin
84329: LD_INT 0
84331: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84332: LD_ADDR_VAR 0 3
84336: PUSH
84337: LD_VAR 0 1
84341: PPUSH
84342: LD_INT 120
84344: PUSH
84345: LD_VAR 0 2
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: PPUSH
84354: CALL_OW 72
84358: ST_TO_ADDR
// end ;
84359: LD_VAR 0 3
84363: RET
// export function IsDriver ( un ) ; begin
84364: LD_INT 0
84366: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84367: LD_ADDR_VAR 0 2
84371: PUSH
84372: LD_VAR 0 1
84376: PUSH
84377: LD_INT 55
84379: PUSH
84380: EMPTY
84381: LIST
84382: PPUSH
84383: CALL_OW 69
84387: IN
84388: ST_TO_ADDR
// end ;
84389: LD_VAR 0 2
84393: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84394: LD_INT 0
84396: PPUSH
84397: PPUSH
// list := [ ] ;
84398: LD_ADDR_VAR 0 5
84402: PUSH
84403: EMPTY
84404: ST_TO_ADDR
// case d of 0 :
84405: LD_VAR 0 3
84409: PUSH
84410: LD_INT 0
84412: DOUBLE
84413: EQUAL
84414: IFTRUE 84418
84416: GO 84551
84418: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84419: LD_ADDR_VAR 0 5
84423: PUSH
84424: LD_VAR 0 1
84428: PUSH
84429: LD_INT 4
84431: MINUS
84432: PUSH
84433: LD_VAR 0 2
84437: PUSH
84438: LD_INT 4
84440: MINUS
84441: PUSH
84442: LD_INT 2
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: LIST
84449: PUSH
84450: LD_VAR 0 1
84454: PUSH
84455: LD_INT 3
84457: MINUS
84458: PUSH
84459: LD_VAR 0 2
84463: PUSH
84464: LD_INT 1
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: LIST
84471: PUSH
84472: LD_VAR 0 1
84476: PUSH
84477: LD_INT 4
84479: PLUS
84480: PUSH
84481: LD_VAR 0 2
84485: PUSH
84486: LD_INT 4
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: LIST
84493: PUSH
84494: LD_VAR 0 1
84498: PUSH
84499: LD_INT 3
84501: PLUS
84502: PUSH
84503: LD_VAR 0 2
84507: PUSH
84508: LD_INT 3
84510: PLUS
84511: PUSH
84512: LD_INT 5
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: LIST
84519: PUSH
84520: LD_VAR 0 1
84524: PUSH
84525: LD_VAR 0 2
84529: PUSH
84530: LD_INT 4
84532: PLUS
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: LIST
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: ST_TO_ADDR
// end ; 1 :
84549: GO 85249
84551: LD_INT 1
84553: DOUBLE
84554: EQUAL
84555: IFTRUE 84559
84557: GO 84692
84559: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84560: LD_ADDR_VAR 0 5
84564: PUSH
84565: LD_VAR 0 1
84569: PUSH
84570: LD_VAR 0 2
84574: PUSH
84575: LD_INT 4
84577: MINUS
84578: PUSH
84579: LD_INT 3
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: LIST
84586: PUSH
84587: LD_VAR 0 1
84591: PUSH
84592: LD_INT 3
84594: MINUS
84595: PUSH
84596: LD_VAR 0 2
84600: PUSH
84601: LD_INT 3
84603: MINUS
84604: PUSH
84605: LD_INT 2
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: PUSH
84613: LD_VAR 0 1
84617: PUSH
84618: LD_INT 4
84620: MINUS
84621: PUSH
84622: LD_VAR 0 2
84626: PUSH
84627: LD_INT 1
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: LIST
84634: PUSH
84635: LD_VAR 0 1
84639: PUSH
84640: LD_VAR 0 2
84644: PUSH
84645: LD_INT 3
84647: PLUS
84648: PUSH
84649: LD_INT 0
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: PUSH
84657: LD_VAR 0 1
84661: PUSH
84662: LD_INT 4
84664: PLUS
84665: PUSH
84666: LD_VAR 0 2
84670: PUSH
84671: LD_INT 4
84673: PLUS
84674: PUSH
84675: LD_INT 5
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: LIST
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: ST_TO_ADDR
// end ; 2 :
84690: GO 85249
84692: LD_INT 2
84694: DOUBLE
84695: EQUAL
84696: IFTRUE 84700
84698: GO 84829
84700: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84701: LD_ADDR_VAR 0 5
84705: PUSH
84706: LD_VAR 0 1
84710: PUSH
84711: LD_VAR 0 2
84715: PUSH
84716: LD_INT 3
84718: MINUS
84719: PUSH
84720: LD_INT 3
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: LIST
84727: PUSH
84728: LD_VAR 0 1
84732: PUSH
84733: LD_INT 4
84735: PLUS
84736: PUSH
84737: LD_VAR 0 2
84741: PUSH
84742: LD_INT 4
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: LIST
84749: PUSH
84750: LD_VAR 0 1
84754: PUSH
84755: LD_VAR 0 2
84759: PUSH
84760: LD_INT 4
84762: PLUS
84763: PUSH
84764: LD_INT 0
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: LIST
84771: PUSH
84772: LD_VAR 0 1
84776: PUSH
84777: LD_INT 3
84779: MINUS
84780: PUSH
84781: LD_VAR 0 2
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: LIST
84793: PUSH
84794: LD_VAR 0 1
84798: PUSH
84799: LD_INT 4
84801: MINUS
84802: PUSH
84803: LD_VAR 0 2
84807: PUSH
84808: LD_INT 4
84810: MINUS
84811: PUSH
84812: LD_INT 2
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: LIST
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: ST_TO_ADDR
// end ; 3 :
84827: GO 85249
84829: LD_INT 3
84831: DOUBLE
84832: EQUAL
84833: IFTRUE 84837
84835: GO 84970
84837: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84838: LD_ADDR_VAR 0 5
84842: PUSH
84843: LD_VAR 0 1
84847: PUSH
84848: LD_INT 3
84850: PLUS
84851: PUSH
84852: LD_VAR 0 2
84856: PUSH
84857: LD_INT 4
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: LIST
84864: PUSH
84865: LD_VAR 0 1
84869: PUSH
84870: LD_INT 4
84872: PLUS
84873: PUSH
84874: LD_VAR 0 2
84878: PUSH
84879: LD_INT 4
84881: PLUS
84882: PUSH
84883: LD_INT 5
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: LIST
84890: PUSH
84891: LD_VAR 0 1
84895: PUSH
84896: LD_INT 4
84898: MINUS
84899: PUSH
84900: LD_VAR 0 2
84904: PUSH
84905: LD_INT 1
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: LIST
84912: PUSH
84913: LD_VAR 0 1
84917: PUSH
84918: LD_VAR 0 2
84922: PUSH
84923: LD_INT 4
84925: MINUS
84926: PUSH
84927: LD_INT 3
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: LIST
84934: PUSH
84935: LD_VAR 0 1
84939: PUSH
84940: LD_INT 3
84942: MINUS
84943: PUSH
84944: LD_VAR 0 2
84948: PUSH
84949: LD_INT 3
84951: MINUS
84952: PUSH
84953: LD_INT 2
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: LIST
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: ST_TO_ADDR
// end ; 4 :
84968: GO 85249
84970: LD_INT 4
84972: DOUBLE
84973: EQUAL
84974: IFTRUE 84978
84976: GO 85111
84978: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84979: LD_ADDR_VAR 0 5
84983: PUSH
84984: LD_VAR 0 1
84988: PUSH
84989: LD_VAR 0 2
84993: PUSH
84994: LD_INT 4
84996: PLUS
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: LIST
85005: PUSH
85006: LD_VAR 0 1
85010: PUSH
85011: LD_INT 3
85013: PLUS
85014: PUSH
85015: LD_VAR 0 2
85019: PUSH
85020: LD_INT 3
85022: PLUS
85023: PUSH
85024: LD_INT 5
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: LIST
85031: PUSH
85032: LD_VAR 0 1
85036: PUSH
85037: LD_INT 4
85039: PLUS
85040: PUSH
85041: LD_VAR 0 2
85045: PUSH
85046: LD_INT 4
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: LIST
85053: PUSH
85054: LD_VAR 0 1
85058: PUSH
85059: LD_VAR 0 2
85063: PUSH
85064: LD_INT 3
85066: MINUS
85067: PUSH
85068: LD_INT 3
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: LIST
85075: PUSH
85076: LD_VAR 0 1
85080: PUSH
85081: LD_INT 4
85083: MINUS
85084: PUSH
85085: LD_VAR 0 2
85089: PUSH
85090: LD_INT 4
85092: MINUS
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: LIST
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: ST_TO_ADDR
// end ; 5 :
85109: GO 85249
85111: LD_INT 5
85113: DOUBLE
85114: EQUAL
85115: IFTRUE 85119
85117: GO 85248
85119: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85120: LD_ADDR_VAR 0 5
85124: PUSH
85125: LD_VAR 0 1
85129: PUSH
85130: LD_INT 4
85132: MINUS
85133: PUSH
85134: LD_VAR 0 2
85138: PUSH
85139: LD_INT 1
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: LIST
85146: PUSH
85147: LD_VAR 0 1
85151: PUSH
85152: LD_VAR 0 2
85156: PUSH
85157: LD_INT 4
85159: MINUS
85160: PUSH
85161: LD_INT 3
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: LIST
85168: PUSH
85169: LD_VAR 0 1
85173: PUSH
85174: LD_INT 4
85176: PLUS
85177: PUSH
85178: LD_VAR 0 2
85182: PUSH
85183: LD_INT 4
85185: PLUS
85186: PUSH
85187: LD_INT 5
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: LIST
85194: PUSH
85195: LD_VAR 0 1
85199: PUSH
85200: LD_INT 3
85202: PLUS
85203: PUSH
85204: LD_VAR 0 2
85208: PUSH
85209: LD_INT 4
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: LIST
85216: PUSH
85217: LD_VAR 0 1
85221: PUSH
85222: LD_VAR 0 2
85226: PUSH
85227: LD_INT 3
85229: PLUS
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: LIST
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: ST_TO_ADDR
// end ; end ;
85246: GO 85249
85248: POP
// result := list ;
85249: LD_ADDR_VAR 0 4
85253: PUSH
85254: LD_VAR 0 5
85258: ST_TO_ADDR
// end ;
85259: LD_VAR 0 4
85263: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85264: LD_INT 0
85266: PPUSH
85267: PPUSH
85268: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85269: LD_VAR 0 1
85273: NOT
85274: PUSH
85275: LD_VAR 0 2
85279: PUSH
85280: LD_INT 1
85282: PUSH
85283: LD_INT 2
85285: PUSH
85286: LD_INT 3
85288: PUSH
85289: LD_INT 4
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: IN
85298: NOT
85299: OR
85300: IFFALSE 85304
// exit ;
85302: GO 85387
// tmp := [ ] ;
85304: LD_ADDR_VAR 0 5
85308: PUSH
85309: EMPTY
85310: ST_TO_ADDR
// for i in units do
85311: LD_ADDR_VAR 0 4
85315: PUSH
85316: LD_VAR 0 1
85320: PUSH
85321: FOR_IN
85322: IFFALSE 85356
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85324: LD_ADDR_VAR 0 5
85328: PUSH
85329: LD_VAR 0 5
85333: PPUSH
85334: LD_VAR 0 4
85338: PPUSH
85339: LD_VAR 0 2
85343: PPUSH
85344: CALL_OW 259
85348: PPUSH
85349: CALL 86760 0 2
85353: ST_TO_ADDR
85354: GO 85321
85356: POP
85357: POP
// if not tmp then
85358: LD_VAR 0 5
85362: NOT
85363: IFFALSE 85367
// exit ;
85365: GO 85387
// result := SortListByListDesc ( units , tmp ) ;
85367: LD_ADDR_VAR 0 3
85371: PUSH
85372: LD_VAR 0 1
85376: PPUSH
85377: LD_VAR 0 5
85381: PPUSH
85382: CALL_OW 77
85386: ST_TO_ADDR
// end ;
85387: LD_VAR 0 3
85391: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85392: LD_INT 0
85394: PPUSH
85395: PPUSH
85396: PPUSH
// result := false ;
85397: LD_ADDR_VAR 0 3
85401: PUSH
85402: LD_INT 0
85404: ST_TO_ADDR
// if not building then
85405: LD_VAR 0 2
85409: NOT
85410: IFFALSE 85414
// exit ;
85412: GO 85552
// x := GetX ( building ) ;
85414: LD_ADDR_VAR 0 4
85418: PUSH
85419: LD_VAR 0 2
85423: PPUSH
85424: CALL_OW 250
85428: ST_TO_ADDR
// y := GetY ( building ) ;
85429: LD_ADDR_VAR 0 5
85433: PUSH
85434: LD_VAR 0 2
85438: PPUSH
85439: CALL_OW 251
85443: ST_TO_ADDR
// if not x or not y then
85444: LD_VAR 0 4
85448: NOT
85449: PUSH
85450: LD_VAR 0 5
85454: NOT
85455: OR
85456: IFFALSE 85460
// exit ;
85458: GO 85552
// if GetTaskList ( unit ) then
85460: LD_VAR 0 1
85464: PPUSH
85465: CALL_OW 437
85469: IFFALSE 85552
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85471: LD_STRING e
85473: PUSH
85474: LD_VAR 0 1
85478: PPUSH
85479: CALL_OW 437
85483: PUSH
85484: LD_INT 1
85486: ARRAY
85487: PUSH
85488: LD_INT 1
85490: ARRAY
85491: EQUAL
85492: PUSH
85493: LD_VAR 0 4
85497: PUSH
85498: LD_VAR 0 1
85502: PPUSH
85503: CALL_OW 437
85507: PUSH
85508: LD_INT 1
85510: ARRAY
85511: PUSH
85512: LD_INT 2
85514: ARRAY
85515: EQUAL
85516: AND
85517: PUSH
85518: LD_VAR 0 5
85522: PUSH
85523: LD_VAR 0 1
85527: PPUSH
85528: CALL_OW 437
85532: PUSH
85533: LD_INT 1
85535: ARRAY
85536: PUSH
85537: LD_INT 3
85539: ARRAY
85540: EQUAL
85541: AND
85542: IFFALSE 85552
// result := true end ;
85544: LD_ADDR_VAR 0 3
85548: PUSH
85549: LD_INT 1
85551: ST_TO_ADDR
// end ;
85552: LD_VAR 0 3
85556: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85557: LD_INT 0
85559: PPUSH
// result := false ;
85560: LD_ADDR_VAR 0 4
85564: PUSH
85565: LD_INT 0
85567: ST_TO_ADDR
// if GetTaskList ( unit ) then
85568: LD_VAR 0 1
85572: PPUSH
85573: CALL_OW 437
85577: IFFALSE 85660
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85579: LD_STRING M
85581: PUSH
85582: LD_VAR 0 1
85586: PPUSH
85587: CALL_OW 437
85591: PUSH
85592: LD_INT 1
85594: ARRAY
85595: PUSH
85596: LD_INT 1
85598: ARRAY
85599: EQUAL
85600: PUSH
85601: LD_VAR 0 2
85605: PUSH
85606: LD_VAR 0 1
85610: PPUSH
85611: CALL_OW 437
85615: PUSH
85616: LD_INT 1
85618: ARRAY
85619: PUSH
85620: LD_INT 2
85622: ARRAY
85623: EQUAL
85624: AND
85625: PUSH
85626: LD_VAR 0 3
85630: PUSH
85631: LD_VAR 0 1
85635: PPUSH
85636: CALL_OW 437
85640: PUSH
85641: LD_INT 1
85643: ARRAY
85644: PUSH
85645: LD_INT 3
85647: ARRAY
85648: EQUAL
85649: AND
85650: IFFALSE 85660
// result := true ;
85652: LD_ADDR_VAR 0 4
85656: PUSH
85657: LD_INT 1
85659: ST_TO_ADDR
// end ; end ;
85660: LD_VAR 0 4
85664: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85665: LD_INT 0
85667: PPUSH
85668: PPUSH
85669: PPUSH
85670: PPUSH
// if not unit or not area then
85671: LD_VAR 0 1
85675: NOT
85676: PUSH
85677: LD_VAR 0 2
85681: NOT
85682: OR
85683: IFFALSE 85687
// exit ;
85685: GO 85863
// tmp := AreaToList ( area , i ) ;
85687: LD_ADDR_VAR 0 6
85691: PUSH
85692: LD_VAR 0 2
85696: PPUSH
85697: LD_VAR 0 5
85701: PPUSH
85702: CALL_OW 517
85706: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85707: LD_ADDR_VAR 0 5
85711: PUSH
85712: DOUBLE
85713: LD_INT 1
85715: DEC
85716: ST_TO_ADDR
85717: LD_VAR 0 6
85721: PUSH
85722: LD_INT 1
85724: ARRAY
85725: PUSH
85726: FOR_TO
85727: IFFALSE 85861
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85729: LD_ADDR_VAR 0 7
85733: PUSH
85734: LD_VAR 0 6
85738: PUSH
85739: LD_INT 1
85741: ARRAY
85742: PUSH
85743: LD_VAR 0 5
85747: ARRAY
85748: PUSH
85749: LD_VAR 0 6
85753: PUSH
85754: LD_INT 2
85756: ARRAY
85757: PUSH
85758: LD_VAR 0 5
85762: ARRAY
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85768: LD_INT 92
85770: PUSH
85771: LD_VAR 0 7
85775: PUSH
85776: LD_INT 1
85778: ARRAY
85779: PUSH
85780: LD_VAR 0 7
85784: PUSH
85785: LD_INT 2
85787: ARRAY
85788: PUSH
85789: LD_INT 2
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: PPUSH
85798: CALL_OW 69
85802: PUSH
85803: LD_INT 0
85805: EQUAL
85806: IFFALSE 85859
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85808: LD_VAR 0 1
85812: PPUSH
85813: LD_VAR 0 7
85817: PUSH
85818: LD_INT 1
85820: ARRAY
85821: PPUSH
85822: LD_VAR 0 7
85826: PUSH
85827: LD_INT 2
85829: ARRAY
85830: PPUSH
85831: LD_VAR 0 3
85835: PPUSH
85836: CALL_OW 48
// result := IsPlaced ( unit ) ;
85840: LD_ADDR_VAR 0 4
85844: PUSH
85845: LD_VAR 0 1
85849: PPUSH
85850: CALL_OW 305
85854: ST_TO_ADDR
// exit ;
85855: POP
85856: POP
85857: GO 85863
// end ; end ;
85859: GO 85726
85861: POP
85862: POP
// end ;
85863: LD_VAR 0 4
85867: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85868: LD_INT 0
85870: PPUSH
85871: PPUSH
85872: PPUSH
// if not side or side > 8 then
85873: LD_VAR 0 1
85877: NOT
85878: PUSH
85879: LD_VAR 0 1
85883: PUSH
85884: LD_INT 8
85886: GREATER
85887: OR
85888: IFFALSE 85892
// exit ;
85890: GO 86079
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85892: LD_ADDR_VAR 0 4
85896: PUSH
85897: LD_INT 22
85899: PUSH
85900: LD_VAR 0 1
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 21
85911: PUSH
85912: LD_INT 3
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PPUSH
85923: CALL_OW 69
85927: ST_TO_ADDR
// if not tmp then
85928: LD_VAR 0 4
85932: NOT
85933: IFFALSE 85937
// exit ;
85935: GO 86079
// enable_addtolog := true ;
85937: LD_ADDR_OWVAR 81
85941: PUSH
85942: LD_INT 1
85944: ST_TO_ADDR
// AddToLog ( [ ) ;
85945: LD_STRING [
85947: PPUSH
85948: CALL_OW 561
// for i in tmp do
85952: LD_ADDR_VAR 0 3
85956: PUSH
85957: LD_VAR 0 4
85961: PUSH
85962: FOR_IN
85963: IFFALSE 86070
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85965: LD_STRING [
85967: PUSH
85968: LD_VAR 0 3
85972: PPUSH
85973: CALL_OW 266
85977: STR
85978: PUSH
85979: LD_STRING , 
85981: STR
85982: PUSH
85983: LD_VAR 0 3
85987: PPUSH
85988: CALL_OW 250
85992: STR
85993: PUSH
85994: LD_STRING , 
85996: STR
85997: PUSH
85998: LD_VAR 0 3
86002: PPUSH
86003: CALL_OW 251
86007: STR
86008: PUSH
86009: LD_STRING , 
86011: STR
86012: PUSH
86013: LD_VAR 0 3
86017: PPUSH
86018: CALL_OW 254
86022: STR
86023: PUSH
86024: LD_STRING , 
86026: STR
86027: PUSH
86028: LD_VAR 0 3
86032: PPUSH
86033: LD_INT 1
86035: PPUSH
86036: CALL_OW 268
86040: STR
86041: PUSH
86042: LD_STRING , 
86044: STR
86045: PUSH
86046: LD_VAR 0 3
86050: PPUSH
86051: LD_INT 2
86053: PPUSH
86054: CALL_OW 268
86058: STR
86059: PUSH
86060: LD_STRING ],
86062: STR
86063: PPUSH
86064: CALL_OW 561
// end ;
86068: GO 85962
86070: POP
86071: POP
// AddToLog ( ]; ) ;
86072: LD_STRING ];
86074: PPUSH
86075: CALL_OW 561
// end ;
86079: LD_VAR 0 2
86083: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86084: LD_INT 0
86086: PPUSH
86087: PPUSH
86088: PPUSH
86089: PPUSH
86090: PPUSH
// if not area or not rate or not max then
86091: LD_VAR 0 1
86095: NOT
86096: PUSH
86097: LD_VAR 0 2
86101: NOT
86102: OR
86103: PUSH
86104: LD_VAR 0 4
86108: NOT
86109: OR
86110: IFFALSE 86114
// exit ;
86112: GO 86303
// while 1 do
86114: LD_INT 1
86116: IFFALSE 86303
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86118: LD_ADDR_VAR 0 9
86122: PUSH
86123: LD_VAR 0 1
86127: PPUSH
86128: LD_INT 1
86130: PPUSH
86131: CALL_OW 287
86135: PUSH
86136: LD_INT 10
86138: MUL
86139: ST_TO_ADDR
// r := rate / 10 ;
86140: LD_ADDR_VAR 0 7
86144: PUSH
86145: LD_VAR 0 2
86149: PUSH
86150: LD_INT 10
86152: DIVREAL
86153: ST_TO_ADDR
// time := 1 1$00 ;
86154: LD_ADDR_VAR 0 8
86158: PUSH
86159: LD_INT 2100
86161: ST_TO_ADDR
// if amount < min then
86162: LD_VAR 0 9
86166: PUSH
86167: LD_VAR 0 3
86171: LESS
86172: IFFALSE 86190
// r := r * 2 else
86174: LD_ADDR_VAR 0 7
86178: PUSH
86179: LD_VAR 0 7
86183: PUSH
86184: LD_INT 2
86186: MUL
86187: ST_TO_ADDR
86188: GO 86216
// if amount > max then
86190: LD_VAR 0 9
86194: PUSH
86195: LD_VAR 0 4
86199: GREATER
86200: IFFALSE 86216
// r := r / 2 ;
86202: LD_ADDR_VAR 0 7
86206: PUSH
86207: LD_VAR 0 7
86211: PUSH
86212: LD_INT 2
86214: DIVREAL
86215: ST_TO_ADDR
// time := time / r ;
86216: LD_ADDR_VAR 0 8
86220: PUSH
86221: LD_VAR 0 8
86225: PUSH
86226: LD_VAR 0 7
86230: DIVREAL
86231: ST_TO_ADDR
// if time < 0 then
86232: LD_VAR 0 8
86236: PUSH
86237: LD_INT 0
86239: LESS
86240: IFFALSE 86257
// time := time * - 1 ;
86242: LD_ADDR_VAR 0 8
86246: PUSH
86247: LD_VAR 0 8
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: MUL
86256: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86257: LD_VAR 0 8
86261: PUSH
86262: LD_INT 35
86264: PPUSH
86265: LD_INT 875
86267: PPUSH
86268: CALL_OW 12
86272: PLUS
86273: PPUSH
86274: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86278: LD_INT 1
86280: PPUSH
86281: LD_INT 5
86283: PPUSH
86284: CALL_OW 12
86288: PPUSH
86289: LD_VAR 0 1
86293: PPUSH
86294: LD_INT 1
86296: PPUSH
86297: CALL_OW 55
// end ;
86301: GO 86114
// end ;
86303: LD_VAR 0 5
86307: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86308: LD_INT 0
86310: PPUSH
86311: PPUSH
86312: PPUSH
86313: PPUSH
86314: PPUSH
86315: PPUSH
86316: PPUSH
86317: PPUSH
// if not turrets or not factories then
86318: LD_VAR 0 1
86322: NOT
86323: PUSH
86324: LD_VAR 0 2
86328: NOT
86329: OR
86330: IFFALSE 86334
// exit ;
86332: GO 86641
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86334: LD_ADDR_VAR 0 10
86338: PUSH
86339: LD_INT 5
86341: PUSH
86342: LD_INT 6
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 2
86351: PUSH
86352: LD_INT 4
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 3
86361: PUSH
86362: LD_INT 5
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 24
86376: PUSH
86377: LD_INT 25
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PUSH
86384: LD_INT 23
86386: PUSH
86387: LD_INT 27
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 42
86400: PUSH
86401: LD_INT 43
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 44
86410: PUSH
86411: LD_INT 46
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 45
86420: PUSH
86421: LD_INT 47
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: LIST
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: LIST
86437: ST_TO_ADDR
// result := [ ] ;
86438: LD_ADDR_VAR 0 3
86442: PUSH
86443: EMPTY
86444: ST_TO_ADDR
// for i in turrets do
86445: LD_ADDR_VAR 0 4
86449: PUSH
86450: LD_VAR 0 1
86454: PUSH
86455: FOR_IN
86456: IFFALSE 86639
// begin nat := GetNation ( i ) ;
86458: LD_ADDR_VAR 0 7
86462: PUSH
86463: LD_VAR 0 4
86467: PPUSH
86468: CALL_OW 248
86472: ST_TO_ADDR
// weapon := 0 ;
86473: LD_ADDR_VAR 0 8
86477: PUSH
86478: LD_INT 0
86480: ST_TO_ADDR
// if not nat then
86481: LD_VAR 0 7
86485: NOT
86486: IFFALSE 86490
// continue ;
86488: GO 86455
// for j in list [ nat ] do
86490: LD_ADDR_VAR 0 5
86494: PUSH
86495: LD_VAR 0 10
86499: PUSH
86500: LD_VAR 0 7
86504: ARRAY
86505: PUSH
86506: FOR_IN
86507: IFFALSE 86548
// if GetBWeapon ( i ) = j [ 1 ] then
86509: LD_VAR 0 4
86513: PPUSH
86514: CALL_OW 269
86518: PUSH
86519: LD_VAR 0 5
86523: PUSH
86524: LD_INT 1
86526: ARRAY
86527: EQUAL
86528: IFFALSE 86546
// begin weapon := j [ 2 ] ;
86530: LD_ADDR_VAR 0 8
86534: PUSH
86535: LD_VAR 0 5
86539: PUSH
86540: LD_INT 2
86542: ARRAY
86543: ST_TO_ADDR
// break ;
86544: GO 86548
// end ;
86546: GO 86506
86548: POP
86549: POP
// if not weapon then
86550: LD_VAR 0 8
86554: NOT
86555: IFFALSE 86559
// continue ;
86557: GO 86455
// for k in factories do
86559: LD_ADDR_VAR 0 6
86563: PUSH
86564: LD_VAR 0 2
86568: PUSH
86569: FOR_IN
86570: IFFALSE 86635
// begin weapons := AvailableWeaponList ( k ) ;
86572: LD_ADDR_VAR 0 9
86576: PUSH
86577: LD_VAR 0 6
86581: PPUSH
86582: CALL_OW 478
86586: ST_TO_ADDR
// if not weapons then
86587: LD_VAR 0 9
86591: NOT
86592: IFFALSE 86596
// continue ;
86594: GO 86569
// if weapon in weapons then
86596: LD_VAR 0 8
86600: PUSH
86601: LD_VAR 0 9
86605: IN
86606: IFFALSE 86633
// begin result := [ i , weapon ] ;
86608: LD_ADDR_VAR 0 3
86612: PUSH
86613: LD_VAR 0 4
86617: PUSH
86618: LD_VAR 0 8
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: ST_TO_ADDR
// exit ;
86627: POP
86628: POP
86629: POP
86630: POP
86631: GO 86641
// end ; end ;
86633: GO 86569
86635: POP
86636: POP
// end ;
86637: GO 86455
86639: POP
86640: POP
// end ;
86641: LD_VAR 0 3
86645: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86646: LD_INT 0
86648: PPUSH
// if not side or side > 8 then
86649: LD_VAR 0 3
86653: NOT
86654: PUSH
86655: LD_VAR 0 3
86659: PUSH
86660: LD_INT 8
86662: GREATER
86663: OR
86664: IFFALSE 86668
// exit ;
86666: GO 86727
// if not range then
86668: LD_VAR 0 4
86672: NOT
86673: IFFALSE 86684
// range := - 12 ;
86675: LD_ADDR_VAR 0 4
86679: PUSH
86680: LD_INT 12
86682: NEG
86683: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86684: LD_VAR 0 1
86688: PPUSH
86689: LD_VAR 0 2
86693: PPUSH
86694: LD_VAR 0 3
86698: PPUSH
86699: LD_VAR 0 4
86703: PPUSH
86704: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86708: LD_VAR 0 1
86712: PPUSH
86713: LD_VAR 0 2
86717: PPUSH
86718: LD_VAR 0 3
86722: PPUSH
86723: CALL_OW 331
// end ;
86727: LD_VAR 0 5
86731: RET
// export function Video ( mode ) ; begin
86732: LD_INT 0
86734: PPUSH
// ingame_video = mode ;
86735: LD_ADDR_OWVAR 52
86739: PUSH
86740: LD_VAR 0 1
86744: ST_TO_ADDR
// interface_hidden = mode ;
86745: LD_ADDR_OWVAR 54
86749: PUSH
86750: LD_VAR 0 1
86754: ST_TO_ADDR
// end ;
86755: LD_VAR 0 2
86759: RET
// export function Join ( array , element ) ; begin
86760: LD_INT 0
86762: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86763: LD_ADDR_VAR 0 3
86767: PUSH
86768: LD_VAR 0 1
86772: PPUSH
86773: LD_VAR 0 1
86777: PUSH
86778: LD_INT 1
86780: PLUS
86781: PPUSH
86782: LD_VAR 0 2
86786: PPUSH
86787: CALL_OW 1
86791: ST_TO_ADDR
// end ;
86792: LD_VAR 0 3
86796: RET
// export function JoinUnion ( array , element ) ; begin
86797: LD_INT 0
86799: PPUSH
// result := array union element ;
86800: LD_ADDR_VAR 0 3
86804: PUSH
86805: LD_VAR 0 1
86809: PUSH
86810: LD_VAR 0 2
86814: UNION
86815: ST_TO_ADDR
// end ;
86816: LD_VAR 0 3
86820: RET
// export function GetBehemoths ( side ) ; begin
86821: LD_INT 0
86823: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86824: LD_ADDR_VAR 0 2
86828: PUSH
86829: LD_INT 22
86831: PUSH
86832: LD_VAR 0 1
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 31
86843: PUSH
86844: LD_INT 25
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PPUSH
86855: CALL_OW 69
86859: ST_TO_ADDR
// end ;
86860: LD_VAR 0 2
86864: RET
// export function Shuffle ( array ) ; var i , index ; begin
86865: LD_INT 0
86867: PPUSH
86868: PPUSH
86869: PPUSH
// result := [ ] ;
86870: LD_ADDR_VAR 0 2
86874: PUSH
86875: EMPTY
86876: ST_TO_ADDR
// if not array then
86877: LD_VAR 0 1
86881: NOT
86882: IFFALSE 86886
// exit ;
86884: GO 86985
// Randomize ;
86886: CALL_OW 10
// for i = array downto 1 do
86890: LD_ADDR_VAR 0 3
86894: PUSH
86895: DOUBLE
86896: LD_VAR 0 1
86900: INC
86901: ST_TO_ADDR
86902: LD_INT 1
86904: PUSH
86905: FOR_DOWNTO
86906: IFFALSE 86983
// begin index := rand ( 1 , array ) ;
86908: LD_ADDR_VAR 0 4
86912: PUSH
86913: LD_INT 1
86915: PPUSH
86916: LD_VAR 0 1
86920: PPUSH
86921: CALL_OW 12
86925: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86926: LD_ADDR_VAR 0 2
86930: PUSH
86931: LD_VAR 0 2
86935: PPUSH
86936: LD_VAR 0 2
86940: PUSH
86941: LD_INT 1
86943: PLUS
86944: PPUSH
86945: LD_VAR 0 1
86949: PUSH
86950: LD_VAR 0 4
86954: ARRAY
86955: PPUSH
86956: CALL_OW 2
86960: ST_TO_ADDR
// array := Delete ( array , index ) ;
86961: LD_ADDR_VAR 0 1
86965: PUSH
86966: LD_VAR 0 1
86970: PPUSH
86971: LD_VAR 0 4
86975: PPUSH
86976: CALL_OW 3
86980: ST_TO_ADDR
// end ;
86981: GO 86905
86983: POP
86984: POP
// end ;
86985: LD_VAR 0 2
86989: RET
// export function GetBaseMaterials ( base ) ; begin
86990: LD_INT 0
86992: PPUSH
// result := [ 0 , 0 , 0 ] ;
86993: LD_ADDR_VAR 0 2
86997: PUSH
86998: LD_INT 0
87000: PUSH
87001: LD_INT 0
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: LIST
87011: ST_TO_ADDR
// if not base then
87012: LD_VAR 0 1
87016: NOT
87017: IFFALSE 87021
// exit ;
87019: GO 87070
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87021: LD_ADDR_VAR 0 2
87025: PUSH
87026: LD_VAR 0 1
87030: PPUSH
87031: LD_INT 1
87033: PPUSH
87034: CALL_OW 275
87038: PUSH
87039: LD_VAR 0 1
87043: PPUSH
87044: LD_INT 2
87046: PPUSH
87047: CALL_OW 275
87051: PUSH
87052: LD_VAR 0 1
87056: PPUSH
87057: LD_INT 3
87059: PPUSH
87060: CALL_OW 275
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: LIST
87069: ST_TO_ADDR
// end ;
87070: LD_VAR 0 2
87074: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87075: LD_INT 0
87077: PPUSH
87078: PPUSH
// result := array ;
87079: LD_ADDR_VAR 0 3
87083: PUSH
87084: LD_VAR 0 1
87088: ST_TO_ADDR
// if size >= result then
87089: LD_VAR 0 2
87093: PUSH
87094: LD_VAR 0 3
87098: GREATEREQUAL
87099: IFFALSE 87103
// exit ;
87101: GO 87153
// if size then
87103: LD_VAR 0 2
87107: IFFALSE 87153
// for i := array downto size do
87109: LD_ADDR_VAR 0 4
87113: PUSH
87114: DOUBLE
87115: LD_VAR 0 1
87119: INC
87120: ST_TO_ADDR
87121: LD_VAR 0 2
87125: PUSH
87126: FOR_DOWNTO
87127: IFFALSE 87151
// result := Delete ( result , result ) ;
87129: LD_ADDR_VAR 0 3
87133: PUSH
87134: LD_VAR 0 3
87138: PPUSH
87139: LD_VAR 0 3
87143: PPUSH
87144: CALL_OW 3
87148: ST_TO_ADDR
87149: GO 87126
87151: POP
87152: POP
// end ;
87153: LD_VAR 0 3
87157: RET
// export function ComExit ( unit ) ; var tmp ; begin
87158: LD_INT 0
87160: PPUSH
87161: PPUSH
// if not IsInUnit ( unit ) then
87162: LD_VAR 0 1
87166: PPUSH
87167: CALL_OW 310
87171: NOT
87172: IFFALSE 87176
// exit ;
87174: GO 87236
// tmp := IsInUnit ( unit ) ;
87176: LD_ADDR_VAR 0 3
87180: PUSH
87181: LD_VAR 0 1
87185: PPUSH
87186: CALL_OW 310
87190: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87191: LD_VAR 0 3
87195: PPUSH
87196: CALL_OW 247
87200: PUSH
87201: LD_INT 2
87203: EQUAL
87204: IFFALSE 87217
// ComExitVehicle ( unit ) else
87206: LD_VAR 0 1
87210: PPUSH
87211: CALL_OW 121
87215: GO 87226
// ComExitBuilding ( unit ) ;
87217: LD_VAR 0 1
87221: PPUSH
87222: CALL_OW 122
// result := tmp ;
87226: LD_ADDR_VAR 0 2
87230: PUSH
87231: LD_VAR 0 3
87235: ST_TO_ADDR
// end ;
87236: LD_VAR 0 2
87240: RET
// export function ComExitAll ( units ) ; var i ; begin
87241: LD_INT 0
87243: PPUSH
87244: PPUSH
// if not units then
87245: LD_VAR 0 1
87249: NOT
87250: IFFALSE 87254
// exit ;
87252: GO 87280
// for i in units do
87254: LD_ADDR_VAR 0 3
87258: PUSH
87259: LD_VAR 0 1
87263: PUSH
87264: FOR_IN
87265: IFFALSE 87278
// ComExit ( i ) ;
87267: LD_VAR 0 3
87271: PPUSH
87272: CALL 87158 0 1
87276: GO 87264
87278: POP
87279: POP
// end ;
87280: LD_VAR 0 2
87284: RET
// export function ResetHc ; begin
87285: LD_INT 0
87287: PPUSH
// InitHc ;
87288: CALL_OW 19
// hc_importance := 0 ;
87292: LD_ADDR_OWVAR 32
87296: PUSH
87297: LD_INT 0
87299: ST_TO_ADDR
// end ;
87300: LD_VAR 0 1
87304: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87305: LD_INT 0
87307: PPUSH
87308: PPUSH
87309: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87310: LD_ADDR_VAR 0 6
87314: PUSH
87315: LD_VAR 0 1
87319: PUSH
87320: LD_VAR 0 3
87324: PLUS
87325: PUSH
87326: LD_INT 2
87328: DIV
87329: ST_TO_ADDR
// if _x < 0 then
87330: LD_VAR 0 6
87334: PUSH
87335: LD_INT 0
87337: LESS
87338: IFFALSE 87355
// _x := _x * - 1 ;
87340: LD_ADDR_VAR 0 6
87344: PUSH
87345: LD_VAR 0 6
87349: PUSH
87350: LD_INT 1
87352: NEG
87353: MUL
87354: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87355: LD_ADDR_VAR 0 7
87359: PUSH
87360: LD_VAR 0 2
87364: PUSH
87365: LD_VAR 0 4
87369: PLUS
87370: PUSH
87371: LD_INT 2
87373: DIV
87374: ST_TO_ADDR
// if _y < 0 then
87375: LD_VAR 0 7
87379: PUSH
87380: LD_INT 0
87382: LESS
87383: IFFALSE 87400
// _y := _y * - 1 ;
87385: LD_ADDR_VAR 0 7
87389: PUSH
87390: LD_VAR 0 7
87394: PUSH
87395: LD_INT 1
87397: NEG
87398: MUL
87399: ST_TO_ADDR
// result := [ _x , _y ] ;
87400: LD_ADDR_VAR 0 5
87404: PUSH
87405: LD_VAR 0 6
87409: PUSH
87410: LD_VAR 0 7
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: ST_TO_ADDR
// end ;
87419: LD_VAR 0 5
87423: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87424: LD_INT 0
87426: PPUSH
87427: PPUSH
87428: PPUSH
87429: PPUSH
// task := GetTaskList ( unit ) ;
87430: LD_ADDR_VAR 0 7
87434: PUSH
87435: LD_VAR 0 1
87439: PPUSH
87440: CALL_OW 437
87444: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87445: LD_VAR 0 7
87449: NOT
87450: PUSH
87451: LD_VAR 0 1
87455: PPUSH
87456: LD_VAR 0 2
87460: PPUSH
87461: CALL_OW 308
87465: NOT
87466: AND
87467: IFFALSE 87471
// exit ;
87469: GO 87589
// if IsInArea ( unit , area ) then
87471: LD_VAR 0 1
87475: PPUSH
87476: LD_VAR 0 2
87480: PPUSH
87481: CALL_OW 308
87485: IFFALSE 87503
// begin ComMoveToArea ( unit , goAway ) ;
87487: LD_VAR 0 1
87491: PPUSH
87492: LD_VAR 0 3
87496: PPUSH
87497: CALL_OW 113
// exit ;
87501: GO 87589
// end ; if task [ 1 ] [ 1 ] <> M then
87503: LD_VAR 0 7
87507: PUSH
87508: LD_INT 1
87510: ARRAY
87511: PUSH
87512: LD_INT 1
87514: ARRAY
87515: PUSH
87516: LD_STRING M
87518: NONEQUAL
87519: IFFALSE 87523
// exit ;
87521: GO 87589
// x := task [ 1 ] [ 2 ] ;
87523: LD_ADDR_VAR 0 5
87527: PUSH
87528: LD_VAR 0 7
87532: PUSH
87533: LD_INT 1
87535: ARRAY
87536: PUSH
87537: LD_INT 2
87539: ARRAY
87540: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87541: LD_ADDR_VAR 0 6
87545: PUSH
87546: LD_VAR 0 7
87550: PUSH
87551: LD_INT 1
87553: ARRAY
87554: PUSH
87555: LD_INT 3
87557: ARRAY
87558: ST_TO_ADDR
// if InArea ( x , y , area ) then
87559: LD_VAR 0 5
87563: PPUSH
87564: LD_VAR 0 6
87568: PPUSH
87569: LD_VAR 0 2
87573: PPUSH
87574: CALL_OW 309
87578: IFFALSE 87589
// ComStop ( unit ) ;
87580: LD_VAR 0 1
87584: PPUSH
87585: CALL_OW 141
// end ;
87589: LD_VAR 0 4
87593: RET
// export function Abs ( value ) ; begin
87594: LD_INT 0
87596: PPUSH
// result := value ;
87597: LD_ADDR_VAR 0 2
87601: PUSH
87602: LD_VAR 0 1
87606: ST_TO_ADDR
// if value < 0 then
87607: LD_VAR 0 1
87611: PUSH
87612: LD_INT 0
87614: LESS
87615: IFFALSE 87632
// result := value * - 1 ;
87617: LD_ADDR_VAR 0 2
87621: PUSH
87622: LD_VAR 0 1
87626: PUSH
87627: LD_INT 1
87629: NEG
87630: MUL
87631: ST_TO_ADDR
// end ;
87632: LD_VAR 0 2
87636: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87637: LD_INT 0
87639: PPUSH
87640: PPUSH
87641: PPUSH
87642: PPUSH
87643: PPUSH
87644: PPUSH
87645: PPUSH
87646: PPUSH
// if not unit or not building then
87647: LD_VAR 0 1
87651: NOT
87652: PUSH
87653: LD_VAR 0 2
87657: NOT
87658: OR
87659: IFFALSE 87663
// exit ;
87661: GO 87889
// x := GetX ( building ) ;
87663: LD_ADDR_VAR 0 4
87667: PUSH
87668: LD_VAR 0 2
87672: PPUSH
87673: CALL_OW 250
87677: ST_TO_ADDR
// y := GetY ( building ) ;
87678: LD_ADDR_VAR 0 6
87682: PUSH
87683: LD_VAR 0 2
87687: PPUSH
87688: CALL_OW 251
87692: ST_TO_ADDR
// d := GetDir ( building ) ;
87693: LD_ADDR_VAR 0 8
87697: PUSH
87698: LD_VAR 0 2
87702: PPUSH
87703: CALL_OW 254
87707: ST_TO_ADDR
// r := 4 ;
87708: LD_ADDR_VAR 0 9
87712: PUSH
87713: LD_INT 4
87715: ST_TO_ADDR
// for i := 1 to 5 do
87716: LD_ADDR_VAR 0 10
87720: PUSH
87721: DOUBLE
87722: LD_INT 1
87724: DEC
87725: ST_TO_ADDR
87726: LD_INT 5
87728: PUSH
87729: FOR_TO
87730: IFFALSE 87887
// begin _x := ShiftX ( x , d , r + i ) ;
87732: LD_ADDR_VAR 0 5
87736: PUSH
87737: LD_VAR 0 4
87741: PPUSH
87742: LD_VAR 0 8
87746: PPUSH
87747: LD_VAR 0 9
87751: PUSH
87752: LD_VAR 0 10
87756: PLUS
87757: PPUSH
87758: CALL_OW 272
87762: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87763: LD_ADDR_VAR 0 7
87767: PUSH
87768: LD_VAR 0 6
87772: PPUSH
87773: LD_VAR 0 8
87777: PPUSH
87778: LD_VAR 0 9
87782: PUSH
87783: LD_VAR 0 10
87787: PLUS
87788: PPUSH
87789: CALL_OW 273
87793: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87794: LD_VAR 0 5
87798: PPUSH
87799: LD_VAR 0 7
87803: PPUSH
87804: CALL_OW 488
87808: PUSH
87809: LD_VAR 0 5
87813: PPUSH
87814: LD_VAR 0 7
87818: PPUSH
87819: CALL_OW 428
87823: PPUSH
87824: CALL_OW 247
87828: PUSH
87829: LD_INT 3
87831: PUSH
87832: LD_INT 2
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: IN
87839: NOT
87840: AND
87841: IFFALSE 87885
// begin ComMoveXY ( unit , _x , _y ) ;
87843: LD_VAR 0 1
87847: PPUSH
87848: LD_VAR 0 5
87852: PPUSH
87853: LD_VAR 0 7
87857: PPUSH
87858: CALL_OW 111
// result := [ _x , _y ] ;
87862: LD_ADDR_VAR 0 3
87866: PUSH
87867: LD_VAR 0 5
87871: PUSH
87872: LD_VAR 0 7
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: ST_TO_ADDR
// exit ;
87881: POP
87882: POP
87883: GO 87889
// end ; end ;
87885: GO 87729
87887: POP
87888: POP
// end ;
87889: LD_VAR 0 3
87893: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87894: LD_INT 0
87896: PPUSH
87897: PPUSH
87898: PPUSH
// result := 0 ;
87899: LD_ADDR_VAR 0 3
87903: PUSH
87904: LD_INT 0
87906: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87907: LD_VAR 0 1
87911: PUSH
87912: LD_INT 0
87914: LESS
87915: PUSH
87916: LD_VAR 0 1
87920: PUSH
87921: LD_INT 8
87923: GREATER
87924: OR
87925: PUSH
87926: LD_VAR 0 2
87930: PUSH
87931: LD_INT 0
87933: LESS
87934: OR
87935: PUSH
87936: LD_VAR 0 2
87940: PUSH
87941: LD_INT 8
87943: GREATER
87944: OR
87945: IFFALSE 87949
// exit ;
87947: GO 88024
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87949: LD_ADDR_VAR 0 4
87953: PUSH
87954: LD_INT 22
87956: PUSH
87957: LD_VAR 0 2
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PPUSH
87966: CALL_OW 69
87970: PUSH
87971: FOR_IN
87972: IFFALSE 88022
// begin un := UnitShoot ( i ) ;
87974: LD_ADDR_VAR 0 5
87978: PUSH
87979: LD_VAR 0 4
87983: PPUSH
87984: CALL_OW 504
87988: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87989: LD_VAR 0 5
87993: PPUSH
87994: CALL_OW 255
87998: PUSH
87999: LD_VAR 0 1
88003: EQUAL
88004: IFFALSE 88020
// begin result := un ;
88006: LD_ADDR_VAR 0 3
88010: PUSH
88011: LD_VAR 0 5
88015: ST_TO_ADDR
// exit ;
88016: POP
88017: POP
88018: GO 88024
// end ; end ;
88020: GO 87971
88022: POP
88023: POP
// end ;
88024: LD_VAR 0 3
88028: RET
// export function GetCargoBay ( units ) ; begin
88029: LD_INT 0
88031: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88032: LD_ADDR_VAR 0 2
88036: PUSH
88037: LD_VAR 0 1
88041: PPUSH
88042: LD_INT 2
88044: PUSH
88045: LD_INT 34
88047: PUSH
88048: LD_INT 12
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 34
88057: PUSH
88058: LD_INT 51
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 34
88067: PUSH
88068: LD_INT 32
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 34
88077: PUSH
88078: LD_INT 89
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: PPUSH
88092: CALL_OW 72
88096: ST_TO_ADDR
// end ;
88097: LD_VAR 0 2
88101: RET
// export function Negate ( value ) ; begin
88102: LD_INT 0
88104: PPUSH
// result := not value ;
88105: LD_ADDR_VAR 0 2
88109: PUSH
88110: LD_VAR 0 1
88114: NOT
88115: ST_TO_ADDR
// end ;
88116: LD_VAR 0 2
88120: RET
// export function Inc ( value ) ; begin
88121: LD_INT 0
88123: PPUSH
// result := value + 1 ;
88124: LD_ADDR_VAR 0 2
88128: PUSH
88129: LD_VAR 0 1
88133: PUSH
88134: LD_INT 1
88136: PLUS
88137: ST_TO_ADDR
// end ;
88138: LD_VAR 0 2
88142: RET
// export function Dec ( value ) ; begin
88143: LD_INT 0
88145: PPUSH
// result := value - 1 ;
88146: LD_ADDR_VAR 0 2
88150: PUSH
88151: LD_VAR 0 1
88155: PUSH
88156: LD_INT 1
88158: MINUS
88159: ST_TO_ADDR
// end ;
88160: LD_VAR 0 2
88164: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88165: LD_INT 0
88167: PPUSH
88168: PPUSH
88169: PPUSH
88170: PPUSH
88171: PPUSH
88172: PPUSH
88173: PPUSH
88174: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88175: LD_VAR 0 1
88179: PPUSH
88180: LD_VAR 0 2
88184: PPUSH
88185: CALL_OW 488
88189: NOT
88190: PUSH
88191: LD_VAR 0 3
88195: PPUSH
88196: LD_VAR 0 4
88200: PPUSH
88201: CALL_OW 488
88205: NOT
88206: OR
88207: IFFALSE 88220
// begin result := - 1 ;
88209: LD_ADDR_VAR 0 5
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: ST_TO_ADDR
// exit ;
88218: GO 88455
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88220: LD_ADDR_VAR 0 12
88224: PUSH
88225: LD_VAR 0 1
88229: PPUSH
88230: LD_VAR 0 2
88234: PPUSH
88235: LD_VAR 0 3
88239: PPUSH
88240: LD_VAR 0 4
88244: PPUSH
88245: CALL 87305 0 4
88249: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88250: LD_ADDR_VAR 0 11
88254: PUSH
88255: LD_VAR 0 1
88259: PPUSH
88260: LD_VAR 0 2
88264: PPUSH
88265: LD_VAR 0 12
88269: PUSH
88270: LD_INT 1
88272: ARRAY
88273: PPUSH
88274: LD_VAR 0 12
88278: PUSH
88279: LD_INT 2
88281: ARRAY
88282: PPUSH
88283: CALL_OW 298
88287: ST_TO_ADDR
// distance := 9999 ;
88288: LD_ADDR_VAR 0 10
88292: PUSH
88293: LD_INT 9999
88295: ST_TO_ADDR
// for i := 0 to 5 do
88296: LD_ADDR_VAR 0 6
88300: PUSH
88301: DOUBLE
88302: LD_INT 0
88304: DEC
88305: ST_TO_ADDR
88306: LD_INT 5
88308: PUSH
88309: FOR_TO
88310: IFFALSE 88453
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88312: LD_ADDR_VAR 0 7
88316: PUSH
88317: LD_VAR 0 1
88321: PPUSH
88322: LD_VAR 0 6
88326: PPUSH
88327: LD_VAR 0 11
88331: PPUSH
88332: CALL_OW 272
88336: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88337: LD_ADDR_VAR 0 8
88341: PUSH
88342: LD_VAR 0 2
88346: PPUSH
88347: LD_VAR 0 6
88351: PPUSH
88352: LD_VAR 0 11
88356: PPUSH
88357: CALL_OW 273
88361: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88362: LD_VAR 0 7
88366: PPUSH
88367: LD_VAR 0 8
88371: PPUSH
88372: CALL_OW 488
88376: NOT
88377: IFFALSE 88381
// continue ;
88379: GO 88309
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88381: LD_ADDR_VAR 0 9
88385: PUSH
88386: LD_VAR 0 12
88390: PUSH
88391: LD_INT 1
88393: ARRAY
88394: PPUSH
88395: LD_VAR 0 12
88399: PUSH
88400: LD_INT 2
88402: ARRAY
88403: PPUSH
88404: LD_VAR 0 7
88408: PPUSH
88409: LD_VAR 0 8
88413: PPUSH
88414: CALL_OW 298
88418: ST_TO_ADDR
// if tmp < distance then
88419: LD_VAR 0 9
88423: PUSH
88424: LD_VAR 0 10
88428: LESS
88429: IFFALSE 88451
// begin result := i ;
88431: LD_ADDR_VAR 0 5
88435: PUSH
88436: LD_VAR 0 6
88440: ST_TO_ADDR
// distance := tmp ;
88441: LD_ADDR_VAR 0 10
88445: PUSH
88446: LD_VAR 0 9
88450: ST_TO_ADDR
// end ; end ;
88451: GO 88309
88453: POP
88454: POP
// end ;
88455: LD_VAR 0 5
88459: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88460: LD_INT 0
88462: PPUSH
88463: PPUSH
// if not driver or not IsInUnit ( driver ) then
88464: LD_VAR 0 1
88468: NOT
88469: PUSH
88470: LD_VAR 0 1
88474: PPUSH
88475: CALL_OW 310
88479: NOT
88480: OR
88481: IFFALSE 88485
// exit ;
88483: GO 88575
// vehicle := IsInUnit ( driver ) ;
88485: LD_ADDR_VAR 0 3
88489: PUSH
88490: LD_VAR 0 1
88494: PPUSH
88495: CALL_OW 310
88499: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88500: LD_VAR 0 1
88504: PPUSH
88505: LD_STRING \
88507: PUSH
88508: LD_INT 0
88510: PUSH
88511: LD_INT 0
88513: PUSH
88514: LD_INT 0
88516: PUSH
88517: LD_INT 0
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 0
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: PUSH
88535: LD_STRING E
88537: PUSH
88538: LD_INT 0
88540: PUSH
88541: LD_INT 0
88543: PUSH
88544: LD_VAR 0 3
88548: PUSH
88549: LD_INT 0
88551: PUSH
88552: LD_INT 0
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PPUSH
88571: CALL_OW 446
// end ;
88575: LD_VAR 0 2
88579: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88580: LD_INT 0
88582: PPUSH
88583: PPUSH
// if not driver or not IsInUnit ( driver ) then
88584: LD_VAR 0 1
88588: NOT
88589: PUSH
88590: LD_VAR 0 1
88594: PPUSH
88595: CALL_OW 310
88599: NOT
88600: OR
88601: IFFALSE 88605
// exit ;
88603: GO 88695
// vehicle := IsInUnit ( driver ) ;
88605: LD_ADDR_VAR 0 3
88609: PUSH
88610: LD_VAR 0 1
88614: PPUSH
88615: CALL_OW 310
88619: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88620: LD_VAR 0 1
88624: PPUSH
88625: LD_STRING \
88627: PUSH
88628: LD_INT 0
88630: PUSH
88631: LD_INT 0
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: LD_INT 0
88639: PUSH
88640: LD_INT 0
88642: PUSH
88643: LD_INT 0
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: PUSH
88655: LD_STRING E
88657: PUSH
88658: LD_INT 0
88660: PUSH
88661: LD_INT 0
88663: PUSH
88664: LD_VAR 0 3
88668: PUSH
88669: LD_INT 0
88671: PUSH
88672: LD_INT 0
88674: PUSH
88675: LD_INT 0
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PPUSH
88691: CALL_OW 447
// end ;
88695: LD_VAR 0 2
88699: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88700: LD_INT 0
88702: PPUSH
88703: PPUSH
88704: PPUSH
// tmp := [ ] ;
88705: LD_ADDR_VAR 0 5
88709: PUSH
88710: EMPTY
88711: ST_TO_ADDR
// for i in units do
88712: LD_ADDR_VAR 0 4
88716: PUSH
88717: LD_VAR 0 1
88721: PUSH
88722: FOR_IN
88723: IFFALSE 88761
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88725: LD_ADDR_VAR 0 5
88729: PUSH
88730: LD_VAR 0 5
88734: PPUSH
88735: LD_VAR 0 5
88739: PUSH
88740: LD_INT 1
88742: PLUS
88743: PPUSH
88744: LD_VAR 0 4
88748: PPUSH
88749: CALL_OW 256
88753: PPUSH
88754: CALL_OW 2
88758: ST_TO_ADDR
88759: GO 88722
88761: POP
88762: POP
// if not tmp then
88763: LD_VAR 0 5
88767: NOT
88768: IFFALSE 88772
// exit ;
88770: GO 88820
// if asc then
88772: LD_VAR 0 2
88776: IFFALSE 88800
// result := SortListByListAsc ( units , tmp ) else
88778: LD_ADDR_VAR 0 3
88782: PUSH
88783: LD_VAR 0 1
88787: PPUSH
88788: LD_VAR 0 5
88792: PPUSH
88793: CALL_OW 76
88797: ST_TO_ADDR
88798: GO 88820
// result := SortListByListDesc ( units , tmp ) ;
88800: LD_ADDR_VAR 0 3
88804: PUSH
88805: LD_VAR 0 1
88809: PPUSH
88810: LD_VAR 0 5
88814: PPUSH
88815: CALL_OW 77
88819: ST_TO_ADDR
// end ;
88820: LD_VAR 0 3
88824: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88825: LD_INT 0
88827: PPUSH
88828: PPUSH
// task := GetTaskList ( mech ) ;
88829: LD_ADDR_VAR 0 4
88833: PUSH
88834: LD_VAR 0 1
88838: PPUSH
88839: CALL_OW 437
88843: ST_TO_ADDR
// if not task then
88844: LD_VAR 0 4
88848: NOT
88849: IFFALSE 88853
// exit ;
88851: GO 88895
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88853: LD_ADDR_VAR 0 3
88857: PUSH
88858: LD_VAR 0 4
88862: PUSH
88863: LD_INT 1
88865: ARRAY
88866: PUSH
88867: LD_INT 1
88869: ARRAY
88870: PUSH
88871: LD_STRING r
88873: EQUAL
88874: PUSH
88875: LD_VAR 0 4
88879: PUSH
88880: LD_INT 1
88882: ARRAY
88883: PUSH
88884: LD_INT 4
88886: ARRAY
88887: PUSH
88888: LD_VAR 0 2
88892: EQUAL
88893: AND
88894: ST_TO_ADDR
// end ;
88895: LD_VAR 0 3
88899: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88900: LD_INT 0
88902: PPUSH
// SetDir ( unit , d ) ;
88903: LD_VAR 0 1
88907: PPUSH
88908: LD_VAR 0 4
88912: PPUSH
88913: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
88917: LD_ADDR_VAR 0 6
88921: PUSH
88922: LD_VAR 0 1
88926: PPUSH
88927: LD_VAR 0 2
88931: PPUSH
88932: LD_VAR 0 3
88936: PPUSH
88937: LD_VAR 0 5
88941: PPUSH
88942: CALL_OW 48
88946: ST_TO_ADDR
// end ;
88947: LD_VAR 0 6
88951: RET
// export function ToNaturalNumber ( number ) ; begin
88952: LD_INT 0
88954: PPUSH
// result := number div 1 ;
88955: LD_ADDR_VAR 0 2
88959: PUSH
88960: LD_VAR 0 1
88964: PUSH
88965: LD_INT 1
88967: DIV
88968: ST_TO_ADDR
// if number < 0 then
88969: LD_VAR 0 1
88973: PUSH
88974: LD_INT 0
88976: LESS
88977: IFFALSE 88987
// result := 0 ;
88979: LD_ADDR_VAR 0 2
88983: PUSH
88984: LD_INT 0
88986: ST_TO_ADDR
// end ;
88987: LD_VAR 0 2
88991: RET
// export function SortByClass ( units , class ) ; var un ; begin
88992: LD_INT 0
88994: PPUSH
88995: PPUSH
// if not units or not class then
88996: LD_VAR 0 1
89000: NOT
89001: PUSH
89002: LD_VAR 0 2
89006: NOT
89007: OR
89008: IFFALSE 89012
// exit ;
89010: GO 89107
// result := [ ] ;
89012: LD_ADDR_VAR 0 3
89016: PUSH
89017: EMPTY
89018: ST_TO_ADDR
// for un in units do
89019: LD_ADDR_VAR 0 4
89023: PUSH
89024: LD_VAR 0 1
89028: PUSH
89029: FOR_IN
89030: IFFALSE 89105
// if GetClass ( un ) = class then
89032: LD_VAR 0 4
89036: PPUSH
89037: CALL_OW 257
89041: PUSH
89042: LD_VAR 0 2
89046: EQUAL
89047: IFFALSE 89074
// result := Insert ( result , 1 , un ) else
89049: LD_ADDR_VAR 0 3
89053: PUSH
89054: LD_VAR 0 3
89058: PPUSH
89059: LD_INT 1
89061: PPUSH
89062: LD_VAR 0 4
89066: PPUSH
89067: CALL_OW 2
89071: ST_TO_ADDR
89072: GO 89103
// result := Replace ( result , result + 1 , un ) ;
89074: LD_ADDR_VAR 0 3
89078: PUSH
89079: LD_VAR 0 3
89083: PPUSH
89084: LD_VAR 0 3
89088: PUSH
89089: LD_INT 1
89091: PLUS
89092: PPUSH
89093: LD_VAR 0 4
89097: PPUSH
89098: CALL_OW 1
89102: ST_TO_ADDR
89103: GO 89029
89105: POP
89106: POP
// end ;
89107: LD_VAR 0 3
89111: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89112: LD_INT 0
89114: PPUSH
89115: PPUSH
89116: PPUSH
89117: PPUSH
89118: PPUSH
89119: PPUSH
89120: PPUSH
// result := [ ] ;
89121: LD_ADDR_VAR 0 4
89125: PUSH
89126: EMPTY
89127: ST_TO_ADDR
// if x - r < 0 then
89128: LD_VAR 0 1
89132: PUSH
89133: LD_VAR 0 3
89137: MINUS
89138: PUSH
89139: LD_INT 0
89141: LESS
89142: IFFALSE 89154
// min_x := 0 else
89144: LD_ADDR_VAR 0 8
89148: PUSH
89149: LD_INT 0
89151: ST_TO_ADDR
89152: GO 89170
// min_x := x - r ;
89154: LD_ADDR_VAR 0 8
89158: PUSH
89159: LD_VAR 0 1
89163: PUSH
89164: LD_VAR 0 3
89168: MINUS
89169: ST_TO_ADDR
// if y - r < 0 then
89170: LD_VAR 0 2
89174: PUSH
89175: LD_VAR 0 3
89179: MINUS
89180: PUSH
89181: LD_INT 0
89183: LESS
89184: IFFALSE 89196
// min_y := 0 else
89186: LD_ADDR_VAR 0 7
89190: PUSH
89191: LD_INT 0
89193: ST_TO_ADDR
89194: GO 89212
// min_y := y - r ;
89196: LD_ADDR_VAR 0 7
89200: PUSH
89201: LD_VAR 0 2
89205: PUSH
89206: LD_VAR 0 3
89210: MINUS
89211: ST_TO_ADDR
// max_x := x + r ;
89212: LD_ADDR_VAR 0 9
89216: PUSH
89217: LD_VAR 0 1
89221: PUSH
89222: LD_VAR 0 3
89226: PLUS
89227: ST_TO_ADDR
// max_y := y + r ;
89228: LD_ADDR_VAR 0 10
89232: PUSH
89233: LD_VAR 0 2
89237: PUSH
89238: LD_VAR 0 3
89242: PLUS
89243: ST_TO_ADDR
// for _x = min_x to max_x do
89244: LD_ADDR_VAR 0 5
89248: PUSH
89249: DOUBLE
89250: LD_VAR 0 8
89254: DEC
89255: ST_TO_ADDR
89256: LD_VAR 0 9
89260: PUSH
89261: FOR_TO
89262: IFFALSE 89363
// for _y = min_y to max_y do
89264: LD_ADDR_VAR 0 6
89268: PUSH
89269: DOUBLE
89270: LD_VAR 0 7
89274: DEC
89275: ST_TO_ADDR
89276: LD_VAR 0 10
89280: PUSH
89281: FOR_TO
89282: IFFALSE 89359
// begin if not ValidHex ( _x , _y ) then
89284: LD_VAR 0 5
89288: PPUSH
89289: LD_VAR 0 6
89293: PPUSH
89294: CALL_OW 488
89298: NOT
89299: IFFALSE 89303
// continue ;
89301: GO 89281
// if GetResourceTypeXY ( _x , _y ) then
89303: LD_VAR 0 5
89307: PPUSH
89308: LD_VAR 0 6
89312: PPUSH
89313: CALL_OW 283
89317: IFFALSE 89357
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89319: LD_ADDR_VAR 0 4
89323: PUSH
89324: LD_VAR 0 4
89328: PPUSH
89329: LD_VAR 0 4
89333: PUSH
89334: LD_INT 1
89336: PLUS
89337: PPUSH
89338: LD_VAR 0 5
89342: PUSH
89343: LD_VAR 0 6
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PPUSH
89352: CALL_OW 1
89356: ST_TO_ADDR
// end ;
89357: GO 89281
89359: POP
89360: POP
89361: GO 89261
89363: POP
89364: POP
// end ;
89365: LD_VAR 0 4
89369: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89370: LD_INT 0
89372: PPUSH
89373: PPUSH
89374: PPUSH
89375: PPUSH
89376: PPUSH
89377: PPUSH
89378: PPUSH
89379: PPUSH
// if not units then
89380: LD_VAR 0 1
89384: NOT
89385: IFFALSE 89389
// exit ;
89387: GO 89917
// result := UnitFilter ( units , [ f_ok ] ) ;
89389: LD_ADDR_VAR 0 3
89393: PUSH
89394: LD_VAR 0 1
89398: PPUSH
89399: LD_INT 50
89401: PUSH
89402: EMPTY
89403: LIST
89404: PPUSH
89405: CALL_OW 72
89409: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89410: LD_ADDR_VAR 0 8
89414: PUSH
89415: LD_VAR 0 1
89419: PUSH
89420: LD_INT 1
89422: ARRAY
89423: PPUSH
89424: CALL_OW 255
89428: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89429: LD_ADDR_VAR 0 10
89433: PUSH
89434: LD_INT 29
89436: PUSH
89437: LD_INT 91
89439: PUSH
89440: LD_INT 49
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: LIST
89447: ST_TO_ADDR
// if not result then
89448: LD_VAR 0 3
89452: NOT
89453: IFFALSE 89457
// exit ;
89455: GO 89917
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89457: LD_ADDR_VAR 0 5
89461: PUSH
89462: LD_INT 81
89464: PUSH
89465: LD_VAR 0 8
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PPUSH
89474: CALL_OW 69
89478: ST_TO_ADDR
// for i in result do
89479: LD_ADDR_VAR 0 4
89483: PUSH
89484: LD_VAR 0 3
89488: PUSH
89489: FOR_IN
89490: IFFALSE 89915
// begin tag := GetTag ( i ) + 1 ;
89492: LD_ADDR_VAR 0 9
89496: PUSH
89497: LD_VAR 0 4
89501: PPUSH
89502: CALL_OW 110
89506: PUSH
89507: LD_INT 1
89509: PLUS
89510: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
89511: LD_ADDR_VAR 0 7
89515: PUSH
89516: LD_VAR 0 4
89520: PPUSH
89521: CALL_OW 250
89525: PPUSH
89526: LD_VAR 0 4
89530: PPUSH
89531: CALL_OW 251
89535: PPUSH
89536: LD_INT 4
89538: PPUSH
89539: CALL 89112 0 3
89543: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
89544: LD_VAR 0 4
89548: PPUSH
89549: CALL_OW 247
89553: PUSH
89554: LD_INT 2
89556: EQUAL
89557: PUSH
89558: LD_VAR 0 7
89562: PUSH
89563: LD_INT 2
89565: GREATER
89566: AND
89567: PUSH
89568: LD_VAR 0 4
89572: PPUSH
89573: CALL_OW 264
89577: PUSH
89578: LD_VAR 0 10
89582: IN
89583: NOT
89584: AND
89585: IFFALSE 89624
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89587: LD_VAR 0 4
89591: PPUSH
89592: LD_VAR 0 7
89596: PUSH
89597: LD_INT 1
89599: ARRAY
89600: PUSH
89601: LD_INT 1
89603: ARRAY
89604: PPUSH
89605: LD_VAR 0 7
89609: PUSH
89610: LD_INT 1
89612: ARRAY
89613: PUSH
89614: LD_INT 2
89616: ARRAY
89617: PPUSH
89618: CALL_OW 116
89622: GO 89913
// if path > tag then
89624: LD_VAR 0 2
89628: PUSH
89629: LD_VAR 0 9
89633: GREATER
89634: IFFALSE 89842
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89636: LD_ADDR_VAR 0 6
89640: PUSH
89641: LD_VAR 0 5
89645: PPUSH
89646: LD_INT 91
89648: PUSH
89649: LD_VAR 0 4
89653: PUSH
89654: LD_INT 8
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: LIST
89661: PPUSH
89662: CALL_OW 72
89666: ST_TO_ADDR
// if nearEnemy then
89667: LD_VAR 0 6
89671: IFFALSE 89740
// begin if GetWeapon ( i ) = ru_time_lapser then
89673: LD_VAR 0 4
89677: PPUSH
89678: CALL_OW 264
89682: PUSH
89683: LD_INT 49
89685: EQUAL
89686: IFFALSE 89714
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89688: LD_VAR 0 4
89692: PPUSH
89693: LD_VAR 0 6
89697: PPUSH
89698: LD_VAR 0 4
89702: PPUSH
89703: CALL_OW 74
89707: PPUSH
89708: CALL_OW 112
89712: GO 89738
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89714: LD_VAR 0 4
89718: PPUSH
89719: LD_VAR 0 6
89723: PPUSH
89724: LD_VAR 0 4
89728: PPUSH
89729: CALL_OW 74
89733: PPUSH
89734: CALL 90988 0 2
// end else
89738: GO 89840
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89740: LD_VAR 0 4
89744: PPUSH
89745: LD_VAR 0 2
89749: PUSH
89750: LD_VAR 0 9
89754: ARRAY
89755: PUSH
89756: LD_INT 1
89758: ARRAY
89759: PPUSH
89760: LD_VAR 0 2
89764: PUSH
89765: LD_VAR 0 9
89769: ARRAY
89770: PUSH
89771: LD_INT 2
89773: ARRAY
89774: PPUSH
89775: CALL_OW 297
89779: PUSH
89780: LD_INT 6
89782: GREATER
89783: IFFALSE 89826
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89785: LD_VAR 0 4
89789: PPUSH
89790: LD_VAR 0 2
89794: PUSH
89795: LD_VAR 0 9
89799: ARRAY
89800: PUSH
89801: LD_INT 1
89803: ARRAY
89804: PPUSH
89805: LD_VAR 0 2
89809: PUSH
89810: LD_VAR 0 9
89814: ARRAY
89815: PUSH
89816: LD_INT 2
89818: ARRAY
89819: PPUSH
89820: CALL_OW 114
89824: GO 89840
// SetTag ( i , tag ) ;
89826: LD_VAR 0 4
89830: PPUSH
89831: LD_VAR 0 9
89835: PPUSH
89836: CALL_OW 109
// end else
89840: GO 89913
// if enemy then
89842: LD_VAR 0 5
89846: IFFALSE 89913
// begin if GetWeapon ( i ) = ru_time_lapser then
89848: LD_VAR 0 4
89852: PPUSH
89853: CALL_OW 264
89857: PUSH
89858: LD_INT 49
89860: EQUAL
89861: IFFALSE 89889
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89863: LD_VAR 0 4
89867: PPUSH
89868: LD_VAR 0 5
89872: PPUSH
89873: LD_VAR 0 4
89877: PPUSH
89878: CALL_OW 74
89882: PPUSH
89883: CALL_OW 112
89887: GO 89913
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89889: LD_VAR 0 4
89893: PPUSH
89894: LD_VAR 0 5
89898: PPUSH
89899: LD_VAR 0 4
89903: PPUSH
89904: CALL_OW 74
89908: PPUSH
89909: CALL 90988 0 2
// end ; end ;
89913: GO 89489
89915: POP
89916: POP
// end ;
89917: LD_VAR 0 3
89921: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89922: LD_INT 0
89924: PPUSH
89925: PPUSH
89926: PPUSH
// if not unit or IsInUnit ( unit ) then
89927: LD_VAR 0 1
89931: NOT
89932: PUSH
89933: LD_VAR 0 1
89937: PPUSH
89938: CALL_OW 310
89942: OR
89943: IFFALSE 89947
// exit ;
89945: GO 90038
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89947: LD_ADDR_VAR 0 4
89951: PUSH
89952: LD_VAR 0 1
89956: PPUSH
89957: CALL_OW 250
89961: PPUSH
89962: LD_VAR 0 2
89966: PPUSH
89967: LD_INT 1
89969: PPUSH
89970: CALL_OW 272
89974: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89975: LD_ADDR_VAR 0 5
89979: PUSH
89980: LD_VAR 0 1
89984: PPUSH
89985: CALL_OW 251
89989: PPUSH
89990: LD_VAR 0 2
89994: PPUSH
89995: LD_INT 1
89997: PPUSH
89998: CALL_OW 273
90002: ST_TO_ADDR
// if ValidHex ( x , y ) then
90003: LD_VAR 0 4
90007: PPUSH
90008: LD_VAR 0 5
90012: PPUSH
90013: CALL_OW 488
90017: IFFALSE 90038
// ComTurnXY ( unit , x , y ) ;
90019: LD_VAR 0 1
90023: PPUSH
90024: LD_VAR 0 4
90028: PPUSH
90029: LD_VAR 0 5
90033: PPUSH
90034: CALL_OW 118
// end ;
90038: LD_VAR 0 3
90042: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90043: LD_INT 0
90045: PPUSH
90046: PPUSH
// result := false ;
90047: LD_ADDR_VAR 0 3
90051: PUSH
90052: LD_INT 0
90054: ST_TO_ADDR
// if not units then
90055: LD_VAR 0 2
90059: NOT
90060: IFFALSE 90064
// exit ;
90062: GO 90109
// for i in units do
90064: LD_ADDR_VAR 0 4
90068: PUSH
90069: LD_VAR 0 2
90073: PUSH
90074: FOR_IN
90075: IFFALSE 90107
// if See ( side , i ) then
90077: LD_VAR 0 1
90081: PPUSH
90082: LD_VAR 0 4
90086: PPUSH
90087: CALL_OW 292
90091: IFFALSE 90105
// begin result := true ;
90093: LD_ADDR_VAR 0 3
90097: PUSH
90098: LD_INT 1
90100: ST_TO_ADDR
// exit ;
90101: POP
90102: POP
90103: GO 90109
// end ;
90105: GO 90074
90107: POP
90108: POP
// end ;
90109: LD_VAR 0 3
90113: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90114: LD_INT 0
90116: PPUSH
90117: PPUSH
90118: PPUSH
90119: PPUSH
// if not unit or not points then
90120: LD_VAR 0 1
90124: NOT
90125: PUSH
90126: LD_VAR 0 2
90130: NOT
90131: OR
90132: IFFALSE 90136
// exit ;
90134: GO 90226
// dist := 99999 ;
90136: LD_ADDR_VAR 0 5
90140: PUSH
90141: LD_INT 99999
90143: ST_TO_ADDR
// for i in points do
90144: LD_ADDR_VAR 0 4
90148: PUSH
90149: LD_VAR 0 2
90153: PUSH
90154: FOR_IN
90155: IFFALSE 90224
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90157: LD_ADDR_VAR 0 6
90161: PUSH
90162: LD_VAR 0 1
90166: PPUSH
90167: LD_VAR 0 4
90171: PUSH
90172: LD_INT 1
90174: ARRAY
90175: PPUSH
90176: LD_VAR 0 4
90180: PUSH
90181: LD_INT 2
90183: ARRAY
90184: PPUSH
90185: CALL_OW 297
90189: ST_TO_ADDR
// if tmpDist < dist then
90190: LD_VAR 0 6
90194: PUSH
90195: LD_VAR 0 5
90199: LESS
90200: IFFALSE 90222
// begin result := i ;
90202: LD_ADDR_VAR 0 3
90206: PUSH
90207: LD_VAR 0 4
90211: ST_TO_ADDR
// dist := tmpDist ;
90212: LD_ADDR_VAR 0 5
90216: PUSH
90217: LD_VAR 0 6
90221: ST_TO_ADDR
// end ; end ;
90222: GO 90154
90224: POP
90225: POP
// end ;
90226: LD_VAR 0 3
90230: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90231: LD_INT 0
90233: PPUSH
// uc_side := side ;
90234: LD_ADDR_OWVAR 20
90238: PUSH
90239: LD_VAR 0 1
90243: ST_TO_ADDR
// uc_nation := 3 ;
90244: LD_ADDR_OWVAR 21
90248: PUSH
90249: LD_INT 3
90251: ST_TO_ADDR
// vc_chassis := 25 ;
90252: LD_ADDR_OWVAR 37
90256: PUSH
90257: LD_INT 25
90259: ST_TO_ADDR
// vc_engine := engine_siberite ;
90260: LD_ADDR_OWVAR 39
90264: PUSH
90265: LD_INT 3
90267: ST_TO_ADDR
// vc_control := control_computer ;
90268: LD_ADDR_OWVAR 38
90272: PUSH
90273: LD_INT 3
90275: ST_TO_ADDR
// vc_weapon := 59 ;
90276: LD_ADDR_OWVAR 40
90280: PUSH
90281: LD_INT 59
90283: ST_TO_ADDR
// result := CreateVehicle ;
90284: LD_ADDR_VAR 0 5
90288: PUSH
90289: CALL_OW 45
90293: ST_TO_ADDR
// SetDir ( result , d ) ;
90294: LD_VAR 0 5
90298: PPUSH
90299: LD_VAR 0 4
90303: PPUSH
90304: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90308: LD_VAR 0 5
90312: PPUSH
90313: LD_VAR 0 2
90317: PPUSH
90318: LD_VAR 0 3
90322: PPUSH
90323: LD_INT 0
90325: PPUSH
90326: CALL_OW 48
// end ;
90330: LD_VAR 0 5
90334: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90335: LD_INT 0
90337: PPUSH
90338: PPUSH
90339: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90340: LD_ADDR_VAR 0 2
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: LD_INT 0
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90363: LD_VAR 0 1
90367: NOT
90368: PUSH
90369: LD_VAR 0 1
90373: PPUSH
90374: CALL_OW 264
90378: PUSH
90379: LD_INT 12
90381: PUSH
90382: LD_INT 51
90384: PUSH
90385: LD_INT 32
90387: PUSH
90388: LD_INT 89
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: IN
90397: NOT
90398: OR
90399: IFFALSE 90403
// exit ;
90401: GO 90501
// for i := 1 to 3 do
90403: LD_ADDR_VAR 0 3
90407: PUSH
90408: DOUBLE
90409: LD_INT 1
90411: DEC
90412: ST_TO_ADDR
90413: LD_INT 3
90415: PUSH
90416: FOR_TO
90417: IFFALSE 90499
// begin tmp := GetCargo ( cargo , i ) ;
90419: LD_ADDR_VAR 0 4
90423: PUSH
90424: LD_VAR 0 1
90428: PPUSH
90429: LD_VAR 0 3
90433: PPUSH
90434: CALL_OW 289
90438: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90439: LD_ADDR_VAR 0 2
90443: PUSH
90444: LD_VAR 0 2
90448: PPUSH
90449: LD_VAR 0 3
90453: PPUSH
90454: LD_VAR 0 4
90458: PPUSH
90459: CALL_OW 1
90463: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90464: LD_ADDR_VAR 0 2
90468: PUSH
90469: LD_VAR 0 2
90473: PPUSH
90474: LD_INT 4
90476: PPUSH
90477: LD_VAR 0 2
90481: PUSH
90482: LD_INT 4
90484: ARRAY
90485: PUSH
90486: LD_VAR 0 4
90490: PLUS
90491: PPUSH
90492: CALL_OW 1
90496: ST_TO_ADDR
// end ;
90497: GO 90416
90499: POP
90500: POP
// end ;
90501: LD_VAR 0 2
90505: RET
// export function Length ( array ) ; begin
90506: LD_INT 0
90508: PPUSH
// result := array + 0 ;
90509: LD_ADDR_VAR 0 2
90513: PUSH
90514: LD_VAR 0 1
90518: PUSH
90519: LD_INT 0
90521: PLUS
90522: ST_TO_ADDR
// end ;
90523: LD_VAR 0 2
90527: RET
// export function PrepareArray ( array ) ; begin
90528: LD_INT 0
90530: PPUSH
// result := array diff 0 ;
90531: LD_ADDR_VAR 0 2
90535: PUSH
90536: LD_VAR 0 1
90540: PUSH
90541: LD_INT 0
90543: DIFF
90544: ST_TO_ADDR
// if not result [ 1 ] then
90545: LD_VAR 0 2
90549: PUSH
90550: LD_INT 1
90552: ARRAY
90553: NOT
90554: IFFALSE 90574
// result := Delete ( result , 1 ) ;
90556: LD_ADDR_VAR 0 2
90560: PUSH
90561: LD_VAR 0 2
90565: PPUSH
90566: LD_INT 1
90568: PPUSH
90569: CALL_OW 3
90573: ST_TO_ADDR
// end ;
90574: LD_VAR 0 2
90578: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90579: LD_INT 0
90581: PPUSH
90582: PPUSH
90583: PPUSH
90584: PPUSH
// sibRocketRange := 25 ;
90585: LD_ADDR_VAR 0 6
90589: PUSH
90590: LD_INT 25
90592: ST_TO_ADDR
// result := false ;
90593: LD_ADDR_VAR 0 4
90597: PUSH
90598: LD_INT 0
90600: ST_TO_ADDR
// for i := 0 to 5 do
90601: LD_ADDR_VAR 0 5
90605: PUSH
90606: DOUBLE
90607: LD_INT 0
90609: DEC
90610: ST_TO_ADDR
90611: LD_INT 5
90613: PUSH
90614: FOR_TO
90615: IFFALSE 90682
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90617: LD_VAR 0 1
90621: PPUSH
90622: LD_VAR 0 5
90626: PPUSH
90627: LD_VAR 0 6
90631: PPUSH
90632: CALL_OW 272
90636: PPUSH
90637: LD_VAR 0 2
90641: PPUSH
90642: LD_VAR 0 5
90646: PPUSH
90647: LD_VAR 0 6
90651: PPUSH
90652: CALL_OW 273
90656: PPUSH
90657: LD_VAR 0 3
90661: PPUSH
90662: CALL_OW 309
90666: IFFALSE 90680
// begin result := true ;
90668: LD_ADDR_VAR 0 4
90672: PUSH
90673: LD_INT 1
90675: ST_TO_ADDR
// exit ;
90676: POP
90677: POP
90678: GO 90684
// end ;
90680: GO 90614
90682: POP
90683: POP
// end ;
90684: LD_VAR 0 4
90688: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
90689: LD_INT 0
90691: PPUSH
90692: PPUSH
90693: PPUSH
// if btype = b_depot then
90694: LD_VAR 0 2
90698: PUSH
90699: LD_INT 0
90701: EQUAL
90702: IFFALSE 90714
// begin result := true ;
90704: LD_ADDR_VAR 0 3
90708: PUSH
90709: LD_INT 1
90711: ST_TO_ADDR
// exit ;
90712: GO 90830
// end ; pom := GetBase ( depot ) ;
90714: LD_ADDR_VAR 0 4
90718: PUSH
90719: LD_VAR 0 1
90723: PPUSH
90724: CALL_OW 274
90728: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
90729: LD_ADDR_VAR 0 5
90733: PUSH
90734: LD_VAR 0 2
90738: PPUSH
90739: LD_VAR 0 1
90743: PPUSH
90744: CALL_OW 248
90748: PPUSH
90749: CALL_OW 450
90753: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
90754: LD_ADDR_VAR 0 3
90758: PUSH
90759: LD_VAR 0 4
90763: PPUSH
90764: LD_INT 1
90766: PPUSH
90767: CALL_OW 275
90771: PUSH
90772: LD_VAR 0 5
90776: PUSH
90777: LD_INT 1
90779: ARRAY
90780: GREATEREQUAL
90781: PUSH
90782: LD_VAR 0 4
90786: PPUSH
90787: LD_INT 2
90789: PPUSH
90790: CALL_OW 275
90794: PUSH
90795: LD_VAR 0 5
90799: PUSH
90800: LD_INT 2
90802: ARRAY
90803: GREATEREQUAL
90804: AND
90805: PUSH
90806: LD_VAR 0 4
90810: PPUSH
90811: LD_INT 3
90813: PPUSH
90814: CALL_OW 275
90818: PUSH
90819: LD_VAR 0 5
90823: PUSH
90824: LD_INT 3
90826: ARRAY
90827: GREATEREQUAL
90828: AND
90829: ST_TO_ADDR
// end ;
90830: LD_VAR 0 3
90834: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90835: LD_INT 0
90837: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90838: LD_VAR 0 1
90842: PPUSH
90843: LD_VAR 0 2
90847: PPUSH
90848: LD_INT 0
90850: PPUSH
90851: LD_INT 0
90853: PPUSH
90854: LD_INT 1
90856: PPUSH
90857: LD_INT 0
90859: PPUSH
90860: CALL_OW 587
// end ;
90864: LD_VAR 0 3
90868: RET
// export function CenterOnNow ( unit ) ; begin
90869: LD_INT 0
90871: PPUSH
// result := IsInUnit ( unit ) ;
90872: LD_ADDR_VAR 0 2
90876: PUSH
90877: LD_VAR 0 1
90881: PPUSH
90882: CALL_OW 310
90886: ST_TO_ADDR
// if not result then
90887: LD_VAR 0 2
90891: NOT
90892: IFFALSE 90904
// result := unit ;
90894: LD_ADDR_VAR 0 2
90898: PUSH
90899: LD_VAR 0 1
90903: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90904: LD_VAR 0 1
90908: PPUSH
90909: CALL_OW 87
// end ;
90913: LD_VAR 0 2
90917: RET
// export function ComMoveHex ( unit , hex ) ; begin
90918: LD_INT 0
90920: PPUSH
// if not hex then
90921: LD_VAR 0 2
90925: NOT
90926: IFFALSE 90930
// exit ;
90928: GO 90983
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90930: LD_VAR 0 2
90934: PUSH
90935: LD_INT 1
90937: ARRAY
90938: PPUSH
90939: LD_VAR 0 2
90943: PUSH
90944: LD_INT 2
90946: ARRAY
90947: PPUSH
90948: CALL_OW 428
90952: IFFALSE 90956
// exit ;
90954: GO 90983
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90956: LD_VAR 0 1
90960: PPUSH
90961: LD_VAR 0 2
90965: PUSH
90966: LD_INT 1
90968: ARRAY
90969: PPUSH
90970: LD_VAR 0 2
90974: PUSH
90975: LD_INT 2
90977: ARRAY
90978: PPUSH
90979: CALL_OW 111
// end ;
90983: LD_VAR 0 3
90987: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90988: LD_INT 0
90990: PPUSH
90991: PPUSH
90992: PPUSH
// if not unit or not enemy then
90993: LD_VAR 0 1
90997: NOT
90998: PUSH
90999: LD_VAR 0 2
91003: NOT
91004: OR
91005: IFFALSE 91009
// exit ;
91007: GO 91133
// x := GetX ( enemy ) ;
91009: LD_ADDR_VAR 0 4
91013: PUSH
91014: LD_VAR 0 2
91018: PPUSH
91019: CALL_OW 250
91023: ST_TO_ADDR
// y := GetY ( enemy ) ;
91024: LD_ADDR_VAR 0 5
91028: PUSH
91029: LD_VAR 0 2
91033: PPUSH
91034: CALL_OW 251
91038: ST_TO_ADDR
// if ValidHex ( x , y ) then
91039: LD_VAR 0 4
91043: PPUSH
91044: LD_VAR 0 5
91048: PPUSH
91049: CALL_OW 488
91053: IFFALSE 91133
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
91055: LD_VAR 0 2
91059: PPUSH
91060: CALL_OW 247
91064: PUSH
91065: LD_INT 3
91067: PUSH
91068: LD_INT 2
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: IN
91075: PUSH
91076: LD_VAR 0 1
91080: PPUSH
91081: CALL_OW 255
91085: PPUSH
91086: LD_VAR 0 2
91090: PPUSH
91091: CALL_OW 292
91095: OR
91096: IFFALSE 91114
// ComAttackUnit ( unit , enemy ) else
91098: LD_VAR 0 1
91102: PPUSH
91103: LD_VAR 0 2
91107: PPUSH
91108: CALL_OW 115
91112: GO 91133
// ComAgressiveMove ( unit , x , y ) ;
91114: LD_VAR 0 1
91118: PPUSH
91119: LD_VAR 0 4
91123: PPUSH
91124: LD_VAR 0 5
91128: PPUSH
91129: CALL_OW 114
// end ;
91133: LD_VAR 0 3
91137: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91138: LD_INT 0
91140: PPUSH
91141: PPUSH
91142: PPUSH
// list := AreaToList ( area , 0 ) ;
91143: LD_ADDR_VAR 0 5
91147: PUSH
91148: LD_VAR 0 1
91152: PPUSH
91153: LD_INT 0
91155: PPUSH
91156: CALL_OW 517
91160: ST_TO_ADDR
// if not list then
91161: LD_VAR 0 5
91165: NOT
91166: IFFALSE 91170
// exit ;
91168: GO 91300
// if all then
91170: LD_VAR 0 2
91174: IFFALSE 91262
// begin for i := 1 to list [ 1 ] do
91176: LD_ADDR_VAR 0 4
91180: PUSH
91181: DOUBLE
91182: LD_INT 1
91184: DEC
91185: ST_TO_ADDR
91186: LD_VAR 0 5
91190: PUSH
91191: LD_INT 1
91193: ARRAY
91194: PUSH
91195: FOR_TO
91196: IFFALSE 91258
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91198: LD_ADDR_VAR 0 3
91202: PUSH
91203: LD_VAR 0 3
91207: PPUSH
91208: LD_VAR 0 3
91212: PUSH
91213: LD_INT 1
91215: PLUS
91216: PPUSH
91217: LD_VAR 0 5
91221: PUSH
91222: LD_INT 1
91224: ARRAY
91225: PUSH
91226: LD_VAR 0 4
91230: ARRAY
91231: PUSH
91232: LD_VAR 0 5
91236: PUSH
91237: LD_INT 2
91239: ARRAY
91240: PUSH
91241: LD_VAR 0 4
91245: ARRAY
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PPUSH
91251: CALL_OW 1
91255: ST_TO_ADDR
91256: GO 91195
91258: POP
91259: POP
// exit ;
91260: GO 91300
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
91262: LD_ADDR_VAR 0 3
91266: PUSH
91267: LD_VAR 0 5
91271: PUSH
91272: LD_INT 1
91274: ARRAY
91275: PUSH
91276: LD_INT 1
91278: ARRAY
91279: PUSH
91280: LD_VAR 0 5
91284: PUSH
91285: LD_INT 2
91287: ARRAY
91288: PUSH
91289: LD_INT 1
91291: ARRAY
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: EMPTY
91298: LIST
91299: ST_TO_ADDR
// end ;
91300: LD_VAR 0 3
91304: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
91305: LD_INT 0
91307: PPUSH
91308: PPUSH
// list := AreaToList ( area , 0 ) ;
91309: LD_ADDR_VAR 0 4
91313: PUSH
91314: LD_VAR 0 1
91318: PPUSH
91319: LD_INT 0
91321: PPUSH
91322: CALL_OW 517
91326: ST_TO_ADDR
// if not list then
91327: LD_VAR 0 4
91331: NOT
91332: IFFALSE 91336
// exit ;
91334: GO 91377
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91336: LD_ADDR_VAR 0 3
91340: PUSH
91341: LD_VAR 0 4
91345: PUSH
91346: LD_INT 1
91348: ARRAY
91349: PUSH
91350: LD_INT 1
91352: ARRAY
91353: PUSH
91354: LD_VAR 0 4
91358: PUSH
91359: LD_INT 2
91361: ARRAY
91362: PUSH
91363: LD_INT 1
91365: ARRAY
91366: PUSH
91367: LD_VAR 0 2
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: LIST
91376: ST_TO_ADDR
// end ;
91377: LD_VAR 0 3
91381: RET
// export function First ( array ) ; begin
91382: LD_INT 0
91384: PPUSH
// if not array then
91385: LD_VAR 0 1
91389: NOT
91390: IFFALSE 91394
// exit ;
91392: GO 91408
// result := array [ 1 ] ;
91394: LD_ADDR_VAR 0 2
91398: PUSH
91399: LD_VAR 0 1
91403: PUSH
91404: LD_INT 1
91406: ARRAY
91407: ST_TO_ADDR
// end ;
91408: LD_VAR 0 2
91412: RET
// export function Last ( array ) ; begin
91413: LD_INT 0
91415: PPUSH
// if not array then
91416: LD_VAR 0 1
91420: NOT
91421: IFFALSE 91425
// exit ;
91423: GO 91441
// result := array [ array ] ;
91425: LD_ADDR_VAR 0 2
91429: PUSH
91430: LD_VAR 0 1
91434: PUSH
91435: LD_VAR 0 1
91439: ARRAY
91440: ST_TO_ADDR
// end ;
91441: LD_VAR 0 2
91445: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
91446: LD_INT 0
91448: PPUSH
91449: PPUSH
// result := [ ] ;
91450: LD_ADDR_VAR 0 5
91454: PUSH
91455: EMPTY
91456: ST_TO_ADDR
// if not array then
91457: LD_VAR 0 1
91461: NOT
91462: IFFALSE 91466
// exit ;
91464: GO 91578
// for i := 1 to array do
91466: LD_ADDR_VAR 0 6
91470: PUSH
91471: DOUBLE
91472: LD_INT 1
91474: DEC
91475: ST_TO_ADDR
91476: LD_VAR 0 1
91480: PUSH
91481: FOR_TO
91482: IFFALSE 91576
// if array [ i ] [ index ] = value then
91484: LD_VAR 0 1
91488: PUSH
91489: LD_VAR 0 6
91493: ARRAY
91494: PUSH
91495: LD_VAR 0 2
91499: ARRAY
91500: PUSH
91501: LD_VAR 0 3
91505: EQUAL
91506: IFFALSE 91574
// begin if indexColumn then
91508: LD_VAR 0 4
91512: IFFALSE 91548
// result := Join ( result , array [ i ] [ indexColumn ] ) else
91514: LD_ADDR_VAR 0 5
91518: PUSH
91519: LD_VAR 0 5
91523: PPUSH
91524: LD_VAR 0 1
91528: PUSH
91529: LD_VAR 0 6
91533: ARRAY
91534: PUSH
91535: LD_VAR 0 4
91539: ARRAY
91540: PPUSH
91541: CALL 86760 0 2
91545: ST_TO_ADDR
91546: GO 91574
// result := Join ( result , array [ i ] ) ;
91548: LD_ADDR_VAR 0 5
91552: PUSH
91553: LD_VAR 0 5
91557: PPUSH
91558: LD_VAR 0 1
91562: PUSH
91563: LD_VAR 0 6
91567: ARRAY
91568: PPUSH
91569: CALL 86760 0 2
91573: ST_TO_ADDR
// end ;
91574: GO 91481
91576: POP
91577: POP
// end ;
91578: LD_VAR 0 5
91582: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
91583: LD_INT 0
91585: PPUSH
// if not vehicles or not parkingPoint then
91586: LD_VAR 0 1
91590: NOT
91591: PUSH
91592: LD_VAR 0 2
91596: NOT
91597: OR
91598: IFFALSE 91602
// exit ;
91600: GO 91700
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
91602: LD_ADDR_VAR 0 1
91606: PUSH
91607: LD_VAR 0 1
91611: PPUSH
91612: LD_INT 50
91614: PUSH
91615: EMPTY
91616: LIST
91617: PUSH
91618: LD_INT 3
91620: PUSH
91621: LD_INT 92
91623: PUSH
91624: LD_VAR 0 2
91628: PUSH
91629: LD_INT 1
91631: ARRAY
91632: PUSH
91633: LD_VAR 0 2
91637: PUSH
91638: LD_INT 2
91640: ARRAY
91641: PUSH
91642: LD_INT 8
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: PPUSH
91659: CALL_OW 72
91663: ST_TO_ADDR
// if not vehicles then
91664: LD_VAR 0 1
91668: NOT
91669: IFFALSE 91673
// exit ;
91671: GO 91700
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
91673: LD_VAR 0 1
91677: PPUSH
91678: LD_VAR 0 2
91682: PUSH
91683: LD_INT 1
91685: ARRAY
91686: PPUSH
91687: LD_VAR 0 2
91691: PUSH
91692: LD_INT 2
91694: ARRAY
91695: PPUSH
91696: CALL_OW 111
// end ;
91700: LD_VAR 0 3
91704: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
91705: LD_INT 0
91707: PPUSH
91708: PPUSH
91709: PPUSH
// if not side or not area then
91710: LD_VAR 0 1
91714: NOT
91715: PUSH
91716: LD_VAR 0 2
91720: NOT
91721: OR
91722: IFFALSE 91726
// exit ;
91724: GO 91845
// tmp := AreaToList ( area , 0 ) ;
91726: LD_ADDR_VAR 0 5
91730: PUSH
91731: LD_VAR 0 2
91735: PPUSH
91736: LD_INT 0
91738: PPUSH
91739: CALL_OW 517
91743: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
91744: LD_ADDR_VAR 0 4
91748: PUSH
91749: DOUBLE
91750: LD_INT 1
91752: DEC
91753: ST_TO_ADDR
91754: LD_VAR 0 5
91758: PUSH
91759: LD_INT 1
91761: ARRAY
91762: PUSH
91763: FOR_TO
91764: IFFALSE 91843
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
91766: LD_VAR 0 5
91770: PUSH
91771: LD_INT 1
91773: ARRAY
91774: PUSH
91775: LD_VAR 0 4
91779: ARRAY
91780: PPUSH
91781: LD_VAR 0 5
91785: PUSH
91786: LD_INT 2
91788: ARRAY
91789: PUSH
91790: LD_VAR 0 4
91794: ARRAY
91795: PPUSH
91796: CALL_OW 351
91800: IFFALSE 91841
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
91802: LD_VAR 0 5
91806: PUSH
91807: LD_INT 1
91809: ARRAY
91810: PUSH
91811: LD_VAR 0 4
91815: ARRAY
91816: PPUSH
91817: LD_VAR 0 5
91821: PUSH
91822: LD_INT 2
91824: ARRAY
91825: PUSH
91826: LD_VAR 0 4
91830: ARRAY
91831: PPUSH
91832: LD_VAR 0 1
91836: PPUSH
91837: CALL_OW 244
// end ;
91841: GO 91763
91843: POP
91844: POP
// end ; end_of_file end_of_file
91845: LD_VAR 0 3
91849: RET
// export globalGameSaveCounter ; every 0 0$1 do
91850: GO 91852
91852: DISABLE
// begin enable ;
91853: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91854: LD_STRING updateTimer(
91856: PUSH
91857: LD_OWVAR 1
91861: STR
91862: PUSH
91863: LD_STRING );
91865: STR
91866: PPUSH
91867: CALL_OW 559
// end ;
91871: END
// every 0 0$1 do
91872: GO 91874
91874: DISABLE
// begin globalGameSaveCounter := 0 ;
91875: LD_ADDR_EXP 95
91879: PUSH
91880: LD_INT 0
91882: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91883: LD_STRING setGameSaveCounter(0)
91885: PPUSH
91886: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91890: LD_STRING initStreamRollete();
91892: PPUSH
91893: CALL_OW 559
// InitStreamMode ;
91897: CALL 93240 0 0
// DefineStreamItems ( false ) ;
91901: LD_INT 0
91903: PPUSH
91904: CALL 93704 0 1
// end ;
91908: END
// export function SOS_MapStart ( ) ; begin
91909: LD_INT 0
91911: PPUSH
// if streamModeActive then
91912: LD_EXP 96
91916: IFFALSE 91925
// DefineStreamItems ( true ) ;
91918: LD_INT 1
91920: PPUSH
91921: CALL 93704 0 1
// UpdateLuaVariables ( ) ;
91925: CALL 91942 0 0
// UpdateFactoryWaypoints ( ) ;
91929: CALL 106706 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91933: CALL 106958 0 0
// end ;
91937: LD_VAR 0 1
91941: RET
// function UpdateLuaVariables ( ) ; begin
91942: LD_INT 0
91944: PPUSH
// if globalGameSaveCounter then
91945: LD_EXP 95
91949: IFFALSE 91983
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
91951: LD_ADDR_EXP 95
91955: PUSH
91956: LD_EXP 95
91960: PPUSH
91961: CALL 88121 0 1
91965: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91966: LD_STRING setGameSaveCounter(
91968: PUSH
91969: LD_EXP 95
91973: STR
91974: PUSH
91975: LD_STRING )
91977: STR
91978: PPUSH
91979: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
91983: LD_STRING setGameDifficulty(
91985: PUSH
91986: LD_OWVAR 67
91990: STR
91991: PUSH
91992: LD_STRING )
91994: STR
91995: PPUSH
91996: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92000: LD_STRING displayDifficulty(
92002: PUSH
92003: LD_OWVAR 67
92007: STR
92008: PUSH
92009: LD_STRING )
92011: STR
92012: PPUSH
92013: CALL_OW 559
// end ;
92017: LD_VAR 0 1
92021: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92022: LD_INT 0
92024: PPUSH
// if p2 = stream_mode then
92025: LD_VAR 0 2
92029: PUSH
92030: LD_INT 100
92032: EQUAL
92033: IFFALSE 93036
// begin if not StreamModeActive then
92035: LD_EXP 96
92039: NOT
92040: IFFALSE 92050
// StreamModeActive := true ;
92042: LD_ADDR_EXP 96
92046: PUSH
92047: LD_INT 1
92049: ST_TO_ADDR
// if p3 = 0 then
92050: LD_VAR 0 3
92054: PUSH
92055: LD_INT 0
92057: EQUAL
92058: IFFALSE 92064
// InitStreamMode ;
92060: CALL 93240 0 0
// if p3 = 1 then
92064: LD_VAR 0 3
92068: PUSH
92069: LD_INT 1
92071: EQUAL
92072: IFFALSE 92082
// sRocket := true ;
92074: LD_ADDR_EXP 101
92078: PUSH
92079: LD_INT 1
92081: ST_TO_ADDR
// if p3 = 2 then
92082: LD_VAR 0 3
92086: PUSH
92087: LD_INT 2
92089: EQUAL
92090: IFFALSE 92100
// sSpeed := true ;
92092: LD_ADDR_EXP 100
92096: PUSH
92097: LD_INT 1
92099: ST_TO_ADDR
// if p3 = 3 then
92100: LD_VAR 0 3
92104: PUSH
92105: LD_INT 3
92107: EQUAL
92108: IFFALSE 92118
// sEngine := true ;
92110: LD_ADDR_EXP 102
92114: PUSH
92115: LD_INT 1
92117: ST_TO_ADDR
// if p3 = 4 then
92118: LD_VAR 0 3
92122: PUSH
92123: LD_INT 4
92125: EQUAL
92126: IFFALSE 92136
// sSpec := true ;
92128: LD_ADDR_EXP 99
92132: PUSH
92133: LD_INT 1
92135: ST_TO_ADDR
// if p3 = 5 then
92136: LD_VAR 0 3
92140: PUSH
92141: LD_INT 5
92143: EQUAL
92144: IFFALSE 92154
// sLevel := true ;
92146: LD_ADDR_EXP 103
92150: PUSH
92151: LD_INT 1
92153: ST_TO_ADDR
// if p3 = 6 then
92154: LD_VAR 0 3
92158: PUSH
92159: LD_INT 6
92161: EQUAL
92162: IFFALSE 92172
// sArmoury := true ;
92164: LD_ADDR_EXP 104
92168: PUSH
92169: LD_INT 1
92171: ST_TO_ADDR
// if p3 = 7 then
92172: LD_VAR 0 3
92176: PUSH
92177: LD_INT 7
92179: EQUAL
92180: IFFALSE 92190
// sRadar := true ;
92182: LD_ADDR_EXP 105
92186: PUSH
92187: LD_INT 1
92189: ST_TO_ADDR
// if p3 = 8 then
92190: LD_VAR 0 3
92194: PUSH
92195: LD_INT 8
92197: EQUAL
92198: IFFALSE 92208
// sBunker := true ;
92200: LD_ADDR_EXP 106
92204: PUSH
92205: LD_INT 1
92207: ST_TO_ADDR
// if p3 = 9 then
92208: LD_VAR 0 3
92212: PUSH
92213: LD_INT 9
92215: EQUAL
92216: IFFALSE 92226
// sHack := true ;
92218: LD_ADDR_EXP 107
92222: PUSH
92223: LD_INT 1
92225: ST_TO_ADDR
// if p3 = 10 then
92226: LD_VAR 0 3
92230: PUSH
92231: LD_INT 10
92233: EQUAL
92234: IFFALSE 92244
// sFire := true ;
92236: LD_ADDR_EXP 108
92240: PUSH
92241: LD_INT 1
92243: ST_TO_ADDR
// if p3 = 11 then
92244: LD_VAR 0 3
92248: PUSH
92249: LD_INT 11
92251: EQUAL
92252: IFFALSE 92262
// sRefresh := true ;
92254: LD_ADDR_EXP 109
92258: PUSH
92259: LD_INT 1
92261: ST_TO_ADDR
// if p3 = 12 then
92262: LD_VAR 0 3
92266: PUSH
92267: LD_INT 12
92269: EQUAL
92270: IFFALSE 92280
// sExp := true ;
92272: LD_ADDR_EXP 110
92276: PUSH
92277: LD_INT 1
92279: ST_TO_ADDR
// if p3 = 13 then
92280: LD_VAR 0 3
92284: PUSH
92285: LD_INT 13
92287: EQUAL
92288: IFFALSE 92298
// sDepot := true ;
92290: LD_ADDR_EXP 111
92294: PUSH
92295: LD_INT 1
92297: ST_TO_ADDR
// if p3 = 14 then
92298: LD_VAR 0 3
92302: PUSH
92303: LD_INT 14
92305: EQUAL
92306: IFFALSE 92316
// sFlag := true ;
92308: LD_ADDR_EXP 112
92312: PUSH
92313: LD_INT 1
92315: ST_TO_ADDR
// if p3 = 15 then
92316: LD_VAR 0 3
92320: PUSH
92321: LD_INT 15
92323: EQUAL
92324: IFFALSE 92334
// sKamikadze := true ;
92326: LD_ADDR_EXP 120
92330: PUSH
92331: LD_INT 1
92333: ST_TO_ADDR
// if p3 = 16 then
92334: LD_VAR 0 3
92338: PUSH
92339: LD_INT 16
92341: EQUAL
92342: IFFALSE 92352
// sTroll := true ;
92344: LD_ADDR_EXP 121
92348: PUSH
92349: LD_INT 1
92351: ST_TO_ADDR
// if p3 = 17 then
92352: LD_VAR 0 3
92356: PUSH
92357: LD_INT 17
92359: EQUAL
92360: IFFALSE 92370
// sSlow := true ;
92362: LD_ADDR_EXP 122
92366: PUSH
92367: LD_INT 1
92369: ST_TO_ADDR
// if p3 = 18 then
92370: LD_VAR 0 3
92374: PUSH
92375: LD_INT 18
92377: EQUAL
92378: IFFALSE 92388
// sLack := true ;
92380: LD_ADDR_EXP 123
92384: PUSH
92385: LD_INT 1
92387: ST_TO_ADDR
// if p3 = 19 then
92388: LD_VAR 0 3
92392: PUSH
92393: LD_INT 19
92395: EQUAL
92396: IFFALSE 92406
// sTank := true ;
92398: LD_ADDR_EXP 125
92402: PUSH
92403: LD_INT 1
92405: ST_TO_ADDR
// if p3 = 20 then
92406: LD_VAR 0 3
92410: PUSH
92411: LD_INT 20
92413: EQUAL
92414: IFFALSE 92424
// sRemote := true ;
92416: LD_ADDR_EXP 126
92420: PUSH
92421: LD_INT 1
92423: ST_TO_ADDR
// if p3 = 21 then
92424: LD_VAR 0 3
92428: PUSH
92429: LD_INT 21
92431: EQUAL
92432: IFFALSE 92442
// sPowell := true ;
92434: LD_ADDR_EXP 127
92438: PUSH
92439: LD_INT 1
92441: ST_TO_ADDR
// if p3 = 22 then
92442: LD_VAR 0 3
92446: PUSH
92447: LD_INT 22
92449: EQUAL
92450: IFFALSE 92460
// sTeleport := true ;
92452: LD_ADDR_EXP 130
92456: PUSH
92457: LD_INT 1
92459: ST_TO_ADDR
// if p3 = 23 then
92460: LD_VAR 0 3
92464: PUSH
92465: LD_INT 23
92467: EQUAL
92468: IFFALSE 92478
// sOilTower := true ;
92470: LD_ADDR_EXP 132
92474: PUSH
92475: LD_INT 1
92477: ST_TO_ADDR
// if p3 = 24 then
92478: LD_VAR 0 3
92482: PUSH
92483: LD_INT 24
92485: EQUAL
92486: IFFALSE 92496
// sShovel := true ;
92488: LD_ADDR_EXP 133
92492: PUSH
92493: LD_INT 1
92495: ST_TO_ADDR
// if p3 = 25 then
92496: LD_VAR 0 3
92500: PUSH
92501: LD_INT 25
92503: EQUAL
92504: IFFALSE 92514
// sSheik := true ;
92506: LD_ADDR_EXP 134
92510: PUSH
92511: LD_INT 1
92513: ST_TO_ADDR
// if p3 = 26 then
92514: LD_VAR 0 3
92518: PUSH
92519: LD_INT 26
92521: EQUAL
92522: IFFALSE 92532
// sEarthquake := true ;
92524: LD_ADDR_EXP 136
92528: PUSH
92529: LD_INT 1
92531: ST_TO_ADDR
// if p3 = 27 then
92532: LD_VAR 0 3
92536: PUSH
92537: LD_INT 27
92539: EQUAL
92540: IFFALSE 92550
// sAI := true ;
92542: LD_ADDR_EXP 137
92546: PUSH
92547: LD_INT 1
92549: ST_TO_ADDR
// if p3 = 28 then
92550: LD_VAR 0 3
92554: PUSH
92555: LD_INT 28
92557: EQUAL
92558: IFFALSE 92568
// sCargo := true ;
92560: LD_ADDR_EXP 140
92564: PUSH
92565: LD_INT 1
92567: ST_TO_ADDR
// if p3 = 29 then
92568: LD_VAR 0 3
92572: PUSH
92573: LD_INT 29
92575: EQUAL
92576: IFFALSE 92586
// sDLaser := true ;
92578: LD_ADDR_EXP 141
92582: PUSH
92583: LD_INT 1
92585: ST_TO_ADDR
// if p3 = 30 then
92586: LD_VAR 0 3
92590: PUSH
92591: LD_INT 30
92593: EQUAL
92594: IFFALSE 92604
// sExchange := true ;
92596: LD_ADDR_EXP 142
92600: PUSH
92601: LD_INT 1
92603: ST_TO_ADDR
// if p3 = 31 then
92604: LD_VAR 0 3
92608: PUSH
92609: LD_INT 31
92611: EQUAL
92612: IFFALSE 92622
// sFac := true ;
92614: LD_ADDR_EXP 143
92618: PUSH
92619: LD_INT 1
92621: ST_TO_ADDR
// if p3 = 32 then
92622: LD_VAR 0 3
92626: PUSH
92627: LD_INT 32
92629: EQUAL
92630: IFFALSE 92640
// sPower := true ;
92632: LD_ADDR_EXP 144
92636: PUSH
92637: LD_INT 1
92639: ST_TO_ADDR
// if p3 = 33 then
92640: LD_VAR 0 3
92644: PUSH
92645: LD_INT 33
92647: EQUAL
92648: IFFALSE 92658
// sRandom := true ;
92650: LD_ADDR_EXP 145
92654: PUSH
92655: LD_INT 1
92657: ST_TO_ADDR
// if p3 = 34 then
92658: LD_VAR 0 3
92662: PUSH
92663: LD_INT 34
92665: EQUAL
92666: IFFALSE 92676
// sShield := true ;
92668: LD_ADDR_EXP 146
92672: PUSH
92673: LD_INT 1
92675: ST_TO_ADDR
// if p3 = 35 then
92676: LD_VAR 0 3
92680: PUSH
92681: LD_INT 35
92683: EQUAL
92684: IFFALSE 92694
// sTime := true ;
92686: LD_ADDR_EXP 147
92690: PUSH
92691: LD_INT 1
92693: ST_TO_ADDR
// if p3 = 36 then
92694: LD_VAR 0 3
92698: PUSH
92699: LD_INT 36
92701: EQUAL
92702: IFFALSE 92712
// sTools := true ;
92704: LD_ADDR_EXP 148
92708: PUSH
92709: LD_INT 1
92711: ST_TO_ADDR
// if p3 = 101 then
92712: LD_VAR 0 3
92716: PUSH
92717: LD_INT 101
92719: EQUAL
92720: IFFALSE 92730
// sSold := true ;
92722: LD_ADDR_EXP 113
92726: PUSH
92727: LD_INT 1
92729: ST_TO_ADDR
// if p3 = 102 then
92730: LD_VAR 0 3
92734: PUSH
92735: LD_INT 102
92737: EQUAL
92738: IFFALSE 92748
// sDiff := true ;
92740: LD_ADDR_EXP 114
92744: PUSH
92745: LD_INT 1
92747: ST_TO_ADDR
// if p3 = 103 then
92748: LD_VAR 0 3
92752: PUSH
92753: LD_INT 103
92755: EQUAL
92756: IFFALSE 92766
// sFog := true ;
92758: LD_ADDR_EXP 117
92762: PUSH
92763: LD_INT 1
92765: ST_TO_ADDR
// if p3 = 104 then
92766: LD_VAR 0 3
92770: PUSH
92771: LD_INT 104
92773: EQUAL
92774: IFFALSE 92784
// sReset := true ;
92776: LD_ADDR_EXP 118
92780: PUSH
92781: LD_INT 1
92783: ST_TO_ADDR
// if p3 = 105 then
92784: LD_VAR 0 3
92788: PUSH
92789: LD_INT 105
92791: EQUAL
92792: IFFALSE 92802
// sSun := true ;
92794: LD_ADDR_EXP 119
92798: PUSH
92799: LD_INT 1
92801: ST_TO_ADDR
// if p3 = 106 then
92802: LD_VAR 0 3
92806: PUSH
92807: LD_INT 106
92809: EQUAL
92810: IFFALSE 92820
// sTiger := true ;
92812: LD_ADDR_EXP 115
92816: PUSH
92817: LD_INT 1
92819: ST_TO_ADDR
// if p3 = 107 then
92820: LD_VAR 0 3
92824: PUSH
92825: LD_INT 107
92827: EQUAL
92828: IFFALSE 92838
// sBomb := true ;
92830: LD_ADDR_EXP 116
92834: PUSH
92835: LD_INT 1
92837: ST_TO_ADDR
// if p3 = 108 then
92838: LD_VAR 0 3
92842: PUSH
92843: LD_INT 108
92845: EQUAL
92846: IFFALSE 92856
// sWound := true ;
92848: LD_ADDR_EXP 124
92852: PUSH
92853: LD_INT 1
92855: ST_TO_ADDR
// if p3 = 109 then
92856: LD_VAR 0 3
92860: PUSH
92861: LD_INT 109
92863: EQUAL
92864: IFFALSE 92874
// sBetray := true ;
92866: LD_ADDR_EXP 128
92870: PUSH
92871: LD_INT 1
92873: ST_TO_ADDR
// if p3 = 110 then
92874: LD_VAR 0 3
92878: PUSH
92879: LD_INT 110
92881: EQUAL
92882: IFFALSE 92892
// sContamin := true ;
92884: LD_ADDR_EXP 129
92888: PUSH
92889: LD_INT 1
92891: ST_TO_ADDR
// if p3 = 111 then
92892: LD_VAR 0 3
92896: PUSH
92897: LD_INT 111
92899: EQUAL
92900: IFFALSE 92910
// sOil := true ;
92902: LD_ADDR_EXP 131
92906: PUSH
92907: LD_INT 1
92909: ST_TO_ADDR
// if p3 = 112 then
92910: LD_VAR 0 3
92914: PUSH
92915: LD_INT 112
92917: EQUAL
92918: IFFALSE 92928
// sStu := true ;
92920: LD_ADDR_EXP 135
92924: PUSH
92925: LD_INT 1
92927: ST_TO_ADDR
// if p3 = 113 then
92928: LD_VAR 0 3
92932: PUSH
92933: LD_INT 113
92935: EQUAL
92936: IFFALSE 92946
// sBazooka := true ;
92938: LD_ADDR_EXP 138
92942: PUSH
92943: LD_INT 1
92945: ST_TO_ADDR
// if p3 = 114 then
92946: LD_VAR 0 3
92950: PUSH
92951: LD_INT 114
92953: EQUAL
92954: IFFALSE 92964
// sMortar := true ;
92956: LD_ADDR_EXP 139
92960: PUSH
92961: LD_INT 1
92963: ST_TO_ADDR
// if p3 = 115 then
92964: LD_VAR 0 3
92968: PUSH
92969: LD_INT 115
92971: EQUAL
92972: IFFALSE 92982
// sRanger := true ;
92974: LD_ADDR_EXP 149
92978: PUSH
92979: LD_INT 1
92981: ST_TO_ADDR
// if p3 = 116 then
92982: LD_VAR 0 3
92986: PUSH
92987: LD_INT 116
92989: EQUAL
92990: IFFALSE 93000
// sComputer := true ;
92992: LD_ADDR_EXP 150
92996: PUSH
92997: LD_INT 1
92999: ST_TO_ADDR
// if p3 = 117 then
93000: LD_VAR 0 3
93004: PUSH
93005: LD_INT 117
93007: EQUAL
93008: IFFALSE 93018
// s30 := true ;
93010: LD_ADDR_EXP 151
93014: PUSH
93015: LD_INT 1
93017: ST_TO_ADDR
// if p3 = 118 then
93018: LD_VAR 0 3
93022: PUSH
93023: LD_INT 118
93025: EQUAL
93026: IFFALSE 93036
// s60 := true ;
93028: LD_ADDR_EXP 152
93032: PUSH
93033: LD_INT 1
93035: ST_TO_ADDR
// end ; if p2 = hack_mode then
93036: LD_VAR 0 2
93040: PUSH
93041: LD_INT 101
93043: EQUAL
93044: IFFALSE 93172
// begin case p3 of 1 :
93046: LD_VAR 0 3
93050: PUSH
93051: LD_INT 1
93053: DOUBLE
93054: EQUAL
93055: IFTRUE 93059
93057: GO 93066
93059: POP
// hHackUnlimitedResources ; 2 :
93060: CALL 105319 0 0
93064: GO 93172
93066: LD_INT 2
93068: DOUBLE
93069: EQUAL
93070: IFTRUE 93074
93072: GO 93081
93074: POP
// hHackSetLevel10 ; 3 :
93075: CALL 105452 0 0
93079: GO 93172
93081: LD_INT 3
93083: DOUBLE
93084: EQUAL
93085: IFTRUE 93089
93087: GO 93096
93089: POP
// hHackSetLevel10YourUnits ; 4 :
93090: CALL 105537 0 0
93094: GO 93172
93096: LD_INT 4
93098: DOUBLE
93099: EQUAL
93100: IFTRUE 93104
93102: GO 93111
93104: POP
// hHackInvincible ; 5 :
93105: CALL 105985 0 0
93109: GO 93172
93111: LD_INT 5
93113: DOUBLE
93114: EQUAL
93115: IFTRUE 93119
93117: GO 93126
93119: POP
// hHackInvisible ; 6 :
93120: CALL 106096 0 0
93124: GO 93172
93126: LD_INT 6
93128: DOUBLE
93129: EQUAL
93130: IFTRUE 93134
93132: GO 93141
93134: POP
// hHackChangeYourSide ; 7 :
93135: CALL 106153 0 0
93139: GO 93172
93141: LD_INT 7
93143: DOUBLE
93144: EQUAL
93145: IFTRUE 93149
93147: GO 93156
93149: POP
// hHackChangeUnitSide ; 8 :
93150: CALL 106195 0 0
93154: GO 93172
93156: LD_INT 8
93158: DOUBLE
93159: EQUAL
93160: IFTRUE 93164
93162: GO 93171
93164: POP
// hHackFog ; end ;
93165: CALL 106296 0 0
93169: GO 93172
93171: POP
// end ; if p2 = game_save_mode then
93172: LD_VAR 0 2
93176: PUSH
93177: LD_INT 102
93179: EQUAL
93180: IFFALSE 93235
// begin if p3 = 1 then
93182: LD_VAR 0 3
93186: PUSH
93187: LD_INT 1
93189: EQUAL
93190: IFFALSE 93202
// globalGameSaveCounter := p4 ;
93192: LD_ADDR_EXP 95
93196: PUSH
93197: LD_VAR 0 4
93201: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93202: LD_VAR 0 3
93206: PUSH
93207: LD_INT 2
93209: EQUAL
93210: PUSH
93211: LD_EXP 95
93215: AND
93216: IFFALSE 93235
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93218: LD_STRING setGameSaveCounter(
93220: PUSH
93221: LD_EXP 95
93225: STR
93226: PUSH
93227: LD_STRING )
93229: STR
93230: PPUSH
93231: CALL_OW 559
// end ; end ;
93235: LD_VAR 0 7
93239: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93240: LD_INT 0
93242: PPUSH
// streamModeActive := false ;
93243: LD_ADDR_EXP 96
93247: PUSH
93248: LD_INT 0
93250: ST_TO_ADDR
// normalCounter := 36 ;
93251: LD_ADDR_EXP 97
93255: PUSH
93256: LD_INT 36
93258: ST_TO_ADDR
// hardcoreCounter := 18 ;
93259: LD_ADDR_EXP 98
93263: PUSH
93264: LD_INT 18
93266: ST_TO_ADDR
// sRocket := false ;
93267: LD_ADDR_EXP 101
93271: PUSH
93272: LD_INT 0
93274: ST_TO_ADDR
// sSpeed := false ;
93275: LD_ADDR_EXP 100
93279: PUSH
93280: LD_INT 0
93282: ST_TO_ADDR
// sEngine := false ;
93283: LD_ADDR_EXP 102
93287: PUSH
93288: LD_INT 0
93290: ST_TO_ADDR
// sSpec := false ;
93291: LD_ADDR_EXP 99
93295: PUSH
93296: LD_INT 0
93298: ST_TO_ADDR
// sLevel := false ;
93299: LD_ADDR_EXP 103
93303: PUSH
93304: LD_INT 0
93306: ST_TO_ADDR
// sArmoury := false ;
93307: LD_ADDR_EXP 104
93311: PUSH
93312: LD_INT 0
93314: ST_TO_ADDR
// sRadar := false ;
93315: LD_ADDR_EXP 105
93319: PUSH
93320: LD_INT 0
93322: ST_TO_ADDR
// sBunker := false ;
93323: LD_ADDR_EXP 106
93327: PUSH
93328: LD_INT 0
93330: ST_TO_ADDR
// sHack := false ;
93331: LD_ADDR_EXP 107
93335: PUSH
93336: LD_INT 0
93338: ST_TO_ADDR
// sFire := false ;
93339: LD_ADDR_EXP 108
93343: PUSH
93344: LD_INT 0
93346: ST_TO_ADDR
// sRefresh := false ;
93347: LD_ADDR_EXP 109
93351: PUSH
93352: LD_INT 0
93354: ST_TO_ADDR
// sExp := false ;
93355: LD_ADDR_EXP 110
93359: PUSH
93360: LD_INT 0
93362: ST_TO_ADDR
// sDepot := false ;
93363: LD_ADDR_EXP 111
93367: PUSH
93368: LD_INT 0
93370: ST_TO_ADDR
// sFlag := false ;
93371: LD_ADDR_EXP 112
93375: PUSH
93376: LD_INT 0
93378: ST_TO_ADDR
// sKamikadze := false ;
93379: LD_ADDR_EXP 120
93383: PUSH
93384: LD_INT 0
93386: ST_TO_ADDR
// sTroll := false ;
93387: LD_ADDR_EXP 121
93391: PUSH
93392: LD_INT 0
93394: ST_TO_ADDR
// sSlow := false ;
93395: LD_ADDR_EXP 122
93399: PUSH
93400: LD_INT 0
93402: ST_TO_ADDR
// sLack := false ;
93403: LD_ADDR_EXP 123
93407: PUSH
93408: LD_INT 0
93410: ST_TO_ADDR
// sTank := false ;
93411: LD_ADDR_EXP 125
93415: PUSH
93416: LD_INT 0
93418: ST_TO_ADDR
// sRemote := false ;
93419: LD_ADDR_EXP 126
93423: PUSH
93424: LD_INT 0
93426: ST_TO_ADDR
// sPowell := false ;
93427: LD_ADDR_EXP 127
93431: PUSH
93432: LD_INT 0
93434: ST_TO_ADDR
// sTeleport := false ;
93435: LD_ADDR_EXP 130
93439: PUSH
93440: LD_INT 0
93442: ST_TO_ADDR
// sOilTower := false ;
93443: LD_ADDR_EXP 132
93447: PUSH
93448: LD_INT 0
93450: ST_TO_ADDR
// sShovel := false ;
93451: LD_ADDR_EXP 133
93455: PUSH
93456: LD_INT 0
93458: ST_TO_ADDR
// sSheik := false ;
93459: LD_ADDR_EXP 134
93463: PUSH
93464: LD_INT 0
93466: ST_TO_ADDR
// sEarthquake := false ;
93467: LD_ADDR_EXP 136
93471: PUSH
93472: LD_INT 0
93474: ST_TO_ADDR
// sAI := false ;
93475: LD_ADDR_EXP 137
93479: PUSH
93480: LD_INT 0
93482: ST_TO_ADDR
// sCargo := false ;
93483: LD_ADDR_EXP 140
93487: PUSH
93488: LD_INT 0
93490: ST_TO_ADDR
// sDLaser := false ;
93491: LD_ADDR_EXP 141
93495: PUSH
93496: LD_INT 0
93498: ST_TO_ADDR
// sExchange := false ;
93499: LD_ADDR_EXP 142
93503: PUSH
93504: LD_INT 0
93506: ST_TO_ADDR
// sFac := false ;
93507: LD_ADDR_EXP 143
93511: PUSH
93512: LD_INT 0
93514: ST_TO_ADDR
// sPower := false ;
93515: LD_ADDR_EXP 144
93519: PUSH
93520: LD_INT 0
93522: ST_TO_ADDR
// sRandom := false ;
93523: LD_ADDR_EXP 145
93527: PUSH
93528: LD_INT 0
93530: ST_TO_ADDR
// sShield := false ;
93531: LD_ADDR_EXP 146
93535: PUSH
93536: LD_INT 0
93538: ST_TO_ADDR
// sTime := false ;
93539: LD_ADDR_EXP 147
93543: PUSH
93544: LD_INT 0
93546: ST_TO_ADDR
// sTools := false ;
93547: LD_ADDR_EXP 148
93551: PUSH
93552: LD_INT 0
93554: ST_TO_ADDR
// sSold := false ;
93555: LD_ADDR_EXP 113
93559: PUSH
93560: LD_INT 0
93562: ST_TO_ADDR
// sDiff := false ;
93563: LD_ADDR_EXP 114
93567: PUSH
93568: LD_INT 0
93570: ST_TO_ADDR
// sFog := false ;
93571: LD_ADDR_EXP 117
93575: PUSH
93576: LD_INT 0
93578: ST_TO_ADDR
// sReset := false ;
93579: LD_ADDR_EXP 118
93583: PUSH
93584: LD_INT 0
93586: ST_TO_ADDR
// sSun := false ;
93587: LD_ADDR_EXP 119
93591: PUSH
93592: LD_INT 0
93594: ST_TO_ADDR
// sTiger := false ;
93595: LD_ADDR_EXP 115
93599: PUSH
93600: LD_INT 0
93602: ST_TO_ADDR
// sBomb := false ;
93603: LD_ADDR_EXP 116
93607: PUSH
93608: LD_INT 0
93610: ST_TO_ADDR
// sWound := false ;
93611: LD_ADDR_EXP 124
93615: PUSH
93616: LD_INT 0
93618: ST_TO_ADDR
// sBetray := false ;
93619: LD_ADDR_EXP 128
93623: PUSH
93624: LD_INT 0
93626: ST_TO_ADDR
// sContamin := false ;
93627: LD_ADDR_EXP 129
93631: PUSH
93632: LD_INT 0
93634: ST_TO_ADDR
// sOil := false ;
93635: LD_ADDR_EXP 131
93639: PUSH
93640: LD_INT 0
93642: ST_TO_ADDR
// sStu := false ;
93643: LD_ADDR_EXP 135
93647: PUSH
93648: LD_INT 0
93650: ST_TO_ADDR
// sBazooka := false ;
93651: LD_ADDR_EXP 138
93655: PUSH
93656: LD_INT 0
93658: ST_TO_ADDR
// sMortar := false ;
93659: LD_ADDR_EXP 139
93663: PUSH
93664: LD_INT 0
93666: ST_TO_ADDR
// sRanger := false ;
93667: LD_ADDR_EXP 149
93671: PUSH
93672: LD_INT 0
93674: ST_TO_ADDR
// sComputer := false ;
93675: LD_ADDR_EXP 150
93679: PUSH
93680: LD_INT 0
93682: ST_TO_ADDR
// s30 := false ;
93683: LD_ADDR_EXP 151
93687: PUSH
93688: LD_INT 0
93690: ST_TO_ADDR
// s60 := false ;
93691: LD_ADDR_EXP 152
93695: PUSH
93696: LD_INT 0
93698: ST_TO_ADDR
// end ;
93699: LD_VAR 0 1
93703: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93704: LD_INT 0
93706: PPUSH
93707: PPUSH
93708: PPUSH
93709: PPUSH
93710: PPUSH
93711: PPUSH
93712: PPUSH
// result := [ ] ;
93713: LD_ADDR_VAR 0 2
93717: PUSH
93718: EMPTY
93719: ST_TO_ADDR
// if campaign_id = 1 then
93720: LD_OWVAR 69
93724: PUSH
93725: LD_INT 1
93727: EQUAL
93728: IFFALSE 96894
// begin case mission_number of 1 :
93730: LD_OWVAR 70
93734: PUSH
93735: LD_INT 1
93737: DOUBLE
93738: EQUAL
93739: IFTRUE 93743
93741: GO 93819
93743: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93744: LD_ADDR_VAR 0 2
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 4
93754: PUSH
93755: LD_INT 11
93757: PUSH
93758: LD_INT 12
93760: PUSH
93761: LD_INT 15
93763: PUSH
93764: LD_INT 16
93766: PUSH
93767: LD_INT 22
93769: PUSH
93770: LD_INT 23
93772: PUSH
93773: LD_INT 26
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 101
93789: PUSH
93790: LD_INT 102
93792: PUSH
93793: LD_INT 106
93795: PUSH
93796: LD_INT 116
93798: PUSH
93799: LD_INT 117
93801: PUSH
93802: LD_INT 118
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: ST_TO_ADDR
93817: GO 96892
93819: LD_INT 2
93821: DOUBLE
93822: EQUAL
93823: IFTRUE 93827
93825: GO 93911
93827: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93828: LD_ADDR_VAR 0 2
93832: PUSH
93833: LD_INT 2
93835: PUSH
93836: LD_INT 4
93838: PUSH
93839: LD_INT 11
93841: PUSH
93842: LD_INT 12
93844: PUSH
93845: LD_INT 15
93847: PUSH
93848: LD_INT 16
93850: PUSH
93851: LD_INT 22
93853: PUSH
93854: LD_INT 23
93856: PUSH
93857: LD_INT 26
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 101
93873: PUSH
93874: LD_INT 102
93876: PUSH
93877: LD_INT 105
93879: PUSH
93880: LD_INT 106
93882: PUSH
93883: LD_INT 108
93885: PUSH
93886: LD_INT 116
93888: PUSH
93889: LD_INT 117
93891: PUSH
93892: LD_INT 118
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: ST_TO_ADDR
93909: GO 96892
93911: LD_INT 3
93913: DOUBLE
93914: EQUAL
93915: IFTRUE 93919
93917: GO 94007
93919: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93920: LD_ADDR_VAR 0 2
93924: PUSH
93925: LD_INT 2
93927: PUSH
93928: LD_INT 4
93930: PUSH
93931: LD_INT 5
93933: PUSH
93934: LD_INT 11
93936: PUSH
93937: LD_INT 12
93939: PUSH
93940: LD_INT 15
93942: PUSH
93943: LD_INT 16
93945: PUSH
93946: LD_INT 22
93948: PUSH
93949: LD_INT 26
93951: PUSH
93952: LD_INT 36
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 101
93969: PUSH
93970: LD_INT 102
93972: PUSH
93973: LD_INT 105
93975: PUSH
93976: LD_INT 106
93978: PUSH
93979: LD_INT 108
93981: PUSH
93982: LD_INT 116
93984: PUSH
93985: LD_INT 117
93987: PUSH
93988: LD_INT 118
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: ST_TO_ADDR
94005: GO 96892
94007: LD_INT 4
94009: DOUBLE
94010: EQUAL
94011: IFTRUE 94015
94013: GO 94111
94015: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94016: LD_ADDR_VAR 0 2
94020: PUSH
94021: LD_INT 2
94023: PUSH
94024: LD_INT 4
94026: PUSH
94027: LD_INT 5
94029: PUSH
94030: LD_INT 8
94032: PUSH
94033: LD_INT 11
94035: PUSH
94036: LD_INT 12
94038: PUSH
94039: LD_INT 15
94041: PUSH
94042: LD_INT 16
94044: PUSH
94045: LD_INT 22
94047: PUSH
94048: LD_INT 23
94050: PUSH
94051: LD_INT 26
94053: PUSH
94054: LD_INT 36
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: PUSH
94071: LD_INT 101
94073: PUSH
94074: LD_INT 102
94076: PUSH
94077: LD_INT 105
94079: PUSH
94080: LD_INT 106
94082: PUSH
94083: LD_INT 108
94085: PUSH
94086: LD_INT 116
94088: PUSH
94089: LD_INT 117
94091: PUSH
94092: LD_INT 118
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: ST_TO_ADDR
94109: GO 96892
94111: LD_INT 5
94113: DOUBLE
94114: EQUAL
94115: IFTRUE 94119
94117: GO 94231
94119: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94120: LD_ADDR_VAR 0 2
94124: PUSH
94125: LD_INT 2
94127: PUSH
94128: LD_INT 4
94130: PUSH
94131: LD_INT 5
94133: PUSH
94134: LD_INT 6
94136: PUSH
94137: LD_INT 8
94139: PUSH
94140: LD_INT 11
94142: PUSH
94143: LD_INT 12
94145: PUSH
94146: LD_INT 15
94148: PUSH
94149: LD_INT 16
94151: PUSH
94152: LD_INT 22
94154: PUSH
94155: LD_INT 23
94157: PUSH
94158: LD_INT 25
94160: PUSH
94161: LD_INT 26
94163: PUSH
94164: LD_INT 36
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 101
94185: PUSH
94186: LD_INT 102
94188: PUSH
94189: LD_INT 105
94191: PUSH
94192: LD_INT 106
94194: PUSH
94195: LD_INT 108
94197: PUSH
94198: LD_INT 109
94200: PUSH
94201: LD_INT 112
94203: PUSH
94204: LD_INT 116
94206: PUSH
94207: LD_INT 117
94209: PUSH
94210: LD_INT 118
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: ST_TO_ADDR
94229: GO 96892
94231: LD_INT 6
94233: DOUBLE
94234: EQUAL
94235: IFTRUE 94239
94237: GO 94371
94239: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94240: LD_ADDR_VAR 0 2
94244: PUSH
94245: LD_INT 2
94247: PUSH
94248: LD_INT 4
94250: PUSH
94251: LD_INT 5
94253: PUSH
94254: LD_INT 6
94256: PUSH
94257: LD_INT 8
94259: PUSH
94260: LD_INT 11
94262: PUSH
94263: LD_INT 12
94265: PUSH
94266: LD_INT 15
94268: PUSH
94269: LD_INT 16
94271: PUSH
94272: LD_INT 20
94274: PUSH
94275: LD_INT 21
94277: PUSH
94278: LD_INT 22
94280: PUSH
94281: LD_INT 23
94283: PUSH
94284: LD_INT 25
94286: PUSH
94287: LD_INT 26
94289: PUSH
94290: LD_INT 30
94292: PUSH
94293: LD_INT 31
94295: PUSH
94296: LD_INT 32
94298: PUSH
94299: LD_INT 36
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 101
94325: PUSH
94326: LD_INT 102
94328: PUSH
94329: LD_INT 105
94331: PUSH
94332: LD_INT 106
94334: PUSH
94335: LD_INT 108
94337: PUSH
94338: LD_INT 109
94340: PUSH
94341: LD_INT 112
94343: PUSH
94344: LD_INT 116
94346: PUSH
94347: LD_INT 117
94349: PUSH
94350: LD_INT 118
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: ST_TO_ADDR
94369: GO 96892
94371: LD_INT 7
94373: DOUBLE
94374: EQUAL
94375: IFTRUE 94379
94377: GO 94491
94379: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94380: LD_ADDR_VAR 0 2
94384: PUSH
94385: LD_INT 2
94387: PUSH
94388: LD_INT 4
94390: PUSH
94391: LD_INT 5
94393: PUSH
94394: LD_INT 7
94396: PUSH
94397: LD_INT 11
94399: PUSH
94400: LD_INT 12
94402: PUSH
94403: LD_INT 15
94405: PUSH
94406: LD_INT 16
94408: PUSH
94409: LD_INT 20
94411: PUSH
94412: LD_INT 21
94414: PUSH
94415: LD_INT 22
94417: PUSH
94418: LD_INT 23
94420: PUSH
94421: LD_INT 25
94423: PUSH
94424: LD_INT 26
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 101
94445: PUSH
94446: LD_INT 102
94448: PUSH
94449: LD_INT 103
94451: PUSH
94452: LD_INT 105
94454: PUSH
94455: LD_INT 106
94457: PUSH
94458: LD_INT 108
94460: PUSH
94461: LD_INT 112
94463: PUSH
94464: LD_INT 116
94466: PUSH
94467: LD_INT 117
94469: PUSH
94470: LD_INT 118
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: ST_TO_ADDR
94489: GO 96892
94491: LD_INT 8
94493: DOUBLE
94494: EQUAL
94495: IFTRUE 94499
94497: GO 94639
94499: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94500: LD_ADDR_VAR 0 2
94504: PUSH
94505: LD_INT 2
94507: PUSH
94508: LD_INT 4
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: LD_INT 6
94516: PUSH
94517: LD_INT 7
94519: PUSH
94520: LD_INT 8
94522: PUSH
94523: LD_INT 11
94525: PUSH
94526: LD_INT 12
94528: PUSH
94529: LD_INT 15
94531: PUSH
94532: LD_INT 16
94534: PUSH
94535: LD_INT 20
94537: PUSH
94538: LD_INT 21
94540: PUSH
94541: LD_INT 22
94543: PUSH
94544: LD_INT 23
94546: PUSH
94547: LD_INT 25
94549: PUSH
94550: LD_INT 26
94552: PUSH
94553: LD_INT 30
94555: PUSH
94556: LD_INT 31
94558: PUSH
94559: LD_INT 32
94561: PUSH
94562: LD_INT 36
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: PUSH
94587: LD_INT 101
94589: PUSH
94590: LD_INT 102
94592: PUSH
94593: LD_INT 103
94595: PUSH
94596: LD_INT 105
94598: PUSH
94599: LD_INT 106
94601: PUSH
94602: LD_INT 108
94604: PUSH
94605: LD_INT 109
94607: PUSH
94608: LD_INT 112
94610: PUSH
94611: LD_INT 116
94613: PUSH
94614: LD_INT 117
94616: PUSH
94617: LD_INT 118
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: ST_TO_ADDR
94637: GO 96892
94639: LD_INT 9
94641: DOUBLE
94642: EQUAL
94643: IFTRUE 94647
94645: GO 94795
94647: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94648: LD_ADDR_VAR 0 2
94652: PUSH
94653: LD_INT 2
94655: PUSH
94656: LD_INT 4
94658: PUSH
94659: LD_INT 5
94661: PUSH
94662: LD_INT 6
94664: PUSH
94665: LD_INT 7
94667: PUSH
94668: LD_INT 8
94670: PUSH
94671: LD_INT 11
94673: PUSH
94674: LD_INT 12
94676: PUSH
94677: LD_INT 15
94679: PUSH
94680: LD_INT 16
94682: PUSH
94683: LD_INT 20
94685: PUSH
94686: LD_INT 21
94688: PUSH
94689: LD_INT 22
94691: PUSH
94692: LD_INT 23
94694: PUSH
94695: LD_INT 25
94697: PUSH
94698: LD_INT 26
94700: PUSH
94701: LD_INT 28
94703: PUSH
94704: LD_INT 30
94706: PUSH
94707: LD_INT 31
94709: PUSH
94710: LD_INT 32
94712: PUSH
94713: LD_INT 36
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 101
94741: PUSH
94742: LD_INT 102
94744: PUSH
94745: LD_INT 103
94747: PUSH
94748: LD_INT 105
94750: PUSH
94751: LD_INT 106
94753: PUSH
94754: LD_INT 108
94756: PUSH
94757: LD_INT 109
94759: PUSH
94760: LD_INT 112
94762: PUSH
94763: LD_INT 114
94765: PUSH
94766: LD_INT 116
94768: PUSH
94769: LD_INT 117
94771: PUSH
94772: LD_INT 118
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: ST_TO_ADDR
94793: GO 96892
94795: LD_INT 10
94797: DOUBLE
94798: EQUAL
94799: IFTRUE 94803
94801: GO 94999
94803: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94804: LD_ADDR_VAR 0 2
94808: PUSH
94809: LD_INT 2
94811: PUSH
94812: LD_INT 4
94814: PUSH
94815: LD_INT 5
94817: PUSH
94818: LD_INT 6
94820: PUSH
94821: LD_INT 7
94823: PUSH
94824: LD_INT 8
94826: PUSH
94827: LD_INT 9
94829: PUSH
94830: LD_INT 10
94832: PUSH
94833: LD_INT 11
94835: PUSH
94836: LD_INT 12
94838: PUSH
94839: LD_INT 13
94841: PUSH
94842: LD_INT 14
94844: PUSH
94845: LD_INT 15
94847: PUSH
94848: LD_INT 16
94850: PUSH
94851: LD_INT 17
94853: PUSH
94854: LD_INT 18
94856: PUSH
94857: LD_INT 19
94859: PUSH
94860: LD_INT 20
94862: PUSH
94863: LD_INT 21
94865: PUSH
94866: LD_INT 22
94868: PUSH
94869: LD_INT 23
94871: PUSH
94872: LD_INT 24
94874: PUSH
94875: LD_INT 25
94877: PUSH
94878: LD_INT 26
94880: PUSH
94881: LD_INT 28
94883: PUSH
94884: LD_INT 30
94886: PUSH
94887: LD_INT 31
94889: PUSH
94890: LD_INT 32
94892: PUSH
94893: LD_INT 36
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: PUSH
94927: LD_INT 101
94929: PUSH
94930: LD_INT 102
94932: PUSH
94933: LD_INT 103
94935: PUSH
94936: LD_INT 104
94938: PUSH
94939: LD_INT 105
94941: PUSH
94942: LD_INT 106
94944: PUSH
94945: LD_INT 107
94947: PUSH
94948: LD_INT 108
94950: PUSH
94951: LD_INT 109
94953: PUSH
94954: LD_INT 110
94956: PUSH
94957: LD_INT 111
94959: PUSH
94960: LD_INT 112
94962: PUSH
94963: LD_INT 114
94965: PUSH
94966: LD_INT 116
94968: PUSH
94969: LD_INT 117
94971: PUSH
94972: LD_INT 118
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: ST_TO_ADDR
94997: GO 96892
94999: LD_INT 11
95001: DOUBLE
95002: EQUAL
95003: IFTRUE 95007
95005: GO 95211
95007: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95008: LD_ADDR_VAR 0 2
95012: PUSH
95013: LD_INT 2
95015: PUSH
95016: LD_INT 3
95018: PUSH
95019: LD_INT 4
95021: PUSH
95022: LD_INT 5
95024: PUSH
95025: LD_INT 6
95027: PUSH
95028: LD_INT 7
95030: PUSH
95031: LD_INT 8
95033: PUSH
95034: LD_INT 9
95036: PUSH
95037: LD_INT 10
95039: PUSH
95040: LD_INT 11
95042: PUSH
95043: LD_INT 12
95045: PUSH
95046: LD_INT 13
95048: PUSH
95049: LD_INT 14
95051: PUSH
95052: LD_INT 15
95054: PUSH
95055: LD_INT 16
95057: PUSH
95058: LD_INT 17
95060: PUSH
95061: LD_INT 18
95063: PUSH
95064: LD_INT 19
95066: PUSH
95067: LD_INT 20
95069: PUSH
95070: LD_INT 21
95072: PUSH
95073: LD_INT 22
95075: PUSH
95076: LD_INT 23
95078: PUSH
95079: LD_INT 24
95081: PUSH
95082: LD_INT 25
95084: PUSH
95085: LD_INT 26
95087: PUSH
95088: LD_INT 28
95090: PUSH
95091: LD_INT 30
95093: PUSH
95094: LD_INT 31
95096: PUSH
95097: LD_INT 32
95099: PUSH
95100: LD_INT 34
95102: PUSH
95103: LD_INT 36
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 101
95141: PUSH
95142: LD_INT 102
95144: PUSH
95145: LD_INT 103
95147: PUSH
95148: LD_INT 104
95150: PUSH
95151: LD_INT 105
95153: PUSH
95154: LD_INT 106
95156: PUSH
95157: LD_INT 107
95159: PUSH
95160: LD_INT 108
95162: PUSH
95163: LD_INT 109
95165: PUSH
95166: LD_INT 110
95168: PUSH
95169: LD_INT 111
95171: PUSH
95172: LD_INT 112
95174: PUSH
95175: LD_INT 114
95177: PUSH
95178: LD_INT 116
95180: PUSH
95181: LD_INT 117
95183: PUSH
95184: LD_INT 118
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: ST_TO_ADDR
95209: GO 96892
95211: LD_INT 12
95213: DOUBLE
95214: EQUAL
95215: IFTRUE 95219
95217: GO 95439
95219: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95220: LD_ADDR_VAR 0 2
95224: PUSH
95225: LD_INT 1
95227: PUSH
95228: LD_INT 2
95230: PUSH
95231: LD_INT 3
95233: PUSH
95234: LD_INT 4
95236: PUSH
95237: LD_INT 5
95239: PUSH
95240: LD_INT 6
95242: PUSH
95243: LD_INT 7
95245: PUSH
95246: LD_INT 8
95248: PUSH
95249: LD_INT 9
95251: PUSH
95252: LD_INT 10
95254: PUSH
95255: LD_INT 11
95257: PUSH
95258: LD_INT 12
95260: PUSH
95261: LD_INT 13
95263: PUSH
95264: LD_INT 14
95266: PUSH
95267: LD_INT 15
95269: PUSH
95270: LD_INT 16
95272: PUSH
95273: LD_INT 17
95275: PUSH
95276: LD_INT 18
95278: PUSH
95279: LD_INT 19
95281: PUSH
95282: LD_INT 20
95284: PUSH
95285: LD_INT 21
95287: PUSH
95288: LD_INT 22
95290: PUSH
95291: LD_INT 23
95293: PUSH
95294: LD_INT 24
95296: PUSH
95297: LD_INT 25
95299: PUSH
95300: LD_INT 26
95302: PUSH
95303: LD_INT 27
95305: PUSH
95306: LD_INT 28
95308: PUSH
95309: LD_INT 30
95311: PUSH
95312: LD_INT 31
95314: PUSH
95315: LD_INT 32
95317: PUSH
95318: LD_INT 33
95320: PUSH
95321: LD_INT 34
95323: PUSH
95324: LD_INT 36
95326: PUSH
95327: EMPTY
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: PUSH
95363: LD_INT 101
95365: PUSH
95366: LD_INT 102
95368: PUSH
95369: LD_INT 103
95371: PUSH
95372: LD_INT 104
95374: PUSH
95375: LD_INT 105
95377: PUSH
95378: LD_INT 106
95380: PUSH
95381: LD_INT 107
95383: PUSH
95384: LD_INT 108
95386: PUSH
95387: LD_INT 109
95389: PUSH
95390: LD_INT 110
95392: PUSH
95393: LD_INT 111
95395: PUSH
95396: LD_INT 112
95398: PUSH
95399: LD_INT 113
95401: PUSH
95402: LD_INT 114
95404: PUSH
95405: LD_INT 116
95407: PUSH
95408: LD_INT 117
95410: PUSH
95411: LD_INT 118
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: ST_TO_ADDR
95437: GO 96892
95439: LD_INT 13
95441: DOUBLE
95442: EQUAL
95443: IFTRUE 95447
95445: GO 95655
95447: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95448: LD_ADDR_VAR 0 2
95452: PUSH
95453: LD_INT 1
95455: PUSH
95456: LD_INT 2
95458: PUSH
95459: LD_INT 3
95461: PUSH
95462: LD_INT 4
95464: PUSH
95465: LD_INT 5
95467: PUSH
95468: LD_INT 8
95470: PUSH
95471: LD_INT 9
95473: PUSH
95474: LD_INT 10
95476: PUSH
95477: LD_INT 11
95479: PUSH
95480: LD_INT 12
95482: PUSH
95483: LD_INT 14
95485: PUSH
95486: LD_INT 15
95488: PUSH
95489: LD_INT 16
95491: PUSH
95492: LD_INT 17
95494: PUSH
95495: LD_INT 18
95497: PUSH
95498: LD_INT 19
95500: PUSH
95501: LD_INT 20
95503: PUSH
95504: LD_INT 21
95506: PUSH
95507: LD_INT 22
95509: PUSH
95510: LD_INT 23
95512: PUSH
95513: LD_INT 24
95515: PUSH
95516: LD_INT 25
95518: PUSH
95519: LD_INT 26
95521: PUSH
95522: LD_INT 27
95524: PUSH
95525: LD_INT 28
95527: PUSH
95528: LD_INT 30
95530: PUSH
95531: LD_INT 31
95533: PUSH
95534: LD_INT 32
95536: PUSH
95537: LD_INT 33
95539: PUSH
95540: LD_INT 34
95542: PUSH
95543: LD_INT 36
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 101
95581: PUSH
95582: LD_INT 102
95584: PUSH
95585: LD_INT 103
95587: PUSH
95588: LD_INT 104
95590: PUSH
95591: LD_INT 105
95593: PUSH
95594: LD_INT 106
95596: PUSH
95597: LD_INT 107
95599: PUSH
95600: LD_INT 108
95602: PUSH
95603: LD_INT 109
95605: PUSH
95606: LD_INT 110
95608: PUSH
95609: LD_INT 111
95611: PUSH
95612: LD_INT 112
95614: PUSH
95615: LD_INT 113
95617: PUSH
95618: LD_INT 114
95620: PUSH
95621: LD_INT 116
95623: PUSH
95624: LD_INT 117
95626: PUSH
95627: LD_INT 118
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: ST_TO_ADDR
95653: GO 96892
95655: LD_INT 14
95657: DOUBLE
95658: EQUAL
95659: IFTRUE 95663
95661: GO 95887
95663: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95664: LD_ADDR_VAR 0 2
95668: PUSH
95669: LD_INT 1
95671: PUSH
95672: LD_INT 2
95674: PUSH
95675: LD_INT 3
95677: PUSH
95678: LD_INT 4
95680: PUSH
95681: LD_INT 5
95683: PUSH
95684: LD_INT 6
95686: PUSH
95687: LD_INT 7
95689: PUSH
95690: LD_INT 8
95692: PUSH
95693: LD_INT 9
95695: PUSH
95696: LD_INT 10
95698: PUSH
95699: LD_INT 11
95701: PUSH
95702: LD_INT 12
95704: PUSH
95705: LD_INT 13
95707: PUSH
95708: LD_INT 14
95710: PUSH
95711: LD_INT 15
95713: PUSH
95714: LD_INT 16
95716: PUSH
95717: LD_INT 17
95719: PUSH
95720: LD_INT 18
95722: PUSH
95723: LD_INT 19
95725: PUSH
95726: LD_INT 20
95728: PUSH
95729: LD_INT 21
95731: PUSH
95732: LD_INT 22
95734: PUSH
95735: LD_INT 23
95737: PUSH
95738: LD_INT 24
95740: PUSH
95741: LD_INT 25
95743: PUSH
95744: LD_INT 26
95746: PUSH
95747: LD_INT 27
95749: PUSH
95750: LD_INT 28
95752: PUSH
95753: LD_INT 29
95755: PUSH
95756: LD_INT 30
95758: PUSH
95759: LD_INT 31
95761: PUSH
95762: LD_INT 32
95764: PUSH
95765: LD_INT 33
95767: PUSH
95768: LD_INT 34
95770: PUSH
95771: LD_INT 36
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 101
95813: PUSH
95814: LD_INT 102
95816: PUSH
95817: LD_INT 103
95819: PUSH
95820: LD_INT 104
95822: PUSH
95823: LD_INT 105
95825: PUSH
95826: LD_INT 106
95828: PUSH
95829: LD_INT 107
95831: PUSH
95832: LD_INT 108
95834: PUSH
95835: LD_INT 109
95837: PUSH
95838: LD_INT 110
95840: PUSH
95841: LD_INT 111
95843: PUSH
95844: LD_INT 112
95846: PUSH
95847: LD_INT 113
95849: PUSH
95850: LD_INT 114
95852: PUSH
95853: LD_INT 116
95855: PUSH
95856: LD_INT 117
95858: PUSH
95859: LD_INT 118
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: ST_TO_ADDR
95885: GO 96892
95887: LD_INT 15
95889: DOUBLE
95890: EQUAL
95891: IFTRUE 95895
95893: GO 96119
95895: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95896: LD_ADDR_VAR 0 2
95900: PUSH
95901: LD_INT 1
95903: PUSH
95904: LD_INT 2
95906: PUSH
95907: LD_INT 3
95909: PUSH
95910: LD_INT 4
95912: PUSH
95913: LD_INT 5
95915: PUSH
95916: LD_INT 6
95918: PUSH
95919: LD_INT 7
95921: PUSH
95922: LD_INT 8
95924: PUSH
95925: LD_INT 9
95927: PUSH
95928: LD_INT 10
95930: PUSH
95931: LD_INT 11
95933: PUSH
95934: LD_INT 12
95936: PUSH
95937: LD_INT 13
95939: PUSH
95940: LD_INT 14
95942: PUSH
95943: LD_INT 15
95945: PUSH
95946: LD_INT 16
95948: PUSH
95949: LD_INT 17
95951: PUSH
95952: LD_INT 18
95954: PUSH
95955: LD_INT 19
95957: PUSH
95958: LD_INT 20
95960: PUSH
95961: LD_INT 21
95963: PUSH
95964: LD_INT 22
95966: PUSH
95967: LD_INT 23
95969: PUSH
95970: LD_INT 24
95972: PUSH
95973: LD_INT 25
95975: PUSH
95976: LD_INT 26
95978: PUSH
95979: LD_INT 27
95981: PUSH
95982: LD_INT 28
95984: PUSH
95985: LD_INT 29
95987: PUSH
95988: LD_INT 30
95990: PUSH
95991: LD_INT 31
95993: PUSH
95994: LD_INT 32
95996: PUSH
95997: LD_INT 33
95999: PUSH
96000: LD_INT 34
96002: PUSH
96003: LD_INT 36
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: PUSH
96043: LD_INT 101
96045: PUSH
96046: LD_INT 102
96048: PUSH
96049: LD_INT 103
96051: PUSH
96052: LD_INT 104
96054: PUSH
96055: LD_INT 105
96057: PUSH
96058: LD_INT 106
96060: PUSH
96061: LD_INT 107
96063: PUSH
96064: LD_INT 108
96066: PUSH
96067: LD_INT 109
96069: PUSH
96070: LD_INT 110
96072: PUSH
96073: LD_INT 111
96075: PUSH
96076: LD_INT 112
96078: PUSH
96079: LD_INT 113
96081: PUSH
96082: LD_INT 114
96084: PUSH
96085: LD_INT 116
96087: PUSH
96088: LD_INT 117
96090: PUSH
96091: LD_INT 118
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: ST_TO_ADDR
96117: GO 96892
96119: LD_INT 16
96121: DOUBLE
96122: EQUAL
96123: IFTRUE 96127
96125: GO 96263
96127: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96128: LD_ADDR_VAR 0 2
96132: PUSH
96133: LD_INT 2
96135: PUSH
96136: LD_INT 4
96138: PUSH
96139: LD_INT 5
96141: PUSH
96142: LD_INT 7
96144: PUSH
96145: LD_INT 11
96147: PUSH
96148: LD_INT 12
96150: PUSH
96151: LD_INT 15
96153: PUSH
96154: LD_INT 16
96156: PUSH
96157: LD_INT 20
96159: PUSH
96160: LD_INT 21
96162: PUSH
96163: LD_INT 22
96165: PUSH
96166: LD_INT 23
96168: PUSH
96169: LD_INT 25
96171: PUSH
96172: LD_INT 26
96174: PUSH
96175: LD_INT 30
96177: PUSH
96178: LD_INT 31
96180: PUSH
96181: LD_INT 32
96183: PUSH
96184: LD_INT 33
96186: PUSH
96187: LD_INT 34
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 101
96213: PUSH
96214: LD_INT 102
96216: PUSH
96217: LD_INT 103
96219: PUSH
96220: LD_INT 106
96222: PUSH
96223: LD_INT 108
96225: PUSH
96226: LD_INT 112
96228: PUSH
96229: LD_INT 113
96231: PUSH
96232: LD_INT 114
96234: PUSH
96235: LD_INT 116
96237: PUSH
96238: LD_INT 117
96240: PUSH
96241: LD_INT 118
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: ST_TO_ADDR
96261: GO 96892
96263: LD_INT 17
96265: DOUBLE
96266: EQUAL
96267: IFTRUE 96271
96269: GO 96495
96271: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96272: LD_ADDR_VAR 0 2
96276: PUSH
96277: LD_INT 1
96279: PUSH
96280: LD_INT 2
96282: PUSH
96283: LD_INT 3
96285: PUSH
96286: LD_INT 4
96288: PUSH
96289: LD_INT 5
96291: PUSH
96292: LD_INT 6
96294: PUSH
96295: LD_INT 7
96297: PUSH
96298: LD_INT 8
96300: PUSH
96301: LD_INT 9
96303: PUSH
96304: LD_INT 10
96306: PUSH
96307: LD_INT 11
96309: PUSH
96310: LD_INT 12
96312: PUSH
96313: LD_INT 13
96315: PUSH
96316: LD_INT 14
96318: PUSH
96319: LD_INT 15
96321: PUSH
96322: LD_INT 16
96324: PUSH
96325: LD_INT 17
96327: PUSH
96328: LD_INT 18
96330: PUSH
96331: LD_INT 19
96333: PUSH
96334: LD_INT 20
96336: PUSH
96337: LD_INT 21
96339: PUSH
96340: LD_INT 22
96342: PUSH
96343: LD_INT 23
96345: PUSH
96346: LD_INT 24
96348: PUSH
96349: LD_INT 25
96351: PUSH
96352: LD_INT 26
96354: PUSH
96355: LD_INT 27
96357: PUSH
96358: LD_INT 28
96360: PUSH
96361: LD_INT 29
96363: PUSH
96364: LD_INT 30
96366: PUSH
96367: LD_INT 31
96369: PUSH
96370: LD_INT 32
96372: PUSH
96373: LD_INT 33
96375: PUSH
96376: LD_INT 34
96378: PUSH
96379: LD_INT 36
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: PUSH
96419: LD_INT 101
96421: PUSH
96422: LD_INT 102
96424: PUSH
96425: LD_INT 103
96427: PUSH
96428: LD_INT 104
96430: PUSH
96431: LD_INT 105
96433: PUSH
96434: LD_INT 106
96436: PUSH
96437: LD_INT 107
96439: PUSH
96440: LD_INT 108
96442: PUSH
96443: LD_INT 109
96445: PUSH
96446: LD_INT 110
96448: PUSH
96449: LD_INT 111
96451: PUSH
96452: LD_INT 112
96454: PUSH
96455: LD_INT 113
96457: PUSH
96458: LD_INT 114
96460: PUSH
96461: LD_INT 116
96463: PUSH
96464: LD_INT 117
96466: PUSH
96467: LD_INT 118
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: ST_TO_ADDR
96493: GO 96892
96495: LD_INT 18
96497: DOUBLE
96498: EQUAL
96499: IFTRUE 96503
96501: GO 96651
96503: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96504: LD_ADDR_VAR 0 2
96508: PUSH
96509: LD_INT 2
96511: PUSH
96512: LD_INT 4
96514: PUSH
96515: LD_INT 5
96517: PUSH
96518: LD_INT 7
96520: PUSH
96521: LD_INT 11
96523: PUSH
96524: LD_INT 12
96526: PUSH
96527: LD_INT 15
96529: PUSH
96530: LD_INT 16
96532: PUSH
96533: LD_INT 20
96535: PUSH
96536: LD_INT 21
96538: PUSH
96539: LD_INT 22
96541: PUSH
96542: LD_INT 23
96544: PUSH
96545: LD_INT 25
96547: PUSH
96548: LD_INT 26
96550: PUSH
96551: LD_INT 30
96553: PUSH
96554: LD_INT 31
96556: PUSH
96557: LD_INT 32
96559: PUSH
96560: LD_INT 33
96562: PUSH
96563: LD_INT 34
96565: PUSH
96566: LD_INT 35
96568: PUSH
96569: LD_INT 36
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 101
96597: PUSH
96598: LD_INT 102
96600: PUSH
96601: LD_INT 103
96603: PUSH
96604: LD_INT 106
96606: PUSH
96607: LD_INT 108
96609: PUSH
96610: LD_INT 112
96612: PUSH
96613: LD_INT 113
96615: PUSH
96616: LD_INT 114
96618: PUSH
96619: LD_INT 115
96621: PUSH
96622: LD_INT 116
96624: PUSH
96625: LD_INT 117
96627: PUSH
96628: LD_INT 118
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: PUSH
96645: EMPTY
96646: LIST
96647: LIST
96648: ST_TO_ADDR
96649: GO 96892
96651: LD_INT 19
96653: DOUBLE
96654: EQUAL
96655: IFTRUE 96659
96657: GO 96891
96659: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96660: LD_ADDR_VAR 0 2
96664: PUSH
96665: LD_INT 1
96667: PUSH
96668: LD_INT 2
96670: PUSH
96671: LD_INT 3
96673: PUSH
96674: LD_INT 4
96676: PUSH
96677: LD_INT 5
96679: PUSH
96680: LD_INT 6
96682: PUSH
96683: LD_INT 7
96685: PUSH
96686: LD_INT 8
96688: PUSH
96689: LD_INT 9
96691: PUSH
96692: LD_INT 10
96694: PUSH
96695: LD_INT 11
96697: PUSH
96698: LD_INT 12
96700: PUSH
96701: LD_INT 13
96703: PUSH
96704: LD_INT 14
96706: PUSH
96707: LD_INT 15
96709: PUSH
96710: LD_INT 16
96712: PUSH
96713: LD_INT 17
96715: PUSH
96716: LD_INT 18
96718: PUSH
96719: LD_INT 19
96721: PUSH
96722: LD_INT 20
96724: PUSH
96725: LD_INT 21
96727: PUSH
96728: LD_INT 22
96730: PUSH
96731: LD_INT 23
96733: PUSH
96734: LD_INT 24
96736: PUSH
96737: LD_INT 25
96739: PUSH
96740: LD_INT 26
96742: PUSH
96743: LD_INT 27
96745: PUSH
96746: LD_INT 28
96748: PUSH
96749: LD_INT 29
96751: PUSH
96752: LD_INT 30
96754: PUSH
96755: LD_INT 31
96757: PUSH
96758: LD_INT 32
96760: PUSH
96761: LD_INT 33
96763: PUSH
96764: LD_INT 34
96766: PUSH
96767: LD_INT 35
96769: PUSH
96770: LD_INT 36
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: PUSH
96811: LD_INT 101
96813: PUSH
96814: LD_INT 102
96816: PUSH
96817: LD_INT 103
96819: PUSH
96820: LD_INT 104
96822: PUSH
96823: LD_INT 105
96825: PUSH
96826: LD_INT 106
96828: PUSH
96829: LD_INT 107
96831: PUSH
96832: LD_INT 108
96834: PUSH
96835: LD_INT 109
96837: PUSH
96838: LD_INT 110
96840: PUSH
96841: LD_INT 111
96843: PUSH
96844: LD_INT 112
96846: PUSH
96847: LD_INT 113
96849: PUSH
96850: LD_INT 114
96852: PUSH
96853: LD_INT 115
96855: PUSH
96856: LD_INT 116
96858: PUSH
96859: LD_INT 117
96861: PUSH
96862: LD_INT 118
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: ST_TO_ADDR
96889: GO 96892
96891: POP
// end else
96892: GO 97123
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96894: LD_ADDR_VAR 0 2
96898: PUSH
96899: LD_INT 1
96901: PUSH
96902: LD_INT 2
96904: PUSH
96905: LD_INT 3
96907: PUSH
96908: LD_INT 4
96910: PUSH
96911: LD_INT 5
96913: PUSH
96914: LD_INT 6
96916: PUSH
96917: LD_INT 7
96919: PUSH
96920: LD_INT 8
96922: PUSH
96923: LD_INT 9
96925: PUSH
96926: LD_INT 10
96928: PUSH
96929: LD_INT 11
96931: PUSH
96932: LD_INT 12
96934: PUSH
96935: LD_INT 13
96937: PUSH
96938: LD_INT 14
96940: PUSH
96941: LD_INT 15
96943: PUSH
96944: LD_INT 16
96946: PUSH
96947: LD_INT 17
96949: PUSH
96950: LD_INT 18
96952: PUSH
96953: LD_INT 19
96955: PUSH
96956: LD_INT 20
96958: PUSH
96959: LD_INT 21
96961: PUSH
96962: LD_INT 22
96964: PUSH
96965: LD_INT 23
96967: PUSH
96968: LD_INT 24
96970: PUSH
96971: LD_INT 25
96973: PUSH
96974: LD_INT 26
96976: PUSH
96977: LD_INT 27
96979: PUSH
96980: LD_INT 28
96982: PUSH
96983: LD_INT 29
96985: PUSH
96986: LD_INT 30
96988: PUSH
96989: LD_INT 31
96991: PUSH
96992: LD_INT 32
96994: PUSH
96995: LD_INT 33
96997: PUSH
96998: LD_INT 34
97000: PUSH
97001: LD_INT 35
97003: PUSH
97004: LD_INT 36
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 101
97047: PUSH
97048: LD_INT 102
97050: PUSH
97051: LD_INT 103
97053: PUSH
97054: LD_INT 104
97056: PUSH
97057: LD_INT 105
97059: PUSH
97060: LD_INT 106
97062: PUSH
97063: LD_INT 107
97065: PUSH
97066: LD_INT 108
97068: PUSH
97069: LD_INT 109
97071: PUSH
97072: LD_INT 110
97074: PUSH
97075: LD_INT 111
97077: PUSH
97078: LD_INT 112
97080: PUSH
97081: LD_INT 113
97083: PUSH
97084: LD_INT 114
97086: PUSH
97087: LD_INT 115
97089: PUSH
97090: LD_INT 116
97092: PUSH
97093: LD_INT 117
97095: PUSH
97096: LD_INT 118
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: ST_TO_ADDR
// if result then
97123: LD_VAR 0 2
97127: IFFALSE 97913
// begin normal :=  ;
97129: LD_ADDR_VAR 0 5
97133: PUSH
97134: LD_STRING 
97136: ST_TO_ADDR
// hardcore :=  ;
97137: LD_ADDR_VAR 0 6
97141: PUSH
97142: LD_STRING 
97144: ST_TO_ADDR
// active :=  ;
97145: LD_ADDR_VAR 0 7
97149: PUSH
97150: LD_STRING 
97152: ST_TO_ADDR
// for i = 1 to normalCounter do
97153: LD_ADDR_VAR 0 8
97157: PUSH
97158: DOUBLE
97159: LD_INT 1
97161: DEC
97162: ST_TO_ADDR
97163: LD_EXP 97
97167: PUSH
97168: FOR_TO
97169: IFFALSE 97270
// begin tmp := 0 ;
97171: LD_ADDR_VAR 0 3
97175: PUSH
97176: LD_STRING 0
97178: ST_TO_ADDR
// if result [ 1 ] then
97179: LD_VAR 0 2
97183: PUSH
97184: LD_INT 1
97186: ARRAY
97187: IFFALSE 97252
// if result [ 1 ] [ 1 ] = i then
97189: LD_VAR 0 2
97193: PUSH
97194: LD_INT 1
97196: ARRAY
97197: PUSH
97198: LD_INT 1
97200: ARRAY
97201: PUSH
97202: LD_VAR 0 8
97206: EQUAL
97207: IFFALSE 97252
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97209: LD_ADDR_VAR 0 2
97213: PUSH
97214: LD_VAR 0 2
97218: PPUSH
97219: LD_INT 1
97221: PPUSH
97222: LD_VAR 0 2
97226: PUSH
97227: LD_INT 1
97229: ARRAY
97230: PPUSH
97231: LD_INT 1
97233: PPUSH
97234: CALL_OW 3
97238: PPUSH
97239: CALL_OW 1
97243: ST_TO_ADDR
// tmp := 1 ;
97244: LD_ADDR_VAR 0 3
97248: PUSH
97249: LD_STRING 1
97251: ST_TO_ADDR
// end ; normal := normal & tmp ;
97252: LD_ADDR_VAR 0 5
97256: PUSH
97257: LD_VAR 0 5
97261: PUSH
97262: LD_VAR 0 3
97266: STR
97267: ST_TO_ADDR
// end ;
97268: GO 97168
97270: POP
97271: POP
// for i = 1 to hardcoreCounter do
97272: LD_ADDR_VAR 0 8
97276: PUSH
97277: DOUBLE
97278: LD_INT 1
97280: DEC
97281: ST_TO_ADDR
97282: LD_EXP 98
97286: PUSH
97287: FOR_TO
97288: IFFALSE 97393
// begin tmp := 0 ;
97290: LD_ADDR_VAR 0 3
97294: PUSH
97295: LD_STRING 0
97297: ST_TO_ADDR
// if result [ 2 ] then
97298: LD_VAR 0 2
97302: PUSH
97303: LD_INT 2
97305: ARRAY
97306: IFFALSE 97375
// if result [ 2 ] [ 1 ] = 100 + i then
97308: LD_VAR 0 2
97312: PUSH
97313: LD_INT 2
97315: ARRAY
97316: PUSH
97317: LD_INT 1
97319: ARRAY
97320: PUSH
97321: LD_INT 100
97323: PUSH
97324: LD_VAR 0 8
97328: PLUS
97329: EQUAL
97330: IFFALSE 97375
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97332: LD_ADDR_VAR 0 2
97336: PUSH
97337: LD_VAR 0 2
97341: PPUSH
97342: LD_INT 2
97344: PPUSH
97345: LD_VAR 0 2
97349: PUSH
97350: LD_INT 2
97352: ARRAY
97353: PPUSH
97354: LD_INT 1
97356: PPUSH
97357: CALL_OW 3
97361: PPUSH
97362: CALL_OW 1
97366: ST_TO_ADDR
// tmp := 1 ;
97367: LD_ADDR_VAR 0 3
97371: PUSH
97372: LD_STRING 1
97374: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97375: LD_ADDR_VAR 0 6
97379: PUSH
97380: LD_VAR 0 6
97384: PUSH
97385: LD_VAR 0 3
97389: STR
97390: ST_TO_ADDR
// end ;
97391: GO 97287
97393: POP
97394: POP
// if isGameLoad then
97395: LD_VAR 0 1
97399: IFFALSE 97874
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97401: LD_ADDR_VAR 0 4
97405: PUSH
97406: LD_EXP 101
97410: PUSH
97411: LD_EXP 100
97415: PUSH
97416: LD_EXP 102
97420: PUSH
97421: LD_EXP 99
97425: PUSH
97426: LD_EXP 103
97430: PUSH
97431: LD_EXP 104
97435: PUSH
97436: LD_EXP 105
97440: PUSH
97441: LD_EXP 106
97445: PUSH
97446: LD_EXP 107
97450: PUSH
97451: LD_EXP 108
97455: PUSH
97456: LD_EXP 109
97460: PUSH
97461: LD_EXP 110
97465: PUSH
97466: LD_EXP 111
97470: PUSH
97471: LD_EXP 112
97475: PUSH
97476: LD_EXP 120
97480: PUSH
97481: LD_EXP 121
97485: PUSH
97486: LD_EXP 122
97490: PUSH
97491: LD_EXP 123
97495: PUSH
97496: LD_EXP 125
97500: PUSH
97501: LD_EXP 126
97505: PUSH
97506: LD_EXP 127
97510: PUSH
97511: LD_EXP 130
97515: PUSH
97516: LD_EXP 132
97520: PUSH
97521: LD_EXP 133
97525: PUSH
97526: LD_EXP 134
97530: PUSH
97531: LD_EXP 136
97535: PUSH
97536: LD_EXP 137
97540: PUSH
97541: LD_EXP 140
97545: PUSH
97546: LD_EXP 141
97550: PUSH
97551: LD_EXP 142
97555: PUSH
97556: LD_EXP 143
97560: PUSH
97561: LD_EXP 144
97565: PUSH
97566: LD_EXP 145
97570: PUSH
97571: LD_EXP 146
97575: PUSH
97576: LD_EXP 147
97580: PUSH
97581: LD_EXP 148
97585: PUSH
97586: LD_EXP 113
97590: PUSH
97591: LD_EXP 114
97595: PUSH
97596: LD_EXP 117
97600: PUSH
97601: LD_EXP 118
97605: PUSH
97606: LD_EXP 119
97610: PUSH
97611: LD_EXP 115
97615: PUSH
97616: LD_EXP 116
97620: PUSH
97621: LD_EXP 124
97625: PUSH
97626: LD_EXP 128
97630: PUSH
97631: LD_EXP 129
97635: PUSH
97636: LD_EXP 131
97640: PUSH
97641: LD_EXP 135
97645: PUSH
97646: LD_EXP 138
97650: PUSH
97651: LD_EXP 139
97655: PUSH
97656: LD_EXP 149
97660: PUSH
97661: LD_EXP 150
97665: PUSH
97666: LD_EXP 151
97670: PUSH
97671: LD_EXP 152
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: ST_TO_ADDR
// tmp :=  ;
97732: LD_ADDR_VAR 0 3
97736: PUSH
97737: LD_STRING 
97739: ST_TO_ADDR
// for i = 1 to normalCounter do
97740: LD_ADDR_VAR 0 8
97744: PUSH
97745: DOUBLE
97746: LD_INT 1
97748: DEC
97749: ST_TO_ADDR
97750: LD_EXP 97
97754: PUSH
97755: FOR_TO
97756: IFFALSE 97792
// begin if flags [ i ] then
97758: LD_VAR 0 4
97762: PUSH
97763: LD_VAR 0 8
97767: ARRAY
97768: IFFALSE 97790
// tmp := tmp & i & ; ;
97770: LD_ADDR_VAR 0 3
97774: PUSH
97775: LD_VAR 0 3
97779: PUSH
97780: LD_VAR 0 8
97784: STR
97785: PUSH
97786: LD_STRING ;
97788: STR
97789: ST_TO_ADDR
// end ;
97790: GO 97755
97792: POP
97793: POP
// for i = 1 to hardcoreCounter do
97794: LD_ADDR_VAR 0 8
97798: PUSH
97799: DOUBLE
97800: LD_INT 1
97802: DEC
97803: ST_TO_ADDR
97804: LD_EXP 98
97808: PUSH
97809: FOR_TO
97810: IFFALSE 97856
// begin if flags [ normalCounter + i ] then
97812: LD_VAR 0 4
97816: PUSH
97817: LD_EXP 97
97821: PUSH
97822: LD_VAR 0 8
97826: PLUS
97827: ARRAY
97828: IFFALSE 97854
// tmp := tmp & ( 100 + i ) & ; ;
97830: LD_ADDR_VAR 0 3
97834: PUSH
97835: LD_VAR 0 3
97839: PUSH
97840: LD_INT 100
97842: PUSH
97843: LD_VAR 0 8
97847: PLUS
97848: STR
97849: PUSH
97850: LD_STRING ;
97852: STR
97853: ST_TO_ADDR
// end ;
97854: GO 97809
97856: POP
97857: POP
// if tmp then
97858: LD_VAR 0 3
97862: IFFALSE 97874
// active := tmp ;
97864: LD_ADDR_VAR 0 7
97868: PUSH
97869: LD_VAR 0 3
97873: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97874: LD_STRING getStreamItemsFromMission("
97876: PUSH
97877: LD_VAR 0 5
97881: STR
97882: PUSH
97883: LD_STRING ","
97885: STR
97886: PUSH
97887: LD_VAR 0 6
97891: STR
97892: PUSH
97893: LD_STRING ","
97895: STR
97896: PUSH
97897: LD_VAR 0 7
97901: STR
97902: PUSH
97903: LD_STRING ")
97905: STR
97906: PPUSH
97907: CALL_OW 559
// end else
97911: GO 97920
// ToLua ( getStreamItemsFromMission("","","") ) ;
97913: LD_STRING getStreamItemsFromMission("","","")
97915: PPUSH
97916: CALL_OW 559
// end ;
97920: LD_VAR 0 2
97924: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97925: LD_EXP 96
97929: PUSH
97930: LD_EXP 101
97934: AND
97935: IFFALSE 98059
97937: GO 97939
97939: DISABLE
97940: LD_INT 0
97942: PPUSH
97943: PPUSH
// begin enable ;
97944: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97945: LD_ADDR_VAR 0 2
97949: PUSH
97950: LD_INT 22
97952: PUSH
97953: LD_OWVAR 2
97957: PUSH
97958: EMPTY
97959: LIST
97960: LIST
97961: PUSH
97962: LD_INT 2
97964: PUSH
97965: LD_INT 34
97967: PUSH
97968: LD_INT 7
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: PUSH
97975: LD_INT 34
97977: PUSH
97978: LD_INT 45
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 34
97987: PUSH
97988: LD_INT 28
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 34
97997: PUSH
97998: LD_INT 47
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: PUSH
98012: EMPTY
98013: LIST
98014: LIST
98015: PPUSH
98016: CALL_OW 69
98020: ST_TO_ADDR
// if not tmp then
98021: LD_VAR 0 2
98025: NOT
98026: IFFALSE 98030
// exit ;
98028: GO 98059
// for i in tmp do
98030: LD_ADDR_VAR 0 1
98034: PUSH
98035: LD_VAR 0 2
98039: PUSH
98040: FOR_IN
98041: IFFALSE 98057
// begin SetLives ( i , 0 ) ;
98043: LD_VAR 0 1
98047: PPUSH
98048: LD_INT 0
98050: PPUSH
98051: CALL_OW 234
// end ;
98055: GO 98040
98057: POP
98058: POP
// end ;
98059: PPOPN 2
98061: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98062: LD_EXP 96
98066: PUSH
98067: LD_EXP 102
98071: AND
98072: IFFALSE 98156
98074: GO 98076
98076: DISABLE
98077: LD_INT 0
98079: PPUSH
98080: PPUSH
// begin enable ;
98081: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98082: LD_ADDR_VAR 0 2
98086: PUSH
98087: LD_INT 22
98089: PUSH
98090: LD_OWVAR 2
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 32
98101: PUSH
98102: LD_INT 3
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: PPUSH
98113: CALL_OW 69
98117: ST_TO_ADDR
// if not tmp then
98118: LD_VAR 0 2
98122: NOT
98123: IFFALSE 98127
// exit ;
98125: GO 98156
// for i in tmp do
98127: LD_ADDR_VAR 0 1
98131: PUSH
98132: LD_VAR 0 2
98136: PUSH
98137: FOR_IN
98138: IFFALSE 98154
// begin SetLives ( i , 0 ) ;
98140: LD_VAR 0 1
98144: PPUSH
98145: LD_INT 0
98147: PPUSH
98148: CALL_OW 234
// end ;
98152: GO 98137
98154: POP
98155: POP
// end ;
98156: PPOPN 2
98158: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98159: LD_EXP 96
98163: PUSH
98164: LD_EXP 99
98168: AND
98169: IFFALSE 98262
98171: GO 98173
98173: DISABLE
98174: LD_INT 0
98176: PPUSH
// begin enable ;
98177: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98178: LD_ADDR_VAR 0 1
98182: PUSH
98183: LD_INT 22
98185: PUSH
98186: LD_OWVAR 2
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 2
98197: PUSH
98198: LD_INT 25
98200: PUSH
98201: LD_INT 5
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: PUSH
98208: LD_INT 25
98210: PUSH
98211: LD_INT 9
98213: PUSH
98214: EMPTY
98215: LIST
98216: LIST
98217: PUSH
98218: LD_INT 25
98220: PUSH
98221: LD_INT 8
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: PUSH
98228: EMPTY
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: PUSH
98234: EMPTY
98235: LIST
98236: LIST
98237: PPUSH
98238: CALL_OW 69
98242: PUSH
98243: FOR_IN
98244: IFFALSE 98260
// begin SetClass ( i , 1 ) ;
98246: LD_VAR 0 1
98250: PPUSH
98251: LD_INT 1
98253: PPUSH
98254: CALL_OW 336
// end ;
98258: GO 98243
98260: POP
98261: POP
// end ;
98262: PPOPN 1
98264: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98265: LD_EXP 96
98269: PUSH
98270: LD_EXP 100
98274: AND
98275: PUSH
98276: LD_OWVAR 65
98280: PUSH
98281: LD_INT 7
98283: LESS
98284: AND
98285: IFFALSE 98299
98287: GO 98289
98289: DISABLE
// begin enable ;
98290: ENABLE
// game_speed := 7 ;
98291: LD_ADDR_OWVAR 65
98295: PUSH
98296: LD_INT 7
98298: ST_TO_ADDR
// end ;
98299: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98300: LD_EXP 96
98304: PUSH
98305: LD_EXP 103
98309: AND
98310: IFFALSE 98512
98312: GO 98314
98314: DISABLE
98315: LD_INT 0
98317: PPUSH
98318: PPUSH
98319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98320: LD_ADDR_VAR 0 3
98324: PUSH
98325: LD_INT 81
98327: PUSH
98328: LD_OWVAR 2
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PUSH
98337: LD_INT 21
98339: PUSH
98340: LD_INT 1
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PPUSH
98351: CALL_OW 69
98355: ST_TO_ADDR
// if not tmp then
98356: LD_VAR 0 3
98360: NOT
98361: IFFALSE 98365
// exit ;
98363: GO 98512
// if tmp > 5 then
98365: LD_VAR 0 3
98369: PUSH
98370: LD_INT 5
98372: GREATER
98373: IFFALSE 98385
// k := 5 else
98375: LD_ADDR_VAR 0 2
98379: PUSH
98380: LD_INT 5
98382: ST_TO_ADDR
98383: GO 98395
// k := tmp ;
98385: LD_ADDR_VAR 0 2
98389: PUSH
98390: LD_VAR 0 3
98394: ST_TO_ADDR
// for i := 1 to k do
98395: LD_ADDR_VAR 0 1
98399: PUSH
98400: DOUBLE
98401: LD_INT 1
98403: DEC
98404: ST_TO_ADDR
98405: LD_VAR 0 2
98409: PUSH
98410: FOR_TO
98411: IFFALSE 98510
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98413: LD_VAR 0 3
98417: PUSH
98418: LD_VAR 0 1
98422: ARRAY
98423: PPUSH
98424: LD_VAR 0 1
98428: PUSH
98429: LD_INT 4
98431: MOD
98432: PUSH
98433: LD_INT 1
98435: PLUS
98436: PPUSH
98437: CALL_OW 259
98441: PUSH
98442: LD_INT 10
98444: LESS
98445: IFFALSE 98508
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98447: LD_VAR 0 3
98451: PUSH
98452: LD_VAR 0 1
98456: ARRAY
98457: PPUSH
98458: LD_VAR 0 1
98462: PUSH
98463: LD_INT 4
98465: MOD
98466: PUSH
98467: LD_INT 1
98469: PLUS
98470: PPUSH
98471: LD_VAR 0 3
98475: PUSH
98476: LD_VAR 0 1
98480: ARRAY
98481: PPUSH
98482: LD_VAR 0 1
98486: PUSH
98487: LD_INT 4
98489: MOD
98490: PUSH
98491: LD_INT 1
98493: PLUS
98494: PPUSH
98495: CALL_OW 259
98499: PUSH
98500: LD_INT 1
98502: PLUS
98503: PPUSH
98504: CALL_OW 237
98508: GO 98410
98510: POP
98511: POP
// end ;
98512: PPOPN 3
98514: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98515: LD_EXP 96
98519: PUSH
98520: LD_EXP 104
98524: AND
98525: IFFALSE 98545
98527: GO 98529
98529: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98530: LD_INT 4
98532: PPUSH
98533: LD_OWVAR 2
98537: PPUSH
98538: LD_INT 0
98540: PPUSH
98541: CALL_OW 324
98545: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98546: LD_EXP 96
98550: PUSH
98551: LD_EXP 133
98555: AND
98556: IFFALSE 98576
98558: GO 98560
98560: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98561: LD_INT 19
98563: PPUSH
98564: LD_OWVAR 2
98568: PPUSH
98569: LD_INT 0
98571: PPUSH
98572: CALL_OW 324
98576: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98577: LD_EXP 96
98581: PUSH
98582: LD_EXP 105
98586: AND
98587: IFFALSE 98689
98589: GO 98591
98591: DISABLE
98592: LD_INT 0
98594: PPUSH
98595: PPUSH
// begin enable ;
98596: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98597: LD_ADDR_VAR 0 2
98601: PUSH
98602: LD_INT 22
98604: PUSH
98605: LD_OWVAR 2
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: LD_INT 2
98616: PUSH
98617: LD_INT 34
98619: PUSH
98620: LD_INT 11
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: PUSH
98627: LD_INT 34
98629: PUSH
98630: LD_INT 30
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: LIST
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PPUSH
98646: CALL_OW 69
98650: ST_TO_ADDR
// if not tmp then
98651: LD_VAR 0 2
98655: NOT
98656: IFFALSE 98660
// exit ;
98658: GO 98689
// for i in tmp do
98660: LD_ADDR_VAR 0 1
98664: PUSH
98665: LD_VAR 0 2
98669: PUSH
98670: FOR_IN
98671: IFFALSE 98687
// begin SetLives ( i , 0 ) ;
98673: LD_VAR 0 1
98677: PPUSH
98678: LD_INT 0
98680: PPUSH
98681: CALL_OW 234
// end ;
98685: GO 98670
98687: POP
98688: POP
// end ;
98689: PPOPN 2
98691: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98692: LD_EXP 96
98696: PUSH
98697: LD_EXP 106
98701: AND
98702: IFFALSE 98722
98704: GO 98706
98706: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98707: LD_INT 32
98709: PPUSH
98710: LD_OWVAR 2
98714: PPUSH
98715: LD_INT 0
98717: PPUSH
98718: CALL_OW 324
98722: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98723: LD_EXP 96
98727: PUSH
98728: LD_EXP 107
98732: AND
98733: IFFALSE 98914
98735: GO 98737
98737: DISABLE
98738: LD_INT 0
98740: PPUSH
98741: PPUSH
98742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98743: LD_ADDR_VAR 0 2
98747: PUSH
98748: LD_INT 22
98750: PUSH
98751: LD_OWVAR 2
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 33
98762: PUSH
98763: LD_INT 3
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PPUSH
98774: CALL_OW 69
98778: ST_TO_ADDR
// if not tmp then
98779: LD_VAR 0 2
98783: NOT
98784: IFFALSE 98788
// exit ;
98786: GO 98914
// side := 0 ;
98788: LD_ADDR_VAR 0 3
98792: PUSH
98793: LD_INT 0
98795: ST_TO_ADDR
// for i := 1 to 8 do
98796: LD_ADDR_VAR 0 1
98800: PUSH
98801: DOUBLE
98802: LD_INT 1
98804: DEC
98805: ST_TO_ADDR
98806: LD_INT 8
98808: PUSH
98809: FOR_TO
98810: IFFALSE 98858
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98812: LD_OWVAR 2
98816: PUSH
98817: LD_VAR 0 1
98821: NONEQUAL
98822: PUSH
98823: LD_OWVAR 2
98827: PPUSH
98828: LD_VAR 0 1
98832: PPUSH
98833: CALL_OW 81
98837: PUSH
98838: LD_INT 2
98840: EQUAL
98841: AND
98842: IFFALSE 98856
// begin side := i ;
98844: LD_ADDR_VAR 0 3
98848: PUSH
98849: LD_VAR 0 1
98853: ST_TO_ADDR
// break ;
98854: GO 98858
// end ;
98856: GO 98809
98858: POP
98859: POP
// if not side then
98860: LD_VAR 0 3
98864: NOT
98865: IFFALSE 98869
// exit ;
98867: GO 98914
// for i := 1 to tmp do
98869: LD_ADDR_VAR 0 1
98873: PUSH
98874: DOUBLE
98875: LD_INT 1
98877: DEC
98878: ST_TO_ADDR
98879: LD_VAR 0 2
98883: PUSH
98884: FOR_TO
98885: IFFALSE 98912
// if Prob ( 60 ) then
98887: LD_INT 60
98889: PPUSH
98890: CALL_OW 13
98894: IFFALSE 98910
// SetSide ( i , side ) ;
98896: LD_VAR 0 1
98900: PPUSH
98901: LD_VAR 0 3
98905: PPUSH
98906: CALL_OW 235
98910: GO 98884
98912: POP
98913: POP
// end ;
98914: PPOPN 3
98916: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98917: LD_EXP 96
98921: PUSH
98922: LD_EXP 109
98926: AND
98927: IFFALSE 99046
98929: GO 98931
98931: DISABLE
98932: LD_INT 0
98934: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98935: LD_ADDR_VAR 0 1
98939: PUSH
98940: LD_INT 22
98942: PUSH
98943: LD_OWVAR 2
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: PUSH
98952: LD_INT 21
98954: PUSH
98955: LD_INT 1
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 3
98964: PUSH
98965: LD_INT 23
98967: PUSH
98968: LD_INT 0
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: LIST
98983: PPUSH
98984: CALL_OW 69
98988: PUSH
98989: FOR_IN
98990: IFFALSE 99044
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98992: LD_VAR 0 1
98996: PPUSH
98997: CALL_OW 257
99001: PUSH
99002: LD_INT 1
99004: PUSH
99005: LD_INT 2
99007: PUSH
99008: LD_INT 3
99010: PUSH
99011: LD_INT 4
99013: PUSH
99014: EMPTY
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: IN
99020: IFFALSE 99042
// SetClass ( un , rand ( 1 , 4 ) ) ;
99022: LD_VAR 0 1
99026: PPUSH
99027: LD_INT 1
99029: PPUSH
99030: LD_INT 4
99032: PPUSH
99033: CALL_OW 12
99037: PPUSH
99038: CALL_OW 336
99042: GO 98989
99044: POP
99045: POP
// end ;
99046: PPOPN 1
99048: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99049: LD_EXP 96
99053: PUSH
99054: LD_EXP 108
99058: AND
99059: IFFALSE 99138
99061: GO 99063
99063: DISABLE
99064: LD_INT 0
99066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99067: LD_ADDR_VAR 0 1
99071: PUSH
99072: LD_INT 22
99074: PUSH
99075: LD_OWVAR 2
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: PUSH
99084: LD_INT 21
99086: PUSH
99087: LD_INT 3
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PPUSH
99098: CALL_OW 69
99102: ST_TO_ADDR
// if not tmp then
99103: LD_VAR 0 1
99107: NOT
99108: IFFALSE 99112
// exit ;
99110: GO 99138
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99112: LD_VAR 0 1
99116: PUSH
99117: LD_INT 1
99119: PPUSH
99120: LD_VAR 0 1
99124: PPUSH
99125: CALL_OW 12
99129: ARRAY
99130: PPUSH
99131: LD_INT 100
99133: PPUSH
99134: CALL_OW 234
// end ;
99138: PPOPN 1
99140: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99141: LD_EXP 96
99145: PUSH
99146: LD_EXP 110
99150: AND
99151: IFFALSE 99249
99153: GO 99155
99155: DISABLE
99156: LD_INT 0
99158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99159: LD_ADDR_VAR 0 1
99163: PUSH
99164: LD_INT 22
99166: PUSH
99167: LD_OWVAR 2
99171: PUSH
99172: EMPTY
99173: LIST
99174: LIST
99175: PUSH
99176: LD_INT 21
99178: PUSH
99179: LD_INT 1
99181: PUSH
99182: EMPTY
99183: LIST
99184: LIST
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PPUSH
99190: CALL_OW 69
99194: ST_TO_ADDR
// if not tmp then
99195: LD_VAR 0 1
99199: NOT
99200: IFFALSE 99204
// exit ;
99202: GO 99249
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99204: LD_VAR 0 1
99208: PUSH
99209: LD_INT 1
99211: PPUSH
99212: LD_VAR 0 1
99216: PPUSH
99217: CALL_OW 12
99221: ARRAY
99222: PPUSH
99223: LD_INT 1
99225: PPUSH
99226: LD_INT 4
99228: PPUSH
99229: CALL_OW 12
99233: PPUSH
99234: LD_INT 3000
99236: PPUSH
99237: LD_INT 9000
99239: PPUSH
99240: CALL_OW 12
99244: PPUSH
99245: CALL_OW 492
// end ;
99249: PPOPN 1
99251: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99252: LD_EXP 96
99256: PUSH
99257: LD_EXP 111
99261: AND
99262: IFFALSE 99282
99264: GO 99266
99266: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99267: LD_INT 1
99269: PPUSH
99270: LD_OWVAR 2
99274: PPUSH
99275: LD_INT 0
99277: PPUSH
99278: CALL_OW 324
99282: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99283: LD_EXP 96
99287: PUSH
99288: LD_EXP 112
99292: AND
99293: IFFALSE 99376
99295: GO 99297
99297: DISABLE
99298: LD_INT 0
99300: PPUSH
99301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99302: LD_ADDR_VAR 0 2
99306: PUSH
99307: LD_INT 22
99309: PUSH
99310: LD_OWVAR 2
99314: PUSH
99315: EMPTY
99316: LIST
99317: LIST
99318: PUSH
99319: LD_INT 21
99321: PUSH
99322: LD_INT 3
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PPUSH
99333: CALL_OW 69
99337: ST_TO_ADDR
// if not tmp then
99338: LD_VAR 0 2
99342: NOT
99343: IFFALSE 99347
// exit ;
99345: GO 99376
// for i in tmp do
99347: LD_ADDR_VAR 0 1
99351: PUSH
99352: LD_VAR 0 2
99356: PUSH
99357: FOR_IN
99358: IFFALSE 99374
// SetBLevel ( i , 10 ) ;
99360: LD_VAR 0 1
99364: PPUSH
99365: LD_INT 10
99367: PPUSH
99368: CALL_OW 241
99372: GO 99357
99374: POP
99375: POP
// end ;
99376: PPOPN 2
99378: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99379: LD_EXP 96
99383: PUSH
99384: LD_EXP 113
99388: AND
99389: IFFALSE 99500
99391: GO 99393
99393: DISABLE
99394: LD_INT 0
99396: PPUSH
99397: PPUSH
99398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99399: LD_ADDR_VAR 0 3
99403: PUSH
99404: LD_INT 22
99406: PUSH
99407: LD_OWVAR 2
99411: PUSH
99412: EMPTY
99413: LIST
99414: LIST
99415: PUSH
99416: LD_INT 25
99418: PUSH
99419: LD_INT 1
99421: PUSH
99422: EMPTY
99423: LIST
99424: LIST
99425: PUSH
99426: EMPTY
99427: LIST
99428: LIST
99429: PPUSH
99430: CALL_OW 69
99434: ST_TO_ADDR
// if not tmp then
99435: LD_VAR 0 3
99439: NOT
99440: IFFALSE 99444
// exit ;
99442: GO 99500
// un := tmp [ rand ( 1 , tmp ) ] ;
99444: LD_ADDR_VAR 0 2
99448: PUSH
99449: LD_VAR 0 3
99453: PUSH
99454: LD_INT 1
99456: PPUSH
99457: LD_VAR 0 3
99461: PPUSH
99462: CALL_OW 12
99466: ARRAY
99467: ST_TO_ADDR
// if Crawls ( un ) then
99468: LD_VAR 0 2
99472: PPUSH
99473: CALL_OW 318
99477: IFFALSE 99488
// ComWalk ( un ) ;
99479: LD_VAR 0 2
99483: PPUSH
99484: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99488: LD_VAR 0 2
99492: PPUSH
99493: LD_INT 5
99495: PPUSH
99496: CALL_OW 336
// end ;
99500: PPOPN 3
99502: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99503: LD_EXP 96
99507: PUSH
99508: LD_EXP 114
99512: AND
99513: PUSH
99514: LD_OWVAR 67
99518: PUSH
99519: LD_INT 4
99521: LESS
99522: AND
99523: IFFALSE 99542
99525: GO 99527
99527: DISABLE
// begin Difficulty := Difficulty + 1 ;
99528: LD_ADDR_OWVAR 67
99532: PUSH
99533: LD_OWVAR 67
99537: PUSH
99538: LD_INT 1
99540: PLUS
99541: ST_TO_ADDR
// end ;
99542: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99543: LD_EXP 96
99547: PUSH
99548: LD_EXP 115
99552: AND
99553: IFFALSE 99656
99555: GO 99557
99557: DISABLE
99558: LD_INT 0
99560: PPUSH
// begin for i := 1 to 5 do
99561: LD_ADDR_VAR 0 1
99565: PUSH
99566: DOUBLE
99567: LD_INT 1
99569: DEC
99570: ST_TO_ADDR
99571: LD_INT 5
99573: PUSH
99574: FOR_TO
99575: IFFALSE 99654
// begin uc_nation := nation_nature ;
99577: LD_ADDR_OWVAR 21
99581: PUSH
99582: LD_INT 0
99584: ST_TO_ADDR
// uc_side := 0 ;
99585: LD_ADDR_OWVAR 20
99589: PUSH
99590: LD_INT 0
99592: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99593: LD_ADDR_OWVAR 29
99597: PUSH
99598: LD_INT 12
99600: PUSH
99601: LD_INT 12
99603: PUSH
99604: EMPTY
99605: LIST
99606: LIST
99607: ST_TO_ADDR
// hc_agressivity := 20 ;
99608: LD_ADDR_OWVAR 35
99612: PUSH
99613: LD_INT 20
99615: ST_TO_ADDR
// hc_class := class_tiger ;
99616: LD_ADDR_OWVAR 28
99620: PUSH
99621: LD_INT 14
99623: ST_TO_ADDR
// hc_gallery :=  ;
99624: LD_ADDR_OWVAR 33
99628: PUSH
99629: LD_STRING 
99631: ST_TO_ADDR
// hc_name :=  ;
99632: LD_ADDR_OWVAR 26
99636: PUSH
99637: LD_STRING 
99639: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99640: CALL_OW 44
99644: PPUSH
99645: LD_INT 0
99647: PPUSH
99648: CALL_OW 51
// end ;
99652: GO 99574
99654: POP
99655: POP
// end ;
99656: PPOPN 1
99658: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99659: LD_EXP 96
99663: PUSH
99664: LD_EXP 116
99668: AND
99669: IFFALSE 99678
99671: GO 99673
99673: DISABLE
// StreamSibBomb ;
99674: CALL 99679 0 0
99678: END
// export function StreamSibBomb ; var i , x , y ; begin
99679: LD_INT 0
99681: PPUSH
99682: PPUSH
99683: PPUSH
99684: PPUSH
// result := false ;
99685: LD_ADDR_VAR 0 1
99689: PUSH
99690: LD_INT 0
99692: ST_TO_ADDR
// for i := 1 to 16 do
99693: LD_ADDR_VAR 0 2
99697: PUSH
99698: DOUBLE
99699: LD_INT 1
99701: DEC
99702: ST_TO_ADDR
99703: LD_INT 16
99705: PUSH
99706: FOR_TO
99707: IFFALSE 99906
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99709: LD_ADDR_VAR 0 3
99713: PUSH
99714: LD_INT 10
99716: PUSH
99717: LD_INT 20
99719: PUSH
99720: LD_INT 30
99722: PUSH
99723: LD_INT 40
99725: PUSH
99726: LD_INT 50
99728: PUSH
99729: LD_INT 60
99731: PUSH
99732: LD_INT 70
99734: PUSH
99735: LD_INT 80
99737: PUSH
99738: LD_INT 90
99740: PUSH
99741: LD_INT 100
99743: PUSH
99744: LD_INT 110
99746: PUSH
99747: LD_INT 120
99749: PUSH
99750: LD_INT 130
99752: PUSH
99753: LD_INT 140
99755: PUSH
99756: LD_INT 150
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: LIST
99765: LIST
99766: LIST
99767: LIST
99768: LIST
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: LIST
99775: PUSH
99776: LD_INT 1
99778: PPUSH
99779: LD_INT 15
99781: PPUSH
99782: CALL_OW 12
99786: ARRAY
99787: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99788: LD_ADDR_VAR 0 4
99792: PUSH
99793: LD_INT 10
99795: PUSH
99796: LD_INT 20
99798: PUSH
99799: LD_INT 30
99801: PUSH
99802: LD_INT 40
99804: PUSH
99805: LD_INT 50
99807: PUSH
99808: LD_INT 60
99810: PUSH
99811: LD_INT 70
99813: PUSH
99814: LD_INT 80
99816: PUSH
99817: LD_INT 90
99819: PUSH
99820: LD_INT 100
99822: PUSH
99823: LD_INT 110
99825: PUSH
99826: LD_INT 120
99828: PUSH
99829: LD_INT 130
99831: PUSH
99832: LD_INT 140
99834: PUSH
99835: LD_INT 150
99837: PUSH
99838: EMPTY
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: LIST
99847: LIST
99848: LIST
99849: LIST
99850: LIST
99851: LIST
99852: LIST
99853: LIST
99854: PUSH
99855: LD_INT 1
99857: PPUSH
99858: LD_INT 15
99860: PPUSH
99861: CALL_OW 12
99865: ARRAY
99866: ST_TO_ADDR
// if ValidHex ( x , y ) then
99867: LD_VAR 0 3
99871: PPUSH
99872: LD_VAR 0 4
99876: PPUSH
99877: CALL_OW 488
99881: IFFALSE 99904
// begin result := [ x , y ] ;
99883: LD_ADDR_VAR 0 1
99887: PUSH
99888: LD_VAR 0 3
99892: PUSH
99893: LD_VAR 0 4
99897: PUSH
99898: EMPTY
99899: LIST
99900: LIST
99901: ST_TO_ADDR
// break ;
99902: GO 99906
// end ; end ;
99904: GO 99706
99906: POP
99907: POP
// if result then
99908: LD_VAR 0 1
99912: IFFALSE 99972
// begin ToLua ( playSibBomb() ) ;
99914: LD_STRING playSibBomb()
99916: PPUSH
99917: CALL_OW 559
// wait ( 0 0$14 ) ;
99921: LD_INT 490
99923: PPUSH
99924: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99928: LD_VAR 0 1
99932: PUSH
99933: LD_INT 1
99935: ARRAY
99936: PPUSH
99937: LD_VAR 0 1
99941: PUSH
99942: LD_INT 2
99944: ARRAY
99945: PPUSH
99946: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99950: LD_VAR 0 1
99954: PUSH
99955: LD_INT 1
99957: ARRAY
99958: PPUSH
99959: LD_VAR 0 1
99963: PUSH
99964: LD_INT 2
99966: ARRAY
99967: PPUSH
99968: CALL_OW 429
// end ; end ;
99972: LD_VAR 0 1
99976: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99977: LD_EXP 96
99981: PUSH
99982: LD_EXP 118
99986: AND
99987: IFFALSE 99999
99989: GO 99991
99991: DISABLE
// YouLost (  ) ;
99992: LD_STRING 
99994: PPUSH
99995: CALL_OW 104
99999: END
// every 0 0$1 trigger StreamModeActive and sFog do
100000: LD_EXP 96
100004: PUSH
100005: LD_EXP 117
100009: AND
100010: IFFALSE 100024
100012: GO 100014
100014: DISABLE
// FogOff ( your_side ) ;
100015: LD_OWVAR 2
100019: PPUSH
100020: CALL_OW 344
100024: END
// every 0 0$1 trigger StreamModeActive and sSun do
100025: LD_EXP 96
100029: PUSH
100030: LD_EXP 119
100034: AND
100035: IFFALSE 100063
100037: GO 100039
100039: DISABLE
// begin solar_recharge_percent := 0 ;
100040: LD_ADDR_OWVAR 79
100044: PUSH
100045: LD_INT 0
100047: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100048: LD_INT 10500
100050: PPUSH
100051: CALL_OW 67
// solar_recharge_percent := 100 ;
100055: LD_ADDR_OWVAR 79
100059: PUSH
100060: LD_INT 100
100062: ST_TO_ADDR
// end ;
100063: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100064: LD_EXP 96
100068: PUSH
100069: LD_EXP 120
100073: AND
100074: IFFALSE 100313
100076: GO 100078
100078: DISABLE
100079: LD_INT 0
100081: PPUSH
100082: PPUSH
100083: PPUSH
// begin tmp := [ ] ;
100084: LD_ADDR_VAR 0 3
100088: PUSH
100089: EMPTY
100090: ST_TO_ADDR
// for i := 1 to 6 do
100091: LD_ADDR_VAR 0 1
100095: PUSH
100096: DOUBLE
100097: LD_INT 1
100099: DEC
100100: ST_TO_ADDR
100101: LD_INT 6
100103: PUSH
100104: FOR_TO
100105: IFFALSE 100210
// begin uc_nation := nation_nature ;
100107: LD_ADDR_OWVAR 21
100111: PUSH
100112: LD_INT 0
100114: ST_TO_ADDR
// uc_side := 0 ;
100115: LD_ADDR_OWVAR 20
100119: PUSH
100120: LD_INT 0
100122: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100123: LD_ADDR_OWVAR 29
100127: PUSH
100128: LD_INT 12
100130: PUSH
100131: LD_INT 12
100133: PUSH
100134: EMPTY
100135: LIST
100136: LIST
100137: ST_TO_ADDR
// hc_agressivity := 20 ;
100138: LD_ADDR_OWVAR 35
100142: PUSH
100143: LD_INT 20
100145: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100146: LD_ADDR_OWVAR 28
100150: PUSH
100151: LD_INT 17
100153: ST_TO_ADDR
// hc_gallery :=  ;
100154: LD_ADDR_OWVAR 33
100158: PUSH
100159: LD_STRING 
100161: ST_TO_ADDR
// hc_name :=  ;
100162: LD_ADDR_OWVAR 26
100166: PUSH
100167: LD_STRING 
100169: ST_TO_ADDR
// un := CreateHuman ;
100170: LD_ADDR_VAR 0 2
100174: PUSH
100175: CALL_OW 44
100179: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100180: LD_VAR 0 2
100184: PPUSH
100185: LD_INT 1
100187: PPUSH
100188: CALL_OW 51
// tmp := tmp ^ un ;
100192: LD_ADDR_VAR 0 3
100196: PUSH
100197: LD_VAR 0 3
100201: PUSH
100202: LD_VAR 0 2
100206: ADD
100207: ST_TO_ADDR
// end ;
100208: GO 100104
100210: POP
100211: POP
// repeat wait ( 0 0$1 ) ;
100212: LD_INT 35
100214: PPUSH
100215: CALL_OW 67
// for un in tmp do
100219: LD_ADDR_VAR 0 2
100223: PUSH
100224: LD_VAR 0 3
100228: PUSH
100229: FOR_IN
100230: IFFALSE 100304
// begin if IsDead ( un ) then
100232: LD_VAR 0 2
100236: PPUSH
100237: CALL_OW 301
100241: IFFALSE 100261
// begin tmp := tmp diff un ;
100243: LD_ADDR_VAR 0 3
100247: PUSH
100248: LD_VAR 0 3
100252: PUSH
100253: LD_VAR 0 2
100257: DIFF
100258: ST_TO_ADDR
// continue ;
100259: GO 100229
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100261: LD_VAR 0 2
100265: PPUSH
100266: LD_INT 3
100268: PUSH
100269: LD_INT 22
100271: PUSH
100272: LD_INT 0
100274: PUSH
100275: EMPTY
100276: LIST
100277: LIST
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: PPUSH
100283: CALL_OW 69
100287: PPUSH
100288: LD_VAR 0 2
100292: PPUSH
100293: CALL_OW 74
100297: PPUSH
100298: CALL_OW 115
// end ;
100302: GO 100229
100304: POP
100305: POP
// until not tmp ;
100306: LD_VAR 0 3
100310: NOT
100311: IFFALSE 100212
// end ;
100313: PPOPN 3
100315: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100316: LD_EXP 96
100320: PUSH
100321: LD_EXP 121
100325: AND
100326: IFFALSE 100380
100328: GO 100330
100330: DISABLE
// begin ToLua ( displayTroll(); ) ;
100331: LD_STRING displayTroll();
100333: PPUSH
100334: CALL_OW 559
// wait ( 3 3$00 ) ;
100338: LD_INT 6300
100340: PPUSH
100341: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100345: LD_STRING hideTroll();
100347: PPUSH
100348: CALL_OW 559
// wait ( 1 1$00 ) ;
100352: LD_INT 2100
100354: PPUSH
100355: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100359: LD_STRING displayTroll();
100361: PPUSH
100362: CALL_OW 559
// wait ( 1 1$00 ) ;
100366: LD_INT 2100
100368: PPUSH
100369: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100373: LD_STRING hideTroll();
100375: PPUSH
100376: CALL_OW 559
// end ;
100380: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100381: LD_EXP 96
100385: PUSH
100386: LD_EXP 122
100390: AND
100391: IFFALSE 100454
100393: GO 100395
100395: DISABLE
100396: LD_INT 0
100398: PPUSH
// begin p := 0 ;
100399: LD_ADDR_VAR 0 1
100403: PUSH
100404: LD_INT 0
100406: ST_TO_ADDR
// repeat game_speed := 1 ;
100407: LD_ADDR_OWVAR 65
100411: PUSH
100412: LD_INT 1
100414: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100415: LD_INT 35
100417: PPUSH
100418: CALL_OW 67
// p := p + 1 ;
100422: LD_ADDR_VAR 0 1
100426: PUSH
100427: LD_VAR 0 1
100431: PUSH
100432: LD_INT 1
100434: PLUS
100435: ST_TO_ADDR
// until p >= 60 ;
100436: LD_VAR 0 1
100440: PUSH
100441: LD_INT 60
100443: GREATEREQUAL
100444: IFFALSE 100407
// game_speed := 4 ;
100446: LD_ADDR_OWVAR 65
100450: PUSH
100451: LD_INT 4
100453: ST_TO_ADDR
// end ;
100454: PPOPN 1
100456: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100457: LD_EXP 96
100461: PUSH
100462: LD_EXP 123
100466: AND
100467: IFFALSE 100613
100469: GO 100471
100471: DISABLE
100472: LD_INT 0
100474: PPUSH
100475: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100476: LD_ADDR_VAR 0 1
100480: PUSH
100481: LD_INT 22
100483: PUSH
100484: LD_OWVAR 2
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PUSH
100493: LD_INT 2
100495: PUSH
100496: LD_INT 30
100498: PUSH
100499: LD_INT 0
100501: PUSH
100502: EMPTY
100503: LIST
100504: LIST
100505: PUSH
100506: LD_INT 30
100508: PUSH
100509: LD_INT 1
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: LIST
100520: PUSH
100521: EMPTY
100522: LIST
100523: LIST
100524: PPUSH
100525: CALL_OW 69
100529: ST_TO_ADDR
// if not depot then
100530: LD_VAR 0 1
100534: NOT
100535: IFFALSE 100539
// exit ;
100537: GO 100613
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100539: LD_ADDR_VAR 0 2
100543: PUSH
100544: LD_VAR 0 1
100548: PUSH
100549: LD_INT 1
100551: PPUSH
100552: LD_VAR 0 1
100556: PPUSH
100557: CALL_OW 12
100561: ARRAY
100562: PPUSH
100563: CALL_OW 274
100567: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100568: LD_VAR 0 2
100572: PPUSH
100573: LD_INT 1
100575: PPUSH
100576: LD_INT 0
100578: PPUSH
100579: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100583: LD_VAR 0 2
100587: PPUSH
100588: LD_INT 2
100590: PPUSH
100591: LD_INT 0
100593: PPUSH
100594: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100598: LD_VAR 0 2
100602: PPUSH
100603: LD_INT 3
100605: PPUSH
100606: LD_INT 0
100608: PPUSH
100609: CALL_OW 277
// end ;
100613: PPOPN 2
100615: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100616: LD_EXP 96
100620: PUSH
100621: LD_EXP 124
100625: AND
100626: IFFALSE 100723
100628: GO 100630
100630: DISABLE
100631: LD_INT 0
100633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100634: LD_ADDR_VAR 0 1
100638: PUSH
100639: LD_INT 22
100641: PUSH
100642: LD_OWVAR 2
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: PUSH
100651: LD_INT 21
100653: PUSH
100654: LD_INT 1
100656: PUSH
100657: EMPTY
100658: LIST
100659: LIST
100660: PUSH
100661: LD_INT 3
100663: PUSH
100664: LD_INT 23
100666: PUSH
100667: LD_INT 0
100669: PUSH
100670: EMPTY
100671: LIST
100672: LIST
100673: PUSH
100674: EMPTY
100675: LIST
100676: LIST
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: LIST
100682: PPUSH
100683: CALL_OW 69
100687: ST_TO_ADDR
// if not tmp then
100688: LD_VAR 0 1
100692: NOT
100693: IFFALSE 100697
// exit ;
100695: GO 100723
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100697: LD_VAR 0 1
100701: PUSH
100702: LD_INT 1
100704: PPUSH
100705: LD_VAR 0 1
100709: PPUSH
100710: CALL_OW 12
100714: ARRAY
100715: PPUSH
100716: LD_INT 200
100718: PPUSH
100719: CALL_OW 234
// end ;
100723: PPOPN 1
100725: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100726: LD_EXP 96
100730: PUSH
100731: LD_EXP 125
100735: AND
100736: IFFALSE 100815
100738: GO 100740
100740: DISABLE
100741: LD_INT 0
100743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100744: LD_ADDR_VAR 0 1
100748: PUSH
100749: LD_INT 22
100751: PUSH
100752: LD_OWVAR 2
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PUSH
100761: LD_INT 21
100763: PUSH
100764: LD_INT 2
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: PPUSH
100775: CALL_OW 69
100779: ST_TO_ADDR
// if not tmp then
100780: LD_VAR 0 1
100784: NOT
100785: IFFALSE 100789
// exit ;
100787: GO 100815
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100789: LD_VAR 0 1
100793: PUSH
100794: LD_INT 1
100796: PPUSH
100797: LD_VAR 0 1
100801: PPUSH
100802: CALL_OW 12
100806: ARRAY
100807: PPUSH
100808: LD_INT 60
100810: PPUSH
100811: CALL_OW 234
// end ;
100815: PPOPN 1
100817: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100818: LD_EXP 96
100822: PUSH
100823: LD_EXP 126
100827: AND
100828: IFFALSE 100927
100830: GO 100832
100832: DISABLE
100833: LD_INT 0
100835: PPUSH
100836: PPUSH
// begin enable ;
100837: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100838: LD_ADDR_VAR 0 1
100842: PUSH
100843: LD_INT 22
100845: PUSH
100846: LD_OWVAR 2
100850: PUSH
100851: EMPTY
100852: LIST
100853: LIST
100854: PUSH
100855: LD_INT 61
100857: PUSH
100858: EMPTY
100859: LIST
100860: PUSH
100861: LD_INT 33
100863: PUSH
100864: LD_INT 2
100866: PUSH
100867: EMPTY
100868: LIST
100869: LIST
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: LIST
100875: PPUSH
100876: CALL_OW 69
100880: ST_TO_ADDR
// if not tmp then
100881: LD_VAR 0 1
100885: NOT
100886: IFFALSE 100890
// exit ;
100888: GO 100927
// for i in tmp do
100890: LD_ADDR_VAR 0 2
100894: PUSH
100895: LD_VAR 0 1
100899: PUSH
100900: FOR_IN
100901: IFFALSE 100925
// if IsControledBy ( i ) then
100903: LD_VAR 0 2
100907: PPUSH
100908: CALL_OW 312
100912: IFFALSE 100923
// ComUnlink ( i ) ;
100914: LD_VAR 0 2
100918: PPUSH
100919: CALL_OW 136
100923: GO 100900
100925: POP
100926: POP
// end ;
100927: PPOPN 2
100929: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100930: LD_EXP 96
100934: PUSH
100935: LD_EXP 127
100939: AND
100940: IFFALSE 101080
100942: GO 100944
100944: DISABLE
100945: LD_INT 0
100947: PPUSH
100948: PPUSH
// begin ToLua ( displayPowell(); ) ;
100949: LD_STRING displayPowell();
100951: PPUSH
100952: CALL_OW 559
// uc_side := 0 ;
100956: LD_ADDR_OWVAR 20
100960: PUSH
100961: LD_INT 0
100963: ST_TO_ADDR
// uc_nation := 2 ;
100964: LD_ADDR_OWVAR 21
100968: PUSH
100969: LD_INT 2
100971: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100972: LD_ADDR_OWVAR 37
100976: PUSH
100977: LD_INT 14
100979: ST_TO_ADDR
// vc_engine := engine_siberite ;
100980: LD_ADDR_OWVAR 39
100984: PUSH
100985: LD_INT 3
100987: ST_TO_ADDR
// vc_control := control_apeman ;
100988: LD_ADDR_OWVAR 38
100992: PUSH
100993: LD_INT 5
100995: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100996: LD_ADDR_OWVAR 40
101000: PUSH
101001: LD_INT 29
101003: ST_TO_ADDR
// un := CreateVehicle ;
101004: LD_ADDR_VAR 0 2
101008: PUSH
101009: CALL_OW 45
101013: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101014: LD_VAR 0 2
101018: PPUSH
101019: LD_INT 1
101021: PPUSH
101022: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101026: LD_INT 35
101028: PPUSH
101029: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101033: LD_VAR 0 2
101037: PPUSH
101038: LD_INT 22
101040: PUSH
101041: LD_OWVAR 2
101045: PUSH
101046: EMPTY
101047: LIST
101048: LIST
101049: PPUSH
101050: CALL_OW 69
101054: PPUSH
101055: LD_VAR 0 2
101059: PPUSH
101060: CALL_OW 74
101064: PPUSH
101065: CALL_OW 115
// until IsDead ( un ) ;
101069: LD_VAR 0 2
101073: PPUSH
101074: CALL_OW 301
101078: IFFALSE 101026
// end ;
101080: PPOPN 2
101082: END
// every 0 0$1 trigger StreamModeActive and sStu do
101083: LD_EXP 96
101087: PUSH
101088: LD_EXP 135
101092: AND
101093: IFFALSE 101109
101095: GO 101097
101097: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101098: LD_STRING displayStucuk();
101100: PPUSH
101101: CALL_OW 559
// ResetFog ;
101105: CALL_OW 335
// end ;
101109: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101110: LD_EXP 96
101114: PUSH
101115: LD_EXP 128
101119: AND
101120: IFFALSE 101261
101122: GO 101124
101124: DISABLE
101125: LD_INT 0
101127: PPUSH
101128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101129: LD_ADDR_VAR 0 2
101133: PUSH
101134: LD_INT 22
101136: PUSH
101137: LD_OWVAR 2
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: PUSH
101146: LD_INT 21
101148: PUSH
101149: LD_INT 1
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PPUSH
101160: CALL_OW 69
101164: ST_TO_ADDR
// if not tmp then
101165: LD_VAR 0 2
101169: NOT
101170: IFFALSE 101174
// exit ;
101172: GO 101261
// un := tmp [ rand ( 1 , tmp ) ] ;
101174: LD_ADDR_VAR 0 1
101178: PUSH
101179: LD_VAR 0 2
101183: PUSH
101184: LD_INT 1
101186: PPUSH
101187: LD_VAR 0 2
101191: PPUSH
101192: CALL_OW 12
101196: ARRAY
101197: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101198: LD_VAR 0 1
101202: PPUSH
101203: LD_INT 0
101205: PPUSH
101206: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101210: LD_VAR 0 1
101214: PPUSH
101215: LD_OWVAR 3
101219: PUSH
101220: LD_VAR 0 1
101224: DIFF
101225: PPUSH
101226: LD_VAR 0 1
101230: PPUSH
101231: CALL_OW 74
101235: PPUSH
101236: CALL_OW 115
// wait ( 0 0$20 ) ;
101240: LD_INT 700
101242: PPUSH
101243: CALL_OW 67
// SetSide ( un , your_side ) ;
101247: LD_VAR 0 1
101251: PPUSH
101252: LD_OWVAR 2
101256: PPUSH
101257: CALL_OW 235
// end ;
101261: PPOPN 2
101263: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101264: LD_EXP 96
101268: PUSH
101269: LD_EXP 129
101273: AND
101274: IFFALSE 101380
101276: GO 101278
101278: DISABLE
101279: LD_INT 0
101281: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101282: LD_ADDR_VAR 0 1
101286: PUSH
101287: LD_INT 22
101289: PUSH
101290: LD_OWVAR 2
101294: PUSH
101295: EMPTY
101296: LIST
101297: LIST
101298: PUSH
101299: LD_INT 2
101301: PUSH
101302: LD_INT 30
101304: PUSH
101305: LD_INT 0
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PUSH
101312: LD_INT 30
101314: PUSH
101315: LD_INT 1
101317: PUSH
101318: EMPTY
101319: LIST
101320: LIST
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: LIST
101326: PUSH
101327: EMPTY
101328: LIST
101329: LIST
101330: PPUSH
101331: CALL_OW 69
101335: ST_TO_ADDR
// if not depot then
101336: LD_VAR 0 1
101340: NOT
101341: IFFALSE 101345
// exit ;
101343: GO 101380
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101345: LD_VAR 0 1
101349: PUSH
101350: LD_INT 1
101352: ARRAY
101353: PPUSH
101354: CALL_OW 250
101358: PPUSH
101359: LD_VAR 0 1
101363: PUSH
101364: LD_INT 1
101366: ARRAY
101367: PPUSH
101368: CALL_OW 251
101372: PPUSH
101373: LD_INT 70
101375: PPUSH
101376: CALL_OW 495
// end ;
101380: PPOPN 1
101382: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101383: LD_EXP 96
101387: PUSH
101388: LD_EXP 130
101392: AND
101393: IFFALSE 101604
101395: GO 101397
101397: DISABLE
101398: LD_INT 0
101400: PPUSH
101401: PPUSH
101402: PPUSH
101403: PPUSH
101404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101405: LD_ADDR_VAR 0 5
101409: PUSH
101410: LD_INT 22
101412: PUSH
101413: LD_OWVAR 2
101417: PUSH
101418: EMPTY
101419: LIST
101420: LIST
101421: PUSH
101422: LD_INT 21
101424: PUSH
101425: LD_INT 1
101427: PUSH
101428: EMPTY
101429: LIST
101430: LIST
101431: PUSH
101432: EMPTY
101433: LIST
101434: LIST
101435: PPUSH
101436: CALL_OW 69
101440: ST_TO_ADDR
// if not tmp then
101441: LD_VAR 0 5
101445: NOT
101446: IFFALSE 101450
// exit ;
101448: GO 101604
// for i in tmp do
101450: LD_ADDR_VAR 0 1
101454: PUSH
101455: LD_VAR 0 5
101459: PUSH
101460: FOR_IN
101461: IFFALSE 101602
// begin d := rand ( 0 , 5 ) ;
101463: LD_ADDR_VAR 0 4
101467: PUSH
101468: LD_INT 0
101470: PPUSH
101471: LD_INT 5
101473: PPUSH
101474: CALL_OW 12
101478: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101479: LD_ADDR_VAR 0 2
101483: PUSH
101484: LD_VAR 0 1
101488: PPUSH
101489: CALL_OW 250
101493: PPUSH
101494: LD_VAR 0 4
101498: PPUSH
101499: LD_INT 3
101501: PPUSH
101502: LD_INT 12
101504: PPUSH
101505: CALL_OW 12
101509: PPUSH
101510: CALL_OW 272
101514: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101515: LD_ADDR_VAR 0 3
101519: PUSH
101520: LD_VAR 0 1
101524: PPUSH
101525: CALL_OW 251
101529: PPUSH
101530: LD_VAR 0 4
101534: PPUSH
101535: LD_INT 3
101537: PPUSH
101538: LD_INT 12
101540: PPUSH
101541: CALL_OW 12
101545: PPUSH
101546: CALL_OW 273
101550: ST_TO_ADDR
// if ValidHex ( x , y ) then
101551: LD_VAR 0 2
101555: PPUSH
101556: LD_VAR 0 3
101560: PPUSH
101561: CALL_OW 488
101565: IFFALSE 101600
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101567: LD_VAR 0 1
101571: PPUSH
101572: LD_VAR 0 2
101576: PPUSH
101577: LD_VAR 0 3
101581: PPUSH
101582: LD_INT 3
101584: PPUSH
101585: LD_INT 6
101587: PPUSH
101588: CALL_OW 12
101592: PPUSH
101593: LD_INT 1
101595: PPUSH
101596: CALL_OW 483
// end ;
101600: GO 101460
101602: POP
101603: POP
// end ;
101604: PPOPN 5
101606: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101607: LD_EXP 96
101611: PUSH
101612: LD_EXP 131
101616: AND
101617: IFFALSE 101711
101619: GO 101621
101621: DISABLE
101622: LD_INT 0
101624: PPUSH
101625: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101626: LD_ADDR_VAR 0 2
101630: PUSH
101631: LD_INT 22
101633: PUSH
101634: LD_OWVAR 2
101638: PUSH
101639: EMPTY
101640: LIST
101641: LIST
101642: PUSH
101643: LD_INT 32
101645: PUSH
101646: LD_INT 1
101648: PUSH
101649: EMPTY
101650: LIST
101651: LIST
101652: PUSH
101653: LD_INT 21
101655: PUSH
101656: LD_INT 2
101658: PUSH
101659: EMPTY
101660: LIST
101661: LIST
101662: PUSH
101663: EMPTY
101664: LIST
101665: LIST
101666: LIST
101667: PPUSH
101668: CALL_OW 69
101672: ST_TO_ADDR
// if not tmp then
101673: LD_VAR 0 2
101677: NOT
101678: IFFALSE 101682
// exit ;
101680: GO 101711
// for i in tmp do
101682: LD_ADDR_VAR 0 1
101686: PUSH
101687: LD_VAR 0 2
101691: PUSH
101692: FOR_IN
101693: IFFALSE 101709
// SetFuel ( i , 0 ) ;
101695: LD_VAR 0 1
101699: PPUSH
101700: LD_INT 0
101702: PPUSH
101703: CALL_OW 240
101707: GO 101692
101709: POP
101710: POP
// end ;
101711: PPOPN 2
101713: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101714: LD_EXP 96
101718: PUSH
101719: LD_EXP 132
101723: AND
101724: IFFALSE 101790
101726: GO 101728
101728: DISABLE
101729: LD_INT 0
101731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101732: LD_ADDR_VAR 0 1
101736: PUSH
101737: LD_INT 22
101739: PUSH
101740: LD_OWVAR 2
101744: PUSH
101745: EMPTY
101746: LIST
101747: LIST
101748: PUSH
101749: LD_INT 30
101751: PUSH
101752: LD_INT 29
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: PPUSH
101763: CALL_OW 69
101767: ST_TO_ADDR
// if not tmp then
101768: LD_VAR 0 1
101772: NOT
101773: IFFALSE 101777
// exit ;
101775: GO 101790
// DestroyUnit ( tmp [ 1 ] ) ;
101777: LD_VAR 0 1
101781: PUSH
101782: LD_INT 1
101784: ARRAY
101785: PPUSH
101786: CALL_OW 65
// end ;
101790: PPOPN 1
101792: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101793: LD_EXP 96
101797: PUSH
101798: LD_EXP 134
101802: AND
101803: IFFALSE 101932
101805: GO 101807
101807: DISABLE
101808: LD_INT 0
101810: PPUSH
// begin uc_side := 0 ;
101811: LD_ADDR_OWVAR 20
101815: PUSH
101816: LD_INT 0
101818: ST_TO_ADDR
// uc_nation := nation_arabian ;
101819: LD_ADDR_OWVAR 21
101823: PUSH
101824: LD_INT 2
101826: ST_TO_ADDR
// hc_gallery :=  ;
101827: LD_ADDR_OWVAR 33
101831: PUSH
101832: LD_STRING 
101834: ST_TO_ADDR
// hc_name :=  ;
101835: LD_ADDR_OWVAR 26
101839: PUSH
101840: LD_STRING 
101842: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101843: LD_INT 1
101845: PPUSH
101846: LD_INT 11
101848: PPUSH
101849: LD_INT 10
101851: PPUSH
101852: CALL_OW 380
// un := CreateHuman ;
101856: LD_ADDR_VAR 0 1
101860: PUSH
101861: CALL_OW 44
101865: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101866: LD_VAR 0 1
101870: PPUSH
101871: LD_INT 1
101873: PPUSH
101874: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101878: LD_INT 35
101880: PPUSH
101881: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101885: LD_VAR 0 1
101889: PPUSH
101890: LD_INT 22
101892: PUSH
101893: LD_OWVAR 2
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: PPUSH
101902: CALL_OW 69
101906: PPUSH
101907: LD_VAR 0 1
101911: PPUSH
101912: CALL_OW 74
101916: PPUSH
101917: CALL_OW 115
// until IsDead ( un ) ;
101921: LD_VAR 0 1
101925: PPUSH
101926: CALL_OW 301
101930: IFFALSE 101878
// end ;
101932: PPOPN 1
101934: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101935: LD_EXP 96
101939: PUSH
101940: LD_EXP 136
101944: AND
101945: IFFALSE 101957
101947: GO 101949
101949: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101950: LD_STRING earthquake(getX(game), 0, 32)
101952: PPUSH
101953: CALL_OW 559
101957: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101958: LD_EXP 96
101962: PUSH
101963: LD_EXP 137
101967: AND
101968: IFFALSE 102059
101970: GO 101972
101972: DISABLE
101973: LD_INT 0
101975: PPUSH
// begin enable ;
101976: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101977: LD_ADDR_VAR 0 1
101981: PUSH
101982: LD_INT 22
101984: PUSH
101985: LD_OWVAR 2
101989: PUSH
101990: EMPTY
101991: LIST
101992: LIST
101993: PUSH
101994: LD_INT 21
101996: PUSH
101997: LD_INT 2
101999: PUSH
102000: EMPTY
102001: LIST
102002: LIST
102003: PUSH
102004: LD_INT 33
102006: PUSH
102007: LD_INT 3
102009: PUSH
102010: EMPTY
102011: LIST
102012: LIST
102013: PUSH
102014: EMPTY
102015: LIST
102016: LIST
102017: LIST
102018: PPUSH
102019: CALL_OW 69
102023: ST_TO_ADDR
// if not tmp then
102024: LD_VAR 0 1
102028: NOT
102029: IFFALSE 102033
// exit ;
102031: GO 102059
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102033: LD_VAR 0 1
102037: PUSH
102038: LD_INT 1
102040: PPUSH
102041: LD_VAR 0 1
102045: PPUSH
102046: CALL_OW 12
102050: ARRAY
102051: PPUSH
102052: LD_INT 1
102054: PPUSH
102055: CALL_OW 234
// end ;
102059: PPOPN 1
102061: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102062: LD_EXP 96
102066: PUSH
102067: LD_EXP 138
102071: AND
102072: IFFALSE 102213
102074: GO 102076
102076: DISABLE
102077: LD_INT 0
102079: PPUSH
102080: PPUSH
102081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102082: LD_ADDR_VAR 0 3
102086: PUSH
102087: LD_INT 22
102089: PUSH
102090: LD_OWVAR 2
102094: PUSH
102095: EMPTY
102096: LIST
102097: LIST
102098: PUSH
102099: LD_INT 25
102101: PUSH
102102: LD_INT 1
102104: PUSH
102105: EMPTY
102106: LIST
102107: LIST
102108: PUSH
102109: EMPTY
102110: LIST
102111: LIST
102112: PPUSH
102113: CALL_OW 69
102117: ST_TO_ADDR
// if not tmp then
102118: LD_VAR 0 3
102122: NOT
102123: IFFALSE 102127
// exit ;
102125: GO 102213
// un := tmp [ rand ( 1 , tmp ) ] ;
102127: LD_ADDR_VAR 0 2
102131: PUSH
102132: LD_VAR 0 3
102136: PUSH
102137: LD_INT 1
102139: PPUSH
102140: LD_VAR 0 3
102144: PPUSH
102145: CALL_OW 12
102149: ARRAY
102150: ST_TO_ADDR
// if Crawls ( un ) then
102151: LD_VAR 0 2
102155: PPUSH
102156: CALL_OW 318
102160: IFFALSE 102171
// ComWalk ( un ) ;
102162: LD_VAR 0 2
102166: PPUSH
102167: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102171: LD_VAR 0 2
102175: PPUSH
102176: LD_INT 9
102178: PPUSH
102179: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102183: LD_INT 28
102185: PPUSH
102186: LD_OWVAR 2
102190: PPUSH
102191: LD_INT 2
102193: PPUSH
102194: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102198: LD_INT 29
102200: PPUSH
102201: LD_OWVAR 2
102205: PPUSH
102206: LD_INT 2
102208: PPUSH
102209: CALL_OW 322
// end ;
102213: PPOPN 3
102215: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102216: LD_EXP 96
102220: PUSH
102221: LD_EXP 139
102225: AND
102226: IFFALSE 102337
102228: GO 102230
102230: DISABLE
102231: LD_INT 0
102233: PPUSH
102234: PPUSH
102235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102236: LD_ADDR_VAR 0 3
102240: PUSH
102241: LD_INT 22
102243: PUSH
102244: LD_OWVAR 2
102248: PUSH
102249: EMPTY
102250: LIST
102251: LIST
102252: PUSH
102253: LD_INT 25
102255: PUSH
102256: LD_INT 1
102258: PUSH
102259: EMPTY
102260: LIST
102261: LIST
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: PPUSH
102267: CALL_OW 69
102271: ST_TO_ADDR
// if not tmp then
102272: LD_VAR 0 3
102276: NOT
102277: IFFALSE 102281
// exit ;
102279: GO 102337
// un := tmp [ rand ( 1 , tmp ) ] ;
102281: LD_ADDR_VAR 0 2
102285: PUSH
102286: LD_VAR 0 3
102290: PUSH
102291: LD_INT 1
102293: PPUSH
102294: LD_VAR 0 3
102298: PPUSH
102299: CALL_OW 12
102303: ARRAY
102304: ST_TO_ADDR
// if Crawls ( un ) then
102305: LD_VAR 0 2
102309: PPUSH
102310: CALL_OW 318
102314: IFFALSE 102325
// ComWalk ( un ) ;
102316: LD_VAR 0 2
102320: PPUSH
102321: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102325: LD_VAR 0 2
102329: PPUSH
102330: LD_INT 8
102332: PPUSH
102333: CALL_OW 336
// end ;
102337: PPOPN 3
102339: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102340: LD_EXP 96
102344: PUSH
102345: LD_EXP 140
102349: AND
102350: IFFALSE 102494
102352: GO 102354
102354: DISABLE
102355: LD_INT 0
102357: PPUSH
102358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102359: LD_ADDR_VAR 0 2
102363: PUSH
102364: LD_INT 22
102366: PUSH
102367: LD_OWVAR 2
102371: PUSH
102372: EMPTY
102373: LIST
102374: LIST
102375: PUSH
102376: LD_INT 21
102378: PUSH
102379: LD_INT 2
102381: PUSH
102382: EMPTY
102383: LIST
102384: LIST
102385: PUSH
102386: LD_INT 2
102388: PUSH
102389: LD_INT 34
102391: PUSH
102392: LD_INT 12
102394: PUSH
102395: EMPTY
102396: LIST
102397: LIST
102398: PUSH
102399: LD_INT 34
102401: PUSH
102402: LD_INT 51
102404: PUSH
102405: EMPTY
102406: LIST
102407: LIST
102408: PUSH
102409: LD_INT 34
102411: PUSH
102412: LD_INT 32
102414: PUSH
102415: EMPTY
102416: LIST
102417: LIST
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: PUSH
102425: EMPTY
102426: LIST
102427: LIST
102428: LIST
102429: PPUSH
102430: CALL_OW 69
102434: ST_TO_ADDR
// if not tmp then
102435: LD_VAR 0 2
102439: NOT
102440: IFFALSE 102444
// exit ;
102442: GO 102494
// for i in tmp do
102444: LD_ADDR_VAR 0 1
102448: PUSH
102449: LD_VAR 0 2
102453: PUSH
102454: FOR_IN
102455: IFFALSE 102492
// if GetCargo ( i , mat_artifact ) = 0 then
102457: LD_VAR 0 1
102461: PPUSH
102462: LD_INT 4
102464: PPUSH
102465: CALL_OW 289
102469: PUSH
102470: LD_INT 0
102472: EQUAL
102473: IFFALSE 102490
// SetCargo ( i , mat_siberit , 100 ) ;
102475: LD_VAR 0 1
102479: PPUSH
102480: LD_INT 3
102482: PPUSH
102483: LD_INT 100
102485: PPUSH
102486: CALL_OW 290
102490: GO 102454
102492: POP
102493: POP
// end ;
102494: PPOPN 2
102496: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102497: LD_EXP 96
102501: PUSH
102502: LD_EXP 141
102506: AND
102507: IFFALSE 102690
102509: GO 102511
102511: DISABLE
102512: LD_INT 0
102514: PPUSH
102515: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102516: LD_ADDR_VAR 0 2
102520: PUSH
102521: LD_INT 22
102523: PUSH
102524: LD_OWVAR 2
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: PPUSH
102533: CALL_OW 69
102537: ST_TO_ADDR
// if not tmp then
102538: LD_VAR 0 2
102542: NOT
102543: IFFALSE 102547
// exit ;
102545: GO 102690
// for i := 1 to 2 do
102547: LD_ADDR_VAR 0 1
102551: PUSH
102552: DOUBLE
102553: LD_INT 1
102555: DEC
102556: ST_TO_ADDR
102557: LD_INT 2
102559: PUSH
102560: FOR_TO
102561: IFFALSE 102688
// begin uc_side := your_side ;
102563: LD_ADDR_OWVAR 20
102567: PUSH
102568: LD_OWVAR 2
102572: ST_TO_ADDR
// uc_nation := nation_american ;
102573: LD_ADDR_OWVAR 21
102577: PUSH
102578: LD_INT 1
102580: ST_TO_ADDR
// vc_chassis := us_morphling ;
102581: LD_ADDR_OWVAR 37
102585: PUSH
102586: LD_INT 5
102588: ST_TO_ADDR
// vc_engine := engine_siberite ;
102589: LD_ADDR_OWVAR 39
102593: PUSH
102594: LD_INT 3
102596: ST_TO_ADDR
// vc_control := control_computer ;
102597: LD_ADDR_OWVAR 38
102601: PUSH
102602: LD_INT 3
102604: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102605: LD_ADDR_OWVAR 40
102609: PUSH
102610: LD_INT 10
102612: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102613: LD_VAR 0 2
102617: PUSH
102618: LD_INT 1
102620: ARRAY
102621: PPUSH
102622: CALL_OW 310
102626: NOT
102627: IFFALSE 102674
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102629: CALL_OW 45
102633: PPUSH
102634: LD_VAR 0 2
102638: PUSH
102639: LD_INT 1
102641: ARRAY
102642: PPUSH
102643: CALL_OW 250
102647: PPUSH
102648: LD_VAR 0 2
102652: PUSH
102653: LD_INT 1
102655: ARRAY
102656: PPUSH
102657: CALL_OW 251
102661: PPUSH
102662: LD_INT 12
102664: PPUSH
102665: LD_INT 1
102667: PPUSH
102668: CALL_OW 50
102672: GO 102686
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102674: CALL_OW 45
102678: PPUSH
102679: LD_INT 1
102681: PPUSH
102682: CALL_OW 51
// end ;
102686: GO 102560
102688: POP
102689: POP
// end ;
102690: PPOPN 2
102692: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102693: LD_EXP 96
102697: PUSH
102698: LD_EXP 142
102702: AND
102703: IFFALSE 102925
102705: GO 102707
102707: DISABLE
102708: LD_INT 0
102710: PPUSH
102711: PPUSH
102712: PPUSH
102713: PPUSH
102714: PPUSH
102715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102716: LD_ADDR_VAR 0 6
102720: PUSH
102721: LD_INT 22
102723: PUSH
102724: LD_OWVAR 2
102728: PUSH
102729: EMPTY
102730: LIST
102731: LIST
102732: PUSH
102733: LD_INT 21
102735: PUSH
102736: LD_INT 1
102738: PUSH
102739: EMPTY
102740: LIST
102741: LIST
102742: PUSH
102743: LD_INT 3
102745: PUSH
102746: LD_INT 23
102748: PUSH
102749: LD_INT 0
102751: PUSH
102752: EMPTY
102753: LIST
102754: LIST
102755: PUSH
102756: EMPTY
102757: LIST
102758: LIST
102759: PUSH
102760: EMPTY
102761: LIST
102762: LIST
102763: LIST
102764: PPUSH
102765: CALL_OW 69
102769: ST_TO_ADDR
// if not tmp then
102770: LD_VAR 0 6
102774: NOT
102775: IFFALSE 102779
// exit ;
102777: GO 102925
// s1 := rand ( 1 , 4 ) ;
102779: LD_ADDR_VAR 0 2
102783: PUSH
102784: LD_INT 1
102786: PPUSH
102787: LD_INT 4
102789: PPUSH
102790: CALL_OW 12
102794: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102795: LD_ADDR_VAR 0 4
102799: PUSH
102800: LD_VAR 0 6
102804: PUSH
102805: LD_INT 1
102807: ARRAY
102808: PPUSH
102809: LD_VAR 0 2
102813: PPUSH
102814: CALL_OW 259
102818: ST_TO_ADDR
// if s1 = 1 then
102819: LD_VAR 0 2
102823: PUSH
102824: LD_INT 1
102826: EQUAL
102827: IFFALSE 102847
// s2 := rand ( 2 , 4 ) else
102829: LD_ADDR_VAR 0 3
102833: PUSH
102834: LD_INT 2
102836: PPUSH
102837: LD_INT 4
102839: PPUSH
102840: CALL_OW 12
102844: ST_TO_ADDR
102845: GO 102855
// s2 := 1 ;
102847: LD_ADDR_VAR 0 3
102851: PUSH
102852: LD_INT 1
102854: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102855: LD_ADDR_VAR 0 5
102859: PUSH
102860: LD_VAR 0 6
102864: PUSH
102865: LD_INT 1
102867: ARRAY
102868: PPUSH
102869: LD_VAR 0 3
102873: PPUSH
102874: CALL_OW 259
102878: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102879: LD_VAR 0 6
102883: PUSH
102884: LD_INT 1
102886: ARRAY
102887: PPUSH
102888: LD_VAR 0 2
102892: PPUSH
102893: LD_VAR 0 5
102897: PPUSH
102898: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102902: LD_VAR 0 6
102906: PUSH
102907: LD_INT 1
102909: ARRAY
102910: PPUSH
102911: LD_VAR 0 3
102915: PPUSH
102916: LD_VAR 0 4
102920: PPUSH
102921: CALL_OW 237
// end ;
102925: PPOPN 6
102927: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102928: LD_EXP 96
102932: PUSH
102933: LD_EXP 143
102937: AND
102938: IFFALSE 103017
102940: GO 102942
102942: DISABLE
102943: LD_INT 0
102945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102946: LD_ADDR_VAR 0 1
102950: PUSH
102951: LD_INT 22
102953: PUSH
102954: LD_OWVAR 2
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: PUSH
102963: LD_INT 30
102965: PUSH
102966: LD_INT 3
102968: PUSH
102969: EMPTY
102970: LIST
102971: LIST
102972: PUSH
102973: EMPTY
102974: LIST
102975: LIST
102976: PPUSH
102977: CALL_OW 69
102981: ST_TO_ADDR
// if not tmp then
102982: LD_VAR 0 1
102986: NOT
102987: IFFALSE 102991
// exit ;
102989: GO 103017
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102991: LD_VAR 0 1
102995: PUSH
102996: LD_INT 1
102998: PPUSH
102999: LD_VAR 0 1
103003: PPUSH
103004: CALL_OW 12
103008: ARRAY
103009: PPUSH
103010: LD_INT 1
103012: PPUSH
103013: CALL_OW 234
// end ;
103017: PPOPN 1
103019: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103020: LD_EXP 96
103024: PUSH
103025: LD_EXP 144
103029: AND
103030: IFFALSE 103142
103032: GO 103034
103034: DISABLE
103035: LD_INT 0
103037: PPUSH
103038: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103039: LD_ADDR_VAR 0 2
103043: PUSH
103044: LD_INT 22
103046: PUSH
103047: LD_OWVAR 2
103051: PUSH
103052: EMPTY
103053: LIST
103054: LIST
103055: PUSH
103056: LD_INT 2
103058: PUSH
103059: LD_INT 30
103061: PUSH
103062: LD_INT 27
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: PUSH
103069: LD_INT 30
103071: PUSH
103072: LD_INT 26
103074: PUSH
103075: EMPTY
103076: LIST
103077: LIST
103078: PUSH
103079: LD_INT 30
103081: PUSH
103082: LD_INT 28
103084: PUSH
103085: EMPTY
103086: LIST
103087: LIST
103088: PUSH
103089: EMPTY
103090: LIST
103091: LIST
103092: LIST
103093: LIST
103094: PUSH
103095: EMPTY
103096: LIST
103097: LIST
103098: PPUSH
103099: CALL_OW 69
103103: ST_TO_ADDR
// if not tmp then
103104: LD_VAR 0 2
103108: NOT
103109: IFFALSE 103113
// exit ;
103111: GO 103142
// for i in tmp do
103113: LD_ADDR_VAR 0 1
103117: PUSH
103118: LD_VAR 0 2
103122: PUSH
103123: FOR_IN
103124: IFFALSE 103140
// SetLives ( i , 1 ) ;
103126: LD_VAR 0 1
103130: PPUSH
103131: LD_INT 1
103133: PPUSH
103134: CALL_OW 234
103138: GO 103123
103140: POP
103141: POP
// end ;
103142: PPOPN 2
103144: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103145: LD_EXP 96
103149: PUSH
103150: LD_EXP 145
103154: AND
103155: IFFALSE 103442
103157: GO 103159
103159: DISABLE
103160: LD_INT 0
103162: PPUSH
103163: PPUSH
103164: PPUSH
// begin i := rand ( 1 , 7 ) ;
103165: LD_ADDR_VAR 0 1
103169: PUSH
103170: LD_INT 1
103172: PPUSH
103173: LD_INT 7
103175: PPUSH
103176: CALL_OW 12
103180: ST_TO_ADDR
// case i of 1 :
103181: LD_VAR 0 1
103185: PUSH
103186: LD_INT 1
103188: DOUBLE
103189: EQUAL
103190: IFTRUE 103194
103192: GO 103204
103194: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103195: LD_STRING earthquake(getX(game), 0, 32)
103197: PPUSH
103198: CALL_OW 559
103202: GO 103442
103204: LD_INT 2
103206: DOUBLE
103207: EQUAL
103208: IFTRUE 103212
103210: GO 103226
103212: POP
// begin ToLua ( displayStucuk(); ) ;
103213: LD_STRING displayStucuk();
103215: PPUSH
103216: CALL_OW 559
// ResetFog ;
103220: CALL_OW 335
// end ; 3 :
103224: GO 103442
103226: LD_INT 3
103228: DOUBLE
103229: EQUAL
103230: IFTRUE 103234
103232: GO 103338
103234: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103235: LD_ADDR_VAR 0 2
103239: PUSH
103240: LD_INT 22
103242: PUSH
103243: LD_OWVAR 2
103247: PUSH
103248: EMPTY
103249: LIST
103250: LIST
103251: PUSH
103252: LD_INT 25
103254: PUSH
103255: LD_INT 1
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PUSH
103262: EMPTY
103263: LIST
103264: LIST
103265: PPUSH
103266: CALL_OW 69
103270: ST_TO_ADDR
// if not tmp then
103271: LD_VAR 0 2
103275: NOT
103276: IFFALSE 103280
// exit ;
103278: GO 103442
// un := tmp [ rand ( 1 , tmp ) ] ;
103280: LD_ADDR_VAR 0 3
103284: PUSH
103285: LD_VAR 0 2
103289: PUSH
103290: LD_INT 1
103292: PPUSH
103293: LD_VAR 0 2
103297: PPUSH
103298: CALL_OW 12
103302: ARRAY
103303: ST_TO_ADDR
// if Crawls ( un ) then
103304: LD_VAR 0 3
103308: PPUSH
103309: CALL_OW 318
103313: IFFALSE 103324
// ComWalk ( un ) ;
103315: LD_VAR 0 3
103319: PPUSH
103320: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103324: LD_VAR 0 3
103328: PPUSH
103329: LD_INT 8
103331: PPUSH
103332: CALL_OW 336
// end ; 4 :
103336: GO 103442
103338: LD_INT 4
103340: DOUBLE
103341: EQUAL
103342: IFTRUE 103346
103344: GO 103420
103346: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103347: LD_ADDR_VAR 0 2
103351: PUSH
103352: LD_INT 22
103354: PUSH
103355: LD_OWVAR 2
103359: PUSH
103360: EMPTY
103361: LIST
103362: LIST
103363: PUSH
103364: LD_INT 30
103366: PUSH
103367: LD_INT 29
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PUSH
103374: EMPTY
103375: LIST
103376: LIST
103377: PPUSH
103378: CALL_OW 69
103382: ST_TO_ADDR
// if not tmp then
103383: LD_VAR 0 2
103387: NOT
103388: IFFALSE 103392
// exit ;
103390: GO 103442
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103392: LD_VAR 0 2
103396: PUSH
103397: LD_INT 1
103399: ARRAY
103400: PPUSH
103401: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103405: LD_VAR 0 2
103409: PUSH
103410: LD_INT 1
103412: ARRAY
103413: PPUSH
103414: CALL_OW 65
// end ; 5 .. 7 :
103418: GO 103442
103420: LD_INT 5
103422: DOUBLE
103423: GREATEREQUAL
103424: IFFALSE 103432
103426: LD_INT 7
103428: DOUBLE
103429: LESSEQUAL
103430: IFTRUE 103434
103432: GO 103441
103434: POP
// StreamSibBomb ; end ;
103435: CALL 99679 0 0
103439: GO 103442
103441: POP
// end ;
103442: PPOPN 3
103444: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103445: LD_EXP 96
103449: PUSH
103450: LD_EXP 146
103454: AND
103455: IFFALSE 103611
103457: GO 103459
103459: DISABLE
103460: LD_INT 0
103462: PPUSH
103463: PPUSH
103464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103465: LD_ADDR_VAR 0 2
103469: PUSH
103470: LD_INT 81
103472: PUSH
103473: LD_OWVAR 2
103477: PUSH
103478: EMPTY
103479: LIST
103480: LIST
103481: PUSH
103482: LD_INT 2
103484: PUSH
103485: LD_INT 21
103487: PUSH
103488: LD_INT 1
103490: PUSH
103491: EMPTY
103492: LIST
103493: LIST
103494: PUSH
103495: LD_INT 21
103497: PUSH
103498: LD_INT 2
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PUSH
103505: EMPTY
103506: LIST
103507: LIST
103508: LIST
103509: PUSH
103510: EMPTY
103511: LIST
103512: LIST
103513: PPUSH
103514: CALL_OW 69
103518: ST_TO_ADDR
// if not tmp then
103519: LD_VAR 0 2
103523: NOT
103524: IFFALSE 103528
// exit ;
103526: GO 103611
// p := 0 ;
103528: LD_ADDR_VAR 0 3
103532: PUSH
103533: LD_INT 0
103535: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103536: LD_INT 35
103538: PPUSH
103539: CALL_OW 67
// p := p + 1 ;
103543: LD_ADDR_VAR 0 3
103547: PUSH
103548: LD_VAR 0 3
103552: PUSH
103553: LD_INT 1
103555: PLUS
103556: ST_TO_ADDR
// for i in tmp do
103557: LD_ADDR_VAR 0 1
103561: PUSH
103562: LD_VAR 0 2
103566: PUSH
103567: FOR_IN
103568: IFFALSE 103599
// if GetLives ( i ) < 1000 then
103570: LD_VAR 0 1
103574: PPUSH
103575: CALL_OW 256
103579: PUSH
103580: LD_INT 1000
103582: LESS
103583: IFFALSE 103597
// SetLives ( i , 1000 ) ;
103585: LD_VAR 0 1
103589: PPUSH
103590: LD_INT 1000
103592: PPUSH
103593: CALL_OW 234
103597: GO 103567
103599: POP
103600: POP
// until p > 20 ;
103601: LD_VAR 0 3
103605: PUSH
103606: LD_INT 20
103608: GREATER
103609: IFFALSE 103536
// end ;
103611: PPOPN 3
103613: END
// every 0 0$1 trigger StreamModeActive and sTime do
103614: LD_EXP 96
103618: PUSH
103619: LD_EXP 147
103623: AND
103624: IFFALSE 103659
103626: GO 103628
103628: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103629: LD_INT 28
103631: PPUSH
103632: LD_OWVAR 2
103636: PPUSH
103637: LD_INT 2
103639: PPUSH
103640: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103644: LD_INT 30
103646: PPUSH
103647: LD_OWVAR 2
103651: PPUSH
103652: LD_INT 2
103654: PPUSH
103655: CALL_OW 322
// end ;
103659: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103660: LD_EXP 96
103664: PUSH
103665: LD_EXP 148
103669: AND
103670: IFFALSE 103791
103672: GO 103674
103674: DISABLE
103675: LD_INT 0
103677: PPUSH
103678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103679: LD_ADDR_VAR 0 2
103683: PUSH
103684: LD_INT 22
103686: PUSH
103687: LD_OWVAR 2
103691: PUSH
103692: EMPTY
103693: LIST
103694: LIST
103695: PUSH
103696: LD_INT 21
103698: PUSH
103699: LD_INT 1
103701: PUSH
103702: EMPTY
103703: LIST
103704: LIST
103705: PUSH
103706: LD_INT 3
103708: PUSH
103709: LD_INT 23
103711: PUSH
103712: LD_INT 0
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: LIST
103727: PPUSH
103728: CALL_OW 69
103732: ST_TO_ADDR
// if not tmp then
103733: LD_VAR 0 2
103737: NOT
103738: IFFALSE 103742
// exit ;
103740: GO 103791
// for i in tmp do
103742: LD_ADDR_VAR 0 1
103746: PUSH
103747: LD_VAR 0 2
103751: PUSH
103752: FOR_IN
103753: IFFALSE 103789
// begin if Crawls ( i ) then
103755: LD_VAR 0 1
103759: PPUSH
103760: CALL_OW 318
103764: IFFALSE 103775
// ComWalk ( i ) ;
103766: LD_VAR 0 1
103770: PPUSH
103771: CALL_OW 138
// SetClass ( i , 2 ) ;
103775: LD_VAR 0 1
103779: PPUSH
103780: LD_INT 2
103782: PPUSH
103783: CALL_OW 336
// end ;
103787: GO 103752
103789: POP
103790: POP
// end ;
103791: PPOPN 2
103793: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103794: LD_EXP 96
103798: PUSH
103799: LD_EXP 149
103803: AND
103804: IFFALSE 104092
103806: GO 103808
103808: DISABLE
103809: LD_INT 0
103811: PPUSH
103812: PPUSH
103813: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103814: LD_OWVAR 2
103818: PPUSH
103819: LD_INT 9
103821: PPUSH
103822: LD_INT 1
103824: PPUSH
103825: LD_INT 1
103827: PPUSH
103828: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103832: LD_INT 9
103834: PPUSH
103835: LD_OWVAR 2
103839: PPUSH
103840: CALL_OW 343
// uc_side := 9 ;
103844: LD_ADDR_OWVAR 20
103848: PUSH
103849: LD_INT 9
103851: ST_TO_ADDR
// uc_nation := 2 ;
103852: LD_ADDR_OWVAR 21
103856: PUSH
103857: LD_INT 2
103859: ST_TO_ADDR
// hc_name := Dark Warrior ;
103860: LD_ADDR_OWVAR 26
103864: PUSH
103865: LD_STRING Dark Warrior
103867: ST_TO_ADDR
// hc_gallery :=  ;
103868: LD_ADDR_OWVAR 33
103872: PUSH
103873: LD_STRING 
103875: ST_TO_ADDR
// hc_noskilllimit := true ;
103876: LD_ADDR_OWVAR 76
103880: PUSH
103881: LD_INT 1
103883: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103884: LD_ADDR_OWVAR 31
103888: PUSH
103889: LD_INT 30
103891: PUSH
103892: LD_INT 30
103894: PUSH
103895: LD_INT 30
103897: PUSH
103898: LD_INT 30
103900: PUSH
103901: EMPTY
103902: LIST
103903: LIST
103904: LIST
103905: LIST
103906: ST_TO_ADDR
// un := CreateHuman ;
103907: LD_ADDR_VAR 0 3
103911: PUSH
103912: CALL_OW 44
103916: ST_TO_ADDR
// hc_noskilllimit := false ;
103917: LD_ADDR_OWVAR 76
103921: PUSH
103922: LD_INT 0
103924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103925: LD_VAR 0 3
103929: PPUSH
103930: LD_INT 1
103932: PPUSH
103933: CALL_OW 51
// ToLua ( playRanger() ) ;
103937: LD_STRING playRanger()
103939: PPUSH
103940: CALL_OW 559
// p := 0 ;
103944: LD_ADDR_VAR 0 2
103948: PUSH
103949: LD_INT 0
103951: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103952: LD_INT 35
103954: PPUSH
103955: CALL_OW 67
// p := p + 1 ;
103959: LD_ADDR_VAR 0 2
103963: PUSH
103964: LD_VAR 0 2
103968: PUSH
103969: LD_INT 1
103971: PLUS
103972: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103973: LD_VAR 0 3
103977: PPUSH
103978: CALL_OW 256
103982: PUSH
103983: LD_INT 1000
103985: LESS
103986: IFFALSE 104000
// SetLives ( un , 1000 ) ;
103988: LD_VAR 0 3
103992: PPUSH
103993: LD_INT 1000
103995: PPUSH
103996: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104000: LD_VAR 0 3
104004: PPUSH
104005: LD_INT 81
104007: PUSH
104008: LD_OWVAR 2
104012: PUSH
104013: EMPTY
104014: LIST
104015: LIST
104016: PUSH
104017: LD_INT 91
104019: PUSH
104020: LD_VAR 0 3
104024: PUSH
104025: LD_INT 30
104027: PUSH
104028: EMPTY
104029: LIST
104030: LIST
104031: LIST
104032: PUSH
104033: EMPTY
104034: LIST
104035: LIST
104036: PPUSH
104037: CALL_OW 69
104041: PPUSH
104042: LD_VAR 0 3
104046: PPUSH
104047: CALL_OW 74
104051: PPUSH
104052: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104056: LD_VAR 0 2
104060: PUSH
104061: LD_INT 80
104063: GREATER
104064: PUSH
104065: LD_VAR 0 3
104069: PPUSH
104070: CALL_OW 301
104074: OR
104075: IFFALSE 103952
// if un then
104077: LD_VAR 0 3
104081: IFFALSE 104092
// RemoveUnit ( un ) ;
104083: LD_VAR 0 3
104087: PPUSH
104088: CALL_OW 64
// end ;
104092: PPOPN 3
104094: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104095: LD_EXP 150
104099: IFFALSE 104215
104101: GO 104103
104103: DISABLE
104104: LD_INT 0
104106: PPUSH
104107: PPUSH
104108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104109: LD_ADDR_VAR 0 2
104113: PUSH
104114: LD_INT 81
104116: PUSH
104117: LD_OWVAR 2
104121: PUSH
104122: EMPTY
104123: LIST
104124: LIST
104125: PUSH
104126: LD_INT 21
104128: PUSH
104129: LD_INT 1
104131: PUSH
104132: EMPTY
104133: LIST
104134: LIST
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PPUSH
104140: CALL_OW 69
104144: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104145: LD_STRING playComputer()
104147: PPUSH
104148: CALL_OW 559
// if not tmp then
104152: LD_VAR 0 2
104156: NOT
104157: IFFALSE 104161
// exit ;
104159: GO 104215
// for i in tmp do
104161: LD_ADDR_VAR 0 1
104165: PUSH
104166: LD_VAR 0 2
104170: PUSH
104171: FOR_IN
104172: IFFALSE 104213
// for j := 1 to 4 do
104174: LD_ADDR_VAR 0 3
104178: PUSH
104179: DOUBLE
104180: LD_INT 1
104182: DEC
104183: ST_TO_ADDR
104184: LD_INT 4
104186: PUSH
104187: FOR_TO
104188: IFFALSE 104209
// SetSkill ( i , j , 10 ) ;
104190: LD_VAR 0 1
104194: PPUSH
104195: LD_VAR 0 3
104199: PPUSH
104200: LD_INT 10
104202: PPUSH
104203: CALL_OW 237
104207: GO 104187
104209: POP
104210: POP
104211: GO 104171
104213: POP
104214: POP
// end ;
104215: PPOPN 3
104217: END
// every 0 0$1 trigger s30 do var i , tmp ;
104218: LD_EXP 151
104222: IFFALSE 104291
104224: GO 104226
104226: DISABLE
104227: LD_INT 0
104229: PPUSH
104230: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104231: LD_ADDR_VAR 0 2
104235: PUSH
104236: LD_INT 22
104238: PUSH
104239: LD_OWVAR 2
104243: PUSH
104244: EMPTY
104245: LIST
104246: LIST
104247: PPUSH
104248: CALL_OW 69
104252: ST_TO_ADDR
// if not tmp then
104253: LD_VAR 0 2
104257: NOT
104258: IFFALSE 104262
// exit ;
104260: GO 104291
// for i in tmp do
104262: LD_ADDR_VAR 0 1
104266: PUSH
104267: LD_VAR 0 2
104271: PUSH
104272: FOR_IN
104273: IFFALSE 104289
// SetLives ( i , 300 ) ;
104275: LD_VAR 0 1
104279: PPUSH
104280: LD_INT 300
104282: PPUSH
104283: CALL_OW 234
104287: GO 104272
104289: POP
104290: POP
// end ;
104291: PPOPN 2
104293: END
// every 0 0$1 trigger s60 do var i , tmp ;
104294: LD_EXP 152
104298: IFFALSE 104367
104300: GO 104302
104302: DISABLE
104303: LD_INT 0
104305: PPUSH
104306: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104307: LD_ADDR_VAR 0 2
104311: PUSH
104312: LD_INT 22
104314: PUSH
104315: LD_OWVAR 2
104319: PUSH
104320: EMPTY
104321: LIST
104322: LIST
104323: PPUSH
104324: CALL_OW 69
104328: ST_TO_ADDR
// if not tmp then
104329: LD_VAR 0 2
104333: NOT
104334: IFFALSE 104338
// exit ;
104336: GO 104367
// for i in tmp do
104338: LD_ADDR_VAR 0 1
104342: PUSH
104343: LD_VAR 0 2
104347: PUSH
104348: FOR_IN
104349: IFFALSE 104365
// SetLives ( i , 600 ) ;
104351: LD_VAR 0 1
104355: PPUSH
104356: LD_INT 600
104358: PPUSH
104359: CALL_OW 234
104363: GO 104348
104365: POP
104366: POP
// end ;
104367: PPOPN 2
104369: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104370: LD_INT 0
104372: PPUSH
// case cmd of 301 :
104373: LD_VAR 0 1
104377: PUSH
104378: LD_INT 301
104380: DOUBLE
104381: EQUAL
104382: IFTRUE 104386
104384: GO 104418
104386: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104387: LD_VAR 0 6
104391: PPUSH
104392: LD_VAR 0 7
104396: PPUSH
104397: LD_VAR 0 8
104401: PPUSH
104402: LD_VAR 0 4
104406: PPUSH
104407: LD_VAR 0 5
104411: PPUSH
104412: CALL 105627 0 5
104416: GO 104539
104418: LD_INT 302
104420: DOUBLE
104421: EQUAL
104422: IFTRUE 104426
104424: GO 104463
104426: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104427: LD_VAR 0 6
104431: PPUSH
104432: LD_VAR 0 7
104436: PPUSH
104437: LD_VAR 0 8
104441: PPUSH
104442: LD_VAR 0 9
104446: PPUSH
104447: LD_VAR 0 4
104451: PPUSH
104452: LD_VAR 0 5
104456: PPUSH
104457: CALL 105718 0 6
104461: GO 104539
104463: LD_INT 303
104465: DOUBLE
104466: EQUAL
104467: IFTRUE 104471
104469: GO 104508
104471: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104472: LD_VAR 0 6
104476: PPUSH
104477: LD_VAR 0 7
104481: PPUSH
104482: LD_VAR 0 8
104486: PPUSH
104487: LD_VAR 0 9
104491: PPUSH
104492: LD_VAR 0 4
104496: PPUSH
104497: LD_VAR 0 5
104501: PPUSH
104502: CALL 104544 0 6
104506: GO 104539
104508: LD_INT 304
104510: DOUBLE
104511: EQUAL
104512: IFTRUE 104516
104514: GO 104538
104516: POP
// hHackTeleport ( unit , x , y ) ; end ;
104517: LD_VAR 0 2
104521: PPUSH
104522: LD_VAR 0 4
104526: PPUSH
104527: LD_VAR 0 5
104531: PPUSH
104532: CALL 106311 0 3
104536: GO 104539
104538: POP
// end ;
104539: LD_VAR 0 12
104543: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104544: LD_INT 0
104546: PPUSH
104547: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104548: LD_VAR 0 1
104552: PUSH
104553: LD_INT 1
104555: LESS
104556: PUSH
104557: LD_VAR 0 1
104561: PUSH
104562: LD_INT 3
104564: GREATER
104565: OR
104566: PUSH
104567: LD_VAR 0 5
104571: PPUSH
104572: LD_VAR 0 6
104576: PPUSH
104577: CALL_OW 428
104581: OR
104582: IFFALSE 104586
// exit ;
104584: GO 105314
// uc_side := your_side ;
104586: LD_ADDR_OWVAR 20
104590: PUSH
104591: LD_OWVAR 2
104595: ST_TO_ADDR
// uc_nation := nation ;
104596: LD_ADDR_OWVAR 21
104600: PUSH
104601: LD_VAR 0 1
104605: ST_TO_ADDR
// bc_level = 1 ;
104606: LD_ADDR_OWVAR 43
104610: PUSH
104611: LD_INT 1
104613: ST_TO_ADDR
// case btype of 1 :
104614: LD_VAR 0 2
104618: PUSH
104619: LD_INT 1
104621: DOUBLE
104622: EQUAL
104623: IFTRUE 104627
104625: GO 104638
104627: POP
// bc_type := b_depot ; 2 :
104628: LD_ADDR_OWVAR 42
104632: PUSH
104633: LD_INT 0
104635: ST_TO_ADDR
104636: GO 105258
104638: LD_INT 2
104640: DOUBLE
104641: EQUAL
104642: IFTRUE 104646
104644: GO 104657
104646: POP
// bc_type := b_warehouse ; 3 :
104647: LD_ADDR_OWVAR 42
104651: PUSH
104652: LD_INT 1
104654: ST_TO_ADDR
104655: GO 105258
104657: LD_INT 3
104659: DOUBLE
104660: EQUAL
104661: IFTRUE 104665
104663: GO 104676
104665: POP
// bc_type := b_lab ; 4 .. 9 :
104666: LD_ADDR_OWVAR 42
104670: PUSH
104671: LD_INT 6
104673: ST_TO_ADDR
104674: GO 105258
104676: LD_INT 4
104678: DOUBLE
104679: GREATEREQUAL
104680: IFFALSE 104688
104682: LD_INT 9
104684: DOUBLE
104685: LESSEQUAL
104686: IFTRUE 104690
104688: GO 104750
104690: POP
// begin bc_type := b_lab_half ;
104691: LD_ADDR_OWVAR 42
104695: PUSH
104696: LD_INT 7
104698: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104699: LD_ADDR_OWVAR 44
104703: PUSH
104704: LD_INT 10
104706: PUSH
104707: LD_INT 11
104709: PUSH
104710: LD_INT 12
104712: PUSH
104713: LD_INT 15
104715: PUSH
104716: LD_INT 14
104718: PUSH
104719: LD_INT 13
104721: PUSH
104722: EMPTY
104723: LIST
104724: LIST
104725: LIST
104726: LIST
104727: LIST
104728: LIST
104729: PUSH
104730: LD_VAR 0 2
104734: PUSH
104735: LD_INT 3
104737: MINUS
104738: ARRAY
104739: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104740: LD_ADDR_OWVAR 45
104744: PUSH
104745: LD_INT 9
104747: ST_TO_ADDR
// end ; 10 .. 13 :
104748: GO 105258
104750: LD_INT 10
104752: DOUBLE
104753: GREATEREQUAL
104754: IFFALSE 104762
104756: LD_INT 13
104758: DOUBLE
104759: LESSEQUAL
104760: IFTRUE 104764
104762: GO 104841
104764: POP
// begin bc_type := b_lab_full ;
104765: LD_ADDR_OWVAR 42
104769: PUSH
104770: LD_INT 8
104772: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104773: LD_ADDR_OWVAR 44
104777: PUSH
104778: LD_INT 10
104780: PUSH
104781: LD_INT 12
104783: PUSH
104784: LD_INT 14
104786: PUSH
104787: LD_INT 13
104789: PUSH
104790: EMPTY
104791: LIST
104792: LIST
104793: LIST
104794: LIST
104795: PUSH
104796: LD_VAR 0 2
104800: PUSH
104801: LD_INT 9
104803: MINUS
104804: ARRAY
104805: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104806: LD_ADDR_OWVAR 45
104810: PUSH
104811: LD_INT 11
104813: PUSH
104814: LD_INT 15
104816: PUSH
104817: LD_INT 12
104819: PUSH
104820: LD_INT 15
104822: PUSH
104823: EMPTY
104824: LIST
104825: LIST
104826: LIST
104827: LIST
104828: PUSH
104829: LD_VAR 0 2
104833: PUSH
104834: LD_INT 9
104836: MINUS
104837: ARRAY
104838: ST_TO_ADDR
// end ; 14 :
104839: GO 105258
104841: LD_INT 14
104843: DOUBLE
104844: EQUAL
104845: IFTRUE 104849
104847: GO 104860
104849: POP
// bc_type := b_workshop ; 15 :
104850: LD_ADDR_OWVAR 42
104854: PUSH
104855: LD_INT 2
104857: ST_TO_ADDR
104858: GO 105258
104860: LD_INT 15
104862: DOUBLE
104863: EQUAL
104864: IFTRUE 104868
104866: GO 104879
104868: POP
// bc_type := b_factory ; 16 :
104869: LD_ADDR_OWVAR 42
104873: PUSH
104874: LD_INT 3
104876: ST_TO_ADDR
104877: GO 105258
104879: LD_INT 16
104881: DOUBLE
104882: EQUAL
104883: IFTRUE 104887
104885: GO 104898
104887: POP
// bc_type := b_ext_gun ; 17 :
104888: LD_ADDR_OWVAR 42
104892: PUSH
104893: LD_INT 17
104895: ST_TO_ADDR
104896: GO 105258
104898: LD_INT 17
104900: DOUBLE
104901: EQUAL
104902: IFTRUE 104906
104904: GO 104934
104906: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104907: LD_ADDR_OWVAR 42
104911: PUSH
104912: LD_INT 19
104914: PUSH
104915: LD_INT 23
104917: PUSH
104918: LD_INT 19
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: LIST
104925: PUSH
104926: LD_VAR 0 1
104930: ARRAY
104931: ST_TO_ADDR
104932: GO 105258
104934: LD_INT 18
104936: DOUBLE
104937: EQUAL
104938: IFTRUE 104942
104940: GO 104953
104942: POP
// bc_type := b_ext_radar ; 19 :
104943: LD_ADDR_OWVAR 42
104947: PUSH
104948: LD_INT 20
104950: ST_TO_ADDR
104951: GO 105258
104953: LD_INT 19
104955: DOUBLE
104956: EQUAL
104957: IFTRUE 104961
104959: GO 104972
104961: POP
// bc_type := b_ext_radio ; 20 :
104962: LD_ADDR_OWVAR 42
104966: PUSH
104967: LD_INT 22
104969: ST_TO_ADDR
104970: GO 105258
104972: LD_INT 20
104974: DOUBLE
104975: EQUAL
104976: IFTRUE 104980
104978: GO 104991
104980: POP
// bc_type := b_ext_siberium ; 21 :
104981: LD_ADDR_OWVAR 42
104985: PUSH
104986: LD_INT 21
104988: ST_TO_ADDR
104989: GO 105258
104991: LD_INT 21
104993: DOUBLE
104994: EQUAL
104995: IFTRUE 104999
104997: GO 105010
104999: POP
// bc_type := b_ext_computer ; 22 :
105000: LD_ADDR_OWVAR 42
105004: PUSH
105005: LD_INT 24
105007: ST_TO_ADDR
105008: GO 105258
105010: LD_INT 22
105012: DOUBLE
105013: EQUAL
105014: IFTRUE 105018
105016: GO 105029
105018: POP
// bc_type := b_ext_track ; 23 :
105019: LD_ADDR_OWVAR 42
105023: PUSH
105024: LD_INT 16
105026: ST_TO_ADDR
105027: GO 105258
105029: LD_INT 23
105031: DOUBLE
105032: EQUAL
105033: IFTRUE 105037
105035: GO 105048
105037: POP
// bc_type := b_ext_laser ; 24 :
105038: LD_ADDR_OWVAR 42
105042: PUSH
105043: LD_INT 25
105045: ST_TO_ADDR
105046: GO 105258
105048: LD_INT 24
105050: DOUBLE
105051: EQUAL
105052: IFTRUE 105056
105054: GO 105067
105056: POP
// bc_type := b_control_tower ; 25 :
105057: LD_ADDR_OWVAR 42
105061: PUSH
105062: LD_INT 36
105064: ST_TO_ADDR
105065: GO 105258
105067: LD_INT 25
105069: DOUBLE
105070: EQUAL
105071: IFTRUE 105075
105073: GO 105086
105075: POP
// bc_type := b_breastwork ; 26 :
105076: LD_ADDR_OWVAR 42
105080: PUSH
105081: LD_INT 31
105083: ST_TO_ADDR
105084: GO 105258
105086: LD_INT 26
105088: DOUBLE
105089: EQUAL
105090: IFTRUE 105094
105092: GO 105105
105094: POP
// bc_type := b_bunker ; 27 :
105095: LD_ADDR_OWVAR 42
105099: PUSH
105100: LD_INT 32
105102: ST_TO_ADDR
105103: GO 105258
105105: LD_INT 27
105107: DOUBLE
105108: EQUAL
105109: IFTRUE 105113
105111: GO 105124
105113: POP
// bc_type := b_turret ; 28 :
105114: LD_ADDR_OWVAR 42
105118: PUSH
105119: LD_INT 33
105121: ST_TO_ADDR
105122: GO 105258
105124: LD_INT 28
105126: DOUBLE
105127: EQUAL
105128: IFTRUE 105132
105130: GO 105143
105132: POP
// bc_type := b_armoury ; 29 :
105133: LD_ADDR_OWVAR 42
105137: PUSH
105138: LD_INT 4
105140: ST_TO_ADDR
105141: GO 105258
105143: LD_INT 29
105145: DOUBLE
105146: EQUAL
105147: IFTRUE 105151
105149: GO 105162
105151: POP
// bc_type := b_barracks ; 30 :
105152: LD_ADDR_OWVAR 42
105156: PUSH
105157: LD_INT 5
105159: ST_TO_ADDR
105160: GO 105258
105162: LD_INT 30
105164: DOUBLE
105165: EQUAL
105166: IFTRUE 105170
105168: GO 105181
105170: POP
// bc_type := b_solar_power ; 31 :
105171: LD_ADDR_OWVAR 42
105175: PUSH
105176: LD_INT 27
105178: ST_TO_ADDR
105179: GO 105258
105181: LD_INT 31
105183: DOUBLE
105184: EQUAL
105185: IFTRUE 105189
105187: GO 105200
105189: POP
// bc_type := b_oil_power ; 32 :
105190: LD_ADDR_OWVAR 42
105194: PUSH
105195: LD_INT 26
105197: ST_TO_ADDR
105198: GO 105258
105200: LD_INT 32
105202: DOUBLE
105203: EQUAL
105204: IFTRUE 105208
105206: GO 105219
105208: POP
// bc_type := b_siberite_power ; 33 :
105209: LD_ADDR_OWVAR 42
105213: PUSH
105214: LD_INT 28
105216: ST_TO_ADDR
105217: GO 105258
105219: LD_INT 33
105221: DOUBLE
105222: EQUAL
105223: IFTRUE 105227
105225: GO 105238
105227: POP
// bc_type := b_oil_mine ; 34 :
105228: LD_ADDR_OWVAR 42
105232: PUSH
105233: LD_INT 29
105235: ST_TO_ADDR
105236: GO 105258
105238: LD_INT 34
105240: DOUBLE
105241: EQUAL
105242: IFTRUE 105246
105244: GO 105257
105246: POP
// bc_type := b_siberite_mine ; end ;
105247: LD_ADDR_OWVAR 42
105251: PUSH
105252: LD_INT 30
105254: ST_TO_ADDR
105255: GO 105258
105257: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105258: LD_ADDR_VAR 0 8
105262: PUSH
105263: LD_VAR 0 5
105267: PPUSH
105268: LD_VAR 0 6
105272: PPUSH
105273: LD_VAR 0 3
105277: PPUSH
105278: CALL_OW 47
105282: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105283: LD_OWVAR 42
105287: PUSH
105288: LD_INT 32
105290: PUSH
105291: LD_INT 33
105293: PUSH
105294: EMPTY
105295: LIST
105296: LIST
105297: IN
105298: IFFALSE 105314
// PlaceWeaponTurret ( b , weapon ) ;
105300: LD_VAR 0 8
105304: PPUSH
105305: LD_VAR 0 4
105309: PPUSH
105310: CALL_OW 431
// end ;
105314: LD_VAR 0 7
105318: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105319: LD_INT 0
105321: PPUSH
105322: PPUSH
105323: PPUSH
105324: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105325: LD_ADDR_VAR 0 4
105329: PUSH
105330: LD_INT 22
105332: PUSH
105333: LD_OWVAR 2
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: PUSH
105342: LD_INT 2
105344: PUSH
105345: LD_INT 30
105347: PUSH
105348: LD_INT 0
105350: PUSH
105351: EMPTY
105352: LIST
105353: LIST
105354: PUSH
105355: LD_INT 30
105357: PUSH
105358: LD_INT 1
105360: PUSH
105361: EMPTY
105362: LIST
105363: LIST
105364: PUSH
105365: EMPTY
105366: LIST
105367: LIST
105368: LIST
105369: PUSH
105370: EMPTY
105371: LIST
105372: LIST
105373: PPUSH
105374: CALL_OW 69
105378: ST_TO_ADDR
// if not tmp then
105379: LD_VAR 0 4
105383: NOT
105384: IFFALSE 105388
// exit ;
105386: GO 105447
// for i in tmp do
105388: LD_ADDR_VAR 0 2
105392: PUSH
105393: LD_VAR 0 4
105397: PUSH
105398: FOR_IN
105399: IFFALSE 105445
// for j = 1 to 3 do
105401: LD_ADDR_VAR 0 3
105405: PUSH
105406: DOUBLE
105407: LD_INT 1
105409: DEC
105410: ST_TO_ADDR
105411: LD_INT 3
105413: PUSH
105414: FOR_TO
105415: IFFALSE 105441
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105417: LD_VAR 0 2
105421: PPUSH
105422: CALL_OW 274
105426: PPUSH
105427: LD_VAR 0 3
105431: PPUSH
105432: LD_INT 99999
105434: PPUSH
105435: CALL_OW 277
105439: GO 105414
105441: POP
105442: POP
105443: GO 105398
105445: POP
105446: POP
// end ;
105447: LD_VAR 0 1
105451: RET
// export function hHackSetLevel10 ; var i , j ; begin
105452: LD_INT 0
105454: PPUSH
105455: PPUSH
105456: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105457: LD_ADDR_VAR 0 2
105461: PUSH
105462: LD_INT 21
105464: PUSH
105465: LD_INT 1
105467: PUSH
105468: EMPTY
105469: LIST
105470: LIST
105471: PPUSH
105472: CALL_OW 69
105476: PUSH
105477: FOR_IN
105478: IFFALSE 105530
// if IsSelected ( i ) then
105480: LD_VAR 0 2
105484: PPUSH
105485: CALL_OW 306
105489: IFFALSE 105528
// begin for j := 1 to 4 do
105491: LD_ADDR_VAR 0 3
105495: PUSH
105496: DOUBLE
105497: LD_INT 1
105499: DEC
105500: ST_TO_ADDR
105501: LD_INT 4
105503: PUSH
105504: FOR_TO
105505: IFFALSE 105526
// SetSkill ( i , j , 10 ) ;
105507: LD_VAR 0 2
105511: PPUSH
105512: LD_VAR 0 3
105516: PPUSH
105517: LD_INT 10
105519: PPUSH
105520: CALL_OW 237
105524: GO 105504
105526: POP
105527: POP
// end ;
105528: GO 105477
105530: POP
105531: POP
// end ;
105532: LD_VAR 0 1
105536: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105537: LD_INT 0
105539: PPUSH
105540: PPUSH
105541: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105542: LD_ADDR_VAR 0 2
105546: PUSH
105547: LD_INT 22
105549: PUSH
105550: LD_OWVAR 2
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: PUSH
105559: LD_INT 21
105561: PUSH
105562: LD_INT 1
105564: PUSH
105565: EMPTY
105566: LIST
105567: LIST
105568: PUSH
105569: EMPTY
105570: LIST
105571: LIST
105572: PPUSH
105573: CALL_OW 69
105577: PUSH
105578: FOR_IN
105579: IFFALSE 105620
// begin for j := 1 to 4 do
105581: LD_ADDR_VAR 0 3
105585: PUSH
105586: DOUBLE
105587: LD_INT 1
105589: DEC
105590: ST_TO_ADDR
105591: LD_INT 4
105593: PUSH
105594: FOR_TO
105595: IFFALSE 105616
// SetSkill ( i , j , 10 ) ;
105597: LD_VAR 0 2
105601: PPUSH
105602: LD_VAR 0 3
105606: PPUSH
105607: LD_INT 10
105609: PPUSH
105610: CALL_OW 237
105614: GO 105594
105616: POP
105617: POP
// end ;
105618: GO 105578
105620: POP
105621: POP
// end ;
105622: LD_VAR 0 1
105626: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105627: LD_INT 0
105629: PPUSH
// uc_side := your_side ;
105630: LD_ADDR_OWVAR 20
105634: PUSH
105635: LD_OWVAR 2
105639: ST_TO_ADDR
// uc_nation := nation ;
105640: LD_ADDR_OWVAR 21
105644: PUSH
105645: LD_VAR 0 1
105649: ST_TO_ADDR
// InitHc ;
105650: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105654: LD_INT 0
105656: PPUSH
105657: LD_VAR 0 2
105661: PPUSH
105662: LD_VAR 0 3
105666: PPUSH
105667: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105671: LD_VAR 0 4
105675: PPUSH
105676: LD_VAR 0 5
105680: PPUSH
105681: CALL_OW 428
105685: PUSH
105686: LD_INT 0
105688: EQUAL
105689: IFFALSE 105713
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105691: CALL_OW 44
105695: PPUSH
105696: LD_VAR 0 4
105700: PPUSH
105701: LD_VAR 0 5
105705: PPUSH
105706: LD_INT 1
105708: PPUSH
105709: CALL_OW 48
// end ;
105713: LD_VAR 0 6
105717: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105718: LD_INT 0
105720: PPUSH
105721: PPUSH
// uc_side := your_side ;
105722: LD_ADDR_OWVAR 20
105726: PUSH
105727: LD_OWVAR 2
105731: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105732: LD_VAR 0 1
105736: PUSH
105737: LD_INT 1
105739: PUSH
105740: LD_INT 2
105742: PUSH
105743: LD_INT 3
105745: PUSH
105746: LD_INT 4
105748: PUSH
105749: LD_INT 5
105751: PUSH
105752: EMPTY
105753: LIST
105754: LIST
105755: LIST
105756: LIST
105757: LIST
105758: IN
105759: IFFALSE 105771
// uc_nation := nation_american else
105761: LD_ADDR_OWVAR 21
105765: PUSH
105766: LD_INT 1
105768: ST_TO_ADDR
105769: GO 105814
// if chassis in [ 11 , 12 , 13 , 14 ] then
105771: LD_VAR 0 1
105775: PUSH
105776: LD_INT 11
105778: PUSH
105779: LD_INT 12
105781: PUSH
105782: LD_INT 13
105784: PUSH
105785: LD_INT 14
105787: PUSH
105788: EMPTY
105789: LIST
105790: LIST
105791: LIST
105792: LIST
105793: IN
105794: IFFALSE 105806
// uc_nation := nation_arabian else
105796: LD_ADDR_OWVAR 21
105800: PUSH
105801: LD_INT 2
105803: ST_TO_ADDR
105804: GO 105814
// uc_nation := nation_russian ;
105806: LD_ADDR_OWVAR 21
105810: PUSH
105811: LD_INT 3
105813: ST_TO_ADDR
// vc_chassis := chassis ;
105814: LD_ADDR_OWVAR 37
105818: PUSH
105819: LD_VAR 0 1
105823: ST_TO_ADDR
// vc_engine := engine ;
105824: LD_ADDR_OWVAR 39
105828: PUSH
105829: LD_VAR 0 2
105833: ST_TO_ADDR
// vc_control := control ;
105834: LD_ADDR_OWVAR 38
105838: PUSH
105839: LD_VAR 0 3
105843: ST_TO_ADDR
// vc_weapon := weapon ;
105844: LD_ADDR_OWVAR 40
105848: PUSH
105849: LD_VAR 0 4
105853: ST_TO_ADDR
// un := CreateVehicle ;
105854: LD_ADDR_VAR 0 8
105858: PUSH
105859: CALL_OW 45
105863: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105864: LD_VAR 0 8
105868: PPUSH
105869: LD_INT 0
105871: PPUSH
105872: LD_INT 5
105874: PPUSH
105875: CALL_OW 12
105879: PPUSH
105880: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105884: LD_VAR 0 8
105888: PPUSH
105889: LD_VAR 0 5
105893: PPUSH
105894: LD_VAR 0 6
105898: PPUSH
105899: LD_INT 1
105901: PPUSH
105902: CALL_OW 48
// end ;
105906: LD_VAR 0 7
105910: RET
// export hInvincible ; every 1 do
105911: GO 105913
105913: DISABLE
// hInvincible := [ ] ;
105914: LD_ADDR_EXP 153
105918: PUSH
105919: EMPTY
105920: ST_TO_ADDR
105921: END
// every 10 do var i ;
105922: GO 105924
105924: DISABLE
105925: LD_INT 0
105927: PPUSH
// begin enable ;
105928: ENABLE
// if not hInvincible then
105929: LD_EXP 153
105933: NOT
105934: IFFALSE 105938
// exit ;
105936: GO 105982
// for i in hInvincible do
105938: LD_ADDR_VAR 0 1
105942: PUSH
105943: LD_EXP 153
105947: PUSH
105948: FOR_IN
105949: IFFALSE 105980
// if GetLives ( i ) < 1000 then
105951: LD_VAR 0 1
105955: PPUSH
105956: CALL_OW 256
105960: PUSH
105961: LD_INT 1000
105963: LESS
105964: IFFALSE 105978
// SetLives ( i , 1000 ) ;
105966: LD_VAR 0 1
105970: PPUSH
105971: LD_INT 1000
105973: PPUSH
105974: CALL_OW 234
105978: GO 105948
105980: POP
105981: POP
// end ;
105982: PPOPN 1
105984: END
// export function hHackInvincible ; var i ; begin
105985: LD_INT 0
105987: PPUSH
105988: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105989: LD_ADDR_VAR 0 2
105993: PUSH
105994: LD_INT 2
105996: PUSH
105997: LD_INT 21
105999: PUSH
106000: LD_INT 1
106002: PUSH
106003: EMPTY
106004: LIST
106005: LIST
106006: PUSH
106007: LD_INT 21
106009: PUSH
106010: LD_INT 2
106012: PUSH
106013: EMPTY
106014: LIST
106015: LIST
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: LIST
106021: PPUSH
106022: CALL_OW 69
106026: PUSH
106027: FOR_IN
106028: IFFALSE 106089
// if IsSelected ( i ) then
106030: LD_VAR 0 2
106034: PPUSH
106035: CALL_OW 306
106039: IFFALSE 106087
// begin if i in hInvincible then
106041: LD_VAR 0 2
106045: PUSH
106046: LD_EXP 153
106050: IN
106051: IFFALSE 106071
// hInvincible := hInvincible diff i else
106053: LD_ADDR_EXP 153
106057: PUSH
106058: LD_EXP 153
106062: PUSH
106063: LD_VAR 0 2
106067: DIFF
106068: ST_TO_ADDR
106069: GO 106087
// hInvincible := hInvincible union i ;
106071: LD_ADDR_EXP 153
106075: PUSH
106076: LD_EXP 153
106080: PUSH
106081: LD_VAR 0 2
106085: UNION
106086: ST_TO_ADDR
// end ;
106087: GO 106027
106089: POP
106090: POP
// end ;
106091: LD_VAR 0 1
106095: RET
// export function hHackInvisible ; var i , j ; begin
106096: LD_INT 0
106098: PPUSH
106099: PPUSH
106100: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106101: LD_ADDR_VAR 0 2
106105: PUSH
106106: LD_INT 21
106108: PUSH
106109: LD_INT 1
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: PPUSH
106116: CALL_OW 69
106120: PUSH
106121: FOR_IN
106122: IFFALSE 106146
// if IsSelected ( i ) then
106124: LD_VAR 0 2
106128: PPUSH
106129: CALL_OW 306
106133: IFFALSE 106144
// ComForceInvisible ( i ) ;
106135: LD_VAR 0 2
106139: PPUSH
106140: CALL_OW 496
106144: GO 106121
106146: POP
106147: POP
// end ;
106148: LD_VAR 0 1
106152: RET
// export function hHackChangeYourSide ; begin
106153: LD_INT 0
106155: PPUSH
// if your_side = 8 then
106156: LD_OWVAR 2
106160: PUSH
106161: LD_INT 8
106163: EQUAL
106164: IFFALSE 106176
// your_side := 0 else
106166: LD_ADDR_OWVAR 2
106170: PUSH
106171: LD_INT 0
106173: ST_TO_ADDR
106174: GO 106190
// your_side := your_side + 1 ;
106176: LD_ADDR_OWVAR 2
106180: PUSH
106181: LD_OWVAR 2
106185: PUSH
106186: LD_INT 1
106188: PLUS
106189: ST_TO_ADDR
// end ;
106190: LD_VAR 0 1
106194: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106195: LD_INT 0
106197: PPUSH
106198: PPUSH
106199: PPUSH
// for i in all_units do
106200: LD_ADDR_VAR 0 2
106204: PUSH
106205: LD_OWVAR 3
106209: PUSH
106210: FOR_IN
106211: IFFALSE 106289
// if IsSelected ( i ) then
106213: LD_VAR 0 2
106217: PPUSH
106218: CALL_OW 306
106222: IFFALSE 106287
// begin j := GetSide ( i ) ;
106224: LD_ADDR_VAR 0 3
106228: PUSH
106229: LD_VAR 0 2
106233: PPUSH
106234: CALL_OW 255
106238: ST_TO_ADDR
// if j = 8 then
106239: LD_VAR 0 3
106243: PUSH
106244: LD_INT 8
106246: EQUAL
106247: IFFALSE 106259
// j := 0 else
106249: LD_ADDR_VAR 0 3
106253: PUSH
106254: LD_INT 0
106256: ST_TO_ADDR
106257: GO 106273
// j := j + 1 ;
106259: LD_ADDR_VAR 0 3
106263: PUSH
106264: LD_VAR 0 3
106268: PUSH
106269: LD_INT 1
106271: PLUS
106272: ST_TO_ADDR
// SetSide ( i , j ) ;
106273: LD_VAR 0 2
106277: PPUSH
106278: LD_VAR 0 3
106282: PPUSH
106283: CALL_OW 235
// end ;
106287: GO 106210
106289: POP
106290: POP
// end ;
106291: LD_VAR 0 1
106295: RET
// export function hHackFog ; begin
106296: LD_INT 0
106298: PPUSH
// FogOff ( true ) ;
106299: LD_INT 1
106301: PPUSH
106302: CALL_OW 344
// end ;
106306: LD_VAR 0 1
106310: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106311: LD_INT 0
106313: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106314: LD_VAR 0 1
106318: PPUSH
106319: LD_VAR 0 2
106323: PPUSH
106324: LD_VAR 0 3
106328: PPUSH
106329: LD_INT 1
106331: PPUSH
106332: LD_INT 1
106334: PPUSH
106335: CALL_OW 483
// CenterOnXY ( x , y ) ;
106339: LD_VAR 0 2
106343: PPUSH
106344: LD_VAR 0 3
106348: PPUSH
106349: CALL_OW 84
// end ;
106353: LD_VAR 0 4
106357: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106358: LD_INT 0
106360: PPUSH
106361: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106362: LD_VAR 0 1
106366: NOT
106367: PUSH
106368: LD_VAR 0 2
106372: PPUSH
106373: LD_VAR 0 3
106377: PPUSH
106378: CALL_OW 488
106382: NOT
106383: OR
106384: PUSH
106385: LD_VAR 0 1
106389: PPUSH
106390: CALL_OW 266
106394: PUSH
106395: LD_INT 3
106397: NONEQUAL
106398: PUSH
106399: LD_VAR 0 1
106403: PPUSH
106404: CALL_OW 247
106408: PUSH
106409: LD_INT 1
106411: EQUAL
106412: NOT
106413: AND
106414: OR
106415: IFFALSE 106419
// exit ;
106417: GO 106701
// if GetType ( factory ) = unit_human then
106419: LD_VAR 0 1
106423: PPUSH
106424: CALL_OW 247
106428: PUSH
106429: LD_INT 1
106431: EQUAL
106432: IFFALSE 106449
// factory := IsInUnit ( factory ) ;
106434: LD_ADDR_VAR 0 1
106438: PUSH
106439: LD_VAR 0 1
106443: PPUSH
106444: CALL_OW 310
106448: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106449: LD_VAR 0 1
106453: PPUSH
106454: CALL_OW 266
106458: PUSH
106459: LD_INT 3
106461: NONEQUAL
106462: IFFALSE 106466
// exit ;
106464: GO 106701
// for i := 1 to Count ( factoryWaypoints ) do
106466: LD_ADDR_VAR 0 5
106470: PUSH
106471: DOUBLE
106472: LD_INT 1
106474: DEC
106475: ST_TO_ADDR
106476: LD_EXP 154
106480: PPUSH
106481: CALL 51151 0 1
106485: PUSH
106486: FOR_TO
106487: IFFALSE 106649
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
106489: LD_VAR 0 2
106493: PPUSH
106494: LD_VAR 0 3
106498: PPUSH
106499: CALL_OW 428
106503: PUSH
106504: LD_EXP 154
106508: PUSH
106509: LD_VAR 0 5
106513: ARRAY
106514: PUSH
106515: LD_INT 2
106517: ARRAY
106518: EQUAL
106519: IFFALSE 106551
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106521: LD_ADDR_EXP 154
106525: PUSH
106526: LD_EXP 154
106530: PPUSH
106531: LD_VAR 0 5
106535: PPUSH
106536: CALL_OW 3
106540: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106541: CALL 106706 0 0
// exit ;
106545: POP
106546: POP
106547: GO 106701
// end else
106549: GO 106647
// if factory = factoryWaypoints [ i ] [ 2 ] then
106551: LD_VAR 0 1
106555: PUSH
106556: LD_EXP 154
106560: PUSH
106561: LD_VAR 0 5
106565: ARRAY
106566: PUSH
106567: LD_INT 2
106569: ARRAY
106570: EQUAL
106571: IFFALSE 106647
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106573: LD_ADDR_EXP 154
106577: PUSH
106578: LD_EXP 154
106582: PPUSH
106583: LD_VAR 0 5
106587: PPUSH
106588: CALL_OW 3
106592: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106593: LD_ADDR_EXP 154
106597: PUSH
106598: LD_EXP 154
106602: PPUSH
106603: LD_VAR 0 1
106607: PPUSH
106608: CALL_OW 255
106612: PUSH
106613: LD_VAR 0 1
106617: PUSH
106618: LD_VAR 0 2
106622: PUSH
106623: LD_VAR 0 3
106627: PUSH
106628: EMPTY
106629: LIST
106630: LIST
106631: LIST
106632: LIST
106633: PPUSH
106634: CALL 86760 0 2
106638: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106639: CALL 106706 0 0
// exit ;
106643: POP
106644: POP
106645: GO 106701
// end ; end ;
106647: GO 106486
106649: POP
106650: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106651: LD_ADDR_EXP 154
106655: PUSH
106656: LD_EXP 154
106660: PPUSH
106661: LD_VAR 0 1
106665: PPUSH
106666: CALL_OW 255
106670: PUSH
106671: LD_VAR 0 1
106675: PUSH
106676: LD_VAR 0 2
106680: PUSH
106681: LD_VAR 0 3
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: LIST
106690: LIST
106691: PPUSH
106692: CALL 86760 0 2
106696: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106697: CALL 106706 0 0
// end ;
106701: LD_VAR 0 4
106705: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106706: LD_INT 0
106708: PPUSH
106709: PPUSH
106710: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106711: LD_STRING resetFactoryWaypoint();
106713: PPUSH
106714: CALL_OW 559
// if factoryWaypoints then
106718: LD_EXP 154
106722: IFFALSE 106843
// begin list := factoryWaypoints ;
106724: LD_ADDR_VAR 0 3
106728: PUSH
106729: LD_EXP 154
106733: ST_TO_ADDR
// for i := 1 to list do
106734: LD_ADDR_VAR 0 2
106738: PUSH
106739: DOUBLE
106740: LD_INT 1
106742: DEC
106743: ST_TO_ADDR
106744: LD_VAR 0 3
106748: PUSH
106749: FOR_TO
106750: IFFALSE 106841
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106752: LD_STRING setFactoryWaypointXY(
106754: PUSH
106755: LD_VAR 0 3
106759: PUSH
106760: LD_VAR 0 2
106764: ARRAY
106765: PUSH
106766: LD_INT 1
106768: ARRAY
106769: STR
106770: PUSH
106771: LD_STRING ,
106773: STR
106774: PUSH
106775: LD_VAR 0 3
106779: PUSH
106780: LD_VAR 0 2
106784: ARRAY
106785: PUSH
106786: LD_INT 2
106788: ARRAY
106789: STR
106790: PUSH
106791: LD_STRING ,
106793: STR
106794: PUSH
106795: LD_VAR 0 3
106799: PUSH
106800: LD_VAR 0 2
106804: ARRAY
106805: PUSH
106806: LD_INT 3
106808: ARRAY
106809: STR
106810: PUSH
106811: LD_STRING ,
106813: STR
106814: PUSH
106815: LD_VAR 0 3
106819: PUSH
106820: LD_VAR 0 2
106824: ARRAY
106825: PUSH
106826: LD_INT 4
106828: ARRAY
106829: STR
106830: PUSH
106831: LD_STRING )
106833: STR
106834: PPUSH
106835: CALL_OW 559
106839: GO 106749
106841: POP
106842: POP
// end ; end ;
106843: LD_VAR 0 1
106847: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106848: LD_INT 0
106850: PPUSH
// if HexInfo ( x , y ) = warehouse then
106851: LD_VAR 0 2
106855: PPUSH
106856: LD_VAR 0 3
106860: PPUSH
106861: CALL_OW 428
106865: PUSH
106866: LD_VAR 0 1
106870: EQUAL
106871: IFFALSE 106898
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106873: LD_ADDR_EXP 155
106877: PUSH
106878: LD_EXP 155
106882: PPUSH
106883: LD_VAR 0 1
106887: PPUSH
106888: LD_INT 0
106890: PPUSH
106891: CALL_OW 1
106895: ST_TO_ADDR
106896: GO 106949
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106898: LD_ADDR_EXP 155
106902: PUSH
106903: LD_EXP 155
106907: PPUSH
106908: LD_VAR 0 1
106912: PPUSH
106913: LD_VAR 0 1
106917: PPUSH
106918: CALL_OW 255
106922: PUSH
106923: LD_VAR 0 1
106927: PUSH
106928: LD_VAR 0 2
106932: PUSH
106933: LD_VAR 0 3
106937: PUSH
106938: EMPTY
106939: LIST
106940: LIST
106941: LIST
106942: LIST
106943: PPUSH
106944: CALL_OW 1
106948: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106949: CALL 106958 0 0
// end ;
106953: LD_VAR 0 4
106957: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106958: LD_INT 0
106960: PPUSH
106961: PPUSH
106962: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106963: LD_STRING resetWarehouseGatheringPoints();
106965: PPUSH
106966: CALL_OW 559
// if warehouseGatheringPoints then
106970: LD_EXP 155
106974: IFFALSE 107100
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106976: LD_ADDR_VAR 0 3
106980: PUSH
106981: LD_EXP 155
106985: PPUSH
106986: CALL 90528 0 1
106990: ST_TO_ADDR
// for i := 1 to list do
106991: LD_ADDR_VAR 0 2
106995: PUSH
106996: DOUBLE
106997: LD_INT 1
106999: DEC
107000: ST_TO_ADDR
107001: LD_VAR 0 3
107005: PUSH
107006: FOR_TO
107007: IFFALSE 107098
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107009: LD_STRING setWarehouseGatheringPointXY(
107011: PUSH
107012: LD_VAR 0 3
107016: PUSH
107017: LD_VAR 0 2
107021: ARRAY
107022: PUSH
107023: LD_INT 1
107025: ARRAY
107026: STR
107027: PUSH
107028: LD_STRING ,
107030: STR
107031: PUSH
107032: LD_VAR 0 3
107036: PUSH
107037: LD_VAR 0 2
107041: ARRAY
107042: PUSH
107043: LD_INT 2
107045: ARRAY
107046: STR
107047: PUSH
107048: LD_STRING ,
107050: STR
107051: PUSH
107052: LD_VAR 0 3
107056: PUSH
107057: LD_VAR 0 2
107061: ARRAY
107062: PUSH
107063: LD_INT 3
107065: ARRAY
107066: STR
107067: PUSH
107068: LD_STRING ,
107070: STR
107071: PUSH
107072: LD_VAR 0 3
107076: PUSH
107077: LD_VAR 0 2
107081: ARRAY
107082: PUSH
107083: LD_INT 4
107085: ARRAY
107086: STR
107087: PUSH
107088: LD_STRING )
107090: STR
107091: PPUSH
107092: CALL_OW 559
107096: GO 107006
107098: POP
107099: POP
// end ; end ;
107100: LD_VAR 0 1
107104: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107105: LD_EXP 155
107109: IFFALSE 107794
107111: GO 107113
107113: DISABLE
107114: LD_INT 0
107116: PPUSH
107117: PPUSH
107118: PPUSH
107119: PPUSH
107120: PPUSH
107121: PPUSH
107122: PPUSH
107123: PPUSH
107124: PPUSH
// begin enable ;
107125: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107126: LD_ADDR_VAR 0 3
107130: PUSH
107131: LD_EXP 155
107135: PPUSH
107136: CALL 90528 0 1
107140: ST_TO_ADDR
// if not list then
107141: LD_VAR 0 3
107145: NOT
107146: IFFALSE 107150
// exit ;
107148: GO 107794
// for i := 1 to list do
107150: LD_ADDR_VAR 0 1
107154: PUSH
107155: DOUBLE
107156: LD_INT 1
107158: DEC
107159: ST_TO_ADDR
107160: LD_VAR 0 3
107164: PUSH
107165: FOR_TO
107166: IFFALSE 107792
// begin depot := list [ i ] [ 2 ] ;
107168: LD_ADDR_VAR 0 8
107172: PUSH
107173: LD_VAR 0 3
107177: PUSH
107178: LD_VAR 0 1
107182: ARRAY
107183: PUSH
107184: LD_INT 2
107186: ARRAY
107187: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107188: LD_ADDR_VAR 0 5
107192: PUSH
107193: LD_VAR 0 3
107197: PUSH
107198: LD_VAR 0 1
107202: ARRAY
107203: PUSH
107204: LD_INT 1
107206: ARRAY
107207: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107208: LD_VAR 0 8
107212: PPUSH
107213: CALL_OW 301
107217: PUSH
107218: LD_VAR 0 5
107222: PUSH
107223: LD_VAR 0 8
107227: PPUSH
107228: CALL_OW 255
107232: NONEQUAL
107233: OR
107234: IFFALSE 107263
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107236: LD_ADDR_EXP 155
107240: PUSH
107241: LD_EXP 155
107245: PPUSH
107246: LD_VAR 0 8
107250: PPUSH
107251: LD_INT 0
107253: PPUSH
107254: CALL_OW 1
107258: ST_TO_ADDR
// exit ;
107259: POP
107260: POP
107261: GO 107794
// end ; x := list [ i ] [ 3 ] ;
107263: LD_ADDR_VAR 0 6
107267: PUSH
107268: LD_VAR 0 3
107272: PUSH
107273: LD_VAR 0 1
107277: ARRAY
107278: PUSH
107279: LD_INT 3
107281: ARRAY
107282: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107283: LD_ADDR_VAR 0 7
107287: PUSH
107288: LD_VAR 0 3
107292: PUSH
107293: LD_VAR 0 1
107297: ARRAY
107298: PUSH
107299: LD_INT 4
107301: ARRAY
107302: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107303: LD_ADDR_VAR 0 9
107307: PUSH
107308: LD_VAR 0 6
107312: PPUSH
107313: LD_VAR 0 7
107317: PPUSH
107318: LD_INT 16
107320: PPUSH
107321: CALL 89112 0 3
107325: ST_TO_ADDR
// if not cratesNearbyPoint then
107326: LD_VAR 0 9
107330: NOT
107331: IFFALSE 107337
// exit ;
107333: POP
107334: POP
107335: GO 107794
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107337: LD_ADDR_VAR 0 4
107341: PUSH
107342: LD_INT 22
107344: PUSH
107345: LD_VAR 0 5
107349: PUSH
107350: EMPTY
107351: LIST
107352: LIST
107353: PUSH
107354: LD_INT 3
107356: PUSH
107357: LD_INT 60
107359: PUSH
107360: EMPTY
107361: LIST
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: PUSH
107367: LD_INT 91
107369: PUSH
107370: LD_VAR 0 8
107374: PUSH
107375: LD_INT 6
107377: PUSH
107378: EMPTY
107379: LIST
107380: LIST
107381: LIST
107382: PUSH
107383: LD_INT 2
107385: PUSH
107386: LD_INT 25
107388: PUSH
107389: LD_INT 2
107391: PUSH
107392: EMPTY
107393: LIST
107394: LIST
107395: PUSH
107396: LD_INT 25
107398: PUSH
107399: LD_INT 16
107401: PUSH
107402: EMPTY
107403: LIST
107404: LIST
107405: PUSH
107406: EMPTY
107407: LIST
107408: LIST
107409: LIST
107410: PUSH
107411: EMPTY
107412: LIST
107413: LIST
107414: LIST
107415: LIST
107416: PPUSH
107417: CALL_OW 69
107421: PUSH
107422: LD_VAR 0 8
107426: PPUSH
107427: CALL_OW 313
107431: PPUSH
107432: LD_INT 3
107434: PUSH
107435: LD_INT 60
107437: PUSH
107438: EMPTY
107439: LIST
107440: PUSH
107441: EMPTY
107442: LIST
107443: LIST
107444: PUSH
107445: LD_INT 2
107447: PUSH
107448: LD_INT 25
107450: PUSH
107451: LD_INT 2
107453: PUSH
107454: EMPTY
107455: LIST
107456: LIST
107457: PUSH
107458: LD_INT 25
107460: PUSH
107461: LD_INT 16
107463: PUSH
107464: EMPTY
107465: LIST
107466: LIST
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: LIST
107472: PUSH
107473: EMPTY
107474: LIST
107475: LIST
107476: PPUSH
107477: CALL_OW 72
107481: UNION
107482: ST_TO_ADDR
// if tmp then
107483: LD_VAR 0 4
107487: IFFALSE 107567
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107489: LD_ADDR_VAR 0 4
107493: PUSH
107494: LD_VAR 0 4
107498: PPUSH
107499: LD_INT 3
107501: PPUSH
107502: CALL 87075 0 2
107506: ST_TO_ADDR
// for j in tmp do
107507: LD_ADDR_VAR 0 2
107511: PUSH
107512: LD_VAR 0 4
107516: PUSH
107517: FOR_IN
107518: IFFALSE 107561
// begin if IsInUnit ( j ) then
107520: LD_VAR 0 2
107524: PPUSH
107525: CALL_OW 310
107529: IFFALSE 107540
// ComExit ( j ) ;
107531: LD_VAR 0 2
107535: PPUSH
107536: CALL 87158 0 1
// AddComCollect ( j , x , y ) ;
107540: LD_VAR 0 2
107544: PPUSH
107545: LD_VAR 0 6
107549: PPUSH
107550: LD_VAR 0 7
107554: PPUSH
107555: CALL_OW 177
// end ;
107559: GO 107517
107561: POP
107562: POP
// exit ;
107563: POP
107564: POP
107565: GO 107794
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107567: LD_ADDR_VAR 0 4
107571: PUSH
107572: LD_INT 22
107574: PUSH
107575: LD_VAR 0 5
107579: PUSH
107580: EMPTY
107581: LIST
107582: LIST
107583: PUSH
107584: LD_INT 91
107586: PUSH
107587: LD_VAR 0 8
107591: PUSH
107592: LD_INT 8
107594: PUSH
107595: EMPTY
107596: LIST
107597: LIST
107598: LIST
107599: PUSH
107600: LD_INT 2
107602: PUSH
107603: LD_INT 34
107605: PUSH
107606: LD_INT 12
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: PUSH
107613: LD_INT 34
107615: PUSH
107616: LD_INT 51
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: PUSH
107623: LD_INT 34
107625: PUSH
107626: LD_INT 32
107628: PUSH
107629: EMPTY
107630: LIST
107631: LIST
107632: PUSH
107633: LD_INT 34
107635: PUSH
107636: LD_INT 89
107638: PUSH
107639: EMPTY
107640: LIST
107641: LIST
107642: PUSH
107643: EMPTY
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: LIST
107649: PUSH
107650: EMPTY
107651: LIST
107652: LIST
107653: LIST
107654: PPUSH
107655: CALL_OW 69
107659: ST_TO_ADDR
// if tmp then
107660: LD_VAR 0 4
107664: IFFALSE 107790
// begin for j in tmp do
107666: LD_ADDR_VAR 0 2
107670: PUSH
107671: LD_VAR 0 4
107675: PUSH
107676: FOR_IN
107677: IFFALSE 107788
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107679: LD_VAR 0 2
107683: PPUSH
107684: CALL_OW 262
107688: PUSH
107689: LD_INT 3
107691: EQUAL
107692: PUSH
107693: LD_VAR 0 2
107697: PPUSH
107698: CALL_OW 261
107702: PUSH
107703: LD_INT 20
107705: GREATER
107706: OR
107707: PUSH
107708: LD_VAR 0 2
107712: PPUSH
107713: CALL_OW 314
107717: NOT
107718: AND
107719: PUSH
107720: LD_VAR 0 2
107724: PPUSH
107725: CALL_OW 263
107729: PUSH
107730: LD_INT 1
107732: NONEQUAL
107733: PUSH
107734: LD_VAR 0 2
107738: PPUSH
107739: CALL_OW 311
107743: OR
107744: AND
107745: IFFALSE 107786
// begin ComCollect ( j , x , y ) ;
107747: LD_VAR 0 2
107751: PPUSH
107752: LD_VAR 0 6
107756: PPUSH
107757: LD_VAR 0 7
107761: PPUSH
107762: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107766: LD_VAR 0 2
107770: PPUSH
107771: LD_VAR 0 8
107775: PPUSH
107776: CALL_OW 172
// exit ;
107780: POP
107781: POP
107782: POP
107783: POP
107784: GO 107794
// end ;
107786: GO 107676
107788: POP
107789: POP
// end ; end ;
107790: GO 107165
107792: POP
107793: POP
// end ; end_of_file
107794: PPOPN 9
107796: END
// export function SOS_UnitDestroyed ( un ) ; begin
107797: LD_INT 0
107799: PPUSH
// ComRadiation ( un ) ;
107800: LD_VAR 0 1
107804: PPUSH
107805: CALL 108786 0 1
// end ;
107809: LD_VAR 0 2
107813: RET
// export function SOS_UnitKamikazed ( un ) ; begin
107814: LD_INT 0
107816: PPUSH
// ComRadiation ( un ) ;
107817: LD_VAR 0 1
107821: PPUSH
107822: CALL 108786 0 1
// end ;
107826: LD_VAR 0 2
107830: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107831: LD_INT 0
107833: PPUSH
// end ;
107834: LD_VAR 0 4
107838: RET
// export function SOS_Command ( cmd ) ; begin
107839: LD_INT 0
107841: PPUSH
// end ;
107842: LD_VAR 0 2
107846: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107847: LD_INT 0
107849: PPUSH
// end ;
107850: LD_VAR 0 6
107854: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , tag , driver , hex ; begin
107855: LD_INT 0
107857: PPUSH
107858: PPUSH
107859: PPUSH
107860: PPUSH
107861: PPUSH
// if not vehicle or not factory then
107862: LD_VAR 0 1
107866: NOT
107867: PUSH
107868: LD_VAR 0 2
107872: NOT
107873: OR
107874: IFFALSE 107878
// exit ;
107876: GO 108377
// if not factoryWaypoints then
107878: LD_EXP 154
107882: NOT
107883: IFFALSE 107887
// exit ;
107885: GO 108377
// for i := 1 to Count ( factoryWaypoints ) do
107887: LD_ADDR_VAR 0 4
107891: PUSH
107892: DOUBLE
107893: LD_INT 1
107895: DEC
107896: ST_TO_ADDR
107897: LD_EXP 154
107901: PPUSH
107902: CALL 51151 0 1
107906: PUSH
107907: FOR_TO
107908: IFFALSE 108375
// if factoryWaypoints [ i ] [ 2 ] = factory then
107910: LD_EXP 154
107914: PUSH
107915: LD_VAR 0 4
107919: ARRAY
107920: PUSH
107921: LD_INT 2
107923: ARRAY
107924: PUSH
107925: LD_VAR 0 2
107929: EQUAL
107930: IFFALSE 108373
// begin if GetControl ( vehicle ) = control_manual then
107932: LD_VAR 0 1
107936: PPUSH
107937: CALL_OW 263
107941: PUSH
107942: LD_INT 1
107944: EQUAL
107945: IFFALSE 108256
// begin driver := IsDrivenBy ( vehicle ) ;
107947: LD_ADDR_VAR 0 6
107951: PUSH
107952: LD_VAR 0 1
107956: PPUSH
107957: CALL_OW 311
107961: ST_TO_ADDR
// tag := GetTag ( driver ) ;
107962: LD_ADDR_VAR 0 5
107966: PUSH
107967: LD_VAR 0 6
107971: PPUSH
107972: CALL_OW 110
107976: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
107977: LD_VAR 0 5
107981: PUSH
107982: LD_INT 501
107984: EQUAL
107985: PUSH
107986: LD_VAR 0 1
107990: PPUSH
107991: CALL_OW 110
107995: PUSH
107996: LD_INT 501
107998: EQUAL
107999: OR
108000: IFFALSE 108006
// exit ;
108002: POP
108003: POP
108004: GO 108377
// if not HasTask ( driver ) then
108006: LD_VAR 0 6
108010: PPUSH
108011: CALL_OW 314
108015: NOT
108016: IFFALSE 108254
// begin SetTag ( driver , tDriver ) ;
108018: LD_VAR 0 6
108022: PPUSH
108023: LD_INT 501
108025: PPUSH
108026: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
108030: LD_VAR 0 1
108034: PPUSH
108035: LD_INT 501
108037: PPUSH
108038: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108042: LD_ADDR_VAR 0 7
108046: PUSH
108047: LD_EXP 154
108051: PUSH
108052: LD_VAR 0 4
108056: ARRAY
108057: PUSH
108058: LD_INT 3
108060: ARRAY
108061: PPUSH
108062: LD_EXP 154
108066: PUSH
108067: LD_VAR 0 4
108071: ARRAY
108072: PUSH
108073: LD_INT 4
108075: ARRAY
108076: PPUSH
108077: CALL_OW 428
108081: ST_TO_ADDR
// if hex then
108082: LD_VAR 0 7
108086: IFFALSE 108104
// ComMoveUnit ( driver , hex ) else
108088: LD_VAR 0 6
108092: PPUSH
108093: LD_VAR 0 7
108097: PPUSH
108098: CALL_OW 112
108102: GO 108143
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108104: LD_VAR 0 6
108108: PPUSH
108109: LD_EXP 154
108113: PUSH
108114: LD_VAR 0 4
108118: ARRAY
108119: PUSH
108120: LD_INT 3
108122: ARRAY
108123: PPUSH
108124: LD_EXP 154
108128: PUSH
108129: LD_VAR 0 4
108133: ARRAY
108134: PUSH
108135: LD_INT 4
108137: ARRAY
108138: PPUSH
108139: CALL_OW 111
// AddComExitVehicle ( driver ) ;
108143: LD_VAR 0 6
108147: PPUSH
108148: CALL_OW 181
// if Multiplayer then
108152: LD_OWVAR 4
108156: IFFALSE 108205
// begin repeat wait ( 10 ) ;
108158: LD_INT 10
108160: PPUSH
108161: CALL_OW 67
// until not IsInUnit ( driver ) ;
108165: LD_VAR 0 6
108169: PPUSH
108170: CALL_OW 310
108174: NOT
108175: IFFALSE 108158
// if not HasTask ( driver ) then
108177: LD_VAR 0 6
108181: PPUSH
108182: CALL_OW 314
108186: NOT
108187: IFFALSE 108203
// ComEnterUnit ( driver , factory ) ;
108189: LD_VAR 0 6
108193: PPUSH
108194: LD_VAR 0 2
108198: PPUSH
108199: CALL_OW 120
// end else
108203: GO 108219
// AddComEnterUnit ( driver , factory ) ;
108205: LD_VAR 0 6
108209: PPUSH
108210: LD_VAR 0 2
108214: PPUSH
108215: CALL_OW 180
// wait ( 0 0$1 ) ;
108219: LD_INT 35
108221: PPUSH
108222: CALL_OW 67
// SetTag ( driver , tag ) ;
108226: LD_VAR 0 6
108230: PPUSH
108231: LD_VAR 0 5
108235: PPUSH
108236: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
108240: LD_VAR 0 1
108244: PPUSH
108245: LD_INT 0
108247: PPUSH
108248: CALL_OW 109
// break ;
108252: GO 108375
// end ; end else
108254: GO 108373
// if GetControl ( vehicle ) = control_remote then
108256: LD_VAR 0 1
108260: PPUSH
108261: CALL_OW 263
108265: PUSH
108266: LD_INT 2
108268: EQUAL
108269: IFFALSE 108332
// begin wait ( 0 0$2 ) ;
108271: LD_INT 70
108273: PPUSH
108274: CALL_OW 67
// if Connect ( vehicle ) then
108278: LD_VAR 0 1
108282: PPUSH
108283: CALL 57357 0 1
108287: IFFALSE 108328
// AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108289: LD_VAR 0 1
108293: PPUSH
108294: LD_EXP 154
108298: PUSH
108299: LD_VAR 0 4
108303: ARRAY
108304: PUSH
108305: LD_INT 3
108307: ARRAY
108308: PPUSH
108309: LD_EXP 154
108313: PUSH
108314: LD_VAR 0 4
108318: ARRAY
108319: PUSH
108320: LD_INT 4
108322: ARRAY
108323: PPUSH
108324: CALL_OW 171
// break ;
108328: GO 108375
// end else
108330: GO 108373
// begin AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108332: LD_VAR 0 1
108336: PPUSH
108337: LD_EXP 154
108341: PUSH
108342: LD_VAR 0 4
108346: ARRAY
108347: PUSH
108348: LD_INT 3
108350: ARRAY
108351: PPUSH
108352: LD_EXP 154
108356: PUSH
108357: LD_VAR 0 4
108361: ARRAY
108362: PUSH
108363: LD_INT 4
108365: ARRAY
108366: PPUSH
108367: CALL_OW 171
// break ;
108371: GO 108375
// end ; end ;
108373: GO 107907
108375: POP
108376: POP
// end ;
108377: LD_VAR 0 3
108381: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108382: LD_INT 0
108384: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108385: LD_VAR 0 1
108389: PUSH
108390: LD_INT 250
108392: EQUAL
108393: PUSH
108394: LD_VAR 0 2
108398: PPUSH
108399: CALL_OW 264
108403: PUSH
108404: LD_INT 81
108406: EQUAL
108407: AND
108408: IFFALSE 108429
// MinerPlaceMine ( unit , x , y ) ;
108410: LD_VAR 0 2
108414: PPUSH
108415: LD_VAR 0 4
108419: PPUSH
108420: LD_VAR 0 5
108424: PPUSH
108425: CALL 111521 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108429: LD_VAR 0 1
108433: PUSH
108434: LD_INT 251
108436: EQUAL
108437: PUSH
108438: LD_VAR 0 2
108442: PPUSH
108443: CALL_OW 264
108447: PUSH
108448: LD_INT 81
108450: EQUAL
108451: AND
108452: IFFALSE 108473
// MinerDetonateMine ( unit , x , y ) ;
108454: LD_VAR 0 2
108458: PPUSH
108459: LD_VAR 0 4
108463: PPUSH
108464: LD_VAR 0 5
108468: PPUSH
108469: CALL 111796 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108473: LD_VAR 0 1
108477: PUSH
108478: LD_INT 252
108480: EQUAL
108481: PUSH
108482: LD_VAR 0 2
108486: PPUSH
108487: CALL_OW 264
108491: PUSH
108492: LD_INT 81
108494: EQUAL
108495: AND
108496: IFFALSE 108517
// MinerCreateMinefield ( unit , x , y ) ;
108498: LD_VAR 0 2
108502: PPUSH
108503: LD_VAR 0 4
108507: PPUSH
108508: LD_VAR 0 5
108512: PPUSH
108513: CALL 112213 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108517: LD_VAR 0 1
108521: PUSH
108522: LD_INT 253
108524: EQUAL
108525: PUSH
108526: LD_VAR 0 2
108530: PPUSH
108531: CALL_OW 257
108535: PUSH
108536: LD_INT 5
108538: EQUAL
108539: AND
108540: IFFALSE 108561
// ComBinocular ( unit , x , y ) ;
108542: LD_VAR 0 2
108546: PPUSH
108547: LD_VAR 0 4
108551: PPUSH
108552: LD_VAR 0 5
108556: PPUSH
108557: CALL 112582 0 3
// if selectedUnit then
108561: LD_VAR 0 3
108565: IFFALSE 108621
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108567: LD_VAR 0 1
108571: PUSH
108572: LD_INT 254
108574: EQUAL
108575: PUSH
108576: LD_VAR 0 2
108580: PPUSH
108581: CALL_OW 264
108585: PUSH
108586: LD_INT 99
108588: EQUAL
108589: AND
108590: PUSH
108591: LD_VAR 0 3
108595: PPUSH
108596: CALL_OW 263
108600: PUSH
108601: LD_INT 3
108603: EQUAL
108604: AND
108605: IFFALSE 108621
// HackDestroyVehicle ( unit , selectedUnit ) ;
108607: LD_VAR 0 2
108611: PPUSH
108612: LD_VAR 0 3
108616: PPUSH
108617: CALL 110885 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108621: LD_VAR 0 1
108625: PUSH
108626: LD_INT 255
108628: EQUAL
108629: PUSH
108630: LD_VAR 0 2
108634: PPUSH
108635: CALL_OW 264
108639: PUSH
108640: LD_INT 14
108642: PUSH
108643: LD_INT 53
108645: PUSH
108646: EMPTY
108647: LIST
108648: LIST
108649: IN
108650: AND
108651: PUSH
108652: LD_VAR 0 4
108656: PPUSH
108657: LD_VAR 0 5
108661: PPUSH
108662: CALL_OW 488
108666: AND
108667: IFFALSE 108691
// CutTreeXYR ( unit , x , y , 12 ) ;
108669: LD_VAR 0 2
108673: PPUSH
108674: LD_VAR 0 4
108678: PPUSH
108679: LD_VAR 0 5
108683: PPUSH
108684: LD_INT 12
108686: PPUSH
108687: CALL 108882 0 4
// if cmd = 256 then
108691: LD_VAR 0 1
108695: PUSH
108696: LD_INT 256
108698: EQUAL
108699: IFFALSE 108720
// SetFactoryWaypoint ( unit , x , y ) ;
108701: LD_VAR 0 2
108705: PPUSH
108706: LD_VAR 0 4
108710: PPUSH
108711: LD_VAR 0 5
108715: PPUSH
108716: CALL 106358 0 3
// if cmd = 257 then
108720: LD_VAR 0 1
108724: PUSH
108725: LD_INT 257
108727: EQUAL
108728: IFFALSE 108749
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108730: LD_VAR 0 2
108734: PPUSH
108735: LD_VAR 0 4
108739: PPUSH
108740: LD_VAR 0 5
108744: PPUSH
108745: CALL 106848 0 3
// if cmd = 258 then
108749: LD_VAR 0 1
108753: PUSH
108754: LD_INT 258
108756: EQUAL
108757: IFFALSE 108781
// BurnTreeXYR ( unit , x , y , 8 ) ;
108759: LD_VAR 0 2
108763: PPUSH
108764: LD_VAR 0 4
108768: PPUSH
108769: LD_VAR 0 5
108773: PPUSH
108774: LD_INT 8
108776: PPUSH
108777: CALL 109276 0 4
// end ;
108781: LD_VAR 0 6
108785: RET
// export function ComRadiation ( un ) ; var eff ; begin
108786: LD_INT 0
108788: PPUSH
108789: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
108790: LD_VAR 0 1
108794: PPUSH
108795: CALL_OW 264
108799: PUSH
108800: LD_INT 91
108802: NONEQUAL
108803: IFFALSE 108807
// exit ;
108805: GO 108877
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108807: LD_INT 68
108809: PPUSH
108810: LD_VAR 0 1
108814: PPUSH
108815: CALL_OW 255
108819: PPUSH
108820: CALL_OW 321
108824: PUSH
108825: LD_INT 2
108827: EQUAL
108828: IFFALSE 108840
// eff := 70 else
108830: LD_ADDR_VAR 0 3
108834: PUSH
108835: LD_INT 70
108837: ST_TO_ADDR
108838: GO 108848
// eff := 30 ;
108840: LD_ADDR_VAR 0 3
108844: PUSH
108845: LD_INT 30
108847: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108848: LD_VAR 0 1
108852: PPUSH
108853: CALL_OW 250
108857: PPUSH
108858: LD_VAR 0 1
108862: PPUSH
108863: CALL_OW 251
108867: PPUSH
108868: LD_VAR 0 3
108872: PPUSH
108873: CALL_OW 495
// end ;
108877: LD_VAR 0 2
108881: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108882: LD_INT 0
108884: PPUSH
108885: PPUSH
108886: PPUSH
108887: PPUSH
108888: PPUSH
108889: PPUSH
108890: PPUSH
108891: PPUSH
108892: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
108893: LD_VAR 0 1
108897: PPUSH
108898: CALL_OW 302
108902: NOT
108903: PUSH
108904: LD_VAR 0 2
108908: PPUSH
108909: LD_VAR 0 3
108913: PPUSH
108914: CALL_OW 488
108918: NOT
108919: OR
108920: PUSH
108921: LD_VAR 0 4
108925: NOT
108926: OR
108927: IFFALSE 108931
// exit ;
108929: GO 109271
// list := [ ] ;
108931: LD_ADDR_VAR 0 13
108935: PUSH
108936: EMPTY
108937: ST_TO_ADDR
// if x - r < 0 then
108938: LD_VAR 0 2
108942: PUSH
108943: LD_VAR 0 4
108947: MINUS
108948: PUSH
108949: LD_INT 0
108951: LESS
108952: IFFALSE 108964
// min_x := 0 else
108954: LD_ADDR_VAR 0 7
108958: PUSH
108959: LD_INT 0
108961: ST_TO_ADDR
108962: GO 108980
// min_x := x - r ;
108964: LD_ADDR_VAR 0 7
108968: PUSH
108969: LD_VAR 0 2
108973: PUSH
108974: LD_VAR 0 4
108978: MINUS
108979: ST_TO_ADDR
// if y - r < 0 then
108980: LD_VAR 0 3
108984: PUSH
108985: LD_VAR 0 4
108989: MINUS
108990: PUSH
108991: LD_INT 0
108993: LESS
108994: IFFALSE 109006
// min_y := 0 else
108996: LD_ADDR_VAR 0 8
109000: PUSH
109001: LD_INT 0
109003: ST_TO_ADDR
109004: GO 109022
// min_y := y - r ;
109006: LD_ADDR_VAR 0 8
109010: PUSH
109011: LD_VAR 0 3
109015: PUSH
109016: LD_VAR 0 4
109020: MINUS
109021: ST_TO_ADDR
// max_x := x + r ;
109022: LD_ADDR_VAR 0 9
109026: PUSH
109027: LD_VAR 0 2
109031: PUSH
109032: LD_VAR 0 4
109036: PLUS
109037: ST_TO_ADDR
// max_y := y + r ;
109038: LD_ADDR_VAR 0 10
109042: PUSH
109043: LD_VAR 0 3
109047: PUSH
109048: LD_VAR 0 4
109052: PLUS
109053: ST_TO_ADDR
// for _x = min_x to max_x do
109054: LD_ADDR_VAR 0 11
109058: PUSH
109059: DOUBLE
109060: LD_VAR 0 7
109064: DEC
109065: ST_TO_ADDR
109066: LD_VAR 0 9
109070: PUSH
109071: FOR_TO
109072: IFFALSE 109189
// for _y = min_y to max_y do
109074: LD_ADDR_VAR 0 12
109078: PUSH
109079: DOUBLE
109080: LD_VAR 0 8
109084: DEC
109085: ST_TO_ADDR
109086: LD_VAR 0 10
109090: PUSH
109091: FOR_TO
109092: IFFALSE 109185
// begin if not ValidHex ( _x , _y ) then
109094: LD_VAR 0 11
109098: PPUSH
109099: LD_VAR 0 12
109103: PPUSH
109104: CALL_OW 488
109108: NOT
109109: IFFALSE 109113
// continue ;
109111: GO 109091
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109113: LD_VAR 0 11
109117: PPUSH
109118: LD_VAR 0 12
109122: PPUSH
109123: CALL_OW 351
109127: PUSH
109128: LD_VAR 0 11
109132: PPUSH
109133: LD_VAR 0 12
109137: PPUSH
109138: CALL_OW 554
109142: AND
109143: IFFALSE 109183
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109145: LD_ADDR_VAR 0 13
109149: PUSH
109150: LD_VAR 0 13
109154: PPUSH
109155: LD_VAR 0 13
109159: PUSH
109160: LD_INT 1
109162: PLUS
109163: PPUSH
109164: LD_VAR 0 11
109168: PUSH
109169: LD_VAR 0 12
109173: PUSH
109174: EMPTY
109175: LIST
109176: LIST
109177: PPUSH
109178: CALL_OW 2
109182: ST_TO_ADDR
// end ;
109183: GO 109091
109185: POP
109186: POP
109187: GO 109071
109189: POP
109190: POP
// if not list then
109191: LD_VAR 0 13
109195: NOT
109196: IFFALSE 109200
// exit ;
109198: GO 109271
// for i in list do
109200: LD_ADDR_VAR 0 6
109204: PUSH
109205: LD_VAR 0 13
109209: PUSH
109210: FOR_IN
109211: IFFALSE 109269
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109213: LD_VAR 0 1
109217: PPUSH
109218: LD_STRING M
109220: PUSH
109221: LD_VAR 0 6
109225: PUSH
109226: LD_INT 1
109228: ARRAY
109229: PUSH
109230: LD_VAR 0 6
109234: PUSH
109235: LD_INT 2
109237: ARRAY
109238: PUSH
109239: LD_INT 0
109241: PUSH
109242: LD_INT 0
109244: PUSH
109245: LD_INT 0
109247: PUSH
109248: LD_INT 0
109250: PUSH
109251: EMPTY
109252: LIST
109253: LIST
109254: LIST
109255: LIST
109256: LIST
109257: LIST
109258: LIST
109259: PUSH
109260: EMPTY
109261: LIST
109262: PPUSH
109263: CALL_OW 447
109267: GO 109210
109269: POP
109270: POP
// end ;
109271: LD_VAR 0 5
109275: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
109276: LD_INT 0
109278: PPUSH
109279: PPUSH
109280: PPUSH
109281: PPUSH
109282: PPUSH
109283: PPUSH
109284: PPUSH
109285: PPUSH
109286: PPUSH
109287: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109288: LD_VAR 0 1
109292: PPUSH
109293: CALL_OW 302
109297: NOT
109298: PUSH
109299: LD_VAR 0 2
109303: PPUSH
109304: LD_VAR 0 3
109308: PPUSH
109309: CALL_OW 488
109313: NOT
109314: OR
109315: PUSH
109316: LD_VAR 0 4
109320: NOT
109321: OR
109322: IFFALSE 109326
// exit ;
109324: GO 109839
// list := [ ] ;
109326: LD_ADDR_VAR 0 13
109330: PUSH
109331: EMPTY
109332: ST_TO_ADDR
// if x - r < 0 then
109333: LD_VAR 0 2
109337: PUSH
109338: LD_VAR 0 4
109342: MINUS
109343: PUSH
109344: LD_INT 0
109346: LESS
109347: IFFALSE 109359
// min_x := 0 else
109349: LD_ADDR_VAR 0 7
109353: PUSH
109354: LD_INT 0
109356: ST_TO_ADDR
109357: GO 109375
// min_x := x - r ;
109359: LD_ADDR_VAR 0 7
109363: PUSH
109364: LD_VAR 0 2
109368: PUSH
109369: LD_VAR 0 4
109373: MINUS
109374: ST_TO_ADDR
// if y - r < 0 then
109375: LD_VAR 0 3
109379: PUSH
109380: LD_VAR 0 4
109384: MINUS
109385: PUSH
109386: LD_INT 0
109388: LESS
109389: IFFALSE 109401
// min_y := 0 else
109391: LD_ADDR_VAR 0 8
109395: PUSH
109396: LD_INT 0
109398: ST_TO_ADDR
109399: GO 109417
// min_y := y - r ;
109401: LD_ADDR_VAR 0 8
109405: PUSH
109406: LD_VAR 0 3
109410: PUSH
109411: LD_VAR 0 4
109415: MINUS
109416: ST_TO_ADDR
// max_x := x + r ;
109417: LD_ADDR_VAR 0 9
109421: PUSH
109422: LD_VAR 0 2
109426: PUSH
109427: LD_VAR 0 4
109431: PLUS
109432: ST_TO_ADDR
// max_y := y + r ;
109433: LD_ADDR_VAR 0 10
109437: PUSH
109438: LD_VAR 0 3
109442: PUSH
109443: LD_VAR 0 4
109447: PLUS
109448: ST_TO_ADDR
// for _x = min_x to max_x do
109449: LD_ADDR_VAR 0 11
109453: PUSH
109454: DOUBLE
109455: LD_VAR 0 7
109459: DEC
109460: ST_TO_ADDR
109461: LD_VAR 0 9
109465: PUSH
109466: FOR_TO
109467: IFFALSE 109584
// for _y = min_y to max_y do
109469: LD_ADDR_VAR 0 12
109473: PUSH
109474: DOUBLE
109475: LD_VAR 0 8
109479: DEC
109480: ST_TO_ADDR
109481: LD_VAR 0 10
109485: PUSH
109486: FOR_TO
109487: IFFALSE 109580
// begin if not ValidHex ( _x , _y ) then
109489: LD_VAR 0 11
109493: PPUSH
109494: LD_VAR 0 12
109498: PPUSH
109499: CALL_OW 488
109503: NOT
109504: IFFALSE 109508
// continue ;
109506: GO 109486
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109508: LD_VAR 0 11
109512: PPUSH
109513: LD_VAR 0 12
109517: PPUSH
109518: CALL_OW 351
109522: PUSH
109523: LD_VAR 0 11
109527: PPUSH
109528: LD_VAR 0 12
109532: PPUSH
109533: CALL_OW 554
109537: AND
109538: IFFALSE 109578
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109540: LD_ADDR_VAR 0 13
109544: PUSH
109545: LD_VAR 0 13
109549: PPUSH
109550: LD_VAR 0 13
109554: PUSH
109555: LD_INT 1
109557: PLUS
109558: PPUSH
109559: LD_VAR 0 11
109563: PUSH
109564: LD_VAR 0 12
109568: PUSH
109569: EMPTY
109570: LIST
109571: LIST
109572: PPUSH
109573: CALL_OW 2
109577: ST_TO_ADDR
// end ;
109578: GO 109486
109580: POP
109581: POP
109582: GO 109466
109584: POP
109585: POP
// if not list then
109586: LD_VAR 0 13
109590: NOT
109591: IFFALSE 109595
// exit ;
109593: GO 109839
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109595: LD_ADDR_VAR 0 13
109599: PUSH
109600: LD_VAR 0 1
109604: PPUSH
109605: LD_VAR 0 13
109609: PPUSH
109610: LD_INT 1
109612: PPUSH
109613: LD_INT 1
109615: PPUSH
109616: CALL 54499 0 4
109620: ST_TO_ADDR
// ComStop ( flame ) ;
109621: LD_VAR 0 1
109625: PPUSH
109626: CALL_OW 141
// for i in list do
109630: LD_ADDR_VAR 0 6
109634: PUSH
109635: LD_VAR 0 13
109639: PUSH
109640: FOR_IN
109641: IFFALSE 109672
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109643: LD_VAR 0 1
109647: PPUSH
109648: LD_VAR 0 6
109652: PUSH
109653: LD_INT 1
109655: ARRAY
109656: PPUSH
109657: LD_VAR 0 6
109661: PUSH
109662: LD_INT 2
109664: ARRAY
109665: PPUSH
109666: CALL_OW 176
109670: GO 109640
109672: POP
109673: POP
// repeat wait ( 0 0$1 ) ;
109674: LD_INT 35
109676: PPUSH
109677: CALL_OW 67
// task := GetTaskList ( flame ) ;
109681: LD_ADDR_VAR 0 14
109685: PUSH
109686: LD_VAR 0 1
109690: PPUSH
109691: CALL_OW 437
109695: ST_TO_ADDR
// if not task then
109696: LD_VAR 0 14
109700: NOT
109701: IFFALSE 109705
// exit ;
109703: GO 109839
// if task [ 1 ] [ 1 ] <> | then
109705: LD_VAR 0 14
109709: PUSH
109710: LD_INT 1
109712: ARRAY
109713: PUSH
109714: LD_INT 1
109716: ARRAY
109717: PUSH
109718: LD_STRING |
109720: NONEQUAL
109721: IFFALSE 109725
// exit ;
109723: GO 109839
// _x := task [ 1 ] [ 2 ] ;
109725: LD_ADDR_VAR 0 11
109729: PUSH
109730: LD_VAR 0 14
109734: PUSH
109735: LD_INT 1
109737: ARRAY
109738: PUSH
109739: LD_INT 2
109741: ARRAY
109742: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
109743: LD_ADDR_VAR 0 12
109747: PUSH
109748: LD_VAR 0 14
109752: PUSH
109753: LD_INT 1
109755: ARRAY
109756: PUSH
109757: LD_INT 3
109759: ARRAY
109760: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
109761: LD_VAR 0 11
109765: PPUSH
109766: LD_VAR 0 12
109770: PPUSH
109771: CALL_OW 351
109775: NOT
109776: PUSH
109777: LD_VAR 0 11
109781: PPUSH
109782: LD_VAR 0 12
109786: PPUSH
109787: CALL_OW 554
109791: NOT
109792: OR
109793: IFFALSE 109827
// begin task := Delete ( task , 1 ) ;
109795: LD_ADDR_VAR 0 14
109799: PUSH
109800: LD_VAR 0 14
109804: PPUSH
109805: LD_INT 1
109807: PPUSH
109808: CALL_OW 3
109812: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
109813: LD_VAR 0 1
109817: PPUSH
109818: LD_VAR 0 14
109822: PPUSH
109823: CALL_OW 446
// end ; until not HasTask ( flame ) ;
109827: LD_VAR 0 1
109831: PPUSH
109832: CALL_OW 314
109836: NOT
109837: IFFALSE 109674
// end ;
109839: LD_VAR 0 5
109843: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109844: LD_EXP 157
109848: NOT
109849: IFFALSE 109899
109851: GO 109853
109853: DISABLE
// begin initHack := true ;
109854: LD_ADDR_EXP 157
109858: PUSH
109859: LD_INT 1
109861: ST_TO_ADDR
// hackTanks := [ ] ;
109862: LD_ADDR_EXP 158
109866: PUSH
109867: EMPTY
109868: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109869: LD_ADDR_EXP 159
109873: PUSH
109874: EMPTY
109875: ST_TO_ADDR
// hackLimit := 3 ;
109876: LD_ADDR_EXP 160
109880: PUSH
109881: LD_INT 3
109883: ST_TO_ADDR
// hackDist := 12 ;
109884: LD_ADDR_EXP 161
109888: PUSH
109889: LD_INT 12
109891: ST_TO_ADDR
// hackCounter := [ ] ;
109892: LD_ADDR_EXP 162
109896: PUSH
109897: EMPTY
109898: ST_TO_ADDR
// end ;
109899: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109900: LD_EXP 157
109904: PUSH
109905: LD_INT 34
109907: PUSH
109908: LD_INT 99
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: PPUSH
109915: CALL_OW 69
109919: AND
109920: IFFALSE 110173
109922: GO 109924
109924: DISABLE
109925: LD_INT 0
109927: PPUSH
109928: PPUSH
// begin enable ;
109929: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109930: LD_ADDR_VAR 0 1
109934: PUSH
109935: LD_INT 34
109937: PUSH
109938: LD_INT 99
109940: PUSH
109941: EMPTY
109942: LIST
109943: LIST
109944: PPUSH
109945: CALL_OW 69
109949: PUSH
109950: FOR_IN
109951: IFFALSE 110171
// begin if not i in hackTanks then
109953: LD_VAR 0 1
109957: PUSH
109958: LD_EXP 158
109962: IN
109963: NOT
109964: IFFALSE 110047
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109966: LD_ADDR_EXP 158
109970: PUSH
109971: LD_EXP 158
109975: PPUSH
109976: LD_EXP 158
109980: PUSH
109981: LD_INT 1
109983: PLUS
109984: PPUSH
109985: LD_VAR 0 1
109989: PPUSH
109990: CALL_OW 1
109994: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109995: LD_ADDR_EXP 159
109999: PUSH
110000: LD_EXP 159
110004: PPUSH
110005: LD_EXP 159
110009: PUSH
110010: LD_INT 1
110012: PLUS
110013: PPUSH
110014: EMPTY
110015: PPUSH
110016: CALL_OW 1
110020: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110021: LD_ADDR_EXP 162
110025: PUSH
110026: LD_EXP 162
110030: PPUSH
110031: LD_EXP 162
110035: PUSH
110036: LD_INT 1
110038: PLUS
110039: PPUSH
110040: EMPTY
110041: PPUSH
110042: CALL_OW 1
110046: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110047: LD_VAR 0 1
110051: PPUSH
110052: CALL_OW 302
110056: NOT
110057: IFFALSE 110070
// begin HackUnlinkAll ( i ) ;
110059: LD_VAR 0 1
110063: PPUSH
110064: CALL 110176 0 1
// continue ;
110068: GO 109950
// end ; HackCheckCapturedStatus ( i ) ;
110070: LD_VAR 0 1
110074: PPUSH
110075: CALL 110619 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110079: LD_ADDR_VAR 0 2
110083: PUSH
110084: LD_INT 81
110086: PUSH
110087: LD_VAR 0 1
110091: PPUSH
110092: CALL_OW 255
110096: PUSH
110097: EMPTY
110098: LIST
110099: LIST
110100: PUSH
110101: LD_INT 33
110103: PUSH
110104: LD_INT 3
110106: PUSH
110107: EMPTY
110108: LIST
110109: LIST
110110: PUSH
110111: LD_INT 91
110113: PUSH
110114: LD_VAR 0 1
110118: PUSH
110119: LD_EXP 161
110123: PUSH
110124: EMPTY
110125: LIST
110126: LIST
110127: LIST
110128: PUSH
110129: LD_INT 50
110131: PUSH
110132: EMPTY
110133: LIST
110134: PUSH
110135: EMPTY
110136: LIST
110137: LIST
110138: LIST
110139: LIST
110140: PPUSH
110141: CALL_OW 69
110145: ST_TO_ADDR
// if not tmp then
110146: LD_VAR 0 2
110150: NOT
110151: IFFALSE 110155
// continue ;
110153: GO 109950
// HackLink ( i , tmp ) ;
110155: LD_VAR 0 1
110159: PPUSH
110160: LD_VAR 0 2
110164: PPUSH
110165: CALL 110312 0 2
// end ;
110169: GO 109950
110171: POP
110172: POP
// end ;
110173: PPOPN 2
110175: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110176: LD_INT 0
110178: PPUSH
110179: PPUSH
110180: PPUSH
// if not hack in hackTanks then
110181: LD_VAR 0 1
110185: PUSH
110186: LD_EXP 158
110190: IN
110191: NOT
110192: IFFALSE 110196
// exit ;
110194: GO 110307
// index := GetElementIndex ( hackTanks , hack ) ;
110196: LD_ADDR_VAR 0 4
110200: PUSH
110201: LD_EXP 158
110205: PPUSH
110206: LD_VAR 0 1
110210: PPUSH
110211: CALL 53796 0 2
110215: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110216: LD_EXP 159
110220: PUSH
110221: LD_VAR 0 4
110225: ARRAY
110226: IFFALSE 110307
// begin for i in hackTanksCaptured [ index ] do
110228: LD_ADDR_VAR 0 3
110232: PUSH
110233: LD_EXP 159
110237: PUSH
110238: LD_VAR 0 4
110242: ARRAY
110243: PUSH
110244: FOR_IN
110245: IFFALSE 110271
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110247: LD_VAR 0 3
110251: PUSH
110252: LD_INT 1
110254: ARRAY
110255: PPUSH
110256: LD_VAR 0 3
110260: PUSH
110261: LD_INT 2
110263: ARRAY
110264: PPUSH
110265: CALL_OW 235
110269: GO 110244
110271: POP
110272: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110273: LD_ADDR_EXP 159
110277: PUSH
110278: LD_EXP 159
110282: PPUSH
110283: LD_VAR 0 4
110287: PPUSH
110288: EMPTY
110289: PPUSH
110290: CALL_OW 1
110294: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110295: LD_VAR 0 1
110299: PPUSH
110300: LD_INT 0
110302: PPUSH
110303: CALL_OW 505
// end ; end ;
110307: LD_VAR 0 2
110311: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110312: LD_INT 0
110314: PPUSH
110315: PPUSH
110316: PPUSH
// if not hack in hackTanks or not vehicles then
110317: LD_VAR 0 1
110321: PUSH
110322: LD_EXP 158
110326: IN
110327: NOT
110328: PUSH
110329: LD_VAR 0 2
110333: NOT
110334: OR
110335: IFFALSE 110339
// exit ;
110337: GO 110614
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110339: LD_ADDR_VAR 0 2
110343: PUSH
110344: LD_VAR 0 1
110348: PPUSH
110349: LD_VAR 0 2
110353: PPUSH
110354: LD_INT 1
110356: PPUSH
110357: LD_INT 1
110359: PPUSH
110360: CALL 54446 0 4
110364: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110365: LD_ADDR_VAR 0 5
110369: PUSH
110370: LD_EXP 158
110374: PPUSH
110375: LD_VAR 0 1
110379: PPUSH
110380: CALL 53796 0 2
110384: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110385: LD_EXP 159
110389: PUSH
110390: LD_VAR 0 5
110394: ARRAY
110395: PUSH
110396: LD_EXP 160
110400: LESS
110401: IFFALSE 110590
// begin for i := 1 to vehicles do
110403: LD_ADDR_VAR 0 4
110407: PUSH
110408: DOUBLE
110409: LD_INT 1
110411: DEC
110412: ST_TO_ADDR
110413: LD_VAR 0 2
110417: PUSH
110418: FOR_TO
110419: IFFALSE 110588
// begin if hackTanksCaptured [ index ] = hackLimit then
110421: LD_EXP 159
110425: PUSH
110426: LD_VAR 0 5
110430: ARRAY
110431: PUSH
110432: LD_EXP 160
110436: EQUAL
110437: IFFALSE 110441
// break ;
110439: GO 110588
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110441: LD_ADDR_EXP 162
110445: PUSH
110446: LD_EXP 162
110450: PPUSH
110451: LD_VAR 0 5
110455: PPUSH
110456: LD_EXP 162
110460: PUSH
110461: LD_VAR 0 5
110465: ARRAY
110466: PUSH
110467: LD_INT 1
110469: PLUS
110470: PPUSH
110471: CALL_OW 1
110475: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110476: LD_ADDR_EXP 159
110480: PUSH
110481: LD_EXP 159
110485: PPUSH
110486: LD_VAR 0 5
110490: PUSH
110491: LD_EXP 159
110495: PUSH
110496: LD_VAR 0 5
110500: ARRAY
110501: PUSH
110502: LD_INT 1
110504: PLUS
110505: PUSH
110506: EMPTY
110507: LIST
110508: LIST
110509: PPUSH
110510: LD_VAR 0 2
110514: PUSH
110515: LD_VAR 0 4
110519: ARRAY
110520: PUSH
110521: LD_VAR 0 2
110525: PUSH
110526: LD_VAR 0 4
110530: ARRAY
110531: PPUSH
110532: CALL_OW 255
110536: PUSH
110537: EMPTY
110538: LIST
110539: LIST
110540: PPUSH
110541: CALL 54011 0 3
110545: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110546: LD_VAR 0 2
110550: PUSH
110551: LD_VAR 0 4
110555: ARRAY
110556: PPUSH
110557: LD_VAR 0 1
110561: PPUSH
110562: CALL_OW 255
110566: PPUSH
110567: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110571: LD_VAR 0 2
110575: PUSH
110576: LD_VAR 0 4
110580: ARRAY
110581: PPUSH
110582: CALL_OW 141
// end ;
110586: GO 110418
110588: POP
110589: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110590: LD_VAR 0 1
110594: PPUSH
110595: LD_EXP 159
110599: PUSH
110600: LD_VAR 0 5
110604: ARRAY
110605: PUSH
110606: LD_INT 0
110608: PLUS
110609: PPUSH
110610: CALL_OW 505
// end ;
110614: LD_VAR 0 3
110618: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110619: LD_INT 0
110621: PPUSH
110622: PPUSH
110623: PPUSH
110624: PPUSH
// if not hack in hackTanks then
110625: LD_VAR 0 1
110629: PUSH
110630: LD_EXP 158
110634: IN
110635: NOT
110636: IFFALSE 110640
// exit ;
110638: GO 110880
// index := GetElementIndex ( hackTanks , hack ) ;
110640: LD_ADDR_VAR 0 4
110644: PUSH
110645: LD_EXP 158
110649: PPUSH
110650: LD_VAR 0 1
110654: PPUSH
110655: CALL 53796 0 2
110659: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110660: LD_ADDR_VAR 0 3
110664: PUSH
110665: DOUBLE
110666: LD_EXP 159
110670: PUSH
110671: LD_VAR 0 4
110675: ARRAY
110676: INC
110677: ST_TO_ADDR
110678: LD_INT 1
110680: PUSH
110681: FOR_DOWNTO
110682: IFFALSE 110854
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110684: LD_ADDR_VAR 0 5
110688: PUSH
110689: LD_EXP 159
110693: PUSH
110694: LD_VAR 0 4
110698: ARRAY
110699: PUSH
110700: LD_VAR 0 3
110704: ARRAY
110705: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110706: LD_VAR 0 5
110710: PUSH
110711: LD_INT 1
110713: ARRAY
110714: PPUSH
110715: CALL_OW 302
110719: NOT
110720: PUSH
110721: LD_VAR 0 5
110725: PUSH
110726: LD_INT 1
110728: ARRAY
110729: PPUSH
110730: CALL_OW 255
110734: PUSH
110735: LD_VAR 0 1
110739: PPUSH
110740: CALL_OW 255
110744: NONEQUAL
110745: OR
110746: IFFALSE 110852
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110748: LD_VAR 0 5
110752: PUSH
110753: LD_INT 1
110755: ARRAY
110756: PPUSH
110757: CALL_OW 305
110761: PUSH
110762: LD_VAR 0 5
110766: PUSH
110767: LD_INT 1
110769: ARRAY
110770: PPUSH
110771: CALL_OW 255
110775: PUSH
110776: LD_VAR 0 1
110780: PPUSH
110781: CALL_OW 255
110785: EQUAL
110786: AND
110787: IFFALSE 110811
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110789: LD_VAR 0 5
110793: PUSH
110794: LD_INT 1
110796: ARRAY
110797: PPUSH
110798: LD_VAR 0 5
110802: PUSH
110803: LD_INT 2
110805: ARRAY
110806: PPUSH
110807: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110811: LD_ADDR_EXP 159
110815: PUSH
110816: LD_EXP 159
110820: PPUSH
110821: LD_VAR 0 4
110825: PPUSH
110826: LD_EXP 159
110830: PUSH
110831: LD_VAR 0 4
110835: ARRAY
110836: PPUSH
110837: LD_VAR 0 3
110841: PPUSH
110842: CALL_OW 3
110846: PPUSH
110847: CALL_OW 1
110851: ST_TO_ADDR
// end ; end ;
110852: GO 110681
110854: POP
110855: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110856: LD_VAR 0 1
110860: PPUSH
110861: LD_EXP 159
110865: PUSH
110866: LD_VAR 0 4
110870: ARRAY
110871: PUSH
110872: LD_INT 0
110874: PLUS
110875: PPUSH
110876: CALL_OW 505
// end ;
110880: LD_VAR 0 2
110884: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110885: LD_INT 0
110887: PPUSH
110888: PPUSH
110889: PPUSH
110890: PPUSH
// if not hack in hackTanks then
110891: LD_VAR 0 1
110895: PUSH
110896: LD_EXP 158
110900: IN
110901: NOT
110902: IFFALSE 110906
// exit ;
110904: GO 110991
// index := GetElementIndex ( hackTanks , hack ) ;
110906: LD_ADDR_VAR 0 5
110910: PUSH
110911: LD_EXP 158
110915: PPUSH
110916: LD_VAR 0 1
110920: PPUSH
110921: CALL 53796 0 2
110925: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110926: LD_ADDR_VAR 0 4
110930: PUSH
110931: DOUBLE
110932: LD_INT 1
110934: DEC
110935: ST_TO_ADDR
110936: LD_EXP 159
110940: PUSH
110941: LD_VAR 0 5
110945: ARRAY
110946: PUSH
110947: FOR_TO
110948: IFFALSE 110989
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110950: LD_EXP 159
110954: PUSH
110955: LD_VAR 0 5
110959: ARRAY
110960: PUSH
110961: LD_VAR 0 4
110965: ARRAY
110966: PUSH
110967: LD_INT 1
110969: ARRAY
110970: PUSH
110971: LD_VAR 0 2
110975: EQUAL
110976: IFFALSE 110987
// KillUnit ( vehicle ) ;
110978: LD_VAR 0 2
110982: PPUSH
110983: CALL_OW 66
110987: GO 110947
110989: POP
110990: POP
// end ;
110991: LD_VAR 0 3
110995: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110996: LD_EXP 163
111000: NOT
111001: IFFALSE 111036
111003: GO 111005
111005: DISABLE
// begin initMiner := true ;
111006: LD_ADDR_EXP 163
111010: PUSH
111011: LD_INT 1
111013: ST_TO_ADDR
// minersList := [ ] ;
111014: LD_ADDR_EXP 164
111018: PUSH
111019: EMPTY
111020: ST_TO_ADDR
// minerMinesList := [ ] ;
111021: LD_ADDR_EXP 165
111025: PUSH
111026: EMPTY
111027: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111028: LD_ADDR_EXP 166
111032: PUSH
111033: LD_INT 5
111035: ST_TO_ADDR
// end ;
111036: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111037: LD_EXP 163
111041: PUSH
111042: LD_INT 34
111044: PUSH
111045: LD_INT 81
111047: PUSH
111048: EMPTY
111049: LIST
111050: LIST
111051: PPUSH
111052: CALL_OW 69
111056: AND
111057: IFFALSE 111518
111059: GO 111061
111061: DISABLE
111062: LD_INT 0
111064: PPUSH
111065: PPUSH
111066: PPUSH
111067: PPUSH
// begin enable ;
111068: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111069: LD_ADDR_VAR 0 1
111073: PUSH
111074: LD_INT 34
111076: PUSH
111077: LD_INT 81
111079: PUSH
111080: EMPTY
111081: LIST
111082: LIST
111083: PPUSH
111084: CALL_OW 69
111088: PUSH
111089: FOR_IN
111090: IFFALSE 111162
// begin if not i in minersList then
111092: LD_VAR 0 1
111096: PUSH
111097: LD_EXP 164
111101: IN
111102: NOT
111103: IFFALSE 111160
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111105: LD_ADDR_EXP 164
111109: PUSH
111110: LD_EXP 164
111114: PPUSH
111115: LD_EXP 164
111119: PUSH
111120: LD_INT 1
111122: PLUS
111123: PPUSH
111124: LD_VAR 0 1
111128: PPUSH
111129: CALL_OW 1
111133: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111134: LD_ADDR_EXP 165
111138: PUSH
111139: LD_EXP 165
111143: PPUSH
111144: LD_EXP 165
111148: PUSH
111149: LD_INT 1
111151: PLUS
111152: PPUSH
111153: EMPTY
111154: PPUSH
111155: CALL_OW 1
111159: ST_TO_ADDR
// end end ;
111160: GO 111089
111162: POP
111163: POP
// for i := minerMinesList downto 1 do
111164: LD_ADDR_VAR 0 1
111168: PUSH
111169: DOUBLE
111170: LD_EXP 165
111174: INC
111175: ST_TO_ADDR
111176: LD_INT 1
111178: PUSH
111179: FOR_DOWNTO
111180: IFFALSE 111516
// begin if IsLive ( minersList [ i ] ) then
111182: LD_EXP 164
111186: PUSH
111187: LD_VAR 0 1
111191: ARRAY
111192: PPUSH
111193: CALL_OW 300
111197: IFFALSE 111225
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111199: LD_EXP 164
111203: PUSH
111204: LD_VAR 0 1
111208: ARRAY
111209: PPUSH
111210: LD_EXP 165
111214: PUSH
111215: LD_VAR 0 1
111219: ARRAY
111220: PPUSH
111221: CALL_OW 505
// if not minerMinesList [ i ] then
111225: LD_EXP 165
111229: PUSH
111230: LD_VAR 0 1
111234: ARRAY
111235: NOT
111236: IFFALSE 111240
// continue ;
111238: GO 111179
// for j := minerMinesList [ i ] downto 1 do
111240: LD_ADDR_VAR 0 2
111244: PUSH
111245: DOUBLE
111246: LD_EXP 165
111250: PUSH
111251: LD_VAR 0 1
111255: ARRAY
111256: INC
111257: ST_TO_ADDR
111258: LD_INT 1
111260: PUSH
111261: FOR_DOWNTO
111262: IFFALSE 111512
// begin side := GetSide ( minersList [ i ] ) ;
111264: LD_ADDR_VAR 0 3
111268: PUSH
111269: LD_EXP 164
111273: PUSH
111274: LD_VAR 0 1
111278: ARRAY
111279: PPUSH
111280: CALL_OW 255
111284: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111285: LD_ADDR_VAR 0 4
111289: PUSH
111290: LD_EXP 165
111294: PUSH
111295: LD_VAR 0 1
111299: ARRAY
111300: PUSH
111301: LD_VAR 0 2
111305: ARRAY
111306: PUSH
111307: LD_INT 1
111309: ARRAY
111310: PPUSH
111311: LD_EXP 165
111315: PUSH
111316: LD_VAR 0 1
111320: ARRAY
111321: PUSH
111322: LD_VAR 0 2
111326: ARRAY
111327: PUSH
111328: LD_INT 2
111330: ARRAY
111331: PPUSH
111332: CALL_OW 428
111336: ST_TO_ADDR
// if not tmp then
111337: LD_VAR 0 4
111341: NOT
111342: IFFALSE 111346
// continue ;
111344: GO 111261
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111346: LD_VAR 0 4
111350: PUSH
111351: LD_INT 81
111353: PUSH
111354: LD_VAR 0 3
111358: PUSH
111359: EMPTY
111360: LIST
111361: LIST
111362: PPUSH
111363: CALL_OW 69
111367: IN
111368: PUSH
111369: LD_EXP 165
111373: PUSH
111374: LD_VAR 0 1
111378: ARRAY
111379: PUSH
111380: LD_VAR 0 2
111384: ARRAY
111385: PUSH
111386: LD_INT 1
111388: ARRAY
111389: PPUSH
111390: LD_EXP 165
111394: PUSH
111395: LD_VAR 0 1
111399: ARRAY
111400: PUSH
111401: LD_VAR 0 2
111405: ARRAY
111406: PUSH
111407: LD_INT 2
111409: ARRAY
111410: PPUSH
111411: CALL_OW 458
111415: AND
111416: IFFALSE 111510
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111418: LD_EXP 165
111422: PUSH
111423: LD_VAR 0 1
111427: ARRAY
111428: PUSH
111429: LD_VAR 0 2
111433: ARRAY
111434: PUSH
111435: LD_INT 1
111437: ARRAY
111438: PPUSH
111439: LD_EXP 165
111443: PUSH
111444: LD_VAR 0 1
111448: ARRAY
111449: PUSH
111450: LD_VAR 0 2
111454: ARRAY
111455: PUSH
111456: LD_INT 2
111458: ARRAY
111459: PPUSH
111460: LD_VAR 0 3
111464: PPUSH
111465: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111469: LD_ADDR_EXP 165
111473: PUSH
111474: LD_EXP 165
111478: PPUSH
111479: LD_VAR 0 1
111483: PPUSH
111484: LD_EXP 165
111488: PUSH
111489: LD_VAR 0 1
111493: ARRAY
111494: PPUSH
111495: LD_VAR 0 2
111499: PPUSH
111500: CALL_OW 3
111504: PPUSH
111505: CALL_OW 1
111509: ST_TO_ADDR
// end ; end ;
111510: GO 111261
111512: POP
111513: POP
// end ;
111514: GO 111179
111516: POP
111517: POP
// end ;
111518: PPOPN 4
111520: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111521: LD_INT 0
111523: PPUSH
111524: PPUSH
// result := false ;
111525: LD_ADDR_VAR 0 4
111529: PUSH
111530: LD_INT 0
111532: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111533: LD_VAR 0 1
111537: PPUSH
111538: CALL_OW 264
111542: PUSH
111543: LD_INT 81
111545: EQUAL
111546: NOT
111547: IFFALSE 111551
// exit ;
111549: GO 111791
// index := GetElementIndex ( minersList , unit ) ;
111551: LD_ADDR_VAR 0 5
111555: PUSH
111556: LD_EXP 164
111560: PPUSH
111561: LD_VAR 0 1
111565: PPUSH
111566: CALL 53796 0 2
111570: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111571: LD_EXP 165
111575: PUSH
111576: LD_VAR 0 5
111580: ARRAY
111581: PUSH
111582: LD_EXP 166
111586: GREATEREQUAL
111587: IFFALSE 111591
// exit ;
111589: GO 111791
// ComMoveXY ( unit , x , y ) ;
111591: LD_VAR 0 1
111595: PPUSH
111596: LD_VAR 0 2
111600: PPUSH
111601: LD_VAR 0 3
111605: PPUSH
111606: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111610: LD_INT 35
111612: PPUSH
111613: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111617: LD_VAR 0 1
111621: PPUSH
111622: LD_VAR 0 2
111626: PPUSH
111627: LD_VAR 0 3
111631: PPUSH
111632: CALL 85557 0 3
111636: NOT
111637: PUSH
111638: LD_VAR 0 1
111642: PPUSH
111643: CALL_OW 314
111647: AND
111648: IFFALSE 111652
// exit ;
111650: GO 111791
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111652: LD_VAR 0 2
111656: PPUSH
111657: LD_VAR 0 3
111661: PPUSH
111662: CALL_OW 428
111666: PUSH
111667: LD_VAR 0 1
111671: EQUAL
111672: PUSH
111673: LD_VAR 0 1
111677: PPUSH
111678: CALL_OW 314
111682: NOT
111683: AND
111684: IFFALSE 111610
// PlaySoundXY ( x , y , PlantMine ) ;
111686: LD_VAR 0 2
111690: PPUSH
111691: LD_VAR 0 3
111695: PPUSH
111696: LD_STRING PlantMine
111698: PPUSH
111699: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111703: LD_VAR 0 2
111707: PPUSH
111708: LD_VAR 0 3
111712: PPUSH
111713: LD_VAR 0 1
111717: PPUSH
111718: CALL_OW 255
111722: PPUSH
111723: LD_INT 0
111725: PPUSH
111726: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111730: LD_ADDR_EXP 165
111734: PUSH
111735: LD_EXP 165
111739: PPUSH
111740: LD_VAR 0 5
111744: PUSH
111745: LD_EXP 165
111749: PUSH
111750: LD_VAR 0 5
111754: ARRAY
111755: PUSH
111756: LD_INT 1
111758: PLUS
111759: PUSH
111760: EMPTY
111761: LIST
111762: LIST
111763: PPUSH
111764: LD_VAR 0 2
111768: PUSH
111769: LD_VAR 0 3
111773: PUSH
111774: EMPTY
111775: LIST
111776: LIST
111777: PPUSH
111778: CALL 54011 0 3
111782: ST_TO_ADDR
// result := true ;
111783: LD_ADDR_VAR 0 4
111787: PUSH
111788: LD_INT 1
111790: ST_TO_ADDR
// end ;
111791: LD_VAR 0 4
111795: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111796: LD_INT 0
111798: PPUSH
111799: PPUSH
111800: PPUSH
// if not unit in minersList then
111801: LD_VAR 0 1
111805: PUSH
111806: LD_EXP 164
111810: IN
111811: NOT
111812: IFFALSE 111816
// exit ;
111814: GO 112208
// index := GetElementIndex ( minersList , unit ) ;
111816: LD_ADDR_VAR 0 6
111820: PUSH
111821: LD_EXP 164
111825: PPUSH
111826: LD_VAR 0 1
111830: PPUSH
111831: CALL 53796 0 2
111835: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111836: LD_ADDR_VAR 0 5
111840: PUSH
111841: DOUBLE
111842: LD_EXP 165
111846: PUSH
111847: LD_VAR 0 6
111851: ARRAY
111852: INC
111853: ST_TO_ADDR
111854: LD_INT 1
111856: PUSH
111857: FOR_DOWNTO
111858: IFFALSE 112019
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111860: LD_EXP 165
111864: PUSH
111865: LD_VAR 0 6
111869: ARRAY
111870: PUSH
111871: LD_VAR 0 5
111875: ARRAY
111876: PUSH
111877: LD_INT 1
111879: ARRAY
111880: PUSH
111881: LD_VAR 0 2
111885: EQUAL
111886: PUSH
111887: LD_EXP 165
111891: PUSH
111892: LD_VAR 0 6
111896: ARRAY
111897: PUSH
111898: LD_VAR 0 5
111902: ARRAY
111903: PUSH
111904: LD_INT 2
111906: ARRAY
111907: PUSH
111908: LD_VAR 0 3
111912: EQUAL
111913: AND
111914: IFFALSE 112017
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111916: LD_EXP 165
111920: PUSH
111921: LD_VAR 0 6
111925: ARRAY
111926: PUSH
111927: LD_VAR 0 5
111931: ARRAY
111932: PUSH
111933: LD_INT 1
111935: ARRAY
111936: PPUSH
111937: LD_EXP 165
111941: PUSH
111942: LD_VAR 0 6
111946: ARRAY
111947: PUSH
111948: LD_VAR 0 5
111952: ARRAY
111953: PUSH
111954: LD_INT 2
111956: ARRAY
111957: PPUSH
111958: LD_VAR 0 1
111962: PPUSH
111963: CALL_OW 255
111967: PPUSH
111968: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111972: LD_ADDR_EXP 165
111976: PUSH
111977: LD_EXP 165
111981: PPUSH
111982: LD_VAR 0 6
111986: PPUSH
111987: LD_EXP 165
111991: PUSH
111992: LD_VAR 0 6
111996: ARRAY
111997: PPUSH
111998: LD_VAR 0 5
112002: PPUSH
112003: CALL_OW 3
112007: PPUSH
112008: CALL_OW 1
112012: ST_TO_ADDR
// exit ;
112013: POP
112014: POP
112015: GO 112208
// end ; end ;
112017: GO 111857
112019: POP
112020: POP
// for i := minerMinesList [ index ] downto 1 do
112021: LD_ADDR_VAR 0 5
112025: PUSH
112026: DOUBLE
112027: LD_EXP 165
112031: PUSH
112032: LD_VAR 0 6
112036: ARRAY
112037: INC
112038: ST_TO_ADDR
112039: LD_INT 1
112041: PUSH
112042: FOR_DOWNTO
112043: IFFALSE 112206
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112045: LD_EXP 165
112049: PUSH
112050: LD_VAR 0 6
112054: ARRAY
112055: PUSH
112056: LD_VAR 0 5
112060: ARRAY
112061: PUSH
112062: LD_INT 1
112064: ARRAY
112065: PPUSH
112066: LD_EXP 165
112070: PUSH
112071: LD_VAR 0 6
112075: ARRAY
112076: PUSH
112077: LD_VAR 0 5
112081: ARRAY
112082: PUSH
112083: LD_INT 2
112085: ARRAY
112086: PPUSH
112087: LD_VAR 0 2
112091: PPUSH
112092: LD_VAR 0 3
112096: PPUSH
112097: CALL_OW 298
112101: PUSH
112102: LD_INT 6
112104: LESS
112105: IFFALSE 112204
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112107: LD_EXP 165
112111: PUSH
112112: LD_VAR 0 6
112116: ARRAY
112117: PUSH
112118: LD_VAR 0 5
112122: ARRAY
112123: PUSH
112124: LD_INT 1
112126: ARRAY
112127: PPUSH
112128: LD_EXP 165
112132: PUSH
112133: LD_VAR 0 6
112137: ARRAY
112138: PUSH
112139: LD_VAR 0 5
112143: ARRAY
112144: PUSH
112145: LD_INT 2
112147: ARRAY
112148: PPUSH
112149: LD_VAR 0 1
112153: PPUSH
112154: CALL_OW 255
112158: PPUSH
112159: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112163: LD_ADDR_EXP 165
112167: PUSH
112168: LD_EXP 165
112172: PPUSH
112173: LD_VAR 0 6
112177: PPUSH
112178: LD_EXP 165
112182: PUSH
112183: LD_VAR 0 6
112187: ARRAY
112188: PPUSH
112189: LD_VAR 0 5
112193: PPUSH
112194: CALL_OW 3
112198: PPUSH
112199: CALL_OW 1
112203: ST_TO_ADDR
// end ; end ;
112204: GO 112042
112206: POP
112207: POP
// end ;
112208: LD_VAR 0 4
112212: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112213: LD_INT 0
112215: PPUSH
112216: PPUSH
112217: PPUSH
112218: PPUSH
112219: PPUSH
112220: PPUSH
112221: PPUSH
112222: PPUSH
112223: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112224: LD_VAR 0 1
112228: PPUSH
112229: CALL_OW 264
112233: PUSH
112234: LD_INT 81
112236: EQUAL
112237: NOT
112238: PUSH
112239: LD_VAR 0 1
112243: PUSH
112244: LD_EXP 164
112248: IN
112249: NOT
112250: OR
112251: IFFALSE 112255
// exit ;
112253: GO 112577
// index := GetElementIndex ( minersList , unit ) ;
112255: LD_ADDR_VAR 0 6
112259: PUSH
112260: LD_EXP 164
112264: PPUSH
112265: LD_VAR 0 1
112269: PPUSH
112270: CALL 53796 0 2
112274: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112275: LD_ADDR_VAR 0 8
112279: PUSH
112280: LD_EXP 166
112284: PUSH
112285: LD_EXP 165
112289: PUSH
112290: LD_VAR 0 6
112294: ARRAY
112295: MINUS
112296: ST_TO_ADDR
// if not minesFreeAmount then
112297: LD_VAR 0 8
112301: NOT
112302: IFFALSE 112306
// exit ;
112304: GO 112577
// tmp := [ ] ;
112306: LD_ADDR_VAR 0 7
112310: PUSH
112311: EMPTY
112312: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112313: LD_ADDR_VAR 0 5
112317: PUSH
112318: DOUBLE
112319: LD_INT 1
112321: DEC
112322: ST_TO_ADDR
112323: LD_VAR 0 8
112327: PUSH
112328: FOR_TO
112329: IFFALSE 112524
// begin _d := rand ( 0 , 5 ) ;
112331: LD_ADDR_VAR 0 11
112335: PUSH
112336: LD_INT 0
112338: PPUSH
112339: LD_INT 5
112341: PPUSH
112342: CALL_OW 12
112346: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112347: LD_ADDR_VAR 0 12
112351: PUSH
112352: LD_INT 2
112354: PPUSH
112355: LD_INT 6
112357: PPUSH
112358: CALL_OW 12
112362: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112363: LD_ADDR_VAR 0 9
112367: PUSH
112368: LD_VAR 0 2
112372: PPUSH
112373: LD_VAR 0 11
112377: PPUSH
112378: LD_VAR 0 12
112382: PPUSH
112383: CALL_OW 272
112387: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112388: LD_ADDR_VAR 0 10
112392: PUSH
112393: LD_VAR 0 3
112397: PPUSH
112398: LD_VAR 0 11
112402: PPUSH
112403: LD_VAR 0 12
112407: PPUSH
112408: CALL_OW 273
112412: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112413: LD_VAR 0 9
112417: PPUSH
112418: LD_VAR 0 10
112422: PPUSH
112423: CALL_OW 488
112427: PUSH
112428: LD_VAR 0 9
112432: PUSH
112433: LD_VAR 0 10
112437: PUSH
112438: EMPTY
112439: LIST
112440: LIST
112441: PUSH
112442: LD_VAR 0 7
112446: IN
112447: NOT
112448: AND
112449: PUSH
112450: LD_VAR 0 9
112454: PPUSH
112455: LD_VAR 0 10
112459: PPUSH
112460: CALL_OW 458
112464: NOT
112465: AND
112466: IFFALSE 112508
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112468: LD_ADDR_VAR 0 7
112472: PUSH
112473: LD_VAR 0 7
112477: PPUSH
112478: LD_VAR 0 7
112482: PUSH
112483: LD_INT 1
112485: PLUS
112486: PPUSH
112487: LD_VAR 0 9
112491: PUSH
112492: LD_VAR 0 10
112496: PUSH
112497: EMPTY
112498: LIST
112499: LIST
112500: PPUSH
112501: CALL_OW 1
112505: ST_TO_ADDR
112506: GO 112522
// i := i - 1 ;
112508: LD_ADDR_VAR 0 5
112512: PUSH
112513: LD_VAR 0 5
112517: PUSH
112518: LD_INT 1
112520: MINUS
112521: ST_TO_ADDR
// end ;
112522: GO 112328
112524: POP
112525: POP
// for i in tmp do
112526: LD_ADDR_VAR 0 5
112530: PUSH
112531: LD_VAR 0 7
112535: PUSH
112536: FOR_IN
112537: IFFALSE 112575
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112539: LD_VAR 0 1
112543: PPUSH
112544: LD_VAR 0 5
112548: PUSH
112549: LD_INT 1
112551: ARRAY
112552: PPUSH
112553: LD_VAR 0 5
112557: PUSH
112558: LD_INT 2
112560: ARRAY
112561: PPUSH
112562: CALL 111521 0 3
112566: NOT
112567: IFFALSE 112573
// exit ;
112569: POP
112570: POP
112571: GO 112577
112573: GO 112536
112575: POP
112576: POP
// end ;
112577: LD_VAR 0 4
112581: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
112582: LD_INT 0
112584: PPUSH
112585: PPUSH
112586: PPUSH
112587: PPUSH
112588: PPUSH
112589: PPUSH
112590: PPUSH
112591: PPUSH
112592: PPUSH
// if GetClass ( unit ) <> class_sniper then
112593: LD_VAR 0 1
112597: PPUSH
112598: CALL_OW 257
112602: PUSH
112603: LD_INT 5
112605: NONEQUAL
112606: IFFALSE 112610
// exit ;
112608: GO 113076
// dist := 8 ;
112610: LD_ADDR_VAR 0 5
112614: PUSH
112615: LD_INT 8
112617: ST_TO_ADDR
// viewRange := 12 ;
112618: LD_ADDR_VAR 0 8
112622: PUSH
112623: LD_INT 12
112625: ST_TO_ADDR
// side := GetSide ( unit ) ;
112626: LD_ADDR_VAR 0 6
112630: PUSH
112631: LD_VAR 0 1
112635: PPUSH
112636: CALL_OW 255
112640: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112641: LD_INT 61
112643: PPUSH
112644: LD_VAR 0 6
112648: PPUSH
112649: CALL_OW 321
112653: PUSH
112654: LD_INT 2
112656: EQUAL
112657: IFFALSE 112667
// viewRange := 16 ;
112659: LD_ADDR_VAR 0 8
112663: PUSH
112664: LD_INT 16
112666: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112667: LD_VAR 0 1
112671: PPUSH
112672: LD_VAR 0 2
112676: PPUSH
112677: LD_VAR 0 3
112681: PPUSH
112682: CALL_OW 297
112686: PUSH
112687: LD_VAR 0 5
112691: GREATER
112692: IFFALSE 112771
// begin ComMoveXY ( unit , x , y ) ;
112694: LD_VAR 0 1
112698: PPUSH
112699: LD_VAR 0 2
112703: PPUSH
112704: LD_VAR 0 3
112708: PPUSH
112709: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112713: LD_INT 35
112715: PPUSH
112716: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112720: LD_VAR 0 1
112724: PPUSH
112725: LD_VAR 0 2
112729: PPUSH
112730: LD_VAR 0 3
112734: PPUSH
112735: CALL 85557 0 3
112739: NOT
112740: IFFALSE 112744
// exit ;
112742: GO 113076
// until GetDistUnitXY ( unit , x , y ) < dist ;
112744: LD_VAR 0 1
112748: PPUSH
112749: LD_VAR 0 2
112753: PPUSH
112754: LD_VAR 0 3
112758: PPUSH
112759: CALL_OW 297
112763: PUSH
112764: LD_VAR 0 5
112768: LESS
112769: IFFALSE 112713
// end ; ComTurnXY ( unit , x , y ) ;
112771: LD_VAR 0 1
112775: PPUSH
112776: LD_VAR 0 2
112780: PPUSH
112781: LD_VAR 0 3
112785: PPUSH
112786: CALL_OW 118
// repeat if Multiplayer then
112790: LD_OWVAR 4
112794: IFFALSE 112805
// wait ( 35 ) else
112796: LD_INT 35
112798: PPUSH
112799: CALL_OW 67
112803: GO 112812
// wait ( 5 ) ;
112805: LD_INT 5
112807: PPUSH
112808: CALL_OW 67
// _d := GetDir ( unit ) ;
112812: LD_ADDR_VAR 0 11
112816: PUSH
112817: LD_VAR 0 1
112821: PPUSH
112822: CALL_OW 254
112826: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
112827: LD_ADDR_VAR 0 7
112831: PUSH
112832: LD_VAR 0 1
112836: PPUSH
112837: CALL_OW 250
112841: PPUSH
112842: LD_VAR 0 1
112846: PPUSH
112847: CALL_OW 251
112851: PPUSH
112852: LD_VAR 0 2
112856: PPUSH
112857: LD_VAR 0 3
112861: PPUSH
112862: CALL 88165 0 4
112866: ST_TO_ADDR
// until dir = _d ;
112867: LD_VAR 0 7
112871: PUSH
112872: LD_VAR 0 11
112876: EQUAL
112877: IFFALSE 112790
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
112879: LD_ADDR_VAR 0 9
112883: PUSH
112884: LD_VAR 0 1
112888: PPUSH
112889: CALL_OW 250
112893: PPUSH
112894: LD_VAR 0 7
112898: PPUSH
112899: LD_VAR 0 5
112903: PPUSH
112904: CALL_OW 272
112908: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
112909: LD_ADDR_VAR 0 10
112913: PUSH
112914: LD_VAR 0 1
112918: PPUSH
112919: CALL_OW 251
112923: PPUSH
112924: LD_VAR 0 7
112928: PPUSH
112929: LD_VAR 0 5
112933: PPUSH
112934: CALL_OW 273
112938: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112939: LD_VAR 0 9
112943: PPUSH
112944: LD_VAR 0 10
112948: PPUSH
112949: CALL_OW 488
112953: NOT
112954: IFFALSE 112958
// exit ;
112956: GO 113076
// ComAnimCustom ( unit , 1 ) ;
112958: LD_VAR 0 1
112962: PPUSH
112963: LD_INT 1
112965: PPUSH
112966: CALL_OW 592
// p := 0 ;
112970: LD_ADDR_VAR 0 12
112974: PUSH
112975: LD_INT 0
112977: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112978: LD_VAR 0 9
112982: PPUSH
112983: LD_VAR 0 10
112987: PPUSH
112988: LD_VAR 0 6
112992: PPUSH
112993: LD_VAR 0 8
112997: PPUSH
112998: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
113002: LD_INT 35
113004: PPUSH
113005: CALL_OW 67
// p := Inc ( p ) ;
113009: LD_ADDR_VAR 0 12
113013: PUSH
113014: LD_VAR 0 12
113018: PPUSH
113019: CALL 88121 0 1
113023: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
113024: LD_VAR 0 12
113028: PUSH
113029: LD_INT 3
113031: EQUAL
113032: PUSH
113033: LD_VAR 0 1
113037: PPUSH
113038: CALL_OW 302
113042: NOT
113043: OR
113044: PUSH
113045: LD_VAR 0 1
113049: PPUSH
113050: CALL_OW 301
113054: OR
113055: IFFALSE 113002
// RemoveSeeing ( _x , _y , side ) ;
113057: LD_VAR 0 9
113061: PPUSH
113062: LD_VAR 0 10
113066: PPUSH
113067: LD_VAR 0 6
113071: PPUSH
113072: CALL_OW 331
// end ; end_of_file
113076: LD_VAR 0 4
113080: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113081: LD_INT 0
113083: PPUSH
113084: PPUSH
113085: PPUSH
113086: PPUSH
113087: PPUSH
113088: PPUSH
113089: PPUSH
113090: PPUSH
113091: PPUSH
113092: PPUSH
113093: PPUSH
113094: PPUSH
113095: PPUSH
113096: PPUSH
113097: PPUSH
113098: PPUSH
113099: PPUSH
113100: PPUSH
113101: PPUSH
113102: PPUSH
113103: PPUSH
113104: PPUSH
113105: PPUSH
113106: PPUSH
113107: PPUSH
113108: PPUSH
113109: PPUSH
113110: PPUSH
113111: PPUSH
113112: PPUSH
113113: PPUSH
113114: PPUSH
113115: PPUSH
113116: PPUSH
// if not list then
113117: LD_VAR 0 1
113121: NOT
113122: IFFALSE 113126
// exit ;
113124: GO 117785
// base := list [ 1 ] ;
113126: LD_ADDR_VAR 0 3
113130: PUSH
113131: LD_VAR 0 1
113135: PUSH
113136: LD_INT 1
113138: ARRAY
113139: ST_TO_ADDR
// group := list [ 2 ] ;
113140: LD_ADDR_VAR 0 4
113144: PUSH
113145: LD_VAR 0 1
113149: PUSH
113150: LD_INT 2
113152: ARRAY
113153: ST_TO_ADDR
// path := list [ 3 ] ;
113154: LD_ADDR_VAR 0 5
113158: PUSH
113159: LD_VAR 0 1
113163: PUSH
113164: LD_INT 3
113166: ARRAY
113167: ST_TO_ADDR
// flags := list [ 4 ] ;
113168: LD_ADDR_VAR 0 6
113172: PUSH
113173: LD_VAR 0 1
113177: PUSH
113178: LD_INT 4
113180: ARRAY
113181: ST_TO_ADDR
// mined := [ ] ;
113182: LD_ADDR_VAR 0 27
113186: PUSH
113187: EMPTY
113188: ST_TO_ADDR
// bombed := [ ] ;
113189: LD_ADDR_VAR 0 28
113193: PUSH
113194: EMPTY
113195: ST_TO_ADDR
// healers := [ ] ;
113196: LD_ADDR_VAR 0 31
113200: PUSH
113201: EMPTY
113202: ST_TO_ADDR
// to_heal := [ ] ;
113203: LD_ADDR_VAR 0 30
113207: PUSH
113208: EMPTY
113209: ST_TO_ADDR
// repairs := [ ] ;
113210: LD_ADDR_VAR 0 33
113214: PUSH
113215: EMPTY
113216: ST_TO_ADDR
// to_repair := [ ] ;
113217: LD_ADDR_VAR 0 32
113221: PUSH
113222: EMPTY
113223: ST_TO_ADDR
// if not group or not path then
113224: LD_VAR 0 4
113228: NOT
113229: PUSH
113230: LD_VAR 0 5
113234: NOT
113235: OR
113236: IFFALSE 113240
// exit ;
113238: GO 117785
// side := GetSide ( group [ 1 ] ) ;
113240: LD_ADDR_VAR 0 35
113244: PUSH
113245: LD_VAR 0 4
113249: PUSH
113250: LD_INT 1
113252: ARRAY
113253: PPUSH
113254: CALL_OW 255
113258: ST_TO_ADDR
// if flags then
113259: LD_VAR 0 6
113263: IFFALSE 113407
// begin f_ignore_area := flags [ 1 ] ;
113265: LD_ADDR_VAR 0 17
113269: PUSH
113270: LD_VAR 0 6
113274: PUSH
113275: LD_INT 1
113277: ARRAY
113278: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113279: LD_ADDR_VAR 0 18
113283: PUSH
113284: LD_VAR 0 6
113288: PUSH
113289: LD_INT 2
113291: ARRAY
113292: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113293: LD_ADDR_VAR 0 19
113297: PUSH
113298: LD_VAR 0 6
113302: PUSH
113303: LD_INT 3
113305: ARRAY
113306: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113307: LD_ADDR_VAR 0 20
113311: PUSH
113312: LD_VAR 0 6
113316: PUSH
113317: LD_INT 4
113319: ARRAY
113320: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113321: LD_ADDR_VAR 0 21
113325: PUSH
113326: LD_VAR 0 6
113330: PUSH
113331: LD_INT 5
113333: ARRAY
113334: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113335: LD_ADDR_VAR 0 22
113339: PUSH
113340: LD_VAR 0 6
113344: PUSH
113345: LD_INT 6
113347: ARRAY
113348: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113349: LD_ADDR_VAR 0 23
113353: PUSH
113354: LD_VAR 0 6
113358: PUSH
113359: LD_INT 7
113361: ARRAY
113362: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113363: LD_ADDR_VAR 0 24
113367: PUSH
113368: LD_VAR 0 6
113372: PUSH
113373: LD_INT 8
113375: ARRAY
113376: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113377: LD_ADDR_VAR 0 25
113381: PUSH
113382: LD_VAR 0 6
113386: PUSH
113387: LD_INT 9
113389: ARRAY
113390: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113391: LD_ADDR_VAR 0 26
113395: PUSH
113396: LD_VAR 0 6
113400: PUSH
113401: LD_INT 10
113403: ARRAY
113404: ST_TO_ADDR
// end else
113405: GO 113487
// begin f_ignore_area := false ;
113407: LD_ADDR_VAR 0 17
113411: PUSH
113412: LD_INT 0
113414: ST_TO_ADDR
// f_capture := false ;
113415: LD_ADDR_VAR 0 18
113419: PUSH
113420: LD_INT 0
113422: ST_TO_ADDR
// f_ignore_civ := false ;
113423: LD_ADDR_VAR 0 19
113427: PUSH
113428: LD_INT 0
113430: ST_TO_ADDR
// f_murder := false ;
113431: LD_ADDR_VAR 0 20
113435: PUSH
113436: LD_INT 0
113438: ST_TO_ADDR
// f_mines := false ;
113439: LD_ADDR_VAR 0 21
113443: PUSH
113444: LD_INT 0
113446: ST_TO_ADDR
// f_repair := false ;
113447: LD_ADDR_VAR 0 22
113451: PUSH
113452: LD_INT 0
113454: ST_TO_ADDR
// f_heal := false ;
113455: LD_ADDR_VAR 0 23
113459: PUSH
113460: LD_INT 0
113462: ST_TO_ADDR
// f_spacetime := false ;
113463: LD_ADDR_VAR 0 24
113467: PUSH
113468: LD_INT 0
113470: ST_TO_ADDR
// f_attack_depot := false ;
113471: LD_ADDR_VAR 0 25
113475: PUSH
113476: LD_INT 0
113478: ST_TO_ADDR
// f_crawl := false ;
113479: LD_ADDR_VAR 0 26
113483: PUSH
113484: LD_INT 0
113486: ST_TO_ADDR
// end ; if f_heal then
113487: LD_VAR 0 23
113491: IFFALSE 113518
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113493: LD_ADDR_VAR 0 31
113497: PUSH
113498: LD_VAR 0 4
113502: PPUSH
113503: LD_INT 25
113505: PUSH
113506: LD_INT 4
113508: PUSH
113509: EMPTY
113510: LIST
113511: LIST
113512: PPUSH
113513: CALL_OW 72
113517: ST_TO_ADDR
// if f_repair then
113518: LD_VAR 0 22
113522: IFFALSE 113549
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113524: LD_ADDR_VAR 0 33
113528: PUSH
113529: LD_VAR 0 4
113533: PPUSH
113534: LD_INT 25
113536: PUSH
113537: LD_INT 3
113539: PUSH
113540: EMPTY
113541: LIST
113542: LIST
113543: PPUSH
113544: CALL_OW 72
113548: ST_TO_ADDR
// units_path := [ ] ;
113549: LD_ADDR_VAR 0 16
113553: PUSH
113554: EMPTY
113555: ST_TO_ADDR
// for i = 1 to group do
113556: LD_ADDR_VAR 0 7
113560: PUSH
113561: DOUBLE
113562: LD_INT 1
113564: DEC
113565: ST_TO_ADDR
113566: LD_VAR 0 4
113570: PUSH
113571: FOR_TO
113572: IFFALSE 113601
// units_path := Replace ( units_path , i , path ) ;
113574: LD_ADDR_VAR 0 16
113578: PUSH
113579: LD_VAR 0 16
113583: PPUSH
113584: LD_VAR 0 7
113588: PPUSH
113589: LD_VAR 0 5
113593: PPUSH
113594: CALL_OW 1
113598: ST_TO_ADDR
113599: GO 113571
113601: POP
113602: POP
// repeat for i = group downto 1 do
113603: LD_ADDR_VAR 0 7
113607: PUSH
113608: DOUBLE
113609: LD_VAR 0 4
113613: INC
113614: ST_TO_ADDR
113615: LD_INT 1
113617: PUSH
113618: FOR_DOWNTO
113619: IFFALSE 117741
// begin wait ( 5 ) ;
113621: LD_INT 5
113623: PPUSH
113624: CALL_OW 67
// tmp := [ ] ;
113628: LD_ADDR_VAR 0 14
113632: PUSH
113633: EMPTY
113634: ST_TO_ADDR
// attacking := false ;
113635: LD_ADDR_VAR 0 29
113639: PUSH
113640: LD_INT 0
113642: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113643: LD_VAR 0 4
113647: PUSH
113648: LD_VAR 0 7
113652: ARRAY
113653: PPUSH
113654: CALL_OW 301
113658: PUSH
113659: LD_VAR 0 4
113663: PUSH
113664: LD_VAR 0 7
113668: ARRAY
113669: NOT
113670: OR
113671: IFFALSE 113780
// begin if GetType ( group [ i ] ) = unit_human then
113673: LD_VAR 0 4
113677: PUSH
113678: LD_VAR 0 7
113682: ARRAY
113683: PPUSH
113684: CALL_OW 247
113688: PUSH
113689: LD_INT 1
113691: EQUAL
113692: IFFALSE 113738
// begin to_heal := to_heal diff group [ i ] ;
113694: LD_ADDR_VAR 0 30
113698: PUSH
113699: LD_VAR 0 30
113703: PUSH
113704: LD_VAR 0 4
113708: PUSH
113709: LD_VAR 0 7
113713: ARRAY
113714: DIFF
113715: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113716: LD_ADDR_VAR 0 31
113720: PUSH
113721: LD_VAR 0 31
113725: PUSH
113726: LD_VAR 0 4
113730: PUSH
113731: LD_VAR 0 7
113735: ARRAY
113736: DIFF
113737: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113738: LD_ADDR_VAR 0 4
113742: PUSH
113743: LD_VAR 0 4
113747: PPUSH
113748: LD_VAR 0 7
113752: PPUSH
113753: CALL_OW 3
113757: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113758: LD_ADDR_VAR 0 16
113762: PUSH
113763: LD_VAR 0 16
113767: PPUSH
113768: LD_VAR 0 7
113772: PPUSH
113773: CALL_OW 3
113777: ST_TO_ADDR
// continue ;
113778: GO 113618
// end ; if f_repair then
113780: LD_VAR 0 22
113784: IFFALSE 114273
// begin if GetType ( group [ i ] ) = unit_vehicle then
113786: LD_VAR 0 4
113790: PUSH
113791: LD_VAR 0 7
113795: ARRAY
113796: PPUSH
113797: CALL_OW 247
113801: PUSH
113802: LD_INT 2
113804: EQUAL
113805: IFFALSE 113995
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113807: LD_VAR 0 4
113811: PUSH
113812: LD_VAR 0 7
113816: ARRAY
113817: PPUSH
113818: CALL_OW 256
113822: PUSH
113823: LD_INT 700
113825: LESS
113826: PUSH
113827: LD_VAR 0 4
113831: PUSH
113832: LD_VAR 0 7
113836: ARRAY
113837: PUSH
113838: LD_VAR 0 32
113842: IN
113843: NOT
113844: AND
113845: IFFALSE 113869
// to_repair := to_repair union group [ i ] ;
113847: LD_ADDR_VAR 0 32
113851: PUSH
113852: LD_VAR 0 32
113856: PUSH
113857: LD_VAR 0 4
113861: PUSH
113862: LD_VAR 0 7
113866: ARRAY
113867: UNION
113868: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113869: LD_VAR 0 4
113873: PUSH
113874: LD_VAR 0 7
113878: ARRAY
113879: PPUSH
113880: CALL_OW 256
113884: PUSH
113885: LD_INT 1000
113887: EQUAL
113888: PUSH
113889: LD_VAR 0 4
113893: PUSH
113894: LD_VAR 0 7
113898: ARRAY
113899: PUSH
113900: LD_VAR 0 32
113904: IN
113905: AND
113906: IFFALSE 113930
// to_repair := to_repair diff group [ i ] ;
113908: LD_ADDR_VAR 0 32
113912: PUSH
113913: LD_VAR 0 32
113917: PUSH
113918: LD_VAR 0 4
113922: PUSH
113923: LD_VAR 0 7
113927: ARRAY
113928: DIFF
113929: ST_TO_ADDR
// if group [ i ] in to_repair then
113930: LD_VAR 0 4
113934: PUSH
113935: LD_VAR 0 7
113939: ARRAY
113940: PUSH
113941: LD_VAR 0 32
113945: IN
113946: IFFALSE 113993
// begin if not IsInArea ( group [ i ] , f_repair ) then
113948: LD_VAR 0 4
113952: PUSH
113953: LD_VAR 0 7
113957: ARRAY
113958: PPUSH
113959: LD_VAR 0 22
113963: PPUSH
113964: CALL_OW 308
113968: NOT
113969: IFFALSE 113991
// ComMoveToArea ( group [ i ] , f_repair ) ;
113971: LD_VAR 0 4
113975: PUSH
113976: LD_VAR 0 7
113980: ARRAY
113981: PPUSH
113982: LD_VAR 0 22
113986: PPUSH
113987: CALL_OW 113
// continue ;
113991: GO 113618
// end ; end else
113993: GO 114273
// if group [ i ] in repairs then
113995: LD_VAR 0 4
113999: PUSH
114000: LD_VAR 0 7
114004: ARRAY
114005: PUSH
114006: LD_VAR 0 33
114010: IN
114011: IFFALSE 114273
// begin if IsInUnit ( group [ i ] ) then
114013: LD_VAR 0 4
114017: PUSH
114018: LD_VAR 0 7
114022: ARRAY
114023: PPUSH
114024: CALL_OW 310
114028: IFFALSE 114096
// begin z := IsInUnit ( group [ i ] ) ;
114030: LD_ADDR_VAR 0 13
114034: PUSH
114035: LD_VAR 0 4
114039: PUSH
114040: LD_VAR 0 7
114044: ARRAY
114045: PPUSH
114046: CALL_OW 310
114050: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114051: LD_VAR 0 13
114055: PUSH
114056: LD_VAR 0 32
114060: IN
114061: PUSH
114062: LD_VAR 0 13
114066: PPUSH
114067: LD_VAR 0 22
114071: PPUSH
114072: CALL_OW 308
114076: AND
114077: IFFALSE 114094
// ComExitVehicle ( group [ i ] ) ;
114079: LD_VAR 0 4
114083: PUSH
114084: LD_VAR 0 7
114088: ARRAY
114089: PPUSH
114090: CALL_OW 121
// end else
114094: GO 114273
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114096: LD_ADDR_VAR 0 13
114100: PUSH
114101: LD_VAR 0 4
114105: PPUSH
114106: LD_INT 95
114108: PUSH
114109: LD_VAR 0 22
114113: PUSH
114114: EMPTY
114115: LIST
114116: LIST
114117: PUSH
114118: LD_INT 58
114120: PUSH
114121: EMPTY
114122: LIST
114123: PUSH
114124: EMPTY
114125: LIST
114126: LIST
114127: PPUSH
114128: CALL_OW 72
114132: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114133: LD_VAR 0 4
114137: PUSH
114138: LD_VAR 0 7
114142: ARRAY
114143: PPUSH
114144: CALL_OW 314
114148: NOT
114149: IFFALSE 114271
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114151: LD_ADDR_VAR 0 10
114155: PUSH
114156: LD_VAR 0 13
114160: PPUSH
114161: LD_VAR 0 4
114165: PUSH
114166: LD_VAR 0 7
114170: ARRAY
114171: PPUSH
114172: CALL_OW 74
114176: ST_TO_ADDR
// if not x then
114177: LD_VAR 0 10
114181: NOT
114182: IFFALSE 114186
// continue ;
114184: GO 113618
// if GetLives ( x ) < 1000 then
114186: LD_VAR 0 10
114190: PPUSH
114191: CALL_OW 256
114195: PUSH
114196: LD_INT 1000
114198: LESS
114199: IFFALSE 114223
// ComRepairVehicle ( group [ i ] , x ) else
114201: LD_VAR 0 4
114205: PUSH
114206: LD_VAR 0 7
114210: ARRAY
114211: PPUSH
114212: LD_VAR 0 10
114216: PPUSH
114217: CALL_OW 129
114221: GO 114271
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114223: LD_VAR 0 23
114227: PUSH
114228: LD_VAR 0 4
114232: PUSH
114233: LD_VAR 0 7
114237: ARRAY
114238: PPUSH
114239: CALL_OW 256
114243: PUSH
114244: LD_INT 1000
114246: LESS
114247: AND
114248: NOT
114249: IFFALSE 114271
// ComEnterUnit ( group [ i ] , x ) ;
114251: LD_VAR 0 4
114255: PUSH
114256: LD_VAR 0 7
114260: ARRAY
114261: PPUSH
114262: LD_VAR 0 10
114266: PPUSH
114267: CALL_OW 120
// end ; continue ;
114271: GO 113618
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114273: LD_VAR 0 23
114277: PUSH
114278: LD_VAR 0 4
114282: PUSH
114283: LD_VAR 0 7
114287: ARRAY
114288: PPUSH
114289: CALL_OW 247
114293: PUSH
114294: LD_INT 1
114296: EQUAL
114297: AND
114298: IFFALSE 114776
// begin if group [ i ] in healers then
114300: LD_VAR 0 4
114304: PUSH
114305: LD_VAR 0 7
114309: ARRAY
114310: PUSH
114311: LD_VAR 0 31
114315: IN
114316: IFFALSE 114589
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114318: LD_VAR 0 4
114322: PUSH
114323: LD_VAR 0 7
114327: ARRAY
114328: PPUSH
114329: LD_VAR 0 23
114333: PPUSH
114334: CALL_OW 308
114338: NOT
114339: PUSH
114340: LD_VAR 0 4
114344: PUSH
114345: LD_VAR 0 7
114349: ARRAY
114350: PPUSH
114351: CALL_OW 314
114355: NOT
114356: AND
114357: IFFALSE 114381
// ComMoveToArea ( group [ i ] , f_heal ) else
114359: LD_VAR 0 4
114363: PUSH
114364: LD_VAR 0 7
114368: ARRAY
114369: PPUSH
114370: LD_VAR 0 23
114374: PPUSH
114375: CALL_OW 113
114379: GO 114587
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114381: LD_VAR 0 4
114385: PUSH
114386: LD_VAR 0 7
114390: ARRAY
114391: PPUSH
114392: CALL 84140 0 1
114396: PPUSH
114397: CALL_OW 256
114401: PUSH
114402: LD_INT 1000
114404: EQUAL
114405: IFFALSE 114424
// ComStop ( group [ i ] ) else
114407: LD_VAR 0 4
114411: PUSH
114412: LD_VAR 0 7
114416: ARRAY
114417: PPUSH
114418: CALL_OW 141
114422: GO 114587
// if not HasTask ( group [ i ] ) and to_heal then
114424: LD_VAR 0 4
114428: PUSH
114429: LD_VAR 0 7
114433: ARRAY
114434: PPUSH
114435: CALL_OW 314
114439: NOT
114440: PUSH
114441: LD_VAR 0 30
114445: AND
114446: IFFALSE 114587
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114448: LD_ADDR_VAR 0 13
114452: PUSH
114453: LD_VAR 0 30
114457: PPUSH
114458: LD_INT 3
114460: PUSH
114461: LD_INT 54
114463: PUSH
114464: EMPTY
114465: LIST
114466: PUSH
114467: EMPTY
114468: LIST
114469: LIST
114470: PPUSH
114471: CALL_OW 72
114475: PPUSH
114476: LD_VAR 0 4
114480: PUSH
114481: LD_VAR 0 7
114485: ARRAY
114486: PPUSH
114487: CALL_OW 74
114491: ST_TO_ADDR
// if z then
114492: LD_VAR 0 13
114496: IFFALSE 114587
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114498: LD_INT 91
114500: PUSH
114501: LD_VAR 0 13
114505: PUSH
114506: LD_INT 10
114508: PUSH
114509: EMPTY
114510: LIST
114511: LIST
114512: LIST
114513: PUSH
114514: LD_INT 81
114516: PUSH
114517: LD_VAR 0 13
114521: PPUSH
114522: CALL_OW 255
114526: PUSH
114527: EMPTY
114528: LIST
114529: LIST
114530: PUSH
114531: EMPTY
114532: LIST
114533: LIST
114534: PPUSH
114535: CALL_OW 69
114539: PUSH
114540: LD_INT 0
114542: EQUAL
114543: IFFALSE 114567
// ComHeal ( group [ i ] , z ) else
114545: LD_VAR 0 4
114549: PUSH
114550: LD_VAR 0 7
114554: ARRAY
114555: PPUSH
114556: LD_VAR 0 13
114560: PPUSH
114561: CALL_OW 128
114565: GO 114587
// ComMoveToArea ( group [ i ] , f_heal ) ;
114567: LD_VAR 0 4
114571: PUSH
114572: LD_VAR 0 7
114576: ARRAY
114577: PPUSH
114578: LD_VAR 0 23
114582: PPUSH
114583: CALL_OW 113
// end ; continue ;
114587: GO 113618
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114589: LD_VAR 0 4
114593: PUSH
114594: LD_VAR 0 7
114598: ARRAY
114599: PPUSH
114600: CALL_OW 256
114604: PUSH
114605: LD_INT 700
114607: LESS
114608: PUSH
114609: LD_VAR 0 4
114613: PUSH
114614: LD_VAR 0 7
114618: ARRAY
114619: PUSH
114620: LD_VAR 0 30
114624: IN
114625: NOT
114626: AND
114627: IFFALSE 114651
// to_heal := to_heal union group [ i ] ;
114629: LD_ADDR_VAR 0 30
114633: PUSH
114634: LD_VAR 0 30
114638: PUSH
114639: LD_VAR 0 4
114643: PUSH
114644: LD_VAR 0 7
114648: ARRAY
114649: UNION
114650: ST_TO_ADDR
// if group [ i ] in to_heal then
114651: LD_VAR 0 4
114655: PUSH
114656: LD_VAR 0 7
114660: ARRAY
114661: PUSH
114662: LD_VAR 0 30
114666: IN
114667: IFFALSE 114776
// begin if GetLives ( group [ i ] ) = 1000 then
114669: LD_VAR 0 4
114673: PUSH
114674: LD_VAR 0 7
114678: ARRAY
114679: PPUSH
114680: CALL_OW 256
114684: PUSH
114685: LD_INT 1000
114687: EQUAL
114688: IFFALSE 114714
// to_heal := to_heal diff group [ i ] else
114690: LD_ADDR_VAR 0 30
114694: PUSH
114695: LD_VAR 0 30
114699: PUSH
114700: LD_VAR 0 4
114704: PUSH
114705: LD_VAR 0 7
114709: ARRAY
114710: DIFF
114711: ST_TO_ADDR
114712: GO 114776
// begin if not IsInArea ( group [ i ] , to_heal ) then
114714: LD_VAR 0 4
114718: PUSH
114719: LD_VAR 0 7
114723: ARRAY
114724: PPUSH
114725: LD_VAR 0 30
114729: PPUSH
114730: CALL_OW 308
114734: NOT
114735: IFFALSE 114759
// ComMoveToArea ( group [ i ] , f_heal ) else
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: LD_VAR 0 23
114752: PPUSH
114753: CALL_OW 113
114757: GO 114774
// ComHold ( group [ i ] ) ;
114759: LD_VAR 0 4
114763: PUSH
114764: LD_VAR 0 7
114768: ARRAY
114769: PPUSH
114770: CALL_OW 140
// continue ;
114774: GO 113618
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114776: LD_VAR 0 4
114780: PUSH
114781: LD_VAR 0 7
114785: ARRAY
114786: PPUSH
114787: LD_INT 10
114789: PPUSH
114790: CALL 81902 0 2
114794: NOT
114795: PUSH
114796: LD_VAR 0 16
114800: PUSH
114801: LD_VAR 0 7
114805: ARRAY
114806: PUSH
114807: EMPTY
114808: EQUAL
114809: NOT
114810: AND
114811: IFFALSE 115077
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114813: LD_VAR 0 4
114817: PUSH
114818: LD_VAR 0 7
114822: ARRAY
114823: PPUSH
114824: CALL_OW 262
114828: PUSH
114829: LD_INT 1
114831: PUSH
114832: LD_INT 2
114834: PUSH
114835: EMPTY
114836: LIST
114837: LIST
114838: IN
114839: IFFALSE 114880
// if GetFuel ( group [ i ] ) < 10 then
114841: LD_VAR 0 4
114845: PUSH
114846: LD_VAR 0 7
114850: ARRAY
114851: PPUSH
114852: CALL_OW 261
114856: PUSH
114857: LD_INT 10
114859: LESS
114860: IFFALSE 114880
// SetFuel ( group [ i ] , 12 ) ;
114862: LD_VAR 0 4
114866: PUSH
114867: LD_VAR 0 7
114871: ARRAY
114872: PPUSH
114873: LD_INT 12
114875: PPUSH
114876: CALL_OW 240
// if units_path [ i ] then
114880: LD_VAR 0 16
114884: PUSH
114885: LD_VAR 0 7
114889: ARRAY
114890: IFFALSE 115075
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114892: LD_VAR 0 4
114896: PUSH
114897: LD_VAR 0 7
114901: ARRAY
114902: PPUSH
114903: LD_VAR 0 16
114907: PUSH
114908: LD_VAR 0 7
114912: ARRAY
114913: PUSH
114914: LD_INT 1
114916: ARRAY
114917: PUSH
114918: LD_INT 1
114920: ARRAY
114921: PPUSH
114922: LD_VAR 0 16
114926: PUSH
114927: LD_VAR 0 7
114931: ARRAY
114932: PUSH
114933: LD_INT 1
114935: ARRAY
114936: PUSH
114937: LD_INT 2
114939: ARRAY
114940: PPUSH
114941: CALL_OW 297
114945: PUSH
114946: LD_INT 6
114948: GREATER
114949: IFFALSE 115024
// begin if not HasTask ( group [ i ] ) then
114951: LD_VAR 0 4
114955: PUSH
114956: LD_VAR 0 7
114960: ARRAY
114961: PPUSH
114962: CALL_OW 314
114966: NOT
114967: IFFALSE 115022
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114969: LD_VAR 0 4
114973: PUSH
114974: LD_VAR 0 7
114978: ARRAY
114979: PPUSH
114980: LD_VAR 0 16
114984: PUSH
114985: LD_VAR 0 7
114989: ARRAY
114990: PUSH
114991: LD_INT 1
114993: ARRAY
114994: PUSH
114995: LD_INT 1
114997: ARRAY
114998: PPUSH
114999: LD_VAR 0 16
115003: PUSH
115004: LD_VAR 0 7
115008: ARRAY
115009: PUSH
115010: LD_INT 1
115012: ARRAY
115013: PUSH
115014: LD_INT 2
115016: ARRAY
115017: PPUSH
115018: CALL_OW 114
// end else
115022: GO 115075
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115024: LD_ADDR_VAR 0 15
115028: PUSH
115029: LD_VAR 0 16
115033: PUSH
115034: LD_VAR 0 7
115038: ARRAY
115039: PPUSH
115040: LD_INT 1
115042: PPUSH
115043: CALL_OW 3
115047: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115048: LD_ADDR_VAR 0 16
115052: PUSH
115053: LD_VAR 0 16
115057: PPUSH
115058: LD_VAR 0 7
115062: PPUSH
115063: LD_VAR 0 15
115067: PPUSH
115068: CALL_OW 1
115072: ST_TO_ADDR
// continue ;
115073: GO 113618
// end ; end ; end else
115075: GO 117739
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115077: LD_ADDR_VAR 0 14
115081: PUSH
115082: LD_INT 81
115084: PUSH
115085: LD_VAR 0 4
115089: PUSH
115090: LD_VAR 0 7
115094: ARRAY
115095: PPUSH
115096: CALL_OW 255
115100: PUSH
115101: EMPTY
115102: LIST
115103: LIST
115104: PPUSH
115105: CALL_OW 69
115109: ST_TO_ADDR
// if not tmp then
115110: LD_VAR 0 14
115114: NOT
115115: IFFALSE 115119
// continue ;
115117: GO 113618
// if f_ignore_area then
115119: LD_VAR 0 17
115123: IFFALSE 115211
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115125: LD_ADDR_VAR 0 15
115129: PUSH
115130: LD_VAR 0 14
115134: PPUSH
115135: LD_INT 3
115137: PUSH
115138: LD_INT 92
115140: PUSH
115141: LD_VAR 0 17
115145: PUSH
115146: LD_INT 1
115148: ARRAY
115149: PUSH
115150: LD_VAR 0 17
115154: PUSH
115155: LD_INT 2
115157: ARRAY
115158: PUSH
115159: LD_VAR 0 17
115163: PUSH
115164: LD_INT 3
115166: ARRAY
115167: PUSH
115168: EMPTY
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: PUSH
115174: EMPTY
115175: LIST
115176: LIST
115177: PPUSH
115178: CALL_OW 72
115182: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115183: LD_VAR 0 14
115187: PUSH
115188: LD_VAR 0 15
115192: DIFF
115193: IFFALSE 115211
// tmp := tmp diff tmp2 ;
115195: LD_ADDR_VAR 0 14
115199: PUSH
115200: LD_VAR 0 14
115204: PUSH
115205: LD_VAR 0 15
115209: DIFF
115210: ST_TO_ADDR
// end ; if not f_murder then
115211: LD_VAR 0 20
115215: NOT
115216: IFFALSE 115274
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115218: LD_ADDR_VAR 0 15
115222: PUSH
115223: LD_VAR 0 14
115227: PPUSH
115228: LD_INT 3
115230: PUSH
115231: LD_INT 50
115233: PUSH
115234: EMPTY
115235: LIST
115236: PUSH
115237: EMPTY
115238: LIST
115239: LIST
115240: PPUSH
115241: CALL_OW 72
115245: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115246: LD_VAR 0 14
115250: PUSH
115251: LD_VAR 0 15
115255: DIFF
115256: IFFALSE 115274
// tmp := tmp diff tmp2 ;
115258: LD_ADDR_VAR 0 14
115262: PUSH
115263: LD_VAR 0 14
115267: PUSH
115268: LD_VAR 0 15
115272: DIFF
115273: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115274: LD_ADDR_VAR 0 14
115278: PUSH
115279: LD_VAR 0 4
115283: PUSH
115284: LD_VAR 0 7
115288: ARRAY
115289: PPUSH
115290: LD_VAR 0 14
115294: PPUSH
115295: LD_INT 1
115297: PPUSH
115298: LD_INT 1
115300: PPUSH
115301: CALL 54446 0 4
115305: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115306: LD_VAR 0 4
115310: PUSH
115311: LD_VAR 0 7
115315: ARRAY
115316: PPUSH
115317: CALL_OW 257
115321: PUSH
115322: LD_INT 1
115324: EQUAL
115325: IFFALSE 115773
// begin if WantPlant ( group [ i ] ) then
115327: LD_VAR 0 4
115331: PUSH
115332: LD_VAR 0 7
115336: ARRAY
115337: PPUSH
115338: CALL 53947 0 1
115342: IFFALSE 115346
// continue ;
115344: GO 113618
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115346: LD_VAR 0 18
115350: PUSH
115351: LD_VAR 0 4
115355: PUSH
115356: LD_VAR 0 7
115360: ARRAY
115361: PPUSH
115362: CALL_OW 310
115366: NOT
115367: AND
115368: PUSH
115369: LD_VAR 0 14
115373: PUSH
115374: LD_INT 1
115376: ARRAY
115377: PUSH
115378: LD_VAR 0 14
115382: PPUSH
115383: LD_INT 21
115385: PUSH
115386: LD_INT 2
115388: PUSH
115389: EMPTY
115390: LIST
115391: LIST
115392: PUSH
115393: LD_INT 58
115395: PUSH
115396: EMPTY
115397: LIST
115398: PUSH
115399: EMPTY
115400: LIST
115401: LIST
115402: PPUSH
115403: CALL_OW 72
115407: IN
115408: AND
115409: IFFALSE 115445
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115411: LD_VAR 0 4
115415: PUSH
115416: LD_VAR 0 7
115420: ARRAY
115421: PPUSH
115422: LD_VAR 0 14
115426: PUSH
115427: LD_INT 1
115429: ARRAY
115430: PPUSH
115431: CALL_OW 120
// attacking := true ;
115435: LD_ADDR_VAR 0 29
115439: PUSH
115440: LD_INT 1
115442: ST_TO_ADDR
// continue ;
115443: GO 113618
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115445: LD_VAR 0 26
115449: PUSH
115450: LD_VAR 0 4
115454: PUSH
115455: LD_VAR 0 7
115459: ARRAY
115460: PPUSH
115461: CALL_OW 257
115465: PUSH
115466: LD_INT 1
115468: EQUAL
115469: AND
115470: PUSH
115471: LD_VAR 0 4
115475: PUSH
115476: LD_VAR 0 7
115480: ARRAY
115481: PPUSH
115482: CALL_OW 256
115486: PUSH
115487: LD_INT 800
115489: LESS
115490: AND
115491: PUSH
115492: LD_VAR 0 4
115496: PUSH
115497: LD_VAR 0 7
115501: ARRAY
115502: PPUSH
115503: CALL_OW 318
115507: NOT
115508: AND
115509: IFFALSE 115526
// ComCrawl ( group [ i ] ) ;
115511: LD_VAR 0 4
115515: PUSH
115516: LD_VAR 0 7
115520: ARRAY
115521: PPUSH
115522: CALL_OW 137
// if f_mines then
115526: LD_VAR 0 21
115530: IFFALSE 115773
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115532: LD_VAR 0 14
115536: PUSH
115537: LD_INT 1
115539: ARRAY
115540: PPUSH
115541: CALL_OW 247
115545: PUSH
115546: LD_INT 3
115548: EQUAL
115549: PUSH
115550: LD_VAR 0 14
115554: PUSH
115555: LD_INT 1
115557: ARRAY
115558: PUSH
115559: LD_VAR 0 27
115563: IN
115564: NOT
115565: AND
115566: IFFALSE 115773
// begin x := GetX ( tmp [ 1 ] ) ;
115568: LD_ADDR_VAR 0 10
115572: PUSH
115573: LD_VAR 0 14
115577: PUSH
115578: LD_INT 1
115580: ARRAY
115581: PPUSH
115582: CALL_OW 250
115586: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115587: LD_ADDR_VAR 0 11
115591: PUSH
115592: LD_VAR 0 14
115596: PUSH
115597: LD_INT 1
115599: ARRAY
115600: PPUSH
115601: CALL_OW 251
115605: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115606: LD_ADDR_VAR 0 12
115610: PUSH
115611: LD_VAR 0 4
115615: PUSH
115616: LD_VAR 0 7
115620: ARRAY
115621: PPUSH
115622: CALL 81987 0 1
115626: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115627: LD_VAR 0 4
115631: PUSH
115632: LD_VAR 0 7
115636: ARRAY
115637: PPUSH
115638: LD_VAR 0 10
115642: PPUSH
115643: LD_VAR 0 11
115647: PPUSH
115648: LD_VAR 0 14
115652: PUSH
115653: LD_INT 1
115655: ARRAY
115656: PPUSH
115657: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115661: LD_VAR 0 4
115665: PUSH
115666: LD_VAR 0 7
115670: ARRAY
115671: PPUSH
115672: LD_VAR 0 10
115676: PPUSH
115677: LD_VAR 0 12
115681: PPUSH
115682: LD_INT 7
115684: PPUSH
115685: CALL_OW 272
115689: PPUSH
115690: LD_VAR 0 11
115694: PPUSH
115695: LD_VAR 0 12
115699: PPUSH
115700: LD_INT 7
115702: PPUSH
115703: CALL_OW 273
115707: PPUSH
115708: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115712: LD_VAR 0 4
115716: PUSH
115717: LD_VAR 0 7
115721: ARRAY
115722: PPUSH
115723: LD_INT 71
115725: PPUSH
115726: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115730: LD_ADDR_VAR 0 27
115734: PUSH
115735: LD_VAR 0 27
115739: PPUSH
115740: LD_VAR 0 27
115744: PUSH
115745: LD_INT 1
115747: PLUS
115748: PPUSH
115749: LD_VAR 0 14
115753: PUSH
115754: LD_INT 1
115756: ARRAY
115757: PPUSH
115758: CALL_OW 1
115762: ST_TO_ADDR
// attacking := true ;
115763: LD_ADDR_VAR 0 29
115767: PUSH
115768: LD_INT 1
115770: ST_TO_ADDR
// continue ;
115771: GO 113618
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115773: LD_VAR 0 4
115777: PUSH
115778: LD_VAR 0 7
115782: ARRAY
115783: PPUSH
115784: CALL_OW 257
115788: PUSH
115789: LD_INT 17
115791: EQUAL
115792: PUSH
115793: LD_VAR 0 4
115797: PUSH
115798: LD_VAR 0 7
115802: ARRAY
115803: PPUSH
115804: CALL_OW 110
115808: PUSH
115809: LD_INT 71
115811: EQUAL
115812: NOT
115813: AND
115814: IFFALSE 115960
// begin attacking := false ;
115816: LD_ADDR_VAR 0 29
115820: PUSH
115821: LD_INT 0
115823: ST_TO_ADDR
// k := 5 ;
115824: LD_ADDR_VAR 0 9
115828: PUSH
115829: LD_INT 5
115831: ST_TO_ADDR
// if tmp < k then
115832: LD_VAR 0 14
115836: PUSH
115837: LD_VAR 0 9
115841: LESS
115842: IFFALSE 115854
// k := tmp ;
115844: LD_ADDR_VAR 0 9
115848: PUSH
115849: LD_VAR 0 14
115853: ST_TO_ADDR
// for j = 1 to k do
115854: LD_ADDR_VAR 0 8
115858: PUSH
115859: DOUBLE
115860: LD_INT 1
115862: DEC
115863: ST_TO_ADDR
115864: LD_VAR 0 9
115868: PUSH
115869: FOR_TO
115870: IFFALSE 115958
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115872: LD_VAR 0 14
115876: PUSH
115877: LD_VAR 0 8
115881: ARRAY
115882: PUSH
115883: LD_VAR 0 14
115887: PPUSH
115888: LD_INT 58
115890: PUSH
115891: EMPTY
115892: LIST
115893: PPUSH
115894: CALL_OW 72
115898: IN
115899: NOT
115900: IFFALSE 115956
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115902: LD_VAR 0 4
115906: PUSH
115907: LD_VAR 0 7
115911: ARRAY
115912: PPUSH
115913: LD_VAR 0 14
115917: PUSH
115918: LD_VAR 0 8
115922: ARRAY
115923: PPUSH
115924: CALL_OW 115
// attacking := true ;
115928: LD_ADDR_VAR 0 29
115932: PUSH
115933: LD_INT 1
115935: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115936: LD_VAR 0 4
115940: PUSH
115941: LD_VAR 0 7
115945: ARRAY
115946: PPUSH
115947: LD_INT 71
115949: PPUSH
115950: CALL_OW 109
// continue ;
115954: GO 115869
// end ; end ;
115956: GO 115869
115958: POP
115959: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115960: LD_VAR 0 4
115964: PUSH
115965: LD_VAR 0 7
115969: ARRAY
115970: PPUSH
115971: CALL_OW 257
115975: PUSH
115976: LD_INT 8
115978: EQUAL
115979: PUSH
115980: LD_VAR 0 4
115984: PUSH
115985: LD_VAR 0 7
115989: ARRAY
115990: PPUSH
115991: CALL_OW 264
115995: PUSH
115996: LD_INT 28
115998: PUSH
115999: LD_INT 45
116001: PUSH
116002: LD_INT 7
116004: PUSH
116005: LD_INT 47
116007: PUSH
116008: EMPTY
116009: LIST
116010: LIST
116011: LIST
116012: LIST
116013: IN
116014: OR
116015: IFFALSE 116271
// begin attacking := false ;
116017: LD_ADDR_VAR 0 29
116021: PUSH
116022: LD_INT 0
116024: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116025: LD_VAR 0 14
116029: PUSH
116030: LD_INT 1
116032: ARRAY
116033: PPUSH
116034: CALL_OW 266
116038: PUSH
116039: LD_INT 32
116041: PUSH
116042: LD_INT 31
116044: PUSH
116045: LD_INT 33
116047: PUSH
116048: LD_INT 4
116050: PUSH
116051: LD_INT 5
116053: PUSH
116054: EMPTY
116055: LIST
116056: LIST
116057: LIST
116058: LIST
116059: LIST
116060: IN
116061: IFFALSE 116247
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116063: LD_ADDR_VAR 0 9
116067: PUSH
116068: LD_VAR 0 14
116072: PUSH
116073: LD_INT 1
116075: ARRAY
116076: PPUSH
116077: CALL_OW 266
116081: PPUSH
116082: LD_VAR 0 14
116086: PUSH
116087: LD_INT 1
116089: ARRAY
116090: PPUSH
116091: CALL_OW 250
116095: PPUSH
116096: LD_VAR 0 14
116100: PUSH
116101: LD_INT 1
116103: ARRAY
116104: PPUSH
116105: CALL_OW 251
116109: PPUSH
116110: LD_VAR 0 14
116114: PUSH
116115: LD_INT 1
116117: ARRAY
116118: PPUSH
116119: CALL_OW 254
116123: PPUSH
116124: LD_VAR 0 14
116128: PUSH
116129: LD_INT 1
116131: ARRAY
116132: PPUSH
116133: CALL_OW 248
116137: PPUSH
116138: LD_INT 0
116140: PPUSH
116141: CALL 63357 0 6
116145: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116146: LD_ADDR_VAR 0 8
116150: PUSH
116151: LD_VAR 0 4
116155: PUSH
116156: LD_VAR 0 7
116160: ARRAY
116161: PPUSH
116162: LD_VAR 0 9
116166: PPUSH
116167: CALL 82100 0 2
116171: ST_TO_ADDR
// if j then
116172: LD_VAR 0 8
116176: IFFALSE 116245
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116178: LD_VAR 0 8
116182: PUSH
116183: LD_INT 1
116185: ARRAY
116186: PPUSH
116187: LD_VAR 0 8
116191: PUSH
116192: LD_INT 2
116194: ARRAY
116195: PPUSH
116196: CALL_OW 488
116200: IFFALSE 116245
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116202: LD_VAR 0 4
116206: PUSH
116207: LD_VAR 0 7
116211: ARRAY
116212: PPUSH
116213: LD_VAR 0 8
116217: PUSH
116218: LD_INT 1
116220: ARRAY
116221: PPUSH
116222: LD_VAR 0 8
116226: PUSH
116227: LD_INT 2
116229: ARRAY
116230: PPUSH
116231: CALL_OW 116
// attacking := true ;
116235: LD_ADDR_VAR 0 29
116239: PUSH
116240: LD_INT 1
116242: ST_TO_ADDR
// continue ;
116243: GO 113618
// end ; end else
116245: GO 116271
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116247: LD_VAR 0 4
116251: PUSH
116252: LD_VAR 0 7
116256: ARRAY
116257: PPUSH
116258: LD_VAR 0 14
116262: PUSH
116263: LD_INT 1
116265: ARRAY
116266: PPUSH
116267: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116271: LD_VAR 0 4
116275: PUSH
116276: LD_VAR 0 7
116280: ARRAY
116281: PPUSH
116282: CALL_OW 265
116286: PUSH
116287: LD_INT 11
116289: EQUAL
116290: IFFALSE 116568
// begin k := 10 ;
116292: LD_ADDR_VAR 0 9
116296: PUSH
116297: LD_INT 10
116299: ST_TO_ADDR
// x := 0 ;
116300: LD_ADDR_VAR 0 10
116304: PUSH
116305: LD_INT 0
116307: ST_TO_ADDR
// if tmp < k then
116308: LD_VAR 0 14
116312: PUSH
116313: LD_VAR 0 9
116317: LESS
116318: IFFALSE 116330
// k := tmp ;
116320: LD_ADDR_VAR 0 9
116324: PUSH
116325: LD_VAR 0 14
116329: ST_TO_ADDR
// for j = k downto 1 do
116330: LD_ADDR_VAR 0 8
116334: PUSH
116335: DOUBLE
116336: LD_VAR 0 9
116340: INC
116341: ST_TO_ADDR
116342: LD_INT 1
116344: PUSH
116345: FOR_DOWNTO
116346: IFFALSE 116421
// begin if GetType ( tmp [ j ] ) = unit_human then
116348: LD_VAR 0 14
116352: PUSH
116353: LD_VAR 0 8
116357: ARRAY
116358: PPUSH
116359: CALL_OW 247
116363: PUSH
116364: LD_INT 1
116366: EQUAL
116367: IFFALSE 116419
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116369: LD_VAR 0 4
116373: PUSH
116374: LD_VAR 0 7
116378: ARRAY
116379: PPUSH
116380: LD_VAR 0 14
116384: PUSH
116385: LD_VAR 0 8
116389: ARRAY
116390: PPUSH
116391: CALL 82354 0 2
// x := tmp [ j ] ;
116395: LD_ADDR_VAR 0 10
116399: PUSH
116400: LD_VAR 0 14
116404: PUSH
116405: LD_VAR 0 8
116409: ARRAY
116410: ST_TO_ADDR
// attacking := true ;
116411: LD_ADDR_VAR 0 29
116415: PUSH
116416: LD_INT 1
116418: ST_TO_ADDR
// end ; end ;
116419: GO 116345
116421: POP
116422: POP
// if not x then
116423: LD_VAR 0 10
116427: NOT
116428: IFFALSE 116568
// begin attacking := true ;
116430: LD_ADDR_VAR 0 29
116434: PUSH
116435: LD_INT 1
116437: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116438: LD_VAR 0 4
116442: PUSH
116443: LD_VAR 0 7
116447: ARRAY
116448: PPUSH
116449: CALL_OW 250
116453: PPUSH
116454: LD_VAR 0 4
116458: PUSH
116459: LD_VAR 0 7
116463: ARRAY
116464: PPUSH
116465: CALL_OW 251
116469: PPUSH
116470: CALL_OW 546
116474: PUSH
116475: LD_INT 2
116477: ARRAY
116478: PUSH
116479: LD_VAR 0 14
116483: PUSH
116484: LD_INT 1
116486: ARRAY
116487: PPUSH
116488: CALL_OW 250
116492: PPUSH
116493: LD_VAR 0 14
116497: PUSH
116498: LD_INT 1
116500: ARRAY
116501: PPUSH
116502: CALL_OW 251
116506: PPUSH
116507: CALL_OW 546
116511: PUSH
116512: LD_INT 2
116514: ARRAY
116515: EQUAL
116516: IFFALSE 116544
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116518: LD_VAR 0 4
116522: PUSH
116523: LD_VAR 0 7
116527: ARRAY
116528: PPUSH
116529: LD_VAR 0 14
116533: PUSH
116534: LD_INT 1
116536: ARRAY
116537: PPUSH
116538: CALL 82354 0 2
116542: GO 116568
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116544: LD_VAR 0 4
116548: PUSH
116549: LD_VAR 0 7
116553: ARRAY
116554: PPUSH
116555: LD_VAR 0 14
116559: PUSH
116560: LD_INT 1
116562: ARRAY
116563: PPUSH
116564: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116568: LD_VAR 0 4
116572: PUSH
116573: LD_VAR 0 7
116577: ARRAY
116578: PPUSH
116579: CALL_OW 264
116583: PUSH
116584: LD_INT 29
116586: EQUAL
116587: IFFALSE 116953
// begin if WantsToAttack ( group [ i ] ) in bombed then
116589: LD_VAR 0 4
116593: PUSH
116594: LD_VAR 0 7
116598: ARRAY
116599: PPUSH
116600: CALL_OW 319
116604: PUSH
116605: LD_VAR 0 28
116609: IN
116610: IFFALSE 116614
// continue ;
116612: GO 113618
// k := 8 ;
116614: LD_ADDR_VAR 0 9
116618: PUSH
116619: LD_INT 8
116621: ST_TO_ADDR
// x := 0 ;
116622: LD_ADDR_VAR 0 10
116626: PUSH
116627: LD_INT 0
116629: ST_TO_ADDR
// if tmp < k then
116630: LD_VAR 0 14
116634: PUSH
116635: LD_VAR 0 9
116639: LESS
116640: IFFALSE 116652
// k := tmp ;
116642: LD_ADDR_VAR 0 9
116646: PUSH
116647: LD_VAR 0 14
116651: ST_TO_ADDR
// for j = 1 to k do
116652: LD_ADDR_VAR 0 8
116656: PUSH
116657: DOUBLE
116658: LD_INT 1
116660: DEC
116661: ST_TO_ADDR
116662: LD_VAR 0 9
116666: PUSH
116667: FOR_TO
116668: IFFALSE 116800
// begin if GetType ( tmp [ j ] ) = unit_building then
116670: LD_VAR 0 14
116674: PUSH
116675: LD_VAR 0 8
116679: ARRAY
116680: PPUSH
116681: CALL_OW 247
116685: PUSH
116686: LD_INT 3
116688: EQUAL
116689: IFFALSE 116798
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116691: LD_VAR 0 14
116695: PUSH
116696: LD_VAR 0 8
116700: ARRAY
116701: PUSH
116702: LD_VAR 0 28
116706: IN
116707: NOT
116708: PUSH
116709: LD_VAR 0 14
116713: PUSH
116714: LD_VAR 0 8
116718: ARRAY
116719: PPUSH
116720: CALL_OW 313
116724: AND
116725: IFFALSE 116798
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116727: LD_VAR 0 4
116731: PUSH
116732: LD_VAR 0 7
116736: ARRAY
116737: PPUSH
116738: LD_VAR 0 14
116742: PUSH
116743: LD_VAR 0 8
116747: ARRAY
116748: PPUSH
116749: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116753: LD_ADDR_VAR 0 28
116757: PUSH
116758: LD_VAR 0 28
116762: PPUSH
116763: LD_VAR 0 28
116767: PUSH
116768: LD_INT 1
116770: PLUS
116771: PPUSH
116772: LD_VAR 0 14
116776: PUSH
116777: LD_VAR 0 8
116781: ARRAY
116782: PPUSH
116783: CALL_OW 1
116787: ST_TO_ADDR
// attacking := true ;
116788: LD_ADDR_VAR 0 29
116792: PUSH
116793: LD_INT 1
116795: ST_TO_ADDR
// break ;
116796: GO 116800
// end ; end ;
116798: GO 116667
116800: POP
116801: POP
// if not attacking and f_attack_depot then
116802: LD_VAR 0 29
116806: NOT
116807: PUSH
116808: LD_VAR 0 25
116812: AND
116813: IFFALSE 116908
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116815: LD_ADDR_VAR 0 13
116819: PUSH
116820: LD_VAR 0 14
116824: PPUSH
116825: LD_INT 2
116827: PUSH
116828: LD_INT 30
116830: PUSH
116831: LD_INT 0
116833: PUSH
116834: EMPTY
116835: LIST
116836: LIST
116837: PUSH
116838: LD_INT 30
116840: PUSH
116841: LD_INT 1
116843: PUSH
116844: EMPTY
116845: LIST
116846: LIST
116847: PUSH
116848: EMPTY
116849: LIST
116850: LIST
116851: LIST
116852: PPUSH
116853: CALL_OW 72
116857: ST_TO_ADDR
// if z then
116858: LD_VAR 0 13
116862: IFFALSE 116908
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116864: LD_VAR 0 4
116868: PUSH
116869: LD_VAR 0 7
116873: ARRAY
116874: PPUSH
116875: LD_VAR 0 13
116879: PPUSH
116880: LD_VAR 0 4
116884: PUSH
116885: LD_VAR 0 7
116889: ARRAY
116890: PPUSH
116891: CALL_OW 74
116895: PPUSH
116896: CALL_OW 115
// attacking := true ;
116900: LD_ADDR_VAR 0 29
116904: PUSH
116905: LD_INT 1
116907: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116908: LD_VAR 0 4
116912: PUSH
116913: LD_VAR 0 7
116917: ARRAY
116918: PPUSH
116919: CALL_OW 256
116923: PUSH
116924: LD_INT 500
116926: LESS
116927: IFFALSE 116953
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116929: LD_VAR 0 4
116933: PUSH
116934: LD_VAR 0 7
116938: ARRAY
116939: PPUSH
116940: LD_VAR 0 14
116944: PUSH
116945: LD_INT 1
116947: ARRAY
116948: PPUSH
116949: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116953: LD_VAR 0 4
116957: PUSH
116958: LD_VAR 0 7
116962: ARRAY
116963: PPUSH
116964: CALL_OW 264
116968: PUSH
116969: LD_INT 49
116971: EQUAL
116972: IFFALSE 117093
// begin if not HasTask ( group [ i ] ) then
116974: LD_VAR 0 4
116978: PUSH
116979: LD_VAR 0 7
116983: ARRAY
116984: PPUSH
116985: CALL_OW 314
116989: NOT
116990: IFFALSE 117093
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116992: LD_ADDR_VAR 0 9
116996: PUSH
116997: LD_INT 81
116999: PUSH
117000: LD_VAR 0 4
117004: PUSH
117005: LD_VAR 0 7
117009: ARRAY
117010: PPUSH
117011: CALL_OW 255
117015: PUSH
117016: EMPTY
117017: LIST
117018: LIST
117019: PPUSH
117020: CALL_OW 69
117024: PPUSH
117025: LD_VAR 0 4
117029: PUSH
117030: LD_VAR 0 7
117034: ARRAY
117035: PPUSH
117036: CALL_OW 74
117040: ST_TO_ADDR
// if k then
117041: LD_VAR 0 9
117045: IFFALSE 117093
// if GetDistUnits ( group [ i ] , k ) > 10 then
117047: LD_VAR 0 4
117051: PUSH
117052: LD_VAR 0 7
117056: ARRAY
117057: PPUSH
117058: LD_VAR 0 9
117062: PPUSH
117063: CALL_OW 296
117067: PUSH
117068: LD_INT 10
117070: GREATER
117071: IFFALSE 117093
// ComMoveUnit ( group [ i ] , k ) ;
117073: LD_VAR 0 4
117077: PUSH
117078: LD_VAR 0 7
117082: ARRAY
117083: PPUSH
117084: LD_VAR 0 9
117088: PPUSH
117089: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117093: LD_VAR 0 4
117097: PUSH
117098: LD_VAR 0 7
117102: ARRAY
117103: PPUSH
117104: CALL_OW 256
117108: PUSH
117109: LD_INT 250
117111: LESS
117112: PUSH
117113: LD_VAR 0 4
117117: PUSH
117118: LD_VAR 0 7
117122: ARRAY
117123: PUSH
117124: LD_INT 21
117126: PUSH
117127: LD_INT 2
117129: PUSH
117130: EMPTY
117131: LIST
117132: LIST
117133: PUSH
117134: LD_INT 23
117136: PUSH
117137: LD_INT 2
117139: PUSH
117140: EMPTY
117141: LIST
117142: LIST
117143: PUSH
117144: EMPTY
117145: LIST
117146: LIST
117147: PPUSH
117148: CALL_OW 69
117152: IN
117153: AND
117154: IFFALSE 117279
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117156: LD_ADDR_VAR 0 9
117160: PUSH
117161: LD_OWVAR 3
117165: PUSH
117166: LD_VAR 0 4
117170: PUSH
117171: LD_VAR 0 7
117175: ARRAY
117176: DIFF
117177: PPUSH
117178: LD_VAR 0 4
117182: PUSH
117183: LD_VAR 0 7
117187: ARRAY
117188: PPUSH
117189: CALL_OW 74
117193: ST_TO_ADDR
// if not k then
117194: LD_VAR 0 9
117198: NOT
117199: IFFALSE 117203
// continue ;
117201: GO 113618
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117203: LD_VAR 0 9
117207: PUSH
117208: LD_INT 81
117210: PUSH
117211: LD_VAR 0 4
117215: PUSH
117216: LD_VAR 0 7
117220: ARRAY
117221: PPUSH
117222: CALL_OW 255
117226: PUSH
117227: EMPTY
117228: LIST
117229: LIST
117230: PPUSH
117231: CALL_OW 69
117235: IN
117236: PUSH
117237: LD_VAR 0 9
117241: PPUSH
117242: LD_VAR 0 4
117246: PUSH
117247: LD_VAR 0 7
117251: ARRAY
117252: PPUSH
117253: CALL_OW 296
117257: PUSH
117258: LD_INT 5
117260: LESS
117261: AND
117262: IFFALSE 117279
// ComAutodestruct ( group [ i ] ) ;
117264: LD_VAR 0 4
117268: PUSH
117269: LD_VAR 0 7
117273: ARRAY
117274: PPUSH
117275: CALL 82252 0 1
// end ; if f_attack_depot then
117279: LD_VAR 0 25
117283: IFFALSE 117395
// begin k := 6 ;
117285: LD_ADDR_VAR 0 9
117289: PUSH
117290: LD_INT 6
117292: ST_TO_ADDR
// if tmp < k then
117293: LD_VAR 0 14
117297: PUSH
117298: LD_VAR 0 9
117302: LESS
117303: IFFALSE 117315
// k := tmp ;
117305: LD_ADDR_VAR 0 9
117309: PUSH
117310: LD_VAR 0 14
117314: ST_TO_ADDR
// for j = 1 to k do
117315: LD_ADDR_VAR 0 8
117319: PUSH
117320: DOUBLE
117321: LD_INT 1
117323: DEC
117324: ST_TO_ADDR
117325: LD_VAR 0 9
117329: PUSH
117330: FOR_TO
117331: IFFALSE 117393
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117333: LD_VAR 0 8
117337: PPUSH
117338: CALL_OW 266
117342: PUSH
117343: LD_INT 0
117345: PUSH
117346: LD_INT 1
117348: PUSH
117349: EMPTY
117350: LIST
117351: LIST
117352: IN
117353: IFFALSE 117391
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117355: LD_VAR 0 4
117359: PUSH
117360: LD_VAR 0 7
117364: ARRAY
117365: PPUSH
117366: LD_VAR 0 14
117370: PUSH
117371: LD_VAR 0 8
117375: ARRAY
117376: PPUSH
117377: CALL_OW 115
// attacking := true ;
117381: LD_ADDR_VAR 0 29
117385: PUSH
117386: LD_INT 1
117388: ST_TO_ADDR
// break ;
117389: GO 117393
// end ;
117391: GO 117330
117393: POP
117394: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117395: LD_VAR 0 4
117399: PUSH
117400: LD_VAR 0 7
117404: ARRAY
117405: PPUSH
117406: CALL_OW 302
117410: PUSH
117411: LD_VAR 0 29
117415: NOT
117416: AND
117417: IFFALSE 117739
// begin if GetTag ( group [ i ] ) = 71 then
117419: LD_VAR 0 4
117423: PUSH
117424: LD_VAR 0 7
117428: ARRAY
117429: PPUSH
117430: CALL_OW 110
117434: PUSH
117435: LD_INT 71
117437: EQUAL
117438: IFFALSE 117479
// begin if HasTask ( group [ i ] ) then
117440: LD_VAR 0 4
117444: PUSH
117445: LD_VAR 0 7
117449: ARRAY
117450: PPUSH
117451: CALL_OW 314
117455: IFFALSE 117461
// continue else
117457: GO 113618
117459: GO 117479
// SetTag ( group [ i ] , 0 ) ;
117461: LD_VAR 0 4
117465: PUSH
117466: LD_VAR 0 7
117470: ARRAY
117471: PPUSH
117472: LD_INT 0
117474: PPUSH
117475: CALL_OW 109
// end ; k := 8 ;
117479: LD_ADDR_VAR 0 9
117483: PUSH
117484: LD_INT 8
117486: ST_TO_ADDR
// x := 0 ;
117487: LD_ADDR_VAR 0 10
117491: PUSH
117492: LD_INT 0
117494: ST_TO_ADDR
// if tmp < k then
117495: LD_VAR 0 14
117499: PUSH
117500: LD_VAR 0 9
117504: LESS
117505: IFFALSE 117517
// k := tmp ;
117507: LD_ADDR_VAR 0 9
117511: PUSH
117512: LD_VAR 0 14
117516: ST_TO_ADDR
// for j = 1 to k do
117517: LD_ADDR_VAR 0 8
117521: PUSH
117522: DOUBLE
117523: LD_INT 1
117525: DEC
117526: ST_TO_ADDR
117527: LD_VAR 0 9
117531: PUSH
117532: FOR_TO
117533: IFFALSE 117631
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117535: LD_VAR 0 14
117539: PUSH
117540: LD_VAR 0 8
117544: ARRAY
117545: PPUSH
117546: CALL_OW 247
117550: PUSH
117551: LD_INT 1
117553: EQUAL
117554: PUSH
117555: LD_VAR 0 14
117559: PUSH
117560: LD_VAR 0 8
117564: ARRAY
117565: PPUSH
117566: CALL_OW 256
117570: PUSH
117571: LD_INT 250
117573: LESS
117574: PUSH
117575: LD_VAR 0 20
117579: AND
117580: PUSH
117581: LD_VAR 0 20
117585: NOT
117586: PUSH
117587: LD_VAR 0 14
117591: PUSH
117592: LD_VAR 0 8
117596: ARRAY
117597: PPUSH
117598: CALL_OW 256
117602: PUSH
117603: LD_INT 250
117605: GREATEREQUAL
117606: AND
117607: OR
117608: AND
117609: IFFALSE 117629
// begin x := tmp [ j ] ;
117611: LD_ADDR_VAR 0 10
117615: PUSH
117616: LD_VAR 0 14
117620: PUSH
117621: LD_VAR 0 8
117625: ARRAY
117626: ST_TO_ADDR
// break ;
117627: GO 117631
// end ;
117629: GO 117532
117631: POP
117632: POP
// if x then
117633: LD_VAR 0 10
117637: IFFALSE 117661
// ComAttackUnit ( group [ i ] , x ) else
117639: LD_VAR 0 4
117643: PUSH
117644: LD_VAR 0 7
117648: ARRAY
117649: PPUSH
117650: LD_VAR 0 10
117654: PPUSH
117655: CALL_OW 115
117659: GO 117685
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117661: LD_VAR 0 4
117665: PUSH
117666: LD_VAR 0 7
117670: ARRAY
117671: PPUSH
117672: LD_VAR 0 14
117676: PUSH
117677: LD_INT 1
117679: ARRAY
117680: PPUSH
117681: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117685: LD_VAR 0 4
117689: PUSH
117690: LD_VAR 0 7
117694: ARRAY
117695: PPUSH
117696: CALL_OW 314
117700: NOT
117701: IFFALSE 117739
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117703: LD_VAR 0 4
117707: PUSH
117708: LD_VAR 0 7
117712: ARRAY
117713: PPUSH
117714: LD_VAR 0 14
117718: PPUSH
117719: LD_VAR 0 4
117723: PUSH
117724: LD_VAR 0 7
117728: ARRAY
117729: PPUSH
117730: CALL_OW 74
117734: PPUSH
117735: CALL_OW 115
// end ; end ; end ;
117739: GO 113618
117741: POP
117742: POP
// wait ( 0 0$2 ) ;
117743: LD_INT 70
117745: PPUSH
117746: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117750: LD_VAR 0 4
117754: NOT
117755: PUSH
117756: LD_VAR 0 4
117760: PUSH
117761: EMPTY
117762: EQUAL
117763: OR
117764: PUSH
117765: LD_INT 81
117767: PUSH
117768: LD_VAR 0 35
117772: PUSH
117773: EMPTY
117774: LIST
117775: LIST
117776: PPUSH
117777: CALL_OW 69
117781: NOT
117782: OR
117783: IFFALSE 113603
// end ;
117785: LD_VAR 0 2
117789: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117790: LD_INT 0
117792: PPUSH
117793: PPUSH
117794: PPUSH
117795: PPUSH
117796: PPUSH
117797: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117798: LD_VAR 0 1
117802: NOT
117803: PUSH
117804: LD_EXP 50
117808: PUSH
117809: LD_VAR 0 1
117813: ARRAY
117814: NOT
117815: OR
117816: PUSH
117817: LD_VAR 0 2
117821: NOT
117822: OR
117823: IFFALSE 117827
// exit ;
117825: GO 118381
// side := mc_sides [ base ] ;
117827: LD_ADDR_VAR 0 6
117831: PUSH
117832: LD_EXP 76
117836: PUSH
117837: LD_VAR 0 1
117841: ARRAY
117842: ST_TO_ADDR
// if not side then
117843: LD_VAR 0 6
117847: NOT
117848: IFFALSE 117852
// exit ;
117850: GO 118381
// for i in solds do
117852: LD_ADDR_VAR 0 7
117856: PUSH
117857: LD_VAR 0 2
117861: PUSH
117862: FOR_IN
117863: IFFALSE 117924
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117865: LD_VAR 0 7
117869: PPUSH
117870: CALL_OW 310
117874: PPUSH
117875: CALL_OW 266
117879: PUSH
117880: LD_INT 32
117882: PUSH
117883: LD_INT 31
117885: PUSH
117886: EMPTY
117887: LIST
117888: LIST
117889: IN
117890: IFFALSE 117910
// solds := solds diff i else
117892: LD_ADDR_VAR 0 2
117896: PUSH
117897: LD_VAR 0 2
117901: PUSH
117902: LD_VAR 0 7
117906: DIFF
117907: ST_TO_ADDR
117908: GO 117922
// SetTag ( i , 18 ) ;
117910: LD_VAR 0 7
117914: PPUSH
117915: LD_INT 18
117917: PPUSH
117918: CALL_OW 109
117922: GO 117862
117924: POP
117925: POP
// if not solds then
117926: LD_VAR 0 2
117930: NOT
117931: IFFALSE 117935
// exit ;
117933: GO 118381
// repeat wait ( 0 0$2 ) ;
117935: LD_INT 70
117937: PPUSH
117938: CALL_OW 67
// enemy := mc_scan [ base ] ;
117942: LD_ADDR_VAR 0 4
117946: PUSH
117947: LD_EXP 73
117951: PUSH
117952: LD_VAR 0 1
117956: ARRAY
117957: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117958: LD_EXP 50
117962: PUSH
117963: LD_VAR 0 1
117967: ARRAY
117968: NOT
117969: PUSH
117970: LD_EXP 50
117974: PUSH
117975: LD_VAR 0 1
117979: ARRAY
117980: PUSH
117981: EMPTY
117982: EQUAL
117983: OR
117984: IFFALSE 118021
// begin for i in solds do
117986: LD_ADDR_VAR 0 7
117990: PUSH
117991: LD_VAR 0 2
117995: PUSH
117996: FOR_IN
117997: IFFALSE 118010
// ComStop ( i ) ;
117999: LD_VAR 0 7
118003: PPUSH
118004: CALL_OW 141
118008: GO 117996
118010: POP
118011: POP
// solds := [ ] ;
118012: LD_ADDR_VAR 0 2
118016: PUSH
118017: EMPTY
118018: ST_TO_ADDR
// exit ;
118019: GO 118381
// end ; for i in solds do
118021: LD_ADDR_VAR 0 7
118025: PUSH
118026: LD_VAR 0 2
118030: PUSH
118031: FOR_IN
118032: IFFALSE 118353
// begin if IsInUnit ( i ) then
118034: LD_VAR 0 7
118038: PPUSH
118039: CALL_OW 310
118043: IFFALSE 118054
// ComExitBuilding ( i ) ;
118045: LD_VAR 0 7
118049: PPUSH
118050: CALL_OW 122
// if GetLives ( i ) > 500 then
118054: LD_VAR 0 7
118058: PPUSH
118059: CALL_OW 256
118063: PUSH
118064: LD_INT 500
118066: GREATER
118067: IFFALSE 118120
// begin e := NearestUnitToUnit ( enemy , i ) ;
118069: LD_ADDR_VAR 0 5
118073: PUSH
118074: LD_VAR 0 4
118078: PPUSH
118079: LD_VAR 0 7
118083: PPUSH
118084: CALL_OW 74
118088: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118089: LD_VAR 0 7
118093: PPUSH
118094: LD_VAR 0 5
118098: PPUSH
118099: CALL_OW 250
118103: PPUSH
118104: LD_VAR 0 5
118108: PPUSH
118109: CALL_OW 251
118113: PPUSH
118114: CALL_OW 114
// end else
118118: GO 118351
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118120: LD_VAR 0 7
118124: PPUSH
118125: LD_EXP 50
118129: PUSH
118130: LD_VAR 0 1
118134: ARRAY
118135: PPUSH
118136: LD_INT 2
118138: PUSH
118139: LD_INT 30
118141: PUSH
118142: LD_INT 0
118144: PUSH
118145: EMPTY
118146: LIST
118147: LIST
118148: PUSH
118149: LD_INT 30
118151: PUSH
118152: LD_INT 1
118154: PUSH
118155: EMPTY
118156: LIST
118157: LIST
118158: PUSH
118159: LD_INT 30
118161: PUSH
118162: LD_INT 6
118164: PUSH
118165: EMPTY
118166: LIST
118167: LIST
118168: PUSH
118169: EMPTY
118170: LIST
118171: LIST
118172: LIST
118173: LIST
118174: PPUSH
118175: CALL_OW 72
118179: PPUSH
118180: LD_VAR 0 7
118184: PPUSH
118185: CALL_OW 74
118189: PPUSH
118190: CALL_OW 296
118194: PUSH
118195: LD_INT 10
118197: GREATER
118198: IFFALSE 118351
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118200: LD_ADDR_VAR 0 8
118204: PUSH
118205: LD_EXP 50
118209: PUSH
118210: LD_VAR 0 1
118214: ARRAY
118215: PPUSH
118216: LD_INT 2
118218: PUSH
118219: LD_INT 30
118221: PUSH
118222: LD_INT 0
118224: PUSH
118225: EMPTY
118226: LIST
118227: LIST
118228: PUSH
118229: LD_INT 30
118231: PUSH
118232: LD_INT 1
118234: PUSH
118235: EMPTY
118236: LIST
118237: LIST
118238: PUSH
118239: LD_INT 30
118241: PUSH
118242: LD_INT 6
118244: PUSH
118245: EMPTY
118246: LIST
118247: LIST
118248: PUSH
118249: EMPTY
118250: LIST
118251: LIST
118252: LIST
118253: LIST
118254: PPUSH
118255: CALL_OW 72
118259: PPUSH
118260: LD_VAR 0 7
118264: PPUSH
118265: CALL_OW 74
118269: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118270: LD_VAR 0 7
118274: PPUSH
118275: LD_VAR 0 8
118279: PPUSH
118280: CALL_OW 250
118284: PPUSH
118285: LD_INT 3
118287: PPUSH
118288: LD_INT 5
118290: PPUSH
118291: CALL_OW 272
118295: PPUSH
118296: LD_VAR 0 8
118300: PPUSH
118301: CALL_OW 251
118305: PPUSH
118306: LD_INT 3
118308: PPUSH
118309: LD_INT 5
118311: PPUSH
118312: CALL_OW 273
118316: PPUSH
118317: CALL_OW 111
// SetTag ( i , 0 ) ;
118321: LD_VAR 0 7
118325: PPUSH
118326: LD_INT 0
118328: PPUSH
118329: CALL_OW 109
// solds := solds diff i ;
118333: LD_ADDR_VAR 0 2
118337: PUSH
118338: LD_VAR 0 2
118342: PUSH
118343: LD_VAR 0 7
118347: DIFF
118348: ST_TO_ADDR
// continue ;
118349: GO 118031
// end ; end ;
118351: GO 118031
118353: POP
118354: POP
// until not solds or not enemy ;
118355: LD_VAR 0 2
118359: NOT
118360: PUSH
118361: LD_VAR 0 4
118365: NOT
118366: OR
118367: IFFALSE 117935
// MC_Reset ( base , 18 ) ;
118369: LD_VAR 0 1
118373: PPUSH
118374: LD_INT 18
118376: PPUSH
118377: CALL 22426 0 2
// end ;
118381: LD_VAR 0 3
118385: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118386: LD_INT 0
118388: PPUSH
118389: PPUSH
118390: PPUSH
118391: PPUSH
118392: PPUSH
118393: PPUSH
118394: PPUSH
118395: PPUSH
118396: PPUSH
118397: PPUSH
118398: PPUSH
118399: PPUSH
118400: PPUSH
118401: PPUSH
118402: PPUSH
118403: PPUSH
118404: PPUSH
118405: PPUSH
118406: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118407: LD_ADDR_VAR 0 12
118411: PUSH
118412: LD_EXP 50
118416: PUSH
118417: LD_VAR 0 1
118421: ARRAY
118422: PPUSH
118423: LD_INT 25
118425: PUSH
118426: LD_INT 3
118428: PUSH
118429: EMPTY
118430: LIST
118431: LIST
118432: PPUSH
118433: CALL_OW 72
118437: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118438: LD_EXP 90
118442: PUSH
118443: LD_VAR 0 1
118447: ARRAY
118448: IFFALSE 118472
// mechs := mechs diff mc_remote_driver [ base ] ;
118450: LD_ADDR_VAR 0 12
118454: PUSH
118455: LD_VAR 0 12
118459: PUSH
118460: LD_EXP 90
118464: PUSH
118465: LD_VAR 0 1
118469: ARRAY
118470: DIFF
118471: ST_TO_ADDR
// for i in mechs do
118472: LD_ADDR_VAR 0 4
118476: PUSH
118477: LD_VAR 0 12
118481: PUSH
118482: FOR_IN
118483: IFFALSE 118518
// if GetTag ( i ) > 0 then
118485: LD_VAR 0 4
118489: PPUSH
118490: CALL_OW 110
118494: PUSH
118495: LD_INT 0
118497: GREATER
118498: IFFALSE 118516
// mechs := mechs diff i ;
118500: LD_ADDR_VAR 0 12
118504: PUSH
118505: LD_VAR 0 12
118509: PUSH
118510: LD_VAR 0 4
118514: DIFF
118515: ST_TO_ADDR
118516: GO 118482
118518: POP
118519: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118520: LD_ADDR_VAR 0 8
118524: PUSH
118525: LD_EXP 50
118529: PUSH
118530: LD_VAR 0 1
118534: ARRAY
118535: PPUSH
118536: LD_INT 2
118538: PUSH
118539: LD_INT 25
118541: PUSH
118542: LD_INT 1
118544: PUSH
118545: EMPTY
118546: LIST
118547: LIST
118548: PUSH
118549: LD_INT 25
118551: PUSH
118552: LD_INT 5
118554: PUSH
118555: EMPTY
118556: LIST
118557: LIST
118558: PUSH
118559: LD_INT 25
118561: PUSH
118562: LD_INT 8
118564: PUSH
118565: EMPTY
118566: LIST
118567: LIST
118568: PUSH
118569: LD_INT 25
118571: PUSH
118572: LD_INT 9
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PUSH
118579: EMPTY
118580: LIST
118581: LIST
118582: LIST
118583: LIST
118584: LIST
118585: PPUSH
118586: CALL_OW 72
118590: ST_TO_ADDR
// if not defenders and not solds then
118591: LD_VAR 0 2
118595: NOT
118596: PUSH
118597: LD_VAR 0 8
118601: NOT
118602: AND
118603: IFFALSE 118607
// exit ;
118605: GO 120377
// depot_under_attack := false ;
118607: LD_ADDR_VAR 0 16
118611: PUSH
118612: LD_INT 0
118614: ST_TO_ADDR
// sold_defenders := [ ] ;
118615: LD_ADDR_VAR 0 17
118619: PUSH
118620: EMPTY
118621: ST_TO_ADDR
// if mechs then
118622: LD_VAR 0 12
118626: IFFALSE 118779
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118628: LD_ADDR_VAR 0 4
118632: PUSH
118633: LD_VAR 0 2
118637: PPUSH
118638: LD_INT 21
118640: PUSH
118641: LD_INT 2
118643: PUSH
118644: EMPTY
118645: LIST
118646: LIST
118647: PPUSH
118648: CALL_OW 72
118652: PUSH
118653: FOR_IN
118654: IFFALSE 118777
// begin if GetTag ( i ) <> 20 then
118656: LD_VAR 0 4
118660: PPUSH
118661: CALL_OW 110
118665: PUSH
118666: LD_INT 20
118668: NONEQUAL
118669: IFFALSE 118683
// SetTag ( i , 20 ) ;
118671: LD_VAR 0 4
118675: PPUSH
118676: LD_INT 20
118678: PPUSH
118679: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118683: LD_VAR 0 4
118687: PPUSH
118688: CALL_OW 263
118692: PUSH
118693: LD_INT 1
118695: EQUAL
118696: PUSH
118697: LD_VAR 0 4
118701: PPUSH
118702: CALL_OW 311
118706: NOT
118707: AND
118708: IFFALSE 118775
// begin un := mechs [ 1 ] ;
118710: LD_ADDR_VAR 0 10
118714: PUSH
118715: LD_VAR 0 12
118719: PUSH
118720: LD_INT 1
118722: ARRAY
118723: ST_TO_ADDR
// ComExit ( un ) ;
118724: LD_VAR 0 10
118728: PPUSH
118729: CALL 87158 0 1
// AddComEnterUnit ( un , i ) ;
118733: LD_VAR 0 10
118737: PPUSH
118738: LD_VAR 0 4
118742: PPUSH
118743: CALL_OW 180
// SetTag ( un , 19 ) ;
118747: LD_VAR 0 10
118751: PPUSH
118752: LD_INT 19
118754: PPUSH
118755: CALL_OW 109
// mechs := mechs diff un ;
118759: LD_ADDR_VAR 0 12
118763: PUSH
118764: LD_VAR 0 12
118768: PUSH
118769: LD_VAR 0 10
118773: DIFF
118774: ST_TO_ADDR
// end ; end ;
118775: GO 118653
118777: POP
118778: POP
// if solds then
118779: LD_VAR 0 8
118783: IFFALSE 118842
// for i in solds do
118785: LD_ADDR_VAR 0 4
118789: PUSH
118790: LD_VAR 0 8
118794: PUSH
118795: FOR_IN
118796: IFFALSE 118840
// if not GetTag ( i ) then
118798: LD_VAR 0 4
118802: PPUSH
118803: CALL_OW 110
118807: NOT
118808: IFFALSE 118838
// begin defenders := defenders union i ;
118810: LD_ADDR_VAR 0 2
118814: PUSH
118815: LD_VAR 0 2
118819: PUSH
118820: LD_VAR 0 4
118824: UNION
118825: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118826: LD_VAR 0 4
118830: PPUSH
118831: LD_INT 18
118833: PPUSH
118834: CALL_OW 109
// end ;
118838: GO 118795
118840: POP
118841: POP
// repeat wait ( 0 0$2 ) ;
118842: LD_INT 70
118844: PPUSH
118845: CALL_OW 67
// enemy := mc_scan [ base ] ;
118849: LD_ADDR_VAR 0 21
118853: PUSH
118854: LD_EXP 73
118858: PUSH
118859: LD_VAR 0 1
118863: ARRAY
118864: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118865: LD_EXP 50
118869: PUSH
118870: LD_VAR 0 1
118874: ARRAY
118875: NOT
118876: PUSH
118877: LD_EXP 50
118881: PUSH
118882: LD_VAR 0 1
118886: ARRAY
118887: PUSH
118888: EMPTY
118889: EQUAL
118890: OR
118891: IFFALSE 118928
// begin for i in defenders do
118893: LD_ADDR_VAR 0 4
118897: PUSH
118898: LD_VAR 0 2
118902: PUSH
118903: FOR_IN
118904: IFFALSE 118917
// ComStop ( i ) ;
118906: LD_VAR 0 4
118910: PPUSH
118911: CALL_OW 141
118915: GO 118903
118917: POP
118918: POP
// defenders := [ ] ;
118919: LD_ADDR_VAR 0 2
118923: PUSH
118924: EMPTY
118925: ST_TO_ADDR
// exit ;
118926: GO 120377
// end ; for i in defenders do
118928: LD_ADDR_VAR 0 4
118932: PUSH
118933: LD_VAR 0 2
118937: PUSH
118938: FOR_IN
118939: IFFALSE 119837
// begin e := NearestUnitToUnit ( enemy , i ) ;
118941: LD_ADDR_VAR 0 13
118945: PUSH
118946: LD_VAR 0 21
118950: PPUSH
118951: LD_VAR 0 4
118955: PPUSH
118956: CALL_OW 74
118960: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118961: LD_ADDR_VAR 0 7
118965: PUSH
118966: LD_EXP 50
118970: PUSH
118971: LD_VAR 0 1
118975: ARRAY
118976: PPUSH
118977: LD_INT 2
118979: PUSH
118980: LD_INT 30
118982: PUSH
118983: LD_INT 0
118985: PUSH
118986: EMPTY
118987: LIST
118988: LIST
118989: PUSH
118990: LD_INT 30
118992: PUSH
118993: LD_INT 1
118995: PUSH
118996: EMPTY
118997: LIST
118998: LIST
118999: PUSH
119000: EMPTY
119001: LIST
119002: LIST
119003: LIST
119004: PPUSH
119005: CALL_OW 72
119009: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119010: LD_ADDR_VAR 0 16
119014: PUSH
119015: LD_VAR 0 7
119019: NOT
119020: PUSH
119021: LD_VAR 0 7
119025: PPUSH
119026: LD_INT 3
119028: PUSH
119029: LD_INT 24
119031: PUSH
119032: LD_INT 600
119034: PUSH
119035: EMPTY
119036: LIST
119037: LIST
119038: PUSH
119039: EMPTY
119040: LIST
119041: LIST
119042: PPUSH
119043: CALL_OW 72
119047: OR
119048: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119049: LD_VAR 0 4
119053: PPUSH
119054: CALL_OW 247
119058: PUSH
119059: LD_INT 2
119061: DOUBLE
119062: EQUAL
119063: IFTRUE 119067
119065: GO 119463
119067: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119068: LD_VAR 0 4
119072: PPUSH
119073: CALL_OW 256
119077: PUSH
119078: LD_INT 1000
119080: EQUAL
119081: PUSH
119082: LD_VAR 0 4
119086: PPUSH
119087: LD_VAR 0 13
119091: PPUSH
119092: CALL_OW 296
119096: PUSH
119097: LD_INT 40
119099: LESS
119100: PUSH
119101: LD_VAR 0 13
119105: PPUSH
119106: LD_EXP 75
119110: PUSH
119111: LD_VAR 0 1
119115: ARRAY
119116: PPUSH
119117: CALL_OW 308
119121: OR
119122: AND
119123: IFFALSE 119245
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119125: LD_VAR 0 4
119129: PPUSH
119130: CALL_OW 262
119134: PUSH
119135: LD_INT 1
119137: EQUAL
119138: PUSH
119139: LD_VAR 0 4
119143: PPUSH
119144: CALL_OW 261
119148: PUSH
119149: LD_INT 30
119151: LESS
119152: AND
119153: PUSH
119154: LD_VAR 0 7
119158: AND
119159: IFFALSE 119229
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119161: LD_VAR 0 4
119165: PPUSH
119166: LD_VAR 0 7
119170: PPUSH
119171: LD_VAR 0 4
119175: PPUSH
119176: CALL_OW 74
119180: PPUSH
119181: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119185: LD_VAR 0 4
119189: PPUSH
119190: LD_VAR 0 7
119194: PPUSH
119195: LD_VAR 0 4
119199: PPUSH
119200: CALL_OW 74
119204: PPUSH
119205: CALL_OW 296
119209: PUSH
119210: LD_INT 6
119212: LESS
119213: IFFALSE 119227
// SetFuel ( i , 100 ) ;
119215: LD_VAR 0 4
119219: PPUSH
119220: LD_INT 100
119222: PPUSH
119223: CALL_OW 240
// end else
119227: GO 119243
// ComAttackUnit ( i , e ) ;
119229: LD_VAR 0 4
119233: PPUSH
119234: LD_VAR 0 13
119238: PPUSH
119239: CALL_OW 115
// end else
119243: GO 119346
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119245: LD_VAR 0 13
119249: PPUSH
119250: LD_EXP 75
119254: PUSH
119255: LD_VAR 0 1
119259: ARRAY
119260: PPUSH
119261: CALL_OW 308
119265: NOT
119266: PUSH
119267: LD_VAR 0 4
119271: PPUSH
119272: LD_VAR 0 13
119276: PPUSH
119277: CALL_OW 296
119281: PUSH
119282: LD_INT 40
119284: GREATEREQUAL
119285: AND
119286: PUSH
119287: LD_VAR 0 4
119291: PPUSH
119292: CALL_OW 256
119296: PUSH
119297: LD_INT 650
119299: LESSEQUAL
119300: OR
119301: PUSH
119302: LD_VAR 0 4
119306: PPUSH
119307: LD_EXP 74
119311: PUSH
119312: LD_VAR 0 1
119316: ARRAY
119317: PPUSH
119318: CALL_OW 308
119322: NOT
119323: AND
119324: IFFALSE 119346
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119326: LD_VAR 0 4
119330: PPUSH
119331: LD_EXP 74
119335: PUSH
119336: LD_VAR 0 1
119340: ARRAY
119341: PPUSH
119342: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119346: LD_VAR 0 4
119350: PPUSH
119351: CALL_OW 256
119355: PUSH
119356: LD_INT 1000
119358: LESS
119359: PUSH
119360: LD_VAR 0 4
119364: PPUSH
119365: CALL_OW 263
119369: PUSH
119370: LD_INT 1
119372: EQUAL
119373: AND
119374: PUSH
119375: LD_VAR 0 4
119379: PPUSH
119380: CALL_OW 311
119384: AND
119385: PUSH
119386: LD_VAR 0 4
119390: PPUSH
119391: LD_EXP 74
119395: PUSH
119396: LD_VAR 0 1
119400: ARRAY
119401: PPUSH
119402: CALL_OW 308
119406: AND
119407: IFFALSE 119461
// begin mech := IsDrivenBy ( i ) ;
119409: LD_ADDR_VAR 0 9
119413: PUSH
119414: LD_VAR 0 4
119418: PPUSH
119419: CALL_OW 311
119423: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119424: LD_VAR 0 9
119428: PPUSH
119429: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119433: LD_VAR 0 9
119437: PPUSH
119438: LD_VAR 0 4
119442: PPUSH
119443: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119447: LD_VAR 0 9
119451: PPUSH
119452: LD_VAR 0 4
119456: PPUSH
119457: CALL_OW 180
// end ; end ; unit_human :
119461: GO 119808
119463: LD_INT 1
119465: DOUBLE
119466: EQUAL
119467: IFTRUE 119471
119469: GO 119807
119471: POP
// begin b := IsInUnit ( i ) ;
119472: LD_ADDR_VAR 0 18
119476: PUSH
119477: LD_VAR 0 4
119481: PPUSH
119482: CALL_OW 310
119486: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119487: LD_ADDR_VAR 0 19
119491: PUSH
119492: LD_VAR 0 18
119496: NOT
119497: PUSH
119498: LD_VAR 0 18
119502: PPUSH
119503: CALL_OW 266
119507: PUSH
119508: LD_INT 32
119510: PUSH
119511: LD_INT 31
119513: PUSH
119514: EMPTY
119515: LIST
119516: LIST
119517: IN
119518: OR
119519: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119520: LD_VAR 0 18
119524: PPUSH
119525: CALL_OW 266
119529: PUSH
119530: LD_INT 5
119532: EQUAL
119533: PUSH
119534: LD_VAR 0 4
119538: PPUSH
119539: CALL_OW 257
119543: PUSH
119544: LD_INT 1
119546: PUSH
119547: LD_INT 2
119549: PUSH
119550: LD_INT 3
119552: PUSH
119553: LD_INT 4
119555: PUSH
119556: EMPTY
119557: LIST
119558: LIST
119559: LIST
119560: LIST
119561: IN
119562: AND
119563: IFFALSE 119600
// begin class := AllowSpecClass ( i ) ;
119565: LD_ADDR_VAR 0 20
119569: PUSH
119570: LD_VAR 0 4
119574: PPUSH
119575: CALL 50835 0 1
119579: ST_TO_ADDR
// if class then
119580: LD_VAR 0 20
119584: IFFALSE 119600
// ComChangeProfession ( i , class ) ;
119586: LD_VAR 0 4
119590: PPUSH
119591: LD_VAR 0 20
119595: PPUSH
119596: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119600: LD_VAR 0 16
119604: PUSH
119605: LD_VAR 0 2
119609: PPUSH
119610: LD_INT 21
119612: PUSH
119613: LD_INT 2
119615: PUSH
119616: EMPTY
119617: LIST
119618: LIST
119619: PPUSH
119620: CALL_OW 72
119624: PUSH
119625: LD_INT 1
119627: LESSEQUAL
119628: OR
119629: PUSH
119630: LD_VAR 0 19
119634: AND
119635: PUSH
119636: LD_VAR 0 4
119640: PUSH
119641: LD_VAR 0 17
119645: IN
119646: NOT
119647: AND
119648: IFFALSE 119741
// begin if b then
119650: LD_VAR 0 18
119654: IFFALSE 119703
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119656: LD_VAR 0 18
119660: PPUSH
119661: LD_VAR 0 21
119665: PPUSH
119666: LD_VAR 0 18
119670: PPUSH
119671: CALL_OW 74
119675: PPUSH
119676: CALL_OW 296
119680: PUSH
119681: LD_INT 10
119683: LESS
119684: PUSH
119685: LD_VAR 0 18
119689: PPUSH
119690: CALL_OW 461
119694: PUSH
119695: LD_INT 7
119697: NONEQUAL
119698: AND
119699: IFFALSE 119703
// continue ;
119701: GO 118938
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119703: LD_ADDR_VAR 0 17
119707: PUSH
119708: LD_VAR 0 17
119712: PPUSH
119713: LD_VAR 0 17
119717: PUSH
119718: LD_INT 1
119720: PLUS
119721: PPUSH
119722: LD_VAR 0 4
119726: PPUSH
119727: CALL_OW 1
119731: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119732: LD_VAR 0 4
119736: PPUSH
119737: CALL_OW 122
// end ; if sold_defenders then
119741: LD_VAR 0 17
119745: IFFALSE 119805
// if i in sold_defenders then
119747: LD_VAR 0 4
119751: PUSH
119752: LD_VAR 0 17
119756: IN
119757: IFFALSE 119805
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119759: LD_VAR 0 4
119763: PPUSH
119764: CALL_OW 314
119768: NOT
119769: PUSH
119770: LD_VAR 0 4
119774: PPUSH
119775: LD_VAR 0 13
119779: PPUSH
119780: CALL_OW 296
119784: PUSH
119785: LD_INT 30
119787: LESS
119788: AND
119789: IFFALSE 119805
// ComAttackUnit ( i , e ) ;
119791: LD_VAR 0 4
119795: PPUSH
119796: LD_VAR 0 13
119800: PPUSH
119801: CALL_OW 115
// end ; end ; end ;
119805: GO 119808
119807: POP
// if IsDead ( i ) then
119808: LD_VAR 0 4
119812: PPUSH
119813: CALL_OW 301
119817: IFFALSE 119835
// defenders := defenders diff i ;
119819: LD_ADDR_VAR 0 2
119823: PUSH
119824: LD_VAR 0 2
119828: PUSH
119829: LD_VAR 0 4
119833: DIFF
119834: ST_TO_ADDR
// end ;
119835: GO 118938
119837: POP
119838: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119839: LD_VAR 0 21
119843: NOT
119844: PUSH
119845: LD_VAR 0 2
119849: NOT
119850: OR
119851: PUSH
119852: LD_EXP 50
119856: PUSH
119857: LD_VAR 0 1
119861: ARRAY
119862: NOT
119863: OR
119864: IFFALSE 118842
// MC_Reset ( base , 18 ) ;
119866: LD_VAR 0 1
119870: PPUSH
119871: LD_INT 18
119873: PPUSH
119874: CALL 22426 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119878: LD_ADDR_VAR 0 2
119882: PUSH
119883: LD_VAR 0 2
119887: PUSH
119888: LD_VAR 0 2
119892: PPUSH
119893: LD_INT 2
119895: PUSH
119896: LD_INT 25
119898: PUSH
119899: LD_INT 1
119901: PUSH
119902: EMPTY
119903: LIST
119904: LIST
119905: PUSH
119906: LD_INT 25
119908: PUSH
119909: LD_INT 5
119911: PUSH
119912: EMPTY
119913: LIST
119914: LIST
119915: PUSH
119916: LD_INT 25
119918: PUSH
119919: LD_INT 8
119921: PUSH
119922: EMPTY
119923: LIST
119924: LIST
119925: PUSH
119926: LD_INT 25
119928: PUSH
119929: LD_INT 9
119931: PUSH
119932: EMPTY
119933: LIST
119934: LIST
119935: PUSH
119936: EMPTY
119937: LIST
119938: LIST
119939: LIST
119940: LIST
119941: LIST
119942: PPUSH
119943: CALL_OW 72
119947: DIFF
119948: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119949: LD_VAR 0 21
119953: NOT
119954: PUSH
119955: LD_VAR 0 2
119959: PPUSH
119960: LD_INT 21
119962: PUSH
119963: LD_INT 2
119965: PUSH
119966: EMPTY
119967: LIST
119968: LIST
119969: PPUSH
119970: CALL_OW 72
119974: AND
119975: IFFALSE 120313
// begin tmp := FilterByTag ( defenders , 19 ) ;
119977: LD_ADDR_VAR 0 11
119981: PUSH
119982: LD_VAR 0 2
119986: PPUSH
119987: LD_INT 19
119989: PPUSH
119990: CALL 84329 0 2
119994: ST_TO_ADDR
// if tmp then
119995: LD_VAR 0 11
119999: IFFALSE 120069
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120001: LD_ADDR_VAR 0 11
120005: PUSH
120006: LD_VAR 0 11
120010: PPUSH
120011: LD_INT 25
120013: PUSH
120014: LD_INT 3
120016: PUSH
120017: EMPTY
120018: LIST
120019: LIST
120020: PPUSH
120021: CALL_OW 72
120025: ST_TO_ADDR
// if tmp then
120026: LD_VAR 0 11
120030: IFFALSE 120069
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120032: LD_ADDR_EXP 62
120036: PUSH
120037: LD_EXP 62
120041: PPUSH
120042: LD_VAR 0 1
120046: PPUSH
120047: LD_EXP 62
120051: PUSH
120052: LD_VAR 0 1
120056: ARRAY
120057: PUSH
120058: LD_VAR 0 11
120062: UNION
120063: PPUSH
120064: CALL_OW 1
120068: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120069: LD_VAR 0 1
120073: PPUSH
120074: LD_INT 19
120076: PPUSH
120077: CALL 22426 0 2
// repeat wait ( 0 0$1 ) ;
120081: LD_INT 35
120083: PPUSH
120084: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120088: LD_EXP 50
120092: PUSH
120093: LD_VAR 0 1
120097: ARRAY
120098: NOT
120099: PUSH
120100: LD_EXP 50
120104: PUSH
120105: LD_VAR 0 1
120109: ARRAY
120110: PUSH
120111: EMPTY
120112: EQUAL
120113: OR
120114: IFFALSE 120151
// begin for i in defenders do
120116: LD_ADDR_VAR 0 4
120120: PUSH
120121: LD_VAR 0 2
120125: PUSH
120126: FOR_IN
120127: IFFALSE 120140
// ComStop ( i ) ;
120129: LD_VAR 0 4
120133: PPUSH
120134: CALL_OW 141
120138: GO 120126
120140: POP
120141: POP
// defenders := [ ] ;
120142: LD_ADDR_VAR 0 2
120146: PUSH
120147: EMPTY
120148: ST_TO_ADDR
// exit ;
120149: GO 120377
// end ; for i in defenders do
120151: LD_ADDR_VAR 0 4
120155: PUSH
120156: LD_VAR 0 2
120160: PUSH
120161: FOR_IN
120162: IFFALSE 120251
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120164: LD_VAR 0 4
120168: PPUSH
120169: LD_EXP 74
120173: PUSH
120174: LD_VAR 0 1
120178: ARRAY
120179: PPUSH
120180: CALL_OW 308
120184: NOT
120185: IFFALSE 120209
// ComMoveToArea ( i , mc_parking [ base ] ) else
120187: LD_VAR 0 4
120191: PPUSH
120192: LD_EXP 74
120196: PUSH
120197: LD_VAR 0 1
120201: ARRAY
120202: PPUSH
120203: CALL_OW 113
120207: GO 120249
// if GetControl ( i ) = control_manual then
120209: LD_VAR 0 4
120213: PPUSH
120214: CALL_OW 263
120218: PUSH
120219: LD_INT 1
120221: EQUAL
120222: IFFALSE 120249
// if IsDrivenBy ( i ) then
120224: LD_VAR 0 4
120228: PPUSH
120229: CALL_OW 311
120233: IFFALSE 120249
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120235: LD_VAR 0 4
120239: PPUSH
120240: CALL_OW 311
120244: PPUSH
120245: CALL_OW 121
// end ;
120249: GO 120161
120251: POP
120252: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120253: LD_VAR 0 2
120257: PPUSH
120258: LD_INT 95
120260: PUSH
120261: LD_EXP 74
120265: PUSH
120266: LD_VAR 0 1
120270: ARRAY
120271: PUSH
120272: EMPTY
120273: LIST
120274: LIST
120275: PPUSH
120276: CALL_OW 72
120280: PUSH
120281: LD_VAR 0 2
120285: EQUAL
120286: PUSH
120287: LD_EXP 73
120291: PUSH
120292: LD_VAR 0 1
120296: ARRAY
120297: OR
120298: PUSH
120299: LD_EXP 50
120303: PUSH
120304: LD_VAR 0 1
120308: ARRAY
120309: NOT
120310: OR
120311: IFFALSE 120081
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120313: LD_ADDR_EXP 72
120317: PUSH
120318: LD_EXP 72
120322: PPUSH
120323: LD_VAR 0 1
120327: PPUSH
120328: LD_VAR 0 2
120332: PPUSH
120333: LD_INT 21
120335: PUSH
120336: LD_INT 2
120338: PUSH
120339: EMPTY
120340: LIST
120341: LIST
120342: PPUSH
120343: CALL_OW 72
120347: PPUSH
120348: CALL_OW 1
120352: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120353: LD_VAR 0 1
120357: PPUSH
120358: LD_INT 19
120360: PPUSH
120361: CALL 22426 0 2
// MC_Reset ( base , 20 ) ;
120365: LD_VAR 0 1
120369: PPUSH
120370: LD_INT 20
120372: PPUSH
120373: CALL 22426 0 2
// end ; end_of_file
120377: LD_VAR 0 3
120381: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120382: LD_VAR 0 1
120386: PUSH
120387: LD_INT 200
120389: DOUBLE
120390: GREATEREQUAL
120391: IFFALSE 120399
120393: LD_INT 299
120395: DOUBLE
120396: LESSEQUAL
120397: IFTRUE 120401
120399: GO 120433
120401: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120402: LD_VAR 0 1
120406: PPUSH
120407: LD_VAR 0 2
120411: PPUSH
120412: LD_VAR 0 3
120416: PPUSH
120417: LD_VAR 0 4
120421: PPUSH
120422: LD_VAR 0 5
120426: PPUSH
120427: CALL 108382 0 5
120431: GO 120510
120433: LD_INT 300
120435: DOUBLE
120436: GREATEREQUAL
120437: IFFALSE 120445
120439: LD_INT 399
120441: DOUBLE
120442: LESSEQUAL
120443: IFTRUE 120447
120445: GO 120509
120447: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120448: LD_VAR 0 1
120452: PPUSH
120453: LD_VAR 0 2
120457: PPUSH
120458: LD_VAR 0 3
120462: PPUSH
120463: LD_VAR 0 4
120467: PPUSH
120468: LD_VAR 0 5
120472: PPUSH
120473: LD_VAR 0 6
120477: PPUSH
120478: LD_VAR 0 7
120482: PPUSH
120483: LD_VAR 0 8
120487: PPUSH
120488: LD_VAR 0 9
120492: PPUSH
120493: LD_VAR 0 10
120497: PPUSH
120498: LD_VAR 0 11
120502: PPUSH
120503: CALL 104370 0 11
120507: GO 120510
120509: POP
// end ;
120510: PPOPN 11
120512: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120513: LD_VAR 0 1
120517: PPUSH
120518: LD_VAR 0 2
120522: PPUSH
120523: LD_VAR 0 3
120527: PPUSH
120528: LD_VAR 0 4
120532: PPUSH
120533: LD_VAR 0 5
120537: PPUSH
120538: CALL 107847 0 5
// end ; end_of_file
120542: PPOPN 5
120544: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120545: LD_VAR 0 1
120549: PPUSH
120550: LD_VAR 0 2
120554: PPUSH
120555: LD_VAR 0 3
120559: PPUSH
120560: LD_VAR 0 4
120564: PPUSH
120565: LD_VAR 0 5
120569: PPUSH
120570: LD_VAR 0 6
120574: PPUSH
120575: CALL 92022 0 6
// end ;
120579: PPOPN 6
120581: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120582: LD_INT 0
120584: PPUSH
// begin if not units then
120585: LD_VAR 0 1
120589: NOT
120590: IFFALSE 120594
// exit ;
120592: GO 120594
// end ;
120594: PPOPN 7
120596: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120597: CALL 91909 0 0
// end ;
120601: PPOPN 1
120603: END
