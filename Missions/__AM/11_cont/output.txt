// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18315 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83182 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20495 0 0
// Action ;
  89: CALL 8749 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42233 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42233 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42233 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42659 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42551 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42551 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49025 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49025 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49025 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49025 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49025 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49025 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49025 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49025 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49025 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49025 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49025 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49025 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49025 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49025 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49025 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 3
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57484 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57484 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57484 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57484 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57484 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 54040 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 54040 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 54162 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42947 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42551 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 55058 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5053: LD_EXP 6
5057: IFFALSE 7020
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5071: LD_ADDR_VAR 0 4
5075: PUSH
5076: LD_INT 5
5078: PUSH
5079: LD_INT 6
5081: PUSH
5082: LD_INT 7
5084: PUSH
5085: LD_INT 8
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: PUSH
5094: LD_OWVAR 67
5098: ARRAY
5099: ST_TO_ADDR
// coords := [ ] ;
5100: LD_ADDR_VAR 0 5
5104: PUSH
5105: EMPTY
5106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: LD_INT 0
5114: PUSH
5115: LD_INT 0
5117: PUSH
5118: LD_INT 0
5120: PUSH
5121: LD_INT 0
5123: PUSH
5124: LD_INT 1
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: LD_INT 0
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: LD_INT 1
5138: PUSH
5139: LD_INT 0
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5154: LD_INT 1
5156: PPUSH
5157: LD_INT 14
5159: PUSH
5160: LD_INT 1
5162: PUSH
5163: LD_INT 2
5165: PUSH
5166: LD_INT 28
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 14
5177: PUSH
5178: LD_INT 1
5180: PUSH
5181: LD_INT 2
5183: PUSH
5184: LD_INT 25
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 14
5195: PUSH
5196: LD_INT 1
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: LD_INT 28
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_INT 14
5213: PUSH
5214: LD_INT 1
5216: PUSH
5217: LD_INT 2
5219: PUSH
5220: LD_INT 29
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL 42551 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5239: LD_INT 21000
5241: PUSH
5242: LD_INT 19950
5244: PUSH
5245: LD_INT 18900
5247: PUSH
5248: LD_INT 18200
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 67
// InitHc ;
5267: CALL_OW 19
// InitUc ;
5271: CALL_OW 18
// uc_side := 2 ;
5275: LD_ADDR_OWVAR 20
5279: PUSH
5280: LD_INT 2
5282: ST_TO_ADDR
// uc_nation := 2 ;
5283: LD_ADDR_OWVAR 21
5287: PUSH
5288: LD_INT 2
5290: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5291: LD_ADDR_VAR 0 3
5295: PUSH
5296: EMPTY
5297: PUSH
5298: EMPTY
5299: PUSH
5300: EMPTY
5301: PUSH
5302: EMPTY
5303: PUSH
5304: EMPTY
5305: PUSH
5306: EMPTY
5307: LIST
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5313: LD_ADDR_VAR 0 3
5317: PUSH
5318: LD_VAR 0 3
5322: PPUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_EXP 69
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 2
5337: PUSH
5338: LD_INT 34
5340: PUSH
5341: LD_INT 88
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_INT 32
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: DIFF
5368: PPUSH
5369: CALL_OW 1
5373: ST_TO_ADDR
// for i = 1 to Difficulty do
5374: LD_ADDR_VAR 0 1
5378: PUSH
5379: DOUBLE
5380: LD_INT 1
5382: DEC
5383: ST_TO_ADDR
5384: LD_OWVAR 67
5388: PUSH
5389: FOR_TO
5390: IFFALSE 5528
// begin uc_side := 2 ;
5392: LD_ADDR_OWVAR 20
5396: PUSH
5397: LD_INT 2
5399: ST_TO_ADDR
// uc_nation := 2 ;
5400: LD_ADDR_OWVAR 21
5404: PUSH
5405: LD_INT 2
5407: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5408: LD_INT 13
5410: PPUSH
5411: LD_INT 3
5413: PPUSH
5414: LD_INT 5
5416: PPUSH
5417: LD_INT 29
5419: PPUSH
5420: LD_INT 100
5422: PPUSH
5423: CALL 54040 0 5
// un := CreateVehicle ;
5427: LD_ADDR_VAR 0 2
5431: PUSH
5432: CALL_OW 45
5436: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5437: LD_ADDR_VAR 0 3
5441: PUSH
5442: LD_VAR 0 3
5446: PPUSH
5447: LD_INT 1
5449: PUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PUSH
5459: LD_INT 1
5461: PLUS
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PPUSH
5467: LD_VAR 0 2
5471: PPUSH
5472: CALL 54162 0 3
5476: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5477: LD_VAR 0 2
5481: PPUSH
5482: LD_INT 3
5484: PPUSH
5485: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 16
5496: PPUSH
5497: LD_INT 0
5499: PPUSH
5500: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5504: LD_VAR 0 2
5508: PPUSH
5509: LD_INT 51
5511: PPUSH
5512: LD_INT 10
5514: PPUSH
5515: CALL_OW 111
// wait ( 0 0$2 ) ;
5519: LD_INT 70
5521: PPUSH
5522: CALL_OW 67
// end ;
5526: GO 5389
5528: POP
5529: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5530: LD_ADDR_VAR 0 5
5534: PUSH
5535: LD_INT 51
5537: PUSH
5538: LD_INT 24
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: LD_INT 75
5547: PUSH
5548: LD_INT 90
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5559: LD_INT 1
5561: PPUSH
5562: LD_VAR 0 3
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PPUSH
5571: LD_VAR 0 5
5575: PPUSH
5576: LD_VAR 0 6
5580: PPUSH
5581: CALL 42784 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_INT 1
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: LD_INT 4
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: PUSH
5613: LD_OWVAR 67
5617: ARRAY
5618: PUSH
5619: FOR_TO
5620: IFFALSE 5720
// begin uc_side := 2 ;
5622: LD_ADDR_OWVAR 20
5626: PUSH
5627: LD_INT 2
5629: ST_TO_ADDR
// uc_nation := 2 ;
5630: LD_ADDR_OWVAR 21
5634: PUSH
5635: LD_INT 2
5637: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5638: LD_INT 0
5640: PPUSH
5641: LD_INT 17
5643: PPUSH
5644: LD_VAR 0 4
5648: PPUSH
5649: CALL_OW 380
// un := CreateHuman ;
5653: LD_ADDR_VAR 0 2
5657: PUSH
5658: CALL_OW 44
5662: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5663: LD_ADDR_VAR 0 3
5667: PUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 2
5675: PUSH
5676: LD_VAR 0 3
5680: PUSH
5681: LD_INT 2
5683: ARRAY
5684: PUSH
5685: LD_INT 1
5687: PLUS
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PPUSH
5693: LD_VAR 0 2
5697: PPUSH
5698: CALL 54162 0 3
5702: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5703: LD_VAR 0 2
5707: PPUSH
5708: LD_INT 13
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 49
// end ;
5718: GO 5619
5720: POP
5721: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5722: LD_ADDR_VAR 0 1
5726: PUSH
5727: DOUBLE
5728: LD_INT 1
5730: DEC
5731: ST_TO_ADDR
5732: LD_INT 3
5734: PUSH
5735: LD_INT 4
5737: PUSH
5738: LD_INT 5
5740: PUSH
5741: LD_INT 6
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_OWVAR 67
5754: ARRAY
5755: PUSH
5756: FOR_TO
5757: IFFALSE 5878
// begin uc_side := 2 ;
5759: LD_ADDR_OWVAR 20
5763: PUSH
5764: LD_INT 2
5766: ST_TO_ADDR
// uc_nation := 2 ;
5767: LD_ADDR_OWVAR 21
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 8
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_VAR 0 1
5792: PUSH
5793: LD_INT 2
5795: MOD
5796: PUSH
5797: LD_INT 1
5799: PLUS
5800: ARRAY
5801: PPUSH
5802: LD_VAR 0 4
5806: PPUSH
5807: CALL_OW 380
// un := CreateHuman ;
5811: LD_ADDR_VAR 0 2
5815: PUSH
5816: CALL_OW 44
5820: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_VAR 0 3
5830: PPUSH
5831: LD_INT 2
5833: PUSH
5834: LD_VAR 0 3
5838: PUSH
5839: LD_INT 2
5841: ARRAY
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL 54162 0 3
5860: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5861: LD_VAR 0 2
5865: PPUSH
5866: LD_INT 13
5868: PPUSH
5869: LD_INT 0
5871: PPUSH
5872: CALL_OW 49
// end ;
5876: GO 5756
5878: POP
5879: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 67
5887: PUSH
5888: LD_INT 112
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 85
5897: PUSH
5898: LD_INT 130
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5909: LD_INT 2
5911: PPUSH
5912: LD_VAR 0 3
5916: PUSH
5917: LD_INT 2
5919: ARRAY
5920: PPUSH
5921: LD_VAR 0 5
5925: PPUSH
5926: LD_VAR 0 6
5930: PPUSH
5931: CALL 42784 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5935: LD_ADDR_VAR 0 1
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: PUSH
5963: LD_OWVAR 67
5967: ARRAY
5968: PUSH
5969: FOR_TO
5970: IFFALSE 6070
// begin uc_side := 2 ;
5972: LD_ADDR_OWVAR 20
5976: PUSH
5977: LD_INT 2
5979: ST_TO_ADDR
// uc_nation := 2 ;
5980: LD_ADDR_OWVAR 21
5984: PUSH
5985: LD_INT 2
5987: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5988: LD_INT 0
5990: PPUSH
5991: LD_INT 17
5993: PPUSH
5994: LD_VAR 0 4
5998: PPUSH
5999: CALL_OW 380
// un := CreateHuman ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: CALL_OW 44
6012: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6013: LD_ADDR_VAR 0 3
6017: PUSH
6018: LD_VAR 0 3
6022: PPUSH
6023: LD_INT 3
6025: PUSH
6026: LD_VAR 0 3
6030: PUSH
6031: LD_INT 3
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PLUS
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: LD_VAR 0 2
6047: PPUSH
6048: CALL 54162 0 3
6052: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6053: LD_VAR 0 2
6057: PPUSH
6058: LD_INT 14
6060: PPUSH
6061: LD_INT 0
6063: PPUSH
6064: CALL_OW 49
// end ;
6068: GO 5969
6070: POP
6071: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6072: LD_ADDR_VAR 0 5
6076: PUSH
6077: LD_INT 148
6079: PUSH
6080: LD_INT 158
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 148
6089: PUSH
6090: LD_INT 158
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6101: LD_INT 3
6103: PPUSH
6104: LD_VAR 0 3
6108: PUSH
6109: LD_INT 3
6111: ARRAY
6112: PPUSH
6113: LD_VAR 0 5
6117: PPUSH
6118: LD_VAR 0 6
6122: PPUSH
6123: CALL 42784 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 2
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 4
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_OWVAR 67
6159: ARRAY
6160: PUSH
6161: FOR_TO
6162: IFFALSE 6386
// begin uc_side := 2 ;
6164: LD_ADDR_OWVAR 20
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// uc_nation := 2 ;
6172: LD_ADDR_OWVAR 21
6176: PUSH
6177: LD_INT 2
6179: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6180: LD_INT 14
6182: PPUSH
6183: LD_INT 3
6185: PPUSH
6186: LD_INT 1
6188: PUSH
6189: LD_INT 5
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PUSH
6196: LD_INT 1
6198: PPUSH
6199: LD_INT 2
6201: PPUSH
6202: CALL_OW 12
6206: ARRAY
6207: PPUSH
6208: LD_INT 27
6210: PUSH
6211: LD_INT 26
6213: PUSH
6214: LD_INT 28
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 3
6227: PPUSH
6228: CALL_OW 12
6232: ARRAY
6233: PPUSH
6234: LD_INT 100
6236: PPUSH
6237: CALL 54040 0 5
// un := CreateVehicle ;
6241: LD_ADDR_VAR 0 2
6245: PUSH
6246: CALL_OW 45
6250: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: LD_VAR 0 3
6260: PPUSH
6261: LD_INT 4
6263: PUSH
6264: LD_VAR 0 3
6268: PUSH
6269: LD_INT 4
6271: ARRAY
6272: PUSH
6273: LD_INT 1
6275: PLUS
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: LD_VAR 0 2
6285: PPUSH
6286: CALL 54162 0 3
6290: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6291: LD_VAR 0 2
6295: PPUSH
6296: LD_INT 5
6298: PPUSH
6299: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 15
6310: PPUSH
6311: LD_INT 0
6313: PPUSH
6314: CALL_OW 49
// if GetControl ( un ) = control_manual then
6318: LD_VAR 0 2
6322: PPUSH
6323: CALL_OW 263
6327: PUSH
6328: LD_INT 1
6330: EQUAL
6331: IFFALSE 6362
// begin PrepareHuman ( false , 3 , skill ) ;
6333: LD_INT 0
6335: PPUSH
6336: LD_INT 3
6338: PPUSH
6339: LD_VAR 0 4
6343: PPUSH
6344: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6348: CALL_OW 44
6352: PPUSH
6353: LD_VAR 0 2
6357: PPUSH
6358: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6362: LD_VAR 0 2
6366: PPUSH
6367: LD_INT 179
6369: PPUSH
6370: LD_INT 135
6372: PPUSH
6373: CALL_OW 111
// wait ( 0 0$2 ) ;
6377: LD_INT 70
6379: PPUSH
6380: CALL_OW 67
// end ;
6384: GO 6161
6386: POP
6387: POP
// vc_chassis := 15 ;
6388: LD_ADDR_OWVAR 37
6392: PUSH
6393: LD_INT 15
6395: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6396: LD_ADDR_VAR 0 3
6400: PUSH
6401: LD_VAR 0 3
6405: PPUSH
6406: LD_INT 4
6408: PUSH
6409: LD_VAR 0 3
6413: PUSH
6414: LD_INT 4
6416: ARRAY
6417: PUSH
6418: LD_INT 1
6420: PLUS
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PPUSH
6426: CALL_OW 45
6430: PPUSH
6431: CALL 54162 0 3
6435: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6436: LD_VAR 0 3
6440: PUSH
6441: LD_INT 4
6443: ARRAY
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: ARRAY
6454: PPUSH
6455: LD_INT 15
6457: PPUSH
6458: LD_INT 0
6460: PPUSH
6461: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6465: LD_INT 0
6467: PPUSH
6468: LD_INT 11
6470: PPUSH
6471: LD_VAR 0 4
6475: PPUSH
6476: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6480: LD_ADDR_VAR 0 3
6484: PUSH
6485: LD_VAR 0 3
6489: PPUSH
6490: LD_INT 4
6492: PUSH
6493: LD_VAR 0 3
6497: PUSH
6498: LD_INT 4
6500: ARRAY
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 44
6514: PPUSH
6515: CALL 54162 0 3
6519: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6520: LD_VAR 0 3
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PUSH
6529: LD_VAR 0 3
6533: PUSH
6534: LD_INT 4
6536: ARRAY
6537: ARRAY
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: PUSH
6557: LD_INT 1
6559: MINUS
6560: ARRAY
6561: PPUSH
6562: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6566: LD_ADDR_VAR 0 5
6570: PUSH
6571: LD_INT 148
6573: PUSH
6574: LD_INT 140
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6584: LD_INT 1
6586: PPUSH
6587: LD_VAR 0 3
6591: PUSH
6592: LD_INT 4
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PPUSH
6601: LD_VAR 0 6
6605: PPUSH
6606: CALL 42784 0 4
// if gensher_active then
6610: LD_EXP 18
6614: IFFALSE 7020
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6616: LD_EXP 45
6620: PPUSH
6621: LD_STRING D10-Diet-1
6623: PPUSH
6624: CALL_OW 94
// for i = 1 to 2 do
6628: LD_ADDR_VAR 0 1
6632: PUSH
6633: DOUBLE
6634: LD_INT 1
6636: DEC
6637: ST_TO_ADDR
6638: LD_INT 2
6640: PUSH
6641: FOR_TO
6642: IFFALSE 6780
// begin uc_side := 2 ;
6644: LD_ADDR_OWVAR 20
6648: PUSH
6649: LD_INT 2
6651: ST_TO_ADDR
// uc_nation := 2 ;
6652: LD_ADDR_OWVAR 21
6656: PUSH
6657: LD_INT 2
6659: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6660: LD_INT 13
6662: PPUSH
6663: LD_INT 3
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: LD_INT 29
6671: PPUSH
6672: LD_INT 100
6674: PPUSH
6675: CALL 54040 0 5
// un := CreateVehicle ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 45
6688: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PPUSH
6699: LD_INT 5
6701: PUSH
6702: LD_VAR 0 3
6706: PUSH
6707: LD_INT 5
6709: ARRAY
6710: PUSH
6711: LD_INT 1
6713: PLUS
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PPUSH
6719: LD_VAR 0 2
6723: PPUSH
6724: CALL 54162 0 3
6728: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6729: LD_VAR 0 2
6733: PPUSH
6734: LD_INT 0
6736: PPUSH
6737: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 23
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6756: LD_VAR 0 2
6760: PPUSH
6761: LD_INT 85
6763: PPUSH
6764: LD_INT 152
6766: PPUSH
6767: CALL_OW 111
// wait ( 0 0$2 ) ;
6771: LD_INT 70
6773: PPUSH
6774: CALL_OW 67
// end ;
6778: GO 6641
6780: POP
6781: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: DOUBLE
6788: LD_INT 1
6790: DEC
6791: ST_TO_ADDR
6792: LD_INT 2
6794: PUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 3
6800: PUSH
6801: LD_INT 4
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_OWVAR 67
6814: ARRAY
6815: PUSH
6816: FOR_TO
6817: IFFALSE 6974
// begin uc_side := 2 ;
6819: LD_ADDR_OWVAR 20
6823: PUSH
6824: LD_INT 2
6826: ST_TO_ADDR
// uc_nation := 2 ;
6827: LD_ADDR_OWVAR 21
6831: PUSH
6832: LD_INT 2
6834: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6835: LD_INT 14
6837: PPUSH
6838: LD_INT 3
6840: PPUSH
6841: LD_INT 5
6843: PPUSH
6844: LD_INT 27
6846: PUSH
6847: LD_INT 28
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PUSH
6854: LD_INT 1
6856: PPUSH
6857: LD_INT 2
6859: PPUSH
6860: CALL_OW 12
6864: ARRAY
6865: PPUSH
6866: LD_INT 100
6868: PPUSH
6869: CALL 54040 0 5
// un := CreateVehicle ;
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: CALL_OW 45
6882: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6883: LD_ADDR_VAR 0 3
6887: PUSH
6888: LD_VAR 0 3
6892: PPUSH
6893: LD_INT 5
6895: PUSH
6896: LD_VAR 0 3
6900: PUSH
6901: LD_INT 5
6903: ARRAY
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: LD_VAR 0 2
6917: PPUSH
6918: CALL 54162 0 3
6922: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6923: LD_VAR 0 2
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 23
6942: PPUSH
6943: LD_INT 0
6945: PPUSH
6946: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 85
6957: PPUSH
6958: LD_INT 152
6960: PPUSH
6961: CALL_OW 111
// wait ( 0 0$2 ) ;
6965: LD_INT 70
6967: PPUSH
6968: CALL_OW 67
// end ;
6972: GO 6816
6974: POP
6975: POP
// coords := [ [ 97 , 143 ] ] ;
6976: LD_ADDR_VAR 0 5
6980: PUSH
6981: LD_INT 97
6983: PUSH
6984: LD_INT 143
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6994: LD_INT 1
6996: PPUSH
6997: LD_VAR 0 3
7001: PUSH
7002: LD_INT 5
7004: ARRAY
7005: PPUSH
7006: LD_VAR 0 5
7010: PPUSH
7011: LD_VAR 0 6
7015: PPUSH
7016: CALL 42784 0 4
// end ; end ;
7020: PPOPN 7
7022: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7023: GO 7025
7025: DISABLE
7026: LD_INT 0
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
// begin enable ;
7035: ENABLE
// tmp := [ ] ;
7036: LD_ADDR_VAR 0 2
7040: PUSH
7041: EMPTY
7042: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7043: LD_ADDR_VAR 0 5
7047: PUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 12
7058: ST_TO_ADDR
// if w = 3 then
7059: LD_VAR 0 5
7063: PUSH
7064: LD_INT 3
7066: EQUAL
7067: IFFALSE 7154
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7069: LD_ADDR_VAR 0 6
7073: PUSH
7074: LD_INT 11
7076: PUSH
7077: LD_INT 1
7079: PUSH
7080: LD_INT 2
7082: PUSH
7083: LD_INT 24
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 11
7094: PUSH
7095: LD_INT 1
7097: PUSH
7098: LD_INT 2
7100: PUSH
7101: LD_INT 24
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 11
7112: PUSH
7113: LD_INT 1
7115: PUSH
7116: LD_INT 2
7118: PUSH
7119: LD_INT 24
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 11
7130: PUSH
7131: LD_INT 1
7133: PUSH
7134: LD_INT 2
7136: PUSH
7137: LD_INT 24
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: ST_TO_ADDR
7152: GO 7256
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7154: LD_ADDR_VAR 0 6
7158: PUSH
7159: LD_INT 14
7161: PUSH
7162: LD_INT 1
7164: PUSH
7165: LD_INT 2
7167: PUSH
7168: LD_INT 28
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 14
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: LD_INT 2
7185: PUSH
7186: LD_INT 25
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: PUSH
7195: LD_INT 14
7197: PUSH
7198: LD_INT 1
7200: PUSH
7201: LD_INT 2
7203: PUSH
7204: LD_INT 28
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 14
7215: PUSH
7216: LD_INT 1
7218: PUSH
7219: LD_INT 2
7221: PUSH
7222: LD_INT 29
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 14
7233: PUSH
7234: LD_INT 1
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: LD_INT 29
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: ST_TO_ADDR
// if w < 3 then
7256: LD_VAR 0 5
7260: PUSH
7261: LD_INT 3
7263: LESS
7264: IFFALSE 7344
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7266: LD_ADDR_VAR 0 6
7270: PUSH
7271: LD_VAR 0 6
7275: PPUSH
7276: LD_INT 1
7278: PUSH
7279: LD_VAR 0 6
7283: PUSH
7284: LD_VAR 0 1
7288: ARRAY
7289: PUSH
7290: LD_INT 1
7292: PLUS
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PPUSH
7298: LD_INT 14
7300: PUSH
7301: LD_INT 1
7303: PUSH
7304: LD_INT 2
7306: PUSH
7307: LD_INT 25
7309: PUSH
7310: LD_INT 28
7312: PUSH
7313: LD_INT 29
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: LIST
7320: PUSH
7321: LD_INT 1
7323: PPUSH
7324: LD_INT 3
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL 54162 0 3
7343: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7344: LD_INT 1
7346: PPUSH
7347: LD_VAR 0 6
7351: PPUSH
7352: CALL 42551 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7356: LD_INT 45
7358: PPUSH
7359: CALL_OW 255
7363: PUSH
7364: LD_INT 2
7366: EQUAL
7367: PUSH
7368: LD_INT 45
7370: PPUSH
7371: CALL_OW 302
7375: AND
7376: PUSH
7377: LD_VAR 0 5
7381: PUSH
7382: LD_INT 3
7384: LESS
7385: AND
7386: IFFALSE 7471
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7388: LD_ADDR_VAR 0 6
7392: PUSH
7393: LD_INT 14
7395: PUSH
7396: LD_INT 1
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: LD_INT 28
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: LIST
7409: LIST
7410: PUSH
7411: LD_INT 14
7413: PUSH
7414: LD_INT 1
7416: PUSH
7417: LD_INT 2
7419: PUSH
7420: LD_INT 27
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: PUSH
7429: LD_INT 14
7431: PUSH
7432: LD_INT 1
7434: PUSH
7435: LD_INT 2
7437: PUSH
7438: LD_INT 27
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7452: LD_INT 2
7454: PPUSH
7455: LD_VAR 0 6
7459: PPUSH
7460: CALL 42551 0 2
// wait ( 0 0$20 ) ;
7464: LD_INT 700
7466: PPUSH
7467: CALL_OW 67
// end ; p := 60 ;
7471: LD_ADDR_VAR 0 7
7475: PUSH
7476: LD_INT 60
7478: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7479: LD_INT 35
7481: PPUSH
7482: CALL_OW 67
// p := Dec ( p ) ;
7486: LD_ADDR_VAR 0 7
7490: PUSH
7491: LD_VAR 0 7
7495: PPUSH
7496: CALL 87876 0 1
7500: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7501: LD_EXP 69
7505: PUSH
7506: LD_INT 1
7508: ARRAY
7509: PPUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 34
7518: PUSH
7519: LD_INT 32
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 34
7528: PUSH
7529: LD_INT 88
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 72
7549: PUSH
7550: LD_INT 4
7552: GREATEREQUAL
7553: PUSH
7554: LD_VAR 0 7
7558: PUSH
7559: LD_INT 0
7561: LESSEQUAL
7562: OR
7563: IFFALSE 7479
// wait ( 0 0$10 ) ;
7565: LD_INT 350
7567: PPUSH
7568: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_EXP 69
7581: PUSH
7582: LD_INT 1
7584: ARRAY
7585: PPUSH
7586: LD_INT 3
7588: PUSH
7589: LD_INT 2
7591: PUSH
7592: LD_INT 34
7594: PUSH
7595: LD_INT 32
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 34
7604: PUSH
7605: LD_INT 88
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: LIST
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PPUSH
7621: CALL_OW 72
7625: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7626: LD_ADDR_VAR 0 3
7630: PUSH
7631: LD_EXP 69
7635: PUSH
7636: LD_INT 2
7638: ARRAY
7639: PPUSH
7640: LD_INT 3
7642: PUSH
7643: LD_INT 2
7645: PUSH
7646: LD_INT 34
7648: PUSH
7649: LD_INT 32
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 34
7658: PUSH
7659: LD_INT 88
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PPUSH
7675: CALL_OW 72
7679: ST_TO_ADDR
// if tmp2 then
7680: LD_VAR 0 3
7684: IFFALSE 7702
// tmp := tmp union tmp2 ;
7686: LD_ADDR_VAR 0 2
7690: PUSH
7691: LD_VAR 0 2
7695: PUSH
7696: LD_VAR 0 3
7700: UNION
7701: ST_TO_ADDR
// if not tmp then
7702: LD_VAR 0 2
7706: NOT
7707: IFFALSE 7711
// exit ;
7709: GO 8071
// if Count ( tmp2 ) or Prob ( 50 ) then
7711: LD_VAR 0 3
7715: PPUSH
7716: CALL 51127 0 1
7720: PUSH
7721: LD_INT 50
7723: PPUSH
7724: CALL_OW 13
7728: OR
7729: IFFALSE 7762
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7731: LD_ADDR_VAR 0 4
7735: PUSH
7736: LD_INT 48
7738: PUSH
7739: LD_INT 33
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: PUSH
7746: LD_INT 71
7748: PUSH
7749: LD_INT 88
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: ST_TO_ADDR
7760: GO 7791
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7762: LD_ADDR_VAR 0 4
7766: PUSH
7767: LD_INT 128
7769: PUSH
7770: LD_INT 94
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 180
7779: PUSH
7780: LD_INT 135
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: ST_TO_ADDR
// if w = 3 then
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 3
7798: EQUAL
7799: IFFALSE 7830
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7801: LD_ADDR_VAR 0 4
7805: PUSH
7806: LD_INT 91
7808: PUSH
7809: LD_INT 58
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 117
7818: PUSH
7819: LD_INT 107
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7830: LD_INT 28
7832: PPUSH
7833: LD_INT 22
7835: PUSH
7836: LD_INT 1
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 70
7847: IFFALSE 7867
// coords := [ [ 163 , 41 ] ] ;
7849: LD_ADDR_VAR 0 4
7853: PUSH
7854: LD_INT 163
7856: PUSH
7857: LD_INT 41
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PUSH
7864: EMPTY
7865: LIST
7866: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7867: LD_VAR 0 2
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_INT 1
7879: ARRAY
7880: PPUSH
7881: LD_VAR 0 4
7885: PUSH
7886: LD_INT 2
7888: ARRAY
7889: PPUSH
7890: CALL_OW 114
// p := 90 ;
7894: LD_ADDR_VAR 0 7
7898: PUSH
7899: LD_INT 90
7901: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7902: LD_INT 35
7904: PPUSH
7905: CALL_OW 67
// p := Dec ( p ) ;
7909: LD_ADDR_VAR 0 7
7913: PUSH
7914: LD_VAR 0 7
7918: PPUSH
7919: CALL 87876 0 1
7923: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7924: LD_VAR 0 2
7928: PPUSH
7929: LD_INT 60
7931: PUSH
7932: EMPTY
7933: LIST
7934: PPUSH
7935: CALL_OW 72
7939: PUSH
7940: LD_INT 0
7942: EQUAL
7943: PUSH
7944: LD_VAR 0 7
7948: PUSH
7949: LD_INT 0
7951: LESSEQUAL
7952: OR
7953: IFFALSE 7902
// repeat wait ( 0 0$2 ) ;
7955: LD_INT 70
7957: PPUSH
7958: CALL_OW 67
// for i in tmp do
7962: LD_ADDR_VAR 0 1
7966: PUSH
7967: LD_VAR 0 2
7971: PUSH
7972: FOR_IN
7973: IFFALSE 8062
// if GetChassis ( i ) = ar_hovercraft then
7975: LD_VAR 0 1
7979: PPUSH
7980: CALL_OW 265
7984: PUSH
7985: LD_INT 11
7987: EQUAL
7988: IFFALSE 8026
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7990: LD_VAR 0 1
7994: PPUSH
7995: LD_INT 22
7997: PUSH
7998: LD_INT 1
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PPUSH
8005: CALL_OW 69
8009: PPUSH
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 74
8019: PPUSH
8020: CALL 82108 0 2
8024: GO 8060
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8026: LD_VAR 0 1
8030: PPUSH
8031: LD_INT 22
8033: PUSH
8034: LD_INT 1
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PPUSH
8041: CALL_OW 69
8045: PPUSH
8046: LD_VAR 0 1
8050: PPUSH
8051: CALL_OW 74
8055: PPUSH
8056: CALL_OW 115
8060: GO 7972
8062: POP
8063: POP
// until not tmp ;
8064: LD_VAR 0 2
8068: NOT
8069: IFFALSE 7955
// end ;
8071: PPOPN 7
8073: END
// every 28 28$00 do var i , tmp , un , x , p ;
8074: GO 8076
8076: DISABLE
8077: LD_INT 0
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
// begin enable ;
8084: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8085: LD_INT 35
8087: PPUSH
8088: LD_INT 1190
8090: PPUSH
8091: CALL_OW 12
8095: PPUSH
8096: CALL_OW 67
// tmp := [ ] ;
8100: LD_ADDR_VAR 0 2
8104: PUSH
8105: EMPTY
8106: ST_TO_ADDR
// InitHc ;
8107: CALL_OW 19
// for i = 1 to 3 do
8111: LD_ADDR_VAR 0 1
8115: PUSH
8116: DOUBLE
8117: LD_INT 1
8119: DEC
8120: ST_TO_ADDR
8121: LD_INT 3
8123: PUSH
8124: FOR_TO
8125: IFFALSE 8268
// begin uc_side := 8 ;
8127: LD_ADDR_OWVAR 20
8131: PUSH
8132: LD_INT 8
8134: ST_TO_ADDR
// uc_nation := 2 ;
8135: LD_ADDR_OWVAR 21
8139: PUSH
8140: LD_INT 2
8142: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8143: LD_INT 13
8145: PUSH
8146: LD_INT 14
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: LD_INT 1
8155: PPUSH
8156: LD_INT 2
8158: PPUSH
8159: CALL_OW 12
8163: ARRAY
8164: PPUSH
8165: LD_INT 3
8167: PPUSH
8168: LD_INT 5
8170: PPUSH
8171: LD_INT 27
8173: PUSH
8174: LD_INT 28
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PPUSH
8193: LD_INT 100
8195: PPUSH
8196: CALL 54040 0 5
// un := CreateVehicle ;
8200: LD_ADDR_VAR 0 3
8204: PUSH
8205: CALL_OW 45
8209: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8210: LD_VAR 0 3
8214: PPUSH
8215: LD_INT 4
8217: PPUSH
8218: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8222: LD_VAR 0 3
8226: PPUSH
8227: LD_INT 15
8229: PPUSH
8230: LD_INT 0
8232: PPUSH
8233: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8237: LD_ADDR_VAR 0 2
8241: PUSH
8242: LD_VAR 0 2
8246: PPUSH
8247: LD_VAR 0 2
8251: PUSH
8252: LD_INT 1
8254: PLUS
8255: PPUSH
8256: LD_VAR 0 3
8260: PPUSH
8261: CALL_OW 1
8265: ST_TO_ADDR
// end ;
8266: GO 8124
8268: POP
8269: POP
// for i = 1 to 3 do
8270: LD_ADDR_VAR 0 1
8274: PUSH
8275: DOUBLE
8276: LD_INT 1
8278: DEC
8279: ST_TO_ADDR
8280: LD_INT 3
8282: PUSH
8283: FOR_TO
8284: IFFALSE 8392
// begin uc_side := 8 ;
8286: LD_ADDR_OWVAR 20
8290: PUSH
8291: LD_INT 8
8293: ST_TO_ADDR
// uc_nation := 2 ;
8294: LD_ADDR_OWVAR 21
8298: PUSH
8299: LD_INT 2
8301: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8302: LD_INT 0
8304: PPUSH
8305: LD_INT 1
8307: PPUSH
8308: LD_INT 6
8310: PPUSH
8311: CALL_OW 380
// un := CreateHuman ;
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: CALL_OW 44
8324: ST_TO_ADDR
// if Prob ( 50 ) then
8325: LD_INT 50
8327: PPUSH
8328: CALL_OW 13
8332: IFFALSE 8346
// SetClass ( un , class_mortar ) ;
8334: LD_VAR 0 3
8338: PPUSH
8339: LD_INT 8
8341: PPUSH
8342: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8346: LD_VAR 0 3
8350: PPUSH
8351: LD_INT 15
8353: PPUSH
8354: LD_INT 0
8356: PPUSH
8357: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8361: LD_ADDR_VAR 0 2
8365: PUSH
8366: LD_VAR 0 2
8370: PPUSH
8371: LD_VAR 0 2
8375: PUSH
8376: LD_INT 1
8378: PLUS
8379: PPUSH
8380: LD_VAR 0 3
8384: PPUSH
8385: CALL_OW 1
8389: ST_TO_ADDR
// end ;
8390: GO 8283
8392: POP
8393: POP
// wait ( 0 0$3 ) ;
8394: LD_INT 105
8396: PPUSH
8397: CALL_OW 67
// p := 0 ;
8401: LD_ADDR_VAR 0 5
8405: PUSH
8406: LD_INT 0
8408: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8409: LD_INT 105
8411: PPUSH
8412: CALL_OW 67
// p := p + 3 ;
8416: LD_ADDR_VAR 0 5
8420: PUSH
8421: LD_VAR 0 5
8425: PUSH
8426: LD_INT 3
8428: PLUS
8429: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8430: LD_ADDR_VAR 0 1
8434: PUSH
8435: LD_VAR 0 2
8439: PPUSH
8440: LD_INT 50
8442: PUSH
8443: EMPTY
8444: LIST
8445: PPUSH
8446: CALL_OW 72
8450: PUSH
8451: FOR_IN
8452: IFFALSE 8490
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8454: LD_VAR 0 1
8458: PPUSH
8459: LD_INT 81
8461: PUSH
8462: LD_INT 8
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PPUSH
8469: CALL_OW 69
8473: PPUSH
8474: LD_VAR 0 1
8478: PPUSH
8479: CALL_OW 74
8483: PPUSH
8484: CALL_OW 115
8488: GO 8451
8490: POP
8491: POP
// until p >= 120 ;
8492: LD_VAR 0 5
8496: PUSH
8497: LD_INT 120
8499: GREATEREQUAL
8500: IFFALSE 8409
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8502: LD_VAR 0 2
8506: PPUSH
8507: LD_INT 210
8509: PPUSH
8510: LD_INT 178
8512: PPUSH
8513: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8517: LD_ADDR_VAR 0 4
8521: PUSH
8522: LD_INT 10
8524: PPUSH
8525: LD_INT 22
8527: PUSH
8528: LD_INT 8
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL_OW 70
8539: ST_TO_ADDR
// if x then
8540: LD_VAR 0 4
8544: IFFALSE 8572
// for i in x do
8546: LD_ADDR_VAR 0 1
8550: PUSH
8551: LD_VAR 0 4
8555: PUSH
8556: FOR_IN
8557: IFFALSE 8570
// RemoveUnit ( i ) ;
8559: LD_VAR 0 1
8563: PPUSH
8564: CALL_OW 64
8568: GO 8556
8570: POP
8571: POP
// wait ( 0 0$1 ) ;
8572: LD_INT 35
8574: PPUSH
8575: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8579: LD_INT 22
8581: PUSH
8582: LD_INT 8
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PPUSH
8589: CALL_OW 69
8593: NOT
8594: IFFALSE 8502
// end ;
8596: PPOPN 5
8598: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8599: LD_INT 22
8601: PUSH
8602: LD_INT 2
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: PUSH
8609: LD_INT 34
8611: PUSH
8612: LD_INT 31
8614: PUSH
8615: EMPTY
8616: LIST
8617: LIST
8618: PUSH
8619: LD_INT 3
8621: PUSH
8622: LD_INT 24
8624: PUSH
8625: LD_INT 1000
8627: PUSH
8628: EMPTY
8629: LIST
8630: LIST
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: LIST
8640: PPUSH
8641: CALL_OW 69
8645: IFFALSE 8748
8647: GO 8649
8649: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8650: LD_INT 45
8652: PPUSH
8653: CALL_OW 302
8657: PUSH
8658: LD_INT 45
8660: PPUSH
8661: CALL_OW 255
8665: AND
8666: IFFALSE 8709
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8668: LD_INT 22
8670: PUSH
8671: LD_INT 2
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PUSH
8678: LD_INT 34
8680: PUSH
8681: LD_INT 31
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: PPUSH
8692: CALL_OW 69
8696: PPUSH
8697: LD_INT 18
8699: PPUSH
8700: LD_INT 8
8702: PPUSH
8703: CALL_OW 111
8707: GO 8748
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8709: LD_INT 22
8711: PUSH
8712: LD_INT 2
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: PUSH
8719: LD_INT 34
8721: PUSH
8722: LD_INT 31
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: PPUSH
8733: CALL_OW 69
8737: PPUSH
8738: LD_INT 106
8740: PPUSH
8741: LD_INT 14
8743: PPUSH
8744: CALL_OW 111
// end ; end_of_file
8748: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8749: LD_INT 0
8751: PPUSH
8752: PPUSH
8753: PPUSH
8754: PPUSH
8755: PPUSH
8756: PPUSH
// InGameOn ;
8757: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8761: LD_EXP 21
8765: PPUSH
8766: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8770: LD_INT 2
8772: PPUSH
8773: LD_INT 1
8775: PPUSH
8776: LD_INT 1
8778: PPUSH
8779: LD_INT 1
8781: PPUSH
8782: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8786: LD_ADDR_VAR 0 2
8790: PUSH
8791: LD_INT 22
8793: PUSH
8794: LD_INT 1
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 25
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PPUSH
8815: CALL_OW 69
8819: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8820: LD_ADDR_VAR 0 4
8824: PUSH
8825: LD_INT 22
8827: PUSH
8828: LD_INT 1
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 34
8837: PUSH
8838: LD_INT 11
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 69
8853: PUSH
8854: LD_INT 1
8856: ARRAY
8857: ST_TO_ADDR
// for i = 1 to tmp do
8858: LD_ADDR_VAR 0 6
8862: PUSH
8863: DOUBLE
8864: LD_INT 1
8866: DEC
8867: ST_TO_ADDR
8868: LD_VAR 0 2
8872: PUSH
8873: FOR_TO
8874: IFFALSE 8921
// begin if i = 5 then
8876: LD_VAR 0 6
8880: PUSH
8881: LD_INT 5
8883: EQUAL
8884: IFFALSE 8888
// break ;
8886: GO 8921
// sols := Replace ( sols , i , tmp [ i ] ) ;
8888: LD_ADDR_VAR 0 5
8892: PUSH
8893: LD_VAR 0 5
8897: PPUSH
8898: LD_VAR 0 6
8902: PPUSH
8903: LD_VAR 0 2
8907: PUSH
8908: LD_VAR 0 6
8912: ARRAY
8913: PPUSH
8914: CALL_OW 1
8918: ST_TO_ADDR
// end ;
8919: GO 8873
8921: POP
8922: POP
// tmp := ar_force_tmp ;
8923: LD_ADDR_VAR 0 2
8927: PUSH
8928: LD_EXP 40
8932: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8933: LD_VAR 0 2
8937: PUSH
8938: LD_INT 1
8940: ARRAY
8941: PPUSH
8942: LD_INT 108
8944: PPUSH
8945: LD_INT 139
8947: PPUSH
8948: LD_INT 0
8950: PPUSH
8951: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8955: LD_VAR 0 2
8959: PUSH
8960: LD_INT 1
8962: ARRAY
8963: PPUSH
8964: LD_EXP 21
8968: PPUSH
8969: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8973: LD_VAR 0 2
8977: PUSH
8978: LD_INT 2
8980: ARRAY
8981: PPUSH
8982: LD_INT 114
8984: PPUSH
8985: LD_INT 132
8987: PPUSH
8988: LD_INT 0
8990: PPUSH
8991: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8995: LD_VAR 0 2
8999: PUSH
9000: LD_INT 3
9002: ARRAY
9003: PPUSH
9004: LD_INT 115
9006: PPUSH
9007: LD_INT 132
9009: PPUSH
9010: LD_INT 0
9012: PPUSH
9013: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9017: LD_VAR 0 2
9021: PUSH
9022: LD_INT 2
9024: ARRAY
9025: PUSH
9026: LD_VAR 0 2
9030: PUSH
9031: LD_INT 3
9033: ARRAY
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PPUSH
9039: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9043: LD_VAR 0 4
9047: PPUSH
9048: LD_INT 83
9050: PPUSH
9051: LD_INT 123
9053: PPUSH
9054: CALL_OW 111
// Wait ( 0 0$01 ) ;
9058: LD_INT 35
9060: PPUSH
9061: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9065: LD_INT 90
9067: PPUSH
9068: LD_INT 144
9070: PPUSH
9071: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9075: LD_VAR 0 5
9079: PPUSH
9080: LD_INT 88
9082: PPUSH
9083: LD_INT 129
9085: PPUSH
9086: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9090: LD_ADDR_VAR 0 3
9094: PUSH
9095: LD_INT 92
9097: PUSH
9098: LD_INT 131
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: PUSH
9105: LD_INT 88
9107: PUSH
9108: LD_INT 127
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: LD_INT 91
9117: PUSH
9118: LD_INT 132
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: LD_INT 92
9127: PUSH
9128: LD_INT 134
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: ST_TO_ADDR
// for i = 1 to sols do
9141: LD_ADDR_VAR 0 6
9145: PUSH
9146: DOUBLE
9147: LD_INT 1
9149: DEC
9150: ST_TO_ADDR
9151: LD_VAR 0 5
9155: PUSH
9156: FOR_TO
9157: IFFALSE 9230
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9159: LD_VAR 0 5
9163: PUSH
9164: LD_VAR 0 6
9168: ARRAY
9169: PPUSH
9170: LD_VAR 0 3
9174: PUSH
9175: LD_VAR 0 6
9179: ARRAY
9180: PUSH
9181: LD_INT 1
9183: ARRAY
9184: PPUSH
9185: LD_VAR 0 3
9189: PUSH
9190: LD_VAR 0 6
9194: ARRAY
9195: PUSH
9196: LD_INT 2
9198: ARRAY
9199: PPUSH
9200: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9204: LD_VAR 0 5
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PPUSH
9215: CALL_OW 197
// AddComHold ( sols ) ;
9219: LD_VAR 0 5
9223: PPUSH
9224: CALL_OW 200
// end ;
9228: GO 9156
9230: POP
9231: POP
// repeat wait ( 0 0$1 ) ;
9232: LD_INT 35
9234: PPUSH
9235: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9239: LD_VAR 0 5
9243: PUSH
9244: LD_INT 1
9246: ARRAY
9247: PPUSH
9248: LD_INT 92
9250: PPUSH
9251: LD_INT 131
9253: PPUSH
9254: CALL_OW 297
9258: PUSH
9259: LD_INT 4
9261: LESS
9262: IFFALSE 9232
// CenterOnXY ( 96 , 139 ) ;
9264: LD_INT 96
9266: PPUSH
9267: LD_INT 139
9269: PPUSH
9270: CALL_OW 84
// wait ( 0 0$3 ) ;
9274: LD_INT 105
9276: PPUSH
9277: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9281: LD_INT 111
9283: PPUSH
9284: LD_INT 135
9286: PPUSH
9287: LD_INT 1
9289: PPUSH
9290: LD_INT 25
9292: NEG
9293: PPUSH
9294: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9298: LD_VAR 0 2
9302: PUSH
9303: LD_INT 2
9305: ARRAY
9306: PPUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 250
9320: PUSH
9321: LD_INT 3
9323: PLUS
9324: PPUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: CALL_OW 251
9338: PPUSH
9339: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9343: LD_VAR 0 2
9347: PUSH
9348: LD_INT 3
9350: ARRAY
9351: PPUSH
9352: LD_INT 7
9354: PPUSH
9355: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9359: LD_VAR 0 2
9363: PUSH
9364: LD_INT 2
9366: ARRAY
9367: PPUSH
9368: LD_VAR 0 2
9372: PUSH
9373: LD_INT 1
9375: ARRAY
9376: PPUSH
9377: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9381: LD_INT 35
9383: PPUSH
9384: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9388: LD_VAR 0 2
9392: PUSH
9393: LD_INT 1
9395: ARRAY
9396: PPUSH
9397: LD_VAR 0 2
9401: PUSH
9402: LD_INT 2
9404: ARRAY
9405: PPUSH
9406: CALL_OW 296
9410: PUSH
9411: LD_INT 5
9413: LESS
9414: IFFALSE 9381
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 1
9423: ARRAY
9424: PPUSH
9425: LD_VAR 0 2
9429: PUSH
9430: LD_INT 2
9432: ARRAY
9433: PPUSH
9434: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9438: LD_VAR 0 2
9442: PUSH
9443: LD_INT 1
9445: ARRAY
9446: PPUSH
9447: LD_STRING D1a-Merc1-1
9449: PPUSH
9450: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9454: LD_VAR 0 2
9458: PUSH
9459: LD_INT 2
9461: ARRAY
9462: PPUSH
9463: LD_STRING D1a-FMerc2-1
9465: PPUSH
9466: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9470: LD_VAR 0 2
9474: PUSH
9475: LD_INT 2
9477: ARRAY
9478: PPUSH
9479: LD_VAR 0 2
9483: PUSH
9484: LD_INT 1
9486: ARRAY
9487: PPUSH
9488: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9492: LD_VAR 0 2
9496: PUSH
9497: LD_INT 1
9499: ARRAY
9500: PPUSH
9501: LD_INT 500
9503: PPUSH
9504: CALL_OW 234
// wait ( 0 0$2 ) ;
9508: LD_INT 70
9510: PPUSH
9511: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9515: LD_VAR 0 2
9519: PUSH
9520: LD_INT 1
9522: ARRAY
9523: PPUSH
9524: LD_INT 2
9526: PPUSH
9527: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9531: LD_INT 10
9533: PPUSH
9534: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9538: LD_VAR 0 2
9542: PUSH
9543: LD_INT 1
9545: ARRAY
9546: PPUSH
9547: LD_STRING D1a-Merc1-2
9549: PPUSH
9550: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9554: LD_INT 7
9556: PPUSH
9557: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9561: LD_VAR 0 2
9565: PUSH
9566: LD_INT 1
9568: ARRAY
9569: PPUSH
9570: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9574: LD_VAR 0 2
9578: PUSH
9579: LD_INT 2
9581: ARRAY
9582: PPUSH
9583: LD_INT 10
9585: PPUSH
9586: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9590: LD_VAR 0 2
9594: PUSH
9595: LD_INT 2
9597: ARRAY
9598: PPUSH
9599: LD_STRING D1a-FMerc2-2
9601: PPUSH
9602: CALL_OW 88
// wait ( 0 0$1 ) ;
9606: LD_INT 35
9608: PPUSH
9609: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9613: LD_INT 7
9615: PPUSH
9616: CALL_OW 85
// wait ( 0 0$2 ) ;
9620: LD_INT 70
9622: PPUSH
9623: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9627: LD_EXP 44
9631: PPUSH
9632: LD_STRING D1a-Saliba-1
9634: PPUSH
9635: CALL_OW 91
// KillUnit ( Saliba ) ;
9639: LD_EXP 44
9643: PPUSH
9644: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9648: LD_VAR 0 2
9652: PUSH
9653: LD_INT 3
9655: ARRAY
9656: PPUSH
9657: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9661: LD_EXP 21
9665: PPUSH
9666: CALL_OW 85
// wait ( 0 0$1 ) ;
9670: LD_INT 35
9672: PPUSH
9673: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9677: LD_VAR 0 5
9681: PPUSH
9682: LD_INT 88
9684: PPUSH
9685: LD_INT 141
9687: PPUSH
9688: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9692: LD_VAR 0 5
9696: PPUSH
9697: LD_INT 70
9699: PPUSH
9700: CALL_OW 202
// wait ( 0 0$2 ) ;
9704: LD_INT 70
9706: PPUSH
9707: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9711: LD_INT 2
9713: PPUSH
9714: LD_INT 1
9716: PPUSH
9717: LD_INT 2
9719: PPUSH
9720: LD_INT 1
9722: PPUSH
9723: CALL_OW 80
// InGameOff ;
9727: CALL_OW 9
// ComWalk ( sols ) ;
9731: LD_VAR 0 5
9735: PPUSH
9736: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9740: LD_STRING M1
9742: PPUSH
9743: CALL_OW 337
// game_speed := 4 ;
9747: LD_ADDR_OWVAR 65
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9755: LD_INT 111
9757: PPUSH
9758: LD_INT 135
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL_OW 331
// SaveForQuickRestart ;
9768: CALL_OW 22
// ar_run := true ;
9772: LD_ADDR_EXP 5
9776: PUSH
9777: LD_INT 1
9779: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9780: LD_INT 35
9782: PPUSH
9783: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9787: LD_INT 22
9789: PUSH
9790: LD_INT 1
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 91
9799: PUSH
9800: LD_INT 7
9802: PUSH
9803: LD_INT 10
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: LIST
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PPUSH
9815: CALL_OW 69
9819: PUSH
9820: LD_INT 7
9822: PPUSH
9823: CALL_OW 256
9827: PUSH
9828: LD_INT 999
9830: LESS
9831: OR
9832: IFFALSE 9780
// if GetSide ( ar_dep_s ) = 2 then
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 255
9841: PUSH
9842: LD_INT 2
9844: EQUAL
9845: IFFALSE 9857
// SetSide ( ar_dep_s , 1 ) ;
9847: LD_INT 7
9849: PPUSH
9850: LD_INT 1
9852: PPUSH
9853: CALL_OW 235
// end ;
9857: LD_VAR 0 1
9861: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9862: LD_EXP 5
9866: IFFALSE 10226
9868: GO 9870
9870: DISABLE
9871: LD_INT 0
9873: PPUSH
9874: PPUSH
9875: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9876: LD_ADDR_VAR 0 2
9880: PUSH
9881: LD_EXP 40
9885: PUSH
9886: LD_EXP 36
9890: PPUSH
9891: LD_INT 2
9893: PUSH
9894: LD_INT 21
9896: PUSH
9897: LD_INT 2
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 21
9906: PUSH
9907: LD_INT 1
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: EMPTY
9915: LIST
9916: LIST
9917: LIST
9918: PPUSH
9919: CALL_OW 72
9923: ADD
9924: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9925: LD_VAR 0 2
9929: PPUSH
9930: LD_INT 5
9932: PPUSH
9933: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9937: LD_INT 5
9939: PPUSH
9940: LD_INT 1
9942: PPUSH
9943: CALL_OW 343
// k := 1 ;
9947: LD_ADDR_VAR 0 3
9951: PUSH
9952: LD_INT 1
9954: ST_TO_ADDR
// for i in tmp do
9955: LD_ADDR_VAR 0 1
9959: PUSH
9960: LD_VAR 0 2
9964: PUSH
9965: FOR_IN
9966: IFFALSE 10051
// begin if IsInUnit ( i ) then
9968: LD_VAR 0 1
9972: PPUSH
9973: CALL_OW 310
9977: IFFALSE 9988
// ComExitBuilding ( i ) ;
9979: LD_VAR 0 1
9983: PPUSH
9984: CALL_OW 122
// if GetClass ( i ) = 3 then
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 257
9997: PUSH
9998: LD_INT 3
10000: EQUAL
10001: IFFALSE 10037
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10003: LD_VAR 0 1
10007: PPUSH
10008: LD_EXP 41
10012: PUSH
10013: LD_VAR 0 3
10017: ARRAY
10018: PPUSH
10019: CALL_OW 180
// k := k + 1 ;
10023: LD_ADDR_VAR 0 3
10027: PUSH
10028: LD_VAR 0 3
10032: PUSH
10033: LD_INT 1
10035: PLUS
10036: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10037: LD_VAR 0 1
10041: PPUSH
10042: LD_INT 10
10044: PPUSH
10045: CALL_OW 173
// end ;
10049: GO 9965
10051: POP
10052: POP
// ar_patrol := true ;
10053: LD_ADDR_EXP 7
10057: PUSH
10058: LD_INT 1
10060: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 67
// for i in tmp do
10068: LD_ADDR_VAR 0 1
10072: PUSH
10073: LD_VAR 0 2
10077: PUSH
10078: FOR_IN
10079: IFFALSE 10107
// if not HasTask ( i ) then
10081: LD_VAR 0 1
10085: PPUSH
10086: CALL_OW 314
10090: NOT
10091: IFFALSE 10105
// ComMoveToArea ( i , escape_area ) ;
10093: LD_VAR 0 1
10097: PPUSH
10098: LD_INT 10
10100: PPUSH
10101: CALL_OW 113
10105: GO 10078
10107: POP
10108: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10109: LD_ADDR_VAR 0 3
10113: PUSH
10114: LD_VAR 0 2
10118: PPUSH
10119: LD_INT 95
10121: PUSH
10122: LD_INT 10
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 72
10133: ST_TO_ADDR
// if k then
10134: LD_VAR 0 3
10138: IFFALSE 10207
// for i in k do
10140: LD_ADDR_VAR 0 1
10144: PUSH
10145: LD_VAR 0 3
10149: PUSH
10150: FOR_IN
10151: IFFALSE 10205
// begin if IsInUnit ( i ) then
10153: LD_VAR 0 1
10157: PPUSH
10158: CALL_OW 310
10162: IFFALSE 10178
// RemoveUnit ( IsInUnit ( i ) ) ;
10164: LD_VAR 0 1
10168: PPUSH
10169: CALL_OW 310
10173: PPUSH
10174: CALL_OW 64
// RemoveUnit ( i ) ;
10178: LD_VAR 0 1
10182: PPUSH
10183: CALL_OW 64
// tmp := tmp diff i ;
10187: LD_ADDR_VAR 0 2
10191: PUSH
10192: LD_VAR 0 2
10196: PUSH
10197: LD_VAR 0 1
10201: DIFF
10202: ST_TO_ADDR
// end ;
10203: GO 10150
10205: POP
10206: POP
// until tmp = [ ] ;
10207: LD_VAR 0 2
10211: PUSH
10212: EMPTY
10213: EQUAL
10214: IFFALSE 10061
// ChangeSideFog ( 5 , 5 ) ;
10216: LD_INT 5
10218: PPUSH
10219: LD_INT 5
10221: PPUSH
10222: CALL_OW 343
// end ;
10226: PPOPN 3
10228: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10229: LD_EXP 7
10233: IFFALSE 10523
10235: GO 10237
10237: DISABLE
10238: LD_INT 0
10240: PPUSH
10241: PPUSH
10242: PPUSH
// begin uc_side := 2 ;
10243: LD_ADDR_OWVAR 20
10247: PUSH
10248: LD_INT 2
10250: ST_TO_ADDR
// uc_nation := 2 ;
10251: LD_ADDR_OWVAR 21
10255: PUSH
10256: LD_INT 2
10258: ST_TO_ADDR
// InitHc ;
10259: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10263: LD_INT 1
10265: PPUSH
10266: LD_INT 1
10268: PPUSH
10269: LD_INT 6
10271: PPUSH
10272: CALL_OW 380
// un := CreateHuman ;
10276: LD_ADDR_VAR 0 2
10280: PUSH
10281: CALL_OW 44
10285: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10286: LD_INT 14
10288: PPUSH
10289: LD_INT 1
10291: PPUSH
10292: LD_INT 1
10294: PPUSH
10295: LD_INT 27
10297: PPUSH
10298: LD_INT 98
10300: PPUSH
10301: CALL 54040 0 5
// veh := CreateVehicle ;
10305: LD_ADDR_VAR 0 3
10309: PUSH
10310: CALL_OW 45
10314: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_INT 4
10322: PPUSH
10323: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10327: LD_VAR 0 3
10331: PPUSH
10332: LD_INT 179
10334: PPUSH
10335: LD_INT 135
10337: PPUSH
10338: LD_INT 0
10340: PPUSH
10341: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10345: LD_VAR 0 2
10349: PPUSH
10350: LD_VAR 0 3
10354: PPUSH
10355: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10359: LD_VAR 0 2
10363: PPUSH
10364: LD_INT 126
10366: PPUSH
10367: LD_INT 133
10369: PPUSH
10370: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10374: LD_INT 10
10376: PPUSH
10377: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10381: LD_INT 1
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: CALL_OW 292
10393: PUSH
10394: LD_VAR 0 3
10398: PPUSH
10399: LD_INT 7
10401: PPUSH
10402: CALL_OW 296
10406: PUSH
10407: LD_INT 9
10409: LESS
10410: OR
10411: IFFALSE 10374
// ComHold ( veh ) ;
10413: LD_VAR 0 3
10417: PPUSH
10418: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: LD_STRING D2aa-Ar1-1
10429: PPUSH
10430: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10434: LD_VAR 0 2
10438: PPUSH
10439: LD_INT 177
10441: PPUSH
10442: LD_INT 96
10444: PPUSH
10445: CALL_OW 111
// AddComExitVehicle ( un ) ;
10449: LD_VAR 0 2
10453: PPUSH
10454: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10458: LD_INT 35
10460: PPUSH
10461: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10465: LD_VAR 0 2
10469: PPUSH
10470: LD_INT 204
10472: PPUSH
10473: CALL_OW 296
10477: PUSH
10478: LD_INT 15
10480: LESS
10481: IFFALSE 10458
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10483: LD_ADDR_EXP 50
10487: PUSH
10488: LD_EXP 50
10492: PPUSH
10493: LD_INT 3
10495: PUSH
10496: LD_EXP 50
10500: PUSH
10501: LD_INT 3
10503: ARRAY
10504: PUSH
10505: LD_INT 1
10507: PLUS
10508: PUSH
10509: EMPTY
10510: LIST
10511: LIST
10512: PPUSH
10513: LD_VAR 0 2
10517: PPUSH
10518: CALL 54162 0 3
10522: ST_TO_ADDR
// end ;
10523: PPOPN 3
10525: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10526: LD_INT 7
10528: PPUSH
10529: CALL_OW 255
10533: PUSH
10534: LD_INT 1
10536: EQUAL
10537: PUSH
10538: LD_INT 7
10540: PPUSH
10541: CALL_OW 301
10545: OR
10546: IFFALSE 12951
10548: GO 10550
10550: DISABLE
10551: LD_INT 0
10553: PPUSH
10554: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10555: LD_ADDR_VAR 0 1
10559: PUSH
10560: LD_EXP 36
10564: PPUSH
10565: LD_INT 21
10567: PUSH
10568: LD_INT 3
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: FOR_IN
10581: IFFALSE 10597
// SetSide ( i , 1 ) ;
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 1
10590: PPUSH
10591: CALL_OW 235
10595: GO 10580
10597: POP
10598: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10599: LD_ADDR_VAR 0 2
10603: PUSH
10604: LD_INT 46
10606: PUSH
10607: LD_INT 41
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: PUSH
10614: LD_INT 50
10616: PUSH
10617: LD_INT 25
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 57
10626: PUSH
10627: LD_INT 75
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: LD_INT 75
10636: PUSH
10637: LD_INT 89
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 51
10646: PUSH
10647: LD_INT 45
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 95
10656: PUSH
10657: LD_INT 95
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 84
10666: PUSH
10667: LD_INT 77
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: LD_INT 101
10676: PUSH
10677: LD_INT 76
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 118
10686: PUSH
10687: LD_INT 81
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 139
10696: PUSH
10697: LD_INT 97
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 129
10706: PUSH
10707: LD_INT 114
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 154
10716: PUSH
10717: LD_INT 111
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: ST_TO_ADDR
// base_captured := true ;
10738: LD_ADDR_EXP 6
10742: PUSH
10743: LD_INT 1
10745: ST_TO_ADDR
// DialogueOn ;
10746: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10750: LD_EXP 21
10754: PPUSH
10755: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10759: LD_EXP 21
10763: PPUSH
10764: LD_STRING D2-JMM-1
10766: PPUSH
10767: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10771: LD_EXP 30
10775: PPUSH
10776: LD_STRING D2-Pow-1
10778: PPUSH
10779: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10783: LD_EXP 21
10787: PPUSH
10788: LD_STRING D2-JMM-2
10790: PPUSH
10791: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10795: LD_EXP 30
10799: PPUSH
10800: LD_STRING D2-Pow-2
10802: PPUSH
10803: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10807: LD_EXP 21
10811: PPUSH
10812: LD_STRING D2-JMM-3
10814: PPUSH
10815: CALL_OW 88
// DialogueOff ;
10819: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10823: LD_STRING M2
10825: PPUSH
10826: CALL_OW 337
// Wait ( 0 0$2 ) ;
10830: LD_INT 70
10832: PPUSH
10833: CALL_OW 67
// if IsOk ( Gary ) then
10837: LD_EXP 32
10841: PPUSH
10842: CALL_OW 302
10846: IFFALSE 10860
// Say ( Gary , D2a-Gary-1 ) ;
10848: LD_EXP 32
10852: PPUSH
10853: LD_STRING D2a-Gary-1
10855: PPUSH
10856: CALL_OW 88
// if IsOk ( Bobby ) then
10860: LD_EXP 24
10864: PPUSH
10865: CALL_OW 302
10869: IFFALSE 10883
// Say ( Bobby , D2a-Bobby-1 ) ;
10871: LD_EXP 24
10875: PPUSH
10876: LD_STRING D2a-Bobby-1
10878: PPUSH
10879: CALL_OW 88
// if IsOk ( Cyrus ) then
10883: LD_EXP 25
10887: PPUSH
10888: CALL_OW 302
10892: IFFALSE 10906
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10894: LD_EXP 25
10898: PPUSH
10899: LD_STRING D2a-Cyrus-1
10901: PPUSH
10902: CALL_OW 88
// if IsOk ( Lisa ) then
10906: LD_EXP 22
10910: PPUSH
10911: CALL_OW 302
10915: IFFALSE 10929
// Say ( Lisa , D2a-Lisa-1 ) ;
10917: LD_EXP 22
10921: PPUSH
10922: LD_STRING D2a-Lisa-1
10924: PPUSH
10925: CALL_OW 88
// if IsOk ( Frank ) then
10929: LD_EXP 33
10933: PPUSH
10934: CALL_OW 302
10938: IFFALSE 10952
// Say ( Frank , D2a-Frank-1 ) ;
10940: LD_EXP 33
10944: PPUSH
10945: LD_STRING D2a-Frank-1
10947: PPUSH
10948: CALL_OW 88
// if IsOk ( Cornel ) then
10952: LD_EXP 31
10956: PPUSH
10957: CALL_OW 302
10961: IFFALSE 10975
// Say ( Cornel , D2a-Corn-1 ) ;
10963: LD_EXP 31
10967: PPUSH
10968: LD_STRING D2a-Corn-1
10970: PPUSH
10971: CALL_OW 88
// if IsOk ( Donaldson ) then
10975: LD_EXP 23
10979: PPUSH
10980: CALL_OW 302
10984: IFFALSE 10998
// Say ( Donaldson , D2a-Don-1 ) ;
10986: LD_EXP 23
10990: PPUSH
10991: LD_STRING D2a-Don-1
10993: PPUSH
10994: CALL_OW 88
// if IsOk ( Brown ) then
10998: LD_EXP 27
11002: PPUSH
11003: CALL_OW 302
11007: IFFALSE 11021
// Say ( Brown , D2a-Brown-1 ) ;
11009: LD_EXP 27
11013: PPUSH
11014: LD_STRING D2a-Brown-1
11016: PPUSH
11017: CALL_OW 88
// Wait ( 0 0$30 ) ;
11021: LD_INT 1050
11023: PPUSH
11024: CALL_OW 67
// if IsOk ( Frank ) then
11028: LD_EXP 33
11032: PPUSH
11033: CALL_OW 302
11037: IFFALSE 12017
// begin DialogueOn ;
11039: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11043: LD_EXP 21
11047: PUSH
11048: LD_EXP 33
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PPUSH
11057: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11061: LD_EXP 33
11065: PPUSH
11066: LD_STRING D3F-Frank-1
11068: PPUSH
11069: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11073: LD_EXP 21
11077: PPUSH
11078: LD_STRING D3F-JMM-1
11080: PPUSH
11081: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11085: LD_EXP 33
11089: PPUSH
11090: LD_STRING D3F-Frank-2
11092: PPUSH
11093: CALL_OW 88
// case Query ( QFrank ) of 1 :
11097: LD_STRING QFrank
11099: PPUSH
11100: CALL_OW 97
11104: PUSH
11105: LD_INT 1
11107: DOUBLE
11108: EQUAL
11109: IFTRUE 11113
11111: GO 11136
11113: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11114: LD_EXP 21
11118: PPUSH
11119: LD_STRING D3Fa-JMM-1
11121: PPUSH
11122: CALL_OW 88
// us_scout := 1 ;
11126: LD_ADDR_EXP 8
11130: PUSH
11131: LD_INT 1
11133: ST_TO_ADDR
// end ; 2 :
11134: GO 11299
11136: LD_INT 2
11138: DOUBLE
11139: EQUAL
11140: IFTRUE 11144
11142: GO 11266
11144: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11145: LD_EXP 21
11149: PPUSH
11150: LD_STRING D3Fb-JMM-1
11152: PPUSH
11153: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11157: LD_EXP 33
11161: PPUSH
11162: LD_STRING D3Fb-Frank-1
11164: PPUSH
11165: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11169: LD_STRING QFrank2
11171: PPUSH
11172: CALL_OW 97
11176: PUSH
11177: LD_INT 1
11179: DOUBLE
11180: EQUAL
11181: IFTRUE 11185
11183: GO 11232
11185: POP
// begin us_scout := 2 ;
11186: LD_ADDR_EXP 8
11190: PUSH
11191: LD_INT 2
11193: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11194: LD_EXP 21
11198: PPUSH
11199: LD_STRING D3Fba-JMM-1
11201: PPUSH
11202: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11206: LD_EXP 33
11210: PPUSH
11211: LD_STRING D3Fba-Frank-1
11213: PPUSH
11214: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11218: LD_EXP 21
11222: PPUSH
11223: LD_STRING D3Fba-JMM-2
11225: PPUSH
11226: CALL_OW 88
// end ; 2 :
11230: GO 11264
11232: LD_INT 2
11234: DOUBLE
11235: EQUAL
11236: IFTRUE 11240
11238: GO 11263
11240: POP
// begin us_scout := 0 ;
11241: LD_ADDR_EXP 8
11245: PUSH
11246: LD_INT 0
11248: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11249: LD_EXP 21
11253: PPUSH
11254: LD_STRING D3Fbb-JMM-1
11256: PPUSH
11257: CALL_OW 88
// end ; end ;
11261: GO 11264
11263: POP
// end ; 3 :
11264: GO 11299
11266: LD_INT 3
11268: DOUBLE
11269: EQUAL
11270: IFTRUE 11274
11272: GO 11298
11274: POP
// begin us_scout := - 1 ;
11275: LD_ADDR_EXP 8
11279: PUSH
11280: LD_INT 1
11282: NEG
11283: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11284: LD_EXP 21
11288: PPUSH
11289: LD_STRING D3Fc-JMM-1
11291: PPUSH
11292: CALL_OW 88
// end ; end ;
11296: GO 11299
11298: POP
// DialogueOff ;
11299: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11303: LD_EXP 8
11307: PUSH
11308: LD_INT 1
11310: NEG
11311: PUSH
11312: LD_INT 0
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: IN
11319: IFFALSE 11323
// exit ;
11321: GO 12951
// if us_scout in [ 1 , 2 ] then
11323: LD_EXP 8
11327: PUSH
11328: LD_INT 1
11330: PUSH
11331: LD_INT 2
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 12017
// begin if IsInUnit ( Frank ) then
11340: LD_EXP 33
11344: PPUSH
11345: CALL_OW 310
11349: IFFALSE 11360
// ComExit ( Frank ) ;
11351: LD_EXP 33
11355: PPUSH
11356: CALL 86891 0 1
// SetSide ( Frank , 4 ) ;
11360: LD_EXP 33
11364: PPUSH
11365: LD_INT 4
11367: PPUSH
11368: CALL_OW 235
// wait ( 0 0$1 ) ;
11372: LD_INT 35
11374: PPUSH
11375: CALL_OW 67
// if us_scout = 2 then
11379: LD_EXP 8
11383: PUSH
11384: LD_INT 2
11386: EQUAL
11387: IFFALSE 11755
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11389: LD_EXP 33
11393: PPUSH
11394: LD_INT 75
11396: PPUSH
11397: LD_INT 63
11399: PPUSH
11400: CALL_OW 111
// AddComHold ( Frank ) ;
11404: LD_EXP 33
11408: PPUSH
11409: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11413: LD_EXP 33
11417: PPUSH
11418: LD_INT 770
11420: PPUSH
11421: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11425: LD_EXP 33
11429: PPUSH
11430: LD_INT 100
11432: PPUSH
11433: LD_INT 75
11435: PPUSH
11436: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11440: LD_EXP 33
11444: PPUSH
11445: LD_INT 123
11447: PPUSH
11448: LD_INT 103
11450: PPUSH
11451: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11455: LD_EXP 33
11459: PPUSH
11460: LD_INT 138
11462: PPUSH
11463: LD_INT 108
11465: PPUSH
11466: CALL_OW 171
// AddComHold ( Frank ) ;
11470: LD_EXP 33
11474: PPUSH
11475: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11479: LD_INT 35
11481: PPUSH
11482: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11486: LD_EXP 33
11490: PPUSH
11491: LD_INT 138
11493: PPUSH
11494: LD_INT 108
11496: PPUSH
11497: CALL_OW 307
11501: IFFALSE 11479
// AddComMoveXY ( Frank , 125 , 132 ) ;
11503: LD_EXP 33
11507: PPUSH
11508: LD_INT 125
11510: PPUSH
11511: LD_INT 132
11513: PPUSH
11514: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11518: LD_INT 35
11520: PPUSH
11521: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11525: LD_INT 1
11527: PPUSH
11528: LD_EXP 33
11532: PPUSH
11533: CALL_OW 292
11537: PUSH
11538: LD_EXP 33
11542: PPUSH
11543: LD_INT 7
11545: PPUSH
11546: CALL_OW 296
11550: PUSH
11551: LD_INT 7
11553: LESS
11554: OR
11555: IFFALSE 11518
// DialogueOn ;
11557: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11561: LD_EXP 33
11565: PPUSH
11566: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11570: LD_INT 10
11572: PPUSH
11573: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11577: LD_EXP 21
11581: PPUSH
11582: LD_STRING D4Fa-JMM-1
11584: PPUSH
11585: CALL_OW 88
// for i in points do
11589: LD_ADDR_VAR 0 1
11593: PUSH
11594: LD_VAR 0 2
11598: PUSH
11599: FOR_IN
11600: IFFALSE 11658
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11602: LD_VAR 0 1
11606: PUSH
11607: LD_INT 1
11609: ARRAY
11610: PPUSH
11611: LD_VAR 0 1
11615: PUSH
11616: LD_INT 2
11618: ARRAY
11619: PPUSH
11620: LD_INT 1
11622: PPUSH
11623: LD_INT 20
11625: NEG
11626: PPUSH
11627: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11631: LD_VAR 0 1
11635: PUSH
11636: LD_INT 1
11638: ARRAY
11639: PPUSH
11640: LD_VAR 0 1
11644: PUSH
11645: LD_INT 2
11647: ARRAY
11648: PPUSH
11649: LD_INT 1
11651: PPUSH
11652: CALL_OW 331
// end ;
11656: GO 11599
11658: POP
11659: POP
// dwait ( 0 0$0.5 ) ;
11660: LD_INT 18
11662: PPUSH
11663: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11667: LD_INT 42
11669: PPUSH
11670: LD_INT 27
11672: PPUSH
11673: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11677: LD_EXP 33
11681: PPUSH
11682: LD_STRING D4Fa-Frank-1
11684: PPUSH
11685: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11689: LD_INT 18
11691: PPUSH
11692: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11696: LD_EXP 21
11700: PPUSH
11701: LD_STRING D4Fa-JMM-2
11703: PPUSH
11704: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11708: LD_INT 118
11710: PPUSH
11711: LD_INT 80
11713: PPUSH
11714: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11718: LD_EXP 33
11722: PPUSH
11723: LD_STRING D4Fa-Frank-2
11725: PPUSH
11726: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11730: LD_INT 10
11732: PPUSH
11733: CALL_OW 68
// DialogueOff ;
11737: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11741: LD_EXP 33
11745: PPUSH
11746: LD_INT 1
11748: PPUSH
11749: CALL_OW 235
// end else
11753: GO 12017
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11755: LD_INT 2
11757: PPUSH
11758: LD_INT 4
11760: PPUSH
11761: LD_INT 2
11763: PPUSH
11764: LD_INT 1
11766: PPUSH
11767: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11771: LD_EXP 33
11775: PPUSH
11776: LD_INT 75
11778: PPUSH
11779: LD_INT 63
11781: PPUSH
11782: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11786: LD_EXP 33
11790: PPUSH
11791: LD_INT 175
11793: PPUSH
11794: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11798: LD_EXP 33
11802: PPUSH
11803: LD_INT 102
11805: PPUSH
11806: LD_INT 76
11808: PPUSH
11809: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11813: LD_EXP 33
11817: PPUSH
11818: LD_INT 108
11820: PPUSH
11821: LD_INT 70
11823: PPUSH
11824: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11828: LD_INT 35
11830: PPUSH
11831: CALL_OW 67
// until See ( 2 , Frank ) ;
11835: LD_INT 2
11837: PPUSH
11838: LD_EXP 33
11842: PPUSH
11843: CALL_OW 292
11847: IFFALSE 11828
// ComMoveXY ( Frank , 112 , 118 ) ;
11849: LD_EXP 33
11853: PPUSH
11854: LD_INT 112
11856: PPUSH
11857: LD_INT 118
11859: PPUSH
11860: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11864: LD_EXP 33
11868: PPUSH
11869: CALL_OW 256
11873: PUSH
11874: LD_INT 750
11876: GREATEREQUAL
11877: IFFALSE 11891
// SetLives ( Frank , 700 ) ;
11879: LD_EXP 33
11883: PPUSH
11884: LD_INT 700
11886: PPUSH
11887: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11891: LD_INT 35
11893: PPUSH
11894: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11898: LD_INT 1
11900: PPUSH
11901: LD_EXP 33
11905: PPUSH
11906: CALL_OW 292
11910: PUSH
11911: LD_EXP 33
11915: PPUSH
11916: LD_INT 7
11918: PPUSH
11919: CALL_OW 296
11923: PUSH
11924: LD_INT 17
11926: LESS
11927: OR
11928: IFFALSE 11891
// DialogueOn ;
11930: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11934: LD_EXP 33
11938: PPUSH
11939: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11943: LD_EXP 33
11947: PPUSH
11948: LD_STRING D4Fb-Frank-1
11950: PPUSH
11951: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11955: LD_EXP 21
11959: PPUSH
11960: LD_STRING D4Fb-JMM-1
11962: PPUSH
11963: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11967: LD_INT 2
11969: PPUSH
11970: LD_STRING D4Fb-FSci1-1
11972: PPUSH
11973: CALL 16928 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11977: LD_EXP 33
11981: PPUSH
11982: LD_STRING D4Fb-Frank-2
11984: PPUSH
11985: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11989: LD_EXP 21
11993: PPUSH
11994: LD_STRING D4Fb-JMM-2
11996: PPUSH
11997: CALL_OW 88
// DialogueOff ;
12001: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12005: LD_EXP 33
12009: PPUSH
12010: LD_INT 1
12012: PPUSH
12013: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 302
12026: PUSH
12027: LD_EXP 33
12031: PPUSH
12032: CALL_OW 302
12036: NOT
12037: AND
12038: IFFALSE 12951
// begin DialogueOn ;
12040: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12044: LD_EXP 21
12048: PUSH
12049: LD_EXP 34
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PPUSH
12058: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12062: LD_EXP 34
12066: PPUSH
12067: LD_STRING D3Y-Yam-1
12069: PPUSH
12070: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12074: LD_EXP 21
12078: PPUSH
12079: LD_STRING D3Y-JMM-1
12081: PPUSH
12082: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12086: LD_EXP 34
12090: PPUSH
12091: LD_STRING D3Y-Yam-2
12093: PPUSH
12094: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12098: LD_STRING QYamoko
12100: PPUSH
12101: CALL_OW 97
12105: PUSH
12106: LD_INT 1
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12114
12112: GO 12149
12114: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12115: LD_EXP 21
12119: PPUSH
12120: LD_STRING D3Ya-JMM-1
12122: PPUSH
12123: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12127: LD_EXP 34
12131: PPUSH
12132: LD_STRING D3Ya-Yam-1
12134: PPUSH
12135: CALL_OW 88
// us_scout := 1 ;
12139: LD_ADDR_EXP 8
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// end ; 2 :
12147: GO 12182
12149: LD_INT 2
12151: DOUBLE
12152: EQUAL
12153: IFTRUE 12157
12155: GO 12181
12157: POP
// begin us_scout := - 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: NEG
12166: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12167: LD_EXP 21
12171: PPUSH
12172: LD_STRING D3Yb-JMM-1
12174: PPUSH
12175: CALL_OW 88
// end ; end ;
12179: GO 12182
12181: POP
// DialogueOff ;
12182: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12186: LD_EXP 8
12190: PUSH
12191: LD_INT 1
12193: NEG
12194: PUSH
12195: LD_INT 0
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: IN
12202: IFFALSE 12206
// exit ;
12204: GO 12951
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12206: LD_ADDR_EXP 8
12210: PUSH
12211: LD_INT 2
12213: PUSH
12214: LD_INT 2
12216: PUSH
12217: LD_INT 1
12219: PUSH
12220: LD_INT 1
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: PUSH
12229: LD_OWVAR 67
12233: ARRAY
12234: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12235: LD_EXP 8
12239: PUSH
12240: LD_INT 1
12242: PUSH
12243: LD_INT 2
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: IN
12250: IFFALSE 12951
// begin if IsInUnit ( Kikuchi ) then
12252: LD_EXP 34
12256: PPUSH
12257: CALL_OW 310
12261: IFFALSE 12272
// ComExitBuilding ( Kikuchi ) ;
12263: LD_EXP 34
12267: PPUSH
12268: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12272: LD_EXP 34
12276: PPUSH
12277: CALL_OW 311
12281: IFFALSE 12292
// ComExitVehicle ( Kikuchi ) ;
12283: LD_EXP 34
12287: PPUSH
12288: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12292: LD_EXP 34
12296: PPUSH
12297: LD_INT 4
12299: PPUSH
12300: CALL_OW 235
// wait ( 0 0$1 ) ;
12304: LD_INT 35
12306: PPUSH
12307: CALL_OW 67
// if us_scout = 2 then
12311: LD_EXP 8
12315: PUSH
12316: LD_INT 2
12318: EQUAL
12319: IFFALSE 12699
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12321: LD_EXP 34
12325: PPUSH
12326: LD_INT 75
12328: PPUSH
12329: LD_INT 63
12331: PPUSH
12332: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12336: LD_EXP 34
12340: PPUSH
12341: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12345: LD_EXP 34
12349: PPUSH
12350: LD_INT 770
12352: PPUSH
12353: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12357: LD_EXP 34
12361: PPUSH
12362: LD_INT 100
12364: PPUSH
12365: LD_INT 75
12367: PPUSH
12368: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12372: LD_EXP 34
12376: PPUSH
12377: LD_INT 123
12379: PPUSH
12380: LD_INT 103
12382: PPUSH
12383: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12387: LD_EXP 34
12391: PPUSH
12392: LD_INT 138
12394: PPUSH
12395: LD_INT 108
12397: PPUSH
12398: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12402: LD_EXP 34
12406: PPUSH
12407: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12411: LD_INT 35
12413: PPUSH
12414: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12418: LD_EXP 34
12422: PPUSH
12423: LD_INT 138
12425: PPUSH
12426: LD_INT 108
12428: PPUSH
12429: CALL_OW 307
12433: IFFALSE 12411
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12435: LD_EXP 34
12439: PPUSH
12440: LD_INT 125
12442: PPUSH
12443: LD_INT 132
12445: PPUSH
12446: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12450: LD_INT 35
12452: PPUSH
12453: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12457: LD_INT 1
12459: PPUSH
12460: LD_EXP 34
12464: PPUSH
12465: CALL_OW 292
12469: PUSH
12470: LD_EXP 34
12474: PPUSH
12475: LD_INT 7
12477: PPUSH
12478: CALL_OW 296
12482: PUSH
12483: LD_INT 7
12485: LESS
12486: OR
12487: IFFALSE 12450
// DialogueOn ;
12489: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12493: LD_EXP 34
12497: PPUSH
12498: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12502: LD_INT 10
12504: PPUSH
12505: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12509: LD_EXP 34
12513: PPUSH
12514: LD_STRING D4Ya-Yam-1
12516: PPUSH
12517: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12521: LD_EXP 21
12525: PPUSH
12526: LD_STRING D4Ya-JMM-1
12528: PPUSH
12529: CALL_OW 88
// for i in points do
12533: LD_ADDR_VAR 0 1
12537: PUSH
12538: LD_VAR 0 2
12542: PUSH
12543: FOR_IN
12544: IFFALSE 12602
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12546: LD_VAR 0 1
12550: PUSH
12551: LD_INT 1
12553: ARRAY
12554: PPUSH
12555: LD_VAR 0 1
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 1
12566: PPUSH
12567: LD_INT 20
12569: NEG
12570: PPUSH
12571: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12575: LD_VAR 0 1
12579: PUSH
12580: LD_INT 1
12582: ARRAY
12583: PPUSH
12584: LD_VAR 0 1
12588: PUSH
12589: LD_INT 2
12591: ARRAY
12592: PPUSH
12593: LD_INT 1
12595: PPUSH
12596: CALL_OW 331
// end ;
12600: GO 12543
12602: POP
12603: POP
// dwait ( 0 0$0.5 ) ;
12604: LD_INT 18
12606: PPUSH
12607: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12611: LD_INT 42
12613: PPUSH
12614: LD_INT 27
12616: PPUSH
12617: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12621: LD_EXP 34
12625: PPUSH
12626: LD_STRING D4Ya-Yam-2
12628: PPUSH
12629: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12633: LD_INT 18
12635: PPUSH
12636: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12640: LD_INT 118
12642: PPUSH
12643: LD_INT 80
12645: PPUSH
12646: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12650: LD_EXP 21
12654: PPUSH
12655: LD_STRING D4Ya-JMM-2
12657: PPUSH
12658: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12662: LD_EXP 34
12666: PPUSH
12667: LD_STRING D4Ya-Yam-3
12669: PPUSH
12670: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12674: LD_INT 10
12676: PPUSH
12677: CALL_OW 68
// DialogueOff ;
12681: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12685: LD_EXP 34
12689: PPUSH
12690: LD_INT 1
12692: PPUSH
12693: CALL_OW 235
// end else
12697: GO 12951
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12699: LD_INT 2
12701: PPUSH
12702: LD_INT 4
12704: PPUSH
12705: LD_INT 2
12707: PPUSH
12708: LD_INT 1
12710: PPUSH
12711: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12715: LD_EXP 34
12719: PPUSH
12720: LD_INT 75
12722: PPUSH
12723: LD_INT 63
12725: PPUSH
12726: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12730: LD_EXP 34
12734: PPUSH
12735: LD_INT 175
12737: PPUSH
12738: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12742: LD_EXP 34
12746: PPUSH
12747: LD_INT 102
12749: PPUSH
12750: LD_INT 76
12752: PPUSH
12753: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12757: LD_EXP 34
12761: PPUSH
12762: LD_INT 108
12764: PPUSH
12765: LD_INT 70
12767: PPUSH
12768: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12772: LD_INT 35
12774: PPUSH
12775: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12779: LD_INT 2
12781: PPUSH
12782: LD_EXP 34
12786: PPUSH
12787: CALL_OW 292
12791: IFFALSE 12772
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12793: LD_EXP 34
12797: PPUSH
12798: LD_INT 112
12800: PPUSH
12801: LD_INT 118
12803: PPUSH
12804: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12808: LD_EXP 34
12812: PPUSH
12813: CALL_OW 256
12817: PUSH
12818: LD_INT 750
12820: GREATEREQUAL
12821: IFFALSE 12835
// SetLives ( Kikuchi , 700 ) ;
12823: LD_EXP 34
12827: PPUSH
12828: LD_INT 700
12830: PPUSH
12831: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12835: LD_INT 35
12837: PPUSH
12838: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12842: LD_INT 1
12844: PPUSH
12845: LD_EXP 34
12849: PPUSH
12850: CALL_OW 292
12854: PUSH
12855: LD_EXP 34
12859: PPUSH
12860: LD_INT 7
12862: PPUSH
12863: CALL_OW 296
12867: PUSH
12868: LD_INT 17
12870: LESS
12871: OR
12872: IFFALSE 12835
// DialogueOn ;
12874: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12878: LD_EXP 34
12882: PPUSH
12883: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12887: LD_EXP 34
12891: PPUSH
12892: LD_STRING D4Yb-Yam-1
12894: PPUSH
12895: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12899: LD_EXP 21
12903: PPUSH
12904: LD_STRING D4Yb-JMM-1
12906: PPUSH
12907: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12911: LD_EXP 34
12915: PPUSH
12916: LD_STRING D4Yb-Yam-2
12918: PPUSH
12919: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12923: LD_EXP 21
12927: PPUSH
12928: LD_STRING D4Yb-JMM-2
12930: PPUSH
12931: CALL_OW 88
// DialogueOff ;
12935: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12939: LD_EXP 34
12943: PPUSH
12944: LD_INT 1
12946: PPUSH
12947: CALL_OW 235
// end ; end ; end ; end ;
12951: PPOPN 2
12953: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12954: LD_EXP 6
12958: IFFALSE 13991
12960: GO 12962
12962: DISABLE
12963: LD_INT 0
12965: PPUSH
12966: PPUSH
12967: PPUSH
12968: PPUSH
// begin enable ;
12969: ENABLE
// if not seen [ 1 ] then
12970: LD_EXP 9
12974: PUSH
12975: LD_INT 1
12977: ARRAY
12978: NOT
12979: IFFALSE 13159
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12981: LD_ADDR_VAR 0 2
12985: PUSH
12986: LD_INT 22
12988: PUSH
12989: LD_INT 2
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: LD_INT 2
12998: PUSH
12999: LD_INT 25
13001: PUSH
13002: LD_INT 11
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 33
13011: PUSH
13012: LD_INT 4
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: LIST
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PPUSH
13028: CALL_OW 69
13032: ST_TO_ADDR
// if tmp then
13033: LD_VAR 0 2
13037: IFFALSE 13159
// for i in tmp do
13039: LD_ADDR_VAR 0 1
13043: PUSH
13044: LD_VAR 0 2
13048: PUSH
13049: FOR_IN
13050: IFFALSE 13157
// if See ( 1 , i ) then
13052: LD_INT 1
13054: PPUSH
13055: LD_VAR 0 1
13059: PPUSH
13060: CALL_OW 292
13064: IFFALSE 13155
// begin seen := Replace ( seen , 1 , true ) ;
13066: LD_ADDR_EXP 9
13070: PUSH
13071: LD_EXP 9
13075: PPUSH
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 1
13081: PPUSH
13082: CALL_OW 1
13086: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13087: LD_INT 1
13089: PPUSH
13090: CALL 16750 0 1
13094: IFFALSE 13155
// begin DialogueOn ;
13096: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13100: LD_VAR 0 1
13104: PPUSH
13105: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13109: LD_INT 10
13111: PPUSH
13112: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: LD_INT 1
13123: PPUSH
13124: LD_STRING D5a-Sol2-1
13126: PPUSH
13127: CALL 16928 0 2
13131: ST_TO_ADDR
// if not un then
13132: LD_VAR 0 3
13136: NOT
13137: IFFALSE 13149
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13139: LD_INT 2
13141: PPUSH
13142: LD_STRING D5a-FSol2-1
13144: PPUSH
13145: CALL 16928 0 2
// DialogueOff ;
13149: CALL_OW 7
// break ;
13153: GO 13157
// end ; end ;
13155: GO 13049
13157: POP
13158: POP
// end ; if not seen [ 2 ] then
13159: LD_EXP 9
13163: PUSH
13164: LD_INT 2
13166: ARRAY
13167: NOT
13168: IFFALSE 13393
// begin can_kamikazed := true ;
13170: LD_ADDR_EXP 10
13174: PUSH
13175: LD_INT 1
13177: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13178: LD_ADDR_VAR 0 2
13182: PUSH
13183: LD_INT 22
13185: PUSH
13186: LD_INT 2
13188: PUSH
13189: EMPTY
13190: LIST
13191: LIST
13192: PUSH
13193: LD_INT 25
13195: PUSH
13196: LD_INT 17
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: PPUSH
13207: CALL_OW 69
13211: ST_TO_ADDR
// if tmp then
13212: LD_VAR 0 2
13216: IFFALSE 13393
// for i in tmp do
13218: LD_ADDR_VAR 0 1
13222: PUSH
13223: LD_VAR 0 2
13227: PUSH
13228: FOR_IN
13229: IFFALSE 13391
// if See ( 1 , i ) then
13231: LD_INT 1
13233: PPUSH
13234: LD_VAR 0 1
13238: PPUSH
13239: CALL_OW 292
13243: IFFALSE 13389
// begin seen := Replace ( seen , 2 , true ) ;
13245: LD_ADDR_EXP 9
13249: PUSH
13250: LD_EXP 9
13254: PPUSH
13255: LD_INT 2
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: CALL_OW 1
13265: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13266: LD_INT 1
13268: PPUSH
13269: CALL 16750 0 1
13273: IFFALSE 13389
// begin DialogueOn ;
13275: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13279: LD_VAR 0 1
13283: PPUSH
13284: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13288: LD_INT 10
13290: PPUSH
13291: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13295: LD_ADDR_VAR 0 3
13299: PUSH
13300: LD_INT 1
13302: PPUSH
13303: LD_STRING D5b-Sol1-1
13305: PPUSH
13306: CALL 16928 0 2
13310: ST_TO_ADDR
// if not un then
13311: LD_VAR 0 3
13315: NOT
13316: IFFALSE 13334
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13318: LD_ADDR_VAR 0 3
13322: PUSH
13323: LD_INT 2
13325: PPUSH
13326: LD_STRING D5b-FSol1-1
13328: PPUSH
13329: CALL 16928 0 2
13333: ST_TO_ADDR
// if un then
13334: LD_VAR 0 3
13338: IFFALSE 13383
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13340: LD_ADDR_VAR 0 4
13344: PUSH
13345: LD_INT 1
13347: PPUSH
13348: LD_STRING D5b-Sol2-1
13350: PPUSH
13351: LD_VAR 0 3
13355: PPUSH
13356: CALL 17154 0 3
13360: ST_TO_ADDR
// if not un2 then
13361: LD_VAR 0 4
13365: NOT
13366: IFFALSE 13383
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13368: LD_INT 2
13370: PPUSH
13371: LD_STRING D5b-FSol2-1
13373: PPUSH
13374: LD_VAR 0 3
13378: PPUSH
13379: CALL 17154 0 3
// end ; DialogueOff ;
13383: CALL_OW 7
// break ;
13387: GO 13391
// end ; end ;
13389: GO 13228
13391: POP
13392: POP
// end ; if not seen [ 3 ] then
13393: LD_EXP 9
13397: PUSH
13398: LD_INT 3
13400: ARRAY
13401: NOT
13402: IFFALSE 13576
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13404: LD_ADDR_VAR 0 2
13408: PUSH
13409: LD_INT 22
13411: PUSH
13412: LD_INT 2
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 33
13421: PUSH
13422: LD_INT 2
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PPUSH
13433: CALL_OW 69
13437: ST_TO_ADDR
// if tmp then
13438: LD_VAR 0 2
13442: IFFALSE 13576
// for i in tmp do
13444: LD_ADDR_VAR 0 1
13448: PUSH
13449: LD_VAR 0 2
13453: PUSH
13454: FOR_IN
13455: IFFALSE 13574
// if See ( 1 , i ) then
13457: LD_INT 1
13459: PPUSH
13460: LD_VAR 0 1
13464: PPUSH
13465: CALL_OW 292
13469: IFFALSE 13572
// begin seen := Replace ( seen , 3 , true ) ;
13471: LD_ADDR_EXP 9
13475: PUSH
13476: LD_EXP 9
13480: PPUSH
13481: LD_INT 3
13483: PPUSH
13484: LD_INT 1
13486: PPUSH
13487: CALL_OW 1
13491: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13492: LD_INT 1
13494: PPUSH
13495: CALL 16750 0 1
13499: IFFALSE 13572
// begin DialogueOn ;
13501: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13505: LD_VAR 0 1
13509: PPUSH
13510: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13514: LD_INT 10
13516: PPUSH
13517: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13521: LD_ADDR_VAR 0 3
13525: PUSH
13526: LD_INT 1
13528: PPUSH
13529: LD_STRING D8-Sol1-1
13531: PPUSH
13532: CALL 16928 0 2
13536: ST_TO_ADDR
// if not un then
13537: LD_VAR 0 3
13541: NOT
13542: IFFALSE 13554
// SayRand ( sex_female , D8-FSol1-1 ) ;
13544: LD_INT 2
13546: PPUSH
13547: LD_STRING D8-FSol1-1
13549: PPUSH
13550: CALL 16928 0 2
// Say ( JMM , D8-JMM-1 ) ;
13554: LD_EXP 21
13558: PPUSH
13559: LD_STRING D8-JMM-1
13561: PPUSH
13562: CALL_OW 88
// DialogueOff ;
13566: CALL_OW 7
// break ;
13570: GO 13574
// end ; end ;
13572: GO 13454
13574: POP
13575: POP
// end ; if not seen [ 4 ] then
13576: LD_EXP 9
13580: PUSH
13581: LD_INT 4
13583: ARRAY
13584: NOT
13585: IFFALSE 13747
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_INT 22
13594: PUSH
13595: LD_INT 2
13597: PUSH
13598: EMPTY
13599: LIST
13600: LIST
13601: PUSH
13602: LD_INT 33
13604: PUSH
13605: LD_INT 5
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PPUSH
13616: CALL_OW 69
13620: ST_TO_ADDR
// if tmp then
13621: LD_VAR 0 2
13625: IFFALSE 13747
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13745
// if See ( 1 , i ) then
13640: LD_INT 1
13642: PPUSH
13643: LD_VAR 0 1
13647: PPUSH
13648: CALL_OW 292
13652: IFFALSE 13743
// begin seen := Replace ( seen , 4 , true ) ;
13654: LD_ADDR_EXP 9
13658: PUSH
13659: LD_EXP 9
13663: PPUSH
13664: LD_INT 4
13666: PPUSH
13667: LD_INT 1
13669: PPUSH
13670: CALL_OW 1
13674: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13675: LD_INT 1
13677: PPUSH
13678: CALL 16750 0 1
13682: IFFALSE 13743
// begin DialogueOn ;
13684: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13688: LD_VAR 0 1
13692: PPUSH
13693: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13697: LD_INT 10
13699: PPUSH
13700: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13704: LD_ADDR_VAR 0 3
13708: PUSH
13709: LD_INT 1
13711: PPUSH
13712: LD_STRING D5a-Sol1-1
13714: PPUSH
13715: CALL 16928 0 2
13719: ST_TO_ADDR
// if not un then
13720: LD_VAR 0 3
13724: NOT
13725: IFFALSE 13737
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13727: LD_INT 2
13729: PPUSH
13730: LD_STRING D5a-FSol1-1
13732: PPUSH
13733: CALL 16928 0 2
// DialogueOff ;
13737: CALL_OW 7
// break ;
13741: GO 13745
// end ; end ;
13743: GO 13637
13745: POP
13746: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13747: LD_EXP 9
13751: PUSH
13752: LD_INT 5
13754: ARRAY
13755: NOT
13756: PUSH
13757: LD_EXP 9
13761: PUSH
13762: LD_INT 3
13764: ARRAY
13765: AND
13766: IFFALSE 13940
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13768: LD_ADDR_VAR 0 2
13772: PUSH
13773: LD_INT 22
13775: PUSH
13776: LD_INT 2
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 34
13785: PUSH
13786: LD_INT 31
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: PPUSH
13797: CALL_OW 69
13801: ST_TO_ADDR
// if tmp then
13802: LD_VAR 0 2
13806: IFFALSE 13940
// for i in tmp do
13808: LD_ADDR_VAR 0 1
13812: PUSH
13813: LD_VAR 0 2
13817: PUSH
13818: FOR_IN
13819: IFFALSE 13938
// if See ( 1 , i ) then
13821: LD_INT 1
13823: PPUSH
13824: LD_VAR 0 1
13828: PPUSH
13829: CALL_OW 292
13833: IFFALSE 13936
// begin seen := Replace ( seen , 5 , true ) ;
13835: LD_ADDR_EXP 9
13839: PUSH
13840: LD_EXP 9
13844: PPUSH
13845: LD_INT 5
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 1
13855: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13856: LD_INT 1
13858: PPUSH
13859: CALL 16750 0 1
13863: IFFALSE 13936
// begin DialogueOn ;
13865: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13869: LD_VAR 0 1
13873: PPUSH
13874: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13878: LD_INT 10
13880: PPUSH
13881: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13885: LD_ADDR_VAR 0 3
13889: PUSH
13890: LD_INT 1
13892: PPUSH
13893: LD_STRING D8a-Sol2-1
13895: PPUSH
13896: CALL 16928 0 2
13900: ST_TO_ADDR
// if not un then
13901: LD_VAR 0 3
13905: NOT
13906: IFFALSE 13918
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13908: LD_INT 2
13910: PPUSH
13911: LD_STRING D8a-FSol2-1
13913: PPUSH
13914: CALL 16928 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13918: LD_EXP 21
13922: PPUSH
13923: LD_STRING D8a-JMM-1
13925: PPUSH
13926: CALL_OW 88
// DialogueOff ;
13930: CALL_OW 7
// break ;
13934: GO 13938
// end ; end ;
13936: GO 13818
13938: POP
13939: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13940: LD_EXP 9
13944: PUSH
13945: LD_INT 1
13947: ARRAY
13948: PUSH
13949: LD_EXP 9
13953: PUSH
13954: LD_INT 2
13956: ARRAY
13957: AND
13958: PUSH
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 3
13966: ARRAY
13967: AND
13968: PUSH
13969: LD_EXP 9
13973: PUSH
13974: LD_INT 4
13976: ARRAY
13977: AND
13978: PUSH
13979: LD_EXP 9
13983: PUSH
13984: LD_INT 5
13986: ARRAY
13987: AND
13988: IFFALSE 13991
// disable ;
13990: DISABLE
// end ;
13991: PPOPN 4
13993: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13994: LD_EXP 10
13998: PUSH
13999: LD_EXP 11
14003: AND
14004: IFFALSE 14202
14006: GO 14008
14008: DISABLE
14009: LD_INT 0
14011: PPUSH
// begin DialogueOn ;
14012: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14016: LD_EXP 11
14020: PPUSH
14021: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14025: LD_ADDR_VAR 0 1
14029: PUSH
14030: LD_INT 1
14032: PPUSH
14033: LD_STRING D5c-Sol1-1
14035: PPUSH
14036: CALL 16928 0 2
14040: ST_TO_ADDR
// if not un then
14041: LD_VAR 0 1
14045: NOT
14046: IFFALSE 14064
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14048: LD_ADDR_VAR 0 1
14052: PUSH
14053: LD_INT 2
14055: PPUSH
14056: LD_STRING D5c-FSol1-1
14058: PPUSH
14059: CALL 16928 0 2
14063: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14064: LD_EXP 21
14068: PPUSH
14069: LD_STRING D5c-JMM-1
14071: PPUSH
14072: CALL_OW 88
// if IsOk ( Lisa ) then
14076: LD_EXP 22
14080: PPUSH
14081: CALL_OW 302
14085: IFFALSE 14101
// Say ( Lisa , D5d-Lisa-1 ) else
14087: LD_EXP 22
14091: PPUSH
14092: LD_STRING D5d-Lisa-1
14094: PPUSH
14095: CALL_OW 88
14099: GO 14186
// if IsOk ( Cyrus ) then
14101: LD_EXP 25
14105: PPUSH
14106: CALL_OW 302
14110: IFFALSE 14126
// Say ( Cyrus , D5d-Cyrus-1 ) else
14112: LD_EXP 25
14116: PPUSH
14117: LD_STRING D5d-Cyrus-1
14119: PPUSH
14120: CALL_OW 88
14124: GO 14186
// if IsOk ( Gary ) then
14126: LD_EXP 32
14130: PPUSH
14131: CALL_OW 302
14135: IFFALSE 14151
// Say ( Gary , D5d-Gary-1 ) else
14137: LD_EXP 32
14141: PPUSH
14142: LD_STRING D5d-Gary-1
14144: PPUSH
14145: CALL_OW 88
14149: GO 14186
// if GetSex ( un ) = sex_male then
14151: LD_VAR 0 1
14155: PPUSH
14156: CALL_OW 258
14160: PUSH
14161: LD_INT 1
14163: EQUAL
14164: IFFALSE 14180
// Say ( un , D5d-Sol1-1 ) else
14166: LD_VAR 0 1
14170: PPUSH
14171: LD_STRING D5d-Sol1-1
14173: PPUSH
14174: CALL_OW 88
14178: GO 14186
// begin DialogueOff ;
14180: CALL_OW 7
// exit ;
14184: GO 14202
// end ; Say ( JMM , D5d-JMM-1 ) ;
14186: LD_EXP 21
14190: PPUSH
14191: LD_STRING D5d-JMM-1
14193: PPUSH
14194: CALL_OW 88
// DialogueOff ;
14198: CALL_OW 7
// end ;
14202: PPOPN 1
14204: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14205: LD_INT 1
14207: PPUSH
14208: LD_INT 17
14210: PPUSH
14211: CALL_OW 294
14215: PUSH
14216: LD_INT 2
14218: GREATEREQUAL
14219: IFFALSE 14351
14221: GO 14223
14223: DISABLE
14224: LD_INT 0
14226: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14227: LD_INT 10
14229: PPUSH
14230: LD_INT 5
14232: PPUSH
14233: LD_INT 1
14235: PPUSH
14236: LD_INT 10
14238: NEG
14239: PPUSH
14240: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14244: LD_INT 10
14246: PPUSH
14247: LD_INT 5
14249: PPUSH
14250: LD_INT 1
14252: PPUSH
14253: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14257: LD_INT 10
14259: PPUSH
14260: LD_INT 5
14262: PPUSH
14263: CALL_OW 86
// DialogueOn ;
14267: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14271: LD_ADDR_VAR 0 1
14275: PUSH
14276: LD_INT 1
14278: PPUSH
14279: LD_STRING D6-Sci1-1
14281: PPUSH
14282: CALL 16928 0 2
14286: ST_TO_ADDR
// if un then
14287: LD_VAR 0 1
14291: IFFALSE 14329
// begin Say ( JMM , D6-JMM-1 ) ;
14293: LD_EXP 21
14297: PPUSH
14298: LD_STRING D6-JMM-1
14300: PPUSH
14301: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14305: LD_VAR 0 1
14309: PPUSH
14310: LD_STRING D6-Sci1-2
14312: PPUSH
14313: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14317: LD_EXP 21
14321: PPUSH
14322: LD_STRING D6-JMM-2
14324: PPUSH
14325: CALL_OW 88
// end ; DialogueOff ;
14329: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14333: LD_STRING M3
14335: PPUSH
14336: CALL_OW 337
// wait ( 0 0$30 ) ;
14340: LD_INT 1050
14342: PPUSH
14343: CALL_OW 67
// AmericanReinforcements ;
14347: CALL 2326 0 0
// end ;
14351: PPOPN 1
14353: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14354: LD_OWVAR 1
14358: PUSH
14359: LD_INT 42000
14361: GREATEREQUAL
14362: PUSH
14363: LD_INT 2
14365: PPUSH
14366: LD_INT 169
14368: PPUSH
14369: LD_INT 90
14371: PPUSH
14372: LD_INT 10
14374: PPUSH
14375: CALL 55058 0 4
14379: PUSH
14380: LD_INT 4
14382: ARRAY
14383: PUSH
14384: LD_INT 0
14386: EQUAL
14387: PUSH
14388: LD_INT 45
14390: PPUSH
14391: CALL_OW 301
14395: OR
14396: PUSH
14397: LD_INT 45
14399: PPUSH
14400: CALL_OW 255
14404: PUSH
14405: LD_INT 1
14407: EQUAL
14408: OR
14409: AND
14410: PUSH
14411: LD_INT 94
14413: PPUSH
14414: CALL_OW 301
14418: NOT
14419: AND
14420: IFFALSE 15625
14422: GO 14424
14424: DISABLE
14425: LD_INT 0
14427: PPUSH
14428: PPUSH
14429: PPUSH
14430: PPUSH
14431: PPUSH
// begin uc_side := 5 ;
14432: LD_ADDR_OWVAR 20
14436: PUSH
14437: LD_INT 5
14439: ST_TO_ADDR
// uc_nation := 2 ;
14440: LD_ADDR_OWVAR 21
14444: PUSH
14445: LD_INT 2
14447: ST_TO_ADDR
// InitHc ;
14448: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14452: LD_INT 1
14454: PPUSH
14455: LD_INT 3
14457: PPUSH
14458: LD_INT 8
14460: PPUSH
14461: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14465: LD_ADDR_OWVAR 29
14469: PUSH
14470: LD_INT 12
14472: PUSH
14473: LD_INT 12
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: ST_TO_ADDR
// hc_name := Hans Fliege ;
14480: LD_ADDR_OWVAR 26
14484: PUSH
14485: LD_STRING Hans Fliege
14487: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14488: LD_ADDR_OWVAR 33
14492: PUSH
14493: LD_STRING SecondCharsGal
14495: ST_TO_ADDR
// hc_face_number := 7 ;
14496: LD_ADDR_OWVAR 34
14500: PUSH
14501: LD_INT 7
14503: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14504: LD_ADDR_EXP 46
14508: PUSH
14509: CALL_OW 44
14513: ST_TO_ADDR
// InitHc ;
14514: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14518: LD_INT 1
14520: PPUSH
14521: LD_INT 16
14523: PPUSH
14524: LD_INT 2
14526: PPUSH
14527: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14531: LD_ADDR_OWVAR 29
14535: PUSH
14536: LD_INT 12
14538: PUSH
14539: LD_INT 12
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: ST_TO_ADDR
// hc_name :=  ;
14546: LD_ADDR_OWVAR 26
14550: PUSH
14551: LD_STRING 
14553: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14554: LD_ADDR_EXP 47
14558: PUSH
14559: CALL_OW 44
14563: ST_TO_ADDR
// InitHc ;
14564: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14568: LD_INT 35
14570: PPUSH
14571: CALL_OW 67
// until not InBattle ( 1 ) ;
14575: LD_INT 1
14577: PPUSH
14578: CALL_OW 463
14582: NOT
14583: IFFALSE 14568
// wait ( 0 0$5 ) ;
14585: LD_INT 175
14587: PPUSH
14588: CALL_OW 67
// DialogueOn ;
14592: CALL_OW 6
// InGameOn ;
14596: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_INT 22
14607: PUSH
14608: LD_INT 1
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: PUSH
14615: LD_INT 2
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 1
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: LD_INT 25
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: PUSH
14638: LD_INT 25
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 25
14650: PUSH
14651: LD_INT 4
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 25
14660: PUSH
14661: LD_INT 5
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 25
14670: PUSH
14671: LD_INT 8
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PPUSH
14691: CALL_OW 69
14695: PUSH
14696: LD_EXP 21
14700: PUSH
14701: LD_EXP 22
14705: PUSH
14706: LD_EXP 23
14710: PUSH
14711: LD_EXP 24
14715: PUSH
14716: LD_EXP 25
14720: PUSH
14721: LD_EXP 26
14725: PUSH
14726: LD_EXP 27
14730: PUSH
14731: LD_EXP 28
14735: PUSH
14736: LD_EXP 29
14740: PUSH
14741: LD_EXP 31
14745: PUSH
14746: LD_EXP 32
14750: PUSH
14751: LD_EXP 33
14755: PUSH
14756: LD_EXP 34
14760: PUSH
14761: EMPTY
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: DIFF
14776: PPUSH
14777: LD_INT 26
14779: PUSH
14780: LD_INT 1
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PPUSH
14787: CALL_OW 72
14791: PUSH
14792: LD_INT 1
14794: ARRAY
14795: ST_TO_ADDR
// if Brown then
14796: LD_EXP 27
14800: IFFALSE 14812
// un := Brown ;
14802: LD_ADDR_VAR 0 1
14806: PUSH
14807: LD_EXP 27
14811: ST_TO_ADDR
// if un then
14812: LD_VAR 0 1
14816: IFFALSE 14842
// begin Say ( un , D7-Sol1-1 ) ;
14818: LD_VAR 0 1
14822: PPUSH
14823: LD_STRING D7-Sol1-1
14825: PPUSH
14826: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14830: LD_EXP 21
14834: PPUSH
14835: LD_STRING D7-JMM-1
14837: PPUSH
14838: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14842: LD_EXP 46
14846: PPUSH
14847: LD_STRING D7-Ar1-1
14849: PPUSH
14850: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14854: LD_EXP 21
14858: PPUSH
14859: LD_STRING D7-JMM-2
14861: PPUSH
14862: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14866: LD_EXP 46
14870: PPUSH
14871: LD_STRING D7-Ar1-2
14873: PPUSH
14874: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14878: LD_EXP 21
14882: PPUSH
14883: LD_STRING D7-JMM-3
14885: PPUSH
14886: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14890: LD_EXP 46
14894: PPUSH
14895: LD_STRING D7-Ar1-3
14897: PPUSH
14898: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14902: LD_EXP 21
14906: PPUSH
14907: LD_STRING D7-JMM-4
14909: PPUSH
14910: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14914: LD_EXP 46
14918: PPUSH
14919: LD_STRING D7-Ar1-4
14921: PPUSH
14922: CALL_OW 94
// InGameOff ;
14926: CALL_OW 9
// DialogueOff ;
14930: CALL_OW 7
// case Query ( QCameras ) of 1 :
14934: LD_STRING QCameras
14936: PPUSH
14937: CALL_OW 97
14941: PUSH
14942: LD_INT 1
14944: DOUBLE
14945: EQUAL
14946: IFTRUE 14950
14948: GO 14953
14950: POP
// ; 2 :
14951: GO 14967
14953: LD_INT 2
14955: DOUBLE
14956: EQUAL
14957: IFTRUE 14961
14959: GO 14966
14961: POP
// exit ; end ;
14962: GO 15625
14964: GO 14967
14966: POP
// ChangeMissionObjectives ( MCar ) ;
14967: LD_STRING MCar
14969: PPUSH
14970: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14974: LD_INT 124
14976: PPUSH
14977: LD_INT 90
14979: PPUSH
14980: LD_INT 1
14982: PPUSH
14983: LD_INT 6
14985: NEG
14986: PPUSH
14987: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14991: LD_INT 124
14993: PPUSH
14994: LD_INT 90
14996: PPUSH
14997: LD_INT 1
14999: PPUSH
15000: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15004: LD_INT 12
15006: PPUSH
15007: LD_INT 1
15009: PPUSH
15010: CALL_OW 424
// wait ( 3 ) ;
15014: LD_INT 3
15016: PPUSH
15017: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15021: LD_INT 124
15023: PPUSH
15024: LD_INT 90
15026: PPUSH
15027: CALL_OW 86
// cargo := false ;
15031: LD_ADDR_VAR 0 3
15035: PUSH
15036: LD_INT 0
15038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15039: LD_INT 35
15041: PPUSH
15042: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15046: LD_ADDR_VAR 0 3
15050: PUSH
15051: LD_INT 12
15053: PPUSH
15054: LD_INT 32
15056: PUSH
15057: LD_INT 3
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: LD_INT 34
15066: PUSH
15067: LD_INT 32
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PUSH
15074: LD_INT 58
15076: PUSH
15077: EMPTY
15078: LIST
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: LIST
15084: PPUSH
15085: CALL_OW 70
15089: ST_TO_ADDR
// until cargo ;
15090: LD_VAR 0 3
15094: IFFALSE 15039
// cargo := cargo [ 1 ] ;
15096: LD_ADDR_VAR 0 3
15100: PUSH
15101: LD_VAR 0 3
15105: PUSH
15106: LD_INT 1
15108: ARRAY
15109: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15110: LD_VAR 0 3
15114: PPUSH
15115: LD_INT 5
15117: PPUSH
15118: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15122: LD_INT 12
15124: PPUSH
15125: LD_INT 0
15127: PPUSH
15128: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15132: LD_EXP 46
15136: PPUSH
15137: LD_INT 11
15139: PPUSH
15140: LD_INT 0
15142: PPUSH
15143: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15147: LD_EXP 47
15151: PPUSH
15152: LD_INT 11
15154: PPUSH
15155: LD_INT 0
15157: PPUSH
15158: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15162: LD_EXP 46
15166: PUSH
15167: LD_EXP 47
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PPUSH
15176: LD_INT 12
15178: PPUSH
15179: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15183: LD_EXP 46
15187: PPUSH
15188: LD_VAR 0 3
15192: PPUSH
15193: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15197: LD_EXP 46
15201: PUSH
15202: LD_EXP 47
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PPUSH
15211: LD_INT 209
15213: PPUSH
15214: LD_INT 178
15216: PPUSH
15217: CALL_OW 171
// escaped := 0 ;
15221: LD_ADDR_VAR 0 5
15225: PUSH
15226: LD_INT 0
15228: ST_TO_ADDR
// while ( true ) do
15229: LD_INT 1
15231: IFFALSE 15447
// begin wait ( 0 0$1 ) ;
15233: LD_INT 35
15235: PPUSH
15236: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15240: LD_EXP 46
15244: PPUSH
15245: CALL_OW 314
15249: NOT
15250: PUSH
15251: LD_EXP 47
15255: PPUSH
15256: CALL_OW 314
15260: NOT
15261: OR
15262: IFFALSE 15288
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15264: LD_EXP 46
15268: PUSH
15269: LD_EXP 47
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PPUSH
15278: LD_INT 209
15280: PPUSH
15281: LD_INT 178
15283: PPUSH
15284: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15288: LD_EXP 46
15292: PPUSH
15293: LD_INT 10
15295: PPUSH
15296: CALL_OW 308
15300: IFFALSE 15325
// begin RemoveUnit ( ar_mechanic ) ;
15302: LD_EXP 46
15306: PPUSH
15307: CALL_OW 64
// escaped := escaped + 1 ;
15311: LD_ADDR_VAR 0 5
15315: PUSH
15316: LD_VAR 0 5
15320: PUSH
15321: LD_INT 1
15323: PLUS
15324: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15325: LD_EXP 47
15329: PPUSH
15330: LD_INT 10
15332: PPUSH
15333: CALL_OW 308
15337: IFFALSE 15362
// begin RemoveUnit ( ar_mechanic_friend ) ;
15339: LD_EXP 47
15343: PPUSH
15344: CALL_OW 64
// escaped := escaped + 1 ;
15348: LD_ADDR_VAR 0 5
15352: PUSH
15353: LD_VAR 0 5
15357: PUSH
15358: LD_INT 1
15360: PLUS
15361: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15362: LD_VAR 0 3
15366: PPUSH
15367: LD_INT 10
15369: PPUSH
15370: CALL_OW 308
15374: IFFALSE 15385
// RemoveUnit ( cargo ) ;
15376: LD_VAR 0 3
15380: PPUSH
15381: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15385: LD_EXP 46
15389: PPUSH
15390: CALL_OW 305
15394: NOT
15395: PUSH
15396: LD_VAR 0 5
15400: PUSH
15401: LD_INT 2
15403: GREATEREQUAL
15404: AND
15405: IFFALSE 15409
// break ;
15407: GO 15447
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15409: LD_EXP 46
15413: PPUSH
15414: CALL_OW 305
15418: NOT
15419: PUSH
15420: LD_EXP 47
15424: PPUSH
15425: CALL_OW 305
15429: NOT
15430: AND
15431: PUSH
15432: LD_VAR 0 5
15436: PUSH
15437: LD_INT 2
15439: LESS
15440: AND
15441: IFFALSE 15445
// exit ;
15443: GO 15625
// end ;
15445: GO 15229
// wait ( 0 0$2 ) ;
15447: LD_INT 70
15449: PPUSH
15450: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15454: LD_EXP 46
15458: PPUSH
15459: LD_STRING D7a-Ar1-1
15461: PPUSH
15462: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15466: LD_ADDR_VAR 0 4
15470: PUSH
15471: LD_INT 129
15473: PUSH
15474: LD_INT 10
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 103
15483: PUSH
15484: LD_INT 6
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 148
15493: PUSH
15494: LD_INT 47
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: LD_INT 155
15503: PUSH
15504: LD_INT 16
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: LIST
15515: LIST
15516: ST_TO_ADDR
// if Difficulty = 1 then
15517: LD_OWVAR 67
15521: PUSH
15522: LD_INT 1
15524: EQUAL
15525: IFFALSE 15562
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15527: LD_ADDR_VAR 0 4
15531: PUSH
15532: LD_VAR 0 4
15536: PUSH
15537: LD_INT 78
15539: PUSH
15540: LD_INT 7
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PUSH
15547: LD_INT 104
15549: PUSH
15550: LD_INT 43
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: ADD
15561: ST_TO_ADDR
// for i in tmp do
15562: LD_ADDR_VAR 0 2
15566: PUSH
15567: LD_VAR 0 4
15571: PUSH
15572: FOR_IN
15573: IFFALSE 15606
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15575: LD_VAR 0 2
15579: PUSH
15580: LD_INT 1
15582: ARRAY
15583: PPUSH
15584: LD_VAR 0 2
15588: PUSH
15589: LD_INT 2
15591: ARRAY
15592: PPUSH
15593: LD_INT 1
15595: PPUSH
15596: LD_INT 9
15598: NEG
15599: PPUSH
15600: CALL_OW 330
15604: GO 15572
15606: POP
15607: POP
// SetAchievement ( ACH_FRIEND ) ;
15608: LD_STRING ACH_FRIEND
15610: PPUSH
15611: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15615: LD_INT 129
15617: PPUSH
15618: LD_INT 10
15620: PPUSH
15621: CALL_OW 84
// end ;
15625: PPOPN 5
15627: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15628: LD_EXP 15
15632: PUSH
15633: LD_INT 21000
15635: MINUS
15636: PUSH
15637: LD_OWVAR 1
15641: LESSEQUAL
15642: IFFALSE 15682
15644: GO 15646
15646: DISABLE
// begin powell_warn := true ;
15647: LD_ADDR_EXP 16
15651: PUSH
15652: LD_INT 1
15654: ST_TO_ADDR
// DialogueOn ;
15655: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15659: LD_EXP 30
15663: PPUSH
15664: LD_STRING D9-Pow-1
15666: PPUSH
15667: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15671: LD_INT 10
15673: PPUSH
15674: CALL_OW 68
// DialogueOff ;
15678: CALL_OW 7
// end ;
15682: END
// every 0 0$1 trigger game_time <= tick do
15683: LD_EXP 15
15687: PUSH
15688: LD_OWVAR 1
15692: LESSEQUAL
15693: IFFALSE 15732
15695: GO 15697
15697: DISABLE
// begin DialogueOn ;
15698: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15702: LD_EXP 30
15706: PPUSH
15707: LD_STRING D9a-Pow-1
15709: PPUSH
15710: CALL_OW 94
// dwait ( 0 0$2 ) ;
15714: LD_INT 70
15716: PPUSH
15717: CALL_OW 68
// DialogueOff ;
15721: CALL_OW 7
// YouLost ( Command ) ;
15725: LD_STRING Command
15727: PPUSH
15728: CALL_OW 104
// end ;
15732: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15733: LD_INT 22
15735: PUSH
15736: LD_INT 2
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: LD_INT 30
15745: PUSH
15746: LD_INT 1
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PPUSH
15757: CALL_OW 69
15761: PUSH
15762: LD_INT 0
15764: EQUAL
15765: PUSH
15766: LD_EXP 21
15770: PPUSH
15771: CALL_OW 302
15775: AND
15776: IFFALSE 15824
15778: GO 15780
15780: DISABLE
// begin case Query ( QEndMission ) of 1 :
15781: LD_STRING QEndMission
15783: PPUSH
15784: CALL_OW 97
15788: PUSH
15789: LD_INT 1
15791: DOUBLE
15792: EQUAL
15793: IFTRUE 15797
15795: GO 15808
15797: POP
// end_the_mission_allowed := true ; 2 :
15798: LD_ADDR_OWVAR 57
15802: PUSH
15803: LD_INT 1
15805: ST_TO_ADDR
15806: GO 15824
15808: LD_INT 2
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15823
15816: POP
// EndMission ; end ;
15817: CALL 15832 0 0
15821: GO 15824
15823: POP
// end ;
15824: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15825: CALL 15832 0 0
// end ;
15829: PPOPN 1
15831: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15832: LD_INT 0
15834: PPUSH
15835: PPUSH
15836: PPUSH
15837: PPUSH
15838: PPUSH
// m1 := false ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 0
15846: ST_TO_ADDR
// m2 := false ;
15847: LD_ADDR_VAR 0 4
15851: PUSH
15852: LD_INT 0
15854: ST_TO_ADDR
// m3 := false ;
15855: LD_ADDR_VAR 0 5
15859: PUSH
15860: LD_INT 0
15862: ST_TO_ADDR
// if not am_veh_consturcted then
15863: LD_EXP 20
15867: NOT
15868: IFFALSE 15877
// SetAchievement ( ACH_ARABTECH ) ;
15870: LD_STRING ACH_ARABTECH
15872: PPUSH
15873: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15877: LD_OWVAR 1
15881: PUSH
15882: LD_INT 252000
15884: PUSH
15885: LD_INT 210000
15887: PUSH
15888: LD_INT 199500
15890: PUSH
15891: LD_INT 193200
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: LIST
15898: LIST
15899: PUSH
15900: LD_OWVAR 67
15904: ARRAY
15905: LESS
15906: IFFALSE 15928
// begin m3 := true ;
15908: LD_ADDR_VAR 0 5
15912: PUSH
15913: LD_INT 1
15915: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15916: LD_STRING Time1
15918: PPUSH
15919: LD_INT 1
15921: PPUSH
15922: CALL_OW 101
// end else
15926: GO 15959
// if not powell_warn then
15928: LD_EXP 16
15932: NOT
15933: IFFALSE 15948
// AddMedal ( Time1 , - 1 ) else
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
15946: GO 15959
// AddMedal ( Time1 , - 2 ) ;
15948: LD_STRING Time1
15950: PPUSH
15951: LD_INT 2
15953: NEG
15954: PPUSH
15955: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15959: LD_EXP 17
15963: PUSH
15964: LD_INT 5
15966: PUSH
15967: LD_INT 4
15969: PUSH
15970: LD_INT 3
15972: PUSH
15973: LD_INT 3
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: PUSH
15982: LD_OWVAR 67
15986: ARRAY
15987: GREATEREQUAL
15988: IFFALSE 16003
// AddMedal ( Destroy , - 2 ) else
15990: LD_STRING Destroy
15992: PPUSH
15993: LD_INT 2
15995: NEG
15996: PPUSH
15997: CALL_OW 101
16001: GO 16136
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16003: LD_INT 22
16005: PUSH
16006: LD_INT 2
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PUSH
16013: LD_INT 21
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 50
16025: PUSH
16026: EMPTY
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: LIST
16033: PPUSH
16034: CALL_OW 69
16038: PUSH
16039: LD_INT 25
16041: GREATEREQUAL
16042: IFFALSE 16057
// AddMedal ( Destroy , - 1 ) else
16044: LD_STRING Destroy
16046: PPUSH
16047: LD_INT 1
16049: NEG
16050: PPUSH
16051: CALL_OW 101
16055: GO 16136
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16057: LD_INT 22
16059: PUSH
16060: LD_INT 2
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: LD_INT 21
16069: PUSH
16070: LD_INT 3
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: PUSH
16077: LD_INT 50
16079: PUSH
16080: EMPTY
16081: LIST
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: LIST
16087: PPUSH
16088: CALL_OW 69
16092: PUSH
16093: LD_INT 15
16095: GREATEREQUAL
16096: IFFALSE 16118
// begin m1 := true ;
16098: LD_ADDR_VAR 0 3
16102: PUSH
16103: LD_INT 1
16105: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16106: LD_STRING Destroy
16108: PPUSH
16109: LD_INT 1
16111: PPUSH
16112: CALL_OW 101
// end else
16116: GO 16136
// begin m1 := true ;
16118: LD_ADDR_VAR 0 3
16122: PUSH
16123: LD_INT 1
16125: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16126: LD_STRING Destroy
16128: PPUSH
16129: LD_INT 2
16131: PPUSH
16132: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16136: LD_EXP 13
16140: PPUSH
16141: LD_STRING 11_artifact_captured
16143: PPUSH
16144: CALL_OW 39
// if artifact_get then
16148: LD_EXP 13
16152: IFFALSE 16174
// begin m2 := true ;
16154: LD_ADDR_VAR 0 4
16158: PUSH
16159: LD_INT 1
16161: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16162: LD_STRING Artefact
16164: PPUSH
16165: LD_INT 1
16167: PPUSH
16168: CALL_OW 101
// end else
16172: GO 16185
// AddMedal ( Artefact , - 1 ) ;
16174: LD_STRING Artefact
16176: PPUSH
16177: LD_INT 1
16179: NEG
16180: PPUSH
16181: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16185: LD_VAR 0 3
16189: PUSH
16190: LD_VAR 0 4
16194: AND
16195: PUSH
16196: LD_VAR 0 5
16200: AND
16201: PUSH
16202: LD_OWVAR 67
16206: PUSH
16207: LD_INT 3
16209: GREATEREQUAL
16210: AND
16211: IFFALSE 16223
// SetAchievementEX ( ACH_AMER , 11 ) ;
16213: LD_STRING ACH_AMER
16215: PPUSH
16216: LD_INT 11
16218: PPUSH
16219: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16223: LD_VAR 0 3
16227: PUSH
16228: LD_VAR 0 4
16232: AND
16233: PUSH
16234: LD_VAR 0 5
16238: AND
16239: PUSH
16240: LD_EXP 17
16244: PUSH
16245: LD_INT 0
16247: EQUAL
16248: AND
16249: IFFALSE 16265
// begin wait ( 3 ) ;
16251: LD_INT 3
16253: PPUSH
16254: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16258: LD_STRING ACH_GENERAL
16260: PPUSH
16261: CALL_OW 543
// end ; if tick <= 100 100$00 then
16265: LD_OWVAR 1
16269: PUSH
16270: LD_INT 210000
16272: LESSEQUAL
16273: IFFALSE 16289
// begin wait ( 3 ) ;
16275: LD_INT 3
16277: PPUSH
16278: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16282: LD_STRING ACH_ASPEED_11
16284: PPUSH
16285: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16289: LD_STRING MAIN
16291: PPUSH
16292: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16296: LD_ADDR_EXP 19
16300: PUSH
16301: LD_EXP 19
16305: PPUSH
16306: LD_INT 51
16308: PUSH
16309: EMPTY
16310: LIST
16311: PPUSH
16312: CALL_OW 72
16316: ST_TO_ADDR
// tmp := JMM ^ selected ;
16317: LD_ADDR_VAR 0 2
16321: PUSH
16322: LD_EXP 21
16326: PUSH
16327: LD_EXP 19
16331: ADD
16332: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16333: LD_VAR 0 2
16337: PPUSH
16338: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16342: LD_VAR 0 2
16346: PUSH
16347: LD_EXP 21
16351: PUSH
16352: LD_EXP 22
16356: PUSH
16357: LD_EXP 23
16361: PUSH
16362: LD_EXP 24
16366: PUSH
16367: LD_EXP 25
16371: PUSH
16372: LD_EXP 26
16376: PUSH
16377: LD_EXP 27
16381: PUSH
16382: LD_EXP 28
16386: PUSH
16387: LD_EXP 29
16391: PUSH
16392: LD_EXP 31
16396: PUSH
16397: LD_EXP 32
16401: PUSH
16402: LD_EXP 33
16406: PUSH
16407: LD_EXP 34
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: LIST
16416: LIST
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: LIST
16423: LIST
16424: LIST
16425: LIST
16426: DIFF
16427: PPUSH
16428: LD_STRING 11c_others
16430: PPUSH
16431: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16435: LD_EXP 21
16439: PPUSH
16440: LD_EXP 3
16444: PUSH
16445: LD_STRING JMM
16447: STR
16448: PPUSH
16449: CALL_OW 38
// if Lisa then
16453: LD_EXP 22
16457: IFFALSE 16477
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16459: LD_EXP 22
16463: PPUSH
16464: LD_EXP 3
16468: PUSH
16469: LD_STRING Lisa
16471: STR
16472: PPUSH
16473: CALL_OW 38
// if Donaldson then
16477: LD_EXP 23
16481: IFFALSE 16501
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16483: LD_EXP 23
16487: PPUSH
16488: LD_EXP 3
16492: PUSH
16493: LD_STRING Donaldson
16495: STR
16496: PPUSH
16497: CALL_OW 38
// if Bobby then
16501: LD_EXP 24
16505: IFFALSE 16525
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16507: LD_EXP 24
16511: PPUSH
16512: LD_EXP 3
16516: PUSH
16517: LD_STRING Bobby
16519: STR
16520: PPUSH
16521: CALL_OW 38
// if Cyrus then
16525: LD_EXP 25
16529: IFFALSE 16549
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16531: LD_EXP 25
16535: PPUSH
16536: LD_EXP 3
16540: PUSH
16541: LD_STRING Cyrus
16543: STR
16544: PPUSH
16545: CALL_OW 38
// if Denis then
16549: LD_EXP 26
16553: IFFALSE 16573
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16555: LD_EXP 26
16559: PPUSH
16560: LD_EXP 3
16564: PUSH
16565: LD_STRING Denis
16567: STR
16568: PPUSH
16569: CALL_OW 38
// if Brown then
16573: LD_EXP 27
16577: IFFALSE 16597
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16579: LD_EXP 27
16583: PPUSH
16584: LD_EXP 3
16588: PUSH
16589: LD_STRING Brown
16591: STR
16592: PPUSH
16593: CALL_OW 38
// if Gladstone then
16597: LD_EXP 28
16601: IFFALSE 16621
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16603: LD_EXP 28
16607: PPUSH
16608: LD_EXP 3
16612: PUSH
16613: LD_STRING Gladstone
16615: STR
16616: PPUSH
16617: CALL_OW 38
// if Houten then
16621: LD_EXP 29
16625: IFFALSE 16645
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16627: LD_EXP 29
16631: PPUSH
16632: LD_EXP 3
16636: PUSH
16637: LD_STRING Houten
16639: STR
16640: PPUSH
16641: CALL_OW 38
// if Cornel then
16645: LD_EXP 31
16649: IFFALSE 16669
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16651: LD_EXP 31
16655: PPUSH
16656: LD_EXP 3
16660: PUSH
16661: LD_STRING Cornell
16663: STR
16664: PPUSH
16665: CALL_OW 38
// if Gary then
16669: LD_EXP 32
16673: IFFALSE 16693
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16675: LD_EXP 32
16679: PPUSH
16680: LD_EXP 3
16684: PUSH
16685: LD_STRING Gary
16687: STR
16688: PPUSH
16689: CALL_OW 38
// if Frank then
16693: LD_EXP 33
16697: IFFALSE 16717
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16699: LD_EXP 33
16703: PPUSH
16704: LD_EXP 3
16708: PUSH
16709: LD_STRING Frank
16711: STR
16712: PPUSH
16713: CALL_OW 38
// if Kikuchi then
16717: LD_EXP 34
16721: IFFALSE 16741
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16723: LD_EXP 34
16727: PPUSH
16728: LD_EXP 3
16732: PUSH
16733: LD_STRING Kikuchi
16735: STR
16736: PPUSH
16737: CALL_OW 38
// YouWin ;
16741: CALL_OW 103
// end ;
16745: LD_VAR 0 1
16749: RET
// export function CanSayRand ( side ) ; begin
16750: LD_INT 0
16752: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16753: LD_ADDR_VAR 0 2
16757: PUSH
16758: LD_INT 52
16760: PUSH
16761: EMPTY
16762: LIST
16763: PUSH
16764: LD_INT 22
16766: PUSH
16767: LD_VAR 0 1
16771: PUSH
16772: EMPTY
16773: LIST
16774: LIST
16775: PUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 2
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 3
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 25
16811: PUSH
16812: LD_INT 4
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: LIST
16830: PPUSH
16831: CALL_OW 69
16835: PUSH
16836: LD_EXP 21
16840: PUSH
16841: LD_EXP 33
16845: PUSH
16846: LD_EXP 22
16850: PUSH
16851: LD_EXP 23
16855: PUSH
16856: LD_EXP 24
16860: PUSH
16861: LD_EXP 25
16865: PUSH
16866: LD_EXP 26
16870: PUSH
16871: LD_EXP 27
16875: PUSH
16876: LD_EXP 28
16880: PUSH
16881: LD_EXP 29
16885: PUSH
16886: LD_EXP 30
16890: PUSH
16891: LD_EXP 31
16895: PUSH
16896: LD_EXP 32
16900: PUSH
16901: LD_EXP 34
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: DIFF
16922: ST_TO_ADDR
// end ;
16923: LD_VAR 0 2
16927: RET
// export function SayRand ( sex , dial ) ; begin
16928: LD_INT 0
16930: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16931: LD_ADDR_VAR 0 3
16935: PUSH
16936: LD_INT 52
16938: PUSH
16939: EMPTY
16940: LIST
16941: PUSH
16942: LD_INT 22
16944: PUSH
16945: LD_INT 1
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: PUSH
16952: LD_INT 26
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 2
16966: PUSH
16967: LD_INT 25
16969: PUSH
16970: LD_INT 1
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 25
16979: PUSH
16980: LD_INT 2
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 25
16989: PUSH
16990: LD_INT 3
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: PUSH
16997: LD_INT 25
16999: PUSH
17000: LD_INT 4
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: PUSH
17025: LD_EXP 21
17029: PUSH
17030: LD_EXP 33
17034: PUSH
17035: LD_EXP 22
17039: PUSH
17040: LD_EXP 23
17044: PUSH
17045: LD_EXP 24
17049: PUSH
17050: LD_EXP 25
17054: PUSH
17055: LD_EXP 26
17059: PUSH
17060: LD_EXP 27
17064: PUSH
17065: LD_EXP 28
17069: PUSH
17070: LD_EXP 29
17074: PUSH
17075: LD_EXP 30
17079: PUSH
17080: LD_EXP 31
17084: PUSH
17085: LD_EXP 32
17089: PUSH
17090: LD_EXP 34
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: LIST
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: DIFF
17111: ST_TO_ADDR
// if not result then
17112: LD_VAR 0 3
17116: NOT
17117: IFFALSE 17121
// exit ;
17119: GO 17149
// result := result [ 1 ] ;
17121: LD_ADDR_VAR 0 3
17125: PUSH
17126: LD_VAR 0 3
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: ST_TO_ADDR
// Say ( result , dial ) ;
17135: LD_VAR 0 3
17139: PPUSH
17140: LD_VAR 0 2
17144: PPUSH
17145: CALL_OW 88
// end ;
17149: LD_VAR 0 3
17153: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17154: LD_INT 0
17156: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17157: LD_ADDR_VAR 0 4
17161: PUSH
17162: LD_INT 22
17164: PUSH
17165: LD_INT 1
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 26
17174: PUSH
17175: LD_VAR 0 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 1
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: LD_INT 25
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PUSH
17207: LD_INT 25
17209: PUSH
17210: LD_INT 3
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: PUSH
17217: LD_INT 25
17219: PUSH
17220: LD_INT 4
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: LIST
17232: LIST
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: LIST
17238: PPUSH
17239: CALL_OW 69
17243: PUSH
17244: LD_EXP 21
17248: PUSH
17249: LD_EXP 33
17253: PUSH
17254: LD_EXP 22
17258: PUSH
17259: LD_EXP 23
17263: PUSH
17264: LD_EXP 24
17268: PUSH
17269: LD_EXP 25
17273: PUSH
17274: LD_EXP 26
17278: PUSH
17279: LD_EXP 27
17283: PUSH
17284: LD_EXP 28
17288: PUSH
17289: LD_EXP 29
17293: PUSH
17294: LD_EXP 30
17298: PUSH
17299: LD_EXP 31
17303: PUSH
17304: LD_EXP 32
17308: PUSH
17309: LD_EXP 34
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: LIST
17326: LIST
17327: LIST
17328: LIST
17329: PUSH
17330: LD_VAR 0 3
17334: ADD
17335: DIFF
17336: ST_TO_ADDR
// if not result then
17337: LD_VAR 0 4
17341: NOT
17342: IFFALSE 17346
// exit ;
17344: GO 17374
// result := result [ 1 ] ;
17346: LD_ADDR_VAR 0 4
17350: PUSH
17351: LD_VAR 0 4
17355: PUSH
17356: LD_INT 1
17358: ARRAY
17359: ST_TO_ADDR
// Say ( result , dial ) ;
17360: LD_VAR 0 4
17364: PPUSH
17365: LD_VAR 0 2
17369: PPUSH
17370: CALL_OW 88
// end ; end_of_file
17374: LD_VAR 0 4
17378: RET
// export function CustomEvent ( event ) ; begin
17379: LD_INT 0
17381: PPUSH
// end ;
17382: LD_VAR 0 2
17386: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17387: LD_VAR 0 1
17391: PPUSH
17392: CALL_OW 255
17396: PUSH
17397: LD_INT 1
17399: EQUAL
17400: IFFALSE 17410
// artifact_get := true ;
17402: LD_ADDR_EXP 13
17406: PUSH
17407: LD_INT 1
17409: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17410: LD_VAR 0 1
17414: PPUSH
17415: CALL_OW 255
17419: PUSH
17420: LD_INT 2
17422: EQUAL
17423: IFFALSE 17441
// begin artifact_get := false ;
17425: LD_ADDR_EXP 13
17429: PUSH
17430: LD_INT 0
17432: ST_TO_ADDR
// artifact_stolen := true ;
17433: LD_ADDR_EXP 12
17437: PUSH
17438: LD_INT 1
17440: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17441: LD_ADDR_EXP 14
17445: PUSH
17446: LD_INT 1
17448: ST_TO_ADDR
// end ;
17449: PPOPN 2
17451: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17452: LD_ADDR_EXP 14
17456: PUSH
17457: LD_INT 0
17459: ST_TO_ADDR
// end ;
17460: PPOPN 2
17462: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL 106240 0 1
// if un = JMM then
17472: LD_VAR 0 1
17476: PUSH
17477: LD_EXP 21
17481: EQUAL
17482: IFFALSE 17493
// begin YouLost ( JMM ) ;
17484: LD_STRING JMM
17486: PPUSH
17487: CALL_OW 104
// exit ;
17491: GO 17625
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17493: LD_VAR 0 1
17497: PUSH
17498: LD_INT 22
17500: PUSH
17501: LD_INT 1
17503: PUSH
17504: EMPTY
17505: LIST
17506: LIST
17507: PUSH
17508: LD_INT 21
17510: PUSH
17511: LD_INT 1
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: LD_INT 2
17520: PUSH
17521: LD_INT 25
17523: PUSH
17524: LD_INT 1
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: PUSH
17531: LD_INT 25
17533: PUSH
17534: LD_INT 2
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: LD_INT 25
17543: PUSH
17544: LD_INT 3
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 25
17553: PUSH
17554: LD_INT 4
17556: PUSH
17557: EMPTY
17558: LIST
17559: LIST
17560: PUSH
17561: LD_INT 25
17563: PUSH
17564: LD_INT 5
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PUSH
17571: LD_INT 25
17573: PUSH
17574: LD_INT 8
17576: PUSH
17577: EMPTY
17578: LIST
17579: LIST
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: PUSH
17590: EMPTY
17591: LIST
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 69
17599: IN
17600: IFFALSE 17616
// loses_counter := loses_counter + 1 ;
17602: LD_ADDR_EXP 17
17606: PUSH
17607: LD_EXP 17
17611: PUSH
17612: LD_INT 1
17614: PLUS
17615: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17616: LD_VAR 0 1
17620: PPUSH
17621: CALL 46041 0 1
// end ;
17625: PPOPN 1
17627: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17628: LD_VAR 0 1
17632: PPUSH
17633: LD_VAR 0 2
17637: PPUSH
17638: CALL 48373 0 2
// end ;
17642: PPOPN 2
17644: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17645: LD_VAR 0 1
17649: PPUSH
17650: CALL 47682 0 1
// end ;
17654: PPOPN 1
17656: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17657: LD_VAR 0 1
17661: PPUSH
17662: LD_VAR 0 2
17666: PPUSH
17667: LD_VAR 0 3
17671: PPUSH
17672: LD_VAR 0 4
17676: PPUSH
17677: LD_VAR 0 5
17681: PPUSH
17682: CALL 45357 0 5
// end ;
17686: PPOPN 5
17688: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17689: LD_VAR 0 1
17693: PPUSH
17694: LD_VAR 0 2
17698: PPUSH
17699: CALL 106360 0 2
// if GetNation ( vehicle ) = nation_american then
17703: LD_VAR 0 1
17707: PPUSH
17708: CALL_OW 248
17712: PUSH
17713: LD_INT 1
17715: EQUAL
17716: IFFALSE 17726
// am_veh_consturcted := true ;
17718: LD_ADDR_EXP 20
17722: PUSH
17723: LD_INT 1
17725: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17726: LD_VAR 0 1
17730: PPUSH
17731: LD_VAR 0 2
17735: PPUSH
17736: CALL 44910 0 2
// end ;
17740: PPOPN 2
17742: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17743: LD_VAR 0 1
17747: PPUSH
17748: CALL_OW 247
17752: PUSH
17753: LD_INT 2
17755: EQUAL
17756: IFFALSE 17760
// exit ;
17758: GO 17777
// if not kamikazed then
17760: LD_EXP 11
17764: NOT
17765: IFFALSE 17777
// kamikazed := unit ;
17767: LD_ADDR_EXP 11
17771: PUSH
17772: LD_VAR 0 1
17776: ST_TO_ADDR
// end ;
17777: PPOPN 1
17779: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17780: LD_INT 0
17782: PPUSH
17783: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17784: LD_VAR 0 1
17788: PPUSH
17789: LD_VAR 0 2
17793: PPUSH
17794: LD_VAR 0 3
17798: PPUSH
17799: LD_VAR 0 4
17803: PPUSH
17804: CALL 44748 0 4
// end ;
17808: PPOPN 6
17810: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17811: LD_VAR 0 1
17815: PPUSH
17816: LD_VAR 0 2
17820: PPUSH
17821: LD_VAR 0 3
17825: PPUSH
17826: CALL 44523 0 3
// end ;
17830: PPOPN 3
17832: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17833: LD_VAR 0 1
17837: PPUSH
17838: LD_VAR 0 2
17842: PPUSH
17843: CALL 45737 0 2
// end ;
17847: PPOPN 2
17849: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17850: LD_VAR 0 1
17854: PPUSH
17855: LD_VAR 0 2
17859: PPUSH
17860: CALL 44217 0 2
// end ;
17864: PPOPN 2
17866: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17867: LD_VAR 0 1
17871: PPUSH
17872: LD_VAR 0 2
17876: PPUSH
17877: CALL 44408 0 2
// end ;
17881: PPOPN 2
17883: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17884: LD_VAR 0 1
17888: PPUSH
17889: CALL 47441 0 1
// end ;
17893: PPOPN 1
17895: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17896: LD_VAR 0 1
17900: PPUSH
17901: LD_VAR 0 2
17905: PPUSH
17906: CALL 48668 0 2
// end ;
17910: PPOPN 2
17912: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17913: LD_VAR 0 1
17917: PPUSH
17918: LD_VAR 0 2
17922: PPUSH
17923: LD_VAR 0 3
17927: PPUSH
17928: LD_VAR 0 4
17932: PPUSH
17933: CALL 48884 0 4
// end ;
17937: PPOPN 4
17939: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17940: LD_VAR 0 1
17944: PPUSH
17945: CALL 106344 0 1
// end ;
17949: PPOPN 1
17951: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
17952: LD_INT 22
17954: PUSH
17955: LD_INT 2
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: PUSH
17962: LD_INT 50
17964: PUSH
17965: EMPTY
17966: LIST
17967: PUSH
17968: LD_INT 21
17970: PUSH
17971: LD_INT 1
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: LIST
17982: PPUSH
17983: CALL_OW 69
17987: IFFALSE 18071
17989: GO 17991
17991: DISABLE
17992: LD_INT 0
17994: PPUSH
// begin enable ;
17995: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
17996: LD_ADDR_VAR 0 1
18000: PUSH
18001: LD_INT 22
18003: PUSH
18004: LD_INT 2
18006: PUSH
18007: EMPTY
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 50
18013: PUSH
18014: EMPTY
18015: LIST
18016: PUSH
18017: LD_INT 21
18019: PUSH
18020: LD_INT 1
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: PUSH
18027: EMPTY
18028: LIST
18029: LIST
18030: LIST
18031: PPUSH
18032: CALL_OW 69
18036: PUSH
18037: FOR_IN
18038: IFFALSE 18069
// if GetFuel ( i ) < 3 then
18040: LD_VAR 0 1
18044: PPUSH
18045: CALL_OW 261
18049: PUSH
18050: LD_INT 3
18052: LESS
18053: IFFALSE 18067
// SetFuel ( i , 5 ) ;
18055: LD_VAR 0 1
18059: PPUSH
18060: LD_INT 5
18062: PPUSH
18063: CALL_OW 240
18067: GO 18037
18069: POP
18070: POP
// end ; end_of_file
18071: PPOPN 1
18073: END
// every 0 0$1 trigger game do
18074: LD_EXP 2
18078: IFFALSE 18108
18080: GO 18082
18082: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18083: LD_INT 7
18085: PUSH
18086: LD_INT 6
18088: PUSH
18089: LD_INT 4
18091: PUSH
18092: LD_INT 6
18094: PUSH
18095: EMPTY
18096: LIST
18097: LIST
18098: LIST
18099: LIST
18100: PPUSH
18101: LD_INT 1750
18103: PPUSH
18104: CALL 18109 0 2
18108: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18109: LD_INT 0
18111: PPUSH
18112: PPUSH
18113: PPUSH
// if not areas then
18114: LD_VAR 0 1
18118: NOT
18119: IFFALSE 18123
// exit ;
18121: GO 18253
// repeat wait ( time ) ;
18123: LD_VAR 0 2
18127: PPUSH
18128: CALL_OW 67
// for i in areas do
18132: LD_ADDR_VAR 0 4
18136: PUSH
18137: LD_VAR 0 1
18141: PUSH
18142: FOR_IN
18143: IFFALSE 18212
// begin p := rand ( 1 , 90 ) ;
18145: LD_ADDR_VAR 0 5
18149: PUSH
18150: LD_INT 1
18152: PPUSH
18153: LD_INT 90
18155: PPUSH
18156: CALL_OW 12
18160: ST_TO_ADDR
// if Prob ( p ) then
18161: LD_VAR 0 5
18165: PPUSH
18166: CALL_OW 13
18170: IFFALSE 18210
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18172: LD_INT 2
18174: PPUSH
18175: LD_INT 5
18177: PPUSH
18178: CALL_OW 12
18182: PPUSH
18183: LD_VAR 0 4
18187: PPUSH
18188: LD_INT 1
18190: PPUSH
18191: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18195: LD_INT 735
18197: PPUSH
18198: LD_INT 1295
18200: PPUSH
18201: CALL_OW 12
18205: PPUSH
18206: CALL_OW 67
// end ; end ;
18210: GO 18142
18212: POP
18213: POP
// time := time + 0 0$3 ;
18214: LD_ADDR_VAR 0 2
18218: PUSH
18219: LD_VAR 0 2
18223: PUSH
18224: LD_INT 105
18226: PLUS
18227: ST_TO_ADDR
// if time > 3 3$00 then
18228: LD_VAR 0 2
18232: PUSH
18233: LD_INT 6300
18235: GREATER
18236: IFFALSE 18246
// time := 0 0$40 ;
18238: LD_ADDR_VAR 0 2
18242: PUSH
18243: LD_INT 1400
18245: ST_TO_ADDR
// until not game ;
18246: LD_EXP 2
18250: NOT
18251: IFFALSE 18123
// end ;
18253: LD_VAR 0 3
18257: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18258: LD_OWVAR 1
18262: PUSH
18263: LD_INT 84000
18265: PUSH
18266: LD_INT 73500
18268: PUSH
18269: LD_INT 63000
18271: PUSH
18272: LD_INT 52500
18274: PUSH
18275: EMPTY
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: PUSH
18281: LD_OWVAR 67
18285: ARRAY
18286: LESS
18287: IFFALSE 18314
18289: GO 18291
18291: DISABLE
// begin enable ;
18292: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18293: LD_INT 1
18295: PPUSH
18296: LD_INT 5
18298: PPUSH
18299: CALL_OW 12
18303: PPUSH
18304: LD_INT 7
18306: PPUSH
18307: LD_INT 1
18309: PPUSH
18310: CALL_OW 55
// end ; end_of_file
18314: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18315: LD_INT 0
18317: PPUSH
18318: PPUSH
// skirmish := false ;
18319: LD_ADDR_EXP 48
18323: PUSH
18324: LD_INT 0
18326: ST_TO_ADDR
// debug_mc := false ;
18327: LD_ADDR_EXP 49
18331: PUSH
18332: LD_INT 0
18334: ST_TO_ADDR
// mc_bases := [ ] ;
18335: LD_ADDR_EXP 50
18339: PUSH
18340: EMPTY
18341: ST_TO_ADDR
// mc_sides := [ ] ;
18342: LD_ADDR_EXP 76
18346: PUSH
18347: EMPTY
18348: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18349: LD_ADDR_EXP 51
18353: PUSH
18354: EMPTY
18355: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18356: LD_ADDR_EXP 52
18360: PUSH
18361: EMPTY
18362: ST_TO_ADDR
// mc_need_heal := [ ] ;
18363: LD_ADDR_EXP 53
18367: PUSH
18368: EMPTY
18369: ST_TO_ADDR
// mc_healers := [ ] ;
18370: LD_ADDR_EXP 54
18374: PUSH
18375: EMPTY
18376: ST_TO_ADDR
// mc_build_list := [ ] ;
18377: LD_ADDR_EXP 55
18381: PUSH
18382: EMPTY
18383: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18384: LD_ADDR_EXP 82
18388: PUSH
18389: EMPTY
18390: ST_TO_ADDR
// mc_builders := [ ] ;
18391: LD_ADDR_EXP 56
18395: PUSH
18396: EMPTY
18397: ST_TO_ADDR
// mc_construct_list := [ ] ;
18398: LD_ADDR_EXP 57
18402: PUSH
18403: EMPTY
18404: ST_TO_ADDR
// mc_turret_list := [ ] ;
18405: LD_ADDR_EXP 58
18409: PUSH
18410: EMPTY
18411: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18412: LD_ADDR_EXP 59
18416: PUSH
18417: EMPTY
18418: ST_TO_ADDR
// mc_miners := [ ] ;
18419: LD_ADDR_EXP 64
18423: PUSH
18424: EMPTY
18425: ST_TO_ADDR
// mc_mines := [ ] ;
18426: LD_ADDR_EXP 63
18430: PUSH
18431: EMPTY
18432: ST_TO_ADDR
// mc_minefields := [ ] ;
18433: LD_ADDR_EXP 65
18437: PUSH
18438: EMPTY
18439: ST_TO_ADDR
// mc_crates := [ ] ;
18440: LD_ADDR_EXP 66
18444: PUSH
18445: EMPTY
18446: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18447: LD_ADDR_EXP 67
18451: PUSH
18452: EMPTY
18453: ST_TO_ADDR
// mc_crates_area := [ ] ;
18454: LD_ADDR_EXP 68
18458: PUSH
18459: EMPTY
18460: ST_TO_ADDR
// mc_vehicles := [ ] ;
18461: LD_ADDR_EXP 69
18465: PUSH
18466: EMPTY
18467: ST_TO_ADDR
// mc_attack := [ ] ;
18468: LD_ADDR_EXP 70
18472: PUSH
18473: EMPTY
18474: ST_TO_ADDR
// mc_produce := [ ] ;
18475: LD_ADDR_EXP 71
18479: PUSH
18480: EMPTY
18481: ST_TO_ADDR
// mc_defender := [ ] ;
18482: LD_ADDR_EXP 72
18486: PUSH
18487: EMPTY
18488: ST_TO_ADDR
// mc_parking := [ ] ;
18489: LD_ADDR_EXP 74
18493: PUSH
18494: EMPTY
18495: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18496: LD_ADDR_EXP 60
18500: PUSH
18501: EMPTY
18502: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18503: LD_ADDR_EXP 62
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// mc_scan := [ ] ;
18510: LD_ADDR_EXP 73
18514: PUSH
18515: EMPTY
18516: ST_TO_ADDR
// mc_scan_area := [ ] ;
18517: LD_ADDR_EXP 75
18521: PUSH
18522: EMPTY
18523: ST_TO_ADDR
// mc_tech := [ ] ;
18524: LD_ADDR_EXP 77
18528: PUSH
18529: EMPTY
18530: ST_TO_ADDR
// mc_class := [ ] ;
18531: LD_ADDR_EXP 91
18535: PUSH
18536: EMPTY
18537: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18538: LD_ADDR_EXP 92
18542: PUSH
18543: EMPTY
18544: ST_TO_ADDR
// mc_is_defending := [ ] ;
18545: LD_ADDR_EXP 93
18549: PUSH
18550: EMPTY
18551: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18552: LD_ADDR_EXP 84
18556: PUSH
18557: EMPTY
18558: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18559: LD_ADDR_EXP 94
18563: PUSH
18564: LD_INT 0
18566: ST_TO_ADDR
// end ;
18567: LD_VAR 0 1
18571: RET
// export function MC_Kill ( base ) ; begin
18572: LD_INT 0
18574: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18575: LD_ADDR_EXP 50
18579: PUSH
18580: LD_EXP 50
18584: PPUSH
18585: LD_VAR 0 1
18589: PPUSH
18590: EMPTY
18591: PPUSH
18592: CALL_OW 1
18596: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18597: LD_ADDR_EXP 51
18601: PUSH
18602: LD_EXP 51
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: EMPTY
18613: PPUSH
18614: CALL_OW 1
18618: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18619: LD_ADDR_EXP 52
18623: PUSH
18624: LD_EXP 52
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: EMPTY
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18641: LD_ADDR_EXP 53
18645: PUSH
18646: LD_EXP 53
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: EMPTY
18657: PPUSH
18658: CALL_OW 1
18662: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18663: LD_ADDR_EXP 54
18667: PUSH
18668: LD_EXP 54
18672: PPUSH
18673: LD_VAR 0 1
18677: PPUSH
18678: EMPTY
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18685: LD_ADDR_EXP 55
18689: PUSH
18690: LD_EXP 55
18694: PPUSH
18695: LD_VAR 0 1
18699: PPUSH
18700: EMPTY
18701: PPUSH
18702: CALL_OW 1
18706: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18707: LD_ADDR_EXP 56
18711: PUSH
18712: LD_EXP 56
18716: PPUSH
18717: LD_VAR 0 1
18721: PPUSH
18722: EMPTY
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18729: LD_ADDR_EXP 57
18733: PUSH
18734: LD_EXP 57
18738: PPUSH
18739: LD_VAR 0 1
18743: PPUSH
18744: EMPTY
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18751: LD_ADDR_EXP 58
18755: PUSH
18756: LD_EXP 58
18760: PPUSH
18761: LD_VAR 0 1
18765: PPUSH
18766: EMPTY
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18773: LD_ADDR_EXP 59
18777: PUSH
18778: LD_EXP 59
18782: PPUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: EMPTY
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18795: LD_ADDR_EXP 60
18799: PUSH
18800: LD_EXP 60
18804: PPUSH
18805: LD_VAR 0 1
18809: PPUSH
18810: EMPTY
18811: PPUSH
18812: CALL_OW 1
18816: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18817: LD_ADDR_EXP 61
18821: PUSH
18822: LD_EXP 61
18826: PPUSH
18827: LD_VAR 0 1
18831: PPUSH
18832: LD_INT 0
18834: PPUSH
18835: CALL_OW 1
18839: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18840: LD_ADDR_EXP 62
18844: PUSH
18845: LD_EXP 62
18849: PPUSH
18850: LD_VAR 0 1
18854: PPUSH
18855: EMPTY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18862: LD_ADDR_EXP 63
18866: PUSH
18867: LD_EXP 63
18871: PPUSH
18872: LD_VAR 0 1
18876: PPUSH
18877: EMPTY
18878: PPUSH
18879: CALL_OW 1
18883: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18884: LD_ADDR_EXP 64
18888: PUSH
18889: LD_EXP 64
18893: PPUSH
18894: LD_VAR 0 1
18898: PPUSH
18899: EMPTY
18900: PPUSH
18901: CALL_OW 1
18905: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18906: LD_ADDR_EXP 65
18910: PUSH
18911: LD_EXP 65
18915: PPUSH
18916: LD_VAR 0 1
18920: PPUSH
18921: EMPTY
18922: PPUSH
18923: CALL_OW 1
18927: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18928: LD_ADDR_EXP 66
18932: PUSH
18933: LD_EXP 66
18937: PPUSH
18938: LD_VAR 0 1
18942: PPUSH
18943: EMPTY
18944: PPUSH
18945: CALL_OW 1
18949: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18950: LD_ADDR_EXP 67
18954: PUSH
18955: LD_EXP 67
18959: PPUSH
18960: LD_VAR 0 1
18964: PPUSH
18965: EMPTY
18966: PPUSH
18967: CALL_OW 1
18971: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18972: LD_ADDR_EXP 68
18976: PUSH
18977: LD_EXP 68
18981: PPUSH
18982: LD_VAR 0 1
18986: PPUSH
18987: EMPTY
18988: PPUSH
18989: CALL_OW 1
18993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18994: LD_ADDR_EXP 69
18998: PUSH
18999: LD_EXP 69
19003: PPUSH
19004: LD_VAR 0 1
19008: PPUSH
19009: EMPTY
19010: PPUSH
19011: CALL_OW 1
19015: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19016: LD_ADDR_EXP 70
19020: PUSH
19021: LD_EXP 70
19025: PPUSH
19026: LD_VAR 0 1
19030: PPUSH
19031: EMPTY
19032: PPUSH
19033: CALL_OW 1
19037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19038: LD_ADDR_EXP 71
19042: PUSH
19043: LD_EXP 71
19047: PPUSH
19048: LD_VAR 0 1
19052: PPUSH
19053: EMPTY
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19060: LD_ADDR_EXP 72
19064: PUSH
19065: LD_EXP 72
19069: PPUSH
19070: LD_VAR 0 1
19074: PPUSH
19075: EMPTY
19076: PPUSH
19077: CALL_OW 1
19081: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19082: LD_ADDR_EXP 73
19086: PUSH
19087: LD_EXP 73
19091: PPUSH
19092: LD_VAR 0 1
19096: PPUSH
19097: EMPTY
19098: PPUSH
19099: CALL_OW 1
19103: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19104: LD_ADDR_EXP 74
19108: PUSH
19109: LD_EXP 74
19113: PPUSH
19114: LD_VAR 0 1
19118: PPUSH
19119: EMPTY
19120: PPUSH
19121: CALL_OW 1
19125: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19126: LD_ADDR_EXP 75
19130: PUSH
19131: LD_EXP 75
19135: PPUSH
19136: LD_VAR 0 1
19140: PPUSH
19141: EMPTY
19142: PPUSH
19143: CALL_OW 1
19147: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19148: LD_ADDR_EXP 77
19152: PUSH
19153: LD_EXP 77
19157: PPUSH
19158: LD_VAR 0 1
19162: PPUSH
19163: EMPTY
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19170: LD_ADDR_EXP 79
19174: PUSH
19175: LD_EXP 79
19179: PPUSH
19180: LD_VAR 0 1
19184: PPUSH
19185: EMPTY
19186: PPUSH
19187: CALL_OW 1
19191: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19192: LD_ADDR_EXP 80
19196: PUSH
19197: LD_EXP 80
19201: PPUSH
19202: LD_VAR 0 1
19206: PPUSH
19207: EMPTY
19208: PPUSH
19209: CALL_OW 1
19213: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19214: LD_ADDR_EXP 81
19218: PUSH
19219: LD_EXP 81
19223: PPUSH
19224: LD_VAR 0 1
19228: PPUSH
19229: EMPTY
19230: PPUSH
19231: CALL_OW 1
19235: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19236: LD_ADDR_EXP 82
19240: PUSH
19241: LD_EXP 82
19245: PPUSH
19246: LD_VAR 0 1
19250: PPUSH
19251: EMPTY
19252: PPUSH
19253: CALL_OW 1
19257: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19258: LD_ADDR_EXP 83
19262: PUSH
19263: LD_EXP 83
19267: PPUSH
19268: LD_VAR 0 1
19272: PPUSH
19273: EMPTY
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19280: LD_ADDR_EXP 84
19284: PUSH
19285: LD_EXP 84
19289: PPUSH
19290: LD_VAR 0 1
19294: PPUSH
19295: EMPTY
19296: PPUSH
19297: CALL_OW 1
19301: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19302: LD_ADDR_EXP 85
19306: PUSH
19307: LD_EXP 85
19311: PPUSH
19312: LD_VAR 0 1
19316: PPUSH
19317: EMPTY
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19324: LD_ADDR_EXP 86
19328: PUSH
19329: LD_EXP 86
19333: PPUSH
19334: LD_VAR 0 1
19338: PPUSH
19339: EMPTY
19340: PPUSH
19341: CALL_OW 1
19345: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19346: LD_ADDR_EXP 87
19350: PUSH
19351: LD_EXP 87
19355: PPUSH
19356: LD_VAR 0 1
19360: PPUSH
19361: EMPTY
19362: PPUSH
19363: CALL_OW 1
19367: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19368: LD_ADDR_EXP 88
19372: PUSH
19373: LD_EXP 88
19377: PPUSH
19378: LD_VAR 0 1
19382: PPUSH
19383: EMPTY
19384: PPUSH
19385: CALL_OW 1
19389: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19390: LD_ADDR_EXP 89
19394: PUSH
19395: LD_EXP 89
19399: PPUSH
19400: LD_VAR 0 1
19404: PPUSH
19405: EMPTY
19406: PPUSH
19407: CALL_OW 1
19411: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19412: LD_ADDR_EXP 90
19416: PUSH
19417: LD_EXP 90
19421: PPUSH
19422: LD_VAR 0 1
19426: PPUSH
19427: EMPTY
19428: PPUSH
19429: CALL_OW 1
19433: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19434: LD_ADDR_EXP 91
19438: PUSH
19439: LD_EXP 91
19443: PPUSH
19444: LD_VAR 0 1
19448: PPUSH
19449: EMPTY
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19456: LD_ADDR_EXP 92
19460: PUSH
19461: LD_EXP 92
19465: PPUSH
19466: LD_VAR 0 1
19470: PPUSH
19471: LD_INT 0
19473: PPUSH
19474: CALL_OW 1
19478: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19479: LD_ADDR_EXP 93
19483: PUSH
19484: LD_EXP 93
19488: PPUSH
19489: LD_VAR 0 1
19493: PPUSH
19494: LD_INT 0
19496: PPUSH
19497: CALL_OW 1
19501: ST_TO_ADDR
// end ;
19502: LD_VAR 0 2
19506: RET
// export function MC_Add ( side , units ) ; var base ; begin
19507: LD_INT 0
19509: PPUSH
19510: PPUSH
// base := mc_bases + 1 ;
19511: LD_ADDR_VAR 0 4
19515: PUSH
19516: LD_EXP 50
19520: PUSH
19521: LD_INT 1
19523: PLUS
19524: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19525: LD_ADDR_EXP 76
19529: PUSH
19530: LD_EXP 76
19534: PPUSH
19535: LD_VAR 0 4
19539: PPUSH
19540: LD_VAR 0 1
19544: PPUSH
19545: CALL_OW 1
19549: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19550: LD_ADDR_EXP 50
19554: PUSH
19555: LD_EXP 50
19559: PPUSH
19560: LD_VAR 0 4
19564: PPUSH
19565: LD_VAR 0 2
19569: PPUSH
19570: CALL_OW 1
19574: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19575: LD_ADDR_EXP 51
19579: PUSH
19580: LD_EXP 51
19584: PPUSH
19585: LD_VAR 0 4
19589: PPUSH
19590: EMPTY
19591: PPUSH
19592: CALL_OW 1
19596: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19597: LD_ADDR_EXP 52
19601: PUSH
19602: LD_EXP 52
19606: PPUSH
19607: LD_VAR 0 4
19611: PPUSH
19612: EMPTY
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19619: LD_ADDR_EXP 53
19623: PUSH
19624: LD_EXP 53
19628: PPUSH
19629: LD_VAR 0 4
19633: PPUSH
19634: EMPTY
19635: PPUSH
19636: CALL_OW 1
19640: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19641: LD_ADDR_EXP 54
19645: PUSH
19646: LD_EXP 54
19650: PPUSH
19651: LD_VAR 0 4
19655: PPUSH
19656: EMPTY
19657: PPUSH
19658: CALL_OW 1
19662: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19663: LD_ADDR_EXP 55
19667: PUSH
19668: LD_EXP 55
19672: PPUSH
19673: LD_VAR 0 4
19677: PPUSH
19678: EMPTY
19679: PPUSH
19680: CALL_OW 1
19684: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19685: LD_ADDR_EXP 56
19689: PUSH
19690: LD_EXP 56
19694: PPUSH
19695: LD_VAR 0 4
19699: PPUSH
19700: EMPTY
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19707: LD_ADDR_EXP 57
19711: PUSH
19712: LD_EXP 57
19716: PPUSH
19717: LD_VAR 0 4
19721: PPUSH
19722: EMPTY
19723: PPUSH
19724: CALL_OW 1
19728: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19729: LD_ADDR_EXP 58
19733: PUSH
19734: LD_EXP 58
19738: PPUSH
19739: LD_VAR 0 4
19743: PPUSH
19744: EMPTY
19745: PPUSH
19746: CALL_OW 1
19750: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19751: LD_ADDR_EXP 59
19755: PUSH
19756: LD_EXP 59
19760: PPUSH
19761: LD_VAR 0 4
19765: PPUSH
19766: EMPTY
19767: PPUSH
19768: CALL_OW 1
19772: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19773: LD_ADDR_EXP 60
19777: PUSH
19778: LD_EXP 60
19782: PPUSH
19783: LD_VAR 0 4
19787: PPUSH
19788: EMPTY
19789: PPUSH
19790: CALL_OW 1
19794: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19795: LD_ADDR_EXP 61
19799: PUSH
19800: LD_EXP 61
19804: PPUSH
19805: LD_VAR 0 4
19809: PPUSH
19810: LD_INT 0
19812: PPUSH
19813: CALL_OW 1
19817: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19818: LD_ADDR_EXP 62
19822: PUSH
19823: LD_EXP 62
19827: PPUSH
19828: LD_VAR 0 4
19832: PPUSH
19833: EMPTY
19834: PPUSH
19835: CALL_OW 1
19839: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19840: LD_ADDR_EXP 63
19844: PUSH
19845: LD_EXP 63
19849: PPUSH
19850: LD_VAR 0 4
19854: PPUSH
19855: EMPTY
19856: PPUSH
19857: CALL_OW 1
19861: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19862: LD_ADDR_EXP 64
19866: PUSH
19867: LD_EXP 64
19871: PPUSH
19872: LD_VAR 0 4
19876: PPUSH
19877: EMPTY
19878: PPUSH
19879: CALL_OW 1
19883: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19884: LD_ADDR_EXP 65
19888: PUSH
19889: LD_EXP 65
19893: PPUSH
19894: LD_VAR 0 4
19898: PPUSH
19899: EMPTY
19900: PPUSH
19901: CALL_OW 1
19905: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19906: LD_ADDR_EXP 66
19910: PUSH
19911: LD_EXP 66
19915: PPUSH
19916: LD_VAR 0 4
19920: PPUSH
19921: EMPTY
19922: PPUSH
19923: CALL_OW 1
19927: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19928: LD_ADDR_EXP 67
19932: PUSH
19933: LD_EXP 67
19937: PPUSH
19938: LD_VAR 0 4
19942: PPUSH
19943: EMPTY
19944: PPUSH
19945: CALL_OW 1
19949: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19950: LD_ADDR_EXP 68
19954: PUSH
19955: LD_EXP 68
19959: PPUSH
19960: LD_VAR 0 4
19964: PPUSH
19965: EMPTY
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19972: LD_ADDR_EXP 69
19976: PUSH
19977: LD_EXP 69
19981: PPUSH
19982: LD_VAR 0 4
19986: PPUSH
19987: EMPTY
19988: PPUSH
19989: CALL_OW 1
19993: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19994: LD_ADDR_EXP 70
19998: PUSH
19999: LD_EXP 70
20003: PPUSH
20004: LD_VAR 0 4
20008: PPUSH
20009: EMPTY
20010: PPUSH
20011: CALL_OW 1
20015: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20016: LD_ADDR_EXP 71
20020: PUSH
20021: LD_EXP 71
20025: PPUSH
20026: LD_VAR 0 4
20030: PPUSH
20031: EMPTY
20032: PPUSH
20033: CALL_OW 1
20037: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20038: LD_ADDR_EXP 72
20042: PUSH
20043: LD_EXP 72
20047: PPUSH
20048: LD_VAR 0 4
20052: PPUSH
20053: EMPTY
20054: PPUSH
20055: CALL_OW 1
20059: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20060: LD_ADDR_EXP 73
20064: PUSH
20065: LD_EXP 73
20069: PPUSH
20070: LD_VAR 0 4
20074: PPUSH
20075: EMPTY
20076: PPUSH
20077: CALL_OW 1
20081: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20082: LD_ADDR_EXP 74
20086: PUSH
20087: LD_EXP 74
20091: PPUSH
20092: LD_VAR 0 4
20096: PPUSH
20097: EMPTY
20098: PPUSH
20099: CALL_OW 1
20103: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20104: LD_ADDR_EXP 75
20108: PUSH
20109: LD_EXP 75
20113: PPUSH
20114: LD_VAR 0 4
20118: PPUSH
20119: EMPTY
20120: PPUSH
20121: CALL_OW 1
20125: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20126: LD_ADDR_EXP 77
20130: PUSH
20131: LD_EXP 77
20135: PPUSH
20136: LD_VAR 0 4
20140: PPUSH
20141: EMPTY
20142: PPUSH
20143: CALL_OW 1
20147: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20148: LD_ADDR_EXP 79
20152: PUSH
20153: LD_EXP 79
20157: PPUSH
20158: LD_VAR 0 4
20162: PPUSH
20163: EMPTY
20164: PPUSH
20165: CALL_OW 1
20169: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20170: LD_ADDR_EXP 80
20174: PUSH
20175: LD_EXP 80
20179: PPUSH
20180: LD_VAR 0 4
20184: PPUSH
20185: EMPTY
20186: PPUSH
20187: CALL_OW 1
20191: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20192: LD_ADDR_EXP 81
20196: PUSH
20197: LD_EXP 81
20201: PPUSH
20202: LD_VAR 0 4
20206: PPUSH
20207: EMPTY
20208: PPUSH
20209: CALL_OW 1
20213: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20214: LD_ADDR_EXP 82
20218: PUSH
20219: LD_EXP 82
20223: PPUSH
20224: LD_VAR 0 4
20228: PPUSH
20229: EMPTY
20230: PPUSH
20231: CALL_OW 1
20235: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20236: LD_ADDR_EXP 83
20240: PUSH
20241: LD_EXP 83
20245: PPUSH
20246: LD_VAR 0 4
20250: PPUSH
20251: EMPTY
20252: PPUSH
20253: CALL_OW 1
20257: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20258: LD_ADDR_EXP 84
20262: PUSH
20263: LD_EXP 84
20267: PPUSH
20268: LD_VAR 0 4
20272: PPUSH
20273: EMPTY
20274: PPUSH
20275: CALL_OW 1
20279: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20280: LD_ADDR_EXP 85
20284: PUSH
20285: LD_EXP 85
20289: PPUSH
20290: LD_VAR 0 4
20294: PPUSH
20295: EMPTY
20296: PPUSH
20297: CALL_OW 1
20301: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20302: LD_ADDR_EXP 86
20306: PUSH
20307: LD_EXP 86
20311: PPUSH
20312: LD_VAR 0 4
20316: PPUSH
20317: EMPTY
20318: PPUSH
20319: CALL_OW 1
20323: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20324: LD_ADDR_EXP 87
20328: PUSH
20329: LD_EXP 87
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: EMPTY
20340: PPUSH
20341: CALL_OW 1
20345: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20346: LD_ADDR_EXP 88
20350: PUSH
20351: LD_EXP 88
20355: PPUSH
20356: LD_VAR 0 4
20360: PPUSH
20361: EMPTY
20362: PPUSH
20363: CALL_OW 1
20367: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20368: LD_ADDR_EXP 89
20372: PUSH
20373: LD_EXP 89
20377: PPUSH
20378: LD_VAR 0 4
20382: PPUSH
20383: EMPTY
20384: PPUSH
20385: CALL_OW 1
20389: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20390: LD_ADDR_EXP 90
20394: PUSH
20395: LD_EXP 90
20399: PPUSH
20400: LD_VAR 0 4
20404: PPUSH
20405: EMPTY
20406: PPUSH
20407: CALL_OW 1
20411: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20412: LD_ADDR_EXP 91
20416: PUSH
20417: LD_EXP 91
20421: PPUSH
20422: LD_VAR 0 4
20426: PPUSH
20427: EMPTY
20428: PPUSH
20429: CALL_OW 1
20433: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20434: LD_ADDR_EXP 92
20438: PUSH
20439: LD_EXP 92
20443: PPUSH
20444: LD_VAR 0 4
20448: PPUSH
20449: LD_INT 0
20451: PPUSH
20452: CALL_OW 1
20456: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20457: LD_ADDR_EXP 93
20461: PUSH
20462: LD_EXP 93
20466: PPUSH
20467: LD_VAR 0 4
20471: PPUSH
20472: LD_INT 0
20474: PPUSH
20475: CALL_OW 1
20479: ST_TO_ADDR
// result := base ;
20480: LD_ADDR_VAR 0 3
20484: PUSH
20485: LD_VAR 0 4
20489: ST_TO_ADDR
// end ;
20490: LD_VAR 0 3
20494: RET
// export function MC_Start ( ) ; var i ; begin
20495: LD_INT 0
20497: PPUSH
20498: PPUSH
// for i = 1 to mc_bases do
20499: LD_ADDR_VAR 0 2
20503: PUSH
20504: DOUBLE
20505: LD_INT 1
20507: DEC
20508: ST_TO_ADDR
20509: LD_EXP 50
20513: PUSH
20514: FOR_TO
20515: IFFALSE 21615
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20517: LD_ADDR_EXP 50
20521: PUSH
20522: LD_EXP 50
20526: PPUSH
20527: LD_VAR 0 2
20531: PPUSH
20532: LD_EXP 50
20536: PUSH
20537: LD_VAR 0 2
20541: ARRAY
20542: PUSH
20543: LD_INT 0
20545: DIFF
20546: PPUSH
20547: CALL_OW 1
20551: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20552: LD_ADDR_EXP 51
20556: PUSH
20557: LD_EXP 51
20561: PPUSH
20562: LD_VAR 0 2
20566: PPUSH
20567: EMPTY
20568: PPUSH
20569: CALL_OW 1
20573: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20574: LD_ADDR_EXP 52
20578: PUSH
20579: LD_EXP 52
20583: PPUSH
20584: LD_VAR 0 2
20588: PPUSH
20589: EMPTY
20590: PPUSH
20591: CALL_OW 1
20595: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20596: LD_ADDR_EXP 53
20600: PUSH
20601: LD_EXP 53
20605: PPUSH
20606: LD_VAR 0 2
20610: PPUSH
20611: EMPTY
20612: PPUSH
20613: CALL_OW 1
20617: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20618: LD_ADDR_EXP 54
20622: PUSH
20623: LD_EXP 54
20627: PPUSH
20628: LD_VAR 0 2
20632: PPUSH
20633: EMPTY
20634: PUSH
20635: EMPTY
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: PPUSH
20641: CALL_OW 1
20645: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20646: LD_ADDR_EXP 55
20650: PUSH
20651: LD_EXP 55
20655: PPUSH
20656: LD_VAR 0 2
20660: PPUSH
20661: EMPTY
20662: PPUSH
20663: CALL_OW 1
20667: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20668: LD_ADDR_EXP 82
20672: PUSH
20673: LD_EXP 82
20677: PPUSH
20678: LD_VAR 0 2
20682: PPUSH
20683: EMPTY
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20690: LD_ADDR_EXP 56
20694: PUSH
20695: LD_EXP 56
20699: PPUSH
20700: LD_VAR 0 2
20704: PPUSH
20705: EMPTY
20706: PPUSH
20707: CALL_OW 1
20711: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20712: LD_ADDR_EXP 57
20716: PUSH
20717: LD_EXP 57
20721: PPUSH
20722: LD_VAR 0 2
20726: PPUSH
20727: EMPTY
20728: PPUSH
20729: CALL_OW 1
20733: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20734: LD_ADDR_EXP 58
20738: PUSH
20739: LD_EXP 58
20743: PPUSH
20744: LD_VAR 0 2
20748: PPUSH
20749: LD_EXP 50
20753: PUSH
20754: LD_VAR 0 2
20758: ARRAY
20759: PPUSH
20760: LD_INT 2
20762: PUSH
20763: LD_INT 30
20765: PUSH
20766: LD_INT 32
20768: PUSH
20769: EMPTY
20770: LIST
20771: LIST
20772: PUSH
20773: LD_INT 30
20775: PUSH
20776: LD_INT 33
20778: PUSH
20779: EMPTY
20780: LIST
20781: LIST
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: LIST
20787: PPUSH
20788: CALL_OW 72
20792: PPUSH
20793: CALL_OW 1
20797: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20798: LD_ADDR_EXP 59
20802: PUSH
20803: LD_EXP 59
20807: PPUSH
20808: LD_VAR 0 2
20812: PPUSH
20813: LD_EXP 50
20817: PUSH
20818: LD_VAR 0 2
20822: ARRAY
20823: PPUSH
20824: LD_INT 2
20826: PUSH
20827: LD_INT 30
20829: PUSH
20830: LD_INT 32
20832: PUSH
20833: EMPTY
20834: LIST
20835: LIST
20836: PUSH
20837: LD_INT 30
20839: PUSH
20840: LD_INT 31
20842: PUSH
20843: EMPTY
20844: LIST
20845: LIST
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: LIST
20851: PUSH
20852: LD_INT 58
20854: PUSH
20855: EMPTY
20856: LIST
20857: PUSH
20858: EMPTY
20859: LIST
20860: LIST
20861: PPUSH
20862: CALL_OW 72
20866: PPUSH
20867: CALL_OW 1
20871: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20872: LD_ADDR_EXP 60
20876: PUSH
20877: LD_EXP 60
20881: PPUSH
20882: LD_VAR 0 2
20886: PPUSH
20887: EMPTY
20888: PPUSH
20889: CALL_OW 1
20893: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20894: LD_ADDR_EXP 64
20898: PUSH
20899: LD_EXP 64
20903: PPUSH
20904: LD_VAR 0 2
20908: PPUSH
20909: EMPTY
20910: PPUSH
20911: CALL_OW 1
20915: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20916: LD_ADDR_EXP 63
20920: PUSH
20921: LD_EXP 63
20925: PPUSH
20926: LD_VAR 0 2
20930: PPUSH
20931: EMPTY
20932: PPUSH
20933: CALL_OW 1
20937: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20938: LD_ADDR_EXP 65
20942: PUSH
20943: LD_EXP 65
20947: PPUSH
20948: LD_VAR 0 2
20952: PPUSH
20953: EMPTY
20954: PPUSH
20955: CALL_OW 1
20959: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20960: LD_ADDR_EXP 66
20964: PUSH
20965: LD_EXP 66
20969: PPUSH
20970: LD_VAR 0 2
20974: PPUSH
20975: EMPTY
20976: PPUSH
20977: CALL_OW 1
20981: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20982: LD_ADDR_EXP 67
20986: PUSH
20987: LD_EXP 67
20991: PPUSH
20992: LD_VAR 0 2
20996: PPUSH
20997: EMPTY
20998: PPUSH
20999: CALL_OW 1
21003: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21004: LD_ADDR_EXP 68
21008: PUSH
21009: LD_EXP 68
21013: PPUSH
21014: LD_VAR 0 2
21018: PPUSH
21019: EMPTY
21020: PPUSH
21021: CALL_OW 1
21025: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21026: LD_ADDR_EXP 69
21030: PUSH
21031: LD_EXP 69
21035: PPUSH
21036: LD_VAR 0 2
21040: PPUSH
21041: EMPTY
21042: PPUSH
21043: CALL_OW 1
21047: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21048: LD_ADDR_EXP 70
21052: PUSH
21053: LD_EXP 70
21057: PPUSH
21058: LD_VAR 0 2
21062: PPUSH
21063: EMPTY
21064: PPUSH
21065: CALL_OW 1
21069: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21070: LD_ADDR_EXP 71
21074: PUSH
21075: LD_EXP 71
21079: PPUSH
21080: LD_VAR 0 2
21084: PPUSH
21085: EMPTY
21086: PPUSH
21087: CALL_OW 1
21091: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21092: LD_ADDR_EXP 72
21096: PUSH
21097: LD_EXP 72
21101: PPUSH
21102: LD_VAR 0 2
21106: PPUSH
21107: EMPTY
21108: PPUSH
21109: CALL_OW 1
21113: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21114: LD_ADDR_EXP 61
21118: PUSH
21119: LD_EXP 61
21123: PPUSH
21124: LD_VAR 0 2
21128: PPUSH
21129: LD_INT 0
21131: PPUSH
21132: CALL_OW 1
21136: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21137: LD_ADDR_EXP 74
21141: PUSH
21142: LD_EXP 74
21146: PPUSH
21147: LD_VAR 0 2
21151: PPUSH
21152: LD_INT 0
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21160: LD_ADDR_EXP 62
21164: PUSH
21165: LD_EXP 62
21169: PPUSH
21170: LD_VAR 0 2
21174: PPUSH
21175: EMPTY
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21182: LD_ADDR_EXP 73
21186: PUSH
21187: LD_EXP 73
21191: PPUSH
21192: LD_VAR 0 2
21196: PPUSH
21197: LD_INT 0
21199: PPUSH
21200: CALL_OW 1
21204: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21205: LD_ADDR_EXP 75
21209: PUSH
21210: LD_EXP 75
21214: PPUSH
21215: LD_VAR 0 2
21219: PPUSH
21220: EMPTY
21221: PPUSH
21222: CALL_OW 1
21226: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21227: LD_ADDR_EXP 78
21231: PUSH
21232: LD_EXP 78
21236: PPUSH
21237: LD_VAR 0 2
21241: PPUSH
21242: LD_INT 0
21244: PPUSH
21245: CALL_OW 1
21249: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21250: LD_ADDR_EXP 79
21254: PUSH
21255: LD_EXP 79
21259: PPUSH
21260: LD_VAR 0 2
21264: PPUSH
21265: EMPTY
21266: PPUSH
21267: CALL_OW 1
21271: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21272: LD_ADDR_EXP 80
21276: PUSH
21277: LD_EXP 80
21281: PPUSH
21282: LD_VAR 0 2
21286: PPUSH
21287: EMPTY
21288: PPUSH
21289: CALL_OW 1
21293: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21294: LD_ADDR_EXP 81
21298: PUSH
21299: LD_EXP 81
21303: PPUSH
21304: LD_VAR 0 2
21308: PPUSH
21309: EMPTY
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21316: LD_ADDR_EXP 83
21320: PUSH
21321: LD_EXP 83
21325: PPUSH
21326: LD_VAR 0 2
21330: PPUSH
21331: LD_EXP 50
21335: PUSH
21336: LD_VAR 0 2
21340: ARRAY
21341: PPUSH
21342: LD_INT 2
21344: PUSH
21345: LD_INT 30
21347: PUSH
21348: LD_INT 6
21350: PUSH
21351: EMPTY
21352: LIST
21353: LIST
21354: PUSH
21355: LD_INT 30
21357: PUSH
21358: LD_INT 7
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PUSH
21365: LD_INT 30
21367: PUSH
21368: LD_INT 8
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PUSH
21375: EMPTY
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: PPUSH
21381: CALL_OW 72
21385: PPUSH
21386: CALL_OW 1
21390: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21391: LD_ADDR_EXP 84
21395: PUSH
21396: LD_EXP 84
21400: PPUSH
21401: LD_VAR 0 2
21405: PPUSH
21406: EMPTY
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21413: LD_ADDR_EXP 85
21417: PUSH
21418: LD_EXP 85
21422: PPUSH
21423: LD_VAR 0 2
21427: PPUSH
21428: EMPTY
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21435: LD_ADDR_EXP 86
21439: PUSH
21440: LD_EXP 86
21444: PPUSH
21445: LD_VAR 0 2
21449: PPUSH
21450: EMPTY
21451: PPUSH
21452: CALL_OW 1
21456: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21457: LD_ADDR_EXP 87
21461: PUSH
21462: LD_EXP 87
21466: PPUSH
21467: LD_VAR 0 2
21471: PPUSH
21472: EMPTY
21473: PPUSH
21474: CALL_OW 1
21478: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21479: LD_ADDR_EXP 88
21483: PUSH
21484: LD_EXP 88
21488: PPUSH
21489: LD_VAR 0 2
21493: PPUSH
21494: EMPTY
21495: PPUSH
21496: CALL_OW 1
21500: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21501: LD_ADDR_EXP 89
21505: PUSH
21506: LD_EXP 89
21510: PPUSH
21511: LD_VAR 0 2
21515: PPUSH
21516: EMPTY
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21523: LD_ADDR_EXP 90
21527: PUSH
21528: LD_EXP 90
21532: PPUSH
21533: LD_VAR 0 2
21537: PPUSH
21538: EMPTY
21539: PPUSH
21540: CALL_OW 1
21544: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21545: LD_ADDR_EXP 91
21549: PUSH
21550: LD_EXP 91
21554: PPUSH
21555: LD_VAR 0 2
21559: PPUSH
21560: EMPTY
21561: PPUSH
21562: CALL_OW 1
21566: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21567: LD_ADDR_EXP 92
21571: PUSH
21572: LD_EXP 92
21576: PPUSH
21577: LD_VAR 0 2
21581: PPUSH
21582: LD_INT 0
21584: PPUSH
21585: CALL_OW 1
21589: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21590: LD_ADDR_EXP 93
21594: PUSH
21595: LD_EXP 93
21599: PPUSH
21600: LD_VAR 0 2
21604: PPUSH
21605: LD_INT 0
21607: PPUSH
21608: CALL_OW 1
21612: ST_TO_ADDR
// end ;
21613: GO 20514
21615: POP
21616: POP
// MC_InitSides ( ) ;
21617: CALL 21903 0 0
// MC_InitResearch ( ) ;
21621: CALL 21642 0 0
// CustomInitMacro ( ) ;
21625: CALL 304 0 0
// skirmish := true ;
21629: LD_ADDR_EXP 48
21633: PUSH
21634: LD_INT 1
21636: ST_TO_ADDR
// end ;
21637: LD_VAR 0 1
21641: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
21646: PPUSH
21647: PPUSH
21648: PPUSH
21649: PPUSH
// if not mc_bases then
21650: LD_EXP 50
21654: NOT
21655: IFFALSE 21659
// exit ;
21657: GO 21898
// for i = 1 to 8 do
21659: LD_ADDR_VAR 0 2
21663: PUSH
21664: DOUBLE
21665: LD_INT 1
21667: DEC
21668: ST_TO_ADDR
21669: LD_INT 8
21671: PUSH
21672: FOR_TO
21673: IFFALSE 21699
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21675: LD_ADDR_EXP 77
21679: PUSH
21680: LD_EXP 77
21684: PPUSH
21685: LD_VAR 0 2
21689: PPUSH
21690: EMPTY
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
21697: GO 21672
21699: POP
21700: POP
// tmp := [ ] ;
21701: LD_ADDR_VAR 0 5
21705: PUSH
21706: EMPTY
21707: ST_TO_ADDR
// for i = 1 to mc_sides do
21708: LD_ADDR_VAR 0 2
21712: PUSH
21713: DOUBLE
21714: LD_INT 1
21716: DEC
21717: ST_TO_ADDR
21718: LD_EXP 76
21722: PUSH
21723: FOR_TO
21724: IFFALSE 21782
// if not mc_sides [ i ] in tmp then
21726: LD_EXP 76
21730: PUSH
21731: LD_VAR 0 2
21735: ARRAY
21736: PUSH
21737: LD_VAR 0 5
21741: IN
21742: NOT
21743: IFFALSE 21780
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21745: LD_ADDR_VAR 0 5
21749: PUSH
21750: LD_VAR 0 5
21754: PPUSH
21755: LD_VAR 0 5
21759: PUSH
21760: LD_INT 1
21762: PLUS
21763: PPUSH
21764: LD_EXP 76
21768: PUSH
21769: LD_VAR 0 2
21773: ARRAY
21774: PPUSH
21775: CALL_OW 2
21779: ST_TO_ADDR
21780: GO 21723
21782: POP
21783: POP
// if not tmp then
21784: LD_VAR 0 5
21788: NOT
21789: IFFALSE 21793
// exit ;
21791: GO 21898
// for j in tmp do
21793: LD_ADDR_VAR 0 3
21797: PUSH
21798: LD_VAR 0 5
21802: PUSH
21803: FOR_IN
21804: IFFALSE 21896
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21806: LD_ADDR_VAR 0 6
21810: PUSH
21811: LD_INT 22
21813: PUSH
21814: LD_VAR 0 3
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 69
21827: ST_TO_ADDR
// if not un then
21828: LD_VAR 0 6
21832: NOT
21833: IFFALSE 21837
// continue ;
21835: GO 21803
// nation := GetNation ( un [ 1 ] ) ;
21837: LD_ADDR_VAR 0 4
21841: PUSH
21842: LD_VAR 0 6
21846: PUSH
21847: LD_INT 1
21849: ARRAY
21850: PPUSH
21851: CALL_OW 248
21855: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21856: LD_ADDR_EXP 77
21860: PUSH
21861: LD_EXP 77
21865: PPUSH
21866: LD_VAR 0 3
21870: PPUSH
21871: LD_VAR 0 3
21875: PPUSH
21876: LD_VAR 0 4
21880: PPUSH
21881: LD_INT 1
21883: PPUSH
21884: CALL 49088 0 3
21888: PPUSH
21889: CALL_OW 1
21893: ST_TO_ADDR
// end ;
21894: GO 21803
21896: POP
21897: POP
// end ;
21898: LD_VAR 0 1
21902: RET
// export function MC_InitSides ( ) ; var i ; begin
21903: LD_INT 0
21905: PPUSH
21906: PPUSH
// if not mc_bases then
21907: LD_EXP 50
21911: NOT
21912: IFFALSE 21916
// exit ;
21914: GO 21990
// for i = 1 to mc_bases do
21916: LD_ADDR_VAR 0 2
21920: PUSH
21921: DOUBLE
21922: LD_INT 1
21924: DEC
21925: ST_TO_ADDR
21926: LD_EXP 50
21930: PUSH
21931: FOR_TO
21932: IFFALSE 21988
// if mc_bases [ i ] then
21934: LD_EXP 50
21938: PUSH
21939: LD_VAR 0 2
21943: ARRAY
21944: IFFALSE 21986
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21946: LD_ADDR_EXP 76
21950: PUSH
21951: LD_EXP 76
21955: PPUSH
21956: LD_VAR 0 2
21960: PPUSH
21961: LD_EXP 50
21965: PUSH
21966: LD_VAR 0 2
21970: ARRAY
21971: PUSH
21972: LD_INT 1
21974: ARRAY
21975: PPUSH
21976: CALL_OW 255
21980: PPUSH
21981: CALL_OW 1
21985: ST_TO_ADDR
21986: GO 21931
21988: POP
21989: POP
// end ;
21990: LD_VAR 0 1
21994: RET
// every 0 0$03 trigger skirmish do
21995: LD_EXP 48
21999: IFFALSE 22153
22001: GO 22003
22003: DISABLE
// begin enable ;
22004: ENABLE
// MC_CheckBuildings ( ) ;
22005: CALL 26651 0 0
// MC_CheckPeopleLife ( ) ;
22009: CALL 26812 0 0
// RaiseSailEvent ( 100 ) ;
22013: LD_INT 100
22015: PPUSH
22016: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22020: LD_INT 103
22022: PPUSH
22023: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22027: LD_INT 104
22029: PPUSH
22030: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22034: LD_INT 105
22036: PPUSH
22037: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22041: LD_INT 106
22043: PPUSH
22044: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22048: LD_INT 107
22050: PPUSH
22051: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22055: LD_INT 108
22057: PPUSH
22058: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22062: LD_INT 109
22064: PPUSH
22065: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22069: LD_INT 110
22071: PPUSH
22072: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22076: LD_INT 111
22078: PPUSH
22079: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22083: LD_INT 112
22085: PPUSH
22086: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22090: LD_INT 113
22092: PPUSH
22093: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22097: LD_INT 120
22099: PPUSH
22100: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22104: LD_INT 121
22106: PPUSH
22107: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22111: LD_INT 122
22113: PPUSH
22114: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22118: LD_INT 123
22120: PPUSH
22121: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22125: LD_INT 124
22127: PPUSH
22128: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22132: LD_INT 125
22134: PPUSH
22135: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22139: LD_INT 126
22141: PPUSH
22142: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22146: LD_INT 200
22148: PPUSH
22149: CALL_OW 427
// end ;
22153: END
// on SailEvent ( event ) do begin if event < 100 then
22154: LD_VAR 0 1
22158: PUSH
22159: LD_INT 100
22161: LESS
22162: IFFALSE 22173
// CustomEvent ( event ) ;
22164: LD_VAR 0 1
22168: PPUSH
22169: CALL 17379 0 1
// if event = 100 then
22173: LD_VAR 0 1
22177: PUSH
22178: LD_INT 100
22180: EQUAL
22181: IFFALSE 22187
// MC_ClassManager ( ) ;
22183: CALL 22579 0 0
// if event = 101 then
22187: LD_VAR 0 1
22191: PUSH
22192: LD_INT 101
22194: EQUAL
22195: IFFALSE 22201
// MC_RepairBuildings ( ) ;
22197: CALL 27397 0 0
// if event = 102 then
22201: LD_VAR 0 1
22205: PUSH
22206: LD_INT 102
22208: EQUAL
22209: IFFALSE 22215
// MC_Heal ( ) ;
22211: CALL 28332 0 0
// if event = 103 then
22215: LD_VAR 0 1
22219: PUSH
22220: LD_INT 103
22222: EQUAL
22223: IFFALSE 22229
// MC_Build ( ) ;
22225: CALL 28754 0 0
// if event = 104 then
22229: LD_VAR 0 1
22233: PUSH
22234: LD_INT 104
22236: EQUAL
22237: IFFALSE 22243
// MC_TurretWeapon ( ) ;
22239: CALL 30388 0 0
// if event = 105 then
22243: LD_VAR 0 1
22247: PUSH
22248: LD_INT 105
22250: EQUAL
22251: IFFALSE 22257
// MC_BuildUpgrade ( ) ;
22253: CALL 29939 0 0
// if event = 106 then
22257: LD_VAR 0 1
22261: PUSH
22262: LD_INT 106
22264: EQUAL
22265: IFFALSE 22271
// MC_PlantMines ( ) ;
22267: CALL 30818 0 0
// if event = 107 then
22271: LD_VAR 0 1
22275: PUSH
22276: LD_INT 107
22278: EQUAL
22279: IFFALSE 22285
// MC_CollectCrates ( ) ;
22281: CALL 31609 0 0
// if event = 108 then
22285: LD_VAR 0 1
22289: PUSH
22290: LD_INT 108
22292: EQUAL
22293: IFFALSE 22299
// MC_LinkRemoteControl ( ) ;
22295: CALL 33459 0 0
// if event = 109 then
22299: LD_VAR 0 1
22303: PUSH
22304: LD_INT 109
22306: EQUAL
22307: IFFALSE 22313
// MC_ProduceVehicle ( ) ;
22309: CALL 33640 0 0
// if event = 110 then
22313: LD_VAR 0 1
22317: PUSH
22318: LD_INT 110
22320: EQUAL
22321: IFFALSE 22327
// MC_SendAttack ( ) ;
22323: CALL 34106 0 0
// if event = 111 then
22327: LD_VAR 0 1
22331: PUSH
22332: LD_INT 111
22334: EQUAL
22335: IFFALSE 22341
// MC_Defend ( ) ;
22337: CALL 34214 0 0
// if event = 112 then
22341: LD_VAR 0 1
22345: PUSH
22346: LD_INT 112
22348: EQUAL
22349: IFFALSE 22355
// MC_Research ( ) ;
22351: CALL 35094 0 0
// if event = 113 then
22355: LD_VAR 0 1
22359: PUSH
22360: LD_INT 113
22362: EQUAL
22363: IFFALSE 22369
// MC_MinesTrigger ( ) ;
22365: CALL 36208 0 0
// if event = 120 then
22369: LD_VAR 0 1
22373: PUSH
22374: LD_INT 120
22376: EQUAL
22377: IFFALSE 22383
// MC_RepairVehicle ( ) ;
22379: CALL 36307 0 0
// if event = 121 then
22383: LD_VAR 0 1
22387: PUSH
22388: LD_INT 121
22390: EQUAL
22391: IFFALSE 22397
// MC_TameApe ( ) ;
22393: CALL 37076 0 0
// if event = 122 then
22397: LD_VAR 0 1
22401: PUSH
22402: LD_INT 122
22404: EQUAL
22405: IFFALSE 22411
// MC_ChangeApeClass ( ) ;
22407: CALL 37905 0 0
// if event = 123 then
22411: LD_VAR 0 1
22415: PUSH
22416: LD_INT 123
22418: EQUAL
22419: IFFALSE 22425
// MC_Bazooka ( ) ;
22421: CALL 38555 0 0
// if event = 124 then
22425: LD_VAR 0 1
22429: PUSH
22430: LD_INT 124
22432: EQUAL
22433: IFFALSE 22439
// MC_TeleportExit ( ) ;
22435: CALL 38753 0 0
// if event = 125 then
22439: LD_VAR 0 1
22443: PUSH
22444: LD_INT 125
22446: EQUAL
22447: IFFALSE 22453
// MC_Deposits ( ) ;
22449: CALL 39400 0 0
// if event = 126 then
22453: LD_VAR 0 1
22457: PUSH
22458: LD_INT 126
22460: EQUAL
22461: IFFALSE 22467
// MC_RemoteDriver ( ) ;
22463: CALL 40025 0 0
// if event = 200 then
22467: LD_VAR 0 1
22471: PUSH
22472: LD_INT 200
22474: EQUAL
22475: IFFALSE 22481
// MC_Idle ( ) ;
22477: CALL 41974 0 0
// end ;
22481: PPOPN 1
22483: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22484: LD_INT 0
22486: PPUSH
22487: PPUSH
// if not mc_bases [ base ] or not tag then
22488: LD_EXP 50
22492: PUSH
22493: LD_VAR 0 1
22497: ARRAY
22498: NOT
22499: PUSH
22500: LD_VAR 0 2
22504: NOT
22505: OR
22506: IFFALSE 22510
// exit ;
22508: GO 22574
// for i in mc_bases [ base ] union mc_ape [ base ] do
22510: LD_ADDR_VAR 0 4
22514: PUSH
22515: LD_EXP 50
22519: PUSH
22520: LD_VAR 0 1
22524: ARRAY
22525: PUSH
22526: LD_EXP 79
22530: PUSH
22531: LD_VAR 0 1
22535: ARRAY
22536: UNION
22537: PUSH
22538: FOR_IN
22539: IFFALSE 22572
// if GetTag ( i ) = tag then
22541: LD_VAR 0 4
22545: PPUSH
22546: CALL_OW 110
22550: PUSH
22551: LD_VAR 0 2
22555: EQUAL
22556: IFFALSE 22570
// SetTag ( i , 0 ) ;
22558: LD_VAR 0 4
22562: PPUSH
22563: LD_INT 0
22565: PPUSH
22566: CALL_OW 109
22570: GO 22538
22572: POP
22573: POP
// end ;
22574: LD_VAR 0 3
22578: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22579: LD_INT 0
22581: PPUSH
22582: PPUSH
22583: PPUSH
22584: PPUSH
22585: PPUSH
22586: PPUSH
22587: PPUSH
22588: PPUSH
// if not mc_bases then
22589: LD_EXP 50
22593: NOT
22594: IFFALSE 22598
// exit ;
22596: GO 23056
// for i = 1 to mc_bases do
22598: LD_ADDR_VAR 0 2
22602: PUSH
22603: DOUBLE
22604: LD_INT 1
22606: DEC
22607: ST_TO_ADDR
22608: LD_EXP 50
22612: PUSH
22613: FOR_TO
22614: IFFALSE 23054
// begin tmp := MC_ClassCheckReq ( i ) ;
22616: LD_ADDR_VAR 0 4
22620: PUSH
22621: LD_VAR 0 2
22625: PPUSH
22626: CALL 23061 0 1
22630: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22631: LD_ADDR_EXP 91
22635: PUSH
22636: LD_EXP 91
22640: PPUSH
22641: LD_VAR 0 2
22645: PPUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// if not tmp then
22656: LD_VAR 0 4
22660: NOT
22661: IFFALSE 22665
// continue ;
22663: GO 22613
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22665: LD_ADDR_VAR 0 6
22669: PUSH
22670: LD_EXP 50
22674: PUSH
22675: LD_VAR 0 2
22679: ARRAY
22680: PPUSH
22681: LD_INT 2
22683: PUSH
22684: LD_INT 30
22686: PUSH
22687: LD_INT 4
22689: PUSH
22690: EMPTY
22691: LIST
22692: LIST
22693: PUSH
22694: LD_INT 30
22696: PUSH
22697: LD_INT 5
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: PUSH
22704: EMPTY
22705: LIST
22706: LIST
22707: LIST
22708: PPUSH
22709: CALL_OW 72
22713: PUSH
22714: LD_EXP 50
22718: PUSH
22719: LD_VAR 0 2
22723: ARRAY
22724: PPUSH
22725: LD_INT 2
22727: PUSH
22728: LD_INT 30
22730: PUSH
22731: LD_INT 0
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: PUSH
22738: LD_INT 30
22740: PUSH
22741: LD_INT 1
22743: PUSH
22744: EMPTY
22745: LIST
22746: LIST
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: LIST
22752: PPUSH
22753: CALL_OW 72
22757: PUSH
22758: LD_EXP 50
22762: PUSH
22763: LD_VAR 0 2
22767: ARRAY
22768: PPUSH
22769: LD_INT 30
22771: PUSH
22772: LD_INT 3
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: PPUSH
22779: CALL_OW 72
22783: PUSH
22784: LD_EXP 50
22788: PUSH
22789: LD_VAR 0 2
22793: ARRAY
22794: PPUSH
22795: LD_INT 2
22797: PUSH
22798: LD_INT 30
22800: PUSH
22801: LD_INT 6
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 30
22810: PUSH
22811: LD_INT 7
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: LD_INT 30
22820: PUSH
22821: LD_INT 8
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: PPUSH
22834: CALL_OW 72
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: ST_TO_ADDR
// for j = 1 to 4 do
22845: LD_ADDR_VAR 0 3
22849: PUSH
22850: DOUBLE
22851: LD_INT 1
22853: DEC
22854: ST_TO_ADDR
22855: LD_INT 4
22857: PUSH
22858: FOR_TO
22859: IFFALSE 23050
// begin if not tmp [ j ] then
22861: LD_VAR 0 4
22865: PUSH
22866: LD_VAR 0 3
22870: ARRAY
22871: NOT
22872: IFFALSE 22876
// continue ;
22874: GO 22858
// for p in tmp [ j ] do
22876: LD_ADDR_VAR 0 5
22880: PUSH
22881: LD_VAR 0 4
22885: PUSH
22886: LD_VAR 0 3
22890: ARRAY
22891: PUSH
22892: FOR_IN
22893: IFFALSE 23046
// begin if not b [ j ] then
22895: LD_VAR 0 6
22899: PUSH
22900: LD_VAR 0 3
22904: ARRAY
22905: NOT
22906: IFFALSE 22910
// break ;
22908: GO 23046
// e := 0 ;
22910: LD_ADDR_VAR 0 7
22914: PUSH
22915: LD_INT 0
22917: ST_TO_ADDR
// for k in b [ j ] do
22918: LD_ADDR_VAR 0 8
22922: PUSH
22923: LD_VAR 0 6
22927: PUSH
22928: LD_VAR 0 3
22932: ARRAY
22933: PUSH
22934: FOR_IN
22935: IFFALSE 22962
// if IsNotFull ( k ) then
22937: LD_VAR 0 8
22941: PPUSH
22942: CALL 51241 0 1
22946: IFFALSE 22960
// begin e := k ;
22948: LD_ADDR_VAR 0 7
22952: PUSH
22953: LD_VAR 0 8
22957: ST_TO_ADDR
// break ;
22958: GO 22962
// end ;
22960: GO 22934
22962: POP
22963: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22964: LD_VAR 0 7
22968: PUSH
22969: LD_VAR 0 5
22973: PPUSH
22974: LD_VAR 0 7
22978: PPUSH
22979: CALL 85137 0 2
22983: NOT
22984: AND
22985: IFFALSE 23044
// begin if IsInUnit ( p ) then
22987: LD_VAR 0 5
22991: PPUSH
22992: CALL_OW 310
22996: IFFALSE 23007
// ComExitBuilding ( p ) ;
22998: LD_VAR 0 5
23002: PPUSH
23003: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23007: LD_VAR 0 5
23011: PPUSH
23012: LD_VAR 0 7
23016: PPUSH
23017: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23021: LD_VAR 0 5
23025: PPUSH
23026: LD_VAR 0 3
23030: PPUSH
23031: CALL_OW 183
// AddComExitBuilding ( p ) ;
23035: LD_VAR 0 5
23039: PPUSH
23040: CALL_OW 182
// end ; end ;
23044: GO 22892
23046: POP
23047: POP
// end ;
23048: GO 22858
23050: POP
23051: POP
// end ;
23052: GO 22613
23054: POP
23055: POP
// end ;
23056: LD_VAR 0 1
23060: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23061: LD_INT 0
23063: PPUSH
23064: PPUSH
23065: PPUSH
23066: PPUSH
23067: PPUSH
23068: PPUSH
23069: PPUSH
23070: PPUSH
23071: PPUSH
23072: PPUSH
23073: PPUSH
23074: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23075: LD_VAR 0 1
23079: NOT
23080: PUSH
23081: LD_EXP 50
23085: PUSH
23086: LD_VAR 0 1
23090: ARRAY
23091: NOT
23092: OR
23093: PUSH
23094: LD_EXP 50
23098: PUSH
23099: LD_VAR 0 1
23103: ARRAY
23104: PPUSH
23105: LD_INT 2
23107: PUSH
23108: LD_INT 30
23110: PUSH
23111: LD_INT 0
23113: PUSH
23114: EMPTY
23115: LIST
23116: LIST
23117: PUSH
23118: LD_INT 30
23120: PUSH
23121: LD_INT 1
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: LIST
23132: PPUSH
23133: CALL_OW 72
23137: NOT
23138: OR
23139: IFFALSE 23143
// exit ;
23141: GO 26646
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23143: LD_ADDR_VAR 0 4
23147: PUSH
23148: LD_EXP 50
23152: PUSH
23153: LD_VAR 0 1
23157: ARRAY
23158: PPUSH
23159: LD_INT 2
23161: PUSH
23162: LD_INT 25
23164: PUSH
23165: LD_INT 1
23167: PUSH
23168: EMPTY
23169: LIST
23170: LIST
23171: PUSH
23172: LD_INT 25
23174: PUSH
23175: LD_INT 2
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: PUSH
23182: LD_INT 25
23184: PUSH
23185: LD_INT 3
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: PUSH
23192: LD_INT 25
23194: PUSH
23195: LD_INT 4
23197: PUSH
23198: EMPTY
23199: LIST
23200: LIST
23201: PUSH
23202: LD_INT 25
23204: PUSH
23205: LD_INT 5
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: PUSH
23212: LD_INT 25
23214: PUSH
23215: LD_INT 8
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: PUSH
23222: LD_INT 25
23224: PUSH
23225: LD_INT 9
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: PPUSH
23242: CALL_OW 72
23246: ST_TO_ADDR
// if not tmp then
23247: LD_VAR 0 4
23251: NOT
23252: IFFALSE 23256
// exit ;
23254: GO 26646
// for i in tmp do
23256: LD_ADDR_VAR 0 3
23260: PUSH
23261: LD_VAR 0 4
23265: PUSH
23266: FOR_IN
23267: IFFALSE 23298
// if GetTag ( i ) then
23269: LD_VAR 0 3
23273: PPUSH
23274: CALL_OW 110
23278: IFFALSE 23296
// tmp := tmp diff i ;
23280: LD_ADDR_VAR 0 4
23284: PUSH
23285: LD_VAR 0 4
23289: PUSH
23290: LD_VAR 0 3
23294: DIFF
23295: ST_TO_ADDR
23296: GO 23266
23298: POP
23299: POP
// if not tmp then
23300: LD_VAR 0 4
23304: NOT
23305: IFFALSE 23309
// exit ;
23307: GO 26646
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23309: LD_ADDR_VAR 0 5
23313: PUSH
23314: LD_EXP 50
23318: PUSH
23319: LD_VAR 0 1
23323: ARRAY
23324: PPUSH
23325: LD_INT 2
23327: PUSH
23328: LD_INT 25
23330: PUSH
23331: LD_INT 1
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: PUSH
23338: LD_INT 25
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 25
23350: PUSH
23351: LD_INT 8
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 25
23360: PUSH
23361: LD_INT 9
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: EMPTY
23369: LIST
23370: LIST
23371: LIST
23372: LIST
23373: LIST
23374: PPUSH
23375: CALL_OW 72
23379: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23380: LD_ADDR_VAR 0 6
23384: PUSH
23385: LD_EXP 50
23389: PUSH
23390: LD_VAR 0 1
23394: ARRAY
23395: PPUSH
23396: LD_INT 25
23398: PUSH
23399: LD_INT 2
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PPUSH
23406: CALL_OW 72
23410: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23411: LD_ADDR_VAR 0 7
23415: PUSH
23416: LD_EXP 50
23420: PUSH
23421: LD_VAR 0 1
23425: ARRAY
23426: PPUSH
23427: LD_INT 25
23429: PUSH
23430: LD_INT 3
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PPUSH
23437: CALL_OW 72
23441: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23442: LD_ADDR_VAR 0 8
23446: PUSH
23447: LD_EXP 50
23451: PUSH
23452: LD_VAR 0 1
23456: ARRAY
23457: PPUSH
23458: LD_INT 25
23460: PUSH
23461: LD_INT 4
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: LD_INT 24
23470: PUSH
23471: LD_INT 251
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: PPUSH
23482: CALL_OW 72
23486: ST_TO_ADDR
// if mc_is_defending [ base ] then
23487: LD_EXP 93
23491: PUSH
23492: LD_VAR 0 1
23496: ARRAY
23497: IFFALSE 23958
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23499: LD_ADDR_EXP 92
23503: PUSH
23504: LD_EXP 92
23508: PPUSH
23509: LD_VAR 0 1
23513: PPUSH
23514: LD_INT 4
23516: PPUSH
23517: CALL_OW 1
23521: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23522: LD_ADDR_VAR 0 12
23526: PUSH
23527: LD_EXP 50
23531: PUSH
23532: LD_VAR 0 1
23536: ARRAY
23537: PPUSH
23538: LD_INT 2
23540: PUSH
23541: LD_INT 30
23543: PUSH
23544: LD_INT 4
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: PUSH
23551: LD_INT 30
23553: PUSH
23554: LD_INT 5
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 72
23570: ST_TO_ADDR
// if not b then
23571: LD_VAR 0 12
23575: NOT
23576: IFFALSE 23580
// exit ;
23578: GO 26646
// p := [ ] ;
23580: LD_ADDR_VAR 0 11
23584: PUSH
23585: EMPTY
23586: ST_TO_ADDR
// if sci >= 2 then
23587: LD_VAR 0 8
23591: PUSH
23592: LD_INT 2
23594: GREATEREQUAL
23595: IFFALSE 23626
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23597: LD_ADDR_VAR 0 8
23601: PUSH
23602: LD_VAR 0 8
23606: PUSH
23607: LD_INT 1
23609: ARRAY
23610: PUSH
23611: LD_VAR 0 8
23615: PUSH
23616: LD_INT 2
23618: ARRAY
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: ST_TO_ADDR
23624: GO 23687
// if sci = 1 then
23626: LD_VAR 0 8
23630: PUSH
23631: LD_INT 1
23633: EQUAL
23634: IFFALSE 23655
// sci := [ sci [ 1 ] ] else
23636: LD_ADDR_VAR 0 8
23640: PUSH
23641: LD_VAR 0 8
23645: PUSH
23646: LD_INT 1
23648: ARRAY
23649: PUSH
23650: EMPTY
23651: LIST
23652: ST_TO_ADDR
23653: GO 23687
// if sci = 0 then
23655: LD_VAR 0 8
23659: PUSH
23660: LD_INT 0
23662: EQUAL
23663: IFFALSE 23687
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23665: LD_ADDR_VAR 0 11
23669: PUSH
23670: LD_VAR 0 4
23674: PPUSH
23675: LD_INT 4
23677: PPUSH
23678: CALL 85009 0 2
23682: PUSH
23683: LD_INT 1
23685: ARRAY
23686: ST_TO_ADDR
// if eng > 4 then
23687: LD_VAR 0 6
23691: PUSH
23692: LD_INT 4
23694: GREATER
23695: IFFALSE 23741
// for i = eng downto 4 do
23697: LD_ADDR_VAR 0 3
23701: PUSH
23702: DOUBLE
23703: LD_VAR 0 6
23707: INC
23708: ST_TO_ADDR
23709: LD_INT 4
23711: PUSH
23712: FOR_DOWNTO
23713: IFFALSE 23739
// eng := eng diff eng [ i ] ;
23715: LD_ADDR_VAR 0 6
23719: PUSH
23720: LD_VAR 0 6
23724: PUSH
23725: LD_VAR 0 6
23729: PUSH
23730: LD_VAR 0 3
23734: ARRAY
23735: DIFF
23736: ST_TO_ADDR
23737: GO 23712
23739: POP
23740: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23741: LD_ADDR_VAR 0 4
23745: PUSH
23746: LD_VAR 0 4
23750: PUSH
23751: LD_VAR 0 5
23755: PUSH
23756: LD_VAR 0 6
23760: UNION
23761: PUSH
23762: LD_VAR 0 7
23766: UNION
23767: PUSH
23768: LD_VAR 0 8
23772: UNION
23773: DIFF
23774: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23775: LD_ADDR_VAR 0 13
23779: PUSH
23780: LD_EXP 50
23784: PUSH
23785: LD_VAR 0 1
23789: ARRAY
23790: PPUSH
23791: LD_INT 2
23793: PUSH
23794: LD_INT 30
23796: PUSH
23797: LD_INT 32
23799: PUSH
23800: EMPTY
23801: LIST
23802: LIST
23803: PUSH
23804: LD_INT 30
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: LIST
23818: PPUSH
23819: CALL_OW 72
23823: PUSH
23824: LD_EXP 50
23828: PUSH
23829: LD_VAR 0 1
23833: ARRAY
23834: PPUSH
23835: LD_INT 2
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: LD_INT 4
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 30
23850: PUSH
23851: LD_INT 5
23853: PUSH
23854: EMPTY
23855: LIST
23856: LIST
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: LIST
23862: PPUSH
23863: CALL_OW 72
23867: PUSH
23868: LD_INT 6
23870: MUL
23871: PLUS
23872: ST_TO_ADDR
// if bcount < tmp then
23873: LD_VAR 0 13
23877: PUSH
23878: LD_VAR 0 4
23882: LESS
23883: IFFALSE 23929
// for i = tmp downto bcount do
23885: LD_ADDR_VAR 0 3
23889: PUSH
23890: DOUBLE
23891: LD_VAR 0 4
23895: INC
23896: ST_TO_ADDR
23897: LD_VAR 0 13
23901: PUSH
23902: FOR_DOWNTO
23903: IFFALSE 23927
// tmp := Delete ( tmp , tmp ) ;
23905: LD_ADDR_VAR 0 4
23909: PUSH
23910: LD_VAR 0 4
23914: PPUSH
23915: LD_VAR 0 4
23919: PPUSH
23920: CALL_OW 3
23924: ST_TO_ADDR
23925: GO 23902
23927: POP
23928: POP
// result := [ tmp , 0 , 0 , p ] ;
23929: LD_ADDR_VAR 0 2
23933: PUSH
23934: LD_VAR 0 4
23938: PUSH
23939: LD_INT 0
23941: PUSH
23942: LD_INT 0
23944: PUSH
23945: LD_VAR 0 11
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// exit ;
23956: GO 26646
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23958: LD_EXP 50
23962: PUSH
23963: LD_VAR 0 1
23967: ARRAY
23968: PPUSH
23969: LD_INT 2
23971: PUSH
23972: LD_INT 30
23974: PUSH
23975: LD_INT 6
23977: PUSH
23978: EMPTY
23979: LIST
23980: LIST
23981: PUSH
23982: LD_INT 30
23984: PUSH
23985: LD_INT 7
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PUSH
23992: LD_INT 30
23994: PUSH
23995: LD_INT 8
23997: PUSH
23998: EMPTY
23999: LIST
24000: LIST
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: LIST
24006: LIST
24007: PPUSH
24008: CALL_OW 72
24012: NOT
24013: PUSH
24014: LD_EXP 50
24018: PUSH
24019: LD_VAR 0 1
24023: ARRAY
24024: PPUSH
24025: LD_INT 30
24027: PUSH
24028: LD_INT 3
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: PPUSH
24035: CALL_OW 72
24039: NOT
24040: AND
24041: IFFALSE 24113
// begin if eng = tmp then
24043: LD_VAR 0 6
24047: PUSH
24048: LD_VAR 0 4
24052: EQUAL
24053: IFFALSE 24057
// exit ;
24055: GO 26646
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24057: LD_ADDR_EXP 92
24061: PUSH
24062: LD_EXP 92
24066: PPUSH
24067: LD_VAR 0 1
24071: PPUSH
24072: LD_INT 1
24074: PPUSH
24075: CALL_OW 1
24079: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24080: LD_ADDR_VAR 0 2
24084: PUSH
24085: LD_INT 0
24087: PUSH
24088: LD_VAR 0 4
24092: PUSH
24093: LD_VAR 0 6
24097: DIFF
24098: PUSH
24099: LD_INT 0
24101: PUSH
24102: LD_INT 0
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: LIST
24109: LIST
24110: ST_TO_ADDR
// exit ;
24111: GO 26646
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24113: LD_EXP 77
24117: PUSH
24118: LD_EXP 76
24122: PUSH
24123: LD_VAR 0 1
24127: ARRAY
24128: ARRAY
24129: PUSH
24130: LD_EXP 50
24134: PUSH
24135: LD_VAR 0 1
24139: ARRAY
24140: PPUSH
24141: LD_INT 2
24143: PUSH
24144: LD_INT 30
24146: PUSH
24147: LD_INT 6
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 30
24156: PUSH
24157: LD_INT 7
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: LD_INT 30
24166: PUSH
24167: LD_INT 8
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 72
24184: AND
24185: PUSH
24186: LD_EXP 50
24190: PUSH
24191: LD_VAR 0 1
24195: ARRAY
24196: PPUSH
24197: LD_INT 30
24199: PUSH
24200: LD_INT 3
24202: PUSH
24203: EMPTY
24204: LIST
24205: LIST
24206: PPUSH
24207: CALL_OW 72
24211: NOT
24212: AND
24213: IFFALSE 24427
// begin if sci >= 6 then
24215: LD_VAR 0 8
24219: PUSH
24220: LD_INT 6
24222: GREATEREQUAL
24223: IFFALSE 24227
// exit ;
24225: GO 26646
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24227: LD_ADDR_EXP 92
24231: PUSH
24232: LD_EXP 92
24236: PPUSH
24237: LD_VAR 0 1
24241: PPUSH
24242: LD_INT 2
24244: PPUSH
24245: CALL_OW 1
24249: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24250: LD_ADDR_VAR 0 9
24254: PUSH
24255: LD_VAR 0 4
24259: PUSH
24260: LD_VAR 0 8
24264: DIFF
24265: PPUSH
24266: LD_INT 4
24268: PPUSH
24269: CALL 85009 0 2
24273: ST_TO_ADDR
// p := [ ] ;
24274: LD_ADDR_VAR 0 11
24278: PUSH
24279: EMPTY
24280: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24281: LD_VAR 0 8
24285: PUSH
24286: LD_INT 6
24288: LESS
24289: PUSH
24290: LD_VAR 0 9
24294: PUSH
24295: LD_INT 6
24297: GREATER
24298: AND
24299: IFFALSE 24380
// begin for i = 1 to 6 - sci do
24301: LD_ADDR_VAR 0 3
24305: PUSH
24306: DOUBLE
24307: LD_INT 1
24309: DEC
24310: ST_TO_ADDR
24311: LD_INT 6
24313: PUSH
24314: LD_VAR 0 8
24318: MINUS
24319: PUSH
24320: FOR_TO
24321: IFFALSE 24376
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24323: LD_ADDR_VAR 0 11
24327: PUSH
24328: LD_VAR 0 11
24332: PPUSH
24333: LD_VAR 0 11
24337: PUSH
24338: LD_INT 1
24340: PLUS
24341: PPUSH
24342: LD_VAR 0 9
24346: PUSH
24347: LD_INT 1
24349: ARRAY
24350: PPUSH
24351: CALL_OW 2
24355: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_VAR 0 9
24365: PPUSH
24366: LD_INT 1
24368: PPUSH
24369: CALL_OW 3
24373: ST_TO_ADDR
// end ;
24374: GO 24320
24376: POP
24377: POP
// end else
24378: GO 24400
// if sort then
24380: LD_VAR 0 9
24384: IFFALSE 24400
// p := sort [ 1 ] ;
24386: LD_ADDR_VAR 0 11
24390: PUSH
24391: LD_VAR 0 9
24395: PUSH
24396: LD_INT 1
24398: ARRAY
24399: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24400: LD_ADDR_VAR 0 2
24404: PUSH
24405: LD_INT 0
24407: PUSH
24408: LD_INT 0
24410: PUSH
24411: LD_INT 0
24413: PUSH
24414: LD_VAR 0 11
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: LIST
24423: LIST
24424: ST_TO_ADDR
// exit ;
24425: GO 26646
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24427: LD_EXP 77
24431: PUSH
24432: LD_EXP 76
24436: PUSH
24437: LD_VAR 0 1
24441: ARRAY
24442: ARRAY
24443: PUSH
24444: LD_EXP 50
24448: PUSH
24449: LD_VAR 0 1
24453: ARRAY
24454: PPUSH
24455: LD_INT 2
24457: PUSH
24458: LD_INT 30
24460: PUSH
24461: LD_INT 6
24463: PUSH
24464: EMPTY
24465: LIST
24466: LIST
24467: PUSH
24468: LD_INT 30
24470: PUSH
24471: LD_INT 7
24473: PUSH
24474: EMPTY
24475: LIST
24476: LIST
24477: PUSH
24478: LD_INT 30
24480: PUSH
24481: LD_INT 8
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: PPUSH
24494: CALL_OW 72
24498: AND
24499: PUSH
24500: LD_EXP 50
24504: PUSH
24505: LD_VAR 0 1
24509: ARRAY
24510: PPUSH
24511: LD_INT 30
24513: PUSH
24514: LD_INT 3
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PPUSH
24521: CALL_OW 72
24525: AND
24526: IFFALSE 25260
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24528: LD_ADDR_EXP 92
24532: PUSH
24533: LD_EXP 92
24537: PPUSH
24538: LD_VAR 0 1
24542: PPUSH
24543: LD_INT 3
24545: PPUSH
24546: CALL_OW 1
24550: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24551: LD_ADDR_VAR 0 2
24555: PUSH
24556: LD_INT 0
24558: PUSH
24559: LD_INT 0
24561: PUSH
24562: LD_INT 0
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: EMPTY
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: ST_TO_ADDR
// if not eng then
24574: LD_VAR 0 6
24578: NOT
24579: IFFALSE 24642
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24581: LD_ADDR_VAR 0 11
24585: PUSH
24586: LD_VAR 0 4
24590: PPUSH
24591: LD_INT 2
24593: PPUSH
24594: CALL 85009 0 2
24598: PUSH
24599: LD_INT 1
24601: ARRAY
24602: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24603: LD_ADDR_VAR 0 2
24607: PUSH
24608: LD_VAR 0 2
24612: PPUSH
24613: LD_INT 2
24615: PPUSH
24616: LD_VAR 0 11
24620: PPUSH
24621: CALL_OW 1
24625: ST_TO_ADDR
// tmp := tmp diff p ;
24626: LD_ADDR_VAR 0 4
24630: PUSH
24631: LD_VAR 0 4
24635: PUSH
24636: LD_VAR 0 11
24640: DIFF
24641: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24642: LD_VAR 0 4
24646: PUSH
24647: LD_VAR 0 8
24651: PUSH
24652: LD_INT 6
24654: LESS
24655: AND
24656: IFFALSE 24844
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24658: LD_ADDR_VAR 0 9
24662: PUSH
24663: LD_VAR 0 4
24667: PUSH
24668: LD_VAR 0 8
24672: PUSH
24673: LD_VAR 0 7
24677: UNION
24678: DIFF
24679: PPUSH
24680: LD_INT 4
24682: PPUSH
24683: CALL 85009 0 2
24687: ST_TO_ADDR
// p := [ ] ;
24688: LD_ADDR_VAR 0 11
24692: PUSH
24693: EMPTY
24694: ST_TO_ADDR
// if sort then
24695: LD_VAR 0 9
24699: IFFALSE 24815
// for i = 1 to 6 - sci do
24701: LD_ADDR_VAR 0 3
24705: PUSH
24706: DOUBLE
24707: LD_INT 1
24709: DEC
24710: ST_TO_ADDR
24711: LD_INT 6
24713: PUSH
24714: LD_VAR 0 8
24718: MINUS
24719: PUSH
24720: FOR_TO
24721: IFFALSE 24813
// begin if i = sort then
24723: LD_VAR 0 3
24727: PUSH
24728: LD_VAR 0 9
24732: EQUAL
24733: IFFALSE 24737
// break ;
24735: GO 24813
// if GetClass ( i ) = 4 then
24737: LD_VAR 0 3
24741: PPUSH
24742: CALL_OW 257
24746: PUSH
24747: LD_INT 4
24749: EQUAL
24750: IFFALSE 24754
// continue ;
24752: GO 24720
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24754: LD_ADDR_VAR 0 11
24758: PUSH
24759: LD_VAR 0 11
24763: PPUSH
24764: LD_VAR 0 11
24768: PUSH
24769: LD_INT 1
24771: PLUS
24772: PPUSH
24773: LD_VAR 0 9
24777: PUSH
24778: LD_VAR 0 3
24782: ARRAY
24783: PPUSH
24784: CALL_OW 2
24788: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24789: LD_ADDR_VAR 0 4
24793: PUSH
24794: LD_VAR 0 4
24798: PUSH
24799: LD_VAR 0 9
24803: PUSH
24804: LD_VAR 0 3
24808: ARRAY
24809: DIFF
24810: ST_TO_ADDR
// end ;
24811: GO 24720
24813: POP
24814: POP
// if p then
24815: LD_VAR 0 11
24819: IFFALSE 24844
// result := Replace ( result , 4 , p ) ;
24821: LD_ADDR_VAR 0 2
24825: PUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: LD_INT 4
24833: PPUSH
24834: LD_VAR 0 11
24838: PPUSH
24839: CALL_OW 1
24843: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24844: LD_VAR 0 4
24848: PUSH
24849: LD_VAR 0 7
24853: PUSH
24854: LD_INT 6
24856: LESS
24857: AND
24858: IFFALSE 25046
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24860: LD_ADDR_VAR 0 9
24864: PUSH
24865: LD_VAR 0 4
24869: PUSH
24870: LD_VAR 0 8
24874: PUSH
24875: LD_VAR 0 7
24879: UNION
24880: DIFF
24881: PPUSH
24882: LD_INT 3
24884: PPUSH
24885: CALL 85009 0 2
24889: ST_TO_ADDR
// p := [ ] ;
24890: LD_ADDR_VAR 0 11
24894: PUSH
24895: EMPTY
24896: ST_TO_ADDR
// if sort then
24897: LD_VAR 0 9
24901: IFFALSE 25017
// for i = 1 to 6 - mech do
24903: LD_ADDR_VAR 0 3
24907: PUSH
24908: DOUBLE
24909: LD_INT 1
24911: DEC
24912: ST_TO_ADDR
24913: LD_INT 6
24915: PUSH
24916: LD_VAR 0 7
24920: MINUS
24921: PUSH
24922: FOR_TO
24923: IFFALSE 25015
// begin if i = sort then
24925: LD_VAR 0 3
24929: PUSH
24930: LD_VAR 0 9
24934: EQUAL
24935: IFFALSE 24939
// break ;
24937: GO 25015
// if GetClass ( i ) = 3 then
24939: LD_VAR 0 3
24943: PPUSH
24944: CALL_OW 257
24948: PUSH
24949: LD_INT 3
24951: EQUAL
24952: IFFALSE 24956
// continue ;
24954: GO 24922
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24956: LD_ADDR_VAR 0 11
24960: PUSH
24961: LD_VAR 0 11
24965: PPUSH
24966: LD_VAR 0 11
24970: PUSH
24971: LD_INT 1
24973: PLUS
24974: PPUSH
24975: LD_VAR 0 9
24979: PUSH
24980: LD_VAR 0 3
24984: ARRAY
24985: PPUSH
24986: CALL_OW 2
24990: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24991: LD_ADDR_VAR 0 4
24995: PUSH
24996: LD_VAR 0 4
25000: PUSH
25001: LD_VAR 0 9
25005: PUSH
25006: LD_VAR 0 3
25010: ARRAY
25011: DIFF
25012: ST_TO_ADDR
// end ;
25013: GO 24922
25015: POP
25016: POP
// if p then
25017: LD_VAR 0 11
25021: IFFALSE 25046
// result := Replace ( result , 3 , p ) ;
25023: LD_ADDR_VAR 0 2
25027: PUSH
25028: LD_VAR 0 2
25032: PPUSH
25033: LD_INT 3
25035: PPUSH
25036: LD_VAR 0 11
25040: PPUSH
25041: CALL_OW 1
25045: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25046: LD_VAR 0 4
25050: PUSH
25051: LD_INT 6
25053: GREATER
25054: PUSH
25055: LD_VAR 0 6
25059: PUSH
25060: LD_INT 6
25062: LESS
25063: AND
25064: IFFALSE 25258
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25066: LD_ADDR_VAR 0 9
25070: PUSH
25071: LD_VAR 0 4
25075: PUSH
25076: LD_VAR 0 8
25080: PUSH
25081: LD_VAR 0 7
25085: UNION
25086: PUSH
25087: LD_VAR 0 6
25091: UNION
25092: DIFF
25093: PPUSH
25094: LD_INT 2
25096: PPUSH
25097: CALL 85009 0 2
25101: ST_TO_ADDR
// p := [ ] ;
25102: LD_ADDR_VAR 0 11
25106: PUSH
25107: EMPTY
25108: ST_TO_ADDR
// if sort then
25109: LD_VAR 0 9
25113: IFFALSE 25229
// for i = 1 to 6 - eng do
25115: LD_ADDR_VAR 0 3
25119: PUSH
25120: DOUBLE
25121: LD_INT 1
25123: DEC
25124: ST_TO_ADDR
25125: LD_INT 6
25127: PUSH
25128: LD_VAR 0 6
25132: MINUS
25133: PUSH
25134: FOR_TO
25135: IFFALSE 25227
// begin if i = sort then
25137: LD_VAR 0 3
25141: PUSH
25142: LD_VAR 0 9
25146: EQUAL
25147: IFFALSE 25151
// break ;
25149: GO 25227
// if GetClass ( i ) = 2 then
25151: LD_VAR 0 3
25155: PPUSH
25156: CALL_OW 257
25160: PUSH
25161: LD_INT 2
25163: EQUAL
25164: IFFALSE 25168
// continue ;
25166: GO 25134
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25168: LD_ADDR_VAR 0 11
25172: PUSH
25173: LD_VAR 0 11
25177: PPUSH
25178: LD_VAR 0 11
25182: PUSH
25183: LD_INT 1
25185: PLUS
25186: PPUSH
25187: LD_VAR 0 9
25191: PUSH
25192: LD_VAR 0 3
25196: ARRAY
25197: PPUSH
25198: CALL_OW 2
25202: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25203: LD_ADDR_VAR 0 4
25207: PUSH
25208: LD_VAR 0 4
25212: PUSH
25213: LD_VAR 0 9
25217: PUSH
25218: LD_VAR 0 3
25222: ARRAY
25223: DIFF
25224: ST_TO_ADDR
// end ;
25225: GO 25134
25227: POP
25228: POP
// if p then
25229: LD_VAR 0 11
25233: IFFALSE 25258
// result := Replace ( result , 2 , p ) ;
25235: LD_ADDR_VAR 0 2
25239: PUSH
25240: LD_VAR 0 2
25244: PPUSH
25245: LD_INT 2
25247: PPUSH
25248: LD_VAR 0 11
25252: PPUSH
25253: CALL_OW 1
25257: ST_TO_ADDR
// end ; exit ;
25258: GO 26646
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25260: LD_EXP 77
25264: PUSH
25265: LD_EXP 76
25269: PUSH
25270: LD_VAR 0 1
25274: ARRAY
25275: ARRAY
25276: NOT
25277: PUSH
25278: LD_EXP 50
25282: PUSH
25283: LD_VAR 0 1
25287: ARRAY
25288: PPUSH
25289: LD_INT 30
25291: PUSH
25292: LD_INT 3
25294: PUSH
25295: EMPTY
25296: LIST
25297: LIST
25298: PPUSH
25299: CALL_OW 72
25303: AND
25304: PUSH
25305: LD_EXP 55
25309: PUSH
25310: LD_VAR 0 1
25314: ARRAY
25315: AND
25316: IFFALSE 25924
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25318: LD_ADDR_EXP 92
25322: PUSH
25323: LD_EXP 92
25327: PPUSH
25328: LD_VAR 0 1
25332: PPUSH
25333: LD_INT 5
25335: PPUSH
25336: CALL_OW 1
25340: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25341: LD_ADDR_VAR 0 2
25345: PUSH
25346: LD_INT 0
25348: PUSH
25349: LD_INT 0
25351: PUSH
25352: LD_INT 0
25354: PUSH
25355: LD_INT 0
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: LIST
25362: LIST
25363: ST_TO_ADDR
// if sci > 1 then
25364: LD_VAR 0 8
25368: PUSH
25369: LD_INT 1
25371: GREATER
25372: IFFALSE 25400
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25374: LD_ADDR_VAR 0 4
25378: PUSH
25379: LD_VAR 0 4
25383: PUSH
25384: LD_VAR 0 8
25388: PUSH
25389: LD_VAR 0 8
25393: PUSH
25394: LD_INT 1
25396: ARRAY
25397: DIFF
25398: DIFF
25399: ST_TO_ADDR
// if tmp and not sci then
25400: LD_VAR 0 4
25404: PUSH
25405: LD_VAR 0 8
25409: NOT
25410: AND
25411: IFFALSE 25480
// begin sort := SortBySkill ( tmp , 4 ) ;
25413: LD_ADDR_VAR 0 9
25417: PUSH
25418: LD_VAR 0 4
25422: PPUSH
25423: LD_INT 4
25425: PPUSH
25426: CALL 85009 0 2
25430: ST_TO_ADDR
// if sort then
25431: LD_VAR 0 9
25435: IFFALSE 25451
// p := sort [ 1 ] ;
25437: LD_ADDR_VAR 0 11
25441: PUSH
25442: LD_VAR 0 9
25446: PUSH
25447: LD_INT 1
25449: ARRAY
25450: ST_TO_ADDR
// if p then
25451: LD_VAR 0 11
25455: IFFALSE 25480
// result := Replace ( result , 4 , p ) ;
25457: LD_ADDR_VAR 0 2
25461: PUSH
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 4
25469: PPUSH
25470: LD_VAR 0 11
25474: PPUSH
25475: CALL_OW 1
25479: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25480: LD_ADDR_VAR 0 4
25484: PUSH
25485: LD_VAR 0 4
25489: PUSH
25490: LD_VAR 0 7
25494: DIFF
25495: ST_TO_ADDR
// if tmp and mech < 6 then
25496: LD_VAR 0 4
25500: PUSH
25501: LD_VAR 0 7
25505: PUSH
25506: LD_INT 6
25508: LESS
25509: AND
25510: IFFALSE 25698
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25512: LD_ADDR_VAR 0 9
25516: PUSH
25517: LD_VAR 0 4
25521: PUSH
25522: LD_VAR 0 8
25526: PUSH
25527: LD_VAR 0 7
25531: UNION
25532: DIFF
25533: PPUSH
25534: LD_INT 3
25536: PPUSH
25537: CALL 85009 0 2
25541: ST_TO_ADDR
// p := [ ] ;
25542: LD_ADDR_VAR 0 11
25546: PUSH
25547: EMPTY
25548: ST_TO_ADDR
// if sort then
25549: LD_VAR 0 9
25553: IFFALSE 25669
// for i = 1 to 6 - mech do
25555: LD_ADDR_VAR 0 3
25559: PUSH
25560: DOUBLE
25561: LD_INT 1
25563: DEC
25564: ST_TO_ADDR
25565: LD_INT 6
25567: PUSH
25568: LD_VAR 0 7
25572: MINUS
25573: PUSH
25574: FOR_TO
25575: IFFALSE 25667
// begin if i = sort then
25577: LD_VAR 0 3
25581: PUSH
25582: LD_VAR 0 9
25586: EQUAL
25587: IFFALSE 25591
// break ;
25589: GO 25667
// if GetClass ( i ) = 3 then
25591: LD_VAR 0 3
25595: PPUSH
25596: CALL_OW 257
25600: PUSH
25601: LD_INT 3
25603: EQUAL
25604: IFFALSE 25608
// continue ;
25606: GO 25574
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25608: LD_ADDR_VAR 0 11
25612: PUSH
25613: LD_VAR 0 11
25617: PPUSH
25618: LD_VAR 0 11
25622: PUSH
25623: LD_INT 1
25625: PLUS
25626: PPUSH
25627: LD_VAR 0 9
25631: PUSH
25632: LD_VAR 0 3
25636: ARRAY
25637: PPUSH
25638: CALL_OW 2
25642: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25643: LD_ADDR_VAR 0 4
25647: PUSH
25648: LD_VAR 0 4
25652: PUSH
25653: LD_VAR 0 9
25657: PUSH
25658: LD_VAR 0 3
25662: ARRAY
25663: DIFF
25664: ST_TO_ADDR
// end ;
25665: GO 25574
25667: POP
25668: POP
// if p then
25669: LD_VAR 0 11
25673: IFFALSE 25698
// result := Replace ( result , 3 , p ) ;
25675: LD_ADDR_VAR 0 2
25679: PUSH
25680: LD_VAR 0 2
25684: PPUSH
25685: LD_INT 3
25687: PPUSH
25688: LD_VAR 0 11
25692: PPUSH
25693: CALL_OW 1
25697: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25698: LD_ADDR_VAR 0 4
25702: PUSH
25703: LD_VAR 0 4
25707: PUSH
25708: LD_VAR 0 6
25712: DIFF
25713: ST_TO_ADDR
// if tmp and eng < 6 then
25714: LD_VAR 0 4
25718: PUSH
25719: LD_VAR 0 6
25723: PUSH
25724: LD_INT 6
25726: LESS
25727: AND
25728: IFFALSE 25922
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25730: LD_ADDR_VAR 0 9
25734: PUSH
25735: LD_VAR 0 4
25739: PUSH
25740: LD_VAR 0 8
25744: PUSH
25745: LD_VAR 0 7
25749: UNION
25750: PUSH
25751: LD_VAR 0 6
25755: UNION
25756: DIFF
25757: PPUSH
25758: LD_INT 2
25760: PPUSH
25761: CALL 85009 0 2
25765: ST_TO_ADDR
// p := [ ] ;
25766: LD_ADDR_VAR 0 11
25770: PUSH
25771: EMPTY
25772: ST_TO_ADDR
// if sort then
25773: LD_VAR 0 9
25777: IFFALSE 25893
// for i = 1 to 6 - eng do
25779: LD_ADDR_VAR 0 3
25783: PUSH
25784: DOUBLE
25785: LD_INT 1
25787: DEC
25788: ST_TO_ADDR
25789: LD_INT 6
25791: PUSH
25792: LD_VAR 0 6
25796: MINUS
25797: PUSH
25798: FOR_TO
25799: IFFALSE 25891
// begin if i = sort then
25801: LD_VAR 0 3
25805: PUSH
25806: LD_VAR 0 9
25810: EQUAL
25811: IFFALSE 25815
// break ;
25813: GO 25891
// if GetClass ( i ) = 2 then
25815: LD_VAR 0 3
25819: PPUSH
25820: CALL_OW 257
25824: PUSH
25825: LD_INT 2
25827: EQUAL
25828: IFFALSE 25832
// continue ;
25830: GO 25798
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25832: LD_ADDR_VAR 0 11
25836: PUSH
25837: LD_VAR 0 11
25841: PPUSH
25842: LD_VAR 0 11
25846: PUSH
25847: LD_INT 1
25849: PLUS
25850: PPUSH
25851: LD_VAR 0 9
25855: PUSH
25856: LD_VAR 0 3
25860: ARRAY
25861: PPUSH
25862: CALL_OW 2
25866: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25867: LD_ADDR_VAR 0 4
25871: PUSH
25872: LD_VAR 0 4
25876: PUSH
25877: LD_VAR 0 9
25881: PUSH
25882: LD_VAR 0 3
25886: ARRAY
25887: DIFF
25888: ST_TO_ADDR
// end ;
25889: GO 25798
25891: POP
25892: POP
// if p then
25893: LD_VAR 0 11
25897: IFFALSE 25922
// result := Replace ( result , 2 , p ) ;
25899: LD_ADDR_VAR 0 2
25903: PUSH
25904: LD_VAR 0 2
25908: PPUSH
25909: LD_INT 2
25911: PPUSH
25912: LD_VAR 0 11
25916: PPUSH
25917: CALL_OW 1
25921: ST_TO_ADDR
// end ; exit ;
25922: GO 26646
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25924: LD_EXP 77
25928: PUSH
25929: LD_EXP 76
25933: PUSH
25934: LD_VAR 0 1
25938: ARRAY
25939: ARRAY
25940: NOT
25941: PUSH
25942: LD_EXP 50
25946: PUSH
25947: LD_VAR 0 1
25951: ARRAY
25952: PPUSH
25953: LD_INT 30
25955: PUSH
25956: LD_INT 3
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PPUSH
25963: CALL_OW 72
25967: AND
25968: PUSH
25969: LD_EXP 55
25973: PUSH
25974: LD_VAR 0 1
25978: ARRAY
25979: NOT
25980: AND
25981: IFFALSE 26646
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25983: LD_ADDR_EXP 92
25987: PUSH
25988: LD_EXP 92
25992: PPUSH
25993: LD_VAR 0 1
25997: PPUSH
25998: LD_INT 6
26000: PPUSH
26001: CALL_OW 1
26005: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26006: LD_ADDR_VAR 0 2
26010: PUSH
26011: LD_INT 0
26013: PUSH
26014: LD_INT 0
26016: PUSH
26017: LD_INT 0
26019: PUSH
26020: LD_INT 0
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: ST_TO_ADDR
// if sci >= 1 then
26029: LD_VAR 0 8
26033: PUSH
26034: LD_INT 1
26036: GREATEREQUAL
26037: IFFALSE 26059
// tmp := tmp diff sci [ 1 ] ;
26039: LD_ADDR_VAR 0 4
26043: PUSH
26044: LD_VAR 0 4
26048: PUSH
26049: LD_VAR 0 8
26053: PUSH
26054: LD_INT 1
26056: ARRAY
26057: DIFF
26058: ST_TO_ADDR
// if tmp and not sci then
26059: LD_VAR 0 4
26063: PUSH
26064: LD_VAR 0 8
26068: NOT
26069: AND
26070: IFFALSE 26139
// begin sort := SortBySkill ( tmp , 4 ) ;
26072: LD_ADDR_VAR 0 9
26076: PUSH
26077: LD_VAR 0 4
26081: PPUSH
26082: LD_INT 4
26084: PPUSH
26085: CALL 85009 0 2
26089: ST_TO_ADDR
// if sort then
26090: LD_VAR 0 9
26094: IFFALSE 26110
// p := sort [ 1 ] ;
26096: LD_ADDR_VAR 0 11
26100: PUSH
26101: LD_VAR 0 9
26105: PUSH
26106: LD_INT 1
26108: ARRAY
26109: ST_TO_ADDR
// if p then
26110: LD_VAR 0 11
26114: IFFALSE 26139
// result := Replace ( result , 4 , p ) ;
26116: LD_ADDR_VAR 0 2
26120: PUSH
26121: LD_VAR 0 2
26125: PPUSH
26126: LD_INT 4
26128: PPUSH
26129: LD_VAR 0 11
26133: PPUSH
26134: CALL_OW 1
26138: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26139: LD_ADDR_VAR 0 4
26143: PUSH
26144: LD_VAR 0 4
26148: PUSH
26149: LD_VAR 0 7
26153: DIFF
26154: ST_TO_ADDR
// if tmp and mech < 6 then
26155: LD_VAR 0 4
26159: PUSH
26160: LD_VAR 0 7
26164: PUSH
26165: LD_INT 6
26167: LESS
26168: AND
26169: IFFALSE 26351
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26171: LD_ADDR_VAR 0 9
26175: PUSH
26176: LD_VAR 0 4
26180: PUSH
26181: LD_VAR 0 7
26185: DIFF
26186: PPUSH
26187: LD_INT 3
26189: PPUSH
26190: CALL 85009 0 2
26194: ST_TO_ADDR
// p := [ ] ;
26195: LD_ADDR_VAR 0 11
26199: PUSH
26200: EMPTY
26201: ST_TO_ADDR
// if sort then
26202: LD_VAR 0 9
26206: IFFALSE 26322
// for i = 1 to 6 - mech do
26208: LD_ADDR_VAR 0 3
26212: PUSH
26213: DOUBLE
26214: LD_INT 1
26216: DEC
26217: ST_TO_ADDR
26218: LD_INT 6
26220: PUSH
26221: LD_VAR 0 7
26225: MINUS
26226: PUSH
26227: FOR_TO
26228: IFFALSE 26320
// begin if i = sort then
26230: LD_VAR 0 3
26234: PUSH
26235: LD_VAR 0 9
26239: EQUAL
26240: IFFALSE 26244
// break ;
26242: GO 26320
// if GetClass ( i ) = 3 then
26244: LD_VAR 0 3
26248: PPUSH
26249: CALL_OW 257
26253: PUSH
26254: LD_INT 3
26256: EQUAL
26257: IFFALSE 26261
// continue ;
26259: GO 26227
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26261: LD_ADDR_VAR 0 11
26265: PUSH
26266: LD_VAR 0 11
26270: PPUSH
26271: LD_VAR 0 11
26275: PUSH
26276: LD_INT 1
26278: PLUS
26279: PPUSH
26280: LD_VAR 0 9
26284: PUSH
26285: LD_VAR 0 3
26289: ARRAY
26290: PPUSH
26291: CALL_OW 2
26295: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26296: LD_ADDR_VAR 0 4
26300: PUSH
26301: LD_VAR 0 4
26305: PUSH
26306: LD_VAR 0 9
26310: PUSH
26311: LD_VAR 0 3
26315: ARRAY
26316: DIFF
26317: ST_TO_ADDR
// end ;
26318: GO 26227
26320: POP
26321: POP
// if p then
26322: LD_VAR 0 11
26326: IFFALSE 26351
// result := Replace ( result , 3 , p ) ;
26328: LD_ADDR_VAR 0 2
26332: PUSH
26333: LD_VAR 0 2
26337: PPUSH
26338: LD_INT 3
26340: PPUSH
26341: LD_VAR 0 11
26345: PPUSH
26346: CALL_OW 1
26350: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26351: LD_ADDR_VAR 0 4
26355: PUSH
26356: LD_VAR 0 4
26360: PUSH
26361: LD_VAR 0 6
26365: DIFF
26366: ST_TO_ADDR
// if tmp and eng < 4 then
26367: LD_VAR 0 4
26371: PUSH
26372: LD_VAR 0 6
26376: PUSH
26377: LD_INT 4
26379: LESS
26380: AND
26381: IFFALSE 26571
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26383: LD_ADDR_VAR 0 9
26387: PUSH
26388: LD_VAR 0 4
26392: PUSH
26393: LD_VAR 0 7
26397: PUSH
26398: LD_VAR 0 6
26402: UNION
26403: DIFF
26404: PPUSH
26405: LD_INT 2
26407: PPUSH
26408: CALL 85009 0 2
26412: ST_TO_ADDR
// p := [ ] ;
26413: LD_ADDR_VAR 0 11
26417: PUSH
26418: EMPTY
26419: ST_TO_ADDR
// if sort then
26420: LD_VAR 0 9
26424: IFFALSE 26540
// for i = 1 to 4 - eng do
26426: LD_ADDR_VAR 0 3
26430: PUSH
26431: DOUBLE
26432: LD_INT 1
26434: DEC
26435: ST_TO_ADDR
26436: LD_INT 4
26438: PUSH
26439: LD_VAR 0 6
26443: MINUS
26444: PUSH
26445: FOR_TO
26446: IFFALSE 26538
// begin if i = sort then
26448: LD_VAR 0 3
26452: PUSH
26453: LD_VAR 0 9
26457: EQUAL
26458: IFFALSE 26462
// break ;
26460: GO 26538
// if GetClass ( i ) = 2 then
26462: LD_VAR 0 3
26466: PPUSH
26467: CALL_OW 257
26471: PUSH
26472: LD_INT 2
26474: EQUAL
26475: IFFALSE 26479
// continue ;
26477: GO 26445
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26479: LD_ADDR_VAR 0 11
26483: PUSH
26484: LD_VAR 0 11
26488: PPUSH
26489: LD_VAR 0 11
26493: PUSH
26494: LD_INT 1
26496: PLUS
26497: PPUSH
26498: LD_VAR 0 9
26502: PUSH
26503: LD_VAR 0 3
26507: ARRAY
26508: PPUSH
26509: CALL_OW 2
26513: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26514: LD_ADDR_VAR 0 4
26518: PUSH
26519: LD_VAR 0 4
26523: PUSH
26524: LD_VAR 0 9
26528: PUSH
26529: LD_VAR 0 3
26533: ARRAY
26534: DIFF
26535: ST_TO_ADDR
// end ;
26536: GO 26445
26538: POP
26539: POP
// if p then
26540: LD_VAR 0 11
26544: IFFALSE 26569
// result := Replace ( result , 2 , p ) ;
26546: LD_ADDR_VAR 0 2
26550: PUSH
26551: LD_VAR 0 2
26555: PPUSH
26556: LD_INT 2
26558: PPUSH
26559: LD_VAR 0 11
26563: PPUSH
26564: CALL_OW 1
26568: ST_TO_ADDR
// end else
26569: GO 26615
// for i = eng downto 5 do
26571: LD_ADDR_VAR 0 3
26575: PUSH
26576: DOUBLE
26577: LD_VAR 0 6
26581: INC
26582: ST_TO_ADDR
26583: LD_INT 5
26585: PUSH
26586: FOR_DOWNTO
26587: IFFALSE 26613
// tmp := tmp union eng [ i ] ;
26589: LD_ADDR_VAR 0 4
26593: PUSH
26594: LD_VAR 0 4
26598: PUSH
26599: LD_VAR 0 6
26603: PUSH
26604: LD_VAR 0 3
26608: ARRAY
26609: UNION
26610: ST_TO_ADDR
26611: GO 26586
26613: POP
26614: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26615: LD_ADDR_VAR 0 2
26619: PUSH
26620: LD_VAR 0 2
26624: PPUSH
26625: LD_INT 1
26627: PPUSH
26628: LD_VAR 0 4
26632: PUSH
26633: LD_VAR 0 5
26637: DIFF
26638: PPUSH
26639: CALL_OW 1
26643: ST_TO_ADDR
// exit ;
26644: GO 26646
// end ; end ;
26646: LD_VAR 0 2
26650: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26651: LD_INT 0
26653: PPUSH
26654: PPUSH
26655: PPUSH
// if not mc_bases then
26656: LD_EXP 50
26660: NOT
26661: IFFALSE 26665
// exit ;
26663: GO 26807
// for i = 1 to mc_bases do
26665: LD_ADDR_VAR 0 2
26669: PUSH
26670: DOUBLE
26671: LD_INT 1
26673: DEC
26674: ST_TO_ADDR
26675: LD_EXP 50
26679: PUSH
26680: FOR_TO
26681: IFFALSE 26798
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26683: LD_ADDR_VAR 0 3
26687: PUSH
26688: LD_EXP 50
26692: PUSH
26693: LD_VAR 0 2
26697: ARRAY
26698: PPUSH
26699: LD_INT 21
26701: PUSH
26702: LD_INT 3
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 3
26711: PUSH
26712: LD_INT 2
26714: PUSH
26715: LD_INT 30
26717: PUSH
26718: LD_INT 29
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PUSH
26725: LD_INT 30
26727: PUSH
26728: LD_INT 30
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: LIST
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: PUSH
26744: LD_INT 3
26746: PUSH
26747: LD_INT 24
26749: PUSH
26750: LD_INT 1000
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: LIST
26765: PPUSH
26766: CALL_OW 72
26770: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26771: LD_ADDR_EXP 51
26775: PUSH
26776: LD_EXP 51
26780: PPUSH
26781: LD_VAR 0 2
26785: PPUSH
26786: LD_VAR 0 3
26790: PPUSH
26791: CALL_OW 1
26795: ST_TO_ADDR
// end ;
26796: GO 26680
26798: POP
26799: POP
// RaiseSailEvent ( 101 ) ;
26800: LD_INT 101
26802: PPUSH
26803: CALL_OW 427
// end ;
26807: LD_VAR 0 1
26811: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26812: LD_INT 0
26814: PPUSH
26815: PPUSH
26816: PPUSH
26817: PPUSH
26818: PPUSH
26819: PPUSH
26820: PPUSH
// if not mc_bases then
26821: LD_EXP 50
26825: NOT
26826: IFFALSE 26830
// exit ;
26828: GO 27392
// for i = 1 to mc_bases do
26830: LD_ADDR_VAR 0 2
26834: PUSH
26835: DOUBLE
26836: LD_INT 1
26838: DEC
26839: ST_TO_ADDR
26840: LD_EXP 50
26844: PUSH
26845: FOR_TO
26846: IFFALSE 27383
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26848: LD_ADDR_VAR 0 5
26852: PUSH
26853: LD_EXP 50
26857: PUSH
26858: LD_VAR 0 2
26862: ARRAY
26863: PUSH
26864: LD_EXP 79
26868: PUSH
26869: LD_VAR 0 2
26873: ARRAY
26874: UNION
26875: PPUSH
26876: LD_INT 21
26878: PUSH
26879: LD_INT 1
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: PUSH
26886: LD_INT 1
26888: PUSH
26889: LD_INT 3
26891: PUSH
26892: LD_INT 54
26894: PUSH
26895: EMPTY
26896: LIST
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: PUSH
26902: LD_INT 3
26904: PUSH
26905: LD_INT 24
26907: PUSH
26908: LD_INT 1000
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: LIST
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PPUSH
26928: CALL_OW 72
26932: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26933: LD_ADDR_VAR 0 6
26937: PUSH
26938: LD_EXP 50
26942: PUSH
26943: LD_VAR 0 2
26947: ARRAY
26948: PPUSH
26949: LD_INT 21
26951: PUSH
26952: LD_INT 1
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: LD_INT 3
26964: PUSH
26965: LD_INT 54
26967: PUSH
26968: EMPTY
26969: LIST
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 3
26977: PUSH
26978: LD_INT 24
26980: PUSH
26981: LD_INT 250
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: LIST
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PPUSH
27001: CALL_OW 72
27005: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27006: LD_ADDR_VAR 0 7
27010: PUSH
27011: LD_VAR 0 5
27015: PUSH
27016: LD_VAR 0 6
27020: DIFF
27021: ST_TO_ADDR
// if not need_heal_1 then
27022: LD_VAR 0 6
27026: NOT
27027: IFFALSE 27060
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27029: LD_ADDR_EXP 53
27033: PUSH
27034: LD_EXP 53
27038: PPUSH
27039: LD_VAR 0 2
27043: PUSH
27044: LD_INT 1
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PPUSH
27051: EMPTY
27052: PPUSH
27053: CALL 54162 0 3
27057: ST_TO_ADDR
27058: GO 27130
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27060: LD_ADDR_EXP 53
27064: PUSH
27065: LD_EXP 53
27069: PPUSH
27070: LD_VAR 0 2
27074: PUSH
27075: LD_INT 1
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PPUSH
27082: LD_EXP 53
27086: PUSH
27087: LD_VAR 0 2
27091: ARRAY
27092: PUSH
27093: LD_INT 1
27095: ARRAY
27096: PPUSH
27097: LD_INT 3
27099: PUSH
27100: LD_INT 24
27102: PUSH
27103: LD_INT 1000
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PPUSH
27114: CALL_OW 72
27118: PUSH
27119: LD_VAR 0 6
27123: UNION
27124: PPUSH
27125: CALL 54162 0 3
27129: ST_TO_ADDR
// if not need_heal_2 then
27130: LD_VAR 0 7
27134: NOT
27135: IFFALSE 27168
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27137: LD_ADDR_EXP 53
27141: PUSH
27142: LD_EXP 53
27146: PPUSH
27147: LD_VAR 0 2
27151: PUSH
27152: LD_INT 2
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PPUSH
27159: EMPTY
27160: PPUSH
27161: CALL 54162 0 3
27165: ST_TO_ADDR
27166: GO 27200
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27168: LD_ADDR_EXP 53
27172: PUSH
27173: LD_EXP 53
27177: PPUSH
27178: LD_VAR 0 2
27182: PUSH
27183: LD_INT 2
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PPUSH
27190: LD_VAR 0 7
27194: PPUSH
27195: CALL 54162 0 3
27199: ST_TO_ADDR
// if need_heal_2 then
27200: LD_VAR 0 7
27204: IFFALSE 27365
// for j in need_heal_2 do
27206: LD_ADDR_VAR 0 3
27210: PUSH
27211: LD_VAR 0 7
27215: PUSH
27216: FOR_IN
27217: IFFALSE 27363
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27219: LD_ADDR_VAR 0 5
27223: PUSH
27224: LD_EXP 50
27228: PUSH
27229: LD_VAR 0 2
27233: ARRAY
27234: PPUSH
27235: LD_INT 2
27237: PUSH
27238: LD_INT 30
27240: PUSH
27241: LD_INT 6
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 30
27250: PUSH
27251: LD_INT 7
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 30
27260: PUSH
27261: LD_INT 8
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 30
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PUSH
27278: LD_INT 30
27280: PUSH
27281: LD_INT 1
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: PPUSH
27296: CALL_OW 72
27300: ST_TO_ADDR
// if tmp then
27301: LD_VAR 0 5
27305: IFFALSE 27361
// begin k := NearestUnitToUnit ( tmp , j ) ;
27307: LD_ADDR_VAR 0 4
27311: PUSH
27312: LD_VAR 0 5
27316: PPUSH
27317: LD_VAR 0 3
27321: PPUSH
27322: CALL_OW 74
27326: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27327: LD_VAR 0 3
27331: PPUSH
27332: LD_VAR 0 4
27336: PPUSH
27337: CALL_OW 296
27341: PUSH
27342: LD_INT 5
27344: GREATER
27345: IFFALSE 27361
// ComMoveToNearbyEntrance ( j , k ) ;
27347: LD_VAR 0 3
27351: PPUSH
27352: LD_VAR 0 4
27356: PPUSH
27357: CALL 87370 0 2
// end ; end ;
27361: GO 27216
27363: POP
27364: POP
// if not need_heal_1 and not need_heal_2 then
27365: LD_VAR 0 6
27369: NOT
27370: PUSH
27371: LD_VAR 0 7
27375: NOT
27376: AND
27377: IFFALSE 27381
// continue ;
27379: GO 26845
// end ;
27381: GO 26845
27383: POP
27384: POP
// RaiseSailEvent ( 102 ) ;
27385: LD_INT 102
27387: PPUSH
27388: CALL_OW 427
// end ;
27392: LD_VAR 0 1
27396: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27397: LD_INT 0
27399: PPUSH
27400: PPUSH
27401: PPUSH
27402: PPUSH
27403: PPUSH
27404: PPUSH
27405: PPUSH
27406: PPUSH
// if not mc_bases then
27407: LD_EXP 50
27411: NOT
27412: IFFALSE 27416
// exit ;
27414: GO 28327
// for i = 1 to mc_bases do
27416: LD_ADDR_VAR 0 2
27420: PUSH
27421: DOUBLE
27422: LD_INT 1
27424: DEC
27425: ST_TO_ADDR
27426: LD_EXP 50
27430: PUSH
27431: FOR_TO
27432: IFFALSE 28325
// begin if not mc_building_need_repair [ i ] then
27434: LD_EXP 51
27438: PUSH
27439: LD_VAR 0 2
27443: ARRAY
27444: NOT
27445: IFFALSE 27630
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27447: LD_ADDR_VAR 0 6
27451: PUSH
27452: LD_EXP 69
27456: PUSH
27457: LD_VAR 0 2
27461: ARRAY
27462: PPUSH
27463: LD_INT 3
27465: PUSH
27466: LD_INT 24
27468: PUSH
27469: LD_INT 1000
27471: PUSH
27472: EMPTY
27473: LIST
27474: LIST
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 2
27482: PUSH
27483: LD_INT 34
27485: PUSH
27486: LD_INT 13
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 34
27495: PUSH
27496: LD_INT 52
27498: PUSH
27499: EMPTY
27500: LIST
27501: LIST
27502: PUSH
27503: LD_INT 34
27505: PUSH
27506: LD_INT 88
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PUSH
27513: EMPTY
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PPUSH
27523: CALL_OW 72
27527: ST_TO_ADDR
// if cranes then
27528: LD_VAR 0 6
27532: IFFALSE 27594
// for j in cranes do
27534: LD_ADDR_VAR 0 3
27538: PUSH
27539: LD_VAR 0 6
27543: PUSH
27544: FOR_IN
27545: IFFALSE 27592
// if not IsInArea ( j , mc_parking [ i ] ) then
27547: LD_VAR 0 3
27551: PPUSH
27552: LD_EXP 74
27556: PUSH
27557: LD_VAR 0 2
27561: ARRAY
27562: PPUSH
27563: CALL_OW 308
27567: NOT
27568: IFFALSE 27590
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27570: LD_VAR 0 3
27574: PPUSH
27575: LD_EXP 74
27579: PUSH
27580: LD_VAR 0 2
27584: ARRAY
27585: PPUSH
27586: CALL_OW 113
27590: GO 27544
27592: POP
27593: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27594: LD_ADDR_EXP 52
27598: PUSH
27599: LD_EXP 52
27603: PPUSH
27604: LD_VAR 0 2
27608: PPUSH
27609: EMPTY
27610: PPUSH
27611: CALL_OW 1
27615: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27616: LD_VAR 0 2
27620: PPUSH
27621: LD_INT 101
27623: PPUSH
27624: CALL 22484 0 2
// continue ;
27628: GO 27431
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27630: LD_ADDR_EXP 56
27634: PUSH
27635: LD_EXP 56
27639: PPUSH
27640: LD_VAR 0 2
27644: PPUSH
27645: EMPTY
27646: PPUSH
27647: CALL_OW 1
27651: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27652: LD_VAR 0 2
27656: PPUSH
27657: LD_INT 103
27659: PPUSH
27660: CALL 22484 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27664: LD_ADDR_VAR 0 5
27668: PUSH
27669: LD_EXP 50
27673: PUSH
27674: LD_VAR 0 2
27678: ARRAY
27679: PUSH
27680: LD_EXP 79
27684: PUSH
27685: LD_VAR 0 2
27689: ARRAY
27690: UNION
27691: PPUSH
27692: LD_INT 2
27694: PUSH
27695: LD_INT 25
27697: PUSH
27698: LD_INT 2
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 25
27707: PUSH
27708: LD_INT 16
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: LIST
27719: PUSH
27720: EMPTY
27721: LIST
27722: PPUSH
27723: CALL_OW 72
27727: ST_TO_ADDR
// if mc_need_heal [ i ] then
27728: LD_EXP 53
27732: PUSH
27733: LD_VAR 0 2
27737: ARRAY
27738: IFFALSE 27782
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27740: LD_ADDR_VAR 0 5
27744: PUSH
27745: LD_VAR 0 5
27749: PUSH
27750: LD_EXP 53
27754: PUSH
27755: LD_VAR 0 2
27759: ARRAY
27760: PUSH
27761: LD_INT 1
27763: ARRAY
27764: PUSH
27765: LD_EXP 53
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: PUSH
27776: LD_INT 2
27778: ARRAY
27779: UNION
27780: DIFF
27781: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27782: LD_ADDR_VAR 0 6
27786: PUSH
27787: LD_EXP 69
27791: PUSH
27792: LD_VAR 0 2
27796: ARRAY
27797: PPUSH
27798: LD_INT 2
27800: PUSH
27801: LD_INT 34
27803: PUSH
27804: LD_INT 13
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: LD_INT 34
27813: PUSH
27814: LD_INT 52
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 34
27823: PUSH
27824: LD_INT 88
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL_OW 72
27841: ST_TO_ADDR
// if cranes then
27842: LD_VAR 0 6
27846: IFFALSE 28014
// begin for j in cranes do
27848: LD_ADDR_VAR 0 3
27852: PUSH
27853: LD_VAR 0 6
27857: PUSH
27858: FOR_IN
27859: IFFALSE 28012
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27861: LD_VAR 0 3
27865: PPUSH
27866: CALL_OW 256
27870: PUSH
27871: LD_INT 1000
27873: EQUAL
27874: PUSH
27875: LD_VAR 0 3
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: AND
27886: IFFALSE 27952
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27888: LD_ADDR_VAR 0 8
27892: PUSH
27893: LD_EXP 51
27897: PUSH
27898: LD_VAR 0 2
27902: ARRAY
27903: PPUSH
27904: LD_VAR 0 3
27908: PPUSH
27909: CALL_OW 74
27913: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27914: LD_VAR 0 8
27918: PPUSH
27919: LD_INT 16
27921: PPUSH
27922: CALL 56759 0 2
27926: PUSH
27927: LD_INT 4
27929: ARRAY
27930: PUSH
27931: LD_INT 10
27933: LESS
27934: IFFALSE 27950
// ComRepairBuilding ( j , to_repair ) ;
27936: LD_VAR 0 3
27940: PPUSH
27941: LD_VAR 0 8
27945: PPUSH
27946: CALL_OW 130
// end else
27950: GO 28010
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27952: LD_VAR 0 3
27956: PPUSH
27957: CALL_OW 256
27961: PUSH
27962: LD_INT 500
27964: LESS
27965: PUSH
27966: LD_VAR 0 3
27970: PPUSH
27971: LD_EXP 74
27975: PUSH
27976: LD_VAR 0 2
27980: ARRAY
27981: PPUSH
27982: CALL_OW 308
27986: NOT
27987: AND
27988: IFFALSE 28010
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27990: LD_VAR 0 3
27994: PPUSH
27995: LD_EXP 74
27999: PUSH
28000: LD_VAR 0 2
28004: ARRAY
28005: PPUSH
28006: CALL_OW 113
// end ;
28010: GO 27858
28012: POP
28013: POP
// end ; if tmp > 3 then
28014: LD_VAR 0 5
28018: PUSH
28019: LD_INT 3
28021: GREATER
28022: IFFALSE 28042
// tmp := ShrinkArray ( tmp , 4 ) ;
28024: LD_ADDR_VAR 0 5
28028: PUSH
28029: LD_VAR 0 5
28033: PPUSH
28034: LD_INT 4
28036: PPUSH
28037: CALL 86808 0 2
28041: ST_TO_ADDR
// if not tmp then
28042: LD_VAR 0 5
28046: NOT
28047: IFFALSE 28051
// continue ;
28049: GO 27431
// for j in tmp do
28051: LD_ADDR_VAR 0 3
28055: PUSH
28056: LD_VAR 0 5
28060: PUSH
28061: FOR_IN
28062: IFFALSE 28321
// begin if IsInUnit ( j ) then
28064: LD_VAR 0 3
28068: PPUSH
28069: CALL_OW 310
28073: IFFALSE 28084
// ComExitBuilding ( j ) ;
28075: LD_VAR 0 3
28079: PPUSH
28080: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28084: LD_VAR 0 3
28088: PUSH
28089: LD_EXP 52
28093: PUSH
28094: LD_VAR 0 2
28098: ARRAY
28099: IN
28100: NOT
28101: IFFALSE 28159
// begin SetTag ( j , 101 ) ;
28103: LD_VAR 0 3
28107: PPUSH
28108: LD_INT 101
28110: PPUSH
28111: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28115: LD_ADDR_EXP 52
28119: PUSH
28120: LD_EXP 52
28124: PPUSH
28125: LD_VAR 0 2
28129: PUSH
28130: LD_EXP 52
28134: PUSH
28135: LD_VAR 0 2
28139: ARRAY
28140: PUSH
28141: LD_INT 1
28143: PLUS
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PPUSH
28149: LD_VAR 0 3
28153: PPUSH
28154: CALL 54162 0 3
28158: ST_TO_ADDR
// end ; wait ( 1 ) ;
28159: LD_INT 1
28161: PPUSH
28162: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28166: LD_ADDR_VAR 0 7
28170: PUSH
28171: LD_EXP 51
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: ST_TO_ADDR
// if mc_scan [ i ] then
28182: LD_EXP 73
28186: PUSH
28187: LD_VAR 0 2
28191: ARRAY
28192: IFFALSE 28254
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28194: LD_ADDR_VAR 0 7
28198: PUSH
28199: LD_EXP 51
28203: PUSH
28204: LD_VAR 0 2
28208: ARRAY
28209: PPUSH
28210: LD_INT 3
28212: PUSH
28213: LD_INT 30
28215: PUSH
28216: LD_INT 32
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: LD_INT 30
28225: PUSH
28226: LD_INT 33
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PUSH
28233: LD_INT 30
28235: PUSH
28236: LD_INT 31
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: PPUSH
28249: CALL_OW 72
28253: ST_TO_ADDR
// if not to_repair_tmp then
28254: LD_VAR 0 7
28258: NOT
28259: IFFALSE 28263
// continue ;
28261: GO 28061
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28263: LD_ADDR_VAR 0 8
28267: PUSH
28268: LD_VAR 0 7
28272: PPUSH
28273: LD_VAR 0 3
28277: PPUSH
28278: CALL_OW 74
28282: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28283: LD_VAR 0 8
28287: PPUSH
28288: LD_INT 16
28290: PPUSH
28291: CALL 56759 0 2
28295: PUSH
28296: LD_INT 4
28298: ARRAY
28299: PUSH
28300: LD_INT 14
28302: LESS
28303: IFFALSE 28319
// ComRepairBuilding ( j , to_repair ) ;
28305: LD_VAR 0 3
28309: PPUSH
28310: LD_VAR 0 8
28314: PPUSH
28315: CALL_OW 130
// end ;
28319: GO 28061
28321: POP
28322: POP
// end ;
28323: GO 27431
28325: POP
28326: POP
// end ;
28327: LD_VAR 0 1
28331: RET
// export function MC_Heal ; var i , j , tmp ; begin
28332: LD_INT 0
28334: PPUSH
28335: PPUSH
28336: PPUSH
28337: PPUSH
// if not mc_bases then
28338: LD_EXP 50
28342: NOT
28343: IFFALSE 28347
// exit ;
28345: GO 28749
// for i = 1 to mc_bases do
28347: LD_ADDR_VAR 0 2
28351: PUSH
28352: DOUBLE
28353: LD_INT 1
28355: DEC
28356: ST_TO_ADDR
28357: LD_EXP 50
28361: PUSH
28362: FOR_TO
28363: IFFALSE 28747
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28365: LD_EXP 53
28369: PUSH
28370: LD_VAR 0 2
28374: ARRAY
28375: PUSH
28376: LD_INT 1
28378: ARRAY
28379: NOT
28380: PUSH
28381: LD_EXP 53
28385: PUSH
28386: LD_VAR 0 2
28390: ARRAY
28391: PUSH
28392: LD_INT 2
28394: ARRAY
28395: NOT
28396: AND
28397: IFFALSE 28435
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28399: LD_ADDR_EXP 54
28403: PUSH
28404: LD_EXP 54
28408: PPUSH
28409: LD_VAR 0 2
28413: PPUSH
28414: EMPTY
28415: PPUSH
28416: CALL_OW 1
28420: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28421: LD_VAR 0 2
28425: PPUSH
28426: LD_INT 102
28428: PPUSH
28429: CALL 22484 0 2
// continue ;
28433: GO 28362
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28435: LD_ADDR_VAR 0 4
28439: PUSH
28440: LD_EXP 50
28444: PUSH
28445: LD_VAR 0 2
28449: ARRAY
28450: PPUSH
28451: LD_INT 25
28453: PUSH
28454: LD_INT 4
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL_OW 72
28465: ST_TO_ADDR
// if not tmp then
28466: LD_VAR 0 4
28470: NOT
28471: IFFALSE 28475
// continue ;
28473: GO 28362
// if mc_taming [ i ] then
28475: LD_EXP 81
28479: PUSH
28480: LD_VAR 0 2
28484: ARRAY
28485: IFFALSE 28509
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28487: LD_ADDR_EXP 81
28491: PUSH
28492: LD_EXP 81
28496: PPUSH
28497: LD_VAR 0 2
28501: PPUSH
28502: EMPTY
28503: PPUSH
28504: CALL_OW 1
28508: ST_TO_ADDR
// for j in tmp do
28509: LD_ADDR_VAR 0 3
28513: PUSH
28514: LD_VAR 0 4
28518: PUSH
28519: FOR_IN
28520: IFFALSE 28743
// begin if IsInUnit ( j ) then
28522: LD_VAR 0 3
28526: PPUSH
28527: CALL_OW 310
28531: IFFALSE 28542
// ComExitBuilding ( j ) ;
28533: LD_VAR 0 3
28537: PPUSH
28538: CALL_OW 122
// if not j in mc_healers [ i ] then
28542: LD_VAR 0 3
28546: PUSH
28547: LD_EXP 54
28551: PUSH
28552: LD_VAR 0 2
28556: ARRAY
28557: IN
28558: NOT
28559: IFFALSE 28605
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28561: LD_ADDR_EXP 54
28565: PUSH
28566: LD_EXP 54
28570: PPUSH
28571: LD_VAR 0 2
28575: PUSH
28576: LD_EXP 54
28580: PUSH
28581: LD_VAR 0 2
28585: ARRAY
28586: PUSH
28587: LD_INT 1
28589: PLUS
28590: PUSH
28591: EMPTY
28592: LIST
28593: LIST
28594: PPUSH
28595: LD_VAR 0 3
28599: PPUSH
28600: CALL 54162 0 3
28604: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28605: LD_VAR 0 3
28609: PPUSH
28610: CALL_OW 110
28614: PUSH
28615: LD_INT 102
28617: NONEQUAL
28618: IFFALSE 28632
// SetTag ( j , 102 ) ;
28620: LD_VAR 0 3
28624: PPUSH
28625: LD_INT 102
28627: PPUSH
28628: CALL_OW 109
// Wait ( 3 ) ;
28632: LD_INT 3
28634: PPUSH
28635: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28639: LD_EXP 53
28643: PUSH
28644: LD_VAR 0 2
28648: ARRAY
28649: PUSH
28650: LD_INT 1
28652: ARRAY
28653: IFFALSE 28685
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28655: LD_VAR 0 3
28659: PPUSH
28660: LD_EXP 53
28664: PUSH
28665: LD_VAR 0 2
28669: ARRAY
28670: PUSH
28671: LD_INT 1
28673: ARRAY
28674: PUSH
28675: LD_INT 1
28677: ARRAY
28678: PPUSH
28679: CALL_OW 128
28683: GO 28741
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28685: LD_VAR 0 3
28689: PPUSH
28690: CALL_OW 314
28694: NOT
28695: PUSH
28696: LD_EXP 53
28700: PUSH
28701: LD_VAR 0 2
28705: ARRAY
28706: PUSH
28707: LD_INT 2
28709: ARRAY
28710: AND
28711: IFFALSE 28741
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28713: LD_VAR 0 3
28717: PPUSH
28718: LD_EXP 53
28722: PUSH
28723: LD_VAR 0 2
28727: ARRAY
28728: PUSH
28729: LD_INT 2
28731: ARRAY
28732: PUSH
28733: LD_INT 1
28735: ARRAY
28736: PPUSH
28737: CALL_OW 128
// end ;
28741: GO 28519
28743: POP
28744: POP
// end ;
28745: GO 28362
28747: POP
28748: POP
// end ;
28749: LD_VAR 0 1
28753: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28754: LD_INT 0
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
28760: PPUSH
28761: PPUSH
// if not mc_bases then
28762: LD_EXP 50
28766: NOT
28767: IFFALSE 28771
// exit ;
28769: GO 29934
// for i = 1 to mc_bases do
28771: LD_ADDR_VAR 0 2
28775: PUSH
28776: DOUBLE
28777: LD_INT 1
28779: DEC
28780: ST_TO_ADDR
28781: LD_EXP 50
28785: PUSH
28786: FOR_TO
28787: IFFALSE 29932
// begin if mc_scan [ i ] then
28789: LD_EXP 73
28793: PUSH
28794: LD_VAR 0 2
28798: ARRAY
28799: IFFALSE 28803
// continue ;
28801: GO 28786
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28803: LD_EXP 55
28807: PUSH
28808: LD_VAR 0 2
28812: ARRAY
28813: NOT
28814: PUSH
28815: LD_EXP 57
28819: PUSH
28820: LD_VAR 0 2
28824: ARRAY
28825: NOT
28826: AND
28827: PUSH
28828: LD_EXP 56
28832: PUSH
28833: LD_VAR 0 2
28837: ARRAY
28838: AND
28839: IFFALSE 28877
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28841: LD_ADDR_EXP 56
28845: PUSH
28846: LD_EXP 56
28850: PPUSH
28851: LD_VAR 0 2
28855: PPUSH
28856: EMPTY
28857: PPUSH
28858: CALL_OW 1
28862: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28863: LD_VAR 0 2
28867: PPUSH
28868: LD_INT 103
28870: PPUSH
28871: CALL 22484 0 2
// continue ;
28875: GO 28786
// end ; if mc_construct_list [ i ] then
28877: LD_EXP 57
28881: PUSH
28882: LD_VAR 0 2
28886: ARRAY
28887: IFFALSE 29107
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28889: LD_ADDR_VAR 0 5
28893: PUSH
28894: LD_EXP 50
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PPUSH
28905: LD_INT 25
28907: PUSH
28908: LD_INT 2
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PPUSH
28915: CALL_OW 72
28919: PUSH
28920: LD_EXP 52
28924: PUSH
28925: LD_VAR 0 2
28929: ARRAY
28930: DIFF
28931: ST_TO_ADDR
// if not tmp then
28932: LD_VAR 0 5
28936: NOT
28937: IFFALSE 28941
// continue ;
28939: GO 28786
// for j in tmp do
28941: LD_ADDR_VAR 0 3
28945: PUSH
28946: LD_VAR 0 5
28950: PUSH
28951: FOR_IN
28952: IFFALSE 29103
// begin if not mc_builders [ i ] then
28954: LD_EXP 56
28958: PUSH
28959: LD_VAR 0 2
28963: ARRAY
28964: NOT
28965: IFFALSE 29023
// begin SetTag ( j , 103 ) ;
28967: LD_VAR 0 3
28971: PPUSH
28972: LD_INT 103
28974: PPUSH
28975: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28979: LD_ADDR_EXP 56
28983: PUSH
28984: LD_EXP 56
28988: PPUSH
28989: LD_VAR 0 2
28993: PUSH
28994: LD_EXP 56
28998: PUSH
28999: LD_VAR 0 2
29003: ARRAY
29004: PUSH
29005: LD_INT 1
29007: PLUS
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PPUSH
29013: LD_VAR 0 3
29017: PPUSH
29018: CALL 54162 0 3
29022: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29023: LD_VAR 0 3
29027: PPUSH
29028: CALL_OW 310
29032: IFFALSE 29043
// ComExitBuilding ( j ) ;
29034: LD_VAR 0 3
29038: PPUSH
29039: CALL_OW 122
// wait ( 3 ) ;
29043: LD_INT 3
29045: PPUSH
29046: CALL_OW 67
// if not mc_construct_list [ i ] then
29050: LD_EXP 57
29054: PUSH
29055: LD_VAR 0 2
29059: ARRAY
29060: NOT
29061: IFFALSE 29065
// break ;
29063: GO 29103
// if not HasTask ( j ) then
29065: LD_VAR 0 3
29069: PPUSH
29070: CALL_OW 314
29074: NOT
29075: IFFALSE 29101
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29077: LD_VAR 0 3
29081: PPUSH
29082: LD_EXP 57
29086: PUSH
29087: LD_VAR 0 2
29091: ARRAY
29092: PUSH
29093: LD_INT 1
29095: ARRAY
29096: PPUSH
29097: CALL 57023 0 2
// end ;
29101: GO 28951
29103: POP
29104: POP
// end else
29105: GO 29930
// if mc_build_list [ i ] then
29107: LD_EXP 55
29111: PUSH
29112: LD_VAR 0 2
29116: ARRAY
29117: IFFALSE 29930
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29119: LD_EXP 55
29123: PUSH
29124: LD_VAR 0 2
29128: ARRAY
29129: PUSH
29130: LD_INT 1
29132: ARRAY
29133: PUSH
29134: LD_INT 1
29136: ARRAY
29137: PPUSH
29138: CALL 56847 0 1
29142: PUSH
29143: LD_EXP 50
29147: PUSH
29148: LD_VAR 0 2
29152: ARRAY
29153: PPUSH
29154: LD_INT 2
29156: PUSH
29157: LD_INT 30
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 30
29169: PUSH
29170: LD_INT 3
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: LIST
29181: PPUSH
29182: CALL_OW 72
29186: NOT
29187: AND
29188: IFFALSE 29293
// begin for j = 1 to mc_build_list [ i ] do
29190: LD_ADDR_VAR 0 3
29194: PUSH
29195: DOUBLE
29196: LD_INT 1
29198: DEC
29199: ST_TO_ADDR
29200: LD_EXP 55
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: PUSH
29211: FOR_TO
29212: IFFALSE 29291
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29214: LD_EXP 55
29218: PUSH
29219: LD_VAR 0 2
29223: ARRAY
29224: PUSH
29225: LD_VAR 0 3
29229: ARRAY
29230: PUSH
29231: LD_INT 1
29233: ARRAY
29234: PUSH
29235: LD_INT 2
29237: EQUAL
29238: IFFALSE 29289
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29240: LD_ADDR_EXP 55
29244: PUSH
29245: LD_EXP 55
29249: PPUSH
29250: LD_VAR 0 2
29254: PPUSH
29255: LD_EXP 55
29259: PUSH
29260: LD_VAR 0 2
29264: ARRAY
29265: PPUSH
29266: LD_VAR 0 3
29270: PPUSH
29271: LD_INT 1
29273: PPUSH
29274: LD_INT 0
29276: PPUSH
29277: CALL 53580 0 4
29281: PPUSH
29282: CALL_OW 1
29286: ST_TO_ADDR
// break ;
29287: GO 29291
// end ;
29289: GO 29211
29291: POP
29292: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29293: LD_ADDR_VAR 0 6
29297: PUSH
29298: LD_EXP 50
29302: PUSH
29303: LD_VAR 0 2
29307: ARRAY
29308: PPUSH
29309: LD_INT 2
29311: PUSH
29312: LD_INT 30
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 30
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// for k := 1 to depot do
29342: LD_ADDR_VAR 0 4
29346: PUSH
29347: DOUBLE
29348: LD_INT 1
29350: DEC
29351: ST_TO_ADDR
29352: LD_VAR 0 6
29356: PUSH
29357: FOR_TO
29358: IFFALSE 29928
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29360: LD_EXP 55
29364: PUSH
29365: LD_VAR 0 2
29369: ARRAY
29370: PUSH
29371: LD_INT 1
29373: ARRAY
29374: PUSH
29375: LD_INT 1
29377: ARRAY
29378: PUSH
29379: LD_INT 0
29381: EQUAL
29382: PUSH
29383: LD_VAR 0 6
29387: PUSH
29388: LD_VAR 0 4
29392: ARRAY
29393: PPUSH
29394: LD_EXP 55
29398: PUSH
29399: LD_VAR 0 2
29403: ARRAY
29404: PUSH
29405: LD_INT 1
29407: ARRAY
29408: PUSH
29409: LD_INT 1
29411: ARRAY
29412: PPUSH
29413: LD_EXP 55
29417: PUSH
29418: LD_VAR 0 2
29422: ARRAY
29423: PUSH
29424: LD_INT 1
29426: ARRAY
29427: PUSH
29428: LD_INT 2
29430: ARRAY
29431: PPUSH
29432: LD_EXP 55
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_INT 1
29445: ARRAY
29446: PUSH
29447: LD_INT 3
29449: ARRAY
29450: PPUSH
29451: LD_EXP 55
29455: PUSH
29456: LD_VAR 0 2
29460: ARRAY
29461: PUSH
29462: LD_INT 1
29464: ARRAY
29465: PUSH
29466: LD_INT 4
29468: ARRAY
29469: PPUSH
29470: CALL 62259 0 5
29474: OR
29475: IFFALSE 29756
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29477: LD_ADDR_VAR 0 5
29481: PUSH
29482: LD_EXP 50
29486: PUSH
29487: LD_VAR 0 2
29491: ARRAY
29492: PPUSH
29493: LD_INT 25
29495: PUSH
29496: LD_INT 2
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PPUSH
29503: CALL_OW 72
29507: PUSH
29508: LD_EXP 52
29512: PUSH
29513: LD_VAR 0 2
29517: ARRAY
29518: DIFF
29519: ST_TO_ADDR
// if not tmp then
29520: LD_VAR 0 5
29524: NOT
29525: IFFALSE 29529
// continue ;
29527: GO 29357
// for j in tmp do
29529: LD_ADDR_VAR 0 3
29533: PUSH
29534: LD_VAR 0 5
29538: PUSH
29539: FOR_IN
29540: IFFALSE 29752
// begin if not mc_builders [ i ] then
29542: LD_EXP 56
29546: PUSH
29547: LD_VAR 0 2
29551: ARRAY
29552: NOT
29553: IFFALSE 29611
// begin SetTag ( j , 103 ) ;
29555: LD_VAR 0 3
29559: PPUSH
29560: LD_INT 103
29562: PPUSH
29563: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29567: LD_ADDR_EXP 56
29571: PUSH
29572: LD_EXP 56
29576: PPUSH
29577: LD_VAR 0 2
29581: PUSH
29582: LD_EXP 56
29586: PUSH
29587: LD_VAR 0 2
29591: ARRAY
29592: PUSH
29593: LD_INT 1
29595: PLUS
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PPUSH
29601: LD_VAR 0 3
29605: PPUSH
29606: CALL 54162 0 3
29610: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29611: LD_VAR 0 3
29615: PPUSH
29616: CALL_OW 310
29620: IFFALSE 29631
// ComExitBuilding ( j ) ;
29622: LD_VAR 0 3
29626: PPUSH
29627: CALL_OW 122
// wait ( 3 ) ;
29631: LD_INT 3
29633: PPUSH
29634: CALL_OW 67
// if not mc_build_list [ i ] then
29638: LD_EXP 55
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: NOT
29649: IFFALSE 29653
// break ;
29651: GO 29752
// if not HasTask ( j ) then
29653: LD_VAR 0 3
29657: PPUSH
29658: CALL_OW 314
29662: NOT
29663: IFFALSE 29750
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29665: LD_VAR 0 3
29669: PPUSH
29670: LD_EXP 55
29674: PUSH
29675: LD_VAR 0 2
29679: ARRAY
29680: PUSH
29681: LD_INT 1
29683: ARRAY
29684: PUSH
29685: LD_INT 1
29687: ARRAY
29688: PPUSH
29689: LD_EXP 55
29693: PUSH
29694: LD_VAR 0 2
29698: ARRAY
29699: PUSH
29700: LD_INT 1
29702: ARRAY
29703: PUSH
29704: LD_INT 2
29706: ARRAY
29707: PPUSH
29708: LD_EXP 55
29712: PUSH
29713: LD_VAR 0 2
29717: ARRAY
29718: PUSH
29719: LD_INT 1
29721: ARRAY
29722: PUSH
29723: LD_INT 3
29725: ARRAY
29726: PPUSH
29727: LD_EXP 55
29731: PUSH
29732: LD_VAR 0 2
29736: ARRAY
29737: PUSH
29738: LD_INT 1
29740: ARRAY
29741: PUSH
29742: LD_INT 4
29744: ARRAY
29745: PPUSH
29746: CALL_OW 145
// end ;
29750: GO 29539
29752: POP
29753: POP
// end else
29754: GO 29926
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29756: LD_EXP 50
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: PPUSH
29767: LD_EXP 55
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: PUSH
29778: LD_INT 1
29780: ARRAY
29781: PUSH
29782: LD_INT 1
29784: ARRAY
29785: PPUSH
29786: LD_EXP 55
29790: PUSH
29791: LD_VAR 0 2
29795: ARRAY
29796: PUSH
29797: LD_INT 1
29799: ARRAY
29800: PUSH
29801: LD_INT 2
29803: ARRAY
29804: PPUSH
29805: LD_EXP 55
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: PUSH
29816: LD_INT 1
29818: ARRAY
29819: PUSH
29820: LD_INT 3
29822: ARRAY
29823: PPUSH
29824: LD_EXP 55
29828: PUSH
29829: LD_VAR 0 2
29833: ARRAY
29834: PUSH
29835: LD_INT 1
29837: ARRAY
29838: PUSH
29839: LD_INT 4
29841: ARRAY
29842: PPUSH
29843: LD_EXP 50
29847: PUSH
29848: LD_VAR 0 2
29852: ARRAY
29853: PPUSH
29854: LD_INT 21
29856: PUSH
29857: LD_INT 3
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PPUSH
29864: CALL_OW 72
29868: PPUSH
29869: EMPTY
29870: PPUSH
29871: CALL 61013 0 7
29875: NOT
29876: IFFALSE 29926
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29878: LD_ADDR_EXP 55
29882: PUSH
29883: LD_EXP 55
29887: PPUSH
29888: LD_VAR 0 2
29892: PPUSH
29893: LD_EXP 55
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: PPUSH
29904: LD_INT 1
29906: PPUSH
29907: LD_INT 1
29909: NEG
29910: PPUSH
29911: LD_INT 0
29913: PPUSH
29914: CALL 53580 0 4
29918: PPUSH
29919: CALL_OW 1
29923: ST_TO_ADDR
// continue ;
29924: GO 29357
// end ; end ;
29926: GO 29357
29928: POP
29929: POP
// end ; end ;
29930: GO 28786
29932: POP
29933: POP
// end ;
29934: LD_VAR 0 1
29938: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29939: LD_INT 0
29941: PPUSH
29942: PPUSH
29943: PPUSH
29944: PPUSH
29945: PPUSH
29946: PPUSH
// if not mc_bases then
29947: LD_EXP 50
29951: NOT
29952: IFFALSE 29956
// exit ;
29954: GO 30383
// for i = 1 to mc_bases do
29956: LD_ADDR_VAR 0 2
29960: PUSH
29961: DOUBLE
29962: LD_INT 1
29964: DEC
29965: ST_TO_ADDR
29966: LD_EXP 50
29970: PUSH
29971: FOR_TO
29972: IFFALSE 30381
// begin tmp := mc_build_upgrade [ i ] ;
29974: LD_ADDR_VAR 0 4
29978: PUSH
29979: LD_EXP 82
29983: PUSH
29984: LD_VAR 0 2
29988: ARRAY
29989: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29990: LD_ADDR_VAR 0 6
29994: PUSH
29995: LD_EXP 83
29999: PUSH
30000: LD_VAR 0 2
30004: ARRAY
30005: PPUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 30
30011: PUSH
30012: LD_INT 6
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 30
30021: PUSH
30022: LD_INT 7
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: LIST
30033: PPUSH
30034: CALL_OW 72
30038: ST_TO_ADDR
// if not tmp and not lab then
30039: LD_VAR 0 4
30043: NOT
30044: PUSH
30045: LD_VAR 0 6
30049: NOT
30050: AND
30051: IFFALSE 30055
// continue ;
30053: GO 29971
// if tmp then
30055: LD_VAR 0 4
30059: IFFALSE 30179
// for j in tmp do
30061: LD_ADDR_VAR 0 3
30065: PUSH
30066: LD_VAR 0 4
30070: PUSH
30071: FOR_IN
30072: IFFALSE 30177
// begin if UpgradeCost ( j ) then
30074: LD_VAR 0 3
30078: PPUSH
30079: CALL 60673 0 1
30083: IFFALSE 30175
// begin ComUpgrade ( j ) ;
30085: LD_VAR 0 3
30089: PPUSH
30090: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30094: LD_ADDR_EXP 82
30098: PUSH
30099: LD_EXP 82
30103: PPUSH
30104: LD_VAR 0 2
30108: PPUSH
30109: LD_EXP 82
30113: PUSH
30114: LD_VAR 0 2
30118: ARRAY
30119: PUSH
30120: LD_VAR 0 3
30124: DIFF
30125: PPUSH
30126: CALL_OW 1
30130: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30131: LD_ADDR_EXP 57
30135: PUSH
30136: LD_EXP 57
30140: PPUSH
30141: LD_VAR 0 2
30145: PUSH
30146: LD_EXP 57
30150: PUSH
30151: LD_VAR 0 2
30155: ARRAY
30156: PUSH
30157: LD_INT 1
30159: PLUS
30160: PUSH
30161: EMPTY
30162: LIST
30163: LIST
30164: PPUSH
30165: LD_VAR 0 3
30169: PPUSH
30170: CALL 54162 0 3
30174: ST_TO_ADDR
// end ; end ;
30175: GO 30071
30177: POP
30178: POP
// if not lab or not mc_lab_upgrade [ i ] then
30179: LD_VAR 0 6
30183: NOT
30184: PUSH
30185: LD_EXP 84
30189: PUSH
30190: LD_VAR 0 2
30194: ARRAY
30195: NOT
30196: OR
30197: IFFALSE 30201
// continue ;
30199: GO 29971
// for j in lab do
30201: LD_ADDR_VAR 0 3
30205: PUSH
30206: LD_VAR 0 6
30210: PUSH
30211: FOR_IN
30212: IFFALSE 30377
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30214: LD_VAR 0 3
30218: PPUSH
30219: CALL_OW 266
30223: PUSH
30224: LD_INT 6
30226: PUSH
30227: LD_INT 7
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: IN
30234: PUSH
30235: LD_VAR 0 3
30239: PPUSH
30240: CALL_OW 461
30244: PUSH
30245: LD_INT 1
30247: NONEQUAL
30248: AND
30249: IFFALSE 30375
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30251: LD_VAR 0 3
30255: PPUSH
30256: LD_EXP 84
30260: PUSH
30261: LD_VAR 0 2
30265: ARRAY
30266: PUSH
30267: LD_INT 1
30269: ARRAY
30270: PPUSH
30271: CALL 60878 0 2
30275: IFFALSE 30375
// begin ComCancel ( j ) ;
30277: LD_VAR 0 3
30281: PPUSH
30282: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30286: LD_VAR 0 3
30290: PPUSH
30291: LD_EXP 84
30295: PUSH
30296: LD_VAR 0 2
30300: ARRAY
30301: PUSH
30302: LD_INT 1
30304: ARRAY
30305: PPUSH
30306: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30310: LD_VAR 0 3
30314: PUSH
30315: LD_EXP 57
30319: PUSH
30320: LD_VAR 0 2
30324: ARRAY
30325: IN
30326: NOT
30327: IFFALSE 30373
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30329: LD_ADDR_EXP 57
30333: PUSH
30334: LD_EXP 57
30338: PPUSH
30339: LD_VAR 0 2
30343: PUSH
30344: LD_EXP 57
30348: PUSH
30349: LD_VAR 0 2
30353: ARRAY
30354: PUSH
30355: LD_INT 1
30357: PLUS
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PPUSH
30363: LD_VAR 0 3
30367: PPUSH
30368: CALL 54162 0 3
30372: ST_TO_ADDR
// break ;
30373: GO 30377
// end ; end ; end ;
30375: GO 30211
30377: POP
30378: POP
// end ;
30379: GO 29971
30381: POP
30382: POP
// end ;
30383: LD_VAR 0 1
30387: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30388: LD_INT 0
30390: PPUSH
30391: PPUSH
30392: PPUSH
30393: PPUSH
30394: PPUSH
30395: PPUSH
30396: PPUSH
30397: PPUSH
30398: PPUSH
// if not mc_bases then
30399: LD_EXP 50
30403: NOT
30404: IFFALSE 30408
// exit ;
30406: GO 30813
// for i = 1 to mc_bases do
30408: LD_ADDR_VAR 0 2
30412: PUSH
30413: DOUBLE
30414: LD_INT 1
30416: DEC
30417: ST_TO_ADDR
30418: LD_EXP 50
30422: PUSH
30423: FOR_TO
30424: IFFALSE 30811
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30426: LD_EXP 58
30430: PUSH
30431: LD_VAR 0 2
30435: ARRAY
30436: NOT
30437: PUSH
30438: LD_EXP 50
30442: PUSH
30443: LD_VAR 0 2
30447: ARRAY
30448: PPUSH
30449: LD_INT 30
30451: PUSH
30452: LD_INT 3
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: CALL_OW 72
30463: NOT
30464: OR
30465: IFFALSE 30469
// continue ;
30467: GO 30423
// busy := false ;
30469: LD_ADDR_VAR 0 8
30473: PUSH
30474: LD_INT 0
30476: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30477: LD_ADDR_VAR 0 4
30481: PUSH
30482: LD_EXP 50
30486: PUSH
30487: LD_VAR 0 2
30491: ARRAY
30492: PPUSH
30493: LD_INT 30
30495: PUSH
30496: LD_INT 3
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PPUSH
30503: CALL_OW 72
30507: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30508: LD_ADDR_VAR 0 6
30512: PUSH
30513: LD_EXP 58
30517: PUSH
30518: LD_VAR 0 2
30522: ARRAY
30523: PPUSH
30524: LD_INT 2
30526: PUSH
30527: LD_INT 30
30529: PUSH
30530: LD_INT 32
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 30
30539: PUSH
30540: LD_INT 33
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: LIST
30551: PPUSH
30552: CALL_OW 72
30556: ST_TO_ADDR
// if not t then
30557: LD_VAR 0 6
30561: NOT
30562: IFFALSE 30566
// continue ;
30564: GO 30423
// for j in tmp do
30566: LD_ADDR_VAR 0 3
30570: PUSH
30571: LD_VAR 0 4
30575: PUSH
30576: FOR_IN
30577: IFFALSE 30607
// if not BuildingStatus ( j ) = bs_idle then
30579: LD_VAR 0 3
30583: PPUSH
30584: CALL_OW 461
30588: PUSH
30589: LD_INT 2
30591: EQUAL
30592: NOT
30593: IFFALSE 30605
// begin busy := true ;
30595: LD_ADDR_VAR 0 8
30599: PUSH
30600: LD_INT 1
30602: ST_TO_ADDR
// break ;
30603: GO 30607
// end ;
30605: GO 30576
30607: POP
30608: POP
// if busy then
30609: LD_VAR 0 8
30613: IFFALSE 30617
// continue ;
30615: GO 30423
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30617: LD_ADDR_VAR 0 7
30621: PUSH
30622: LD_VAR 0 6
30626: PPUSH
30627: LD_INT 35
30629: PUSH
30630: LD_INT 0
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PPUSH
30637: CALL_OW 72
30641: ST_TO_ADDR
// if tw then
30642: LD_VAR 0 7
30646: IFFALSE 30723
// begin tw := tw [ 1 ] ;
30648: LD_ADDR_VAR 0 7
30652: PUSH
30653: LD_VAR 0 7
30657: PUSH
30658: LD_INT 1
30660: ARRAY
30661: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30662: LD_ADDR_VAR 0 9
30666: PUSH
30667: LD_VAR 0 7
30671: PPUSH
30672: LD_EXP 75
30676: PUSH
30677: LD_VAR 0 2
30681: ARRAY
30682: PPUSH
30683: CALL 59170 0 2
30687: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30688: LD_EXP 89
30692: PUSH
30693: LD_VAR 0 2
30697: ARRAY
30698: IFFALSE 30721
// if not weapon in mc_allowed_tower_weapons [ i ] then
30700: LD_VAR 0 9
30704: PUSH
30705: LD_EXP 89
30709: PUSH
30710: LD_VAR 0 2
30714: ARRAY
30715: IN
30716: NOT
30717: IFFALSE 30721
// continue ;
30719: GO 30423
// end else
30721: GO 30786
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30723: LD_ADDR_VAR 0 5
30727: PUSH
30728: LD_EXP 58
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PPUSH
30739: LD_VAR 0 4
30743: PPUSH
30744: CALL 86041 0 2
30748: ST_TO_ADDR
// if not tmp2 then
30749: LD_VAR 0 5
30753: NOT
30754: IFFALSE 30758
// continue ;
30756: GO 30423
// tw := tmp2 [ 1 ] ;
30758: LD_ADDR_VAR 0 7
30762: PUSH
30763: LD_VAR 0 5
30767: PUSH
30768: LD_INT 1
30770: ARRAY
30771: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30772: LD_ADDR_VAR 0 9
30776: PUSH
30777: LD_VAR 0 5
30781: PUSH
30782: LD_INT 2
30784: ARRAY
30785: ST_TO_ADDR
// end ; if not weapon then
30786: LD_VAR 0 9
30790: NOT
30791: IFFALSE 30795
// continue ;
30793: GO 30423
// ComPlaceWeapon ( tw , weapon ) ;
30795: LD_VAR 0 7
30799: PPUSH
30800: LD_VAR 0 9
30804: PPUSH
30805: CALL_OW 148
// end ;
30809: GO 30423
30811: POP
30812: POP
// end ;
30813: LD_VAR 0 1
30817: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30818: LD_INT 0
30820: PPUSH
30821: PPUSH
30822: PPUSH
30823: PPUSH
30824: PPUSH
30825: PPUSH
30826: PPUSH
// if not mc_bases then
30827: LD_EXP 50
30831: NOT
30832: IFFALSE 30836
// exit ;
30834: GO 31604
// for i = 1 to mc_bases do
30836: LD_ADDR_VAR 0 2
30840: PUSH
30841: DOUBLE
30842: LD_INT 1
30844: DEC
30845: ST_TO_ADDR
30846: LD_EXP 50
30850: PUSH
30851: FOR_TO
30852: IFFALSE 31602
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30854: LD_EXP 63
30858: PUSH
30859: LD_VAR 0 2
30863: ARRAY
30864: NOT
30865: PUSH
30866: LD_EXP 63
30870: PUSH
30871: LD_VAR 0 2
30875: ARRAY
30876: PUSH
30877: LD_EXP 64
30881: PUSH
30882: LD_VAR 0 2
30886: ARRAY
30887: EQUAL
30888: OR
30889: PUSH
30890: LD_EXP 73
30894: PUSH
30895: LD_VAR 0 2
30899: ARRAY
30900: OR
30901: IFFALSE 30905
// continue ;
30903: GO 30851
// if mc_miners [ i ] then
30905: LD_EXP 64
30909: PUSH
30910: LD_VAR 0 2
30914: ARRAY
30915: IFFALSE 31289
// begin for j = mc_miners [ i ] downto 1 do
30917: LD_ADDR_VAR 0 3
30921: PUSH
30922: DOUBLE
30923: LD_EXP 64
30927: PUSH
30928: LD_VAR 0 2
30932: ARRAY
30933: INC
30934: ST_TO_ADDR
30935: LD_INT 1
30937: PUSH
30938: FOR_DOWNTO
30939: IFFALSE 31287
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30941: LD_EXP 64
30945: PUSH
30946: LD_VAR 0 2
30950: ARRAY
30951: PUSH
30952: LD_VAR 0 3
30956: ARRAY
30957: PPUSH
30958: CALL_OW 301
30962: PUSH
30963: LD_EXP 64
30967: PUSH
30968: LD_VAR 0 2
30972: ARRAY
30973: PUSH
30974: LD_VAR 0 3
30978: ARRAY
30979: PPUSH
30980: CALL_OW 257
30984: PUSH
30985: LD_INT 1
30987: NONEQUAL
30988: OR
30989: IFFALSE 31052
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30991: LD_ADDR_VAR 0 5
30995: PUSH
30996: LD_EXP 64
31000: PUSH
31001: LD_VAR 0 2
31005: ARRAY
31006: PUSH
31007: LD_EXP 64
31011: PUSH
31012: LD_VAR 0 2
31016: ARRAY
31017: PUSH
31018: LD_VAR 0 3
31022: ARRAY
31023: DIFF
31024: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31025: LD_ADDR_EXP 64
31029: PUSH
31030: LD_EXP 64
31034: PPUSH
31035: LD_VAR 0 2
31039: PPUSH
31040: LD_VAR 0 5
31044: PPUSH
31045: CALL_OW 1
31049: ST_TO_ADDR
// continue ;
31050: GO 30938
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31052: LD_EXP 64
31056: PUSH
31057: LD_VAR 0 2
31061: ARRAY
31062: PUSH
31063: LD_VAR 0 3
31067: ARRAY
31068: PPUSH
31069: CALL_OW 257
31073: PUSH
31074: LD_INT 1
31076: EQUAL
31077: PUSH
31078: LD_EXP 64
31082: PUSH
31083: LD_VAR 0 2
31087: ARRAY
31088: PUSH
31089: LD_VAR 0 3
31093: ARRAY
31094: PPUSH
31095: CALL_OW 459
31099: NOT
31100: AND
31101: PUSH
31102: LD_EXP 64
31106: PUSH
31107: LD_VAR 0 2
31111: ARRAY
31112: PUSH
31113: LD_VAR 0 3
31117: ARRAY
31118: PPUSH
31119: CALL_OW 314
31123: NOT
31124: AND
31125: IFFALSE 31285
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31127: LD_EXP 64
31131: PUSH
31132: LD_VAR 0 2
31136: ARRAY
31137: PUSH
31138: LD_VAR 0 3
31142: ARRAY
31143: PPUSH
31144: CALL_OW 310
31148: IFFALSE 31171
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31150: LD_EXP 64
31154: PUSH
31155: LD_VAR 0 2
31159: ARRAY
31160: PUSH
31161: LD_VAR 0 3
31165: ARRAY
31166: PPUSH
31167: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31171: LD_EXP 64
31175: PUSH
31176: LD_VAR 0 2
31180: ARRAY
31181: PUSH
31182: LD_VAR 0 3
31186: ARRAY
31187: PPUSH
31188: CALL_OW 314
31192: NOT
31193: IFFALSE 31285
// begin r := rand ( 1 , mc_mines [ i ] ) ;
31195: LD_ADDR_VAR 0 7
31199: PUSH
31200: LD_INT 1
31202: PPUSH
31203: LD_EXP 63
31207: PUSH
31208: LD_VAR 0 2
31212: ARRAY
31213: PPUSH
31214: CALL_OW 12
31218: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31219: LD_EXP 64
31223: PUSH
31224: LD_VAR 0 2
31228: ARRAY
31229: PUSH
31230: LD_VAR 0 3
31234: ARRAY
31235: PPUSH
31236: LD_EXP 63
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PUSH
31247: LD_VAR 0 7
31251: ARRAY
31252: PUSH
31253: LD_INT 1
31255: ARRAY
31256: PPUSH
31257: LD_EXP 63
31261: PUSH
31262: LD_VAR 0 2
31266: ARRAY
31267: PUSH
31268: LD_VAR 0 7
31272: ARRAY
31273: PUSH
31274: LD_INT 2
31276: ARRAY
31277: PPUSH
31278: LD_INT 0
31280: PPUSH
31281: CALL_OW 193
// end ; end ; end ;
31285: GO 30938
31287: POP
31288: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31289: LD_ADDR_VAR 0 5
31293: PUSH
31294: LD_EXP 50
31298: PUSH
31299: LD_VAR 0 2
31303: ARRAY
31304: PPUSH
31305: LD_INT 2
31307: PUSH
31308: LD_INT 30
31310: PUSH
31311: LD_INT 4
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 30
31320: PUSH
31321: LD_INT 5
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 30
31330: PUSH
31331: LD_INT 32
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: PPUSH
31344: CALL_OW 72
31348: ST_TO_ADDR
// if not tmp then
31349: LD_VAR 0 5
31353: NOT
31354: IFFALSE 31358
// continue ;
31356: GO 30851
// list := [ ] ;
31358: LD_ADDR_VAR 0 6
31362: PUSH
31363: EMPTY
31364: ST_TO_ADDR
// for j in tmp do
31365: LD_ADDR_VAR 0 3
31369: PUSH
31370: LD_VAR 0 5
31374: PUSH
31375: FOR_IN
31376: IFFALSE 31445
// begin for k in UnitsInside ( j ) do
31378: LD_ADDR_VAR 0 4
31382: PUSH
31383: LD_VAR 0 3
31387: PPUSH
31388: CALL_OW 313
31392: PUSH
31393: FOR_IN
31394: IFFALSE 31441
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31396: LD_VAR 0 4
31400: PPUSH
31401: CALL_OW 257
31405: PUSH
31406: LD_INT 1
31408: EQUAL
31409: PUSH
31410: LD_VAR 0 4
31414: PPUSH
31415: CALL_OW 459
31419: NOT
31420: AND
31421: IFFALSE 31439
// list := list ^ k ;
31423: LD_ADDR_VAR 0 6
31427: PUSH
31428: LD_VAR 0 6
31432: PUSH
31433: LD_VAR 0 4
31437: ADD
31438: ST_TO_ADDR
31439: GO 31393
31441: POP
31442: POP
// end ;
31443: GO 31375
31445: POP
31446: POP
// list := list diff mc_miners [ i ] ;
31447: LD_ADDR_VAR 0 6
31451: PUSH
31452: LD_VAR 0 6
31456: PUSH
31457: LD_EXP 64
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: DIFF
31468: ST_TO_ADDR
// if not list then
31469: LD_VAR 0 6
31473: NOT
31474: IFFALSE 31478
// continue ;
31476: GO 30851
// k := mc_mines [ i ] - mc_miners [ i ] ;
31478: LD_ADDR_VAR 0 4
31482: PUSH
31483: LD_EXP 63
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: PUSH
31494: LD_EXP 64
31498: PUSH
31499: LD_VAR 0 2
31503: ARRAY
31504: MINUS
31505: ST_TO_ADDR
// if k > list then
31506: LD_VAR 0 4
31510: PUSH
31511: LD_VAR 0 6
31515: GREATER
31516: IFFALSE 31528
// k := list ;
31518: LD_ADDR_VAR 0 4
31522: PUSH
31523: LD_VAR 0 6
31527: ST_TO_ADDR
// for j = 1 to k do
31528: LD_ADDR_VAR 0 3
31532: PUSH
31533: DOUBLE
31534: LD_INT 1
31536: DEC
31537: ST_TO_ADDR
31538: LD_VAR 0 4
31542: PUSH
31543: FOR_TO
31544: IFFALSE 31598
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31546: LD_ADDR_EXP 64
31550: PUSH
31551: LD_EXP 64
31555: PPUSH
31556: LD_VAR 0 2
31560: PUSH
31561: LD_EXP 64
31565: PUSH
31566: LD_VAR 0 2
31570: ARRAY
31571: PUSH
31572: LD_INT 1
31574: PLUS
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PPUSH
31580: LD_VAR 0 6
31584: PUSH
31585: LD_VAR 0 3
31589: ARRAY
31590: PPUSH
31591: CALL 54162 0 3
31595: ST_TO_ADDR
31596: GO 31543
31598: POP
31599: POP
// end ;
31600: GO 30851
31602: POP
31603: POP
// end ;
31604: LD_VAR 0 1
31608: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31609: LD_INT 0
31611: PPUSH
31612: PPUSH
31613: PPUSH
31614: PPUSH
31615: PPUSH
31616: PPUSH
31617: PPUSH
31618: PPUSH
31619: PPUSH
31620: PPUSH
31621: PPUSH
// if not mc_bases then
31622: LD_EXP 50
31626: NOT
31627: IFFALSE 31631
// exit ;
31629: GO 33454
// for i = 1 to mc_bases do
31631: LD_ADDR_VAR 0 2
31635: PUSH
31636: DOUBLE
31637: LD_INT 1
31639: DEC
31640: ST_TO_ADDR
31641: LD_EXP 50
31645: PUSH
31646: FOR_TO
31647: IFFALSE 33452
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31649: LD_EXP 50
31653: PUSH
31654: LD_VAR 0 2
31658: ARRAY
31659: NOT
31660: PUSH
31661: LD_EXP 57
31665: PUSH
31666: LD_VAR 0 2
31670: ARRAY
31671: OR
31672: IFFALSE 31676
// continue ;
31674: GO 31646
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31676: LD_EXP 66
31680: PUSH
31681: LD_VAR 0 2
31685: ARRAY
31686: NOT
31687: PUSH
31688: LD_EXP 67
31692: PUSH
31693: LD_VAR 0 2
31697: ARRAY
31698: AND
31699: IFFALSE 31737
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31701: LD_ADDR_EXP 67
31705: PUSH
31706: LD_EXP 67
31710: PPUSH
31711: LD_VAR 0 2
31715: PPUSH
31716: EMPTY
31717: PPUSH
31718: CALL_OW 1
31722: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31723: LD_VAR 0 2
31727: PPUSH
31728: LD_INT 107
31730: PPUSH
31731: CALL 22484 0 2
// continue ;
31735: GO 31646
// end ; target := [ ] ;
31737: LD_ADDR_VAR 0 7
31741: PUSH
31742: EMPTY
31743: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31744: LD_ADDR_VAR 0 6
31748: PUSH
31749: LD_EXP 50
31753: PUSH
31754: LD_VAR 0 2
31758: ARRAY
31759: PUSH
31760: LD_INT 1
31762: ARRAY
31763: PPUSH
31764: CALL_OW 255
31768: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31769: LD_ADDR_VAR 0 9
31773: PUSH
31774: LD_EXP 50
31778: PUSH
31779: LD_VAR 0 2
31783: ARRAY
31784: PPUSH
31785: LD_INT 2
31787: PUSH
31788: LD_INT 30
31790: PUSH
31791: LD_INT 0
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PUSH
31798: LD_INT 30
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: LIST
31812: PPUSH
31813: CALL_OW 72
31817: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31818: LD_ADDR_VAR 0 3
31822: PUSH
31823: DOUBLE
31824: LD_EXP 66
31828: PUSH
31829: LD_VAR 0 2
31833: ARRAY
31834: INC
31835: ST_TO_ADDR
31836: LD_INT 1
31838: PUSH
31839: FOR_DOWNTO
31840: IFFALSE 32085
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31842: LD_EXP 66
31846: PUSH
31847: LD_VAR 0 2
31851: ARRAY
31852: PUSH
31853: LD_VAR 0 3
31857: ARRAY
31858: PUSH
31859: LD_INT 2
31861: ARRAY
31862: PPUSH
31863: LD_EXP 66
31867: PUSH
31868: LD_VAR 0 2
31872: ARRAY
31873: PUSH
31874: LD_VAR 0 3
31878: ARRAY
31879: PUSH
31880: LD_INT 3
31882: ARRAY
31883: PPUSH
31884: CALL_OW 488
31888: PUSH
31889: LD_EXP 66
31893: PUSH
31894: LD_VAR 0 2
31898: ARRAY
31899: PUSH
31900: LD_VAR 0 3
31904: ARRAY
31905: PUSH
31906: LD_INT 2
31908: ARRAY
31909: PPUSH
31910: LD_EXP 66
31914: PUSH
31915: LD_VAR 0 2
31919: ARRAY
31920: PUSH
31921: LD_VAR 0 3
31925: ARRAY
31926: PUSH
31927: LD_INT 3
31929: ARRAY
31930: PPUSH
31931: CALL_OW 284
31935: PUSH
31936: LD_INT 0
31938: EQUAL
31939: AND
31940: IFFALSE 31995
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31942: LD_ADDR_VAR 0 5
31946: PUSH
31947: LD_EXP 66
31951: PUSH
31952: LD_VAR 0 2
31956: ARRAY
31957: PPUSH
31958: LD_VAR 0 3
31962: PPUSH
31963: CALL_OW 3
31967: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31968: LD_ADDR_EXP 66
31972: PUSH
31973: LD_EXP 66
31977: PPUSH
31978: LD_VAR 0 2
31982: PPUSH
31983: LD_VAR 0 5
31987: PPUSH
31988: CALL_OW 1
31992: ST_TO_ADDR
// continue ;
31993: GO 31839
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31995: LD_VAR 0 6
31999: PPUSH
32000: LD_EXP 66
32004: PUSH
32005: LD_VAR 0 2
32009: ARRAY
32010: PUSH
32011: LD_VAR 0 3
32015: ARRAY
32016: PUSH
32017: LD_INT 2
32019: ARRAY
32020: PPUSH
32021: LD_EXP 66
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: PUSH
32032: LD_VAR 0 3
32036: ARRAY
32037: PUSH
32038: LD_INT 3
32040: ARRAY
32041: PPUSH
32042: LD_INT 30
32044: PPUSH
32045: CALL 55058 0 4
32049: PUSH
32050: LD_INT 4
32052: ARRAY
32053: PUSH
32054: LD_INT 0
32056: EQUAL
32057: IFFALSE 32083
// begin target := mc_crates [ i ] [ j ] ;
32059: LD_ADDR_VAR 0 7
32063: PUSH
32064: LD_EXP 66
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PUSH
32075: LD_VAR 0 3
32079: ARRAY
32080: ST_TO_ADDR
// break ;
32081: GO 32085
// end ; end ;
32083: GO 31839
32085: POP
32086: POP
// if not target then
32087: LD_VAR 0 7
32091: NOT
32092: IFFALSE 32096
// continue ;
32094: GO 31646
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32096: LD_ADDR_VAR 0 8
32100: PUSH
32101: LD_EXP 69
32105: PUSH
32106: LD_VAR 0 2
32110: ARRAY
32111: PPUSH
32112: LD_INT 2
32114: PUSH
32115: LD_INT 3
32117: PUSH
32118: LD_INT 58
32120: PUSH
32121: EMPTY
32122: LIST
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 61
32130: PUSH
32131: EMPTY
32132: LIST
32133: PUSH
32134: LD_INT 33
32136: PUSH
32137: LD_INT 5
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 33
32146: PUSH
32147: LD_INT 3
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: PUSH
32161: LD_INT 2
32163: PUSH
32164: LD_INT 34
32166: PUSH
32167: LD_INT 32
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 34
32176: PUSH
32177: LD_INT 51
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 34
32186: PUSH
32187: LD_INT 12
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PPUSH
32204: CALL_OW 72
32208: ST_TO_ADDR
// if not cargo then
32209: LD_VAR 0 8
32213: NOT
32214: IFFALSE 32920
// begin if mc_crates_collector [ i ] < 5 then
32216: LD_EXP 67
32220: PUSH
32221: LD_VAR 0 2
32225: ARRAY
32226: PUSH
32227: LD_INT 5
32229: LESS
32230: IFFALSE 32596
// begin if mc_ape [ i ] then
32232: LD_EXP 79
32236: PUSH
32237: LD_VAR 0 2
32241: ARRAY
32242: IFFALSE 32289
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32244: LD_ADDR_VAR 0 5
32248: PUSH
32249: LD_EXP 79
32253: PUSH
32254: LD_VAR 0 2
32258: ARRAY
32259: PPUSH
32260: LD_INT 25
32262: PUSH
32263: LD_INT 16
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 24
32272: PUSH
32273: LD_INT 750
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PPUSH
32284: CALL_OW 72
32288: ST_TO_ADDR
// if not tmp then
32289: LD_VAR 0 5
32293: NOT
32294: IFFALSE 32341
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32296: LD_ADDR_VAR 0 5
32300: PUSH
32301: LD_EXP 50
32305: PUSH
32306: LD_VAR 0 2
32310: ARRAY
32311: PPUSH
32312: LD_INT 25
32314: PUSH
32315: LD_INT 2
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 24
32324: PUSH
32325: LD_INT 750
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PPUSH
32336: CALL_OW 72
32340: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32341: LD_EXP 79
32345: PUSH
32346: LD_VAR 0 2
32350: ARRAY
32351: PUSH
32352: LD_EXP 50
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 25
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 24
32375: PUSH
32376: LD_INT 750
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: AND
32392: PUSH
32393: LD_VAR 0 5
32397: PUSH
32398: LD_INT 5
32400: LESS
32401: AND
32402: IFFALSE 32484
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_EXP 50
32413: PUSH
32414: LD_VAR 0 2
32418: ARRAY
32419: PPUSH
32420: LD_INT 25
32422: PUSH
32423: LD_INT 2
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 24
32432: PUSH
32433: LD_INT 750
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PPUSH
32444: CALL_OW 72
32448: PUSH
32449: FOR_IN
32450: IFFALSE 32482
// begin tmp := tmp union j ;
32452: LD_ADDR_VAR 0 5
32456: PUSH
32457: LD_VAR 0 5
32461: PUSH
32462: LD_VAR 0 3
32466: UNION
32467: ST_TO_ADDR
// if tmp >= 5 then
32468: LD_VAR 0 5
32472: PUSH
32473: LD_INT 5
32475: GREATEREQUAL
32476: IFFALSE 32480
// break ;
32478: GO 32482
// end ;
32480: GO 32449
32482: POP
32483: POP
// end ; if not tmp then
32484: LD_VAR 0 5
32488: NOT
32489: IFFALSE 32493
// continue ;
32491: GO 31646
// for j in tmp do
32493: LD_ADDR_VAR 0 3
32497: PUSH
32498: LD_VAR 0 5
32502: PUSH
32503: FOR_IN
32504: IFFALSE 32594
// if not GetTag ( j ) then
32506: LD_VAR 0 3
32510: PPUSH
32511: CALL_OW 110
32515: NOT
32516: IFFALSE 32592
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32518: LD_ADDR_EXP 67
32522: PUSH
32523: LD_EXP 67
32527: PPUSH
32528: LD_VAR 0 2
32532: PUSH
32533: LD_EXP 67
32537: PUSH
32538: LD_VAR 0 2
32542: ARRAY
32543: PUSH
32544: LD_INT 1
32546: PLUS
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PPUSH
32552: LD_VAR 0 3
32556: PPUSH
32557: CALL 54162 0 3
32561: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32562: LD_VAR 0 3
32566: PPUSH
32567: LD_INT 107
32569: PPUSH
32570: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32574: LD_EXP 67
32578: PUSH
32579: LD_VAR 0 2
32583: ARRAY
32584: PUSH
32585: LD_INT 5
32587: GREATEREQUAL
32588: IFFALSE 32592
// break ;
32590: GO 32594
// end ;
32592: GO 32503
32594: POP
32595: POP
// end ; if mc_crates_collector [ i ] and target then
32596: LD_EXP 67
32600: PUSH
32601: LD_VAR 0 2
32605: ARRAY
32606: PUSH
32607: LD_VAR 0 7
32611: AND
32612: IFFALSE 32918
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32614: LD_EXP 67
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PUSH
32625: LD_VAR 0 7
32629: PUSH
32630: LD_INT 1
32632: ARRAY
32633: LESS
32634: IFFALSE 32654
// tmp := mc_crates_collector [ i ] else
32636: LD_ADDR_VAR 0 5
32640: PUSH
32641: LD_EXP 67
32645: PUSH
32646: LD_VAR 0 2
32650: ARRAY
32651: ST_TO_ADDR
32652: GO 32668
// tmp := target [ 1 ] ;
32654: LD_ADDR_VAR 0 5
32658: PUSH
32659: LD_VAR 0 7
32663: PUSH
32664: LD_INT 1
32666: ARRAY
32667: ST_TO_ADDR
// k := 0 ;
32668: LD_ADDR_VAR 0 4
32672: PUSH
32673: LD_INT 0
32675: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32676: LD_ADDR_VAR 0 3
32680: PUSH
32681: LD_EXP 67
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: PUSH
32692: FOR_IN
32693: IFFALSE 32916
// begin k := k + 1 ;
32695: LD_ADDR_VAR 0 4
32699: PUSH
32700: LD_VAR 0 4
32704: PUSH
32705: LD_INT 1
32707: PLUS
32708: ST_TO_ADDR
// if k > tmp then
32709: LD_VAR 0 4
32713: PUSH
32714: LD_VAR 0 5
32718: GREATER
32719: IFFALSE 32723
// break ;
32721: GO 32916
// if not GetClass ( j ) in [ 2 , 16 ] then
32723: LD_VAR 0 3
32727: PPUSH
32728: CALL_OW 257
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: LD_INT 16
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: IN
32743: NOT
32744: IFFALSE 32797
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32746: LD_ADDR_EXP 67
32750: PUSH
32751: LD_EXP 67
32755: PPUSH
32756: LD_VAR 0 2
32760: PPUSH
32761: LD_EXP 67
32765: PUSH
32766: LD_VAR 0 2
32770: ARRAY
32771: PUSH
32772: LD_VAR 0 3
32776: DIFF
32777: PPUSH
32778: CALL_OW 1
32782: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32783: LD_VAR 0 3
32787: PPUSH
32788: LD_INT 0
32790: PPUSH
32791: CALL_OW 109
// continue ;
32795: GO 32692
// end ; if IsInUnit ( j ) then
32797: LD_VAR 0 3
32801: PPUSH
32802: CALL_OW 310
32806: IFFALSE 32817
// ComExitBuilding ( j ) ;
32808: LD_VAR 0 3
32812: PPUSH
32813: CALL_OW 122
// wait ( 3 ) ;
32817: LD_INT 3
32819: PPUSH
32820: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32824: LD_VAR 0 3
32828: PPUSH
32829: CALL_OW 314
32833: PUSH
32834: LD_VAR 0 6
32838: PPUSH
32839: LD_VAR 0 7
32843: PUSH
32844: LD_INT 2
32846: ARRAY
32847: PPUSH
32848: LD_VAR 0 7
32852: PUSH
32853: LD_INT 3
32855: ARRAY
32856: PPUSH
32857: LD_INT 30
32859: PPUSH
32860: CALL 55058 0 4
32864: PUSH
32865: LD_INT 4
32867: ARRAY
32868: AND
32869: IFFALSE 32887
// ComStandNearbyBuilding ( j , depot ) else
32871: LD_VAR 0 3
32875: PPUSH
32876: LD_VAR 0 9
32880: PPUSH
32881: CALL 50589 0 2
32885: GO 32914
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32887: LD_VAR 0 3
32891: PPUSH
32892: LD_VAR 0 7
32896: PUSH
32897: LD_INT 2
32899: ARRAY
32900: PPUSH
32901: LD_VAR 0 7
32905: PUSH
32906: LD_INT 3
32908: ARRAY
32909: PPUSH
32910: CALL_OW 117
// end ;
32914: GO 32692
32916: POP
32917: POP
// end ; end else
32918: GO 33450
// begin for j in cargo do
32920: LD_ADDR_VAR 0 3
32924: PUSH
32925: LD_VAR 0 8
32929: PUSH
32930: FOR_IN
32931: IFFALSE 33448
// begin if GetTag ( j ) <> 0 then
32933: LD_VAR 0 3
32937: PPUSH
32938: CALL_OW 110
32942: PUSH
32943: LD_INT 0
32945: NONEQUAL
32946: IFFALSE 32950
// continue ;
32948: GO 32930
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32950: LD_VAR 0 3
32954: PPUSH
32955: CALL_OW 256
32959: PUSH
32960: LD_INT 1000
32962: LESS
32963: PUSH
32964: LD_VAR 0 3
32968: PPUSH
32969: LD_EXP 74
32973: PUSH
32974: LD_VAR 0 2
32978: ARRAY
32979: PPUSH
32980: CALL_OW 308
32984: NOT
32985: AND
32986: IFFALSE 33008
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32988: LD_VAR 0 3
32992: PPUSH
32993: LD_EXP 74
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33008: LD_VAR 0 3
33012: PPUSH
33013: CALL_OW 256
33017: PUSH
33018: LD_INT 1000
33020: LESS
33021: PUSH
33022: LD_VAR 0 3
33026: PPUSH
33027: LD_EXP 74
33031: PUSH
33032: LD_VAR 0 2
33036: ARRAY
33037: PPUSH
33038: CALL_OW 308
33042: AND
33043: IFFALSE 33047
// continue ;
33045: GO 32930
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33047: LD_VAR 0 3
33051: PPUSH
33052: CALL_OW 262
33056: PUSH
33057: LD_INT 2
33059: EQUAL
33060: PUSH
33061: LD_VAR 0 3
33065: PPUSH
33066: CALL_OW 261
33070: PUSH
33071: LD_INT 15
33073: LESS
33074: AND
33075: IFFALSE 33079
// continue ;
33077: GO 32930
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33079: LD_VAR 0 3
33083: PPUSH
33084: CALL_OW 262
33088: PUSH
33089: LD_INT 1
33091: EQUAL
33092: PUSH
33093: LD_VAR 0 3
33097: PPUSH
33098: CALL_OW 261
33102: PUSH
33103: LD_INT 10
33105: LESS
33106: AND
33107: IFFALSE 33387
// begin if not depot then
33109: LD_VAR 0 9
33113: NOT
33114: IFFALSE 33118
// continue ;
33116: GO 32930
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33118: LD_VAR 0 3
33122: PPUSH
33123: LD_VAR 0 9
33127: PPUSH
33128: LD_VAR 0 3
33132: PPUSH
33133: CALL_OW 74
33137: PPUSH
33138: CALL_OW 296
33142: PUSH
33143: LD_INT 6
33145: LESS
33146: IFFALSE 33162
// SetFuel ( j , 100 ) else
33148: LD_VAR 0 3
33152: PPUSH
33153: LD_INT 100
33155: PPUSH
33156: CALL_OW 240
33160: GO 33387
// if GetFuel ( j ) = 0 then
33162: LD_VAR 0 3
33166: PPUSH
33167: CALL_OW 261
33171: PUSH
33172: LD_INT 0
33174: EQUAL
33175: IFFALSE 33387
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33177: LD_ADDR_EXP 69
33181: PUSH
33182: LD_EXP 69
33186: PPUSH
33187: LD_VAR 0 2
33191: PPUSH
33192: LD_EXP 69
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: PUSH
33203: LD_VAR 0 3
33207: DIFF
33208: PPUSH
33209: CALL_OW 1
33213: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33214: LD_VAR 0 3
33218: PPUSH
33219: CALL_OW 263
33223: PUSH
33224: LD_INT 1
33226: EQUAL
33227: IFFALSE 33243
// ComExitVehicle ( IsInUnit ( j ) ) ;
33229: LD_VAR 0 3
33233: PPUSH
33234: CALL_OW 310
33238: PPUSH
33239: CALL_OW 121
// if GetControl ( j ) = control_remote then
33243: LD_VAR 0 3
33247: PPUSH
33248: CALL_OW 263
33252: PUSH
33253: LD_INT 2
33255: EQUAL
33256: IFFALSE 33267
// ComUnlink ( j ) ;
33258: LD_VAR 0 3
33262: PPUSH
33263: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33267: LD_ADDR_VAR 0 10
33271: PUSH
33272: LD_VAR 0 2
33276: PPUSH
33277: LD_INT 3
33279: PPUSH
33280: CALL 43054 0 2
33284: ST_TO_ADDR
// if fac then
33285: LD_VAR 0 10
33289: IFFALSE 33385
// begin for k in fac do
33291: LD_ADDR_VAR 0 4
33295: PUSH
33296: LD_VAR 0 10
33300: PUSH
33301: FOR_IN
33302: IFFALSE 33383
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33304: LD_ADDR_VAR 0 11
33308: PUSH
33309: LD_VAR 0 10
33313: PPUSH
33314: LD_VAR 0 3
33318: PPUSH
33319: CALL_OW 265
33323: PPUSH
33324: LD_VAR 0 3
33328: PPUSH
33329: CALL_OW 262
33333: PPUSH
33334: LD_VAR 0 3
33338: PPUSH
33339: CALL_OW 263
33343: PPUSH
33344: LD_VAR 0 3
33348: PPUSH
33349: CALL_OW 264
33353: PPUSH
33354: CALL 51660 0 5
33358: ST_TO_ADDR
// if components then
33359: LD_VAR 0 11
33363: IFFALSE 33381
// begin MC_InsertProduceList ( i , components ) ;
33365: LD_VAR 0 2
33369: PPUSH
33370: LD_VAR 0 11
33374: PPUSH
33375: CALL 42599 0 2
// break ;
33379: GO 33383
// end ; end ;
33381: GO 33301
33383: POP
33384: POP
// end ; continue ;
33385: GO 32930
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33387: LD_VAR 0 3
33391: PPUSH
33392: LD_INT 1
33394: PPUSH
33395: CALL_OW 289
33399: PUSH
33400: LD_INT 100
33402: LESS
33403: PUSH
33404: LD_VAR 0 3
33408: PPUSH
33409: CALL_OW 314
33413: NOT
33414: AND
33415: IFFALSE 33444
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33417: LD_VAR 0 3
33421: PPUSH
33422: LD_VAR 0 7
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: LD_VAR 0 7
33435: PUSH
33436: LD_INT 3
33438: ARRAY
33439: PPUSH
33440: CALL_OW 117
// break ;
33444: GO 33448
// end ;
33446: GO 32930
33448: POP
33449: POP
// end ; end ;
33450: GO 31646
33452: POP
33453: POP
// end ;
33454: LD_VAR 0 1
33458: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33459: LD_INT 0
33461: PPUSH
33462: PPUSH
33463: PPUSH
33464: PPUSH
// if not mc_bases then
33465: LD_EXP 50
33469: NOT
33470: IFFALSE 33474
// exit ;
33472: GO 33635
// for i = 1 to mc_bases do
33474: LD_ADDR_VAR 0 2
33478: PUSH
33479: DOUBLE
33480: LD_INT 1
33482: DEC
33483: ST_TO_ADDR
33484: LD_EXP 50
33488: PUSH
33489: FOR_TO
33490: IFFALSE 33633
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33492: LD_ADDR_VAR 0 4
33496: PUSH
33497: LD_EXP 69
33501: PUSH
33502: LD_VAR 0 2
33506: ARRAY
33507: PUSH
33508: LD_EXP 72
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: UNION
33519: PPUSH
33520: LD_INT 33
33522: PUSH
33523: LD_INT 2
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PPUSH
33530: CALL_OW 72
33534: ST_TO_ADDR
// if tmp then
33535: LD_VAR 0 4
33539: IFFALSE 33631
// for j in tmp do
33541: LD_ADDR_VAR 0 3
33545: PUSH
33546: LD_VAR 0 4
33550: PUSH
33551: FOR_IN
33552: IFFALSE 33629
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33554: LD_VAR 0 3
33558: PPUSH
33559: CALL_OW 312
33563: NOT
33564: PUSH
33565: LD_VAR 0 3
33569: PPUSH
33570: CALL_OW 256
33574: PUSH
33575: LD_INT 250
33577: GREATEREQUAL
33578: AND
33579: IFFALSE 33592
// Connect ( j ) else
33581: LD_VAR 0 3
33585: PPUSH
33586: CALL 57131 0 1
33590: GO 33627
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33592: LD_VAR 0 3
33596: PPUSH
33597: CALL_OW 256
33601: PUSH
33602: LD_INT 250
33604: LESS
33605: PUSH
33606: LD_VAR 0 3
33610: PPUSH
33611: CALL_OW 312
33615: AND
33616: IFFALSE 33627
// ComUnlink ( j ) ;
33618: LD_VAR 0 3
33622: PPUSH
33623: CALL_OW 136
33627: GO 33551
33629: POP
33630: POP
// end ;
33631: GO 33489
33633: POP
33634: POP
// end ;
33635: LD_VAR 0 1
33639: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33640: LD_INT 0
33642: PPUSH
33643: PPUSH
33644: PPUSH
33645: PPUSH
33646: PPUSH
// if not mc_bases then
33647: LD_EXP 50
33651: NOT
33652: IFFALSE 33656
// exit ;
33654: GO 34101
// for i = 1 to mc_bases do
33656: LD_ADDR_VAR 0 2
33660: PUSH
33661: DOUBLE
33662: LD_INT 1
33664: DEC
33665: ST_TO_ADDR
33666: LD_EXP 50
33670: PUSH
33671: FOR_TO
33672: IFFALSE 34099
// begin if not mc_produce [ i ] then
33674: LD_EXP 71
33678: PUSH
33679: LD_VAR 0 2
33683: ARRAY
33684: NOT
33685: IFFALSE 33689
// continue ;
33687: GO 33671
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33689: LD_ADDR_VAR 0 5
33693: PUSH
33694: LD_EXP 50
33698: PUSH
33699: LD_VAR 0 2
33703: ARRAY
33704: PPUSH
33705: LD_INT 30
33707: PUSH
33708: LD_INT 3
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PPUSH
33715: CALL_OW 72
33719: ST_TO_ADDR
// if not fac then
33720: LD_VAR 0 5
33724: NOT
33725: IFFALSE 33729
// continue ;
33727: GO 33671
// for j in fac do
33729: LD_ADDR_VAR 0 3
33733: PUSH
33734: LD_VAR 0 5
33738: PUSH
33739: FOR_IN
33740: IFFALSE 34095
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33742: LD_VAR 0 3
33746: PPUSH
33747: CALL_OW 461
33751: PUSH
33752: LD_INT 2
33754: NONEQUAL
33755: PUSH
33756: LD_VAR 0 3
33760: PPUSH
33761: LD_INT 15
33763: PPUSH
33764: CALL 56759 0 2
33768: PUSH
33769: LD_INT 4
33771: ARRAY
33772: OR
33773: IFFALSE 33777
// continue ;
33775: GO 33739
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33777: LD_VAR 0 3
33781: PPUSH
33782: LD_EXP 71
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: PUSH
33793: LD_INT 1
33795: ARRAY
33796: PUSH
33797: LD_INT 1
33799: ARRAY
33800: PPUSH
33801: LD_EXP 71
33805: PUSH
33806: LD_VAR 0 2
33810: ARRAY
33811: PUSH
33812: LD_INT 1
33814: ARRAY
33815: PUSH
33816: LD_INT 2
33818: ARRAY
33819: PPUSH
33820: LD_EXP 71
33824: PUSH
33825: LD_VAR 0 2
33829: ARRAY
33830: PUSH
33831: LD_INT 1
33833: ARRAY
33834: PUSH
33835: LD_INT 3
33837: ARRAY
33838: PPUSH
33839: LD_EXP 71
33843: PUSH
33844: LD_VAR 0 2
33848: ARRAY
33849: PUSH
33850: LD_INT 1
33852: ARRAY
33853: PUSH
33854: LD_INT 4
33856: ARRAY
33857: PPUSH
33858: CALL_OW 448
33862: PUSH
33863: LD_VAR 0 3
33867: PPUSH
33868: LD_EXP 71
33872: PUSH
33873: LD_VAR 0 2
33877: ARRAY
33878: PUSH
33879: LD_INT 1
33881: ARRAY
33882: PUSH
33883: LD_INT 1
33885: ARRAY
33886: PUSH
33887: LD_EXP 71
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: PUSH
33898: LD_INT 1
33900: ARRAY
33901: PUSH
33902: LD_INT 2
33904: ARRAY
33905: PUSH
33906: LD_EXP 71
33910: PUSH
33911: LD_VAR 0 2
33915: ARRAY
33916: PUSH
33917: LD_INT 1
33919: ARRAY
33920: PUSH
33921: LD_INT 3
33923: ARRAY
33924: PUSH
33925: LD_EXP 71
33929: PUSH
33930: LD_VAR 0 2
33934: ARRAY
33935: PUSH
33936: LD_INT 1
33938: ARRAY
33939: PUSH
33940: LD_INT 4
33942: ARRAY
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: PPUSH
33950: CALL 60526 0 2
33954: AND
33955: IFFALSE 34093
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33957: LD_VAR 0 3
33961: PPUSH
33962: LD_EXP 71
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_INT 1
33975: ARRAY
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: LD_EXP 71
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PUSH
33992: LD_INT 1
33994: ARRAY
33995: PUSH
33996: LD_INT 2
33998: ARRAY
33999: PPUSH
34000: LD_EXP 71
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PUSH
34011: LD_INT 1
34013: ARRAY
34014: PUSH
34015: LD_INT 3
34017: ARRAY
34018: PPUSH
34019: LD_EXP 71
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_INT 1
34032: ARRAY
34033: PUSH
34034: LD_INT 4
34036: ARRAY
34037: PPUSH
34038: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34042: LD_ADDR_VAR 0 4
34046: PUSH
34047: LD_EXP 71
34051: PUSH
34052: LD_VAR 0 2
34056: ARRAY
34057: PPUSH
34058: LD_INT 1
34060: PPUSH
34061: CALL_OW 3
34065: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34066: LD_ADDR_EXP 71
34070: PUSH
34071: LD_EXP 71
34075: PPUSH
34076: LD_VAR 0 2
34080: PPUSH
34081: LD_VAR 0 4
34085: PPUSH
34086: CALL_OW 1
34090: ST_TO_ADDR
// break ;
34091: GO 34095
// end ; end ;
34093: GO 33739
34095: POP
34096: POP
// end ;
34097: GO 33671
34099: POP
34100: POP
// end ;
34101: LD_VAR 0 1
34105: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34106: LD_INT 0
34108: PPUSH
34109: PPUSH
34110: PPUSH
// if not mc_bases then
34111: LD_EXP 50
34115: NOT
34116: IFFALSE 34120
// exit ;
34118: GO 34209
// for i = 1 to mc_bases do
34120: LD_ADDR_VAR 0 2
34124: PUSH
34125: DOUBLE
34126: LD_INT 1
34128: DEC
34129: ST_TO_ADDR
34130: LD_EXP 50
34134: PUSH
34135: FOR_TO
34136: IFFALSE 34207
// begin if mc_attack [ i ] then
34138: LD_EXP 70
34142: PUSH
34143: LD_VAR 0 2
34147: ARRAY
34148: IFFALSE 34205
// begin tmp := mc_attack [ i ] [ 1 ] ;
34150: LD_ADDR_VAR 0 3
34154: PUSH
34155: LD_EXP 70
34159: PUSH
34160: LD_VAR 0 2
34164: ARRAY
34165: PUSH
34166: LD_INT 1
34168: ARRAY
34169: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34170: LD_ADDR_EXP 70
34174: PUSH
34175: LD_EXP 70
34179: PPUSH
34180: LD_VAR 0 2
34184: PPUSH
34185: EMPTY
34186: PPUSH
34187: CALL_OW 1
34191: ST_TO_ADDR
// Attack ( tmp ) ;
34192: LD_VAR 0 3
34196: PPUSH
34197: CALL 110529 0 1
// exit ;
34201: POP
34202: POP
34203: GO 34209
// end ; end ;
34205: GO 34135
34207: POP
34208: POP
// end ;
34209: LD_VAR 0 1
34213: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34214: LD_INT 0
34216: PPUSH
34217: PPUSH
34218: PPUSH
34219: PPUSH
34220: PPUSH
34221: PPUSH
34222: PPUSH
// if not mc_bases then
34223: LD_EXP 50
34227: NOT
34228: IFFALSE 34232
// exit ;
34230: GO 35089
// for i = 1 to mc_bases do
34232: LD_ADDR_VAR 0 2
34236: PUSH
34237: DOUBLE
34238: LD_INT 1
34240: DEC
34241: ST_TO_ADDR
34242: LD_EXP 50
34246: PUSH
34247: FOR_TO
34248: IFFALSE 35087
// begin if not mc_bases [ i ] then
34250: LD_EXP 50
34254: PUSH
34255: LD_VAR 0 2
34259: ARRAY
34260: NOT
34261: IFFALSE 34265
// continue ;
34263: GO 34247
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34265: LD_ADDR_VAR 0 7
34269: PUSH
34270: LD_EXP 50
34274: PUSH
34275: LD_VAR 0 2
34279: ARRAY
34280: PUSH
34281: LD_INT 1
34283: ARRAY
34284: PPUSH
34285: CALL 50811 0 1
34289: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34290: LD_ADDR_EXP 73
34294: PUSH
34295: LD_EXP 73
34299: PPUSH
34300: LD_VAR 0 2
34304: PPUSH
34305: LD_EXP 50
34309: PUSH
34310: LD_VAR 0 2
34314: ARRAY
34315: PUSH
34316: LD_INT 1
34318: ARRAY
34319: PPUSH
34320: CALL_OW 255
34324: PPUSH
34325: LD_EXP 75
34329: PUSH
34330: LD_VAR 0 2
34334: ARRAY
34335: PPUSH
34336: CALL 50776 0 2
34340: PPUSH
34341: CALL_OW 1
34345: ST_TO_ADDR
// if not mc_scan [ i ] then
34346: LD_EXP 73
34350: PUSH
34351: LD_VAR 0 2
34355: ARRAY
34356: NOT
34357: IFFALSE 34535
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34359: LD_ADDR_EXP 93
34363: PUSH
34364: LD_EXP 93
34368: PPUSH
34369: LD_VAR 0 2
34373: PPUSH
34374: LD_INT 0
34376: PPUSH
34377: CALL_OW 1
34381: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34382: LD_ADDR_VAR 0 4
34386: PUSH
34387: LD_EXP 50
34391: PUSH
34392: LD_VAR 0 2
34396: ARRAY
34397: PPUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 25
34403: PUSH
34404: LD_INT 5
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 25
34413: PUSH
34414: LD_INT 8
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 25
34423: PUSH
34424: LD_INT 9
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: PPUSH
34437: CALL_OW 72
34441: ST_TO_ADDR
// if not tmp then
34442: LD_VAR 0 4
34446: NOT
34447: IFFALSE 34451
// continue ;
34449: GO 34247
// for j in tmp do
34451: LD_ADDR_VAR 0 3
34455: PUSH
34456: LD_VAR 0 4
34460: PUSH
34461: FOR_IN
34462: IFFALSE 34533
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34464: LD_VAR 0 3
34468: PPUSH
34469: CALL_OW 310
34473: PPUSH
34474: CALL_OW 266
34478: PUSH
34479: LD_INT 5
34481: EQUAL
34482: PUSH
34483: LD_VAR 0 3
34487: PPUSH
34488: CALL_OW 257
34492: PUSH
34493: LD_INT 1
34495: EQUAL
34496: AND
34497: PUSH
34498: LD_VAR 0 3
34502: PPUSH
34503: CALL_OW 459
34507: NOT
34508: AND
34509: PUSH
34510: LD_VAR 0 7
34514: AND
34515: IFFALSE 34531
// ComChangeProfession ( j , class ) ;
34517: LD_VAR 0 3
34521: PPUSH
34522: LD_VAR 0 7
34526: PPUSH
34527: CALL_OW 123
34531: GO 34461
34533: POP
34534: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34535: LD_EXP 73
34539: PUSH
34540: LD_VAR 0 2
34544: ARRAY
34545: PUSH
34546: LD_EXP 93
34550: PUSH
34551: LD_VAR 0 2
34555: ARRAY
34556: NOT
34557: AND
34558: PUSH
34559: LD_EXP 72
34563: PUSH
34564: LD_VAR 0 2
34568: ARRAY
34569: NOT
34570: AND
34571: PUSH
34572: LD_EXP 50
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: PPUSH
34583: LD_INT 50
34585: PUSH
34586: EMPTY
34587: LIST
34588: PUSH
34589: LD_INT 2
34591: PUSH
34592: LD_INT 30
34594: PUSH
34595: LD_INT 32
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 30
34604: PUSH
34605: LD_INT 33
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 30
34614: PUSH
34615: LD_INT 4
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 30
34624: PUSH
34625: LD_INT 5
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PPUSH
34643: CALL_OW 72
34647: PUSH
34648: LD_INT 4
34650: LESS
34651: PUSH
34652: LD_EXP 50
34656: PUSH
34657: LD_VAR 0 2
34661: ARRAY
34662: PPUSH
34663: LD_INT 3
34665: PUSH
34666: LD_INT 24
34668: PUSH
34669: LD_INT 1000
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 2
34682: PUSH
34683: LD_INT 30
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 30
34695: PUSH
34696: LD_INT 1
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: LIST
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PPUSH
34712: CALL_OW 72
34716: OR
34717: AND
34718: IFFALSE 34969
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34720: LD_ADDR_EXP 93
34724: PUSH
34725: LD_EXP 93
34729: PPUSH
34730: LD_VAR 0 2
34734: PPUSH
34735: LD_INT 1
34737: PPUSH
34738: CALL_OW 1
34742: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34743: LD_ADDR_VAR 0 4
34747: PUSH
34748: LD_EXP 50
34752: PUSH
34753: LD_VAR 0 2
34757: ARRAY
34758: PPUSH
34759: LD_INT 2
34761: PUSH
34762: LD_INT 25
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 25
34774: PUSH
34775: LD_INT 5
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 25
34784: PUSH
34785: LD_INT 8
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 25
34794: PUSH
34795: LD_INT 9
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: PPUSH
34809: CALL_OW 72
34813: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34814: LD_ADDR_VAR 0 4
34818: PUSH
34819: LD_VAR 0 4
34823: PUSH
34824: LD_VAR 0 4
34828: PPUSH
34829: LD_INT 18
34831: PPUSH
34832: CALL 84074 0 2
34836: DIFF
34837: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34838: LD_VAR 0 4
34842: NOT
34843: PUSH
34844: LD_EXP 50
34848: PUSH
34849: LD_VAR 0 2
34853: ARRAY
34854: PPUSH
34855: LD_INT 2
34857: PUSH
34858: LD_INT 30
34860: PUSH
34861: LD_INT 4
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 30
34870: PUSH
34871: LD_INT 5
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL_OW 72
34887: NOT
34888: AND
34889: IFFALSE 34951
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34891: LD_ADDR_VAR 0 4
34895: PUSH
34896: LD_EXP 50
34900: PUSH
34901: LD_VAR 0 2
34905: ARRAY
34906: PPUSH
34907: LD_INT 2
34909: PUSH
34910: LD_INT 25
34912: PUSH
34913: LD_INT 2
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 25
34922: PUSH
34923: LD_INT 3
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 25
34932: PUSH
34933: LD_INT 4
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: PPUSH
34946: CALL_OW 72
34950: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34951: LD_VAR 0 2
34955: PPUSH
34956: LD_VAR 0 4
34960: PPUSH
34961: CALL 115238 0 2
// exit ;
34965: POP
34966: POP
34967: GO 35089
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34969: LD_EXP 73
34973: PUSH
34974: LD_VAR 0 2
34978: ARRAY
34979: PUSH
34980: LD_EXP 93
34984: PUSH
34985: LD_VAR 0 2
34989: ARRAY
34990: NOT
34991: AND
34992: PUSH
34993: LD_EXP 72
34997: PUSH
34998: LD_VAR 0 2
35002: ARRAY
35003: AND
35004: IFFALSE 35085
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35006: LD_ADDR_EXP 93
35010: PUSH
35011: LD_EXP 93
35015: PPUSH
35016: LD_VAR 0 2
35020: PPUSH
35021: LD_INT 1
35023: PPUSH
35024: CALL_OW 1
35028: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35029: LD_ADDR_VAR 0 4
35033: PUSH
35034: LD_EXP 72
35038: PUSH
35039: LD_VAR 0 2
35043: ARRAY
35044: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35045: LD_ADDR_EXP 72
35049: PUSH
35050: LD_EXP 72
35054: PPUSH
35055: LD_VAR 0 2
35059: PPUSH
35060: EMPTY
35061: PPUSH
35062: CALL_OW 1
35066: ST_TO_ADDR
// Defend ( i , tmp ) ;
35067: LD_VAR 0 2
35071: PPUSH
35072: LD_VAR 0 4
35076: PPUSH
35077: CALL 115834 0 2
// exit ;
35081: POP
35082: POP
35083: GO 35089
// end ; end ;
35085: GO 34247
35087: POP
35088: POP
// end ;
35089: LD_VAR 0 1
35093: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35094: LD_INT 0
35096: PPUSH
35097: PPUSH
35098: PPUSH
35099: PPUSH
35100: PPUSH
35101: PPUSH
35102: PPUSH
35103: PPUSH
35104: PPUSH
35105: PPUSH
35106: PPUSH
// if not mc_bases then
35107: LD_EXP 50
35111: NOT
35112: IFFALSE 35116
// exit ;
35114: GO 36203
// for i = 1 to mc_bases do
35116: LD_ADDR_VAR 0 2
35120: PUSH
35121: DOUBLE
35122: LD_INT 1
35124: DEC
35125: ST_TO_ADDR
35126: LD_EXP 50
35130: PUSH
35131: FOR_TO
35132: IFFALSE 36201
// begin tmp := mc_lab [ i ] ;
35134: LD_ADDR_VAR 0 6
35138: PUSH
35139: LD_EXP 83
35143: PUSH
35144: LD_VAR 0 2
35148: ARRAY
35149: ST_TO_ADDR
// if not tmp then
35150: LD_VAR 0 6
35154: NOT
35155: IFFALSE 35159
// continue ;
35157: GO 35131
// idle_lab := 0 ;
35159: LD_ADDR_VAR 0 11
35163: PUSH
35164: LD_INT 0
35166: ST_TO_ADDR
// for j in tmp do
35167: LD_ADDR_VAR 0 3
35171: PUSH
35172: LD_VAR 0 6
35176: PUSH
35177: FOR_IN
35178: IFFALSE 36197
// begin researching := false ;
35180: LD_ADDR_VAR 0 10
35184: PUSH
35185: LD_INT 0
35187: ST_TO_ADDR
// side := GetSide ( j ) ;
35188: LD_ADDR_VAR 0 4
35192: PUSH
35193: LD_VAR 0 3
35197: PPUSH
35198: CALL_OW 255
35202: ST_TO_ADDR
// if not mc_tech [ side ] then
35203: LD_EXP 77
35207: PUSH
35208: LD_VAR 0 4
35212: ARRAY
35213: NOT
35214: IFFALSE 35218
// continue ;
35216: GO 35177
// if BuildingStatus ( j ) = bs_idle then
35218: LD_VAR 0 3
35222: PPUSH
35223: CALL_OW 461
35227: PUSH
35228: LD_INT 2
35230: EQUAL
35231: IFFALSE 35419
// begin if idle_lab and UnitsInside ( j ) < 6 then
35233: LD_VAR 0 11
35237: PUSH
35238: LD_VAR 0 3
35242: PPUSH
35243: CALL_OW 313
35247: PUSH
35248: LD_INT 6
35250: LESS
35251: AND
35252: IFFALSE 35323
// begin tmp2 := UnitsInside ( idle_lab ) ;
35254: LD_ADDR_VAR 0 9
35258: PUSH
35259: LD_VAR 0 11
35263: PPUSH
35264: CALL_OW 313
35268: ST_TO_ADDR
// if tmp2 then
35269: LD_VAR 0 9
35273: IFFALSE 35315
// for x in tmp2 do
35275: LD_ADDR_VAR 0 7
35279: PUSH
35280: LD_VAR 0 9
35284: PUSH
35285: FOR_IN
35286: IFFALSE 35313
// begin ComExitBuilding ( x ) ;
35288: LD_VAR 0 7
35292: PPUSH
35293: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35297: LD_VAR 0 7
35301: PPUSH
35302: LD_VAR 0 3
35306: PPUSH
35307: CALL_OW 180
// end ;
35311: GO 35285
35313: POP
35314: POP
// idle_lab := 0 ;
35315: LD_ADDR_VAR 0 11
35319: PUSH
35320: LD_INT 0
35322: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35323: LD_ADDR_VAR 0 5
35327: PUSH
35328: LD_EXP 77
35332: PUSH
35333: LD_VAR 0 4
35337: ARRAY
35338: PUSH
35339: FOR_IN
35340: IFFALSE 35400
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35342: LD_VAR 0 3
35346: PPUSH
35347: LD_VAR 0 5
35351: PPUSH
35352: CALL_OW 430
35356: PUSH
35357: LD_VAR 0 4
35361: PPUSH
35362: LD_VAR 0 5
35366: PPUSH
35367: CALL 49881 0 2
35371: AND
35372: IFFALSE 35398
// begin researching := true ;
35374: LD_ADDR_VAR 0 10
35378: PUSH
35379: LD_INT 1
35381: ST_TO_ADDR
// ComResearch ( j , t ) ;
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_VAR 0 5
35391: PPUSH
35392: CALL_OW 124
// break ;
35396: GO 35400
// end ;
35398: GO 35339
35400: POP
35401: POP
// if not researching then
35402: LD_VAR 0 10
35406: NOT
35407: IFFALSE 35419
// idle_lab := j ;
35409: LD_ADDR_VAR 0 11
35413: PUSH
35414: LD_VAR 0 3
35418: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35419: LD_VAR 0 3
35423: PPUSH
35424: CALL_OW 461
35428: PUSH
35429: LD_INT 10
35431: EQUAL
35432: IFFALSE 36020
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35434: LD_EXP 79
35438: PUSH
35439: LD_VAR 0 2
35443: ARRAY
35444: NOT
35445: PUSH
35446: LD_EXP 80
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: NOT
35457: AND
35458: PUSH
35459: LD_EXP 77
35463: PUSH
35464: LD_VAR 0 4
35468: ARRAY
35469: PUSH
35470: LD_INT 1
35472: GREATER
35473: AND
35474: IFFALSE 35605
// begin ComCancel ( j ) ;
35476: LD_VAR 0 3
35480: PPUSH
35481: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35485: LD_ADDR_EXP 77
35489: PUSH
35490: LD_EXP 77
35494: PPUSH
35495: LD_VAR 0 4
35499: PPUSH
35500: LD_EXP 77
35504: PUSH
35505: LD_VAR 0 4
35509: ARRAY
35510: PPUSH
35511: LD_EXP 77
35515: PUSH
35516: LD_VAR 0 4
35520: ARRAY
35521: PUSH
35522: LD_INT 1
35524: MINUS
35525: PPUSH
35526: LD_EXP 77
35530: PUSH
35531: LD_VAR 0 4
35535: ARRAY
35536: PPUSH
35537: LD_INT 0
35539: PPUSH
35540: CALL 53580 0 4
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35550: LD_ADDR_EXP 77
35554: PUSH
35555: LD_EXP 77
35559: PPUSH
35560: LD_VAR 0 4
35564: PPUSH
35565: LD_EXP 77
35569: PUSH
35570: LD_VAR 0 4
35574: ARRAY
35575: PPUSH
35576: LD_EXP 77
35580: PUSH
35581: LD_VAR 0 4
35585: ARRAY
35586: PPUSH
35587: LD_INT 1
35589: PPUSH
35590: LD_INT 0
35592: PPUSH
35593: CALL 53580 0 4
35597: PPUSH
35598: CALL_OW 1
35602: ST_TO_ADDR
// continue ;
35603: GO 35177
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35605: LD_EXP 79
35609: PUSH
35610: LD_VAR 0 2
35614: ARRAY
35615: PUSH
35616: LD_EXP 80
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: NOT
35627: AND
35628: IFFALSE 35755
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35630: LD_ADDR_EXP 80
35634: PUSH
35635: LD_EXP 80
35639: PPUSH
35640: LD_VAR 0 2
35644: PUSH
35645: LD_EXP 80
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: LD_INT 1
35658: PLUS
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PPUSH
35664: LD_EXP 79
35668: PUSH
35669: LD_VAR 0 2
35673: ARRAY
35674: PUSH
35675: LD_INT 1
35677: ARRAY
35678: PPUSH
35679: CALL 54162 0 3
35683: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35684: LD_EXP 79
35688: PUSH
35689: LD_VAR 0 2
35693: ARRAY
35694: PUSH
35695: LD_INT 1
35697: ARRAY
35698: PPUSH
35699: LD_INT 112
35701: PPUSH
35702: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35706: LD_ADDR_VAR 0 9
35710: PUSH
35711: LD_EXP 79
35715: PUSH
35716: LD_VAR 0 2
35720: ARRAY
35721: PPUSH
35722: LD_INT 1
35724: PPUSH
35725: CALL_OW 3
35729: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35730: LD_ADDR_EXP 79
35734: PUSH
35735: LD_EXP 79
35739: PPUSH
35740: LD_VAR 0 2
35744: PPUSH
35745: LD_VAR 0 9
35749: PPUSH
35750: CALL_OW 1
35754: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35755: LD_EXP 79
35759: PUSH
35760: LD_VAR 0 2
35764: ARRAY
35765: PUSH
35766: LD_EXP 80
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: AND
35777: PUSH
35778: LD_EXP 80
35782: PUSH
35783: LD_VAR 0 2
35787: ARRAY
35788: PUSH
35789: LD_INT 1
35791: ARRAY
35792: PPUSH
35793: CALL_OW 310
35797: NOT
35798: AND
35799: PUSH
35800: LD_VAR 0 3
35804: PPUSH
35805: CALL_OW 313
35809: PUSH
35810: LD_INT 6
35812: EQUAL
35813: AND
35814: IFFALSE 35870
// begin tmp2 := UnitsInside ( j ) ;
35816: LD_ADDR_VAR 0 9
35820: PUSH
35821: LD_VAR 0 3
35825: PPUSH
35826: CALL_OW 313
35830: ST_TO_ADDR
// if tmp2 = 6 then
35831: LD_VAR 0 9
35835: PUSH
35836: LD_INT 6
35838: EQUAL
35839: IFFALSE 35870
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35841: LD_VAR 0 9
35845: PUSH
35846: LD_INT 1
35848: ARRAY
35849: PPUSH
35850: LD_INT 112
35852: PPUSH
35853: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35857: LD_VAR 0 9
35861: PUSH
35862: LD_INT 1
35864: ARRAY
35865: PPUSH
35866: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35870: LD_EXP 80
35874: PUSH
35875: LD_VAR 0 2
35879: ARRAY
35880: PUSH
35881: LD_EXP 80
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PPUSH
35896: CALL_OW 314
35900: NOT
35901: AND
35902: PUSH
35903: LD_EXP 80
35907: PUSH
35908: LD_VAR 0 2
35912: ARRAY
35913: PUSH
35914: LD_INT 1
35916: ARRAY
35917: PPUSH
35918: CALL_OW 310
35922: NOT
35923: AND
35924: IFFALSE 35950
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35926: LD_EXP 80
35930: PUSH
35931: LD_VAR 0 2
35935: ARRAY
35936: PUSH
35937: LD_INT 1
35939: ARRAY
35940: PPUSH
35941: LD_VAR 0 3
35945: PPUSH
35946: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35950: LD_EXP 80
35954: PUSH
35955: LD_VAR 0 2
35959: ARRAY
35960: PUSH
35961: LD_INT 1
35963: ARRAY
35964: PPUSH
35965: CALL_OW 310
35969: PUSH
35970: LD_EXP 80
35974: PUSH
35975: LD_VAR 0 2
35979: ARRAY
35980: PUSH
35981: LD_INT 1
35983: ARRAY
35984: PPUSH
35985: CALL_OW 310
35989: PPUSH
35990: CALL_OW 461
35994: PUSH
35995: LD_INT 3
35997: NONEQUAL
35998: AND
35999: IFFALSE 36020
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36001: LD_EXP 80
36005: PUSH
36006: LD_VAR 0 2
36010: ARRAY
36011: PUSH
36012: LD_INT 1
36014: ARRAY
36015: PPUSH
36016: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36020: LD_VAR 0 3
36024: PPUSH
36025: CALL_OW 461
36029: PUSH
36030: LD_INT 6
36032: EQUAL
36033: PUSH
36034: LD_VAR 0 6
36038: PUSH
36039: LD_INT 1
36041: GREATER
36042: AND
36043: IFFALSE 36195
// begin sci := [ ] ;
36045: LD_ADDR_VAR 0 8
36049: PUSH
36050: EMPTY
36051: ST_TO_ADDR
// for x in ( tmp diff j ) do
36052: LD_ADDR_VAR 0 7
36056: PUSH
36057: LD_VAR 0 6
36061: PUSH
36062: LD_VAR 0 3
36066: DIFF
36067: PUSH
36068: FOR_IN
36069: IFFALSE 36121
// begin if sci = 6 then
36071: LD_VAR 0 8
36075: PUSH
36076: LD_INT 6
36078: EQUAL
36079: IFFALSE 36083
// break ;
36081: GO 36121
// if BuildingStatus ( x ) = bs_idle then
36083: LD_VAR 0 7
36087: PPUSH
36088: CALL_OW 461
36092: PUSH
36093: LD_INT 2
36095: EQUAL
36096: IFFALSE 36119
// sci := sci ^ UnitsInside ( x ) ;
36098: LD_ADDR_VAR 0 8
36102: PUSH
36103: LD_VAR 0 8
36107: PUSH
36108: LD_VAR 0 7
36112: PPUSH
36113: CALL_OW 313
36117: ADD
36118: ST_TO_ADDR
// end ;
36119: GO 36068
36121: POP
36122: POP
// if not sci then
36123: LD_VAR 0 8
36127: NOT
36128: IFFALSE 36132
// continue ;
36130: GO 35177
// for x in sci do
36132: LD_ADDR_VAR 0 7
36136: PUSH
36137: LD_VAR 0 8
36141: PUSH
36142: FOR_IN
36143: IFFALSE 36193
// if IsInUnit ( x ) and not HasTask ( x ) then
36145: LD_VAR 0 7
36149: PPUSH
36150: CALL_OW 310
36154: PUSH
36155: LD_VAR 0 7
36159: PPUSH
36160: CALL_OW 314
36164: NOT
36165: AND
36166: IFFALSE 36191
// begin ComExitBuilding ( x ) ;
36168: LD_VAR 0 7
36172: PPUSH
36173: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36177: LD_VAR 0 7
36181: PPUSH
36182: LD_VAR 0 3
36186: PPUSH
36187: CALL_OW 180
// end ;
36191: GO 36142
36193: POP
36194: POP
// end ; end ;
36195: GO 35177
36197: POP
36198: POP
// end ;
36199: GO 35131
36201: POP
36202: POP
// end ;
36203: LD_VAR 0 1
36207: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36208: LD_INT 0
36210: PPUSH
36211: PPUSH
// if not mc_bases then
36212: LD_EXP 50
36216: NOT
36217: IFFALSE 36221
// exit ;
36219: GO 36302
// for i = 1 to mc_bases do
36221: LD_ADDR_VAR 0 2
36225: PUSH
36226: DOUBLE
36227: LD_INT 1
36229: DEC
36230: ST_TO_ADDR
36231: LD_EXP 50
36235: PUSH
36236: FOR_TO
36237: IFFALSE 36300
// if mc_mines [ i ] and mc_miners [ i ] then
36239: LD_EXP 63
36243: PUSH
36244: LD_VAR 0 2
36248: ARRAY
36249: PUSH
36250: LD_EXP 64
36254: PUSH
36255: LD_VAR 0 2
36259: ARRAY
36260: AND
36261: IFFALSE 36298
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36263: LD_EXP 64
36267: PUSH
36268: LD_VAR 0 2
36272: ARRAY
36273: PUSH
36274: LD_INT 1
36276: ARRAY
36277: PPUSH
36278: CALL_OW 255
36282: PPUSH
36283: LD_EXP 63
36287: PUSH
36288: LD_VAR 0 2
36292: ARRAY
36293: PPUSH
36294: CALL 50964 0 2
36298: GO 36236
36300: POP
36301: POP
// end ;
36302: LD_VAR 0 1
36306: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36307: LD_INT 0
36309: PPUSH
36310: PPUSH
36311: PPUSH
36312: PPUSH
36313: PPUSH
36314: PPUSH
36315: PPUSH
36316: PPUSH
// if not mc_bases or not mc_parking then
36317: LD_EXP 50
36321: NOT
36322: PUSH
36323: LD_EXP 74
36327: NOT
36328: OR
36329: IFFALSE 36333
// exit ;
36331: GO 37071
// for i = 1 to mc_bases do
36333: LD_ADDR_VAR 0 2
36337: PUSH
36338: DOUBLE
36339: LD_INT 1
36341: DEC
36342: ST_TO_ADDR
36343: LD_EXP 50
36347: PUSH
36348: FOR_TO
36349: IFFALSE 37069
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36351: LD_EXP 50
36355: PUSH
36356: LD_VAR 0 2
36360: ARRAY
36361: NOT
36362: PUSH
36363: LD_EXP 74
36367: PUSH
36368: LD_VAR 0 2
36372: ARRAY
36373: NOT
36374: OR
36375: IFFALSE 36379
// continue ;
36377: GO 36348
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36379: LD_ADDR_VAR 0 5
36383: PUSH
36384: LD_EXP 50
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL_OW 255
36403: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36404: LD_ADDR_VAR 0 6
36408: PUSH
36409: LD_EXP 50
36413: PUSH
36414: LD_VAR 0 2
36418: ARRAY
36419: PPUSH
36420: LD_INT 30
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PPUSH
36430: CALL_OW 72
36434: ST_TO_ADDR
// if not fac then
36435: LD_VAR 0 6
36439: NOT
36440: IFFALSE 36491
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36442: LD_ADDR_VAR 0 6
36446: PUSH
36447: LD_EXP 50
36451: PUSH
36452: LD_VAR 0 2
36456: ARRAY
36457: PPUSH
36458: LD_INT 2
36460: PUSH
36461: LD_INT 30
36463: PUSH
36464: LD_INT 0
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 30
36473: PUSH
36474: LD_INT 1
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: LIST
36485: PPUSH
36486: CALL_OW 72
36490: ST_TO_ADDR
// if not fac then
36491: LD_VAR 0 6
36495: NOT
36496: IFFALSE 36500
// continue ;
36498: GO 36348
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36500: LD_ADDR_VAR 0 7
36504: PUSH
36505: LD_EXP 74
36509: PUSH
36510: LD_VAR 0 2
36514: ARRAY
36515: PPUSH
36516: LD_INT 22
36518: PUSH
36519: LD_VAR 0 5
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 21
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 3
36540: PUSH
36541: LD_INT 60
36543: PUSH
36544: EMPTY
36545: LIST
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 3
36553: PUSH
36554: LD_INT 24
36556: PUSH
36557: LD_INT 1000
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: LIST
36572: LIST
36573: PPUSH
36574: CALL_OW 70
36578: ST_TO_ADDR
// for j in fac do
36579: LD_ADDR_VAR 0 3
36583: PUSH
36584: LD_VAR 0 6
36588: PUSH
36589: FOR_IN
36590: IFFALSE 36685
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36592: LD_ADDR_VAR 0 7
36596: PUSH
36597: LD_VAR 0 7
36601: PUSH
36602: LD_INT 22
36604: PUSH
36605: LD_VAR 0 5
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 91
36616: PUSH
36617: LD_VAR 0 3
36621: PUSH
36622: LD_INT 15
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 21
36632: PUSH
36633: LD_INT 2
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 3
36642: PUSH
36643: LD_INT 60
36645: PUSH
36646: EMPTY
36647: LIST
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 3
36655: PUSH
36656: LD_INT 24
36658: PUSH
36659: LD_INT 1000
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: PPUSH
36677: CALL_OW 69
36681: UNION
36682: ST_TO_ADDR
36683: GO 36589
36685: POP
36686: POP
// if not vehs then
36687: LD_VAR 0 7
36691: NOT
36692: IFFALSE 36718
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36694: LD_ADDR_EXP 62
36698: PUSH
36699: LD_EXP 62
36703: PPUSH
36704: LD_VAR 0 2
36708: PPUSH
36709: EMPTY
36710: PPUSH
36711: CALL_OW 1
36715: ST_TO_ADDR
// continue ;
36716: GO 36348
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36718: LD_ADDR_VAR 0 8
36722: PUSH
36723: LD_EXP 50
36727: PUSH
36728: LD_VAR 0 2
36732: ARRAY
36733: PPUSH
36734: LD_INT 30
36736: PUSH
36737: LD_INT 3
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PPUSH
36744: CALL_OW 72
36748: ST_TO_ADDR
// if tmp then
36749: LD_VAR 0 8
36753: IFFALSE 36856
// begin for j in tmp do
36755: LD_ADDR_VAR 0 3
36759: PUSH
36760: LD_VAR 0 8
36764: PUSH
36765: FOR_IN
36766: IFFALSE 36854
// for k in UnitsInside ( j ) do
36768: LD_ADDR_VAR 0 4
36772: PUSH
36773: LD_VAR 0 3
36777: PPUSH
36778: CALL_OW 313
36782: PUSH
36783: FOR_IN
36784: IFFALSE 36850
// if k then
36786: LD_VAR 0 4
36790: IFFALSE 36848
// if not k in mc_repair_vehicle [ i ] then
36792: LD_VAR 0 4
36796: PUSH
36797: LD_EXP 62
36801: PUSH
36802: LD_VAR 0 2
36806: ARRAY
36807: IN
36808: NOT
36809: IFFALSE 36848
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36811: LD_ADDR_EXP 62
36815: PUSH
36816: LD_EXP 62
36820: PPUSH
36821: LD_VAR 0 2
36825: PPUSH
36826: LD_EXP 62
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PUSH
36837: LD_VAR 0 4
36841: UNION
36842: PPUSH
36843: CALL_OW 1
36847: ST_TO_ADDR
36848: GO 36783
36850: POP
36851: POP
36852: GO 36765
36854: POP
36855: POP
// end ; if not mc_repair_vehicle [ i ] then
36856: LD_EXP 62
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: NOT
36867: IFFALSE 36871
// continue ;
36869: GO 36348
// for j in mc_repair_vehicle [ i ] do
36871: LD_ADDR_VAR 0 3
36875: PUSH
36876: LD_EXP 62
36880: PUSH
36881: LD_VAR 0 2
36885: ARRAY
36886: PUSH
36887: FOR_IN
36888: IFFALSE 37065
// begin if GetClass ( j ) <> 3 then
36890: LD_VAR 0 3
36894: PPUSH
36895: CALL_OW 257
36899: PUSH
36900: LD_INT 3
36902: NONEQUAL
36903: IFFALSE 36944
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36905: LD_ADDR_EXP 62
36909: PUSH
36910: LD_EXP 62
36914: PPUSH
36915: LD_VAR 0 2
36919: PPUSH
36920: LD_EXP 62
36924: PUSH
36925: LD_VAR 0 2
36929: ARRAY
36930: PUSH
36931: LD_VAR 0 3
36935: DIFF
36936: PPUSH
36937: CALL_OW 1
36941: ST_TO_ADDR
// continue ;
36942: GO 36887
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36944: LD_VAR 0 3
36948: PPUSH
36949: CALL_OW 311
36953: NOT
36954: PUSH
36955: LD_VAR 0 3
36959: PUSH
36960: LD_EXP 53
36964: PUSH
36965: LD_VAR 0 2
36969: ARRAY
36970: PUSH
36971: LD_INT 1
36973: ARRAY
36974: IN
36975: NOT
36976: AND
36977: PUSH
36978: LD_VAR 0 3
36982: PUSH
36983: LD_EXP 53
36987: PUSH
36988: LD_VAR 0 2
36992: ARRAY
36993: PUSH
36994: LD_INT 2
36996: ARRAY
36997: IN
36998: NOT
36999: AND
37000: IFFALSE 37063
// begin if IsInUnit ( j ) then
37002: LD_VAR 0 3
37006: PPUSH
37007: CALL_OW 310
37011: IFFALSE 37024
// ComExitBuilding ( j ) else
37013: LD_VAR 0 3
37017: PPUSH
37018: CALL_OW 122
37022: GO 37063
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37024: LD_VAR 0 3
37028: PPUSH
37029: LD_VAR 0 7
37033: PUSH
37034: LD_INT 1
37036: ARRAY
37037: PPUSH
37038: CALL 88558 0 2
37042: NOT
37043: IFFALSE 37063
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37045: LD_VAR 0 3
37049: PPUSH
37050: LD_VAR 0 7
37054: PUSH
37055: LD_INT 1
37057: ARRAY
37058: PPUSH
37059: CALL_OW 129
// end ; end ;
37063: GO 36887
37065: POP
37066: POP
// end ;
37067: GO 36348
37069: POP
37070: POP
// end ;
37071: LD_VAR 0 1
37075: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37076: LD_INT 0
37078: PPUSH
37079: PPUSH
37080: PPUSH
37081: PPUSH
37082: PPUSH
37083: PPUSH
37084: PPUSH
37085: PPUSH
37086: PPUSH
37087: PPUSH
37088: PPUSH
// if not mc_bases then
37089: LD_EXP 50
37093: NOT
37094: IFFALSE 37098
// exit ;
37096: GO 37900
// for i = 1 to mc_bases do
37098: LD_ADDR_VAR 0 2
37102: PUSH
37103: DOUBLE
37104: LD_INT 1
37106: DEC
37107: ST_TO_ADDR
37108: LD_EXP 50
37112: PUSH
37113: FOR_TO
37114: IFFALSE 37898
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37116: LD_EXP 78
37120: PUSH
37121: LD_VAR 0 2
37125: ARRAY
37126: NOT
37127: PUSH
37128: LD_EXP 53
37132: PUSH
37133: LD_VAR 0 2
37137: ARRAY
37138: PUSH
37139: LD_INT 1
37141: ARRAY
37142: OR
37143: PUSH
37144: LD_EXP 53
37148: PUSH
37149: LD_VAR 0 2
37153: ARRAY
37154: PUSH
37155: LD_INT 2
37157: ARRAY
37158: OR
37159: PUSH
37160: LD_EXP 76
37164: PUSH
37165: LD_VAR 0 2
37169: ARRAY
37170: PPUSH
37171: LD_INT 1
37173: PPUSH
37174: CALL_OW 325
37178: NOT
37179: OR
37180: PUSH
37181: LD_EXP 73
37185: PUSH
37186: LD_VAR 0 2
37190: ARRAY
37191: OR
37192: IFFALSE 37196
// continue ;
37194: GO 37113
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37196: LD_ADDR_VAR 0 8
37200: PUSH
37201: LD_EXP 50
37205: PUSH
37206: LD_VAR 0 2
37210: ARRAY
37211: PPUSH
37212: LD_INT 25
37214: PUSH
37215: LD_INT 4
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 50
37224: PUSH
37225: EMPTY
37226: LIST
37227: PUSH
37228: LD_INT 3
37230: PUSH
37231: LD_INT 60
37233: PUSH
37234: EMPTY
37235: LIST
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: LIST
37245: PPUSH
37246: CALL_OW 72
37250: PUSH
37251: LD_EXP 54
37255: PUSH
37256: LD_VAR 0 2
37260: ARRAY
37261: DIFF
37262: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37263: LD_ADDR_VAR 0 9
37267: PUSH
37268: LD_EXP 50
37272: PUSH
37273: LD_VAR 0 2
37277: ARRAY
37278: PPUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 30
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 30
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: LIST
37306: PPUSH
37307: CALL_OW 72
37311: ST_TO_ADDR
// if not tmp or not dep then
37312: LD_VAR 0 8
37316: NOT
37317: PUSH
37318: LD_VAR 0 9
37322: NOT
37323: OR
37324: IFFALSE 37328
// continue ;
37326: GO 37113
// side := GetSide ( tmp [ 1 ] ) ;
37328: LD_ADDR_VAR 0 11
37332: PUSH
37333: LD_VAR 0 8
37337: PUSH
37338: LD_INT 1
37340: ARRAY
37341: PPUSH
37342: CALL_OW 255
37346: ST_TO_ADDR
// dep := dep [ 1 ] ;
37347: LD_ADDR_VAR 0 9
37351: PUSH
37352: LD_VAR 0 9
37356: PUSH
37357: LD_INT 1
37359: ARRAY
37360: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37361: LD_ADDR_VAR 0 7
37365: PUSH
37366: LD_EXP 78
37370: PUSH
37371: LD_VAR 0 2
37375: ARRAY
37376: PPUSH
37377: LD_INT 22
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 25
37389: PUSH
37390: LD_INT 12
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PPUSH
37401: CALL_OW 70
37405: PUSH
37406: LD_INT 22
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 25
37418: PUSH
37419: LD_INT 12
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 91
37428: PUSH
37429: LD_VAR 0 9
37433: PUSH
37434: LD_INT 20
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: LIST
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: LIST
37446: PPUSH
37447: CALL_OW 69
37451: UNION
37452: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37453: LD_ADDR_VAR 0 10
37457: PUSH
37458: LD_EXP 78
37462: PUSH
37463: LD_VAR 0 2
37467: ARRAY
37468: PPUSH
37469: LD_INT 81
37471: PUSH
37472: LD_VAR 0 11
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PPUSH
37481: CALL_OW 70
37485: ST_TO_ADDR
// if not apes or danger_at_area then
37486: LD_VAR 0 7
37490: NOT
37491: PUSH
37492: LD_VAR 0 10
37496: OR
37497: IFFALSE 37547
// begin if mc_taming [ i ] then
37499: LD_EXP 81
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: IFFALSE 37545
// begin MC_Reset ( i , 121 ) ;
37511: LD_VAR 0 2
37515: PPUSH
37516: LD_INT 121
37518: PPUSH
37519: CALL 22484 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37523: LD_ADDR_EXP 81
37527: PUSH
37528: LD_EXP 81
37532: PPUSH
37533: LD_VAR 0 2
37537: PPUSH
37538: EMPTY
37539: PPUSH
37540: CALL_OW 1
37544: ST_TO_ADDR
// end ; continue ;
37545: GO 37113
// end ; for j in tmp do
37547: LD_ADDR_VAR 0 3
37551: PUSH
37552: LD_VAR 0 8
37556: PUSH
37557: FOR_IN
37558: IFFALSE 37894
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37560: LD_VAR 0 3
37564: PUSH
37565: LD_EXP 81
37569: PUSH
37570: LD_VAR 0 2
37574: ARRAY
37575: IN
37576: NOT
37577: PUSH
37578: LD_EXP 81
37582: PUSH
37583: LD_VAR 0 2
37587: ARRAY
37588: PUSH
37589: LD_INT 3
37591: LESS
37592: AND
37593: IFFALSE 37651
// begin SetTag ( j , 121 ) ;
37595: LD_VAR 0 3
37599: PPUSH
37600: LD_INT 121
37602: PPUSH
37603: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37607: LD_ADDR_EXP 81
37611: PUSH
37612: LD_EXP 81
37616: PPUSH
37617: LD_VAR 0 2
37621: PUSH
37622: LD_EXP 81
37626: PUSH
37627: LD_VAR 0 2
37631: ARRAY
37632: PUSH
37633: LD_INT 1
37635: PLUS
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PPUSH
37641: LD_VAR 0 3
37645: PPUSH
37646: CALL 54162 0 3
37650: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37651: LD_VAR 0 3
37655: PUSH
37656: LD_EXP 81
37660: PUSH
37661: LD_VAR 0 2
37665: ARRAY
37666: IN
37667: IFFALSE 37892
// begin if GetClass ( j ) <> 4 then
37669: LD_VAR 0 3
37673: PPUSH
37674: CALL_OW 257
37678: PUSH
37679: LD_INT 4
37681: NONEQUAL
37682: IFFALSE 37735
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37684: LD_ADDR_EXP 81
37688: PUSH
37689: LD_EXP 81
37693: PPUSH
37694: LD_VAR 0 2
37698: PPUSH
37699: LD_EXP 81
37703: PUSH
37704: LD_VAR 0 2
37708: ARRAY
37709: PUSH
37710: LD_VAR 0 3
37714: DIFF
37715: PPUSH
37716: CALL_OW 1
37720: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37721: LD_VAR 0 3
37725: PPUSH
37726: LD_INT 0
37728: PPUSH
37729: CALL_OW 109
// continue ;
37733: GO 37557
// end ; if IsInUnit ( j ) then
37735: LD_VAR 0 3
37739: PPUSH
37740: CALL_OW 310
37744: IFFALSE 37755
// ComExitBuilding ( j ) ;
37746: LD_VAR 0 3
37750: PPUSH
37751: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37755: LD_ADDR_VAR 0 6
37759: PUSH
37760: LD_VAR 0 7
37764: PPUSH
37765: LD_VAR 0 3
37769: PPUSH
37770: CALL_OW 74
37774: ST_TO_ADDR
// if not ape then
37775: LD_VAR 0 6
37779: NOT
37780: IFFALSE 37784
// break ;
37782: GO 37894
// x := GetX ( ape ) ;
37784: LD_ADDR_VAR 0 4
37788: PUSH
37789: LD_VAR 0 6
37793: PPUSH
37794: CALL_OW 250
37798: ST_TO_ADDR
// y := GetY ( ape ) ;
37799: LD_ADDR_VAR 0 5
37803: PUSH
37804: LD_VAR 0 6
37808: PPUSH
37809: CALL_OW 251
37813: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37814: LD_VAR 0 4
37818: PPUSH
37819: LD_VAR 0 5
37823: PPUSH
37824: CALL_OW 488
37828: NOT
37829: PUSH
37830: LD_VAR 0 11
37834: PPUSH
37835: LD_VAR 0 4
37839: PPUSH
37840: LD_VAR 0 5
37844: PPUSH
37845: LD_INT 20
37847: PPUSH
37848: CALL 55058 0 4
37852: PUSH
37853: LD_INT 4
37855: ARRAY
37856: OR
37857: IFFALSE 37861
// break ;
37859: GO 37894
// if not HasTask ( j ) then
37861: LD_VAR 0 3
37865: PPUSH
37866: CALL_OW 314
37870: NOT
37871: IFFALSE 37892
// ComTameXY ( j , x , y ) ;
37873: LD_VAR 0 3
37877: PPUSH
37878: LD_VAR 0 4
37882: PPUSH
37883: LD_VAR 0 5
37887: PPUSH
37888: CALL_OW 131
// end ; end ;
37892: GO 37557
37894: POP
37895: POP
// end ;
37896: GO 37113
37898: POP
37899: POP
// end ;
37900: LD_VAR 0 1
37904: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37905: LD_INT 0
37907: PPUSH
37908: PPUSH
37909: PPUSH
37910: PPUSH
37911: PPUSH
37912: PPUSH
37913: PPUSH
37914: PPUSH
// if not mc_bases then
37915: LD_EXP 50
37919: NOT
37920: IFFALSE 37924
// exit ;
37922: GO 38550
// for i = 1 to mc_bases do
37924: LD_ADDR_VAR 0 2
37928: PUSH
37929: DOUBLE
37930: LD_INT 1
37932: DEC
37933: ST_TO_ADDR
37934: LD_EXP 50
37938: PUSH
37939: FOR_TO
37940: IFFALSE 38548
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37942: LD_EXP 79
37946: PUSH
37947: LD_VAR 0 2
37951: ARRAY
37952: NOT
37953: PUSH
37954: LD_EXP 79
37958: PUSH
37959: LD_VAR 0 2
37963: ARRAY
37964: PPUSH
37965: LD_INT 25
37967: PUSH
37968: LD_INT 12
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PPUSH
37975: CALL_OW 72
37979: NOT
37980: OR
37981: IFFALSE 37985
// continue ;
37983: GO 37939
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37985: LD_ADDR_VAR 0 5
37989: PUSH
37990: LD_EXP 79
37994: PUSH
37995: LD_VAR 0 2
37999: ARRAY
38000: PUSH
38001: LD_INT 1
38003: ARRAY
38004: PPUSH
38005: CALL_OW 255
38009: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38010: LD_VAR 0 5
38014: PPUSH
38015: LD_INT 2
38017: PPUSH
38018: CALL_OW 325
38022: IFFALSE 38275
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38024: LD_ADDR_VAR 0 4
38028: PUSH
38029: LD_EXP 79
38033: PUSH
38034: LD_VAR 0 2
38038: ARRAY
38039: PPUSH
38040: LD_INT 25
38042: PUSH
38043: LD_INT 16
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PPUSH
38050: CALL_OW 72
38054: ST_TO_ADDR
// if tmp < 6 then
38055: LD_VAR 0 4
38059: PUSH
38060: LD_INT 6
38062: LESS
38063: IFFALSE 38275
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38065: LD_ADDR_VAR 0 6
38069: PUSH
38070: LD_EXP 50
38074: PUSH
38075: LD_VAR 0 2
38079: ARRAY
38080: PPUSH
38081: LD_INT 2
38083: PUSH
38084: LD_INT 30
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 30
38096: PUSH
38097: LD_INT 1
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: LIST
38108: PPUSH
38109: CALL_OW 72
38113: ST_TO_ADDR
// if depot then
38114: LD_VAR 0 6
38118: IFFALSE 38275
// begin selected := 0 ;
38120: LD_ADDR_VAR 0 7
38124: PUSH
38125: LD_INT 0
38127: ST_TO_ADDR
// for j in depot do
38128: LD_ADDR_VAR 0 3
38132: PUSH
38133: LD_VAR 0 6
38137: PUSH
38138: FOR_IN
38139: IFFALSE 38170
// begin if UnitsInside ( j ) < 6 then
38141: LD_VAR 0 3
38145: PPUSH
38146: CALL_OW 313
38150: PUSH
38151: LD_INT 6
38153: LESS
38154: IFFALSE 38168
// begin selected := j ;
38156: LD_ADDR_VAR 0 7
38160: PUSH
38161: LD_VAR 0 3
38165: ST_TO_ADDR
// break ;
38166: GO 38170
// end ; end ;
38168: GO 38138
38170: POP
38171: POP
// if selected then
38172: LD_VAR 0 7
38176: IFFALSE 38275
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38178: LD_ADDR_VAR 0 3
38182: PUSH
38183: LD_EXP 79
38187: PUSH
38188: LD_VAR 0 2
38192: ARRAY
38193: PPUSH
38194: LD_INT 25
38196: PUSH
38197: LD_INT 12
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PPUSH
38204: CALL_OW 72
38208: PUSH
38209: FOR_IN
38210: IFFALSE 38273
// if not HasTask ( j ) then
38212: LD_VAR 0 3
38216: PPUSH
38217: CALL_OW 314
38221: NOT
38222: IFFALSE 38271
// begin if not IsInUnit ( j ) then
38224: LD_VAR 0 3
38228: PPUSH
38229: CALL_OW 310
38233: NOT
38234: IFFALSE 38250
// ComEnterUnit ( j , selected ) ;
38236: LD_VAR 0 3
38240: PPUSH
38241: LD_VAR 0 7
38245: PPUSH
38246: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38250: LD_VAR 0 3
38254: PPUSH
38255: LD_INT 16
38257: PPUSH
38258: CALL_OW 183
// AddComExitBuilding ( j ) ;
38262: LD_VAR 0 3
38266: PPUSH
38267: CALL_OW 182
// end ;
38271: GO 38209
38273: POP
38274: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38275: LD_VAR 0 5
38279: PPUSH
38280: LD_INT 11
38282: PPUSH
38283: CALL_OW 325
38287: IFFALSE 38546
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38289: LD_ADDR_VAR 0 4
38293: PUSH
38294: LD_EXP 79
38298: PUSH
38299: LD_VAR 0 2
38303: ARRAY
38304: PPUSH
38305: LD_INT 25
38307: PUSH
38308: LD_INT 16
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PPUSH
38315: CALL_OW 72
38319: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38320: LD_VAR 0 4
38324: PUSH
38325: LD_INT 6
38327: GREATEREQUAL
38328: PUSH
38329: LD_VAR 0 5
38333: PPUSH
38334: LD_INT 2
38336: PPUSH
38337: CALL_OW 325
38341: NOT
38342: OR
38343: IFFALSE 38546
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38345: LD_ADDR_VAR 0 8
38349: PUSH
38350: LD_EXP 50
38354: PUSH
38355: LD_VAR 0 2
38359: ARRAY
38360: PPUSH
38361: LD_INT 2
38363: PUSH
38364: LD_INT 30
38366: PUSH
38367: LD_INT 4
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 30
38376: PUSH
38377: LD_INT 5
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: LIST
38388: PPUSH
38389: CALL_OW 72
38393: ST_TO_ADDR
// if barracks then
38394: LD_VAR 0 8
38398: IFFALSE 38546
// begin selected := 0 ;
38400: LD_ADDR_VAR 0 7
38404: PUSH
38405: LD_INT 0
38407: ST_TO_ADDR
// for j in barracks do
38408: LD_ADDR_VAR 0 3
38412: PUSH
38413: LD_VAR 0 8
38417: PUSH
38418: FOR_IN
38419: IFFALSE 38450
// begin if UnitsInside ( j ) < 6 then
38421: LD_VAR 0 3
38425: PPUSH
38426: CALL_OW 313
38430: PUSH
38431: LD_INT 6
38433: LESS
38434: IFFALSE 38448
// begin selected := j ;
38436: LD_ADDR_VAR 0 7
38440: PUSH
38441: LD_VAR 0 3
38445: ST_TO_ADDR
// break ;
38446: GO 38450
// end ; end ;
38448: GO 38418
38450: POP
38451: POP
// if selected then
38452: LD_VAR 0 7
38456: IFFALSE 38546
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38458: LD_ADDR_VAR 0 3
38462: PUSH
38463: LD_EXP 79
38467: PUSH
38468: LD_VAR 0 2
38472: ARRAY
38473: PPUSH
38474: LD_INT 25
38476: PUSH
38477: LD_INT 12
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PPUSH
38484: CALL_OW 72
38488: PUSH
38489: FOR_IN
38490: IFFALSE 38544
// if not IsInUnit ( j ) and not HasTask ( j ) then
38492: LD_VAR 0 3
38496: PPUSH
38497: CALL_OW 310
38501: NOT
38502: PUSH
38503: LD_VAR 0 3
38507: PPUSH
38508: CALL_OW 314
38512: NOT
38513: AND
38514: IFFALSE 38542
// begin ComEnterUnit ( j , selected ) ;
38516: LD_VAR 0 3
38520: PPUSH
38521: LD_VAR 0 7
38525: PPUSH
38526: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38530: LD_VAR 0 3
38534: PPUSH
38535: LD_INT 15
38537: PPUSH
38538: CALL_OW 183
// end ;
38542: GO 38489
38544: POP
38545: POP
// end ; end ; end ; end ; end ;
38546: GO 37939
38548: POP
38549: POP
// end ;
38550: LD_VAR 0 1
38554: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38555: LD_INT 0
38557: PPUSH
38558: PPUSH
38559: PPUSH
38560: PPUSH
// if not mc_bases then
38561: LD_EXP 50
38565: NOT
38566: IFFALSE 38570
// exit ;
38568: GO 38748
// for i = 1 to mc_bases do
38570: LD_ADDR_VAR 0 2
38574: PUSH
38575: DOUBLE
38576: LD_INT 1
38578: DEC
38579: ST_TO_ADDR
38580: LD_EXP 50
38584: PUSH
38585: FOR_TO
38586: IFFALSE 38746
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38588: LD_ADDR_VAR 0 4
38592: PUSH
38593: LD_EXP 50
38597: PUSH
38598: LD_VAR 0 2
38602: ARRAY
38603: PPUSH
38604: LD_INT 25
38606: PUSH
38607: LD_INT 9
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PPUSH
38614: CALL_OW 72
38618: ST_TO_ADDR
// if not tmp then
38619: LD_VAR 0 4
38623: NOT
38624: IFFALSE 38628
// continue ;
38626: GO 38585
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38628: LD_EXP 76
38632: PUSH
38633: LD_VAR 0 2
38637: ARRAY
38638: PPUSH
38639: LD_INT 29
38641: PPUSH
38642: CALL_OW 325
38646: NOT
38647: PUSH
38648: LD_EXP 76
38652: PUSH
38653: LD_VAR 0 2
38657: ARRAY
38658: PPUSH
38659: LD_INT 28
38661: PPUSH
38662: CALL_OW 325
38666: NOT
38667: AND
38668: IFFALSE 38672
// continue ;
38670: GO 38585
// for j in tmp do
38672: LD_ADDR_VAR 0 3
38676: PUSH
38677: LD_VAR 0 4
38681: PUSH
38682: FOR_IN
38683: IFFALSE 38742
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38685: LD_VAR 0 3
38689: PUSH
38690: LD_EXP 53
38694: PUSH
38695: LD_VAR 0 2
38699: ARRAY
38700: PUSH
38701: LD_INT 1
38703: ARRAY
38704: IN
38705: NOT
38706: PUSH
38707: LD_VAR 0 3
38711: PUSH
38712: LD_EXP 53
38716: PUSH
38717: LD_VAR 0 2
38721: ARRAY
38722: PUSH
38723: LD_INT 2
38725: ARRAY
38726: IN
38727: NOT
38728: AND
38729: IFFALSE 38740
// ComSpaceTimeShoot ( j ) ;
38731: LD_VAR 0 3
38735: PPUSH
38736: CALL 49972 0 1
38740: GO 38682
38742: POP
38743: POP
// end ;
38744: GO 38585
38746: POP
38747: POP
// end ;
38748: LD_VAR 0 1
38752: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38753: LD_INT 0
38755: PPUSH
38756: PPUSH
38757: PPUSH
38758: PPUSH
38759: PPUSH
38760: PPUSH
38761: PPUSH
38762: PPUSH
38763: PPUSH
// if not mc_bases then
38764: LD_EXP 50
38768: NOT
38769: IFFALSE 38773
// exit ;
38771: GO 39395
// for i = 1 to mc_bases do
38773: LD_ADDR_VAR 0 2
38777: PUSH
38778: DOUBLE
38779: LD_INT 1
38781: DEC
38782: ST_TO_ADDR
38783: LD_EXP 50
38787: PUSH
38788: FOR_TO
38789: IFFALSE 39393
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38791: LD_EXP 85
38795: PUSH
38796: LD_VAR 0 2
38800: ARRAY
38801: NOT
38802: PUSH
38803: LD_INT 38
38805: PPUSH
38806: LD_EXP 76
38810: PUSH
38811: LD_VAR 0 2
38815: ARRAY
38816: PPUSH
38817: CALL_OW 321
38821: PUSH
38822: LD_INT 2
38824: NONEQUAL
38825: OR
38826: IFFALSE 38830
// continue ;
38828: GO 38788
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38830: LD_ADDR_VAR 0 8
38834: PUSH
38835: LD_EXP 50
38839: PUSH
38840: LD_VAR 0 2
38844: ARRAY
38845: PPUSH
38846: LD_INT 30
38848: PUSH
38849: LD_INT 34
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PPUSH
38856: CALL_OW 72
38860: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38861: LD_ADDR_VAR 0 9
38865: PUSH
38866: LD_EXP 50
38870: PUSH
38871: LD_VAR 0 2
38875: ARRAY
38876: PPUSH
38877: LD_INT 25
38879: PUSH
38880: LD_INT 4
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PPUSH
38887: CALL_OW 72
38891: PPUSH
38892: LD_INT 0
38894: PPUSH
38895: CALL 84074 0 2
38899: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38900: LD_VAR 0 9
38904: NOT
38905: PUSH
38906: LD_VAR 0 8
38910: NOT
38911: OR
38912: PUSH
38913: LD_EXP 50
38917: PUSH
38918: LD_VAR 0 2
38922: ARRAY
38923: PPUSH
38924: LD_INT 124
38926: PPUSH
38927: CALL 84074 0 2
38931: OR
38932: IFFALSE 38936
// continue ;
38934: GO 38788
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38936: LD_EXP 86
38940: PUSH
38941: LD_VAR 0 2
38945: ARRAY
38946: PUSH
38947: LD_EXP 85
38951: PUSH
38952: LD_VAR 0 2
38956: ARRAY
38957: LESS
38958: PUSH
38959: LD_EXP 86
38963: PUSH
38964: LD_VAR 0 2
38968: ARRAY
38969: PUSH
38970: LD_VAR 0 8
38974: LESS
38975: AND
38976: IFFALSE 39391
// begin tmp := sci [ 1 ] ;
38978: LD_ADDR_VAR 0 7
38982: PUSH
38983: LD_VAR 0 9
38987: PUSH
38988: LD_INT 1
38990: ARRAY
38991: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38992: LD_VAR 0 7
38996: PPUSH
38997: LD_INT 124
38999: PPUSH
39000: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39004: LD_ADDR_VAR 0 3
39008: PUSH
39009: DOUBLE
39010: LD_EXP 85
39014: PUSH
39015: LD_VAR 0 2
39019: ARRAY
39020: INC
39021: ST_TO_ADDR
39022: LD_EXP 85
39026: PUSH
39027: LD_VAR 0 2
39031: ARRAY
39032: PUSH
39033: FOR_DOWNTO
39034: IFFALSE 39377
// begin if IsInUnit ( tmp ) then
39036: LD_VAR 0 7
39040: PPUSH
39041: CALL_OW 310
39045: IFFALSE 39056
// ComExitBuilding ( tmp ) ;
39047: LD_VAR 0 7
39051: PPUSH
39052: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39056: LD_INT 35
39058: PPUSH
39059: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39063: LD_VAR 0 7
39067: PPUSH
39068: CALL_OW 310
39072: NOT
39073: PUSH
39074: LD_VAR 0 7
39078: PPUSH
39079: CALL_OW 314
39083: NOT
39084: AND
39085: IFFALSE 39056
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39087: LD_ADDR_VAR 0 6
39091: PUSH
39092: LD_VAR 0 7
39096: PPUSH
39097: CALL_OW 250
39101: PUSH
39102: LD_VAR 0 7
39106: PPUSH
39107: CALL_OW 251
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39116: LD_INT 35
39118: PPUSH
39119: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39123: LD_ADDR_VAR 0 4
39127: PUSH
39128: LD_EXP 85
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: PUSH
39139: LD_VAR 0 3
39143: ARRAY
39144: PUSH
39145: LD_INT 1
39147: ARRAY
39148: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39149: LD_ADDR_VAR 0 5
39153: PUSH
39154: LD_EXP 85
39158: PUSH
39159: LD_VAR 0 2
39163: ARRAY
39164: PUSH
39165: LD_VAR 0 3
39169: ARRAY
39170: PUSH
39171: LD_INT 2
39173: ARRAY
39174: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39175: LD_VAR 0 7
39179: PPUSH
39180: LD_INT 10
39182: PPUSH
39183: CALL 56759 0 2
39187: PUSH
39188: LD_INT 4
39190: ARRAY
39191: IFFALSE 39229
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39193: LD_VAR 0 7
39197: PPUSH
39198: LD_VAR 0 6
39202: PUSH
39203: LD_INT 1
39205: ARRAY
39206: PPUSH
39207: LD_VAR 0 6
39211: PUSH
39212: LD_INT 2
39214: ARRAY
39215: PPUSH
39216: CALL_OW 111
// wait ( 0 0$10 ) ;
39220: LD_INT 350
39222: PPUSH
39223: CALL_OW 67
// end else
39227: GO 39255
// begin ComMoveXY ( tmp , x , y ) ;
39229: LD_VAR 0 7
39233: PPUSH
39234: LD_VAR 0 4
39238: PPUSH
39239: LD_VAR 0 5
39243: PPUSH
39244: CALL_OW 111
// wait ( 0 0$3 ) ;
39248: LD_INT 105
39250: PPUSH
39251: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39255: LD_VAR 0 7
39259: PPUSH
39260: LD_VAR 0 4
39264: PPUSH
39265: LD_VAR 0 5
39269: PPUSH
39270: CALL_OW 307
39274: IFFALSE 39116
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39276: LD_VAR 0 7
39280: PPUSH
39281: LD_VAR 0 4
39285: PPUSH
39286: LD_VAR 0 5
39290: PPUSH
39291: LD_VAR 0 8
39295: PUSH
39296: LD_VAR 0 3
39300: ARRAY
39301: PPUSH
39302: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39306: LD_INT 35
39308: PPUSH
39309: CALL_OW 67
// until not HasTask ( tmp ) ;
39313: LD_VAR 0 7
39317: PPUSH
39318: CALL_OW 314
39322: NOT
39323: IFFALSE 39306
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39325: LD_ADDR_EXP 86
39329: PUSH
39330: LD_EXP 86
39334: PPUSH
39335: LD_VAR 0 2
39339: PUSH
39340: LD_EXP 86
39344: PUSH
39345: LD_VAR 0 2
39349: ARRAY
39350: PUSH
39351: LD_INT 1
39353: PLUS
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PPUSH
39359: LD_VAR 0 8
39363: PUSH
39364: LD_VAR 0 3
39368: ARRAY
39369: PPUSH
39370: CALL 54162 0 3
39374: ST_TO_ADDR
// end ;
39375: GO 39033
39377: POP
39378: POP
// MC_Reset ( i , 124 ) ;
39379: LD_VAR 0 2
39383: PPUSH
39384: LD_INT 124
39386: PPUSH
39387: CALL 22484 0 2
// end ; end ;
39391: GO 38788
39393: POP
39394: POP
// end ;
39395: LD_VAR 0 1
39399: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39400: LD_INT 0
39402: PPUSH
39403: PPUSH
39404: PPUSH
// if not mc_bases then
39405: LD_EXP 50
39409: NOT
39410: IFFALSE 39414
// exit ;
39412: GO 40020
// for i = 1 to mc_bases do
39414: LD_ADDR_VAR 0 2
39418: PUSH
39419: DOUBLE
39420: LD_INT 1
39422: DEC
39423: ST_TO_ADDR
39424: LD_EXP 50
39428: PUSH
39429: FOR_TO
39430: IFFALSE 40018
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39432: LD_ADDR_VAR 0 3
39436: PUSH
39437: LD_EXP 50
39441: PUSH
39442: LD_VAR 0 2
39446: ARRAY
39447: PPUSH
39448: LD_INT 25
39450: PUSH
39451: LD_INT 4
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PPUSH
39458: CALL_OW 72
39462: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39463: LD_VAR 0 3
39467: NOT
39468: PUSH
39469: LD_EXP 87
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: NOT
39480: OR
39481: PUSH
39482: LD_EXP 50
39486: PUSH
39487: LD_VAR 0 2
39491: ARRAY
39492: PPUSH
39493: LD_INT 2
39495: PUSH
39496: LD_INT 30
39498: PUSH
39499: LD_INT 0
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 30
39508: PUSH
39509: LD_INT 1
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: LIST
39520: PPUSH
39521: CALL_OW 72
39525: NOT
39526: OR
39527: IFFALSE 39577
// begin if mc_deposits_finder [ i ] then
39529: LD_EXP 88
39533: PUSH
39534: LD_VAR 0 2
39538: ARRAY
39539: IFFALSE 39575
// begin MC_Reset ( i , 125 ) ;
39541: LD_VAR 0 2
39545: PPUSH
39546: LD_INT 125
39548: PPUSH
39549: CALL 22484 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39553: LD_ADDR_EXP 88
39557: PUSH
39558: LD_EXP 88
39562: PPUSH
39563: LD_VAR 0 2
39567: PPUSH
39568: EMPTY
39569: PPUSH
39570: CALL_OW 1
39574: ST_TO_ADDR
// end ; continue ;
39575: GO 39429
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39577: LD_EXP 87
39581: PUSH
39582: LD_VAR 0 2
39586: ARRAY
39587: PUSH
39588: LD_INT 1
39590: ARRAY
39591: PUSH
39592: LD_INT 3
39594: ARRAY
39595: PUSH
39596: LD_INT 1
39598: EQUAL
39599: PUSH
39600: LD_INT 20
39602: PPUSH
39603: LD_EXP 76
39607: PUSH
39608: LD_VAR 0 2
39612: ARRAY
39613: PPUSH
39614: CALL_OW 321
39618: PUSH
39619: LD_INT 2
39621: NONEQUAL
39622: AND
39623: IFFALSE 39673
// begin if mc_deposits_finder [ i ] then
39625: LD_EXP 88
39629: PUSH
39630: LD_VAR 0 2
39634: ARRAY
39635: IFFALSE 39671
// begin MC_Reset ( i , 125 ) ;
39637: LD_VAR 0 2
39641: PPUSH
39642: LD_INT 125
39644: PPUSH
39645: CALL 22484 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39649: LD_ADDR_EXP 88
39653: PUSH
39654: LD_EXP 88
39658: PPUSH
39659: LD_VAR 0 2
39663: PPUSH
39664: EMPTY
39665: PPUSH
39666: CALL_OW 1
39670: ST_TO_ADDR
// end ; continue ;
39671: GO 39429
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39673: LD_EXP 87
39677: PUSH
39678: LD_VAR 0 2
39682: ARRAY
39683: PUSH
39684: LD_INT 1
39686: ARRAY
39687: PUSH
39688: LD_INT 1
39690: ARRAY
39691: PPUSH
39692: LD_EXP 87
39696: PUSH
39697: LD_VAR 0 2
39701: ARRAY
39702: PUSH
39703: LD_INT 1
39705: ARRAY
39706: PUSH
39707: LD_INT 2
39709: ARRAY
39710: PPUSH
39711: LD_EXP 76
39715: PUSH
39716: LD_VAR 0 2
39720: ARRAY
39721: PPUSH
39722: CALL_OW 440
39726: IFFALSE 39769
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39728: LD_ADDR_EXP 87
39732: PUSH
39733: LD_EXP 87
39737: PPUSH
39738: LD_VAR 0 2
39742: PPUSH
39743: LD_EXP 87
39747: PUSH
39748: LD_VAR 0 2
39752: ARRAY
39753: PPUSH
39754: LD_INT 1
39756: PPUSH
39757: CALL_OW 3
39761: PPUSH
39762: CALL_OW 1
39766: ST_TO_ADDR
39767: GO 40016
// begin if not mc_deposits_finder [ i ] then
39769: LD_EXP 88
39773: PUSH
39774: LD_VAR 0 2
39778: ARRAY
39779: NOT
39780: IFFALSE 39832
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39782: LD_ADDR_EXP 88
39786: PUSH
39787: LD_EXP 88
39791: PPUSH
39792: LD_VAR 0 2
39796: PPUSH
39797: LD_VAR 0 3
39801: PUSH
39802: LD_INT 1
39804: ARRAY
39805: PUSH
39806: EMPTY
39807: LIST
39808: PPUSH
39809: CALL_OW 1
39813: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39814: LD_VAR 0 3
39818: PUSH
39819: LD_INT 1
39821: ARRAY
39822: PPUSH
39823: LD_INT 125
39825: PPUSH
39826: CALL_OW 109
// end else
39830: GO 40016
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39832: LD_EXP 88
39836: PUSH
39837: LD_VAR 0 2
39841: ARRAY
39842: PUSH
39843: LD_INT 1
39845: ARRAY
39846: PPUSH
39847: CALL_OW 310
39851: IFFALSE 39874
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39853: LD_EXP 88
39857: PUSH
39858: LD_VAR 0 2
39862: ARRAY
39863: PUSH
39864: LD_INT 1
39866: ARRAY
39867: PPUSH
39868: CALL_OW 122
39872: GO 40016
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39874: LD_EXP 88
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PUSH
39885: LD_INT 1
39887: ARRAY
39888: PPUSH
39889: CALL_OW 314
39893: NOT
39894: PUSH
39895: LD_EXP 88
39899: PUSH
39900: LD_VAR 0 2
39904: ARRAY
39905: PUSH
39906: LD_INT 1
39908: ARRAY
39909: PPUSH
39910: LD_EXP 87
39914: PUSH
39915: LD_VAR 0 2
39919: ARRAY
39920: PUSH
39921: LD_INT 1
39923: ARRAY
39924: PUSH
39925: LD_INT 1
39927: ARRAY
39928: PPUSH
39929: LD_EXP 87
39933: PUSH
39934: LD_VAR 0 2
39938: ARRAY
39939: PUSH
39940: LD_INT 1
39942: ARRAY
39943: PUSH
39944: LD_INT 2
39946: ARRAY
39947: PPUSH
39948: CALL_OW 297
39952: PUSH
39953: LD_INT 6
39955: GREATER
39956: AND
39957: IFFALSE 40016
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39959: LD_EXP 88
39963: PUSH
39964: LD_VAR 0 2
39968: ARRAY
39969: PUSH
39970: LD_INT 1
39972: ARRAY
39973: PPUSH
39974: LD_EXP 87
39978: PUSH
39979: LD_VAR 0 2
39983: ARRAY
39984: PUSH
39985: LD_INT 1
39987: ARRAY
39988: PUSH
39989: LD_INT 1
39991: ARRAY
39992: PPUSH
39993: LD_EXP 87
39997: PUSH
39998: LD_VAR 0 2
40002: ARRAY
40003: PUSH
40004: LD_INT 1
40006: ARRAY
40007: PUSH
40008: LD_INT 2
40010: ARRAY
40011: PPUSH
40012: CALL_OW 111
// end ; end ; end ;
40016: GO 39429
40018: POP
40019: POP
// end ;
40020: LD_VAR 0 1
40024: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40025: LD_INT 0
40027: PPUSH
40028: PPUSH
40029: PPUSH
40030: PPUSH
40031: PPUSH
40032: PPUSH
40033: PPUSH
40034: PPUSH
40035: PPUSH
40036: PPUSH
40037: PPUSH
// if not mc_bases then
40038: LD_EXP 50
40042: NOT
40043: IFFALSE 40047
// exit ;
40045: GO 40987
// for i = 1 to mc_bases do
40047: LD_ADDR_VAR 0 2
40051: PUSH
40052: DOUBLE
40053: LD_INT 1
40055: DEC
40056: ST_TO_ADDR
40057: LD_EXP 50
40061: PUSH
40062: FOR_TO
40063: IFFALSE 40985
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40065: LD_EXP 50
40069: PUSH
40070: LD_VAR 0 2
40074: ARRAY
40075: NOT
40076: PUSH
40077: LD_EXP 73
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: OR
40088: IFFALSE 40092
// continue ;
40090: GO 40062
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40092: LD_ADDR_VAR 0 7
40096: PUSH
40097: LD_EXP 50
40101: PUSH
40102: LD_VAR 0 2
40106: ARRAY
40107: PUSH
40108: LD_INT 1
40110: ARRAY
40111: PPUSH
40112: CALL_OW 248
40116: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40117: LD_VAR 0 7
40121: PUSH
40122: LD_INT 3
40124: EQUAL
40125: PUSH
40126: LD_EXP 69
40130: PUSH
40131: LD_VAR 0 2
40135: ARRAY
40136: PUSH
40137: LD_EXP 72
40141: PUSH
40142: LD_VAR 0 2
40146: ARRAY
40147: UNION
40148: PPUSH
40149: LD_INT 33
40151: PUSH
40152: LD_INT 2
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PPUSH
40159: CALL_OW 72
40163: NOT
40164: OR
40165: IFFALSE 40169
// continue ;
40167: GO 40062
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40169: LD_ADDR_VAR 0 9
40173: PUSH
40174: LD_EXP 50
40178: PUSH
40179: LD_VAR 0 2
40183: ARRAY
40184: PPUSH
40185: LD_INT 30
40187: PUSH
40188: LD_INT 36
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PPUSH
40195: CALL_OW 72
40199: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40200: LD_ADDR_VAR 0 10
40204: PUSH
40205: LD_EXP 69
40209: PUSH
40210: LD_VAR 0 2
40214: ARRAY
40215: PPUSH
40216: LD_INT 34
40218: PUSH
40219: LD_INT 31
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PPUSH
40226: CALL_OW 72
40230: ST_TO_ADDR
// if not cts and not mcts then
40231: LD_VAR 0 9
40235: NOT
40236: PUSH
40237: LD_VAR 0 10
40241: NOT
40242: AND
40243: IFFALSE 40247
// continue ;
40245: GO 40062
// x := cts ;
40247: LD_ADDR_VAR 0 11
40251: PUSH
40252: LD_VAR 0 9
40256: ST_TO_ADDR
// if not x then
40257: LD_VAR 0 11
40261: NOT
40262: IFFALSE 40274
// x := mcts ;
40264: LD_ADDR_VAR 0 11
40268: PUSH
40269: LD_VAR 0 10
40273: ST_TO_ADDR
// if not x then
40274: LD_VAR 0 11
40278: NOT
40279: IFFALSE 40283
// continue ;
40281: GO 40062
// if mc_remote_driver [ i ] then
40283: LD_EXP 90
40287: PUSH
40288: LD_VAR 0 2
40292: ARRAY
40293: IFFALSE 40680
// for j in mc_remote_driver [ i ] do
40295: LD_ADDR_VAR 0 3
40299: PUSH
40300: LD_EXP 90
40304: PUSH
40305: LD_VAR 0 2
40309: ARRAY
40310: PUSH
40311: FOR_IN
40312: IFFALSE 40678
// begin if GetClass ( j ) <> 3 then
40314: LD_VAR 0 3
40318: PPUSH
40319: CALL_OW 257
40323: PUSH
40324: LD_INT 3
40326: NONEQUAL
40327: IFFALSE 40380
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40329: LD_ADDR_EXP 90
40333: PUSH
40334: LD_EXP 90
40338: PPUSH
40339: LD_VAR 0 2
40343: PPUSH
40344: LD_EXP 90
40348: PUSH
40349: LD_VAR 0 2
40353: ARRAY
40354: PUSH
40355: LD_VAR 0 3
40359: DIFF
40360: PPUSH
40361: CALL_OW 1
40365: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40366: LD_VAR 0 3
40370: PPUSH
40371: LD_INT 0
40373: PPUSH
40374: CALL_OW 109
// continue ;
40378: GO 40311
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40380: LD_EXP 69
40384: PUSH
40385: LD_VAR 0 2
40389: ARRAY
40390: PPUSH
40391: LD_INT 34
40393: PUSH
40394: LD_INT 31
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 58
40403: PUSH
40404: EMPTY
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: PUSH
40416: LD_VAR 0 3
40420: PPUSH
40421: CALL 84109 0 1
40425: NOT
40426: AND
40427: IFFALSE 40498
// begin if IsInUnit ( j ) then
40429: LD_VAR 0 3
40433: PPUSH
40434: CALL_OW 310
40438: IFFALSE 40449
// ComExitBuilding ( j ) ;
40440: LD_VAR 0 3
40444: PPUSH
40445: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40449: LD_VAR 0 3
40453: PPUSH
40454: LD_EXP 69
40458: PUSH
40459: LD_VAR 0 2
40463: ARRAY
40464: PPUSH
40465: LD_INT 34
40467: PUSH
40468: LD_INT 31
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 58
40477: PUSH
40478: EMPTY
40479: LIST
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PPUSH
40485: CALL_OW 72
40489: PUSH
40490: LD_INT 1
40492: ARRAY
40493: PPUSH
40494: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40498: LD_VAR 0 3
40502: PPUSH
40503: CALL_OW 310
40507: NOT
40508: PUSH
40509: LD_VAR 0 3
40513: PPUSH
40514: CALL_OW 310
40518: PPUSH
40519: CALL_OW 266
40523: PUSH
40524: LD_INT 36
40526: NONEQUAL
40527: PUSH
40528: LD_VAR 0 3
40532: PPUSH
40533: CALL 84109 0 1
40537: NOT
40538: AND
40539: OR
40540: IFFALSE 40676
// begin if IsInUnit ( j ) then
40542: LD_VAR 0 3
40546: PPUSH
40547: CALL_OW 310
40551: IFFALSE 40562
// ComExitBuilding ( j ) ;
40553: LD_VAR 0 3
40557: PPUSH
40558: CALL_OW 122
// ct := 0 ;
40562: LD_ADDR_VAR 0 8
40566: PUSH
40567: LD_INT 0
40569: ST_TO_ADDR
// for k in x do
40570: LD_ADDR_VAR 0 4
40574: PUSH
40575: LD_VAR 0 11
40579: PUSH
40580: FOR_IN
40581: IFFALSE 40654
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40583: LD_VAR 0 4
40587: PPUSH
40588: CALL_OW 264
40592: PUSH
40593: LD_INT 31
40595: EQUAL
40596: PUSH
40597: LD_VAR 0 4
40601: PPUSH
40602: CALL_OW 311
40606: NOT
40607: AND
40608: PUSH
40609: LD_VAR 0 4
40613: PPUSH
40614: CALL_OW 266
40618: PUSH
40619: LD_INT 36
40621: EQUAL
40622: PUSH
40623: LD_VAR 0 4
40627: PPUSH
40628: CALL_OW 313
40632: PUSH
40633: LD_INT 3
40635: LESS
40636: AND
40637: OR
40638: IFFALSE 40652
// begin ct := k ;
40640: LD_ADDR_VAR 0 8
40644: PUSH
40645: LD_VAR 0 4
40649: ST_TO_ADDR
// break ;
40650: GO 40654
// end ;
40652: GO 40580
40654: POP
40655: POP
// if ct then
40656: LD_VAR 0 8
40660: IFFALSE 40676
// ComEnterUnit ( j , ct ) ;
40662: LD_VAR 0 3
40666: PPUSH
40667: LD_VAR 0 8
40671: PPUSH
40672: CALL_OW 120
// end ; end ;
40676: GO 40311
40678: POP
40679: POP
// places := 0 ;
40680: LD_ADDR_VAR 0 5
40684: PUSH
40685: LD_INT 0
40687: ST_TO_ADDR
// for j = 1 to x do
40688: LD_ADDR_VAR 0 3
40692: PUSH
40693: DOUBLE
40694: LD_INT 1
40696: DEC
40697: ST_TO_ADDR
40698: LD_VAR 0 11
40702: PUSH
40703: FOR_TO
40704: IFFALSE 40780
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40706: LD_VAR 0 11
40710: PUSH
40711: LD_VAR 0 3
40715: ARRAY
40716: PPUSH
40717: CALL_OW 264
40721: PUSH
40722: LD_INT 31
40724: EQUAL
40725: IFFALSE 40743
// places := places + 1 else
40727: LD_ADDR_VAR 0 5
40731: PUSH
40732: LD_VAR 0 5
40736: PUSH
40737: LD_INT 1
40739: PLUS
40740: ST_TO_ADDR
40741: GO 40778
// if GetBType ( x [ j ] ) = b_control_tower then
40743: LD_VAR 0 11
40747: PUSH
40748: LD_VAR 0 3
40752: ARRAY
40753: PPUSH
40754: CALL_OW 266
40758: PUSH
40759: LD_INT 36
40761: EQUAL
40762: IFFALSE 40778
// places := places + 3 ;
40764: LD_ADDR_VAR 0 5
40768: PUSH
40769: LD_VAR 0 5
40773: PUSH
40774: LD_INT 3
40776: PLUS
40777: ST_TO_ADDR
40778: GO 40703
40780: POP
40781: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40782: LD_VAR 0 5
40786: PUSH
40787: LD_INT 0
40789: EQUAL
40790: PUSH
40791: LD_VAR 0 5
40795: PUSH
40796: LD_EXP 90
40800: PUSH
40801: LD_VAR 0 2
40805: ARRAY
40806: LESSEQUAL
40807: OR
40808: IFFALSE 40812
// continue ;
40810: GO 40062
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40812: LD_ADDR_VAR 0 6
40816: PUSH
40817: LD_EXP 50
40821: PUSH
40822: LD_VAR 0 2
40826: ARRAY
40827: PPUSH
40828: LD_INT 25
40830: PUSH
40831: LD_INT 3
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PPUSH
40838: CALL_OW 72
40842: PUSH
40843: LD_EXP 90
40847: PUSH
40848: LD_VAR 0 2
40852: ARRAY
40853: DIFF
40854: PPUSH
40855: LD_INT 3
40857: PPUSH
40858: CALL 85009 0 2
40862: ST_TO_ADDR
// for j in tmp do
40863: LD_ADDR_VAR 0 3
40867: PUSH
40868: LD_VAR 0 6
40872: PUSH
40873: FOR_IN
40874: IFFALSE 40909
// if GetTag ( j ) > 0 then
40876: LD_VAR 0 3
40880: PPUSH
40881: CALL_OW 110
40885: PUSH
40886: LD_INT 0
40888: GREATER
40889: IFFALSE 40907
// tmp := tmp diff j ;
40891: LD_ADDR_VAR 0 6
40895: PUSH
40896: LD_VAR 0 6
40900: PUSH
40901: LD_VAR 0 3
40905: DIFF
40906: ST_TO_ADDR
40907: GO 40873
40909: POP
40910: POP
// if not tmp then
40911: LD_VAR 0 6
40915: NOT
40916: IFFALSE 40920
// continue ;
40918: GO 40062
// if places then
40920: LD_VAR 0 5
40924: IFFALSE 40983
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40926: LD_ADDR_EXP 90
40930: PUSH
40931: LD_EXP 90
40935: PPUSH
40936: LD_VAR 0 2
40940: PPUSH
40941: LD_EXP 90
40945: PUSH
40946: LD_VAR 0 2
40950: ARRAY
40951: PUSH
40952: LD_VAR 0 6
40956: PUSH
40957: LD_INT 1
40959: ARRAY
40960: UNION
40961: PPUSH
40962: CALL_OW 1
40966: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40967: LD_VAR 0 6
40971: PUSH
40972: LD_INT 1
40974: ARRAY
40975: PPUSH
40976: LD_INT 126
40978: PPUSH
40979: CALL_OW 109
// end ; end ;
40983: GO 40062
40985: POP
40986: POP
// end ;
40987: LD_VAR 0 1
40991: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40992: LD_INT 0
40994: PPUSH
40995: PPUSH
40996: PPUSH
40997: PPUSH
40998: PPUSH
40999: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41000: LD_VAR 0 1
41004: NOT
41005: PUSH
41006: LD_VAR 0 2
41010: NOT
41011: OR
41012: PUSH
41013: LD_VAR 0 3
41017: NOT
41018: OR
41019: PUSH
41020: LD_VAR 0 4
41024: PUSH
41025: LD_INT 1
41027: PUSH
41028: LD_INT 2
41030: PUSH
41031: LD_INT 3
41033: PUSH
41034: LD_INT 4
41036: PUSH
41037: LD_INT 5
41039: PUSH
41040: LD_INT 8
41042: PUSH
41043: LD_INT 9
41045: PUSH
41046: LD_INT 15
41048: PUSH
41049: LD_INT 16
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: IN
41063: NOT
41064: OR
41065: IFFALSE 41069
// exit ;
41067: GO 41969
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41069: LD_ADDR_VAR 0 2
41073: PUSH
41074: LD_VAR 0 2
41078: PPUSH
41079: LD_INT 21
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 24
41091: PUSH
41092: LD_INT 250
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PPUSH
41103: CALL_OW 72
41107: ST_TO_ADDR
// case class of 1 , 15 :
41108: LD_VAR 0 4
41112: PUSH
41113: LD_INT 1
41115: DOUBLE
41116: EQUAL
41117: IFTRUE 41127
41119: LD_INT 15
41121: DOUBLE
41122: EQUAL
41123: IFTRUE 41127
41125: GO 41212
41127: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41128: LD_ADDR_VAR 0 8
41132: PUSH
41133: LD_VAR 0 2
41137: PPUSH
41138: LD_INT 2
41140: PUSH
41141: LD_INT 30
41143: PUSH
41144: LD_INT 32
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 30
41153: PUSH
41154: LD_INT 31
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: LIST
41165: PPUSH
41166: CALL_OW 72
41170: PUSH
41171: LD_VAR 0 2
41175: PPUSH
41176: LD_INT 2
41178: PUSH
41179: LD_INT 30
41181: PUSH
41182: LD_INT 4
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 30
41191: PUSH
41192: LD_INT 5
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: LIST
41203: PPUSH
41204: CALL_OW 72
41208: ADD
41209: ST_TO_ADDR
41210: GO 41458
41212: LD_INT 2
41214: DOUBLE
41215: EQUAL
41216: IFTRUE 41226
41218: LD_INT 16
41220: DOUBLE
41221: EQUAL
41222: IFTRUE 41226
41224: GO 41272
41226: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41227: LD_ADDR_VAR 0 8
41231: PUSH
41232: LD_VAR 0 2
41236: PPUSH
41237: LD_INT 2
41239: PUSH
41240: LD_INT 30
41242: PUSH
41243: LD_INT 0
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 30
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: LIST
41264: PPUSH
41265: CALL_OW 72
41269: ST_TO_ADDR
41270: GO 41458
41272: LD_INT 3
41274: DOUBLE
41275: EQUAL
41276: IFTRUE 41280
41278: GO 41326
41280: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41281: LD_ADDR_VAR 0 8
41285: PUSH
41286: LD_VAR 0 2
41290: PPUSH
41291: LD_INT 2
41293: PUSH
41294: LD_INT 30
41296: PUSH
41297: LD_INT 2
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 30
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: LIST
41318: PPUSH
41319: CALL_OW 72
41323: ST_TO_ADDR
41324: GO 41458
41326: LD_INT 4
41328: DOUBLE
41329: EQUAL
41330: IFTRUE 41334
41332: GO 41391
41334: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41335: LD_ADDR_VAR 0 8
41339: PUSH
41340: LD_VAR 0 2
41344: PPUSH
41345: LD_INT 2
41347: PUSH
41348: LD_INT 30
41350: PUSH
41351: LD_INT 6
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 30
41360: PUSH
41361: LD_INT 7
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 30
41370: PUSH
41371: LD_INT 8
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: LIST
41382: LIST
41383: PPUSH
41384: CALL_OW 72
41388: ST_TO_ADDR
41389: GO 41458
41391: LD_INT 5
41393: DOUBLE
41394: EQUAL
41395: IFTRUE 41411
41397: LD_INT 8
41399: DOUBLE
41400: EQUAL
41401: IFTRUE 41411
41403: LD_INT 9
41405: DOUBLE
41406: EQUAL
41407: IFTRUE 41411
41409: GO 41457
41411: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41412: LD_ADDR_VAR 0 8
41416: PUSH
41417: LD_VAR 0 2
41421: PPUSH
41422: LD_INT 2
41424: PUSH
41425: LD_INT 30
41427: PUSH
41428: LD_INT 4
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 30
41437: PUSH
41438: LD_INT 5
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: LIST
41449: PPUSH
41450: CALL_OW 72
41454: ST_TO_ADDR
41455: GO 41458
41457: POP
// if not tmp then
41458: LD_VAR 0 8
41462: NOT
41463: IFFALSE 41467
// exit ;
41465: GO 41969
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41467: LD_VAR 0 4
41471: PUSH
41472: LD_INT 1
41474: PUSH
41475: LD_INT 15
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: IN
41482: PUSH
41483: LD_EXP 59
41487: PUSH
41488: LD_VAR 0 1
41492: ARRAY
41493: AND
41494: IFFALSE 41650
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41496: LD_ADDR_VAR 0 9
41500: PUSH
41501: LD_EXP 59
41505: PUSH
41506: LD_VAR 0 1
41510: ARRAY
41511: PUSH
41512: LD_INT 1
41514: ARRAY
41515: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41516: LD_VAR 0 9
41520: PUSH
41521: LD_EXP 60
41525: PUSH
41526: LD_VAR 0 1
41530: ARRAY
41531: IN
41532: NOT
41533: IFFALSE 41648
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41535: LD_ADDR_EXP 60
41539: PUSH
41540: LD_EXP 60
41544: PPUSH
41545: LD_VAR 0 1
41549: PUSH
41550: LD_EXP 60
41554: PUSH
41555: LD_VAR 0 1
41559: ARRAY
41560: PUSH
41561: LD_INT 1
41563: PLUS
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PPUSH
41569: LD_VAR 0 9
41573: PPUSH
41574: CALL 54162 0 3
41578: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41579: LD_ADDR_EXP 59
41583: PUSH
41584: LD_EXP 59
41588: PPUSH
41589: LD_VAR 0 1
41593: PPUSH
41594: LD_EXP 59
41598: PUSH
41599: LD_VAR 0 1
41603: ARRAY
41604: PUSH
41605: LD_VAR 0 9
41609: DIFF
41610: PPUSH
41611: CALL_OW 1
41615: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41616: LD_VAR 0 3
41620: PPUSH
41621: LD_EXP 60
41625: PUSH
41626: LD_VAR 0 1
41630: ARRAY
41631: PUSH
41632: LD_EXP 60
41636: PUSH
41637: LD_VAR 0 1
41641: ARRAY
41642: ARRAY
41643: PPUSH
41644: CALL_OW 120
// end ; exit ;
41648: GO 41969
// end ; if tmp > 1 then
41650: LD_VAR 0 8
41654: PUSH
41655: LD_INT 1
41657: GREATER
41658: IFFALSE 41762
// for i = 2 to tmp do
41660: LD_ADDR_VAR 0 6
41664: PUSH
41665: DOUBLE
41666: LD_INT 2
41668: DEC
41669: ST_TO_ADDR
41670: LD_VAR 0 8
41674: PUSH
41675: FOR_TO
41676: IFFALSE 41760
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41678: LD_VAR 0 8
41682: PUSH
41683: LD_VAR 0 6
41687: ARRAY
41688: PPUSH
41689: CALL_OW 461
41693: PUSH
41694: LD_INT 6
41696: EQUAL
41697: IFFALSE 41758
// begin x := tmp [ i ] ;
41699: LD_ADDR_VAR 0 9
41703: PUSH
41704: LD_VAR 0 8
41708: PUSH
41709: LD_VAR 0 6
41713: ARRAY
41714: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41715: LD_ADDR_VAR 0 8
41719: PUSH
41720: LD_VAR 0 8
41724: PPUSH
41725: LD_VAR 0 6
41729: PPUSH
41730: CALL_OW 3
41734: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41735: LD_ADDR_VAR 0 8
41739: PUSH
41740: LD_VAR 0 8
41744: PPUSH
41745: LD_INT 1
41747: PPUSH
41748: LD_VAR 0 9
41752: PPUSH
41753: CALL_OW 2
41757: ST_TO_ADDR
// end ;
41758: GO 41675
41760: POP
41761: POP
// for i in tmp do
41762: LD_ADDR_VAR 0 6
41766: PUSH
41767: LD_VAR 0 8
41771: PUSH
41772: FOR_IN
41773: IFFALSE 41842
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41775: LD_VAR 0 6
41779: PPUSH
41780: CALL_OW 313
41784: PUSH
41785: LD_INT 6
41787: LESS
41788: PUSH
41789: LD_VAR 0 6
41793: PPUSH
41794: CALL_OW 266
41798: PUSH
41799: LD_INT 31
41801: PUSH
41802: LD_INT 32
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: IN
41809: NOT
41810: AND
41811: PUSH
41812: LD_VAR 0 6
41816: PPUSH
41817: CALL_OW 313
41821: PUSH
41822: LD_INT 0
41824: EQUAL
41825: OR
41826: IFFALSE 41840
// begin j := i ;
41828: LD_ADDR_VAR 0 7
41832: PUSH
41833: LD_VAR 0 6
41837: ST_TO_ADDR
// break ;
41838: GO 41842
// end ; end ;
41840: GO 41772
41842: POP
41843: POP
// if j then
41844: LD_VAR 0 7
41848: IFFALSE 41866
// ComEnterUnit ( unit , j ) else
41850: LD_VAR 0 3
41854: PPUSH
41855: LD_VAR 0 7
41859: PPUSH
41860: CALL_OW 120
41864: GO 41969
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41866: LD_ADDR_VAR 0 10
41870: PUSH
41871: LD_VAR 0 2
41875: PPUSH
41876: LD_INT 2
41878: PUSH
41879: LD_INT 30
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 30
41891: PUSH
41892: LD_INT 1
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: PPUSH
41904: CALL_OW 72
41908: ST_TO_ADDR
// if depot then
41909: LD_VAR 0 10
41913: IFFALSE 41969
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41915: LD_ADDR_VAR 0 10
41919: PUSH
41920: LD_VAR 0 10
41924: PPUSH
41925: LD_VAR 0 3
41929: PPUSH
41930: CALL_OW 74
41934: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41935: LD_VAR 0 3
41939: PPUSH
41940: LD_VAR 0 10
41944: PPUSH
41945: CALL_OW 296
41949: PUSH
41950: LD_INT 10
41952: GREATER
41953: IFFALSE 41969
// ComStandNearbyBuilding ( unit , depot ) ;
41955: LD_VAR 0 3
41959: PPUSH
41960: LD_VAR 0 10
41964: PPUSH
41965: CALL 50589 0 2
// end ; end ; end ;
41969: LD_VAR 0 5
41973: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41974: LD_INT 0
41976: PPUSH
41977: PPUSH
41978: PPUSH
41979: PPUSH
// if not mc_bases then
41980: LD_EXP 50
41984: NOT
41985: IFFALSE 41989
// exit ;
41987: GO 42228
// for i = 1 to mc_bases do
41989: LD_ADDR_VAR 0 2
41993: PUSH
41994: DOUBLE
41995: LD_INT 1
41997: DEC
41998: ST_TO_ADDR
41999: LD_EXP 50
42003: PUSH
42004: FOR_TO
42005: IFFALSE 42226
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42007: LD_ADDR_VAR 0 4
42011: PUSH
42012: LD_EXP 50
42016: PUSH
42017: LD_VAR 0 2
42021: ARRAY
42022: PPUSH
42023: LD_INT 21
42025: PUSH
42026: LD_INT 1
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PPUSH
42033: CALL_OW 72
42037: PUSH
42038: LD_EXP 79
42042: PUSH
42043: LD_VAR 0 2
42047: ARRAY
42048: UNION
42049: ST_TO_ADDR
// if not tmp then
42050: LD_VAR 0 4
42054: NOT
42055: IFFALSE 42059
// continue ;
42057: GO 42004
// for j in tmp do
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: FOR_IN
42070: IFFALSE 42222
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 110
42081: NOT
42082: PUSH
42083: LD_VAR 0 3
42087: PPUSH
42088: CALL_OW 314
42092: NOT
42093: AND
42094: PUSH
42095: LD_VAR 0 3
42099: PPUSH
42100: CALL_OW 311
42104: NOT
42105: AND
42106: PUSH
42107: LD_VAR 0 3
42111: PPUSH
42112: CALL_OW 310
42116: NOT
42117: AND
42118: PUSH
42119: LD_VAR 0 3
42123: PUSH
42124: LD_EXP 53
42128: PUSH
42129: LD_VAR 0 2
42133: ARRAY
42134: PUSH
42135: LD_INT 1
42137: ARRAY
42138: IN
42139: NOT
42140: AND
42141: PUSH
42142: LD_VAR 0 3
42146: PUSH
42147: LD_EXP 53
42151: PUSH
42152: LD_VAR 0 2
42156: ARRAY
42157: PUSH
42158: LD_INT 2
42160: ARRAY
42161: IN
42162: NOT
42163: AND
42164: PUSH
42165: LD_VAR 0 3
42169: PUSH
42170: LD_EXP 62
42174: PUSH
42175: LD_VAR 0 2
42179: ARRAY
42180: IN
42181: NOT
42182: AND
42183: IFFALSE 42220
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42185: LD_VAR 0 2
42189: PPUSH
42190: LD_EXP 50
42194: PUSH
42195: LD_VAR 0 2
42199: ARRAY
42200: PPUSH
42201: LD_VAR 0 3
42205: PPUSH
42206: LD_VAR 0 3
42210: PPUSH
42211: CALL_OW 257
42215: PPUSH
42216: CALL 40992 0 4
// end ;
42220: GO 42069
42222: POP
42223: POP
// end ;
42224: GO 42004
42226: POP
42227: POP
// end ;
42228: LD_VAR 0 1
42232: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
42233: LD_INT 0
42235: PPUSH
42236: PPUSH
42237: PPUSH
42238: PPUSH
42239: PPUSH
42240: PPUSH
// if not mc_bases [ base ] then
42241: LD_EXP 50
42245: PUSH
42246: LD_VAR 0 1
42250: ARRAY
42251: NOT
42252: IFFALSE 42256
// exit ;
42254: GO 42438
// tmp := [ ] ;
42256: LD_ADDR_VAR 0 6
42260: PUSH
42261: EMPTY
42262: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42263: LD_ADDR_VAR 0 7
42267: PUSH
42268: LD_VAR 0 3
42272: PPUSH
42273: LD_INT 0
42275: PPUSH
42276: CALL_OW 517
42280: ST_TO_ADDR
// if not list then
42281: LD_VAR 0 7
42285: NOT
42286: IFFALSE 42290
// exit ;
42288: GO 42438
// for i = 1 to amount do
42290: LD_ADDR_VAR 0 5
42294: PUSH
42295: DOUBLE
42296: LD_INT 1
42298: DEC
42299: ST_TO_ADDR
42300: LD_VAR 0 2
42304: PUSH
42305: FOR_TO
42306: IFFALSE 42386
// begin x := rand ( 1 , list [ 1 ] ) ;
42308: LD_ADDR_VAR 0 8
42312: PUSH
42313: LD_INT 1
42315: PPUSH
42316: LD_VAR 0 7
42320: PUSH
42321: LD_INT 1
42323: ARRAY
42324: PPUSH
42325: CALL_OW 12
42329: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
42330: LD_ADDR_VAR 0 6
42334: PUSH
42335: LD_VAR 0 6
42339: PPUSH
42340: LD_VAR 0 5
42344: PPUSH
42345: LD_VAR 0 7
42349: PUSH
42350: LD_INT 1
42352: ARRAY
42353: PUSH
42354: LD_VAR 0 8
42358: ARRAY
42359: PUSH
42360: LD_VAR 0 7
42364: PUSH
42365: LD_INT 2
42367: ARRAY
42368: PUSH
42369: LD_VAR 0 8
42373: ARRAY
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PPUSH
42379: CALL_OW 1
42383: ST_TO_ADDR
// end ;
42384: GO 42305
42386: POP
42387: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42388: LD_ADDR_EXP 63
42392: PUSH
42393: LD_EXP 63
42397: PPUSH
42398: LD_VAR 0 1
42402: PPUSH
42403: LD_VAR 0 6
42407: PPUSH
42408: CALL_OW 1
42412: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42413: LD_ADDR_EXP 65
42417: PUSH
42418: LD_EXP 65
42422: PPUSH
42423: LD_VAR 0 1
42427: PPUSH
42428: LD_VAR 0 3
42432: PPUSH
42433: CALL_OW 1
42437: ST_TO_ADDR
// end ;
42438: LD_VAR 0 4
42442: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42443: LD_INT 0
42445: PPUSH
// if not mc_bases [ base ] then
42446: LD_EXP 50
42450: PUSH
42451: LD_VAR 0 1
42455: ARRAY
42456: NOT
42457: IFFALSE 42461
// exit ;
42459: GO 42486
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42461: LD_ADDR_EXP 55
42465: PUSH
42466: LD_EXP 55
42470: PPUSH
42471: LD_VAR 0 1
42475: PPUSH
42476: LD_VAR 0 2
42480: PPUSH
42481: CALL_OW 1
42485: ST_TO_ADDR
// end ;
42486: LD_VAR 0 3
42490: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42491: LD_INT 0
42493: PPUSH
// if not mc_bases [ base ] then
42494: LD_EXP 50
42498: PUSH
42499: LD_VAR 0 1
42503: ARRAY
42504: NOT
42505: IFFALSE 42509
// exit ;
42507: GO 42546
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42509: LD_ADDR_EXP 55
42513: PUSH
42514: LD_EXP 55
42518: PPUSH
42519: LD_VAR 0 1
42523: PPUSH
42524: LD_EXP 55
42528: PUSH
42529: LD_VAR 0 1
42533: ARRAY
42534: PUSH
42535: LD_VAR 0 2
42539: UNION
42540: PPUSH
42541: CALL_OW 1
42545: ST_TO_ADDR
// end ;
42546: LD_VAR 0 3
42550: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42551: LD_INT 0
42553: PPUSH
// if not mc_bases [ base ] then
42554: LD_EXP 50
42558: PUSH
42559: LD_VAR 0 1
42563: ARRAY
42564: NOT
42565: IFFALSE 42569
// exit ;
42567: GO 42594
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42569: LD_ADDR_EXP 71
42573: PUSH
42574: LD_EXP 71
42578: PPUSH
42579: LD_VAR 0 1
42583: PPUSH
42584: LD_VAR 0 2
42588: PPUSH
42589: CALL_OW 1
42593: ST_TO_ADDR
// end ;
42594: LD_VAR 0 3
42598: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42599: LD_INT 0
42601: PPUSH
// if not mc_bases [ base ] then
42602: LD_EXP 50
42606: PUSH
42607: LD_VAR 0 1
42611: ARRAY
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 42654
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42617: LD_ADDR_EXP 71
42621: PUSH
42622: LD_EXP 71
42626: PPUSH
42627: LD_VAR 0 1
42631: PPUSH
42632: LD_EXP 71
42636: PUSH
42637: LD_VAR 0 1
42641: ARRAY
42642: PUSH
42643: LD_VAR 0 2
42647: ADD
42648: PPUSH
42649: CALL_OW 1
42653: ST_TO_ADDR
// end ;
42654: LD_VAR 0 3
42658: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42659: LD_INT 0
42661: PPUSH
// if not mc_bases [ base ] then
42662: LD_EXP 50
42666: PUSH
42667: LD_VAR 0 1
42671: ARRAY
42672: NOT
42673: IFFALSE 42677
// exit ;
42675: GO 42731
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42677: LD_ADDR_EXP 72
42681: PUSH
42682: LD_EXP 72
42686: PPUSH
42687: LD_VAR 0 1
42691: PPUSH
42692: LD_VAR 0 2
42696: PPUSH
42697: CALL_OW 1
42701: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42702: LD_ADDR_EXP 61
42706: PUSH
42707: LD_EXP 61
42711: PPUSH
42712: LD_VAR 0 1
42716: PPUSH
42717: LD_VAR 0 2
42721: PUSH
42722: LD_INT 0
42724: PLUS
42725: PPUSH
42726: CALL_OW 1
42730: ST_TO_ADDR
// end ;
42731: LD_VAR 0 3
42735: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42736: LD_INT 0
42738: PPUSH
// if not mc_bases [ base ] then
42739: LD_EXP 50
42743: PUSH
42744: LD_VAR 0 1
42748: ARRAY
42749: NOT
42750: IFFALSE 42754
// exit ;
42752: GO 42779
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42754: LD_ADDR_EXP 61
42758: PUSH
42759: LD_EXP 61
42763: PPUSH
42764: LD_VAR 0 1
42768: PPUSH
42769: LD_VAR 0 2
42773: PPUSH
42774: CALL_OW 1
42778: ST_TO_ADDR
// end ;
42779: LD_VAR 0 3
42783: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42784: LD_INT 0
42786: PPUSH
42787: PPUSH
42788: PPUSH
42789: PPUSH
// if not mc_bases [ base ] then
42790: LD_EXP 50
42794: PUSH
42795: LD_VAR 0 1
42799: ARRAY
42800: NOT
42801: IFFALSE 42805
// exit ;
42803: GO 42870
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42805: LD_ADDR_EXP 70
42809: PUSH
42810: LD_EXP 70
42814: PPUSH
42815: LD_VAR 0 1
42819: PUSH
42820: LD_EXP 70
42824: PUSH
42825: LD_VAR 0 1
42829: ARRAY
42830: PUSH
42831: LD_INT 1
42833: PLUS
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PPUSH
42839: LD_VAR 0 1
42843: PUSH
42844: LD_VAR 0 2
42848: PUSH
42849: LD_VAR 0 3
42853: PUSH
42854: LD_VAR 0 4
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: PPUSH
42865: CALL 54162 0 3
42869: ST_TO_ADDR
// end ;
42870: LD_VAR 0 5
42874: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42875: LD_INT 0
42877: PPUSH
// if not mc_bases [ base ] then
42878: LD_EXP 50
42882: PUSH
42883: LD_VAR 0 1
42887: ARRAY
42888: NOT
42889: IFFALSE 42893
// exit ;
42891: GO 42918
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42893: LD_ADDR_EXP 87
42897: PUSH
42898: LD_EXP 87
42902: PPUSH
42903: LD_VAR 0 1
42907: PPUSH
42908: LD_VAR 0 2
42912: PPUSH
42913: CALL_OW 1
42917: ST_TO_ADDR
// end ;
42918: LD_VAR 0 3
42922: RET
// export function MC_GetMinesField ( base ) ; begin
42923: LD_INT 0
42925: PPUSH
// result := mc_mines [ base ] ;
42926: LD_ADDR_VAR 0 2
42930: PUSH
42931: LD_EXP 63
42935: PUSH
42936: LD_VAR 0 1
42940: ARRAY
42941: ST_TO_ADDR
// end ;
42942: LD_VAR 0 2
42946: RET
// export function MC_GetProduceList ( base ) ; begin
42947: LD_INT 0
42949: PPUSH
// result := mc_produce [ base ] ;
42950: LD_ADDR_VAR 0 2
42954: PUSH
42955: LD_EXP 71
42959: PUSH
42960: LD_VAR 0 1
42964: ARRAY
42965: ST_TO_ADDR
// end ;
42966: LD_VAR 0 2
42970: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42971: LD_INT 0
42973: PPUSH
42974: PPUSH
// if not mc_bases then
42975: LD_EXP 50
42979: NOT
42980: IFFALSE 42984
// exit ;
42982: GO 43049
// if mc_bases [ base ] then
42984: LD_EXP 50
42988: PUSH
42989: LD_VAR 0 1
42993: ARRAY
42994: IFFALSE 43049
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42996: LD_ADDR_VAR 0 3
43000: PUSH
43001: LD_EXP 50
43005: PUSH
43006: LD_VAR 0 1
43010: ARRAY
43011: PPUSH
43012: LD_INT 30
43014: PUSH
43015: LD_VAR 0 2
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PPUSH
43024: CALL_OW 72
43028: ST_TO_ADDR
// if result then
43029: LD_VAR 0 3
43033: IFFALSE 43049
// result := result [ 1 ] ;
43035: LD_ADDR_VAR 0 3
43039: PUSH
43040: LD_VAR 0 3
43044: PUSH
43045: LD_INT 1
43047: ARRAY
43048: ST_TO_ADDR
// end ; end ;
43049: LD_VAR 0 3
43053: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43054: LD_INT 0
43056: PPUSH
43057: PPUSH
// if not mc_bases then
43058: LD_EXP 50
43062: NOT
43063: IFFALSE 43067
// exit ;
43065: GO 43112
// if mc_bases [ base ] then
43067: LD_EXP 50
43071: PUSH
43072: LD_VAR 0 1
43076: ARRAY
43077: IFFALSE 43112
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43079: LD_ADDR_VAR 0 3
43083: PUSH
43084: LD_EXP 50
43088: PUSH
43089: LD_VAR 0 1
43093: ARRAY
43094: PPUSH
43095: LD_INT 30
43097: PUSH
43098: LD_VAR 0 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PPUSH
43107: CALL_OW 72
43111: ST_TO_ADDR
// end ;
43112: LD_VAR 0 3
43116: RET
// export function MC_SetTame ( base , area ) ; begin
43117: LD_INT 0
43119: PPUSH
// if not mc_bases or not base then
43120: LD_EXP 50
43124: NOT
43125: PUSH
43126: LD_VAR 0 1
43130: NOT
43131: OR
43132: IFFALSE 43136
// exit ;
43134: GO 43161
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43136: LD_ADDR_EXP 78
43140: PUSH
43141: LD_EXP 78
43145: PPUSH
43146: LD_VAR 0 1
43150: PPUSH
43151: LD_VAR 0 2
43155: PPUSH
43156: CALL_OW 1
43160: ST_TO_ADDR
// end ;
43161: LD_VAR 0 3
43165: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43166: LD_INT 0
43168: PPUSH
43169: PPUSH
// if not mc_bases or not base then
43170: LD_EXP 50
43174: NOT
43175: PUSH
43176: LD_VAR 0 1
43180: NOT
43181: OR
43182: IFFALSE 43186
// exit ;
43184: GO 43288
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43186: LD_ADDR_VAR 0 4
43190: PUSH
43191: LD_EXP 50
43195: PUSH
43196: LD_VAR 0 1
43200: ARRAY
43201: PPUSH
43202: LD_INT 30
43204: PUSH
43205: LD_VAR 0 2
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PPUSH
43214: CALL_OW 72
43218: ST_TO_ADDR
// if not tmp then
43219: LD_VAR 0 4
43223: NOT
43224: IFFALSE 43228
// exit ;
43226: GO 43288
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43228: LD_ADDR_EXP 82
43232: PUSH
43233: LD_EXP 82
43237: PPUSH
43238: LD_VAR 0 1
43242: PPUSH
43243: LD_EXP 82
43247: PUSH
43248: LD_VAR 0 1
43252: ARRAY
43253: PPUSH
43254: LD_EXP 82
43258: PUSH
43259: LD_VAR 0 1
43263: ARRAY
43264: PUSH
43265: LD_INT 1
43267: PLUS
43268: PPUSH
43269: LD_VAR 0 4
43273: PUSH
43274: LD_INT 1
43276: ARRAY
43277: PPUSH
43278: CALL_OW 2
43282: PPUSH
43283: CALL_OW 1
43287: ST_TO_ADDR
// end ;
43288: LD_VAR 0 3
43292: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43293: LD_INT 0
43295: PPUSH
43296: PPUSH
// if not mc_bases or not base or not kinds then
43297: LD_EXP 50
43301: NOT
43302: PUSH
43303: LD_VAR 0 1
43307: NOT
43308: OR
43309: PUSH
43310: LD_VAR 0 2
43314: NOT
43315: OR
43316: IFFALSE 43320
// exit ;
43318: GO 43381
// for i in kinds do
43320: LD_ADDR_VAR 0 4
43324: PUSH
43325: LD_VAR 0 2
43329: PUSH
43330: FOR_IN
43331: IFFALSE 43379
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43333: LD_ADDR_EXP 84
43337: PUSH
43338: LD_EXP 84
43342: PPUSH
43343: LD_VAR 0 1
43347: PUSH
43348: LD_EXP 84
43352: PUSH
43353: LD_VAR 0 1
43357: ARRAY
43358: PUSH
43359: LD_INT 1
43361: PLUS
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PPUSH
43367: LD_VAR 0 4
43371: PPUSH
43372: CALL 54162 0 3
43376: ST_TO_ADDR
43377: GO 43330
43379: POP
43380: POP
// end ;
43381: LD_VAR 0 3
43385: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43386: LD_INT 0
43388: PPUSH
// if not mc_bases or not base or not areas then
43389: LD_EXP 50
43393: NOT
43394: PUSH
43395: LD_VAR 0 1
43399: NOT
43400: OR
43401: PUSH
43402: LD_VAR 0 2
43406: NOT
43407: OR
43408: IFFALSE 43412
// exit ;
43410: GO 43437
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43412: LD_ADDR_EXP 68
43416: PUSH
43417: LD_EXP 68
43421: PPUSH
43422: LD_VAR 0 1
43426: PPUSH
43427: LD_VAR 0 2
43431: PPUSH
43432: CALL_OW 1
43436: ST_TO_ADDR
// end ;
43437: LD_VAR 0 3
43441: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43442: LD_INT 0
43444: PPUSH
// if not mc_bases or not base or not teleports_exit then
43445: LD_EXP 50
43449: NOT
43450: PUSH
43451: LD_VAR 0 1
43455: NOT
43456: OR
43457: PUSH
43458: LD_VAR 0 2
43462: NOT
43463: OR
43464: IFFALSE 43468
// exit ;
43466: GO 43493
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43468: LD_ADDR_EXP 85
43472: PUSH
43473: LD_EXP 85
43477: PPUSH
43478: LD_VAR 0 1
43482: PPUSH
43483: LD_VAR 0 2
43487: PPUSH
43488: CALL_OW 1
43492: ST_TO_ADDR
// end ;
43493: LD_VAR 0 3
43497: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43498: LD_INT 0
43500: PPUSH
43501: PPUSH
43502: PPUSH
// if not mc_bases or not base or not ext_list then
43503: LD_EXP 50
43507: NOT
43508: PUSH
43509: LD_VAR 0 1
43513: NOT
43514: OR
43515: PUSH
43516: LD_VAR 0 5
43520: NOT
43521: OR
43522: IFFALSE 43526
// exit ;
43524: GO 43699
// tmp := GetFacExtXYD ( x , y , d ) ;
43526: LD_ADDR_VAR 0 8
43530: PUSH
43531: LD_VAR 0 2
43535: PPUSH
43536: LD_VAR 0 3
43540: PPUSH
43541: LD_VAR 0 4
43545: PPUSH
43546: CALL 84139 0 3
43550: ST_TO_ADDR
// if not tmp then
43551: LD_VAR 0 8
43555: NOT
43556: IFFALSE 43560
// exit ;
43558: GO 43699
// for i in tmp do
43560: LD_ADDR_VAR 0 7
43564: PUSH
43565: LD_VAR 0 8
43569: PUSH
43570: FOR_IN
43571: IFFALSE 43697
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43573: LD_ADDR_EXP 55
43577: PUSH
43578: LD_EXP 55
43582: PPUSH
43583: LD_VAR 0 1
43587: PPUSH
43588: LD_EXP 55
43592: PUSH
43593: LD_VAR 0 1
43597: ARRAY
43598: PPUSH
43599: LD_EXP 55
43603: PUSH
43604: LD_VAR 0 1
43608: ARRAY
43609: PUSH
43610: LD_INT 1
43612: PLUS
43613: PPUSH
43614: LD_VAR 0 5
43618: PUSH
43619: LD_INT 1
43621: ARRAY
43622: PUSH
43623: LD_VAR 0 7
43627: PUSH
43628: LD_INT 1
43630: ARRAY
43631: PUSH
43632: LD_VAR 0 7
43636: PUSH
43637: LD_INT 2
43639: ARRAY
43640: PUSH
43641: LD_VAR 0 7
43645: PUSH
43646: LD_INT 3
43648: ARRAY
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: LIST
43654: LIST
43655: PPUSH
43656: CALL_OW 2
43660: PPUSH
43661: CALL_OW 1
43665: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43666: LD_ADDR_VAR 0 5
43670: PUSH
43671: LD_VAR 0 5
43675: PPUSH
43676: LD_INT 1
43678: PPUSH
43679: CALL_OW 3
43683: ST_TO_ADDR
// if not ext_list then
43684: LD_VAR 0 5
43688: NOT
43689: IFFALSE 43695
// exit ;
43691: POP
43692: POP
43693: GO 43699
// end ;
43695: GO 43570
43697: POP
43698: POP
// end ;
43699: LD_VAR 0 6
43703: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43704: LD_INT 0
43706: PPUSH
// if not mc_bases or not base or not weapon_list then
43707: LD_EXP 50
43711: NOT
43712: PUSH
43713: LD_VAR 0 1
43717: NOT
43718: OR
43719: PUSH
43720: LD_VAR 0 2
43724: NOT
43725: OR
43726: IFFALSE 43730
// exit ;
43728: GO 43755
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43730: LD_ADDR_EXP 89
43734: PUSH
43735: LD_EXP 89
43739: PPUSH
43740: LD_VAR 0 1
43744: PPUSH
43745: LD_VAR 0 2
43749: PPUSH
43750: CALL_OW 1
43754: ST_TO_ADDR
// end ;
43755: LD_VAR 0 3
43759: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43760: LD_INT 0
43762: PPUSH
// if not mc_bases or not base or not tech_list then
43763: LD_EXP 50
43767: NOT
43768: PUSH
43769: LD_VAR 0 1
43773: NOT
43774: OR
43775: PUSH
43776: LD_VAR 0 2
43780: NOT
43781: OR
43782: IFFALSE 43786
// exit ;
43784: GO 43811
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43786: LD_ADDR_EXP 77
43790: PUSH
43791: LD_EXP 77
43795: PPUSH
43796: LD_VAR 0 1
43800: PPUSH
43801: LD_VAR 0 2
43805: PPUSH
43806: CALL_OW 1
43810: ST_TO_ADDR
// end ;
43811: LD_VAR 0 3
43815: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43816: LD_INT 0
43818: PPUSH
// if not mc_bases or not parking_area or not base then
43819: LD_EXP 50
43823: NOT
43824: PUSH
43825: LD_VAR 0 2
43829: NOT
43830: OR
43831: PUSH
43832: LD_VAR 0 1
43836: NOT
43837: OR
43838: IFFALSE 43842
// exit ;
43840: GO 43867
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43842: LD_ADDR_EXP 74
43846: PUSH
43847: LD_EXP 74
43851: PPUSH
43852: LD_VAR 0 1
43856: PPUSH
43857: LD_VAR 0 2
43861: PPUSH
43862: CALL_OW 1
43866: ST_TO_ADDR
// end ;
43867: LD_VAR 0 3
43871: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43872: LD_INT 0
43874: PPUSH
// if not mc_bases or not base or not scan_area then
43875: LD_EXP 50
43879: NOT
43880: PUSH
43881: LD_VAR 0 1
43885: NOT
43886: OR
43887: PUSH
43888: LD_VAR 0 2
43892: NOT
43893: OR
43894: IFFALSE 43898
// exit ;
43896: GO 43923
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43898: LD_ADDR_EXP 75
43902: PUSH
43903: LD_EXP 75
43907: PPUSH
43908: LD_VAR 0 1
43912: PPUSH
43913: LD_VAR 0 2
43917: PPUSH
43918: CALL_OW 1
43922: ST_TO_ADDR
// end ;
43923: LD_VAR 0 3
43927: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43928: LD_INT 0
43930: PPUSH
43931: PPUSH
// if not mc_bases or not base then
43932: LD_EXP 50
43936: NOT
43937: PUSH
43938: LD_VAR 0 1
43942: NOT
43943: OR
43944: IFFALSE 43948
// exit ;
43946: GO 44012
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43948: LD_ADDR_VAR 0 3
43952: PUSH
43953: LD_INT 1
43955: PUSH
43956: LD_INT 2
43958: PUSH
43959: LD_INT 3
43961: PUSH
43962: LD_INT 4
43964: PUSH
43965: LD_INT 11
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43975: LD_ADDR_EXP 77
43979: PUSH
43980: LD_EXP 77
43984: PPUSH
43985: LD_VAR 0 1
43989: PPUSH
43990: LD_EXP 77
43994: PUSH
43995: LD_VAR 0 1
43999: ARRAY
44000: PUSH
44001: LD_VAR 0 3
44005: DIFF
44006: PPUSH
44007: CALL_OW 1
44011: ST_TO_ADDR
// end ;
44012: LD_VAR 0 2
44016: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44017: LD_INT 0
44019: PPUSH
// result := mc_vehicles [ base ] ;
44020: LD_ADDR_VAR 0 3
44024: PUSH
44025: LD_EXP 69
44029: PUSH
44030: LD_VAR 0 1
44034: ARRAY
44035: ST_TO_ADDR
// if onlyCombat then
44036: LD_VAR 0 2
44040: IFFALSE 44212
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44042: LD_ADDR_VAR 0 3
44046: PUSH
44047: LD_VAR 0 3
44051: PUSH
44052: LD_VAR 0 3
44056: PPUSH
44057: LD_INT 2
44059: PUSH
44060: LD_INT 34
44062: PUSH
44063: LD_INT 12
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 34
44072: PUSH
44073: LD_INT 51
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 34
44082: PUSH
44083: LD_INT 89
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: PUSH
44090: LD_INT 34
44092: PUSH
44093: LD_INT 32
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 34
44102: PUSH
44103: LD_INT 13
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 34
44112: PUSH
44113: LD_INT 52
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 34
44122: PUSH
44123: LD_INT 88
44125: PUSH
44126: EMPTY
44127: LIST
44128: LIST
44129: PUSH
44130: LD_INT 34
44132: PUSH
44133: LD_INT 14
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 53
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 34
44152: PUSH
44153: LD_INT 98
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 31
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 48
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 34
44182: PUSH
44183: LD_INT 8
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: LIST
44203: LIST
44204: LIST
44205: PPUSH
44206: CALL_OW 72
44210: DIFF
44211: ST_TO_ADDR
// end ; end_of_file
44212: LD_VAR 0 3
44216: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44217: LD_INT 0
44219: PPUSH
44220: PPUSH
44221: PPUSH
// if not mc_bases or not skirmish then
44222: LD_EXP 50
44226: NOT
44227: PUSH
44228: LD_EXP 48
44232: NOT
44233: OR
44234: IFFALSE 44238
// exit ;
44236: GO 44403
// for i = 1 to mc_bases do
44238: LD_ADDR_VAR 0 4
44242: PUSH
44243: DOUBLE
44244: LD_INT 1
44246: DEC
44247: ST_TO_ADDR
44248: LD_EXP 50
44252: PUSH
44253: FOR_TO
44254: IFFALSE 44401
// begin if sci in mc_bases [ i ] then
44256: LD_VAR 0 2
44260: PUSH
44261: LD_EXP 50
44265: PUSH
44266: LD_VAR 0 4
44270: ARRAY
44271: IN
44272: IFFALSE 44399
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44274: LD_ADDR_EXP 79
44278: PUSH
44279: LD_EXP 79
44283: PPUSH
44284: LD_VAR 0 4
44288: PUSH
44289: LD_EXP 79
44293: PUSH
44294: LD_VAR 0 4
44298: ARRAY
44299: PUSH
44300: LD_INT 1
44302: PLUS
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PPUSH
44308: LD_VAR 0 1
44312: PPUSH
44313: CALL 54162 0 3
44317: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44318: LD_ADDR_VAR 0 5
44322: PUSH
44323: LD_EXP 50
44327: PUSH
44328: LD_VAR 0 4
44332: ARRAY
44333: PPUSH
44334: LD_INT 2
44336: PUSH
44337: LD_INT 30
44339: PUSH
44340: LD_INT 0
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 30
44349: PUSH
44350: LD_INT 1
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: LIST
44361: PPUSH
44362: CALL_OW 72
44366: PPUSH
44367: LD_VAR 0 1
44371: PPUSH
44372: CALL_OW 74
44376: ST_TO_ADDR
// if tmp then
44377: LD_VAR 0 5
44381: IFFALSE 44397
// ComStandNearbyBuilding ( ape , tmp ) ;
44383: LD_VAR 0 1
44387: PPUSH
44388: LD_VAR 0 5
44392: PPUSH
44393: CALL 50589 0 2
// break ;
44397: GO 44401
// end ; end ;
44399: GO 44253
44401: POP
44402: POP
// end ;
44403: LD_VAR 0 3
44407: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44408: LD_INT 0
44410: PPUSH
44411: PPUSH
44412: PPUSH
// if not mc_bases or not skirmish then
44413: LD_EXP 50
44417: NOT
44418: PUSH
44419: LD_EXP 48
44423: NOT
44424: OR
44425: IFFALSE 44429
// exit ;
44427: GO 44518
// for i = 1 to mc_bases do
44429: LD_ADDR_VAR 0 4
44433: PUSH
44434: DOUBLE
44435: LD_INT 1
44437: DEC
44438: ST_TO_ADDR
44439: LD_EXP 50
44443: PUSH
44444: FOR_TO
44445: IFFALSE 44516
// begin if building in mc_busy_turret_list [ i ] then
44447: LD_VAR 0 1
44451: PUSH
44452: LD_EXP 60
44456: PUSH
44457: LD_VAR 0 4
44461: ARRAY
44462: IN
44463: IFFALSE 44514
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44465: LD_ADDR_VAR 0 5
44469: PUSH
44470: LD_EXP 60
44474: PUSH
44475: LD_VAR 0 4
44479: ARRAY
44480: PUSH
44481: LD_VAR 0 1
44485: DIFF
44486: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44487: LD_ADDR_EXP 60
44491: PUSH
44492: LD_EXP 60
44496: PPUSH
44497: LD_VAR 0 4
44501: PPUSH
44502: LD_VAR 0 5
44506: PPUSH
44507: CALL_OW 1
44511: ST_TO_ADDR
// break ;
44512: GO 44516
// end ; end ;
44514: GO 44444
44516: POP
44517: POP
// end ;
44518: LD_VAR 0 3
44522: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44523: LD_INT 0
44525: PPUSH
44526: PPUSH
44527: PPUSH
// if not mc_bases or not skirmish then
44528: LD_EXP 50
44532: NOT
44533: PUSH
44534: LD_EXP 48
44538: NOT
44539: OR
44540: IFFALSE 44544
// exit ;
44542: GO 44743
// for i = 1 to mc_bases do
44544: LD_ADDR_VAR 0 5
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_EXP 50
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44741
// if building in mc_bases [ i ] then
44562: LD_VAR 0 1
44566: PUSH
44567: LD_EXP 50
44571: PUSH
44572: LD_VAR 0 5
44576: ARRAY
44577: IN
44578: IFFALSE 44739
// begin tmp := mc_bases [ i ] diff building ;
44580: LD_ADDR_VAR 0 6
44584: PUSH
44585: LD_EXP 50
44589: PUSH
44590: LD_VAR 0 5
44594: ARRAY
44595: PUSH
44596: LD_VAR 0 1
44600: DIFF
44601: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44602: LD_ADDR_EXP 50
44606: PUSH
44607: LD_EXP 50
44611: PPUSH
44612: LD_VAR 0 5
44616: PPUSH
44617: LD_VAR 0 6
44621: PPUSH
44622: CALL_OW 1
44626: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44627: LD_VAR 0 1
44631: PUSH
44632: LD_EXP 58
44636: PUSH
44637: LD_VAR 0 5
44641: ARRAY
44642: IN
44643: IFFALSE 44682
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44645: LD_ADDR_EXP 58
44649: PUSH
44650: LD_EXP 58
44654: PPUSH
44655: LD_VAR 0 5
44659: PPUSH
44660: LD_EXP 58
44664: PUSH
44665: LD_VAR 0 5
44669: ARRAY
44670: PUSH
44671: LD_VAR 0 1
44675: DIFF
44676: PPUSH
44677: CALL_OW 1
44681: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44682: LD_VAR 0 1
44686: PUSH
44687: LD_EXP 59
44691: PUSH
44692: LD_VAR 0 5
44696: ARRAY
44697: IN
44698: IFFALSE 44737
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44700: LD_ADDR_EXP 59
44704: PUSH
44705: LD_EXP 59
44709: PPUSH
44710: LD_VAR 0 5
44714: PPUSH
44715: LD_EXP 59
44719: PUSH
44720: LD_VAR 0 5
44724: ARRAY
44725: PUSH
44726: LD_VAR 0 1
44730: DIFF
44731: PPUSH
44732: CALL_OW 1
44736: ST_TO_ADDR
// break ;
44737: GO 44741
// end ;
44739: GO 44559
44741: POP
44742: POP
// end ;
44743: LD_VAR 0 4
44747: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44748: LD_INT 0
44750: PPUSH
44751: PPUSH
44752: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44753: LD_EXP 50
44757: NOT
44758: PUSH
44759: LD_EXP 48
44763: NOT
44764: OR
44765: PUSH
44766: LD_VAR 0 3
44770: PUSH
44771: LD_EXP 76
44775: IN
44776: NOT
44777: OR
44778: IFFALSE 44782
// exit ;
44780: GO 44905
// for i = 1 to mc_vehicles do
44782: LD_ADDR_VAR 0 6
44786: PUSH
44787: DOUBLE
44788: LD_INT 1
44790: DEC
44791: ST_TO_ADDR
44792: LD_EXP 69
44796: PUSH
44797: FOR_TO
44798: IFFALSE 44903
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44800: LD_VAR 0 2
44804: PUSH
44805: LD_EXP 69
44809: PUSH
44810: LD_VAR 0 6
44814: ARRAY
44815: IN
44816: PUSH
44817: LD_VAR 0 1
44821: PUSH
44822: LD_EXP 69
44826: PUSH
44827: LD_VAR 0 6
44831: ARRAY
44832: IN
44833: OR
44834: IFFALSE 44901
// begin tmp := mc_vehicles [ i ] diff old ;
44836: LD_ADDR_VAR 0 7
44840: PUSH
44841: LD_EXP 69
44845: PUSH
44846: LD_VAR 0 6
44850: ARRAY
44851: PUSH
44852: LD_VAR 0 2
44856: DIFF
44857: ST_TO_ADDR
// tmp := tmp diff new ;
44858: LD_ADDR_VAR 0 7
44862: PUSH
44863: LD_VAR 0 7
44867: PUSH
44868: LD_VAR 0 1
44872: DIFF
44873: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44874: LD_ADDR_EXP 69
44878: PUSH
44879: LD_EXP 69
44883: PPUSH
44884: LD_VAR 0 6
44888: PPUSH
44889: LD_VAR 0 7
44893: PPUSH
44894: CALL_OW 1
44898: ST_TO_ADDR
// break ;
44899: GO 44903
// end ;
44901: GO 44797
44903: POP
44904: POP
// end ;
44905: LD_VAR 0 5
44909: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44910: LD_INT 0
44912: PPUSH
44913: PPUSH
44914: PPUSH
44915: PPUSH
// if not mc_bases or not skirmish then
44916: LD_EXP 50
44920: NOT
44921: PUSH
44922: LD_EXP 48
44926: NOT
44927: OR
44928: IFFALSE 44932
// exit ;
44930: GO 45352
// repeat wait ( 0 0$1 ) ;
44932: LD_INT 35
44934: PPUSH
44935: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
44939: LD_EXP 94
44943: NOT
44944: IFFALSE 44932
// mc_block_vehicle_constructed_thread := true ;
44946: LD_ADDR_EXP 94
44950: PUSH
44951: LD_INT 1
44953: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
44954: LD_ADDR_VAR 0 5
44958: PUSH
44959: LD_VAR 0 1
44963: PPUSH
44964: CALL_OW 255
44968: ST_TO_ADDR
// for i = 1 to mc_bases do
44969: LD_ADDR_VAR 0 4
44973: PUSH
44974: DOUBLE
44975: LD_INT 1
44977: DEC
44978: ST_TO_ADDR
44979: LD_EXP 50
44983: PUSH
44984: FOR_TO
44985: IFFALSE 45342
// begin if factory in mc_bases [ i ] then
44987: LD_VAR 0 2
44991: PUSH
44992: LD_EXP 50
44996: PUSH
44997: LD_VAR 0 4
45001: ARRAY
45002: IN
45003: IFFALSE 45340
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45005: LD_EXP 72
45009: PUSH
45010: LD_VAR 0 4
45014: ARRAY
45015: PUSH
45016: LD_EXP 61
45020: PUSH
45021: LD_VAR 0 4
45025: ARRAY
45026: LESS
45027: PUSH
45028: LD_VAR 0 1
45032: PPUSH
45033: CALL_OW 264
45037: PUSH
45038: LD_INT 31
45040: PUSH
45041: LD_INT 32
45043: PUSH
45044: LD_INT 51
45046: PUSH
45047: LD_INT 89
45049: PUSH
45050: LD_INT 12
45052: PUSH
45053: LD_INT 30
45055: PUSH
45056: LD_INT 98
45058: PUSH
45059: LD_INT 11
45061: PUSH
45062: LD_INT 53
45064: PUSH
45065: LD_INT 14
45067: PUSH
45068: LD_INT 91
45070: PUSH
45071: LD_INT 29
45073: PUSH
45074: LD_INT 99
45076: PUSH
45077: LD_INT 13
45079: PUSH
45080: LD_INT 52
45082: PUSH
45083: LD_INT 88
45085: PUSH
45086: LD_INT 48
45088: PUSH
45089: LD_INT 8
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: IN
45112: NOT
45113: AND
45114: IFFALSE 45162
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45116: LD_ADDR_EXP 72
45120: PUSH
45121: LD_EXP 72
45125: PPUSH
45126: LD_VAR 0 4
45130: PUSH
45131: LD_EXP 72
45135: PUSH
45136: LD_VAR 0 4
45140: ARRAY
45141: PUSH
45142: LD_INT 1
45144: PLUS
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PPUSH
45150: LD_VAR 0 1
45154: PPUSH
45155: CALL 54162 0 3
45159: ST_TO_ADDR
45160: GO 45206
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45162: LD_ADDR_EXP 69
45166: PUSH
45167: LD_EXP 69
45171: PPUSH
45172: LD_VAR 0 4
45176: PUSH
45177: LD_EXP 69
45181: PUSH
45182: LD_VAR 0 4
45186: ARRAY
45187: PUSH
45188: LD_INT 1
45190: PLUS
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PPUSH
45196: LD_VAR 0 1
45200: PPUSH
45201: CALL 54162 0 3
45205: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45206: LD_ADDR_EXP 94
45210: PUSH
45211: LD_INT 0
45213: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45214: LD_VAR 0 1
45218: PPUSH
45219: CALL_OW 263
45223: PUSH
45224: LD_INT 2
45226: EQUAL
45227: IFFALSE 45256
// begin repeat wait ( 0 0$3 ) ;
45229: LD_INT 105
45231: PPUSH
45232: CALL_OW 67
// Connect ( vehicle ) ;
45236: LD_VAR 0 1
45240: PPUSH
45241: CALL 57131 0 1
// until IsControledBy ( vehicle ) ;
45245: LD_VAR 0 1
45249: PPUSH
45250: CALL_OW 312
45254: IFFALSE 45229
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45256: LD_VAR 0 1
45260: PPUSH
45261: LD_EXP 74
45265: PUSH
45266: LD_VAR 0 4
45270: ARRAY
45271: PPUSH
45272: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45276: LD_VAR 0 1
45280: PPUSH
45281: CALL_OW 263
45285: PUSH
45286: LD_INT 1
45288: NONEQUAL
45289: IFFALSE 45293
// break ;
45291: GO 45342
// repeat wait ( 0 0$1 ) ;
45293: LD_INT 35
45295: PPUSH
45296: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45300: LD_VAR 0 1
45304: PPUSH
45305: LD_EXP 74
45309: PUSH
45310: LD_VAR 0 4
45314: ARRAY
45315: PPUSH
45316: CALL_OW 308
45320: IFFALSE 45293
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45322: LD_VAR 0 1
45326: PPUSH
45327: CALL_OW 311
45331: PPUSH
45332: CALL_OW 121
// exit ;
45336: POP
45337: POP
45338: GO 45352
// end ; end ;
45340: GO 44984
45342: POP
45343: POP
// mc_block_vehicle_constructed_thread := false ;
45344: LD_ADDR_EXP 94
45348: PUSH
45349: LD_INT 0
45351: ST_TO_ADDR
// end ;
45352: LD_VAR 0 3
45356: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45357: LD_INT 0
45359: PPUSH
45360: PPUSH
45361: PPUSH
45362: PPUSH
// if not mc_bases or not skirmish then
45363: LD_EXP 50
45367: NOT
45368: PUSH
45369: LD_EXP 48
45373: NOT
45374: OR
45375: IFFALSE 45379
// exit ;
45377: GO 45732
// repeat wait ( 0 0$1 ) ;
45379: LD_INT 35
45381: PPUSH
45382: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45386: LD_VAR 0 2
45390: PPUSH
45391: LD_VAR 0 3
45395: PPUSH
45396: CALL_OW 284
45400: IFFALSE 45379
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45402: LD_VAR 0 2
45406: PPUSH
45407: LD_VAR 0 3
45411: PPUSH
45412: CALL_OW 283
45416: PUSH
45417: LD_INT 4
45419: EQUAL
45420: IFFALSE 45424
// exit ;
45422: GO 45732
// for i = 1 to mc_bases do
45424: LD_ADDR_VAR 0 7
45428: PUSH
45429: DOUBLE
45430: LD_INT 1
45432: DEC
45433: ST_TO_ADDR
45434: LD_EXP 50
45438: PUSH
45439: FOR_TO
45440: IFFALSE 45730
// begin if mc_crates_area [ i ] then
45442: LD_EXP 68
45446: PUSH
45447: LD_VAR 0 7
45451: ARRAY
45452: IFFALSE 45563
// for j in mc_crates_area [ i ] do
45454: LD_ADDR_VAR 0 8
45458: PUSH
45459: LD_EXP 68
45463: PUSH
45464: LD_VAR 0 7
45468: ARRAY
45469: PUSH
45470: FOR_IN
45471: IFFALSE 45561
// if InArea ( x , y , j ) then
45473: LD_VAR 0 2
45477: PPUSH
45478: LD_VAR 0 3
45482: PPUSH
45483: LD_VAR 0 8
45487: PPUSH
45488: CALL_OW 309
45492: IFFALSE 45559
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45494: LD_ADDR_EXP 66
45498: PUSH
45499: LD_EXP 66
45503: PPUSH
45504: LD_VAR 0 7
45508: PUSH
45509: LD_EXP 66
45513: PUSH
45514: LD_VAR 0 7
45518: ARRAY
45519: PUSH
45520: LD_INT 1
45522: PLUS
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PPUSH
45528: LD_VAR 0 4
45532: PUSH
45533: LD_VAR 0 2
45537: PUSH
45538: LD_VAR 0 3
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: LIST
45547: PPUSH
45548: CALL 54162 0 3
45552: ST_TO_ADDR
// exit ;
45553: POP
45554: POP
45555: POP
45556: POP
45557: GO 45732
// end ;
45559: GO 45470
45561: POP
45562: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45563: LD_ADDR_VAR 0 9
45567: PUSH
45568: LD_EXP 50
45572: PUSH
45573: LD_VAR 0 7
45577: ARRAY
45578: PPUSH
45579: LD_INT 2
45581: PUSH
45582: LD_INT 30
45584: PUSH
45585: LD_INT 0
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 30
45594: PUSH
45595: LD_INT 1
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: LIST
45606: PPUSH
45607: CALL_OW 72
45611: ST_TO_ADDR
// if not depot then
45612: LD_VAR 0 9
45616: NOT
45617: IFFALSE 45621
// continue ;
45619: GO 45439
// for j in depot do
45621: LD_ADDR_VAR 0 8
45625: PUSH
45626: LD_VAR 0 9
45630: PUSH
45631: FOR_IN
45632: IFFALSE 45726
// if GetDistUnitXY ( j , x , y ) < 30 then
45634: LD_VAR 0 8
45638: PPUSH
45639: LD_VAR 0 2
45643: PPUSH
45644: LD_VAR 0 3
45648: PPUSH
45649: CALL_OW 297
45653: PUSH
45654: LD_INT 30
45656: LESS
45657: IFFALSE 45724
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45659: LD_ADDR_EXP 66
45663: PUSH
45664: LD_EXP 66
45668: PPUSH
45669: LD_VAR 0 7
45673: PUSH
45674: LD_EXP 66
45678: PUSH
45679: LD_VAR 0 7
45683: ARRAY
45684: PUSH
45685: LD_INT 1
45687: PLUS
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PPUSH
45693: LD_VAR 0 4
45697: PUSH
45698: LD_VAR 0 2
45702: PUSH
45703: LD_VAR 0 3
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: LIST
45712: PPUSH
45713: CALL 54162 0 3
45717: ST_TO_ADDR
// exit ;
45718: POP
45719: POP
45720: POP
45721: POP
45722: GO 45732
// end ;
45724: GO 45631
45726: POP
45727: POP
// end ;
45728: GO 45439
45730: POP
45731: POP
// end ;
45732: LD_VAR 0 6
45736: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45737: LD_INT 0
45739: PPUSH
45740: PPUSH
45741: PPUSH
45742: PPUSH
// if not mc_bases or not skirmish then
45743: LD_EXP 50
45747: NOT
45748: PUSH
45749: LD_EXP 48
45753: NOT
45754: OR
45755: IFFALSE 45759
// exit ;
45757: GO 46036
// side := GetSide ( lab ) ;
45759: LD_ADDR_VAR 0 4
45763: PUSH
45764: LD_VAR 0 2
45768: PPUSH
45769: CALL_OW 255
45773: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45774: LD_VAR 0 4
45778: PUSH
45779: LD_EXP 76
45783: IN
45784: NOT
45785: PUSH
45786: LD_EXP 77
45790: NOT
45791: OR
45792: PUSH
45793: LD_EXP 50
45797: NOT
45798: OR
45799: IFFALSE 45803
// exit ;
45801: GO 46036
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45803: LD_ADDR_EXP 77
45807: PUSH
45808: LD_EXP 77
45812: PPUSH
45813: LD_VAR 0 4
45817: PPUSH
45818: LD_EXP 77
45822: PUSH
45823: LD_VAR 0 4
45827: ARRAY
45828: PUSH
45829: LD_VAR 0 1
45833: DIFF
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// for i = 1 to mc_bases do
45840: LD_ADDR_VAR 0 5
45844: PUSH
45845: DOUBLE
45846: LD_INT 1
45848: DEC
45849: ST_TO_ADDR
45850: LD_EXP 50
45854: PUSH
45855: FOR_TO
45856: IFFALSE 46034
// begin if lab in mc_bases [ i ] then
45858: LD_VAR 0 2
45862: PUSH
45863: LD_EXP 50
45867: PUSH
45868: LD_VAR 0 5
45872: ARRAY
45873: IN
45874: IFFALSE 46032
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45876: LD_VAR 0 1
45880: PUSH
45881: LD_INT 11
45883: PUSH
45884: LD_INT 4
45886: PUSH
45887: LD_INT 3
45889: PUSH
45890: LD_INT 2
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: IN
45899: PUSH
45900: LD_EXP 80
45904: PUSH
45905: LD_VAR 0 5
45909: ARRAY
45910: AND
45911: IFFALSE 46032
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45913: LD_ADDR_VAR 0 6
45917: PUSH
45918: LD_EXP 80
45922: PUSH
45923: LD_VAR 0 5
45927: ARRAY
45928: PUSH
45929: LD_INT 1
45931: ARRAY
45932: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45933: LD_ADDR_EXP 80
45937: PUSH
45938: LD_EXP 80
45942: PPUSH
45943: LD_VAR 0 5
45947: PPUSH
45948: EMPTY
45949: PPUSH
45950: CALL_OW 1
45954: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45955: LD_VAR 0 6
45959: PPUSH
45960: LD_INT 0
45962: PPUSH
45963: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45967: LD_VAR 0 6
45971: PPUSH
45972: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45976: LD_ADDR_EXP 79
45980: PUSH
45981: LD_EXP 79
45985: PPUSH
45986: LD_VAR 0 5
45990: PPUSH
45991: LD_EXP 79
45995: PUSH
45996: LD_VAR 0 5
46000: ARRAY
46001: PPUSH
46002: LD_INT 1
46004: PPUSH
46005: LD_VAR 0 6
46009: PPUSH
46010: CALL_OW 2
46014: PPUSH
46015: CALL_OW 1
46019: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46020: LD_VAR 0 5
46024: PPUSH
46025: LD_INT 112
46027: PPUSH
46028: CALL 22484 0 2
// end ; end ; end ;
46032: GO 45855
46034: POP
46035: POP
// end ;
46036: LD_VAR 0 3
46040: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46041: LD_INT 0
46043: PPUSH
46044: PPUSH
46045: PPUSH
46046: PPUSH
46047: PPUSH
46048: PPUSH
46049: PPUSH
46050: PPUSH
// if not mc_bases or not skirmish then
46051: LD_EXP 50
46055: NOT
46056: PUSH
46057: LD_EXP 48
46061: NOT
46062: OR
46063: IFFALSE 46067
// exit ;
46065: GO 47436
// for i = 1 to mc_bases do
46067: LD_ADDR_VAR 0 3
46071: PUSH
46072: DOUBLE
46073: LD_INT 1
46075: DEC
46076: ST_TO_ADDR
46077: LD_EXP 50
46081: PUSH
46082: FOR_TO
46083: IFFALSE 47434
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46085: LD_VAR 0 1
46089: PUSH
46090: LD_EXP 50
46094: PUSH
46095: LD_VAR 0 3
46099: ARRAY
46100: IN
46101: PUSH
46102: LD_VAR 0 1
46106: PUSH
46107: LD_EXP 57
46111: PUSH
46112: LD_VAR 0 3
46116: ARRAY
46117: IN
46118: OR
46119: PUSH
46120: LD_VAR 0 1
46124: PUSH
46125: LD_EXP 72
46129: PUSH
46130: LD_VAR 0 3
46134: ARRAY
46135: IN
46136: OR
46137: PUSH
46138: LD_VAR 0 1
46142: PUSH
46143: LD_EXP 69
46147: PUSH
46148: LD_VAR 0 3
46152: ARRAY
46153: IN
46154: OR
46155: PUSH
46156: LD_VAR 0 1
46160: PUSH
46161: LD_EXP 79
46165: PUSH
46166: LD_VAR 0 3
46170: ARRAY
46171: IN
46172: OR
46173: PUSH
46174: LD_VAR 0 1
46178: PUSH
46179: LD_EXP 80
46183: PUSH
46184: LD_VAR 0 3
46188: ARRAY
46189: IN
46190: OR
46191: IFFALSE 47432
// begin if un in mc_ape [ i ] then
46193: LD_VAR 0 1
46197: PUSH
46198: LD_EXP 79
46202: PUSH
46203: LD_VAR 0 3
46207: ARRAY
46208: IN
46209: IFFALSE 46248
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46211: LD_ADDR_EXP 79
46215: PUSH
46216: LD_EXP 79
46220: PPUSH
46221: LD_VAR 0 3
46225: PPUSH
46226: LD_EXP 79
46230: PUSH
46231: LD_VAR 0 3
46235: ARRAY
46236: PUSH
46237: LD_VAR 0 1
46241: DIFF
46242: PPUSH
46243: CALL_OW 1
46247: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46248: LD_VAR 0 1
46252: PUSH
46253: LD_EXP 80
46257: PUSH
46258: LD_VAR 0 3
46262: ARRAY
46263: IN
46264: IFFALSE 46288
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46266: LD_ADDR_EXP 80
46270: PUSH
46271: LD_EXP 80
46275: PPUSH
46276: LD_VAR 0 3
46280: PPUSH
46281: EMPTY
46282: PPUSH
46283: CALL_OW 1
46287: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46288: LD_VAR 0 1
46292: PPUSH
46293: CALL_OW 247
46297: PUSH
46298: LD_INT 2
46300: EQUAL
46301: PUSH
46302: LD_VAR 0 1
46306: PPUSH
46307: CALL_OW 110
46311: PUSH
46312: LD_INT 20
46314: EQUAL
46315: PUSH
46316: LD_VAR 0 1
46320: PUSH
46321: LD_EXP 72
46325: PUSH
46326: LD_VAR 0 3
46330: ARRAY
46331: IN
46332: OR
46333: PUSH
46334: LD_VAR 0 1
46338: PPUSH
46339: CALL_OW 264
46343: PUSH
46344: LD_INT 12
46346: PUSH
46347: LD_INT 51
46349: PUSH
46350: LD_INT 89
46352: PUSH
46353: LD_INT 32
46355: PUSH
46356: LD_INT 13
46358: PUSH
46359: LD_INT 52
46361: PUSH
46362: LD_INT 31
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: IN
46374: OR
46375: AND
46376: IFFALSE 46684
// begin if un in mc_defender [ i ] then
46378: LD_VAR 0 1
46382: PUSH
46383: LD_EXP 72
46387: PUSH
46388: LD_VAR 0 3
46392: ARRAY
46393: IN
46394: IFFALSE 46433
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46396: LD_ADDR_EXP 72
46400: PUSH
46401: LD_EXP 72
46405: PPUSH
46406: LD_VAR 0 3
46410: PPUSH
46411: LD_EXP 72
46415: PUSH
46416: LD_VAR 0 3
46420: ARRAY
46421: PUSH
46422: LD_VAR 0 1
46426: DIFF
46427: PPUSH
46428: CALL_OW 1
46432: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46433: LD_ADDR_VAR 0 8
46437: PUSH
46438: LD_VAR 0 3
46442: PPUSH
46443: LD_INT 3
46445: PPUSH
46446: CALL 43054 0 2
46450: ST_TO_ADDR
// if fac then
46451: LD_VAR 0 8
46455: IFFALSE 46684
// begin for j in fac do
46457: LD_ADDR_VAR 0 4
46461: PUSH
46462: LD_VAR 0 8
46466: PUSH
46467: FOR_IN
46468: IFFALSE 46682
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46470: LD_ADDR_VAR 0 9
46474: PUSH
46475: LD_VAR 0 8
46479: PPUSH
46480: LD_VAR 0 1
46484: PPUSH
46485: CALL_OW 265
46489: PPUSH
46490: LD_VAR 0 1
46494: PPUSH
46495: CALL_OW 262
46499: PPUSH
46500: LD_VAR 0 1
46504: PPUSH
46505: CALL_OW 263
46509: PPUSH
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 264
46519: PPUSH
46520: CALL 51660 0 5
46524: ST_TO_ADDR
// if components then
46525: LD_VAR 0 9
46529: IFFALSE 46680
// begin if GetWeapon ( un ) = ar_control_tower then
46531: LD_VAR 0 1
46535: PPUSH
46536: CALL_OW 264
46540: PUSH
46541: LD_INT 31
46543: EQUAL
46544: IFFALSE 46661
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46546: LD_VAR 0 1
46550: PPUSH
46551: CALL_OW 311
46555: PPUSH
46556: LD_INT 0
46558: PPUSH
46559: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46563: LD_ADDR_EXP 90
46567: PUSH
46568: LD_EXP 90
46572: PPUSH
46573: LD_VAR 0 3
46577: PPUSH
46578: LD_EXP 90
46582: PUSH
46583: LD_VAR 0 3
46587: ARRAY
46588: PUSH
46589: LD_VAR 0 1
46593: PPUSH
46594: CALL_OW 311
46598: DIFF
46599: PPUSH
46600: CALL_OW 1
46604: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46605: LD_ADDR_VAR 0 7
46609: PUSH
46610: LD_EXP 71
46614: PUSH
46615: LD_VAR 0 3
46619: ARRAY
46620: PPUSH
46621: LD_INT 1
46623: PPUSH
46624: LD_VAR 0 9
46628: PPUSH
46629: CALL_OW 2
46633: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46634: LD_ADDR_EXP 71
46638: PUSH
46639: LD_EXP 71
46643: PPUSH
46644: LD_VAR 0 3
46648: PPUSH
46649: LD_VAR 0 7
46653: PPUSH
46654: CALL_OW 1
46658: ST_TO_ADDR
// end else
46659: GO 46678
// MC_InsertProduceList ( i , [ components ] ) ;
46661: LD_VAR 0 3
46665: PPUSH
46666: LD_VAR 0 9
46670: PUSH
46671: EMPTY
46672: LIST
46673: PPUSH
46674: CALL 42599 0 2
// break ;
46678: GO 46682
// end ; end ;
46680: GO 46467
46682: POP
46683: POP
// end ; end ; if GetType ( un ) = unit_building then
46684: LD_VAR 0 1
46688: PPUSH
46689: CALL_OW 247
46693: PUSH
46694: LD_INT 3
46696: EQUAL
46697: IFFALSE 47100
// begin btype := GetBType ( un ) ;
46699: LD_ADDR_VAR 0 5
46703: PUSH
46704: LD_VAR 0 1
46708: PPUSH
46709: CALL_OW 266
46713: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46714: LD_VAR 0 5
46718: PUSH
46719: LD_INT 29
46721: PUSH
46722: LD_INT 30
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: IN
46729: IFFALSE 46802
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46731: LD_VAR 0 1
46735: PPUSH
46736: CALL_OW 250
46740: PPUSH
46741: LD_VAR 0 1
46745: PPUSH
46746: CALL_OW 251
46750: PPUSH
46751: LD_VAR 0 1
46755: PPUSH
46756: CALL_OW 255
46760: PPUSH
46761: CALL_OW 440
46765: NOT
46766: IFFALSE 46802
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46768: LD_VAR 0 1
46772: PPUSH
46773: CALL_OW 250
46777: PPUSH
46778: LD_VAR 0 1
46782: PPUSH
46783: CALL_OW 251
46787: PPUSH
46788: LD_VAR 0 1
46792: PPUSH
46793: CALL_OW 255
46797: PPUSH
46798: CALL_OW 441
// end ; if btype = b_warehouse then
46802: LD_VAR 0 5
46806: PUSH
46807: LD_INT 1
46809: EQUAL
46810: IFFALSE 46828
// begin btype := b_depot ;
46812: LD_ADDR_VAR 0 5
46816: PUSH
46817: LD_INT 0
46819: ST_TO_ADDR
// pos := 1 ;
46820: LD_ADDR_VAR 0 6
46824: PUSH
46825: LD_INT 1
46827: ST_TO_ADDR
// end ; if btype = b_factory then
46828: LD_VAR 0 5
46832: PUSH
46833: LD_INT 3
46835: EQUAL
46836: IFFALSE 46854
// begin btype := b_workshop ;
46838: LD_ADDR_VAR 0 5
46842: PUSH
46843: LD_INT 2
46845: ST_TO_ADDR
// pos := 1 ;
46846: LD_ADDR_VAR 0 6
46850: PUSH
46851: LD_INT 1
46853: ST_TO_ADDR
// end ; if btype = b_barracks then
46854: LD_VAR 0 5
46858: PUSH
46859: LD_INT 5
46861: EQUAL
46862: IFFALSE 46872
// btype := b_armoury ;
46864: LD_ADDR_VAR 0 5
46868: PUSH
46869: LD_INT 4
46871: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46872: LD_VAR 0 5
46876: PUSH
46877: LD_INT 7
46879: PUSH
46880: LD_INT 8
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: IN
46887: IFFALSE 46897
// btype := b_lab ;
46889: LD_ADDR_VAR 0 5
46893: PUSH
46894: LD_INT 6
46896: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46897: LD_ADDR_EXP 55
46901: PUSH
46902: LD_EXP 55
46906: PPUSH
46907: LD_VAR 0 3
46911: PUSH
46912: LD_EXP 55
46916: PUSH
46917: LD_VAR 0 3
46921: ARRAY
46922: PUSH
46923: LD_INT 1
46925: PLUS
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PPUSH
46931: LD_VAR 0 5
46935: PUSH
46936: LD_VAR 0 1
46940: PPUSH
46941: CALL_OW 250
46945: PUSH
46946: LD_VAR 0 1
46950: PPUSH
46951: CALL_OW 251
46955: PUSH
46956: LD_VAR 0 1
46960: PPUSH
46961: CALL_OW 254
46965: PUSH
46966: EMPTY
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: PPUSH
46972: CALL 54162 0 3
46976: ST_TO_ADDR
// if pos = 1 then
46977: LD_VAR 0 6
46981: PUSH
46982: LD_INT 1
46984: EQUAL
46985: IFFALSE 47100
// begin tmp := mc_build_list [ i ] ;
46987: LD_ADDR_VAR 0 7
46991: PUSH
46992: LD_EXP 55
46996: PUSH
46997: LD_VAR 0 3
47001: ARRAY
47002: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47003: LD_VAR 0 7
47007: PPUSH
47008: LD_INT 2
47010: PUSH
47011: LD_INT 30
47013: PUSH
47014: LD_INT 0
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 30
47023: PUSH
47024: LD_INT 1
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: LIST
47035: PPUSH
47036: CALL_OW 72
47040: IFFALSE 47050
// pos := 2 ;
47042: LD_ADDR_VAR 0 6
47046: PUSH
47047: LD_INT 2
47049: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47050: LD_ADDR_VAR 0 7
47054: PUSH
47055: LD_VAR 0 7
47059: PPUSH
47060: LD_VAR 0 6
47064: PPUSH
47065: LD_VAR 0 7
47069: PPUSH
47070: CALL 54488 0 3
47074: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47075: LD_ADDR_EXP 55
47079: PUSH
47080: LD_EXP 55
47084: PPUSH
47085: LD_VAR 0 3
47089: PPUSH
47090: LD_VAR 0 7
47094: PPUSH
47095: CALL_OW 1
47099: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47100: LD_VAR 0 1
47104: PUSH
47105: LD_EXP 50
47109: PUSH
47110: LD_VAR 0 3
47114: ARRAY
47115: IN
47116: IFFALSE 47155
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47118: LD_ADDR_EXP 50
47122: PUSH
47123: LD_EXP 50
47127: PPUSH
47128: LD_VAR 0 3
47132: PPUSH
47133: LD_EXP 50
47137: PUSH
47138: LD_VAR 0 3
47142: ARRAY
47143: PUSH
47144: LD_VAR 0 1
47148: DIFF
47149: PPUSH
47150: CALL_OW 1
47154: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47155: LD_VAR 0 1
47159: PUSH
47160: LD_EXP 57
47164: PUSH
47165: LD_VAR 0 3
47169: ARRAY
47170: IN
47171: IFFALSE 47210
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47173: LD_ADDR_EXP 57
47177: PUSH
47178: LD_EXP 57
47182: PPUSH
47183: LD_VAR 0 3
47187: PPUSH
47188: LD_EXP 57
47192: PUSH
47193: LD_VAR 0 3
47197: ARRAY
47198: PUSH
47199: LD_VAR 0 1
47203: DIFF
47204: PPUSH
47205: CALL_OW 1
47209: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47210: LD_VAR 0 1
47214: PUSH
47215: LD_EXP 69
47219: PUSH
47220: LD_VAR 0 3
47224: ARRAY
47225: IN
47226: IFFALSE 47265
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47228: LD_ADDR_EXP 69
47232: PUSH
47233: LD_EXP 69
47237: PPUSH
47238: LD_VAR 0 3
47242: PPUSH
47243: LD_EXP 69
47247: PUSH
47248: LD_VAR 0 3
47252: ARRAY
47253: PUSH
47254: LD_VAR 0 1
47258: DIFF
47259: PPUSH
47260: CALL_OW 1
47264: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47265: LD_VAR 0 1
47269: PUSH
47270: LD_EXP 72
47274: PUSH
47275: LD_VAR 0 3
47279: ARRAY
47280: IN
47281: IFFALSE 47320
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47283: LD_ADDR_EXP 72
47287: PUSH
47288: LD_EXP 72
47292: PPUSH
47293: LD_VAR 0 3
47297: PPUSH
47298: LD_EXP 72
47302: PUSH
47303: LD_VAR 0 3
47307: ARRAY
47308: PUSH
47309: LD_VAR 0 1
47313: DIFF
47314: PPUSH
47315: CALL_OW 1
47319: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47320: LD_VAR 0 1
47324: PUSH
47325: LD_EXP 59
47329: PUSH
47330: LD_VAR 0 3
47334: ARRAY
47335: IN
47336: IFFALSE 47375
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47338: LD_ADDR_EXP 59
47342: PUSH
47343: LD_EXP 59
47347: PPUSH
47348: LD_VAR 0 3
47352: PPUSH
47353: LD_EXP 59
47357: PUSH
47358: LD_VAR 0 3
47362: ARRAY
47363: PUSH
47364: LD_VAR 0 1
47368: DIFF
47369: PPUSH
47370: CALL_OW 1
47374: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47375: LD_VAR 0 1
47379: PUSH
47380: LD_EXP 58
47384: PUSH
47385: LD_VAR 0 3
47389: ARRAY
47390: IN
47391: IFFALSE 47430
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47393: LD_ADDR_EXP 58
47397: PUSH
47398: LD_EXP 58
47402: PPUSH
47403: LD_VAR 0 3
47407: PPUSH
47408: LD_EXP 58
47412: PUSH
47413: LD_VAR 0 3
47417: ARRAY
47418: PUSH
47419: LD_VAR 0 1
47423: DIFF
47424: PPUSH
47425: CALL_OW 1
47429: ST_TO_ADDR
// end ; break ;
47430: GO 47434
// end ;
47432: GO 46082
47434: POP
47435: POP
// end ;
47436: LD_VAR 0 2
47440: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47441: LD_INT 0
47443: PPUSH
47444: PPUSH
47445: PPUSH
// if not mc_bases or not skirmish then
47446: LD_EXP 50
47450: NOT
47451: PUSH
47452: LD_EXP 48
47456: NOT
47457: OR
47458: IFFALSE 47462
// exit ;
47460: GO 47677
// for i = 1 to mc_bases do
47462: LD_ADDR_VAR 0 3
47466: PUSH
47467: DOUBLE
47468: LD_INT 1
47470: DEC
47471: ST_TO_ADDR
47472: LD_EXP 50
47476: PUSH
47477: FOR_TO
47478: IFFALSE 47675
// begin if building in mc_construct_list [ i ] then
47480: LD_VAR 0 1
47484: PUSH
47485: LD_EXP 57
47489: PUSH
47490: LD_VAR 0 3
47494: ARRAY
47495: IN
47496: IFFALSE 47673
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47498: LD_ADDR_EXP 57
47502: PUSH
47503: LD_EXP 57
47507: PPUSH
47508: LD_VAR 0 3
47512: PPUSH
47513: LD_EXP 57
47517: PUSH
47518: LD_VAR 0 3
47522: ARRAY
47523: PUSH
47524: LD_VAR 0 1
47528: DIFF
47529: PPUSH
47530: CALL_OW 1
47534: ST_TO_ADDR
// if building in mc_lab [ i ] then
47535: LD_VAR 0 1
47539: PUSH
47540: LD_EXP 83
47544: PUSH
47545: LD_VAR 0 3
47549: ARRAY
47550: IN
47551: IFFALSE 47606
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47553: LD_ADDR_EXP 84
47557: PUSH
47558: LD_EXP 84
47562: PPUSH
47563: LD_VAR 0 3
47567: PPUSH
47568: LD_EXP 84
47572: PUSH
47573: LD_VAR 0 3
47577: ARRAY
47578: PPUSH
47579: LD_INT 1
47581: PPUSH
47582: LD_EXP 84
47586: PUSH
47587: LD_VAR 0 3
47591: ARRAY
47592: PPUSH
47593: LD_INT 0
47595: PPUSH
47596: CALL 53580 0 4
47600: PPUSH
47601: CALL_OW 1
47605: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47606: LD_VAR 0 1
47610: PUSH
47611: LD_EXP 50
47615: PUSH
47616: LD_VAR 0 3
47620: ARRAY
47621: IN
47622: NOT
47623: IFFALSE 47669
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47625: LD_ADDR_EXP 50
47629: PUSH
47630: LD_EXP 50
47634: PPUSH
47635: LD_VAR 0 3
47639: PUSH
47640: LD_EXP 50
47644: PUSH
47645: LD_VAR 0 3
47649: ARRAY
47650: PUSH
47651: LD_INT 1
47653: PLUS
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: PPUSH
47659: LD_VAR 0 1
47663: PPUSH
47664: CALL 54162 0 3
47668: ST_TO_ADDR
// exit ;
47669: POP
47670: POP
47671: GO 47677
// end ; end ;
47673: GO 47477
47675: POP
47676: POP
// end ;
47677: LD_VAR 0 2
47681: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47682: LD_INT 0
47684: PPUSH
47685: PPUSH
47686: PPUSH
47687: PPUSH
47688: PPUSH
47689: PPUSH
47690: PPUSH
// if not mc_bases or not skirmish then
47691: LD_EXP 50
47695: NOT
47696: PUSH
47697: LD_EXP 48
47701: NOT
47702: OR
47703: IFFALSE 47707
// exit ;
47705: GO 48368
// for i = 1 to mc_bases do
47707: LD_ADDR_VAR 0 3
47711: PUSH
47712: DOUBLE
47713: LD_INT 1
47715: DEC
47716: ST_TO_ADDR
47717: LD_EXP 50
47721: PUSH
47722: FOR_TO
47723: IFFALSE 48366
// begin if building in mc_construct_list [ i ] then
47725: LD_VAR 0 1
47729: PUSH
47730: LD_EXP 57
47734: PUSH
47735: LD_VAR 0 3
47739: ARRAY
47740: IN
47741: IFFALSE 48364
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47743: LD_ADDR_EXP 57
47747: PUSH
47748: LD_EXP 57
47752: PPUSH
47753: LD_VAR 0 3
47757: PPUSH
47758: LD_EXP 57
47762: PUSH
47763: LD_VAR 0 3
47767: ARRAY
47768: PUSH
47769: LD_VAR 0 1
47773: DIFF
47774: PPUSH
47775: CALL_OW 1
47779: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47780: LD_ADDR_EXP 50
47784: PUSH
47785: LD_EXP 50
47789: PPUSH
47790: LD_VAR 0 3
47794: PUSH
47795: LD_EXP 50
47799: PUSH
47800: LD_VAR 0 3
47804: ARRAY
47805: PUSH
47806: LD_INT 1
47808: PLUS
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PPUSH
47814: LD_VAR 0 1
47818: PPUSH
47819: CALL 54162 0 3
47823: ST_TO_ADDR
// btype := GetBType ( building ) ;
47824: LD_ADDR_VAR 0 5
47828: PUSH
47829: LD_VAR 0 1
47833: PPUSH
47834: CALL_OW 266
47838: ST_TO_ADDR
// side := GetSide ( building ) ;
47839: LD_ADDR_VAR 0 8
47843: PUSH
47844: LD_VAR 0 1
47848: PPUSH
47849: CALL_OW 255
47853: ST_TO_ADDR
// if btype = b_lab then
47854: LD_VAR 0 5
47858: PUSH
47859: LD_INT 6
47861: EQUAL
47862: IFFALSE 47912
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47864: LD_ADDR_EXP 83
47868: PUSH
47869: LD_EXP 83
47873: PPUSH
47874: LD_VAR 0 3
47878: PUSH
47879: LD_EXP 83
47883: PUSH
47884: LD_VAR 0 3
47888: ARRAY
47889: PUSH
47890: LD_INT 1
47892: PLUS
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PPUSH
47898: LD_VAR 0 1
47902: PPUSH
47903: CALL 54162 0 3
47907: ST_TO_ADDR
// exit ;
47908: POP
47909: POP
47910: GO 48368
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47912: LD_VAR 0 5
47916: PUSH
47917: LD_INT 0
47919: PUSH
47920: LD_INT 2
47922: PUSH
47923: LD_INT 4
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: LIST
47930: IN
47931: IFFALSE 48055
// begin if btype = b_armoury then
47933: LD_VAR 0 5
47937: PUSH
47938: LD_INT 4
47940: EQUAL
47941: IFFALSE 47951
// btype := b_barracks ;
47943: LD_ADDR_VAR 0 5
47947: PUSH
47948: LD_INT 5
47950: ST_TO_ADDR
// if btype = b_depot then
47951: LD_VAR 0 5
47955: PUSH
47956: LD_INT 0
47958: EQUAL
47959: IFFALSE 47969
// btype := b_warehouse ;
47961: LD_ADDR_VAR 0 5
47965: PUSH
47966: LD_INT 1
47968: ST_TO_ADDR
// if btype = b_workshop then
47969: LD_VAR 0 5
47973: PUSH
47974: LD_INT 2
47976: EQUAL
47977: IFFALSE 47987
// btype := b_factory ;
47979: LD_ADDR_VAR 0 5
47983: PUSH
47984: LD_INT 3
47986: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47987: LD_VAR 0 5
47991: PPUSH
47992: LD_VAR 0 8
47996: PPUSH
47997: CALL_OW 323
48001: PUSH
48002: LD_INT 1
48004: EQUAL
48005: IFFALSE 48051
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48007: LD_ADDR_EXP 82
48011: PUSH
48012: LD_EXP 82
48016: PPUSH
48017: LD_VAR 0 3
48021: PUSH
48022: LD_EXP 82
48026: PUSH
48027: LD_VAR 0 3
48031: ARRAY
48032: PUSH
48033: LD_INT 1
48035: PLUS
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PPUSH
48041: LD_VAR 0 1
48045: PPUSH
48046: CALL 54162 0 3
48050: ST_TO_ADDR
// exit ;
48051: POP
48052: POP
48053: GO 48368
// end ; if btype in [ b_bunker , b_turret ] then
48055: LD_VAR 0 5
48059: PUSH
48060: LD_INT 32
48062: PUSH
48063: LD_INT 33
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: IN
48070: IFFALSE 48360
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48072: LD_ADDR_EXP 58
48076: PUSH
48077: LD_EXP 58
48081: PPUSH
48082: LD_VAR 0 3
48086: PUSH
48087: LD_EXP 58
48091: PUSH
48092: LD_VAR 0 3
48096: ARRAY
48097: PUSH
48098: LD_INT 1
48100: PLUS
48101: PUSH
48102: EMPTY
48103: LIST
48104: LIST
48105: PPUSH
48106: LD_VAR 0 1
48110: PPUSH
48111: CALL 54162 0 3
48115: ST_TO_ADDR
// if btype = b_bunker then
48116: LD_VAR 0 5
48120: PUSH
48121: LD_INT 32
48123: EQUAL
48124: IFFALSE 48360
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48126: LD_ADDR_EXP 59
48130: PUSH
48131: LD_EXP 59
48135: PPUSH
48136: LD_VAR 0 3
48140: PUSH
48141: LD_EXP 59
48145: PUSH
48146: LD_VAR 0 3
48150: ARRAY
48151: PUSH
48152: LD_INT 1
48154: PLUS
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: PPUSH
48160: LD_VAR 0 1
48164: PPUSH
48165: CALL 54162 0 3
48169: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48170: LD_ADDR_VAR 0 6
48174: PUSH
48175: LD_EXP 50
48179: PUSH
48180: LD_VAR 0 3
48184: ARRAY
48185: PPUSH
48186: LD_INT 25
48188: PUSH
48189: LD_INT 1
48191: PUSH
48192: EMPTY
48193: LIST
48194: LIST
48195: PUSH
48196: LD_INT 3
48198: PUSH
48199: LD_INT 54
48201: PUSH
48202: EMPTY
48203: LIST
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PPUSH
48213: CALL_OW 72
48217: ST_TO_ADDR
// if tmp then
48218: LD_VAR 0 6
48222: IFFALSE 48228
// exit ;
48224: POP
48225: POP
48226: GO 48368
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48228: LD_ADDR_VAR 0 6
48232: PUSH
48233: LD_EXP 50
48237: PUSH
48238: LD_VAR 0 3
48242: ARRAY
48243: PPUSH
48244: LD_INT 2
48246: PUSH
48247: LD_INT 30
48249: PUSH
48250: LD_INT 4
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 30
48259: PUSH
48260: LD_INT 5
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: LIST
48271: PPUSH
48272: CALL_OW 72
48276: ST_TO_ADDR
// if not tmp then
48277: LD_VAR 0 6
48281: NOT
48282: IFFALSE 48288
// exit ;
48284: POP
48285: POP
48286: GO 48368
// for j in tmp do
48288: LD_ADDR_VAR 0 4
48292: PUSH
48293: LD_VAR 0 6
48297: PUSH
48298: FOR_IN
48299: IFFALSE 48358
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48301: LD_ADDR_VAR 0 7
48305: PUSH
48306: LD_VAR 0 4
48310: PPUSH
48311: CALL_OW 313
48315: PPUSH
48316: LD_INT 25
48318: PUSH
48319: LD_INT 1
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PPUSH
48326: CALL_OW 72
48330: ST_TO_ADDR
// if units then
48331: LD_VAR 0 7
48335: IFFALSE 48356
// begin ComExitBuilding ( units [ 1 ] ) ;
48337: LD_VAR 0 7
48341: PUSH
48342: LD_INT 1
48344: ARRAY
48345: PPUSH
48346: CALL_OW 122
// exit ;
48350: POP
48351: POP
48352: POP
48353: POP
48354: GO 48368
// end ; end ;
48356: GO 48298
48358: POP
48359: POP
// end ; end ; exit ;
48360: POP
48361: POP
48362: GO 48368
// end ; end ;
48364: GO 47722
48366: POP
48367: POP
// end ;
48368: LD_VAR 0 2
48372: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48373: LD_INT 0
48375: PPUSH
48376: PPUSH
48377: PPUSH
48378: PPUSH
48379: PPUSH
48380: PPUSH
48381: PPUSH
// if not mc_bases or not skirmish then
48382: LD_EXP 50
48386: NOT
48387: PUSH
48388: LD_EXP 48
48392: NOT
48393: OR
48394: IFFALSE 48398
// exit ;
48396: GO 48663
// btype := GetBType ( building ) ;
48398: LD_ADDR_VAR 0 6
48402: PUSH
48403: LD_VAR 0 1
48407: PPUSH
48408: CALL_OW 266
48412: ST_TO_ADDR
// x := GetX ( building ) ;
48413: LD_ADDR_VAR 0 7
48417: PUSH
48418: LD_VAR 0 1
48422: PPUSH
48423: CALL_OW 250
48427: ST_TO_ADDR
// y := GetY ( building ) ;
48428: LD_ADDR_VAR 0 8
48432: PUSH
48433: LD_VAR 0 1
48437: PPUSH
48438: CALL_OW 251
48442: ST_TO_ADDR
// d := GetDir ( building ) ;
48443: LD_ADDR_VAR 0 9
48447: PUSH
48448: LD_VAR 0 1
48452: PPUSH
48453: CALL_OW 254
48457: ST_TO_ADDR
// for i = 1 to mc_bases do
48458: LD_ADDR_VAR 0 4
48462: PUSH
48463: DOUBLE
48464: LD_INT 1
48466: DEC
48467: ST_TO_ADDR
48468: LD_EXP 50
48472: PUSH
48473: FOR_TO
48474: IFFALSE 48661
// begin if not mc_build_list [ i ] then
48476: LD_EXP 55
48480: PUSH
48481: LD_VAR 0 4
48485: ARRAY
48486: NOT
48487: IFFALSE 48491
// continue ;
48489: GO 48473
// for j := 1 to mc_build_list [ i ] do
48491: LD_ADDR_VAR 0 5
48495: PUSH
48496: DOUBLE
48497: LD_INT 1
48499: DEC
48500: ST_TO_ADDR
48501: LD_EXP 55
48505: PUSH
48506: LD_VAR 0 4
48510: ARRAY
48511: PUSH
48512: FOR_TO
48513: IFFALSE 48657
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48515: LD_VAR 0 6
48519: PUSH
48520: LD_VAR 0 7
48524: PUSH
48525: LD_VAR 0 8
48529: PUSH
48530: LD_VAR 0 9
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: LIST
48539: LIST
48540: PPUSH
48541: LD_EXP 55
48545: PUSH
48546: LD_VAR 0 4
48550: ARRAY
48551: PUSH
48552: LD_VAR 0 5
48556: ARRAY
48557: PPUSH
48558: CALL 60342 0 2
48562: IFFALSE 48655
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48564: LD_ADDR_EXP 55
48568: PUSH
48569: LD_EXP 55
48573: PPUSH
48574: LD_VAR 0 4
48578: PPUSH
48579: LD_EXP 55
48583: PUSH
48584: LD_VAR 0 4
48588: ARRAY
48589: PPUSH
48590: LD_VAR 0 5
48594: PPUSH
48595: CALL_OW 3
48599: PPUSH
48600: CALL_OW 1
48604: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48605: LD_ADDR_EXP 57
48609: PUSH
48610: LD_EXP 57
48614: PPUSH
48615: LD_VAR 0 4
48619: PUSH
48620: LD_EXP 57
48624: PUSH
48625: LD_VAR 0 4
48629: ARRAY
48630: PUSH
48631: LD_INT 1
48633: PLUS
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: PPUSH
48639: LD_VAR 0 1
48643: PPUSH
48644: CALL 54162 0 3
48648: ST_TO_ADDR
// exit ;
48649: POP
48650: POP
48651: POP
48652: POP
48653: GO 48663
// end ;
48655: GO 48512
48657: POP
48658: POP
// end ;
48659: GO 48473
48661: POP
48662: POP
// end ;
48663: LD_VAR 0 3
48667: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48668: LD_INT 0
48670: PPUSH
48671: PPUSH
48672: PPUSH
// if not mc_bases or not skirmish then
48673: LD_EXP 50
48677: NOT
48678: PUSH
48679: LD_EXP 48
48683: NOT
48684: OR
48685: IFFALSE 48689
// exit ;
48687: GO 48879
// for i = 1 to mc_bases do
48689: LD_ADDR_VAR 0 4
48693: PUSH
48694: DOUBLE
48695: LD_INT 1
48697: DEC
48698: ST_TO_ADDR
48699: LD_EXP 50
48703: PUSH
48704: FOR_TO
48705: IFFALSE 48792
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48707: LD_VAR 0 1
48711: PUSH
48712: LD_EXP 58
48716: PUSH
48717: LD_VAR 0 4
48721: ARRAY
48722: IN
48723: PUSH
48724: LD_VAR 0 1
48728: PUSH
48729: LD_EXP 59
48733: PUSH
48734: LD_VAR 0 4
48738: ARRAY
48739: IN
48740: NOT
48741: AND
48742: IFFALSE 48790
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48744: LD_ADDR_EXP 59
48748: PUSH
48749: LD_EXP 59
48753: PPUSH
48754: LD_VAR 0 4
48758: PUSH
48759: LD_EXP 59
48763: PUSH
48764: LD_VAR 0 4
48768: ARRAY
48769: PUSH
48770: LD_INT 1
48772: PLUS
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PPUSH
48778: LD_VAR 0 1
48782: PPUSH
48783: CALL 54162 0 3
48787: ST_TO_ADDR
// break ;
48788: GO 48792
// end ; end ;
48790: GO 48704
48792: POP
48793: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48794: LD_VAR 0 1
48798: PPUSH
48799: CALL_OW 257
48803: PUSH
48804: LD_EXP 76
48808: IN
48809: PUSH
48810: LD_VAR 0 1
48814: PPUSH
48815: CALL_OW 266
48819: PUSH
48820: LD_INT 5
48822: EQUAL
48823: AND
48824: PUSH
48825: LD_VAR 0 2
48829: PPUSH
48830: CALL_OW 110
48834: PUSH
48835: LD_INT 18
48837: NONEQUAL
48838: AND
48839: IFFALSE 48879
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48841: LD_VAR 0 2
48845: PPUSH
48846: CALL_OW 257
48850: PUSH
48851: LD_INT 5
48853: PUSH
48854: LD_INT 8
48856: PUSH
48857: LD_INT 9
48859: PUSH
48860: EMPTY
48861: LIST
48862: LIST
48863: LIST
48864: IN
48865: IFFALSE 48879
// SetClass ( unit , 1 ) ;
48867: LD_VAR 0 2
48871: PPUSH
48872: LD_INT 1
48874: PPUSH
48875: CALL_OW 336
// end ;
48879: LD_VAR 0 3
48883: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48884: LD_INT 0
48886: PPUSH
48887: PPUSH
// if not mc_bases or not skirmish then
48888: LD_EXP 50
48892: NOT
48893: PUSH
48894: LD_EXP 48
48898: NOT
48899: OR
48900: IFFALSE 48904
// exit ;
48902: GO 49020
// if GetLives ( abandoned_vehicle ) > 250 then
48904: LD_VAR 0 2
48908: PPUSH
48909: CALL_OW 256
48913: PUSH
48914: LD_INT 250
48916: GREATER
48917: IFFALSE 48921
// exit ;
48919: GO 49020
// for i = 1 to mc_bases do
48921: LD_ADDR_VAR 0 6
48925: PUSH
48926: DOUBLE
48927: LD_INT 1
48929: DEC
48930: ST_TO_ADDR
48931: LD_EXP 50
48935: PUSH
48936: FOR_TO
48937: IFFALSE 49018
// begin if driver in mc_bases [ i ] then
48939: LD_VAR 0 1
48943: PUSH
48944: LD_EXP 50
48948: PUSH
48949: LD_VAR 0 6
48953: ARRAY
48954: IN
48955: IFFALSE 49016
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48957: LD_VAR 0 1
48961: PPUSH
48962: LD_EXP 50
48966: PUSH
48967: LD_VAR 0 6
48971: ARRAY
48972: PPUSH
48973: LD_INT 2
48975: PUSH
48976: LD_INT 30
48978: PUSH
48979: LD_INT 0
48981: PUSH
48982: EMPTY
48983: LIST
48984: LIST
48985: PUSH
48986: LD_INT 30
48988: PUSH
48989: LD_INT 1
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: PUSH
48996: EMPTY
48997: LIST
48998: LIST
48999: LIST
49000: PPUSH
49001: CALL_OW 72
49005: PUSH
49006: LD_INT 1
49008: ARRAY
49009: PPUSH
49010: CALL 87370 0 2
// break ;
49014: GO 49018
// end ; end ;
49016: GO 48936
49018: POP
49019: POP
// end ; end_of_file
49020: LD_VAR 0 5
49024: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49025: LD_INT 0
49027: PPUSH
49028: PPUSH
// if exist_mode then
49029: LD_VAR 0 2
49033: IFFALSE 49058
// unit := CreateCharacter ( prefix & ident ) else
49035: LD_ADDR_VAR 0 5
49039: PUSH
49040: LD_VAR 0 3
49044: PUSH
49045: LD_VAR 0 1
49049: STR
49050: PPUSH
49051: CALL_OW 34
49055: ST_TO_ADDR
49056: GO 49073
// unit := NewCharacter ( ident ) ;
49058: LD_ADDR_VAR 0 5
49062: PUSH
49063: LD_VAR 0 1
49067: PPUSH
49068: CALL_OW 25
49072: ST_TO_ADDR
// result := unit ;
49073: LD_ADDR_VAR 0 4
49077: PUSH
49078: LD_VAR 0 5
49082: ST_TO_ADDR
// end ;
49083: LD_VAR 0 4
49087: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49088: LD_INT 0
49090: PPUSH
49091: PPUSH
// if not side or not nation then
49092: LD_VAR 0 1
49096: NOT
49097: PUSH
49098: LD_VAR 0 2
49102: NOT
49103: OR
49104: IFFALSE 49108
// exit ;
49106: GO 49876
// case nation of nation_american :
49108: LD_VAR 0 2
49112: PUSH
49113: LD_INT 1
49115: DOUBLE
49116: EQUAL
49117: IFTRUE 49121
49119: GO 49335
49121: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49122: LD_ADDR_VAR 0 4
49126: PUSH
49127: LD_INT 35
49129: PUSH
49130: LD_INT 45
49132: PUSH
49133: LD_INT 46
49135: PUSH
49136: LD_INT 47
49138: PUSH
49139: LD_INT 82
49141: PUSH
49142: LD_INT 83
49144: PUSH
49145: LD_INT 84
49147: PUSH
49148: LD_INT 85
49150: PUSH
49151: LD_INT 86
49153: PUSH
49154: LD_INT 1
49156: PUSH
49157: LD_INT 2
49159: PUSH
49160: LD_INT 6
49162: PUSH
49163: LD_INT 15
49165: PUSH
49166: LD_INT 16
49168: PUSH
49169: LD_INT 7
49171: PUSH
49172: LD_INT 12
49174: PUSH
49175: LD_INT 13
49177: PUSH
49178: LD_INT 10
49180: PUSH
49181: LD_INT 14
49183: PUSH
49184: LD_INT 20
49186: PUSH
49187: LD_INT 21
49189: PUSH
49190: LD_INT 22
49192: PUSH
49193: LD_INT 25
49195: PUSH
49196: LD_INT 32
49198: PUSH
49199: LD_INT 27
49201: PUSH
49202: LD_INT 36
49204: PUSH
49205: LD_INT 69
49207: PUSH
49208: LD_INT 39
49210: PUSH
49211: LD_INT 34
49213: PUSH
49214: LD_INT 40
49216: PUSH
49217: LD_INT 48
49219: PUSH
49220: LD_INT 49
49222: PUSH
49223: LD_INT 50
49225: PUSH
49226: LD_INT 51
49228: PUSH
49229: LD_INT 52
49231: PUSH
49232: LD_INT 53
49234: PUSH
49235: LD_INT 54
49237: PUSH
49238: LD_INT 55
49240: PUSH
49241: LD_INT 56
49243: PUSH
49244: LD_INT 57
49246: PUSH
49247: LD_INT 58
49249: PUSH
49250: LD_INT 59
49252: PUSH
49253: LD_INT 60
49255: PUSH
49256: LD_INT 61
49258: PUSH
49259: LD_INT 62
49261: PUSH
49262: LD_INT 80
49264: PUSH
49265: LD_INT 82
49267: PUSH
49268: LD_INT 83
49270: PUSH
49271: LD_INT 84
49273: PUSH
49274: LD_INT 85
49276: PUSH
49277: LD_INT 86
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: ST_TO_ADDR
49333: GO 49800
49335: LD_INT 2
49337: DOUBLE
49338: EQUAL
49339: IFTRUE 49343
49341: GO 49569
49343: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49344: LD_ADDR_VAR 0 4
49348: PUSH
49349: LD_INT 35
49351: PUSH
49352: LD_INT 45
49354: PUSH
49355: LD_INT 46
49357: PUSH
49358: LD_INT 47
49360: PUSH
49361: LD_INT 82
49363: PUSH
49364: LD_INT 83
49366: PUSH
49367: LD_INT 84
49369: PUSH
49370: LD_INT 85
49372: PUSH
49373: LD_INT 87
49375: PUSH
49376: LD_INT 70
49378: PUSH
49379: LD_INT 1
49381: PUSH
49382: LD_INT 11
49384: PUSH
49385: LD_INT 3
49387: PUSH
49388: LD_INT 4
49390: PUSH
49391: LD_INT 5
49393: PUSH
49394: LD_INT 6
49396: PUSH
49397: LD_INT 15
49399: PUSH
49400: LD_INT 18
49402: PUSH
49403: LD_INT 7
49405: PUSH
49406: LD_INT 17
49408: PUSH
49409: LD_INT 8
49411: PUSH
49412: LD_INT 20
49414: PUSH
49415: LD_INT 21
49417: PUSH
49418: LD_INT 22
49420: PUSH
49421: LD_INT 72
49423: PUSH
49424: LD_INT 26
49426: PUSH
49427: LD_INT 69
49429: PUSH
49430: LD_INT 39
49432: PUSH
49433: LD_INT 40
49435: PUSH
49436: LD_INT 41
49438: PUSH
49439: LD_INT 42
49441: PUSH
49442: LD_INT 43
49444: PUSH
49445: LD_INT 48
49447: PUSH
49448: LD_INT 49
49450: PUSH
49451: LD_INT 50
49453: PUSH
49454: LD_INT 51
49456: PUSH
49457: LD_INT 52
49459: PUSH
49460: LD_INT 53
49462: PUSH
49463: LD_INT 54
49465: PUSH
49466: LD_INT 55
49468: PUSH
49469: LD_INT 56
49471: PUSH
49472: LD_INT 60
49474: PUSH
49475: LD_INT 61
49477: PUSH
49478: LD_INT 62
49480: PUSH
49481: LD_INT 66
49483: PUSH
49484: LD_INT 67
49486: PUSH
49487: LD_INT 68
49489: PUSH
49490: LD_INT 81
49492: PUSH
49493: LD_INT 82
49495: PUSH
49496: LD_INT 83
49498: PUSH
49499: LD_INT 84
49501: PUSH
49502: LD_INT 85
49504: PUSH
49505: LD_INT 87
49507: PUSH
49508: LD_INT 88
49510: PUSH
49511: EMPTY
49512: LIST
49513: LIST
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: LIST
49522: LIST
49523: LIST
49524: LIST
49525: LIST
49526: LIST
49527: LIST
49528: LIST
49529: LIST
49530: LIST
49531: LIST
49532: LIST
49533: LIST
49534: LIST
49535: LIST
49536: LIST
49537: LIST
49538: LIST
49539: LIST
49540: LIST
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: LIST
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: LIST
49555: LIST
49556: LIST
49557: LIST
49558: LIST
49559: LIST
49560: LIST
49561: LIST
49562: LIST
49563: LIST
49564: LIST
49565: LIST
49566: ST_TO_ADDR
49567: GO 49800
49569: LD_INT 3
49571: DOUBLE
49572: EQUAL
49573: IFTRUE 49577
49575: GO 49799
49577: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49578: LD_ADDR_VAR 0 4
49582: PUSH
49583: LD_INT 46
49585: PUSH
49586: LD_INT 47
49588: PUSH
49589: LD_INT 1
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 82
49597: PUSH
49598: LD_INT 83
49600: PUSH
49601: LD_INT 84
49603: PUSH
49604: LD_INT 85
49606: PUSH
49607: LD_INT 86
49609: PUSH
49610: LD_INT 11
49612: PUSH
49613: LD_INT 9
49615: PUSH
49616: LD_INT 20
49618: PUSH
49619: LD_INT 19
49621: PUSH
49622: LD_INT 21
49624: PUSH
49625: LD_INT 24
49627: PUSH
49628: LD_INT 22
49630: PUSH
49631: LD_INT 25
49633: PUSH
49634: LD_INT 28
49636: PUSH
49637: LD_INT 29
49639: PUSH
49640: LD_INT 30
49642: PUSH
49643: LD_INT 31
49645: PUSH
49646: LD_INT 37
49648: PUSH
49649: LD_INT 38
49651: PUSH
49652: LD_INT 32
49654: PUSH
49655: LD_INT 27
49657: PUSH
49658: LD_INT 33
49660: PUSH
49661: LD_INT 69
49663: PUSH
49664: LD_INT 39
49666: PUSH
49667: LD_INT 34
49669: PUSH
49670: LD_INT 40
49672: PUSH
49673: LD_INT 71
49675: PUSH
49676: LD_INT 23
49678: PUSH
49679: LD_INT 44
49681: PUSH
49682: LD_INT 48
49684: PUSH
49685: LD_INT 49
49687: PUSH
49688: LD_INT 50
49690: PUSH
49691: LD_INT 51
49693: PUSH
49694: LD_INT 52
49696: PUSH
49697: LD_INT 53
49699: PUSH
49700: LD_INT 54
49702: PUSH
49703: LD_INT 55
49705: PUSH
49706: LD_INT 56
49708: PUSH
49709: LD_INT 57
49711: PUSH
49712: LD_INT 58
49714: PUSH
49715: LD_INT 59
49717: PUSH
49718: LD_INT 63
49720: PUSH
49721: LD_INT 64
49723: PUSH
49724: LD_INT 65
49726: PUSH
49727: LD_INT 82
49729: PUSH
49730: LD_INT 83
49732: PUSH
49733: LD_INT 84
49735: PUSH
49736: LD_INT 85
49738: PUSH
49739: LD_INT 86
49741: PUSH
49742: EMPTY
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: ST_TO_ADDR
49797: GO 49800
49799: POP
// if state > - 1 and state < 3 then
49800: LD_VAR 0 3
49804: PUSH
49805: LD_INT 1
49807: NEG
49808: GREATER
49809: PUSH
49810: LD_VAR 0 3
49814: PUSH
49815: LD_INT 3
49817: LESS
49818: AND
49819: IFFALSE 49876
// for i in result do
49821: LD_ADDR_VAR 0 5
49825: PUSH
49826: LD_VAR 0 4
49830: PUSH
49831: FOR_IN
49832: IFFALSE 49874
// if GetTech ( i , side ) <> state then
49834: LD_VAR 0 5
49838: PPUSH
49839: LD_VAR 0 1
49843: PPUSH
49844: CALL_OW 321
49848: PUSH
49849: LD_VAR 0 3
49853: NONEQUAL
49854: IFFALSE 49872
// result := result diff i ;
49856: LD_ADDR_VAR 0 4
49860: PUSH
49861: LD_VAR 0 4
49865: PUSH
49866: LD_VAR 0 5
49870: DIFF
49871: ST_TO_ADDR
49872: GO 49831
49874: POP
49875: POP
// end ;
49876: LD_VAR 0 4
49880: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49881: LD_INT 0
49883: PPUSH
49884: PPUSH
49885: PPUSH
// result := true ;
49886: LD_ADDR_VAR 0 3
49890: PUSH
49891: LD_INT 1
49893: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49894: LD_ADDR_VAR 0 5
49898: PUSH
49899: LD_VAR 0 2
49903: PPUSH
49904: CALL_OW 480
49908: ST_TO_ADDR
// if not tmp then
49909: LD_VAR 0 5
49913: NOT
49914: IFFALSE 49918
// exit ;
49916: GO 49967
// for i in tmp do
49918: LD_ADDR_VAR 0 4
49922: PUSH
49923: LD_VAR 0 5
49927: PUSH
49928: FOR_IN
49929: IFFALSE 49965
// if GetTech ( i , side ) <> state_researched then
49931: LD_VAR 0 4
49935: PPUSH
49936: LD_VAR 0 1
49940: PPUSH
49941: CALL_OW 321
49945: PUSH
49946: LD_INT 2
49948: NONEQUAL
49949: IFFALSE 49963
// begin result := false ;
49951: LD_ADDR_VAR 0 3
49955: PUSH
49956: LD_INT 0
49958: ST_TO_ADDR
// exit ;
49959: POP
49960: POP
49961: GO 49967
// end ;
49963: GO 49928
49965: POP
49966: POP
// end ;
49967: LD_VAR 0 3
49971: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49972: LD_INT 0
49974: PPUSH
49975: PPUSH
49976: PPUSH
49977: PPUSH
49978: PPUSH
49979: PPUSH
49980: PPUSH
49981: PPUSH
49982: PPUSH
49983: PPUSH
49984: PPUSH
49985: PPUSH
49986: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49987: LD_VAR 0 1
49991: NOT
49992: PUSH
49993: LD_VAR 0 1
49997: PPUSH
49998: CALL_OW 257
50002: PUSH
50003: LD_INT 9
50005: NONEQUAL
50006: OR
50007: IFFALSE 50011
// exit ;
50009: GO 50584
// side := GetSide ( unit ) ;
50011: LD_ADDR_VAR 0 9
50015: PUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 255
50025: ST_TO_ADDR
// tech_space := tech_spacanom ;
50026: LD_ADDR_VAR 0 12
50030: PUSH
50031: LD_INT 29
50033: ST_TO_ADDR
// tech_time := tech_taurad ;
50034: LD_ADDR_VAR 0 13
50038: PUSH
50039: LD_INT 28
50041: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50042: LD_ADDR_VAR 0 11
50046: PUSH
50047: LD_VAR 0 1
50051: PPUSH
50052: CALL_OW 310
50056: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50057: LD_VAR 0 11
50061: PPUSH
50062: CALL_OW 247
50066: PUSH
50067: LD_INT 2
50069: EQUAL
50070: IFFALSE 50074
// exit ;
50072: GO 50584
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50074: LD_ADDR_VAR 0 8
50078: PUSH
50079: LD_INT 81
50081: PUSH
50082: LD_VAR 0 9
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PUSH
50091: LD_INT 3
50093: PUSH
50094: LD_INT 21
50096: PUSH
50097: LD_INT 3
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PUSH
50104: EMPTY
50105: LIST
50106: LIST
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: PPUSH
50112: CALL_OW 69
50116: ST_TO_ADDR
// if not tmp then
50117: LD_VAR 0 8
50121: NOT
50122: IFFALSE 50126
// exit ;
50124: GO 50584
// if in_unit then
50126: LD_VAR 0 11
50130: IFFALSE 50154
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50132: LD_ADDR_VAR 0 10
50136: PUSH
50137: LD_VAR 0 8
50141: PPUSH
50142: LD_VAR 0 11
50146: PPUSH
50147: CALL_OW 74
50151: ST_TO_ADDR
50152: GO 50174
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50154: LD_ADDR_VAR 0 10
50158: PUSH
50159: LD_VAR 0 8
50163: PPUSH
50164: LD_VAR 0 1
50168: PPUSH
50169: CALL_OW 74
50173: ST_TO_ADDR
// if not enemy then
50174: LD_VAR 0 10
50178: NOT
50179: IFFALSE 50183
// exit ;
50181: GO 50584
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50183: LD_VAR 0 11
50187: PUSH
50188: LD_VAR 0 11
50192: PPUSH
50193: LD_VAR 0 10
50197: PPUSH
50198: CALL_OW 296
50202: PUSH
50203: LD_INT 13
50205: GREATER
50206: AND
50207: PUSH
50208: LD_VAR 0 1
50212: PPUSH
50213: LD_VAR 0 10
50217: PPUSH
50218: CALL_OW 296
50222: PUSH
50223: LD_INT 12
50225: GREATER
50226: OR
50227: IFFALSE 50231
// exit ;
50229: GO 50584
// missile := [ 1 ] ;
50231: LD_ADDR_VAR 0 14
50235: PUSH
50236: LD_INT 1
50238: PUSH
50239: EMPTY
50240: LIST
50241: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50242: LD_VAR 0 9
50246: PPUSH
50247: LD_VAR 0 12
50251: PPUSH
50252: CALL_OW 325
50256: IFFALSE 50285
// missile := Replace ( missile , missile + 1 , 2 ) ;
50258: LD_ADDR_VAR 0 14
50262: PUSH
50263: LD_VAR 0 14
50267: PPUSH
50268: LD_VAR 0 14
50272: PUSH
50273: LD_INT 1
50275: PLUS
50276: PPUSH
50277: LD_INT 2
50279: PPUSH
50280: CALL_OW 1
50284: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50285: LD_VAR 0 9
50289: PPUSH
50290: LD_VAR 0 13
50294: PPUSH
50295: CALL_OW 325
50299: PUSH
50300: LD_VAR 0 10
50304: PPUSH
50305: CALL_OW 255
50309: PPUSH
50310: LD_VAR 0 13
50314: PPUSH
50315: CALL_OW 325
50319: NOT
50320: AND
50321: IFFALSE 50350
// missile := Replace ( missile , missile + 1 , 3 ) ;
50323: LD_ADDR_VAR 0 14
50327: PUSH
50328: LD_VAR 0 14
50332: PPUSH
50333: LD_VAR 0 14
50337: PUSH
50338: LD_INT 1
50340: PLUS
50341: PPUSH
50342: LD_INT 3
50344: PPUSH
50345: CALL_OW 1
50349: ST_TO_ADDR
// if missile < 2 then
50350: LD_VAR 0 14
50354: PUSH
50355: LD_INT 2
50357: LESS
50358: IFFALSE 50362
// exit ;
50360: GO 50584
// x := GetX ( enemy ) ;
50362: LD_ADDR_VAR 0 4
50366: PUSH
50367: LD_VAR 0 10
50371: PPUSH
50372: CALL_OW 250
50376: ST_TO_ADDR
// y := GetY ( enemy ) ;
50377: LD_ADDR_VAR 0 5
50381: PUSH
50382: LD_VAR 0 10
50386: PPUSH
50387: CALL_OW 251
50391: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50392: LD_ADDR_VAR 0 6
50396: PUSH
50397: LD_VAR 0 4
50401: PUSH
50402: LD_INT 1
50404: NEG
50405: PPUSH
50406: LD_INT 1
50408: PPUSH
50409: CALL_OW 12
50413: PLUS
50414: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50415: LD_ADDR_VAR 0 7
50419: PUSH
50420: LD_VAR 0 5
50424: PUSH
50425: LD_INT 1
50427: NEG
50428: PPUSH
50429: LD_INT 1
50431: PPUSH
50432: CALL_OW 12
50436: PLUS
50437: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50438: LD_VAR 0 6
50442: PPUSH
50443: LD_VAR 0 7
50447: PPUSH
50448: CALL_OW 488
50452: NOT
50453: IFFALSE 50475
// begin _x := x ;
50455: LD_ADDR_VAR 0 6
50459: PUSH
50460: LD_VAR 0 4
50464: ST_TO_ADDR
// _y := y ;
50465: LD_ADDR_VAR 0 7
50469: PUSH
50470: LD_VAR 0 5
50474: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50475: LD_ADDR_VAR 0 3
50479: PUSH
50480: LD_INT 1
50482: PPUSH
50483: LD_VAR 0 14
50487: PPUSH
50488: CALL_OW 12
50492: ST_TO_ADDR
// case i of 1 :
50493: LD_VAR 0 3
50497: PUSH
50498: LD_INT 1
50500: DOUBLE
50501: EQUAL
50502: IFTRUE 50506
50504: GO 50523
50506: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50507: LD_VAR 0 1
50511: PPUSH
50512: LD_VAR 0 10
50516: PPUSH
50517: CALL_OW 115
50521: GO 50584
50523: LD_INT 2
50525: DOUBLE
50526: EQUAL
50527: IFTRUE 50531
50529: GO 50553
50531: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50532: LD_VAR 0 1
50536: PPUSH
50537: LD_VAR 0 6
50541: PPUSH
50542: LD_VAR 0 7
50546: PPUSH
50547: CALL_OW 153
50551: GO 50584
50553: LD_INT 3
50555: DOUBLE
50556: EQUAL
50557: IFTRUE 50561
50559: GO 50583
50561: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50562: LD_VAR 0 1
50566: PPUSH
50567: LD_VAR 0 6
50571: PPUSH
50572: LD_VAR 0 7
50576: PPUSH
50577: CALL_OW 154
50581: GO 50584
50583: POP
// end ;
50584: LD_VAR 0 2
50588: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50589: LD_INT 0
50591: PPUSH
50592: PPUSH
50593: PPUSH
50594: PPUSH
50595: PPUSH
50596: PPUSH
// if not unit or not building then
50597: LD_VAR 0 1
50601: NOT
50602: PUSH
50603: LD_VAR 0 2
50607: NOT
50608: OR
50609: IFFALSE 50613
// exit ;
50611: GO 50771
// x := GetX ( building ) ;
50613: LD_ADDR_VAR 0 5
50617: PUSH
50618: LD_VAR 0 2
50622: PPUSH
50623: CALL_OW 250
50627: ST_TO_ADDR
// y := GetY ( building ) ;
50628: LD_ADDR_VAR 0 6
50632: PUSH
50633: LD_VAR 0 2
50637: PPUSH
50638: CALL_OW 251
50642: ST_TO_ADDR
// for i = 0 to 5 do
50643: LD_ADDR_VAR 0 4
50647: PUSH
50648: DOUBLE
50649: LD_INT 0
50651: DEC
50652: ST_TO_ADDR
50653: LD_INT 5
50655: PUSH
50656: FOR_TO
50657: IFFALSE 50769
// begin _x := ShiftX ( x , i , 3 ) ;
50659: LD_ADDR_VAR 0 7
50663: PUSH
50664: LD_VAR 0 5
50668: PPUSH
50669: LD_VAR 0 4
50673: PPUSH
50674: LD_INT 3
50676: PPUSH
50677: CALL_OW 272
50681: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50682: LD_ADDR_VAR 0 8
50686: PUSH
50687: LD_VAR 0 6
50691: PPUSH
50692: LD_VAR 0 4
50696: PPUSH
50697: LD_INT 3
50699: PPUSH
50700: CALL_OW 273
50704: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50705: LD_VAR 0 7
50709: PPUSH
50710: LD_VAR 0 8
50714: PPUSH
50715: CALL_OW 488
50719: NOT
50720: IFFALSE 50724
// continue ;
50722: GO 50656
// if HexInfo ( _x , _y ) = 0 then
50724: LD_VAR 0 7
50728: PPUSH
50729: LD_VAR 0 8
50733: PPUSH
50734: CALL_OW 428
50738: PUSH
50739: LD_INT 0
50741: EQUAL
50742: IFFALSE 50767
// begin ComMoveXY ( unit , _x , _y ) ;
50744: LD_VAR 0 1
50748: PPUSH
50749: LD_VAR 0 7
50753: PPUSH
50754: LD_VAR 0 8
50758: PPUSH
50759: CALL_OW 111
// exit ;
50763: POP
50764: POP
50765: GO 50771
// end ; end ;
50767: GO 50656
50769: POP
50770: POP
// end ;
50771: LD_VAR 0 3
50775: RET
// export function ScanBase ( side , base_area ) ; begin
50776: LD_INT 0
50778: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50779: LD_ADDR_VAR 0 3
50783: PUSH
50784: LD_VAR 0 2
50788: PPUSH
50789: LD_INT 81
50791: PUSH
50792: LD_VAR 0 1
50796: PUSH
50797: EMPTY
50798: LIST
50799: LIST
50800: PPUSH
50801: CALL_OW 70
50805: ST_TO_ADDR
// end ;
50806: LD_VAR 0 3
50810: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50811: LD_INT 0
50813: PPUSH
50814: PPUSH
50815: PPUSH
50816: PPUSH
// result := false ;
50817: LD_ADDR_VAR 0 2
50821: PUSH
50822: LD_INT 0
50824: ST_TO_ADDR
// side := GetSide ( unit ) ;
50825: LD_ADDR_VAR 0 3
50829: PUSH
50830: LD_VAR 0 1
50834: PPUSH
50835: CALL_OW 255
50839: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50840: LD_ADDR_VAR 0 4
50844: PUSH
50845: LD_VAR 0 1
50849: PPUSH
50850: CALL_OW 248
50854: ST_TO_ADDR
// case nat of 1 :
50855: LD_VAR 0 4
50859: PUSH
50860: LD_INT 1
50862: DOUBLE
50863: EQUAL
50864: IFTRUE 50868
50866: GO 50879
50868: POP
// tech := tech_lassight ; 2 :
50869: LD_ADDR_VAR 0 5
50873: PUSH
50874: LD_INT 12
50876: ST_TO_ADDR
50877: GO 50918
50879: LD_INT 2
50881: DOUBLE
50882: EQUAL
50883: IFTRUE 50887
50885: GO 50898
50887: POP
// tech := tech_mortar ; 3 :
50888: LD_ADDR_VAR 0 5
50892: PUSH
50893: LD_INT 41
50895: ST_TO_ADDR
50896: GO 50918
50898: LD_INT 3
50900: DOUBLE
50901: EQUAL
50902: IFTRUE 50906
50904: GO 50917
50906: POP
// tech := tech_bazooka ; end ;
50907: LD_ADDR_VAR 0 5
50911: PUSH
50912: LD_INT 44
50914: ST_TO_ADDR
50915: GO 50918
50917: POP
// if Researched ( side , tech ) then
50918: LD_VAR 0 3
50922: PPUSH
50923: LD_VAR 0 5
50927: PPUSH
50928: CALL_OW 325
50932: IFFALSE 50959
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50934: LD_ADDR_VAR 0 2
50938: PUSH
50939: LD_INT 5
50941: PUSH
50942: LD_INT 8
50944: PUSH
50945: LD_INT 9
50947: PUSH
50948: EMPTY
50949: LIST
50950: LIST
50951: LIST
50952: PUSH
50953: LD_VAR 0 4
50957: ARRAY
50958: ST_TO_ADDR
// end ;
50959: LD_VAR 0 2
50963: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50964: LD_INT 0
50966: PPUSH
50967: PPUSH
50968: PPUSH
// if not mines then
50969: LD_VAR 0 2
50973: NOT
50974: IFFALSE 50978
// exit ;
50976: GO 51122
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50978: LD_ADDR_VAR 0 5
50982: PUSH
50983: LD_INT 81
50985: PUSH
50986: LD_VAR 0 1
50990: PUSH
50991: EMPTY
50992: LIST
50993: LIST
50994: PUSH
50995: LD_INT 3
50997: PUSH
50998: LD_INT 21
51000: PUSH
51001: LD_INT 3
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: PPUSH
51016: CALL_OW 69
51020: ST_TO_ADDR
// for i in mines do
51021: LD_ADDR_VAR 0 4
51025: PUSH
51026: LD_VAR 0 2
51030: PUSH
51031: FOR_IN
51032: IFFALSE 51120
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51034: LD_VAR 0 4
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PPUSH
51043: LD_VAR 0 4
51047: PUSH
51048: LD_INT 2
51050: ARRAY
51051: PPUSH
51052: CALL_OW 458
51056: NOT
51057: IFFALSE 51061
// continue ;
51059: GO 51031
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51061: LD_VAR 0 4
51065: PUSH
51066: LD_INT 1
51068: ARRAY
51069: PPUSH
51070: LD_VAR 0 4
51074: PUSH
51075: LD_INT 2
51077: ARRAY
51078: PPUSH
51079: CALL_OW 428
51083: PUSH
51084: LD_VAR 0 5
51088: IN
51089: IFFALSE 51118
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51091: LD_VAR 0 4
51095: PUSH
51096: LD_INT 1
51098: ARRAY
51099: PPUSH
51100: LD_VAR 0 4
51104: PUSH
51105: LD_INT 2
51107: ARRAY
51108: PPUSH
51109: LD_VAR 0 1
51113: PPUSH
51114: CALL_OW 456
// end ;
51118: GO 51031
51120: POP
51121: POP
// end ;
51122: LD_VAR 0 3
51126: RET
// export function Count ( array ) ; var i ; begin
51127: LD_INT 0
51129: PPUSH
51130: PPUSH
// result := 0 ;
51131: LD_ADDR_VAR 0 2
51135: PUSH
51136: LD_INT 0
51138: ST_TO_ADDR
// for i in array do
51139: LD_ADDR_VAR 0 3
51143: PUSH
51144: LD_VAR 0 1
51148: PUSH
51149: FOR_IN
51150: IFFALSE 51174
// if i then
51152: LD_VAR 0 3
51156: IFFALSE 51172
// result := result + 1 ;
51158: LD_ADDR_VAR 0 2
51162: PUSH
51163: LD_VAR 0 2
51167: PUSH
51168: LD_INT 1
51170: PLUS
51171: ST_TO_ADDR
51172: GO 51149
51174: POP
51175: POP
// end ;
51176: LD_VAR 0 2
51180: RET
// export function IsEmpty ( building ) ; begin
51181: LD_INT 0
51183: PPUSH
// if not building then
51184: LD_VAR 0 1
51188: NOT
51189: IFFALSE 51193
// exit ;
51191: GO 51236
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51193: LD_ADDR_VAR 0 2
51197: PUSH
51198: LD_VAR 0 1
51202: PUSH
51203: LD_INT 22
51205: PUSH
51206: LD_VAR 0 1
51210: PPUSH
51211: CALL_OW 255
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PUSH
51220: LD_INT 58
51222: PUSH
51223: EMPTY
51224: LIST
51225: PUSH
51226: EMPTY
51227: LIST
51228: LIST
51229: PPUSH
51230: CALL_OW 69
51234: IN
51235: ST_TO_ADDR
// end ;
51236: LD_VAR 0 2
51240: RET
// export function IsNotFull ( building ) ; var places ; begin
51241: LD_INT 0
51243: PPUSH
51244: PPUSH
// if not building then
51245: LD_VAR 0 1
51249: NOT
51250: IFFALSE 51254
// exit ;
51252: GO 51425
// result := false ;
51254: LD_ADDR_VAR 0 2
51258: PUSH
51259: LD_INT 0
51261: ST_TO_ADDR
// places := 0 ;
51262: LD_ADDR_VAR 0 3
51266: PUSH
51267: LD_INT 0
51269: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
51270: LD_VAR 0 1
51274: PPUSH
51275: CALL_OW 266
51279: PUSH
51280: LD_INT 0
51282: DOUBLE
51283: EQUAL
51284: IFTRUE 51342
51286: LD_INT 1
51288: DOUBLE
51289: EQUAL
51290: IFTRUE 51342
51292: LD_INT 6
51294: DOUBLE
51295: EQUAL
51296: IFTRUE 51342
51298: LD_INT 7
51300: DOUBLE
51301: EQUAL
51302: IFTRUE 51342
51304: LD_INT 8
51306: DOUBLE
51307: EQUAL
51308: IFTRUE 51342
51310: LD_INT 4
51312: DOUBLE
51313: EQUAL
51314: IFTRUE 51342
51316: LD_INT 5
51318: DOUBLE
51319: EQUAL
51320: IFTRUE 51342
51322: LD_INT 2
51324: DOUBLE
51325: EQUAL
51326: IFTRUE 51342
51328: LD_INT 3
51330: DOUBLE
51331: EQUAL
51332: IFTRUE 51342
51334: LD_INT 35
51336: DOUBLE
51337: EQUAL
51338: IFTRUE 51342
51340: GO 51353
51342: POP
// places := 6 ; b_bunker , b_breastwork :
51343: LD_ADDR_VAR 0 3
51347: PUSH
51348: LD_INT 6
51350: ST_TO_ADDR
51351: GO 51398
51353: LD_INT 32
51355: DOUBLE
51356: EQUAL
51357: IFTRUE 51367
51359: LD_INT 31
51361: DOUBLE
51362: EQUAL
51363: IFTRUE 51367
51365: GO 51378
51367: POP
// places := 1 ; b_control_tower :
51368: LD_ADDR_VAR 0 3
51372: PUSH
51373: LD_INT 1
51375: ST_TO_ADDR
51376: GO 51398
51378: LD_INT 36
51380: DOUBLE
51381: EQUAL
51382: IFTRUE 51386
51384: GO 51397
51386: POP
// places := 3 ; end ;
51387: LD_ADDR_VAR 0 3
51391: PUSH
51392: LD_INT 3
51394: ST_TO_ADDR
51395: GO 51398
51397: POP
// if places then
51398: LD_VAR 0 3
51402: IFFALSE 51425
// result := UnitsInside ( building ) < places ;
51404: LD_ADDR_VAR 0 2
51408: PUSH
51409: LD_VAR 0 1
51413: PPUSH
51414: CALL_OW 313
51418: PUSH
51419: LD_VAR 0 3
51423: LESS
51424: ST_TO_ADDR
// end ;
51425: LD_VAR 0 2
51429: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51430: LD_INT 0
51432: PPUSH
51433: PPUSH
51434: PPUSH
51435: PPUSH
// tmp := [ ] ;
51436: LD_ADDR_VAR 0 3
51440: PUSH
51441: EMPTY
51442: ST_TO_ADDR
// list := [ ] ;
51443: LD_ADDR_VAR 0 5
51447: PUSH
51448: EMPTY
51449: ST_TO_ADDR
// for i = 16 to 25 do
51450: LD_ADDR_VAR 0 4
51454: PUSH
51455: DOUBLE
51456: LD_INT 16
51458: DEC
51459: ST_TO_ADDR
51460: LD_INT 25
51462: PUSH
51463: FOR_TO
51464: IFFALSE 51537
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51466: LD_ADDR_VAR 0 3
51470: PUSH
51471: LD_VAR 0 3
51475: PUSH
51476: LD_INT 22
51478: PUSH
51479: LD_VAR 0 1
51483: PPUSH
51484: CALL_OW 255
51488: PUSH
51489: EMPTY
51490: LIST
51491: LIST
51492: PUSH
51493: LD_INT 91
51495: PUSH
51496: LD_VAR 0 1
51500: PUSH
51501: LD_INT 6
51503: PUSH
51504: EMPTY
51505: LIST
51506: LIST
51507: LIST
51508: PUSH
51509: LD_INT 30
51511: PUSH
51512: LD_VAR 0 4
51516: PUSH
51517: EMPTY
51518: LIST
51519: LIST
51520: PUSH
51521: EMPTY
51522: LIST
51523: LIST
51524: LIST
51525: PUSH
51526: EMPTY
51527: LIST
51528: PPUSH
51529: CALL_OW 69
51533: ADD
51534: ST_TO_ADDR
51535: GO 51463
51537: POP
51538: POP
// for i = 1 to tmp do
51539: LD_ADDR_VAR 0 4
51543: PUSH
51544: DOUBLE
51545: LD_INT 1
51547: DEC
51548: ST_TO_ADDR
51549: LD_VAR 0 3
51553: PUSH
51554: FOR_TO
51555: IFFALSE 51643
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51557: LD_ADDR_VAR 0 5
51561: PUSH
51562: LD_VAR 0 5
51566: PUSH
51567: LD_VAR 0 3
51571: PUSH
51572: LD_VAR 0 4
51576: ARRAY
51577: PPUSH
51578: CALL_OW 266
51582: PUSH
51583: LD_VAR 0 3
51587: PUSH
51588: LD_VAR 0 4
51592: ARRAY
51593: PPUSH
51594: CALL_OW 250
51598: PUSH
51599: LD_VAR 0 3
51603: PUSH
51604: LD_VAR 0 4
51608: ARRAY
51609: PPUSH
51610: CALL_OW 251
51614: PUSH
51615: LD_VAR 0 3
51619: PUSH
51620: LD_VAR 0 4
51624: ARRAY
51625: PPUSH
51626: CALL_OW 254
51630: PUSH
51631: EMPTY
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: PUSH
51637: EMPTY
51638: LIST
51639: ADD
51640: ST_TO_ADDR
51641: GO 51554
51643: POP
51644: POP
// result := list ;
51645: LD_ADDR_VAR 0 2
51649: PUSH
51650: LD_VAR 0 5
51654: ST_TO_ADDR
// end ;
51655: LD_VAR 0 2
51659: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51660: LD_INT 0
51662: PPUSH
51663: PPUSH
51664: PPUSH
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
// if not factory then
51669: LD_VAR 0 1
51673: NOT
51674: IFFALSE 51678
// exit ;
51676: GO 52271
// if control = control_apeman then
51678: LD_VAR 0 4
51682: PUSH
51683: LD_INT 5
51685: EQUAL
51686: IFFALSE 51795
// begin tmp := UnitsInside ( factory ) ;
51688: LD_ADDR_VAR 0 8
51692: PUSH
51693: LD_VAR 0 1
51697: PPUSH
51698: CALL_OW 313
51702: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51703: LD_VAR 0 8
51707: PPUSH
51708: LD_INT 25
51710: PUSH
51711: LD_INT 12
51713: PUSH
51714: EMPTY
51715: LIST
51716: LIST
51717: PPUSH
51718: CALL_OW 72
51722: NOT
51723: IFFALSE 51733
// control := control_manual ;
51725: LD_ADDR_VAR 0 4
51729: PUSH
51730: LD_INT 1
51732: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51733: LD_ADDR_VAR 0 8
51737: PUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL 51430 0 1
51747: ST_TO_ADDR
// if tmp then
51748: LD_VAR 0 8
51752: IFFALSE 51795
// begin for i in tmp do
51754: LD_ADDR_VAR 0 7
51758: PUSH
51759: LD_VAR 0 8
51763: PUSH
51764: FOR_IN
51765: IFFALSE 51793
// if i [ 1 ] = b_ext_radio then
51767: LD_VAR 0 7
51771: PUSH
51772: LD_INT 1
51774: ARRAY
51775: PUSH
51776: LD_INT 22
51778: EQUAL
51779: IFFALSE 51791
// begin control := control_remote ;
51781: LD_ADDR_VAR 0 4
51785: PUSH
51786: LD_INT 2
51788: ST_TO_ADDR
// break ;
51789: GO 51793
// end ;
51791: GO 51764
51793: POP
51794: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51795: LD_VAR 0 1
51799: PPUSH
51800: LD_VAR 0 2
51804: PPUSH
51805: LD_VAR 0 3
51809: PPUSH
51810: LD_VAR 0 4
51814: PPUSH
51815: LD_VAR 0 5
51819: PPUSH
51820: CALL_OW 448
51824: IFFALSE 51859
// begin result := [ chassis , engine , control , weapon ] ;
51826: LD_ADDR_VAR 0 6
51830: PUSH
51831: LD_VAR 0 2
51835: PUSH
51836: LD_VAR 0 3
51840: PUSH
51841: LD_VAR 0 4
51845: PUSH
51846: LD_VAR 0 5
51850: PUSH
51851: EMPTY
51852: LIST
51853: LIST
51854: LIST
51855: LIST
51856: ST_TO_ADDR
// exit ;
51857: GO 52271
// end ; _chassis := AvailableChassisList ( factory ) ;
51859: LD_ADDR_VAR 0 9
51863: PUSH
51864: LD_VAR 0 1
51868: PPUSH
51869: CALL_OW 475
51873: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51874: LD_ADDR_VAR 0 11
51878: PUSH
51879: LD_VAR 0 1
51883: PPUSH
51884: CALL_OW 476
51888: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51889: LD_ADDR_VAR 0 12
51893: PUSH
51894: LD_VAR 0 1
51898: PPUSH
51899: CALL_OW 477
51903: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51904: LD_ADDR_VAR 0 10
51908: PUSH
51909: LD_VAR 0 1
51913: PPUSH
51914: CALL_OW 478
51918: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51919: LD_VAR 0 9
51923: NOT
51924: PUSH
51925: LD_VAR 0 11
51929: NOT
51930: OR
51931: PUSH
51932: LD_VAR 0 12
51936: NOT
51937: OR
51938: PUSH
51939: LD_VAR 0 10
51943: NOT
51944: OR
51945: IFFALSE 51980
// begin result := [ chassis , engine , control , weapon ] ;
51947: LD_ADDR_VAR 0 6
51951: PUSH
51952: LD_VAR 0 2
51956: PUSH
51957: LD_VAR 0 3
51961: PUSH
51962: LD_VAR 0 4
51966: PUSH
51967: LD_VAR 0 5
51971: PUSH
51972: EMPTY
51973: LIST
51974: LIST
51975: LIST
51976: LIST
51977: ST_TO_ADDR
// exit ;
51978: GO 52271
// end ; if not chassis in _chassis then
51980: LD_VAR 0 2
51984: PUSH
51985: LD_VAR 0 9
51989: IN
51990: NOT
51991: IFFALSE 52017
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51993: LD_ADDR_VAR 0 2
51997: PUSH
51998: LD_VAR 0 9
52002: PUSH
52003: LD_INT 1
52005: PPUSH
52006: LD_VAR 0 9
52010: PPUSH
52011: CALL_OW 12
52015: ARRAY
52016: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52017: LD_VAR 0 2
52021: PPUSH
52022: LD_VAR 0 3
52026: PPUSH
52027: CALL 52276 0 2
52031: NOT
52032: IFFALSE 52091
// repeat engine := _engine [ 1 ] ;
52034: LD_ADDR_VAR 0 3
52038: PUSH
52039: LD_VAR 0 11
52043: PUSH
52044: LD_INT 1
52046: ARRAY
52047: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52048: LD_ADDR_VAR 0 11
52052: PUSH
52053: LD_VAR 0 11
52057: PPUSH
52058: LD_INT 1
52060: PPUSH
52061: CALL_OW 3
52065: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52066: LD_VAR 0 2
52070: PPUSH
52071: LD_VAR 0 3
52075: PPUSH
52076: CALL 52276 0 2
52080: PUSH
52081: LD_VAR 0 11
52085: PUSH
52086: EMPTY
52087: EQUAL
52088: OR
52089: IFFALSE 52034
// if not control in _control then
52091: LD_VAR 0 4
52095: PUSH
52096: LD_VAR 0 12
52100: IN
52101: NOT
52102: IFFALSE 52128
// control := _control [ rand ( 1 , _control ) ] ;
52104: LD_ADDR_VAR 0 4
52108: PUSH
52109: LD_VAR 0 12
52113: PUSH
52114: LD_INT 1
52116: PPUSH
52117: LD_VAR 0 12
52121: PPUSH
52122: CALL_OW 12
52126: ARRAY
52127: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52128: LD_VAR 0 2
52132: PPUSH
52133: LD_VAR 0 5
52137: PPUSH
52138: CALL 52496 0 2
52142: NOT
52143: IFFALSE 52202
// repeat weapon := _weapon [ 1 ] ;
52145: LD_ADDR_VAR 0 5
52149: PUSH
52150: LD_VAR 0 10
52154: PUSH
52155: LD_INT 1
52157: ARRAY
52158: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52159: LD_ADDR_VAR 0 10
52163: PUSH
52164: LD_VAR 0 10
52168: PPUSH
52169: LD_INT 1
52171: PPUSH
52172: CALL_OW 3
52176: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52177: LD_VAR 0 2
52181: PPUSH
52182: LD_VAR 0 5
52186: PPUSH
52187: CALL 52496 0 2
52191: PUSH
52192: LD_VAR 0 10
52196: PUSH
52197: EMPTY
52198: EQUAL
52199: OR
52200: IFFALSE 52145
// result := [ ] ;
52202: LD_ADDR_VAR 0 6
52206: PUSH
52207: EMPTY
52208: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52209: LD_VAR 0 1
52213: PPUSH
52214: LD_VAR 0 2
52218: PPUSH
52219: LD_VAR 0 3
52223: PPUSH
52224: LD_VAR 0 4
52228: PPUSH
52229: LD_VAR 0 5
52233: PPUSH
52234: CALL_OW 448
52238: IFFALSE 52271
// result := [ chassis , engine , control , weapon ] ;
52240: LD_ADDR_VAR 0 6
52244: PUSH
52245: LD_VAR 0 2
52249: PUSH
52250: LD_VAR 0 3
52254: PUSH
52255: LD_VAR 0 4
52259: PUSH
52260: LD_VAR 0 5
52264: PUSH
52265: EMPTY
52266: LIST
52267: LIST
52268: LIST
52269: LIST
52270: ST_TO_ADDR
// end ;
52271: LD_VAR 0 6
52275: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52276: LD_INT 0
52278: PPUSH
// if not chassis or not engine then
52279: LD_VAR 0 1
52283: NOT
52284: PUSH
52285: LD_VAR 0 2
52289: NOT
52290: OR
52291: IFFALSE 52295
// exit ;
52293: GO 52491
// case engine of engine_solar :
52295: LD_VAR 0 2
52299: PUSH
52300: LD_INT 2
52302: DOUBLE
52303: EQUAL
52304: IFTRUE 52308
52306: GO 52346
52308: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52309: LD_ADDR_VAR 0 3
52313: PUSH
52314: LD_INT 11
52316: PUSH
52317: LD_INT 12
52319: PUSH
52320: LD_INT 13
52322: PUSH
52323: LD_INT 14
52325: PUSH
52326: LD_INT 1
52328: PUSH
52329: LD_INT 2
52331: PUSH
52332: LD_INT 3
52334: PUSH
52335: EMPTY
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: ST_TO_ADDR
52344: GO 52475
52346: LD_INT 1
52348: DOUBLE
52349: EQUAL
52350: IFTRUE 52354
52352: GO 52416
52354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52355: LD_ADDR_VAR 0 3
52359: PUSH
52360: LD_INT 11
52362: PUSH
52363: LD_INT 12
52365: PUSH
52366: LD_INT 13
52368: PUSH
52369: LD_INT 14
52371: PUSH
52372: LD_INT 1
52374: PUSH
52375: LD_INT 2
52377: PUSH
52378: LD_INT 3
52380: PUSH
52381: LD_INT 4
52383: PUSH
52384: LD_INT 5
52386: PUSH
52387: LD_INT 21
52389: PUSH
52390: LD_INT 23
52392: PUSH
52393: LD_INT 22
52395: PUSH
52396: LD_INT 24
52398: PUSH
52399: EMPTY
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: LIST
52405: LIST
52406: LIST
52407: LIST
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: ST_TO_ADDR
52414: GO 52475
52416: LD_INT 3
52418: DOUBLE
52419: EQUAL
52420: IFTRUE 52424
52422: GO 52474
52424: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52425: LD_ADDR_VAR 0 3
52429: PUSH
52430: LD_INT 13
52432: PUSH
52433: LD_INT 14
52435: PUSH
52436: LD_INT 2
52438: PUSH
52439: LD_INT 3
52441: PUSH
52442: LD_INT 4
52444: PUSH
52445: LD_INT 5
52447: PUSH
52448: LD_INT 21
52450: PUSH
52451: LD_INT 22
52453: PUSH
52454: LD_INT 23
52456: PUSH
52457: LD_INT 24
52459: PUSH
52460: EMPTY
52461: LIST
52462: LIST
52463: LIST
52464: LIST
52465: LIST
52466: LIST
52467: LIST
52468: LIST
52469: LIST
52470: LIST
52471: ST_TO_ADDR
52472: GO 52475
52474: POP
// result := ( chassis in result ) ;
52475: LD_ADDR_VAR 0 3
52479: PUSH
52480: LD_VAR 0 1
52484: PUSH
52485: LD_VAR 0 3
52489: IN
52490: ST_TO_ADDR
// end ;
52491: LD_VAR 0 3
52495: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52496: LD_INT 0
52498: PPUSH
// if not chassis or not weapon then
52499: LD_VAR 0 1
52503: NOT
52504: PUSH
52505: LD_VAR 0 2
52509: NOT
52510: OR
52511: IFFALSE 52515
// exit ;
52513: GO 53575
// case weapon of us_machine_gun :
52515: LD_VAR 0 2
52519: PUSH
52520: LD_INT 2
52522: DOUBLE
52523: EQUAL
52524: IFTRUE 52528
52526: GO 52558
52528: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52529: LD_ADDR_VAR 0 3
52533: PUSH
52534: LD_INT 1
52536: PUSH
52537: LD_INT 2
52539: PUSH
52540: LD_INT 3
52542: PUSH
52543: LD_INT 4
52545: PUSH
52546: LD_INT 5
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: ST_TO_ADDR
52556: GO 53559
52558: LD_INT 3
52560: DOUBLE
52561: EQUAL
52562: IFTRUE 52566
52564: GO 52596
52566: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52567: LD_ADDR_VAR 0 3
52571: PUSH
52572: LD_INT 1
52574: PUSH
52575: LD_INT 2
52577: PUSH
52578: LD_INT 3
52580: PUSH
52581: LD_INT 4
52583: PUSH
52584: LD_INT 5
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: LIST
52591: LIST
52592: LIST
52593: ST_TO_ADDR
52594: GO 53559
52596: LD_INT 11
52598: DOUBLE
52599: EQUAL
52600: IFTRUE 52604
52602: GO 52634
52604: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52605: LD_ADDR_VAR 0 3
52609: PUSH
52610: LD_INT 1
52612: PUSH
52613: LD_INT 2
52615: PUSH
52616: LD_INT 3
52618: PUSH
52619: LD_INT 4
52621: PUSH
52622: LD_INT 5
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: LIST
52629: LIST
52630: LIST
52631: ST_TO_ADDR
52632: GO 53559
52634: LD_INT 4
52636: DOUBLE
52637: EQUAL
52638: IFTRUE 52642
52640: GO 52668
52642: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52643: LD_ADDR_VAR 0 3
52647: PUSH
52648: LD_INT 2
52650: PUSH
52651: LD_INT 3
52653: PUSH
52654: LD_INT 4
52656: PUSH
52657: LD_INT 5
52659: PUSH
52660: EMPTY
52661: LIST
52662: LIST
52663: LIST
52664: LIST
52665: ST_TO_ADDR
52666: GO 53559
52668: LD_INT 5
52670: DOUBLE
52671: EQUAL
52672: IFTRUE 52676
52674: GO 52702
52676: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52677: LD_ADDR_VAR 0 3
52681: PUSH
52682: LD_INT 2
52684: PUSH
52685: LD_INT 3
52687: PUSH
52688: LD_INT 4
52690: PUSH
52691: LD_INT 5
52693: PUSH
52694: EMPTY
52695: LIST
52696: LIST
52697: LIST
52698: LIST
52699: ST_TO_ADDR
52700: GO 53559
52702: LD_INT 9
52704: DOUBLE
52705: EQUAL
52706: IFTRUE 52710
52708: GO 52736
52710: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52711: LD_ADDR_VAR 0 3
52715: PUSH
52716: LD_INT 2
52718: PUSH
52719: LD_INT 3
52721: PUSH
52722: LD_INT 4
52724: PUSH
52725: LD_INT 5
52727: PUSH
52728: EMPTY
52729: LIST
52730: LIST
52731: LIST
52732: LIST
52733: ST_TO_ADDR
52734: GO 53559
52736: LD_INT 7
52738: DOUBLE
52739: EQUAL
52740: IFTRUE 52744
52742: GO 52770
52744: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52745: LD_ADDR_VAR 0 3
52749: PUSH
52750: LD_INT 2
52752: PUSH
52753: LD_INT 3
52755: PUSH
52756: LD_INT 4
52758: PUSH
52759: LD_INT 5
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: ST_TO_ADDR
52768: GO 53559
52770: LD_INT 12
52772: DOUBLE
52773: EQUAL
52774: IFTRUE 52778
52776: GO 52804
52778: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52779: LD_ADDR_VAR 0 3
52783: PUSH
52784: LD_INT 2
52786: PUSH
52787: LD_INT 3
52789: PUSH
52790: LD_INT 4
52792: PUSH
52793: LD_INT 5
52795: PUSH
52796: EMPTY
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: ST_TO_ADDR
52802: GO 53559
52804: LD_INT 13
52806: DOUBLE
52807: EQUAL
52808: IFTRUE 52812
52810: GO 52838
52812: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52813: LD_ADDR_VAR 0 3
52817: PUSH
52818: LD_INT 2
52820: PUSH
52821: LD_INT 3
52823: PUSH
52824: LD_INT 4
52826: PUSH
52827: LD_INT 5
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: LIST
52834: LIST
52835: ST_TO_ADDR
52836: GO 53559
52838: LD_INT 14
52840: DOUBLE
52841: EQUAL
52842: IFTRUE 52846
52844: GO 52864
52846: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52847: LD_ADDR_VAR 0 3
52851: PUSH
52852: LD_INT 4
52854: PUSH
52855: LD_INT 5
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: ST_TO_ADDR
52862: GO 53559
52864: LD_INT 6
52866: DOUBLE
52867: EQUAL
52868: IFTRUE 52872
52870: GO 52890
52872: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52873: LD_ADDR_VAR 0 3
52877: PUSH
52878: LD_INT 4
52880: PUSH
52881: LD_INT 5
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: ST_TO_ADDR
52888: GO 53559
52890: LD_INT 10
52892: DOUBLE
52893: EQUAL
52894: IFTRUE 52898
52896: GO 52916
52898: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52899: LD_ADDR_VAR 0 3
52903: PUSH
52904: LD_INT 4
52906: PUSH
52907: LD_INT 5
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: ST_TO_ADDR
52914: GO 53559
52916: LD_INT 22
52918: DOUBLE
52919: EQUAL
52920: IFTRUE 52924
52922: GO 52950
52924: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52925: LD_ADDR_VAR 0 3
52929: PUSH
52930: LD_INT 11
52932: PUSH
52933: LD_INT 12
52935: PUSH
52936: LD_INT 13
52938: PUSH
52939: LD_INT 14
52941: PUSH
52942: EMPTY
52943: LIST
52944: LIST
52945: LIST
52946: LIST
52947: ST_TO_ADDR
52948: GO 53559
52950: LD_INT 23
52952: DOUBLE
52953: EQUAL
52954: IFTRUE 52958
52956: GO 52984
52958: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52959: LD_ADDR_VAR 0 3
52963: PUSH
52964: LD_INT 11
52966: PUSH
52967: LD_INT 12
52969: PUSH
52970: LD_INT 13
52972: PUSH
52973: LD_INT 14
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: LIST
52980: LIST
52981: ST_TO_ADDR
52982: GO 53559
52984: LD_INT 24
52986: DOUBLE
52987: EQUAL
52988: IFTRUE 52992
52990: GO 53018
52992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52993: LD_ADDR_VAR 0 3
52997: PUSH
52998: LD_INT 11
53000: PUSH
53001: LD_INT 12
53003: PUSH
53004: LD_INT 13
53006: PUSH
53007: LD_INT 14
53009: PUSH
53010: EMPTY
53011: LIST
53012: LIST
53013: LIST
53014: LIST
53015: ST_TO_ADDR
53016: GO 53559
53018: LD_INT 30
53020: DOUBLE
53021: EQUAL
53022: IFTRUE 53026
53024: GO 53052
53026: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53027: LD_ADDR_VAR 0 3
53031: PUSH
53032: LD_INT 11
53034: PUSH
53035: LD_INT 12
53037: PUSH
53038: LD_INT 13
53040: PUSH
53041: LD_INT 14
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: LIST
53048: LIST
53049: ST_TO_ADDR
53050: GO 53559
53052: LD_INT 25
53054: DOUBLE
53055: EQUAL
53056: IFTRUE 53060
53058: GO 53078
53060: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53061: LD_ADDR_VAR 0 3
53065: PUSH
53066: LD_INT 13
53068: PUSH
53069: LD_INT 14
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: ST_TO_ADDR
53076: GO 53559
53078: LD_INT 27
53080: DOUBLE
53081: EQUAL
53082: IFTRUE 53086
53084: GO 53104
53086: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53087: LD_ADDR_VAR 0 3
53091: PUSH
53092: LD_INT 13
53094: PUSH
53095: LD_INT 14
53097: PUSH
53098: EMPTY
53099: LIST
53100: LIST
53101: ST_TO_ADDR
53102: GO 53559
53104: LD_INT 92
53106: DOUBLE
53107: EQUAL
53108: IFTRUE 53112
53110: GO 53138
53112: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53113: LD_ADDR_VAR 0 3
53117: PUSH
53118: LD_INT 11
53120: PUSH
53121: LD_INT 12
53123: PUSH
53124: LD_INT 13
53126: PUSH
53127: LD_INT 14
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: LIST
53134: LIST
53135: ST_TO_ADDR
53136: GO 53559
53138: LD_INT 28
53140: DOUBLE
53141: EQUAL
53142: IFTRUE 53146
53144: GO 53164
53146: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53147: LD_ADDR_VAR 0 3
53151: PUSH
53152: LD_INT 13
53154: PUSH
53155: LD_INT 14
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: ST_TO_ADDR
53162: GO 53559
53164: LD_INT 29
53166: DOUBLE
53167: EQUAL
53168: IFTRUE 53172
53170: GO 53190
53172: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53173: LD_ADDR_VAR 0 3
53177: PUSH
53178: LD_INT 13
53180: PUSH
53181: LD_INT 14
53183: PUSH
53184: EMPTY
53185: LIST
53186: LIST
53187: ST_TO_ADDR
53188: GO 53559
53190: LD_INT 31
53192: DOUBLE
53193: EQUAL
53194: IFTRUE 53198
53196: GO 53216
53198: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53199: LD_ADDR_VAR 0 3
53203: PUSH
53204: LD_INT 13
53206: PUSH
53207: LD_INT 14
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: ST_TO_ADDR
53214: GO 53559
53216: LD_INT 26
53218: DOUBLE
53219: EQUAL
53220: IFTRUE 53224
53222: GO 53242
53224: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53225: LD_ADDR_VAR 0 3
53229: PUSH
53230: LD_INT 13
53232: PUSH
53233: LD_INT 14
53235: PUSH
53236: EMPTY
53237: LIST
53238: LIST
53239: ST_TO_ADDR
53240: GO 53559
53242: LD_INT 42
53244: DOUBLE
53245: EQUAL
53246: IFTRUE 53250
53248: GO 53276
53250: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53251: LD_ADDR_VAR 0 3
53255: PUSH
53256: LD_INT 21
53258: PUSH
53259: LD_INT 22
53261: PUSH
53262: LD_INT 23
53264: PUSH
53265: LD_INT 24
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: LIST
53272: LIST
53273: ST_TO_ADDR
53274: GO 53559
53276: LD_INT 43
53278: DOUBLE
53279: EQUAL
53280: IFTRUE 53284
53282: GO 53310
53284: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53285: LD_ADDR_VAR 0 3
53289: PUSH
53290: LD_INT 21
53292: PUSH
53293: LD_INT 22
53295: PUSH
53296: LD_INT 23
53298: PUSH
53299: LD_INT 24
53301: PUSH
53302: EMPTY
53303: LIST
53304: LIST
53305: LIST
53306: LIST
53307: ST_TO_ADDR
53308: GO 53559
53310: LD_INT 44
53312: DOUBLE
53313: EQUAL
53314: IFTRUE 53318
53316: GO 53344
53318: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53319: LD_ADDR_VAR 0 3
53323: PUSH
53324: LD_INT 21
53326: PUSH
53327: LD_INT 22
53329: PUSH
53330: LD_INT 23
53332: PUSH
53333: LD_INT 24
53335: PUSH
53336: EMPTY
53337: LIST
53338: LIST
53339: LIST
53340: LIST
53341: ST_TO_ADDR
53342: GO 53559
53344: LD_INT 45
53346: DOUBLE
53347: EQUAL
53348: IFTRUE 53352
53350: GO 53378
53352: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53353: LD_ADDR_VAR 0 3
53357: PUSH
53358: LD_INT 21
53360: PUSH
53361: LD_INT 22
53363: PUSH
53364: LD_INT 23
53366: PUSH
53367: LD_INT 24
53369: PUSH
53370: EMPTY
53371: LIST
53372: LIST
53373: LIST
53374: LIST
53375: ST_TO_ADDR
53376: GO 53559
53378: LD_INT 49
53380: DOUBLE
53381: EQUAL
53382: IFTRUE 53386
53384: GO 53412
53386: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53387: LD_ADDR_VAR 0 3
53391: PUSH
53392: LD_INT 21
53394: PUSH
53395: LD_INT 22
53397: PUSH
53398: LD_INT 23
53400: PUSH
53401: LD_INT 24
53403: PUSH
53404: EMPTY
53405: LIST
53406: LIST
53407: LIST
53408: LIST
53409: ST_TO_ADDR
53410: GO 53559
53412: LD_INT 51
53414: DOUBLE
53415: EQUAL
53416: IFTRUE 53420
53418: GO 53446
53420: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53421: LD_ADDR_VAR 0 3
53425: PUSH
53426: LD_INT 21
53428: PUSH
53429: LD_INT 22
53431: PUSH
53432: LD_INT 23
53434: PUSH
53435: LD_INT 24
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: LIST
53442: LIST
53443: ST_TO_ADDR
53444: GO 53559
53446: LD_INT 52
53448: DOUBLE
53449: EQUAL
53450: IFTRUE 53454
53452: GO 53480
53454: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53455: LD_ADDR_VAR 0 3
53459: PUSH
53460: LD_INT 21
53462: PUSH
53463: LD_INT 22
53465: PUSH
53466: LD_INT 23
53468: PUSH
53469: LD_INT 24
53471: PUSH
53472: EMPTY
53473: LIST
53474: LIST
53475: LIST
53476: LIST
53477: ST_TO_ADDR
53478: GO 53559
53480: LD_INT 53
53482: DOUBLE
53483: EQUAL
53484: IFTRUE 53488
53486: GO 53506
53488: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: LD_INT 23
53496: PUSH
53497: LD_INT 24
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: ST_TO_ADDR
53504: GO 53559
53506: LD_INT 46
53508: DOUBLE
53509: EQUAL
53510: IFTRUE 53514
53512: GO 53532
53514: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53515: LD_ADDR_VAR 0 3
53519: PUSH
53520: LD_INT 23
53522: PUSH
53523: LD_INT 24
53525: PUSH
53526: EMPTY
53527: LIST
53528: LIST
53529: ST_TO_ADDR
53530: GO 53559
53532: LD_INT 47
53534: DOUBLE
53535: EQUAL
53536: IFTRUE 53540
53538: GO 53558
53540: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53541: LD_ADDR_VAR 0 3
53545: PUSH
53546: LD_INT 23
53548: PUSH
53549: LD_INT 24
53551: PUSH
53552: EMPTY
53553: LIST
53554: LIST
53555: ST_TO_ADDR
53556: GO 53559
53558: POP
// result := ( chassis in result ) ;
53559: LD_ADDR_VAR 0 3
53563: PUSH
53564: LD_VAR 0 1
53568: PUSH
53569: LD_VAR 0 3
53573: IN
53574: ST_TO_ADDR
// end ;
53575: LD_VAR 0 3
53579: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53580: LD_INT 0
53582: PPUSH
53583: PPUSH
53584: PPUSH
53585: PPUSH
53586: PPUSH
53587: PPUSH
53588: PPUSH
// result := array ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: LD_VAR 0 1
53598: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53599: LD_VAR 0 1
53603: NOT
53604: PUSH
53605: LD_VAR 0 2
53609: NOT
53610: OR
53611: PUSH
53612: LD_VAR 0 3
53616: NOT
53617: OR
53618: PUSH
53619: LD_VAR 0 2
53623: PUSH
53624: LD_VAR 0 1
53628: GREATER
53629: OR
53630: PUSH
53631: LD_VAR 0 3
53635: PUSH
53636: LD_VAR 0 1
53640: GREATER
53641: OR
53642: IFFALSE 53646
// exit ;
53644: GO 53942
// if direction then
53646: LD_VAR 0 4
53650: IFFALSE 53714
// begin d := 1 ;
53652: LD_ADDR_VAR 0 9
53656: PUSH
53657: LD_INT 1
53659: ST_TO_ADDR
// if i_from > i_to then
53660: LD_VAR 0 2
53664: PUSH
53665: LD_VAR 0 3
53669: GREATER
53670: IFFALSE 53696
// length := ( array - i_from ) + i_to else
53672: LD_ADDR_VAR 0 11
53676: PUSH
53677: LD_VAR 0 1
53681: PUSH
53682: LD_VAR 0 2
53686: MINUS
53687: PUSH
53688: LD_VAR 0 3
53692: PLUS
53693: ST_TO_ADDR
53694: GO 53712
// length := i_to - i_from ;
53696: LD_ADDR_VAR 0 11
53700: PUSH
53701: LD_VAR 0 3
53705: PUSH
53706: LD_VAR 0 2
53710: MINUS
53711: ST_TO_ADDR
// end else
53712: GO 53775
// begin d := - 1 ;
53714: LD_ADDR_VAR 0 9
53718: PUSH
53719: LD_INT 1
53721: NEG
53722: ST_TO_ADDR
// if i_from > i_to then
53723: LD_VAR 0 2
53727: PUSH
53728: LD_VAR 0 3
53732: GREATER
53733: IFFALSE 53753
// length := i_from - i_to else
53735: LD_ADDR_VAR 0 11
53739: PUSH
53740: LD_VAR 0 2
53744: PUSH
53745: LD_VAR 0 3
53749: MINUS
53750: ST_TO_ADDR
53751: GO 53775
// length := ( array - i_to ) + i_from ;
53753: LD_ADDR_VAR 0 11
53757: PUSH
53758: LD_VAR 0 1
53762: PUSH
53763: LD_VAR 0 3
53767: MINUS
53768: PUSH
53769: LD_VAR 0 2
53773: PLUS
53774: ST_TO_ADDR
// end ; if not length then
53775: LD_VAR 0 11
53779: NOT
53780: IFFALSE 53784
// exit ;
53782: GO 53942
// tmp := array ;
53784: LD_ADDR_VAR 0 10
53788: PUSH
53789: LD_VAR 0 1
53793: ST_TO_ADDR
// for i = 1 to length do
53794: LD_ADDR_VAR 0 6
53798: PUSH
53799: DOUBLE
53800: LD_INT 1
53802: DEC
53803: ST_TO_ADDR
53804: LD_VAR 0 11
53808: PUSH
53809: FOR_TO
53810: IFFALSE 53930
// begin for j = 1 to array do
53812: LD_ADDR_VAR 0 7
53816: PUSH
53817: DOUBLE
53818: LD_INT 1
53820: DEC
53821: ST_TO_ADDR
53822: LD_VAR 0 1
53826: PUSH
53827: FOR_TO
53828: IFFALSE 53916
// begin k := j + d ;
53830: LD_ADDR_VAR 0 8
53834: PUSH
53835: LD_VAR 0 7
53839: PUSH
53840: LD_VAR 0 9
53844: PLUS
53845: ST_TO_ADDR
// if k > array then
53846: LD_VAR 0 8
53850: PUSH
53851: LD_VAR 0 1
53855: GREATER
53856: IFFALSE 53866
// k := 1 ;
53858: LD_ADDR_VAR 0 8
53862: PUSH
53863: LD_INT 1
53865: ST_TO_ADDR
// if not k then
53866: LD_VAR 0 8
53870: NOT
53871: IFFALSE 53883
// k := array ;
53873: LD_ADDR_VAR 0 8
53877: PUSH
53878: LD_VAR 0 1
53882: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53883: LD_ADDR_VAR 0 10
53887: PUSH
53888: LD_VAR 0 10
53892: PPUSH
53893: LD_VAR 0 8
53897: PPUSH
53898: LD_VAR 0 1
53902: PUSH
53903: LD_VAR 0 7
53907: ARRAY
53908: PPUSH
53909: CALL_OW 1
53913: ST_TO_ADDR
// end ;
53914: GO 53827
53916: POP
53917: POP
// array := tmp ;
53918: LD_ADDR_VAR 0 1
53922: PUSH
53923: LD_VAR 0 10
53927: ST_TO_ADDR
// end ;
53928: GO 53809
53930: POP
53931: POP
// result := array ;
53932: LD_ADDR_VAR 0 5
53936: PUSH
53937: LD_VAR 0 1
53941: ST_TO_ADDR
// end ;
53942: LD_VAR 0 5
53946: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53947: LD_INT 0
53949: PPUSH
53950: PPUSH
// result := 0 ;
53951: LD_ADDR_VAR 0 3
53955: PUSH
53956: LD_INT 0
53958: ST_TO_ADDR
// if not array or not value in array then
53959: LD_VAR 0 1
53963: NOT
53964: PUSH
53965: LD_VAR 0 2
53969: PUSH
53970: LD_VAR 0 1
53974: IN
53975: NOT
53976: OR
53977: IFFALSE 53981
// exit ;
53979: GO 54035
// for i = 1 to array do
53981: LD_ADDR_VAR 0 4
53985: PUSH
53986: DOUBLE
53987: LD_INT 1
53989: DEC
53990: ST_TO_ADDR
53991: LD_VAR 0 1
53995: PUSH
53996: FOR_TO
53997: IFFALSE 54033
// if value = array [ i ] then
53999: LD_VAR 0 2
54003: PUSH
54004: LD_VAR 0 1
54008: PUSH
54009: LD_VAR 0 4
54013: ARRAY
54014: EQUAL
54015: IFFALSE 54031
// begin result := i ;
54017: LD_ADDR_VAR 0 3
54021: PUSH
54022: LD_VAR 0 4
54026: ST_TO_ADDR
// exit ;
54027: POP
54028: POP
54029: GO 54035
// end ;
54031: GO 53996
54033: POP
54034: POP
// end ;
54035: LD_VAR 0 3
54039: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54040: LD_INT 0
54042: PPUSH
// vc_chassis := chassis ;
54043: LD_ADDR_OWVAR 37
54047: PUSH
54048: LD_VAR 0 1
54052: ST_TO_ADDR
// vc_engine := engine ;
54053: LD_ADDR_OWVAR 39
54057: PUSH
54058: LD_VAR 0 2
54062: ST_TO_ADDR
// vc_control := control ;
54063: LD_ADDR_OWVAR 38
54067: PUSH
54068: LD_VAR 0 3
54072: ST_TO_ADDR
// vc_weapon := weapon ;
54073: LD_ADDR_OWVAR 40
54077: PUSH
54078: LD_VAR 0 4
54082: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54083: LD_ADDR_OWVAR 41
54087: PUSH
54088: LD_VAR 0 5
54092: ST_TO_ADDR
// end ;
54093: LD_VAR 0 6
54097: RET
// export function WantPlant ( unit ) ; var task ; begin
54098: LD_INT 0
54100: PPUSH
54101: PPUSH
// result := false ;
54102: LD_ADDR_VAR 0 2
54106: PUSH
54107: LD_INT 0
54109: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54110: LD_ADDR_VAR 0 3
54114: PUSH
54115: LD_VAR 0 1
54119: PPUSH
54120: CALL_OW 437
54124: ST_TO_ADDR
// if task then
54125: LD_VAR 0 3
54129: IFFALSE 54157
// if task [ 1 ] [ 1 ] = p then
54131: LD_VAR 0 3
54135: PUSH
54136: LD_INT 1
54138: ARRAY
54139: PUSH
54140: LD_INT 1
54142: ARRAY
54143: PUSH
54144: LD_STRING p
54146: EQUAL
54147: IFFALSE 54157
// result := true ;
54149: LD_ADDR_VAR 0 2
54153: PUSH
54154: LD_INT 1
54156: ST_TO_ADDR
// end ;
54157: LD_VAR 0 2
54161: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54162: LD_INT 0
54164: PPUSH
54165: PPUSH
54166: PPUSH
54167: PPUSH
// if pos < 1 then
54168: LD_VAR 0 2
54172: PUSH
54173: LD_INT 1
54175: LESS
54176: IFFALSE 54180
// exit ;
54178: GO 54483
// if pos = 1 then
54180: LD_VAR 0 2
54184: PUSH
54185: LD_INT 1
54187: EQUAL
54188: IFFALSE 54221
// result := Replace ( arr , pos [ 1 ] , value ) else
54190: LD_ADDR_VAR 0 4
54194: PUSH
54195: LD_VAR 0 1
54199: PPUSH
54200: LD_VAR 0 2
54204: PUSH
54205: LD_INT 1
54207: ARRAY
54208: PPUSH
54209: LD_VAR 0 3
54213: PPUSH
54214: CALL_OW 1
54218: ST_TO_ADDR
54219: GO 54483
// begin tmp := arr ;
54221: LD_ADDR_VAR 0 6
54225: PUSH
54226: LD_VAR 0 1
54230: ST_TO_ADDR
// s_arr := [ tmp ] ;
54231: LD_ADDR_VAR 0 7
54235: PUSH
54236: LD_VAR 0 6
54240: PUSH
54241: EMPTY
54242: LIST
54243: ST_TO_ADDR
// for i = 1 to pos - 1 do
54244: LD_ADDR_VAR 0 5
54248: PUSH
54249: DOUBLE
54250: LD_INT 1
54252: DEC
54253: ST_TO_ADDR
54254: LD_VAR 0 2
54258: PUSH
54259: LD_INT 1
54261: MINUS
54262: PUSH
54263: FOR_TO
54264: IFFALSE 54309
// begin tmp := tmp [ pos [ i ] ] ;
54266: LD_ADDR_VAR 0 6
54270: PUSH
54271: LD_VAR 0 6
54275: PUSH
54276: LD_VAR 0 2
54280: PUSH
54281: LD_VAR 0 5
54285: ARRAY
54286: ARRAY
54287: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54288: LD_ADDR_VAR 0 7
54292: PUSH
54293: LD_VAR 0 7
54297: PUSH
54298: LD_VAR 0 6
54302: PUSH
54303: EMPTY
54304: LIST
54305: ADD
54306: ST_TO_ADDR
// end ;
54307: GO 54263
54309: POP
54310: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54311: LD_ADDR_VAR 0 6
54315: PUSH
54316: LD_VAR 0 6
54320: PPUSH
54321: LD_VAR 0 2
54325: PUSH
54326: LD_VAR 0 2
54330: ARRAY
54331: PPUSH
54332: LD_VAR 0 3
54336: PPUSH
54337: CALL_OW 1
54341: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54342: LD_ADDR_VAR 0 7
54346: PUSH
54347: LD_VAR 0 7
54351: PPUSH
54352: LD_VAR 0 7
54356: PPUSH
54357: LD_VAR 0 6
54361: PPUSH
54362: CALL_OW 1
54366: ST_TO_ADDR
// for i = s_arr downto 2 do
54367: LD_ADDR_VAR 0 5
54371: PUSH
54372: DOUBLE
54373: LD_VAR 0 7
54377: INC
54378: ST_TO_ADDR
54379: LD_INT 2
54381: PUSH
54382: FOR_DOWNTO
54383: IFFALSE 54467
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54385: LD_ADDR_VAR 0 6
54389: PUSH
54390: LD_VAR 0 7
54394: PUSH
54395: LD_VAR 0 5
54399: PUSH
54400: LD_INT 1
54402: MINUS
54403: ARRAY
54404: PPUSH
54405: LD_VAR 0 2
54409: PUSH
54410: LD_VAR 0 5
54414: PUSH
54415: LD_INT 1
54417: MINUS
54418: ARRAY
54419: PPUSH
54420: LD_VAR 0 7
54424: PUSH
54425: LD_VAR 0 5
54429: ARRAY
54430: PPUSH
54431: CALL_OW 1
54435: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54436: LD_ADDR_VAR 0 7
54440: PUSH
54441: LD_VAR 0 7
54445: PPUSH
54446: LD_VAR 0 5
54450: PUSH
54451: LD_INT 1
54453: MINUS
54454: PPUSH
54455: LD_VAR 0 6
54459: PPUSH
54460: CALL_OW 1
54464: ST_TO_ADDR
// end ;
54465: GO 54382
54467: POP
54468: POP
// result := s_arr [ 1 ] ;
54469: LD_ADDR_VAR 0 4
54473: PUSH
54474: LD_VAR 0 7
54478: PUSH
54479: LD_INT 1
54481: ARRAY
54482: ST_TO_ADDR
// end ; end ;
54483: LD_VAR 0 4
54487: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54488: LD_INT 0
54490: PPUSH
54491: PPUSH
// if not list then
54492: LD_VAR 0 1
54496: NOT
54497: IFFALSE 54501
// exit ;
54499: GO 54592
// i := list [ pos1 ] ;
54501: LD_ADDR_VAR 0 5
54505: PUSH
54506: LD_VAR 0 1
54510: PUSH
54511: LD_VAR 0 2
54515: ARRAY
54516: ST_TO_ADDR
// if not i then
54517: LD_VAR 0 5
54521: NOT
54522: IFFALSE 54526
// exit ;
54524: GO 54592
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54526: LD_ADDR_VAR 0 1
54530: PUSH
54531: LD_VAR 0 1
54535: PPUSH
54536: LD_VAR 0 2
54540: PPUSH
54541: LD_VAR 0 1
54545: PUSH
54546: LD_VAR 0 3
54550: ARRAY
54551: PPUSH
54552: CALL_OW 1
54556: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54557: LD_ADDR_VAR 0 1
54561: PUSH
54562: LD_VAR 0 1
54566: PPUSH
54567: LD_VAR 0 3
54571: PPUSH
54572: LD_VAR 0 5
54576: PPUSH
54577: CALL_OW 1
54581: ST_TO_ADDR
// result := list ;
54582: LD_ADDR_VAR 0 4
54586: PUSH
54587: LD_VAR 0 1
54591: ST_TO_ADDR
// end ;
54592: LD_VAR 0 4
54596: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54597: LD_INT 0
54599: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54600: LD_ADDR_VAR 0 5
54604: PUSH
54605: LD_VAR 0 1
54609: PPUSH
54610: CALL_OW 250
54614: PPUSH
54615: LD_VAR 0 1
54619: PPUSH
54620: CALL_OW 251
54624: PPUSH
54625: LD_VAR 0 2
54629: PPUSH
54630: LD_VAR 0 3
54634: PPUSH
54635: LD_VAR 0 4
54639: PPUSH
54640: CALL 54650 0 5
54644: ST_TO_ADDR
// end ;
54645: LD_VAR 0 5
54649: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54650: LD_INT 0
54652: PPUSH
54653: PPUSH
54654: PPUSH
54655: PPUSH
// if not list then
54656: LD_VAR 0 3
54660: NOT
54661: IFFALSE 54665
// exit ;
54663: GO 55053
// result := [ ] ;
54665: LD_ADDR_VAR 0 6
54669: PUSH
54670: EMPTY
54671: ST_TO_ADDR
// for i in list do
54672: LD_ADDR_VAR 0 7
54676: PUSH
54677: LD_VAR 0 3
54681: PUSH
54682: FOR_IN
54683: IFFALSE 54885
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54685: LD_ADDR_VAR 0 9
54689: PUSH
54690: LD_VAR 0 7
54694: PPUSH
54695: LD_VAR 0 1
54699: PPUSH
54700: LD_VAR 0 2
54704: PPUSH
54705: CALL_OW 297
54709: ST_TO_ADDR
// if not result then
54710: LD_VAR 0 6
54714: NOT
54715: IFFALSE 54741
// result := [ [ i , tmp ] ] else
54717: LD_ADDR_VAR 0 6
54721: PUSH
54722: LD_VAR 0 7
54726: PUSH
54727: LD_VAR 0 9
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PUSH
54736: EMPTY
54737: LIST
54738: ST_TO_ADDR
54739: GO 54883
// begin if result [ result ] [ 2 ] < tmp then
54741: LD_VAR 0 6
54745: PUSH
54746: LD_VAR 0 6
54750: ARRAY
54751: PUSH
54752: LD_INT 2
54754: ARRAY
54755: PUSH
54756: LD_VAR 0 9
54760: LESS
54761: IFFALSE 54803
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54763: LD_ADDR_VAR 0 6
54767: PUSH
54768: LD_VAR 0 6
54772: PPUSH
54773: LD_VAR 0 6
54777: PUSH
54778: LD_INT 1
54780: PLUS
54781: PPUSH
54782: LD_VAR 0 7
54786: PUSH
54787: LD_VAR 0 9
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PPUSH
54796: CALL_OW 2
54800: ST_TO_ADDR
54801: GO 54883
// for j = 1 to result do
54803: LD_ADDR_VAR 0 8
54807: PUSH
54808: DOUBLE
54809: LD_INT 1
54811: DEC
54812: ST_TO_ADDR
54813: LD_VAR 0 6
54817: PUSH
54818: FOR_TO
54819: IFFALSE 54881
// begin if tmp < result [ j ] [ 2 ] then
54821: LD_VAR 0 9
54825: PUSH
54826: LD_VAR 0 6
54830: PUSH
54831: LD_VAR 0 8
54835: ARRAY
54836: PUSH
54837: LD_INT 2
54839: ARRAY
54840: LESS
54841: IFFALSE 54879
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54843: LD_ADDR_VAR 0 6
54847: PUSH
54848: LD_VAR 0 6
54852: PPUSH
54853: LD_VAR 0 8
54857: PPUSH
54858: LD_VAR 0 7
54862: PUSH
54863: LD_VAR 0 9
54867: PUSH
54868: EMPTY
54869: LIST
54870: LIST
54871: PPUSH
54872: CALL_OW 2
54876: ST_TO_ADDR
// break ;
54877: GO 54881
// end ; end ;
54879: GO 54818
54881: POP
54882: POP
// end ; end ;
54883: GO 54682
54885: POP
54886: POP
// if result and not asc then
54887: LD_VAR 0 6
54891: PUSH
54892: LD_VAR 0 4
54896: NOT
54897: AND
54898: IFFALSE 54973
// begin tmp := result ;
54900: LD_ADDR_VAR 0 9
54904: PUSH
54905: LD_VAR 0 6
54909: ST_TO_ADDR
// for i = tmp downto 1 do
54910: LD_ADDR_VAR 0 7
54914: PUSH
54915: DOUBLE
54916: LD_VAR 0 9
54920: INC
54921: ST_TO_ADDR
54922: LD_INT 1
54924: PUSH
54925: FOR_DOWNTO
54926: IFFALSE 54971
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54928: LD_ADDR_VAR 0 6
54932: PUSH
54933: LD_VAR 0 6
54937: PPUSH
54938: LD_VAR 0 9
54942: PUSH
54943: LD_VAR 0 7
54947: MINUS
54948: PUSH
54949: LD_INT 1
54951: PLUS
54952: PPUSH
54953: LD_VAR 0 9
54957: PUSH
54958: LD_VAR 0 7
54962: ARRAY
54963: PPUSH
54964: CALL_OW 1
54968: ST_TO_ADDR
54969: GO 54925
54971: POP
54972: POP
// end ; tmp := [ ] ;
54973: LD_ADDR_VAR 0 9
54977: PUSH
54978: EMPTY
54979: ST_TO_ADDR
// if mode then
54980: LD_VAR 0 5
54984: IFFALSE 55053
// begin for i = 1 to result do
54986: LD_ADDR_VAR 0 7
54990: PUSH
54991: DOUBLE
54992: LD_INT 1
54994: DEC
54995: ST_TO_ADDR
54996: LD_VAR 0 6
55000: PUSH
55001: FOR_TO
55002: IFFALSE 55041
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55004: LD_ADDR_VAR 0 9
55008: PUSH
55009: LD_VAR 0 9
55013: PPUSH
55014: LD_VAR 0 7
55018: PPUSH
55019: LD_VAR 0 6
55023: PUSH
55024: LD_VAR 0 7
55028: ARRAY
55029: PUSH
55030: LD_INT 1
55032: ARRAY
55033: PPUSH
55034: CALL_OW 1
55038: ST_TO_ADDR
55039: GO 55001
55041: POP
55042: POP
// result := tmp ;
55043: LD_ADDR_VAR 0 6
55047: PUSH
55048: LD_VAR 0 9
55052: ST_TO_ADDR
// end ; end ;
55053: LD_VAR 0 6
55057: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55058: LD_INT 0
55060: PPUSH
55061: PPUSH
55062: PPUSH
55063: PPUSH
55064: PPUSH
55065: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55066: LD_ADDR_VAR 0 5
55070: PUSH
55071: LD_INT 0
55073: PUSH
55074: LD_INT 0
55076: PUSH
55077: LD_INT 0
55079: PUSH
55080: EMPTY
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: LIST
55086: LIST
55087: ST_TO_ADDR
// if not x or not y then
55088: LD_VAR 0 2
55092: NOT
55093: PUSH
55094: LD_VAR 0 3
55098: NOT
55099: OR
55100: IFFALSE 55104
// exit ;
55102: GO 56754
// if not range then
55104: LD_VAR 0 4
55108: NOT
55109: IFFALSE 55119
// range := 10 ;
55111: LD_ADDR_VAR 0 4
55115: PUSH
55116: LD_INT 10
55118: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55119: LD_ADDR_VAR 0 8
55123: PUSH
55124: LD_INT 81
55126: PUSH
55127: LD_VAR 0 1
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: PUSH
55136: LD_INT 92
55138: PUSH
55139: LD_VAR 0 2
55143: PUSH
55144: LD_VAR 0 3
55148: PUSH
55149: LD_VAR 0 4
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: LIST
55158: LIST
55159: PUSH
55160: LD_INT 3
55162: PUSH
55163: LD_INT 21
55165: PUSH
55166: LD_INT 3
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: PUSH
55177: EMPTY
55178: LIST
55179: LIST
55180: LIST
55181: PPUSH
55182: CALL_OW 69
55186: ST_TO_ADDR
// if not tmp then
55187: LD_VAR 0 8
55191: NOT
55192: IFFALSE 55196
// exit ;
55194: GO 56754
// for i in tmp do
55196: LD_ADDR_VAR 0 6
55200: PUSH
55201: LD_VAR 0 8
55205: PUSH
55206: FOR_IN
55207: IFFALSE 56729
// begin points := [ 0 , 0 , 0 ] ;
55209: LD_ADDR_VAR 0 9
55213: PUSH
55214: LD_INT 0
55216: PUSH
55217: LD_INT 0
55219: PUSH
55220: LD_INT 0
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: LIST
55227: ST_TO_ADDR
// bpoints := 1 ;
55228: LD_ADDR_VAR 0 10
55232: PUSH
55233: LD_INT 1
55235: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55236: LD_VAR 0 6
55240: PPUSH
55241: CALL_OW 247
55245: PUSH
55246: LD_INT 1
55248: DOUBLE
55249: EQUAL
55250: IFTRUE 55254
55252: GO 55832
55254: POP
// begin if GetClass ( i ) = 1 then
55255: LD_VAR 0 6
55259: PPUSH
55260: CALL_OW 257
55264: PUSH
55265: LD_INT 1
55267: EQUAL
55268: IFFALSE 55289
// points := [ 10 , 5 , 3 ] ;
55270: LD_ADDR_VAR 0 9
55274: PUSH
55275: LD_INT 10
55277: PUSH
55278: LD_INT 5
55280: PUSH
55281: LD_INT 3
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: LIST
55288: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55289: LD_VAR 0 6
55293: PPUSH
55294: CALL_OW 257
55298: PUSH
55299: LD_INT 2
55301: PUSH
55302: LD_INT 3
55304: PUSH
55305: LD_INT 4
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: LIST
55312: IN
55313: IFFALSE 55334
// points := [ 3 , 2 , 1 ] ;
55315: LD_ADDR_VAR 0 9
55319: PUSH
55320: LD_INT 3
55322: PUSH
55323: LD_INT 2
55325: PUSH
55326: LD_INT 1
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: LIST
55333: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55334: LD_VAR 0 6
55338: PPUSH
55339: CALL_OW 257
55343: PUSH
55344: LD_INT 5
55346: EQUAL
55347: IFFALSE 55368
// points := [ 130 , 5 , 2 ] ;
55349: LD_ADDR_VAR 0 9
55353: PUSH
55354: LD_INT 130
55356: PUSH
55357: LD_INT 5
55359: PUSH
55360: LD_INT 2
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55368: LD_VAR 0 6
55372: PPUSH
55373: CALL_OW 257
55377: PUSH
55378: LD_INT 8
55380: EQUAL
55381: IFFALSE 55402
// points := [ 35 , 35 , 30 ] ;
55383: LD_ADDR_VAR 0 9
55387: PUSH
55388: LD_INT 35
55390: PUSH
55391: LD_INT 35
55393: PUSH
55394: LD_INT 30
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55402: LD_VAR 0 6
55406: PPUSH
55407: CALL_OW 257
55411: PUSH
55412: LD_INT 9
55414: EQUAL
55415: IFFALSE 55436
// points := [ 20 , 55 , 40 ] ;
55417: LD_ADDR_VAR 0 9
55421: PUSH
55422: LD_INT 20
55424: PUSH
55425: LD_INT 55
55427: PUSH
55428: LD_INT 40
55430: PUSH
55431: EMPTY
55432: LIST
55433: LIST
55434: LIST
55435: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55436: LD_VAR 0 6
55440: PPUSH
55441: CALL_OW 257
55445: PUSH
55446: LD_INT 12
55448: PUSH
55449: LD_INT 16
55451: PUSH
55452: EMPTY
55453: LIST
55454: LIST
55455: IN
55456: IFFALSE 55477
// points := [ 5 , 3 , 2 ] ;
55458: LD_ADDR_VAR 0 9
55462: PUSH
55463: LD_INT 5
55465: PUSH
55466: LD_INT 3
55468: PUSH
55469: LD_INT 2
55471: PUSH
55472: EMPTY
55473: LIST
55474: LIST
55475: LIST
55476: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55477: LD_VAR 0 6
55481: PPUSH
55482: CALL_OW 257
55486: PUSH
55487: LD_INT 17
55489: EQUAL
55490: IFFALSE 55511
// points := [ 100 , 50 , 75 ] ;
55492: LD_ADDR_VAR 0 9
55496: PUSH
55497: LD_INT 100
55499: PUSH
55500: LD_INT 50
55502: PUSH
55503: LD_INT 75
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: LIST
55510: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55511: LD_VAR 0 6
55515: PPUSH
55516: CALL_OW 257
55520: PUSH
55521: LD_INT 15
55523: EQUAL
55524: IFFALSE 55545
// points := [ 10 , 5 , 3 ] ;
55526: LD_ADDR_VAR 0 9
55530: PUSH
55531: LD_INT 10
55533: PUSH
55534: LD_INT 5
55536: PUSH
55537: LD_INT 3
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: LIST
55544: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55545: LD_VAR 0 6
55549: PPUSH
55550: CALL_OW 257
55554: PUSH
55555: LD_INT 14
55557: EQUAL
55558: IFFALSE 55579
// points := [ 10 , 0 , 0 ] ;
55560: LD_ADDR_VAR 0 9
55564: PUSH
55565: LD_INT 10
55567: PUSH
55568: LD_INT 0
55570: PUSH
55571: LD_INT 0
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: LIST
55578: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55579: LD_VAR 0 6
55583: PPUSH
55584: CALL_OW 257
55588: PUSH
55589: LD_INT 11
55591: EQUAL
55592: IFFALSE 55613
// points := [ 30 , 10 , 5 ] ;
55594: LD_ADDR_VAR 0 9
55598: PUSH
55599: LD_INT 30
55601: PUSH
55602: LD_INT 10
55604: PUSH
55605: LD_INT 5
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: LIST
55612: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55613: LD_VAR 0 1
55617: PPUSH
55618: LD_INT 5
55620: PPUSH
55621: CALL_OW 321
55625: PUSH
55626: LD_INT 2
55628: EQUAL
55629: IFFALSE 55646
// bpoints := bpoints * 1.8 ;
55631: LD_ADDR_VAR 0 10
55635: PUSH
55636: LD_VAR 0 10
55640: PUSH
55641: LD_REAL  1.80000000000000E+0000
55644: MUL
55645: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55646: LD_VAR 0 6
55650: PPUSH
55651: CALL_OW 257
55655: PUSH
55656: LD_INT 1
55658: PUSH
55659: LD_INT 2
55661: PUSH
55662: LD_INT 3
55664: PUSH
55665: LD_INT 4
55667: PUSH
55668: EMPTY
55669: LIST
55670: LIST
55671: LIST
55672: LIST
55673: IN
55674: PUSH
55675: LD_VAR 0 1
55679: PPUSH
55680: LD_INT 51
55682: PPUSH
55683: CALL_OW 321
55687: PUSH
55688: LD_INT 2
55690: EQUAL
55691: AND
55692: IFFALSE 55709
// bpoints := bpoints * 1.2 ;
55694: LD_ADDR_VAR 0 10
55698: PUSH
55699: LD_VAR 0 10
55703: PUSH
55704: LD_REAL  1.20000000000000E+0000
55707: MUL
55708: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55709: LD_VAR 0 6
55713: PPUSH
55714: CALL_OW 257
55718: PUSH
55719: LD_INT 5
55721: PUSH
55722: LD_INT 7
55724: PUSH
55725: LD_INT 9
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: LIST
55732: IN
55733: PUSH
55734: LD_VAR 0 1
55738: PPUSH
55739: LD_INT 52
55741: PPUSH
55742: CALL_OW 321
55746: PUSH
55747: LD_INT 2
55749: EQUAL
55750: AND
55751: IFFALSE 55768
// bpoints := bpoints * 1.5 ;
55753: LD_ADDR_VAR 0 10
55757: PUSH
55758: LD_VAR 0 10
55762: PUSH
55763: LD_REAL  1.50000000000000E+0000
55766: MUL
55767: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55768: LD_VAR 0 1
55772: PPUSH
55773: LD_INT 66
55775: PPUSH
55776: CALL_OW 321
55780: PUSH
55781: LD_INT 2
55783: EQUAL
55784: IFFALSE 55801
// bpoints := bpoints * 1.1 ;
55786: LD_ADDR_VAR 0 10
55790: PUSH
55791: LD_VAR 0 10
55795: PUSH
55796: LD_REAL  1.10000000000000E+0000
55799: MUL
55800: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55801: LD_ADDR_VAR 0 10
55805: PUSH
55806: LD_VAR 0 10
55810: PUSH
55811: LD_VAR 0 6
55815: PPUSH
55816: LD_INT 1
55818: PPUSH
55819: CALL_OW 259
55823: PUSH
55824: LD_REAL  1.15000000000000E+0000
55827: MUL
55828: MUL
55829: ST_TO_ADDR
// end ; unit_vehicle :
55830: GO 56658
55832: LD_INT 2
55834: DOUBLE
55835: EQUAL
55836: IFTRUE 55840
55838: GO 56646
55840: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55841: LD_VAR 0 6
55845: PPUSH
55846: CALL_OW 264
55850: PUSH
55851: LD_INT 2
55853: PUSH
55854: LD_INT 42
55856: PUSH
55857: LD_INT 24
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: LIST
55864: IN
55865: IFFALSE 55886
// points := [ 25 , 5 , 3 ] ;
55867: LD_ADDR_VAR 0 9
55871: PUSH
55872: LD_INT 25
55874: PUSH
55875: LD_INT 5
55877: PUSH
55878: LD_INT 3
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55886: LD_VAR 0 6
55890: PPUSH
55891: CALL_OW 264
55895: PUSH
55896: LD_INT 4
55898: PUSH
55899: LD_INT 43
55901: PUSH
55902: LD_INT 25
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: LIST
55909: IN
55910: IFFALSE 55931
// points := [ 40 , 15 , 5 ] ;
55912: LD_ADDR_VAR 0 9
55916: PUSH
55917: LD_INT 40
55919: PUSH
55920: LD_INT 15
55922: PUSH
55923: LD_INT 5
55925: PUSH
55926: EMPTY
55927: LIST
55928: LIST
55929: LIST
55930: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55931: LD_VAR 0 6
55935: PPUSH
55936: CALL_OW 264
55940: PUSH
55941: LD_INT 3
55943: PUSH
55944: LD_INT 23
55946: PUSH
55947: EMPTY
55948: LIST
55949: LIST
55950: IN
55951: IFFALSE 55972
// points := [ 7 , 25 , 8 ] ;
55953: LD_ADDR_VAR 0 9
55957: PUSH
55958: LD_INT 7
55960: PUSH
55961: LD_INT 25
55963: PUSH
55964: LD_INT 8
55966: PUSH
55967: EMPTY
55968: LIST
55969: LIST
55970: LIST
55971: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55972: LD_VAR 0 6
55976: PPUSH
55977: CALL_OW 264
55981: PUSH
55982: LD_INT 5
55984: PUSH
55985: LD_INT 27
55987: PUSH
55988: LD_INT 44
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: LIST
55995: IN
55996: IFFALSE 56017
// points := [ 14 , 50 , 16 ] ;
55998: LD_ADDR_VAR 0 9
56002: PUSH
56003: LD_INT 14
56005: PUSH
56006: LD_INT 50
56008: PUSH
56009: LD_INT 16
56011: PUSH
56012: EMPTY
56013: LIST
56014: LIST
56015: LIST
56016: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56017: LD_VAR 0 6
56021: PPUSH
56022: CALL_OW 264
56026: PUSH
56027: LD_INT 6
56029: PUSH
56030: LD_INT 46
56032: PUSH
56033: EMPTY
56034: LIST
56035: LIST
56036: IN
56037: IFFALSE 56058
// points := [ 32 , 120 , 70 ] ;
56039: LD_ADDR_VAR 0 9
56043: PUSH
56044: LD_INT 32
56046: PUSH
56047: LD_INT 120
56049: PUSH
56050: LD_INT 70
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: LIST
56057: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56058: LD_VAR 0 6
56062: PPUSH
56063: CALL_OW 264
56067: PUSH
56068: LD_INT 7
56070: PUSH
56071: LD_INT 28
56073: PUSH
56074: LD_INT 45
56076: PUSH
56077: LD_INT 92
56079: PUSH
56080: EMPTY
56081: LIST
56082: LIST
56083: LIST
56084: LIST
56085: IN
56086: IFFALSE 56107
// points := [ 35 , 20 , 45 ] ;
56088: LD_ADDR_VAR 0 9
56092: PUSH
56093: LD_INT 35
56095: PUSH
56096: LD_INT 20
56098: PUSH
56099: LD_INT 45
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: LIST
56106: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56107: LD_VAR 0 6
56111: PPUSH
56112: CALL_OW 264
56116: PUSH
56117: LD_INT 47
56119: PUSH
56120: EMPTY
56121: LIST
56122: IN
56123: IFFALSE 56144
// points := [ 67 , 45 , 75 ] ;
56125: LD_ADDR_VAR 0 9
56129: PUSH
56130: LD_INT 67
56132: PUSH
56133: LD_INT 45
56135: PUSH
56136: LD_INT 75
56138: PUSH
56139: EMPTY
56140: LIST
56141: LIST
56142: LIST
56143: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56144: LD_VAR 0 6
56148: PPUSH
56149: CALL_OW 264
56153: PUSH
56154: LD_INT 26
56156: PUSH
56157: EMPTY
56158: LIST
56159: IN
56160: IFFALSE 56181
// points := [ 120 , 30 , 80 ] ;
56162: LD_ADDR_VAR 0 9
56166: PUSH
56167: LD_INT 120
56169: PUSH
56170: LD_INT 30
56172: PUSH
56173: LD_INT 80
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: LIST
56180: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56181: LD_VAR 0 6
56185: PPUSH
56186: CALL_OW 264
56190: PUSH
56191: LD_INT 22
56193: PUSH
56194: EMPTY
56195: LIST
56196: IN
56197: IFFALSE 56218
// points := [ 40 , 1 , 1 ] ;
56199: LD_ADDR_VAR 0 9
56203: PUSH
56204: LD_INT 40
56206: PUSH
56207: LD_INT 1
56209: PUSH
56210: LD_INT 1
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56218: LD_VAR 0 6
56222: PPUSH
56223: CALL_OW 264
56227: PUSH
56228: LD_INT 29
56230: PUSH
56231: EMPTY
56232: LIST
56233: IN
56234: IFFALSE 56255
// points := [ 70 , 200 , 400 ] ;
56236: LD_ADDR_VAR 0 9
56240: PUSH
56241: LD_INT 70
56243: PUSH
56244: LD_INT 200
56246: PUSH
56247: LD_INT 400
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: LIST
56254: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56255: LD_VAR 0 6
56259: PPUSH
56260: CALL_OW 264
56264: PUSH
56265: LD_INT 14
56267: PUSH
56268: LD_INT 53
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: IN
56275: IFFALSE 56296
// points := [ 40 , 10 , 20 ] ;
56277: LD_ADDR_VAR 0 9
56281: PUSH
56282: LD_INT 40
56284: PUSH
56285: LD_INT 10
56287: PUSH
56288: LD_INT 20
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: LIST
56295: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56296: LD_VAR 0 6
56300: PPUSH
56301: CALL_OW 264
56305: PUSH
56306: LD_INT 9
56308: PUSH
56309: EMPTY
56310: LIST
56311: IN
56312: IFFALSE 56333
// points := [ 5 , 70 , 20 ] ;
56314: LD_ADDR_VAR 0 9
56318: PUSH
56319: LD_INT 5
56321: PUSH
56322: LD_INT 70
56324: PUSH
56325: LD_INT 20
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: LIST
56332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56333: LD_VAR 0 6
56337: PPUSH
56338: CALL_OW 264
56342: PUSH
56343: LD_INT 10
56345: PUSH
56346: EMPTY
56347: LIST
56348: IN
56349: IFFALSE 56370
// points := [ 35 , 110 , 70 ] ;
56351: LD_ADDR_VAR 0 9
56355: PUSH
56356: LD_INT 35
56358: PUSH
56359: LD_INT 110
56361: PUSH
56362: LD_INT 70
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: LIST
56369: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56370: LD_VAR 0 6
56374: PPUSH
56375: CALL_OW 265
56379: PUSH
56380: LD_INT 25
56382: EQUAL
56383: IFFALSE 56404
// points := [ 80 , 65 , 100 ] ;
56385: LD_ADDR_VAR 0 9
56389: PUSH
56390: LD_INT 80
56392: PUSH
56393: LD_INT 65
56395: PUSH
56396: LD_INT 100
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: LIST
56403: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56404: LD_VAR 0 6
56408: PPUSH
56409: CALL_OW 263
56413: PUSH
56414: LD_INT 1
56416: EQUAL
56417: IFFALSE 56452
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56419: LD_ADDR_VAR 0 10
56423: PUSH
56424: LD_VAR 0 10
56428: PUSH
56429: LD_VAR 0 6
56433: PPUSH
56434: CALL_OW 311
56438: PPUSH
56439: LD_INT 3
56441: PPUSH
56442: CALL_OW 259
56446: PUSH
56447: LD_INT 4
56449: MUL
56450: MUL
56451: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56452: LD_VAR 0 6
56456: PPUSH
56457: CALL_OW 263
56461: PUSH
56462: LD_INT 2
56464: EQUAL
56465: IFFALSE 56516
// begin j := IsControledBy ( i ) ;
56467: LD_ADDR_VAR 0 7
56471: PUSH
56472: LD_VAR 0 6
56476: PPUSH
56477: CALL_OW 312
56481: ST_TO_ADDR
// if j then
56482: LD_VAR 0 7
56486: IFFALSE 56516
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56488: LD_ADDR_VAR 0 10
56492: PUSH
56493: LD_VAR 0 10
56497: PUSH
56498: LD_VAR 0 7
56502: PPUSH
56503: LD_INT 3
56505: PPUSH
56506: CALL_OW 259
56510: PUSH
56511: LD_INT 3
56513: MUL
56514: MUL
56515: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56516: LD_VAR 0 6
56520: PPUSH
56521: CALL_OW 264
56525: PUSH
56526: LD_INT 5
56528: PUSH
56529: LD_INT 6
56531: PUSH
56532: LD_INT 46
56534: PUSH
56535: LD_INT 44
56537: PUSH
56538: LD_INT 47
56540: PUSH
56541: LD_INT 45
56543: PUSH
56544: LD_INT 28
56546: PUSH
56547: LD_INT 7
56549: PUSH
56550: LD_INT 27
56552: PUSH
56553: LD_INT 29
56555: PUSH
56556: EMPTY
56557: LIST
56558: LIST
56559: LIST
56560: LIST
56561: LIST
56562: LIST
56563: LIST
56564: LIST
56565: LIST
56566: LIST
56567: IN
56568: PUSH
56569: LD_VAR 0 1
56573: PPUSH
56574: LD_INT 52
56576: PPUSH
56577: CALL_OW 321
56581: PUSH
56582: LD_INT 2
56584: EQUAL
56585: AND
56586: IFFALSE 56603
// bpoints := bpoints * 1.2 ;
56588: LD_ADDR_VAR 0 10
56592: PUSH
56593: LD_VAR 0 10
56597: PUSH
56598: LD_REAL  1.20000000000000E+0000
56601: MUL
56602: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56603: LD_VAR 0 6
56607: PPUSH
56608: CALL_OW 264
56612: PUSH
56613: LD_INT 6
56615: PUSH
56616: LD_INT 46
56618: PUSH
56619: LD_INT 47
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: LIST
56626: IN
56627: IFFALSE 56644
// bpoints := bpoints * 1.2 ;
56629: LD_ADDR_VAR 0 10
56633: PUSH
56634: LD_VAR 0 10
56638: PUSH
56639: LD_REAL  1.20000000000000E+0000
56642: MUL
56643: ST_TO_ADDR
// end ; unit_building :
56644: GO 56658
56646: LD_INT 3
56648: DOUBLE
56649: EQUAL
56650: IFTRUE 56654
56652: GO 56657
56654: POP
// ; end ;
56655: GO 56658
56657: POP
// for j = 1 to 3 do
56658: LD_ADDR_VAR 0 7
56662: PUSH
56663: DOUBLE
56664: LD_INT 1
56666: DEC
56667: ST_TO_ADDR
56668: LD_INT 3
56670: PUSH
56671: FOR_TO
56672: IFFALSE 56725
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56674: LD_ADDR_VAR 0 5
56678: PUSH
56679: LD_VAR 0 5
56683: PPUSH
56684: LD_VAR 0 7
56688: PPUSH
56689: LD_VAR 0 5
56693: PUSH
56694: LD_VAR 0 7
56698: ARRAY
56699: PUSH
56700: LD_VAR 0 9
56704: PUSH
56705: LD_VAR 0 7
56709: ARRAY
56710: PUSH
56711: LD_VAR 0 10
56715: MUL
56716: PLUS
56717: PPUSH
56718: CALL_OW 1
56722: ST_TO_ADDR
56723: GO 56671
56725: POP
56726: POP
// end ;
56727: GO 55206
56729: POP
56730: POP
// result := Replace ( result , 4 , tmp ) ;
56731: LD_ADDR_VAR 0 5
56735: PUSH
56736: LD_VAR 0 5
56740: PPUSH
56741: LD_INT 4
56743: PPUSH
56744: LD_VAR 0 8
56748: PPUSH
56749: CALL_OW 1
56753: ST_TO_ADDR
// end ;
56754: LD_VAR 0 5
56758: RET
// export function DangerAtRange ( unit , range ) ; begin
56759: LD_INT 0
56761: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56762: LD_ADDR_VAR 0 3
56766: PUSH
56767: LD_VAR 0 1
56771: PPUSH
56772: CALL_OW 255
56776: PPUSH
56777: LD_VAR 0 1
56781: PPUSH
56782: CALL_OW 250
56786: PPUSH
56787: LD_VAR 0 1
56791: PPUSH
56792: CALL_OW 251
56796: PPUSH
56797: LD_VAR 0 2
56801: PPUSH
56802: CALL 55058 0 4
56806: ST_TO_ADDR
// end ;
56807: LD_VAR 0 3
56811: RET
// export function DangerInArea ( side , area ) ; begin
56812: LD_INT 0
56814: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56815: LD_ADDR_VAR 0 3
56819: PUSH
56820: LD_VAR 0 2
56824: PPUSH
56825: LD_INT 81
56827: PUSH
56828: LD_VAR 0 1
56832: PUSH
56833: EMPTY
56834: LIST
56835: LIST
56836: PPUSH
56837: CALL_OW 70
56841: ST_TO_ADDR
// end ;
56842: LD_VAR 0 3
56846: RET
// export function IsExtension ( b ) ; begin
56847: LD_INT 0
56849: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56850: LD_ADDR_VAR 0 2
56854: PUSH
56855: LD_VAR 0 1
56859: PUSH
56860: LD_INT 23
56862: PUSH
56863: LD_INT 20
56865: PUSH
56866: LD_INT 22
56868: PUSH
56869: LD_INT 17
56871: PUSH
56872: LD_INT 24
56874: PUSH
56875: LD_INT 21
56877: PUSH
56878: LD_INT 19
56880: PUSH
56881: LD_INT 16
56883: PUSH
56884: LD_INT 25
56886: PUSH
56887: LD_INT 18
56889: PUSH
56890: EMPTY
56891: LIST
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: IN
56902: ST_TO_ADDR
// end ;
56903: LD_VAR 0 2
56907: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56908: LD_INT 0
56910: PPUSH
56911: PPUSH
56912: PPUSH
// result := [ ] ;
56913: LD_ADDR_VAR 0 4
56917: PUSH
56918: EMPTY
56919: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56920: LD_ADDR_VAR 0 5
56924: PUSH
56925: LD_VAR 0 2
56929: PPUSH
56930: LD_INT 21
56932: PUSH
56933: LD_INT 3
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: PPUSH
56940: CALL_OW 70
56944: ST_TO_ADDR
// if not tmp then
56945: LD_VAR 0 5
56949: NOT
56950: IFFALSE 56954
// exit ;
56952: GO 57018
// if checkLink then
56954: LD_VAR 0 3
56958: IFFALSE 57008
// begin for i in tmp do
56960: LD_ADDR_VAR 0 6
56964: PUSH
56965: LD_VAR 0 5
56969: PUSH
56970: FOR_IN
56971: IFFALSE 57006
// if GetBase ( i ) <> base then
56973: LD_VAR 0 6
56977: PPUSH
56978: CALL_OW 274
56982: PUSH
56983: LD_VAR 0 1
56987: NONEQUAL
56988: IFFALSE 57004
// ComLinkToBase ( base , i ) ;
56990: LD_VAR 0 1
56994: PPUSH
56995: LD_VAR 0 6
56999: PPUSH
57000: CALL_OW 169
57004: GO 56970
57006: POP
57007: POP
// end ; result := tmp ;
57008: LD_ADDR_VAR 0 4
57012: PUSH
57013: LD_VAR 0 5
57017: ST_TO_ADDR
// end ;
57018: LD_VAR 0 4
57022: RET
// export function ComComplete ( units , b ) ; var i ; begin
57023: LD_INT 0
57025: PPUSH
57026: PPUSH
// if not units then
57027: LD_VAR 0 1
57031: NOT
57032: IFFALSE 57036
// exit ;
57034: GO 57126
// for i in units do
57036: LD_ADDR_VAR 0 4
57040: PUSH
57041: LD_VAR 0 1
57045: PUSH
57046: FOR_IN
57047: IFFALSE 57124
// if BuildingStatus ( b ) = bs_build then
57049: LD_VAR 0 2
57053: PPUSH
57054: CALL_OW 461
57058: PUSH
57059: LD_INT 1
57061: EQUAL
57062: IFFALSE 57122
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57064: LD_VAR 0 4
57068: PPUSH
57069: LD_STRING h
57071: PUSH
57072: LD_VAR 0 2
57076: PPUSH
57077: CALL_OW 250
57081: PUSH
57082: LD_VAR 0 2
57086: PPUSH
57087: CALL_OW 251
57091: PUSH
57092: LD_VAR 0 2
57096: PUSH
57097: LD_INT 0
57099: PUSH
57100: LD_INT 0
57102: PUSH
57103: LD_INT 0
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: LIST
57110: LIST
57111: LIST
57112: LIST
57113: LIST
57114: PUSH
57115: EMPTY
57116: LIST
57117: PPUSH
57118: CALL_OW 446
57122: GO 57046
57124: POP
57125: POP
// end ;
57126: LD_VAR 0 3
57130: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57131: LD_INT 0
57133: PPUSH
57134: PPUSH
57135: PPUSH
57136: PPUSH
57137: PPUSH
57138: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57139: LD_VAR 0 1
57143: NOT
57144: PUSH
57145: LD_VAR 0 1
57149: PPUSH
57150: CALL_OW 263
57154: PUSH
57155: LD_INT 2
57157: NONEQUAL
57158: OR
57159: IFFALSE 57163
// exit ;
57161: GO 57479
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57163: LD_ADDR_VAR 0 6
57167: PUSH
57168: LD_INT 22
57170: PUSH
57171: LD_VAR 0 1
57175: PPUSH
57176: CALL_OW 255
57180: PUSH
57181: EMPTY
57182: LIST
57183: LIST
57184: PUSH
57185: LD_INT 2
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 36
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: LD_INT 34
57200: PUSH
57201: LD_INT 31
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: LIST
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: PPUSH
57217: CALL_OW 69
57221: ST_TO_ADDR
// if not tmp then
57222: LD_VAR 0 6
57226: NOT
57227: IFFALSE 57231
// exit ;
57229: GO 57479
// result := [ ] ;
57231: LD_ADDR_VAR 0 2
57235: PUSH
57236: EMPTY
57237: ST_TO_ADDR
// for i in tmp do
57238: LD_ADDR_VAR 0 3
57242: PUSH
57243: LD_VAR 0 6
57247: PUSH
57248: FOR_IN
57249: IFFALSE 57320
// begin t := UnitsInside ( i ) ;
57251: LD_ADDR_VAR 0 4
57255: PUSH
57256: LD_VAR 0 3
57260: PPUSH
57261: CALL_OW 313
57265: ST_TO_ADDR
// if t then
57266: LD_VAR 0 4
57270: IFFALSE 57318
// for j in t do
57272: LD_ADDR_VAR 0 7
57276: PUSH
57277: LD_VAR 0 4
57281: PUSH
57282: FOR_IN
57283: IFFALSE 57316
// result := Replace ( result , result + 1 , j ) ;
57285: LD_ADDR_VAR 0 2
57289: PUSH
57290: LD_VAR 0 2
57294: PPUSH
57295: LD_VAR 0 2
57299: PUSH
57300: LD_INT 1
57302: PLUS
57303: PPUSH
57304: LD_VAR 0 7
57308: PPUSH
57309: CALL_OW 1
57313: ST_TO_ADDR
57314: GO 57282
57316: POP
57317: POP
// end ;
57318: GO 57248
57320: POP
57321: POP
// if not result then
57322: LD_VAR 0 2
57326: NOT
57327: IFFALSE 57331
// exit ;
57329: GO 57479
// mech := result [ 1 ] ;
57331: LD_ADDR_VAR 0 5
57335: PUSH
57336: LD_VAR 0 2
57340: PUSH
57341: LD_INT 1
57343: ARRAY
57344: ST_TO_ADDR
// if result > 1 then
57345: LD_VAR 0 2
57349: PUSH
57350: LD_INT 1
57352: GREATER
57353: IFFALSE 57465
// begin for i = 2 to result do
57355: LD_ADDR_VAR 0 3
57359: PUSH
57360: DOUBLE
57361: LD_INT 2
57363: DEC
57364: ST_TO_ADDR
57365: LD_VAR 0 2
57369: PUSH
57370: FOR_TO
57371: IFFALSE 57463
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57373: LD_ADDR_VAR 0 4
57377: PUSH
57378: LD_VAR 0 2
57382: PUSH
57383: LD_VAR 0 3
57387: ARRAY
57388: PPUSH
57389: LD_INT 3
57391: PPUSH
57392: CALL_OW 259
57396: PUSH
57397: LD_VAR 0 2
57401: PUSH
57402: LD_VAR 0 3
57406: ARRAY
57407: PPUSH
57408: CALL_OW 432
57412: MINUS
57413: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57414: LD_VAR 0 4
57418: PUSH
57419: LD_VAR 0 5
57423: PPUSH
57424: LD_INT 3
57426: PPUSH
57427: CALL_OW 259
57431: PUSH
57432: LD_VAR 0 5
57436: PPUSH
57437: CALL_OW 432
57441: MINUS
57442: GREATEREQUAL
57443: IFFALSE 57461
// mech := result [ i ] ;
57445: LD_ADDR_VAR 0 5
57449: PUSH
57450: LD_VAR 0 2
57454: PUSH
57455: LD_VAR 0 3
57459: ARRAY
57460: ST_TO_ADDR
// end ;
57461: GO 57370
57463: POP
57464: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57465: LD_VAR 0 1
57469: PPUSH
57470: LD_VAR 0 5
57474: PPUSH
57475: CALL_OW 135
// end ;
57479: LD_VAR 0 2
57483: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57484: LD_INT 0
57486: PPUSH
57487: PPUSH
57488: PPUSH
57489: PPUSH
57490: PPUSH
57491: PPUSH
57492: PPUSH
57493: PPUSH
57494: PPUSH
57495: PPUSH
57496: PPUSH
57497: PPUSH
57498: PPUSH
// result := [ ] ;
57499: LD_ADDR_VAR 0 7
57503: PUSH
57504: EMPTY
57505: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57506: LD_VAR 0 1
57510: PPUSH
57511: CALL_OW 266
57515: PUSH
57516: LD_INT 0
57518: PUSH
57519: LD_INT 1
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: IN
57526: NOT
57527: IFFALSE 57531
// exit ;
57529: GO 59165
// if name then
57531: LD_VAR 0 3
57535: IFFALSE 57551
// SetBName ( base_dep , name ) ;
57537: LD_VAR 0 1
57541: PPUSH
57542: LD_VAR 0 3
57546: PPUSH
57547: CALL_OW 500
// base := GetBase ( base_dep ) ;
57551: LD_ADDR_VAR 0 15
57555: PUSH
57556: LD_VAR 0 1
57560: PPUSH
57561: CALL_OW 274
57565: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57566: LD_ADDR_VAR 0 16
57570: PUSH
57571: LD_VAR 0 1
57575: PPUSH
57576: CALL_OW 255
57580: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57581: LD_ADDR_VAR 0 17
57585: PUSH
57586: LD_VAR 0 1
57590: PPUSH
57591: CALL_OW 248
57595: ST_TO_ADDR
// if sources then
57596: LD_VAR 0 5
57600: IFFALSE 57647
// for i = 1 to 3 do
57602: LD_ADDR_VAR 0 8
57606: PUSH
57607: DOUBLE
57608: LD_INT 1
57610: DEC
57611: ST_TO_ADDR
57612: LD_INT 3
57614: PUSH
57615: FOR_TO
57616: IFFALSE 57645
// AddResourceType ( base , i , sources [ i ] ) ;
57618: LD_VAR 0 15
57622: PPUSH
57623: LD_VAR 0 8
57627: PPUSH
57628: LD_VAR 0 5
57632: PUSH
57633: LD_VAR 0 8
57637: ARRAY
57638: PPUSH
57639: CALL_OW 276
57643: GO 57615
57645: POP
57646: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57647: LD_ADDR_VAR 0 18
57651: PUSH
57652: LD_VAR 0 15
57656: PPUSH
57657: LD_VAR 0 2
57661: PPUSH
57662: LD_INT 1
57664: PPUSH
57665: CALL 56908 0 3
57669: ST_TO_ADDR
// InitHc ;
57670: CALL_OW 19
// InitUc ;
57674: CALL_OW 18
// uc_side := side ;
57678: LD_ADDR_OWVAR 20
57682: PUSH
57683: LD_VAR 0 16
57687: ST_TO_ADDR
// uc_nation := nation ;
57688: LD_ADDR_OWVAR 21
57692: PUSH
57693: LD_VAR 0 17
57697: ST_TO_ADDR
// if buildings then
57698: LD_VAR 0 18
57702: IFFALSE 59024
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57704: LD_ADDR_VAR 0 19
57708: PUSH
57709: LD_VAR 0 18
57713: PPUSH
57714: LD_INT 2
57716: PUSH
57717: LD_INT 30
57719: PUSH
57720: LD_INT 29
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: PUSH
57727: LD_INT 30
57729: PUSH
57730: LD_INT 30
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: LIST
57741: PPUSH
57742: CALL_OW 72
57746: ST_TO_ADDR
// if tmp then
57747: LD_VAR 0 19
57751: IFFALSE 57799
// for i in tmp do
57753: LD_ADDR_VAR 0 8
57757: PUSH
57758: LD_VAR 0 19
57762: PUSH
57763: FOR_IN
57764: IFFALSE 57797
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57766: LD_VAR 0 8
57770: PPUSH
57771: CALL_OW 250
57775: PPUSH
57776: LD_VAR 0 8
57780: PPUSH
57781: CALL_OW 251
57785: PPUSH
57786: LD_VAR 0 16
57790: PPUSH
57791: CALL_OW 441
57795: GO 57763
57797: POP
57798: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57799: LD_VAR 0 18
57803: PPUSH
57804: LD_INT 2
57806: PUSH
57807: LD_INT 30
57809: PUSH
57810: LD_INT 32
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: PUSH
57817: LD_INT 30
57819: PUSH
57820: LD_INT 33
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: LIST
57831: PPUSH
57832: CALL_OW 72
57836: IFFALSE 57924
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57838: LD_ADDR_VAR 0 8
57842: PUSH
57843: LD_VAR 0 18
57847: PPUSH
57848: LD_INT 2
57850: PUSH
57851: LD_INT 30
57853: PUSH
57854: LD_INT 32
57856: PUSH
57857: EMPTY
57858: LIST
57859: LIST
57860: PUSH
57861: LD_INT 30
57863: PUSH
57864: LD_INT 33
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: LIST
57875: PPUSH
57876: CALL_OW 72
57880: PUSH
57881: FOR_IN
57882: IFFALSE 57922
// begin if not GetBWeapon ( i ) then
57884: LD_VAR 0 8
57888: PPUSH
57889: CALL_OW 269
57893: NOT
57894: IFFALSE 57920
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57896: LD_VAR 0 8
57900: PPUSH
57901: LD_VAR 0 8
57905: PPUSH
57906: LD_VAR 0 2
57910: PPUSH
57911: CALL 59170 0 2
57915: PPUSH
57916: CALL_OW 431
// end ;
57920: GO 57881
57922: POP
57923: POP
// end ; for i = 1 to personel do
57924: LD_ADDR_VAR 0 8
57928: PUSH
57929: DOUBLE
57930: LD_INT 1
57932: DEC
57933: ST_TO_ADDR
57934: LD_VAR 0 6
57938: PUSH
57939: FOR_TO
57940: IFFALSE 59004
// begin if i > 4 then
57942: LD_VAR 0 8
57946: PUSH
57947: LD_INT 4
57949: GREATER
57950: IFFALSE 57954
// break ;
57952: GO 59004
// case i of 1 :
57954: LD_VAR 0 8
57958: PUSH
57959: LD_INT 1
57961: DOUBLE
57962: EQUAL
57963: IFTRUE 57967
57965: GO 58047
57967: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57968: LD_ADDR_VAR 0 12
57972: PUSH
57973: LD_VAR 0 18
57977: PPUSH
57978: LD_INT 22
57980: PUSH
57981: LD_VAR 0 16
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: PUSH
57990: LD_INT 58
57992: PUSH
57993: EMPTY
57994: LIST
57995: PUSH
57996: LD_INT 2
57998: PUSH
57999: LD_INT 30
58001: PUSH
58002: LD_INT 32
58004: PUSH
58005: EMPTY
58006: LIST
58007: LIST
58008: PUSH
58009: LD_INT 30
58011: PUSH
58012: LD_INT 4
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: LD_INT 30
58021: PUSH
58022: LD_INT 5
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: LIST
58033: LIST
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: LIST
58039: PPUSH
58040: CALL_OW 72
58044: ST_TO_ADDR
58045: GO 58269
58047: LD_INT 2
58049: DOUBLE
58050: EQUAL
58051: IFTRUE 58055
58053: GO 58117
58055: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58056: LD_ADDR_VAR 0 12
58060: PUSH
58061: LD_VAR 0 18
58065: PPUSH
58066: LD_INT 22
58068: PUSH
58069: LD_VAR 0 16
58073: PUSH
58074: EMPTY
58075: LIST
58076: LIST
58077: PUSH
58078: LD_INT 2
58080: PUSH
58081: LD_INT 30
58083: PUSH
58084: LD_INT 0
58086: PUSH
58087: EMPTY
58088: LIST
58089: LIST
58090: PUSH
58091: LD_INT 30
58093: PUSH
58094: LD_INT 1
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: PUSH
58101: EMPTY
58102: LIST
58103: LIST
58104: LIST
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: PPUSH
58110: CALL_OW 72
58114: ST_TO_ADDR
58115: GO 58269
58117: LD_INT 3
58119: DOUBLE
58120: EQUAL
58121: IFTRUE 58125
58123: GO 58187
58125: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58126: LD_ADDR_VAR 0 12
58130: PUSH
58131: LD_VAR 0 18
58135: PPUSH
58136: LD_INT 22
58138: PUSH
58139: LD_VAR 0 16
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PUSH
58148: LD_INT 2
58150: PUSH
58151: LD_INT 30
58153: PUSH
58154: LD_INT 2
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: PUSH
58161: LD_INT 30
58163: PUSH
58164: LD_INT 3
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: LIST
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: PPUSH
58180: CALL_OW 72
58184: ST_TO_ADDR
58185: GO 58269
58187: LD_INT 4
58189: DOUBLE
58190: EQUAL
58191: IFTRUE 58195
58193: GO 58268
58195: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58196: LD_ADDR_VAR 0 12
58200: PUSH
58201: LD_VAR 0 18
58205: PPUSH
58206: LD_INT 22
58208: PUSH
58209: LD_VAR 0 16
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: PUSH
58218: LD_INT 2
58220: PUSH
58221: LD_INT 30
58223: PUSH
58224: LD_INT 6
58226: PUSH
58227: EMPTY
58228: LIST
58229: LIST
58230: PUSH
58231: LD_INT 30
58233: PUSH
58234: LD_INT 7
58236: PUSH
58237: EMPTY
58238: LIST
58239: LIST
58240: PUSH
58241: LD_INT 30
58243: PUSH
58244: LD_INT 8
58246: PUSH
58247: EMPTY
58248: LIST
58249: LIST
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: LIST
58255: LIST
58256: PUSH
58257: EMPTY
58258: LIST
58259: LIST
58260: PPUSH
58261: CALL_OW 72
58265: ST_TO_ADDR
58266: GO 58269
58268: POP
// if i = 1 then
58269: LD_VAR 0 8
58273: PUSH
58274: LD_INT 1
58276: EQUAL
58277: IFFALSE 58388
// begin tmp := [ ] ;
58279: LD_ADDR_VAR 0 19
58283: PUSH
58284: EMPTY
58285: ST_TO_ADDR
// for j in f do
58286: LD_ADDR_VAR 0 9
58290: PUSH
58291: LD_VAR 0 12
58295: PUSH
58296: FOR_IN
58297: IFFALSE 58370
// if GetBType ( j ) = b_bunker then
58299: LD_VAR 0 9
58303: PPUSH
58304: CALL_OW 266
58308: PUSH
58309: LD_INT 32
58311: EQUAL
58312: IFFALSE 58339
// tmp := Insert ( tmp , 1 , j ) else
58314: LD_ADDR_VAR 0 19
58318: PUSH
58319: LD_VAR 0 19
58323: PPUSH
58324: LD_INT 1
58326: PPUSH
58327: LD_VAR 0 9
58331: PPUSH
58332: CALL_OW 2
58336: ST_TO_ADDR
58337: GO 58368
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58339: LD_ADDR_VAR 0 19
58343: PUSH
58344: LD_VAR 0 19
58348: PPUSH
58349: LD_VAR 0 19
58353: PUSH
58354: LD_INT 1
58356: PLUS
58357: PPUSH
58358: LD_VAR 0 9
58362: PPUSH
58363: CALL_OW 2
58367: ST_TO_ADDR
58368: GO 58296
58370: POP
58371: POP
// if tmp then
58372: LD_VAR 0 19
58376: IFFALSE 58388
// f := tmp ;
58378: LD_ADDR_VAR 0 12
58382: PUSH
58383: LD_VAR 0 19
58387: ST_TO_ADDR
// end ; x := personel [ i ] ;
58388: LD_ADDR_VAR 0 13
58392: PUSH
58393: LD_VAR 0 6
58397: PUSH
58398: LD_VAR 0 8
58402: ARRAY
58403: ST_TO_ADDR
// if x = - 1 then
58404: LD_VAR 0 13
58408: PUSH
58409: LD_INT 1
58411: NEG
58412: EQUAL
58413: IFFALSE 58622
// begin for j in f do
58415: LD_ADDR_VAR 0 9
58419: PUSH
58420: LD_VAR 0 12
58424: PUSH
58425: FOR_IN
58426: IFFALSE 58618
// repeat InitHc ;
58428: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58432: LD_VAR 0 9
58436: PPUSH
58437: CALL_OW 266
58441: PUSH
58442: LD_INT 5
58444: EQUAL
58445: IFFALSE 58515
// begin if UnitsInside ( j ) < 3 then
58447: LD_VAR 0 9
58451: PPUSH
58452: CALL_OW 313
58456: PUSH
58457: LD_INT 3
58459: LESS
58460: IFFALSE 58496
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58462: LD_INT 0
58464: PPUSH
58465: LD_INT 5
58467: PUSH
58468: LD_INT 8
58470: PUSH
58471: LD_INT 9
58473: PUSH
58474: EMPTY
58475: LIST
58476: LIST
58477: LIST
58478: PUSH
58479: LD_VAR 0 17
58483: ARRAY
58484: PPUSH
58485: LD_VAR 0 4
58489: PPUSH
58490: CALL_OW 380
58494: GO 58513
// PrepareHuman ( false , i , skill ) ;
58496: LD_INT 0
58498: PPUSH
58499: LD_VAR 0 8
58503: PPUSH
58504: LD_VAR 0 4
58508: PPUSH
58509: CALL_OW 380
// end else
58513: GO 58532
// PrepareHuman ( false , i , skill ) ;
58515: LD_INT 0
58517: PPUSH
58518: LD_VAR 0 8
58522: PPUSH
58523: LD_VAR 0 4
58527: PPUSH
58528: CALL_OW 380
// un := CreateHuman ;
58532: LD_ADDR_VAR 0 14
58536: PUSH
58537: CALL_OW 44
58541: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58542: LD_ADDR_VAR 0 7
58546: PUSH
58547: LD_VAR 0 7
58551: PPUSH
58552: LD_INT 1
58554: PPUSH
58555: LD_VAR 0 14
58559: PPUSH
58560: CALL_OW 2
58564: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58565: LD_VAR 0 14
58569: PPUSH
58570: LD_VAR 0 9
58574: PPUSH
58575: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58579: LD_VAR 0 9
58583: PPUSH
58584: CALL_OW 313
58588: PUSH
58589: LD_INT 6
58591: EQUAL
58592: PUSH
58593: LD_VAR 0 9
58597: PPUSH
58598: CALL_OW 266
58602: PUSH
58603: LD_INT 32
58605: PUSH
58606: LD_INT 31
58608: PUSH
58609: EMPTY
58610: LIST
58611: LIST
58612: IN
58613: OR
58614: IFFALSE 58428
58616: GO 58425
58618: POP
58619: POP
// end else
58620: GO 59002
// for j = 1 to x do
58622: LD_ADDR_VAR 0 9
58626: PUSH
58627: DOUBLE
58628: LD_INT 1
58630: DEC
58631: ST_TO_ADDR
58632: LD_VAR 0 13
58636: PUSH
58637: FOR_TO
58638: IFFALSE 59000
// begin InitHc ;
58640: CALL_OW 19
// if not f then
58644: LD_VAR 0 12
58648: NOT
58649: IFFALSE 58738
// begin PrepareHuman ( false , i , skill ) ;
58651: LD_INT 0
58653: PPUSH
58654: LD_VAR 0 8
58658: PPUSH
58659: LD_VAR 0 4
58663: PPUSH
58664: CALL_OW 380
// un := CreateHuman ;
58668: LD_ADDR_VAR 0 14
58672: PUSH
58673: CALL_OW 44
58677: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58678: LD_ADDR_VAR 0 7
58682: PUSH
58683: LD_VAR 0 7
58687: PPUSH
58688: LD_INT 1
58690: PPUSH
58691: LD_VAR 0 14
58695: PPUSH
58696: CALL_OW 2
58700: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58701: LD_VAR 0 14
58705: PPUSH
58706: LD_VAR 0 1
58710: PPUSH
58711: CALL_OW 250
58715: PPUSH
58716: LD_VAR 0 1
58720: PPUSH
58721: CALL_OW 251
58725: PPUSH
58726: LD_INT 10
58728: PPUSH
58729: LD_INT 0
58731: PPUSH
58732: CALL_OW 50
// continue ;
58736: GO 58637
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58738: LD_VAR 0 12
58742: PUSH
58743: LD_INT 1
58745: ARRAY
58746: PPUSH
58747: CALL_OW 313
58751: PUSH
58752: LD_VAR 0 12
58756: PUSH
58757: LD_INT 1
58759: ARRAY
58760: PPUSH
58761: CALL_OW 266
58765: PUSH
58766: LD_INT 32
58768: PUSH
58769: LD_INT 31
58771: PUSH
58772: EMPTY
58773: LIST
58774: LIST
58775: IN
58776: AND
58777: PUSH
58778: LD_VAR 0 12
58782: PUSH
58783: LD_INT 1
58785: ARRAY
58786: PPUSH
58787: CALL_OW 313
58791: PUSH
58792: LD_INT 6
58794: EQUAL
58795: OR
58796: IFFALSE 58816
// f := Delete ( f , 1 ) ;
58798: LD_ADDR_VAR 0 12
58802: PUSH
58803: LD_VAR 0 12
58807: PPUSH
58808: LD_INT 1
58810: PPUSH
58811: CALL_OW 3
58815: ST_TO_ADDR
// if not f then
58816: LD_VAR 0 12
58820: NOT
58821: IFFALSE 58839
// begin x := x + 2 ;
58823: LD_ADDR_VAR 0 13
58827: PUSH
58828: LD_VAR 0 13
58832: PUSH
58833: LD_INT 2
58835: PLUS
58836: ST_TO_ADDR
// continue ;
58837: GO 58637
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58839: LD_VAR 0 12
58843: PUSH
58844: LD_INT 1
58846: ARRAY
58847: PPUSH
58848: CALL_OW 266
58852: PUSH
58853: LD_INT 5
58855: EQUAL
58856: IFFALSE 58930
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58858: LD_VAR 0 12
58862: PUSH
58863: LD_INT 1
58865: ARRAY
58866: PPUSH
58867: CALL_OW 313
58871: PUSH
58872: LD_INT 3
58874: LESS
58875: IFFALSE 58911
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58877: LD_INT 0
58879: PPUSH
58880: LD_INT 5
58882: PUSH
58883: LD_INT 8
58885: PUSH
58886: LD_INT 9
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: LIST
58893: PUSH
58894: LD_VAR 0 17
58898: ARRAY
58899: PPUSH
58900: LD_VAR 0 4
58904: PPUSH
58905: CALL_OW 380
58909: GO 58928
// PrepareHuman ( false , i , skill ) ;
58911: LD_INT 0
58913: PPUSH
58914: LD_VAR 0 8
58918: PPUSH
58919: LD_VAR 0 4
58923: PPUSH
58924: CALL_OW 380
// end else
58928: GO 58947
// PrepareHuman ( false , i , skill ) ;
58930: LD_INT 0
58932: PPUSH
58933: LD_VAR 0 8
58937: PPUSH
58938: LD_VAR 0 4
58942: PPUSH
58943: CALL_OW 380
// un := CreateHuman ;
58947: LD_ADDR_VAR 0 14
58951: PUSH
58952: CALL_OW 44
58956: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58957: LD_ADDR_VAR 0 7
58961: PUSH
58962: LD_VAR 0 7
58966: PPUSH
58967: LD_INT 1
58969: PPUSH
58970: LD_VAR 0 14
58974: PPUSH
58975: CALL_OW 2
58979: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58980: LD_VAR 0 14
58984: PPUSH
58985: LD_VAR 0 12
58989: PUSH
58990: LD_INT 1
58992: ARRAY
58993: PPUSH
58994: CALL_OW 52
// end ;
58998: GO 58637
59000: POP
59001: POP
// end ;
59002: GO 57939
59004: POP
59005: POP
// result := result ^ buildings ;
59006: LD_ADDR_VAR 0 7
59010: PUSH
59011: LD_VAR 0 7
59015: PUSH
59016: LD_VAR 0 18
59020: ADD
59021: ST_TO_ADDR
// end else
59022: GO 59165
// begin for i = 1 to personel do
59024: LD_ADDR_VAR 0 8
59028: PUSH
59029: DOUBLE
59030: LD_INT 1
59032: DEC
59033: ST_TO_ADDR
59034: LD_VAR 0 6
59038: PUSH
59039: FOR_TO
59040: IFFALSE 59163
// begin if i > 4 then
59042: LD_VAR 0 8
59046: PUSH
59047: LD_INT 4
59049: GREATER
59050: IFFALSE 59054
// break ;
59052: GO 59163
// x := personel [ i ] ;
59054: LD_ADDR_VAR 0 13
59058: PUSH
59059: LD_VAR 0 6
59063: PUSH
59064: LD_VAR 0 8
59068: ARRAY
59069: ST_TO_ADDR
// if x = - 1 then
59070: LD_VAR 0 13
59074: PUSH
59075: LD_INT 1
59077: NEG
59078: EQUAL
59079: IFFALSE 59083
// continue ;
59081: GO 59039
// PrepareHuman ( false , i , skill ) ;
59083: LD_INT 0
59085: PPUSH
59086: LD_VAR 0 8
59090: PPUSH
59091: LD_VAR 0 4
59095: PPUSH
59096: CALL_OW 380
// un := CreateHuman ;
59100: LD_ADDR_VAR 0 14
59104: PUSH
59105: CALL_OW 44
59109: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59110: LD_VAR 0 14
59114: PPUSH
59115: LD_VAR 0 1
59119: PPUSH
59120: CALL_OW 250
59124: PPUSH
59125: LD_VAR 0 1
59129: PPUSH
59130: CALL_OW 251
59134: PPUSH
59135: LD_INT 10
59137: PPUSH
59138: LD_INT 0
59140: PPUSH
59141: CALL_OW 50
// result := result ^ un ;
59145: LD_ADDR_VAR 0 7
59149: PUSH
59150: LD_VAR 0 7
59154: PUSH
59155: LD_VAR 0 14
59159: ADD
59160: ST_TO_ADDR
// end ;
59161: GO 59039
59163: POP
59164: POP
// end ; end ;
59165: LD_VAR 0 7
59169: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59170: LD_INT 0
59172: PPUSH
59173: PPUSH
59174: PPUSH
59175: PPUSH
59176: PPUSH
59177: PPUSH
59178: PPUSH
59179: PPUSH
59180: PPUSH
59181: PPUSH
59182: PPUSH
59183: PPUSH
59184: PPUSH
59185: PPUSH
59186: PPUSH
59187: PPUSH
// result := false ;
59188: LD_ADDR_VAR 0 3
59192: PUSH
59193: LD_INT 0
59195: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59196: LD_VAR 0 1
59200: NOT
59201: PUSH
59202: LD_VAR 0 1
59206: PPUSH
59207: CALL_OW 266
59211: PUSH
59212: LD_INT 32
59214: PUSH
59215: LD_INT 33
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: IN
59222: NOT
59223: OR
59224: IFFALSE 59228
// exit ;
59226: GO 60337
// nat := GetNation ( tower ) ;
59228: LD_ADDR_VAR 0 12
59232: PUSH
59233: LD_VAR 0 1
59237: PPUSH
59238: CALL_OW 248
59242: ST_TO_ADDR
// side := GetSide ( tower ) ;
59243: LD_ADDR_VAR 0 16
59247: PUSH
59248: LD_VAR 0 1
59252: PPUSH
59253: CALL_OW 255
59257: ST_TO_ADDR
// x := GetX ( tower ) ;
59258: LD_ADDR_VAR 0 10
59262: PUSH
59263: LD_VAR 0 1
59267: PPUSH
59268: CALL_OW 250
59272: ST_TO_ADDR
// y := GetY ( tower ) ;
59273: LD_ADDR_VAR 0 11
59277: PUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: CALL_OW 251
59287: ST_TO_ADDR
// if not x or not y then
59288: LD_VAR 0 10
59292: NOT
59293: PUSH
59294: LD_VAR 0 11
59298: NOT
59299: OR
59300: IFFALSE 59304
// exit ;
59302: GO 60337
// weapon := 0 ;
59304: LD_ADDR_VAR 0 18
59308: PUSH
59309: LD_INT 0
59311: ST_TO_ADDR
// fac_list := [ ] ;
59312: LD_ADDR_VAR 0 17
59316: PUSH
59317: EMPTY
59318: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59319: LD_ADDR_VAR 0 6
59323: PUSH
59324: LD_VAR 0 1
59328: PPUSH
59329: CALL_OW 274
59333: PPUSH
59334: LD_VAR 0 2
59338: PPUSH
59339: LD_INT 0
59341: PPUSH
59342: CALL 56908 0 3
59346: PPUSH
59347: LD_INT 30
59349: PUSH
59350: LD_INT 3
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PPUSH
59357: CALL_OW 72
59361: ST_TO_ADDR
// if not factories then
59362: LD_VAR 0 6
59366: NOT
59367: IFFALSE 59371
// exit ;
59369: GO 60337
// for i in factories do
59371: LD_ADDR_VAR 0 8
59375: PUSH
59376: LD_VAR 0 6
59380: PUSH
59381: FOR_IN
59382: IFFALSE 59407
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59384: LD_ADDR_VAR 0 17
59388: PUSH
59389: LD_VAR 0 17
59393: PUSH
59394: LD_VAR 0 8
59398: PPUSH
59399: CALL_OW 478
59403: UNION
59404: ST_TO_ADDR
59405: GO 59381
59407: POP
59408: POP
// if not fac_list then
59409: LD_VAR 0 17
59413: NOT
59414: IFFALSE 59418
// exit ;
59416: GO 60337
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59418: LD_ADDR_VAR 0 5
59422: PUSH
59423: LD_INT 4
59425: PUSH
59426: LD_INT 5
59428: PUSH
59429: LD_INT 9
59431: PUSH
59432: LD_INT 10
59434: PUSH
59435: LD_INT 6
59437: PUSH
59438: LD_INT 7
59440: PUSH
59441: LD_INT 11
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: LIST
59448: LIST
59449: LIST
59450: LIST
59451: LIST
59452: PUSH
59453: LD_INT 27
59455: PUSH
59456: LD_INT 28
59458: PUSH
59459: LD_INT 26
59461: PUSH
59462: LD_INT 30
59464: PUSH
59465: EMPTY
59466: LIST
59467: LIST
59468: LIST
59469: LIST
59470: PUSH
59471: LD_INT 43
59473: PUSH
59474: LD_INT 44
59476: PUSH
59477: LD_INT 46
59479: PUSH
59480: LD_INT 45
59482: PUSH
59483: LD_INT 47
59485: PUSH
59486: LD_INT 49
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: LIST
59493: LIST
59494: LIST
59495: LIST
59496: PUSH
59497: EMPTY
59498: LIST
59499: LIST
59500: LIST
59501: PUSH
59502: LD_VAR 0 12
59506: ARRAY
59507: ST_TO_ADDR
// list := list isect fac_list ;
59508: LD_ADDR_VAR 0 5
59512: PUSH
59513: LD_VAR 0 5
59517: PUSH
59518: LD_VAR 0 17
59522: ISECT
59523: ST_TO_ADDR
// if not list then
59524: LD_VAR 0 5
59528: NOT
59529: IFFALSE 59533
// exit ;
59531: GO 60337
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59533: LD_VAR 0 12
59537: PUSH
59538: LD_INT 3
59540: EQUAL
59541: PUSH
59542: LD_INT 49
59544: PUSH
59545: LD_VAR 0 5
59549: IN
59550: AND
59551: PUSH
59552: LD_INT 31
59554: PPUSH
59555: LD_VAR 0 16
59559: PPUSH
59560: CALL_OW 321
59564: PUSH
59565: LD_INT 2
59567: EQUAL
59568: AND
59569: IFFALSE 59629
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59571: LD_INT 22
59573: PUSH
59574: LD_VAR 0 16
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: PUSH
59583: LD_INT 35
59585: PUSH
59586: LD_INT 49
59588: PUSH
59589: EMPTY
59590: LIST
59591: LIST
59592: PUSH
59593: LD_INT 91
59595: PUSH
59596: LD_VAR 0 1
59600: PUSH
59601: LD_INT 10
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: LIST
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: LIST
59613: PPUSH
59614: CALL_OW 69
59618: NOT
59619: IFFALSE 59629
// weapon := ru_time_lapser ;
59621: LD_ADDR_VAR 0 18
59625: PUSH
59626: LD_INT 49
59628: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59629: LD_VAR 0 12
59633: PUSH
59634: LD_INT 1
59636: PUSH
59637: LD_INT 2
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: IN
59644: PUSH
59645: LD_INT 11
59647: PUSH
59648: LD_VAR 0 5
59652: IN
59653: PUSH
59654: LD_INT 30
59656: PUSH
59657: LD_VAR 0 5
59661: IN
59662: OR
59663: AND
59664: PUSH
59665: LD_INT 6
59667: PPUSH
59668: LD_VAR 0 16
59672: PPUSH
59673: CALL_OW 321
59677: PUSH
59678: LD_INT 2
59680: EQUAL
59681: AND
59682: IFFALSE 59847
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59684: LD_INT 22
59686: PUSH
59687: LD_VAR 0 16
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: PUSH
59696: LD_INT 2
59698: PUSH
59699: LD_INT 35
59701: PUSH
59702: LD_INT 11
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: PUSH
59709: LD_INT 35
59711: PUSH
59712: LD_INT 30
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: LIST
59723: PUSH
59724: LD_INT 91
59726: PUSH
59727: LD_VAR 0 1
59731: PUSH
59732: LD_INT 18
59734: PUSH
59735: EMPTY
59736: LIST
59737: LIST
59738: LIST
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: LIST
59744: PPUSH
59745: CALL_OW 69
59749: NOT
59750: PUSH
59751: LD_INT 22
59753: PUSH
59754: LD_VAR 0 16
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: LD_INT 2
59765: PUSH
59766: LD_INT 30
59768: PUSH
59769: LD_INT 32
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_INT 30
59778: PUSH
59779: LD_INT 33
59781: PUSH
59782: EMPTY
59783: LIST
59784: LIST
59785: PUSH
59786: EMPTY
59787: LIST
59788: LIST
59789: LIST
59790: PUSH
59791: LD_INT 91
59793: PUSH
59794: LD_VAR 0 1
59798: PUSH
59799: LD_INT 12
59801: PUSH
59802: EMPTY
59803: LIST
59804: LIST
59805: LIST
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: LIST
59811: PUSH
59812: EMPTY
59813: LIST
59814: PPUSH
59815: CALL_OW 69
59819: PUSH
59820: LD_INT 2
59822: GREATER
59823: AND
59824: IFFALSE 59847
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59826: LD_ADDR_VAR 0 18
59830: PUSH
59831: LD_INT 11
59833: PUSH
59834: LD_INT 30
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: PUSH
59841: LD_VAR 0 12
59845: ARRAY
59846: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59847: LD_VAR 0 18
59851: NOT
59852: PUSH
59853: LD_INT 40
59855: PPUSH
59856: LD_VAR 0 16
59860: PPUSH
59861: CALL_OW 321
59865: PUSH
59866: LD_INT 2
59868: EQUAL
59869: AND
59870: PUSH
59871: LD_INT 7
59873: PUSH
59874: LD_VAR 0 5
59878: IN
59879: PUSH
59880: LD_INT 28
59882: PUSH
59883: LD_VAR 0 5
59887: IN
59888: OR
59889: PUSH
59890: LD_INT 45
59892: PUSH
59893: LD_VAR 0 5
59897: IN
59898: OR
59899: AND
59900: IFFALSE 60154
// begin hex := GetHexInfo ( x , y ) ;
59902: LD_ADDR_VAR 0 4
59906: PUSH
59907: LD_VAR 0 10
59911: PPUSH
59912: LD_VAR 0 11
59916: PPUSH
59917: CALL_OW 546
59921: ST_TO_ADDR
// if hex [ 1 ] then
59922: LD_VAR 0 4
59926: PUSH
59927: LD_INT 1
59929: ARRAY
59930: IFFALSE 59934
// exit ;
59932: GO 60337
// height := hex [ 2 ] ;
59934: LD_ADDR_VAR 0 15
59938: PUSH
59939: LD_VAR 0 4
59943: PUSH
59944: LD_INT 2
59946: ARRAY
59947: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59948: LD_ADDR_VAR 0 14
59952: PUSH
59953: LD_INT 0
59955: PUSH
59956: LD_INT 2
59958: PUSH
59959: LD_INT 3
59961: PUSH
59962: LD_INT 5
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: LIST
59969: LIST
59970: ST_TO_ADDR
// for i in tmp do
59971: LD_ADDR_VAR 0 8
59975: PUSH
59976: LD_VAR 0 14
59980: PUSH
59981: FOR_IN
59982: IFFALSE 60152
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59984: LD_ADDR_VAR 0 9
59988: PUSH
59989: LD_VAR 0 10
59993: PPUSH
59994: LD_VAR 0 8
59998: PPUSH
59999: LD_INT 5
60001: PPUSH
60002: CALL_OW 272
60006: PUSH
60007: LD_VAR 0 11
60011: PPUSH
60012: LD_VAR 0 8
60016: PPUSH
60017: LD_INT 5
60019: PPUSH
60020: CALL_OW 273
60024: PUSH
60025: EMPTY
60026: LIST
60027: LIST
60028: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60029: LD_VAR 0 9
60033: PUSH
60034: LD_INT 1
60036: ARRAY
60037: PPUSH
60038: LD_VAR 0 9
60042: PUSH
60043: LD_INT 2
60045: ARRAY
60046: PPUSH
60047: CALL_OW 488
60051: IFFALSE 60150
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60053: LD_ADDR_VAR 0 4
60057: PUSH
60058: LD_VAR 0 9
60062: PUSH
60063: LD_INT 1
60065: ARRAY
60066: PPUSH
60067: LD_VAR 0 9
60071: PUSH
60072: LD_INT 2
60074: ARRAY
60075: PPUSH
60076: CALL_OW 546
60080: ST_TO_ADDR
// if hex [ 1 ] then
60081: LD_VAR 0 4
60085: PUSH
60086: LD_INT 1
60088: ARRAY
60089: IFFALSE 60093
// continue ;
60091: GO 59981
// h := hex [ 2 ] ;
60093: LD_ADDR_VAR 0 13
60097: PUSH
60098: LD_VAR 0 4
60102: PUSH
60103: LD_INT 2
60105: ARRAY
60106: ST_TO_ADDR
// if h + 7 < height then
60107: LD_VAR 0 13
60111: PUSH
60112: LD_INT 7
60114: PLUS
60115: PUSH
60116: LD_VAR 0 15
60120: LESS
60121: IFFALSE 60150
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60123: LD_ADDR_VAR 0 18
60127: PUSH
60128: LD_INT 7
60130: PUSH
60131: LD_INT 28
60133: PUSH
60134: LD_INT 45
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: LIST
60141: PUSH
60142: LD_VAR 0 12
60146: ARRAY
60147: ST_TO_ADDR
// break ;
60148: GO 60152
// end ; end ; end ;
60150: GO 59981
60152: POP
60153: POP
// end ; if not weapon then
60154: LD_VAR 0 18
60158: NOT
60159: IFFALSE 60219
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60161: LD_ADDR_VAR 0 5
60165: PUSH
60166: LD_VAR 0 5
60170: PUSH
60171: LD_INT 11
60173: PUSH
60174: LD_INT 30
60176: PUSH
60177: LD_INT 49
60179: PUSH
60180: EMPTY
60181: LIST
60182: LIST
60183: LIST
60184: DIFF
60185: ST_TO_ADDR
// if not list then
60186: LD_VAR 0 5
60190: NOT
60191: IFFALSE 60195
// exit ;
60193: GO 60337
// weapon := list [ rand ( 1 , list ) ] ;
60195: LD_ADDR_VAR 0 18
60199: PUSH
60200: LD_VAR 0 5
60204: PUSH
60205: LD_INT 1
60207: PPUSH
60208: LD_VAR 0 5
60212: PPUSH
60213: CALL_OW 12
60217: ARRAY
60218: ST_TO_ADDR
// end ; if weapon then
60219: LD_VAR 0 18
60223: IFFALSE 60337
// begin tmp := CostOfWeapon ( weapon ) ;
60225: LD_ADDR_VAR 0 14
60229: PUSH
60230: LD_VAR 0 18
60234: PPUSH
60235: CALL_OW 451
60239: ST_TO_ADDR
// j := GetBase ( tower ) ;
60240: LD_ADDR_VAR 0 9
60244: PUSH
60245: LD_VAR 0 1
60249: PPUSH
60250: CALL_OW 274
60254: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60255: LD_VAR 0 9
60259: PPUSH
60260: LD_INT 1
60262: PPUSH
60263: CALL_OW 275
60267: PUSH
60268: LD_VAR 0 14
60272: PUSH
60273: LD_INT 1
60275: ARRAY
60276: GREATEREQUAL
60277: PUSH
60278: LD_VAR 0 9
60282: PPUSH
60283: LD_INT 2
60285: PPUSH
60286: CALL_OW 275
60290: PUSH
60291: LD_VAR 0 14
60295: PUSH
60296: LD_INT 2
60298: ARRAY
60299: GREATEREQUAL
60300: AND
60301: PUSH
60302: LD_VAR 0 9
60306: PPUSH
60307: LD_INT 3
60309: PPUSH
60310: CALL_OW 275
60314: PUSH
60315: LD_VAR 0 14
60319: PUSH
60320: LD_INT 3
60322: ARRAY
60323: GREATEREQUAL
60324: AND
60325: IFFALSE 60337
// result := weapon ;
60327: LD_ADDR_VAR 0 3
60331: PUSH
60332: LD_VAR 0 18
60336: ST_TO_ADDR
// end ; end ;
60337: LD_VAR 0 3
60341: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60342: LD_INT 0
60344: PPUSH
60345: PPUSH
// result := true ;
60346: LD_ADDR_VAR 0 3
60350: PUSH
60351: LD_INT 1
60353: ST_TO_ADDR
// if array1 = array2 then
60354: LD_VAR 0 1
60358: PUSH
60359: LD_VAR 0 2
60363: EQUAL
60364: IFFALSE 60424
// begin for i = 1 to array1 do
60366: LD_ADDR_VAR 0 4
60370: PUSH
60371: DOUBLE
60372: LD_INT 1
60374: DEC
60375: ST_TO_ADDR
60376: LD_VAR 0 1
60380: PUSH
60381: FOR_TO
60382: IFFALSE 60420
// if array1 [ i ] <> array2 [ i ] then
60384: LD_VAR 0 1
60388: PUSH
60389: LD_VAR 0 4
60393: ARRAY
60394: PUSH
60395: LD_VAR 0 2
60399: PUSH
60400: LD_VAR 0 4
60404: ARRAY
60405: NONEQUAL
60406: IFFALSE 60418
// begin result := false ;
60408: LD_ADDR_VAR 0 3
60412: PUSH
60413: LD_INT 0
60415: ST_TO_ADDR
// break ;
60416: GO 60420
// end ;
60418: GO 60381
60420: POP
60421: POP
// end else
60422: GO 60432
// result := false ;
60424: LD_ADDR_VAR 0 3
60428: PUSH
60429: LD_INT 0
60431: ST_TO_ADDR
// end ;
60432: LD_VAR 0 3
60436: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60437: LD_INT 0
60439: PPUSH
60440: PPUSH
// if not array1 or not array2 then
60441: LD_VAR 0 1
60445: NOT
60446: PUSH
60447: LD_VAR 0 2
60451: NOT
60452: OR
60453: IFFALSE 60457
// exit ;
60455: GO 60521
// result := true ;
60457: LD_ADDR_VAR 0 3
60461: PUSH
60462: LD_INT 1
60464: ST_TO_ADDR
// for i = 1 to array1 do
60465: LD_ADDR_VAR 0 4
60469: PUSH
60470: DOUBLE
60471: LD_INT 1
60473: DEC
60474: ST_TO_ADDR
60475: LD_VAR 0 1
60479: PUSH
60480: FOR_TO
60481: IFFALSE 60519
// if array1 [ i ] <> array2 [ i ] then
60483: LD_VAR 0 1
60487: PUSH
60488: LD_VAR 0 4
60492: ARRAY
60493: PUSH
60494: LD_VAR 0 2
60498: PUSH
60499: LD_VAR 0 4
60503: ARRAY
60504: NONEQUAL
60505: IFFALSE 60517
// begin result := false ;
60507: LD_ADDR_VAR 0 3
60511: PUSH
60512: LD_INT 0
60514: ST_TO_ADDR
// break ;
60515: GO 60519
// end ;
60517: GO 60480
60519: POP
60520: POP
// end ;
60521: LD_VAR 0 3
60525: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60526: LD_INT 0
60528: PPUSH
60529: PPUSH
60530: PPUSH
// pom := GetBase ( fac ) ;
60531: LD_ADDR_VAR 0 5
60535: PUSH
60536: LD_VAR 0 1
60540: PPUSH
60541: CALL_OW 274
60545: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60546: LD_ADDR_VAR 0 4
60550: PUSH
60551: LD_VAR 0 2
60555: PUSH
60556: LD_INT 1
60558: ARRAY
60559: PPUSH
60560: LD_VAR 0 2
60564: PUSH
60565: LD_INT 2
60567: ARRAY
60568: PPUSH
60569: LD_VAR 0 2
60573: PUSH
60574: LD_INT 3
60576: ARRAY
60577: PPUSH
60578: LD_VAR 0 2
60582: PUSH
60583: LD_INT 4
60585: ARRAY
60586: PPUSH
60587: CALL_OW 449
60591: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60592: LD_ADDR_VAR 0 3
60596: PUSH
60597: LD_VAR 0 5
60601: PPUSH
60602: LD_INT 1
60604: PPUSH
60605: CALL_OW 275
60609: PUSH
60610: LD_VAR 0 4
60614: PUSH
60615: LD_INT 1
60617: ARRAY
60618: GREATEREQUAL
60619: PUSH
60620: LD_VAR 0 5
60624: PPUSH
60625: LD_INT 2
60627: PPUSH
60628: CALL_OW 275
60632: PUSH
60633: LD_VAR 0 4
60637: PUSH
60638: LD_INT 2
60640: ARRAY
60641: GREATEREQUAL
60642: AND
60643: PUSH
60644: LD_VAR 0 5
60648: PPUSH
60649: LD_INT 3
60651: PPUSH
60652: CALL_OW 275
60656: PUSH
60657: LD_VAR 0 4
60661: PUSH
60662: LD_INT 3
60664: ARRAY
60665: GREATEREQUAL
60666: AND
60667: ST_TO_ADDR
// end ;
60668: LD_VAR 0 3
60672: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60673: LD_INT 0
60675: PPUSH
60676: PPUSH
60677: PPUSH
60678: PPUSH
// pom := GetBase ( building ) ;
60679: LD_ADDR_VAR 0 3
60683: PUSH
60684: LD_VAR 0 1
60688: PPUSH
60689: CALL_OW 274
60693: ST_TO_ADDR
// if not pom then
60694: LD_VAR 0 3
60698: NOT
60699: IFFALSE 60703
// exit ;
60701: GO 60873
// btype := GetBType ( building ) ;
60703: LD_ADDR_VAR 0 5
60707: PUSH
60708: LD_VAR 0 1
60712: PPUSH
60713: CALL_OW 266
60717: ST_TO_ADDR
// if btype = b_armoury then
60718: LD_VAR 0 5
60722: PUSH
60723: LD_INT 4
60725: EQUAL
60726: IFFALSE 60736
// btype := b_barracks ;
60728: LD_ADDR_VAR 0 5
60732: PUSH
60733: LD_INT 5
60735: ST_TO_ADDR
// if btype = b_depot then
60736: LD_VAR 0 5
60740: PUSH
60741: LD_INT 0
60743: EQUAL
60744: IFFALSE 60754
// btype := b_warehouse ;
60746: LD_ADDR_VAR 0 5
60750: PUSH
60751: LD_INT 1
60753: ST_TO_ADDR
// if btype = b_workshop then
60754: LD_VAR 0 5
60758: PUSH
60759: LD_INT 2
60761: EQUAL
60762: IFFALSE 60772
// btype := b_factory ;
60764: LD_ADDR_VAR 0 5
60768: PUSH
60769: LD_INT 3
60771: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60772: LD_ADDR_VAR 0 4
60776: PUSH
60777: LD_VAR 0 5
60781: PPUSH
60782: LD_VAR 0 1
60786: PPUSH
60787: CALL_OW 248
60791: PPUSH
60792: CALL_OW 450
60796: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60797: LD_ADDR_VAR 0 2
60801: PUSH
60802: LD_VAR 0 3
60806: PPUSH
60807: LD_INT 1
60809: PPUSH
60810: CALL_OW 275
60814: PUSH
60815: LD_VAR 0 4
60819: PUSH
60820: LD_INT 1
60822: ARRAY
60823: GREATEREQUAL
60824: PUSH
60825: LD_VAR 0 3
60829: PPUSH
60830: LD_INT 2
60832: PPUSH
60833: CALL_OW 275
60837: PUSH
60838: LD_VAR 0 4
60842: PUSH
60843: LD_INT 2
60845: ARRAY
60846: GREATEREQUAL
60847: AND
60848: PUSH
60849: LD_VAR 0 3
60853: PPUSH
60854: LD_INT 3
60856: PPUSH
60857: CALL_OW 275
60861: PUSH
60862: LD_VAR 0 4
60866: PUSH
60867: LD_INT 3
60869: ARRAY
60870: GREATEREQUAL
60871: AND
60872: ST_TO_ADDR
// end ;
60873: LD_VAR 0 2
60877: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60878: LD_INT 0
60880: PPUSH
60881: PPUSH
60882: PPUSH
// pom := GetBase ( building ) ;
60883: LD_ADDR_VAR 0 4
60887: PUSH
60888: LD_VAR 0 1
60892: PPUSH
60893: CALL_OW 274
60897: ST_TO_ADDR
// if not pom then
60898: LD_VAR 0 4
60902: NOT
60903: IFFALSE 60907
// exit ;
60905: GO 61008
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60907: LD_ADDR_VAR 0 5
60911: PUSH
60912: LD_VAR 0 2
60916: PPUSH
60917: LD_VAR 0 1
60921: PPUSH
60922: CALL_OW 248
60926: PPUSH
60927: CALL_OW 450
60931: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60932: LD_ADDR_VAR 0 3
60936: PUSH
60937: LD_VAR 0 4
60941: PPUSH
60942: LD_INT 1
60944: PPUSH
60945: CALL_OW 275
60949: PUSH
60950: LD_VAR 0 5
60954: PUSH
60955: LD_INT 1
60957: ARRAY
60958: GREATEREQUAL
60959: PUSH
60960: LD_VAR 0 4
60964: PPUSH
60965: LD_INT 2
60967: PPUSH
60968: CALL_OW 275
60972: PUSH
60973: LD_VAR 0 5
60977: PUSH
60978: LD_INT 2
60980: ARRAY
60981: GREATEREQUAL
60982: AND
60983: PUSH
60984: LD_VAR 0 4
60988: PPUSH
60989: LD_INT 3
60991: PPUSH
60992: CALL_OW 275
60996: PUSH
60997: LD_VAR 0 5
61001: PUSH
61002: LD_INT 3
61004: ARRAY
61005: GREATEREQUAL
61006: AND
61007: ST_TO_ADDR
// end ;
61008: LD_VAR 0 3
61012: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61013: LD_INT 0
61015: PPUSH
61016: PPUSH
61017: PPUSH
61018: PPUSH
61019: PPUSH
61020: PPUSH
61021: PPUSH
61022: PPUSH
61023: PPUSH
61024: PPUSH
61025: PPUSH
// result := false ;
61026: LD_ADDR_VAR 0 8
61030: PUSH
61031: LD_INT 0
61033: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61034: LD_VAR 0 5
61038: NOT
61039: PUSH
61040: LD_VAR 0 1
61044: NOT
61045: OR
61046: PUSH
61047: LD_VAR 0 2
61051: NOT
61052: OR
61053: PUSH
61054: LD_VAR 0 3
61058: NOT
61059: OR
61060: IFFALSE 61064
// exit ;
61062: GO 61878
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61064: LD_ADDR_VAR 0 14
61068: PUSH
61069: LD_VAR 0 1
61073: PPUSH
61074: LD_VAR 0 2
61078: PPUSH
61079: LD_VAR 0 3
61083: PPUSH
61084: LD_VAR 0 4
61088: PPUSH
61089: LD_VAR 0 5
61093: PUSH
61094: LD_INT 1
61096: ARRAY
61097: PPUSH
61098: CALL_OW 248
61102: PPUSH
61103: LD_INT 0
61105: PPUSH
61106: CALL 63111 0 6
61110: ST_TO_ADDR
// if not hexes then
61111: LD_VAR 0 14
61115: NOT
61116: IFFALSE 61120
// exit ;
61118: GO 61878
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61120: LD_ADDR_VAR 0 17
61124: PUSH
61125: LD_VAR 0 5
61129: PPUSH
61130: LD_INT 22
61132: PUSH
61133: LD_VAR 0 13
61137: PPUSH
61138: CALL_OW 255
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: PUSH
61147: LD_INT 2
61149: PUSH
61150: LD_INT 30
61152: PUSH
61153: LD_INT 0
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: PUSH
61160: LD_INT 30
61162: PUSH
61163: LD_INT 1
61165: PUSH
61166: EMPTY
61167: LIST
61168: LIST
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: LIST
61174: PUSH
61175: EMPTY
61176: LIST
61177: LIST
61178: PPUSH
61179: CALL_OW 72
61183: ST_TO_ADDR
// for i = 1 to hexes do
61184: LD_ADDR_VAR 0 9
61188: PUSH
61189: DOUBLE
61190: LD_INT 1
61192: DEC
61193: ST_TO_ADDR
61194: LD_VAR 0 14
61198: PUSH
61199: FOR_TO
61200: IFFALSE 61876
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61202: LD_ADDR_VAR 0 13
61206: PUSH
61207: LD_VAR 0 14
61211: PUSH
61212: LD_VAR 0 9
61216: ARRAY
61217: PUSH
61218: LD_INT 1
61220: ARRAY
61221: PPUSH
61222: LD_VAR 0 14
61226: PUSH
61227: LD_VAR 0 9
61231: ARRAY
61232: PUSH
61233: LD_INT 2
61235: ARRAY
61236: PPUSH
61237: CALL_OW 428
61241: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61242: LD_VAR 0 14
61246: PUSH
61247: LD_VAR 0 9
61251: ARRAY
61252: PUSH
61253: LD_INT 1
61255: ARRAY
61256: PPUSH
61257: LD_VAR 0 14
61261: PUSH
61262: LD_VAR 0 9
61266: ARRAY
61267: PUSH
61268: LD_INT 2
61270: ARRAY
61271: PPUSH
61272: CALL_OW 351
61276: PUSH
61277: LD_VAR 0 14
61281: PUSH
61282: LD_VAR 0 9
61286: ARRAY
61287: PUSH
61288: LD_INT 1
61290: ARRAY
61291: PPUSH
61292: LD_VAR 0 14
61296: PUSH
61297: LD_VAR 0 9
61301: ARRAY
61302: PUSH
61303: LD_INT 2
61305: ARRAY
61306: PPUSH
61307: CALL_OW 488
61311: NOT
61312: OR
61313: PUSH
61314: LD_VAR 0 13
61318: PPUSH
61319: CALL_OW 247
61323: PUSH
61324: LD_INT 3
61326: EQUAL
61327: OR
61328: IFFALSE 61334
// exit ;
61330: POP
61331: POP
61332: GO 61878
// if not tmp then
61334: LD_VAR 0 13
61338: NOT
61339: IFFALSE 61343
// continue ;
61341: GO 61199
// result := true ;
61343: LD_ADDR_VAR 0 8
61347: PUSH
61348: LD_INT 1
61350: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61351: LD_VAR 0 6
61355: PUSH
61356: LD_VAR 0 13
61360: PPUSH
61361: CALL_OW 247
61365: PUSH
61366: LD_INT 2
61368: EQUAL
61369: AND
61370: PUSH
61371: LD_VAR 0 13
61375: PPUSH
61376: CALL_OW 263
61380: PUSH
61381: LD_INT 1
61383: EQUAL
61384: AND
61385: IFFALSE 61549
// begin if IsDrivenBy ( tmp ) then
61387: LD_VAR 0 13
61391: PPUSH
61392: CALL_OW 311
61396: IFFALSE 61400
// continue ;
61398: GO 61199
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61400: LD_VAR 0 6
61404: PPUSH
61405: LD_INT 3
61407: PUSH
61408: LD_INT 60
61410: PUSH
61411: EMPTY
61412: LIST
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PUSH
61418: LD_INT 3
61420: PUSH
61421: LD_INT 55
61423: PUSH
61424: EMPTY
61425: LIST
61426: PUSH
61427: EMPTY
61428: LIST
61429: LIST
61430: PUSH
61431: EMPTY
61432: LIST
61433: LIST
61434: PPUSH
61435: CALL_OW 72
61439: IFFALSE 61547
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61441: LD_ADDR_VAR 0 18
61445: PUSH
61446: LD_VAR 0 6
61450: PPUSH
61451: LD_INT 3
61453: PUSH
61454: LD_INT 60
61456: PUSH
61457: EMPTY
61458: LIST
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: PUSH
61464: LD_INT 3
61466: PUSH
61467: LD_INT 55
61469: PUSH
61470: EMPTY
61471: LIST
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PUSH
61477: EMPTY
61478: LIST
61479: LIST
61480: PPUSH
61481: CALL_OW 72
61485: PUSH
61486: LD_INT 1
61488: ARRAY
61489: ST_TO_ADDR
// if IsInUnit ( driver ) then
61490: LD_VAR 0 18
61494: PPUSH
61495: CALL_OW 310
61499: IFFALSE 61510
// ComExit ( driver ) ;
61501: LD_VAR 0 18
61505: PPUSH
61506: CALL 86891 0 1
// AddComEnterUnit ( driver , tmp ) ;
61510: LD_VAR 0 18
61514: PPUSH
61515: LD_VAR 0 13
61519: PPUSH
61520: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61524: LD_VAR 0 18
61528: PPUSH
61529: LD_VAR 0 7
61533: PPUSH
61534: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61538: LD_VAR 0 18
61542: PPUSH
61543: CALL_OW 181
// end ; continue ;
61547: GO 61199
// end ; if not cleaners or not tmp in cleaners then
61549: LD_VAR 0 6
61553: NOT
61554: PUSH
61555: LD_VAR 0 13
61559: PUSH
61560: LD_VAR 0 6
61564: IN
61565: NOT
61566: OR
61567: IFFALSE 61874
// begin if dep then
61569: LD_VAR 0 17
61573: IFFALSE 61709
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61575: LD_ADDR_VAR 0 16
61579: PUSH
61580: LD_VAR 0 17
61584: PUSH
61585: LD_INT 1
61587: ARRAY
61588: PPUSH
61589: CALL_OW 250
61593: PPUSH
61594: LD_VAR 0 17
61598: PUSH
61599: LD_INT 1
61601: ARRAY
61602: PPUSH
61603: CALL_OW 254
61607: PPUSH
61608: LD_INT 5
61610: PPUSH
61611: CALL_OW 272
61615: PUSH
61616: LD_VAR 0 17
61620: PUSH
61621: LD_INT 1
61623: ARRAY
61624: PPUSH
61625: CALL_OW 251
61629: PPUSH
61630: LD_VAR 0 17
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PPUSH
61639: CALL_OW 254
61643: PPUSH
61644: LD_INT 5
61646: PPUSH
61647: CALL_OW 273
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61656: LD_VAR 0 16
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: PPUSH
61665: LD_VAR 0 16
61669: PUSH
61670: LD_INT 2
61672: ARRAY
61673: PPUSH
61674: CALL_OW 488
61678: IFFALSE 61709
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61680: LD_VAR 0 13
61684: PPUSH
61685: LD_VAR 0 16
61689: PUSH
61690: LD_INT 1
61692: ARRAY
61693: PPUSH
61694: LD_VAR 0 16
61698: PUSH
61699: LD_INT 2
61701: ARRAY
61702: PPUSH
61703: CALL_OW 111
// continue ;
61707: GO 61199
// end ; end ; r := GetDir ( tmp ) ;
61709: LD_ADDR_VAR 0 15
61713: PUSH
61714: LD_VAR 0 13
61718: PPUSH
61719: CALL_OW 254
61723: ST_TO_ADDR
// if r = 5 then
61724: LD_VAR 0 15
61728: PUSH
61729: LD_INT 5
61731: EQUAL
61732: IFFALSE 61742
// r := 0 ;
61734: LD_ADDR_VAR 0 15
61738: PUSH
61739: LD_INT 0
61741: ST_TO_ADDR
// for j = r to 5 do
61742: LD_ADDR_VAR 0 10
61746: PUSH
61747: DOUBLE
61748: LD_VAR 0 15
61752: DEC
61753: ST_TO_ADDR
61754: LD_INT 5
61756: PUSH
61757: FOR_TO
61758: IFFALSE 61872
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61760: LD_ADDR_VAR 0 11
61764: PUSH
61765: LD_VAR 0 13
61769: PPUSH
61770: CALL_OW 250
61774: PPUSH
61775: LD_VAR 0 10
61779: PPUSH
61780: LD_INT 2
61782: PPUSH
61783: CALL_OW 272
61787: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61788: LD_ADDR_VAR 0 12
61792: PUSH
61793: LD_VAR 0 13
61797: PPUSH
61798: CALL_OW 251
61802: PPUSH
61803: LD_VAR 0 10
61807: PPUSH
61808: LD_INT 2
61810: PPUSH
61811: CALL_OW 273
61815: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61816: LD_VAR 0 11
61820: PPUSH
61821: LD_VAR 0 12
61825: PPUSH
61826: CALL_OW 488
61830: PUSH
61831: LD_VAR 0 11
61835: PPUSH
61836: LD_VAR 0 12
61840: PPUSH
61841: CALL_OW 428
61845: NOT
61846: AND
61847: IFFALSE 61870
// begin ComMoveXY ( tmp , _x , _y ) ;
61849: LD_VAR 0 13
61853: PPUSH
61854: LD_VAR 0 11
61858: PPUSH
61859: LD_VAR 0 12
61863: PPUSH
61864: CALL_OW 111
// break ;
61868: GO 61872
// end ; end ;
61870: GO 61757
61872: POP
61873: POP
// end ; end ;
61874: GO 61199
61876: POP
61877: POP
// end ;
61878: LD_VAR 0 8
61882: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61883: LD_INT 0
61885: PPUSH
// result := true ;
61886: LD_ADDR_VAR 0 3
61890: PUSH
61891: LD_INT 1
61893: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61894: LD_VAR 0 2
61898: PUSH
61899: LD_INT 24
61901: DOUBLE
61902: EQUAL
61903: IFTRUE 61913
61905: LD_INT 33
61907: DOUBLE
61908: EQUAL
61909: IFTRUE 61913
61911: GO 61938
61913: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61914: LD_ADDR_VAR 0 3
61918: PUSH
61919: LD_INT 32
61921: PPUSH
61922: LD_VAR 0 1
61926: PPUSH
61927: CALL_OW 321
61931: PUSH
61932: LD_INT 2
61934: EQUAL
61935: ST_TO_ADDR
61936: GO 62254
61938: LD_INT 20
61940: DOUBLE
61941: EQUAL
61942: IFTRUE 61946
61944: GO 61971
61946: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61947: LD_ADDR_VAR 0 3
61951: PUSH
61952: LD_INT 6
61954: PPUSH
61955: LD_VAR 0 1
61959: PPUSH
61960: CALL_OW 321
61964: PUSH
61965: LD_INT 2
61967: EQUAL
61968: ST_TO_ADDR
61969: GO 62254
61971: LD_INT 22
61973: DOUBLE
61974: EQUAL
61975: IFTRUE 61985
61977: LD_INT 36
61979: DOUBLE
61980: EQUAL
61981: IFTRUE 61985
61983: GO 62010
61985: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61986: LD_ADDR_VAR 0 3
61990: PUSH
61991: LD_INT 15
61993: PPUSH
61994: LD_VAR 0 1
61998: PPUSH
61999: CALL_OW 321
62003: PUSH
62004: LD_INT 2
62006: EQUAL
62007: ST_TO_ADDR
62008: GO 62254
62010: LD_INT 30
62012: DOUBLE
62013: EQUAL
62014: IFTRUE 62018
62016: GO 62043
62018: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62019: LD_ADDR_VAR 0 3
62023: PUSH
62024: LD_INT 20
62026: PPUSH
62027: LD_VAR 0 1
62031: PPUSH
62032: CALL_OW 321
62036: PUSH
62037: LD_INT 2
62039: EQUAL
62040: ST_TO_ADDR
62041: GO 62254
62043: LD_INT 28
62045: DOUBLE
62046: EQUAL
62047: IFTRUE 62057
62049: LD_INT 21
62051: DOUBLE
62052: EQUAL
62053: IFTRUE 62057
62055: GO 62082
62057: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62058: LD_ADDR_VAR 0 3
62062: PUSH
62063: LD_INT 21
62065: PPUSH
62066: LD_VAR 0 1
62070: PPUSH
62071: CALL_OW 321
62075: PUSH
62076: LD_INT 2
62078: EQUAL
62079: ST_TO_ADDR
62080: GO 62254
62082: LD_INT 16
62084: DOUBLE
62085: EQUAL
62086: IFTRUE 62090
62088: GO 62115
62090: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62091: LD_ADDR_VAR 0 3
62095: PUSH
62096: LD_INT 84
62098: PPUSH
62099: LD_VAR 0 1
62103: PPUSH
62104: CALL_OW 321
62108: PUSH
62109: LD_INT 2
62111: EQUAL
62112: ST_TO_ADDR
62113: GO 62254
62115: LD_INT 19
62117: DOUBLE
62118: EQUAL
62119: IFTRUE 62129
62121: LD_INT 23
62123: DOUBLE
62124: EQUAL
62125: IFTRUE 62129
62127: GO 62154
62129: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62130: LD_ADDR_VAR 0 3
62134: PUSH
62135: LD_INT 83
62137: PPUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: CALL_OW 321
62147: PUSH
62148: LD_INT 2
62150: EQUAL
62151: ST_TO_ADDR
62152: GO 62254
62154: LD_INT 17
62156: DOUBLE
62157: EQUAL
62158: IFTRUE 62162
62160: GO 62187
62162: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62163: LD_ADDR_VAR 0 3
62167: PUSH
62168: LD_INT 39
62170: PPUSH
62171: LD_VAR 0 1
62175: PPUSH
62176: CALL_OW 321
62180: PUSH
62181: LD_INT 2
62183: EQUAL
62184: ST_TO_ADDR
62185: GO 62254
62187: LD_INT 18
62189: DOUBLE
62190: EQUAL
62191: IFTRUE 62195
62193: GO 62220
62195: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62196: LD_ADDR_VAR 0 3
62200: PUSH
62201: LD_INT 40
62203: PPUSH
62204: LD_VAR 0 1
62208: PPUSH
62209: CALL_OW 321
62213: PUSH
62214: LD_INT 2
62216: EQUAL
62217: ST_TO_ADDR
62218: GO 62254
62220: LD_INT 27
62222: DOUBLE
62223: EQUAL
62224: IFTRUE 62228
62226: GO 62253
62228: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62229: LD_ADDR_VAR 0 3
62233: PUSH
62234: LD_INT 35
62236: PPUSH
62237: LD_VAR 0 1
62241: PPUSH
62242: CALL_OW 321
62246: PUSH
62247: LD_INT 2
62249: EQUAL
62250: ST_TO_ADDR
62251: GO 62254
62253: POP
// end ;
62254: LD_VAR 0 3
62258: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62259: LD_INT 0
62261: PPUSH
62262: PPUSH
62263: PPUSH
62264: PPUSH
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
62269: PPUSH
62270: PPUSH
62271: PPUSH
// result := false ;
62272: LD_ADDR_VAR 0 6
62276: PUSH
62277: LD_INT 0
62279: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62280: LD_VAR 0 1
62284: NOT
62285: PUSH
62286: LD_VAR 0 1
62290: PPUSH
62291: CALL_OW 266
62295: PUSH
62296: LD_INT 0
62298: PUSH
62299: LD_INT 1
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: IN
62306: NOT
62307: OR
62308: PUSH
62309: LD_VAR 0 2
62313: NOT
62314: OR
62315: PUSH
62316: LD_VAR 0 5
62320: PUSH
62321: LD_INT 0
62323: PUSH
62324: LD_INT 1
62326: PUSH
62327: LD_INT 2
62329: PUSH
62330: LD_INT 3
62332: PUSH
62333: LD_INT 4
62335: PUSH
62336: LD_INT 5
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: IN
62347: NOT
62348: OR
62349: PUSH
62350: LD_VAR 0 3
62354: PPUSH
62355: LD_VAR 0 4
62359: PPUSH
62360: CALL_OW 488
62364: NOT
62365: OR
62366: IFFALSE 62370
// exit ;
62368: GO 63106
// side := GetSide ( depot ) ;
62370: LD_ADDR_VAR 0 9
62374: PUSH
62375: LD_VAR 0 1
62379: PPUSH
62380: CALL_OW 255
62384: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62385: LD_VAR 0 9
62389: PPUSH
62390: LD_VAR 0 2
62394: PPUSH
62395: CALL 61883 0 2
62399: NOT
62400: IFFALSE 62404
// exit ;
62402: GO 63106
// pom := GetBase ( depot ) ;
62404: LD_ADDR_VAR 0 10
62408: PUSH
62409: LD_VAR 0 1
62413: PPUSH
62414: CALL_OW 274
62418: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62419: LD_ADDR_VAR 0 11
62423: PUSH
62424: LD_VAR 0 2
62428: PPUSH
62429: LD_VAR 0 1
62433: PPUSH
62434: CALL_OW 248
62438: PPUSH
62439: CALL_OW 450
62443: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62444: LD_VAR 0 10
62448: PPUSH
62449: LD_INT 1
62451: PPUSH
62452: CALL_OW 275
62456: PUSH
62457: LD_VAR 0 11
62461: PUSH
62462: LD_INT 1
62464: ARRAY
62465: GREATEREQUAL
62466: PUSH
62467: LD_VAR 0 10
62471: PPUSH
62472: LD_INT 2
62474: PPUSH
62475: CALL_OW 275
62479: PUSH
62480: LD_VAR 0 11
62484: PUSH
62485: LD_INT 2
62487: ARRAY
62488: GREATEREQUAL
62489: AND
62490: PUSH
62491: LD_VAR 0 10
62495: PPUSH
62496: LD_INT 3
62498: PPUSH
62499: CALL_OW 275
62503: PUSH
62504: LD_VAR 0 11
62508: PUSH
62509: LD_INT 3
62511: ARRAY
62512: GREATEREQUAL
62513: AND
62514: NOT
62515: IFFALSE 62519
// exit ;
62517: GO 63106
// if GetBType ( depot ) = b_depot then
62519: LD_VAR 0 1
62523: PPUSH
62524: CALL_OW 266
62528: PUSH
62529: LD_INT 0
62531: EQUAL
62532: IFFALSE 62544
// dist := 28 else
62534: LD_ADDR_VAR 0 14
62538: PUSH
62539: LD_INT 28
62541: ST_TO_ADDR
62542: GO 62552
// dist := 36 ;
62544: LD_ADDR_VAR 0 14
62548: PUSH
62549: LD_INT 36
62551: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62552: LD_VAR 0 1
62556: PPUSH
62557: LD_VAR 0 3
62561: PPUSH
62562: LD_VAR 0 4
62566: PPUSH
62567: CALL_OW 297
62571: PUSH
62572: LD_VAR 0 14
62576: GREATER
62577: IFFALSE 62581
// exit ;
62579: GO 63106
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62581: LD_ADDR_VAR 0 12
62585: PUSH
62586: LD_VAR 0 2
62590: PPUSH
62591: LD_VAR 0 3
62595: PPUSH
62596: LD_VAR 0 4
62600: PPUSH
62601: LD_VAR 0 5
62605: PPUSH
62606: LD_VAR 0 1
62610: PPUSH
62611: CALL_OW 248
62615: PPUSH
62616: LD_INT 0
62618: PPUSH
62619: CALL 63111 0 6
62623: ST_TO_ADDR
// if not hexes then
62624: LD_VAR 0 12
62628: NOT
62629: IFFALSE 62633
// exit ;
62631: GO 63106
// hex := GetHexInfo ( x , y ) ;
62633: LD_ADDR_VAR 0 15
62637: PUSH
62638: LD_VAR 0 3
62642: PPUSH
62643: LD_VAR 0 4
62647: PPUSH
62648: CALL_OW 546
62652: ST_TO_ADDR
// if hex [ 1 ] then
62653: LD_VAR 0 15
62657: PUSH
62658: LD_INT 1
62660: ARRAY
62661: IFFALSE 62665
// exit ;
62663: GO 63106
// height := hex [ 2 ] ;
62665: LD_ADDR_VAR 0 13
62669: PUSH
62670: LD_VAR 0 15
62674: PUSH
62675: LD_INT 2
62677: ARRAY
62678: ST_TO_ADDR
// for i = 1 to hexes do
62679: LD_ADDR_VAR 0 7
62683: PUSH
62684: DOUBLE
62685: LD_INT 1
62687: DEC
62688: ST_TO_ADDR
62689: LD_VAR 0 12
62693: PUSH
62694: FOR_TO
62695: IFFALSE 63025
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62697: LD_VAR 0 12
62701: PUSH
62702: LD_VAR 0 7
62706: ARRAY
62707: PUSH
62708: LD_INT 1
62710: ARRAY
62711: PPUSH
62712: LD_VAR 0 12
62716: PUSH
62717: LD_VAR 0 7
62721: ARRAY
62722: PUSH
62723: LD_INT 2
62725: ARRAY
62726: PPUSH
62727: CALL_OW 488
62731: NOT
62732: PUSH
62733: LD_VAR 0 12
62737: PUSH
62738: LD_VAR 0 7
62742: ARRAY
62743: PUSH
62744: LD_INT 1
62746: ARRAY
62747: PPUSH
62748: LD_VAR 0 12
62752: PUSH
62753: LD_VAR 0 7
62757: ARRAY
62758: PUSH
62759: LD_INT 2
62761: ARRAY
62762: PPUSH
62763: CALL_OW 428
62767: PUSH
62768: LD_INT 0
62770: GREATER
62771: OR
62772: PUSH
62773: LD_VAR 0 12
62777: PUSH
62778: LD_VAR 0 7
62782: ARRAY
62783: PUSH
62784: LD_INT 1
62786: ARRAY
62787: PPUSH
62788: LD_VAR 0 12
62792: PUSH
62793: LD_VAR 0 7
62797: ARRAY
62798: PUSH
62799: LD_INT 2
62801: ARRAY
62802: PPUSH
62803: CALL_OW 351
62807: OR
62808: IFFALSE 62814
// exit ;
62810: POP
62811: POP
62812: GO 63106
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62814: LD_ADDR_VAR 0 8
62818: PUSH
62819: LD_VAR 0 12
62823: PUSH
62824: LD_VAR 0 7
62828: ARRAY
62829: PUSH
62830: LD_INT 1
62832: ARRAY
62833: PPUSH
62834: LD_VAR 0 12
62838: PUSH
62839: LD_VAR 0 7
62843: ARRAY
62844: PUSH
62845: LD_INT 2
62847: ARRAY
62848: PPUSH
62849: CALL_OW 546
62853: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62854: LD_VAR 0 8
62858: PUSH
62859: LD_INT 1
62861: ARRAY
62862: PUSH
62863: LD_VAR 0 8
62867: PUSH
62868: LD_INT 2
62870: ARRAY
62871: PUSH
62872: LD_VAR 0 13
62876: PUSH
62877: LD_INT 2
62879: PLUS
62880: GREATER
62881: OR
62882: PUSH
62883: LD_VAR 0 8
62887: PUSH
62888: LD_INT 2
62890: ARRAY
62891: PUSH
62892: LD_VAR 0 13
62896: PUSH
62897: LD_INT 2
62899: MINUS
62900: LESS
62901: OR
62902: PUSH
62903: LD_VAR 0 8
62907: PUSH
62908: LD_INT 3
62910: ARRAY
62911: PUSH
62912: LD_INT 0
62914: PUSH
62915: LD_INT 8
62917: PUSH
62918: LD_INT 9
62920: PUSH
62921: LD_INT 10
62923: PUSH
62924: LD_INT 11
62926: PUSH
62927: LD_INT 12
62929: PUSH
62930: LD_INT 13
62932: PUSH
62933: LD_INT 16
62935: PUSH
62936: LD_INT 17
62938: PUSH
62939: LD_INT 18
62941: PUSH
62942: LD_INT 19
62944: PUSH
62945: LD_INT 20
62947: PUSH
62948: LD_INT 21
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: LIST
62955: LIST
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: LIST
62961: LIST
62962: LIST
62963: LIST
62964: LIST
62965: IN
62966: NOT
62967: OR
62968: PUSH
62969: LD_VAR 0 8
62973: PUSH
62974: LD_INT 5
62976: ARRAY
62977: NOT
62978: OR
62979: PUSH
62980: LD_VAR 0 8
62984: PUSH
62985: LD_INT 6
62987: ARRAY
62988: PUSH
62989: LD_INT 1
62991: PUSH
62992: LD_INT 2
62994: PUSH
62995: LD_INT 7
62997: PUSH
62998: LD_INT 9
63000: PUSH
63001: LD_INT 10
63003: PUSH
63004: LD_INT 11
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: IN
63015: NOT
63016: OR
63017: IFFALSE 63023
// exit ;
63019: POP
63020: POP
63021: GO 63106
// end ;
63023: GO 62694
63025: POP
63026: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63027: LD_VAR 0 9
63031: PPUSH
63032: LD_VAR 0 3
63036: PPUSH
63037: LD_VAR 0 4
63041: PPUSH
63042: LD_INT 20
63044: PPUSH
63045: CALL 55058 0 4
63049: PUSH
63050: LD_INT 4
63052: ARRAY
63053: IFFALSE 63057
// exit ;
63055: GO 63106
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63057: LD_VAR 0 2
63061: PUSH
63062: LD_INT 29
63064: PUSH
63065: LD_INT 30
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: IN
63072: PUSH
63073: LD_VAR 0 3
63077: PPUSH
63078: LD_VAR 0 4
63082: PPUSH
63083: LD_VAR 0 9
63087: PPUSH
63088: CALL_OW 440
63092: NOT
63093: AND
63094: IFFALSE 63098
// exit ;
63096: GO 63106
// result := true ;
63098: LD_ADDR_VAR 0 6
63102: PUSH
63103: LD_INT 1
63105: ST_TO_ADDR
// end ;
63106: LD_VAR 0 6
63110: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63111: LD_INT 0
63113: PPUSH
63114: PPUSH
63115: PPUSH
63116: PPUSH
63117: PPUSH
63118: PPUSH
63119: PPUSH
63120: PPUSH
63121: PPUSH
63122: PPUSH
63123: PPUSH
63124: PPUSH
63125: PPUSH
63126: PPUSH
63127: PPUSH
63128: PPUSH
63129: PPUSH
63130: PPUSH
63131: PPUSH
63132: PPUSH
63133: PPUSH
63134: PPUSH
63135: PPUSH
63136: PPUSH
63137: PPUSH
63138: PPUSH
63139: PPUSH
63140: PPUSH
63141: PPUSH
63142: PPUSH
63143: PPUSH
63144: PPUSH
63145: PPUSH
63146: PPUSH
63147: PPUSH
63148: PPUSH
63149: PPUSH
63150: PPUSH
63151: PPUSH
63152: PPUSH
63153: PPUSH
63154: PPUSH
63155: PPUSH
63156: PPUSH
63157: PPUSH
63158: PPUSH
63159: PPUSH
63160: PPUSH
63161: PPUSH
63162: PPUSH
63163: PPUSH
63164: PPUSH
63165: PPUSH
63166: PPUSH
63167: PPUSH
63168: PPUSH
63169: PPUSH
63170: PPUSH
// result = [ ] ;
63171: LD_ADDR_VAR 0 7
63175: PUSH
63176: EMPTY
63177: ST_TO_ADDR
// temp_list = [ ] ;
63178: LD_ADDR_VAR 0 9
63182: PUSH
63183: EMPTY
63184: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63185: LD_VAR 0 4
63189: PUSH
63190: LD_INT 0
63192: PUSH
63193: LD_INT 1
63195: PUSH
63196: LD_INT 2
63198: PUSH
63199: LD_INT 3
63201: PUSH
63202: LD_INT 4
63204: PUSH
63205: LD_INT 5
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: IN
63216: NOT
63217: PUSH
63218: LD_VAR 0 1
63222: PUSH
63223: LD_INT 0
63225: PUSH
63226: LD_INT 1
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: IN
63233: PUSH
63234: LD_VAR 0 5
63238: PUSH
63239: LD_INT 1
63241: PUSH
63242: LD_INT 2
63244: PUSH
63245: LD_INT 3
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: LIST
63252: IN
63253: NOT
63254: AND
63255: OR
63256: IFFALSE 63260
// exit ;
63258: GO 81651
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63260: LD_VAR 0 1
63264: PUSH
63265: LD_INT 6
63267: PUSH
63268: LD_INT 7
63270: PUSH
63271: LD_INT 8
63273: PUSH
63274: LD_INT 13
63276: PUSH
63277: LD_INT 12
63279: PUSH
63280: LD_INT 15
63282: PUSH
63283: LD_INT 11
63285: PUSH
63286: LD_INT 14
63288: PUSH
63289: LD_INT 10
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: LIST
63300: LIST
63301: LIST
63302: IN
63303: IFFALSE 63313
// btype = b_lab ;
63305: LD_ADDR_VAR 0 1
63309: PUSH
63310: LD_INT 6
63312: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63313: LD_VAR 0 6
63317: PUSH
63318: LD_INT 0
63320: PUSH
63321: LD_INT 1
63323: PUSH
63324: LD_INT 2
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: LIST
63331: IN
63332: NOT
63333: PUSH
63334: LD_VAR 0 1
63338: PUSH
63339: LD_INT 0
63341: PUSH
63342: LD_INT 1
63344: PUSH
63345: LD_INT 2
63347: PUSH
63348: LD_INT 3
63350: PUSH
63351: LD_INT 6
63353: PUSH
63354: LD_INT 36
63356: PUSH
63357: LD_INT 4
63359: PUSH
63360: LD_INT 5
63362: PUSH
63363: LD_INT 31
63365: PUSH
63366: LD_INT 32
63368: PUSH
63369: LD_INT 33
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: LIST
63376: LIST
63377: LIST
63378: LIST
63379: LIST
63380: LIST
63381: LIST
63382: LIST
63383: LIST
63384: IN
63385: NOT
63386: PUSH
63387: LD_VAR 0 6
63391: PUSH
63392: LD_INT 1
63394: EQUAL
63395: AND
63396: OR
63397: PUSH
63398: LD_VAR 0 1
63402: PUSH
63403: LD_INT 2
63405: PUSH
63406: LD_INT 3
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: IN
63413: NOT
63414: PUSH
63415: LD_VAR 0 6
63419: PUSH
63420: LD_INT 2
63422: EQUAL
63423: AND
63424: OR
63425: IFFALSE 63435
// mode = 0 ;
63427: LD_ADDR_VAR 0 6
63431: PUSH
63432: LD_INT 0
63434: ST_TO_ADDR
// case mode of 0 :
63435: LD_VAR 0 6
63439: PUSH
63440: LD_INT 0
63442: DOUBLE
63443: EQUAL
63444: IFTRUE 63448
63446: GO 74901
63448: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63449: LD_ADDR_VAR 0 11
63453: PUSH
63454: LD_INT 0
63456: PUSH
63457: LD_INT 0
63459: PUSH
63460: EMPTY
63461: LIST
63462: LIST
63463: PUSH
63464: LD_INT 0
63466: PUSH
63467: LD_INT 1
63469: NEG
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: PUSH
63475: LD_INT 1
63477: PUSH
63478: LD_INT 0
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: LD_INT 1
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: PUSH
63495: LD_INT 0
63497: PUSH
63498: LD_INT 1
63500: PUSH
63501: EMPTY
63502: LIST
63503: LIST
63504: PUSH
63505: LD_INT 1
63507: NEG
63508: PUSH
63509: LD_INT 0
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PUSH
63516: LD_INT 1
63518: NEG
63519: PUSH
63520: LD_INT 1
63522: NEG
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PUSH
63528: LD_INT 1
63530: NEG
63531: PUSH
63532: LD_INT 2
63534: NEG
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: PUSH
63540: LD_INT 0
63542: PUSH
63543: LD_INT 2
63545: NEG
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: PUSH
63551: LD_INT 1
63553: PUSH
63554: LD_INT 1
63556: NEG
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: LD_INT 1
63564: PUSH
63565: LD_INT 2
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PUSH
63572: LD_INT 0
63574: PUSH
63575: LD_INT 2
63577: PUSH
63578: EMPTY
63579: LIST
63580: LIST
63581: PUSH
63582: LD_INT 1
63584: NEG
63585: PUSH
63586: LD_INT 1
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PUSH
63593: LD_INT 1
63595: PUSH
63596: LD_INT 3
63598: PUSH
63599: EMPTY
63600: LIST
63601: LIST
63602: PUSH
63603: LD_INT 0
63605: PUSH
63606: LD_INT 3
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 1
63615: NEG
63616: PUSH
63617: LD_INT 2
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63642: LD_ADDR_VAR 0 12
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: LD_INT 0
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PUSH
63657: LD_INT 0
63659: PUSH
63660: LD_INT 1
63662: NEG
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 1
63670: PUSH
63671: LD_INT 0
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 1
63680: PUSH
63681: LD_INT 1
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: PUSH
63688: LD_INT 0
63690: PUSH
63691: LD_INT 1
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 1
63700: NEG
63701: PUSH
63702: LD_INT 0
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: PUSH
63709: LD_INT 1
63711: NEG
63712: PUSH
63713: LD_INT 1
63715: NEG
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: LD_INT 1
63726: NEG
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 2
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 2
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PUSH
63752: LD_INT 1
63754: NEG
63755: PUSH
63756: LD_INT 1
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 2
63765: NEG
63766: PUSH
63767: LD_INT 0
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 2
63776: NEG
63777: PUSH
63778: LD_INT 1
63780: NEG
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PUSH
63786: LD_INT 2
63788: NEG
63789: PUSH
63790: LD_INT 1
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 3
63799: NEG
63800: PUSH
63801: LD_INT 0
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 3
63810: NEG
63811: PUSH
63812: LD_INT 1
63814: NEG
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: PUSH
63820: EMPTY
63821: LIST
63822: LIST
63823: LIST
63824: LIST
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: LIST
63835: LIST
63836: LIST
63837: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63838: LD_ADDR_VAR 0 13
63842: PUSH
63843: LD_INT 0
63845: PUSH
63846: LD_INT 0
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 0
63855: PUSH
63856: LD_INT 1
63858: NEG
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: LD_INT 1
63866: PUSH
63867: LD_INT 0
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 1
63876: PUSH
63877: LD_INT 1
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 0
63886: PUSH
63887: LD_INT 1
63889: PUSH
63890: EMPTY
63891: LIST
63892: LIST
63893: PUSH
63894: LD_INT 1
63896: NEG
63897: PUSH
63898: LD_INT 0
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 1
63907: NEG
63908: PUSH
63909: LD_INT 1
63911: NEG
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 1
63919: NEG
63920: PUSH
63921: LD_INT 2
63923: NEG
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 2
63931: PUSH
63932: LD_INT 1
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 2
63941: PUSH
63942: LD_INT 2
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: PUSH
63949: LD_INT 1
63951: PUSH
63952: LD_INT 2
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: LD_INT 2
63961: NEG
63962: PUSH
63963: LD_INT 1
63965: NEG
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PUSH
63971: LD_INT 2
63973: NEG
63974: PUSH
63975: LD_INT 2
63977: NEG
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 2
63985: NEG
63986: PUSH
63987: LD_INT 3
63989: NEG
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: PUSH
63995: LD_INT 3
63997: NEG
63998: PUSH
63999: LD_INT 2
64001: NEG
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 3
64009: NEG
64010: PUSH
64011: LD_INT 3
64013: NEG
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: LIST
64027: LIST
64028: LIST
64029: LIST
64030: LIST
64031: LIST
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64037: LD_ADDR_VAR 0 14
64041: PUSH
64042: LD_INT 0
64044: PUSH
64045: LD_INT 0
64047: PUSH
64048: EMPTY
64049: LIST
64050: LIST
64051: PUSH
64052: LD_INT 0
64054: PUSH
64055: LD_INT 1
64057: NEG
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PUSH
64063: LD_INT 1
64065: PUSH
64066: LD_INT 0
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 1
64075: PUSH
64076: LD_INT 1
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PUSH
64083: LD_INT 0
64085: PUSH
64086: LD_INT 1
64088: PUSH
64089: EMPTY
64090: LIST
64091: LIST
64092: PUSH
64093: LD_INT 1
64095: NEG
64096: PUSH
64097: LD_INT 0
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 1
64106: NEG
64107: PUSH
64108: LD_INT 1
64110: NEG
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PUSH
64116: LD_INT 1
64118: NEG
64119: PUSH
64120: LD_INT 2
64122: NEG
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 0
64130: PUSH
64131: LD_INT 2
64133: NEG
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: PUSH
64139: LD_INT 1
64141: PUSH
64142: LD_INT 1
64144: NEG
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 1
64152: PUSH
64153: LD_INT 2
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 0
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 1
64172: NEG
64173: PUSH
64174: LD_INT 1
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 1
64183: NEG
64184: PUSH
64185: LD_INT 3
64187: NEG
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 0
64195: PUSH
64196: LD_INT 3
64198: NEG
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PUSH
64204: LD_INT 1
64206: PUSH
64207: LD_INT 2
64209: NEG
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64233: LD_ADDR_VAR 0 15
64237: PUSH
64238: LD_INT 0
64240: PUSH
64241: LD_INT 0
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 0
64250: PUSH
64251: LD_INT 1
64253: NEG
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: PUSH
64259: LD_INT 1
64261: PUSH
64262: LD_INT 0
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: PUSH
64269: LD_INT 1
64271: PUSH
64272: LD_INT 1
64274: PUSH
64275: EMPTY
64276: LIST
64277: LIST
64278: PUSH
64279: LD_INT 0
64281: PUSH
64282: LD_INT 1
64284: PUSH
64285: EMPTY
64286: LIST
64287: LIST
64288: PUSH
64289: LD_INT 1
64291: NEG
64292: PUSH
64293: LD_INT 0
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: PUSH
64300: LD_INT 1
64302: NEG
64303: PUSH
64304: LD_INT 1
64306: NEG
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PUSH
64312: LD_INT 1
64314: PUSH
64315: LD_INT 1
64317: NEG
64318: PUSH
64319: EMPTY
64320: LIST
64321: LIST
64322: PUSH
64323: LD_INT 2
64325: PUSH
64326: LD_INT 0
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PUSH
64333: LD_INT 2
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: EMPTY
64340: LIST
64341: LIST
64342: PUSH
64343: LD_INT 1
64345: NEG
64346: PUSH
64347: LD_INT 1
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PUSH
64354: LD_INT 2
64356: NEG
64357: PUSH
64358: LD_INT 0
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 2
64367: NEG
64368: PUSH
64369: LD_INT 1
64371: NEG
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 2
64379: PUSH
64380: LD_INT 1
64382: NEG
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 3
64390: PUSH
64391: LD_INT 0
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: LD_INT 3
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: LIST
64419: LIST
64420: LIST
64421: LIST
64422: LIST
64423: LIST
64424: LIST
64425: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64426: LD_ADDR_VAR 0 16
64430: PUSH
64431: LD_INT 0
64433: PUSH
64434: LD_INT 0
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 0
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: LD_INT 1
64454: PUSH
64455: LD_INT 0
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 1
64464: PUSH
64465: LD_INT 1
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PUSH
64472: LD_INT 0
64474: PUSH
64475: LD_INT 1
64477: PUSH
64478: EMPTY
64479: LIST
64480: LIST
64481: PUSH
64482: LD_INT 1
64484: NEG
64485: PUSH
64486: LD_INT 0
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PUSH
64493: LD_INT 1
64495: NEG
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 1
64507: NEG
64508: PUSH
64509: LD_INT 2
64511: NEG
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 2
64519: PUSH
64520: LD_INT 1
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 2
64529: PUSH
64530: LD_INT 2
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 1
64539: PUSH
64540: LD_INT 2
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: LD_INT 2
64549: NEG
64550: PUSH
64551: LD_INT 1
64553: NEG
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 2
64561: NEG
64562: PUSH
64563: LD_INT 2
64565: NEG
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 3
64573: PUSH
64574: LD_INT 2
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 3
64583: PUSH
64584: LD_INT 3
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: PUSH
64591: LD_INT 2
64593: PUSH
64594: LD_INT 3
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64619: LD_ADDR_VAR 0 17
64623: PUSH
64624: LD_INT 0
64626: PUSH
64627: LD_INT 0
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 0
64636: PUSH
64637: LD_INT 1
64639: NEG
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 1
64647: PUSH
64648: LD_INT 0
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: LD_INT 1
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: LD_INT 0
64667: PUSH
64668: LD_INT 1
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: PUSH
64675: LD_INT 1
64677: NEG
64678: PUSH
64679: LD_INT 0
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 1
64688: NEG
64689: PUSH
64690: LD_INT 1
64692: NEG
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: PUSH
64698: LD_INT 1
64700: NEG
64701: PUSH
64702: LD_INT 2
64704: NEG
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: LD_INT 0
64712: PUSH
64713: LD_INT 2
64715: NEG
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 1
64723: PUSH
64724: LD_INT 1
64726: NEG
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 2
64734: PUSH
64735: LD_INT 0
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: LD_INT 2
64744: PUSH
64745: LD_INT 1
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 2
64754: PUSH
64755: LD_INT 2
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: LD_INT 1
64764: PUSH
64765: LD_INT 2
64767: PUSH
64768: EMPTY
64769: LIST
64770: LIST
64771: PUSH
64772: LD_INT 0
64774: PUSH
64775: LD_INT 2
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 1
64784: NEG
64785: PUSH
64786: LD_INT 1
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 2
64795: NEG
64796: PUSH
64797: LD_INT 0
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: LD_INT 2
64806: NEG
64807: PUSH
64808: LD_INT 1
64810: NEG
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 2
64818: NEG
64819: PUSH
64820: LD_INT 2
64822: NEG
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: LIST
64832: LIST
64833: LIST
64834: LIST
64835: LIST
64836: LIST
64837: LIST
64838: LIST
64839: LIST
64840: LIST
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: LIST
64848: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64849: LD_ADDR_VAR 0 18
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 0
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_INT 0
64866: PUSH
64867: LD_INT 1
64869: NEG
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PUSH
64875: LD_INT 1
64877: PUSH
64878: LD_INT 0
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: LD_INT 1
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 0
64897: PUSH
64898: LD_INT 1
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: LD_INT 1
64907: NEG
64908: PUSH
64909: LD_INT 0
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 1
64918: NEG
64919: PUSH
64920: LD_INT 1
64922: NEG
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: LD_INT 1
64930: NEG
64931: PUSH
64932: LD_INT 2
64934: NEG
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PUSH
64940: LD_INT 0
64942: PUSH
64943: LD_INT 2
64945: NEG
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 2
64964: PUSH
64965: LD_INT 0
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 2
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: PUSH
64982: LD_INT 2
64984: PUSH
64985: LD_INT 2
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 1
64994: PUSH
64995: LD_INT 2
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: LD_INT 0
65004: PUSH
65005: LD_INT 2
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PUSH
65012: LD_INT 1
65014: NEG
65015: PUSH
65016: LD_INT 1
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 2
65025: NEG
65026: PUSH
65027: LD_INT 0
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 2
65036: NEG
65037: PUSH
65038: LD_INT 1
65040: NEG
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 2
65048: NEG
65049: PUSH
65050: LD_INT 2
65052: NEG
65053: PUSH
65054: EMPTY
65055: LIST
65056: LIST
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: LIST
65062: LIST
65063: LIST
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: LIST
65075: LIST
65076: LIST
65077: LIST
65078: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65079: LD_ADDR_VAR 0 19
65083: PUSH
65084: LD_INT 0
65086: PUSH
65087: LD_INT 0
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PUSH
65094: LD_INT 0
65096: PUSH
65097: LD_INT 1
65099: NEG
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: LD_INT 1
65107: PUSH
65108: LD_INT 0
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: LD_INT 1
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PUSH
65125: LD_INT 0
65127: PUSH
65128: LD_INT 1
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 1
65137: NEG
65138: PUSH
65139: LD_INT 0
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 1
65148: NEG
65149: PUSH
65150: LD_INT 1
65152: NEG
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PUSH
65158: LD_INT 1
65160: NEG
65161: PUSH
65162: LD_INT 2
65164: NEG
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PUSH
65170: LD_INT 0
65172: PUSH
65173: LD_INT 2
65175: NEG
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 1
65183: PUSH
65184: LD_INT 1
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 2
65194: PUSH
65195: LD_INT 0
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 2
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 2
65214: PUSH
65215: LD_INT 2
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 1
65224: PUSH
65225: LD_INT 2
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: LD_INT 0
65234: PUSH
65235: LD_INT 2
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PUSH
65242: LD_INT 1
65244: NEG
65245: PUSH
65246: LD_INT 1
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 2
65255: NEG
65256: PUSH
65257: LD_INT 0
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 2
65266: NEG
65267: PUSH
65268: LD_INT 1
65270: NEG
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 2
65278: NEG
65279: PUSH
65280: LD_INT 2
65282: NEG
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: LIST
65306: LIST
65307: LIST
65308: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65309: LD_ADDR_VAR 0 20
65313: PUSH
65314: LD_INT 0
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 0
65326: PUSH
65327: LD_INT 1
65329: NEG
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PUSH
65335: LD_INT 1
65337: PUSH
65338: LD_INT 0
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: LD_INT 1
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: LD_INT 0
65357: PUSH
65358: LD_INT 1
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 1
65367: NEG
65368: PUSH
65369: LD_INT 0
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 1
65378: NEG
65379: PUSH
65380: LD_INT 1
65382: NEG
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: LD_INT 1
65390: NEG
65391: PUSH
65392: LD_INT 2
65394: NEG
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: LD_INT 2
65405: NEG
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 1
65413: PUSH
65414: LD_INT 1
65416: NEG
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 2
65424: PUSH
65425: LD_INT 0
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 2
65434: PUSH
65435: LD_INT 1
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PUSH
65442: LD_INT 2
65444: PUSH
65445: LD_INT 2
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 1
65454: PUSH
65455: LD_INT 2
65457: PUSH
65458: EMPTY
65459: LIST
65460: LIST
65461: PUSH
65462: LD_INT 0
65464: PUSH
65465: LD_INT 2
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 1
65474: NEG
65475: PUSH
65476: LD_INT 1
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 2
65485: NEG
65486: PUSH
65487: LD_INT 0
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 2
65496: NEG
65497: PUSH
65498: LD_INT 1
65500: NEG
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 2
65508: NEG
65509: PUSH
65510: LD_INT 2
65512: NEG
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65539: LD_ADDR_VAR 0 21
65543: PUSH
65544: LD_INT 0
65546: PUSH
65547: LD_INT 0
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: LD_INT 0
65556: PUSH
65557: LD_INT 1
65559: NEG
65560: PUSH
65561: EMPTY
65562: LIST
65563: LIST
65564: PUSH
65565: LD_INT 1
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: LD_INT 1
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: LD_INT 0
65587: PUSH
65588: LD_INT 1
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 1
65597: NEG
65598: PUSH
65599: LD_INT 0
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 1
65608: NEG
65609: PUSH
65610: LD_INT 1
65612: NEG
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 1
65620: NEG
65621: PUSH
65622: LD_INT 2
65624: NEG
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 0
65632: PUSH
65633: LD_INT 2
65635: NEG
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 1
65643: PUSH
65644: LD_INT 1
65646: NEG
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 2
65654: PUSH
65655: LD_INT 0
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 2
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: LD_INT 2
65674: PUSH
65675: LD_INT 2
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 1
65684: PUSH
65685: LD_INT 2
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 0
65694: PUSH
65695: LD_INT 2
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 1
65704: NEG
65705: PUSH
65706: LD_INT 1
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 2
65715: NEG
65716: PUSH
65717: LD_INT 0
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 2
65726: NEG
65727: PUSH
65728: LD_INT 1
65730: NEG
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 2
65738: NEG
65739: PUSH
65740: LD_INT 2
65742: NEG
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: LIST
65763: LIST
65764: LIST
65765: LIST
65766: LIST
65767: LIST
65768: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65769: LD_ADDR_VAR 0 22
65773: PUSH
65774: LD_INT 0
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: LD_INT 0
65786: PUSH
65787: LD_INT 1
65789: NEG
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: LD_INT 1
65797: PUSH
65798: LD_INT 0
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 1
65807: PUSH
65808: LD_INT 1
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 0
65817: PUSH
65818: LD_INT 1
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 1
65827: NEG
65828: PUSH
65829: LD_INT 0
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 1
65838: NEG
65839: PUSH
65840: LD_INT 1
65842: NEG
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 1
65850: NEG
65851: PUSH
65852: LD_INT 2
65854: NEG
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 0
65862: PUSH
65863: LD_INT 2
65865: NEG
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 1
65873: PUSH
65874: LD_INT 1
65876: NEG
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 2
65884: PUSH
65885: LD_INT 0
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 2
65894: PUSH
65895: LD_INT 1
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: PUSH
65902: LD_INT 2
65904: PUSH
65905: LD_INT 2
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 1
65914: PUSH
65915: LD_INT 2
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 0
65924: PUSH
65925: LD_INT 2
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 1
65934: NEG
65935: PUSH
65936: LD_INT 1
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 2
65945: NEG
65946: PUSH
65947: LD_INT 0
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 2
65956: NEG
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: PUSH
65966: LD_INT 2
65968: NEG
65969: PUSH
65970: LD_INT 2
65972: NEG
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65999: LD_ADDR_VAR 0 23
66003: PUSH
66004: LD_INT 0
66006: PUSH
66007: LD_INT 0
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 0
66016: PUSH
66017: LD_INT 1
66019: NEG
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 1
66027: PUSH
66028: LD_INT 0
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: LD_INT 1
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: LD_INT 0
66047: PUSH
66048: LD_INT 1
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 1
66057: NEG
66058: PUSH
66059: LD_INT 0
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 1
66068: NEG
66069: PUSH
66070: LD_INT 1
66072: NEG
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PUSH
66078: LD_INT 1
66080: NEG
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PUSH
66090: LD_INT 0
66092: PUSH
66093: LD_INT 2
66095: NEG
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 1
66103: PUSH
66104: LD_INT 1
66106: NEG
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 2
66114: PUSH
66115: LD_INT 0
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 2
66124: PUSH
66125: LD_INT 1
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 2
66134: PUSH
66135: LD_INT 2
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 1
66144: PUSH
66145: LD_INT 2
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 0
66154: PUSH
66155: LD_INT 2
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 1
66164: NEG
66165: PUSH
66166: LD_INT 1
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 2
66175: NEG
66176: PUSH
66177: LD_INT 0
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 2
66186: NEG
66187: PUSH
66188: LD_INT 1
66190: NEG
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 2
66198: NEG
66199: PUSH
66200: LD_INT 2
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 2
66210: NEG
66211: PUSH
66212: LD_INT 3
66214: NEG
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 1
66222: NEG
66223: PUSH
66224: LD_INT 3
66226: NEG
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 1
66234: PUSH
66235: LD_INT 2
66237: NEG
66238: PUSH
66239: EMPTY
66240: LIST
66241: LIST
66242: PUSH
66243: LD_INT 2
66245: PUSH
66246: LD_INT 1
66248: NEG
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66279: LD_ADDR_VAR 0 24
66283: PUSH
66284: LD_INT 0
66286: PUSH
66287: LD_INT 0
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: LD_INT 0
66296: PUSH
66297: LD_INT 1
66299: NEG
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 1
66307: PUSH
66308: LD_INT 0
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: LD_INT 1
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: LD_INT 1
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 1
66337: NEG
66338: PUSH
66339: LD_INT 0
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 1
66348: NEG
66349: PUSH
66350: LD_INT 1
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 1
66360: NEG
66361: PUSH
66362: LD_INT 2
66364: NEG
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: LD_INT 2
66375: NEG
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 2
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 2
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 2
66414: PUSH
66415: LD_INT 2
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: PUSH
66425: LD_INT 2
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 0
66434: PUSH
66435: LD_INT 2
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 1
66444: NEG
66445: PUSH
66446: LD_INT 1
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 2
66455: NEG
66456: PUSH
66457: LD_INT 0
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 2
66466: NEG
66467: PUSH
66468: LD_INT 1
66470: NEG
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 2
66478: NEG
66479: PUSH
66480: LD_INT 2
66482: NEG
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 2
66493: NEG
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 2
66501: PUSH
66502: LD_INT 1
66504: NEG
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 3
66512: PUSH
66513: LD_INT 1
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 3
66522: PUSH
66523: LD_INT 2
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66555: LD_ADDR_VAR 0 25
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 0
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 0
66572: PUSH
66573: LD_INT 1
66575: NEG
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: LD_INT 0
66603: PUSH
66604: LD_INT 1
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 1
66613: NEG
66614: PUSH
66615: LD_INT 0
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: LD_INT 1
66628: NEG
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 0
66648: PUSH
66649: LD_INT 2
66651: NEG
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: LD_INT 1
66662: NEG
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: LD_INT 0
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 2
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 2
66690: PUSH
66691: LD_INT 2
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 1
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 0
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 1
66720: NEG
66721: PUSH
66722: LD_INT 1
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 2
66731: NEG
66732: PUSH
66733: LD_INT 0
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 2
66742: NEG
66743: PUSH
66744: LD_INT 1
66746: NEG
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 2
66754: NEG
66755: PUSH
66756: LD_INT 2
66758: NEG
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 3
66766: PUSH
66767: LD_INT 1
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 3
66776: PUSH
66777: LD_INT 2
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 2
66786: PUSH
66787: LD_INT 3
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 1
66796: PUSH
66797: LD_INT 3
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66829: LD_ADDR_VAR 0 26
66833: PUSH
66834: LD_INT 0
66836: PUSH
66837: LD_INT 0
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 0
66846: PUSH
66847: LD_INT 1
66849: NEG
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 1
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 1
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 0
66877: PUSH
66878: LD_INT 1
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 1
66887: NEG
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 1
66898: NEG
66899: PUSH
66900: LD_INT 1
66902: NEG
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: LD_INT 1
66910: NEG
66911: PUSH
66912: LD_INT 2
66914: NEG
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 0
66922: PUSH
66923: LD_INT 2
66925: NEG
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 1
66933: PUSH
66934: LD_INT 1
66936: NEG
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 2
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 2
66954: PUSH
66955: LD_INT 1
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 2
66964: PUSH
66965: LD_INT 2
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: PUSH
66975: LD_INT 2
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 0
66984: PUSH
66985: LD_INT 2
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: NEG
66995: PUSH
66996: LD_INT 1
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 2
67005: NEG
67006: PUSH
67007: LD_INT 0
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 2
67016: NEG
67017: PUSH
67018: LD_INT 1
67020: NEG
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 2
67028: NEG
67029: PUSH
67030: LD_INT 2
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 2
67040: PUSH
67041: LD_INT 3
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: LD_INT 1
67050: PUSH
67051: LD_INT 3
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 1
67060: NEG
67061: PUSH
67062: LD_INT 2
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 2
67071: NEG
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67105: LD_ADDR_VAR 0 27
67109: PUSH
67110: LD_INT 0
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 0
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: PUSH
67134: LD_INT 0
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: LD_INT 1
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 0
67153: PUSH
67154: LD_INT 1
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 1
67163: NEG
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 1
67174: NEG
67175: PUSH
67176: LD_INT 1
67178: NEG
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 1
67186: NEG
67187: PUSH
67188: LD_INT 2
67190: NEG
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: LD_INT 0
67198: PUSH
67199: LD_INT 2
67201: NEG
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 1
67209: PUSH
67210: LD_INT 1
67212: NEG
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 2
67220: PUSH
67221: LD_INT 0
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 2
67230: PUSH
67231: LD_INT 1
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: PUSH
67238: LD_INT 2
67240: PUSH
67241: LD_INT 2
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PUSH
67248: LD_INT 1
67250: PUSH
67251: LD_INT 2
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: LD_INT 2
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 1
67270: NEG
67271: PUSH
67272: LD_INT 1
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: LD_INT 2
67281: NEG
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 2
67292: NEG
67293: PUSH
67294: LD_INT 1
67296: NEG
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PUSH
67302: LD_INT 2
67304: NEG
67305: PUSH
67306: LD_INT 2
67308: NEG
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: LD_INT 1
67316: NEG
67317: PUSH
67318: LD_INT 2
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: PUSH
67325: LD_INT 2
67327: NEG
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 3
67338: NEG
67339: PUSH
67340: LD_INT 1
67342: NEG
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 3
67350: NEG
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67385: LD_ADDR_VAR 0 28
67389: PUSH
67390: LD_INT 0
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 0
67402: PUSH
67403: LD_INT 1
67405: NEG
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 1
67413: PUSH
67414: LD_INT 0
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: PUSH
67424: LD_INT 1
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 0
67433: PUSH
67434: LD_INT 1
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: PUSH
67441: LD_INT 1
67443: NEG
67444: PUSH
67445: LD_INT 0
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 1
67454: NEG
67455: PUSH
67456: LD_INT 1
67458: NEG
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 1
67466: NEG
67467: PUSH
67468: LD_INT 2
67470: NEG
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 0
67478: PUSH
67479: LD_INT 2
67481: NEG
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 1
67489: PUSH
67490: LD_INT 1
67492: NEG
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 2
67500: PUSH
67501: LD_INT 0
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 2
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 2
67520: PUSH
67521: LD_INT 2
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 1
67530: PUSH
67531: LD_INT 2
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 0
67540: PUSH
67541: LD_INT 2
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 1
67550: NEG
67551: PUSH
67552: LD_INT 1
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 2
67561: NEG
67562: PUSH
67563: LD_INT 0
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 2
67572: NEG
67573: PUSH
67574: LD_INT 1
67576: NEG
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: LD_INT 2
67588: NEG
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 2
67596: NEG
67597: PUSH
67598: LD_INT 3
67600: NEG
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 1
67608: NEG
67609: PUSH
67610: LD_INT 3
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 3
67620: NEG
67621: PUSH
67622: LD_INT 1
67624: NEG
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 3
67632: NEG
67633: PUSH
67634: LD_INT 2
67636: NEG
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67667: LD_ADDR_VAR 0 29
67671: PUSH
67672: LD_INT 0
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: LD_INT 1
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: LD_INT 1
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 0
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: LD_INT 1
67740: NEG
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: NEG
67749: PUSH
67750: LD_INT 2
67752: NEG
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 0
67760: PUSH
67761: LD_INT 2
67763: NEG
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 1
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 2
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 2
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: PUSH
67800: LD_INT 1
67802: PUSH
67803: LD_INT 2
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 0
67812: PUSH
67813: LD_INT 2
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 1
67822: NEG
67823: PUSH
67824: LD_INT 1
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 2
67833: NEG
67834: PUSH
67835: LD_INT 1
67837: NEG
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 2
67845: NEG
67846: PUSH
67847: LD_INT 2
67849: NEG
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 2
67857: NEG
67858: PUSH
67859: LD_INT 3
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 2
67869: PUSH
67870: LD_INT 1
67872: NEG
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 3
67880: PUSH
67881: LD_INT 1
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 1
67890: PUSH
67891: LD_INT 3
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 1
67900: NEG
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: LD_INT 3
67911: NEG
67912: PUSH
67913: LD_INT 2
67915: NEG
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67946: LD_ADDR_VAR 0 30
67950: PUSH
67951: LD_INT 0
67953: PUSH
67954: LD_INT 0
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 1
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: PUSH
67985: LD_INT 1
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 0
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: NEG
68005: PUSH
68006: LD_INT 0
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: LD_INT 2
68031: NEG
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 0
68039: PUSH
68040: LD_INT 2
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: PUSH
68051: LD_INT 1
68053: NEG
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 2
68061: PUSH
68062: LD_INT 0
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 2
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 2
68081: PUSH
68082: LD_INT 2
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 1
68091: PUSH
68092: LD_INT 2
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PUSH
68099: LD_INT 1
68101: NEG
68102: PUSH
68103: LD_INT 1
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 2
68112: NEG
68113: PUSH
68114: LD_INT 0
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 2
68123: NEG
68124: PUSH
68125: LD_INT 1
68127: NEG
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 1
68135: NEG
68136: PUSH
68137: LD_INT 3
68139: NEG
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 1
68147: PUSH
68148: LD_INT 2
68150: NEG
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 3
68158: PUSH
68159: LD_INT 2
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 2
68168: PUSH
68169: LD_INT 3
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 2
68178: NEG
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 3
68189: NEG
68190: PUSH
68191: LD_INT 1
68193: NEG
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68224: LD_ADDR_VAR 0 31
68228: PUSH
68229: LD_INT 0
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 0
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 1
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 0
68272: PUSH
68273: LD_INT 1
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 1
68282: NEG
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 1
68293: NEG
68294: PUSH
68295: LD_INT 1
68297: NEG
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 1
68305: NEG
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 1
68317: PUSH
68318: LD_INT 1
68320: NEG
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 2
68328: PUSH
68329: LD_INT 0
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 2
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 2
68348: PUSH
68349: LD_INT 2
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: LD_INT 2
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 0
68368: PUSH
68369: LD_INT 2
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: NEG
68379: PUSH
68380: LD_INT 1
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PUSH
68387: LD_INT 2
68389: NEG
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 2
68401: NEG
68402: PUSH
68403: LD_INT 2
68405: NEG
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: LD_INT 3
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: LD_INT 1
68428: NEG
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 3
68436: PUSH
68437: LD_INT 1
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: LD_INT 3
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 1
68456: NEG
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 3
68467: NEG
68468: PUSH
68469: LD_INT 2
68471: NEG
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68502: LD_ADDR_VAR 0 32
68506: PUSH
68507: LD_INT 0
68509: PUSH
68510: LD_INT 0
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: LD_INT 1
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 1
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 1
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: LD_INT 1
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: LD_INT 0
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: NEG
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 1
68583: NEG
68584: PUSH
68585: LD_INT 2
68587: NEG
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 0
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 1
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 2
68617: PUSH
68618: LD_INT 1
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 2
68627: PUSH
68628: LD_INT 2
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 0
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: LD_INT 0
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 2
68679: NEG
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 1
68691: NEG
68692: PUSH
68693: LD_INT 3
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 1
68703: PUSH
68704: LD_INT 2
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 3
68714: PUSH
68715: LD_INT 2
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 2
68724: PUSH
68725: LD_INT 3
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 2
68734: NEG
68735: PUSH
68736: LD_INT 1
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 3
68745: NEG
68746: PUSH
68747: LD_INT 1
68749: NEG
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68780: LD_ADDR_VAR 0 33
68784: PUSH
68785: LD_INT 0
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 0
68797: PUSH
68798: LD_INT 1
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 1
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 0
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 1
68838: NEG
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 1
68849: NEG
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 1
68861: NEG
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 2
68884: PUSH
68885: LD_INT 0
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 2
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 2
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: LD_INT 2
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 2
68935: NEG
68936: PUSH
68937: LD_INT 0
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 2
68946: NEG
68947: PUSH
68948: LD_INT 1
68950: NEG
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 2
68958: NEG
68959: PUSH
68960: LD_INT 2
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 3
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: PUSH
68983: LD_INT 1
68985: NEG
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 3
68993: PUSH
68994: LD_INT 1
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: LD_INT 1
69003: PUSH
69004: LD_INT 3
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: PUSH
69011: LD_INT 1
69013: NEG
69014: PUSH
69015: LD_INT 2
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 3
69024: NEG
69025: PUSH
69026: LD_INT 2
69028: NEG
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69059: LD_ADDR_VAR 0 34
69063: PUSH
69064: LD_INT 0
69066: PUSH
69067: LD_INT 0
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: LD_INT 1
69079: NEG
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 1
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 0
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: NEG
69118: PUSH
69119: LD_INT 0
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 1
69128: NEG
69129: PUSH
69130: LD_INT 1
69132: NEG
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: LD_INT 2
69144: NEG
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 2
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 1
69166: NEG
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: LD_INT 1
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 2
69184: PUSH
69185: LD_INT 2
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 1
69194: PUSH
69195: LD_INT 2
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 1
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 2
69215: NEG
69216: PUSH
69217: LD_INT 0
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 2
69226: NEG
69227: PUSH
69228: LD_INT 1
69230: NEG
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 2
69238: NEG
69239: PUSH
69240: LD_INT 2
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 1
69250: NEG
69251: PUSH
69252: LD_INT 3
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 2
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 3
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 3
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: NEG
69294: PUSH
69295: LD_INT 1
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 3
69304: NEG
69305: PUSH
69306: LD_INT 1
69308: NEG
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69339: LD_ADDR_VAR 0 35
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: LD_INT 0
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: LD_INT 1
69359: NEG
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: LD_INT 0
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 1
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: LD_INT 0
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: NEG
69409: PUSH
69410: LD_INT 1
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 2
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 2
69430: NEG
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69451: LD_ADDR_VAR 0 36
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: LD_INT 0
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: LD_INT 1
69471: NEG
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: LD_INT 0
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 1
69489: PUSH
69490: LD_INT 1
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 0
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 1
69509: NEG
69510: PUSH
69511: LD_INT 0
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 1
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: LD_INT 2
69536: NEG
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 1
69544: PUSH
69545: LD_INT 2
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69563: LD_ADDR_VAR 0 37
69567: PUSH
69568: LD_INT 0
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 0
69580: PUSH
69581: LD_INT 1
69583: NEG
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 1
69591: PUSH
69592: LD_INT 0
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: PUSH
69599: LD_INT 1
69601: PUSH
69602: LD_INT 1
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 0
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: LD_INT 0
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 1
69632: NEG
69633: PUSH
69634: LD_INT 1
69636: NEG
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: LD_INT 1
69647: NEG
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 1
69655: NEG
69656: PUSH
69657: LD_INT 1
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69675: LD_ADDR_VAR 0 38
69679: PUSH
69680: LD_INT 0
69682: PUSH
69683: LD_INT 0
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 1
69695: NEG
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 1
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: PUSH
69714: LD_INT 1
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 0
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 1
69733: NEG
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 1
69744: NEG
69745: PUSH
69746: LD_INT 1
69748: NEG
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 2
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 2
69766: NEG
69767: PUSH
69768: LD_INT 1
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69787: LD_ADDR_VAR 0 39
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: LD_INT 0
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: LD_INT 1
69807: NEG
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 1
69815: PUSH
69816: LD_INT 0
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 1
69825: PUSH
69826: LD_INT 1
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 0
69835: PUSH
69836: LD_INT 1
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 1
69845: NEG
69846: PUSH
69847: LD_INT 0
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 1
69856: NEG
69857: PUSH
69858: LD_INT 1
69860: NEG
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: LD_INT 2
69872: NEG
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: LD_INT 1
69880: PUSH
69881: LD_INT 2
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: LIST
69895: LIST
69896: LIST
69897: LIST
69898: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69899: LD_ADDR_VAR 0 40
69903: PUSH
69904: LD_INT 0
69906: PUSH
69907: LD_INT 0
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 1
69927: PUSH
69928: LD_INT 0
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: PUSH
69935: LD_INT 1
69937: PUSH
69938: LD_INT 1
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 0
69947: PUSH
69948: LD_INT 1
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 0
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 1
69968: NEG
69969: PUSH
69970: LD_INT 1
69972: NEG
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 1
69980: PUSH
69981: LD_INT 1
69983: NEG
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 1
69991: NEG
69992: PUSH
69993: LD_INT 1
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70011: LD_ADDR_VAR 0 41
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 0
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 1
70049: PUSH
70050: LD_INT 1
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 0
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: LD_INT 0
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 1
70080: NEG
70081: PUSH
70082: LD_INT 1
70084: NEG
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: LD_INT 2
70096: NEG
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 1
70104: PUSH
70105: LD_INT 1
70107: NEG
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 2
70115: PUSH
70116: LD_INT 0
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 2
70125: PUSH
70126: LD_INT 1
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 2
70135: PUSH
70136: LD_INT 2
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 1
70145: PUSH
70146: LD_INT 2
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 1
70155: NEG
70156: PUSH
70157: LD_INT 1
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 0
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 2
70177: NEG
70178: PUSH
70179: LD_INT 1
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 2
70189: NEG
70190: PUSH
70191: LD_INT 2
70193: NEG
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 2
70201: NEG
70202: PUSH
70203: LD_INT 3
70205: NEG
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 2
70213: PUSH
70214: LD_INT 1
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 3
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 3
70234: PUSH
70235: LD_INT 1
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 3
70244: PUSH
70245: LD_INT 2
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 3
70254: PUSH
70255: LD_INT 3
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 2
70264: PUSH
70265: LD_INT 3
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 2
70274: NEG
70275: PUSH
70276: LD_INT 1
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 3
70285: NEG
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 3
70296: NEG
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 3
70308: NEG
70309: PUSH
70310: LD_INT 2
70312: NEG
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 3
70320: NEG
70321: PUSH
70322: LD_INT 3
70324: NEG
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70361: LD_ADDR_VAR 0 42
70365: PUSH
70366: LD_INT 0
70368: PUSH
70369: LD_INT 0
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 0
70378: PUSH
70379: LD_INT 1
70381: NEG
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: LD_INT 0
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: LD_INT 1
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 0
70409: PUSH
70410: LD_INT 1
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 0
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: NEG
70431: PUSH
70432: LD_INT 1
70434: NEG
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: LD_INT 2
70446: NEG
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: LD_INT 2
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: LD_INT 1
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: LD_INT 1
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: LD_INT 2
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 1
70496: PUSH
70497: LD_INT 2
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 0
70506: PUSH
70507: LD_INT 2
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: NEG
70517: PUSH
70518: LD_INT 1
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 2
70527: NEG
70528: PUSH
70529: LD_INT 1
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 2
70539: NEG
70540: PUSH
70541: LD_INT 2
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 2
70551: NEG
70552: PUSH
70553: LD_INT 3
70555: NEG
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: LD_INT 3
70567: NEG
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: LD_INT 3
70578: NEG
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: LD_INT 2
70589: NEG
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 3
70597: PUSH
70598: LD_INT 2
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: LD_INT 3
70607: PUSH
70608: LD_INT 3
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 2
70617: PUSH
70618: LD_INT 3
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: LD_INT 3
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 0
70637: PUSH
70638: LD_INT 3
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 1
70647: NEG
70648: PUSH
70649: LD_INT 2
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 3
70658: NEG
70659: PUSH
70660: LD_INT 2
70662: NEG
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 3
70670: NEG
70671: PUSH
70672: LD_INT 3
70674: NEG
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70711: LD_ADDR_VAR 0 43
70715: PUSH
70716: LD_INT 0
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 0
70728: PUSH
70729: LD_INT 1
70731: NEG
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: LD_INT 0
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: LD_INT 1
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 0
70759: PUSH
70760: LD_INT 1
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: LD_INT 0
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 1
70780: NEG
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: NEG
70793: PUSH
70794: LD_INT 2
70796: NEG
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: LD_INT 2
70807: NEG
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: LD_INT 1
70818: NEG
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 2
70826: PUSH
70827: LD_INT 0
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 2
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 1
70866: NEG
70867: PUSH
70868: LD_INT 1
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 2
70877: NEG
70878: PUSH
70879: LD_INT 0
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: NEG
70889: PUSH
70890: LD_INT 1
70892: NEG
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 1
70900: NEG
70901: PUSH
70902: LD_INT 3
70904: NEG
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: LD_INT 0
70912: PUSH
70913: LD_INT 3
70915: NEG
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: LD_INT 2
70926: NEG
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: LD_INT 2
70934: PUSH
70935: LD_INT 1
70937: NEG
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 3
70945: PUSH
70946: LD_INT 0
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 3
70955: PUSH
70956: LD_INT 1
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: LD_INT 3
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 0
70975: PUSH
70976: LD_INT 3
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 1
70985: NEG
70986: PUSH
70987: LD_INT 2
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 2
70996: NEG
70997: PUSH
70998: LD_INT 1
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: LD_INT 0
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 3
71018: NEG
71019: PUSH
71020: LD_INT 1
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71059: LD_ADDR_VAR 0 44
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: LD_INT 0
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 0
71076: PUSH
71077: LD_INT 1
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 1
71097: PUSH
71098: LD_INT 1
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: LD_INT 1
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 0
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: NEG
71129: PUSH
71130: LD_INT 1
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: NEG
71141: PUSH
71142: LD_INT 2
71144: NEG
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 1
71152: PUSH
71153: LD_INT 1
71155: NEG
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 2
71163: PUSH
71164: LD_INT 0
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 2
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 2
71183: PUSH
71184: LD_INT 2
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 1
71193: PUSH
71194: LD_INT 2
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 1
71203: NEG
71204: PUSH
71205: LD_INT 1
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: LD_INT 0
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 2
71225: NEG
71226: PUSH
71227: LD_INT 1
71229: NEG
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 2
71237: NEG
71238: PUSH
71239: LD_INT 2
71241: NEG
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 2
71249: NEG
71250: PUSH
71251: LD_INT 3
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 2
71261: PUSH
71262: LD_INT 1
71264: NEG
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 3
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 3
71282: PUSH
71283: LD_INT 1
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 3
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 3
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 2
71312: PUSH
71313: LD_INT 3
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 2
71322: NEG
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 3
71333: NEG
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 3
71344: NEG
71345: PUSH
71346: LD_INT 1
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 3
71356: NEG
71357: PUSH
71358: LD_INT 2
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 3
71368: NEG
71369: PUSH
71370: LD_INT 3
71372: NEG
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71409: LD_ADDR_VAR 0 45
71413: PUSH
71414: LD_INT 0
71416: PUSH
71417: LD_INT 0
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: LD_INT 1
71429: NEG
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 1
71437: PUSH
71438: LD_INT 0
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: PUSH
71448: LD_INT 1
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 0
71457: PUSH
71458: LD_INT 1
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: NEG
71479: PUSH
71480: LD_INT 1
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 1
71490: NEG
71491: PUSH
71492: LD_INT 2
71494: NEG
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: LD_INT 2
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: PUSH
71514: LD_INT 1
71516: NEG
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: LD_INT 1
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: LD_INT 2
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 1
71544: PUSH
71545: LD_INT 2
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 0
71554: PUSH
71555: LD_INT 2
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 1
71564: NEG
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 2
71575: NEG
71576: PUSH
71577: LD_INT 1
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 2
71587: NEG
71588: PUSH
71589: LD_INT 2
71591: NEG
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 2
71599: NEG
71600: PUSH
71601: LD_INT 3
71603: NEG
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: LD_INT 3
71615: NEG
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: LD_INT 0
71623: PUSH
71624: LD_INT 3
71626: NEG
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 1
71634: PUSH
71635: LD_INT 2
71637: NEG
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 3
71645: PUSH
71646: LD_INT 2
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 3
71655: PUSH
71656: LD_INT 3
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 2
71665: PUSH
71666: LD_INT 3
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: LD_INT 3
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 0
71685: PUSH
71686: LD_INT 3
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: LD_INT 2
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: LD_INT 3
71706: NEG
71707: PUSH
71708: LD_INT 2
71710: NEG
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 3
71718: NEG
71719: PUSH
71720: LD_INT 3
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: LIST
71742: LIST
71743: LIST
71744: LIST
71745: LIST
71746: LIST
71747: LIST
71748: LIST
71749: LIST
71750: LIST
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71759: LD_ADDR_VAR 0 46
71763: PUSH
71764: LD_INT 0
71766: PUSH
71767: LD_INT 0
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 0
71776: PUSH
71777: LD_INT 1
71779: NEG
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: LD_INT 0
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: LD_INT 1
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 0
71807: PUSH
71808: LD_INT 1
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 1
71817: NEG
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: NEG
71829: PUSH
71830: LD_INT 1
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 1
71840: NEG
71841: PUSH
71842: LD_INT 2
71844: NEG
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 0
71852: PUSH
71853: LD_INT 2
71855: NEG
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: PUSH
71861: LD_INT 1
71863: PUSH
71864: LD_INT 1
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 2
71874: PUSH
71875: LD_INT 0
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 2
71884: PUSH
71885: LD_INT 1
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: PUSH
71895: LD_INT 2
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 0
71904: PUSH
71905: LD_INT 2
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 1
71914: NEG
71915: PUSH
71916: LD_INT 1
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 2
71936: NEG
71937: PUSH
71938: LD_INT 1
71940: NEG
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 1
71948: NEG
71949: PUSH
71950: LD_INT 3
71952: NEG
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 0
71960: PUSH
71961: LD_INT 3
71963: NEG
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 1
71971: PUSH
71972: LD_INT 2
71974: NEG
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 2
71982: PUSH
71983: LD_INT 1
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 3
71993: PUSH
71994: LD_INT 0
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 3
72003: PUSH
72004: LD_INT 1
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: LD_INT 3
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 0
72023: PUSH
72024: LD_INT 3
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 1
72033: NEG
72034: PUSH
72035: LD_INT 2
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 2
72044: NEG
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 3
72055: NEG
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 3
72066: NEG
72067: PUSH
72068: LD_INT 1
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72107: LD_ADDR_VAR 0 47
72111: PUSH
72112: LD_INT 0
72114: PUSH
72115: LD_INT 0
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 0
72124: PUSH
72125: LD_INT 1
72127: NEG
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: PUSH
72133: LD_INT 1
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: LD_INT 1
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 0
72155: PUSH
72156: LD_INT 1
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 1
72176: NEG
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: NEG
72189: PUSH
72190: LD_INT 2
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 0
72200: PUSH
72201: LD_INT 2
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 1
72211: PUSH
72212: LD_INT 1
72214: NEG
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 2
72222: NEG
72223: PUSH
72224: LD_INT 1
72226: NEG
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 2
72234: NEG
72235: PUSH
72236: LD_INT 2
72238: NEG
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: LIST
72256: LIST
72257: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72258: LD_ADDR_VAR 0 48
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 0
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 0
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: PUSH
72287: LD_INT 0
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 0
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: NEG
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: LD_INT 1
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: NEG
72340: PUSH
72341: LD_INT 2
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: LD_INT 2
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: LD_INT 1
72365: NEG
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 2
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 2
72383: PUSH
72384: LD_INT 1
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72405: LD_ADDR_VAR 0 49
72409: PUSH
72410: LD_INT 0
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 0
72422: PUSH
72423: LD_INT 1
72425: NEG
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: LD_INT 1
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: LD_INT 1
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 0
72453: PUSH
72454: LD_INT 1
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: NEG
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 1
72474: NEG
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 1
72486: PUSH
72487: LD_INT 1
72489: NEG
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 2
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 2
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 2
72517: PUSH
72518: LD_INT 2
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: LD_INT 2
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72549: LD_ADDR_VAR 0 50
72553: PUSH
72554: LD_INT 0
72556: PUSH
72557: LD_INT 0
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 0
72566: PUSH
72567: LD_INT 1
72569: NEG
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 1
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 1
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 0
72597: PUSH
72598: LD_INT 1
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 1
72607: NEG
72608: PUSH
72609: LD_INT 0
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: LD_INT 1
72622: NEG
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 2
72630: PUSH
72631: LD_INT 1
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 2
72640: PUSH
72641: LD_INT 2
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 1
72650: PUSH
72651: LD_INT 2
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 0
72660: PUSH
72661: LD_INT 2
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 1
72670: NEG
72671: PUSH
72672: LD_INT 1
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72693: LD_ADDR_VAR 0 51
72697: PUSH
72698: LD_INT 0
72700: PUSH
72701: LD_INT 0
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: LD_INT 1
72713: NEG
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 1
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 1
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: NEG
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 1
72762: NEG
72763: PUSH
72764: LD_INT 1
72766: NEG
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 1
72774: PUSH
72775: LD_INT 2
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: LD_INT 2
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: LD_INT 1
72820: NEG
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72840: LD_ADDR_VAR 0 52
72844: PUSH
72845: LD_INT 0
72847: PUSH
72848: LD_INT 0
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: PUSH
72869: LD_INT 0
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 1
72878: PUSH
72879: LD_INT 1
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 0
72888: PUSH
72889: LD_INT 1
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 0
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 1
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: LD_INT 2
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 1
72933: NEG
72934: PUSH
72935: LD_INT 1
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 2
72944: NEG
72945: PUSH
72946: LD_INT 0
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 2
72955: NEG
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 2
72967: NEG
72968: PUSH
72969: LD_INT 2
72971: NEG
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72991: LD_ADDR_VAR 0 53
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 0
73008: PUSH
73009: LD_INT 1
73011: NEG
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 1
73019: PUSH
73020: LD_INT 0
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: LD_INT 1
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 1
73049: NEG
73050: PUSH
73051: LD_INT 0
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 1
73060: NEG
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: LD_INT 2
73076: NEG
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 0
73084: PUSH
73085: LD_INT 2
73087: NEG
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 1
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 2
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 2
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 2
73126: PUSH
73127: LD_INT 2
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: LD_INT 2
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 0
73146: PUSH
73147: LD_INT 2
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: LD_INT 1
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 2
73167: NEG
73168: PUSH
73169: LD_INT 0
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: LD_INT 1
73182: NEG
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 2
73190: NEG
73191: PUSH
73192: LD_INT 2
73194: NEG
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73221: LD_ADDR_VAR 0 54
73225: PUSH
73226: LD_INT 0
73228: PUSH
73229: LD_INT 0
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 0
73238: PUSH
73239: LD_INT 1
73241: NEG
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 1
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 1
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 1
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 1
73279: NEG
73280: PUSH
73281: LD_INT 0
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: LD_INT 1
73294: NEG
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 1
73302: NEG
73303: PUSH
73304: LD_INT 2
73306: NEG
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 0
73314: PUSH
73315: LD_INT 2
73317: NEG
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: PUSH
73326: LD_INT 1
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 2
73336: PUSH
73337: LD_INT 0
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 2
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 2
73356: PUSH
73357: LD_INT 2
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: PUSH
73367: LD_INT 2
73369: PUSH
73370: EMPTY
73371: LIST
73372: LIST
73373: PUSH
73374: LD_INT 0
73376: PUSH
73377: LD_INT 2
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PUSH
73384: LD_INT 1
73386: NEG
73387: PUSH
73388: LD_INT 1
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 2
73397: NEG
73398: PUSH
73399: LD_INT 0
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 2
73408: NEG
73409: PUSH
73410: LD_INT 1
73412: NEG
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 2
73420: NEG
73421: PUSH
73422: LD_INT 2
73424: NEG
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73451: LD_ADDR_VAR 0 55
73455: PUSH
73456: LD_INT 0
73458: PUSH
73459: LD_INT 0
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 0
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 1
73479: PUSH
73480: LD_INT 0
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: LD_INT 1
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 0
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 1
73509: NEG
73510: PUSH
73511: LD_INT 0
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 1
73520: NEG
73521: PUSH
73522: LD_INT 1
73524: NEG
73525: PUSH
73526: EMPTY
73527: LIST
73528: LIST
73529: PUSH
73530: LD_INT 1
73532: NEG
73533: PUSH
73534: LD_INT 2
73536: NEG
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: LD_INT 2
73547: NEG
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 1
73555: PUSH
73556: LD_INT 1
73558: NEG
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 2
73566: PUSH
73567: LD_INT 0
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 2
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 2
73586: PUSH
73587: LD_INT 2
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 1
73596: PUSH
73597: LD_INT 2
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 0
73606: PUSH
73607: LD_INT 2
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 1
73616: NEG
73617: PUSH
73618: LD_INT 1
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 2
73627: NEG
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 2
73638: NEG
73639: PUSH
73640: LD_INT 1
73642: NEG
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 2
73650: NEG
73651: PUSH
73652: LD_INT 2
73654: NEG
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: LIST
73673: LIST
73674: LIST
73675: LIST
73676: LIST
73677: LIST
73678: LIST
73679: LIST
73680: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73681: LD_ADDR_VAR 0 56
73685: PUSH
73686: LD_INT 0
73688: PUSH
73689: LD_INT 0
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 0
73698: PUSH
73699: LD_INT 1
73701: NEG
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: LD_INT 1
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: LD_INT 1
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 0
73729: PUSH
73730: LD_INT 1
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: PUSH
73737: LD_INT 1
73739: NEG
73740: PUSH
73741: LD_INT 0
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 1
73750: NEG
73751: PUSH
73752: LD_INT 1
73754: NEG
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 1
73762: NEG
73763: PUSH
73764: LD_INT 2
73766: NEG
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 0
73774: PUSH
73775: LD_INT 2
73777: NEG
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 1
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 2
73796: PUSH
73797: LD_INT 0
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 2
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 2
73816: PUSH
73817: LD_INT 2
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: PUSH
73827: LD_INT 2
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 0
73836: PUSH
73837: LD_INT 2
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 1
73846: NEG
73847: PUSH
73848: LD_INT 1
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 2
73857: NEG
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 2
73868: NEG
73869: PUSH
73870: LD_INT 1
73872: NEG
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: LD_INT 2
73880: NEG
73881: PUSH
73882: LD_INT 2
73884: NEG
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73911: LD_ADDR_VAR 0 57
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: PUSH
73926: LD_INT 0
73928: PUSH
73929: LD_INT 1
73931: NEG
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 1
73939: PUSH
73940: LD_INT 0
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 0
73959: PUSH
73960: LD_INT 1
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 1
73969: NEG
73970: PUSH
73971: LD_INT 0
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 1
73980: NEG
73981: PUSH
73982: LD_INT 1
73984: NEG
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 1
73992: NEG
73993: PUSH
73994: LD_INT 2
73996: NEG
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: LD_INT 2
74007: NEG
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 1
74015: PUSH
74016: LD_INT 1
74018: NEG
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: LD_INT 0
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 2
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 2
74046: PUSH
74047: LD_INT 2
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: LD_INT 2
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: LD_INT 2
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 1
74076: NEG
74077: PUSH
74078: LD_INT 1
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 2
74087: NEG
74088: PUSH
74089: LD_INT 0
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: NEG
74099: PUSH
74100: LD_INT 1
74102: NEG
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 2
74110: NEG
74111: PUSH
74112: LD_INT 2
74114: NEG
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74141: LD_ADDR_VAR 0 58
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: LD_INT 1
74161: NEG
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: LD_INT 0
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 1
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 0
74189: PUSH
74190: LD_INT 1
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 1
74199: NEG
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 1
74210: NEG
74211: PUSH
74212: LD_INT 1
74214: NEG
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 1
74222: NEG
74223: PUSH
74224: LD_INT 2
74226: NEG
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 0
74234: PUSH
74235: LD_INT 2
74237: NEG
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: LD_INT 1
74248: NEG
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 2
74256: PUSH
74257: LD_INT 0
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 2
74266: PUSH
74267: LD_INT 1
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 2
74276: PUSH
74277: LD_INT 2
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 1
74286: PUSH
74287: LD_INT 2
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: LD_INT 2
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 1
74306: NEG
74307: PUSH
74308: LD_INT 1
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 2
74317: NEG
74318: PUSH
74319: LD_INT 0
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 2
74328: NEG
74329: PUSH
74330: LD_INT 1
74332: NEG
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 2
74340: NEG
74341: PUSH
74342: LD_INT 2
74344: NEG
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74371: LD_ADDR_VAR 0 59
74375: PUSH
74376: LD_INT 0
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: LD_INT 1
74391: NEG
74392: PUSH
74393: EMPTY
74394: LIST
74395: LIST
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: LD_INT 0
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: PUSH
74407: LD_INT 1
74409: PUSH
74410: LD_INT 1
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 0
74419: PUSH
74420: LD_INT 1
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 1
74429: NEG
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: LD_INT 1
74444: NEG
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74459: LD_ADDR_VAR 0 60
74463: PUSH
74464: LD_INT 0
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 0
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: LD_INT 0
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: LD_INT 1
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: NEG
74518: PUSH
74519: LD_INT 0
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: LIST
74542: LIST
74543: LIST
74544: LIST
74545: LIST
74546: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74547: LD_ADDR_VAR 0 61
74551: PUSH
74552: LD_INT 0
74554: PUSH
74555: LD_INT 0
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: LD_INT 1
74567: NEG
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 1
74575: PUSH
74576: LD_INT 0
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 1
74585: PUSH
74586: LD_INT 1
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: PUSH
74593: LD_INT 0
74595: PUSH
74596: LD_INT 1
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 1
74605: NEG
74606: PUSH
74607: LD_INT 0
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 1
74616: NEG
74617: PUSH
74618: LD_INT 1
74620: NEG
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74635: LD_ADDR_VAR 0 62
74639: PUSH
74640: LD_INT 0
74642: PUSH
74643: LD_INT 0
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: PUSH
74650: LD_INT 0
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: PUSH
74664: LD_INT 0
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 1
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: LD_INT 0
74683: PUSH
74684: LD_INT 1
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: LD_INT 0
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 1
74704: NEG
74705: PUSH
74706: LD_INT 1
74708: NEG
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: LIST
74722: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74723: LD_ADDR_VAR 0 63
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: PUSH
74752: LD_INT 0
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 1
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 1
74792: NEG
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74811: LD_ADDR_VAR 0 64
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: LD_INT 0
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: LD_INT 1
74831: NEG
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 1
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 1
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: LD_INT 1
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 1
74880: NEG
74881: PUSH
74882: LD_INT 1
74884: NEG
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: LIST
74894: LIST
74895: LIST
74896: LIST
74897: LIST
74898: ST_TO_ADDR
// end ; 1 :
74899: GO 80796
74901: LD_INT 1
74903: DOUBLE
74904: EQUAL
74905: IFTRUE 74909
74907: GO 77532
74909: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74910: LD_ADDR_VAR 0 11
74914: PUSH
74915: LD_INT 1
74917: NEG
74918: PUSH
74919: LD_INT 3
74921: NEG
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: LD_INT 3
74932: NEG
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 1
74940: PUSH
74941: LD_INT 2
74943: NEG
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: LIST
74953: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74954: LD_ADDR_VAR 0 12
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: LD_INT 1
74964: NEG
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 3
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 3
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: LIST
74994: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74995: LD_ADDR_VAR 0 13
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: LD_INT 2
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 3
75012: PUSH
75013: LD_INT 3
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 2
75022: PUSH
75023: LD_INT 3
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: LIST
75034: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75035: LD_ADDR_VAR 0 14
75039: PUSH
75040: LD_INT 1
75042: PUSH
75043: LD_INT 3
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 0
75052: PUSH
75053: LD_INT 3
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 1
75062: NEG
75063: PUSH
75064: LD_INT 2
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: LIST
75075: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75076: LD_ADDR_VAR 0 15
75080: PUSH
75081: LD_INT 2
75083: NEG
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 3
75094: NEG
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 3
75105: NEG
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: LIST
75119: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75120: LD_ADDR_VAR 0 16
75124: PUSH
75125: LD_INT 2
75127: NEG
75128: PUSH
75129: LD_INT 3
75131: NEG
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 3
75139: NEG
75140: PUSH
75141: LD_INT 2
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 3
75151: NEG
75152: PUSH
75153: LD_INT 3
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: LIST
75165: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75166: LD_ADDR_VAR 0 17
75170: PUSH
75171: LD_INT 1
75173: NEG
75174: PUSH
75175: LD_INT 3
75177: NEG
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 0
75185: PUSH
75186: LD_INT 3
75188: NEG
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 1
75196: PUSH
75197: LD_INT 2
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: LIST
75209: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75210: LD_ADDR_VAR 0 18
75214: PUSH
75215: LD_INT 2
75217: PUSH
75218: LD_INT 1
75220: NEG
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 3
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 3
75238: PUSH
75239: LD_INT 1
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: LIST
75250: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75251: LD_ADDR_VAR 0 19
75255: PUSH
75256: LD_INT 3
75258: PUSH
75259: LD_INT 2
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 3
75268: PUSH
75269: LD_INT 3
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 2
75278: PUSH
75279: LD_INT 3
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: LIST
75290: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75291: LD_ADDR_VAR 0 20
75295: PUSH
75296: LD_INT 1
75298: PUSH
75299: LD_INT 3
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 0
75308: PUSH
75309: LD_INT 3
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 1
75318: NEG
75319: PUSH
75320: LD_INT 2
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: LIST
75331: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75332: LD_ADDR_VAR 0 21
75336: PUSH
75337: LD_INT 2
75339: NEG
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 3
75350: NEG
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 3
75361: NEG
75362: PUSH
75363: LD_INT 1
75365: NEG
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: LIST
75375: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75376: LD_ADDR_VAR 0 22
75380: PUSH
75381: LD_INT 2
75383: NEG
75384: PUSH
75385: LD_INT 3
75387: NEG
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: LD_INT 3
75395: NEG
75396: PUSH
75397: LD_INT 2
75399: NEG
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 3
75407: NEG
75408: PUSH
75409: LD_INT 3
75411: NEG
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: LIST
75421: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75422: LD_ADDR_VAR 0 23
75426: PUSH
75427: LD_INT 0
75429: PUSH
75430: LD_INT 3
75432: NEG
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 1
75440: NEG
75441: PUSH
75442: LD_INT 4
75444: NEG
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 1
75452: PUSH
75453: LD_INT 3
75455: NEG
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: LIST
75465: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75466: LD_ADDR_VAR 0 24
75470: PUSH
75471: LD_INT 3
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 3
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: LD_INT 4
75494: PUSH
75495: LD_INT 1
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: LIST
75506: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75507: LD_ADDR_VAR 0 25
75511: PUSH
75512: LD_INT 3
75514: PUSH
75515: LD_INT 3
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PUSH
75522: LD_INT 4
75524: PUSH
75525: LD_INT 3
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 3
75534: PUSH
75535: LD_INT 4
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: LIST
75546: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75547: LD_ADDR_VAR 0 26
75551: PUSH
75552: LD_INT 0
75554: PUSH
75555: LD_INT 3
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: PUSH
75565: LD_INT 4
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 1
75574: NEG
75575: PUSH
75576: LD_INT 3
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: LIST
75587: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75588: LD_ADDR_VAR 0 27
75592: PUSH
75593: LD_INT 3
75595: NEG
75596: PUSH
75597: LD_INT 0
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 3
75606: NEG
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: LD_INT 4
75617: NEG
75618: PUSH
75619: LD_INT 1
75621: NEG
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: LIST
75631: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75632: LD_ADDR_VAR 0 28
75636: PUSH
75637: LD_INT 3
75639: NEG
75640: PUSH
75641: LD_INT 3
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 3
75651: NEG
75652: PUSH
75653: LD_INT 4
75655: NEG
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 4
75663: NEG
75664: PUSH
75665: LD_INT 3
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: LIST
75677: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75678: LD_ADDR_VAR 0 29
75682: PUSH
75683: LD_INT 1
75685: NEG
75686: PUSH
75687: LD_INT 3
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 0
75697: PUSH
75698: LD_INT 3
75700: NEG
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: LD_INT 2
75711: NEG
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 1
75719: NEG
75720: PUSH
75721: LD_INT 4
75723: NEG
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: LD_INT 4
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: PUSH
75743: LD_INT 3
75745: NEG
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 1
75753: NEG
75754: PUSH
75755: LD_INT 5
75757: NEG
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 0
75765: PUSH
75766: LD_INT 5
75768: NEG
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 1
75776: PUSH
75777: LD_INT 4
75779: NEG
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: NEG
75788: PUSH
75789: LD_INT 6
75791: NEG
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 0
75799: PUSH
75800: LD_INT 6
75802: NEG
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: LD_INT 5
75813: NEG
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: LIST
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75833: LD_ADDR_VAR 0 30
75837: PUSH
75838: LD_INT 2
75840: PUSH
75841: LD_INT 1
75843: NEG
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 3
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 3
75861: PUSH
75862: LD_INT 1
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 3
75871: PUSH
75872: LD_INT 1
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 4
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 4
75892: PUSH
75893: LD_INT 1
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 4
75902: PUSH
75903: LD_INT 1
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 5
75913: PUSH
75914: LD_INT 0
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 5
75923: PUSH
75924: LD_INT 1
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 5
75933: PUSH
75934: LD_INT 1
75936: NEG
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 6
75944: PUSH
75945: LD_INT 0
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 6
75954: PUSH
75955: LD_INT 1
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: LIST
75966: LIST
75967: LIST
75968: LIST
75969: LIST
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75976: LD_ADDR_VAR 0 31
75980: PUSH
75981: LD_INT 3
75983: PUSH
75984: LD_INT 2
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 3
75993: PUSH
75994: LD_INT 3
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 2
76003: PUSH
76004: LD_INT 3
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 4
76013: PUSH
76014: LD_INT 3
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 4
76023: PUSH
76024: LD_INT 4
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: PUSH
76034: LD_INT 4
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 5
76043: PUSH
76044: LD_INT 4
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 5
76053: PUSH
76054: LD_INT 5
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 4
76063: PUSH
76064: LD_INT 5
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 6
76073: PUSH
76074: LD_INT 5
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 6
76083: PUSH
76084: LD_INT 6
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 5
76093: PUSH
76094: LD_INT 6
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: LIST
76113: LIST
76114: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76115: LD_ADDR_VAR 0 32
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: LD_INT 3
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: LD_INT 3
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 1
76142: NEG
76143: PUSH
76144: LD_INT 2
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 1
76153: PUSH
76154: LD_INT 4
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 0
76163: PUSH
76164: LD_INT 4
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 1
76173: NEG
76174: PUSH
76175: LD_INT 3
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 1
76184: PUSH
76185: LD_INT 5
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 0
76194: PUSH
76195: LD_INT 5
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 1
76204: NEG
76205: PUSH
76206: LD_INT 4
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 1
76215: PUSH
76216: LD_INT 6
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 0
76225: PUSH
76226: LD_INT 6
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: NEG
76236: PUSH
76237: LD_INT 5
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76258: LD_ADDR_VAR 0 33
76262: PUSH
76263: LD_INT 2
76265: NEG
76266: PUSH
76267: LD_INT 1
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 3
76276: NEG
76277: PUSH
76278: LD_INT 0
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 3
76287: NEG
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 3
76299: NEG
76300: PUSH
76301: LD_INT 1
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 4
76310: NEG
76311: PUSH
76312: LD_INT 0
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 4
76321: NEG
76322: PUSH
76323: LD_INT 1
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 4
76333: NEG
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: LD_INT 5
76344: NEG
76345: PUSH
76346: LD_INT 0
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 5
76355: NEG
76356: PUSH
76357: LD_INT 1
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 5
76367: NEG
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 6
76378: NEG
76379: PUSH
76380: LD_INT 0
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 6
76389: NEG
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76413: LD_ADDR_VAR 0 34
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: LD_INT 3
76424: NEG
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 3
76432: NEG
76433: PUSH
76434: LD_INT 2
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 3
76444: NEG
76445: PUSH
76446: LD_INT 3
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 3
76456: NEG
76457: PUSH
76458: LD_INT 4
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 4
76468: NEG
76469: PUSH
76470: LD_INT 3
76472: NEG
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 4
76480: NEG
76481: PUSH
76482: LD_INT 4
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 4
76492: NEG
76493: PUSH
76494: LD_INT 5
76496: NEG
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 5
76504: NEG
76505: PUSH
76506: LD_INT 4
76508: NEG
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 5
76516: NEG
76517: PUSH
76518: LD_INT 5
76520: NEG
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 5
76528: NEG
76529: PUSH
76530: LD_INT 6
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 6
76540: NEG
76541: PUSH
76542: LD_INT 5
76544: NEG
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 6
76552: NEG
76553: PUSH
76554: LD_INT 6
76556: NEG
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76576: LD_ADDR_VAR 0 41
76580: PUSH
76581: LD_INT 0
76583: PUSH
76584: LD_INT 2
76586: NEG
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 1
76594: NEG
76595: PUSH
76596: LD_INT 3
76598: NEG
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 1
76606: PUSH
76607: LD_INT 2
76609: NEG
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: LIST
76619: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76620: LD_ADDR_VAR 0 42
76624: PUSH
76625: LD_INT 2
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: LD_INT 1
76640: NEG
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 3
76648: PUSH
76649: LD_INT 1
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: LIST
76660: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76661: LD_ADDR_VAR 0 43
76665: PUSH
76666: LD_INT 2
76668: PUSH
76669: LD_INT 2
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 3
76678: PUSH
76679: LD_INT 2
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 2
76688: PUSH
76689: LD_INT 3
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: LIST
76700: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76701: LD_ADDR_VAR 0 44
76705: PUSH
76706: LD_INT 0
76708: PUSH
76709: LD_INT 2
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 1
76718: PUSH
76719: LD_INT 3
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 1
76728: NEG
76729: PUSH
76730: LD_INT 2
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: LIST
76741: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76742: LD_ADDR_VAR 0 45
76746: PUSH
76747: LD_INT 2
76749: NEG
76750: PUSH
76751: LD_INT 0
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 2
76760: NEG
76761: PUSH
76762: LD_INT 1
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 3
76771: NEG
76772: PUSH
76773: LD_INT 1
76775: NEG
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: LIST
76785: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76786: LD_ADDR_VAR 0 46
76790: PUSH
76791: LD_INT 2
76793: NEG
76794: PUSH
76795: LD_INT 2
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 2
76805: NEG
76806: PUSH
76807: LD_INT 3
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 3
76817: NEG
76818: PUSH
76819: LD_INT 2
76821: NEG
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: LIST
76831: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76832: LD_ADDR_VAR 0 47
76836: PUSH
76837: LD_INT 2
76839: NEG
76840: PUSH
76841: LD_INT 3
76843: NEG
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 1
76851: NEG
76852: PUSH
76853: LD_INT 3
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76865: LD_ADDR_VAR 0 48
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: LD_INT 2
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 2
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76896: LD_ADDR_VAR 0 49
76900: PUSH
76901: LD_INT 3
76903: PUSH
76904: LD_INT 1
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 3
76913: PUSH
76914: LD_INT 2
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76925: LD_ADDR_VAR 0 50
76929: PUSH
76930: LD_INT 2
76932: PUSH
76933: LD_INT 3
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 1
76942: PUSH
76943: LD_INT 3
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76954: LD_ADDR_VAR 0 51
76958: PUSH
76959: LD_INT 1
76961: NEG
76962: PUSH
76963: LD_INT 2
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 2
76972: NEG
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76985: LD_ADDR_VAR 0 52
76989: PUSH
76990: LD_INT 3
76992: NEG
76993: PUSH
76994: LD_INT 1
76996: NEG
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 3
77004: NEG
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77018: LD_ADDR_VAR 0 53
77022: PUSH
77023: LD_INT 1
77025: NEG
77026: PUSH
77027: LD_INT 3
77029: NEG
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 0
77037: PUSH
77038: LD_INT 3
77040: NEG
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: LD_INT 2
77051: NEG
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: LIST
77061: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77062: LD_ADDR_VAR 0 54
77066: PUSH
77067: LD_INT 2
77069: PUSH
77070: LD_INT 1
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 3
77080: PUSH
77081: LD_INT 0
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 3
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: LIST
77102: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77103: LD_ADDR_VAR 0 55
77107: PUSH
77108: LD_INT 3
77110: PUSH
77111: LD_INT 2
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 3
77120: PUSH
77121: LD_INT 3
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 2
77130: PUSH
77131: LD_INT 3
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: LIST
77142: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77143: LD_ADDR_VAR 0 56
77147: PUSH
77148: LD_INT 1
77150: PUSH
77151: LD_INT 3
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: LD_INT 3
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 1
77170: NEG
77171: PUSH
77172: LD_INT 2
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: LIST
77183: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77184: LD_ADDR_VAR 0 57
77188: PUSH
77189: LD_INT 2
77191: NEG
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 3
77202: NEG
77203: PUSH
77204: LD_INT 0
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 3
77213: NEG
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: LIST
77227: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77228: LD_ADDR_VAR 0 58
77232: PUSH
77233: LD_INT 2
77235: NEG
77236: PUSH
77237: LD_INT 3
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 3
77247: NEG
77248: PUSH
77249: LD_INT 2
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 3
77259: NEG
77260: PUSH
77261: LD_INT 3
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: LIST
77273: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77274: LD_ADDR_VAR 0 59
77278: PUSH
77279: LD_INT 1
77281: NEG
77282: PUSH
77283: LD_INT 2
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: LD_INT 2
77296: NEG
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: PUSH
77302: LD_INT 1
77304: PUSH
77305: LD_INT 1
77307: NEG
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: LIST
77317: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77318: LD_ADDR_VAR 0 60
77322: PUSH
77323: LD_INT 1
77325: PUSH
77326: LD_INT 1
77328: NEG
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 2
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 2
77346: PUSH
77347: LD_INT 1
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: LIST
77358: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77359: LD_ADDR_VAR 0 61
77363: PUSH
77364: LD_INT 2
77366: PUSH
77367: LD_INT 1
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 2
77376: PUSH
77377: LD_INT 2
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 1
77386: PUSH
77387: LD_INT 2
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77399: LD_ADDR_VAR 0 62
77403: PUSH
77404: LD_INT 1
77406: PUSH
77407: LD_INT 2
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: LD_INT 2
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 1
77426: NEG
77427: PUSH
77428: LD_INT 1
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: LIST
77439: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77440: LD_ADDR_VAR 0 63
77444: PUSH
77445: LD_INT 1
77447: NEG
77448: PUSH
77449: LD_INT 1
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 2
77458: NEG
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 2
77469: NEG
77470: PUSH
77471: LD_INT 1
77473: NEG
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: LIST
77483: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77484: LD_ADDR_VAR 0 64
77488: PUSH
77489: LD_INT 1
77491: NEG
77492: PUSH
77493: LD_INT 2
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 2
77503: NEG
77504: PUSH
77505: LD_INT 1
77507: NEG
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 2
77515: NEG
77516: PUSH
77517: LD_INT 2
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: LIST
77529: ST_TO_ADDR
// end ; 2 :
77530: GO 80796
77532: LD_INT 2
77534: DOUBLE
77535: EQUAL
77536: IFTRUE 77540
77538: GO 80795
77540: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77541: LD_ADDR_VAR 0 29
77545: PUSH
77546: LD_INT 4
77548: PUSH
77549: LD_INT 0
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 4
77558: PUSH
77559: LD_INT 1
77561: NEG
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 5
77569: PUSH
77570: LD_INT 0
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 5
77579: PUSH
77580: LD_INT 1
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 4
77589: PUSH
77590: LD_INT 1
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 3
77599: PUSH
77600: LD_INT 0
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 3
77609: PUSH
77610: LD_INT 1
77612: NEG
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 3
77620: PUSH
77621: LD_INT 2
77623: NEG
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 5
77631: PUSH
77632: LD_INT 2
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: PUSH
77642: LD_INT 3
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 3
77651: PUSH
77652: LD_INT 2
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: LD_INT 4
77661: PUSH
77662: LD_INT 3
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 4
77671: PUSH
77672: LD_INT 4
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 3
77681: PUSH
77682: LD_INT 4
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: LD_INT 2
77691: PUSH
77692: LD_INT 3
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 2
77701: PUSH
77702: LD_INT 2
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 4
77711: PUSH
77712: LD_INT 2
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 2
77721: PUSH
77722: LD_INT 4
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 0
77731: PUSH
77732: LD_INT 4
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 0
77741: PUSH
77742: LD_INT 3
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 1
77751: PUSH
77752: LD_INT 4
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 1
77761: PUSH
77762: LD_INT 5
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 0
77771: PUSH
77772: LD_INT 5
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 1
77781: NEG
77782: PUSH
77783: LD_INT 4
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 1
77792: NEG
77793: PUSH
77794: LD_INT 3
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 2
77803: PUSH
77804: LD_INT 5
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: LD_INT 3
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 3
77824: NEG
77825: PUSH
77826: LD_INT 0
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 3
77835: NEG
77836: PUSH
77837: LD_INT 1
77839: NEG
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 2
77847: NEG
77848: PUSH
77849: LD_INT 0
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 2
77858: NEG
77859: PUSH
77860: LD_INT 1
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 3
77869: NEG
77870: PUSH
77871: LD_INT 1
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 4
77880: NEG
77881: PUSH
77882: LD_INT 0
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 4
77891: NEG
77892: PUSH
77893: LD_INT 1
77895: NEG
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 4
77903: NEG
77904: PUSH
77905: LD_INT 2
77907: NEG
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 2
77915: NEG
77916: PUSH
77917: LD_INT 2
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: LD_INT 4
77926: NEG
77927: PUSH
77928: LD_INT 4
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 4
77938: NEG
77939: PUSH
77940: LD_INT 5
77942: NEG
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 3
77950: NEG
77951: PUSH
77952: LD_INT 4
77954: NEG
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 3
77962: NEG
77963: PUSH
77964: LD_INT 3
77966: NEG
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 4
77974: NEG
77975: PUSH
77976: LD_INT 3
77978: NEG
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 5
77986: NEG
77987: PUSH
77988: LD_INT 4
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 5
77998: NEG
77999: PUSH
78000: LD_INT 5
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: LD_INT 5
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 5
78022: NEG
78023: PUSH
78024: LD_INT 3
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: LIST
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78079: LD_ADDR_VAR 0 30
78083: PUSH
78084: LD_INT 4
78086: PUSH
78087: LD_INT 4
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 4
78096: PUSH
78097: LD_INT 3
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 5
78106: PUSH
78107: LD_INT 4
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: PUSH
78114: LD_INT 5
78116: PUSH
78117: LD_INT 5
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 4
78126: PUSH
78127: LD_INT 5
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 3
78136: PUSH
78137: LD_INT 4
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 3
78146: PUSH
78147: LD_INT 3
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 5
78156: PUSH
78157: LD_INT 3
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 3
78166: PUSH
78167: LD_INT 5
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 0
78176: PUSH
78177: LD_INT 3
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 0
78186: PUSH
78187: LD_INT 2
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: LD_INT 3
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 1
78206: PUSH
78207: LD_INT 4
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 0
78216: PUSH
78217: LD_INT 4
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: LD_INT 3
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 1
78237: NEG
78238: PUSH
78239: LD_INT 2
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 2
78248: PUSH
78249: LD_INT 4
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 2
78258: NEG
78259: PUSH
78260: LD_INT 2
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 4
78269: NEG
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 4
78280: NEG
78281: PUSH
78282: LD_INT 1
78284: NEG
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 3
78292: NEG
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 3
78303: NEG
78304: PUSH
78305: LD_INT 1
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 4
78314: NEG
78315: PUSH
78316: LD_INT 1
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 5
78325: NEG
78326: PUSH
78327: LD_INT 0
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 5
78336: NEG
78337: PUSH
78338: LD_INT 1
78340: NEG
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: LD_INT 5
78348: NEG
78349: PUSH
78350: LD_INT 2
78352: NEG
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 3
78360: NEG
78361: PUSH
78362: LD_INT 2
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 3
78371: NEG
78372: PUSH
78373: LD_INT 3
78375: NEG
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 3
78383: NEG
78384: PUSH
78385: LD_INT 4
78387: NEG
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 2
78395: NEG
78396: PUSH
78397: LD_INT 3
78399: NEG
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 2
78407: NEG
78408: PUSH
78409: LD_INT 2
78411: NEG
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PUSH
78417: LD_INT 3
78419: NEG
78420: PUSH
78421: LD_INT 2
78423: NEG
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 4
78431: NEG
78432: PUSH
78433: LD_INT 3
78435: NEG
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 4
78443: NEG
78444: PUSH
78445: LD_INT 4
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 2
78455: NEG
78456: PUSH
78457: LD_INT 4
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 4
78467: NEG
78468: PUSH
78469: LD_INT 2
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 0
78479: PUSH
78480: LD_INT 4
78482: NEG
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 0
78490: PUSH
78491: LD_INT 5
78493: NEG
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 1
78501: PUSH
78502: LD_INT 4
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 1
78512: PUSH
78513: LD_INT 3
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 0
78523: PUSH
78524: LD_INT 3
78526: NEG
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 1
78534: NEG
78535: PUSH
78536: LD_INT 4
78538: NEG
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 1
78546: NEG
78547: PUSH
78548: LD_INT 5
78550: NEG
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: LD_INT 3
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 2
78569: NEG
78570: PUSH
78571: LD_INT 5
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: LIST
78619: LIST
78620: LIST
78621: LIST
78622: LIST
78623: LIST
78624: LIST
78625: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78626: LD_ADDR_VAR 0 31
78630: PUSH
78631: LD_INT 0
78633: PUSH
78634: LD_INT 4
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 0
78643: PUSH
78644: LD_INT 3
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: LD_INT 4
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 1
78663: PUSH
78664: LD_INT 5
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 0
78673: PUSH
78674: LD_INT 5
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 1
78683: NEG
78684: PUSH
78685: LD_INT 4
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 1
78694: NEG
78695: PUSH
78696: LD_INT 3
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 2
78705: PUSH
78706: LD_INT 5
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 2
78715: NEG
78716: PUSH
78717: LD_INT 3
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 3
78726: NEG
78727: PUSH
78728: LD_INT 0
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: LD_INT 3
78737: NEG
78738: PUSH
78739: LD_INT 1
78741: NEG
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 2
78749: NEG
78750: PUSH
78751: LD_INT 0
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 2
78760: NEG
78761: PUSH
78762: LD_INT 1
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 3
78771: NEG
78772: PUSH
78773: LD_INT 1
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 4
78782: NEG
78783: PUSH
78784: LD_INT 0
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 4
78793: NEG
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 4
78805: NEG
78806: PUSH
78807: LD_INT 2
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 2
78817: NEG
78818: PUSH
78819: LD_INT 2
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 4
78828: NEG
78829: PUSH
78830: LD_INT 4
78832: NEG
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 4
78840: NEG
78841: PUSH
78842: LD_INT 5
78844: NEG
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 3
78852: NEG
78853: PUSH
78854: LD_INT 4
78856: NEG
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 3
78864: NEG
78865: PUSH
78866: LD_INT 3
78868: NEG
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 4
78876: NEG
78877: PUSH
78878: LD_INT 3
78880: NEG
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 5
78888: NEG
78889: PUSH
78890: LD_INT 4
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 5
78900: NEG
78901: PUSH
78902: LD_INT 5
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: LD_INT 5
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 5
78924: NEG
78925: PUSH
78926: LD_INT 3
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 0
78936: PUSH
78937: LD_INT 3
78939: NEG
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: LD_INT 0
78947: PUSH
78948: LD_INT 4
78950: NEG
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 1
78958: PUSH
78959: LD_INT 3
78961: NEG
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: LD_INT 2
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 0
78980: PUSH
78981: LD_INT 2
78983: NEG
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 1
78991: NEG
78992: PUSH
78993: LD_INT 3
78995: NEG
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 1
79003: NEG
79004: PUSH
79005: LD_INT 4
79007: NEG
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 2
79015: PUSH
79016: LD_INT 2
79018: NEG
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 2
79026: NEG
79027: PUSH
79028: LD_INT 4
79030: NEG
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 4
79038: PUSH
79039: LD_INT 0
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 4
79048: PUSH
79049: LD_INT 1
79051: NEG
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 5
79059: PUSH
79060: LD_INT 0
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 5
79069: PUSH
79070: LD_INT 1
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 4
79079: PUSH
79080: LD_INT 1
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 3
79089: PUSH
79090: LD_INT 0
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 3
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 3
79110: PUSH
79111: LD_INT 2
79113: NEG
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 5
79121: PUSH
79122: LD_INT 2
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79176: LD_ADDR_VAR 0 32
79180: PUSH
79181: LD_INT 4
79183: NEG
79184: PUSH
79185: LD_INT 0
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 4
79194: NEG
79195: PUSH
79196: LD_INT 1
79198: NEG
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 3
79206: NEG
79207: PUSH
79208: LD_INT 0
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 3
79217: NEG
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 4
79228: NEG
79229: PUSH
79230: LD_INT 1
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 5
79239: NEG
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 5
79250: NEG
79251: PUSH
79252: LD_INT 1
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 5
79262: NEG
79263: PUSH
79264: LD_INT 2
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 3
79274: NEG
79275: PUSH
79276: LD_INT 2
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 3
79285: NEG
79286: PUSH
79287: LD_INT 3
79289: NEG
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 3
79297: NEG
79298: PUSH
79299: LD_INT 4
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 2
79309: NEG
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 2
79321: NEG
79322: PUSH
79323: LD_INT 2
79325: NEG
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 3
79333: NEG
79334: PUSH
79335: LD_INT 2
79337: NEG
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 4
79345: NEG
79346: PUSH
79347: LD_INT 3
79349: NEG
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 4
79357: NEG
79358: PUSH
79359: LD_INT 4
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 2
79369: NEG
79370: PUSH
79371: LD_INT 4
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 4
79381: NEG
79382: PUSH
79383: LD_INT 2
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 0
79393: PUSH
79394: LD_INT 4
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 0
79404: PUSH
79405: LD_INT 5
79407: NEG
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 1
79415: PUSH
79416: LD_INT 4
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 1
79426: PUSH
79427: LD_INT 3
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 0
79437: PUSH
79438: LD_INT 3
79440: NEG
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 1
79448: NEG
79449: PUSH
79450: LD_INT 4
79452: NEG
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 1
79460: NEG
79461: PUSH
79462: LD_INT 5
79464: NEG
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 2
79472: PUSH
79473: LD_INT 3
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 2
79483: NEG
79484: PUSH
79485: LD_INT 5
79487: NEG
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 3
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 3
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 4
79516: PUSH
79517: LD_INT 0
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 4
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 3
79536: PUSH
79537: LD_INT 1
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 2
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 2
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: LD_INT 2
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 4
79578: PUSH
79579: LD_INT 2
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 4
79588: PUSH
79589: LD_INT 4
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 4
79598: PUSH
79599: LD_INT 3
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 5
79608: PUSH
79609: LD_INT 4
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 5
79618: PUSH
79619: LD_INT 5
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 4
79628: PUSH
79629: LD_INT 5
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 3
79638: PUSH
79639: LD_INT 4
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 3
79648: PUSH
79649: LD_INT 3
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 5
79658: PUSH
79659: LD_INT 3
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 3
79668: PUSH
79669: LD_INT 5
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: LIST
79694: LIST
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79723: LD_ADDR_VAR 0 33
79727: PUSH
79728: LD_INT 4
79730: NEG
79731: PUSH
79732: LD_INT 4
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 4
79742: NEG
79743: PUSH
79744: LD_INT 5
79746: NEG
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 3
79754: NEG
79755: PUSH
79756: LD_INT 4
79758: NEG
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 3
79766: NEG
79767: PUSH
79768: LD_INT 3
79770: NEG
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 4
79778: NEG
79779: PUSH
79780: LD_INT 3
79782: NEG
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 5
79790: NEG
79791: PUSH
79792: LD_INT 4
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 5
79802: NEG
79803: PUSH
79804: LD_INT 5
79806: NEG
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 3
79814: NEG
79815: PUSH
79816: LD_INT 5
79818: NEG
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 5
79826: NEG
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: LD_INT 3
79841: NEG
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 0
79849: PUSH
79850: LD_INT 4
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 1
79860: PUSH
79861: LD_INT 3
79863: NEG
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 0
79882: PUSH
79883: LD_INT 2
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 1
79893: NEG
79894: PUSH
79895: LD_INT 3
79897: NEG
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 1
79905: NEG
79906: PUSH
79907: LD_INT 4
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 2
79917: PUSH
79918: LD_INT 2
79920: NEG
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 2
79928: NEG
79929: PUSH
79930: LD_INT 4
79932: NEG
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 4
79940: PUSH
79941: LD_INT 0
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 4
79950: PUSH
79951: LD_INT 1
79953: NEG
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 5
79961: PUSH
79962: LD_INT 0
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 5
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 4
79981: PUSH
79982: LD_INT 1
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 3
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 3
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: LD_INT 2
80015: NEG
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 5
80023: PUSH
80024: LD_INT 2
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 3
80033: PUSH
80034: LD_INT 3
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 3
80043: PUSH
80044: LD_INT 2
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 4
80053: PUSH
80054: LD_INT 3
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 4
80063: PUSH
80064: LD_INT 4
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 3
80073: PUSH
80074: LD_INT 4
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 2
80083: PUSH
80084: LD_INT 3
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 2
80093: PUSH
80094: LD_INT 2
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 4
80103: PUSH
80104: LD_INT 2
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 2
80113: PUSH
80114: LD_INT 4
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 0
80123: PUSH
80124: LD_INT 4
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: LD_INT 3
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 1
80143: PUSH
80144: LD_INT 4
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 1
80153: PUSH
80154: LD_INT 5
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: LD_INT 5
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: NEG
80174: PUSH
80175: LD_INT 4
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: LD_INT 3
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: LD_INT 5
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 2
80205: NEG
80206: PUSH
80207: LD_INT 3
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: LIST
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80261: LD_ADDR_VAR 0 34
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: LD_INT 4
80271: NEG
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 0
80279: PUSH
80280: LD_INT 5
80282: NEG
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 1
80290: PUSH
80291: LD_INT 4
80293: NEG
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 1
80301: PUSH
80302: LD_INT 3
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: LD_INT 3
80315: NEG
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 1
80323: NEG
80324: PUSH
80325: LD_INT 4
80327: NEG
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: LD_INT 5
80339: NEG
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 2
80347: PUSH
80348: LD_INT 3
80350: NEG
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 2
80358: NEG
80359: PUSH
80360: LD_INT 5
80362: NEG
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 3
80370: PUSH
80371: LD_INT 0
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 3
80380: PUSH
80381: LD_INT 1
80383: NEG
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 4
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 4
80401: PUSH
80402: LD_INT 1
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 3
80411: PUSH
80412: LD_INT 1
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 2
80421: PUSH
80422: LD_INT 0
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 2
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 2
80442: PUSH
80443: LD_INT 2
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 4
80453: PUSH
80454: LD_INT 2
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 4
80463: PUSH
80464: LD_INT 4
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 4
80473: PUSH
80474: LD_INT 3
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 5
80483: PUSH
80484: LD_INT 4
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 5
80493: PUSH
80494: LD_INT 5
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 4
80503: PUSH
80504: LD_INT 5
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 3
80513: PUSH
80514: LD_INT 4
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 3
80523: PUSH
80524: LD_INT 3
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 5
80533: PUSH
80534: LD_INT 3
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 3
80543: PUSH
80544: LD_INT 5
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 0
80553: PUSH
80554: LD_INT 3
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: LD_INT 2
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 3
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: LD_INT 4
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 4
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 3
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 2
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 2
80625: PUSH
80626: LD_INT 4
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 2
80635: NEG
80636: PUSH
80637: LD_INT 2
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 4
80646: NEG
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 4
80657: NEG
80658: PUSH
80659: LD_INT 1
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 3
80669: NEG
80670: PUSH
80671: LD_INT 0
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 3
80680: NEG
80681: PUSH
80682: LD_INT 1
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 4
80691: NEG
80692: PUSH
80693: LD_INT 1
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 5
80702: NEG
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 5
80713: NEG
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 5
80725: NEG
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 3
80737: NEG
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: ST_TO_ADDR
// end ; end ;
80793: GO 80796
80795: POP
// case btype of b_depot , b_warehouse :
80796: LD_VAR 0 1
80800: PUSH
80801: LD_INT 0
80803: DOUBLE
80804: EQUAL
80805: IFTRUE 80815
80807: LD_INT 1
80809: DOUBLE
80810: EQUAL
80811: IFTRUE 80815
80813: GO 81016
80815: POP
// case nation of nation_american :
80816: LD_VAR 0 5
80820: PUSH
80821: LD_INT 1
80823: DOUBLE
80824: EQUAL
80825: IFTRUE 80829
80827: GO 80885
80829: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80830: LD_ADDR_VAR 0 9
80834: PUSH
80835: LD_VAR 0 11
80839: PUSH
80840: LD_VAR 0 12
80844: PUSH
80845: LD_VAR 0 13
80849: PUSH
80850: LD_VAR 0 14
80854: PUSH
80855: LD_VAR 0 15
80859: PUSH
80860: LD_VAR 0 16
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: PUSH
80873: LD_VAR 0 4
80877: PUSH
80878: LD_INT 1
80880: PLUS
80881: ARRAY
80882: ST_TO_ADDR
80883: GO 81014
80885: LD_INT 2
80887: DOUBLE
80888: EQUAL
80889: IFTRUE 80893
80891: GO 80949
80893: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80894: LD_ADDR_VAR 0 9
80898: PUSH
80899: LD_VAR 0 17
80903: PUSH
80904: LD_VAR 0 18
80908: PUSH
80909: LD_VAR 0 19
80913: PUSH
80914: LD_VAR 0 20
80918: PUSH
80919: LD_VAR 0 21
80923: PUSH
80924: LD_VAR 0 22
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: PUSH
80937: LD_VAR 0 4
80941: PUSH
80942: LD_INT 1
80944: PLUS
80945: ARRAY
80946: ST_TO_ADDR
80947: GO 81014
80949: LD_INT 3
80951: DOUBLE
80952: EQUAL
80953: IFTRUE 80957
80955: GO 81013
80957: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80958: LD_ADDR_VAR 0 9
80962: PUSH
80963: LD_VAR 0 23
80967: PUSH
80968: LD_VAR 0 24
80972: PUSH
80973: LD_VAR 0 25
80977: PUSH
80978: LD_VAR 0 26
80982: PUSH
80983: LD_VAR 0 27
80987: PUSH
80988: LD_VAR 0 28
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: PUSH
81001: LD_VAR 0 4
81005: PUSH
81006: LD_INT 1
81008: PLUS
81009: ARRAY
81010: ST_TO_ADDR
81011: GO 81014
81013: POP
81014: GO 81569
81016: LD_INT 2
81018: DOUBLE
81019: EQUAL
81020: IFTRUE 81030
81022: LD_INT 3
81024: DOUBLE
81025: EQUAL
81026: IFTRUE 81030
81028: GO 81086
81030: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81031: LD_ADDR_VAR 0 9
81035: PUSH
81036: LD_VAR 0 29
81040: PUSH
81041: LD_VAR 0 30
81045: PUSH
81046: LD_VAR 0 31
81050: PUSH
81051: LD_VAR 0 32
81055: PUSH
81056: LD_VAR 0 33
81060: PUSH
81061: LD_VAR 0 34
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: PUSH
81074: LD_VAR 0 4
81078: PUSH
81079: LD_INT 1
81081: PLUS
81082: ARRAY
81083: ST_TO_ADDR
81084: GO 81569
81086: LD_INT 16
81088: DOUBLE
81089: EQUAL
81090: IFTRUE 81148
81092: LD_INT 17
81094: DOUBLE
81095: EQUAL
81096: IFTRUE 81148
81098: LD_INT 18
81100: DOUBLE
81101: EQUAL
81102: IFTRUE 81148
81104: LD_INT 19
81106: DOUBLE
81107: EQUAL
81108: IFTRUE 81148
81110: LD_INT 22
81112: DOUBLE
81113: EQUAL
81114: IFTRUE 81148
81116: LD_INT 20
81118: DOUBLE
81119: EQUAL
81120: IFTRUE 81148
81122: LD_INT 21
81124: DOUBLE
81125: EQUAL
81126: IFTRUE 81148
81128: LD_INT 23
81130: DOUBLE
81131: EQUAL
81132: IFTRUE 81148
81134: LD_INT 24
81136: DOUBLE
81137: EQUAL
81138: IFTRUE 81148
81140: LD_INT 25
81142: DOUBLE
81143: EQUAL
81144: IFTRUE 81148
81146: GO 81204
81148: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81149: LD_ADDR_VAR 0 9
81153: PUSH
81154: LD_VAR 0 35
81158: PUSH
81159: LD_VAR 0 36
81163: PUSH
81164: LD_VAR 0 37
81168: PUSH
81169: LD_VAR 0 38
81173: PUSH
81174: LD_VAR 0 39
81178: PUSH
81179: LD_VAR 0 40
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: PUSH
81192: LD_VAR 0 4
81196: PUSH
81197: LD_INT 1
81199: PLUS
81200: ARRAY
81201: ST_TO_ADDR
81202: GO 81569
81204: LD_INT 6
81206: DOUBLE
81207: EQUAL
81208: IFTRUE 81260
81210: LD_INT 7
81212: DOUBLE
81213: EQUAL
81214: IFTRUE 81260
81216: LD_INT 8
81218: DOUBLE
81219: EQUAL
81220: IFTRUE 81260
81222: LD_INT 13
81224: DOUBLE
81225: EQUAL
81226: IFTRUE 81260
81228: LD_INT 12
81230: DOUBLE
81231: EQUAL
81232: IFTRUE 81260
81234: LD_INT 15
81236: DOUBLE
81237: EQUAL
81238: IFTRUE 81260
81240: LD_INT 11
81242: DOUBLE
81243: EQUAL
81244: IFTRUE 81260
81246: LD_INT 14
81248: DOUBLE
81249: EQUAL
81250: IFTRUE 81260
81252: LD_INT 10
81254: DOUBLE
81255: EQUAL
81256: IFTRUE 81260
81258: GO 81316
81260: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81261: LD_ADDR_VAR 0 9
81265: PUSH
81266: LD_VAR 0 41
81270: PUSH
81271: LD_VAR 0 42
81275: PUSH
81276: LD_VAR 0 43
81280: PUSH
81281: LD_VAR 0 44
81285: PUSH
81286: LD_VAR 0 45
81290: PUSH
81291: LD_VAR 0 46
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: PUSH
81304: LD_VAR 0 4
81308: PUSH
81309: LD_INT 1
81311: PLUS
81312: ARRAY
81313: ST_TO_ADDR
81314: GO 81569
81316: LD_INT 36
81318: DOUBLE
81319: EQUAL
81320: IFTRUE 81324
81322: GO 81380
81324: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81325: LD_ADDR_VAR 0 9
81329: PUSH
81330: LD_VAR 0 47
81334: PUSH
81335: LD_VAR 0 48
81339: PUSH
81340: LD_VAR 0 49
81344: PUSH
81345: LD_VAR 0 50
81349: PUSH
81350: LD_VAR 0 51
81354: PUSH
81355: LD_VAR 0 52
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: PUSH
81368: LD_VAR 0 4
81372: PUSH
81373: LD_INT 1
81375: PLUS
81376: ARRAY
81377: ST_TO_ADDR
81378: GO 81569
81380: LD_INT 4
81382: DOUBLE
81383: EQUAL
81384: IFTRUE 81406
81386: LD_INT 5
81388: DOUBLE
81389: EQUAL
81390: IFTRUE 81406
81392: LD_INT 34
81394: DOUBLE
81395: EQUAL
81396: IFTRUE 81406
81398: LD_INT 37
81400: DOUBLE
81401: EQUAL
81402: IFTRUE 81406
81404: GO 81462
81406: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81407: LD_ADDR_VAR 0 9
81411: PUSH
81412: LD_VAR 0 53
81416: PUSH
81417: LD_VAR 0 54
81421: PUSH
81422: LD_VAR 0 55
81426: PUSH
81427: LD_VAR 0 56
81431: PUSH
81432: LD_VAR 0 57
81436: PUSH
81437: LD_VAR 0 58
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: PUSH
81450: LD_VAR 0 4
81454: PUSH
81455: LD_INT 1
81457: PLUS
81458: ARRAY
81459: ST_TO_ADDR
81460: GO 81569
81462: LD_INT 31
81464: DOUBLE
81465: EQUAL
81466: IFTRUE 81512
81468: LD_INT 32
81470: DOUBLE
81471: EQUAL
81472: IFTRUE 81512
81474: LD_INT 33
81476: DOUBLE
81477: EQUAL
81478: IFTRUE 81512
81480: LD_INT 27
81482: DOUBLE
81483: EQUAL
81484: IFTRUE 81512
81486: LD_INT 26
81488: DOUBLE
81489: EQUAL
81490: IFTRUE 81512
81492: LD_INT 28
81494: DOUBLE
81495: EQUAL
81496: IFTRUE 81512
81498: LD_INT 29
81500: DOUBLE
81501: EQUAL
81502: IFTRUE 81512
81504: LD_INT 30
81506: DOUBLE
81507: EQUAL
81508: IFTRUE 81512
81510: GO 81568
81512: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81513: LD_ADDR_VAR 0 9
81517: PUSH
81518: LD_VAR 0 59
81522: PUSH
81523: LD_VAR 0 60
81527: PUSH
81528: LD_VAR 0 61
81532: PUSH
81533: LD_VAR 0 62
81537: PUSH
81538: LD_VAR 0 63
81542: PUSH
81543: LD_VAR 0 64
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: PUSH
81556: LD_VAR 0 4
81560: PUSH
81561: LD_INT 1
81563: PLUS
81564: ARRAY
81565: ST_TO_ADDR
81566: GO 81569
81568: POP
// temp_list2 = [ ] ;
81569: LD_ADDR_VAR 0 10
81573: PUSH
81574: EMPTY
81575: ST_TO_ADDR
// for i in temp_list do
81576: LD_ADDR_VAR 0 8
81580: PUSH
81581: LD_VAR 0 9
81585: PUSH
81586: FOR_IN
81587: IFFALSE 81639
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81589: LD_ADDR_VAR 0 10
81593: PUSH
81594: LD_VAR 0 10
81598: PUSH
81599: LD_VAR 0 8
81603: PUSH
81604: LD_INT 1
81606: ARRAY
81607: PUSH
81608: LD_VAR 0 2
81612: PLUS
81613: PUSH
81614: LD_VAR 0 8
81618: PUSH
81619: LD_INT 2
81621: ARRAY
81622: PUSH
81623: LD_VAR 0 3
81627: PLUS
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: EMPTY
81634: LIST
81635: ADD
81636: ST_TO_ADDR
81637: GO 81586
81639: POP
81640: POP
// result = temp_list2 ;
81641: LD_ADDR_VAR 0 7
81645: PUSH
81646: LD_VAR 0 10
81650: ST_TO_ADDR
// end ;
81651: LD_VAR 0 7
81655: RET
// export function EnemyInRange ( unit , dist ) ; begin
81656: LD_INT 0
81658: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81659: LD_ADDR_VAR 0 3
81663: PUSH
81664: LD_VAR 0 1
81668: PPUSH
81669: CALL_OW 255
81673: PPUSH
81674: LD_VAR 0 1
81678: PPUSH
81679: CALL_OW 250
81683: PPUSH
81684: LD_VAR 0 1
81688: PPUSH
81689: CALL_OW 251
81693: PPUSH
81694: LD_VAR 0 2
81698: PPUSH
81699: CALL 55058 0 4
81703: PUSH
81704: LD_INT 4
81706: ARRAY
81707: ST_TO_ADDR
// end ;
81708: LD_VAR 0 3
81712: RET
// export function PlayerSeeMe ( unit ) ; begin
81713: LD_INT 0
81715: PPUSH
// result := See ( your_side , unit ) ;
81716: LD_ADDR_VAR 0 2
81720: PUSH
81721: LD_OWVAR 2
81725: PPUSH
81726: LD_VAR 0 1
81730: PPUSH
81731: CALL_OW 292
81735: ST_TO_ADDR
// end ;
81736: LD_VAR 0 2
81740: RET
// export function ReverseDir ( unit ) ; begin
81741: LD_INT 0
81743: PPUSH
// if not unit then
81744: LD_VAR 0 1
81748: NOT
81749: IFFALSE 81753
// exit ;
81751: GO 81776
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81753: LD_ADDR_VAR 0 2
81757: PUSH
81758: LD_VAR 0 1
81762: PPUSH
81763: CALL_OW 254
81767: PUSH
81768: LD_INT 3
81770: PLUS
81771: PUSH
81772: LD_INT 6
81774: MOD
81775: ST_TO_ADDR
// end ;
81776: LD_VAR 0 2
81780: RET
// export function ReverseArray ( array ) ; var i ; begin
81781: LD_INT 0
81783: PPUSH
81784: PPUSH
// if not array then
81785: LD_VAR 0 1
81789: NOT
81790: IFFALSE 81794
// exit ;
81792: GO 81849
// result := [ ] ;
81794: LD_ADDR_VAR 0 2
81798: PUSH
81799: EMPTY
81800: ST_TO_ADDR
// for i := array downto 1 do
81801: LD_ADDR_VAR 0 3
81805: PUSH
81806: DOUBLE
81807: LD_VAR 0 1
81811: INC
81812: ST_TO_ADDR
81813: LD_INT 1
81815: PUSH
81816: FOR_DOWNTO
81817: IFFALSE 81847
// result := Join ( result , array [ i ] ) ;
81819: LD_ADDR_VAR 0 2
81823: PUSH
81824: LD_VAR 0 2
81828: PPUSH
81829: LD_VAR 0 1
81833: PUSH
81834: LD_VAR 0 3
81838: ARRAY
81839: PPUSH
81840: CALL 86493 0 2
81844: ST_TO_ADDR
81845: GO 81816
81847: POP
81848: POP
// end ;
81849: LD_VAR 0 2
81853: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81854: LD_INT 0
81856: PPUSH
81857: PPUSH
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
// if not unit or not hexes then
81862: LD_VAR 0 1
81866: NOT
81867: PUSH
81868: LD_VAR 0 2
81872: NOT
81873: OR
81874: IFFALSE 81878
// exit ;
81876: GO 82001
// dist := 9999 ;
81878: LD_ADDR_VAR 0 5
81882: PUSH
81883: LD_INT 9999
81885: ST_TO_ADDR
// for i = 1 to hexes do
81886: LD_ADDR_VAR 0 4
81890: PUSH
81891: DOUBLE
81892: LD_INT 1
81894: DEC
81895: ST_TO_ADDR
81896: LD_VAR 0 2
81900: PUSH
81901: FOR_TO
81902: IFFALSE 81989
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81904: LD_ADDR_VAR 0 6
81908: PUSH
81909: LD_VAR 0 1
81913: PPUSH
81914: LD_VAR 0 2
81918: PUSH
81919: LD_VAR 0 4
81923: ARRAY
81924: PUSH
81925: LD_INT 1
81927: ARRAY
81928: PPUSH
81929: LD_VAR 0 2
81933: PUSH
81934: LD_VAR 0 4
81938: ARRAY
81939: PUSH
81940: LD_INT 2
81942: ARRAY
81943: PPUSH
81944: CALL_OW 297
81948: ST_TO_ADDR
// if tdist < dist then
81949: LD_VAR 0 6
81953: PUSH
81954: LD_VAR 0 5
81958: LESS
81959: IFFALSE 81987
// begin hex := hexes [ i ] ;
81961: LD_ADDR_VAR 0 8
81965: PUSH
81966: LD_VAR 0 2
81970: PUSH
81971: LD_VAR 0 4
81975: ARRAY
81976: ST_TO_ADDR
// dist := tdist ;
81977: LD_ADDR_VAR 0 5
81981: PUSH
81982: LD_VAR 0 6
81986: ST_TO_ADDR
// end ; end ;
81987: GO 81901
81989: POP
81990: POP
// result := hex ;
81991: LD_ADDR_VAR 0 3
81995: PUSH
81996: LD_VAR 0 8
82000: ST_TO_ADDR
// end ;
82001: LD_VAR 0 3
82005: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82006: LD_INT 0
82008: PPUSH
82009: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82010: LD_VAR 0 1
82014: NOT
82015: PUSH
82016: LD_VAR 0 1
82020: PUSH
82021: LD_INT 21
82023: PUSH
82024: LD_INT 2
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 23
82033: PUSH
82034: LD_INT 2
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PPUSH
82045: CALL_OW 69
82049: IN
82050: NOT
82051: OR
82052: IFFALSE 82056
// exit ;
82054: GO 82103
// for i = 1 to 3 do
82056: LD_ADDR_VAR 0 3
82060: PUSH
82061: DOUBLE
82062: LD_INT 1
82064: DEC
82065: ST_TO_ADDR
82066: LD_INT 3
82068: PUSH
82069: FOR_TO
82070: IFFALSE 82101
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82072: LD_VAR 0 1
82076: PPUSH
82077: CALL_OW 250
82081: PPUSH
82082: LD_VAR 0 1
82086: PPUSH
82087: CALL_OW 251
82091: PPUSH
82092: LD_INT 1
82094: PPUSH
82095: CALL_OW 453
82099: GO 82069
82101: POP
82102: POP
// end ;
82103: LD_VAR 0 2
82107: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82108: LD_INT 0
82110: PPUSH
82111: PPUSH
82112: PPUSH
82113: PPUSH
82114: PPUSH
82115: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82116: LD_VAR 0 1
82120: NOT
82121: PUSH
82122: LD_VAR 0 2
82126: NOT
82127: OR
82128: PUSH
82129: LD_VAR 0 1
82133: PPUSH
82134: CALL_OW 314
82138: OR
82139: IFFALSE 82143
// exit ;
82141: GO 82610
// if GetLives ( i ) < 250 then
82143: LD_VAR 0 4
82147: PPUSH
82148: CALL_OW 256
82152: PUSH
82153: LD_INT 250
82155: LESS
82156: IFFALSE 82169
// begin ComAutodestruct ( i ) ;
82158: LD_VAR 0 4
82162: PPUSH
82163: CALL 82006 0 1
// exit ;
82167: GO 82610
// end ; x := GetX ( enemy_unit ) ;
82169: LD_ADDR_VAR 0 7
82173: PUSH
82174: LD_VAR 0 2
82178: PPUSH
82179: CALL_OW 250
82183: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82184: LD_ADDR_VAR 0 8
82188: PUSH
82189: LD_VAR 0 2
82193: PPUSH
82194: CALL_OW 251
82198: ST_TO_ADDR
// if not x or not y then
82199: LD_VAR 0 7
82203: NOT
82204: PUSH
82205: LD_VAR 0 8
82209: NOT
82210: OR
82211: IFFALSE 82215
// exit ;
82213: GO 82610
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82215: LD_ADDR_VAR 0 6
82219: PUSH
82220: LD_VAR 0 7
82224: PPUSH
82225: LD_INT 0
82227: PPUSH
82228: LD_INT 4
82230: PPUSH
82231: CALL_OW 272
82235: PUSH
82236: LD_VAR 0 8
82240: PPUSH
82241: LD_INT 0
82243: PPUSH
82244: LD_INT 4
82246: PPUSH
82247: CALL_OW 273
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_VAR 0 7
82260: PPUSH
82261: LD_INT 1
82263: PPUSH
82264: LD_INT 4
82266: PPUSH
82267: CALL_OW 272
82271: PUSH
82272: LD_VAR 0 8
82276: PPUSH
82277: LD_INT 1
82279: PPUSH
82280: LD_INT 4
82282: PPUSH
82283: CALL_OW 273
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_VAR 0 7
82296: PPUSH
82297: LD_INT 2
82299: PPUSH
82300: LD_INT 4
82302: PPUSH
82303: CALL_OW 272
82307: PUSH
82308: LD_VAR 0 8
82312: PPUSH
82313: LD_INT 2
82315: PPUSH
82316: LD_INT 4
82318: PPUSH
82319: CALL_OW 273
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_VAR 0 7
82332: PPUSH
82333: LD_INT 3
82335: PPUSH
82336: LD_INT 4
82338: PPUSH
82339: CALL_OW 272
82343: PUSH
82344: LD_VAR 0 8
82348: PPUSH
82349: LD_INT 3
82351: PPUSH
82352: LD_INT 4
82354: PPUSH
82355: CALL_OW 273
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_VAR 0 7
82368: PPUSH
82369: LD_INT 4
82371: PPUSH
82372: LD_INT 4
82374: PPUSH
82375: CALL_OW 272
82379: PUSH
82380: LD_VAR 0 8
82384: PPUSH
82385: LD_INT 4
82387: PPUSH
82388: LD_INT 4
82390: PPUSH
82391: CALL_OW 273
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_VAR 0 7
82404: PPUSH
82405: LD_INT 5
82407: PPUSH
82408: LD_INT 4
82410: PPUSH
82411: CALL_OW 272
82415: PUSH
82416: LD_VAR 0 8
82420: PPUSH
82421: LD_INT 5
82423: PPUSH
82424: LD_INT 4
82426: PPUSH
82427: CALL_OW 273
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: LIST
82442: LIST
82443: ST_TO_ADDR
// for i = tmp downto 1 do
82444: LD_ADDR_VAR 0 4
82448: PUSH
82449: DOUBLE
82450: LD_VAR 0 6
82454: INC
82455: ST_TO_ADDR
82456: LD_INT 1
82458: PUSH
82459: FOR_DOWNTO
82460: IFFALSE 82561
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82462: LD_VAR 0 6
82466: PUSH
82467: LD_VAR 0 4
82471: ARRAY
82472: PUSH
82473: LD_INT 1
82475: ARRAY
82476: PPUSH
82477: LD_VAR 0 6
82481: PUSH
82482: LD_VAR 0 4
82486: ARRAY
82487: PUSH
82488: LD_INT 2
82490: ARRAY
82491: PPUSH
82492: CALL_OW 488
82496: NOT
82497: PUSH
82498: LD_VAR 0 6
82502: PUSH
82503: LD_VAR 0 4
82507: ARRAY
82508: PUSH
82509: LD_INT 1
82511: ARRAY
82512: PPUSH
82513: LD_VAR 0 6
82517: PUSH
82518: LD_VAR 0 4
82522: ARRAY
82523: PUSH
82524: LD_INT 2
82526: ARRAY
82527: PPUSH
82528: CALL_OW 428
82532: PUSH
82533: LD_INT 0
82535: NONEQUAL
82536: OR
82537: IFFALSE 82559
// tmp := Delete ( tmp , i ) ;
82539: LD_ADDR_VAR 0 6
82543: PUSH
82544: LD_VAR 0 6
82548: PPUSH
82549: LD_VAR 0 4
82553: PPUSH
82554: CALL_OW 3
82558: ST_TO_ADDR
82559: GO 82459
82561: POP
82562: POP
// j := GetClosestHex ( unit , tmp ) ;
82563: LD_ADDR_VAR 0 5
82567: PUSH
82568: LD_VAR 0 1
82572: PPUSH
82573: LD_VAR 0 6
82577: PPUSH
82578: CALL 81854 0 2
82582: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82583: LD_VAR 0 1
82587: PPUSH
82588: LD_VAR 0 5
82592: PUSH
82593: LD_INT 1
82595: ARRAY
82596: PPUSH
82597: LD_VAR 0 5
82601: PUSH
82602: LD_INT 2
82604: ARRAY
82605: PPUSH
82606: CALL_OW 111
// end ;
82610: LD_VAR 0 3
82614: RET
// export function PrepareApemanSoldier ( ) ; begin
82615: LD_INT 0
82617: PPUSH
// uc_nation := 0 ;
82618: LD_ADDR_OWVAR 21
82622: PUSH
82623: LD_INT 0
82625: ST_TO_ADDR
// hc_sex := sex_male ;
82626: LD_ADDR_OWVAR 27
82630: PUSH
82631: LD_INT 1
82633: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82634: LD_ADDR_OWVAR 28
82638: PUSH
82639: LD_INT 15
82641: ST_TO_ADDR
// hc_gallery :=  ;
82642: LD_ADDR_OWVAR 33
82646: PUSH
82647: LD_STRING 
82649: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82650: LD_ADDR_OWVAR 31
82654: PUSH
82655: LD_INT 0
82657: PPUSH
82658: LD_INT 3
82660: PPUSH
82661: CALL_OW 12
82665: PUSH
82666: LD_INT 0
82668: PPUSH
82669: LD_INT 3
82671: PPUSH
82672: CALL_OW 12
82676: PUSH
82677: LD_INT 0
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: ST_TO_ADDR
// end ;
82689: LD_VAR 0 1
82693: RET
// export function PrepareApemanEngineer ( ) ; begin
82694: LD_INT 0
82696: PPUSH
// uc_nation := 0 ;
82697: LD_ADDR_OWVAR 21
82701: PUSH
82702: LD_INT 0
82704: ST_TO_ADDR
// hc_sex := sex_male ;
82705: LD_ADDR_OWVAR 27
82709: PUSH
82710: LD_INT 1
82712: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82713: LD_ADDR_OWVAR 28
82717: PUSH
82718: LD_INT 16
82720: ST_TO_ADDR
// hc_gallery :=  ;
82721: LD_ADDR_OWVAR 33
82725: PUSH
82726: LD_STRING 
82728: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82729: LD_ADDR_OWVAR 31
82733: PUSH
82734: LD_INT 0
82736: PPUSH
82737: LD_INT 3
82739: PPUSH
82740: CALL_OW 12
82744: PUSH
82745: LD_INT 0
82747: PPUSH
82748: LD_INT 3
82750: PPUSH
82751: CALL_OW 12
82755: PUSH
82756: LD_INT 0
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: ST_TO_ADDR
// end ;
82768: LD_VAR 0 1
82772: RET
// export function PrepareApeman ( agressivity ) ; begin
82773: LD_INT 0
82775: PPUSH
// uc_side := 0 ;
82776: LD_ADDR_OWVAR 20
82780: PUSH
82781: LD_INT 0
82783: ST_TO_ADDR
// uc_nation := 0 ;
82784: LD_ADDR_OWVAR 21
82788: PUSH
82789: LD_INT 0
82791: ST_TO_ADDR
// hc_sex := sex_male ;
82792: LD_ADDR_OWVAR 27
82796: PUSH
82797: LD_INT 1
82799: ST_TO_ADDR
// hc_class := class_apeman ;
82800: LD_ADDR_OWVAR 28
82804: PUSH
82805: LD_INT 12
82807: ST_TO_ADDR
// hc_gallery :=  ;
82808: LD_ADDR_OWVAR 33
82812: PUSH
82813: LD_STRING 
82815: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82816: LD_ADDR_OWVAR 35
82820: PUSH
82821: LD_VAR 0 1
82825: NEG
82826: PPUSH
82827: LD_VAR 0 1
82831: PPUSH
82832: CALL_OW 12
82836: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82837: LD_ADDR_OWVAR 31
82841: PUSH
82842: LD_INT 0
82844: PPUSH
82845: LD_INT 3
82847: PPUSH
82848: CALL_OW 12
82852: PUSH
82853: LD_INT 0
82855: PPUSH
82856: LD_INT 3
82858: PPUSH
82859: CALL_OW 12
82863: PUSH
82864: LD_INT 0
82866: PUSH
82867: LD_INT 0
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: ST_TO_ADDR
// end ;
82876: LD_VAR 0 2
82880: RET
// export function PrepareTiger ( agressivity ) ; begin
82881: LD_INT 0
82883: PPUSH
// uc_side := 0 ;
82884: LD_ADDR_OWVAR 20
82888: PUSH
82889: LD_INT 0
82891: ST_TO_ADDR
// uc_nation := 0 ;
82892: LD_ADDR_OWVAR 21
82896: PUSH
82897: LD_INT 0
82899: ST_TO_ADDR
// hc_class := class_tiger ;
82900: LD_ADDR_OWVAR 28
82904: PUSH
82905: LD_INT 14
82907: ST_TO_ADDR
// hc_gallery :=  ;
82908: LD_ADDR_OWVAR 33
82912: PUSH
82913: LD_STRING 
82915: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82916: LD_ADDR_OWVAR 35
82920: PUSH
82921: LD_VAR 0 1
82925: NEG
82926: PPUSH
82927: LD_VAR 0 1
82931: PPUSH
82932: CALL_OW 12
82936: ST_TO_ADDR
// end ;
82937: LD_VAR 0 2
82941: RET
// export function PrepareEnchidna ( ) ; begin
82942: LD_INT 0
82944: PPUSH
// uc_side := 0 ;
82945: LD_ADDR_OWVAR 20
82949: PUSH
82950: LD_INT 0
82952: ST_TO_ADDR
// uc_nation := 0 ;
82953: LD_ADDR_OWVAR 21
82957: PUSH
82958: LD_INT 0
82960: ST_TO_ADDR
// hc_class := class_baggie ;
82961: LD_ADDR_OWVAR 28
82965: PUSH
82966: LD_INT 13
82968: ST_TO_ADDR
// hc_gallery :=  ;
82969: LD_ADDR_OWVAR 33
82973: PUSH
82974: LD_STRING 
82976: ST_TO_ADDR
// end ;
82977: LD_VAR 0 1
82981: RET
// export function PrepareFrog ( ) ; begin
82982: LD_INT 0
82984: PPUSH
// uc_side := 0 ;
82985: LD_ADDR_OWVAR 20
82989: PUSH
82990: LD_INT 0
82992: ST_TO_ADDR
// uc_nation := 0 ;
82993: LD_ADDR_OWVAR 21
82997: PUSH
82998: LD_INT 0
83000: ST_TO_ADDR
// hc_class := class_frog ;
83001: LD_ADDR_OWVAR 28
83005: PUSH
83006: LD_INT 19
83008: ST_TO_ADDR
// hc_gallery :=  ;
83009: LD_ADDR_OWVAR 33
83013: PUSH
83014: LD_STRING 
83016: ST_TO_ADDR
// end ;
83017: LD_VAR 0 1
83021: RET
// export function PrepareFish ( ) ; begin
83022: LD_INT 0
83024: PPUSH
// uc_side := 0 ;
83025: LD_ADDR_OWVAR 20
83029: PUSH
83030: LD_INT 0
83032: ST_TO_ADDR
// uc_nation := 0 ;
83033: LD_ADDR_OWVAR 21
83037: PUSH
83038: LD_INT 0
83040: ST_TO_ADDR
// hc_class := class_fish ;
83041: LD_ADDR_OWVAR 28
83045: PUSH
83046: LD_INT 20
83048: ST_TO_ADDR
// hc_gallery :=  ;
83049: LD_ADDR_OWVAR 33
83053: PUSH
83054: LD_STRING 
83056: ST_TO_ADDR
// end ;
83057: LD_VAR 0 1
83061: RET
// export function PrepareBird ( ) ; begin
83062: LD_INT 0
83064: PPUSH
// uc_side := 0 ;
83065: LD_ADDR_OWVAR 20
83069: PUSH
83070: LD_INT 0
83072: ST_TO_ADDR
// uc_nation := 0 ;
83073: LD_ADDR_OWVAR 21
83077: PUSH
83078: LD_INT 0
83080: ST_TO_ADDR
// hc_class := class_phororhacos ;
83081: LD_ADDR_OWVAR 28
83085: PUSH
83086: LD_INT 18
83088: ST_TO_ADDR
// hc_gallery :=  ;
83089: LD_ADDR_OWVAR 33
83093: PUSH
83094: LD_STRING 
83096: ST_TO_ADDR
// end ;
83097: LD_VAR 0 1
83101: RET
// export function PrepareHorse ( ) ; begin
83102: LD_INT 0
83104: PPUSH
// uc_side := 0 ;
83105: LD_ADDR_OWVAR 20
83109: PUSH
83110: LD_INT 0
83112: ST_TO_ADDR
// uc_nation := 0 ;
83113: LD_ADDR_OWVAR 21
83117: PUSH
83118: LD_INT 0
83120: ST_TO_ADDR
// hc_class := class_horse ;
83121: LD_ADDR_OWVAR 28
83125: PUSH
83126: LD_INT 21
83128: ST_TO_ADDR
// hc_gallery :=  ;
83129: LD_ADDR_OWVAR 33
83133: PUSH
83134: LD_STRING 
83136: ST_TO_ADDR
// end ;
83137: LD_VAR 0 1
83141: RET
// export function PrepareMastodont ( ) ; begin
83142: LD_INT 0
83144: PPUSH
// uc_side := 0 ;
83145: LD_ADDR_OWVAR 20
83149: PUSH
83150: LD_INT 0
83152: ST_TO_ADDR
// uc_nation := 0 ;
83153: LD_ADDR_OWVAR 21
83157: PUSH
83158: LD_INT 0
83160: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83161: LD_ADDR_OWVAR 37
83165: PUSH
83166: LD_INT 31
83168: ST_TO_ADDR
// vc_control := control_rider ;
83169: LD_ADDR_OWVAR 38
83173: PUSH
83174: LD_INT 4
83176: ST_TO_ADDR
// end ;
83177: LD_VAR 0 1
83181: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83182: LD_INT 0
83184: PPUSH
83185: PPUSH
83186: PPUSH
// uc_side = 0 ;
83187: LD_ADDR_OWVAR 20
83191: PUSH
83192: LD_INT 0
83194: ST_TO_ADDR
// uc_nation = 0 ;
83195: LD_ADDR_OWVAR 21
83199: PUSH
83200: LD_INT 0
83202: ST_TO_ADDR
// InitHc_All ( ) ;
83203: CALL_OW 584
// InitVc ;
83207: CALL_OW 20
// if mastodonts then
83211: LD_VAR 0 6
83215: IFFALSE 83282
// for i = 1 to mastodonts do
83217: LD_ADDR_VAR 0 11
83221: PUSH
83222: DOUBLE
83223: LD_INT 1
83225: DEC
83226: ST_TO_ADDR
83227: LD_VAR 0 6
83231: PUSH
83232: FOR_TO
83233: IFFALSE 83280
// begin vc_chassis := 31 ;
83235: LD_ADDR_OWVAR 37
83239: PUSH
83240: LD_INT 31
83242: ST_TO_ADDR
// vc_control := control_rider ;
83243: LD_ADDR_OWVAR 38
83247: PUSH
83248: LD_INT 4
83250: ST_TO_ADDR
// animal := CreateVehicle ;
83251: LD_ADDR_VAR 0 12
83255: PUSH
83256: CALL_OW 45
83260: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83261: LD_VAR 0 12
83265: PPUSH
83266: LD_VAR 0 8
83270: PPUSH
83271: LD_INT 0
83273: PPUSH
83274: CALL 85410 0 3
// end ;
83278: GO 83232
83280: POP
83281: POP
// if horses then
83282: LD_VAR 0 5
83286: IFFALSE 83353
// for i = 1 to horses do
83288: LD_ADDR_VAR 0 11
83292: PUSH
83293: DOUBLE
83294: LD_INT 1
83296: DEC
83297: ST_TO_ADDR
83298: LD_VAR 0 5
83302: PUSH
83303: FOR_TO
83304: IFFALSE 83351
// begin hc_class := 21 ;
83306: LD_ADDR_OWVAR 28
83310: PUSH
83311: LD_INT 21
83313: ST_TO_ADDR
// hc_gallery :=  ;
83314: LD_ADDR_OWVAR 33
83318: PUSH
83319: LD_STRING 
83321: ST_TO_ADDR
// animal := CreateHuman ;
83322: LD_ADDR_VAR 0 12
83326: PUSH
83327: CALL_OW 44
83331: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83332: LD_VAR 0 12
83336: PPUSH
83337: LD_VAR 0 8
83341: PPUSH
83342: LD_INT 0
83344: PPUSH
83345: CALL 85410 0 3
// end ;
83349: GO 83303
83351: POP
83352: POP
// if birds then
83353: LD_VAR 0 1
83357: IFFALSE 83424
// for i = 1 to birds do
83359: LD_ADDR_VAR 0 11
83363: PUSH
83364: DOUBLE
83365: LD_INT 1
83367: DEC
83368: ST_TO_ADDR
83369: LD_VAR 0 1
83373: PUSH
83374: FOR_TO
83375: IFFALSE 83422
// begin hc_class = 18 ;
83377: LD_ADDR_OWVAR 28
83381: PUSH
83382: LD_INT 18
83384: ST_TO_ADDR
// hc_gallery =  ;
83385: LD_ADDR_OWVAR 33
83389: PUSH
83390: LD_STRING 
83392: ST_TO_ADDR
// animal := CreateHuman ;
83393: LD_ADDR_VAR 0 12
83397: PUSH
83398: CALL_OW 44
83402: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83403: LD_VAR 0 12
83407: PPUSH
83408: LD_VAR 0 8
83412: PPUSH
83413: LD_INT 0
83415: PPUSH
83416: CALL 85410 0 3
// end ;
83420: GO 83374
83422: POP
83423: POP
// if tigers then
83424: LD_VAR 0 2
83428: IFFALSE 83512
// for i = 1 to tigers do
83430: LD_ADDR_VAR 0 11
83434: PUSH
83435: DOUBLE
83436: LD_INT 1
83438: DEC
83439: ST_TO_ADDR
83440: LD_VAR 0 2
83444: PUSH
83445: FOR_TO
83446: IFFALSE 83510
// begin hc_class = class_tiger ;
83448: LD_ADDR_OWVAR 28
83452: PUSH
83453: LD_INT 14
83455: ST_TO_ADDR
// hc_gallery =  ;
83456: LD_ADDR_OWVAR 33
83460: PUSH
83461: LD_STRING 
83463: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83464: LD_ADDR_OWVAR 35
83468: PUSH
83469: LD_INT 7
83471: NEG
83472: PPUSH
83473: LD_INT 7
83475: PPUSH
83476: CALL_OW 12
83480: ST_TO_ADDR
// animal := CreateHuman ;
83481: LD_ADDR_VAR 0 12
83485: PUSH
83486: CALL_OW 44
83490: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83491: LD_VAR 0 12
83495: PPUSH
83496: LD_VAR 0 8
83500: PPUSH
83501: LD_INT 0
83503: PPUSH
83504: CALL 85410 0 3
// end ;
83508: GO 83445
83510: POP
83511: POP
// if apemans then
83512: LD_VAR 0 3
83516: IFFALSE 83639
// for i = 1 to apemans do
83518: LD_ADDR_VAR 0 11
83522: PUSH
83523: DOUBLE
83524: LD_INT 1
83526: DEC
83527: ST_TO_ADDR
83528: LD_VAR 0 3
83532: PUSH
83533: FOR_TO
83534: IFFALSE 83637
// begin hc_class = class_apeman ;
83536: LD_ADDR_OWVAR 28
83540: PUSH
83541: LD_INT 12
83543: ST_TO_ADDR
// hc_gallery =  ;
83544: LD_ADDR_OWVAR 33
83548: PUSH
83549: LD_STRING 
83551: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83552: LD_ADDR_OWVAR 35
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PPUSH
83561: LD_INT 2
83563: PPUSH
83564: CALL_OW 12
83568: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83569: LD_ADDR_OWVAR 31
83573: PUSH
83574: LD_INT 1
83576: PPUSH
83577: LD_INT 3
83579: PPUSH
83580: CALL_OW 12
83584: PUSH
83585: LD_INT 1
83587: PPUSH
83588: LD_INT 3
83590: PPUSH
83591: CALL_OW 12
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: LD_INT 0
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: ST_TO_ADDR
// animal := CreateHuman ;
83608: LD_ADDR_VAR 0 12
83612: PUSH
83613: CALL_OW 44
83617: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83618: LD_VAR 0 12
83622: PPUSH
83623: LD_VAR 0 8
83627: PPUSH
83628: LD_INT 0
83630: PPUSH
83631: CALL 85410 0 3
// end ;
83635: GO 83533
83637: POP
83638: POP
// if enchidnas then
83639: LD_VAR 0 4
83643: IFFALSE 83710
// for i = 1 to enchidnas do
83645: LD_ADDR_VAR 0 11
83649: PUSH
83650: DOUBLE
83651: LD_INT 1
83653: DEC
83654: ST_TO_ADDR
83655: LD_VAR 0 4
83659: PUSH
83660: FOR_TO
83661: IFFALSE 83708
// begin hc_class = 13 ;
83663: LD_ADDR_OWVAR 28
83667: PUSH
83668: LD_INT 13
83670: ST_TO_ADDR
// hc_gallery =  ;
83671: LD_ADDR_OWVAR 33
83675: PUSH
83676: LD_STRING 
83678: ST_TO_ADDR
// animal := CreateHuman ;
83679: LD_ADDR_VAR 0 12
83683: PUSH
83684: CALL_OW 44
83688: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83689: LD_VAR 0 12
83693: PPUSH
83694: LD_VAR 0 8
83698: PPUSH
83699: LD_INT 0
83701: PPUSH
83702: CALL 85410 0 3
// end ;
83706: GO 83660
83708: POP
83709: POP
// if fishes then
83710: LD_VAR 0 7
83714: IFFALSE 83781
// for i = 1 to fishes do
83716: LD_ADDR_VAR 0 11
83720: PUSH
83721: DOUBLE
83722: LD_INT 1
83724: DEC
83725: ST_TO_ADDR
83726: LD_VAR 0 7
83730: PUSH
83731: FOR_TO
83732: IFFALSE 83779
// begin hc_class = 20 ;
83734: LD_ADDR_OWVAR 28
83738: PUSH
83739: LD_INT 20
83741: ST_TO_ADDR
// hc_gallery =  ;
83742: LD_ADDR_OWVAR 33
83746: PUSH
83747: LD_STRING 
83749: ST_TO_ADDR
// animal := CreateHuman ;
83750: LD_ADDR_VAR 0 12
83754: PUSH
83755: CALL_OW 44
83759: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83760: LD_VAR 0 12
83764: PPUSH
83765: LD_VAR 0 9
83769: PPUSH
83770: LD_INT 0
83772: PPUSH
83773: CALL 85410 0 3
// end ;
83777: GO 83731
83779: POP
83780: POP
// end ;
83781: LD_VAR 0 10
83785: RET
// export function WantHeal ( sci , unit ) ; begin
83786: LD_INT 0
83788: PPUSH
// if GetTaskList ( sci ) > 0 then
83789: LD_VAR 0 1
83793: PPUSH
83794: CALL_OW 437
83798: PUSH
83799: LD_INT 0
83801: GREATER
83802: IFFALSE 83872
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83804: LD_VAR 0 1
83808: PPUSH
83809: CALL_OW 437
83813: PUSH
83814: LD_INT 1
83816: ARRAY
83817: PUSH
83818: LD_INT 1
83820: ARRAY
83821: PUSH
83822: LD_STRING l
83824: EQUAL
83825: PUSH
83826: LD_VAR 0 1
83830: PPUSH
83831: CALL_OW 437
83835: PUSH
83836: LD_INT 1
83838: ARRAY
83839: PUSH
83840: LD_INT 4
83842: ARRAY
83843: PUSH
83844: LD_VAR 0 2
83848: EQUAL
83849: AND
83850: IFFALSE 83862
// result := true else
83852: LD_ADDR_VAR 0 3
83856: PUSH
83857: LD_INT 1
83859: ST_TO_ADDR
83860: GO 83870
// result := false ;
83862: LD_ADDR_VAR 0 3
83866: PUSH
83867: LD_INT 0
83869: ST_TO_ADDR
// end else
83870: GO 83880
// result := false ;
83872: LD_ADDR_VAR 0 3
83876: PUSH
83877: LD_INT 0
83879: ST_TO_ADDR
// end ;
83880: LD_VAR 0 3
83884: RET
// export function HealTarget ( sci ) ; begin
83885: LD_INT 0
83887: PPUSH
// if not sci then
83888: LD_VAR 0 1
83892: NOT
83893: IFFALSE 83897
// exit ;
83895: GO 83962
// result := 0 ;
83897: LD_ADDR_VAR 0 2
83901: PUSH
83902: LD_INT 0
83904: ST_TO_ADDR
// if GetTaskList ( sci ) then
83905: LD_VAR 0 1
83909: PPUSH
83910: CALL_OW 437
83914: IFFALSE 83962
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83916: LD_VAR 0 1
83920: PPUSH
83921: CALL_OW 437
83925: PUSH
83926: LD_INT 1
83928: ARRAY
83929: PUSH
83930: LD_INT 1
83932: ARRAY
83933: PUSH
83934: LD_STRING l
83936: EQUAL
83937: IFFALSE 83962
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83939: LD_ADDR_VAR 0 2
83943: PUSH
83944: LD_VAR 0 1
83948: PPUSH
83949: CALL_OW 437
83953: PUSH
83954: LD_INT 1
83956: ARRAY
83957: PUSH
83958: LD_INT 4
83960: ARRAY
83961: ST_TO_ADDR
// end ;
83962: LD_VAR 0 2
83966: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83967: LD_INT 0
83969: PPUSH
83970: PPUSH
83971: PPUSH
83972: PPUSH
// if not base_units then
83973: LD_VAR 0 1
83977: NOT
83978: IFFALSE 83982
// exit ;
83980: GO 84069
// result := false ;
83982: LD_ADDR_VAR 0 2
83986: PUSH
83987: LD_INT 0
83989: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83990: LD_ADDR_VAR 0 5
83994: PUSH
83995: LD_VAR 0 1
83999: PPUSH
84000: LD_INT 21
84002: PUSH
84003: LD_INT 3
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PPUSH
84010: CALL_OW 72
84014: ST_TO_ADDR
// if not tmp then
84015: LD_VAR 0 5
84019: NOT
84020: IFFALSE 84024
// exit ;
84022: GO 84069
// for i in tmp do
84024: LD_ADDR_VAR 0 3
84028: PUSH
84029: LD_VAR 0 5
84033: PUSH
84034: FOR_IN
84035: IFFALSE 84067
// begin result := EnemyInRange ( i , 22 ) ;
84037: LD_ADDR_VAR 0 2
84041: PUSH
84042: LD_VAR 0 3
84046: PPUSH
84047: LD_INT 22
84049: PPUSH
84050: CALL 81656 0 2
84054: ST_TO_ADDR
// if result then
84055: LD_VAR 0 2
84059: IFFALSE 84065
// exit ;
84061: POP
84062: POP
84063: GO 84069
// end ;
84065: GO 84034
84067: POP
84068: POP
// end ;
84069: LD_VAR 0 2
84073: RET
// export function FilterByTag ( units , tag ) ; begin
84074: LD_INT 0
84076: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84077: LD_ADDR_VAR 0 3
84081: PUSH
84082: LD_VAR 0 1
84086: PPUSH
84087: LD_INT 120
84089: PUSH
84090: LD_VAR 0 2
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PPUSH
84099: CALL_OW 72
84103: ST_TO_ADDR
// end ;
84104: LD_VAR 0 3
84108: RET
// export function IsDriver ( un ) ; begin
84109: LD_INT 0
84111: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84112: LD_ADDR_VAR 0 2
84116: PUSH
84117: LD_VAR 0 1
84121: PUSH
84122: LD_INT 55
84124: PUSH
84125: EMPTY
84126: LIST
84127: PPUSH
84128: CALL_OW 69
84132: IN
84133: ST_TO_ADDR
// end ;
84134: LD_VAR 0 2
84138: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84139: LD_INT 0
84141: PPUSH
84142: PPUSH
// list := [ ] ;
84143: LD_ADDR_VAR 0 5
84147: PUSH
84148: EMPTY
84149: ST_TO_ADDR
// case d of 0 :
84150: LD_VAR 0 3
84154: PUSH
84155: LD_INT 0
84157: DOUBLE
84158: EQUAL
84159: IFTRUE 84163
84161: GO 84296
84163: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84164: LD_ADDR_VAR 0 5
84168: PUSH
84169: LD_VAR 0 1
84173: PUSH
84174: LD_INT 4
84176: MINUS
84177: PUSH
84178: LD_VAR 0 2
84182: PUSH
84183: LD_INT 4
84185: MINUS
84186: PUSH
84187: LD_INT 2
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: LIST
84194: PUSH
84195: LD_VAR 0 1
84199: PUSH
84200: LD_INT 3
84202: MINUS
84203: PUSH
84204: LD_VAR 0 2
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: LIST
84216: PUSH
84217: LD_VAR 0 1
84221: PUSH
84222: LD_INT 4
84224: PLUS
84225: PUSH
84226: LD_VAR 0 2
84230: PUSH
84231: LD_INT 4
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: LIST
84238: PUSH
84239: LD_VAR 0 1
84243: PUSH
84244: LD_INT 3
84246: PLUS
84247: PUSH
84248: LD_VAR 0 2
84252: PUSH
84253: LD_INT 3
84255: PLUS
84256: PUSH
84257: LD_INT 5
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: LIST
84264: PUSH
84265: LD_VAR 0 1
84269: PUSH
84270: LD_VAR 0 2
84274: PUSH
84275: LD_INT 4
84277: PLUS
84278: PUSH
84279: LD_INT 0
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: LIST
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: ST_TO_ADDR
// end ; 1 :
84294: GO 84994
84296: LD_INT 1
84298: DOUBLE
84299: EQUAL
84300: IFTRUE 84304
84302: GO 84437
84304: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84305: LD_ADDR_VAR 0 5
84309: PUSH
84310: LD_VAR 0 1
84314: PUSH
84315: LD_VAR 0 2
84319: PUSH
84320: LD_INT 4
84322: MINUS
84323: PUSH
84324: LD_INT 3
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: LIST
84331: PUSH
84332: LD_VAR 0 1
84336: PUSH
84337: LD_INT 3
84339: MINUS
84340: PUSH
84341: LD_VAR 0 2
84345: PUSH
84346: LD_INT 3
84348: MINUS
84349: PUSH
84350: LD_INT 2
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: LIST
84357: PUSH
84358: LD_VAR 0 1
84362: PUSH
84363: LD_INT 4
84365: MINUS
84366: PUSH
84367: LD_VAR 0 2
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: LIST
84379: PUSH
84380: LD_VAR 0 1
84384: PUSH
84385: LD_VAR 0 2
84389: PUSH
84390: LD_INT 3
84392: PLUS
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: LIST
84401: PUSH
84402: LD_VAR 0 1
84406: PUSH
84407: LD_INT 4
84409: PLUS
84410: PUSH
84411: LD_VAR 0 2
84415: PUSH
84416: LD_INT 4
84418: PLUS
84419: PUSH
84420: LD_INT 5
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: LIST
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: ST_TO_ADDR
// end ; 2 :
84435: GO 84994
84437: LD_INT 2
84439: DOUBLE
84440: EQUAL
84441: IFTRUE 84445
84443: GO 84574
84445: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84446: LD_ADDR_VAR 0 5
84450: PUSH
84451: LD_VAR 0 1
84455: PUSH
84456: LD_VAR 0 2
84460: PUSH
84461: LD_INT 3
84463: MINUS
84464: PUSH
84465: LD_INT 3
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: LIST
84472: PUSH
84473: LD_VAR 0 1
84477: PUSH
84478: LD_INT 4
84480: PLUS
84481: PUSH
84482: LD_VAR 0 2
84486: PUSH
84487: LD_INT 4
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: LIST
84494: PUSH
84495: LD_VAR 0 1
84499: PUSH
84500: LD_VAR 0 2
84504: PUSH
84505: LD_INT 4
84507: PLUS
84508: PUSH
84509: LD_INT 0
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: LIST
84516: PUSH
84517: LD_VAR 0 1
84521: PUSH
84522: LD_INT 3
84524: MINUS
84525: PUSH
84526: LD_VAR 0 2
84530: PUSH
84531: LD_INT 1
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: LIST
84538: PUSH
84539: LD_VAR 0 1
84543: PUSH
84544: LD_INT 4
84546: MINUS
84547: PUSH
84548: LD_VAR 0 2
84552: PUSH
84553: LD_INT 4
84555: MINUS
84556: PUSH
84557: LD_INT 2
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: LIST
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: ST_TO_ADDR
// end ; 3 :
84572: GO 84994
84574: LD_INT 3
84576: DOUBLE
84577: EQUAL
84578: IFTRUE 84582
84580: GO 84715
84582: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84583: LD_ADDR_VAR 0 5
84587: PUSH
84588: LD_VAR 0 1
84592: PUSH
84593: LD_INT 3
84595: PLUS
84596: PUSH
84597: LD_VAR 0 2
84601: PUSH
84602: LD_INT 4
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: LIST
84609: PUSH
84610: LD_VAR 0 1
84614: PUSH
84615: LD_INT 4
84617: PLUS
84618: PUSH
84619: LD_VAR 0 2
84623: PUSH
84624: LD_INT 4
84626: PLUS
84627: PUSH
84628: LD_INT 5
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: LIST
84635: PUSH
84636: LD_VAR 0 1
84640: PUSH
84641: LD_INT 4
84643: MINUS
84644: PUSH
84645: LD_VAR 0 2
84649: PUSH
84650: LD_INT 1
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: PUSH
84658: LD_VAR 0 1
84662: PUSH
84663: LD_VAR 0 2
84667: PUSH
84668: LD_INT 4
84670: MINUS
84671: PUSH
84672: LD_INT 3
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: LIST
84679: PUSH
84680: LD_VAR 0 1
84684: PUSH
84685: LD_INT 3
84687: MINUS
84688: PUSH
84689: LD_VAR 0 2
84693: PUSH
84694: LD_INT 3
84696: MINUS
84697: PUSH
84698: LD_INT 2
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: LIST
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: ST_TO_ADDR
// end ; 4 :
84713: GO 84994
84715: LD_INT 4
84717: DOUBLE
84718: EQUAL
84719: IFTRUE 84723
84721: GO 84856
84723: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84724: LD_ADDR_VAR 0 5
84728: PUSH
84729: LD_VAR 0 1
84733: PUSH
84734: LD_VAR 0 2
84738: PUSH
84739: LD_INT 4
84741: PLUS
84742: PUSH
84743: LD_INT 0
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: LIST
84750: PUSH
84751: LD_VAR 0 1
84755: PUSH
84756: LD_INT 3
84758: PLUS
84759: PUSH
84760: LD_VAR 0 2
84764: PUSH
84765: LD_INT 3
84767: PLUS
84768: PUSH
84769: LD_INT 5
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: LIST
84776: PUSH
84777: LD_VAR 0 1
84781: PUSH
84782: LD_INT 4
84784: PLUS
84785: PUSH
84786: LD_VAR 0 2
84790: PUSH
84791: LD_INT 4
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: LIST
84798: PUSH
84799: LD_VAR 0 1
84803: PUSH
84804: LD_VAR 0 2
84808: PUSH
84809: LD_INT 3
84811: MINUS
84812: PUSH
84813: LD_INT 3
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: LIST
84820: PUSH
84821: LD_VAR 0 1
84825: PUSH
84826: LD_INT 4
84828: MINUS
84829: PUSH
84830: LD_VAR 0 2
84834: PUSH
84835: LD_INT 4
84837: MINUS
84838: PUSH
84839: LD_INT 2
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: LIST
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: ST_TO_ADDR
// end ; 5 :
84854: GO 84994
84856: LD_INT 5
84858: DOUBLE
84859: EQUAL
84860: IFTRUE 84864
84862: GO 84993
84864: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84865: LD_ADDR_VAR 0 5
84869: PUSH
84870: LD_VAR 0 1
84874: PUSH
84875: LD_INT 4
84877: MINUS
84878: PUSH
84879: LD_VAR 0 2
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: LIST
84891: PUSH
84892: LD_VAR 0 1
84896: PUSH
84897: LD_VAR 0 2
84901: PUSH
84902: LD_INT 4
84904: MINUS
84905: PUSH
84906: LD_INT 3
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: PUSH
84914: LD_VAR 0 1
84918: PUSH
84919: LD_INT 4
84921: PLUS
84922: PUSH
84923: LD_VAR 0 2
84927: PUSH
84928: LD_INT 4
84930: PLUS
84931: PUSH
84932: LD_INT 5
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: LIST
84939: PUSH
84940: LD_VAR 0 1
84944: PUSH
84945: LD_INT 3
84947: PLUS
84948: PUSH
84949: LD_VAR 0 2
84953: PUSH
84954: LD_INT 4
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: LIST
84961: PUSH
84962: LD_VAR 0 1
84966: PUSH
84967: LD_VAR 0 2
84971: PUSH
84972: LD_INT 3
84974: PLUS
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: LIST
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: ST_TO_ADDR
// end ; end ;
84991: GO 84994
84993: POP
// result := list ;
84994: LD_ADDR_VAR 0 4
84998: PUSH
84999: LD_VAR 0 5
85003: ST_TO_ADDR
// end ;
85004: LD_VAR 0 4
85008: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85009: LD_INT 0
85011: PPUSH
85012: PPUSH
85013: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85014: LD_VAR 0 1
85018: NOT
85019: PUSH
85020: LD_VAR 0 2
85024: PUSH
85025: LD_INT 1
85027: PUSH
85028: LD_INT 2
85030: PUSH
85031: LD_INT 3
85033: PUSH
85034: LD_INT 4
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: IN
85043: NOT
85044: OR
85045: IFFALSE 85049
// exit ;
85047: GO 85132
// tmp := [ ] ;
85049: LD_ADDR_VAR 0 5
85053: PUSH
85054: EMPTY
85055: ST_TO_ADDR
// for i in units do
85056: LD_ADDR_VAR 0 4
85060: PUSH
85061: LD_VAR 0 1
85065: PUSH
85066: FOR_IN
85067: IFFALSE 85101
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85069: LD_ADDR_VAR 0 5
85073: PUSH
85074: LD_VAR 0 5
85078: PPUSH
85079: LD_VAR 0 4
85083: PPUSH
85084: LD_VAR 0 2
85088: PPUSH
85089: CALL_OW 259
85093: PPUSH
85094: CALL 86493 0 2
85098: ST_TO_ADDR
85099: GO 85066
85101: POP
85102: POP
// if not tmp then
85103: LD_VAR 0 5
85107: NOT
85108: IFFALSE 85112
// exit ;
85110: GO 85132
// result := SortListByListDesc ( units , tmp ) ;
85112: LD_ADDR_VAR 0 3
85116: PUSH
85117: LD_VAR 0 1
85121: PPUSH
85122: LD_VAR 0 5
85126: PPUSH
85127: CALL_OW 77
85131: ST_TO_ADDR
// end ;
85132: LD_VAR 0 3
85136: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85137: LD_INT 0
85139: PPUSH
85140: PPUSH
85141: PPUSH
// result := false ;
85142: LD_ADDR_VAR 0 3
85146: PUSH
85147: LD_INT 0
85149: ST_TO_ADDR
// if not building then
85150: LD_VAR 0 2
85154: NOT
85155: IFFALSE 85159
// exit ;
85157: GO 85297
// x := GetX ( building ) ;
85159: LD_ADDR_VAR 0 4
85163: PUSH
85164: LD_VAR 0 2
85168: PPUSH
85169: CALL_OW 250
85173: ST_TO_ADDR
// y := GetY ( building ) ;
85174: LD_ADDR_VAR 0 5
85178: PUSH
85179: LD_VAR 0 2
85183: PPUSH
85184: CALL_OW 251
85188: ST_TO_ADDR
// if not x or not y then
85189: LD_VAR 0 4
85193: NOT
85194: PUSH
85195: LD_VAR 0 5
85199: NOT
85200: OR
85201: IFFALSE 85205
// exit ;
85203: GO 85297
// if GetTaskList ( unit ) then
85205: LD_VAR 0 1
85209: PPUSH
85210: CALL_OW 437
85214: IFFALSE 85297
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85216: LD_STRING e
85218: PUSH
85219: LD_VAR 0 1
85223: PPUSH
85224: CALL_OW 437
85228: PUSH
85229: LD_INT 1
85231: ARRAY
85232: PUSH
85233: LD_INT 1
85235: ARRAY
85236: EQUAL
85237: PUSH
85238: LD_VAR 0 4
85242: PUSH
85243: LD_VAR 0 1
85247: PPUSH
85248: CALL_OW 437
85252: PUSH
85253: LD_INT 1
85255: ARRAY
85256: PUSH
85257: LD_INT 2
85259: ARRAY
85260: EQUAL
85261: AND
85262: PUSH
85263: LD_VAR 0 5
85267: PUSH
85268: LD_VAR 0 1
85272: PPUSH
85273: CALL_OW 437
85277: PUSH
85278: LD_INT 1
85280: ARRAY
85281: PUSH
85282: LD_INT 3
85284: ARRAY
85285: EQUAL
85286: AND
85287: IFFALSE 85297
// result := true end ;
85289: LD_ADDR_VAR 0 3
85293: PUSH
85294: LD_INT 1
85296: ST_TO_ADDR
// end ;
85297: LD_VAR 0 3
85301: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85302: LD_INT 0
85304: PPUSH
// result := false ;
85305: LD_ADDR_VAR 0 4
85309: PUSH
85310: LD_INT 0
85312: ST_TO_ADDR
// if GetTaskList ( unit ) then
85313: LD_VAR 0 1
85317: PPUSH
85318: CALL_OW 437
85322: IFFALSE 85405
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85324: LD_STRING M
85326: PUSH
85327: LD_VAR 0 1
85331: PPUSH
85332: CALL_OW 437
85336: PUSH
85337: LD_INT 1
85339: ARRAY
85340: PUSH
85341: LD_INT 1
85343: ARRAY
85344: EQUAL
85345: PUSH
85346: LD_VAR 0 2
85350: PUSH
85351: LD_VAR 0 1
85355: PPUSH
85356: CALL_OW 437
85360: PUSH
85361: LD_INT 1
85363: ARRAY
85364: PUSH
85365: LD_INT 2
85367: ARRAY
85368: EQUAL
85369: AND
85370: PUSH
85371: LD_VAR 0 3
85375: PUSH
85376: LD_VAR 0 1
85380: PPUSH
85381: CALL_OW 437
85385: PUSH
85386: LD_INT 1
85388: ARRAY
85389: PUSH
85390: LD_INT 3
85392: ARRAY
85393: EQUAL
85394: AND
85395: IFFALSE 85405
// result := true ;
85397: LD_ADDR_VAR 0 4
85401: PUSH
85402: LD_INT 1
85404: ST_TO_ADDR
// end ; end ;
85405: LD_VAR 0 4
85409: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85410: LD_INT 0
85412: PPUSH
85413: PPUSH
85414: PPUSH
85415: PPUSH
// if not unit or not area then
85416: LD_VAR 0 1
85420: NOT
85421: PUSH
85422: LD_VAR 0 2
85426: NOT
85427: OR
85428: IFFALSE 85432
// exit ;
85430: GO 85596
// tmp := AreaToList ( area , i ) ;
85432: LD_ADDR_VAR 0 6
85436: PUSH
85437: LD_VAR 0 2
85441: PPUSH
85442: LD_VAR 0 5
85446: PPUSH
85447: CALL_OW 517
85451: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85452: LD_ADDR_VAR 0 5
85456: PUSH
85457: DOUBLE
85458: LD_INT 1
85460: DEC
85461: ST_TO_ADDR
85462: LD_VAR 0 6
85466: PUSH
85467: LD_INT 1
85469: ARRAY
85470: PUSH
85471: FOR_TO
85472: IFFALSE 85594
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85474: LD_ADDR_VAR 0 7
85478: PUSH
85479: LD_VAR 0 6
85483: PUSH
85484: LD_INT 1
85486: ARRAY
85487: PUSH
85488: LD_VAR 0 5
85492: ARRAY
85493: PUSH
85494: LD_VAR 0 6
85498: PUSH
85499: LD_INT 2
85501: ARRAY
85502: PUSH
85503: LD_VAR 0 5
85507: ARRAY
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85513: LD_VAR 0 7
85517: PUSH
85518: LD_INT 1
85520: ARRAY
85521: PPUSH
85522: LD_VAR 0 7
85526: PUSH
85527: LD_INT 2
85529: ARRAY
85530: PPUSH
85531: CALL_OW 428
85535: PUSH
85536: LD_INT 0
85538: EQUAL
85539: IFFALSE 85592
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85541: LD_VAR 0 1
85545: PPUSH
85546: LD_VAR 0 7
85550: PUSH
85551: LD_INT 1
85553: ARRAY
85554: PPUSH
85555: LD_VAR 0 7
85559: PUSH
85560: LD_INT 2
85562: ARRAY
85563: PPUSH
85564: LD_VAR 0 3
85568: PPUSH
85569: CALL_OW 48
// result := IsPlaced ( unit ) ;
85573: LD_ADDR_VAR 0 4
85577: PUSH
85578: LD_VAR 0 1
85582: PPUSH
85583: CALL_OW 305
85587: ST_TO_ADDR
// exit ;
85588: POP
85589: POP
85590: GO 85596
// end ; end ;
85592: GO 85471
85594: POP
85595: POP
// end ;
85596: LD_VAR 0 4
85600: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85601: LD_INT 0
85603: PPUSH
85604: PPUSH
85605: PPUSH
// if not side or side > 8 then
85606: LD_VAR 0 1
85610: NOT
85611: PUSH
85612: LD_VAR 0 1
85616: PUSH
85617: LD_INT 8
85619: GREATER
85620: OR
85621: IFFALSE 85625
// exit ;
85623: GO 85812
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85625: LD_ADDR_VAR 0 4
85629: PUSH
85630: LD_INT 22
85632: PUSH
85633: LD_VAR 0 1
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 21
85644: PUSH
85645: LD_INT 3
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: EMPTY
85653: LIST
85654: LIST
85655: PPUSH
85656: CALL_OW 69
85660: ST_TO_ADDR
// if not tmp then
85661: LD_VAR 0 4
85665: NOT
85666: IFFALSE 85670
// exit ;
85668: GO 85812
// enable_addtolog := true ;
85670: LD_ADDR_OWVAR 81
85674: PUSH
85675: LD_INT 1
85677: ST_TO_ADDR
// AddToLog ( [ ) ;
85678: LD_STRING [
85680: PPUSH
85681: CALL_OW 561
// for i in tmp do
85685: LD_ADDR_VAR 0 3
85689: PUSH
85690: LD_VAR 0 4
85694: PUSH
85695: FOR_IN
85696: IFFALSE 85803
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85698: LD_STRING [
85700: PUSH
85701: LD_VAR 0 3
85705: PPUSH
85706: CALL_OW 266
85710: STR
85711: PUSH
85712: LD_STRING , 
85714: STR
85715: PUSH
85716: LD_VAR 0 3
85720: PPUSH
85721: CALL_OW 250
85725: STR
85726: PUSH
85727: LD_STRING , 
85729: STR
85730: PUSH
85731: LD_VAR 0 3
85735: PPUSH
85736: CALL_OW 251
85740: STR
85741: PUSH
85742: LD_STRING , 
85744: STR
85745: PUSH
85746: LD_VAR 0 3
85750: PPUSH
85751: CALL_OW 254
85755: STR
85756: PUSH
85757: LD_STRING , 
85759: STR
85760: PUSH
85761: LD_VAR 0 3
85765: PPUSH
85766: LD_INT 1
85768: PPUSH
85769: CALL_OW 268
85773: STR
85774: PUSH
85775: LD_STRING , 
85777: STR
85778: PUSH
85779: LD_VAR 0 3
85783: PPUSH
85784: LD_INT 2
85786: PPUSH
85787: CALL_OW 268
85791: STR
85792: PUSH
85793: LD_STRING ],
85795: STR
85796: PPUSH
85797: CALL_OW 561
// end ;
85801: GO 85695
85803: POP
85804: POP
// AddToLog ( ]; ) ;
85805: LD_STRING ];
85807: PPUSH
85808: CALL_OW 561
// end ;
85812: LD_VAR 0 2
85816: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85817: LD_INT 0
85819: PPUSH
85820: PPUSH
85821: PPUSH
85822: PPUSH
85823: PPUSH
// if not area or not rate or not max then
85824: LD_VAR 0 1
85828: NOT
85829: PUSH
85830: LD_VAR 0 2
85834: NOT
85835: OR
85836: PUSH
85837: LD_VAR 0 4
85841: NOT
85842: OR
85843: IFFALSE 85847
// exit ;
85845: GO 86036
// while 1 do
85847: LD_INT 1
85849: IFFALSE 86036
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85851: LD_ADDR_VAR 0 9
85855: PUSH
85856: LD_VAR 0 1
85860: PPUSH
85861: LD_INT 1
85863: PPUSH
85864: CALL_OW 287
85868: PUSH
85869: LD_INT 10
85871: MUL
85872: ST_TO_ADDR
// r := rate / 10 ;
85873: LD_ADDR_VAR 0 7
85877: PUSH
85878: LD_VAR 0 2
85882: PUSH
85883: LD_INT 10
85885: DIVREAL
85886: ST_TO_ADDR
// time := 1 1$00 ;
85887: LD_ADDR_VAR 0 8
85891: PUSH
85892: LD_INT 2100
85894: ST_TO_ADDR
// if amount < min then
85895: LD_VAR 0 9
85899: PUSH
85900: LD_VAR 0 3
85904: LESS
85905: IFFALSE 85923
// r := r * 2 else
85907: LD_ADDR_VAR 0 7
85911: PUSH
85912: LD_VAR 0 7
85916: PUSH
85917: LD_INT 2
85919: MUL
85920: ST_TO_ADDR
85921: GO 85949
// if amount > max then
85923: LD_VAR 0 9
85927: PUSH
85928: LD_VAR 0 4
85932: GREATER
85933: IFFALSE 85949
// r := r / 2 ;
85935: LD_ADDR_VAR 0 7
85939: PUSH
85940: LD_VAR 0 7
85944: PUSH
85945: LD_INT 2
85947: DIVREAL
85948: ST_TO_ADDR
// time := time / r ;
85949: LD_ADDR_VAR 0 8
85953: PUSH
85954: LD_VAR 0 8
85958: PUSH
85959: LD_VAR 0 7
85963: DIVREAL
85964: ST_TO_ADDR
// if time < 0 then
85965: LD_VAR 0 8
85969: PUSH
85970: LD_INT 0
85972: LESS
85973: IFFALSE 85990
// time := time * - 1 ;
85975: LD_ADDR_VAR 0 8
85979: PUSH
85980: LD_VAR 0 8
85984: PUSH
85985: LD_INT 1
85987: NEG
85988: MUL
85989: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85990: LD_VAR 0 8
85994: PUSH
85995: LD_INT 35
85997: PPUSH
85998: LD_INT 875
86000: PPUSH
86001: CALL_OW 12
86005: PLUS
86006: PPUSH
86007: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86011: LD_INT 1
86013: PPUSH
86014: LD_INT 5
86016: PPUSH
86017: CALL_OW 12
86021: PPUSH
86022: LD_VAR 0 1
86026: PPUSH
86027: LD_INT 1
86029: PPUSH
86030: CALL_OW 55
// end ;
86034: GO 85847
// end ;
86036: LD_VAR 0 5
86040: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86041: LD_INT 0
86043: PPUSH
86044: PPUSH
86045: PPUSH
86046: PPUSH
86047: PPUSH
86048: PPUSH
86049: PPUSH
86050: PPUSH
// if not turrets or not factories then
86051: LD_VAR 0 1
86055: NOT
86056: PUSH
86057: LD_VAR 0 2
86061: NOT
86062: OR
86063: IFFALSE 86067
// exit ;
86065: GO 86374
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86067: LD_ADDR_VAR 0 10
86071: PUSH
86072: LD_INT 5
86074: PUSH
86075: LD_INT 6
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 2
86084: PUSH
86085: LD_INT 4
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 3
86094: PUSH
86095: LD_INT 5
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 24
86109: PUSH
86110: LD_INT 25
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 23
86119: PUSH
86120: LD_INT 27
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 42
86133: PUSH
86134: LD_INT 43
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 44
86143: PUSH
86144: LD_INT 46
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 45
86153: PUSH
86154: LD_INT 47
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: LIST
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: LIST
86170: ST_TO_ADDR
// result := [ ] ;
86171: LD_ADDR_VAR 0 3
86175: PUSH
86176: EMPTY
86177: ST_TO_ADDR
// for i in turrets do
86178: LD_ADDR_VAR 0 4
86182: PUSH
86183: LD_VAR 0 1
86187: PUSH
86188: FOR_IN
86189: IFFALSE 86372
// begin nat := GetNation ( i ) ;
86191: LD_ADDR_VAR 0 7
86195: PUSH
86196: LD_VAR 0 4
86200: PPUSH
86201: CALL_OW 248
86205: ST_TO_ADDR
// weapon := 0 ;
86206: LD_ADDR_VAR 0 8
86210: PUSH
86211: LD_INT 0
86213: ST_TO_ADDR
// if not nat then
86214: LD_VAR 0 7
86218: NOT
86219: IFFALSE 86223
// continue ;
86221: GO 86188
// for j in list [ nat ] do
86223: LD_ADDR_VAR 0 5
86227: PUSH
86228: LD_VAR 0 10
86232: PUSH
86233: LD_VAR 0 7
86237: ARRAY
86238: PUSH
86239: FOR_IN
86240: IFFALSE 86281
// if GetBWeapon ( i ) = j [ 1 ] then
86242: LD_VAR 0 4
86246: PPUSH
86247: CALL_OW 269
86251: PUSH
86252: LD_VAR 0 5
86256: PUSH
86257: LD_INT 1
86259: ARRAY
86260: EQUAL
86261: IFFALSE 86279
// begin weapon := j [ 2 ] ;
86263: LD_ADDR_VAR 0 8
86267: PUSH
86268: LD_VAR 0 5
86272: PUSH
86273: LD_INT 2
86275: ARRAY
86276: ST_TO_ADDR
// break ;
86277: GO 86281
// end ;
86279: GO 86239
86281: POP
86282: POP
// if not weapon then
86283: LD_VAR 0 8
86287: NOT
86288: IFFALSE 86292
// continue ;
86290: GO 86188
// for k in factories do
86292: LD_ADDR_VAR 0 6
86296: PUSH
86297: LD_VAR 0 2
86301: PUSH
86302: FOR_IN
86303: IFFALSE 86368
// begin weapons := AvailableWeaponList ( k ) ;
86305: LD_ADDR_VAR 0 9
86309: PUSH
86310: LD_VAR 0 6
86314: PPUSH
86315: CALL_OW 478
86319: ST_TO_ADDR
// if not weapons then
86320: LD_VAR 0 9
86324: NOT
86325: IFFALSE 86329
// continue ;
86327: GO 86302
// if weapon in weapons then
86329: LD_VAR 0 8
86333: PUSH
86334: LD_VAR 0 9
86338: IN
86339: IFFALSE 86366
// begin result := [ i , weapon ] ;
86341: LD_ADDR_VAR 0 3
86345: PUSH
86346: LD_VAR 0 4
86350: PUSH
86351: LD_VAR 0 8
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: ST_TO_ADDR
// exit ;
86360: POP
86361: POP
86362: POP
86363: POP
86364: GO 86374
// end ; end ;
86366: GO 86302
86368: POP
86369: POP
// end ;
86370: GO 86188
86372: POP
86373: POP
// end ;
86374: LD_VAR 0 3
86378: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86379: LD_INT 0
86381: PPUSH
// if not side or side > 8 then
86382: LD_VAR 0 3
86386: NOT
86387: PUSH
86388: LD_VAR 0 3
86392: PUSH
86393: LD_INT 8
86395: GREATER
86396: OR
86397: IFFALSE 86401
// exit ;
86399: GO 86460
// if not range then
86401: LD_VAR 0 4
86405: NOT
86406: IFFALSE 86417
// range := - 12 ;
86408: LD_ADDR_VAR 0 4
86412: PUSH
86413: LD_INT 12
86415: NEG
86416: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86417: LD_VAR 0 1
86421: PPUSH
86422: LD_VAR 0 2
86426: PPUSH
86427: LD_VAR 0 3
86431: PPUSH
86432: LD_VAR 0 4
86436: PPUSH
86437: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86441: LD_VAR 0 1
86445: PPUSH
86446: LD_VAR 0 2
86450: PPUSH
86451: LD_VAR 0 3
86455: PPUSH
86456: CALL_OW 331
// end ;
86460: LD_VAR 0 5
86464: RET
// export function Video ( mode ) ; begin
86465: LD_INT 0
86467: PPUSH
// ingame_video = mode ;
86468: LD_ADDR_OWVAR 52
86472: PUSH
86473: LD_VAR 0 1
86477: ST_TO_ADDR
// interface_hidden = mode ;
86478: LD_ADDR_OWVAR 54
86482: PUSH
86483: LD_VAR 0 1
86487: ST_TO_ADDR
// end ;
86488: LD_VAR 0 2
86492: RET
// export function Join ( array , element ) ; begin
86493: LD_INT 0
86495: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86496: LD_ADDR_VAR 0 3
86500: PUSH
86501: LD_VAR 0 1
86505: PPUSH
86506: LD_VAR 0 1
86510: PUSH
86511: LD_INT 1
86513: PLUS
86514: PPUSH
86515: LD_VAR 0 2
86519: PPUSH
86520: CALL_OW 1
86524: ST_TO_ADDR
// end ;
86525: LD_VAR 0 3
86529: RET
// export function JoinUnion ( array , element ) ; begin
86530: LD_INT 0
86532: PPUSH
// result := array union element ;
86533: LD_ADDR_VAR 0 3
86537: PUSH
86538: LD_VAR 0 1
86542: PUSH
86543: LD_VAR 0 2
86547: UNION
86548: ST_TO_ADDR
// end ;
86549: LD_VAR 0 3
86553: RET
// export function GetBehemoths ( side ) ; begin
86554: LD_INT 0
86556: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86557: LD_ADDR_VAR 0 2
86561: PUSH
86562: LD_INT 22
86564: PUSH
86565: LD_VAR 0 1
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 31
86576: PUSH
86577: LD_INT 25
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PPUSH
86588: CALL_OW 69
86592: ST_TO_ADDR
// end ;
86593: LD_VAR 0 2
86597: RET
// export function Shuffle ( array ) ; var i , index ; begin
86598: LD_INT 0
86600: PPUSH
86601: PPUSH
86602: PPUSH
// result := [ ] ;
86603: LD_ADDR_VAR 0 2
86607: PUSH
86608: EMPTY
86609: ST_TO_ADDR
// if not array then
86610: LD_VAR 0 1
86614: NOT
86615: IFFALSE 86619
// exit ;
86617: GO 86718
// Randomize ;
86619: CALL_OW 10
// for i = array downto 1 do
86623: LD_ADDR_VAR 0 3
86627: PUSH
86628: DOUBLE
86629: LD_VAR 0 1
86633: INC
86634: ST_TO_ADDR
86635: LD_INT 1
86637: PUSH
86638: FOR_DOWNTO
86639: IFFALSE 86716
// begin index := rand ( 1 , array ) ;
86641: LD_ADDR_VAR 0 4
86645: PUSH
86646: LD_INT 1
86648: PPUSH
86649: LD_VAR 0 1
86653: PPUSH
86654: CALL_OW 12
86658: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86659: LD_ADDR_VAR 0 2
86663: PUSH
86664: LD_VAR 0 2
86668: PPUSH
86669: LD_VAR 0 2
86673: PUSH
86674: LD_INT 1
86676: PLUS
86677: PPUSH
86678: LD_VAR 0 1
86682: PUSH
86683: LD_VAR 0 4
86687: ARRAY
86688: PPUSH
86689: CALL_OW 2
86693: ST_TO_ADDR
// array := Delete ( array , index ) ;
86694: LD_ADDR_VAR 0 1
86698: PUSH
86699: LD_VAR 0 1
86703: PPUSH
86704: LD_VAR 0 4
86708: PPUSH
86709: CALL_OW 3
86713: ST_TO_ADDR
// end ;
86714: GO 86638
86716: POP
86717: POP
// end ;
86718: LD_VAR 0 2
86722: RET
// export function GetBaseMaterials ( base ) ; begin
86723: LD_INT 0
86725: PPUSH
// result := [ 0 , 0 , 0 ] ;
86726: LD_ADDR_VAR 0 2
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: LD_INT 0
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: LIST
86744: ST_TO_ADDR
// if not base then
86745: LD_VAR 0 1
86749: NOT
86750: IFFALSE 86754
// exit ;
86752: GO 86803
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86754: LD_ADDR_VAR 0 2
86758: PUSH
86759: LD_VAR 0 1
86763: PPUSH
86764: LD_INT 1
86766: PPUSH
86767: CALL_OW 275
86771: PUSH
86772: LD_VAR 0 1
86776: PPUSH
86777: LD_INT 2
86779: PPUSH
86780: CALL_OW 275
86784: PUSH
86785: LD_VAR 0 1
86789: PPUSH
86790: LD_INT 3
86792: PPUSH
86793: CALL_OW 275
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: LIST
86802: ST_TO_ADDR
// end ;
86803: LD_VAR 0 2
86807: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86808: LD_INT 0
86810: PPUSH
86811: PPUSH
// result := array ;
86812: LD_ADDR_VAR 0 3
86816: PUSH
86817: LD_VAR 0 1
86821: ST_TO_ADDR
// if size >= result then
86822: LD_VAR 0 2
86826: PUSH
86827: LD_VAR 0 3
86831: GREATEREQUAL
86832: IFFALSE 86836
// exit ;
86834: GO 86886
// if size then
86836: LD_VAR 0 2
86840: IFFALSE 86886
// for i := array downto size do
86842: LD_ADDR_VAR 0 4
86846: PUSH
86847: DOUBLE
86848: LD_VAR 0 1
86852: INC
86853: ST_TO_ADDR
86854: LD_VAR 0 2
86858: PUSH
86859: FOR_DOWNTO
86860: IFFALSE 86884
// result := Delete ( result , result ) ;
86862: LD_ADDR_VAR 0 3
86866: PUSH
86867: LD_VAR 0 3
86871: PPUSH
86872: LD_VAR 0 3
86876: PPUSH
86877: CALL_OW 3
86881: ST_TO_ADDR
86882: GO 86859
86884: POP
86885: POP
// end ;
86886: LD_VAR 0 3
86890: RET
// export function ComExit ( unit ) ; var tmp ; begin
86891: LD_INT 0
86893: PPUSH
86894: PPUSH
// if not IsInUnit ( unit ) then
86895: LD_VAR 0 1
86899: PPUSH
86900: CALL_OW 310
86904: NOT
86905: IFFALSE 86909
// exit ;
86907: GO 86969
// tmp := IsInUnit ( unit ) ;
86909: LD_ADDR_VAR 0 3
86913: PUSH
86914: LD_VAR 0 1
86918: PPUSH
86919: CALL_OW 310
86923: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86924: LD_VAR 0 3
86928: PPUSH
86929: CALL_OW 247
86933: PUSH
86934: LD_INT 2
86936: EQUAL
86937: IFFALSE 86950
// ComExitVehicle ( unit ) else
86939: LD_VAR 0 1
86943: PPUSH
86944: CALL_OW 121
86948: GO 86959
// ComExitBuilding ( unit ) ;
86950: LD_VAR 0 1
86954: PPUSH
86955: CALL_OW 122
// result := tmp ;
86959: LD_ADDR_VAR 0 2
86963: PUSH
86964: LD_VAR 0 3
86968: ST_TO_ADDR
// end ;
86969: LD_VAR 0 2
86973: RET
// export function ComExitAll ( units ) ; var i ; begin
86974: LD_INT 0
86976: PPUSH
86977: PPUSH
// if not units then
86978: LD_VAR 0 1
86982: NOT
86983: IFFALSE 86987
// exit ;
86985: GO 87013
// for i in units do
86987: LD_ADDR_VAR 0 3
86991: PUSH
86992: LD_VAR 0 1
86996: PUSH
86997: FOR_IN
86998: IFFALSE 87011
// ComExit ( i ) ;
87000: LD_VAR 0 3
87004: PPUSH
87005: CALL 86891 0 1
87009: GO 86997
87011: POP
87012: POP
// end ;
87013: LD_VAR 0 2
87017: RET
// export function ResetHc ; begin
87018: LD_INT 0
87020: PPUSH
// InitHc ;
87021: CALL_OW 19
// hc_importance := 0 ;
87025: LD_ADDR_OWVAR 32
87029: PUSH
87030: LD_INT 0
87032: ST_TO_ADDR
// end ;
87033: LD_VAR 0 1
87037: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87038: LD_INT 0
87040: PPUSH
87041: PPUSH
87042: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87043: LD_ADDR_VAR 0 6
87047: PUSH
87048: LD_VAR 0 1
87052: PUSH
87053: LD_VAR 0 3
87057: PLUS
87058: PUSH
87059: LD_INT 2
87061: DIV
87062: ST_TO_ADDR
// if _x < 0 then
87063: LD_VAR 0 6
87067: PUSH
87068: LD_INT 0
87070: LESS
87071: IFFALSE 87088
// _x := _x * - 1 ;
87073: LD_ADDR_VAR 0 6
87077: PUSH
87078: LD_VAR 0 6
87082: PUSH
87083: LD_INT 1
87085: NEG
87086: MUL
87087: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87088: LD_ADDR_VAR 0 7
87092: PUSH
87093: LD_VAR 0 2
87097: PUSH
87098: LD_VAR 0 4
87102: PLUS
87103: PUSH
87104: LD_INT 2
87106: DIV
87107: ST_TO_ADDR
// if _y < 0 then
87108: LD_VAR 0 7
87112: PUSH
87113: LD_INT 0
87115: LESS
87116: IFFALSE 87133
// _y := _y * - 1 ;
87118: LD_ADDR_VAR 0 7
87122: PUSH
87123: LD_VAR 0 7
87127: PUSH
87128: LD_INT 1
87130: NEG
87131: MUL
87132: ST_TO_ADDR
// result := [ _x , _y ] ;
87133: LD_ADDR_VAR 0 5
87137: PUSH
87138: LD_VAR 0 6
87142: PUSH
87143: LD_VAR 0 7
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: ST_TO_ADDR
// end ;
87152: LD_VAR 0 5
87156: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87157: LD_INT 0
87159: PPUSH
87160: PPUSH
87161: PPUSH
87162: PPUSH
// task := GetTaskList ( unit ) ;
87163: LD_ADDR_VAR 0 7
87167: PUSH
87168: LD_VAR 0 1
87172: PPUSH
87173: CALL_OW 437
87177: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87178: LD_VAR 0 7
87182: NOT
87183: PUSH
87184: LD_VAR 0 1
87188: PPUSH
87189: LD_VAR 0 2
87193: PPUSH
87194: CALL_OW 308
87198: NOT
87199: AND
87200: IFFALSE 87204
// exit ;
87202: GO 87322
// if IsInArea ( unit , area ) then
87204: LD_VAR 0 1
87208: PPUSH
87209: LD_VAR 0 2
87213: PPUSH
87214: CALL_OW 308
87218: IFFALSE 87236
// begin ComMoveToArea ( unit , goAway ) ;
87220: LD_VAR 0 1
87224: PPUSH
87225: LD_VAR 0 3
87229: PPUSH
87230: CALL_OW 113
// exit ;
87234: GO 87322
// end ; if task [ 1 ] [ 1 ] <> M then
87236: LD_VAR 0 7
87240: PUSH
87241: LD_INT 1
87243: ARRAY
87244: PUSH
87245: LD_INT 1
87247: ARRAY
87248: PUSH
87249: LD_STRING M
87251: NONEQUAL
87252: IFFALSE 87256
// exit ;
87254: GO 87322
// x := task [ 1 ] [ 2 ] ;
87256: LD_ADDR_VAR 0 5
87260: PUSH
87261: LD_VAR 0 7
87265: PUSH
87266: LD_INT 1
87268: ARRAY
87269: PUSH
87270: LD_INT 2
87272: ARRAY
87273: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87274: LD_ADDR_VAR 0 6
87278: PUSH
87279: LD_VAR 0 7
87283: PUSH
87284: LD_INT 1
87286: ARRAY
87287: PUSH
87288: LD_INT 3
87290: ARRAY
87291: ST_TO_ADDR
// if InArea ( x , y , area ) then
87292: LD_VAR 0 5
87296: PPUSH
87297: LD_VAR 0 6
87301: PPUSH
87302: LD_VAR 0 2
87306: PPUSH
87307: CALL_OW 309
87311: IFFALSE 87322
// ComStop ( unit ) ;
87313: LD_VAR 0 1
87317: PPUSH
87318: CALL_OW 141
// end ;
87322: LD_VAR 0 4
87326: RET
// export function Abs ( value ) ; begin
87327: LD_INT 0
87329: PPUSH
// result := value ;
87330: LD_ADDR_VAR 0 2
87334: PUSH
87335: LD_VAR 0 1
87339: ST_TO_ADDR
// if value < 0 then
87340: LD_VAR 0 1
87344: PUSH
87345: LD_INT 0
87347: LESS
87348: IFFALSE 87365
// result := value * - 1 ;
87350: LD_ADDR_VAR 0 2
87354: PUSH
87355: LD_VAR 0 1
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: MUL
87364: ST_TO_ADDR
// end ;
87365: LD_VAR 0 2
87369: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87370: LD_INT 0
87372: PPUSH
87373: PPUSH
87374: PPUSH
87375: PPUSH
87376: PPUSH
87377: PPUSH
87378: PPUSH
87379: PPUSH
// if not unit or not building then
87380: LD_VAR 0 1
87384: NOT
87385: PUSH
87386: LD_VAR 0 2
87390: NOT
87391: OR
87392: IFFALSE 87396
// exit ;
87394: GO 87622
// x := GetX ( building ) ;
87396: LD_ADDR_VAR 0 4
87400: PUSH
87401: LD_VAR 0 2
87405: PPUSH
87406: CALL_OW 250
87410: ST_TO_ADDR
// y := GetY ( building ) ;
87411: LD_ADDR_VAR 0 6
87415: PUSH
87416: LD_VAR 0 2
87420: PPUSH
87421: CALL_OW 251
87425: ST_TO_ADDR
// d := GetDir ( building ) ;
87426: LD_ADDR_VAR 0 8
87430: PUSH
87431: LD_VAR 0 2
87435: PPUSH
87436: CALL_OW 254
87440: ST_TO_ADDR
// r := 4 ;
87441: LD_ADDR_VAR 0 9
87445: PUSH
87446: LD_INT 4
87448: ST_TO_ADDR
// for i := 1 to 5 do
87449: LD_ADDR_VAR 0 10
87453: PUSH
87454: DOUBLE
87455: LD_INT 1
87457: DEC
87458: ST_TO_ADDR
87459: LD_INT 5
87461: PUSH
87462: FOR_TO
87463: IFFALSE 87620
// begin _x := ShiftX ( x , d , r + i ) ;
87465: LD_ADDR_VAR 0 5
87469: PUSH
87470: LD_VAR 0 4
87474: PPUSH
87475: LD_VAR 0 8
87479: PPUSH
87480: LD_VAR 0 9
87484: PUSH
87485: LD_VAR 0 10
87489: PLUS
87490: PPUSH
87491: CALL_OW 272
87495: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87496: LD_ADDR_VAR 0 7
87500: PUSH
87501: LD_VAR 0 6
87505: PPUSH
87506: LD_VAR 0 8
87510: PPUSH
87511: LD_VAR 0 9
87515: PUSH
87516: LD_VAR 0 10
87520: PLUS
87521: PPUSH
87522: CALL_OW 273
87526: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87527: LD_VAR 0 5
87531: PPUSH
87532: LD_VAR 0 7
87536: PPUSH
87537: CALL_OW 488
87541: PUSH
87542: LD_VAR 0 5
87546: PPUSH
87547: LD_VAR 0 7
87551: PPUSH
87552: CALL_OW 428
87556: PPUSH
87557: CALL_OW 247
87561: PUSH
87562: LD_INT 3
87564: PUSH
87565: LD_INT 2
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: IN
87572: NOT
87573: AND
87574: IFFALSE 87618
// begin ComMoveXY ( unit , _x , _y ) ;
87576: LD_VAR 0 1
87580: PPUSH
87581: LD_VAR 0 5
87585: PPUSH
87586: LD_VAR 0 7
87590: PPUSH
87591: CALL_OW 111
// result := [ _x , _y ] ;
87595: LD_ADDR_VAR 0 3
87599: PUSH
87600: LD_VAR 0 5
87604: PUSH
87605: LD_VAR 0 7
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: ST_TO_ADDR
// exit ;
87614: POP
87615: POP
87616: GO 87622
// end ; end ;
87618: GO 87462
87620: POP
87621: POP
// end ;
87622: LD_VAR 0 3
87626: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87627: LD_INT 0
87629: PPUSH
87630: PPUSH
87631: PPUSH
// result := 0 ;
87632: LD_ADDR_VAR 0 3
87636: PUSH
87637: LD_INT 0
87639: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87640: LD_VAR 0 1
87644: PUSH
87645: LD_INT 0
87647: LESS
87648: PUSH
87649: LD_VAR 0 1
87653: PUSH
87654: LD_INT 8
87656: GREATER
87657: OR
87658: PUSH
87659: LD_VAR 0 2
87663: PUSH
87664: LD_INT 0
87666: LESS
87667: OR
87668: PUSH
87669: LD_VAR 0 2
87673: PUSH
87674: LD_INT 8
87676: GREATER
87677: OR
87678: IFFALSE 87682
// exit ;
87680: GO 87757
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87682: LD_ADDR_VAR 0 4
87686: PUSH
87687: LD_INT 22
87689: PUSH
87690: LD_VAR 0 2
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PPUSH
87699: CALL_OW 69
87703: PUSH
87704: FOR_IN
87705: IFFALSE 87755
// begin un := UnitShoot ( i ) ;
87707: LD_ADDR_VAR 0 5
87711: PUSH
87712: LD_VAR 0 4
87716: PPUSH
87717: CALL_OW 504
87721: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87722: LD_VAR 0 5
87726: PPUSH
87727: CALL_OW 255
87731: PUSH
87732: LD_VAR 0 1
87736: EQUAL
87737: IFFALSE 87753
// begin result := un ;
87739: LD_ADDR_VAR 0 3
87743: PUSH
87744: LD_VAR 0 5
87748: ST_TO_ADDR
// exit ;
87749: POP
87750: POP
87751: GO 87757
// end ; end ;
87753: GO 87704
87755: POP
87756: POP
// end ;
87757: LD_VAR 0 3
87761: RET
// export function GetCargoBay ( units ) ; begin
87762: LD_INT 0
87764: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87765: LD_ADDR_VAR 0 2
87769: PUSH
87770: LD_VAR 0 1
87774: PPUSH
87775: LD_INT 2
87777: PUSH
87778: LD_INT 34
87780: PUSH
87781: LD_INT 12
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 34
87790: PUSH
87791: LD_INT 51
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 34
87800: PUSH
87801: LD_INT 32
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 34
87810: PUSH
87811: LD_INT 89
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: PPUSH
87825: CALL_OW 72
87829: ST_TO_ADDR
// end ;
87830: LD_VAR 0 2
87834: RET
// export function Negate ( value ) ; begin
87835: LD_INT 0
87837: PPUSH
// result := not value ;
87838: LD_ADDR_VAR 0 2
87842: PUSH
87843: LD_VAR 0 1
87847: NOT
87848: ST_TO_ADDR
// end ;
87849: LD_VAR 0 2
87853: RET
// export function Inc ( value ) ; begin
87854: LD_INT 0
87856: PPUSH
// result := value + 1 ;
87857: LD_ADDR_VAR 0 2
87861: PUSH
87862: LD_VAR 0 1
87866: PUSH
87867: LD_INT 1
87869: PLUS
87870: ST_TO_ADDR
// end ;
87871: LD_VAR 0 2
87875: RET
// export function Dec ( value ) ; begin
87876: LD_INT 0
87878: PPUSH
// result := value - 1 ;
87879: LD_ADDR_VAR 0 2
87883: PUSH
87884: LD_VAR 0 1
87888: PUSH
87889: LD_INT 1
87891: MINUS
87892: ST_TO_ADDR
// end ;
87893: LD_VAR 0 2
87897: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87898: LD_INT 0
87900: PPUSH
87901: PPUSH
87902: PPUSH
87903: PPUSH
87904: PPUSH
87905: PPUSH
87906: PPUSH
87907: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87908: LD_VAR 0 1
87912: PPUSH
87913: LD_VAR 0 2
87917: PPUSH
87918: CALL_OW 488
87922: NOT
87923: PUSH
87924: LD_VAR 0 3
87928: PPUSH
87929: LD_VAR 0 4
87933: PPUSH
87934: CALL_OW 488
87938: NOT
87939: OR
87940: IFFALSE 87953
// begin result := - 1 ;
87942: LD_ADDR_VAR 0 5
87946: PUSH
87947: LD_INT 1
87949: NEG
87950: ST_TO_ADDR
// exit ;
87951: GO 88188
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87953: LD_ADDR_VAR 0 12
87957: PUSH
87958: LD_VAR 0 1
87962: PPUSH
87963: LD_VAR 0 2
87967: PPUSH
87968: LD_VAR 0 3
87972: PPUSH
87973: LD_VAR 0 4
87977: PPUSH
87978: CALL 87038 0 4
87982: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87983: LD_ADDR_VAR 0 11
87987: PUSH
87988: LD_VAR 0 1
87992: PPUSH
87993: LD_VAR 0 2
87997: PPUSH
87998: LD_VAR 0 12
88002: PUSH
88003: LD_INT 1
88005: ARRAY
88006: PPUSH
88007: LD_VAR 0 12
88011: PUSH
88012: LD_INT 2
88014: ARRAY
88015: PPUSH
88016: CALL_OW 298
88020: ST_TO_ADDR
// distance := 9999 ;
88021: LD_ADDR_VAR 0 10
88025: PUSH
88026: LD_INT 9999
88028: ST_TO_ADDR
// for i := 0 to 5 do
88029: LD_ADDR_VAR 0 6
88033: PUSH
88034: DOUBLE
88035: LD_INT 0
88037: DEC
88038: ST_TO_ADDR
88039: LD_INT 5
88041: PUSH
88042: FOR_TO
88043: IFFALSE 88186
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88045: LD_ADDR_VAR 0 7
88049: PUSH
88050: LD_VAR 0 1
88054: PPUSH
88055: LD_VAR 0 6
88059: PPUSH
88060: LD_VAR 0 11
88064: PPUSH
88065: CALL_OW 272
88069: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88070: LD_ADDR_VAR 0 8
88074: PUSH
88075: LD_VAR 0 2
88079: PPUSH
88080: LD_VAR 0 6
88084: PPUSH
88085: LD_VAR 0 11
88089: PPUSH
88090: CALL_OW 273
88094: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88095: LD_VAR 0 7
88099: PPUSH
88100: LD_VAR 0 8
88104: PPUSH
88105: CALL_OW 488
88109: NOT
88110: IFFALSE 88114
// continue ;
88112: GO 88042
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88114: LD_ADDR_VAR 0 9
88118: PUSH
88119: LD_VAR 0 12
88123: PUSH
88124: LD_INT 1
88126: ARRAY
88127: PPUSH
88128: LD_VAR 0 12
88132: PUSH
88133: LD_INT 2
88135: ARRAY
88136: PPUSH
88137: LD_VAR 0 7
88141: PPUSH
88142: LD_VAR 0 8
88146: PPUSH
88147: CALL_OW 298
88151: ST_TO_ADDR
// if tmp < distance then
88152: LD_VAR 0 9
88156: PUSH
88157: LD_VAR 0 10
88161: LESS
88162: IFFALSE 88184
// begin result := i ;
88164: LD_ADDR_VAR 0 5
88168: PUSH
88169: LD_VAR 0 6
88173: ST_TO_ADDR
// distance := tmp ;
88174: LD_ADDR_VAR 0 10
88178: PUSH
88179: LD_VAR 0 9
88183: ST_TO_ADDR
// end ; end ;
88184: GO 88042
88186: POP
88187: POP
// end ;
88188: LD_VAR 0 5
88192: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88193: LD_INT 0
88195: PPUSH
88196: PPUSH
// if not driver or not IsInUnit ( driver ) then
88197: LD_VAR 0 1
88201: NOT
88202: PUSH
88203: LD_VAR 0 1
88207: PPUSH
88208: CALL_OW 310
88212: NOT
88213: OR
88214: IFFALSE 88218
// exit ;
88216: GO 88308
// vehicle := IsInUnit ( driver ) ;
88218: LD_ADDR_VAR 0 3
88222: PUSH
88223: LD_VAR 0 1
88227: PPUSH
88228: CALL_OW 310
88232: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88233: LD_VAR 0 1
88237: PPUSH
88238: LD_STRING \
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: LD_INT 0
88249: PUSH
88250: LD_INT 0
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: PUSH
88268: LD_STRING E
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: LD_INT 0
88276: PUSH
88277: LD_VAR 0 3
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: LD_INT 0
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PPUSH
88304: CALL_OW 446
// end ;
88308: LD_VAR 0 2
88312: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88313: LD_INT 0
88315: PPUSH
88316: PPUSH
// if not driver or not IsInUnit ( driver ) then
88317: LD_VAR 0 1
88321: NOT
88322: PUSH
88323: LD_VAR 0 1
88327: PPUSH
88328: CALL_OW 310
88332: NOT
88333: OR
88334: IFFALSE 88338
// exit ;
88336: GO 88428
// vehicle := IsInUnit ( driver ) ;
88338: LD_ADDR_VAR 0 3
88342: PUSH
88343: LD_VAR 0 1
88347: PPUSH
88348: CALL_OW 310
88352: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88353: LD_VAR 0 1
88357: PPUSH
88358: LD_STRING \
88360: PUSH
88361: LD_INT 0
88363: PUSH
88364: LD_INT 0
88366: PUSH
88367: LD_INT 0
88369: PUSH
88370: LD_INT 0
88372: PUSH
88373: LD_INT 0
88375: PUSH
88376: LD_INT 0
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: PUSH
88388: LD_STRING E
88390: PUSH
88391: LD_INT 0
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: LD_VAR 0 3
88401: PUSH
88402: LD_INT 0
88404: PUSH
88405: LD_INT 0
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PPUSH
88424: CALL_OW 447
// end ;
88428: LD_VAR 0 2
88432: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88433: LD_INT 0
88435: PPUSH
88436: PPUSH
88437: PPUSH
// tmp := [ ] ;
88438: LD_ADDR_VAR 0 5
88442: PUSH
88443: EMPTY
88444: ST_TO_ADDR
// for i in units do
88445: LD_ADDR_VAR 0 4
88449: PUSH
88450: LD_VAR 0 1
88454: PUSH
88455: FOR_IN
88456: IFFALSE 88494
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88458: LD_ADDR_VAR 0 5
88462: PUSH
88463: LD_VAR 0 5
88467: PPUSH
88468: LD_VAR 0 5
88472: PUSH
88473: LD_INT 1
88475: PLUS
88476: PPUSH
88477: LD_VAR 0 4
88481: PPUSH
88482: CALL_OW 256
88486: PPUSH
88487: CALL_OW 2
88491: ST_TO_ADDR
88492: GO 88455
88494: POP
88495: POP
// if not tmp then
88496: LD_VAR 0 5
88500: NOT
88501: IFFALSE 88505
// exit ;
88503: GO 88553
// if asc then
88505: LD_VAR 0 2
88509: IFFALSE 88533
// result := SortListByListAsc ( units , tmp ) else
88511: LD_ADDR_VAR 0 3
88515: PUSH
88516: LD_VAR 0 1
88520: PPUSH
88521: LD_VAR 0 5
88525: PPUSH
88526: CALL_OW 76
88530: ST_TO_ADDR
88531: GO 88553
// result := SortListByListDesc ( units , tmp ) ;
88533: LD_ADDR_VAR 0 3
88537: PUSH
88538: LD_VAR 0 1
88542: PPUSH
88543: LD_VAR 0 5
88547: PPUSH
88548: CALL_OW 77
88552: ST_TO_ADDR
// end ;
88553: LD_VAR 0 3
88557: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88558: LD_INT 0
88560: PPUSH
88561: PPUSH
// task := GetTaskList ( mech ) ;
88562: LD_ADDR_VAR 0 4
88566: PUSH
88567: LD_VAR 0 1
88571: PPUSH
88572: CALL_OW 437
88576: ST_TO_ADDR
// if not task then
88577: LD_VAR 0 4
88581: NOT
88582: IFFALSE 88586
// exit ;
88584: GO 88628
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88586: LD_ADDR_VAR 0 3
88590: PUSH
88591: LD_VAR 0 4
88595: PUSH
88596: LD_INT 1
88598: ARRAY
88599: PUSH
88600: LD_INT 1
88602: ARRAY
88603: PUSH
88604: LD_STRING r
88606: EQUAL
88607: PUSH
88608: LD_VAR 0 4
88612: PUSH
88613: LD_INT 1
88615: ARRAY
88616: PUSH
88617: LD_INT 4
88619: ARRAY
88620: PUSH
88621: LD_VAR 0 2
88625: EQUAL
88626: AND
88627: ST_TO_ADDR
// end ;
88628: LD_VAR 0 3
88632: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88633: LD_INT 0
88635: PPUSH
// SetDir ( unit , d ) ;
88636: LD_VAR 0 1
88640: PPUSH
88641: LD_VAR 0 4
88645: PPUSH
88646: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88650: LD_VAR 0 1
88654: PPUSH
88655: LD_VAR 0 2
88659: PPUSH
88660: LD_VAR 0 3
88664: PPUSH
88665: LD_VAR 0 5
88669: PPUSH
88670: CALL_OW 48
// end ;
88674: LD_VAR 0 6
88678: RET
// export function ToNaturalNumber ( number ) ; begin
88679: LD_INT 0
88681: PPUSH
// result := number div 1 ;
88682: LD_ADDR_VAR 0 2
88686: PUSH
88687: LD_VAR 0 1
88691: PUSH
88692: LD_INT 1
88694: DIV
88695: ST_TO_ADDR
// if number < 0 then
88696: LD_VAR 0 1
88700: PUSH
88701: LD_INT 0
88703: LESS
88704: IFFALSE 88714
// result := 0 ;
88706: LD_ADDR_VAR 0 2
88710: PUSH
88711: LD_INT 0
88713: ST_TO_ADDR
// end ;
88714: LD_VAR 0 2
88718: RET
// export function SortByClass ( units , class ) ; var un ; begin
88719: LD_INT 0
88721: PPUSH
88722: PPUSH
// if not units or not class then
88723: LD_VAR 0 1
88727: NOT
88728: PUSH
88729: LD_VAR 0 2
88733: NOT
88734: OR
88735: IFFALSE 88739
// exit ;
88737: GO 88834
// result := [ ] ;
88739: LD_ADDR_VAR 0 3
88743: PUSH
88744: EMPTY
88745: ST_TO_ADDR
// for un in units do
88746: LD_ADDR_VAR 0 4
88750: PUSH
88751: LD_VAR 0 1
88755: PUSH
88756: FOR_IN
88757: IFFALSE 88832
// if GetClass ( un ) = class then
88759: LD_VAR 0 4
88763: PPUSH
88764: CALL_OW 257
88768: PUSH
88769: LD_VAR 0 2
88773: EQUAL
88774: IFFALSE 88801
// result := Insert ( result , 1 , un ) else
88776: LD_ADDR_VAR 0 3
88780: PUSH
88781: LD_VAR 0 3
88785: PPUSH
88786: LD_INT 1
88788: PPUSH
88789: LD_VAR 0 4
88793: PPUSH
88794: CALL_OW 2
88798: ST_TO_ADDR
88799: GO 88830
// result := Replace ( result , result + 1 , un ) ;
88801: LD_ADDR_VAR 0 3
88805: PUSH
88806: LD_VAR 0 3
88810: PPUSH
88811: LD_VAR 0 3
88815: PUSH
88816: LD_INT 1
88818: PLUS
88819: PPUSH
88820: LD_VAR 0 4
88824: PPUSH
88825: CALL_OW 1
88829: ST_TO_ADDR
88830: GO 88756
88832: POP
88833: POP
// end ;
88834: LD_VAR 0 3
88838: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88839: LD_INT 0
88841: PPUSH
88842: PPUSH
88843: PPUSH
88844: PPUSH
88845: PPUSH
88846: PPUSH
88847: PPUSH
// result := [ ] ;
88848: LD_ADDR_VAR 0 4
88852: PUSH
88853: EMPTY
88854: ST_TO_ADDR
// if x - r < 0 then
88855: LD_VAR 0 1
88859: PUSH
88860: LD_VAR 0 3
88864: MINUS
88865: PUSH
88866: LD_INT 0
88868: LESS
88869: IFFALSE 88881
// min_x := 0 else
88871: LD_ADDR_VAR 0 8
88875: PUSH
88876: LD_INT 0
88878: ST_TO_ADDR
88879: GO 88897
// min_x := x - r ;
88881: LD_ADDR_VAR 0 8
88885: PUSH
88886: LD_VAR 0 1
88890: PUSH
88891: LD_VAR 0 3
88895: MINUS
88896: ST_TO_ADDR
// if y - r < 0 then
88897: LD_VAR 0 2
88901: PUSH
88902: LD_VAR 0 3
88906: MINUS
88907: PUSH
88908: LD_INT 0
88910: LESS
88911: IFFALSE 88923
// min_y := 0 else
88913: LD_ADDR_VAR 0 7
88917: PUSH
88918: LD_INT 0
88920: ST_TO_ADDR
88921: GO 88939
// min_y := y - r ;
88923: LD_ADDR_VAR 0 7
88927: PUSH
88928: LD_VAR 0 2
88932: PUSH
88933: LD_VAR 0 3
88937: MINUS
88938: ST_TO_ADDR
// max_x := x + r ;
88939: LD_ADDR_VAR 0 9
88943: PUSH
88944: LD_VAR 0 1
88948: PUSH
88949: LD_VAR 0 3
88953: PLUS
88954: ST_TO_ADDR
// max_y := y + r ;
88955: LD_ADDR_VAR 0 10
88959: PUSH
88960: LD_VAR 0 2
88964: PUSH
88965: LD_VAR 0 3
88969: PLUS
88970: ST_TO_ADDR
// for _x = min_x to max_x do
88971: LD_ADDR_VAR 0 5
88975: PUSH
88976: DOUBLE
88977: LD_VAR 0 8
88981: DEC
88982: ST_TO_ADDR
88983: LD_VAR 0 9
88987: PUSH
88988: FOR_TO
88989: IFFALSE 89090
// for _y = min_y to max_y do
88991: LD_ADDR_VAR 0 6
88995: PUSH
88996: DOUBLE
88997: LD_VAR 0 7
89001: DEC
89002: ST_TO_ADDR
89003: LD_VAR 0 10
89007: PUSH
89008: FOR_TO
89009: IFFALSE 89086
// begin if not ValidHex ( _x , _y ) then
89011: LD_VAR 0 5
89015: PPUSH
89016: LD_VAR 0 6
89020: PPUSH
89021: CALL_OW 488
89025: NOT
89026: IFFALSE 89030
// continue ;
89028: GO 89008
// if GetResourceTypeXY ( _x , _y ) then
89030: LD_VAR 0 5
89034: PPUSH
89035: LD_VAR 0 6
89039: PPUSH
89040: CALL_OW 283
89044: IFFALSE 89084
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89046: LD_ADDR_VAR 0 4
89050: PUSH
89051: LD_VAR 0 4
89055: PPUSH
89056: LD_VAR 0 4
89060: PUSH
89061: LD_INT 1
89063: PLUS
89064: PPUSH
89065: LD_VAR 0 5
89069: PUSH
89070: LD_VAR 0 6
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PPUSH
89079: CALL_OW 1
89083: ST_TO_ADDR
// end ;
89084: GO 89008
89086: POP
89087: POP
89088: GO 88988
89090: POP
89091: POP
// end ;
89092: LD_VAR 0 4
89096: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89097: LD_INT 0
89099: PPUSH
89100: PPUSH
89101: PPUSH
89102: PPUSH
89103: PPUSH
89104: PPUSH
89105: PPUSH
89106: PPUSH
// if not units then
89107: LD_VAR 0 1
89111: NOT
89112: IFFALSE 89116
// exit ;
89114: GO 89640
// result := UnitFilter ( units , [ f_ok ] ) ;
89116: LD_ADDR_VAR 0 3
89120: PUSH
89121: LD_VAR 0 1
89125: PPUSH
89126: LD_INT 50
89128: PUSH
89129: EMPTY
89130: LIST
89131: PPUSH
89132: CALL_OW 72
89136: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89137: LD_ADDR_VAR 0 8
89141: PUSH
89142: LD_VAR 0 1
89146: PUSH
89147: LD_INT 1
89149: ARRAY
89150: PPUSH
89151: CALL_OW 255
89155: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89156: LD_ADDR_VAR 0 10
89160: PUSH
89161: LD_INT 29
89163: PUSH
89164: LD_INT 91
89166: PUSH
89167: LD_INT 49
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: LIST
89174: ST_TO_ADDR
// if not result then
89175: LD_VAR 0 3
89179: NOT
89180: IFFALSE 89184
// exit ;
89182: GO 89640
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89184: LD_ADDR_VAR 0 5
89188: PUSH
89189: LD_INT 81
89191: PUSH
89192: LD_VAR 0 8
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PPUSH
89201: CALL_OW 69
89205: ST_TO_ADDR
// for i in result do
89206: LD_ADDR_VAR 0 4
89210: PUSH
89211: LD_VAR 0 3
89215: PUSH
89216: FOR_IN
89217: IFFALSE 89638
// begin tag := GetTag ( i ) + 1 ;
89219: LD_ADDR_VAR 0 9
89223: PUSH
89224: LD_VAR 0 4
89228: PPUSH
89229: CALL_OW 110
89233: PUSH
89234: LD_INT 1
89236: PLUS
89237: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89238: LD_ADDR_VAR 0 7
89242: PUSH
89243: LD_VAR 0 4
89247: PPUSH
89248: CALL_OW 250
89252: PPUSH
89253: LD_VAR 0 4
89257: PPUSH
89258: CALL_OW 251
89262: PPUSH
89263: LD_INT 6
89265: PPUSH
89266: CALL 88839 0 3
89270: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89271: LD_VAR 0 4
89275: PPUSH
89276: CALL_OW 247
89280: PUSH
89281: LD_INT 2
89283: EQUAL
89284: PUSH
89285: LD_VAR 0 7
89289: AND
89290: PUSH
89291: LD_VAR 0 4
89295: PPUSH
89296: CALL_OW 264
89300: PUSH
89301: LD_VAR 0 10
89305: IN
89306: NOT
89307: AND
89308: IFFALSE 89347
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89310: LD_VAR 0 4
89314: PPUSH
89315: LD_VAR 0 7
89319: PUSH
89320: LD_INT 1
89322: ARRAY
89323: PUSH
89324: LD_INT 1
89326: ARRAY
89327: PPUSH
89328: LD_VAR 0 7
89332: PUSH
89333: LD_INT 1
89335: ARRAY
89336: PUSH
89337: LD_INT 2
89339: ARRAY
89340: PPUSH
89341: CALL_OW 116
89345: GO 89636
// if path > tag then
89347: LD_VAR 0 2
89351: PUSH
89352: LD_VAR 0 9
89356: GREATER
89357: IFFALSE 89565
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89359: LD_ADDR_VAR 0 6
89363: PUSH
89364: LD_VAR 0 5
89368: PPUSH
89369: LD_INT 91
89371: PUSH
89372: LD_VAR 0 4
89376: PUSH
89377: LD_INT 8
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: LIST
89384: PPUSH
89385: CALL_OW 72
89389: ST_TO_ADDR
// if nearEnemy then
89390: LD_VAR 0 6
89394: IFFALSE 89463
// begin if GetWeapon ( i ) = ru_time_lapser then
89396: LD_VAR 0 4
89400: PPUSH
89401: CALL_OW 264
89405: PUSH
89406: LD_INT 49
89408: EQUAL
89409: IFFALSE 89437
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89411: LD_VAR 0 4
89415: PPUSH
89416: LD_VAR 0 6
89420: PPUSH
89421: LD_VAR 0 4
89425: PPUSH
89426: CALL_OW 74
89430: PPUSH
89431: CALL_OW 112
89435: GO 89461
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89437: LD_VAR 0 4
89441: PPUSH
89442: LD_VAR 0 6
89446: PPUSH
89447: LD_VAR 0 4
89451: PPUSH
89452: CALL_OW 74
89456: PPUSH
89457: CALL_OW 115
// end else
89461: GO 89563
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89463: LD_VAR 0 4
89467: PPUSH
89468: LD_VAR 0 2
89472: PUSH
89473: LD_VAR 0 9
89477: ARRAY
89478: PUSH
89479: LD_INT 1
89481: ARRAY
89482: PPUSH
89483: LD_VAR 0 2
89487: PUSH
89488: LD_VAR 0 9
89492: ARRAY
89493: PUSH
89494: LD_INT 2
89496: ARRAY
89497: PPUSH
89498: CALL_OW 297
89502: PUSH
89503: LD_INT 6
89505: GREATER
89506: IFFALSE 89549
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89508: LD_VAR 0 4
89512: PPUSH
89513: LD_VAR 0 2
89517: PUSH
89518: LD_VAR 0 9
89522: ARRAY
89523: PUSH
89524: LD_INT 1
89526: ARRAY
89527: PPUSH
89528: LD_VAR 0 2
89532: PUSH
89533: LD_VAR 0 9
89537: ARRAY
89538: PUSH
89539: LD_INT 2
89541: ARRAY
89542: PPUSH
89543: CALL_OW 114
89547: GO 89563
// SetTag ( i , tag ) ;
89549: LD_VAR 0 4
89553: PPUSH
89554: LD_VAR 0 9
89558: PPUSH
89559: CALL_OW 109
// end else
89563: GO 89636
// if enemy then
89565: LD_VAR 0 5
89569: IFFALSE 89636
// begin if GetWeapon ( i ) = ru_time_lapser then
89571: LD_VAR 0 4
89575: PPUSH
89576: CALL_OW 264
89580: PUSH
89581: LD_INT 49
89583: EQUAL
89584: IFFALSE 89612
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89586: LD_VAR 0 4
89590: PPUSH
89591: LD_VAR 0 5
89595: PPUSH
89596: LD_VAR 0 4
89600: PPUSH
89601: CALL_OW 74
89605: PPUSH
89606: CALL_OW 112
89610: GO 89636
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89612: LD_VAR 0 4
89616: PPUSH
89617: LD_VAR 0 5
89621: PPUSH
89622: LD_VAR 0 4
89626: PPUSH
89627: CALL_OW 74
89631: PPUSH
89632: CALL_OW 115
// end ; end ;
89636: GO 89216
89638: POP
89639: POP
// end ;
89640: LD_VAR 0 3
89644: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89645: LD_INT 0
89647: PPUSH
89648: PPUSH
89649: PPUSH
// if not unit or IsInUnit ( unit ) then
89650: LD_VAR 0 1
89654: NOT
89655: PUSH
89656: LD_VAR 0 1
89660: PPUSH
89661: CALL_OW 310
89665: OR
89666: IFFALSE 89670
// exit ;
89668: GO 89761
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89670: LD_ADDR_VAR 0 4
89674: PUSH
89675: LD_VAR 0 1
89679: PPUSH
89680: CALL_OW 250
89684: PPUSH
89685: LD_VAR 0 2
89689: PPUSH
89690: LD_INT 1
89692: PPUSH
89693: CALL_OW 272
89697: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89698: LD_ADDR_VAR 0 5
89702: PUSH
89703: LD_VAR 0 1
89707: PPUSH
89708: CALL_OW 251
89712: PPUSH
89713: LD_VAR 0 2
89717: PPUSH
89718: LD_INT 1
89720: PPUSH
89721: CALL_OW 273
89725: ST_TO_ADDR
// if ValidHex ( x , y ) then
89726: LD_VAR 0 4
89730: PPUSH
89731: LD_VAR 0 5
89735: PPUSH
89736: CALL_OW 488
89740: IFFALSE 89761
// ComTurnXY ( unit , x , y ) ;
89742: LD_VAR 0 1
89746: PPUSH
89747: LD_VAR 0 4
89751: PPUSH
89752: LD_VAR 0 5
89756: PPUSH
89757: CALL_OW 118
// end ;
89761: LD_VAR 0 3
89765: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89766: LD_INT 0
89768: PPUSH
89769: PPUSH
// result := false ;
89770: LD_ADDR_VAR 0 3
89774: PUSH
89775: LD_INT 0
89777: ST_TO_ADDR
// if not units then
89778: LD_VAR 0 2
89782: NOT
89783: IFFALSE 89787
// exit ;
89785: GO 89832
// for i in units do
89787: LD_ADDR_VAR 0 4
89791: PUSH
89792: LD_VAR 0 2
89796: PUSH
89797: FOR_IN
89798: IFFALSE 89830
// if See ( side , i ) then
89800: LD_VAR 0 1
89804: PPUSH
89805: LD_VAR 0 4
89809: PPUSH
89810: CALL_OW 292
89814: IFFALSE 89828
// begin result := true ;
89816: LD_ADDR_VAR 0 3
89820: PUSH
89821: LD_INT 1
89823: ST_TO_ADDR
// exit ;
89824: POP
89825: POP
89826: GO 89832
// end ;
89828: GO 89797
89830: POP
89831: POP
// end ;
89832: LD_VAR 0 3
89836: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89837: LD_INT 0
89839: PPUSH
89840: PPUSH
89841: PPUSH
89842: PPUSH
// if not unit or not points then
89843: LD_VAR 0 1
89847: NOT
89848: PUSH
89849: LD_VAR 0 2
89853: NOT
89854: OR
89855: IFFALSE 89859
// exit ;
89857: GO 89949
// dist := 99999 ;
89859: LD_ADDR_VAR 0 5
89863: PUSH
89864: LD_INT 99999
89866: ST_TO_ADDR
// for i in points do
89867: LD_ADDR_VAR 0 4
89871: PUSH
89872: LD_VAR 0 2
89876: PUSH
89877: FOR_IN
89878: IFFALSE 89947
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89880: LD_ADDR_VAR 0 6
89884: PUSH
89885: LD_VAR 0 1
89889: PPUSH
89890: LD_VAR 0 4
89894: PUSH
89895: LD_INT 1
89897: ARRAY
89898: PPUSH
89899: LD_VAR 0 4
89903: PUSH
89904: LD_INT 2
89906: ARRAY
89907: PPUSH
89908: CALL_OW 297
89912: ST_TO_ADDR
// if tmpDist < dist then
89913: LD_VAR 0 6
89917: PUSH
89918: LD_VAR 0 5
89922: LESS
89923: IFFALSE 89945
// begin result := i ;
89925: LD_ADDR_VAR 0 3
89929: PUSH
89930: LD_VAR 0 4
89934: ST_TO_ADDR
// dist := tmpDist ;
89935: LD_ADDR_VAR 0 5
89939: PUSH
89940: LD_VAR 0 6
89944: ST_TO_ADDR
// end ; end ;
89945: GO 89877
89947: POP
89948: POP
// end ;
89949: LD_VAR 0 3
89953: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89954: LD_INT 0
89956: PPUSH
// uc_side := side ;
89957: LD_ADDR_OWVAR 20
89961: PUSH
89962: LD_VAR 0 1
89966: ST_TO_ADDR
// uc_nation := 3 ;
89967: LD_ADDR_OWVAR 21
89971: PUSH
89972: LD_INT 3
89974: ST_TO_ADDR
// vc_chassis := 25 ;
89975: LD_ADDR_OWVAR 37
89979: PUSH
89980: LD_INT 25
89982: ST_TO_ADDR
// vc_engine := engine_siberite ;
89983: LD_ADDR_OWVAR 39
89987: PUSH
89988: LD_INT 3
89990: ST_TO_ADDR
// vc_control := control_computer ;
89991: LD_ADDR_OWVAR 38
89995: PUSH
89996: LD_INT 3
89998: ST_TO_ADDR
// vc_weapon := 59 ;
89999: LD_ADDR_OWVAR 40
90003: PUSH
90004: LD_INT 59
90006: ST_TO_ADDR
// result := CreateVehicle ;
90007: LD_ADDR_VAR 0 5
90011: PUSH
90012: CALL_OW 45
90016: ST_TO_ADDR
// SetDir ( result , d ) ;
90017: LD_VAR 0 5
90021: PPUSH
90022: LD_VAR 0 4
90026: PPUSH
90027: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90031: LD_VAR 0 5
90035: PPUSH
90036: LD_VAR 0 2
90040: PPUSH
90041: LD_VAR 0 3
90045: PPUSH
90046: LD_INT 0
90048: PPUSH
90049: CALL_OW 48
// end ;
90053: LD_VAR 0 5
90057: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90058: LD_INT 0
90060: PPUSH
90061: PPUSH
90062: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90063: LD_ADDR_VAR 0 2
90067: PUSH
90068: LD_INT 0
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: LD_INT 0
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90086: LD_VAR 0 1
90090: NOT
90091: PUSH
90092: LD_VAR 0 1
90096: PPUSH
90097: CALL_OW 264
90101: PUSH
90102: LD_INT 12
90104: PUSH
90105: LD_INT 51
90107: PUSH
90108: LD_INT 32
90110: PUSH
90111: LD_INT 89
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: IN
90120: NOT
90121: OR
90122: IFFALSE 90126
// exit ;
90124: GO 90224
// for i := 1 to 3 do
90126: LD_ADDR_VAR 0 3
90130: PUSH
90131: DOUBLE
90132: LD_INT 1
90134: DEC
90135: ST_TO_ADDR
90136: LD_INT 3
90138: PUSH
90139: FOR_TO
90140: IFFALSE 90222
// begin tmp := GetCargo ( cargo , i ) ;
90142: LD_ADDR_VAR 0 4
90146: PUSH
90147: LD_VAR 0 1
90151: PPUSH
90152: LD_VAR 0 3
90156: PPUSH
90157: CALL_OW 289
90161: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90162: LD_ADDR_VAR 0 2
90166: PUSH
90167: LD_VAR 0 2
90171: PPUSH
90172: LD_VAR 0 3
90176: PPUSH
90177: LD_VAR 0 4
90181: PPUSH
90182: CALL_OW 1
90186: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90187: LD_ADDR_VAR 0 2
90191: PUSH
90192: LD_VAR 0 2
90196: PPUSH
90197: LD_INT 4
90199: PPUSH
90200: LD_VAR 0 2
90204: PUSH
90205: LD_INT 4
90207: ARRAY
90208: PUSH
90209: LD_VAR 0 4
90213: PLUS
90214: PPUSH
90215: CALL_OW 1
90219: ST_TO_ADDR
// end ;
90220: GO 90139
90222: POP
90223: POP
// end ;
90224: LD_VAR 0 2
90228: RET
// export function Length ( array ) ; begin
90229: LD_INT 0
90231: PPUSH
// result := array + 0 ;
90232: LD_ADDR_VAR 0 2
90236: PUSH
90237: LD_VAR 0 1
90241: PUSH
90242: LD_INT 0
90244: PLUS
90245: ST_TO_ADDR
// end ;
90246: LD_VAR 0 2
90250: RET
// export function PrepareArray ( array ) ; begin
90251: LD_INT 0
90253: PPUSH
// result := array diff 0 ;
90254: LD_ADDR_VAR 0 2
90258: PUSH
90259: LD_VAR 0 1
90263: PUSH
90264: LD_INT 0
90266: DIFF
90267: ST_TO_ADDR
// if not result [ 1 ] then
90268: LD_VAR 0 2
90272: PUSH
90273: LD_INT 1
90275: ARRAY
90276: NOT
90277: IFFALSE 90297
// result := Delete ( result , 1 ) ;
90279: LD_ADDR_VAR 0 2
90283: PUSH
90284: LD_VAR 0 2
90288: PPUSH
90289: LD_INT 1
90291: PPUSH
90292: CALL_OW 3
90296: ST_TO_ADDR
// end ;
90297: LD_VAR 0 2
90301: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90302: LD_INT 0
90304: PPUSH
90305: PPUSH
90306: PPUSH
90307: PPUSH
// sibRocketRange := 25 ;
90308: LD_ADDR_VAR 0 6
90312: PUSH
90313: LD_INT 25
90315: ST_TO_ADDR
// result := false ;
90316: LD_ADDR_VAR 0 4
90320: PUSH
90321: LD_INT 0
90323: ST_TO_ADDR
// for i := 0 to 5 do
90324: LD_ADDR_VAR 0 5
90328: PUSH
90329: DOUBLE
90330: LD_INT 0
90332: DEC
90333: ST_TO_ADDR
90334: LD_INT 5
90336: PUSH
90337: FOR_TO
90338: IFFALSE 90405
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90340: LD_VAR 0 1
90344: PPUSH
90345: LD_VAR 0 5
90349: PPUSH
90350: LD_VAR 0 6
90354: PPUSH
90355: CALL_OW 272
90359: PPUSH
90360: LD_VAR 0 2
90364: PPUSH
90365: LD_VAR 0 5
90369: PPUSH
90370: LD_VAR 0 6
90374: PPUSH
90375: CALL_OW 273
90379: PPUSH
90380: LD_VAR 0 3
90384: PPUSH
90385: CALL_OW 309
90389: IFFALSE 90403
// begin result := true ;
90391: LD_ADDR_VAR 0 4
90395: PUSH
90396: LD_INT 1
90398: ST_TO_ADDR
// exit ;
90399: POP
90400: POP
90401: GO 90407
// end ;
90403: GO 90337
90405: POP
90406: POP
// end ;
90407: LD_VAR 0 4
90411: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90412: LD_INT 0
90414: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90415: LD_VAR 0 1
90419: PPUSH
90420: LD_VAR 0 2
90424: PPUSH
90425: LD_INT 0
90427: PPUSH
90428: LD_INT 0
90430: PPUSH
90431: LD_INT 1
90433: PPUSH
90434: LD_INT 0
90436: PPUSH
90437: CALL_OW 587
// end ; end_of_file end_of_file
90441: LD_VAR 0 3
90445: RET
// export globalGameSaveCounter ; every 0 0$1 do
90446: GO 90448
90448: DISABLE
// begin enable ;
90449: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90450: LD_STRING updateTimer(
90452: PUSH
90453: LD_OWVAR 1
90457: STR
90458: PUSH
90459: LD_STRING );
90461: STR
90462: PPUSH
90463: CALL_OW 559
// end ;
90467: END
// every 0 0$1 do
90468: GO 90470
90470: DISABLE
// begin globalGameSaveCounter := 0 ;
90471: LD_ADDR_EXP 95
90475: PUSH
90476: LD_INT 0
90478: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90479: LD_STRING setGameSaveCounter(0)
90481: PPUSH
90482: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90486: LD_STRING initStreamRollete();
90488: PPUSH
90489: CALL_OW 559
// InitStreamMode ;
90493: CALL 91819 0 0
// DefineStreamItems ( false ) ;
90497: LD_INT 0
90499: PPUSH
90500: CALL 92283 0 1
// end ;
90504: END
// export function SOS_MapStart ( ) ; begin
90505: LD_INT 0
90507: PPUSH
// if streamModeActive then
90508: LD_EXP 96
90512: IFFALSE 90521
// DefineStreamItems ( true ) ;
90514: LD_INT 1
90516: PPUSH
90517: CALL 92283 0 1
// UpdateLuaVariables ( ) ;
90521: CALL 90538 0 0
// UpdateFactoryWaypoints ( ) ;
90525: CALL 105144 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90529: CALL 105401 0 0
// end ;
90533: LD_VAR 0 1
90537: RET
// function UpdateLuaVariables ( ) ; begin
90538: LD_INT 0
90540: PPUSH
// if globalGameSaveCounter then
90541: LD_EXP 95
90545: IFFALSE 90579
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90547: LD_ADDR_EXP 95
90551: PUSH
90552: LD_EXP 95
90556: PPUSH
90557: CALL 87854 0 1
90561: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90562: LD_STRING setGameSaveCounter(
90564: PUSH
90565: LD_EXP 95
90569: STR
90570: PUSH
90571: LD_STRING )
90573: STR
90574: PPUSH
90575: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90579: LD_STRING setGameDifficulty(
90581: PUSH
90582: LD_OWVAR 67
90586: STR
90587: PUSH
90588: LD_STRING )
90590: STR
90591: PPUSH
90592: CALL_OW 559
// end ;
90596: LD_VAR 0 1
90600: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90601: LD_INT 0
90603: PPUSH
// if p2 = stream_mode then
90604: LD_VAR 0 2
90608: PUSH
90609: LD_INT 100
90611: EQUAL
90612: IFFALSE 91615
// begin if not StreamModeActive then
90614: LD_EXP 96
90618: NOT
90619: IFFALSE 90629
// StreamModeActive := true ;
90621: LD_ADDR_EXP 96
90625: PUSH
90626: LD_INT 1
90628: ST_TO_ADDR
// if p3 = 0 then
90629: LD_VAR 0 3
90633: PUSH
90634: LD_INT 0
90636: EQUAL
90637: IFFALSE 90643
// InitStreamMode ;
90639: CALL 91819 0 0
// if p3 = 1 then
90643: LD_VAR 0 3
90647: PUSH
90648: LD_INT 1
90650: EQUAL
90651: IFFALSE 90661
// sRocket := true ;
90653: LD_ADDR_EXP 101
90657: PUSH
90658: LD_INT 1
90660: ST_TO_ADDR
// if p3 = 2 then
90661: LD_VAR 0 3
90665: PUSH
90666: LD_INT 2
90668: EQUAL
90669: IFFALSE 90679
// sSpeed := true ;
90671: LD_ADDR_EXP 100
90675: PUSH
90676: LD_INT 1
90678: ST_TO_ADDR
// if p3 = 3 then
90679: LD_VAR 0 3
90683: PUSH
90684: LD_INT 3
90686: EQUAL
90687: IFFALSE 90697
// sEngine := true ;
90689: LD_ADDR_EXP 102
90693: PUSH
90694: LD_INT 1
90696: ST_TO_ADDR
// if p3 = 4 then
90697: LD_VAR 0 3
90701: PUSH
90702: LD_INT 4
90704: EQUAL
90705: IFFALSE 90715
// sSpec := true ;
90707: LD_ADDR_EXP 99
90711: PUSH
90712: LD_INT 1
90714: ST_TO_ADDR
// if p3 = 5 then
90715: LD_VAR 0 3
90719: PUSH
90720: LD_INT 5
90722: EQUAL
90723: IFFALSE 90733
// sLevel := true ;
90725: LD_ADDR_EXP 103
90729: PUSH
90730: LD_INT 1
90732: ST_TO_ADDR
// if p3 = 6 then
90733: LD_VAR 0 3
90737: PUSH
90738: LD_INT 6
90740: EQUAL
90741: IFFALSE 90751
// sArmoury := true ;
90743: LD_ADDR_EXP 104
90747: PUSH
90748: LD_INT 1
90750: ST_TO_ADDR
// if p3 = 7 then
90751: LD_VAR 0 3
90755: PUSH
90756: LD_INT 7
90758: EQUAL
90759: IFFALSE 90769
// sRadar := true ;
90761: LD_ADDR_EXP 105
90765: PUSH
90766: LD_INT 1
90768: ST_TO_ADDR
// if p3 = 8 then
90769: LD_VAR 0 3
90773: PUSH
90774: LD_INT 8
90776: EQUAL
90777: IFFALSE 90787
// sBunker := true ;
90779: LD_ADDR_EXP 106
90783: PUSH
90784: LD_INT 1
90786: ST_TO_ADDR
// if p3 = 9 then
90787: LD_VAR 0 3
90791: PUSH
90792: LD_INT 9
90794: EQUAL
90795: IFFALSE 90805
// sHack := true ;
90797: LD_ADDR_EXP 107
90801: PUSH
90802: LD_INT 1
90804: ST_TO_ADDR
// if p3 = 10 then
90805: LD_VAR 0 3
90809: PUSH
90810: LD_INT 10
90812: EQUAL
90813: IFFALSE 90823
// sFire := true ;
90815: LD_ADDR_EXP 108
90819: PUSH
90820: LD_INT 1
90822: ST_TO_ADDR
// if p3 = 11 then
90823: LD_VAR 0 3
90827: PUSH
90828: LD_INT 11
90830: EQUAL
90831: IFFALSE 90841
// sRefresh := true ;
90833: LD_ADDR_EXP 109
90837: PUSH
90838: LD_INT 1
90840: ST_TO_ADDR
// if p3 = 12 then
90841: LD_VAR 0 3
90845: PUSH
90846: LD_INT 12
90848: EQUAL
90849: IFFALSE 90859
// sExp := true ;
90851: LD_ADDR_EXP 110
90855: PUSH
90856: LD_INT 1
90858: ST_TO_ADDR
// if p3 = 13 then
90859: LD_VAR 0 3
90863: PUSH
90864: LD_INT 13
90866: EQUAL
90867: IFFALSE 90877
// sDepot := true ;
90869: LD_ADDR_EXP 111
90873: PUSH
90874: LD_INT 1
90876: ST_TO_ADDR
// if p3 = 14 then
90877: LD_VAR 0 3
90881: PUSH
90882: LD_INT 14
90884: EQUAL
90885: IFFALSE 90895
// sFlag := true ;
90887: LD_ADDR_EXP 112
90891: PUSH
90892: LD_INT 1
90894: ST_TO_ADDR
// if p3 = 15 then
90895: LD_VAR 0 3
90899: PUSH
90900: LD_INT 15
90902: EQUAL
90903: IFFALSE 90913
// sKamikadze := true ;
90905: LD_ADDR_EXP 120
90909: PUSH
90910: LD_INT 1
90912: ST_TO_ADDR
// if p3 = 16 then
90913: LD_VAR 0 3
90917: PUSH
90918: LD_INT 16
90920: EQUAL
90921: IFFALSE 90931
// sTroll := true ;
90923: LD_ADDR_EXP 121
90927: PUSH
90928: LD_INT 1
90930: ST_TO_ADDR
// if p3 = 17 then
90931: LD_VAR 0 3
90935: PUSH
90936: LD_INT 17
90938: EQUAL
90939: IFFALSE 90949
// sSlow := true ;
90941: LD_ADDR_EXP 122
90945: PUSH
90946: LD_INT 1
90948: ST_TO_ADDR
// if p3 = 18 then
90949: LD_VAR 0 3
90953: PUSH
90954: LD_INT 18
90956: EQUAL
90957: IFFALSE 90967
// sLack := true ;
90959: LD_ADDR_EXP 123
90963: PUSH
90964: LD_INT 1
90966: ST_TO_ADDR
// if p3 = 19 then
90967: LD_VAR 0 3
90971: PUSH
90972: LD_INT 19
90974: EQUAL
90975: IFFALSE 90985
// sTank := true ;
90977: LD_ADDR_EXP 125
90981: PUSH
90982: LD_INT 1
90984: ST_TO_ADDR
// if p3 = 20 then
90985: LD_VAR 0 3
90989: PUSH
90990: LD_INT 20
90992: EQUAL
90993: IFFALSE 91003
// sRemote := true ;
90995: LD_ADDR_EXP 126
90999: PUSH
91000: LD_INT 1
91002: ST_TO_ADDR
// if p3 = 21 then
91003: LD_VAR 0 3
91007: PUSH
91008: LD_INT 21
91010: EQUAL
91011: IFFALSE 91021
// sPowell := true ;
91013: LD_ADDR_EXP 127
91017: PUSH
91018: LD_INT 1
91020: ST_TO_ADDR
// if p3 = 22 then
91021: LD_VAR 0 3
91025: PUSH
91026: LD_INT 22
91028: EQUAL
91029: IFFALSE 91039
// sTeleport := true ;
91031: LD_ADDR_EXP 130
91035: PUSH
91036: LD_INT 1
91038: ST_TO_ADDR
// if p3 = 23 then
91039: LD_VAR 0 3
91043: PUSH
91044: LD_INT 23
91046: EQUAL
91047: IFFALSE 91057
// sOilTower := true ;
91049: LD_ADDR_EXP 132
91053: PUSH
91054: LD_INT 1
91056: ST_TO_ADDR
// if p3 = 24 then
91057: LD_VAR 0 3
91061: PUSH
91062: LD_INT 24
91064: EQUAL
91065: IFFALSE 91075
// sShovel := true ;
91067: LD_ADDR_EXP 133
91071: PUSH
91072: LD_INT 1
91074: ST_TO_ADDR
// if p3 = 25 then
91075: LD_VAR 0 3
91079: PUSH
91080: LD_INT 25
91082: EQUAL
91083: IFFALSE 91093
// sSheik := true ;
91085: LD_ADDR_EXP 134
91089: PUSH
91090: LD_INT 1
91092: ST_TO_ADDR
// if p3 = 26 then
91093: LD_VAR 0 3
91097: PUSH
91098: LD_INT 26
91100: EQUAL
91101: IFFALSE 91111
// sEarthquake := true ;
91103: LD_ADDR_EXP 136
91107: PUSH
91108: LD_INT 1
91110: ST_TO_ADDR
// if p3 = 27 then
91111: LD_VAR 0 3
91115: PUSH
91116: LD_INT 27
91118: EQUAL
91119: IFFALSE 91129
// sAI := true ;
91121: LD_ADDR_EXP 137
91125: PUSH
91126: LD_INT 1
91128: ST_TO_ADDR
// if p3 = 28 then
91129: LD_VAR 0 3
91133: PUSH
91134: LD_INT 28
91136: EQUAL
91137: IFFALSE 91147
// sCargo := true ;
91139: LD_ADDR_EXP 140
91143: PUSH
91144: LD_INT 1
91146: ST_TO_ADDR
// if p3 = 29 then
91147: LD_VAR 0 3
91151: PUSH
91152: LD_INT 29
91154: EQUAL
91155: IFFALSE 91165
// sDLaser := true ;
91157: LD_ADDR_EXP 141
91161: PUSH
91162: LD_INT 1
91164: ST_TO_ADDR
// if p3 = 30 then
91165: LD_VAR 0 3
91169: PUSH
91170: LD_INT 30
91172: EQUAL
91173: IFFALSE 91183
// sExchange := true ;
91175: LD_ADDR_EXP 142
91179: PUSH
91180: LD_INT 1
91182: ST_TO_ADDR
// if p3 = 31 then
91183: LD_VAR 0 3
91187: PUSH
91188: LD_INT 31
91190: EQUAL
91191: IFFALSE 91201
// sFac := true ;
91193: LD_ADDR_EXP 143
91197: PUSH
91198: LD_INT 1
91200: ST_TO_ADDR
// if p3 = 32 then
91201: LD_VAR 0 3
91205: PUSH
91206: LD_INT 32
91208: EQUAL
91209: IFFALSE 91219
// sPower := true ;
91211: LD_ADDR_EXP 144
91215: PUSH
91216: LD_INT 1
91218: ST_TO_ADDR
// if p3 = 33 then
91219: LD_VAR 0 3
91223: PUSH
91224: LD_INT 33
91226: EQUAL
91227: IFFALSE 91237
// sRandom := true ;
91229: LD_ADDR_EXP 145
91233: PUSH
91234: LD_INT 1
91236: ST_TO_ADDR
// if p3 = 34 then
91237: LD_VAR 0 3
91241: PUSH
91242: LD_INT 34
91244: EQUAL
91245: IFFALSE 91255
// sShield := true ;
91247: LD_ADDR_EXP 146
91251: PUSH
91252: LD_INT 1
91254: ST_TO_ADDR
// if p3 = 35 then
91255: LD_VAR 0 3
91259: PUSH
91260: LD_INT 35
91262: EQUAL
91263: IFFALSE 91273
// sTime := true ;
91265: LD_ADDR_EXP 147
91269: PUSH
91270: LD_INT 1
91272: ST_TO_ADDR
// if p3 = 36 then
91273: LD_VAR 0 3
91277: PUSH
91278: LD_INT 36
91280: EQUAL
91281: IFFALSE 91291
// sTools := true ;
91283: LD_ADDR_EXP 148
91287: PUSH
91288: LD_INT 1
91290: ST_TO_ADDR
// if p3 = 101 then
91291: LD_VAR 0 3
91295: PUSH
91296: LD_INT 101
91298: EQUAL
91299: IFFALSE 91309
// sSold := true ;
91301: LD_ADDR_EXP 113
91305: PUSH
91306: LD_INT 1
91308: ST_TO_ADDR
// if p3 = 102 then
91309: LD_VAR 0 3
91313: PUSH
91314: LD_INT 102
91316: EQUAL
91317: IFFALSE 91327
// sDiff := true ;
91319: LD_ADDR_EXP 114
91323: PUSH
91324: LD_INT 1
91326: ST_TO_ADDR
// if p3 = 103 then
91327: LD_VAR 0 3
91331: PUSH
91332: LD_INT 103
91334: EQUAL
91335: IFFALSE 91345
// sFog := true ;
91337: LD_ADDR_EXP 117
91341: PUSH
91342: LD_INT 1
91344: ST_TO_ADDR
// if p3 = 104 then
91345: LD_VAR 0 3
91349: PUSH
91350: LD_INT 104
91352: EQUAL
91353: IFFALSE 91363
// sReset := true ;
91355: LD_ADDR_EXP 118
91359: PUSH
91360: LD_INT 1
91362: ST_TO_ADDR
// if p3 = 105 then
91363: LD_VAR 0 3
91367: PUSH
91368: LD_INT 105
91370: EQUAL
91371: IFFALSE 91381
// sSun := true ;
91373: LD_ADDR_EXP 119
91377: PUSH
91378: LD_INT 1
91380: ST_TO_ADDR
// if p3 = 106 then
91381: LD_VAR 0 3
91385: PUSH
91386: LD_INT 106
91388: EQUAL
91389: IFFALSE 91399
// sTiger := true ;
91391: LD_ADDR_EXP 115
91395: PUSH
91396: LD_INT 1
91398: ST_TO_ADDR
// if p3 = 107 then
91399: LD_VAR 0 3
91403: PUSH
91404: LD_INT 107
91406: EQUAL
91407: IFFALSE 91417
// sBomb := true ;
91409: LD_ADDR_EXP 116
91413: PUSH
91414: LD_INT 1
91416: ST_TO_ADDR
// if p3 = 108 then
91417: LD_VAR 0 3
91421: PUSH
91422: LD_INT 108
91424: EQUAL
91425: IFFALSE 91435
// sWound := true ;
91427: LD_ADDR_EXP 124
91431: PUSH
91432: LD_INT 1
91434: ST_TO_ADDR
// if p3 = 109 then
91435: LD_VAR 0 3
91439: PUSH
91440: LD_INT 109
91442: EQUAL
91443: IFFALSE 91453
// sBetray := true ;
91445: LD_ADDR_EXP 128
91449: PUSH
91450: LD_INT 1
91452: ST_TO_ADDR
// if p3 = 110 then
91453: LD_VAR 0 3
91457: PUSH
91458: LD_INT 110
91460: EQUAL
91461: IFFALSE 91471
// sContamin := true ;
91463: LD_ADDR_EXP 129
91467: PUSH
91468: LD_INT 1
91470: ST_TO_ADDR
// if p3 = 111 then
91471: LD_VAR 0 3
91475: PUSH
91476: LD_INT 111
91478: EQUAL
91479: IFFALSE 91489
// sOil := true ;
91481: LD_ADDR_EXP 131
91485: PUSH
91486: LD_INT 1
91488: ST_TO_ADDR
// if p3 = 112 then
91489: LD_VAR 0 3
91493: PUSH
91494: LD_INT 112
91496: EQUAL
91497: IFFALSE 91507
// sStu := true ;
91499: LD_ADDR_EXP 135
91503: PUSH
91504: LD_INT 1
91506: ST_TO_ADDR
// if p3 = 113 then
91507: LD_VAR 0 3
91511: PUSH
91512: LD_INT 113
91514: EQUAL
91515: IFFALSE 91525
// sBazooka := true ;
91517: LD_ADDR_EXP 138
91521: PUSH
91522: LD_INT 1
91524: ST_TO_ADDR
// if p3 = 114 then
91525: LD_VAR 0 3
91529: PUSH
91530: LD_INT 114
91532: EQUAL
91533: IFFALSE 91543
// sMortar := true ;
91535: LD_ADDR_EXP 139
91539: PUSH
91540: LD_INT 1
91542: ST_TO_ADDR
// if p3 = 115 then
91543: LD_VAR 0 3
91547: PUSH
91548: LD_INT 115
91550: EQUAL
91551: IFFALSE 91561
// sRanger := true ;
91553: LD_ADDR_EXP 149
91557: PUSH
91558: LD_INT 1
91560: ST_TO_ADDR
// if p3 = 116 then
91561: LD_VAR 0 3
91565: PUSH
91566: LD_INT 116
91568: EQUAL
91569: IFFALSE 91579
// sComputer := true ;
91571: LD_ADDR_EXP 150
91575: PUSH
91576: LD_INT 1
91578: ST_TO_ADDR
// if p3 = 117 then
91579: LD_VAR 0 3
91583: PUSH
91584: LD_INT 117
91586: EQUAL
91587: IFFALSE 91597
// s30 := true ;
91589: LD_ADDR_EXP 151
91593: PUSH
91594: LD_INT 1
91596: ST_TO_ADDR
// if p3 = 118 then
91597: LD_VAR 0 3
91601: PUSH
91602: LD_INT 118
91604: EQUAL
91605: IFFALSE 91615
// s60 := true ;
91607: LD_ADDR_EXP 152
91611: PUSH
91612: LD_INT 1
91614: ST_TO_ADDR
// end ; if p2 = hack_mode then
91615: LD_VAR 0 2
91619: PUSH
91620: LD_INT 101
91622: EQUAL
91623: IFFALSE 91751
// begin case p3 of 1 :
91625: LD_VAR 0 3
91629: PUSH
91630: LD_INT 1
91632: DOUBLE
91633: EQUAL
91634: IFTRUE 91638
91636: GO 91645
91638: POP
// hHackUnlimitedResources ; 2 :
91639: CALL 103890 0 0
91643: GO 91751
91645: LD_INT 2
91647: DOUBLE
91648: EQUAL
91649: IFTRUE 91653
91651: GO 91660
91653: POP
// hHackSetLevel10 ; 3 :
91654: CALL 104023 0 0
91658: GO 91751
91660: LD_INT 3
91662: DOUBLE
91663: EQUAL
91664: IFTRUE 91668
91666: GO 91675
91668: POP
// hHackSetLevel10YourUnits ; 4 :
91669: CALL 104108 0 0
91673: GO 91751
91675: LD_INT 4
91677: DOUBLE
91678: EQUAL
91679: IFTRUE 91683
91681: GO 91690
91683: POP
// hHackInvincible ; 5 :
91684: CALL 104556 0 0
91688: GO 91751
91690: LD_INT 5
91692: DOUBLE
91693: EQUAL
91694: IFTRUE 91698
91696: GO 91705
91698: POP
// hHackInvisible ; 6 :
91699: CALL 104667 0 0
91703: GO 91751
91705: LD_INT 6
91707: DOUBLE
91708: EQUAL
91709: IFTRUE 91713
91711: GO 91720
91713: POP
// hHackChangeYourSide ; 7 :
91714: CALL 104724 0 0
91718: GO 91751
91720: LD_INT 7
91722: DOUBLE
91723: EQUAL
91724: IFTRUE 91728
91726: GO 91735
91728: POP
// hHackChangeUnitSide ; 8 :
91729: CALL 104766 0 0
91733: GO 91751
91735: LD_INT 8
91737: DOUBLE
91738: EQUAL
91739: IFTRUE 91743
91741: GO 91750
91743: POP
// hHackFog ; end ;
91744: CALL 104867 0 0
91748: GO 91751
91750: POP
// end ; if p2 = game_save_mode then
91751: LD_VAR 0 2
91755: PUSH
91756: LD_INT 102
91758: EQUAL
91759: IFFALSE 91814
// begin if p3 = 1 then
91761: LD_VAR 0 3
91765: PUSH
91766: LD_INT 1
91768: EQUAL
91769: IFFALSE 91781
// globalGameSaveCounter := p4 ;
91771: LD_ADDR_EXP 95
91775: PUSH
91776: LD_VAR 0 4
91780: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91781: LD_VAR 0 3
91785: PUSH
91786: LD_INT 2
91788: EQUAL
91789: PUSH
91790: LD_EXP 95
91794: AND
91795: IFFALSE 91814
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91797: LD_STRING setGameSaveCounter(
91799: PUSH
91800: LD_EXP 95
91804: STR
91805: PUSH
91806: LD_STRING )
91808: STR
91809: PPUSH
91810: CALL_OW 559
// end ; end ;
91814: LD_VAR 0 7
91818: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91819: LD_INT 0
91821: PPUSH
// streamModeActive := false ;
91822: LD_ADDR_EXP 96
91826: PUSH
91827: LD_INT 0
91829: ST_TO_ADDR
// normalCounter := 36 ;
91830: LD_ADDR_EXP 97
91834: PUSH
91835: LD_INT 36
91837: ST_TO_ADDR
// hardcoreCounter := 18 ;
91838: LD_ADDR_EXP 98
91842: PUSH
91843: LD_INT 18
91845: ST_TO_ADDR
// sRocket := false ;
91846: LD_ADDR_EXP 101
91850: PUSH
91851: LD_INT 0
91853: ST_TO_ADDR
// sSpeed := false ;
91854: LD_ADDR_EXP 100
91858: PUSH
91859: LD_INT 0
91861: ST_TO_ADDR
// sEngine := false ;
91862: LD_ADDR_EXP 102
91866: PUSH
91867: LD_INT 0
91869: ST_TO_ADDR
// sSpec := false ;
91870: LD_ADDR_EXP 99
91874: PUSH
91875: LD_INT 0
91877: ST_TO_ADDR
// sLevel := false ;
91878: LD_ADDR_EXP 103
91882: PUSH
91883: LD_INT 0
91885: ST_TO_ADDR
// sArmoury := false ;
91886: LD_ADDR_EXP 104
91890: PUSH
91891: LD_INT 0
91893: ST_TO_ADDR
// sRadar := false ;
91894: LD_ADDR_EXP 105
91898: PUSH
91899: LD_INT 0
91901: ST_TO_ADDR
// sBunker := false ;
91902: LD_ADDR_EXP 106
91906: PUSH
91907: LD_INT 0
91909: ST_TO_ADDR
// sHack := false ;
91910: LD_ADDR_EXP 107
91914: PUSH
91915: LD_INT 0
91917: ST_TO_ADDR
// sFire := false ;
91918: LD_ADDR_EXP 108
91922: PUSH
91923: LD_INT 0
91925: ST_TO_ADDR
// sRefresh := false ;
91926: LD_ADDR_EXP 109
91930: PUSH
91931: LD_INT 0
91933: ST_TO_ADDR
// sExp := false ;
91934: LD_ADDR_EXP 110
91938: PUSH
91939: LD_INT 0
91941: ST_TO_ADDR
// sDepot := false ;
91942: LD_ADDR_EXP 111
91946: PUSH
91947: LD_INT 0
91949: ST_TO_ADDR
// sFlag := false ;
91950: LD_ADDR_EXP 112
91954: PUSH
91955: LD_INT 0
91957: ST_TO_ADDR
// sKamikadze := false ;
91958: LD_ADDR_EXP 120
91962: PUSH
91963: LD_INT 0
91965: ST_TO_ADDR
// sTroll := false ;
91966: LD_ADDR_EXP 121
91970: PUSH
91971: LD_INT 0
91973: ST_TO_ADDR
// sSlow := false ;
91974: LD_ADDR_EXP 122
91978: PUSH
91979: LD_INT 0
91981: ST_TO_ADDR
// sLack := false ;
91982: LD_ADDR_EXP 123
91986: PUSH
91987: LD_INT 0
91989: ST_TO_ADDR
// sTank := false ;
91990: LD_ADDR_EXP 125
91994: PUSH
91995: LD_INT 0
91997: ST_TO_ADDR
// sRemote := false ;
91998: LD_ADDR_EXP 126
92002: PUSH
92003: LD_INT 0
92005: ST_TO_ADDR
// sPowell := false ;
92006: LD_ADDR_EXP 127
92010: PUSH
92011: LD_INT 0
92013: ST_TO_ADDR
// sTeleport := false ;
92014: LD_ADDR_EXP 130
92018: PUSH
92019: LD_INT 0
92021: ST_TO_ADDR
// sOilTower := false ;
92022: LD_ADDR_EXP 132
92026: PUSH
92027: LD_INT 0
92029: ST_TO_ADDR
// sShovel := false ;
92030: LD_ADDR_EXP 133
92034: PUSH
92035: LD_INT 0
92037: ST_TO_ADDR
// sSheik := false ;
92038: LD_ADDR_EXP 134
92042: PUSH
92043: LD_INT 0
92045: ST_TO_ADDR
// sEarthquake := false ;
92046: LD_ADDR_EXP 136
92050: PUSH
92051: LD_INT 0
92053: ST_TO_ADDR
// sAI := false ;
92054: LD_ADDR_EXP 137
92058: PUSH
92059: LD_INT 0
92061: ST_TO_ADDR
// sCargo := false ;
92062: LD_ADDR_EXP 140
92066: PUSH
92067: LD_INT 0
92069: ST_TO_ADDR
// sDLaser := false ;
92070: LD_ADDR_EXP 141
92074: PUSH
92075: LD_INT 0
92077: ST_TO_ADDR
// sExchange := false ;
92078: LD_ADDR_EXP 142
92082: PUSH
92083: LD_INT 0
92085: ST_TO_ADDR
// sFac := false ;
92086: LD_ADDR_EXP 143
92090: PUSH
92091: LD_INT 0
92093: ST_TO_ADDR
// sPower := false ;
92094: LD_ADDR_EXP 144
92098: PUSH
92099: LD_INT 0
92101: ST_TO_ADDR
// sRandom := false ;
92102: LD_ADDR_EXP 145
92106: PUSH
92107: LD_INT 0
92109: ST_TO_ADDR
// sShield := false ;
92110: LD_ADDR_EXP 146
92114: PUSH
92115: LD_INT 0
92117: ST_TO_ADDR
// sTime := false ;
92118: LD_ADDR_EXP 147
92122: PUSH
92123: LD_INT 0
92125: ST_TO_ADDR
// sTools := false ;
92126: LD_ADDR_EXP 148
92130: PUSH
92131: LD_INT 0
92133: ST_TO_ADDR
// sSold := false ;
92134: LD_ADDR_EXP 113
92138: PUSH
92139: LD_INT 0
92141: ST_TO_ADDR
// sDiff := false ;
92142: LD_ADDR_EXP 114
92146: PUSH
92147: LD_INT 0
92149: ST_TO_ADDR
// sFog := false ;
92150: LD_ADDR_EXP 117
92154: PUSH
92155: LD_INT 0
92157: ST_TO_ADDR
// sReset := false ;
92158: LD_ADDR_EXP 118
92162: PUSH
92163: LD_INT 0
92165: ST_TO_ADDR
// sSun := false ;
92166: LD_ADDR_EXP 119
92170: PUSH
92171: LD_INT 0
92173: ST_TO_ADDR
// sTiger := false ;
92174: LD_ADDR_EXP 115
92178: PUSH
92179: LD_INT 0
92181: ST_TO_ADDR
// sBomb := false ;
92182: LD_ADDR_EXP 116
92186: PUSH
92187: LD_INT 0
92189: ST_TO_ADDR
// sWound := false ;
92190: LD_ADDR_EXP 124
92194: PUSH
92195: LD_INT 0
92197: ST_TO_ADDR
// sBetray := false ;
92198: LD_ADDR_EXP 128
92202: PUSH
92203: LD_INT 0
92205: ST_TO_ADDR
// sContamin := false ;
92206: LD_ADDR_EXP 129
92210: PUSH
92211: LD_INT 0
92213: ST_TO_ADDR
// sOil := false ;
92214: LD_ADDR_EXP 131
92218: PUSH
92219: LD_INT 0
92221: ST_TO_ADDR
// sStu := false ;
92222: LD_ADDR_EXP 135
92226: PUSH
92227: LD_INT 0
92229: ST_TO_ADDR
// sBazooka := false ;
92230: LD_ADDR_EXP 138
92234: PUSH
92235: LD_INT 0
92237: ST_TO_ADDR
// sMortar := false ;
92238: LD_ADDR_EXP 139
92242: PUSH
92243: LD_INT 0
92245: ST_TO_ADDR
// sRanger := false ;
92246: LD_ADDR_EXP 149
92250: PUSH
92251: LD_INT 0
92253: ST_TO_ADDR
// sComputer := false ;
92254: LD_ADDR_EXP 150
92258: PUSH
92259: LD_INT 0
92261: ST_TO_ADDR
// s30 := false ;
92262: LD_ADDR_EXP 151
92266: PUSH
92267: LD_INT 0
92269: ST_TO_ADDR
// s60 := false ;
92270: LD_ADDR_EXP 152
92274: PUSH
92275: LD_INT 0
92277: ST_TO_ADDR
// end ;
92278: LD_VAR 0 1
92282: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92283: LD_INT 0
92285: PPUSH
92286: PPUSH
92287: PPUSH
92288: PPUSH
92289: PPUSH
92290: PPUSH
92291: PPUSH
// result := [ ] ;
92292: LD_ADDR_VAR 0 2
92296: PUSH
92297: EMPTY
92298: ST_TO_ADDR
// if campaign_id = 1 then
92299: LD_OWVAR 69
92303: PUSH
92304: LD_INT 1
92306: EQUAL
92307: IFFALSE 95473
// begin case mission_number of 1 :
92309: LD_OWVAR 70
92313: PUSH
92314: LD_INT 1
92316: DOUBLE
92317: EQUAL
92318: IFTRUE 92322
92320: GO 92398
92322: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92323: LD_ADDR_VAR 0 2
92327: PUSH
92328: LD_INT 2
92330: PUSH
92331: LD_INT 4
92333: PUSH
92334: LD_INT 11
92336: PUSH
92337: LD_INT 12
92339: PUSH
92340: LD_INT 15
92342: PUSH
92343: LD_INT 16
92345: PUSH
92346: LD_INT 22
92348: PUSH
92349: LD_INT 23
92351: PUSH
92352: LD_INT 26
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 101
92368: PUSH
92369: LD_INT 102
92371: PUSH
92372: LD_INT 106
92374: PUSH
92375: LD_INT 116
92377: PUSH
92378: LD_INT 117
92380: PUSH
92381: LD_INT 118
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: ST_TO_ADDR
92396: GO 95471
92398: LD_INT 2
92400: DOUBLE
92401: EQUAL
92402: IFTRUE 92406
92404: GO 92490
92406: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92407: LD_ADDR_VAR 0 2
92411: PUSH
92412: LD_INT 2
92414: PUSH
92415: LD_INT 4
92417: PUSH
92418: LD_INT 11
92420: PUSH
92421: LD_INT 12
92423: PUSH
92424: LD_INT 15
92426: PUSH
92427: LD_INT 16
92429: PUSH
92430: LD_INT 22
92432: PUSH
92433: LD_INT 23
92435: PUSH
92436: LD_INT 26
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 101
92452: PUSH
92453: LD_INT 102
92455: PUSH
92456: LD_INT 105
92458: PUSH
92459: LD_INT 106
92461: PUSH
92462: LD_INT 108
92464: PUSH
92465: LD_INT 116
92467: PUSH
92468: LD_INT 117
92470: PUSH
92471: LD_INT 118
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: ST_TO_ADDR
92488: GO 95471
92490: LD_INT 3
92492: DOUBLE
92493: EQUAL
92494: IFTRUE 92498
92496: GO 92586
92498: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92499: LD_ADDR_VAR 0 2
92503: PUSH
92504: LD_INT 2
92506: PUSH
92507: LD_INT 4
92509: PUSH
92510: LD_INT 5
92512: PUSH
92513: LD_INT 11
92515: PUSH
92516: LD_INT 12
92518: PUSH
92519: LD_INT 15
92521: PUSH
92522: LD_INT 16
92524: PUSH
92525: LD_INT 22
92527: PUSH
92528: LD_INT 26
92530: PUSH
92531: LD_INT 36
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 101
92548: PUSH
92549: LD_INT 102
92551: PUSH
92552: LD_INT 105
92554: PUSH
92555: LD_INT 106
92557: PUSH
92558: LD_INT 108
92560: PUSH
92561: LD_INT 116
92563: PUSH
92564: LD_INT 117
92566: PUSH
92567: LD_INT 118
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: ST_TO_ADDR
92584: GO 95471
92586: LD_INT 4
92588: DOUBLE
92589: EQUAL
92590: IFTRUE 92594
92592: GO 92690
92594: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92595: LD_ADDR_VAR 0 2
92599: PUSH
92600: LD_INT 2
92602: PUSH
92603: LD_INT 4
92605: PUSH
92606: LD_INT 5
92608: PUSH
92609: LD_INT 8
92611: PUSH
92612: LD_INT 11
92614: PUSH
92615: LD_INT 12
92617: PUSH
92618: LD_INT 15
92620: PUSH
92621: LD_INT 16
92623: PUSH
92624: LD_INT 22
92626: PUSH
92627: LD_INT 23
92629: PUSH
92630: LD_INT 26
92632: PUSH
92633: LD_INT 36
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 101
92652: PUSH
92653: LD_INT 102
92655: PUSH
92656: LD_INT 105
92658: PUSH
92659: LD_INT 106
92661: PUSH
92662: LD_INT 108
92664: PUSH
92665: LD_INT 116
92667: PUSH
92668: LD_INT 117
92670: PUSH
92671: LD_INT 118
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: ST_TO_ADDR
92688: GO 95471
92690: LD_INT 5
92692: DOUBLE
92693: EQUAL
92694: IFTRUE 92698
92696: GO 92810
92698: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92699: LD_ADDR_VAR 0 2
92703: PUSH
92704: LD_INT 2
92706: PUSH
92707: LD_INT 4
92709: PUSH
92710: LD_INT 5
92712: PUSH
92713: LD_INT 6
92715: PUSH
92716: LD_INT 8
92718: PUSH
92719: LD_INT 11
92721: PUSH
92722: LD_INT 12
92724: PUSH
92725: LD_INT 15
92727: PUSH
92728: LD_INT 16
92730: PUSH
92731: LD_INT 22
92733: PUSH
92734: LD_INT 23
92736: PUSH
92737: LD_INT 25
92739: PUSH
92740: LD_INT 26
92742: PUSH
92743: LD_INT 36
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 101
92764: PUSH
92765: LD_INT 102
92767: PUSH
92768: LD_INT 105
92770: PUSH
92771: LD_INT 106
92773: PUSH
92774: LD_INT 108
92776: PUSH
92777: LD_INT 109
92779: PUSH
92780: LD_INT 112
92782: PUSH
92783: LD_INT 116
92785: PUSH
92786: LD_INT 117
92788: PUSH
92789: LD_INT 118
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: ST_TO_ADDR
92808: GO 95471
92810: LD_INT 6
92812: DOUBLE
92813: EQUAL
92814: IFTRUE 92818
92816: GO 92950
92818: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92819: LD_ADDR_VAR 0 2
92823: PUSH
92824: LD_INT 2
92826: PUSH
92827: LD_INT 4
92829: PUSH
92830: LD_INT 5
92832: PUSH
92833: LD_INT 6
92835: PUSH
92836: LD_INT 8
92838: PUSH
92839: LD_INT 11
92841: PUSH
92842: LD_INT 12
92844: PUSH
92845: LD_INT 15
92847: PUSH
92848: LD_INT 16
92850: PUSH
92851: LD_INT 20
92853: PUSH
92854: LD_INT 21
92856: PUSH
92857: LD_INT 22
92859: PUSH
92860: LD_INT 23
92862: PUSH
92863: LD_INT 25
92865: PUSH
92866: LD_INT 26
92868: PUSH
92869: LD_INT 30
92871: PUSH
92872: LD_INT 31
92874: PUSH
92875: LD_INT 32
92877: PUSH
92878: LD_INT 36
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: PUSH
92902: LD_INT 101
92904: PUSH
92905: LD_INT 102
92907: PUSH
92908: LD_INT 105
92910: PUSH
92911: LD_INT 106
92913: PUSH
92914: LD_INT 108
92916: PUSH
92917: LD_INT 109
92919: PUSH
92920: LD_INT 112
92922: PUSH
92923: LD_INT 116
92925: PUSH
92926: LD_INT 117
92928: PUSH
92929: LD_INT 118
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: ST_TO_ADDR
92948: GO 95471
92950: LD_INT 7
92952: DOUBLE
92953: EQUAL
92954: IFTRUE 92958
92956: GO 93070
92958: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92959: LD_ADDR_VAR 0 2
92963: PUSH
92964: LD_INT 2
92966: PUSH
92967: LD_INT 4
92969: PUSH
92970: LD_INT 5
92972: PUSH
92973: LD_INT 7
92975: PUSH
92976: LD_INT 11
92978: PUSH
92979: LD_INT 12
92981: PUSH
92982: LD_INT 15
92984: PUSH
92985: LD_INT 16
92987: PUSH
92988: LD_INT 20
92990: PUSH
92991: LD_INT 21
92993: PUSH
92994: LD_INT 22
92996: PUSH
92997: LD_INT 23
92999: PUSH
93000: LD_INT 25
93002: PUSH
93003: LD_INT 26
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 101
93024: PUSH
93025: LD_INT 102
93027: PUSH
93028: LD_INT 103
93030: PUSH
93031: LD_INT 105
93033: PUSH
93034: LD_INT 106
93036: PUSH
93037: LD_INT 108
93039: PUSH
93040: LD_INT 112
93042: PUSH
93043: LD_INT 116
93045: PUSH
93046: LD_INT 117
93048: PUSH
93049: LD_INT 118
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: ST_TO_ADDR
93068: GO 95471
93070: LD_INT 8
93072: DOUBLE
93073: EQUAL
93074: IFTRUE 93078
93076: GO 93218
93078: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93079: LD_ADDR_VAR 0 2
93083: PUSH
93084: LD_INT 2
93086: PUSH
93087: LD_INT 4
93089: PUSH
93090: LD_INT 5
93092: PUSH
93093: LD_INT 6
93095: PUSH
93096: LD_INT 7
93098: PUSH
93099: LD_INT 8
93101: PUSH
93102: LD_INT 11
93104: PUSH
93105: LD_INT 12
93107: PUSH
93108: LD_INT 15
93110: PUSH
93111: LD_INT 16
93113: PUSH
93114: LD_INT 20
93116: PUSH
93117: LD_INT 21
93119: PUSH
93120: LD_INT 22
93122: PUSH
93123: LD_INT 23
93125: PUSH
93126: LD_INT 25
93128: PUSH
93129: LD_INT 26
93131: PUSH
93132: LD_INT 30
93134: PUSH
93135: LD_INT 31
93137: PUSH
93138: LD_INT 32
93140: PUSH
93141: LD_INT 36
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 101
93168: PUSH
93169: LD_INT 102
93171: PUSH
93172: LD_INT 103
93174: PUSH
93175: LD_INT 105
93177: PUSH
93178: LD_INT 106
93180: PUSH
93181: LD_INT 108
93183: PUSH
93184: LD_INT 109
93186: PUSH
93187: LD_INT 112
93189: PUSH
93190: LD_INT 116
93192: PUSH
93193: LD_INT 117
93195: PUSH
93196: LD_INT 118
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: ST_TO_ADDR
93216: GO 95471
93218: LD_INT 9
93220: DOUBLE
93221: EQUAL
93222: IFTRUE 93226
93224: GO 93374
93226: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93227: LD_ADDR_VAR 0 2
93231: PUSH
93232: LD_INT 2
93234: PUSH
93235: LD_INT 4
93237: PUSH
93238: LD_INT 5
93240: PUSH
93241: LD_INT 6
93243: PUSH
93244: LD_INT 7
93246: PUSH
93247: LD_INT 8
93249: PUSH
93250: LD_INT 11
93252: PUSH
93253: LD_INT 12
93255: PUSH
93256: LD_INT 15
93258: PUSH
93259: LD_INT 16
93261: PUSH
93262: LD_INT 20
93264: PUSH
93265: LD_INT 21
93267: PUSH
93268: LD_INT 22
93270: PUSH
93271: LD_INT 23
93273: PUSH
93274: LD_INT 25
93276: PUSH
93277: LD_INT 26
93279: PUSH
93280: LD_INT 28
93282: PUSH
93283: LD_INT 30
93285: PUSH
93286: LD_INT 31
93288: PUSH
93289: LD_INT 32
93291: PUSH
93292: LD_INT 36
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 101
93320: PUSH
93321: LD_INT 102
93323: PUSH
93324: LD_INT 103
93326: PUSH
93327: LD_INT 105
93329: PUSH
93330: LD_INT 106
93332: PUSH
93333: LD_INT 108
93335: PUSH
93336: LD_INT 109
93338: PUSH
93339: LD_INT 112
93341: PUSH
93342: LD_INT 114
93344: PUSH
93345: LD_INT 116
93347: PUSH
93348: LD_INT 117
93350: PUSH
93351: LD_INT 118
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: ST_TO_ADDR
93372: GO 95471
93374: LD_INT 10
93376: DOUBLE
93377: EQUAL
93378: IFTRUE 93382
93380: GO 93578
93382: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93383: LD_ADDR_VAR 0 2
93387: PUSH
93388: LD_INT 2
93390: PUSH
93391: LD_INT 4
93393: PUSH
93394: LD_INT 5
93396: PUSH
93397: LD_INT 6
93399: PUSH
93400: LD_INT 7
93402: PUSH
93403: LD_INT 8
93405: PUSH
93406: LD_INT 9
93408: PUSH
93409: LD_INT 10
93411: PUSH
93412: LD_INT 11
93414: PUSH
93415: LD_INT 12
93417: PUSH
93418: LD_INT 13
93420: PUSH
93421: LD_INT 14
93423: PUSH
93424: LD_INT 15
93426: PUSH
93427: LD_INT 16
93429: PUSH
93430: LD_INT 17
93432: PUSH
93433: LD_INT 18
93435: PUSH
93436: LD_INT 19
93438: PUSH
93439: LD_INT 20
93441: PUSH
93442: LD_INT 21
93444: PUSH
93445: LD_INT 22
93447: PUSH
93448: LD_INT 23
93450: PUSH
93451: LD_INT 24
93453: PUSH
93454: LD_INT 25
93456: PUSH
93457: LD_INT 26
93459: PUSH
93460: LD_INT 28
93462: PUSH
93463: LD_INT 30
93465: PUSH
93466: LD_INT 31
93468: PUSH
93469: LD_INT 32
93471: PUSH
93472: LD_INT 36
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: PUSH
93506: LD_INT 101
93508: PUSH
93509: LD_INT 102
93511: PUSH
93512: LD_INT 103
93514: PUSH
93515: LD_INT 104
93517: PUSH
93518: LD_INT 105
93520: PUSH
93521: LD_INT 106
93523: PUSH
93524: LD_INT 107
93526: PUSH
93527: LD_INT 108
93529: PUSH
93530: LD_INT 109
93532: PUSH
93533: LD_INT 110
93535: PUSH
93536: LD_INT 111
93538: PUSH
93539: LD_INT 112
93541: PUSH
93542: LD_INT 114
93544: PUSH
93545: LD_INT 116
93547: PUSH
93548: LD_INT 117
93550: PUSH
93551: LD_INT 118
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: ST_TO_ADDR
93576: GO 95471
93578: LD_INT 11
93580: DOUBLE
93581: EQUAL
93582: IFTRUE 93586
93584: GO 93790
93586: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93587: LD_ADDR_VAR 0 2
93591: PUSH
93592: LD_INT 2
93594: PUSH
93595: LD_INT 3
93597: PUSH
93598: LD_INT 4
93600: PUSH
93601: LD_INT 5
93603: PUSH
93604: LD_INT 6
93606: PUSH
93607: LD_INT 7
93609: PUSH
93610: LD_INT 8
93612: PUSH
93613: LD_INT 9
93615: PUSH
93616: LD_INT 10
93618: PUSH
93619: LD_INT 11
93621: PUSH
93622: LD_INT 12
93624: PUSH
93625: LD_INT 13
93627: PUSH
93628: LD_INT 14
93630: PUSH
93631: LD_INT 15
93633: PUSH
93634: LD_INT 16
93636: PUSH
93637: LD_INT 17
93639: PUSH
93640: LD_INT 18
93642: PUSH
93643: LD_INT 19
93645: PUSH
93646: LD_INT 20
93648: PUSH
93649: LD_INT 21
93651: PUSH
93652: LD_INT 22
93654: PUSH
93655: LD_INT 23
93657: PUSH
93658: LD_INT 24
93660: PUSH
93661: LD_INT 25
93663: PUSH
93664: LD_INT 26
93666: PUSH
93667: LD_INT 28
93669: PUSH
93670: LD_INT 30
93672: PUSH
93673: LD_INT 31
93675: PUSH
93676: LD_INT 32
93678: PUSH
93679: LD_INT 34
93681: PUSH
93682: LD_INT 36
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 101
93720: PUSH
93721: LD_INT 102
93723: PUSH
93724: LD_INT 103
93726: PUSH
93727: LD_INT 104
93729: PUSH
93730: LD_INT 105
93732: PUSH
93733: LD_INT 106
93735: PUSH
93736: LD_INT 107
93738: PUSH
93739: LD_INT 108
93741: PUSH
93742: LD_INT 109
93744: PUSH
93745: LD_INT 110
93747: PUSH
93748: LD_INT 111
93750: PUSH
93751: LD_INT 112
93753: PUSH
93754: LD_INT 114
93756: PUSH
93757: LD_INT 116
93759: PUSH
93760: LD_INT 117
93762: PUSH
93763: LD_INT 118
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: ST_TO_ADDR
93788: GO 95471
93790: LD_INT 12
93792: DOUBLE
93793: EQUAL
93794: IFTRUE 93798
93796: GO 94018
93798: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93799: LD_ADDR_VAR 0 2
93803: PUSH
93804: LD_INT 1
93806: PUSH
93807: LD_INT 2
93809: PUSH
93810: LD_INT 3
93812: PUSH
93813: LD_INT 4
93815: PUSH
93816: LD_INT 5
93818: PUSH
93819: LD_INT 6
93821: PUSH
93822: LD_INT 7
93824: PUSH
93825: LD_INT 8
93827: PUSH
93828: LD_INT 9
93830: PUSH
93831: LD_INT 10
93833: PUSH
93834: LD_INT 11
93836: PUSH
93837: LD_INT 12
93839: PUSH
93840: LD_INT 13
93842: PUSH
93843: LD_INT 14
93845: PUSH
93846: LD_INT 15
93848: PUSH
93849: LD_INT 16
93851: PUSH
93852: LD_INT 17
93854: PUSH
93855: LD_INT 18
93857: PUSH
93858: LD_INT 19
93860: PUSH
93861: LD_INT 20
93863: PUSH
93864: LD_INT 21
93866: PUSH
93867: LD_INT 22
93869: PUSH
93870: LD_INT 23
93872: PUSH
93873: LD_INT 24
93875: PUSH
93876: LD_INT 25
93878: PUSH
93879: LD_INT 26
93881: PUSH
93882: LD_INT 27
93884: PUSH
93885: LD_INT 28
93887: PUSH
93888: LD_INT 30
93890: PUSH
93891: LD_INT 31
93893: PUSH
93894: LD_INT 32
93896: PUSH
93897: LD_INT 33
93899: PUSH
93900: LD_INT 34
93902: PUSH
93903: LD_INT 36
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 101
93944: PUSH
93945: LD_INT 102
93947: PUSH
93948: LD_INT 103
93950: PUSH
93951: LD_INT 104
93953: PUSH
93954: LD_INT 105
93956: PUSH
93957: LD_INT 106
93959: PUSH
93960: LD_INT 107
93962: PUSH
93963: LD_INT 108
93965: PUSH
93966: LD_INT 109
93968: PUSH
93969: LD_INT 110
93971: PUSH
93972: LD_INT 111
93974: PUSH
93975: LD_INT 112
93977: PUSH
93978: LD_INT 113
93980: PUSH
93981: LD_INT 114
93983: PUSH
93984: LD_INT 116
93986: PUSH
93987: LD_INT 117
93989: PUSH
93990: LD_INT 118
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: ST_TO_ADDR
94016: GO 95471
94018: LD_INT 13
94020: DOUBLE
94021: EQUAL
94022: IFTRUE 94026
94024: GO 94234
94026: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94027: LD_ADDR_VAR 0 2
94031: PUSH
94032: LD_INT 1
94034: PUSH
94035: LD_INT 2
94037: PUSH
94038: LD_INT 3
94040: PUSH
94041: LD_INT 4
94043: PUSH
94044: LD_INT 5
94046: PUSH
94047: LD_INT 8
94049: PUSH
94050: LD_INT 9
94052: PUSH
94053: LD_INT 10
94055: PUSH
94056: LD_INT 11
94058: PUSH
94059: LD_INT 12
94061: PUSH
94062: LD_INT 14
94064: PUSH
94065: LD_INT 15
94067: PUSH
94068: LD_INT 16
94070: PUSH
94071: LD_INT 17
94073: PUSH
94074: LD_INT 18
94076: PUSH
94077: LD_INT 19
94079: PUSH
94080: LD_INT 20
94082: PUSH
94083: LD_INT 21
94085: PUSH
94086: LD_INT 22
94088: PUSH
94089: LD_INT 23
94091: PUSH
94092: LD_INT 24
94094: PUSH
94095: LD_INT 25
94097: PUSH
94098: LD_INT 26
94100: PUSH
94101: LD_INT 27
94103: PUSH
94104: LD_INT 28
94106: PUSH
94107: LD_INT 30
94109: PUSH
94110: LD_INT 31
94112: PUSH
94113: LD_INT 32
94115: PUSH
94116: LD_INT 33
94118: PUSH
94119: LD_INT 34
94121: PUSH
94122: LD_INT 36
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 101
94160: PUSH
94161: LD_INT 102
94163: PUSH
94164: LD_INT 103
94166: PUSH
94167: LD_INT 104
94169: PUSH
94170: LD_INT 105
94172: PUSH
94173: LD_INT 106
94175: PUSH
94176: LD_INT 107
94178: PUSH
94179: LD_INT 108
94181: PUSH
94182: LD_INT 109
94184: PUSH
94185: LD_INT 110
94187: PUSH
94188: LD_INT 111
94190: PUSH
94191: LD_INT 112
94193: PUSH
94194: LD_INT 113
94196: PUSH
94197: LD_INT 114
94199: PUSH
94200: LD_INT 116
94202: PUSH
94203: LD_INT 117
94205: PUSH
94206: LD_INT 118
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: ST_TO_ADDR
94232: GO 95471
94234: LD_INT 14
94236: DOUBLE
94237: EQUAL
94238: IFTRUE 94242
94240: GO 94466
94242: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94243: LD_ADDR_VAR 0 2
94247: PUSH
94248: LD_INT 1
94250: PUSH
94251: LD_INT 2
94253: PUSH
94254: LD_INT 3
94256: PUSH
94257: LD_INT 4
94259: PUSH
94260: LD_INT 5
94262: PUSH
94263: LD_INT 6
94265: PUSH
94266: LD_INT 7
94268: PUSH
94269: LD_INT 8
94271: PUSH
94272: LD_INT 9
94274: PUSH
94275: LD_INT 10
94277: PUSH
94278: LD_INT 11
94280: PUSH
94281: LD_INT 12
94283: PUSH
94284: LD_INT 13
94286: PUSH
94287: LD_INT 14
94289: PUSH
94290: LD_INT 15
94292: PUSH
94293: LD_INT 16
94295: PUSH
94296: LD_INT 17
94298: PUSH
94299: LD_INT 18
94301: PUSH
94302: LD_INT 19
94304: PUSH
94305: LD_INT 20
94307: PUSH
94308: LD_INT 21
94310: PUSH
94311: LD_INT 22
94313: PUSH
94314: LD_INT 23
94316: PUSH
94317: LD_INT 24
94319: PUSH
94320: LD_INT 25
94322: PUSH
94323: LD_INT 26
94325: PUSH
94326: LD_INT 27
94328: PUSH
94329: LD_INT 28
94331: PUSH
94332: LD_INT 29
94334: PUSH
94335: LD_INT 30
94337: PUSH
94338: LD_INT 31
94340: PUSH
94341: LD_INT 32
94343: PUSH
94344: LD_INT 33
94346: PUSH
94347: LD_INT 34
94349: PUSH
94350: LD_INT 36
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 101
94392: PUSH
94393: LD_INT 102
94395: PUSH
94396: LD_INT 103
94398: PUSH
94399: LD_INT 104
94401: PUSH
94402: LD_INT 105
94404: PUSH
94405: LD_INT 106
94407: PUSH
94408: LD_INT 107
94410: PUSH
94411: LD_INT 108
94413: PUSH
94414: LD_INT 109
94416: PUSH
94417: LD_INT 110
94419: PUSH
94420: LD_INT 111
94422: PUSH
94423: LD_INT 112
94425: PUSH
94426: LD_INT 113
94428: PUSH
94429: LD_INT 114
94431: PUSH
94432: LD_INT 116
94434: PUSH
94435: LD_INT 117
94437: PUSH
94438: LD_INT 118
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: ST_TO_ADDR
94464: GO 95471
94466: LD_INT 15
94468: DOUBLE
94469: EQUAL
94470: IFTRUE 94474
94472: GO 94698
94474: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94475: LD_ADDR_VAR 0 2
94479: PUSH
94480: LD_INT 1
94482: PUSH
94483: LD_INT 2
94485: PUSH
94486: LD_INT 3
94488: PUSH
94489: LD_INT 4
94491: PUSH
94492: LD_INT 5
94494: PUSH
94495: LD_INT 6
94497: PUSH
94498: LD_INT 7
94500: PUSH
94501: LD_INT 8
94503: PUSH
94504: LD_INT 9
94506: PUSH
94507: LD_INT 10
94509: PUSH
94510: LD_INT 11
94512: PUSH
94513: LD_INT 12
94515: PUSH
94516: LD_INT 13
94518: PUSH
94519: LD_INT 14
94521: PUSH
94522: LD_INT 15
94524: PUSH
94525: LD_INT 16
94527: PUSH
94528: LD_INT 17
94530: PUSH
94531: LD_INT 18
94533: PUSH
94534: LD_INT 19
94536: PUSH
94537: LD_INT 20
94539: PUSH
94540: LD_INT 21
94542: PUSH
94543: LD_INT 22
94545: PUSH
94546: LD_INT 23
94548: PUSH
94549: LD_INT 24
94551: PUSH
94552: LD_INT 25
94554: PUSH
94555: LD_INT 26
94557: PUSH
94558: LD_INT 27
94560: PUSH
94561: LD_INT 28
94563: PUSH
94564: LD_INT 29
94566: PUSH
94567: LD_INT 30
94569: PUSH
94570: LD_INT 31
94572: PUSH
94573: LD_INT 32
94575: PUSH
94576: LD_INT 33
94578: PUSH
94579: LD_INT 34
94581: PUSH
94582: LD_INT 36
94584: PUSH
94585: EMPTY
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 101
94624: PUSH
94625: LD_INT 102
94627: PUSH
94628: LD_INT 103
94630: PUSH
94631: LD_INT 104
94633: PUSH
94634: LD_INT 105
94636: PUSH
94637: LD_INT 106
94639: PUSH
94640: LD_INT 107
94642: PUSH
94643: LD_INT 108
94645: PUSH
94646: LD_INT 109
94648: PUSH
94649: LD_INT 110
94651: PUSH
94652: LD_INT 111
94654: PUSH
94655: LD_INT 112
94657: PUSH
94658: LD_INT 113
94660: PUSH
94661: LD_INT 114
94663: PUSH
94664: LD_INT 116
94666: PUSH
94667: LD_INT 117
94669: PUSH
94670: LD_INT 118
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: ST_TO_ADDR
94696: GO 95471
94698: LD_INT 16
94700: DOUBLE
94701: EQUAL
94702: IFTRUE 94706
94704: GO 94842
94706: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94707: LD_ADDR_VAR 0 2
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: LD_INT 4
94717: PUSH
94718: LD_INT 5
94720: PUSH
94721: LD_INT 7
94723: PUSH
94724: LD_INT 11
94726: PUSH
94727: LD_INT 12
94729: PUSH
94730: LD_INT 15
94732: PUSH
94733: LD_INT 16
94735: PUSH
94736: LD_INT 20
94738: PUSH
94739: LD_INT 21
94741: PUSH
94742: LD_INT 22
94744: PUSH
94745: LD_INT 23
94747: PUSH
94748: LD_INT 25
94750: PUSH
94751: LD_INT 26
94753: PUSH
94754: LD_INT 30
94756: PUSH
94757: LD_INT 31
94759: PUSH
94760: LD_INT 32
94762: PUSH
94763: LD_INT 33
94765: PUSH
94766: LD_INT 34
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 101
94792: PUSH
94793: LD_INT 102
94795: PUSH
94796: LD_INT 103
94798: PUSH
94799: LD_INT 106
94801: PUSH
94802: LD_INT 108
94804: PUSH
94805: LD_INT 112
94807: PUSH
94808: LD_INT 113
94810: PUSH
94811: LD_INT 114
94813: PUSH
94814: LD_INT 116
94816: PUSH
94817: LD_INT 117
94819: PUSH
94820: LD_INT 118
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: ST_TO_ADDR
94840: GO 95471
94842: LD_INT 17
94844: DOUBLE
94845: EQUAL
94846: IFTRUE 94850
94848: GO 95074
94850: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94851: LD_ADDR_VAR 0 2
94855: PUSH
94856: LD_INT 1
94858: PUSH
94859: LD_INT 2
94861: PUSH
94862: LD_INT 3
94864: PUSH
94865: LD_INT 4
94867: PUSH
94868: LD_INT 5
94870: PUSH
94871: LD_INT 6
94873: PUSH
94874: LD_INT 7
94876: PUSH
94877: LD_INT 8
94879: PUSH
94880: LD_INT 9
94882: PUSH
94883: LD_INT 10
94885: PUSH
94886: LD_INT 11
94888: PUSH
94889: LD_INT 12
94891: PUSH
94892: LD_INT 13
94894: PUSH
94895: LD_INT 14
94897: PUSH
94898: LD_INT 15
94900: PUSH
94901: LD_INT 16
94903: PUSH
94904: LD_INT 17
94906: PUSH
94907: LD_INT 18
94909: PUSH
94910: LD_INT 19
94912: PUSH
94913: LD_INT 20
94915: PUSH
94916: LD_INT 21
94918: PUSH
94919: LD_INT 22
94921: PUSH
94922: LD_INT 23
94924: PUSH
94925: LD_INT 24
94927: PUSH
94928: LD_INT 25
94930: PUSH
94931: LD_INT 26
94933: PUSH
94934: LD_INT 27
94936: PUSH
94937: LD_INT 28
94939: PUSH
94940: LD_INT 29
94942: PUSH
94943: LD_INT 30
94945: PUSH
94946: LD_INT 31
94948: PUSH
94949: LD_INT 32
94951: PUSH
94952: LD_INT 33
94954: PUSH
94955: LD_INT 34
94957: PUSH
94958: LD_INT 36
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 101
95000: PUSH
95001: LD_INT 102
95003: PUSH
95004: LD_INT 103
95006: PUSH
95007: LD_INT 104
95009: PUSH
95010: LD_INT 105
95012: PUSH
95013: LD_INT 106
95015: PUSH
95016: LD_INT 107
95018: PUSH
95019: LD_INT 108
95021: PUSH
95022: LD_INT 109
95024: PUSH
95025: LD_INT 110
95027: PUSH
95028: LD_INT 111
95030: PUSH
95031: LD_INT 112
95033: PUSH
95034: LD_INT 113
95036: PUSH
95037: LD_INT 114
95039: PUSH
95040: LD_INT 116
95042: PUSH
95043: LD_INT 117
95045: PUSH
95046: LD_INT 118
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: ST_TO_ADDR
95072: GO 95471
95074: LD_INT 18
95076: DOUBLE
95077: EQUAL
95078: IFTRUE 95082
95080: GO 95230
95082: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95083: LD_ADDR_VAR 0 2
95087: PUSH
95088: LD_INT 2
95090: PUSH
95091: LD_INT 4
95093: PUSH
95094: LD_INT 5
95096: PUSH
95097: LD_INT 7
95099: PUSH
95100: LD_INT 11
95102: PUSH
95103: LD_INT 12
95105: PUSH
95106: LD_INT 15
95108: PUSH
95109: LD_INT 16
95111: PUSH
95112: LD_INT 20
95114: PUSH
95115: LD_INT 21
95117: PUSH
95118: LD_INT 22
95120: PUSH
95121: LD_INT 23
95123: PUSH
95124: LD_INT 25
95126: PUSH
95127: LD_INT 26
95129: PUSH
95130: LD_INT 30
95132: PUSH
95133: LD_INT 31
95135: PUSH
95136: LD_INT 32
95138: PUSH
95139: LD_INT 33
95141: PUSH
95142: LD_INT 34
95144: PUSH
95145: LD_INT 35
95147: PUSH
95148: LD_INT 36
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: PUSH
95174: LD_INT 101
95176: PUSH
95177: LD_INT 102
95179: PUSH
95180: LD_INT 103
95182: PUSH
95183: LD_INT 106
95185: PUSH
95186: LD_INT 108
95188: PUSH
95189: LD_INT 112
95191: PUSH
95192: LD_INT 113
95194: PUSH
95195: LD_INT 114
95197: PUSH
95198: LD_INT 115
95200: PUSH
95201: LD_INT 116
95203: PUSH
95204: LD_INT 117
95206: PUSH
95207: LD_INT 118
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: ST_TO_ADDR
95228: GO 95471
95230: LD_INT 19
95232: DOUBLE
95233: EQUAL
95234: IFTRUE 95238
95236: GO 95470
95238: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95239: LD_ADDR_VAR 0 2
95243: PUSH
95244: LD_INT 1
95246: PUSH
95247: LD_INT 2
95249: PUSH
95250: LD_INT 3
95252: PUSH
95253: LD_INT 4
95255: PUSH
95256: LD_INT 5
95258: PUSH
95259: LD_INT 6
95261: PUSH
95262: LD_INT 7
95264: PUSH
95265: LD_INT 8
95267: PUSH
95268: LD_INT 9
95270: PUSH
95271: LD_INT 10
95273: PUSH
95274: LD_INT 11
95276: PUSH
95277: LD_INT 12
95279: PUSH
95280: LD_INT 13
95282: PUSH
95283: LD_INT 14
95285: PUSH
95286: LD_INT 15
95288: PUSH
95289: LD_INT 16
95291: PUSH
95292: LD_INT 17
95294: PUSH
95295: LD_INT 18
95297: PUSH
95298: LD_INT 19
95300: PUSH
95301: LD_INT 20
95303: PUSH
95304: LD_INT 21
95306: PUSH
95307: LD_INT 22
95309: PUSH
95310: LD_INT 23
95312: PUSH
95313: LD_INT 24
95315: PUSH
95316: LD_INT 25
95318: PUSH
95319: LD_INT 26
95321: PUSH
95322: LD_INT 27
95324: PUSH
95325: LD_INT 28
95327: PUSH
95328: LD_INT 29
95330: PUSH
95331: LD_INT 30
95333: PUSH
95334: LD_INT 31
95336: PUSH
95337: LD_INT 32
95339: PUSH
95340: LD_INT 33
95342: PUSH
95343: LD_INT 34
95345: PUSH
95346: LD_INT 35
95348: PUSH
95349: LD_INT 36
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: PUSH
95390: LD_INT 101
95392: PUSH
95393: LD_INT 102
95395: PUSH
95396: LD_INT 103
95398: PUSH
95399: LD_INT 104
95401: PUSH
95402: LD_INT 105
95404: PUSH
95405: LD_INT 106
95407: PUSH
95408: LD_INT 107
95410: PUSH
95411: LD_INT 108
95413: PUSH
95414: LD_INT 109
95416: PUSH
95417: LD_INT 110
95419: PUSH
95420: LD_INT 111
95422: PUSH
95423: LD_INT 112
95425: PUSH
95426: LD_INT 113
95428: PUSH
95429: LD_INT 114
95431: PUSH
95432: LD_INT 115
95434: PUSH
95435: LD_INT 116
95437: PUSH
95438: LD_INT 117
95440: PUSH
95441: LD_INT 118
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: ST_TO_ADDR
95468: GO 95471
95470: POP
// end else
95471: GO 95702
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95473: LD_ADDR_VAR 0 2
95477: PUSH
95478: LD_INT 1
95480: PUSH
95481: LD_INT 2
95483: PUSH
95484: LD_INT 3
95486: PUSH
95487: LD_INT 4
95489: PUSH
95490: LD_INT 5
95492: PUSH
95493: LD_INT 6
95495: PUSH
95496: LD_INT 7
95498: PUSH
95499: LD_INT 8
95501: PUSH
95502: LD_INT 9
95504: PUSH
95505: LD_INT 10
95507: PUSH
95508: LD_INT 11
95510: PUSH
95511: LD_INT 12
95513: PUSH
95514: LD_INT 13
95516: PUSH
95517: LD_INT 14
95519: PUSH
95520: LD_INT 15
95522: PUSH
95523: LD_INT 16
95525: PUSH
95526: LD_INT 17
95528: PUSH
95529: LD_INT 18
95531: PUSH
95532: LD_INT 19
95534: PUSH
95535: LD_INT 20
95537: PUSH
95538: LD_INT 21
95540: PUSH
95541: LD_INT 22
95543: PUSH
95544: LD_INT 23
95546: PUSH
95547: LD_INT 24
95549: PUSH
95550: LD_INT 25
95552: PUSH
95553: LD_INT 26
95555: PUSH
95556: LD_INT 27
95558: PUSH
95559: LD_INT 28
95561: PUSH
95562: LD_INT 29
95564: PUSH
95565: LD_INT 30
95567: PUSH
95568: LD_INT 31
95570: PUSH
95571: LD_INT 32
95573: PUSH
95574: LD_INT 33
95576: PUSH
95577: LD_INT 34
95579: PUSH
95580: LD_INT 35
95582: PUSH
95583: LD_INT 36
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 101
95626: PUSH
95627: LD_INT 102
95629: PUSH
95630: LD_INT 103
95632: PUSH
95633: LD_INT 104
95635: PUSH
95636: LD_INT 105
95638: PUSH
95639: LD_INT 106
95641: PUSH
95642: LD_INT 107
95644: PUSH
95645: LD_INT 108
95647: PUSH
95648: LD_INT 109
95650: PUSH
95651: LD_INT 110
95653: PUSH
95654: LD_INT 111
95656: PUSH
95657: LD_INT 112
95659: PUSH
95660: LD_INT 113
95662: PUSH
95663: LD_INT 114
95665: PUSH
95666: LD_INT 115
95668: PUSH
95669: LD_INT 116
95671: PUSH
95672: LD_INT 117
95674: PUSH
95675: LD_INT 118
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: ST_TO_ADDR
// if result then
95702: LD_VAR 0 2
95706: IFFALSE 96492
// begin normal :=  ;
95708: LD_ADDR_VAR 0 5
95712: PUSH
95713: LD_STRING 
95715: ST_TO_ADDR
// hardcore :=  ;
95716: LD_ADDR_VAR 0 6
95720: PUSH
95721: LD_STRING 
95723: ST_TO_ADDR
// active :=  ;
95724: LD_ADDR_VAR 0 7
95728: PUSH
95729: LD_STRING 
95731: ST_TO_ADDR
// for i = 1 to normalCounter do
95732: LD_ADDR_VAR 0 8
95736: PUSH
95737: DOUBLE
95738: LD_INT 1
95740: DEC
95741: ST_TO_ADDR
95742: LD_EXP 97
95746: PUSH
95747: FOR_TO
95748: IFFALSE 95849
// begin tmp := 0 ;
95750: LD_ADDR_VAR 0 3
95754: PUSH
95755: LD_STRING 0
95757: ST_TO_ADDR
// if result [ 1 ] then
95758: LD_VAR 0 2
95762: PUSH
95763: LD_INT 1
95765: ARRAY
95766: IFFALSE 95831
// if result [ 1 ] [ 1 ] = i then
95768: LD_VAR 0 2
95772: PUSH
95773: LD_INT 1
95775: ARRAY
95776: PUSH
95777: LD_INT 1
95779: ARRAY
95780: PUSH
95781: LD_VAR 0 8
95785: EQUAL
95786: IFFALSE 95831
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95788: LD_ADDR_VAR 0 2
95792: PUSH
95793: LD_VAR 0 2
95797: PPUSH
95798: LD_INT 1
95800: PPUSH
95801: LD_VAR 0 2
95805: PUSH
95806: LD_INT 1
95808: ARRAY
95809: PPUSH
95810: LD_INT 1
95812: PPUSH
95813: CALL_OW 3
95817: PPUSH
95818: CALL_OW 1
95822: ST_TO_ADDR
// tmp := 1 ;
95823: LD_ADDR_VAR 0 3
95827: PUSH
95828: LD_STRING 1
95830: ST_TO_ADDR
// end ; normal := normal & tmp ;
95831: LD_ADDR_VAR 0 5
95835: PUSH
95836: LD_VAR 0 5
95840: PUSH
95841: LD_VAR 0 3
95845: STR
95846: ST_TO_ADDR
// end ;
95847: GO 95747
95849: POP
95850: POP
// for i = 1 to hardcoreCounter do
95851: LD_ADDR_VAR 0 8
95855: PUSH
95856: DOUBLE
95857: LD_INT 1
95859: DEC
95860: ST_TO_ADDR
95861: LD_EXP 98
95865: PUSH
95866: FOR_TO
95867: IFFALSE 95972
// begin tmp := 0 ;
95869: LD_ADDR_VAR 0 3
95873: PUSH
95874: LD_STRING 0
95876: ST_TO_ADDR
// if result [ 2 ] then
95877: LD_VAR 0 2
95881: PUSH
95882: LD_INT 2
95884: ARRAY
95885: IFFALSE 95954
// if result [ 2 ] [ 1 ] = 100 + i then
95887: LD_VAR 0 2
95891: PUSH
95892: LD_INT 2
95894: ARRAY
95895: PUSH
95896: LD_INT 1
95898: ARRAY
95899: PUSH
95900: LD_INT 100
95902: PUSH
95903: LD_VAR 0 8
95907: PLUS
95908: EQUAL
95909: IFFALSE 95954
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95911: LD_ADDR_VAR 0 2
95915: PUSH
95916: LD_VAR 0 2
95920: PPUSH
95921: LD_INT 2
95923: PPUSH
95924: LD_VAR 0 2
95928: PUSH
95929: LD_INT 2
95931: ARRAY
95932: PPUSH
95933: LD_INT 1
95935: PPUSH
95936: CALL_OW 3
95940: PPUSH
95941: CALL_OW 1
95945: ST_TO_ADDR
// tmp := 1 ;
95946: LD_ADDR_VAR 0 3
95950: PUSH
95951: LD_STRING 1
95953: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95954: LD_ADDR_VAR 0 6
95958: PUSH
95959: LD_VAR 0 6
95963: PUSH
95964: LD_VAR 0 3
95968: STR
95969: ST_TO_ADDR
// end ;
95970: GO 95866
95972: POP
95973: POP
// if isGameLoad then
95974: LD_VAR 0 1
95978: IFFALSE 96453
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95980: LD_ADDR_VAR 0 4
95984: PUSH
95985: LD_EXP 101
95989: PUSH
95990: LD_EXP 100
95994: PUSH
95995: LD_EXP 102
95999: PUSH
96000: LD_EXP 99
96004: PUSH
96005: LD_EXP 103
96009: PUSH
96010: LD_EXP 104
96014: PUSH
96015: LD_EXP 105
96019: PUSH
96020: LD_EXP 106
96024: PUSH
96025: LD_EXP 107
96029: PUSH
96030: LD_EXP 108
96034: PUSH
96035: LD_EXP 109
96039: PUSH
96040: LD_EXP 110
96044: PUSH
96045: LD_EXP 111
96049: PUSH
96050: LD_EXP 112
96054: PUSH
96055: LD_EXP 120
96059: PUSH
96060: LD_EXP 121
96064: PUSH
96065: LD_EXP 122
96069: PUSH
96070: LD_EXP 123
96074: PUSH
96075: LD_EXP 125
96079: PUSH
96080: LD_EXP 126
96084: PUSH
96085: LD_EXP 127
96089: PUSH
96090: LD_EXP 130
96094: PUSH
96095: LD_EXP 132
96099: PUSH
96100: LD_EXP 133
96104: PUSH
96105: LD_EXP 134
96109: PUSH
96110: LD_EXP 136
96114: PUSH
96115: LD_EXP 137
96119: PUSH
96120: LD_EXP 140
96124: PUSH
96125: LD_EXP 141
96129: PUSH
96130: LD_EXP 142
96134: PUSH
96135: LD_EXP 143
96139: PUSH
96140: LD_EXP 144
96144: PUSH
96145: LD_EXP 145
96149: PUSH
96150: LD_EXP 146
96154: PUSH
96155: LD_EXP 147
96159: PUSH
96160: LD_EXP 148
96164: PUSH
96165: LD_EXP 113
96169: PUSH
96170: LD_EXP 114
96174: PUSH
96175: LD_EXP 117
96179: PUSH
96180: LD_EXP 118
96184: PUSH
96185: LD_EXP 119
96189: PUSH
96190: LD_EXP 115
96194: PUSH
96195: LD_EXP 116
96199: PUSH
96200: LD_EXP 124
96204: PUSH
96205: LD_EXP 128
96209: PUSH
96210: LD_EXP 129
96214: PUSH
96215: LD_EXP 131
96219: PUSH
96220: LD_EXP 135
96224: PUSH
96225: LD_EXP 138
96229: PUSH
96230: LD_EXP 139
96234: PUSH
96235: LD_EXP 149
96239: PUSH
96240: LD_EXP 150
96244: PUSH
96245: LD_EXP 151
96249: PUSH
96250: LD_EXP 152
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: ST_TO_ADDR
// tmp :=  ;
96311: LD_ADDR_VAR 0 3
96315: PUSH
96316: LD_STRING 
96318: ST_TO_ADDR
// for i = 1 to normalCounter do
96319: LD_ADDR_VAR 0 8
96323: PUSH
96324: DOUBLE
96325: LD_INT 1
96327: DEC
96328: ST_TO_ADDR
96329: LD_EXP 97
96333: PUSH
96334: FOR_TO
96335: IFFALSE 96371
// begin if flags [ i ] then
96337: LD_VAR 0 4
96341: PUSH
96342: LD_VAR 0 8
96346: ARRAY
96347: IFFALSE 96369
// tmp := tmp & i & ; ;
96349: LD_ADDR_VAR 0 3
96353: PUSH
96354: LD_VAR 0 3
96358: PUSH
96359: LD_VAR 0 8
96363: STR
96364: PUSH
96365: LD_STRING ;
96367: STR
96368: ST_TO_ADDR
// end ;
96369: GO 96334
96371: POP
96372: POP
// for i = 1 to hardcoreCounter do
96373: LD_ADDR_VAR 0 8
96377: PUSH
96378: DOUBLE
96379: LD_INT 1
96381: DEC
96382: ST_TO_ADDR
96383: LD_EXP 98
96387: PUSH
96388: FOR_TO
96389: IFFALSE 96435
// begin if flags [ normalCounter + i ] then
96391: LD_VAR 0 4
96395: PUSH
96396: LD_EXP 97
96400: PUSH
96401: LD_VAR 0 8
96405: PLUS
96406: ARRAY
96407: IFFALSE 96433
// tmp := tmp & ( 100 + i ) & ; ;
96409: LD_ADDR_VAR 0 3
96413: PUSH
96414: LD_VAR 0 3
96418: PUSH
96419: LD_INT 100
96421: PUSH
96422: LD_VAR 0 8
96426: PLUS
96427: STR
96428: PUSH
96429: LD_STRING ;
96431: STR
96432: ST_TO_ADDR
// end ;
96433: GO 96388
96435: POP
96436: POP
// if tmp then
96437: LD_VAR 0 3
96441: IFFALSE 96453
// active := tmp ;
96443: LD_ADDR_VAR 0 7
96447: PUSH
96448: LD_VAR 0 3
96452: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96453: LD_STRING getStreamItemsFromMission("
96455: PUSH
96456: LD_VAR 0 5
96460: STR
96461: PUSH
96462: LD_STRING ","
96464: STR
96465: PUSH
96466: LD_VAR 0 6
96470: STR
96471: PUSH
96472: LD_STRING ","
96474: STR
96475: PUSH
96476: LD_VAR 0 7
96480: STR
96481: PUSH
96482: LD_STRING ")
96484: STR
96485: PPUSH
96486: CALL_OW 559
// end else
96490: GO 96499
// ToLua ( getStreamItemsFromMission("","","") ) ;
96492: LD_STRING getStreamItemsFromMission("","","")
96494: PPUSH
96495: CALL_OW 559
// end ;
96499: LD_VAR 0 2
96503: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96504: LD_EXP 96
96508: PUSH
96509: LD_EXP 101
96513: AND
96514: IFFALSE 96638
96516: GO 96518
96518: DISABLE
96519: LD_INT 0
96521: PPUSH
96522: PPUSH
// begin enable ;
96523: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96524: LD_ADDR_VAR 0 2
96528: PUSH
96529: LD_INT 22
96531: PUSH
96532: LD_OWVAR 2
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 2
96543: PUSH
96544: LD_INT 34
96546: PUSH
96547: LD_INT 7
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 34
96556: PUSH
96557: LD_INT 45
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 34
96566: PUSH
96567: LD_INT 28
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 34
96576: PUSH
96577: LD_INT 47
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PPUSH
96595: CALL_OW 69
96599: ST_TO_ADDR
// if not tmp then
96600: LD_VAR 0 2
96604: NOT
96605: IFFALSE 96609
// exit ;
96607: GO 96638
// for i in tmp do
96609: LD_ADDR_VAR 0 1
96613: PUSH
96614: LD_VAR 0 2
96618: PUSH
96619: FOR_IN
96620: IFFALSE 96636
// begin SetLives ( i , 0 ) ;
96622: LD_VAR 0 1
96626: PPUSH
96627: LD_INT 0
96629: PPUSH
96630: CALL_OW 234
// end ;
96634: GO 96619
96636: POP
96637: POP
// end ;
96638: PPOPN 2
96640: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96641: LD_EXP 96
96645: PUSH
96646: LD_EXP 102
96650: AND
96651: IFFALSE 96735
96653: GO 96655
96655: DISABLE
96656: LD_INT 0
96658: PPUSH
96659: PPUSH
// begin enable ;
96660: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96661: LD_ADDR_VAR 0 2
96665: PUSH
96666: LD_INT 22
96668: PUSH
96669: LD_OWVAR 2
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 32
96680: PUSH
96681: LD_INT 3
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PPUSH
96692: CALL_OW 69
96696: ST_TO_ADDR
// if not tmp then
96697: LD_VAR 0 2
96701: NOT
96702: IFFALSE 96706
// exit ;
96704: GO 96735
// for i in tmp do
96706: LD_ADDR_VAR 0 1
96710: PUSH
96711: LD_VAR 0 2
96715: PUSH
96716: FOR_IN
96717: IFFALSE 96733
// begin SetLives ( i , 0 ) ;
96719: LD_VAR 0 1
96723: PPUSH
96724: LD_INT 0
96726: PPUSH
96727: CALL_OW 234
// end ;
96731: GO 96716
96733: POP
96734: POP
// end ;
96735: PPOPN 2
96737: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96738: LD_EXP 96
96742: PUSH
96743: LD_EXP 99
96747: AND
96748: IFFALSE 96841
96750: GO 96752
96752: DISABLE
96753: LD_INT 0
96755: PPUSH
// begin enable ;
96756: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96757: LD_ADDR_VAR 0 1
96761: PUSH
96762: LD_INT 22
96764: PUSH
96765: LD_OWVAR 2
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: LD_INT 25
96779: PUSH
96780: LD_INT 5
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 25
96789: PUSH
96790: LD_INT 9
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 25
96799: PUSH
96800: LD_INT 8
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: EMPTY
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PPUSH
96817: CALL_OW 69
96821: PUSH
96822: FOR_IN
96823: IFFALSE 96839
// begin SetClass ( i , 1 ) ;
96825: LD_VAR 0 1
96829: PPUSH
96830: LD_INT 1
96832: PPUSH
96833: CALL_OW 336
// end ;
96837: GO 96822
96839: POP
96840: POP
// end ;
96841: PPOPN 1
96843: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96844: LD_EXP 96
96848: PUSH
96849: LD_EXP 100
96853: AND
96854: PUSH
96855: LD_OWVAR 65
96859: PUSH
96860: LD_INT 7
96862: LESS
96863: AND
96864: IFFALSE 96878
96866: GO 96868
96868: DISABLE
// begin enable ;
96869: ENABLE
// game_speed := 7 ;
96870: LD_ADDR_OWVAR 65
96874: PUSH
96875: LD_INT 7
96877: ST_TO_ADDR
// end ;
96878: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96879: LD_EXP 96
96883: PUSH
96884: LD_EXP 103
96888: AND
96889: IFFALSE 97091
96891: GO 96893
96893: DISABLE
96894: LD_INT 0
96896: PPUSH
96897: PPUSH
96898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96899: LD_ADDR_VAR 0 3
96903: PUSH
96904: LD_INT 81
96906: PUSH
96907: LD_OWVAR 2
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 21
96918: PUSH
96919: LD_INT 1
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PPUSH
96930: CALL_OW 69
96934: ST_TO_ADDR
// if not tmp then
96935: LD_VAR 0 3
96939: NOT
96940: IFFALSE 96944
// exit ;
96942: GO 97091
// if tmp > 5 then
96944: LD_VAR 0 3
96948: PUSH
96949: LD_INT 5
96951: GREATER
96952: IFFALSE 96964
// k := 5 else
96954: LD_ADDR_VAR 0 2
96958: PUSH
96959: LD_INT 5
96961: ST_TO_ADDR
96962: GO 96974
// k := tmp ;
96964: LD_ADDR_VAR 0 2
96968: PUSH
96969: LD_VAR 0 3
96973: ST_TO_ADDR
// for i := 1 to k do
96974: LD_ADDR_VAR 0 1
96978: PUSH
96979: DOUBLE
96980: LD_INT 1
96982: DEC
96983: ST_TO_ADDR
96984: LD_VAR 0 2
96988: PUSH
96989: FOR_TO
96990: IFFALSE 97089
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96992: LD_VAR 0 3
96996: PUSH
96997: LD_VAR 0 1
97001: ARRAY
97002: PPUSH
97003: LD_VAR 0 1
97007: PUSH
97008: LD_INT 4
97010: MOD
97011: PUSH
97012: LD_INT 1
97014: PLUS
97015: PPUSH
97016: CALL_OW 259
97020: PUSH
97021: LD_INT 10
97023: LESS
97024: IFFALSE 97087
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97026: LD_VAR 0 3
97030: PUSH
97031: LD_VAR 0 1
97035: ARRAY
97036: PPUSH
97037: LD_VAR 0 1
97041: PUSH
97042: LD_INT 4
97044: MOD
97045: PUSH
97046: LD_INT 1
97048: PLUS
97049: PPUSH
97050: LD_VAR 0 3
97054: PUSH
97055: LD_VAR 0 1
97059: ARRAY
97060: PPUSH
97061: LD_VAR 0 1
97065: PUSH
97066: LD_INT 4
97068: MOD
97069: PUSH
97070: LD_INT 1
97072: PLUS
97073: PPUSH
97074: CALL_OW 259
97078: PUSH
97079: LD_INT 1
97081: PLUS
97082: PPUSH
97083: CALL_OW 237
97087: GO 96989
97089: POP
97090: POP
// end ;
97091: PPOPN 3
97093: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97094: LD_EXP 96
97098: PUSH
97099: LD_EXP 104
97103: AND
97104: IFFALSE 97124
97106: GO 97108
97108: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97109: LD_INT 4
97111: PPUSH
97112: LD_OWVAR 2
97116: PPUSH
97117: LD_INT 0
97119: PPUSH
97120: CALL_OW 324
97124: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97125: LD_EXP 96
97129: PUSH
97130: LD_EXP 133
97134: AND
97135: IFFALSE 97155
97137: GO 97139
97139: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97140: LD_INT 19
97142: PPUSH
97143: LD_OWVAR 2
97147: PPUSH
97148: LD_INT 0
97150: PPUSH
97151: CALL_OW 324
97155: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97156: LD_EXP 96
97160: PUSH
97161: LD_EXP 105
97165: AND
97166: IFFALSE 97268
97168: GO 97170
97170: DISABLE
97171: LD_INT 0
97173: PPUSH
97174: PPUSH
// begin enable ;
97175: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97176: LD_ADDR_VAR 0 2
97180: PUSH
97181: LD_INT 22
97183: PUSH
97184: LD_OWVAR 2
97188: PUSH
97189: EMPTY
97190: LIST
97191: LIST
97192: PUSH
97193: LD_INT 2
97195: PUSH
97196: LD_INT 34
97198: PUSH
97199: LD_INT 11
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 34
97208: PUSH
97209: LD_INT 30
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: LIST
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PPUSH
97225: CALL_OW 69
97229: ST_TO_ADDR
// if not tmp then
97230: LD_VAR 0 2
97234: NOT
97235: IFFALSE 97239
// exit ;
97237: GO 97268
// for i in tmp do
97239: LD_ADDR_VAR 0 1
97243: PUSH
97244: LD_VAR 0 2
97248: PUSH
97249: FOR_IN
97250: IFFALSE 97266
// begin SetLives ( i , 0 ) ;
97252: LD_VAR 0 1
97256: PPUSH
97257: LD_INT 0
97259: PPUSH
97260: CALL_OW 234
// end ;
97264: GO 97249
97266: POP
97267: POP
// end ;
97268: PPOPN 2
97270: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97271: LD_EXP 96
97275: PUSH
97276: LD_EXP 106
97280: AND
97281: IFFALSE 97301
97283: GO 97285
97285: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97286: LD_INT 32
97288: PPUSH
97289: LD_OWVAR 2
97293: PPUSH
97294: LD_INT 0
97296: PPUSH
97297: CALL_OW 324
97301: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97302: LD_EXP 96
97306: PUSH
97307: LD_EXP 107
97311: AND
97312: IFFALSE 97493
97314: GO 97316
97316: DISABLE
97317: LD_INT 0
97319: PPUSH
97320: PPUSH
97321: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97322: LD_ADDR_VAR 0 2
97326: PUSH
97327: LD_INT 22
97329: PUSH
97330: LD_OWVAR 2
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: PUSH
97339: LD_INT 33
97341: PUSH
97342: LD_INT 3
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PPUSH
97353: CALL_OW 69
97357: ST_TO_ADDR
// if not tmp then
97358: LD_VAR 0 2
97362: NOT
97363: IFFALSE 97367
// exit ;
97365: GO 97493
// side := 0 ;
97367: LD_ADDR_VAR 0 3
97371: PUSH
97372: LD_INT 0
97374: ST_TO_ADDR
// for i := 1 to 8 do
97375: LD_ADDR_VAR 0 1
97379: PUSH
97380: DOUBLE
97381: LD_INT 1
97383: DEC
97384: ST_TO_ADDR
97385: LD_INT 8
97387: PUSH
97388: FOR_TO
97389: IFFALSE 97437
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97391: LD_OWVAR 2
97395: PUSH
97396: LD_VAR 0 1
97400: NONEQUAL
97401: PUSH
97402: LD_OWVAR 2
97406: PPUSH
97407: LD_VAR 0 1
97411: PPUSH
97412: CALL_OW 81
97416: PUSH
97417: LD_INT 2
97419: EQUAL
97420: AND
97421: IFFALSE 97435
// begin side := i ;
97423: LD_ADDR_VAR 0 3
97427: PUSH
97428: LD_VAR 0 1
97432: ST_TO_ADDR
// break ;
97433: GO 97437
// end ;
97435: GO 97388
97437: POP
97438: POP
// if not side then
97439: LD_VAR 0 3
97443: NOT
97444: IFFALSE 97448
// exit ;
97446: GO 97493
// for i := 1 to tmp do
97448: LD_ADDR_VAR 0 1
97452: PUSH
97453: DOUBLE
97454: LD_INT 1
97456: DEC
97457: ST_TO_ADDR
97458: LD_VAR 0 2
97462: PUSH
97463: FOR_TO
97464: IFFALSE 97491
// if Prob ( 60 ) then
97466: LD_INT 60
97468: PPUSH
97469: CALL_OW 13
97473: IFFALSE 97489
// SetSide ( i , side ) ;
97475: LD_VAR 0 1
97479: PPUSH
97480: LD_VAR 0 3
97484: PPUSH
97485: CALL_OW 235
97489: GO 97463
97491: POP
97492: POP
// end ;
97493: PPOPN 3
97495: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97496: LD_EXP 96
97500: PUSH
97501: LD_EXP 109
97505: AND
97506: IFFALSE 97625
97508: GO 97510
97510: DISABLE
97511: LD_INT 0
97513: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97514: LD_ADDR_VAR 0 1
97518: PUSH
97519: LD_INT 22
97521: PUSH
97522: LD_OWVAR 2
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 21
97533: PUSH
97534: LD_INT 1
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 3
97543: PUSH
97544: LD_INT 23
97546: PUSH
97547: LD_INT 0
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: LIST
97562: PPUSH
97563: CALL_OW 69
97567: PUSH
97568: FOR_IN
97569: IFFALSE 97623
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97571: LD_VAR 0 1
97575: PPUSH
97576: CALL_OW 257
97580: PUSH
97581: LD_INT 1
97583: PUSH
97584: LD_INT 2
97586: PUSH
97587: LD_INT 3
97589: PUSH
97590: LD_INT 4
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: IN
97599: IFFALSE 97621
// SetClass ( un , rand ( 1 , 4 ) ) ;
97601: LD_VAR 0 1
97605: PPUSH
97606: LD_INT 1
97608: PPUSH
97609: LD_INT 4
97611: PPUSH
97612: CALL_OW 12
97616: PPUSH
97617: CALL_OW 336
97621: GO 97568
97623: POP
97624: POP
// end ;
97625: PPOPN 1
97627: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97628: LD_EXP 96
97632: PUSH
97633: LD_EXP 108
97637: AND
97638: IFFALSE 97717
97640: GO 97642
97642: DISABLE
97643: LD_INT 0
97645: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97646: LD_ADDR_VAR 0 1
97650: PUSH
97651: LD_INT 22
97653: PUSH
97654: LD_OWVAR 2
97658: PUSH
97659: EMPTY
97660: LIST
97661: LIST
97662: PUSH
97663: LD_INT 21
97665: PUSH
97666: LD_INT 3
97668: PUSH
97669: EMPTY
97670: LIST
97671: LIST
97672: PUSH
97673: EMPTY
97674: LIST
97675: LIST
97676: PPUSH
97677: CALL_OW 69
97681: ST_TO_ADDR
// if not tmp then
97682: LD_VAR 0 1
97686: NOT
97687: IFFALSE 97691
// exit ;
97689: GO 97717
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97691: LD_VAR 0 1
97695: PUSH
97696: LD_INT 1
97698: PPUSH
97699: LD_VAR 0 1
97703: PPUSH
97704: CALL_OW 12
97708: ARRAY
97709: PPUSH
97710: LD_INT 100
97712: PPUSH
97713: CALL_OW 234
// end ;
97717: PPOPN 1
97719: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97720: LD_EXP 96
97724: PUSH
97725: LD_EXP 110
97729: AND
97730: IFFALSE 97828
97732: GO 97734
97734: DISABLE
97735: LD_INT 0
97737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97738: LD_ADDR_VAR 0 1
97742: PUSH
97743: LD_INT 22
97745: PUSH
97746: LD_OWVAR 2
97750: PUSH
97751: EMPTY
97752: LIST
97753: LIST
97754: PUSH
97755: LD_INT 21
97757: PUSH
97758: LD_INT 1
97760: PUSH
97761: EMPTY
97762: LIST
97763: LIST
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PPUSH
97769: CALL_OW 69
97773: ST_TO_ADDR
// if not tmp then
97774: LD_VAR 0 1
97778: NOT
97779: IFFALSE 97783
// exit ;
97781: GO 97828
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97783: LD_VAR 0 1
97787: PUSH
97788: LD_INT 1
97790: PPUSH
97791: LD_VAR 0 1
97795: PPUSH
97796: CALL_OW 12
97800: ARRAY
97801: PPUSH
97802: LD_INT 1
97804: PPUSH
97805: LD_INT 4
97807: PPUSH
97808: CALL_OW 12
97812: PPUSH
97813: LD_INT 3000
97815: PPUSH
97816: LD_INT 9000
97818: PPUSH
97819: CALL_OW 12
97823: PPUSH
97824: CALL_OW 492
// end ;
97828: PPOPN 1
97830: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97831: LD_EXP 96
97835: PUSH
97836: LD_EXP 111
97840: AND
97841: IFFALSE 97861
97843: GO 97845
97845: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97846: LD_INT 1
97848: PPUSH
97849: LD_OWVAR 2
97853: PPUSH
97854: LD_INT 0
97856: PPUSH
97857: CALL_OW 324
97861: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97862: LD_EXP 96
97866: PUSH
97867: LD_EXP 112
97871: AND
97872: IFFALSE 97955
97874: GO 97876
97876: DISABLE
97877: LD_INT 0
97879: PPUSH
97880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97881: LD_ADDR_VAR 0 2
97885: PUSH
97886: LD_INT 22
97888: PUSH
97889: LD_OWVAR 2
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 21
97900: PUSH
97901: LD_INT 3
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PPUSH
97912: CALL_OW 69
97916: ST_TO_ADDR
// if not tmp then
97917: LD_VAR 0 2
97921: NOT
97922: IFFALSE 97926
// exit ;
97924: GO 97955
// for i in tmp do
97926: LD_ADDR_VAR 0 1
97930: PUSH
97931: LD_VAR 0 2
97935: PUSH
97936: FOR_IN
97937: IFFALSE 97953
// SetBLevel ( i , 10 ) ;
97939: LD_VAR 0 1
97943: PPUSH
97944: LD_INT 10
97946: PPUSH
97947: CALL_OW 241
97951: GO 97936
97953: POP
97954: POP
// end ;
97955: PPOPN 2
97957: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97958: LD_EXP 96
97962: PUSH
97963: LD_EXP 113
97967: AND
97968: IFFALSE 98079
97970: GO 97972
97972: DISABLE
97973: LD_INT 0
97975: PPUSH
97976: PPUSH
97977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97978: LD_ADDR_VAR 0 3
97982: PUSH
97983: LD_INT 22
97985: PUSH
97986: LD_OWVAR 2
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 25
97997: PUSH
97998: LD_INT 1
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: PPUSH
98009: CALL_OW 69
98013: ST_TO_ADDR
// if not tmp then
98014: LD_VAR 0 3
98018: NOT
98019: IFFALSE 98023
// exit ;
98021: GO 98079
// un := tmp [ rand ( 1 , tmp ) ] ;
98023: LD_ADDR_VAR 0 2
98027: PUSH
98028: LD_VAR 0 3
98032: PUSH
98033: LD_INT 1
98035: PPUSH
98036: LD_VAR 0 3
98040: PPUSH
98041: CALL_OW 12
98045: ARRAY
98046: ST_TO_ADDR
// if Crawls ( un ) then
98047: LD_VAR 0 2
98051: PPUSH
98052: CALL_OW 318
98056: IFFALSE 98067
// ComWalk ( un ) ;
98058: LD_VAR 0 2
98062: PPUSH
98063: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98067: LD_VAR 0 2
98071: PPUSH
98072: LD_INT 5
98074: PPUSH
98075: CALL_OW 336
// end ;
98079: PPOPN 3
98081: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98082: LD_EXP 96
98086: PUSH
98087: LD_EXP 114
98091: AND
98092: PUSH
98093: LD_OWVAR 67
98097: PUSH
98098: LD_INT 4
98100: LESS
98101: AND
98102: IFFALSE 98121
98104: GO 98106
98106: DISABLE
// begin Difficulty := Difficulty + 1 ;
98107: LD_ADDR_OWVAR 67
98111: PUSH
98112: LD_OWVAR 67
98116: PUSH
98117: LD_INT 1
98119: PLUS
98120: ST_TO_ADDR
// end ;
98121: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98122: LD_EXP 96
98126: PUSH
98127: LD_EXP 115
98131: AND
98132: IFFALSE 98235
98134: GO 98136
98136: DISABLE
98137: LD_INT 0
98139: PPUSH
// begin for i := 1 to 5 do
98140: LD_ADDR_VAR 0 1
98144: PUSH
98145: DOUBLE
98146: LD_INT 1
98148: DEC
98149: ST_TO_ADDR
98150: LD_INT 5
98152: PUSH
98153: FOR_TO
98154: IFFALSE 98233
// begin uc_nation := nation_nature ;
98156: LD_ADDR_OWVAR 21
98160: PUSH
98161: LD_INT 0
98163: ST_TO_ADDR
// uc_side := 0 ;
98164: LD_ADDR_OWVAR 20
98168: PUSH
98169: LD_INT 0
98171: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98172: LD_ADDR_OWVAR 29
98176: PUSH
98177: LD_INT 12
98179: PUSH
98180: LD_INT 12
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: ST_TO_ADDR
// hc_agressivity := 20 ;
98187: LD_ADDR_OWVAR 35
98191: PUSH
98192: LD_INT 20
98194: ST_TO_ADDR
// hc_class := class_tiger ;
98195: LD_ADDR_OWVAR 28
98199: PUSH
98200: LD_INT 14
98202: ST_TO_ADDR
// hc_gallery :=  ;
98203: LD_ADDR_OWVAR 33
98207: PUSH
98208: LD_STRING 
98210: ST_TO_ADDR
// hc_name :=  ;
98211: LD_ADDR_OWVAR 26
98215: PUSH
98216: LD_STRING 
98218: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98219: CALL_OW 44
98223: PPUSH
98224: LD_INT 0
98226: PPUSH
98227: CALL_OW 51
// end ;
98231: GO 98153
98233: POP
98234: POP
// end ;
98235: PPOPN 1
98237: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98238: LD_EXP 96
98242: PUSH
98243: LD_EXP 116
98247: AND
98248: IFFALSE 98257
98250: GO 98252
98252: DISABLE
// StreamSibBomb ;
98253: CALL 98258 0 0
98257: END
// export function StreamSibBomb ; var i , x , y ; begin
98258: LD_INT 0
98260: PPUSH
98261: PPUSH
98262: PPUSH
98263: PPUSH
// result := false ;
98264: LD_ADDR_VAR 0 1
98268: PUSH
98269: LD_INT 0
98271: ST_TO_ADDR
// for i := 1 to 16 do
98272: LD_ADDR_VAR 0 2
98276: PUSH
98277: DOUBLE
98278: LD_INT 1
98280: DEC
98281: ST_TO_ADDR
98282: LD_INT 16
98284: PUSH
98285: FOR_TO
98286: IFFALSE 98485
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98288: LD_ADDR_VAR 0 3
98292: PUSH
98293: LD_INT 10
98295: PUSH
98296: LD_INT 20
98298: PUSH
98299: LD_INT 30
98301: PUSH
98302: LD_INT 40
98304: PUSH
98305: LD_INT 50
98307: PUSH
98308: LD_INT 60
98310: PUSH
98311: LD_INT 70
98313: PUSH
98314: LD_INT 80
98316: PUSH
98317: LD_INT 90
98319: PUSH
98320: LD_INT 100
98322: PUSH
98323: LD_INT 110
98325: PUSH
98326: LD_INT 120
98328: PUSH
98329: LD_INT 130
98331: PUSH
98332: LD_INT 140
98334: PUSH
98335: LD_INT 150
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: PUSH
98355: LD_INT 1
98357: PPUSH
98358: LD_INT 15
98360: PPUSH
98361: CALL_OW 12
98365: ARRAY
98366: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98367: LD_ADDR_VAR 0 4
98371: PUSH
98372: LD_INT 10
98374: PUSH
98375: LD_INT 20
98377: PUSH
98378: LD_INT 30
98380: PUSH
98381: LD_INT 40
98383: PUSH
98384: LD_INT 50
98386: PUSH
98387: LD_INT 60
98389: PUSH
98390: LD_INT 70
98392: PUSH
98393: LD_INT 80
98395: PUSH
98396: LD_INT 90
98398: PUSH
98399: LD_INT 100
98401: PUSH
98402: LD_INT 110
98404: PUSH
98405: LD_INT 120
98407: PUSH
98408: LD_INT 130
98410: PUSH
98411: LD_INT 140
98413: PUSH
98414: LD_INT 150
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: PUSH
98434: LD_INT 1
98436: PPUSH
98437: LD_INT 15
98439: PPUSH
98440: CALL_OW 12
98444: ARRAY
98445: ST_TO_ADDR
// if ValidHex ( x , y ) then
98446: LD_VAR 0 3
98450: PPUSH
98451: LD_VAR 0 4
98455: PPUSH
98456: CALL_OW 488
98460: IFFALSE 98483
// begin result := [ x , y ] ;
98462: LD_ADDR_VAR 0 1
98466: PUSH
98467: LD_VAR 0 3
98471: PUSH
98472: LD_VAR 0 4
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: ST_TO_ADDR
// break ;
98481: GO 98485
// end ; end ;
98483: GO 98285
98485: POP
98486: POP
// if result then
98487: LD_VAR 0 1
98491: IFFALSE 98551
// begin ToLua ( playSibBomb() ) ;
98493: LD_STRING playSibBomb()
98495: PPUSH
98496: CALL_OW 559
// wait ( 0 0$14 ) ;
98500: LD_INT 490
98502: PPUSH
98503: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98507: LD_VAR 0 1
98511: PUSH
98512: LD_INT 1
98514: ARRAY
98515: PPUSH
98516: LD_VAR 0 1
98520: PUSH
98521: LD_INT 2
98523: ARRAY
98524: PPUSH
98525: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98529: LD_VAR 0 1
98533: PUSH
98534: LD_INT 1
98536: ARRAY
98537: PPUSH
98538: LD_VAR 0 1
98542: PUSH
98543: LD_INT 2
98545: ARRAY
98546: PPUSH
98547: CALL_OW 429
// end ; end ;
98551: LD_VAR 0 1
98555: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98556: LD_EXP 96
98560: PUSH
98561: LD_EXP 118
98565: AND
98566: IFFALSE 98578
98568: GO 98570
98570: DISABLE
// YouLost (  ) ;
98571: LD_STRING 
98573: PPUSH
98574: CALL_OW 104
98578: END
// every 0 0$1 trigger StreamModeActive and sFog do
98579: LD_EXP 96
98583: PUSH
98584: LD_EXP 117
98588: AND
98589: IFFALSE 98603
98591: GO 98593
98593: DISABLE
// FogOff ( your_side ) ;
98594: LD_OWVAR 2
98598: PPUSH
98599: CALL_OW 344
98603: END
// every 0 0$1 trigger StreamModeActive and sSun do
98604: LD_EXP 96
98608: PUSH
98609: LD_EXP 119
98613: AND
98614: IFFALSE 98642
98616: GO 98618
98618: DISABLE
// begin solar_recharge_percent := 0 ;
98619: LD_ADDR_OWVAR 79
98623: PUSH
98624: LD_INT 0
98626: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98627: LD_INT 10500
98629: PPUSH
98630: CALL_OW 67
// solar_recharge_percent := 100 ;
98634: LD_ADDR_OWVAR 79
98638: PUSH
98639: LD_INT 100
98641: ST_TO_ADDR
// end ;
98642: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98643: LD_EXP 96
98647: PUSH
98648: LD_EXP 120
98652: AND
98653: IFFALSE 98892
98655: GO 98657
98657: DISABLE
98658: LD_INT 0
98660: PPUSH
98661: PPUSH
98662: PPUSH
// begin tmp := [ ] ;
98663: LD_ADDR_VAR 0 3
98667: PUSH
98668: EMPTY
98669: ST_TO_ADDR
// for i := 1 to 6 do
98670: LD_ADDR_VAR 0 1
98674: PUSH
98675: DOUBLE
98676: LD_INT 1
98678: DEC
98679: ST_TO_ADDR
98680: LD_INT 6
98682: PUSH
98683: FOR_TO
98684: IFFALSE 98789
// begin uc_nation := nation_nature ;
98686: LD_ADDR_OWVAR 21
98690: PUSH
98691: LD_INT 0
98693: ST_TO_ADDR
// uc_side := 0 ;
98694: LD_ADDR_OWVAR 20
98698: PUSH
98699: LD_INT 0
98701: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98702: LD_ADDR_OWVAR 29
98706: PUSH
98707: LD_INT 12
98709: PUSH
98710: LD_INT 12
98712: PUSH
98713: EMPTY
98714: LIST
98715: LIST
98716: ST_TO_ADDR
// hc_agressivity := 20 ;
98717: LD_ADDR_OWVAR 35
98721: PUSH
98722: LD_INT 20
98724: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98725: LD_ADDR_OWVAR 28
98729: PUSH
98730: LD_INT 17
98732: ST_TO_ADDR
// hc_gallery :=  ;
98733: LD_ADDR_OWVAR 33
98737: PUSH
98738: LD_STRING 
98740: ST_TO_ADDR
// hc_name :=  ;
98741: LD_ADDR_OWVAR 26
98745: PUSH
98746: LD_STRING 
98748: ST_TO_ADDR
// un := CreateHuman ;
98749: LD_ADDR_VAR 0 2
98753: PUSH
98754: CALL_OW 44
98758: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98759: LD_VAR 0 2
98763: PPUSH
98764: LD_INT 1
98766: PPUSH
98767: CALL_OW 51
// tmp := tmp ^ un ;
98771: LD_ADDR_VAR 0 3
98775: PUSH
98776: LD_VAR 0 3
98780: PUSH
98781: LD_VAR 0 2
98785: ADD
98786: ST_TO_ADDR
// end ;
98787: GO 98683
98789: POP
98790: POP
// repeat wait ( 0 0$1 ) ;
98791: LD_INT 35
98793: PPUSH
98794: CALL_OW 67
// for un in tmp do
98798: LD_ADDR_VAR 0 2
98802: PUSH
98803: LD_VAR 0 3
98807: PUSH
98808: FOR_IN
98809: IFFALSE 98883
// begin if IsDead ( un ) then
98811: LD_VAR 0 2
98815: PPUSH
98816: CALL_OW 301
98820: IFFALSE 98840
// begin tmp := tmp diff un ;
98822: LD_ADDR_VAR 0 3
98826: PUSH
98827: LD_VAR 0 3
98831: PUSH
98832: LD_VAR 0 2
98836: DIFF
98837: ST_TO_ADDR
// continue ;
98838: GO 98808
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98840: LD_VAR 0 2
98844: PPUSH
98845: LD_INT 3
98847: PUSH
98848: LD_INT 22
98850: PUSH
98851: LD_INT 0
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: PPUSH
98862: CALL_OW 69
98866: PPUSH
98867: LD_VAR 0 2
98871: PPUSH
98872: CALL_OW 74
98876: PPUSH
98877: CALL_OW 115
// end ;
98881: GO 98808
98883: POP
98884: POP
// until not tmp ;
98885: LD_VAR 0 3
98889: NOT
98890: IFFALSE 98791
// end ;
98892: PPOPN 3
98894: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98895: LD_EXP 96
98899: PUSH
98900: LD_EXP 121
98904: AND
98905: IFFALSE 98959
98907: GO 98909
98909: DISABLE
// begin ToLua ( displayTroll(); ) ;
98910: LD_STRING displayTroll();
98912: PPUSH
98913: CALL_OW 559
// wait ( 3 3$00 ) ;
98917: LD_INT 6300
98919: PPUSH
98920: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98924: LD_STRING hideTroll();
98926: PPUSH
98927: CALL_OW 559
// wait ( 1 1$00 ) ;
98931: LD_INT 2100
98933: PPUSH
98934: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98938: LD_STRING displayTroll();
98940: PPUSH
98941: CALL_OW 559
// wait ( 1 1$00 ) ;
98945: LD_INT 2100
98947: PPUSH
98948: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98952: LD_STRING hideTroll();
98954: PPUSH
98955: CALL_OW 559
// end ;
98959: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98960: LD_EXP 96
98964: PUSH
98965: LD_EXP 122
98969: AND
98970: IFFALSE 99033
98972: GO 98974
98974: DISABLE
98975: LD_INT 0
98977: PPUSH
// begin p := 0 ;
98978: LD_ADDR_VAR 0 1
98982: PUSH
98983: LD_INT 0
98985: ST_TO_ADDR
// repeat game_speed := 1 ;
98986: LD_ADDR_OWVAR 65
98990: PUSH
98991: LD_INT 1
98993: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98994: LD_INT 35
98996: PPUSH
98997: CALL_OW 67
// p := p + 1 ;
99001: LD_ADDR_VAR 0 1
99005: PUSH
99006: LD_VAR 0 1
99010: PUSH
99011: LD_INT 1
99013: PLUS
99014: ST_TO_ADDR
// until p >= 60 ;
99015: LD_VAR 0 1
99019: PUSH
99020: LD_INT 60
99022: GREATEREQUAL
99023: IFFALSE 98986
// game_speed := 4 ;
99025: LD_ADDR_OWVAR 65
99029: PUSH
99030: LD_INT 4
99032: ST_TO_ADDR
// end ;
99033: PPOPN 1
99035: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99036: LD_EXP 96
99040: PUSH
99041: LD_EXP 123
99045: AND
99046: IFFALSE 99192
99048: GO 99050
99050: DISABLE
99051: LD_INT 0
99053: PPUSH
99054: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99055: LD_ADDR_VAR 0 1
99059: PUSH
99060: LD_INT 22
99062: PUSH
99063: LD_OWVAR 2
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: PUSH
99072: LD_INT 2
99074: PUSH
99075: LD_INT 30
99077: PUSH
99078: LD_INT 0
99080: PUSH
99081: EMPTY
99082: LIST
99083: LIST
99084: PUSH
99085: LD_INT 30
99087: PUSH
99088: LD_INT 1
99090: PUSH
99091: EMPTY
99092: LIST
99093: LIST
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: LIST
99099: PUSH
99100: EMPTY
99101: LIST
99102: LIST
99103: PPUSH
99104: CALL_OW 69
99108: ST_TO_ADDR
// if not depot then
99109: LD_VAR 0 1
99113: NOT
99114: IFFALSE 99118
// exit ;
99116: GO 99192
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99118: LD_ADDR_VAR 0 2
99122: PUSH
99123: LD_VAR 0 1
99127: PUSH
99128: LD_INT 1
99130: PPUSH
99131: LD_VAR 0 1
99135: PPUSH
99136: CALL_OW 12
99140: ARRAY
99141: PPUSH
99142: CALL_OW 274
99146: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99147: LD_VAR 0 2
99151: PPUSH
99152: LD_INT 1
99154: PPUSH
99155: LD_INT 0
99157: PPUSH
99158: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99162: LD_VAR 0 2
99166: PPUSH
99167: LD_INT 2
99169: PPUSH
99170: LD_INT 0
99172: PPUSH
99173: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99177: LD_VAR 0 2
99181: PPUSH
99182: LD_INT 3
99184: PPUSH
99185: LD_INT 0
99187: PPUSH
99188: CALL_OW 277
// end ;
99192: PPOPN 2
99194: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99195: LD_EXP 96
99199: PUSH
99200: LD_EXP 124
99204: AND
99205: IFFALSE 99302
99207: GO 99209
99209: DISABLE
99210: LD_INT 0
99212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99213: LD_ADDR_VAR 0 1
99217: PUSH
99218: LD_INT 22
99220: PUSH
99221: LD_OWVAR 2
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: LD_INT 21
99232: PUSH
99233: LD_INT 1
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: PUSH
99240: LD_INT 3
99242: PUSH
99243: LD_INT 23
99245: PUSH
99246: LD_INT 0
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: PPUSH
99262: CALL_OW 69
99266: ST_TO_ADDR
// if not tmp then
99267: LD_VAR 0 1
99271: NOT
99272: IFFALSE 99276
// exit ;
99274: GO 99302
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99276: LD_VAR 0 1
99280: PUSH
99281: LD_INT 1
99283: PPUSH
99284: LD_VAR 0 1
99288: PPUSH
99289: CALL_OW 12
99293: ARRAY
99294: PPUSH
99295: LD_INT 200
99297: PPUSH
99298: CALL_OW 234
// end ;
99302: PPOPN 1
99304: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99305: LD_EXP 96
99309: PUSH
99310: LD_EXP 125
99314: AND
99315: IFFALSE 99394
99317: GO 99319
99319: DISABLE
99320: LD_INT 0
99322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99323: LD_ADDR_VAR 0 1
99327: PUSH
99328: LD_INT 22
99330: PUSH
99331: LD_OWVAR 2
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PUSH
99340: LD_INT 21
99342: PUSH
99343: LD_INT 2
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: ST_TO_ADDR
// if not tmp then
99359: LD_VAR 0 1
99363: NOT
99364: IFFALSE 99368
// exit ;
99366: GO 99394
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99368: LD_VAR 0 1
99372: PUSH
99373: LD_INT 1
99375: PPUSH
99376: LD_VAR 0 1
99380: PPUSH
99381: CALL_OW 12
99385: ARRAY
99386: PPUSH
99387: LD_INT 60
99389: PPUSH
99390: CALL_OW 234
// end ;
99394: PPOPN 1
99396: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99397: LD_EXP 96
99401: PUSH
99402: LD_EXP 126
99406: AND
99407: IFFALSE 99506
99409: GO 99411
99411: DISABLE
99412: LD_INT 0
99414: PPUSH
99415: PPUSH
// begin enable ;
99416: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99417: LD_ADDR_VAR 0 1
99421: PUSH
99422: LD_INT 22
99424: PUSH
99425: LD_OWVAR 2
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 61
99436: PUSH
99437: EMPTY
99438: LIST
99439: PUSH
99440: LD_INT 33
99442: PUSH
99443: LD_INT 2
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: LIST
99454: PPUSH
99455: CALL_OW 69
99459: ST_TO_ADDR
// if not tmp then
99460: LD_VAR 0 1
99464: NOT
99465: IFFALSE 99469
// exit ;
99467: GO 99506
// for i in tmp do
99469: LD_ADDR_VAR 0 2
99473: PUSH
99474: LD_VAR 0 1
99478: PUSH
99479: FOR_IN
99480: IFFALSE 99504
// if IsControledBy ( i ) then
99482: LD_VAR 0 2
99486: PPUSH
99487: CALL_OW 312
99491: IFFALSE 99502
// ComUnlink ( i ) ;
99493: LD_VAR 0 2
99497: PPUSH
99498: CALL_OW 136
99502: GO 99479
99504: POP
99505: POP
// end ;
99506: PPOPN 2
99508: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99509: LD_EXP 96
99513: PUSH
99514: LD_EXP 127
99518: AND
99519: IFFALSE 99659
99521: GO 99523
99523: DISABLE
99524: LD_INT 0
99526: PPUSH
99527: PPUSH
// begin ToLua ( displayPowell(); ) ;
99528: LD_STRING displayPowell();
99530: PPUSH
99531: CALL_OW 559
// uc_side := 0 ;
99535: LD_ADDR_OWVAR 20
99539: PUSH
99540: LD_INT 0
99542: ST_TO_ADDR
// uc_nation := 2 ;
99543: LD_ADDR_OWVAR 21
99547: PUSH
99548: LD_INT 2
99550: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99551: LD_ADDR_OWVAR 37
99555: PUSH
99556: LD_INT 14
99558: ST_TO_ADDR
// vc_engine := engine_siberite ;
99559: LD_ADDR_OWVAR 39
99563: PUSH
99564: LD_INT 3
99566: ST_TO_ADDR
// vc_control := control_apeman ;
99567: LD_ADDR_OWVAR 38
99571: PUSH
99572: LD_INT 5
99574: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99575: LD_ADDR_OWVAR 40
99579: PUSH
99580: LD_INT 29
99582: ST_TO_ADDR
// un := CreateVehicle ;
99583: LD_ADDR_VAR 0 2
99587: PUSH
99588: CALL_OW 45
99592: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99593: LD_VAR 0 2
99597: PPUSH
99598: LD_INT 1
99600: PPUSH
99601: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99605: LD_INT 35
99607: PPUSH
99608: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99612: LD_VAR 0 2
99616: PPUSH
99617: LD_INT 22
99619: PUSH
99620: LD_OWVAR 2
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: PPUSH
99629: CALL_OW 69
99633: PPUSH
99634: LD_VAR 0 2
99638: PPUSH
99639: CALL_OW 74
99643: PPUSH
99644: CALL_OW 115
// until IsDead ( un ) ;
99648: LD_VAR 0 2
99652: PPUSH
99653: CALL_OW 301
99657: IFFALSE 99605
// end ;
99659: PPOPN 2
99661: END
// every 0 0$1 trigger StreamModeActive and sStu do
99662: LD_EXP 96
99666: PUSH
99667: LD_EXP 135
99671: AND
99672: IFFALSE 99688
99674: GO 99676
99676: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99677: LD_STRING displayStucuk();
99679: PPUSH
99680: CALL_OW 559
// ResetFog ;
99684: CALL_OW 335
// end ;
99688: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99689: LD_EXP 96
99693: PUSH
99694: LD_EXP 128
99698: AND
99699: IFFALSE 99840
99701: GO 99703
99703: DISABLE
99704: LD_INT 0
99706: PPUSH
99707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99708: LD_ADDR_VAR 0 2
99712: PUSH
99713: LD_INT 22
99715: PUSH
99716: LD_OWVAR 2
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 21
99727: PUSH
99728: LD_INT 1
99730: PUSH
99731: EMPTY
99732: LIST
99733: LIST
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: PPUSH
99739: CALL_OW 69
99743: ST_TO_ADDR
// if not tmp then
99744: LD_VAR 0 2
99748: NOT
99749: IFFALSE 99753
// exit ;
99751: GO 99840
// un := tmp [ rand ( 1 , tmp ) ] ;
99753: LD_ADDR_VAR 0 1
99757: PUSH
99758: LD_VAR 0 2
99762: PUSH
99763: LD_INT 1
99765: PPUSH
99766: LD_VAR 0 2
99770: PPUSH
99771: CALL_OW 12
99775: ARRAY
99776: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99777: LD_VAR 0 1
99781: PPUSH
99782: LD_INT 0
99784: PPUSH
99785: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99789: LD_VAR 0 1
99793: PPUSH
99794: LD_OWVAR 3
99798: PUSH
99799: LD_VAR 0 1
99803: DIFF
99804: PPUSH
99805: LD_VAR 0 1
99809: PPUSH
99810: CALL_OW 74
99814: PPUSH
99815: CALL_OW 115
// wait ( 0 0$20 ) ;
99819: LD_INT 700
99821: PPUSH
99822: CALL_OW 67
// SetSide ( un , your_side ) ;
99826: LD_VAR 0 1
99830: PPUSH
99831: LD_OWVAR 2
99835: PPUSH
99836: CALL_OW 235
// end ;
99840: PPOPN 2
99842: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99843: LD_EXP 96
99847: PUSH
99848: LD_EXP 129
99852: AND
99853: IFFALSE 99959
99855: GO 99857
99857: DISABLE
99858: LD_INT 0
99860: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99861: LD_ADDR_VAR 0 1
99865: PUSH
99866: LD_INT 22
99868: PUSH
99869: LD_OWVAR 2
99873: PUSH
99874: EMPTY
99875: LIST
99876: LIST
99877: PUSH
99878: LD_INT 2
99880: PUSH
99881: LD_INT 30
99883: PUSH
99884: LD_INT 0
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 30
99893: PUSH
99894: LD_INT 1
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: LIST
99905: PUSH
99906: EMPTY
99907: LIST
99908: LIST
99909: PPUSH
99910: CALL_OW 69
99914: ST_TO_ADDR
// if not depot then
99915: LD_VAR 0 1
99919: NOT
99920: IFFALSE 99924
// exit ;
99922: GO 99959
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99924: LD_VAR 0 1
99928: PUSH
99929: LD_INT 1
99931: ARRAY
99932: PPUSH
99933: CALL_OW 250
99937: PPUSH
99938: LD_VAR 0 1
99942: PUSH
99943: LD_INT 1
99945: ARRAY
99946: PPUSH
99947: CALL_OW 251
99951: PPUSH
99952: LD_INT 70
99954: PPUSH
99955: CALL_OW 495
// end ;
99959: PPOPN 1
99961: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99962: LD_EXP 96
99966: PUSH
99967: LD_EXP 130
99971: AND
99972: IFFALSE 100183
99974: GO 99976
99976: DISABLE
99977: LD_INT 0
99979: PPUSH
99980: PPUSH
99981: PPUSH
99982: PPUSH
99983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99984: LD_ADDR_VAR 0 5
99988: PUSH
99989: LD_INT 22
99991: PUSH
99992: LD_OWVAR 2
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: LD_INT 21
100003: PUSH
100004: LD_INT 1
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PPUSH
100015: CALL_OW 69
100019: ST_TO_ADDR
// if not tmp then
100020: LD_VAR 0 5
100024: NOT
100025: IFFALSE 100029
// exit ;
100027: GO 100183
// for i in tmp do
100029: LD_ADDR_VAR 0 1
100033: PUSH
100034: LD_VAR 0 5
100038: PUSH
100039: FOR_IN
100040: IFFALSE 100181
// begin d := rand ( 0 , 5 ) ;
100042: LD_ADDR_VAR 0 4
100046: PUSH
100047: LD_INT 0
100049: PPUSH
100050: LD_INT 5
100052: PPUSH
100053: CALL_OW 12
100057: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100058: LD_ADDR_VAR 0 2
100062: PUSH
100063: LD_VAR 0 1
100067: PPUSH
100068: CALL_OW 250
100072: PPUSH
100073: LD_VAR 0 4
100077: PPUSH
100078: LD_INT 3
100080: PPUSH
100081: LD_INT 12
100083: PPUSH
100084: CALL_OW 12
100088: PPUSH
100089: CALL_OW 272
100093: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100094: LD_ADDR_VAR 0 3
100098: PUSH
100099: LD_VAR 0 1
100103: PPUSH
100104: CALL_OW 251
100108: PPUSH
100109: LD_VAR 0 4
100113: PPUSH
100114: LD_INT 3
100116: PPUSH
100117: LD_INT 12
100119: PPUSH
100120: CALL_OW 12
100124: PPUSH
100125: CALL_OW 273
100129: ST_TO_ADDR
// if ValidHex ( x , y ) then
100130: LD_VAR 0 2
100134: PPUSH
100135: LD_VAR 0 3
100139: PPUSH
100140: CALL_OW 488
100144: IFFALSE 100179
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100146: LD_VAR 0 1
100150: PPUSH
100151: LD_VAR 0 2
100155: PPUSH
100156: LD_VAR 0 3
100160: PPUSH
100161: LD_INT 3
100163: PPUSH
100164: LD_INT 6
100166: PPUSH
100167: CALL_OW 12
100171: PPUSH
100172: LD_INT 1
100174: PPUSH
100175: CALL_OW 483
// end ;
100179: GO 100039
100181: POP
100182: POP
// end ;
100183: PPOPN 5
100185: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100186: LD_EXP 96
100190: PUSH
100191: LD_EXP 131
100195: AND
100196: IFFALSE 100290
100198: GO 100200
100200: DISABLE
100201: LD_INT 0
100203: PPUSH
100204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100205: LD_ADDR_VAR 0 2
100209: PUSH
100210: LD_INT 22
100212: PUSH
100213: LD_OWVAR 2
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PUSH
100222: LD_INT 32
100224: PUSH
100225: LD_INT 1
100227: PUSH
100228: EMPTY
100229: LIST
100230: LIST
100231: PUSH
100232: LD_INT 21
100234: PUSH
100235: LD_INT 2
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: PUSH
100242: EMPTY
100243: LIST
100244: LIST
100245: LIST
100246: PPUSH
100247: CALL_OW 69
100251: ST_TO_ADDR
// if not tmp then
100252: LD_VAR 0 2
100256: NOT
100257: IFFALSE 100261
// exit ;
100259: GO 100290
// for i in tmp do
100261: LD_ADDR_VAR 0 1
100265: PUSH
100266: LD_VAR 0 2
100270: PUSH
100271: FOR_IN
100272: IFFALSE 100288
// SetFuel ( i , 0 ) ;
100274: LD_VAR 0 1
100278: PPUSH
100279: LD_INT 0
100281: PPUSH
100282: CALL_OW 240
100286: GO 100271
100288: POP
100289: POP
// end ;
100290: PPOPN 2
100292: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100293: LD_EXP 96
100297: PUSH
100298: LD_EXP 132
100302: AND
100303: IFFALSE 100369
100305: GO 100307
100307: DISABLE
100308: LD_INT 0
100310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100311: LD_ADDR_VAR 0 1
100315: PUSH
100316: LD_INT 22
100318: PUSH
100319: LD_OWVAR 2
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 30
100330: PUSH
100331: LD_INT 29
100333: PUSH
100334: EMPTY
100335: LIST
100336: LIST
100337: PUSH
100338: EMPTY
100339: LIST
100340: LIST
100341: PPUSH
100342: CALL_OW 69
100346: ST_TO_ADDR
// if not tmp then
100347: LD_VAR 0 1
100351: NOT
100352: IFFALSE 100356
// exit ;
100354: GO 100369
// DestroyUnit ( tmp [ 1 ] ) ;
100356: LD_VAR 0 1
100360: PUSH
100361: LD_INT 1
100363: ARRAY
100364: PPUSH
100365: CALL_OW 65
// end ;
100369: PPOPN 1
100371: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100372: LD_EXP 96
100376: PUSH
100377: LD_EXP 134
100381: AND
100382: IFFALSE 100511
100384: GO 100386
100386: DISABLE
100387: LD_INT 0
100389: PPUSH
// begin uc_side := 0 ;
100390: LD_ADDR_OWVAR 20
100394: PUSH
100395: LD_INT 0
100397: ST_TO_ADDR
// uc_nation := nation_arabian ;
100398: LD_ADDR_OWVAR 21
100402: PUSH
100403: LD_INT 2
100405: ST_TO_ADDR
// hc_gallery :=  ;
100406: LD_ADDR_OWVAR 33
100410: PUSH
100411: LD_STRING 
100413: ST_TO_ADDR
// hc_name :=  ;
100414: LD_ADDR_OWVAR 26
100418: PUSH
100419: LD_STRING 
100421: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100422: LD_INT 1
100424: PPUSH
100425: LD_INT 11
100427: PPUSH
100428: LD_INT 10
100430: PPUSH
100431: CALL_OW 380
// un := CreateHuman ;
100435: LD_ADDR_VAR 0 1
100439: PUSH
100440: CALL_OW 44
100444: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100445: LD_VAR 0 1
100449: PPUSH
100450: LD_INT 1
100452: PPUSH
100453: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100457: LD_INT 35
100459: PPUSH
100460: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100464: LD_VAR 0 1
100468: PPUSH
100469: LD_INT 22
100471: PUSH
100472: LD_OWVAR 2
100476: PUSH
100477: EMPTY
100478: LIST
100479: LIST
100480: PPUSH
100481: CALL_OW 69
100485: PPUSH
100486: LD_VAR 0 1
100490: PPUSH
100491: CALL_OW 74
100495: PPUSH
100496: CALL_OW 115
// until IsDead ( un ) ;
100500: LD_VAR 0 1
100504: PPUSH
100505: CALL_OW 301
100509: IFFALSE 100457
// end ;
100511: PPOPN 1
100513: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100514: LD_EXP 96
100518: PUSH
100519: LD_EXP 136
100523: AND
100524: IFFALSE 100536
100526: GO 100528
100528: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100529: LD_STRING earthquake(getX(game), 0, 32)
100531: PPUSH
100532: CALL_OW 559
100536: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100537: LD_EXP 96
100541: PUSH
100542: LD_EXP 137
100546: AND
100547: IFFALSE 100638
100549: GO 100551
100551: DISABLE
100552: LD_INT 0
100554: PPUSH
// begin enable ;
100555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100556: LD_ADDR_VAR 0 1
100560: PUSH
100561: LD_INT 22
100563: PUSH
100564: LD_OWVAR 2
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: LD_INT 21
100575: PUSH
100576: LD_INT 2
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: LD_INT 33
100585: PUSH
100586: LD_INT 3
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: PUSH
100593: EMPTY
100594: LIST
100595: LIST
100596: LIST
100597: PPUSH
100598: CALL_OW 69
100602: ST_TO_ADDR
// if not tmp then
100603: LD_VAR 0 1
100607: NOT
100608: IFFALSE 100612
// exit ;
100610: GO 100638
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100612: LD_VAR 0 1
100616: PUSH
100617: LD_INT 1
100619: PPUSH
100620: LD_VAR 0 1
100624: PPUSH
100625: CALL_OW 12
100629: ARRAY
100630: PPUSH
100631: LD_INT 1
100633: PPUSH
100634: CALL_OW 234
// end ;
100638: PPOPN 1
100640: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100641: LD_EXP 96
100645: PUSH
100646: LD_EXP 138
100650: AND
100651: IFFALSE 100792
100653: GO 100655
100655: DISABLE
100656: LD_INT 0
100658: PPUSH
100659: PPUSH
100660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100661: LD_ADDR_VAR 0 3
100665: PUSH
100666: LD_INT 22
100668: PUSH
100669: LD_OWVAR 2
100673: PUSH
100674: EMPTY
100675: LIST
100676: LIST
100677: PUSH
100678: LD_INT 25
100680: PUSH
100681: LD_INT 1
100683: PUSH
100684: EMPTY
100685: LIST
100686: LIST
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: PPUSH
100692: CALL_OW 69
100696: ST_TO_ADDR
// if not tmp then
100697: LD_VAR 0 3
100701: NOT
100702: IFFALSE 100706
// exit ;
100704: GO 100792
// un := tmp [ rand ( 1 , tmp ) ] ;
100706: LD_ADDR_VAR 0 2
100710: PUSH
100711: LD_VAR 0 3
100715: PUSH
100716: LD_INT 1
100718: PPUSH
100719: LD_VAR 0 3
100723: PPUSH
100724: CALL_OW 12
100728: ARRAY
100729: ST_TO_ADDR
// if Crawls ( un ) then
100730: LD_VAR 0 2
100734: PPUSH
100735: CALL_OW 318
100739: IFFALSE 100750
// ComWalk ( un ) ;
100741: LD_VAR 0 2
100745: PPUSH
100746: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100750: LD_VAR 0 2
100754: PPUSH
100755: LD_INT 9
100757: PPUSH
100758: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100762: LD_INT 28
100764: PPUSH
100765: LD_OWVAR 2
100769: PPUSH
100770: LD_INT 2
100772: PPUSH
100773: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100777: LD_INT 29
100779: PPUSH
100780: LD_OWVAR 2
100784: PPUSH
100785: LD_INT 2
100787: PPUSH
100788: CALL_OW 322
// end ;
100792: PPOPN 3
100794: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100795: LD_EXP 96
100799: PUSH
100800: LD_EXP 139
100804: AND
100805: IFFALSE 100916
100807: GO 100809
100809: DISABLE
100810: LD_INT 0
100812: PPUSH
100813: PPUSH
100814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100815: LD_ADDR_VAR 0 3
100819: PUSH
100820: LD_INT 22
100822: PUSH
100823: LD_OWVAR 2
100827: PUSH
100828: EMPTY
100829: LIST
100830: LIST
100831: PUSH
100832: LD_INT 25
100834: PUSH
100835: LD_INT 1
100837: PUSH
100838: EMPTY
100839: LIST
100840: LIST
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: PPUSH
100846: CALL_OW 69
100850: ST_TO_ADDR
// if not tmp then
100851: LD_VAR 0 3
100855: NOT
100856: IFFALSE 100860
// exit ;
100858: GO 100916
// un := tmp [ rand ( 1 , tmp ) ] ;
100860: LD_ADDR_VAR 0 2
100864: PUSH
100865: LD_VAR 0 3
100869: PUSH
100870: LD_INT 1
100872: PPUSH
100873: LD_VAR 0 3
100877: PPUSH
100878: CALL_OW 12
100882: ARRAY
100883: ST_TO_ADDR
// if Crawls ( un ) then
100884: LD_VAR 0 2
100888: PPUSH
100889: CALL_OW 318
100893: IFFALSE 100904
// ComWalk ( un ) ;
100895: LD_VAR 0 2
100899: PPUSH
100900: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100904: LD_VAR 0 2
100908: PPUSH
100909: LD_INT 8
100911: PPUSH
100912: CALL_OW 336
// end ;
100916: PPOPN 3
100918: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100919: LD_EXP 96
100923: PUSH
100924: LD_EXP 140
100928: AND
100929: IFFALSE 101073
100931: GO 100933
100933: DISABLE
100934: LD_INT 0
100936: PPUSH
100937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100938: LD_ADDR_VAR 0 2
100942: PUSH
100943: LD_INT 22
100945: PUSH
100946: LD_OWVAR 2
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PUSH
100955: LD_INT 21
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: PUSH
100965: LD_INT 2
100967: PUSH
100968: LD_INT 34
100970: PUSH
100971: LD_INT 12
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: LD_INT 34
100980: PUSH
100981: LD_INT 51
100983: PUSH
100984: EMPTY
100985: LIST
100986: LIST
100987: PUSH
100988: LD_INT 34
100990: PUSH
100991: LD_INT 32
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: PUSH
100998: EMPTY
100999: LIST
101000: LIST
101001: LIST
101002: LIST
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: LIST
101008: PPUSH
101009: CALL_OW 69
101013: ST_TO_ADDR
// if not tmp then
101014: LD_VAR 0 2
101018: NOT
101019: IFFALSE 101023
// exit ;
101021: GO 101073
// for i in tmp do
101023: LD_ADDR_VAR 0 1
101027: PUSH
101028: LD_VAR 0 2
101032: PUSH
101033: FOR_IN
101034: IFFALSE 101071
// if GetCargo ( i , mat_artifact ) = 0 then
101036: LD_VAR 0 1
101040: PPUSH
101041: LD_INT 4
101043: PPUSH
101044: CALL_OW 289
101048: PUSH
101049: LD_INT 0
101051: EQUAL
101052: IFFALSE 101069
// SetCargo ( i , mat_siberit , 100 ) ;
101054: LD_VAR 0 1
101058: PPUSH
101059: LD_INT 3
101061: PPUSH
101062: LD_INT 100
101064: PPUSH
101065: CALL_OW 290
101069: GO 101033
101071: POP
101072: POP
// end ;
101073: PPOPN 2
101075: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101076: LD_EXP 96
101080: PUSH
101081: LD_EXP 141
101085: AND
101086: IFFALSE 101269
101088: GO 101090
101090: DISABLE
101091: LD_INT 0
101093: PPUSH
101094: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101095: LD_ADDR_VAR 0 2
101099: PUSH
101100: LD_INT 22
101102: PUSH
101103: LD_OWVAR 2
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: PPUSH
101112: CALL_OW 69
101116: ST_TO_ADDR
// if not tmp then
101117: LD_VAR 0 2
101121: NOT
101122: IFFALSE 101126
// exit ;
101124: GO 101269
// for i := 1 to 2 do
101126: LD_ADDR_VAR 0 1
101130: PUSH
101131: DOUBLE
101132: LD_INT 1
101134: DEC
101135: ST_TO_ADDR
101136: LD_INT 2
101138: PUSH
101139: FOR_TO
101140: IFFALSE 101267
// begin uc_side := your_side ;
101142: LD_ADDR_OWVAR 20
101146: PUSH
101147: LD_OWVAR 2
101151: ST_TO_ADDR
// uc_nation := nation_american ;
101152: LD_ADDR_OWVAR 21
101156: PUSH
101157: LD_INT 1
101159: ST_TO_ADDR
// vc_chassis := us_morphling ;
101160: LD_ADDR_OWVAR 37
101164: PUSH
101165: LD_INT 5
101167: ST_TO_ADDR
// vc_engine := engine_siberite ;
101168: LD_ADDR_OWVAR 39
101172: PUSH
101173: LD_INT 3
101175: ST_TO_ADDR
// vc_control := control_computer ;
101176: LD_ADDR_OWVAR 38
101180: PUSH
101181: LD_INT 3
101183: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101184: LD_ADDR_OWVAR 40
101188: PUSH
101189: LD_INT 10
101191: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101192: LD_VAR 0 2
101196: PUSH
101197: LD_INT 1
101199: ARRAY
101200: PPUSH
101201: CALL_OW 310
101205: NOT
101206: IFFALSE 101253
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101208: CALL_OW 45
101212: PPUSH
101213: LD_VAR 0 2
101217: PUSH
101218: LD_INT 1
101220: ARRAY
101221: PPUSH
101222: CALL_OW 250
101226: PPUSH
101227: LD_VAR 0 2
101231: PUSH
101232: LD_INT 1
101234: ARRAY
101235: PPUSH
101236: CALL_OW 251
101240: PPUSH
101241: LD_INT 12
101243: PPUSH
101244: LD_INT 1
101246: PPUSH
101247: CALL_OW 50
101251: GO 101265
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101253: CALL_OW 45
101257: PPUSH
101258: LD_INT 1
101260: PPUSH
101261: CALL_OW 51
// end ;
101265: GO 101139
101267: POP
101268: POP
// end ;
101269: PPOPN 2
101271: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101272: LD_EXP 96
101276: PUSH
101277: LD_EXP 142
101281: AND
101282: IFFALSE 101504
101284: GO 101286
101286: DISABLE
101287: LD_INT 0
101289: PPUSH
101290: PPUSH
101291: PPUSH
101292: PPUSH
101293: PPUSH
101294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101295: LD_ADDR_VAR 0 6
101299: PUSH
101300: LD_INT 22
101302: PUSH
101303: LD_OWVAR 2
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PUSH
101312: LD_INT 21
101314: PUSH
101315: LD_INT 1
101317: PUSH
101318: EMPTY
101319: LIST
101320: LIST
101321: PUSH
101322: LD_INT 3
101324: PUSH
101325: LD_INT 23
101327: PUSH
101328: LD_INT 0
101330: PUSH
101331: EMPTY
101332: LIST
101333: LIST
101334: PUSH
101335: EMPTY
101336: LIST
101337: LIST
101338: PUSH
101339: EMPTY
101340: LIST
101341: LIST
101342: LIST
101343: PPUSH
101344: CALL_OW 69
101348: ST_TO_ADDR
// if not tmp then
101349: LD_VAR 0 6
101353: NOT
101354: IFFALSE 101358
// exit ;
101356: GO 101504
// s1 := rand ( 1 , 4 ) ;
101358: LD_ADDR_VAR 0 2
101362: PUSH
101363: LD_INT 1
101365: PPUSH
101366: LD_INT 4
101368: PPUSH
101369: CALL_OW 12
101373: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101374: LD_ADDR_VAR 0 4
101378: PUSH
101379: LD_VAR 0 6
101383: PUSH
101384: LD_INT 1
101386: ARRAY
101387: PPUSH
101388: LD_VAR 0 2
101392: PPUSH
101393: CALL_OW 259
101397: ST_TO_ADDR
// if s1 = 1 then
101398: LD_VAR 0 2
101402: PUSH
101403: LD_INT 1
101405: EQUAL
101406: IFFALSE 101426
// s2 := rand ( 2 , 4 ) else
101408: LD_ADDR_VAR 0 3
101412: PUSH
101413: LD_INT 2
101415: PPUSH
101416: LD_INT 4
101418: PPUSH
101419: CALL_OW 12
101423: ST_TO_ADDR
101424: GO 101434
// s2 := 1 ;
101426: LD_ADDR_VAR 0 3
101430: PUSH
101431: LD_INT 1
101433: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101434: LD_ADDR_VAR 0 5
101438: PUSH
101439: LD_VAR 0 6
101443: PUSH
101444: LD_INT 1
101446: ARRAY
101447: PPUSH
101448: LD_VAR 0 3
101452: PPUSH
101453: CALL_OW 259
101457: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101458: LD_VAR 0 6
101462: PUSH
101463: LD_INT 1
101465: ARRAY
101466: PPUSH
101467: LD_VAR 0 2
101471: PPUSH
101472: LD_VAR 0 5
101476: PPUSH
101477: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101481: LD_VAR 0 6
101485: PUSH
101486: LD_INT 1
101488: ARRAY
101489: PPUSH
101490: LD_VAR 0 3
101494: PPUSH
101495: LD_VAR 0 4
101499: PPUSH
101500: CALL_OW 237
// end ;
101504: PPOPN 6
101506: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101507: LD_EXP 96
101511: PUSH
101512: LD_EXP 143
101516: AND
101517: IFFALSE 101596
101519: GO 101521
101521: DISABLE
101522: LD_INT 0
101524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101525: LD_ADDR_VAR 0 1
101529: PUSH
101530: LD_INT 22
101532: PUSH
101533: LD_OWVAR 2
101537: PUSH
101538: EMPTY
101539: LIST
101540: LIST
101541: PUSH
101542: LD_INT 30
101544: PUSH
101545: LD_INT 3
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PPUSH
101556: CALL_OW 69
101560: ST_TO_ADDR
// if not tmp then
101561: LD_VAR 0 1
101565: NOT
101566: IFFALSE 101570
// exit ;
101568: GO 101596
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101570: LD_VAR 0 1
101574: PUSH
101575: LD_INT 1
101577: PPUSH
101578: LD_VAR 0 1
101582: PPUSH
101583: CALL_OW 12
101587: ARRAY
101588: PPUSH
101589: LD_INT 1
101591: PPUSH
101592: CALL_OW 234
// end ;
101596: PPOPN 1
101598: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101599: LD_EXP 96
101603: PUSH
101604: LD_EXP 144
101608: AND
101609: IFFALSE 101721
101611: GO 101613
101613: DISABLE
101614: LD_INT 0
101616: PPUSH
101617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101618: LD_ADDR_VAR 0 2
101622: PUSH
101623: LD_INT 22
101625: PUSH
101626: LD_OWVAR 2
101630: PUSH
101631: EMPTY
101632: LIST
101633: LIST
101634: PUSH
101635: LD_INT 2
101637: PUSH
101638: LD_INT 30
101640: PUSH
101641: LD_INT 27
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: PUSH
101648: LD_INT 30
101650: PUSH
101651: LD_INT 26
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PUSH
101658: LD_INT 30
101660: PUSH
101661: LD_INT 28
101663: PUSH
101664: EMPTY
101665: LIST
101666: LIST
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: PUSH
101674: EMPTY
101675: LIST
101676: LIST
101677: PPUSH
101678: CALL_OW 69
101682: ST_TO_ADDR
// if not tmp then
101683: LD_VAR 0 2
101687: NOT
101688: IFFALSE 101692
// exit ;
101690: GO 101721
// for i in tmp do
101692: LD_ADDR_VAR 0 1
101696: PUSH
101697: LD_VAR 0 2
101701: PUSH
101702: FOR_IN
101703: IFFALSE 101719
// SetLives ( i , 1 ) ;
101705: LD_VAR 0 1
101709: PPUSH
101710: LD_INT 1
101712: PPUSH
101713: CALL_OW 234
101717: GO 101702
101719: POP
101720: POP
// end ;
101721: PPOPN 2
101723: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101724: LD_EXP 96
101728: PUSH
101729: LD_EXP 145
101733: AND
101734: IFFALSE 102021
101736: GO 101738
101738: DISABLE
101739: LD_INT 0
101741: PPUSH
101742: PPUSH
101743: PPUSH
// begin i := rand ( 1 , 7 ) ;
101744: LD_ADDR_VAR 0 1
101748: PUSH
101749: LD_INT 1
101751: PPUSH
101752: LD_INT 7
101754: PPUSH
101755: CALL_OW 12
101759: ST_TO_ADDR
// case i of 1 :
101760: LD_VAR 0 1
101764: PUSH
101765: LD_INT 1
101767: DOUBLE
101768: EQUAL
101769: IFTRUE 101773
101771: GO 101783
101773: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101774: LD_STRING earthquake(getX(game), 0, 32)
101776: PPUSH
101777: CALL_OW 559
101781: GO 102021
101783: LD_INT 2
101785: DOUBLE
101786: EQUAL
101787: IFTRUE 101791
101789: GO 101805
101791: POP
// begin ToLua ( displayStucuk(); ) ;
101792: LD_STRING displayStucuk();
101794: PPUSH
101795: CALL_OW 559
// ResetFog ;
101799: CALL_OW 335
// end ; 3 :
101803: GO 102021
101805: LD_INT 3
101807: DOUBLE
101808: EQUAL
101809: IFTRUE 101813
101811: GO 101917
101813: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101814: LD_ADDR_VAR 0 2
101818: PUSH
101819: LD_INT 22
101821: PUSH
101822: LD_OWVAR 2
101826: PUSH
101827: EMPTY
101828: LIST
101829: LIST
101830: PUSH
101831: LD_INT 25
101833: PUSH
101834: LD_INT 1
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: PUSH
101841: EMPTY
101842: LIST
101843: LIST
101844: PPUSH
101845: CALL_OW 69
101849: ST_TO_ADDR
// if not tmp then
101850: LD_VAR 0 2
101854: NOT
101855: IFFALSE 101859
// exit ;
101857: GO 102021
// un := tmp [ rand ( 1 , tmp ) ] ;
101859: LD_ADDR_VAR 0 3
101863: PUSH
101864: LD_VAR 0 2
101868: PUSH
101869: LD_INT 1
101871: PPUSH
101872: LD_VAR 0 2
101876: PPUSH
101877: CALL_OW 12
101881: ARRAY
101882: ST_TO_ADDR
// if Crawls ( un ) then
101883: LD_VAR 0 3
101887: PPUSH
101888: CALL_OW 318
101892: IFFALSE 101903
// ComWalk ( un ) ;
101894: LD_VAR 0 3
101898: PPUSH
101899: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101903: LD_VAR 0 3
101907: PPUSH
101908: LD_INT 8
101910: PPUSH
101911: CALL_OW 336
// end ; 4 :
101915: GO 102021
101917: LD_INT 4
101919: DOUBLE
101920: EQUAL
101921: IFTRUE 101925
101923: GO 101999
101925: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101926: LD_ADDR_VAR 0 2
101930: PUSH
101931: LD_INT 22
101933: PUSH
101934: LD_OWVAR 2
101938: PUSH
101939: EMPTY
101940: LIST
101941: LIST
101942: PUSH
101943: LD_INT 30
101945: PUSH
101946: LD_INT 29
101948: PUSH
101949: EMPTY
101950: LIST
101951: LIST
101952: PUSH
101953: EMPTY
101954: LIST
101955: LIST
101956: PPUSH
101957: CALL_OW 69
101961: ST_TO_ADDR
// if not tmp then
101962: LD_VAR 0 2
101966: NOT
101967: IFFALSE 101971
// exit ;
101969: GO 102021
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101971: LD_VAR 0 2
101975: PUSH
101976: LD_INT 1
101978: ARRAY
101979: PPUSH
101980: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101984: LD_VAR 0 2
101988: PUSH
101989: LD_INT 1
101991: ARRAY
101992: PPUSH
101993: CALL_OW 65
// end ; 5 .. 7 :
101997: GO 102021
101999: LD_INT 5
102001: DOUBLE
102002: GREATEREQUAL
102003: IFFALSE 102011
102005: LD_INT 7
102007: DOUBLE
102008: LESSEQUAL
102009: IFTRUE 102013
102011: GO 102020
102013: POP
// StreamSibBomb ; end ;
102014: CALL 98258 0 0
102018: GO 102021
102020: POP
// end ;
102021: PPOPN 3
102023: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102024: LD_EXP 96
102028: PUSH
102029: LD_EXP 146
102033: AND
102034: IFFALSE 102190
102036: GO 102038
102038: DISABLE
102039: LD_INT 0
102041: PPUSH
102042: PPUSH
102043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102044: LD_ADDR_VAR 0 2
102048: PUSH
102049: LD_INT 81
102051: PUSH
102052: LD_OWVAR 2
102056: PUSH
102057: EMPTY
102058: LIST
102059: LIST
102060: PUSH
102061: LD_INT 2
102063: PUSH
102064: LD_INT 21
102066: PUSH
102067: LD_INT 1
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: PUSH
102074: LD_INT 21
102076: PUSH
102077: LD_INT 2
102079: PUSH
102080: EMPTY
102081: LIST
102082: LIST
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: LIST
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: PPUSH
102093: CALL_OW 69
102097: ST_TO_ADDR
// if not tmp then
102098: LD_VAR 0 2
102102: NOT
102103: IFFALSE 102107
// exit ;
102105: GO 102190
// p := 0 ;
102107: LD_ADDR_VAR 0 3
102111: PUSH
102112: LD_INT 0
102114: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102115: LD_INT 35
102117: PPUSH
102118: CALL_OW 67
// p := p + 1 ;
102122: LD_ADDR_VAR 0 3
102126: PUSH
102127: LD_VAR 0 3
102131: PUSH
102132: LD_INT 1
102134: PLUS
102135: ST_TO_ADDR
// for i in tmp do
102136: LD_ADDR_VAR 0 1
102140: PUSH
102141: LD_VAR 0 2
102145: PUSH
102146: FOR_IN
102147: IFFALSE 102178
// if GetLives ( i ) < 1000 then
102149: LD_VAR 0 1
102153: PPUSH
102154: CALL_OW 256
102158: PUSH
102159: LD_INT 1000
102161: LESS
102162: IFFALSE 102176
// SetLives ( i , 1000 ) ;
102164: LD_VAR 0 1
102168: PPUSH
102169: LD_INT 1000
102171: PPUSH
102172: CALL_OW 234
102176: GO 102146
102178: POP
102179: POP
// until p > 20 ;
102180: LD_VAR 0 3
102184: PUSH
102185: LD_INT 20
102187: GREATER
102188: IFFALSE 102115
// end ;
102190: PPOPN 3
102192: END
// every 0 0$1 trigger StreamModeActive and sTime do
102193: LD_EXP 96
102197: PUSH
102198: LD_EXP 147
102202: AND
102203: IFFALSE 102238
102205: GO 102207
102207: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102208: LD_INT 28
102210: PPUSH
102211: LD_OWVAR 2
102215: PPUSH
102216: LD_INT 2
102218: PPUSH
102219: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102223: LD_INT 30
102225: PPUSH
102226: LD_OWVAR 2
102230: PPUSH
102231: LD_INT 2
102233: PPUSH
102234: CALL_OW 322
// end ;
102238: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102239: LD_EXP 96
102243: PUSH
102244: LD_EXP 148
102248: AND
102249: IFFALSE 102370
102251: GO 102253
102253: DISABLE
102254: LD_INT 0
102256: PPUSH
102257: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102258: LD_ADDR_VAR 0 2
102262: PUSH
102263: LD_INT 22
102265: PUSH
102266: LD_OWVAR 2
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PUSH
102275: LD_INT 21
102277: PUSH
102278: LD_INT 1
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PUSH
102285: LD_INT 3
102287: PUSH
102288: LD_INT 23
102290: PUSH
102291: LD_INT 0
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: PUSH
102302: EMPTY
102303: LIST
102304: LIST
102305: LIST
102306: PPUSH
102307: CALL_OW 69
102311: ST_TO_ADDR
// if not tmp then
102312: LD_VAR 0 2
102316: NOT
102317: IFFALSE 102321
// exit ;
102319: GO 102370
// for i in tmp do
102321: LD_ADDR_VAR 0 1
102325: PUSH
102326: LD_VAR 0 2
102330: PUSH
102331: FOR_IN
102332: IFFALSE 102368
// begin if Crawls ( i ) then
102334: LD_VAR 0 1
102338: PPUSH
102339: CALL_OW 318
102343: IFFALSE 102354
// ComWalk ( i ) ;
102345: LD_VAR 0 1
102349: PPUSH
102350: CALL_OW 138
// SetClass ( i , 2 ) ;
102354: LD_VAR 0 1
102358: PPUSH
102359: LD_INT 2
102361: PPUSH
102362: CALL_OW 336
// end ;
102366: GO 102331
102368: POP
102369: POP
// end ;
102370: PPOPN 2
102372: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102373: LD_EXP 96
102377: PUSH
102378: LD_EXP 149
102382: AND
102383: IFFALSE 102671
102385: GO 102387
102387: DISABLE
102388: LD_INT 0
102390: PPUSH
102391: PPUSH
102392: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102393: LD_OWVAR 2
102397: PPUSH
102398: LD_INT 9
102400: PPUSH
102401: LD_INT 1
102403: PPUSH
102404: LD_INT 1
102406: PPUSH
102407: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102411: LD_INT 9
102413: PPUSH
102414: LD_OWVAR 2
102418: PPUSH
102419: CALL_OW 343
// uc_side := 9 ;
102423: LD_ADDR_OWVAR 20
102427: PUSH
102428: LD_INT 9
102430: ST_TO_ADDR
// uc_nation := 2 ;
102431: LD_ADDR_OWVAR 21
102435: PUSH
102436: LD_INT 2
102438: ST_TO_ADDR
// hc_name := Dark Warrior ;
102439: LD_ADDR_OWVAR 26
102443: PUSH
102444: LD_STRING Dark Warrior
102446: ST_TO_ADDR
// hc_gallery :=  ;
102447: LD_ADDR_OWVAR 33
102451: PUSH
102452: LD_STRING 
102454: ST_TO_ADDR
// hc_noskilllimit := true ;
102455: LD_ADDR_OWVAR 76
102459: PUSH
102460: LD_INT 1
102462: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102463: LD_ADDR_OWVAR 31
102467: PUSH
102468: LD_INT 30
102470: PUSH
102471: LD_INT 30
102473: PUSH
102474: LD_INT 30
102476: PUSH
102477: LD_INT 30
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: LIST
102484: LIST
102485: ST_TO_ADDR
// un := CreateHuman ;
102486: LD_ADDR_VAR 0 3
102490: PUSH
102491: CALL_OW 44
102495: ST_TO_ADDR
// hc_noskilllimit := false ;
102496: LD_ADDR_OWVAR 76
102500: PUSH
102501: LD_INT 0
102503: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102504: LD_VAR 0 3
102508: PPUSH
102509: LD_INT 1
102511: PPUSH
102512: CALL_OW 51
// ToLua ( playRanger() ) ;
102516: LD_STRING playRanger()
102518: PPUSH
102519: CALL_OW 559
// p := 0 ;
102523: LD_ADDR_VAR 0 2
102527: PUSH
102528: LD_INT 0
102530: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102531: LD_INT 35
102533: PPUSH
102534: CALL_OW 67
// p := p + 1 ;
102538: LD_ADDR_VAR 0 2
102542: PUSH
102543: LD_VAR 0 2
102547: PUSH
102548: LD_INT 1
102550: PLUS
102551: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102552: LD_VAR 0 3
102556: PPUSH
102557: CALL_OW 256
102561: PUSH
102562: LD_INT 1000
102564: LESS
102565: IFFALSE 102579
// SetLives ( un , 1000 ) ;
102567: LD_VAR 0 3
102571: PPUSH
102572: LD_INT 1000
102574: PPUSH
102575: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102579: LD_VAR 0 3
102583: PPUSH
102584: LD_INT 81
102586: PUSH
102587: LD_OWVAR 2
102591: PUSH
102592: EMPTY
102593: LIST
102594: LIST
102595: PUSH
102596: LD_INT 91
102598: PUSH
102599: LD_VAR 0 3
102603: PUSH
102604: LD_INT 30
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: LIST
102611: PUSH
102612: EMPTY
102613: LIST
102614: LIST
102615: PPUSH
102616: CALL_OW 69
102620: PPUSH
102621: LD_VAR 0 3
102625: PPUSH
102626: CALL_OW 74
102630: PPUSH
102631: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102635: LD_VAR 0 2
102639: PUSH
102640: LD_INT 80
102642: GREATER
102643: PUSH
102644: LD_VAR 0 3
102648: PPUSH
102649: CALL_OW 301
102653: OR
102654: IFFALSE 102531
// if un then
102656: LD_VAR 0 3
102660: IFFALSE 102671
// RemoveUnit ( un ) ;
102662: LD_VAR 0 3
102666: PPUSH
102667: CALL_OW 64
// end ;
102671: PPOPN 3
102673: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102674: LD_EXP 150
102678: IFFALSE 102794
102680: GO 102682
102682: DISABLE
102683: LD_INT 0
102685: PPUSH
102686: PPUSH
102687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102688: LD_ADDR_VAR 0 2
102692: PUSH
102693: LD_INT 81
102695: PUSH
102696: LD_OWVAR 2
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: PUSH
102705: LD_INT 21
102707: PUSH
102708: LD_INT 1
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PUSH
102715: EMPTY
102716: LIST
102717: LIST
102718: PPUSH
102719: CALL_OW 69
102723: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102724: LD_STRING playComputer()
102726: PPUSH
102727: CALL_OW 559
// if not tmp then
102731: LD_VAR 0 2
102735: NOT
102736: IFFALSE 102740
// exit ;
102738: GO 102794
// for i in tmp do
102740: LD_ADDR_VAR 0 1
102744: PUSH
102745: LD_VAR 0 2
102749: PUSH
102750: FOR_IN
102751: IFFALSE 102792
// for j := 1 to 4 do
102753: LD_ADDR_VAR 0 3
102757: PUSH
102758: DOUBLE
102759: LD_INT 1
102761: DEC
102762: ST_TO_ADDR
102763: LD_INT 4
102765: PUSH
102766: FOR_TO
102767: IFFALSE 102788
// SetSkill ( i , j , 10 ) ;
102769: LD_VAR 0 1
102773: PPUSH
102774: LD_VAR 0 3
102778: PPUSH
102779: LD_INT 10
102781: PPUSH
102782: CALL_OW 237
102786: GO 102766
102788: POP
102789: POP
102790: GO 102750
102792: POP
102793: POP
// end ;
102794: PPOPN 3
102796: END
// every 0 0$1 trigger s30 do var i , tmp ;
102797: LD_EXP 151
102801: IFFALSE 102870
102803: GO 102805
102805: DISABLE
102806: LD_INT 0
102808: PPUSH
102809: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102810: LD_ADDR_VAR 0 2
102814: PUSH
102815: LD_INT 22
102817: PUSH
102818: LD_OWVAR 2
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: PPUSH
102827: CALL_OW 69
102831: ST_TO_ADDR
// if not tmp then
102832: LD_VAR 0 2
102836: NOT
102837: IFFALSE 102841
// exit ;
102839: GO 102870
// for i in tmp do
102841: LD_ADDR_VAR 0 1
102845: PUSH
102846: LD_VAR 0 2
102850: PUSH
102851: FOR_IN
102852: IFFALSE 102868
// SetLives ( i , 300 ) ;
102854: LD_VAR 0 1
102858: PPUSH
102859: LD_INT 300
102861: PPUSH
102862: CALL_OW 234
102866: GO 102851
102868: POP
102869: POP
// end ;
102870: PPOPN 2
102872: END
// every 0 0$1 trigger s60 do var i , tmp ;
102873: LD_EXP 152
102877: IFFALSE 102946
102879: GO 102881
102881: DISABLE
102882: LD_INT 0
102884: PPUSH
102885: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102886: LD_ADDR_VAR 0 2
102890: PUSH
102891: LD_INT 22
102893: PUSH
102894: LD_OWVAR 2
102898: PUSH
102899: EMPTY
102900: LIST
102901: LIST
102902: PPUSH
102903: CALL_OW 69
102907: ST_TO_ADDR
// if not tmp then
102908: LD_VAR 0 2
102912: NOT
102913: IFFALSE 102917
// exit ;
102915: GO 102946
// for i in tmp do
102917: LD_ADDR_VAR 0 1
102921: PUSH
102922: LD_VAR 0 2
102926: PUSH
102927: FOR_IN
102928: IFFALSE 102944
// SetLives ( i , 600 ) ;
102930: LD_VAR 0 1
102934: PPUSH
102935: LD_INT 600
102937: PPUSH
102938: CALL_OW 234
102942: GO 102927
102944: POP
102945: POP
// end ;
102946: PPOPN 2
102948: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102949: LD_INT 0
102951: PPUSH
// case cmd of 301 :
102952: LD_VAR 0 1
102956: PUSH
102957: LD_INT 301
102959: DOUBLE
102960: EQUAL
102961: IFTRUE 102965
102963: GO 102997
102965: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102966: LD_VAR 0 6
102970: PPUSH
102971: LD_VAR 0 7
102975: PPUSH
102976: LD_VAR 0 8
102980: PPUSH
102981: LD_VAR 0 4
102985: PPUSH
102986: LD_VAR 0 5
102990: PPUSH
102991: CALL 104198 0 5
102995: GO 103118
102997: LD_INT 302
102999: DOUBLE
103000: EQUAL
103001: IFTRUE 103005
103003: GO 103042
103005: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103006: LD_VAR 0 6
103010: PPUSH
103011: LD_VAR 0 7
103015: PPUSH
103016: LD_VAR 0 8
103020: PPUSH
103021: LD_VAR 0 9
103025: PPUSH
103026: LD_VAR 0 4
103030: PPUSH
103031: LD_VAR 0 5
103035: PPUSH
103036: CALL 104289 0 6
103040: GO 103118
103042: LD_INT 303
103044: DOUBLE
103045: EQUAL
103046: IFTRUE 103050
103048: GO 103087
103050: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103051: LD_VAR 0 6
103055: PPUSH
103056: LD_VAR 0 7
103060: PPUSH
103061: LD_VAR 0 8
103065: PPUSH
103066: LD_VAR 0 9
103070: PPUSH
103071: LD_VAR 0 4
103075: PPUSH
103076: LD_VAR 0 5
103080: PPUSH
103081: CALL 103123 0 6
103085: GO 103118
103087: LD_INT 304
103089: DOUBLE
103090: EQUAL
103091: IFTRUE 103095
103093: GO 103117
103095: POP
// hHackTeleport ( unit , x , y ) ; end ;
103096: LD_VAR 0 2
103100: PPUSH
103101: LD_VAR 0 4
103105: PPUSH
103106: LD_VAR 0 5
103110: PPUSH
103111: CALL 104882 0 3
103115: GO 103118
103117: POP
// end ;
103118: LD_VAR 0 12
103122: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103123: LD_INT 0
103125: PPUSH
103126: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103127: LD_VAR 0 1
103131: PUSH
103132: LD_INT 1
103134: LESS
103135: PUSH
103136: LD_VAR 0 1
103140: PUSH
103141: LD_INT 3
103143: GREATER
103144: OR
103145: PUSH
103146: LD_VAR 0 5
103150: PPUSH
103151: LD_VAR 0 6
103155: PPUSH
103156: CALL_OW 428
103160: OR
103161: IFFALSE 103165
// exit ;
103163: GO 103885
// uc_side := your_side ;
103165: LD_ADDR_OWVAR 20
103169: PUSH
103170: LD_OWVAR 2
103174: ST_TO_ADDR
// uc_nation := nation ;
103175: LD_ADDR_OWVAR 21
103179: PUSH
103180: LD_VAR 0 1
103184: ST_TO_ADDR
// bc_level = 1 ;
103185: LD_ADDR_OWVAR 43
103189: PUSH
103190: LD_INT 1
103192: ST_TO_ADDR
// case btype of 1 :
103193: LD_VAR 0 2
103197: PUSH
103198: LD_INT 1
103200: DOUBLE
103201: EQUAL
103202: IFTRUE 103206
103204: GO 103217
103206: POP
// bc_type := b_depot ; 2 :
103207: LD_ADDR_OWVAR 42
103211: PUSH
103212: LD_INT 0
103214: ST_TO_ADDR
103215: GO 103829
103217: LD_INT 2
103219: DOUBLE
103220: EQUAL
103221: IFTRUE 103225
103223: GO 103236
103225: POP
// bc_type := b_warehouse ; 3 :
103226: LD_ADDR_OWVAR 42
103230: PUSH
103231: LD_INT 1
103233: ST_TO_ADDR
103234: GO 103829
103236: LD_INT 3
103238: DOUBLE
103239: EQUAL
103240: IFTRUE 103244
103242: GO 103255
103244: POP
// bc_type := b_lab ; 4 .. 9 :
103245: LD_ADDR_OWVAR 42
103249: PUSH
103250: LD_INT 6
103252: ST_TO_ADDR
103253: GO 103829
103255: LD_INT 4
103257: DOUBLE
103258: GREATEREQUAL
103259: IFFALSE 103267
103261: LD_INT 9
103263: DOUBLE
103264: LESSEQUAL
103265: IFTRUE 103269
103267: GO 103321
103269: POP
// begin bc_type := b_lab_half ;
103270: LD_ADDR_OWVAR 42
103274: PUSH
103275: LD_INT 7
103277: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103278: LD_ADDR_OWVAR 44
103282: PUSH
103283: LD_INT 10
103285: PUSH
103286: LD_INT 11
103288: PUSH
103289: LD_INT 12
103291: PUSH
103292: LD_INT 15
103294: PUSH
103295: LD_INT 14
103297: PUSH
103298: LD_INT 13
103300: PUSH
103301: EMPTY
103302: LIST
103303: LIST
103304: LIST
103305: LIST
103306: LIST
103307: LIST
103308: PUSH
103309: LD_VAR 0 2
103313: PUSH
103314: LD_INT 3
103316: MINUS
103317: ARRAY
103318: ST_TO_ADDR
// end ; 10 .. 13 :
103319: GO 103829
103321: LD_INT 10
103323: DOUBLE
103324: GREATEREQUAL
103325: IFFALSE 103333
103327: LD_INT 13
103329: DOUBLE
103330: LESSEQUAL
103331: IFTRUE 103335
103333: GO 103412
103335: POP
// begin bc_type := b_lab_full ;
103336: LD_ADDR_OWVAR 42
103340: PUSH
103341: LD_INT 8
103343: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103344: LD_ADDR_OWVAR 44
103348: PUSH
103349: LD_INT 10
103351: PUSH
103352: LD_INT 12
103354: PUSH
103355: LD_INT 14
103357: PUSH
103358: LD_INT 13
103360: PUSH
103361: EMPTY
103362: LIST
103363: LIST
103364: LIST
103365: LIST
103366: PUSH
103367: LD_VAR 0 2
103371: PUSH
103372: LD_INT 9
103374: MINUS
103375: ARRAY
103376: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103377: LD_ADDR_OWVAR 45
103381: PUSH
103382: LD_INT 11
103384: PUSH
103385: LD_INT 15
103387: PUSH
103388: LD_INT 12
103390: PUSH
103391: LD_INT 15
103393: PUSH
103394: EMPTY
103395: LIST
103396: LIST
103397: LIST
103398: LIST
103399: PUSH
103400: LD_VAR 0 2
103404: PUSH
103405: LD_INT 9
103407: MINUS
103408: ARRAY
103409: ST_TO_ADDR
// end ; 14 :
103410: GO 103829
103412: LD_INT 14
103414: DOUBLE
103415: EQUAL
103416: IFTRUE 103420
103418: GO 103431
103420: POP
// bc_type := b_workshop ; 15 :
103421: LD_ADDR_OWVAR 42
103425: PUSH
103426: LD_INT 2
103428: ST_TO_ADDR
103429: GO 103829
103431: LD_INT 15
103433: DOUBLE
103434: EQUAL
103435: IFTRUE 103439
103437: GO 103450
103439: POP
// bc_type := b_factory ; 16 :
103440: LD_ADDR_OWVAR 42
103444: PUSH
103445: LD_INT 3
103447: ST_TO_ADDR
103448: GO 103829
103450: LD_INT 16
103452: DOUBLE
103453: EQUAL
103454: IFTRUE 103458
103456: GO 103469
103458: POP
// bc_type := b_ext_gun ; 17 :
103459: LD_ADDR_OWVAR 42
103463: PUSH
103464: LD_INT 17
103466: ST_TO_ADDR
103467: GO 103829
103469: LD_INT 17
103471: DOUBLE
103472: EQUAL
103473: IFTRUE 103477
103475: GO 103505
103477: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103478: LD_ADDR_OWVAR 42
103482: PUSH
103483: LD_INT 19
103485: PUSH
103486: LD_INT 23
103488: PUSH
103489: LD_INT 19
103491: PUSH
103492: EMPTY
103493: LIST
103494: LIST
103495: LIST
103496: PUSH
103497: LD_VAR 0 1
103501: ARRAY
103502: ST_TO_ADDR
103503: GO 103829
103505: LD_INT 18
103507: DOUBLE
103508: EQUAL
103509: IFTRUE 103513
103511: GO 103524
103513: POP
// bc_type := b_ext_radar ; 19 :
103514: LD_ADDR_OWVAR 42
103518: PUSH
103519: LD_INT 20
103521: ST_TO_ADDR
103522: GO 103829
103524: LD_INT 19
103526: DOUBLE
103527: EQUAL
103528: IFTRUE 103532
103530: GO 103543
103532: POP
// bc_type := b_ext_radio ; 20 :
103533: LD_ADDR_OWVAR 42
103537: PUSH
103538: LD_INT 22
103540: ST_TO_ADDR
103541: GO 103829
103543: LD_INT 20
103545: DOUBLE
103546: EQUAL
103547: IFTRUE 103551
103549: GO 103562
103551: POP
// bc_type := b_ext_siberium ; 21 :
103552: LD_ADDR_OWVAR 42
103556: PUSH
103557: LD_INT 21
103559: ST_TO_ADDR
103560: GO 103829
103562: LD_INT 21
103564: DOUBLE
103565: EQUAL
103566: IFTRUE 103570
103568: GO 103581
103570: POP
// bc_type := b_ext_computer ; 22 :
103571: LD_ADDR_OWVAR 42
103575: PUSH
103576: LD_INT 24
103578: ST_TO_ADDR
103579: GO 103829
103581: LD_INT 22
103583: DOUBLE
103584: EQUAL
103585: IFTRUE 103589
103587: GO 103600
103589: POP
// bc_type := b_ext_track ; 23 :
103590: LD_ADDR_OWVAR 42
103594: PUSH
103595: LD_INT 16
103597: ST_TO_ADDR
103598: GO 103829
103600: LD_INT 23
103602: DOUBLE
103603: EQUAL
103604: IFTRUE 103608
103606: GO 103619
103608: POP
// bc_type := b_ext_laser ; 24 :
103609: LD_ADDR_OWVAR 42
103613: PUSH
103614: LD_INT 25
103616: ST_TO_ADDR
103617: GO 103829
103619: LD_INT 24
103621: DOUBLE
103622: EQUAL
103623: IFTRUE 103627
103625: GO 103638
103627: POP
// bc_type := b_control_tower ; 25 :
103628: LD_ADDR_OWVAR 42
103632: PUSH
103633: LD_INT 36
103635: ST_TO_ADDR
103636: GO 103829
103638: LD_INT 25
103640: DOUBLE
103641: EQUAL
103642: IFTRUE 103646
103644: GO 103657
103646: POP
// bc_type := b_breastwork ; 26 :
103647: LD_ADDR_OWVAR 42
103651: PUSH
103652: LD_INT 31
103654: ST_TO_ADDR
103655: GO 103829
103657: LD_INT 26
103659: DOUBLE
103660: EQUAL
103661: IFTRUE 103665
103663: GO 103676
103665: POP
// bc_type := b_bunker ; 27 :
103666: LD_ADDR_OWVAR 42
103670: PUSH
103671: LD_INT 32
103673: ST_TO_ADDR
103674: GO 103829
103676: LD_INT 27
103678: DOUBLE
103679: EQUAL
103680: IFTRUE 103684
103682: GO 103695
103684: POP
// bc_type := b_turret ; 28 :
103685: LD_ADDR_OWVAR 42
103689: PUSH
103690: LD_INT 33
103692: ST_TO_ADDR
103693: GO 103829
103695: LD_INT 28
103697: DOUBLE
103698: EQUAL
103699: IFTRUE 103703
103701: GO 103714
103703: POP
// bc_type := b_armoury ; 29 :
103704: LD_ADDR_OWVAR 42
103708: PUSH
103709: LD_INT 4
103711: ST_TO_ADDR
103712: GO 103829
103714: LD_INT 29
103716: DOUBLE
103717: EQUAL
103718: IFTRUE 103722
103720: GO 103733
103722: POP
// bc_type := b_barracks ; 30 :
103723: LD_ADDR_OWVAR 42
103727: PUSH
103728: LD_INT 5
103730: ST_TO_ADDR
103731: GO 103829
103733: LD_INT 30
103735: DOUBLE
103736: EQUAL
103737: IFTRUE 103741
103739: GO 103752
103741: POP
// bc_type := b_solar_power ; 31 :
103742: LD_ADDR_OWVAR 42
103746: PUSH
103747: LD_INT 27
103749: ST_TO_ADDR
103750: GO 103829
103752: LD_INT 31
103754: DOUBLE
103755: EQUAL
103756: IFTRUE 103760
103758: GO 103771
103760: POP
// bc_type := b_oil_power ; 32 :
103761: LD_ADDR_OWVAR 42
103765: PUSH
103766: LD_INT 26
103768: ST_TO_ADDR
103769: GO 103829
103771: LD_INT 32
103773: DOUBLE
103774: EQUAL
103775: IFTRUE 103779
103777: GO 103790
103779: POP
// bc_type := b_siberite_power ; 33 :
103780: LD_ADDR_OWVAR 42
103784: PUSH
103785: LD_INT 28
103787: ST_TO_ADDR
103788: GO 103829
103790: LD_INT 33
103792: DOUBLE
103793: EQUAL
103794: IFTRUE 103798
103796: GO 103809
103798: POP
// bc_type := b_oil_mine ; 34 :
103799: LD_ADDR_OWVAR 42
103803: PUSH
103804: LD_INT 29
103806: ST_TO_ADDR
103807: GO 103829
103809: LD_INT 34
103811: DOUBLE
103812: EQUAL
103813: IFTRUE 103817
103815: GO 103828
103817: POP
// bc_type := b_siberite_mine ; end ;
103818: LD_ADDR_OWVAR 42
103822: PUSH
103823: LD_INT 30
103825: ST_TO_ADDR
103826: GO 103829
103828: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103829: LD_ADDR_VAR 0 8
103833: PUSH
103834: LD_VAR 0 5
103838: PPUSH
103839: LD_VAR 0 6
103843: PPUSH
103844: LD_VAR 0 3
103848: PPUSH
103849: CALL_OW 47
103853: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103854: LD_OWVAR 42
103858: PUSH
103859: LD_INT 32
103861: PUSH
103862: LD_INT 33
103864: PUSH
103865: EMPTY
103866: LIST
103867: LIST
103868: IN
103869: IFFALSE 103885
// PlaceWeaponTurret ( b , weapon ) ;
103871: LD_VAR 0 8
103875: PPUSH
103876: LD_VAR 0 4
103880: PPUSH
103881: CALL_OW 431
// end ;
103885: LD_VAR 0 7
103889: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103890: LD_INT 0
103892: PPUSH
103893: PPUSH
103894: PPUSH
103895: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103896: LD_ADDR_VAR 0 4
103900: PUSH
103901: LD_INT 22
103903: PUSH
103904: LD_OWVAR 2
103908: PUSH
103909: EMPTY
103910: LIST
103911: LIST
103912: PUSH
103913: LD_INT 2
103915: PUSH
103916: LD_INT 30
103918: PUSH
103919: LD_INT 0
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: PUSH
103926: LD_INT 30
103928: PUSH
103929: LD_INT 1
103931: PUSH
103932: EMPTY
103933: LIST
103934: LIST
103935: PUSH
103936: EMPTY
103937: LIST
103938: LIST
103939: LIST
103940: PUSH
103941: EMPTY
103942: LIST
103943: LIST
103944: PPUSH
103945: CALL_OW 69
103949: ST_TO_ADDR
// if not tmp then
103950: LD_VAR 0 4
103954: NOT
103955: IFFALSE 103959
// exit ;
103957: GO 104018
// for i in tmp do
103959: LD_ADDR_VAR 0 2
103963: PUSH
103964: LD_VAR 0 4
103968: PUSH
103969: FOR_IN
103970: IFFALSE 104016
// for j = 1 to 3 do
103972: LD_ADDR_VAR 0 3
103976: PUSH
103977: DOUBLE
103978: LD_INT 1
103980: DEC
103981: ST_TO_ADDR
103982: LD_INT 3
103984: PUSH
103985: FOR_TO
103986: IFFALSE 104012
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103988: LD_VAR 0 2
103992: PPUSH
103993: CALL_OW 274
103997: PPUSH
103998: LD_VAR 0 3
104002: PPUSH
104003: LD_INT 99999
104005: PPUSH
104006: CALL_OW 277
104010: GO 103985
104012: POP
104013: POP
104014: GO 103969
104016: POP
104017: POP
// end ;
104018: LD_VAR 0 1
104022: RET
// export function hHackSetLevel10 ; var i , j ; begin
104023: LD_INT 0
104025: PPUSH
104026: PPUSH
104027: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104028: LD_ADDR_VAR 0 2
104032: PUSH
104033: LD_INT 21
104035: PUSH
104036: LD_INT 1
104038: PUSH
104039: EMPTY
104040: LIST
104041: LIST
104042: PPUSH
104043: CALL_OW 69
104047: PUSH
104048: FOR_IN
104049: IFFALSE 104101
// if IsSelected ( i ) then
104051: LD_VAR 0 2
104055: PPUSH
104056: CALL_OW 306
104060: IFFALSE 104099
// begin for j := 1 to 4 do
104062: LD_ADDR_VAR 0 3
104066: PUSH
104067: DOUBLE
104068: LD_INT 1
104070: DEC
104071: ST_TO_ADDR
104072: LD_INT 4
104074: PUSH
104075: FOR_TO
104076: IFFALSE 104097
// SetSkill ( i , j , 10 ) ;
104078: LD_VAR 0 2
104082: PPUSH
104083: LD_VAR 0 3
104087: PPUSH
104088: LD_INT 10
104090: PPUSH
104091: CALL_OW 237
104095: GO 104075
104097: POP
104098: POP
// end ;
104099: GO 104048
104101: POP
104102: POP
// end ;
104103: LD_VAR 0 1
104107: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104108: LD_INT 0
104110: PPUSH
104111: PPUSH
104112: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104113: LD_ADDR_VAR 0 2
104117: PUSH
104118: LD_INT 22
104120: PUSH
104121: LD_OWVAR 2
104125: PUSH
104126: EMPTY
104127: LIST
104128: LIST
104129: PUSH
104130: LD_INT 21
104132: PUSH
104133: LD_INT 1
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PUSH
104140: EMPTY
104141: LIST
104142: LIST
104143: PPUSH
104144: CALL_OW 69
104148: PUSH
104149: FOR_IN
104150: IFFALSE 104191
// begin for j := 1 to 4 do
104152: LD_ADDR_VAR 0 3
104156: PUSH
104157: DOUBLE
104158: LD_INT 1
104160: DEC
104161: ST_TO_ADDR
104162: LD_INT 4
104164: PUSH
104165: FOR_TO
104166: IFFALSE 104187
// SetSkill ( i , j , 10 ) ;
104168: LD_VAR 0 2
104172: PPUSH
104173: LD_VAR 0 3
104177: PPUSH
104178: LD_INT 10
104180: PPUSH
104181: CALL_OW 237
104185: GO 104165
104187: POP
104188: POP
// end ;
104189: GO 104149
104191: POP
104192: POP
// end ;
104193: LD_VAR 0 1
104197: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104198: LD_INT 0
104200: PPUSH
// uc_side := your_side ;
104201: LD_ADDR_OWVAR 20
104205: PUSH
104206: LD_OWVAR 2
104210: ST_TO_ADDR
// uc_nation := nation ;
104211: LD_ADDR_OWVAR 21
104215: PUSH
104216: LD_VAR 0 1
104220: ST_TO_ADDR
// InitHc ;
104221: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104225: LD_INT 0
104227: PPUSH
104228: LD_VAR 0 2
104232: PPUSH
104233: LD_VAR 0 3
104237: PPUSH
104238: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104242: LD_VAR 0 4
104246: PPUSH
104247: LD_VAR 0 5
104251: PPUSH
104252: CALL_OW 428
104256: PUSH
104257: LD_INT 0
104259: EQUAL
104260: IFFALSE 104284
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104262: CALL_OW 44
104266: PPUSH
104267: LD_VAR 0 4
104271: PPUSH
104272: LD_VAR 0 5
104276: PPUSH
104277: LD_INT 1
104279: PPUSH
104280: CALL_OW 48
// end ;
104284: LD_VAR 0 6
104288: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104289: LD_INT 0
104291: PPUSH
104292: PPUSH
// uc_side := your_side ;
104293: LD_ADDR_OWVAR 20
104297: PUSH
104298: LD_OWVAR 2
104302: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104303: LD_VAR 0 1
104307: PUSH
104308: LD_INT 1
104310: PUSH
104311: LD_INT 2
104313: PUSH
104314: LD_INT 3
104316: PUSH
104317: LD_INT 4
104319: PUSH
104320: LD_INT 5
104322: PUSH
104323: EMPTY
104324: LIST
104325: LIST
104326: LIST
104327: LIST
104328: LIST
104329: IN
104330: IFFALSE 104342
// uc_nation := nation_american else
104332: LD_ADDR_OWVAR 21
104336: PUSH
104337: LD_INT 1
104339: ST_TO_ADDR
104340: GO 104385
// if chassis in [ 11 , 12 , 13 , 14 ] then
104342: LD_VAR 0 1
104346: PUSH
104347: LD_INT 11
104349: PUSH
104350: LD_INT 12
104352: PUSH
104353: LD_INT 13
104355: PUSH
104356: LD_INT 14
104358: PUSH
104359: EMPTY
104360: LIST
104361: LIST
104362: LIST
104363: LIST
104364: IN
104365: IFFALSE 104377
// uc_nation := nation_arabian else
104367: LD_ADDR_OWVAR 21
104371: PUSH
104372: LD_INT 2
104374: ST_TO_ADDR
104375: GO 104385
// uc_nation := nation_russian ;
104377: LD_ADDR_OWVAR 21
104381: PUSH
104382: LD_INT 3
104384: ST_TO_ADDR
// vc_chassis := chassis ;
104385: LD_ADDR_OWVAR 37
104389: PUSH
104390: LD_VAR 0 1
104394: ST_TO_ADDR
// vc_engine := engine ;
104395: LD_ADDR_OWVAR 39
104399: PUSH
104400: LD_VAR 0 2
104404: ST_TO_ADDR
// vc_control := control ;
104405: LD_ADDR_OWVAR 38
104409: PUSH
104410: LD_VAR 0 3
104414: ST_TO_ADDR
// vc_weapon := weapon ;
104415: LD_ADDR_OWVAR 40
104419: PUSH
104420: LD_VAR 0 4
104424: ST_TO_ADDR
// un := CreateVehicle ;
104425: LD_ADDR_VAR 0 8
104429: PUSH
104430: CALL_OW 45
104434: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104435: LD_VAR 0 8
104439: PPUSH
104440: LD_INT 0
104442: PPUSH
104443: LD_INT 5
104445: PPUSH
104446: CALL_OW 12
104450: PPUSH
104451: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104455: LD_VAR 0 8
104459: PPUSH
104460: LD_VAR 0 5
104464: PPUSH
104465: LD_VAR 0 6
104469: PPUSH
104470: LD_INT 1
104472: PPUSH
104473: CALL_OW 48
// end ;
104477: LD_VAR 0 7
104481: RET
// export hInvincible ; every 1 do
104482: GO 104484
104484: DISABLE
// hInvincible := [ ] ;
104485: LD_ADDR_EXP 153
104489: PUSH
104490: EMPTY
104491: ST_TO_ADDR
104492: END
// every 10 do var i ;
104493: GO 104495
104495: DISABLE
104496: LD_INT 0
104498: PPUSH
// begin enable ;
104499: ENABLE
// if not hInvincible then
104500: LD_EXP 153
104504: NOT
104505: IFFALSE 104509
// exit ;
104507: GO 104553
// for i in hInvincible do
104509: LD_ADDR_VAR 0 1
104513: PUSH
104514: LD_EXP 153
104518: PUSH
104519: FOR_IN
104520: IFFALSE 104551
// if GetLives ( i ) < 1000 then
104522: LD_VAR 0 1
104526: PPUSH
104527: CALL_OW 256
104531: PUSH
104532: LD_INT 1000
104534: LESS
104535: IFFALSE 104549
// SetLives ( i , 1000 ) ;
104537: LD_VAR 0 1
104541: PPUSH
104542: LD_INT 1000
104544: PPUSH
104545: CALL_OW 234
104549: GO 104519
104551: POP
104552: POP
// end ;
104553: PPOPN 1
104555: END
// export function hHackInvincible ; var i ; begin
104556: LD_INT 0
104558: PPUSH
104559: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104560: LD_ADDR_VAR 0 2
104564: PUSH
104565: LD_INT 2
104567: PUSH
104568: LD_INT 21
104570: PUSH
104571: LD_INT 1
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 21
104580: PUSH
104581: LD_INT 2
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: LIST
104592: PPUSH
104593: CALL_OW 69
104597: PUSH
104598: FOR_IN
104599: IFFALSE 104660
// if IsSelected ( i ) then
104601: LD_VAR 0 2
104605: PPUSH
104606: CALL_OW 306
104610: IFFALSE 104658
// begin if i in hInvincible then
104612: LD_VAR 0 2
104616: PUSH
104617: LD_EXP 153
104621: IN
104622: IFFALSE 104642
// hInvincible := hInvincible diff i else
104624: LD_ADDR_EXP 153
104628: PUSH
104629: LD_EXP 153
104633: PUSH
104634: LD_VAR 0 2
104638: DIFF
104639: ST_TO_ADDR
104640: GO 104658
// hInvincible := hInvincible union i ;
104642: LD_ADDR_EXP 153
104646: PUSH
104647: LD_EXP 153
104651: PUSH
104652: LD_VAR 0 2
104656: UNION
104657: ST_TO_ADDR
// end ;
104658: GO 104598
104660: POP
104661: POP
// end ;
104662: LD_VAR 0 1
104666: RET
// export function hHackInvisible ; var i , j ; begin
104667: LD_INT 0
104669: PPUSH
104670: PPUSH
104671: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104672: LD_ADDR_VAR 0 2
104676: PUSH
104677: LD_INT 21
104679: PUSH
104680: LD_INT 1
104682: PUSH
104683: EMPTY
104684: LIST
104685: LIST
104686: PPUSH
104687: CALL_OW 69
104691: PUSH
104692: FOR_IN
104693: IFFALSE 104717
// if IsSelected ( i ) then
104695: LD_VAR 0 2
104699: PPUSH
104700: CALL_OW 306
104704: IFFALSE 104715
// ComForceInvisible ( i ) ;
104706: LD_VAR 0 2
104710: PPUSH
104711: CALL_OW 496
104715: GO 104692
104717: POP
104718: POP
// end ;
104719: LD_VAR 0 1
104723: RET
// export function hHackChangeYourSide ; begin
104724: LD_INT 0
104726: PPUSH
// if your_side = 8 then
104727: LD_OWVAR 2
104731: PUSH
104732: LD_INT 8
104734: EQUAL
104735: IFFALSE 104747
// your_side := 0 else
104737: LD_ADDR_OWVAR 2
104741: PUSH
104742: LD_INT 0
104744: ST_TO_ADDR
104745: GO 104761
// your_side := your_side + 1 ;
104747: LD_ADDR_OWVAR 2
104751: PUSH
104752: LD_OWVAR 2
104756: PUSH
104757: LD_INT 1
104759: PLUS
104760: ST_TO_ADDR
// end ;
104761: LD_VAR 0 1
104765: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104766: LD_INT 0
104768: PPUSH
104769: PPUSH
104770: PPUSH
// for i in all_units do
104771: LD_ADDR_VAR 0 2
104775: PUSH
104776: LD_OWVAR 3
104780: PUSH
104781: FOR_IN
104782: IFFALSE 104860
// if IsSelected ( i ) then
104784: LD_VAR 0 2
104788: PPUSH
104789: CALL_OW 306
104793: IFFALSE 104858
// begin j := GetSide ( i ) ;
104795: LD_ADDR_VAR 0 3
104799: PUSH
104800: LD_VAR 0 2
104804: PPUSH
104805: CALL_OW 255
104809: ST_TO_ADDR
// if j = 8 then
104810: LD_VAR 0 3
104814: PUSH
104815: LD_INT 8
104817: EQUAL
104818: IFFALSE 104830
// j := 0 else
104820: LD_ADDR_VAR 0 3
104824: PUSH
104825: LD_INT 0
104827: ST_TO_ADDR
104828: GO 104844
// j := j + 1 ;
104830: LD_ADDR_VAR 0 3
104834: PUSH
104835: LD_VAR 0 3
104839: PUSH
104840: LD_INT 1
104842: PLUS
104843: ST_TO_ADDR
// SetSide ( i , j ) ;
104844: LD_VAR 0 2
104848: PPUSH
104849: LD_VAR 0 3
104853: PPUSH
104854: CALL_OW 235
// end ;
104858: GO 104781
104860: POP
104861: POP
// end ;
104862: LD_VAR 0 1
104866: RET
// export function hHackFog ; begin
104867: LD_INT 0
104869: PPUSH
// FogOff ( true ) ;
104870: LD_INT 1
104872: PPUSH
104873: CALL_OW 344
// end ;
104877: LD_VAR 0 1
104881: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104882: LD_INT 0
104884: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104885: LD_VAR 0 1
104889: PPUSH
104890: LD_VAR 0 2
104894: PPUSH
104895: LD_VAR 0 3
104899: PPUSH
104900: LD_INT 1
104902: PPUSH
104903: LD_INT 1
104905: PPUSH
104906: CALL_OW 483
// CenterOnXY ( x , y ) ;
104910: LD_VAR 0 2
104914: PPUSH
104915: LD_VAR 0 3
104919: PPUSH
104920: CALL_OW 84
// end ;
104924: LD_VAR 0 4
104928: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104929: LD_INT 0
104931: PPUSH
104932: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104933: LD_VAR 0 1
104937: NOT
104938: PUSH
104939: LD_VAR 0 2
104943: PPUSH
104944: LD_VAR 0 3
104948: PPUSH
104949: CALL_OW 488
104953: NOT
104954: OR
104955: PUSH
104956: LD_VAR 0 1
104960: PPUSH
104961: CALL_OW 266
104965: PUSH
104966: LD_INT 3
104968: NONEQUAL
104969: PUSH
104970: LD_VAR 0 1
104974: PPUSH
104975: CALL_OW 247
104979: PUSH
104980: LD_INT 1
104982: EQUAL
104983: NOT
104984: AND
104985: OR
104986: IFFALSE 104990
// exit ;
104988: GO 105139
// if GetType ( factory ) = unit_human then
104990: LD_VAR 0 1
104994: PPUSH
104995: CALL_OW 247
104999: PUSH
105000: LD_INT 1
105002: EQUAL
105003: IFFALSE 105020
// factory := IsInUnit ( factory ) ;
105005: LD_ADDR_VAR 0 1
105009: PUSH
105010: LD_VAR 0 1
105014: PPUSH
105015: CALL_OW 310
105019: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105020: LD_VAR 0 1
105024: PPUSH
105025: CALL_OW 266
105029: PUSH
105030: LD_INT 3
105032: NONEQUAL
105033: IFFALSE 105037
// exit ;
105035: GO 105139
// if HexInfo ( x , y ) = factory then
105037: LD_VAR 0 2
105041: PPUSH
105042: LD_VAR 0 3
105046: PPUSH
105047: CALL_OW 428
105051: PUSH
105052: LD_VAR 0 1
105056: EQUAL
105057: IFFALSE 105084
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105059: LD_ADDR_EXP 154
105063: PUSH
105064: LD_EXP 154
105068: PPUSH
105069: LD_VAR 0 1
105073: PPUSH
105074: LD_INT 0
105076: PPUSH
105077: CALL_OW 1
105081: ST_TO_ADDR
105082: GO 105135
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105084: LD_ADDR_EXP 154
105088: PUSH
105089: LD_EXP 154
105093: PPUSH
105094: LD_VAR 0 1
105098: PPUSH
105099: LD_VAR 0 1
105103: PPUSH
105104: CALL_OW 255
105108: PUSH
105109: LD_VAR 0 1
105113: PUSH
105114: LD_VAR 0 2
105118: PUSH
105119: LD_VAR 0 3
105123: PUSH
105124: EMPTY
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: PPUSH
105130: CALL_OW 1
105134: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105135: CALL 105144 0 0
// end ;
105139: LD_VAR 0 4
105143: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105144: LD_INT 0
105146: PPUSH
105147: PPUSH
105148: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105149: LD_STRING resetFactoryWaypoint();
105151: PPUSH
105152: CALL_OW 559
// if factoryWaypoints then
105156: LD_EXP 154
105160: IFFALSE 105286
// begin list := PrepareArray ( factoryWaypoints ) ;
105162: LD_ADDR_VAR 0 3
105166: PUSH
105167: LD_EXP 154
105171: PPUSH
105172: CALL 90251 0 1
105176: ST_TO_ADDR
// for i := 1 to list do
105177: LD_ADDR_VAR 0 2
105181: PUSH
105182: DOUBLE
105183: LD_INT 1
105185: DEC
105186: ST_TO_ADDR
105187: LD_VAR 0 3
105191: PUSH
105192: FOR_TO
105193: IFFALSE 105284
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105195: LD_STRING setFactoryWaypointXY(
105197: PUSH
105198: LD_VAR 0 3
105202: PUSH
105203: LD_VAR 0 2
105207: ARRAY
105208: PUSH
105209: LD_INT 1
105211: ARRAY
105212: STR
105213: PUSH
105214: LD_STRING ,
105216: STR
105217: PUSH
105218: LD_VAR 0 3
105222: PUSH
105223: LD_VAR 0 2
105227: ARRAY
105228: PUSH
105229: LD_INT 2
105231: ARRAY
105232: STR
105233: PUSH
105234: LD_STRING ,
105236: STR
105237: PUSH
105238: LD_VAR 0 3
105242: PUSH
105243: LD_VAR 0 2
105247: ARRAY
105248: PUSH
105249: LD_INT 3
105251: ARRAY
105252: STR
105253: PUSH
105254: LD_STRING ,
105256: STR
105257: PUSH
105258: LD_VAR 0 3
105262: PUSH
105263: LD_VAR 0 2
105267: ARRAY
105268: PUSH
105269: LD_INT 4
105271: ARRAY
105272: STR
105273: PUSH
105274: LD_STRING )
105276: STR
105277: PPUSH
105278: CALL_OW 559
105282: GO 105192
105284: POP
105285: POP
// end ; end ;
105286: LD_VAR 0 1
105290: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105291: LD_INT 0
105293: PPUSH
// if HexInfo ( x , y ) = warehouse then
105294: LD_VAR 0 2
105298: PPUSH
105299: LD_VAR 0 3
105303: PPUSH
105304: CALL_OW 428
105308: PUSH
105309: LD_VAR 0 1
105313: EQUAL
105314: IFFALSE 105341
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105316: LD_ADDR_EXP 155
105320: PUSH
105321: LD_EXP 155
105325: PPUSH
105326: LD_VAR 0 1
105330: PPUSH
105331: LD_INT 0
105333: PPUSH
105334: CALL_OW 1
105338: ST_TO_ADDR
105339: GO 105392
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105341: LD_ADDR_EXP 155
105345: PUSH
105346: LD_EXP 155
105350: PPUSH
105351: LD_VAR 0 1
105355: PPUSH
105356: LD_VAR 0 1
105360: PPUSH
105361: CALL_OW 255
105365: PUSH
105366: LD_VAR 0 1
105370: PUSH
105371: LD_VAR 0 2
105375: PUSH
105376: LD_VAR 0 3
105380: PUSH
105381: EMPTY
105382: LIST
105383: LIST
105384: LIST
105385: LIST
105386: PPUSH
105387: CALL_OW 1
105391: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105392: CALL 105401 0 0
// end ;
105396: LD_VAR 0 4
105400: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105401: LD_INT 0
105403: PPUSH
105404: PPUSH
105405: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105406: LD_STRING resetWarehouseGatheringPoints();
105408: PPUSH
105409: CALL_OW 559
// if warehouseGatheringPoints then
105413: LD_EXP 155
105417: IFFALSE 105543
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105419: LD_ADDR_VAR 0 3
105423: PUSH
105424: LD_EXP 155
105428: PPUSH
105429: CALL 90251 0 1
105433: ST_TO_ADDR
// for i := 1 to list do
105434: LD_ADDR_VAR 0 2
105438: PUSH
105439: DOUBLE
105440: LD_INT 1
105442: DEC
105443: ST_TO_ADDR
105444: LD_VAR 0 3
105448: PUSH
105449: FOR_TO
105450: IFFALSE 105541
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105452: LD_STRING setWarehouseGatheringPointXY(
105454: PUSH
105455: LD_VAR 0 3
105459: PUSH
105460: LD_VAR 0 2
105464: ARRAY
105465: PUSH
105466: LD_INT 1
105468: ARRAY
105469: STR
105470: PUSH
105471: LD_STRING ,
105473: STR
105474: PUSH
105475: LD_VAR 0 3
105479: PUSH
105480: LD_VAR 0 2
105484: ARRAY
105485: PUSH
105486: LD_INT 2
105488: ARRAY
105489: STR
105490: PUSH
105491: LD_STRING ,
105493: STR
105494: PUSH
105495: LD_VAR 0 3
105499: PUSH
105500: LD_VAR 0 2
105504: ARRAY
105505: PUSH
105506: LD_INT 3
105508: ARRAY
105509: STR
105510: PUSH
105511: LD_STRING ,
105513: STR
105514: PUSH
105515: LD_VAR 0 3
105519: PUSH
105520: LD_VAR 0 2
105524: ARRAY
105525: PUSH
105526: LD_INT 4
105528: ARRAY
105529: STR
105530: PUSH
105531: LD_STRING )
105533: STR
105534: PPUSH
105535: CALL_OW 559
105539: GO 105449
105541: POP
105542: POP
// end ; end ;
105543: LD_VAR 0 1
105547: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105548: LD_EXP 155
105552: IFFALSE 106237
105554: GO 105556
105556: DISABLE
105557: LD_INT 0
105559: PPUSH
105560: PPUSH
105561: PPUSH
105562: PPUSH
105563: PPUSH
105564: PPUSH
105565: PPUSH
105566: PPUSH
105567: PPUSH
// begin enable ;
105568: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105569: LD_ADDR_VAR 0 3
105573: PUSH
105574: LD_EXP 155
105578: PPUSH
105579: CALL 90251 0 1
105583: ST_TO_ADDR
// if not list then
105584: LD_VAR 0 3
105588: NOT
105589: IFFALSE 105593
// exit ;
105591: GO 106237
// for i := 1 to list do
105593: LD_ADDR_VAR 0 1
105597: PUSH
105598: DOUBLE
105599: LD_INT 1
105601: DEC
105602: ST_TO_ADDR
105603: LD_VAR 0 3
105607: PUSH
105608: FOR_TO
105609: IFFALSE 106235
// begin depot := list [ i ] [ 2 ] ;
105611: LD_ADDR_VAR 0 8
105615: PUSH
105616: LD_VAR 0 3
105620: PUSH
105621: LD_VAR 0 1
105625: ARRAY
105626: PUSH
105627: LD_INT 2
105629: ARRAY
105630: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105631: LD_ADDR_VAR 0 5
105635: PUSH
105636: LD_VAR 0 3
105640: PUSH
105641: LD_VAR 0 1
105645: ARRAY
105646: PUSH
105647: LD_INT 1
105649: ARRAY
105650: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105651: LD_VAR 0 8
105655: PPUSH
105656: CALL_OW 301
105660: PUSH
105661: LD_VAR 0 5
105665: PUSH
105666: LD_VAR 0 8
105670: PPUSH
105671: CALL_OW 255
105675: NONEQUAL
105676: OR
105677: IFFALSE 105706
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105679: LD_ADDR_EXP 155
105683: PUSH
105684: LD_EXP 155
105688: PPUSH
105689: LD_VAR 0 8
105693: PPUSH
105694: LD_INT 0
105696: PPUSH
105697: CALL_OW 1
105701: ST_TO_ADDR
// exit ;
105702: POP
105703: POP
105704: GO 106237
// end ; x := list [ i ] [ 3 ] ;
105706: LD_ADDR_VAR 0 6
105710: PUSH
105711: LD_VAR 0 3
105715: PUSH
105716: LD_VAR 0 1
105720: ARRAY
105721: PUSH
105722: LD_INT 3
105724: ARRAY
105725: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105726: LD_ADDR_VAR 0 7
105730: PUSH
105731: LD_VAR 0 3
105735: PUSH
105736: LD_VAR 0 1
105740: ARRAY
105741: PUSH
105742: LD_INT 4
105744: ARRAY
105745: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105746: LD_ADDR_VAR 0 9
105750: PUSH
105751: LD_VAR 0 6
105755: PPUSH
105756: LD_VAR 0 7
105760: PPUSH
105761: LD_INT 16
105763: PPUSH
105764: CALL 88839 0 3
105768: ST_TO_ADDR
// if not cratesNearbyPoint then
105769: LD_VAR 0 9
105773: NOT
105774: IFFALSE 105780
// exit ;
105776: POP
105777: POP
105778: GO 106237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105780: LD_ADDR_VAR 0 4
105784: PUSH
105785: LD_INT 22
105787: PUSH
105788: LD_VAR 0 5
105792: PUSH
105793: EMPTY
105794: LIST
105795: LIST
105796: PUSH
105797: LD_INT 3
105799: PUSH
105800: LD_INT 60
105802: PUSH
105803: EMPTY
105804: LIST
105805: PUSH
105806: EMPTY
105807: LIST
105808: LIST
105809: PUSH
105810: LD_INT 91
105812: PUSH
105813: LD_VAR 0 8
105817: PUSH
105818: LD_INT 6
105820: PUSH
105821: EMPTY
105822: LIST
105823: LIST
105824: LIST
105825: PUSH
105826: LD_INT 2
105828: PUSH
105829: LD_INT 25
105831: PUSH
105832: LD_INT 2
105834: PUSH
105835: EMPTY
105836: LIST
105837: LIST
105838: PUSH
105839: LD_INT 25
105841: PUSH
105842: LD_INT 16
105844: PUSH
105845: EMPTY
105846: LIST
105847: LIST
105848: PUSH
105849: EMPTY
105850: LIST
105851: LIST
105852: LIST
105853: PUSH
105854: EMPTY
105855: LIST
105856: LIST
105857: LIST
105858: LIST
105859: PPUSH
105860: CALL_OW 69
105864: PUSH
105865: LD_VAR 0 8
105869: PPUSH
105870: CALL_OW 313
105874: PPUSH
105875: LD_INT 3
105877: PUSH
105878: LD_INT 60
105880: PUSH
105881: EMPTY
105882: LIST
105883: PUSH
105884: EMPTY
105885: LIST
105886: LIST
105887: PUSH
105888: LD_INT 2
105890: PUSH
105891: LD_INT 25
105893: PUSH
105894: LD_INT 2
105896: PUSH
105897: EMPTY
105898: LIST
105899: LIST
105900: PUSH
105901: LD_INT 25
105903: PUSH
105904: LD_INT 16
105906: PUSH
105907: EMPTY
105908: LIST
105909: LIST
105910: PUSH
105911: EMPTY
105912: LIST
105913: LIST
105914: LIST
105915: PUSH
105916: EMPTY
105917: LIST
105918: LIST
105919: PPUSH
105920: CALL_OW 72
105924: UNION
105925: ST_TO_ADDR
// if tmp then
105926: LD_VAR 0 4
105930: IFFALSE 106010
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105932: LD_ADDR_VAR 0 4
105936: PUSH
105937: LD_VAR 0 4
105941: PPUSH
105942: LD_INT 3
105944: PPUSH
105945: CALL 86808 0 2
105949: ST_TO_ADDR
// for j in tmp do
105950: LD_ADDR_VAR 0 2
105954: PUSH
105955: LD_VAR 0 4
105959: PUSH
105960: FOR_IN
105961: IFFALSE 106004
// begin if IsInUnit ( j ) then
105963: LD_VAR 0 2
105967: PPUSH
105968: CALL_OW 310
105972: IFFALSE 105983
// ComExit ( j ) ;
105974: LD_VAR 0 2
105978: PPUSH
105979: CALL 86891 0 1
// AddComCollect ( j , x , y ) ;
105983: LD_VAR 0 2
105987: PPUSH
105988: LD_VAR 0 6
105992: PPUSH
105993: LD_VAR 0 7
105997: PPUSH
105998: CALL_OW 177
// end ;
106002: GO 105960
106004: POP
106005: POP
// exit ;
106006: POP
106007: POP
106008: GO 106237
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106010: LD_ADDR_VAR 0 4
106014: PUSH
106015: LD_INT 22
106017: PUSH
106018: LD_VAR 0 5
106022: PUSH
106023: EMPTY
106024: LIST
106025: LIST
106026: PUSH
106027: LD_INT 91
106029: PUSH
106030: LD_VAR 0 8
106034: PUSH
106035: LD_INT 8
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: LIST
106042: PUSH
106043: LD_INT 2
106045: PUSH
106046: LD_INT 34
106048: PUSH
106049: LD_INT 12
106051: PUSH
106052: EMPTY
106053: LIST
106054: LIST
106055: PUSH
106056: LD_INT 34
106058: PUSH
106059: LD_INT 51
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: PUSH
106066: LD_INT 34
106068: PUSH
106069: LD_INT 32
106071: PUSH
106072: EMPTY
106073: LIST
106074: LIST
106075: PUSH
106076: LD_INT 34
106078: PUSH
106079: LD_INT 89
106081: PUSH
106082: EMPTY
106083: LIST
106084: LIST
106085: PUSH
106086: EMPTY
106087: LIST
106088: LIST
106089: LIST
106090: LIST
106091: LIST
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: LIST
106097: PPUSH
106098: CALL_OW 69
106102: ST_TO_ADDR
// if tmp then
106103: LD_VAR 0 4
106107: IFFALSE 106233
// begin for j in tmp do
106109: LD_ADDR_VAR 0 2
106113: PUSH
106114: LD_VAR 0 4
106118: PUSH
106119: FOR_IN
106120: IFFALSE 106231
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106122: LD_VAR 0 2
106126: PPUSH
106127: CALL_OW 262
106131: PUSH
106132: LD_INT 3
106134: EQUAL
106135: PUSH
106136: LD_VAR 0 2
106140: PPUSH
106141: CALL_OW 261
106145: PUSH
106146: LD_INT 20
106148: GREATER
106149: OR
106150: PUSH
106151: LD_VAR 0 2
106155: PPUSH
106156: CALL_OW 314
106160: NOT
106161: AND
106162: PUSH
106163: LD_VAR 0 2
106167: PPUSH
106168: CALL_OW 263
106172: PUSH
106173: LD_INT 1
106175: NONEQUAL
106176: PUSH
106177: LD_VAR 0 2
106181: PPUSH
106182: CALL_OW 311
106186: OR
106187: AND
106188: IFFALSE 106229
// begin ComCollect ( j , x , y ) ;
106190: LD_VAR 0 2
106194: PPUSH
106195: LD_VAR 0 6
106199: PPUSH
106200: LD_VAR 0 7
106204: PPUSH
106205: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106209: LD_VAR 0 2
106213: PPUSH
106214: LD_VAR 0 8
106218: PPUSH
106219: CALL_OW 172
// exit ;
106223: POP
106224: POP
106225: POP
106226: POP
106227: GO 106237
// end ;
106229: GO 106119
106231: POP
106232: POP
// end ; end ;
106233: GO 105608
106235: POP
106236: POP
// end ; end_of_file
106237: PPOPN 9
106239: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106240: LD_INT 0
106242: PPUSH
106243: PPUSH
106244: PPUSH
106245: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106246: LD_VAR 0 1
106250: PPUSH
106251: CALL_OW 264
106255: PUSH
106256: LD_INT 91
106258: EQUAL
106259: IFFALSE 106331
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106261: LD_INT 68
106263: PPUSH
106264: LD_VAR 0 1
106268: PPUSH
106269: CALL_OW 255
106273: PPUSH
106274: CALL_OW 321
106278: PUSH
106279: LD_INT 2
106281: EQUAL
106282: IFFALSE 106294
// eff := 70 else
106284: LD_ADDR_VAR 0 4
106288: PUSH
106289: LD_INT 70
106291: ST_TO_ADDR
106292: GO 106302
// eff := 30 ;
106294: LD_ADDR_VAR 0 4
106298: PUSH
106299: LD_INT 30
106301: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106302: LD_VAR 0 1
106306: PPUSH
106307: CALL_OW 250
106311: PPUSH
106312: LD_VAR 0 1
106316: PPUSH
106317: CALL_OW 251
106321: PPUSH
106322: LD_VAR 0 4
106326: PPUSH
106327: CALL_OW 495
// end ; end ;
106331: LD_VAR 0 2
106335: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106336: LD_INT 0
106338: PPUSH
// end ;
106339: LD_VAR 0 4
106343: RET
// export function SOS_Command ( cmd ) ; begin
106344: LD_INT 0
106346: PPUSH
// end ;
106347: LD_VAR 0 2
106351: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106352: LD_INT 0
106354: PPUSH
// end ;
106355: LD_VAR 0 6
106359: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106360: LD_INT 0
106362: PPUSH
106363: PPUSH
// if not vehicle or not factory then
106364: LD_VAR 0 1
106368: NOT
106369: PUSH
106370: LD_VAR 0 2
106374: NOT
106375: OR
106376: IFFALSE 106380
// exit ;
106378: GO 106611
// if factoryWaypoints >= factory then
106380: LD_EXP 154
106384: PUSH
106385: LD_VAR 0 2
106389: GREATEREQUAL
106390: IFFALSE 106611
// if factoryWaypoints [ factory ] then
106392: LD_EXP 154
106396: PUSH
106397: LD_VAR 0 2
106401: ARRAY
106402: IFFALSE 106611
// begin if GetControl ( vehicle ) = control_manual then
106404: LD_VAR 0 1
106408: PPUSH
106409: CALL_OW 263
106413: PUSH
106414: LD_INT 1
106416: EQUAL
106417: IFFALSE 106498
// begin driver := IsDrivenBy ( vehicle ) ;
106419: LD_ADDR_VAR 0 4
106423: PUSH
106424: LD_VAR 0 1
106428: PPUSH
106429: CALL_OW 311
106433: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106434: LD_VAR 0 4
106438: PPUSH
106439: LD_EXP 154
106443: PUSH
106444: LD_VAR 0 2
106448: ARRAY
106449: PUSH
106450: LD_INT 3
106452: ARRAY
106453: PPUSH
106454: LD_EXP 154
106458: PUSH
106459: LD_VAR 0 2
106463: ARRAY
106464: PUSH
106465: LD_INT 4
106467: ARRAY
106468: PPUSH
106469: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106473: LD_VAR 0 4
106477: PPUSH
106478: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106482: LD_VAR 0 4
106486: PPUSH
106487: LD_VAR 0 2
106491: PPUSH
106492: CALL_OW 180
// end else
106496: GO 106611
// if GetControl ( vehicle ) = control_remote then
106498: LD_VAR 0 1
106502: PPUSH
106503: CALL_OW 263
106507: PUSH
106508: LD_INT 2
106510: EQUAL
106511: IFFALSE 106572
// begin wait ( 0 0$2 ) ;
106513: LD_INT 70
106515: PPUSH
106516: CALL_OW 67
// if Connect ( vehicle ) then
106520: LD_VAR 0 1
106524: PPUSH
106525: CALL 57131 0 1
106529: IFFALSE 106570
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106531: LD_VAR 0 1
106535: PPUSH
106536: LD_EXP 154
106540: PUSH
106541: LD_VAR 0 2
106545: ARRAY
106546: PUSH
106547: LD_INT 3
106549: ARRAY
106550: PPUSH
106551: LD_EXP 154
106555: PUSH
106556: LD_VAR 0 2
106560: ARRAY
106561: PUSH
106562: LD_INT 4
106564: ARRAY
106565: PPUSH
106566: CALL_OW 171
// end else
106570: GO 106611
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106572: LD_VAR 0 1
106576: PPUSH
106577: LD_EXP 154
106581: PUSH
106582: LD_VAR 0 2
106586: ARRAY
106587: PUSH
106588: LD_INT 3
106590: ARRAY
106591: PPUSH
106592: LD_EXP 154
106596: PUSH
106597: LD_VAR 0 2
106601: ARRAY
106602: PUSH
106603: LD_INT 4
106605: ARRAY
106606: PPUSH
106607: CALL_OW 171
// end ; end ;
106611: LD_VAR 0 3
106615: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106616: LD_INT 0
106618: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106619: LD_VAR 0 1
106623: PUSH
106624: LD_INT 250
106626: EQUAL
106627: PUSH
106628: LD_VAR 0 2
106632: PPUSH
106633: CALL_OW 264
106637: PUSH
106638: LD_INT 81
106640: EQUAL
106641: AND
106642: IFFALSE 106663
// MinerPlaceMine ( unit , x , y ) ;
106644: LD_VAR 0 2
106648: PPUSH
106649: LD_VAR 0 4
106653: PPUSH
106654: LD_VAR 0 5
106658: PPUSH
106659: CALL 109048 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106663: LD_VAR 0 1
106667: PUSH
106668: LD_INT 251
106670: EQUAL
106671: PUSH
106672: LD_VAR 0 2
106676: PPUSH
106677: CALL_OW 264
106681: PUSH
106682: LD_INT 81
106684: EQUAL
106685: AND
106686: IFFALSE 106707
// MinerDetonateMine ( unit , x , y ) ;
106688: LD_VAR 0 2
106692: PPUSH
106693: LD_VAR 0 4
106697: PPUSH
106698: LD_VAR 0 5
106702: PPUSH
106703: CALL 109323 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106707: LD_VAR 0 1
106711: PUSH
106712: LD_INT 252
106714: EQUAL
106715: PUSH
106716: LD_VAR 0 2
106720: PPUSH
106721: CALL_OW 264
106725: PUSH
106726: LD_INT 81
106728: EQUAL
106729: AND
106730: IFFALSE 106751
// MinerCreateMinefield ( unit , x , y ) ;
106732: LD_VAR 0 2
106736: PPUSH
106737: LD_VAR 0 4
106741: PPUSH
106742: LD_VAR 0 5
106746: PPUSH
106747: CALL 109740 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106751: LD_VAR 0 1
106755: PUSH
106756: LD_INT 253
106758: EQUAL
106759: PUSH
106760: LD_VAR 0 2
106764: PPUSH
106765: CALL_OW 257
106769: PUSH
106770: LD_INT 5
106772: EQUAL
106773: AND
106774: IFFALSE 106795
// ComBinocular ( unit , x , y ) ;
106776: LD_VAR 0 2
106780: PPUSH
106781: LD_VAR 0 4
106785: PPUSH
106786: LD_VAR 0 5
106790: PPUSH
106791: CALL 110109 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106795: LD_VAR 0 1
106799: PUSH
106800: LD_INT 254
106802: EQUAL
106803: PUSH
106804: LD_VAR 0 2
106808: PPUSH
106809: CALL_OW 264
106813: PUSH
106814: LD_INT 99
106816: EQUAL
106817: AND
106818: PUSH
106819: LD_VAR 0 3
106823: PPUSH
106824: CALL_OW 263
106828: PUSH
106829: LD_INT 3
106831: EQUAL
106832: AND
106833: IFFALSE 106849
// HackDestroyVehicle ( unit , selectedUnit ) ;
106835: LD_VAR 0 2
106839: PPUSH
106840: LD_VAR 0 3
106844: PPUSH
106845: CALL 108412 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106849: LD_VAR 0 1
106853: PUSH
106854: LD_INT 255
106856: EQUAL
106857: PUSH
106858: LD_VAR 0 2
106862: PPUSH
106863: CALL_OW 264
106867: PUSH
106868: LD_INT 14
106870: PUSH
106871: LD_INT 53
106873: PUSH
106874: EMPTY
106875: LIST
106876: LIST
106877: IN
106878: AND
106879: PUSH
106880: LD_VAR 0 4
106884: PPUSH
106885: LD_VAR 0 5
106889: PPUSH
106890: CALL_OW 488
106894: AND
106895: IFFALSE 106919
// CutTreeXYR ( unit , x , y , 12 ) ;
106897: LD_VAR 0 2
106901: PPUSH
106902: LD_VAR 0 4
106906: PPUSH
106907: LD_VAR 0 5
106911: PPUSH
106912: LD_INT 12
106914: PPUSH
106915: CALL 106982 0 4
// if cmd = 256 then
106919: LD_VAR 0 1
106923: PUSH
106924: LD_INT 256
106926: EQUAL
106927: IFFALSE 106948
// SetFactoryWaypoint ( unit , x , y ) ;
106929: LD_VAR 0 2
106933: PPUSH
106934: LD_VAR 0 4
106938: PPUSH
106939: LD_VAR 0 5
106943: PPUSH
106944: CALL 104929 0 3
// if cmd = 257 then
106948: LD_VAR 0 1
106952: PUSH
106953: LD_INT 257
106955: EQUAL
106956: IFFALSE 106977
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106958: LD_VAR 0 2
106962: PPUSH
106963: LD_VAR 0 4
106967: PPUSH
106968: LD_VAR 0 5
106972: PPUSH
106973: CALL 105291 0 3
// end ;
106977: LD_VAR 0 6
106981: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106982: LD_INT 0
106984: PPUSH
106985: PPUSH
106986: PPUSH
106987: PPUSH
106988: PPUSH
106989: PPUSH
106990: PPUSH
106991: PPUSH
106992: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106993: LD_VAR 0 1
106997: NOT
106998: PUSH
106999: LD_VAR 0 2
107003: PPUSH
107004: LD_VAR 0 3
107008: PPUSH
107009: CALL_OW 488
107013: NOT
107014: OR
107015: PUSH
107016: LD_VAR 0 4
107020: NOT
107021: OR
107022: IFFALSE 107026
// exit ;
107024: GO 107366
// list := [ ] ;
107026: LD_ADDR_VAR 0 13
107030: PUSH
107031: EMPTY
107032: ST_TO_ADDR
// if x - r < 0 then
107033: LD_VAR 0 2
107037: PUSH
107038: LD_VAR 0 4
107042: MINUS
107043: PUSH
107044: LD_INT 0
107046: LESS
107047: IFFALSE 107059
// min_x := 0 else
107049: LD_ADDR_VAR 0 7
107053: PUSH
107054: LD_INT 0
107056: ST_TO_ADDR
107057: GO 107075
// min_x := x - r ;
107059: LD_ADDR_VAR 0 7
107063: PUSH
107064: LD_VAR 0 2
107068: PUSH
107069: LD_VAR 0 4
107073: MINUS
107074: ST_TO_ADDR
// if y - r < 0 then
107075: LD_VAR 0 3
107079: PUSH
107080: LD_VAR 0 4
107084: MINUS
107085: PUSH
107086: LD_INT 0
107088: LESS
107089: IFFALSE 107101
// min_y := 0 else
107091: LD_ADDR_VAR 0 8
107095: PUSH
107096: LD_INT 0
107098: ST_TO_ADDR
107099: GO 107117
// min_y := y - r ;
107101: LD_ADDR_VAR 0 8
107105: PUSH
107106: LD_VAR 0 3
107110: PUSH
107111: LD_VAR 0 4
107115: MINUS
107116: ST_TO_ADDR
// max_x := x + r ;
107117: LD_ADDR_VAR 0 9
107121: PUSH
107122: LD_VAR 0 2
107126: PUSH
107127: LD_VAR 0 4
107131: PLUS
107132: ST_TO_ADDR
// max_y := y + r ;
107133: LD_ADDR_VAR 0 10
107137: PUSH
107138: LD_VAR 0 3
107142: PUSH
107143: LD_VAR 0 4
107147: PLUS
107148: ST_TO_ADDR
// for _x = min_x to max_x do
107149: LD_ADDR_VAR 0 11
107153: PUSH
107154: DOUBLE
107155: LD_VAR 0 7
107159: DEC
107160: ST_TO_ADDR
107161: LD_VAR 0 9
107165: PUSH
107166: FOR_TO
107167: IFFALSE 107284
// for _y = min_y to max_y do
107169: LD_ADDR_VAR 0 12
107173: PUSH
107174: DOUBLE
107175: LD_VAR 0 8
107179: DEC
107180: ST_TO_ADDR
107181: LD_VAR 0 10
107185: PUSH
107186: FOR_TO
107187: IFFALSE 107280
// begin if not ValidHex ( _x , _y ) then
107189: LD_VAR 0 11
107193: PPUSH
107194: LD_VAR 0 12
107198: PPUSH
107199: CALL_OW 488
107203: NOT
107204: IFFALSE 107208
// continue ;
107206: GO 107186
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107208: LD_VAR 0 11
107212: PPUSH
107213: LD_VAR 0 12
107217: PPUSH
107218: CALL_OW 351
107222: PUSH
107223: LD_VAR 0 11
107227: PPUSH
107228: LD_VAR 0 12
107232: PPUSH
107233: CALL_OW 554
107237: AND
107238: IFFALSE 107278
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107240: LD_ADDR_VAR 0 13
107244: PUSH
107245: LD_VAR 0 13
107249: PPUSH
107250: LD_VAR 0 13
107254: PUSH
107255: LD_INT 1
107257: PLUS
107258: PPUSH
107259: LD_VAR 0 11
107263: PUSH
107264: LD_VAR 0 12
107268: PUSH
107269: EMPTY
107270: LIST
107271: LIST
107272: PPUSH
107273: CALL_OW 2
107277: ST_TO_ADDR
// end ;
107278: GO 107186
107280: POP
107281: POP
107282: GO 107166
107284: POP
107285: POP
// if not list then
107286: LD_VAR 0 13
107290: NOT
107291: IFFALSE 107295
// exit ;
107293: GO 107366
// for i in list do
107295: LD_ADDR_VAR 0 6
107299: PUSH
107300: LD_VAR 0 13
107304: PUSH
107305: FOR_IN
107306: IFFALSE 107364
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107308: LD_VAR 0 1
107312: PPUSH
107313: LD_STRING M
107315: PUSH
107316: LD_VAR 0 6
107320: PUSH
107321: LD_INT 1
107323: ARRAY
107324: PUSH
107325: LD_VAR 0 6
107329: PUSH
107330: LD_INT 2
107332: ARRAY
107333: PUSH
107334: LD_INT 0
107336: PUSH
107337: LD_INT 0
107339: PUSH
107340: LD_INT 0
107342: PUSH
107343: LD_INT 0
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: LIST
107350: LIST
107351: LIST
107352: LIST
107353: LIST
107354: PUSH
107355: EMPTY
107356: LIST
107357: PPUSH
107358: CALL_OW 447
107362: GO 107305
107364: POP
107365: POP
// end ;
107366: LD_VAR 0 5
107370: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107371: LD_EXP 157
107375: NOT
107376: IFFALSE 107426
107378: GO 107380
107380: DISABLE
// begin initHack := true ;
107381: LD_ADDR_EXP 157
107385: PUSH
107386: LD_INT 1
107388: ST_TO_ADDR
// hackTanks := [ ] ;
107389: LD_ADDR_EXP 158
107393: PUSH
107394: EMPTY
107395: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107396: LD_ADDR_EXP 159
107400: PUSH
107401: EMPTY
107402: ST_TO_ADDR
// hackLimit := 3 ;
107403: LD_ADDR_EXP 160
107407: PUSH
107408: LD_INT 3
107410: ST_TO_ADDR
// hackDist := 12 ;
107411: LD_ADDR_EXP 161
107415: PUSH
107416: LD_INT 12
107418: ST_TO_ADDR
// hackCounter := [ ] ;
107419: LD_ADDR_EXP 162
107423: PUSH
107424: EMPTY
107425: ST_TO_ADDR
// end ;
107426: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107427: LD_EXP 157
107431: PUSH
107432: LD_INT 34
107434: PUSH
107435: LD_INT 99
107437: PUSH
107438: EMPTY
107439: LIST
107440: LIST
107441: PPUSH
107442: CALL_OW 69
107446: AND
107447: IFFALSE 107700
107449: GO 107451
107451: DISABLE
107452: LD_INT 0
107454: PPUSH
107455: PPUSH
// begin enable ;
107456: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107457: LD_ADDR_VAR 0 1
107461: PUSH
107462: LD_INT 34
107464: PUSH
107465: LD_INT 99
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: PPUSH
107472: CALL_OW 69
107476: PUSH
107477: FOR_IN
107478: IFFALSE 107698
// begin if not i in hackTanks then
107480: LD_VAR 0 1
107484: PUSH
107485: LD_EXP 158
107489: IN
107490: NOT
107491: IFFALSE 107574
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107493: LD_ADDR_EXP 158
107497: PUSH
107498: LD_EXP 158
107502: PPUSH
107503: LD_EXP 158
107507: PUSH
107508: LD_INT 1
107510: PLUS
107511: PPUSH
107512: LD_VAR 0 1
107516: PPUSH
107517: CALL_OW 1
107521: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107522: LD_ADDR_EXP 159
107526: PUSH
107527: LD_EXP 159
107531: PPUSH
107532: LD_EXP 159
107536: PUSH
107537: LD_INT 1
107539: PLUS
107540: PPUSH
107541: EMPTY
107542: PPUSH
107543: CALL_OW 1
107547: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107548: LD_ADDR_EXP 162
107552: PUSH
107553: LD_EXP 162
107557: PPUSH
107558: LD_EXP 162
107562: PUSH
107563: LD_INT 1
107565: PLUS
107566: PPUSH
107567: EMPTY
107568: PPUSH
107569: CALL_OW 1
107573: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107574: LD_VAR 0 1
107578: PPUSH
107579: CALL_OW 302
107583: NOT
107584: IFFALSE 107597
// begin HackUnlinkAll ( i ) ;
107586: LD_VAR 0 1
107590: PPUSH
107591: CALL 107703 0 1
// continue ;
107595: GO 107477
// end ; HackCheckCapturedStatus ( i ) ;
107597: LD_VAR 0 1
107601: PPUSH
107602: CALL 108146 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107606: LD_ADDR_VAR 0 2
107610: PUSH
107611: LD_INT 81
107613: PUSH
107614: LD_VAR 0 1
107618: PPUSH
107619: CALL_OW 255
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PUSH
107628: LD_INT 33
107630: PUSH
107631: LD_INT 3
107633: PUSH
107634: EMPTY
107635: LIST
107636: LIST
107637: PUSH
107638: LD_INT 91
107640: PUSH
107641: LD_VAR 0 1
107645: PUSH
107646: LD_EXP 161
107650: PUSH
107651: EMPTY
107652: LIST
107653: LIST
107654: LIST
107655: PUSH
107656: LD_INT 50
107658: PUSH
107659: EMPTY
107660: LIST
107661: PUSH
107662: EMPTY
107663: LIST
107664: LIST
107665: LIST
107666: LIST
107667: PPUSH
107668: CALL_OW 69
107672: ST_TO_ADDR
// if not tmp then
107673: LD_VAR 0 2
107677: NOT
107678: IFFALSE 107682
// continue ;
107680: GO 107477
// HackLink ( i , tmp ) ;
107682: LD_VAR 0 1
107686: PPUSH
107687: LD_VAR 0 2
107691: PPUSH
107692: CALL 107839 0 2
// end ;
107696: GO 107477
107698: POP
107699: POP
// end ;
107700: PPOPN 2
107702: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107703: LD_INT 0
107705: PPUSH
107706: PPUSH
107707: PPUSH
// if not hack in hackTanks then
107708: LD_VAR 0 1
107712: PUSH
107713: LD_EXP 158
107717: IN
107718: NOT
107719: IFFALSE 107723
// exit ;
107721: GO 107834
// index := GetElementIndex ( hackTanks , hack ) ;
107723: LD_ADDR_VAR 0 4
107727: PUSH
107728: LD_EXP 158
107732: PPUSH
107733: LD_VAR 0 1
107737: PPUSH
107738: CALL 53947 0 2
107742: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107743: LD_EXP 159
107747: PUSH
107748: LD_VAR 0 4
107752: ARRAY
107753: IFFALSE 107834
// begin for i in hackTanksCaptured [ index ] do
107755: LD_ADDR_VAR 0 3
107759: PUSH
107760: LD_EXP 159
107764: PUSH
107765: LD_VAR 0 4
107769: ARRAY
107770: PUSH
107771: FOR_IN
107772: IFFALSE 107798
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107774: LD_VAR 0 3
107778: PUSH
107779: LD_INT 1
107781: ARRAY
107782: PPUSH
107783: LD_VAR 0 3
107787: PUSH
107788: LD_INT 2
107790: ARRAY
107791: PPUSH
107792: CALL_OW 235
107796: GO 107771
107798: POP
107799: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107800: LD_ADDR_EXP 159
107804: PUSH
107805: LD_EXP 159
107809: PPUSH
107810: LD_VAR 0 4
107814: PPUSH
107815: EMPTY
107816: PPUSH
107817: CALL_OW 1
107821: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107822: LD_VAR 0 1
107826: PPUSH
107827: LD_INT 0
107829: PPUSH
107830: CALL_OW 505
// end ; end ;
107834: LD_VAR 0 2
107838: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107839: LD_INT 0
107841: PPUSH
107842: PPUSH
107843: PPUSH
// if not hack in hackTanks or not vehicles then
107844: LD_VAR 0 1
107848: PUSH
107849: LD_EXP 158
107853: IN
107854: NOT
107855: PUSH
107856: LD_VAR 0 2
107860: NOT
107861: OR
107862: IFFALSE 107866
// exit ;
107864: GO 108141
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107866: LD_ADDR_VAR 0 2
107870: PUSH
107871: LD_VAR 0 1
107875: PPUSH
107876: LD_VAR 0 2
107880: PPUSH
107881: LD_INT 1
107883: PPUSH
107884: LD_INT 1
107886: PPUSH
107887: CALL 54597 0 4
107891: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107892: LD_ADDR_VAR 0 5
107896: PUSH
107897: LD_EXP 158
107901: PPUSH
107902: LD_VAR 0 1
107906: PPUSH
107907: CALL 53947 0 2
107911: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107912: LD_EXP 159
107916: PUSH
107917: LD_VAR 0 5
107921: ARRAY
107922: PUSH
107923: LD_EXP 160
107927: LESS
107928: IFFALSE 108117
// begin for i := 1 to vehicles do
107930: LD_ADDR_VAR 0 4
107934: PUSH
107935: DOUBLE
107936: LD_INT 1
107938: DEC
107939: ST_TO_ADDR
107940: LD_VAR 0 2
107944: PUSH
107945: FOR_TO
107946: IFFALSE 108115
// begin if hackTanksCaptured [ index ] = hackLimit then
107948: LD_EXP 159
107952: PUSH
107953: LD_VAR 0 5
107957: ARRAY
107958: PUSH
107959: LD_EXP 160
107963: EQUAL
107964: IFFALSE 107968
// break ;
107966: GO 108115
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107968: LD_ADDR_EXP 162
107972: PUSH
107973: LD_EXP 162
107977: PPUSH
107978: LD_VAR 0 5
107982: PPUSH
107983: LD_EXP 162
107987: PUSH
107988: LD_VAR 0 5
107992: ARRAY
107993: PUSH
107994: LD_INT 1
107996: PLUS
107997: PPUSH
107998: CALL_OW 1
108002: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108003: LD_ADDR_EXP 159
108007: PUSH
108008: LD_EXP 159
108012: PPUSH
108013: LD_VAR 0 5
108017: PUSH
108018: LD_EXP 159
108022: PUSH
108023: LD_VAR 0 5
108027: ARRAY
108028: PUSH
108029: LD_INT 1
108031: PLUS
108032: PUSH
108033: EMPTY
108034: LIST
108035: LIST
108036: PPUSH
108037: LD_VAR 0 2
108041: PUSH
108042: LD_VAR 0 4
108046: ARRAY
108047: PUSH
108048: LD_VAR 0 2
108052: PUSH
108053: LD_VAR 0 4
108057: ARRAY
108058: PPUSH
108059: CALL_OW 255
108063: PUSH
108064: EMPTY
108065: LIST
108066: LIST
108067: PPUSH
108068: CALL 54162 0 3
108072: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108073: LD_VAR 0 2
108077: PUSH
108078: LD_VAR 0 4
108082: ARRAY
108083: PPUSH
108084: LD_VAR 0 1
108088: PPUSH
108089: CALL_OW 255
108093: PPUSH
108094: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108098: LD_VAR 0 2
108102: PUSH
108103: LD_VAR 0 4
108107: ARRAY
108108: PPUSH
108109: CALL_OW 141
// end ;
108113: GO 107945
108115: POP
108116: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108117: LD_VAR 0 1
108121: PPUSH
108122: LD_EXP 159
108126: PUSH
108127: LD_VAR 0 5
108131: ARRAY
108132: PUSH
108133: LD_INT 0
108135: PLUS
108136: PPUSH
108137: CALL_OW 505
// end ;
108141: LD_VAR 0 3
108145: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108146: LD_INT 0
108148: PPUSH
108149: PPUSH
108150: PPUSH
108151: PPUSH
// if not hack in hackTanks then
108152: LD_VAR 0 1
108156: PUSH
108157: LD_EXP 158
108161: IN
108162: NOT
108163: IFFALSE 108167
// exit ;
108165: GO 108407
// index := GetElementIndex ( hackTanks , hack ) ;
108167: LD_ADDR_VAR 0 4
108171: PUSH
108172: LD_EXP 158
108176: PPUSH
108177: LD_VAR 0 1
108181: PPUSH
108182: CALL 53947 0 2
108186: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108187: LD_ADDR_VAR 0 3
108191: PUSH
108192: DOUBLE
108193: LD_EXP 159
108197: PUSH
108198: LD_VAR 0 4
108202: ARRAY
108203: INC
108204: ST_TO_ADDR
108205: LD_INT 1
108207: PUSH
108208: FOR_DOWNTO
108209: IFFALSE 108381
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108211: LD_ADDR_VAR 0 5
108215: PUSH
108216: LD_EXP 159
108220: PUSH
108221: LD_VAR 0 4
108225: ARRAY
108226: PUSH
108227: LD_VAR 0 3
108231: ARRAY
108232: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108233: LD_VAR 0 5
108237: PUSH
108238: LD_INT 1
108240: ARRAY
108241: PPUSH
108242: CALL_OW 302
108246: NOT
108247: PUSH
108248: LD_VAR 0 5
108252: PUSH
108253: LD_INT 1
108255: ARRAY
108256: PPUSH
108257: CALL_OW 255
108261: PUSH
108262: LD_VAR 0 1
108266: PPUSH
108267: CALL_OW 255
108271: NONEQUAL
108272: OR
108273: IFFALSE 108379
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108275: LD_VAR 0 5
108279: PUSH
108280: LD_INT 1
108282: ARRAY
108283: PPUSH
108284: CALL_OW 305
108288: PUSH
108289: LD_VAR 0 5
108293: PUSH
108294: LD_INT 1
108296: ARRAY
108297: PPUSH
108298: CALL_OW 255
108302: PUSH
108303: LD_VAR 0 1
108307: PPUSH
108308: CALL_OW 255
108312: EQUAL
108313: AND
108314: IFFALSE 108338
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108316: LD_VAR 0 5
108320: PUSH
108321: LD_INT 1
108323: ARRAY
108324: PPUSH
108325: LD_VAR 0 5
108329: PUSH
108330: LD_INT 2
108332: ARRAY
108333: PPUSH
108334: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108338: LD_ADDR_EXP 159
108342: PUSH
108343: LD_EXP 159
108347: PPUSH
108348: LD_VAR 0 4
108352: PPUSH
108353: LD_EXP 159
108357: PUSH
108358: LD_VAR 0 4
108362: ARRAY
108363: PPUSH
108364: LD_VAR 0 3
108368: PPUSH
108369: CALL_OW 3
108373: PPUSH
108374: CALL_OW 1
108378: ST_TO_ADDR
// end ; end ;
108379: GO 108208
108381: POP
108382: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_EXP 159
108392: PUSH
108393: LD_VAR 0 4
108397: ARRAY
108398: PUSH
108399: LD_INT 0
108401: PLUS
108402: PPUSH
108403: CALL_OW 505
// end ;
108407: LD_VAR 0 2
108411: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108412: LD_INT 0
108414: PPUSH
108415: PPUSH
108416: PPUSH
108417: PPUSH
// if not hack in hackTanks then
108418: LD_VAR 0 1
108422: PUSH
108423: LD_EXP 158
108427: IN
108428: NOT
108429: IFFALSE 108433
// exit ;
108431: GO 108518
// index := GetElementIndex ( hackTanks , hack ) ;
108433: LD_ADDR_VAR 0 5
108437: PUSH
108438: LD_EXP 158
108442: PPUSH
108443: LD_VAR 0 1
108447: PPUSH
108448: CALL 53947 0 2
108452: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108453: LD_ADDR_VAR 0 4
108457: PUSH
108458: DOUBLE
108459: LD_INT 1
108461: DEC
108462: ST_TO_ADDR
108463: LD_EXP 159
108467: PUSH
108468: LD_VAR 0 5
108472: ARRAY
108473: PUSH
108474: FOR_TO
108475: IFFALSE 108516
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108477: LD_EXP 159
108481: PUSH
108482: LD_VAR 0 5
108486: ARRAY
108487: PUSH
108488: LD_VAR 0 4
108492: ARRAY
108493: PUSH
108494: LD_INT 1
108496: ARRAY
108497: PUSH
108498: LD_VAR 0 2
108502: EQUAL
108503: IFFALSE 108514
// KillUnit ( vehicle ) ;
108505: LD_VAR 0 2
108509: PPUSH
108510: CALL_OW 66
108514: GO 108474
108516: POP
108517: POP
// end ;
108518: LD_VAR 0 3
108522: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108523: LD_EXP 163
108527: NOT
108528: IFFALSE 108563
108530: GO 108532
108532: DISABLE
// begin initMiner := true ;
108533: LD_ADDR_EXP 163
108537: PUSH
108538: LD_INT 1
108540: ST_TO_ADDR
// minersList := [ ] ;
108541: LD_ADDR_EXP 164
108545: PUSH
108546: EMPTY
108547: ST_TO_ADDR
// minerMinesList := [ ] ;
108548: LD_ADDR_EXP 165
108552: PUSH
108553: EMPTY
108554: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108555: LD_ADDR_EXP 166
108559: PUSH
108560: LD_INT 5
108562: ST_TO_ADDR
// end ;
108563: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108564: LD_EXP 163
108568: PUSH
108569: LD_INT 34
108571: PUSH
108572: LD_INT 81
108574: PUSH
108575: EMPTY
108576: LIST
108577: LIST
108578: PPUSH
108579: CALL_OW 69
108583: AND
108584: IFFALSE 109045
108586: GO 108588
108588: DISABLE
108589: LD_INT 0
108591: PPUSH
108592: PPUSH
108593: PPUSH
108594: PPUSH
// begin enable ;
108595: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108596: LD_ADDR_VAR 0 1
108600: PUSH
108601: LD_INT 34
108603: PUSH
108604: LD_INT 81
108606: PUSH
108607: EMPTY
108608: LIST
108609: LIST
108610: PPUSH
108611: CALL_OW 69
108615: PUSH
108616: FOR_IN
108617: IFFALSE 108689
// begin if not i in minersList then
108619: LD_VAR 0 1
108623: PUSH
108624: LD_EXP 164
108628: IN
108629: NOT
108630: IFFALSE 108687
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108632: LD_ADDR_EXP 164
108636: PUSH
108637: LD_EXP 164
108641: PPUSH
108642: LD_EXP 164
108646: PUSH
108647: LD_INT 1
108649: PLUS
108650: PPUSH
108651: LD_VAR 0 1
108655: PPUSH
108656: CALL_OW 1
108660: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108661: LD_ADDR_EXP 165
108665: PUSH
108666: LD_EXP 165
108670: PPUSH
108671: LD_EXP 165
108675: PUSH
108676: LD_INT 1
108678: PLUS
108679: PPUSH
108680: EMPTY
108681: PPUSH
108682: CALL_OW 1
108686: ST_TO_ADDR
// end end ;
108687: GO 108616
108689: POP
108690: POP
// for i := minerMinesList downto 1 do
108691: LD_ADDR_VAR 0 1
108695: PUSH
108696: DOUBLE
108697: LD_EXP 165
108701: INC
108702: ST_TO_ADDR
108703: LD_INT 1
108705: PUSH
108706: FOR_DOWNTO
108707: IFFALSE 109043
// begin if IsLive ( minersList [ i ] ) then
108709: LD_EXP 164
108713: PUSH
108714: LD_VAR 0 1
108718: ARRAY
108719: PPUSH
108720: CALL_OW 300
108724: IFFALSE 108752
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108726: LD_EXP 164
108730: PUSH
108731: LD_VAR 0 1
108735: ARRAY
108736: PPUSH
108737: LD_EXP 165
108741: PUSH
108742: LD_VAR 0 1
108746: ARRAY
108747: PPUSH
108748: CALL_OW 505
// if not minerMinesList [ i ] then
108752: LD_EXP 165
108756: PUSH
108757: LD_VAR 0 1
108761: ARRAY
108762: NOT
108763: IFFALSE 108767
// continue ;
108765: GO 108706
// for j := minerMinesList [ i ] downto 1 do
108767: LD_ADDR_VAR 0 2
108771: PUSH
108772: DOUBLE
108773: LD_EXP 165
108777: PUSH
108778: LD_VAR 0 1
108782: ARRAY
108783: INC
108784: ST_TO_ADDR
108785: LD_INT 1
108787: PUSH
108788: FOR_DOWNTO
108789: IFFALSE 109039
// begin side := GetSide ( minersList [ i ] ) ;
108791: LD_ADDR_VAR 0 3
108795: PUSH
108796: LD_EXP 164
108800: PUSH
108801: LD_VAR 0 1
108805: ARRAY
108806: PPUSH
108807: CALL_OW 255
108811: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108812: LD_ADDR_VAR 0 4
108816: PUSH
108817: LD_EXP 165
108821: PUSH
108822: LD_VAR 0 1
108826: ARRAY
108827: PUSH
108828: LD_VAR 0 2
108832: ARRAY
108833: PUSH
108834: LD_INT 1
108836: ARRAY
108837: PPUSH
108838: LD_EXP 165
108842: PUSH
108843: LD_VAR 0 1
108847: ARRAY
108848: PUSH
108849: LD_VAR 0 2
108853: ARRAY
108854: PUSH
108855: LD_INT 2
108857: ARRAY
108858: PPUSH
108859: CALL_OW 428
108863: ST_TO_ADDR
// if not tmp then
108864: LD_VAR 0 4
108868: NOT
108869: IFFALSE 108873
// continue ;
108871: GO 108788
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108873: LD_VAR 0 4
108877: PUSH
108878: LD_INT 81
108880: PUSH
108881: LD_VAR 0 3
108885: PUSH
108886: EMPTY
108887: LIST
108888: LIST
108889: PPUSH
108890: CALL_OW 69
108894: IN
108895: PUSH
108896: LD_EXP 165
108900: PUSH
108901: LD_VAR 0 1
108905: ARRAY
108906: PUSH
108907: LD_VAR 0 2
108911: ARRAY
108912: PUSH
108913: LD_INT 1
108915: ARRAY
108916: PPUSH
108917: LD_EXP 165
108921: PUSH
108922: LD_VAR 0 1
108926: ARRAY
108927: PUSH
108928: LD_VAR 0 2
108932: ARRAY
108933: PUSH
108934: LD_INT 2
108936: ARRAY
108937: PPUSH
108938: CALL_OW 458
108942: AND
108943: IFFALSE 109037
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108945: LD_EXP 165
108949: PUSH
108950: LD_VAR 0 1
108954: ARRAY
108955: PUSH
108956: LD_VAR 0 2
108960: ARRAY
108961: PUSH
108962: LD_INT 1
108964: ARRAY
108965: PPUSH
108966: LD_EXP 165
108970: PUSH
108971: LD_VAR 0 1
108975: ARRAY
108976: PUSH
108977: LD_VAR 0 2
108981: ARRAY
108982: PUSH
108983: LD_INT 2
108985: ARRAY
108986: PPUSH
108987: LD_VAR 0 3
108991: PPUSH
108992: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108996: LD_ADDR_EXP 165
109000: PUSH
109001: LD_EXP 165
109005: PPUSH
109006: LD_VAR 0 1
109010: PPUSH
109011: LD_EXP 165
109015: PUSH
109016: LD_VAR 0 1
109020: ARRAY
109021: PPUSH
109022: LD_VAR 0 2
109026: PPUSH
109027: CALL_OW 3
109031: PPUSH
109032: CALL_OW 1
109036: ST_TO_ADDR
// end ; end ;
109037: GO 108788
109039: POP
109040: POP
// end ;
109041: GO 108706
109043: POP
109044: POP
// end ;
109045: PPOPN 4
109047: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109048: LD_INT 0
109050: PPUSH
109051: PPUSH
// result := false ;
109052: LD_ADDR_VAR 0 4
109056: PUSH
109057: LD_INT 0
109059: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109060: LD_VAR 0 1
109064: PPUSH
109065: CALL_OW 264
109069: PUSH
109070: LD_INT 81
109072: EQUAL
109073: NOT
109074: IFFALSE 109078
// exit ;
109076: GO 109318
// index := GetElementIndex ( minersList , unit ) ;
109078: LD_ADDR_VAR 0 5
109082: PUSH
109083: LD_EXP 164
109087: PPUSH
109088: LD_VAR 0 1
109092: PPUSH
109093: CALL 53947 0 2
109097: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109098: LD_EXP 165
109102: PUSH
109103: LD_VAR 0 5
109107: ARRAY
109108: PUSH
109109: LD_EXP 166
109113: GREATEREQUAL
109114: IFFALSE 109118
// exit ;
109116: GO 109318
// ComMoveXY ( unit , x , y ) ;
109118: LD_VAR 0 1
109122: PPUSH
109123: LD_VAR 0 2
109127: PPUSH
109128: LD_VAR 0 3
109132: PPUSH
109133: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109137: LD_INT 35
109139: PPUSH
109140: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109144: LD_VAR 0 1
109148: PPUSH
109149: LD_VAR 0 2
109153: PPUSH
109154: LD_VAR 0 3
109158: PPUSH
109159: CALL 85302 0 3
109163: NOT
109164: PUSH
109165: LD_VAR 0 1
109169: PPUSH
109170: CALL_OW 314
109174: AND
109175: IFFALSE 109179
// exit ;
109177: GO 109318
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109179: LD_VAR 0 2
109183: PPUSH
109184: LD_VAR 0 3
109188: PPUSH
109189: CALL_OW 428
109193: PUSH
109194: LD_VAR 0 1
109198: EQUAL
109199: PUSH
109200: LD_VAR 0 1
109204: PPUSH
109205: CALL_OW 314
109209: NOT
109210: AND
109211: IFFALSE 109137
// PlaySoundXY ( x , y , PlantMine ) ;
109213: LD_VAR 0 2
109217: PPUSH
109218: LD_VAR 0 3
109222: PPUSH
109223: LD_STRING PlantMine
109225: PPUSH
109226: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109230: LD_VAR 0 2
109234: PPUSH
109235: LD_VAR 0 3
109239: PPUSH
109240: LD_VAR 0 1
109244: PPUSH
109245: CALL_OW 255
109249: PPUSH
109250: LD_INT 0
109252: PPUSH
109253: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109257: LD_ADDR_EXP 165
109261: PUSH
109262: LD_EXP 165
109266: PPUSH
109267: LD_VAR 0 5
109271: PUSH
109272: LD_EXP 165
109276: PUSH
109277: LD_VAR 0 5
109281: ARRAY
109282: PUSH
109283: LD_INT 1
109285: PLUS
109286: PUSH
109287: EMPTY
109288: LIST
109289: LIST
109290: PPUSH
109291: LD_VAR 0 2
109295: PUSH
109296: LD_VAR 0 3
109300: PUSH
109301: EMPTY
109302: LIST
109303: LIST
109304: PPUSH
109305: CALL 54162 0 3
109309: ST_TO_ADDR
// result := true ;
109310: LD_ADDR_VAR 0 4
109314: PUSH
109315: LD_INT 1
109317: ST_TO_ADDR
// end ;
109318: LD_VAR 0 4
109322: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109323: LD_INT 0
109325: PPUSH
109326: PPUSH
109327: PPUSH
// if not unit in minersList then
109328: LD_VAR 0 1
109332: PUSH
109333: LD_EXP 164
109337: IN
109338: NOT
109339: IFFALSE 109343
// exit ;
109341: GO 109735
// index := GetElementIndex ( minersList , unit ) ;
109343: LD_ADDR_VAR 0 6
109347: PUSH
109348: LD_EXP 164
109352: PPUSH
109353: LD_VAR 0 1
109357: PPUSH
109358: CALL 53947 0 2
109362: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109363: LD_ADDR_VAR 0 5
109367: PUSH
109368: DOUBLE
109369: LD_EXP 165
109373: PUSH
109374: LD_VAR 0 6
109378: ARRAY
109379: INC
109380: ST_TO_ADDR
109381: LD_INT 1
109383: PUSH
109384: FOR_DOWNTO
109385: IFFALSE 109546
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109387: LD_EXP 165
109391: PUSH
109392: LD_VAR 0 6
109396: ARRAY
109397: PUSH
109398: LD_VAR 0 5
109402: ARRAY
109403: PUSH
109404: LD_INT 1
109406: ARRAY
109407: PUSH
109408: LD_VAR 0 2
109412: EQUAL
109413: PUSH
109414: LD_EXP 165
109418: PUSH
109419: LD_VAR 0 6
109423: ARRAY
109424: PUSH
109425: LD_VAR 0 5
109429: ARRAY
109430: PUSH
109431: LD_INT 2
109433: ARRAY
109434: PUSH
109435: LD_VAR 0 3
109439: EQUAL
109440: AND
109441: IFFALSE 109544
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109443: LD_EXP 165
109447: PUSH
109448: LD_VAR 0 6
109452: ARRAY
109453: PUSH
109454: LD_VAR 0 5
109458: ARRAY
109459: PUSH
109460: LD_INT 1
109462: ARRAY
109463: PPUSH
109464: LD_EXP 165
109468: PUSH
109469: LD_VAR 0 6
109473: ARRAY
109474: PUSH
109475: LD_VAR 0 5
109479: ARRAY
109480: PUSH
109481: LD_INT 2
109483: ARRAY
109484: PPUSH
109485: LD_VAR 0 1
109489: PPUSH
109490: CALL_OW 255
109494: PPUSH
109495: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109499: LD_ADDR_EXP 165
109503: PUSH
109504: LD_EXP 165
109508: PPUSH
109509: LD_VAR 0 6
109513: PPUSH
109514: LD_EXP 165
109518: PUSH
109519: LD_VAR 0 6
109523: ARRAY
109524: PPUSH
109525: LD_VAR 0 5
109529: PPUSH
109530: CALL_OW 3
109534: PPUSH
109535: CALL_OW 1
109539: ST_TO_ADDR
// exit ;
109540: POP
109541: POP
109542: GO 109735
// end ; end ;
109544: GO 109384
109546: POP
109547: POP
// for i := minerMinesList [ index ] downto 1 do
109548: LD_ADDR_VAR 0 5
109552: PUSH
109553: DOUBLE
109554: LD_EXP 165
109558: PUSH
109559: LD_VAR 0 6
109563: ARRAY
109564: INC
109565: ST_TO_ADDR
109566: LD_INT 1
109568: PUSH
109569: FOR_DOWNTO
109570: IFFALSE 109733
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109572: LD_EXP 165
109576: PUSH
109577: LD_VAR 0 6
109581: ARRAY
109582: PUSH
109583: LD_VAR 0 5
109587: ARRAY
109588: PUSH
109589: LD_INT 1
109591: ARRAY
109592: PPUSH
109593: LD_EXP 165
109597: PUSH
109598: LD_VAR 0 6
109602: ARRAY
109603: PUSH
109604: LD_VAR 0 5
109608: ARRAY
109609: PUSH
109610: LD_INT 2
109612: ARRAY
109613: PPUSH
109614: LD_VAR 0 2
109618: PPUSH
109619: LD_VAR 0 3
109623: PPUSH
109624: CALL_OW 298
109628: PUSH
109629: LD_INT 6
109631: LESS
109632: IFFALSE 109731
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109634: LD_EXP 165
109638: PUSH
109639: LD_VAR 0 6
109643: ARRAY
109644: PUSH
109645: LD_VAR 0 5
109649: ARRAY
109650: PUSH
109651: LD_INT 1
109653: ARRAY
109654: PPUSH
109655: LD_EXP 165
109659: PUSH
109660: LD_VAR 0 6
109664: ARRAY
109665: PUSH
109666: LD_VAR 0 5
109670: ARRAY
109671: PUSH
109672: LD_INT 2
109674: ARRAY
109675: PPUSH
109676: LD_VAR 0 1
109680: PPUSH
109681: CALL_OW 255
109685: PPUSH
109686: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109690: LD_ADDR_EXP 165
109694: PUSH
109695: LD_EXP 165
109699: PPUSH
109700: LD_VAR 0 6
109704: PPUSH
109705: LD_EXP 165
109709: PUSH
109710: LD_VAR 0 6
109714: ARRAY
109715: PPUSH
109716: LD_VAR 0 5
109720: PPUSH
109721: CALL_OW 3
109725: PPUSH
109726: CALL_OW 1
109730: ST_TO_ADDR
// end ; end ;
109731: GO 109569
109733: POP
109734: POP
// end ;
109735: LD_VAR 0 4
109739: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109740: LD_INT 0
109742: PPUSH
109743: PPUSH
109744: PPUSH
109745: PPUSH
109746: PPUSH
109747: PPUSH
109748: PPUSH
109749: PPUSH
109750: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109751: LD_VAR 0 1
109755: PPUSH
109756: CALL_OW 264
109760: PUSH
109761: LD_INT 81
109763: EQUAL
109764: NOT
109765: PUSH
109766: LD_VAR 0 1
109770: PUSH
109771: LD_EXP 164
109775: IN
109776: NOT
109777: OR
109778: IFFALSE 109782
// exit ;
109780: GO 110104
// index := GetElementIndex ( minersList , unit ) ;
109782: LD_ADDR_VAR 0 6
109786: PUSH
109787: LD_EXP 164
109791: PPUSH
109792: LD_VAR 0 1
109796: PPUSH
109797: CALL 53947 0 2
109801: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109802: LD_ADDR_VAR 0 8
109806: PUSH
109807: LD_EXP 166
109811: PUSH
109812: LD_EXP 165
109816: PUSH
109817: LD_VAR 0 6
109821: ARRAY
109822: MINUS
109823: ST_TO_ADDR
// if not minesFreeAmount then
109824: LD_VAR 0 8
109828: NOT
109829: IFFALSE 109833
// exit ;
109831: GO 110104
// tmp := [ ] ;
109833: LD_ADDR_VAR 0 7
109837: PUSH
109838: EMPTY
109839: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109840: LD_ADDR_VAR 0 5
109844: PUSH
109845: DOUBLE
109846: LD_INT 1
109848: DEC
109849: ST_TO_ADDR
109850: LD_VAR 0 8
109854: PUSH
109855: FOR_TO
109856: IFFALSE 110051
// begin _d := rand ( 0 , 5 ) ;
109858: LD_ADDR_VAR 0 11
109862: PUSH
109863: LD_INT 0
109865: PPUSH
109866: LD_INT 5
109868: PPUSH
109869: CALL_OW 12
109873: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109874: LD_ADDR_VAR 0 12
109878: PUSH
109879: LD_INT 2
109881: PPUSH
109882: LD_INT 6
109884: PPUSH
109885: CALL_OW 12
109889: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109890: LD_ADDR_VAR 0 9
109894: PUSH
109895: LD_VAR 0 2
109899: PPUSH
109900: LD_VAR 0 11
109904: PPUSH
109905: LD_VAR 0 12
109909: PPUSH
109910: CALL_OW 272
109914: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109915: LD_ADDR_VAR 0 10
109919: PUSH
109920: LD_VAR 0 3
109924: PPUSH
109925: LD_VAR 0 11
109929: PPUSH
109930: LD_VAR 0 12
109934: PPUSH
109935: CALL_OW 273
109939: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109940: LD_VAR 0 9
109944: PPUSH
109945: LD_VAR 0 10
109949: PPUSH
109950: CALL_OW 488
109954: PUSH
109955: LD_VAR 0 9
109959: PUSH
109960: LD_VAR 0 10
109964: PUSH
109965: EMPTY
109966: LIST
109967: LIST
109968: PUSH
109969: LD_VAR 0 7
109973: IN
109974: NOT
109975: AND
109976: PUSH
109977: LD_VAR 0 9
109981: PPUSH
109982: LD_VAR 0 10
109986: PPUSH
109987: CALL_OW 458
109991: NOT
109992: AND
109993: IFFALSE 110035
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109995: LD_ADDR_VAR 0 7
109999: PUSH
110000: LD_VAR 0 7
110004: PPUSH
110005: LD_VAR 0 7
110009: PUSH
110010: LD_INT 1
110012: PLUS
110013: PPUSH
110014: LD_VAR 0 9
110018: PUSH
110019: LD_VAR 0 10
110023: PUSH
110024: EMPTY
110025: LIST
110026: LIST
110027: PPUSH
110028: CALL_OW 1
110032: ST_TO_ADDR
110033: GO 110049
// i := i - 1 ;
110035: LD_ADDR_VAR 0 5
110039: PUSH
110040: LD_VAR 0 5
110044: PUSH
110045: LD_INT 1
110047: MINUS
110048: ST_TO_ADDR
// end ;
110049: GO 109855
110051: POP
110052: POP
// for i in tmp do
110053: LD_ADDR_VAR 0 5
110057: PUSH
110058: LD_VAR 0 7
110062: PUSH
110063: FOR_IN
110064: IFFALSE 110102
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110066: LD_VAR 0 1
110070: PPUSH
110071: LD_VAR 0 5
110075: PUSH
110076: LD_INT 1
110078: ARRAY
110079: PPUSH
110080: LD_VAR 0 5
110084: PUSH
110085: LD_INT 2
110087: ARRAY
110088: PPUSH
110089: CALL 109048 0 3
110093: NOT
110094: IFFALSE 110100
// exit ;
110096: POP
110097: POP
110098: GO 110104
110100: GO 110063
110102: POP
110103: POP
// end ;
110104: LD_VAR 0 4
110108: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110109: LD_INT 0
110111: PPUSH
110112: PPUSH
110113: PPUSH
110114: PPUSH
110115: PPUSH
110116: PPUSH
110117: PPUSH
// if not GetClass ( unit ) = class_sniper then
110118: LD_VAR 0 1
110122: PPUSH
110123: CALL_OW 257
110127: PUSH
110128: LD_INT 5
110130: EQUAL
110131: NOT
110132: IFFALSE 110136
// exit ;
110134: GO 110524
// dist := 8 ;
110136: LD_ADDR_VAR 0 5
110140: PUSH
110141: LD_INT 8
110143: ST_TO_ADDR
// viewRange := 12 ;
110144: LD_ADDR_VAR 0 7
110148: PUSH
110149: LD_INT 12
110151: ST_TO_ADDR
// side := GetSide ( unit ) ;
110152: LD_ADDR_VAR 0 6
110156: PUSH
110157: LD_VAR 0 1
110161: PPUSH
110162: CALL_OW 255
110166: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110167: LD_INT 61
110169: PPUSH
110170: LD_VAR 0 6
110174: PPUSH
110175: CALL_OW 321
110179: PUSH
110180: LD_INT 2
110182: EQUAL
110183: IFFALSE 110193
// viewRange := 16 ;
110185: LD_ADDR_VAR 0 7
110189: PUSH
110190: LD_INT 16
110192: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110193: LD_VAR 0 1
110197: PPUSH
110198: LD_VAR 0 2
110202: PPUSH
110203: LD_VAR 0 3
110207: PPUSH
110208: CALL_OW 297
110212: PUSH
110213: LD_VAR 0 5
110217: GREATER
110218: IFFALSE 110297
// begin ComMoveXY ( unit , x , y ) ;
110220: LD_VAR 0 1
110224: PPUSH
110225: LD_VAR 0 2
110229: PPUSH
110230: LD_VAR 0 3
110234: PPUSH
110235: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110239: LD_INT 35
110241: PPUSH
110242: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110246: LD_VAR 0 1
110250: PPUSH
110251: LD_VAR 0 2
110255: PPUSH
110256: LD_VAR 0 3
110260: PPUSH
110261: CALL 85302 0 3
110265: NOT
110266: IFFALSE 110270
// exit ;
110268: GO 110524
// until GetDistUnitXY ( unit , x , y ) < dist ;
110270: LD_VAR 0 1
110274: PPUSH
110275: LD_VAR 0 2
110279: PPUSH
110280: LD_VAR 0 3
110284: PPUSH
110285: CALL_OW 297
110289: PUSH
110290: LD_VAR 0 5
110294: LESS
110295: IFFALSE 110239
// end ; ComTurnXY ( unit , x , y ) ;
110297: LD_VAR 0 1
110301: PPUSH
110302: LD_VAR 0 2
110306: PPUSH
110307: LD_VAR 0 3
110311: PPUSH
110312: CALL_OW 118
// wait ( 5 ) ;
110316: LD_INT 5
110318: PPUSH
110319: CALL_OW 67
// _d := GetDir ( unit ) ;
110323: LD_ADDR_VAR 0 10
110327: PUSH
110328: LD_VAR 0 1
110332: PPUSH
110333: CALL_OW 254
110337: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110338: LD_ADDR_VAR 0 8
110342: PUSH
110343: LD_VAR 0 1
110347: PPUSH
110348: CALL_OW 250
110352: PPUSH
110353: LD_VAR 0 10
110357: PPUSH
110358: LD_VAR 0 5
110362: PPUSH
110363: CALL_OW 272
110367: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110368: LD_ADDR_VAR 0 9
110372: PUSH
110373: LD_VAR 0 1
110377: PPUSH
110378: CALL_OW 251
110382: PPUSH
110383: LD_VAR 0 10
110387: PPUSH
110388: LD_VAR 0 5
110392: PPUSH
110393: CALL_OW 273
110397: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110398: LD_VAR 0 8
110402: PPUSH
110403: LD_VAR 0 9
110407: PPUSH
110408: CALL_OW 488
110412: NOT
110413: IFFALSE 110417
// exit ;
110415: GO 110524
// ComAnimCustom ( unit , 1 ) ;
110417: LD_VAR 0 1
110421: PPUSH
110422: LD_INT 1
110424: PPUSH
110425: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110429: LD_VAR 0 8
110433: PPUSH
110434: LD_VAR 0 9
110438: PPUSH
110439: LD_VAR 0 6
110443: PPUSH
110444: LD_VAR 0 7
110448: PPUSH
110449: CALL_OW 330
// repeat wait ( 1 ) ;
110453: LD_INT 1
110455: PPUSH
110456: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110460: LD_VAR 0 1
110464: PPUSH
110465: CALL_OW 316
110469: PUSH
110470: LD_VAR 0 1
110474: PPUSH
110475: CALL_OW 314
110479: OR
110480: PUSH
110481: LD_VAR 0 1
110485: PPUSH
110486: CALL_OW 302
110490: NOT
110491: OR
110492: PUSH
110493: LD_VAR 0 1
110497: PPUSH
110498: CALL_OW 301
110502: OR
110503: IFFALSE 110453
// RemoveSeeing ( _x , _y , side ) ;
110505: LD_VAR 0 8
110509: PPUSH
110510: LD_VAR 0 9
110514: PPUSH
110515: LD_VAR 0 6
110519: PPUSH
110520: CALL_OW 331
// end ; end_of_file
110524: LD_VAR 0 4
110528: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110529: LD_INT 0
110531: PPUSH
110532: PPUSH
110533: PPUSH
110534: PPUSH
110535: PPUSH
110536: PPUSH
110537: PPUSH
110538: PPUSH
110539: PPUSH
110540: PPUSH
110541: PPUSH
110542: PPUSH
110543: PPUSH
110544: PPUSH
110545: PPUSH
110546: PPUSH
110547: PPUSH
110548: PPUSH
110549: PPUSH
110550: PPUSH
110551: PPUSH
110552: PPUSH
110553: PPUSH
110554: PPUSH
110555: PPUSH
110556: PPUSH
110557: PPUSH
110558: PPUSH
110559: PPUSH
110560: PPUSH
110561: PPUSH
110562: PPUSH
110563: PPUSH
110564: PPUSH
// if not list then
110565: LD_VAR 0 1
110569: NOT
110570: IFFALSE 110574
// exit ;
110572: GO 115233
// base := list [ 1 ] ;
110574: LD_ADDR_VAR 0 3
110578: PUSH
110579: LD_VAR 0 1
110583: PUSH
110584: LD_INT 1
110586: ARRAY
110587: ST_TO_ADDR
// group := list [ 2 ] ;
110588: LD_ADDR_VAR 0 4
110592: PUSH
110593: LD_VAR 0 1
110597: PUSH
110598: LD_INT 2
110600: ARRAY
110601: ST_TO_ADDR
// path := list [ 3 ] ;
110602: LD_ADDR_VAR 0 5
110606: PUSH
110607: LD_VAR 0 1
110611: PUSH
110612: LD_INT 3
110614: ARRAY
110615: ST_TO_ADDR
// flags := list [ 4 ] ;
110616: LD_ADDR_VAR 0 6
110620: PUSH
110621: LD_VAR 0 1
110625: PUSH
110626: LD_INT 4
110628: ARRAY
110629: ST_TO_ADDR
// mined := [ ] ;
110630: LD_ADDR_VAR 0 27
110634: PUSH
110635: EMPTY
110636: ST_TO_ADDR
// bombed := [ ] ;
110637: LD_ADDR_VAR 0 28
110641: PUSH
110642: EMPTY
110643: ST_TO_ADDR
// healers := [ ] ;
110644: LD_ADDR_VAR 0 31
110648: PUSH
110649: EMPTY
110650: ST_TO_ADDR
// to_heal := [ ] ;
110651: LD_ADDR_VAR 0 30
110655: PUSH
110656: EMPTY
110657: ST_TO_ADDR
// repairs := [ ] ;
110658: LD_ADDR_VAR 0 33
110662: PUSH
110663: EMPTY
110664: ST_TO_ADDR
// to_repair := [ ] ;
110665: LD_ADDR_VAR 0 32
110669: PUSH
110670: EMPTY
110671: ST_TO_ADDR
// if not group or not path then
110672: LD_VAR 0 4
110676: NOT
110677: PUSH
110678: LD_VAR 0 5
110682: NOT
110683: OR
110684: IFFALSE 110688
// exit ;
110686: GO 115233
// side := GetSide ( group [ 1 ] ) ;
110688: LD_ADDR_VAR 0 35
110692: PUSH
110693: LD_VAR 0 4
110697: PUSH
110698: LD_INT 1
110700: ARRAY
110701: PPUSH
110702: CALL_OW 255
110706: ST_TO_ADDR
// if flags then
110707: LD_VAR 0 6
110711: IFFALSE 110855
// begin f_ignore_area := flags [ 1 ] ;
110713: LD_ADDR_VAR 0 17
110717: PUSH
110718: LD_VAR 0 6
110722: PUSH
110723: LD_INT 1
110725: ARRAY
110726: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110727: LD_ADDR_VAR 0 18
110731: PUSH
110732: LD_VAR 0 6
110736: PUSH
110737: LD_INT 2
110739: ARRAY
110740: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110741: LD_ADDR_VAR 0 19
110745: PUSH
110746: LD_VAR 0 6
110750: PUSH
110751: LD_INT 3
110753: ARRAY
110754: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110755: LD_ADDR_VAR 0 20
110759: PUSH
110760: LD_VAR 0 6
110764: PUSH
110765: LD_INT 4
110767: ARRAY
110768: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110769: LD_ADDR_VAR 0 21
110773: PUSH
110774: LD_VAR 0 6
110778: PUSH
110779: LD_INT 5
110781: ARRAY
110782: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110783: LD_ADDR_VAR 0 22
110787: PUSH
110788: LD_VAR 0 6
110792: PUSH
110793: LD_INT 6
110795: ARRAY
110796: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110797: LD_ADDR_VAR 0 23
110801: PUSH
110802: LD_VAR 0 6
110806: PUSH
110807: LD_INT 7
110809: ARRAY
110810: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110811: LD_ADDR_VAR 0 24
110815: PUSH
110816: LD_VAR 0 6
110820: PUSH
110821: LD_INT 8
110823: ARRAY
110824: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110825: LD_ADDR_VAR 0 25
110829: PUSH
110830: LD_VAR 0 6
110834: PUSH
110835: LD_INT 9
110837: ARRAY
110838: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110839: LD_ADDR_VAR 0 26
110843: PUSH
110844: LD_VAR 0 6
110848: PUSH
110849: LD_INT 10
110851: ARRAY
110852: ST_TO_ADDR
// end else
110853: GO 110935
// begin f_ignore_area := false ;
110855: LD_ADDR_VAR 0 17
110859: PUSH
110860: LD_INT 0
110862: ST_TO_ADDR
// f_capture := false ;
110863: LD_ADDR_VAR 0 18
110867: PUSH
110868: LD_INT 0
110870: ST_TO_ADDR
// f_ignore_civ := false ;
110871: LD_ADDR_VAR 0 19
110875: PUSH
110876: LD_INT 0
110878: ST_TO_ADDR
// f_murder := false ;
110879: LD_ADDR_VAR 0 20
110883: PUSH
110884: LD_INT 0
110886: ST_TO_ADDR
// f_mines := false ;
110887: LD_ADDR_VAR 0 21
110891: PUSH
110892: LD_INT 0
110894: ST_TO_ADDR
// f_repair := false ;
110895: LD_ADDR_VAR 0 22
110899: PUSH
110900: LD_INT 0
110902: ST_TO_ADDR
// f_heal := false ;
110903: LD_ADDR_VAR 0 23
110907: PUSH
110908: LD_INT 0
110910: ST_TO_ADDR
// f_spacetime := false ;
110911: LD_ADDR_VAR 0 24
110915: PUSH
110916: LD_INT 0
110918: ST_TO_ADDR
// f_attack_depot := false ;
110919: LD_ADDR_VAR 0 25
110923: PUSH
110924: LD_INT 0
110926: ST_TO_ADDR
// f_crawl := false ;
110927: LD_ADDR_VAR 0 26
110931: PUSH
110932: LD_INT 0
110934: ST_TO_ADDR
// end ; if f_heal then
110935: LD_VAR 0 23
110939: IFFALSE 110966
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110941: LD_ADDR_VAR 0 31
110945: PUSH
110946: LD_VAR 0 4
110950: PPUSH
110951: LD_INT 25
110953: PUSH
110954: LD_INT 4
110956: PUSH
110957: EMPTY
110958: LIST
110959: LIST
110960: PPUSH
110961: CALL_OW 72
110965: ST_TO_ADDR
// if f_repair then
110966: LD_VAR 0 22
110970: IFFALSE 110997
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110972: LD_ADDR_VAR 0 33
110976: PUSH
110977: LD_VAR 0 4
110981: PPUSH
110982: LD_INT 25
110984: PUSH
110985: LD_INT 3
110987: PUSH
110988: EMPTY
110989: LIST
110990: LIST
110991: PPUSH
110992: CALL_OW 72
110996: ST_TO_ADDR
// units_path := [ ] ;
110997: LD_ADDR_VAR 0 16
111001: PUSH
111002: EMPTY
111003: ST_TO_ADDR
// for i = 1 to group do
111004: LD_ADDR_VAR 0 7
111008: PUSH
111009: DOUBLE
111010: LD_INT 1
111012: DEC
111013: ST_TO_ADDR
111014: LD_VAR 0 4
111018: PUSH
111019: FOR_TO
111020: IFFALSE 111049
// units_path := Replace ( units_path , i , path ) ;
111022: LD_ADDR_VAR 0 16
111026: PUSH
111027: LD_VAR 0 16
111031: PPUSH
111032: LD_VAR 0 7
111036: PPUSH
111037: LD_VAR 0 5
111041: PPUSH
111042: CALL_OW 1
111046: ST_TO_ADDR
111047: GO 111019
111049: POP
111050: POP
// repeat for i = group downto 1 do
111051: LD_ADDR_VAR 0 7
111055: PUSH
111056: DOUBLE
111057: LD_VAR 0 4
111061: INC
111062: ST_TO_ADDR
111063: LD_INT 1
111065: PUSH
111066: FOR_DOWNTO
111067: IFFALSE 115189
// begin wait ( 5 ) ;
111069: LD_INT 5
111071: PPUSH
111072: CALL_OW 67
// tmp := [ ] ;
111076: LD_ADDR_VAR 0 14
111080: PUSH
111081: EMPTY
111082: ST_TO_ADDR
// attacking := false ;
111083: LD_ADDR_VAR 0 29
111087: PUSH
111088: LD_INT 0
111090: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111091: LD_VAR 0 4
111095: PUSH
111096: LD_VAR 0 7
111100: ARRAY
111101: PPUSH
111102: CALL_OW 301
111106: PUSH
111107: LD_VAR 0 4
111111: PUSH
111112: LD_VAR 0 7
111116: ARRAY
111117: NOT
111118: OR
111119: IFFALSE 111228
// begin if GetType ( group [ i ] ) = unit_human then
111121: LD_VAR 0 4
111125: PUSH
111126: LD_VAR 0 7
111130: ARRAY
111131: PPUSH
111132: CALL_OW 247
111136: PUSH
111137: LD_INT 1
111139: EQUAL
111140: IFFALSE 111186
// begin to_heal := to_heal diff group [ i ] ;
111142: LD_ADDR_VAR 0 30
111146: PUSH
111147: LD_VAR 0 30
111151: PUSH
111152: LD_VAR 0 4
111156: PUSH
111157: LD_VAR 0 7
111161: ARRAY
111162: DIFF
111163: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111164: LD_ADDR_VAR 0 31
111168: PUSH
111169: LD_VAR 0 31
111173: PUSH
111174: LD_VAR 0 4
111178: PUSH
111179: LD_VAR 0 7
111183: ARRAY
111184: DIFF
111185: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111186: LD_ADDR_VAR 0 4
111190: PUSH
111191: LD_VAR 0 4
111195: PPUSH
111196: LD_VAR 0 7
111200: PPUSH
111201: CALL_OW 3
111205: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111206: LD_ADDR_VAR 0 16
111210: PUSH
111211: LD_VAR 0 16
111215: PPUSH
111216: LD_VAR 0 7
111220: PPUSH
111221: CALL_OW 3
111225: ST_TO_ADDR
// continue ;
111226: GO 111066
// end ; if f_repair then
111228: LD_VAR 0 22
111232: IFFALSE 111721
// begin if GetType ( group [ i ] ) = unit_vehicle then
111234: LD_VAR 0 4
111238: PUSH
111239: LD_VAR 0 7
111243: ARRAY
111244: PPUSH
111245: CALL_OW 247
111249: PUSH
111250: LD_INT 2
111252: EQUAL
111253: IFFALSE 111443
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111255: LD_VAR 0 4
111259: PUSH
111260: LD_VAR 0 7
111264: ARRAY
111265: PPUSH
111266: CALL_OW 256
111270: PUSH
111271: LD_INT 700
111273: LESS
111274: PUSH
111275: LD_VAR 0 4
111279: PUSH
111280: LD_VAR 0 7
111284: ARRAY
111285: PUSH
111286: LD_VAR 0 32
111290: IN
111291: NOT
111292: AND
111293: IFFALSE 111317
// to_repair := to_repair union group [ i ] ;
111295: LD_ADDR_VAR 0 32
111299: PUSH
111300: LD_VAR 0 32
111304: PUSH
111305: LD_VAR 0 4
111309: PUSH
111310: LD_VAR 0 7
111314: ARRAY
111315: UNION
111316: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111317: LD_VAR 0 4
111321: PUSH
111322: LD_VAR 0 7
111326: ARRAY
111327: PPUSH
111328: CALL_OW 256
111332: PUSH
111333: LD_INT 1000
111335: EQUAL
111336: PUSH
111337: LD_VAR 0 4
111341: PUSH
111342: LD_VAR 0 7
111346: ARRAY
111347: PUSH
111348: LD_VAR 0 32
111352: IN
111353: AND
111354: IFFALSE 111378
// to_repair := to_repair diff group [ i ] ;
111356: LD_ADDR_VAR 0 32
111360: PUSH
111361: LD_VAR 0 32
111365: PUSH
111366: LD_VAR 0 4
111370: PUSH
111371: LD_VAR 0 7
111375: ARRAY
111376: DIFF
111377: ST_TO_ADDR
// if group [ i ] in to_repair then
111378: LD_VAR 0 4
111382: PUSH
111383: LD_VAR 0 7
111387: ARRAY
111388: PUSH
111389: LD_VAR 0 32
111393: IN
111394: IFFALSE 111441
// begin if not IsInArea ( group [ i ] , f_repair ) then
111396: LD_VAR 0 4
111400: PUSH
111401: LD_VAR 0 7
111405: ARRAY
111406: PPUSH
111407: LD_VAR 0 22
111411: PPUSH
111412: CALL_OW 308
111416: NOT
111417: IFFALSE 111439
// ComMoveToArea ( group [ i ] , f_repair ) ;
111419: LD_VAR 0 4
111423: PUSH
111424: LD_VAR 0 7
111428: ARRAY
111429: PPUSH
111430: LD_VAR 0 22
111434: PPUSH
111435: CALL_OW 113
// continue ;
111439: GO 111066
// end ; end else
111441: GO 111721
// if group [ i ] in repairs then
111443: LD_VAR 0 4
111447: PUSH
111448: LD_VAR 0 7
111452: ARRAY
111453: PUSH
111454: LD_VAR 0 33
111458: IN
111459: IFFALSE 111721
// begin if IsInUnit ( group [ i ] ) then
111461: LD_VAR 0 4
111465: PUSH
111466: LD_VAR 0 7
111470: ARRAY
111471: PPUSH
111472: CALL_OW 310
111476: IFFALSE 111544
// begin z := IsInUnit ( group [ i ] ) ;
111478: LD_ADDR_VAR 0 13
111482: PUSH
111483: LD_VAR 0 4
111487: PUSH
111488: LD_VAR 0 7
111492: ARRAY
111493: PPUSH
111494: CALL_OW 310
111498: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111499: LD_VAR 0 13
111503: PUSH
111504: LD_VAR 0 32
111508: IN
111509: PUSH
111510: LD_VAR 0 13
111514: PPUSH
111515: LD_VAR 0 22
111519: PPUSH
111520: CALL_OW 308
111524: AND
111525: IFFALSE 111542
// ComExitVehicle ( group [ i ] ) ;
111527: LD_VAR 0 4
111531: PUSH
111532: LD_VAR 0 7
111536: ARRAY
111537: PPUSH
111538: CALL_OW 121
// end else
111542: GO 111721
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111544: LD_ADDR_VAR 0 13
111548: PUSH
111549: LD_VAR 0 4
111553: PPUSH
111554: LD_INT 95
111556: PUSH
111557: LD_VAR 0 22
111561: PUSH
111562: EMPTY
111563: LIST
111564: LIST
111565: PUSH
111566: LD_INT 58
111568: PUSH
111569: EMPTY
111570: LIST
111571: PUSH
111572: EMPTY
111573: LIST
111574: LIST
111575: PPUSH
111576: CALL_OW 72
111580: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111581: LD_VAR 0 4
111585: PUSH
111586: LD_VAR 0 7
111590: ARRAY
111591: PPUSH
111592: CALL_OW 314
111596: NOT
111597: IFFALSE 111719
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111599: LD_ADDR_VAR 0 10
111603: PUSH
111604: LD_VAR 0 13
111608: PPUSH
111609: LD_VAR 0 4
111613: PUSH
111614: LD_VAR 0 7
111618: ARRAY
111619: PPUSH
111620: CALL_OW 74
111624: ST_TO_ADDR
// if not x then
111625: LD_VAR 0 10
111629: NOT
111630: IFFALSE 111634
// continue ;
111632: GO 111066
// if GetLives ( x ) < 1000 then
111634: LD_VAR 0 10
111638: PPUSH
111639: CALL_OW 256
111643: PUSH
111644: LD_INT 1000
111646: LESS
111647: IFFALSE 111671
// ComRepairVehicle ( group [ i ] , x ) else
111649: LD_VAR 0 4
111653: PUSH
111654: LD_VAR 0 7
111658: ARRAY
111659: PPUSH
111660: LD_VAR 0 10
111664: PPUSH
111665: CALL_OW 129
111669: GO 111719
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111671: LD_VAR 0 23
111675: PUSH
111676: LD_VAR 0 4
111680: PUSH
111681: LD_VAR 0 7
111685: ARRAY
111686: PPUSH
111687: CALL_OW 256
111691: PUSH
111692: LD_INT 1000
111694: LESS
111695: AND
111696: NOT
111697: IFFALSE 111719
// ComEnterUnit ( group [ i ] , x ) ;
111699: LD_VAR 0 4
111703: PUSH
111704: LD_VAR 0 7
111708: ARRAY
111709: PPUSH
111710: LD_VAR 0 10
111714: PPUSH
111715: CALL_OW 120
// end ; continue ;
111719: GO 111066
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111721: LD_VAR 0 23
111725: PUSH
111726: LD_VAR 0 4
111730: PUSH
111731: LD_VAR 0 7
111735: ARRAY
111736: PPUSH
111737: CALL_OW 247
111741: PUSH
111742: LD_INT 1
111744: EQUAL
111745: AND
111746: IFFALSE 112224
// begin if group [ i ] in healers then
111748: LD_VAR 0 4
111752: PUSH
111753: LD_VAR 0 7
111757: ARRAY
111758: PUSH
111759: LD_VAR 0 31
111763: IN
111764: IFFALSE 112037
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111766: LD_VAR 0 4
111770: PUSH
111771: LD_VAR 0 7
111775: ARRAY
111776: PPUSH
111777: LD_VAR 0 23
111781: PPUSH
111782: CALL_OW 308
111786: NOT
111787: PUSH
111788: LD_VAR 0 4
111792: PUSH
111793: LD_VAR 0 7
111797: ARRAY
111798: PPUSH
111799: CALL_OW 314
111803: NOT
111804: AND
111805: IFFALSE 111829
// ComMoveToArea ( group [ i ] , f_heal ) else
111807: LD_VAR 0 4
111811: PUSH
111812: LD_VAR 0 7
111816: ARRAY
111817: PPUSH
111818: LD_VAR 0 23
111822: PPUSH
111823: CALL_OW 113
111827: GO 112035
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111829: LD_VAR 0 4
111833: PUSH
111834: LD_VAR 0 7
111838: ARRAY
111839: PPUSH
111840: CALL 83885 0 1
111844: PPUSH
111845: CALL_OW 256
111849: PUSH
111850: LD_INT 1000
111852: EQUAL
111853: IFFALSE 111872
// ComStop ( group [ i ] ) else
111855: LD_VAR 0 4
111859: PUSH
111860: LD_VAR 0 7
111864: ARRAY
111865: PPUSH
111866: CALL_OW 141
111870: GO 112035
// if not HasTask ( group [ i ] ) and to_heal then
111872: LD_VAR 0 4
111876: PUSH
111877: LD_VAR 0 7
111881: ARRAY
111882: PPUSH
111883: CALL_OW 314
111887: NOT
111888: PUSH
111889: LD_VAR 0 30
111893: AND
111894: IFFALSE 112035
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111896: LD_ADDR_VAR 0 13
111900: PUSH
111901: LD_VAR 0 30
111905: PPUSH
111906: LD_INT 3
111908: PUSH
111909: LD_INT 54
111911: PUSH
111912: EMPTY
111913: LIST
111914: PUSH
111915: EMPTY
111916: LIST
111917: LIST
111918: PPUSH
111919: CALL_OW 72
111923: PPUSH
111924: LD_VAR 0 4
111928: PUSH
111929: LD_VAR 0 7
111933: ARRAY
111934: PPUSH
111935: CALL_OW 74
111939: ST_TO_ADDR
// if z then
111940: LD_VAR 0 13
111944: IFFALSE 112035
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111946: LD_INT 91
111948: PUSH
111949: LD_VAR 0 13
111953: PUSH
111954: LD_INT 10
111956: PUSH
111957: EMPTY
111958: LIST
111959: LIST
111960: LIST
111961: PUSH
111962: LD_INT 81
111964: PUSH
111965: LD_VAR 0 13
111969: PPUSH
111970: CALL_OW 255
111974: PUSH
111975: EMPTY
111976: LIST
111977: LIST
111978: PUSH
111979: EMPTY
111980: LIST
111981: LIST
111982: PPUSH
111983: CALL_OW 69
111987: PUSH
111988: LD_INT 0
111990: EQUAL
111991: IFFALSE 112015
// ComHeal ( group [ i ] , z ) else
111993: LD_VAR 0 4
111997: PUSH
111998: LD_VAR 0 7
112002: ARRAY
112003: PPUSH
112004: LD_VAR 0 13
112008: PPUSH
112009: CALL_OW 128
112013: GO 112035
// ComMoveToArea ( group [ i ] , f_heal ) ;
112015: LD_VAR 0 4
112019: PUSH
112020: LD_VAR 0 7
112024: ARRAY
112025: PPUSH
112026: LD_VAR 0 23
112030: PPUSH
112031: CALL_OW 113
// end ; continue ;
112035: GO 111066
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112037: LD_VAR 0 4
112041: PUSH
112042: LD_VAR 0 7
112046: ARRAY
112047: PPUSH
112048: CALL_OW 256
112052: PUSH
112053: LD_INT 700
112055: LESS
112056: PUSH
112057: LD_VAR 0 4
112061: PUSH
112062: LD_VAR 0 7
112066: ARRAY
112067: PUSH
112068: LD_VAR 0 30
112072: IN
112073: NOT
112074: AND
112075: IFFALSE 112099
// to_heal := to_heal union group [ i ] ;
112077: LD_ADDR_VAR 0 30
112081: PUSH
112082: LD_VAR 0 30
112086: PUSH
112087: LD_VAR 0 4
112091: PUSH
112092: LD_VAR 0 7
112096: ARRAY
112097: UNION
112098: ST_TO_ADDR
// if group [ i ] in to_heal then
112099: LD_VAR 0 4
112103: PUSH
112104: LD_VAR 0 7
112108: ARRAY
112109: PUSH
112110: LD_VAR 0 30
112114: IN
112115: IFFALSE 112224
// begin if GetLives ( group [ i ] ) = 1000 then
112117: LD_VAR 0 4
112121: PUSH
112122: LD_VAR 0 7
112126: ARRAY
112127: PPUSH
112128: CALL_OW 256
112132: PUSH
112133: LD_INT 1000
112135: EQUAL
112136: IFFALSE 112162
// to_heal := to_heal diff group [ i ] else
112138: LD_ADDR_VAR 0 30
112142: PUSH
112143: LD_VAR 0 30
112147: PUSH
112148: LD_VAR 0 4
112152: PUSH
112153: LD_VAR 0 7
112157: ARRAY
112158: DIFF
112159: ST_TO_ADDR
112160: GO 112224
// begin if not IsInArea ( group [ i ] , to_heal ) then
112162: LD_VAR 0 4
112166: PUSH
112167: LD_VAR 0 7
112171: ARRAY
112172: PPUSH
112173: LD_VAR 0 30
112177: PPUSH
112178: CALL_OW 308
112182: NOT
112183: IFFALSE 112207
// ComMoveToArea ( group [ i ] , f_heal ) else
112185: LD_VAR 0 4
112189: PUSH
112190: LD_VAR 0 7
112194: ARRAY
112195: PPUSH
112196: LD_VAR 0 23
112200: PPUSH
112201: CALL_OW 113
112205: GO 112222
// ComHold ( group [ i ] ) ;
112207: LD_VAR 0 4
112211: PUSH
112212: LD_VAR 0 7
112216: ARRAY
112217: PPUSH
112218: CALL_OW 140
// continue ;
112222: GO 111066
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112224: LD_VAR 0 4
112228: PUSH
112229: LD_VAR 0 7
112233: ARRAY
112234: PPUSH
112235: LD_INT 10
112237: PPUSH
112238: CALL 81656 0 2
112242: NOT
112243: PUSH
112244: LD_VAR 0 16
112248: PUSH
112249: LD_VAR 0 7
112253: ARRAY
112254: PUSH
112255: EMPTY
112256: EQUAL
112257: NOT
112258: AND
112259: IFFALSE 112525
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112261: LD_VAR 0 4
112265: PUSH
112266: LD_VAR 0 7
112270: ARRAY
112271: PPUSH
112272: CALL_OW 262
112276: PUSH
112277: LD_INT 1
112279: PUSH
112280: LD_INT 2
112282: PUSH
112283: EMPTY
112284: LIST
112285: LIST
112286: IN
112287: IFFALSE 112328
// if GetFuel ( group [ i ] ) < 10 then
112289: LD_VAR 0 4
112293: PUSH
112294: LD_VAR 0 7
112298: ARRAY
112299: PPUSH
112300: CALL_OW 261
112304: PUSH
112305: LD_INT 10
112307: LESS
112308: IFFALSE 112328
// SetFuel ( group [ i ] , 12 ) ;
112310: LD_VAR 0 4
112314: PUSH
112315: LD_VAR 0 7
112319: ARRAY
112320: PPUSH
112321: LD_INT 12
112323: PPUSH
112324: CALL_OW 240
// if units_path [ i ] then
112328: LD_VAR 0 16
112332: PUSH
112333: LD_VAR 0 7
112337: ARRAY
112338: IFFALSE 112523
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112340: LD_VAR 0 4
112344: PUSH
112345: LD_VAR 0 7
112349: ARRAY
112350: PPUSH
112351: LD_VAR 0 16
112355: PUSH
112356: LD_VAR 0 7
112360: ARRAY
112361: PUSH
112362: LD_INT 1
112364: ARRAY
112365: PUSH
112366: LD_INT 1
112368: ARRAY
112369: PPUSH
112370: LD_VAR 0 16
112374: PUSH
112375: LD_VAR 0 7
112379: ARRAY
112380: PUSH
112381: LD_INT 1
112383: ARRAY
112384: PUSH
112385: LD_INT 2
112387: ARRAY
112388: PPUSH
112389: CALL_OW 297
112393: PUSH
112394: LD_INT 6
112396: GREATER
112397: IFFALSE 112472
// begin if not HasTask ( group [ i ] ) then
112399: LD_VAR 0 4
112403: PUSH
112404: LD_VAR 0 7
112408: ARRAY
112409: PPUSH
112410: CALL_OW 314
112414: NOT
112415: IFFALSE 112470
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112417: LD_VAR 0 4
112421: PUSH
112422: LD_VAR 0 7
112426: ARRAY
112427: PPUSH
112428: LD_VAR 0 16
112432: PUSH
112433: LD_VAR 0 7
112437: ARRAY
112438: PUSH
112439: LD_INT 1
112441: ARRAY
112442: PUSH
112443: LD_INT 1
112445: ARRAY
112446: PPUSH
112447: LD_VAR 0 16
112451: PUSH
112452: LD_VAR 0 7
112456: ARRAY
112457: PUSH
112458: LD_INT 1
112460: ARRAY
112461: PUSH
112462: LD_INT 2
112464: ARRAY
112465: PPUSH
112466: CALL_OW 114
// end else
112470: GO 112523
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112472: LD_ADDR_VAR 0 15
112476: PUSH
112477: LD_VAR 0 16
112481: PUSH
112482: LD_VAR 0 7
112486: ARRAY
112487: PPUSH
112488: LD_INT 1
112490: PPUSH
112491: CALL_OW 3
112495: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112496: LD_ADDR_VAR 0 16
112500: PUSH
112501: LD_VAR 0 16
112505: PPUSH
112506: LD_VAR 0 7
112510: PPUSH
112511: LD_VAR 0 15
112515: PPUSH
112516: CALL_OW 1
112520: ST_TO_ADDR
// continue ;
112521: GO 111066
// end ; end ; end else
112523: GO 115187
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112525: LD_ADDR_VAR 0 14
112529: PUSH
112530: LD_INT 81
112532: PUSH
112533: LD_VAR 0 4
112537: PUSH
112538: LD_VAR 0 7
112542: ARRAY
112543: PPUSH
112544: CALL_OW 255
112548: PUSH
112549: EMPTY
112550: LIST
112551: LIST
112552: PPUSH
112553: CALL_OW 69
112557: ST_TO_ADDR
// if not tmp then
112558: LD_VAR 0 14
112562: NOT
112563: IFFALSE 112567
// continue ;
112565: GO 111066
// if f_ignore_area then
112567: LD_VAR 0 17
112571: IFFALSE 112659
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112573: LD_ADDR_VAR 0 15
112577: PUSH
112578: LD_VAR 0 14
112582: PPUSH
112583: LD_INT 3
112585: PUSH
112586: LD_INT 92
112588: PUSH
112589: LD_VAR 0 17
112593: PUSH
112594: LD_INT 1
112596: ARRAY
112597: PUSH
112598: LD_VAR 0 17
112602: PUSH
112603: LD_INT 2
112605: ARRAY
112606: PUSH
112607: LD_VAR 0 17
112611: PUSH
112612: LD_INT 3
112614: ARRAY
112615: PUSH
112616: EMPTY
112617: LIST
112618: LIST
112619: LIST
112620: LIST
112621: PUSH
112622: EMPTY
112623: LIST
112624: LIST
112625: PPUSH
112626: CALL_OW 72
112630: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112631: LD_VAR 0 14
112635: PUSH
112636: LD_VAR 0 15
112640: DIFF
112641: IFFALSE 112659
// tmp := tmp diff tmp2 ;
112643: LD_ADDR_VAR 0 14
112647: PUSH
112648: LD_VAR 0 14
112652: PUSH
112653: LD_VAR 0 15
112657: DIFF
112658: ST_TO_ADDR
// end ; if not f_murder then
112659: LD_VAR 0 20
112663: NOT
112664: IFFALSE 112722
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112666: LD_ADDR_VAR 0 15
112670: PUSH
112671: LD_VAR 0 14
112675: PPUSH
112676: LD_INT 3
112678: PUSH
112679: LD_INT 50
112681: PUSH
112682: EMPTY
112683: LIST
112684: PUSH
112685: EMPTY
112686: LIST
112687: LIST
112688: PPUSH
112689: CALL_OW 72
112693: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112694: LD_VAR 0 14
112698: PUSH
112699: LD_VAR 0 15
112703: DIFF
112704: IFFALSE 112722
// tmp := tmp diff tmp2 ;
112706: LD_ADDR_VAR 0 14
112710: PUSH
112711: LD_VAR 0 14
112715: PUSH
112716: LD_VAR 0 15
112720: DIFF
112721: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112722: LD_ADDR_VAR 0 14
112726: PUSH
112727: LD_VAR 0 4
112731: PUSH
112732: LD_VAR 0 7
112736: ARRAY
112737: PPUSH
112738: LD_VAR 0 14
112742: PPUSH
112743: LD_INT 1
112745: PPUSH
112746: LD_INT 1
112748: PPUSH
112749: CALL 54597 0 4
112753: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112754: LD_VAR 0 4
112758: PUSH
112759: LD_VAR 0 7
112763: ARRAY
112764: PPUSH
112765: CALL_OW 257
112769: PUSH
112770: LD_INT 1
112772: EQUAL
112773: IFFALSE 113221
// begin if WantPlant ( group [ i ] ) then
112775: LD_VAR 0 4
112779: PUSH
112780: LD_VAR 0 7
112784: ARRAY
112785: PPUSH
112786: CALL 54098 0 1
112790: IFFALSE 112794
// continue ;
112792: GO 111066
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112794: LD_VAR 0 18
112798: PUSH
112799: LD_VAR 0 4
112803: PUSH
112804: LD_VAR 0 7
112808: ARRAY
112809: PPUSH
112810: CALL_OW 310
112814: NOT
112815: AND
112816: PUSH
112817: LD_VAR 0 14
112821: PUSH
112822: LD_INT 1
112824: ARRAY
112825: PUSH
112826: LD_VAR 0 14
112830: PPUSH
112831: LD_INT 21
112833: PUSH
112834: LD_INT 2
112836: PUSH
112837: EMPTY
112838: LIST
112839: LIST
112840: PUSH
112841: LD_INT 58
112843: PUSH
112844: EMPTY
112845: LIST
112846: PUSH
112847: EMPTY
112848: LIST
112849: LIST
112850: PPUSH
112851: CALL_OW 72
112855: IN
112856: AND
112857: IFFALSE 112893
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112859: LD_VAR 0 4
112863: PUSH
112864: LD_VAR 0 7
112868: ARRAY
112869: PPUSH
112870: LD_VAR 0 14
112874: PUSH
112875: LD_INT 1
112877: ARRAY
112878: PPUSH
112879: CALL_OW 120
// attacking := true ;
112883: LD_ADDR_VAR 0 29
112887: PUSH
112888: LD_INT 1
112890: ST_TO_ADDR
// continue ;
112891: GO 111066
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112893: LD_VAR 0 26
112897: PUSH
112898: LD_VAR 0 4
112902: PUSH
112903: LD_VAR 0 7
112907: ARRAY
112908: PPUSH
112909: CALL_OW 257
112913: PUSH
112914: LD_INT 1
112916: EQUAL
112917: AND
112918: PUSH
112919: LD_VAR 0 4
112923: PUSH
112924: LD_VAR 0 7
112928: ARRAY
112929: PPUSH
112930: CALL_OW 256
112934: PUSH
112935: LD_INT 800
112937: LESS
112938: AND
112939: PUSH
112940: LD_VAR 0 4
112944: PUSH
112945: LD_VAR 0 7
112949: ARRAY
112950: PPUSH
112951: CALL_OW 318
112955: NOT
112956: AND
112957: IFFALSE 112974
// ComCrawl ( group [ i ] ) ;
112959: LD_VAR 0 4
112963: PUSH
112964: LD_VAR 0 7
112968: ARRAY
112969: PPUSH
112970: CALL_OW 137
// if f_mines then
112974: LD_VAR 0 21
112978: IFFALSE 113221
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112980: LD_VAR 0 14
112984: PUSH
112985: LD_INT 1
112987: ARRAY
112988: PPUSH
112989: CALL_OW 247
112993: PUSH
112994: LD_INT 3
112996: EQUAL
112997: PUSH
112998: LD_VAR 0 14
113002: PUSH
113003: LD_INT 1
113005: ARRAY
113006: PUSH
113007: LD_VAR 0 27
113011: IN
113012: NOT
113013: AND
113014: IFFALSE 113221
// begin x := GetX ( tmp [ 1 ] ) ;
113016: LD_ADDR_VAR 0 10
113020: PUSH
113021: LD_VAR 0 14
113025: PUSH
113026: LD_INT 1
113028: ARRAY
113029: PPUSH
113030: CALL_OW 250
113034: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113035: LD_ADDR_VAR 0 11
113039: PUSH
113040: LD_VAR 0 14
113044: PUSH
113045: LD_INT 1
113047: ARRAY
113048: PPUSH
113049: CALL_OW 251
113053: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113054: LD_ADDR_VAR 0 12
113058: PUSH
113059: LD_VAR 0 4
113063: PUSH
113064: LD_VAR 0 7
113068: ARRAY
113069: PPUSH
113070: CALL 81741 0 1
113074: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113075: LD_VAR 0 4
113079: PUSH
113080: LD_VAR 0 7
113084: ARRAY
113085: PPUSH
113086: LD_VAR 0 10
113090: PPUSH
113091: LD_VAR 0 11
113095: PPUSH
113096: LD_VAR 0 14
113100: PUSH
113101: LD_INT 1
113103: ARRAY
113104: PPUSH
113105: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113109: LD_VAR 0 4
113113: PUSH
113114: LD_VAR 0 7
113118: ARRAY
113119: PPUSH
113120: LD_VAR 0 10
113124: PPUSH
113125: LD_VAR 0 12
113129: PPUSH
113130: LD_INT 7
113132: PPUSH
113133: CALL_OW 272
113137: PPUSH
113138: LD_VAR 0 11
113142: PPUSH
113143: LD_VAR 0 12
113147: PPUSH
113148: LD_INT 7
113150: PPUSH
113151: CALL_OW 273
113155: PPUSH
113156: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113160: LD_VAR 0 4
113164: PUSH
113165: LD_VAR 0 7
113169: ARRAY
113170: PPUSH
113171: LD_INT 71
113173: PPUSH
113174: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113178: LD_ADDR_VAR 0 27
113182: PUSH
113183: LD_VAR 0 27
113187: PPUSH
113188: LD_VAR 0 27
113192: PUSH
113193: LD_INT 1
113195: PLUS
113196: PPUSH
113197: LD_VAR 0 14
113201: PUSH
113202: LD_INT 1
113204: ARRAY
113205: PPUSH
113206: CALL_OW 1
113210: ST_TO_ADDR
// attacking := true ;
113211: LD_ADDR_VAR 0 29
113215: PUSH
113216: LD_INT 1
113218: ST_TO_ADDR
// continue ;
113219: GO 111066
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113221: LD_VAR 0 4
113225: PUSH
113226: LD_VAR 0 7
113230: ARRAY
113231: PPUSH
113232: CALL_OW 257
113236: PUSH
113237: LD_INT 17
113239: EQUAL
113240: PUSH
113241: LD_VAR 0 4
113245: PUSH
113246: LD_VAR 0 7
113250: ARRAY
113251: PPUSH
113252: CALL_OW 110
113256: PUSH
113257: LD_INT 71
113259: EQUAL
113260: NOT
113261: AND
113262: IFFALSE 113408
// begin attacking := false ;
113264: LD_ADDR_VAR 0 29
113268: PUSH
113269: LD_INT 0
113271: ST_TO_ADDR
// k := 5 ;
113272: LD_ADDR_VAR 0 9
113276: PUSH
113277: LD_INT 5
113279: ST_TO_ADDR
// if tmp < k then
113280: LD_VAR 0 14
113284: PUSH
113285: LD_VAR 0 9
113289: LESS
113290: IFFALSE 113302
// k := tmp ;
113292: LD_ADDR_VAR 0 9
113296: PUSH
113297: LD_VAR 0 14
113301: ST_TO_ADDR
// for j = 1 to k do
113302: LD_ADDR_VAR 0 8
113306: PUSH
113307: DOUBLE
113308: LD_INT 1
113310: DEC
113311: ST_TO_ADDR
113312: LD_VAR 0 9
113316: PUSH
113317: FOR_TO
113318: IFFALSE 113406
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113320: LD_VAR 0 14
113324: PUSH
113325: LD_VAR 0 8
113329: ARRAY
113330: PUSH
113331: LD_VAR 0 14
113335: PPUSH
113336: LD_INT 58
113338: PUSH
113339: EMPTY
113340: LIST
113341: PPUSH
113342: CALL_OW 72
113346: IN
113347: NOT
113348: IFFALSE 113404
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113350: LD_VAR 0 4
113354: PUSH
113355: LD_VAR 0 7
113359: ARRAY
113360: PPUSH
113361: LD_VAR 0 14
113365: PUSH
113366: LD_VAR 0 8
113370: ARRAY
113371: PPUSH
113372: CALL_OW 115
// attacking := true ;
113376: LD_ADDR_VAR 0 29
113380: PUSH
113381: LD_INT 1
113383: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113384: LD_VAR 0 4
113388: PUSH
113389: LD_VAR 0 7
113393: ARRAY
113394: PPUSH
113395: LD_INT 71
113397: PPUSH
113398: CALL_OW 109
// continue ;
113402: GO 113317
// end ; end ;
113404: GO 113317
113406: POP
113407: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113408: LD_VAR 0 4
113412: PUSH
113413: LD_VAR 0 7
113417: ARRAY
113418: PPUSH
113419: CALL_OW 257
113423: PUSH
113424: LD_INT 8
113426: EQUAL
113427: PUSH
113428: LD_VAR 0 4
113432: PUSH
113433: LD_VAR 0 7
113437: ARRAY
113438: PPUSH
113439: CALL_OW 264
113443: PUSH
113444: LD_INT 28
113446: PUSH
113447: LD_INT 45
113449: PUSH
113450: LD_INT 7
113452: PUSH
113453: LD_INT 47
113455: PUSH
113456: EMPTY
113457: LIST
113458: LIST
113459: LIST
113460: LIST
113461: IN
113462: OR
113463: IFFALSE 113719
// begin attacking := false ;
113465: LD_ADDR_VAR 0 29
113469: PUSH
113470: LD_INT 0
113472: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113473: LD_VAR 0 14
113477: PUSH
113478: LD_INT 1
113480: ARRAY
113481: PPUSH
113482: CALL_OW 266
113486: PUSH
113487: LD_INT 32
113489: PUSH
113490: LD_INT 31
113492: PUSH
113493: LD_INT 33
113495: PUSH
113496: LD_INT 4
113498: PUSH
113499: LD_INT 5
113501: PUSH
113502: EMPTY
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: IN
113509: IFFALSE 113695
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113511: LD_ADDR_VAR 0 9
113515: PUSH
113516: LD_VAR 0 14
113520: PUSH
113521: LD_INT 1
113523: ARRAY
113524: PPUSH
113525: CALL_OW 266
113529: PPUSH
113530: LD_VAR 0 14
113534: PUSH
113535: LD_INT 1
113537: ARRAY
113538: PPUSH
113539: CALL_OW 250
113543: PPUSH
113544: LD_VAR 0 14
113548: PUSH
113549: LD_INT 1
113551: ARRAY
113552: PPUSH
113553: CALL_OW 251
113557: PPUSH
113558: LD_VAR 0 14
113562: PUSH
113563: LD_INT 1
113565: ARRAY
113566: PPUSH
113567: CALL_OW 254
113571: PPUSH
113572: LD_VAR 0 14
113576: PUSH
113577: LD_INT 1
113579: ARRAY
113580: PPUSH
113581: CALL_OW 248
113585: PPUSH
113586: LD_INT 0
113588: PPUSH
113589: CALL 63111 0 6
113593: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113594: LD_ADDR_VAR 0 8
113598: PUSH
113599: LD_VAR 0 4
113603: PUSH
113604: LD_VAR 0 7
113608: ARRAY
113609: PPUSH
113610: LD_VAR 0 9
113614: PPUSH
113615: CALL 81854 0 2
113619: ST_TO_ADDR
// if j then
113620: LD_VAR 0 8
113624: IFFALSE 113693
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113626: LD_VAR 0 8
113630: PUSH
113631: LD_INT 1
113633: ARRAY
113634: PPUSH
113635: LD_VAR 0 8
113639: PUSH
113640: LD_INT 2
113642: ARRAY
113643: PPUSH
113644: CALL_OW 488
113648: IFFALSE 113693
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113650: LD_VAR 0 4
113654: PUSH
113655: LD_VAR 0 7
113659: ARRAY
113660: PPUSH
113661: LD_VAR 0 8
113665: PUSH
113666: LD_INT 1
113668: ARRAY
113669: PPUSH
113670: LD_VAR 0 8
113674: PUSH
113675: LD_INT 2
113677: ARRAY
113678: PPUSH
113679: CALL_OW 116
// attacking := true ;
113683: LD_ADDR_VAR 0 29
113687: PUSH
113688: LD_INT 1
113690: ST_TO_ADDR
// continue ;
113691: GO 111066
// end ; end else
113693: GO 113719
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113695: LD_VAR 0 4
113699: PUSH
113700: LD_VAR 0 7
113704: ARRAY
113705: PPUSH
113706: LD_VAR 0 14
113710: PUSH
113711: LD_INT 1
113713: ARRAY
113714: PPUSH
113715: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113719: LD_VAR 0 4
113723: PUSH
113724: LD_VAR 0 7
113728: ARRAY
113729: PPUSH
113730: CALL_OW 265
113734: PUSH
113735: LD_INT 11
113737: EQUAL
113738: IFFALSE 114016
// begin k := 10 ;
113740: LD_ADDR_VAR 0 9
113744: PUSH
113745: LD_INT 10
113747: ST_TO_ADDR
// x := 0 ;
113748: LD_ADDR_VAR 0 10
113752: PUSH
113753: LD_INT 0
113755: ST_TO_ADDR
// if tmp < k then
113756: LD_VAR 0 14
113760: PUSH
113761: LD_VAR 0 9
113765: LESS
113766: IFFALSE 113778
// k := tmp ;
113768: LD_ADDR_VAR 0 9
113772: PUSH
113773: LD_VAR 0 14
113777: ST_TO_ADDR
// for j = k downto 1 do
113778: LD_ADDR_VAR 0 8
113782: PUSH
113783: DOUBLE
113784: LD_VAR 0 9
113788: INC
113789: ST_TO_ADDR
113790: LD_INT 1
113792: PUSH
113793: FOR_DOWNTO
113794: IFFALSE 113869
// begin if GetType ( tmp [ j ] ) = unit_human then
113796: LD_VAR 0 14
113800: PUSH
113801: LD_VAR 0 8
113805: ARRAY
113806: PPUSH
113807: CALL_OW 247
113811: PUSH
113812: LD_INT 1
113814: EQUAL
113815: IFFALSE 113867
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113817: LD_VAR 0 4
113821: PUSH
113822: LD_VAR 0 7
113826: ARRAY
113827: PPUSH
113828: LD_VAR 0 14
113832: PUSH
113833: LD_VAR 0 8
113837: ARRAY
113838: PPUSH
113839: CALL 82108 0 2
// x := tmp [ j ] ;
113843: LD_ADDR_VAR 0 10
113847: PUSH
113848: LD_VAR 0 14
113852: PUSH
113853: LD_VAR 0 8
113857: ARRAY
113858: ST_TO_ADDR
// attacking := true ;
113859: LD_ADDR_VAR 0 29
113863: PUSH
113864: LD_INT 1
113866: ST_TO_ADDR
// end ; end ;
113867: GO 113793
113869: POP
113870: POP
// if not x then
113871: LD_VAR 0 10
113875: NOT
113876: IFFALSE 114016
// begin attacking := true ;
113878: LD_ADDR_VAR 0 29
113882: PUSH
113883: LD_INT 1
113885: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113886: LD_VAR 0 4
113890: PUSH
113891: LD_VAR 0 7
113895: ARRAY
113896: PPUSH
113897: CALL_OW 250
113901: PPUSH
113902: LD_VAR 0 4
113906: PUSH
113907: LD_VAR 0 7
113911: ARRAY
113912: PPUSH
113913: CALL_OW 251
113917: PPUSH
113918: CALL_OW 546
113922: PUSH
113923: LD_INT 2
113925: ARRAY
113926: PUSH
113927: LD_VAR 0 14
113931: PUSH
113932: LD_INT 1
113934: ARRAY
113935: PPUSH
113936: CALL_OW 250
113940: PPUSH
113941: LD_VAR 0 14
113945: PUSH
113946: LD_INT 1
113948: ARRAY
113949: PPUSH
113950: CALL_OW 251
113954: PPUSH
113955: CALL_OW 546
113959: PUSH
113960: LD_INT 2
113962: ARRAY
113963: EQUAL
113964: IFFALSE 113992
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113966: LD_VAR 0 4
113970: PUSH
113971: LD_VAR 0 7
113975: ARRAY
113976: PPUSH
113977: LD_VAR 0 14
113981: PUSH
113982: LD_INT 1
113984: ARRAY
113985: PPUSH
113986: CALL 82108 0 2
113990: GO 114016
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113992: LD_VAR 0 4
113996: PUSH
113997: LD_VAR 0 7
114001: ARRAY
114002: PPUSH
114003: LD_VAR 0 14
114007: PUSH
114008: LD_INT 1
114010: ARRAY
114011: PPUSH
114012: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114016: LD_VAR 0 4
114020: PUSH
114021: LD_VAR 0 7
114025: ARRAY
114026: PPUSH
114027: CALL_OW 264
114031: PUSH
114032: LD_INT 29
114034: EQUAL
114035: IFFALSE 114401
// begin if WantsToAttack ( group [ i ] ) in bombed then
114037: LD_VAR 0 4
114041: PUSH
114042: LD_VAR 0 7
114046: ARRAY
114047: PPUSH
114048: CALL_OW 319
114052: PUSH
114053: LD_VAR 0 28
114057: IN
114058: IFFALSE 114062
// continue ;
114060: GO 111066
// k := 8 ;
114062: LD_ADDR_VAR 0 9
114066: PUSH
114067: LD_INT 8
114069: ST_TO_ADDR
// x := 0 ;
114070: LD_ADDR_VAR 0 10
114074: PUSH
114075: LD_INT 0
114077: ST_TO_ADDR
// if tmp < k then
114078: LD_VAR 0 14
114082: PUSH
114083: LD_VAR 0 9
114087: LESS
114088: IFFALSE 114100
// k := tmp ;
114090: LD_ADDR_VAR 0 9
114094: PUSH
114095: LD_VAR 0 14
114099: ST_TO_ADDR
// for j = 1 to k do
114100: LD_ADDR_VAR 0 8
114104: PUSH
114105: DOUBLE
114106: LD_INT 1
114108: DEC
114109: ST_TO_ADDR
114110: LD_VAR 0 9
114114: PUSH
114115: FOR_TO
114116: IFFALSE 114248
// begin if GetType ( tmp [ j ] ) = unit_building then
114118: LD_VAR 0 14
114122: PUSH
114123: LD_VAR 0 8
114127: ARRAY
114128: PPUSH
114129: CALL_OW 247
114133: PUSH
114134: LD_INT 3
114136: EQUAL
114137: IFFALSE 114246
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114139: LD_VAR 0 14
114143: PUSH
114144: LD_VAR 0 8
114148: ARRAY
114149: PUSH
114150: LD_VAR 0 28
114154: IN
114155: NOT
114156: PUSH
114157: LD_VAR 0 14
114161: PUSH
114162: LD_VAR 0 8
114166: ARRAY
114167: PPUSH
114168: CALL_OW 313
114172: AND
114173: IFFALSE 114246
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114175: LD_VAR 0 4
114179: PUSH
114180: LD_VAR 0 7
114184: ARRAY
114185: PPUSH
114186: LD_VAR 0 14
114190: PUSH
114191: LD_VAR 0 8
114195: ARRAY
114196: PPUSH
114197: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114201: LD_ADDR_VAR 0 28
114205: PUSH
114206: LD_VAR 0 28
114210: PPUSH
114211: LD_VAR 0 28
114215: PUSH
114216: LD_INT 1
114218: PLUS
114219: PPUSH
114220: LD_VAR 0 14
114224: PUSH
114225: LD_VAR 0 8
114229: ARRAY
114230: PPUSH
114231: CALL_OW 1
114235: ST_TO_ADDR
// attacking := true ;
114236: LD_ADDR_VAR 0 29
114240: PUSH
114241: LD_INT 1
114243: ST_TO_ADDR
// break ;
114244: GO 114248
// end ; end ;
114246: GO 114115
114248: POP
114249: POP
// if not attacking and f_attack_depot then
114250: LD_VAR 0 29
114254: NOT
114255: PUSH
114256: LD_VAR 0 25
114260: AND
114261: IFFALSE 114356
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114263: LD_ADDR_VAR 0 13
114267: PUSH
114268: LD_VAR 0 14
114272: PPUSH
114273: LD_INT 2
114275: PUSH
114276: LD_INT 30
114278: PUSH
114279: LD_INT 0
114281: PUSH
114282: EMPTY
114283: LIST
114284: LIST
114285: PUSH
114286: LD_INT 30
114288: PUSH
114289: LD_INT 1
114291: PUSH
114292: EMPTY
114293: LIST
114294: LIST
114295: PUSH
114296: EMPTY
114297: LIST
114298: LIST
114299: LIST
114300: PPUSH
114301: CALL_OW 72
114305: ST_TO_ADDR
// if z then
114306: LD_VAR 0 13
114310: IFFALSE 114356
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114312: LD_VAR 0 4
114316: PUSH
114317: LD_VAR 0 7
114321: ARRAY
114322: PPUSH
114323: LD_VAR 0 13
114327: PPUSH
114328: LD_VAR 0 4
114332: PUSH
114333: LD_VAR 0 7
114337: ARRAY
114338: PPUSH
114339: CALL_OW 74
114343: PPUSH
114344: CALL_OW 115
// attacking := true ;
114348: LD_ADDR_VAR 0 29
114352: PUSH
114353: LD_INT 1
114355: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114356: LD_VAR 0 4
114360: PUSH
114361: LD_VAR 0 7
114365: ARRAY
114366: PPUSH
114367: CALL_OW 256
114371: PUSH
114372: LD_INT 500
114374: LESS
114375: IFFALSE 114401
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114377: LD_VAR 0 4
114381: PUSH
114382: LD_VAR 0 7
114386: ARRAY
114387: PPUSH
114388: LD_VAR 0 14
114392: PUSH
114393: LD_INT 1
114395: ARRAY
114396: PPUSH
114397: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114401: LD_VAR 0 4
114405: PUSH
114406: LD_VAR 0 7
114410: ARRAY
114411: PPUSH
114412: CALL_OW 264
114416: PUSH
114417: LD_INT 49
114419: EQUAL
114420: IFFALSE 114541
// begin if not HasTask ( group [ i ] ) then
114422: LD_VAR 0 4
114426: PUSH
114427: LD_VAR 0 7
114431: ARRAY
114432: PPUSH
114433: CALL_OW 314
114437: NOT
114438: IFFALSE 114541
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114440: LD_ADDR_VAR 0 9
114444: PUSH
114445: LD_INT 81
114447: PUSH
114448: LD_VAR 0 4
114452: PUSH
114453: LD_VAR 0 7
114457: ARRAY
114458: PPUSH
114459: CALL_OW 255
114463: PUSH
114464: EMPTY
114465: LIST
114466: LIST
114467: PPUSH
114468: CALL_OW 69
114472: PPUSH
114473: LD_VAR 0 4
114477: PUSH
114478: LD_VAR 0 7
114482: ARRAY
114483: PPUSH
114484: CALL_OW 74
114488: ST_TO_ADDR
// if k then
114489: LD_VAR 0 9
114493: IFFALSE 114541
// if GetDistUnits ( group [ i ] , k ) > 10 then
114495: LD_VAR 0 4
114499: PUSH
114500: LD_VAR 0 7
114504: ARRAY
114505: PPUSH
114506: LD_VAR 0 9
114510: PPUSH
114511: CALL_OW 296
114515: PUSH
114516: LD_INT 10
114518: GREATER
114519: IFFALSE 114541
// ComMoveUnit ( group [ i ] , k ) ;
114521: LD_VAR 0 4
114525: PUSH
114526: LD_VAR 0 7
114530: ARRAY
114531: PPUSH
114532: LD_VAR 0 9
114536: PPUSH
114537: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114541: LD_VAR 0 4
114545: PUSH
114546: LD_VAR 0 7
114550: ARRAY
114551: PPUSH
114552: CALL_OW 256
114556: PUSH
114557: LD_INT 250
114559: LESS
114560: PUSH
114561: LD_VAR 0 4
114565: PUSH
114566: LD_VAR 0 7
114570: ARRAY
114571: PUSH
114572: LD_INT 21
114574: PUSH
114575: LD_INT 2
114577: PUSH
114578: EMPTY
114579: LIST
114580: LIST
114581: PUSH
114582: LD_INT 23
114584: PUSH
114585: LD_INT 2
114587: PUSH
114588: EMPTY
114589: LIST
114590: LIST
114591: PUSH
114592: EMPTY
114593: LIST
114594: LIST
114595: PPUSH
114596: CALL_OW 69
114600: IN
114601: AND
114602: IFFALSE 114727
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114604: LD_ADDR_VAR 0 9
114608: PUSH
114609: LD_OWVAR 3
114613: PUSH
114614: LD_VAR 0 4
114618: PUSH
114619: LD_VAR 0 7
114623: ARRAY
114624: DIFF
114625: PPUSH
114626: LD_VAR 0 4
114630: PUSH
114631: LD_VAR 0 7
114635: ARRAY
114636: PPUSH
114637: CALL_OW 74
114641: ST_TO_ADDR
// if not k then
114642: LD_VAR 0 9
114646: NOT
114647: IFFALSE 114651
// continue ;
114649: GO 111066
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114651: LD_VAR 0 9
114655: PUSH
114656: LD_INT 81
114658: PUSH
114659: LD_VAR 0 4
114663: PUSH
114664: LD_VAR 0 7
114668: ARRAY
114669: PPUSH
114670: CALL_OW 255
114674: PUSH
114675: EMPTY
114676: LIST
114677: LIST
114678: PPUSH
114679: CALL_OW 69
114683: IN
114684: PUSH
114685: LD_VAR 0 9
114689: PPUSH
114690: LD_VAR 0 4
114694: PUSH
114695: LD_VAR 0 7
114699: ARRAY
114700: PPUSH
114701: CALL_OW 296
114705: PUSH
114706: LD_INT 5
114708: LESS
114709: AND
114710: IFFALSE 114727
// ComAutodestruct ( group [ i ] ) ;
114712: LD_VAR 0 4
114716: PUSH
114717: LD_VAR 0 7
114721: ARRAY
114722: PPUSH
114723: CALL 82006 0 1
// end ; if f_attack_depot then
114727: LD_VAR 0 25
114731: IFFALSE 114843
// begin k := 6 ;
114733: LD_ADDR_VAR 0 9
114737: PUSH
114738: LD_INT 6
114740: ST_TO_ADDR
// if tmp < k then
114741: LD_VAR 0 14
114745: PUSH
114746: LD_VAR 0 9
114750: LESS
114751: IFFALSE 114763
// k := tmp ;
114753: LD_ADDR_VAR 0 9
114757: PUSH
114758: LD_VAR 0 14
114762: ST_TO_ADDR
// for j = 1 to k do
114763: LD_ADDR_VAR 0 8
114767: PUSH
114768: DOUBLE
114769: LD_INT 1
114771: DEC
114772: ST_TO_ADDR
114773: LD_VAR 0 9
114777: PUSH
114778: FOR_TO
114779: IFFALSE 114841
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114781: LD_VAR 0 8
114785: PPUSH
114786: CALL_OW 266
114790: PUSH
114791: LD_INT 0
114793: PUSH
114794: LD_INT 1
114796: PUSH
114797: EMPTY
114798: LIST
114799: LIST
114800: IN
114801: IFFALSE 114839
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114803: LD_VAR 0 4
114807: PUSH
114808: LD_VAR 0 7
114812: ARRAY
114813: PPUSH
114814: LD_VAR 0 14
114818: PUSH
114819: LD_VAR 0 8
114823: ARRAY
114824: PPUSH
114825: CALL_OW 115
// attacking := true ;
114829: LD_ADDR_VAR 0 29
114833: PUSH
114834: LD_INT 1
114836: ST_TO_ADDR
// break ;
114837: GO 114841
// end ;
114839: GO 114778
114841: POP
114842: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114843: LD_VAR 0 4
114847: PUSH
114848: LD_VAR 0 7
114852: ARRAY
114853: PPUSH
114854: CALL_OW 302
114858: PUSH
114859: LD_VAR 0 29
114863: NOT
114864: AND
114865: IFFALSE 115187
// begin if GetTag ( group [ i ] ) = 71 then
114867: LD_VAR 0 4
114871: PUSH
114872: LD_VAR 0 7
114876: ARRAY
114877: PPUSH
114878: CALL_OW 110
114882: PUSH
114883: LD_INT 71
114885: EQUAL
114886: IFFALSE 114927
// begin if HasTask ( group [ i ] ) then
114888: LD_VAR 0 4
114892: PUSH
114893: LD_VAR 0 7
114897: ARRAY
114898: PPUSH
114899: CALL_OW 314
114903: IFFALSE 114909
// continue else
114905: GO 111066
114907: GO 114927
// SetTag ( group [ i ] , 0 ) ;
114909: LD_VAR 0 4
114913: PUSH
114914: LD_VAR 0 7
114918: ARRAY
114919: PPUSH
114920: LD_INT 0
114922: PPUSH
114923: CALL_OW 109
// end ; k := 8 ;
114927: LD_ADDR_VAR 0 9
114931: PUSH
114932: LD_INT 8
114934: ST_TO_ADDR
// x := 0 ;
114935: LD_ADDR_VAR 0 10
114939: PUSH
114940: LD_INT 0
114942: ST_TO_ADDR
// if tmp < k then
114943: LD_VAR 0 14
114947: PUSH
114948: LD_VAR 0 9
114952: LESS
114953: IFFALSE 114965
// k := tmp ;
114955: LD_ADDR_VAR 0 9
114959: PUSH
114960: LD_VAR 0 14
114964: ST_TO_ADDR
// for j = 1 to k do
114965: LD_ADDR_VAR 0 8
114969: PUSH
114970: DOUBLE
114971: LD_INT 1
114973: DEC
114974: ST_TO_ADDR
114975: LD_VAR 0 9
114979: PUSH
114980: FOR_TO
114981: IFFALSE 115079
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114983: LD_VAR 0 14
114987: PUSH
114988: LD_VAR 0 8
114992: ARRAY
114993: PPUSH
114994: CALL_OW 247
114998: PUSH
114999: LD_INT 1
115001: EQUAL
115002: PUSH
115003: LD_VAR 0 14
115007: PUSH
115008: LD_VAR 0 8
115012: ARRAY
115013: PPUSH
115014: CALL_OW 256
115018: PUSH
115019: LD_INT 250
115021: LESS
115022: PUSH
115023: LD_VAR 0 20
115027: AND
115028: PUSH
115029: LD_VAR 0 20
115033: NOT
115034: PUSH
115035: LD_VAR 0 14
115039: PUSH
115040: LD_VAR 0 8
115044: ARRAY
115045: PPUSH
115046: CALL_OW 256
115050: PUSH
115051: LD_INT 250
115053: GREATEREQUAL
115054: AND
115055: OR
115056: AND
115057: IFFALSE 115077
// begin x := tmp [ j ] ;
115059: LD_ADDR_VAR 0 10
115063: PUSH
115064: LD_VAR 0 14
115068: PUSH
115069: LD_VAR 0 8
115073: ARRAY
115074: ST_TO_ADDR
// break ;
115075: GO 115079
// end ;
115077: GO 114980
115079: POP
115080: POP
// if x then
115081: LD_VAR 0 10
115085: IFFALSE 115109
// ComAttackUnit ( group [ i ] , x ) else
115087: LD_VAR 0 4
115091: PUSH
115092: LD_VAR 0 7
115096: ARRAY
115097: PPUSH
115098: LD_VAR 0 10
115102: PPUSH
115103: CALL_OW 115
115107: GO 115133
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115109: LD_VAR 0 4
115113: PUSH
115114: LD_VAR 0 7
115118: ARRAY
115119: PPUSH
115120: LD_VAR 0 14
115124: PUSH
115125: LD_INT 1
115127: ARRAY
115128: PPUSH
115129: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115133: LD_VAR 0 4
115137: PUSH
115138: LD_VAR 0 7
115142: ARRAY
115143: PPUSH
115144: CALL_OW 314
115148: NOT
115149: IFFALSE 115187
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115151: LD_VAR 0 4
115155: PUSH
115156: LD_VAR 0 7
115160: ARRAY
115161: PPUSH
115162: LD_VAR 0 14
115166: PPUSH
115167: LD_VAR 0 4
115171: PUSH
115172: LD_VAR 0 7
115176: ARRAY
115177: PPUSH
115178: CALL_OW 74
115182: PPUSH
115183: CALL_OW 115
// end ; end ; end ;
115187: GO 111066
115189: POP
115190: POP
// wait ( 0 0$2 ) ;
115191: LD_INT 70
115193: PPUSH
115194: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115198: LD_VAR 0 4
115202: NOT
115203: PUSH
115204: LD_VAR 0 4
115208: PUSH
115209: EMPTY
115210: EQUAL
115211: OR
115212: PUSH
115213: LD_INT 81
115215: PUSH
115216: LD_VAR 0 35
115220: PUSH
115221: EMPTY
115222: LIST
115223: LIST
115224: PPUSH
115225: CALL_OW 69
115229: NOT
115230: OR
115231: IFFALSE 111051
// end ;
115233: LD_VAR 0 2
115237: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115238: LD_INT 0
115240: PPUSH
115241: PPUSH
115242: PPUSH
115243: PPUSH
115244: PPUSH
115245: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115246: LD_VAR 0 1
115250: NOT
115251: PUSH
115252: LD_EXP 50
115256: PUSH
115257: LD_VAR 0 1
115261: ARRAY
115262: NOT
115263: OR
115264: PUSH
115265: LD_VAR 0 2
115269: NOT
115270: OR
115271: IFFALSE 115275
// exit ;
115273: GO 115829
// side := mc_sides [ base ] ;
115275: LD_ADDR_VAR 0 6
115279: PUSH
115280: LD_EXP 76
115284: PUSH
115285: LD_VAR 0 1
115289: ARRAY
115290: ST_TO_ADDR
// if not side then
115291: LD_VAR 0 6
115295: NOT
115296: IFFALSE 115300
// exit ;
115298: GO 115829
// for i in solds do
115300: LD_ADDR_VAR 0 7
115304: PUSH
115305: LD_VAR 0 2
115309: PUSH
115310: FOR_IN
115311: IFFALSE 115372
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115313: LD_VAR 0 7
115317: PPUSH
115318: CALL_OW 310
115322: PPUSH
115323: CALL_OW 266
115327: PUSH
115328: LD_INT 32
115330: PUSH
115331: LD_INT 31
115333: PUSH
115334: EMPTY
115335: LIST
115336: LIST
115337: IN
115338: IFFALSE 115358
// solds := solds diff i else
115340: LD_ADDR_VAR 0 2
115344: PUSH
115345: LD_VAR 0 2
115349: PUSH
115350: LD_VAR 0 7
115354: DIFF
115355: ST_TO_ADDR
115356: GO 115370
// SetTag ( i , 18 ) ;
115358: LD_VAR 0 7
115362: PPUSH
115363: LD_INT 18
115365: PPUSH
115366: CALL_OW 109
115370: GO 115310
115372: POP
115373: POP
// if not solds then
115374: LD_VAR 0 2
115378: NOT
115379: IFFALSE 115383
// exit ;
115381: GO 115829
// repeat wait ( 0 0$2 ) ;
115383: LD_INT 70
115385: PPUSH
115386: CALL_OW 67
// enemy := mc_scan [ base ] ;
115390: LD_ADDR_VAR 0 4
115394: PUSH
115395: LD_EXP 73
115399: PUSH
115400: LD_VAR 0 1
115404: ARRAY
115405: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115406: LD_EXP 50
115410: PUSH
115411: LD_VAR 0 1
115415: ARRAY
115416: NOT
115417: PUSH
115418: LD_EXP 50
115422: PUSH
115423: LD_VAR 0 1
115427: ARRAY
115428: PUSH
115429: EMPTY
115430: EQUAL
115431: OR
115432: IFFALSE 115469
// begin for i in solds do
115434: LD_ADDR_VAR 0 7
115438: PUSH
115439: LD_VAR 0 2
115443: PUSH
115444: FOR_IN
115445: IFFALSE 115458
// ComStop ( i ) ;
115447: LD_VAR 0 7
115451: PPUSH
115452: CALL_OW 141
115456: GO 115444
115458: POP
115459: POP
// solds := [ ] ;
115460: LD_ADDR_VAR 0 2
115464: PUSH
115465: EMPTY
115466: ST_TO_ADDR
// exit ;
115467: GO 115829
// end ; for i in solds do
115469: LD_ADDR_VAR 0 7
115473: PUSH
115474: LD_VAR 0 2
115478: PUSH
115479: FOR_IN
115480: IFFALSE 115801
// begin if IsInUnit ( i ) then
115482: LD_VAR 0 7
115486: PPUSH
115487: CALL_OW 310
115491: IFFALSE 115502
// ComExitBuilding ( i ) ;
115493: LD_VAR 0 7
115497: PPUSH
115498: CALL_OW 122
// if GetLives ( i ) > 500 then
115502: LD_VAR 0 7
115506: PPUSH
115507: CALL_OW 256
115511: PUSH
115512: LD_INT 500
115514: GREATER
115515: IFFALSE 115568
// begin e := NearestUnitToUnit ( enemy , i ) ;
115517: LD_ADDR_VAR 0 5
115521: PUSH
115522: LD_VAR 0 4
115526: PPUSH
115527: LD_VAR 0 7
115531: PPUSH
115532: CALL_OW 74
115536: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115537: LD_VAR 0 7
115541: PPUSH
115542: LD_VAR 0 5
115546: PPUSH
115547: CALL_OW 250
115551: PPUSH
115552: LD_VAR 0 5
115556: PPUSH
115557: CALL_OW 251
115561: PPUSH
115562: CALL_OW 114
// end else
115566: GO 115799
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115568: LD_VAR 0 7
115572: PPUSH
115573: LD_EXP 50
115577: PUSH
115578: LD_VAR 0 1
115582: ARRAY
115583: PPUSH
115584: LD_INT 2
115586: PUSH
115587: LD_INT 30
115589: PUSH
115590: LD_INT 0
115592: PUSH
115593: EMPTY
115594: LIST
115595: LIST
115596: PUSH
115597: LD_INT 30
115599: PUSH
115600: LD_INT 1
115602: PUSH
115603: EMPTY
115604: LIST
115605: LIST
115606: PUSH
115607: LD_INT 30
115609: PUSH
115610: LD_INT 6
115612: PUSH
115613: EMPTY
115614: LIST
115615: LIST
115616: PUSH
115617: EMPTY
115618: LIST
115619: LIST
115620: LIST
115621: LIST
115622: PPUSH
115623: CALL_OW 72
115627: PPUSH
115628: LD_VAR 0 7
115632: PPUSH
115633: CALL_OW 74
115637: PPUSH
115638: CALL_OW 296
115642: PUSH
115643: LD_INT 10
115645: GREATER
115646: IFFALSE 115799
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115648: LD_ADDR_VAR 0 8
115652: PUSH
115653: LD_EXP 50
115657: PUSH
115658: LD_VAR 0 1
115662: ARRAY
115663: PPUSH
115664: LD_INT 2
115666: PUSH
115667: LD_INT 30
115669: PUSH
115670: LD_INT 0
115672: PUSH
115673: EMPTY
115674: LIST
115675: LIST
115676: PUSH
115677: LD_INT 30
115679: PUSH
115680: LD_INT 1
115682: PUSH
115683: EMPTY
115684: LIST
115685: LIST
115686: PUSH
115687: LD_INT 30
115689: PUSH
115690: LD_INT 6
115692: PUSH
115693: EMPTY
115694: LIST
115695: LIST
115696: PUSH
115697: EMPTY
115698: LIST
115699: LIST
115700: LIST
115701: LIST
115702: PPUSH
115703: CALL_OW 72
115707: PPUSH
115708: LD_VAR 0 7
115712: PPUSH
115713: CALL_OW 74
115717: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115718: LD_VAR 0 7
115722: PPUSH
115723: LD_VAR 0 8
115727: PPUSH
115728: CALL_OW 250
115732: PPUSH
115733: LD_INT 3
115735: PPUSH
115736: LD_INT 5
115738: PPUSH
115739: CALL_OW 272
115743: PPUSH
115744: LD_VAR 0 8
115748: PPUSH
115749: CALL_OW 251
115753: PPUSH
115754: LD_INT 3
115756: PPUSH
115757: LD_INT 5
115759: PPUSH
115760: CALL_OW 273
115764: PPUSH
115765: CALL_OW 111
// SetTag ( i , 0 ) ;
115769: LD_VAR 0 7
115773: PPUSH
115774: LD_INT 0
115776: PPUSH
115777: CALL_OW 109
// solds := solds diff i ;
115781: LD_ADDR_VAR 0 2
115785: PUSH
115786: LD_VAR 0 2
115790: PUSH
115791: LD_VAR 0 7
115795: DIFF
115796: ST_TO_ADDR
// continue ;
115797: GO 115479
// end ; end ;
115799: GO 115479
115801: POP
115802: POP
// until not solds or not enemy ;
115803: LD_VAR 0 2
115807: NOT
115808: PUSH
115809: LD_VAR 0 4
115813: NOT
115814: OR
115815: IFFALSE 115383
// MC_Reset ( base , 18 ) ;
115817: LD_VAR 0 1
115821: PPUSH
115822: LD_INT 18
115824: PPUSH
115825: CALL 22484 0 2
// end ;
115829: LD_VAR 0 3
115833: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115834: LD_INT 0
115836: PPUSH
115837: PPUSH
115838: PPUSH
115839: PPUSH
115840: PPUSH
115841: PPUSH
115842: PPUSH
115843: PPUSH
115844: PPUSH
115845: PPUSH
115846: PPUSH
115847: PPUSH
115848: PPUSH
115849: PPUSH
115850: PPUSH
115851: PPUSH
115852: PPUSH
115853: PPUSH
115854: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115855: LD_ADDR_VAR 0 12
115859: PUSH
115860: LD_EXP 50
115864: PUSH
115865: LD_VAR 0 1
115869: ARRAY
115870: PPUSH
115871: LD_INT 25
115873: PUSH
115874: LD_INT 3
115876: PUSH
115877: EMPTY
115878: LIST
115879: LIST
115880: PPUSH
115881: CALL_OW 72
115885: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115886: LD_EXP 90
115890: PUSH
115891: LD_VAR 0 1
115895: ARRAY
115896: IFFALSE 115920
// mechs := mechs diff mc_remote_driver [ base ] ;
115898: LD_ADDR_VAR 0 12
115902: PUSH
115903: LD_VAR 0 12
115907: PUSH
115908: LD_EXP 90
115912: PUSH
115913: LD_VAR 0 1
115917: ARRAY
115918: DIFF
115919: ST_TO_ADDR
// for i in mechs do
115920: LD_ADDR_VAR 0 4
115924: PUSH
115925: LD_VAR 0 12
115929: PUSH
115930: FOR_IN
115931: IFFALSE 115966
// if GetTag ( i ) > 0 then
115933: LD_VAR 0 4
115937: PPUSH
115938: CALL_OW 110
115942: PUSH
115943: LD_INT 0
115945: GREATER
115946: IFFALSE 115964
// mechs := mechs diff i ;
115948: LD_ADDR_VAR 0 12
115952: PUSH
115953: LD_VAR 0 12
115957: PUSH
115958: LD_VAR 0 4
115962: DIFF
115963: ST_TO_ADDR
115964: GO 115930
115966: POP
115967: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115968: LD_ADDR_VAR 0 8
115972: PUSH
115973: LD_EXP 50
115977: PUSH
115978: LD_VAR 0 1
115982: ARRAY
115983: PPUSH
115984: LD_INT 2
115986: PUSH
115987: LD_INT 25
115989: PUSH
115990: LD_INT 1
115992: PUSH
115993: EMPTY
115994: LIST
115995: LIST
115996: PUSH
115997: LD_INT 25
115999: PUSH
116000: LD_INT 5
116002: PUSH
116003: EMPTY
116004: LIST
116005: LIST
116006: PUSH
116007: LD_INT 25
116009: PUSH
116010: LD_INT 8
116012: PUSH
116013: EMPTY
116014: LIST
116015: LIST
116016: PUSH
116017: LD_INT 25
116019: PUSH
116020: LD_INT 9
116022: PUSH
116023: EMPTY
116024: LIST
116025: LIST
116026: PUSH
116027: EMPTY
116028: LIST
116029: LIST
116030: LIST
116031: LIST
116032: LIST
116033: PPUSH
116034: CALL_OW 72
116038: ST_TO_ADDR
// if not defenders and not solds then
116039: LD_VAR 0 2
116043: NOT
116044: PUSH
116045: LD_VAR 0 8
116049: NOT
116050: AND
116051: IFFALSE 116055
// exit ;
116053: GO 117825
// depot_under_attack := false ;
116055: LD_ADDR_VAR 0 16
116059: PUSH
116060: LD_INT 0
116062: ST_TO_ADDR
// sold_defenders := [ ] ;
116063: LD_ADDR_VAR 0 17
116067: PUSH
116068: EMPTY
116069: ST_TO_ADDR
// if mechs then
116070: LD_VAR 0 12
116074: IFFALSE 116227
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116076: LD_ADDR_VAR 0 4
116080: PUSH
116081: LD_VAR 0 2
116085: PPUSH
116086: LD_INT 21
116088: PUSH
116089: LD_INT 2
116091: PUSH
116092: EMPTY
116093: LIST
116094: LIST
116095: PPUSH
116096: CALL_OW 72
116100: PUSH
116101: FOR_IN
116102: IFFALSE 116225
// begin if GetTag ( i ) <> 20 then
116104: LD_VAR 0 4
116108: PPUSH
116109: CALL_OW 110
116113: PUSH
116114: LD_INT 20
116116: NONEQUAL
116117: IFFALSE 116131
// SetTag ( i , 20 ) ;
116119: LD_VAR 0 4
116123: PPUSH
116124: LD_INT 20
116126: PPUSH
116127: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116131: LD_VAR 0 4
116135: PPUSH
116136: CALL_OW 263
116140: PUSH
116141: LD_INT 1
116143: EQUAL
116144: PUSH
116145: LD_VAR 0 4
116149: PPUSH
116150: CALL_OW 311
116154: NOT
116155: AND
116156: IFFALSE 116223
// begin un := mechs [ 1 ] ;
116158: LD_ADDR_VAR 0 10
116162: PUSH
116163: LD_VAR 0 12
116167: PUSH
116168: LD_INT 1
116170: ARRAY
116171: ST_TO_ADDR
// ComExit ( un ) ;
116172: LD_VAR 0 10
116176: PPUSH
116177: CALL 86891 0 1
// AddComEnterUnit ( un , i ) ;
116181: LD_VAR 0 10
116185: PPUSH
116186: LD_VAR 0 4
116190: PPUSH
116191: CALL_OW 180
// SetTag ( un , 19 ) ;
116195: LD_VAR 0 10
116199: PPUSH
116200: LD_INT 19
116202: PPUSH
116203: CALL_OW 109
// mechs := mechs diff un ;
116207: LD_ADDR_VAR 0 12
116211: PUSH
116212: LD_VAR 0 12
116216: PUSH
116217: LD_VAR 0 10
116221: DIFF
116222: ST_TO_ADDR
// end ; end ;
116223: GO 116101
116225: POP
116226: POP
// if solds then
116227: LD_VAR 0 8
116231: IFFALSE 116290
// for i in solds do
116233: LD_ADDR_VAR 0 4
116237: PUSH
116238: LD_VAR 0 8
116242: PUSH
116243: FOR_IN
116244: IFFALSE 116288
// if not GetTag ( i ) then
116246: LD_VAR 0 4
116250: PPUSH
116251: CALL_OW 110
116255: NOT
116256: IFFALSE 116286
// begin defenders := defenders union i ;
116258: LD_ADDR_VAR 0 2
116262: PUSH
116263: LD_VAR 0 2
116267: PUSH
116268: LD_VAR 0 4
116272: UNION
116273: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116274: LD_VAR 0 4
116278: PPUSH
116279: LD_INT 18
116281: PPUSH
116282: CALL_OW 109
// end ;
116286: GO 116243
116288: POP
116289: POP
// repeat wait ( 0 0$2 ) ;
116290: LD_INT 70
116292: PPUSH
116293: CALL_OW 67
// enemy := mc_scan [ base ] ;
116297: LD_ADDR_VAR 0 21
116301: PUSH
116302: LD_EXP 73
116306: PUSH
116307: LD_VAR 0 1
116311: ARRAY
116312: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116313: LD_EXP 50
116317: PUSH
116318: LD_VAR 0 1
116322: ARRAY
116323: NOT
116324: PUSH
116325: LD_EXP 50
116329: PUSH
116330: LD_VAR 0 1
116334: ARRAY
116335: PUSH
116336: EMPTY
116337: EQUAL
116338: OR
116339: IFFALSE 116376
// begin for i in defenders do
116341: LD_ADDR_VAR 0 4
116345: PUSH
116346: LD_VAR 0 2
116350: PUSH
116351: FOR_IN
116352: IFFALSE 116365
// ComStop ( i ) ;
116354: LD_VAR 0 4
116358: PPUSH
116359: CALL_OW 141
116363: GO 116351
116365: POP
116366: POP
// defenders := [ ] ;
116367: LD_ADDR_VAR 0 2
116371: PUSH
116372: EMPTY
116373: ST_TO_ADDR
// exit ;
116374: GO 117825
// end ; for i in defenders do
116376: LD_ADDR_VAR 0 4
116380: PUSH
116381: LD_VAR 0 2
116385: PUSH
116386: FOR_IN
116387: IFFALSE 117285
// begin e := NearestUnitToUnit ( enemy , i ) ;
116389: LD_ADDR_VAR 0 13
116393: PUSH
116394: LD_VAR 0 21
116398: PPUSH
116399: LD_VAR 0 4
116403: PPUSH
116404: CALL_OW 74
116408: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116409: LD_ADDR_VAR 0 7
116413: PUSH
116414: LD_EXP 50
116418: PUSH
116419: LD_VAR 0 1
116423: ARRAY
116424: PPUSH
116425: LD_INT 2
116427: PUSH
116428: LD_INT 30
116430: PUSH
116431: LD_INT 0
116433: PUSH
116434: EMPTY
116435: LIST
116436: LIST
116437: PUSH
116438: LD_INT 30
116440: PUSH
116441: LD_INT 1
116443: PUSH
116444: EMPTY
116445: LIST
116446: LIST
116447: PUSH
116448: EMPTY
116449: LIST
116450: LIST
116451: LIST
116452: PPUSH
116453: CALL_OW 72
116457: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116458: LD_ADDR_VAR 0 16
116462: PUSH
116463: LD_VAR 0 7
116467: NOT
116468: PUSH
116469: LD_VAR 0 7
116473: PPUSH
116474: LD_INT 3
116476: PUSH
116477: LD_INT 24
116479: PUSH
116480: LD_INT 600
116482: PUSH
116483: EMPTY
116484: LIST
116485: LIST
116486: PUSH
116487: EMPTY
116488: LIST
116489: LIST
116490: PPUSH
116491: CALL_OW 72
116495: OR
116496: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116497: LD_VAR 0 4
116501: PPUSH
116502: CALL_OW 247
116506: PUSH
116507: LD_INT 2
116509: DOUBLE
116510: EQUAL
116511: IFTRUE 116515
116513: GO 116911
116515: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116516: LD_VAR 0 4
116520: PPUSH
116521: CALL_OW 256
116525: PUSH
116526: LD_INT 1000
116528: EQUAL
116529: PUSH
116530: LD_VAR 0 4
116534: PPUSH
116535: LD_VAR 0 13
116539: PPUSH
116540: CALL_OW 296
116544: PUSH
116545: LD_INT 40
116547: LESS
116548: PUSH
116549: LD_VAR 0 13
116553: PPUSH
116554: LD_EXP 75
116558: PUSH
116559: LD_VAR 0 1
116563: ARRAY
116564: PPUSH
116565: CALL_OW 308
116569: OR
116570: AND
116571: IFFALSE 116693
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116573: LD_VAR 0 4
116577: PPUSH
116578: CALL_OW 262
116582: PUSH
116583: LD_INT 1
116585: EQUAL
116586: PUSH
116587: LD_VAR 0 4
116591: PPUSH
116592: CALL_OW 261
116596: PUSH
116597: LD_INT 30
116599: LESS
116600: AND
116601: PUSH
116602: LD_VAR 0 7
116606: AND
116607: IFFALSE 116677
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116609: LD_VAR 0 4
116613: PPUSH
116614: LD_VAR 0 7
116618: PPUSH
116619: LD_VAR 0 4
116623: PPUSH
116624: CALL_OW 74
116628: PPUSH
116629: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116633: LD_VAR 0 4
116637: PPUSH
116638: LD_VAR 0 7
116642: PPUSH
116643: LD_VAR 0 4
116647: PPUSH
116648: CALL_OW 74
116652: PPUSH
116653: CALL_OW 296
116657: PUSH
116658: LD_INT 6
116660: LESS
116661: IFFALSE 116675
// SetFuel ( i , 100 ) ;
116663: LD_VAR 0 4
116667: PPUSH
116668: LD_INT 100
116670: PPUSH
116671: CALL_OW 240
// end else
116675: GO 116691
// ComAttackUnit ( i , e ) ;
116677: LD_VAR 0 4
116681: PPUSH
116682: LD_VAR 0 13
116686: PPUSH
116687: CALL_OW 115
// end else
116691: GO 116794
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116693: LD_VAR 0 13
116697: PPUSH
116698: LD_EXP 75
116702: PUSH
116703: LD_VAR 0 1
116707: ARRAY
116708: PPUSH
116709: CALL_OW 308
116713: NOT
116714: PUSH
116715: LD_VAR 0 4
116719: PPUSH
116720: LD_VAR 0 13
116724: PPUSH
116725: CALL_OW 296
116729: PUSH
116730: LD_INT 40
116732: GREATEREQUAL
116733: AND
116734: PUSH
116735: LD_VAR 0 4
116739: PPUSH
116740: CALL_OW 256
116744: PUSH
116745: LD_INT 650
116747: LESSEQUAL
116748: OR
116749: PUSH
116750: LD_VAR 0 4
116754: PPUSH
116755: LD_EXP 74
116759: PUSH
116760: LD_VAR 0 1
116764: ARRAY
116765: PPUSH
116766: CALL_OW 308
116770: NOT
116771: AND
116772: IFFALSE 116794
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116774: LD_VAR 0 4
116778: PPUSH
116779: LD_EXP 74
116783: PUSH
116784: LD_VAR 0 1
116788: ARRAY
116789: PPUSH
116790: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116794: LD_VAR 0 4
116798: PPUSH
116799: CALL_OW 256
116803: PUSH
116804: LD_INT 1000
116806: LESS
116807: PUSH
116808: LD_VAR 0 4
116812: PPUSH
116813: CALL_OW 263
116817: PUSH
116818: LD_INT 1
116820: EQUAL
116821: AND
116822: PUSH
116823: LD_VAR 0 4
116827: PPUSH
116828: CALL_OW 311
116832: AND
116833: PUSH
116834: LD_VAR 0 4
116838: PPUSH
116839: LD_EXP 74
116843: PUSH
116844: LD_VAR 0 1
116848: ARRAY
116849: PPUSH
116850: CALL_OW 308
116854: AND
116855: IFFALSE 116909
// begin mech := IsDrivenBy ( i ) ;
116857: LD_ADDR_VAR 0 9
116861: PUSH
116862: LD_VAR 0 4
116866: PPUSH
116867: CALL_OW 311
116871: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116872: LD_VAR 0 9
116876: PPUSH
116877: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116881: LD_VAR 0 9
116885: PPUSH
116886: LD_VAR 0 4
116890: PPUSH
116891: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116895: LD_VAR 0 9
116899: PPUSH
116900: LD_VAR 0 4
116904: PPUSH
116905: CALL_OW 180
// end ; end ; unit_human :
116909: GO 117256
116911: LD_INT 1
116913: DOUBLE
116914: EQUAL
116915: IFTRUE 116919
116917: GO 117255
116919: POP
// begin b := IsInUnit ( i ) ;
116920: LD_ADDR_VAR 0 18
116924: PUSH
116925: LD_VAR 0 4
116929: PPUSH
116930: CALL_OW 310
116934: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116935: LD_ADDR_VAR 0 19
116939: PUSH
116940: LD_VAR 0 18
116944: NOT
116945: PUSH
116946: LD_VAR 0 18
116950: PPUSH
116951: CALL_OW 266
116955: PUSH
116956: LD_INT 32
116958: PUSH
116959: LD_INT 31
116961: PUSH
116962: EMPTY
116963: LIST
116964: LIST
116965: IN
116966: OR
116967: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116968: LD_VAR 0 18
116972: PPUSH
116973: CALL_OW 266
116977: PUSH
116978: LD_INT 5
116980: EQUAL
116981: PUSH
116982: LD_VAR 0 4
116986: PPUSH
116987: CALL_OW 257
116991: PUSH
116992: LD_INT 1
116994: PUSH
116995: LD_INT 2
116997: PUSH
116998: LD_INT 3
117000: PUSH
117001: LD_INT 4
117003: PUSH
117004: EMPTY
117005: LIST
117006: LIST
117007: LIST
117008: LIST
117009: IN
117010: AND
117011: IFFALSE 117048
// begin class := AllowSpecClass ( i ) ;
117013: LD_ADDR_VAR 0 20
117017: PUSH
117018: LD_VAR 0 4
117022: PPUSH
117023: CALL 50811 0 1
117027: ST_TO_ADDR
// if class then
117028: LD_VAR 0 20
117032: IFFALSE 117048
// ComChangeProfession ( i , class ) ;
117034: LD_VAR 0 4
117038: PPUSH
117039: LD_VAR 0 20
117043: PPUSH
117044: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117048: LD_VAR 0 16
117052: PUSH
117053: LD_VAR 0 2
117057: PPUSH
117058: LD_INT 21
117060: PUSH
117061: LD_INT 2
117063: PUSH
117064: EMPTY
117065: LIST
117066: LIST
117067: PPUSH
117068: CALL_OW 72
117072: PUSH
117073: LD_INT 1
117075: LESSEQUAL
117076: OR
117077: PUSH
117078: LD_VAR 0 19
117082: AND
117083: PUSH
117084: LD_VAR 0 4
117088: PUSH
117089: LD_VAR 0 17
117093: IN
117094: NOT
117095: AND
117096: IFFALSE 117189
// begin if b then
117098: LD_VAR 0 18
117102: IFFALSE 117151
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117104: LD_VAR 0 18
117108: PPUSH
117109: LD_VAR 0 21
117113: PPUSH
117114: LD_VAR 0 18
117118: PPUSH
117119: CALL_OW 74
117123: PPUSH
117124: CALL_OW 296
117128: PUSH
117129: LD_INT 10
117131: LESS
117132: PUSH
117133: LD_VAR 0 18
117137: PPUSH
117138: CALL_OW 461
117142: PUSH
117143: LD_INT 7
117145: NONEQUAL
117146: AND
117147: IFFALSE 117151
// continue ;
117149: GO 116386
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117151: LD_ADDR_VAR 0 17
117155: PUSH
117156: LD_VAR 0 17
117160: PPUSH
117161: LD_VAR 0 17
117165: PUSH
117166: LD_INT 1
117168: PLUS
117169: PPUSH
117170: LD_VAR 0 4
117174: PPUSH
117175: CALL_OW 1
117179: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117180: LD_VAR 0 4
117184: PPUSH
117185: CALL_OW 122
// end ; if sold_defenders then
117189: LD_VAR 0 17
117193: IFFALSE 117253
// if i in sold_defenders then
117195: LD_VAR 0 4
117199: PUSH
117200: LD_VAR 0 17
117204: IN
117205: IFFALSE 117253
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117207: LD_VAR 0 4
117211: PPUSH
117212: CALL_OW 314
117216: NOT
117217: PUSH
117218: LD_VAR 0 4
117222: PPUSH
117223: LD_VAR 0 13
117227: PPUSH
117228: CALL_OW 296
117232: PUSH
117233: LD_INT 30
117235: LESS
117236: AND
117237: IFFALSE 117253
// ComAttackUnit ( i , e ) ;
117239: LD_VAR 0 4
117243: PPUSH
117244: LD_VAR 0 13
117248: PPUSH
117249: CALL_OW 115
// end ; end ; end ;
117253: GO 117256
117255: POP
// if IsDead ( i ) then
117256: LD_VAR 0 4
117260: PPUSH
117261: CALL_OW 301
117265: IFFALSE 117283
// defenders := defenders diff i ;
117267: LD_ADDR_VAR 0 2
117271: PUSH
117272: LD_VAR 0 2
117276: PUSH
117277: LD_VAR 0 4
117281: DIFF
117282: ST_TO_ADDR
// end ;
117283: GO 116386
117285: POP
117286: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117287: LD_VAR 0 21
117291: NOT
117292: PUSH
117293: LD_VAR 0 2
117297: NOT
117298: OR
117299: PUSH
117300: LD_EXP 50
117304: PUSH
117305: LD_VAR 0 1
117309: ARRAY
117310: NOT
117311: OR
117312: IFFALSE 116290
// MC_Reset ( base , 18 ) ;
117314: LD_VAR 0 1
117318: PPUSH
117319: LD_INT 18
117321: PPUSH
117322: CALL 22484 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117326: LD_ADDR_VAR 0 2
117330: PUSH
117331: LD_VAR 0 2
117335: PUSH
117336: LD_VAR 0 2
117340: PPUSH
117341: LD_INT 2
117343: PUSH
117344: LD_INT 25
117346: PUSH
117347: LD_INT 1
117349: PUSH
117350: EMPTY
117351: LIST
117352: LIST
117353: PUSH
117354: LD_INT 25
117356: PUSH
117357: LD_INT 5
117359: PUSH
117360: EMPTY
117361: LIST
117362: LIST
117363: PUSH
117364: LD_INT 25
117366: PUSH
117367: LD_INT 8
117369: PUSH
117370: EMPTY
117371: LIST
117372: LIST
117373: PUSH
117374: LD_INT 25
117376: PUSH
117377: LD_INT 9
117379: PUSH
117380: EMPTY
117381: LIST
117382: LIST
117383: PUSH
117384: EMPTY
117385: LIST
117386: LIST
117387: LIST
117388: LIST
117389: LIST
117390: PPUSH
117391: CALL_OW 72
117395: DIFF
117396: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117397: LD_VAR 0 21
117401: NOT
117402: PUSH
117403: LD_VAR 0 2
117407: PPUSH
117408: LD_INT 21
117410: PUSH
117411: LD_INT 2
117413: PUSH
117414: EMPTY
117415: LIST
117416: LIST
117417: PPUSH
117418: CALL_OW 72
117422: AND
117423: IFFALSE 117761
// begin tmp := FilterByTag ( defenders , 19 ) ;
117425: LD_ADDR_VAR 0 11
117429: PUSH
117430: LD_VAR 0 2
117434: PPUSH
117435: LD_INT 19
117437: PPUSH
117438: CALL 84074 0 2
117442: ST_TO_ADDR
// if tmp then
117443: LD_VAR 0 11
117447: IFFALSE 117517
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117449: LD_ADDR_VAR 0 11
117453: PUSH
117454: LD_VAR 0 11
117458: PPUSH
117459: LD_INT 25
117461: PUSH
117462: LD_INT 3
117464: PUSH
117465: EMPTY
117466: LIST
117467: LIST
117468: PPUSH
117469: CALL_OW 72
117473: ST_TO_ADDR
// if tmp then
117474: LD_VAR 0 11
117478: IFFALSE 117517
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117480: LD_ADDR_EXP 62
117484: PUSH
117485: LD_EXP 62
117489: PPUSH
117490: LD_VAR 0 1
117494: PPUSH
117495: LD_EXP 62
117499: PUSH
117500: LD_VAR 0 1
117504: ARRAY
117505: PUSH
117506: LD_VAR 0 11
117510: UNION
117511: PPUSH
117512: CALL_OW 1
117516: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117517: LD_VAR 0 1
117521: PPUSH
117522: LD_INT 19
117524: PPUSH
117525: CALL 22484 0 2
// repeat wait ( 0 0$1 ) ;
117529: LD_INT 35
117531: PPUSH
117532: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117536: LD_EXP 50
117540: PUSH
117541: LD_VAR 0 1
117545: ARRAY
117546: NOT
117547: PUSH
117548: LD_EXP 50
117552: PUSH
117553: LD_VAR 0 1
117557: ARRAY
117558: PUSH
117559: EMPTY
117560: EQUAL
117561: OR
117562: IFFALSE 117599
// begin for i in defenders do
117564: LD_ADDR_VAR 0 4
117568: PUSH
117569: LD_VAR 0 2
117573: PUSH
117574: FOR_IN
117575: IFFALSE 117588
// ComStop ( i ) ;
117577: LD_VAR 0 4
117581: PPUSH
117582: CALL_OW 141
117586: GO 117574
117588: POP
117589: POP
// defenders := [ ] ;
117590: LD_ADDR_VAR 0 2
117594: PUSH
117595: EMPTY
117596: ST_TO_ADDR
// exit ;
117597: GO 117825
// end ; for i in defenders do
117599: LD_ADDR_VAR 0 4
117603: PUSH
117604: LD_VAR 0 2
117608: PUSH
117609: FOR_IN
117610: IFFALSE 117699
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117612: LD_VAR 0 4
117616: PPUSH
117617: LD_EXP 74
117621: PUSH
117622: LD_VAR 0 1
117626: ARRAY
117627: PPUSH
117628: CALL_OW 308
117632: NOT
117633: IFFALSE 117657
// ComMoveToArea ( i , mc_parking [ base ] ) else
117635: LD_VAR 0 4
117639: PPUSH
117640: LD_EXP 74
117644: PUSH
117645: LD_VAR 0 1
117649: ARRAY
117650: PPUSH
117651: CALL_OW 113
117655: GO 117697
// if GetControl ( i ) = control_manual then
117657: LD_VAR 0 4
117661: PPUSH
117662: CALL_OW 263
117666: PUSH
117667: LD_INT 1
117669: EQUAL
117670: IFFALSE 117697
// if IsDrivenBy ( i ) then
117672: LD_VAR 0 4
117676: PPUSH
117677: CALL_OW 311
117681: IFFALSE 117697
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117683: LD_VAR 0 4
117687: PPUSH
117688: CALL_OW 311
117692: PPUSH
117693: CALL_OW 121
// end ;
117697: GO 117609
117699: POP
117700: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117701: LD_VAR 0 2
117705: PPUSH
117706: LD_INT 95
117708: PUSH
117709: LD_EXP 74
117713: PUSH
117714: LD_VAR 0 1
117718: ARRAY
117719: PUSH
117720: EMPTY
117721: LIST
117722: LIST
117723: PPUSH
117724: CALL_OW 72
117728: PUSH
117729: LD_VAR 0 2
117733: EQUAL
117734: PUSH
117735: LD_EXP 73
117739: PUSH
117740: LD_VAR 0 1
117744: ARRAY
117745: OR
117746: PUSH
117747: LD_EXP 50
117751: PUSH
117752: LD_VAR 0 1
117756: ARRAY
117757: NOT
117758: OR
117759: IFFALSE 117529
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117761: LD_ADDR_EXP 72
117765: PUSH
117766: LD_EXP 72
117770: PPUSH
117771: LD_VAR 0 1
117775: PPUSH
117776: LD_VAR 0 2
117780: PPUSH
117781: LD_INT 21
117783: PUSH
117784: LD_INT 2
117786: PUSH
117787: EMPTY
117788: LIST
117789: LIST
117790: PPUSH
117791: CALL_OW 72
117795: PPUSH
117796: CALL_OW 1
117800: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117801: LD_VAR 0 1
117805: PPUSH
117806: LD_INT 19
117808: PPUSH
117809: CALL 22484 0 2
// MC_Reset ( base , 20 ) ;
117813: LD_VAR 0 1
117817: PPUSH
117818: LD_INT 20
117820: PPUSH
117821: CALL 22484 0 2
// end ; end_of_file
117825: LD_VAR 0 3
117829: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117830: LD_VAR 0 1
117834: PUSH
117835: LD_INT 200
117837: DOUBLE
117838: GREATEREQUAL
117839: IFFALSE 117847
117841: LD_INT 299
117843: DOUBLE
117844: LESSEQUAL
117845: IFTRUE 117849
117847: GO 117881
117849: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117850: LD_VAR 0 1
117854: PPUSH
117855: LD_VAR 0 2
117859: PPUSH
117860: LD_VAR 0 3
117864: PPUSH
117865: LD_VAR 0 4
117869: PPUSH
117870: LD_VAR 0 5
117874: PPUSH
117875: CALL 106616 0 5
117879: GO 117958
117881: LD_INT 300
117883: DOUBLE
117884: GREATEREQUAL
117885: IFFALSE 117893
117887: LD_INT 399
117889: DOUBLE
117890: LESSEQUAL
117891: IFTRUE 117895
117893: GO 117957
117895: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117896: LD_VAR 0 1
117900: PPUSH
117901: LD_VAR 0 2
117905: PPUSH
117906: LD_VAR 0 3
117910: PPUSH
117911: LD_VAR 0 4
117915: PPUSH
117916: LD_VAR 0 5
117920: PPUSH
117921: LD_VAR 0 6
117925: PPUSH
117926: LD_VAR 0 7
117930: PPUSH
117931: LD_VAR 0 8
117935: PPUSH
117936: LD_VAR 0 9
117940: PPUSH
117941: LD_VAR 0 10
117945: PPUSH
117946: LD_VAR 0 11
117950: PPUSH
117951: CALL 102949 0 11
117955: GO 117958
117957: POP
// end ;
117958: PPOPN 11
117960: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117961: LD_VAR 0 1
117965: PPUSH
117966: LD_VAR 0 2
117970: PPUSH
117971: LD_VAR 0 3
117975: PPUSH
117976: LD_VAR 0 4
117980: PPUSH
117981: LD_VAR 0 5
117985: PPUSH
117986: CALL 106352 0 5
// end ; end_of_file
117990: PPOPN 5
117992: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117993: LD_VAR 0 1
117997: PPUSH
117998: LD_VAR 0 2
118002: PPUSH
118003: LD_VAR 0 3
118007: PPUSH
118008: LD_VAR 0 4
118012: PPUSH
118013: LD_VAR 0 5
118017: PPUSH
118018: LD_VAR 0 6
118022: PPUSH
118023: CALL 90601 0 6
// end ;
118027: PPOPN 6
118029: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118030: LD_INT 0
118032: PPUSH
// begin if not units then
118033: LD_VAR 0 1
118037: NOT
118038: IFFALSE 118042
// exit ;
118040: GO 118042
// end ;
118042: PPOPN 7
118044: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118045: CALL 90505 0 0
// end ;
118049: PPOPN 1
118051: END
