// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 84583 0 0
// InitMacro ;
  23: CALL 17446 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 80129 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2319 0 0
// MC_Start ( ) ;
  89: CALL 19558 0 0
// Action ;
  93: CALL 8156 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 40785 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 40785 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 40785 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41211 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 99
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 99
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41103 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 99
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41103 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 47514 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 47514 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 47514 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 47514 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 47514 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 47514 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 47514 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 47514 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 47514 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 47514 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 47514 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 47514 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 47514 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 47514 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 47514 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ; end_of_file
2314: LD_VAR 0 1
2318: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
2325: PPUSH
2326: PPUSH
// if Difficulty = 1 then
2327: LD_OWVAR 67
2331: PUSH
2332: LD_INT 1
2334: EQUAL
2335: IFFALSE 2432
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2337: LD_ADDR_VAR 0 6
2341: PUSH
2342: LD_INT 129
2344: PUSH
2345: LD_INT 45
2347: PUSH
2348: EMPTY
2349: LIST
2350: LIST
2351: PUSH
2352: LD_INT 143
2354: PUSH
2355: LD_INT 58
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 184
2364: PUSH
2365: LD_INT 113
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: LD_INT 163
2374: PUSH
2375: LD_INT 107
2377: PUSH
2378: EMPTY
2379: LIST
2380: LIST
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: LIST
2386: LIST
2387: ST_TO_ADDR
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 6
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2430
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2401: LD_VAR 0 2
2405: PUSH
2406: LD_INT 1
2408: ARRAY
2409: PPUSH
2410: LD_VAR 0 2
2414: PUSH
2415: LD_INT 2
2417: ARRAY
2418: PPUSH
2419: CALL_OW 428
2423: PPUSH
2424: CALL_OW 64
2428: GO 2398
2430: POP
2431: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2432: LD_ADDR_VAR 0 2
2436: PUSH
2437: LD_INT 21
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: EMPTY
2444: LIST
2445: LIST
2446: PPUSH
2447: CALL_OW 69
2451: PUSH
2452: FOR_IN
2453: IFFALSE 2486
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2455: LD_VAR 0 2
2459: PPUSH
2460: LD_INT 5
2462: PUSH
2463: LD_INT 6
2465: PUSH
2466: LD_INT 7
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: PUSH
2474: LD_OWVAR 67
2478: ARRAY
2479: PPUSH
2480: CALL_OW 241
2484: GO 2452
2486: POP
2487: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2488: LD_ADDR_VAR 0 5
2492: PUSH
2493: LD_INT 5
2495: PUSH
2496: LD_INT 6
2498: PUSH
2499: LD_INT 7
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: LIST
2506: PUSH
2507: LD_OWVAR 67
2511: ARRAY
2512: ST_TO_ADDR
// uc_side := 2 ;
2513: LD_ADDR_OWVAR 20
2517: PUSH
2518: LD_INT 2
2520: ST_TO_ADDR
// uc_nation := 2 ;
2521: LD_ADDR_OWVAR 21
2525: PUSH
2526: LD_INT 2
2528: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2529: LD_ADDR_OWVAR 37
2533: PUSH
2534: LD_INT 14
2536: ST_TO_ADDR
// vc_engine := engine_siberite ;
2537: LD_ADDR_OWVAR 39
2541: PUSH
2542: LD_INT 3
2544: ST_TO_ADDR
// vc_control := control_manual ;
2545: LD_ADDR_OWVAR 38
2549: PUSH
2550: LD_INT 1
2552: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2553: LD_ADDR_OWVAR 40
2557: PUSH
2558: LD_INT 31
2560: ST_TO_ADDR
// for i = 1 to 3 do
2561: LD_ADDR_VAR 0 2
2565: PUSH
2566: DOUBLE
2567: LD_INT 1
2569: DEC
2570: ST_TO_ADDR
2571: LD_INT 3
2573: PUSH
2574: FOR_TO
2575: IFFALSE 2659
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2577: LD_INT 0
2579: PPUSH
2580: LD_INT 3
2582: PPUSH
2583: LD_VAR 0 5
2587: PPUSH
2588: CALL_OW 380
// un := CreateVehicle ;
2592: LD_ADDR_VAR 0 4
2596: PUSH
2597: CALL_OW 45
2601: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2602: LD_VAR 0 4
2606: PPUSH
2607: LD_INT 0
2609: PPUSH
2610: LD_INT 5
2612: PPUSH
2613: CALL_OW 12
2617: PPUSH
2618: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2622: LD_VAR 0 4
2626: PPUSH
2627: LD_INT 156
2629: PPUSH
2630: LD_INT 15
2632: PPUSH
2633: LD_INT 6
2635: PPUSH
2636: LD_INT 0
2638: PPUSH
2639: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2643: CALL_OW 44
2647: PPUSH
2648: LD_VAR 0 4
2652: PPUSH
2653: CALL_OW 52
// end ;
2657: GO 2574
2659: POP
2660: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2661: LD_ADDR_EXP 37
2665: PUSH
2666: LD_INT 94
2668: PPUSH
2669: LD_INT 28
2671: PPUSH
2672: LD_STRING dammam
2674: PPUSH
2675: LD_VAR 0 5
2679: PPUSH
2680: LD_INT 10000
2682: PUSH
2683: LD_INT 1000
2685: PUSH
2686: LD_INT 300
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: LIST
2693: PPUSH
2694: LD_INT 12
2696: PUSH
2697: LD_INT 2
2699: PUSH
2700: LD_INT 3
2702: PUSH
2703: LD_INT 4
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: LIST
2710: PUSH
2711: LD_OWVAR 67
2715: ARRAY
2716: PUSH
2717: LD_INT 1
2719: NEG
2720: PUSH
2721: LD_INT 4
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL 55747 0 6
2734: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2735: LD_ADDR_EXP 37
2739: PUSH
2740: LD_EXP 37
2744: PUSH
2745: LD_INT 122
2747: PPUSH
2748: LD_INT 25
2750: PPUSH
2751: LD_STRING 
2753: PPUSH
2754: LD_VAR 0 5
2758: PPUSH
2759: LD_INT 500
2761: PUSH
2762: LD_INT 60
2764: PUSH
2765: LD_INT 0
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: LIST
2772: PPUSH
2773: LD_INT 8
2775: PUSH
2776: LD_INT 2
2778: PUSH
2779: LD_INT 3
2781: PUSH
2782: LD_INT 4
2784: PUSH
2785: EMPTY
2786: LIST
2787: LIST
2788: LIST
2789: PUSH
2790: LD_OWVAR 67
2794: ARRAY
2795: PUSH
2796: LD_INT 2
2798: PUSH
2799: LD_INT 0
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: PPUSH
2808: CALL 55747 0 6
2812: UNION
2813: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
2814: LD_ADDR_EXP 35
2818: PUSH
2819: LD_INT 45
2821: PPUSH
2822: LD_INT 24
2824: PPUSH
2825: LD_STRING jeddah
2827: PPUSH
2828: LD_VAR 0 5
2832: PPUSH
2833: LD_INT 700
2835: PUSH
2836: LD_INT 300
2838: PUSH
2839: LD_INT 10
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: LIST
2846: PPUSH
2847: LD_INT 10
2849: PUSH
2850: LD_INT 4
2852: PUSH
2853: LD_INT 3
2855: PUSH
2856: LD_INT 2
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL 55747 0 6
2869: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2870: LD_ADDR_EXP 36
2874: PUSH
2875: LD_INT 7
2877: PPUSH
2878: LD_INT 27
2880: PPUSH
2881: LD_STRING riyadh
2883: PPUSH
2884: LD_VAR 0 5
2888: PPUSH
2889: LD_INT 500
2891: PUSH
2892: LD_INT 60
2894: PUSH
2895: LD_INT 0
2897: PUSH
2898: EMPTY
2899: LIST
2900: LIST
2901: LIST
2902: PPUSH
2903: LD_INT 4
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: LD_INT 3
2911: PUSH
2912: LD_INT 1
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: LIST
2920: PPUSH
2921: CALL 55747 0 6
2925: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
2926: LD_ADDR_EXP 39
2930: PUSH
2931: LD_INT 204
2933: PPUSH
2934: LD_INT 26
2936: PPUSH
2937: LD_STRING 
2939: PPUSH
2940: LD_VAR 0 5
2944: PPUSH
2945: LD_INT 500
2947: PUSH
2948: LD_INT 50
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: PPUSH
2959: LD_INT 10
2961: PUSH
2962: LD_INT 2
2964: PUSH
2965: LD_INT 3
2967: PUSH
2968: LD_INT 1
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: LIST
2975: LIST
2976: PPUSH
2977: CALL 55747 0 6
2981: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2982: LD_ADDR_EXP 50
2986: PUSH
2987: LD_EXP 37
2991: PUSH
2992: LD_EXP 35
2996: PUSH
2997: LD_EXP 39
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3007: LD_ADDR_VAR 0 2
3011: PUSH
3012: LD_INT 22
3014: PUSH
3015: LD_INT 2
3017: PUSH
3018: EMPTY
3019: LIST
3020: LIST
3021: PUSH
3022: LD_INT 30
3024: PUSH
3025: LD_INT 31
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: PUSH
3032: LD_INT 58
3034: PUSH
3035: EMPTY
3036: LIST
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: PPUSH
3043: CALL_OW 69
3047: PUSH
3048: FOR_IN
3049: IFFALSE 3174
// begin if GetBase ( i ) then
3051: LD_VAR 0 2
3055: PPUSH
3056: CALL_OW 274
3060: IFFALSE 3064
// continue ;
3062: GO 3048
// d := GetDir ( i ) ;
3064: LD_ADDR_VAR 0 3
3068: PUSH
3069: LD_VAR 0 2
3073: PPUSH
3074: CALL_OW 254
3078: ST_TO_ADDR
// if d < 3 then
3079: LD_VAR 0 3
3083: PUSH
3084: LD_INT 3
3086: LESS
3087: IFFALSE 3105
// d := d + 3 else
3089: LD_ADDR_VAR 0 3
3093: PUSH
3094: LD_VAR 0 3
3098: PUSH
3099: LD_INT 3
3101: PLUS
3102: ST_TO_ADDR
3103: GO 3119
// d := d - 3 ;
3105: LD_ADDR_VAR 0 3
3109: PUSH
3110: LD_VAR 0 3
3114: PUSH
3115: LD_INT 3
3117: MINUS
3118: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3119: LD_INT 0
3121: PPUSH
3122: LD_INT 8
3124: PPUSH
3125: LD_VAR 0 5
3129: PPUSH
3130: CALL_OW 380
// un := CreateHuman ;
3134: LD_ADDR_VAR 0 4
3138: PUSH
3139: CALL_OW 44
3143: ST_TO_ADDR
// SetDir ( un , d ) ;
3144: LD_VAR 0 4
3148: PPUSH
3149: LD_VAR 0 3
3153: PPUSH
3154: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3158: LD_VAR 0 4
3162: PPUSH
3163: LD_VAR 0 2
3167: PPUSH
3168: CALL_OW 52
// end ;
3172: GO 3048
3174: POP
3175: POP
// if Difficulty > 1 then
3176: LD_OWVAR 67
3180: PUSH
3181: LD_INT 1
3183: GREATER
3184: IFFALSE 3555
// begin ar_kamikadze := [ ] ;
3186: LD_ADDR_EXP 42
3190: PUSH
3191: EMPTY
3192: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3193: LD_INT 0
3195: PPUSH
3196: LD_INT 1
3198: PPUSH
3199: LD_VAR 0 5
3203: PPUSH
3204: CALL_OW 380
// un := CreateHuman ;
3208: LD_ADDR_VAR 0 4
3212: PUSH
3213: CALL_OW 44
3217: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3218: LD_VAR 0 4
3222: PPUSH
3223: LD_INT 3
3225: PPUSH
3226: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3230: LD_VAR 0 4
3234: PPUSH
3235: LD_INT 23
3237: PPUSH
3238: LD_INT 44
3240: PPUSH
3241: LD_INT 0
3243: PPUSH
3244: CALL_OW 48
// ComCrawl ( un ) ;
3248: LD_VAR 0 4
3252: PPUSH
3253: CALL_OW 137
// un := CreateHuman ;
3257: LD_ADDR_VAR 0 4
3261: PUSH
3262: CALL_OW 44
3266: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3267: LD_VAR 0 4
3271: PPUSH
3272: LD_INT 3
3274: PPUSH
3275: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3279: LD_VAR 0 4
3283: PPUSH
3284: LD_INT 30
3286: PPUSH
3287: LD_INT 39
3289: PPUSH
3290: LD_INT 0
3292: PPUSH
3293: CALL_OW 48
// ComCrawl ( un ) ;
3297: LD_VAR 0 4
3301: PPUSH
3302: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3306: LD_INT 0
3308: PPUSH
3309: LD_INT 17
3311: PPUSH
3312: LD_VAR 0 5
3316: PPUSH
3317: CALL_OW 380
// un := CreateHuman ;
3321: LD_ADDR_VAR 0 4
3325: PUSH
3326: CALL_OW 44
3330: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3331: LD_VAR 0 4
3335: PPUSH
3336: LD_INT 3
3338: PPUSH
3339: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3343: LD_VAR 0 4
3347: PPUSH
3348: LD_INT 45
3350: PPUSH
3351: LD_INT 86
3353: PPUSH
3354: LD_INT 0
3356: PPUSH
3357: CALL_OW 48
// ComHold ( un ) ;
3361: LD_VAR 0 4
3365: PPUSH
3366: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3370: LD_ADDR_EXP 42
3374: PUSH
3375: LD_EXP 42
3379: PPUSH
3380: LD_EXP 42
3384: PUSH
3385: LD_INT 1
3387: PLUS
3388: PPUSH
3389: LD_VAR 0 4
3393: PPUSH
3394: CALL_OW 1
3398: ST_TO_ADDR
// un := CreateHuman ;
3399: LD_ADDR_VAR 0 4
3403: PUSH
3404: CALL_OW 44
3408: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3409: LD_VAR 0 4
3413: PPUSH
3414: LD_INT 3
3416: PPUSH
3417: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3421: LD_VAR 0 4
3425: PPUSH
3426: LD_INT 60
3428: PPUSH
3429: LD_INT 85
3431: PPUSH
3432: LD_INT 0
3434: PPUSH
3435: CALL_OW 48
// ComHold ( un ) ;
3439: LD_VAR 0 4
3443: PPUSH
3444: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3448: LD_ADDR_EXP 42
3452: PUSH
3453: LD_EXP 42
3457: PPUSH
3458: LD_EXP 42
3462: PUSH
3463: LD_INT 1
3465: PLUS
3466: PPUSH
3467: LD_VAR 0 4
3471: PPUSH
3472: CALL_OW 1
3476: ST_TO_ADDR
// un := CreateHuman ;
3477: LD_ADDR_VAR 0 4
3481: PUSH
3482: CALL_OW 44
3486: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3487: LD_VAR 0 4
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3499: LD_VAR 0 4
3503: PPUSH
3504: LD_INT 222
3506: PPUSH
3507: LD_INT 166
3509: PPUSH
3510: LD_INT 0
3512: PPUSH
3513: CALL_OW 48
// ComHold ( un ) ;
3517: LD_VAR 0 4
3521: PPUSH
3522: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3526: LD_ADDR_EXP 42
3530: PUSH
3531: LD_EXP 42
3535: PPUSH
3536: LD_EXP 42
3540: PUSH
3541: LD_INT 1
3543: PLUS
3544: PPUSH
3545: LD_VAR 0 4
3549: PPUSH
3550: CALL_OW 1
3554: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3555: LD_ADDR_EXP 40
3559: PUSH
3560: EMPTY
3561: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: LD_VAR 0 5
3572: PPUSH
3573: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3577: LD_ADDR_OWVAR 26
3581: PUSH
3582: LD_STRING Pavel Grigorovic
3584: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3585: LD_ADDR_OWVAR 33
3589: PUSH
3590: LD_STRING SecondCharsGal
3592: ST_TO_ADDR
// hc_face_number := 4 ;
3593: LD_ADDR_OWVAR 34
3597: PUSH
3598: LD_INT 4
3600: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3601: LD_ADDR_EXP 40
3605: PUSH
3606: LD_EXP 40
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 44
3618: PPUSH
3619: CALL_OW 1
3623: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3624: LD_INT 2
3626: PPUSH
3627: LD_INT 4
3629: PPUSH
3630: LD_INT 2
3632: PPUSH
3633: CALL_OW 380
// hc_name := Lucy Sebel ;
3637: LD_ADDR_OWVAR 26
3641: PUSH
3642: LD_STRING Lucy Sebel
3644: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3645: LD_ADDR_OWVAR 33
3649: PUSH
3650: LD_STRING SecondCharsGal
3652: ST_TO_ADDR
// hc_face_number := 15 ;
3653: LD_ADDR_OWVAR 34
3657: PUSH
3658: LD_INT 15
3660: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3661: LD_ADDR_EXP 40
3665: PUSH
3666: LD_EXP 40
3670: PPUSH
3671: LD_INT 2
3673: PPUSH
3674: CALL_OW 44
3678: PPUSH
3679: CALL_OW 1
3683: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3684: LD_INT 2
3686: PPUSH
3687: LD_INT 4
3689: PPUSH
3690: LD_INT 2
3692: PPUSH
3693: CALL_OW 380
// hc_gallery :=  ;
3697: LD_ADDR_OWVAR 33
3701: PUSH
3702: LD_STRING 
3704: ST_TO_ADDR
// hc_name :=  ;
3705: LD_ADDR_OWVAR 26
3709: PUSH
3710: LD_STRING 
3712: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3713: LD_ADDR_EXP 40
3717: PUSH
3718: LD_EXP 40
3722: PPUSH
3723: LD_INT 3
3725: PPUSH
3726: CALL_OW 44
3730: PPUSH
3731: CALL_OW 1
3735: ST_TO_ADDR
// hc_sex := sex_male ;
3736: LD_ADDR_OWVAR 27
3740: PUSH
3741: LD_INT 1
3743: ST_TO_ADDR
// hc_class = 11 ;
3744: LD_ADDR_OWVAR 28
3748: PUSH
3749: LD_INT 11
3751: ST_TO_ADDR
// hc_gallery = sandar ;
3752: LD_ADDR_OWVAR 33
3756: PUSH
3757: LD_STRING sandar
3759: ST_TO_ADDR
// hc_face_number = 33 ;
3760: LD_ADDR_OWVAR 34
3764: PUSH
3765: LD_INT 33
3767: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3768: LD_ADDR_OWVAR 26
3772: PUSH
3773: LD_STRING Thabit Muhair Saliba
3775: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3776: LD_ADDR_OWVAR 31
3780: PUSH
3781: LD_INT 0
3783: PUSH
3784: LD_INT 0
3786: PUSH
3787: LD_INT 0
3789: PUSH
3790: LD_INT 0
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: ST_TO_ADDR
// Saliba = CreateHuman ;
3799: LD_ADDR_EXP 44
3803: PUSH
3804: CALL_OW 44
3808: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3809: LD_EXP 44
3813: PPUSH
3814: LD_INT 7
3816: PPUSH
3817: CALL_OW 52
// if gensher_active then
3821: LD_EXP 18
3825: IFFALSE 3852
// begin Gensher = NewCharacter ( Dietrich ) ;
3827: LD_ADDR_EXP 45
3831: PUSH
3832: LD_STRING Dietrich
3834: PPUSH
3835: CALL_OW 25
3839: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3840: LD_EXP 45
3844: PPUSH
3845: LD_INT 94
3847: PPUSH
3848: CALL_OW 52
// end ; InitHc ;
3852: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3856: LD_ADDR_EXP 41
3860: PUSH
3861: EMPTY
3862: ST_TO_ADDR
// for i = 1 to 5 do
3863: LD_ADDR_VAR 0 2
3867: PUSH
3868: DOUBLE
3869: LD_INT 1
3871: DEC
3872: ST_TO_ADDR
3873: LD_INT 5
3875: PUSH
3876: FOR_TO
3877: IFFALSE 4049
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3879: LD_INT 13
3881: PUSH
3882: LD_INT 14
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: PUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 2
3894: PPUSH
3895: CALL_OW 12
3899: ARRAY
3900: PPUSH
3901: LD_INT 1
3903: PUSH
3904: LD_INT 2
3906: PUSH
3907: EMPTY
3908: LIST
3909: LIST
3910: PUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 2
3916: PPUSH
3917: CALL_OW 12
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 25
3928: PUSH
3929: LD_INT 27
3931: PUSH
3932: LD_INT 26
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 3
3945: PPUSH
3946: CALL_OW 12
3950: ARRAY
3951: PPUSH
3952: LD_INT 60
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: PPUSH
3963: CALL 52338 0 5
// un := CreateVehicle ;
3967: LD_ADDR_VAR 0 4
3971: PUSH
3972: CALL_OW 45
3976: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3977: LD_ADDR_EXP 41
3981: PUSH
3982: LD_EXP 41
3986: PPUSH
3987: LD_EXP 41
3991: PUSH
3992: LD_INT 1
3994: PLUS
3995: PPUSH
3996: LD_VAR 0 4
4000: PPUSH
4001: CALL_OW 1
4005: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4006: LD_VAR 0 4
4010: PPUSH
4011: LD_INT 0
4013: PPUSH
4014: LD_INT 5
4016: PPUSH
4017: CALL_OW 12
4021: PPUSH
4022: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4026: LD_VAR 0 4
4030: PPUSH
4031: LD_INT 124
4033: PPUSH
4034: LD_INT 141
4036: PPUSH
4037: LD_INT 8
4039: PPUSH
4040: LD_INT 0
4042: PPUSH
4043: CALL_OW 50
// end ;
4047: GO 3876
4049: POP
4050: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4051: LD_ADDR_EXP 43
4055: PUSH
4056: EMPTY
4057: PUSH
4058: EMPTY
4059: PUSH
4060: EMPTY
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4067: LD_ADDR_VAR 0 3
4071: PUSH
4072: DOUBLE
4073: LD_INT 1
4075: DEC
4076: ST_TO_ADDR
4077: LD_INT 3
4079: PUSH
4080: LD_INT 3
4082: PUSH
4083: LD_INT 4
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: LIST
4090: PUSH
4091: LD_OWVAR 67
4095: ARRAY
4096: PUSH
4097: FOR_TO
4098: IFFALSE 4312
// for i = 1 to 3 do
4100: LD_ADDR_VAR 0 2
4104: PUSH
4105: DOUBLE
4106: LD_INT 1
4108: DEC
4109: ST_TO_ADDR
4110: LD_INT 3
4112: PUSH
4113: FOR_TO
4114: IFFALSE 4308
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4116: LD_INT 14
4118: PPUSH
4119: LD_INT 3
4121: PUSH
4122: LD_INT 2
4124: PUSH
4125: EMPTY
4126: LIST
4127: LIST
4128: PUSH
4129: LD_INT 1
4131: PPUSH
4132: LD_INT 2
4134: PPUSH
4135: CALL_OW 12
4139: ARRAY
4140: PPUSH
4141: LD_INT 1
4143: PUSH
4144: LD_INT 5
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: PUSH
4151: LD_INT 1
4153: PPUSH
4154: LD_INT 2
4156: PPUSH
4157: CALL_OW 12
4161: ARRAY
4162: PPUSH
4163: LD_INT 25
4165: PUSH
4166: LD_INT 27
4168: PUSH
4169: LD_INT 26
4171: PUSH
4172: LD_INT 28
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: LIST
4180: PUSH
4181: LD_INT 1
4183: PPUSH
4184: LD_INT 4
4186: PPUSH
4187: CALL_OW 12
4191: ARRAY
4192: PPUSH
4193: LD_INT 100
4195: PPUSH
4196: CALL 52338 0 5
// un := CreateVehicle ;
4200: LD_ADDR_VAR 0 4
4204: PUSH
4205: CALL_OW 45
4209: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4210: LD_ADDR_EXP 43
4214: PUSH
4215: LD_EXP 43
4219: PPUSH
4220: LD_VAR 0 2
4224: PUSH
4225: LD_EXP 43
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: PUSH
4236: LD_INT 1
4238: PLUS
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PPUSH
4244: LD_VAR 0 4
4248: PPUSH
4249: CALL 52460 0 3
4253: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4254: LD_VAR 0 4
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: LD_INT 5
4264: PPUSH
4265: CALL_OW 12
4269: PPUSH
4270: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4274: LD_VAR 0 4
4278: PPUSH
4279: LD_INT 20
4281: PUSH
4282: LD_INT 21
4284: PUSH
4285: LD_INT 22
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_VAR 0 2
4297: ARRAY
4298: PPUSH
4299: LD_INT 0
4301: PPUSH
4302: CALL_OW 49
// end ;
4306: GO 4113
4308: POP
4309: POP
4310: GO 4097
4312: POP
4313: POP
// InitHc ;
4314: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4318: LD_INT 4
4320: PPUSH
4321: LD_INT 5
4323: PPUSH
4324: LD_INT 10
4326: PPUSH
4327: LD_INT 5
4329: PPUSH
4330: LD_INT 0
4332: PPUSH
4333: CALL_OW 58
// end ;
4337: LD_VAR 0 1
4341: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4342: LD_EXP 42
4346: IFFALSE 4420
4348: GO 4350
4350: DISABLE
4351: LD_INT 0
4353: PPUSH
// begin enable ;
4354: ENABLE
// for i in ar_kamikadze do
4355: LD_ADDR_VAR 0 1
4359: PUSH
4360: LD_EXP 42
4364: PUSH
4365: FOR_IN
4366: IFFALSE 4418
// if See ( 1 , i ) then
4368: LD_INT 1
4370: PPUSH
4371: LD_VAR 0 1
4375: PPUSH
4376: CALL_OW 292
4380: IFFALSE 4416
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: LD_INT 81
4389: PUSH
4390: LD_INT 2
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PPUSH
4397: CALL_OW 69
4401: PPUSH
4402: LD_VAR 0 1
4406: PPUSH
4407: CALL_OW 74
4411: PPUSH
4412: CALL_OW 115
4416: GO 4365
4418: POP
4419: POP
// end ;
4420: PPOPN 1
4422: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4423: LD_EXP 13
4427: IFFALSE 4744
4429: GO 4431
4431: DISABLE
4432: LD_INT 0
4434: PPUSH
4435: PPUSH
4436: PPUSH
4437: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4438: LD_INT 35
4440: PPUSH
4441: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4445: LD_INT 1
4447: PPUSH
4448: CALL 41499 0 1
4452: PUSH
4453: LD_INT 0
4455: EQUAL
4456: IFFALSE 4438
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4458: LD_INT 1
4460: PPUSH
4461: LD_INT 14
4463: PUSH
4464: LD_INT 3
4466: PUSH
4467: LD_INT 2
4469: PUSH
4470: LD_INT 32
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: LIST
4477: LIST
4478: PUSH
4479: EMPTY
4480: LIST
4481: PPUSH
4482: CALL 41103 0 2
// repeat wait ( 0 0$1 ) ;
4486: LD_INT 35
4488: PPUSH
4489: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4493: LD_EXP 69
4497: PUSH
4498: LD_INT 1
4500: ARRAY
4501: PPUSH
4502: LD_INT 33
4504: PUSH
4505: LD_INT 2
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: PUSH
4512: LD_INT 34
4514: PUSH
4515: LD_INT 32
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 72
4530: IFFALSE 4486
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4532: LD_ADDR_VAR 0 2
4536: PUSH
4537: LD_EXP 69
4541: PUSH
4542: LD_INT 1
4544: ARRAY
4545: PPUSH
4546: LD_INT 33
4548: PUSH
4549: LD_INT 2
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 34
4558: PUSH
4559: LD_INT 32
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PPUSH
4570: CALL_OW 72
4574: PUSH
4575: LD_INT 1
4577: ARRAY
4578: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: LD_INT 5
4586: PPUSH
4587: CALL_OW 469
4591: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4592: LD_INT 35
4594: PPUSH
4595: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4599: LD_ADDR_VAR 0 4
4603: PUSH
4604: LD_INT 5
4606: PPUSH
4607: CALL_OW 469
4611: ST_TO_ADDR
// tmp := 100 ;
4612: LD_ADDR_VAR 0 3
4616: PUSH
4617: LD_INT 100
4619: ST_TO_ADDR
// if pos then
4620: LD_VAR 0 4
4624: IFFALSE 4664
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4626: LD_ADDR_VAR 0 3
4630: PUSH
4631: LD_INT 2
4633: PPUSH
4634: LD_VAR 0 4
4638: PUSH
4639: LD_INT 1
4641: ARRAY
4642: PPUSH
4643: LD_VAR 0 4
4647: PUSH
4648: LD_INT 2
4650: ARRAY
4651: PPUSH
4652: LD_INT 20
4654: PPUSH
4655: CALL 53356 0 4
4659: PUSH
4660: LD_INT 4
4662: ARRAY
4663: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4664: LD_VAR 0 4
4668: PUSH
4669: LD_EXP 14
4673: NOT
4674: AND
4675: PUSH
4676: LD_VAR 0 3
4680: PUSH
4681: LD_INT 10
4683: LESS
4684: AND
4685: IFFALSE 4592
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4687: LD_VAR 0 2
4691: PPUSH
4692: LD_VAR 0 4
4696: PUSH
4697: LD_INT 1
4699: ARRAY
4700: PPUSH
4701: LD_VAR 0 4
4705: PUSH
4706: LD_INT 2
4708: ARRAY
4709: PPUSH
4710: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4714: LD_VAR 0 2
4718: PPUSH
4719: LD_INT 198
4721: PPUSH
4722: LD_INT 113
4724: PPUSH
4725: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4729: LD_VAR 0 2
4733: PPUSH
4734: LD_INT 124
4736: PPUSH
4737: LD_INT 7
4739: PPUSH
4740: CALL_OW 171
// end ;
4744: PPOPN 4
4746: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4747: LD_EXP 6
4751: IFFALSE 7532
4753: GO 4755
4755: DISABLE
4756: LD_INT 0
4758: PPUSH
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
4763: PPUSH
4764: PPUSH
4765: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4766: LD_ADDR_VAR 0 4
4770: PUSH
4771: LD_INT 5
4773: PUSH
4774: LD_INT 6
4776: PUSH
4777: LD_INT 7
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: LD_OWVAR 67
4789: ARRAY
4790: ST_TO_ADDR
// coords := [ ] ;
4791: LD_ADDR_VAR 0 5
4795: PUSH
4796: EMPTY
4797: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4798: LD_ADDR_VAR 0 6
4802: PUSH
4803: LD_INT 0
4805: PUSH
4806: LD_INT 0
4808: PUSH
4809: LD_INT 0
4811: PUSH
4812: LD_INT 0
4814: PUSH
4815: LD_INT 1
4817: PUSH
4818: LD_INT 0
4820: PUSH
4821: LD_INT 0
4823: PUSH
4824: LD_INT 0
4826: PUSH
4827: LD_INT 1
4829: PUSH
4830: LD_INT 0
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4845: LD_INT 1
4847: PPUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 28
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 25
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_INT 28
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 14
4904: PUSH
4905: LD_INT 1
4907: PUSH
4908: LD_INT 2
4910: PUSH
4911: LD_INT 29
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: LIST
4918: LIST
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PPUSH
4926: CALL 41103 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4930: LD_INT 21000
4932: PUSH
4933: LD_INT 19950
4935: PUSH
4936: LD_INT 18900
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_OWVAR 67
4948: ARRAY
4949: PPUSH
4950: CALL_OW 67
// InitHc ;
4954: CALL_OW 19
// InitUc ;
4958: CALL_OW 18
// uc_side := 2 ;
4962: LD_ADDR_OWVAR 20
4966: PUSH
4967: LD_INT 2
4969: ST_TO_ADDR
// uc_nation := 2 ;
4970: LD_ADDR_OWVAR 21
4974: PUSH
4975: LD_INT 2
4977: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4978: LD_ADDR_VAR 0 3
4982: PUSH
4983: EMPTY
4984: PUSH
4985: EMPTY
4986: PUSH
4987: EMPTY
4988: PUSH
4989: EMPTY
4990: PUSH
4991: EMPTY
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
5000: LD_ADDR_VAR 0 3
5004: PUSH
5005: LD_VAR 0 3
5009: PPUSH
5010: LD_INT 1
5012: PPUSH
5013: LD_EXP 69
5017: PUSH
5018: LD_INT 1
5020: ARRAY
5021: PUSH
5022: LD_INT 34
5024: PUSH
5025: LD_INT 32
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: PPUSH
5032: CALL_OW 69
5036: DIFF
5037: PPUSH
5038: CALL_OW 1
5042: ST_TO_ADDR
// for i = 1 to Difficulty do
5043: LD_ADDR_VAR 0 1
5047: PUSH
5048: DOUBLE
5049: LD_INT 1
5051: DEC
5052: ST_TO_ADDR
5053: LD_OWVAR 67
5057: PUSH
5058: FOR_TO
5059: IFFALSE 5197
// begin uc_side := 2 ;
5061: LD_ADDR_OWVAR 20
5065: PUSH
5066: LD_INT 2
5068: ST_TO_ADDR
// uc_nation := 2 ;
5069: LD_ADDR_OWVAR 21
5073: PUSH
5074: LD_INT 2
5076: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5077: LD_INT 13
5079: PPUSH
5080: LD_INT 3
5082: PPUSH
5083: LD_INT 5
5085: PPUSH
5086: LD_INT 29
5088: PPUSH
5089: LD_INT 100
5091: PPUSH
5092: CALL 52338 0 5
// un := CreateVehicle ;
5096: LD_ADDR_VAR 0 2
5100: PUSH
5101: CALL_OW 45
5105: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5106: LD_ADDR_VAR 0 3
5110: PUSH
5111: LD_VAR 0 3
5115: PPUSH
5116: LD_INT 1
5118: PUSH
5119: LD_VAR 0 3
5123: PUSH
5124: LD_INT 1
5126: ARRAY
5127: PUSH
5128: LD_INT 1
5130: PLUS
5131: PUSH
5132: EMPTY
5133: LIST
5134: LIST
5135: PPUSH
5136: LD_VAR 0 2
5140: PPUSH
5141: CALL 52460 0 3
5145: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5146: LD_VAR 0 2
5150: PPUSH
5151: LD_INT 3
5153: PPUSH
5154: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5158: LD_VAR 0 2
5162: PPUSH
5163: LD_INT 16
5165: PPUSH
5166: LD_INT 0
5168: PPUSH
5169: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5173: LD_VAR 0 2
5177: PPUSH
5178: LD_INT 51
5180: PPUSH
5181: LD_INT 10
5183: PPUSH
5184: CALL_OW 111
// wait ( 0 0$2 ) ;
5188: LD_INT 70
5190: PPUSH
5191: CALL_OW 67
// end ;
5195: GO 5058
5197: POP
5198: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5199: LD_ADDR_VAR 0 5
5203: PUSH
5204: LD_INT 51
5206: PUSH
5207: LD_INT 24
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: PUSH
5214: LD_INT 75
5216: PUSH
5217: LD_INT 90
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5228: LD_INT 1
5230: PPUSH
5231: LD_VAR 0 3
5235: PUSH
5236: LD_INT 1
5238: ARRAY
5239: PPUSH
5240: LD_VAR 0 5
5244: PPUSH
5245: LD_VAR 0 6
5249: PPUSH
5250: CALL 41336 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5254: LD_ADDR_VAR 0 1
5258: PUSH
5259: DOUBLE
5260: LD_INT 1
5262: DEC
5263: ST_TO_ADDR
5264: LD_INT 1
5266: PUSH
5267: LD_INT 3
5269: PUSH
5270: LD_INT 3
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: PUSH
5284: FOR_TO
5285: IFFALSE 5385
// begin uc_side := 2 ;
5287: LD_ADDR_OWVAR 20
5291: PUSH
5292: LD_INT 2
5294: ST_TO_ADDR
// uc_nation := 2 ;
5295: LD_ADDR_OWVAR 21
5299: PUSH
5300: LD_INT 2
5302: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5303: LD_INT 0
5305: PPUSH
5306: LD_INT 17
5308: PPUSH
5309: LD_VAR 0 4
5313: PPUSH
5314: CALL_OW 380
// un := CreateHuman ;
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5328: LD_ADDR_VAR 0 3
5332: PUSH
5333: LD_VAR 0 3
5337: PPUSH
5338: LD_INT 2
5340: PUSH
5341: LD_VAR 0 3
5345: PUSH
5346: LD_INT 2
5348: ARRAY
5349: PUSH
5350: LD_INT 1
5352: PLUS
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_VAR 0 2
5362: PPUSH
5363: CALL 52460 0 3
5367: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5368: LD_VAR 0 2
5372: PPUSH
5373: LD_INT 13
5375: PPUSH
5376: LD_INT 0
5378: PPUSH
5379: CALL_OW 49
// end ;
5383: GO 5284
5385: POP
5386: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5387: LD_ADDR_VAR 0 1
5391: PUSH
5392: DOUBLE
5393: LD_INT 1
5395: DEC
5396: ST_TO_ADDR
5397: LD_INT 3
5399: PUSH
5400: LD_INT 4
5402: PUSH
5403: LD_INT 4
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: PUSH
5411: LD_OWVAR 67
5415: ARRAY
5416: PUSH
5417: FOR_TO
5418: IFFALSE 5539
// begin uc_side := 2 ;
5420: LD_ADDR_OWVAR 20
5424: PUSH
5425: LD_INT 2
5427: ST_TO_ADDR
// uc_nation := 2 ;
5428: LD_ADDR_OWVAR 21
5432: PUSH
5433: LD_INT 2
5435: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5436: LD_INT 0
5438: PPUSH
5439: LD_INT 1
5441: PUSH
5442: LD_INT 8
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_VAR 0 1
5453: PUSH
5454: LD_INT 2
5456: MOD
5457: PUSH
5458: LD_INT 1
5460: PLUS
5461: ARRAY
5462: PPUSH
5463: LD_VAR 0 4
5467: PPUSH
5468: CALL_OW 380
// un := CreateHuman ;
5472: LD_ADDR_VAR 0 2
5476: PUSH
5477: CALL_OW 44
5481: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5482: LD_ADDR_VAR 0 3
5486: PUSH
5487: LD_VAR 0 3
5491: PPUSH
5492: LD_INT 2
5494: PUSH
5495: LD_VAR 0 3
5499: PUSH
5500: LD_INT 2
5502: ARRAY
5503: PUSH
5504: LD_INT 1
5506: PLUS
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: PPUSH
5512: LD_VAR 0 2
5516: PPUSH
5517: CALL 52460 0 3
5521: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5522: LD_VAR 0 2
5526: PPUSH
5527: LD_INT 13
5529: PPUSH
5530: LD_INT 0
5532: PPUSH
5533: CALL_OW 49
// end ;
5537: GO 5417
5539: POP
5540: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5541: LD_ADDR_VAR 0 5
5545: PUSH
5546: LD_INT 67
5548: PUSH
5549: LD_INT 112
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 85
5558: PUSH
5559: LD_INT 130
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5570: LD_INT 2
5572: PPUSH
5573: LD_VAR 0 3
5577: PUSH
5578: LD_INT 2
5580: ARRAY
5581: PPUSH
5582: LD_VAR 0 5
5586: PPUSH
5587: LD_VAR 0 6
5591: PPUSH
5592: CALL 41336 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5596: LD_ADDR_VAR 0 1
5600: PUSH
5601: DOUBLE
5602: LD_INT 1
5604: DEC
5605: ST_TO_ADDR
5606: LD_INT 1
5608: PUSH
5609: LD_INT 2
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PUSH
5620: LD_OWVAR 67
5624: ARRAY
5625: PUSH
5626: FOR_TO
5627: IFFALSE 5727
// begin uc_side := 2 ;
5629: LD_ADDR_OWVAR 20
5633: PUSH
5634: LD_INT 2
5636: ST_TO_ADDR
// uc_nation := 2 ;
5637: LD_ADDR_OWVAR 21
5641: PUSH
5642: LD_INT 2
5644: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5645: LD_INT 0
5647: PPUSH
5648: LD_INT 17
5650: PPUSH
5651: LD_VAR 0 4
5655: PPUSH
5656: CALL_OW 380
// un := CreateHuman ;
5660: LD_ADDR_VAR 0 2
5664: PUSH
5665: CALL_OW 44
5669: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5670: LD_ADDR_VAR 0 3
5674: PUSH
5675: LD_VAR 0 3
5679: PPUSH
5680: LD_INT 3
5682: PUSH
5683: LD_VAR 0 3
5687: PUSH
5688: LD_INT 3
5690: ARRAY
5691: PUSH
5692: LD_INT 1
5694: PLUS
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: PPUSH
5700: LD_VAR 0 2
5704: PPUSH
5705: CALL 52460 0 3
5709: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5710: LD_VAR 0 2
5714: PPUSH
5715: LD_INT 14
5717: PPUSH
5718: LD_INT 0
5720: PPUSH
5721: CALL_OW 49
// end ;
5725: GO 5626
5727: POP
5728: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5729: LD_ADDR_VAR 0 5
5733: PUSH
5734: LD_INT 148
5736: PUSH
5737: LD_INT 158
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 148
5746: PUSH
5747: LD_INT 158
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5758: LD_INT 3
5760: PPUSH
5761: LD_VAR 0 3
5765: PUSH
5766: LD_INT 3
5768: ARRAY
5769: PPUSH
5770: LD_VAR 0 5
5774: PPUSH
5775: LD_VAR 0 6
5779: PPUSH
5780: CALL 41336 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5784: LD_ADDR_VAR 0 1
5788: PUSH
5789: DOUBLE
5790: LD_INT 1
5792: DEC
5793: ST_TO_ADDR
5794: LD_INT 2
5796: PUSH
5797: LD_INT 4
5799: PUSH
5800: LD_INT 4
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: FOR_TO
5815: IFFALSE 6039
// begin uc_side := 2 ;
5817: LD_ADDR_OWVAR 20
5821: PUSH
5822: LD_INT 2
5824: ST_TO_ADDR
// uc_nation := 2 ;
5825: LD_ADDR_OWVAR 21
5829: PUSH
5830: LD_INT 2
5832: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5833: LD_INT 14
5835: PPUSH
5836: LD_INT 3
5838: PPUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 5
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 2
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: PPUSH
5861: LD_INT 27
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 28
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 1
5877: PPUSH
5878: LD_INT 3
5880: PPUSH
5881: CALL_OW 12
5885: ARRAY
5886: PPUSH
5887: LD_INT 100
5889: PPUSH
5890: CALL 52338 0 5
// un := CreateVehicle ;
5894: LD_ADDR_VAR 0 2
5898: PUSH
5899: CALL_OW 45
5903: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5904: LD_ADDR_VAR 0 3
5908: PUSH
5909: LD_VAR 0 3
5913: PPUSH
5914: LD_INT 4
5916: PUSH
5917: LD_VAR 0 3
5921: PUSH
5922: LD_INT 4
5924: ARRAY
5925: PUSH
5926: LD_INT 1
5928: PLUS
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: LD_VAR 0 2
5938: PPUSH
5939: CALL 52460 0 3
5943: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5944: LD_VAR 0 2
5948: PPUSH
5949: LD_INT 5
5951: PPUSH
5952: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5956: LD_VAR 0 2
5960: PPUSH
5961: LD_INT 15
5963: PPUSH
5964: LD_INT 0
5966: PPUSH
5967: CALL_OW 49
// if GetControl ( un ) = control_manual then
5971: LD_VAR 0 2
5975: PPUSH
5976: CALL_OW 263
5980: PUSH
5981: LD_INT 1
5983: EQUAL
5984: IFFALSE 6015
// begin PrepareHuman ( false , 3 , skill ) ;
5986: LD_INT 0
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_VAR 0 4
5996: PPUSH
5997: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6001: CALL_OW 44
6005: PPUSH
6006: LD_VAR 0 2
6010: PPUSH
6011: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 179
6022: PPUSH
6023: LD_INT 135
6025: PPUSH
6026: CALL_OW 111
// wait ( 0 0$2 ) ;
6030: LD_INT 70
6032: PPUSH
6033: CALL_OW 67
// end ;
6037: GO 5814
6039: POP
6040: POP
// vc_chassis := 15 ;
6041: LD_ADDR_OWVAR 37
6045: PUSH
6046: LD_INT 15
6048: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6049: LD_ADDR_VAR 0 3
6053: PUSH
6054: LD_VAR 0 3
6058: PPUSH
6059: LD_INT 4
6061: PUSH
6062: LD_VAR 0 3
6066: PUSH
6067: LD_INT 4
6069: ARRAY
6070: PUSH
6071: LD_INT 1
6073: PLUS
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PPUSH
6079: CALL_OW 45
6083: PPUSH
6084: CALL 52460 0 3
6088: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6089: LD_VAR 0 3
6093: PUSH
6094: LD_INT 4
6096: ARRAY
6097: PUSH
6098: LD_VAR 0 3
6102: PUSH
6103: LD_INT 4
6105: ARRAY
6106: ARRAY
6107: PPUSH
6108: LD_INT 15
6110: PPUSH
6111: LD_INT 0
6113: PPUSH
6114: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6118: LD_INT 0
6120: PPUSH
6121: LD_INT 11
6123: PPUSH
6124: LD_VAR 0 4
6128: PPUSH
6129: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6133: LD_ADDR_VAR 0 3
6137: PUSH
6138: LD_VAR 0 3
6142: PPUSH
6143: LD_INT 4
6145: PUSH
6146: LD_VAR 0 3
6150: PUSH
6151: LD_INT 4
6153: ARRAY
6154: PUSH
6155: LD_INT 1
6157: PLUS
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 44
6167: PPUSH
6168: CALL 52460 0 3
6172: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6173: LD_VAR 0 3
6177: PUSH
6178: LD_INT 4
6180: ARRAY
6181: PUSH
6182: LD_VAR 0 3
6186: PUSH
6187: LD_INT 4
6189: ARRAY
6190: ARRAY
6191: PPUSH
6192: LD_VAR 0 3
6196: PUSH
6197: LD_INT 4
6199: ARRAY
6200: PUSH
6201: LD_VAR 0 3
6205: PUSH
6206: LD_INT 4
6208: ARRAY
6209: PUSH
6210: LD_INT 1
6212: MINUS
6213: ARRAY
6214: PPUSH
6215: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6219: LD_ADDR_VAR 0 5
6223: PUSH
6224: LD_INT 148
6226: PUSH
6227: LD_INT 140
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PUSH
6234: EMPTY
6235: LIST
6236: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6237: LD_INT 1
6239: PPUSH
6240: LD_VAR 0 3
6244: PUSH
6245: LD_INT 4
6247: ARRAY
6248: PPUSH
6249: LD_VAR 0 5
6253: PPUSH
6254: LD_VAR 0 6
6258: PPUSH
6259: CALL 41336 0 4
// if gensher_active then
6263: LD_EXP 18
6267: IFFALSE 6669
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6269: LD_EXP 45
6273: PPUSH
6274: LD_STRING D10-Diet-1
6276: PPUSH
6277: CALL_OW 94
// for i = 1 to 2 do
6281: LD_ADDR_VAR 0 1
6285: PUSH
6286: DOUBLE
6287: LD_INT 1
6289: DEC
6290: ST_TO_ADDR
6291: LD_INT 2
6293: PUSH
6294: FOR_TO
6295: IFFALSE 6433
// begin uc_side := 2 ;
6297: LD_ADDR_OWVAR 20
6301: PUSH
6302: LD_INT 2
6304: ST_TO_ADDR
// uc_nation := 2 ;
6305: LD_ADDR_OWVAR 21
6309: PUSH
6310: LD_INT 2
6312: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6313: LD_INT 13
6315: PPUSH
6316: LD_INT 3
6318: PPUSH
6319: LD_INT 5
6321: PPUSH
6322: LD_INT 29
6324: PPUSH
6325: LD_INT 100
6327: PPUSH
6328: CALL 52338 0 5
// un := CreateVehicle ;
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: CALL_OW 45
6341: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6342: LD_ADDR_VAR 0 3
6346: PUSH
6347: LD_VAR 0 3
6351: PPUSH
6352: LD_INT 5
6354: PUSH
6355: LD_VAR 0 3
6359: PUSH
6360: LD_INT 5
6362: ARRAY
6363: PUSH
6364: LD_INT 1
6366: PLUS
6367: PUSH
6368: EMPTY
6369: LIST
6370: LIST
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL 52460 0 3
6381: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6382: LD_VAR 0 2
6386: PPUSH
6387: LD_INT 0
6389: PPUSH
6390: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6394: LD_VAR 0 2
6398: PPUSH
6399: LD_INT 23
6401: PPUSH
6402: LD_INT 0
6404: PPUSH
6405: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6409: LD_VAR 0 2
6413: PPUSH
6414: LD_INT 85
6416: PPUSH
6417: LD_INT 152
6419: PPUSH
6420: CALL_OW 111
// wait ( 0 0$2 ) ;
6424: LD_INT 70
6426: PPUSH
6427: CALL_OW 67
// end ;
6431: GO 6294
6433: POP
6434: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6435: LD_ADDR_VAR 0 1
6439: PUSH
6440: DOUBLE
6441: LD_INT 1
6443: DEC
6444: ST_TO_ADDR
6445: LD_INT 2
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: LD_INT 3
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: PUSH
6459: LD_OWVAR 67
6463: ARRAY
6464: PUSH
6465: FOR_TO
6466: IFFALSE 6623
// begin uc_side := 2 ;
6468: LD_ADDR_OWVAR 20
6472: PUSH
6473: LD_INT 2
6475: ST_TO_ADDR
// uc_nation := 2 ;
6476: LD_ADDR_OWVAR 21
6480: PUSH
6481: LD_INT 2
6483: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6484: LD_INT 14
6486: PPUSH
6487: LD_INT 3
6489: PPUSH
6490: LD_INT 5
6492: PPUSH
6493: LD_INT 27
6495: PUSH
6496: LD_INT 28
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PUSH
6503: LD_INT 1
6505: PPUSH
6506: LD_INT 2
6508: PPUSH
6509: CALL_OW 12
6513: ARRAY
6514: PPUSH
6515: LD_INT 100
6517: PPUSH
6518: CALL 52338 0 5
// un := CreateVehicle ;
6522: LD_ADDR_VAR 0 2
6526: PUSH
6527: CALL_OW 45
6531: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6532: LD_ADDR_VAR 0 3
6536: PUSH
6537: LD_VAR 0 3
6541: PPUSH
6542: LD_INT 5
6544: PUSH
6545: LD_VAR 0 3
6549: PUSH
6550: LD_INT 5
6552: ARRAY
6553: PUSH
6554: LD_INT 1
6556: PLUS
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: PPUSH
6562: LD_VAR 0 2
6566: PPUSH
6567: CALL 52460 0 3
6571: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6572: LD_VAR 0 2
6576: PPUSH
6577: LD_INT 0
6579: PPUSH
6580: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6584: LD_VAR 0 2
6588: PPUSH
6589: LD_INT 23
6591: PPUSH
6592: LD_INT 0
6594: PPUSH
6595: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6599: LD_VAR 0 2
6603: PPUSH
6604: LD_INT 85
6606: PPUSH
6607: LD_INT 152
6609: PPUSH
6610: CALL_OW 111
// wait ( 0 0$2 ) ;
6614: LD_INT 70
6616: PPUSH
6617: CALL_OW 67
// end ;
6621: GO 6465
6623: POP
6624: POP
// coords := [ [ 97 , 143 ] ] ;
6625: LD_ADDR_VAR 0 5
6629: PUSH
6630: LD_INT 97
6632: PUSH
6633: LD_INT 143
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: EMPTY
6641: LIST
6642: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6643: LD_INT 1
6645: PPUSH
6646: LD_VAR 0 3
6650: PUSH
6651: LD_INT 5
6653: ARRAY
6654: PPUSH
6655: LD_VAR 0 5
6659: PPUSH
6660: LD_VAR 0 6
6664: PPUSH
6665: CALL 41336 0 4
// end ; Wait ( 13 13$00 ) ;
6669: LD_INT 27300
6671: PPUSH
6672: CALL_OW 67
// tmp := [ ] ;
6676: LD_ADDR_VAR 0 3
6680: PUSH
6681: EMPTY
6682: ST_TO_ADDR
// w := 1 ;
6683: LD_ADDR_VAR 0 7
6687: PUSH
6688: LD_INT 1
6690: ST_TO_ADDR
// repeat tmp := [ ] ;
6691: LD_ADDR_VAR 0 3
6695: PUSH
6696: EMPTY
6697: ST_TO_ADDR
// if w mod 4 = 0 then
6698: LD_VAR 0 7
6702: PUSH
6703: LD_INT 4
6705: MOD
6706: PUSH
6707: LD_INT 0
6709: EQUAL
6710: IFFALSE 6797
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6712: LD_ADDR_VAR 0 8
6716: PUSH
6717: LD_INT 11
6719: PUSH
6720: LD_INT 1
6722: PUSH
6723: LD_INT 2
6725: PUSH
6726: LD_INT 24
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: LIST
6733: LIST
6734: PUSH
6735: LD_INT 11
6737: PUSH
6738: LD_INT 1
6740: PUSH
6741: LD_INT 2
6743: PUSH
6744: LD_INT 24
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 11
6755: PUSH
6756: LD_INT 1
6758: PUSH
6759: LD_INT 2
6761: PUSH
6762: LD_INT 24
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: LIST
6769: LIST
6770: PUSH
6771: LD_INT 11
6773: PUSH
6774: LD_INT 1
6776: PUSH
6777: LD_INT 2
6779: PUSH
6780: LD_INT 24
6782: PUSH
6783: EMPTY
6784: LIST
6785: LIST
6786: LIST
6787: LIST
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: ST_TO_ADDR
6795: GO 6899
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6797: LD_ADDR_VAR 0 8
6801: PUSH
6802: LD_INT 14
6804: PUSH
6805: LD_INT 1
6807: PUSH
6808: LD_INT 2
6810: PUSH
6811: LD_INT 28
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 14
6822: PUSH
6823: LD_INT 1
6825: PUSH
6826: LD_INT 2
6828: PUSH
6829: LD_INT 25
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PUSH
6838: LD_INT 14
6840: PUSH
6841: LD_INT 1
6843: PUSH
6844: LD_INT 2
6846: PUSH
6847: LD_INT 28
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 14
6858: PUSH
6859: LD_INT 1
6861: PUSH
6862: LD_INT 2
6864: PUSH
6865: LD_INT 29
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 11
6876: PUSH
6877: LD_INT 1
6879: PUSH
6880: LD_INT 2
6882: PUSH
6883: LD_INT 24
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: LIST
6898: ST_TO_ADDR
// if w mod 3 = 0 then
6899: LD_VAR 0 7
6903: PUSH
6904: LD_INT 3
6906: MOD
6907: PUSH
6908: LD_INT 0
6910: EQUAL
6911: IFFALSE 6987
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6913: LD_ADDR_VAR 0 8
6917: PUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: LD_INT 1
6925: PUSH
6926: LD_VAR 0 8
6930: PUSH
6931: LD_VAR 0 1
6935: ARRAY
6936: PUSH
6937: LD_INT 1
6939: PLUS
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PPUSH
6945: LD_INT 14
6947: PUSH
6948: LD_INT 1
6950: PUSH
6951: LD_INT 2
6953: PUSH
6954: LD_INT 25
6956: PUSH
6957: LD_INT 28
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 1
6966: PPUSH
6967: LD_INT 2
6969: PPUSH
6970: CALL_OW 12
6974: ARRAY
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: PPUSH
6982: CALL 52460 0 3
6986: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6987: LD_INT 1
6989: PPUSH
6990: LD_VAR 0 8
6994: PPUSH
6995: CALL 41103 0 2
// if GetSide ( ar_dep_w ) = 2 then
6999: LD_INT 45
7001: PPUSH
7002: CALL_OW 255
7006: PUSH
7007: LD_INT 2
7009: EQUAL
7010: IFFALSE 7095
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7012: LD_ADDR_VAR 0 8
7016: PUSH
7017: LD_INT 14
7019: PUSH
7020: LD_INT 1
7022: PUSH
7023: LD_INT 2
7025: PUSH
7026: LD_INT 28
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 14
7037: PUSH
7038: LD_INT 1
7040: PUSH
7041: LD_INT 2
7043: PUSH
7044: LD_INT 27
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: PUSH
7053: LD_INT 14
7055: PUSH
7056: LD_INT 1
7058: PUSH
7059: LD_INT 2
7061: PUSH
7062: LD_INT 27
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7076: LD_INT 2
7078: PPUSH
7079: LD_VAR 0 8
7083: PPUSH
7084: CALL 41103 0 2
// wait ( 0 0$50 ) ;
7088: LD_INT 1750
7090: PPUSH
7091: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7095: LD_INT 35
7097: PPUSH
7098: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7102: LD_EXP 69
7106: PUSH
7107: LD_INT 1
7109: ARRAY
7110: PPUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 34
7116: PUSH
7117: LD_INT 32
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PPUSH
7128: CALL_OW 72
7132: PUSH
7133: LD_INT 4
7135: GREATEREQUAL
7136: IFFALSE 7095
// wait ( 0 0$10 ) ;
7138: LD_INT 350
7140: PPUSH
7141: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7145: LD_ADDR_VAR 0 3
7149: PUSH
7150: LD_EXP 69
7154: PUSH
7155: LD_INT 1
7157: ARRAY
7158: PPUSH
7159: LD_INT 3
7161: PUSH
7162: LD_INT 34
7164: PUSH
7165: LD_INT 32
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: PPUSH
7176: CALL_OW 72
7180: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7181: LD_INT 100
7183: PPUSH
7184: CALL_OW 13
7188: PUSH
7189: LD_INT 50
7191: LESS
7192: IFFALSE 7225
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7194: LD_ADDR_VAR 0 5
7198: PUSH
7199: LD_INT 55
7201: PUSH
7202: LD_INT 7
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 75
7211: PUSH
7212: LD_INT 90
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: ST_TO_ADDR
7223: GO 7254
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7225: LD_ADDR_VAR 0 5
7229: PUSH
7230: LD_INT 128
7232: PUSH
7233: LD_INT 94
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: PUSH
7240: LD_INT 180
7242: PUSH
7243: LD_INT 135
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: ST_TO_ADDR
// if w mod 4 = 0 then
7254: LD_VAR 0 7
7258: PUSH
7259: LD_INT 4
7261: MOD
7262: PUSH
7263: LD_INT 0
7265: EQUAL
7266: IFFALSE 7297
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7268: LD_ADDR_VAR 0 5
7272: PUSH
7273: LD_INT 91
7275: PUSH
7276: LD_INT 58
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: LD_INT 117
7285: PUSH
7286: LD_INT 107
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7297: LD_VAR 0 3
7301: PPUSH
7302: LD_VAR 0 5
7306: PUSH
7307: LD_INT 1
7309: ARRAY
7310: PPUSH
7311: LD_VAR 0 5
7315: PUSH
7316: LD_INT 2
7318: ARRAY
7319: PPUSH
7320: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7324: LD_INT 35
7326: PPUSH
7327: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7331: LD_VAR 0 3
7335: PPUSH
7336: LD_INT 60
7338: PUSH
7339: EMPTY
7340: LIST
7341: PPUSH
7342: CALL_OW 72
7346: PUSH
7347: LD_INT 0
7349: EQUAL
7350: IFFALSE 7324
// repeat wait ( 0 0$2 ) ;
7352: LD_INT 70
7354: PPUSH
7355: CALL_OW 67
// for i in tmp do
7359: LD_ADDR_VAR 0 1
7363: PUSH
7364: LD_VAR 0 3
7368: PUSH
7369: FOR_IN
7370: IFFALSE 7459
// if GetChassis ( i ) = ar_hovercraft then
7372: LD_VAR 0 1
7376: PPUSH
7377: CALL_OW 265
7381: PUSH
7382: LD_INT 11
7384: EQUAL
7385: IFFALSE 7423
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7387: LD_VAR 0 1
7391: PPUSH
7392: LD_INT 22
7394: PUSH
7395: LD_INT 1
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PPUSH
7402: CALL_OW 69
7406: PPUSH
7407: LD_VAR 0 1
7411: PPUSH
7412: CALL_OW 74
7416: PPUSH
7417: CALL 79648 0 2
7421: GO 7457
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7423: LD_VAR 0 1
7427: PPUSH
7428: LD_INT 22
7430: PUSH
7431: LD_INT 1
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PPUSH
7438: CALL_OW 69
7442: PPUSH
7443: LD_VAR 0 1
7447: PPUSH
7448: CALL_OW 74
7452: PPUSH
7453: CALL_OW 115
7457: GO 7369
7459: POP
7460: POP
// until not tmp ;
7461: LD_VAR 0 3
7465: NOT
7466: IFFALSE 7352
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7468: LD_INT 22050
7470: PPUSH
7471: LD_INT 28350
7473: PPUSH
7474: CALL_OW 12
7478: PPUSH
7479: CALL_OW 67
// w := w + 1 ;
7483: LD_ADDR_VAR 0 7
7487: PUSH
7488: LD_VAR 0 7
7492: PUSH
7493: LD_INT 1
7495: PLUS
7496: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7497: LD_INT 94
7499: PPUSH
7500: CALL_OW 301
7504: PUSH
7505: LD_EXP 50
7509: PUSH
7510: LD_INT 1
7512: ARRAY
7513: PPUSH
7514: LD_INT 30
7516: PUSH
7517: LD_INT 3
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: NOT
7529: OR
7530: IFFALSE 6691
// end ;
7532: PPOPN 8
7534: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7535: LD_INT 204
7537: IFFALSE 8003
7539: GO 7541
7541: DISABLE
7542: LD_INT 0
7544: PPUSH
7545: PPUSH
7546: PPUSH
7547: PPUSH
// begin enable ;
7548: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7549: LD_INT 35
7551: PPUSH
7552: LD_INT 1190
7554: PPUSH
7555: CALL_OW 12
7559: PPUSH
7560: CALL_OW 67
// tmp := [ ] ;
7564: LD_ADDR_VAR 0 2
7568: PUSH
7569: EMPTY
7570: ST_TO_ADDR
// uc_side := 8 ;
7571: LD_ADDR_OWVAR 20
7575: PUSH
7576: LD_INT 8
7578: ST_TO_ADDR
// uc_nation := 2 ;
7579: LD_ADDR_OWVAR 21
7583: PUSH
7584: LD_INT 2
7586: ST_TO_ADDR
// InitHc ;
7587: CALL_OW 19
// for i = 1 to 3 do
7591: LD_ADDR_VAR 0 1
7595: PUSH
7596: DOUBLE
7597: LD_INT 1
7599: DEC
7600: ST_TO_ADDR
7601: LD_INT 3
7603: PUSH
7604: FOR_TO
7605: IFFALSE 7732
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7607: LD_INT 13
7609: PUSH
7610: LD_INT 14
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 1
7619: PPUSH
7620: LD_INT 2
7622: PPUSH
7623: CALL_OW 12
7627: ARRAY
7628: PPUSH
7629: LD_INT 3
7631: PPUSH
7632: LD_INT 5
7634: PPUSH
7635: LD_INT 27
7637: PUSH
7638: LD_INT 28
7640: PUSH
7641: EMPTY
7642: LIST
7643: LIST
7644: PUSH
7645: LD_INT 1
7647: PPUSH
7648: LD_INT 2
7650: PPUSH
7651: CALL_OW 12
7655: ARRAY
7656: PPUSH
7657: LD_INT 100
7659: PPUSH
7660: CALL 52338 0 5
// un := CreateVehicle ;
7664: LD_ADDR_VAR 0 3
7668: PUSH
7669: CALL_OW 45
7673: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7674: LD_VAR 0 3
7678: PPUSH
7679: LD_INT 4
7681: PPUSH
7682: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7686: LD_VAR 0 3
7690: PPUSH
7691: LD_INT 15
7693: PPUSH
7694: LD_INT 0
7696: PPUSH
7697: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7701: LD_ADDR_VAR 0 2
7705: PUSH
7706: LD_VAR 0 2
7710: PPUSH
7711: LD_VAR 0 2
7715: PUSH
7716: LD_INT 1
7718: PLUS
7719: PPUSH
7720: LD_VAR 0 3
7724: PPUSH
7725: CALL_OW 1
7729: ST_TO_ADDR
// end ;
7730: GO 7604
7732: POP
7733: POP
// for i = 1 to 4 do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: DOUBLE
7740: LD_INT 1
7742: DEC
7743: ST_TO_ADDR
7744: LD_INT 4
7746: PUSH
7747: FOR_TO
7748: IFFALSE 7819
// begin PrepareHuman ( false , 1 , 6 ) ;
7750: LD_INT 0
7752: PPUSH
7753: LD_INT 1
7755: PPUSH
7756: LD_INT 6
7758: PPUSH
7759: CALL_OW 380
// un := CreateHuman ;
7763: LD_ADDR_VAR 0 3
7767: PUSH
7768: CALL_OW 44
7772: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7773: LD_VAR 0 3
7777: PPUSH
7778: LD_INT 15
7780: PPUSH
7781: LD_INT 0
7783: PPUSH
7784: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7788: LD_ADDR_VAR 0 2
7792: PUSH
7793: LD_VAR 0 2
7797: PPUSH
7798: LD_VAR 0 2
7802: PUSH
7803: LD_INT 1
7805: PLUS
7806: PPUSH
7807: LD_VAR 0 3
7811: PPUSH
7812: CALL_OW 1
7816: ST_TO_ADDR
// end ;
7817: GO 7747
7819: POP
7820: POP
// wait ( 0 0$3 ) ;
7821: LD_INT 105
7823: PPUSH
7824: CALL_OW 67
// for i in tmp do
7828: LD_ADDR_VAR 0 1
7832: PUSH
7833: LD_VAR 0 2
7837: PUSH
7838: FOR_IN
7839: IFFALSE 7907
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7841: LD_VAR 0 1
7845: PPUSH
7846: CALL_OW 257
7850: PUSH
7851: LD_INT 1
7853: EQUAL
7854: PUSH
7855: LD_VAR 0 1
7859: PPUSH
7860: CALL_OW 247
7864: PUSH
7865: LD_INT 2
7867: EQUAL
7868: OR
7869: IFFALSE 7905
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7871: LD_VAR 0 1
7875: PPUSH
7876: LD_INT 81
7878: PUSH
7879: LD_INT 8
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: PPUSH
7886: CALL_OW 69
7890: PPUSH
7891: LD_VAR 0 1
7895: PPUSH
7896: CALL_OW 74
7900: PPUSH
7901: CALL_OW 115
7905: GO 7838
7907: POP
7908: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7909: LD_VAR 0 2
7913: PPUSH
7914: LD_INT 210
7916: PPUSH
7917: LD_INT 178
7919: PPUSH
7920: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7924: LD_ADDR_VAR 0 4
7928: PUSH
7929: LD_INT 10
7931: PPUSH
7932: LD_INT 22
7934: PUSH
7935: LD_INT 8
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PPUSH
7942: CALL_OW 70
7946: ST_TO_ADDR
// if x then
7947: LD_VAR 0 4
7951: IFFALSE 7979
// for i in x do
7953: LD_ADDR_VAR 0 1
7957: PUSH
7958: LD_VAR 0 4
7962: PUSH
7963: FOR_IN
7964: IFFALSE 7977
// RemoveUnit ( i ) ;
7966: LD_VAR 0 1
7970: PPUSH
7971: CALL_OW 64
7975: GO 7963
7977: POP
7978: POP
// wait ( 0 0$1 ) ;
7979: LD_INT 35
7981: PPUSH
7982: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7986: LD_INT 22
7988: PUSH
7989: LD_INT 8
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: PPUSH
7996: CALL_OW 69
8000: NOT
8001: IFFALSE 7909
// end ;
8003: PPOPN 4
8005: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8006: LD_INT 22
8008: PUSH
8009: LD_INT 2
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 34
8018: PUSH
8019: LD_INT 31
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 3
8028: PUSH
8029: LD_INT 24
8031: PUSH
8032: LD_INT 1000
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: LIST
8047: PPUSH
8048: CALL_OW 69
8052: IFFALSE 8155
8054: GO 8056
8056: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8057: LD_INT 45
8059: PPUSH
8060: CALL_OW 302
8064: PUSH
8065: LD_INT 45
8067: PPUSH
8068: CALL_OW 255
8072: AND
8073: IFFALSE 8116
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8075: LD_INT 22
8077: PUSH
8078: LD_INT 2
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: LD_INT 34
8087: PUSH
8088: LD_INT 31
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 69
8103: PPUSH
8104: LD_INT 18
8106: PPUSH
8107: LD_INT 8
8109: PPUSH
8110: CALL_OW 111
8114: GO 8155
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8116: LD_INT 22
8118: PUSH
8119: LD_INT 2
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 34
8128: PUSH
8129: LD_INT 31
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 69
8144: PPUSH
8145: LD_INT 106
8147: PPUSH
8148: LD_INT 14
8150: PPUSH
8151: CALL_OW 111
// end ; end_of_file
8155: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8156: LD_INT 0
8158: PPUSH
8159: PPUSH
8160: PPUSH
8161: PPUSH
8162: PPUSH
8163: PPUSH
// InGameOn ;
8164: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8168: LD_EXP 21
8172: PPUSH
8173: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8177: LD_INT 2
8179: PPUSH
8180: LD_INT 1
8182: PPUSH
8183: LD_INT 1
8185: PPUSH
8186: LD_INT 1
8188: PPUSH
8189: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8193: LD_ADDR_VAR 0 2
8197: PUSH
8198: LD_INT 22
8200: PUSH
8201: LD_INT 1
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 25
8210: PUSH
8211: LD_INT 1
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8227: LD_ADDR_VAR 0 4
8231: PUSH
8232: LD_INT 22
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: LD_INT 34
8244: PUSH
8245: LD_INT 11
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PPUSH
8256: CALL_OW 69
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: ST_TO_ADDR
// for i = 1 to tmp do
8265: LD_ADDR_VAR 0 6
8269: PUSH
8270: DOUBLE
8271: LD_INT 1
8273: DEC
8274: ST_TO_ADDR
8275: LD_VAR 0 2
8279: PUSH
8280: FOR_TO
8281: IFFALSE 8328
// begin if i = 5 then
8283: LD_VAR 0 6
8287: PUSH
8288: LD_INT 5
8290: EQUAL
8291: IFFALSE 8295
// break ;
8293: GO 8328
// sols := Replace ( sols , i , tmp [ i ] ) ;
8295: LD_ADDR_VAR 0 5
8299: PUSH
8300: LD_VAR 0 5
8304: PPUSH
8305: LD_VAR 0 6
8309: PPUSH
8310: LD_VAR 0 2
8314: PUSH
8315: LD_VAR 0 6
8319: ARRAY
8320: PPUSH
8321: CALL_OW 1
8325: ST_TO_ADDR
// end ;
8326: GO 8280
8328: POP
8329: POP
// tmp := ar_force_tmp ;
8330: LD_ADDR_VAR 0 2
8334: PUSH
8335: LD_EXP 40
8339: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8340: LD_VAR 0 2
8344: PUSH
8345: LD_INT 1
8347: ARRAY
8348: PPUSH
8349: LD_INT 108
8351: PPUSH
8352: LD_INT 139
8354: PPUSH
8355: LD_INT 0
8357: PPUSH
8358: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8362: LD_VAR 0 2
8366: PUSH
8367: LD_INT 1
8369: ARRAY
8370: PPUSH
8371: LD_EXP 21
8375: PPUSH
8376: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8380: LD_VAR 0 2
8384: PUSH
8385: LD_INT 2
8387: ARRAY
8388: PPUSH
8389: LD_INT 114
8391: PPUSH
8392: LD_INT 132
8394: PPUSH
8395: LD_INT 0
8397: PPUSH
8398: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 3
8409: ARRAY
8410: PPUSH
8411: LD_INT 115
8413: PPUSH
8414: LD_INT 132
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8424: LD_VAR 0 2
8428: PUSH
8429: LD_INT 2
8431: ARRAY
8432: PUSH
8433: LD_VAR 0 2
8437: PUSH
8438: LD_INT 3
8440: ARRAY
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PPUSH
8446: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8450: LD_VAR 0 4
8454: PPUSH
8455: LD_INT 83
8457: PPUSH
8458: LD_INT 123
8460: PPUSH
8461: CALL_OW 111
// Wait ( 0 0$01 ) ;
8465: LD_INT 35
8467: PPUSH
8468: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8472: LD_INT 90
8474: PPUSH
8475: LD_INT 144
8477: PPUSH
8478: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8482: LD_VAR 0 5
8486: PPUSH
8487: LD_INT 88
8489: PPUSH
8490: LD_INT 129
8492: PPUSH
8493: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: LD_INT 92
8504: PUSH
8505: LD_INT 131
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: PUSH
8512: LD_INT 88
8514: PUSH
8515: LD_INT 127
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 91
8524: PUSH
8525: LD_INT 132
8527: PUSH
8528: EMPTY
8529: LIST
8530: LIST
8531: PUSH
8532: LD_INT 92
8534: PUSH
8535: LD_INT 134
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: EMPTY
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: ST_TO_ADDR
// for i = 1 to sols do
8548: LD_ADDR_VAR 0 6
8552: PUSH
8553: DOUBLE
8554: LD_INT 1
8556: DEC
8557: ST_TO_ADDR
8558: LD_VAR 0 5
8562: PUSH
8563: FOR_TO
8564: IFFALSE 8637
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8566: LD_VAR 0 5
8570: PUSH
8571: LD_VAR 0 6
8575: ARRAY
8576: PPUSH
8577: LD_VAR 0 3
8581: PUSH
8582: LD_VAR 0 6
8586: ARRAY
8587: PUSH
8588: LD_INT 1
8590: ARRAY
8591: PPUSH
8592: LD_VAR 0 3
8596: PUSH
8597: LD_VAR 0 6
8601: ARRAY
8602: PUSH
8603: LD_INT 2
8605: ARRAY
8606: PPUSH
8607: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8611: LD_VAR 0 5
8615: PUSH
8616: LD_VAR 0 6
8620: ARRAY
8621: PPUSH
8622: CALL_OW 197
// AddComHold ( sols ) ;
8626: LD_VAR 0 5
8630: PPUSH
8631: CALL_OW 200
// end ;
8635: GO 8563
8637: POP
8638: POP
// repeat wait ( 0 0$1 ) ;
8639: LD_INT 35
8641: PPUSH
8642: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8646: LD_VAR 0 5
8650: PUSH
8651: LD_INT 1
8653: ARRAY
8654: PPUSH
8655: LD_INT 92
8657: PPUSH
8658: LD_INT 131
8660: PPUSH
8661: CALL_OW 297
8665: PUSH
8666: LD_INT 4
8668: LESS
8669: IFFALSE 8639
// CenterOnXY ( 96 , 139 ) ;
8671: LD_INT 96
8673: PPUSH
8674: LD_INT 139
8676: PPUSH
8677: CALL_OW 84
// wait ( 0 0$3 ) ;
8681: LD_INT 105
8683: PPUSH
8684: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8688: LD_INT 111
8690: PPUSH
8691: LD_INT 135
8693: PPUSH
8694: LD_INT 1
8696: PPUSH
8697: LD_INT 25
8699: NEG
8700: PPUSH
8701: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8705: LD_VAR 0 2
8709: PUSH
8710: LD_INT 2
8712: ARRAY
8713: PPUSH
8714: LD_VAR 0 2
8718: PUSH
8719: LD_INT 1
8721: ARRAY
8722: PPUSH
8723: CALL_OW 250
8727: PUSH
8728: LD_INT 3
8730: PLUS
8731: PPUSH
8732: LD_VAR 0 2
8736: PUSH
8737: LD_INT 1
8739: ARRAY
8740: PPUSH
8741: CALL_OW 251
8745: PPUSH
8746: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 3
8757: ARRAY
8758: PPUSH
8759: LD_INT 7
8761: PPUSH
8762: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8766: LD_VAR 0 2
8770: PUSH
8771: LD_INT 2
8773: ARRAY
8774: PPUSH
8775: LD_VAR 0 2
8779: PUSH
8780: LD_INT 1
8782: ARRAY
8783: PPUSH
8784: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8788: LD_INT 35
8790: PPUSH
8791: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8795: LD_VAR 0 2
8799: PUSH
8800: LD_INT 1
8802: ARRAY
8803: PPUSH
8804: LD_VAR 0 2
8808: PUSH
8809: LD_INT 2
8811: ARRAY
8812: PPUSH
8813: CALL_OW 296
8817: PUSH
8818: LD_INT 5
8820: LESS
8821: IFFALSE 8788
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8823: LD_VAR 0 2
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PPUSH
8832: LD_VAR 0 2
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PPUSH
8841: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8845: LD_VAR 0 2
8849: PUSH
8850: LD_INT 1
8852: ARRAY
8853: PPUSH
8854: LD_STRING D1a-Merc1-1
8856: PPUSH
8857: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8861: LD_VAR 0 2
8865: PUSH
8866: LD_INT 2
8868: ARRAY
8869: PPUSH
8870: LD_STRING D1a-FMerc2-1
8872: PPUSH
8873: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8877: LD_VAR 0 2
8881: PUSH
8882: LD_INT 2
8884: ARRAY
8885: PPUSH
8886: LD_VAR 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8899: LD_VAR 0 2
8903: PUSH
8904: LD_INT 1
8906: ARRAY
8907: PPUSH
8908: LD_INT 500
8910: PPUSH
8911: CALL_OW 234
// wait ( 0 0$2 ) ;
8915: LD_INT 70
8917: PPUSH
8918: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8922: LD_VAR 0 2
8926: PUSH
8927: LD_INT 1
8929: ARRAY
8930: PPUSH
8931: LD_INT 2
8933: PPUSH
8934: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8938: LD_INT 10
8940: PPUSH
8941: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8945: LD_VAR 0 2
8949: PUSH
8950: LD_INT 1
8952: ARRAY
8953: PPUSH
8954: LD_STRING D1a-Merc1-2
8956: PPUSH
8957: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8961: LD_INT 7
8963: PPUSH
8964: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8968: LD_VAR 0 2
8972: PUSH
8973: LD_INT 1
8975: ARRAY
8976: PPUSH
8977: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8981: LD_VAR 0 2
8985: PUSH
8986: LD_INT 2
8988: ARRAY
8989: PPUSH
8990: LD_INT 10
8992: PPUSH
8993: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8997: LD_VAR 0 2
9001: PUSH
9002: LD_INT 2
9004: ARRAY
9005: PPUSH
9006: LD_STRING D1a-FMerc2-2
9008: PPUSH
9009: CALL_OW 88
// wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9020: LD_INT 7
9022: PPUSH
9023: CALL_OW 85
// wait ( 0 0$2 ) ;
9027: LD_INT 70
9029: PPUSH
9030: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9034: LD_EXP 44
9038: PPUSH
9039: LD_STRING D1a-Saliba-1
9041: PPUSH
9042: CALL_OW 91
// KillUnit ( Saliba ) ;
9046: LD_EXP 44
9050: PPUSH
9051: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9055: LD_VAR 0 2
9059: PUSH
9060: LD_INT 3
9062: ARRAY
9063: PPUSH
9064: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9068: LD_EXP 21
9072: PPUSH
9073: CALL_OW 85
// wait ( 0 0$1 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9084: LD_VAR 0 5
9088: PPUSH
9089: LD_INT 88
9091: PPUSH
9092: LD_INT 141
9094: PPUSH
9095: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9099: LD_VAR 0 5
9103: PPUSH
9104: LD_INT 70
9106: PPUSH
9107: CALL_OW 202
// wait ( 0 0$2 ) ;
9111: LD_INT 70
9113: PPUSH
9114: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9118: LD_INT 2
9120: PPUSH
9121: LD_INT 1
9123: PPUSH
9124: LD_INT 2
9126: PPUSH
9127: LD_INT 1
9129: PPUSH
9130: CALL_OW 80
// InGameOff ;
9134: CALL_OW 9
// ComWalk ( sols ) ;
9138: LD_VAR 0 5
9142: PPUSH
9143: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9147: LD_STRING M1
9149: PPUSH
9150: CALL_OW 337
// game_speed := 4 ;
9154: LD_ADDR_OWVAR 65
9158: PUSH
9159: LD_INT 4
9161: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9162: LD_INT 111
9164: PPUSH
9165: LD_INT 135
9167: PPUSH
9168: LD_INT 1
9170: PPUSH
9171: CALL_OW 331
// SaveForQuickRestart ;
9175: CALL_OW 22
// ar_run := true ;
9179: LD_ADDR_EXP 5
9183: PUSH
9184: LD_INT 1
9186: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9187: LD_INT 35
9189: PPUSH
9190: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9194: LD_INT 22
9196: PUSH
9197: LD_INT 1
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PUSH
9204: LD_INT 91
9206: PUSH
9207: LD_INT 7
9209: PUSH
9210: LD_INT 10
9212: PUSH
9213: EMPTY
9214: LIST
9215: LIST
9216: LIST
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PPUSH
9222: CALL_OW 69
9226: PUSH
9227: LD_INT 7
9229: PPUSH
9230: CALL_OW 256
9234: PUSH
9235: LD_INT 999
9237: LESS
9238: OR
9239: IFFALSE 9187
// if GetSide ( ar_dep_s ) = 2 then
9241: LD_INT 7
9243: PPUSH
9244: CALL_OW 255
9248: PUSH
9249: LD_INT 2
9251: EQUAL
9252: IFFALSE 9264
// SetSide ( ar_dep_s , 1 ) ;
9254: LD_INT 7
9256: PPUSH
9257: LD_INT 1
9259: PPUSH
9260: CALL_OW 235
// end ;
9264: LD_VAR 0 1
9268: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9269: LD_EXP 5
9273: IFFALSE 9633
9275: GO 9277
9277: DISABLE
9278: LD_INT 0
9280: PPUSH
9281: PPUSH
9282: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9283: LD_ADDR_VAR 0 2
9287: PUSH
9288: LD_EXP 40
9292: PUSH
9293: LD_EXP 36
9297: PPUSH
9298: LD_INT 2
9300: PUSH
9301: LD_INT 21
9303: PUSH
9304: LD_INT 2
9306: PUSH
9307: EMPTY
9308: LIST
9309: LIST
9310: PUSH
9311: LD_INT 21
9313: PUSH
9314: LD_INT 1
9316: PUSH
9317: EMPTY
9318: LIST
9319: LIST
9320: PUSH
9321: EMPTY
9322: LIST
9323: LIST
9324: LIST
9325: PPUSH
9326: CALL_OW 72
9330: ADD
9331: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9332: LD_VAR 0 2
9336: PPUSH
9337: LD_INT 5
9339: PPUSH
9340: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9344: LD_INT 5
9346: PPUSH
9347: LD_INT 1
9349: PPUSH
9350: CALL_OW 343
// k := 1 ;
9354: LD_ADDR_VAR 0 3
9358: PUSH
9359: LD_INT 1
9361: ST_TO_ADDR
// for i in tmp do
9362: LD_ADDR_VAR 0 1
9366: PUSH
9367: LD_VAR 0 2
9371: PUSH
9372: FOR_IN
9373: IFFALSE 9458
// begin if IsInUnit ( i ) then
9375: LD_VAR 0 1
9379: PPUSH
9380: CALL_OW 310
9384: IFFALSE 9395
// ComExitBuilding ( i ) ;
9386: LD_VAR 0 1
9390: PPUSH
9391: CALL_OW 122
// if GetClass ( i ) = 3 then
9395: LD_VAR 0 1
9399: PPUSH
9400: CALL_OW 257
9404: PUSH
9405: LD_INT 3
9407: EQUAL
9408: IFFALSE 9444
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9410: LD_VAR 0 1
9414: PPUSH
9415: LD_EXP 41
9419: PUSH
9420: LD_VAR 0 3
9424: ARRAY
9425: PPUSH
9426: CALL_OW 180
// k := k + 1 ;
9430: LD_ADDR_VAR 0 3
9434: PUSH
9435: LD_VAR 0 3
9439: PUSH
9440: LD_INT 1
9442: PLUS
9443: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9444: LD_VAR 0 1
9448: PPUSH
9449: LD_INT 10
9451: PPUSH
9452: CALL_OW 173
// end ;
9456: GO 9372
9458: POP
9459: POP
// ar_patrol := true ;
9460: LD_ADDR_EXP 7
9464: PUSH
9465: LD_INT 1
9467: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9468: LD_INT 10
9470: PPUSH
9471: CALL_OW 67
// for i in tmp do
9475: LD_ADDR_VAR 0 1
9479: PUSH
9480: LD_VAR 0 2
9484: PUSH
9485: FOR_IN
9486: IFFALSE 9514
// if not HasTask ( i ) then
9488: LD_VAR 0 1
9492: PPUSH
9493: CALL_OW 314
9497: NOT
9498: IFFALSE 9512
// ComMoveToArea ( i , escape_area ) ;
9500: LD_VAR 0 1
9504: PPUSH
9505: LD_INT 10
9507: PPUSH
9508: CALL_OW 113
9512: GO 9485
9514: POP
9515: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9516: LD_ADDR_VAR 0 3
9520: PUSH
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_INT 95
9528: PUSH
9529: LD_INT 10
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PPUSH
9536: CALL_OW 72
9540: ST_TO_ADDR
// if k then
9541: LD_VAR 0 3
9545: IFFALSE 9614
// for i in k do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 3
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9612
// begin if IsInUnit ( i ) then
9560: LD_VAR 0 1
9564: PPUSH
9565: CALL_OW 310
9569: IFFALSE 9585
// RemoveUnit ( IsInUnit ( i ) ) ;
9571: LD_VAR 0 1
9575: PPUSH
9576: CALL_OW 310
9580: PPUSH
9581: CALL_OW 64
// RemoveUnit ( i ) ;
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 64
// tmp := tmp diff i ;
9594: LD_ADDR_VAR 0 2
9598: PUSH
9599: LD_VAR 0 2
9603: PUSH
9604: LD_VAR 0 1
9608: DIFF
9609: ST_TO_ADDR
// end ;
9610: GO 9557
9612: POP
9613: POP
// until tmp = [ ] ;
9614: LD_VAR 0 2
9618: PUSH
9619: EMPTY
9620: EQUAL
9621: IFFALSE 9468
// ChangeSideFog ( 5 , 5 ) ;
9623: LD_INT 5
9625: PPUSH
9626: LD_INT 5
9628: PPUSH
9629: CALL_OW 343
// end ;
9633: PPOPN 3
9635: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9636: LD_EXP 7
9640: IFFALSE 9930
9642: GO 9644
9644: DISABLE
9645: LD_INT 0
9647: PPUSH
9648: PPUSH
9649: PPUSH
// begin uc_side := 2 ;
9650: LD_ADDR_OWVAR 20
9654: PUSH
9655: LD_INT 2
9657: ST_TO_ADDR
// uc_nation := 2 ;
9658: LD_ADDR_OWVAR 21
9662: PUSH
9663: LD_INT 2
9665: ST_TO_ADDR
// InitHc ;
9666: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9670: LD_INT 1
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 6
9678: PPUSH
9679: CALL_OW 380
// un := CreateHuman ;
9683: LD_ADDR_VAR 0 2
9687: PUSH
9688: CALL_OW 44
9692: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9693: LD_INT 14
9695: PPUSH
9696: LD_INT 1
9698: PPUSH
9699: LD_INT 1
9701: PPUSH
9702: LD_INT 27
9704: PPUSH
9705: LD_INT 98
9707: PPUSH
9708: CALL 52338 0 5
// veh := CreateVehicle ;
9712: LD_ADDR_VAR 0 3
9716: PUSH
9717: CALL_OW 45
9721: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9722: LD_VAR 0 3
9726: PPUSH
9727: LD_INT 4
9729: PPUSH
9730: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9734: LD_VAR 0 3
9738: PPUSH
9739: LD_INT 179
9741: PPUSH
9742: LD_INT 135
9744: PPUSH
9745: LD_INT 0
9747: PPUSH
9748: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9752: LD_VAR 0 2
9756: PPUSH
9757: LD_VAR 0 3
9761: PPUSH
9762: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9766: LD_VAR 0 2
9770: PPUSH
9771: LD_INT 126
9773: PPUSH
9774: LD_INT 133
9776: PPUSH
9777: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9781: LD_INT 10
9783: PPUSH
9784: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9788: LD_INT 1
9790: PPUSH
9791: LD_VAR 0 3
9795: PPUSH
9796: CALL_OW 292
9800: PUSH
9801: LD_VAR 0 3
9805: PPUSH
9806: LD_INT 7
9808: PPUSH
9809: CALL_OW 296
9813: PUSH
9814: LD_INT 9
9816: LESS
9817: OR
9818: IFFALSE 9781
// ComHold ( veh ) ;
9820: LD_VAR 0 3
9824: PPUSH
9825: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9829: LD_VAR 0 2
9833: PPUSH
9834: LD_STRING D2aa-Ar1-1
9836: PPUSH
9837: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9841: LD_VAR 0 2
9845: PPUSH
9846: LD_INT 177
9848: PPUSH
9849: LD_INT 96
9851: PPUSH
9852: CALL_OW 111
// AddComExitVehicle ( un ) ;
9856: LD_VAR 0 2
9860: PPUSH
9861: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9865: LD_INT 35
9867: PPUSH
9868: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_INT 204
9879: PPUSH
9880: CALL_OW 296
9884: PUSH
9885: LD_INT 15
9887: LESS
9888: IFFALSE 9865
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9890: LD_ADDR_EXP 50
9894: PUSH
9895: LD_EXP 50
9899: PPUSH
9900: LD_INT 3
9902: PUSH
9903: LD_EXP 50
9907: PUSH
9908: LD_INT 3
9910: ARRAY
9911: PUSH
9912: LD_INT 1
9914: PLUS
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PPUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: CALL 52460 0 3
9929: ST_TO_ADDR
// end ;
9930: PPOPN 3
9932: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9933: LD_INT 7
9935: PPUSH
9936: CALL_OW 255
9940: PUSH
9941: LD_INT 1
9943: EQUAL
9944: PUSH
9945: LD_INT 7
9947: PPUSH
9948: CALL_OW 301
9952: OR
9953: IFFALSE 12357
9955: GO 9957
9957: DISABLE
9958: LD_INT 0
9960: PPUSH
9961: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9962: LD_ADDR_VAR 0 1
9966: PUSH
9967: LD_EXP 36
9971: PPUSH
9972: LD_INT 21
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: PUSH
9987: FOR_IN
9988: IFFALSE 10004
// SetSide ( i , 1 ) ;
9990: LD_VAR 0 1
9994: PPUSH
9995: LD_INT 1
9997: PPUSH
9998: CALL_OW 235
10002: GO 9987
10004: POP
10005: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10006: LD_ADDR_VAR 0 2
10010: PUSH
10011: LD_INT 46
10013: PUSH
10014: LD_INT 41
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 50
10023: PUSH
10024: LD_INT 25
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 57
10033: PUSH
10034: LD_INT 75
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 75
10043: PUSH
10044: LD_INT 89
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: LD_INT 51
10053: PUSH
10054: LD_INT 45
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PUSH
10061: LD_INT 95
10063: PUSH
10064: LD_INT 95
10066: PUSH
10067: EMPTY
10068: LIST
10069: LIST
10070: PUSH
10071: LD_INT 84
10073: PUSH
10074: LD_INT 77
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: PUSH
10081: LD_INT 101
10083: PUSH
10084: LD_INT 76
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: PUSH
10091: LD_INT 118
10093: PUSH
10094: LD_INT 81
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: PUSH
10101: LD_INT 139
10103: PUSH
10104: LD_INT 97
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: PUSH
10111: LD_INT 129
10113: PUSH
10114: LD_INT 114
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PUSH
10121: LD_INT 154
10123: PUSH
10124: LD_INT 111
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: ST_TO_ADDR
// base_captured := true ;
10145: LD_ADDR_EXP 6
10149: PUSH
10150: LD_INT 1
10152: ST_TO_ADDR
// DialogueOn ;
10153: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10157: LD_EXP 21
10161: PPUSH
10162: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10166: LD_EXP 21
10170: PPUSH
10171: LD_STRING D2-JMM-1
10173: PPUSH
10174: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10178: LD_EXP 30
10182: PPUSH
10183: LD_STRING D2-Pow-1
10185: PPUSH
10186: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10190: LD_EXP 21
10194: PPUSH
10195: LD_STRING D2-JMM-2
10197: PPUSH
10198: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10202: LD_EXP 30
10206: PPUSH
10207: LD_STRING D2-Pow-2
10209: PPUSH
10210: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10214: LD_EXP 21
10218: PPUSH
10219: LD_STRING D2-JMM-3
10221: PPUSH
10222: CALL_OW 88
// DialogueOff ;
10226: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10230: LD_STRING M2
10232: PPUSH
10233: CALL_OW 337
// Wait ( 0 0$2 ) ;
10237: LD_INT 70
10239: PPUSH
10240: CALL_OW 67
// if IsOk ( Gary ) then
10244: LD_EXP 32
10248: PPUSH
10249: CALL_OW 302
10253: IFFALSE 10267
// Say ( Gary , D2a-Gary-1 ) ;
10255: LD_EXP 32
10259: PPUSH
10260: LD_STRING D2a-Gary-1
10262: PPUSH
10263: CALL_OW 88
// if IsOk ( Bobby ) then
10267: LD_EXP 24
10271: PPUSH
10272: CALL_OW 302
10276: IFFALSE 10290
// Say ( Bobby , D2a-Bobby-1 ) ;
10278: LD_EXP 24
10282: PPUSH
10283: LD_STRING D2a-Bobby-1
10285: PPUSH
10286: CALL_OW 88
// if IsOk ( Cyrus ) then
10290: LD_EXP 25
10294: PPUSH
10295: CALL_OW 302
10299: IFFALSE 10313
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10301: LD_EXP 25
10305: PPUSH
10306: LD_STRING D2a-Cyrus-1
10308: PPUSH
10309: CALL_OW 88
// if IsOk ( Lisa ) then
10313: LD_EXP 22
10317: PPUSH
10318: CALL_OW 302
10322: IFFALSE 10336
// Say ( Lisa , D2a-Lisa-1 ) ;
10324: LD_EXP 22
10328: PPUSH
10329: LD_STRING D2a-Lisa-1
10331: PPUSH
10332: CALL_OW 88
// if IsOk ( Frank ) then
10336: LD_EXP 33
10340: PPUSH
10341: CALL_OW 302
10345: IFFALSE 10359
// Say ( Frank , D2a-Frank-1 ) ;
10347: LD_EXP 33
10351: PPUSH
10352: LD_STRING D2a-Frank-1
10354: PPUSH
10355: CALL_OW 88
// if IsOk ( Cornel ) then
10359: LD_EXP 31
10363: PPUSH
10364: CALL_OW 302
10368: IFFALSE 10382
// Say ( Cornel , D2a-Corn-1 ) ;
10370: LD_EXP 31
10374: PPUSH
10375: LD_STRING D2a-Corn-1
10377: PPUSH
10378: CALL_OW 88
// if IsOk ( Donaldson ) then
10382: LD_EXP 23
10386: PPUSH
10387: CALL_OW 302
10391: IFFALSE 10405
// Say ( Donaldson , D2a-Don-1 ) ;
10393: LD_EXP 23
10397: PPUSH
10398: LD_STRING D2a-Don-1
10400: PPUSH
10401: CALL_OW 88
// if IsOk ( Brown ) then
10405: LD_EXP 27
10409: PPUSH
10410: CALL_OW 302
10414: IFFALSE 10428
// Say ( Brown , D2a-Brown-1 ) ;
10416: LD_EXP 27
10420: PPUSH
10421: LD_STRING D2a-Brown-1
10423: PPUSH
10424: CALL_OW 88
// Wait ( 0 0$30 ) ;
10428: LD_INT 1050
10430: PPUSH
10431: CALL_OW 67
// if IsOk ( Frank ) then
10435: LD_EXP 33
10439: PPUSH
10440: CALL_OW 302
10444: IFFALSE 10710
// begin DialogueOn ;
10446: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10450: LD_EXP 21
10454: PUSH
10455: LD_EXP 33
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PPUSH
10464: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10468: LD_EXP 33
10472: PPUSH
10473: LD_STRING D3F-Frank-1
10475: PPUSH
10476: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10480: LD_EXP 21
10484: PPUSH
10485: LD_STRING D3F-JMM-1
10487: PPUSH
10488: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10492: LD_EXP 33
10496: PPUSH
10497: LD_STRING D3F-Frank-2
10499: PPUSH
10500: CALL_OW 88
// case Query ( QFrank ) of 1 :
10504: LD_STRING QFrank
10506: PPUSH
10507: CALL_OW 97
10511: PUSH
10512: LD_INT 1
10514: DOUBLE
10515: EQUAL
10516: IFTRUE 10520
10518: GO 10543
10520: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10521: LD_EXP 21
10525: PPUSH
10526: LD_STRING D3Fa-JMM-1
10528: PPUSH
10529: CALL_OW 88
// us_scout := 1 ;
10533: LD_ADDR_EXP 8
10537: PUSH
10538: LD_INT 1
10540: ST_TO_ADDR
// end ; 2 :
10541: GO 10706
10543: LD_INT 2
10545: DOUBLE
10546: EQUAL
10547: IFTRUE 10551
10549: GO 10673
10551: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10552: LD_EXP 21
10556: PPUSH
10557: LD_STRING D3Fb-JMM-1
10559: PPUSH
10560: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10564: LD_EXP 33
10568: PPUSH
10569: LD_STRING D3Fb-Frank-1
10571: PPUSH
10572: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10576: LD_STRING QFrank2
10578: PPUSH
10579: CALL_OW 97
10583: PUSH
10584: LD_INT 1
10586: DOUBLE
10587: EQUAL
10588: IFTRUE 10592
10590: GO 10639
10592: POP
// begin us_scout := 2 ;
10593: LD_ADDR_EXP 8
10597: PUSH
10598: LD_INT 2
10600: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10601: LD_EXP 21
10605: PPUSH
10606: LD_STRING D3Fba-JMM-1
10608: PPUSH
10609: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10613: LD_EXP 33
10617: PPUSH
10618: LD_STRING D3Fba-Frank-1
10620: PPUSH
10621: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10625: LD_EXP 21
10629: PPUSH
10630: LD_STRING D3Fba-JMM-2
10632: PPUSH
10633: CALL_OW 88
// end ; 2 :
10637: GO 10671
10639: LD_INT 2
10641: DOUBLE
10642: EQUAL
10643: IFTRUE 10647
10645: GO 10670
10647: POP
// begin us_scout := 0 ;
10648: LD_ADDR_EXP 8
10652: PUSH
10653: LD_INT 0
10655: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10656: LD_EXP 21
10660: PPUSH
10661: LD_STRING D3Fbb-JMM-1
10663: PPUSH
10664: CALL_OW 88
// end ; end ;
10668: GO 10671
10670: POP
// end ; 3 :
10671: GO 10706
10673: LD_INT 3
10675: DOUBLE
10676: EQUAL
10677: IFTRUE 10681
10679: GO 10705
10681: POP
// begin us_scout := - 1 ;
10682: LD_ADDR_EXP 8
10686: PUSH
10687: LD_INT 1
10689: NEG
10690: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10691: LD_EXP 21
10695: PPUSH
10696: LD_STRING D3Fc-JMM-1
10698: PPUSH
10699: CALL_OW 88
// end ; end ;
10703: GO 10706
10705: POP
// DialogueOff ;
10706: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10710: LD_EXP 8
10714: PUSH
10715: LD_INT 1
10717: NEG
10718: PUSH
10719: LD_INT 0
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: IN
10726: IFFALSE 10730
// exit ;
10728: GO 12357
// if us_scout in [ 1 , 2 ] then
10730: LD_EXP 8
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: LD_INT 2
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: IN
10745: IFFALSE 11424
// begin if IsInUnit ( Frank ) then
10747: LD_EXP 33
10751: PPUSH
10752: CALL_OW 310
10756: IFFALSE 10767
// ComExit ( Frank ) ;
10758: LD_EXP 33
10762: PPUSH
10763: CALL 83891 0 1
// SetSide ( Frank , 4 ) ;
10767: LD_EXP 33
10771: PPUSH
10772: LD_INT 4
10774: PPUSH
10775: CALL_OW 235
// wait ( 0 0$1 ) ;
10779: LD_INT 35
10781: PPUSH
10782: CALL_OW 67
// if us_scout = 2 then
10786: LD_EXP 8
10790: PUSH
10791: LD_INT 2
10793: EQUAL
10794: IFFALSE 11162
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10796: LD_EXP 33
10800: PPUSH
10801: LD_INT 75
10803: PPUSH
10804: LD_INT 63
10806: PPUSH
10807: CALL_OW 111
// AddComHold ( Frank ) ;
10811: LD_EXP 33
10815: PPUSH
10816: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10820: LD_EXP 33
10824: PPUSH
10825: LD_INT 770
10827: PPUSH
10828: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10832: LD_EXP 33
10836: PPUSH
10837: LD_INT 100
10839: PPUSH
10840: LD_INT 75
10842: PPUSH
10843: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10847: LD_EXP 33
10851: PPUSH
10852: LD_INT 123
10854: PPUSH
10855: LD_INT 103
10857: PPUSH
10858: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10862: LD_EXP 33
10866: PPUSH
10867: LD_INT 138
10869: PPUSH
10870: LD_INT 108
10872: PPUSH
10873: CALL_OW 171
// AddComHold ( Frank ) ;
10877: LD_EXP 33
10881: PPUSH
10882: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10886: LD_INT 35
10888: PPUSH
10889: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10893: LD_EXP 33
10897: PPUSH
10898: LD_INT 138
10900: PPUSH
10901: LD_INT 108
10903: PPUSH
10904: CALL_OW 307
10908: IFFALSE 10886
// AddComMoveXY ( Frank , 125 , 132 ) ;
10910: LD_EXP 33
10914: PPUSH
10915: LD_INT 125
10917: PPUSH
10918: LD_INT 132
10920: PPUSH
10921: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10925: LD_INT 35
10927: PPUSH
10928: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10932: LD_INT 1
10934: PPUSH
10935: LD_EXP 33
10939: PPUSH
10940: CALL_OW 292
10944: PUSH
10945: LD_EXP 33
10949: PPUSH
10950: LD_INT 7
10952: PPUSH
10953: CALL_OW 296
10957: PUSH
10958: LD_INT 7
10960: LESS
10961: OR
10962: IFFALSE 10925
// DialogueOn ;
10964: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10968: LD_EXP 33
10972: PPUSH
10973: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10977: LD_INT 10
10979: PPUSH
10980: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10984: LD_EXP 21
10988: PPUSH
10989: LD_STRING D4Fa-JMM-1
10991: PPUSH
10992: CALL_OW 88
// for i in points do
10996: LD_ADDR_VAR 0 1
11000: PUSH
11001: LD_VAR 0 2
11005: PUSH
11006: FOR_IN
11007: IFFALSE 11065
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11009: LD_VAR 0 1
11013: PUSH
11014: LD_INT 1
11016: ARRAY
11017: PPUSH
11018: LD_VAR 0 1
11022: PUSH
11023: LD_INT 2
11025: ARRAY
11026: PPUSH
11027: LD_INT 1
11029: PPUSH
11030: LD_INT 20
11032: NEG
11033: PPUSH
11034: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11038: LD_VAR 0 1
11042: PUSH
11043: LD_INT 1
11045: ARRAY
11046: PPUSH
11047: LD_VAR 0 1
11051: PUSH
11052: LD_INT 2
11054: ARRAY
11055: PPUSH
11056: LD_INT 1
11058: PPUSH
11059: CALL_OW 331
// end ;
11063: GO 11006
11065: POP
11066: POP
// dwait ( 0 0$0.5 ) ;
11067: LD_INT 18
11069: PPUSH
11070: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11074: LD_INT 42
11076: PPUSH
11077: LD_INT 27
11079: PPUSH
11080: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11084: LD_EXP 33
11088: PPUSH
11089: LD_STRING D4Fa-Frank-1
11091: PPUSH
11092: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11096: LD_INT 18
11098: PPUSH
11099: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11103: LD_EXP 21
11107: PPUSH
11108: LD_STRING D4Fa-JMM-2
11110: PPUSH
11111: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11115: LD_INT 118
11117: PPUSH
11118: LD_INT 80
11120: PPUSH
11121: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11125: LD_EXP 33
11129: PPUSH
11130: LD_STRING D4Fa-Frank-2
11132: PPUSH
11133: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11137: LD_INT 10
11139: PPUSH
11140: CALL_OW 68
// DialogueOff ;
11144: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11148: LD_EXP 33
11152: PPUSH
11153: LD_INT 1
11155: PPUSH
11156: CALL_OW 235
// end else
11160: GO 11424
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11162: LD_INT 2
11164: PPUSH
11165: LD_INT 4
11167: PPUSH
11168: LD_INT 2
11170: PPUSH
11171: LD_INT 1
11173: PPUSH
11174: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11178: LD_EXP 33
11182: PPUSH
11183: LD_INT 75
11185: PPUSH
11186: LD_INT 63
11188: PPUSH
11189: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11193: LD_EXP 33
11197: PPUSH
11198: LD_INT 175
11200: PPUSH
11201: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11205: LD_EXP 33
11209: PPUSH
11210: LD_INT 102
11212: PPUSH
11213: LD_INT 76
11215: PPUSH
11216: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11220: LD_EXP 33
11224: PPUSH
11225: LD_INT 108
11227: PPUSH
11228: LD_INT 70
11230: PPUSH
11231: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11235: LD_INT 35
11237: PPUSH
11238: CALL_OW 67
// until See ( 2 , Frank ) ;
11242: LD_INT 2
11244: PPUSH
11245: LD_EXP 33
11249: PPUSH
11250: CALL_OW 292
11254: IFFALSE 11235
// ComMoveXY ( Frank , 112 , 118 ) ;
11256: LD_EXP 33
11260: PPUSH
11261: LD_INT 112
11263: PPUSH
11264: LD_INT 118
11266: PPUSH
11267: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11271: LD_EXP 33
11275: PPUSH
11276: CALL_OW 256
11280: PUSH
11281: LD_INT 750
11283: GREATEREQUAL
11284: IFFALSE 11298
// SetLives ( Frank , 700 ) ;
11286: LD_EXP 33
11290: PPUSH
11291: LD_INT 700
11293: PPUSH
11294: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11298: LD_INT 35
11300: PPUSH
11301: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11305: LD_INT 1
11307: PPUSH
11308: LD_EXP 33
11312: PPUSH
11313: CALL_OW 292
11317: PUSH
11318: LD_EXP 33
11322: PPUSH
11323: LD_INT 7
11325: PPUSH
11326: CALL_OW 296
11330: PUSH
11331: LD_INT 17
11333: LESS
11334: OR
11335: IFFALSE 11298
// DialogueOn ;
11337: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11341: LD_EXP 33
11345: PPUSH
11346: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11350: LD_EXP 33
11354: PPUSH
11355: LD_STRING D4Fb-Frank-1
11357: PPUSH
11358: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11362: LD_EXP 21
11366: PPUSH
11367: LD_STRING D4Fb-JMM-1
11369: PPUSH
11370: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11374: LD_INT 2
11376: PPUSH
11377: LD_STRING D4Fb-FSci1-1
11379: PPUSH
11380: CALL 16261 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11384: LD_EXP 33
11388: PPUSH
11389: LD_STRING D4Fb-Frank-2
11391: PPUSH
11392: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11396: LD_EXP 21
11400: PPUSH
11401: LD_STRING D4Fb-JMM-2
11403: PPUSH
11404: CALL_OW 88
// DialogueOff ;
11408: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11412: LD_EXP 33
11416: PPUSH
11417: LD_INT 1
11419: PPUSH
11420: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11424: LD_EXP 34
11428: PPUSH
11429: CALL_OW 302
11433: PUSH
11434: LD_EXP 33
11438: NOT
11439: AND
11440: IFFALSE 11588
// begin DialogueOn ;
11442: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11446: LD_EXP 21
11450: PUSH
11451: LD_EXP 34
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: PPUSH
11460: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11464: LD_EXP 34
11468: PPUSH
11469: LD_STRING D3Y-Yam-1
11471: PPUSH
11472: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11476: LD_EXP 21
11480: PPUSH
11481: LD_STRING D3Y-JMM-1
11483: PPUSH
11484: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11488: LD_EXP 34
11492: PPUSH
11493: LD_STRING D3Y-Yam-2
11495: PPUSH
11496: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11500: LD_STRING QYamoko
11502: PPUSH
11503: CALL_OW 97
11507: PUSH
11508: LD_INT 1
11510: DOUBLE
11511: EQUAL
11512: IFTRUE 11516
11514: GO 11551
11516: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11517: LD_EXP 21
11521: PPUSH
11522: LD_STRING D3Ya-JMM-1
11524: PPUSH
11525: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11529: LD_EXP 34
11533: PPUSH
11534: LD_STRING D3Ya-Yam-1
11536: PPUSH
11537: CALL_OW 88
// us_scout := 1 ;
11541: LD_ADDR_EXP 8
11545: PUSH
11546: LD_INT 1
11548: ST_TO_ADDR
// end ; 2 :
11549: GO 11584
11551: LD_INT 2
11553: DOUBLE
11554: EQUAL
11555: IFTRUE 11559
11557: GO 11583
11559: POP
// begin us_scout := - 1 ;
11560: LD_ADDR_EXP 8
11564: PUSH
11565: LD_INT 1
11567: NEG
11568: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11569: LD_EXP 21
11573: PPUSH
11574: LD_STRING D3Yb-JMM-1
11576: PPUSH
11577: CALL_OW 88
// end ; end ;
11581: GO 11584
11583: POP
// DialogueOff ;
11584: CALL_OW 7
// end ; if Frank then
11588: LD_EXP 33
11592: IFFALSE 11596
// exit ;
11594: GO 12357
// if us_scout in [ - 1 , 0 ] then
11596: LD_EXP 8
11600: PUSH
11601: LD_INT 1
11603: NEG
11604: PUSH
11605: LD_INT 0
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: IN
11612: IFFALSE 11616
// exit ;
11614: GO 12357
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11616: LD_ADDR_EXP 8
11620: PUSH
11621: LD_INT 2
11623: PUSH
11624: LD_INT 2
11626: PUSH
11627: LD_INT 1
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: LIST
11634: PUSH
11635: LD_OWVAR 67
11639: ARRAY
11640: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11641: LD_EXP 8
11645: PUSH
11646: LD_INT 1
11648: PUSH
11649: LD_INT 2
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: IN
11656: IFFALSE 12357
// begin if IsInUnit ( Kikuchi ) then
11658: LD_EXP 34
11662: PPUSH
11663: CALL_OW 310
11667: IFFALSE 11678
// ComExitBuilding ( Kikuchi ) ;
11669: LD_EXP 34
11673: PPUSH
11674: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11678: LD_EXP 34
11682: PPUSH
11683: CALL_OW 311
11687: IFFALSE 11698
// ComExitVehicle ( Kikuchi ) ;
11689: LD_EXP 34
11693: PPUSH
11694: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11698: LD_EXP 34
11702: PPUSH
11703: LD_INT 4
11705: PPUSH
11706: CALL_OW 235
// wait ( 0 0$1 ) ;
11710: LD_INT 35
11712: PPUSH
11713: CALL_OW 67
// if us_scout = 2 then
11717: LD_EXP 8
11721: PUSH
11722: LD_INT 2
11724: EQUAL
11725: IFFALSE 12105
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11727: LD_EXP 34
11731: PPUSH
11732: LD_INT 75
11734: PPUSH
11735: LD_INT 63
11737: PPUSH
11738: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11742: LD_EXP 34
11746: PPUSH
11747: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11751: LD_EXP 34
11755: PPUSH
11756: LD_INT 770
11758: PPUSH
11759: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11763: LD_EXP 34
11767: PPUSH
11768: LD_INT 100
11770: PPUSH
11771: LD_INT 75
11773: PPUSH
11774: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11778: LD_EXP 34
11782: PPUSH
11783: LD_INT 123
11785: PPUSH
11786: LD_INT 103
11788: PPUSH
11789: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11793: LD_EXP 34
11797: PPUSH
11798: LD_INT 138
11800: PPUSH
11801: LD_INT 108
11803: PPUSH
11804: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11808: LD_EXP 34
11812: PPUSH
11813: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11817: LD_INT 35
11819: PPUSH
11820: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11824: LD_EXP 34
11828: PPUSH
11829: LD_INT 138
11831: PPUSH
11832: LD_INT 108
11834: PPUSH
11835: CALL_OW 307
11839: IFFALSE 11817
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11841: LD_EXP 34
11845: PPUSH
11846: LD_INT 125
11848: PPUSH
11849: LD_INT 132
11851: PPUSH
11852: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11856: LD_INT 35
11858: PPUSH
11859: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11863: LD_INT 1
11865: PPUSH
11866: LD_EXP 34
11870: PPUSH
11871: CALL_OW 292
11875: PUSH
11876: LD_EXP 34
11880: PPUSH
11881: LD_INT 7
11883: PPUSH
11884: CALL_OW 296
11888: PUSH
11889: LD_INT 7
11891: LESS
11892: OR
11893: IFFALSE 11856
// DialogueOn ;
11895: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11899: LD_EXP 34
11903: PPUSH
11904: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11908: LD_INT 10
11910: PPUSH
11911: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11915: LD_EXP 34
11919: PPUSH
11920: LD_STRING D4Ya-Yam-1
11922: PPUSH
11923: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11927: LD_EXP 21
11931: PPUSH
11932: LD_STRING D4Ya-JMM-1
11934: PPUSH
11935: CALL_OW 88
// for i in points do
11939: LD_ADDR_VAR 0 1
11943: PUSH
11944: LD_VAR 0 2
11948: PUSH
11949: FOR_IN
11950: IFFALSE 12008
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11952: LD_VAR 0 1
11956: PUSH
11957: LD_INT 1
11959: ARRAY
11960: PPUSH
11961: LD_VAR 0 1
11965: PUSH
11966: LD_INT 2
11968: ARRAY
11969: PPUSH
11970: LD_INT 1
11972: PPUSH
11973: LD_INT 20
11975: NEG
11976: PPUSH
11977: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11981: LD_VAR 0 1
11985: PUSH
11986: LD_INT 1
11988: ARRAY
11989: PPUSH
11990: LD_VAR 0 1
11994: PUSH
11995: LD_INT 2
11997: ARRAY
11998: PPUSH
11999: LD_INT 1
12001: PPUSH
12002: CALL_OW 331
// end ;
12006: GO 11949
12008: POP
12009: POP
// dwait ( 0 0$0.5 ) ;
12010: LD_INT 18
12012: PPUSH
12013: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12017: LD_INT 42
12019: PPUSH
12020: LD_INT 27
12022: PPUSH
12023: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12027: LD_EXP 34
12031: PPUSH
12032: LD_STRING D4Ya-Yam-2
12034: PPUSH
12035: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12039: LD_INT 18
12041: PPUSH
12042: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12046: LD_INT 118
12048: PPUSH
12049: LD_INT 80
12051: PPUSH
12052: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12056: LD_EXP 21
12060: PPUSH
12061: LD_STRING D4Ya-JMM-2
12063: PPUSH
12064: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12068: LD_EXP 34
12072: PPUSH
12073: LD_STRING D4Ya-Yam-3
12075: PPUSH
12076: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12080: LD_INT 10
12082: PPUSH
12083: CALL_OW 68
// DialogueOff ;
12087: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12091: LD_EXP 34
12095: PPUSH
12096: LD_INT 1
12098: PPUSH
12099: CALL_OW 235
// end else
12103: GO 12357
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12105: LD_INT 2
12107: PPUSH
12108: LD_INT 4
12110: PPUSH
12111: LD_INT 2
12113: PPUSH
12114: LD_INT 1
12116: PPUSH
12117: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12121: LD_EXP 34
12125: PPUSH
12126: LD_INT 75
12128: PPUSH
12129: LD_INT 63
12131: PPUSH
12132: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12136: LD_EXP 34
12140: PPUSH
12141: LD_INT 175
12143: PPUSH
12144: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12148: LD_EXP 34
12152: PPUSH
12153: LD_INT 102
12155: PPUSH
12156: LD_INT 76
12158: PPUSH
12159: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 108
12170: PPUSH
12171: LD_INT 70
12173: PPUSH
12174: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12178: LD_INT 35
12180: PPUSH
12181: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_EXP 34
12192: PPUSH
12193: CALL_OW 292
12197: IFFALSE 12178
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12199: LD_EXP 34
12203: PPUSH
12204: LD_INT 112
12206: PPUSH
12207: LD_INT 118
12209: PPUSH
12210: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12214: LD_EXP 34
12218: PPUSH
12219: CALL_OW 256
12223: PUSH
12224: LD_INT 750
12226: GREATEREQUAL
12227: IFFALSE 12241
// SetLives ( Kikuchi , 700 ) ;
12229: LD_EXP 34
12233: PPUSH
12234: LD_INT 700
12236: PPUSH
12237: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12241: LD_INT 35
12243: PPUSH
12244: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12248: LD_INT 1
12250: PPUSH
12251: LD_EXP 34
12255: PPUSH
12256: CALL_OW 292
12260: PUSH
12261: LD_EXP 34
12265: PPUSH
12266: LD_INT 7
12268: PPUSH
12269: CALL_OW 296
12273: PUSH
12274: LD_INT 17
12276: LESS
12277: OR
12278: IFFALSE 12241
// DialogueOn ;
12280: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12284: LD_EXP 34
12288: PPUSH
12289: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12293: LD_EXP 34
12297: PPUSH
12298: LD_STRING D4Yb-Yam-1
12300: PPUSH
12301: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12305: LD_EXP 21
12309: PPUSH
12310: LD_STRING D4Yb-JMM-1
12312: PPUSH
12313: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12317: LD_EXP 34
12321: PPUSH
12322: LD_STRING D4Yb-Yam-2
12324: PPUSH
12325: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12329: LD_EXP 21
12333: PPUSH
12334: LD_STRING D4Yb-JMM-2
12336: PPUSH
12337: CALL_OW 88
// DialogueOff ;
12341: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12345: LD_EXP 34
12349: PPUSH
12350: LD_INT 1
12352: PPUSH
12353: CALL_OW 235
// end ; end ; end ;
12357: PPOPN 2
12359: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12360: LD_EXP 6
12364: IFFALSE 13397
12366: GO 12368
12368: DISABLE
12369: LD_INT 0
12371: PPUSH
12372: PPUSH
12373: PPUSH
12374: PPUSH
// begin enable ;
12375: ENABLE
// if not seen [ 1 ] then
12376: LD_EXP 9
12380: PUSH
12381: LD_INT 1
12383: ARRAY
12384: NOT
12385: IFFALSE 12565
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12387: LD_ADDR_VAR 0 2
12391: PUSH
12392: LD_INT 22
12394: PUSH
12395: LD_INT 2
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PUSH
12402: LD_INT 2
12404: PUSH
12405: LD_INT 25
12407: PUSH
12408: LD_INT 11
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 33
12417: PUSH
12418: LD_INT 4
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: PUSH
12425: EMPTY
12426: LIST
12427: LIST
12428: LIST
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PPUSH
12434: CALL_OW 69
12438: ST_TO_ADDR
// if tmp then
12439: LD_VAR 0 2
12443: IFFALSE 12565
// for i in tmp do
12445: LD_ADDR_VAR 0 1
12449: PUSH
12450: LD_VAR 0 2
12454: PUSH
12455: FOR_IN
12456: IFFALSE 12563
// if See ( 1 , i ) then
12458: LD_INT 1
12460: PPUSH
12461: LD_VAR 0 1
12465: PPUSH
12466: CALL_OW 292
12470: IFFALSE 12561
// begin seen := Replace ( seen , 1 , true ) ;
12472: LD_ADDR_EXP 9
12476: PUSH
12477: LD_EXP 9
12481: PPUSH
12482: LD_INT 1
12484: PPUSH
12485: LD_INT 1
12487: PPUSH
12488: CALL_OW 1
12492: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12493: LD_INT 1
12495: PPUSH
12496: CALL 16083 0 1
12500: IFFALSE 12561
// begin DialogueOn ;
12502: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12515: LD_INT 10
12517: PPUSH
12518: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12522: LD_ADDR_VAR 0 3
12526: PUSH
12527: LD_INT 1
12529: PPUSH
12530: LD_STRING D5a-Sol2-1
12532: PPUSH
12533: CALL 16261 0 2
12537: ST_TO_ADDR
// if not un then
12538: LD_VAR 0 3
12542: NOT
12543: IFFALSE 12555
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12545: LD_INT 2
12547: PPUSH
12548: LD_STRING D5a-FSol2-1
12550: PPUSH
12551: CALL 16261 0 2
// DialogueOff ;
12555: CALL_OW 7
// break ;
12559: GO 12563
// end ; end ;
12561: GO 12455
12563: POP
12564: POP
// end ; if not seen [ 2 ] then
12565: LD_EXP 9
12569: PUSH
12570: LD_INT 2
12572: ARRAY
12573: NOT
12574: IFFALSE 12799
// begin can_kamikazed := true ;
12576: LD_ADDR_EXP 10
12580: PUSH
12581: LD_INT 1
12583: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12584: LD_ADDR_VAR 0 2
12588: PUSH
12589: LD_INT 22
12591: PUSH
12592: LD_INT 2
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 25
12601: PUSH
12602: LD_INT 17
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PPUSH
12613: CALL_OW 69
12617: ST_TO_ADDR
// if tmp then
12618: LD_VAR 0 2
12622: IFFALSE 12799
// for i in tmp do
12624: LD_ADDR_VAR 0 1
12628: PUSH
12629: LD_VAR 0 2
12633: PUSH
12634: FOR_IN
12635: IFFALSE 12797
// if See ( 1 , i ) then
12637: LD_INT 1
12639: PPUSH
12640: LD_VAR 0 1
12644: PPUSH
12645: CALL_OW 292
12649: IFFALSE 12795
// begin seen := Replace ( seen , 2 , true ) ;
12651: LD_ADDR_EXP 9
12655: PUSH
12656: LD_EXP 9
12660: PPUSH
12661: LD_INT 2
12663: PPUSH
12664: LD_INT 1
12666: PPUSH
12667: CALL_OW 1
12671: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12672: LD_INT 1
12674: PPUSH
12675: CALL 16083 0 1
12679: IFFALSE 12795
// begin DialogueOn ;
12681: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12685: LD_VAR 0 1
12689: PPUSH
12690: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12694: LD_INT 10
12696: PPUSH
12697: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12701: LD_ADDR_VAR 0 3
12705: PUSH
12706: LD_INT 1
12708: PPUSH
12709: LD_STRING D5b-Sol1-1
12711: PPUSH
12712: CALL 16261 0 2
12716: ST_TO_ADDR
// if not un then
12717: LD_VAR 0 3
12721: NOT
12722: IFFALSE 12740
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_INT 2
12731: PPUSH
12732: LD_STRING D5b-FSol1-1
12734: PPUSH
12735: CALL 16261 0 2
12739: ST_TO_ADDR
// if un then
12740: LD_VAR 0 3
12744: IFFALSE 12789
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12746: LD_ADDR_VAR 0 4
12750: PUSH
12751: LD_INT 1
12753: PPUSH
12754: LD_STRING D5b-Sol2-1
12756: PPUSH
12757: LD_VAR 0 3
12761: PPUSH
12762: CALL 16487 0 3
12766: ST_TO_ADDR
// if not un2 then
12767: LD_VAR 0 4
12771: NOT
12772: IFFALSE 12789
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12774: LD_INT 2
12776: PPUSH
12777: LD_STRING D5b-FSol2-1
12779: PPUSH
12780: LD_VAR 0 3
12784: PPUSH
12785: CALL 16487 0 3
// end ; DialogueOff ;
12789: CALL_OW 7
// break ;
12793: GO 12797
// end ; end ;
12795: GO 12634
12797: POP
12798: POP
// end ; if not seen [ 3 ] then
12799: LD_EXP 9
12803: PUSH
12804: LD_INT 3
12806: ARRAY
12807: NOT
12808: IFFALSE 12982
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12810: LD_ADDR_VAR 0 2
12814: PUSH
12815: LD_INT 22
12817: PUSH
12818: LD_INT 2
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 33
12827: PUSH
12828: LD_INT 2
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PPUSH
12839: CALL_OW 69
12843: ST_TO_ADDR
// if tmp then
12844: LD_VAR 0 2
12848: IFFALSE 12982
// for i in tmp do
12850: LD_ADDR_VAR 0 1
12854: PUSH
12855: LD_VAR 0 2
12859: PUSH
12860: FOR_IN
12861: IFFALSE 12980
// if See ( 1 , i ) then
12863: LD_INT 1
12865: PPUSH
12866: LD_VAR 0 1
12870: PPUSH
12871: CALL_OW 292
12875: IFFALSE 12978
// begin seen := Replace ( seen , 3 , true ) ;
12877: LD_ADDR_EXP 9
12881: PUSH
12882: LD_EXP 9
12886: PPUSH
12887: LD_INT 3
12889: PPUSH
12890: LD_INT 1
12892: PPUSH
12893: CALL_OW 1
12897: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12898: LD_INT 1
12900: PPUSH
12901: CALL 16083 0 1
12905: IFFALSE 12978
// begin DialogueOn ;
12907: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12911: LD_VAR 0 1
12915: PPUSH
12916: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12920: LD_INT 10
12922: PPUSH
12923: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12927: LD_ADDR_VAR 0 3
12931: PUSH
12932: LD_INT 1
12934: PPUSH
12935: LD_STRING D8-Sol1-1
12937: PPUSH
12938: CALL 16261 0 2
12942: ST_TO_ADDR
// if not un then
12943: LD_VAR 0 3
12947: NOT
12948: IFFALSE 12960
// SayRand ( sex_female , D8-FSol1-1 ) ;
12950: LD_INT 2
12952: PPUSH
12953: LD_STRING D8-FSol1-1
12955: PPUSH
12956: CALL 16261 0 2
// Say ( JMM , D8-JMM-1 ) ;
12960: LD_EXP 21
12964: PPUSH
12965: LD_STRING D8-JMM-1
12967: PPUSH
12968: CALL_OW 88
// DialogueOff ;
12972: CALL_OW 7
// break ;
12976: GO 12980
// end ; end ;
12978: GO 12860
12980: POP
12981: POP
// end ; if not seen [ 4 ] then
12982: LD_EXP 9
12986: PUSH
12987: LD_INT 4
12989: ARRAY
12990: NOT
12991: IFFALSE 13153
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12993: LD_ADDR_VAR 0 2
12997: PUSH
12998: LD_INT 22
13000: PUSH
13001: LD_INT 2
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PUSH
13008: LD_INT 33
13010: PUSH
13011: LD_INT 5
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PPUSH
13022: CALL_OW 69
13026: ST_TO_ADDR
// if tmp then
13027: LD_VAR 0 2
13031: IFFALSE 13153
// for i in tmp do
13033: LD_ADDR_VAR 0 1
13037: PUSH
13038: LD_VAR 0 2
13042: PUSH
13043: FOR_IN
13044: IFFALSE 13151
// if See ( 1 , i ) then
13046: LD_INT 1
13048: PPUSH
13049: LD_VAR 0 1
13053: PPUSH
13054: CALL_OW 292
13058: IFFALSE 13149
// begin seen := Replace ( seen , 4 , true ) ;
13060: LD_ADDR_EXP 9
13064: PUSH
13065: LD_EXP 9
13069: PPUSH
13070: LD_INT 4
13072: PPUSH
13073: LD_INT 1
13075: PPUSH
13076: CALL_OW 1
13080: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13081: LD_INT 1
13083: PPUSH
13084: CALL 16083 0 1
13088: IFFALSE 13149
// begin DialogueOn ;
13090: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13094: LD_VAR 0 1
13098: PPUSH
13099: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13103: LD_INT 10
13105: PPUSH
13106: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13110: LD_ADDR_VAR 0 3
13114: PUSH
13115: LD_INT 1
13117: PPUSH
13118: LD_STRING D5a-Sol1-1
13120: PPUSH
13121: CALL 16261 0 2
13125: ST_TO_ADDR
// if not un then
13126: LD_VAR 0 3
13130: NOT
13131: IFFALSE 13143
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13133: LD_INT 2
13135: PPUSH
13136: LD_STRING D5a-FSol1-1
13138: PPUSH
13139: CALL 16261 0 2
// DialogueOff ;
13143: CALL_OW 7
// break ;
13147: GO 13151
// end ; end ;
13149: GO 13043
13151: POP
13152: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13153: LD_EXP 9
13157: PUSH
13158: LD_INT 5
13160: ARRAY
13161: NOT
13162: PUSH
13163: LD_EXP 9
13167: PUSH
13168: LD_INT 3
13170: ARRAY
13171: AND
13172: IFFALSE 13346
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13174: LD_ADDR_VAR 0 2
13178: PUSH
13179: LD_INT 22
13181: PUSH
13182: LD_INT 2
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: PUSH
13189: LD_INT 34
13191: PUSH
13192: LD_INT 31
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: PPUSH
13203: CALL_OW 69
13207: ST_TO_ADDR
// if tmp then
13208: LD_VAR 0 2
13212: IFFALSE 13346
// for i in tmp do
13214: LD_ADDR_VAR 0 1
13218: PUSH
13219: LD_VAR 0 2
13223: PUSH
13224: FOR_IN
13225: IFFALSE 13344
// if See ( 1 , i ) then
13227: LD_INT 1
13229: PPUSH
13230: LD_VAR 0 1
13234: PPUSH
13235: CALL_OW 292
13239: IFFALSE 13342
// begin seen := Replace ( seen , 5 , true ) ;
13241: LD_ADDR_EXP 9
13245: PUSH
13246: LD_EXP 9
13250: PPUSH
13251: LD_INT 5
13253: PPUSH
13254: LD_INT 1
13256: PPUSH
13257: CALL_OW 1
13261: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13262: LD_INT 1
13264: PPUSH
13265: CALL 16083 0 1
13269: IFFALSE 13342
// begin DialogueOn ;
13271: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13284: LD_INT 10
13286: PPUSH
13287: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13291: LD_ADDR_VAR 0 3
13295: PUSH
13296: LD_INT 1
13298: PPUSH
13299: LD_STRING D8a-Sol2-1
13301: PPUSH
13302: CALL 16261 0 2
13306: ST_TO_ADDR
// if not un then
13307: LD_VAR 0 3
13311: NOT
13312: IFFALSE 13324
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13314: LD_INT 2
13316: PPUSH
13317: LD_STRING D8a-FSol2-1
13319: PPUSH
13320: CALL 16261 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13324: LD_EXP 21
13328: PPUSH
13329: LD_STRING D8a-JMM-1
13331: PPUSH
13332: CALL_OW 88
// DialogueOff ;
13336: CALL_OW 7
// break ;
13340: GO 13344
// end ; end ;
13342: GO 13224
13344: POP
13345: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13346: LD_EXP 9
13350: PUSH
13351: LD_INT 1
13353: ARRAY
13354: PUSH
13355: LD_EXP 9
13359: PUSH
13360: LD_INT 2
13362: ARRAY
13363: AND
13364: PUSH
13365: LD_EXP 9
13369: PUSH
13370: LD_INT 3
13372: ARRAY
13373: AND
13374: PUSH
13375: LD_EXP 9
13379: PUSH
13380: LD_INT 4
13382: ARRAY
13383: AND
13384: PUSH
13385: LD_EXP 9
13389: PUSH
13390: LD_INT 5
13392: ARRAY
13393: AND
13394: IFFALSE 13397
// disable ;
13396: DISABLE
// end ;
13397: PPOPN 4
13399: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13400: LD_EXP 10
13404: PUSH
13405: LD_EXP 11
13409: AND
13410: IFFALSE 13608
13412: GO 13414
13414: DISABLE
13415: LD_INT 0
13417: PPUSH
// begin DialogueOn ;
13418: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13422: LD_EXP 11
13426: PPUSH
13427: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13431: LD_ADDR_VAR 0 1
13435: PUSH
13436: LD_INT 1
13438: PPUSH
13439: LD_STRING D5c-Sol1-1
13441: PPUSH
13442: CALL 16261 0 2
13446: ST_TO_ADDR
// if not un then
13447: LD_VAR 0 1
13451: NOT
13452: IFFALSE 13470
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13454: LD_ADDR_VAR 0 1
13458: PUSH
13459: LD_INT 2
13461: PPUSH
13462: LD_STRING D5c-FSol1-1
13464: PPUSH
13465: CALL 16261 0 2
13469: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13470: LD_EXP 21
13474: PPUSH
13475: LD_STRING D5c-JMM-1
13477: PPUSH
13478: CALL_OW 88
// if IsOk ( Lisa ) then
13482: LD_EXP 22
13486: PPUSH
13487: CALL_OW 302
13491: IFFALSE 13507
// Say ( Lisa , D5d-Lisa-1 ) else
13493: LD_EXP 22
13497: PPUSH
13498: LD_STRING D5d-Lisa-1
13500: PPUSH
13501: CALL_OW 88
13505: GO 13592
// if IsOk ( Cyrus ) then
13507: LD_EXP 25
13511: PPUSH
13512: CALL_OW 302
13516: IFFALSE 13532
// Say ( Cyrus , D5d-Cyrus-1 ) else
13518: LD_EXP 25
13522: PPUSH
13523: LD_STRING D5d-Cyrus-1
13525: PPUSH
13526: CALL_OW 88
13530: GO 13592
// if IsOk ( Gary ) then
13532: LD_EXP 32
13536: PPUSH
13537: CALL_OW 302
13541: IFFALSE 13557
// Say ( Gary , D5d-Gary-1 ) else
13543: LD_EXP 32
13547: PPUSH
13548: LD_STRING D5d-Gary-1
13550: PPUSH
13551: CALL_OW 88
13555: GO 13592
// if GetSex ( un ) = sex_male then
13557: LD_VAR 0 1
13561: PPUSH
13562: CALL_OW 258
13566: PUSH
13567: LD_INT 1
13569: EQUAL
13570: IFFALSE 13586
// Say ( un , D5d-Sol1-1 ) else
13572: LD_VAR 0 1
13576: PPUSH
13577: LD_STRING D5d-Sol1-1
13579: PPUSH
13580: CALL_OW 88
13584: GO 13592
// begin DialogueOff ;
13586: CALL_OW 7
// exit ;
13590: GO 13608
// end ; Say ( JMM , D5d-JMM-1 ) ;
13592: LD_EXP 21
13596: PPUSH
13597: LD_STRING D5d-JMM-1
13599: PPUSH
13600: CALL_OW 88
// DialogueOff ;
13604: CALL_OW 7
// end ;
13608: PPOPN 1
13610: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13611: LD_INT 1
13613: PPUSH
13614: LD_INT 17
13616: PPUSH
13617: CALL_OW 294
13621: PUSH
13622: LD_INT 2
13624: GREATEREQUAL
13625: IFFALSE 13746
13627: GO 13629
13629: DISABLE
13630: LD_INT 0
13632: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13633: LD_INT 10
13635: PPUSH
13636: LD_INT 5
13638: PPUSH
13639: LD_INT 1
13641: PPUSH
13642: LD_INT 10
13644: NEG
13645: PPUSH
13646: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13650: LD_INT 10
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: LD_INT 1
13658: PPUSH
13659: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13663: LD_INT 10
13665: PPUSH
13666: LD_INT 5
13668: PPUSH
13669: CALL_OW 86
// DialogueOn ;
13673: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13677: LD_ADDR_VAR 0 1
13681: PUSH
13682: LD_INT 1
13684: PPUSH
13685: LD_STRING D6-Sci1-1
13687: PPUSH
13688: CALL 16261 0 2
13692: ST_TO_ADDR
// if un then
13693: LD_VAR 0 1
13697: IFFALSE 13735
// begin Say ( JMM , D6-JMM-1 ) ;
13699: LD_EXP 21
13703: PPUSH
13704: LD_STRING D6-JMM-1
13706: PPUSH
13707: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13711: LD_VAR 0 1
13715: PPUSH
13716: LD_STRING D6-Sci1-2
13718: PPUSH
13719: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13723: LD_EXP 21
13727: PPUSH
13728: LD_STRING D6-JMM-2
13730: PPUSH
13731: CALL_OW 88
// end ; DialogueOff ;
13735: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13739: LD_STRING M3
13741: PPUSH
13742: CALL_OW 337
// end ;
13746: PPOPN 1
13748: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13749: LD_OWVAR 1
13753: PUSH
13754: LD_INT 42000
13756: GREATEREQUAL
13757: PUSH
13758: LD_INT 2
13760: PPUSH
13761: LD_INT 169
13763: PPUSH
13764: LD_INT 90
13766: PPUSH
13767: LD_INT 10
13769: PPUSH
13770: CALL 53356 0 4
13774: PUSH
13775: LD_INT 4
13777: ARRAY
13778: PUSH
13779: LD_INT 0
13781: EQUAL
13782: PUSH
13783: LD_INT 45
13785: PPUSH
13786: CALL_OW 301
13790: OR
13791: PUSH
13792: LD_INT 45
13794: PPUSH
13795: CALL_OW 255
13799: PUSH
13800: LD_INT 1
13802: EQUAL
13803: OR
13804: AND
13805: PUSH
13806: LD_INT 94
13808: PPUSH
13809: CALL_OW 301
13813: NOT
13814: AND
13815: IFFALSE 15020
13817: GO 13819
13819: DISABLE
13820: LD_INT 0
13822: PPUSH
13823: PPUSH
13824: PPUSH
13825: PPUSH
13826: PPUSH
// begin uc_side := 5 ;
13827: LD_ADDR_OWVAR 20
13831: PUSH
13832: LD_INT 5
13834: ST_TO_ADDR
// uc_nation := 2 ;
13835: LD_ADDR_OWVAR 21
13839: PUSH
13840: LD_INT 2
13842: ST_TO_ADDR
// InitHc ;
13843: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13847: LD_INT 1
13849: PPUSH
13850: LD_INT 3
13852: PPUSH
13853: LD_INT 8
13855: PPUSH
13856: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13860: LD_ADDR_OWVAR 29
13864: PUSH
13865: LD_INT 12
13867: PUSH
13868: LD_INT 12
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: ST_TO_ADDR
// hc_name := Hans Felige ;
13875: LD_ADDR_OWVAR 26
13879: PUSH
13880: LD_STRING Hans Felige
13882: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13883: LD_ADDR_OWVAR 33
13887: PUSH
13888: LD_STRING SecondCharsGal
13890: ST_TO_ADDR
// hc_face_number := 7 ;
13891: LD_ADDR_OWVAR 34
13895: PUSH
13896: LD_INT 7
13898: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13899: LD_ADDR_EXP 46
13903: PUSH
13904: CALL_OW 44
13908: ST_TO_ADDR
// InitHc ;
13909: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13913: LD_INT 1
13915: PPUSH
13916: LD_INT 16
13918: PPUSH
13919: LD_INT 2
13921: PPUSH
13922: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13926: LD_ADDR_OWVAR 29
13930: PUSH
13931: LD_INT 12
13933: PUSH
13934: LD_INT 12
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: ST_TO_ADDR
// hc_name :=  ;
13941: LD_ADDR_OWVAR 26
13945: PUSH
13946: LD_STRING 
13948: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13949: LD_ADDR_EXP 47
13953: PUSH
13954: CALL_OW 44
13958: ST_TO_ADDR
// InitHc ;
13959: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13963: LD_INT 35
13965: PPUSH
13966: CALL_OW 67
// until not InBattle ( 1 ) ;
13970: LD_INT 1
13972: PPUSH
13973: CALL_OW 463
13977: NOT
13978: IFFALSE 13963
// wait ( 0 0$5 ) ;
13980: LD_INT 175
13982: PPUSH
13983: CALL_OW 67
// DialogueOn ;
13987: CALL_OW 6
// InGameOn ;
13991: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13995: LD_ADDR_VAR 0 1
13999: PUSH
14000: LD_INT 22
14002: PUSH
14003: LD_INT 1
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 2
14012: PUSH
14013: LD_INT 25
14015: PUSH
14016: LD_INT 1
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: PUSH
14023: LD_INT 25
14025: PUSH
14026: LD_INT 2
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 25
14035: PUSH
14036: LD_INT 3
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: LD_INT 25
14045: PUSH
14046: LD_INT 4
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PUSH
14053: LD_INT 25
14055: PUSH
14056: LD_INT 5
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 8
14068: PUSH
14069: EMPTY
14070: LIST
14071: LIST
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: PPUSH
14086: CALL_OW 69
14090: PUSH
14091: LD_EXP 21
14095: PUSH
14096: LD_EXP 22
14100: PUSH
14101: LD_EXP 23
14105: PUSH
14106: LD_EXP 24
14110: PUSH
14111: LD_EXP 25
14115: PUSH
14116: LD_EXP 26
14120: PUSH
14121: LD_EXP 27
14125: PUSH
14126: LD_EXP 28
14130: PUSH
14131: LD_EXP 29
14135: PUSH
14136: LD_EXP 31
14140: PUSH
14141: LD_EXP 32
14145: PUSH
14146: LD_EXP 33
14150: PUSH
14151: LD_EXP 34
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: DIFF
14171: PPUSH
14172: LD_INT 26
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: PPUSH
14182: CALL_OW 72
14186: PUSH
14187: LD_INT 1
14189: ARRAY
14190: ST_TO_ADDR
// if Brown then
14191: LD_EXP 27
14195: IFFALSE 14207
// un := Brown ;
14197: LD_ADDR_VAR 0 1
14201: PUSH
14202: LD_EXP 27
14206: ST_TO_ADDR
// if un then
14207: LD_VAR 0 1
14211: IFFALSE 14237
// begin Say ( un , D7-Sol1-1 ) ;
14213: LD_VAR 0 1
14217: PPUSH
14218: LD_STRING D7-Sol1-1
14220: PPUSH
14221: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14225: LD_EXP 21
14229: PPUSH
14230: LD_STRING D7-JMM-1
14232: PPUSH
14233: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14237: LD_EXP 46
14241: PPUSH
14242: LD_STRING D7-Ar1-1
14244: PPUSH
14245: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14249: LD_EXP 21
14253: PPUSH
14254: LD_STRING D7-JMM-2
14256: PPUSH
14257: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14261: LD_EXP 46
14265: PPUSH
14266: LD_STRING D7-Ar1-2
14268: PPUSH
14269: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14273: LD_EXP 21
14277: PPUSH
14278: LD_STRING D7-JMM-3
14280: PPUSH
14281: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14285: LD_EXP 46
14289: PPUSH
14290: LD_STRING D7-Ar1-3
14292: PPUSH
14293: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14297: LD_EXP 21
14301: PPUSH
14302: LD_STRING D7-JMM-4
14304: PPUSH
14305: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14309: LD_EXP 46
14313: PPUSH
14314: LD_STRING D7-Ar1-4
14316: PPUSH
14317: CALL_OW 94
// InGameOff ;
14321: CALL_OW 9
// DialogueOff ;
14325: CALL_OW 7
// case Query ( QCameras ) of 1 :
14329: LD_STRING QCameras
14331: PPUSH
14332: CALL_OW 97
14336: PUSH
14337: LD_INT 1
14339: DOUBLE
14340: EQUAL
14341: IFTRUE 14345
14343: GO 14348
14345: POP
// ; 2 :
14346: GO 14362
14348: LD_INT 2
14350: DOUBLE
14351: EQUAL
14352: IFTRUE 14356
14354: GO 14361
14356: POP
// exit ; end ;
14357: GO 15020
14359: GO 14362
14361: POP
// ChangeMissionObjectives ( MCar ) ;
14362: LD_STRING MCar
14364: PPUSH
14365: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14369: LD_INT 124
14371: PPUSH
14372: LD_INT 90
14374: PPUSH
14375: LD_INT 1
14377: PPUSH
14378: LD_INT 6
14380: NEG
14381: PPUSH
14382: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14386: LD_INT 124
14388: PPUSH
14389: LD_INT 90
14391: PPUSH
14392: LD_INT 1
14394: PPUSH
14395: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14399: LD_INT 12
14401: PPUSH
14402: LD_INT 1
14404: PPUSH
14405: CALL_OW 424
// wait ( 3 ) ;
14409: LD_INT 3
14411: PPUSH
14412: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14416: LD_INT 124
14418: PPUSH
14419: LD_INT 90
14421: PPUSH
14422: CALL_OW 86
// cargo := false ;
14426: LD_ADDR_VAR 0 3
14430: PUSH
14431: LD_INT 0
14433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14434: LD_INT 35
14436: PPUSH
14437: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14441: LD_ADDR_VAR 0 3
14445: PUSH
14446: LD_INT 12
14448: PPUSH
14449: LD_INT 32
14451: PUSH
14452: LD_INT 3
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 34
14461: PUSH
14462: LD_INT 32
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: LD_INT 58
14471: PUSH
14472: EMPTY
14473: LIST
14474: PUSH
14475: EMPTY
14476: LIST
14477: LIST
14478: LIST
14479: PPUSH
14480: CALL_OW 70
14484: ST_TO_ADDR
// until cargo ;
14485: LD_VAR 0 3
14489: IFFALSE 14434
// cargo := cargo [ 1 ] ;
14491: LD_ADDR_VAR 0 3
14495: PUSH
14496: LD_VAR 0 3
14500: PUSH
14501: LD_INT 1
14503: ARRAY
14504: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14505: LD_VAR 0 3
14509: PPUSH
14510: LD_INT 5
14512: PPUSH
14513: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14517: LD_INT 12
14519: PPUSH
14520: LD_INT 0
14522: PPUSH
14523: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14527: LD_EXP 46
14531: PPUSH
14532: LD_INT 11
14534: PPUSH
14535: LD_INT 0
14537: PPUSH
14538: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14542: LD_EXP 47
14546: PPUSH
14547: LD_INT 11
14549: PPUSH
14550: LD_INT 0
14552: PPUSH
14553: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14557: LD_EXP 46
14561: PUSH
14562: LD_EXP 47
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PPUSH
14571: LD_INT 12
14573: PPUSH
14574: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14578: LD_EXP 46
14582: PPUSH
14583: LD_VAR 0 3
14587: PPUSH
14588: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14592: LD_EXP 46
14596: PUSH
14597: LD_EXP 47
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PPUSH
14606: LD_INT 209
14608: PPUSH
14609: LD_INT 178
14611: PPUSH
14612: CALL_OW 171
// escaped := 0 ;
14616: LD_ADDR_VAR 0 5
14620: PUSH
14621: LD_INT 0
14623: ST_TO_ADDR
// while ( true ) do
14624: LD_INT 1
14626: IFFALSE 14842
// begin wait ( 0 0$1 ) ;
14628: LD_INT 35
14630: PPUSH
14631: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14635: LD_EXP 46
14639: PPUSH
14640: CALL_OW 314
14644: NOT
14645: PUSH
14646: LD_EXP 47
14650: PPUSH
14651: CALL_OW 314
14655: NOT
14656: OR
14657: IFFALSE 14683
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14659: LD_EXP 46
14663: PUSH
14664: LD_EXP 47
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PPUSH
14673: LD_INT 209
14675: PPUSH
14676: LD_INT 178
14678: PPUSH
14679: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14683: LD_EXP 46
14687: PPUSH
14688: LD_INT 10
14690: PPUSH
14691: CALL_OW 308
14695: IFFALSE 14720
// begin RemoveUnit ( ar_mechanic ) ;
14697: LD_EXP 46
14701: PPUSH
14702: CALL_OW 64
// escaped := escaped + 1 ;
14706: LD_ADDR_VAR 0 5
14710: PUSH
14711: LD_VAR 0 5
14715: PUSH
14716: LD_INT 1
14718: PLUS
14719: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14720: LD_EXP 47
14724: PPUSH
14725: LD_INT 10
14727: PPUSH
14728: CALL_OW 308
14732: IFFALSE 14757
// begin RemoveUnit ( ar_mechanic_friend ) ;
14734: LD_EXP 47
14738: PPUSH
14739: CALL_OW 64
// escaped := escaped + 1 ;
14743: LD_ADDR_VAR 0 5
14747: PUSH
14748: LD_VAR 0 5
14752: PUSH
14753: LD_INT 1
14755: PLUS
14756: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14757: LD_VAR 0 3
14761: PPUSH
14762: LD_INT 10
14764: PPUSH
14765: CALL_OW 308
14769: IFFALSE 14780
// RemoveUnit ( cargo ) ;
14771: LD_VAR 0 3
14775: PPUSH
14776: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14780: LD_EXP 46
14784: PPUSH
14785: CALL_OW 305
14789: NOT
14790: PUSH
14791: LD_VAR 0 5
14795: PUSH
14796: LD_INT 2
14798: GREATEREQUAL
14799: AND
14800: IFFALSE 14804
// break ;
14802: GO 14842
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14804: LD_EXP 46
14808: PPUSH
14809: CALL_OW 305
14813: NOT
14814: PUSH
14815: LD_EXP 47
14819: PPUSH
14820: CALL_OW 305
14824: NOT
14825: AND
14826: PUSH
14827: LD_VAR 0 5
14831: PUSH
14832: LD_INT 2
14834: LESS
14835: AND
14836: IFFALSE 14840
// exit ;
14838: GO 15020
// end ;
14840: GO 14624
// wait ( 0 0$2 ) ;
14842: LD_INT 70
14844: PPUSH
14845: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14849: LD_EXP 46
14853: PPUSH
14854: LD_STRING D7a-Ar1-1
14856: PPUSH
14857: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14861: LD_ADDR_VAR 0 4
14865: PUSH
14866: LD_INT 129
14868: PUSH
14869: LD_INT 10
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: LD_INT 103
14878: PUSH
14879: LD_INT 6
14881: PUSH
14882: EMPTY
14883: LIST
14884: LIST
14885: PUSH
14886: LD_INT 148
14888: PUSH
14889: LD_INT 47
14891: PUSH
14892: EMPTY
14893: LIST
14894: LIST
14895: PUSH
14896: LD_INT 155
14898: PUSH
14899: LD_INT 16
14901: PUSH
14902: EMPTY
14903: LIST
14904: LIST
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: ST_TO_ADDR
// if Difficulty = 1 then
14912: LD_OWVAR 67
14916: PUSH
14917: LD_INT 1
14919: EQUAL
14920: IFFALSE 14957
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14922: LD_ADDR_VAR 0 4
14926: PUSH
14927: LD_VAR 0 4
14931: PUSH
14932: LD_INT 78
14934: PUSH
14935: LD_INT 7
14937: PUSH
14938: EMPTY
14939: LIST
14940: LIST
14941: PUSH
14942: LD_INT 104
14944: PUSH
14945: LD_INT 43
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: ADD
14956: ST_TO_ADDR
// for i in tmp do
14957: LD_ADDR_VAR 0 2
14961: PUSH
14962: LD_VAR 0 4
14966: PUSH
14967: FOR_IN
14968: IFFALSE 15001
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14970: LD_VAR 0 2
14974: PUSH
14975: LD_INT 1
14977: ARRAY
14978: PPUSH
14979: LD_VAR 0 2
14983: PUSH
14984: LD_INT 2
14986: ARRAY
14987: PPUSH
14988: LD_INT 1
14990: PPUSH
14991: LD_INT 9
14993: NEG
14994: PPUSH
14995: CALL_OW 330
14999: GO 14967
15001: POP
15002: POP
// SetAchievement ( ACH_FRIEND ) ;
15003: LD_STRING ACH_FRIEND
15005: PPUSH
15006: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15010: LD_INT 129
15012: PPUSH
15013: LD_INT 10
15015: PPUSH
15016: CALL_OW 84
// end ;
15020: PPOPN 5
15022: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15023: LD_EXP 15
15027: PUSH
15028: LD_INT 21000
15030: MINUS
15031: PUSH
15032: LD_OWVAR 1
15036: LESSEQUAL
15037: IFFALSE 15077
15039: GO 15041
15041: DISABLE
// begin powell_warn := true ;
15042: LD_ADDR_EXP 16
15046: PUSH
15047: LD_INT 1
15049: ST_TO_ADDR
// DialogueOn ;
15050: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15054: LD_EXP 30
15058: PPUSH
15059: LD_STRING D9-Pow-1
15061: PPUSH
15062: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15066: LD_INT 10
15068: PPUSH
15069: CALL_OW 68
// DialogueOff ;
15073: CALL_OW 7
// end ;
15077: END
// every 0 0$1 trigger game_time <= tick do
15078: LD_EXP 15
15082: PUSH
15083: LD_OWVAR 1
15087: LESSEQUAL
15088: IFFALSE 15127
15090: GO 15092
15092: DISABLE
// begin DialogueOn ;
15093: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15097: LD_EXP 30
15101: PPUSH
15102: LD_STRING D9a-Pow-1
15104: PPUSH
15105: CALL_OW 94
// dwait ( 0 0$2 ) ;
15109: LD_INT 70
15111: PPUSH
15112: CALL_OW 68
// DialogueOff ;
15116: CALL_OW 7
// YouLost ( Command ) ;
15120: LD_STRING Command
15122: PPUSH
15123: CALL_OW 104
// end ;
15127: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15128: LD_INT 22
15130: PUSH
15131: LD_INT 2
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: PUSH
15138: LD_INT 30
15140: PUSH
15141: LD_INT 1
15143: PUSH
15144: EMPTY
15145: LIST
15146: LIST
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PPUSH
15152: CALL_OW 69
15156: PUSH
15157: LD_INT 0
15159: EQUAL
15160: PUSH
15161: LD_EXP 21
15165: PPUSH
15166: CALL_OW 302
15170: AND
15171: IFFALSE 16080
15173: GO 15175
15175: DISABLE
15176: LD_INT 0
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
// begin m1 := false ;
15182: LD_ADDR_VAR 0 2
15186: PUSH
15187: LD_INT 0
15189: ST_TO_ADDR
// m2 := false ;
15190: LD_ADDR_VAR 0 3
15194: PUSH
15195: LD_INT 0
15197: ST_TO_ADDR
// m3 := false ;
15198: LD_ADDR_VAR 0 4
15202: PUSH
15203: LD_INT 0
15205: ST_TO_ADDR
// if not am_veh_consturcted then
15206: LD_EXP 20
15210: NOT
15211: IFFALSE 15220
// SetAchievement ( ACH_ARABTECH ) ;
15213: LD_STRING ACH_ARABTECH
15215: PPUSH
15216: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15220: LD_OWVAR 1
15224: PUSH
15225: LD_INT 252000
15227: PUSH
15228: LD_INT 210000
15230: PUSH
15231: LD_INT 199500
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: LIST
15238: PUSH
15239: LD_OWVAR 67
15243: ARRAY
15244: LESS
15245: IFFALSE 15267
// begin m3 := true ;
15247: LD_ADDR_VAR 0 4
15251: PUSH
15252: LD_INT 1
15254: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15255: LD_STRING Time1
15257: PPUSH
15258: LD_INT 1
15260: PPUSH
15261: CALL_OW 101
// end else
15265: GO 15298
// if not powell_warn then
15267: LD_EXP 16
15271: NOT
15272: IFFALSE 15287
// AddMedal ( Time1 , - 1 ) else
15274: LD_STRING Time1
15276: PPUSH
15277: LD_INT 1
15279: NEG
15280: PPUSH
15281: CALL_OW 101
15285: GO 15298
// AddMedal ( Time1 , - 2 ) ;
15287: LD_STRING Time1
15289: PPUSH
15290: LD_INT 2
15292: NEG
15293: PPUSH
15294: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15298: LD_EXP 17
15302: PUSH
15303: LD_INT 5
15305: PUSH
15306: LD_INT 4
15308: PUSH
15309: LD_INT 3
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: LIST
15316: PUSH
15317: LD_OWVAR 67
15321: ARRAY
15322: GREATEREQUAL
15323: IFFALSE 15338
// AddMedal ( Destroy , - 2 ) else
15325: LD_STRING Destroy
15327: PPUSH
15328: LD_INT 2
15330: NEG
15331: PPUSH
15332: CALL_OW 101
15336: GO 15471
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15338: LD_INT 22
15340: PUSH
15341: LD_INT 2
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: LD_INT 21
15350: PUSH
15351: LD_INT 3
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: PUSH
15358: LD_INT 50
15360: PUSH
15361: EMPTY
15362: LIST
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: LIST
15368: PPUSH
15369: CALL_OW 69
15373: PUSH
15374: LD_INT 25
15376: GREATEREQUAL
15377: IFFALSE 15392
// AddMedal ( Destroy , - 1 ) else
15379: LD_STRING Destroy
15381: PPUSH
15382: LD_INT 1
15384: NEG
15385: PPUSH
15386: CALL_OW 101
15390: GO 15471
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15392: LD_INT 22
15394: PUSH
15395: LD_INT 2
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: PUSH
15402: LD_INT 21
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: PUSH
15412: LD_INT 50
15414: PUSH
15415: EMPTY
15416: LIST
15417: PUSH
15418: EMPTY
15419: LIST
15420: LIST
15421: LIST
15422: PPUSH
15423: CALL_OW 69
15427: PUSH
15428: LD_INT 15
15430: GREATEREQUAL
15431: IFFALSE 15453
// begin m1 := true ;
15433: LD_ADDR_VAR 0 2
15437: PUSH
15438: LD_INT 1
15440: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15441: LD_STRING Destroy
15443: PPUSH
15444: LD_INT 1
15446: PPUSH
15447: CALL_OW 101
// end else
15451: GO 15471
// begin m1 := true ;
15453: LD_ADDR_VAR 0 2
15457: PUSH
15458: LD_INT 1
15460: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15461: LD_STRING Destroy
15463: PPUSH
15464: LD_INT 2
15466: PPUSH
15467: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15471: LD_EXP 13
15475: PPUSH
15476: LD_STRING 11_artifact_captured
15478: PPUSH
15479: CALL_OW 39
// if artifact_get then
15483: LD_EXP 13
15487: IFFALSE 15509
// begin m2 := true ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_INT 1
15496: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15497: LD_STRING Artefact
15499: PPUSH
15500: LD_INT 1
15502: PPUSH
15503: CALL_OW 101
// end else
15507: GO 15520
// AddMedal ( Artefact , - 1 ) ;
15509: LD_STRING Artefact
15511: PPUSH
15512: LD_INT 1
15514: NEG
15515: PPUSH
15516: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15520: LD_VAR 0 2
15524: PUSH
15525: LD_VAR 0 3
15529: AND
15530: PUSH
15531: LD_VAR 0 4
15535: AND
15536: PUSH
15537: LD_OWVAR 67
15541: PUSH
15542: LD_INT 3
15544: EQUAL
15545: AND
15546: IFFALSE 15558
// SetAchievementEX ( ACH_AMER , 11 ) ;
15548: LD_STRING ACH_AMER
15550: PPUSH
15551: LD_INT 11
15553: PPUSH
15554: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15558: LD_VAR 0 2
15562: PUSH
15563: LD_VAR 0 3
15567: AND
15568: PUSH
15569: LD_VAR 0 4
15573: AND
15574: PUSH
15575: LD_EXP 17
15579: PUSH
15580: LD_INT 0
15582: EQUAL
15583: AND
15584: IFFALSE 15600
// begin wait ( 3 ) ;
15586: LD_INT 3
15588: PPUSH
15589: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15593: LD_STRING ACH_GENERAL
15595: PPUSH
15596: CALL_OW 543
// end ; if tick <= 100 100$00 then
15600: LD_OWVAR 1
15604: PUSH
15605: LD_INT 210000
15607: LESSEQUAL
15608: IFFALSE 15624
// begin wait ( 3 ) ;
15610: LD_INT 3
15612: PPUSH
15613: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15617: LD_STRING ACH_ASPEED_11
15619: PPUSH
15620: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15624: LD_STRING MAIN
15626: PPUSH
15627: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15631: LD_ADDR_EXP 19
15635: PUSH
15636: LD_EXP 19
15640: PPUSH
15641: LD_INT 51
15643: PUSH
15644: EMPTY
15645: LIST
15646: PPUSH
15647: CALL_OW 72
15651: ST_TO_ADDR
// tmp := JMM ^ selected ;
15652: LD_ADDR_VAR 0 1
15656: PUSH
15657: LD_EXP 21
15661: PUSH
15662: LD_EXP 19
15666: ADD
15667: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15668: LD_VAR 0 1
15672: PPUSH
15673: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15677: LD_VAR 0 1
15681: PUSH
15682: LD_EXP 21
15686: PUSH
15687: LD_EXP 22
15691: PUSH
15692: LD_EXP 23
15696: PUSH
15697: LD_EXP 24
15701: PUSH
15702: LD_EXP 25
15706: PUSH
15707: LD_EXP 26
15711: PUSH
15712: LD_EXP 27
15716: PUSH
15717: LD_EXP 28
15721: PUSH
15722: LD_EXP 29
15726: PUSH
15727: LD_EXP 31
15731: PUSH
15732: LD_EXP 32
15736: PUSH
15737: LD_EXP 33
15741: PUSH
15742: LD_EXP 34
15746: PUSH
15747: EMPTY
15748: LIST
15749: LIST
15750: LIST
15751: LIST
15752: LIST
15753: LIST
15754: LIST
15755: LIST
15756: LIST
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: DIFF
15762: PPUSH
15763: LD_STRING 11c_others
15765: PPUSH
15766: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15770: LD_EXP 21
15774: PPUSH
15775: LD_EXP 3
15779: PUSH
15780: LD_STRING JMM
15782: STR
15783: PPUSH
15784: CALL_OW 38
// if Lisa then
15788: LD_EXP 22
15792: IFFALSE 15812
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15794: LD_EXP 22
15798: PPUSH
15799: LD_EXP 3
15803: PUSH
15804: LD_STRING Lisa
15806: STR
15807: PPUSH
15808: CALL_OW 38
// if Donaldson then
15812: LD_EXP 23
15816: IFFALSE 15836
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15818: LD_EXP 23
15822: PPUSH
15823: LD_EXP 3
15827: PUSH
15828: LD_STRING Donaldson
15830: STR
15831: PPUSH
15832: CALL_OW 38
// if Bobby then
15836: LD_EXP 24
15840: IFFALSE 15860
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15842: LD_EXP 24
15846: PPUSH
15847: LD_EXP 3
15851: PUSH
15852: LD_STRING Bobby
15854: STR
15855: PPUSH
15856: CALL_OW 38
// if Cyrus then
15860: LD_EXP 25
15864: IFFALSE 15884
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15866: LD_EXP 25
15870: PPUSH
15871: LD_EXP 3
15875: PUSH
15876: LD_STRING Cyrus
15878: STR
15879: PPUSH
15880: CALL_OW 38
// if Denis then
15884: LD_EXP 26
15888: IFFALSE 15908
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15890: LD_EXP 26
15894: PPUSH
15895: LD_EXP 3
15899: PUSH
15900: LD_STRING Denis
15902: STR
15903: PPUSH
15904: CALL_OW 38
// if Brown then
15908: LD_EXP 27
15912: IFFALSE 15932
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15914: LD_EXP 27
15918: PPUSH
15919: LD_EXP 3
15923: PUSH
15924: LD_STRING Brown
15926: STR
15927: PPUSH
15928: CALL_OW 38
// if Gladstone then
15932: LD_EXP 28
15936: IFFALSE 15956
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15938: LD_EXP 28
15942: PPUSH
15943: LD_EXP 3
15947: PUSH
15948: LD_STRING Gladstone
15950: STR
15951: PPUSH
15952: CALL_OW 38
// if Houten then
15956: LD_EXP 29
15960: IFFALSE 15980
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15962: LD_EXP 29
15966: PPUSH
15967: LD_EXP 3
15971: PUSH
15972: LD_STRING Houten
15974: STR
15975: PPUSH
15976: CALL_OW 38
// if Cornel then
15980: LD_EXP 31
15984: IFFALSE 16004
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15986: LD_EXP 31
15990: PPUSH
15991: LD_EXP 3
15995: PUSH
15996: LD_STRING Cornell
15998: STR
15999: PPUSH
16000: CALL_OW 38
// if Gary then
16004: LD_EXP 32
16008: IFFALSE 16028
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16010: LD_EXP 32
16014: PPUSH
16015: LD_EXP 3
16019: PUSH
16020: LD_STRING Gary
16022: STR
16023: PPUSH
16024: CALL_OW 38
// if Frank then
16028: LD_EXP 33
16032: IFFALSE 16052
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16034: LD_EXP 33
16038: PPUSH
16039: LD_EXP 3
16043: PUSH
16044: LD_STRING Frank
16046: STR
16047: PPUSH
16048: CALL_OW 38
// if Kikuchi then
16052: LD_EXP 34
16056: IFFALSE 16076
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16058: LD_EXP 34
16062: PPUSH
16063: LD_EXP 3
16067: PUSH
16068: LD_STRING Kikuchi
16070: STR
16071: PPUSH
16072: CALL_OW 38
// YouWin ;
16076: CALL_OW 103
// end ;
16080: PPOPN 4
16082: END
// export function CanSayRand ( side ) ; begin
16083: LD_INT 0
16085: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16086: LD_ADDR_VAR 0 2
16090: PUSH
16091: LD_INT 52
16093: PUSH
16094: EMPTY
16095: LIST
16096: PUSH
16097: LD_INT 22
16099: PUSH
16100: LD_VAR 0 1
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: LD_INT 2
16111: PUSH
16112: LD_INT 25
16114: PUSH
16115: LD_INT 1
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 25
16124: PUSH
16125: LD_INT 2
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: PUSH
16132: LD_INT 25
16134: PUSH
16135: LD_INT 3
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PUSH
16142: LD_INT 25
16144: PUSH
16145: LD_INT 4
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: LIST
16163: PPUSH
16164: CALL_OW 69
16168: PUSH
16169: LD_EXP 21
16173: PUSH
16174: LD_EXP 33
16178: PUSH
16179: LD_EXP 22
16183: PUSH
16184: LD_EXP 23
16188: PUSH
16189: LD_EXP 24
16193: PUSH
16194: LD_EXP 25
16198: PUSH
16199: LD_EXP 26
16203: PUSH
16204: LD_EXP 27
16208: PUSH
16209: LD_EXP 28
16213: PUSH
16214: LD_EXP 29
16218: PUSH
16219: LD_EXP 30
16223: PUSH
16224: LD_EXP 31
16228: PUSH
16229: LD_EXP 32
16233: PUSH
16234: LD_EXP 34
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: LIST
16253: LIST
16254: DIFF
16255: ST_TO_ADDR
// end ;
16256: LD_VAR 0 2
16260: RET
// export function SayRand ( sex , dial ) ; begin
16261: LD_INT 0
16263: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16264: LD_ADDR_VAR 0 3
16268: PUSH
16269: LD_INT 52
16271: PUSH
16272: EMPTY
16273: LIST
16274: PUSH
16275: LD_INT 22
16277: PUSH
16278: LD_INT 1
16280: PUSH
16281: EMPTY
16282: LIST
16283: LIST
16284: PUSH
16285: LD_INT 26
16287: PUSH
16288: LD_VAR 0 1
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: PUSH
16297: LD_INT 2
16299: PUSH
16300: LD_INT 25
16302: PUSH
16303: LD_INT 1
16305: PUSH
16306: EMPTY
16307: LIST
16308: LIST
16309: PUSH
16310: LD_INT 25
16312: PUSH
16313: LD_INT 2
16315: PUSH
16316: EMPTY
16317: LIST
16318: LIST
16319: PUSH
16320: LD_INT 25
16322: PUSH
16323: LD_INT 3
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PUSH
16330: LD_INT 25
16332: PUSH
16333: LD_INT 4
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: LIST
16344: LIST
16345: LIST
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: LIST
16351: LIST
16352: PPUSH
16353: CALL_OW 69
16357: PUSH
16358: LD_EXP 21
16362: PUSH
16363: LD_EXP 33
16367: PUSH
16368: LD_EXP 22
16372: PUSH
16373: LD_EXP 23
16377: PUSH
16378: LD_EXP 24
16382: PUSH
16383: LD_EXP 25
16387: PUSH
16388: LD_EXP 26
16392: PUSH
16393: LD_EXP 27
16397: PUSH
16398: LD_EXP 28
16402: PUSH
16403: LD_EXP 29
16407: PUSH
16408: LD_EXP 30
16412: PUSH
16413: LD_EXP 31
16417: PUSH
16418: LD_EXP 32
16422: PUSH
16423: LD_EXP 34
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: LIST
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: DIFF
16444: ST_TO_ADDR
// if not result then
16445: LD_VAR 0 3
16449: NOT
16450: IFFALSE 16454
// exit ;
16452: GO 16482
// result := result [ 1 ] ;
16454: LD_ADDR_VAR 0 3
16458: PUSH
16459: LD_VAR 0 3
16463: PUSH
16464: LD_INT 1
16466: ARRAY
16467: ST_TO_ADDR
// Say ( result , dial ) ;
16468: LD_VAR 0 3
16472: PPUSH
16473: LD_VAR 0 2
16477: PPUSH
16478: CALL_OW 88
// end ;
16482: LD_VAR 0 3
16486: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16487: LD_INT 0
16489: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16490: LD_ADDR_VAR 0 4
16494: PUSH
16495: LD_INT 22
16497: PUSH
16498: LD_INT 1
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: PUSH
16505: LD_INT 26
16507: PUSH
16508: LD_VAR 0 1
16512: PUSH
16513: EMPTY
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 2
16519: PUSH
16520: LD_INT 25
16522: PUSH
16523: LD_INT 1
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 25
16532: PUSH
16533: LD_INT 2
16535: PUSH
16536: EMPTY
16537: LIST
16538: LIST
16539: PUSH
16540: LD_INT 25
16542: PUSH
16543: LD_INT 3
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 25
16552: PUSH
16553: LD_INT 4
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: LIST
16565: LIST
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: LIST
16571: PPUSH
16572: CALL_OW 69
16576: PUSH
16577: LD_EXP 21
16581: PUSH
16582: LD_EXP 33
16586: PUSH
16587: LD_EXP 22
16591: PUSH
16592: LD_EXP 23
16596: PUSH
16597: LD_EXP 24
16601: PUSH
16602: LD_EXP 25
16606: PUSH
16607: LD_EXP 26
16611: PUSH
16612: LD_EXP 27
16616: PUSH
16617: LD_EXP 28
16621: PUSH
16622: LD_EXP 29
16626: PUSH
16627: LD_EXP 30
16631: PUSH
16632: LD_EXP 31
16636: PUSH
16637: LD_EXP 32
16641: PUSH
16642: LD_EXP 34
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: LIST
16652: LIST
16653: LIST
16654: LIST
16655: LIST
16656: LIST
16657: LIST
16658: LIST
16659: LIST
16660: LIST
16661: LIST
16662: PUSH
16663: LD_VAR 0 3
16667: ADD
16668: DIFF
16669: ST_TO_ADDR
// if not result then
16670: LD_VAR 0 4
16674: NOT
16675: IFFALSE 16679
// exit ;
16677: GO 16707
// result := result [ 1 ] ;
16679: LD_ADDR_VAR 0 4
16683: PUSH
16684: LD_VAR 0 4
16688: PUSH
16689: LD_INT 1
16691: ARRAY
16692: ST_TO_ADDR
// Say ( result , dial ) ;
16693: LD_VAR 0 4
16697: PPUSH
16698: LD_VAR 0 2
16702: PPUSH
16703: CALL_OW 88
// end ; end_of_file
16707: LD_VAR 0 4
16711: RET
// export function CustomEvent ( event ) ; begin
16712: LD_INT 0
16714: PPUSH
// end ;
16715: LD_VAR 0 2
16719: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16720: LD_VAR 0 1
16724: PPUSH
16725: CALL_OW 255
16729: PUSH
16730: LD_INT 1
16732: EQUAL
16733: IFFALSE 16743
// artifact_get := true ;
16735: LD_ADDR_EXP 13
16739: PUSH
16740: LD_INT 1
16742: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16743: LD_VAR 0 1
16747: PPUSH
16748: CALL_OW 255
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: IFFALSE 16774
// begin artifact_get := false ;
16758: LD_ADDR_EXP 13
16762: PUSH
16763: LD_INT 0
16765: ST_TO_ADDR
// artifact_stolen := true ;
16766: LD_ADDR_EXP 12
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16774: LD_ADDR_EXP 14
16778: PUSH
16779: LD_INT 1
16781: ST_TO_ADDR
// end ;
16782: PPOPN 2
16784: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16785: LD_ADDR_EXP 14
16789: PUSH
16790: LD_INT 0
16792: ST_TO_ADDR
// end ;
16793: PPOPN 2
16795: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16796: LD_VAR 0 1
16800: PUSH
16801: LD_EXP 21
16805: EQUAL
16806: IFFALSE 16817
// begin YouLost ( JMM ) ;
16808: LD_STRING JMM
16810: PPUSH
16811: CALL_OW 104
// exit ;
16815: GO 16949
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16817: LD_VAR 0 1
16821: PUSH
16822: LD_INT 22
16824: PUSH
16825: LD_INT 1
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 21
16834: PUSH
16835: LD_INT 1
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: LD_INT 2
16844: PUSH
16845: LD_INT 25
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 25
16857: PUSH
16858: LD_INT 2
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 25
16867: PUSH
16868: LD_INT 3
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 25
16877: PUSH
16878: LD_INT 4
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 25
16887: PUSH
16888: LD_INT 5
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: LD_INT 25
16897: PUSH
16898: LD_INT 8
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: EMPTY
16906: LIST
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: LIST
16912: LIST
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: LIST
16918: PPUSH
16919: CALL_OW 69
16923: IN
16924: IFFALSE 16940
// loses_counter := loses_counter + 1 ;
16926: LD_ADDR_EXP 17
16930: PUSH
16931: LD_EXP 17
16935: PUSH
16936: LD_INT 1
16938: PLUS
16939: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16940: LD_VAR 0 1
16944: PPUSH
16945: CALL 44562 0 1
// end ;
16949: PPOPN 1
16951: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_VAR 0 2
16961: PPUSH
16962: CALL 46896 0 2
// end ;
16966: PPOPN 2
16968: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16969: LD_VAR 0 1
16973: PPUSH
16974: CALL 46205 0 1
// end ;
16978: PPOPN 1
16980: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16981: LD_VAR 0 1
16985: PPUSH
16986: LD_VAR 0 2
16990: PPUSH
16991: LD_VAR 0 3
16995: PPUSH
16996: LD_VAR 0 4
17000: PPUSH
17001: LD_VAR 0 5
17005: PPUSH
17006: CALL 43878 0 5
// end ;
17010: PPOPN 5
17012: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 248
17022: PUSH
17023: LD_INT 1
17025: EQUAL
17026: IFFALSE 17036
// am_veh_consturcted := true ;
17028: LD_ADDR_EXP 20
17032: PUSH
17033: LD_INT 1
17035: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17036: LD_VAR 0 1
17040: PPUSH
17041: LD_VAR 0 2
17045: PPUSH
17046: CALL 43468 0 2
// end ;
17050: PPOPN 2
17052: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 247
17062: PUSH
17063: LD_INT 2
17065: EQUAL
17066: IFFALSE 17070
// exit ;
17068: GO 17087
// if not kamikazed then
17070: LD_EXP 11
17074: NOT
17075: IFFALSE 17087
// kamikazed := unit ;
17077: LD_ADDR_EXP 11
17081: PUSH
17082: LD_VAR 0 1
17086: ST_TO_ADDR
// end ;
17087: PPOPN 1
17089: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17090: LD_INT 0
17092: PPUSH
17093: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17094: LD_VAR 0 1
17098: PPUSH
17099: LD_VAR 0 2
17103: PPUSH
17104: LD_VAR 0 3
17108: PPUSH
17109: LD_VAR 0 4
17113: PPUSH
17114: CALL 43306 0 4
// end ;
17118: PPOPN 6
17120: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17121: LD_VAR 0 1
17125: PPUSH
17126: LD_VAR 0 2
17130: PPUSH
17131: LD_VAR 0 3
17135: PPUSH
17136: CALL 43081 0 3
// end ;
17140: PPOPN 3
17142: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17143: LD_VAR 0 1
17147: PPUSH
17148: LD_VAR 0 2
17152: PPUSH
17153: CALL 44258 0 2
// end ;
17157: PPOPN 2
17159: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17160: LD_VAR 0 1
17164: PPUSH
17165: LD_VAR 0 2
17169: PPUSH
17170: CALL 42775 0 2
// end ;
17174: PPOPN 2
17176: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17177: LD_VAR 0 1
17181: PPUSH
17182: LD_VAR 0 2
17186: PPUSH
17187: CALL 42966 0 2
// end ;
17191: PPOPN 2
17193: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17194: LD_VAR 0 1
17198: PPUSH
17199: CALL 45964 0 1
// end ;
17203: PPOPN 1
17205: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17206: LD_VAR 0 1
17210: PPUSH
17211: LD_VAR 0 2
17215: PPUSH
17216: CALL 47157 0 2
// end ;
17220: PPOPN 2
17222: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17223: LD_VAR 0 1
17227: PPUSH
17228: LD_VAR 0 2
17232: PPUSH
17233: LD_VAR 0 3
17237: PPUSH
17238: LD_VAR 0 4
17242: PPUSH
17243: CALL 47373 0 4
// end ;
17247: PPOPN 4
17249: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 98000 0 1
// end ; end_of_file
17259: PPOPN 1
17261: END
// every 0 0$1 trigger game do
17262: LD_EXP 2
17266: IFFALSE 17296
17268: GO 17270
17270: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17271: LD_INT 7
17273: PUSH
17274: LD_INT 6
17276: PUSH
17277: LD_INT 4
17279: PUSH
17280: LD_INT 6
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: LIST
17287: LIST
17288: PPUSH
17289: LD_INT 1750
17291: PPUSH
17292: CALL 17297 0 2
17296: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17297: LD_INT 0
17299: PPUSH
17300: PPUSH
17301: PPUSH
// if not areas then
17302: LD_VAR 0 1
17306: NOT
17307: IFFALSE 17311
// exit ;
17309: GO 17441
// repeat wait ( time ) ;
17311: LD_VAR 0 2
17315: PPUSH
17316: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17320: LD_ADDR_VAR 0 5
17324: PUSH
17325: LD_INT 1
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: CALL_OW 12
17335: ST_TO_ADDR
// for i in areas do
17336: LD_ADDR_VAR 0 4
17340: PUSH
17341: LD_VAR 0 1
17345: PUSH
17346: FOR_IN
17347: IFFALSE 17400
// begin if Prob ( p ) then
17349: LD_VAR 0 5
17353: PPUSH
17354: CALL_OW 13
17358: IFFALSE 17398
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17360: LD_INT 1
17362: PPUSH
17363: LD_INT 5
17365: PPUSH
17366: CALL_OW 12
17370: PPUSH
17371: LD_VAR 0 4
17375: PPUSH
17376: LD_INT 1
17378: PPUSH
17379: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17383: LD_INT 385
17385: PPUSH
17386: LD_INT 595
17388: PPUSH
17389: CALL_OW 12
17393: PPUSH
17394: CALL_OW 67
// end ; end ;
17398: GO 17346
17400: POP
17401: POP
// time := time + 0 0$3 ;
17402: LD_ADDR_VAR 0 2
17406: PUSH
17407: LD_VAR 0 2
17411: PUSH
17412: LD_INT 105
17414: PLUS
17415: ST_TO_ADDR
// if time > 7 7$00 then
17416: LD_VAR 0 2
17420: PUSH
17421: LD_INT 14700
17423: GREATER
17424: IFFALSE 17434
// time := 0 0$40 ;
17426: LD_ADDR_VAR 0 2
17430: PUSH
17431: LD_INT 1400
17433: ST_TO_ADDR
// until not game ;
17434: LD_EXP 2
17438: NOT
17439: IFFALSE 17311
// end ; end_of_file
17441: LD_VAR 0 3
17445: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17446: LD_INT 0
17448: PPUSH
17449: PPUSH
// skirmish := false ;
17450: LD_ADDR_EXP 48
17454: PUSH
17455: LD_INT 0
17457: ST_TO_ADDR
// debug_mc := false ;
17458: LD_ADDR_EXP 49
17462: PUSH
17463: LD_INT 0
17465: ST_TO_ADDR
// mc_bases := [ ] ;
17466: LD_ADDR_EXP 50
17470: PUSH
17471: EMPTY
17472: ST_TO_ADDR
// mc_sides := [ ] ;
17473: LD_ADDR_EXP 76
17477: PUSH
17478: EMPTY
17479: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17480: LD_ADDR_EXP 51
17484: PUSH
17485: EMPTY
17486: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17487: LD_ADDR_EXP 52
17491: PUSH
17492: EMPTY
17493: ST_TO_ADDR
// mc_need_heal := [ ] ;
17494: LD_ADDR_EXP 53
17498: PUSH
17499: EMPTY
17500: ST_TO_ADDR
// mc_healers := [ ] ;
17501: LD_ADDR_EXP 54
17505: PUSH
17506: EMPTY
17507: ST_TO_ADDR
// mc_build_list := [ ] ;
17508: LD_ADDR_EXP 55
17512: PUSH
17513: EMPTY
17514: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17515: LD_ADDR_EXP 82
17519: PUSH
17520: EMPTY
17521: ST_TO_ADDR
// mc_builders := [ ] ;
17522: LD_ADDR_EXP 56
17526: PUSH
17527: EMPTY
17528: ST_TO_ADDR
// mc_construct_list := [ ] ;
17529: LD_ADDR_EXP 57
17533: PUSH
17534: EMPTY
17535: ST_TO_ADDR
// mc_turret_list := [ ] ;
17536: LD_ADDR_EXP 58
17540: PUSH
17541: EMPTY
17542: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17543: LD_ADDR_EXP 59
17547: PUSH
17548: EMPTY
17549: ST_TO_ADDR
// mc_miners := [ ] ;
17550: LD_ADDR_EXP 64
17554: PUSH
17555: EMPTY
17556: ST_TO_ADDR
// mc_mines := [ ] ;
17557: LD_ADDR_EXP 63
17561: PUSH
17562: EMPTY
17563: ST_TO_ADDR
// mc_minefields := [ ] ;
17564: LD_ADDR_EXP 65
17568: PUSH
17569: EMPTY
17570: ST_TO_ADDR
// mc_crates := [ ] ;
17571: LD_ADDR_EXP 66
17575: PUSH
17576: EMPTY
17577: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17578: LD_ADDR_EXP 67
17582: PUSH
17583: EMPTY
17584: ST_TO_ADDR
// mc_crates_area := [ ] ;
17585: LD_ADDR_EXP 68
17589: PUSH
17590: EMPTY
17591: ST_TO_ADDR
// mc_vehicles := [ ] ;
17592: LD_ADDR_EXP 69
17596: PUSH
17597: EMPTY
17598: ST_TO_ADDR
// mc_attack := [ ] ;
17599: LD_ADDR_EXP 70
17603: PUSH
17604: EMPTY
17605: ST_TO_ADDR
// mc_produce := [ ] ;
17606: LD_ADDR_EXP 71
17610: PUSH
17611: EMPTY
17612: ST_TO_ADDR
// mc_defender := [ ] ;
17613: LD_ADDR_EXP 72
17617: PUSH
17618: EMPTY
17619: ST_TO_ADDR
// mc_parking := [ ] ;
17620: LD_ADDR_EXP 74
17624: PUSH
17625: EMPTY
17626: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17627: LD_ADDR_EXP 60
17631: PUSH
17632: EMPTY
17633: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17634: LD_ADDR_EXP 62
17638: PUSH
17639: EMPTY
17640: ST_TO_ADDR
// mc_scan := [ ] ;
17641: LD_ADDR_EXP 73
17645: PUSH
17646: EMPTY
17647: ST_TO_ADDR
// mc_scan_area := [ ] ;
17648: LD_ADDR_EXP 75
17652: PUSH
17653: EMPTY
17654: ST_TO_ADDR
// mc_tech := [ ] ;
17655: LD_ADDR_EXP 77
17659: PUSH
17660: EMPTY
17661: ST_TO_ADDR
// mc_class := [ ] ;
17662: LD_ADDR_EXP 91
17666: PUSH
17667: EMPTY
17668: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17669: LD_ADDR_EXP 92
17673: PUSH
17674: EMPTY
17675: ST_TO_ADDR
// end ;
17676: LD_VAR 0 1
17680: RET
// export function MC_Kill ( base ) ; begin
17681: LD_INT 0
17683: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17684: LD_ADDR_EXP 50
17688: PUSH
17689: LD_EXP 50
17693: PPUSH
17694: LD_VAR 0 1
17698: PPUSH
17699: EMPTY
17700: PPUSH
17701: CALL_OW 1
17705: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17706: LD_ADDR_EXP 51
17710: PUSH
17711: LD_EXP 51
17715: PPUSH
17716: LD_VAR 0 1
17720: PPUSH
17721: EMPTY
17722: PPUSH
17723: CALL_OW 1
17727: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17728: LD_ADDR_EXP 52
17732: PUSH
17733: LD_EXP 52
17737: PPUSH
17738: LD_VAR 0 1
17742: PPUSH
17743: EMPTY
17744: PPUSH
17745: CALL_OW 1
17749: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17750: LD_ADDR_EXP 53
17754: PUSH
17755: LD_EXP 53
17759: PPUSH
17760: LD_VAR 0 1
17764: PPUSH
17765: EMPTY
17766: PPUSH
17767: CALL_OW 1
17771: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17772: LD_ADDR_EXP 54
17776: PUSH
17777: LD_EXP 54
17781: PPUSH
17782: LD_VAR 0 1
17786: PPUSH
17787: EMPTY
17788: PPUSH
17789: CALL_OW 1
17793: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17794: LD_ADDR_EXP 55
17798: PUSH
17799: LD_EXP 55
17803: PPUSH
17804: LD_VAR 0 1
17808: PPUSH
17809: EMPTY
17810: PPUSH
17811: CALL_OW 1
17815: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17816: LD_ADDR_EXP 56
17820: PUSH
17821: LD_EXP 56
17825: PPUSH
17826: LD_VAR 0 1
17830: PPUSH
17831: EMPTY
17832: PPUSH
17833: CALL_OW 1
17837: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17838: LD_ADDR_EXP 57
17842: PUSH
17843: LD_EXP 57
17847: PPUSH
17848: LD_VAR 0 1
17852: PPUSH
17853: EMPTY
17854: PPUSH
17855: CALL_OW 1
17859: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17860: LD_ADDR_EXP 58
17864: PUSH
17865: LD_EXP 58
17869: PPUSH
17870: LD_VAR 0 1
17874: PPUSH
17875: EMPTY
17876: PPUSH
17877: CALL_OW 1
17881: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17882: LD_ADDR_EXP 59
17886: PUSH
17887: LD_EXP 59
17891: PPUSH
17892: LD_VAR 0 1
17896: PPUSH
17897: EMPTY
17898: PPUSH
17899: CALL_OW 1
17903: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17904: LD_ADDR_EXP 60
17908: PUSH
17909: LD_EXP 60
17913: PPUSH
17914: LD_VAR 0 1
17918: PPUSH
17919: EMPTY
17920: PPUSH
17921: CALL_OW 1
17925: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17926: LD_ADDR_EXP 61
17930: PUSH
17931: LD_EXP 61
17935: PPUSH
17936: LD_VAR 0 1
17940: PPUSH
17941: LD_INT 0
17943: PPUSH
17944: CALL_OW 1
17948: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17949: LD_ADDR_EXP 62
17953: PUSH
17954: LD_EXP 62
17958: PPUSH
17959: LD_VAR 0 1
17963: PPUSH
17964: EMPTY
17965: PPUSH
17966: CALL_OW 1
17970: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17971: LD_ADDR_EXP 63
17975: PUSH
17976: LD_EXP 63
17980: PPUSH
17981: LD_VAR 0 1
17985: PPUSH
17986: EMPTY
17987: PPUSH
17988: CALL_OW 1
17992: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17993: LD_ADDR_EXP 64
17997: PUSH
17998: LD_EXP 64
18002: PPUSH
18003: LD_VAR 0 1
18007: PPUSH
18008: EMPTY
18009: PPUSH
18010: CALL_OW 1
18014: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18015: LD_ADDR_EXP 65
18019: PUSH
18020: LD_EXP 65
18024: PPUSH
18025: LD_VAR 0 1
18029: PPUSH
18030: EMPTY
18031: PPUSH
18032: CALL_OW 1
18036: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18037: LD_ADDR_EXP 66
18041: PUSH
18042: LD_EXP 66
18046: PPUSH
18047: LD_VAR 0 1
18051: PPUSH
18052: EMPTY
18053: PPUSH
18054: CALL_OW 1
18058: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18059: LD_ADDR_EXP 67
18063: PUSH
18064: LD_EXP 67
18068: PPUSH
18069: LD_VAR 0 1
18073: PPUSH
18074: EMPTY
18075: PPUSH
18076: CALL_OW 1
18080: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18081: LD_ADDR_EXP 68
18085: PUSH
18086: LD_EXP 68
18090: PPUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: EMPTY
18097: PPUSH
18098: CALL_OW 1
18102: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18103: LD_ADDR_EXP 69
18107: PUSH
18108: LD_EXP 69
18112: PPUSH
18113: LD_VAR 0 1
18117: PPUSH
18118: EMPTY
18119: PPUSH
18120: CALL_OW 1
18124: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18125: LD_ADDR_EXP 70
18129: PUSH
18130: LD_EXP 70
18134: PPUSH
18135: LD_VAR 0 1
18139: PPUSH
18140: EMPTY
18141: PPUSH
18142: CALL_OW 1
18146: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18147: LD_ADDR_EXP 71
18151: PUSH
18152: LD_EXP 71
18156: PPUSH
18157: LD_VAR 0 1
18161: PPUSH
18162: EMPTY
18163: PPUSH
18164: CALL_OW 1
18168: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18169: LD_ADDR_EXP 72
18173: PUSH
18174: LD_EXP 72
18178: PPUSH
18179: LD_VAR 0 1
18183: PPUSH
18184: EMPTY
18185: PPUSH
18186: CALL_OW 1
18190: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18191: LD_ADDR_EXP 73
18195: PUSH
18196: LD_EXP 73
18200: PPUSH
18201: LD_VAR 0 1
18205: PPUSH
18206: EMPTY
18207: PPUSH
18208: CALL_OW 1
18212: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18213: LD_ADDR_EXP 74
18217: PUSH
18218: LD_EXP 74
18222: PPUSH
18223: LD_VAR 0 1
18227: PPUSH
18228: EMPTY
18229: PPUSH
18230: CALL_OW 1
18234: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18235: LD_ADDR_EXP 75
18239: PUSH
18240: LD_EXP 75
18244: PPUSH
18245: LD_VAR 0 1
18249: PPUSH
18250: EMPTY
18251: PPUSH
18252: CALL_OW 1
18256: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18257: LD_ADDR_EXP 77
18261: PUSH
18262: LD_EXP 77
18266: PPUSH
18267: LD_VAR 0 1
18271: PPUSH
18272: EMPTY
18273: PPUSH
18274: CALL_OW 1
18278: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18279: LD_ADDR_EXP 79
18283: PUSH
18284: LD_EXP 79
18288: PPUSH
18289: LD_VAR 0 1
18293: PPUSH
18294: EMPTY
18295: PPUSH
18296: CALL_OW 1
18300: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18301: LD_ADDR_EXP 80
18305: PUSH
18306: LD_EXP 80
18310: PPUSH
18311: LD_VAR 0 1
18315: PPUSH
18316: EMPTY
18317: PPUSH
18318: CALL_OW 1
18322: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18323: LD_ADDR_EXP 81
18327: PUSH
18328: LD_EXP 81
18332: PPUSH
18333: LD_VAR 0 1
18337: PPUSH
18338: EMPTY
18339: PPUSH
18340: CALL_OW 1
18344: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18345: LD_ADDR_EXP 82
18349: PUSH
18350: LD_EXP 82
18354: PPUSH
18355: LD_VAR 0 1
18359: PPUSH
18360: EMPTY
18361: PPUSH
18362: CALL_OW 1
18366: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18367: LD_ADDR_EXP 83
18371: PUSH
18372: LD_EXP 83
18376: PPUSH
18377: LD_VAR 0 1
18381: PPUSH
18382: EMPTY
18383: PPUSH
18384: CALL_OW 1
18388: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18389: LD_ADDR_EXP 84
18393: PUSH
18394: LD_EXP 84
18398: PPUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: EMPTY
18405: PPUSH
18406: CALL_OW 1
18410: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18411: LD_ADDR_EXP 85
18415: PUSH
18416: LD_EXP 85
18420: PPUSH
18421: LD_VAR 0 1
18425: PPUSH
18426: EMPTY
18427: PPUSH
18428: CALL_OW 1
18432: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18433: LD_ADDR_EXP 86
18437: PUSH
18438: LD_EXP 86
18442: PPUSH
18443: LD_VAR 0 1
18447: PPUSH
18448: EMPTY
18449: PPUSH
18450: CALL_OW 1
18454: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18455: LD_ADDR_EXP 87
18459: PUSH
18460: LD_EXP 87
18464: PPUSH
18465: LD_VAR 0 1
18469: PPUSH
18470: EMPTY
18471: PPUSH
18472: CALL_OW 1
18476: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18477: LD_ADDR_EXP 88
18481: PUSH
18482: LD_EXP 88
18486: PPUSH
18487: LD_VAR 0 1
18491: PPUSH
18492: EMPTY
18493: PPUSH
18494: CALL_OW 1
18498: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18499: LD_ADDR_EXP 89
18503: PUSH
18504: LD_EXP 89
18508: PPUSH
18509: LD_VAR 0 1
18513: PPUSH
18514: EMPTY
18515: PPUSH
18516: CALL_OW 1
18520: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18521: LD_ADDR_EXP 90
18525: PUSH
18526: LD_EXP 90
18530: PPUSH
18531: LD_VAR 0 1
18535: PPUSH
18536: EMPTY
18537: PPUSH
18538: CALL_OW 1
18542: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18543: LD_ADDR_EXP 91
18547: PUSH
18548: LD_EXP 91
18552: PPUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: EMPTY
18559: PPUSH
18560: CALL_OW 1
18564: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18565: LD_ADDR_EXP 92
18569: PUSH
18570: LD_EXP 92
18574: PPUSH
18575: LD_VAR 0 1
18579: PPUSH
18580: LD_INT 0
18582: PPUSH
18583: CALL_OW 1
18587: ST_TO_ADDR
// end ;
18588: LD_VAR 0 2
18592: RET
// export function MC_Add ( side , units ) ; var base ; begin
18593: LD_INT 0
18595: PPUSH
18596: PPUSH
// base := mc_bases + 1 ;
18597: LD_ADDR_VAR 0 4
18601: PUSH
18602: LD_EXP 50
18606: PUSH
18607: LD_INT 1
18609: PLUS
18610: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18611: LD_ADDR_EXP 76
18615: PUSH
18616: LD_EXP 76
18620: PPUSH
18621: LD_VAR 0 4
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: CALL_OW 1
18635: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18636: LD_ADDR_EXP 50
18640: PUSH
18641: LD_EXP 50
18645: PPUSH
18646: LD_VAR 0 4
18650: PPUSH
18651: LD_VAR 0 2
18655: PPUSH
18656: CALL_OW 1
18660: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18661: LD_ADDR_EXP 51
18665: PUSH
18666: LD_EXP 51
18670: PPUSH
18671: LD_VAR 0 4
18675: PPUSH
18676: EMPTY
18677: PPUSH
18678: CALL_OW 1
18682: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18683: LD_ADDR_EXP 52
18687: PUSH
18688: LD_EXP 52
18692: PPUSH
18693: LD_VAR 0 4
18697: PPUSH
18698: EMPTY
18699: PPUSH
18700: CALL_OW 1
18704: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18705: LD_ADDR_EXP 53
18709: PUSH
18710: LD_EXP 53
18714: PPUSH
18715: LD_VAR 0 4
18719: PPUSH
18720: EMPTY
18721: PPUSH
18722: CALL_OW 1
18726: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18727: LD_ADDR_EXP 54
18731: PUSH
18732: LD_EXP 54
18736: PPUSH
18737: LD_VAR 0 4
18741: PPUSH
18742: EMPTY
18743: PPUSH
18744: CALL_OW 1
18748: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18749: LD_ADDR_EXP 55
18753: PUSH
18754: LD_EXP 55
18758: PPUSH
18759: LD_VAR 0 4
18763: PPUSH
18764: EMPTY
18765: PPUSH
18766: CALL_OW 1
18770: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18771: LD_ADDR_EXP 56
18775: PUSH
18776: LD_EXP 56
18780: PPUSH
18781: LD_VAR 0 4
18785: PPUSH
18786: EMPTY
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18793: LD_ADDR_EXP 57
18797: PUSH
18798: LD_EXP 57
18802: PPUSH
18803: LD_VAR 0 4
18807: PPUSH
18808: EMPTY
18809: PPUSH
18810: CALL_OW 1
18814: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18815: LD_ADDR_EXP 58
18819: PUSH
18820: LD_EXP 58
18824: PPUSH
18825: LD_VAR 0 4
18829: PPUSH
18830: EMPTY
18831: PPUSH
18832: CALL_OW 1
18836: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18837: LD_ADDR_EXP 59
18841: PUSH
18842: LD_EXP 59
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: EMPTY
18853: PPUSH
18854: CALL_OW 1
18858: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18859: LD_ADDR_EXP 60
18863: PUSH
18864: LD_EXP 60
18868: PPUSH
18869: LD_VAR 0 4
18873: PPUSH
18874: EMPTY
18875: PPUSH
18876: CALL_OW 1
18880: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18881: LD_ADDR_EXP 61
18885: PUSH
18886: LD_EXP 61
18890: PPUSH
18891: LD_VAR 0 4
18895: PPUSH
18896: LD_INT 0
18898: PPUSH
18899: CALL_OW 1
18903: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18904: LD_ADDR_EXP 62
18908: PUSH
18909: LD_EXP 62
18913: PPUSH
18914: LD_VAR 0 4
18918: PPUSH
18919: EMPTY
18920: PPUSH
18921: CALL_OW 1
18925: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18926: LD_ADDR_EXP 63
18930: PUSH
18931: LD_EXP 63
18935: PPUSH
18936: LD_VAR 0 4
18940: PPUSH
18941: EMPTY
18942: PPUSH
18943: CALL_OW 1
18947: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18948: LD_ADDR_EXP 64
18952: PUSH
18953: LD_EXP 64
18957: PPUSH
18958: LD_VAR 0 4
18962: PPUSH
18963: EMPTY
18964: PPUSH
18965: CALL_OW 1
18969: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18970: LD_ADDR_EXP 65
18974: PUSH
18975: LD_EXP 65
18979: PPUSH
18980: LD_VAR 0 4
18984: PPUSH
18985: EMPTY
18986: PPUSH
18987: CALL_OW 1
18991: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18992: LD_ADDR_EXP 66
18996: PUSH
18997: LD_EXP 66
19001: PPUSH
19002: LD_VAR 0 4
19006: PPUSH
19007: EMPTY
19008: PPUSH
19009: CALL_OW 1
19013: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19014: LD_ADDR_EXP 67
19018: PUSH
19019: LD_EXP 67
19023: PPUSH
19024: LD_VAR 0 4
19028: PPUSH
19029: EMPTY
19030: PPUSH
19031: CALL_OW 1
19035: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19036: LD_ADDR_EXP 68
19040: PUSH
19041: LD_EXP 68
19045: PPUSH
19046: LD_VAR 0 4
19050: PPUSH
19051: EMPTY
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19058: LD_ADDR_EXP 69
19062: PUSH
19063: LD_EXP 69
19067: PPUSH
19068: LD_VAR 0 4
19072: PPUSH
19073: EMPTY
19074: PPUSH
19075: CALL_OW 1
19079: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19080: LD_ADDR_EXP 70
19084: PUSH
19085: LD_EXP 70
19089: PPUSH
19090: LD_VAR 0 4
19094: PPUSH
19095: EMPTY
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19102: LD_ADDR_EXP 71
19106: PUSH
19107: LD_EXP 71
19111: PPUSH
19112: LD_VAR 0 4
19116: PPUSH
19117: EMPTY
19118: PPUSH
19119: CALL_OW 1
19123: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19124: LD_ADDR_EXP 72
19128: PUSH
19129: LD_EXP 72
19133: PPUSH
19134: LD_VAR 0 4
19138: PPUSH
19139: EMPTY
19140: PPUSH
19141: CALL_OW 1
19145: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19146: LD_ADDR_EXP 73
19150: PUSH
19151: LD_EXP 73
19155: PPUSH
19156: LD_VAR 0 4
19160: PPUSH
19161: EMPTY
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19168: LD_ADDR_EXP 74
19172: PUSH
19173: LD_EXP 74
19177: PPUSH
19178: LD_VAR 0 4
19182: PPUSH
19183: EMPTY
19184: PPUSH
19185: CALL_OW 1
19189: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19190: LD_ADDR_EXP 75
19194: PUSH
19195: LD_EXP 75
19199: PPUSH
19200: LD_VAR 0 4
19204: PPUSH
19205: EMPTY
19206: PPUSH
19207: CALL_OW 1
19211: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19212: LD_ADDR_EXP 77
19216: PUSH
19217: LD_EXP 77
19221: PPUSH
19222: LD_VAR 0 4
19226: PPUSH
19227: EMPTY
19228: PPUSH
19229: CALL_OW 1
19233: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19234: LD_ADDR_EXP 79
19238: PUSH
19239: LD_EXP 79
19243: PPUSH
19244: LD_VAR 0 4
19248: PPUSH
19249: EMPTY
19250: PPUSH
19251: CALL_OW 1
19255: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19256: LD_ADDR_EXP 80
19260: PUSH
19261: LD_EXP 80
19265: PPUSH
19266: LD_VAR 0 4
19270: PPUSH
19271: EMPTY
19272: PPUSH
19273: CALL_OW 1
19277: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19278: LD_ADDR_EXP 81
19282: PUSH
19283: LD_EXP 81
19287: PPUSH
19288: LD_VAR 0 4
19292: PPUSH
19293: EMPTY
19294: PPUSH
19295: CALL_OW 1
19299: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19300: LD_ADDR_EXP 82
19304: PUSH
19305: LD_EXP 82
19309: PPUSH
19310: LD_VAR 0 4
19314: PPUSH
19315: EMPTY
19316: PPUSH
19317: CALL_OW 1
19321: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19322: LD_ADDR_EXP 83
19326: PUSH
19327: LD_EXP 83
19331: PPUSH
19332: LD_VAR 0 4
19336: PPUSH
19337: EMPTY
19338: PPUSH
19339: CALL_OW 1
19343: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19344: LD_ADDR_EXP 84
19348: PUSH
19349: LD_EXP 84
19353: PPUSH
19354: LD_VAR 0 4
19358: PPUSH
19359: EMPTY
19360: PPUSH
19361: CALL_OW 1
19365: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19366: LD_ADDR_EXP 85
19370: PUSH
19371: LD_EXP 85
19375: PPUSH
19376: LD_VAR 0 4
19380: PPUSH
19381: EMPTY
19382: PPUSH
19383: CALL_OW 1
19387: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19388: LD_ADDR_EXP 86
19392: PUSH
19393: LD_EXP 86
19397: PPUSH
19398: LD_VAR 0 4
19402: PPUSH
19403: EMPTY
19404: PPUSH
19405: CALL_OW 1
19409: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19410: LD_ADDR_EXP 87
19414: PUSH
19415: LD_EXP 87
19419: PPUSH
19420: LD_VAR 0 4
19424: PPUSH
19425: EMPTY
19426: PPUSH
19427: CALL_OW 1
19431: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19432: LD_ADDR_EXP 88
19436: PUSH
19437: LD_EXP 88
19441: PPUSH
19442: LD_VAR 0 4
19446: PPUSH
19447: EMPTY
19448: PPUSH
19449: CALL_OW 1
19453: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19454: LD_ADDR_EXP 89
19458: PUSH
19459: LD_EXP 89
19463: PPUSH
19464: LD_VAR 0 4
19468: PPUSH
19469: EMPTY
19470: PPUSH
19471: CALL_OW 1
19475: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19476: LD_ADDR_EXP 90
19480: PUSH
19481: LD_EXP 90
19485: PPUSH
19486: LD_VAR 0 4
19490: PPUSH
19491: EMPTY
19492: PPUSH
19493: CALL_OW 1
19497: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19498: LD_ADDR_EXP 91
19502: PUSH
19503: LD_EXP 91
19507: PPUSH
19508: LD_VAR 0 4
19512: PPUSH
19513: EMPTY
19514: PPUSH
19515: CALL_OW 1
19519: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19520: LD_ADDR_EXP 92
19524: PUSH
19525: LD_EXP 92
19529: PPUSH
19530: LD_VAR 0 4
19534: PPUSH
19535: LD_INT 0
19537: PPUSH
19538: CALL_OW 1
19542: ST_TO_ADDR
// result := base ;
19543: LD_ADDR_VAR 0 3
19547: PUSH
19548: LD_VAR 0 4
19552: ST_TO_ADDR
// end ;
19553: LD_VAR 0 3
19557: RET
// export function MC_Start ( ) ; var i ; begin
19558: LD_INT 0
19560: PPUSH
19561: PPUSH
// for i = 1 to mc_bases do
19562: LD_ADDR_VAR 0 2
19566: PUSH
19567: DOUBLE
19568: LD_INT 1
19570: DEC
19571: ST_TO_ADDR
19572: LD_EXP 50
19576: PUSH
19577: FOR_TO
19578: IFFALSE 20655
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19580: LD_ADDR_EXP 50
19584: PUSH
19585: LD_EXP 50
19589: PPUSH
19590: LD_VAR 0 2
19594: PPUSH
19595: LD_EXP 50
19599: PUSH
19600: LD_VAR 0 2
19604: ARRAY
19605: PUSH
19606: LD_INT 0
19608: DIFF
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19615: LD_ADDR_EXP 51
19619: PUSH
19620: LD_EXP 51
19624: PPUSH
19625: LD_VAR 0 2
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19637: LD_ADDR_EXP 52
19641: PUSH
19642: LD_EXP 52
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19659: LD_ADDR_EXP 53
19663: PUSH
19664: LD_EXP 53
19668: PPUSH
19669: LD_VAR 0 2
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19681: LD_ADDR_EXP 54
19685: PUSH
19686: LD_EXP 54
19690: PPUSH
19691: LD_VAR 0 2
19695: PPUSH
19696: EMPTY
19697: PUSH
19698: EMPTY
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: PPUSH
19704: CALL_OW 1
19708: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19709: LD_ADDR_EXP 55
19713: PUSH
19714: LD_EXP 55
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: EMPTY
19725: PPUSH
19726: CALL_OW 1
19730: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19731: LD_ADDR_EXP 82
19735: PUSH
19736: LD_EXP 82
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: EMPTY
19747: PPUSH
19748: CALL_OW 1
19752: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19753: LD_ADDR_EXP 56
19757: PUSH
19758: LD_EXP 56
19762: PPUSH
19763: LD_VAR 0 2
19767: PPUSH
19768: EMPTY
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19775: LD_ADDR_EXP 57
19779: PUSH
19780: LD_EXP 57
19784: PPUSH
19785: LD_VAR 0 2
19789: PPUSH
19790: EMPTY
19791: PPUSH
19792: CALL_OW 1
19796: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19797: LD_ADDR_EXP 58
19801: PUSH
19802: LD_EXP 58
19806: PPUSH
19807: LD_VAR 0 2
19811: PPUSH
19812: LD_EXP 50
19816: PUSH
19817: LD_VAR 0 2
19821: ARRAY
19822: PPUSH
19823: LD_INT 2
19825: PUSH
19826: LD_INT 30
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 30
19838: PUSH
19839: LD_INT 33
19841: PUSH
19842: EMPTY
19843: LIST
19844: LIST
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: PPUSH
19851: CALL_OW 72
19855: PPUSH
19856: CALL_OW 1
19860: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19861: LD_ADDR_EXP 59
19865: PUSH
19866: LD_EXP 59
19870: PPUSH
19871: LD_VAR 0 2
19875: PPUSH
19876: LD_EXP 50
19880: PUSH
19881: LD_VAR 0 2
19885: ARRAY
19886: PPUSH
19887: LD_INT 2
19889: PUSH
19890: LD_INT 30
19892: PUSH
19893: LD_INT 32
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 30
19902: PUSH
19903: LD_INT 31
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: LIST
19914: PUSH
19915: LD_INT 58
19917: PUSH
19918: EMPTY
19919: LIST
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: PPUSH
19925: CALL_OW 72
19929: PPUSH
19930: CALL_OW 1
19934: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19935: LD_ADDR_EXP 60
19939: PUSH
19940: LD_EXP 60
19944: PPUSH
19945: LD_VAR 0 2
19949: PPUSH
19950: EMPTY
19951: PPUSH
19952: CALL_OW 1
19956: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19957: LD_ADDR_EXP 64
19961: PUSH
19962: LD_EXP 64
19966: PPUSH
19967: LD_VAR 0 2
19971: PPUSH
19972: EMPTY
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19979: LD_ADDR_EXP 63
19983: PUSH
19984: LD_EXP 63
19988: PPUSH
19989: LD_VAR 0 2
19993: PPUSH
19994: EMPTY
19995: PPUSH
19996: CALL_OW 1
20000: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20001: LD_ADDR_EXP 65
20005: PUSH
20006: LD_EXP 65
20010: PPUSH
20011: LD_VAR 0 2
20015: PPUSH
20016: EMPTY
20017: PPUSH
20018: CALL_OW 1
20022: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20023: LD_ADDR_EXP 66
20027: PUSH
20028: LD_EXP 66
20032: PPUSH
20033: LD_VAR 0 2
20037: PPUSH
20038: EMPTY
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20045: LD_ADDR_EXP 67
20049: PUSH
20050: LD_EXP 67
20054: PPUSH
20055: LD_VAR 0 2
20059: PPUSH
20060: EMPTY
20061: PPUSH
20062: CALL_OW 1
20066: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20067: LD_ADDR_EXP 68
20071: PUSH
20072: LD_EXP 68
20076: PPUSH
20077: LD_VAR 0 2
20081: PPUSH
20082: EMPTY
20083: PPUSH
20084: CALL_OW 1
20088: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20089: LD_ADDR_EXP 69
20093: PUSH
20094: LD_EXP 69
20098: PPUSH
20099: LD_VAR 0 2
20103: PPUSH
20104: EMPTY
20105: PPUSH
20106: CALL_OW 1
20110: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20111: LD_ADDR_EXP 70
20115: PUSH
20116: LD_EXP 70
20120: PPUSH
20121: LD_VAR 0 2
20125: PPUSH
20126: EMPTY
20127: PPUSH
20128: CALL_OW 1
20132: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20133: LD_ADDR_EXP 71
20137: PUSH
20138: LD_EXP 71
20142: PPUSH
20143: LD_VAR 0 2
20147: PPUSH
20148: EMPTY
20149: PPUSH
20150: CALL_OW 1
20154: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20155: LD_ADDR_EXP 72
20159: PUSH
20160: LD_EXP 72
20164: PPUSH
20165: LD_VAR 0 2
20169: PPUSH
20170: EMPTY
20171: PPUSH
20172: CALL_OW 1
20176: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20177: LD_ADDR_EXP 61
20181: PUSH
20182: LD_EXP 61
20186: PPUSH
20187: LD_VAR 0 2
20191: PPUSH
20192: LD_INT 0
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20200: LD_ADDR_EXP 74
20204: PUSH
20205: LD_EXP 74
20209: PPUSH
20210: LD_VAR 0 2
20214: PPUSH
20215: LD_INT 0
20217: PPUSH
20218: CALL_OW 1
20222: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20223: LD_ADDR_EXP 62
20227: PUSH
20228: LD_EXP 62
20232: PPUSH
20233: LD_VAR 0 2
20237: PPUSH
20238: EMPTY
20239: PPUSH
20240: CALL_OW 1
20244: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20245: LD_ADDR_EXP 73
20249: PUSH
20250: LD_EXP 73
20254: PPUSH
20255: LD_VAR 0 2
20259: PPUSH
20260: LD_INT 0
20262: PPUSH
20263: CALL_OW 1
20267: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20268: LD_ADDR_EXP 75
20272: PUSH
20273: LD_EXP 75
20277: PPUSH
20278: LD_VAR 0 2
20282: PPUSH
20283: EMPTY
20284: PPUSH
20285: CALL_OW 1
20289: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20290: LD_ADDR_EXP 78
20294: PUSH
20295: LD_EXP 78
20299: PPUSH
20300: LD_VAR 0 2
20304: PPUSH
20305: LD_INT 0
20307: PPUSH
20308: CALL_OW 1
20312: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20313: LD_ADDR_EXP 79
20317: PUSH
20318: LD_EXP 79
20322: PPUSH
20323: LD_VAR 0 2
20327: PPUSH
20328: EMPTY
20329: PPUSH
20330: CALL_OW 1
20334: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20335: LD_ADDR_EXP 80
20339: PUSH
20340: LD_EXP 80
20344: PPUSH
20345: LD_VAR 0 2
20349: PPUSH
20350: EMPTY
20351: PPUSH
20352: CALL_OW 1
20356: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20357: LD_ADDR_EXP 81
20361: PUSH
20362: LD_EXP 81
20366: PPUSH
20367: LD_VAR 0 2
20371: PPUSH
20372: EMPTY
20373: PPUSH
20374: CALL_OW 1
20378: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20379: LD_ADDR_EXP 83
20383: PUSH
20384: LD_EXP 83
20388: PPUSH
20389: LD_VAR 0 2
20393: PPUSH
20394: LD_EXP 50
20398: PUSH
20399: LD_VAR 0 2
20403: ARRAY
20404: PPUSH
20405: LD_INT 2
20407: PUSH
20408: LD_INT 30
20410: PUSH
20411: LD_INT 6
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: PUSH
20418: LD_INT 30
20420: PUSH
20421: LD_INT 7
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: LD_INT 8
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: PPUSH
20444: CALL_OW 72
20448: PPUSH
20449: CALL_OW 1
20453: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20454: LD_ADDR_EXP 84
20458: PUSH
20459: LD_EXP 84
20463: PPUSH
20464: LD_VAR 0 2
20468: PPUSH
20469: EMPTY
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20476: LD_ADDR_EXP 85
20480: PUSH
20481: LD_EXP 85
20485: PPUSH
20486: LD_VAR 0 2
20490: PPUSH
20491: EMPTY
20492: PPUSH
20493: CALL_OW 1
20497: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20498: LD_ADDR_EXP 86
20502: PUSH
20503: LD_EXP 86
20507: PPUSH
20508: LD_VAR 0 2
20512: PPUSH
20513: EMPTY
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20520: LD_ADDR_EXP 87
20524: PUSH
20525: LD_EXP 87
20529: PPUSH
20530: LD_VAR 0 2
20534: PPUSH
20535: EMPTY
20536: PPUSH
20537: CALL_OW 1
20541: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20542: LD_ADDR_EXP 88
20546: PUSH
20547: LD_EXP 88
20551: PPUSH
20552: LD_VAR 0 2
20556: PPUSH
20557: EMPTY
20558: PPUSH
20559: CALL_OW 1
20563: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20564: LD_ADDR_EXP 89
20568: PUSH
20569: LD_EXP 89
20573: PPUSH
20574: LD_VAR 0 2
20578: PPUSH
20579: EMPTY
20580: PPUSH
20581: CALL_OW 1
20585: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20586: LD_ADDR_EXP 90
20590: PUSH
20591: LD_EXP 90
20595: PPUSH
20596: LD_VAR 0 2
20600: PPUSH
20601: EMPTY
20602: PPUSH
20603: CALL_OW 1
20607: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20608: LD_ADDR_EXP 91
20612: PUSH
20613: LD_EXP 91
20617: PPUSH
20618: LD_VAR 0 2
20622: PPUSH
20623: EMPTY
20624: PPUSH
20625: CALL_OW 1
20629: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20630: LD_ADDR_EXP 92
20634: PUSH
20635: LD_EXP 92
20639: PPUSH
20640: LD_VAR 0 2
20644: PPUSH
20645: LD_INT 0
20647: PPUSH
20648: CALL_OW 1
20652: ST_TO_ADDR
// end ;
20653: GO 19577
20655: POP
20656: POP
// MC_InitSides ( ) ;
20657: CALL 20943 0 0
// MC_InitResearch ( ) ;
20661: CALL 20682 0 0
// CustomInitMacro ( ) ;
20665: CALL 304 0 0
// skirmish := true ;
20669: LD_ADDR_EXP 48
20673: PUSH
20674: LD_INT 1
20676: ST_TO_ADDR
// end ;
20677: LD_VAR 0 1
20681: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20682: LD_INT 0
20684: PPUSH
20685: PPUSH
20686: PPUSH
20687: PPUSH
20688: PPUSH
20689: PPUSH
// if not mc_bases then
20690: LD_EXP 50
20694: NOT
20695: IFFALSE 20699
// exit ;
20697: GO 20938
// for i = 1 to 8 do
20699: LD_ADDR_VAR 0 2
20703: PUSH
20704: DOUBLE
20705: LD_INT 1
20707: DEC
20708: ST_TO_ADDR
20709: LD_INT 8
20711: PUSH
20712: FOR_TO
20713: IFFALSE 20739
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20715: LD_ADDR_EXP 77
20719: PUSH
20720: LD_EXP 77
20724: PPUSH
20725: LD_VAR 0 2
20729: PPUSH
20730: EMPTY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
20737: GO 20712
20739: POP
20740: POP
// tmp := [ ] ;
20741: LD_ADDR_VAR 0 5
20745: PUSH
20746: EMPTY
20747: ST_TO_ADDR
// for i = 1 to mc_sides do
20748: LD_ADDR_VAR 0 2
20752: PUSH
20753: DOUBLE
20754: LD_INT 1
20756: DEC
20757: ST_TO_ADDR
20758: LD_EXP 76
20762: PUSH
20763: FOR_TO
20764: IFFALSE 20822
// if not mc_sides [ i ] in tmp then
20766: LD_EXP 76
20770: PUSH
20771: LD_VAR 0 2
20775: ARRAY
20776: PUSH
20777: LD_VAR 0 5
20781: IN
20782: NOT
20783: IFFALSE 20820
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20785: LD_ADDR_VAR 0 5
20789: PUSH
20790: LD_VAR 0 5
20794: PPUSH
20795: LD_VAR 0 5
20799: PUSH
20800: LD_INT 1
20802: PLUS
20803: PPUSH
20804: LD_EXP 76
20808: PUSH
20809: LD_VAR 0 2
20813: ARRAY
20814: PPUSH
20815: CALL_OW 2
20819: ST_TO_ADDR
20820: GO 20763
20822: POP
20823: POP
// if not tmp then
20824: LD_VAR 0 5
20828: NOT
20829: IFFALSE 20833
// exit ;
20831: GO 20938
// for j in tmp do
20833: LD_ADDR_VAR 0 3
20837: PUSH
20838: LD_VAR 0 5
20842: PUSH
20843: FOR_IN
20844: IFFALSE 20936
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20846: LD_ADDR_VAR 0 6
20850: PUSH
20851: LD_INT 22
20853: PUSH
20854: LD_VAR 0 3
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PPUSH
20863: CALL_OW 69
20867: ST_TO_ADDR
// if not un then
20868: LD_VAR 0 6
20872: NOT
20873: IFFALSE 20877
// continue ;
20875: GO 20843
// nation := GetNation ( un [ 1 ] ) ;
20877: LD_ADDR_VAR 0 4
20881: PUSH
20882: LD_VAR 0 6
20886: PUSH
20887: LD_INT 1
20889: ARRAY
20890: PPUSH
20891: CALL_OW 248
20895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20896: LD_ADDR_EXP 77
20900: PUSH
20901: LD_EXP 77
20905: PPUSH
20906: LD_VAR 0 3
20910: PPUSH
20911: LD_VAR 0 3
20915: PPUSH
20916: LD_VAR 0 4
20920: PPUSH
20921: LD_INT 1
20923: PPUSH
20924: CALL 47577 0 3
20928: PPUSH
20929: CALL_OW 1
20933: ST_TO_ADDR
// end ;
20934: GO 20843
20936: POP
20937: POP
// end ;
20938: LD_VAR 0 1
20942: RET
// export function MC_InitSides ( ) ; var i ; begin
20943: LD_INT 0
20945: PPUSH
20946: PPUSH
// if not mc_bases then
20947: LD_EXP 50
20951: NOT
20952: IFFALSE 20956
// exit ;
20954: GO 21030
// for i = 1 to mc_bases do
20956: LD_ADDR_VAR 0 2
20960: PUSH
20961: DOUBLE
20962: LD_INT 1
20964: DEC
20965: ST_TO_ADDR
20966: LD_EXP 50
20970: PUSH
20971: FOR_TO
20972: IFFALSE 21028
// if mc_bases [ i ] then
20974: LD_EXP 50
20978: PUSH
20979: LD_VAR 0 2
20983: ARRAY
20984: IFFALSE 21026
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20986: LD_ADDR_EXP 76
20990: PUSH
20991: LD_EXP 76
20995: PPUSH
20996: LD_VAR 0 2
21000: PPUSH
21001: LD_EXP 50
21005: PUSH
21006: LD_VAR 0 2
21010: ARRAY
21011: PUSH
21012: LD_INT 1
21014: ARRAY
21015: PPUSH
21016: CALL_OW 255
21020: PPUSH
21021: CALL_OW 1
21025: ST_TO_ADDR
21026: GO 20971
21028: POP
21029: POP
// end ;
21030: LD_VAR 0 1
21034: RET
// every 0 0$01 trigger skirmish do
21035: LD_EXP 48
21039: IFFALSE 21193
21041: GO 21043
21043: DISABLE
// begin enable ;
21044: ENABLE
// MC_CheckBuildings ( ) ;
21045: CALL 25691 0 0
// MC_CheckPeopleLife ( ) ;
21049: CALL 25816 0 0
// RaiseSailEvent ( 100 ) ;
21053: LD_INT 100
21055: PPUSH
21056: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21060: LD_INT 103
21062: PPUSH
21063: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21067: LD_INT 104
21069: PPUSH
21070: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21074: LD_INT 105
21076: PPUSH
21077: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21081: LD_INT 106
21083: PPUSH
21084: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21088: LD_INT 107
21090: PPUSH
21091: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21095: LD_INT 108
21097: PPUSH
21098: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21102: LD_INT 109
21104: PPUSH
21105: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21109: LD_INT 110
21111: PPUSH
21112: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21116: LD_INT 111
21118: PPUSH
21119: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21123: LD_INT 112
21125: PPUSH
21126: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21130: LD_INT 113
21132: PPUSH
21133: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21137: LD_INT 120
21139: PPUSH
21140: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21144: LD_INT 121
21146: PPUSH
21147: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21151: LD_INT 122
21153: PPUSH
21154: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21158: LD_INT 123
21160: PPUSH
21161: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21165: LD_INT 124
21167: PPUSH
21168: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21172: LD_INT 125
21174: PPUSH
21175: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21179: LD_INT 126
21181: PPUSH
21182: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21186: LD_INT 200
21188: PPUSH
21189: CALL_OW 427
// end ;
21193: END
// on SailEvent ( event ) do begin if event < 100 then
21194: LD_VAR 0 1
21198: PUSH
21199: LD_INT 100
21201: LESS
21202: IFFALSE 21213
// CustomEvent ( event ) ;
21204: LD_VAR 0 1
21208: PPUSH
21209: CALL 16712 0 1
// if event = 100 then
21213: LD_VAR 0 1
21217: PUSH
21218: LD_INT 100
21220: EQUAL
21221: IFFALSE 21227
// MC_ClassManager ( ) ;
21223: CALL 21619 0 0
// if event = 101 then
21227: LD_VAR 0 1
21231: PUSH
21232: LD_INT 101
21234: EQUAL
21235: IFFALSE 21241
// MC_RepairBuildings ( ) ;
21237: CALL 26401 0 0
// if event = 102 then
21241: LD_VAR 0 1
21245: PUSH
21246: LD_INT 102
21248: EQUAL
21249: IFFALSE 21255
// MC_Heal ( ) ;
21251: CALL 27286 0 0
// if event = 103 then
21255: LD_VAR 0 1
21259: PUSH
21260: LD_INT 103
21262: EQUAL
21263: IFFALSE 21269
// MC_Build ( ) ;
21265: CALL 27708 0 0
// if event = 104 then
21269: LD_VAR 0 1
21273: PUSH
21274: LD_INT 104
21276: EQUAL
21277: IFFALSE 21283
// MC_TurretWeapon ( ) ;
21279: CALL 29321 0 0
// if event = 105 then
21283: LD_VAR 0 1
21287: PUSH
21288: LD_INT 105
21290: EQUAL
21291: IFFALSE 21297
// MC_BuildUpgrade ( ) ;
21293: CALL 28872 0 0
// if event = 106 then
21297: LD_VAR 0 1
21301: PUSH
21302: LD_INT 106
21304: EQUAL
21305: IFFALSE 21311
// MC_PlantMines ( ) ;
21307: CALL 29751 0 0
// if event = 107 then
21311: LD_VAR 0 1
21315: PUSH
21316: LD_INT 107
21318: EQUAL
21319: IFFALSE 21325
// MC_CollectCrates ( ) ;
21321: CALL 30549 0 0
// if event = 108 then
21325: LD_VAR 0 1
21329: PUSH
21330: LD_INT 108
21332: EQUAL
21333: IFFALSE 21339
// MC_LinkRemoteControl ( ) ;
21335: CALL 32325 0 0
// if event = 109 then
21339: LD_VAR 0 1
21343: PUSH
21344: LD_INT 109
21346: EQUAL
21347: IFFALSE 21353
// MC_ProduceVehicle ( ) ;
21349: CALL 32506 0 0
// if event = 110 then
21353: LD_VAR 0 1
21357: PUSH
21358: LD_INT 110
21360: EQUAL
21361: IFFALSE 21367
// MC_SendAttack ( ) ;
21363: CALL 32972 0 0
// if event = 111 then
21367: LD_VAR 0 1
21371: PUSH
21372: LD_INT 111
21374: EQUAL
21375: IFFALSE 21381
// MC_Defend ( ) ;
21377: CALL 33080 0 0
// if event = 112 then
21381: LD_VAR 0 1
21385: PUSH
21386: LD_INT 112
21388: EQUAL
21389: IFFALSE 21395
// MC_Research ( ) ;
21391: CALL 33685 0 0
// if event = 113 then
21395: LD_VAR 0 1
21399: PUSH
21400: LD_INT 113
21402: EQUAL
21403: IFFALSE 21409
// MC_MinesTrigger ( ) ;
21405: CALL 34799 0 0
// if event = 120 then
21409: LD_VAR 0 1
21413: PUSH
21414: LD_INT 120
21416: EQUAL
21417: IFFALSE 21423
// MC_RepairVehicle ( ) ;
21419: CALL 34898 0 0
// if event = 121 then
21423: LD_VAR 0 1
21427: PUSH
21428: LD_INT 121
21430: EQUAL
21431: IFFALSE 21437
// MC_TameApe ( ) ;
21433: CALL 35628 0 0
// if event = 122 then
21437: LD_VAR 0 1
21441: PUSH
21442: LD_INT 122
21444: EQUAL
21445: IFFALSE 21451
// MC_ChangeApeClass ( ) ;
21447: CALL 36457 0 0
// if event = 123 then
21451: LD_VAR 0 1
21455: PUSH
21456: LD_INT 123
21458: EQUAL
21459: IFFALSE 21465
// MC_Bazooka ( ) ;
21461: CALL 37107 0 0
// if event = 124 then
21465: LD_VAR 0 1
21469: PUSH
21470: LD_INT 124
21472: EQUAL
21473: IFFALSE 21479
// MC_TeleportExit ( ) ;
21475: CALL 37305 0 0
// if event = 125 then
21479: LD_VAR 0 1
21483: PUSH
21484: LD_INT 125
21486: EQUAL
21487: IFFALSE 21493
// MC_Deposits ( ) ;
21489: CALL 37952 0 0
// if event = 126 then
21493: LD_VAR 0 1
21497: PUSH
21498: LD_INT 126
21500: EQUAL
21501: IFFALSE 21507
// MC_RemoteDriver ( ) ;
21503: CALL 38577 0 0
// if event = 200 then
21507: LD_VAR 0 1
21511: PUSH
21512: LD_INT 200
21514: EQUAL
21515: IFFALSE 21521
// MC_Idle ( ) ;
21517: CALL 40526 0 0
// end ;
21521: PPOPN 1
21523: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21524: LD_INT 0
21526: PPUSH
21527: PPUSH
// if not mc_bases [ base ] or not tag then
21528: LD_EXP 50
21532: PUSH
21533: LD_VAR 0 1
21537: ARRAY
21538: NOT
21539: PUSH
21540: LD_VAR 0 2
21544: NOT
21545: OR
21546: IFFALSE 21550
// exit ;
21548: GO 21614
// for i in mc_bases [ base ] union mc_ape [ base ] do
21550: LD_ADDR_VAR 0 4
21554: PUSH
21555: LD_EXP 50
21559: PUSH
21560: LD_VAR 0 1
21564: ARRAY
21565: PUSH
21566: LD_EXP 79
21570: PUSH
21571: LD_VAR 0 1
21575: ARRAY
21576: UNION
21577: PUSH
21578: FOR_IN
21579: IFFALSE 21612
// if GetTag ( i ) = tag then
21581: LD_VAR 0 4
21585: PPUSH
21586: CALL_OW 110
21590: PUSH
21591: LD_VAR 0 2
21595: EQUAL
21596: IFFALSE 21610
// SetTag ( i , 0 ) ;
21598: LD_VAR 0 4
21602: PPUSH
21603: LD_INT 0
21605: PPUSH
21606: CALL_OW 109
21610: GO 21578
21612: POP
21613: POP
// end ;
21614: LD_VAR 0 3
21618: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21619: LD_INT 0
21621: PPUSH
21622: PPUSH
21623: PPUSH
21624: PPUSH
21625: PPUSH
21626: PPUSH
21627: PPUSH
21628: PPUSH
// if not mc_bases then
21629: LD_EXP 50
21633: NOT
21634: IFFALSE 21638
// exit ;
21636: GO 22096
// for i = 1 to mc_bases do
21638: LD_ADDR_VAR 0 2
21642: PUSH
21643: DOUBLE
21644: LD_INT 1
21646: DEC
21647: ST_TO_ADDR
21648: LD_EXP 50
21652: PUSH
21653: FOR_TO
21654: IFFALSE 22094
// begin tmp := MC_ClassCheckReq ( i ) ;
21656: LD_ADDR_VAR 0 4
21660: PUSH
21661: LD_VAR 0 2
21665: PPUSH
21666: CALL 22101 0 1
21670: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21671: LD_ADDR_EXP 91
21675: PUSH
21676: LD_EXP 91
21680: PPUSH
21681: LD_VAR 0 2
21685: PPUSH
21686: LD_VAR 0 4
21690: PPUSH
21691: CALL_OW 1
21695: ST_TO_ADDR
// if not tmp then
21696: LD_VAR 0 4
21700: NOT
21701: IFFALSE 21705
// continue ;
21703: GO 21653
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21705: LD_ADDR_VAR 0 6
21709: PUSH
21710: LD_EXP 50
21714: PUSH
21715: LD_VAR 0 2
21719: ARRAY
21720: PPUSH
21721: LD_INT 2
21723: PUSH
21724: LD_INT 30
21726: PUSH
21727: LD_INT 4
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: LD_INT 30
21736: PUSH
21737: LD_INT 5
21739: PUSH
21740: EMPTY
21741: LIST
21742: LIST
21743: PUSH
21744: EMPTY
21745: LIST
21746: LIST
21747: LIST
21748: PPUSH
21749: CALL_OW 72
21753: PUSH
21754: LD_EXP 50
21758: PUSH
21759: LD_VAR 0 2
21763: ARRAY
21764: PPUSH
21765: LD_INT 2
21767: PUSH
21768: LD_INT 30
21770: PUSH
21771: LD_INT 0
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: PUSH
21778: LD_INT 30
21780: PUSH
21781: LD_INT 1
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: LIST
21792: PPUSH
21793: CALL_OW 72
21797: PUSH
21798: LD_EXP 50
21802: PUSH
21803: LD_VAR 0 2
21807: ARRAY
21808: PPUSH
21809: LD_INT 30
21811: PUSH
21812: LD_INT 3
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PPUSH
21819: CALL_OW 72
21823: PUSH
21824: LD_EXP 50
21828: PUSH
21829: LD_VAR 0 2
21833: ARRAY
21834: PPUSH
21835: LD_INT 2
21837: PUSH
21838: LD_INT 30
21840: PUSH
21841: LD_INT 6
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: LD_INT 30
21850: PUSH
21851: LD_INT 7
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: PUSH
21858: LD_INT 30
21860: PUSH
21861: LD_INT 8
21863: PUSH
21864: EMPTY
21865: LIST
21866: LIST
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: LIST
21872: LIST
21873: PPUSH
21874: CALL_OW 72
21878: PUSH
21879: EMPTY
21880: LIST
21881: LIST
21882: LIST
21883: LIST
21884: ST_TO_ADDR
// for j = 1 to 4 do
21885: LD_ADDR_VAR 0 3
21889: PUSH
21890: DOUBLE
21891: LD_INT 1
21893: DEC
21894: ST_TO_ADDR
21895: LD_INT 4
21897: PUSH
21898: FOR_TO
21899: IFFALSE 22090
// begin if not tmp [ j ] then
21901: LD_VAR 0 4
21905: PUSH
21906: LD_VAR 0 3
21910: ARRAY
21911: NOT
21912: IFFALSE 21916
// continue ;
21914: GO 21898
// for p in tmp [ j ] do
21916: LD_ADDR_VAR 0 5
21920: PUSH
21921: LD_VAR 0 4
21925: PUSH
21926: LD_VAR 0 3
21930: ARRAY
21931: PUSH
21932: FOR_IN
21933: IFFALSE 22086
// begin if not b [ j ] then
21935: LD_VAR 0 6
21939: PUSH
21940: LD_VAR 0 3
21944: ARRAY
21945: NOT
21946: IFFALSE 21950
// break ;
21948: GO 22086
// e := 0 ;
21950: LD_ADDR_VAR 0 7
21954: PUSH
21955: LD_INT 0
21957: ST_TO_ADDR
// for k in b [ j ] do
21958: LD_ADDR_VAR 0 8
21962: PUSH
21963: LD_VAR 0 6
21967: PUSH
21968: LD_VAR 0 3
21972: ARRAY
21973: PUSH
21974: FOR_IN
21975: IFFALSE 22002
// if IsNotFull ( k ) then
21977: LD_VAR 0 8
21981: PPUSH
21982: CALL 49726 0 1
21986: IFFALSE 22000
// begin e := k ;
21988: LD_ADDR_VAR 0 7
21992: PUSH
21993: LD_VAR 0 8
21997: ST_TO_ADDR
// break ;
21998: GO 22002
// end ;
22000: GO 21974
22002: POP
22003: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22004: LD_VAR 0 7
22008: PUSH
22009: LD_VAR 0 5
22013: PPUSH
22014: LD_VAR 0 7
22018: PPUSH
22019: CALL 82146 0 2
22023: NOT
22024: AND
22025: IFFALSE 22084
// begin if IsInUnit ( p ) then
22027: LD_VAR 0 5
22031: PPUSH
22032: CALL_OW 310
22036: IFFALSE 22047
// ComExitBuilding ( p ) ;
22038: LD_VAR 0 5
22042: PPUSH
22043: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22047: LD_VAR 0 5
22051: PPUSH
22052: LD_VAR 0 7
22056: PPUSH
22057: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22061: LD_VAR 0 5
22065: PPUSH
22066: LD_VAR 0 3
22070: PPUSH
22071: CALL_OW 183
// AddComExitBuilding ( p ) ;
22075: LD_VAR 0 5
22079: PPUSH
22080: CALL_OW 182
// end ; end ;
22084: GO 21932
22086: POP
22087: POP
// end ;
22088: GO 21898
22090: POP
22091: POP
// end ;
22092: GO 21653
22094: POP
22095: POP
// end ;
22096: LD_VAR 0 1
22100: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22101: LD_INT 0
22103: PPUSH
22104: PPUSH
22105: PPUSH
22106: PPUSH
22107: PPUSH
22108: PPUSH
22109: PPUSH
22110: PPUSH
22111: PPUSH
22112: PPUSH
22113: PPUSH
22114: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22115: LD_VAR 0 1
22119: NOT
22120: PUSH
22121: LD_EXP 50
22125: PUSH
22126: LD_VAR 0 1
22130: ARRAY
22131: NOT
22132: OR
22133: PUSH
22134: LD_EXP 50
22138: PUSH
22139: LD_VAR 0 1
22143: ARRAY
22144: PPUSH
22145: LD_INT 2
22147: PUSH
22148: LD_INT 30
22150: PUSH
22151: LD_INT 0
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: LD_INT 1
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: EMPTY
22169: LIST
22170: LIST
22171: LIST
22172: PPUSH
22173: CALL_OW 72
22177: NOT
22178: OR
22179: IFFALSE 22183
// exit ;
22181: GO 25686
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22183: LD_ADDR_VAR 0 4
22187: PUSH
22188: LD_EXP 50
22192: PUSH
22193: LD_VAR 0 1
22197: ARRAY
22198: PPUSH
22199: LD_INT 2
22201: PUSH
22202: LD_INT 25
22204: PUSH
22205: LD_INT 1
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: LD_INT 25
22214: PUSH
22215: LD_INT 2
22217: PUSH
22218: EMPTY
22219: LIST
22220: LIST
22221: PUSH
22222: LD_INT 25
22224: PUSH
22225: LD_INT 3
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: LD_INT 25
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 25
22244: PUSH
22245: LD_INT 5
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: LD_INT 25
22254: PUSH
22255: LD_INT 8
22257: PUSH
22258: EMPTY
22259: LIST
22260: LIST
22261: PUSH
22262: LD_INT 25
22264: PUSH
22265: LD_INT 9
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: LIST
22276: LIST
22277: LIST
22278: LIST
22279: LIST
22280: LIST
22281: PPUSH
22282: CALL_OW 72
22286: ST_TO_ADDR
// if not tmp then
22287: LD_VAR 0 4
22291: NOT
22292: IFFALSE 22296
// exit ;
22294: GO 25686
// for i in tmp do
22296: LD_ADDR_VAR 0 3
22300: PUSH
22301: LD_VAR 0 4
22305: PUSH
22306: FOR_IN
22307: IFFALSE 22338
// if GetTag ( i ) then
22309: LD_VAR 0 3
22313: PPUSH
22314: CALL_OW 110
22318: IFFALSE 22336
// tmp := tmp diff i ;
22320: LD_ADDR_VAR 0 4
22324: PUSH
22325: LD_VAR 0 4
22329: PUSH
22330: LD_VAR 0 3
22334: DIFF
22335: ST_TO_ADDR
22336: GO 22306
22338: POP
22339: POP
// if not tmp then
22340: LD_VAR 0 4
22344: NOT
22345: IFFALSE 22349
// exit ;
22347: GO 25686
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22349: LD_ADDR_VAR 0 5
22353: PUSH
22354: LD_EXP 50
22358: PUSH
22359: LD_VAR 0 1
22363: ARRAY
22364: PPUSH
22365: LD_INT 2
22367: PUSH
22368: LD_INT 25
22370: PUSH
22371: LD_INT 1
22373: PUSH
22374: EMPTY
22375: LIST
22376: LIST
22377: PUSH
22378: LD_INT 25
22380: PUSH
22381: LD_INT 5
22383: PUSH
22384: EMPTY
22385: LIST
22386: LIST
22387: PUSH
22388: LD_INT 25
22390: PUSH
22391: LD_INT 8
22393: PUSH
22394: EMPTY
22395: LIST
22396: LIST
22397: PUSH
22398: LD_INT 25
22400: PUSH
22401: LD_INT 9
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: LIST
22413: LIST
22414: PPUSH
22415: CALL_OW 72
22419: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22420: LD_ADDR_VAR 0 6
22424: PUSH
22425: LD_EXP 50
22429: PUSH
22430: LD_VAR 0 1
22434: ARRAY
22435: PPUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PPUSH
22446: CALL_OW 72
22450: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22451: LD_ADDR_VAR 0 7
22455: PUSH
22456: LD_EXP 50
22460: PUSH
22461: LD_VAR 0 1
22465: ARRAY
22466: PPUSH
22467: LD_INT 25
22469: PUSH
22470: LD_INT 3
22472: PUSH
22473: EMPTY
22474: LIST
22475: LIST
22476: PPUSH
22477: CALL_OW 72
22481: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22482: LD_ADDR_VAR 0 8
22486: PUSH
22487: LD_EXP 50
22491: PUSH
22492: LD_VAR 0 1
22496: ARRAY
22497: PPUSH
22498: LD_INT 25
22500: PUSH
22501: LD_INT 4
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: PUSH
22508: LD_INT 24
22510: PUSH
22511: LD_INT 251
22513: PUSH
22514: EMPTY
22515: LIST
22516: LIST
22517: PUSH
22518: EMPTY
22519: LIST
22520: LIST
22521: PPUSH
22522: CALL_OW 72
22526: ST_TO_ADDR
// if mc_scan [ base ] then
22527: LD_EXP 73
22531: PUSH
22532: LD_VAR 0 1
22536: ARRAY
22537: IFFALSE 22998
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22539: LD_ADDR_EXP 92
22543: PUSH
22544: LD_EXP 92
22548: PPUSH
22549: LD_VAR 0 1
22553: PPUSH
22554: LD_INT 4
22556: PPUSH
22557: CALL_OW 1
22561: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22562: LD_ADDR_VAR 0 12
22566: PUSH
22567: LD_EXP 50
22571: PUSH
22572: LD_VAR 0 1
22576: ARRAY
22577: PPUSH
22578: LD_INT 2
22580: PUSH
22581: LD_INT 30
22583: PUSH
22584: LD_INT 4
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: PUSH
22591: LD_INT 30
22593: PUSH
22594: LD_INT 5
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: LIST
22605: PPUSH
22606: CALL_OW 72
22610: ST_TO_ADDR
// if not b then
22611: LD_VAR 0 12
22615: NOT
22616: IFFALSE 22620
// exit ;
22618: GO 25686
// p := [ ] ;
22620: LD_ADDR_VAR 0 11
22624: PUSH
22625: EMPTY
22626: ST_TO_ADDR
// if sci >= 2 then
22627: LD_VAR 0 8
22631: PUSH
22632: LD_INT 2
22634: GREATEREQUAL
22635: IFFALSE 22666
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22637: LD_ADDR_VAR 0 8
22641: PUSH
22642: LD_VAR 0 8
22646: PUSH
22647: LD_INT 1
22649: ARRAY
22650: PUSH
22651: LD_VAR 0 8
22655: PUSH
22656: LD_INT 2
22658: ARRAY
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: ST_TO_ADDR
22664: GO 22727
// if sci = 1 then
22666: LD_VAR 0 8
22670: PUSH
22671: LD_INT 1
22673: EQUAL
22674: IFFALSE 22695
// sci := [ sci [ 1 ] ] else
22676: LD_ADDR_VAR 0 8
22680: PUSH
22681: LD_VAR 0 8
22685: PUSH
22686: LD_INT 1
22688: ARRAY
22689: PUSH
22690: EMPTY
22691: LIST
22692: ST_TO_ADDR
22693: GO 22727
// if sci = 0 then
22695: LD_VAR 0 8
22699: PUSH
22700: LD_INT 0
22702: EQUAL
22703: IFFALSE 22727
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22705: LD_ADDR_VAR 0 11
22709: PUSH
22710: LD_VAR 0 4
22714: PPUSH
22715: LD_INT 4
22717: PPUSH
22718: CALL 82009 0 2
22722: PUSH
22723: LD_INT 1
22725: ARRAY
22726: ST_TO_ADDR
// if eng > 4 then
22727: LD_VAR 0 6
22731: PUSH
22732: LD_INT 4
22734: GREATER
22735: IFFALSE 22781
// for i = eng downto 4 do
22737: LD_ADDR_VAR 0 3
22741: PUSH
22742: DOUBLE
22743: LD_VAR 0 6
22747: INC
22748: ST_TO_ADDR
22749: LD_INT 4
22751: PUSH
22752: FOR_DOWNTO
22753: IFFALSE 22779
// eng := eng diff eng [ i ] ;
22755: LD_ADDR_VAR 0 6
22759: PUSH
22760: LD_VAR 0 6
22764: PUSH
22765: LD_VAR 0 6
22769: PUSH
22770: LD_VAR 0 3
22774: ARRAY
22775: DIFF
22776: ST_TO_ADDR
22777: GO 22752
22779: POP
22780: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22781: LD_ADDR_VAR 0 4
22785: PUSH
22786: LD_VAR 0 4
22790: PUSH
22791: LD_VAR 0 5
22795: PUSH
22796: LD_VAR 0 6
22800: UNION
22801: PUSH
22802: LD_VAR 0 7
22806: UNION
22807: PUSH
22808: LD_VAR 0 8
22812: UNION
22813: DIFF
22814: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22815: LD_ADDR_VAR 0 13
22819: PUSH
22820: LD_EXP 50
22824: PUSH
22825: LD_VAR 0 1
22829: ARRAY
22830: PPUSH
22831: LD_INT 2
22833: PUSH
22834: LD_INT 30
22836: PUSH
22837: LD_INT 32
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PUSH
22844: LD_INT 30
22846: PUSH
22847: LD_INT 31
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: LIST
22858: PPUSH
22859: CALL_OW 72
22863: PUSH
22864: LD_EXP 50
22868: PUSH
22869: LD_VAR 0 1
22873: ARRAY
22874: PPUSH
22875: LD_INT 2
22877: PUSH
22878: LD_INT 30
22880: PUSH
22881: LD_INT 4
22883: PUSH
22884: EMPTY
22885: LIST
22886: LIST
22887: PUSH
22888: LD_INT 30
22890: PUSH
22891: LD_INT 5
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: LIST
22902: PPUSH
22903: CALL_OW 72
22907: PUSH
22908: LD_INT 6
22910: MUL
22911: PLUS
22912: ST_TO_ADDR
// if bcount < tmp then
22913: LD_VAR 0 13
22917: PUSH
22918: LD_VAR 0 4
22922: LESS
22923: IFFALSE 22969
// for i = tmp downto bcount do
22925: LD_ADDR_VAR 0 3
22929: PUSH
22930: DOUBLE
22931: LD_VAR 0 4
22935: INC
22936: ST_TO_ADDR
22937: LD_VAR 0 13
22941: PUSH
22942: FOR_DOWNTO
22943: IFFALSE 22967
// tmp := Delete ( tmp , tmp ) ;
22945: LD_ADDR_VAR 0 4
22949: PUSH
22950: LD_VAR 0 4
22954: PPUSH
22955: LD_VAR 0 4
22959: PPUSH
22960: CALL_OW 3
22964: ST_TO_ADDR
22965: GO 22942
22967: POP
22968: POP
// result := [ tmp , 0 , 0 , p ] ;
22969: LD_ADDR_VAR 0 2
22973: PUSH
22974: LD_VAR 0 4
22978: PUSH
22979: LD_INT 0
22981: PUSH
22982: LD_INT 0
22984: PUSH
22985: LD_VAR 0 11
22989: PUSH
22990: EMPTY
22991: LIST
22992: LIST
22993: LIST
22994: LIST
22995: ST_TO_ADDR
// exit ;
22996: GO 25686
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22998: LD_EXP 50
23002: PUSH
23003: LD_VAR 0 1
23007: ARRAY
23008: PPUSH
23009: LD_INT 2
23011: PUSH
23012: LD_INT 30
23014: PUSH
23015: LD_INT 6
23017: PUSH
23018: EMPTY
23019: LIST
23020: LIST
23021: PUSH
23022: LD_INT 30
23024: PUSH
23025: LD_INT 7
23027: PUSH
23028: EMPTY
23029: LIST
23030: LIST
23031: PUSH
23032: LD_INT 30
23034: PUSH
23035: LD_INT 8
23037: PUSH
23038: EMPTY
23039: LIST
23040: LIST
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: PPUSH
23048: CALL_OW 72
23052: NOT
23053: PUSH
23054: LD_EXP 50
23058: PUSH
23059: LD_VAR 0 1
23063: ARRAY
23064: PPUSH
23065: LD_INT 30
23067: PUSH
23068: LD_INT 3
23070: PUSH
23071: EMPTY
23072: LIST
23073: LIST
23074: PPUSH
23075: CALL_OW 72
23079: NOT
23080: AND
23081: IFFALSE 23153
// begin if eng = tmp then
23083: LD_VAR 0 6
23087: PUSH
23088: LD_VAR 0 4
23092: EQUAL
23093: IFFALSE 23097
// exit ;
23095: GO 25686
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23097: LD_ADDR_EXP 92
23101: PUSH
23102: LD_EXP 92
23106: PPUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: LD_INT 1
23114: PPUSH
23115: CALL_OW 1
23119: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23120: LD_ADDR_VAR 0 2
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: LD_VAR 0 4
23132: PUSH
23133: LD_VAR 0 6
23137: DIFF
23138: PUSH
23139: LD_INT 0
23141: PUSH
23142: LD_INT 0
23144: PUSH
23145: EMPTY
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: ST_TO_ADDR
// exit ;
23151: GO 25686
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23153: LD_EXP 77
23157: PUSH
23158: LD_EXP 76
23162: PUSH
23163: LD_VAR 0 1
23167: ARRAY
23168: ARRAY
23169: PUSH
23170: LD_EXP 50
23174: PUSH
23175: LD_VAR 0 1
23179: ARRAY
23180: PPUSH
23181: LD_INT 2
23183: PUSH
23184: LD_INT 30
23186: PUSH
23187: LD_INT 6
23189: PUSH
23190: EMPTY
23191: LIST
23192: LIST
23193: PUSH
23194: LD_INT 30
23196: PUSH
23197: LD_INT 7
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 30
23206: PUSH
23207: LD_INT 8
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: LIST
23218: LIST
23219: PPUSH
23220: CALL_OW 72
23224: AND
23225: PUSH
23226: LD_EXP 50
23230: PUSH
23231: LD_VAR 0 1
23235: ARRAY
23236: PPUSH
23237: LD_INT 30
23239: PUSH
23240: LD_INT 3
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PPUSH
23247: CALL_OW 72
23251: NOT
23252: AND
23253: IFFALSE 23467
// begin if sci >= 6 then
23255: LD_VAR 0 8
23259: PUSH
23260: LD_INT 6
23262: GREATEREQUAL
23263: IFFALSE 23267
// exit ;
23265: GO 25686
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23267: LD_ADDR_EXP 92
23271: PUSH
23272: LD_EXP 92
23276: PPUSH
23277: LD_VAR 0 1
23281: PPUSH
23282: LD_INT 2
23284: PPUSH
23285: CALL_OW 1
23289: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23290: LD_ADDR_VAR 0 9
23294: PUSH
23295: LD_VAR 0 4
23299: PUSH
23300: LD_VAR 0 8
23304: DIFF
23305: PPUSH
23306: LD_INT 4
23308: PPUSH
23309: CALL 82009 0 2
23313: ST_TO_ADDR
// p := [ ] ;
23314: LD_ADDR_VAR 0 11
23318: PUSH
23319: EMPTY
23320: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23321: LD_VAR 0 8
23325: PUSH
23326: LD_INT 6
23328: LESS
23329: PUSH
23330: LD_VAR 0 9
23334: PUSH
23335: LD_INT 6
23337: GREATER
23338: AND
23339: IFFALSE 23420
// begin for i = 1 to 6 - sci do
23341: LD_ADDR_VAR 0 3
23345: PUSH
23346: DOUBLE
23347: LD_INT 1
23349: DEC
23350: ST_TO_ADDR
23351: LD_INT 6
23353: PUSH
23354: LD_VAR 0 8
23358: MINUS
23359: PUSH
23360: FOR_TO
23361: IFFALSE 23416
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23363: LD_ADDR_VAR 0 11
23367: PUSH
23368: LD_VAR 0 11
23372: PPUSH
23373: LD_VAR 0 11
23377: PUSH
23378: LD_INT 1
23380: PLUS
23381: PPUSH
23382: LD_VAR 0 9
23386: PUSH
23387: LD_INT 1
23389: ARRAY
23390: PPUSH
23391: CALL_OW 2
23395: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23396: LD_ADDR_VAR 0 9
23400: PUSH
23401: LD_VAR 0 9
23405: PPUSH
23406: LD_INT 1
23408: PPUSH
23409: CALL_OW 3
23413: ST_TO_ADDR
// end ;
23414: GO 23360
23416: POP
23417: POP
// end else
23418: GO 23440
// if sort then
23420: LD_VAR 0 9
23424: IFFALSE 23440
// p := sort [ 1 ] ;
23426: LD_ADDR_VAR 0 11
23430: PUSH
23431: LD_VAR 0 9
23435: PUSH
23436: LD_INT 1
23438: ARRAY
23439: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23440: LD_ADDR_VAR 0 2
23444: PUSH
23445: LD_INT 0
23447: PUSH
23448: LD_INT 0
23450: PUSH
23451: LD_INT 0
23453: PUSH
23454: LD_VAR 0 11
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: LIST
23463: LIST
23464: ST_TO_ADDR
// exit ;
23465: GO 25686
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23467: LD_EXP 77
23471: PUSH
23472: LD_EXP 76
23476: PUSH
23477: LD_VAR 0 1
23481: ARRAY
23482: ARRAY
23483: PUSH
23484: LD_EXP 50
23488: PUSH
23489: LD_VAR 0 1
23493: ARRAY
23494: PPUSH
23495: LD_INT 2
23497: PUSH
23498: LD_INT 30
23500: PUSH
23501: LD_INT 6
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 30
23510: PUSH
23511: LD_INT 7
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: PUSH
23518: LD_INT 30
23520: PUSH
23521: LD_INT 8
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: LIST
23532: LIST
23533: PPUSH
23534: CALL_OW 72
23538: AND
23539: PUSH
23540: LD_EXP 50
23544: PUSH
23545: LD_VAR 0 1
23549: ARRAY
23550: PPUSH
23551: LD_INT 30
23553: PUSH
23554: LD_INT 3
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PPUSH
23561: CALL_OW 72
23565: AND
23566: IFFALSE 24300
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23568: LD_ADDR_EXP 92
23572: PUSH
23573: LD_EXP 92
23577: PPUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: LD_INT 3
23585: PPUSH
23586: CALL_OW 1
23590: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23591: LD_ADDR_VAR 0 2
23595: PUSH
23596: LD_INT 0
23598: PUSH
23599: LD_INT 0
23601: PUSH
23602: LD_INT 0
23604: PUSH
23605: LD_INT 0
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: LIST
23612: LIST
23613: ST_TO_ADDR
// if not eng then
23614: LD_VAR 0 6
23618: NOT
23619: IFFALSE 23682
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23621: LD_ADDR_VAR 0 11
23625: PUSH
23626: LD_VAR 0 4
23630: PPUSH
23631: LD_INT 2
23633: PPUSH
23634: CALL 82009 0 2
23638: PUSH
23639: LD_INT 1
23641: ARRAY
23642: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23643: LD_ADDR_VAR 0 2
23647: PUSH
23648: LD_VAR 0 2
23652: PPUSH
23653: LD_INT 2
23655: PPUSH
23656: LD_VAR 0 11
23660: PPUSH
23661: CALL_OW 1
23665: ST_TO_ADDR
// tmp := tmp diff p ;
23666: LD_ADDR_VAR 0 4
23670: PUSH
23671: LD_VAR 0 4
23675: PUSH
23676: LD_VAR 0 11
23680: DIFF
23681: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23682: LD_VAR 0 4
23686: PUSH
23687: LD_VAR 0 8
23691: PUSH
23692: LD_INT 6
23694: LESS
23695: AND
23696: IFFALSE 23884
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23698: LD_ADDR_VAR 0 9
23702: PUSH
23703: LD_VAR 0 4
23707: PUSH
23708: LD_VAR 0 8
23712: PUSH
23713: LD_VAR 0 7
23717: UNION
23718: DIFF
23719: PPUSH
23720: LD_INT 4
23722: PPUSH
23723: CALL 82009 0 2
23727: ST_TO_ADDR
// p := [ ] ;
23728: LD_ADDR_VAR 0 11
23732: PUSH
23733: EMPTY
23734: ST_TO_ADDR
// if sort then
23735: LD_VAR 0 9
23739: IFFALSE 23855
// for i = 1 to 6 - sci do
23741: LD_ADDR_VAR 0 3
23745: PUSH
23746: DOUBLE
23747: LD_INT 1
23749: DEC
23750: ST_TO_ADDR
23751: LD_INT 6
23753: PUSH
23754: LD_VAR 0 8
23758: MINUS
23759: PUSH
23760: FOR_TO
23761: IFFALSE 23853
// begin if i = sort then
23763: LD_VAR 0 3
23767: PUSH
23768: LD_VAR 0 9
23772: EQUAL
23773: IFFALSE 23777
// break ;
23775: GO 23853
// if GetClass ( i ) = 4 then
23777: LD_VAR 0 3
23781: PPUSH
23782: CALL_OW 257
23786: PUSH
23787: LD_INT 4
23789: EQUAL
23790: IFFALSE 23794
// continue ;
23792: GO 23760
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23794: LD_ADDR_VAR 0 11
23798: PUSH
23799: LD_VAR 0 11
23803: PPUSH
23804: LD_VAR 0 11
23808: PUSH
23809: LD_INT 1
23811: PLUS
23812: PPUSH
23813: LD_VAR 0 9
23817: PUSH
23818: LD_VAR 0 3
23822: ARRAY
23823: PPUSH
23824: CALL_OW 2
23828: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23829: LD_ADDR_VAR 0 4
23833: PUSH
23834: LD_VAR 0 4
23838: PUSH
23839: LD_VAR 0 9
23843: PUSH
23844: LD_VAR 0 3
23848: ARRAY
23849: DIFF
23850: ST_TO_ADDR
// end ;
23851: GO 23760
23853: POP
23854: POP
// if p then
23855: LD_VAR 0 11
23859: IFFALSE 23884
// result := Replace ( result , 4 , p ) ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 2
23870: PPUSH
23871: LD_INT 4
23873: PPUSH
23874: LD_VAR 0 11
23878: PPUSH
23879: CALL_OW 1
23883: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23884: LD_VAR 0 4
23888: PUSH
23889: LD_VAR 0 7
23893: PUSH
23894: LD_INT 6
23896: LESS
23897: AND
23898: IFFALSE 24086
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23900: LD_ADDR_VAR 0 9
23904: PUSH
23905: LD_VAR 0 4
23909: PUSH
23910: LD_VAR 0 8
23914: PUSH
23915: LD_VAR 0 7
23919: UNION
23920: DIFF
23921: PPUSH
23922: LD_INT 3
23924: PPUSH
23925: CALL 82009 0 2
23929: ST_TO_ADDR
// p := [ ] ;
23930: LD_ADDR_VAR 0 11
23934: PUSH
23935: EMPTY
23936: ST_TO_ADDR
// if sort then
23937: LD_VAR 0 9
23941: IFFALSE 24057
// for i = 1 to 6 - mech do
23943: LD_ADDR_VAR 0 3
23947: PUSH
23948: DOUBLE
23949: LD_INT 1
23951: DEC
23952: ST_TO_ADDR
23953: LD_INT 6
23955: PUSH
23956: LD_VAR 0 7
23960: MINUS
23961: PUSH
23962: FOR_TO
23963: IFFALSE 24055
// begin if i = sort then
23965: LD_VAR 0 3
23969: PUSH
23970: LD_VAR 0 9
23974: EQUAL
23975: IFFALSE 23979
// break ;
23977: GO 24055
// if GetClass ( i ) = 3 then
23979: LD_VAR 0 3
23983: PPUSH
23984: CALL_OW 257
23988: PUSH
23989: LD_INT 3
23991: EQUAL
23992: IFFALSE 23996
// continue ;
23994: GO 23962
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_VAR 0 11
24005: PPUSH
24006: LD_VAR 0 11
24010: PUSH
24011: LD_INT 1
24013: PLUS
24014: PPUSH
24015: LD_VAR 0 9
24019: PUSH
24020: LD_VAR 0 3
24024: ARRAY
24025: PPUSH
24026: CALL_OW 2
24030: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24031: LD_ADDR_VAR 0 4
24035: PUSH
24036: LD_VAR 0 4
24040: PUSH
24041: LD_VAR 0 9
24045: PUSH
24046: LD_VAR 0 3
24050: ARRAY
24051: DIFF
24052: ST_TO_ADDR
// end ;
24053: GO 23962
24055: POP
24056: POP
// if p then
24057: LD_VAR 0 11
24061: IFFALSE 24086
// result := Replace ( result , 3 , p ) ;
24063: LD_ADDR_VAR 0 2
24067: PUSH
24068: LD_VAR 0 2
24072: PPUSH
24073: LD_INT 3
24075: PPUSH
24076: LD_VAR 0 11
24080: PPUSH
24081: CALL_OW 1
24085: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24086: LD_VAR 0 4
24090: PUSH
24091: LD_INT 6
24093: GREATER
24094: PUSH
24095: LD_VAR 0 6
24099: PUSH
24100: LD_INT 6
24102: LESS
24103: AND
24104: IFFALSE 24298
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24106: LD_ADDR_VAR 0 9
24110: PUSH
24111: LD_VAR 0 4
24115: PUSH
24116: LD_VAR 0 8
24120: PUSH
24121: LD_VAR 0 7
24125: UNION
24126: PUSH
24127: LD_VAR 0 6
24131: UNION
24132: DIFF
24133: PPUSH
24134: LD_INT 2
24136: PPUSH
24137: CALL 82009 0 2
24141: ST_TO_ADDR
// p := [ ] ;
24142: LD_ADDR_VAR 0 11
24146: PUSH
24147: EMPTY
24148: ST_TO_ADDR
// if sort then
24149: LD_VAR 0 9
24153: IFFALSE 24269
// for i = 1 to 6 - eng do
24155: LD_ADDR_VAR 0 3
24159: PUSH
24160: DOUBLE
24161: LD_INT 1
24163: DEC
24164: ST_TO_ADDR
24165: LD_INT 6
24167: PUSH
24168: LD_VAR 0 6
24172: MINUS
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24267
// begin if i = sort then
24177: LD_VAR 0 3
24181: PUSH
24182: LD_VAR 0 9
24186: EQUAL
24187: IFFALSE 24191
// break ;
24189: GO 24267
// if GetClass ( i ) = 2 then
24191: LD_VAR 0 3
24195: PPUSH
24196: CALL_OW 257
24200: PUSH
24201: LD_INT 2
24203: EQUAL
24204: IFFALSE 24208
// continue ;
24206: GO 24174
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24208: LD_ADDR_VAR 0 11
24212: PUSH
24213: LD_VAR 0 11
24217: PPUSH
24218: LD_VAR 0 11
24222: PUSH
24223: LD_INT 1
24225: PLUS
24226: PPUSH
24227: LD_VAR 0 9
24231: PUSH
24232: LD_VAR 0 3
24236: ARRAY
24237: PPUSH
24238: CALL_OW 2
24242: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24243: LD_ADDR_VAR 0 4
24247: PUSH
24248: LD_VAR 0 4
24252: PUSH
24253: LD_VAR 0 9
24257: PUSH
24258: LD_VAR 0 3
24262: ARRAY
24263: DIFF
24264: ST_TO_ADDR
// end ;
24265: GO 24174
24267: POP
24268: POP
// if p then
24269: LD_VAR 0 11
24273: IFFALSE 24298
// result := Replace ( result , 2 , p ) ;
24275: LD_ADDR_VAR 0 2
24279: PUSH
24280: LD_VAR 0 2
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: LD_VAR 0 11
24292: PPUSH
24293: CALL_OW 1
24297: ST_TO_ADDR
// end ; exit ;
24298: GO 25686
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24300: LD_EXP 77
24304: PUSH
24305: LD_EXP 76
24309: PUSH
24310: LD_VAR 0 1
24314: ARRAY
24315: ARRAY
24316: NOT
24317: PUSH
24318: LD_EXP 50
24322: PUSH
24323: LD_VAR 0 1
24327: ARRAY
24328: PPUSH
24329: LD_INT 30
24331: PUSH
24332: LD_INT 3
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PPUSH
24339: CALL_OW 72
24343: AND
24344: PUSH
24345: LD_EXP 55
24349: PUSH
24350: LD_VAR 0 1
24354: ARRAY
24355: AND
24356: IFFALSE 24964
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24358: LD_ADDR_EXP 92
24362: PUSH
24363: LD_EXP 92
24367: PPUSH
24368: LD_VAR 0 1
24372: PPUSH
24373: LD_INT 5
24375: PPUSH
24376: CALL_OW 1
24380: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24381: LD_ADDR_VAR 0 2
24385: PUSH
24386: LD_INT 0
24388: PUSH
24389: LD_INT 0
24391: PUSH
24392: LD_INT 0
24394: PUSH
24395: LD_INT 0
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: LIST
24402: LIST
24403: ST_TO_ADDR
// if sci > 1 then
24404: LD_VAR 0 8
24408: PUSH
24409: LD_INT 1
24411: GREATER
24412: IFFALSE 24440
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24414: LD_ADDR_VAR 0 4
24418: PUSH
24419: LD_VAR 0 4
24423: PUSH
24424: LD_VAR 0 8
24428: PUSH
24429: LD_VAR 0 8
24433: PUSH
24434: LD_INT 1
24436: ARRAY
24437: DIFF
24438: DIFF
24439: ST_TO_ADDR
// if tmp and not sci then
24440: LD_VAR 0 4
24444: PUSH
24445: LD_VAR 0 8
24449: NOT
24450: AND
24451: IFFALSE 24520
// begin sort := SortBySkill ( tmp , 4 ) ;
24453: LD_ADDR_VAR 0 9
24457: PUSH
24458: LD_VAR 0 4
24462: PPUSH
24463: LD_INT 4
24465: PPUSH
24466: CALL 82009 0 2
24470: ST_TO_ADDR
// if sort then
24471: LD_VAR 0 9
24475: IFFALSE 24491
// p := sort [ 1 ] ;
24477: LD_ADDR_VAR 0 11
24481: PUSH
24482: LD_VAR 0 9
24486: PUSH
24487: LD_INT 1
24489: ARRAY
24490: ST_TO_ADDR
// if p then
24491: LD_VAR 0 11
24495: IFFALSE 24520
// result := Replace ( result , 4 , p ) ;
24497: LD_ADDR_VAR 0 2
24501: PUSH
24502: LD_VAR 0 2
24506: PPUSH
24507: LD_INT 4
24509: PPUSH
24510: LD_VAR 0 11
24514: PPUSH
24515: CALL_OW 1
24519: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24520: LD_ADDR_VAR 0 4
24524: PUSH
24525: LD_VAR 0 4
24529: PUSH
24530: LD_VAR 0 7
24534: DIFF
24535: ST_TO_ADDR
// if tmp and mech < 6 then
24536: LD_VAR 0 4
24540: PUSH
24541: LD_VAR 0 7
24545: PUSH
24546: LD_INT 6
24548: LESS
24549: AND
24550: IFFALSE 24738
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24552: LD_ADDR_VAR 0 9
24556: PUSH
24557: LD_VAR 0 4
24561: PUSH
24562: LD_VAR 0 8
24566: PUSH
24567: LD_VAR 0 7
24571: UNION
24572: DIFF
24573: PPUSH
24574: LD_INT 3
24576: PPUSH
24577: CALL 82009 0 2
24581: ST_TO_ADDR
// p := [ ] ;
24582: LD_ADDR_VAR 0 11
24586: PUSH
24587: EMPTY
24588: ST_TO_ADDR
// if sort then
24589: LD_VAR 0 9
24593: IFFALSE 24709
// for i = 1 to 6 - mech do
24595: LD_ADDR_VAR 0 3
24599: PUSH
24600: DOUBLE
24601: LD_INT 1
24603: DEC
24604: ST_TO_ADDR
24605: LD_INT 6
24607: PUSH
24608: LD_VAR 0 7
24612: MINUS
24613: PUSH
24614: FOR_TO
24615: IFFALSE 24707
// begin if i = sort then
24617: LD_VAR 0 3
24621: PUSH
24622: LD_VAR 0 9
24626: EQUAL
24627: IFFALSE 24631
// break ;
24629: GO 24707
// if GetClass ( i ) = 3 then
24631: LD_VAR 0 3
24635: PPUSH
24636: CALL_OW 257
24640: PUSH
24641: LD_INT 3
24643: EQUAL
24644: IFFALSE 24648
// continue ;
24646: GO 24614
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24648: LD_ADDR_VAR 0 11
24652: PUSH
24653: LD_VAR 0 11
24657: PPUSH
24658: LD_VAR 0 11
24662: PUSH
24663: LD_INT 1
24665: PLUS
24666: PPUSH
24667: LD_VAR 0 9
24671: PUSH
24672: LD_VAR 0 3
24676: ARRAY
24677: PPUSH
24678: CALL_OW 2
24682: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24683: LD_ADDR_VAR 0 4
24687: PUSH
24688: LD_VAR 0 4
24692: PUSH
24693: LD_VAR 0 9
24697: PUSH
24698: LD_VAR 0 3
24702: ARRAY
24703: DIFF
24704: ST_TO_ADDR
// end ;
24705: GO 24614
24707: POP
24708: POP
// if p then
24709: LD_VAR 0 11
24713: IFFALSE 24738
// result := Replace ( result , 3 , p ) ;
24715: LD_ADDR_VAR 0 2
24719: PUSH
24720: LD_VAR 0 2
24724: PPUSH
24725: LD_INT 3
24727: PPUSH
24728: LD_VAR 0 11
24732: PPUSH
24733: CALL_OW 1
24737: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24738: LD_ADDR_VAR 0 4
24742: PUSH
24743: LD_VAR 0 4
24747: PUSH
24748: LD_VAR 0 6
24752: DIFF
24753: ST_TO_ADDR
// if tmp and eng < 6 then
24754: LD_VAR 0 4
24758: PUSH
24759: LD_VAR 0 6
24763: PUSH
24764: LD_INT 6
24766: LESS
24767: AND
24768: IFFALSE 24962
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24770: LD_ADDR_VAR 0 9
24774: PUSH
24775: LD_VAR 0 4
24779: PUSH
24780: LD_VAR 0 8
24784: PUSH
24785: LD_VAR 0 7
24789: UNION
24790: PUSH
24791: LD_VAR 0 6
24795: UNION
24796: DIFF
24797: PPUSH
24798: LD_INT 2
24800: PPUSH
24801: CALL 82009 0 2
24805: ST_TO_ADDR
// p := [ ] ;
24806: LD_ADDR_VAR 0 11
24810: PUSH
24811: EMPTY
24812: ST_TO_ADDR
// if sort then
24813: LD_VAR 0 9
24817: IFFALSE 24933
// for i = 1 to 6 - eng do
24819: LD_ADDR_VAR 0 3
24823: PUSH
24824: DOUBLE
24825: LD_INT 1
24827: DEC
24828: ST_TO_ADDR
24829: LD_INT 6
24831: PUSH
24832: LD_VAR 0 6
24836: MINUS
24837: PUSH
24838: FOR_TO
24839: IFFALSE 24931
// begin if i = sort then
24841: LD_VAR 0 3
24845: PUSH
24846: LD_VAR 0 9
24850: EQUAL
24851: IFFALSE 24855
// break ;
24853: GO 24931
// if GetClass ( i ) = 2 then
24855: LD_VAR 0 3
24859: PPUSH
24860: CALL_OW 257
24864: PUSH
24865: LD_INT 2
24867: EQUAL
24868: IFFALSE 24872
// continue ;
24870: GO 24838
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24872: LD_ADDR_VAR 0 11
24876: PUSH
24877: LD_VAR 0 11
24881: PPUSH
24882: LD_VAR 0 11
24886: PUSH
24887: LD_INT 1
24889: PLUS
24890: PPUSH
24891: LD_VAR 0 9
24895: PUSH
24896: LD_VAR 0 3
24900: ARRAY
24901: PPUSH
24902: CALL_OW 2
24906: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24907: LD_ADDR_VAR 0 4
24911: PUSH
24912: LD_VAR 0 4
24916: PUSH
24917: LD_VAR 0 9
24921: PUSH
24922: LD_VAR 0 3
24926: ARRAY
24927: DIFF
24928: ST_TO_ADDR
// end ;
24929: GO 24838
24931: POP
24932: POP
// if p then
24933: LD_VAR 0 11
24937: IFFALSE 24962
// result := Replace ( result , 2 , p ) ;
24939: LD_ADDR_VAR 0 2
24943: PUSH
24944: LD_VAR 0 2
24948: PPUSH
24949: LD_INT 2
24951: PPUSH
24952: LD_VAR 0 11
24956: PPUSH
24957: CALL_OW 1
24961: ST_TO_ADDR
// end ; exit ;
24962: GO 25686
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24964: LD_EXP 77
24968: PUSH
24969: LD_EXP 76
24973: PUSH
24974: LD_VAR 0 1
24978: ARRAY
24979: ARRAY
24980: NOT
24981: PUSH
24982: LD_EXP 50
24986: PUSH
24987: LD_VAR 0 1
24991: ARRAY
24992: PPUSH
24993: LD_INT 30
24995: PUSH
24996: LD_INT 3
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PPUSH
25003: CALL_OW 72
25007: AND
25008: PUSH
25009: LD_EXP 55
25013: PUSH
25014: LD_VAR 0 1
25018: ARRAY
25019: NOT
25020: AND
25021: IFFALSE 25686
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25023: LD_ADDR_EXP 92
25027: PUSH
25028: LD_EXP 92
25032: PPUSH
25033: LD_VAR 0 1
25037: PPUSH
25038: LD_INT 6
25040: PPUSH
25041: CALL_OW 1
25045: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25046: LD_ADDR_VAR 0 2
25050: PUSH
25051: LD_INT 0
25053: PUSH
25054: LD_INT 0
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: LD_INT 0
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: LIST
25067: LIST
25068: ST_TO_ADDR
// if sci >= 1 then
25069: LD_VAR 0 8
25073: PUSH
25074: LD_INT 1
25076: GREATEREQUAL
25077: IFFALSE 25099
// tmp := tmp diff sci [ 1 ] ;
25079: LD_ADDR_VAR 0 4
25083: PUSH
25084: LD_VAR 0 4
25088: PUSH
25089: LD_VAR 0 8
25093: PUSH
25094: LD_INT 1
25096: ARRAY
25097: DIFF
25098: ST_TO_ADDR
// if tmp and not sci then
25099: LD_VAR 0 4
25103: PUSH
25104: LD_VAR 0 8
25108: NOT
25109: AND
25110: IFFALSE 25179
// begin sort := SortBySkill ( tmp , 4 ) ;
25112: LD_ADDR_VAR 0 9
25116: PUSH
25117: LD_VAR 0 4
25121: PPUSH
25122: LD_INT 4
25124: PPUSH
25125: CALL 82009 0 2
25129: ST_TO_ADDR
// if sort then
25130: LD_VAR 0 9
25134: IFFALSE 25150
// p := sort [ 1 ] ;
25136: LD_ADDR_VAR 0 11
25140: PUSH
25141: LD_VAR 0 9
25145: PUSH
25146: LD_INT 1
25148: ARRAY
25149: ST_TO_ADDR
// if p then
25150: LD_VAR 0 11
25154: IFFALSE 25179
// result := Replace ( result , 4 , p ) ;
25156: LD_ADDR_VAR 0 2
25160: PUSH
25161: LD_VAR 0 2
25165: PPUSH
25166: LD_INT 4
25168: PPUSH
25169: LD_VAR 0 11
25173: PPUSH
25174: CALL_OW 1
25178: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25179: LD_ADDR_VAR 0 4
25183: PUSH
25184: LD_VAR 0 4
25188: PUSH
25189: LD_VAR 0 7
25193: DIFF
25194: ST_TO_ADDR
// if tmp and mech < 6 then
25195: LD_VAR 0 4
25199: PUSH
25200: LD_VAR 0 7
25204: PUSH
25205: LD_INT 6
25207: LESS
25208: AND
25209: IFFALSE 25391
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25211: LD_ADDR_VAR 0 9
25215: PUSH
25216: LD_VAR 0 4
25220: PUSH
25221: LD_VAR 0 7
25225: DIFF
25226: PPUSH
25227: LD_INT 3
25229: PPUSH
25230: CALL 82009 0 2
25234: ST_TO_ADDR
// p := [ ] ;
25235: LD_ADDR_VAR 0 11
25239: PUSH
25240: EMPTY
25241: ST_TO_ADDR
// if sort then
25242: LD_VAR 0 9
25246: IFFALSE 25362
// for i = 1 to 6 - mech do
25248: LD_ADDR_VAR 0 3
25252: PUSH
25253: DOUBLE
25254: LD_INT 1
25256: DEC
25257: ST_TO_ADDR
25258: LD_INT 6
25260: PUSH
25261: LD_VAR 0 7
25265: MINUS
25266: PUSH
25267: FOR_TO
25268: IFFALSE 25360
// begin if i = sort then
25270: LD_VAR 0 3
25274: PUSH
25275: LD_VAR 0 9
25279: EQUAL
25280: IFFALSE 25284
// break ;
25282: GO 25360
// if GetClass ( i ) = 3 then
25284: LD_VAR 0 3
25288: PPUSH
25289: CALL_OW 257
25293: PUSH
25294: LD_INT 3
25296: EQUAL
25297: IFFALSE 25301
// continue ;
25299: GO 25267
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25301: LD_ADDR_VAR 0 11
25305: PUSH
25306: LD_VAR 0 11
25310: PPUSH
25311: LD_VAR 0 11
25315: PUSH
25316: LD_INT 1
25318: PLUS
25319: PPUSH
25320: LD_VAR 0 9
25324: PUSH
25325: LD_VAR 0 3
25329: ARRAY
25330: PPUSH
25331: CALL_OW 2
25335: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25336: LD_ADDR_VAR 0 4
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_VAR 0 9
25350: PUSH
25351: LD_VAR 0 3
25355: ARRAY
25356: DIFF
25357: ST_TO_ADDR
// end ;
25358: GO 25267
25360: POP
25361: POP
// if p then
25362: LD_VAR 0 11
25366: IFFALSE 25391
// result := Replace ( result , 3 , p ) ;
25368: LD_ADDR_VAR 0 2
25372: PUSH
25373: LD_VAR 0 2
25377: PPUSH
25378: LD_INT 3
25380: PPUSH
25381: LD_VAR 0 11
25385: PPUSH
25386: CALL_OW 1
25390: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25391: LD_ADDR_VAR 0 4
25395: PUSH
25396: LD_VAR 0 4
25400: PUSH
25401: LD_VAR 0 6
25405: DIFF
25406: ST_TO_ADDR
// if tmp and eng < 4 then
25407: LD_VAR 0 4
25411: PUSH
25412: LD_VAR 0 6
25416: PUSH
25417: LD_INT 4
25419: LESS
25420: AND
25421: IFFALSE 25611
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25423: LD_ADDR_VAR 0 9
25427: PUSH
25428: LD_VAR 0 4
25432: PUSH
25433: LD_VAR 0 7
25437: PUSH
25438: LD_VAR 0 6
25442: UNION
25443: DIFF
25444: PPUSH
25445: LD_INT 2
25447: PPUSH
25448: CALL 82009 0 2
25452: ST_TO_ADDR
// p := [ ] ;
25453: LD_ADDR_VAR 0 11
25457: PUSH
25458: EMPTY
25459: ST_TO_ADDR
// if sort then
25460: LD_VAR 0 9
25464: IFFALSE 25580
// for i = 1 to 4 - eng do
25466: LD_ADDR_VAR 0 3
25470: PUSH
25471: DOUBLE
25472: LD_INT 1
25474: DEC
25475: ST_TO_ADDR
25476: LD_INT 4
25478: PUSH
25479: LD_VAR 0 6
25483: MINUS
25484: PUSH
25485: FOR_TO
25486: IFFALSE 25578
// begin if i = sort then
25488: LD_VAR 0 3
25492: PUSH
25493: LD_VAR 0 9
25497: EQUAL
25498: IFFALSE 25502
// break ;
25500: GO 25578
// if GetClass ( i ) = 2 then
25502: LD_VAR 0 3
25506: PPUSH
25507: CALL_OW 257
25511: PUSH
25512: LD_INT 2
25514: EQUAL
25515: IFFALSE 25519
// continue ;
25517: GO 25485
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25519: LD_ADDR_VAR 0 11
25523: PUSH
25524: LD_VAR 0 11
25528: PPUSH
25529: LD_VAR 0 11
25533: PUSH
25534: LD_INT 1
25536: PLUS
25537: PPUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_VAR 0 3
25547: ARRAY
25548: PPUSH
25549: CALL_OW 2
25553: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25554: LD_ADDR_VAR 0 4
25558: PUSH
25559: LD_VAR 0 4
25563: PUSH
25564: LD_VAR 0 9
25568: PUSH
25569: LD_VAR 0 3
25573: ARRAY
25574: DIFF
25575: ST_TO_ADDR
// end ;
25576: GO 25485
25578: POP
25579: POP
// if p then
25580: LD_VAR 0 11
25584: IFFALSE 25609
// result := Replace ( result , 2 , p ) ;
25586: LD_ADDR_VAR 0 2
25590: PUSH
25591: LD_VAR 0 2
25595: PPUSH
25596: LD_INT 2
25598: PPUSH
25599: LD_VAR 0 11
25603: PPUSH
25604: CALL_OW 1
25608: ST_TO_ADDR
// end else
25609: GO 25655
// for i = eng downto 5 do
25611: LD_ADDR_VAR 0 3
25615: PUSH
25616: DOUBLE
25617: LD_VAR 0 6
25621: INC
25622: ST_TO_ADDR
25623: LD_INT 5
25625: PUSH
25626: FOR_DOWNTO
25627: IFFALSE 25653
// tmp := tmp union eng [ i ] ;
25629: LD_ADDR_VAR 0 4
25633: PUSH
25634: LD_VAR 0 4
25638: PUSH
25639: LD_VAR 0 6
25643: PUSH
25644: LD_VAR 0 3
25648: ARRAY
25649: UNION
25650: ST_TO_ADDR
25651: GO 25626
25653: POP
25654: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25655: LD_ADDR_VAR 0 2
25659: PUSH
25660: LD_VAR 0 2
25664: PPUSH
25665: LD_INT 1
25667: PPUSH
25668: LD_VAR 0 4
25672: PUSH
25673: LD_VAR 0 5
25677: DIFF
25678: PPUSH
25679: CALL_OW 1
25683: ST_TO_ADDR
// exit ;
25684: GO 25686
// end ; end ;
25686: LD_VAR 0 2
25690: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25691: LD_INT 0
25693: PPUSH
25694: PPUSH
25695: PPUSH
// if not mc_bases then
25696: LD_EXP 50
25700: NOT
25701: IFFALSE 25705
// exit ;
25703: GO 25811
// for i = 1 to mc_bases do
25705: LD_ADDR_VAR 0 2
25709: PUSH
25710: DOUBLE
25711: LD_INT 1
25713: DEC
25714: ST_TO_ADDR
25715: LD_EXP 50
25719: PUSH
25720: FOR_TO
25721: IFFALSE 25802
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25723: LD_ADDR_VAR 0 3
25727: PUSH
25728: LD_EXP 50
25732: PUSH
25733: LD_VAR 0 2
25737: ARRAY
25738: PPUSH
25739: LD_INT 21
25741: PUSH
25742: LD_INT 3
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_INT 3
25751: PUSH
25752: LD_INT 24
25754: PUSH
25755: LD_INT 1000
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 72
25774: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25775: LD_ADDR_EXP 51
25779: PUSH
25780: LD_EXP 51
25784: PPUSH
25785: LD_VAR 0 2
25789: PPUSH
25790: LD_VAR 0 3
25794: PPUSH
25795: CALL_OW 1
25799: ST_TO_ADDR
// end ;
25800: GO 25720
25802: POP
25803: POP
// RaiseSailEvent ( 101 ) ;
25804: LD_INT 101
25806: PPUSH
25807: CALL_OW 427
// end ;
25811: LD_VAR 0 1
25815: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25816: LD_INT 0
25818: PPUSH
25819: PPUSH
25820: PPUSH
25821: PPUSH
25822: PPUSH
25823: PPUSH
25824: PPUSH
// if not mc_bases then
25825: LD_EXP 50
25829: NOT
25830: IFFALSE 25834
// exit ;
25832: GO 26396
// for i = 1 to mc_bases do
25834: LD_ADDR_VAR 0 2
25838: PUSH
25839: DOUBLE
25840: LD_INT 1
25842: DEC
25843: ST_TO_ADDR
25844: LD_EXP 50
25848: PUSH
25849: FOR_TO
25850: IFFALSE 26387
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25852: LD_ADDR_VAR 0 5
25856: PUSH
25857: LD_EXP 50
25861: PUSH
25862: LD_VAR 0 2
25866: ARRAY
25867: PUSH
25868: LD_EXP 79
25872: PUSH
25873: LD_VAR 0 2
25877: ARRAY
25878: UNION
25879: PPUSH
25880: LD_INT 21
25882: PUSH
25883: LD_INT 1
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 1
25892: PUSH
25893: LD_INT 3
25895: PUSH
25896: LD_INT 54
25898: PUSH
25899: EMPTY
25900: LIST
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: LD_INT 24
25911: PUSH
25912: LD_INT 800
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PPUSH
25932: CALL_OW 72
25936: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25937: LD_ADDR_VAR 0 6
25941: PUSH
25942: LD_EXP 50
25946: PUSH
25947: LD_VAR 0 2
25951: ARRAY
25952: PPUSH
25953: LD_INT 21
25955: PUSH
25956: LD_INT 1
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 1
25965: PUSH
25966: LD_INT 3
25968: PUSH
25969: LD_INT 54
25971: PUSH
25972: EMPTY
25973: LIST
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: PUSH
25979: LD_INT 3
25981: PUSH
25982: LD_INT 24
25984: PUSH
25985: LD_INT 250
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: LIST
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PPUSH
26005: CALL_OW 72
26009: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26010: LD_ADDR_VAR 0 7
26014: PUSH
26015: LD_VAR 0 5
26019: PUSH
26020: LD_VAR 0 6
26024: DIFF
26025: ST_TO_ADDR
// if not need_heal_1 then
26026: LD_VAR 0 6
26030: NOT
26031: IFFALSE 26064
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26033: LD_ADDR_EXP 53
26037: PUSH
26038: LD_EXP 53
26042: PPUSH
26043: LD_VAR 0 2
26047: PUSH
26048: LD_INT 1
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PPUSH
26055: EMPTY
26056: PPUSH
26057: CALL 52460 0 3
26061: ST_TO_ADDR
26062: GO 26134
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26064: LD_ADDR_EXP 53
26068: PUSH
26069: LD_EXP 53
26073: PPUSH
26074: LD_VAR 0 2
26078: PUSH
26079: LD_INT 1
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PPUSH
26086: LD_EXP 53
26090: PUSH
26091: LD_VAR 0 2
26095: ARRAY
26096: PUSH
26097: LD_INT 1
26099: ARRAY
26100: PPUSH
26101: LD_INT 3
26103: PUSH
26104: LD_INT 24
26106: PUSH
26107: LD_INT 1000
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PPUSH
26118: CALL_OW 72
26122: PUSH
26123: LD_VAR 0 6
26127: UNION
26128: PPUSH
26129: CALL 52460 0 3
26133: ST_TO_ADDR
// if not need_heal_2 then
26134: LD_VAR 0 7
26138: NOT
26139: IFFALSE 26172
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26141: LD_ADDR_EXP 53
26145: PUSH
26146: LD_EXP 53
26150: PPUSH
26151: LD_VAR 0 2
26155: PUSH
26156: LD_INT 2
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PPUSH
26163: EMPTY
26164: PPUSH
26165: CALL 52460 0 3
26169: ST_TO_ADDR
26170: GO 26204
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26172: LD_ADDR_EXP 53
26176: PUSH
26177: LD_EXP 53
26181: PPUSH
26182: LD_VAR 0 2
26186: PUSH
26187: LD_INT 2
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PPUSH
26194: LD_VAR 0 7
26198: PPUSH
26199: CALL 52460 0 3
26203: ST_TO_ADDR
// if need_heal_2 then
26204: LD_VAR 0 7
26208: IFFALSE 26369
// for j in need_heal_2 do
26210: LD_ADDR_VAR 0 3
26214: PUSH
26215: LD_VAR 0 7
26219: PUSH
26220: FOR_IN
26221: IFFALSE 26367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26223: LD_ADDR_VAR 0 5
26227: PUSH
26228: LD_EXP 50
26232: PUSH
26233: LD_VAR 0 2
26237: ARRAY
26238: PPUSH
26239: LD_INT 2
26241: PUSH
26242: LD_INT 30
26244: PUSH
26245: LD_INT 6
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 30
26254: PUSH
26255: LD_INT 7
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 30
26264: PUSH
26265: LD_INT 8
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 30
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 30
26284: PUSH
26285: LD_INT 1
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: PPUSH
26300: CALL_OW 72
26304: ST_TO_ADDR
// if tmp then
26305: LD_VAR 0 5
26309: IFFALSE 26365
// begin k := NearestUnitToUnit ( tmp , j ) ;
26311: LD_ADDR_VAR 0 4
26315: PUSH
26316: LD_VAR 0 5
26320: PPUSH
26321: LD_VAR 0 3
26325: PPUSH
26326: CALL_OW 74
26330: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26331: LD_VAR 0 3
26335: PPUSH
26336: LD_VAR 0 4
26340: PPUSH
26341: CALL_OW 296
26345: PUSH
26346: LD_INT 5
26348: GREATER
26349: IFFALSE 26365
// ComMoveToNearbyEntrance ( j , k ) ;
26351: LD_VAR 0 3
26355: PPUSH
26356: LD_VAR 0 4
26360: PPUSH
26361: CALL 84326 0 2
// end ; end ;
26365: GO 26220
26367: POP
26368: POP
// if not need_heal_1 and not need_heal_2 then
26369: LD_VAR 0 6
26373: NOT
26374: PUSH
26375: LD_VAR 0 7
26379: NOT
26380: AND
26381: IFFALSE 26385
// continue ;
26383: GO 25849
// end ;
26385: GO 25849
26387: POP
26388: POP
// RaiseSailEvent ( 102 ) ;
26389: LD_INT 102
26391: PPUSH
26392: CALL_OW 427
// end ;
26396: LD_VAR 0 1
26400: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26401: LD_INT 0
26403: PPUSH
26404: PPUSH
26405: PPUSH
26406: PPUSH
26407: PPUSH
26408: PPUSH
26409: PPUSH
26410: PPUSH
// if not mc_bases then
26411: LD_EXP 50
26415: NOT
26416: IFFALSE 26420
// exit ;
26418: GO 27281
// for i = 1 to mc_bases do
26420: LD_ADDR_VAR 0 2
26424: PUSH
26425: DOUBLE
26426: LD_INT 1
26428: DEC
26429: ST_TO_ADDR
26430: LD_EXP 50
26434: PUSH
26435: FOR_TO
26436: IFFALSE 27279
// begin if not mc_building_need_repair [ i ] then
26438: LD_EXP 51
26442: PUSH
26443: LD_VAR 0 2
26447: ARRAY
26448: NOT
26449: IFFALSE 26636
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26451: LD_ADDR_VAR 0 6
26455: PUSH
26456: LD_EXP 69
26460: PUSH
26461: LD_VAR 0 2
26465: ARRAY
26466: PPUSH
26467: LD_INT 3
26469: PUSH
26470: LD_INT 24
26472: PUSH
26473: LD_INT 1000
26475: PUSH
26476: EMPTY
26477: LIST
26478: LIST
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: PUSH
26484: LD_INT 2
26486: PUSH
26487: LD_INT 34
26489: PUSH
26490: LD_INT 13
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PUSH
26497: LD_INT 34
26499: PUSH
26500: LD_INT 52
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_INT 34
26509: PUSH
26510: LD_EXP 99
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: LIST
26523: LIST
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PPUSH
26529: CALL_OW 72
26533: ST_TO_ADDR
// if cranes then
26534: LD_VAR 0 6
26538: IFFALSE 26600
// for j in cranes do
26540: LD_ADDR_VAR 0 3
26544: PUSH
26545: LD_VAR 0 6
26549: PUSH
26550: FOR_IN
26551: IFFALSE 26598
// if not IsInArea ( j , mc_parking [ i ] ) then
26553: LD_VAR 0 3
26557: PPUSH
26558: LD_EXP 74
26562: PUSH
26563: LD_VAR 0 2
26567: ARRAY
26568: PPUSH
26569: CALL_OW 308
26573: NOT
26574: IFFALSE 26596
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26576: LD_VAR 0 3
26580: PPUSH
26581: LD_EXP 74
26585: PUSH
26586: LD_VAR 0 2
26590: ARRAY
26591: PPUSH
26592: CALL_OW 113
26596: GO 26550
26598: POP
26599: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26600: LD_ADDR_EXP 52
26604: PUSH
26605: LD_EXP 52
26609: PPUSH
26610: LD_VAR 0 2
26614: PPUSH
26615: EMPTY
26616: PPUSH
26617: CALL_OW 1
26621: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26622: LD_VAR 0 2
26626: PPUSH
26627: LD_INT 101
26629: PPUSH
26630: CALL 21524 0 2
// continue ;
26634: GO 26435
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26636: LD_ADDR_EXP 56
26640: PUSH
26641: LD_EXP 56
26645: PPUSH
26646: LD_VAR 0 2
26650: PPUSH
26651: EMPTY
26652: PPUSH
26653: CALL_OW 1
26657: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26658: LD_VAR 0 2
26662: PPUSH
26663: LD_INT 103
26665: PPUSH
26666: CALL 21524 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
26670: LD_ADDR_VAR 0 5
26674: PUSH
26675: LD_EXP 50
26679: PUSH
26680: LD_VAR 0 2
26684: ARRAY
26685: PUSH
26686: LD_EXP 79
26690: PUSH
26691: LD_VAR 0 2
26695: ARRAY
26696: UNION
26697: PPUSH
26698: LD_INT 2
26700: PUSH
26701: LD_INT 25
26703: PUSH
26704: LD_INT 2
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 25
26713: PUSH
26714: LD_INT 16
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: LIST
26725: PUSH
26726: EMPTY
26727: LIST
26728: PPUSH
26729: CALL_OW 72
26733: PUSH
26734: LD_EXP 53
26738: PUSH
26739: LD_VAR 0 2
26743: ARRAY
26744: PUSH
26745: LD_INT 1
26747: ARRAY
26748: PUSH
26749: LD_EXP 53
26753: PUSH
26754: LD_VAR 0 2
26758: ARRAY
26759: PUSH
26760: LD_INT 2
26762: ARRAY
26763: UNION
26764: DIFF
26765: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
26766: LD_ADDR_VAR 0 6
26770: PUSH
26771: LD_EXP 69
26775: PUSH
26776: LD_VAR 0 2
26780: ARRAY
26781: PPUSH
26782: LD_INT 2
26784: PUSH
26785: LD_INT 34
26787: PUSH
26788: LD_INT 13
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: PUSH
26795: LD_INT 34
26797: PUSH
26798: LD_INT 52
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 34
26807: PUSH
26808: LD_EXP 99
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: PPUSH
26823: CALL_OW 72
26827: ST_TO_ADDR
// if cranes then
26828: LD_VAR 0 6
26832: IFFALSE 26968
// begin for j in cranes do
26834: LD_ADDR_VAR 0 3
26838: PUSH
26839: LD_VAR 0 6
26843: PUSH
26844: FOR_IN
26845: IFFALSE 26966
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
26847: LD_VAR 0 3
26851: PPUSH
26852: CALL_OW 256
26856: PUSH
26857: LD_INT 1000
26859: EQUAL
26860: PUSH
26861: LD_VAR 0 3
26865: PPUSH
26866: CALL_OW 314
26870: NOT
26871: AND
26872: IFFALSE 26906
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26874: LD_VAR 0 3
26878: PPUSH
26879: LD_EXP 51
26883: PUSH
26884: LD_VAR 0 2
26888: ARRAY
26889: PPUSH
26890: LD_VAR 0 3
26894: PPUSH
26895: CALL_OW 74
26899: PPUSH
26900: CALL_OW 130
26904: GO 26964
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26906: LD_VAR 0 3
26910: PPUSH
26911: CALL_OW 256
26915: PUSH
26916: LD_INT 500
26918: LESS
26919: PUSH
26920: LD_VAR 0 3
26924: PPUSH
26925: LD_EXP 74
26929: PUSH
26930: LD_VAR 0 2
26934: ARRAY
26935: PPUSH
26936: CALL_OW 308
26940: NOT
26941: AND
26942: IFFALSE 26964
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26944: LD_VAR 0 3
26948: PPUSH
26949: LD_EXP 74
26953: PUSH
26954: LD_VAR 0 2
26958: ARRAY
26959: PPUSH
26960: CALL_OW 113
// end ;
26964: GO 26844
26966: POP
26967: POP
// end ; if tmp > 3 then
26968: LD_VAR 0 5
26972: PUSH
26973: LD_INT 3
26975: GREATER
26976: IFFALSE 26996
// tmp := ShrinkArray ( tmp , 4 ) ;
26978: LD_ADDR_VAR 0 5
26982: PUSH
26983: LD_VAR 0 5
26987: PPUSH
26988: LD_INT 4
26990: PPUSH
26991: CALL 83818 0 2
26995: ST_TO_ADDR
// if not tmp then
26996: LD_VAR 0 5
27000: NOT
27001: IFFALSE 27005
// continue ;
27003: GO 26435
// for j in tmp do
27005: LD_ADDR_VAR 0 3
27009: PUSH
27010: LD_VAR 0 5
27014: PUSH
27015: FOR_IN
27016: IFFALSE 27275
// begin if IsInUnit ( j ) then
27018: LD_VAR 0 3
27022: PPUSH
27023: CALL_OW 310
27027: IFFALSE 27038
// ComExitBuilding ( j ) ;
27029: LD_VAR 0 3
27033: PPUSH
27034: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27038: LD_VAR 0 3
27042: PUSH
27043: LD_EXP 52
27047: PUSH
27048: LD_VAR 0 2
27052: ARRAY
27053: IN
27054: NOT
27055: IFFALSE 27113
// begin SetTag ( j , 101 ) ;
27057: LD_VAR 0 3
27061: PPUSH
27062: LD_INT 101
27064: PPUSH
27065: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27069: LD_ADDR_EXP 52
27073: PUSH
27074: LD_EXP 52
27078: PPUSH
27079: LD_VAR 0 2
27083: PUSH
27084: LD_EXP 52
27088: PUSH
27089: LD_VAR 0 2
27093: ARRAY
27094: PUSH
27095: LD_INT 1
27097: PLUS
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PPUSH
27103: LD_VAR 0 3
27107: PPUSH
27108: CALL 52460 0 3
27112: ST_TO_ADDR
// end ; wait ( 1 ) ;
27113: LD_INT 1
27115: PPUSH
27116: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27120: LD_ADDR_VAR 0 7
27124: PUSH
27125: LD_EXP 51
27129: PUSH
27130: LD_VAR 0 2
27134: ARRAY
27135: ST_TO_ADDR
// if mc_scan [ i ] then
27136: LD_EXP 73
27140: PUSH
27141: LD_VAR 0 2
27145: ARRAY
27146: IFFALSE 27208
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27148: LD_ADDR_VAR 0 7
27152: PUSH
27153: LD_EXP 51
27157: PUSH
27158: LD_VAR 0 2
27162: ARRAY
27163: PPUSH
27164: LD_INT 3
27166: PUSH
27167: LD_INT 30
27169: PUSH
27170: LD_INT 32
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: LD_INT 30
27179: PUSH
27180: LD_INT 33
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 30
27189: PUSH
27190: LD_INT 31
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: LIST
27201: LIST
27202: PPUSH
27203: CALL_OW 72
27207: ST_TO_ADDR
// if not to_repair_tmp then
27208: LD_VAR 0 7
27212: NOT
27213: IFFALSE 27217
// continue ;
27215: GO 27015
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27217: LD_ADDR_VAR 0 8
27221: PUSH
27222: LD_VAR 0 7
27226: PPUSH
27227: LD_VAR 0 3
27231: PPUSH
27232: CALL_OW 74
27236: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27237: LD_VAR 0 8
27241: PPUSH
27242: LD_INT 16
27244: PPUSH
27245: CALL 55053 0 2
27249: PUSH
27250: LD_INT 4
27252: ARRAY
27253: PUSH
27254: LD_INT 10
27256: LESS
27257: IFFALSE 27273
// ComRepairBuilding ( j , to_repair ) ;
27259: LD_VAR 0 3
27263: PPUSH
27264: LD_VAR 0 8
27268: PPUSH
27269: CALL_OW 130
// end ;
27273: GO 27015
27275: POP
27276: POP
// end ;
27277: GO 26435
27279: POP
27280: POP
// end ;
27281: LD_VAR 0 1
27285: RET
// export function MC_Heal ; var i , j , tmp ; begin
27286: LD_INT 0
27288: PPUSH
27289: PPUSH
27290: PPUSH
27291: PPUSH
// if not mc_bases then
27292: LD_EXP 50
27296: NOT
27297: IFFALSE 27301
// exit ;
27299: GO 27703
// for i = 1 to mc_bases do
27301: LD_ADDR_VAR 0 2
27305: PUSH
27306: DOUBLE
27307: LD_INT 1
27309: DEC
27310: ST_TO_ADDR
27311: LD_EXP 50
27315: PUSH
27316: FOR_TO
27317: IFFALSE 27701
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27319: LD_EXP 53
27323: PUSH
27324: LD_VAR 0 2
27328: ARRAY
27329: PUSH
27330: LD_INT 1
27332: ARRAY
27333: NOT
27334: PUSH
27335: LD_EXP 53
27339: PUSH
27340: LD_VAR 0 2
27344: ARRAY
27345: PUSH
27346: LD_INT 2
27348: ARRAY
27349: NOT
27350: AND
27351: IFFALSE 27389
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27353: LD_ADDR_EXP 54
27357: PUSH
27358: LD_EXP 54
27362: PPUSH
27363: LD_VAR 0 2
27367: PPUSH
27368: EMPTY
27369: PPUSH
27370: CALL_OW 1
27374: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27375: LD_VAR 0 2
27379: PPUSH
27380: LD_INT 102
27382: PPUSH
27383: CALL 21524 0 2
// continue ;
27387: GO 27316
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27389: LD_ADDR_VAR 0 4
27393: PUSH
27394: LD_EXP 50
27398: PUSH
27399: LD_VAR 0 2
27403: ARRAY
27404: PPUSH
27405: LD_INT 25
27407: PUSH
27408: LD_INT 4
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PPUSH
27415: CALL_OW 72
27419: ST_TO_ADDR
// if not tmp then
27420: LD_VAR 0 4
27424: NOT
27425: IFFALSE 27429
// continue ;
27427: GO 27316
// if mc_taming [ i ] then
27429: LD_EXP 81
27433: PUSH
27434: LD_VAR 0 2
27438: ARRAY
27439: IFFALSE 27463
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27441: LD_ADDR_EXP 81
27445: PUSH
27446: LD_EXP 81
27450: PPUSH
27451: LD_VAR 0 2
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL_OW 1
27462: ST_TO_ADDR
// for j in tmp do
27463: LD_ADDR_VAR 0 3
27467: PUSH
27468: LD_VAR 0 4
27472: PUSH
27473: FOR_IN
27474: IFFALSE 27697
// begin if IsInUnit ( j ) then
27476: LD_VAR 0 3
27480: PPUSH
27481: CALL_OW 310
27485: IFFALSE 27496
// ComExitBuilding ( j ) ;
27487: LD_VAR 0 3
27491: PPUSH
27492: CALL_OW 122
// if not j in mc_healers [ i ] then
27496: LD_VAR 0 3
27500: PUSH
27501: LD_EXP 54
27505: PUSH
27506: LD_VAR 0 2
27510: ARRAY
27511: IN
27512: NOT
27513: IFFALSE 27559
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27515: LD_ADDR_EXP 54
27519: PUSH
27520: LD_EXP 54
27524: PPUSH
27525: LD_VAR 0 2
27529: PUSH
27530: LD_EXP 54
27534: PUSH
27535: LD_VAR 0 2
27539: ARRAY
27540: PUSH
27541: LD_INT 1
27543: PLUS
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PPUSH
27549: LD_VAR 0 3
27553: PPUSH
27554: CALL 52460 0 3
27558: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27559: LD_VAR 0 3
27563: PPUSH
27564: CALL_OW 110
27568: PUSH
27569: LD_INT 102
27571: NONEQUAL
27572: IFFALSE 27586
// SetTag ( j , 102 ) ;
27574: LD_VAR 0 3
27578: PPUSH
27579: LD_INT 102
27581: PPUSH
27582: CALL_OW 109
// Wait ( 3 ) ;
27586: LD_INT 3
27588: PPUSH
27589: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27593: LD_EXP 53
27597: PUSH
27598: LD_VAR 0 2
27602: ARRAY
27603: PUSH
27604: LD_INT 1
27606: ARRAY
27607: IFFALSE 27639
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27609: LD_VAR 0 3
27613: PPUSH
27614: LD_EXP 53
27618: PUSH
27619: LD_VAR 0 2
27623: ARRAY
27624: PUSH
27625: LD_INT 1
27627: ARRAY
27628: PUSH
27629: LD_INT 1
27631: ARRAY
27632: PPUSH
27633: CALL_OW 128
27637: GO 27695
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27639: LD_VAR 0 3
27643: PPUSH
27644: CALL_OW 314
27648: NOT
27649: PUSH
27650: LD_EXP 53
27654: PUSH
27655: LD_VAR 0 2
27659: ARRAY
27660: PUSH
27661: LD_INT 2
27663: ARRAY
27664: AND
27665: IFFALSE 27695
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27667: LD_VAR 0 3
27671: PPUSH
27672: LD_EXP 53
27676: PUSH
27677: LD_VAR 0 2
27681: ARRAY
27682: PUSH
27683: LD_INT 2
27685: ARRAY
27686: PUSH
27687: LD_INT 1
27689: ARRAY
27690: PPUSH
27691: CALL_OW 128
// end ;
27695: GO 27473
27697: POP
27698: POP
// end ;
27699: GO 27316
27701: POP
27702: POP
// end ;
27703: LD_VAR 0 1
27707: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27708: LD_INT 0
27710: PPUSH
27711: PPUSH
27712: PPUSH
27713: PPUSH
27714: PPUSH
// if not mc_bases then
27715: LD_EXP 50
27719: NOT
27720: IFFALSE 27724
// exit ;
27722: GO 28867
// for i = 1 to mc_bases do
27724: LD_ADDR_VAR 0 2
27728: PUSH
27729: DOUBLE
27730: LD_INT 1
27732: DEC
27733: ST_TO_ADDR
27734: LD_EXP 50
27738: PUSH
27739: FOR_TO
27740: IFFALSE 28865
// begin if mc_scan [ i ] then
27742: LD_EXP 73
27746: PUSH
27747: LD_VAR 0 2
27751: ARRAY
27752: IFFALSE 27756
// continue ;
27754: GO 27739
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27756: LD_EXP 55
27760: PUSH
27761: LD_VAR 0 2
27765: ARRAY
27766: NOT
27767: PUSH
27768: LD_EXP 57
27772: PUSH
27773: LD_VAR 0 2
27777: ARRAY
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 56
27785: PUSH
27786: LD_VAR 0 2
27790: ARRAY
27791: AND
27792: IFFALSE 27830
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27794: LD_ADDR_EXP 56
27798: PUSH
27799: LD_EXP 56
27803: PPUSH
27804: LD_VAR 0 2
27808: PPUSH
27809: EMPTY
27810: PPUSH
27811: CALL_OW 1
27815: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27816: LD_VAR 0 2
27820: PPUSH
27821: LD_INT 103
27823: PPUSH
27824: CALL 21524 0 2
// continue ;
27828: GO 27739
// end ; if mc_construct_list [ i ] then
27830: LD_EXP 57
27834: PUSH
27835: LD_VAR 0 2
27839: ARRAY
27840: IFFALSE 28060
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27842: LD_ADDR_VAR 0 4
27846: PUSH
27847: LD_EXP 50
27851: PUSH
27852: LD_VAR 0 2
27856: ARRAY
27857: PPUSH
27858: LD_INT 25
27860: PUSH
27861: LD_INT 2
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PPUSH
27868: CALL_OW 72
27872: PUSH
27873: LD_EXP 52
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: DIFF
27884: ST_TO_ADDR
// if not tmp then
27885: LD_VAR 0 4
27889: NOT
27890: IFFALSE 27894
// continue ;
27892: GO 27739
// for j in tmp do
27894: LD_ADDR_VAR 0 3
27898: PUSH
27899: LD_VAR 0 4
27903: PUSH
27904: FOR_IN
27905: IFFALSE 28056
// begin if not mc_builders [ i ] then
27907: LD_EXP 56
27911: PUSH
27912: LD_VAR 0 2
27916: ARRAY
27917: NOT
27918: IFFALSE 27976
// begin SetTag ( j , 103 ) ;
27920: LD_VAR 0 3
27924: PPUSH
27925: LD_INT 103
27927: PPUSH
27928: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27932: LD_ADDR_EXP 56
27936: PUSH
27937: LD_EXP 56
27941: PPUSH
27942: LD_VAR 0 2
27946: PUSH
27947: LD_EXP 56
27951: PUSH
27952: LD_VAR 0 2
27956: ARRAY
27957: PUSH
27958: LD_INT 1
27960: PLUS
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PPUSH
27966: LD_VAR 0 3
27970: PPUSH
27971: CALL 52460 0 3
27975: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27976: LD_VAR 0 3
27980: PPUSH
27981: CALL_OW 310
27985: IFFALSE 27996
// ComExitBuilding ( j ) ;
27987: LD_VAR 0 3
27991: PPUSH
27992: CALL_OW 122
// wait ( 3 ) ;
27996: LD_INT 3
27998: PPUSH
27999: CALL_OW 67
// if not mc_construct_list [ i ] then
28003: LD_EXP 57
28007: PUSH
28008: LD_VAR 0 2
28012: ARRAY
28013: NOT
28014: IFFALSE 28018
// break ;
28016: GO 28056
// if not HasTask ( j ) then
28018: LD_VAR 0 3
28022: PPUSH
28023: CALL_OW 314
28027: NOT
28028: IFFALSE 28054
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28030: LD_VAR 0 3
28034: PPUSH
28035: LD_EXP 57
28039: PUSH
28040: LD_VAR 0 2
28044: ARRAY
28045: PUSH
28046: LD_INT 1
28048: ARRAY
28049: PPUSH
28050: CALL 55311 0 2
// end ;
28054: GO 27904
28056: POP
28057: POP
// end else
28058: GO 28863
// if mc_build_list [ i ] then
28060: LD_EXP 55
28064: PUSH
28065: LD_VAR 0 2
28069: ARRAY
28070: IFFALSE 28863
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28072: LD_ADDR_VAR 0 5
28076: PUSH
28077: LD_EXP 50
28081: PUSH
28082: LD_VAR 0 2
28086: ARRAY
28087: PPUSH
28088: LD_INT 2
28090: PUSH
28091: LD_INT 30
28093: PUSH
28094: LD_INT 0
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 30
28103: PUSH
28104: LD_INT 1
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: LIST
28115: PPUSH
28116: CALL_OW 72
28120: ST_TO_ADDR
// if depot then
28121: LD_VAR 0 5
28125: IFFALSE 28143
// depot := depot [ 1 ] else
28127: LD_ADDR_VAR 0 5
28131: PUSH
28132: LD_VAR 0 5
28136: PUSH
28137: LD_INT 1
28139: ARRAY
28140: ST_TO_ADDR
28141: GO 28151
// depot := 0 ;
28143: LD_ADDR_VAR 0 5
28147: PUSH
28148: LD_INT 0
28150: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28151: LD_EXP 55
28155: PUSH
28156: LD_VAR 0 2
28160: ARRAY
28161: PUSH
28162: LD_INT 1
28164: ARRAY
28165: PUSH
28166: LD_INT 1
28168: ARRAY
28169: PPUSH
28170: CALL 55141 0 1
28174: PUSH
28175: LD_EXP 50
28179: PUSH
28180: LD_VAR 0 2
28184: ARRAY
28185: PPUSH
28186: LD_INT 2
28188: PUSH
28189: LD_INT 30
28191: PUSH
28192: LD_INT 2
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 30
28201: PUSH
28202: LD_INT 3
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: LIST
28213: PPUSH
28214: CALL_OW 72
28218: NOT
28219: AND
28220: IFFALSE 28325
// begin for j = 1 to mc_build_list [ i ] do
28222: LD_ADDR_VAR 0 3
28226: PUSH
28227: DOUBLE
28228: LD_INT 1
28230: DEC
28231: ST_TO_ADDR
28232: LD_EXP 55
28236: PUSH
28237: LD_VAR 0 2
28241: ARRAY
28242: PUSH
28243: FOR_TO
28244: IFFALSE 28323
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28246: LD_EXP 55
28250: PUSH
28251: LD_VAR 0 2
28255: ARRAY
28256: PUSH
28257: LD_VAR 0 3
28261: ARRAY
28262: PUSH
28263: LD_INT 1
28265: ARRAY
28266: PUSH
28267: LD_INT 2
28269: EQUAL
28270: IFFALSE 28321
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28272: LD_ADDR_EXP 55
28276: PUSH
28277: LD_EXP 55
28281: PPUSH
28282: LD_VAR 0 2
28286: PPUSH
28287: LD_EXP 55
28291: PUSH
28292: LD_VAR 0 2
28296: ARRAY
28297: PPUSH
28298: LD_VAR 0 3
28302: PPUSH
28303: LD_INT 1
28305: PPUSH
28306: LD_INT 0
28308: PPUSH
28309: CALL 51878 0 4
28313: PPUSH
28314: CALL_OW 1
28318: ST_TO_ADDR
// break ;
28319: GO 28323
// end ;
28321: GO 28243
28323: POP
28324: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28325: LD_EXP 55
28329: PUSH
28330: LD_VAR 0 2
28334: ARRAY
28335: PUSH
28336: LD_INT 1
28338: ARRAY
28339: PUSH
28340: LD_INT 1
28342: ARRAY
28343: PUSH
28344: LD_INT 0
28346: EQUAL
28347: PUSH
28348: LD_VAR 0 5
28352: PUSH
28353: LD_VAR 0 5
28357: PPUSH
28358: LD_EXP 55
28362: PUSH
28363: LD_VAR 0 2
28367: ARRAY
28368: PUSH
28369: LD_INT 1
28371: ARRAY
28372: PUSH
28373: LD_INT 1
28375: ARRAY
28376: PPUSH
28377: LD_EXP 55
28381: PUSH
28382: LD_VAR 0 2
28386: ARRAY
28387: PUSH
28388: LD_INT 1
28390: ARRAY
28391: PUSH
28392: LD_INT 2
28394: ARRAY
28395: PPUSH
28396: LD_EXP 55
28400: PUSH
28401: LD_VAR 0 2
28405: ARRAY
28406: PUSH
28407: LD_INT 1
28409: ARRAY
28410: PUSH
28411: LD_INT 3
28413: ARRAY
28414: PPUSH
28415: LD_EXP 55
28419: PUSH
28420: LD_VAR 0 2
28424: ARRAY
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: PUSH
28430: LD_INT 4
28432: ARRAY
28433: PPUSH
28434: CALL 59875 0 5
28438: AND
28439: OR
28440: IFFALSE 28721
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28442: LD_ADDR_VAR 0 4
28446: PUSH
28447: LD_EXP 50
28451: PUSH
28452: LD_VAR 0 2
28456: ARRAY
28457: PPUSH
28458: LD_INT 25
28460: PUSH
28461: LD_INT 2
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PPUSH
28468: CALL_OW 72
28472: PUSH
28473: LD_EXP 52
28477: PUSH
28478: LD_VAR 0 2
28482: ARRAY
28483: DIFF
28484: ST_TO_ADDR
// if not tmp then
28485: LD_VAR 0 4
28489: NOT
28490: IFFALSE 28494
// continue ;
28492: GO 27739
// for j in tmp do
28494: LD_ADDR_VAR 0 3
28498: PUSH
28499: LD_VAR 0 4
28503: PUSH
28504: FOR_IN
28505: IFFALSE 28717
// begin if not mc_builders [ i ] then
28507: LD_EXP 56
28511: PUSH
28512: LD_VAR 0 2
28516: ARRAY
28517: NOT
28518: IFFALSE 28576
// begin SetTag ( j , 103 ) ;
28520: LD_VAR 0 3
28524: PPUSH
28525: LD_INT 103
28527: PPUSH
28528: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28532: LD_ADDR_EXP 56
28536: PUSH
28537: LD_EXP 56
28541: PPUSH
28542: LD_VAR 0 2
28546: PUSH
28547: LD_EXP 56
28551: PUSH
28552: LD_VAR 0 2
28556: ARRAY
28557: PUSH
28558: LD_INT 1
28560: PLUS
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PPUSH
28566: LD_VAR 0 3
28570: PPUSH
28571: CALL 52460 0 3
28575: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28576: LD_VAR 0 3
28580: PPUSH
28581: CALL_OW 310
28585: IFFALSE 28596
// ComExitBuilding ( j ) ;
28587: LD_VAR 0 3
28591: PPUSH
28592: CALL_OW 122
// wait ( 3 ) ;
28596: LD_INT 3
28598: PPUSH
28599: CALL_OW 67
// if not mc_build_list [ i ] then
28603: LD_EXP 55
28607: PUSH
28608: LD_VAR 0 2
28612: ARRAY
28613: NOT
28614: IFFALSE 28618
// break ;
28616: GO 28717
// if not HasTask ( j ) then
28618: LD_VAR 0 3
28622: PPUSH
28623: CALL_OW 314
28627: NOT
28628: IFFALSE 28715
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28630: LD_VAR 0 3
28634: PPUSH
28635: LD_EXP 55
28639: PUSH
28640: LD_VAR 0 2
28644: ARRAY
28645: PUSH
28646: LD_INT 1
28648: ARRAY
28649: PUSH
28650: LD_INT 1
28652: ARRAY
28653: PPUSH
28654: LD_EXP 55
28658: PUSH
28659: LD_VAR 0 2
28663: ARRAY
28664: PUSH
28665: LD_INT 1
28667: ARRAY
28668: PUSH
28669: LD_INT 2
28671: ARRAY
28672: PPUSH
28673: LD_EXP 55
28677: PUSH
28678: LD_VAR 0 2
28682: ARRAY
28683: PUSH
28684: LD_INT 1
28686: ARRAY
28687: PUSH
28688: LD_INT 3
28690: ARRAY
28691: PPUSH
28692: LD_EXP 55
28696: PUSH
28697: LD_VAR 0 2
28701: ARRAY
28702: PUSH
28703: LD_INT 1
28705: ARRAY
28706: PUSH
28707: LD_INT 4
28709: ARRAY
28710: PPUSH
28711: CALL_OW 145
// end ;
28715: GO 28504
28717: POP
28718: POP
// end else
28719: GO 28863
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28721: LD_EXP 50
28725: PUSH
28726: LD_VAR 0 2
28730: ARRAY
28731: PPUSH
28732: LD_EXP 55
28736: PUSH
28737: LD_VAR 0 2
28741: ARRAY
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PUSH
28747: LD_INT 1
28749: ARRAY
28750: PPUSH
28751: LD_EXP 55
28755: PUSH
28756: LD_VAR 0 2
28760: ARRAY
28761: PUSH
28762: LD_INT 1
28764: ARRAY
28765: PUSH
28766: LD_INT 2
28768: ARRAY
28769: PPUSH
28770: LD_EXP 55
28774: PUSH
28775: LD_VAR 0 2
28779: ARRAY
28780: PUSH
28781: LD_INT 1
28783: ARRAY
28784: PUSH
28785: LD_INT 3
28787: ARRAY
28788: PPUSH
28789: LD_EXP 55
28793: PUSH
28794: LD_VAR 0 2
28798: ARRAY
28799: PUSH
28800: LD_INT 1
28802: ARRAY
28803: PUSH
28804: LD_INT 4
28806: ARRAY
28807: PPUSH
28808: CALL 59211 0 5
28812: NOT
28813: IFFALSE 28863
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28815: LD_ADDR_EXP 55
28819: PUSH
28820: LD_EXP 55
28824: PPUSH
28825: LD_VAR 0 2
28829: PPUSH
28830: LD_EXP 55
28834: PUSH
28835: LD_VAR 0 2
28839: ARRAY
28840: PPUSH
28841: LD_INT 1
28843: PPUSH
28844: LD_INT 1
28846: NEG
28847: PPUSH
28848: LD_INT 0
28850: PPUSH
28851: CALL 51878 0 4
28855: PPUSH
28856: CALL_OW 1
28860: ST_TO_ADDR
// continue ;
28861: GO 27739
// end ; end ; end ;
28863: GO 27739
28865: POP
28866: POP
// end ;
28867: LD_VAR 0 1
28871: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28872: LD_INT 0
28874: PPUSH
28875: PPUSH
28876: PPUSH
28877: PPUSH
28878: PPUSH
28879: PPUSH
// if not mc_bases then
28880: LD_EXP 50
28884: NOT
28885: IFFALSE 28889
// exit ;
28887: GO 29316
// for i = 1 to mc_bases do
28889: LD_ADDR_VAR 0 2
28893: PUSH
28894: DOUBLE
28895: LD_INT 1
28897: DEC
28898: ST_TO_ADDR
28899: LD_EXP 50
28903: PUSH
28904: FOR_TO
28905: IFFALSE 29314
// begin tmp := mc_build_upgrade [ i ] ;
28907: LD_ADDR_VAR 0 4
28911: PUSH
28912: LD_EXP 82
28916: PUSH
28917: LD_VAR 0 2
28921: ARRAY
28922: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28923: LD_ADDR_VAR 0 6
28927: PUSH
28928: LD_EXP 83
28932: PUSH
28933: LD_VAR 0 2
28937: ARRAY
28938: PPUSH
28939: LD_INT 2
28941: PUSH
28942: LD_INT 30
28944: PUSH
28945: LD_INT 6
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 30
28954: PUSH
28955: LD_INT 7
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: LIST
28966: PPUSH
28967: CALL_OW 72
28971: ST_TO_ADDR
// if not tmp and not lab then
28972: LD_VAR 0 4
28976: NOT
28977: PUSH
28978: LD_VAR 0 6
28982: NOT
28983: AND
28984: IFFALSE 28988
// continue ;
28986: GO 28904
// if tmp then
28988: LD_VAR 0 4
28992: IFFALSE 29112
// for j in tmp do
28994: LD_ADDR_VAR 0 3
28998: PUSH
28999: LD_VAR 0 4
29003: PUSH
29004: FOR_IN
29005: IFFALSE 29110
// begin if UpgradeCost ( j ) then
29007: LD_VAR 0 3
29011: PPUSH
29012: CALL 58871 0 1
29016: IFFALSE 29108
// begin ComUpgrade ( j ) ;
29018: LD_VAR 0 3
29022: PPUSH
29023: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29027: LD_ADDR_EXP 82
29031: PUSH
29032: LD_EXP 82
29036: PPUSH
29037: LD_VAR 0 2
29041: PPUSH
29042: LD_EXP 82
29046: PUSH
29047: LD_VAR 0 2
29051: ARRAY
29052: PUSH
29053: LD_VAR 0 3
29057: DIFF
29058: PPUSH
29059: CALL_OW 1
29063: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29064: LD_ADDR_EXP 57
29068: PUSH
29069: LD_EXP 57
29073: PPUSH
29074: LD_VAR 0 2
29078: PUSH
29079: LD_EXP 57
29083: PUSH
29084: LD_VAR 0 2
29088: ARRAY
29089: PUSH
29090: LD_INT 1
29092: PLUS
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PPUSH
29098: LD_VAR 0 3
29102: PPUSH
29103: CALL 52460 0 3
29107: ST_TO_ADDR
// end ; end ;
29108: GO 29004
29110: POP
29111: POP
// if not lab or not mc_lab_upgrade [ i ] then
29112: LD_VAR 0 6
29116: NOT
29117: PUSH
29118: LD_EXP 84
29122: PUSH
29123: LD_VAR 0 2
29127: ARRAY
29128: NOT
29129: OR
29130: IFFALSE 29134
// continue ;
29132: GO 28904
// for j in lab do
29134: LD_ADDR_VAR 0 3
29138: PUSH
29139: LD_VAR 0 6
29143: PUSH
29144: FOR_IN
29145: IFFALSE 29310
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29147: LD_VAR 0 3
29151: PPUSH
29152: CALL_OW 266
29156: PUSH
29157: LD_INT 6
29159: PUSH
29160: LD_INT 7
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: IN
29167: PUSH
29168: LD_VAR 0 3
29172: PPUSH
29173: CALL_OW 461
29177: PUSH
29178: LD_INT 1
29180: NONEQUAL
29181: AND
29182: IFFALSE 29308
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29184: LD_VAR 0 3
29188: PPUSH
29189: LD_EXP 84
29193: PUSH
29194: LD_VAR 0 2
29198: ARRAY
29199: PUSH
29200: LD_INT 1
29202: ARRAY
29203: PPUSH
29204: CALL 59076 0 2
29208: IFFALSE 29308
// begin ComCancel ( j ) ;
29210: LD_VAR 0 3
29214: PPUSH
29215: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29219: LD_VAR 0 3
29223: PPUSH
29224: LD_EXP 84
29228: PUSH
29229: LD_VAR 0 2
29233: ARRAY
29234: PUSH
29235: LD_INT 1
29237: ARRAY
29238: PPUSH
29239: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29243: LD_VAR 0 3
29247: PUSH
29248: LD_EXP 57
29252: PUSH
29253: LD_VAR 0 2
29257: ARRAY
29258: IN
29259: NOT
29260: IFFALSE 29306
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29262: LD_ADDR_EXP 57
29266: PUSH
29267: LD_EXP 57
29271: PPUSH
29272: LD_VAR 0 2
29276: PUSH
29277: LD_EXP 57
29281: PUSH
29282: LD_VAR 0 2
29286: ARRAY
29287: PUSH
29288: LD_INT 1
29290: PLUS
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PPUSH
29296: LD_VAR 0 3
29300: PPUSH
29301: CALL 52460 0 3
29305: ST_TO_ADDR
// break ;
29306: GO 29310
// end ; end ; end ;
29308: GO 29144
29310: POP
29311: POP
// end ;
29312: GO 28904
29314: POP
29315: POP
// end ;
29316: LD_VAR 0 1
29320: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29321: LD_INT 0
29323: PPUSH
29324: PPUSH
29325: PPUSH
29326: PPUSH
29327: PPUSH
29328: PPUSH
29329: PPUSH
29330: PPUSH
29331: PPUSH
// if not mc_bases then
29332: LD_EXP 50
29336: NOT
29337: IFFALSE 29341
// exit ;
29339: GO 29746
// for i = 1 to mc_bases do
29341: LD_ADDR_VAR 0 2
29345: PUSH
29346: DOUBLE
29347: LD_INT 1
29349: DEC
29350: ST_TO_ADDR
29351: LD_EXP 50
29355: PUSH
29356: FOR_TO
29357: IFFALSE 29744
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29359: LD_EXP 58
29363: PUSH
29364: LD_VAR 0 2
29368: ARRAY
29369: NOT
29370: PUSH
29371: LD_EXP 50
29375: PUSH
29376: LD_VAR 0 2
29380: ARRAY
29381: PPUSH
29382: LD_INT 30
29384: PUSH
29385: LD_INT 3
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PPUSH
29392: CALL_OW 72
29396: NOT
29397: OR
29398: IFFALSE 29402
// continue ;
29400: GO 29356
// busy := false ;
29402: LD_ADDR_VAR 0 8
29406: PUSH
29407: LD_INT 0
29409: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29410: LD_ADDR_VAR 0 4
29414: PUSH
29415: LD_EXP 50
29419: PUSH
29420: LD_VAR 0 2
29424: ARRAY
29425: PPUSH
29426: LD_INT 30
29428: PUSH
29429: LD_INT 3
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PPUSH
29436: CALL_OW 72
29440: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29441: LD_ADDR_VAR 0 6
29445: PUSH
29446: LD_EXP 58
29450: PUSH
29451: LD_VAR 0 2
29455: ARRAY
29456: PPUSH
29457: LD_INT 2
29459: PUSH
29460: LD_INT 30
29462: PUSH
29463: LD_INT 32
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 30
29472: PUSH
29473: LD_INT 33
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: LIST
29484: PPUSH
29485: CALL_OW 72
29489: ST_TO_ADDR
// if not t then
29490: LD_VAR 0 6
29494: NOT
29495: IFFALSE 29499
// continue ;
29497: GO 29356
// for j in tmp do
29499: LD_ADDR_VAR 0 3
29503: PUSH
29504: LD_VAR 0 4
29508: PUSH
29509: FOR_IN
29510: IFFALSE 29540
// if not BuildingStatus ( j ) = bs_idle then
29512: LD_VAR 0 3
29516: PPUSH
29517: CALL_OW 461
29521: PUSH
29522: LD_INT 2
29524: EQUAL
29525: NOT
29526: IFFALSE 29538
// begin busy := true ;
29528: LD_ADDR_VAR 0 8
29532: PUSH
29533: LD_INT 1
29535: ST_TO_ADDR
// break ;
29536: GO 29540
// end ;
29538: GO 29509
29540: POP
29541: POP
// if busy then
29542: LD_VAR 0 8
29546: IFFALSE 29550
// continue ;
29548: GO 29356
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29550: LD_ADDR_VAR 0 7
29554: PUSH
29555: LD_VAR 0 6
29559: PPUSH
29560: LD_INT 35
29562: PUSH
29563: LD_INT 0
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PPUSH
29570: CALL_OW 72
29574: ST_TO_ADDR
// if tw then
29575: LD_VAR 0 7
29579: IFFALSE 29656
// begin tw := tw [ 1 ] ;
29581: LD_ADDR_VAR 0 7
29585: PUSH
29586: LD_VAR 0 7
29590: PUSH
29591: LD_INT 1
29593: ARRAY
29594: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29595: LD_ADDR_VAR 0 9
29599: PUSH
29600: LD_VAR 0 7
29604: PPUSH
29605: LD_EXP 75
29609: PUSH
29610: LD_VAR 0 2
29614: ARRAY
29615: PPUSH
29616: CALL 57430 0 2
29620: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29621: LD_EXP 89
29625: PUSH
29626: LD_VAR 0 2
29630: ARRAY
29631: IFFALSE 29654
// if not weapon in mc_allowed_tower_weapons [ i ] then
29633: LD_VAR 0 9
29637: PUSH
29638: LD_EXP 89
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: IN
29649: NOT
29650: IFFALSE 29654
// continue ;
29652: GO 29356
// end else
29654: GO 29719
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29656: LD_ADDR_VAR 0 5
29660: PUSH
29661: LD_EXP 58
29665: PUSH
29666: LD_VAR 0 2
29670: ARRAY
29671: PPUSH
29672: LD_VAR 0 4
29676: PPUSH
29677: CALL 83051 0 2
29681: ST_TO_ADDR
// if not tmp2 then
29682: LD_VAR 0 5
29686: NOT
29687: IFFALSE 29691
// continue ;
29689: GO 29356
// tw := tmp2 [ 1 ] ;
29691: LD_ADDR_VAR 0 7
29695: PUSH
29696: LD_VAR 0 5
29700: PUSH
29701: LD_INT 1
29703: ARRAY
29704: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29705: LD_ADDR_VAR 0 9
29709: PUSH
29710: LD_VAR 0 5
29714: PUSH
29715: LD_INT 2
29717: ARRAY
29718: ST_TO_ADDR
// end ; if not weapon then
29719: LD_VAR 0 9
29723: NOT
29724: IFFALSE 29728
// continue ;
29726: GO 29356
// ComPlaceWeapon ( tw , weapon ) ;
29728: LD_VAR 0 7
29732: PPUSH
29733: LD_VAR 0 9
29737: PPUSH
29738: CALL_OW 148
// end ;
29742: GO 29356
29744: POP
29745: POP
// end ;
29746: LD_VAR 0 1
29750: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29751: LD_INT 0
29753: PPUSH
29754: PPUSH
29755: PPUSH
29756: PPUSH
29757: PPUSH
29758: PPUSH
// if not mc_bases then
29759: LD_EXP 50
29763: NOT
29764: IFFALSE 29768
// exit ;
29766: GO 30544
// for i = 1 to mc_bases do
29768: LD_ADDR_VAR 0 2
29772: PUSH
29773: DOUBLE
29774: LD_INT 1
29776: DEC
29777: ST_TO_ADDR
29778: LD_EXP 50
29782: PUSH
29783: FOR_TO
29784: IFFALSE 30542
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29786: LD_EXP 63
29790: PUSH
29791: LD_VAR 0 2
29795: ARRAY
29796: NOT
29797: PUSH
29798: LD_EXP 63
29802: PUSH
29803: LD_VAR 0 2
29807: ARRAY
29808: PUSH
29809: LD_EXP 64
29813: PUSH
29814: LD_VAR 0 2
29818: ARRAY
29819: EQUAL
29820: OR
29821: PUSH
29822: LD_EXP 73
29826: PUSH
29827: LD_VAR 0 2
29831: ARRAY
29832: OR
29833: IFFALSE 29837
// continue ;
29835: GO 29783
// if mc_miners [ i ] then
29837: LD_EXP 64
29841: PUSH
29842: LD_VAR 0 2
29846: ARRAY
29847: IFFALSE 30229
// begin for j = mc_miners [ i ] downto 1 do
29849: LD_ADDR_VAR 0 3
29853: PUSH
29854: DOUBLE
29855: LD_EXP 64
29859: PUSH
29860: LD_VAR 0 2
29864: ARRAY
29865: INC
29866: ST_TO_ADDR
29867: LD_INT 1
29869: PUSH
29870: FOR_DOWNTO
29871: IFFALSE 30227
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29873: LD_EXP 64
29877: PUSH
29878: LD_VAR 0 2
29882: ARRAY
29883: PUSH
29884: LD_VAR 0 3
29888: ARRAY
29889: PPUSH
29890: CALL_OW 301
29894: PUSH
29895: LD_EXP 64
29899: PUSH
29900: LD_VAR 0 2
29904: ARRAY
29905: PUSH
29906: LD_VAR 0 3
29910: ARRAY
29911: PPUSH
29912: CALL_OW 257
29916: PUSH
29917: LD_INT 1
29919: NONEQUAL
29920: OR
29921: IFFALSE 29984
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29923: LD_ADDR_VAR 0 5
29927: PUSH
29928: LD_EXP 64
29932: PUSH
29933: LD_VAR 0 2
29937: ARRAY
29938: PUSH
29939: LD_EXP 64
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PUSH
29950: LD_VAR 0 3
29954: ARRAY
29955: DIFF
29956: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29957: LD_ADDR_EXP 64
29961: PUSH
29962: LD_EXP 64
29966: PPUSH
29967: LD_VAR 0 2
29971: PPUSH
29972: LD_VAR 0 5
29976: PPUSH
29977: CALL_OW 1
29981: ST_TO_ADDR
// continue ;
29982: GO 29870
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29984: LD_EXP 64
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: PUSH
29995: LD_VAR 0 3
29999: ARRAY
30000: PPUSH
30001: CALL_OW 257
30005: PUSH
30006: LD_INT 1
30008: EQUAL
30009: PUSH
30010: LD_EXP 64
30014: PUSH
30015: LD_VAR 0 2
30019: ARRAY
30020: PUSH
30021: LD_VAR 0 3
30025: ARRAY
30026: PPUSH
30027: CALL_OW 459
30031: NOT
30032: AND
30033: PUSH
30034: LD_EXP 64
30038: PUSH
30039: LD_VAR 0 2
30043: ARRAY
30044: PUSH
30045: LD_VAR 0 3
30049: ARRAY
30050: PPUSH
30051: CALL_OW 314
30055: NOT
30056: AND
30057: IFFALSE 30225
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30059: LD_EXP 64
30063: PUSH
30064: LD_VAR 0 2
30068: ARRAY
30069: PUSH
30070: LD_VAR 0 3
30074: ARRAY
30075: PPUSH
30076: CALL_OW 310
30080: IFFALSE 30103
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30082: LD_EXP 64
30086: PUSH
30087: LD_VAR 0 2
30091: ARRAY
30092: PUSH
30093: LD_VAR 0 3
30097: ARRAY
30098: PPUSH
30099: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30103: LD_EXP 64
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PUSH
30114: LD_VAR 0 3
30118: ARRAY
30119: PPUSH
30120: CALL_OW 314
30124: NOT
30125: IFFALSE 30225
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30127: LD_EXP 64
30131: PUSH
30132: LD_VAR 0 2
30136: ARRAY
30137: PUSH
30138: LD_VAR 0 3
30142: ARRAY
30143: PPUSH
30144: LD_EXP 63
30148: PUSH
30149: LD_VAR 0 2
30153: ARRAY
30154: PUSH
30155: LD_VAR 0 3
30159: PUSH
30160: LD_EXP 63
30164: PUSH
30165: LD_VAR 0 2
30169: ARRAY
30170: MOD
30171: PUSH
30172: LD_INT 1
30174: PLUS
30175: ARRAY
30176: PUSH
30177: LD_INT 1
30179: ARRAY
30180: PPUSH
30181: LD_EXP 63
30185: PUSH
30186: LD_VAR 0 2
30190: ARRAY
30191: PUSH
30192: LD_VAR 0 3
30196: PUSH
30197: LD_EXP 63
30201: PUSH
30202: LD_VAR 0 2
30206: ARRAY
30207: MOD
30208: PUSH
30209: LD_INT 1
30211: PLUS
30212: ARRAY
30213: PUSH
30214: LD_INT 2
30216: ARRAY
30217: PPUSH
30218: LD_INT 0
30220: PPUSH
30221: CALL_OW 193
// end ; end ;
30225: GO 29870
30227: POP
30228: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30229: LD_ADDR_VAR 0 5
30233: PUSH
30234: LD_EXP 50
30238: PUSH
30239: LD_VAR 0 2
30243: ARRAY
30244: PPUSH
30245: LD_INT 2
30247: PUSH
30248: LD_INT 30
30250: PUSH
30251: LD_INT 4
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 30
30260: PUSH
30261: LD_INT 5
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 30
30270: PUSH
30271: LD_INT 32
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: PPUSH
30284: CALL_OW 72
30288: ST_TO_ADDR
// if not tmp then
30289: LD_VAR 0 5
30293: NOT
30294: IFFALSE 30298
// continue ;
30296: GO 29783
// list := [ ] ;
30298: LD_ADDR_VAR 0 6
30302: PUSH
30303: EMPTY
30304: ST_TO_ADDR
// for j in tmp do
30305: LD_ADDR_VAR 0 3
30309: PUSH
30310: LD_VAR 0 5
30314: PUSH
30315: FOR_IN
30316: IFFALSE 30385
// begin for k in UnitsInside ( j ) do
30318: LD_ADDR_VAR 0 4
30322: PUSH
30323: LD_VAR 0 3
30327: PPUSH
30328: CALL_OW 313
30332: PUSH
30333: FOR_IN
30334: IFFALSE 30381
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30336: LD_VAR 0 4
30340: PPUSH
30341: CALL_OW 257
30345: PUSH
30346: LD_INT 1
30348: EQUAL
30349: PUSH
30350: LD_VAR 0 4
30354: PPUSH
30355: CALL_OW 459
30359: NOT
30360: AND
30361: IFFALSE 30379
// list := list ^ k ;
30363: LD_ADDR_VAR 0 6
30367: PUSH
30368: LD_VAR 0 6
30372: PUSH
30373: LD_VAR 0 4
30377: ADD
30378: ST_TO_ADDR
30379: GO 30333
30381: POP
30382: POP
// end ;
30383: GO 30315
30385: POP
30386: POP
// list := list diff mc_miners [ i ] ;
30387: LD_ADDR_VAR 0 6
30391: PUSH
30392: LD_VAR 0 6
30396: PUSH
30397: LD_EXP 64
30401: PUSH
30402: LD_VAR 0 2
30406: ARRAY
30407: DIFF
30408: ST_TO_ADDR
// if not list then
30409: LD_VAR 0 6
30413: NOT
30414: IFFALSE 30418
// continue ;
30416: GO 29783
// k := mc_mines [ i ] - mc_miners [ i ] ;
30418: LD_ADDR_VAR 0 4
30422: PUSH
30423: LD_EXP 63
30427: PUSH
30428: LD_VAR 0 2
30432: ARRAY
30433: PUSH
30434: LD_EXP 64
30438: PUSH
30439: LD_VAR 0 2
30443: ARRAY
30444: MINUS
30445: ST_TO_ADDR
// if k > list then
30446: LD_VAR 0 4
30450: PUSH
30451: LD_VAR 0 6
30455: GREATER
30456: IFFALSE 30468
// k := list ;
30458: LD_ADDR_VAR 0 4
30462: PUSH
30463: LD_VAR 0 6
30467: ST_TO_ADDR
// for j = 1 to k do
30468: LD_ADDR_VAR 0 3
30472: PUSH
30473: DOUBLE
30474: LD_INT 1
30476: DEC
30477: ST_TO_ADDR
30478: LD_VAR 0 4
30482: PUSH
30483: FOR_TO
30484: IFFALSE 30538
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30486: LD_ADDR_EXP 64
30490: PUSH
30491: LD_EXP 64
30495: PPUSH
30496: LD_VAR 0 2
30500: PUSH
30501: LD_EXP 64
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: PUSH
30512: LD_INT 1
30514: PLUS
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PPUSH
30520: LD_VAR 0 6
30524: PUSH
30525: LD_VAR 0 3
30529: ARRAY
30530: PPUSH
30531: CALL 52460 0 3
30535: ST_TO_ADDR
30536: GO 30483
30538: POP
30539: POP
// end ;
30540: GO 29783
30542: POP
30543: POP
// end ;
30544: LD_VAR 0 1
30548: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30549: LD_INT 0
30551: PPUSH
30552: PPUSH
30553: PPUSH
30554: PPUSH
30555: PPUSH
30556: PPUSH
30557: PPUSH
30558: PPUSH
30559: PPUSH
30560: PPUSH
// if not mc_bases then
30561: LD_EXP 50
30565: NOT
30566: IFFALSE 30570
// exit ;
30568: GO 32320
// for i = 1 to mc_bases do
30570: LD_ADDR_VAR 0 2
30574: PUSH
30575: DOUBLE
30576: LD_INT 1
30578: DEC
30579: ST_TO_ADDR
30580: LD_EXP 50
30584: PUSH
30585: FOR_TO
30586: IFFALSE 32318
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30588: LD_EXP 50
30592: PUSH
30593: LD_VAR 0 2
30597: ARRAY
30598: NOT
30599: PUSH
30600: LD_EXP 57
30604: PUSH
30605: LD_VAR 0 2
30609: ARRAY
30610: OR
30611: IFFALSE 30615
// continue ;
30613: GO 30585
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30615: LD_EXP 66
30619: PUSH
30620: LD_VAR 0 2
30624: ARRAY
30625: NOT
30626: PUSH
30627: LD_EXP 67
30631: PUSH
30632: LD_VAR 0 2
30636: ARRAY
30637: AND
30638: IFFALSE 30676
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30640: LD_ADDR_EXP 67
30644: PUSH
30645: LD_EXP 67
30649: PPUSH
30650: LD_VAR 0 2
30654: PPUSH
30655: EMPTY
30656: PPUSH
30657: CALL_OW 1
30661: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30662: LD_VAR 0 2
30666: PPUSH
30667: LD_INT 107
30669: PPUSH
30670: CALL 21524 0 2
// continue ;
30674: GO 30585
// end ; target := [ ] ;
30676: LD_ADDR_VAR 0 6
30680: PUSH
30681: EMPTY
30682: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30683: LD_ADDR_VAR 0 3
30687: PUSH
30688: DOUBLE
30689: LD_EXP 66
30693: PUSH
30694: LD_VAR 0 2
30698: ARRAY
30699: INC
30700: ST_TO_ADDR
30701: LD_INT 1
30703: PUSH
30704: FOR_DOWNTO
30705: IFFALSE 30965
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30707: LD_EXP 66
30711: PUSH
30712: LD_VAR 0 2
30716: ARRAY
30717: PUSH
30718: LD_VAR 0 3
30722: ARRAY
30723: PUSH
30724: LD_INT 2
30726: ARRAY
30727: PPUSH
30728: LD_EXP 66
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PUSH
30739: LD_VAR 0 3
30743: ARRAY
30744: PUSH
30745: LD_INT 3
30747: ARRAY
30748: PPUSH
30749: CALL_OW 488
30753: PUSH
30754: LD_EXP 66
30758: PUSH
30759: LD_VAR 0 2
30763: ARRAY
30764: PUSH
30765: LD_VAR 0 3
30769: ARRAY
30770: PUSH
30771: LD_INT 2
30773: ARRAY
30774: PPUSH
30775: LD_EXP 66
30779: PUSH
30780: LD_VAR 0 2
30784: ARRAY
30785: PUSH
30786: LD_VAR 0 3
30790: ARRAY
30791: PUSH
30792: LD_INT 3
30794: ARRAY
30795: PPUSH
30796: CALL_OW 284
30800: PUSH
30801: LD_INT 0
30803: EQUAL
30804: AND
30805: IFFALSE 30860
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30807: LD_ADDR_VAR 0 5
30811: PUSH
30812: LD_EXP 66
30816: PUSH
30817: LD_VAR 0 2
30821: ARRAY
30822: PPUSH
30823: LD_VAR 0 3
30827: PPUSH
30828: CALL_OW 3
30832: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30833: LD_ADDR_EXP 66
30837: PUSH
30838: LD_EXP 66
30842: PPUSH
30843: LD_VAR 0 2
30847: PPUSH
30848: LD_VAR 0 5
30852: PPUSH
30853: CALL_OW 1
30857: ST_TO_ADDR
// continue ;
30858: GO 30704
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30860: LD_EXP 50
30864: PUSH
30865: LD_VAR 0 2
30869: ARRAY
30870: PUSH
30871: LD_INT 1
30873: ARRAY
30874: PPUSH
30875: CALL_OW 255
30879: PPUSH
30880: LD_EXP 66
30884: PUSH
30885: LD_VAR 0 2
30889: ARRAY
30890: PUSH
30891: LD_VAR 0 3
30895: ARRAY
30896: PUSH
30897: LD_INT 2
30899: ARRAY
30900: PPUSH
30901: LD_EXP 66
30905: PUSH
30906: LD_VAR 0 2
30910: ARRAY
30911: PUSH
30912: LD_VAR 0 3
30916: ARRAY
30917: PUSH
30918: LD_INT 3
30920: ARRAY
30921: PPUSH
30922: LD_INT 30
30924: PPUSH
30925: CALL 53356 0 4
30929: PUSH
30930: LD_INT 4
30932: ARRAY
30933: PUSH
30934: LD_INT 0
30936: EQUAL
30937: IFFALSE 30963
// begin target := mc_crates [ i ] [ j ] ;
30939: LD_ADDR_VAR 0 6
30943: PUSH
30944: LD_EXP 66
30948: PUSH
30949: LD_VAR 0 2
30953: ARRAY
30954: PUSH
30955: LD_VAR 0 3
30959: ARRAY
30960: ST_TO_ADDR
// break ;
30961: GO 30965
// end ; end ;
30963: GO 30704
30965: POP
30966: POP
// if not target then
30967: LD_VAR 0 6
30971: NOT
30972: IFFALSE 30976
// continue ;
30974: GO 30585
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30976: LD_ADDR_VAR 0 7
30980: PUSH
30981: LD_EXP 69
30985: PUSH
30986: LD_VAR 0 2
30990: ARRAY
30991: PPUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 3
30997: PUSH
30998: LD_INT 58
31000: PUSH
31001: EMPTY
31002: LIST
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 61
31010: PUSH
31011: EMPTY
31012: LIST
31013: PUSH
31014: LD_INT 33
31016: PUSH
31017: LD_INT 5
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 33
31026: PUSH
31027: LD_INT 3
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 2
31043: PUSH
31044: LD_INT 34
31046: PUSH
31047: LD_INT 32
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 34
31056: PUSH
31057: LD_INT 51
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: LD_INT 34
31066: PUSH
31067: LD_INT 12
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: PPUSH
31084: CALL_OW 72
31088: ST_TO_ADDR
// if not cargo then
31089: LD_VAR 0 7
31093: NOT
31094: IFFALSE 31737
// begin if mc_crates_collector [ i ] < 5 then
31096: LD_EXP 67
31100: PUSH
31101: LD_VAR 0 2
31105: ARRAY
31106: PUSH
31107: LD_INT 5
31109: LESS
31110: IFFALSE 31476
// begin if mc_ape [ i ] then
31112: LD_EXP 79
31116: PUSH
31117: LD_VAR 0 2
31121: ARRAY
31122: IFFALSE 31169
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31124: LD_ADDR_VAR 0 5
31128: PUSH
31129: LD_EXP 79
31133: PUSH
31134: LD_VAR 0 2
31138: ARRAY
31139: PPUSH
31140: LD_INT 25
31142: PUSH
31143: LD_INT 16
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 24
31152: PUSH
31153: LD_INT 750
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PPUSH
31164: CALL_OW 72
31168: ST_TO_ADDR
// if not tmp then
31169: LD_VAR 0 5
31173: NOT
31174: IFFALSE 31221
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31176: LD_ADDR_VAR 0 5
31180: PUSH
31181: LD_EXP 50
31185: PUSH
31186: LD_VAR 0 2
31190: ARRAY
31191: PPUSH
31192: LD_INT 25
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 24
31204: PUSH
31205: LD_INT 750
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PPUSH
31216: CALL_OW 72
31220: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31221: LD_EXP 79
31225: PUSH
31226: LD_VAR 0 2
31230: ARRAY
31231: PUSH
31232: LD_EXP 50
31236: PUSH
31237: LD_VAR 0 2
31241: ARRAY
31242: PPUSH
31243: LD_INT 25
31245: PUSH
31246: LD_INT 2
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 24
31255: PUSH
31256: LD_INT 750
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PPUSH
31267: CALL_OW 72
31271: AND
31272: PUSH
31273: LD_VAR 0 5
31277: PUSH
31278: LD_INT 5
31280: LESS
31281: AND
31282: IFFALSE 31364
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31284: LD_ADDR_VAR 0 3
31288: PUSH
31289: LD_EXP 50
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PPUSH
31300: LD_INT 25
31302: PUSH
31303: LD_INT 2
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 24
31312: PUSH
31313: LD_INT 750
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PPUSH
31324: CALL_OW 72
31328: PUSH
31329: FOR_IN
31330: IFFALSE 31362
// begin tmp := tmp union j ;
31332: LD_ADDR_VAR 0 5
31336: PUSH
31337: LD_VAR 0 5
31341: PUSH
31342: LD_VAR 0 3
31346: UNION
31347: ST_TO_ADDR
// if tmp >= 5 then
31348: LD_VAR 0 5
31352: PUSH
31353: LD_INT 5
31355: GREATEREQUAL
31356: IFFALSE 31360
// break ;
31358: GO 31362
// end ;
31360: GO 31329
31362: POP
31363: POP
// end ; if not tmp then
31364: LD_VAR 0 5
31368: NOT
31369: IFFALSE 31373
// continue ;
31371: GO 30585
// for j in tmp do
31373: LD_ADDR_VAR 0 3
31377: PUSH
31378: LD_VAR 0 5
31382: PUSH
31383: FOR_IN
31384: IFFALSE 31474
// if not GetTag ( j ) then
31386: LD_VAR 0 3
31390: PPUSH
31391: CALL_OW 110
31395: NOT
31396: IFFALSE 31472
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31398: LD_ADDR_EXP 67
31402: PUSH
31403: LD_EXP 67
31407: PPUSH
31408: LD_VAR 0 2
31412: PUSH
31413: LD_EXP 67
31417: PUSH
31418: LD_VAR 0 2
31422: ARRAY
31423: PUSH
31424: LD_INT 1
31426: PLUS
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PPUSH
31432: LD_VAR 0 3
31436: PPUSH
31437: CALL 52460 0 3
31441: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31442: LD_VAR 0 3
31446: PPUSH
31447: LD_INT 107
31449: PPUSH
31450: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31454: LD_EXP 67
31458: PUSH
31459: LD_VAR 0 2
31463: ARRAY
31464: PUSH
31465: LD_INT 5
31467: GREATEREQUAL
31468: IFFALSE 31472
// break ;
31470: GO 31474
// end ;
31472: GO 31383
31474: POP
31475: POP
// end ; if mc_crates_collector [ i ] and target then
31476: LD_EXP 67
31480: PUSH
31481: LD_VAR 0 2
31485: ARRAY
31486: PUSH
31487: LD_VAR 0 6
31491: AND
31492: IFFALSE 31735
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31494: LD_EXP 67
31498: PUSH
31499: LD_VAR 0 2
31503: ARRAY
31504: PUSH
31505: LD_VAR 0 6
31509: PUSH
31510: LD_INT 1
31512: ARRAY
31513: LESS
31514: IFFALSE 31534
// tmp := mc_crates_collector [ i ] else
31516: LD_ADDR_VAR 0 5
31520: PUSH
31521: LD_EXP 67
31525: PUSH
31526: LD_VAR 0 2
31530: ARRAY
31531: ST_TO_ADDR
31532: GO 31548
// tmp := target [ 1 ] ;
31534: LD_ADDR_VAR 0 5
31538: PUSH
31539: LD_VAR 0 6
31543: PUSH
31544: LD_INT 1
31546: ARRAY
31547: ST_TO_ADDR
// k := 0 ;
31548: LD_ADDR_VAR 0 4
31552: PUSH
31553: LD_INT 0
31555: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31556: LD_ADDR_VAR 0 3
31560: PUSH
31561: LD_EXP 67
31565: PUSH
31566: LD_VAR 0 2
31570: ARRAY
31571: PUSH
31572: FOR_IN
31573: IFFALSE 31733
// begin k := k + 1 ;
31575: LD_ADDR_VAR 0 4
31579: PUSH
31580: LD_VAR 0 4
31584: PUSH
31585: LD_INT 1
31587: PLUS
31588: ST_TO_ADDR
// if k > tmp then
31589: LD_VAR 0 4
31593: PUSH
31594: LD_VAR 0 5
31598: GREATER
31599: IFFALSE 31603
// break ;
31601: GO 31733
// if not GetClass ( j ) in [ 2 , 16 ] then
31603: LD_VAR 0 3
31607: PPUSH
31608: CALL_OW 257
31612: PUSH
31613: LD_INT 2
31615: PUSH
31616: LD_INT 16
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: IN
31623: NOT
31624: IFFALSE 31677
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31626: LD_ADDR_EXP 67
31630: PUSH
31631: LD_EXP 67
31635: PPUSH
31636: LD_VAR 0 2
31640: PPUSH
31641: LD_EXP 67
31645: PUSH
31646: LD_VAR 0 2
31650: ARRAY
31651: PUSH
31652: LD_VAR 0 3
31656: DIFF
31657: PPUSH
31658: CALL_OW 1
31662: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31663: LD_VAR 0 3
31667: PPUSH
31668: LD_INT 0
31670: PPUSH
31671: CALL_OW 109
// continue ;
31675: GO 31572
// end ; if IsInUnit ( j ) then
31677: LD_VAR 0 3
31681: PPUSH
31682: CALL_OW 310
31686: IFFALSE 31697
// ComExitBuilding ( j ) ;
31688: LD_VAR 0 3
31692: PPUSH
31693: CALL_OW 122
// wait ( 3 ) ;
31697: LD_INT 3
31699: PPUSH
31700: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31704: LD_VAR 0 3
31708: PPUSH
31709: LD_VAR 0 6
31713: PUSH
31714: LD_INT 2
31716: ARRAY
31717: PPUSH
31718: LD_VAR 0 6
31722: PUSH
31723: LD_INT 3
31725: ARRAY
31726: PPUSH
31727: CALL_OW 117
// end ;
31731: GO 31572
31733: POP
31734: POP
// end ; end else
31735: GO 32316
// begin for j in cargo do
31737: LD_ADDR_VAR 0 3
31741: PUSH
31742: LD_VAR 0 7
31746: PUSH
31747: FOR_IN
31748: IFFALSE 32314
// begin if GetTag ( j ) <> 0 then
31750: LD_VAR 0 3
31754: PPUSH
31755: CALL_OW 110
31759: PUSH
31760: LD_INT 0
31762: NONEQUAL
31763: IFFALSE 31767
// continue ;
31765: GO 31747
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31767: LD_VAR 0 3
31771: PPUSH
31772: CALL_OW 256
31776: PUSH
31777: LD_INT 1000
31779: LESS
31780: PUSH
31781: LD_VAR 0 3
31785: PPUSH
31786: LD_EXP 74
31790: PUSH
31791: LD_VAR 0 2
31795: ARRAY
31796: PPUSH
31797: CALL_OW 308
31801: NOT
31802: AND
31803: IFFALSE 31825
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31805: LD_VAR 0 3
31809: PPUSH
31810: LD_EXP 74
31814: PUSH
31815: LD_VAR 0 2
31819: ARRAY
31820: PPUSH
31821: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31825: LD_VAR 0 3
31829: PPUSH
31830: CALL_OW 256
31834: PUSH
31835: LD_INT 1000
31837: LESS
31838: PUSH
31839: LD_VAR 0 3
31843: PPUSH
31844: LD_EXP 74
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: PPUSH
31855: CALL_OW 308
31859: AND
31860: IFFALSE 31864
// continue ;
31862: GO 31747
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31864: LD_VAR 0 3
31868: PPUSH
31869: CALL_OW 262
31873: PUSH
31874: LD_INT 2
31876: EQUAL
31877: PUSH
31878: LD_VAR 0 3
31882: PPUSH
31883: CALL_OW 261
31887: PUSH
31888: LD_INT 15
31890: LESS
31891: AND
31892: IFFALSE 31896
// continue ;
31894: GO 31747
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31896: LD_VAR 0 3
31900: PPUSH
31901: CALL_OW 262
31905: PUSH
31906: LD_INT 1
31908: EQUAL
31909: PUSH
31910: LD_VAR 0 3
31914: PPUSH
31915: CALL_OW 261
31919: PUSH
31920: LD_INT 10
31922: LESS
31923: AND
31924: IFFALSE 32253
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31926: LD_ADDR_VAR 0 8
31930: PUSH
31931: LD_EXP 50
31935: PUSH
31936: LD_VAR 0 2
31940: ARRAY
31941: PPUSH
31942: LD_INT 2
31944: PUSH
31945: LD_INT 30
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 30
31957: PUSH
31958: LD_INT 1
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: LIST
31969: PPUSH
31970: CALL_OW 72
31974: ST_TO_ADDR
// if not depot then
31975: LD_VAR 0 8
31979: NOT
31980: IFFALSE 31984
// continue ;
31982: GO 31747
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31984: LD_VAR 0 3
31988: PPUSH
31989: LD_VAR 0 8
31993: PPUSH
31994: LD_VAR 0 3
31998: PPUSH
31999: CALL_OW 74
32003: PPUSH
32004: CALL_OW 296
32008: PUSH
32009: LD_INT 6
32011: LESS
32012: IFFALSE 32028
// SetFuel ( j , 100 ) else
32014: LD_VAR 0 3
32018: PPUSH
32019: LD_INT 100
32021: PPUSH
32022: CALL_OW 240
32026: GO 32253
// if GetFuel ( j ) = 0 then
32028: LD_VAR 0 3
32032: PPUSH
32033: CALL_OW 261
32037: PUSH
32038: LD_INT 0
32040: EQUAL
32041: IFFALSE 32253
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32043: LD_ADDR_EXP 69
32047: PUSH
32048: LD_EXP 69
32052: PPUSH
32053: LD_VAR 0 2
32057: PPUSH
32058: LD_EXP 69
32062: PUSH
32063: LD_VAR 0 2
32067: ARRAY
32068: PUSH
32069: LD_VAR 0 3
32073: DIFF
32074: PPUSH
32075: CALL_OW 1
32079: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32080: LD_VAR 0 3
32084: PPUSH
32085: CALL_OW 263
32089: PUSH
32090: LD_INT 1
32092: EQUAL
32093: IFFALSE 32109
// ComExitVehicle ( IsInUnit ( j ) ) ;
32095: LD_VAR 0 3
32099: PPUSH
32100: CALL_OW 310
32104: PPUSH
32105: CALL_OW 121
// if GetControl ( j ) = control_remote then
32109: LD_VAR 0 3
32113: PPUSH
32114: CALL_OW 263
32118: PUSH
32119: LD_INT 2
32121: EQUAL
32122: IFFALSE 32133
// ComUnlink ( j ) ;
32124: LD_VAR 0 3
32128: PPUSH
32129: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32133: LD_ADDR_VAR 0 9
32137: PUSH
32138: LD_VAR 0 2
32142: PPUSH
32143: LD_INT 3
32145: PPUSH
32146: CALL 41606 0 2
32150: ST_TO_ADDR
// if fac then
32151: LD_VAR 0 9
32155: IFFALSE 32251
// begin for k in fac do
32157: LD_ADDR_VAR 0 4
32161: PUSH
32162: LD_VAR 0 9
32166: PUSH
32167: FOR_IN
32168: IFFALSE 32249
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32170: LD_ADDR_VAR 0 10
32174: PUSH
32175: LD_VAR 0 9
32179: PPUSH
32180: LD_VAR 0 3
32184: PPUSH
32185: CALL_OW 265
32189: PPUSH
32190: LD_VAR 0 3
32194: PPUSH
32195: CALL_OW 262
32199: PPUSH
32200: LD_VAR 0 3
32204: PPUSH
32205: CALL_OW 263
32209: PPUSH
32210: LD_VAR 0 3
32214: PPUSH
32215: CALL_OW 264
32219: PPUSH
32220: CALL 49992 0 5
32224: ST_TO_ADDR
// if components then
32225: LD_VAR 0 10
32229: IFFALSE 32247
// begin MC_InsertProduceList ( i , components ) ;
32231: LD_VAR 0 2
32235: PPUSH
32236: LD_VAR 0 10
32240: PPUSH
32241: CALL 41151 0 2
// break ;
32245: GO 32249
// end ; end ;
32247: GO 32167
32249: POP
32250: POP
// end ; continue ;
32251: GO 31747
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32253: LD_VAR 0 3
32257: PPUSH
32258: LD_INT 1
32260: PPUSH
32261: CALL_OW 289
32265: PUSH
32266: LD_INT 100
32268: LESS
32269: PUSH
32270: LD_VAR 0 3
32274: PPUSH
32275: CALL_OW 314
32279: NOT
32280: AND
32281: IFFALSE 32310
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32283: LD_VAR 0 3
32287: PPUSH
32288: LD_VAR 0 6
32292: PUSH
32293: LD_INT 2
32295: ARRAY
32296: PPUSH
32297: LD_VAR 0 6
32301: PUSH
32302: LD_INT 3
32304: ARRAY
32305: PPUSH
32306: CALL_OW 117
// break ;
32310: GO 32314
// end ;
32312: GO 31747
32314: POP
32315: POP
// end ; end ;
32316: GO 30585
32318: POP
32319: POP
// end ;
32320: LD_VAR 0 1
32324: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32325: LD_INT 0
32327: PPUSH
32328: PPUSH
32329: PPUSH
32330: PPUSH
// if not mc_bases then
32331: LD_EXP 50
32335: NOT
32336: IFFALSE 32340
// exit ;
32338: GO 32501
// for i = 1 to mc_bases do
32340: LD_ADDR_VAR 0 2
32344: PUSH
32345: DOUBLE
32346: LD_INT 1
32348: DEC
32349: ST_TO_ADDR
32350: LD_EXP 50
32354: PUSH
32355: FOR_TO
32356: IFFALSE 32499
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32358: LD_ADDR_VAR 0 4
32362: PUSH
32363: LD_EXP 69
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: PUSH
32374: LD_EXP 72
32378: PUSH
32379: LD_VAR 0 2
32383: ARRAY
32384: UNION
32385: PPUSH
32386: LD_INT 33
32388: PUSH
32389: LD_INT 2
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PPUSH
32396: CALL_OW 72
32400: ST_TO_ADDR
// if tmp then
32401: LD_VAR 0 4
32405: IFFALSE 32497
// for j in tmp do
32407: LD_ADDR_VAR 0 3
32411: PUSH
32412: LD_VAR 0 4
32416: PUSH
32417: FOR_IN
32418: IFFALSE 32495
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32420: LD_VAR 0 3
32424: PPUSH
32425: CALL_OW 312
32429: NOT
32430: PUSH
32431: LD_VAR 0 3
32435: PPUSH
32436: CALL_OW 256
32440: PUSH
32441: LD_INT 250
32443: GREATEREQUAL
32444: AND
32445: IFFALSE 32458
// Connect ( j ) else
32447: LD_VAR 0 3
32451: PPUSH
32452: CALL 55393 0 1
32456: GO 32493
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32458: LD_VAR 0 3
32462: PPUSH
32463: CALL_OW 256
32467: PUSH
32468: LD_INT 250
32470: LESS
32471: PUSH
32472: LD_VAR 0 3
32476: PPUSH
32477: CALL_OW 312
32481: AND
32482: IFFALSE 32493
// ComUnlink ( j ) ;
32484: LD_VAR 0 3
32488: PPUSH
32489: CALL_OW 136
32493: GO 32417
32495: POP
32496: POP
// end ;
32497: GO 32355
32499: POP
32500: POP
// end ;
32501: LD_VAR 0 1
32505: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32506: LD_INT 0
32508: PPUSH
32509: PPUSH
32510: PPUSH
32511: PPUSH
32512: PPUSH
// if not mc_bases then
32513: LD_EXP 50
32517: NOT
32518: IFFALSE 32522
// exit ;
32520: GO 32967
// for i = 1 to mc_bases do
32522: LD_ADDR_VAR 0 2
32526: PUSH
32527: DOUBLE
32528: LD_INT 1
32530: DEC
32531: ST_TO_ADDR
32532: LD_EXP 50
32536: PUSH
32537: FOR_TO
32538: IFFALSE 32965
// begin if not mc_produce [ i ] then
32540: LD_EXP 71
32544: PUSH
32545: LD_VAR 0 2
32549: ARRAY
32550: NOT
32551: IFFALSE 32555
// continue ;
32553: GO 32537
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32555: LD_ADDR_VAR 0 5
32559: PUSH
32560: LD_EXP 50
32564: PUSH
32565: LD_VAR 0 2
32569: ARRAY
32570: PPUSH
32571: LD_INT 30
32573: PUSH
32574: LD_INT 3
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PPUSH
32581: CALL_OW 72
32585: ST_TO_ADDR
// if not fac then
32586: LD_VAR 0 5
32590: NOT
32591: IFFALSE 32595
// continue ;
32593: GO 32537
// for j in fac do
32595: LD_ADDR_VAR 0 3
32599: PUSH
32600: LD_VAR 0 5
32604: PUSH
32605: FOR_IN
32606: IFFALSE 32961
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32608: LD_VAR 0 3
32612: PPUSH
32613: CALL_OW 461
32617: PUSH
32618: LD_INT 2
32620: NONEQUAL
32621: PUSH
32622: LD_VAR 0 3
32626: PPUSH
32627: LD_INT 15
32629: PPUSH
32630: CALL 55053 0 2
32634: PUSH
32635: LD_INT 4
32637: ARRAY
32638: OR
32639: IFFALSE 32643
// continue ;
32641: GO 32605
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32643: LD_VAR 0 3
32647: PPUSH
32648: LD_EXP 71
32652: PUSH
32653: LD_VAR 0 2
32657: ARRAY
32658: PUSH
32659: LD_INT 1
32661: ARRAY
32662: PUSH
32663: LD_INT 1
32665: ARRAY
32666: PPUSH
32667: LD_EXP 71
32671: PUSH
32672: LD_VAR 0 2
32676: ARRAY
32677: PUSH
32678: LD_INT 1
32680: ARRAY
32681: PUSH
32682: LD_INT 2
32684: ARRAY
32685: PPUSH
32686: LD_EXP 71
32690: PUSH
32691: LD_VAR 0 2
32695: ARRAY
32696: PUSH
32697: LD_INT 1
32699: ARRAY
32700: PUSH
32701: LD_INT 3
32703: ARRAY
32704: PPUSH
32705: LD_EXP 71
32709: PUSH
32710: LD_VAR 0 2
32714: ARRAY
32715: PUSH
32716: LD_INT 1
32718: ARRAY
32719: PUSH
32720: LD_INT 4
32722: ARRAY
32723: PPUSH
32724: CALL_OW 448
32728: PUSH
32729: LD_VAR 0 3
32733: PPUSH
32734: LD_EXP 71
32738: PUSH
32739: LD_VAR 0 2
32743: ARRAY
32744: PUSH
32745: LD_INT 1
32747: ARRAY
32748: PUSH
32749: LD_INT 1
32751: ARRAY
32752: PUSH
32753: LD_EXP 71
32757: PUSH
32758: LD_VAR 0 2
32762: ARRAY
32763: PUSH
32764: LD_INT 1
32766: ARRAY
32767: PUSH
32768: LD_INT 2
32770: ARRAY
32771: PUSH
32772: LD_EXP 71
32776: PUSH
32777: LD_VAR 0 2
32781: ARRAY
32782: PUSH
32783: LD_INT 1
32785: ARRAY
32786: PUSH
32787: LD_INT 3
32789: ARRAY
32790: PUSH
32791: LD_EXP 71
32795: PUSH
32796: LD_VAR 0 2
32800: ARRAY
32801: PUSH
32802: LD_INT 1
32804: ARRAY
32805: PUSH
32806: LD_INT 4
32808: ARRAY
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: LIST
32814: LIST
32815: PPUSH
32816: CALL 58724 0 2
32820: AND
32821: IFFALSE 32959
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32823: LD_VAR 0 3
32827: PPUSH
32828: LD_EXP 71
32832: PUSH
32833: LD_VAR 0 2
32837: ARRAY
32838: PUSH
32839: LD_INT 1
32841: ARRAY
32842: PUSH
32843: LD_INT 1
32845: ARRAY
32846: PPUSH
32847: LD_EXP 71
32851: PUSH
32852: LD_VAR 0 2
32856: ARRAY
32857: PUSH
32858: LD_INT 1
32860: ARRAY
32861: PUSH
32862: LD_INT 2
32864: ARRAY
32865: PPUSH
32866: LD_EXP 71
32870: PUSH
32871: LD_VAR 0 2
32875: ARRAY
32876: PUSH
32877: LD_INT 1
32879: ARRAY
32880: PUSH
32881: LD_INT 3
32883: ARRAY
32884: PPUSH
32885: LD_EXP 71
32889: PUSH
32890: LD_VAR 0 2
32894: ARRAY
32895: PUSH
32896: LD_INT 1
32898: ARRAY
32899: PUSH
32900: LD_INT 4
32902: ARRAY
32903: PPUSH
32904: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32908: LD_ADDR_VAR 0 4
32912: PUSH
32913: LD_EXP 71
32917: PUSH
32918: LD_VAR 0 2
32922: ARRAY
32923: PPUSH
32924: LD_INT 1
32926: PPUSH
32927: CALL_OW 3
32931: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32932: LD_ADDR_EXP 71
32936: PUSH
32937: LD_EXP 71
32941: PPUSH
32942: LD_VAR 0 2
32946: PPUSH
32947: LD_VAR 0 4
32951: PPUSH
32952: CALL_OW 1
32956: ST_TO_ADDR
// break ;
32957: GO 32961
// end ; end ;
32959: GO 32605
32961: POP
32962: POP
// end ;
32963: GO 32537
32965: POP
32966: POP
// end ;
32967: LD_VAR 0 1
32971: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32972: LD_INT 0
32974: PPUSH
32975: PPUSH
32976: PPUSH
// if not mc_bases then
32977: LD_EXP 50
32981: NOT
32982: IFFALSE 32986
// exit ;
32984: GO 33075
// for i = 1 to mc_bases do
32986: LD_ADDR_VAR 0 2
32990: PUSH
32991: DOUBLE
32992: LD_INT 1
32994: DEC
32995: ST_TO_ADDR
32996: LD_EXP 50
33000: PUSH
33001: FOR_TO
33002: IFFALSE 33073
// begin if mc_attack [ i ] then
33004: LD_EXP 70
33008: PUSH
33009: LD_VAR 0 2
33013: ARRAY
33014: IFFALSE 33071
// begin tmp := mc_attack [ i ] [ 1 ] ;
33016: LD_ADDR_VAR 0 3
33020: PUSH
33021: LD_EXP 70
33025: PUSH
33026: LD_VAR 0 2
33030: ARRAY
33031: PUSH
33032: LD_INT 1
33034: ARRAY
33035: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33036: LD_ADDR_EXP 70
33040: PUSH
33041: LD_EXP 70
33045: PPUSH
33046: LD_VAR 0 2
33050: PPUSH
33051: EMPTY
33052: PPUSH
33053: CALL_OW 1
33057: ST_TO_ADDR
// Attack ( tmp ) ;
33058: LD_VAR 0 3
33062: PPUSH
33063: CALL 101883 0 1
// exit ;
33067: POP
33068: POP
33069: GO 33075
// end ; end ;
33071: GO 33001
33073: POP
33074: POP
// end ;
33075: LD_VAR 0 1
33079: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33080: LD_INT 0
33082: PPUSH
33083: PPUSH
33084: PPUSH
33085: PPUSH
33086: PPUSH
33087: PPUSH
33088: PPUSH
// if not mc_bases then
33089: LD_EXP 50
33093: NOT
33094: IFFALSE 33098
// exit ;
33096: GO 33680
// for i = 1 to mc_bases do
33098: LD_ADDR_VAR 0 2
33102: PUSH
33103: DOUBLE
33104: LD_INT 1
33106: DEC
33107: ST_TO_ADDR
33108: LD_EXP 50
33112: PUSH
33113: FOR_TO
33114: IFFALSE 33678
// begin if not mc_bases [ i ] then
33116: LD_EXP 50
33120: PUSH
33121: LD_VAR 0 2
33125: ARRAY
33126: NOT
33127: IFFALSE 33131
// continue ;
33129: GO 33113
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33131: LD_ADDR_VAR 0 7
33135: PUSH
33136: LD_EXP 50
33140: PUSH
33141: LD_VAR 0 2
33145: ARRAY
33146: PUSH
33147: LD_INT 1
33149: ARRAY
33150: PPUSH
33151: CALL 49296 0 1
33155: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33156: LD_ADDR_EXP 73
33160: PUSH
33161: LD_EXP 73
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: LD_EXP 50
33175: PUSH
33176: LD_VAR 0 2
33180: ARRAY
33181: PUSH
33182: LD_INT 1
33184: ARRAY
33185: PPUSH
33186: CALL_OW 255
33190: PPUSH
33191: LD_EXP 75
33195: PUSH
33196: LD_VAR 0 2
33200: ARRAY
33201: PPUSH
33202: CALL 49261 0 2
33206: PPUSH
33207: CALL_OW 1
33211: ST_TO_ADDR
// if not mc_scan [ i ] then
33212: LD_EXP 73
33216: PUSH
33217: LD_VAR 0 2
33221: ARRAY
33222: NOT
33223: IFFALSE 33378
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33225: LD_ADDR_VAR 0 4
33229: PUSH
33230: LD_EXP 50
33234: PUSH
33235: LD_VAR 0 2
33239: ARRAY
33240: PPUSH
33241: LD_INT 2
33243: PUSH
33244: LD_INT 25
33246: PUSH
33247: LD_INT 5
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 25
33256: PUSH
33257: LD_INT 8
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 25
33266: PUSH
33267: LD_INT 9
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: PPUSH
33280: CALL_OW 72
33284: ST_TO_ADDR
// if not tmp then
33285: LD_VAR 0 4
33289: NOT
33290: IFFALSE 33294
// continue ;
33292: GO 33113
// for j in tmp do
33294: LD_ADDR_VAR 0 3
33298: PUSH
33299: LD_VAR 0 4
33303: PUSH
33304: FOR_IN
33305: IFFALSE 33376
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33307: LD_VAR 0 3
33311: PPUSH
33312: CALL_OW 310
33316: PPUSH
33317: CALL_OW 266
33321: PUSH
33322: LD_INT 5
33324: EQUAL
33325: PUSH
33326: LD_VAR 0 3
33330: PPUSH
33331: CALL_OW 257
33335: PUSH
33336: LD_INT 1
33338: EQUAL
33339: AND
33340: PUSH
33341: LD_VAR 0 3
33345: PPUSH
33346: CALL_OW 459
33350: NOT
33351: AND
33352: PUSH
33353: LD_VAR 0 7
33357: AND
33358: IFFALSE 33374
// ComChangeProfession ( j , class ) ;
33360: LD_VAR 0 3
33364: PPUSH
33365: LD_VAR 0 7
33369: PPUSH
33370: CALL_OW 123
33374: GO 33304
33376: POP
33377: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33378: LD_EXP 73
33382: PUSH
33383: LD_VAR 0 2
33387: ARRAY
33388: PUSH
33389: LD_EXP 72
33393: PUSH
33394: LD_VAR 0 2
33398: ARRAY
33399: NOT
33400: AND
33401: PUSH
33402: LD_EXP 50
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PPUSH
33413: LD_INT 30
33415: PUSH
33416: LD_INT 32
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PPUSH
33423: CALL_OW 72
33427: NOT
33428: AND
33429: PUSH
33430: LD_EXP 50
33434: PUSH
33435: LD_VAR 0 2
33439: ARRAY
33440: PPUSH
33441: LD_INT 2
33443: PUSH
33444: LD_INT 30
33446: PUSH
33447: LD_INT 4
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 30
33456: PUSH
33457: LD_INT 5
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: LIST
33468: PPUSH
33469: CALL_OW 72
33473: NOT
33474: AND
33475: IFFALSE 33607
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33477: LD_ADDR_VAR 0 4
33481: PUSH
33482: LD_EXP 50
33486: PUSH
33487: LD_VAR 0 2
33491: ARRAY
33492: PPUSH
33493: LD_INT 2
33495: PUSH
33496: LD_INT 25
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 25
33508: PUSH
33509: LD_INT 5
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 25
33518: PUSH
33519: LD_INT 8
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 25
33528: PUSH
33529: LD_INT 9
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: LIST
33540: LIST
33541: LIST
33542: PPUSH
33543: CALL_OW 72
33547: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33548: LD_ADDR_VAR 0 4
33552: PUSH
33553: LD_VAR 0 4
33557: PUSH
33558: LD_VAR 0 4
33562: PPUSH
33563: LD_INT 18
33565: PPUSH
33566: CALL 81021 0 2
33570: DIFF
33571: ST_TO_ADDR
// if tmp then
33572: LD_VAR 0 4
33576: IFFALSE 33607
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33578: LD_VAR 0 2
33582: PPUSH
33583: LD_VAR 0 4
33587: PPUSH
33588: LD_EXP 75
33592: PUSH
33593: LD_VAR 0 2
33597: ARRAY
33598: PPUSH
33599: CALL 106592 0 3
// exit ;
33603: POP
33604: POP
33605: GO 33680
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33607: LD_EXP 73
33611: PUSH
33612: LD_VAR 0 2
33616: ARRAY
33617: PUSH
33618: LD_EXP 72
33622: PUSH
33623: LD_VAR 0 2
33627: ARRAY
33628: AND
33629: IFFALSE 33676
// begin tmp := mc_defender [ i ] ;
33631: LD_ADDR_VAR 0 4
33635: PUSH
33636: LD_EXP 72
33640: PUSH
33641: LD_VAR 0 2
33645: ARRAY
33646: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33647: LD_VAR 0 2
33651: PPUSH
33652: LD_VAR 0 4
33656: PPUSH
33657: LD_EXP 73
33661: PUSH
33662: LD_VAR 0 2
33666: ARRAY
33667: PPUSH
33668: CALL 107153 0 3
// exit ;
33672: POP
33673: POP
33674: GO 33680
// end ; end ;
33676: GO 33113
33678: POP
33679: POP
// end ;
33680: LD_VAR 0 1
33684: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33685: LD_INT 0
33687: PPUSH
33688: PPUSH
33689: PPUSH
33690: PPUSH
33691: PPUSH
33692: PPUSH
33693: PPUSH
33694: PPUSH
33695: PPUSH
33696: PPUSH
33697: PPUSH
// if not mc_bases then
33698: LD_EXP 50
33702: NOT
33703: IFFALSE 33707
// exit ;
33705: GO 34794
// for i = 1 to mc_bases do
33707: LD_ADDR_VAR 0 2
33711: PUSH
33712: DOUBLE
33713: LD_INT 1
33715: DEC
33716: ST_TO_ADDR
33717: LD_EXP 50
33721: PUSH
33722: FOR_TO
33723: IFFALSE 34792
// begin tmp := mc_lab [ i ] ;
33725: LD_ADDR_VAR 0 6
33729: PUSH
33730: LD_EXP 83
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: ST_TO_ADDR
// if not tmp then
33741: LD_VAR 0 6
33745: NOT
33746: IFFALSE 33750
// continue ;
33748: GO 33722
// idle_lab := 0 ;
33750: LD_ADDR_VAR 0 11
33754: PUSH
33755: LD_INT 0
33757: ST_TO_ADDR
// for j in tmp do
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: LD_VAR 0 6
33767: PUSH
33768: FOR_IN
33769: IFFALSE 34788
// begin researching := false ;
33771: LD_ADDR_VAR 0 10
33775: PUSH
33776: LD_INT 0
33778: ST_TO_ADDR
// side := GetSide ( j ) ;
33779: LD_ADDR_VAR 0 4
33783: PUSH
33784: LD_VAR 0 3
33788: PPUSH
33789: CALL_OW 255
33793: ST_TO_ADDR
// if not mc_tech [ side ] then
33794: LD_EXP 77
33798: PUSH
33799: LD_VAR 0 4
33803: ARRAY
33804: NOT
33805: IFFALSE 33809
// continue ;
33807: GO 33768
// if BuildingStatus ( j ) = bs_idle then
33809: LD_VAR 0 3
33813: PPUSH
33814: CALL_OW 461
33818: PUSH
33819: LD_INT 2
33821: EQUAL
33822: IFFALSE 34010
// begin if idle_lab and UnitsInside ( j ) < 6 then
33824: LD_VAR 0 11
33828: PUSH
33829: LD_VAR 0 3
33833: PPUSH
33834: CALL_OW 313
33838: PUSH
33839: LD_INT 6
33841: LESS
33842: AND
33843: IFFALSE 33914
// begin tmp2 := UnitsInside ( idle_lab ) ;
33845: LD_ADDR_VAR 0 9
33849: PUSH
33850: LD_VAR 0 11
33854: PPUSH
33855: CALL_OW 313
33859: ST_TO_ADDR
// if tmp2 then
33860: LD_VAR 0 9
33864: IFFALSE 33906
// for x in tmp2 do
33866: LD_ADDR_VAR 0 7
33870: PUSH
33871: LD_VAR 0 9
33875: PUSH
33876: FOR_IN
33877: IFFALSE 33904
// begin ComExitBuilding ( x ) ;
33879: LD_VAR 0 7
33883: PPUSH
33884: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33888: LD_VAR 0 7
33892: PPUSH
33893: LD_VAR 0 3
33897: PPUSH
33898: CALL_OW 180
// end ;
33902: GO 33876
33904: POP
33905: POP
// idle_lab := 0 ;
33906: LD_ADDR_VAR 0 11
33910: PUSH
33911: LD_INT 0
33913: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33914: LD_ADDR_VAR 0 5
33918: PUSH
33919: LD_EXP 77
33923: PUSH
33924: LD_VAR 0 4
33928: ARRAY
33929: PUSH
33930: FOR_IN
33931: IFFALSE 33991
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33933: LD_VAR 0 3
33937: PPUSH
33938: LD_VAR 0 5
33942: PPUSH
33943: CALL_OW 430
33947: PUSH
33948: LD_VAR 0 4
33952: PPUSH
33953: LD_VAR 0 5
33957: PPUSH
33958: CALL 48366 0 2
33962: AND
33963: IFFALSE 33989
// begin researching := true ;
33965: LD_ADDR_VAR 0 10
33969: PUSH
33970: LD_INT 1
33972: ST_TO_ADDR
// ComResearch ( j , t ) ;
33973: LD_VAR 0 3
33977: PPUSH
33978: LD_VAR 0 5
33982: PPUSH
33983: CALL_OW 124
// break ;
33987: GO 33991
// end ;
33989: GO 33930
33991: POP
33992: POP
// if not researching then
33993: LD_VAR 0 10
33997: NOT
33998: IFFALSE 34010
// idle_lab := j ;
34000: LD_ADDR_VAR 0 11
34004: PUSH
34005: LD_VAR 0 3
34009: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34010: LD_VAR 0 3
34014: PPUSH
34015: CALL_OW 461
34019: PUSH
34020: LD_INT 10
34022: EQUAL
34023: IFFALSE 34611
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34025: LD_EXP 79
34029: PUSH
34030: LD_VAR 0 2
34034: ARRAY
34035: NOT
34036: PUSH
34037: LD_EXP 80
34041: PUSH
34042: LD_VAR 0 2
34046: ARRAY
34047: NOT
34048: AND
34049: PUSH
34050: LD_EXP 77
34054: PUSH
34055: LD_VAR 0 4
34059: ARRAY
34060: PUSH
34061: LD_INT 1
34063: GREATER
34064: AND
34065: IFFALSE 34196
// begin ComCancel ( j ) ;
34067: LD_VAR 0 3
34071: PPUSH
34072: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34076: LD_ADDR_EXP 77
34080: PUSH
34081: LD_EXP 77
34085: PPUSH
34086: LD_VAR 0 4
34090: PPUSH
34091: LD_EXP 77
34095: PUSH
34096: LD_VAR 0 4
34100: ARRAY
34101: PPUSH
34102: LD_EXP 77
34106: PUSH
34107: LD_VAR 0 4
34111: ARRAY
34112: PUSH
34113: LD_INT 1
34115: MINUS
34116: PPUSH
34117: LD_EXP 77
34121: PUSH
34122: LD_VAR 0 4
34126: ARRAY
34127: PPUSH
34128: LD_INT 0
34130: PPUSH
34131: CALL 51878 0 4
34135: PPUSH
34136: CALL_OW 1
34140: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34141: LD_ADDR_EXP 77
34145: PUSH
34146: LD_EXP 77
34150: PPUSH
34151: LD_VAR 0 4
34155: PPUSH
34156: LD_EXP 77
34160: PUSH
34161: LD_VAR 0 4
34165: ARRAY
34166: PPUSH
34167: LD_EXP 77
34171: PUSH
34172: LD_VAR 0 4
34176: ARRAY
34177: PPUSH
34178: LD_INT 1
34180: PPUSH
34181: LD_INT 0
34183: PPUSH
34184: CALL 51878 0 4
34188: PPUSH
34189: CALL_OW 1
34193: ST_TO_ADDR
// continue ;
34194: GO 33768
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34196: LD_EXP 79
34200: PUSH
34201: LD_VAR 0 2
34205: ARRAY
34206: PUSH
34207: LD_EXP 80
34211: PUSH
34212: LD_VAR 0 2
34216: ARRAY
34217: NOT
34218: AND
34219: IFFALSE 34346
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34221: LD_ADDR_EXP 80
34225: PUSH
34226: LD_EXP 80
34230: PPUSH
34231: LD_VAR 0 2
34235: PUSH
34236: LD_EXP 80
34240: PUSH
34241: LD_VAR 0 2
34245: ARRAY
34246: PUSH
34247: LD_INT 1
34249: PLUS
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PPUSH
34255: LD_EXP 79
34259: PUSH
34260: LD_VAR 0 2
34264: ARRAY
34265: PUSH
34266: LD_INT 1
34268: ARRAY
34269: PPUSH
34270: CALL 52460 0 3
34274: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34275: LD_EXP 79
34279: PUSH
34280: LD_VAR 0 2
34284: ARRAY
34285: PUSH
34286: LD_INT 1
34288: ARRAY
34289: PPUSH
34290: LD_INT 112
34292: PPUSH
34293: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34297: LD_ADDR_VAR 0 9
34301: PUSH
34302: LD_EXP 79
34306: PUSH
34307: LD_VAR 0 2
34311: ARRAY
34312: PPUSH
34313: LD_INT 1
34315: PPUSH
34316: CALL_OW 3
34320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34321: LD_ADDR_EXP 79
34325: PUSH
34326: LD_EXP 79
34330: PPUSH
34331: LD_VAR 0 2
34335: PPUSH
34336: LD_VAR 0 9
34340: PPUSH
34341: CALL_OW 1
34345: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34346: LD_EXP 79
34350: PUSH
34351: LD_VAR 0 2
34355: ARRAY
34356: PUSH
34357: LD_EXP 80
34361: PUSH
34362: LD_VAR 0 2
34366: ARRAY
34367: AND
34368: PUSH
34369: LD_EXP 80
34373: PUSH
34374: LD_VAR 0 2
34378: ARRAY
34379: PUSH
34380: LD_INT 1
34382: ARRAY
34383: PPUSH
34384: CALL_OW 310
34388: NOT
34389: AND
34390: PUSH
34391: LD_VAR 0 3
34395: PPUSH
34396: CALL_OW 313
34400: PUSH
34401: LD_INT 6
34403: EQUAL
34404: AND
34405: IFFALSE 34461
// begin tmp2 := UnitsInside ( j ) ;
34407: LD_ADDR_VAR 0 9
34411: PUSH
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL_OW 313
34421: ST_TO_ADDR
// if tmp2 = 6 then
34422: LD_VAR 0 9
34426: PUSH
34427: LD_INT 6
34429: EQUAL
34430: IFFALSE 34461
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34432: LD_VAR 0 9
34436: PUSH
34437: LD_INT 1
34439: ARRAY
34440: PPUSH
34441: LD_INT 112
34443: PPUSH
34444: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34448: LD_VAR 0 9
34452: PUSH
34453: LD_INT 1
34455: ARRAY
34456: PPUSH
34457: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34461: LD_EXP 80
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PUSH
34472: LD_EXP 80
34476: PUSH
34477: LD_VAR 0 2
34481: ARRAY
34482: PUSH
34483: LD_INT 1
34485: ARRAY
34486: PPUSH
34487: CALL_OW 314
34491: NOT
34492: AND
34493: PUSH
34494: LD_EXP 80
34498: PUSH
34499: LD_VAR 0 2
34503: ARRAY
34504: PUSH
34505: LD_INT 1
34507: ARRAY
34508: PPUSH
34509: CALL_OW 310
34513: NOT
34514: AND
34515: IFFALSE 34541
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34517: LD_EXP 80
34521: PUSH
34522: LD_VAR 0 2
34526: ARRAY
34527: PUSH
34528: LD_INT 1
34530: ARRAY
34531: PPUSH
34532: LD_VAR 0 3
34536: PPUSH
34537: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34541: LD_EXP 80
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: PUSH
34552: LD_INT 1
34554: ARRAY
34555: PPUSH
34556: CALL_OW 310
34560: PUSH
34561: LD_EXP 80
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PUSH
34572: LD_INT 1
34574: ARRAY
34575: PPUSH
34576: CALL_OW 310
34580: PPUSH
34581: CALL_OW 461
34585: PUSH
34586: LD_INT 3
34588: NONEQUAL
34589: AND
34590: IFFALSE 34611
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34592: LD_EXP 80
34596: PUSH
34597: LD_VAR 0 2
34601: ARRAY
34602: PUSH
34603: LD_INT 1
34605: ARRAY
34606: PPUSH
34607: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34611: LD_VAR 0 3
34615: PPUSH
34616: CALL_OW 461
34620: PUSH
34621: LD_INT 6
34623: EQUAL
34624: PUSH
34625: LD_VAR 0 6
34629: PUSH
34630: LD_INT 1
34632: GREATER
34633: AND
34634: IFFALSE 34786
// begin sci := [ ] ;
34636: LD_ADDR_VAR 0 8
34640: PUSH
34641: EMPTY
34642: ST_TO_ADDR
// for x in ( tmp diff j ) do
34643: LD_ADDR_VAR 0 7
34647: PUSH
34648: LD_VAR 0 6
34652: PUSH
34653: LD_VAR 0 3
34657: DIFF
34658: PUSH
34659: FOR_IN
34660: IFFALSE 34712
// begin if sci = 6 then
34662: LD_VAR 0 8
34666: PUSH
34667: LD_INT 6
34669: EQUAL
34670: IFFALSE 34674
// break ;
34672: GO 34712
// if BuildingStatus ( x ) = bs_idle then
34674: LD_VAR 0 7
34678: PPUSH
34679: CALL_OW 461
34683: PUSH
34684: LD_INT 2
34686: EQUAL
34687: IFFALSE 34710
// sci := sci ^ UnitsInside ( x ) ;
34689: LD_ADDR_VAR 0 8
34693: PUSH
34694: LD_VAR 0 8
34698: PUSH
34699: LD_VAR 0 7
34703: PPUSH
34704: CALL_OW 313
34708: ADD
34709: ST_TO_ADDR
// end ;
34710: GO 34659
34712: POP
34713: POP
// if not sci then
34714: LD_VAR 0 8
34718: NOT
34719: IFFALSE 34723
// continue ;
34721: GO 33768
// for x in sci do
34723: LD_ADDR_VAR 0 7
34727: PUSH
34728: LD_VAR 0 8
34732: PUSH
34733: FOR_IN
34734: IFFALSE 34784
// if IsInUnit ( x ) and not HasTask ( x ) then
34736: LD_VAR 0 7
34740: PPUSH
34741: CALL_OW 310
34745: PUSH
34746: LD_VAR 0 7
34750: PPUSH
34751: CALL_OW 314
34755: NOT
34756: AND
34757: IFFALSE 34782
// begin ComExitBuilding ( x ) ;
34759: LD_VAR 0 7
34763: PPUSH
34764: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34768: LD_VAR 0 7
34772: PPUSH
34773: LD_VAR 0 3
34777: PPUSH
34778: CALL_OW 180
// end ;
34782: GO 34733
34784: POP
34785: POP
// end ; end ;
34786: GO 33768
34788: POP
34789: POP
// end ;
34790: GO 33722
34792: POP
34793: POP
// end ;
34794: LD_VAR 0 1
34798: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34799: LD_INT 0
34801: PPUSH
34802: PPUSH
// if not mc_bases then
34803: LD_EXP 50
34807: NOT
34808: IFFALSE 34812
// exit ;
34810: GO 34893
// for i = 1 to mc_bases do
34812: LD_ADDR_VAR 0 2
34816: PUSH
34817: DOUBLE
34818: LD_INT 1
34820: DEC
34821: ST_TO_ADDR
34822: LD_EXP 50
34826: PUSH
34827: FOR_TO
34828: IFFALSE 34891
// if mc_mines [ i ] and mc_miners [ i ] then
34830: LD_EXP 63
34834: PUSH
34835: LD_VAR 0 2
34839: ARRAY
34840: PUSH
34841: LD_EXP 64
34845: PUSH
34846: LD_VAR 0 2
34850: ARRAY
34851: AND
34852: IFFALSE 34889
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34854: LD_EXP 64
34858: PUSH
34859: LD_VAR 0 2
34863: ARRAY
34864: PUSH
34865: LD_INT 1
34867: ARRAY
34868: PPUSH
34869: CALL_OW 255
34873: PPUSH
34874: LD_EXP 63
34878: PUSH
34879: LD_VAR 0 2
34883: ARRAY
34884: PPUSH
34885: CALL 49449 0 2
34889: GO 34827
34891: POP
34892: POP
// end ;
34893: LD_VAR 0 1
34897: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34898: LD_INT 0
34900: PPUSH
34901: PPUSH
34902: PPUSH
34903: PPUSH
34904: PPUSH
34905: PPUSH
34906: PPUSH
34907: PPUSH
// if not mc_bases or not mc_parking then
34908: LD_EXP 50
34912: NOT
34913: PUSH
34914: LD_EXP 74
34918: NOT
34919: OR
34920: IFFALSE 34924
// exit ;
34922: GO 35623
// for i = 1 to mc_bases do
34924: LD_ADDR_VAR 0 2
34928: PUSH
34929: DOUBLE
34930: LD_INT 1
34932: DEC
34933: ST_TO_ADDR
34934: LD_EXP 50
34938: PUSH
34939: FOR_TO
34940: IFFALSE 35621
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34942: LD_EXP 50
34946: PUSH
34947: LD_VAR 0 2
34951: ARRAY
34952: NOT
34953: PUSH
34954: LD_EXP 74
34958: PUSH
34959: LD_VAR 0 2
34963: ARRAY
34964: NOT
34965: OR
34966: IFFALSE 34970
// continue ;
34968: GO 34939
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34970: LD_ADDR_VAR 0 5
34974: PUSH
34975: LD_EXP 50
34979: PUSH
34980: LD_VAR 0 2
34984: ARRAY
34985: PUSH
34986: LD_INT 1
34988: ARRAY
34989: PPUSH
34990: CALL_OW 255
34994: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34995: LD_ADDR_VAR 0 6
34999: PUSH
35000: LD_EXP 50
35004: PUSH
35005: LD_VAR 0 2
35009: ARRAY
35010: PPUSH
35011: LD_INT 30
35013: PUSH
35014: LD_INT 3
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PPUSH
35021: CALL_OW 72
35025: ST_TO_ADDR
// if not fac then
35026: LD_VAR 0 6
35030: NOT
35031: IFFALSE 35082
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35033: LD_ADDR_VAR 0 6
35037: PUSH
35038: LD_EXP 50
35042: PUSH
35043: LD_VAR 0 2
35047: ARRAY
35048: PPUSH
35049: LD_INT 2
35051: PUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 30
35064: PUSH
35065: LD_INT 1
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: LIST
35076: PPUSH
35077: CALL_OW 72
35081: ST_TO_ADDR
// if not fac then
35082: LD_VAR 0 6
35086: NOT
35087: IFFALSE 35091
// continue ;
35089: GO 34939
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35091: LD_ADDR_VAR 0 7
35095: PUSH
35096: LD_EXP 74
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: PPUSH
35107: LD_INT 22
35109: PUSH
35110: LD_VAR 0 5
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 21
35121: PUSH
35122: LD_INT 2
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 3
35131: PUSH
35132: LD_INT 24
35134: PUSH
35135: LD_INT 1000
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: LIST
35150: PPUSH
35151: CALL_OW 70
35155: ST_TO_ADDR
// for j in fac do
35156: LD_ADDR_VAR 0 3
35160: PUSH
35161: LD_VAR 0 6
35165: PUSH
35166: FOR_IN
35167: IFFALSE 35248
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35169: LD_ADDR_VAR 0 7
35173: PUSH
35174: LD_VAR 0 7
35178: PUSH
35179: LD_INT 22
35181: PUSH
35182: LD_VAR 0 5
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 91
35193: PUSH
35194: LD_VAR 0 3
35198: PUSH
35199: LD_INT 15
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 21
35209: PUSH
35210: LD_INT 2
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 3
35219: PUSH
35220: LD_INT 24
35222: PUSH
35223: LD_INT 1000
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: PPUSH
35240: CALL_OW 69
35244: UNION
35245: ST_TO_ADDR
35246: GO 35166
35248: POP
35249: POP
// if not vehs then
35250: LD_VAR 0 7
35254: NOT
35255: IFFALSE 35281
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35257: LD_ADDR_EXP 62
35261: PUSH
35262: LD_EXP 62
35266: PPUSH
35267: LD_VAR 0 2
35271: PPUSH
35272: EMPTY
35273: PPUSH
35274: CALL_OW 1
35278: ST_TO_ADDR
// continue ;
35279: GO 34939
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35281: LD_ADDR_VAR 0 8
35285: PUSH
35286: LD_EXP 50
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: PPUSH
35297: LD_INT 30
35299: PUSH
35300: LD_INT 3
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PPUSH
35307: CALL_OW 72
35311: ST_TO_ADDR
// if tmp then
35312: LD_VAR 0 8
35316: IFFALSE 35419
// begin for j in tmp do
35318: LD_ADDR_VAR 0 3
35322: PUSH
35323: LD_VAR 0 8
35327: PUSH
35328: FOR_IN
35329: IFFALSE 35417
// for k in UnitsInside ( j ) do
35331: LD_ADDR_VAR 0 4
35335: PUSH
35336: LD_VAR 0 3
35340: PPUSH
35341: CALL_OW 313
35345: PUSH
35346: FOR_IN
35347: IFFALSE 35413
// if k then
35349: LD_VAR 0 4
35353: IFFALSE 35411
// if not k in mc_repair_vehicle [ i ] then
35355: LD_VAR 0 4
35359: PUSH
35360: LD_EXP 62
35364: PUSH
35365: LD_VAR 0 2
35369: ARRAY
35370: IN
35371: NOT
35372: IFFALSE 35411
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35374: LD_ADDR_EXP 62
35378: PUSH
35379: LD_EXP 62
35383: PPUSH
35384: LD_VAR 0 2
35388: PPUSH
35389: LD_EXP 62
35393: PUSH
35394: LD_VAR 0 2
35398: ARRAY
35399: PUSH
35400: LD_VAR 0 4
35404: UNION
35405: PPUSH
35406: CALL_OW 1
35410: ST_TO_ADDR
35411: GO 35346
35413: POP
35414: POP
35415: GO 35328
35417: POP
35418: POP
// end ; if not mc_repair_vehicle [ i ] then
35419: LD_EXP 62
35423: PUSH
35424: LD_VAR 0 2
35428: ARRAY
35429: NOT
35430: IFFALSE 35434
// continue ;
35432: GO 34939
// for j in mc_repair_vehicle [ i ] do
35434: LD_ADDR_VAR 0 3
35438: PUSH
35439: LD_EXP 62
35443: PUSH
35444: LD_VAR 0 2
35448: ARRAY
35449: PUSH
35450: FOR_IN
35451: IFFALSE 35617
// begin if GetClass ( j ) <> 3 then
35453: LD_VAR 0 3
35457: PPUSH
35458: CALL_OW 257
35462: PUSH
35463: LD_INT 3
35465: NONEQUAL
35466: IFFALSE 35507
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35468: LD_ADDR_EXP 62
35472: PUSH
35473: LD_EXP 62
35477: PPUSH
35478: LD_VAR 0 2
35482: PPUSH
35483: LD_EXP 62
35487: PUSH
35488: LD_VAR 0 2
35492: ARRAY
35493: PUSH
35494: LD_VAR 0 3
35498: DIFF
35499: PPUSH
35500: CALL_OW 1
35504: ST_TO_ADDR
// continue ;
35505: GO 35450
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35507: LD_VAR 0 3
35511: PPUSH
35512: CALL_OW 311
35516: NOT
35517: PUSH
35518: LD_VAR 0 3
35522: PUSH
35523: LD_EXP 53
35527: PUSH
35528: LD_VAR 0 2
35532: ARRAY
35533: PUSH
35534: LD_INT 1
35536: ARRAY
35537: IN
35538: NOT
35539: AND
35540: PUSH
35541: LD_VAR 0 3
35545: PUSH
35546: LD_EXP 53
35550: PUSH
35551: LD_VAR 0 2
35555: ARRAY
35556: PUSH
35557: LD_INT 2
35559: ARRAY
35560: IN
35561: NOT
35562: AND
35563: IFFALSE 35615
// begin if IsInUnit ( j ) then
35565: LD_VAR 0 3
35569: PPUSH
35570: CALL_OW 310
35574: IFFALSE 35585
// ComExitBuilding ( j ) ;
35576: LD_VAR 0 3
35580: PPUSH
35581: CALL_OW 122
// if not HasTask ( j ) then
35585: LD_VAR 0 3
35589: PPUSH
35590: CALL_OW 314
35594: NOT
35595: IFFALSE 35615
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35597: LD_VAR 0 3
35601: PPUSH
35602: LD_VAR 0 7
35606: PUSH
35607: LD_INT 1
35609: ARRAY
35610: PPUSH
35611: CALL_OW 189
// end ; end ;
35615: GO 35450
35617: POP
35618: POP
// end ;
35619: GO 34939
35621: POP
35622: POP
// end ;
35623: LD_VAR 0 1
35627: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35628: LD_INT 0
35630: PPUSH
35631: PPUSH
35632: PPUSH
35633: PPUSH
35634: PPUSH
35635: PPUSH
35636: PPUSH
35637: PPUSH
35638: PPUSH
35639: PPUSH
35640: PPUSH
// if not mc_bases then
35641: LD_EXP 50
35645: NOT
35646: IFFALSE 35650
// exit ;
35648: GO 36452
// for i = 1 to mc_bases do
35650: LD_ADDR_VAR 0 2
35654: PUSH
35655: DOUBLE
35656: LD_INT 1
35658: DEC
35659: ST_TO_ADDR
35660: LD_EXP 50
35664: PUSH
35665: FOR_TO
35666: IFFALSE 36450
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35668: LD_EXP 78
35672: PUSH
35673: LD_VAR 0 2
35677: ARRAY
35678: NOT
35679: PUSH
35680: LD_EXP 53
35684: PUSH
35685: LD_VAR 0 2
35689: ARRAY
35690: PUSH
35691: LD_INT 1
35693: ARRAY
35694: OR
35695: PUSH
35696: LD_EXP 53
35700: PUSH
35701: LD_VAR 0 2
35705: ARRAY
35706: PUSH
35707: LD_INT 2
35709: ARRAY
35710: OR
35711: PUSH
35712: LD_EXP 76
35716: PUSH
35717: LD_VAR 0 2
35721: ARRAY
35722: PPUSH
35723: LD_INT 1
35725: PPUSH
35726: CALL_OW 325
35730: NOT
35731: OR
35732: PUSH
35733: LD_EXP 73
35737: PUSH
35738: LD_VAR 0 2
35742: ARRAY
35743: OR
35744: IFFALSE 35748
// continue ;
35746: GO 35665
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35748: LD_ADDR_VAR 0 8
35752: PUSH
35753: LD_EXP 50
35757: PUSH
35758: LD_VAR 0 2
35762: ARRAY
35763: PPUSH
35764: LD_INT 25
35766: PUSH
35767: LD_INT 4
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 50
35776: PUSH
35777: EMPTY
35778: LIST
35779: PUSH
35780: LD_INT 3
35782: PUSH
35783: LD_INT 60
35785: PUSH
35786: EMPTY
35787: LIST
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: LIST
35797: PPUSH
35798: CALL_OW 72
35802: PUSH
35803: LD_EXP 54
35807: PUSH
35808: LD_VAR 0 2
35812: ARRAY
35813: DIFF
35814: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35815: LD_ADDR_VAR 0 9
35819: PUSH
35820: LD_EXP 50
35824: PUSH
35825: LD_VAR 0 2
35829: ARRAY
35830: PPUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 30
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 30
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: LIST
35858: PPUSH
35859: CALL_OW 72
35863: ST_TO_ADDR
// if not tmp or not dep then
35864: LD_VAR 0 8
35868: NOT
35869: PUSH
35870: LD_VAR 0 9
35874: NOT
35875: OR
35876: IFFALSE 35880
// continue ;
35878: GO 35665
// side := GetSide ( tmp [ 1 ] ) ;
35880: LD_ADDR_VAR 0 11
35884: PUSH
35885: LD_VAR 0 8
35889: PUSH
35890: LD_INT 1
35892: ARRAY
35893: PPUSH
35894: CALL_OW 255
35898: ST_TO_ADDR
// dep := dep [ 1 ] ;
35899: LD_ADDR_VAR 0 9
35903: PUSH
35904: LD_VAR 0 9
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35913: LD_ADDR_VAR 0 7
35917: PUSH
35918: LD_EXP 78
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PPUSH
35929: LD_INT 22
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 25
35941: PUSH
35942: LD_INT 12
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PPUSH
35953: CALL_OW 70
35957: PUSH
35958: LD_INT 22
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 25
35970: PUSH
35971: LD_INT 12
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 91
35980: PUSH
35981: LD_VAR 0 9
35985: PUSH
35986: LD_INT 20
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: LIST
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: LIST
35998: PPUSH
35999: CALL_OW 69
36003: UNION
36004: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36005: LD_ADDR_VAR 0 10
36009: PUSH
36010: LD_EXP 78
36014: PUSH
36015: LD_VAR 0 2
36019: ARRAY
36020: PPUSH
36021: LD_INT 81
36023: PUSH
36024: LD_VAR 0 11
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PPUSH
36033: CALL_OW 70
36037: ST_TO_ADDR
// if not apes or danger_at_area then
36038: LD_VAR 0 7
36042: NOT
36043: PUSH
36044: LD_VAR 0 10
36048: OR
36049: IFFALSE 36099
// begin if mc_taming [ i ] then
36051: LD_EXP 81
36055: PUSH
36056: LD_VAR 0 2
36060: ARRAY
36061: IFFALSE 36097
// begin MC_Reset ( i , 121 ) ;
36063: LD_VAR 0 2
36067: PPUSH
36068: LD_INT 121
36070: PPUSH
36071: CALL 21524 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36075: LD_ADDR_EXP 81
36079: PUSH
36080: LD_EXP 81
36084: PPUSH
36085: LD_VAR 0 2
36089: PPUSH
36090: EMPTY
36091: PPUSH
36092: CALL_OW 1
36096: ST_TO_ADDR
// end ; continue ;
36097: GO 35665
// end ; for j in tmp do
36099: LD_ADDR_VAR 0 3
36103: PUSH
36104: LD_VAR 0 8
36108: PUSH
36109: FOR_IN
36110: IFFALSE 36446
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36112: LD_VAR 0 3
36116: PUSH
36117: LD_EXP 81
36121: PUSH
36122: LD_VAR 0 2
36126: ARRAY
36127: IN
36128: NOT
36129: PUSH
36130: LD_EXP 81
36134: PUSH
36135: LD_VAR 0 2
36139: ARRAY
36140: PUSH
36141: LD_INT 3
36143: LESS
36144: AND
36145: IFFALSE 36203
// begin SetTag ( j , 121 ) ;
36147: LD_VAR 0 3
36151: PPUSH
36152: LD_INT 121
36154: PPUSH
36155: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36159: LD_ADDR_EXP 81
36163: PUSH
36164: LD_EXP 81
36168: PPUSH
36169: LD_VAR 0 2
36173: PUSH
36174: LD_EXP 81
36178: PUSH
36179: LD_VAR 0 2
36183: ARRAY
36184: PUSH
36185: LD_INT 1
36187: PLUS
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PPUSH
36193: LD_VAR 0 3
36197: PPUSH
36198: CALL 52460 0 3
36202: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36203: LD_VAR 0 3
36207: PUSH
36208: LD_EXP 81
36212: PUSH
36213: LD_VAR 0 2
36217: ARRAY
36218: IN
36219: IFFALSE 36444
// begin if GetClass ( j ) <> 4 then
36221: LD_VAR 0 3
36225: PPUSH
36226: CALL_OW 257
36230: PUSH
36231: LD_INT 4
36233: NONEQUAL
36234: IFFALSE 36287
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36236: LD_ADDR_EXP 81
36240: PUSH
36241: LD_EXP 81
36245: PPUSH
36246: LD_VAR 0 2
36250: PPUSH
36251: LD_EXP 81
36255: PUSH
36256: LD_VAR 0 2
36260: ARRAY
36261: PUSH
36262: LD_VAR 0 3
36266: DIFF
36267: PPUSH
36268: CALL_OW 1
36272: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36273: LD_VAR 0 3
36277: PPUSH
36278: LD_INT 0
36280: PPUSH
36281: CALL_OW 109
// continue ;
36285: GO 36109
// end ; if IsInUnit ( j ) then
36287: LD_VAR 0 3
36291: PPUSH
36292: CALL_OW 310
36296: IFFALSE 36307
// ComExitBuilding ( j ) ;
36298: LD_VAR 0 3
36302: PPUSH
36303: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36307: LD_ADDR_VAR 0 6
36311: PUSH
36312: LD_VAR 0 7
36316: PPUSH
36317: LD_VAR 0 3
36321: PPUSH
36322: CALL_OW 74
36326: ST_TO_ADDR
// if not ape then
36327: LD_VAR 0 6
36331: NOT
36332: IFFALSE 36336
// break ;
36334: GO 36446
// x := GetX ( ape ) ;
36336: LD_ADDR_VAR 0 4
36340: PUSH
36341: LD_VAR 0 6
36345: PPUSH
36346: CALL_OW 250
36350: ST_TO_ADDR
// y := GetY ( ape ) ;
36351: LD_ADDR_VAR 0 5
36355: PUSH
36356: LD_VAR 0 6
36360: PPUSH
36361: CALL_OW 251
36365: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36366: LD_VAR 0 4
36370: PPUSH
36371: LD_VAR 0 5
36375: PPUSH
36376: CALL_OW 488
36380: NOT
36381: PUSH
36382: LD_VAR 0 11
36386: PPUSH
36387: LD_VAR 0 4
36391: PPUSH
36392: LD_VAR 0 5
36396: PPUSH
36397: LD_INT 20
36399: PPUSH
36400: CALL 53356 0 4
36404: PUSH
36405: LD_INT 4
36407: ARRAY
36408: OR
36409: IFFALSE 36413
// break ;
36411: GO 36446
// if not HasTask ( j ) then
36413: LD_VAR 0 3
36417: PPUSH
36418: CALL_OW 314
36422: NOT
36423: IFFALSE 36444
// ComTameXY ( j , x , y ) ;
36425: LD_VAR 0 3
36429: PPUSH
36430: LD_VAR 0 4
36434: PPUSH
36435: LD_VAR 0 5
36439: PPUSH
36440: CALL_OW 131
// end ; end ;
36444: GO 36109
36446: POP
36447: POP
// end ;
36448: GO 35665
36450: POP
36451: POP
// end ;
36452: LD_VAR 0 1
36456: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36457: LD_INT 0
36459: PPUSH
36460: PPUSH
36461: PPUSH
36462: PPUSH
36463: PPUSH
36464: PPUSH
36465: PPUSH
36466: PPUSH
// if not mc_bases then
36467: LD_EXP 50
36471: NOT
36472: IFFALSE 36476
// exit ;
36474: GO 37102
// for i = 1 to mc_bases do
36476: LD_ADDR_VAR 0 2
36480: PUSH
36481: DOUBLE
36482: LD_INT 1
36484: DEC
36485: ST_TO_ADDR
36486: LD_EXP 50
36490: PUSH
36491: FOR_TO
36492: IFFALSE 37100
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36494: LD_EXP 79
36498: PUSH
36499: LD_VAR 0 2
36503: ARRAY
36504: NOT
36505: PUSH
36506: LD_EXP 79
36510: PUSH
36511: LD_VAR 0 2
36515: ARRAY
36516: PPUSH
36517: LD_INT 25
36519: PUSH
36520: LD_INT 12
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PPUSH
36527: CALL_OW 72
36531: NOT
36532: OR
36533: IFFALSE 36537
// continue ;
36535: GO 36491
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36537: LD_ADDR_VAR 0 5
36541: PUSH
36542: LD_EXP 79
36546: PUSH
36547: LD_VAR 0 2
36551: ARRAY
36552: PUSH
36553: LD_INT 1
36555: ARRAY
36556: PPUSH
36557: CALL_OW 255
36561: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36562: LD_VAR 0 5
36566: PPUSH
36567: LD_INT 2
36569: PPUSH
36570: CALL_OW 325
36574: IFFALSE 36827
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36576: LD_ADDR_VAR 0 4
36580: PUSH
36581: LD_EXP 79
36585: PUSH
36586: LD_VAR 0 2
36590: ARRAY
36591: PPUSH
36592: LD_INT 25
36594: PUSH
36595: LD_INT 16
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PPUSH
36602: CALL_OW 72
36606: ST_TO_ADDR
// if tmp < 6 then
36607: LD_VAR 0 4
36611: PUSH
36612: LD_INT 6
36614: LESS
36615: IFFALSE 36827
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36617: LD_ADDR_VAR 0 6
36621: PUSH
36622: LD_EXP 50
36626: PUSH
36627: LD_VAR 0 2
36631: ARRAY
36632: PPUSH
36633: LD_INT 2
36635: PUSH
36636: LD_INT 30
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 30
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: LIST
36660: PPUSH
36661: CALL_OW 72
36665: ST_TO_ADDR
// if depot then
36666: LD_VAR 0 6
36670: IFFALSE 36827
// begin selected := 0 ;
36672: LD_ADDR_VAR 0 7
36676: PUSH
36677: LD_INT 0
36679: ST_TO_ADDR
// for j in depot do
36680: LD_ADDR_VAR 0 3
36684: PUSH
36685: LD_VAR 0 6
36689: PUSH
36690: FOR_IN
36691: IFFALSE 36722
// begin if UnitsInside ( j ) < 6 then
36693: LD_VAR 0 3
36697: PPUSH
36698: CALL_OW 313
36702: PUSH
36703: LD_INT 6
36705: LESS
36706: IFFALSE 36720
// begin selected := j ;
36708: LD_ADDR_VAR 0 7
36712: PUSH
36713: LD_VAR 0 3
36717: ST_TO_ADDR
// break ;
36718: GO 36722
// end ; end ;
36720: GO 36690
36722: POP
36723: POP
// if selected then
36724: LD_VAR 0 7
36728: IFFALSE 36827
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36730: LD_ADDR_VAR 0 3
36734: PUSH
36735: LD_EXP 79
36739: PUSH
36740: LD_VAR 0 2
36744: ARRAY
36745: PPUSH
36746: LD_INT 25
36748: PUSH
36749: LD_INT 12
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PPUSH
36756: CALL_OW 72
36760: PUSH
36761: FOR_IN
36762: IFFALSE 36825
// if not HasTask ( j ) then
36764: LD_VAR 0 3
36768: PPUSH
36769: CALL_OW 314
36773: NOT
36774: IFFALSE 36823
// begin if not IsInUnit ( j ) then
36776: LD_VAR 0 3
36780: PPUSH
36781: CALL_OW 310
36785: NOT
36786: IFFALSE 36802
// ComEnterUnit ( j , selected ) ;
36788: LD_VAR 0 3
36792: PPUSH
36793: LD_VAR 0 7
36797: PPUSH
36798: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36802: LD_VAR 0 3
36806: PPUSH
36807: LD_INT 16
36809: PPUSH
36810: CALL_OW 183
// AddComExitBuilding ( j ) ;
36814: LD_VAR 0 3
36818: PPUSH
36819: CALL_OW 182
// end ;
36823: GO 36761
36825: POP
36826: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36827: LD_VAR 0 5
36831: PPUSH
36832: LD_INT 11
36834: PPUSH
36835: CALL_OW 325
36839: IFFALSE 37098
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36841: LD_ADDR_VAR 0 4
36845: PUSH
36846: LD_EXP 79
36850: PUSH
36851: LD_VAR 0 2
36855: ARRAY
36856: PPUSH
36857: LD_INT 25
36859: PUSH
36860: LD_INT 16
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PPUSH
36867: CALL_OW 72
36871: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36872: LD_VAR 0 4
36876: PUSH
36877: LD_INT 6
36879: GREATEREQUAL
36880: PUSH
36881: LD_VAR 0 5
36885: PPUSH
36886: LD_INT 2
36888: PPUSH
36889: CALL_OW 325
36893: NOT
36894: OR
36895: IFFALSE 37098
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36897: LD_ADDR_VAR 0 8
36901: PUSH
36902: LD_EXP 50
36906: PUSH
36907: LD_VAR 0 2
36911: ARRAY
36912: PPUSH
36913: LD_INT 2
36915: PUSH
36916: LD_INT 30
36918: PUSH
36919: LD_INT 4
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 30
36928: PUSH
36929: LD_INT 5
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: LIST
36940: PPUSH
36941: CALL_OW 72
36945: ST_TO_ADDR
// if barracks then
36946: LD_VAR 0 8
36950: IFFALSE 37098
// begin selected := 0 ;
36952: LD_ADDR_VAR 0 7
36956: PUSH
36957: LD_INT 0
36959: ST_TO_ADDR
// for j in barracks do
36960: LD_ADDR_VAR 0 3
36964: PUSH
36965: LD_VAR 0 8
36969: PUSH
36970: FOR_IN
36971: IFFALSE 37002
// begin if UnitsInside ( j ) < 6 then
36973: LD_VAR 0 3
36977: PPUSH
36978: CALL_OW 313
36982: PUSH
36983: LD_INT 6
36985: LESS
36986: IFFALSE 37000
// begin selected := j ;
36988: LD_ADDR_VAR 0 7
36992: PUSH
36993: LD_VAR 0 3
36997: ST_TO_ADDR
// break ;
36998: GO 37002
// end ; end ;
37000: GO 36970
37002: POP
37003: POP
// if selected then
37004: LD_VAR 0 7
37008: IFFALSE 37098
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37010: LD_ADDR_VAR 0 3
37014: PUSH
37015: LD_EXP 79
37019: PUSH
37020: LD_VAR 0 2
37024: ARRAY
37025: PPUSH
37026: LD_INT 25
37028: PUSH
37029: LD_INT 12
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PPUSH
37036: CALL_OW 72
37040: PUSH
37041: FOR_IN
37042: IFFALSE 37096
// if not IsInUnit ( j ) and not HasTask ( j ) then
37044: LD_VAR 0 3
37048: PPUSH
37049: CALL_OW 310
37053: NOT
37054: PUSH
37055: LD_VAR 0 3
37059: PPUSH
37060: CALL_OW 314
37064: NOT
37065: AND
37066: IFFALSE 37094
// begin ComEnterUnit ( j , selected ) ;
37068: LD_VAR 0 3
37072: PPUSH
37073: LD_VAR 0 7
37077: PPUSH
37078: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37082: LD_VAR 0 3
37086: PPUSH
37087: LD_INT 15
37089: PPUSH
37090: CALL_OW 183
// end ;
37094: GO 37041
37096: POP
37097: POP
// end ; end ; end ; end ; end ;
37098: GO 36491
37100: POP
37101: POP
// end ;
37102: LD_VAR 0 1
37106: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37107: LD_INT 0
37109: PPUSH
37110: PPUSH
37111: PPUSH
37112: PPUSH
// if not mc_bases then
37113: LD_EXP 50
37117: NOT
37118: IFFALSE 37122
// exit ;
37120: GO 37300
// for i = 1 to mc_bases do
37122: LD_ADDR_VAR 0 2
37126: PUSH
37127: DOUBLE
37128: LD_INT 1
37130: DEC
37131: ST_TO_ADDR
37132: LD_EXP 50
37136: PUSH
37137: FOR_TO
37138: IFFALSE 37298
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37140: LD_ADDR_VAR 0 4
37144: PUSH
37145: LD_EXP 50
37149: PUSH
37150: LD_VAR 0 2
37154: ARRAY
37155: PPUSH
37156: LD_INT 25
37158: PUSH
37159: LD_INT 9
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PPUSH
37166: CALL_OW 72
37170: ST_TO_ADDR
// if not tmp then
37171: LD_VAR 0 4
37175: NOT
37176: IFFALSE 37180
// continue ;
37178: GO 37137
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37180: LD_EXP 76
37184: PUSH
37185: LD_VAR 0 2
37189: ARRAY
37190: PPUSH
37191: LD_INT 29
37193: PPUSH
37194: CALL_OW 325
37198: NOT
37199: PUSH
37200: LD_EXP 76
37204: PUSH
37205: LD_VAR 0 2
37209: ARRAY
37210: PPUSH
37211: LD_INT 28
37213: PPUSH
37214: CALL_OW 325
37218: NOT
37219: AND
37220: IFFALSE 37224
// continue ;
37222: GO 37137
// for j in tmp do
37224: LD_ADDR_VAR 0 3
37228: PUSH
37229: LD_VAR 0 4
37233: PUSH
37234: FOR_IN
37235: IFFALSE 37294
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37237: LD_VAR 0 3
37241: PUSH
37242: LD_EXP 53
37246: PUSH
37247: LD_VAR 0 2
37251: ARRAY
37252: PUSH
37253: LD_INT 1
37255: ARRAY
37256: IN
37257: NOT
37258: PUSH
37259: LD_VAR 0 3
37263: PUSH
37264: LD_EXP 53
37268: PUSH
37269: LD_VAR 0 2
37273: ARRAY
37274: PUSH
37275: LD_INT 2
37277: ARRAY
37278: IN
37279: NOT
37280: AND
37281: IFFALSE 37292
// ComSpaceTimeShoot ( j ) ;
37283: LD_VAR 0 3
37287: PPUSH
37288: CALL 48457 0 1
37292: GO 37234
37294: POP
37295: POP
// end ;
37296: GO 37137
37298: POP
37299: POP
// end ;
37300: LD_VAR 0 1
37304: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37305: LD_INT 0
37307: PPUSH
37308: PPUSH
37309: PPUSH
37310: PPUSH
37311: PPUSH
37312: PPUSH
37313: PPUSH
37314: PPUSH
37315: PPUSH
// if not mc_bases then
37316: LD_EXP 50
37320: NOT
37321: IFFALSE 37325
// exit ;
37323: GO 37947
// for i = 1 to mc_bases do
37325: LD_ADDR_VAR 0 2
37329: PUSH
37330: DOUBLE
37331: LD_INT 1
37333: DEC
37334: ST_TO_ADDR
37335: LD_EXP 50
37339: PUSH
37340: FOR_TO
37341: IFFALSE 37945
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37343: LD_EXP 85
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: NOT
37354: PUSH
37355: LD_INT 38
37357: PPUSH
37358: LD_EXP 76
37362: PUSH
37363: LD_VAR 0 2
37367: ARRAY
37368: PPUSH
37369: CALL_OW 321
37373: PUSH
37374: LD_INT 2
37376: NONEQUAL
37377: OR
37378: IFFALSE 37382
// continue ;
37380: GO 37340
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37382: LD_ADDR_VAR 0 8
37386: PUSH
37387: LD_EXP 50
37391: PUSH
37392: LD_VAR 0 2
37396: ARRAY
37397: PPUSH
37398: LD_INT 30
37400: PUSH
37401: LD_INT 34
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PPUSH
37408: CALL_OW 72
37412: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37413: LD_ADDR_VAR 0 9
37417: PUSH
37418: LD_EXP 50
37422: PUSH
37423: LD_VAR 0 2
37427: ARRAY
37428: PPUSH
37429: LD_INT 25
37431: PUSH
37432: LD_INT 4
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PPUSH
37439: CALL_OW 72
37443: PPUSH
37444: LD_INT 0
37446: PPUSH
37447: CALL 81021 0 2
37451: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37452: LD_VAR 0 9
37456: NOT
37457: PUSH
37458: LD_VAR 0 8
37462: NOT
37463: OR
37464: PUSH
37465: LD_EXP 50
37469: PUSH
37470: LD_VAR 0 2
37474: ARRAY
37475: PPUSH
37476: LD_INT 124
37478: PPUSH
37479: CALL 81021 0 2
37483: OR
37484: IFFALSE 37488
// continue ;
37486: GO 37340
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37488: LD_EXP 86
37492: PUSH
37493: LD_VAR 0 2
37497: ARRAY
37498: PUSH
37499: LD_EXP 85
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: LESS
37510: PUSH
37511: LD_EXP 86
37515: PUSH
37516: LD_VAR 0 2
37520: ARRAY
37521: PUSH
37522: LD_VAR 0 8
37526: LESS
37527: AND
37528: IFFALSE 37943
// begin tmp := sci [ 1 ] ;
37530: LD_ADDR_VAR 0 7
37534: PUSH
37535: LD_VAR 0 9
37539: PUSH
37540: LD_INT 1
37542: ARRAY
37543: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37544: LD_VAR 0 7
37548: PPUSH
37549: LD_INT 124
37551: PPUSH
37552: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37556: LD_ADDR_VAR 0 3
37560: PUSH
37561: DOUBLE
37562: LD_EXP 85
37566: PUSH
37567: LD_VAR 0 2
37571: ARRAY
37572: INC
37573: ST_TO_ADDR
37574: LD_EXP 85
37578: PUSH
37579: LD_VAR 0 2
37583: ARRAY
37584: PUSH
37585: FOR_DOWNTO
37586: IFFALSE 37929
// begin if IsInUnit ( tmp ) then
37588: LD_VAR 0 7
37592: PPUSH
37593: CALL_OW 310
37597: IFFALSE 37608
// ComExitBuilding ( tmp ) ;
37599: LD_VAR 0 7
37603: PPUSH
37604: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37608: LD_INT 35
37610: PPUSH
37611: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37615: LD_VAR 0 7
37619: PPUSH
37620: CALL_OW 310
37624: NOT
37625: PUSH
37626: LD_VAR 0 7
37630: PPUSH
37631: CALL_OW 314
37635: NOT
37636: AND
37637: IFFALSE 37608
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37639: LD_ADDR_VAR 0 6
37643: PUSH
37644: LD_VAR 0 7
37648: PPUSH
37649: CALL_OW 250
37653: PUSH
37654: LD_VAR 0 7
37658: PPUSH
37659: CALL_OW 251
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37668: LD_INT 35
37670: PPUSH
37671: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37675: LD_ADDR_VAR 0 4
37679: PUSH
37680: LD_EXP 85
37684: PUSH
37685: LD_VAR 0 2
37689: ARRAY
37690: PUSH
37691: LD_VAR 0 3
37695: ARRAY
37696: PUSH
37697: LD_INT 1
37699: ARRAY
37700: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37701: LD_ADDR_VAR 0 5
37705: PUSH
37706: LD_EXP 85
37710: PUSH
37711: LD_VAR 0 2
37715: ARRAY
37716: PUSH
37717: LD_VAR 0 3
37721: ARRAY
37722: PUSH
37723: LD_INT 2
37725: ARRAY
37726: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37727: LD_VAR 0 7
37731: PPUSH
37732: LD_INT 10
37734: PPUSH
37735: CALL 55053 0 2
37739: PUSH
37740: LD_INT 4
37742: ARRAY
37743: IFFALSE 37781
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37745: LD_VAR 0 7
37749: PPUSH
37750: LD_VAR 0 6
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: PPUSH
37759: LD_VAR 0 6
37763: PUSH
37764: LD_INT 2
37766: ARRAY
37767: PPUSH
37768: CALL_OW 111
// wait ( 0 0$10 ) ;
37772: LD_INT 350
37774: PPUSH
37775: CALL_OW 67
// end else
37779: GO 37807
// begin ComMoveXY ( tmp , x , y ) ;
37781: LD_VAR 0 7
37785: PPUSH
37786: LD_VAR 0 4
37790: PPUSH
37791: LD_VAR 0 5
37795: PPUSH
37796: CALL_OW 111
// wait ( 0 0$3 ) ;
37800: LD_INT 105
37802: PPUSH
37803: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37807: LD_VAR 0 7
37811: PPUSH
37812: LD_VAR 0 4
37816: PPUSH
37817: LD_VAR 0 5
37821: PPUSH
37822: CALL_OW 307
37826: IFFALSE 37668
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37828: LD_VAR 0 7
37832: PPUSH
37833: LD_VAR 0 4
37837: PPUSH
37838: LD_VAR 0 5
37842: PPUSH
37843: LD_VAR 0 8
37847: PUSH
37848: LD_VAR 0 3
37852: ARRAY
37853: PPUSH
37854: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37858: LD_INT 35
37860: PPUSH
37861: CALL_OW 67
// until not HasTask ( tmp ) ;
37865: LD_VAR 0 7
37869: PPUSH
37870: CALL_OW 314
37874: NOT
37875: IFFALSE 37858
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37877: LD_ADDR_EXP 86
37881: PUSH
37882: LD_EXP 86
37886: PPUSH
37887: LD_VAR 0 2
37891: PUSH
37892: LD_EXP 86
37896: PUSH
37897: LD_VAR 0 2
37901: ARRAY
37902: PUSH
37903: LD_INT 1
37905: PLUS
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PPUSH
37911: LD_VAR 0 8
37915: PUSH
37916: LD_VAR 0 3
37920: ARRAY
37921: PPUSH
37922: CALL 52460 0 3
37926: ST_TO_ADDR
// end ;
37927: GO 37585
37929: POP
37930: POP
// MC_Reset ( i , 124 ) ;
37931: LD_VAR 0 2
37935: PPUSH
37936: LD_INT 124
37938: PPUSH
37939: CALL 21524 0 2
// end ; end ;
37943: GO 37340
37945: POP
37946: POP
// end ;
37947: LD_VAR 0 1
37951: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37952: LD_INT 0
37954: PPUSH
37955: PPUSH
37956: PPUSH
// if not mc_bases then
37957: LD_EXP 50
37961: NOT
37962: IFFALSE 37966
// exit ;
37964: GO 38572
// for i = 1 to mc_bases do
37966: LD_ADDR_VAR 0 2
37970: PUSH
37971: DOUBLE
37972: LD_INT 1
37974: DEC
37975: ST_TO_ADDR
37976: LD_EXP 50
37980: PUSH
37981: FOR_TO
37982: IFFALSE 38570
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37984: LD_ADDR_VAR 0 3
37988: PUSH
37989: LD_EXP 50
37993: PUSH
37994: LD_VAR 0 2
37998: ARRAY
37999: PPUSH
38000: LD_INT 25
38002: PUSH
38003: LD_INT 4
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PPUSH
38010: CALL_OW 72
38014: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38015: LD_VAR 0 3
38019: NOT
38020: PUSH
38021: LD_EXP 87
38025: PUSH
38026: LD_VAR 0 2
38030: ARRAY
38031: NOT
38032: OR
38033: PUSH
38034: LD_EXP 50
38038: PUSH
38039: LD_VAR 0 2
38043: ARRAY
38044: PPUSH
38045: LD_INT 2
38047: PUSH
38048: LD_INT 30
38050: PUSH
38051: LD_INT 0
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PUSH
38058: LD_INT 30
38060: PUSH
38061: LD_INT 1
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: LIST
38072: PPUSH
38073: CALL_OW 72
38077: NOT
38078: OR
38079: IFFALSE 38129
// begin if mc_deposits_finder [ i ] then
38081: LD_EXP 88
38085: PUSH
38086: LD_VAR 0 2
38090: ARRAY
38091: IFFALSE 38127
// begin MC_Reset ( i , 125 ) ;
38093: LD_VAR 0 2
38097: PPUSH
38098: LD_INT 125
38100: PPUSH
38101: CALL 21524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38105: LD_ADDR_EXP 88
38109: PUSH
38110: LD_EXP 88
38114: PPUSH
38115: LD_VAR 0 2
38119: PPUSH
38120: EMPTY
38121: PPUSH
38122: CALL_OW 1
38126: ST_TO_ADDR
// end ; continue ;
38127: GO 37981
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38129: LD_EXP 87
38133: PUSH
38134: LD_VAR 0 2
38138: ARRAY
38139: PUSH
38140: LD_INT 1
38142: ARRAY
38143: PUSH
38144: LD_INT 3
38146: ARRAY
38147: PUSH
38148: LD_INT 1
38150: EQUAL
38151: PUSH
38152: LD_INT 20
38154: PPUSH
38155: LD_EXP 76
38159: PUSH
38160: LD_VAR 0 2
38164: ARRAY
38165: PPUSH
38166: CALL_OW 321
38170: PUSH
38171: LD_INT 2
38173: NONEQUAL
38174: AND
38175: IFFALSE 38225
// begin if mc_deposits_finder [ i ] then
38177: LD_EXP 88
38181: PUSH
38182: LD_VAR 0 2
38186: ARRAY
38187: IFFALSE 38223
// begin MC_Reset ( i , 125 ) ;
38189: LD_VAR 0 2
38193: PPUSH
38194: LD_INT 125
38196: PPUSH
38197: CALL 21524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38201: LD_ADDR_EXP 88
38205: PUSH
38206: LD_EXP 88
38210: PPUSH
38211: LD_VAR 0 2
38215: PPUSH
38216: EMPTY
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// end ; continue ;
38223: GO 37981
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38225: LD_EXP 87
38229: PUSH
38230: LD_VAR 0 2
38234: ARRAY
38235: PUSH
38236: LD_INT 1
38238: ARRAY
38239: PUSH
38240: LD_INT 1
38242: ARRAY
38243: PPUSH
38244: LD_EXP 87
38248: PUSH
38249: LD_VAR 0 2
38253: ARRAY
38254: PUSH
38255: LD_INT 1
38257: ARRAY
38258: PUSH
38259: LD_INT 2
38261: ARRAY
38262: PPUSH
38263: LD_EXP 76
38267: PUSH
38268: LD_VAR 0 2
38272: ARRAY
38273: PPUSH
38274: CALL_OW 440
38278: IFFALSE 38321
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38280: LD_ADDR_EXP 87
38284: PUSH
38285: LD_EXP 87
38289: PPUSH
38290: LD_VAR 0 2
38294: PPUSH
38295: LD_EXP 87
38299: PUSH
38300: LD_VAR 0 2
38304: ARRAY
38305: PPUSH
38306: LD_INT 1
38308: PPUSH
38309: CALL_OW 3
38313: PPUSH
38314: CALL_OW 1
38318: ST_TO_ADDR
38319: GO 38568
// begin if not mc_deposits_finder [ i ] then
38321: LD_EXP 88
38325: PUSH
38326: LD_VAR 0 2
38330: ARRAY
38331: NOT
38332: IFFALSE 38384
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38334: LD_ADDR_EXP 88
38338: PUSH
38339: LD_EXP 88
38343: PPUSH
38344: LD_VAR 0 2
38348: PPUSH
38349: LD_VAR 0 3
38353: PUSH
38354: LD_INT 1
38356: ARRAY
38357: PUSH
38358: EMPTY
38359: LIST
38360: PPUSH
38361: CALL_OW 1
38365: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38366: LD_VAR 0 3
38370: PUSH
38371: LD_INT 1
38373: ARRAY
38374: PPUSH
38375: LD_INT 125
38377: PPUSH
38378: CALL_OW 109
// end else
38382: GO 38568
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38384: LD_EXP 88
38388: PUSH
38389: LD_VAR 0 2
38393: ARRAY
38394: PUSH
38395: LD_INT 1
38397: ARRAY
38398: PPUSH
38399: CALL_OW 310
38403: IFFALSE 38426
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38405: LD_EXP 88
38409: PUSH
38410: LD_VAR 0 2
38414: ARRAY
38415: PUSH
38416: LD_INT 1
38418: ARRAY
38419: PPUSH
38420: CALL_OW 122
38424: GO 38568
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38426: LD_EXP 88
38430: PUSH
38431: LD_VAR 0 2
38435: ARRAY
38436: PUSH
38437: LD_INT 1
38439: ARRAY
38440: PPUSH
38441: CALL_OW 314
38445: NOT
38446: PUSH
38447: LD_EXP 88
38451: PUSH
38452: LD_VAR 0 2
38456: ARRAY
38457: PUSH
38458: LD_INT 1
38460: ARRAY
38461: PPUSH
38462: LD_EXP 87
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PUSH
38473: LD_INT 1
38475: ARRAY
38476: PUSH
38477: LD_INT 1
38479: ARRAY
38480: PPUSH
38481: LD_EXP 87
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: PUSH
38496: LD_INT 2
38498: ARRAY
38499: PPUSH
38500: CALL_OW 297
38504: PUSH
38505: LD_INT 6
38507: GREATER
38508: AND
38509: IFFALSE 38568
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38511: LD_EXP 88
38515: PUSH
38516: LD_VAR 0 2
38520: ARRAY
38521: PUSH
38522: LD_INT 1
38524: ARRAY
38525: PPUSH
38526: LD_EXP 87
38530: PUSH
38531: LD_VAR 0 2
38535: ARRAY
38536: PUSH
38537: LD_INT 1
38539: ARRAY
38540: PUSH
38541: LD_INT 1
38543: ARRAY
38544: PPUSH
38545: LD_EXP 87
38549: PUSH
38550: LD_VAR 0 2
38554: ARRAY
38555: PUSH
38556: LD_INT 1
38558: ARRAY
38559: PUSH
38560: LD_INT 2
38562: ARRAY
38563: PPUSH
38564: CALL_OW 111
// end ; end ; end ;
38568: GO 37981
38570: POP
38571: POP
// end ;
38572: LD_VAR 0 1
38576: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38577: LD_INT 0
38579: PPUSH
38580: PPUSH
38581: PPUSH
38582: PPUSH
38583: PPUSH
38584: PPUSH
38585: PPUSH
38586: PPUSH
38587: PPUSH
38588: PPUSH
38589: PPUSH
// if not mc_bases then
38590: LD_EXP 50
38594: NOT
38595: IFFALSE 38599
// exit ;
38597: GO 39539
// for i = 1 to mc_bases do
38599: LD_ADDR_VAR 0 2
38603: PUSH
38604: DOUBLE
38605: LD_INT 1
38607: DEC
38608: ST_TO_ADDR
38609: LD_EXP 50
38613: PUSH
38614: FOR_TO
38615: IFFALSE 39537
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38617: LD_EXP 50
38621: PUSH
38622: LD_VAR 0 2
38626: ARRAY
38627: NOT
38628: PUSH
38629: LD_EXP 73
38633: PUSH
38634: LD_VAR 0 2
38638: ARRAY
38639: OR
38640: IFFALSE 38644
// continue ;
38642: GO 38614
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38644: LD_ADDR_VAR 0 7
38648: PUSH
38649: LD_EXP 50
38653: PUSH
38654: LD_VAR 0 2
38658: ARRAY
38659: PUSH
38660: LD_INT 1
38662: ARRAY
38663: PPUSH
38664: CALL_OW 248
38668: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38669: LD_VAR 0 7
38673: PUSH
38674: LD_INT 3
38676: EQUAL
38677: PUSH
38678: LD_EXP 69
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: PUSH
38689: LD_EXP 72
38693: PUSH
38694: LD_VAR 0 2
38698: ARRAY
38699: UNION
38700: PPUSH
38701: LD_INT 33
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PPUSH
38711: CALL_OW 72
38715: NOT
38716: OR
38717: IFFALSE 38721
// continue ;
38719: GO 38614
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38721: LD_ADDR_VAR 0 9
38725: PUSH
38726: LD_EXP 50
38730: PUSH
38731: LD_VAR 0 2
38735: ARRAY
38736: PPUSH
38737: LD_INT 30
38739: PUSH
38740: LD_INT 36
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PPUSH
38747: CALL_OW 72
38751: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38752: LD_ADDR_VAR 0 10
38756: PUSH
38757: LD_EXP 69
38761: PUSH
38762: LD_VAR 0 2
38766: ARRAY
38767: PPUSH
38768: LD_INT 34
38770: PUSH
38771: LD_INT 31
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PPUSH
38778: CALL_OW 72
38782: ST_TO_ADDR
// if not cts and not mcts then
38783: LD_VAR 0 9
38787: NOT
38788: PUSH
38789: LD_VAR 0 10
38793: NOT
38794: AND
38795: IFFALSE 38799
// continue ;
38797: GO 38614
// x := cts ;
38799: LD_ADDR_VAR 0 11
38803: PUSH
38804: LD_VAR 0 9
38808: ST_TO_ADDR
// if not x then
38809: LD_VAR 0 11
38813: NOT
38814: IFFALSE 38826
// x := mcts ;
38816: LD_ADDR_VAR 0 11
38820: PUSH
38821: LD_VAR 0 10
38825: ST_TO_ADDR
// if not x then
38826: LD_VAR 0 11
38830: NOT
38831: IFFALSE 38835
// continue ;
38833: GO 38614
// if mc_remote_driver [ i ] then
38835: LD_EXP 90
38839: PUSH
38840: LD_VAR 0 2
38844: ARRAY
38845: IFFALSE 39232
// for j in mc_remote_driver [ i ] do
38847: LD_ADDR_VAR 0 3
38851: PUSH
38852: LD_EXP 90
38856: PUSH
38857: LD_VAR 0 2
38861: ARRAY
38862: PUSH
38863: FOR_IN
38864: IFFALSE 39230
// begin if GetClass ( j ) <> 3 then
38866: LD_VAR 0 3
38870: PPUSH
38871: CALL_OW 257
38875: PUSH
38876: LD_INT 3
38878: NONEQUAL
38879: IFFALSE 38932
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38881: LD_ADDR_EXP 90
38885: PUSH
38886: LD_EXP 90
38890: PPUSH
38891: LD_VAR 0 2
38895: PPUSH
38896: LD_EXP 90
38900: PUSH
38901: LD_VAR 0 2
38905: ARRAY
38906: PUSH
38907: LD_VAR 0 3
38911: DIFF
38912: PPUSH
38913: CALL_OW 1
38917: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38918: LD_VAR 0 3
38922: PPUSH
38923: LD_INT 0
38925: PPUSH
38926: CALL_OW 109
// continue ;
38930: GO 38863
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38932: LD_EXP 69
38936: PUSH
38937: LD_VAR 0 2
38941: ARRAY
38942: PPUSH
38943: LD_INT 34
38945: PUSH
38946: LD_INT 31
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 58
38955: PUSH
38956: EMPTY
38957: LIST
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PPUSH
38963: CALL_OW 72
38967: PUSH
38968: LD_VAR 0 3
38972: PPUSH
38973: CALL 81109 0 1
38977: NOT
38978: AND
38979: IFFALSE 39050
// begin if IsInUnit ( j ) then
38981: LD_VAR 0 3
38985: PPUSH
38986: CALL_OW 310
38990: IFFALSE 39001
// ComExitBuilding ( j ) ;
38992: LD_VAR 0 3
38996: PPUSH
38997: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39001: LD_VAR 0 3
39005: PPUSH
39006: LD_EXP 69
39010: PUSH
39011: LD_VAR 0 2
39015: ARRAY
39016: PPUSH
39017: LD_INT 34
39019: PUSH
39020: LD_INT 31
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 58
39029: PUSH
39030: EMPTY
39031: LIST
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PPUSH
39037: CALL_OW 72
39041: PUSH
39042: LD_INT 1
39044: ARRAY
39045: PPUSH
39046: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39050: LD_VAR 0 3
39054: PPUSH
39055: CALL_OW 310
39059: NOT
39060: PUSH
39061: LD_VAR 0 3
39065: PPUSH
39066: CALL_OW 310
39070: PPUSH
39071: CALL_OW 266
39075: PUSH
39076: LD_INT 36
39078: NONEQUAL
39079: PUSH
39080: LD_VAR 0 3
39084: PPUSH
39085: CALL 81109 0 1
39089: NOT
39090: AND
39091: OR
39092: IFFALSE 39228
// begin if IsInUnit ( j ) then
39094: LD_VAR 0 3
39098: PPUSH
39099: CALL_OW 310
39103: IFFALSE 39114
// ComExitBuilding ( j ) ;
39105: LD_VAR 0 3
39109: PPUSH
39110: CALL_OW 122
// ct := 0 ;
39114: LD_ADDR_VAR 0 8
39118: PUSH
39119: LD_INT 0
39121: ST_TO_ADDR
// for k in x do
39122: LD_ADDR_VAR 0 4
39126: PUSH
39127: LD_VAR 0 11
39131: PUSH
39132: FOR_IN
39133: IFFALSE 39206
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39135: LD_VAR 0 4
39139: PPUSH
39140: CALL_OW 264
39144: PUSH
39145: LD_INT 31
39147: EQUAL
39148: PUSH
39149: LD_VAR 0 4
39153: PPUSH
39154: CALL_OW 311
39158: NOT
39159: AND
39160: PUSH
39161: LD_VAR 0 4
39165: PPUSH
39166: CALL_OW 266
39170: PUSH
39171: LD_INT 36
39173: EQUAL
39174: PUSH
39175: LD_VAR 0 4
39179: PPUSH
39180: CALL_OW 313
39184: PUSH
39185: LD_INT 3
39187: LESS
39188: AND
39189: OR
39190: IFFALSE 39204
// begin ct := k ;
39192: LD_ADDR_VAR 0 8
39196: PUSH
39197: LD_VAR 0 4
39201: ST_TO_ADDR
// break ;
39202: GO 39206
// end ;
39204: GO 39132
39206: POP
39207: POP
// if ct then
39208: LD_VAR 0 8
39212: IFFALSE 39228
// ComEnterUnit ( j , ct ) ;
39214: LD_VAR 0 3
39218: PPUSH
39219: LD_VAR 0 8
39223: PPUSH
39224: CALL_OW 120
// end ; end ;
39228: GO 38863
39230: POP
39231: POP
// places := 0 ;
39232: LD_ADDR_VAR 0 5
39236: PUSH
39237: LD_INT 0
39239: ST_TO_ADDR
// for j = 1 to x do
39240: LD_ADDR_VAR 0 3
39244: PUSH
39245: DOUBLE
39246: LD_INT 1
39248: DEC
39249: ST_TO_ADDR
39250: LD_VAR 0 11
39254: PUSH
39255: FOR_TO
39256: IFFALSE 39332
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39258: LD_VAR 0 11
39262: PUSH
39263: LD_VAR 0 3
39267: ARRAY
39268: PPUSH
39269: CALL_OW 264
39273: PUSH
39274: LD_INT 31
39276: EQUAL
39277: IFFALSE 39295
// places := places + 1 else
39279: LD_ADDR_VAR 0 5
39283: PUSH
39284: LD_VAR 0 5
39288: PUSH
39289: LD_INT 1
39291: PLUS
39292: ST_TO_ADDR
39293: GO 39330
// if GetBType ( x [ j ] ) = b_control_tower then
39295: LD_VAR 0 11
39299: PUSH
39300: LD_VAR 0 3
39304: ARRAY
39305: PPUSH
39306: CALL_OW 266
39310: PUSH
39311: LD_INT 36
39313: EQUAL
39314: IFFALSE 39330
// places := places + 3 ;
39316: LD_ADDR_VAR 0 5
39320: PUSH
39321: LD_VAR 0 5
39325: PUSH
39326: LD_INT 3
39328: PLUS
39329: ST_TO_ADDR
39330: GO 39255
39332: POP
39333: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39334: LD_VAR 0 5
39338: PUSH
39339: LD_INT 0
39341: EQUAL
39342: PUSH
39343: LD_VAR 0 5
39347: PUSH
39348: LD_EXP 90
39352: PUSH
39353: LD_VAR 0 2
39357: ARRAY
39358: LESSEQUAL
39359: OR
39360: IFFALSE 39364
// continue ;
39362: GO 38614
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39364: LD_ADDR_VAR 0 6
39368: PUSH
39369: LD_EXP 50
39373: PUSH
39374: LD_VAR 0 2
39378: ARRAY
39379: PPUSH
39380: LD_INT 25
39382: PUSH
39383: LD_INT 3
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PPUSH
39390: CALL_OW 72
39394: PUSH
39395: LD_EXP 90
39399: PUSH
39400: LD_VAR 0 2
39404: ARRAY
39405: DIFF
39406: PPUSH
39407: LD_INT 3
39409: PPUSH
39410: CALL 82009 0 2
39414: ST_TO_ADDR
// for j in tmp do
39415: LD_ADDR_VAR 0 3
39419: PUSH
39420: LD_VAR 0 6
39424: PUSH
39425: FOR_IN
39426: IFFALSE 39461
// if GetTag ( j ) > 0 then
39428: LD_VAR 0 3
39432: PPUSH
39433: CALL_OW 110
39437: PUSH
39438: LD_INT 0
39440: GREATER
39441: IFFALSE 39459
// tmp := tmp diff j ;
39443: LD_ADDR_VAR 0 6
39447: PUSH
39448: LD_VAR 0 6
39452: PUSH
39453: LD_VAR 0 3
39457: DIFF
39458: ST_TO_ADDR
39459: GO 39425
39461: POP
39462: POP
// if not tmp then
39463: LD_VAR 0 6
39467: NOT
39468: IFFALSE 39472
// continue ;
39470: GO 38614
// if places then
39472: LD_VAR 0 5
39476: IFFALSE 39535
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39478: LD_ADDR_EXP 90
39482: PUSH
39483: LD_EXP 90
39487: PPUSH
39488: LD_VAR 0 2
39492: PPUSH
39493: LD_EXP 90
39497: PUSH
39498: LD_VAR 0 2
39502: ARRAY
39503: PUSH
39504: LD_VAR 0 6
39508: PUSH
39509: LD_INT 1
39511: ARRAY
39512: UNION
39513: PPUSH
39514: CALL_OW 1
39518: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39519: LD_VAR 0 6
39523: PUSH
39524: LD_INT 1
39526: ARRAY
39527: PPUSH
39528: LD_INT 126
39530: PPUSH
39531: CALL_OW 109
// end ; end ;
39535: GO 38614
39537: POP
39538: POP
// end ;
39539: LD_VAR 0 1
39543: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39544: LD_INT 0
39546: PPUSH
39547: PPUSH
39548: PPUSH
39549: PPUSH
39550: PPUSH
39551: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39552: LD_VAR 0 1
39556: NOT
39557: PUSH
39558: LD_VAR 0 2
39562: NOT
39563: OR
39564: PUSH
39565: LD_VAR 0 3
39569: NOT
39570: OR
39571: PUSH
39572: LD_VAR 0 4
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: LD_INT 2
39582: PUSH
39583: LD_INT 3
39585: PUSH
39586: LD_INT 4
39588: PUSH
39589: LD_INT 5
39591: PUSH
39592: LD_INT 8
39594: PUSH
39595: LD_INT 9
39597: PUSH
39598: LD_INT 15
39600: PUSH
39601: LD_INT 16
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: IN
39615: NOT
39616: OR
39617: IFFALSE 39621
// exit ;
39619: GO 40521
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39621: LD_ADDR_VAR 0 2
39625: PUSH
39626: LD_VAR 0 2
39630: PPUSH
39631: LD_INT 21
39633: PUSH
39634: LD_INT 3
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 24
39643: PUSH
39644: LD_INT 250
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PPUSH
39655: CALL_OW 72
39659: ST_TO_ADDR
// case class of 1 , 15 :
39660: LD_VAR 0 4
39664: PUSH
39665: LD_INT 1
39667: DOUBLE
39668: EQUAL
39669: IFTRUE 39679
39671: LD_INT 15
39673: DOUBLE
39674: EQUAL
39675: IFTRUE 39679
39677: GO 39764
39679: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39680: LD_ADDR_VAR 0 8
39684: PUSH
39685: LD_VAR 0 2
39689: PPUSH
39690: LD_INT 2
39692: PUSH
39693: LD_INT 30
39695: PUSH
39696: LD_INT 32
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 30
39705: PUSH
39706: LD_INT 31
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: LIST
39717: PPUSH
39718: CALL_OW 72
39722: PUSH
39723: LD_VAR 0 2
39727: PPUSH
39728: LD_INT 2
39730: PUSH
39731: LD_INT 30
39733: PUSH
39734: LD_INT 4
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 30
39743: PUSH
39744: LD_INT 5
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: LIST
39755: PPUSH
39756: CALL_OW 72
39760: ADD
39761: ST_TO_ADDR
39762: GO 40010
39764: LD_INT 2
39766: DOUBLE
39767: EQUAL
39768: IFTRUE 39778
39770: LD_INT 16
39772: DOUBLE
39773: EQUAL
39774: IFTRUE 39778
39776: GO 39824
39778: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39779: LD_ADDR_VAR 0 8
39783: PUSH
39784: LD_VAR 0 2
39788: PPUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 30
39794: PUSH
39795: LD_INT 0
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 30
39804: PUSH
39805: LD_INT 1
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: LIST
39816: PPUSH
39817: CALL_OW 72
39821: ST_TO_ADDR
39822: GO 40010
39824: LD_INT 3
39826: DOUBLE
39827: EQUAL
39828: IFTRUE 39832
39830: GO 39878
39832: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39833: LD_ADDR_VAR 0 8
39837: PUSH
39838: LD_VAR 0 2
39842: PPUSH
39843: LD_INT 2
39845: PUSH
39846: LD_INT 30
39848: PUSH
39849: LD_INT 2
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 30
39858: PUSH
39859: LD_INT 3
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: LIST
39870: PPUSH
39871: CALL_OW 72
39875: ST_TO_ADDR
39876: GO 40010
39878: LD_INT 4
39880: DOUBLE
39881: EQUAL
39882: IFTRUE 39886
39884: GO 39943
39886: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39887: LD_ADDR_VAR 0 8
39891: PUSH
39892: LD_VAR 0 2
39896: PPUSH
39897: LD_INT 2
39899: PUSH
39900: LD_INT 30
39902: PUSH
39903: LD_INT 6
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 30
39912: PUSH
39913: LD_INT 7
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 30
39922: PUSH
39923: LD_INT 8
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: PPUSH
39936: CALL_OW 72
39940: ST_TO_ADDR
39941: GO 40010
39943: LD_INT 5
39945: DOUBLE
39946: EQUAL
39947: IFTRUE 39963
39949: LD_INT 8
39951: DOUBLE
39952: EQUAL
39953: IFTRUE 39963
39955: LD_INT 9
39957: DOUBLE
39958: EQUAL
39959: IFTRUE 39963
39961: GO 40009
39963: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39964: LD_ADDR_VAR 0 8
39968: PUSH
39969: LD_VAR 0 2
39973: PPUSH
39974: LD_INT 2
39976: PUSH
39977: LD_INT 30
39979: PUSH
39980: LD_INT 4
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 30
39989: PUSH
39990: LD_INT 5
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: LIST
40001: PPUSH
40002: CALL_OW 72
40006: ST_TO_ADDR
40007: GO 40010
40009: POP
// if not tmp then
40010: LD_VAR 0 8
40014: NOT
40015: IFFALSE 40019
// exit ;
40017: GO 40521
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40019: LD_VAR 0 4
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: LD_INT 15
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: IN
40034: PUSH
40035: LD_EXP 59
40039: PUSH
40040: LD_VAR 0 1
40044: ARRAY
40045: AND
40046: IFFALSE 40202
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40048: LD_ADDR_VAR 0 9
40052: PUSH
40053: LD_EXP 59
40057: PUSH
40058: LD_VAR 0 1
40062: ARRAY
40063: PUSH
40064: LD_INT 1
40066: ARRAY
40067: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40068: LD_VAR 0 9
40072: PUSH
40073: LD_EXP 60
40077: PUSH
40078: LD_VAR 0 1
40082: ARRAY
40083: IN
40084: NOT
40085: IFFALSE 40200
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40087: LD_ADDR_EXP 60
40091: PUSH
40092: LD_EXP 60
40096: PPUSH
40097: LD_VAR 0 1
40101: PUSH
40102: LD_EXP 60
40106: PUSH
40107: LD_VAR 0 1
40111: ARRAY
40112: PUSH
40113: LD_INT 1
40115: PLUS
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PPUSH
40121: LD_VAR 0 9
40125: PPUSH
40126: CALL 52460 0 3
40130: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40131: LD_ADDR_EXP 59
40135: PUSH
40136: LD_EXP 59
40140: PPUSH
40141: LD_VAR 0 1
40145: PPUSH
40146: LD_EXP 59
40150: PUSH
40151: LD_VAR 0 1
40155: ARRAY
40156: PUSH
40157: LD_VAR 0 9
40161: DIFF
40162: PPUSH
40163: CALL_OW 1
40167: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40168: LD_VAR 0 3
40172: PPUSH
40173: LD_EXP 60
40177: PUSH
40178: LD_VAR 0 1
40182: ARRAY
40183: PUSH
40184: LD_EXP 60
40188: PUSH
40189: LD_VAR 0 1
40193: ARRAY
40194: ARRAY
40195: PPUSH
40196: CALL_OW 120
// end ; exit ;
40200: GO 40521
// end ; if tmp > 1 then
40202: LD_VAR 0 8
40206: PUSH
40207: LD_INT 1
40209: GREATER
40210: IFFALSE 40314
// for i = 2 to tmp do
40212: LD_ADDR_VAR 0 6
40216: PUSH
40217: DOUBLE
40218: LD_INT 2
40220: DEC
40221: ST_TO_ADDR
40222: LD_VAR 0 8
40226: PUSH
40227: FOR_TO
40228: IFFALSE 40312
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40230: LD_VAR 0 8
40234: PUSH
40235: LD_VAR 0 6
40239: ARRAY
40240: PPUSH
40241: CALL_OW 461
40245: PUSH
40246: LD_INT 6
40248: EQUAL
40249: IFFALSE 40310
// begin x := tmp [ i ] ;
40251: LD_ADDR_VAR 0 9
40255: PUSH
40256: LD_VAR 0 8
40260: PUSH
40261: LD_VAR 0 6
40265: ARRAY
40266: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40267: LD_ADDR_VAR 0 8
40271: PUSH
40272: LD_VAR 0 8
40276: PPUSH
40277: LD_VAR 0 6
40281: PPUSH
40282: CALL_OW 3
40286: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40287: LD_ADDR_VAR 0 8
40291: PUSH
40292: LD_VAR 0 8
40296: PPUSH
40297: LD_INT 1
40299: PPUSH
40300: LD_VAR 0 9
40304: PPUSH
40305: CALL_OW 2
40309: ST_TO_ADDR
// end ;
40310: GO 40227
40312: POP
40313: POP
// for i in tmp do
40314: LD_ADDR_VAR 0 6
40318: PUSH
40319: LD_VAR 0 8
40323: PUSH
40324: FOR_IN
40325: IFFALSE 40394
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40327: LD_VAR 0 6
40331: PPUSH
40332: CALL_OW 313
40336: PUSH
40337: LD_INT 6
40339: LESS
40340: PUSH
40341: LD_VAR 0 6
40345: PPUSH
40346: CALL_OW 266
40350: PUSH
40351: LD_INT 31
40353: PUSH
40354: LD_INT 32
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: IN
40361: NOT
40362: AND
40363: PUSH
40364: LD_VAR 0 6
40368: PPUSH
40369: CALL_OW 313
40373: PUSH
40374: LD_INT 0
40376: EQUAL
40377: OR
40378: IFFALSE 40392
// begin j := i ;
40380: LD_ADDR_VAR 0 7
40384: PUSH
40385: LD_VAR 0 6
40389: ST_TO_ADDR
// break ;
40390: GO 40394
// end ; end ;
40392: GO 40324
40394: POP
40395: POP
// if j then
40396: LD_VAR 0 7
40400: IFFALSE 40418
// ComEnterUnit ( unit , j ) else
40402: LD_VAR 0 3
40406: PPUSH
40407: LD_VAR 0 7
40411: PPUSH
40412: CALL_OW 120
40416: GO 40521
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40418: LD_ADDR_VAR 0 10
40422: PUSH
40423: LD_VAR 0 2
40427: PPUSH
40428: LD_INT 2
40430: PUSH
40431: LD_INT 30
40433: PUSH
40434: LD_INT 0
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 30
40443: PUSH
40444: LD_INT 1
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: LIST
40455: PPUSH
40456: CALL_OW 72
40460: ST_TO_ADDR
// if depot then
40461: LD_VAR 0 10
40465: IFFALSE 40521
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40467: LD_ADDR_VAR 0 10
40471: PUSH
40472: LD_VAR 0 10
40476: PPUSH
40477: LD_VAR 0 3
40481: PPUSH
40482: CALL_OW 74
40486: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40487: LD_VAR 0 3
40491: PPUSH
40492: LD_VAR 0 10
40496: PPUSH
40497: CALL_OW 296
40501: PUSH
40502: LD_INT 10
40504: GREATER
40505: IFFALSE 40521
// ComStandNearbyBuilding ( unit , depot ) ;
40507: LD_VAR 0 3
40511: PPUSH
40512: LD_VAR 0 10
40516: PPUSH
40517: CALL 49074 0 2
// end ; end ; end ;
40521: LD_VAR 0 5
40525: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40526: LD_INT 0
40528: PPUSH
40529: PPUSH
40530: PPUSH
40531: PPUSH
// if not mc_bases then
40532: LD_EXP 50
40536: NOT
40537: IFFALSE 40541
// exit ;
40539: GO 40780
// for i = 1 to mc_bases do
40541: LD_ADDR_VAR 0 2
40545: PUSH
40546: DOUBLE
40547: LD_INT 1
40549: DEC
40550: ST_TO_ADDR
40551: LD_EXP 50
40555: PUSH
40556: FOR_TO
40557: IFFALSE 40778
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40559: LD_ADDR_VAR 0 4
40563: PUSH
40564: LD_EXP 50
40568: PUSH
40569: LD_VAR 0 2
40573: ARRAY
40574: PPUSH
40575: LD_INT 21
40577: PUSH
40578: LD_INT 1
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PPUSH
40585: CALL_OW 72
40589: PUSH
40590: LD_EXP 79
40594: PUSH
40595: LD_VAR 0 2
40599: ARRAY
40600: UNION
40601: ST_TO_ADDR
// if not tmp then
40602: LD_VAR 0 4
40606: NOT
40607: IFFALSE 40611
// continue ;
40609: GO 40556
// for j in tmp do
40611: LD_ADDR_VAR 0 3
40615: PUSH
40616: LD_VAR 0 4
40620: PUSH
40621: FOR_IN
40622: IFFALSE 40774
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40624: LD_VAR 0 3
40628: PPUSH
40629: CALL_OW 110
40633: NOT
40634: PUSH
40635: LD_VAR 0 3
40639: PPUSH
40640: CALL_OW 314
40644: NOT
40645: AND
40646: PUSH
40647: LD_VAR 0 3
40651: PPUSH
40652: CALL_OW 311
40656: NOT
40657: AND
40658: PUSH
40659: LD_VAR 0 3
40663: PPUSH
40664: CALL_OW 310
40668: NOT
40669: AND
40670: PUSH
40671: LD_VAR 0 3
40675: PUSH
40676: LD_EXP 53
40680: PUSH
40681: LD_VAR 0 2
40685: ARRAY
40686: PUSH
40687: LD_INT 1
40689: ARRAY
40690: IN
40691: NOT
40692: AND
40693: PUSH
40694: LD_VAR 0 3
40698: PUSH
40699: LD_EXP 53
40703: PUSH
40704: LD_VAR 0 2
40708: ARRAY
40709: PUSH
40710: LD_INT 2
40712: ARRAY
40713: IN
40714: NOT
40715: AND
40716: PUSH
40717: LD_VAR 0 3
40721: PUSH
40722: LD_EXP 62
40726: PUSH
40727: LD_VAR 0 2
40731: ARRAY
40732: IN
40733: NOT
40734: AND
40735: IFFALSE 40772
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40737: LD_VAR 0 2
40741: PPUSH
40742: LD_EXP 50
40746: PUSH
40747: LD_VAR 0 2
40751: ARRAY
40752: PPUSH
40753: LD_VAR 0 3
40757: PPUSH
40758: LD_VAR 0 3
40762: PPUSH
40763: CALL_OW 257
40767: PPUSH
40768: CALL 39544 0 4
// end ;
40772: GO 40621
40774: POP
40775: POP
// end ;
40776: GO 40556
40778: POP
40779: POP
// end ;
40780: LD_VAR 0 1
40784: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40785: LD_INT 0
40787: PPUSH
40788: PPUSH
40789: PPUSH
40790: PPUSH
40791: PPUSH
40792: PPUSH
// if not mc_bases [ base ] then
40793: LD_EXP 50
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: NOT
40804: IFFALSE 40808
// exit ;
40806: GO 40990
// tmp := [ ] ;
40808: LD_ADDR_VAR 0 6
40812: PUSH
40813: EMPTY
40814: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40815: LD_ADDR_VAR 0 7
40819: PUSH
40820: LD_VAR 0 3
40824: PPUSH
40825: LD_INT 0
40827: PPUSH
40828: CALL_OW 517
40832: ST_TO_ADDR
// if not list then
40833: LD_VAR 0 7
40837: NOT
40838: IFFALSE 40842
// exit ;
40840: GO 40990
// for i = 1 to amount do
40842: LD_ADDR_VAR 0 5
40846: PUSH
40847: DOUBLE
40848: LD_INT 1
40850: DEC
40851: ST_TO_ADDR
40852: LD_VAR 0 2
40856: PUSH
40857: FOR_TO
40858: IFFALSE 40938
// begin x := rand ( 1 , list [ 1 ] ) ;
40860: LD_ADDR_VAR 0 8
40864: PUSH
40865: LD_INT 1
40867: PPUSH
40868: LD_VAR 0 7
40872: PUSH
40873: LD_INT 1
40875: ARRAY
40876: PPUSH
40877: CALL_OW 12
40881: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40882: LD_ADDR_VAR 0 6
40886: PUSH
40887: LD_VAR 0 6
40891: PPUSH
40892: LD_VAR 0 5
40896: PPUSH
40897: LD_VAR 0 7
40901: PUSH
40902: LD_INT 1
40904: ARRAY
40905: PUSH
40906: LD_VAR 0 8
40910: ARRAY
40911: PUSH
40912: LD_VAR 0 7
40916: PUSH
40917: LD_INT 2
40919: ARRAY
40920: PUSH
40921: LD_VAR 0 8
40925: ARRAY
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PPUSH
40931: CALL_OW 1
40935: ST_TO_ADDR
// end ;
40936: GO 40857
40938: POP
40939: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40940: LD_ADDR_EXP 63
40944: PUSH
40945: LD_EXP 63
40949: PPUSH
40950: LD_VAR 0 1
40954: PPUSH
40955: LD_VAR 0 6
40959: PPUSH
40960: CALL_OW 1
40964: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40965: LD_ADDR_EXP 65
40969: PUSH
40970: LD_EXP 65
40974: PPUSH
40975: LD_VAR 0 1
40979: PPUSH
40980: LD_VAR 0 3
40984: PPUSH
40985: CALL_OW 1
40989: ST_TO_ADDR
// end ;
40990: LD_VAR 0 4
40994: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40995: LD_INT 0
40997: PPUSH
// if not mc_bases [ base ] then
40998: LD_EXP 50
41002: PUSH
41003: LD_VAR 0 1
41007: ARRAY
41008: NOT
41009: IFFALSE 41013
// exit ;
41011: GO 41038
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41013: LD_ADDR_EXP 55
41017: PUSH
41018: LD_EXP 55
41022: PPUSH
41023: LD_VAR 0 1
41027: PPUSH
41028: LD_VAR 0 2
41032: PPUSH
41033: CALL_OW 1
41037: ST_TO_ADDR
// end ;
41038: LD_VAR 0 3
41042: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41043: LD_INT 0
41045: PPUSH
// if not mc_bases [ base ] then
41046: LD_EXP 50
41050: PUSH
41051: LD_VAR 0 1
41055: ARRAY
41056: NOT
41057: IFFALSE 41061
// exit ;
41059: GO 41098
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41061: LD_ADDR_EXP 55
41065: PUSH
41066: LD_EXP 55
41070: PPUSH
41071: LD_VAR 0 1
41075: PPUSH
41076: LD_EXP 55
41080: PUSH
41081: LD_VAR 0 1
41085: ARRAY
41086: PUSH
41087: LD_VAR 0 2
41091: UNION
41092: PPUSH
41093: CALL_OW 1
41097: ST_TO_ADDR
// end ;
41098: LD_VAR 0 3
41102: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41103: LD_INT 0
41105: PPUSH
// if not mc_bases [ base ] then
41106: LD_EXP 50
41110: PUSH
41111: LD_VAR 0 1
41115: ARRAY
41116: NOT
41117: IFFALSE 41121
// exit ;
41119: GO 41146
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41121: LD_ADDR_EXP 71
41125: PUSH
41126: LD_EXP 71
41130: PPUSH
41131: LD_VAR 0 1
41135: PPUSH
41136: LD_VAR 0 2
41140: PPUSH
41141: CALL_OW 1
41145: ST_TO_ADDR
// end ;
41146: LD_VAR 0 3
41150: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41151: LD_INT 0
41153: PPUSH
// if not mc_bases [ base ] then
41154: LD_EXP 50
41158: PUSH
41159: LD_VAR 0 1
41163: ARRAY
41164: NOT
41165: IFFALSE 41169
// exit ;
41167: GO 41206
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41169: LD_ADDR_EXP 71
41173: PUSH
41174: LD_EXP 71
41178: PPUSH
41179: LD_VAR 0 1
41183: PPUSH
41184: LD_EXP 71
41188: PUSH
41189: LD_VAR 0 1
41193: ARRAY
41194: PUSH
41195: LD_VAR 0 2
41199: ADD
41200: PPUSH
41201: CALL_OW 1
41205: ST_TO_ADDR
// end ;
41206: LD_VAR 0 3
41210: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41211: LD_INT 0
41213: PPUSH
// if not mc_bases [ base ] then
41214: LD_EXP 50
41218: PUSH
41219: LD_VAR 0 1
41223: ARRAY
41224: NOT
41225: IFFALSE 41229
// exit ;
41227: GO 41283
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41229: LD_ADDR_EXP 72
41233: PUSH
41234: LD_EXP 72
41238: PPUSH
41239: LD_VAR 0 1
41243: PPUSH
41244: LD_VAR 0 2
41248: PPUSH
41249: CALL_OW 1
41253: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41254: LD_ADDR_EXP 61
41258: PUSH
41259: LD_EXP 61
41263: PPUSH
41264: LD_VAR 0 1
41268: PPUSH
41269: LD_VAR 0 2
41273: PUSH
41274: LD_INT 0
41276: PLUS
41277: PPUSH
41278: CALL_OW 1
41282: ST_TO_ADDR
// end ;
41283: LD_VAR 0 3
41287: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41288: LD_INT 0
41290: PPUSH
// if not mc_bases [ base ] then
41291: LD_EXP 50
41295: PUSH
41296: LD_VAR 0 1
41300: ARRAY
41301: NOT
41302: IFFALSE 41306
// exit ;
41304: GO 41331
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41306: LD_ADDR_EXP 61
41310: PUSH
41311: LD_EXP 61
41315: PPUSH
41316: LD_VAR 0 1
41320: PPUSH
41321: LD_VAR 0 2
41325: PPUSH
41326: CALL_OW 1
41330: ST_TO_ADDR
// end ;
41331: LD_VAR 0 3
41335: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41336: LD_INT 0
41338: PPUSH
41339: PPUSH
41340: PPUSH
41341: PPUSH
// if not mc_bases [ base ] then
41342: LD_EXP 50
41346: PUSH
41347: LD_VAR 0 1
41351: ARRAY
41352: NOT
41353: IFFALSE 41357
// exit ;
41355: GO 41422
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41357: LD_ADDR_EXP 70
41361: PUSH
41362: LD_EXP 70
41366: PPUSH
41367: LD_VAR 0 1
41371: PUSH
41372: LD_EXP 70
41376: PUSH
41377: LD_VAR 0 1
41381: ARRAY
41382: PUSH
41383: LD_INT 1
41385: PLUS
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PPUSH
41391: LD_VAR 0 1
41395: PUSH
41396: LD_VAR 0 2
41400: PUSH
41401: LD_VAR 0 3
41405: PUSH
41406: LD_VAR 0 4
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: PPUSH
41417: CALL 52460 0 3
41421: ST_TO_ADDR
// end ;
41422: LD_VAR 0 5
41426: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41427: LD_INT 0
41429: PPUSH
// if not mc_bases [ base ] then
41430: LD_EXP 50
41434: PUSH
41435: LD_VAR 0 1
41439: ARRAY
41440: NOT
41441: IFFALSE 41445
// exit ;
41443: GO 41470
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41445: LD_ADDR_EXP 87
41449: PUSH
41450: LD_EXP 87
41454: PPUSH
41455: LD_VAR 0 1
41459: PPUSH
41460: LD_VAR 0 2
41464: PPUSH
41465: CALL_OW 1
41469: ST_TO_ADDR
// end ;
41470: LD_VAR 0 3
41474: RET
// export function MC_GetMinesField ( base ) ; begin
41475: LD_INT 0
41477: PPUSH
// result := mc_mines [ base ] ;
41478: LD_ADDR_VAR 0 2
41482: PUSH
41483: LD_EXP 63
41487: PUSH
41488: LD_VAR 0 1
41492: ARRAY
41493: ST_TO_ADDR
// end ;
41494: LD_VAR 0 2
41498: RET
// export function MC_GetProduceList ( base ) ; begin
41499: LD_INT 0
41501: PPUSH
// result := mc_produce [ base ] ;
41502: LD_ADDR_VAR 0 2
41506: PUSH
41507: LD_EXP 71
41511: PUSH
41512: LD_VAR 0 1
41516: ARRAY
41517: ST_TO_ADDR
// end ;
41518: LD_VAR 0 2
41522: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41523: LD_INT 0
41525: PPUSH
41526: PPUSH
// if not mc_bases then
41527: LD_EXP 50
41531: NOT
41532: IFFALSE 41536
// exit ;
41534: GO 41601
// if mc_bases [ base ] then
41536: LD_EXP 50
41540: PUSH
41541: LD_VAR 0 1
41545: ARRAY
41546: IFFALSE 41601
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41548: LD_ADDR_VAR 0 3
41552: PUSH
41553: LD_EXP 50
41557: PUSH
41558: LD_VAR 0 1
41562: ARRAY
41563: PPUSH
41564: LD_INT 30
41566: PUSH
41567: LD_VAR 0 2
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PPUSH
41576: CALL_OW 72
41580: ST_TO_ADDR
// if result then
41581: LD_VAR 0 3
41585: IFFALSE 41601
// result := result [ 1 ] ;
41587: LD_ADDR_VAR 0 3
41591: PUSH
41592: LD_VAR 0 3
41596: PUSH
41597: LD_INT 1
41599: ARRAY
41600: ST_TO_ADDR
// end ; end ;
41601: LD_VAR 0 3
41605: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41606: LD_INT 0
41608: PPUSH
41609: PPUSH
// if not mc_bases then
41610: LD_EXP 50
41614: NOT
41615: IFFALSE 41619
// exit ;
41617: GO 41664
// if mc_bases [ base ] then
41619: LD_EXP 50
41623: PUSH
41624: LD_VAR 0 1
41628: ARRAY
41629: IFFALSE 41664
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41631: LD_ADDR_VAR 0 3
41635: PUSH
41636: LD_EXP 50
41640: PUSH
41641: LD_VAR 0 1
41645: ARRAY
41646: PPUSH
41647: LD_INT 30
41649: PUSH
41650: LD_VAR 0 2
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PPUSH
41659: CALL_OW 72
41663: ST_TO_ADDR
// end ;
41664: LD_VAR 0 3
41668: RET
// export function MC_SetTame ( base , area ) ; begin
41669: LD_INT 0
41671: PPUSH
// if not mc_bases or not base then
41672: LD_EXP 50
41676: NOT
41677: PUSH
41678: LD_VAR 0 1
41682: NOT
41683: OR
41684: IFFALSE 41688
// exit ;
41686: GO 41713
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41688: LD_ADDR_EXP 78
41692: PUSH
41693: LD_EXP 78
41697: PPUSH
41698: LD_VAR 0 1
41702: PPUSH
41703: LD_VAR 0 2
41707: PPUSH
41708: CALL_OW 1
41712: ST_TO_ADDR
// end ;
41713: LD_VAR 0 3
41717: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41718: LD_INT 0
41720: PPUSH
41721: PPUSH
// if not mc_bases or not base then
41722: LD_EXP 50
41726: NOT
41727: PUSH
41728: LD_VAR 0 1
41732: NOT
41733: OR
41734: IFFALSE 41738
// exit ;
41736: GO 41840
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41738: LD_ADDR_VAR 0 4
41742: PUSH
41743: LD_EXP 50
41747: PUSH
41748: LD_VAR 0 1
41752: ARRAY
41753: PPUSH
41754: LD_INT 30
41756: PUSH
41757: LD_VAR 0 2
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PPUSH
41766: CALL_OW 72
41770: ST_TO_ADDR
// if not tmp then
41771: LD_VAR 0 4
41775: NOT
41776: IFFALSE 41780
// exit ;
41778: GO 41840
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41780: LD_ADDR_EXP 82
41784: PUSH
41785: LD_EXP 82
41789: PPUSH
41790: LD_VAR 0 1
41794: PPUSH
41795: LD_EXP 82
41799: PUSH
41800: LD_VAR 0 1
41804: ARRAY
41805: PPUSH
41806: LD_EXP 82
41810: PUSH
41811: LD_VAR 0 1
41815: ARRAY
41816: PUSH
41817: LD_INT 1
41819: PLUS
41820: PPUSH
41821: LD_VAR 0 4
41825: PUSH
41826: LD_INT 1
41828: ARRAY
41829: PPUSH
41830: CALL_OW 2
41834: PPUSH
41835: CALL_OW 1
41839: ST_TO_ADDR
// end ;
41840: LD_VAR 0 3
41844: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41845: LD_INT 0
41847: PPUSH
41848: PPUSH
// if not mc_bases or not base or not kinds then
41849: LD_EXP 50
41853: NOT
41854: PUSH
41855: LD_VAR 0 1
41859: NOT
41860: OR
41861: PUSH
41862: LD_VAR 0 2
41866: NOT
41867: OR
41868: IFFALSE 41872
// exit ;
41870: GO 41933
// for i in kinds do
41872: LD_ADDR_VAR 0 4
41876: PUSH
41877: LD_VAR 0 2
41881: PUSH
41882: FOR_IN
41883: IFFALSE 41931
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41885: LD_ADDR_EXP 84
41889: PUSH
41890: LD_EXP 84
41894: PPUSH
41895: LD_VAR 0 1
41899: PUSH
41900: LD_EXP 84
41904: PUSH
41905: LD_VAR 0 1
41909: ARRAY
41910: PUSH
41911: LD_INT 1
41913: PLUS
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PPUSH
41919: LD_VAR 0 4
41923: PPUSH
41924: CALL 52460 0 3
41928: ST_TO_ADDR
41929: GO 41882
41931: POP
41932: POP
// end ;
41933: LD_VAR 0 3
41937: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41938: LD_INT 0
41940: PPUSH
// if not mc_bases or not base or not areas then
41941: LD_EXP 50
41945: NOT
41946: PUSH
41947: LD_VAR 0 1
41951: NOT
41952: OR
41953: PUSH
41954: LD_VAR 0 2
41958: NOT
41959: OR
41960: IFFALSE 41964
// exit ;
41962: GO 41989
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41964: LD_ADDR_EXP 68
41968: PUSH
41969: LD_EXP 68
41973: PPUSH
41974: LD_VAR 0 1
41978: PPUSH
41979: LD_VAR 0 2
41983: PPUSH
41984: CALL_OW 1
41988: ST_TO_ADDR
// end ;
41989: LD_VAR 0 3
41993: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41994: LD_INT 0
41996: PPUSH
// if not mc_bases or not base or not teleports_exit then
41997: LD_EXP 50
42001: NOT
42002: PUSH
42003: LD_VAR 0 1
42007: NOT
42008: OR
42009: PUSH
42010: LD_VAR 0 2
42014: NOT
42015: OR
42016: IFFALSE 42020
// exit ;
42018: GO 42045
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42020: LD_ADDR_EXP 85
42024: PUSH
42025: LD_EXP 85
42029: PPUSH
42030: LD_VAR 0 1
42034: PPUSH
42035: LD_VAR 0 2
42039: PPUSH
42040: CALL_OW 1
42044: ST_TO_ADDR
// end ;
42045: LD_VAR 0 3
42049: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42050: LD_INT 0
42052: PPUSH
42053: PPUSH
42054: PPUSH
// if not mc_bases or not base or not ext_list then
42055: LD_EXP 50
42059: NOT
42060: PUSH
42061: LD_VAR 0 1
42065: NOT
42066: OR
42067: PUSH
42068: LD_VAR 0 5
42072: NOT
42073: OR
42074: IFFALSE 42078
// exit ;
42076: GO 42251
// tmp := GetFacExtXYD ( x , y , d ) ;
42078: LD_ADDR_VAR 0 8
42082: PUSH
42083: LD_VAR 0 2
42087: PPUSH
42088: LD_VAR 0 3
42092: PPUSH
42093: LD_VAR 0 4
42097: PPUSH
42098: CALL 81139 0 3
42102: ST_TO_ADDR
// if not tmp then
42103: LD_VAR 0 8
42107: NOT
42108: IFFALSE 42112
// exit ;
42110: GO 42251
// for i in tmp do
42112: LD_ADDR_VAR 0 7
42116: PUSH
42117: LD_VAR 0 8
42121: PUSH
42122: FOR_IN
42123: IFFALSE 42249
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42125: LD_ADDR_EXP 55
42129: PUSH
42130: LD_EXP 55
42134: PPUSH
42135: LD_VAR 0 1
42139: PPUSH
42140: LD_EXP 55
42144: PUSH
42145: LD_VAR 0 1
42149: ARRAY
42150: PPUSH
42151: LD_EXP 55
42155: PUSH
42156: LD_VAR 0 1
42160: ARRAY
42161: PUSH
42162: LD_INT 1
42164: PLUS
42165: PPUSH
42166: LD_VAR 0 5
42170: PUSH
42171: LD_INT 1
42173: ARRAY
42174: PUSH
42175: LD_VAR 0 7
42179: PUSH
42180: LD_INT 1
42182: ARRAY
42183: PUSH
42184: LD_VAR 0 7
42188: PUSH
42189: LD_INT 2
42191: ARRAY
42192: PUSH
42193: LD_VAR 0 7
42197: PUSH
42198: LD_INT 3
42200: ARRAY
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: PPUSH
42208: CALL_OW 2
42212: PPUSH
42213: CALL_OW 1
42217: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42218: LD_ADDR_VAR 0 5
42222: PUSH
42223: LD_VAR 0 5
42227: PPUSH
42228: LD_INT 1
42230: PPUSH
42231: CALL_OW 3
42235: ST_TO_ADDR
// if not ext_list then
42236: LD_VAR 0 5
42240: NOT
42241: IFFALSE 42247
// exit ;
42243: POP
42244: POP
42245: GO 42251
// end ;
42247: GO 42122
42249: POP
42250: POP
// end ;
42251: LD_VAR 0 6
42255: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42256: LD_INT 0
42258: PPUSH
// if not mc_bases or not base or not weapon_list then
42259: LD_EXP 50
42263: NOT
42264: PUSH
42265: LD_VAR 0 1
42269: NOT
42270: OR
42271: PUSH
42272: LD_VAR 0 2
42276: NOT
42277: OR
42278: IFFALSE 42282
// exit ;
42280: GO 42307
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42282: LD_ADDR_EXP 89
42286: PUSH
42287: LD_EXP 89
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: LD_VAR 0 2
42301: PPUSH
42302: CALL_OW 1
42306: ST_TO_ADDR
// end ;
42307: LD_VAR 0 3
42311: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42312: LD_INT 0
42314: PPUSH
// if not mc_bases or not base or not tech_list then
42315: LD_EXP 50
42319: NOT
42320: PUSH
42321: LD_VAR 0 1
42325: NOT
42326: OR
42327: PUSH
42328: LD_VAR 0 2
42332: NOT
42333: OR
42334: IFFALSE 42338
// exit ;
42336: GO 42363
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42338: LD_ADDR_EXP 77
42342: PUSH
42343: LD_EXP 77
42347: PPUSH
42348: LD_VAR 0 1
42352: PPUSH
42353: LD_VAR 0 2
42357: PPUSH
42358: CALL_OW 1
42362: ST_TO_ADDR
// end ;
42363: LD_VAR 0 3
42367: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42368: LD_INT 0
42370: PPUSH
// if not mc_bases or not parking_area or not base then
42371: LD_EXP 50
42375: NOT
42376: PUSH
42377: LD_VAR 0 2
42381: NOT
42382: OR
42383: PUSH
42384: LD_VAR 0 1
42388: NOT
42389: OR
42390: IFFALSE 42394
// exit ;
42392: GO 42419
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42394: LD_ADDR_EXP 74
42398: PUSH
42399: LD_EXP 74
42403: PPUSH
42404: LD_VAR 0 1
42408: PPUSH
42409: LD_VAR 0 2
42413: PPUSH
42414: CALL_OW 1
42418: ST_TO_ADDR
// end ;
42419: LD_VAR 0 3
42423: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42424: LD_INT 0
42426: PPUSH
// if not mc_bases or not base or not scan_area then
42427: LD_EXP 50
42431: NOT
42432: PUSH
42433: LD_VAR 0 1
42437: NOT
42438: OR
42439: PUSH
42440: LD_VAR 0 2
42444: NOT
42445: OR
42446: IFFALSE 42450
// exit ;
42448: GO 42475
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42450: LD_ADDR_EXP 75
42454: PUSH
42455: LD_EXP 75
42459: PPUSH
42460: LD_VAR 0 1
42464: PPUSH
42465: LD_VAR 0 2
42469: PPUSH
42470: CALL_OW 1
42474: ST_TO_ADDR
// end ;
42475: LD_VAR 0 3
42479: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42480: LD_INT 0
42482: PPUSH
42483: PPUSH
// if not mc_bases or not base then
42484: LD_EXP 50
42488: NOT
42489: PUSH
42490: LD_VAR 0 1
42494: NOT
42495: OR
42496: IFFALSE 42500
// exit ;
42498: GO 42564
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42500: LD_ADDR_VAR 0 3
42504: PUSH
42505: LD_INT 1
42507: PUSH
42508: LD_INT 2
42510: PUSH
42511: LD_INT 3
42513: PUSH
42514: LD_INT 4
42516: PUSH
42517: LD_INT 11
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: LIST
42526: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42527: LD_ADDR_EXP 77
42531: PUSH
42532: LD_EXP 77
42536: PPUSH
42537: LD_VAR 0 1
42541: PPUSH
42542: LD_EXP 77
42546: PUSH
42547: LD_VAR 0 1
42551: ARRAY
42552: PUSH
42553: LD_VAR 0 3
42557: DIFF
42558: PPUSH
42559: CALL_OW 1
42563: ST_TO_ADDR
// end ;
42564: LD_VAR 0 2
42568: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42569: LD_INT 0
42571: PPUSH
// result := mc_vehicles [ base ] ;
42572: LD_ADDR_VAR 0 3
42576: PUSH
42577: LD_EXP 69
42581: PUSH
42582: LD_VAR 0 1
42586: ARRAY
42587: ST_TO_ADDR
// if onlyCombat then
42588: LD_VAR 0 2
42592: IFFALSE 42770
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42594: LD_ADDR_VAR 0 3
42598: PUSH
42599: LD_VAR 0 3
42603: PUSH
42604: LD_VAR 0 3
42608: PPUSH
42609: LD_INT 2
42611: PUSH
42612: LD_INT 34
42614: PUSH
42615: LD_INT 12
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 34
42624: PUSH
42625: LD_INT 51
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 34
42634: PUSH
42635: LD_EXP 94
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 34
42646: PUSH
42647: LD_INT 32
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 34
42656: PUSH
42657: LD_INT 13
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 34
42666: PUSH
42667: LD_INT 52
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 34
42676: PUSH
42677: LD_EXP 99
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 34
42688: PUSH
42689: LD_INT 14
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 34
42698: PUSH
42699: LD_INT 53
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 34
42708: PUSH
42709: LD_EXP 93
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 34
42720: PUSH
42721: LD_INT 31
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 34
42730: PUSH
42731: LD_INT 48
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 34
42740: PUSH
42741: LD_INT 8
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: PPUSH
42764: CALL_OW 72
42768: DIFF
42769: ST_TO_ADDR
// end ; end_of_file
42770: LD_VAR 0 3
42774: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42775: LD_INT 0
42777: PPUSH
42778: PPUSH
42779: PPUSH
// if not mc_bases or not skirmish then
42780: LD_EXP 50
42784: NOT
42785: PUSH
42786: LD_EXP 48
42790: NOT
42791: OR
42792: IFFALSE 42796
// exit ;
42794: GO 42961
// for i = 1 to mc_bases do
42796: LD_ADDR_VAR 0 4
42800: PUSH
42801: DOUBLE
42802: LD_INT 1
42804: DEC
42805: ST_TO_ADDR
42806: LD_EXP 50
42810: PUSH
42811: FOR_TO
42812: IFFALSE 42959
// begin if sci in mc_bases [ i ] then
42814: LD_VAR 0 2
42818: PUSH
42819: LD_EXP 50
42823: PUSH
42824: LD_VAR 0 4
42828: ARRAY
42829: IN
42830: IFFALSE 42957
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42832: LD_ADDR_EXP 79
42836: PUSH
42837: LD_EXP 79
42841: PPUSH
42842: LD_VAR 0 4
42846: PUSH
42847: LD_EXP 79
42851: PUSH
42852: LD_VAR 0 4
42856: ARRAY
42857: PUSH
42858: LD_INT 1
42860: PLUS
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PPUSH
42866: LD_VAR 0 1
42870: PPUSH
42871: CALL 52460 0 3
42875: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42876: LD_ADDR_VAR 0 5
42880: PUSH
42881: LD_EXP 50
42885: PUSH
42886: LD_VAR 0 4
42890: ARRAY
42891: PPUSH
42892: LD_INT 2
42894: PUSH
42895: LD_INT 30
42897: PUSH
42898: LD_INT 0
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: LD_INT 30
42907: PUSH
42908: LD_INT 1
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: LIST
42919: PPUSH
42920: CALL_OW 72
42924: PPUSH
42925: LD_VAR 0 1
42929: PPUSH
42930: CALL_OW 74
42934: ST_TO_ADDR
// if tmp then
42935: LD_VAR 0 5
42939: IFFALSE 42955
// ComStandNearbyBuilding ( ape , tmp ) ;
42941: LD_VAR 0 1
42945: PPUSH
42946: LD_VAR 0 5
42950: PPUSH
42951: CALL 49074 0 2
// break ;
42955: GO 42959
// end ; end ;
42957: GO 42811
42959: POP
42960: POP
// end ;
42961: LD_VAR 0 3
42965: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42966: LD_INT 0
42968: PPUSH
42969: PPUSH
42970: PPUSH
// if not mc_bases or not skirmish then
42971: LD_EXP 50
42975: NOT
42976: PUSH
42977: LD_EXP 48
42981: NOT
42982: OR
42983: IFFALSE 42987
// exit ;
42985: GO 43076
// for i = 1 to mc_bases do
42987: LD_ADDR_VAR 0 4
42991: PUSH
42992: DOUBLE
42993: LD_INT 1
42995: DEC
42996: ST_TO_ADDR
42997: LD_EXP 50
43001: PUSH
43002: FOR_TO
43003: IFFALSE 43074
// begin if building in mc_busy_turret_list [ i ] then
43005: LD_VAR 0 1
43009: PUSH
43010: LD_EXP 60
43014: PUSH
43015: LD_VAR 0 4
43019: ARRAY
43020: IN
43021: IFFALSE 43072
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43023: LD_ADDR_VAR 0 5
43027: PUSH
43028: LD_EXP 60
43032: PUSH
43033: LD_VAR 0 4
43037: ARRAY
43038: PUSH
43039: LD_VAR 0 1
43043: DIFF
43044: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43045: LD_ADDR_EXP 60
43049: PUSH
43050: LD_EXP 60
43054: PPUSH
43055: LD_VAR 0 4
43059: PPUSH
43060: LD_VAR 0 5
43064: PPUSH
43065: CALL_OW 1
43069: ST_TO_ADDR
// break ;
43070: GO 43074
// end ; end ;
43072: GO 43002
43074: POP
43075: POP
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// if not mc_bases or not skirmish then
43086: LD_EXP 50
43090: NOT
43091: PUSH
43092: LD_EXP 48
43096: NOT
43097: OR
43098: IFFALSE 43102
// exit ;
43100: GO 43301
// for i = 1 to mc_bases do
43102: LD_ADDR_VAR 0 5
43106: PUSH
43107: DOUBLE
43108: LD_INT 1
43110: DEC
43111: ST_TO_ADDR
43112: LD_EXP 50
43116: PUSH
43117: FOR_TO
43118: IFFALSE 43299
// if building in mc_bases [ i ] then
43120: LD_VAR 0 1
43124: PUSH
43125: LD_EXP 50
43129: PUSH
43130: LD_VAR 0 5
43134: ARRAY
43135: IN
43136: IFFALSE 43297
// begin tmp := mc_bases [ i ] diff building ;
43138: LD_ADDR_VAR 0 6
43142: PUSH
43143: LD_EXP 50
43147: PUSH
43148: LD_VAR 0 5
43152: ARRAY
43153: PUSH
43154: LD_VAR 0 1
43158: DIFF
43159: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43160: LD_ADDR_EXP 50
43164: PUSH
43165: LD_EXP 50
43169: PPUSH
43170: LD_VAR 0 5
43174: PPUSH
43175: LD_VAR 0 6
43179: PPUSH
43180: CALL_OW 1
43184: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43185: LD_VAR 0 1
43189: PUSH
43190: LD_EXP 58
43194: PUSH
43195: LD_VAR 0 5
43199: ARRAY
43200: IN
43201: IFFALSE 43240
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43203: LD_ADDR_EXP 58
43207: PUSH
43208: LD_EXP 58
43212: PPUSH
43213: LD_VAR 0 5
43217: PPUSH
43218: LD_EXP 58
43222: PUSH
43223: LD_VAR 0 5
43227: ARRAY
43228: PUSH
43229: LD_VAR 0 1
43233: DIFF
43234: PPUSH
43235: CALL_OW 1
43239: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43240: LD_VAR 0 1
43244: PUSH
43245: LD_EXP 59
43249: PUSH
43250: LD_VAR 0 5
43254: ARRAY
43255: IN
43256: IFFALSE 43295
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43258: LD_ADDR_EXP 59
43262: PUSH
43263: LD_EXP 59
43267: PPUSH
43268: LD_VAR 0 5
43272: PPUSH
43273: LD_EXP 59
43277: PUSH
43278: LD_VAR 0 5
43282: ARRAY
43283: PUSH
43284: LD_VAR 0 1
43288: DIFF
43289: PPUSH
43290: CALL_OW 1
43294: ST_TO_ADDR
// break ;
43295: GO 43299
// end ;
43297: GO 43117
43299: POP
43300: POP
// end ;
43301: LD_VAR 0 4
43305: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43306: LD_INT 0
43308: PPUSH
43309: PPUSH
43310: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43311: LD_EXP 50
43315: NOT
43316: PUSH
43317: LD_EXP 48
43321: NOT
43322: OR
43323: PUSH
43324: LD_VAR 0 3
43328: PUSH
43329: LD_EXP 76
43333: IN
43334: NOT
43335: OR
43336: IFFALSE 43340
// exit ;
43338: GO 43463
// for i = 1 to mc_vehicles do
43340: LD_ADDR_VAR 0 6
43344: PUSH
43345: DOUBLE
43346: LD_INT 1
43348: DEC
43349: ST_TO_ADDR
43350: LD_EXP 69
43354: PUSH
43355: FOR_TO
43356: IFFALSE 43461
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43358: LD_VAR 0 2
43362: PUSH
43363: LD_EXP 69
43367: PUSH
43368: LD_VAR 0 6
43372: ARRAY
43373: IN
43374: PUSH
43375: LD_VAR 0 1
43379: PUSH
43380: LD_EXP 69
43384: PUSH
43385: LD_VAR 0 6
43389: ARRAY
43390: IN
43391: OR
43392: IFFALSE 43459
// begin tmp := mc_vehicles [ i ] diff old ;
43394: LD_ADDR_VAR 0 7
43398: PUSH
43399: LD_EXP 69
43403: PUSH
43404: LD_VAR 0 6
43408: ARRAY
43409: PUSH
43410: LD_VAR 0 2
43414: DIFF
43415: ST_TO_ADDR
// tmp := tmp diff new ;
43416: LD_ADDR_VAR 0 7
43420: PUSH
43421: LD_VAR 0 7
43425: PUSH
43426: LD_VAR 0 1
43430: DIFF
43431: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43432: LD_ADDR_EXP 69
43436: PUSH
43437: LD_EXP 69
43441: PPUSH
43442: LD_VAR 0 6
43446: PPUSH
43447: LD_VAR 0 7
43451: PPUSH
43452: CALL_OW 1
43456: ST_TO_ADDR
// break ;
43457: GO 43461
// end ;
43459: GO 43355
43461: POP
43462: POP
// end ;
43463: LD_VAR 0 5
43467: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43468: LD_INT 0
43470: PPUSH
43471: PPUSH
43472: PPUSH
43473: PPUSH
// if not mc_bases or not skirmish then
43474: LD_EXP 50
43478: NOT
43479: PUSH
43480: LD_EXP 48
43484: NOT
43485: OR
43486: IFFALSE 43490
// exit ;
43488: GO 43873
// side := GetSide ( vehicle ) ;
43490: LD_ADDR_VAR 0 5
43494: PUSH
43495: LD_VAR 0 1
43499: PPUSH
43500: CALL_OW 255
43504: ST_TO_ADDR
// for i = 1 to mc_bases do
43505: LD_ADDR_VAR 0 4
43509: PUSH
43510: DOUBLE
43511: LD_INT 1
43513: DEC
43514: ST_TO_ADDR
43515: LD_EXP 50
43519: PUSH
43520: FOR_TO
43521: IFFALSE 43871
// begin if factory in mc_bases [ i ] then
43523: LD_VAR 0 2
43527: PUSH
43528: LD_EXP 50
43532: PUSH
43533: LD_VAR 0 4
43537: ARRAY
43538: IN
43539: IFFALSE 43869
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
43541: LD_EXP 72
43545: PUSH
43546: LD_VAR 0 4
43550: ARRAY
43551: PUSH
43552: LD_EXP 61
43556: PUSH
43557: LD_VAR 0 4
43561: ARRAY
43562: LESS
43563: PUSH
43564: LD_VAR 0 1
43568: PPUSH
43569: CALL_OW 264
43573: PUSH
43574: LD_INT 31
43576: PUSH
43577: LD_INT 32
43579: PUSH
43580: LD_INT 51
43582: PUSH
43583: LD_EXP 94
43587: PUSH
43588: LD_INT 12
43590: PUSH
43591: LD_INT 30
43593: PUSH
43594: LD_EXP 93
43598: PUSH
43599: LD_INT 11
43601: PUSH
43602: LD_INT 53
43604: PUSH
43605: LD_INT 14
43607: PUSH
43608: LD_EXP 97
43612: PUSH
43613: LD_INT 29
43615: PUSH
43616: LD_EXP 95
43620: PUSH
43621: LD_INT 13
43623: PUSH
43624: LD_INT 52
43626: PUSH
43627: LD_EXP 99
43631: PUSH
43632: LD_INT 48
43634: PUSH
43635: LD_INT 8
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: LIST
43650: LIST
43651: LIST
43652: LIST
43653: LIST
43654: LIST
43655: LIST
43656: LIST
43657: IN
43658: NOT
43659: AND
43660: IFFALSE 43708
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43662: LD_ADDR_EXP 72
43666: PUSH
43667: LD_EXP 72
43671: PPUSH
43672: LD_VAR 0 4
43676: PUSH
43677: LD_EXP 72
43681: PUSH
43682: LD_VAR 0 4
43686: ARRAY
43687: PUSH
43688: LD_INT 1
43690: PLUS
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PPUSH
43696: LD_VAR 0 1
43700: PPUSH
43701: CALL 52460 0 3
43705: ST_TO_ADDR
43706: GO 43752
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43708: LD_ADDR_EXP 69
43712: PUSH
43713: LD_EXP 69
43717: PPUSH
43718: LD_VAR 0 4
43722: PUSH
43723: LD_EXP 69
43727: PUSH
43728: LD_VAR 0 4
43732: ARRAY
43733: PUSH
43734: LD_INT 1
43736: PLUS
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PPUSH
43742: LD_VAR 0 1
43746: PPUSH
43747: CALL 52460 0 3
43751: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43752: LD_VAR 0 1
43756: PPUSH
43757: CALL_OW 263
43761: PUSH
43762: LD_INT 2
43764: EQUAL
43765: IFFALSE 43785
// begin repeat wait ( 0 0$1 ) ;
43767: LD_INT 35
43769: PPUSH
43770: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43774: LD_VAR 0 1
43778: PPUSH
43779: CALL_OW 312
43783: IFFALSE 43767
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43785: LD_VAR 0 1
43789: PPUSH
43790: LD_EXP 74
43794: PUSH
43795: LD_VAR 0 4
43799: ARRAY
43800: PPUSH
43801: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43805: LD_VAR 0 1
43809: PPUSH
43810: CALL_OW 263
43814: PUSH
43815: LD_INT 1
43817: NONEQUAL
43818: IFFALSE 43822
// break ;
43820: GO 43871
// repeat wait ( 0 0$1 ) ;
43822: LD_INT 35
43824: PPUSH
43825: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43829: LD_VAR 0 1
43833: PPUSH
43834: LD_EXP 74
43838: PUSH
43839: LD_VAR 0 4
43843: ARRAY
43844: PPUSH
43845: CALL_OW 308
43849: IFFALSE 43822
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43851: LD_VAR 0 1
43855: PPUSH
43856: CALL_OW 311
43860: PPUSH
43861: CALL_OW 121
// exit ;
43865: POP
43866: POP
43867: GO 43873
// end ; end ;
43869: GO 43520
43871: POP
43872: POP
// end ;
43873: LD_VAR 0 3
43877: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43878: LD_INT 0
43880: PPUSH
43881: PPUSH
43882: PPUSH
43883: PPUSH
// if not mc_bases or not skirmish then
43884: LD_EXP 50
43888: NOT
43889: PUSH
43890: LD_EXP 48
43894: NOT
43895: OR
43896: IFFALSE 43900
// exit ;
43898: GO 44253
// repeat wait ( 0 0$1 ) ;
43900: LD_INT 35
43902: PPUSH
43903: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43907: LD_VAR 0 2
43911: PPUSH
43912: LD_VAR 0 3
43916: PPUSH
43917: CALL_OW 284
43921: IFFALSE 43900
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43923: LD_VAR 0 2
43927: PPUSH
43928: LD_VAR 0 3
43932: PPUSH
43933: CALL_OW 283
43937: PUSH
43938: LD_INT 4
43940: EQUAL
43941: IFFALSE 43945
// exit ;
43943: GO 44253
// for i = 1 to mc_bases do
43945: LD_ADDR_VAR 0 7
43949: PUSH
43950: DOUBLE
43951: LD_INT 1
43953: DEC
43954: ST_TO_ADDR
43955: LD_EXP 50
43959: PUSH
43960: FOR_TO
43961: IFFALSE 44251
// begin if mc_crates_area [ i ] then
43963: LD_EXP 68
43967: PUSH
43968: LD_VAR 0 7
43972: ARRAY
43973: IFFALSE 44084
// for j in mc_crates_area [ i ] do
43975: LD_ADDR_VAR 0 8
43979: PUSH
43980: LD_EXP 68
43984: PUSH
43985: LD_VAR 0 7
43989: ARRAY
43990: PUSH
43991: FOR_IN
43992: IFFALSE 44082
// if InArea ( x , y , j ) then
43994: LD_VAR 0 2
43998: PPUSH
43999: LD_VAR 0 3
44003: PPUSH
44004: LD_VAR 0 8
44008: PPUSH
44009: CALL_OW 309
44013: IFFALSE 44080
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44015: LD_ADDR_EXP 66
44019: PUSH
44020: LD_EXP 66
44024: PPUSH
44025: LD_VAR 0 7
44029: PUSH
44030: LD_EXP 66
44034: PUSH
44035: LD_VAR 0 7
44039: ARRAY
44040: PUSH
44041: LD_INT 1
44043: PLUS
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PPUSH
44049: LD_VAR 0 4
44053: PUSH
44054: LD_VAR 0 2
44058: PUSH
44059: LD_VAR 0 3
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: LIST
44068: PPUSH
44069: CALL 52460 0 3
44073: ST_TO_ADDR
// exit ;
44074: POP
44075: POP
44076: POP
44077: POP
44078: GO 44253
// end ;
44080: GO 43991
44082: POP
44083: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44084: LD_ADDR_VAR 0 9
44088: PUSH
44089: LD_EXP 50
44093: PUSH
44094: LD_VAR 0 7
44098: ARRAY
44099: PPUSH
44100: LD_INT 2
44102: PUSH
44103: LD_INT 30
44105: PUSH
44106: LD_INT 0
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 30
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: LIST
44127: PPUSH
44128: CALL_OW 72
44132: ST_TO_ADDR
// if not depot then
44133: LD_VAR 0 9
44137: NOT
44138: IFFALSE 44142
// continue ;
44140: GO 43960
// for j in depot do
44142: LD_ADDR_VAR 0 8
44146: PUSH
44147: LD_VAR 0 9
44151: PUSH
44152: FOR_IN
44153: IFFALSE 44247
// if GetDistUnitXY ( j , x , y ) < 30 then
44155: LD_VAR 0 8
44159: PPUSH
44160: LD_VAR 0 2
44164: PPUSH
44165: LD_VAR 0 3
44169: PPUSH
44170: CALL_OW 297
44174: PUSH
44175: LD_INT 30
44177: LESS
44178: IFFALSE 44245
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44180: LD_ADDR_EXP 66
44184: PUSH
44185: LD_EXP 66
44189: PPUSH
44190: LD_VAR 0 7
44194: PUSH
44195: LD_EXP 66
44199: PUSH
44200: LD_VAR 0 7
44204: ARRAY
44205: PUSH
44206: LD_INT 1
44208: PLUS
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PPUSH
44214: LD_VAR 0 4
44218: PUSH
44219: LD_VAR 0 2
44223: PUSH
44224: LD_VAR 0 3
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: LIST
44233: PPUSH
44234: CALL 52460 0 3
44238: ST_TO_ADDR
// exit ;
44239: POP
44240: POP
44241: POP
44242: POP
44243: GO 44253
// end ;
44245: GO 44152
44247: POP
44248: POP
// end ;
44249: GO 43960
44251: POP
44252: POP
// end ;
44253: LD_VAR 0 6
44257: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44258: LD_INT 0
44260: PPUSH
44261: PPUSH
44262: PPUSH
44263: PPUSH
// if not mc_bases or not skirmish then
44264: LD_EXP 50
44268: NOT
44269: PUSH
44270: LD_EXP 48
44274: NOT
44275: OR
44276: IFFALSE 44280
// exit ;
44278: GO 44557
// side := GetSide ( lab ) ;
44280: LD_ADDR_VAR 0 4
44284: PUSH
44285: LD_VAR 0 2
44289: PPUSH
44290: CALL_OW 255
44294: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44295: LD_VAR 0 4
44299: PUSH
44300: LD_EXP 76
44304: IN
44305: NOT
44306: PUSH
44307: LD_EXP 77
44311: NOT
44312: OR
44313: PUSH
44314: LD_EXP 50
44318: NOT
44319: OR
44320: IFFALSE 44324
// exit ;
44322: GO 44557
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44324: LD_ADDR_EXP 77
44328: PUSH
44329: LD_EXP 77
44333: PPUSH
44334: LD_VAR 0 4
44338: PPUSH
44339: LD_EXP 77
44343: PUSH
44344: LD_VAR 0 4
44348: ARRAY
44349: PUSH
44350: LD_VAR 0 1
44354: DIFF
44355: PPUSH
44356: CALL_OW 1
44360: ST_TO_ADDR
// for i = 1 to mc_bases do
44361: LD_ADDR_VAR 0 5
44365: PUSH
44366: DOUBLE
44367: LD_INT 1
44369: DEC
44370: ST_TO_ADDR
44371: LD_EXP 50
44375: PUSH
44376: FOR_TO
44377: IFFALSE 44555
// begin if lab in mc_bases [ i ] then
44379: LD_VAR 0 2
44383: PUSH
44384: LD_EXP 50
44388: PUSH
44389: LD_VAR 0 5
44393: ARRAY
44394: IN
44395: IFFALSE 44553
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44397: LD_VAR 0 1
44401: PUSH
44402: LD_INT 11
44404: PUSH
44405: LD_INT 4
44407: PUSH
44408: LD_INT 3
44410: PUSH
44411: LD_INT 2
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: IN
44420: PUSH
44421: LD_EXP 80
44425: PUSH
44426: LD_VAR 0 5
44430: ARRAY
44431: AND
44432: IFFALSE 44553
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44434: LD_ADDR_VAR 0 6
44438: PUSH
44439: LD_EXP 80
44443: PUSH
44444: LD_VAR 0 5
44448: ARRAY
44449: PUSH
44450: LD_INT 1
44452: ARRAY
44453: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44454: LD_ADDR_EXP 80
44458: PUSH
44459: LD_EXP 80
44463: PPUSH
44464: LD_VAR 0 5
44468: PPUSH
44469: EMPTY
44470: PPUSH
44471: CALL_OW 1
44475: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44476: LD_VAR 0 6
44480: PPUSH
44481: LD_INT 0
44483: PPUSH
44484: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44488: LD_VAR 0 6
44492: PPUSH
44493: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44497: LD_ADDR_EXP 79
44501: PUSH
44502: LD_EXP 79
44506: PPUSH
44507: LD_VAR 0 5
44511: PPUSH
44512: LD_EXP 79
44516: PUSH
44517: LD_VAR 0 5
44521: ARRAY
44522: PPUSH
44523: LD_INT 1
44525: PPUSH
44526: LD_VAR 0 6
44530: PPUSH
44531: CALL_OW 2
44535: PPUSH
44536: CALL_OW 1
44540: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44541: LD_VAR 0 5
44545: PPUSH
44546: LD_INT 112
44548: PPUSH
44549: CALL 21524 0 2
// end ; end ; end ;
44553: GO 44376
44555: POP
44556: POP
// end ;
44557: LD_VAR 0 3
44561: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44562: LD_INT 0
44564: PPUSH
44565: PPUSH
44566: PPUSH
44567: PPUSH
44568: PPUSH
44569: PPUSH
44570: PPUSH
44571: PPUSH
// if not mc_bases or not skirmish then
44572: LD_EXP 50
44576: NOT
44577: PUSH
44578: LD_EXP 48
44582: NOT
44583: OR
44584: IFFALSE 44588
// exit ;
44586: GO 45959
// for i = 1 to mc_bases do
44588: LD_ADDR_VAR 0 3
44592: PUSH
44593: DOUBLE
44594: LD_INT 1
44596: DEC
44597: ST_TO_ADDR
44598: LD_EXP 50
44602: PUSH
44603: FOR_TO
44604: IFFALSE 45957
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44606: LD_VAR 0 1
44610: PUSH
44611: LD_EXP 50
44615: PUSH
44616: LD_VAR 0 3
44620: ARRAY
44621: IN
44622: PUSH
44623: LD_VAR 0 1
44627: PUSH
44628: LD_EXP 57
44632: PUSH
44633: LD_VAR 0 3
44637: ARRAY
44638: IN
44639: OR
44640: PUSH
44641: LD_VAR 0 1
44645: PUSH
44646: LD_EXP 72
44650: PUSH
44651: LD_VAR 0 3
44655: ARRAY
44656: IN
44657: OR
44658: PUSH
44659: LD_VAR 0 1
44663: PUSH
44664: LD_EXP 69
44668: PUSH
44669: LD_VAR 0 3
44673: ARRAY
44674: IN
44675: OR
44676: PUSH
44677: LD_VAR 0 1
44681: PUSH
44682: LD_EXP 79
44686: PUSH
44687: LD_VAR 0 3
44691: ARRAY
44692: IN
44693: OR
44694: PUSH
44695: LD_VAR 0 1
44699: PUSH
44700: LD_EXP 80
44704: PUSH
44705: LD_VAR 0 3
44709: ARRAY
44710: IN
44711: OR
44712: IFFALSE 45955
// begin if un in mc_ape [ i ] then
44714: LD_VAR 0 1
44718: PUSH
44719: LD_EXP 79
44723: PUSH
44724: LD_VAR 0 3
44728: ARRAY
44729: IN
44730: IFFALSE 44769
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44732: LD_ADDR_EXP 79
44736: PUSH
44737: LD_EXP 79
44741: PPUSH
44742: LD_VAR 0 3
44746: PPUSH
44747: LD_EXP 79
44751: PUSH
44752: LD_VAR 0 3
44756: ARRAY
44757: PUSH
44758: LD_VAR 0 1
44762: DIFF
44763: PPUSH
44764: CALL_OW 1
44768: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44769: LD_VAR 0 1
44773: PUSH
44774: LD_EXP 80
44778: PUSH
44779: LD_VAR 0 3
44783: ARRAY
44784: IN
44785: IFFALSE 44809
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44787: LD_ADDR_EXP 80
44791: PUSH
44792: LD_EXP 80
44796: PPUSH
44797: LD_VAR 0 3
44801: PPUSH
44802: EMPTY
44803: PPUSH
44804: CALL_OW 1
44808: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44809: LD_VAR 0 1
44813: PPUSH
44814: CALL_OW 247
44818: PUSH
44819: LD_INT 2
44821: EQUAL
44822: PUSH
44823: LD_VAR 0 1
44827: PPUSH
44828: CALL_OW 110
44832: PUSH
44833: LD_INT 20
44835: EQUAL
44836: PUSH
44837: LD_VAR 0 1
44841: PUSH
44842: LD_EXP 72
44846: PUSH
44847: LD_VAR 0 3
44851: ARRAY
44852: IN
44853: OR
44854: PUSH
44855: LD_VAR 0 1
44859: PPUSH
44860: CALL_OW 264
44864: PUSH
44865: LD_INT 12
44867: PUSH
44868: LD_INT 51
44870: PUSH
44871: LD_EXP 94
44875: PUSH
44876: LD_INT 32
44878: PUSH
44879: LD_INT 13
44881: PUSH
44882: LD_INT 52
44884: PUSH
44885: LD_INT 31
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: IN
44897: OR
44898: AND
44899: IFFALSE 45207
// begin if un in mc_defender [ i ] then
44901: LD_VAR 0 1
44905: PUSH
44906: LD_EXP 72
44910: PUSH
44911: LD_VAR 0 3
44915: ARRAY
44916: IN
44917: IFFALSE 44956
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44919: LD_ADDR_EXP 72
44923: PUSH
44924: LD_EXP 72
44928: PPUSH
44929: LD_VAR 0 3
44933: PPUSH
44934: LD_EXP 72
44938: PUSH
44939: LD_VAR 0 3
44943: ARRAY
44944: PUSH
44945: LD_VAR 0 1
44949: DIFF
44950: PPUSH
44951: CALL_OW 1
44955: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44956: LD_ADDR_VAR 0 8
44960: PUSH
44961: LD_VAR 0 3
44965: PPUSH
44966: LD_INT 3
44968: PPUSH
44969: CALL 41606 0 2
44973: ST_TO_ADDR
// if fac then
44974: LD_VAR 0 8
44978: IFFALSE 45207
// begin for j in fac do
44980: LD_ADDR_VAR 0 4
44984: PUSH
44985: LD_VAR 0 8
44989: PUSH
44990: FOR_IN
44991: IFFALSE 45205
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44993: LD_ADDR_VAR 0 9
44997: PUSH
44998: LD_VAR 0 8
45002: PPUSH
45003: LD_VAR 0 1
45007: PPUSH
45008: CALL_OW 265
45012: PPUSH
45013: LD_VAR 0 1
45017: PPUSH
45018: CALL_OW 262
45022: PPUSH
45023: LD_VAR 0 1
45027: PPUSH
45028: CALL_OW 263
45032: PPUSH
45033: LD_VAR 0 1
45037: PPUSH
45038: CALL_OW 264
45042: PPUSH
45043: CALL 49992 0 5
45047: ST_TO_ADDR
// if components then
45048: LD_VAR 0 9
45052: IFFALSE 45203
// begin if GetWeapon ( un ) = ar_control_tower then
45054: LD_VAR 0 1
45058: PPUSH
45059: CALL_OW 264
45063: PUSH
45064: LD_INT 31
45066: EQUAL
45067: IFFALSE 45184
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45069: LD_VAR 0 1
45073: PPUSH
45074: CALL_OW 311
45078: PPUSH
45079: LD_INT 0
45081: PPUSH
45082: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45086: LD_ADDR_EXP 90
45090: PUSH
45091: LD_EXP 90
45095: PPUSH
45096: LD_VAR 0 3
45100: PPUSH
45101: LD_EXP 90
45105: PUSH
45106: LD_VAR 0 3
45110: ARRAY
45111: PUSH
45112: LD_VAR 0 1
45116: PPUSH
45117: CALL_OW 311
45121: DIFF
45122: PPUSH
45123: CALL_OW 1
45127: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45128: LD_ADDR_VAR 0 7
45132: PUSH
45133: LD_EXP 71
45137: PUSH
45138: LD_VAR 0 3
45142: ARRAY
45143: PPUSH
45144: LD_INT 1
45146: PPUSH
45147: LD_VAR 0 9
45151: PPUSH
45152: CALL_OW 2
45156: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45157: LD_ADDR_EXP 71
45161: PUSH
45162: LD_EXP 71
45166: PPUSH
45167: LD_VAR 0 3
45171: PPUSH
45172: LD_VAR 0 7
45176: PPUSH
45177: CALL_OW 1
45181: ST_TO_ADDR
// end else
45182: GO 45201
// MC_InsertProduceList ( i , [ components ] ) ;
45184: LD_VAR 0 3
45188: PPUSH
45189: LD_VAR 0 9
45193: PUSH
45194: EMPTY
45195: LIST
45196: PPUSH
45197: CALL 41151 0 2
// break ;
45201: GO 45205
// end ; end ;
45203: GO 44990
45205: POP
45206: POP
// end ; end ; if GetType ( un ) = unit_building then
45207: LD_VAR 0 1
45211: PPUSH
45212: CALL_OW 247
45216: PUSH
45217: LD_INT 3
45219: EQUAL
45220: IFFALSE 45623
// begin btype := GetBType ( un ) ;
45222: LD_ADDR_VAR 0 5
45226: PUSH
45227: LD_VAR 0 1
45231: PPUSH
45232: CALL_OW 266
45236: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45237: LD_VAR 0 5
45241: PUSH
45242: LD_INT 29
45244: PUSH
45245: LD_INT 30
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: IN
45252: IFFALSE 45325
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45254: LD_VAR 0 1
45258: PPUSH
45259: CALL_OW 250
45263: PPUSH
45264: LD_VAR 0 1
45268: PPUSH
45269: CALL_OW 251
45273: PPUSH
45274: LD_VAR 0 1
45278: PPUSH
45279: CALL_OW 255
45283: PPUSH
45284: CALL_OW 440
45288: NOT
45289: IFFALSE 45325
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45291: LD_VAR 0 1
45295: PPUSH
45296: CALL_OW 250
45300: PPUSH
45301: LD_VAR 0 1
45305: PPUSH
45306: CALL_OW 251
45310: PPUSH
45311: LD_VAR 0 1
45315: PPUSH
45316: CALL_OW 255
45320: PPUSH
45321: CALL_OW 441
// end ; if btype = b_warehouse then
45325: LD_VAR 0 5
45329: PUSH
45330: LD_INT 1
45332: EQUAL
45333: IFFALSE 45351
// begin btype := b_depot ;
45335: LD_ADDR_VAR 0 5
45339: PUSH
45340: LD_INT 0
45342: ST_TO_ADDR
// pos := 1 ;
45343: LD_ADDR_VAR 0 6
45347: PUSH
45348: LD_INT 1
45350: ST_TO_ADDR
// end ; if btype = b_factory then
45351: LD_VAR 0 5
45355: PUSH
45356: LD_INT 3
45358: EQUAL
45359: IFFALSE 45377
// begin btype := b_workshop ;
45361: LD_ADDR_VAR 0 5
45365: PUSH
45366: LD_INT 2
45368: ST_TO_ADDR
// pos := 1 ;
45369: LD_ADDR_VAR 0 6
45373: PUSH
45374: LD_INT 1
45376: ST_TO_ADDR
// end ; if btype = b_barracks then
45377: LD_VAR 0 5
45381: PUSH
45382: LD_INT 5
45384: EQUAL
45385: IFFALSE 45395
// btype := b_armoury ;
45387: LD_ADDR_VAR 0 5
45391: PUSH
45392: LD_INT 4
45394: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45395: LD_VAR 0 5
45399: PUSH
45400: LD_INT 7
45402: PUSH
45403: LD_INT 8
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: IN
45410: IFFALSE 45420
// btype := b_lab ;
45412: LD_ADDR_VAR 0 5
45416: PUSH
45417: LD_INT 6
45419: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45420: LD_ADDR_EXP 55
45424: PUSH
45425: LD_EXP 55
45429: PPUSH
45430: LD_VAR 0 3
45434: PUSH
45435: LD_EXP 55
45439: PUSH
45440: LD_VAR 0 3
45444: ARRAY
45445: PUSH
45446: LD_INT 1
45448: PLUS
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PPUSH
45454: LD_VAR 0 5
45458: PUSH
45459: LD_VAR 0 1
45463: PPUSH
45464: CALL_OW 250
45468: PUSH
45469: LD_VAR 0 1
45473: PPUSH
45474: CALL_OW 251
45478: PUSH
45479: LD_VAR 0 1
45483: PPUSH
45484: CALL_OW 254
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: PPUSH
45495: CALL 52460 0 3
45499: ST_TO_ADDR
// if pos = 1 then
45500: LD_VAR 0 6
45504: PUSH
45505: LD_INT 1
45507: EQUAL
45508: IFFALSE 45623
// begin tmp := mc_build_list [ i ] ;
45510: LD_ADDR_VAR 0 7
45514: PUSH
45515: LD_EXP 55
45519: PUSH
45520: LD_VAR 0 3
45524: ARRAY
45525: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45526: LD_VAR 0 7
45530: PPUSH
45531: LD_INT 2
45533: PUSH
45534: LD_INT 30
45536: PUSH
45537: LD_INT 0
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PUSH
45544: LD_INT 30
45546: PUSH
45547: LD_INT 1
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: LIST
45558: PPUSH
45559: CALL_OW 72
45563: IFFALSE 45573
// pos := 2 ;
45565: LD_ADDR_VAR 0 6
45569: PUSH
45570: LD_INT 2
45572: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45573: LD_ADDR_VAR 0 7
45577: PUSH
45578: LD_VAR 0 7
45582: PPUSH
45583: LD_VAR 0 6
45587: PPUSH
45588: LD_VAR 0 7
45592: PPUSH
45593: CALL 52786 0 3
45597: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45598: LD_ADDR_EXP 55
45602: PUSH
45603: LD_EXP 55
45607: PPUSH
45608: LD_VAR 0 3
45612: PPUSH
45613: LD_VAR 0 7
45617: PPUSH
45618: CALL_OW 1
45622: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45623: LD_VAR 0 1
45627: PUSH
45628: LD_EXP 50
45632: PUSH
45633: LD_VAR 0 3
45637: ARRAY
45638: IN
45639: IFFALSE 45678
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45641: LD_ADDR_EXP 50
45645: PUSH
45646: LD_EXP 50
45650: PPUSH
45651: LD_VAR 0 3
45655: PPUSH
45656: LD_EXP 50
45660: PUSH
45661: LD_VAR 0 3
45665: ARRAY
45666: PUSH
45667: LD_VAR 0 1
45671: DIFF
45672: PPUSH
45673: CALL_OW 1
45677: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45678: LD_VAR 0 1
45682: PUSH
45683: LD_EXP 57
45687: PUSH
45688: LD_VAR 0 3
45692: ARRAY
45693: IN
45694: IFFALSE 45733
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45696: LD_ADDR_EXP 57
45700: PUSH
45701: LD_EXP 57
45705: PPUSH
45706: LD_VAR 0 3
45710: PPUSH
45711: LD_EXP 57
45715: PUSH
45716: LD_VAR 0 3
45720: ARRAY
45721: PUSH
45722: LD_VAR 0 1
45726: DIFF
45727: PPUSH
45728: CALL_OW 1
45732: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45733: LD_VAR 0 1
45737: PUSH
45738: LD_EXP 69
45742: PUSH
45743: LD_VAR 0 3
45747: ARRAY
45748: IN
45749: IFFALSE 45788
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45751: LD_ADDR_EXP 69
45755: PUSH
45756: LD_EXP 69
45760: PPUSH
45761: LD_VAR 0 3
45765: PPUSH
45766: LD_EXP 69
45770: PUSH
45771: LD_VAR 0 3
45775: ARRAY
45776: PUSH
45777: LD_VAR 0 1
45781: DIFF
45782: PPUSH
45783: CALL_OW 1
45787: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45788: LD_VAR 0 1
45792: PUSH
45793: LD_EXP 72
45797: PUSH
45798: LD_VAR 0 3
45802: ARRAY
45803: IN
45804: IFFALSE 45843
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45806: LD_ADDR_EXP 72
45810: PUSH
45811: LD_EXP 72
45815: PPUSH
45816: LD_VAR 0 3
45820: PPUSH
45821: LD_EXP 72
45825: PUSH
45826: LD_VAR 0 3
45830: ARRAY
45831: PUSH
45832: LD_VAR 0 1
45836: DIFF
45837: PPUSH
45838: CALL_OW 1
45842: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45843: LD_VAR 0 1
45847: PUSH
45848: LD_EXP 59
45852: PUSH
45853: LD_VAR 0 3
45857: ARRAY
45858: IN
45859: IFFALSE 45898
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45861: LD_ADDR_EXP 59
45865: PUSH
45866: LD_EXP 59
45870: PPUSH
45871: LD_VAR 0 3
45875: PPUSH
45876: LD_EXP 59
45880: PUSH
45881: LD_VAR 0 3
45885: ARRAY
45886: PUSH
45887: LD_VAR 0 1
45891: DIFF
45892: PPUSH
45893: CALL_OW 1
45897: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45898: LD_VAR 0 1
45902: PUSH
45903: LD_EXP 58
45907: PUSH
45908: LD_VAR 0 3
45912: ARRAY
45913: IN
45914: IFFALSE 45953
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45916: LD_ADDR_EXP 58
45920: PUSH
45921: LD_EXP 58
45925: PPUSH
45926: LD_VAR 0 3
45930: PPUSH
45931: LD_EXP 58
45935: PUSH
45936: LD_VAR 0 3
45940: ARRAY
45941: PUSH
45942: LD_VAR 0 1
45946: DIFF
45947: PPUSH
45948: CALL_OW 1
45952: ST_TO_ADDR
// end ; break ;
45953: GO 45957
// end ;
45955: GO 44603
45957: POP
45958: POP
// end ;
45959: LD_VAR 0 2
45963: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45964: LD_INT 0
45966: PPUSH
45967: PPUSH
45968: PPUSH
// if not mc_bases or not skirmish then
45969: LD_EXP 50
45973: NOT
45974: PUSH
45975: LD_EXP 48
45979: NOT
45980: OR
45981: IFFALSE 45985
// exit ;
45983: GO 46200
// for i = 1 to mc_bases do
45985: LD_ADDR_VAR 0 3
45989: PUSH
45990: DOUBLE
45991: LD_INT 1
45993: DEC
45994: ST_TO_ADDR
45995: LD_EXP 50
45999: PUSH
46000: FOR_TO
46001: IFFALSE 46198
// begin if building in mc_construct_list [ i ] then
46003: LD_VAR 0 1
46007: PUSH
46008: LD_EXP 57
46012: PUSH
46013: LD_VAR 0 3
46017: ARRAY
46018: IN
46019: IFFALSE 46196
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46021: LD_ADDR_EXP 57
46025: PUSH
46026: LD_EXP 57
46030: PPUSH
46031: LD_VAR 0 3
46035: PPUSH
46036: LD_EXP 57
46040: PUSH
46041: LD_VAR 0 3
46045: ARRAY
46046: PUSH
46047: LD_VAR 0 1
46051: DIFF
46052: PPUSH
46053: CALL_OW 1
46057: ST_TO_ADDR
// if building in mc_lab [ i ] then
46058: LD_VAR 0 1
46062: PUSH
46063: LD_EXP 83
46067: PUSH
46068: LD_VAR 0 3
46072: ARRAY
46073: IN
46074: IFFALSE 46129
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46076: LD_ADDR_EXP 84
46080: PUSH
46081: LD_EXP 84
46085: PPUSH
46086: LD_VAR 0 3
46090: PPUSH
46091: LD_EXP 84
46095: PUSH
46096: LD_VAR 0 3
46100: ARRAY
46101: PPUSH
46102: LD_INT 1
46104: PPUSH
46105: LD_EXP 84
46109: PUSH
46110: LD_VAR 0 3
46114: ARRAY
46115: PPUSH
46116: LD_INT 0
46118: PPUSH
46119: CALL 51878 0 4
46123: PPUSH
46124: CALL_OW 1
46128: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46129: LD_VAR 0 1
46133: PUSH
46134: LD_EXP 50
46138: PUSH
46139: LD_VAR 0 3
46143: ARRAY
46144: IN
46145: NOT
46146: IFFALSE 46192
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46148: LD_ADDR_EXP 50
46152: PUSH
46153: LD_EXP 50
46157: PPUSH
46158: LD_VAR 0 3
46162: PUSH
46163: LD_EXP 50
46167: PUSH
46168: LD_VAR 0 3
46172: ARRAY
46173: PUSH
46174: LD_INT 1
46176: PLUS
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PPUSH
46182: LD_VAR 0 1
46186: PPUSH
46187: CALL 52460 0 3
46191: ST_TO_ADDR
// exit ;
46192: POP
46193: POP
46194: GO 46200
// end ; end ;
46196: GO 46000
46198: POP
46199: POP
// end ;
46200: LD_VAR 0 2
46204: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46205: LD_INT 0
46207: PPUSH
46208: PPUSH
46209: PPUSH
46210: PPUSH
46211: PPUSH
46212: PPUSH
46213: PPUSH
// if not mc_bases or not skirmish then
46214: LD_EXP 50
46218: NOT
46219: PUSH
46220: LD_EXP 48
46224: NOT
46225: OR
46226: IFFALSE 46230
// exit ;
46228: GO 46891
// for i = 1 to mc_bases do
46230: LD_ADDR_VAR 0 3
46234: PUSH
46235: DOUBLE
46236: LD_INT 1
46238: DEC
46239: ST_TO_ADDR
46240: LD_EXP 50
46244: PUSH
46245: FOR_TO
46246: IFFALSE 46889
// begin if building in mc_construct_list [ i ] then
46248: LD_VAR 0 1
46252: PUSH
46253: LD_EXP 57
46257: PUSH
46258: LD_VAR 0 3
46262: ARRAY
46263: IN
46264: IFFALSE 46887
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46266: LD_ADDR_EXP 57
46270: PUSH
46271: LD_EXP 57
46275: PPUSH
46276: LD_VAR 0 3
46280: PPUSH
46281: LD_EXP 57
46285: PUSH
46286: LD_VAR 0 3
46290: ARRAY
46291: PUSH
46292: LD_VAR 0 1
46296: DIFF
46297: PPUSH
46298: CALL_OW 1
46302: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46303: LD_ADDR_EXP 50
46307: PUSH
46308: LD_EXP 50
46312: PPUSH
46313: LD_VAR 0 3
46317: PUSH
46318: LD_EXP 50
46322: PUSH
46323: LD_VAR 0 3
46327: ARRAY
46328: PUSH
46329: LD_INT 1
46331: PLUS
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PPUSH
46337: LD_VAR 0 1
46341: PPUSH
46342: CALL 52460 0 3
46346: ST_TO_ADDR
// btype := GetBType ( building ) ;
46347: LD_ADDR_VAR 0 5
46351: PUSH
46352: LD_VAR 0 1
46356: PPUSH
46357: CALL_OW 266
46361: ST_TO_ADDR
// side := GetSide ( building ) ;
46362: LD_ADDR_VAR 0 8
46366: PUSH
46367: LD_VAR 0 1
46371: PPUSH
46372: CALL_OW 255
46376: ST_TO_ADDR
// if btype = b_lab then
46377: LD_VAR 0 5
46381: PUSH
46382: LD_INT 6
46384: EQUAL
46385: IFFALSE 46435
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46387: LD_ADDR_EXP 83
46391: PUSH
46392: LD_EXP 83
46396: PPUSH
46397: LD_VAR 0 3
46401: PUSH
46402: LD_EXP 83
46406: PUSH
46407: LD_VAR 0 3
46411: ARRAY
46412: PUSH
46413: LD_INT 1
46415: PLUS
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PPUSH
46421: LD_VAR 0 1
46425: PPUSH
46426: CALL 52460 0 3
46430: ST_TO_ADDR
// exit ;
46431: POP
46432: POP
46433: GO 46891
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46435: LD_VAR 0 5
46439: PUSH
46440: LD_INT 0
46442: PUSH
46443: LD_INT 2
46445: PUSH
46446: LD_INT 4
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: LIST
46453: IN
46454: IFFALSE 46578
// begin if btype = b_armoury then
46456: LD_VAR 0 5
46460: PUSH
46461: LD_INT 4
46463: EQUAL
46464: IFFALSE 46474
// btype := b_barracks ;
46466: LD_ADDR_VAR 0 5
46470: PUSH
46471: LD_INT 5
46473: ST_TO_ADDR
// if btype = b_depot then
46474: LD_VAR 0 5
46478: PUSH
46479: LD_INT 0
46481: EQUAL
46482: IFFALSE 46492
// btype := b_warehouse ;
46484: LD_ADDR_VAR 0 5
46488: PUSH
46489: LD_INT 1
46491: ST_TO_ADDR
// if btype = b_workshop then
46492: LD_VAR 0 5
46496: PUSH
46497: LD_INT 2
46499: EQUAL
46500: IFFALSE 46510
// btype := b_factory ;
46502: LD_ADDR_VAR 0 5
46506: PUSH
46507: LD_INT 3
46509: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46510: LD_VAR 0 5
46514: PPUSH
46515: LD_VAR 0 8
46519: PPUSH
46520: CALL_OW 323
46524: PUSH
46525: LD_INT 1
46527: EQUAL
46528: IFFALSE 46574
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46530: LD_ADDR_EXP 82
46534: PUSH
46535: LD_EXP 82
46539: PPUSH
46540: LD_VAR 0 3
46544: PUSH
46545: LD_EXP 82
46549: PUSH
46550: LD_VAR 0 3
46554: ARRAY
46555: PUSH
46556: LD_INT 1
46558: PLUS
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PPUSH
46564: LD_VAR 0 1
46568: PPUSH
46569: CALL 52460 0 3
46573: ST_TO_ADDR
// exit ;
46574: POP
46575: POP
46576: GO 46891
// end ; if btype in [ b_bunker , b_turret ] then
46578: LD_VAR 0 5
46582: PUSH
46583: LD_INT 32
46585: PUSH
46586: LD_INT 33
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: IN
46593: IFFALSE 46883
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46595: LD_ADDR_EXP 58
46599: PUSH
46600: LD_EXP 58
46604: PPUSH
46605: LD_VAR 0 3
46609: PUSH
46610: LD_EXP 58
46614: PUSH
46615: LD_VAR 0 3
46619: ARRAY
46620: PUSH
46621: LD_INT 1
46623: PLUS
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PPUSH
46629: LD_VAR 0 1
46633: PPUSH
46634: CALL 52460 0 3
46638: ST_TO_ADDR
// if btype = b_bunker then
46639: LD_VAR 0 5
46643: PUSH
46644: LD_INT 32
46646: EQUAL
46647: IFFALSE 46883
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46649: LD_ADDR_EXP 59
46653: PUSH
46654: LD_EXP 59
46658: PPUSH
46659: LD_VAR 0 3
46663: PUSH
46664: LD_EXP 59
46668: PUSH
46669: LD_VAR 0 3
46673: ARRAY
46674: PUSH
46675: LD_INT 1
46677: PLUS
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: PPUSH
46683: LD_VAR 0 1
46687: PPUSH
46688: CALL 52460 0 3
46692: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46693: LD_ADDR_VAR 0 6
46697: PUSH
46698: LD_EXP 50
46702: PUSH
46703: LD_VAR 0 3
46707: ARRAY
46708: PPUSH
46709: LD_INT 25
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 54
46724: PUSH
46725: EMPTY
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: PPUSH
46736: CALL_OW 72
46740: ST_TO_ADDR
// if tmp then
46741: LD_VAR 0 6
46745: IFFALSE 46751
// exit ;
46747: POP
46748: POP
46749: GO 46891
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46751: LD_ADDR_VAR 0 6
46755: PUSH
46756: LD_EXP 50
46760: PUSH
46761: LD_VAR 0 3
46765: ARRAY
46766: PPUSH
46767: LD_INT 2
46769: PUSH
46770: LD_INT 30
46772: PUSH
46773: LD_INT 4
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 30
46782: PUSH
46783: LD_INT 5
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: LIST
46794: PPUSH
46795: CALL_OW 72
46799: ST_TO_ADDR
// if not tmp then
46800: LD_VAR 0 6
46804: NOT
46805: IFFALSE 46811
// exit ;
46807: POP
46808: POP
46809: GO 46891
// for j in tmp do
46811: LD_ADDR_VAR 0 4
46815: PUSH
46816: LD_VAR 0 6
46820: PUSH
46821: FOR_IN
46822: IFFALSE 46881
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46824: LD_ADDR_VAR 0 7
46828: PUSH
46829: LD_VAR 0 4
46833: PPUSH
46834: CALL_OW 313
46838: PPUSH
46839: LD_INT 25
46841: PUSH
46842: LD_INT 1
46844: PUSH
46845: EMPTY
46846: LIST
46847: LIST
46848: PPUSH
46849: CALL_OW 72
46853: ST_TO_ADDR
// if units then
46854: LD_VAR 0 7
46858: IFFALSE 46879
// begin ComExitBuilding ( units [ 1 ] ) ;
46860: LD_VAR 0 7
46864: PUSH
46865: LD_INT 1
46867: ARRAY
46868: PPUSH
46869: CALL_OW 122
// exit ;
46873: POP
46874: POP
46875: POP
46876: POP
46877: GO 46891
// end ; end ;
46879: GO 46821
46881: POP
46882: POP
// end ; end ; exit ;
46883: POP
46884: POP
46885: GO 46891
// end ; end ;
46887: GO 46245
46889: POP
46890: POP
// end ;
46891: LD_VAR 0 2
46895: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46896: LD_INT 0
46898: PPUSH
46899: PPUSH
46900: PPUSH
46901: PPUSH
46902: PPUSH
46903: PPUSH
46904: PPUSH
// if not mc_bases or not skirmish then
46905: LD_EXP 50
46909: NOT
46910: PUSH
46911: LD_EXP 48
46915: NOT
46916: OR
46917: IFFALSE 46921
// exit ;
46919: GO 47152
// btype := GetBType ( building ) ;
46921: LD_ADDR_VAR 0 6
46925: PUSH
46926: LD_VAR 0 1
46930: PPUSH
46931: CALL_OW 266
46935: ST_TO_ADDR
// x := GetX ( building ) ;
46936: LD_ADDR_VAR 0 7
46940: PUSH
46941: LD_VAR 0 1
46945: PPUSH
46946: CALL_OW 250
46950: ST_TO_ADDR
// y := GetY ( building ) ;
46951: LD_ADDR_VAR 0 8
46955: PUSH
46956: LD_VAR 0 1
46960: PPUSH
46961: CALL_OW 251
46965: ST_TO_ADDR
// d := GetDir ( building ) ;
46966: LD_ADDR_VAR 0 9
46970: PUSH
46971: LD_VAR 0 1
46975: PPUSH
46976: CALL_OW 254
46980: ST_TO_ADDR
// for i = 1 to mc_bases do
46981: LD_ADDR_VAR 0 4
46985: PUSH
46986: DOUBLE
46987: LD_INT 1
46989: DEC
46990: ST_TO_ADDR
46991: LD_EXP 50
46995: PUSH
46996: FOR_TO
46997: IFFALSE 47150
// begin if not mc_build_list [ i ] then
46999: LD_EXP 55
47003: PUSH
47004: LD_VAR 0 4
47008: ARRAY
47009: NOT
47010: IFFALSE 47014
// continue ;
47012: GO 46996
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
47014: LD_VAR 0 6
47018: PUSH
47019: LD_VAR 0 7
47023: PUSH
47024: LD_VAR 0 8
47028: PUSH
47029: LD_VAR 0 9
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: PPUSH
47040: LD_EXP 55
47044: PUSH
47045: LD_VAR 0 4
47049: ARRAY
47050: PUSH
47051: LD_INT 1
47053: ARRAY
47054: PPUSH
47055: CALL 58629 0 2
47059: IFFALSE 47148
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
47061: LD_ADDR_EXP 55
47065: PUSH
47066: LD_EXP 55
47070: PPUSH
47071: LD_VAR 0 4
47075: PPUSH
47076: LD_EXP 55
47080: PUSH
47081: LD_VAR 0 4
47085: ARRAY
47086: PPUSH
47087: LD_INT 1
47089: PPUSH
47090: CALL_OW 3
47094: PPUSH
47095: CALL_OW 1
47099: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47100: LD_ADDR_EXP 57
47104: PUSH
47105: LD_EXP 57
47109: PPUSH
47110: LD_VAR 0 4
47114: PUSH
47115: LD_EXP 57
47119: PUSH
47120: LD_VAR 0 4
47124: ARRAY
47125: PUSH
47126: LD_INT 1
47128: PLUS
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: PPUSH
47134: LD_VAR 0 1
47138: PPUSH
47139: CALL 52460 0 3
47143: ST_TO_ADDR
// exit ;
47144: POP
47145: POP
47146: GO 47152
// end ; end ;
47148: GO 46996
47150: POP
47151: POP
// end ;
47152: LD_VAR 0 3
47156: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47157: LD_INT 0
47159: PPUSH
47160: PPUSH
47161: PPUSH
// if not mc_bases or not skirmish then
47162: LD_EXP 50
47166: NOT
47167: PUSH
47168: LD_EXP 48
47172: NOT
47173: OR
47174: IFFALSE 47178
// exit ;
47176: GO 47368
// for i = 1 to mc_bases do
47178: LD_ADDR_VAR 0 4
47182: PUSH
47183: DOUBLE
47184: LD_INT 1
47186: DEC
47187: ST_TO_ADDR
47188: LD_EXP 50
47192: PUSH
47193: FOR_TO
47194: IFFALSE 47281
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47196: LD_VAR 0 1
47200: PUSH
47201: LD_EXP 58
47205: PUSH
47206: LD_VAR 0 4
47210: ARRAY
47211: IN
47212: PUSH
47213: LD_VAR 0 1
47217: PUSH
47218: LD_EXP 59
47222: PUSH
47223: LD_VAR 0 4
47227: ARRAY
47228: IN
47229: NOT
47230: AND
47231: IFFALSE 47279
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47233: LD_ADDR_EXP 59
47237: PUSH
47238: LD_EXP 59
47242: PPUSH
47243: LD_VAR 0 4
47247: PUSH
47248: LD_EXP 59
47252: PUSH
47253: LD_VAR 0 4
47257: ARRAY
47258: PUSH
47259: LD_INT 1
47261: PLUS
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PPUSH
47267: LD_VAR 0 1
47271: PPUSH
47272: CALL 52460 0 3
47276: ST_TO_ADDR
// break ;
47277: GO 47281
// end ; end ;
47279: GO 47193
47281: POP
47282: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47283: LD_VAR 0 1
47287: PPUSH
47288: CALL_OW 257
47292: PUSH
47293: LD_EXP 76
47297: IN
47298: PUSH
47299: LD_VAR 0 1
47303: PPUSH
47304: CALL_OW 266
47308: PUSH
47309: LD_INT 5
47311: EQUAL
47312: AND
47313: PUSH
47314: LD_VAR 0 2
47318: PPUSH
47319: CALL_OW 110
47323: PUSH
47324: LD_INT 18
47326: NONEQUAL
47327: AND
47328: IFFALSE 47368
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47330: LD_VAR 0 2
47334: PPUSH
47335: CALL_OW 257
47339: PUSH
47340: LD_INT 5
47342: PUSH
47343: LD_INT 8
47345: PUSH
47346: LD_INT 9
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: LIST
47353: IN
47354: IFFALSE 47368
// SetClass ( unit , 1 ) ;
47356: LD_VAR 0 2
47360: PPUSH
47361: LD_INT 1
47363: PPUSH
47364: CALL_OW 336
// end ;
47368: LD_VAR 0 3
47372: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47373: LD_INT 0
47375: PPUSH
47376: PPUSH
// if not mc_bases or not skirmish then
47377: LD_EXP 50
47381: NOT
47382: PUSH
47383: LD_EXP 48
47387: NOT
47388: OR
47389: IFFALSE 47393
// exit ;
47391: GO 47509
// if GetLives ( abandoned_vehicle ) > 250 then
47393: LD_VAR 0 2
47397: PPUSH
47398: CALL_OW 256
47402: PUSH
47403: LD_INT 250
47405: GREATER
47406: IFFALSE 47410
// exit ;
47408: GO 47509
// for i = 1 to mc_bases do
47410: LD_ADDR_VAR 0 6
47414: PUSH
47415: DOUBLE
47416: LD_INT 1
47418: DEC
47419: ST_TO_ADDR
47420: LD_EXP 50
47424: PUSH
47425: FOR_TO
47426: IFFALSE 47507
// begin if driver in mc_bases [ i ] then
47428: LD_VAR 0 1
47432: PUSH
47433: LD_EXP 50
47437: PUSH
47438: LD_VAR 0 6
47442: ARRAY
47443: IN
47444: IFFALSE 47505
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47446: LD_VAR 0 1
47450: PPUSH
47451: LD_EXP 50
47455: PUSH
47456: LD_VAR 0 6
47460: ARRAY
47461: PPUSH
47462: LD_INT 2
47464: PUSH
47465: LD_INT 30
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: EMPTY
47472: LIST
47473: LIST
47474: PUSH
47475: LD_INT 30
47477: PUSH
47478: LD_INT 1
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: LIST
47489: PPUSH
47490: CALL_OW 72
47494: PUSH
47495: LD_INT 1
47497: ARRAY
47498: PPUSH
47499: CALL 84326 0 2
// break ;
47503: GO 47507
// end ; end ;
47505: GO 47425
47507: POP
47508: POP
// end ; end_of_file
47509: LD_VAR 0 5
47513: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47514: LD_INT 0
47516: PPUSH
47517: PPUSH
// if exist_mode then
47518: LD_VAR 0 2
47522: IFFALSE 47547
// unit := CreateCharacter ( prefix & ident ) else
47524: LD_ADDR_VAR 0 5
47528: PUSH
47529: LD_VAR 0 3
47533: PUSH
47534: LD_VAR 0 1
47538: STR
47539: PPUSH
47540: CALL_OW 34
47544: ST_TO_ADDR
47545: GO 47562
// unit := NewCharacter ( ident ) ;
47547: LD_ADDR_VAR 0 5
47551: PUSH
47552: LD_VAR 0 1
47556: PPUSH
47557: CALL_OW 25
47561: ST_TO_ADDR
// result := unit ;
47562: LD_ADDR_VAR 0 4
47566: PUSH
47567: LD_VAR 0 5
47571: ST_TO_ADDR
// end ;
47572: LD_VAR 0 4
47576: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47577: LD_INT 0
47579: PPUSH
47580: PPUSH
// if not side or not nation then
47581: LD_VAR 0 1
47585: NOT
47586: PUSH
47587: LD_VAR 0 2
47591: NOT
47592: OR
47593: IFFALSE 47597
// exit ;
47595: GO 48361
// case nation of nation_american :
47597: LD_VAR 0 2
47601: PUSH
47602: LD_INT 1
47604: DOUBLE
47605: EQUAL
47606: IFTRUE 47610
47608: GO 47824
47610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47611: LD_ADDR_VAR 0 4
47615: PUSH
47616: LD_INT 35
47618: PUSH
47619: LD_INT 45
47621: PUSH
47622: LD_INT 46
47624: PUSH
47625: LD_INT 47
47627: PUSH
47628: LD_INT 82
47630: PUSH
47631: LD_INT 83
47633: PUSH
47634: LD_INT 84
47636: PUSH
47637: LD_INT 85
47639: PUSH
47640: LD_INT 86
47642: PUSH
47643: LD_INT 1
47645: PUSH
47646: LD_INT 2
47648: PUSH
47649: LD_INT 6
47651: PUSH
47652: LD_INT 15
47654: PUSH
47655: LD_INT 16
47657: PUSH
47658: LD_INT 7
47660: PUSH
47661: LD_INT 12
47663: PUSH
47664: LD_INT 13
47666: PUSH
47667: LD_INT 10
47669: PUSH
47670: LD_INT 14
47672: PUSH
47673: LD_INT 20
47675: PUSH
47676: LD_INT 21
47678: PUSH
47679: LD_INT 22
47681: PUSH
47682: LD_INT 25
47684: PUSH
47685: LD_INT 32
47687: PUSH
47688: LD_INT 27
47690: PUSH
47691: LD_INT 36
47693: PUSH
47694: LD_INT 69
47696: PUSH
47697: LD_INT 39
47699: PUSH
47700: LD_INT 34
47702: PUSH
47703: LD_INT 40
47705: PUSH
47706: LD_INT 48
47708: PUSH
47709: LD_INT 49
47711: PUSH
47712: LD_INT 50
47714: PUSH
47715: LD_INT 51
47717: PUSH
47718: LD_INT 52
47720: PUSH
47721: LD_INT 53
47723: PUSH
47724: LD_INT 54
47726: PUSH
47727: LD_INT 55
47729: PUSH
47730: LD_INT 56
47732: PUSH
47733: LD_INT 57
47735: PUSH
47736: LD_INT 58
47738: PUSH
47739: LD_INT 59
47741: PUSH
47742: LD_INT 60
47744: PUSH
47745: LD_INT 61
47747: PUSH
47748: LD_INT 62
47750: PUSH
47751: LD_INT 80
47753: PUSH
47754: LD_INT 82
47756: PUSH
47757: LD_INT 83
47759: PUSH
47760: LD_INT 84
47762: PUSH
47763: LD_INT 85
47765: PUSH
47766: LD_INT 86
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: ST_TO_ADDR
47822: GO 48285
47824: LD_INT 2
47826: DOUBLE
47827: EQUAL
47828: IFTRUE 47832
47830: GO 48054
47832: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
47833: LD_ADDR_VAR 0 4
47837: PUSH
47838: LD_INT 35
47840: PUSH
47841: LD_INT 45
47843: PUSH
47844: LD_INT 46
47846: PUSH
47847: LD_INT 47
47849: PUSH
47850: LD_INT 82
47852: PUSH
47853: LD_INT 83
47855: PUSH
47856: LD_INT 84
47858: PUSH
47859: LD_INT 85
47861: PUSH
47862: LD_INT 87
47864: PUSH
47865: LD_INT 70
47867: PUSH
47868: LD_INT 1
47870: PUSH
47871: LD_INT 11
47873: PUSH
47874: LD_INT 3
47876: PUSH
47877: LD_INT 4
47879: PUSH
47880: LD_INT 5
47882: PUSH
47883: LD_INT 6
47885: PUSH
47886: LD_INT 15
47888: PUSH
47889: LD_INT 18
47891: PUSH
47892: LD_INT 7
47894: PUSH
47895: LD_INT 17
47897: PUSH
47898: LD_INT 8
47900: PUSH
47901: LD_INT 20
47903: PUSH
47904: LD_INT 21
47906: PUSH
47907: LD_INT 22
47909: PUSH
47910: LD_INT 72
47912: PUSH
47913: LD_INT 26
47915: PUSH
47916: LD_INT 69
47918: PUSH
47919: LD_INT 39
47921: PUSH
47922: LD_INT 40
47924: PUSH
47925: LD_INT 41
47927: PUSH
47928: LD_INT 42
47930: PUSH
47931: LD_INT 43
47933: PUSH
47934: LD_INT 48
47936: PUSH
47937: LD_INT 49
47939: PUSH
47940: LD_INT 50
47942: PUSH
47943: LD_INT 51
47945: PUSH
47946: LD_INT 52
47948: PUSH
47949: LD_INT 53
47951: PUSH
47952: LD_INT 54
47954: PUSH
47955: LD_INT 55
47957: PUSH
47958: LD_INT 56
47960: PUSH
47961: LD_INT 60
47963: PUSH
47964: LD_INT 61
47966: PUSH
47967: LD_INT 62
47969: PUSH
47970: LD_INT 66
47972: PUSH
47973: LD_INT 67
47975: PUSH
47976: LD_INT 68
47978: PUSH
47979: LD_INT 81
47981: PUSH
47982: LD_INT 82
47984: PUSH
47985: LD_INT 83
47987: PUSH
47988: LD_INT 84
47990: PUSH
47991: LD_INT 85
47993: PUSH
47994: LD_INT 87
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: ST_TO_ADDR
48052: GO 48285
48054: LD_INT 3
48056: DOUBLE
48057: EQUAL
48058: IFTRUE 48062
48060: GO 48284
48062: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48063: LD_ADDR_VAR 0 4
48067: PUSH
48068: LD_INT 46
48070: PUSH
48071: LD_INT 47
48073: PUSH
48074: LD_INT 1
48076: PUSH
48077: LD_INT 2
48079: PUSH
48080: LD_INT 82
48082: PUSH
48083: LD_INT 83
48085: PUSH
48086: LD_INT 84
48088: PUSH
48089: LD_INT 85
48091: PUSH
48092: LD_INT 86
48094: PUSH
48095: LD_INT 11
48097: PUSH
48098: LD_INT 9
48100: PUSH
48101: LD_INT 20
48103: PUSH
48104: LD_INT 19
48106: PUSH
48107: LD_INT 21
48109: PUSH
48110: LD_INT 24
48112: PUSH
48113: LD_INT 22
48115: PUSH
48116: LD_INT 25
48118: PUSH
48119: LD_INT 28
48121: PUSH
48122: LD_INT 29
48124: PUSH
48125: LD_INT 30
48127: PUSH
48128: LD_INT 31
48130: PUSH
48131: LD_INT 37
48133: PUSH
48134: LD_INT 38
48136: PUSH
48137: LD_INT 32
48139: PUSH
48140: LD_INT 27
48142: PUSH
48143: LD_INT 33
48145: PUSH
48146: LD_INT 69
48148: PUSH
48149: LD_INT 39
48151: PUSH
48152: LD_INT 34
48154: PUSH
48155: LD_INT 40
48157: PUSH
48158: LD_INT 71
48160: PUSH
48161: LD_INT 23
48163: PUSH
48164: LD_INT 44
48166: PUSH
48167: LD_INT 48
48169: PUSH
48170: LD_INT 49
48172: PUSH
48173: LD_INT 50
48175: PUSH
48176: LD_INT 51
48178: PUSH
48179: LD_INT 52
48181: PUSH
48182: LD_INT 53
48184: PUSH
48185: LD_INT 54
48187: PUSH
48188: LD_INT 55
48190: PUSH
48191: LD_INT 56
48193: PUSH
48194: LD_INT 57
48196: PUSH
48197: LD_INT 58
48199: PUSH
48200: LD_INT 59
48202: PUSH
48203: LD_INT 63
48205: PUSH
48206: LD_INT 64
48208: PUSH
48209: LD_INT 65
48211: PUSH
48212: LD_INT 82
48214: PUSH
48215: LD_INT 83
48217: PUSH
48218: LD_INT 84
48220: PUSH
48221: LD_INT 85
48223: PUSH
48224: LD_INT 86
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: ST_TO_ADDR
48282: GO 48285
48284: POP
// if state > - 1 and state < 3 then
48285: LD_VAR 0 3
48289: PUSH
48290: LD_INT 1
48292: NEG
48293: GREATER
48294: PUSH
48295: LD_VAR 0 3
48299: PUSH
48300: LD_INT 3
48302: LESS
48303: AND
48304: IFFALSE 48361
// for i in result do
48306: LD_ADDR_VAR 0 5
48310: PUSH
48311: LD_VAR 0 4
48315: PUSH
48316: FOR_IN
48317: IFFALSE 48359
// if GetTech ( i , side ) <> state then
48319: LD_VAR 0 5
48323: PPUSH
48324: LD_VAR 0 1
48328: PPUSH
48329: CALL_OW 321
48333: PUSH
48334: LD_VAR 0 3
48338: NONEQUAL
48339: IFFALSE 48357
// result := result diff i ;
48341: LD_ADDR_VAR 0 4
48345: PUSH
48346: LD_VAR 0 4
48350: PUSH
48351: LD_VAR 0 5
48355: DIFF
48356: ST_TO_ADDR
48357: GO 48316
48359: POP
48360: POP
// end ;
48361: LD_VAR 0 4
48365: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48366: LD_INT 0
48368: PPUSH
48369: PPUSH
48370: PPUSH
// result := true ;
48371: LD_ADDR_VAR 0 3
48375: PUSH
48376: LD_INT 1
48378: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48379: LD_ADDR_VAR 0 5
48383: PUSH
48384: LD_VAR 0 2
48388: PPUSH
48389: CALL_OW 480
48393: ST_TO_ADDR
// if not tmp then
48394: LD_VAR 0 5
48398: NOT
48399: IFFALSE 48403
// exit ;
48401: GO 48452
// for i in tmp do
48403: LD_ADDR_VAR 0 4
48407: PUSH
48408: LD_VAR 0 5
48412: PUSH
48413: FOR_IN
48414: IFFALSE 48450
// if GetTech ( i , side ) <> state_researched then
48416: LD_VAR 0 4
48420: PPUSH
48421: LD_VAR 0 1
48425: PPUSH
48426: CALL_OW 321
48430: PUSH
48431: LD_INT 2
48433: NONEQUAL
48434: IFFALSE 48448
// begin result := false ;
48436: LD_ADDR_VAR 0 3
48440: PUSH
48441: LD_INT 0
48443: ST_TO_ADDR
// exit ;
48444: POP
48445: POP
48446: GO 48452
// end ;
48448: GO 48413
48450: POP
48451: POP
// end ;
48452: LD_VAR 0 3
48456: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48457: LD_INT 0
48459: PPUSH
48460: PPUSH
48461: PPUSH
48462: PPUSH
48463: PPUSH
48464: PPUSH
48465: PPUSH
48466: PPUSH
48467: PPUSH
48468: PPUSH
48469: PPUSH
48470: PPUSH
48471: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48472: LD_VAR 0 1
48476: NOT
48477: PUSH
48478: LD_VAR 0 1
48482: PPUSH
48483: CALL_OW 257
48487: PUSH
48488: LD_INT 9
48490: NONEQUAL
48491: OR
48492: IFFALSE 48496
// exit ;
48494: GO 49069
// side := GetSide ( unit ) ;
48496: LD_ADDR_VAR 0 9
48500: PUSH
48501: LD_VAR 0 1
48505: PPUSH
48506: CALL_OW 255
48510: ST_TO_ADDR
// tech_space := tech_spacanom ;
48511: LD_ADDR_VAR 0 12
48515: PUSH
48516: LD_INT 29
48518: ST_TO_ADDR
// tech_time := tech_taurad ;
48519: LD_ADDR_VAR 0 13
48523: PUSH
48524: LD_INT 28
48526: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48527: LD_ADDR_VAR 0 11
48531: PUSH
48532: LD_VAR 0 1
48536: PPUSH
48537: CALL_OW 310
48541: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48542: LD_VAR 0 11
48546: PPUSH
48547: CALL_OW 247
48551: PUSH
48552: LD_INT 2
48554: EQUAL
48555: IFFALSE 48559
// exit ;
48557: GO 49069
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48559: LD_ADDR_VAR 0 8
48563: PUSH
48564: LD_INT 81
48566: PUSH
48567: LD_VAR 0 9
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PUSH
48576: LD_INT 3
48578: PUSH
48579: LD_INT 21
48581: PUSH
48582: LD_INT 3
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: PUSH
48589: EMPTY
48590: LIST
48591: LIST
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PPUSH
48597: CALL_OW 69
48601: ST_TO_ADDR
// if not tmp then
48602: LD_VAR 0 8
48606: NOT
48607: IFFALSE 48611
// exit ;
48609: GO 49069
// if in_unit then
48611: LD_VAR 0 11
48615: IFFALSE 48639
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48617: LD_ADDR_VAR 0 10
48621: PUSH
48622: LD_VAR 0 8
48626: PPUSH
48627: LD_VAR 0 11
48631: PPUSH
48632: CALL_OW 74
48636: ST_TO_ADDR
48637: GO 48659
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48639: LD_ADDR_VAR 0 10
48643: PUSH
48644: LD_VAR 0 8
48648: PPUSH
48649: LD_VAR 0 1
48653: PPUSH
48654: CALL_OW 74
48658: ST_TO_ADDR
// if not enemy then
48659: LD_VAR 0 10
48663: NOT
48664: IFFALSE 48668
// exit ;
48666: GO 49069
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48668: LD_VAR 0 11
48672: PUSH
48673: LD_VAR 0 11
48677: PPUSH
48678: LD_VAR 0 10
48682: PPUSH
48683: CALL_OW 296
48687: PUSH
48688: LD_INT 13
48690: GREATER
48691: AND
48692: PUSH
48693: LD_VAR 0 1
48697: PPUSH
48698: LD_VAR 0 10
48702: PPUSH
48703: CALL_OW 296
48707: PUSH
48708: LD_INT 12
48710: GREATER
48711: OR
48712: IFFALSE 48716
// exit ;
48714: GO 49069
// missile := [ 1 ] ;
48716: LD_ADDR_VAR 0 14
48720: PUSH
48721: LD_INT 1
48723: PUSH
48724: EMPTY
48725: LIST
48726: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48727: LD_VAR 0 9
48731: PPUSH
48732: LD_VAR 0 12
48736: PPUSH
48737: CALL_OW 325
48741: IFFALSE 48770
// missile := Insert ( missile , missile + 1 , 2 ) ;
48743: LD_ADDR_VAR 0 14
48747: PUSH
48748: LD_VAR 0 14
48752: PPUSH
48753: LD_VAR 0 14
48757: PUSH
48758: LD_INT 1
48760: PLUS
48761: PPUSH
48762: LD_INT 2
48764: PPUSH
48765: CALL_OW 2
48769: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48770: LD_VAR 0 9
48774: PPUSH
48775: LD_VAR 0 13
48779: PPUSH
48780: CALL_OW 325
48784: PUSH
48785: LD_VAR 0 10
48789: PPUSH
48790: CALL_OW 255
48794: PPUSH
48795: LD_VAR 0 13
48799: PPUSH
48800: CALL_OW 325
48804: NOT
48805: AND
48806: IFFALSE 48835
// missile := Insert ( missile , missile + 1 , 3 ) ;
48808: LD_ADDR_VAR 0 14
48812: PUSH
48813: LD_VAR 0 14
48817: PPUSH
48818: LD_VAR 0 14
48822: PUSH
48823: LD_INT 1
48825: PLUS
48826: PPUSH
48827: LD_INT 3
48829: PPUSH
48830: CALL_OW 2
48834: ST_TO_ADDR
// if missile < 2 then
48835: LD_VAR 0 14
48839: PUSH
48840: LD_INT 2
48842: LESS
48843: IFFALSE 48847
// exit ;
48845: GO 49069
// x := GetX ( enemy ) ;
48847: LD_ADDR_VAR 0 4
48851: PUSH
48852: LD_VAR 0 10
48856: PPUSH
48857: CALL_OW 250
48861: ST_TO_ADDR
// y := GetY ( enemy ) ;
48862: LD_ADDR_VAR 0 5
48866: PUSH
48867: LD_VAR 0 10
48871: PPUSH
48872: CALL_OW 251
48876: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48877: LD_ADDR_VAR 0 6
48881: PUSH
48882: LD_VAR 0 4
48886: PUSH
48887: LD_INT 1
48889: NEG
48890: PPUSH
48891: LD_INT 1
48893: PPUSH
48894: CALL_OW 12
48898: PLUS
48899: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48900: LD_ADDR_VAR 0 7
48904: PUSH
48905: LD_VAR 0 5
48909: PUSH
48910: LD_INT 1
48912: NEG
48913: PPUSH
48914: LD_INT 1
48916: PPUSH
48917: CALL_OW 12
48921: PLUS
48922: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48923: LD_VAR 0 6
48927: PPUSH
48928: LD_VAR 0 7
48932: PPUSH
48933: CALL_OW 488
48937: NOT
48938: IFFALSE 48960
// begin _x := x ;
48940: LD_ADDR_VAR 0 6
48944: PUSH
48945: LD_VAR 0 4
48949: ST_TO_ADDR
// _y := y ;
48950: LD_ADDR_VAR 0 7
48954: PUSH
48955: LD_VAR 0 5
48959: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48960: LD_ADDR_VAR 0 3
48964: PUSH
48965: LD_INT 1
48967: PPUSH
48968: LD_VAR 0 14
48972: PPUSH
48973: CALL_OW 12
48977: ST_TO_ADDR
// case i of 1 :
48978: LD_VAR 0 3
48982: PUSH
48983: LD_INT 1
48985: DOUBLE
48986: EQUAL
48987: IFTRUE 48991
48989: GO 49008
48991: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48992: LD_VAR 0 1
48996: PPUSH
48997: LD_VAR 0 10
49001: PPUSH
49002: CALL_OW 115
49006: GO 49069
49008: LD_INT 2
49010: DOUBLE
49011: EQUAL
49012: IFTRUE 49016
49014: GO 49038
49016: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49017: LD_VAR 0 1
49021: PPUSH
49022: LD_VAR 0 6
49026: PPUSH
49027: LD_VAR 0 7
49031: PPUSH
49032: CALL_OW 153
49036: GO 49069
49038: LD_INT 3
49040: DOUBLE
49041: EQUAL
49042: IFTRUE 49046
49044: GO 49068
49046: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49047: LD_VAR 0 1
49051: PPUSH
49052: LD_VAR 0 6
49056: PPUSH
49057: LD_VAR 0 7
49061: PPUSH
49062: CALL_OW 154
49066: GO 49069
49068: POP
// end ;
49069: LD_VAR 0 2
49073: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49074: LD_INT 0
49076: PPUSH
49077: PPUSH
49078: PPUSH
49079: PPUSH
49080: PPUSH
49081: PPUSH
// if not unit or not building then
49082: LD_VAR 0 1
49086: NOT
49087: PUSH
49088: LD_VAR 0 2
49092: NOT
49093: OR
49094: IFFALSE 49098
// exit ;
49096: GO 49256
// x := GetX ( building ) ;
49098: LD_ADDR_VAR 0 5
49102: PUSH
49103: LD_VAR 0 2
49107: PPUSH
49108: CALL_OW 250
49112: ST_TO_ADDR
// y := GetY ( building ) ;
49113: LD_ADDR_VAR 0 6
49117: PUSH
49118: LD_VAR 0 2
49122: PPUSH
49123: CALL_OW 251
49127: ST_TO_ADDR
// for i = 0 to 5 do
49128: LD_ADDR_VAR 0 4
49132: PUSH
49133: DOUBLE
49134: LD_INT 0
49136: DEC
49137: ST_TO_ADDR
49138: LD_INT 5
49140: PUSH
49141: FOR_TO
49142: IFFALSE 49254
// begin _x := ShiftX ( x , i , 3 ) ;
49144: LD_ADDR_VAR 0 7
49148: PUSH
49149: LD_VAR 0 5
49153: PPUSH
49154: LD_VAR 0 4
49158: PPUSH
49159: LD_INT 3
49161: PPUSH
49162: CALL_OW 272
49166: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49167: LD_ADDR_VAR 0 8
49171: PUSH
49172: LD_VAR 0 6
49176: PPUSH
49177: LD_VAR 0 4
49181: PPUSH
49182: LD_INT 3
49184: PPUSH
49185: CALL_OW 273
49189: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49190: LD_VAR 0 7
49194: PPUSH
49195: LD_VAR 0 8
49199: PPUSH
49200: CALL_OW 488
49204: NOT
49205: IFFALSE 49209
// continue ;
49207: GO 49141
// if HexInfo ( _x , _y ) = 0 then
49209: LD_VAR 0 7
49213: PPUSH
49214: LD_VAR 0 8
49218: PPUSH
49219: CALL_OW 428
49223: PUSH
49224: LD_INT 0
49226: EQUAL
49227: IFFALSE 49252
// begin ComMoveXY ( unit , _x , _y ) ;
49229: LD_VAR 0 1
49233: PPUSH
49234: LD_VAR 0 7
49238: PPUSH
49239: LD_VAR 0 8
49243: PPUSH
49244: CALL_OW 111
// exit ;
49248: POP
49249: POP
49250: GO 49256
// end ; end ;
49252: GO 49141
49254: POP
49255: POP
// end ;
49256: LD_VAR 0 3
49260: RET
// export function ScanBase ( side , base_area ) ; begin
49261: LD_INT 0
49263: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49264: LD_ADDR_VAR 0 3
49268: PUSH
49269: LD_VAR 0 2
49273: PPUSH
49274: LD_INT 81
49276: PUSH
49277: LD_VAR 0 1
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PPUSH
49286: CALL_OW 70
49290: ST_TO_ADDR
// end ;
49291: LD_VAR 0 3
49295: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49296: LD_INT 0
49298: PPUSH
49299: PPUSH
49300: PPUSH
49301: PPUSH
// result := false ;
49302: LD_ADDR_VAR 0 2
49306: PUSH
49307: LD_INT 0
49309: ST_TO_ADDR
// side := GetSide ( unit ) ;
49310: LD_ADDR_VAR 0 3
49314: PUSH
49315: LD_VAR 0 1
49319: PPUSH
49320: CALL_OW 255
49324: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49325: LD_ADDR_VAR 0 4
49329: PUSH
49330: LD_VAR 0 1
49334: PPUSH
49335: CALL_OW 248
49339: ST_TO_ADDR
// case nat of 1 :
49340: LD_VAR 0 4
49344: PUSH
49345: LD_INT 1
49347: DOUBLE
49348: EQUAL
49349: IFTRUE 49353
49351: GO 49364
49353: POP
// tech := tech_lassight ; 2 :
49354: LD_ADDR_VAR 0 5
49358: PUSH
49359: LD_INT 12
49361: ST_TO_ADDR
49362: GO 49403
49364: LD_INT 2
49366: DOUBLE
49367: EQUAL
49368: IFTRUE 49372
49370: GO 49383
49372: POP
// tech := tech_mortar ; 3 :
49373: LD_ADDR_VAR 0 5
49377: PUSH
49378: LD_INT 41
49380: ST_TO_ADDR
49381: GO 49403
49383: LD_INT 3
49385: DOUBLE
49386: EQUAL
49387: IFTRUE 49391
49389: GO 49402
49391: POP
// tech := tech_bazooka ; end ;
49392: LD_ADDR_VAR 0 5
49396: PUSH
49397: LD_INT 44
49399: ST_TO_ADDR
49400: GO 49403
49402: POP
// if Researched ( side , tech ) then
49403: LD_VAR 0 3
49407: PPUSH
49408: LD_VAR 0 5
49412: PPUSH
49413: CALL_OW 325
49417: IFFALSE 49444
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49419: LD_ADDR_VAR 0 2
49423: PUSH
49424: LD_INT 5
49426: PUSH
49427: LD_INT 8
49429: PUSH
49430: LD_INT 9
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: LIST
49437: PUSH
49438: LD_VAR 0 4
49442: ARRAY
49443: ST_TO_ADDR
// end ;
49444: LD_VAR 0 2
49448: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49449: LD_INT 0
49451: PPUSH
49452: PPUSH
49453: PPUSH
// if not mines then
49454: LD_VAR 0 2
49458: NOT
49459: IFFALSE 49463
// exit ;
49461: GO 49607
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49463: LD_ADDR_VAR 0 5
49467: PUSH
49468: LD_INT 81
49470: PUSH
49471: LD_VAR 0 1
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PUSH
49480: LD_INT 3
49482: PUSH
49483: LD_INT 21
49485: PUSH
49486: LD_INT 3
49488: PUSH
49489: EMPTY
49490: LIST
49491: LIST
49492: PUSH
49493: EMPTY
49494: LIST
49495: LIST
49496: PUSH
49497: EMPTY
49498: LIST
49499: LIST
49500: PPUSH
49501: CALL_OW 69
49505: ST_TO_ADDR
// for i in mines do
49506: LD_ADDR_VAR 0 4
49510: PUSH
49511: LD_VAR 0 2
49515: PUSH
49516: FOR_IN
49517: IFFALSE 49605
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49519: LD_VAR 0 4
49523: PUSH
49524: LD_INT 1
49526: ARRAY
49527: PPUSH
49528: LD_VAR 0 4
49532: PUSH
49533: LD_INT 2
49535: ARRAY
49536: PPUSH
49537: CALL_OW 458
49541: NOT
49542: IFFALSE 49546
// continue ;
49544: GO 49516
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49546: LD_VAR 0 4
49550: PUSH
49551: LD_INT 1
49553: ARRAY
49554: PPUSH
49555: LD_VAR 0 4
49559: PUSH
49560: LD_INT 2
49562: ARRAY
49563: PPUSH
49564: CALL_OW 428
49568: PUSH
49569: LD_VAR 0 5
49573: IN
49574: IFFALSE 49603
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49576: LD_VAR 0 4
49580: PUSH
49581: LD_INT 1
49583: ARRAY
49584: PPUSH
49585: LD_VAR 0 4
49589: PUSH
49590: LD_INT 2
49592: ARRAY
49593: PPUSH
49594: LD_VAR 0 1
49598: PPUSH
49599: CALL_OW 456
// end ;
49603: GO 49516
49605: POP
49606: POP
// end ;
49607: LD_VAR 0 3
49611: RET
// export function Count ( array ) ; var i ; begin
49612: LD_INT 0
49614: PPUSH
49615: PPUSH
// result := 0 ;
49616: LD_ADDR_VAR 0 2
49620: PUSH
49621: LD_INT 0
49623: ST_TO_ADDR
// for i in array do
49624: LD_ADDR_VAR 0 3
49628: PUSH
49629: LD_VAR 0 1
49633: PUSH
49634: FOR_IN
49635: IFFALSE 49659
// if i then
49637: LD_VAR 0 3
49641: IFFALSE 49657
// result := result + 1 ;
49643: LD_ADDR_VAR 0 2
49647: PUSH
49648: LD_VAR 0 2
49652: PUSH
49653: LD_INT 1
49655: PLUS
49656: ST_TO_ADDR
49657: GO 49634
49659: POP
49660: POP
// end ;
49661: LD_VAR 0 2
49665: RET
// export function IsEmpty ( building ) ; begin
49666: LD_INT 0
49668: PPUSH
// if not building then
49669: LD_VAR 0 1
49673: NOT
49674: IFFALSE 49678
// exit ;
49676: GO 49721
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
49678: LD_ADDR_VAR 0 2
49682: PUSH
49683: LD_VAR 0 1
49687: PUSH
49688: LD_INT 22
49690: PUSH
49691: LD_VAR 0 1
49695: PPUSH
49696: CALL_OW 255
49700: PUSH
49701: EMPTY
49702: LIST
49703: LIST
49704: PUSH
49705: LD_INT 58
49707: PUSH
49708: EMPTY
49709: LIST
49710: PUSH
49711: EMPTY
49712: LIST
49713: LIST
49714: PPUSH
49715: CALL_OW 69
49719: IN
49720: ST_TO_ADDR
// end ;
49721: LD_VAR 0 2
49725: RET
// export function IsNotFull ( building ) ; begin
49726: LD_INT 0
49728: PPUSH
// if not building then
49729: LD_VAR 0 1
49733: NOT
49734: IFFALSE 49738
// exit ;
49736: GO 49757
// result := UnitsInside ( building ) < 6 ;
49738: LD_ADDR_VAR 0 2
49742: PUSH
49743: LD_VAR 0 1
49747: PPUSH
49748: CALL_OW 313
49752: PUSH
49753: LD_INT 6
49755: LESS
49756: ST_TO_ADDR
// end ;
49757: LD_VAR 0 2
49761: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
49762: LD_INT 0
49764: PPUSH
49765: PPUSH
49766: PPUSH
49767: PPUSH
// tmp := [ ] ;
49768: LD_ADDR_VAR 0 3
49772: PUSH
49773: EMPTY
49774: ST_TO_ADDR
// list := [ ] ;
49775: LD_ADDR_VAR 0 5
49779: PUSH
49780: EMPTY
49781: ST_TO_ADDR
// for i = 16 to 25 do
49782: LD_ADDR_VAR 0 4
49786: PUSH
49787: DOUBLE
49788: LD_INT 16
49790: DEC
49791: ST_TO_ADDR
49792: LD_INT 25
49794: PUSH
49795: FOR_TO
49796: IFFALSE 49869
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
49798: LD_ADDR_VAR 0 3
49802: PUSH
49803: LD_VAR 0 3
49807: PUSH
49808: LD_INT 22
49810: PUSH
49811: LD_VAR 0 1
49815: PPUSH
49816: CALL_OW 255
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 91
49827: PUSH
49828: LD_VAR 0 1
49832: PUSH
49833: LD_INT 6
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: LIST
49840: PUSH
49841: LD_INT 30
49843: PUSH
49844: LD_VAR 0 4
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: EMPTY
49854: LIST
49855: LIST
49856: LIST
49857: PUSH
49858: EMPTY
49859: LIST
49860: PPUSH
49861: CALL_OW 69
49865: ADD
49866: ST_TO_ADDR
49867: GO 49795
49869: POP
49870: POP
// for i = 1 to tmp do
49871: LD_ADDR_VAR 0 4
49875: PUSH
49876: DOUBLE
49877: LD_INT 1
49879: DEC
49880: ST_TO_ADDR
49881: LD_VAR 0 3
49885: PUSH
49886: FOR_TO
49887: IFFALSE 49975
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
49889: LD_ADDR_VAR 0 5
49893: PUSH
49894: LD_VAR 0 5
49898: PUSH
49899: LD_VAR 0 3
49903: PUSH
49904: LD_VAR 0 4
49908: ARRAY
49909: PPUSH
49910: CALL_OW 266
49914: PUSH
49915: LD_VAR 0 3
49919: PUSH
49920: LD_VAR 0 4
49924: ARRAY
49925: PPUSH
49926: CALL_OW 250
49930: PUSH
49931: LD_VAR 0 3
49935: PUSH
49936: LD_VAR 0 4
49940: ARRAY
49941: PPUSH
49942: CALL_OW 251
49946: PUSH
49947: LD_VAR 0 3
49951: PUSH
49952: LD_VAR 0 4
49956: ARRAY
49957: PPUSH
49958: CALL_OW 254
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: LIST
49967: LIST
49968: PUSH
49969: EMPTY
49970: LIST
49971: ADD
49972: ST_TO_ADDR
49973: GO 49886
49975: POP
49976: POP
// result := list ;
49977: LD_ADDR_VAR 0 2
49981: PUSH
49982: LD_VAR 0 5
49986: ST_TO_ADDR
// end ;
49987: LD_VAR 0 2
49991: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
49992: LD_INT 0
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
49998: PPUSH
49999: PPUSH
50000: PPUSH
// if not factory then
50001: LD_VAR 0 1
50005: NOT
50006: IFFALSE 50010
// exit ;
50008: GO 50603
// if control = control_apeman then
50010: LD_VAR 0 4
50014: PUSH
50015: LD_INT 5
50017: EQUAL
50018: IFFALSE 50127
// begin tmp := UnitsInside ( factory ) ;
50020: LD_ADDR_VAR 0 8
50024: PUSH
50025: LD_VAR 0 1
50029: PPUSH
50030: CALL_OW 313
50034: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50035: LD_VAR 0 8
50039: PPUSH
50040: LD_INT 25
50042: PUSH
50043: LD_INT 12
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: PPUSH
50050: CALL_OW 72
50054: NOT
50055: IFFALSE 50065
// control := control_manual ;
50057: LD_ADDR_VAR 0 4
50061: PUSH
50062: LD_INT 1
50064: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50065: LD_ADDR_VAR 0 8
50069: PUSH
50070: LD_VAR 0 1
50074: PPUSH
50075: CALL 49762 0 1
50079: ST_TO_ADDR
// if tmp then
50080: LD_VAR 0 8
50084: IFFALSE 50127
// begin for i in tmp do
50086: LD_ADDR_VAR 0 7
50090: PUSH
50091: LD_VAR 0 8
50095: PUSH
50096: FOR_IN
50097: IFFALSE 50125
// if i [ 1 ] = b_ext_radio then
50099: LD_VAR 0 7
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PUSH
50108: LD_INT 22
50110: EQUAL
50111: IFFALSE 50123
// begin control := control_remote ;
50113: LD_ADDR_VAR 0 4
50117: PUSH
50118: LD_INT 2
50120: ST_TO_ADDR
// break ;
50121: GO 50125
// end ;
50123: GO 50096
50125: POP
50126: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50127: LD_VAR 0 1
50131: PPUSH
50132: LD_VAR 0 2
50136: PPUSH
50137: LD_VAR 0 3
50141: PPUSH
50142: LD_VAR 0 4
50146: PPUSH
50147: LD_VAR 0 5
50151: PPUSH
50152: CALL_OW 448
50156: IFFALSE 50191
// begin result := [ chassis , engine , control , weapon ] ;
50158: LD_ADDR_VAR 0 6
50162: PUSH
50163: LD_VAR 0 2
50167: PUSH
50168: LD_VAR 0 3
50172: PUSH
50173: LD_VAR 0 4
50177: PUSH
50178: LD_VAR 0 5
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: ST_TO_ADDR
// exit ;
50189: GO 50603
// end ; _chassis := AvailableChassisList ( factory ) ;
50191: LD_ADDR_VAR 0 9
50195: PUSH
50196: LD_VAR 0 1
50200: PPUSH
50201: CALL_OW 475
50205: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50206: LD_ADDR_VAR 0 11
50210: PUSH
50211: LD_VAR 0 1
50215: PPUSH
50216: CALL_OW 476
50220: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50221: LD_ADDR_VAR 0 12
50225: PUSH
50226: LD_VAR 0 1
50230: PPUSH
50231: CALL_OW 477
50235: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50236: LD_ADDR_VAR 0 10
50240: PUSH
50241: LD_VAR 0 1
50245: PPUSH
50246: CALL_OW 478
50250: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50251: LD_VAR 0 9
50255: NOT
50256: PUSH
50257: LD_VAR 0 11
50261: NOT
50262: OR
50263: PUSH
50264: LD_VAR 0 12
50268: NOT
50269: OR
50270: PUSH
50271: LD_VAR 0 10
50275: NOT
50276: OR
50277: IFFALSE 50312
// begin result := [ chassis , engine , control , weapon ] ;
50279: LD_ADDR_VAR 0 6
50283: PUSH
50284: LD_VAR 0 2
50288: PUSH
50289: LD_VAR 0 3
50293: PUSH
50294: LD_VAR 0 4
50298: PUSH
50299: LD_VAR 0 5
50303: PUSH
50304: EMPTY
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: ST_TO_ADDR
// exit ;
50310: GO 50603
// end ; if not chassis in _chassis then
50312: LD_VAR 0 2
50316: PUSH
50317: LD_VAR 0 9
50321: IN
50322: NOT
50323: IFFALSE 50349
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50325: LD_ADDR_VAR 0 2
50329: PUSH
50330: LD_VAR 0 9
50334: PUSH
50335: LD_INT 1
50337: PPUSH
50338: LD_VAR 0 9
50342: PPUSH
50343: CALL_OW 12
50347: ARRAY
50348: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50349: LD_VAR 0 2
50353: PPUSH
50354: LD_VAR 0 3
50358: PPUSH
50359: CALL 50608 0 2
50363: NOT
50364: IFFALSE 50423
// repeat engine := _engine [ 1 ] ;
50366: LD_ADDR_VAR 0 3
50370: PUSH
50371: LD_VAR 0 11
50375: PUSH
50376: LD_INT 1
50378: ARRAY
50379: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50380: LD_ADDR_VAR 0 11
50384: PUSH
50385: LD_VAR 0 11
50389: PPUSH
50390: LD_INT 1
50392: PPUSH
50393: CALL_OW 3
50397: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50398: LD_VAR 0 2
50402: PPUSH
50403: LD_VAR 0 3
50407: PPUSH
50408: CALL 50608 0 2
50412: PUSH
50413: LD_VAR 0 11
50417: PUSH
50418: EMPTY
50419: EQUAL
50420: OR
50421: IFFALSE 50366
// if not control in _control then
50423: LD_VAR 0 4
50427: PUSH
50428: LD_VAR 0 12
50432: IN
50433: NOT
50434: IFFALSE 50460
// control := _control [ rand ( 1 , _control ) ] ;
50436: LD_ADDR_VAR 0 4
50440: PUSH
50441: LD_VAR 0 12
50445: PUSH
50446: LD_INT 1
50448: PPUSH
50449: LD_VAR 0 12
50453: PPUSH
50454: CALL_OW 12
50458: ARRAY
50459: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50460: LD_VAR 0 2
50464: PPUSH
50465: LD_VAR 0 5
50469: PPUSH
50470: CALL 50828 0 2
50474: NOT
50475: IFFALSE 50534
// repeat weapon := _weapon [ 1 ] ;
50477: LD_ADDR_VAR 0 5
50481: PUSH
50482: LD_VAR 0 10
50486: PUSH
50487: LD_INT 1
50489: ARRAY
50490: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50491: LD_ADDR_VAR 0 10
50495: PUSH
50496: LD_VAR 0 10
50500: PPUSH
50501: LD_INT 1
50503: PPUSH
50504: CALL_OW 3
50508: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50509: LD_VAR 0 2
50513: PPUSH
50514: LD_VAR 0 5
50518: PPUSH
50519: CALL 50828 0 2
50523: PUSH
50524: LD_VAR 0 10
50528: PUSH
50529: EMPTY
50530: EQUAL
50531: OR
50532: IFFALSE 50477
// result := [ ] ;
50534: LD_ADDR_VAR 0 6
50538: PUSH
50539: EMPTY
50540: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50541: LD_VAR 0 1
50545: PPUSH
50546: LD_VAR 0 2
50550: PPUSH
50551: LD_VAR 0 3
50555: PPUSH
50556: LD_VAR 0 4
50560: PPUSH
50561: LD_VAR 0 5
50565: PPUSH
50566: CALL_OW 448
50570: IFFALSE 50603
// result := [ chassis , engine , control , weapon ] ;
50572: LD_ADDR_VAR 0 6
50576: PUSH
50577: LD_VAR 0 2
50581: PUSH
50582: LD_VAR 0 3
50586: PUSH
50587: LD_VAR 0 4
50591: PUSH
50592: LD_VAR 0 5
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: LIST
50601: LIST
50602: ST_TO_ADDR
// end ;
50603: LD_VAR 0 6
50607: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50608: LD_INT 0
50610: PPUSH
// if not chassis or not engine then
50611: LD_VAR 0 1
50615: NOT
50616: PUSH
50617: LD_VAR 0 2
50621: NOT
50622: OR
50623: IFFALSE 50627
// exit ;
50625: GO 50823
// case engine of engine_solar :
50627: LD_VAR 0 2
50631: PUSH
50632: LD_INT 2
50634: DOUBLE
50635: EQUAL
50636: IFTRUE 50640
50638: GO 50678
50640: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
50641: LD_ADDR_VAR 0 3
50645: PUSH
50646: LD_INT 11
50648: PUSH
50649: LD_INT 12
50651: PUSH
50652: LD_INT 13
50654: PUSH
50655: LD_INT 14
50657: PUSH
50658: LD_INT 1
50660: PUSH
50661: LD_INT 2
50663: PUSH
50664: LD_INT 3
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: LIST
50675: ST_TO_ADDR
50676: GO 50807
50678: LD_INT 1
50680: DOUBLE
50681: EQUAL
50682: IFTRUE 50686
50684: GO 50748
50686: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
50687: LD_ADDR_VAR 0 3
50691: PUSH
50692: LD_INT 11
50694: PUSH
50695: LD_INT 12
50697: PUSH
50698: LD_INT 13
50700: PUSH
50701: LD_INT 14
50703: PUSH
50704: LD_INT 1
50706: PUSH
50707: LD_INT 2
50709: PUSH
50710: LD_INT 3
50712: PUSH
50713: LD_INT 4
50715: PUSH
50716: LD_INT 5
50718: PUSH
50719: LD_INT 21
50721: PUSH
50722: LD_INT 23
50724: PUSH
50725: LD_INT 22
50727: PUSH
50728: LD_INT 24
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: LIST
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: ST_TO_ADDR
50746: GO 50807
50748: LD_INT 3
50750: DOUBLE
50751: EQUAL
50752: IFTRUE 50756
50754: GO 50806
50756: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50757: LD_ADDR_VAR 0 3
50761: PUSH
50762: LD_INT 13
50764: PUSH
50765: LD_INT 14
50767: PUSH
50768: LD_INT 2
50770: PUSH
50771: LD_INT 3
50773: PUSH
50774: LD_INT 4
50776: PUSH
50777: LD_INT 5
50779: PUSH
50780: LD_INT 21
50782: PUSH
50783: LD_INT 22
50785: PUSH
50786: LD_INT 23
50788: PUSH
50789: LD_INT 24
50791: PUSH
50792: EMPTY
50793: LIST
50794: LIST
50795: LIST
50796: LIST
50797: LIST
50798: LIST
50799: LIST
50800: LIST
50801: LIST
50802: LIST
50803: ST_TO_ADDR
50804: GO 50807
50806: POP
// result := ( chassis in result ) ;
50807: LD_ADDR_VAR 0 3
50811: PUSH
50812: LD_VAR 0 1
50816: PUSH
50817: LD_VAR 0 3
50821: IN
50822: ST_TO_ADDR
// end ;
50823: LD_VAR 0 3
50827: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
50828: LD_INT 0
50830: PPUSH
// if not chassis or not weapon then
50831: LD_VAR 0 1
50835: NOT
50836: PUSH
50837: LD_VAR 0 2
50841: NOT
50842: OR
50843: IFFALSE 50847
// exit ;
50845: GO 51873
// case weapon of us_machine_gun :
50847: LD_VAR 0 2
50851: PUSH
50852: LD_INT 2
50854: DOUBLE
50855: EQUAL
50856: IFTRUE 50860
50858: GO 50890
50860: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
50861: LD_ADDR_VAR 0 3
50865: PUSH
50866: LD_INT 1
50868: PUSH
50869: LD_INT 2
50871: PUSH
50872: LD_INT 3
50874: PUSH
50875: LD_INT 4
50877: PUSH
50878: LD_INT 5
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: ST_TO_ADDR
50888: GO 51857
50890: LD_INT 3
50892: DOUBLE
50893: EQUAL
50894: IFTRUE 50898
50896: GO 50928
50898: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
50899: LD_ADDR_VAR 0 3
50903: PUSH
50904: LD_INT 1
50906: PUSH
50907: LD_INT 2
50909: PUSH
50910: LD_INT 3
50912: PUSH
50913: LD_INT 4
50915: PUSH
50916: LD_INT 5
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: ST_TO_ADDR
50926: GO 51857
50928: LD_INT 11
50930: DOUBLE
50931: EQUAL
50932: IFTRUE 50936
50934: GO 50966
50936: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
50937: LD_ADDR_VAR 0 3
50941: PUSH
50942: LD_INT 1
50944: PUSH
50945: LD_INT 2
50947: PUSH
50948: LD_INT 3
50950: PUSH
50951: LD_INT 4
50953: PUSH
50954: LD_INT 5
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: ST_TO_ADDR
50964: GO 51857
50966: LD_INT 4
50968: DOUBLE
50969: EQUAL
50970: IFTRUE 50974
50972: GO 51000
50974: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
50975: LD_ADDR_VAR 0 3
50979: PUSH
50980: LD_INT 2
50982: PUSH
50983: LD_INT 3
50985: PUSH
50986: LD_INT 4
50988: PUSH
50989: LD_INT 5
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: LIST
50996: LIST
50997: ST_TO_ADDR
50998: GO 51857
51000: LD_INT 5
51002: DOUBLE
51003: EQUAL
51004: IFTRUE 51008
51006: GO 51034
51008: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51009: LD_ADDR_VAR 0 3
51013: PUSH
51014: LD_INT 2
51016: PUSH
51017: LD_INT 3
51019: PUSH
51020: LD_INT 4
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: ST_TO_ADDR
51032: GO 51857
51034: LD_INT 9
51036: DOUBLE
51037: EQUAL
51038: IFTRUE 51042
51040: GO 51068
51042: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51043: LD_ADDR_VAR 0 3
51047: PUSH
51048: LD_INT 2
51050: PUSH
51051: LD_INT 3
51053: PUSH
51054: LD_INT 4
51056: PUSH
51057: LD_INT 5
51059: PUSH
51060: EMPTY
51061: LIST
51062: LIST
51063: LIST
51064: LIST
51065: ST_TO_ADDR
51066: GO 51857
51068: LD_INT 7
51070: DOUBLE
51071: EQUAL
51072: IFTRUE 51076
51074: GO 51102
51076: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51077: LD_ADDR_VAR 0 3
51081: PUSH
51082: LD_INT 2
51084: PUSH
51085: LD_INT 3
51087: PUSH
51088: LD_INT 4
51090: PUSH
51091: LD_INT 5
51093: PUSH
51094: EMPTY
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: ST_TO_ADDR
51100: GO 51857
51102: LD_INT 12
51104: DOUBLE
51105: EQUAL
51106: IFTRUE 51110
51108: GO 51136
51110: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51111: LD_ADDR_VAR 0 3
51115: PUSH
51116: LD_INT 2
51118: PUSH
51119: LD_INT 3
51121: PUSH
51122: LD_INT 4
51124: PUSH
51125: LD_INT 5
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: ST_TO_ADDR
51134: GO 51857
51136: LD_INT 13
51138: DOUBLE
51139: EQUAL
51140: IFTRUE 51144
51142: GO 51170
51144: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51145: LD_ADDR_VAR 0 3
51149: PUSH
51150: LD_INT 2
51152: PUSH
51153: LD_INT 3
51155: PUSH
51156: LD_INT 4
51158: PUSH
51159: LD_INT 5
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: ST_TO_ADDR
51168: GO 51857
51170: LD_INT 14
51172: DOUBLE
51173: EQUAL
51174: IFTRUE 51178
51176: GO 51196
51178: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51179: LD_ADDR_VAR 0 3
51183: PUSH
51184: LD_INT 4
51186: PUSH
51187: LD_INT 5
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: ST_TO_ADDR
51194: GO 51857
51196: LD_INT 6
51198: DOUBLE
51199: EQUAL
51200: IFTRUE 51204
51202: GO 51222
51204: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51205: LD_ADDR_VAR 0 3
51209: PUSH
51210: LD_INT 4
51212: PUSH
51213: LD_INT 5
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: ST_TO_ADDR
51220: GO 51857
51222: LD_INT 10
51224: DOUBLE
51225: EQUAL
51226: IFTRUE 51230
51228: GO 51248
51230: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51231: LD_ADDR_VAR 0 3
51235: PUSH
51236: LD_INT 4
51238: PUSH
51239: LD_INT 5
51241: PUSH
51242: EMPTY
51243: LIST
51244: LIST
51245: ST_TO_ADDR
51246: GO 51857
51248: LD_INT 22
51250: DOUBLE
51251: EQUAL
51252: IFTRUE 51256
51254: GO 51282
51256: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51257: LD_ADDR_VAR 0 3
51261: PUSH
51262: LD_INT 11
51264: PUSH
51265: LD_INT 12
51267: PUSH
51268: LD_INT 13
51270: PUSH
51271: LD_INT 14
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: ST_TO_ADDR
51280: GO 51857
51282: LD_INT 23
51284: DOUBLE
51285: EQUAL
51286: IFTRUE 51290
51288: GO 51316
51290: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51291: LD_ADDR_VAR 0 3
51295: PUSH
51296: LD_INT 11
51298: PUSH
51299: LD_INT 12
51301: PUSH
51302: LD_INT 13
51304: PUSH
51305: LD_INT 14
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: LIST
51312: LIST
51313: ST_TO_ADDR
51314: GO 51857
51316: LD_INT 24
51318: DOUBLE
51319: EQUAL
51320: IFTRUE 51324
51322: GO 51350
51324: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51325: LD_ADDR_VAR 0 3
51329: PUSH
51330: LD_INT 11
51332: PUSH
51333: LD_INT 12
51335: PUSH
51336: LD_INT 13
51338: PUSH
51339: LD_INT 14
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: ST_TO_ADDR
51348: GO 51857
51350: LD_INT 30
51352: DOUBLE
51353: EQUAL
51354: IFTRUE 51358
51356: GO 51384
51358: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51359: LD_ADDR_VAR 0 3
51363: PUSH
51364: LD_INT 11
51366: PUSH
51367: LD_INT 12
51369: PUSH
51370: LD_INT 13
51372: PUSH
51373: LD_INT 14
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: ST_TO_ADDR
51382: GO 51857
51384: LD_INT 25
51386: DOUBLE
51387: EQUAL
51388: IFTRUE 51392
51390: GO 51410
51392: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51393: LD_ADDR_VAR 0 3
51397: PUSH
51398: LD_INT 13
51400: PUSH
51401: LD_INT 14
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: ST_TO_ADDR
51408: GO 51857
51410: LD_INT 27
51412: DOUBLE
51413: EQUAL
51414: IFTRUE 51418
51416: GO 51436
51418: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51419: LD_ADDR_VAR 0 3
51423: PUSH
51424: LD_INT 13
51426: PUSH
51427: LD_INT 14
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: ST_TO_ADDR
51434: GO 51857
51436: LD_INT 28
51438: DOUBLE
51439: EQUAL
51440: IFTRUE 51444
51442: GO 51462
51444: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51445: LD_ADDR_VAR 0 3
51449: PUSH
51450: LD_INT 13
51452: PUSH
51453: LD_INT 14
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: ST_TO_ADDR
51460: GO 51857
51462: LD_INT 29
51464: DOUBLE
51465: EQUAL
51466: IFTRUE 51470
51468: GO 51488
51470: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51471: LD_ADDR_VAR 0 3
51475: PUSH
51476: LD_INT 13
51478: PUSH
51479: LD_INT 14
51481: PUSH
51482: EMPTY
51483: LIST
51484: LIST
51485: ST_TO_ADDR
51486: GO 51857
51488: LD_INT 31
51490: DOUBLE
51491: EQUAL
51492: IFTRUE 51496
51494: GO 51514
51496: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51497: LD_ADDR_VAR 0 3
51501: PUSH
51502: LD_INT 13
51504: PUSH
51505: LD_INT 14
51507: PUSH
51508: EMPTY
51509: LIST
51510: LIST
51511: ST_TO_ADDR
51512: GO 51857
51514: LD_INT 26
51516: DOUBLE
51517: EQUAL
51518: IFTRUE 51522
51520: GO 51540
51522: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51523: LD_ADDR_VAR 0 3
51527: PUSH
51528: LD_INT 13
51530: PUSH
51531: LD_INT 14
51533: PUSH
51534: EMPTY
51535: LIST
51536: LIST
51537: ST_TO_ADDR
51538: GO 51857
51540: LD_INT 42
51542: DOUBLE
51543: EQUAL
51544: IFTRUE 51548
51546: GO 51574
51548: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51549: LD_ADDR_VAR 0 3
51553: PUSH
51554: LD_INT 21
51556: PUSH
51557: LD_INT 22
51559: PUSH
51560: LD_INT 23
51562: PUSH
51563: LD_INT 24
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: LIST
51570: LIST
51571: ST_TO_ADDR
51572: GO 51857
51574: LD_INT 43
51576: DOUBLE
51577: EQUAL
51578: IFTRUE 51582
51580: GO 51608
51582: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51583: LD_ADDR_VAR 0 3
51587: PUSH
51588: LD_INT 21
51590: PUSH
51591: LD_INT 22
51593: PUSH
51594: LD_INT 23
51596: PUSH
51597: LD_INT 24
51599: PUSH
51600: EMPTY
51601: LIST
51602: LIST
51603: LIST
51604: LIST
51605: ST_TO_ADDR
51606: GO 51857
51608: LD_INT 44
51610: DOUBLE
51611: EQUAL
51612: IFTRUE 51616
51614: GO 51642
51616: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51617: LD_ADDR_VAR 0 3
51621: PUSH
51622: LD_INT 21
51624: PUSH
51625: LD_INT 22
51627: PUSH
51628: LD_INT 23
51630: PUSH
51631: LD_INT 24
51633: PUSH
51634: EMPTY
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: ST_TO_ADDR
51640: GO 51857
51642: LD_INT 45
51644: DOUBLE
51645: EQUAL
51646: IFTRUE 51650
51648: GO 51676
51650: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
51651: LD_ADDR_VAR 0 3
51655: PUSH
51656: LD_INT 21
51658: PUSH
51659: LD_INT 22
51661: PUSH
51662: LD_INT 23
51664: PUSH
51665: LD_INT 24
51667: PUSH
51668: EMPTY
51669: LIST
51670: LIST
51671: LIST
51672: LIST
51673: ST_TO_ADDR
51674: GO 51857
51676: LD_INT 49
51678: DOUBLE
51679: EQUAL
51680: IFTRUE 51684
51682: GO 51710
51684: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
51685: LD_ADDR_VAR 0 3
51689: PUSH
51690: LD_INT 21
51692: PUSH
51693: LD_INT 22
51695: PUSH
51696: LD_INT 23
51698: PUSH
51699: LD_INT 24
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: LIST
51706: LIST
51707: ST_TO_ADDR
51708: GO 51857
51710: LD_INT 51
51712: DOUBLE
51713: EQUAL
51714: IFTRUE 51718
51716: GO 51744
51718: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
51719: LD_ADDR_VAR 0 3
51723: PUSH
51724: LD_INT 21
51726: PUSH
51727: LD_INT 22
51729: PUSH
51730: LD_INT 23
51732: PUSH
51733: LD_INT 24
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: ST_TO_ADDR
51742: GO 51857
51744: LD_INT 52
51746: DOUBLE
51747: EQUAL
51748: IFTRUE 51752
51750: GO 51778
51752: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
51753: LD_ADDR_VAR 0 3
51757: PUSH
51758: LD_INT 21
51760: PUSH
51761: LD_INT 22
51763: PUSH
51764: LD_INT 23
51766: PUSH
51767: LD_INT 24
51769: PUSH
51770: EMPTY
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: ST_TO_ADDR
51776: GO 51857
51778: LD_INT 53
51780: DOUBLE
51781: EQUAL
51782: IFTRUE 51786
51784: GO 51804
51786: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
51787: LD_ADDR_VAR 0 3
51791: PUSH
51792: LD_INT 23
51794: PUSH
51795: LD_INT 24
51797: PUSH
51798: EMPTY
51799: LIST
51800: LIST
51801: ST_TO_ADDR
51802: GO 51857
51804: LD_INT 46
51806: DOUBLE
51807: EQUAL
51808: IFTRUE 51812
51810: GO 51830
51812: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
51813: LD_ADDR_VAR 0 3
51817: PUSH
51818: LD_INT 23
51820: PUSH
51821: LD_INT 24
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: ST_TO_ADDR
51828: GO 51857
51830: LD_INT 47
51832: DOUBLE
51833: EQUAL
51834: IFTRUE 51838
51836: GO 51856
51838: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51839: LD_ADDR_VAR 0 3
51843: PUSH
51844: LD_INT 23
51846: PUSH
51847: LD_INT 24
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: ST_TO_ADDR
51854: GO 51857
51856: POP
// result := ( chassis in result ) ;
51857: LD_ADDR_VAR 0 3
51861: PUSH
51862: LD_VAR 0 1
51866: PUSH
51867: LD_VAR 0 3
51871: IN
51872: ST_TO_ADDR
// end ;
51873: LD_VAR 0 3
51877: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
51878: LD_INT 0
51880: PPUSH
51881: PPUSH
51882: PPUSH
51883: PPUSH
51884: PPUSH
51885: PPUSH
51886: PPUSH
// result := array ;
51887: LD_ADDR_VAR 0 5
51891: PUSH
51892: LD_VAR 0 1
51896: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
51897: LD_VAR 0 1
51901: NOT
51902: PUSH
51903: LD_VAR 0 2
51907: NOT
51908: OR
51909: PUSH
51910: LD_VAR 0 3
51914: NOT
51915: OR
51916: PUSH
51917: LD_VAR 0 2
51921: PUSH
51922: LD_VAR 0 1
51926: GREATER
51927: OR
51928: PUSH
51929: LD_VAR 0 3
51933: PUSH
51934: LD_VAR 0 1
51938: GREATER
51939: OR
51940: IFFALSE 51944
// exit ;
51942: GO 52240
// if direction then
51944: LD_VAR 0 4
51948: IFFALSE 52012
// begin d := 1 ;
51950: LD_ADDR_VAR 0 9
51954: PUSH
51955: LD_INT 1
51957: ST_TO_ADDR
// if i_from > i_to then
51958: LD_VAR 0 2
51962: PUSH
51963: LD_VAR 0 3
51967: GREATER
51968: IFFALSE 51994
// length := ( array - i_from ) + i_to else
51970: LD_ADDR_VAR 0 11
51974: PUSH
51975: LD_VAR 0 1
51979: PUSH
51980: LD_VAR 0 2
51984: MINUS
51985: PUSH
51986: LD_VAR 0 3
51990: PLUS
51991: ST_TO_ADDR
51992: GO 52010
// length := i_to - i_from ;
51994: LD_ADDR_VAR 0 11
51998: PUSH
51999: LD_VAR 0 3
52003: PUSH
52004: LD_VAR 0 2
52008: MINUS
52009: ST_TO_ADDR
// end else
52010: GO 52073
// begin d := - 1 ;
52012: LD_ADDR_VAR 0 9
52016: PUSH
52017: LD_INT 1
52019: NEG
52020: ST_TO_ADDR
// if i_from > i_to then
52021: LD_VAR 0 2
52025: PUSH
52026: LD_VAR 0 3
52030: GREATER
52031: IFFALSE 52051
// length := i_from - i_to else
52033: LD_ADDR_VAR 0 11
52037: PUSH
52038: LD_VAR 0 2
52042: PUSH
52043: LD_VAR 0 3
52047: MINUS
52048: ST_TO_ADDR
52049: GO 52073
// length := ( array - i_to ) + i_from ;
52051: LD_ADDR_VAR 0 11
52055: PUSH
52056: LD_VAR 0 1
52060: PUSH
52061: LD_VAR 0 3
52065: MINUS
52066: PUSH
52067: LD_VAR 0 2
52071: PLUS
52072: ST_TO_ADDR
// end ; if not length then
52073: LD_VAR 0 11
52077: NOT
52078: IFFALSE 52082
// exit ;
52080: GO 52240
// tmp := array ;
52082: LD_ADDR_VAR 0 10
52086: PUSH
52087: LD_VAR 0 1
52091: ST_TO_ADDR
// for i = 1 to length do
52092: LD_ADDR_VAR 0 6
52096: PUSH
52097: DOUBLE
52098: LD_INT 1
52100: DEC
52101: ST_TO_ADDR
52102: LD_VAR 0 11
52106: PUSH
52107: FOR_TO
52108: IFFALSE 52228
// begin for j = 1 to array do
52110: LD_ADDR_VAR 0 7
52114: PUSH
52115: DOUBLE
52116: LD_INT 1
52118: DEC
52119: ST_TO_ADDR
52120: LD_VAR 0 1
52124: PUSH
52125: FOR_TO
52126: IFFALSE 52214
// begin k := j + d ;
52128: LD_ADDR_VAR 0 8
52132: PUSH
52133: LD_VAR 0 7
52137: PUSH
52138: LD_VAR 0 9
52142: PLUS
52143: ST_TO_ADDR
// if k > array then
52144: LD_VAR 0 8
52148: PUSH
52149: LD_VAR 0 1
52153: GREATER
52154: IFFALSE 52164
// k := 1 ;
52156: LD_ADDR_VAR 0 8
52160: PUSH
52161: LD_INT 1
52163: ST_TO_ADDR
// if not k then
52164: LD_VAR 0 8
52168: NOT
52169: IFFALSE 52181
// k := array ;
52171: LD_ADDR_VAR 0 8
52175: PUSH
52176: LD_VAR 0 1
52180: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52181: LD_ADDR_VAR 0 10
52185: PUSH
52186: LD_VAR 0 10
52190: PPUSH
52191: LD_VAR 0 8
52195: PPUSH
52196: LD_VAR 0 1
52200: PUSH
52201: LD_VAR 0 7
52205: ARRAY
52206: PPUSH
52207: CALL_OW 1
52211: ST_TO_ADDR
// end ;
52212: GO 52125
52214: POP
52215: POP
// array := tmp ;
52216: LD_ADDR_VAR 0 1
52220: PUSH
52221: LD_VAR 0 10
52225: ST_TO_ADDR
// end ;
52226: GO 52107
52228: POP
52229: POP
// result := array ;
52230: LD_ADDR_VAR 0 5
52234: PUSH
52235: LD_VAR 0 1
52239: ST_TO_ADDR
// end ;
52240: LD_VAR 0 5
52244: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52245: LD_INT 0
52247: PPUSH
52248: PPUSH
// result := 0 ;
52249: LD_ADDR_VAR 0 3
52253: PUSH
52254: LD_INT 0
52256: ST_TO_ADDR
// if not array or not value in array then
52257: LD_VAR 0 1
52261: NOT
52262: PUSH
52263: LD_VAR 0 2
52267: PUSH
52268: LD_VAR 0 1
52272: IN
52273: NOT
52274: OR
52275: IFFALSE 52279
// exit ;
52277: GO 52333
// for i = 1 to array do
52279: LD_ADDR_VAR 0 4
52283: PUSH
52284: DOUBLE
52285: LD_INT 1
52287: DEC
52288: ST_TO_ADDR
52289: LD_VAR 0 1
52293: PUSH
52294: FOR_TO
52295: IFFALSE 52331
// if value = array [ i ] then
52297: LD_VAR 0 2
52301: PUSH
52302: LD_VAR 0 1
52306: PUSH
52307: LD_VAR 0 4
52311: ARRAY
52312: EQUAL
52313: IFFALSE 52329
// begin result := i ;
52315: LD_ADDR_VAR 0 3
52319: PUSH
52320: LD_VAR 0 4
52324: ST_TO_ADDR
// exit ;
52325: POP
52326: POP
52327: GO 52333
// end ;
52329: GO 52294
52331: POP
52332: POP
// end ;
52333: LD_VAR 0 3
52337: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52338: LD_INT 0
52340: PPUSH
// vc_chassis := chassis ;
52341: LD_ADDR_OWVAR 37
52345: PUSH
52346: LD_VAR 0 1
52350: ST_TO_ADDR
// vc_engine := engine ;
52351: LD_ADDR_OWVAR 39
52355: PUSH
52356: LD_VAR 0 2
52360: ST_TO_ADDR
// vc_control := control ;
52361: LD_ADDR_OWVAR 38
52365: PUSH
52366: LD_VAR 0 3
52370: ST_TO_ADDR
// vc_weapon := weapon ;
52371: LD_ADDR_OWVAR 40
52375: PUSH
52376: LD_VAR 0 4
52380: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52381: LD_ADDR_OWVAR 41
52385: PUSH
52386: LD_VAR 0 5
52390: ST_TO_ADDR
// end ;
52391: LD_VAR 0 6
52395: RET
// export function WantPlant ( unit ) ; var task ; begin
52396: LD_INT 0
52398: PPUSH
52399: PPUSH
// result := false ;
52400: LD_ADDR_VAR 0 2
52404: PUSH
52405: LD_INT 0
52407: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52408: LD_ADDR_VAR 0 3
52412: PUSH
52413: LD_VAR 0 1
52417: PPUSH
52418: CALL_OW 437
52422: ST_TO_ADDR
// if task then
52423: LD_VAR 0 3
52427: IFFALSE 52455
// if task [ 1 ] [ 1 ] = p then
52429: LD_VAR 0 3
52433: PUSH
52434: LD_INT 1
52436: ARRAY
52437: PUSH
52438: LD_INT 1
52440: ARRAY
52441: PUSH
52442: LD_STRING p
52444: EQUAL
52445: IFFALSE 52455
// result := true ;
52447: LD_ADDR_VAR 0 2
52451: PUSH
52452: LD_INT 1
52454: ST_TO_ADDR
// end ;
52455: LD_VAR 0 2
52459: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52460: LD_INT 0
52462: PPUSH
52463: PPUSH
52464: PPUSH
52465: PPUSH
// if pos < 1 then
52466: LD_VAR 0 2
52470: PUSH
52471: LD_INT 1
52473: LESS
52474: IFFALSE 52478
// exit ;
52476: GO 52781
// if pos = 1 then
52478: LD_VAR 0 2
52482: PUSH
52483: LD_INT 1
52485: EQUAL
52486: IFFALSE 52519
// result := Replace ( arr , pos [ 1 ] , value ) else
52488: LD_ADDR_VAR 0 4
52492: PUSH
52493: LD_VAR 0 1
52497: PPUSH
52498: LD_VAR 0 2
52502: PUSH
52503: LD_INT 1
52505: ARRAY
52506: PPUSH
52507: LD_VAR 0 3
52511: PPUSH
52512: CALL_OW 1
52516: ST_TO_ADDR
52517: GO 52781
// begin tmp := arr ;
52519: LD_ADDR_VAR 0 6
52523: PUSH
52524: LD_VAR 0 1
52528: ST_TO_ADDR
// s_arr := [ tmp ] ;
52529: LD_ADDR_VAR 0 7
52533: PUSH
52534: LD_VAR 0 6
52538: PUSH
52539: EMPTY
52540: LIST
52541: ST_TO_ADDR
// for i = 1 to pos - 1 do
52542: LD_ADDR_VAR 0 5
52546: PUSH
52547: DOUBLE
52548: LD_INT 1
52550: DEC
52551: ST_TO_ADDR
52552: LD_VAR 0 2
52556: PUSH
52557: LD_INT 1
52559: MINUS
52560: PUSH
52561: FOR_TO
52562: IFFALSE 52607
// begin tmp := tmp [ pos [ i ] ] ;
52564: LD_ADDR_VAR 0 6
52568: PUSH
52569: LD_VAR 0 6
52573: PUSH
52574: LD_VAR 0 2
52578: PUSH
52579: LD_VAR 0 5
52583: ARRAY
52584: ARRAY
52585: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52586: LD_ADDR_VAR 0 7
52590: PUSH
52591: LD_VAR 0 7
52595: PUSH
52596: LD_VAR 0 6
52600: PUSH
52601: EMPTY
52602: LIST
52603: ADD
52604: ST_TO_ADDR
// end ;
52605: GO 52561
52607: POP
52608: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52609: LD_ADDR_VAR 0 6
52613: PUSH
52614: LD_VAR 0 6
52618: PPUSH
52619: LD_VAR 0 2
52623: PUSH
52624: LD_VAR 0 2
52628: ARRAY
52629: PPUSH
52630: LD_VAR 0 3
52634: PPUSH
52635: CALL_OW 1
52639: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
52640: LD_ADDR_VAR 0 7
52644: PUSH
52645: LD_VAR 0 7
52649: PPUSH
52650: LD_VAR 0 7
52654: PPUSH
52655: LD_VAR 0 6
52659: PPUSH
52660: CALL_OW 1
52664: ST_TO_ADDR
// for i = s_arr downto 2 do
52665: LD_ADDR_VAR 0 5
52669: PUSH
52670: DOUBLE
52671: LD_VAR 0 7
52675: INC
52676: ST_TO_ADDR
52677: LD_INT 2
52679: PUSH
52680: FOR_DOWNTO
52681: IFFALSE 52765
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
52683: LD_ADDR_VAR 0 6
52687: PUSH
52688: LD_VAR 0 7
52692: PUSH
52693: LD_VAR 0 5
52697: PUSH
52698: LD_INT 1
52700: MINUS
52701: ARRAY
52702: PPUSH
52703: LD_VAR 0 2
52707: PUSH
52708: LD_VAR 0 5
52712: PUSH
52713: LD_INT 1
52715: MINUS
52716: ARRAY
52717: PPUSH
52718: LD_VAR 0 7
52722: PUSH
52723: LD_VAR 0 5
52727: ARRAY
52728: PPUSH
52729: CALL_OW 1
52733: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
52734: LD_ADDR_VAR 0 7
52738: PUSH
52739: LD_VAR 0 7
52743: PPUSH
52744: LD_VAR 0 5
52748: PUSH
52749: LD_INT 1
52751: MINUS
52752: PPUSH
52753: LD_VAR 0 6
52757: PPUSH
52758: CALL_OW 1
52762: ST_TO_ADDR
// end ;
52763: GO 52680
52765: POP
52766: POP
// result := s_arr [ 1 ] ;
52767: LD_ADDR_VAR 0 4
52771: PUSH
52772: LD_VAR 0 7
52776: PUSH
52777: LD_INT 1
52779: ARRAY
52780: ST_TO_ADDR
// end ; end ;
52781: LD_VAR 0 4
52785: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
52786: LD_INT 0
52788: PPUSH
52789: PPUSH
// if not list then
52790: LD_VAR 0 1
52794: NOT
52795: IFFALSE 52799
// exit ;
52797: GO 52890
// i := list [ pos1 ] ;
52799: LD_ADDR_VAR 0 5
52803: PUSH
52804: LD_VAR 0 1
52808: PUSH
52809: LD_VAR 0 2
52813: ARRAY
52814: ST_TO_ADDR
// if not i then
52815: LD_VAR 0 5
52819: NOT
52820: IFFALSE 52824
// exit ;
52822: GO 52890
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
52824: LD_ADDR_VAR 0 1
52828: PUSH
52829: LD_VAR 0 1
52833: PPUSH
52834: LD_VAR 0 2
52838: PPUSH
52839: LD_VAR 0 1
52843: PUSH
52844: LD_VAR 0 3
52848: ARRAY
52849: PPUSH
52850: CALL_OW 1
52854: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
52855: LD_ADDR_VAR 0 1
52859: PUSH
52860: LD_VAR 0 1
52864: PPUSH
52865: LD_VAR 0 3
52869: PPUSH
52870: LD_VAR 0 5
52874: PPUSH
52875: CALL_OW 1
52879: ST_TO_ADDR
// result := list ;
52880: LD_ADDR_VAR 0 4
52884: PUSH
52885: LD_VAR 0 1
52889: ST_TO_ADDR
// end ;
52890: LD_VAR 0 4
52894: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
52895: LD_INT 0
52897: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
52898: LD_ADDR_VAR 0 5
52902: PUSH
52903: LD_VAR 0 1
52907: PPUSH
52908: CALL_OW 250
52912: PPUSH
52913: LD_VAR 0 1
52917: PPUSH
52918: CALL_OW 251
52922: PPUSH
52923: LD_VAR 0 2
52927: PPUSH
52928: LD_VAR 0 3
52932: PPUSH
52933: LD_VAR 0 4
52937: PPUSH
52938: CALL 52948 0 5
52942: ST_TO_ADDR
// end ;
52943: LD_VAR 0 5
52947: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
52948: LD_INT 0
52950: PPUSH
52951: PPUSH
52952: PPUSH
52953: PPUSH
// if not list then
52954: LD_VAR 0 3
52958: NOT
52959: IFFALSE 52963
// exit ;
52961: GO 53351
// result := [ ] ;
52963: LD_ADDR_VAR 0 6
52967: PUSH
52968: EMPTY
52969: ST_TO_ADDR
// for i in list do
52970: LD_ADDR_VAR 0 7
52974: PUSH
52975: LD_VAR 0 3
52979: PUSH
52980: FOR_IN
52981: IFFALSE 53183
// begin tmp := GetDistUnitXY ( i , x , y ) ;
52983: LD_ADDR_VAR 0 9
52987: PUSH
52988: LD_VAR 0 7
52992: PPUSH
52993: LD_VAR 0 1
52997: PPUSH
52998: LD_VAR 0 2
53002: PPUSH
53003: CALL_OW 297
53007: ST_TO_ADDR
// if not result then
53008: LD_VAR 0 6
53012: NOT
53013: IFFALSE 53039
// result := [ [ i , tmp ] ] else
53015: LD_ADDR_VAR 0 6
53019: PUSH
53020: LD_VAR 0 7
53024: PUSH
53025: LD_VAR 0 9
53029: PUSH
53030: EMPTY
53031: LIST
53032: LIST
53033: PUSH
53034: EMPTY
53035: LIST
53036: ST_TO_ADDR
53037: GO 53181
// begin if result [ result ] [ 2 ] < tmp then
53039: LD_VAR 0 6
53043: PUSH
53044: LD_VAR 0 6
53048: ARRAY
53049: PUSH
53050: LD_INT 2
53052: ARRAY
53053: PUSH
53054: LD_VAR 0 9
53058: LESS
53059: IFFALSE 53101
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53061: LD_ADDR_VAR 0 6
53065: PUSH
53066: LD_VAR 0 6
53070: PPUSH
53071: LD_VAR 0 6
53075: PUSH
53076: LD_INT 1
53078: PLUS
53079: PPUSH
53080: LD_VAR 0 7
53084: PUSH
53085: LD_VAR 0 9
53089: PUSH
53090: EMPTY
53091: LIST
53092: LIST
53093: PPUSH
53094: CALL_OW 2
53098: ST_TO_ADDR
53099: GO 53181
// for j = 1 to result do
53101: LD_ADDR_VAR 0 8
53105: PUSH
53106: DOUBLE
53107: LD_INT 1
53109: DEC
53110: ST_TO_ADDR
53111: LD_VAR 0 6
53115: PUSH
53116: FOR_TO
53117: IFFALSE 53179
// begin if tmp < result [ j ] [ 2 ] then
53119: LD_VAR 0 9
53123: PUSH
53124: LD_VAR 0 6
53128: PUSH
53129: LD_VAR 0 8
53133: ARRAY
53134: PUSH
53135: LD_INT 2
53137: ARRAY
53138: LESS
53139: IFFALSE 53177
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53141: LD_ADDR_VAR 0 6
53145: PUSH
53146: LD_VAR 0 6
53150: PPUSH
53151: LD_VAR 0 8
53155: PPUSH
53156: LD_VAR 0 7
53160: PUSH
53161: LD_VAR 0 9
53165: PUSH
53166: EMPTY
53167: LIST
53168: LIST
53169: PPUSH
53170: CALL_OW 2
53174: ST_TO_ADDR
// break ;
53175: GO 53179
// end ; end ;
53177: GO 53116
53179: POP
53180: POP
// end ; end ;
53181: GO 52980
53183: POP
53184: POP
// if result and not asc then
53185: LD_VAR 0 6
53189: PUSH
53190: LD_VAR 0 4
53194: NOT
53195: AND
53196: IFFALSE 53271
// begin tmp := result ;
53198: LD_ADDR_VAR 0 9
53202: PUSH
53203: LD_VAR 0 6
53207: ST_TO_ADDR
// for i = tmp downto 1 do
53208: LD_ADDR_VAR 0 7
53212: PUSH
53213: DOUBLE
53214: LD_VAR 0 9
53218: INC
53219: ST_TO_ADDR
53220: LD_INT 1
53222: PUSH
53223: FOR_DOWNTO
53224: IFFALSE 53269
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53226: LD_ADDR_VAR 0 6
53230: PUSH
53231: LD_VAR 0 6
53235: PPUSH
53236: LD_VAR 0 9
53240: PUSH
53241: LD_VAR 0 7
53245: MINUS
53246: PUSH
53247: LD_INT 1
53249: PLUS
53250: PPUSH
53251: LD_VAR 0 9
53255: PUSH
53256: LD_VAR 0 7
53260: ARRAY
53261: PPUSH
53262: CALL_OW 1
53266: ST_TO_ADDR
53267: GO 53223
53269: POP
53270: POP
// end ; tmp := [ ] ;
53271: LD_ADDR_VAR 0 9
53275: PUSH
53276: EMPTY
53277: ST_TO_ADDR
// if mode then
53278: LD_VAR 0 5
53282: IFFALSE 53351
// begin for i = 1 to result do
53284: LD_ADDR_VAR 0 7
53288: PUSH
53289: DOUBLE
53290: LD_INT 1
53292: DEC
53293: ST_TO_ADDR
53294: LD_VAR 0 6
53298: PUSH
53299: FOR_TO
53300: IFFALSE 53339
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53302: LD_ADDR_VAR 0 9
53306: PUSH
53307: LD_VAR 0 9
53311: PPUSH
53312: LD_VAR 0 7
53316: PPUSH
53317: LD_VAR 0 6
53321: PUSH
53322: LD_VAR 0 7
53326: ARRAY
53327: PUSH
53328: LD_INT 1
53330: ARRAY
53331: PPUSH
53332: CALL_OW 1
53336: ST_TO_ADDR
53337: GO 53299
53339: POP
53340: POP
// result := tmp ;
53341: LD_ADDR_VAR 0 6
53345: PUSH
53346: LD_VAR 0 9
53350: ST_TO_ADDR
// end ; end ;
53351: LD_VAR 0 6
53355: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53356: LD_INT 0
53358: PPUSH
53359: PPUSH
53360: PPUSH
53361: PPUSH
53362: PPUSH
53363: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53364: LD_ADDR_VAR 0 5
53368: PUSH
53369: LD_INT 0
53371: PUSH
53372: LD_INT 0
53374: PUSH
53375: LD_INT 0
53377: PUSH
53378: EMPTY
53379: PUSH
53380: EMPTY
53381: LIST
53382: LIST
53383: LIST
53384: LIST
53385: ST_TO_ADDR
// if not x or not y then
53386: LD_VAR 0 2
53390: NOT
53391: PUSH
53392: LD_VAR 0 3
53396: NOT
53397: OR
53398: IFFALSE 53402
// exit ;
53400: GO 55048
// if not range then
53402: LD_VAR 0 4
53406: NOT
53407: IFFALSE 53417
// range := 10 ;
53409: LD_ADDR_VAR 0 4
53413: PUSH
53414: LD_INT 10
53416: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53417: LD_ADDR_VAR 0 8
53421: PUSH
53422: LD_INT 81
53424: PUSH
53425: LD_VAR 0 1
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: PUSH
53434: LD_INT 92
53436: PUSH
53437: LD_VAR 0 2
53441: PUSH
53442: LD_VAR 0 3
53446: PUSH
53447: LD_VAR 0 4
53451: PUSH
53452: EMPTY
53453: LIST
53454: LIST
53455: LIST
53456: LIST
53457: PUSH
53458: LD_INT 3
53460: PUSH
53461: LD_INT 21
53463: PUSH
53464: LD_INT 3
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: LIST
53479: PPUSH
53480: CALL_OW 69
53484: ST_TO_ADDR
// if not tmp then
53485: LD_VAR 0 8
53489: NOT
53490: IFFALSE 53494
// exit ;
53492: GO 55048
// for i in tmp do
53494: LD_ADDR_VAR 0 6
53498: PUSH
53499: LD_VAR 0 8
53503: PUSH
53504: FOR_IN
53505: IFFALSE 55023
// begin points := [ 0 , 0 , 0 ] ;
53507: LD_ADDR_VAR 0 9
53511: PUSH
53512: LD_INT 0
53514: PUSH
53515: LD_INT 0
53517: PUSH
53518: LD_INT 0
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: LIST
53525: ST_TO_ADDR
// bpoints := 1 ;
53526: LD_ADDR_VAR 0 10
53530: PUSH
53531: LD_INT 1
53533: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53534: LD_VAR 0 6
53538: PPUSH
53539: CALL_OW 247
53543: PUSH
53544: LD_INT 1
53546: DOUBLE
53547: EQUAL
53548: IFTRUE 53552
53550: GO 54130
53552: POP
// begin if GetClass ( i ) = 1 then
53553: LD_VAR 0 6
53557: PPUSH
53558: CALL_OW 257
53562: PUSH
53563: LD_INT 1
53565: EQUAL
53566: IFFALSE 53587
// points := [ 10 , 5 , 3 ] ;
53568: LD_ADDR_VAR 0 9
53572: PUSH
53573: LD_INT 10
53575: PUSH
53576: LD_INT 5
53578: PUSH
53579: LD_INT 3
53581: PUSH
53582: EMPTY
53583: LIST
53584: LIST
53585: LIST
53586: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53587: LD_VAR 0 6
53591: PPUSH
53592: CALL_OW 257
53596: PUSH
53597: LD_INT 2
53599: PUSH
53600: LD_INT 3
53602: PUSH
53603: LD_INT 4
53605: PUSH
53606: EMPTY
53607: LIST
53608: LIST
53609: LIST
53610: IN
53611: IFFALSE 53632
// points := [ 3 , 2 , 1 ] ;
53613: LD_ADDR_VAR 0 9
53617: PUSH
53618: LD_INT 3
53620: PUSH
53621: LD_INT 2
53623: PUSH
53624: LD_INT 1
53626: PUSH
53627: EMPTY
53628: LIST
53629: LIST
53630: LIST
53631: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53632: LD_VAR 0 6
53636: PPUSH
53637: CALL_OW 257
53641: PUSH
53642: LD_INT 5
53644: EQUAL
53645: IFFALSE 53666
// points := [ 130 , 5 , 2 ] ;
53647: LD_ADDR_VAR 0 9
53651: PUSH
53652: LD_INT 130
53654: PUSH
53655: LD_INT 5
53657: PUSH
53658: LD_INT 2
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: LIST
53665: ST_TO_ADDR
// if GetClass ( i ) = 8 then
53666: LD_VAR 0 6
53670: PPUSH
53671: CALL_OW 257
53675: PUSH
53676: LD_INT 8
53678: EQUAL
53679: IFFALSE 53700
// points := [ 35 , 35 , 30 ] ;
53681: LD_ADDR_VAR 0 9
53685: PUSH
53686: LD_INT 35
53688: PUSH
53689: LD_INT 35
53691: PUSH
53692: LD_INT 30
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: LIST
53699: ST_TO_ADDR
// if GetClass ( i ) = 9 then
53700: LD_VAR 0 6
53704: PPUSH
53705: CALL_OW 257
53709: PUSH
53710: LD_INT 9
53712: EQUAL
53713: IFFALSE 53734
// points := [ 20 , 55 , 40 ] ;
53715: LD_ADDR_VAR 0 9
53719: PUSH
53720: LD_INT 20
53722: PUSH
53723: LD_INT 55
53725: PUSH
53726: LD_INT 40
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
53734: LD_VAR 0 6
53738: PPUSH
53739: CALL_OW 257
53743: PUSH
53744: LD_INT 12
53746: PUSH
53747: LD_INT 16
53749: PUSH
53750: EMPTY
53751: LIST
53752: LIST
53753: IN
53754: IFFALSE 53775
// points := [ 5 , 3 , 2 ] ;
53756: LD_ADDR_VAR 0 9
53760: PUSH
53761: LD_INT 5
53763: PUSH
53764: LD_INT 3
53766: PUSH
53767: LD_INT 2
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: LIST
53774: ST_TO_ADDR
// if GetClass ( i ) = 17 then
53775: LD_VAR 0 6
53779: PPUSH
53780: CALL_OW 257
53784: PUSH
53785: LD_INT 17
53787: EQUAL
53788: IFFALSE 53809
// points := [ 100 , 50 , 75 ] ;
53790: LD_ADDR_VAR 0 9
53794: PUSH
53795: LD_INT 100
53797: PUSH
53798: LD_INT 50
53800: PUSH
53801: LD_INT 75
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: LIST
53808: ST_TO_ADDR
// if GetClass ( i ) = 15 then
53809: LD_VAR 0 6
53813: PPUSH
53814: CALL_OW 257
53818: PUSH
53819: LD_INT 15
53821: EQUAL
53822: IFFALSE 53843
// points := [ 10 , 5 , 3 ] ;
53824: LD_ADDR_VAR 0 9
53828: PUSH
53829: LD_INT 10
53831: PUSH
53832: LD_INT 5
53834: PUSH
53835: LD_INT 3
53837: PUSH
53838: EMPTY
53839: LIST
53840: LIST
53841: LIST
53842: ST_TO_ADDR
// if GetClass ( i ) = 14 then
53843: LD_VAR 0 6
53847: PPUSH
53848: CALL_OW 257
53852: PUSH
53853: LD_INT 14
53855: EQUAL
53856: IFFALSE 53877
// points := [ 10 , 0 , 0 ] ;
53858: LD_ADDR_VAR 0 9
53862: PUSH
53863: LD_INT 10
53865: PUSH
53866: LD_INT 0
53868: PUSH
53869: LD_INT 0
53871: PUSH
53872: EMPTY
53873: LIST
53874: LIST
53875: LIST
53876: ST_TO_ADDR
// if GetClass ( i ) = 11 then
53877: LD_VAR 0 6
53881: PPUSH
53882: CALL_OW 257
53886: PUSH
53887: LD_INT 11
53889: EQUAL
53890: IFFALSE 53911
// points := [ 30 , 10 , 5 ] ;
53892: LD_ADDR_VAR 0 9
53896: PUSH
53897: LD_INT 30
53899: PUSH
53900: LD_INT 10
53902: PUSH
53903: LD_INT 5
53905: PUSH
53906: EMPTY
53907: LIST
53908: LIST
53909: LIST
53910: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
53911: LD_VAR 0 1
53915: PPUSH
53916: LD_INT 5
53918: PPUSH
53919: CALL_OW 321
53923: PUSH
53924: LD_INT 2
53926: EQUAL
53927: IFFALSE 53944
// bpoints := bpoints * 1.8 ;
53929: LD_ADDR_VAR 0 10
53933: PUSH
53934: LD_VAR 0 10
53938: PUSH
53939: LD_REAL  1.80000000000000E+0000
53942: MUL
53943: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
53944: LD_VAR 0 6
53948: PPUSH
53949: CALL_OW 257
53953: PUSH
53954: LD_INT 1
53956: PUSH
53957: LD_INT 2
53959: PUSH
53960: LD_INT 3
53962: PUSH
53963: LD_INT 4
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: LIST
53970: LIST
53971: IN
53972: PUSH
53973: LD_VAR 0 1
53977: PPUSH
53978: LD_INT 51
53980: PPUSH
53981: CALL_OW 321
53985: PUSH
53986: LD_INT 2
53988: EQUAL
53989: AND
53990: IFFALSE 54007
// bpoints := bpoints * 1.2 ;
53992: LD_ADDR_VAR 0 10
53996: PUSH
53997: LD_VAR 0 10
54001: PUSH
54002: LD_REAL  1.20000000000000E+0000
54005: MUL
54006: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54007: LD_VAR 0 6
54011: PPUSH
54012: CALL_OW 257
54016: PUSH
54017: LD_INT 5
54019: PUSH
54020: LD_INT 7
54022: PUSH
54023: LD_INT 9
54025: PUSH
54026: EMPTY
54027: LIST
54028: LIST
54029: LIST
54030: IN
54031: PUSH
54032: LD_VAR 0 1
54036: PPUSH
54037: LD_INT 52
54039: PPUSH
54040: CALL_OW 321
54044: PUSH
54045: LD_INT 2
54047: EQUAL
54048: AND
54049: IFFALSE 54066
// bpoints := bpoints * 1.5 ;
54051: LD_ADDR_VAR 0 10
54055: PUSH
54056: LD_VAR 0 10
54060: PUSH
54061: LD_REAL  1.50000000000000E+0000
54064: MUL
54065: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54066: LD_VAR 0 1
54070: PPUSH
54071: LD_INT 66
54073: PPUSH
54074: CALL_OW 321
54078: PUSH
54079: LD_INT 2
54081: EQUAL
54082: IFFALSE 54099
// bpoints := bpoints * 1.1 ;
54084: LD_ADDR_VAR 0 10
54088: PUSH
54089: LD_VAR 0 10
54093: PUSH
54094: LD_REAL  1.10000000000000E+0000
54097: MUL
54098: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54099: LD_ADDR_VAR 0 10
54103: PUSH
54104: LD_VAR 0 10
54108: PUSH
54109: LD_VAR 0 6
54113: PPUSH
54114: LD_INT 1
54116: PPUSH
54117: CALL_OW 259
54121: PUSH
54122: LD_REAL  1.15000000000000E+0000
54125: MUL
54126: MUL
54127: ST_TO_ADDR
// end ; unit_vehicle :
54128: GO 54952
54130: LD_INT 2
54132: DOUBLE
54133: EQUAL
54134: IFTRUE 54138
54136: GO 54940
54138: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54139: LD_VAR 0 6
54143: PPUSH
54144: CALL_OW 264
54148: PUSH
54149: LD_INT 2
54151: PUSH
54152: LD_INT 42
54154: PUSH
54155: LD_INT 24
54157: PUSH
54158: EMPTY
54159: LIST
54160: LIST
54161: LIST
54162: IN
54163: IFFALSE 54184
// points := [ 25 , 5 , 3 ] ;
54165: LD_ADDR_VAR 0 9
54169: PUSH
54170: LD_INT 25
54172: PUSH
54173: LD_INT 5
54175: PUSH
54176: LD_INT 3
54178: PUSH
54179: EMPTY
54180: LIST
54181: LIST
54182: LIST
54183: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54184: LD_VAR 0 6
54188: PPUSH
54189: CALL_OW 264
54193: PUSH
54194: LD_INT 4
54196: PUSH
54197: LD_INT 43
54199: PUSH
54200: LD_INT 25
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: LIST
54207: IN
54208: IFFALSE 54229
// points := [ 40 , 15 , 5 ] ;
54210: LD_ADDR_VAR 0 9
54214: PUSH
54215: LD_INT 40
54217: PUSH
54218: LD_INT 15
54220: PUSH
54221: LD_INT 5
54223: PUSH
54224: EMPTY
54225: LIST
54226: LIST
54227: LIST
54228: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54229: LD_VAR 0 6
54233: PPUSH
54234: CALL_OW 264
54238: PUSH
54239: LD_INT 3
54241: PUSH
54242: LD_INT 23
54244: PUSH
54245: EMPTY
54246: LIST
54247: LIST
54248: IN
54249: IFFALSE 54270
// points := [ 7 , 25 , 8 ] ;
54251: LD_ADDR_VAR 0 9
54255: PUSH
54256: LD_INT 7
54258: PUSH
54259: LD_INT 25
54261: PUSH
54262: LD_INT 8
54264: PUSH
54265: EMPTY
54266: LIST
54267: LIST
54268: LIST
54269: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54270: LD_VAR 0 6
54274: PPUSH
54275: CALL_OW 264
54279: PUSH
54280: LD_INT 5
54282: PUSH
54283: LD_INT 27
54285: PUSH
54286: LD_INT 44
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: LIST
54293: IN
54294: IFFALSE 54315
// points := [ 14 , 50 , 16 ] ;
54296: LD_ADDR_VAR 0 9
54300: PUSH
54301: LD_INT 14
54303: PUSH
54304: LD_INT 50
54306: PUSH
54307: LD_INT 16
54309: PUSH
54310: EMPTY
54311: LIST
54312: LIST
54313: LIST
54314: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54315: LD_VAR 0 6
54319: PPUSH
54320: CALL_OW 264
54324: PUSH
54325: LD_INT 6
54327: PUSH
54328: LD_INT 46
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: IN
54335: IFFALSE 54356
// points := [ 32 , 120 , 70 ] ;
54337: LD_ADDR_VAR 0 9
54341: PUSH
54342: LD_INT 32
54344: PUSH
54345: LD_INT 120
54347: PUSH
54348: LD_INT 70
54350: PUSH
54351: EMPTY
54352: LIST
54353: LIST
54354: LIST
54355: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54356: LD_VAR 0 6
54360: PPUSH
54361: CALL_OW 264
54365: PUSH
54366: LD_INT 7
54368: PUSH
54369: LD_INT 28
54371: PUSH
54372: LD_INT 45
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: LIST
54379: IN
54380: IFFALSE 54401
// points := [ 35 , 20 , 45 ] ;
54382: LD_ADDR_VAR 0 9
54386: PUSH
54387: LD_INT 35
54389: PUSH
54390: LD_INT 20
54392: PUSH
54393: LD_INT 45
54395: PUSH
54396: EMPTY
54397: LIST
54398: LIST
54399: LIST
54400: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54401: LD_VAR 0 6
54405: PPUSH
54406: CALL_OW 264
54410: PUSH
54411: LD_INT 47
54413: PUSH
54414: EMPTY
54415: LIST
54416: IN
54417: IFFALSE 54438
// points := [ 67 , 45 , 75 ] ;
54419: LD_ADDR_VAR 0 9
54423: PUSH
54424: LD_INT 67
54426: PUSH
54427: LD_INT 45
54429: PUSH
54430: LD_INT 75
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54438: LD_VAR 0 6
54442: PPUSH
54443: CALL_OW 264
54447: PUSH
54448: LD_INT 26
54450: PUSH
54451: EMPTY
54452: LIST
54453: IN
54454: IFFALSE 54475
// points := [ 120 , 30 , 80 ] ;
54456: LD_ADDR_VAR 0 9
54460: PUSH
54461: LD_INT 120
54463: PUSH
54464: LD_INT 30
54466: PUSH
54467: LD_INT 80
54469: PUSH
54470: EMPTY
54471: LIST
54472: LIST
54473: LIST
54474: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54475: LD_VAR 0 6
54479: PPUSH
54480: CALL_OW 264
54484: PUSH
54485: LD_INT 22
54487: PUSH
54488: EMPTY
54489: LIST
54490: IN
54491: IFFALSE 54512
// points := [ 40 , 1 , 1 ] ;
54493: LD_ADDR_VAR 0 9
54497: PUSH
54498: LD_INT 40
54500: PUSH
54501: LD_INT 1
54503: PUSH
54504: LD_INT 1
54506: PUSH
54507: EMPTY
54508: LIST
54509: LIST
54510: LIST
54511: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54512: LD_VAR 0 6
54516: PPUSH
54517: CALL_OW 264
54521: PUSH
54522: LD_INT 29
54524: PUSH
54525: EMPTY
54526: LIST
54527: IN
54528: IFFALSE 54549
// points := [ 70 , 200 , 400 ] ;
54530: LD_ADDR_VAR 0 9
54534: PUSH
54535: LD_INT 70
54537: PUSH
54538: LD_INT 200
54540: PUSH
54541: LD_INT 400
54543: PUSH
54544: EMPTY
54545: LIST
54546: LIST
54547: LIST
54548: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54549: LD_VAR 0 6
54553: PPUSH
54554: CALL_OW 264
54558: PUSH
54559: LD_INT 14
54561: PUSH
54562: LD_INT 53
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: IN
54569: IFFALSE 54590
// points := [ 40 , 10 , 20 ] ;
54571: LD_ADDR_VAR 0 9
54575: PUSH
54576: LD_INT 40
54578: PUSH
54579: LD_INT 10
54581: PUSH
54582: LD_INT 20
54584: PUSH
54585: EMPTY
54586: LIST
54587: LIST
54588: LIST
54589: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54590: LD_VAR 0 6
54594: PPUSH
54595: CALL_OW 264
54599: PUSH
54600: LD_INT 9
54602: PUSH
54603: EMPTY
54604: LIST
54605: IN
54606: IFFALSE 54627
// points := [ 5 , 70 , 20 ] ;
54608: LD_ADDR_VAR 0 9
54612: PUSH
54613: LD_INT 5
54615: PUSH
54616: LD_INT 70
54618: PUSH
54619: LD_INT 20
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: LIST
54626: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54627: LD_VAR 0 6
54631: PPUSH
54632: CALL_OW 264
54636: PUSH
54637: LD_INT 10
54639: PUSH
54640: EMPTY
54641: LIST
54642: IN
54643: IFFALSE 54664
// points := [ 35 , 110 , 70 ] ;
54645: LD_ADDR_VAR 0 9
54649: PUSH
54650: LD_INT 35
54652: PUSH
54653: LD_INT 110
54655: PUSH
54656: LD_INT 70
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: LIST
54663: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
54664: LD_VAR 0 6
54668: PPUSH
54669: CALL_OW 265
54673: PUSH
54674: LD_INT 25
54676: EQUAL
54677: IFFALSE 54698
// points := [ 80 , 65 , 100 ] ;
54679: LD_ADDR_VAR 0 9
54683: PUSH
54684: LD_INT 80
54686: PUSH
54687: LD_INT 65
54689: PUSH
54690: LD_INT 100
54692: PUSH
54693: EMPTY
54694: LIST
54695: LIST
54696: LIST
54697: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
54698: LD_VAR 0 6
54702: PPUSH
54703: CALL_OW 263
54707: PUSH
54708: LD_INT 1
54710: EQUAL
54711: IFFALSE 54746
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
54713: LD_ADDR_VAR 0 10
54717: PUSH
54718: LD_VAR 0 10
54722: PUSH
54723: LD_VAR 0 6
54727: PPUSH
54728: CALL_OW 311
54732: PPUSH
54733: LD_INT 3
54735: PPUSH
54736: CALL_OW 259
54740: PUSH
54741: LD_INT 4
54743: MUL
54744: MUL
54745: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
54746: LD_VAR 0 6
54750: PPUSH
54751: CALL_OW 263
54755: PUSH
54756: LD_INT 2
54758: EQUAL
54759: IFFALSE 54810
// begin j := IsControledBy ( i ) ;
54761: LD_ADDR_VAR 0 7
54765: PUSH
54766: LD_VAR 0 6
54770: PPUSH
54771: CALL_OW 312
54775: ST_TO_ADDR
// if j then
54776: LD_VAR 0 7
54780: IFFALSE 54810
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
54782: LD_ADDR_VAR 0 10
54786: PUSH
54787: LD_VAR 0 10
54791: PUSH
54792: LD_VAR 0 7
54796: PPUSH
54797: LD_INT 3
54799: PPUSH
54800: CALL_OW 259
54804: PUSH
54805: LD_INT 3
54807: MUL
54808: MUL
54809: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
54810: LD_VAR 0 6
54814: PPUSH
54815: CALL_OW 264
54819: PUSH
54820: LD_INT 5
54822: PUSH
54823: LD_INT 6
54825: PUSH
54826: LD_INT 46
54828: PUSH
54829: LD_INT 44
54831: PUSH
54832: LD_INT 47
54834: PUSH
54835: LD_INT 45
54837: PUSH
54838: LD_INT 28
54840: PUSH
54841: LD_INT 7
54843: PUSH
54844: LD_INT 27
54846: PUSH
54847: LD_INT 29
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: LIST
54855: LIST
54856: LIST
54857: LIST
54858: LIST
54859: LIST
54860: LIST
54861: IN
54862: PUSH
54863: LD_VAR 0 1
54867: PPUSH
54868: LD_INT 52
54870: PPUSH
54871: CALL_OW 321
54875: PUSH
54876: LD_INT 2
54878: EQUAL
54879: AND
54880: IFFALSE 54897
// bpoints := bpoints * 1.2 ;
54882: LD_ADDR_VAR 0 10
54886: PUSH
54887: LD_VAR 0 10
54891: PUSH
54892: LD_REAL  1.20000000000000E+0000
54895: MUL
54896: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
54897: LD_VAR 0 6
54901: PPUSH
54902: CALL_OW 264
54906: PUSH
54907: LD_INT 6
54909: PUSH
54910: LD_INT 46
54912: PUSH
54913: LD_INT 47
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: LIST
54920: IN
54921: IFFALSE 54938
// bpoints := bpoints * 1.2 ;
54923: LD_ADDR_VAR 0 10
54927: PUSH
54928: LD_VAR 0 10
54932: PUSH
54933: LD_REAL  1.20000000000000E+0000
54936: MUL
54937: ST_TO_ADDR
// end ; unit_building :
54938: GO 54952
54940: LD_INT 3
54942: DOUBLE
54943: EQUAL
54944: IFTRUE 54948
54946: GO 54951
54948: POP
// ; end ;
54949: GO 54952
54951: POP
// for j = 1 to 3 do
54952: LD_ADDR_VAR 0 7
54956: PUSH
54957: DOUBLE
54958: LD_INT 1
54960: DEC
54961: ST_TO_ADDR
54962: LD_INT 3
54964: PUSH
54965: FOR_TO
54966: IFFALSE 55019
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
54968: LD_ADDR_VAR 0 5
54972: PUSH
54973: LD_VAR 0 5
54977: PPUSH
54978: LD_VAR 0 7
54982: PPUSH
54983: LD_VAR 0 5
54987: PUSH
54988: LD_VAR 0 7
54992: ARRAY
54993: PUSH
54994: LD_VAR 0 9
54998: PUSH
54999: LD_VAR 0 7
55003: ARRAY
55004: PUSH
55005: LD_VAR 0 10
55009: MUL
55010: PLUS
55011: PPUSH
55012: CALL_OW 1
55016: ST_TO_ADDR
55017: GO 54965
55019: POP
55020: POP
// end ;
55021: GO 53504
55023: POP
55024: POP
// result := Replace ( result , 4 , tmp ) ;
55025: LD_ADDR_VAR 0 5
55029: PUSH
55030: LD_VAR 0 5
55034: PPUSH
55035: LD_INT 4
55037: PPUSH
55038: LD_VAR 0 8
55042: PPUSH
55043: CALL_OW 1
55047: ST_TO_ADDR
// end ;
55048: LD_VAR 0 5
55052: RET
// export function DangerAtRange ( unit , range ) ; begin
55053: LD_INT 0
55055: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55056: LD_ADDR_VAR 0 3
55060: PUSH
55061: LD_VAR 0 1
55065: PPUSH
55066: CALL_OW 255
55070: PPUSH
55071: LD_VAR 0 1
55075: PPUSH
55076: CALL_OW 250
55080: PPUSH
55081: LD_VAR 0 1
55085: PPUSH
55086: CALL_OW 251
55090: PPUSH
55091: LD_VAR 0 2
55095: PPUSH
55096: CALL 53356 0 4
55100: ST_TO_ADDR
// end ;
55101: LD_VAR 0 3
55105: RET
// export function DangerInArea ( side , area ) ; begin
55106: LD_INT 0
55108: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55109: LD_ADDR_VAR 0 3
55113: PUSH
55114: LD_VAR 0 2
55118: PPUSH
55119: LD_INT 81
55121: PUSH
55122: LD_VAR 0 1
55126: PUSH
55127: EMPTY
55128: LIST
55129: LIST
55130: PPUSH
55131: CALL_OW 70
55135: ST_TO_ADDR
// end ;
55136: LD_VAR 0 3
55140: RET
// export function IsExtension ( b ) ; begin
55141: LD_INT 0
55143: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55144: LD_ADDR_VAR 0 2
55148: PUSH
55149: LD_VAR 0 1
55153: PUSH
55154: LD_INT 23
55156: PUSH
55157: LD_INT 20
55159: PUSH
55160: LD_INT 22
55162: PUSH
55163: LD_INT 17
55165: PUSH
55166: LD_INT 24
55168: PUSH
55169: LD_INT 21
55171: PUSH
55172: LD_INT 19
55174: PUSH
55175: LD_INT 16
55177: PUSH
55178: LD_INT 25
55180: PUSH
55181: LD_INT 18
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: LIST
55190: LIST
55191: LIST
55192: LIST
55193: LIST
55194: LIST
55195: IN
55196: ST_TO_ADDR
// end ;
55197: LD_VAR 0 2
55201: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55202: LD_INT 0
55204: PPUSH
55205: PPUSH
55206: PPUSH
// result := [ ] ;
55207: LD_ADDR_VAR 0 3
55211: PUSH
55212: EMPTY
55213: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55214: LD_ADDR_VAR 0 4
55218: PUSH
55219: LD_VAR 0 2
55223: PPUSH
55224: LD_INT 21
55226: PUSH
55227: LD_INT 3
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PPUSH
55234: CALL_OW 70
55238: ST_TO_ADDR
// if not tmp then
55239: LD_VAR 0 4
55243: NOT
55244: IFFALSE 55248
// exit ;
55246: GO 55306
// for i in tmp do
55248: LD_ADDR_VAR 0 5
55252: PUSH
55253: LD_VAR 0 4
55257: PUSH
55258: FOR_IN
55259: IFFALSE 55294
// if GetBase ( i ) <> base then
55261: LD_VAR 0 5
55265: PPUSH
55266: CALL_OW 274
55270: PUSH
55271: LD_VAR 0 1
55275: NONEQUAL
55276: IFFALSE 55292
// ComLinkToBase ( base , i ) ;
55278: LD_VAR 0 1
55282: PPUSH
55283: LD_VAR 0 5
55287: PPUSH
55288: CALL_OW 169
55292: GO 55258
55294: POP
55295: POP
// result := tmp ;
55296: LD_ADDR_VAR 0 3
55300: PUSH
55301: LD_VAR 0 4
55305: ST_TO_ADDR
// end ;
55306: LD_VAR 0 3
55310: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55311: LD_INT 0
55313: PPUSH
55314: PPUSH
// if BuildingStatus ( b ) = bs_build then
55315: LD_VAR 0 2
55319: PPUSH
55320: CALL_OW 461
55324: PUSH
55325: LD_INT 1
55327: EQUAL
55328: IFFALSE 55388
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55330: LD_VAR 0 1
55334: PPUSH
55335: LD_STRING h
55337: PUSH
55338: LD_VAR 0 2
55342: PPUSH
55343: CALL_OW 250
55347: PUSH
55348: LD_VAR 0 2
55352: PPUSH
55353: CALL_OW 251
55357: PUSH
55358: LD_VAR 0 2
55362: PUSH
55363: LD_INT 0
55365: PUSH
55366: LD_INT 0
55368: PUSH
55369: LD_INT 0
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: LIST
55377: LIST
55378: LIST
55379: LIST
55380: PUSH
55381: EMPTY
55382: LIST
55383: PPUSH
55384: CALL_OW 446
// end ;
55388: LD_VAR 0 3
55392: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55393: LD_INT 0
55395: PPUSH
55396: PPUSH
55397: PPUSH
55398: PPUSH
55399: PPUSH
55400: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55401: LD_VAR 0 1
55405: NOT
55406: PUSH
55407: LD_VAR 0 1
55411: PPUSH
55412: CALL_OW 263
55416: PUSH
55417: LD_INT 2
55419: EQUAL
55420: NOT
55421: OR
55422: IFFALSE 55426
// exit ;
55424: GO 55742
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55426: LD_ADDR_VAR 0 6
55430: PUSH
55431: LD_INT 22
55433: PUSH
55434: LD_VAR 0 1
55438: PPUSH
55439: CALL_OW 255
55443: PUSH
55444: EMPTY
55445: LIST
55446: LIST
55447: PUSH
55448: LD_INT 2
55450: PUSH
55451: LD_INT 30
55453: PUSH
55454: LD_INT 36
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: PUSH
55461: LD_INT 34
55463: PUSH
55464: LD_INT 31
55466: PUSH
55467: EMPTY
55468: LIST
55469: LIST
55470: PUSH
55471: EMPTY
55472: LIST
55473: LIST
55474: LIST
55475: PUSH
55476: EMPTY
55477: LIST
55478: LIST
55479: PPUSH
55480: CALL_OW 69
55484: ST_TO_ADDR
// if not tmp then
55485: LD_VAR 0 6
55489: NOT
55490: IFFALSE 55494
// exit ;
55492: GO 55742
// result := [ ] ;
55494: LD_ADDR_VAR 0 2
55498: PUSH
55499: EMPTY
55500: ST_TO_ADDR
// for i in tmp do
55501: LD_ADDR_VAR 0 3
55505: PUSH
55506: LD_VAR 0 6
55510: PUSH
55511: FOR_IN
55512: IFFALSE 55583
// begin t := UnitsInside ( i ) ;
55514: LD_ADDR_VAR 0 4
55518: PUSH
55519: LD_VAR 0 3
55523: PPUSH
55524: CALL_OW 313
55528: ST_TO_ADDR
// if t then
55529: LD_VAR 0 4
55533: IFFALSE 55581
// for j in t do
55535: LD_ADDR_VAR 0 7
55539: PUSH
55540: LD_VAR 0 4
55544: PUSH
55545: FOR_IN
55546: IFFALSE 55579
// result := Insert ( result , result + 1 , j ) ;
55548: LD_ADDR_VAR 0 2
55552: PUSH
55553: LD_VAR 0 2
55557: PPUSH
55558: LD_VAR 0 2
55562: PUSH
55563: LD_INT 1
55565: PLUS
55566: PPUSH
55567: LD_VAR 0 7
55571: PPUSH
55572: CALL_OW 2
55576: ST_TO_ADDR
55577: GO 55545
55579: POP
55580: POP
// end ;
55581: GO 55511
55583: POP
55584: POP
// if not result then
55585: LD_VAR 0 2
55589: NOT
55590: IFFALSE 55594
// exit ;
55592: GO 55742
// mech := result [ 1 ] ;
55594: LD_ADDR_VAR 0 5
55598: PUSH
55599: LD_VAR 0 2
55603: PUSH
55604: LD_INT 1
55606: ARRAY
55607: ST_TO_ADDR
// if result > 1 then
55608: LD_VAR 0 2
55612: PUSH
55613: LD_INT 1
55615: GREATER
55616: IFFALSE 55728
// for i = 2 to result do
55618: LD_ADDR_VAR 0 3
55622: PUSH
55623: DOUBLE
55624: LD_INT 2
55626: DEC
55627: ST_TO_ADDR
55628: LD_VAR 0 2
55632: PUSH
55633: FOR_TO
55634: IFFALSE 55726
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
55636: LD_ADDR_VAR 0 4
55640: PUSH
55641: LD_VAR 0 2
55645: PUSH
55646: LD_VAR 0 3
55650: ARRAY
55651: PPUSH
55652: LD_INT 3
55654: PPUSH
55655: CALL_OW 259
55659: PUSH
55660: LD_VAR 0 2
55664: PUSH
55665: LD_VAR 0 3
55669: ARRAY
55670: PPUSH
55671: CALL_OW 432
55675: MINUS
55676: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
55677: LD_VAR 0 4
55681: PUSH
55682: LD_VAR 0 5
55686: PPUSH
55687: LD_INT 3
55689: PPUSH
55690: CALL_OW 259
55694: PUSH
55695: LD_VAR 0 5
55699: PPUSH
55700: CALL_OW 432
55704: MINUS
55705: GREATEREQUAL
55706: IFFALSE 55724
// mech := result [ i ] ;
55708: LD_ADDR_VAR 0 5
55712: PUSH
55713: LD_VAR 0 2
55717: PUSH
55718: LD_VAR 0 3
55722: ARRAY
55723: ST_TO_ADDR
// end ;
55724: GO 55633
55726: POP
55727: POP
// ComLinkTo ( vehicle , mech ) ;
55728: LD_VAR 0 1
55732: PPUSH
55733: LD_VAR 0 5
55737: PPUSH
55738: CALL_OW 135
// end ;
55742: LD_VAR 0 2
55746: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
55747: LD_INT 0
55749: PPUSH
55750: PPUSH
55751: PPUSH
55752: PPUSH
55753: PPUSH
55754: PPUSH
55755: PPUSH
55756: PPUSH
55757: PPUSH
55758: PPUSH
55759: PPUSH
55760: PPUSH
55761: PPUSH
// result := [ ] ;
55762: LD_ADDR_VAR 0 7
55766: PUSH
55767: EMPTY
55768: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
55769: LD_VAR 0 1
55773: PPUSH
55774: CALL_OW 266
55778: PUSH
55779: LD_INT 0
55781: PUSH
55782: LD_INT 1
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: IN
55789: NOT
55790: IFFALSE 55794
// exit ;
55792: GO 57425
// if name then
55794: LD_VAR 0 3
55798: IFFALSE 55814
// SetBName ( base_dep , name ) ;
55800: LD_VAR 0 1
55804: PPUSH
55805: LD_VAR 0 3
55809: PPUSH
55810: CALL_OW 500
// base := GetBase ( base_dep ) ;
55814: LD_ADDR_VAR 0 15
55818: PUSH
55819: LD_VAR 0 1
55823: PPUSH
55824: CALL_OW 274
55828: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
55829: LD_ADDR_VAR 0 16
55833: PUSH
55834: LD_VAR 0 1
55838: PPUSH
55839: CALL_OW 255
55843: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
55844: LD_ADDR_VAR 0 17
55848: PUSH
55849: LD_VAR 0 1
55853: PPUSH
55854: CALL_OW 248
55858: ST_TO_ADDR
// if sources then
55859: LD_VAR 0 5
55863: IFFALSE 55910
// for i = 1 to 3 do
55865: LD_ADDR_VAR 0 8
55869: PUSH
55870: DOUBLE
55871: LD_INT 1
55873: DEC
55874: ST_TO_ADDR
55875: LD_INT 3
55877: PUSH
55878: FOR_TO
55879: IFFALSE 55908
// AddResourceType ( base , i , sources [ i ] ) ;
55881: LD_VAR 0 15
55885: PPUSH
55886: LD_VAR 0 8
55890: PPUSH
55891: LD_VAR 0 5
55895: PUSH
55896: LD_VAR 0 8
55900: ARRAY
55901: PPUSH
55902: CALL_OW 276
55906: GO 55878
55908: POP
55909: POP
// buildings := GetBaseBuildings ( base , area ) ;
55910: LD_ADDR_VAR 0 18
55914: PUSH
55915: LD_VAR 0 15
55919: PPUSH
55920: LD_VAR 0 2
55924: PPUSH
55925: CALL 55202 0 2
55929: ST_TO_ADDR
// InitHc ;
55930: CALL_OW 19
// InitUc ;
55934: CALL_OW 18
// uc_side := side ;
55938: LD_ADDR_OWVAR 20
55942: PUSH
55943: LD_VAR 0 16
55947: ST_TO_ADDR
// uc_nation := nation ;
55948: LD_ADDR_OWVAR 21
55952: PUSH
55953: LD_VAR 0 17
55957: ST_TO_ADDR
// if buildings then
55958: LD_VAR 0 18
55962: IFFALSE 57284
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
55964: LD_ADDR_VAR 0 19
55968: PUSH
55969: LD_VAR 0 18
55973: PPUSH
55974: LD_INT 2
55976: PUSH
55977: LD_INT 30
55979: PUSH
55980: LD_INT 29
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: PUSH
55987: LD_INT 30
55989: PUSH
55990: LD_INT 30
55992: PUSH
55993: EMPTY
55994: LIST
55995: LIST
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: PPUSH
56002: CALL_OW 72
56006: ST_TO_ADDR
// if tmp then
56007: LD_VAR 0 19
56011: IFFALSE 56059
// for i in tmp do
56013: LD_ADDR_VAR 0 8
56017: PUSH
56018: LD_VAR 0 19
56022: PUSH
56023: FOR_IN
56024: IFFALSE 56057
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56026: LD_VAR 0 8
56030: PPUSH
56031: CALL_OW 250
56035: PPUSH
56036: LD_VAR 0 8
56040: PPUSH
56041: CALL_OW 251
56045: PPUSH
56046: LD_VAR 0 16
56050: PPUSH
56051: CALL_OW 441
56055: GO 56023
56057: POP
56058: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56059: LD_VAR 0 18
56063: PPUSH
56064: LD_INT 2
56066: PUSH
56067: LD_INT 30
56069: PUSH
56070: LD_INT 32
56072: PUSH
56073: EMPTY
56074: LIST
56075: LIST
56076: PUSH
56077: LD_INT 30
56079: PUSH
56080: LD_INT 33
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: PUSH
56087: EMPTY
56088: LIST
56089: LIST
56090: LIST
56091: PPUSH
56092: CALL_OW 72
56096: IFFALSE 56184
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56098: LD_ADDR_VAR 0 8
56102: PUSH
56103: LD_VAR 0 18
56107: PPUSH
56108: LD_INT 2
56110: PUSH
56111: LD_INT 30
56113: PUSH
56114: LD_INT 32
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: PUSH
56121: LD_INT 30
56123: PUSH
56124: LD_INT 33
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: LIST
56135: PPUSH
56136: CALL_OW 72
56140: PUSH
56141: FOR_IN
56142: IFFALSE 56182
// begin if not GetBWeapon ( i ) then
56144: LD_VAR 0 8
56148: PPUSH
56149: CALL_OW 269
56153: NOT
56154: IFFALSE 56180
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56156: LD_VAR 0 8
56160: PPUSH
56161: LD_VAR 0 8
56165: PPUSH
56166: LD_VAR 0 2
56170: PPUSH
56171: CALL 57430 0 2
56175: PPUSH
56176: CALL_OW 431
// end ;
56180: GO 56141
56182: POP
56183: POP
// end ; for i = 1 to personel do
56184: LD_ADDR_VAR 0 8
56188: PUSH
56189: DOUBLE
56190: LD_INT 1
56192: DEC
56193: ST_TO_ADDR
56194: LD_VAR 0 6
56198: PUSH
56199: FOR_TO
56200: IFFALSE 57264
// begin if i > 4 then
56202: LD_VAR 0 8
56206: PUSH
56207: LD_INT 4
56209: GREATER
56210: IFFALSE 56214
// break ;
56212: GO 57264
// case i of 1 :
56214: LD_VAR 0 8
56218: PUSH
56219: LD_INT 1
56221: DOUBLE
56222: EQUAL
56223: IFTRUE 56227
56225: GO 56307
56227: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56228: LD_ADDR_VAR 0 12
56232: PUSH
56233: LD_VAR 0 18
56237: PPUSH
56238: LD_INT 22
56240: PUSH
56241: LD_VAR 0 16
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: PUSH
56250: LD_INT 58
56252: PUSH
56253: EMPTY
56254: LIST
56255: PUSH
56256: LD_INT 2
56258: PUSH
56259: LD_INT 30
56261: PUSH
56262: LD_INT 32
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: PUSH
56269: LD_INT 30
56271: PUSH
56272: LD_INT 4
56274: PUSH
56275: EMPTY
56276: LIST
56277: LIST
56278: PUSH
56279: LD_INT 30
56281: PUSH
56282: LD_INT 5
56284: PUSH
56285: EMPTY
56286: LIST
56287: LIST
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: LIST
56293: LIST
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: LIST
56299: PPUSH
56300: CALL_OW 72
56304: ST_TO_ADDR
56305: GO 56529
56307: LD_INT 2
56309: DOUBLE
56310: EQUAL
56311: IFTRUE 56315
56313: GO 56377
56315: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56316: LD_ADDR_VAR 0 12
56320: PUSH
56321: LD_VAR 0 18
56325: PPUSH
56326: LD_INT 22
56328: PUSH
56329: LD_VAR 0 16
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PUSH
56338: LD_INT 2
56340: PUSH
56341: LD_INT 30
56343: PUSH
56344: LD_INT 0
56346: PUSH
56347: EMPTY
56348: LIST
56349: LIST
56350: PUSH
56351: LD_INT 30
56353: PUSH
56354: LD_INT 1
56356: PUSH
56357: EMPTY
56358: LIST
56359: LIST
56360: PUSH
56361: EMPTY
56362: LIST
56363: LIST
56364: LIST
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: PPUSH
56370: CALL_OW 72
56374: ST_TO_ADDR
56375: GO 56529
56377: LD_INT 3
56379: DOUBLE
56380: EQUAL
56381: IFTRUE 56385
56383: GO 56447
56385: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56386: LD_ADDR_VAR 0 12
56390: PUSH
56391: LD_VAR 0 18
56395: PPUSH
56396: LD_INT 22
56398: PUSH
56399: LD_VAR 0 16
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: PUSH
56408: LD_INT 2
56410: PUSH
56411: LD_INT 30
56413: PUSH
56414: LD_INT 2
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PUSH
56421: LD_INT 30
56423: PUSH
56424: LD_INT 3
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: LIST
56435: PUSH
56436: EMPTY
56437: LIST
56438: LIST
56439: PPUSH
56440: CALL_OW 72
56444: ST_TO_ADDR
56445: GO 56529
56447: LD_INT 4
56449: DOUBLE
56450: EQUAL
56451: IFTRUE 56455
56453: GO 56528
56455: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56456: LD_ADDR_VAR 0 12
56460: PUSH
56461: LD_VAR 0 18
56465: PPUSH
56466: LD_INT 22
56468: PUSH
56469: LD_VAR 0 16
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: PUSH
56478: LD_INT 2
56480: PUSH
56481: LD_INT 30
56483: PUSH
56484: LD_INT 6
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: PUSH
56491: LD_INT 30
56493: PUSH
56494: LD_INT 7
56496: PUSH
56497: EMPTY
56498: LIST
56499: LIST
56500: PUSH
56501: LD_INT 30
56503: PUSH
56504: LD_INT 8
56506: PUSH
56507: EMPTY
56508: LIST
56509: LIST
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: LIST
56515: LIST
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: PPUSH
56521: CALL_OW 72
56525: ST_TO_ADDR
56526: GO 56529
56528: POP
// if i = 1 then
56529: LD_VAR 0 8
56533: PUSH
56534: LD_INT 1
56536: EQUAL
56537: IFFALSE 56648
// begin tmp := [ ] ;
56539: LD_ADDR_VAR 0 19
56543: PUSH
56544: EMPTY
56545: ST_TO_ADDR
// for j in f do
56546: LD_ADDR_VAR 0 9
56550: PUSH
56551: LD_VAR 0 12
56555: PUSH
56556: FOR_IN
56557: IFFALSE 56630
// if GetBType ( j ) = b_bunker then
56559: LD_VAR 0 9
56563: PPUSH
56564: CALL_OW 266
56568: PUSH
56569: LD_INT 32
56571: EQUAL
56572: IFFALSE 56599
// tmp := Insert ( tmp , 1 , j ) else
56574: LD_ADDR_VAR 0 19
56578: PUSH
56579: LD_VAR 0 19
56583: PPUSH
56584: LD_INT 1
56586: PPUSH
56587: LD_VAR 0 9
56591: PPUSH
56592: CALL_OW 2
56596: ST_TO_ADDR
56597: GO 56628
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56599: LD_ADDR_VAR 0 19
56603: PUSH
56604: LD_VAR 0 19
56608: PPUSH
56609: LD_VAR 0 19
56613: PUSH
56614: LD_INT 1
56616: PLUS
56617: PPUSH
56618: LD_VAR 0 9
56622: PPUSH
56623: CALL_OW 2
56627: ST_TO_ADDR
56628: GO 56556
56630: POP
56631: POP
// if tmp then
56632: LD_VAR 0 19
56636: IFFALSE 56648
// f := tmp ;
56638: LD_ADDR_VAR 0 12
56642: PUSH
56643: LD_VAR 0 19
56647: ST_TO_ADDR
// end ; x := personel [ i ] ;
56648: LD_ADDR_VAR 0 13
56652: PUSH
56653: LD_VAR 0 6
56657: PUSH
56658: LD_VAR 0 8
56662: ARRAY
56663: ST_TO_ADDR
// if x = - 1 then
56664: LD_VAR 0 13
56668: PUSH
56669: LD_INT 1
56671: NEG
56672: EQUAL
56673: IFFALSE 56882
// begin for j in f do
56675: LD_ADDR_VAR 0 9
56679: PUSH
56680: LD_VAR 0 12
56684: PUSH
56685: FOR_IN
56686: IFFALSE 56878
// repeat InitHc ;
56688: CALL_OW 19
// if GetBType ( j ) = b_barracks then
56692: LD_VAR 0 9
56696: PPUSH
56697: CALL_OW 266
56701: PUSH
56702: LD_INT 5
56704: EQUAL
56705: IFFALSE 56775
// begin if UnitsInside ( j ) < 3 then
56707: LD_VAR 0 9
56711: PPUSH
56712: CALL_OW 313
56716: PUSH
56717: LD_INT 3
56719: LESS
56720: IFFALSE 56756
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
56722: LD_INT 0
56724: PPUSH
56725: LD_INT 5
56727: PUSH
56728: LD_INT 8
56730: PUSH
56731: LD_INT 9
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: LIST
56738: PUSH
56739: LD_VAR 0 17
56743: ARRAY
56744: PPUSH
56745: LD_VAR 0 4
56749: PPUSH
56750: CALL_OW 380
56754: GO 56773
// PrepareHuman ( false , i , skill ) ;
56756: LD_INT 0
56758: PPUSH
56759: LD_VAR 0 8
56763: PPUSH
56764: LD_VAR 0 4
56768: PPUSH
56769: CALL_OW 380
// end else
56773: GO 56792
// PrepareHuman ( false , i , skill ) ;
56775: LD_INT 0
56777: PPUSH
56778: LD_VAR 0 8
56782: PPUSH
56783: LD_VAR 0 4
56787: PPUSH
56788: CALL_OW 380
// un := CreateHuman ;
56792: LD_ADDR_VAR 0 14
56796: PUSH
56797: CALL_OW 44
56801: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56802: LD_ADDR_VAR 0 7
56806: PUSH
56807: LD_VAR 0 7
56811: PPUSH
56812: LD_INT 1
56814: PPUSH
56815: LD_VAR 0 14
56819: PPUSH
56820: CALL_OW 2
56824: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
56825: LD_VAR 0 14
56829: PPUSH
56830: LD_VAR 0 9
56834: PPUSH
56835: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
56839: LD_VAR 0 9
56843: PPUSH
56844: CALL_OW 313
56848: PUSH
56849: LD_INT 6
56851: EQUAL
56852: PUSH
56853: LD_VAR 0 9
56857: PPUSH
56858: CALL_OW 266
56862: PUSH
56863: LD_INT 32
56865: PUSH
56866: LD_INT 31
56868: PUSH
56869: EMPTY
56870: LIST
56871: LIST
56872: IN
56873: OR
56874: IFFALSE 56688
56876: GO 56685
56878: POP
56879: POP
// end else
56880: GO 57262
// for j = 1 to x do
56882: LD_ADDR_VAR 0 9
56886: PUSH
56887: DOUBLE
56888: LD_INT 1
56890: DEC
56891: ST_TO_ADDR
56892: LD_VAR 0 13
56896: PUSH
56897: FOR_TO
56898: IFFALSE 57260
// begin InitHc ;
56900: CALL_OW 19
// if not f then
56904: LD_VAR 0 12
56908: NOT
56909: IFFALSE 56998
// begin PrepareHuman ( false , i , skill ) ;
56911: LD_INT 0
56913: PPUSH
56914: LD_VAR 0 8
56918: PPUSH
56919: LD_VAR 0 4
56923: PPUSH
56924: CALL_OW 380
// un := CreateHuman ;
56928: LD_ADDR_VAR 0 14
56932: PUSH
56933: CALL_OW 44
56937: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56938: LD_ADDR_VAR 0 7
56942: PUSH
56943: LD_VAR 0 7
56947: PPUSH
56948: LD_INT 1
56950: PPUSH
56951: LD_VAR 0 14
56955: PPUSH
56956: CALL_OW 2
56960: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56961: LD_VAR 0 14
56965: PPUSH
56966: LD_VAR 0 1
56970: PPUSH
56971: CALL_OW 250
56975: PPUSH
56976: LD_VAR 0 1
56980: PPUSH
56981: CALL_OW 251
56985: PPUSH
56986: LD_INT 10
56988: PPUSH
56989: LD_INT 0
56991: PPUSH
56992: CALL_OW 50
// continue ;
56996: GO 56897
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
56998: LD_VAR 0 12
57002: PUSH
57003: LD_INT 1
57005: ARRAY
57006: PPUSH
57007: CALL_OW 313
57011: PUSH
57012: LD_VAR 0 12
57016: PUSH
57017: LD_INT 1
57019: ARRAY
57020: PPUSH
57021: CALL_OW 266
57025: PUSH
57026: LD_INT 32
57028: PUSH
57029: LD_INT 31
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: IN
57036: AND
57037: PUSH
57038: LD_VAR 0 12
57042: PUSH
57043: LD_INT 1
57045: ARRAY
57046: PPUSH
57047: CALL_OW 313
57051: PUSH
57052: LD_INT 6
57054: EQUAL
57055: OR
57056: IFFALSE 57076
// f := Delete ( f , 1 ) ;
57058: LD_ADDR_VAR 0 12
57062: PUSH
57063: LD_VAR 0 12
57067: PPUSH
57068: LD_INT 1
57070: PPUSH
57071: CALL_OW 3
57075: ST_TO_ADDR
// if not f then
57076: LD_VAR 0 12
57080: NOT
57081: IFFALSE 57099
// begin x := x + 2 ;
57083: LD_ADDR_VAR 0 13
57087: PUSH
57088: LD_VAR 0 13
57092: PUSH
57093: LD_INT 2
57095: PLUS
57096: ST_TO_ADDR
// continue ;
57097: GO 56897
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57099: LD_VAR 0 12
57103: PUSH
57104: LD_INT 1
57106: ARRAY
57107: PPUSH
57108: CALL_OW 266
57112: PUSH
57113: LD_INT 5
57115: EQUAL
57116: IFFALSE 57190
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57118: LD_VAR 0 12
57122: PUSH
57123: LD_INT 1
57125: ARRAY
57126: PPUSH
57127: CALL_OW 313
57131: PUSH
57132: LD_INT 3
57134: LESS
57135: IFFALSE 57171
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57137: LD_INT 0
57139: PPUSH
57140: LD_INT 5
57142: PUSH
57143: LD_INT 8
57145: PUSH
57146: LD_INT 9
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: PUSH
57154: LD_VAR 0 17
57158: ARRAY
57159: PPUSH
57160: LD_VAR 0 4
57164: PPUSH
57165: CALL_OW 380
57169: GO 57188
// PrepareHuman ( false , i , skill ) ;
57171: LD_INT 0
57173: PPUSH
57174: LD_VAR 0 8
57178: PPUSH
57179: LD_VAR 0 4
57183: PPUSH
57184: CALL_OW 380
// end else
57188: GO 57207
// PrepareHuman ( false , i , skill ) ;
57190: LD_INT 0
57192: PPUSH
57193: LD_VAR 0 8
57197: PPUSH
57198: LD_VAR 0 4
57202: PPUSH
57203: CALL_OW 380
// un := CreateHuman ;
57207: LD_ADDR_VAR 0 14
57211: PUSH
57212: CALL_OW 44
57216: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57217: LD_ADDR_VAR 0 7
57221: PUSH
57222: LD_VAR 0 7
57226: PPUSH
57227: LD_INT 1
57229: PPUSH
57230: LD_VAR 0 14
57234: PPUSH
57235: CALL_OW 2
57239: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57240: LD_VAR 0 14
57244: PPUSH
57245: LD_VAR 0 12
57249: PUSH
57250: LD_INT 1
57252: ARRAY
57253: PPUSH
57254: CALL_OW 52
// end ;
57258: GO 56897
57260: POP
57261: POP
// end ;
57262: GO 56199
57264: POP
57265: POP
// result := result ^ buildings ;
57266: LD_ADDR_VAR 0 7
57270: PUSH
57271: LD_VAR 0 7
57275: PUSH
57276: LD_VAR 0 18
57280: ADD
57281: ST_TO_ADDR
// end else
57282: GO 57425
// begin for i = 1 to personel do
57284: LD_ADDR_VAR 0 8
57288: PUSH
57289: DOUBLE
57290: LD_INT 1
57292: DEC
57293: ST_TO_ADDR
57294: LD_VAR 0 6
57298: PUSH
57299: FOR_TO
57300: IFFALSE 57423
// begin if i > 4 then
57302: LD_VAR 0 8
57306: PUSH
57307: LD_INT 4
57309: GREATER
57310: IFFALSE 57314
// break ;
57312: GO 57423
// x := personel [ i ] ;
57314: LD_ADDR_VAR 0 13
57318: PUSH
57319: LD_VAR 0 6
57323: PUSH
57324: LD_VAR 0 8
57328: ARRAY
57329: ST_TO_ADDR
// if x = - 1 then
57330: LD_VAR 0 13
57334: PUSH
57335: LD_INT 1
57337: NEG
57338: EQUAL
57339: IFFALSE 57343
// continue ;
57341: GO 57299
// PrepareHuman ( false , i , skill ) ;
57343: LD_INT 0
57345: PPUSH
57346: LD_VAR 0 8
57350: PPUSH
57351: LD_VAR 0 4
57355: PPUSH
57356: CALL_OW 380
// un := CreateHuman ;
57360: LD_ADDR_VAR 0 14
57364: PUSH
57365: CALL_OW 44
57369: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57370: LD_VAR 0 14
57374: PPUSH
57375: LD_VAR 0 1
57379: PPUSH
57380: CALL_OW 250
57384: PPUSH
57385: LD_VAR 0 1
57389: PPUSH
57390: CALL_OW 251
57394: PPUSH
57395: LD_INT 10
57397: PPUSH
57398: LD_INT 0
57400: PPUSH
57401: CALL_OW 50
// result := result ^ un ;
57405: LD_ADDR_VAR 0 7
57409: PUSH
57410: LD_VAR 0 7
57414: PUSH
57415: LD_VAR 0 14
57419: ADD
57420: ST_TO_ADDR
// end ;
57421: GO 57299
57423: POP
57424: POP
// end ; end ;
57425: LD_VAR 0 7
57429: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57430: LD_INT 0
57432: PPUSH
57433: PPUSH
57434: PPUSH
57435: PPUSH
57436: PPUSH
57437: PPUSH
57438: PPUSH
57439: PPUSH
57440: PPUSH
57441: PPUSH
57442: PPUSH
57443: PPUSH
57444: PPUSH
57445: PPUSH
57446: PPUSH
57447: PPUSH
// result := false ;
57448: LD_ADDR_VAR 0 3
57452: PUSH
57453: LD_INT 0
57455: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57456: LD_VAR 0 1
57460: NOT
57461: PUSH
57462: LD_VAR 0 1
57466: PPUSH
57467: CALL_OW 266
57471: PUSH
57472: LD_INT 32
57474: PUSH
57475: LD_INT 33
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: IN
57482: NOT
57483: OR
57484: IFFALSE 57488
// exit ;
57486: GO 58624
// nat := GetNation ( tower ) ;
57488: LD_ADDR_VAR 0 12
57492: PUSH
57493: LD_VAR 0 1
57497: PPUSH
57498: CALL_OW 248
57502: ST_TO_ADDR
// side := GetSide ( tower ) ;
57503: LD_ADDR_VAR 0 16
57507: PUSH
57508: LD_VAR 0 1
57512: PPUSH
57513: CALL_OW 255
57517: ST_TO_ADDR
// x := GetX ( tower ) ;
57518: LD_ADDR_VAR 0 10
57522: PUSH
57523: LD_VAR 0 1
57527: PPUSH
57528: CALL_OW 250
57532: ST_TO_ADDR
// y := GetY ( tower ) ;
57533: LD_ADDR_VAR 0 11
57537: PUSH
57538: LD_VAR 0 1
57542: PPUSH
57543: CALL_OW 251
57547: ST_TO_ADDR
// if not x or not y then
57548: LD_VAR 0 10
57552: NOT
57553: PUSH
57554: LD_VAR 0 11
57558: NOT
57559: OR
57560: IFFALSE 57564
// exit ;
57562: GO 58624
// weapon := 0 ;
57564: LD_ADDR_VAR 0 18
57568: PUSH
57569: LD_INT 0
57571: ST_TO_ADDR
// fac_list := [ ] ;
57572: LD_ADDR_VAR 0 17
57576: PUSH
57577: EMPTY
57578: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57579: LD_ADDR_VAR 0 6
57583: PUSH
57584: LD_VAR 0 1
57588: PPUSH
57589: CALL_OW 274
57593: PPUSH
57594: LD_VAR 0 2
57598: PPUSH
57599: CALL 55202 0 2
57603: PPUSH
57604: LD_INT 30
57606: PUSH
57607: LD_INT 3
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: PPUSH
57614: CALL_OW 72
57618: ST_TO_ADDR
// if not factories then
57619: LD_VAR 0 6
57623: NOT
57624: IFFALSE 57628
// exit ;
57626: GO 58624
// for i in factories do
57628: LD_ADDR_VAR 0 8
57632: PUSH
57633: LD_VAR 0 6
57637: PUSH
57638: FOR_IN
57639: IFFALSE 57664
// fac_list := fac_list union AvailableWeaponList ( i ) ;
57641: LD_ADDR_VAR 0 17
57645: PUSH
57646: LD_VAR 0 17
57650: PUSH
57651: LD_VAR 0 8
57655: PPUSH
57656: CALL_OW 478
57660: UNION
57661: ST_TO_ADDR
57662: GO 57638
57664: POP
57665: POP
// if not fac_list then
57666: LD_VAR 0 17
57670: NOT
57671: IFFALSE 57675
// exit ;
57673: GO 58624
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
57675: LD_ADDR_VAR 0 5
57679: PUSH
57680: LD_INT 4
57682: PUSH
57683: LD_INT 5
57685: PUSH
57686: LD_INT 9
57688: PUSH
57689: LD_INT 10
57691: PUSH
57692: LD_INT 6
57694: PUSH
57695: LD_INT 7
57697: PUSH
57698: LD_INT 11
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: LIST
57705: LIST
57706: LIST
57707: LIST
57708: LIST
57709: PUSH
57710: LD_INT 27
57712: PUSH
57713: LD_INT 28
57715: PUSH
57716: LD_INT 26
57718: PUSH
57719: LD_INT 30
57721: PUSH
57722: EMPTY
57723: LIST
57724: LIST
57725: LIST
57726: LIST
57727: PUSH
57728: LD_INT 43
57730: PUSH
57731: LD_INT 44
57733: PUSH
57734: LD_INT 46
57736: PUSH
57737: LD_INT 45
57739: PUSH
57740: LD_INT 47
57742: PUSH
57743: LD_INT 49
57745: PUSH
57746: EMPTY
57747: LIST
57748: LIST
57749: LIST
57750: LIST
57751: LIST
57752: LIST
57753: PUSH
57754: EMPTY
57755: LIST
57756: LIST
57757: LIST
57758: PUSH
57759: LD_VAR 0 12
57763: ARRAY
57764: ST_TO_ADDR
// for i in list do
57765: LD_ADDR_VAR 0 8
57769: PUSH
57770: LD_VAR 0 5
57774: PUSH
57775: FOR_IN
57776: IFFALSE 57809
// if not i in fac_list then
57778: LD_VAR 0 8
57782: PUSH
57783: LD_VAR 0 17
57787: IN
57788: NOT
57789: IFFALSE 57807
// list := list diff i ;
57791: LD_ADDR_VAR 0 5
57795: PUSH
57796: LD_VAR 0 5
57800: PUSH
57801: LD_VAR 0 8
57805: DIFF
57806: ST_TO_ADDR
57807: GO 57775
57809: POP
57810: POP
// if not list then
57811: LD_VAR 0 5
57815: NOT
57816: IFFALSE 57820
// exit ;
57818: GO 58624
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
57820: LD_VAR 0 12
57824: PUSH
57825: LD_INT 3
57827: EQUAL
57828: PUSH
57829: LD_INT 49
57831: PUSH
57832: LD_VAR 0 5
57836: IN
57837: AND
57838: PUSH
57839: LD_INT 31
57841: PPUSH
57842: LD_VAR 0 16
57846: PPUSH
57847: CALL_OW 321
57851: PUSH
57852: LD_INT 2
57854: EQUAL
57855: AND
57856: IFFALSE 57916
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
57858: LD_INT 22
57860: PUSH
57861: LD_VAR 0 16
57865: PUSH
57866: EMPTY
57867: LIST
57868: LIST
57869: PUSH
57870: LD_INT 35
57872: PUSH
57873: LD_INT 49
57875: PUSH
57876: EMPTY
57877: LIST
57878: LIST
57879: PUSH
57880: LD_INT 91
57882: PUSH
57883: LD_VAR 0 1
57887: PUSH
57888: LD_INT 10
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: LIST
57895: PUSH
57896: EMPTY
57897: LIST
57898: LIST
57899: LIST
57900: PPUSH
57901: CALL_OW 69
57905: NOT
57906: IFFALSE 57916
// weapon := ru_time_lapser ;
57908: LD_ADDR_VAR 0 18
57912: PUSH
57913: LD_INT 49
57915: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
57916: LD_VAR 0 12
57920: PUSH
57921: LD_INT 1
57923: PUSH
57924: LD_INT 2
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: IN
57931: PUSH
57932: LD_INT 11
57934: PUSH
57935: LD_VAR 0 5
57939: IN
57940: PUSH
57941: LD_INT 30
57943: PUSH
57944: LD_VAR 0 5
57948: IN
57949: OR
57950: AND
57951: PUSH
57952: LD_INT 6
57954: PPUSH
57955: LD_VAR 0 16
57959: PPUSH
57960: CALL_OW 321
57964: PUSH
57965: LD_INT 2
57967: EQUAL
57968: AND
57969: IFFALSE 58134
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
57971: LD_INT 22
57973: PUSH
57974: LD_VAR 0 16
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: PUSH
57983: LD_INT 2
57985: PUSH
57986: LD_INT 35
57988: PUSH
57989: LD_INT 11
57991: PUSH
57992: EMPTY
57993: LIST
57994: LIST
57995: PUSH
57996: LD_INT 35
57998: PUSH
57999: LD_INT 30
58001: PUSH
58002: EMPTY
58003: LIST
58004: LIST
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: LIST
58010: PUSH
58011: LD_INT 91
58013: PUSH
58014: LD_VAR 0 1
58018: PUSH
58019: LD_INT 18
58021: PUSH
58022: EMPTY
58023: LIST
58024: LIST
58025: LIST
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: LIST
58031: PPUSH
58032: CALL_OW 69
58036: NOT
58037: PUSH
58038: LD_INT 22
58040: PUSH
58041: LD_VAR 0 16
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: PUSH
58050: LD_INT 2
58052: PUSH
58053: LD_INT 30
58055: PUSH
58056: LD_INT 32
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: PUSH
58063: LD_INT 30
58065: PUSH
58066: LD_INT 33
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: PUSH
58078: LD_INT 91
58080: PUSH
58081: LD_VAR 0 1
58085: PUSH
58086: LD_INT 12
58088: PUSH
58089: EMPTY
58090: LIST
58091: LIST
58092: LIST
58093: PUSH
58094: EMPTY
58095: LIST
58096: LIST
58097: LIST
58098: PUSH
58099: EMPTY
58100: LIST
58101: PPUSH
58102: CALL_OW 69
58106: PUSH
58107: LD_INT 2
58109: GREATER
58110: AND
58111: IFFALSE 58134
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58113: LD_ADDR_VAR 0 18
58117: PUSH
58118: LD_INT 11
58120: PUSH
58121: LD_INT 30
58123: PUSH
58124: EMPTY
58125: LIST
58126: LIST
58127: PUSH
58128: LD_VAR 0 12
58132: ARRAY
58133: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58134: LD_VAR 0 18
58138: NOT
58139: PUSH
58140: LD_INT 40
58142: PPUSH
58143: LD_VAR 0 16
58147: PPUSH
58148: CALL_OW 321
58152: PUSH
58153: LD_INT 2
58155: EQUAL
58156: AND
58157: PUSH
58158: LD_INT 7
58160: PUSH
58161: LD_VAR 0 5
58165: IN
58166: PUSH
58167: LD_INT 28
58169: PUSH
58170: LD_VAR 0 5
58174: IN
58175: OR
58176: PUSH
58177: LD_INT 45
58179: PUSH
58180: LD_VAR 0 5
58184: IN
58185: OR
58186: AND
58187: IFFALSE 58441
// begin hex := GetHexInfo ( x , y ) ;
58189: LD_ADDR_VAR 0 4
58193: PUSH
58194: LD_VAR 0 10
58198: PPUSH
58199: LD_VAR 0 11
58203: PPUSH
58204: CALL_OW 546
58208: ST_TO_ADDR
// if hex [ 1 ] then
58209: LD_VAR 0 4
58213: PUSH
58214: LD_INT 1
58216: ARRAY
58217: IFFALSE 58221
// exit ;
58219: GO 58624
// height := hex [ 2 ] ;
58221: LD_ADDR_VAR 0 15
58225: PUSH
58226: LD_VAR 0 4
58230: PUSH
58231: LD_INT 2
58233: ARRAY
58234: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58235: LD_ADDR_VAR 0 14
58239: PUSH
58240: LD_INT 0
58242: PUSH
58243: LD_INT 2
58245: PUSH
58246: LD_INT 3
58248: PUSH
58249: LD_INT 5
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: LIST
58256: LIST
58257: ST_TO_ADDR
// for i in tmp do
58258: LD_ADDR_VAR 0 8
58262: PUSH
58263: LD_VAR 0 14
58267: PUSH
58268: FOR_IN
58269: IFFALSE 58439
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58271: LD_ADDR_VAR 0 9
58275: PUSH
58276: LD_VAR 0 10
58280: PPUSH
58281: LD_VAR 0 8
58285: PPUSH
58286: LD_INT 5
58288: PPUSH
58289: CALL_OW 272
58293: PUSH
58294: LD_VAR 0 11
58298: PPUSH
58299: LD_VAR 0 8
58303: PPUSH
58304: LD_INT 5
58306: PPUSH
58307: CALL_OW 273
58311: PUSH
58312: EMPTY
58313: LIST
58314: LIST
58315: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58316: LD_VAR 0 9
58320: PUSH
58321: LD_INT 1
58323: ARRAY
58324: PPUSH
58325: LD_VAR 0 9
58329: PUSH
58330: LD_INT 2
58332: ARRAY
58333: PPUSH
58334: CALL_OW 488
58338: IFFALSE 58437
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58340: LD_ADDR_VAR 0 4
58344: PUSH
58345: LD_VAR 0 9
58349: PUSH
58350: LD_INT 1
58352: ARRAY
58353: PPUSH
58354: LD_VAR 0 9
58358: PUSH
58359: LD_INT 2
58361: ARRAY
58362: PPUSH
58363: CALL_OW 546
58367: ST_TO_ADDR
// if hex [ 1 ] then
58368: LD_VAR 0 4
58372: PUSH
58373: LD_INT 1
58375: ARRAY
58376: IFFALSE 58380
// continue ;
58378: GO 58268
// h := hex [ 2 ] ;
58380: LD_ADDR_VAR 0 13
58384: PUSH
58385: LD_VAR 0 4
58389: PUSH
58390: LD_INT 2
58392: ARRAY
58393: ST_TO_ADDR
// if h + 7 < height then
58394: LD_VAR 0 13
58398: PUSH
58399: LD_INT 7
58401: PLUS
58402: PUSH
58403: LD_VAR 0 15
58407: LESS
58408: IFFALSE 58437
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58410: LD_ADDR_VAR 0 18
58414: PUSH
58415: LD_INT 7
58417: PUSH
58418: LD_INT 28
58420: PUSH
58421: LD_INT 45
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: LIST
58428: PUSH
58429: LD_VAR 0 12
58433: ARRAY
58434: ST_TO_ADDR
// break ;
58435: GO 58439
// end ; end ; end ;
58437: GO 58268
58439: POP
58440: POP
// end ; if not weapon then
58441: LD_VAR 0 18
58445: NOT
58446: IFFALSE 58506
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58448: LD_ADDR_VAR 0 5
58452: PUSH
58453: LD_VAR 0 5
58457: PUSH
58458: LD_INT 11
58460: PUSH
58461: LD_INT 30
58463: PUSH
58464: LD_INT 49
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: LIST
58471: DIFF
58472: ST_TO_ADDR
// if not list then
58473: LD_VAR 0 5
58477: NOT
58478: IFFALSE 58482
// exit ;
58480: GO 58624
// weapon := list [ rand ( 1 , list ) ] ;
58482: LD_ADDR_VAR 0 18
58486: PUSH
58487: LD_VAR 0 5
58491: PUSH
58492: LD_INT 1
58494: PPUSH
58495: LD_VAR 0 5
58499: PPUSH
58500: CALL_OW 12
58504: ARRAY
58505: ST_TO_ADDR
// end ; if weapon then
58506: LD_VAR 0 18
58510: IFFALSE 58624
// begin tmp := CostOfWeapon ( weapon ) ;
58512: LD_ADDR_VAR 0 14
58516: PUSH
58517: LD_VAR 0 18
58521: PPUSH
58522: CALL_OW 451
58526: ST_TO_ADDR
// j := GetBase ( tower ) ;
58527: LD_ADDR_VAR 0 9
58531: PUSH
58532: LD_VAR 0 1
58536: PPUSH
58537: CALL_OW 274
58541: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58542: LD_VAR 0 9
58546: PPUSH
58547: LD_INT 1
58549: PPUSH
58550: CALL_OW 275
58554: PUSH
58555: LD_VAR 0 14
58559: PUSH
58560: LD_INT 1
58562: ARRAY
58563: GREATEREQUAL
58564: PUSH
58565: LD_VAR 0 9
58569: PPUSH
58570: LD_INT 2
58572: PPUSH
58573: CALL_OW 275
58577: PUSH
58578: LD_VAR 0 14
58582: PUSH
58583: LD_INT 2
58585: ARRAY
58586: GREATEREQUAL
58587: AND
58588: PUSH
58589: LD_VAR 0 9
58593: PPUSH
58594: LD_INT 3
58596: PPUSH
58597: CALL_OW 275
58601: PUSH
58602: LD_VAR 0 14
58606: PUSH
58607: LD_INT 3
58609: ARRAY
58610: GREATEREQUAL
58611: AND
58612: IFFALSE 58624
// result := weapon ;
58614: LD_ADDR_VAR 0 3
58618: PUSH
58619: LD_VAR 0 18
58623: ST_TO_ADDR
// end ; end ;
58624: LD_VAR 0 3
58628: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58629: LD_INT 0
58631: PPUSH
58632: PPUSH
// result := true ;
58633: LD_ADDR_VAR 0 3
58637: PUSH
58638: LD_INT 1
58640: ST_TO_ADDR
// if array1 = array2 then
58641: LD_VAR 0 1
58645: PUSH
58646: LD_VAR 0 2
58650: EQUAL
58651: IFFALSE 58711
// begin for i = 1 to array1 do
58653: LD_ADDR_VAR 0 4
58657: PUSH
58658: DOUBLE
58659: LD_INT 1
58661: DEC
58662: ST_TO_ADDR
58663: LD_VAR 0 1
58667: PUSH
58668: FOR_TO
58669: IFFALSE 58707
// if array1 [ i ] <> array2 [ i ] then
58671: LD_VAR 0 1
58675: PUSH
58676: LD_VAR 0 4
58680: ARRAY
58681: PUSH
58682: LD_VAR 0 2
58686: PUSH
58687: LD_VAR 0 4
58691: ARRAY
58692: NONEQUAL
58693: IFFALSE 58705
// begin result := false ;
58695: LD_ADDR_VAR 0 3
58699: PUSH
58700: LD_INT 0
58702: ST_TO_ADDR
// break ;
58703: GO 58707
// end ;
58705: GO 58668
58707: POP
58708: POP
// end else
58709: GO 58719
// result := false ;
58711: LD_ADDR_VAR 0 3
58715: PUSH
58716: LD_INT 0
58718: ST_TO_ADDR
// end ;
58719: LD_VAR 0 3
58723: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
58724: LD_INT 0
58726: PPUSH
58727: PPUSH
58728: PPUSH
// pom := GetBase ( fac ) ;
58729: LD_ADDR_VAR 0 5
58733: PUSH
58734: LD_VAR 0 1
58738: PPUSH
58739: CALL_OW 274
58743: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
58744: LD_ADDR_VAR 0 4
58748: PUSH
58749: LD_VAR 0 2
58753: PUSH
58754: LD_INT 1
58756: ARRAY
58757: PPUSH
58758: LD_VAR 0 2
58762: PUSH
58763: LD_INT 2
58765: ARRAY
58766: PPUSH
58767: LD_VAR 0 2
58771: PUSH
58772: LD_INT 3
58774: ARRAY
58775: PPUSH
58776: LD_VAR 0 2
58780: PUSH
58781: LD_INT 4
58783: ARRAY
58784: PPUSH
58785: CALL_OW 449
58789: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58790: LD_ADDR_VAR 0 3
58794: PUSH
58795: LD_VAR 0 5
58799: PPUSH
58800: LD_INT 1
58802: PPUSH
58803: CALL_OW 275
58807: PUSH
58808: LD_VAR 0 4
58812: PUSH
58813: LD_INT 1
58815: ARRAY
58816: GREATEREQUAL
58817: PUSH
58818: LD_VAR 0 5
58822: PPUSH
58823: LD_INT 2
58825: PPUSH
58826: CALL_OW 275
58830: PUSH
58831: LD_VAR 0 4
58835: PUSH
58836: LD_INT 2
58838: ARRAY
58839: GREATEREQUAL
58840: AND
58841: PUSH
58842: LD_VAR 0 5
58846: PPUSH
58847: LD_INT 3
58849: PPUSH
58850: CALL_OW 275
58854: PUSH
58855: LD_VAR 0 4
58859: PUSH
58860: LD_INT 3
58862: ARRAY
58863: GREATEREQUAL
58864: AND
58865: ST_TO_ADDR
// end ;
58866: LD_VAR 0 3
58870: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
58871: LD_INT 0
58873: PPUSH
58874: PPUSH
58875: PPUSH
58876: PPUSH
// pom := GetBase ( building ) ;
58877: LD_ADDR_VAR 0 3
58881: PUSH
58882: LD_VAR 0 1
58886: PPUSH
58887: CALL_OW 274
58891: ST_TO_ADDR
// if not pom then
58892: LD_VAR 0 3
58896: NOT
58897: IFFALSE 58901
// exit ;
58899: GO 59071
// btype := GetBType ( building ) ;
58901: LD_ADDR_VAR 0 5
58905: PUSH
58906: LD_VAR 0 1
58910: PPUSH
58911: CALL_OW 266
58915: ST_TO_ADDR
// if btype = b_armoury then
58916: LD_VAR 0 5
58920: PUSH
58921: LD_INT 4
58923: EQUAL
58924: IFFALSE 58934
// btype := b_barracks ;
58926: LD_ADDR_VAR 0 5
58930: PUSH
58931: LD_INT 5
58933: ST_TO_ADDR
// if btype = b_depot then
58934: LD_VAR 0 5
58938: PUSH
58939: LD_INT 0
58941: EQUAL
58942: IFFALSE 58952
// btype := b_warehouse ;
58944: LD_ADDR_VAR 0 5
58948: PUSH
58949: LD_INT 1
58951: ST_TO_ADDR
// if btype = b_workshop then
58952: LD_VAR 0 5
58956: PUSH
58957: LD_INT 2
58959: EQUAL
58960: IFFALSE 58970
// btype := b_factory ;
58962: LD_ADDR_VAR 0 5
58966: PUSH
58967: LD_INT 3
58969: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58970: LD_ADDR_VAR 0 4
58974: PUSH
58975: LD_VAR 0 5
58979: PPUSH
58980: LD_VAR 0 1
58984: PPUSH
58985: CALL_OW 248
58989: PPUSH
58990: CALL_OW 450
58994: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58995: LD_ADDR_VAR 0 2
58999: PUSH
59000: LD_VAR 0 3
59004: PPUSH
59005: LD_INT 1
59007: PPUSH
59008: CALL_OW 275
59012: PUSH
59013: LD_VAR 0 4
59017: PUSH
59018: LD_INT 1
59020: ARRAY
59021: GREATEREQUAL
59022: PUSH
59023: LD_VAR 0 3
59027: PPUSH
59028: LD_INT 2
59030: PPUSH
59031: CALL_OW 275
59035: PUSH
59036: LD_VAR 0 4
59040: PUSH
59041: LD_INT 2
59043: ARRAY
59044: GREATEREQUAL
59045: AND
59046: PUSH
59047: LD_VAR 0 3
59051: PPUSH
59052: LD_INT 3
59054: PPUSH
59055: CALL_OW 275
59059: PUSH
59060: LD_VAR 0 4
59064: PUSH
59065: LD_INT 3
59067: ARRAY
59068: GREATEREQUAL
59069: AND
59070: ST_TO_ADDR
// end ;
59071: LD_VAR 0 2
59075: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59076: LD_INT 0
59078: PPUSH
59079: PPUSH
59080: PPUSH
// pom := GetBase ( building ) ;
59081: LD_ADDR_VAR 0 4
59085: PUSH
59086: LD_VAR 0 1
59090: PPUSH
59091: CALL_OW 274
59095: ST_TO_ADDR
// if not pom then
59096: LD_VAR 0 4
59100: NOT
59101: IFFALSE 59105
// exit ;
59103: GO 59206
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59105: LD_ADDR_VAR 0 5
59109: PUSH
59110: LD_VAR 0 2
59114: PPUSH
59115: LD_VAR 0 1
59119: PPUSH
59120: CALL_OW 248
59124: PPUSH
59125: CALL_OW 450
59129: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59130: LD_ADDR_VAR 0 3
59134: PUSH
59135: LD_VAR 0 4
59139: PPUSH
59140: LD_INT 1
59142: PPUSH
59143: CALL_OW 275
59147: PUSH
59148: LD_VAR 0 5
59152: PUSH
59153: LD_INT 1
59155: ARRAY
59156: GREATEREQUAL
59157: PUSH
59158: LD_VAR 0 4
59162: PPUSH
59163: LD_INT 2
59165: PPUSH
59166: CALL_OW 275
59170: PUSH
59171: LD_VAR 0 5
59175: PUSH
59176: LD_INT 2
59178: ARRAY
59179: GREATEREQUAL
59180: AND
59181: PUSH
59182: LD_VAR 0 4
59186: PPUSH
59187: LD_INT 3
59189: PPUSH
59190: CALL_OW 275
59194: PUSH
59195: LD_VAR 0 5
59199: PUSH
59200: LD_INT 3
59202: ARRAY
59203: GREATEREQUAL
59204: AND
59205: ST_TO_ADDR
// end ;
59206: LD_VAR 0 3
59210: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59211: LD_INT 0
59213: PPUSH
59214: PPUSH
59215: PPUSH
59216: PPUSH
59217: PPUSH
59218: PPUSH
59219: PPUSH
59220: PPUSH
59221: PPUSH
59222: PPUSH
// result := false ;
59223: LD_ADDR_VAR 0 6
59227: PUSH
59228: LD_INT 0
59230: ST_TO_ADDR
// if not base or not btype or not x or not y then
59231: LD_VAR 0 1
59235: NOT
59236: PUSH
59237: LD_VAR 0 2
59241: NOT
59242: OR
59243: PUSH
59244: LD_VAR 0 3
59248: NOT
59249: OR
59250: PUSH
59251: LD_VAR 0 4
59255: NOT
59256: OR
59257: IFFALSE 59261
// exit ;
59259: GO 59870
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59261: LD_ADDR_VAR 0 12
59265: PUSH
59266: LD_VAR 0 2
59270: PPUSH
59271: LD_VAR 0 3
59275: PPUSH
59276: LD_VAR 0 4
59280: PPUSH
59281: LD_VAR 0 5
59285: PPUSH
59286: LD_VAR 0 1
59290: PUSH
59291: LD_INT 1
59293: ARRAY
59294: PPUSH
59295: CALL_OW 248
59299: PPUSH
59300: LD_INT 0
59302: PPUSH
59303: CALL 60707 0 6
59307: ST_TO_ADDR
// if not hexes then
59308: LD_VAR 0 12
59312: NOT
59313: IFFALSE 59317
// exit ;
59315: GO 59870
// for i = 1 to hexes do
59317: LD_ADDR_VAR 0 7
59321: PUSH
59322: DOUBLE
59323: LD_INT 1
59325: DEC
59326: ST_TO_ADDR
59327: LD_VAR 0 12
59331: PUSH
59332: FOR_TO
59333: IFFALSE 59868
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59335: LD_ADDR_VAR 0 11
59339: PUSH
59340: LD_VAR 0 12
59344: PUSH
59345: LD_VAR 0 7
59349: ARRAY
59350: PUSH
59351: LD_INT 1
59353: ARRAY
59354: PPUSH
59355: LD_VAR 0 12
59359: PUSH
59360: LD_VAR 0 7
59364: ARRAY
59365: PUSH
59366: LD_INT 2
59368: ARRAY
59369: PPUSH
59370: CALL_OW 428
59374: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59375: LD_VAR 0 12
59379: PUSH
59380: LD_VAR 0 7
59384: ARRAY
59385: PUSH
59386: LD_INT 1
59388: ARRAY
59389: PPUSH
59390: LD_VAR 0 12
59394: PUSH
59395: LD_VAR 0 7
59399: ARRAY
59400: PUSH
59401: LD_INT 2
59403: ARRAY
59404: PPUSH
59405: CALL_OW 351
59409: PUSH
59410: LD_VAR 0 12
59414: PUSH
59415: LD_VAR 0 7
59419: ARRAY
59420: PUSH
59421: LD_INT 1
59423: ARRAY
59424: PPUSH
59425: LD_VAR 0 12
59429: PUSH
59430: LD_VAR 0 7
59434: ARRAY
59435: PUSH
59436: LD_INT 2
59438: ARRAY
59439: PPUSH
59440: CALL_OW 488
59444: NOT
59445: OR
59446: PUSH
59447: LD_VAR 0 11
59451: PPUSH
59452: CALL_OW 247
59456: PUSH
59457: LD_INT 3
59459: EQUAL
59460: OR
59461: IFFALSE 59467
// exit ;
59463: POP
59464: POP
59465: GO 59870
// if not tmp or not tmp in base then
59467: LD_VAR 0 11
59471: NOT
59472: PUSH
59473: LD_VAR 0 11
59477: PUSH
59478: LD_VAR 0 1
59482: IN
59483: NOT
59484: OR
59485: IFFALSE 59489
// continue ;
59487: GO 59332
// result := true ;
59489: LD_ADDR_VAR 0 6
59493: PUSH
59494: LD_INT 1
59496: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59497: LD_ADDR_VAR 0 15
59501: PUSH
59502: LD_VAR 0 1
59506: PPUSH
59507: LD_INT 22
59509: PUSH
59510: LD_VAR 0 11
59514: PPUSH
59515: CALL_OW 255
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 2
59526: PUSH
59527: LD_INT 30
59529: PUSH
59530: LD_INT 0
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: PUSH
59537: LD_INT 30
59539: PUSH
59540: LD_INT 1
59542: PUSH
59543: EMPTY
59544: LIST
59545: LIST
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: LIST
59551: PUSH
59552: EMPTY
59553: LIST
59554: LIST
59555: PPUSH
59556: CALL_OW 72
59560: ST_TO_ADDR
// if dep then
59561: LD_VAR 0 15
59565: IFFALSE 59701
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59567: LD_ADDR_VAR 0 14
59571: PUSH
59572: LD_VAR 0 15
59576: PUSH
59577: LD_INT 1
59579: ARRAY
59580: PPUSH
59581: CALL_OW 250
59585: PPUSH
59586: LD_VAR 0 15
59590: PUSH
59591: LD_INT 1
59593: ARRAY
59594: PPUSH
59595: CALL_OW 254
59599: PPUSH
59600: LD_INT 5
59602: PPUSH
59603: CALL_OW 272
59607: PUSH
59608: LD_VAR 0 15
59612: PUSH
59613: LD_INT 1
59615: ARRAY
59616: PPUSH
59617: CALL_OW 251
59621: PPUSH
59622: LD_VAR 0 15
59626: PUSH
59627: LD_INT 1
59629: ARRAY
59630: PPUSH
59631: CALL_OW 254
59635: PPUSH
59636: LD_INT 5
59638: PPUSH
59639: CALL_OW 273
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
59648: LD_VAR 0 14
59652: PUSH
59653: LD_INT 1
59655: ARRAY
59656: PPUSH
59657: LD_VAR 0 14
59661: PUSH
59662: LD_INT 2
59664: ARRAY
59665: PPUSH
59666: CALL_OW 488
59670: IFFALSE 59701
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
59672: LD_VAR 0 11
59676: PPUSH
59677: LD_VAR 0 14
59681: PUSH
59682: LD_INT 1
59684: ARRAY
59685: PPUSH
59686: LD_VAR 0 14
59690: PUSH
59691: LD_INT 2
59693: ARRAY
59694: PPUSH
59695: CALL_OW 111
// continue ;
59699: GO 59332
// end ; end ; r := GetDir ( tmp ) ;
59701: LD_ADDR_VAR 0 13
59705: PUSH
59706: LD_VAR 0 11
59710: PPUSH
59711: CALL_OW 254
59715: ST_TO_ADDR
// if r = 5 then
59716: LD_VAR 0 13
59720: PUSH
59721: LD_INT 5
59723: EQUAL
59724: IFFALSE 59734
// r := 0 ;
59726: LD_ADDR_VAR 0 13
59730: PUSH
59731: LD_INT 0
59733: ST_TO_ADDR
// for j = r to 5 do
59734: LD_ADDR_VAR 0 8
59738: PUSH
59739: DOUBLE
59740: LD_VAR 0 13
59744: DEC
59745: ST_TO_ADDR
59746: LD_INT 5
59748: PUSH
59749: FOR_TO
59750: IFFALSE 59864
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
59752: LD_ADDR_VAR 0 9
59756: PUSH
59757: LD_VAR 0 11
59761: PPUSH
59762: CALL_OW 250
59766: PPUSH
59767: LD_VAR 0 8
59771: PPUSH
59772: LD_INT 2
59774: PPUSH
59775: CALL_OW 272
59779: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
59780: LD_ADDR_VAR 0 10
59784: PUSH
59785: LD_VAR 0 11
59789: PPUSH
59790: CALL_OW 251
59794: PPUSH
59795: LD_VAR 0 8
59799: PPUSH
59800: LD_INT 2
59802: PPUSH
59803: CALL_OW 273
59807: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
59808: LD_VAR 0 9
59812: PPUSH
59813: LD_VAR 0 10
59817: PPUSH
59818: CALL_OW 488
59822: PUSH
59823: LD_VAR 0 9
59827: PPUSH
59828: LD_VAR 0 10
59832: PPUSH
59833: CALL_OW 428
59837: NOT
59838: AND
59839: IFFALSE 59862
// begin ComMoveXY ( tmp , _x , _y ) ;
59841: LD_VAR 0 11
59845: PPUSH
59846: LD_VAR 0 9
59850: PPUSH
59851: LD_VAR 0 10
59855: PPUSH
59856: CALL_OW 111
// break ;
59860: GO 59864
// end ; end ;
59862: GO 59749
59864: POP
59865: POP
// end ;
59866: GO 59332
59868: POP
59869: POP
// end ;
59870: LD_VAR 0 6
59874: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
59875: LD_INT 0
59877: PPUSH
59878: PPUSH
59879: PPUSH
59880: PPUSH
59881: PPUSH
59882: PPUSH
59883: PPUSH
59884: PPUSH
59885: PPUSH
59886: PPUSH
// result := false ;
59887: LD_ADDR_VAR 0 6
59891: PUSH
59892: LD_INT 0
59894: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
59895: LD_VAR 0 1
59899: NOT
59900: PUSH
59901: LD_VAR 0 1
59905: PPUSH
59906: CALL_OW 266
59910: PUSH
59911: LD_INT 0
59913: PUSH
59914: LD_INT 1
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: IN
59921: NOT
59922: OR
59923: PUSH
59924: LD_VAR 0 2
59928: NOT
59929: OR
59930: PUSH
59931: LD_VAR 0 5
59935: PUSH
59936: LD_INT 0
59938: PUSH
59939: LD_INT 1
59941: PUSH
59942: LD_INT 2
59944: PUSH
59945: LD_INT 3
59947: PUSH
59948: LD_INT 4
59950: PUSH
59951: LD_INT 5
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: LIST
59958: LIST
59959: LIST
59960: LIST
59961: IN
59962: NOT
59963: OR
59964: PUSH
59965: LD_VAR 0 3
59969: PPUSH
59970: LD_VAR 0 4
59974: PPUSH
59975: CALL_OW 488
59979: NOT
59980: OR
59981: IFFALSE 59985
// exit ;
59983: GO 60702
// pom := GetBase ( depot ) ;
59985: LD_ADDR_VAR 0 10
59989: PUSH
59990: LD_VAR 0 1
59994: PPUSH
59995: CALL_OW 274
59999: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
60000: LD_ADDR_VAR 0 11
60004: PUSH
60005: LD_VAR 0 2
60009: PPUSH
60010: LD_VAR 0 1
60014: PPUSH
60015: CALL_OW 248
60019: PPUSH
60020: CALL_OW 450
60024: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
60025: LD_VAR 0 10
60029: PPUSH
60030: LD_INT 1
60032: PPUSH
60033: CALL_OW 275
60037: PUSH
60038: LD_VAR 0 11
60042: PUSH
60043: LD_INT 1
60045: ARRAY
60046: GREATEREQUAL
60047: PUSH
60048: LD_VAR 0 10
60052: PPUSH
60053: LD_INT 2
60055: PPUSH
60056: CALL_OW 275
60060: PUSH
60061: LD_VAR 0 11
60065: PUSH
60066: LD_INT 2
60068: ARRAY
60069: GREATEREQUAL
60070: AND
60071: PUSH
60072: LD_VAR 0 10
60076: PPUSH
60077: LD_INT 3
60079: PPUSH
60080: CALL_OW 275
60084: PUSH
60085: LD_VAR 0 11
60089: PUSH
60090: LD_INT 3
60092: ARRAY
60093: GREATEREQUAL
60094: AND
60095: NOT
60096: IFFALSE 60100
// exit ;
60098: GO 60702
// if GetBType ( depot ) = b_depot then
60100: LD_VAR 0 1
60104: PPUSH
60105: CALL_OW 266
60109: PUSH
60110: LD_INT 0
60112: EQUAL
60113: IFFALSE 60125
// dist := 28 else
60115: LD_ADDR_VAR 0 14
60119: PUSH
60120: LD_INT 28
60122: ST_TO_ADDR
60123: GO 60133
// dist := 36 ;
60125: LD_ADDR_VAR 0 14
60129: PUSH
60130: LD_INT 36
60132: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60133: LD_VAR 0 1
60137: PPUSH
60138: LD_VAR 0 3
60142: PPUSH
60143: LD_VAR 0 4
60147: PPUSH
60148: CALL_OW 297
60152: PUSH
60153: LD_VAR 0 14
60157: GREATER
60158: IFFALSE 60162
// exit ;
60160: GO 60702
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60162: LD_ADDR_VAR 0 12
60166: PUSH
60167: LD_VAR 0 2
60171: PPUSH
60172: LD_VAR 0 3
60176: PPUSH
60177: LD_VAR 0 4
60181: PPUSH
60182: LD_VAR 0 5
60186: PPUSH
60187: LD_VAR 0 1
60191: PPUSH
60192: CALL_OW 248
60196: PPUSH
60197: LD_INT 0
60199: PPUSH
60200: CALL 60707 0 6
60204: ST_TO_ADDR
// if not hexes then
60205: LD_VAR 0 12
60209: NOT
60210: IFFALSE 60214
// exit ;
60212: GO 60702
// hex := GetHexInfo ( x , y ) ;
60214: LD_ADDR_VAR 0 15
60218: PUSH
60219: LD_VAR 0 3
60223: PPUSH
60224: LD_VAR 0 4
60228: PPUSH
60229: CALL_OW 546
60233: ST_TO_ADDR
// if hex [ 1 ] then
60234: LD_VAR 0 15
60238: PUSH
60239: LD_INT 1
60241: ARRAY
60242: IFFALSE 60246
// exit ;
60244: GO 60702
// height := hex [ 2 ] ;
60246: LD_ADDR_VAR 0 13
60250: PUSH
60251: LD_VAR 0 15
60255: PUSH
60256: LD_INT 2
60258: ARRAY
60259: ST_TO_ADDR
// for i = 1 to hexes do
60260: LD_ADDR_VAR 0 7
60264: PUSH
60265: DOUBLE
60266: LD_INT 1
60268: DEC
60269: ST_TO_ADDR
60270: LD_VAR 0 12
60274: PUSH
60275: FOR_TO
60276: IFFALSE 60606
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60278: LD_VAR 0 12
60282: PUSH
60283: LD_VAR 0 7
60287: ARRAY
60288: PUSH
60289: LD_INT 1
60291: ARRAY
60292: PPUSH
60293: LD_VAR 0 12
60297: PUSH
60298: LD_VAR 0 7
60302: ARRAY
60303: PUSH
60304: LD_INT 2
60306: ARRAY
60307: PPUSH
60308: CALL_OW 488
60312: NOT
60313: PUSH
60314: LD_VAR 0 12
60318: PUSH
60319: LD_VAR 0 7
60323: ARRAY
60324: PUSH
60325: LD_INT 1
60327: ARRAY
60328: PPUSH
60329: LD_VAR 0 12
60333: PUSH
60334: LD_VAR 0 7
60338: ARRAY
60339: PUSH
60340: LD_INT 2
60342: ARRAY
60343: PPUSH
60344: CALL_OW 428
60348: PUSH
60349: LD_INT 0
60351: GREATER
60352: OR
60353: PUSH
60354: LD_VAR 0 12
60358: PUSH
60359: LD_VAR 0 7
60363: ARRAY
60364: PUSH
60365: LD_INT 1
60367: ARRAY
60368: PPUSH
60369: LD_VAR 0 12
60373: PUSH
60374: LD_VAR 0 7
60378: ARRAY
60379: PUSH
60380: LD_INT 2
60382: ARRAY
60383: PPUSH
60384: CALL_OW 351
60388: OR
60389: IFFALSE 60395
// exit ;
60391: POP
60392: POP
60393: GO 60702
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60395: LD_ADDR_VAR 0 8
60399: PUSH
60400: LD_VAR 0 12
60404: PUSH
60405: LD_VAR 0 7
60409: ARRAY
60410: PUSH
60411: LD_INT 1
60413: ARRAY
60414: PPUSH
60415: LD_VAR 0 12
60419: PUSH
60420: LD_VAR 0 7
60424: ARRAY
60425: PUSH
60426: LD_INT 2
60428: ARRAY
60429: PPUSH
60430: CALL_OW 546
60434: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60435: LD_VAR 0 8
60439: PUSH
60440: LD_INT 1
60442: ARRAY
60443: PUSH
60444: LD_VAR 0 8
60448: PUSH
60449: LD_INT 2
60451: ARRAY
60452: PUSH
60453: LD_VAR 0 13
60457: PUSH
60458: LD_INT 2
60460: PLUS
60461: GREATER
60462: OR
60463: PUSH
60464: LD_VAR 0 8
60468: PUSH
60469: LD_INT 2
60471: ARRAY
60472: PUSH
60473: LD_VAR 0 13
60477: PUSH
60478: LD_INT 2
60480: MINUS
60481: LESS
60482: OR
60483: PUSH
60484: LD_VAR 0 8
60488: PUSH
60489: LD_INT 3
60491: ARRAY
60492: PUSH
60493: LD_INT 0
60495: PUSH
60496: LD_INT 8
60498: PUSH
60499: LD_INT 9
60501: PUSH
60502: LD_INT 10
60504: PUSH
60505: LD_INT 11
60507: PUSH
60508: LD_INT 12
60510: PUSH
60511: LD_INT 13
60513: PUSH
60514: LD_INT 16
60516: PUSH
60517: LD_INT 17
60519: PUSH
60520: LD_INT 18
60522: PUSH
60523: LD_INT 19
60525: PUSH
60526: LD_INT 20
60528: PUSH
60529: LD_INT 21
60531: PUSH
60532: EMPTY
60533: LIST
60534: LIST
60535: LIST
60536: LIST
60537: LIST
60538: LIST
60539: LIST
60540: LIST
60541: LIST
60542: LIST
60543: LIST
60544: LIST
60545: LIST
60546: IN
60547: NOT
60548: OR
60549: PUSH
60550: LD_VAR 0 8
60554: PUSH
60555: LD_INT 5
60557: ARRAY
60558: NOT
60559: OR
60560: PUSH
60561: LD_VAR 0 8
60565: PUSH
60566: LD_INT 6
60568: ARRAY
60569: PUSH
60570: LD_INT 1
60572: PUSH
60573: LD_INT 2
60575: PUSH
60576: LD_INT 7
60578: PUSH
60579: LD_INT 9
60581: PUSH
60582: LD_INT 10
60584: PUSH
60585: LD_INT 11
60587: PUSH
60588: EMPTY
60589: LIST
60590: LIST
60591: LIST
60592: LIST
60593: LIST
60594: LIST
60595: IN
60596: NOT
60597: OR
60598: IFFALSE 60604
// exit ;
60600: POP
60601: POP
60602: GO 60702
// end ;
60604: GO 60275
60606: POP
60607: POP
// side := GetSide ( depot ) ;
60608: LD_ADDR_VAR 0 9
60612: PUSH
60613: LD_VAR 0 1
60617: PPUSH
60618: CALL_OW 255
60622: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60623: LD_VAR 0 9
60627: PPUSH
60628: LD_VAR 0 3
60632: PPUSH
60633: LD_VAR 0 4
60637: PPUSH
60638: LD_INT 20
60640: PPUSH
60641: CALL 53356 0 4
60645: PUSH
60646: LD_INT 4
60648: ARRAY
60649: IFFALSE 60653
// exit ;
60651: GO 60702
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
60653: LD_VAR 0 2
60657: PUSH
60658: LD_INT 29
60660: PUSH
60661: LD_INT 30
60663: PUSH
60664: EMPTY
60665: LIST
60666: LIST
60667: IN
60668: PUSH
60669: LD_VAR 0 3
60673: PPUSH
60674: LD_VAR 0 4
60678: PPUSH
60679: LD_VAR 0 9
60683: PPUSH
60684: CALL_OW 440
60688: NOT
60689: AND
60690: IFFALSE 60694
// exit ;
60692: GO 60702
// result := true ;
60694: LD_ADDR_VAR 0 6
60698: PUSH
60699: LD_INT 1
60701: ST_TO_ADDR
// end ;
60702: LD_VAR 0 6
60706: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
60707: LD_INT 0
60709: PPUSH
60710: PPUSH
60711: PPUSH
60712: PPUSH
60713: PPUSH
60714: PPUSH
60715: PPUSH
60716: PPUSH
60717: PPUSH
60718: PPUSH
60719: PPUSH
60720: PPUSH
60721: PPUSH
60722: PPUSH
60723: PPUSH
60724: PPUSH
60725: PPUSH
60726: PPUSH
60727: PPUSH
60728: PPUSH
60729: PPUSH
60730: PPUSH
60731: PPUSH
60732: PPUSH
60733: PPUSH
60734: PPUSH
60735: PPUSH
60736: PPUSH
60737: PPUSH
60738: PPUSH
60739: PPUSH
60740: PPUSH
60741: PPUSH
60742: PPUSH
60743: PPUSH
60744: PPUSH
60745: PPUSH
60746: PPUSH
60747: PPUSH
60748: PPUSH
60749: PPUSH
60750: PPUSH
60751: PPUSH
60752: PPUSH
60753: PPUSH
60754: PPUSH
60755: PPUSH
60756: PPUSH
60757: PPUSH
60758: PPUSH
60759: PPUSH
60760: PPUSH
60761: PPUSH
60762: PPUSH
60763: PPUSH
60764: PPUSH
60765: PPUSH
60766: PPUSH
// result = [ ] ;
60767: LD_ADDR_VAR 0 7
60771: PUSH
60772: EMPTY
60773: ST_TO_ADDR
// temp_list = [ ] ;
60774: LD_ADDR_VAR 0 9
60778: PUSH
60779: EMPTY
60780: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
60781: LD_VAR 0 4
60785: PUSH
60786: LD_INT 0
60788: PUSH
60789: LD_INT 1
60791: PUSH
60792: LD_INT 2
60794: PUSH
60795: LD_INT 3
60797: PUSH
60798: LD_INT 4
60800: PUSH
60801: LD_INT 5
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: LIST
60808: LIST
60809: LIST
60810: LIST
60811: IN
60812: NOT
60813: PUSH
60814: LD_VAR 0 1
60818: PUSH
60819: LD_INT 0
60821: PUSH
60822: LD_INT 1
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: IN
60829: PUSH
60830: LD_VAR 0 5
60834: PUSH
60835: LD_INT 1
60837: PUSH
60838: LD_INT 2
60840: PUSH
60841: LD_INT 3
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: LIST
60848: IN
60849: NOT
60850: AND
60851: OR
60852: IFFALSE 60856
// exit ;
60854: GO 79247
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
60856: LD_VAR 0 1
60860: PUSH
60861: LD_INT 6
60863: PUSH
60864: LD_INT 7
60866: PUSH
60867: LD_INT 8
60869: PUSH
60870: LD_INT 13
60872: PUSH
60873: LD_INT 12
60875: PUSH
60876: LD_INT 15
60878: PUSH
60879: LD_INT 11
60881: PUSH
60882: LD_INT 14
60884: PUSH
60885: LD_INT 10
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: LIST
60892: LIST
60893: LIST
60894: LIST
60895: LIST
60896: LIST
60897: LIST
60898: IN
60899: IFFALSE 60909
// btype = b_lab ;
60901: LD_ADDR_VAR 0 1
60905: PUSH
60906: LD_INT 6
60908: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
60909: LD_VAR 0 6
60913: PUSH
60914: LD_INT 0
60916: PUSH
60917: LD_INT 1
60919: PUSH
60920: LD_INT 2
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: LIST
60927: IN
60928: NOT
60929: PUSH
60930: LD_VAR 0 1
60934: PUSH
60935: LD_INT 0
60937: PUSH
60938: LD_INT 1
60940: PUSH
60941: LD_INT 2
60943: PUSH
60944: LD_INT 3
60946: PUSH
60947: LD_INT 6
60949: PUSH
60950: LD_INT 36
60952: PUSH
60953: LD_INT 4
60955: PUSH
60956: LD_INT 5
60958: PUSH
60959: LD_INT 31
60961: PUSH
60962: LD_INT 32
60964: PUSH
60965: LD_INT 33
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: LIST
60972: LIST
60973: LIST
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: LIST
60979: LIST
60980: IN
60981: NOT
60982: PUSH
60983: LD_VAR 0 6
60987: PUSH
60988: LD_INT 1
60990: EQUAL
60991: AND
60992: OR
60993: PUSH
60994: LD_VAR 0 1
60998: PUSH
60999: LD_INT 2
61001: PUSH
61002: LD_INT 3
61004: PUSH
61005: EMPTY
61006: LIST
61007: LIST
61008: IN
61009: NOT
61010: PUSH
61011: LD_VAR 0 6
61015: PUSH
61016: LD_INT 2
61018: EQUAL
61019: AND
61020: OR
61021: IFFALSE 61031
// mode = 0 ;
61023: LD_ADDR_VAR 0 6
61027: PUSH
61028: LD_INT 0
61030: ST_TO_ADDR
// case mode of 0 :
61031: LD_VAR 0 6
61035: PUSH
61036: LD_INT 0
61038: DOUBLE
61039: EQUAL
61040: IFTRUE 61044
61042: GO 72497
61044: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
61045: LD_ADDR_VAR 0 11
61049: PUSH
61050: LD_INT 0
61052: PUSH
61053: LD_INT 0
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: PUSH
61060: LD_INT 0
61062: PUSH
61063: LD_INT 1
61065: NEG
61066: PUSH
61067: EMPTY
61068: LIST
61069: LIST
61070: PUSH
61071: LD_INT 1
61073: PUSH
61074: LD_INT 0
61076: PUSH
61077: EMPTY
61078: LIST
61079: LIST
61080: PUSH
61081: LD_INT 1
61083: PUSH
61084: LD_INT 1
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PUSH
61091: LD_INT 0
61093: PUSH
61094: LD_INT 1
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: PUSH
61101: LD_INT 1
61103: NEG
61104: PUSH
61105: LD_INT 0
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: PUSH
61112: LD_INT 1
61114: NEG
61115: PUSH
61116: LD_INT 1
61118: NEG
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 1
61126: NEG
61127: PUSH
61128: LD_INT 2
61130: NEG
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 0
61138: PUSH
61139: LD_INT 2
61141: NEG
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: PUSH
61147: LD_INT 1
61149: PUSH
61150: LD_INT 1
61152: NEG
61153: PUSH
61154: EMPTY
61155: LIST
61156: LIST
61157: PUSH
61158: LD_INT 1
61160: PUSH
61161: LD_INT 2
61163: PUSH
61164: EMPTY
61165: LIST
61166: LIST
61167: PUSH
61168: LD_INT 0
61170: PUSH
61171: LD_INT 2
61173: PUSH
61174: EMPTY
61175: LIST
61176: LIST
61177: PUSH
61178: LD_INT 1
61180: NEG
61181: PUSH
61182: LD_INT 1
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PUSH
61189: LD_INT 1
61191: PUSH
61192: LD_INT 3
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: PUSH
61199: LD_INT 0
61201: PUSH
61202: LD_INT 3
61204: PUSH
61205: EMPTY
61206: LIST
61207: LIST
61208: PUSH
61209: LD_INT 1
61211: NEG
61212: PUSH
61213: LD_INT 2
61215: PUSH
61216: EMPTY
61217: LIST
61218: LIST
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61238: LD_ADDR_VAR 0 12
61242: PUSH
61243: LD_INT 0
61245: PUSH
61246: LD_INT 0
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 0
61255: PUSH
61256: LD_INT 1
61258: NEG
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 1
61266: PUSH
61267: LD_INT 0
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: LD_INT 1
61276: PUSH
61277: LD_INT 1
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: LD_INT 0
61286: PUSH
61287: LD_INT 1
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PUSH
61294: LD_INT 1
61296: NEG
61297: PUSH
61298: LD_INT 0
61300: PUSH
61301: EMPTY
61302: LIST
61303: LIST
61304: PUSH
61305: LD_INT 1
61307: NEG
61308: PUSH
61309: LD_INT 1
61311: NEG
61312: PUSH
61313: EMPTY
61314: LIST
61315: LIST
61316: PUSH
61317: LD_INT 1
61319: PUSH
61320: LD_INT 1
61322: NEG
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PUSH
61328: LD_INT 2
61330: PUSH
61331: LD_INT 0
61333: PUSH
61334: EMPTY
61335: LIST
61336: LIST
61337: PUSH
61338: LD_INT 2
61340: PUSH
61341: LD_INT 1
61343: PUSH
61344: EMPTY
61345: LIST
61346: LIST
61347: PUSH
61348: LD_INT 1
61350: NEG
61351: PUSH
61352: LD_INT 1
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: PUSH
61359: LD_INT 2
61361: NEG
61362: PUSH
61363: LD_INT 0
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: LD_INT 2
61372: NEG
61373: PUSH
61374: LD_INT 1
61376: NEG
61377: PUSH
61378: EMPTY
61379: LIST
61380: LIST
61381: PUSH
61382: LD_INT 2
61384: NEG
61385: PUSH
61386: LD_INT 1
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PUSH
61393: LD_INT 3
61395: NEG
61396: PUSH
61397: LD_INT 0
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 3
61406: NEG
61407: PUSH
61408: LD_INT 1
61410: NEG
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PUSH
61416: EMPTY
61417: LIST
61418: LIST
61419: LIST
61420: LIST
61421: LIST
61422: LIST
61423: LIST
61424: LIST
61425: LIST
61426: LIST
61427: LIST
61428: LIST
61429: LIST
61430: LIST
61431: LIST
61432: LIST
61433: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61434: LD_ADDR_VAR 0 13
61438: PUSH
61439: LD_INT 0
61441: PUSH
61442: LD_INT 0
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PUSH
61449: LD_INT 0
61451: PUSH
61452: LD_INT 1
61454: NEG
61455: PUSH
61456: EMPTY
61457: LIST
61458: LIST
61459: PUSH
61460: LD_INT 1
61462: PUSH
61463: LD_INT 0
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: PUSH
61470: LD_INT 1
61472: PUSH
61473: LD_INT 1
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 0
61482: PUSH
61483: LD_INT 1
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PUSH
61490: LD_INT 1
61492: NEG
61493: PUSH
61494: LD_INT 0
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 1
61503: NEG
61504: PUSH
61505: LD_INT 1
61507: NEG
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PUSH
61513: LD_INT 1
61515: NEG
61516: PUSH
61517: LD_INT 2
61519: NEG
61520: PUSH
61521: EMPTY
61522: LIST
61523: LIST
61524: PUSH
61525: LD_INT 2
61527: PUSH
61528: LD_INT 1
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: LD_INT 2
61537: PUSH
61538: LD_INT 2
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: LD_INT 1
61547: PUSH
61548: LD_INT 2
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: PUSH
61555: LD_INT 2
61557: NEG
61558: PUSH
61559: LD_INT 1
61561: NEG
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PUSH
61567: LD_INT 2
61569: NEG
61570: PUSH
61571: LD_INT 2
61573: NEG
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: LD_INT 2
61581: NEG
61582: PUSH
61583: LD_INT 3
61585: NEG
61586: PUSH
61587: EMPTY
61588: LIST
61589: LIST
61590: PUSH
61591: LD_INT 3
61593: NEG
61594: PUSH
61595: LD_INT 2
61597: NEG
61598: PUSH
61599: EMPTY
61600: LIST
61601: LIST
61602: PUSH
61603: LD_INT 3
61605: NEG
61606: PUSH
61607: LD_INT 3
61609: NEG
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: LIST
61619: LIST
61620: LIST
61621: LIST
61622: LIST
61623: LIST
61624: LIST
61625: LIST
61626: LIST
61627: LIST
61628: LIST
61629: LIST
61630: LIST
61631: LIST
61632: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61633: LD_ADDR_VAR 0 14
61637: PUSH
61638: LD_INT 0
61640: PUSH
61641: LD_INT 0
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: PUSH
61648: LD_INT 0
61650: PUSH
61651: LD_INT 1
61653: NEG
61654: PUSH
61655: EMPTY
61656: LIST
61657: LIST
61658: PUSH
61659: LD_INT 1
61661: PUSH
61662: LD_INT 0
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: PUSH
61669: LD_INT 1
61671: PUSH
61672: LD_INT 1
61674: PUSH
61675: EMPTY
61676: LIST
61677: LIST
61678: PUSH
61679: LD_INT 0
61681: PUSH
61682: LD_INT 1
61684: PUSH
61685: EMPTY
61686: LIST
61687: LIST
61688: PUSH
61689: LD_INT 1
61691: NEG
61692: PUSH
61693: LD_INT 0
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: LD_INT 1
61702: NEG
61703: PUSH
61704: LD_INT 1
61706: NEG
61707: PUSH
61708: EMPTY
61709: LIST
61710: LIST
61711: PUSH
61712: LD_INT 1
61714: NEG
61715: PUSH
61716: LD_INT 2
61718: NEG
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: PUSH
61724: LD_INT 0
61726: PUSH
61727: LD_INT 2
61729: NEG
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PUSH
61735: LD_INT 1
61737: PUSH
61738: LD_INT 1
61740: NEG
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 1
61748: PUSH
61749: LD_INT 2
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PUSH
61756: LD_INT 0
61758: PUSH
61759: LD_INT 2
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: PUSH
61766: LD_INT 1
61768: NEG
61769: PUSH
61770: LD_INT 1
61772: PUSH
61773: EMPTY
61774: LIST
61775: LIST
61776: PUSH
61777: LD_INT 1
61779: NEG
61780: PUSH
61781: LD_INT 3
61783: NEG
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: PUSH
61789: LD_INT 0
61791: PUSH
61792: LD_INT 3
61794: NEG
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PUSH
61800: LD_INT 1
61802: PUSH
61803: LD_INT 2
61805: NEG
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: LIST
61815: LIST
61816: LIST
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: LIST
61827: LIST
61828: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
61829: LD_ADDR_VAR 0 15
61833: PUSH
61834: LD_INT 0
61836: PUSH
61837: LD_INT 0
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: LD_INT 0
61846: PUSH
61847: LD_INT 1
61849: NEG
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 1
61857: PUSH
61858: LD_INT 0
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: PUSH
61865: LD_INT 1
61867: PUSH
61868: LD_INT 1
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: LD_INT 0
61877: PUSH
61878: LD_INT 1
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: PUSH
61885: LD_INT 1
61887: NEG
61888: PUSH
61889: LD_INT 0
61891: PUSH
61892: EMPTY
61893: LIST
61894: LIST
61895: PUSH
61896: LD_INT 1
61898: NEG
61899: PUSH
61900: LD_INT 1
61902: NEG
61903: PUSH
61904: EMPTY
61905: LIST
61906: LIST
61907: PUSH
61908: LD_INT 1
61910: PUSH
61911: LD_INT 1
61913: NEG
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: LD_INT 2
61921: PUSH
61922: LD_INT 0
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: PUSH
61929: LD_INT 2
61931: PUSH
61932: LD_INT 1
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PUSH
61939: LD_INT 1
61941: NEG
61942: PUSH
61943: LD_INT 1
61945: PUSH
61946: EMPTY
61947: LIST
61948: LIST
61949: PUSH
61950: LD_INT 2
61952: NEG
61953: PUSH
61954: LD_INT 0
61956: PUSH
61957: EMPTY
61958: LIST
61959: LIST
61960: PUSH
61961: LD_INT 2
61963: NEG
61964: PUSH
61965: LD_INT 1
61967: NEG
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PUSH
61973: LD_INT 2
61975: PUSH
61976: LD_INT 1
61978: NEG
61979: PUSH
61980: EMPTY
61981: LIST
61982: LIST
61983: PUSH
61984: LD_INT 3
61986: PUSH
61987: LD_INT 0
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PUSH
61994: LD_INT 3
61996: PUSH
61997: LD_INT 1
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: LIST
62016: LIST
62017: LIST
62018: LIST
62019: LIST
62020: LIST
62021: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
62022: LD_ADDR_VAR 0 16
62026: PUSH
62027: LD_INT 0
62029: PUSH
62030: LD_INT 0
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: PUSH
62037: LD_INT 0
62039: PUSH
62040: LD_INT 1
62042: NEG
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 1
62050: PUSH
62051: LD_INT 0
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 1
62060: PUSH
62061: LD_INT 1
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: LD_INT 0
62070: PUSH
62071: LD_INT 1
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: PUSH
62078: LD_INT 1
62080: NEG
62081: PUSH
62082: LD_INT 0
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: LD_INT 1
62091: NEG
62092: PUSH
62093: LD_INT 1
62095: NEG
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: LD_INT 1
62103: NEG
62104: PUSH
62105: LD_INT 2
62107: NEG
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: PUSH
62113: LD_INT 2
62115: PUSH
62116: LD_INT 1
62118: PUSH
62119: EMPTY
62120: LIST
62121: LIST
62122: PUSH
62123: LD_INT 2
62125: PUSH
62126: LD_INT 2
62128: PUSH
62129: EMPTY
62130: LIST
62131: LIST
62132: PUSH
62133: LD_INT 1
62135: PUSH
62136: LD_INT 2
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PUSH
62143: LD_INT 2
62145: NEG
62146: PUSH
62147: LD_INT 1
62149: NEG
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: LD_INT 2
62157: NEG
62158: PUSH
62159: LD_INT 2
62161: NEG
62162: PUSH
62163: EMPTY
62164: LIST
62165: LIST
62166: PUSH
62167: LD_INT 3
62169: PUSH
62170: LD_INT 2
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PUSH
62177: LD_INT 3
62179: PUSH
62180: LD_INT 3
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 2
62189: PUSH
62190: LD_INT 3
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: LIST
62203: LIST
62204: LIST
62205: LIST
62206: LIST
62207: LIST
62208: LIST
62209: LIST
62210: LIST
62211: LIST
62212: LIST
62213: LIST
62214: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62215: LD_ADDR_VAR 0 17
62219: PUSH
62220: LD_INT 0
62222: PUSH
62223: LD_INT 0
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: PUSH
62230: LD_INT 0
62232: PUSH
62233: LD_INT 1
62235: NEG
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 1
62243: PUSH
62244: LD_INT 0
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: LD_INT 1
62253: PUSH
62254: LD_INT 1
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: PUSH
62261: LD_INT 0
62263: PUSH
62264: LD_INT 1
62266: PUSH
62267: EMPTY
62268: LIST
62269: LIST
62270: PUSH
62271: LD_INT 1
62273: NEG
62274: PUSH
62275: LD_INT 0
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 1
62284: NEG
62285: PUSH
62286: LD_INT 1
62288: NEG
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 1
62296: NEG
62297: PUSH
62298: LD_INT 2
62300: NEG
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: PUSH
62306: LD_INT 0
62308: PUSH
62309: LD_INT 2
62311: NEG
62312: PUSH
62313: EMPTY
62314: LIST
62315: LIST
62316: PUSH
62317: LD_INT 1
62319: PUSH
62320: LD_INT 1
62322: NEG
62323: PUSH
62324: EMPTY
62325: LIST
62326: LIST
62327: PUSH
62328: LD_INT 2
62330: PUSH
62331: LD_INT 0
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: PUSH
62338: LD_INT 2
62340: PUSH
62341: LD_INT 1
62343: PUSH
62344: EMPTY
62345: LIST
62346: LIST
62347: PUSH
62348: LD_INT 2
62350: PUSH
62351: LD_INT 2
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: PUSH
62358: LD_INT 1
62360: PUSH
62361: LD_INT 2
62363: PUSH
62364: EMPTY
62365: LIST
62366: LIST
62367: PUSH
62368: LD_INT 0
62370: PUSH
62371: LD_INT 2
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: PUSH
62378: LD_INT 1
62380: NEG
62381: PUSH
62382: LD_INT 1
62384: PUSH
62385: EMPTY
62386: LIST
62387: LIST
62388: PUSH
62389: LD_INT 2
62391: NEG
62392: PUSH
62393: LD_INT 0
62395: PUSH
62396: EMPTY
62397: LIST
62398: LIST
62399: PUSH
62400: LD_INT 2
62402: NEG
62403: PUSH
62404: LD_INT 1
62406: NEG
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: PUSH
62412: LD_INT 2
62414: NEG
62415: PUSH
62416: LD_INT 2
62418: NEG
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: PUSH
62424: EMPTY
62425: LIST
62426: LIST
62427: LIST
62428: LIST
62429: LIST
62430: LIST
62431: LIST
62432: LIST
62433: LIST
62434: LIST
62435: LIST
62436: LIST
62437: LIST
62438: LIST
62439: LIST
62440: LIST
62441: LIST
62442: LIST
62443: LIST
62444: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62445: LD_ADDR_VAR 0 18
62449: PUSH
62450: LD_INT 0
62452: PUSH
62453: LD_INT 0
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: PUSH
62460: LD_INT 0
62462: PUSH
62463: LD_INT 1
62465: NEG
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: LD_INT 1
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 1
62483: PUSH
62484: LD_INT 1
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: LD_INT 0
62493: PUSH
62494: LD_INT 1
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: PUSH
62501: LD_INT 1
62503: NEG
62504: PUSH
62505: LD_INT 0
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 1
62514: NEG
62515: PUSH
62516: LD_INT 1
62518: NEG
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PUSH
62524: LD_INT 1
62526: NEG
62527: PUSH
62528: LD_INT 2
62530: NEG
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: PUSH
62536: LD_INT 0
62538: PUSH
62539: LD_INT 2
62541: NEG
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PUSH
62547: LD_INT 1
62549: PUSH
62550: LD_INT 1
62552: NEG
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: PUSH
62558: LD_INT 2
62560: PUSH
62561: LD_INT 0
62563: PUSH
62564: EMPTY
62565: LIST
62566: LIST
62567: PUSH
62568: LD_INT 2
62570: PUSH
62571: LD_INT 1
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: PUSH
62578: LD_INT 2
62580: PUSH
62581: LD_INT 2
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: PUSH
62588: LD_INT 1
62590: PUSH
62591: LD_INT 2
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 0
62600: PUSH
62601: LD_INT 2
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: LD_INT 1
62610: NEG
62611: PUSH
62612: LD_INT 1
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PUSH
62619: LD_INT 2
62621: NEG
62622: PUSH
62623: LD_INT 0
62625: PUSH
62626: EMPTY
62627: LIST
62628: LIST
62629: PUSH
62630: LD_INT 2
62632: NEG
62633: PUSH
62634: LD_INT 1
62636: NEG
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: PUSH
62642: LD_INT 2
62644: NEG
62645: PUSH
62646: LD_INT 2
62648: NEG
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: LIST
62658: LIST
62659: LIST
62660: LIST
62661: LIST
62662: LIST
62663: LIST
62664: LIST
62665: LIST
62666: LIST
62667: LIST
62668: LIST
62669: LIST
62670: LIST
62671: LIST
62672: LIST
62673: LIST
62674: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62675: LD_ADDR_VAR 0 19
62679: PUSH
62680: LD_INT 0
62682: PUSH
62683: LD_INT 0
62685: PUSH
62686: EMPTY
62687: LIST
62688: LIST
62689: PUSH
62690: LD_INT 0
62692: PUSH
62693: LD_INT 1
62695: NEG
62696: PUSH
62697: EMPTY
62698: LIST
62699: LIST
62700: PUSH
62701: LD_INT 1
62703: PUSH
62704: LD_INT 0
62706: PUSH
62707: EMPTY
62708: LIST
62709: LIST
62710: PUSH
62711: LD_INT 1
62713: PUSH
62714: LD_INT 1
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PUSH
62721: LD_INT 0
62723: PUSH
62724: LD_INT 1
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: PUSH
62731: LD_INT 1
62733: NEG
62734: PUSH
62735: LD_INT 0
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: PUSH
62742: LD_INT 1
62744: NEG
62745: PUSH
62746: LD_INT 1
62748: NEG
62749: PUSH
62750: EMPTY
62751: LIST
62752: LIST
62753: PUSH
62754: LD_INT 1
62756: NEG
62757: PUSH
62758: LD_INT 2
62760: NEG
62761: PUSH
62762: EMPTY
62763: LIST
62764: LIST
62765: PUSH
62766: LD_INT 0
62768: PUSH
62769: LD_INT 2
62771: NEG
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: PUSH
62777: LD_INT 1
62779: PUSH
62780: LD_INT 1
62782: NEG
62783: PUSH
62784: EMPTY
62785: LIST
62786: LIST
62787: PUSH
62788: LD_INT 2
62790: PUSH
62791: LD_INT 0
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PUSH
62798: LD_INT 2
62800: PUSH
62801: LD_INT 1
62803: PUSH
62804: EMPTY
62805: LIST
62806: LIST
62807: PUSH
62808: LD_INT 2
62810: PUSH
62811: LD_INT 2
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: PUSH
62818: LD_INT 1
62820: PUSH
62821: LD_INT 2
62823: PUSH
62824: EMPTY
62825: LIST
62826: LIST
62827: PUSH
62828: LD_INT 0
62830: PUSH
62831: LD_INT 2
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: PUSH
62838: LD_INT 1
62840: NEG
62841: PUSH
62842: LD_INT 1
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PUSH
62849: LD_INT 2
62851: NEG
62852: PUSH
62853: LD_INT 0
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 2
62862: NEG
62863: PUSH
62864: LD_INT 1
62866: NEG
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: PUSH
62872: LD_INT 2
62874: NEG
62875: PUSH
62876: LD_INT 2
62878: NEG
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PUSH
62884: EMPTY
62885: LIST
62886: LIST
62887: LIST
62888: LIST
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: LIST
62900: LIST
62901: LIST
62902: LIST
62903: LIST
62904: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62905: LD_ADDR_VAR 0 20
62909: PUSH
62910: LD_INT 0
62912: PUSH
62913: LD_INT 0
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: PUSH
62920: LD_INT 0
62922: PUSH
62923: LD_INT 1
62925: NEG
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: PUSH
62931: LD_INT 1
62933: PUSH
62934: LD_INT 0
62936: PUSH
62937: EMPTY
62938: LIST
62939: LIST
62940: PUSH
62941: LD_INT 1
62943: PUSH
62944: LD_INT 1
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: PUSH
62951: LD_INT 0
62953: PUSH
62954: LD_INT 1
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: PUSH
62961: LD_INT 1
62963: NEG
62964: PUSH
62965: LD_INT 0
62967: PUSH
62968: EMPTY
62969: LIST
62970: LIST
62971: PUSH
62972: LD_INT 1
62974: NEG
62975: PUSH
62976: LD_INT 1
62978: NEG
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PUSH
62984: LD_INT 1
62986: NEG
62987: PUSH
62988: LD_INT 2
62990: NEG
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: PUSH
62996: LD_INT 0
62998: PUSH
62999: LD_INT 2
63001: NEG
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: LD_INT 1
63009: PUSH
63010: LD_INT 1
63012: NEG
63013: PUSH
63014: EMPTY
63015: LIST
63016: LIST
63017: PUSH
63018: LD_INT 2
63020: PUSH
63021: LD_INT 0
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: PUSH
63028: LD_INT 2
63030: PUSH
63031: LD_INT 1
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PUSH
63038: LD_INT 2
63040: PUSH
63041: LD_INT 2
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: PUSH
63048: LD_INT 1
63050: PUSH
63051: LD_INT 2
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: LD_INT 2
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: LD_INT 1
63070: NEG
63071: PUSH
63072: LD_INT 1
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 2
63081: NEG
63082: PUSH
63083: LD_INT 0
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: PUSH
63090: LD_INT 2
63092: NEG
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 2
63104: NEG
63105: PUSH
63106: LD_INT 2
63108: NEG
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: LIST
63118: LIST
63119: LIST
63120: LIST
63121: LIST
63122: LIST
63123: LIST
63124: LIST
63125: LIST
63126: LIST
63127: LIST
63128: LIST
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: LIST
63134: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63135: LD_ADDR_VAR 0 21
63139: PUSH
63140: LD_INT 0
63142: PUSH
63143: LD_INT 0
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: PUSH
63150: LD_INT 0
63152: PUSH
63153: LD_INT 1
63155: NEG
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 1
63163: PUSH
63164: LD_INT 0
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 1
63173: PUSH
63174: LD_INT 1
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: LD_INT 0
63183: PUSH
63184: LD_INT 1
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: PUSH
63191: LD_INT 1
63193: NEG
63194: PUSH
63195: LD_INT 0
63197: PUSH
63198: EMPTY
63199: LIST
63200: LIST
63201: PUSH
63202: LD_INT 1
63204: NEG
63205: PUSH
63206: LD_INT 1
63208: NEG
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: LD_INT 1
63216: NEG
63217: PUSH
63218: LD_INT 2
63220: NEG
63221: PUSH
63222: EMPTY
63223: LIST
63224: LIST
63225: PUSH
63226: LD_INT 0
63228: PUSH
63229: LD_INT 2
63231: NEG
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PUSH
63237: LD_INT 1
63239: PUSH
63240: LD_INT 1
63242: NEG
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 2
63250: PUSH
63251: LD_INT 0
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PUSH
63258: LD_INT 2
63260: PUSH
63261: LD_INT 1
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: PUSH
63268: LD_INT 2
63270: PUSH
63271: LD_INT 2
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: LD_INT 1
63280: PUSH
63281: LD_INT 2
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: LD_INT 0
63290: PUSH
63291: LD_INT 2
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PUSH
63298: LD_INT 1
63300: NEG
63301: PUSH
63302: LD_INT 1
63304: PUSH
63305: EMPTY
63306: LIST
63307: LIST
63308: PUSH
63309: LD_INT 2
63311: NEG
63312: PUSH
63313: LD_INT 0
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PUSH
63320: LD_INT 2
63322: NEG
63323: PUSH
63324: LD_INT 1
63326: NEG
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PUSH
63332: LD_INT 2
63334: NEG
63335: PUSH
63336: LD_INT 2
63338: NEG
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: LIST
63363: LIST
63364: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63365: LD_ADDR_VAR 0 22
63369: PUSH
63370: LD_INT 0
63372: PUSH
63373: LD_INT 0
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 0
63382: PUSH
63383: LD_INT 1
63385: NEG
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PUSH
63391: LD_INT 1
63393: PUSH
63394: LD_INT 0
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 1
63403: PUSH
63404: LD_INT 1
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 0
63413: PUSH
63414: LD_INT 1
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 1
63423: NEG
63424: PUSH
63425: LD_INT 0
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: PUSH
63432: LD_INT 1
63434: NEG
63435: PUSH
63436: LD_INT 1
63438: NEG
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: PUSH
63444: LD_INT 1
63446: NEG
63447: PUSH
63448: LD_INT 2
63450: NEG
63451: PUSH
63452: EMPTY
63453: LIST
63454: LIST
63455: PUSH
63456: LD_INT 0
63458: PUSH
63459: LD_INT 2
63461: NEG
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: PUSH
63467: LD_INT 1
63469: PUSH
63470: LD_INT 1
63472: NEG
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 2
63480: PUSH
63481: LD_INT 0
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 2
63490: PUSH
63491: LD_INT 1
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: PUSH
63498: LD_INT 2
63500: PUSH
63501: LD_INT 2
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: PUSH
63508: LD_INT 1
63510: PUSH
63511: LD_INT 2
63513: PUSH
63514: EMPTY
63515: LIST
63516: LIST
63517: PUSH
63518: LD_INT 0
63520: PUSH
63521: LD_INT 2
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PUSH
63528: LD_INT 1
63530: NEG
63531: PUSH
63532: LD_INT 1
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: PUSH
63539: LD_INT 2
63541: NEG
63542: PUSH
63543: LD_INT 0
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: PUSH
63550: LD_INT 2
63552: NEG
63553: PUSH
63554: LD_INT 1
63556: NEG
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: LD_INT 2
63564: NEG
63565: PUSH
63566: LD_INT 2
63568: NEG
63569: PUSH
63570: EMPTY
63571: LIST
63572: LIST
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: LIST
63578: LIST
63579: LIST
63580: LIST
63581: LIST
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63595: LD_ADDR_VAR 0 23
63599: PUSH
63600: LD_INT 0
63602: PUSH
63603: LD_INT 0
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 0
63612: PUSH
63613: LD_INT 1
63615: NEG
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: LD_INT 0
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PUSH
63631: LD_INT 1
63633: PUSH
63634: LD_INT 1
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PUSH
63641: LD_INT 0
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 1
63653: NEG
63654: PUSH
63655: LD_INT 0
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 1
63664: NEG
63665: PUSH
63666: LD_INT 1
63668: NEG
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 1
63676: NEG
63677: PUSH
63678: LD_INT 2
63680: NEG
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 0
63688: PUSH
63689: LD_INT 2
63691: NEG
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: LD_INT 1
63702: NEG
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 2
63710: PUSH
63711: LD_INT 0
63713: PUSH
63714: EMPTY
63715: LIST
63716: LIST
63717: PUSH
63718: LD_INT 2
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 2
63730: PUSH
63731: LD_INT 2
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: PUSH
63738: LD_INT 1
63740: PUSH
63741: LD_INT 2
63743: PUSH
63744: EMPTY
63745: LIST
63746: LIST
63747: PUSH
63748: LD_INT 0
63750: PUSH
63751: LD_INT 2
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: PUSH
63758: LD_INT 1
63760: NEG
63761: PUSH
63762: LD_INT 1
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: LD_INT 2
63771: NEG
63772: PUSH
63773: LD_INT 0
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PUSH
63780: LD_INT 2
63782: NEG
63783: PUSH
63784: LD_INT 1
63786: NEG
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 2
63794: NEG
63795: PUSH
63796: LD_INT 2
63798: NEG
63799: PUSH
63800: EMPTY
63801: LIST
63802: LIST
63803: PUSH
63804: LD_INT 2
63806: NEG
63807: PUSH
63808: LD_INT 3
63810: NEG
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: LD_INT 1
63818: NEG
63819: PUSH
63820: LD_INT 3
63822: NEG
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: PUSH
63831: LD_INT 2
63833: NEG
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 2
63841: PUSH
63842: LD_INT 1
63844: NEG
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
63875: LD_ADDR_VAR 0 24
63879: PUSH
63880: LD_INT 0
63882: PUSH
63883: LD_INT 0
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 0
63892: PUSH
63893: LD_INT 1
63895: NEG
63896: PUSH
63897: EMPTY
63898: LIST
63899: LIST
63900: PUSH
63901: LD_INT 1
63903: PUSH
63904: LD_INT 0
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: PUSH
63911: LD_INT 1
63913: PUSH
63914: LD_INT 1
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: PUSH
63921: LD_INT 0
63923: PUSH
63924: LD_INT 1
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: LD_INT 0
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: LD_INT 1
63948: NEG
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 1
63956: NEG
63957: PUSH
63958: LD_INT 2
63960: NEG
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PUSH
63966: LD_INT 0
63968: PUSH
63969: LD_INT 2
63971: NEG
63972: PUSH
63973: EMPTY
63974: LIST
63975: LIST
63976: PUSH
63977: LD_INT 1
63979: PUSH
63980: LD_INT 1
63982: NEG
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 2
63990: PUSH
63991: LD_INT 0
63993: PUSH
63994: EMPTY
63995: LIST
63996: LIST
63997: PUSH
63998: LD_INT 2
64000: PUSH
64001: LD_INT 1
64003: PUSH
64004: EMPTY
64005: LIST
64006: LIST
64007: PUSH
64008: LD_INT 2
64010: PUSH
64011: LD_INT 2
64013: PUSH
64014: EMPTY
64015: LIST
64016: LIST
64017: PUSH
64018: LD_INT 1
64020: PUSH
64021: LD_INT 2
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PUSH
64028: LD_INT 0
64030: PUSH
64031: LD_INT 2
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: LD_INT 1
64040: NEG
64041: PUSH
64042: LD_INT 1
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: PUSH
64049: LD_INT 2
64051: NEG
64052: PUSH
64053: LD_INT 0
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 2
64062: NEG
64063: PUSH
64064: LD_INT 1
64066: NEG
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PUSH
64072: LD_INT 2
64074: NEG
64075: PUSH
64076: LD_INT 2
64078: NEG
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 1
64086: PUSH
64087: LD_INT 2
64089: NEG
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PUSH
64095: LD_INT 2
64097: PUSH
64098: LD_INT 1
64100: NEG
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 3
64108: PUSH
64109: LD_INT 1
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PUSH
64116: LD_INT 3
64118: PUSH
64119: LD_INT 2
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64151: LD_ADDR_VAR 0 25
64155: PUSH
64156: LD_INT 0
64158: PUSH
64159: LD_INT 0
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 0
64168: PUSH
64169: LD_INT 1
64171: NEG
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 1
64179: PUSH
64180: LD_INT 0
64182: PUSH
64183: EMPTY
64184: LIST
64185: LIST
64186: PUSH
64187: LD_INT 1
64189: PUSH
64190: LD_INT 1
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: PUSH
64197: LD_INT 0
64199: PUSH
64200: LD_INT 1
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 1
64209: NEG
64210: PUSH
64211: LD_INT 0
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 1
64220: NEG
64221: PUSH
64222: LD_INT 1
64224: NEG
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PUSH
64230: LD_INT 1
64232: NEG
64233: PUSH
64234: LD_INT 2
64236: NEG
64237: PUSH
64238: EMPTY
64239: LIST
64240: LIST
64241: PUSH
64242: LD_INT 0
64244: PUSH
64245: LD_INT 2
64247: NEG
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PUSH
64253: LD_INT 1
64255: PUSH
64256: LD_INT 1
64258: NEG
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: LD_INT 2
64266: PUSH
64267: LD_INT 0
64269: PUSH
64270: EMPTY
64271: LIST
64272: LIST
64273: PUSH
64274: LD_INT 2
64276: PUSH
64277: LD_INT 1
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 2
64286: PUSH
64287: LD_INT 2
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 1
64296: PUSH
64297: LD_INT 2
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 0
64306: PUSH
64307: LD_INT 2
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: LD_INT 1
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 2
64327: NEG
64328: PUSH
64329: LD_INT 0
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 2
64338: NEG
64339: PUSH
64340: LD_INT 1
64342: NEG
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 2
64350: NEG
64351: PUSH
64352: LD_INT 2
64354: NEG
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: LD_INT 3
64362: PUSH
64363: LD_INT 1
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 3
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 2
64382: PUSH
64383: LD_INT 3
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 1
64392: PUSH
64393: LD_INT 3
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: LIST
64419: LIST
64420: LIST
64421: LIST
64422: LIST
64423: LIST
64424: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64425: LD_ADDR_VAR 0 26
64429: PUSH
64430: LD_INT 0
64432: PUSH
64433: LD_INT 0
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: PUSH
64440: LD_INT 0
64442: PUSH
64443: LD_INT 1
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 1
64453: PUSH
64454: LD_INT 0
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PUSH
64461: LD_INT 1
64463: PUSH
64464: LD_INT 1
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 0
64473: PUSH
64474: LD_INT 1
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 1
64483: NEG
64484: PUSH
64485: LD_INT 0
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: PUSH
64492: LD_INT 1
64494: NEG
64495: PUSH
64496: LD_INT 1
64498: NEG
64499: PUSH
64500: EMPTY
64501: LIST
64502: LIST
64503: PUSH
64504: LD_INT 1
64506: NEG
64507: PUSH
64508: LD_INT 2
64510: NEG
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: PUSH
64516: LD_INT 0
64518: PUSH
64519: LD_INT 2
64521: NEG
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 1
64529: PUSH
64530: LD_INT 1
64532: NEG
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: PUSH
64538: LD_INT 2
64540: PUSH
64541: LD_INT 0
64543: PUSH
64544: EMPTY
64545: LIST
64546: LIST
64547: PUSH
64548: LD_INT 2
64550: PUSH
64551: LD_INT 1
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 2
64560: PUSH
64561: LD_INT 2
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: LD_INT 1
64570: PUSH
64571: LD_INT 2
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PUSH
64578: LD_INT 0
64580: PUSH
64581: LD_INT 2
64583: PUSH
64584: EMPTY
64585: LIST
64586: LIST
64587: PUSH
64588: LD_INT 1
64590: NEG
64591: PUSH
64592: LD_INT 1
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 2
64601: NEG
64602: PUSH
64603: LD_INT 0
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: PUSH
64610: LD_INT 2
64612: NEG
64613: PUSH
64614: LD_INT 1
64616: NEG
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: PUSH
64622: LD_INT 2
64624: NEG
64625: PUSH
64626: LD_INT 2
64628: NEG
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 2
64636: PUSH
64637: LD_INT 3
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 1
64646: PUSH
64647: LD_INT 3
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: LD_INT 1
64656: NEG
64657: PUSH
64658: LD_INT 2
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: LD_INT 2
64667: NEG
64668: PUSH
64669: LD_INT 1
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64701: LD_ADDR_VAR 0 27
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: LD_INT 0
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 0
64718: PUSH
64719: LD_INT 1
64721: NEG
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PUSH
64727: LD_INT 1
64729: PUSH
64730: LD_INT 0
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: LD_INT 1
64739: PUSH
64740: LD_INT 1
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: LD_INT 0
64749: PUSH
64750: LD_INT 1
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 1
64759: NEG
64760: PUSH
64761: LD_INT 0
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 1
64770: NEG
64771: PUSH
64772: LD_INT 1
64774: NEG
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 1
64782: NEG
64783: PUSH
64784: LD_INT 2
64786: NEG
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 0
64794: PUSH
64795: LD_INT 2
64797: NEG
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 1
64805: PUSH
64806: LD_INT 1
64808: NEG
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: LD_INT 2
64816: PUSH
64817: LD_INT 0
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 2
64826: PUSH
64827: LD_INT 1
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 2
64836: PUSH
64837: LD_INT 2
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 1
64846: PUSH
64847: LD_INT 2
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 2
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_INT 1
64866: NEG
64867: PUSH
64868: LD_INT 1
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PUSH
64875: LD_INT 2
64877: NEG
64878: PUSH
64879: LD_INT 0
64881: PUSH
64882: EMPTY
64883: LIST
64884: LIST
64885: PUSH
64886: LD_INT 2
64888: NEG
64889: PUSH
64890: LD_INT 1
64892: NEG
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 2
64900: NEG
64901: PUSH
64902: LD_INT 2
64904: NEG
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: PUSH
64910: LD_INT 1
64912: NEG
64913: PUSH
64914: LD_INT 2
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: PUSH
64921: LD_INT 2
64923: NEG
64924: PUSH
64925: LD_INT 1
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 3
64934: NEG
64935: PUSH
64936: LD_INT 1
64938: NEG
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: PUSH
64944: LD_INT 3
64946: NEG
64947: PUSH
64948: LD_INT 2
64950: NEG
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: LIST
64963: LIST
64964: LIST
64965: LIST
64966: LIST
64967: LIST
64968: LIST
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64981: LD_ADDR_VAR 0 28
64985: PUSH
64986: LD_INT 0
64988: PUSH
64989: LD_INT 0
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 0
64998: PUSH
64999: LD_INT 1
65001: NEG
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: PUSH
65007: LD_INT 1
65009: PUSH
65010: LD_INT 0
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PUSH
65017: LD_INT 1
65019: PUSH
65020: LD_INT 1
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 0
65029: PUSH
65030: LD_INT 1
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 1
65039: NEG
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 1
65050: NEG
65051: PUSH
65052: LD_INT 1
65054: NEG
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PUSH
65060: LD_INT 1
65062: NEG
65063: PUSH
65064: LD_INT 2
65066: NEG
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: LD_INT 0
65074: PUSH
65075: LD_INT 2
65077: NEG
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PUSH
65083: LD_INT 1
65085: PUSH
65086: LD_INT 1
65088: NEG
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PUSH
65094: LD_INT 2
65096: PUSH
65097: LD_INT 0
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 2
65106: PUSH
65107: LD_INT 1
65109: PUSH
65110: EMPTY
65111: LIST
65112: LIST
65113: PUSH
65114: LD_INT 2
65116: PUSH
65117: LD_INT 2
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 1
65126: PUSH
65127: LD_INT 2
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: LD_INT 0
65136: PUSH
65137: LD_INT 2
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PUSH
65144: LD_INT 1
65146: NEG
65147: PUSH
65148: LD_INT 1
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: PUSH
65155: LD_INT 2
65157: NEG
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 2
65168: NEG
65169: PUSH
65170: LD_INT 1
65172: NEG
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PUSH
65178: LD_INT 2
65180: NEG
65181: PUSH
65182: LD_INT 2
65184: NEG
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 2
65192: NEG
65193: PUSH
65194: LD_INT 3
65196: NEG
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 1
65204: NEG
65205: PUSH
65206: LD_INT 3
65208: NEG
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 3
65216: NEG
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: LD_INT 3
65228: NEG
65229: PUSH
65230: LD_INT 2
65232: NEG
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65263: LD_ADDR_VAR 0 29
65267: PUSH
65268: LD_INT 0
65270: PUSH
65271: LD_INT 0
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 0
65280: PUSH
65281: LD_INT 1
65283: NEG
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 1
65291: PUSH
65292: LD_INT 0
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 1
65301: PUSH
65302: LD_INT 1
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 0
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 1
65321: NEG
65322: PUSH
65323: LD_INT 0
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: LD_INT 1
65332: NEG
65333: PUSH
65334: LD_INT 1
65336: NEG
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: LD_INT 2
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 0
65356: PUSH
65357: LD_INT 2
65359: NEG
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 1
65367: PUSH
65368: LD_INT 1
65370: NEG
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: LD_INT 0
65381: PUSH
65382: EMPTY
65383: LIST
65384: LIST
65385: PUSH
65386: LD_INT 2
65388: PUSH
65389: LD_INT 1
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 1
65398: PUSH
65399: LD_INT 2
65401: PUSH
65402: EMPTY
65403: LIST
65404: LIST
65405: PUSH
65406: LD_INT 0
65408: PUSH
65409: LD_INT 2
65411: PUSH
65412: EMPTY
65413: LIST
65414: LIST
65415: PUSH
65416: LD_INT 1
65418: NEG
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 2
65429: NEG
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 2
65441: NEG
65442: PUSH
65443: LD_INT 2
65445: NEG
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 2
65453: NEG
65454: PUSH
65455: LD_INT 3
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 2
65465: PUSH
65466: LD_INT 1
65468: NEG
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 3
65476: PUSH
65477: LD_INT 1
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 1
65486: PUSH
65487: LD_INT 3
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 1
65496: NEG
65497: PUSH
65498: LD_INT 2
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 3
65507: NEG
65508: PUSH
65509: LD_INT 2
65511: NEG
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65542: LD_ADDR_VAR 0 30
65546: PUSH
65547: LD_INT 0
65549: PUSH
65550: LD_INT 0
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 0
65559: PUSH
65560: LD_INT 1
65562: NEG
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 1
65570: PUSH
65571: LD_INT 0
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 1
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: EMPTY
65585: LIST
65586: LIST
65587: PUSH
65588: LD_INT 0
65590: PUSH
65591: LD_INT 1
65593: PUSH
65594: EMPTY
65595: LIST
65596: LIST
65597: PUSH
65598: LD_INT 1
65600: NEG
65601: PUSH
65602: LD_INT 0
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 1
65611: NEG
65612: PUSH
65613: LD_INT 1
65615: NEG
65616: PUSH
65617: EMPTY
65618: LIST
65619: LIST
65620: PUSH
65621: LD_INT 1
65623: NEG
65624: PUSH
65625: LD_INT 2
65627: NEG
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: LD_INT 2
65638: NEG
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 1
65646: PUSH
65647: LD_INT 1
65649: NEG
65650: PUSH
65651: EMPTY
65652: LIST
65653: LIST
65654: PUSH
65655: LD_INT 2
65657: PUSH
65658: LD_INT 0
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 2
65667: PUSH
65668: LD_INT 1
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 2
65677: PUSH
65678: LD_INT 2
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 1
65687: PUSH
65688: LD_INT 2
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 1
65697: NEG
65698: PUSH
65699: LD_INT 1
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: PUSH
65706: LD_INT 2
65708: NEG
65709: PUSH
65710: LD_INT 0
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 2
65719: NEG
65720: PUSH
65721: LD_INT 1
65723: NEG
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 1
65731: NEG
65732: PUSH
65733: LD_INT 3
65735: NEG
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 1
65743: PUSH
65744: LD_INT 2
65746: NEG
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: LD_INT 3
65754: PUSH
65755: LD_INT 2
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: LD_INT 3
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PUSH
65772: LD_INT 2
65774: NEG
65775: PUSH
65776: LD_INT 1
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 3
65785: NEG
65786: PUSH
65787: LD_INT 1
65789: NEG
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65820: LD_ADDR_VAR 0 31
65824: PUSH
65825: LD_INT 0
65827: PUSH
65828: LD_INT 0
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 0
65837: PUSH
65838: LD_INT 1
65840: NEG
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 1
65848: PUSH
65849: LD_INT 0
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 1
65858: PUSH
65859: LD_INT 1
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 0
65868: PUSH
65869: LD_INT 1
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 1
65878: NEG
65879: PUSH
65880: LD_INT 0
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 1
65889: NEG
65890: PUSH
65891: LD_INT 1
65893: NEG
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 1
65901: NEG
65902: PUSH
65903: LD_INT 2
65905: NEG
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 1
65916: NEG
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 2
65924: PUSH
65925: LD_INT 0
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 2
65934: PUSH
65935: LD_INT 1
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 2
65944: PUSH
65945: LD_INT 2
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 1
65954: PUSH
65955: LD_INT 2
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: LD_INT 2
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: PUSH
65972: LD_INT 1
65974: NEG
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 2
65985: NEG
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 2
65997: NEG
65998: PUSH
65999: LD_INT 2
66001: NEG
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: LD_INT 2
66009: NEG
66010: PUSH
66011: LD_INT 3
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: LD_INT 1
66024: NEG
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 3
66032: PUSH
66033: LD_INT 1
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PUSH
66040: LD_INT 1
66042: PUSH
66043: LD_INT 3
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 1
66052: NEG
66053: PUSH
66054: LD_INT 2
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 3
66063: NEG
66064: PUSH
66065: LD_INT 2
66067: NEG
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: LIST
66083: LIST
66084: LIST
66085: LIST
66086: LIST
66087: LIST
66088: LIST
66089: LIST
66090: LIST
66091: LIST
66092: LIST
66093: LIST
66094: LIST
66095: LIST
66096: LIST
66097: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66098: LD_ADDR_VAR 0 32
66102: PUSH
66103: LD_INT 0
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 0
66115: PUSH
66116: LD_INT 1
66118: NEG
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 1
66126: PUSH
66127: LD_INT 0
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 1
66136: PUSH
66137: LD_INT 1
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 0
66146: PUSH
66147: LD_INT 1
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 1
66156: NEG
66157: PUSH
66158: LD_INT 0
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PUSH
66165: LD_INT 1
66167: NEG
66168: PUSH
66169: LD_INT 1
66171: NEG
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 1
66179: NEG
66180: PUSH
66181: LD_INT 2
66183: NEG
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 0
66191: PUSH
66192: LD_INT 2
66194: NEG
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 1
66202: PUSH
66203: LD_INT 1
66205: NEG
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 2
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 2
66223: PUSH
66224: LD_INT 2
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: LD_INT 2
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 0
66243: PUSH
66244: LD_INT 2
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 1
66253: NEG
66254: PUSH
66255: LD_INT 1
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 2
66264: NEG
66265: PUSH
66266: LD_INT 0
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 2
66275: NEG
66276: PUSH
66277: LD_INT 1
66279: NEG
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: LD_INT 3
66291: NEG
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: LD_INT 1
66299: PUSH
66300: LD_INT 2
66302: NEG
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 3
66310: PUSH
66311: LD_INT 2
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 2
66320: PUSH
66321: LD_INT 3
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 2
66330: NEG
66331: PUSH
66332: LD_INT 1
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 3
66341: NEG
66342: PUSH
66343: LD_INT 1
66345: NEG
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66376: LD_ADDR_VAR 0 33
66380: PUSH
66381: LD_INT 0
66383: PUSH
66384: LD_INT 0
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: LD_INT 1
66396: NEG
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 1
66404: PUSH
66405: LD_INT 0
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 1
66414: PUSH
66415: LD_INT 1
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: LD_INT 1
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 1
66434: NEG
66435: PUSH
66436: LD_INT 0
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 1
66457: NEG
66458: PUSH
66459: LD_INT 2
66461: NEG
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 1
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 2
66480: PUSH
66481: LD_INT 0
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 2
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 1
66500: PUSH
66501: LD_INT 2
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 0
66510: PUSH
66511: LD_INT 2
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: LD_INT 1
66520: NEG
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 2
66531: NEG
66532: PUSH
66533: LD_INT 0
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 2
66542: NEG
66543: PUSH
66544: LD_INT 1
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 2
66554: NEG
66555: PUSH
66556: LD_INT 2
66558: NEG
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 2
66566: NEG
66567: PUSH
66568: LD_INT 3
66570: NEG
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: PUSH
66579: LD_INT 1
66581: NEG
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 3
66589: PUSH
66590: LD_INT 1
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 1
66599: PUSH
66600: LD_INT 3
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PUSH
66611: LD_INT 2
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 3
66620: NEG
66621: PUSH
66622: LD_INT 2
66624: NEG
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66655: LD_ADDR_VAR 0 34
66659: PUSH
66660: LD_INT 0
66662: PUSH
66663: LD_INT 0
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 0
66672: PUSH
66673: LD_INT 1
66675: NEG
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: LD_INT 1
66693: PUSH
66694: LD_INT 1
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 0
66703: PUSH
66704: LD_INT 1
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 1
66713: NEG
66714: PUSH
66715: LD_INT 0
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: LD_INT 1
66724: NEG
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 1
66736: NEG
66737: PUSH
66738: LD_INT 2
66740: NEG
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 0
66748: PUSH
66749: LD_INT 2
66751: NEG
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 1
66759: PUSH
66760: LD_INT 1
66762: NEG
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 2
66780: PUSH
66781: LD_INT 2
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: LD_INT 2
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 1
66800: NEG
66801: PUSH
66802: LD_INT 1
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 2
66811: NEG
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 2
66822: NEG
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 2
66834: NEG
66835: PUSH
66836: LD_INT 2
66838: NEG
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 1
66846: NEG
66847: PUSH
66848: LD_INT 3
66850: NEG
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 1
66858: PUSH
66859: LD_INT 2
66861: NEG
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 3
66869: PUSH
66870: LD_INT 2
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: PUSH
66880: LD_INT 3
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 2
66889: NEG
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 3
66900: NEG
66901: PUSH
66902: LD_INT 1
66904: NEG
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66935: LD_ADDR_VAR 0 35
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: LD_INT 0
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 0
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 1
66973: PUSH
66974: LD_INT 1
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: LD_INT 1
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 1
67004: NEG
67005: PUSH
67006: LD_INT 1
67008: NEG
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 2
67016: PUSH
67017: LD_INT 1
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 2
67026: NEG
67027: PUSH
67028: LD_INT 1
67030: NEG
67031: PUSH
67032: EMPTY
67033: LIST
67034: LIST
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67047: LD_ADDR_VAR 0 36
67051: PUSH
67052: LD_INT 0
67054: PUSH
67055: LD_INT 0
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 0
67064: PUSH
67065: LD_INT 1
67067: NEG
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: LD_INT 0
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: LD_INT 1
67085: PUSH
67086: LD_INT 1
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 0
67095: PUSH
67096: LD_INT 1
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 1
67105: NEG
67106: PUSH
67107: LD_INT 0
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PUSH
67118: LD_INT 1
67120: NEG
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 1
67128: NEG
67129: PUSH
67130: LD_INT 2
67132: NEG
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: LD_INT 2
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67159: LD_ADDR_VAR 0 37
67163: PUSH
67164: LD_INT 0
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 0
67176: PUSH
67177: LD_INT 1
67179: NEG
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 1
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 1
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 1
67217: NEG
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: NEG
67229: PUSH
67230: LD_INT 1
67232: NEG
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: PUSH
67238: LD_INT 1
67240: PUSH
67241: LD_INT 1
67243: NEG
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 1
67251: NEG
67252: PUSH
67253: LD_INT 1
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67271: LD_ADDR_VAR 0 38
67275: PUSH
67276: LD_INT 0
67278: PUSH
67279: LD_INT 0
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 0
67288: PUSH
67289: LD_INT 1
67291: NEG
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 1
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: LD_INT 1
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 1
67329: NEG
67330: PUSH
67331: LD_INT 0
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 1
67340: NEG
67341: PUSH
67342: LD_INT 1
67344: NEG
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 2
67352: PUSH
67353: LD_INT 1
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 2
67362: NEG
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67383: LD_ADDR_VAR 0 39
67387: PUSH
67388: LD_INT 0
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 1
67403: NEG
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 1
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 1
67421: PUSH
67422: LD_INT 1
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 0
67431: PUSH
67432: LD_INT 1
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 1
67441: NEG
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: NEG
67453: PUSH
67454: LD_INT 1
67456: NEG
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 1
67464: NEG
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: LD_INT 2
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67495: LD_ADDR_VAR 0 40
67499: PUSH
67500: LD_INT 0
67502: PUSH
67503: LD_INT 0
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 0
67512: PUSH
67513: LD_INT 1
67515: NEG
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 1
67523: PUSH
67524: LD_INT 0
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 1
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 0
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: LD_INT 0
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: LD_INT 1
67568: NEG
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: LD_INT 1
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67607: LD_ADDR_VAR 0 41
67611: PUSH
67612: LD_INT 0
67614: PUSH
67615: LD_INT 0
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 0
67624: PUSH
67625: LD_INT 1
67627: NEG
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: LD_INT 1
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 1
67645: PUSH
67646: LD_INT 1
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: PUSH
67653: LD_INT 0
67655: PUSH
67656: LD_INT 1
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: NEG
67666: PUSH
67667: LD_INT 0
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: LD_INT 1
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 1
67688: NEG
67689: PUSH
67690: LD_INT 2
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: LD_INT 0
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 2
67721: PUSH
67722: LD_INT 1
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 2
67731: PUSH
67732: LD_INT 2
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 1
67741: PUSH
67742: LD_INT 2
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 1
67751: NEG
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: NEG
67763: PUSH
67764: LD_INT 0
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 2
67773: NEG
67774: PUSH
67775: LD_INT 1
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 2
67785: NEG
67786: PUSH
67787: LD_INT 2
67789: NEG
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 2
67797: NEG
67798: PUSH
67799: LD_INT 3
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 2
67809: PUSH
67810: LD_INT 1
67812: NEG
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 3
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 3
67830: PUSH
67831: LD_INT 1
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 3
67840: PUSH
67841: LD_INT 2
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 3
67850: PUSH
67851: LD_INT 3
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 2
67860: PUSH
67861: LD_INT 3
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 2
67870: NEG
67871: PUSH
67872: LD_INT 1
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 3
67881: NEG
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 3
67892: NEG
67893: PUSH
67894: LD_INT 1
67896: NEG
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 3
67904: NEG
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 3
67916: NEG
67917: PUSH
67918: LD_INT 3
67920: NEG
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67957: LD_ADDR_VAR 0 42
67961: PUSH
67962: LD_INT 0
67964: PUSH
67965: LD_INT 0
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 0
67974: PUSH
67975: LD_INT 1
67977: NEG
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 1
67995: PUSH
67996: LD_INT 1
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 0
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: LD_INT 0
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 1
68026: NEG
68027: PUSH
68028: LD_INT 1
68030: NEG
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: LD_INT 2
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: LD_INT 2
68053: NEG
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 1
68061: PUSH
68062: LD_INT 1
68064: NEG
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 2
68072: PUSH
68073: LD_INT 1
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 2
68082: PUSH
68083: LD_INT 2
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 1
68092: PUSH
68093: LD_INT 2
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 0
68102: PUSH
68103: LD_INT 2
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 1
68112: NEG
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 2
68123: NEG
68124: PUSH
68125: LD_INT 1
68127: NEG
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 2
68135: NEG
68136: PUSH
68137: LD_INT 2
68139: NEG
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 2
68147: NEG
68148: PUSH
68149: LD_INT 3
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 1
68159: NEG
68160: PUSH
68161: LD_INT 3
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 0
68171: PUSH
68172: LD_INT 3
68174: NEG
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: LD_INT 2
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 3
68193: PUSH
68194: LD_INT 2
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 3
68203: PUSH
68204: LD_INT 3
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 2
68213: PUSH
68214: LD_INT 3
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: PUSH
68224: LD_INT 3
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 0
68233: PUSH
68234: LD_INT 3
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 3
68254: NEG
68255: PUSH
68256: LD_INT 2
68258: NEG
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 3
68266: NEG
68267: PUSH
68268: LD_INT 3
68270: NEG
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68307: LD_ADDR_VAR 0 43
68311: PUSH
68312: LD_INT 0
68314: PUSH
68315: LD_INT 0
68317: PUSH
68318: EMPTY
68319: LIST
68320: LIST
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: LD_INT 1
68327: NEG
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 1
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 0
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 1
68365: NEG
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: LD_INT 1
68380: NEG
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: LD_INT 2
68392: NEG
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 0
68400: PUSH
68401: LD_INT 2
68403: NEG
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PUSH
68409: LD_INT 1
68411: PUSH
68412: LD_INT 1
68414: NEG
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 2
68422: PUSH
68423: LD_INT 0
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 2
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 1
68442: PUSH
68443: LD_INT 2
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 0
68452: PUSH
68453: LD_INT 2
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 1
68462: NEG
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 2
68473: NEG
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: NEG
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: NEG
68497: PUSH
68498: LD_INT 3
68500: NEG
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 0
68508: PUSH
68509: LD_INT 3
68511: NEG
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 1
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: LD_INT 1
68533: NEG
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 3
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 3
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 1
68561: PUSH
68562: LD_INT 3
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 0
68571: PUSH
68572: LD_INT 3
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 1
68581: NEG
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 2
68592: NEG
68593: PUSH
68594: LD_INT 1
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 3
68603: NEG
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 3
68614: NEG
68615: PUSH
68616: LD_INT 1
68618: NEG
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: LIST
68654: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68655: LD_ADDR_VAR 0 44
68659: PUSH
68660: LD_INT 0
68662: PUSH
68663: LD_INT 0
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 0
68672: PUSH
68673: LD_INT 1
68675: NEG
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 1
68683: PUSH
68684: LD_INT 0
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: LD_INT 1
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 0
68703: PUSH
68704: LD_INT 1
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: PUSH
68711: LD_INT 1
68713: NEG
68714: PUSH
68715: LD_INT 0
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 1
68724: NEG
68725: PUSH
68726: LD_INT 1
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 1
68736: NEG
68737: PUSH
68738: LD_INT 2
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 2
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 2
68769: PUSH
68770: LD_INT 1
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 2
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 1
68789: PUSH
68790: LD_INT 2
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 1
68799: NEG
68800: PUSH
68801: LD_INT 1
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: PUSH
68808: LD_INT 2
68810: NEG
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 2
68821: NEG
68822: PUSH
68823: LD_INT 1
68825: NEG
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 2
68833: NEG
68834: PUSH
68835: LD_INT 2
68837: NEG
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 2
68845: NEG
68846: PUSH
68847: LD_INT 3
68849: NEG
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 2
68857: PUSH
68858: LD_INT 1
68860: NEG
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: LD_INT 3
68868: PUSH
68869: LD_INT 0
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 3
68878: PUSH
68879: LD_INT 1
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 3
68888: PUSH
68889: LD_INT 2
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 3
68898: PUSH
68899: LD_INT 3
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 2
68908: PUSH
68909: LD_INT 3
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 2
68918: NEG
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 3
68929: NEG
68930: PUSH
68931: LD_INT 0
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 3
68940: NEG
68941: PUSH
68942: LD_INT 1
68944: NEG
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 3
68952: NEG
68953: PUSH
68954: LD_INT 2
68956: NEG
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 3
68964: NEG
68965: PUSH
68966: LD_INT 3
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69005: LD_ADDR_VAR 0 45
69009: PUSH
69010: LD_INT 0
69012: PUSH
69013: LD_INT 0
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 0
69022: PUSH
69023: LD_INT 1
69025: NEG
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 1
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 1
69043: PUSH
69044: LD_INT 1
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: LD_INT 1
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: NEG
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: LD_INT 2
69090: NEG
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: LD_INT 2
69101: NEG
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 2
69120: PUSH
69121: LD_INT 1
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 2
69130: PUSH
69131: LD_INT 2
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: LD_INT 2
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: LD_INT 2
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 1
69160: NEG
69161: PUSH
69162: LD_INT 1
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 2
69171: NEG
69172: PUSH
69173: LD_INT 1
69175: NEG
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 2
69183: NEG
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 2
69195: NEG
69196: PUSH
69197: LD_INT 3
69199: NEG
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 1
69207: NEG
69208: PUSH
69209: LD_INT 3
69211: NEG
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 0
69219: PUSH
69220: LD_INT 3
69222: NEG
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: LD_INT 2
69233: NEG
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: LD_INT 2
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 3
69251: PUSH
69252: LD_INT 3
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: PUSH
69259: LD_INT 2
69261: PUSH
69262: LD_INT 3
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: LD_INT 3
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 0
69281: PUSH
69282: LD_INT 3
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PUSH
69289: LD_INT 1
69291: NEG
69292: PUSH
69293: LD_INT 2
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 3
69302: NEG
69303: PUSH
69304: LD_INT 2
69306: NEG
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 3
69314: NEG
69315: PUSH
69316: LD_INT 3
69318: NEG
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69355: LD_ADDR_VAR 0 46
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: LD_INT 0
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 0
69372: PUSH
69373: LD_INT 1
69375: NEG
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 1
69383: PUSH
69384: LD_INT 0
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 1
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 1
69413: NEG
69414: PUSH
69415: LD_INT 0
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: NEG
69425: PUSH
69426: LD_INT 1
69428: NEG
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: LD_INT 2
69440: NEG
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: LD_INT 2
69451: NEG
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 1
69459: PUSH
69460: LD_INT 1
69462: NEG
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 2
69470: PUSH
69471: LD_INT 0
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 2
69480: PUSH
69481: LD_INT 1
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 0
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: NEG
69511: PUSH
69512: LD_INT 1
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 2
69521: NEG
69522: PUSH
69523: LD_INT 0
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 2
69532: NEG
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 1
69544: NEG
69545: PUSH
69546: LD_INT 3
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 0
69556: PUSH
69557: LD_INT 3
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: LD_INT 2
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 3
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 3
69599: PUSH
69600: LD_INT 1
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 1
69609: PUSH
69610: LD_INT 3
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 0
69619: PUSH
69620: LD_INT 3
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: LD_INT 2
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 2
69640: NEG
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 3
69651: NEG
69652: PUSH
69653: LD_INT 0
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 3
69662: NEG
69663: PUSH
69664: LD_INT 1
69666: NEG
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69703: LD_ADDR_VAR 0 47
69707: PUSH
69708: LD_INT 0
69710: PUSH
69711: LD_INT 0
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 0
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: LD_INT 0
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 0
69751: PUSH
69752: LD_INT 1
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 1
69772: NEG
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: NEG
69785: PUSH
69786: LD_INT 2
69788: NEG
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: LD_INT 1
69810: NEG
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 2
69818: NEG
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 2
69830: NEG
69831: PUSH
69832: LD_INT 2
69834: NEG
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69854: LD_ADDR_VAR 0 48
69858: PUSH
69859: LD_INT 0
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 0
69871: PUSH
69872: LD_INT 1
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: LD_INT 0
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: LD_INT 1
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 1
69912: NEG
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 2
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 0
69947: PUSH
69948: LD_INT 2
69950: NEG
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: LD_INT 1
69958: PUSH
69959: LD_INT 1
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 2
69969: PUSH
69970: LD_INT 0
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 2
69979: PUSH
69980: LD_INT 1
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70001: LD_ADDR_VAR 0 49
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: LD_INT 1
70021: NEG
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 0
70049: PUSH
70050: LD_INT 1
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 1
70059: NEG
70060: PUSH
70061: LD_INT 0
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 1
70070: NEG
70071: PUSH
70072: LD_INT 1
70074: NEG
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 1
70082: PUSH
70083: LD_INT 1
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 2
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 1
70123: PUSH
70124: LD_INT 2
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70145: LD_ADDR_VAR 0 50
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: LD_INT 0
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 0
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: LD_INT 1
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 1
70214: NEG
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 2
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 2
70236: PUSH
70237: LD_INT 2
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 2
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: LD_INT 2
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: LD_INT 1
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70289: LD_ADDR_VAR 0 51
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 0
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 0
70306: PUSH
70307: LD_INT 1
70309: NEG
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: PUSH
70328: LD_INT 1
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: LD_INT 1
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: LD_INT 1
70347: NEG
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: LD_INT 1
70362: NEG
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 1
70370: PUSH
70371: LD_INT 2
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 0
70380: PUSH
70381: LD_INT 2
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: LD_INT 1
70390: NEG
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 2
70401: NEG
70402: PUSH
70403: LD_INT 0
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 2
70412: NEG
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70436: LD_ADDR_VAR 0 52
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: LD_INT 0
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: LD_INT 1
70456: NEG
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: PUSH
70465: LD_INT 0
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: PUSH
70472: LD_INT 1
70474: PUSH
70475: LD_INT 1
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: LD_INT 1
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 1
70494: NEG
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: LD_INT 1
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 1
70517: NEG
70518: PUSH
70519: LD_INT 2
70521: NEG
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 1
70529: NEG
70530: PUSH
70531: LD_INT 1
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 2
70540: NEG
70541: PUSH
70542: LD_INT 0
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 2
70551: NEG
70552: PUSH
70553: LD_INT 1
70555: NEG
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 2
70563: NEG
70564: PUSH
70565: LD_INT 2
70567: NEG
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70587: LD_ADDR_VAR 0 53
70591: PUSH
70592: LD_INT 0
70594: PUSH
70595: LD_INT 0
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 0
70604: PUSH
70605: LD_INT 1
70607: NEG
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 1
70615: PUSH
70616: LD_INT 0
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: LD_INT 1
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 0
70635: PUSH
70636: LD_INT 1
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 1
70656: NEG
70657: PUSH
70658: LD_INT 1
70660: NEG
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 1
70668: NEG
70669: PUSH
70670: LD_INT 2
70672: NEG
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: LD_INT 2
70683: NEG
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 2
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: LD_INT 1
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 2
70722: PUSH
70723: LD_INT 2
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 2
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 0
70742: PUSH
70743: LD_INT 2
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 2
70763: NEG
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 2
70774: NEG
70775: PUSH
70776: LD_INT 1
70778: NEG
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 2
70786: NEG
70787: PUSH
70788: LD_INT 2
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70817: LD_ADDR_VAR 0 54
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 0
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 1
70886: NEG
70887: PUSH
70888: LD_INT 1
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 2
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 0
70910: PUSH
70911: LD_INT 2
70913: NEG
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 1
70921: PUSH
70922: LD_INT 1
70924: NEG
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: LD_INT 2
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 1
70962: PUSH
70963: LD_INT 2
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: LD_INT 2
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: NEG
70983: PUSH
70984: LD_INT 1
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 2
70993: NEG
70994: PUSH
70995: LD_INT 0
70997: PUSH
70998: EMPTY
70999: LIST
71000: LIST
71001: PUSH
71002: LD_INT 2
71004: NEG
71005: PUSH
71006: LD_INT 1
71008: NEG
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PUSH
71014: LD_INT 2
71016: NEG
71017: PUSH
71018: LD_INT 2
71020: NEG
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71047: LD_ADDR_VAR 0 55
71051: PUSH
71052: LD_INT 0
71054: PUSH
71055: LD_INT 0
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: LD_INT 1
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: PUSH
71076: LD_INT 0
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: LD_INT 1
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 0
71095: PUSH
71096: LD_INT 1
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 1
71116: NEG
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: NEG
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 0
71140: PUSH
71141: LD_INT 2
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 1
71151: PUSH
71152: LD_INT 1
71154: NEG
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 2
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 2
71172: PUSH
71173: LD_INT 1
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 2
71182: PUSH
71183: LD_INT 2
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 1
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 0
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 1
71212: NEG
71213: PUSH
71214: LD_INT 1
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: PUSH
71221: LD_INT 2
71223: NEG
71224: PUSH
71225: LD_INT 0
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 2
71234: NEG
71235: PUSH
71236: LD_INT 1
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 2
71246: NEG
71247: PUSH
71248: LD_INT 2
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71277: LD_ADDR_VAR 0 56
71281: PUSH
71282: LD_INT 0
71284: PUSH
71285: LD_INT 0
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 0
71294: PUSH
71295: LD_INT 1
71297: NEG
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 0
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 1
71315: PUSH
71316: LD_INT 1
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 0
71325: PUSH
71326: LD_INT 1
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: LD_INT 0
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: LD_INT 1
71350: NEG
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 1
71358: NEG
71359: PUSH
71360: LD_INT 2
71362: NEG
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 0
71370: PUSH
71371: LD_INT 2
71373: NEG
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 1
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: LD_INT 0
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 2
71402: PUSH
71403: LD_INT 1
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 2
71412: PUSH
71413: LD_INT 2
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: LD_INT 2
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 0
71432: PUSH
71433: LD_INT 2
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 1
71442: NEG
71443: PUSH
71444: LD_INT 1
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PUSH
71451: LD_INT 2
71453: NEG
71454: PUSH
71455: LD_INT 0
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: NEG
71465: PUSH
71466: LD_INT 1
71468: NEG
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 2
71476: NEG
71477: PUSH
71478: LD_INT 2
71480: NEG
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71507: LD_ADDR_VAR 0 57
71511: PUSH
71512: LD_INT 0
71514: PUSH
71515: LD_INT 0
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 0
71524: PUSH
71525: LD_INT 1
71527: NEG
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: LD_INT 0
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: LD_INT 1
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 0
71555: PUSH
71556: LD_INT 1
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 1
71576: NEG
71577: PUSH
71578: LD_INT 1
71580: NEG
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 1
71588: NEG
71589: PUSH
71590: LD_INT 2
71592: NEG
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 0
71600: PUSH
71601: LD_INT 2
71603: NEG
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 1
71611: PUSH
71612: LD_INT 1
71614: NEG
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 2
71622: PUSH
71623: LD_INT 0
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 2
71632: PUSH
71633: LD_INT 1
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 2
71642: PUSH
71643: LD_INT 2
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 2
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: LD_INT 2
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: LD_INT 1
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 2
71683: NEG
71684: PUSH
71685: LD_INT 0
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 2
71694: NEG
71695: PUSH
71696: LD_INT 1
71698: NEG
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: LD_INT 2
71706: NEG
71707: PUSH
71708: LD_INT 2
71710: NEG
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71737: LD_ADDR_VAR 0 58
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: LD_INT 0
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: LD_INT 1
71757: NEG
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 0
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: LD_INT 1
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: LD_INT 1
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: LD_INT 0
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: LD_INT 2
71822: NEG
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 0
71830: PUSH
71831: LD_INT 2
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: LD_INT 1
71844: NEG
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 2
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 2
71862: PUSH
71863: LD_INT 1
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 2
71872: PUSH
71873: LD_INT 2
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: PUSH
71883: LD_INT 2
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: LD_INT 2
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: NEG
71903: PUSH
71904: LD_INT 1
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 2
71913: NEG
71914: PUSH
71915: LD_INT 0
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 2
71924: NEG
71925: PUSH
71926: LD_INT 1
71928: NEG
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 2
71936: NEG
71937: PUSH
71938: LD_INT 2
71940: NEG
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71967: LD_ADDR_VAR 0 59
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 0
71984: PUSH
71985: LD_INT 1
71987: NEG
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: LD_INT 0
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 1
72005: PUSH
72006: LD_INT 1
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: PUSH
72027: LD_INT 0
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 1
72036: NEG
72037: PUSH
72038: LD_INT 1
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72055: LD_ADDR_VAR 0 60
72059: PUSH
72060: LD_INT 0
72062: PUSH
72063: LD_INT 0
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: LD_INT 1
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: LD_INT 0
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: LD_INT 1
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: NEG
72114: PUSH
72115: LD_INT 0
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: NEG
72125: PUSH
72126: LD_INT 1
72128: NEG
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72143: LD_ADDR_VAR 0 61
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 0
72160: PUSH
72161: LD_INT 1
72163: NEG
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: PUSH
72172: LD_INT 0
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 1
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 0
72191: PUSH
72192: LD_INT 1
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 1
72201: NEG
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: LD_INT 1
72216: NEG
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72231: LD_ADDR_VAR 0 62
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 1
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72319: LD_ADDR_VAR 0 63
72323: PUSH
72324: LD_INT 0
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 0
72336: PUSH
72337: LD_INT 1
72339: NEG
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: PUSH
72345: LD_INT 1
72347: PUSH
72348: LD_INT 0
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: LD_INT 1
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 0
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 1
72377: NEG
72378: PUSH
72379: LD_INT 0
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: LD_INT 1
72392: NEG
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72407: LD_ADDR_VAR 0 64
72411: PUSH
72412: LD_INT 0
72414: PUSH
72415: LD_INT 0
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 1
72427: NEG
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 1
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: LD_INT 1
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: LD_INT 0
72455: PUSH
72456: LD_INT 1
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: PUSH
72463: LD_INT 1
72465: NEG
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 1
72476: NEG
72477: PUSH
72478: LD_INT 1
72480: NEG
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: ST_TO_ADDR
// end ; 1 :
72495: GO 78392
72497: LD_INT 1
72499: DOUBLE
72500: EQUAL
72501: IFTRUE 72505
72503: GO 75128
72505: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72506: LD_ADDR_VAR 0 11
72510: PUSH
72511: LD_INT 1
72513: NEG
72514: PUSH
72515: LD_INT 3
72517: NEG
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 0
72525: PUSH
72526: LD_INT 3
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: PUSH
72537: LD_INT 2
72539: NEG
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: LIST
72549: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72550: LD_ADDR_VAR 0 12
72554: PUSH
72555: LD_INT 2
72557: PUSH
72558: LD_INT 1
72560: NEG
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 3
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 3
72578: PUSH
72579: LD_INT 1
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: LIST
72590: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72591: LD_ADDR_VAR 0 13
72595: PUSH
72596: LD_INT 3
72598: PUSH
72599: LD_INT 2
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 3
72608: PUSH
72609: LD_INT 3
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 2
72618: PUSH
72619: LD_INT 3
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: LIST
72630: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72631: LD_ADDR_VAR 0 14
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 3
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 0
72648: PUSH
72649: LD_INT 3
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 1
72658: NEG
72659: PUSH
72660: LD_INT 2
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: LIST
72671: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72672: LD_ADDR_VAR 0 15
72676: PUSH
72677: LD_INT 2
72679: NEG
72680: PUSH
72681: LD_INT 1
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 3
72690: NEG
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 3
72701: NEG
72702: PUSH
72703: LD_INT 1
72705: NEG
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: LIST
72715: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72716: LD_ADDR_VAR 0 16
72720: PUSH
72721: LD_INT 2
72723: NEG
72724: PUSH
72725: LD_INT 3
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 3
72735: NEG
72736: PUSH
72737: LD_INT 2
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 3
72747: NEG
72748: PUSH
72749: LD_INT 3
72751: NEG
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: LIST
72761: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72762: LD_ADDR_VAR 0 17
72766: PUSH
72767: LD_INT 1
72769: NEG
72770: PUSH
72771: LD_INT 3
72773: NEG
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: LD_INT 3
72784: NEG
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: LD_INT 1
72792: PUSH
72793: LD_INT 2
72795: NEG
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: LIST
72805: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72806: LD_ADDR_VAR 0 18
72810: PUSH
72811: LD_INT 2
72813: PUSH
72814: LD_INT 1
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 3
72824: PUSH
72825: LD_INT 0
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 3
72834: PUSH
72835: LD_INT 1
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: LIST
72846: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72847: LD_ADDR_VAR 0 19
72851: PUSH
72852: LD_INT 3
72854: PUSH
72855: LD_INT 2
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 3
72864: PUSH
72865: LD_INT 3
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 2
72874: PUSH
72875: LD_INT 3
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: LIST
72886: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72887: LD_ADDR_VAR 0 20
72891: PUSH
72892: LD_INT 1
72894: PUSH
72895: LD_INT 3
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 0
72904: PUSH
72905: LD_INT 3
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 1
72914: NEG
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: LIST
72927: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72928: LD_ADDR_VAR 0 21
72932: PUSH
72933: LD_INT 2
72935: NEG
72936: PUSH
72937: LD_INT 1
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 3
72946: NEG
72947: PUSH
72948: LD_INT 0
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 3
72957: NEG
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: LIST
72971: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72972: LD_ADDR_VAR 0 22
72976: PUSH
72977: LD_INT 2
72979: NEG
72980: PUSH
72981: LD_INT 3
72983: NEG
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 3
72991: NEG
72992: PUSH
72993: LD_INT 2
72995: NEG
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 3
73003: NEG
73004: PUSH
73005: LD_INT 3
73007: NEG
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: LIST
73017: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
73018: LD_ADDR_VAR 0 23
73022: PUSH
73023: LD_INT 0
73025: PUSH
73026: LD_INT 3
73028: NEG
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 1
73036: NEG
73037: PUSH
73038: LD_INT 4
73040: NEG
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 1
73048: PUSH
73049: LD_INT 3
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: LIST
73061: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
73062: LD_ADDR_VAR 0 24
73066: PUSH
73067: LD_INT 3
73069: PUSH
73070: LD_INT 0
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 3
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 4
73090: PUSH
73091: LD_INT 1
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: LIST
73102: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
73103: LD_ADDR_VAR 0 25
73107: PUSH
73108: LD_INT 3
73110: PUSH
73111: LD_INT 3
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 4
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 3
73130: PUSH
73131: LD_INT 4
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: LIST
73142: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73143: LD_ADDR_VAR 0 26
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: LD_INT 3
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 1
73160: PUSH
73161: LD_INT 4
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: NEG
73171: PUSH
73172: LD_INT 3
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: LIST
73183: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73184: LD_ADDR_VAR 0 27
73188: PUSH
73189: LD_INT 3
73191: NEG
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 3
73202: NEG
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 4
73213: NEG
73214: PUSH
73215: LD_INT 1
73217: NEG
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: LIST
73227: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73228: LD_ADDR_VAR 0 28
73232: PUSH
73233: LD_INT 3
73235: NEG
73236: PUSH
73237: LD_INT 3
73239: NEG
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 3
73247: NEG
73248: PUSH
73249: LD_INT 4
73251: NEG
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 4
73259: NEG
73260: PUSH
73261: LD_INT 3
73263: NEG
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: LIST
73273: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73274: LD_ADDR_VAR 0 29
73278: PUSH
73279: LD_INT 1
73281: NEG
73282: PUSH
73283: LD_INT 3
73285: NEG
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: LD_INT 3
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: PUSH
73305: LD_INT 2
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: LD_INT 4
73319: NEG
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: LD_INT 4
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: LD_INT 3
73341: NEG
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 1
73349: NEG
73350: PUSH
73351: LD_INT 5
73353: NEG
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 0
73361: PUSH
73362: LD_INT 5
73364: NEG
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 1
73372: PUSH
73373: LD_INT 4
73375: NEG
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 1
73383: NEG
73384: PUSH
73385: LD_INT 6
73387: NEG
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: LD_INT 6
73398: NEG
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: PUSH
73404: LD_INT 1
73406: PUSH
73407: LD_INT 5
73409: NEG
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73429: LD_ADDR_VAR 0 30
73433: PUSH
73434: LD_INT 2
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 3
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 3
73457: PUSH
73458: LD_INT 1
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 3
73467: PUSH
73468: LD_INT 1
73470: NEG
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 4
73478: PUSH
73479: LD_INT 0
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 4
73488: PUSH
73489: LD_INT 1
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 4
73498: PUSH
73499: LD_INT 1
73501: NEG
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 5
73509: PUSH
73510: LD_INT 0
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 5
73519: PUSH
73520: LD_INT 1
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 5
73529: PUSH
73530: LD_INT 1
73532: NEG
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 6
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 6
73550: PUSH
73551: LD_INT 1
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73572: LD_ADDR_VAR 0 31
73576: PUSH
73577: LD_INT 3
73579: PUSH
73580: LD_INT 2
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 3
73589: PUSH
73590: LD_INT 3
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 2
73599: PUSH
73600: LD_INT 3
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 4
73609: PUSH
73610: LD_INT 3
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 4
73619: PUSH
73620: LD_INT 4
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 3
73629: PUSH
73630: LD_INT 4
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 5
73639: PUSH
73640: LD_INT 4
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 5
73649: PUSH
73650: LD_INT 5
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 4
73659: PUSH
73660: LD_INT 5
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 6
73669: PUSH
73670: LD_INT 5
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 6
73679: PUSH
73680: LD_INT 6
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 5
73689: PUSH
73690: LD_INT 6
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
73711: LD_ADDR_VAR 0 32
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: LD_INT 3
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: LD_INT 3
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 1
73738: NEG
73739: PUSH
73740: LD_INT 2
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 1
73749: PUSH
73750: LD_INT 4
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: LD_INT 4
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: PUSH
73767: LD_INT 1
73769: NEG
73770: PUSH
73771: LD_INT 3
73773: PUSH
73774: EMPTY
73775: LIST
73776: LIST
73777: PUSH
73778: LD_INT 1
73780: PUSH
73781: LD_INT 5
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 0
73790: PUSH
73791: LD_INT 5
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: LD_INT 4
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 1
73811: PUSH
73812: LD_INT 6
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 0
73821: PUSH
73822: LD_INT 6
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: NEG
73832: PUSH
73833: LD_INT 5
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
73854: LD_ADDR_VAR 0 33
73858: PUSH
73859: LD_INT 2
73861: NEG
73862: PUSH
73863: LD_INT 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 3
73872: NEG
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 3
73883: NEG
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 3
73895: NEG
73896: PUSH
73897: LD_INT 1
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 4
73906: NEG
73907: PUSH
73908: LD_INT 0
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 4
73917: NEG
73918: PUSH
73919: LD_INT 1
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 4
73929: NEG
73930: PUSH
73931: LD_INT 1
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 5
73940: NEG
73941: PUSH
73942: LD_INT 0
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 5
73951: NEG
73952: PUSH
73953: LD_INT 1
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 5
73963: NEG
73964: PUSH
73965: LD_INT 1
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 6
73974: NEG
73975: PUSH
73976: LD_INT 0
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 6
73985: NEG
73986: PUSH
73987: LD_INT 1
73989: NEG
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
74009: LD_ADDR_VAR 0 34
74013: PUSH
74014: LD_INT 2
74016: NEG
74017: PUSH
74018: LD_INT 3
74020: NEG
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: LD_INT 3
74028: NEG
74029: PUSH
74030: LD_INT 2
74032: NEG
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PUSH
74038: LD_INT 3
74040: NEG
74041: PUSH
74042: LD_INT 3
74044: NEG
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 3
74052: NEG
74053: PUSH
74054: LD_INT 4
74056: NEG
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 4
74064: NEG
74065: PUSH
74066: LD_INT 3
74068: NEG
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 4
74076: NEG
74077: PUSH
74078: LD_INT 4
74080: NEG
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 4
74088: NEG
74089: PUSH
74090: LD_INT 5
74092: NEG
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 5
74100: NEG
74101: PUSH
74102: LD_INT 4
74104: NEG
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 5
74112: NEG
74113: PUSH
74114: LD_INT 5
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 5
74124: NEG
74125: PUSH
74126: LD_INT 6
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 6
74136: NEG
74137: PUSH
74138: LD_INT 5
74140: NEG
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 6
74148: NEG
74149: PUSH
74150: LD_INT 6
74152: NEG
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74172: LD_ADDR_VAR 0 41
74176: PUSH
74177: LD_INT 0
74179: PUSH
74180: LD_INT 2
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 1
74190: NEG
74191: PUSH
74192: LD_INT 3
74194: NEG
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 1
74202: PUSH
74203: LD_INT 2
74205: NEG
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: LIST
74215: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74216: LD_ADDR_VAR 0 42
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: LD_INT 0
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: LD_INT 1
74236: NEG
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 3
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: LIST
74256: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74257: LD_ADDR_VAR 0 43
74261: PUSH
74262: LD_INT 2
74264: PUSH
74265: LD_INT 2
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 3
74274: PUSH
74275: LD_INT 2
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 2
74284: PUSH
74285: LD_INT 3
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: LIST
74296: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74297: LD_ADDR_VAR 0 44
74301: PUSH
74302: LD_INT 0
74304: PUSH
74305: LD_INT 2
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 1
74314: PUSH
74315: LD_INT 3
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 1
74324: NEG
74325: PUSH
74326: LD_INT 2
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74338: LD_ADDR_VAR 0 45
74342: PUSH
74343: LD_INT 2
74345: NEG
74346: PUSH
74347: LD_INT 0
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 2
74356: NEG
74357: PUSH
74358: LD_INT 1
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 3
74367: NEG
74368: PUSH
74369: LD_INT 1
74371: NEG
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: LIST
74381: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74382: LD_ADDR_VAR 0 46
74386: PUSH
74387: LD_INT 2
74389: NEG
74390: PUSH
74391: LD_INT 2
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 2
74401: NEG
74402: PUSH
74403: LD_INT 3
74405: NEG
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: LD_INT 3
74413: NEG
74414: PUSH
74415: LD_INT 2
74417: NEG
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: LIST
74427: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74428: LD_ADDR_VAR 0 47
74432: PUSH
74433: LD_INT 2
74435: NEG
74436: PUSH
74437: LD_INT 3
74439: NEG
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: NEG
74448: PUSH
74449: LD_INT 3
74451: NEG
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74461: LD_ADDR_VAR 0 48
74465: PUSH
74466: LD_INT 1
74468: PUSH
74469: LD_INT 2
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 2
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74492: LD_ADDR_VAR 0 49
74496: PUSH
74497: LD_INT 3
74499: PUSH
74500: LD_INT 1
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 3
74509: PUSH
74510: LD_INT 2
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74521: LD_ADDR_VAR 0 50
74525: PUSH
74526: LD_INT 2
74528: PUSH
74529: LD_INT 3
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 1
74538: PUSH
74539: LD_INT 3
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74550: LD_ADDR_VAR 0 51
74554: PUSH
74555: LD_INT 1
74557: NEG
74558: PUSH
74559: LD_INT 2
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 2
74568: NEG
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74581: LD_ADDR_VAR 0 52
74585: PUSH
74586: LD_INT 3
74588: NEG
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 3
74600: NEG
74601: PUSH
74602: LD_INT 2
74604: NEG
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74614: LD_ADDR_VAR 0 53
74618: PUSH
74619: LD_INT 1
74621: NEG
74622: PUSH
74623: LD_INT 3
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 0
74633: PUSH
74634: LD_INT 3
74636: NEG
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 1
74644: PUSH
74645: LD_INT 2
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: LIST
74657: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74658: LD_ADDR_VAR 0 54
74662: PUSH
74663: LD_INT 2
74665: PUSH
74666: LD_INT 1
74668: NEG
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 3
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 3
74686: PUSH
74687: LD_INT 1
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: LIST
74698: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74699: LD_ADDR_VAR 0 55
74703: PUSH
74704: LD_INT 3
74706: PUSH
74707: LD_INT 2
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 3
74716: PUSH
74717: LD_INT 3
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 2
74726: PUSH
74727: LD_INT 3
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: LIST
74738: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74739: LD_ADDR_VAR 0 56
74743: PUSH
74744: LD_INT 1
74746: PUSH
74747: LD_INT 3
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: LD_INT 0
74756: PUSH
74757: LD_INT 3
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 1
74766: NEG
74767: PUSH
74768: LD_INT 2
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: LIST
74779: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74780: LD_ADDR_VAR 0 57
74784: PUSH
74785: LD_INT 2
74787: NEG
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 3
74798: NEG
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 3
74809: NEG
74810: PUSH
74811: LD_INT 1
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: LIST
74823: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74824: LD_ADDR_VAR 0 58
74828: PUSH
74829: LD_INT 2
74831: NEG
74832: PUSH
74833: LD_INT 3
74835: NEG
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 3
74843: NEG
74844: PUSH
74845: LD_INT 2
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 3
74855: NEG
74856: PUSH
74857: LD_INT 3
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: LIST
74869: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
74870: LD_ADDR_VAR 0 59
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 2
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 2
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 1
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: LIST
74913: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74914: LD_ADDR_VAR 0 60
74918: PUSH
74919: LD_INT 1
74921: PUSH
74922: LD_INT 1
74924: NEG
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 2
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 2
74942: PUSH
74943: LD_INT 1
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: LIST
74954: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74955: LD_ADDR_VAR 0 61
74959: PUSH
74960: LD_INT 2
74962: PUSH
74963: LD_INT 1
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 2
74972: PUSH
74973: LD_INT 2
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 1
74982: PUSH
74983: LD_INT 2
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: LIST
74994: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74995: LD_ADDR_VAR 0 62
74999: PUSH
75000: LD_INT 1
75002: PUSH
75003: LD_INT 2
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: LD_INT 2
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 1
75022: NEG
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: LIST
75035: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75036: LD_ADDR_VAR 0 63
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: LD_INT 1
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 2
75054: NEG
75055: PUSH
75056: LD_INT 0
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 2
75065: NEG
75066: PUSH
75067: LD_INT 1
75069: NEG
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: LIST
75079: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75080: LD_ADDR_VAR 0 64
75084: PUSH
75085: LD_INT 1
75087: NEG
75088: PUSH
75089: LD_INT 2
75091: NEG
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 2
75099: NEG
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 2
75111: NEG
75112: PUSH
75113: LD_INT 2
75115: NEG
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: LIST
75125: ST_TO_ADDR
// end ; 2 :
75126: GO 78392
75128: LD_INT 2
75130: DOUBLE
75131: EQUAL
75132: IFTRUE 75136
75134: GO 78391
75136: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75137: LD_ADDR_VAR 0 29
75141: PUSH
75142: LD_INT 4
75144: PUSH
75145: LD_INT 0
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 4
75154: PUSH
75155: LD_INT 1
75157: NEG
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 5
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 5
75175: PUSH
75176: LD_INT 1
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 4
75185: PUSH
75186: LD_INT 1
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 3
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: LD_INT 1
75208: NEG
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 3
75216: PUSH
75217: LD_INT 2
75219: NEG
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 5
75227: PUSH
75228: LD_INT 2
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 3
75237: PUSH
75238: LD_INT 3
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 3
75247: PUSH
75248: LD_INT 2
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 4
75257: PUSH
75258: LD_INT 3
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 4
75267: PUSH
75268: LD_INT 4
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 3
75277: PUSH
75278: LD_INT 4
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 2
75287: PUSH
75288: LD_INT 3
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: LD_INT 2
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 4
75307: PUSH
75308: LD_INT 2
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 2
75317: PUSH
75318: LD_INT 4
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 4
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 0
75337: PUSH
75338: LD_INT 3
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 4
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: PUSH
75358: LD_INT 5
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 0
75367: PUSH
75368: LD_INT 5
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 1
75377: NEG
75378: PUSH
75379: LD_INT 4
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 1
75388: NEG
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 2
75399: PUSH
75400: LD_INT 5
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 2
75409: NEG
75410: PUSH
75411: LD_INT 3
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 3
75420: NEG
75421: PUSH
75422: LD_INT 0
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 3
75431: NEG
75432: PUSH
75433: LD_INT 1
75435: NEG
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 2
75443: NEG
75444: PUSH
75445: LD_INT 0
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 2
75454: NEG
75455: PUSH
75456: LD_INT 1
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 3
75465: NEG
75466: PUSH
75467: LD_INT 1
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 4
75476: NEG
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 4
75487: NEG
75488: PUSH
75489: LD_INT 1
75491: NEG
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: LD_INT 4
75499: NEG
75500: PUSH
75501: LD_INT 2
75503: NEG
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 2
75511: NEG
75512: PUSH
75513: LD_INT 2
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 4
75522: NEG
75523: PUSH
75524: LD_INT 4
75526: NEG
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 4
75534: NEG
75535: PUSH
75536: LD_INT 5
75538: NEG
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 3
75546: NEG
75547: PUSH
75548: LD_INT 4
75550: NEG
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 3
75558: NEG
75559: PUSH
75560: LD_INT 3
75562: NEG
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 4
75570: NEG
75571: PUSH
75572: LD_INT 3
75574: NEG
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 5
75582: NEG
75583: PUSH
75584: LD_INT 4
75586: NEG
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 5
75594: NEG
75595: PUSH
75596: LD_INT 5
75598: NEG
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 3
75606: NEG
75607: PUSH
75608: LD_INT 5
75610: NEG
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 5
75618: NEG
75619: PUSH
75620: LD_INT 3
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: LIST
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
75675: LD_ADDR_VAR 0 30
75679: PUSH
75680: LD_INT 4
75682: PUSH
75683: LD_INT 4
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 4
75692: PUSH
75693: LD_INT 3
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 5
75702: PUSH
75703: LD_INT 4
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 5
75712: PUSH
75713: LD_INT 5
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 4
75722: PUSH
75723: LD_INT 5
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 3
75732: PUSH
75733: LD_INT 4
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 3
75742: PUSH
75743: LD_INT 3
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 5
75752: PUSH
75753: LD_INT 3
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 3
75762: PUSH
75763: LD_INT 5
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 0
75772: PUSH
75773: LD_INT 3
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 0
75782: PUSH
75783: LD_INT 2
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 1
75792: PUSH
75793: LD_INT 3
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: LD_INT 1
75802: PUSH
75803: LD_INT 4
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: LD_INT 4
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: LD_INT 1
75822: NEG
75823: PUSH
75824: LD_INT 3
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 1
75833: NEG
75834: PUSH
75835: LD_INT 2
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 2
75844: PUSH
75845: LD_INT 4
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 4
75865: NEG
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 4
75876: NEG
75877: PUSH
75878: LD_INT 1
75880: NEG
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 3
75888: NEG
75889: PUSH
75890: LD_INT 0
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 3
75899: NEG
75900: PUSH
75901: LD_INT 1
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 4
75910: NEG
75911: PUSH
75912: LD_INT 1
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 5
75921: NEG
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 5
75932: NEG
75933: PUSH
75934: LD_INT 1
75936: NEG
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 5
75944: NEG
75945: PUSH
75946: LD_INT 2
75948: NEG
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 3
75956: NEG
75957: PUSH
75958: LD_INT 2
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: LD_INT 3
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 3
75979: NEG
75980: PUSH
75981: LD_INT 4
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 2
75991: NEG
75992: PUSH
75993: LD_INT 3
75995: NEG
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 2
76003: NEG
76004: PUSH
76005: LD_INT 2
76007: NEG
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 3
76015: NEG
76016: PUSH
76017: LD_INT 2
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 4
76027: NEG
76028: PUSH
76029: LD_INT 3
76031: NEG
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 4
76039: NEG
76040: PUSH
76041: LD_INT 4
76043: NEG
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 2
76051: NEG
76052: PUSH
76053: LD_INT 4
76055: NEG
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 4
76063: NEG
76064: PUSH
76065: LD_INT 2
76067: NEG
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 4
76078: NEG
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 0
76086: PUSH
76087: LD_INT 5
76089: NEG
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 1
76097: PUSH
76098: LD_INT 4
76100: NEG
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 1
76108: PUSH
76109: LD_INT 3
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 0
76119: PUSH
76120: LD_INT 3
76122: NEG
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 1
76130: NEG
76131: PUSH
76132: LD_INT 4
76134: NEG
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 1
76142: NEG
76143: PUSH
76144: LD_INT 5
76146: NEG
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 2
76154: PUSH
76155: LD_INT 3
76157: NEG
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 2
76165: NEG
76166: PUSH
76167: LD_INT 5
76169: NEG
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76222: LD_ADDR_VAR 0 31
76226: PUSH
76227: LD_INT 0
76229: PUSH
76230: LD_INT 4
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 0
76239: PUSH
76240: LD_INT 3
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 1
76249: PUSH
76250: LD_INT 4
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 1
76259: PUSH
76260: LD_INT 5
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 0
76269: PUSH
76270: LD_INT 5
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 1
76279: NEG
76280: PUSH
76281: LD_INT 4
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 1
76290: NEG
76291: PUSH
76292: LD_INT 3
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 2
76301: PUSH
76302: LD_INT 5
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 2
76311: NEG
76312: PUSH
76313: LD_INT 3
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 3
76322: NEG
76323: PUSH
76324: LD_INT 0
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 3
76333: NEG
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 2
76345: NEG
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 2
76356: NEG
76357: PUSH
76358: LD_INT 1
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 3
76367: NEG
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 4
76378: NEG
76379: PUSH
76380: LD_INT 0
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 4
76389: NEG
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 4
76401: NEG
76402: PUSH
76403: LD_INT 2
76405: NEG
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 2
76413: NEG
76414: PUSH
76415: LD_INT 2
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: LD_INT 4
76424: NEG
76425: PUSH
76426: LD_INT 4
76428: NEG
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 4
76436: NEG
76437: PUSH
76438: LD_INT 5
76440: NEG
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 3
76448: NEG
76449: PUSH
76450: LD_INT 4
76452: NEG
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: LD_INT 3
76460: NEG
76461: PUSH
76462: LD_INT 3
76464: NEG
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 4
76472: NEG
76473: PUSH
76474: LD_INT 3
76476: NEG
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 5
76484: NEG
76485: PUSH
76486: LD_INT 4
76488: NEG
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 5
76496: NEG
76497: PUSH
76498: LD_INT 5
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 3
76508: NEG
76509: PUSH
76510: LD_INT 5
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 5
76520: NEG
76521: PUSH
76522: LD_INT 3
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 0
76532: PUSH
76533: LD_INT 3
76535: NEG
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 0
76543: PUSH
76544: LD_INT 4
76546: NEG
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 1
76554: PUSH
76555: LD_INT 3
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: LD_INT 2
76568: NEG
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 0
76576: PUSH
76577: LD_INT 2
76579: NEG
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 1
76587: NEG
76588: PUSH
76589: LD_INT 3
76591: NEG
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 1
76599: NEG
76600: PUSH
76601: LD_INT 4
76603: NEG
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 2
76611: PUSH
76612: LD_INT 2
76614: NEG
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 2
76622: NEG
76623: PUSH
76624: LD_INT 4
76626: NEG
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: LD_INT 4
76634: PUSH
76635: LD_INT 0
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 4
76644: PUSH
76645: LD_INT 1
76647: NEG
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 5
76655: PUSH
76656: LD_INT 0
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 5
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 4
76675: PUSH
76676: LD_INT 1
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: LD_INT 3
76685: PUSH
76686: LD_INT 0
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 3
76695: PUSH
76696: LD_INT 1
76698: NEG
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 3
76706: PUSH
76707: LD_INT 2
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 5
76717: PUSH
76718: LD_INT 2
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: LIST
76729: LIST
76730: LIST
76731: LIST
76732: LIST
76733: LIST
76734: LIST
76735: LIST
76736: LIST
76737: LIST
76738: LIST
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
76772: LD_ADDR_VAR 0 32
76776: PUSH
76777: LD_INT 4
76779: NEG
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 4
76790: NEG
76791: PUSH
76792: LD_INT 1
76794: NEG
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 3
76802: NEG
76803: PUSH
76804: LD_INT 0
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 3
76813: NEG
76814: PUSH
76815: LD_INT 1
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 4
76824: NEG
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 5
76835: NEG
76836: PUSH
76837: LD_INT 0
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 5
76846: NEG
76847: PUSH
76848: LD_INT 1
76850: NEG
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: LD_INT 5
76858: NEG
76859: PUSH
76860: LD_INT 2
76862: NEG
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PUSH
76868: LD_INT 3
76870: NEG
76871: PUSH
76872: LD_INT 2
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: LD_INT 3
76881: NEG
76882: PUSH
76883: LD_INT 3
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 3
76893: NEG
76894: PUSH
76895: LD_INT 4
76897: NEG
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: LD_INT 3
76909: NEG
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 2
76917: NEG
76918: PUSH
76919: LD_INT 2
76921: NEG
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 3
76929: NEG
76930: PUSH
76931: LD_INT 2
76933: NEG
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 4
76941: NEG
76942: PUSH
76943: LD_INT 3
76945: NEG
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 4
76953: NEG
76954: PUSH
76955: LD_INT 4
76957: NEG
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: LD_INT 4
76969: NEG
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 4
76977: NEG
76978: PUSH
76979: LD_INT 2
76981: NEG
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 0
76989: PUSH
76990: LD_INT 4
76992: NEG
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: LD_INT 0
77000: PUSH
77001: LD_INT 5
77003: NEG
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 1
77011: PUSH
77012: LD_INT 4
77014: NEG
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: PUSH
77023: LD_INT 3
77025: NEG
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 0
77033: PUSH
77034: LD_INT 3
77036: NEG
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: LD_INT 1
77044: NEG
77045: PUSH
77046: LD_INT 4
77048: NEG
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 1
77056: NEG
77057: PUSH
77058: LD_INT 5
77060: NEG
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 2
77068: PUSH
77069: LD_INT 3
77071: NEG
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 2
77079: NEG
77080: PUSH
77081: LD_INT 5
77083: NEG
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 3
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 3
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 4
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 4
77122: PUSH
77123: LD_INT 1
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 3
77132: PUSH
77133: LD_INT 1
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 2
77142: PUSH
77143: LD_INT 0
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 2
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 2
77163: PUSH
77164: LD_INT 2
77166: NEG
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 4
77174: PUSH
77175: LD_INT 2
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 4
77184: PUSH
77185: LD_INT 4
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 4
77194: PUSH
77195: LD_INT 3
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 5
77204: PUSH
77205: LD_INT 4
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 5
77214: PUSH
77215: LD_INT 5
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 4
77224: PUSH
77225: LD_INT 5
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 3
77234: PUSH
77235: LD_INT 4
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 3
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 5
77254: PUSH
77255: LD_INT 3
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 3
77264: PUSH
77265: LD_INT 5
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77319: LD_ADDR_VAR 0 33
77323: PUSH
77324: LD_INT 4
77326: NEG
77327: PUSH
77328: LD_INT 4
77330: NEG
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 4
77338: NEG
77339: PUSH
77340: LD_INT 5
77342: NEG
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 3
77350: NEG
77351: PUSH
77352: LD_INT 4
77354: NEG
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 3
77362: NEG
77363: PUSH
77364: LD_INT 3
77366: NEG
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 4
77374: NEG
77375: PUSH
77376: LD_INT 3
77378: NEG
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 5
77386: NEG
77387: PUSH
77388: LD_INT 4
77390: NEG
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 5
77398: NEG
77399: PUSH
77400: LD_INT 5
77402: NEG
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 3
77410: NEG
77411: PUSH
77412: LD_INT 5
77414: NEG
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 5
77422: NEG
77423: PUSH
77424: LD_INT 3
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: LD_INT 3
77437: NEG
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 0
77445: PUSH
77446: LD_INT 4
77448: NEG
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 1
77456: PUSH
77457: LD_INT 3
77459: NEG
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 1
77467: PUSH
77468: LD_INT 2
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: LD_INT 2
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: NEG
77490: PUSH
77491: LD_INT 3
77493: NEG
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 1
77501: NEG
77502: PUSH
77503: LD_INT 4
77505: NEG
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 2
77513: PUSH
77514: LD_INT 2
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 2
77524: NEG
77525: PUSH
77526: LD_INT 4
77528: NEG
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 4
77536: PUSH
77537: LD_INT 0
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 4
77546: PUSH
77547: LD_INT 1
77549: NEG
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 5
77557: PUSH
77558: LD_INT 0
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 5
77567: PUSH
77568: LD_INT 1
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 4
77577: PUSH
77578: LD_INT 1
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 3
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 3
77597: PUSH
77598: LD_INT 1
77600: NEG
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 3
77608: PUSH
77609: LD_INT 2
77611: NEG
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 5
77619: PUSH
77620: LD_INT 2
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 3
77629: PUSH
77630: LD_INT 3
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 3
77639: PUSH
77640: LD_INT 2
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 4
77649: PUSH
77650: LD_INT 3
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 4
77659: PUSH
77660: LD_INT 4
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 3
77669: PUSH
77670: LD_INT 4
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 2
77679: PUSH
77680: LD_INT 3
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 2
77689: PUSH
77690: LD_INT 2
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 4
77699: PUSH
77700: LD_INT 2
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 2
77709: PUSH
77710: LD_INT 4
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 0
77719: PUSH
77720: LD_INT 4
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 0
77729: PUSH
77730: LD_INT 3
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 1
77739: PUSH
77740: LD_INT 4
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: LD_INT 5
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 0
77759: PUSH
77760: LD_INT 5
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 1
77769: NEG
77770: PUSH
77771: LD_INT 4
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 1
77780: NEG
77781: PUSH
77782: LD_INT 3
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 2
77791: PUSH
77792: LD_INT 5
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: NEG
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
77857: LD_ADDR_VAR 0 34
77861: PUSH
77862: LD_INT 0
77864: PUSH
77865: LD_INT 4
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: LD_INT 5
77878: NEG
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 4
77889: NEG
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 3
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: LD_INT 4
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 1
77931: NEG
77932: PUSH
77933: LD_INT 5
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: LD_INT 3
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: LD_INT 5
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 3
77966: PUSH
77967: LD_INT 0
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 3
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 4
77987: PUSH
77988: LD_INT 0
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 4
77997: PUSH
77998: LD_INT 1
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 3
78007: PUSH
78008: LD_INT 1
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 2
78017: PUSH
78018: LD_INT 0
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 2
78027: PUSH
78028: LD_INT 1
78030: NEG
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 2
78038: PUSH
78039: LD_INT 2
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 4
78049: PUSH
78050: LD_INT 2
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 4
78059: PUSH
78060: LD_INT 4
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 4
78069: PUSH
78070: LD_INT 3
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 5
78079: PUSH
78080: LD_INT 4
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 5
78089: PUSH
78090: LD_INT 5
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 4
78099: PUSH
78100: LD_INT 5
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 3
78109: PUSH
78110: LD_INT 4
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: LD_INT 3
78119: PUSH
78120: LD_INT 3
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 5
78129: PUSH
78130: LD_INT 3
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 3
78139: PUSH
78140: LD_INT 5
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 0
78149: PUSH
78150: LD_INT 3
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 0
78159: PUSH
78160: LD_INT 2
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 1
78169: PUSH
78170: LD_INT 3
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: PUSH
78180: LD_INT 4
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 0
78189: PUSH
78190: LD_INT 4
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: LD_INT 1
78199: NEG
78200: PUSH
78201: LD_INT 3
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 1
78210: NEG
78211: PUSH
78212: LD_INT 2
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: LD_INT 2
78221: PUSH
78222: LD_INT 4
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 2
78231: NEG
78232: PUSH
78233: LD_INT 2
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 4
78242: NEG
78243: PUSH
78244: LD_INT 0
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 4
78253: NEG
78254: PUSH
78255: LD_INT 1
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 3
78265: NEG
78266: PUSH
78267: LD_INT 0
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 3
78276: NEG
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 4
78287: NEG
78288: PUSH
78289: LD_INT 1
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 5
78298: NEG
78299: PUSH
78300: LD_INT 0
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 5
78309: NEG
78310: PUSH
78311: LD_INT 1
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 5
78321: NEG
78322: PUSH
78323: LD_INT 2
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: LD_INT 2
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: ST_TO_ADDR
// end ; end ;
78389: GO 78392
78391: POP
// case btype of b_depot , b_warehouse :
78392: LD_VAR 0 1
78396: PUSH
78397: LD_INT 0
78399: DOUBLE
78400: EQUAL
78401: IFTRUE 78411
78403: LD_INT 1
78405: DOUBLE
78406: EQUAL
78407: IFTRUE 78411
78409: GO 78612
78411: POP
// case nation of nation_american :
78412: LD_VAR 0 5
78416: PUSH
78417: LD_INT 1
78419: DOUBLE
78420: EQUAL
78421: IFTRUE 78425
78423: GO 78481
78425: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
78426: LD_ADDR_VAR 0 9
78430: PUSH
78431: LD_VAR 0 11
78435: PUSH
78436: LD_VAR 0 12
78440: PUSH
78441: LD_VAR 0 13
78445: PUSH
78446: LD_VAR 0 14
78450: PUSH
78451: LD_VAR 0 15
78455: PUSH
78456: LD_VAR 0 16
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: PUSH
78469: LD_VAR 0 4
78473: PUSH
78474: LD_INT 1
78476: PLUS
78477: ARRAY
78478: ST_TO_ADDR
78479: GO 78610
78481: LD_INT 2
78483: DOUBLE
78484: EQUAL
78485: IFTRUE 78489
78487: GO 78545
78489: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
78490: LD_ADDR_VAR 0 9
78494: PUSH
78495: LD_VAR 0 17
78499: PUSH
78500: LD_VAR 0 18
78504: PUSH
78505: LD_VAR 0 19
78509: PUSH
78510: LD_VAR 0 20
78514: PUSH
78515: LD_VAR 0 21
78519: PUSH
78520: LD_VAR 0 22
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: PUSH
78533: LD_VAR 0 4
78537: PUSH
78538: LD_INT 1
78540: PLUS
78541: ARRAY
78542: ST_TO_ADDR
78543: GO 78610
78545: LD_INT 3
78547: DOUBLE
78548: EQUAL
78549: IFTRUE 78553
78551: GO 78609
78553: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78554: LD_ADDR_VAR 0 9
78558: PUSH
78559: LD_VAR 0 23
78563: PUSH
78564: LD_VAR 0 24
78568: PUSH
78569: LD_VAR 0 25
78573: PUSH
78574: LD_VAR 0 26
78578: PUSH
78579: LD_VAR 0 27
78583: PUSH
78584: LD_VAR 0 28
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: PUSH
78597: LD_VAR 0 4
78601: PUSH
78602: LD_INT 1
78604: PLUS
78605: ARRAY
78606: ST_TO_ADDR
78607: GO 78610
78609: POP
78610: GO 79165
78612: LD_INT 2
78614: DOUBLE
78615: EQUAL
78616: IFTRUE 78626
78618: LD_INT 3
78620: DOUBLE
78621: EQUAL
78622: IFTRUE 78626
78624: GO 78682
78626: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78627: LD_ADDR_VAR 0 9
78631: PUSH
78632: LD_VAR 0 29
78636: PUSH
78637: LD_VAR 0 30
78641: PUSH
78642: LD_VAR 0 31
78646: PUSH
78647: LD_VAR 0 32
78651: PUSH
78652: LD_VAR 0 33
78656: PUSH
78657: LD_VAR 0 34
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: PUSH
78670: LD_VAR 0 4
78674: PUSH
78675: LD_INT 1
78677: PLUS
78678: ARRAY
78679: ST_TO_ADDR
78680: GO 79165
78682: LD_INT 16
78684: DOUBLE
78685: EQUAL
78686: IFTRUE 78744
78688: LD_INT 17
78690: DOUBLE
78691: EQUAL
78692: IFTRUE 78744
78694: LD_INT 18
78696: DOUBLE
78697: EQUAL
78698: IFTRUE 78744
78700: LD_INT 19
78702: DOUBLE
78703: EQUAL
78704: IFTRUE 78744
78706: LD_INT 22
78708: DOUBLE
78709: EQUAL
78710: IFTRUE 78744
78712: LD_INT 20
78714: DOUBLE
78715: EQUAL
78716: IFTRUE 78744
78718: LD_INT 21
78720: DOUBLE
78721: EQUAL
78722: IFTRUE 78744
78724: LD_INT 23
78726: DOUBLE
78727: EQUAL
78728: IFTRUE 78744
78730: LD_INT 24
78732: DOUBLE
78733: EQUAL
78734: IFTRUE 78744
78736: LD_INT 25
78738: DOUBLE
78739: EQUAL
78740: IFTRUE 78744
78742: GO 78800
78744: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
78745: LD_ADDR_VAR 0 9
78749: PUSH
78750: LD_VAR 0 35
78754: PUSH
78755: LD_VAR 0 36
78759: PUSH
78760: LD_VAR 0 37
78764: PUSH
78765: LD_VAR 0 38
78769: PUSH
78770: LD_VAR 0 39
78774: PUSH
78775: LD_VAR 0 40
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: PUSH
78788: LD_VAR 0 4
78792: PUSH
78793: LD_INT 1
78795: PLUS
78796: ARRAY
78797: ST_TO_ADDR
78798: GO 79165
78800: LD_INT 6
78802: DOUBLE
78803: EQUAL
78804: IFTRUE 78856
78806: LD_INT 7
78808: DOUBLE
78809: EQUAL
78810: IFTRUE 78856
78812: LD_INT 8
78814: DOUBLE
78815: EQUAL
78816: IFTRUE 78856
78818: LD_INT 13
78820: DOUBLE
78821: EQUAL
78822: IFTRUE 78856
78824: LD_INT 12
78826: DOUBLE
78827: EQUAL
78828: IFTRUE 78856
78830: LD_INT 15
78832: DOUBLE
78833: EQUAL
78834: IFTRUE 78856
78836: LD_INT 11
78838: DOUBLE
78839: EQUAL
78840: IFTRUE 78856
78842: LD_INT 14
78844: DOUBLE
78845: EQUAL
78846: IFTRUE 78856
78848: LD_INT 10
78850: DOUBLE
78851: EQUAL
78852: IFTRUE 78856
78854: GO 78912
78856: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
78857: LD_ADDR_VAR 0 9
78861: PUSH
78862: LD_VAR 0 41
78866: PUSH
78867: LD_VAR 0 42
78871: PUSH
78872: LD_VAR 0 43
78876: PUSH
78877: LD_VAR 0 44
78881: PUSH
78882: LD_VAR 0 45
78886: PUSH
78887: LD_VAR 0 46
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: PUSH
78900: LD_VAR 0 4
78904: PUSH
78905: LD_INT 1
78907: PLUS
78908: ARRAY
78909: ST_TO_ADDR
78910: GO 79165
78912: LD_INT 36
78914: DOUBLE
78915: EQUAL
78916: IFTRUE 78920
78918: GO 78976
78920: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
78921: LD_ADDR_VAR 0 9
78925: PUSH
78926: LD_VAR 0 47
78930: PUSH
78931: LD_VAR 0 48
78935: PUSH
78936: LD_VAR 0 49
78940: PUSH
78941: LD_VAR 0 50
78945: PUSH
78946: LD_VAR 0 51
78950: PUSH
78951: LD_VAR 0 52
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: PUSH
78964: LD_VAR 0 4
78968: PUSH
78969: LD_INT 1
78971: PLUS
78972: ARRAY
78973: ST_TO_ADDR
78974: GO 79165
78976: LD_INT 4
78978: DOUBLE
78979: EQUAL
78980: IFTRUE 79002
78982: LD_INT 5
78984: DOUBLE
78985: EQUAL
78986: IFTRUE 79002
78988: LD_INT 34
78990: DOUBLE
78991: EQUAL
78992: IFTRUE 79002
78994: LD_INT 37
78996: DOUBLE
78997: EQUAL
78998: IFTRUE 79002
79000: GO 79058
79002: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
79003: LD_ADDR_VAR 0 9
79007: PUSH
79008: LD_VAR 0 53
79012: PUSH
79013: LD_VAR 0 54
79017: PUSH
79018: LD_VAR 0 55
79022: PUSH
79023: LD_VAR 0 56
79027: PUSH
79028: LD_VAR 0 57
79032: PUSH
79033: LD_VAR 0 58
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: LIST
79042: LIST
79043: LIST
79044: LIST
79045: PUSH
79046: LD_VAR 0 4
79050: PUSH
79051: LD_INT 1
79053: PLUS
79054: ARRAY
79055: ST_TO_ADDR
79056: GO 79165
79058: LD_INT 31
79060: DOUBLE
79061: EQUAL
79062: IFTRUE 79108
79064: LD_INT 32
79066: DOUBLE
79067: EQUAL
79068: IFTRUE 79108
79070: LD_INT 33
79072: DOUBLE
79073: EQUAL
79074: IFTRUE 79108
79076: LD_INT 27
79078: DOUBLE
79079: EQUAL
79080: IFTRUE 79108
79082: LD_INT 26
79084: DOUBLE
79085: EQUAL
79086: IFTRUE 79108
79088: LD_INT 28
79090: DOUBLE
79091: EQUAL
79092: IFTRUE 79108
79094: LD_INT 29
79096: DOUBLE
79097: EQUAL
79098: IFTRUE 79108
79100: LD_INT 30
79102: DOUBLE
79103: EQUAL
79104: IFTRUE 79108
79106: GO 79164
79108: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
79109: LD_ADDR_VAR 0 9
79113: PUSH
79114: LD_VAR 0 59
79118: PUSH
79119: LD_VAR 0 60
79123: PUSH
79124: LD_VAR 0 61
79128: PUSH
79129: LD_VAR 0 62
79133: PUSH
79134: LD_VAR 0 63
79138: PUSH
79139: LD_VAR 0 64
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: PUSH
79152: LD_VAR 0 4
79156: PUSH
79157: LD_INT 1
79159: PLUS
79160: ARRAY
79161: ST_TO_ADDR
79162: GO 79165
79164: POP
// temp_list2 = [ ] ;
79165: LD_ADDR_VAR 0 10
79169: PUSH
79170: EMPTY
79171: ST_TO_ADDR
// for i in temp_list do
79172: LD_ADDR_VAR 0 8
79176: PUSH
79177: LD_VAR 0 9
79181: PUSH
79182: FOR_IN
79183: IFFALSE 79235
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79185: LD_ADDR_VAR 0 10
79189: PUSH
79190: LD_VAR 0 10
79194: PUSH
79195: LD_VAR 0 8
79199: PUSH
79200: LD_INT 1
79202: ARRAY
79203: PUSH
79204: LD_VAR 0 2
79208: PLUS
79209: PUSH
79210: LD_VAR 0 8
79214: PUSH
79215: LD_INT 2
79217: ARRAY
79218: PUSH
79219: LD_VAR 0 3
79223: PLUS
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: EMPTY
79230: LIST
79231: ADD
79232: ST_TO_ADDR
79233: GO 79182
79235: POP
79236: POP
// result = temp_list2 ;
79237: LD_ADDR_VAR 0 7
79241: PUSH
79242: LD_VAR 0 10
79246: ST_TO_ADDR
// end ;
79247: LD_VAR 0 7
79251: RET
// export function EnemyInRange ( unit , dist ) ; begin
79252: LD_INT 0
79254: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79255: LD_ADDR_VAR 0 3
79259: PUSH
79260: LD_VAR 0 1
79264: PPUSH
79265: CALL_OW 255
79269: PPUSH
79270: LD_VAR 0 1
79274: PPUSH
79275: CALL_OW 250
79279: PPUSH
79280: LD_VAR 0 1
79284: PPUSH
79285: CALL_OW 251
79289: PPUSH
79290: LD_VAR 0 2
79294: PPUSH
79295: CALL 53356 0 4
79299: PUSH
79300: LD_INT 4
79302: ARRAY
79303: ST_TO_ADDR
// end ;
79304: LD_VAR 0 3
79308: RET
// export function PlayerSeeMe ( unit ) ; begin
79309: LD_INT 0
79311: PPUSH
// result := See ( your_side , unit ) ;
79312: LD_ADDR_VAR 0 2
79316: PUSH
79317: LD_OWVAR 2
79321: PPUSH
79322: LD_VAR 0 1
79326: PPUSH
79327: CALL_OW 292
79331: ST_TO_ADDR
// end ;
79332: LD_VAR 0 2
79336: RET
// export function ReverseDir ( unit ) ; begin
79337: LD_INT 0
79339: PPUSH
// if not unit then
79340: LD_VAR 0 1
79344: NOT
79345: IFFALSE 79349
// exit ;
79347: GO 79372
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79349: LD_ADDR_VAR 0 2
79353: PUSH
79354: LD_VAR 0 1
79358: PPUSH
79359: CALL_OW 254
79363: PUSH
79364: LD_INT 3
79366: PLUS
79367: PUSH
79368: LD_INT 6
79370: MOD
79371: ST_TO_ADDR
// end ;
79372: LD_VAR 0 2
79376: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79377: LD_INT 0
79379: PPUSH
79380: PPUSH
79381: PPUSH
79382: PPUSH
79383: PPUSH
// if not hexes then
79384: LD_VAR 0 2
79388: NOT
79389: IFFALSE 79393
// exit ;
79391: GO 79541
// dist := 9999 ;
79393: LD_ADDR_VAR 0 5
79397: PUSH
79398: LD_INT 9999
79400: ST_TO_ADDR
// for i = 1 to hexes do
79401: LD_ADDR_VAR 0 4
79405: PUSH
79406: DOUBLE
79407: LD_INT 1
79409: DEC
79410: ST_TO_ADDR
79411: LD_VAR 0 2
79415: PUSH
79416: FOR_TO
79417: IFFALSE 79529
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79419: LD_VAR 0 1
79423: PPUSH
79424: LD_VAR 0 2
79428: PUSH
79429: LD_VAR 0 4
79433: ARRAY
79434: PUSH
79435: LD_INT 1
79437: ARRAY
79438: PPUSH
79439: LD_VAR 0 2
79443: PUSH
79444: LD_VAR 0 4
79448: ARRAY
79449: PUSH
79450: LD_INT 2
79452: ARRAY
79453: PPUSH
79454: CALL_OW 297
79458: PUSH
79459: LD_VAR 0 5
79463: LESS
79464: IFFALSE 79527
// begin hex := hexes [ i ] ;
79466: LD_ADDR_VAR 0 7
79470: PUSH
79471: LD_VAR 0 2
79475: PUSH
79476: LD_VAR 0 4
79480: ARRAY
79481: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79482: LD_ADDR_VAR 0 5
79486: PUSH
79487: LD_VAR 0 1
79491: PPUSH
79492: LD_VAR 0 2
79496: PUSH
79497: LD_VAR 0 4
79501: ARRAY
79502: PUSH
79503: LD_INT 1
79505: ARRAY
79506: PPUSH
79507: LD_VAR 0 2
79511: PUSH
79512: LD_VAR 0 4
79516: ARRAY
79517: PUSH
79518: LD_INT 2
79520: ARRAY
79521: PPUSH
79522: CALL_OW 297
79526: ST_TO_ADDR
// end ; end ;
79527: GO 79416
79529: POP
79530: POP
// result := hex ;
79531: LD_ADDR_VAR 0 3
79535: PUSH
79536: LD_VAR 0 7
79540: ST_TO_ADDR
// end ;
79541: LD_VAR 0 3
79545: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79546: LD_INT 0
79548: PPUSH
79549: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79550: LD_VAR 0 1
79554: NOT
79555: PUSH
79556: LD_VAR 0 1
79560: PUSH
79561: LD_INT 21
79563: PUSH
79564: LD_INT 2
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 23
79573: PUSH
79574: LD_INT 2
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PPUSH
79585: CALL_OW 69
79589: IN
79590: NOT
79591: OR
79592: IFFALSE 79596
// exit ;
79594: GO 79643
// for i = 1 to 3 do
79596: LD_ADDR_VAR 0 3
79600: PUSH
79601: DOUBLE
79602: LD_INT 1
79604: DEC
79605: ST_TO_ADDR
79606: LD_INT 3
79608: PUSH
79609: FOR_TO
79610: IFFALSE 79641
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79612: LD_VAR 0 1
79616: PPUSH
79617: CALL_OW 250
79621: PPUSH
79622: LD_VAR 0 1
79626: PPUSH
79627: CALL_OW 251
79631: PPUSH
79632: LD_INT 1
79634: PPUSH
79635: CALL_OW 453
79639: GO 79609
79641: POP
79642: POP
// end ;
79643: LD_VAR 0 2
79647: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
79648: LD_INT 0
79650: PPUSH
79651: PPUSH
79652: PPUSH
79653: PPUSH
79654: PPUSH
79655: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
79656: LD_VAR 0 1
79660: NOT
79661: PUSH
79662: LD_VAR 0 2
79666: NOT
79667: OR
79668: PUSH
79669: LD_VAR 0 1
79673: PPUSH
79674: CALL_OW 314
79678: OR
79679: IFFALSE 79683
// exit ;
79681: GO 80124
// x := GetX ( enemy_unit ) ;
79683: LD_ADDR_VAR 0 7
79687: PUSH
79688: LD_VAR 0 2
79692: PPUSH
79693: CALL_OW 250
79697: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
79698: LD_ADDR_VAR 0 8
79702: PUSH
79703: LD_VAR 0 2
79707: PPUSH
79708: CALL_OW 251
79712: ST_TO_ADDR
// if not x or not y then
79713: LD_VAR 0 7
79717: NOT
79718: PUSH
79719: LD_VAR 0 8
79723: NOT
79724: OR
79725: IFFALSE 79729
// exit ;
79727: GO 80124
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
79729: LD_ADDR_VAR 0 6
79733: PUSH
79734: LD_VAR 0 7
79738: PPUSH
79739: LD_INT 0
79741: PPUSH
79742: LD_INT 4
79744: PPUSH
79745: CALL_OW 272
79749: PUSH
79750: LD_VAR 0 8
79754: PPUSH
79755: LD_INT 0
79757: PPUSH
79758: LD_INT 4
79760: PPUSH
79761: CALL_OW 273
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_VAR 0 7
79774: PPUSH
79775: LD_INT 1
79777: PPUSH
79778: LD_INT 4
79780: PPUSH
79781: CALL_OW 272
79785: PUSH
79786: LD_VAR 0 8
79790: PPUSH
79791: LD_INT 1
79793: PPUSH
79794: LD_INT 4
79796: PPUSH
79797: CALL_OW 273
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_VAR 0 7
79810: PPUSH
79811: LD_INT 2
79813: PPUSH
79814: LD_INT 4
79816: PPUSH
79817: CALL_OW 272
79821: PUSH
79822: LD_VAR 0 8
79826: PPUSH
79827: LD_INT 2
79829: PPUSH
79830: LD_INT 4
79832: PPUSH
79833: CALL_OW 273
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_VAR 0 7
79846: PPUSH
79847: LD_INT 3
79849: PPUSH
79850: LD_INT 4
79852: PPUSH
79853: CALL_OW 272
79857: PUSH
79858: LD_VAR 0 8
79862: PPUSH
79863: LD_INT 3
79865: PPUSH
79866: LD_INT 4
79868: PPUSH
79869: CALL_OW 273
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_VAR 0 7
79882: PPUSH
79883: LD_INT 4
79885: PPUSH
79886: LD_INT 4
79888: PPUSH
79889: CALL_OW 272
79893: PUSH
79894: LD_VAR 0 8
79898: PPUSH
79899: LD_INT 4
79901: PPUSH
79902: LD_INT 4
79904: PPUSH
79905: CALL_OW 273
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_VAR 0 7
79918: PPUSH
79919: LD_INT 5
79921: PPUSH
79922: LD_INT 4
79924: PPUSH
79925: CALL_OW 272
79929: PUSH
79930: LD_VAR 0 8
79934: PPUSH
79935: LD_INT 5
79937: PPUSH
79938: LD_INT 4
79940: PPUSH
79941: CALL_OW 273
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: ST_TO_ADDR
// for i = tmp downto 1 do
79958: LD_ADDR_VAR 0 4
79962: PUSH
79963: DOUBLE
79964: LD_VAR 0 6
79968: INC
79969: ST_TO_ADDR
79970: LD_INT 1
79972: PUSH
79973: FOR_DOWNTO
79974: IFFALSE 80075
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
79976: LD_VAR 0 6
79980: PUSH
79981: LD_VAR 0 4
79985: ARRAY
79986: PUSH
79987: LD_INT 1
79989: ARRAY
79990: PPUSH
79991: LD_VAR 0 6
79995: PUSH
79996: LD_VAR 0 4
80000: ARRAY
80001: PUSH
80002: LD_INT 2
80004: ARRAY
80005: PPUSH
80006: CALL_OW 488
80010: NOT
80011: PUSH
80012: LD_VAR 0 6
80016: PUSH
80017: LD_VAR 0 4
80021: ARRAY
80022: PUSH
80023: LD_INT 1
80025: ARRAY
80026: PPUSH
80027: LD_VAR 0 6
80031: PUSH
80032: LD_VAR 0 4
80036: ARRAY
80037: PUSH
80038: LD_INT 2
80040: ARRAY
80041: PPUSH
80042: CALL_OW 428
80046: PUSH
80047: LD_INT 0
80049: NONEQUAL
80050: OR
80051: IFFALSE 80073
// tmp := Delete ( tmp , i ) ;
80053: LD_ADDR_VAR 0 6
80057: PUSH
80058: LD_VAR 0 6
80062: PPUSH
80063: LD_VAR 0 4
80067: PPUSH
80068: CALL_OW 3
80072: ST_TO_ADDR
80073: GO 79973
80075: POP
80076: POP
// j := GetClosestHex ( unit , tmp ) ;
80077: LD_ADDR_VAR 0 5
80081: PUSH
80082: LD_VAR 0 1
80086: PPUSH
80087: LD_VAR 0 6
80091: PPUSH
80092: CALL 79377 0 2
80096: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
80097: LD_VAR 0 1
80101: PPUSH
80102: LD_VAR 0 5
80106: PUSH
80107: LD_INT 1
80109: ARRAY
80110: PPUSH
80111: LD_VAR 0 5
80115: PUSH
80116: LD_INT 2
80118: ARRAY
80119: PPUSH
80120: CALL_OW 111
// end ;
80124: LD_VAR 0 3
80128: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80129: LD_INT 0
80131: PPUSH
80132: PPUSH
80133: PPUSH
// uc_side = 0 ;
80134: LD_ADDR_OWVAR 20
80138: PUSH
80139: LD_INT 0
80141: ST_TO_ADDR
// uc_nation = 0 ;
80142: LD_ADDR_OWVAR 21
80146: PUSH
80147: LD_INT 0
80149: ST_TO_ADDR
// InitHc_All ( ) ;
80150: CALL_OW 584
// InitVc ;
80154: CALL_OW 20
// if mastodonts then
80158: LD_VAR 0 6
80162: IFFALSE 80229
// for i = 1 to mastodonts do
80164: LD_ADDR_VAR 0 11
80168: PUSH
80169: DOUBLE
80170: LD_INT 1
80172: DEC
80173: ST_TO_ADDR
80174: LD_VAR 0 6
80178: PUSH
80179: FOR_TO
80180: IFFALSE 80227
// begin vc_chassis := 31 ;
80182: LD_ADDR_OWVAR 37
80186: PUSH
80187: LD_INT 31
80189: ST_TO_ADDR
// vc_control := control_rider ;
80190: LD_ADDR_OWVAR 38
80194: PUSH
80195: LD_INT 4
80197: ST_TO_ADDR
// animal := CreateVehicle ;
80198: LD_ADDR_VAR 0 12
80202: PUSH
80203: CALL_OW 45
80207: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80208: LD_VAR 0 12
80212: PPUSH
80213: LD_VAR 0 8
80217: PPUSH
80218: LD_INT 0
80220: PPUSH
80221: CALL 82417 0 3
// end ;
80225: GO 80179
80227: POP
80228: POP
// if horses then
80229: LD_VAR 0 5
80233: IFFALSE 80300
// for i = 1 to horses do
80235: LD_ADDR_VAR 0 11
80239: PUSH
80240: DOUBLE
80241: LD_INT 1
80243: DEC
80244: ST_TO_ADDR
80245: LD_VAR 0 5
80249: PUSH
80250: FOR_TO
80251: IFFALSE 80298
// begin hc_class := 21 ;
80253: LD_ADDR_OWVAR 28
80257: PUSH
80258: LD_INT 21
80260: ST_TO_ADDR
// hc_gallery :=  ;
80261: LD_ADDR_OWVAR 33
80265: PUSH
80266: LD_STRING 
80268: ST_TO_ADDR
// animal := CreateHuman ;
80269: LD_ADDR_VAR 0 12
80273: PUSH
80274: CALL_OW 44
80278: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80279: LD_VAR 0 12
80283: PPUSH
80284: LD_VAR 0 8
80288: PPUSH
80289: LD_INT 0
80291: PPUSH
80292: CALL 82417 0 3
// end ;
80296: GO 80250
80298: POP
80299: POP
// if birds then
80300: LD_VAR 0 1
80304: IFFALSE 80371
// for i = 1 to birds do
80306: LD_ADDR_VAR 0 11
80310: PUSH
80311: DOUBLE
80312: LD_INT 1
80314: DEC
80315: ST_TO_ADDR
80316: LD_VAR 0 1
80320: PUSH
80321: FOR_TO
80322: IFFALSE 80369
// begin hc_class = 18 ;
80324: LD_ADDR_OWVAR 28
80328: PUSH
80329: LD_INT 18
80331: ST_TO_ADDR
// hc_gallery =  ;
80332: LD_ADDR_OWVAR 33
80336: PUSH
80337: LD_STRING 
80339: ST_TO_ADDR
// animal := CreateHuman ;
80340: LD_ADDR_VAR 0 12
80344: PUSH
80345: CALL_OW 44
80349: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80350: LD_VAR 0 12
80354: PPUSH
80355: LD_VAR 0 8
80359: PPUSH
80360: LD_INT 0
80362: PPUSH
80363: CALL 82417 0 3
// end ;
80367: GO 80321
80369: POP
80370: POP
// if tigers then
80371: LD_VAR 0 2
80375: IFFALSE 80459
// for i = 1 to tigers do
80377: LD_ADDR_VAR 0 11
80381: PUSH
80382: DOUBLE
80383: LD_INT 1
80385: DEC
80386: ST_TO_ADDR
80387: LD_VAR 0 2
80391: PUSH
80392: FOR_TO
80393: IFFALSE 80457
// begin hc_class = class_tiger ;
80395: LD_ADDR_OWVAR 28
80399: PUSH
80400: LD_INT 14
80402: ST_TO_ADDR
// hc_gallery =  ;
80403: LD_ADDR_OWVAR 33
80407: PUSH
80408: LD_STRING 
80410: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80411: LD_ADDR_OWVAR 35
80415: PUSH
80416: LD_INT 7
80418: NEG
80419: PPUSH
80420: LD_INT 7
80422: PPUSH
80423: CALL_OW 12
80427: ST_TO_ADDR
// animal := CreateHuman ;
80428: LD_ADDR_VAR 0 12
80432: PUSH
80433: CALL_OW 44
80437: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80438: LD_VAR 0 12
80442: PPUSH
80443: LD_VAR 0 8
80447: PPUSH
80448: LD_INT 0
80450: PPUSH
80451: CALL 82417 0 3
// end ;
80455: GO 80392
80457: POP
80458: POP
// if apemans then
80459: LD_VAR 0 3
80463: IFFALSE 80586
// for i = 1 to apemans do
80465: LD_ADDR_VAR 0 11
80469: PUSH
80470: DOUBLE
80471: LD_INT 1
80473: DEC
80474: ST_TO_ADDR
80475: LD_VAR 0 3
80479: PUSH
80480: FOR_TO
80481: IFFALSE 80584
// begin hc_class = class_apeman ;
80483: LD_ADDR_OWVAR 28
80487: PUSH
80488: LD_INT 12
80490: ST_TO_ADDR
// hc_gallery =  ;
80491: LD_ADDR_OWVAR 33
80495: PUSH
80496: LD_STRING 
80498: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80499: LD_ADDR_OWVAR 35
80503: PUSH
80504: LD_INT 5
80506: NEG
80507: PPUSH
80508: LD_INT 5
80510: PPUSH
80511: CALL_OW 12
80515: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80516: LD_ADDR_OWVAR 31
80520: PUSH
80521: LD_INT 1
80523: PPUSH
80524: LD_INT 3
80526: PPUSH
80527: CALL_OW 12
80531: PUSH
80532: LD_INT 1
80534: PPUSH
80535: LD_INT 3
80537: PPUSH
80538: CALL_OW 12
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: LD_INT 0
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: ST_TO_ADDR
// animal := CreateHuman ;
80555: LD_ADDR_VAR 0 12
80559: PUSH
80560: CALL_OW 44
80564: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80565: LD_VAR 0 12
80569: PPUSH
80570: LD_VAR 0 8
80574: PPUSH
80575: LD_INT 0
80577: PPUSH
80578: CALL 82417 0 3
// end ;
80582: GO 80480
80584: POP
80585: POP
// if enchidnas then
80586: LD_VAR 0 4
80590: IFFALSE 80657
// for i = 1 to enchidnas do
80592: LD_ADDR_VAR 0 11
80596: PUSH
80597: DOUBLE
80598: LD_INT 1
80600: DEC
80601: ST_TO_ADDR
80602: LD_VAR 0 4
80606: PUSH
80607: FOR_TO
80608: IFFALSE 80655
// begin hc_class = 13 ;
80610: LD_ADDR_OWVAR 28
80614: PUSH
80615: LD_INT 13
80617: ST_TO_ADDR
// hc_gallery =  ;
80618: LD_ADDR_OWVAR 33
80622: PUSH
80623: LD_STRING 
80625: ST_TO_ADDR
// animal := CreateHuman ;
80626: LD_ADDR_VAR 0 12
80630: PUSH
80631: CALL_OW 44
80635: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80636: LD_VAR 0 12
80640: PPUSH
80641: LD_VAR 0 8
80645: PPUSH
80646: LD_INT 0
80648: PPUSH
80649: CALL 82417 0 3
// end ;
80653: GO 80607
80655: POP
80656: POP
// if fishes then
80657: LD_VAR 0 7
80661: IFFALSE 80728
// for i = 1 to fishes do
80663: LD_ADDR_VAR 0 11
80667: PUSH
80668: DOUBLE
80669: LD_INT 1
80671: DEC
80672: ST_TO_ADDR
80673: LD_VAR 0 7
80677: PUSH
80678: FOR_TO
80679: IFFALSE 80726
// begin hc_class = 20 ;
80681: LD_ADDR_OWVAR 28
80685: PUSH
80686: LD_INT 20
80688: ST_TO_ADDR
// hc_gallery =  ;
80689: LD_ADDR_OWVAR 33
80693: PUSH
80694: LD_STRING 
80696: ST_TO_ADDR
// animal := CreateHuman ;
80697: LD_ADDR_VAR 0 12
80701: PUSH
80702: CALL_OW 44
80706: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
80707: LD_VAR 0 12
80711: PPUSH
80712: LD_VAR 0 9
80716: PPUSH
80717: LD_INT 0
80719: PPUSH
80720: CALL 82417 0 3
// end ;
80724: GO 80678
80726: POP
80727: POP
// end ;
80728: LD_VAR 0 10
80732: RET
// export function WantHeal ( sci , unit ) ; begin
80733: LD_INT 0
80735: PPUSH
// if GetTaskList ( sci ) > 0 then
80736: LD_VAR 0 1
80740: PPUSH
80741: CALL_OW 437
80745: PUSH
80746: LD_INT 0
80748: GREATER
80749: IFFALSE 80819
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
80751: LD_VAR 0 1
80755: PPUSH
80756: CALL_OW 437
80760: PUSH
80761: LD_INT 1
80763: ARRAY
80764: PUSH
80765: LD_INT 1
80767: ARRAY
80768: PUSH
80769: LD_STRING l
80771: EQUAL
80772: PUSH
80773: LD_VAR 0 1
80777: PPUSH
80778: CALL_OW 437
80782: PUSH
80783: LD_INT 1
80785: ARRAY
80786: PUSH
80787: LD_INT 4
80789: ARRAY
80790: PUSH
80791: LD_VAR 0 2
80795: EQUAL
80796: AND
80797: IFFALSE 80809
// result := true else
80799: LD_ADDR_VAR 0 3
80803: PUSH
80804: LD_INT 1
80806: ST_TO_ADDR
80807: GO 80817
// result := false ;
80809: LD_ADDR_VAR 0 3
80813: PUSH
80814: LD_INT 0
80816: ST_TO_ADDR
// end else
80817: GO 80827
// result := false ;
80819: LD_ADDR_VAR 0 3
80823: PUSH
80824: LD_INT 0
80826: ST_TO_ADDR
// end ;
80827: LD_VAR 0 3
80831: RET
// export function HealTarget ( sci ) ; begin
80832: LD_INT 0
80834: PPUSH
// if not sci then
80835: LD_VAR 0 1
80839: NOT
80840: IFFALSE 80844
// exit ;
80842: GO 80909
// result := 0 ;
80844: LD_ADDR_VAR 0 2
80848: PUSH
80849: LD_INT 0
80851: ST_TO_ADDR
// if GetTaskList ( sci ) then
80852: LD_VAR 0 1
80856: PPUSH
80857: CALL_OW 437
80861: IFFALSE 80909
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
80863: LD_VAR 0 1
80867: PPUSH
80868: CALL_OW 437
80872: PUSH
80873: LD_INT 1
80875: ARRAY
80876: PUSH
80877: LD_INT 1
80879: ARRAY
80880: PUSH
80881: LD_STRING l
80883: EQUAL
80884: IFFALSE 80909
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
80886: LD_ADDR_VAR 0 2
80890: PUSH
80891: LD_VAR 0 1
80895: PPUSH
80896: CALL_OW 437
80900: PUSH
80901: LD_INT 1
80903: ARRAY
80904: PUSH
80905: LD_INT 4
80907: ARRAY
80908: ST_TO_ADDR
// end ;
80909: LD_VAR 0 2
80913: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80914: LD_INT 0
80916: PPUSH
80917: PPUSH
80918: PPUSH
80919: PPUSH
// if not base_units then
80920: LD_VAR 0 1
80924: NOT
80925: IFFALSE 80929
// exit ;
80927: GO 81016
// result := false ;
80929: LD_ADDR_VAR 0 2
80933: PUSH
80934: LD_INT 0
80936: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80937: LD_ADDR_VAR 0 5
80941: PUSH
80942: LD_VAR 0 1
80946: PPUSH
80947: LD_INT 21
80949: PUSH
80950: LD_INT 3
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PPUSH
80957: CALL_OW 72
80961: ST_TO_ADDR
// if not tmp then
80962: LD_VAR 0 5
80966: NOT
80967: IFFALSE 80971
// exit ;
80969: GO 81016
// for i in tmp do
80971: LD_ADDR_VAR 0 3
80975: PUSH
80976: LD_VAR 0 5
80980: PUSH
80981: FOR_IN
80982: IFFALSE 81014
// begin result := EnemyInRange ( i , 22 ) ;
80984: LD_ADDR_VAR 0 2
80988: PUSH
80989: LD_VAR 0 3
80993: PPUSH
80994: LD_INT 22
80996: PPUSH
80997: CALL 79252 0 2
81001: ST_TO_ADDR
// if result then
81002: LD_VAR 0 2
81006: IFFALSE 81012
// exit ;
81008: POP
81009: POP
81010: GO 81016
// end ;
81012: GO 80981
81014: POP
81015: POP
// end ;
81016: LD_VAR 0 2
81020: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
81021: LD_INT 0
81023: PPUSH
81024: PPUSH
// if not units then
81025: LD_VAR 0 1
81029: NOT
81030: IFFALSE 81034
// exit ;
81032: GO 81104
// result := [ ] ;
81034: LD_ADDR_VAR 0 3
81038: PUSH
81039: EMPTY
81040: ST_TO_ADDR
// for i in units do
81041: LD_ADDR_VAR 0 4
81045: PUSH
81046: LD_VAR 0 1
81050: PUSH
81051: FOR_IN
81052: IFFALSE 81102
// if GetTag ( i ) = tag then
81054: LD_VAR 0 4
81058: PPUSH
81059: CALL_OW 110
81063: PUSH
81064: LD_VAR 0 2
81068: EQUAL
81069: IFFALSE 81100
// result := Insert ( result , result + 1 , i ) ;
81071: LD_ADDR_VAR 0 3
81075: PUSH
81076: LD_VAR 0 3
81080: PPUSH
81081: LD_VAR 0 3
81085: PUSH
81086: LD_INT 1
81088: PLUS
81089: PPUSH
81090: LD_VAR 0 4
81094: PPUSH
81095: CALL_OW 2
81099: ST_TO_ADDR
81100: GO 81051
81102: POP
81103: POP
// end ;
81104: LD_VAR 0 3
81108: RET
// export function IsDriver ( un ) ; begin
81109: LD_INT 0
81111: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81112: LD_ADDR_VAR 0 2
81116: PUSH
81117: LD_VAR 0 1
81121: PUSH
81122: LD_INT 55
81124: PUSH
81125: EMPTY
81126: LIST
81127: PPUSH
81128: CALL_OW 69
81132: IN
81133: ST_TO_ADDR
// end ;
81134: LD_VAR 0 2
81138: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81139: LD_INT 0
81141: PPUSH
81142: PPUSH
// list := [ ] ;
81143: LD_ADDR_VAR 0 5
81147: PUSH
81148: EMPTY
81149: ST_TO_ADDR
// case d of 0 :
81150: LD_VAR 0 3
81154: PUSH
81155: LD_INT 0
81157: DOUBLE
81158: EQUAL
81159: IFTRUE 81163
81161: GO 81296
81163: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81164: LD_ADDR_VAR 0 5
81168: PUSH
81169: LD_VAR 0 1
81173: PUSH
81174: LD_INT 4
81176: MINUS
81177: PUSH
81178: LD_VAR 0 2
81182: PUSH
81183: LD_INT 4
81185: MINUS
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: LIST
81194: PUSH
81195: LD_VAR 0 1
81199: PUSH
81200: LD_INT 3
81202: MINUS
81203: PUSH
81204: LD_VAR 0 2
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: LIST
81216: PUSH
81217: LD_VAR 0 1
81221: PUSH
81222: LD_INT 4
81224: PLUS
81225: PUSH
81226: LD_VAR 0 2
81230: PUSH
81231: LD_INT 4
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: LIST
81238: PUSH
81239: LD_VAR 0 1
81243: PUSH
81244: LD_INT 3
81246: PLUS
81247: PUSH
81248: LD_VAR 0 2
81252: PUSH
81253: LD_INT 3
81255: PLUS
81256: PUSH
81257: LD_INT 5
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: LIST
81264: PUSH
81265: LD_VAR 0 1
81269: PUSH
81270: LD_VAR 0 2
81274: PUSH
81275: LD_INT 4
81277: PLUS
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: LIST
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: ST_TO_ADDR
// end ; 1 :
81294: GO 81994
81296: LD_INT 1
81298: DOUBLE
81299: EQUAL
81300: IFTRUE 81304
81302: GO 81437
81304: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81305: LD_ADDR_VAR 0 5
81309: PUSH
81310: LD_VAR 0 1
81314: PUSH
81315: LD_VAR 0 2
81319: PUSH
81320: LD_INT 4
81322: MINUS
81323: PUSH
81324: LD_INT 3
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: LIST
81331: PUSH
81332: LD_VAR 0 1
81336: PUSH
81337: LD_INT 3
81339: MINUS
81340: PUSH
81341: LD_VAR 0 2
81345: PUSH
81346: LD_INT 3
81348: MINUS
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: LIST
81357: PUSH
81358: LD_VAR 0 1
81362: PUSH
81363: LD_INT 4
81365: MINUS
81366: PUSH
81367: LD_VAR 0 2
81371: PUSH
81372: LD_INT 1
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: LIST
81379: PUSH
81380: LD_VAR 0 1
81384: PUSH
81385: LD_VAR 0 2
81389: PUSH
81390: LD_INT 3
81392: PLUS
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: LIST
81401: PUSH
81402: LD_VAR 0 1
81406: PUSH
81407: LD_INT 4
81409: PLUS
81410: PUSH
81411: LD_VAR 0 2
81415: PUSH
81416: LD_INT 4
81418: PLUS
81419: PUSH
81420: LD_INT 5
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: LIST
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: ST_TO_ADDR
// end ; 2 :
81435: GO 81994
81437: LD_INT 2
81439: DOUBLE
81440: EQUAL
81441: IFTRUE 81445
81443: GO 81574
81445: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81446: LD_ADDR_VAR 0 5
81450: PUSH
81451: LD_VAR 0 1
81455: PUSH
81456: LD_VAR 0 2
81460: PUSH
81461: LD_INT 3
81463: MINUS
81464: PUSH
81465: LD_INT 3
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: LIST
81472: PUSH
81473: LD_VAR 0 1
81477: PUSH
81478: LD_INT 4
81480: PLUS
81481: PUSH
81482: LD_VAR 0 2
81486: PUSH
81487: LD_INT 4
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: LIST
81494: PUSH
81495: LD_VAR 0 1
81499: PUSH
81500: LD_VAR 0 2
81504: PUSH
81505: LD_INT 4
81507: PLUS
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: PUSH
81517: LD_VAR 0 1
81521: PUSH
81522: LD_INT 3
81524: MINUS
81525: PUSH
81526: LD_VAR 0 2
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: LIST
81538: PUSH
81539: LD_VAR 0 1
81543: PUSH
81544: LD_INT 4
81546: MINUS
81547: PUSH
81548: LD_VAR 0 2
81552: PUSH
81553: LD_INT 4
81555: MINUS
81556: PUSH
81557: LD_INT 2
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: LIST
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: ST_TO_ADDR
// end ; 3 :
81572: GO 81994
81574: LD_INT 3
81576: DOUBLE
81577: EQUAL
81578: IFTRUE 81582
81580: GO 81715
81582: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81583: LD_ADDR_VAR 0 5
81587: PUSH
81588: LD_VAR 0 1
81592: PUSH
81593: LD_INT 3
81595: PLUS
81596: PUSH
81597: LD_VAR 0 2
81601: PUSH
81602: LD_INT 4
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: LIST
81609: PUSH
81610: LD_VAR 0 1
81614: PUSH
81615: LD_INT 4
81617: PLUS
81618: PUSH
81619: LD_VAR 0 2
81623: PUSH
81624: LD_INT 4
81626: PLUS
81627: PUSH
81628: LD_INT 5
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: LIST
81635: PUSH
81636: LD_VAR 0 1
81640: PUSH
81641: LD_INT 4
81643: MINUS
81644: PUSH
81645: LD_VAR 0 2
81649: PUSH
81650: LD_INT 1
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: LIST
81657: PUSH
81658: LD_VAR 0 1
81662: PUSH
81663: LD_VAR 0 2
81667: PUSH
81668: LD_INT 4
81670: MINUS
81671: PUSH
81672: LD_INT 3
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: LIST
81679: PUSH
81680: LD_VAR 0 1
81684: PUSH
81685: LD_INT 3
81687: MINUS
81688: PUSH
81689: LD_VAR 0 2
81693: PUSH
81694: LD_INT 3
81696: MINUS
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: LIST
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: ST_TO_ADDR
// end ; 4 :
81713: GO 81994
81715: LD_INT 4
81717: DOUBLE
81718: EQUAL
81719: IFTRUE 81723
81721: GO 81856
81723: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81724: LD_ADDR_VAR 0 5
81728: PUSH
81729: LD_VAR 0 1
81733: PUSH
81734: LD_VAR 0 2
81738: PUSH
81739: LD_INT 4
81741: PLUS
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: LIST
81750: PUSH
81751: LD_VAR 0 1
81755: PUSH
81756: LD_INT 3
81758: PLUS
81759: PUSH
81760: LD_VAR 0 2
81764: PUSH
81765: LD_INT 3
81767: PLUS
81768: PUSH
81769: LD_INT 5
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: LIST
81776: PUSH
81777: LD_VAR 0 1
81781: PUSH
81782: LD_INT 4
81784: PLUS
81785: PUSH
81786: LD_VAR 0 2
81790: PUSH
81791: LD_INT 4
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: PUSH
81799: LD_VAR 0 1
81803: PUSH
81804: LD_VAR 0 2
81808: PUSH
81809: LD_INT 3
81811: MINUS
81812: PUSH
81813: LD_INT 3
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: LIST
81820: PUSH
81821: LD_VAR 0 1
81825: PUSH
81826: LD_INT 4
81828: MINUS
81829: PUSH
81830: LD_VAR 0 2
81834: PUSH
81835: LD_INT 4
81837: MINUS
81838: PUSH
81839: LD_INT 2
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: LIST
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: LIST
81853: ST_TO_ADDR
// end ; 5 :
81854: GO 81994
81856: LD_INT 5
81858: DOUBLE
81859: EQUAL
81860: IFTRUE 81864
81862: GO 81993
81864: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81865: LD_ADDR_VAR 0 5
81869: PUSH
81870: LD_VAR 0 1
81874: PUSH
81875: LD_INT 4
81877: MINUS
81878: PUSH
81879: LD_VAR 0 2
81883: PUSH
81884: LD_INT 1
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: LIST
81891: PUSH
81892: LD_VAR 0 1
81896: PUSH
81897: LD_VAR 0 2
81901: PUSH
81902: LD_INT 4
81904: MINUS
81905: PUSH
81906: LD_INT 3
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: LIST
81913: PUSH
81914: LD_VAR 0 1
81918: PUSH
81919: LD_INT 4
81921: PLUS
81922: PUSH
81923: LD_VAR 0 2
81927: PUSH
81928: LD_INT 4
81930: PLUS
81931: PUSH
81932: LD_INT 5
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: LIST
81939: PUSH
81940: LD_VAR 0 1
81944: PUSH
81945: LD_INT 3
81947: PLUS
81948: PUSH
81949: LD_VAR 0 2
81953: PUSH
81954: LD_INT 4
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: LIST
81961: PUSH
81962: LD_VAR 0 1
81966: PUSH
81967: LD_VAR 0 2
81971: PUSH
81972: LD_INT 3
81974: PLUS
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: LIST
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: ST_TO_ADDR
// end ; end ;
81991: GO 81994
81993: POP
// result := list ;
81994: LD_ADDR_VAR 0 4
81998: PUSH
81999: LD_VAR 0 5
82003: ST_TO_ADDR
// end ;
82004: LD_VAR 0 4
82008: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
82009: LD_INT 0
82011: PPUSH
82012: PPUSH
82013: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
82014: LD_VAR 0 1
82018: NOT
82019: PUSH
82020: LD_VAR 0 2
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: LD_INT 2
82030: PUSH
82031: LD_INT 3
82033: PUSH
82034: LD_INT 4
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: IN
82043: NOT
82044: OR
82045: IFFALSE 82049
// exit ;
82047: GO 82141
// tmp := [ ] ;
82049: LD_ADDR_VAR 0 5
82053: PUSH
82054: EMPTY
82055: ST_TO_ADDR
// for i in units do
82056: LD_ADDR_VAR 0 4
82060: PUSH
82061: LD_VAR 0 1
82065: PUSH
82066: FOR_IN
82067: IFFALSE 82110
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
82069: LD_ADDR_VAR 0 5
82073: PUSH
82074: LD_VAR 0 5
82078: PPUSH
82079: LD_VAR 0 5
82083: PUSH
82084: LD_INT 1
82086: PLUS
82087: PPUSH
82088: LD_VAR 0 4
82092: PPUSH
82093: LD_VAR 0 2
82097: PPUSH
82098: CALL_OW 259
82102: PPUSH
82103: CALL_OW 2
82107: ST_TO_ADDR
82108: GO 82066
82110: POP
82111: POP
// if not tmp then
82112: LD_VAR 0 5
82116: NOT
82117: IFFALSE 82121
// exit ;
82119: GO 82141
// result := SortListByListDesc ( units , tmp ) ;
82121: LD_ADDR_VAR 0 3
82125: PUSH
82126: LD_VAR 0 1
82130: PPUSH
82131: LD_VAR 0 5
82135: PPUSH
82136: CALL_OW 77
82140: ST_TO_ADDR
// end ;
82141: LD_VAR 0 3
82145: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82146: LD_INT 0
82148: PPUSH
82149: PPUSH
82150: PPUSH
// result := false ;
82151: LD_ADDR_VAR 0 3
82155: PUSH
82156: LD_INT 0
82158: ST_TO_ADDR
// x := GetX ( building ) ;
82159: LD_ADDR_VAR 0 4
82163: PUSH
82164: LD_VAR 0 2
82168: PPUSH
82169: CALL_OW 250
82173: ST_TO_ADDR
// y := GetY ( building ) ;
82174: LD_ADDR_VAR 0 5
82178: PUSH
82179: LD_VAR 0 2
82183: PPUSH
82184: CALL_OW 251
82188: ST_TO_ADDR
// if not building or not x or not y then
82189: LD_VAR 0 2
82193: NOT
82194: PUSH
82195: LD_VAR 0 4
82199: NOT
82200: OR
82201: PUSH
82202: LD_VAR 0 5
82206: NOT
82207: OR
82208: IFFALSE 82212
// exit ;
82210: GO 82304
// if GetTaskList ( unit ) then
82212: LD_VAR 0 1
82216: PPUSH
82217: CALL_OW 437
82221: IFFALSE 82304
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82223: LD_STRING e
82225: PUSH
82226: LD_VAR 0 1
82230: PPUSH
82231: CALL_OW 437
82235: PUSH
82236: LD_INT 1
82238: ARRAY
82239: PUSH
82240: LD_INT 1
82242: ARRAY
82243: EQUAL
82244: PUSH
82245: LD_VAR 0 4
82249: PUSH
82250: LD_VAR 0 1
82254: PPUSH
82255: CALL_OW 437
82259: PUSH
82260: LD_INT 1
82262: ARRAY
82263: PUSH
82264: LD_INT 2
82266: ARRAY
82267: EQUAL
82268: AND
82269: PUSH
82270: LD_VAR 0 5
82274: PUSH
82275: LD_VAR 0 1
82279: PPUSH
82280: CALL_OW 437
82284: PUSH
82285: LD_INT 1
82287: ARRAY
82288: PUSH
82289: LD_INT 3
82291: ARRAY
82292: EQUAL
82293: AND
82294: IFFALSE 82304
// result := true end ;
82296: LD_ADDR_VAR 0 3
82300: PUSH
82301: LD_INT 1
82303: ST_TO_ADDR
// end ;
82304: LD_VAR 0 3
82308: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
82309: LD_INT 0
82311: PPUSH
// result := false ;
82312: LD_ADDR_VAR 0 4
82316: PUSH
82317: LD_INT 0
82319: ST_TO_ADDR
// if GetTaskList ( unit ) then
82320: LD_VAR 0 1
82324: PPUSH
82325: CALL_OW 437
82329: IFFALSE 82412
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82331: LD_STRING M
82333: PUSH
82334: LD_VAR 0 1
82338: PPUSH
82339: CALL_OW 437
82343: PUSH
82344: LD_INT 1
82346: ARRAY
82347: PUSH
82348: LD_INT 1
82350: ARRAY
82351: EQUAL
82352: PUSH
82353: LD_VAR 0 2
82357: PUSH
82358: LD_VAR 0 1
82362: PPUSH
82363: CALL_OW 437
82367: PUSH
82368: LD_INT 1
82370: ARRAY
82371: PUSH
82372: LD_INT 2
82374: ARRAY
82375: EQUAL
82376: AND
82377: PUSH
82378: LD_VAR 0 3
82382: PUSH
82383: LD_VAR 0 1
82387: PPUSH
82388: CALL_OW 437
82392: PUSH
82393: LD_INT 1
82395: ARRAY
82396: PUSH
82397: LD_INT 3
82399: ARRAY
82400: EQUAL
82401: AND
82402: IFFALSE 82412
// result := true ;
82404: LD_ADDR_VAR 0 4
82408: PUSH
82409: LD_INT 1
82411: ST_TO_ADDR
// end ; end ;
82412: LD_VAR 0 4
82416: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82417: LD_INT 0
82419: PPUSH
82420: PPUSH
82421: PPUSH
82422: PPUSH
// if not unit or not area then
82423: LD_VAR 0 1
82427: NOT
82428: PUSH
82429: LD_VAR 0 2
82433: NOT
82434: OR
82435: IFFALSE 82439
// exit ;
82437: GO 82603
// tmp := AreaToList ( area , i ) ;
82439: LD_ADDR_VAR 0 6
82443: PUSH
82444: LD_VAR 0 2
82448: PPUSH
82449: LD_VAR 0 5
82453: PPUSH
82454: CALL_OW 517
82458: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82459: LD_ADDR_VAR 0 5
82463: PUSH
82464: DOUBLE
82465: LD_INT 1
82467: DEC
82468: ST_TO_ADDR
82469: LD_VAR 0 6
82473: PUSH
82474: LD_INT 1
82476: ARRAY
82477: PUSH
82478: FOR_TO
82479: IFFALSE 82601
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82481: LD_ADDR_VAR 0 7
82485: PUSH
82486: LD_VAR 0 6
82490: PUSH
82491: LD_INT 1
82493: ARRAY
82494: PUSH
82495: LD_VAR 0 5
82499: ARRAY
82500: PUSH
82501: LD_VAR 0 6
82505: PUSH
82506: LD_INT 2
82508: ARRAY
82509: PUSH
82510: LD_VAR 0 5
82514: ARRAY
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82520: LD_VAR 0 7
82524: PUSH
82525: LD_INT 1
82527: ARRAY
82528: PPUSH
82529: LD_VAR 0 7
82533: PUSH
82534: LD_INT 2
82536: ARRAY
82537: PPUSH
82538: CALL_OW 428
82542: PUSH
82543: LD_INT 0
82545: EQUAL
82546: IFFALSE 82599
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82548: LD_VAR 0 1
82552: PPUSH
82553: LD_VAR 0 7
82557: PUSH
82558: LD_INT 1
82560: ARRAY
82561: PPUSH
82562: LD_VAR 0 7
82566: PUSH
82567: LD_INT 2
82569: ARRAY
82570: PPUSH
82571: LD_VAR 0 3
82575: PPUSH
82576: CALL_OW 48
// result := IsPlaced ( unit ) ;
82580: LD_ADDR_VAR 0 4
82584: PUSH
82585: LD_VAR 0 1
82589: PPUSH
82590: CALL_OW 305
82594: ST_TO_ADDR
// exit ;
82595: POP
82596: POP
82597: GO 82603
// end ; end ;
82599: GO 82478
82601: POP
82602: POP
// end ;
82603: LD_VAR 0 4
82607: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82608: LD_INT 0
82610: PPUSH
82611: PPUSH
82612: PPUSH
// if not side or side > 8 then
82613: LD_VAR 0 1
82617: NOT
82618: PUSH
82619: LD_VAR 0 1
82623: PUSH
82624: LD_INT 8
82626: GREATER
82627: OR
82628: IFFALSE 82632
// exit ;
82630: GO 82819
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82632: LD_ADDR_VAR 0 4
82636: PUSH
82637: LD_INT 22
82639: PUSH
82640: LD_VAR 0 1
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 21
82651: PUSH
82652: LD_INT 3
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PPUSH
82663: CALL_OW 69
82667: ST_TO_ADDR
// if not tmp then
82668: LD_VAR 0 4
82672: NOT
82673: IFFALSE 82677
// exit ;
82675: GO 82819
// enable_addtolog := true ;
82677: LD_ADDR_OWVAR 81
82681: PUSH
82682: LD_INT 1
82684: ST_TO_ADDR
// AddToLog ( [ ) ;
82685: LD_STRING [
82687: PPUSH
82688: CALL_OW 561
// for i in tmp do
82692: LD_ADDR_VAR 0 3
82696: PUSH
82697: LD_VAR 0 4
82701: PUSH
82702: FOR_IN
82703: IFFALSE 82810
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
82705: LD_STRING [
82707: PUSH
82708: LD_VAR 0 3
82712: PPUSH
82713: CALL_OW 266
82717: STR
82718: PUSH
82719: LD_STRING , 
82721: STR
82722: PUSH
82723: LD_VAR 0 3
82727: PPUSH
82728: CALL_OW 250
82732: STR
82733: PUSH
82734: LD_STRING , 
82736: STR
82737: PUSH
82738: LD_VAR 0 3
82742: PPUSH
82743: CALL_OW 251
82747: STR
82748: PUSH
82749: LD_STRING , 
82751: STR
82752: PUSH
82753: LD_VAR 0 3
82757: PPUSH
82758: CALL_OW 254
82762: STR
82763: PUSH
82764: LD_STRING , 
82766: STR
82767: PUSH
82768: LD_VAR 0 3
82772: PPUSH
82773: LD_INT 1
82775: PPUSH
82776: CALL_OW 268
82780: STR
82781: PUSH
82782: LD_STRING , 
82784: STR
82785: PUSH
82786: LD_VAR 0 3
82790: PPUSH
82791: LD_INT 2
82793: PPUSH
82794: CALL_OW 268
82798: STR
82799: PUSH
82800: LD_STRING ],
82802: STR
82803: PPUSH
82804: CALL_OW 561
// end ;
82808: GO 82702
82810: POP
82811: POP
// AddToLog ( ]; ) ;
82812: LD_STRING ];
82814: PPUSH
82815: CALL_OW 561
// end ;
82819: LD_VAR 0 2
82823: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82824: LD_INT 0
82826: PPUSH
82827: PPUSH
82828: PPUSH
82829: PPUSH
82830: PPUSH
// if not area or not rate or not max then
82831: LD_VAR 0 1
82835: NOT
82836: PUSH
82837: LD_VAR 0 2
82841: NOT
82842: OR
82843: PUSH
82844: LD_VAR 0 4
82848: NOT
82849: OR
82850: IFFALSE 82854
// exit ;
82852: GO 83046
// while 1 do
82854: LD_INT 1
82856: IFFALSE 83046
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82858: LD_ADDR_VAR 0 9
82862: PUSH
82863: LD_VAR 0 1
82867: PPUSH
82868: LD_INT 1
82870: PPUSH
82871: CALL_OW 287
82875: PUSH
82876: LD_INT 10
82878: MUL
82879: ST_TO_ADDR
// r := rate / 10 ;
82880: LD_ADDR_VAR 0 7
82884: PUSH
82885: LD_VAR 0 2
82889: PUSH
82890: LD_INT 10
82892: DIVREAL
82893: ST_TO_ADDR
// time := 1 1$00 ;
82894: LD_ADDR_VAR 0 8
82898: PUSH
82899: LD_INT 2100
82901: ST_TO_ADDR
// if amount < min then
82902: LD_VAR 0 9
82906: PUSH
82907: LD_VAR 0 3
82911: LESS
82912: IFFALSE 82930
// r := r * 2 else
82914: LD_ADDR_VAR 0 7
82918: PUSH
82919: LD_VAR 0 7
82923: PUSH
82924: LD_INT 2
82926: MUL
82927: ST_TO_ADDR
82928: GO 82956
// if amount > max then
82930: LD_VAR 0 9
82934: PUSH
82935: LD_VAR 0 4
82939: GREATER
82940: IFFALSE 82956
// r := r / 2 ;
82942: LD_ADDR_VAR 0 7
82946: PUSH
82947: LD_VAR 0 7
82951: PUSH
82952: LD_INT 2
82954: DIVREAL
82955: ST_TO_ADDR
// time := time / r ;
82956: LD_ADDR_VAR 0 8
82960: PUSH
82961: LD_VAR 0 8
82965: PUSH
82966: LD_VAR 0 7
82970: DIVREAL
82971: ST_TO_ADDR
// if time < 0 then
82972: LD_VAR 0 8
82976: PUSH
82977: LD_INT 0
82979: LESS
82980: IFFALSE 82997
// time := time * - 1 ;
82982: LD_ADDR_VAR 0 8
82986: PUSH
82987: LD_VAR 0 8
82991: PUSH
82992: LD_INT 1
82994: NEG
82995: MUL
82996: ST_TO_ADDR
// wait ( time ) ;
82997: LD_VAR 0 8
83001: PPUSH
83002: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
83006: LD_INT 35
83008: PPUSH
83009: LD_INT 875
83011: PPUSH
83012: CALL_OW 12
83016: PPUSH
83017: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
83021: LD_INT 1
83023: PPUSH
83024: LD_INT 5
83026: PPUSH
83027: CALL_OW 12
83031: PPUSH
83032: LD_VAR 0 1
83036: PPUSH
83037: LD_INT 1
83039: PPUSH
83040: CALL_OW 55
// end ;
83044: GO 82854
// end ;
83046: LD_VAR 0 5
83050: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
83051: LD_INT 0
83053: PPUSH
83054: PPUSH
83055: PPUSH
83056: PPUSH
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
// if not turrets or not factories then
83061: LD_VAR 0 1
83065: NOT
83066: PUSH
83067: LD_VAR 0 2
83071: NOT
83072: OR
83073: IFFALSE 83077
// exit ;
83075: GO 83384
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
83077: LD_ADDR_VAR 0 10
83081: PUSH
83082: LD_INT 5
83084: PUSH
83085: LD_INT 6
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 2
83094: PUSH
83095: LD_INT 4
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 3
83104: PUSH
83105: LD_INT 5
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 24
83119: PUSH
83120: LD_INT 25
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 23
83129: PUSH
83130: LD_INT 27
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 42
83143: PUSH
83144: LD_INT 43
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 44
83153: PUSH
83154: LD_INT 46
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 45
83163: PUSH
83164: LD_INT 47
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: EMPTY
83172: LIST
83173: LIST
83174: LIST
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: LIST
83180: ST_TO_ADDR
// result := [ ] ;
83181: LD_ADDR_VAR 0 3
83185: PUSH
83186: EMPTY
83187: ST_TO_ADDR
// for i in turrets do
83188: LD_ADDR_VAR 0 4
83192: PUSH
83193: LD_VAR 0 1
83197: PUSH
83198: FOR_IN
83199: IFFALSE 83382
// begin nat := GetNation ( i ) ;
83201: LD_ADDR_VAR 0 7
83205: PUSH
83206: LD_VAR 0 4
83210: PPUSH
83211: CALL_OW 248
83215: ST_TO_ADDR
// weapon := 0 ;
83216: LD_ADDR_VAR 0 8
83220: PUSH
83221: LD_INT 0
83223: ST_TO_ADDR
// if not nat then
83224: LD_VAR 0 7
83228: NOT
83229: IFFALSE 83233
// continue ;
83231: GO 83198
// for j in list [ nat ] do
83233: LD_ADDR_VAR 0 5
83237: PUSH
83238: LD_VAR 0 10
83242: PUSH
83243: LD_VAR 0 7
83247: ARRAY
83248: PUSH
83249: FOR_IN
83250: IFFALSE 83291
// if GetBWeapon ( i ) = j [ 1 ] then
83252: LD_VAR 0 4
83256: PPUSH
83257: CALL_OW 269
83261: PUSH
83262: LD_VAR 0 5
83266: PUSH
83267: LD_INT 1
83269: ARRAY
83270: EQUAL
83271: IFFALSE 83289
// begin weapon := j [ 2 ] ;
83273: LD_ADDR_VAR 0 8
83277: PUSH
83278: LD_VAR 0 5
83282: PUSH
83283: LD_INT 2
83285: ARRAY
83286: ST_TO_ADDR
// break ;
83287: GO 83291
// end ;
83289: GO 83249
83291: POP
83292: POP
// if not weapon then
83293: LD_VAR 0 8
83297: NOT
83298: IFFALSE 83302
// continue ;
83300: GO 83198
// for k in factories do
83302: LD_ADDR_VAR 0 6
83306: PUSH
83307: LD_VAR 0 2
83311: PUSH
83312: FOR_IN
83313: IFFALSE 83378
// begin weapons := AvailableWeaponList ( k ) ;
83315: LD_ADDR_VAR 0 9
83319: PUSH
83320: LD_VAR 0 6
83324: PPUSH
83325: CALL_OW 478
83329: ST_TO_ADDR
// if not weapons then
83330: LD_VAR 0 9
83334: NOT
83335: IFFALSE 83339
// continue ;
83337: GO 83312
// if weapon in weapons then
83339: LD_VAR 0 8
83343: PUSH
83344: LD_VAR 0 9
83348: IN
83349: IFFALSE 83376
// begin result := [ i , weapon ] ;
83351: LD_ADDR_VAR 0 3
83355: PUSH
83356: LD_VAR 0 4
83360: PUSH
83361: LD_VAR 0 8
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: ST_TO_ADDR
// exit ;
83370: POP
83371: POP
83372: POP
83373: POP
83374: GO 83384
// end ; end ;
83376: GO 83312
83378: POP
83379: POP
// end ;
83380: GO 83198
83382: POP
83383: POP
// end ;
83384: LD_VAR 0 3
83388: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83389: LD_INT 0
83391: PPUSH
// if not side or side > 8 then
83392: LD_VAR 0 3
83396: NOT
83397: PUSH
83398: LD_VAR 0 3
83402: PUSH
83403: LD_INT 8
83405: GREATER
83406: OR
83407: IFFALSE 83411
// exit ;
83409: GO 83470
// if not range then
83411: LD_VAR 0 4
83415: NOT
83416: IFFALSE 83427
// range := - 12 ;
83418: LD_ADDR_VAR 0 4
83422: PUSH
83423: LD_INT 12
83425: NEG
83426: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83427: LD_VAR 0 1
83431: PPUSH
83432: LD_VAR 0 2
83436: PPUSH
83437: LD_VAR 0 3
83441: PPUSH
83442: LD_VAR 0 4
83446: PPUSH
83447: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83451: LD_VAR 0 1
83455: PPUSH
83456: LD_VAR 0 2
83460: PPUSH
83461: LD_VAR 0 3
83465: PPUSH
83466: CALL_OW 331
// end ;
83470: LD_VAR 0 5
83474: RET
// export function Video ( mode ) ; begin
83475: LD_INT 0
83477: PPUSH
// ingame_video = mode ;
83478: LD_ADDR_OWVAR 52
83482: PUSH
83483: LD_VAR 0 1
83487: ST_TO_ADDR
// interface_hidden = mode ;
83488: LD_ADDR_OWVAR 54
83492: PUSH
83493: LD_VAR 0 1
83497: ST_TO_ADDR
// end ;
83498: LD_VAR 0 2
83502: RET
// export function Join ( array , element ) ; begin
83503: LD_INT 0
83505: PPUSH
// result := Replace ( array , array + 1 , element ) ;
83506: LD_ADDR_VAR 0 3
83510: PUSH
83511: LD_VAR 0 1
83515: PPUSH
83516: LD_VAR 0 1
83520: PUSH
83521: LD_INT 1
83523: PLUS
83524: PPUSH
83525: LD_VAR 0 2
83529: PPUSH
83530: CALL_OW 1
83534: ST_TO_ADDR
// end ;
83535: LD_VAR 0 3
83539: RET
// export function JoinUnion ( array , element ) ; begin
83540: LD_INT 0
83542: PPUSH
// result := array union element ;
83543: LD_ADDR_VAR 0 3
83547: PUSH
83548: LD_VAR 0 1
83552: PUSH
83553: LD_VAR 0 2
83557: UNION
83558: ST_TO_ADDR
// end ;
83559: LD_VAR 0 3
83563: RET
// export function GetBehemoths ( side ) ; begin
83564: LD_INT 0
83566: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83567: LD_ADDR_VAR 0 2
83571: PUSH
83572: LD_INT 22
83574: PUSH
83575: LD_VAR 0 1
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 31
83586: PUSH
83587: LD_INT 25
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PPUSH
83598: CALL_OW 69
83602: ST_TO_ADDR
// end ;
83603: LD_VAR 0 2
83607: RET
// export function Shuffle ( array ) ; var i , index ; begin
83608: LD_INT 0
83610: PPUSH
83611: PPUSH
83612: PPUSH
// result := [ ] ;
83613: LD_ADDR_VAR 0 2
83617: PUSH
83618: EMPTY
83619: ST_TO_ADDR
// if not array then
83620: LD_VAR 0 1
83624: NOT
83625: IFFALSE 83629
// exit ;
83627: GO 83728
// Randomize ;
83629: CALL_OW 10
// for i = array downto 1 do
83633: LD_ADDR_VAR 0 3
83637: PUSH
83638: DOUBLE
83639: LD_VAR 0 1
83643: INC
83644: ST_TO_ADDR
83645: LD_INT 1
83647: PUSH
83648: FOR_DOWNTO
83649: IFFALSE 83726
// begin index := rand ( 1 , array ) ;
83651: LD_ADDR_VAR 0 4
83655: PUSH
83656: LD_INT 1
83658: PPUSH
83659: LD_VAR 0 1
83663: PPUSH
83664: CALL_OW 12
83668: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
83669: LD_ADDR_VAR 0 2
83673: PUSH
83674: LD_VAR 0 2
83678: PPUSH
83679: LD_VAR 0 2
83683: PUSH
83684: LD_INT 1
83686: PLUS
83687: PPUSH
83688: LD_VAR 0 1
83692: PUSH
83693: LD_VAR 0 4
83697: ARRAY
83698: PPUSH
83699: CALL_OW 2
83703: ST_TO_ADDR
// array := Delete ( array , index ) ;
83704: LD_ADDR_VAR 0 1
83708: PUSH
83709: LD_VAR 0 1
83713: PPUSH
83714: LD_VAR 0 4
83718: PPUSH
83719: CALL_OW 3
83723: ST_TO_ADDR
// end ;
83724: GO 83648
83726: POP
83727: POP
// end ;
83728: LD_VAR 0 2
83732: RET
// export function GetBaseMaterials ( base ) ; begin
83733: LD_INT 0
83735: PPUSH
// result := [ 0 , 0 , 0 ] ;
83736: LD_ADDR_VAR 0 2
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: LD_INT 0
83746: PUSH
83747: LD_INT 0
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: LIST
83754: ST_TO_ADDR
// if not base then
83755: LD_VAR 0 1
83759: NOT
83760: IFFALSE 83764
// exit ;
83762: GO 83813
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
83764: LD_ADDR_VAR 0 2
83768: PUSH
83769: LD_VAR 0 1
83773: PPUSH
83774: LD_INT 1
83776: PPUSH
83777: CALL_OW 275
83781: PUSH
83782: LD_VAR 0 1
83786: PPUSH
83787: LD_INT 2
83789: PPUSH
83790: CALL_OW 275
83794: PUSH
83795: LD_VAR 0 1
83799: PPUSH
83800: LD_INT 3
83802: PPUSH
83803: CALL_OW 275
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: LIST
83812: ST_TO_ADDR
// end ;
83813: LD_VAR 0 2
83817: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
83818: LD_INT 0
83820: PPUSH
83821: PPUSH
// result := array ;
83822: LD_ADDR_VAR 0 3
83826: PUSH
83827: LD_VAR 0 1
83831: ST_TO_ADDR
// if size > 0 then
83832: LD_VAR 0 2
83836: PUSH
83837: LD_INT 0
83839: GREATER
83840: IFFALSE 83886
// for i := array downto size do
83842: LD_ADDR_VAR 0 4
83846: PUSH
83847: DOUBLE
83848: LD_VAR 0 1
83852: INC
83853: ST_TO_ADDR
83854: LD_VAR 0 2
83858: PUSH
83859: FOR_DOWNTO
83860: IFFALSE 83884
// result := Delete ( result , result ) ;
83862: LD_ADDR_VAR 0 3
83866: PUSH
83867: LD_VAR 0 3
83871: PPUSH
83872: LD_VAR 0 3
83876: PPUSH
83877: CALL_OW 3
83881: ST_TO_ADDR
83882: GO 83859
83884: POP
83885: POP
// end ;
83886: LD_VAR 0 3
83890: RET
// export function ComExit ( unit ) ; var tmp ; begin
83891: LD_INT 0
83893: PPUSH
83894: PPUSH
// if not IsInUnit ( unit ) then
83895: LD_VAR 0 1
83899: PPUSH
83900: CALL_OW 310
83904: NOT
83905: IFFALSE 83909
// exit ;
83907: GO 83969
// tmp := IsInUnit ( unit ) ;
83909: LD_ADDR_VAR 0 3
83913: PUSH
83914: LD_VAR 0 1
83918: PPUSH
83919: CALL_OW 310
83923: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
83924: LD_VAR 0 3
83928: PPUSH
83929: CALL_OW 247
83933: PUSH
83934: LD_INT 2
83936: EQUAL
83937: IFFALSE 83950
// ComExitVehicle ( unit ) else
83939: LD_VAR 0 1
83943: PPUSH
83944: CALL_OW 121
83948: GO 83959
// ComExitBuilding ( unit ) ;
83950: LD_VAR 0 1
83954: PPUSH
83955: CALL_OW 122
// result := tmp ;
83959: LD_ADDR_VAR 0 2
83963: PUSH
83964: LD_VAR 0 3
83968: ST_TO_ADDR
// end ;
83969: LD_VAR 0 2
83973: RET
// export function ResetHc ; begin
83974: LD_INT 0
83976: PPUSH
// InitHc ;
83977: CALL_OW 19
// hc_importance := 0 ;
83981: LD_ADDR_OWVAR 32
83985: PUSH
83986: LD_INT 0
83988: ST_TO_ADDR
// end ;
83989: LD_VAR 0 1
83993: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
83994: LD_INT 0
83996: PPUSH
83997: PPUSH
83998: PPUSH
// _x := ( x1 + x2 ) div 2 ;
83999: LD_ADDR_VAR 0 6
84003: PUSH
84004: LD_VAR 0 1
84008: PUSH
84009: LD_VAR 0 3
84013: PLUS
84014: PUSH
84015: LD_INT 2
84017: DIV
84018: ST_TO_ADDR
// if _x < 0 then
84019: LD_VAR 0 6
84023: PUSH
84024: LD_INT 0
84026: LESS
84027: IFFALSE 84044
// _x := _x * - 1 ;
84029: LD_ADDR_VAR 0 6
84033: PUSH
84034: LD_VAR 0 6
84038: PUSH
84039: LD_INT 1
84041: NEG
84042: MUL
84043: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
84044: LD_ADDR_VAR 0 7
84048: PUSH
84049: LD_VAR 0 2
84053: PUSH
84054: LD_VAR 0 4
84058: PLUS
84059: PUSH
84060: LD_INT 2
84062: DIV
84063: ST_TO_ADDR
// if _y < 0 then
84064: LD_VAR 0 7
84068: PUSH
84069: LD_INT 0
84071: LESS
84072: IFFALSE 84089
// _y := _y * - 1 ;
84074: LD_ADDR_VAR 0 7
84078: PUSH
84079: LD_VAR 0 7
84083: PUSH
84084: LD_INT 1
84086: NEG
84087: MUL
84088: ST_TO_ADDR
// result := [ _x , _y ] ;
84089: LD_ADDR_VAR 0 5
84093: PUSH
84094: LD_VAR 0 6
84098: PUSH
84099: LD_VAR 0 7
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: ST_TO_ADDR
// end ;
84108: LD_VAR 0 5
84112: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
84113: LD_INT 0
84115: PPUSH
84116: PPUSH
84117: PPUSH
84118: PPUSH
// task := GetTaskList ( unit ) ;
84119: LD_ADDR_VAR 0 7
84123: PUSH
84124: LD_VAR 0 1
84128: PPUSH
84129: CALL_OW 437
84133: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
84134: LD_VAR 0 7
84138: NOT
84139: PUSH
84140: LD_VAR 0 1
84144: PPUSH
84145: LD_VAR 0 2
84149: PPUSH
84150: CALL_OW 308
84154: NOT
84155: AND
84156: IFFALSE 84160
// exit ;
84158: GO 84278
// if IsInArea ( unit , area ) then
84160: LD_VAR 0 1
84164: PPUSH
84165: LD_VAR 0 2
84169: PPUSH
84170: CALL_OW 308
84174: IFFALSE 84192
// begin ComMoveToArea ( unit , goAway ) ;
84176: LD_VAR 0 1
84180: PPUSH
84181: LD_VAR 0 3
84185: PPUSH
84186: CALL_OW 113
// exit ;
84190: GO 84278
// end ; if task [ 1 ] [ 1 ] <> M then
84192: LD_VAR 0 7
84196: PUSH
84197: LD_INT 1
84199: ARRAY
84200: PUSH
84201: LD_INT 1
84203: ARRAY
84204: PUSH
84205: LD_STRING M
84207: NONEQUAL
84208: IFFALSE 84212
// exit ;
84210: GO 84278
// x := task [ 1 ] [ 2 ] ;
84212: LD_ADDR_VAR 0 5
84216: PUSH
84217: LD_VAR 0 7
84221: PUSH
84222: LD_INT 1
84224: ARRAY
84225: PUSH
84226: LD_INT 2
84228: ARRAY
84229: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
84230: LD_ADDR_VAR 0 6
84234: PUSH
84235: LD_VAR 0 7
84239: PUSH
84240: LD_INT 1
84242: ARRAY
84243: PUSH
84244: LD_INT 3
84246: ARRAY
84247: ST_TO_ADDR
// if InArea ( x , y , area ) then
84248: LD_VAR 0 5
84252: PPUSH
84253: LD_VAR 0 6
84257: PPUSH
84258: LD_VAR 0 2
84262: PPUSH
84263: CALL_OW 309
84267: IFFALSE 84278
// ComStop ( unit ) ;
84269: LD_VAR 0 1
84273: PPUSH
84274: CALL_OW 141
// end ;
84278: LD_VAR 0 4
84282: RET
// export function Abs ( value ) ; begin
84283: LD_INT 0
84285: PPUSH
// result := value ;
84286: LD_ADDR_VAR 0 2
84290: PUSH
84291: LD_VAR 0 1
84295: ST_TO_ADDR
// if value < 0 then
84296: LD_VAR 0 1
84300: PUSH
84301: LD_INT 0
84303: LESS
84304: IFFALSE 84321
// result := value * - 1 ;
84306: LD_ADDR_VAR 0 2
84310: PUSH
84311: LD_VAR 0 1
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: MUL
84320: ST_TO_ADDR
// end ;
84321: LD_VAR 0 2
84325: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
84326: LD_INT 0
84328: PPUSH
84329: PPUSH
84330: PPUSH
84331: PPUSH
84332: PPUSH
84333: PPUSH
84334: PPUSH
84335: PPUSH
// if not unit or not building then
84336: LD_VAR 0 1
84340: NOT
84341: PUSH
84342: LD_VAR 0 2
84346: NOT
84347: OR
84348: IFFALSE 84352
// exit ;
84350: GO 84578
// x := GetX ( building ) ;
84352: LD_ADDR_VAR 0 4
84356: PUSH
84357: LD_VAR 0 2
84361: PPUSH
84362: CALL_OW 250
84366: ST_TO_ADDR
// y := GetY ( building ) ;
84367: LD_ADDR_VAR 0 6
84371: PUSH
84372: LD_VAR 0 2
84376: PPUSH
84377: CALL_OW 251
84381: ST_TO_ADDR
// d := GetDir ( building ) ;
84382: LD_ADDR_VAR 0 8
84386: PUSH
84387: LD_VAR 0 2
84391: PPUSH
84392: CALL_OW 254
84396: ST_TO_ADDR
// r := 4 ;
84397: LD_ADDR_VAR 0 9
84401: PUSH
84402: LD_INT 4
84404: ST_TO_ADDR
// for i := 1 to 5 do
84405: LD_ADDR_VAR 0 10
84409: PUSH
84410: DOUBLE
84411: LD_INT 1
84413: DEC
84414: ST_TO_ADDR
84415: LD_INT 5
84417: PUSH
84418: FOR_TO
84419: IFFALSE 84576
// begin _x := ShiftX ( x , d , r + i ) ;
84421: LD_ADDR_VAR 0 5
84425: PUSH
84426: LD_VAR 0 4
84430: PPUSH
84431: LD_VAR 0 8
84435: PPUSH
84436: LD_VAR 0 9
84440: PUSH
84441: LD_VAR 0 10
84445: PLUS
84446: PPUSH
84447: CALL_OW 272
84451: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
84452: LD_ADDR_VAR 0 7
84456: PUSH
84457: LD_VAR 0 6
84461: PPUSH
84462: LD_VAR 0 8
84466: PPUSH
84467: LD_VAR 0 9
84471: PUSH
84472: LD_VAR 0 10
84476: PLUS
84477: PPUSH
84478: CALL_OW 273
84482: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
84483: LD_VAR 0 5
84487: PPUSH
84488: LD_VAR 0 7
84492: PPUSH
84493: CALL_OW 488
84497: PUSH
84498: LD_VAR 0 5
84502: PPUSH
84503: LD_VAR 0 7
84507: PPUSH
84508: CALL_OW 428
84512: PPUSH
84513: CALL_OW 247
84517: PUSH
84518: LD_INT 3
84520: PUSH
84521: LD_INT 2
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: IN
84528: NOT
84529: AND
84530: IFFALSE 84574
// begin ComMoveXY ( unit , _x , _y ) ;
84532: LD_VAR 0 1
84536: PPUSH
84537: LD_VAR 0 5
84541: PPUSH
84542: LD_VAR 0 7
84546: PPUSH
84547: CALL_OW 111
// result := [ _x , _y ] ;
84551: LD_ADDR_VAR 0 3
84555: PUSH
84556: LD_VAR 0 5
84560: PUSH
84561: LD_VAR 0 7
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: ST_TO_ADDR
// exit ;
84570: POP
84571: POP
84572: GO 84578
// end ; end ;
84574: GO 84418
84576: POP
84577: POP
// end ; end_of_file
84578: LD_VAR 0 3
84582: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
84583: LD_INT 0
84585: PPUSH
// ar_miner := 81 ;
84586: LD_ADDR_EXP 100
84590: PUSH
84591: LD_INT 81
84593: ST_TO_ADDR
// ar_crane := 88 ;
84594: LD_ADDR_EXP 99
84598: PUSH
84599: LD_INT 88
84601: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84602: LD_ADDR_EXP 94
84606: PUSH
84607: LD_INT 89
84609: ST_TO_ADDR
// us_hack := 99 ;
84610: LD_ADDR_EXP 95
84614: PUSH
84615: LD_INT 99
84617: ST_TO_ADDR
// us_artillery := 97 ;
84618: LD_ADDR_EXP 96
84622: PUSH
84623: LD_INT 97
84625: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84626: LD_ADDR_EXP 97
84630: PUSH
84631: LD_INT 91
84633: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
84634: LD_ADDR_EXP 98
84638: PUSH
84639: LD_INT 92
84641: ST_TO_ADDR
// ru_radar := 98 ;
84642: LD_ADDR_EXP 93
84646: PUSH
84647: LD_INT 98
84649: ST_TO_ADDR
// tech_Artillery := 80 ;
84650: LD_ADDR_EXP 101
84654: PUSH
84655: LD_INT 80
84657: ST_TO_ADDR
// tech_RadMat := 81 ;
84658: LD_ADDR_EXP 102
84662: PUSH
84663: LD_INT 81
84665: ST_TO_ADDR
// tech_BasicTools := 82 ;
84666: LD_ADDR_EXP 103
84670: PUSH
84671: LD_INT 82
84673: ST_TO_ADDR
// tech_Cargo := 83 ;
84674: LD_ADDR_EXP 104
84678: PUSH
84679: LD_INT 83
84681: ST_TO_ADDR
// tech_Track := 84 ;
84682: LD_ADDR_EXP 105
84686: PUSH
84687: LD_INT 84
84689: ST_TO_ADDR
// tech_Crane := 85 ;
84690: LD_ADDR_EXP 106
84694: PUSH
84695: LD_INT 85
84697: ST_TO_ADDR
// tech_Bulldozer := 86 ;
84698: LD_ADDR_EXP 107
84702: PUSH
84703: LD_INT 86
84705: ST_TO_ADDR
// tech_Hovercraft := 87 ;
84706: LD_ADDR_EXP 108
84710: PUSH
84711: LD_INT 87
84713: ST_TO_ADDR
// end ;
84714: LD_VAR 0 1
84718: RET
// every 1 do
84719: GO 84721
84721: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
84722: CALL 84583 0 0
84726: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
84727: LD_VAR 0 2
84731: PUSH
84732: LD_INT 100
84734: EQUAL
84735: IFFALSE 85684
// begin if not StreamModeActive then
84737: LD_EXP 109
84741: NOT
84742: IFFALSE 84752
// StreamModeActive := true ;
84744: LD_ADDR_EXP 109
84748: PUSH
84749: LD_INT 1
84751: ST_TO_ADDR
// if p3 = 0 then
84752: LD_VAR 0 3
84756: PUSH
84757: LD_INT 0
84759: EQUAL
84760: IFFALSE 84766
// InitStreamMode ;
84762: CALL 85842 0 0
// if p3 = 1 then
84766: LD_VAR 0 3
84770: PUSH
84771: LD_INT 1
84773: EQUAL
84774: IFFALSE 84784
// sRocket := true ;
84776: LD_ADDR_EXP 114
84780: PUSH
84781: LD_INT 1
84783: ST_TO_ADDR
// if p3 = 2 then
84784: LD_VAR 0 3
84788: PUSH
84789: LD_INT 2
84791: EQUAL
84792: IFFALSE 84802
// sSpeed := true ;
84794: LD_ADDR_EXP 113
84798: PUSH
84799: LD_INT 1
84801: ST_TO_ADDR
// if p3 = 3 then
84802: LD_VAR 0 3
84806: PUSH
84807: LD_INT 3
84809: EQUAL
84810: IFFALSE 84820
// sEngine := true ;
84812: LD_ADDR_EXP 115
84816: PUSH
84817: LD_INT 1
84819: ST_TO_ADDR
// if p3 = 4 then
84820: LD_VAR 0 3
84824: PUSH
84825: LD_INT 4
84827: EQUAL
84828: IFFALSE 84838
// sSpec := true ;
84830: LD_ADDR_EXP 112
84834: PUSH
84835: LD_INT 1
84837: ST_TO_ADDR
// if p3 = 5 then
84838: LD_VAR 0 3
84842: PUSH
84843: LD_INT 5
84845: EQUAL
84846: IFFALSE 84856
// sLevel := true ;
84848: LD_ADDR_EXP 116
84852: PUSH
84853: LD_INT 1
84855: ST_TO_ADDR
// if p3 = 6 then
84856: LD_VAR 0 3
84860: PUSH
84861: LD_INT 6
84863: EQUAL
84864: IFFALSE 84874
// sArmoury := true ;
84866: LD_ADDR_EXP 117
84870: PUSH
84871: LD_INT 1
84873: ST_TO_ADDR
// if p3 = 7 then
84874: LD_VAR 0 3
84878: PUSH
84879: LD_INT 7
84881: EQUAL
84882: IFFALSE 84892
// sRadar := true ;
84884: LD_ADDR_EXP 118
84888: PUSH
84889: LD_INT 1
84891: ST_TO_ADDR
// if p3 = 8 then
84892: LD_VAR 0 3
84896: PUSH
84897: LD_INT 8
84899: EQUAL
84900: IFFALSE 84910
// sBunker := true ;
84902: LD_ADDR_EXP 119
84906: PUSH
84907: LD_INT 1
84909: ST_TO_ADDR
// if p3 = 9 then
84910: LD_VAR 0 3
84914: PUSH
84915: LD_INT 9
84917: EQUAL
84918: IFFALSE 84928
// sHack := true ;
84920: LD_ADDR_EXP 120
84924: PUSH
84925: LD_INT 1
84927: ST_TO_ADDR
// if p3 = 10 then
84928: LD_VAR 0 3
84932: PUSH
84933: LD_INT 10
84935: EQUAL
84936: IFFALSE 84946
// sFire := true ;
84938: LD_ADDR_EXP 121
84942: PUSH
84943: LD_INT 1
84945: ST_TO_ADDR
// if p3 = 11 then
84946: LD_VAR 0 3
84950: PUSH
84951: LD_INT 11
84953: EQUAL
84954: IFFALSE 84964
// sRefresh := true ;
84956: LD_ADDR_EXP 122
84960: PUSH
84961: LD_INT 1
84963: ST_TO_ADDR
// if p3 = 12 then
84964: LD_VAR 0 3
84968: PUSH
84969: LD_INT 12
84971: EQUAL
84972: IFFALSE 84982
// sExp := true ;
84974: LD_ADDR_EXP 123
84978: PUSH
84979: LD_INT 1
84981: ST_TO_ADDR
// if p3 = 13 then
84982: LD_VAR 0 3
84986: PUSH
84987: LD_INT 13
84989: EQUAL
84990: IFFALSE 85000
// sDepot := true ;
84992: LD_ADDR_EXP 124
84996: PUSH
84997: LD_INT 1
84999: ST_TO_ADDR
// if p3 = 14 then
85000: LD_VAR 0 3
85004: PUSH
85005: LD_INT 14
85007: EQUAL
85008: IFFALSE 85018
// sFlag := true ;
85010: LD_ADDR_EXP 125
85014: PUSH
85015: LD_INT 1
85017: ST_TO_ADDR
// if p3 = 15 then
85018: LD_VAR 0 3
85022: PUSH
85023: LD_INT 15
85025: EQUAL
85026: IFFALSE 85036
// sKamikadze := true ;
85028: LD_ADDR_EXP 133
85032: PUSH
85033: LD_INT 1
85035: ST_TO_ADDR
// if p3 = 16 then
85036: LD_VAR 0 3
85040: PUSH
85041: LD_INT 16
85043: EQUAL
85044: IFFALSE 85054
// sTroll := true ;
85046: LD_ADDR_EXP 134
85050: PUSH
85051: LD_INT 1
85053: ST_TO_ADDR
// if p3 = 17 then
85054: LD_VAR 0 3
85058: PUSH
85059: LD_INT 17
85061: EQUAL
85062: IFFALSE 85072
// sSlow := true ;
85064: LD_ADDR_EXP 135
85068: PUSH
85069: LD_INT 1
85071: ST_TO_ADDR
// if p3 = 18 then
85072: LD_VAR 0 3
85076: PUSH
85077: LD_INT 18
85079: EQUAL
85080: IFFALSE 85090
// sLack := true ;
85082: LD_ADDR_EXP 136
85086: PUSH
85087: LD_INT 1
85089: ST_TO_ADDR
// if p3 = 19 then
85090: LD_VAR 0 3
85094: PUSH
85095: LD_INT 19
85097: EQUAL
85098: IFFALSE 85108
// sTank := true ;
85100: LD_ADDR_EXP 138
85104: PUSH
85105: LD_INT 1
85107: ST_TO_ADDR
// if p3 = 20 then
85108: LD_VAR 0 3
85112: PUSH
85113: LD_INT 20
85115: EQUAL
85116: IFFALSE 85126
// sRemote := true ;
85118: LD_ADDR_EXP 139
85122: PUSH
85123: LD_INT 1
85125: ST_TO_ADDR
// if p3 = 21 then
85126: LD_VAR 0 3
85130: PUSH
85131: LD_INT 21
85133: EQUAL
85134: IFFALSE 85144
// sPowell := true ;
85136: LD_ADDR_EXP 140
85140: PUSH
85141: LD_INT 1
85143: ST_TO_ADDR
// if p3 = 22 then
85144: LD_VAR 0 3
85148: PUSH
85149: LD_INT 22
85151: EQUAL
85152: IFFALSE 85162
// sTeleport := true ;
85154: LD_ADDR_EXP 143
85158: PUSH
85159: LD_INT 1
85161: ST_TO_ADDR
// if p3 = 23 then
85162: LD_VAR 0 3
85166: PUSH
85167: LD_INT 23
85169: EQUAL
85170: IFFALSE 85180
// sOilTower := true ;
85172: LD_ADDR_EXP 145
85176: PUSH
85177: LD_INT 1
85179: ST_TO_ADDR
// if p3 = 24 then
85180: LD_VAR 0 3
85184: PUSH
85185: LD_INT 24
85187: EQUAL
85188: IFFALSE 85198
// sShovel := true ;
85190: LD_ADDR_EXP 146
85194: PUSH
85195: LD_INT 1
85197: ST_TO_ADDR
// if p3 = 25 then
85198: LD_VAR 0 3
85202: PUSH
85203: LD_INT 25
85205: EQUAL
85206: IFFALSE 85216
// sSheik := true ;
85208: LD_ADDR_EXP 147
85212: PUSH
85213: LD_INT 1
85215: ST_TO_ADDR
// if p3 = 26 then
85216: LD_VAR 0 3
85220: PUSH
85221: LD_INT 26
85223: EQUAL
85224: IFFALSE 85234
// sEarthquake := true ;
85226: LD_ADDR_EXP 149
85230: PUSH
85231: LD_INT 1
85233: ST_TO_ADDR
// if p3 = 27 then
85234: LD_VAR 0 3
85238: PUSH
85239: LD_INT 27
85241: EQUAL
85242: IFFALSE 85252
// sAI := true ;
85244: LD_ADDR_EXP 150
85248: PUSH
85249: LD_INT 1
85251: ST_TO_ADDR
// if p3 = 28 then
85252: LD_VAR 0 3
85256: PUSH
85257: LD_INT 28
85259: EQUAL
85260: IFFALSE 85270
// sCargo := true ;
85262: LD_ADDR_EXP 153
85266: PUSH
85267: LD_INT 1
85269: ST_TO_ADDR
// if p3 = 29 then
85270: LD_VAR 0 3
85274: PUSH
85275: LD_INT 29
85277: EQUAL
85278: IFFALSE 85288
// sDLaser := true ;
85280: LD_ADDR_EXP 154
85284: PUSH
85285: LD_INT 1
85287: ST_TO_ADDR
// if p3 = 30 then
85288: LD_VAR 0 3
85292: PUSH
85293: LD_INT 30
85295: EQUAL
85296: IFFALSE 85306
// sExchange := true ;
85298: LD_ADDR_EXP 155
85302: PUSH
85303: LD_INT 1
85305: ST_TO_ADDR
// if p3 = 31 then
85306: LD_VAR 0 3
85310: PUSH
85311: LD_INT 31
85313: EQUAL
85314: IFFALSE 85324
// sFac := true ;
85316: LD_ADDR_EXP 156
85320: PUSH
85321: LD_INT 1
85323: ST_TO_ADDR
// if p3 = 32 then
85324: LD_VAR 0 3
85328: PUSH
85329: LD_INT 32
85331: EQUAL
85332: IFFALSE 85342
// sPower := true ;
85334: LD_ADDR_EXP 157
85338: PUSH
85339: LD_INT 1
85341: ST_TO_ADDR
// if p3 = 33 then
85342: LD_VAR 0 3
85346: PUSH
85347: LD_INT 33
85349: EQUAL
85350: IFFALSE 85360
// sRandom := true ;
85352: LD_ADDR_EXP 158
85356: PUSH
85357: LD_INT 1
85359: ST_TO_ADDR
// if p3 = 34 then
85360: LD_VAR 0 3
85364: PUSH
85365: LD_INT 34
85367: EQUAL
85368: IFFALSE 85378
// sShield := true ;
85370: LD_ADDR_EXP 159
85374: PUSH
85375: LD_INT 1
85377: ST_TO_ADDR
// if p3 = 35 then
85378: LD_VAR 0 3
85382: PUSH
85383: LD_INT 35
85385: EQUAL
85386: IFFALSE 85396
// sTime := true ;
85388: LD_ADDR_EXP 160
85392: PUSH
85393: LD_INT 1
85395: ST_TO_ADDR
// if p3 = 36 then
85396: LD_VAR 0 3
85400: PUSH
85401: LD_INT 36
85403: EQUAL
85404: IFFALSE 85414
// sTools := true ;
85406: LD_ADDR_EXP 161
85410: PUSH
85411: LD_INT 1
85413: ST_TO_ADDR
// if p3 = 101 then
85414: LD_VAR 0 3
85418: PUSH
85419: LD_INT 101
85421: EQUAL
85422: IFFALSE 85432
// sSold := true ;
85424: LD_ADDR_EXP 126
85428: PUSH
85429: LD_INT 1
85431: ST_TO_ADDR
// if p3 = 102 then
85432: LD_VAR 0 3
85436: PUSH
85437: LD_INT 102
85439: EQUAL
85440: IFFALSE 85450
// sDiff := true ;
85442: LD_ADDR_EXP 127
85446: PUSH
85447: LD_INT 1
85449: ST_TO_ADDR
// if p3 = 103 then
85450: LD_VAR 0 3
85454: PUSH
85455: LD_INT 103
85457: EQUAL
85458: IFFALSE 85468
// sFog := true ;
85460: LD_ADDR_EXP 130
85464: PUSH
85465: LD_INT 1
85467: ST_TO_ADDR
// if p3 = 104 then
85468: LD_VAR 0 3
85472: PUSH
85473: LD_INT 104
85475: EQUAL
85476: IFFALSE 85486
// sReset := true ;
85478: LD_ADDR_EXP 131
85482: PUSH
85483: LD_INT 1
85485: ST_TO_ADDR
// if p3 = 105 then
85486: LD_VAR 0 3
85490: PUSH
85491: LD_INT 105
85493: EQUAL
85494: IFFALSE 85504
// sSun := true ;
85496: LD_ADDR_EXP 132
85500: PUSH
85501: LD_INT 1
85503: ST_TO_ADDR
// if p3 = 106 then
85504: LD_VAR 0 3
85508: PUSH
85509: LD_INT 106
85511: EQUAL
85512: IFFALSE 85522
// sTiger := true ;
85514: LD_ADDR_EXP 128
85518: PUSH
85519: LD_INT 1
85521: ST_TO_ADDR
// if p3 = 107 then
85522: LD_VAR 0 3
85526: PUSH
85527: LD_INT 107
85529: EQUAL
85530: IFFALSE 85540
// sBomb := true ;
85532: LD_ADDR_EXP 129
85536: PUSH
85537: LD_INT 1
85539: ST_TO_ADDR
// if p3 = 108 then
85540: LD_VAR 0 3
85544: PUSH
85545: LD_INT 108
85547: EQUAL
85548: IFFALSE 85558
// sWound := true ;
85550: LD_ADDR_EXP 137
85554: PUSH
85555: LD_INT 1
85557: ST_TO_ADDR
// if p3 = 109 then
85558: LD_VAR 0 3
85562: PUSH
85563: LD_INT 109
85565: EQUAL
85566: IFFALSE 85576
// sBetray := true ;
85568: LD_ADDR_EXP 141
85572: PUSH
85573: LD_INT 1
85575: ST_TO_ADDR
// if p3 = 110 then
85576: LD_VAR 0 3
85580: PUSH
85581: LD_INT 110
85583: EQUAL
85584: IFFALSE 85594
// sContamin := true ;
85586: LD_ADDR_EXP 142
85590: PUSH
85591: LD_INT 1
85593: ST_TO_ADDR
// if p3 = 111 then
85594: LD_VAR 0 3
85598: PUSH
85599: LD_INT 111
85601: EQUAL
85602: IFFALSE 85612
// sOil := true ;
85604: LD_ADDR_EXP 144
85608: PUSH
85609: LD_INT 1
85611: ST_TO_ADDR
// if p3 = 112 then
85612: LD_VAR 0 3
85616: PUSH
85617: LD_INT 112
85619: EQUAL
85620: IFFALSE 85630
// sStu := true ;
85622: LD_ADDR_EXP 148
85626: PUSH
85627: LD_INT 1
85629: ST_TO_ADDR
// if p3 = 113 then
85630: LD_VAR 0 3
85634: PUSH
85635: LD_INT 113
85637: EQUAL
85638: IFFALSE 85648
// sBazooka := true ;
85640: LD_ADDR_EXP 151
85644: PUSH
85645: LD_INT 1
85647: ST_TO_ADDR
// if p3 = 114 then
85648: LD_VAR 0 3
85652: PUSH
85653: LD_INT 114
85655: EQUAL
85656: IFFALSE 85666
// sMortar := true ;
85658: LD_ADDR_EXP 152
85662: PUSH
85663: LD_INT 1
85665: ST_TO_ADDR
// if p3 = 115 then
85666: LD_VAR 0 3
85670: PUSH
85671: LD_INT 115
85673: EQUAL
85674: IFFALSE 85684
// sRanger := true ;
85676: LD_ADDR_EXP 162
85680: PUSH
85681: LD_INT 1
85683: ST_TO_ADDR
// end ; if p2 = 101 then
85684: LD_VAR 0 2
85688: PUSH
85689: LD_INT 101
85691: EQUAL
85692: IFFALSE 85820
// begin case p3 of 1 :
85694: LD_VAR 0 3
85698: PUSH
85699: LD_INT 1
85701: DOUBLE
85702: EQUAL
85703: IFTRUE 85707
85705: GO 85714
85707: POP
// hHackUnlimitedResources ; 2 :
85708: CALL 96855 0 0
85712: GO 85820
85714: LD_INT 2
85716: DOUBLE
85717: EQUAL
85718: IFTRUE 85722
85720: GO 85729
85722: POP
// hHackSetLevel10 ; 3 :
85723: CALL 96988 0 0
85727: GO 85820
85729: LD_INT 3
85731: DOUBLE
85732: EQUAL
85733: IFTRUE 85737
85735: GO 85744
85737: POP
// hHackSetLevel10YourUnits ; 4 :
85738: CALL 97073 0 0
85742: GO 85820
85744: LD_INT 4
85746: DOUBLE
85747: EQUAL
85748: IFTRUE 85752
85750: GO 85759
85752: POP
// hHackInvincible ; 5 :
85753: CALL 97521 0 0
85757: GO 85820
85759: LD_INT 5
85761: DOUBLE
85762: EQUAL
85763: IFTRUE 85767
85765: GO 85774
85767: POP
// hHackInvisible ; 6 :
85768: CALL 97632 0 0
85772: GO 85820
85774: LD_INT 6
85776: DOUBLE
85777: EQUAL
85778: IFTRUE 85782
85780: GO 85789
85782: POP
// hHackChangeYourSide ; 7 :
85783: CALL 97689 0 0
85787: GO 85820
85789: LD_INT 7
85791: DOUBLE
85792: EQUAL
85793: IFTRUE 85797
85795: GO 85804
85797: POP
// hHackChangeUnitSide ; 8 :
85798: CALL 97731 0 0
85802: GO 85820
85804: LD_INT 8
85806: DOUBLE
85807: EQUAL
85808: IFTRUE 85812
85810: GO 85819
85812: POP
// hHackFog ; end ;
85813: CALL 97832 0 0
85817: GO 85820
85819: POP
// end ; end ;
85820: PPOPN 6
85822: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
85823: GO 85825
85825: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85826: LD_STRING initStreamRollete();
85828: PPUSH
85829: CALL_OW 559
// InitStreamMode ;
85833: CALL 85842 0 0
// DefineStreamItems ( ) ;
85837: CALL 86282 0 0
// end ;
85841: END
// function InitStreamMode ; begin
85842: LD_INT 0
85844: PPUSH
// streamModeActive := false ;
85845: LD_ADDR_EXP 109
85849: PUSH
85850: LD_INT 0
85852: ST_TO_ADDR
// normalCounter := 36 ;
85853: LD_ADDR_EXP 110
85857: PUSH
85858: LD_INT 36
85860: ST_TO_ADDR
// hardcoreCounter := 16 ;
85861: LD_ADDR_EXP 111
85865: PUSH
85866: LD_INT 16
85868: ST_TO_ADDR
// sRocket := false ;
85869: LD_ADDR_EXP 114
85873: PUSH
85874: LD_INT 0
85876: ST_TO_ADDR
// sSpeed := false ;
85877: LD_ADDR_EXP 113
85881: PUSH
85882: LD_INT 0
85884: ST_TO_ADDR
// sEngine := false ;
85885: LD_ADDR_EXP 115
85889: PUSH
85890: LD_INT 0
85892: ST_TO_ADDR
// sSpec := false ;
85893: LD_ADDR_EXP 112
85897: PUSH
85898: LD_INT 0
85900: ST_TO_ADDR
// sLevel := false ;
85901: LD_ADDR_EXP 116
85905: PUSH
85906: LD_INT 0
85908: ST_TO_ADDR
// sArmoury := false ;
85909: LD_ADDR_EXP 117
85913: PUSH
85914: LD_INT 0
85916: ST_TO_ADDR
// sRadar := false ;
85917: LD_ADDR_EXP 118
85921: PUSH
85922: LD_INT 0
85924: ST_TO_ADDR
// sBunker := false ;
85925: LD_ADDR_EXP 119
85929: PUSH
85930: LD_INT 0
85932: ST_TO_ADDR
// sHack := false ;
85933: LD_ADDR_EXP 120
85937: PUSH
85938: LD_INT 0
85940: ST_TO_ADDR
// sFire := false ;
85941: LD_ADDR_EXP 121
85945: PUSH
85946: LD_INT 0
85948: ST_TO_ADDR
// sRefresh := false ;
85949: LD_ADDR_EXP 122
85953: PUSH
85954: LD_INT 0
85956: ST_TO_ADDR
// sExp := false ;
85957: LD_ADDR_EXP 123
85961: PUSH
85962: LD_INT 0
85964: ST_TO_ADDR
// sDepot := false ;
85965: LD_ADDR_EXP 124
85969: PUSH
85970: LD_INT 0
85972: ST_TO_ADDR
// sFlag := false ;
85973: LD_ADDR_EXP 125
85977: PUSH
85978: LD_INT 0
85980: ST_TO_ADDR
// sKamikadze := false ;
85981: LD_ADDR_EXP 133
85985: PUSH
85986: LD_INT 0
85988: ST_TO_ADDR
// sTroll := false ;
85989: LD_ADDR_EXP 134
85993: PUSH
85994: LD_INT 0
85996: ST_TO_ADDR
// sSlow := false ;
85997: LD_ADDR_EXP 135
86001: PUSH
86002: LD_INT 0
86004: ST_TO_ADDR
// sLack := false ;
86005: LD_ADDR_EXP 136
86009: PUSH
86010: LD_INT 0
86012: ST_TO_ADDR
// sTank := false ;
86013: LD_ADDR_EXP 138
86017: PUSH
86018: LD_INT 0
86020: ST_TO_ADDR
// sRemote := false ;
86021: LD_ADDR_EXP 139
86025: PUSH
86026: LD_INT 0
86028: ST_TO_ADDR
// sPowell := false ;
86029: LD_ADDR_EXP 140
86033: PUSH
86034: LD_INT 0
86036: ST_TO_ADDR
// sTeleport := false ;
86037: LD_ADDR_EXP 143
86041: PUSH
86042: LD_INT 0
86044: ST_TO_ADDR
// sOilTower := false ;
86045: LD_ADDR_EXP 145
86049: PUSH
86050: LD_INT 0
86052: ST_TO_ADDR
// sShovel := false ;
86053: LD_ADDR_EXP 146
86057: PUSH
86058: LD_INT 0
86060: ST_TO_ADDR
// sSheik := false ;
86061: LD_ADDR_EXP 147
86065: PUSH
86066: LD_INT 0
86068: ST_TO_ADDR
// sEarthquake := false ;
86069: LD_ADDR_EXP 149
86073: PUSH
86074: LD_INT 0
86076: ST_TO_ADDR
// sAI := false ;
86077: LD_ADDR_EXP 150
86081: PUSH
86082: LD_INT 0
86084: ST_TO_ADDR
// sCargo := false ;
86085: LD_ADDR_EXP 153
86089: PUSH
86090: LD_INT 0
86092: ST_TO_ADDR
// sDLaser := false ;
86093: LD_ADDR_EXP 154
86097: PUSH
86098: LD_INT 0
86100: ST_TO_ADDR
// sExchange := false ;
86101: LD_ADDR_EXP 155
86105: PUSH
86106: LD_INT 0
86108: ST_TO_ADDR
// sFac := false ;
86109: LD_ADDR_EXP 156
86113: PUSH
86114: LD_INT 0
86116: ST_TO_ADDR
// sPower := false ;
86117: LD_ADDR_EXP 157
86121: PUSH
86122: LD_INT 0
86124: ST_TO_ADDR
// sRandom := false ;
86125: LD_ADDR_EXP 158
86129: PUSH
86130: LD_INT 0
86132: ST_TO_ADDR
// sShield := false ;
86133: LD_ADDR_EXP 159
86137: PUSH
86138: LD_INT 0
86140: ST_TO_ADDR
// sTime := false ;
86141: LD_ADDR_EXP 160
86145: PUSH
86146: LD_INT 0
86148: ST_TO_ADDR
// sTools := false ;
86149: LD_ADDR_EXP 161
86153: PUSH
86154: LD_INT 0
86156: ST_TO_ADDR
// sSold := false ;
86157: LD_ADDR_EXP 126
86161: PUSH
86162: LD_INT 0
86164: ST_TO_ADDR
// sDiff := false ;
86165: LD_ADDR_EXP 127
86169: PUSH
86170: LD_INT 0
86172: ST_TO_ADDR
// sFog := false ;
86173: LD_ADDR_EXP 130
86177: PUSH
86178: LD_INT 0
86180: ST_TO_ADDR
// sReset := false ;
86181: LD_ADDR_EXP 131
86185: PUSH
86186: LD_INT 0
86188: ST_TO_ADDR
// sSun := false ;
86189: LD_ADDR_EXP 132
86193: PUSH
86194: LD_INT 0
86196: ST_TO_ADDR
// sTiger := false ;
86197: LD_ADDR_EXP 128
86201: PUSH
86202: LD_INT 0
86204: ST_TO_ADDR
// sBomb := false ;
86205: LD_ADDR_EXP 129
86209: PUSH
86210: LD_INT 0
86212: ST_TO_ADDR
// sWound := false ;
86213: LD_ADDR_EXP 137
86217: PUSH
86218: LD_INT 0
86220: ST_TO_ADDR
// sBetray := false ;
86221: LD_ADDR_EXP 141
86225: PUSH
86226: LD_INT 0
86228: ST_TO_ADDR
// sContamin := false ;
86229: LD_ADDR_EXP 142
86233: PUSH
86234: LD_INT 0
86236: ST_TO_ADDR
// sOil := false ;
86237: LD_ADDR_EXP 144
86241: PUSH
86242: LD_INT 0
86244: ST_TO_ADDR
// sStu := false ;
86245: LD_ADDR_EXP 148
86249: PUSH
86250: LD_INT 0
86252: ST_TO_ADDR
// sBazooka := false ;
86253: LD_ADDR_EXP 151
86257: PUSH
86258: LD_INT 0
86260: ST_TO_ADDR
// sMortar := false ;
86261: LD_ADDR_EXP 152
86265: PUSH
86266: LD_INT 0
86268: ST_TO_ADDR
// sRanger := false ;
86269: LD_ADDR_EXP 162
86273: PUSH
86274: LD_INT 0
86276: ST_TO_ADDR
// end ;
86277: LD_VAR 0 1
86281: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86282: LD_INT 0
86284: PPUSH
86285: PPUSH
86286: PPUSH
86287: PPUSH
86288: PPUSH
// result := [ ] ;
86289: LD_ADDR_VAR 0 1
86293: PUSH
86294: EMPTY
86295: ST_TO_ADDR
// if campaign_id = 1 then
86296: LD_OWVAR 69
86300: PUSH
86301: LD_INT 1
86303: EQUAL
86304: IFFALSE 89242
// begin case mission_number of 1 :
86306: LD_OWVAR 70
86310: PUSH
86311: LD_INT 1
86313: DOUBLE
86314: EQUAL
86315: IFTRUE 86319
86317: GO 86383
86319: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
86320: LD_ADDR_VAR 0 1
86324: PUSH
86325: LD_INT 2
86327: PUSH
86328: LD_INT 4
86330: PUSH
86331: LD_INT 11
86333: PUSH
86334: LD_INT 12
86336: PUSH
86337: LD_INT 15
86339: PUSH
86340: LD_INT 16
86342: PUSH
86343: LD_INT 22
86345: PUSH
86346: LD_INT 23
86348: PUSH
86349: LD_INT 26
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 101
86365: PUSH
86366: LD_INT 102
86368: PUSH
86369: LD_INT 106
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: LIST
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: ST_TO_ADDR
86381: GO 89240
86383: LD_INT 2
86385: DOUBLE
86386: EQUAL
86387: IFTRUE 86391
86389: GO 86463
86391: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
86392: LD_ADDR_VAR 0 1
86396: PUSH
86397: LD_INT 2
86399: PUSH
86400: LD_INT 4
86402: PUSH
86403: LD_INT 11
86405: PUSH
86406: LD_INT 12
86408: PUSH
86409: LD_INT 15
86411: PUSH
86412: LD_INT 16
86414: PUSH
86415: LD_INT 22
86417: PUSH
86418: LD_INT 23
86420: PUSH
86421: LD_INT 26
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 101
86437: PUSH
86438: LD_INT 102
86440: PUSH
86441: LD_INT 105
86443: PUSH
86444: LD_INT 106
86446: PUSH
86447: LD_INT 108
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: ST_TO_ADDR
86461: GO 89240
86463: LD_INT 3
86465: DOUBLE
86466: EQUAL
86467: IFTRUE 86471
86469: GO 86547
86471: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86472: LD_ADDR_VAR 0 1
86476: PUSH
86477: LD_INT 2
86479: PUSH
86480: LD_INT 4
86482: PUSH
86483: LD_INT 5
86485: PUSH
86486: LD_INT 11
86488: PUSH
86489: LD_INT 12
86491: PUSH
86492: LD_INT 15
86494: PUSH
86495: LD_INT 16
86497: PUSH
86498: LD_INT 22
86500: PUSH
86501: LD_INT 26
86503: PUSH
86504: LD_INT 36
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 101
86521: PUSH
86522: LD_INT 102
86524: PUSH
86525: LD_INT 105
86527: PUSH
86528: LD_INT 106
86530: PUSH
86531: LD_INT 108
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: ST_TO_ADDR
86545: GO 89240
86547: LD_INT 4
86549: DOUBLE
86550: EQUAL
86551: IFTRUE 86555
86553: GO 86639
86555: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86556: LD_ADDR_VAR 0 1
86560: PUSH
86561: LD_INT 2
86563: PUSH
86564: LD_INT 4
86566: PUSH
86567: LD_INT 5
86569: PUSH
86570: LD_INT 8
86572: PUSH
86573: LD_INT 11
86575: PUSH
86576: LD_INT 12
86578: PUSH
86579: LD_INT 15
86581: PUSH
86582: LD_INT 16
86584: PUSH
86585: LD_INT 22
86587: PUSH
86588: LD_INT 23
86590: PUSH
86591: LD_INT 26
86593: PUSH
86594: LD_INT 36
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 101
86613: PUSH
86614: LD_INT 102
86616: PUSH
86617: LD_INT 105
86619: PUSH
86620: LD_INT 106
86622: PUSH
86623: LD_INT 108
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: ST_TO_ADDR
86637: GO 89240
86639: LD_INT 5
86641: DOUBLE
86642: EQUAL
86643: IFTRUE 86647
86645: GO 86747
86647: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
86648: LD_ADDR_VAR 0 1
86652: PUSH
86653: LD_INT 2
86655: PUSH
86656: LD_INT 4
86658: PUSH
86659: LD_INT 5
86661: PUSH
86662: LD_INT 6
86664: PUSH
86665: LD_INT 8
86667: PUSH
86668: LD_INT 11
86670: PUSH
86671: LD_INT 12
86673: PUSH
86674: LD_INT 15
86676: PUSH
86677: LD_INT 16
86679: PUSH
86680: LD_INT 22
86682: PUSH
86683: LD_INT 23
86685: PUSH
86686: LD_INT 25
86688: PUSH
86689: LD_INT 26
86691: PUSH
86692: LD_INT 36
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 101
86713: PUSH
86714: LD_INT 102
86716: PUSH
86717: LD_INT 105
86719: PUSH
86720: LD_INT 106
86722: PUSH
86723: LD_INT 108
86725: PUSH
86726: LD_INT 109
86728: PUSH
86729: LD_INT 112
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: ST_TO_ADDR
86745: GO 89240
86747: LD_INT 6
86749: DOUBLE
86750: EQUAL
86751: IFTRUE 86755
86753: GO 86875
86755: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
86756: LD_ADDR_VAR 0 1
86760: PUSH
86761: LD_INT 2
86763: PUSH
86764: LD_INT 4
86766: PUSH
86767: LD_INT 5
86769: PUSH
86770: LD_INT 6
86772: PUSH
86773: LD_INT 8
86775: PUSH
86776: LD_INT 11
86778: PUSH
86779: LD_INT 12
86781: PUSH
86782: LD_INT 15
86784: PUSH
86785: LD_INT 16
86787: PUSH
86788: LD_INT 20
86790: PUSH
86791: LD_INT 21
86793: PUSH
86794: LD_INT 22
86796: PUSH
86797: LD_INT 23
86799: PUSH
86800: LD_INT 25
86802: PUSH
86803: LD_INT 26
86805: PUSH
86806: LD_INT 30
86808: PUSH
86809: LD_INT 31
86811: PUSH
86812: LD_INT 32
86814: PUSH
86815: LD_INT 36
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 101
86841: PUSH
86842: LD_INT 102
86844: PUSH
86845: LD_INT 105
86847: PUSH
86848: LD_INT 106
86850: PUSH
86851: LD_INT 108
86853: PUSH
86854: LD_INT 109
86856: PUSH
86857: LD_INT 112
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: ST_TO_ADDR
86873: GO 89240
86875: LD_INT 7
86877: DOUBLE
86878: EQUAL
86879: IFTRUE 86883
86881: GO 86983
86883: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
86884: LD_ADDR_VAR 0 1
86888: PUSH
86889: LD_INT 2
86891: PUSH
86892: LD_INT 4
86894: PUSH
86895: LD_INT 5
86897: PUSH
86898: LD_INT 7
86900: PUSH
86901: LD_INT 11
86903: PUSH
86904: LD_INT 12
86906: PUSH
86907: LD_INT 15
86909: PUSH
86910: LD_INT 16
86912: PUSH
86913: LD_INT 20
86915: PUSH
86916: LD_INT 21
86918: PUSH
86919: LD_INT 22
86921: PUSH
86922: LD_INT 23
86924: PUSH
86925: LD_INT 25
86927: PUSH
86928: LD_INT 26
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 101
86949: PUSH
86950: LD_INT 102
86952: PUSH
86953: LD_INT 103
86955: PUSH
86956: LD_INT 105
86958: PUSH
86959: LD_INT 106
86961: PUSH
86962: LD_INT 108
86964: PUSH
86965: LD_INT 112
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: ST_TO_ADDR
86981: GO 89240
86983: LD_INT 8
86985: DOUBLE
86986: EQUAL
86987: IFTRUE 86991
86989: GO 87119
86991: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
86992: LD_ADDR_VAR 0 1
86996: PUSH
86997: LD_INT 2
86999: PUSH
87000: LD_INT 4
87002: PUSH
87003: LD_INT 5
87005: PUSH
87006: LD_INT 6
87008: PUSH
87009: LD_INT 7
87011: PUSH
87012: LD_INT 8
87014: PUSH
87015: LD_INT 11
87017: PUSH
87018: LD_INT 12
87020: PUSH
87021: LD_INT 15
87023: PUSH
87024: LD_INT 16
87026: PUSH
87027: LD_INT 20
87029: PUSH
87030: LD_INT 21
87032: PUSH
87033: LD_INT 22
87035: PUSH
87036: LD_INT 23
87038: PUSH
87039: LD_INT 25
87041: PUSH
87042: LD_INT 26
87044: PUSH
87045: LD_INT 30
87047: PUSH
87048: LD_INT 31
87050: PUSH
87051: LD_INT 32
87053: PUSH
87054: LD_INT 36
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 101
87081: PUSH
87082: LD_INT 102
87084: PUSH
87085: LD_INT 103
87087: PUSH
87088: LD_INT 105
87090: PUSH
87091: LD_INT 106
87093: PUSH
87094: LD_INT 108
87096: PUSH
87097: LD_INT 109
87099: PUSH
87100: LD_INT 112
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: ST_TO_ADDR
87117: GO 89240
87119: LD_INT 9
87121: DOUBLE
87122: EQUAL
87123: IFTRUE 87127
87125: GO 87263
87127: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
87128: LD_ADDR_VAR 0 1
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: LD_INT 4
87138: PUSH
87139: LD_INT 5
87141: PUSH
87142: LD_INT 6
87144: PUSH
87145: LD_INT 7
87147: PUSH
87148: LD_INT 8
87150: PUSH
87151: LD_INT 11
87153: PUSH
87154: LD_INT 12
87156: PUSH
87157: LD_INT 15
87159: PUSH
87160: LD_INT 16
87162: PUSH
87163: LD_INT 20
87165: PUSH
87166: LD_INT 21
87168: PUSH
87169: LD_INT 22
87171: PUSH
87172: LD_INT 23
87174: PUSH
87175: LD_INT 25
87177: PUSH
87178: LD_INT 26
87180: PUSH
87181: LD_INT 28
87183: PUSH
87184: LD_INT 30
87186: PUSH
87187: LD_INT 31
87189: PUSH
87190: LD_INT 32
87192: PUSH
87193: LD_INT 36
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 101
87221: PUSH
87222: LD_INT 102
87224: PUSH
87225: LD_INT 103
87227: PUSH
87228: LD_INT 105
87230: PUSH
87231: LD_INT 106
87233: PUSH
87234: LD_INT 108
87236: PUSH
87237: LD_INT 109
87239: PUSH
87240: LD_INT 112
87242: PUSH
87243: LD_INT 114
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: ST_TO_ADDR
87261: GO 89240
87263: LD_INT 10
87265: DOUBLE
87266: EQUAL
87267: IFTRUE 87271
87269: GO 87455
87271: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
87272: LD_ADDR_VAR 0 1
87276: PUSH
87277: LD_INT 2
87279: PUSH
87280: LD_INT 4
87282: PUSH
87283: LD_INT 5
87285: PUSH
87286: LD_INT 6
87288: PUSH
87289: LD_INT 7
87291: PUSH
87292: LD_INT 8
87294: PUSH
87295: LD_INT 9
87297: PUSH
87298: LD_INT 10
87300: PUSH
87301: LD_INT 11
87303: PUSH
87304: LD_INT 12
87306: PUSH
87307: LD_INT 13
87309: PUSH
87310: LD_INT 14
87312: PUSH
87313: LD_INT 15
87315: PUSH
87316: LD_INT 16
87318: PUSH
87319: LD_INT 17
87321: PUSH
87322: LD_INT 18
87324: PUSH
87325: LD_INT 19
87327: PUSH
87328: LD_INT 20
87330: PUSH
87331: LD_INT 21
87333: PUSH
87334: LD_INT 22
87336: PUSH
87337: LD_INT 23
87339: PUSH
87340: LD_INT 24
87342: PUSH
87343: LD_INT 25
87345: PUSH
87346: LD_INT 26
87348: PUSH
87349: LD_INT 28
87351: PUSH
87352: LD_INT 30
87354: PUSH
87355: LD_INT 31
87357: PUSH
87358: LD_INT 32
87360: PUSH
87361: LD_INT 36
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 101
87397: PUSH
87398: LD_INT 102
87400: PUSH
87401: LD_INT 103
87403: PUSH
87404: LD_INT 104
87406: PUSH
87407: LD_INT 105
87409: PUSH
87410: LD_INT 106
87412: PUSH
87413: LD_INT 107
87415: PUSH
87416: LD_INT 108
87418: PUSH
87419: LD_INT 109
87421: PUSH
87422: LD_INT 110
87424: PUSH
87425: LD_INT 111
87427: PUSH
87428: LD_INT 112
87430: PUSH
87431: LD_INT 114
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: ST_TO_ADDR
87453: GO 89240
87455: LD_INT 11
87457: DOUBLE
87458: EQUAL
87459: IFTRUE 87463
87461: GO 87655
87463: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87464: LD_ADDR_VAR 0 1
87468: PUSH
87469: LD_INT 2
87471: PUSH
87472: LD_INT 3
87474: PUSH
87475: LD_INT 4
87477: PUSH
87478: LD_INT 5
87480: PUSH
87481: LD_INT 6
87483: PUSH
87484: LD_INT 7
87486: PUSH
87487: LD_INT 8
87489: PUSH
87490: LD_INT 9
87492: PUSH
87493: LD_INT 10
87495: PUSH
87496: LD_INT 11
87498: PUSH
87499: LD_INT 12
87501: PUSH
87502: LD_INT 13
87504: PUSH
87505: LD_INT 14
87507: PUSH
87508: LD_INT 15
87510: PUSH
87511: LD_INT 16
87513: PUSH
87514: LD_INT 17
87516: PUSH
87517: LD_INT 18
87519: PUSH
87520: LD_INT 19
87522: PUSH
87523: LD_INT 20
87525: PUSH
87526: LD_INT 21
87528: PUSH
87529: LD_INT 22
87531: PUSH
87532: LD_INT 23
87534: PUSH
87535: LD_INT 24
87537: PUSH
87538: LD_INT 25
87540: PUSH
87541: LD_INT 26
87543: PUSH
87544: LD_INT 28
87546: PUSH
87547: LD_INT 30
87549: PUSH
87550: LD_INT 31
87552: PUSH
87553: LD_INT 32
87555: PUSH
87556: LD_INT 34
87558: PUSH
87559: LD_INT 36
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: PUSH
87595: LD_INT 101
87597: PUSH
87598: LD_INT 102
87600: PUSH
87601: LD_INT 103
87603: PUSH
87604: LD_INT 104
87606: PUSH
87607: LD_INT 105
87609: PUSH
87610: LD_INT 106
87612: PUSH
87613: LD_INT 107
87615: PUSH
87616: LD_INT 108
87618: PUSH
87619: LD_INT 109
87621: PUSH
87622: LD_INT 110
87624: PUSH
87625: LD_INT 111
87627: PUSH
87628: LD_INT 112
87630: PUSH
87631: LD_INT 114
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: ST_TO_ADDR
87653: GO 89240
87655: LD_INT 12
87657: DOUBLE
87658: EQUAL
87659: IFTRUE 87663
87661: GO 87871
87663: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
87664: LD_ADDR_VAR 0 1
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: LD_INT 2
87674: PUSH
87675: LD_INT 3
87677: PUSH
87678: LD_INT 4
87680: PUSH
87681: LD_INT 5
87683: PUSH
87684: LD_INT 6
87686: PUSH
87687: LD_INT 7
87689: PUSH
87690: LD_INT 8
87692: PUSH
87693: LD_INT 9
87695: PUSH
87696: LD_INT 10
87698: PUSH
87699: LD_INT 11
87701: PUSH
87702: LD_INT 12
87704: PUSH
87705: LD_INT 13
87707: PUSH
87708: LD_INT 14
87710: PUSH
87711: LD_INT 15
87713: PUSH
87714: LD_INT 16
87716: PUSH
87717: LD_INT 17
87719: PUSH
87720: LD_INT 18
87722: PUSH
87723: LD_INT 19
87725: PUSH
87726: LD_INT 20
87728: PUSH
87729: LD_INT 21
87731: PUSH
87732: LD_INT 22
87734: PUSH
87735: LD_INT 23
87737: PUSH
87738: LD_INT 24
87740: PUSH
87741: LD_INT 25
87743: PUSH
87744: LD_INT 26
87746: PUSH
87747: LD_INT 27
87749: PUSH
87750: LD_INT 28
87752: PUSH
87753: LD_INT 30
87755: PUSH
87756: LD_INT 31
87758: PUSH
87759: LD_INT 32
87761: PUSH
87762: LD_INT 33
87764: PUSH
87765: LD_INT 34
87767: PUSH
87768: LD_INT 36
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 101
87809: PUSH
87810: LD_INT 102
87812: PUSH
87813: LD_INT 103
87815: PUSH
87816: LD_INT 104
87818: PUSH
87819: LD_INT 105
87821: PUSH
87822: LD_INT 106
87824: PUSH
87825: LD_INT 107
87827: PUSH
87828: LD_INT 108
87830: PUSH
87831: LD_INT 109
87833: PUSH
87834: LD_INT 110
87836: PUSH
87837: LD_INT 111
87839: PUSH
87840: LD_INT 112
87842: PUSH
87843: LD_INT 113
87845: PUSH
87846: LD_INT 114
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: ST_TO_ADDR
87869: GO 89240
87871: LD_INT 13
87873: DOUBLE
87874: EQUAL
87875: IFTRUE 87879
87877: GO 88075
87879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
87880: LD_ADDR_VAR 0 1
87884: PUSH
87885: LD_INT 1
87887: PUSH
87888: LD_INT 2
87890: PUSH
87891: LD_INT 3
87893: PUSH
87894: LD_INT 4
87896: PUSH
87897: LD_INT 5
87899: PUSH
87900: LD_INT 8
87902: PUSH
87903: LD_INT 9
87905: PUSH
87906: LD_INT 10
87908: PUSH
87909: LD_INT 11
87911: PUSH
87912: LD_INT 12
87914: PUSH
87915: LD_INT 14
87917: PUSH
87918: LD_INT 15
87920: PUSH
87921: LD_INT 16
87923: PUSH
87924: LD_INT 17
87926: PUSH
87927: LD_INT 18
87929: PUSH
87930: LD_INT 19
87932: PUSH
87933: LD_INT 20
87935: PUSH
87936: LD_INT 21
87938: PUSH
87939: LD_INT 22
87941: PUSH
87942: LD_INT 23
87944: PUSH
87945: LD_INT 24
87947: PUSH
87948: LD_INT 25
87950: PUSH
87951: LD_INT 26
87953: PUSH
87954: LD_INT 27
87956: PUSH
87957: LD_INT 28
87959: PUSH
87960: LD_INT 30
87962: PUSH
87963: LD_INT 31
87965: PUSH
87966: LD_INT 32
87968: PUSH
87969: LD_INT 33
87971: PUSH
87972: LD_INT 34
87974: PUSH
87975: LD_INT 36
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 101
88013: PUSH
88014: LD_INT 102
88016: PUSH
88017: LD_INT 103
88019: PUSH
88020: LD_INT 104
88022: PUSH
88023: LD_INT 105
88025: PUSH
88026: LD_INT 106
88028: PUSH
88029: LD_INT 107
88031: PUSH
88032: LD_INT 108
88034: PUSH
88035: LD_INT 109
88037: PUSH
88038: LD_INT 110
88040: PUSH
88041: LD_INT 111
88043: PUSH
88044: LD_INT 112
88046: PUSH
88047: LD_INT 113
88049: PUSH
88050: LD_INT 114
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: ST_TO_ADDR
88073: GO 89240
88075: LD_INT 14
88077: DOUBLE
88078: EQUAL
88079: IFTRUE 88083
88081: GO 88295
88083: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
88084: LD_ADDR_VAR 0 1
88088: PUSH
88089: LD_INT 1
88091: PUSH
88092: LD_INT 2
88094: PUSH
88095: LD_INT 3
88097: PUSH
88098: LD_INT 4
88100: PUSH
88101: LD_INT 5
88103: PUSH
88104: LD_INT 6
88106: PUSH
88107: LD_INT 7
88109: PUSH
88110: LD_INT 8
88112: PUSH
88113: LD_INT 9
88115: PUSH
88116: LD_INT 10
88118: PUSH
88119: LD_INT 11
88121: PUSH
88122: LD_INT 12
88124: PUSH
88125: LD_INT 13
88127: PUSH
88128: LD_INT 14
88130: PUSH
88131: LD_INT 15
88133: PUSH
88134: LD_INT 16
88136: PUSH
88137: LD_INT 17
88139: PUSH
88140: LD_INT 18
88142: PUSH
88143: LD_INT 19
88145: PUSH
88146: LD_INT 20
88148: PUSH
88149: LD_INT 21
88151: PUSH
88152: LD_INT 22
88154: PUSH
88155: LD_INT 23
88157: PUSH
88158: LD_INT 24
88160: PUSH
88161: LD_INT 25
88163: PUSH
88164: LD_INT 26
88166: PUSH
88167: LD_INT 27
88169: PUSH
88170: LD_INT 28
88172: PUSH
88173: LD_INT 29
88175: PUSH
88176: LD_INT 30
88178: PUSH
88179: LD_INT 31
88181: PUSH
88182: LD_INT 32
88184: PUSH
88185: LD_INT 33
88187: PUSH
88188: LD_INT 34
88190: PUSH
88191: LD_INT 36
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 101
88233: PUSH
88234: LD_INT 102
88236: PUSH
88237: LD_INT 103
88239: PUSH
88240: LD_INT 104
88242: PUSH
88243: LD_INT 105
88245: PUSH
88246: LD_INT 106
88248: PUSH
88249: LD_INT 107
88251: PUSH
88252: LD_INT 108
88254: PUSH
88255: LD_INT 109
88257: PUSH
88258: LD_INT 110
88260: PUSH
88261: LD_INT 111
88263: PUSH
88264: LD_INT 112
88266: PUSH
88267: LD_INT 113
88269: PUSH
88270: LD_INT 114
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: ST_TO_ADDR
88293: GO 89240
88295: LD_INT 15
88297: DOUBLE
88298: EQUAL
88299: IFTRUE 88303
88301: GO 88515
88303: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
88304: LD_ADDR_VAR 0 1
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: LD_INT 2
88314: PUSH
88315: LD_INT 3
88317: PUSH
88318: LD_INT 4
88320: PUSH
88321: LD_INT 5
88323: PUSH
88324: LD_INT 6
88326: PUSH
88327: LD_INT 7
88329: PUSH
88330: LD_INT 8
88332: PUSH
88333: LD_INT 9
88335: PUSH
88336: LD_INT 10
88338: PUSH
88339: LD_INT 11
88341: PUSH
88342: LD_INT 12
88344: PUSH
88345: LD_INT 13
88347: PUSH
88348: LD_INT 14
88350: PUSH
88351: LD_INT 15
88353: PUSH
88354: LD_INT 16
88356: PUSH
88357: LD_INT 17
88359: PUSH
88360: LD_INT 18
88362: PUSH
88363: LD_INT 19
88365: PUSH
88366: LD_INT 20
88368: PUSH
88369: LD_INT 21
88371: PUSH
88372: LD_INT 22
88374: PUSH
88375: LD_INT 23
88377: PUSH
88378: LD_INT 24
88380: PUSH
88381: LD_INT 25
88383: PUSH
88384: LD_INT 26
88386: PUSH
88387: LD_INT 27
88389: PUSH
88390: LD_INT 28
88392: PUSH
88393: LD_INT 29
88395: PUSH
88396: LD_INT 30
88398: PUSH
88399: LD_INT 31
88401: PUSH
88402: LD_INT 32
88404: PUSH
88405: LD_INT 33
88407: PUSH
88408: LD_INT 34
88410: PUSH
88411: LD_INT 36
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 101
88453: PUSH
88454: LD_INT 102
88456: PUSH
88457: LD_INT 103
88459: PUSH
88460: LD_INT 104
88462: PUSH
88463: LD_INT 105
88465: PUSH
88466: LD_INT 106
88468: PUSH
88469: LD_INT 107
88471: PUSH
88472: LD_INT 108
88474: PUSH
88475: LD_INT 109
88477: PUSH
88478: LD_INT 110
88480: PUSH
88481: LD_INT 111
88483: PUSH
88484: LD_INT 112
88486: PUSH
88487: LD_INT 113
88489: PUSH
88490: LD_INT 114
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: PUSH
88509: EMPTY
88510: LIST
88511: LIST
88512: ST_TO_ADDR
88513: GO 89240
88515: LD_INT 16
88517: DOUBLE
88518: EQUAL
88519: IFTRUE 88523
88521: GO 88647
88523: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88524: LD_ADDR_VAR 0 1
88528: PUSH
88529: LD_INT 2
88531: PUSH
88532: LD_INT 4
88534: PUSH
88535: LD_INT 5
88537: PUSH
88538: LD_INT 7
88540: PUSH
88541: LD_INT 11
88543: PUSH
88544: LD_INT 12
88546: PUSH
88547: LD_INT 15
88549: PUSH
88550: LD_INT 16
88552: PUSH
88553: LD_INT 20
88555: PUSH
88556: LD_INT 21
88558: PUSH
88559: LD_INT 22
88561: PUSH
88562: LD_INT 23
88564: PUSH
88565: LD_INT 25
88567: PUSH
88568: LD_INT 26
88570: PUSH
88571: LD_INT 30
88573: PUSH
88574: LD_INT 31
88576: PUSH
88577: LD_INT 32
88579: PUSH
88580: LD_INT 33
88582: PUSH
88583: LD_INT 34
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 101
88609: PUSH
88610: LD_INT 102
88612: PUSH
88613: LD_INT 103
88615: PUSH
88616: LD_INT 106
88618: PUSH
88619: LD_INT 108
88621: PUSH
88622: LD_INT 112
88624: PUSH
88625: LD_INT 113
88627: PUSH
88628: LD_INT 114
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: ST_TO_ADDR
88645: GO 89240
88647: LD_INT 17
88649: DOUBLE
88650: EQUAL
88651: IFTRUE 88655
88653: GO 88867
88655: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
88656: LD_ADDR_VAR 0 1
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: LD_INT 2
88666: PUSH
88667: LD_INT 3
88669: PUSH
88670: LD_INT 4
88672: PUSH
88673: LD_INT 5
88675: PUSH
88676: LD_INT 6
88678: PUSH
88679: LD_INT 7
88681: PUSH
88682: LD_INT 8
88684: PUSH
88685: LD_INT 9
88687: PUSH
88688: LD_INT 10
88690: PUSH
88691: LD_INT 11
88693: PUSH
88694: LD_INT 12
88696: PUSH
88697: LD_INT 13
88699: PUSH
88700: LD_INT 14
88702: PUSH
88703: LD_INT 15
88705: PUSH
88706: LD_INT 16
88708: PUSH
88709: LD_INT 17
88711: PUSH
88712: LD_INT 18
88714: PUSH
88715: LD_INT 19
88717: PUSH
88718: LD_INT 20
88720: PUSH
88721: LD_INT 21
88723: PUSH
88724: LD_INT 22
88726: PUSH
88727: LD_INT 23
88729: PUSH
88730: LD_INT 24
88732: PUSH
88733: LD_INT 25
88735: PUSH
88736: LD_INT 26
88738: PUSH
88739: LD_INT 27
88741: PUSH
88742: LD_INT 28
88744: PUSH
88745: LD_INT 29
88747: PUSH
88748: LD_INT 30
88750: PUSH
88751: LD_INT 31
88753: PUSH
88754: LD_INT 32
88756: PUSH
88757: LD_INT 33
88759: PUSH
88760: LD_INT 34
88762: PUSH
88763: LD_INT 36
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 101
88805: PUSH
88806: LD_INT 102
88808: PUSH
88809: LD_INT 103
88811: PUSH
88812: LD_INT 104
88814: PUSH
88815: LD_INT 105
88817: PUSH
88818: LD_INT 106
88820: PUSH
88821: LD_INT 107
88823: PUSH
88824: LD_INT 108
88826: PUSH
88827: LD_INT 109
88829: PUSH
88830: LD_INT 110
88832: PUSH
88833: LD_INT 111
88835: PUSH
88836: LD_INT 112
88838: PUSH
88839: LD_INT 113
88841: PUSH
88842: LD_INT 114
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: ST_TO_ADDR
88865: GO 89240
88867: LD_INT 18
88869: DOUBLE
88870: EQUAL
88871: IFTRUE 88875
88873: GO 89011
88875: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
88876: LD_ADDR_VAR 0 1
88880: PUSH
88881: LD_INT 2
88883: PUSH
88884: LD_INT 4
88886: PUSH
88887: LD_INT 5
88889: PUSH
88890: LD_INT 7
88892: PUSH
88893: LD_INT 11
88895: PUSH
88896: LD_INT 12
88898: PUSH
88899: LD_INT 15
88901: PUSH
88902: LD_INT 16
88904: PUSH
88905: LD_INT 20
88907: PUSH
88908: LD_INT 21
88910: PUSH
88911: LD_INT 22
88913: PUSH
88914: LD_INT 23
88916: PUSH
88917: LD_INT 25
88919: PUSH
88920: LD_INT 26
88922: PUSH
88923: LD_INT 30
88925: PUSH
88926: LD_INT 31
88928: PUSH
88929: LD_INT 32
88931: PUSH
88932: LD_INT 33
88934: PUSH
88935: LD_INT 34
88937: PUSH
88938: LD_INT 35
88940: PUSH
88941: LD_INT 36
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 101
88969: PUSH
88970: LD_INT 102
88972: PUSH
88973: LD_INT 103
88975: PUSH
88976: LD_INT 106
88978: PUSH
88979: LD_INT 108
88981: PUSH
88982: LD_INT 112
88984: PUSH
88985: LD_INT 113
88987: PUSH
88988: LD_INT 114
88990: PUSH
88991: LD_INT 115
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: ST_TO_ADDR
89009: GO 89240
89011: LD_INT 19
89013: DOUBLE
89014: EQUAL
89015: IFTRUE 89019
89017: GO 89239
89019: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
89020: LD_ADDR_VAR 0 1
89024: PUSH
89025: LD_INT 1
89027: PUSH
89028: LD_INT 2
89030: PUSH
89031: LD_INT 3
89033: PUSH
89034: LD_INT 4
89036: PUSH
89037: LD_INT 5
89039: PUSH
89040: LD_INT 6
89042: PUSH
89043: LD_INT 7
89045: PUSH
89046: LD_INT 8
89048: PUSH
89049: LD_INT 9
89051: PUSH
89052: LD_INT 10
89054: PUSH
89055: LD_INT 11
89057: PUSH
89058: LD_INT 12
89060: PUSH
89061: LD_INT 13
89063: PUSH
89064: LD_INT 14
89066: PUSH
89067: LD_INT 15
89069: PUSH
89070: LD_INT 16
89072: PUSH
89073: LD_INT 17
89075: PUSH
89076: LD_INT 18
89078: PUSH
89079: LD_INT 19
89081: PUSH
89082: LD_INT 20
89084: PUSH
89085: LD_INT 21
89087: PUSH
89088: LD_INT 22
89090: PUSH
89091: LD_INT 23
89093: PUSH
89094: LD_INT 24
89096: PUSH
89097: LD_INT 25
89099: PUSH
89100: LD_INT 26
89102: PUSH
89103: LD_INT 27
89105: PUSH
89106: LD_INT 28
89108: PUSH
89109: LD_INT 29
89111: PUSH
89112: LD_INT 30
89114: PUSH
89115: LD_INT 31
89117: PUSH
89118: LD_INT 32
89120: PUSH
89121: LD_INT 33
89123: PUSH
89124: LD_INT 34
89126: PUSH
89127: LD_INT 35
89129: PUSH
89130: LD_INT 36
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 101
89173: PUSH
89174: LD_INT 102
89176: PUSH
89177: LD_INT 103
89179: PUSH
89180: LD_INT 104
89182: PUSH
89183: LD_INT 105
89185: PUSH
89186: LD_INT 106
89188: PUSH
89189: LD_INT 107
89191: PUSH
89192: LD_INT 108
89194: PUSH
89195: LD_INT 109
89197: PUSH
89198: LD_INT 110
89200: PUSH
89201: LD_INT 111
89203: PUSH
89204: LD_INT 112
89206: PUSH
89207: LD_INT 113
89209: PUSH
89210: LD_INT 114
89212: PUSH
89213: LD_INT 115
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: ST_TO_ADDR
89237: GO 89240
89239: POP
// end else
89240: GO 89459
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
89242: LD_ADDR_VAR 0 1
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: LD_INT 2
89252: PUSH
89253: LD_INT 3
89255: PUSH
89256: LD_INT 4
89258: PUSH
89259: LD_INT 5
89261: PUSH
89262: LD_INT 6
89264: PUSH
89265: LD_INT 7
89267: PUSH
89268: LD_INT 8
89270: PUSH
89271: LD_INT 9
89273: PUSH
89274: LD_INT 10
89276: PUSH
89277: LD_INT 11
89279: PUSH
89280: LD_INT 12
89282: PUSH
89283: LD_INT 13
89285: PUSH
89286: LD_INT 14
89288: PUSH
89289: LD_INT 15
89291: PUSH
89292: LD_INT 16
89294: PUSH
89295: LD_INT 17
89297: PUSH
89298: LD_INT 18
89300: PUSH
89301: LD_INT 19
89303: PUSH
89304: LD_INT 20
89306: PUSH
89307: LD_INT 21
89309: PUSH
89310: LD_INT 22
89312: PUSH
89313: LD_INT 23
89315: PUSH
89316: LD_INT 24
89318: PUSH
89319: LD_INT 25
89321: PUSH
89322: LD_INT 26
89324: PUSH
89325: LD_INT 27
89327: PUSH
89328: LD_INT 28
89330: PUSH
89331: LD_INT 29
89333: PUSH
89334: LD_INT 30
89336: PUSH
89337: LD_INT 31
89339: PUSH
89340: LD_INT 32
89342: PUSH
89343: LD_INT 33
89345: PUSH
89346: LD_INT 34
89348: PUSH
89349: LD_INT 35
89351: PUSH
89352: LD_INT 36
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 101
89395: PUSH
89396: LD_INT 102
89398: PUSH
89399: LD_INT 103
89401: PUSH
89402: LD_INT 104
89404: PUSH
89405: LD_INT 105
89407: PUSH
89408: LD_INT 106
89410: PUSH
89411: LD_INT 107
89413: PUSH
89414: LD_INT 108
89416: PUSH
89417: LD_INT 109
89419: PUSH
89420: LD_INT 110
89422: PUSH
89423: LD_INT 111
89425: PUSH
89426: LD_INT 112
89428: PUSH
89429: LD_INT 113
89431: PUSH
89432: LD_INT 114
89434: PUSH
89435: LD_INT 115
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: ST_TO_ADDR
// if result then
89459: LD_VAR 0 1
89463: IFFALSE 89752
// begin normal :=  ;
89465: LD_ADDR_VAR 0 3
89469: PUSH
89470: LD_STRING 
89472: ST_TO_ADDR
// hardcore :=  ;
89473: LD_ADDR_VAR 0 4
89477: PUSH
89478: LD_STRING 
89480: ST_TO_ADDR
// for i = 1 to normalCounter do
89481: LD_ADDR_VAR 0 5
89485: PUSH
89486: DOUBLE
89487: LD_INT 1
89489: DEC
89490: ST_TO_ADDR
89491: LD_EXP 110
89495: PUSH
89496: FOR_TO
89497: IFFALSE 89598
// begin tmp := 0 ;
89499: LD_ADDR_VAR 0 2
89503: PUSH
89504: LD_STRING 0
89506: ST_TO_ADDR
// if result [ 1 ] then
89507: LD_VAR 0 1
89511: PUSH
89512: LD_INT 1
89514: ARRAY
89515: IFFALSE 89580
// if result [ 1 ] [ 1 ] = i then
89517: LD_VAR 0 1
89521: PUSH
89522: LD_INT 1
89524: ARRAY
89525: PUSH
89526: LD_INT 1
89528: ARRAY
89529: PUSH
89530: LD_VAR 0 5
89534: EQUAL
89535: IFFALSE 89580
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89537: LD_ADDR_VAR 0 1
89541: PUSH
89542: LD_VAR 0 1
89546: PPUSH
89547: LD_INT 1
89549: PPUSH
89550: LD_VAR 0 1
89554: PUSH
89555: LD_INT 1
89557: ARRAY
89558: PPUSH
89559: LD_INT 1
89561: PPUSH
89562: CALL_OW 3
89566: PPUSH
89567: CALL_OW 1
89571: ST_TO_ADDR
// tmp := 1 ;
89572: LD_ADDR_VAR 0 2
89576: PUSH
89577: LD_STRING 1
89579: ST_TO_ADDR
// end ; normal := normal & tmp ;
89580: LD_ADDR_VAR 0 3
89584: PUSH
89585: LD_VAR 0 3
89589: PUSH
89590: LD_VAR 0 2
89594: STR
89595: ST_TO_ADDR
// end ;
89596: GO 89496
89598: POP
89599: POP
// for i = 1 to hardcoreCounter do
89600: LD_ADDR_VAR 0 5
89604: PUSH
89605: DOUBLE
89606: LD_INT 1
89608: DEC
89609: ST_TO_ADDR
89610: LD_EXP 111
89614: PUSH
89615: FOR_TO
89616: IFFALSE 89721
// begin tmp := 0 ;
89618: LD_ADDR_VAR 0 2
89622: PUSH
89623: LD_STRING 0
89625: ST_TO_ADDR
// if result [ 2 ] then
89626: LD_VAR 0 1
89630: PUSH
89631: LD_INT 2
89633: ARRAY
89634: IFFALSE 89703
// if result [ 2 ] [ 1 ] = 100 + i then
89636: LD_VAR 0 1
89640: PUSH
89641: LD_INT 2
89643: ARRAY
89644: PUSH
89645: LD_INT 1
89647: ARRAY
89648: PUSH
89649: LD_INT 100
89651: PUSH
89652: LD_VAR 0 5
89656: PLUS
89657: EQUAL
89658: IFFALSE 89703
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89660: LD_ADDR_VAR 0 1
89664: PUSH
89665: LD_VAR 0 1
89669: PPUSH
89670: LD_INT 2
89672: PPUSH
89673: LD_VAR 0 1
89677: PUSH
89678: LD_INT 2
89680: ARRAY
89681: PPUSH
89682: LD_INT 1
89684: PPUSH
89685: CALL_OW 3
89689: PPUSH
89690: CALL_OW 1
89694: ST_TO_ADDR
// tmp := 1 ;
89695: LD_ADDR_VAR 0 2
89699: PUSH
89700: LD_STRING 1
89702: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89703: LD_ADDR_VAR 0 4
89707: PUSH
89708: LD_VAR 0 4
89712: PUSH
89713: LD_VAR 0 2
89717: STR
89718: ST_TO_ADDR
// end ;
89719: GO 89615
89721: POP
89722: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
89723: LD_STRING getStreamItemsFromMission("
89725: PUSH
89726: LD_VAR 0 3
89730: STR
89731: PUSH
89732: LD_STRING ","
89734: STR
89735: PUSH
89736: LD_VAR 0 4
89740: STR
89741: PUSH
89742: LD_STRING ")
89744: STR
89745: PPUSH
89746: CALL_OW 559
// end else
89750: GO 89759
// ToLua ( getStreamItemsFromMission("","") ) ;
89752: LD_STRING getStreamItemsFromMission("","")
89754: PPUSH
89755: CALL_OW 559
// end ;
89759: LD_VAR 0 1
89763: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89764: LD_EXP 109
89768: PUSH
89769: LD_EXP 114
89773: AND
89774: IFFALSE 89898
89776: GO 89778
89778: DISABLE
89779: LD_INT 0
89781: PPUSH
89782: PPUSH
// begin enable ;
89783: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89784: LD_ADDR_VAR 0 2
89788: PUSH
89789: LD_INT 22
89791: PUSH
89792: LD_OWVAR 2
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 2
89803: PUSH
89804: LD_INT 34
89806: PUSH
89807: LD_INT 7
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: LD_INT 34
89816: PUSH
89817: LD_INT 45
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 34
89826: PUSH
89827: LD_INT 28
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 34
89836: PUSH
89837: LD_INT 47
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PPUSH
89855: CALL_OW 69
89859: ST_TO_ADDR
// if not tmp then
89860: LD_VAR 0 2
89864: NOT
89865: IFFALSE 89869
// exit ;
89867: GO 89898
// for i in tmp do
89869: LD_ADDR_VAR 0 1
89873: PUSH
89874: LD_VAR 0 2
89878: PUSH
89879: FOR_IN
89880: IFFALSE 89896
// begin SetLives ( i , 0 ) ;
89882: LD_VAR 0 1
89886: PPUSH
89887: LD_INT 0
89889: PPUSH
89890: CALL_OW 234
// end ;
89894: GO 89879
89896: POP
89897: POP
// end ;
89898: PPOPN 2
89900: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89901: LD_EXP 109
89905: PUSH
89906: LD_EXP 115
89910: AND
89911: IFFALSE 89995
89913: GO 89915
89915: DISABLE
89916: LD_INT 0
89918: PPUSH
89919: PPUSH
// begin enable ;
89920: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89921: LD_ADDR_VAR 0 2
89925: PUSH
89926: LD_INT 22
89928: PUSH
89929: LD_OWVAR 2
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: LD_INT 32
89940: PUSH
89941: LD_INT 3
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PPUSH
89952: CALL_OW 69
89956: ST_TO_ADDR
// if not tmp then
89957: LD_VAR 0 2
89961: NOT
89962: IFFALSE 89966
// exit ;
89964: GO 89995
// for i in tmp do
89966: LD_ADDR_VAR 0 1
89970: PUSH
89971: LD_VAR 0 2
89975: PUSH
89976: FOR_IN
89977: IFFALSE 89993
// begin SetLives ( i , 0 ) ;
89979: LD_VAR 0 1
89983: PPUSH
89984: LD_INT 0
89986: PPUSH
89987: CALL_OW 234
// end ;
89991: GO 89976
89993: POP
89994: POP
// end ;
89995: PPOPN 2
89997: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89998: LD_EXP 109
90002: PUSH
90003: LD_EXP 112
90007: AND
90008: IFFALSE 90101
90010: GO 90012
90012: DISABLE
90013: LD_INT 0
90015: PPUSH
// begin enable ;
90016: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90017: LD_ADDR_VAR 0 1
90021: PUSH
90022: LD_INT 22
90024: PUSH
90025: LD_OWVAR 2
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 2
90036: PUSH
90037: LD_INT 25
90039: PUSH
90040: LD_INT 5
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 25
90049: PUSH
90050: LD_INT 9
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 25
90059: PUSH
90060: LD_INT 8
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PPUSH
90077: CALL_OW 69
90081: PUSH
90082: FOR_IN
90083: IFFALSE 90099
// begin SetClass ( i , 1 ) ;
90085: LD_VAR 0 1
90089: PPUSH
90090: LD_INT 1
90092: PPUSH
90093: CALL_OW 336
// end ;
90097: GO 90082
90099: POP
90100: POP
// end ;
90101: PPOPN 1
90103: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90104: LD_EXP 109
90108: PUSH
90109: LD_EXP 113
90113: AND
90114: PUSH
90115: LD_OWVAR 65
90119: PUSH
90120: LD_INT 7
90122: LESS
90123: AND
90124: IFFALSE 90138
90126: GO 90128
90128: DISABLE
// begin enable ;
90129: ENABLE
// game_speed := 7 ;
90130: LD_ADDR_OWVAR 65
90134: PUSH
90135: LD_INT 7
90137: ST_TO_ADDR
// end ;
90138: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90139: LD_EXP 109
90143: PUSH
90144: LD_EXP 116
90148: AND
90149: IFFALSE 90351
90151: GO 90153
90153: DISABLE
90154: LD_INT 0
90156: PPUSH
90157: PPUSH
90158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90159: LD_ADDR_VAR 0 3
90163: PUSH
90164: LD_INT 81
90166: PUSH
90167: LD_OWVAR 2
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 21
90178: PUSH
90179: LD_INT 1
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PPUSH
90190: CALL_OW 69
90194: ST_TO_ADDR
// if not tmp then
90195: LD_VAR 0 3
90199: NOT
90200: IFFALSE 90204
// exit ;
90202: GO 90351
// if tmp > 5 then
90204: LD_VAR 0 3
90208: PUSH
90209: LD_INT 5
90211: GREATER
90212: IFFALSE 90224
// k := 5 else
90214: LD_ADDR_VAR 0 2
90218: PUSH
90219: LD_INT 5
90221: ST_TO_ADDR
90222: GO 90234
// k := tmp ;
90224: LD_ADDR_VAR 0 2
90228: PUSH
90229: LD_VAR 0 3
90233: ST_TO_ADDR
// for i := 1 to k do
90234: LD_ADDR_VAR 0 1
90238: PUSH
90239: DOUBLE
90240: LD_INT 1
90242: DEC
90243: ST_TO_ADDR
90244: LD_VAR 0 2
90248: PUSH
90249: FOR_TO
90250: IFFALSE 90349
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90252: LD_VAR 0 3
90256: PUSH
90257: LD_VAR 0 1
90261: ARRAY
90262: PPUSH
90263: LD_VAR 0 1
90267: PUSH
90268: LD_INT 4
90270: MOD
90271: PUSH
90272: LD_INT 1
90274: PLUS
90275: PPUSH
90276: CALL_OW 259
90280: PUSH
90281: LD_INT 10
90283: LESS
90284: IFFALSE 90347
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90286: LD_VAR 0 3
90290: PUSH
90291: LD_VAR 0 1
90295: ARRAY
90296: PPUSH
90297: LD_VAR 0 1
90301: PUSH
90302: LD_INT 4
90304: MOD
90305: PUSH
90306: LD_INT 1
90308: PLUS
90309: PPUSH
90310: LD_VAR 0 3
90314: PUSH
90315: LD_VAR 0 1
90319: ARRAY
90320: PPUSH
90321: LD_VAR 0 1
90325: PUSH
90326: LD_INT 4
90328: MOD
90329: PUSH
90330: LD_INT 1
90332: PLUS
90333: PPUSH
90334: CALL_OW 259
90338: PUSH
90339: LD_INT 1
90341: PLUS
90342: PPUSH
90343: CALL_OW 237
90347: GO 90249
90349: POP
90350: POP
// end ;
90351: PPOPN 3
90353: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90354: LD_EXP 109
90358: PUSH
90359: LD_EXP 117
90363: AND
90364: IFFALSE 90384
90366: GO 90368
90368: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90369: LD_INT 4
90371: PPUSH
90372: LD_OWVAR 2
90376: PPUSH
90377: LD_INT 0
90379: PPUSH
90380: CALL_OW 324
90384: END
// every 0 0$1 trigger StreamModeActive and sShovel do
90385: LD_EXP 109
90389: PUSH
90390: LD_EXP 146
90394: AND
90395: IFFALSE 90415
90397: GO 90399
90399: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90400: LD_INT 19
90402: PPUSH
90403: LD_OWVAR 2
90407: PPUSH
90408: LD_INT 0
90410: PPUSH
90411: CALL_OW 324
90415: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90416: LD_EXP 109
90420: PUSH
90421: LD_EXP 118
90425: AND
90426: IFFALSE 90528
90428: GO 90430
90430: DISABLE
90431: LD_INT 0
90433: PPUSH
90434: PPUSH
// begin enable ;
90435: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90436: LD_ADDR_VAR 0 2
90440: PUSH
90441: LD_INT 22
90443: PUSH
90444: LD_OWVAR 2
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: LD_INT 34
90458: PUSH
90459: LD_INT 11
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: PUSH
90466: LD_INT 34
90468: PUSH
90469: LD_INT 30
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: LIST
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PPUSH
90485: CALL_OW 69
90489: ST_TO_ADDR
// if not tmp then
90490: LD_VAR 0 2
90494: NOT
90495: IFFALSE 90499
// exit ;
90497: GO 90528
// for i in tmp do
90499: LD_ADDR_VAR 0 1
90503: PUSH
90504: LD_VAR 0 2
90508: PUSH
90509: FOR_IN
90510: IFFALSE 90526
// begin SetLives ( i , 0 ) ;
90512: LD_VAR 0 1
90516: PPUSH
90517: LD_INT 0
90519: PPUSH
90520: CALL_OW 234
// end ;
90524: GO 90509
90526: POP
90527: POP
// end ;
90528: PPOPN 2
90530: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90531: LD_EXP 109
90535: PUSH
90536: LD_EXP 119
90540: AND
90541: IFFALSE 90561
90543: GO 90545
90545: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90546: LD_INT 32
90548: PPUSH
90549: LD_OWVAR 2
90553: PPUSH
90554: LD_INT 0
90556: PPUSH
90557: CALL_OW 324
90561: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90562: LD_EXP 109
90566: PUSH
90567: LD_EXP 120
90571: AND
90572: IFFALSE 90753
90574: GO 90576
90576: DISABLE
90577: LD_INT 0
90579: PPUSH
90580: PPUSH
90581: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90582: LD_ADDR_VAR 0 2
90586: PUSH
90587: LD_INT 22
90589: PUSH
90590: LD_OWVAR 2
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 33
90601: PUSH
90602: LD_INT 3
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PPUSH
90613: CALL_OW 69
90617: ST_TO_ADDR
// if not tmp then
90618: LD_VAR 0 2
90622: NOT
90623: IFFALSE 90627
// exit ;
90625: GO 90753
// side := 0 ;
90627: LD_ADDR_VAR 0 3
90631: PUSH
90632: LD_INT 0
90634: ST_TO_ADDR
// for i := 1 to 8 do
90635: LD_ADDR_VAR 0 1
90639: PUSH
90640: DOUBLE
90641: LD_INT 1
90643: DEC
90644: ST_TO_ADDR
90645: LD_INT 8
90647: PUSH
90648: FOR_TO
90649: IFFALSE 90697
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90651: LD_OWVAR 2
90655: PUSH
90656: LD_VAR 0 1
90660: NONEQUAL
90661: PUSH
90662: LD_OWVAR 2
90666: PPUSH
90667: LD_VAR 0 1
90671: PPUSH
90672: CALL_OW 81
90676: PUSH
90677: LD_INT 2
90679: EQUAL
90680: AND
90681: IFFALSE 90695
// begin side := i ;
90683: LD_ADDR_VAR 0 3
90687: PUSH
90688: LD_VAR 0 1
90692: ST_TO_ADDR
// break ;
90693: GO 90697
// end ;
90695: GO 90648
90697: POP
90698: POP
// if not side then
90699: LD_VAR 0 3
90703: NOT
90704: IFFALSE 90708
// exit ;
90706: GO 90753
// for i := 1 to tmp do
90708: LD_ADDR_VAR 0 1
90712: PUSH
90713: DOUBLE
90714: LD_INT 1
90716: DEC
90717: ST_TO_ADDR
90718: LD_VAR 0 2
90722: PUSH
90723: FOR_TO
90724: IFFALSE 90751
// if Prob ( 60 ) then
90726: LD_INT 60
90728: PPUSH
90729: CALL_OW 13
90733: IFFALSE 90749
// SetSide ( i , side ) ;
90735: LD_VAR 0 1
90739: PPUSH
90740: LD_VAR 0 3
90744: PPUSH
90745: CALL_OW 235
90749: GO 90723
90751: POP
90752: POP
// end ;
90753: PPOPN 3
90755: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90756: LD_EXP 109
90760: PUSH
90761: LD_EXP 122
90765: AND
90766: IFFALSE 90885
90768: GO 90770
90770: DISABLE
90771: LD_INT 0
90773: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90774: LD_ADDR_VAR 0 1
90778: PUSH
90779: LD_INT 22
90781: PUSH
90782: LD_OWVAR 2
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 21
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 3
90803: PUSH
90804: LD_INT 23
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: LIST
90822: PPUSH
90823: CALL_OW 69
90827: PUSH
90828: FOR_IN
90829: IFFALSE 90883
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90831: LD_VAR 0 1
90835: PPUSH
90836: CALL_OW 257
90840: PUSH
90841: LD_INT 1
90843: PUSH
90844: LD_INT 2
90846: PUSH
90847: LD_INT 3
90849: PUSH
90850: LD_INT 4
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: IN
90859: IFFALSE 90881
// SetClass ( un , rand ( 1 , 4 ) ) ;
90861: LD_VAR 0 1
90865: PPUSH
90866: LD_INT 1
90868: PPUSH
90869: LD_INT 4
90871: PPUSH
90872: CALL_OW 12
90876: PPUSH
90877: CALL_OW 336
90881: GO 90828
90883: POP
90884: POP
// end ;
90885: PPOPN 1
90887: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90888: LD_EXP 109
90892: PUSH
90893: LD_EXP 121
90897: AND
90898: IFFALSE 90977
90900: GO 90902
90902: DISABLE
90903: LD_INT 0
90905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90906: LD_ADDR_VAR 0 1
90910: PUSH
90911: LD_INT 22
90913: PUSH
90914: LD_OWVAR 2
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 21
90925: PUSH
90926: LD_INT 3
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PPUSH
90937: CALL_OW 69
90941: ST_TO_ADDR
// if not tmp then
90942: LD_VAR 0 1
90946: NOT
90947: IFFALSE 90951
// exit ;
90949: GO 90977
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90951: LD_VAR 0 1
90955: PUSH
90956: LD_INT 1
90958: PPUSH
90959: LD_VAR 0 1
90963: PPUSH
90964: CALL_OW 12
90968: ARRAY
90969: PPUSH
90970: LD_INT 100
90972: PPUSH
90973: CALL_OW 234
// end ;
90977: PPOPN 1
90979: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90980: LD_EXP 109
90984: PUSH
90985: LD_EXP 123
90989: AND
90990: IFFALSE 91088
90992: GO 90994
90994: DISABLE
90995: LD_INT 0
90997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90998: LD_ADDR_VAR 0 1
91002: PUSH
91003: LD_INT 22
91005: PUSH
91006: LD_OWVAR 2
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 21
91017: PUSH
91018: LD_INT 1
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PPUSH
91029: CALL_OW 69
91033: ST_TO_ADDR
// if not tmp then
91034: LD_VAR 0 1
91038: NOT
91039: IFFALSE 91043
// exit ;
91041: GO 91088
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91043: LD_VAR 0 1
91047: PUSH
91048: LD_INT 1
91050: PPUSH
91051: LD_VAR 0 1
91055: PPUSH
91056: CALL_OW 12
91060: ARRAY
91061: PPUSH
91062: LD_INT 1
91064: PPUSH
91065: LD_INT 4
91067: PPUSH
91068: CALL_OW 12
91072: PPUSH
91073: LD_INT 3000
91075: PPUSH
91076: LD_INT 9000
91078: PPUSH
91079: CALL_OW 12
91083: PPUSH
91084: CALL_OW 492
// end ;
91088: PPOPN 1
91090: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91091: LD_EXP 109
91095: PUSH
91096: LD_EXP 124
91100: AND
91101: IFFALSE 91121
91103: GO 91105
91105: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91106: LD_INT 1
91108: PPUSH
91109: LD_OWVAR 2
91113: PPUSH
91114: LD_INT 0
91116: PPUSH
91117: CALL_OW 324
91121: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91122: LD_EXP 109
91126: PUSH
91127: LD_EXP 125
91131: AND
91132: IFFALSE 91215
91134: GO 91136
91136: DISABLE
91137: LD_INT 0
91139: PPUSH
91140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91141: LD_ADDR_VAR 0 2
91145: PUSH
91146: LD_INT 22
91148: PUSH
91149: LD_OWVAR 2
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: LD_INT 21
91160: PUSH
91161: LD_INT 3
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PPUSH
91172: CALL_OW 69
91176: ST_TO_ADDR
// if not tmp then
91177: LD_VAR 0 2
91181: NOT
91182: IFFALSE 91186
// exit ;
91184: GO 91215
// for i in tmp do
91186: LD_ADDR_VAR 0 1
91190: PUSH
91191: LD_VAR 0 2
91195: PUSH
91196: FOR_IN
91197: IFFALSE 91213
// SetBLevel ( i , 10 ) ;
91199: LD_VAR 0 1
91203: PPUSH
91204: LD_INT 10
91206: PPUSH
91207: CALL_OW 241
91211: GO 91196
91213: POP
91214: POP
// end ;
91215: PPOPN 2
91217: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91218: LD_EXP 109
91222: PUSH
91223: LD_EXP 126
91227: AND
91228: IFFALSE 91339
91230: GO 91232
91232: DISABLE
91233: LD_INT 0
91235: PPUSH
91236: PPUSH
91237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91238: LD_ADDR_VAR 0 3
91242: PUSH
91243: LD_INT 22
91245: PUSH
91246: LD_OWVAR 2
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 25
91257: PUSH
91258: LD_INT 1
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PPUSH
91269: CALL_OW 69
91273: ST_TO_ADDR
// if not tmp then
91274: LD_VAR 0 3
91278: NOT
91279: IFFALSE 91283
// exit ;
91281: GO 91339
// un := tmp [ rand ( 1 , tmp ) ] ;
91283: LD_ADDR_VAR 0 2
91287: PUSH
91288: LD_VAR 0 3
91292: PUSH
91293: LD_INT 1
91295: PPUSH
91296: LD_VAR 0 3
91300: PPUSH
91301: CALL_OW 12
91305: ARRAY
91306: ST_TO_ADDR
// if Crawls ( un ) then
91307: LD_VAR 0 2
91311: PPUSH
91312: CALL_OW 318
91316: IFFALSE 91327
// ComWalk ( un ) ;
91318: LD_VAR 0 2
91322: PPUSH
91323: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91327: LD_VAR 0 2
91331: PPUSH
91332: LD_INT 5
91334: PPUSH
91335: CALL_OW 336
// end ;
91339: PPOPN 3
91341: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
91342: LD_EXP 109
91346: PUSH
91347: LD_EXP 127
91351: AND
91352: PUSH
91353: LD_OWVAR 67
91357: PUSH
91358: LD_INT 3
91360: LESS
91361: AND
91362: IFFALSE 91381
91364: GO 91366
91366: DISABLE
// Difficulty := Difficulty + 1 ;
91367: LD_ADDR_OWVAR 67
91371: PUSH
91372: LD_OWVAR 67
91376: PUSH
91377: LD_INT 1
91379: PLUS
91380: ST_TO_ADDR
91381: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
91382: LD_EXP 109
91386: PUSH
91387: LD_EXP 128
91391: AND
91392: IFFALSE 91495
91394: GO 91396
91396: DISABLE
91397: LD_INT 0
91399: PPUSH
// begin for i := 1 to 5 do
91400: LD_ADDR_VAR 0 1
91404: PUSH
91405: DOUBLE
91406: LD_INT 1
91408: DEC
91409: ST_TO_ADDR
91410: LD_INT 5
91412: PUSH
91413: FOR_TO
91414: IFFALSE 91493
// begin uc_nation := nation_nature ;
91416: LD_ADDR_OWVAR 21
91420: PUSH
91421: LD_INT 0
91423: ST_TO_ADDR
// uc_side := 0 ;
91424: LD_ADDR_OWVAR 20
91428: PUSH
91429: LD_INT 0
91431: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91432: LD_ADDR_OWVAR 29
91436: PUSH
91437: LD_INT 12
91439: PUSH
91440: LD_INT 12
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: ST_TO_ADDR
// hc_agressivity := 20 ;
91447: LD_ADDR_OWVAR 35
91451: PUSH
91452: LD_INT 20
91454: ST_TO_ADDR
// hc_class := class_tiger ;
91455: LD_ADDR_OWVAR 28
91459: PUSH
91460: LD_INT 14
91462: ST_TO_ADDR
// hc_gallery :=  ;
91463: LD_ADDR_OWVAR 33
91467: PUSH
91468: LD_STRING 
91470: ST_TO_ADDR
// hc_name :=  ;
91471: LD_ADDR_OWVAR 26
91475: PUSH
91476: LD_STRING 
91478: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91479: CALL_OW 44
91483: PPUSH
91484: LD_INT 0
91486: PPUSH
91487: CALL_OW 51
// end ;
91491: GO 91413
91493: POP
91494: POP
// end ;
91495: PPOPN 1
91497: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91498: LD_EXP 109
91502: PUSH
91503: LD_EXP 129
91507: AND
91508: IFFALSE 91517
91510: GO 91512
91512: DISABLE
// StreamSibBomb ;
91513: CALL 91518 0 0
91517: END
// export function StreamSibBomb ; var i , x , y ; begin
91518: LD_INT 0
91520: PPUSH
91521: PPUSH
91522: PPUSH
91523: PPUSH
// result := false ;
91524: LD_ADDR_VAR 0 1
91528: PUSH
91529: LD_INT 0
91531: ST_TO_ADDR
// for i := 1 to 16 do
91532: LD_ADDR_VAR 0 2
91536: PUSH
91537: DOUBLE
91538: LD_INT 1
91540: DEC
91541: ST_TO_ADDR
91542: LD_INT 16
91544: PUSH
91545: FOR_TO
91546: IFFALSE 91745
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91548: LD_ADDR_VAR 0 3
91552: PUSH
91553: LD_INT 10
91555: PUSH
91556: LD_INT 20
91558: PUSH
91559: LD_INT 30
91561: PUSH
91562: LD_INT 40
91564: PUSH
91565: LD_INT 50
91567: PUSH
91568: LD_INT 60
91570: PUSH
91571: LD_INT 70
91573: PUSH
91574: LD_INT 80
91576: PUSH
91577: LD_INT 90
91579: PUSH
91580: LD_INT 100
91582: PUSH
91583: LD_INT 110
91585: PUSH
91586: LD_INT 120
91588: PUSH
91589: LD_INT 130
91591: PUSH
91592: LD_INT 140
91594: PUSH
91595: LD_INT 150
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 1
91617: PPUSH
91618: LD_INT 15
91620: PPUSH
91621: CALL_OW 12
91625: ARRAY
91626: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91627: LD_ADDR_VAR 0 4
91631: PUSH
91632: LD_INT 10
91634: PUSH
91635: LD_INT 20
91637: PUSH
91638: LD_INT 30
91640: PUSH
91641: LD_INT 40
91643: PUSH
91644: LD_INT 50
91646: PUSH
91647: LD_INT 60
91649: PUSH
91650: LD_INT 70
91652: PUSH
91653: LD_INT 80
91655: PUSH
91656: LD_INT 90
91658: PUSH
91659: LD_INT 100
91661: PUSH
91662: LD_INT 110
91664: PUSH
91665: LD_INT 120
91667: PUSH
91668: LD_INT 130
91670: PUSH
91671: LD_INT 140
91673: PUSH
91674: LD_INT 150
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 1
91696: PPUSH
91697: LD_INT 15
91699: PPUSH
91700: CALL_OW 12
91704: ARRAY
91705: ST_TO_ADDR
// if ValidHex ( x , y ) then
91706: LD_VAR 0 3
91710: PPUSH
91711: LD_VAR 0 4
91715: PPUSH
91716: CALL_OW 488
91720: IFFALSE 91743
// begin result := [ x , y ] ;
91722: LD_ADDR_VAR 0 1
91726: PUSH
91727: LD_VAR 0 3
91731: PUSH
91732: LD_VAR 0 4
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: ST_TO_ADDR
// break ;
91741: GO 91745
// end ; end ;
91743: GO 91545
91745: POP
91746: POP
// if result then
91747: LD_VAR 0 1
91751: IFFALSE 91811
// begin ToLua ( playSibBomb() ) ;
91753: LD_STRING playSibBomb()
91755: PPUSH
91756: CALL_OW 559
// wait ( 0 0$14 ) ;
91760: LD_INT 490
91762: PPUSH
91763: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91767: LD_VAR 0 1
91771: PUSH
91772: LD_INT 1
91774: ARRAY
91775: PPUSH
91776: LD_VAR 0 1
91780: PUSH
91781: LD_INT 2
91783: ARRAY
91784: PPUSH
91785: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91789: LD_VAR 0 1
91793: PUSH
91794: LD_INT 1
91796: ARRAY
91797: PPUSH
91798: LD_VAR 0 1
91802: PUSH
91803: LD_INT 2
91805: ARRAY
91806: PPUSH
91807: CALL_OW 429
// end ; end ;
91811: LD_VAR 0 1
91815: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91816: LD_EXP 109
91820: PUSH
91821: LD_EXP 131
91825: AND
91826: IFFALSE 91838
91828: GO 91830
91830: DISABLE
// YouLost (  ) ;
91831: LD_STRING 
91833: PPUSH
91834: CALL_OW 104
91838: END
// every 0 0$1 trigger StreamModeActive and sFog do
91839: LD_EXP 109
91843: PUSH
91844: LD_EXP 130
91848: AND
91849: IFFALSE 91863
91851: GO 91853
91853: DISABLE
// FogOff ( your_side ) ;
91854: LD_OWVAR 2
91858: PPUSH
91859: CALL_OW 344
91863: END
// every 0 0$1 trigger StreamModeActive and sSun do
91864: LD_EXP 109
91868: PUSH
91869: LD_EXP 132
91873: AND
91874: IFFALSE 91902
91876: GO 91878
91878: DISABLE
// begin solar_recharge_percent := 0 ;
91879: LD_ADDR_OWVAR 79
91883: PUSH
91884: LD_INT 0
91886: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91887: LD_INT 10500
91889: PPUSH
91890: CALL_OW 67
// solar_recharge_percent := 100 ;
91894: LD_ADDR_OWVAR 79
91898: PUSH
91899: LD_INT 100
91901: ST_TO_ADDR
// end ;
91902: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91903: LD_EXP 109
91907: PUSH
91908: LD_EXP 133
91912: AND
91913: IFFALSE 92152
91915: GO 91917
91917: DISABLE
91918: LD_INT 0
91920: PPUSH
91921: PPUSH
91922: PPUSH
// begin tmp := [ ] ;
91923: LD_ADDR_VAR 0 3
91927: PUSH
91928: EMPTY
91929: ST_TO_ADDR
// for i := 1 to 6 do
91930: LD_ADDR_VAR 0 1
91934: PUSH
91935: DOUBLE
91936: LD_INT 1
91938: DEC
91939: ST_TO_ADDR
91940: LD_INT 6
91942: PUSH
91943: FOR_TO
91944: IFFALSE 92049
// begin uc_nation := nation_nature ;
91946: LD_ADDR_OWVAR 21
91950: PUSH
91951: LD_INT 0
91953: ST_TO_ADDR
// uc_side := 0 ;
91954: LD_ADDR_OWVAR 20
91958: PUSH
91959: LD_INT 0
91961: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91962: LD_ADDR_OWVAR 29
91966: PUSH
91967: LD_INT 12
91969: PUSH
91970: LD_INT 12
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: ST_TO_ADDR
// hc_agressivity := 20 ;
91977: LD_ADDR_OWVAR 35
91981: PUSH
91982: LD_INT 20
91984: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91985: LD_ADDR_OWVAR 28
91989: PUSH
91990: LD_INT 17
91992: ST_TO_ADDR
// hc_gallery :=  ;
91993: LD_ADDR_OWVAR 33
91997: PUSH
91998: LD_STRING 
92000: ST_TO_ADDR
// hc_name :=  ;
92001: LD_ADDR_OWVAR 26
92005: PUSH
92006: LD_STRING 
92008: ST_TO_ADDR
// un := CreateHuman ;
92009: LD_ADDR_VAR 0 2
92013: PUSH
92014: CALL_OW 44
92018: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92019: LD_VAR 0 2
92023: PPUSH
92024: LD_INT 1
92026: PPUSH
92027: CALL_OW 51
// tmp := tmp ^ un ;
92031: LD_ADDR_VAR 0 3
92035: PUSH
92036: LD_VAR 0 3
92040: PUSH
92041: LD_VAR 0 2
92045: ADD
92046: ST_TO_ADDR
// end ;
92047: GO 91943
92049: POP
92050: POP
// repeat wait ( 0 0$1 ) ;
92051: LD_INT 35
92053: PPUSH
92054: CALL_OW 67
// for un in tmp do
92058: LD_ADDR_VAR 0 2
92062: PUSH
92063: LD_VAR 0 3
92067: PUSH
92068: FOR_IN
92069: IFFALSE 92143
// begin if IsDead ( un ) then
92071: LD_VAR 0 2
92075: PPUSH
92076: CALL_OW 301
92080: IFFALSE 92100
// begin tmp := tmp diff un ;
92082: LD_ADDR_VAR 0 3
92086: PUSH
92087: LD_VAR 0 3
92091: PUSH
92092: LD_VAR 0 2
92096: DIFF
92097: ST_TO_ADDR
// continue ;
92098: GO 92068
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92100: LD_VAR 0 2
92104: PPUSH
92105: LD_INT 3
92107: PUSH
92108: LD_INT 22
92110: PUSH
92111: LD_INT 0
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: EMPTY
92119: LIST
92120: LIST
92121: PPUSH
92122: CALL_OW 69
92126: PPUSH
92127: LD_VAR 0 2
92131: PPUSH
92132: CALL_OW 74
92136: PPUSH
92137: CALL_OW 115
// end ;
92141: GO 92068
92143: POP
92144: POP
// until not tmp ;
92145: LD_VAR 0 3
92149: NOT
92150: IFFALSE 92051
// end ;
92152: PPOPN 3
92154: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92155: LD_EXP 109
92159: PUSH
92160: LD_EXP 134
92164: AND
92165: IFFALSE 92219
92167: GO 92169
92169: DISABLE
// begin ToLua ( displayTroll(); ) ;
92170: LD_STRING displayTroll();
92172: PPUSH
92173: CALL_OW 559
// wait ( 3 3$00 ) ;
92177: LD_INT 6300
92179: PPUSH
92180: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92184: LD_STRING hideTroll();
92186: PPUSH
92187: CALL_OW 559
// wait ( 1 1$00 ) ;
92191: LD_INT 2100
92193: PPUSH
92194: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92198: LD_STRING displayTroll();
92200: PPUSH
92201: CALL_OW 559
// wait ( 1 1$00 ) ;
92205: LD_INT 2100
92207: PPUSH
92208: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92212: LD_STRING hideTroll();
92214: PPUSH
92215: CALL_OW 559
// end ;
92219: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92220: LD_EXP 109
92224: PUSH
92225: LD_EXP 135
92229: AND
92230: IFFALSE 92293
92232: GO 92234
92234: DISABLE
92235: LD_INT 0
92237: PPUSH
// begin p := 0 ;
92238: LD_ADDR_VAR 0 1
92242: PUSH
92243: LD_INT 0
92245: ST_TO_ADDR
// repeat game_speed := 1 ;
92246: LD_ADDR_OWVAR 65
92250: PUSH
92251: LD_INT 1
92253: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92254: LD_INT 35
92256: PPUSH
92257: CALL_OW 67
// p := p + 1 ;
92261: LD_ADDR_VAR 0 1
92265: PUSH
92266: LD_VAR 0 1
92270: PUSH
92271: LD_INT 1
92273: PLUS
92274: ST_TO_ADDR
// until p >= 60 ;
92275: LD_VAR 0 1
92279: PUSH
92280: LD_INT 60
92282: GREATEREQUAL
92283: IFFALSE 92246
// game_speed := 4 ;
92285: LD_ADDR_OWVAR 65
92289: PUSH
92290: LD_INT 4
92292: ST_TO_ADDR
// end ;
92293: PPOPN 1
92295: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92296: LD_EXP 109
92300: PUSH
92301: LD_EXP 136
92305: AND
92306: IFFALSE 92452
92308: GO 92310
92310: DISABLE
92311: LD_INT 0
92313: PPUSH
92314: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92315: LD_ADDR_VAR 0 1
92319: PUSH
92320: LD_INT 22
92322: PUSH
92323: LD_OWVAR 2
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 2
92334: PUSH
92335: LD_INT 30
92337: PUSH
92338: LD_INT 0
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 30
92347: PUSH
92348: LD_INT 1
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: LIST
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PPUSH
92364: CALL_OW 69
92368: ST_TO_ADDR
// if not depot then
92369: LD_VAR 0 1
92373: NOT
92374: IFFALSE 92378
// exit ;
92376: GO 92452
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
92378: LD_ADDR_VAR 0 2
92382: PUSH
92383: LD_VAR 0 1
92387: PUSH
92388: LD_INT 1
92390: PPUSH
92391: LD_VAR 0 1
92395: PPUSH
92396: CALL_OW 12
92400: ARRAY
92401: PPUSH
92402: CALL_OW 274
92406: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92407: LD_VAR 0 2
92411: PPUSH
92412: LD_INT 1
92414: PPUSH
92415: LD_INT 0
92417: PPUSH
92418: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92422: LD_VAR 0 2
92426: PPUSH
92427: LD_INT 2
92429: PPUSH
92430: LD_INT 0
92432: PPUSH
92433: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92437: LD_VAR 0 2
92441: PPUSH
92442: LD_INT 3
92444: PPUSH
92445: LD_INT 0
92447: PPUSH
92448: CALL_OW 277
// end ;
92452: PPOPN 2
92454: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92455: LD_EXP 109
92459: PUSH
92460: LD_EXP 137
92464: AND
92465: IFFALSE 92562
92467: GO 92469
92469: DISABLE
92470: LD_INT 0
92472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92473: LD_ADDR_VAR 0 1
92477: PUSH
92478: LD_INT 22
92480: PUSH
92481: LD_OWVAR 2
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: LD_INT 21
92492: PUSH
92493: LD_INT 1
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 3
92502: PUSH
92503: LD_INT 23
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: LIST
92521: PPUSH
92522: CALL_OW 69
92526: ST_TO_ADDR
// if not tmp then
92527: LD_VAR 0 1
92531: NOT
92532: IFFALSE 92536
// exit ;
92534: GO 92562
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92536: LD_VAR 0 1
92540: PUSH
92541: LD_INT 1
92543: PPUSH
92544: LD_VAR 0 1
92548: PPUSH
92549: CALL_OW 12
92553: ARRAY
92554: PPUSH
92555: LD_INT 200
92557: PPUSH
92558: CALL_OW 234
// end ;
92562: PPOPN 1
92564: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92565: LD_EXP 109
92569: PUSH
92570: LD_EXP 138
92574: AND
92575: IFFALSE 92654
92577: GO 92579
92579: DISABLE
92580: LD_INT 0
92582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92583: LD_ADDR_VAR 0 1
92587: PUSH
92588: LD_INT 22
92590: PUSH
92591: LD_OWVAR 2
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 21
92602: PUSH
92603: LD_INT 2
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PPUSH
92614: CALL_OW 69
92618: ST_TO_ADDR
// if not tmp then
92619: LD_VAR 0 1
92623: NOT
92624: IFFALSE 92628
// exit ;
92626: GO 92654
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92628: LD_VAR 0 1
92632: PUSH
92633: LD_INT 1
92635: PPUSH
92636: LD_VAR 0 1
92640: PPUSH
92641: CALL_OW 12
92645: ARRAY
92646: PPUSH
92647: LD_INT 60
92649: PPUSH
92650: CALL_OW 234
// end ;
92654: PPOPN 1
92656: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92657: LD_EXP 109
92661: PUSH
92662: LD_EXP 139
92666: AND
92667: IFFALSE 92766
92669: GO 92671
92671: DISABLE
92672: LD_INT 0
92674: PPUSH
92675: PPUSH
// begin enable ;
92676: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92677: LD_ADDR_VAR 0 1
92681: PUSH
92682: LD_INT 22
92684: PUSH
92685: LD_OWVAR 2
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: LD_INT 61
92696: PUSH
92697: EMPTY
92698: LIST
92699: PUSH
92700: LD_INT 33
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: LIST
92714: PPUSH
92715: CALL_OW 69
92719: ST_TO_ADDR
// if not tmp then
92720: LD_VAR 0 1
92724: NOT
92725: IFFALSE 92729
// exit ;
92727: GO 92766
// for i in tmp do
92729: LD_ADDR_VAR 0 2
92733: PUSH
92734: LD_VAR 0 1
92738: PUSH
92739: FOR_IN
92740: IFFALSE 92764
// if IsControledBy ( i ) then
92742: LD_VAR 0 2
92746: PPUSH
92747: CALL_OW 312
92751: IFFALSE 92762
// ComUnlink ( i ) ;
92753: LD_VAR 0 2
92757: PPUSH
92758: CALL_OW 136
92762: GO 92739
92764: POP
92765: POP
// end ;
92766: PPOPN 2
92768: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92769: LD_EXP 109
92773: PUSH
92774: LD_EXP 140
92778: AND
92779: IFFALSE 92919
92781: GO 92783
92783: DISABLE
92784: LD_INT 0
92786: PPUSH
92787: PPUSH
// begin ToLua ( displayPowell(); ) ;
92788: LD_STRING displayPowell();
92790: PPUSH
92791: CALL_OW 559
// uc_side := 0 ;
92795: LD_ADDR_OWVAR 20
92799: PUSH
92800: LD_INT 0
92802: ST_TO_ADDR
// uc_nation := 2 ;
92803: LD_ADDR_OWVAR 21
92807: PUSH
92808: LD_INT 2
92810: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92811: LD_ADDR_OWVAR 37
92815: PUSH
92816: LD_INT 14
92818: ST_TO_ADDR
// vc_engine := engine_siberite ;
92819: LD_ADDR_OWVAR 39
92823: PUSH
92824: LD_INT 3
92826: ST_TO_ADDR
// vc_control := control_apeman ;
92827: LD_ADDR_OWVAR 38
92831: PUSH
92832: LD_INT 5
92834: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92835: LD_ADDR_OWVAR 40
92839: PUSH
92840: LD_INT 29
92842: ST_TO_ADDR
// un := CreateVehicle ;
92843: LD_ADDR_VAR 0 2
92847: PUSH
92848: CALL_OW 45
92852: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92853: LD_VAR 0 2
92857: PPUSH
92858: LD_INT 1
92860: PPUSH
92861: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92865: LD_INT 35
92867: PPUSH
92868: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92872: LD_VAR 0 2
92876: PPUSH
92877: LD_INT 22
92879: PUSH
92880: LD_OWVAR 2
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PPUSH
92889: CALL_OW 69
92893: PPUSH
92894: LD_VAR 0 2
92898: PPUSH
92899: CALL_OW 74
92903: PPUSH
92904: CALL_OW 115
// until IsDead ( un ) ;
92908: LD_VAR 0 2
92912: PPUSH
92913: CALL_OW 301
92917: IFFALSE 92865
// end ;
92919: PPOPN 2
92921: END
// every 0 0$1 trigger StreamModeActive and sStu do
92922: LD_EXP 109
92926: PUSH
92927: LD_EXP 148
92931: AND
92932: IFFALSE 92948
92934: GO 92936
92936: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92937: LD_STRING displayStucuk();
92939: PPUSH
92940: CALL_OW 559
// ResetFog ;
92944: CALL_OW 335
// end ;
92948: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92949: LD_EXP 109
92953: PUSH
92954: LD_EXP 141
92958: AND
92959: IFFALSE 93100
92961: GO 92963
92963: DISABLE
92964: LD_INT 0
92966: PPUSH
92967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92968: LD_ADDR_VAR 0 2
92972: PUSH
92973: LD_INT 22
92975: PUSH
92976: LD_OWVAR 2
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 21
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PPUSH
92999: CALL_OW 69
93003: ST_TO_ADDR
// if not tmp then
93004: LD_VAR 0 2
93008: NOT
93009: IFFALSE 93013
// exit ;
93011: GO 93100
// un := tmp [ rand ( 1 , tmp ) ] ;
93013: LD_ADDR_VAR 0 1
93017: PUSH
93018: LD_VAR 0 2
93022: PUSH
93023: LD_INT 1
93025: PPUSH
93026: LD_VAR 0 2
93030: PPUSH
93031: CALL_OW 12
93035: ARRAY
93036: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93037: LD_VAR 0 1
93041: PPUSH
93042: LD_INT 0
93044: PPUSH
93045: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93049: LD_VAR 0 1
93053: PPUSH
93054: LD_OWVAR 3
93058: PUSH
93059: LD_VAR 0 1
93063: DIFF
93064: PPUSH
93065: LD_VAR 0 1
93069: PPUSH
93070: CALL_OW 74
93074: PPUSH
93075: CALL_OW 115
// wait ( 0 0$20 ) ;
93079: LD_INT 700
93081: PPUSH
93082: CALL_OW 67
// SetSide ( un , your_side ) ;
93086: LD_VAR 0 1
93090: PPUSH
93091: LD_OWVAR 2
93095: PPUSH
93096: CALL_OW 235
// end ;
93100: PPOPN 2
93102: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93103: LD_EXP 109
93107: PUSH
93108: LD_EXP 142
93112: AND
93113: IFFALSE 93219
93115: GO 93117
93117: DISABLE
93118: LD_INT 0
93120: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93121: LD_ADDR_VAR 0 1
93125: PUSH
93126: LD_INT 22
93128: PUSH
93129: LD_OWVAR 2
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 2
93140: PUSH
93141: LD_INT 30
93143: PUSH
93144: LD_INT 0
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 30
93153: PUSH
93154: LD_INT 1
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: LIST
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PPUSH
93170: CALL_OW 69
93174: ST_TO_ADDR
// if not depot then
93175: LD_VAR 0 1
93179: NOT
93180: IFFALSE 93184
// exit ;
93182: GO 93219
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93184: LD_VAR 0 1
93188: PUSH
93189: LD_INT 1
93191: ARRAY
93192: PPUSH
93193: CALL_OW 250
93197: PPUSH
93198: LD_VAR 0 1
93202: PUSH
93203: LD_INT 1
93205: ARRAY
93206: PPUSH
93207: CALL_OW 251
93211: PPUSH
93212: LD_INT 70
93214: PPUSH
93215: CALL_OW 495
// end ;
93219: PPOPN 1
93221: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93222: LD_EXP 109
93226: PUSH
93227: LD_EXP 143
93231: AND
93232: IFFALSE 93443
93234: GO 93236
93236: DISABLE
93237: LD_INT 0
93239: PPUSH
93240: PPUSH
93241: PPUSH
93242: PPUSH
93243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93244: LD_ADDR_VAR 0 5
93248: PUSH
93249: LD_INT 22
93251: PUSH
93252: LD_OWVAR 2
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 21
93263: PUSH
93264: LD_INT 1
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PPUSH
93275: CALL_OW 69
93279: ST_TO_ADDR
// if not tmp then
93280: LD_VAR 0 5
93284: NOT
93285: IFFALSE 93289
// exit ;
93287: GO 93443
// for i in tmp do
93289: LD_ADDR_VAR 0 1
93293: PUSH
93294: LD_VAR 0 5
93298: PUSH
93299: FOR_IN
93300: IFFALSE 93441
// begin d := rand ( 0 , 5 ) ;
93302: LD_ADDR_VAR 0 4
93306: PUSH
93307: LD_INT 0
93309: PPUSH
93310: LD_INT 5
93312: PPUSH
93313: CALL_OW 12
93317: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93318: LD_ADDR_VAR 0 2
93322: PUSH
93323: LD_VAR 0 1
93327: PPUSH
93328: CALL_OW 250
93332: PPUSH
93333: LD_VAR 0 4
93337: PPUSH
93338: LD_INT 3
93340: PPUSH
93341: LD_INT 12
93343: PPUSH
93344: CALL_OW 12
93348: PPUSH
93349: CALL_OW 272
93353: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93354: LD_ADDR_VAR 0 3
93358: PUSH
93359: LD_VAR 0 1
93363: PPUSH
93364: CALL_OW 251
93368: PPUSH
93369: LD_VAR 0 4
93373: PPUSH
93374: LD_INT 3
93376: PPUSH
93377: LD_INT 12
93379: PPUSH
93380: CALL_OW 12
93384: PPUSH
93385: CALL_OW 273
93389: ST_TO_ADDR
// if ValidHex ( x , y ) then
93390: LD_VAR 0 2
93394: PPUSH
93395: LD_VAR 0 3
93399: PPUSH
93400: CALL_OW 488
93404: IFFALSE 93439
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93406: LD_VAR 0 1
93410: PPUSH
93411: LD_VAR 0 2
93415: PPUSH
93416: LD_VAR 0 3
93420: PPUSH
93421: LD_INT 3
93423: PPUSH
93424: LD_INT 6
93426: PPUSH
93427: CALL_OW 12
93431: PPUSH
93432: LD_INT 1
93434: PPUSH
93435: CALL_OW 483
// end ;
93439: GO 93299
93441: POP
93442: POP
// end ;
93443: PPOPN 5
93445: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93446: LD_EXP 109
93450: PUSH
93451: LD_EXP 144
93455: AND
93456: IFFALSE 93550
93458: GO 93460
93460: DISABLE
93461: LD_INT 0
93463: PPUSH
93464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93465: LD_ADDR_VAR 0 2
93469: PUSH
93470: LD_INT 22
93472: PUSH
93473: LD_OWVAR 2
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: LD_INT 32
93484: PUSH
93485: LD_INT 1
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PUSH
93492: LD_INT 21
93494: PUSH
93495: LD_INT 2
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: LIST
93506: PPUSH
93507: CALL_OW 69
93511: ST_TO_ADDR
// if not tmp then
93512: LD_VAR 0 2
93516: NOT
93517: IFFALSE 93521
// exit ;
93519: GO 93550
// for i in tmp do
93521: LD_ADDR_VAR 0 1
93525: PUSH
93526: LD_VAR 0 2
93530: PUSH
93531: FOR_IN
93532: IFFALSE 93548
// SetFuel ( i , 0 ) ;
93534: LD_VAR 0 1
93538: PPUSH
93539: LD_INT 0
93541: PPUSH
93542: CALL_OW 240
93546: GO 93531
93548: POP
93549: POP
// end ;
93550: PPOPN 2
93552: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93553: LD_EXP 109
93557: PUSH
93558: LD_EXP 145
93562: AND
93563: IFFALSE 93629
93565: GO 93567
93567: DISABLE
93568: LD_INT 0
93570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93571: LD_ADDR_VAR 0 1
93575: PUSH
93576: LD_INT 22
93578: PUSH
93579: LD_OWVAR 2
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 30
93590: PUSH
93591: LD_INT 29
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PPUSH
93602: CALL_OW 69
93606: ST_TO_ADDR
// if not tmp then
93607: LD_VAR 0 1
93611: NOT
93612: IFFALSE 93616
// exit ;
93614: GO 93629
// DestroyUnit ( tmp [ 1 ] ) ;
93616: LD_VAR 0 1
93620: PUSH
93621: LD_INT 1
93623: ARRAY
93624: PPUSH
93625: CALL_OW 65
// end ;
93629: PPOPN 1
93631: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93632: LD_EXP 109
93636: PUSH
93637: LD_EXP 147
93641: AND
93642: IFFALSE 93771
93644: GO 93646
93646: DISABLE
93647: LD_INT 0
93649: PPUSH
// begin uc_side := 0 ;
93650: LD_ADDR_OWVAR 20
93654: PUSH
93655: LD_INT 0
93657: ST_TO_ADDR
// uc_nation := nation_arabian ;
93658: LD_ADDR_OWVAR 21
93662: PUSH
93663: LD_INT 2
93665: ST_TO_ADDR
// hc_gallery :=  ;
93666: LD_ADDR_OWVAR 33
93670: PUSH
93671: LD_STRING 
93673: ST_TO_ADDR
// hc_name :=  ;
93674: LD_ADDR_OWVAR 26
93678: PUSH
93679: LD_STRING 
93681: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93682: LD_INT 1
93684: PPUSH
93685: LD_INT 11
93687: PPUSH
93688: LD_INT 10
93690: PPUSH
93691: CALL_OW 380
// un := CreateHuman ;
93695: LD_ADDR_VAR 0 1
93699: PUSH
93700: CALL_OW 44
93704: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93705: LD_VAR 0 1
93709: PPUSH
93710: LD_INT 1
93712: PPUSH
93713: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93717: LD_INT 35
93719: PPUSH
93720: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93724: LD_VAR 0 1
93728: PPUSH
93729: LD_INT 22
93731: PUSH
93732: LD_OWVAR 2
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PPUSH
93741: CALL_OW 69
93745: PPUSH
93746: LD_VAR 0 1
93750: PPUSH
93751: CALL_OW 74
93755: PPUSH
93756: CALL_OW 115
// until IsDead ( un ) ;
93760: LD_VAR 0 1
93764: PPUSH
93765: CALL_OW 301
93769: IFFALSE 93717
// end ;
93771: PPOPN 1
93773: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93774: LD_EXP 109
93778: PUSH
93779: LD_EXP 149
93783: AND
93784: IFFALSE 93796
93786: GO 93788
93788: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93789: LD_STRING earthquake(getX(game), 0, 32)
93791: PPUSH
93792: CALL_OW 559
93796: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93797: LD_EXP 109
93801: PUSH
93802: LD_EXP 150
93806: AND
93807: IFFALSE 93898
93809: GO 93811
93811: DISABLE
93812: LD_INT 0
93814: PPUSH
// begin enable ;
93815: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93816: LD_ADDR_VAR 0 1
93820: PUSH
93821: LD_INT 22
93823: PUSH
93824: LD_OWVAR 2
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 21
93835: PUSH
93836: LD_INT 2
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 33
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: PPUSH
93858: CALL_OW 69
93862: ST_TO_ADDR
// if not tmp then
93863: LD_VAR 0 1
93867: NOT
93868: IFFALSE 93872
// exit ;
93870: GO 93898
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93872: LD_VAR 0 1
93876: PUSH
93877: LD_INT 1
93879: PPUSH
93880: LD_VAR 0 1
93884: PPUSH
93885: CALL_OW 12
93889: ARRAY
93890: PPUSH
93891: LD_INT 1
93893: PPUSH
93894: CALL_OW 234
// end ;
93898: PPOPN 1
93900: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93901: LD_EXP 109
93905: PUSH
93906: LD_EXP 151
93910: AND
93911: IFFALSE 94052
93913: GO 93915
93915: DISABLE
93916: LD_INT 0
93918: PPUSH
93919: PPUSH
93920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93921: LD_ADDR_VAR 0 3
93925: PUSH
93926: LD_INT 22
93928: PUSH
93929: LD_OWVAR 2
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 25
93940: PUSH
93941: LD_INT 1
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PPUSH
93952: CALL_OW 69
93956: ST_TO_ADDR
// if not tmp then
93957: LD_VAR 0 3
93961: NOT
93962: IFFALSE 93966
// exit ;
93964: GO 94052
// un := tmp [ rand ( 1 , tmp ) ] ;
93966: LD_ADDR_VAR 0 2
93970: PUSH
93971: LD_VAR 0 3
93975: PUSH
93976: LD_INT 1
93978: PPUSH
93979: LD_VAR 0 3
93983: PPUSH
93984: CALL_OW 12
93988: ARRAY
93989: ST_TO_ADDR
// if Crawls ( un ) then
93990: LD_VAR 0 2
93994: PPUSH
93995: CALL_OW 318
93999: IFFALSE 94010
// ComWalk ( un ) ;
94001: LD_VAR 0 2
94005: PPUSH
94006: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94010: LD_VAR 0 2
94014: PPUSH
94015: LD_INT 9
94017: PPUSH
94018: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94022: LD_INT 28
94024: PPUSH
94025: LD_OWVAR 2
94029: PPUSH
94030: LD_INT 2
94032: PPUSH
94033: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94037: LD_INT 29
94039: PPUSH
94040: LD_OWVAR 2
94044: PPUSH
94045: LD_INT 2
94047: PPUSH
94048: CALL_OW 322
// end ;
94052: PPOPN 3
94054: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94055: LD_EXP 109
94059: PUSH
94060: LD_EXP 152
94064: AND
94065: IFFALSE 94176
94067: GO 94069
94069: DISABLE
94070: LD_INT 0
94072: PPUSH
94073: PPUSH
94074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94075: LD_ADDR_VAR 0 3
94079: PUSH
94080: LD_INT 22
94082: PUSH
94083: LD_OWVAR 2
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 25
94094: PUSH
94095: LD_INT 1
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PPUSH
94106: CALL_OW 69
94110: ST_TO_ADDR
// if not tmp then
94111: LD_VAR 0 3
94115: NOT
94116: IFFALSE 94120
// exit ;
94118: GO 94176
// un := tmp [ rand ( 1 , tmp ) ] ;
94120: LD_ADDR_VAR 0 2
94124: PUSH
94125: LD_VAR 0 3
94129: PUSH
94130: LD_INT 1
94132: PPUSH
94133: LD_VAR 0 3
94137: PPUSH
94138: CALL_OW 12
94142: ARRAY
94143: ST_TO_ADDR
// if Crawls ( un ) then
94144: LD_VAR 0 2
94148: PPUSH
94149: CALL_OW 318
94153: IFFALSE 94164
// ComWalk ( un ) ;
94155: LD_VAR 0 2
94159: PPUSH
94160: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94164: LD_VAR 0 2
94168: PPUSH
94169: LD_INT 8
94171: PPUSH
94172: CALL_OW 336
// end ;
94176: PPOPN 3
94178: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94179: LD_EXP 109
94183: PUSH
94184: LD_EXP 153
94188: AND
94189: IFFALSE 94333
94191: GO 94193
94193: DISABLE
94194: LD_INT 0
94196: PPUSH
94197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94198: LD_ADDR_VAR 0 2
94202: PUSH
94203: LD_INT 22
94205: PUSH
94206: LD_OWVAR 2
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 21
94217: PUSH
94218: LD_INT 2
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 2
94227: PUSH
94228: LD_INT 34
94230: PUSH
94231: LD_INT 12
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 34
94240: PUSH
94241: LD_INT 51
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 34
94250: PUSH
94251: LD_INT 32
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: LIST
94268: PPUSH
94269: CALL_OW 69
94273: ST_TO_ADDR
// if not tmp then
94274: LD_VAR 0 2
94278: NOT
94279: IFFALSE 94283
// exit ;
94281: GO 94333
// for i in tmp do
94283: LD_ADDR_VAR 0 1
94287: PUSH
94288: LD_VAR 0 2
94292: PUSH
94293: FOR_IN
94294: IFFALSE 94331
// if GetCargo ( i , mat_artifact ) = 0 then
94296: LD_VAR 0 1
94300: PPUSH
94301: LD_INT 4
94303: PPUSH
94304: CALL_OW 289
94308: PUSH
94309: LD_INT 0
94311: EQUAL
94312: IFFALSE 94329
// SetCargo ( i , mat_siberit , 100 ) ;
94314: LD_VAR 0 1
94318: PPUSH
94319: LD_INT 3
94321: PPUSH
94322: LD_INT 100
94324: PPUSH
94325: CALL_OW 290
94329: GO 94293
94331: POP
94332: POP
// end ;
94333: PPOPN 2
94335: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94336: LD_EXP 109
94340: PUSH
94341: LD_EXP 154
94345: AND
94346: IFFALSE 94529
94348: GO 94350
94350: DISABLE
94351: LD_INT 0
94353: PPUSH
94354: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94355: LD_ADDR_VAR 0 2
94359: PUSH
94360: LD_INT 22
94362: PUSH
94363: LD_OWVAR 2
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PPUSH
94372: CALL_OW 69
94376: ST_TO_ADDR
// if not tmp then
94377: LD_VAR 0 2
94381: NOT
94382: IFFALSE 94386
// exit ;
94384: GO 94529
// for i := 1 to 2 do
94386: LD_ADDR_VAR 0 1
94390: PUSH
94391: DOUBLE
94392: LD_INT 1
94394: DEC
94395: ST_TO_ADDR
94396: LD_INT 2
94398: PUSH
94399: FOR_TO
94400: IFFALSE 94527
// begin uc_side := your_side ;
94402: LD_ADDR_OWVAR 20
94406: PUSH
94407: LD_OWVAR 2
94411: ST_TO_ADDR
// uc_nation := nation_american ;
94412: LD_ADDR_OWVAR 21
94416: PUSH
94417: LD_INT 1
94419: ST_TO_ADDR
// vc_chassis := us_morphling ;
94420: LD_ADDR_OWVAR 37
94424: PUSH
94425: LD_INT 5
94427: ST_TO_ADDR
// vc_engine := engine_siberite ;
94428: LD_ADDR_OWVAR 39
94432: PUSH
94433: LD_INT 3
94435: ST_TO_ADDR
// vc_control := control_computer ;
94436: LD_ADDR_OWVAR 38
94440: PUSH
94441: LD_INT 3
94443: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94444: LD_ADDR_OWVAR 40
94448: PUSH
94449: LD_INT 10
94451: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94452: LD_VAR 0 2
94456: PUSH
94457: LD_INT 1
94459: ARRAY
94460: PPUSH
94461: CALL_OW 310
94465: NOT
94466: IFFALSE 94513
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94468: CALL_OW 45
94472: PPUSH
94473: LD_VAR 0 2
94477: PUSH
94478: LD_INT 1
94480: ARRAY
94481: PPUSH
94482: CALL_OW 250
94486: PPUSH
94487: LD_VAR 0 2
94491: PUSH
94492: LD_INT 1
94494: ARRAY
94495: PPUSH
94496: CALL_OW 251
94500: PPUSH
94501: LD_INT 12
94503: PPUSH
94504: LD_INT 1
94506: PPUSH
94507: CALL_OW 50
94511: GO 94525
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94513: CALL_OW 45
94517: PPUSH
94518: LD_INT 1
94520: PPUSH
94521: CALL_OW 51
// end ;
94525: GO 94399
94527: POP
94528: POP
// end ;
94529: PPOPN 2
94531: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94532: LD_EXP 109
94536: PUSH
94537: LD_EXP 155
94541: AND
94542: IFFALSE 94764
94544: GO 94546
94546: DISABLE
94547: LD_INT 0
94549: PPUSH
94550: PPUSH
94551: PPUSH
94552: PPUSH
94553: PPUSH
94554: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94555: LD_ADDR_VAR 0 6
94559: PUSH
94560: LD_INT 22
94562: PUSH
94563: LD_OWVAR 2
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 21
94574: PUSH
94575: LD_INT 1
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 3
94584: PUSH
94585: LD_INT 23
94587: PUSH
94588: LD_INT 0
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: LIST
94603: PPUSH
94604: CALL_OW 69
94608: ST_TO_ADDR
// if not tmp then
94609: LD_VAR 0 6
94613: NOT
94614: IFFALSE 94618
// exit ;
94616: GO 94764
// s1 := rand ( 1 , 4 ) ;
94618: LD_ADDR_VAR 0 2
94622: PUSH
94623: LD_INT 1
94625: PPUSH
94626: LD_INT 4
94628: PPUSH
94629: CALL_OW 12
94633: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94634: LD_ADDR_VAR 0 4
94638: PUSH
94639: LD_VAR 0 6
94643: PUSH
94644: LD_INT 1
94646: ARRAY
94647: PPUSH
94648: LD_VAR 0 2
94652: PPUSH
94653: CALL_OW 259
94657: ST_TO_ADDR
// if s1 = 1 then
94658: LD_VAR 0 2
94662: PUSH
94663: LD_INT 1
94665: EQUAL
94666: IFFALSE 94686
// s2 := rand ( 2 , 4 ) else
94668: LD_ADDR_VAR 0 3
94672: PUSH
94673: LD_INT 2
94675: PPUSH
94676: LD_INT 4
94678: PPUSH
94679: CALL_OW 12
94683: ST_TO_ADDR
94684: GO 94694
// s2 := 1 ;
94686: LD_ADDR_VAR 0 3
94690: PUSH
94691: LD_INT 1
94693: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94694: LD_ADDR_VAR 0 5
94698: PUSH
94699: LD_VAR 0 6
94703: PUSH
94704: LD_INT 1
94706: ARRAY
94707: PPUSH
94708: LD_VAR 0 3
94712: PPUSH
94713: CALL_OW 259
94717: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
94718: LD_VAR 0 6
94722: PUSH
94723: LD_INT 1
94725: ARRAY
94726: PPUSH
94727: LD_VAR 0 2
94731: PPUSH
94732: LD_VAR 0 5
94736: PPUSH
94737: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
94741: LD_VAR 0 6
94745: PUSH
94746: LD_INT 1
94748: ARRAY
94749: PPUSH
94750: LD_VAR 0 3
94754: PPUSH
94755: LD_VAR 0 4
94759: PPUSH
94760: CALL_OW 237
// end ;
94764: PPOPN 6
94766: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94767: LD_EXP 109
94771: PUSH
94772: LD_EXP 156
94776: AND
94777: IFFALSE 94856
94779: GO 94781
94781: DISABLE
94782: LD_INT 0
94784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94785: LD_ADDR_VAR 0 1
94789: PUSH
94790: LD_INT 22
94792: PUSH
94793: LD_OWVAR 2
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 30
94804: PUSH
94805: LD_INT 3
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PPUSH
94816: CALL_OW 69
94820: ST_TO_ADDR
// if not tmp then
94821: LD_VAR 0 1
94825: NOT
94826: IFFALSE 94830
// exit ;
94828: GO 94856
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94830: LD_VAR 0 1
94834: PUSH
94835: LD_INT 1
94837: PPUSH
94838: LD_VAR 0 1
94842: PPUSH
94843: CALL_OW 12
94847: ARRAY
94848: PPUSH
94849: LD_INT 1
94851: PPUSH
94852: CALL_OW 234
// end ;
94856: PPOPN 1
94858: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94859: LD_EXP 109
94863: PUSH
94864: LD_EXP 157
94868: AND
94869: IFFALSE 94981
94871: GO 94873
94873: DISABLE
94874: LD_INT 0
94876: PPUSH
94877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94878: LD_ADDR_VAR 0 2
94882: PUSH
94883: LD_INT 22
94885: PUSH
94886: LD_OWVAR 2
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 2
94897: PUSH
94898: LD_INT 30
94900: PUSH
94901: LD_INT 27
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: LD_INT 30
94910: PUSH
94911: LD_INT 26
94913: PUSH
94914: EMPTY
94915: LIST
94916: LIST
94917: PUSH
94918: LD_INT 30
94920: PUSH
94921: LD_INT 28
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PPUSH
94938: CALL_OW 69
94942: ST_TO_ADDR
// if not tmp then
94943: LD_VAR 0 2
94947: NOT
94948: IFFALSE 94952
// exit ;
94950: GO 94981
// for i in tmp do
94952: LD_ADDR_VAR 0 1
94956: PUSH
94957: LD_VAR 0 2
94961: PUSH
94962: FOR_IN
94963: IFFALSE 94979
// SetLives ( i , 1 ) ;
94965: LD_VAR 0 1
94969: PPUSH
94970: LD_INT 1
94972: PPUSH
94973: CALL_OW 234
94977: GO 94962
94979: POP
94980: POP
// end ;
94981: PPOPN 2
94983: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94984: LD_EXP 109
94988: PUSH
94989: LD_EXP 158
94993: AND
94994: IFFALSE 95268
94996: GO 94998
94998: DISABLE
94999: LD_INT 0
95001: PPUSH
95002: PPUSH
95003: PPUSH
// begin i := rand ( 1 , 7 ) ;
95004: LD_ADDR_VAR 0 1
95008: PUSH
95009: LD_INT 1
95011: PPUSH
95012: LD_INT 7
95014: PPUSH
95015: CALL_OW 12
95019: ST_TO_ADDR
// case i of 1 :
95020: LD_VAR 0 1
95024: PUSH
95025: LD_INT 1
95027: DOUBLE
95028: EQUAL
95029: IFTRUE 95033
95031: GO 95043
95033: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95034: LD_STRING earthquake(getX(game), 0, 32)
95036: PPUSH
95037: CALL_OW 559
95041: GO 95268
95043: LD_INT 2
95045: DOUBLE
95046: EQUAL
95047: IFTRUE 95051
95049: GO 95065
95051: POP
// begin ToLua ( displayStucuk(); ) ;
95052: LD_STRING displayStucuk();
95054: PPUSH
95055: CALL_OW 559
// ResetFog ;
95059: CALL_OW 335
// end ; 3 :
95063: GO 95268
95065: LD_INT 3
95067: DOUBLE
95068: EQUAL
95069: IFTRUE 95073
95071: GO 95177
95073: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95074: LD_ADDR_VAR 0 2
95078: PUSH
95079: LD_INT 22
95081: PUSH
95082: LD_OWVAR 2
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 25
95093: PUSH
95094: LD_INT 1
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PPUSH
95105: CALL_OW 69
95109: ST_TO_ADDR
// if not tmp then
95110: LD_VAR 0 2
95114: NOT
95115: IFFALSE 95119
// exit ;
95117: GO 95268
// un := tmp [ rand ( 1 , tmp ) ] ;
95119: LD_ADDR_VAR 0 3
95123: PUSH
95124: LD_VAR 0 2
95128: PUSH
95129: LD_INT 1
95131: PPUSH
95132: LD_VAR 0 2
95136: PPUSH
95137: CALL_OW 12
95141: ARRAY
95142: ST_TO_ADDR
// if Crawls ( un ) then
95143: LD_VAR 0 3
95147: PPUSH
95148: CALL_OW 318
95152: IFFALSE 95163
// ComWalk ( un ) ;
95154: LD_VAR 0 3
95158: PPUSH
95159: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95163: LD_VAR 0 3
95167: PPUSH
95168: LD_INT 8
95170: PPUSH
95171: CALL_OW 336
// end ; 4 :
95175: GO 95268
95177: LD_INT 4
95179: DOUBLE
95180: EQUAL
95181: IFTRUE 95185
95183: GO 95246
95185: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95186: LD_ADDR_VAR 0 2
95190: PUSH
95191: LD_INT 22
95193: PUSH
95194: LD_OWVAR 2
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 30
95205: PUSH
95206: LD_INT 29
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PPUSH
95217: CALL_OW 69
95221: ST_TO_ADDR
// if not tmp then
95222: LD_VAR 0 2
95226: NOT
95227: IFFALSE 95231
// exit ;
95229: GO 95268
// DestroyUnit ( tmp [ 1 ] ) ;
95231: LD_VAR 0 2
95235: PUSH
95236: LD_INT 1
95238: ARRAY
95239: PPUSH
95240: CALL_OW 65
// end ; 5 .. 7 :
95244: GO 95268
95246: LD_INT 5
95248: DOUBLE
95249: GREATEREQUAL
95250: IFFALSE 95258
95252: LD_INT 7
95254: DOUBLE
95255: LESSEQUAL
95256: IFTRUE 95260
95258: GO 95267
95260: POP
// StreamSibBomb ; end ;
95261: CALL 91518 0 0
95265: GO 95268
95267: POP
// end ;
95268: PPOPN 3
95270: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95271: LD_EXP 109
95275: PUSH
95276: LD_EXP 159
95280: AND
95281: IFFALSE 95437
95283: GO 95285
95285: DISABLE
95286: LD_INT 0
95288: PPUSH
95289: PPUSH
95290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95291: LD_ADDR_VAR 0 2
95295: PUSH
95296: LD_INT 81
95298: PUSH
95299: LD_OWVAR 2
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 2
95310: PUSH
95311: LD_INT 21
95313: PUSH
95314: LD_INT 1
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: PUSH
95321: LD_INT 21
95323: PUSH
95324: LD_INT 2
95326: PUSH
95327: EMPTY
95328: LIST
95329: LIST
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: LIST
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PPUSH
95340: CALL_OW 69
95344: ST_TO_ADDR
// if not tmp then
95345: LD_VAR 0 2
95349: NOT
95350: IFFALSE 95354
// exit ;
95352: GO 95437
// p := 0 ;
95354: LD_ADDR_VAR 0 3
95358: PUSH
95359: LD_INT 0
95361: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95362: LD_INT 35
95364: PPUSH
95365: CALL_OW 67
// p := p + 1 ;
95369: LD_ADDR_VAR 0 3
95373: PUSH
95374: LD_VAR 0 3
95378: PUSH
95379: LD_INT 1
95381: PLUS
95382: ST_TO_ADDR
// for i in tmp do
95383: LD_ADDR_VAR 0 1
95387: PUSH
95388: LD_VAR 0 2
95392: PUSH
95393: FOR_IN
95394: IFFALSE 95425
// if GetLives ( i ) < 1000 then
95396: LD_VAR 0 1
95400: PPUSH
95401: CALL_OW 256
95405: PUSH
95406: LD_INT 1000
95408: LESS
95409: IFFALSE 95423
// SetLives ( i , 1000 ) ;
95411: LD_VAR 0 1
95415: PPUSH
95416: LD_INT 1000
95418: PPUSH
95419: CALL_OW 234
95423: GO 95393
95425: POP
95426: POP
// until p > 20 ;
95427: LD_VAR 0 3
95431: PUSH
95432: LD_INT 20
95434: GREATER
95435: IFFALSE 95362
// end ;
95437: PPOPN 3
95439: END
// every 0 0$1 trigger StreamModeActive and sTime do
95440: LD_EXP 109
95444: PUSH
95445: LD_EXP 160
95449: AND
95450: IFFALSE 95485
95452: GO 95454
95454: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95455: LD_INT 28
95457: PPUSH
95458: LD_OWVAR 2
95462: PPUSH
95463: LD_INT 2
95465: PPUSH
95466: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95470: LD_INT 30
95472: PPUSH
95473: LD_OWVAR 2
95477: PPUSH
95478: LD_INT 2
95480: PPUSH
95481: CALL_OW 322
// end ;
95485: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95486: LD_EXP 109
95490: PUSH
95491: LD_EXP 161
95495: AND
95496: IFFALSE 95617
95498: GO 95500
95500: DISABLE
95501: LD_INT 0
95503: PPUSH
95504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95505: LD_ADDR_VAR 0 2
95509: PUSH
95510: LD_INT 22
95512: PUSH
95513: LD_OWVAR 2
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 21
95524: PUSH
95525: LD_INT 1
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 3
95534: PUSH
95535: LD_INT 23
95537: PUSH
95538: LD_INT 0
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: LIST
95553: PPUSH
95554: CALL_OW 69
95558: ST_TO_ADDR
// if not tmp then
95559: LD_VAR 0 2
95563: NOT
95564: IFFALSE 95568
// exit ;
95566: GO 95617
// for i in tmp do
95568: LD_ADDR_VAR 0 1
95572: PUSH
95573: LD_VAR 0 2
95577: PUSH
95578: FOR_IN
95579: IFFALSE 95615
// begin if Crawls ( i ) then
95581: LD_VAR 0 1
95585: PPUSH
95586: CALL_OW 318
95590: IFFALSE 95601
// ComWalk ( i ) ;
95592: LD_VAR 0 1
95596: PPUSH
95597: CALL_OW 138
// SetClass ( i , 2 ) ;
95601: LD_VAR 0 1
95605: PPUSH
95606: LD_INT 2
95608: PPUSH
95609: CALL_OW 336
// end ;
95613: GO 95578
95615: POP
95616: POP
// end ;
95617: PPOPN 2
95619: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95620: LD_EXP 109
95624: PUSH
95625: LD_EXP 162
95629: AND
95630: IFFALSE 95911
95632: GO 95634
95634: DISABLE
95635: LD_INT 0
95637: PPUSH
95638: PPUSH
95639: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95640: LD_OWVAR 2
95644: PPUSH
95645: LD_INT 9
95647: PPUSH
95648: LD_INT 1
95650: PPUSH
95651: LD_INT 1
95653: PPUSH
95654: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95658: LD_INT 9
95660: PPUSH
95661: LD_OWVAR 2
95665: PPUSH
95666: CALL_OW 343
// uc_side := 9 ;
95670: LD_ADDR_OWVAR 20
95674: PUSH
95675: LD_INT 9
95677: ST_TO_ADDR
// uc_nation := 2 ;
95678: LD_ADDR_OWVAR 21
95682: PUSH
95683: LD_INT 2
95685: ST_TO_ADDR
// hc_name := Dark Warrior ;
95686: LD_ADDR_OWVAR 26
95690: PUSH
95691: LD_STRING Dark Warrior
95693: ST_TO_ADDR
// hc_gallery :=  ;
95694: LD_ADDR_OWVAR 33
95698: PUSH
95699: LD_STRING 
95701: ST_TO_ADDR
// hc_noskilllimit := true ;
95702: LD_ADDR_OWVAR 76
95706: PUSH
95707: LD_INT 1
95709: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95710: LD_ADDR_OWVAR 31
95714: PUSH
95715: LD_INT 30
95717: PUSH
95718: LD_INT 30
95720: PUSH
95721: LD_INT 30
95723: PUSH
95724: LD_INT 30
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: ST_TO_ADDR
// un := CreateHuman ;
95733: LD_ADDR_VAR 0 3
95737: PUSH
95738: CALL_OW 44
95742: ST_TO_ADDR
// hc_noskilllimit := false ;
95743: LD_ADDR_OWVAR 76
95747: PUSH
95748: LD_INT 0
95750: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95751: LD_VAR 0 3
95755: PPUSH
95756: LD_INT 1
95758: PPUSH
95759: CALL_OW 51
// p := 0 ;
95763: LD_ADDR_VAR 0 2
95767: PUSH
95768: LD_INT 0
95770: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95771: LD_INT 35
95773: PPUSH
95774: CALL_OW 67
// p := p + 1 ;
95778: LD_ADDR_VAR 0 2
95782: PUSH
95783: LD_VAR 0 2
95787: PUSH
95788: LD_INT 1
95790: PLUS
95791: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95792: LD_VAR 0 3
95796: PPUSH
95797: CALL_OW 256
95801: PUSH
95802: LD_INT 1000
95804: LESS
95805: IFFALSE 95819
// SetLives ( un , 1000 ) ;
95807: LD_VAR 0 3
95811: PPUSH
95812: LD_INT 1000
95814: PPUSH
95815: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95819: LD_VAR 0 3
95823: PPUSH
95824: LD_INT 81
95826: PUSH
95827: LD_OWVAR 2
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 91
95838: PUSH
95839: LD_VAR 0 3
95843: PUSH
95844: LD_INT 30
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: LIST
95851: PUSH
95852: EMPTY
95853: LIST
95854: LIST
95855: PPUSH
95856: CALL_OW 69
95860: PPUSH
95861: LD_VAR 0 3
95865: PPUSH
95866: CALL_OW 74
95870: PPUSH
95871: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
95875: LD_VAR 0 2
95879: PUSH
95880: LD_INT 60
95882: GREATER
95883: PUSH
95884: LD_VAR 0 3
95888: PPUSH
95889: CALL_OW 301
95893: OR
95894: IFFALSE 95771
// if un then
95896: LD_VAR 0 3
95900: IFFALSE 95911
// RemoveUnit ( un ) ;
95902: LD_VAR 0 3
95906: PPUSH
95907: CALL_OW 64
// end ;
95911: PPOPN 3
95913: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95914: LD_INT 0
95916: PPUSH
// case cmd of 301 :
95917: LD_VAR 0 1
95921: PUSH
95922: LD_INT 301
95924: DOUBLE
95925: EQUAL
95926: IFTRUE 95930
95928: GO 95962
95930: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
95931: LD_VAR 0 6
95935: PPUSH
95936: LD_VAR 0 7
95940: PPUSH
95941: LD_VAR 0 8
95945: PPUSH
95946: LD_VAR 0 4
95950: PPUSH
95951: LD_VAR 0 5
95955: PPUSH
95956: CALL 97163 0 5
95960: GO 96083
95962: LD_INT 302
95964: DOUBLE
95965: EQUAL
95966: IFTRUE 95970
95968: GO 96007
95970: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
95971: LD_VAR 0 6
95975: PPUSH
95976: LD_VAR 0 7
95980: PPUSH
95981: LD_VAR 0 8
95985: PPUSH
95986: LD_VAR 0 9
95990: PPUSH
95991: LD_VAR 0 4
95995: PPUSH
95996: LD_VAR 0 5
96000: PPUSH
96001: CALL 97254 0 6
96005: GO 96083
96007: LD_INT 303
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96015
96013: GO 96052
96015: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96016: LD_VAR 0 6
96020: PPUSH
96021: LD_VAR 0 7
96025: PPUSH
96026: LD_VAR 0 8
96030: PPUSH
96031: LD_VAR 0 9
96035: PPUSH
96036: LD_VAR 0 4
96040: PPUSH
96041: LD_VAR 0 5
96045: PPUSH
96046: CALL 96088 0 6
96050: GO 96083
96052: LD_INT 304
96054: DOUBLE
96055: EQUAL
96056: IFTRUE 96060
96058: GO 96082
96060: POP
// hHackTeleport ( unit , x , y ) ; end ;
96061: LD_VAR 0 2
96065: PPUSH
96066: LD_VAR 0 4
96070: PPUSH
96071: LD_VAR 0 5
96075: PPUSH
96076: CALL 97847 0 3
96080: GO 96083
96082: POP
// end ;
96083: LD_VAR 0 12
96087: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
96088: LD_INT 0
96090: PPUSH
96091: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
96092: LD_VAR 0 1
96096: PUSH
96097: LD_INT 1
96099: LESS
96100: PUSH
96101: LD_VAR 0 1
96105: PUSH
96106: LD_INT 3
96108: GREATER
96109: OR
96110: PUSH
96111: LD_VAR 0 5
96115: PPUSH
96116: LD_VAR 0 6
96120: PPUSH
96121: CALL_OW 428
96125: OR
96126: IFFALSE 96130
// exit ;
96128: GO 96850
// uc_side := your_side ;
96130: LD_ADDR_OWVAR 20
96134: PUSH
96135: LD_OWVAR 2
96139: ST_TO_ADDR
// uc_nation := nation ;
96140: LD_ADDR_OWVAR 21
96144: PUSH
96145: LD_VAR 0 1
96149: ST_TO_ADDR
// bc_level = 1 ;
96150: LD_ADDR_OWVAR 43
96154: PUSH
96155: LD_INT 1
96157: ST_TO_ADDR
// case btype of 1 :
96158: LD_VAR 0 2
96162: PUSH
96163: LD_INT 1
96165: DOUBLE
96166: EQUAL
96167: IFTRUE 96171
96169: GO 96182
96171: POP
// bc_type := b_depot ; 2 :
96172: LD_ADDR_OWVAR 42
96176: PUSH
96177: LD_INT 0
96179: ST_TO_ADDR
96180: GO 96794
96182: LD_INT 2
96184: DOUBLE
96185: EQUAL
96186: IFTRUE 96190
96188: GO 96201
96190: POP
// bc_type := b_warehouse ; 3 :
96191: LD_ADDR_OWVAR 42
96195: PUSH
96196: LD_INT 1
96198: ST_TO_ADDR
96199: GO 96794
96201: LD_INT 3
96203: DOUBLE
96204: EQUAL
96205: IFTRUE 96209
96207: GO 96220
96209: POP
// bc_type := b_lab ; 4 .. 9 :
96210: LD_ADDR_OWVAR 42
96214: PUSH
96215: LD_INT 6
96217: ST_TO_ADDR
96218: GO 96794
96220: LD_INT 4
96222: DOUBLE
96223: GREATEREQUAL
96224: IFFALSE 96232
96226: LD_INT 9
96228: DOUBLE
96229: LESSEQUAL
96230: IFTRUE 96234
96232: GO 96286
96234: POP
// begin bc_type := b_lab_half ;
96235: LD_ADDR_OWVAR 42
96239: PUSH
96240: LD_INT 7
96242: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96243: LD_ADDR_OWVAR 44
96247: PUSH
96248: LD_INT 10
96250: PUSH
96251: LD_INT 11
96253: PUSH
96254: LD_INT 12
96256: PUSH
96257: LD_INT 15
96259: PUSH
96260: LD_INT 14
96262: PUSH
96263: LD_INT 13
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: PUSH
96274: LD_VAR 0 2
96278: PUSH
96279: LD_INT 3
96281: MINUS
96282: ARRAY
96283: ST_TO_ADDR
// end ; 10 .. 13 :
96284: GO 96794
96286: LD_INT 10
96288: DOUBLE
96289: GREATEREQUAL
96290: IFFALSE 96298
96292: LD_INT 13
96294: DOUBLE
96295: LESSEQUAL
96296: IFTRUE 96300
96298: GO 96377
96300: POP
// begin bc_type := b_lab_full ;
96301: LD_ADDR_OWVAR 42
96305: PUSH
96306: LD_INT 8
96308: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96309: LD_ADDR_OWVAR 44
96313: PUSH
96314: LD_INT 10
96316: PUSH
96317: LD_INT 12
96319: PUSH
96320: LD_INT 14
96322: PUSH
96323: LD_INT 13
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: PUSH
96332: LD_VAR 0 2
96336: PUSH
96337: LD_INT 9
96339: MINUS
96340: ARRAY
96341: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96342: LD_ADDR_OWVAR 45
96346: PUSH
96347: LD_INT 11
96349: PUSH
96350: LD_INT 15
96352: PUSH
96353: LD_INT 12
96355: PUSH
96356: LD_INT 15
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: PUSH
96365: LD_VAR 0 2
96369: PUSH
96370: LD_INT 9
96372: MINUS
96373: ARRAY
96374: ST_TO_ADDR
// end ; 14 :
96375: GO 96794
96377: LD_INT 14
96379: DOUBLE
96380: EQUAL
96381: IFTRUE 96385
96383: GO 96396
96385: POP
// bc_type := b_workshop ; 15 :
96386: LD_ADDR_OWVAR 42
96390: PUSH
96391: LD_INT 2
96393: ST_TO_ADDR
96394: GO 96794
96396: LD_INT 15
96398: DOUBLE
96399: EQUAL
96400: IFTRUE 96404
96402: GO 96415
96404: POP
// bc_type := b_factory ; 16 :
96405: LD_ADDR_OWVAR 42
96409: PUSH
96410: LD_INT 3
96412: ST_TO_ADDR
96413: GO 96794
96415: LD_INT 16
96417: DOUBLE
96418: EQUAL
96419: IFTRUE 96423
96421: GO 96434
96423: POP
// bc_type := b_ext_gun ; 17 :
96424: LD_ADDR_OWVAR 42
96428: PUSH
96429: LD_INT 17
96431: ST_TO_ADDR
96432: GO 96794
96434: LD_INT 17
96436: DOUBLE
96437: EQUAL
96438: IFTRUE 96442
96440: GO 96470
96442: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96443: LD_ADDR_OWVAR 42
96447: PUSH
96448: LD_INT 19
96450: PUSH
96451: LD_INT 23
96453: PUSH
96454: LD_INT 19
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: LIST
96461: PUSH
96462: LD_VAR 0 1
96466: ARRAY
96467: ST_TO_ADDR
96468: GO 96794
96470: LD_INT 18
96472: DOUBLE
96473: EQUAL
96474: IFTRUE 96478
96476: GO 96489
96478: POP
// bc_type := b_ext_radar ; 19 :
96479: LD_ADDR_OWVAR 42
96483: PUSH
96484: LD_INT 20
96486: ST_TO_ADDR
96487: GO 96794
96489: LD_INT 19
96491: DOUBLE
96492: EQUAL
96493: IFTRUE 96497
96495: GO 96508
96497: POP
// bc_type := b_ext_radio ; 20 :
96498: LD_ADDR_OWVAR 42
96502: PUSH
96503: LD_INT 22
96505: ST_TO_ADDR
96506: GO 96794
96508: LD_INT 20
96510: DOUBLE
96511: EQUAL
96512: IFTRUE 96516
96514: GO 96527
96516: POP
// bc_type := b_ext_siberium ; 21 :
96517: LD_ADDR_OWVAR 42
96521: PUSH
96522: LD_INT 21
96524: ST_TO_ADDR
96525: GO 96794
96527: LD_INT 21
96529: DOUBLE
96530: EQUAL
96531: IFTRUE 96535
96533: GO 96546
96535: POP
// bc_type := b_ext_computer ; 22 :
96536: LD_ADDR_OWVAR 42
96540: PUSH
96541: LD_INT 24
96543: ST_TO_ADDR
96544: GO 96794
96546: LD_INT 22
96548: DOUBLE
96549: EQUAL
96550: IFTRUE 96554
96552: GO 96565
96554: POP
// bc_type := b_ext_track ; 23 :
96555: LD_ADDR_OWVAR 42
96559: PUSH
96560: LD_INT 16
96562: ST_TO_ADDR
96563: GO 96794
96565: LD_INT 23
96567: DOUBLE
96568: EQUAL
96569: IFTRUE 96573
96571: GO 96584
96573: POP
// bc_type := b_ext_laser ; 24 :
96574: LD_ADDR_OWVAR 42
96578: PUSH
96579: LD_INT 25
96581: ST_TO_ADDR
96582: GO 96794
96584: LD_INT 24
96586: DOUBLE
96587: EQUAL
96588: IFTRUE 96592
96590: GO 96603
96592: POP
// bc_type := b_control_tower ; 25 :
96593: LD_ADDR_OWVAR 42
96597: PUSH
96598: LD_INT 36
96600: ST_TO_ADDR
96601: GO 96794
96603: LD_INT 25
96605: DOUBLE
96606: EQUAL
96607: IFTRUE 96611
96609: GO 96622
96611: POP
// bc_type := b_breastwork ; 26 :
96612: LD_ADDR_OWVAR 42
96616: PUSH
96617: LD_INT 31
96619: ST_TO_ADDR
96620: GO 96794
96622: LD_INT 26
96624: DOUBLE
96625: EQUAL
96626: IFTRUE 96630
96628: GO 96641
96630: POP
// bc_type := b_bunker ; 27 :
96631: LD_ADDR_OWVAR 42
96635: PUSH
96636: LD_INT 32
96638: ST_TO_ADDR
96639: GO 96794
96641: LD_INT 27
96643: DOUBLE
96644: EQUAL
96645: IFTRUE 96649
96647: GO 96660
96649: POP
// bc_type := b_turret ; 28 :
96650: LD_ADDR_OWVAR 42
96654: PUSH
96655: LD_INT 33
96657: ST_TO_ADDR
96658: GO 96794
96660: LD_INT 28
96662: DOUBLE
96663: EQUAL
96664: IFTRUE 96668
96666: GO 96679
96668: POP
// bc_type := b_armoury ; 29 :
96669: LD_ADDR_OWVAR 42
96673: PUSH
96674: LD_INT 4
96676: ST_TO_ADDR
96677: GO 96794
96679: LD_INT 29
96681: DOUBLE
96682: EQUAL
96683: IFTRUE 96687
96685: GO 96698
96687: POP
// bc_type := b_barracks ; 30 :
96688: LD_ADDR_OWVAR 42
96692: PUSH
96693: LD_INT 5
96695: ST_TO_ADDR
96696: GO 96794
96698: LD_INT 30
96700: DOUBLE
96701: EQUAL
96702: IFTRUE 96706
96704: GO 96717
96706: POP
// bc_type := b_solar_power ; 31 :
96707: LD_ADDR_OWVAR 42
96711: PUSH
96712: LD_INT 27
96714: ST_TO_ADDR
96715: GO 96794
96717: LD_INT 31
96719: DOUBLE
96720: EQUAL
96721: IFTRUE 96725
96723: GO 96736
96725: POP
// bc_type := b_oil_power ; 32 :
96726: LD_ADDR_OWVAR 42
96730: PUSH
96731: LD_INT 26
96733: ST_TO_ADDR
96734: GO 96794
96736: LD_INT 32
96738: DOUBLE
96739: EQUAL
96740: IFTRUE 96744
96742: GO 96755
96744: POP
// bc_type := b_siberite_power ; 33 :
96745: LD_ADDR_OWVAR 42
96749: PUSH
96750: LD_INT 28
96752: ST_TO_ADDR
96753: GO 96794
96755: LD_INT 33
96757: DOUBLE
96758: EQUAL
96759: IFTRUE 96763
96761: GO 96774
96763: POP
// bc_type := b_oil_mine ; 34 :
96764: LD_ADDR_OWVAR 42
96768: PUSH
96769: LD_INT 29
96771: ST_TO_ADDR
96772: GO 96794
96774: LD_INT 34
96776: DOUBLE
96777: EQUAL
96778: IFTRUE 96782
96780: GO 96793
96782: POP
// bc_type := b_siberite_mine ; end ;
96783: LD_ADDR_OWVAR 42
96787: PUSH
96788: LD_INT 30
96790: ST_TO_ADDR
96791: GO 96794
96793: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
96794: LD_ADDR_VAR 0 8
96798: PUSH
96799: LD_VAR 0 5
96803: PPUSH
96804: LD_VAR 0 6
96808: PPUSH
96809: LD_VAR 0 3
96813: PPUSH
96814: CALL_OW 47
96818: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
96819: LD_OWVAR 42
96823: PUSH
96824: LD_INT 32
96826: PUSH
96827: LD_INT 33
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: IN
96834: IFFALSE 96850
// PlaceWeaponTurret ( b , weapon ) ;
96836: LD_VAR 0 8
96840: PPUSH
96841: LD_VAR 0 4
96845: PPUSH
96846: CALL_OW 431
// end ;
96850: LD_VAR 0 7
96854: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
96855: LD_INT 0
96857: PPUSH
96858: PPUSH
96859: PPUSH
96860: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96861: LD_ADDR_VAR 0 4
96865: PUSH
96866: LD_INT 22
96868: PUSH
96869: LD_OWVAR 2
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 2
96880: PUSH
96881: LD_INT 30
96883: PUSH
96884: LD_INT 0
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 30
96893: PUSH
96894: LD_INT 1
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: LIST
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: PPUSH
96910: CALL_OW 69
96914: ST_TO_ADDR
// if not tmp then
96915: LD_VAR 0 4
96919: NOT
96920: IFFALSE 96924
// exit ;
96922: GO 96983
// for i in tmp do
96924: LD_ADDR_VAR 0 2
96928: PUSH
96929: LD_VAR 0 4
96933: PUSH
96934: FOR_IN
96935: IFFALSE 96981
// for j = 1 to 3 do
96937: LD_ADDR_VAR 0 3
96941: PUSH
96942: DOUBLE
96943: LD_INT 1
96945: DEC
96946: ST_TO_ADDR
96947: LD_INT 3
96949: PUSH
96950: FOR_TO
96951: IFFALSE 96977
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
96953: LD_VAR 0 2
96957: PPUSH
96958: CALL_OW 274
96962: PPUSH
96963: LD_VAR 0 3
96967: PPUSH
96968: LD_INT 99999
96970: PPUSH
96971: CALL_OW 277
96975: GO 96950
96977: POP
96978: POP
96979: GO 96934
96981: POP
96982: POP
// end ;
96983: LD_VAR 0 1
96987: RET
// export function hHackSetLevel10 ; var i , j ; begin
96988: LD_INT 0
96990: PPUSH
96991: PPUSH
96992: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96993: LD_ADDR_VAR 0 2
96997: PUSH
96998: LD_INT 21
97000: PUSH
97001: LD_INT 1
97003: PUSH
97004: EMPTY
97005: LIST
97006: LIST
97007: PPUSH
97008: CALL_OW 69
97012: PUSH
97013: FOR_IN
97014: IFFALSE 97066
// if IsSelected ( i ) then
97016: LD_VAR 0 2
97020: PPUSH
97021: CALL_OW 306
97025: IFFALSE 97064
// begin for j := 1 to 4 do
97027: LD_ADDR_VAR 0 3
97031: PUSH
97032: DOUBLE
97033: LD_INT 1
97035: DEC
97036: ST_TO_ADDR
97037: LD_INT 4
97039: PUSH
97040: FOR_TO
97041: IFFALSE 97062
// SetSkill ( i , j , 10 ) ;
97043: LD_VAR 0 2
97047: PPUSH
97048: LD_VAR 0 3
97052: PPUSH
97053: LD_INT 10
97055: PPUSH
97056: CALL_OW 237
97060: GO 97040
97062: POP
97063: POP
// end ;
97064: GO 97013
97066: POP
97067: POP
// end ;
97068: LD_VAR 0 1
97072: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97073: LD_INT 0
97075: PPUSH
97076: PPUSH
97077: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
97078: LD_ADDR_VAR 0 2
97082: PUSH
97083: LD_INT 22
97085: PUSH
97086: LD_OWVAR 2
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 21
97097: PUSH
97098: LD_INT 1
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PPUSH
97109: CALL_OW 69
97113: PUSH
97114: FOR_IN
97115: IFFALSE 97156
// begin for j := 1 to 4 do
97117: LD_ADDR_VAR 0 3
97121: PUSH
97122: DOUBLE
97123: LD_INT 1
97125: DEC
97126: ST_TO_ADDR
97127: LD_INT 4
97129: PUSH
97130: FOR_TO
97131: IFFALSE 97152
// SetSkill ( i , j , 10 ) ;
97133: LD_VAR 0 2
97137: PPUSH
97138: LD_VAR 0 3
97142: PPUSH
97143: LD_INT 10
97145: PPUSH
97146: CALL_OW 237
97150: GO 97130
97152: POP
97153: POP
// end ;
97154: GO 97114
97156: POP
97157: POP
// end ;
97158: LD_VAR 0 1
97162: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97163: LD_INT 0
97165: PPUSH
// uc_side := your_side ;
97166: LD_ADDR_OWVAR 20
97170: PUSH
97171: LD_OWVAR 2
97175: ST_TO_ADDR
// uc_nation := nation ;
97176: LD_ADDR_OWVAR 21
97180: PUSH
97181: LD_VAR 0 1
97185: ST_TO_ADDR
// InitHc ;
97186: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97190: LD_INT 0
97192: PPUSH
97193: LD_VAR 0 2
97197: PPUSH
97198: LD_VAR 0 3
97202: PPUSH
97203: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97207: LD_VAR 0 4
97211: PPUSH
97212: LD_VAR 0 5
97216: PPUSH
97217: CALL_OW 428
97221: PUSH
97222: LD_INT 0
97224: EQUAL
97225: IFFALSE 97249
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97227: CALL_OW 44
97231: PPUSH
97232: LD_VAR 0 4
97236: PPUSH
97237: LD_VAR 0 5
97241: PPUSH
97242: LD_INT 1
97244: PPUSH
97245: CALL_OW 48
// end ;
97249: LD_VAR 0 6
97253: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97254: LD_INT 0
97256: PPUSH
97257: PPUSH
// uc_side := your_side ;
97258: LD_ADDR_OWVAR 20
97262: PUSH
97263: LD_OWVAR 2
97267: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97268: LD_VAR 0 1
97272: PUSH
97273: LD_INT 1
97275: PUSH
97276: LD_INT 2
97278: PUSH
97279: LD_INT 3
97281: PUSH
97282: LD_INT 4
97284: PUSH
97285: LD_INT 5
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: IN
97295: IFFALSE 97307
// uc_nation := nation_american else
97297: LD_ADDR_OWVAR 21
97301: PUSH
97302: LD_INT 1
97304: ST_TO_ADDR
97305: GO 97350
// if chassis in [ 11 , 12 , 13 , 14 ] then
97307: LD_VAR 0 1
97311: PUSH
97312: LD_INT 11
97314: PUSH
97315: LD_INT 12
97317: PUSH
97318: LD_INT 13
97320: PUSH
97321: LD_INT 14
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: IN
97330: IFFALSE 97342
// uc_nation := nation_arabian else
97332: LD_ADDR_OWVAR 21
97336: PUSH
97337: LD_INT 2
97339: ST_TO_ADDR
97340: GO 97350
// uc_nation := nation_russian ;
97342: LD_ADDR_OWVAR 21
97346: PUSH
97347: LD_INT 3
97349: ST_TO_ADDR
// vc_chassis := chassis ;
97350: LD_ADDR_OWVAR 37
97354: PUSH
97355: LD_VAR 0 1
97359: ST_TO_ADDR
// vc_engine := engine ;
97360: LD_ADDR_OWVAR 39
97364: PUSH
97365: LD_VAR 0 2
97369: ST_TO_ADDR
// vc_control := control ;
97370: LD_ADDR_OWVAR 38
97374: PUSH
97375: LD_VAR 0 3
97379: ST_TO_ADDR
// vc_weapon := weapon ;
97380: LD_ADDR_OWVAR 40
97384: PUSH
97385: LD_VAR 0 4
97389: ST_TO_ADDR
// un := CreateVehicle ;
97390: LD_ADDR_VAR 0 8
97394: PUSH
97395: CALL_OW 45
97399: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97400: LD_VAR 0 8
97404: PPUSH
97405: LD_INT 0
97407: PPUSH
97408: LD_INT 5
97410: PPUSH
97411: CALL_OW 12
97415: PPUSH
97416: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97420: LD_VAR 0 8
97424: PPUSH
97425: LD_VAR 0 5
97429: PPUSH
97430: LD_VAR 0 6
97434: PPUSH
97435: LD_INT 1
97437: PPUSH
97438: CALL_OW 48
// end ;
97442: LD_VAR 0 7
97446: RET
// export hInvincible ; every 1 do
97447: GO 97449
97449: DISABLE
// hInvincible := [ ] ;
97450: LD_ADDR_EXP 163
97454: PUSH
97455: EMPTY
97456: ST_TO_ADDR
97457: END
// every 10 do var i ;
97458: GO 97460
97460: DISABLE
97461: LD_INT 0
97463: PPUSH
// begin enable ;
97464: ENABLE
// if not hInvincible then
97465: LD_EXP 163
97469: NOT
97470: IFFALSE 97474
// exit ;
97472: GO 97518
// for i in hInvincible do
97474: LD_ADDR_VAR 0 1
97478: PUSH
97479: LD_EXP 163
97483: PUSH
97484: FOR_IN
97485: IFFALSE 97516
// if GetLives ( i ) < 1000 then
97487: LD_VAR 0 1
97491: PPUSH
97492: CALL_OW 256
97496: PUSH
97497: LD_INT 1000
97499: LESS
97500: IFFALSE 97514
// SetLives ( i , 1000 ) ;
97502: LD_VAR 0 1
97506: PPUSH
97507: LD_INT 1000
97509: PPUSH
97510: CALL_OW 234
97514: GO 97484
97516: POP
97517: POP
// end ;
97518: PPOPN 1
97520: END
// export function hHackInvincible ; var i ; begin
97521: LD_INT 0
97523: PPUSH
97524: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97525: LD_ADDR_VAR 0 2
97529: PUSH
97530: LD_INT 2
97532: PUSH
97533: LD_INT 21
97535: PUSH
97536: LD_INT 1
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 21
97545: PUSH
97546: LD_INT 2
97548: PUSH
97549: EMPTY
97550: LIST
97551: LIST
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: LIST
97557: PPUSH
97558: CALL_OW 69
97562: PUSH
97563: FOR_IN
97564: IFFALSE 97625
// if IsSelected ( i ) then
97566: LD_VAR 0 2
97570: PPUSH
97571: CALL_OW 306
97575: IFFALSE 97623
// begin if i in hInvincible then
97577: LD_VAR 0 2
97581: PUSH
97582: LD_EXP 163
97586: IN
97587: IFFALSE 97607
// hInvincible := hInvincible diff i else
97589: LD_ADDR_EXP 163
97593: PUSH
97594: LD_EXP 163
97598: PUSH
97599: LD_VAR 0 2
97603: DIFF
97604: ST_TO_ADDR
97605: GO 97623
// hInvincible := hInvincible union i ;
97607: LD_ADDR_EXP 163
97611: PUSH
97612: LD_EXP 163
97616: PUSH
97617: LD_VAR 0 2
97621: UNION
97622: ST_TO_ADDR
// end ;
97623: GO 97563
97625: POP
97626: POP
// end ;
97627: LD_VAR 0 1
97631: RET
// export function hHackInvisible ; var i , j ; begin
97632: LD_INT 0
97634: PPUSH
97635: PPUSH
97636: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97637: LD_ADDR_VAR 0 2
97641: PUSH
97642: LD_INT 21
97644: PUSH
97645: LD_INT 1
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: PPUSH
97652: CALL_OW 69
97656: PUSH
97657: FOR_IN
97658: IFFALSE 97682
// if IsSelected ( i ) then
97660: LD_VAR 0 2
97664: PPUSH
97665: CALL_OW 306
97669: IFFALSE 97680
// ComForceInvisible ( i ) ;
97671: LD_VAR 0 2
97675: PPUSH
97676: CALL_OW 496
97680: GO 97657
97682: POP
97683: POP
// end ;
97684: LD_VAR 0 1
97688: RET
// export function hHackChangeYourSide ; begin
97689: LD_INT 0
97691: PPUSH
// if your_side = 8 then
97692: LD_OWVAR 2
97696: PUSH
97697: LD_INT 8
97699: EQUAL
97700: IFFALSE 97712
// your_side := 0 else
97702: LD_ADDR_OWVAR 2
97706: PUSH
97707: LD_INT 0
97709: ST_TO_ADDR
97710: GO 97726
// your_side := your_side + 1 ;
97712: LD_ADDR_OWVAR 2
97716: PUSH
97717: LD_OWVAR 2
97721: PUSH
97722: LD_INT 1
97724: PLUS
97725: ST_TO_ADDR
// end ;
97726: LD_VAR 0 1
97730: RET
// export function hHackChangeUnitSide ; var i , j ; begin
97731: LD_INT 0
97733: PPUSH
97734: PPUSH
97735: PPUSH
// for i in all_units do
97736: LD_ADDR_VAR 0 2
97740: PUSH
97741: LD_OWVAR 3
97745: PUSH
97746: FOR_IN
97747: IFFALSE 97825
// if IsSelected ( i ) then
97749: LD_VAR 0 2
97753: PPUSH
97754: CALL_OW 306
97758: IFFALSE 97823
// begin j := GetSide ( i ) ;
97760: LD_ADDR_VAR 0 3
97764: PUSH
97765: LD_VAR 0 2
97769: PPUSH
97770: CALL_OW 255
97774: ST_TO_ADDR
// if j = 8 then
97775: LD_VAR 0 3
97779: PUSH
97780: LD_INT 8
97782: EQUAL
97783: IFFALSE 97795
// j := 0 else
97785: LD_ADDR_VAR 0 3
97789: PUSH
97790: LD_INT 0
97792: ST_TO_ADDR
97793: GO 97809
// j := j + 1 ;
97795: LD_ADDR_VAR 0 3
97799: PUSH
97800: LD_VAR 0 3
97804: PUSH
97805: LD_INT 1
97807: PLUS
97808: ST_TO_ADDR
// SetSide ( i , j ) ;
97809: LD_VAR 0 2
97813: PPUSH
97814: LD_VAR 0 3
97818: PPUSH
97819: CALL_OW 235
// end ;
97823: GO 97746
97825: POP
97826: POP
// end ;
97827: LD_VAR 0 1
97831: RET
// export function hHackFog ; begin
97832: LD_INT 0
97834: PPUSH
// FogOff ( true ) ;
97835: LD_INT 1
97837: PPUSH
97838: CALL_OW 344
// end ;
97842: LD_VAR 0 1
97846: RET
// export function hHackTeleport ( unit , x , y ) ; begin
97847: LD_INT 0
97849: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
97850: LD_VAR 0 1
97854: PPUSH
97855: LD_VAR 0 2
97859: PPUSH
97860: LD_VAR 0 3
97864: PPUSH
97865: LD_INT 1
97867: PPUSH
97868: LD_INT 1
97870: PPUSH
97871: CALL_OW 483
// CenterOnXY ( x , y ) ;
97875: LD_VAR 0 2
97879: PPUSH
97880: LD_VAR 0 3
97884: PPUSH
97885: CALL_OW 84
// end ; end_of_file
97889: LD_VAR 0 4
97893: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
97894: LD_INT 0
97896: PPUSH
97897: PPUSH
97898: PPUSH
97899: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
97900: LD_VAR 0 1
97904: PPUSH
97905: CALL_OW 264
97909: PUSH
97910: LD_EXP 97
97914: EQUAL
97915: IFFALSE 97987
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
97917: LD_INT 68
97919: PPUSH
97920: LD_VAR 0 1
97924: PPUSH
97925: CALL_OW 255
97929: PPUSH
97930: CALL_OW 321
97934: PUSH
97935: LD_INT 2
97937: EQUAL
97938: IFFALSE 97950
// eff := 70 else
97940: LD_ADDR_VAR 0 4
97944: PUSH
97945: LD_INT 70
97947: ST_TO_ADDR
97948: GO 97958
// eff := 30 ;
97950: LD_ADDR_VAR 0 4
97954: PUSH
97955: LD_INT 30
97957: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
97958: LD_VAR 0 1
97962: PPUSH
97963: CALL_OW 250
97967: PPUSH
97968: LD_VAR 0 1
97972: PPUSH
97973: CALL_OW 251
97977: PPUSH
97978: LD_VAR 0 4
97982: PPUSH
97983: CALL_OW 495
// end ; end ;
97987: LD_VAR 0 2
97991: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
97992: LD_INT 0
97994: PPUSH
// end ;
97995: LD_VAR 0 4
97999: RET
// export function SOS_Command ( cmd ) ; begin
98000: LD_INT 0
98002: PPUSH
// end ;
98003: LD_VAR 0 2
98007: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
98008: LD_INT 0
98010: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
98011: LD_VAR 0 1
98015: PUSH
98016: LD_INT 250
98018: EQUAL
98019: PUSH
98020: LD_VAR 0 2
98024: PPUSH
98025: CALL_OW 264
98029: PUSH
98030: LD_EXP 100
98034: EQUAL
98035: AND
98036: IFFALSE 98057
// MinerPlaceMine ( unit , x , y ) ;
98038: LD_VAR 0 2
98042: PPUSH
98043: LD_VAR 0 4
98047: PPUSH
98048: LD_VAR 0 5
98052: PPUSH
98053: CALL 100398 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
98057: LD_VAR 0 1
98061: PUSH
98062: LD_INT 251
98064: EQUAL
98065: PUSH
98066: LD_VAR 0 2
98070: PPUSH
98071: CALL_OW 264
98075: PUSH
98076: LD_EXP 100
98080: EQUAL
98081: AND
98082: IFFALSE 98103
// MinerDetonateMine ( unit , x , y ) ;
98084: LD_VAR 0 2
98088: PPUSH
98089: LD_VAR 0 4
98093: PPUSH
98094: LD_VAR 0 5
98098: PPUSH
98099: CALL 100675 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
98103: LD_VAR 0 1
98107: PUSH
98108: LD_INT 252
98110: EQUAL
98111: PUSH
98112: LD_VAR 0 2
98116: PPUSH
98117: CALL_OW 264
98121: PUSH
98122: LD_EXP 100
98126: EQUAL
98127: AND
98128: IFFALSE 98149
// MinerCreateMinefield ( unit , x , y ) ;
98130: LD_VAR 0 2
98134: PPUSH
98135: LD_VAR 0 4
98139: PPUSH
98140: LD_VAR 0 5
98144: PPUSH
98145: CALL 101092 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
98149: LD_VAR 0 1
98153: PUSH
98154: LD_INT 253
98156: EQUAL
98157: PUSH
98158: LD_VAR 0 2
98162: PPUSH
98163: CALL_OW 257
98167: PUSH
98168: LD_INT 5
98170: EQUAL
98171: AND
98172: IFFALSE 98193
// ComBinocular ( unit , x , y ) ;
98174: LD_VAR 0 2
98178: PPUSH
98179: LD_VAR 0 4
98183: PPUSH
98184: LD_VAR 0 5
98188: PPUSH
98189: CALL 101463 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98193: LD_VAR 0 1
98197: PUSH
98198: LD_INT 254
98200: EQUAL
98201: PUSH
98202: LD_VAR 0 2
98206: PPUSH
98207: CALL_OW 264
98211: PUSH
98212: LD_EXP 95
98216: EQUAL
98217: AND
98218: PUSH
98219: LD_VAR 0 3
98223: PPUSH
98224: CALL_OW 263
98228: PUSH
98229: LD_INT 3
98231: EQUAL
98232: AND
98233: IFFALSE 98249
// HackDestroyVehicle ( unit , selectedUnit ) ;
98235: LD_VAR 0 2
98239: PPUSH
98240: LD_VAR 0 3
98244: PPUSH
98245: CALL 99758 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98249: LD_VAR 0 1
98253: PUSH
98254: LD_INT 255
98256: EQUAL
98257: PUSH
98258: LD_VAR 0 2
98262: PPUSH
98263: CALL_OW 264
98267: PUSH
98268: LD_INT 14
98270: PUSH
98271: LD_INT 53
98273: PUSH
98274: EMPTY
98275: LIST
98276: LIST
98277: IN
98278: AND
98279: PUSH
98280: LD_VAR 0 4
98284: PPUSH
98285: LD_VAR 0 5
98289: PPUSH
98290: CALL_OW 488
98294: AND
98295: IFFALSE 98319
// CutTreeXYR ( unit , x , y , 12 ) ;
98297: LD_VAR 0 2
98301: PPUSH
98302: LD_VAR 0 4
98306: PPUSH
98307: LD_VAR 0 5
98311: PPUSH
98312: LD_INT 12
98314: PPUSH
98315: CALL 98324 0 4
// end ;
98319: LD_VAR 0 6
98323: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98324: LD_INT 0
98326: PPUSH
98327: PPUSH
98328: PPUSH
98329: PPUSH
98330: PPUSH
98331: PPUSH
98332: PPUSH
98333: PPUSH
98334: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98335: LD_VAR 0 1
98339: NOT
98340: PUSH
98341: LD_VAR 0 2
98345: PPUSH
98346: LD_VAR 0 3
98350: PPUSH
98351: CALL_OW 488
98355: NOT
98356: OR
98357: PUSH
98358: LD_VAR 0 4
98362: NOT
98363: OR
98364: IFFALSE 98368
// exit ;
98366: GO 98708
// list := [ ] ;
98368: LD_ADDR_VAR 0 13
98372: PUSH
98373: EMPTY
98374: ST_TO_ADDR
// if x - r < 0 then
98375: LD_VAR 0 2
98379: PUSH
98380: LD_VAR 0 4
98384: MINUS
98385: PUSH
98386: LD_INT 0
98388: LESS
98389: IFFALSE 98401
// min_x := 0 else
98391: LD_ADDR_VAR 0 7
98395: PUSH
98396: LD_INT 0
98398: ST_TO_ADDR
98399: GO 98417
// min_x := x - r ;
98401: LD_ADDR_VAR 0 7
98405: PUSH
98406: LD_VAR 0 2
98410: PUSH
98411: LD_VAR 0 4
98415: MINUS
98416: ST_TO_ADDR
// if y - r < 0 then
98417: LD_VAR 0 3
98421: PUSH
98422: LD_VAR 0 4
98426: MINUS
98427: PUSH
98428: LD_INT 0
98430: LESS
98431: IFFALSE 98443
// min_y := 0 else
98433: LD_ADDR_VAR 0 8
98437: PUSH
98438: LD_INT 0
98440: ST_TO_ADDR
98441: GO 98459
// min_y := y - r ;
98443: LD_ADDR_VAR 0 8
98447: PUSH
98448: LD_VAR 0 3
98452: PUSH
98453: LD_VAR 0 4
98457: MINUS
98458: ST_TO_ADDR
// max_x := x + r ;
98459: LD_ADDR_VAR 0 9
98463: PUSH
98464: LD_VAR 0 2
98468: PUSH
98469: LD_VAR 0 4
98473: PLUS
98474: ST_TO_ADDR
// max_y := y + r ;
98475: LD_ADDR_VAR 0 10
98479: PUSH
98480: LD_VAR 0 3
98484: PUSH
98485: LD_VAR 0 4
98489: PLUS
98490: ST_TO_ADDR
// for _x = min_x to max_x do
98491: LD_ADDR_VAR 0 11
98495: PUSH
98496: DOUBLE
98497: LD_VAR 0 7
98501: DEC
98502: ST_TO_ADDR
98503: LD_VAR 0 9
98507: PUSH
98508: FOR_TO
98509: IFFALSE 98626
// for _y = min_y to max_y do
98511: LD_ADDR_VAR 0 12
98515: PUSH
98516: DOUBLE
98517: LD_VAR 0 8
98521: DEC
98522: ST_TO_ADDR
98523: LD_VAR 0 10
98527: PUSH
98528: FOR_TO
98529: IFFALSE 98622
// begin if not ValidHex ( _x , _y ) then
98531: LD_VAR 0 11
98535: PPUSH
98536: LD_VAR 0 12
98540: PPUSH
98541: CALL_OW 488
98545: NOT
98546: IFFALSE 98550
// continue ;
98548: GO 98528
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98550: LD_VAR 0 11
98554: PPUSH
98555: LD_VAR 0 12
98559: PPUSH
98560: CALL_OW 351
98564: PUSH
98565: LD_VAR 0 11
98569: PPUSH
98570: LD_VAR 0 12
98574: PPUSH
98575: CALL_OW 554
98579: AND
98580: IFFALSE 98620
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98582: LD_ADDR_VAR 0 13
98586: PUSH
98587: LD_VAR 0 13
98591: PPUSH
98592: LD_VAR 0 13
98596: PUSH
98597: LD_INT 1
98599: PLUS
98600: PPUSH
98601: LD_VAR 0 11
98605: PUSH
98606: LD_VAR 0 12
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: PPUSH
98615: CALL_OW 2
98619: ST_TO_ADDR
// end ;
98620: GO 98528
98622: POP
98623: POP
98624: GO 98508
98626: POP
98627: POP
// if not list then
98628: LD_VAR 0 13
98632: NOT
98633: IFFALSE 98637
// exit ;
98635: GO 98708
// for i in list do
98637: LD_ADDR_VAR 0 6
98641: PUSH
98642: LD_VAR 0 13
98646: PUSH
98647: FOR_IN
98648: IFFALSE 98706
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98650: LD_VAR 0 1
98654: PPUSH
98655: LD_STRING M
98657: PUSH
98658: LD_VAR 0 6
98662: PUSH
98663: LD_INT 1
98665: ARRAY
98666: PUSH
98667: LD_VAR 0 6
98671: PUSH
98672: LD_INT 2
98674: ARRAY
98675: PUSH
98676: LD_INT 0
98678: PUSH
98679: LD_INT 0
98681: PUSH
98682: LD_INT 0
98684: PUSH
98685: LD_INT 0
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: PUSH
98697: EMPTY
98698: LIST
98699: PPUSH
98700: CALL_OW 447
98704: GO 98647
98706: POP
98707: POP
// end ;
98708: LD_VAR 0 5
98712: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
98713: LD_EXP 164
98717: NOT
98718: IFFALSE 98768
98720: GO 98722
98722: DISABLE
// begin initHack := true ;
98723: LD_ADDR_EXP 164
98727: PUSH
98728: LD_INT 1
98730: ST_TO_ADDR
// hackTanks := [ ] ;
98731: LD_ADDR_EXP 165
98735: PUSH
98736: EMPTY
98737: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
98738: LD_ADDR_EXP 166
98742: PUSH
98743: EMPTY
98744: ST_TO_ADDR
// hackLimit := 3 ;
98745: LD_ADDR_EXP 167
98749: PUSH
98750: LD_INT 3
98752: ST_TO_ADDR
// hackDist := 12 ;
98753: LD_ADDR_EXP 168
98757: PUSH
98758: LD_INT 12
98760: ST_TO_ADDR
// hackCounter := [ ] ;
98761: LD_ADDR_EXP 169
98765: PUSH
98766: EMPTY
98767: ST_TO_ADDR
// end ;
98768: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
98769: LD_EXP 164
98773: PUSH
98774: LD_INT 34
98776: PUSH
98777: LD_EXP 95
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: PPUSH
98786: CALL_OW 69
98790: AND
98791: IFFALSE 99046
98793: GO 98795
98795: DISABLE
98796: LD_INT 0
98798: PPUSH
98799: PPUSH
// begin enable ;
98800: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
98801: LD_ADDR_VAR 0 1
98805: PUSH
98806: LD_INT 34
98808: PUSH
98809: LD_EXP 95
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: PPUSH
98818: CALL_OW 69
98822: PUSH
98823: FOR_IN
98824: IFFALSE 99044
// begin if not i in hackTanks then
98826: LD_VAR 0 1
98830: PUSH
98831: LD_EXP 165
98835: IN
98836: NOT
98837: IFFALSE 98920
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
98839: LD_ADDR_EXP 165
98843: PUSH
98844: LD_EXP 165
98848: PPUSH
98849: LD_EXP 165
98853: PUSH
98854: LD_INT 1
98856: PLUS
98857: PPUSH
98858: LD_VAR 0 1
98862: PPUSH
98863: CALL_OW 1
98867: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
98868: LD_ADDR_EXP 166
98872: PUSH
98873: LD_EXP 166
98877: PPUSH
98878: LD_EXP 166
98882: PUSH
98883: LD_INT 1
98885: PLUS
98886: PPUSH
98887: EMPTY
98888: PPUSH
98889: CALL_OW 1
98893: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
98894: LD_ADDR_EXP 169
98898: PUSH
98899: LD_EXP 169
98903: PPUSH
98904: LD_EXP 169
98908: PUSH
98909: LD_INT 1
98911: PLUS
98912: PPUSH
98913: EMPTY
98914: PPUSH
98915: CALL_OW 1
98919: ST_TO_ADDR
// end ; if not IsOk ( i ) then
98920: LD_VAR 0 1
98924: PPUSH
98925: CALL_OW 302
98929: NOT
98930: IFFALSE 98943
// begin HackUnlinkAll ( i ) ;
98932: LD_VAR 0 1
98936: PPUSH
98937: CALL 99049 0 1
// continue ;
98941: GO 98823
// end ; HackCheckCapturedStatus ( i ) ;
98943: LD_VAR 0 1
98947: PPUSH
98948: CALL 99492 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
98952: LD_ADDR_VAR 0 2
98956: PUSH
98957: LD_INT 81
98959: PUSH
98960: LD_VAR 0 1
98964: PPUSH
98965: CALL_OW 255
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PUSH
98974: LD_INT 33
98976: PUSH
98977: LD_INT 3
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PUSH
98984: LD_INT 91
98986: PUSH
98987: LD_VAR 0 1
98991: PUSH
98992: LD_EXP 168
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 50
99004: PUSH
99005: EMPTY
99006: LIST
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: PPUSH
99014: CALL_OW 69
99018: ST_TO_ADDR
// if not tmp then
99019: LD_VAR 0 2
99023: NOT
99024: IFFALSE 99028
// continue ;
99026: GO 98823
// HackLink ( i , tmp ) ;
99028: LD_VAR 0 1
99032: PPUSH
99033: LD_VAR 0 2
99037: PPUSH
99038: CALL 99185 0 2
// end ;
99042: GO 98823
99044: POP
99045: POP
// end ;
99046: PPOPN 2
99048: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99049: LD_INT 0
99051: PPUSH
99052: PPUSH
99053: PPUSH
// if not hack in hackTanks then
99054: LD_VAR 0 1
99058: PUSH
99059: LD_EXP 165
99063: IN
99064: NOT
99065: IFFALSE 99069
// exit ;
99067: GO 99180
// index := GetElementIndex ( hackTanks , hack ) ;
99069: LD_ADDR_VAR 0 4
99073: PUSH
99074: LD_EXP 165
99078: PPUSH
99079: LD_VAR 0 1
99083: PPUSH
99084: CALL 52245 0 2
99088: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99089: LD_EXP 166
99093: PUSH
99094: LD_VAR 0 4
99098: ARRAY
99099: IFFALSE 99180
// begin for i in hackTanksCaptured [ index ] do
99101: LD_ADDR_VAR 0 3
99105: PUSH
99106: LD_EXP 166
99110: PUSH
99111: LD_VAR 0 4
99115: ARRAY
99116: PUSH
99117: FOR_IN
99118: IFFALSE 99144
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99120: LD_VAR 0 3
99124: PUSH
99125: LD_INT 1
99127: ARRAY
99128: PPUSH
99129: LD_VAR 0 3
99133: PUSH
99134: LD_INT 2
99136: ARRAY
99137: PPUSH
99138: CALL_OW 235
99142: GO 99117
99144: POP
99145: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99146: LD_ADDR_EXP 166
99150: PUSH
99151: LD_EXP 166
99155: PPUSH
99156: LD_VAR 0 4
99160: PPUSH
99161: EMPTY
99162: PPUSH
99163: CALL_OW 1
99167: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99168: LD_VAR 0 1
99172: PPUSH
99173: LD_INT 0
99175: PPUSH
99176: CALL_OW 505
// end ; end ;
99180: LD_VAR 0 2
99184: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99185: LD_INT 0
99187: PPUSH
99188: PPUSH
99189: PPUSH
// if not hack in hackTanks or not vehicles then
99190: LD_VAR 0 1
99194: PUSH
99195: LD_EXP 165
99199: IN
99200: NOT
99201: PUSH
99202: LD_VAR 0 2
99206: NOT
99207: OR
99208: IFFALSE 99212
// exit ;
99210: GO 99487
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99212: LD_ADDR_VAR 0 2
99216: PUSH
99217: LD_VAR 0 1
99221: PPUSH
99222: LD_VAR 0 2
99226: PPUSH
99227: LD_INT 1
99229: PPUSH
99230: LD_INT 1
99232: PPUSH
99233: CALL 52895 0 4
99237: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99238: LD_ADDR_VAR 0 5
99242: PUSH
99243: LD_EXP 165
99247: PPUSH
99248: LD_VAR 0 1
99252: PPUSH
99253: CALL 52245 0 2
99257: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99258: LD_EXP 166
99262: PUSH
99263: LD_VAR 0 5
99267: ARRAY
99268: PUSH
99269: LD_EXP 167
99273: LESS
99274: IFFALSE 99463
// begin for i := 1 to vehicles do
99276: LD_ADDR_VAR 0 4
99280: PUSH
99281: DOUBLE
99282: LD_INT 1
99284: DEC
99285: ST_TO_ADDR
99286: LD_VAR 0 2
99290: PUSH
99291: FOR_TO
99292: IFFALSE 99461
// begin if hackTanksCaptured [ index ] = hackLimit then
99294: LD_EXP 166
99298: PUSH
99299: LD_VAR 0 5
99303: ARRAY
99304: PUSH
99305: LD_EXP 167
99309: EQUAL
99310: IFFALSE 99314
// break ;
99312: GO 99461
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99314: LD_ADDR_EXP 169
99318: PUSH
99319: LD_EXP 169
99323: PPUSH
99324: LD_VAR 0 5
99328: PPUSH
99329: LD_EXP 169
99333: PUSH
99334: LD_VAR 0 5
99338: ARRAY
99339: PUSH
99340: LD_INT 1
99342: PLUS
99343: PPUSH
99344: CALL_OW 1
99348: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99349: LD_ADDR_EXP 166
99353: PUSH
99354: LD_EXP 166
99358: PPUSH
99359: LD_VAR 0 5
99363: PUSH
99364: LD_EXP 166
99368: PUSH
99369: LD_VAR 0 5
99373: ARRAY
99374: PUSH
99375: LD_INT 1
99377: PLUS
99378: PUSH
99379: EMPTY
99380: LIST
99381: LIST
99382: PPUSH
99383: LD_VAR 0 2
99387: PUSH
99388: LD_VAR 0 4
99392: ARRAY
99393: PUSH
99394: LD_VAR 0 2
99398: PUSH
99399: LD_VAR 0 4
99403: ARRAY
99404: PPUSH
99405: CALL_OW 255
99409: PUSH
99410: EMPTY
99411: LIST
99412: LIST
99413: PPUSH
99414: CALL 52460 0 3
99418: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99419: LD_VAR 0 2
99423: PUSH
99424: LD_VAR 0 4
99428: ARRAY
99429: PPUSH
99430: LD_VAR 0 1
99434: PPUSH
99435: CALL_OW 255
99439: PPUSH
99440: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99444: LD_VAR 0 2
99448: PUSH
99449: LD_VAR 0 4
99453: ARRAY
99454: PPUSH
99455: CALL_OW 141
// end ;
99459: GO 99291
99461: POP
99462: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99463: LD_VAR 0 1
99467: PPUSH
99468: LD_EXP 166
99472: PUSH
99473: LD_VAR 0 5
99477: ARRAY
99478: PUSH
99479: LD_INT 0
99481: PLUS
99482: PPUSH
99483: CALL_OW 505
// end ;
99487: LD_VAR 0 3
99491: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99492: LD_INT 0
99494: PPUSH
99495: PPUSH
99496: PPUSH
99497: PPUSH
// if not hack in hackTanks then
99498: LD_VAR 0 1
99502: PUSH
99503: LD_EXP 165
99507: IN
99508: NOT
99509: IFFALSE 99513
// exit ;
99511: GO 99753
// index := GetElementIndex ( hackTanks , hack ) ;
99513: LD_ADDR_VAR 0 4
99517: PUSH
99518: LD_EXP 165
99522: PPUSH
99523: LD_VAR 0 1
99527: PPUSH
99528: CALL 52245 0 2
99532: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99533: LD_ADDR_VAR 0 3
99537: PUSH
99538: DOUBLE
99539: LD_EXP 166
99543: PUSH
99544: LD_VAR 0 4
99548: ARRAY
99549: INC
99550: ST_TO_ADDR
99551: LD_INT 1
99553: PUSH
99554: FOR_DOWNTO
99555: IFFALSE 99727
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99557: LD_ADDR_VAR 0 5
99561: PUSH
99562: LD_EXP 166
99566: PUSH
99567: LD_VAR 0 4
99571: ARRAY
99572: PUSH
99573: LD_VAR 0 3
99577: ARRAY
99578: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99579: LD_VAR 0 5
99583: PUSH
99584: LD_INT 1
99586: ARRAY
99587: PPUSH
99588: CALL_OW 302
99592: NOT
99593: PUSH
99594: LD_VAR 0 5
99598: PUSH
99599: LD_INT 1
99601: ARRAY
99602: PPUSH
99603: CALL_OW 255
99607: PUSH
99608: LD_VAR 0 1
99612: PPUSH
99613: CALL_OW 255
99617: NONEQUAL
99618: OR
99619: IFFALSE 99725
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99621: LD_VAR 0 5
99625: PUSH
99626: LD_INT 1
99628: ARRAY
99629: PPUSH
99630: CALL_OW 305
99634: PUSH
99635: LD_VAR 0 5
99639: PUSH
99640: LD_INT 1
99642: ARRAY
99643: PPUSH
99644: CALL_OW 255
99648: PUSH
99649: LD_VAR 0 1
99653: PPUSH
99654: CALL_OW 255
99658: EQUAL
99659: AND
99660: IFFALSE 99684
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99662: LD_VAR 0 5
99666: PUSH
99667: LD_INT 1
99669: ARRAY
99670: PPUSH
99671: LD_VAR 0 5
99675: PUSH
99676: LD_INT 2
99678: ARRAY
99679: PPUSH
99680: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99684: LD_ADDR_EXP 166
99688: PUSH
99689: LD_EXP 166
99693: PPUSH
99694: LD_VAR 0 4
99698: PPUSH
99699: LD_EXP 166
99703: PUSH
99704: LD_VAR 0 4
99708: ARRAY
99709: PPUSH
99710: LD_VAR 0 3
99714: PPUSH
99715: CALL_OW 3
99719: PPUSH
99720: CALL_OW 1
99724: ST_TO_ADDR
// end ; end ;
99725: GO 99554
99727: POP
99728: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99729: LD_VAR 0 1
99733: PPUSH
99734: LD_EXP 166
99738: PUSH
99739: LD_VAR 0 4
99743: ARRAY
99744: PUSH
99745: LD_INT 0
99747: PLUS
99748: PPUSH
99749: CALL_OW 505
// end ;
99753: LD_VAR 0 2
99757: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
99758: LD_INT 0
99760: PPUSH
99761: PPUSH
99762: PPUSH
99763: PPUSH
// if not hack in hackTanks then
99764: LD_VAR 0 1
99768: PUSH
99769: LD_EXP 165
99773: IN
99774: NOT
99775: IFFALSE 99779
// exit ;
99777: GO 99864
// index := GetElementIndex ( hackTanks , hack ) ;
99779: LD_ADDR_VAR 0 5
99783: PUSH
99784: LD_EXP 165
99788: PPUSH
99789: LD_VAR 0 1
99793: PPUSH
99794: CALL 52245 0 2
99798: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
99799: LD_ADDR_VAR 0 4
99803: PUSH
99804: DOUBLE
99805: LD_INT 1
99807: DEC
99808: ST_TO_ADDR
99809: LD_EXP 166
99813: PUSH
99814: LD_VAR 0 5
99818: ARRAY
99819: PUSH
99820: FOR_TO
99821: IFFALSE 99862
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
99823: LD_EXP 166
99827: PUSH
99828: LD_VAR 0 5
99832: ARRAY
99833: PUSH
99834: LD_VAR 0 4
99838: ARRAY
99839: PUSH
99840: LD_INT 1
99842: ARRAY
99843: PUSH
99844: LD_VAR 0 2
99848: EQUAL
99849: IFFALSE 99860
// KillUnit ( vehicle ) ;
99851: LD_VAR 0 2
99855: PPUSH
99856: CALL_OW 66
99860: GO 99820
99862: POP
99863: POP
// end ;
99864: LD_VAR 0 3
99868: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
99869: LD_EXP 170
99873: NOT
99874: IFFALSE 99909
99876: GO 99878
99878: DISABLE
// begin initMiner := true ;
99879: LD_ADDR_EXP 170
99883: PUSH
99884: LD_INT 1
99886: ST_TO_ADDR
// minersList := [ ] ;
99887: LD_ADDR_EXP 171
99891: PUSH
99892: EMPTY
99893: ST_TO_ADDR
// minerMinesList := [ ] ;
99894: LD_ADDR_EXP 172
99898: PUSH
99899: EMPTY
99900: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
99901: LD_ADDR_EXP 173
99905: PUSH
99906: LD_INT 5
99908: ST_TO_ADDR
// end ;
99909: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
99910: LD_EXP 170
99914: PUSH
99915: LD_INT 34
99917: PUSH
99918: LD_EXP 100
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: PPUSH
99927: CALL_OW 69
99931: AND
99932: IFFALSE 100395
99934: GO 99936
99936: DISABLE
99937: LD_INT 0
99939: PPUSH
99940: PPUSH
99941: PPUSH
99942: PPUSH
// begin enable ;
99943: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
99944: LD_ADDR_VAR 0 1
99948: PUSH
99949: LD_INT 34
99951: PUSH
99952: LD_EXP 100
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: PPUSH
99961: CALL_OW 69
99965: PUSH
99966: FOR_IN
99967: IFFALSE 100039
// begin if not i in minersList then
99969: LD_VAR 0 1
99973: PUSH
99974: LD_EXP 171
99978: IN
99979: NOT
99980: IFFALSE 100037
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
99982: LD_ADDR_EXP 171
99986: PUSH
99987: LD_EXP 171
99991: PPUSH
99992: LD_EXP 171
99996: PUSH
99997: LD_INT 1
99999: PLUS
100000: PPUSH
100001: LD_VAR 0 1
100005: PPUSH
100006: CALL_OW 1
100010: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
100011: LD_ADDR_EXP 172
100015: PUSH
100016: LD_EXP 172
100020: PPUSH
100021: LD_EXP 172
100025: PUSH
100026: LD_INT 1
100028: PLUS
100029: PPUSH
100030: EMPTY
100031: PPUSH
100032: CALL_OW 1
100036: ST_TO_ADDR
// end end ;
100037: GO 99966
100039: POP
100040: POP
// for i := minerMinesList downto 1 do
100041: LD_ADDR_VAR 0 1
100045: PUSH
100046: DOUBLE
100047: LD_EXP 172
100051: INC
100052: ST_TO_ADDR
100053: LD_INT 1
100055: PUSH
100056: FOR_DOWNTO
100057: IFFALSE 100393
// begin if IsLive ( minersList [ i ] ) then
100059: LD_EXP 171
100063: PUSH
100064: LD_VAR 0 1
100068: ARRAY
100069: PPUSH
100070: CALL_OW 300
100074: IFFALSE 100102
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
100076: LD_EXP 171
100080: PUSH
100081: LD_VAR 0 1
100085: ARRAY
100086: PPUSH
100087: LD_EXP 172
100091: PUSH
100092: LD_VAR 0 1
100096: ARRAY
100097: PPUSH
100098: CALL_OW 505
// if not minerMinesList [ i ] then
100102: LD_EXP 172
100106: PUSH
100107: LD_VAR 0 1
100111: ARRAY
100112: NOT
100113: IFFALSE 100117
// continue ;
100115: GO 100056
// for j := minerMinesList [ i ] downto 1 do
100117: LD_ADDR_VAR 0 2
100121: PUSH
100122: DOUBLE
100123: LD_EXP 172
100127: PUSH
100128: LD_VAR 0 1
100132: ARRAY
100133: INC
100134: ST_TO_ADDR
100135: LD_INT 1
100137: PUSH
100138: FOR_DOWNTO
100139: IFFALSE 100389
// begin side := GetSide ( minersList [ i ] ) ;
100141: LD_ADDR_VAR 0 3
100145: PUSH
100146: LD_EXP 171
100150: PUSH
100151: LD_VAR 0 1
100155: ARRAY
100156: PPUSH
100157: CALL_OW 255
100161: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100162: LD_ADDR_VAR 0 4
100166: PUSH
100167: LD_EXP 172
100171: PUSH
100172: LD_VAR 0 1
100176: ARRAY
100177: PUSH
100178: LD_VAR 0 2
100182: ARRAY
100183: PUSH
100184: LD_INT 1
100186: ARRAY
100187: PPUSH
100188: LD_EXP 172
100192: PUSH
100193: LD_VAR 0 1
100197: ARRAY
100198: PUSH
100199: LD_VAR 0 2
100203: ARRAY
100204: PUSH
100205: LD_INT 2
100207: ARRAY
100208: PPUSH
100209: CALL_OW 428
100213: ST_TO_ADDR
// if not tmp then
100214: LD_VAR 0 4
100218: NOT
100219: IFFALSE 100223
// continue ;
100221: GO 100138
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100223: LD_VAR 0 4
100227: PUSH
100228: LD_INT 81
100230: PUSH
100231: LD_VAR 0 3
100235: PUSH
100236: EMPTY
100237: LIST
100238: LIST
100239: PPUSH
100240: CALL_OW 69
100244: IN
100245: PUSH
100246: LD_EXP 172
100250: PUSH
100251: LD_VAR 0 1
100255: ARRAY
100256: PUSH
100257: LD_VAR 0 2
100261: ARRAY
100262: PUSH
100263: LD_INT 1
100265: ARRAY
100266: PPUSH
100267: LD_EXP 172
100271: PUSH
100272: LD_VAR 0 1
100276: ARRAY
100277: PUSH
100278: LD_VAR 0 2
100282: ARRAY
100283: PUSH
100284: LD_INT 2
100286: ARRAY
100287: PPUSH
100288: CALL_OW 458
100292: AND
100293: IFFALSE 100387
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100295: LD_EXP 172
100299: PUSH
100300: LD_VAR 0 1
100304: ARRAY
100305: PUSH
100306: LD_VAR 0 2
100310: ARRAY
100311: PUSH
100312: LD_INT 1
100314: ARRAY
100315: PPUSH
100316: LD_EXP 172
100320: PUSH
100321: LD_VAR 0 1
100325: ARRAY
100326: PUSH
100327: LD_VAR 0 2
100331: ARRAY
100332: PUSH
100333: LD_INT 2
100335: ARRAY
100336: PPUSH
100337: LD_VAR 0 3
100341: PPUSH
100342: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100346: LD_ADDR_EXP 172
100350: PUSH
100351: LD_EXP 172
100355: PPUSH
100356: LD_VAR 0 1
100360: PPUSH
100361: LD_EXP 172
100365: PUSH
100366: LD_VAR 0 1
100370: ARRAY
100371: PPUSH
100372: LD_VAR 0 2
100376: PPUSH
100377: CALL_OW 3
100381: PPUSH
100382: CALL_OW 1
100386: ST_TO_ADDR
// end ; end ;
100387: GO 100138
100389: POP
100390: POP
// end ;
100391: GO 100056
100393: POP
100394: POP
// end ;
100395: PPOPN 4
100397: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100398: LD_INT 0
100400: PPUSH
100401: PPUSH
// result := false ;
100402: LD_ADDR_VAR 0 4
100406: PUSH
100407: LD_INT 0
100409: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100410: LD_VAR 0 1
100414: PPUSH
100415: CALL_OW 264
100419: PUSH
100420: LD_EXP 100
100424: EQUAL
100425: NOT
100426: IFFALSE 100430
// exit ;
100428: GO 100670
// index := GetElementIndex ( minersList , unit ) ;
100430: LD_ADDR_VAR 0 5
100434: PUSH
100435: LD_EXP 171
100439: PPUSH
100440: LD_VAR 0 1
100444: PPUSH
100445: CALL 52245 0 2
100449: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100450: LD_EXP 172
100454: PUSH
100455: LD_VAR 0 5
100459: ARRAY
100460: PUSH
100461: LD_EXP 173
100465: GREATEREQUAL
100466: IFFALSE 100470
// exit ;
100468: GO 100670
// ComMoveXY ( unit , x , y ) ;
100470: LD_VAR 0 1
100474: PPUSH
100475: LD_VAR 0 2
100479: PPUSH
100480: LD_VAR 0 3
100484: PPUSH
100485: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100489: LD_INT 35
100491: PPUSH
100492: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100496: LD_VAR 0 1
100500: PPUSH
100501: LD_VAR 0 2
100505: PPUSH
100506: LD_VAR 0 3
100510: PPUSH
100511: CALL 82309 0 3
100515: NOT
100516: PUSH
100517: LD_VAR 0 1
100521: PPUSH
100522: CALL_OW 314
100526: AND
100527: IFFALSE 100531
// exit ;
100529: GO 100670
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100531: LD_VAR 0 2
100535: PPUSH
100536: LD_VAR 0 3
100540: PPUSH
100541: CALL_OW 428
100545: PUSH
100546: LD_VAR 0 1
100550: EQUAL
100551: PUSH
100552: LD_VAR 0 1
100556: PPUSH
100557: CALL_OW 314
100561: NOT
100562: AND
100563: IFFALSE 100489
// PlaySoundXY ( x , y , PlantMine ) ;
100565: LD_VAR 0 2
100569: PPUSH
100570: LD_VAR 0 3
100574: PPUSH
100575: LD_STRING PlantMine
100577: PPUSH
100578: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100582: LD_VAR 0 2
100586: PPUSH
100587: LD_VAR 0 3
100591: PPUSH
100592: LD_VAR 0 1
100596: PPUSH
100597: CALL_OW 255
100601: PPUSH
100602: LD_INT 0
100604: PPUSH
100605: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100609: LD_ADDR_EXP 172
100613: PUSH
100614: LD_EXP 172
100618: PPUSH
100619: LD_VAR 0 5
100623: PUSH
100624: LD_EXP 172
100628: PUSH
100629: LD_VAR 0 5
100633: ARRAY
100634: PUSH
100635: LD_INT 1
100637: PLUS
100638: PUSH
100639: EMPTY
100640: LIST
100641: LIST
100642: PPUSH
100643: LD_VAR 0 2
100647: PUSH
100648: LD_VAR 0 3
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PPUSH
100657: CALL 52460 0 3
100661: ST_TO_ADDR
// result := true ;
100662: LD_ADDR_VAR 0 4
100666: PUSH
100667: LD_INT 1
100669: ST_TO_ADDR
// end ;
100670: LD_VAR 0 4
100674: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
100675: LD_INT 0
100677: PPUSH
100678: PPUSH
100679: PPUSH
// if not unit in minersList then
100680: LD_VAR 0 1
100684: PUSH
100685: LD_EXP 171
100689: IN
100690: NOT
100691: IFFALSE 100695
// exit ;
100693: GO 101087
// index := GetElementIndex ( minersList , unit ) ;
100695: LD_ADDR_VAR 0 6
100699: PUSH
100700: LD_EXP 171
100704: PPUSH
100705: LD_VAR 0 1
100709: PPUSH
100710: CALL 52245 0 2
100714: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
100715: LD_ADDR_VAR 0 5
100719: PUSH
100720: DOUBLE
100721: LD_EXP 172
100725: PUSH
100726: LD_VAR 0 6
100730: ARRAY
100731: INC
100732: ST_TO_ADDR
100733: LD_INT 1
100735: PUSH
100736: FOR_DOWNTO
100737: IFFALSE 100898
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
100739: LD_EXP 172
100743: PUSH
100744: LD_VAR 0 6
100748: ARRAY
100749: PUSH
100750: LD_VAR 0 5
100754: ARRAY
100755: PUSH
100756: LD_INT 1
100758: ARRAY
100759: PUSH
100760: LD_VAR 0 2
100764: EQUAL
100765: PUSH
100766: LD_EXP 172
100770: PUSH
100771: LD_VAR 0 6
100775: ARRAY
100776: PUSH
100777: LD_VAR 0 5
100781: ARRAY
100782: PUSH
100783: LD_INT 2
100785: ARRAY
100786: PUSH
100787: LD_VAR 0 3
100791: EQUAL
100792: AND
100793: IFFALSE 100896
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100795: LD_EXP 172
100799: PUSH
100800: LD_VAR 0 6
100804: ARRAY
100805: PUSH
100806: LD_VAR 0 5
100810: ARRAY
100811: PUSH
100812: LD_INT 1
100814: ARRAY
100815: PPUSH
100816: LD_EXP 172
100820: PUSH
100821: LD_VAR 0 6
100825: ARRAY
100826: PUSH
100827: LD_VAR 0 5
100831: ARRAY
100832: PUSH
100833: LD_INT 2
100835: ARRAY
100836: PPUSH
100837: LD_VAR 0 1
100841: PPUSH
100842: CALL_OW 255
100846: PPUSH
100847: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100851: LD_ADDR_EXP 172
100855: PUSH
100856: LD_EXP 172
100860: PPUSH
100861: LD_VAR 0 6
100865: PPUSH
100866: LD_EXP 172
100870: PUSH
100871: LD_VAR 0 6
100875: ARRAY
100876: PPUSH
100877: LD_VAR 0 5
100881: PPUSH
100882: CALL_OW 3
100886: PPUSH
100887: CALL_OW 1
100891: ST_TO_ADDR
// exit ;
100892: POP
100893: POP
100894: GO 101087
// end ; end ;
100896: GO 100736
100898: POP
100899: POP
// for i := minerMinesList [ index ] downto 1 do
100900: LD_ADDR_VAR 0 5
100904: PUSH
100905: DOUBLE
100906: LD_EXP 172
100910: PUSH
100911: LD_VAR 0 6
100915: ARRAY
100916: INC
100917: ST_TO_ADDR
100918: LD_INT 1
100920: PUSH
100921: FOR_DOWNTO
100922: IFFALSE 101085
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
100924: LD_EXP 172
100928: PUSH
100929: LD_VAR 0 6
100933: ARRAY
100934: PUSH
100935: LD_VAR 0 5
100939: ARRAY
100940: PUSH
100941: LD_INT 1
100943: ARRAY
100944: PPUSH
100945: LD_EXP 172
100949: PUSH
100950: LD_VAR 0 6
100954: ARRAY
100955: PUSH
100956: LD_VAR 0 5
100960: ARRAY
100961: PUSH
100962: LD_INT 2
100964: ARRAY
100965: PPUSH
100966: LD_VAR 0 2
100970: PPUSH
100971: LD_VAR 0 3
100975: PPUSH
100976: CALL_OW 298
100980: PUSH
100981: LD_INT 6
100983: LESS
100984: IFFALSE 101083
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100986: LD_EXP 172
100990: PUSH
100991: LD_VAR 0 6
100995: ARRAY
100996: PUSH
100997: LD_VAR 0 5
101001: ARRAY
101002: PUSH
101003: LD_INT 1
101005: ARRAY
101006: PPUSH
101007: LD_EXP 172
101011: PUSH
101012: LD_VAR 0 6
101016: ARRAY
101017: PUSH
101018: LD_VAR 0 5
101022: ARRAY
101023: PUSH
101024: LD_INT 2
101026: ARRAY
101027: PPUSH
101028: LD_VAR 0 1
101032: PPUSH
101033: CALL_OW 255
101037: PPUSH
101038: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101042: LD_ADDR_EXP 172
101046: PUSH
101047: LD_EXP 172
101051: PPUSH
101052: LD_VAR 0 6
101056: PPUSH
101057: LD_EXP 172
101061: PUSH
101062: LD_VAR 0 6
101066: ARRAY
101067: PPUSH
101068: LD_VAR 0 5
101072: PPUSH
101073: CALL_OW 3
101077: PPUSH
101078: CALL_OW 1
101082: ST_TO_ADDR
// end ; end ;
101083: GO 100921
101085: POP
101086: POP
// end ;
101087: LD_VAR 0 4
101091: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
101092: LD_INT 0
101094: PPUSH
101095: PPUSH
101096: PPUSH
101097: PPUSH
101098: PPUSH
101099: PPUSH
101100: PPUSH
101101: PPUSH
101102: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
101103: LD_VAR 0 1
101107: PPUSH
101108: CALL_OW 264
101112: PUSH
101113: LD_EXP 100
101117: EQUAL
101118: NOT
101119: PUSH
101120: LD_VAR 0 1
101124: PUSH
101125: LD_EXP 171
101129: IN
101130: NOT
101131: OR
101132: IFFALSE 101136
// exit ;
101134: GO 101458
// index := GetElementIndex ( minersList , unit ) ;
101136: LD_ADDR_VAR 0 6
101140: PUSH
101141: LD_EXP 171
101145: PPUSH
101146: LD_VAR 0 1
101150: PPUSH
101151: CALL 52245 0 2
101155: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101156: LD_ADDR_VAR 0 8
101160: PUSH
101161: LD_EXP 173
101165: PUSH
101166: LD_EXP 172
101170: PUSH
101171: LD_VAR 0 6
101175: ARRAY
101176: MINUS
101177: ST_TO_ADDR
// if not minesFreeAmount then
101178: LD_VAR 0 8
101182: NOT
101183: IFFALSE 101187
// exit ;
101185: GO 101458
// tmp := [ ] ;
101187: LD_ADDR_VAR 0 7
101191: PUSH
101192: EMPTY
101193: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101194: LD_ADDR_VAR 0 5
101198: PUSH
101199: DOUBLE
101200: LD_INT 1
101202: DEC
101203: ST_TO_ADDR
101204: LD_VAR 0 8
101208: PUSH
101209: FOR_TO
101210: IFFALSE 101405
// begin _d := rand ( 0 , 5 ) ;
101212: LD_ADDR_VAR 0 11
101216: PUSH
101217: LD_INT 0
101219: PPUSH
101220: LD_INT 5
101222: PPUSH
101223: CALL_OW 12
101227: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101228: LD_ADDR_VAR 0 12
101232: PUSH
101233: LD_INT 2
101235: PPUSH
101236: LD_INT 6
101238: PPUSH
101239: CALL_OW 12
101243: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101244: LD_ADDR_VAR 0 9
101248: PUSH
101249: LD_VAR 0 2
101253: PPUSH
101254: LD_VAR 0 11
101258: PPUSH
101259: LD_VAR 0 12
101263: PPUSH
101264: CALL_OW 272
101268: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101269: LD_ADDR_VAR 0 10
101273: PUSH
101274: LD_VAR 0 3
101278: PPUSH
101279: LD_VAR 0 11
101283: PPUSH
101284: LD_VAR 0 12
101288: PPUSH
101289: CALL_OW 273
101293: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101294: LD_VAR 0 9
101298: PPUSH
101299: LD_VAR 0 10
101303: PPUSH
101304: CALL_OW 488
101308: PUSH
101309: LD_VAR 0 9
101313: PUSH
101314: LD_VAR 0 10
101318: PUSH
101319: EMPTY
101320: LIST
101321: LIST
101322: PUSH
101323: LD_VAR 0 7
101327: IN
101328: NOT
101329: AND
101330: PUSH
101331: LD_VAR 0 9
101335: PPUSH
101336: LD_VAR 0 10
101340: PPUSH
101341: CALL_OW 458
101345: NOT
101346: AND
101347: IFFALSE 101389
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101349: LD_ADDR_VAR 0 7
101353: PUSH
101354: LD_VAR 0 7
101358: PPUSH
101359: LD_VAR 0 7
101363: PUSH
101364: LD_INT 1
101366: PLUS
101367: PPUSH
101368: LD_VAR 0 9
101372: PUSH
101373: LD_VAR 0 10
101377: PUSH
101378: EMPTY
101379: LIST
101380: LIST
101381: PPUSH
101382: CALL_OW 1
101386: ST_TO_ADDR
101387: GO 101403
// i := i - 1 ;
101389: LD_ADDR_VAR 0 5
101393: PUSH
101394: LD_VAR 0 5
101398: PUSH
101399: LD_INT 1
101401: MINUS
101402: ST_TO_ADDR
// end ;
101403: GO 101209
101405: POP
101406: POP
// for i in tmp do
101407: LD_ADDR_VAR 0 5
101411: PUSH
101412: LD_VAR 0 7
101416: PUSH
101417: FOR_IN
101418: IFFALSE 101456
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101420: LD_VAR 0 1
101424: PPUSH
101425: LD_VAR 0 5
101429: PUSH
101430: LD_INT 1
101432: ARRAY
101433: PPUSH
101434: LD_VAR 0 5
101438: PUSH
101439: LD_INT 2
101441: ARRAY
101442: PPUSH
101443: CALL 100398 0 3
101447: NOT
101448: IFFALSE 101454
// exit ;
101450: POP
101451: POP
101452: GO 101458
101454: GO 101417
101456: POP
101457: POP
// end ;
101458: LD_VAR 0 4
101462: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101463: LD_INT 0
101465: PPUSH
101466: PPUSH
101467: PPUSH
101468: PPUSH
101469: PPUSH
101470: PPUSH
101471: PPUSH
// if not GetClass ( unit ) = class_sniper then
101472: LD_VAR 0 1
101476: PPUSH
101477: CALL_OW 257
101481: PUSH
101482: LD_INT 5
101484: EQUAL
101485: NOT
101486: IFFALSE 101490
// exit ;
101488: GO 101878
// dist := 8 ;
101490: LD_ADDR_VAR 0 5
101494: PUSH
101495: LD_INT 8
101497: ST_TO_ADDR
// viewRange := 12 ;
101498: LD_ADDR_VAR 0 7
101502: PUSH
101503: LD_INT 12
101505: ST_TO_ADDR
// side := GetSide ( unit ) ;
101506: LD_ADDR_VAR 0 6
101510: PUSH
101511: LD_VAR 0 1
101515: PPUSH
101516: CALL_OW 255
101520: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101521: LD_INT 61
101523: PPUSH
101524: LD_VAR 0 6
101528: PPUSH
101529: CALL_OW 321
101533: PUSH
101534: LD_INT 2
101536: EQUAL
101537: IFFALSE 101547
// viewRange := 16 ;
101539: LD_ADDR_VAR 0 7
101543: PUSH
101544: LD_INT 16
101546: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101547: LD_VAR 0 1
101551: PPUSH
101552: LD_VAR 0 2
101556: PPUSH
101557: LD_VAR 0 3
101561: PPUSH
101562: CALL_OW 297
101566: PUSH
101567: LD_VAR 0 5
101571: GREATER
101572: IFFALSE 101651
// begin ComMoveXY ( unit , x , y ) ;
101574: LD_VAR 0 1
101578: PPUSH
101579: LD_VAR 0 2
101583: PPUSH
101584: LD_VAR 0 3
101588: PPUSH
101589: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101593: LD_INT 35
101595: PPUSH
101596: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101600: LD_VAR 0 1
101604: PPUSH
101605: LD_VAR 0 2
101609: PPUSH
101610: LD_VAR 0 3
101614: PPUSH
101615: CALL 82309 0 3
101619: NOT
101620: IFFALSE 101624
// exit ;
101622: GO 101878
// until GetDistUnitXY ( unit , x , y ) < dist ;
101624: LD_VAR 0 1
101628: PPUSH
101629: LD_VAR 0 2
101633: PPUSH
101634: LD_VAR 0 3
101638: PPUSH
101639: CALL_OW 297
101643: PUSH
101644: LD_VAR 0 5
101648: LESS
101649: IFFALSE 101593
// end ; ComTurnXY ( unit , x , y ) ;
101651: LD_VAR 0 1
101655: PPUSH
101656: LD_VAR 0 2
101660: PPUSH
101661: LD_VAR 0 3
101665: PPUSH
101666: CALL_OW 118
// wait ( 5 ) ;
101670: LD_INT 5
101672: PPUSH
101673: CALL_OW 67
// _d := GetDir ( unit ) ;
101677: LD_ADDR_VAR 0 10
101681: PUSH
101682: LD_VAR 0 1
101686: PPUSH
101687: CALL_OW 254
101691: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
101692: LD_ADDR_VAR 0 8
101696: PUSH
101697: LD_VAR 0 1
101701: PPUSH
101702: CALL_OW 250
101706: PPUSH
101707: LD_VAR 0 10
101711: PPUSH
101712: LD_VAR 0 5
101716: PPUSH
101717: CALL_OW 272
101721: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
101722: LD_ADDR_VAR 0 9
101726: PUSH
101727: LD_VAR 0 1
101731: PPUSH
101732: CALL_OW 251
101736: PPUSH
101737: LD_VAR 0 10
101741: PPUSH
101742: LD_VAR 0 5
101746: PPUSH
101747: CALL_OW 273
101751: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
101752: LD_VAR 0 8
101756: PPUSH
101757: LD_VAR 0 9
101761: PPUSH
101762: CALL_OW 488
101766: NOT
101767: IFFALSE 101771
// exit ;
101769: GO 101878
// ComAnimCustom ( unit , 1 ) ;
101771: LD_VAR 0 1
101775: PPUSH
101776: LD_INT 1
101778: PPUSH
101779: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
101783: LD_VAR 0 8
101787: PPUSH
101788: LD_VAR 0 9
101792: PPUSH
101793: LD_VAR 0 6
101797: PPUSH
101798: LD_VAR 0 7
101802: PPUSH
101803: CALL_OW 330
// repeat wait ( 1 ) ;
101807: LD_INT 1
101809: PPUSH
101810: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
101814: LD_VAR 0 1
101818: PPUSH
101819: CALL_OW 316
101823: PUSH
101824: LD_VAR 0 1
101828: PPUSH
101829: CALL_OW 314
101833: OR
101834: PUSH
101835: LD_VAR 0 1
101839: PPUSH
101840: CALL_OW 302
101844: NOT
101845: OR
101846: PUSH
101847: LD_VAR 0 1
101851: PPUSH
101852: CALL_OW 301
101856: OR
101857: IFFALSE 101807
// RemoveSeeing ( _x , _y , side ) ;
101859: LD_VAR 0 8
101863: PPUSH
101864: LD_VAR 0 9
101868: PPUSH
101869: LD_VAR 0 6
101873: PPUSH
101874: CALL_OW 331
// end ; end_of_file
101878: LD_VAR 0 4
101882: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101883: LD_INT 0
101885: PPUSH
101886: PPUSH
101887: PPUSH
101888: PPUSH
101889: PPUSH
101890: PPUSH
101891: PPUSH
101892: PPUSH
101893: PPUSH
101894: PPUSH
101895: PPUSH
101896: PPUSH
101897: PPUSH
101898: PPUSH
101899: PPUSH
101900: PPUSH
101901: PPUSH
101902: PPUSH
101903: PPUSH
101904: PPUSH
101905: PPUSH
101906: PPUSH
101907: PPUSH
101908: PPUSH
101909: PPUSH
101910: PPUSH
101911: PPUSH
101912: PPUSH
101913: PPUSH
101914: PPUSH
101915: PPUSH
101916: PPUSH
101917: PPUSH
101918: PPUSH
// if not list then
101919: LD_VAR 0 1
101923: NOT
101924: IFFALSE 101928
// exit ;
101926: GO 106587
// base := list [ 1 ] ;
101928: LD_ADDR_VAR 0 3
101932: PUSH
101933: LD_VAR 0 1
101937: PUSH
101938: LD_INT 1
101940: ARRAY
101941: ST_TO_ADDR
// group := list [ 2 ] ;
101942: LD_ADDR_VAR 0 4
101946: PUSH
101947: LD_VAR 0 1
101951: PUSH
101952: LD_INT 2
101954: ARRAY
101955: ST_TO_ADDR
// path := list [ 3 ] ;
101956: LD_ADDR_VAR 0 5
101960: PUSH
101961: LD_VAR 0 1
101965: PUSH
101966: LD_INT 3
101968: ARRAY
101969: ST_TO_ADDR
// flags := list [ 4 ] ;
101970: LD_ADDR_VAR 0 6
101974: PUSH
101975: LD_VAR 0 1
101979: PUSH
101980: LD_INT 4
101982: ARRAY
101983: ST_TO_ADDR
// mined := [ ] ;
101984: LD_ADDR_VAR 0 27
101988: PUSH
101989: EMPTY
101990: ST_TO_ADDR
// bombed := [ ] ;
101991: LD_ADDR_VAR 0 28
101995: PUSH
101996: EMPTY
101997: ST_TO_ADDR
// healers := [ ] ;
101998: LD_ADDR_VAR 0 31
102002: PUSH
102003: EMPTY
102004: ST_TO_ADDR
// to_heal := [ ] ;
102005: LD_ADDR_VAR 0 30
102009: PUSH
102010: EMPTY
102011: ST_TO_ADDR
// repairs := [ ] ;
102012: LD_ADDR_VAR 0 33
102016: PUSH
102017: EMPTY
102018: ST_TO_ADDR
// to_repair := [ ] ;
102019: LD_ADDR_VAR 0 32
102023: PUSH
102024: EMPTY
102025: ST_TO_ADDR
// if not group or not path then
102026: LD_VAR 0 4
102030: NOT
102031: PUSH
102032: LD_VAR 0 5
102036: NOT
102037: OR
102038: IFFALSE 102042
// exit ;
102040: GO 106587
// side := GetSide ( group [ 1 ] ) ;
102042: LD_ADDR_VAR 0 35
102046: PUSH
102047: LD_VAR 0 4
102051: PUSH
102052: LD_INT 1
102054: ARRAY
102055: PPUSH
102056: CALL_OW 255
102060: ST_TO_ADDR
// if flags then
102061: LD_VAR 0 6
102065: IFFALSE 102209
// begin f_ignore_area := flags [ 1 ] ;
102067: LD_ADDR_VAR 0 17
102071: PUSH
102072: LD_VAR 0 6
102076: PUSH
102077: LD_INT 1
102079: ARRAY
102080: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
102081: LD_ADDR_VAR 0 18
102085: PUSH
102086: LD_VAR 0 6
102090: PUSH
102091: LD_INT 2
102093: ARRAY
102094: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
102095: LD_ADDR_VAR 0 19
102099: PUSH
102100: LD_VAR 0 6
102104: PUSH
102105: LD_INT 3
102107: ARRAY
102108: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
102109: LD_ADDR_VAR 0 20
102113: PUSH
102114: LD_VAR 0 6
102118: PUSH
102119: LD_INT 4
102121: ARRAY
102122: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
102123: LD_ADDR_VAR 0 21
102127: PUSH
102128: LD_VAR 0 6
102132: PUSH
102133: LD_INT 5
102135: ARRAY
102136: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
102137: LD_ADDR_VAR 0 22
102141: PUSH
102142: LD_VAR 0 6
102146: PUSH
102147: LD_INT 6
102149: ARRAY
102150: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102151: LD_ADDR_VAR 0 23
102155: PUSH
102156: LD_VAR 0 6
102160: PUSH
102161: LD_INT 7
102163: ARRAY
102164: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102165: LD_ADDR_VAR 0 24
102169: PUSH
102170: LD_VAR 0 6
102174: PUSH
102175: LD_INT 8
102177: ARRAY
102178: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102179: LD_ADDR_VAR 0 25
102183: PUSH
102184: LD_VAR 0 6
102188: PUSH
102189: LD_INT 9
102191: ARRAY
102192: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102193: LD_ADDR_VAR 0 26
102197: PUSH
102198: LD_VAR 0 6
102202: PUSH
102203: LD_INT 10
102205: ARRAY
102206: ST_TO_ADDR
// end else
102207: GO 102289
// begin f_ignore_area := false ;
102209: LD_ADDR_VAR 0 17
102213: PUSH
102214: LD_INT 0
102216: ST_TO_ADDR
// f_capture := false ;
102217: LD_ADDR_VAR 0 18
102221: PUSH
102222: LD_INT 0
102224: ST_TO_ADDR
// f_ignore_civ := false ;
102225: LD_ADDR_VAR 0 19
102229: PUSH
102230: LD_INT 0
102232: ST_TO_ADDR
// f_murder := false ;
102233: LD_ADDR_VAR 0 20
102237: PUSH
102238: LD_INT 0
102240: ST_TO_ADDR
// f_mines := false ;
102241: LD_ADDR_VAR 0 21
102245: PUSH
102246: LD_INT 0
102248: ST_TO_ADDR
// f_repair := false ;
102249: LD_ADDR_VAR 0 22
102253: PUSH
102254: LD_INT 0
102256: ST_TO_ADDR
// f_heal := false ;
102257: LD_ADDR_VAR 0 23
102261: PUSH
102262: LD_INT 0
102264: ST_TO_ADDR
// f_spacetime := false ;
102265: LD_ADDR_VAR 0 24
102269: PUSH
102270: LD_INT 0
102272: ST_TO_ADDR
// f_attack_depot := false ;
102273: LD_ADDR_VAR 0 25
102277: PUSH
102278: LD_INT 0
102280: ST_TO_ADDR
// f_crawl := false ;
102281: LD_ADDR_VAR 0 26
102285: PUSH
102286: LD_INT 0
102288: ST_TO_ADDR
// end ; if f_heal then
102289: LD_VAR 0 23
102293: IFFALSE 102320
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102295: LD_ADDR_VAR 0 31
102299: PUSH
102300: LD_VAR 0 4
102304: PPUSH
102305: LD_INT 25
102307: PUSH
102308: LD_INT 4
102310: PUSH
102311: EMPTY
102312: LIST
102313: LIST
102314: PPUSH
102315: CALL_OW 72
102319: ST_TO_ADDR
// if f_repair then
102320: LD_VAR 0 22
102324: IFFALSE 102351
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102326: LD_ADDR_VAR 0 33
102330: PUSH
102331: LD_VAR 0 4
102335: PPUSH
102336: LD_INT 25
102338: PUSH
102339: LD_INT 3
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: PPUSH
102346: CALL_OW 72
102350: ST_TO_ADDR
// units_path := [ ] ;
102351: LD_ADDR_VAR 0 16
102355: PUSH
102356: EMPTY
102357: ST_TO_ADDR
// for i = 1 to group do
102358: LD_ADDR_VAR 0 7
102362: PUSH
102363: DOUBLE
102364: LD_INT 1
102366: DEC
102367: ST_TO_ADDR
102368: LD_VAR 0 4
102372: PUSH
102373: FOR_TO
102374: IFFALSE 102403
// units_path := Replace ( units_path , i , path ) ;
102376: LD_ADDR_VAR 0 16
102380: PUSH
102381: LD_VAR 0 16
102385: PPUSH
102386: LD_VAR 0 7
102390: PPUSH
102391: LD_VAR 0 5
102395: PPUSH
102396: CALL_OW 1
102400: ST_TO_ADDR
102401: GO 102373
102403: POP
102404: POP
// repeat for i = group downto 1 do
102405: LD_ADDR_VAR 0 7
102409: PUSH
102410: DOUBLE
102411: LD_VAR 0 4
102415: INC
102416: ST_TO_ADDR
102417: LD_INT 1
102419: PUSH
102420: FOR_DOWNTO
102421: IFFALSE 106543
// begin wait ( 5 ) ;
102423: LD_INT 5
102425: PPUSH
102426: CALL_OW 67
// tmp := [ ] ;
102430: LD_ADDR_VAR 0 14
102434: PUSH
102435: EMPTY
102436: ST_TO_ADDR
// attacking := false ;
102437: LD_ADDR_VAR 0 29
102441: PUSH
102442: LD_INT 0
102444: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102445: LD_VAR 0 4
102449: PUSH
102450: LD_VAR 0 7
102454: ARRAY
102455: PPUSH
102456: CALL_OW 301
102460: PUSH
102461: LD_VAR 0 4
102465: PUSH
102466: LD_VAR 0 7
102470: ARRAY
102471: NOT
102472: OR
102473: IFFALSE 102582
// begin if GetType ( group [ i ] ) = unit_human then
102475: LD_VAR 0 4
102479: PUSH
102480: LD_VAR 0 7
102484: ARRAY
102485: PPUSH
102486: CALL_OW 247
102490: PUSH
102491: LD_INT 1
102493: EQUAL
102494: IFFALSE 102540
// begin to_heal := to_heal diff group [ i ] ;
102496: LD_ADDR_VAR 0 30
102500: PUSH
102501: LD_VAR 0 30
102505: PUSH
102506: LD_VAR 0 4
102510: PUSH
102511: LD_VAR 0 7
102515: ARRAY
102516: DIFF
102517: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102518: LD_ADDR_VAR 0 31
102522: PUSH
102523: LD_VAR 0 31
102527: PUSH
102528: LD_VAR 0 4
102532: PUSH
102533: LD_VAR 0 7
102537: ARRAY
102538: DIFF
102539: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102540: LD_ADDR_VAR 0 4
102544: PUSH
102545: LD_VAR 0 4
102549: PPUSH
102550: LD_VAR 0 7
102554: PPUSH
102555: CALL_OW 3
102559: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102560: LD_ADDR_VAR 0 16
102564: PUSH
102565: LD_VAR 0 16
102569: PPUSH
102570: LD_VAR 0 7
102574: PPUSH
102575: CALL_OW 3
102579: ST_TO_ADDR
// continue ;
102580: GO 102420
// end ; if f_repair then
102582: LD_VAR 0 22
102586: IFFALSE 103075
// begin if GetType ( group [ i ] ) = unit_vehicle then
102588: LD_VAR 0 4
102592: PUSH
102593: LD_VAR 0 7
102597: ARRAY
102598: PPUSH
102599: CALL_OW 247
102603: PUSH
102604: LD_INT 2
102606: EQUAL
102607: IFFALSE 102797
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102609: LD_VAR 0 4
102613: PUSH
102614: LD_VAR 0 7
102618: ARRAY
102619: PPUSH
102620: CALL_OW 256
102624: PUSH
102625: LD_INT 700
102627: LESS
102628: PUSH
102629: LD_VAR 0 4
102633: PUSH
102634: LD_VAR 0 7
102638: ARRAY
102639: PUSH
102640: LD_VAR 0 32
102644: IN
102645: NOT
102646: AND
102647: IFFALSE 102671
// to_repair := to_repair union group [ i ] ;
102649: LD_ADDR_VAR 0 32
102653: PUSH
102654: LD_VAR 0 32
102658: PUSH
102659: LD_VAR 0 4
102663: PUSH
102664: LD_VAR 0 7
102668: ARRAY
102669: UNION
102670: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102671: LD_VAR 0 4
102675: PUSH
102676: LD_VAR 0 7
102680: ARRAY
102681: PPUSH
102682: CALL_OW 256
102686: PUSH
102687: LD_INT 1000
102689: EQUAL
102690: PUSH
102691: LD_VAR 0 4
102695: PUSH
102696: LD_VAR 0 7
102700: ARRAY
102701: PUSH
102702: LD_VAR 0 32
102706: IN
102707: AND
102708: IFFALSE 102732
// to_repair := to_repair diff group [ i ] ;
102710: LD_ADDR_VAR 0 32
102714: PUSH
102715: LD_VAR 0 32
102719: PUSH
102720: LD_VAR 0 4
102724: PUSH
102725: LD_VAR 0 7
102729: ARRAY
102730: DIFF
102731: ST_TO_ADDR
// if group [ i ] in to_repair then
102732: LD_VAR 0 4
102736: PUSH
102737: LD_VAR 0 7
102741: ARRAY
102742: PUSH
102743: LD_VAR 0 32
102747: IN
102748: IFFALSE 102795
// begin if not IsInArea ( group [ i ] , f_repair ) then
102750: LD_VAR 0 4
102754: PUSH
102755: LD_VAR 0 7
102759: ARRAY
102760: PPUSH
102761: LD_VAR 0 22
102765: PPUSH
102766: CALL_OW 308
102770: NOT
102771: IFFALSE 102793
// ComMoveToArea ( group [ i ] , f_repair ) ;
102773: LD_VAR 0 4
102777: PUSH
102778: LD_VAR 0 7
102782: ARRAY
102783: PPUSH
102784: LD_VAR 0 22
102788: PPUSH
102789: CALL_OW 113
// continue ;
102793: GO 102420
// end ; end else
102795: GO 103075
// if group [ i ] in repairs then
102797: LD_VAR 0 4
102801: PUSH
102802: LD_VAR 0 7
102806: ARRAY
102807: PUSH
102808: LD_VAR 0 33
102812: IN
102813: IFFALSE 103075
// begin if IsInUnit ( group [ i ] ) then
102815: LD_VAR 0 4
102819: PUSH
102820: LD_VAR 0 7
102824: ARRAY
102825: PPUSH
102826: CALL_OW 310
102830: IFFALSE 102898
// begin z := IsInUnit ( group [ i ] ) ;
102832: LD_ADDR_VAR 0 13
102836: PUSH
102837: LD_VAR 0 4
102841: PUSH
102842: LD_VAR 0 7
102846: ARRAY
102847: PPUSH
102848: CALL_OW 310
102852: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102853: LD_VAR 0 13
102857: PUSH
102858: LD_VAR 0 32
102862: IN
102863: PUSH
102864: LD_VAR 0 13
102868: PPUSH
102869: LD_VAR 0 22
102873: PPUSH
102874: CALL_OW 308
102878: AND
102879: IFFALSE 102896
// ComExitVehicle ( group [ i ] ) ;
102881: LD_VAR 0 4
102885: PUSH
102886: LD_VAR 0 7
102890: ARRAY
102891: PPUSH
102892: CALL_OW 121
// end else
102896: GO 103075
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102898: LD_ADDR_VAR 0 13
102902: PUSH
102903: LD_VAR 0 4
102907: PPUSH
102908: LD_INT 95
102910: PUSH
102911: LD_VAR 0 22
102915: PUSH
102916: EMPTY
102917: LIST
102918: LIST
102919: PUSH
102920: LD_INT 58
102922: PUSH
102923: EMPTY
102924: LIST
102925: PUSH
102926: EMPTY
102927: LIST
102928: LIST
102929: PPUSH
102930: CALL_OW 72
102934: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102935: LD_VAR 0 4
102939: PUSH
102940: LD_VAR 0 7
102944: ARRAY
102945: PPUSH
102946: CALL_OW 314
102950: NOT
102951: IFFALSE 103073
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102953: LD_ADDR_VAR 0 10
102957: PUSH
102958: LD_VAR 0 13
102962: PPUSH
102963: LD_VAR 0 4
102967: PUSH
102968: LD_VAR 0 7
102972: ARRAY
102973: PPUSH
102974: CALL_OW 74
102978: ST_TO_ADDR
// if not x then
102979: LD_VAR 0 10
102983: NOT
102984: IFFALSE 102988
// continue ;
102986: GO 102420
// if GetLives ( x ) < 1000 then
102988: LD_VAR 0 10
102992: PPUSH
102993: CALL_OW 256
102997: PUSH
102998: LD_INT 1000
103000: LESS
103001: IFFALSE 103025
// ComRepairVehicle ( group [ i ] , x ) else
103003: LD_VAR 0 4
103007: PUSH
103008: LD_VAR 0 7
103012: ARRAY
103013: PPUSH
103014: LD_VAR 0 10
103018: PPUSH
103019: CALL_OW 129
103023: GO 103073
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
103025: LD_VAR 0 23
103029: PUSH
103030: LD_VAR 0 4
103034: PUSH
103035: LD_VAR 0 7
103039: ARRAY
103040: PPUSH
103041: CALL_OW 256
103045: PUSH
103046: LD_INT 1000
103048: LESS
103049: AND
103050: NOT
103051: IFFALSE 103073
// ComEnterUnit ( group [ i ] , x ) ;
103053: LD_VAR 0 4
103057: PUSH
103058: LD_VAR 0 7
103062: ARRAY
103063: PPUSH
103064: LD_VAR 0 10
103068: PPUSH
103069: CALL_OW 120
// end ; continue ;
103073: GO 102420
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
103075: LD_VAR 0 23
103079: PUSH
103080: LD_VAR 0 4
103084: PUSH
103085: LD_VAR 0 7
103089: ARRAY
103090: PPUSH
103091: CALL_OW 247
103095: PUSH
103096: LD_INT 1
103098: EQUAL
103099: AND
103100: IFFALSE 103578
// begin if group [ i ] in healers then
103102: LD_VAR 0 4
103106: PUSH
103107: LD_VAR 0 7
103111: ARRAY
103112: PUSH
103113: LD_VAR 0 31
103117: IN
103118: IFFALSE 103391
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
103120: LD_VAR 0 4
103124: PUSH
103125: LD_VAR 0 7
103129: ARRAY
103130: PPUSH
103131: LD_VAR 0 23
103135: PPUSH
103136: CALL_OW 308
103140: NOT
103141: PUSH
103142: LD_VAR 0 4
103146: PUSH
103147: LD_VAR 0 7
103151: ARRAY
103152: PPUSH
103153: CALL_OW 314
103157: NOT
103158: AND
103159: IFFALSE 103183
// ComMoveToArea ( group [ i ] , f_heal ) else
103161: LD_VAR 0 4
103165: PUSH
103166: LD_VAR 0 7
103170: ARRAY
103171: PPUSH
103172: LD_VAR 0 23
103176: PPUSH
103177: CALL_OW 113
103181: GO 103389
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103183: LD_VAR 0 4
103187: PUSH
103188: LD_VAR 0 7
103192: ARRAY
103193: PPUSH
103194: CALL 80832 0 1
103198: PPUSH
103199: CALL_OW 256
103203: PUSH
103204: LD_INT 1000
103206: EQUAL
103207: IFFALSE 103226
// ComStop ( group [ i ] ) else
103209: LD_VAR 0 4
103213: PUSH
103214: LD_VAR 0 7
103218: ARRAY
103219: PPUSH
103220: CALL_OW 141
103224: GO 103389
// if not HasTask ( group [ i ] ) and to_heal then
103226: LD_VAR 0 4
103230: PUSH
103231: LD_VAR 0 7
103235: ARRAY
103236: PPUSH
103237: CALL_OW 314
103241: NOT
103242: PUSH
103243: LD_VAR 0 30
103247: AND
103248: IFFALSE 103389
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103250: LD_ADDR_VAR 0 13
103254: PUSH
103255: LD_VAR 0 30
103259: PPUSH
103260: LD_INT 3
103262: PUSH
103263: LD_INT 54
103265: PUSH
103266: EMPTY
103267: LIST
103268: PUSH
103269: EMPTY
103270: LIST
103271: LIST
103272: PPUSH
103273: CALL_OW 72
103277: PPUSH
103278: LD_VAR 0 4
103282: PUSH
103283: LD_VAR 0 7
103287: ARRAY
103288: PPUSH
103289: CALL_OW 74
103293: ST_TO_ADDR
// if z then
103294: LD_VAR 0 13
103298: IFFALSE 103389
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103300: LD_INT 91
103302: PUSH
103303: LD_VAR 0 13
103307: PUSH
103308: LD_INT 10
103310: PUSH
103311: EMPTY
103312: LIST
103313: LIST
103314: LIST
103315: PUSH
103316: LD_INT 81
103318: PUSH
103319: LD_VAR 0 13
103323: PPUSH
103324: CALL_OW 255
103328: PUSH
103329: EMPTY
103330: LIST
103331: LIST
103332: PUSH
103333: EMPTY
103334: LIST
103335: LIST
103336: PPUSH
103337: CALL_OW 69
103341: PUSH
103342: LD_INT 0
103344: EQUAL
103345: IFFALSE 103369
// ComHeal ( group [ i ] , z ) else
103347: LD_VAR 0 4
103351: PUSH
103352: LD_VAR 0 7
103356: ARRAY
103357: PPUSH
103358: LD_VAR 0 13
103362: PPUSH
103363: CALL_OW 128
103367: GO 103389
// ComMoveToArea ( group [ i ] , f_heal ) ;
103369: LD_VAR 0 4
103373: PUSH
103374: LD_VAR 0 7
103378: ARRAY
103379: PPUSH
103380: LD_VAR 0 23
103384: PPUSH
103385: CALL_OW 113
// end ; continue ;
103389: GO 102420
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103391: LD_VAR 0 4
103395: PUSH
103396: LD_VAR 0 7
103400: ARRAY
103401: PPUSH
103402: CALL_OW 256
103406: PUSH
103407: LD_INT 700
103409: LESS
103410: PUSH
103411: LD_VAR 0 4
103415: PUSH
103416: LD_VAR 0 7
103420: ARRAY
103421: PUSH
103422: LD_VAR 0 30
103426: IN
103427: NOT
103428: AND
103429: IFFALSE 103453
// to_heal := to_heal union group [ i ] ;
103431: LD_ADDR_VAR 0 30
103435: PUSH
103436: LD_VAR 0 30
103440: PUSH
103441: LD_VAR 0 4
103445: PUSH
103446: LD_VAR 0 7
103450: ARRAY
103451: UNION
103452: ST_TO_ADDR
// if group [ i ] in to_heal then
103453: LD_VAR 0 4
103457: PUSH
103458: LD_VAR 0 7
103462: ARRAY
103463: PUSH
103464: LD_VAR 0 30
103468: IN
103469: IFFALSE 103578
// begin if GetLives ( group [ i ] ) = 1000 then
103471: LD_VAR 0 4
103475: PUSH
103476: LD_VAR 0 7
103480: ARRAY
103481: PPUSH
103482: CALL_OW 256
103486: PUSH
103487: LD_INT 1000
103489: EQUAL
103490: IFFALSE 103516
// to_heal := to_heal diff group [ i ] else
103492: LD_ADDR_VAR 0 30
103496: PUSH
103497: LD_VAR 0 30
103501: PUSH
103502: LD_VAR 0 4
103506: PUSH
103507: LD_VAR 0 7
103511: ARRAY
103512: DIFF
103513: ST_TO_ADDR
103514: GO 103578
// begin if not IsInArea ( group [ i ] , to_heal ) then
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: LD_VAR 0 30
103531: PPUSH
103532: CALL_OW 308
103536: NOT
103537: IFFALSE 103561
// ComMoveToArea ( group [ i ] , f_heal ) else
103539: LD_VAR 0 4
103543: PUSH
103544: LD_VAR 0 7
103548: ARRAY
103549: PPUSH
103550: LD_VAR 0 23
103554: PPUSH
103555: CALL_OW 113
103559: GO 103576
// ComHold ( group [ i ] ) ;
103561: LD_VAR 0 4
103565: PUSH
103566: LD_VAR 0 7
103570: ARRAY
103571: PPUSH
103572: CALL_OW 140
// continue ;
103576: GO 102420
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103578: LD_VAR 0 4
103582: PUSH
103583: LD_VAR 0 7
103587: ARRAY
103588: PPUSH
103589: LD_INT 10
103591: PPUSH
103592: CALL 79252 0 2
103596: NOT
103597: PUSH
103598: LD_VAR 0 16
103602: PUSH
103603: LD_VAR 0 7
103607: ARRAY
103608: PUSH
103609: EMPTY
103610: EQUAL
103611: NOT
103612: AND
103613: IFFALSE 103879
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103615: LD_VAR 0 4
103619: PUSH
103620: LD_VAR 0 7
103624: ARRAY
103625: PPUSH
103626: CALL_OW 262
103630: PUSH
103631: LD_INT 1
103633: PUSH
103634: LD_INT 2
103636: PUSH
103637: EMPTY
103638: LIST
103639: LIST
103640: IN
103641: IFFALSE 103682
// if GetFuel ( group [ i ] ) < 10 then
103643: LD_VAR 0 4
103647: PUSH
103648: LD_VAR 0 7
103652: ARRAY
103653: PPUSH
103654: CALL_OW 261
103658: PUSH
103659: LD_INT 10
103661: LESS
103662: IFFALSE 103682
// SetFuel ( group [ i ] , 12 ) ;
103664: LD_VAR 0 4
103668: PUSH
103669: LD_VAR 0 7
103673: ARRAY
103674: PPUSH
103675: LD_INT 12
103677: PPUSH
103678: CALL_OW 240
// if units_path [ i ] then
103682: LD_VAR 0 16
103686: PUSH
103687: LD_VAR 0 7
103691: ARRAY
103692: IFFALSE 103877
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103694: LD_VAR 0 4
103698: PUSH
103699: LD_VAR 0 7
103703: ARRAY
103704: PPUSH
103705: LD_VAR 0 16
103709: PUSH
103710: LD_VAR 0 7
103714: ARRAY
103715: PUSH
103716: LD_INT 1
103718: ARRAY
103719: PUSH
103720: LD_INT 1
103722: ARRAY
103723: PPUSH
103724: LD_VAR 0 16
103728: PUSH
103729: LD_VAR 0 7
103733: ARRAY
103734: PUSH
103735: LD_INT 1
103737: ARRAY
103738: PUSH
103739: LD_INT 2
103741: ARRAY
103742: PPUSH
103743: CALL_OW 297
103747: PUSH
103748: LD_INT 6
103750: GREATER
103751: IFFALSE 103826
// begin if not HasTask ( group [ i ] ) then
103753: LD_VAR 0 4
103757: PUSH
103758: LD_VAR 0 7
103762: ARRAY
103763: PPUSH
103764: CALL_OW 314
103768: NOT
103769: IFFALSE 103824
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103771: LD_VAR 0 4
103775: PUSH
103776: LD_VAR 0 7
103780: ARRAY
103781: PPUSH
103782: LD_VAR 0 16
103786: PUSH
103787: LD_VAR 0 7
103791: ARRAY
103792: PUSH
103793: LD_INT 1
103795: ARRAY
103796: PUSH
103797: LD_INT 1
103799: ARRAY
103800: PPUSH
103801: LD_VAR 0 16
103805: PUSH
103806: LD_VAR 0 7
103810: ARRAY
103811: PUSH
103812: LD_INT 1
103814: ARRAY
103815: PUSH
103816: LD_INT 2
103818: ARRAY
103819: PPUSH
103820: CALL_OW 114
// end else
103824: GO 103877
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103826: LD_ADDR_VAR 0 15
103830: PUSH
103831: LD_VAR 0 16
103835: PUSH
103836: LD_VAR 0 7
103840: ARRAY
103841: PPUSH
103842: LD_INT 1
103844: PPUSH
103845: CALL_OW 3
103849: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103850: LD_ADDR_VAR 0 16
103854: PUSH
103855: LD_VAR 0 16
103859: PPUSH
103860: LD_VAR 0 7
103864: PPUSH
103865: LD_VAR 0 15
103869: PPUSH
103870: CALL_OW 1
103874: ST_TO_ADDR
// continue ;
103875: GO 102420
// end ; end ; end else
103877: GO 106541
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103879: LD_ADDR_VAR 0 14
103883: PUSH
103884: LD_INT 81
103886: PUSH
103887: LD_VAR 0 4
103891: PUSH
103892: LD_VAR 0 7
103896: ARRAY
103897: PPUSH
103898: CALL_OW 255
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PPUSH
103907: CALL_OW 69
103911: ST_TO_ADDR
// if not tmp then
103912: LD_VAR 0 14
103916: NOT
103917: IFFALSE 103921
// continue ;
103919: GO 102420
// if f_ignore_area then
103921: LD_VAR 0 17
103925: IFFALSE 104013
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103927: LD_ADDR_VAR 0 15
103931: PUSH
103932: LD_VAR 0 14
103936: PPUSH
103937: LD_INT 3
103939: PUSH
103940: LD_INT 92
103942: PUSH
103943: LD_VAR 0 17
103947: PUSH
103948: LD_INT 1
103950: ARRAY
103951: PUSH
103952: LD_VAR 0 17
103956: PUSH
103957: LD_INT 2
103959: ARRAY
103960: PUSH
103961: LD_VAR 0 17
103965: PUSH
103966: LD_INT 3
103968: ARRAY
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: LIST
103974: LIST
103975: PUSH
103976: EMPTY
103977: LIST
103978: LIST
103979: PPUSH
103980: CALL_OW 72
103984: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103985: LD_VAR 0 14
103989: PUSH
103990: LD_VAR 0 15
103994: DIFF
103995: IFFALSE 104013
// tmp := tmp diff tmp2 ;
103997: LD_ADDR_VAR 0 14
104001: PUSH
104002: LD_VAR 0 14
104006: PUSH
104007: LD_VAR 0 15
104011: DIFF
104012: ST_TO_ADDR
// end ; if not f_murder then
104013: LD_VAR 0 20
104017: NOT
104018: IFFALSE 104076
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
104020: LD_ADDR_VAR 0 15
104024: PUSH
104025: LD_VAR 0 14
104029: PPUSH
104030: LD_INT 3
104032: PUSH
104033: LD_INT 50
104035: PUSH
104036: EMPTY
104037: LIST
104038: PUSH
104039: EMPTY
104040: LIST
104041: LIST
104042: PPUSH
104043: CALL_OW 72
104047: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104048: LD_VAR 0 14
104052: PUSH
104053: LD_VAR 0 15
104057: DIFF
104058: IFFALSE 104076
// tmp := tmp diff tmp2 ;
104060: LD_ADDR_VAR 0 14
104064: PUSH
104065: LD_VAR 0 14
104069: PUSH
104070: LD_VAR 0 15
104074: DIFF
104075: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
104076: LD_ADDR_VAR 0 14
104080: PUSH
104081: LD_VAR 0 4
104085: PUSH
104086: LD_VAR 0 7
104090: ARRAY
104091: PPUSH
104092: LD_VAR 0 14
104096: PPUSH
104097: LD_INT 1
104099: PPUSH
104100: LD_INT 1
104102: PPUSH
104103: CALL 52895 0 4
104107: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
104108: LD_VAR 0 4
104112: PUSH
104113: LD_VAR 0 7
104117: ARRAY
104118: PPUSH
104119: CALL_OW 257
104123: PUSH
104124: LD_INT 1
104126: EQUAL
104127: IFFALSE 104575
// begin if WantPlant ( group [ i ] ) then
104129: LD_VAR 0 4
104133: PUSH
104134: LD_VAR 0 7
104138: ARRAY
104139: PPUSH
104140: CALL 52396 0 1
104144: IFFALSE 104148
// continue ;
104146: GO 102420
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104148: LD_VAR 0 18
104152: PUSH
104153: LD_VAR 0 4
104157: PUSH
104158: LD_VAR 0 7
104162: ARRAY
104163: PPUSH
104164: CALL_OW 310
104168: NOT
104169: AND
104170: PUSH
104171: LD_VAR 0 14
104175: PUSH
104176: LD_INT 1
104178: ARRAY
104179: PUSH
104180: LD_VAR 0 14
104184: PPUSH
104185: LD_INT 21
104187: PUSH
104188: LD_INT 2
104190: PUSH
104191: EMPTY
104192: LIST
104193: LIST
104194: PUSH
104195: LD_INT 58
104197: PUSH
104198: EMPTY
104199: LIST
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PPUSH
104205: CALL_OW 72
104209: IN
104210: AND
104211: IFFALSE 104247
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104213: LD_VAR 0 4
104217: PUSH
104218: LD_VAR 0 7
104222: ARRAY
104223: PPUSH
104224: LD_VAR 0 14
104228: PUSH
104229: LD_INT 1
104231: ARRAY
104232: PPUSH
104233: CALL_OW 120
// attacking := true ;
104237: LD_ADDR_VAR 0 29
104241: PUSH
104242: LD_INT 1
104244: ST_TO_ADDR
// continue ;
104245: GO 102420
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104247: LD_VAR 0 26
104251: PUSH
104252: LD_VAR 0 4
104256: PUSH
104257: LD_VAR 0 7
104261: ARRAY
104262: PPUSH
104263: CALL_OW 257
104267: PUSH
104268: LD_INT 1
104270: EQUAL
104271: AND
104272: PUSH
104273: LD_VAR 0 4
104277: PUSH
104278: LD_VAR 0 7
104282: ARRAY
104283: PPUSH
104284: CALL_OW 256
104288: PUSH
104289: LD_INT 800
104291: LESS
104292: AND
104293: PUSH
104294: LD_VAR 0 4
104298: PUSH
104299: LD_VAR 0 7
104303: ARRAY
104304: PPUSH
104305: CALL_OW 318
104309: NOT
104310: AND
104311: IFFALSE 104328
// ComCrawl ( group [ i ] ) ;
104313: LD_VAR 0 4
104317: PUSH
104318: LD_VAR 0 7
104322: ARRAY
104323: PPUSH
104324: CALL_OW 137
// if f_mines then
104328: LD_VAR 0 21
104332: IFFALSE 104575
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104334: LD_VAR 0 14
104338: PUSH
104339: LD_INT 1
104341: ARRAY
104342: PPUSH
104343: CALL_OW 247
104347: PUSH
104348: LD_INT 3
104350: EQUAL
104351: PUSH
104352: LD_VAR 0 14
104356: PUSH
104357: LD_INT 1
104359: ARRAY
104360: PUSH
104361: LD_VAR 0 27
104365: IN
104366: NOT
104367: AND
104368: IFFALSE 104575
// begin x := GetX ( tmp [ 1 ] ) ;
104370: LD_ADDR_VAR 0 10
104374: PUSH
104375: LD_VAR 0 14
104379: PUSH
104380: LD_INT 1
104382: ARRAY
104383: PPUSH
104384: CALL_OW 250
104388: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104389: LD_ADDR_VAR 0 11
104393: PUSH
104394: LD_VAR 0 14
104398: PUSH
104399: LD_INT 1
104401: ARRAY
104402: PPUSH
104403: CALL_OW 251
104407: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104408: LD_ADDR_VAR 0 12
104412: PUSH
104413: LD_VAR 0 4
104417: PUSH
104418: LD_VAR 0 7
104422: ARRAY
104423: PPUSH
104424: CALL 79337 0 1
104428: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104429: LD_VAR 0 4
104433: PUSH
104434: LD_VAR 0 7
104438: ARRAY
104439: PPUSH
104440: LD_VAR 0 10
104444: PPUSH
104445: LD_VAR 0 11
104449: PPUSH
104450: LD_VAR 0 14
104454: PUSH
104455: LD_INT 1
104457: ARRAY
104458: PPUSH
104459: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104463: LD_VAR 0 4
104467: PUSH
104468: LD_VAR 0 7
104472: ARRAY
104473: PPUSH
104474: LD_VAR 0 10
104478: PPUSH
104479: LD_VAR 0 12
104483: PPUSH
104484: LD_INT 7
104486: PPUSH
104487: CALL_OW 272
104491: PPUSH
104492: LD_VAR 0 11
104496: PPUSH
104497: LD_VAR 0 12
104501: PPUSH
104502: LD_INT 7
104504: PPUSH
104505: CALL_OW 273
104509: PPUSH
104510: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104514: LD_VAR 0 4
104518: PUSH
104519: LD_VAR 0 7
104523: ARRAY
104524: PPUSH
104525: LD_INT 71
104527: PPUSH
104528: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104532: LD_ADDR_VAR 0 27
104536: PUSH
104537: LD_VAR 0 27
104541: PPUSH
104542: LD_VAR 0 27
104546: PUSH
104547: LD_INT 1
104549: PLUS
104550: PPUSH
104551: LD_VAR 0 14
104555: PUSH
104556: LD_INT 1
104558: ARRAY
104559: PPUSH
104560: CALL_OW 1
104564: ST_TO_ADDR
// attacking := true ;
104565: LD_ADDR_VAR 0 29
104569: PUSH
104570: LD_INT 1
104572: ST_TO_ADDR
// continue ;
104573: GO 102420
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104575: LD_VAR 0 4
104579: PUSH
104580: LD_VAR 0 7
104584: ARRAY
104585: PPUSH
104586: CALL_OW 257
104590: PUSH
104591: LD_INT 17
104593: EQUAL
104594: PUSH
104595: LD_VAR 0 4
104599: PUSH
104600: LD_VAR 0 7
104604: ARRAY
104605: PPUSH
104606: CALL_OW 110
104610: PUSH
104611: LD_INT 71
104613: EQUAL
104614: NOT
104615: AND
104616: IFFALSE 104762
// begin attacking := false ;
104618: LD_ADDR_VAR 0 29
104622: PUSH
104623: LD_INT 0
104625: ST_TO_ADDR
// k := 5 ;
104626: LD_ADDR_VAR 0 9
104630: PUSH
104631: LD_INT 5
104633: ST_TO_ADDR
// if tmp < k then
104634: LD_VAR 0 14
104638: PUSH
104639: LD_VAR 0 9
104643: LESS
104644: IFFALSE 104656
// k := tmp ;
104646: LD_ADDR_VAR 0 9
104650: PUSH
104651: LD_VAR 0 14
104655: ST_TO_ADDR
// for j = 1 to k do
104656: LD_ADDR_VAR 0 8
104660: PUSH
104661: DOUBLE
104662: LD_INT 1
104664: DEC
104665: ST_TO_ADDR
104666: LD_VAR 0 9
104670: PUSH
104671: FOR_TO
104672: IFFALSE 104760
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104674: LD_VAR 0 14
104678: PUSH
104679: LD_VAR 0 8
104683: ARRAY
104684: PUSH
104685: LD_VAR 0 14
104689: PPUSH
104690: LD_INT 58
104692: PUSH
104693: EMPTY
104694: LIST
104695: PPUSH
104696: CALL_OW 72
104700: IN
104701: NOT
104702: IFFALSE 104758
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104704: LD_VAR 0 4
104708: PUSH
104709: LD_VAR 0 7
104713: ARRAY
104714: PPUSH
104715: LD_VAR 0 14
104719: PUSH
104720: LD_VAR 0 8
104724: ARRAY
104725: PPUSH
104726: CALL_OW 115
// attacking := true ;
104730: LD_ADDR_VAR 0 29
104734: PUSH
104735: LD_INT 1
104737: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104738: LD_VAR 0 4
104742: PUSH
104743: LD_VAR 0 7
104747: ARRAY
104748: PPUSH
104749: LD_INT 71
104751: PPUSH
104752: CALL_OW 109
// continue ;
104756: GO 104671
// end ; end ;
104758: GO 104671
104760: POP
104761: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104762: LD_VAR 0 4
104766: PUSH
104767: LD_VAR 0 7
104771: ARRAY
104772: PPUSH
104773: CALL_OW 257
104777: PUSH
104778: LD_INT 8
104780: EQUAL
104781: PUSH
104782: LD_VAR 0 4
104786: PUSH
104787: LD_VAR 0 7
104791: ARRAY
104792: PPUSH
104793: CALL_OW 264
104797: PUSH
104798: LD_INT 28
104800: PUSH
104801: LD_INT 45
104803: PUSH
104804: LD_INT 7
104806: PUSH
104807: LD_INT 47
104809: PUSH
104810: EMPTY
104811: LIST
104812: LIST
104813: LIST
104814: LIST
104815: IN
104816: OR
104817: IFFALSE 105073
// begin attacking := false ;
104819: LD_ADDR_VAR 0 29
104823: PUSH
104824: LD_INT 0
104826: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104827: LD_VAR 0 14
104831: PUSH
104832: LD_INT 1
104834: ARRAY
104835: PPUSH
104836: CALL_OW 266
104840: PUSH
104841: LD_INT 32
104843: PUSH
104844: LD_INT 31
104846: PUSH
104847: LD_INT 33
104849: PUSH
104850: LD_INT 4
104852: PUSH
104853: LD_INT 5
104855: PUSH
104856: EMPTY
104857: LIST
104858: LIST
104859: LIST
104860: LIST
104861: LIST
104862: IN
104863: IFFALSE 105049
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104865: LD_ADDR_VAR 0 9
104869: PUSH
104870: LD_VAR 0 14
104874: PUSH
104875: LD_INT 1
104877: ARRAY
104878: PPUSH
104879: CALL_OW 266
104883: PPUSH
104884: LD_VAR 0 14
104888: PUSH
104889: LD_INT 1
104891: ARRAY
104892: PPUSH
104893: CALL_OW 250
104897: PPUSH
104898: LD_VAR 0 14
104902: PUSH
104903: LD_INT 1
104905: ARRAY
104906: PPUSH
104907: CALL_OW 251
104911: PPUSH
104912: LD_VAR 0 14
104916: PUSH
104917: LD_INT 1
104919: ARRAY
104920: PPUSH
104921: CALL_OW 254
104925: PPUSH
104926: LD_VAR 0 14
104930: PUSH
104931: LD_INT 1
104933: ARRAY
104934: PPUSH
104935: CALL_OW 248
104939: PPUSH
104940: LD_INT 0
104942: PPUSH
104943: CALL 60707 0 6
104947: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104948: LD_ADDR_VAR 0 8
104952: PUSH
104953: LD_VAR 0 4
104957: PUSH
104958: LD_VAR 0 7
104962: ARRAY
104963: PPUSH
104964: LD_VAR 0 9
104968: PPUSH
104969: CALL 79377 0 2
104973: ST_TO_ADDR
// if j then
104974: LD_VAR 0 8
104978: IFFALSE 105047
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104980: LD_VAR 0 8
104984: PUSH
104985: LD_INT 1
104987: ARRAY
104988: PPUSH
104989: LD_VAR 0 8
104993: PUSH
104994: LD_INT 2
104996: ARRAY
104997: PPUSH
104998: CALL_OW 488
105002: IFFALSE 105047
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
105004: LD_VAR 0 4
105008: PUSH
105009: LD_VAR 0 7
105013: ARRAY
105014: PPUSH
105015: LD_VAR 0 8
105019: PUSH
105020: LD_INT 1
105022: ARRAY
105023: PPUSH
105024: LD_VAR 0 8
105028: PUSH
105029: LD_INT 2
105031: ARRAY
105032: PPUSH
105033: CALL_OW 116
// attacking := true ;
105037: LD_ADDR_VAR 0 29
105041: PUSH
105042: LD_INT 1
105044: ST_TO_ADDR
// continue ;
105045: GO 102420
// end ; end else
105047: GO 105073
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105049: LD_VAR 0 4
105053: PUSH
105054: LD_VAR 0 7
105058: ARRAY
105059: PPUSH
105060: LD_VAR 0 14
105064: PUSH
105065: LD_INT 1
105067: ARRAY
105068: PPUSH
105069: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
105073: LD_VAR 0 4
105077: PUSH
105078: LD_VAR 0 7
105082: ARRAY
105083: PPUSH
105084: CALL_OW 265
105088: PUSH
105089: LD_INT 11
105091: EQUAL
105092: IFFALSE 105370
// begin k := 10 ;
105094: LD_ADDR_VAR 0 9
105098: PUSH
105099: LD_INT 10
105101: ST_TO_ADDR
// x := 0 ;
105102: LD_ADDR_VAR 0 10
105106: PUSH
105107: LD_INT 0
105109: ST_TO_ADDR
// if tmp < k then
105110: LD_VAR 0 14
105114: PUSH
105115: LD_VAR 0 9
105119: LESS
105120: IFFALSE 105132
// k := tmp ;
105122: LD_ADDR_VAR 0 9
105126: PUSH
105127: LD_VAR 0 14
105131: ST_TO_ADDR
// for j = k downto 1 do
105132: LD_ADDR_VAR 0 8
105136: PUSH
105137: DOUBLE
105138: LD_VAR 0 9
105142: INC
105143: ST_TO_ADDR
105144: LD_INT 1
105146: PUSH
105147: FOR_DOWNTO
105148: IFFALSE 105223
// begin if GetType ( tmp [ j ] ) = unit_human then
105150: LD_VAR 0 14
105154: PUSH
105155: LD_VAR 0 8
105159: ARRAY
105160: PPUSH
105161: CALL_OW 247
105165: PUSH
105166: LD_INT 1
105168: EQUAL
105169: IFFALSE 105221
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105171: LD_VAR 0 4
105175: PUSH
105176: LD_VAR 0 7
105180: ARRAY
105181: PPUSH
105182: LD_VAR 0 14
105186: PUSH
105187: LD_VAR 0 8
105191: ARRAY
105192: PPUSH
105193: CALL 79648 0 2
// x := tmp [ j ] ;
105197: LD_ADDR_VAR 0 10
105201: PUSH
105202: LD_VAR 0 14
105206: PUSH
105207: LD_VAR 0 8
105211: ARRAY
105212: ST_TO_ADDR
// attacking := true ;
105213: LD_ADDR_VAR 0 29
105217: PUSH
105218: LD_INT 1
105220: ST_TO_ADDR
// end ; end ;
105221: GO 105147
105223: POP
105224: POP
// if not x then
105225: LD_VAR 0 10
105229: NOT
105230: IFFALSE 105370
// begin attacking := true ;
105232: LD_ADDR_VAR 0 29
105236: PUSH
105237: LD_INT 1
105239: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105240: LD_VAR 0 4
105244: PUSH
105245: LD_VAR 0 7
105249: ARRAY
105250: PPUSH
105251: CALL_OW 250
105255: PPUSH
105256: LD_VAR 0 4
105260: PUSH
105261: LD_VAR 0 7
105265: ARRAY
105266: PPUSH
105267: CALL_OW 251
105271: PPUSH
105272: CALL_OW 546
105276: PUSH
105277: LD_INT 2
105279: ARRAY
105280: PUSH
105281: LD_VAR 0 14
105285: PUSH
105286: LD_INT 1
105288: ARRAY
105289: PPUSH
105290: CALL_OW 250
105294: PPUSH
105295: LD_VAR 0 14
105299: PUSH
105300: LD_INT 1
105302: ARRAY
105303: PPUSH
105304: CALL_OW 251
105308: PPUSH
105309: CALL_OW 546
105313: PUSH
105314: LD_INT 2
105316: ARRAY
105317: EQUAL
105318: IFFALSE 105346
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105320: LD_VAR 0 4
105324: PUSH
105325: LD_VAR 0 7
105329: ARRAY
105330: PPUSH
105331: LD_VAR 0 14
105335: PUSH
105336: LD_INT 1
105338: ARRAY
105339: PPUSH
105340: CALL 79648 0 2
105344: GO 105370
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105346: LD_VAR 0 4
105350: PUSH
105351: LD_VAR 0 7
105355: ARRAY
105356: PPUSH
105357: LD_VAR 0 14
105361: PUSH
105362: LD_INT 1
105364: ARRAY
105365: PPUSH
105366: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105370: LD_VAR 0 4
105374: PUSH
105375: LD_VAR 0 7
105379: ARRAY
105380: PPUSH
105381: CALL_OW 264
105385: PUSH
105386: LD_INT 29
105388: EQUAL
105389: IFFALSE 105755
// begin if WantsToAttack ( group [ i ] ) in bombed then
105391: LD_VAR 0 4
105395: PUSH
105396: LD_VAR 0 7
105400: ARRAY
105401: PPUSH
105402: CALL_OW 319
105406: PUSH
105407: LD_VAR 0 28
105411: IN
105412: IFFALSE 105416
// continue ;
105414: GO 102420
// k := 8 ;
105416: LD_ADDR_VAR 0 9
105420: PUSH
105421: LD_INT 8
105423: ST_TO_ADDR
// x := 0 ;
105424: LD_ADDR_VAR 0 10
105428: PUSH
105429: LD_INT 0
105431: ST_TO_ADDR
// if tmp < k then
105432: LD_VAR 0 14
105436: PUSH
105437: LD_VAR 0 9
105441: LESS
105442: IFFALSE 105454
// k := tmp ;
105444: LD_ADDR_VAR 0 9
105448: PUSH
105449: LD_VAR 0 14
105453: ST_TO_ADDR
// for j = 1 to k do
105454: LD_ADDR_VAR 0 8
105458: PUSH
105459: DOUBLE
105460: LD_INT 1
105462: DEC
105463: ST_TO_ADDR
105464: LD_VAR 0 9
105468: PUSH
105469: FOR_TO
105470: IFFALSE 105602
// begin if GetType ( tmp [ j ] ) = unit_building then
105472: LD_VAR 0 14
105476: PUSH
105477: LD_VAR 0 8
105481: ARRAY
105482: PPUSH
105483: CALL_OW 247
105487: PUSH
105488: LD_INT 3
105490: EQUAL
105491: IFFALSE 105600
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105493: LD_VAR 0 14
105497: PUSH
105498: LD_VAR 0 8
105502: ARRAY
105503: PUSH
105504: LD_VAR 0 28
105508: IN
105509: NOT
105510: PUSH
105511: LD_VAR 0 14
105515: PUSH
105516: LD_VAR 0 8
105520: ARRAY
105521: PPUSH
105522: CALL_OW 313
105526: AND
105527: IFFALSE 105600
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105529: LD_VAR 0 4
105533: PUSH
105534: LD_VAR 0 7
105538: ARRAY
105539: PPUSH
105540: LD_VAR 0 14
105544: PUSH
105545: LD_VAR 0 8
105549: ARRAY
105550: PPUSH
105551: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105555: LD_ADDR_VAR 0 28
105559: PUSH
105560: LD_VAR 0 28
105564: PPUSH
105565: LD_VAR 0 28
105569: PUSH
105570: LD_INT 1
105572: PLUS
105573: PPUSH
105574: LD_VAR 0 14
105578: PUSH
105579: LD_VAR 0 8
105583: ARRAY
105584: PPUSH
105585: CALL_OW 1
105589: ST_TO_ADDR
// attacking := true ;
105590: LD_ADDR_VAR 0 29
105594: PUSH
105595: LD_INT 1
105597: ST_TO_ADDR
// break ;
105598: GO 105602
// end ; end ;
105600: GO 105469
105602: POP
105603: POP
// if not attacking and f_attack_depot then
105604: LD_VAR 0 29
105608: NOT
105609: PUSH
105610: LD_VAR 0 25
105614: AND
105615: IFFALSE 105710
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105617: LD_ADDR_VAR 0 13
105621: PUSH
105622: LD_VAR 0 14
105626: PPUSH
105627: LD_INT 2
105629: PUSH
105630: LD_INT 30
105632: PUSH
105633: LD_INT 0
105635: PUSH
105636: EMPTY
105637: LIST
105638: LIST
105639: PUSH
105640: LD_INT 30
105642: PUSH
105643: LD_INT 1
105645: PUSH
105646: EMPTY
105647: LIST
105648: LIST
105649: PUSH
105650: EMPTY
105651: LIST
105652: LIST
105653: LIST
105654: PPUSH
105655: CALL_OW 72
105659: ST_TO_ADDR
// if z then
105660: LD_VAR 0 13
105664: IFFALSE 105710
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105666: LD_VAR 0 4
105670: PUSH
105671: LD_VAR 0 7
105675: ARRAY
105676: PPUSH
105677: LD_VAR 0 13
105681: PPUSH
105682: LD_VAR 0 4
105686: PUSH
105687: LD_VAR 0 7
105691: ARRAY
105692: PPUSH
105693: CALL_OW 74
105697: PPUSH
105698: CALL_OW 115
// attacking := true ;
105702: LD_ADDR_VAR 0 29
105706: PUSH
105707: LD_INT 1
105709: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105710: LD_VAR 0 4
105714: PUSH
105715: LD_VAR 0 7
105719: ARRAY
105720: PPUSH
105721: CALL_OW 256
105725: PUSH
105726: LD_INT 500
105728: LESS
105729: IFFALSE 105755
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105731: LD_VAR 0 4
105735: PUSH
105736: LD_VAR 0 7
105740: ARRAY
105741: PPUSH
105742: LD_VAR 0 14
105746: PUSH
105747: LD_INT 1
105749: ARRAY
105750: PPUSH
105751: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105755: LD_VAR 0 4
105759: PUSH
105760: LD_VAR 0 7
105764: ARRAY
105765: PPUSH
105766: CALL_OW 264
105770: PUSH
105771: LD_INT 49
105773: EQUAL
105774: IFFALSE 105895
// begin if not HasTask ( group [ i ] ) then
105776: LD_VAR 0 4
105780: PUSH
105781: LD_VAR 0 7
105785: ARRAY
105786: PPUSH
105787: CALL_OW 314
105791: NOT
105792: IFFALSE 105895
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105794: LD_ADDR_VAR 0 9
105798: PUSH
105799: LD_INT 81
105801: PUSH
105802: LD_VAR 0 4
105806: PUSH
105807: LD_VAR 0 7
105811: ARRAY
105812: PPUSH
105813: CALL_OW 255
105817: PUSH
105818: EMPTY
105819: LIST
105820: LIST
105821: PPUSH
105822: CALL_OW 69
105826: PPUSH
105827: LD_VAR 0 4
105831: PUSH
105832: LD_VAR 0 7
105836: ARRAY
105837: PPUSH
105838: CALL_OW 74
105842: ST_TO_ADDR
// if k then
105843: LD_VAR 0 9
105847: IFFALSE 105895
// if GetDistUnits ( group [ i ] , k ) > 10 then
105849: LD_VAR 0 4
105853: PUSH
105854: LD_VAR 0 7
105858: ARRAY
105859: PPUSH
105860: LD_VAR 0 9
105864: PPUSH
105865: CALL_OW 296
105869: PUSH
105870: LD_INT 10
105872: GREATER
105873: IFFALSE 105895
// ComMoveUnit ( group [ i ] , k ) ;
105875: LD_VAR 0 4
105879: PUSH
105880: LD_VAR 0 7
105884: ARRAY
105885: PPUSH
105886: LD_VAR 0 9
105890: PPUSH
105891: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105895: LD_VAR 0 4
105899: PUSH
105900: LD_VAR 0 7
105904: ARRAY
105905: PPUSH
105906: CALL_OW 256
105910: PUSH
105911: LD_INT 250
105913: LESS
105914: PUSH
105915: LD_VAR 0 4
105919: PUSH
105920: LD_VAR 0 7
105924: ARRAY
105925: PUSH
105926: LD_INT 21
105928: PUSH
105929: LD_INT 2
105931: PUSH
105932: EMPTY
105933: LIST
105934: LIST
105935: PUSH
105936: LD_INT 23
105938: PUSH
105939: LD_INT 2
105941: PUSH
105942: EMPTY
105943: LIST
105944: LIST
105945: PUSH
105946: EMPTY
105947: LIST
105948: LIST
105949: PPUSH
105950: CALL_OW 69
105954: IN
105955: AND
105956: IFFALSE 106081
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105958: LD_ADDR_VAR 0 9
105962: PUSH
105963: LD_OWVAR 3
105967: PUSH
105968: LD_VAR 0 4
105972: PUSH
105973: LD_VAR 0 7
105977: ARRAY
105978: DIFF
105979: PPUSH
105980: LD_VAR 0 4
105984: PUSH
105985: LD_VAR 0 7
105989: ARRAY
105990: PPUSH
105991: CALL_OW 74
105995: ST_TO_ADDR
// if not k then
105996: LD_VAR 0 9
106000: NOT
106001: IFFALSE 106005
// continue ;
106003: GO 102420
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
106005: LD_VAR 0 9
106009: PUSH
106010: LD_INT 81
106012: PUSH
106013: LD_VAR 0 4
106017: PUSH
106018: LD_VAR 0 7
106022: ARRAY
106023: PPUSH
106024: CALL_OW 255
106028: PUSH
106029: EMPTY
106030: LIST
106031: LIST
106032: PPUSH
106033: CALL_OW 69
106037: IN
106038: PUSH
106039: LD_VAR 0 9
106043: PPUSH
106044: LD_VAR 0 4
106048: PUSH
106049: LD_VAR 0 7
106053: ARRAY
106054: PPUSH
106055: CALL_OW 296
106059: PUSH
106060: LD_INT 5
106062: LESS
106063: AND
106064: IFFALSE 106081
// ComAutodestruct ( group [ i ] ) ;
106066: LD_VAR 0 4
106070: PUSH
106071: LD_VAR 0 7
106075: ARRAY
106076: PPUSH
106077: CALL 79546 0 1
// end ; if f_attack_depot then
106081: LD_VAR 0 25
106085: IFFALSE 106197
// begin k := 6 ;
106087: LD_ADDR_VAR 0 9
106091: PUSH
106092: LD_INT 6
106094: ST_TO_ADDR
// if tmp < k then
106095: LD_VAR 0 14
106099: PUSH
106100: LD_VAR 0 9
106104: LESS
106105: IFFALSE 106117
// k := tmp ;
106107: LD_ADDR_VAR 0 9
106111: PUSH
106112: LD_VAR 0 14
106116: ST_TO_ADDR
// for j = 1 to k do
106117: LD_ADDR_VAR 0 8
106121: PUSH
106122: DOUBLE
106123: LD_INT 1
106125: DEC
106126: ST_TO_ADDR
106127: LD_VAR 0 9
106131: PUSH
106132: FOR_TO
106133: IFFALSE 106195
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
106135: LD_VAR 0 8
106139: PPUSH
106140: CALL_OW 266
106144: PUSH
106145: LD_INT 0
106147: PUSH
106148: LD_INT 1
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: IN
106155: IFFALSE 106193
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106157: LD_VAR 0 4
106161: PUSH
106162: LD_VAR 0 7
106166: ARRAY
106167: PPUSH
106168: LD_VAR 0 14
106172: PUSH
106173: LD_VAR 0 8
106177: ARRAY
106178: PPUSH
106179: CALL_OW 115
// attacking := true ;
106183: LD_ADDR_VAR 0 29
106187: PUSH
106188: LD_INT 1
106190: ST_TO_ADDR
// break ;
106191: GO 106195
// end ;
106193: GO 106132
106195: POP
106196: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106197: LD_VAR 0 4
106201: PUSH
106202: LD_VAR 0 7
106206: ARRAY
106207: PPUSH
106208: CALL_OW 302
106212: PUSH
106213: LD_VAR 0 29
106217: NOT
106218: AND
106219: IFFALSE 106541
// begin if GetTag ( group [ i ] ) = 71 then
106221: LD_VAR 0 4
106225: PUSH
106226: LD_VAR 0 7
106230: ARRAY
106231: PPUSH
106232: CALL_OW 110
106236: PUSH
106237: LD_INT 71
106239: EQUAL
106240: IFFALSE 106281
// begin if HasTask ( group [ i ] ) then
106242: LD_VAR 0 4
106246: PUSH
106247: LD_VAR 0 7
106251: ARRAY
106252: PPUSH
106253: CALL_OW 314
106257: IFFALSE 106263
// continue else
106259: GO 102420
106261: GO 106281
// SetTag ( group [ i ] , 0 ) ;
106263: LD_VAR 0 4
106267: PUSH
106268: LD_VAR 0 7
106272: ARRAY
106273: PPUSH
106274: LD_INT 0
106276: PPUSH
106277: CALL_OW 109
// end ; k := 8 ;
106281: LD_ADDR_VAR 0 9
106285: PUSH
106286: LD_INT 8
106288: ST_TO_ADDR
// x := 0 ;
106289: LD_ADDR_VAR 0 10
106293: PUSH
106294: LD_INT 0
106296: ST_TO_ADDR
// if tmp < k then
106297: LD_VAR 0 14
106301: PUSH
106302: LD_VAR 0 9
106306: LESS
106307: IFFALSE 106319
// k := tmp ;
106309: LD_ADDR_VAR 0 9
106313: PUSH
106314: LD_VAR 0 14
106318: ST_TO_ADDR
// for j = 1 to k do
106319: LD_ADDR_VAR 0 8
106323: PUSH
106324: DOUBLE
106325: LD_INT 1
106327: DEC
106328: ST_TO_ADDR
106329: LD_VAR 0 9
106333: PUSH
106334: FOR_TO
106335: IFFALSE 106433
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106337: LD_VAR 0 14
106341: PUSH
106342: LD_VAR 0 8
106346: ARRAY
106347: PPUSH
106348: CALL_OW 247
106352: PUSH
106353: LD_INT 1
106355: EQUAL
106356: PUSH
106357: LD_VAR 0 14
106361: PUSH
106362: LD_VAR 0 8
106366: ARRAY
106367: PPUSH
106368: CALL_OW 256
106372: PUSH
106373: LD_INT 250
106375: LESS
106376: PUSH
106377: LD_VAR 0 20
106381: AND
106382: PUSH
106383: LD_VAR 0 20
106387: NOT
106388: PUSH
106389: LD_VAR 0 14
106393: PUSH
106394: LD_VAR 0 8
106398: ARRAY
106399: PPUSH
106400: CALL_OW 256
106404: PUSH
106405: LD_INT 250
106407: GREATEREQUAL
106408: AND
106409: OR
106410: AND
106411: IFFALSE 106431
// begin x := tmp [ j ] ;
106413: LD_ADDR_VAR 0 10
106417: PUSH
106418: LD_VAR 0 14
106422: PUSH
106423: LD_VAR 0 8
106427: ARRAY
106428: ST_TO_ADDR
// break ;
106429: GO 106433
// end ;
106431: GO 106334
106433: POP
106434: POP
// if x then
106435: LD_VAR 0 10
106439: IFFALSE 106463
// ComAttackUnit ( group [ i ] , x ) else
106441: LD_VAR 0 4
106445: PUSH
106446: LD_VAR 0 7
106450: ARRAY
106451: PPUSH
106452: LD_VAR 0 10
106456: PPUSH
106457: CALL_OW 115
106461: GO 106487
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106463: LD_VAR 0 4
106467: PUSH
106468: LD_VAR 0 7
106472: ARRAY
106473: PPUSH
106474: LD_VAR 0 14
106478: PUSH
106479: LD_INT 1
106481: ARRAY
106482: PPUSH
106483: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106487: LD_VAR 0 4
106491: PUSH
106492: LD_VAR 0 7
106496: ARRAY
106497: PPUSH
106498: CALL_OW 314
106502: NOT
106503: IFFALSE 106541
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106505: LD_VAR 0 4
106509: PUSH
106510: LD_VAR 0 7
106514: ARRAY
106515: PPUSH
106516: LD_VAR 0 14
106520: PPUSH
106521: LD_VAR 0 4
106525: PUSH
106526: LD_VAR 0 7
106530: ARRAY
106531: PPUSH
106532: CALL_OW 74
106536: PPUSH
106537: CALL_OW 115
// end ; end ; end ;
106541: GO 102420
106543: POP
106544: POP
// wait ( 0 0$2 ) ;
106545: LD_INT 70
106547: PPUSH
106548: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106552: LD_VAR 0 4
106556: NOT
106557: PUSH
106558: LD_VAR 0 4
106562: PUSH
106563: EMPTY
106564: EQUAL
106565: OR
106566: PUSH
106567: LD_INT 81
106569: PUSH
106570: LD_VAR 0 35
106574: PUSH
106575: EMPTY
106576: LIST
106577: LIST
106578: PPUSH
106579: CALL_OW 69
106583: NOT
106584: OR
106585: IFFALSE 102405
// end ;
106587: LD_VAR 0 2
106591: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106592: LD_INT 0
106594: PPUSH
106595: PPUSH
106596: PPUSH
106597: PPUSH
106598: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106599: LD_VAR 0 1
106603: NOT
106604: PUSH
106605: LD_EXP 50
106609: PUSH
106610: LD_VAR 0 1
106614: ARRAY
106615: NOT
106616: OR
106617: PUSH
106618: LD_VAR 0 2
106622: NOT
106623: OR
106624: PUSH
106625: LD_VAR 0 3
106629: NOT
106630: OR
106631: IFFALSE 106635
// exit ;
106633: GO 107148
// side := mc_sides [ base ] ;
106635: LD_ADDR_VAR 0 6
106639: PUSH
106640: LD_EXP 76
106644: PUSH
106645: LD_VAR 0 1
106649: ARRAY
106650: ST_TO_ADDR
// if not side then
106651: LD_VAR 0 6
106655: NOT
106656: IFFALSE 106660
// exit ;
106658: GO 107148
// for i in solds do
106660: LD_ADDR_VAR 0 7
106664: PUSH
106665: LD_VAR 0 2
106669: PUSH
106670: FOR_IN
106671: IFFALSE 106732
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106673: LD_VAR 0 7
106677: PPUSH
106678: CALL_OW 310
106682: PPUSH
106683: CALL_OW 266
106687: PUSH
106688: LD_INT 32
106690: PUSH
106691: LD_INT 31
106693: PUSH
106694: EMPTY
106695: LIST
106696: LIST
106697: IN
106698: IFFALSE 106718
// solds := solds diff i else
106700: LD_ADDR_VAR 0 2
106704: PUSH
106705: LD_VAR 0 2
106709: PUSH
106710: LD_VAR 0 7
106714: DIFF
106715: ST_TO_ADDR
106716: GO 106730
// SetTag ( i , 18 ) ;
106718: LD_VAR 0 7
106722: PPUSH
106723: LD_INT 18
106725: PPUSH
106726: CALL_OW 109
106730: GO 106670
106732: POP
106733: POP
// if not solds then
106734: LD_VAR 0 2
106738: NOT
106739: IFFALSE 106743
// exit ;
106741: GO 107148
// repeat wait ( 0 0$1 ) ;
106743: LD_INT 35
106745: PPUSH
106746: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
106750: LD_ADDR_VAR 0 5
106754: PUSH
106755: LD_VAR 0 6
106759: PPUSH
106760: LD_VAR 0 3
106764: PPUSH
106765: CALL 49261 0 2
106769: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106770: LD_EXP 50
106774: PUSH
106775: LD_VAR 0 1
106779: ARRAY
106780: NOT
106781: PUSH
106782: LD_EXP 50
106786: PUSH
106787: LD_VAR 0 1
106791: ARRAY
106792: PUSH
106793: EMPTY
106794: EQUAL
106795: OR
106796: IFFALSE 106833
// begin for i in solds do
106798: LD_ADDR_VAR 0 7
106802: PUSH
106803: LD_VAR 0 2
106807: PUSH
106808: FOR_IN
106809: IFFALSE 106822
// ComStop ( i ) ;
106811: LD_VAR 0 7
106815: PPUSH
106816: CALL_OW 141
106820: GO 106808
106822: POP
106823: POP
// solds := [ ] ;
106824: LD_ADDR_VAR 0 2
106828: PUSH
106829: EMPTY
106830: ST_TO_ADDR
// exit ;
106831: GO 107148
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
106833: LD_VAR 0 5
106837: NOT
106838: PUSH
106839: LD_VAR 0 5
106843: PUSH
106844: LD_INT 3
106846: GREATER
106847: OR
106848: PUSH
106849: LD_EXP 72
106853: PUSH
106854: LD_VAR 0 1
106858: ARRAY
106859: OR
106860: IFFALSE 106901
// begin for i in solds do
106862: LD_ADDR_VAR 0 7
106866: PUSH
106867: LD_VAR 0 2
106871: PUSH
106872: FOR_IN
106873: IFFALSE 106897
// if HasTask ( i ) then
106875: LD_VAR 0 7
106879: PPUSH
106880: CALL_OW 314
106884: IFFALSE 106895
// ComStop ( i ) ;
106886: LD_VAR 0 7
106890: PPUSH
106891: CALL_OW 141
106895: GO 106872
106897: POP
106898: POP
// break ;
106899: GO 107136
// end ; for i in solds do
106901: LD_ADDR_VAR 0 7
106905: PUSH
106906: LD_VAR 0 2
106910: PUSH
106911: FOR_IN
106912: IFFALSE 107128
// begin if IsInUnit ( i ) then
106914: LD_VAR 0 7
106918: PPUSH
106919: CALL_OW 310
106923: IFFALSE 106934
// ComExitBuilding ( i ) ;
106925: LD_VAR 0 7
106929: PPUSH
106930: CALL_OW 122
// if GetLives ( i ) > 333 then
106934: LD_VAR 0 7
106938: PPUSH
106939: CALL_OW 256
106943: PUSH
106944: LD_INT 333
106946: GREATER
106947: IFFALSE 106975
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106949: LD_VAR 0 7
106953: PPUSH
106954: LD_VAR 0 5
106958: PPUSH
106959: LD_VAR 0 7
106963: PPUSH
106964: CALL_OW 74
106968: PPUSH
106969: CALL_OW 115
106973: GO 107126
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106975: LD_ADDR_VAR 0 8
106979: PUSH
106980: LD_EXP 50
106984: PUSH
106985: LD_VAR 0 1
106989: ARRAY
106990: PPUSH
106991: LD_INT 2
106993: PUSH
106994: LD_INT 30
106996: PUSH
106997: LD_INT 0
106999: PUSH
107000: EMPTY
107001: LIST
107002: LIST
107003: PUSH
107004: LD_INT 30
107006: PUSH
107007: LD_INT 1
107009: PUSH
107010: EMPTY
107011: LIST
107012: LIST
107013: PUSH
107014: LD_INT 30
107016: PUSH
107017: LD_INT 6
107019: PUSH
107020: EMPTY
107021: LIST
107022: LIST
107023: PUSH
107024: EMPTY
107025: LIST
107026: LIST
107027: LIST
107028: LIST
107029: PPUSH
107030: CALL_OW 72
107034: PPUSH
107035: LD_VAR 0 7
107039: PPUSH
107040: CALL_OW 74
107044: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
107045: LD_VAR 0 7
107049: PPUSH
107050: LD_VAR 0 8
107054: PPUSH
107055: CALL_OW 250
107059: PPUSH
107060: LD_INT 3
107062: PPUSH
107063: LD_INT 5
107065: PPUSH
107066: CALL_OW 272
107070: PPUSH
107071: LD_VAR 0 8
107075: PPUSH
107076: CALL_OW 251
107080: PPUSH
107081: LD_INT 3
107083: PPUSH
107084: LD_INT 5
107086: PPUSH
107087: CALL_OW 273
107091: PPUSH
107092: CALL_OW 111
// SetTag ( i , 0 ) ;
107096: LD_VAR 0 7
107100: PPUSH
107101: LD_INT 0
107103: PPUSH
107104: CALL_OW 109
// solds := solds diff i ;
107108: LD_ADDR_VAR 0 2
107112: PUSH
107113: LD_VAR 0 2
107117: PUSH
107118: LD_VAR 0 7
107122: DIFF
107123: ST_TO_ADDR
// continue ;
107124: GO 106911
// end ; end ;
107126: GO 106911
107128: POP
107129: POP
// until solds ;
107130: LD_VAR 0 2
107134: IFFALSE 106743
// MC_Reset ( base , 18 ) ;
107136: LD_VAR 0 1
107140: PPUSH
107141: LD_INT 18
107143: PPUSH
107144: CALL 21524 0 2
// end ;
107148: LD_VAR 0 4
107152: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
107153: LD_INT 0
107155: PPUSH
107156: PPUSH
107157: PPUSH
107158: PPUSH
107159: PPUSH
107160: PPUSH
107161: PPUSH
107162: PPUSH
107163: PPUSH
107164: PPUSH
107165: PPUSH
107166: PPUSH
107167: PPUSH
107168: PPUSH
107169: PPUSH
107170: PPUSH
107171: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107172: LD_ADDR_VAR 0 13
107176: PUSH
107177: LD_EXP 50
107181: PUSH
107182: LD_VAR 0 1
107186: ARRAY
107187: PPUSH
107188: LD_INT 25
107190: PUSH
107191: LD_INT 3
107193: PUSH
107194: EMPTY
107195: LIST
107196: LIST
107197: PPUSH
107198: CALL_OW 72
107202: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107203: LD_EXP 90
107207: PUSH
107208: LD_VAR 0 1
107212: ARRAY
107213: IFFALSE 107237
// mechs := mechs diff mc_remote_driver [ base ] ;
107215: LD_ADDR_VAR 0 13
107219: PUSH
107220: LD_VAR 0 13
107224: PUSH
107225: LD_EXP 90
107229: PUSH
107230: LD_VAR 0 1
107234: ARRAY
107235: DIFF
107236: ST_TO_ADDR
// for i in mechs do
107237: LD_ADDR_VAR 0 5
107241: PUSH
107242: LD_VAR 0 13
107246: PUSH
107247: FOR_IN
107248: IFFALSE 107283
// if GetTag ( i ) > 0 then
107250: LD_VAR 0 5
107254: PPUSH
107255: CALL_OW 110
107259: PUSH
107260: LD_INT 0
107262: GREATER
107263: IFFALSE 107281
// mechs := mechs diff i ;
107265: LD_ADDR_VAR 0 13
107269: PUSH
107270: LD_VAR 0 13
107274: PUSH
107275: LD_VAR 0 5
107279: DIFF
107280: ST_TO_ADDR
107281: GO 107247
107283: POP
107284: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107285: LD_ADDR_VAR 0 9
107289: PUSH
107290: LD_EXP 50
107294: PUSH
107295: LD_VAR 0 1
107299: ARRAY
107300: PPUSH
107301: LD_INT 2
107303: PUSH
107304: LD_INT 25
107306: PUSH
107307: LD_INT 1
107309: PUSH
107310: EMPTY
107311: LIST
107312: LIST
107313: PUSH
107314: LD_INT 25
107316: PUSH
107317: LD_INT 5
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: PUSH
107324: LD_INT 25
107326: PUSH
107327: LD_INT 8
107329: PUSH
107330: EMPTY
107331: LIST
107332: LIST
107333: PUSH
107334: LD_INT 25
107336: PUSH
107337: LD_INT 9
107339: PUSH
107340: EMPTY
107341: LIST
107342: LIST
107343: PUSH
107344: EMPTY
107345: LIST
107346: LIST
107347: LIST
107348: LIST
107349: LIST
107350: PPUSH
107351: CALL_OW 72
107355: ST_TO_ADDR
// if not defenders and not solds then
107356: LD_VAR 0 2
107360: NOT
107361: PUSH
107362: LD_VAR 0 9
107366: NOT
107367: AND
107368: IFFALSE 107372
// exit ;
107370: GO 108998
// depot_under_attack := false ;
107372: LD_ADDR_VAR 0 17
107376: PUSH
107377: LD_INT 0
107379: ST_TO_ADDR
// sold_defenders := [ ] ;
107380: LD_ADDR_VAR 0 18
107384: PUSH
107385: EMPTY
107386: ST_TO_ADDR
// if mechs then
107387: LD_VAR 0 13
107391: IFFALSE 107520
// for i in defenders do
107393: LD_ADDR_VAR 0 5
107397: PUSH
107398: LD_VAR 0 2
107402: PUSH
107403: FOR_IN
107404: IFFALSE 107518
// begin SetTag ( i , 20 ) ;
107406: LD_VAR 0 5
107410: PPUSH
107411: LD_INT 20
107413: PPUSH
107414: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
107418: LD_VAR 0 5
107422: PPUSH
107423: CALL_OW 263
107427: PUSH
107428: LD_INT 1
107430: EQUAL
107431: PUSH
107432: LD_VAR 0 5
107436: PPUSH
107437: CALL_OW 311
107441: NOT
107442: AND
107443: PUSH
107444: LD_VAR 0 13
107448: AND
107449: IFFALSE 107516
// begin un := mechs [ 1 ] ;
107451: LD_ADDR_VAR 0 11
107455: PUSH
107456: LD_VAR 0 13
107460: PUSH
107461: LD_INT 1
107463: ARRAY
107464: ST_TO_ADDR
// ComExitBuilding ( un ) ;
107465: LD_VAR 0 11
107469: PPUSH
107470: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
107474: LD_VAR 0 11
107478: PPUSH
107479: LD_VAR 0 5
107483: PPUSH
107484: CALL_OW 180
// SetTag ( un , 19 ) ;
107488: LD_VAR 0 11
107492: PPUSH
107493: LD_INT 19
107495: PPUSH
107496: CALL_OW 109
// mechs := mechs diff un ;
107500: LD_ADDR_VAR 0 13
107504: PUSH
107505: LD_VAR 0 13
107509: PUSH
107510: LD_VAR 0 11
107514: DIFF
107515: ST_TO_ADDR
// end ; end ;
107516: GO 107403
107518: POP
107519: POP
// if solds then
107520: LD_VAR 0 9
107524: IFFALSE 107583
// for i in solds do
107526: LD_ADDR_VAR 0 5
107530: PUSH
107531: LD_VAR 0 9
107535: PUSH
107536: FOR_IN
107537: IFFALSE 107581
// if not GetTag ( i ) then
107539: LD_VAR 0 5
107543: PPUSH
107544: CALL_OW 110
107548: NOT
107549: IFFALSE 107579
// begin defenders := defenders union i ;
107551: LD_ADDR_VAR 0 2
107555: PUSH
107556: LD_VAR 0 2
107560: PUSH
107561: LD_VAR 0 5
107565: UNION
107566: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107567: LD_VAR 0 5
107571: PPUSH
107572: LD_INT 18
107574: PPUSH
107575: CALL_OW 109
// end ;
107579: GO 107536
107581: POP
107582: POP
// repeat wait ( 0 0$1 ) ;
107583: LD_INT 35
107585: PPUSH
107586: CALL_OW 67
// enemy := mc_scan [ base ] ;
107590: LD_ADDR_VAR 0 3
107594: PUSH
107595: LD_EXP 73
107599: PUSH
107600: LD_VAR 0 1
107604: ARRAY
107605: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107606: LD_EXP 50
107610: PUSH
107611: LD_VAR 0 1
107615: ARRAY
107616: NOT
107617: PUSH
107618: LD_EXP 50
107622: PUSH
107623: LD_VAR 0 1
107627: ARRAY
107628: PUSH
107629: EMPTY
107630: EQUAL
107631: OR
107632: IFFALSE 107669
// begin for i in defenders do
107634: LD_ADDR_VAR 0 5
107638: PUSH
107639: LD_VAR 0 2
107643: PUSH
107644: FOR_IN
107645: IFFALSE 107658
// ComStop ( i ) ;
107647: LD_VAR 0 5
107651: PPUSH
107652: CALL_OW 141
107656: GO 107644
107658: POP
107659: POP
// defenders := [ ] ;
107660: LD_ADDR_VAR 0 2
107664: PUSH
107665: EMPTY
107666: ST_TO_ADDR
// exit ;
107667: GO 108998
// end ; for i in defenders do
107669: LD_ADDR_VAR 0 5
107673: PUSH
107674: LD_VAR 0 2
107678: PUSH
107679: FOR_IN
107680: IFFALSE 108498
// begin e := NearestUnitToUnit ( enemy , i ) ;
107682: LD_ADDR_VAR 0 14
107686: PUSH
107687: LD_VAR 0 3
107691: PPUSH
107692: LD_VAR 0 5
107696: PPUSH
107697: CALL_OW 74
107701: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107702: LD_ADDR_VAR 0 8
107706: PUSH
107707: LD_EXP 50
107711: PUSH
107712: LD_VAR 0 1
107716: ARRAY
107717: PPUSH
107718: LD_INT 2
107720: PUSH
107721: LD_INT 30
107723: PUSH
107724: LD_INT 0
107726: PUSH
107727: EMPTY
107728: LIST
107729: LIST
107730: PUSH
107731: LD_INT 30
107733: PUSH
107734: LD_INT 1
107736: PUSH
107737: EMPTY
107738: LIST
107739: LIST
107740: PUSH
107741: EMPTY
107742: LIST
107743: LIST
107744: LIST
107745: PPUSH
107746: CALL_OW 72
107750: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107751: LD_ADDR_VAR 0 17
107755: PUSH
107756: LD_VAR 0 8
107760: NOT
107761: PUSH
107762: LD_VAR 0 8
107766: PPUSH
107767: LD_INT 3
107769: PUSH
107770: LD_INT 24
107772: PUSH
107773: LD_INT 600
107775: PUSH
107776: EMPTY
107777: LIST
107778: LIST
107779: PUSH
107780: EMPTY
107781: LIST
107782: LIST
107783: PPUSH
107784: CALL_OW 72
107788: OR
107789: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107790: LD_VAR 0 5
107794: PPUSH
107795: CALL_OW 247
107799: PUSH
107800: LD_INT 2
107802: DOUBLE
107803: EQUAL
107804: IFTRUE 107808
107806: GO 108204
107808: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107809: LD_VAR 0 5
107813: PPUSH
107814: CALL_OW 256
107818: PUSH
107819: LD_INT 650
107821: GREATER
107822: PUSH
107823: LD_VAR 0 5
107827: PPUSH
107828: LD_VAR 0 14
107832: PPUSH
107833: CALL_OW 296
107837: PUSH
107838: LD_INT 40
107840: LESS
107841: PUSH
107842: LD_VAR 0 14
107846: PPUSH
107847: LD_EXP 75
107851: PUSH
107852: LD_VAR 0 1
107856: ARRAY
107857: PPUSH
107858: CALL_OW 308
107862: OR
107863: AND
107864: IFFALSE 107986
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107866: LD_VAR 0 5
107870: PPUSH
107871: CALL_OW 262
107875: PUSH
107876: LD_INT 1
107878: EQUAL
107879: PUSH
107880: LD_VAR 0 5
107884: PPUSH
107885: CALL_OW 261
107889: PUSH
107890: LD_INT 30
107892: LESS
107893: AND
107894: PUSH
107895: LD_VAR 0 8
107899: AND
107900: IFFALSE 107970
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107902: LD_VAR 0 5
107906: PPUSH
107907: LD_VAR 0 8
107911: PPUSH
107912: LD_VAR 0 5
107916: PPUSH
107917: CALL_OW 74
107921: PPUSH
107922: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107926: LD_VAR 0 5
107930: PPUSH
107931: LD_VAR 0 8
107935: PPUSH
107936: LD_VAR 0 5
107940: PPUSH
107941: CALL_OW 74
107945: PPUSH
107946: CALL_OW 296
107950: PUSH
107951: LD_INT 6
107953: LESS
107954: IFFALSE 107968
// SetFuel ( i , 100 ) ;
107956: LD_VAR 0 5
107960: PPUSH
107961: LD_INT 100
107963: PPUSH
107964: CALL_OW 240
// end else
107968: GO 107984
// ComAttackUnit ( i , e ) ;
107970: LD_VAR 0 5
107974: PPUSH
107975: LD_VAR 0 14
107979: PPUSH
107980: CALL_OW 115
// end else
107984: GO 108087
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107986: LD_VAR 0 14
107990: PPUSH
107991: LD_EXP 75
107995: PUSH
107996: LD_VAR 0 1
108000: ARRAY
108001: PPUSH
108002: CALL_OW 308
108006: NOT
108007: PUSH
108008: LD_VAR 0 5
108012: PPUSH
108013: LD_VAR 0 14
108017: PPUSH
108018: CALL_OW 296
108022: PUSH
108023: LD_INT 40
108025: GREATEREQUAL
108026: AND
108027: PUSH
108028: LD_VAR 0 5
108032: PPUSH
108033: CALL_OW 256
108037: PUSH
108038: LD_INT 650
108040: LESSEQUAL
108041: OR
108042: PUSH
108043: LD_VAR 0 5
108047: PPUSH
108048: LD_EXP 74
108052: PUSH
108053: LD_VAR 0 1
108057: ARRAY
108058: PPUSH
108059: CALL_OW 308
108063: NOT
108064: AND
108065: IFFALSE 108087
// ComMoveToArea ( i , mc_parking [ base ] ) ;
108067: LD_VAR 0 5
108071: PPUSH
108072: LD_EXP 74
108076: PUSH
108077: LD_VAR 0 1
108081: ARRAY
108082: PPUSH
108083: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108087: LD_VAR 0 5
108091: PPUSH
108092: CALL_OW 256
108096: PUSH
108097: LD_INT 998
108099: LESS
108100: PUSH
108101: LD_VAR 0 5
108105: PPUSH
108106: CALL_OW 263
108110: PUSH
108111: LD_INT 1
108113: EQUAL
108114: AND
108115: PUSH
108116: LD_VAR 0 5
108120: PPUSH
108121: CALL_OW 311
108125: AND
108126: PUSH
108127: LD_VAR 0 5
108131: PPUSH
108132: LD_EXP 74
108136: PUSH
108137: LD_VAR 0 1
108141: ARRAY
108142: PPUSH
108143: CALL_OW 308
108147: AND
108148: IFFALSE 108202
// begin mech := IsDrivenBy ( i ) ;
108150: LD_ADDR_VAR 0 10
108154: PUSH
108155: LD_VAR 0 5
108159: PPUSH
108160: CALL_OW 311
108164: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108165: LD_VAR 0 10
108169: PPUSH
108170: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108174: LD_VAR 0 10
108178: PPUSH
108179: LD_VAR 0 5
108183: PPUSH
108184: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108188: LD_VAR 0 10
108192: PPUSH
108193: LD_VAR 0 5
108197: PPUSH
108198: CALL_OW 180
// end ; end ; unit_human :
108202: GO 108469
108204: LD_INT 1
108206: DOUBLE
108207: EQUAL
108208: IFTRUE 108212
108210: GO 108468
108212: POP
// begin b := IsInUnit ( i ) ;
108213: LD_ADDR_VAR 0 19
108217: PUSH
108218: LD_VAR 0 5
108222: PPUSH
108223: CALL_OW 310
108227: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108228: LD_ADDR_VAR 0 20
108232: PUSH
108233: LD_VAR 0 19
108237: NOT
108238: PUSH
108239: LD_VAR 0 19
108243: PPUSH
108244: CALL_OW 266
108248: PUSH
108249: LD_INT 32
108251: PUSH
108252: LD_INT 31
108254: PUSH
108255: EMPTY
108256: LIST
108257: LIST
108258: IN
108259: OR
108260: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108261: LD_VAR 0 17
108265: PUSH
108266: LD_VAR 0 2
108270: PPUSH
108271: LD_INT 21
108273: PUSH
108274: LD_INT 2
108276: PUSH
108277: EMPTY
108278: LIST
108279: LIST
108280: PPUSH
108281: CALL_OW 72
108285: PUSH
108286: LD_INT 1
108288: LESSEQUAL
108289: OR
108290: PUSH
108291: LD_VAR 0 20
108295: AND
108296: PUSH
108297: LD_VAR 0 5
108301: PUSH
108302: LD_VAR 0 18
108306: IN
108307: NOT
108308: AND
108309: IFFALSE 108402
// begin if b then
108311: LD_VAR 0 19
108315: IFFALSE 108364
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108317: LD_VAR 0 19
108321: PPUSH
108322: LD_VAR 0 3
108326: PPUSH
108327: LD_VAR 0 19
108331: PPUSH
108332: CALL_OW 74
108336: PPUSH
108337: CALL_OW 296
108341: PUSH
108342: LD_INT 10
108344: LESS
108345: PUSH
108346: LD_VAR 0 19
108350: PPUSH
108351: CALL_OW 461
108355: PUSH
108356: LD_INT 7
108358: NONEQUAL
108359: AND
108360: IFFALSE 108364
// continue ;
108362: GO 107679
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108364: LD_ADDR_VAR 0 18
108368: PUSH
108369: LD_VAR 0 18
108373: PPUSH
108374: LD_VAR 0 18
108378: PUSH
108379: LD_INT 1
108381: PLUS
108382: PPUSH
108383: LD_VAR 0 5
108387: PPUSH
108388: CALL_OW 1
108392: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108393: LD_VAR 0 5
108397: PPUSH
108398: CALL_OW 122
// end ; if sold_defenders then
108402: LD_VAR 0 18
108406: IFFALSE 108466
// if i in sold_defenders then
108408: LD_VAR 0 5
108412: PUSH
108413: LD_VAR 0 18
108417: IN
108418: IFFALSE 108466
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108420: LD_VAR 0 5
108424: PPUSH
108425: CALL_OW 314
108429: NOT
108430: PUSH
108431: LD_VAR 0 5
108435: PPUSH
108436: LD_VAR 0 14
108440: PPUSH
108441: CALL_OW 296
108445: PUSH
108446: LD_INT 30
108448: LESS
108449: AND
108450: IFFALSE 108466
// ComAttackUnit ( i , e ) ;
108452: LD_VAR 0 5
108456: PPUSH
108457: LD_VAR 0 14
108461: PPUSH
108462: CALL_OW 115
// end ; end ; end ;
108466: GO 108469
108468: POP
// if IsDead ( i ) then
108469: LD_VAR 0 5
108473: PPUSH
108474: CALL_OW 301
108478: IFFALSE 108496
// defenders := defenders diff i ;
108480: LD_ADDR_VAR 0 2
108484: PUSH
108485: LD_VAR 0 2
108489: PUSH
108490: LD_VAR 0 5
108494: DIFF
108495: ST_TO_ADDR
// end ;
108496: GO 107679
108498: POP
108499: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108500: LD_VAR 0 3
108504: NOT
108505: PUSH
108506: LD_VAR 0 2
108510: NOT
108511: OR
108512: PUSH
108513: LD_EXP 50
108517: PUSH
108518: LD_VAR 0 1
108522: ARRAY
108523: NOT
108524: OR
108525: IFFALSE 107583
// MC_Reset ( base , 18 ) ;
108527: LD_VAR 0 1
108531: PPUSH
108532: LD_INT 18
108534: PPUSH
108535: CALL 21524 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108539: LD_ADDR_VAR 0 2
108543: PUSH
108544: LD_VAR 0 2
108548: PUSH
108549: LD_VAR 0 2
108553: PPUSH
108554: LD_INT 2
108556: PUSH
108557: LD_INT 25
108559: PUSH
108560: LD_INT 1
108562: PUSH
108563: EMPTY
108564: LIST
108565: LIST
108566: PUSH
108567: LD_INT 25
108569: PUSH
108570: LD_INT 5
108572: PUSH
108573: EMPTY
108574: LIST
108575: LIST
108576: PUSH
108577: LD_INT 25
108579: PUSH
108580: LD_INT 8
108582: PUSH
108583: EMPTY
108584: LIST
108585: LIST
108586: PUSH
108587: LD_INT 25
108589: PUSH
108590: LD_INT 9
108592: PUSH
108593: EMPTY
108594: LIST
108595: LIST
108596: PUSH
108597: EMPTY
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: LIST
108603: PPUSH
108604: CALL_OW 72
108608: DIFF
108609: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108610: LD_VAR 0 3
108614: NOT
108615: PUSH
108616: LD_VAR 0 2
108620: PPUSH
108621: LD_INT 21
108623: PUSH
108624: LD_INT 2
108626: PUSH
108627: EMPTY
108628: LIST
108629: LIST
108630: PPUSH
108631: CALL_OW 72
108635: AND
108636: IFFALSE 108974
// begin tmp := FilterByTag ( defenders , 19 ) ;
108638: LD_ADDR_VAR 0 12
108642: PUSH
108643: LD_VAR 0 2
108647: PPUSH
108648: LD_INT 19
108650: PPUSH
108651: CALL 81021 0 2
108655: ST_TO_ADDR
// if tmp then
108656: LD_VAR 0 12
108660: IFFALSE 108730
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108662: LD_ADDR_VAR 0 12
108666: PUSH
108667: LD_VAR 0 12
108671: PPUSH
108672: LD_INT 25
108674: PUSH
108675: LD_INT 3
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: PPUSH
108682: CALL_OW 72
108686: ST_TO_ADDR
// if tmp then
108687: LD_VAR 0 12
108691: IFFALSE 108730
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108693: LD_ADDR_EXP 62
108697: PUSH
108698: LD_EXP 62
108702: PPUSH
108703: LD_VAR 0 1
108707: PPUSH
108708: LD_EXP 62
108712: PUSH
108713: LD_VAR 0 1
108717: ARRAY
108718: PUSH
108719: LD_VAR 0 12
108723: UNION
108724: PPUSH
108725: CALL_OW 1
108729: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108730: LD_VAR 0 1
108734: PPUSH
108735: LD_INT 19
108737: PPUSH
108738: CALL 21524 0 2
// repeat wait ( 0 0$1 ) ;
108742: LD_INT 35
108744: PPUSH
108745: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108749: LD_EXP 50
108753: PUSH
108754: LD_VAR 0 1
108758: ARRAY
108759: NOT
108760: PUSH
108761: LD_EXP 50
108765: PUSH
108766: LD_VAR 0 1
108770: ARRAY
108771: PUSH
108772: EMPTY
108773: EQUAL
108774: OR
108775: IFFALSE 108812
// begin for i in defenders do
108777: LD_ADDR_VAR 0 5
108781: PUSH
108782: LD_VAR 0 2
108786: PUSH
108787: FOR_IN
108788: IFFALSE 108801
// ComStop ( i ) ;
108790: LD_VAR 0 5
108794: PPUSH
108795: CALL_OW 141
108799: GO 108787
108801: POP
108802: POP
// defenders := [ ] ;
108803: LD_ADDR_VAR 0 2
108807: PUSH
108808: EMPTY
108809: ST_TO_ADDR
// exit ;
108810: GO 108998
// end ; for i in defenders do
108812: LD_ADDR_VAR 0 5
108816: PUSH
108817: LD_VAR 0 2
108821: PUSH
108822: FOR_IN
108823: IFFALSE 108912
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108825: LD_VAR 0 5
108829: PPUSH
108830: LD_EXP 74
108834: PUSH
108835: LD_VAR 0 1
108839: ARRAY
108840: PPUSH
108841: CALL_OW 308
108845: NOT
108846: IFFALSE 108870
// ComMoveToArea ( i , mc_parking [ base ] ) else
108848: LD_VAR 0 5
108852: PPUSH
108853: LD_EXP 74
108857: PUSH
108858: LD_VAR 0 1
108862: ARRAY
108863: PPUSH
108864: CALL_OW 113
108868: GO 108910
// if GetControl ( i ) = control_manual then
108870: LD_VAR 0 5
108874: PPUSH
108875: CALL_OW 263
108879: PUSH
108880: LD_INT 1
108882: EQUAL
108883: IFFALSE 108910
// if IsDrivenBy ( i ) then
108885: LD_VAR 0 5
108889: PPUSH
108890: CALL_OW 311
108894: IFFALSE 108910
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108896: LD_VAR 0 5
108900: PPUSH
108901: CALL_OW 311
108905: PPUSH
108906: CALL_OW 121
// end ;
108910: GO 108822
108912: POP
108913: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108914: LD_VAR 0 2
108918: PPUSH
108919: LD_INT 95
108921: PUSH
108922: LD_EXP 74
108926: PUSH
108927: LD_VAR 0 1
108931: ARRAY
108932: PUSH
108933: EMPTY
108934: LIST
108935: LIST
108936: PPUSH
108937: CALL_OW 72
108941: PUSH
108942: LD_VAR 0 2
108946: EQUAL
108947: PUSH
108948: LD_EXP 73
108952: PUSH
108953: LD_VAR 0 1
108957: ARRAY
108958: OR
108959: PUSH
108960: LD_EXP 50
108964: PUSH
108965: LD_VAR 0 1
108969: ARRAY
108970: NOT
108971: OR
108972: IFFALSE 108742
// end ; MC_Reset ( base , 19 ) ;
108974: LD_VAR 0 1
108978: PPUSH
108979: LD_INT 19
108981: PPUSH
108982: CALL 21524 0 2
// MC_Reset ( base , 20 ) ;
108986: LD_VAR 0 1
108990: PPUSH
108991: LD_INT 20
108993: PPUSH
108994: CALL 21524 0 2
// end ; end_of_file
108998: LD_VAR 0 4
109002: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109003: LD_VAR 0 1
109007: PUSH
109008: LD_INT 200
109010: DOUBLE
109011: GREATEREQUAL
109012: IFFALSE 109020
109014: LD_INT 299
109016: DOUBLE
109017: LESSEQUAL
109018: IFTRUE 109022
109020: GO 109054
109022: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109023: LD_VAR 0 1
109027: PPUSH
109028: LD_VAR 0 2
109032: PPUSH
109033: LD_VAR 0 3
109037: PPUSH
109038: LD_VAR 0 4
109042: PPUSH
109043: LD_VAR 0 5
109047: PPUSH
109048: CALL 98008 0 5
109052: GO 109131
109054: LD_INT 300
109056: DOUBLE
109057: GREATEREQUAL
109058: IFFALSE 109066
109060: LD_INT 399
109062: DOUBLE
109063: LESSEQUAL
109064: IFTRUE 109068
109066: GO 109130
109068: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109069: LD_VAR 0 1
109073: PPUSH
109074: LD_VAR 0 2
109078: PPUSH
109079: LD_VAR 0 3
109083: PPUSH
109084: LD_VAR 0 4
109088: PPUSH
109089: LD_VAR 0 5
109093: PPUSH
109094: LD_VAR 0 6
109098: PPUSH
109099: LD_VAR 0 7
109103: PPUSH
109104: LD_VAR 0 8
109108: PPUSH
109109: LD_VAR 0 9
109113: PPUSH
109114: LD_VAR 0 10
109118: PPUSH
109119: LD_VAR 0 11
109123: PPUSH
109124: CALL 95914 0 11
109128: GO 109131
109130: POP
// end ;
109131: PPOPN 11
109133: END
