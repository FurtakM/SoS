// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 87963 0 0
// InitMacro ;
  23: CALL 17929 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81771 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2614 0 0
// MC_Start ( ) ;
  89: CALL 20094 0 0
// Action ;
  93: CALL 8559 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41636 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41636 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41636 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42062 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 41954 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 41954 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48408 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48408 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48408 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48408 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48408 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48408 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48408 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48408 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48408 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48408 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48408 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48408 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48408 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48408 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48408 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2268
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2251
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2249
// SetMark ( veh , 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 242
// end else
2249: GO 2266
// PlaceUnitArea ( i , am_hum_start , false ) ;
2251: LD_VAR 0 2
2255: PPUSH
2256: LD_INT 9
2258: PPUSH
2259: LD_INT 0
2261: PPUSH
2262: CALL_OW 49
// end ;
2266: GO 2078
2268: POP
2269: POP
// vc_chassis := us_medium_tracked ;
2270: LD_ADDR_OWVAR 37
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_engine := engine_solar ;
2278: LD_ADDR_OWVAR 39
2282: PUSH
2283: LD_INT 2
2285: ST_TO_ADDR
// vc_control := control_computer ;
2286: LD_ADDR_OWVAR 38
2290: PUSH
2291: LD_INT 3
2293: ST_TO_ADDR
// vc_weapon := us_radar ;
2294: LD_ADDR_OWVAR 40
2298: PUSH
2299: LD_INT 11
2301: ST_TO_ADDR
// veh := CreateVehicle ;
2302: LD_ADDR_VAR 0 7
2306: PUSH
2307: CALL_OW 45
2311: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2312: LD_VAR 0 7
2316: PPUSH
2317: LD_INT 87
2319: PPUSH
2320: LD_INT 142
2322: PPUSH
2323: LD_INT 0
2325: PPUSH
2326: CALL_OW 48
// end ;
2330: LD_VAR 0 1
2334: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2335: LD_INT 0
2337: PPUSH
2338: PPUSH
2339: PPUSH
2340: PPUSH
// uc_side := 1 ;
2341: LD_ADDR_OWVAR 20
2345: PUSH
2346: LD_INT 1
2348: ST_TO_ADDR
// uc_nation := 1 ;
2349: LD_ADDR_OWVAR 21
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2357: LD_ADDR_VAR 0 3
2361: PUSH
2362: LD_INT 3
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: LD_INT 3
2370: PUSH
2371: LD_INT 5
2373: PUSH
2374: EMPTY
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 3
2382: PUSH
2383: LD_INT 1
2385: PUSH
2386: LD_INT 3
2388: PUSH
2389: LD_INT 7
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 3
2400: PUSH
2401: LD_INT 1
2403: PUSH
2404: LD_INT 3
2406: PUSH
2407: LD_INT 7
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 11
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 4
2436: PUSH
2437: LD_INT 1
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 6
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: PUSH
2452: LD_INT 4
2454: PUSH
2455: LD_INT 1
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 5
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2478: LD_ADDR_VAR 0 2
2482: PUSH
2483: DOUBLE
2484: LD_INT 1
2486: DEC
2487: ST_TO_ADDR
2488: LD_INT 7
2490: PUSH
2491: LD_OWVAR 67
2495: MINUS
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2607
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2500: LD_ADDR_OWVAR 37
2504: PUSH
2505: LD_VAR 0 3
2509: PUSH
2510: LD_VAR 0 2
2514: ARRAY
2515: PUSH
2516: LD_INT 1
2518: ARRAY
2519: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2520: LD_ADDR_OWVAR 39
2524: PUSH
2525: LD_VAR 0 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2540: LD_ADDR_OWVAR 38
2544: PUSH
2545: LD_VAR 0 3
2549: PUSH
2550: LD_VAR 0 2
2554: ARRAY
2555: PUSH
2556: LD_INT 3
2558: ARRAY
2559: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2560: LD_ADDR_OWVAR 40
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: LD_VAR 0 2
2574: ARRAY
2575: PUSH
2576: LD_INT 4
2578: ARRAY
2579: ST_TO_ADDR
// veh := CreateVehicle ;
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: CALL_OW 45
2589: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2590: LD_VAR 0 4
2594: PPUSH
2595: LD_INT 8
2597: PPUSH
2598: LD_INT 0
2600: PPUSH
2601: CALL_OW 49
// end ;
2605: GO 2497
2607: POP
2608: POP
// end ; end_of_file
2609: LD_VAR 0 1
2613: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2614: LD_INT 0
2616: PPUSH
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
// if Difficulty = 1 then
2622: LD_OWVAR 67
2626: PUSH
2627: LD_INT 1
2629: EQUAL
2630: IFFALSE 2727
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2632: LD_ADDR_VAR 0 6
2636: PUSH
2637: LD_INT 129
2639: PUSH
2640: LD_INT 45
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 143
2649: PUSH
2650: LD_INT 58
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 184
2659: PUSH
2660: LD_INT 113
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 163
2669: PUSH
2670: LD_INT 107
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: ST_TO_ADDR
// for i in tmp do
2683: LD_ADDR_VAR 0 2
2687: PUSH
2688: LD_VAR 0 6
2692: PUSH
2693: FOR_IN
2694: IFFALSE 2725
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 1
2703: ARRAY
2704: PPUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_INT 2
2712: ARRAY
2713: PPUSH
2714: CALL_OW 428
2718: PPUSH
2719: CALL_OW 64
2723: GO 2693
2725: POP
2726: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_INT 21
2734: PUSH
2735: LD_INT 3
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: PUSH
2747: FOR_IN
2748: IFFALSE 2785
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2750: LD_VAR 0 2
2754: PPUSH
2755: LD_INT 5
2757: PUSH
2758: LD_INT 6
2760: PUSH
2761: LD_INT 7
2763: PUSH
2764: LD_INT 8
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: LIST
2771: LIST
2772: PUSH
2773: LD_OWVAR 67
2777: ARRAY
2778: PPUSH
2779: CALL_OW 241
2783: GO 2747
2785: POP
2786: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_INT 5
2794: PUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 7
2800: PUSH
2801: LD_INT 8
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: PUSH
2810: LD_OWVAR 67
2814: ARRAY
2815: ST_TO_ADDR
// uc_side := 2 ;
2816: LD_ADDR_OWVAR 20
2820: PUSH
2821: LD_INT 2
2823: ST_TO_ADDR
// uc_nation := 2 ;
2824: LD_ADDR_OWVAR 21
2828: PUSH
2829: LD_INT 2
2831: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2832: LD_ADDR_OWVAR 37
2836: PUSH
2837: LD_INT 14
2839: ST_TO_ADDR
// vc_engine := engine_siberite ;
2840: LD_ADDR_OWVAR 39
2844: PUSH
2845: LD_INT 3
2847: ST_TO_ADDR
// vc_control := control_manual ;
2848: LD_ADDR_OWVAR 38
2852: PUSH
2853: LD_INT 1
2855: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2856: LD_ADDR_OWVAR 40
2860: PUSH
2861: LD_INT 31
2863: ST_TO_ADDR
// for i = 1 to 3 do
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: DOUBLE
2870: LD_INT 1
2872: DEC
2873: ST_TO_ADDR
2874: LD_INT 3
2876: PUSH
2877: FOR_TO
2878: IFFALSE 2962
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 3
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateVehicle ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 45
2904: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 0
2912: PPUSH
2913: LD_INT 5
2915: PPUSH
2916: CALL_OW 12
2920: PPUSH
2921: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2925: LD_VAR 0 4
2929: PPUSH
2930: LD_INT 156
2932: PPUSH
2933: LD_INT 15
2935: PPUSH
2936: LD_INT 6
2938: PPUSH
2939: LD_INT 0
2941: PPUSH
2942: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2946: CALL_OW 44
2950: PPUSH
2951: LD_VAR 0 4
2955: PPUSH
2956: CALL_OW 52
// end ;
2960: GO 2877
2962: POP
2963: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2964: LD_ADDR_EXP 37
2968: PUSH
2969: LD_INT 94
2971: PPUSH
2972: LD_INT 28
2974: PPUSH
2975: LD_STRING dammam
2977: PPUSH
2978: LD_VAR 0 5
2982: PPUSH
2983: LD_INT 10000
2985: PUSH
2986: LD_INT 1000
2988: PUSH
2989: LD_INT 300
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: PPUSH
2997: LD_INT 12
2999: PUSH
3000: LD_INT 2
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 4
3008: PUSH
3009: LD_INT 4
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: PUSH
3018: LD_OWVAR 67
3022: ARRAY
3023: PUSH
3024: LD_INT 1
3026: NEG
3027: PUSH
3028: LD_INT 4
3030: PUSH
3031: EMPTY
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: PPUSH
3037: CALL 56718 0 6
3041: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3042: LD_ADDR_EXP 37
3046: PUSH
3047: LD_EXP 37
3051: PUSH
3052: LD_INT 122
3054: PPUSH
3055: LD_INT 25
3057: PPUSH
3058: LD_STRING 
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: LD_INT 500
3068: PUSH
3069: LD_INT 60
3071: PUSH
3072: LD_INT 0
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: PPUSH
3080: LD_INT 8
3082: PUSH
3083: LD_INT 2
3085: PUSH
3086: LD_INT 3
3088: PUSH
3089: LD_INT 4
3091: PUSH
3092: LD_INT 5
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: PPUSH
3119: CALL 56718 0 6
3123: UNION
3124: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3125: LD_ADDR_EXP 35
3129: PUSH
3130: LD_INT 45
3132: PPUSH
3133: LD_INT 24
3135: PPUSH
3136: LD_STRING jeddah
3138: PPUSH
3139: LD_VAR 0 5
3143: PPUSH
3144: LD_INT 700
3146: PUSH
3147: LD_INT 300
3149: PUSH
3150: LD_INT 10
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: PPUSH
3158: LD_INT 9
3160: PUSH
3161: LD_INT 4
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 2
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL 56718 0 6
3180: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3181: LD_ADDR_EXP 36
3185: PUSH
3186: LD_INT 7
3188: PPUSH
3189: LD_INT 27
3191: PPUSH
3192: LD_STRING riyadh
3194: PPUSH
3195: LD_VAR 0 5
3199: PPUSH
3200: LD_INT 500
3202: PUSH
3203: LD_INT 60
3205: PUSH
3206: LD_INT 0
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: LIST
3213: PPUSH
3214: LD_INT 4
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 3
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL 56718 0 6
3236: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3237: LD_ADDR_EXP 39
3241: PUSH
3242: LD_INT 204
3244: PPUSH
3245: LD_INT 26
3247: PPUSH
3248: LD_STRING 
3250: PPUSH
3251: LD_VAR 0 5
3255: PPUSH
3256: LD_INT 500
3258: PUSH
3259: LD_INT 50
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: PPUSH
3270: LD_INT 9
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: LD_INT 1
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL 56718 0 6
3292: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3293: LD_ADDR_EXP 50
3297: PUSH
3298: LD_EXP 37
3302: PUSH
3303: LD_EXP 35
3307: PUSH
3308: LD_EXP 39
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: LIST
3317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3318: LD_ADDR_VAR 0 2
3322: PUSH
3323: LD_INT 22
3325: PUSH
3326: LD_INT 2
3328: PUSH
3329: EMPTY
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 30
3335: PUSH
3336: LD_INT 31
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 58
3345: PUSH
3346: EMPTY
3347: LIST
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: PPUSH
3354: CALL_OW 69
3358: PUSH
3359: FOR_IN
3360: IFFALSE 3485
// begin if GetBase ( i ) then
3362: LD_VAR 0 2
3366: PPUSH
3367: CALL_OW 274
3371: IFFALSE 3375
// continue ;
3373: GO 3359
// d := GetDir ( i ) ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: LD_VAR 0 2
3384: PPUSH
3385: CALL_OW 254
3389: ST_TO_ADDR
// if d < 3 then
3390: LD_VAR 0 3
3394: PUSH
3395: LD_INT 3
3397: LESS
3398: IFFALSE 3416
// d := d + 3 else
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PUSH
3410: LD_INT 3
3412: PLUS
3413: ST_TO_ADDR
3414: GO 3430
// d := d - 3 ;
3416: LD_ADDR_VAR 0 3
3420: PUSH
3421: LD_VAR 0 3
3425: PUSH
3426: LD_INT 3
3428: MINUS
3429: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 8
3435: PPUSH
3436: LD_VAR 0 5
3440: PPUSH
3441: CALL_OW 380
// un := CreateHuman ;
3445: LD_ADDR_VAR 0 4
3449: PUSH
3450: CALL_OW 44
3454: ST_TO_ADDR
// SetDir ( un , d ) ;
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_VAR 0 3
3464: PPUSH
3465: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3469: LD_VAR 0 4
3473: PPUSH
3474: LD_VAR 0 2
3478: PPUSH
3479: CALL_OW 52
// end ;
3483: GO 3359
3485: POP
3486: POP
// if Difficulty > 1 then
3487: LD_OWVAR 67
3491: PUSH
3492: LD_INT 1
3494: GREATER
3495: IFFALSE 3866
// begin ar_kamikadze := [ ] ;
3497: LD_ADDR_EXP 42
3501: PUSH
3502: EMPTY
3503: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3504: LD_INT 0
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_VAR 0 5
3514: PPUSH
3515: CALL_OW 380
// un := CreateHuman ;
3519: LD_ADDR_VAR 0 4
3523: PUSH
3524: CALL_OW 44
3528: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3529: LD_VAR 0 4
3533: PPUSH
3534: LD_INT 3
3536: PPUSH
3537: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3541: LD_VAR 0 4
3545: PPUSH
3546: LD_INT 23
3548: PPUSH
3549: LD_INT 44
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// ComCrawl ( un ) ;
3559: LD_VAR 0 4
3563: PPUSH
3564: CALL_OW 137
// un := CreateHuman ;
3568: LD_ADDR_VAR 0 4
3572: PUSH
3573: CALL_OW 44
3577: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3578: LD_VAR 0 4
3582: PPUSH
3583: LD_INT 3
3585: PPUSH
3586: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3590: LD_VAR 0 4
3594: PPUSH
3595: LD_INT 30
3597: PPUSH
3598: LD_INT 39
3600: PPUSH
3601: LD_INT 0
3603: PPUSH
3604: CALL_OW 48
// ComCrawl ( un ) ;
3608: LD_VAR 0 4
3612: PPUSH
3613: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3617: LD_INT 0
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: LD_VAR 0 5
3627: PPUSH
3628: CALL_OW 380
// un := CreateHuman ;
3632: LD_ADDR_VAR 0 4
3636: PUSH
3637: CALL_OW 44
3641: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3642: LD_VAR 0 4
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3654: LD_VAR 0 4
3658: PPUSH
3659: LD_INT 45
3661: PPUSH
3662: LD_INT 86
3664: PPUSH
3665: LD_INT 0
3667: PPUSH
3668: CALL_OW 48
// ComHold ( un ) ;
3672: LD_VAR 0 4
3676: PPUSH
3677: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3681: LD_ADDR_EXP 42
3685: PUSH
3686: LD_EXP 42
3690: PPUSH
3691: LD_EXP 42
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_VAR 0 4
3704: PPUSH
3705: CALL_OW 1
3709: ST_TO_ADDR
// un := CreateHuman ;
3710: LD_ADDR_VAR 0 4
3714: PUSH
3715: CALL_OW 44
3719: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3732: LD_VAR 0 4
3736: PPUSH
3737: LD_INT 60
3739: PPUSH
3740: LD_INT 85
3742: PPUSH
3743: LD_INT 0
3745: PPUSH
3746: CALL_OW 48
// ComHold ( un ) ;
3750: LD_VAR 0 4
3754: PPUSH
3755: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3759: LD_ADDR_EXP 42
3763: PUSH
3764: LD_EXP 42
3768: PPUSH
3769: LD_EXP 42
3773: PUSH
3774: LD_INT 1
3776: PLUS
3777: PPUSH
3778: LD_VAR 0 4
3782: PPUSH
3783: CALL_OW 1
3787: ST_TO_ADDR
// un := CreateHuman ;
3788: LD_ADDR_VAR 0 4
3792: PUSH
3793: CALL_OW 44
3797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3798: LD_VAR 0 4
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3810: LD_VAR 0 4
3814: PPUSH
3815: LD_INT 222
3817: PPUSH
3818: LD_INT 166
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
// ComHold ( un ) ;
3828: LD_VAR 0 4
3832: PPUSH
3833: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3837: LD_ADDR_EXP 42
3841: PUSH
3842: LD_EXP 42
3846: PPUSH
3847: LD_EXP 42
3851: PUSH
3852: LD_INT 1
3854: PLUS
3855: PPUSH
3856: LD_VAR 0 4
3860: PPUSH
3861: CALL_OW 1
3865: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3866: LD_ADDR_EXP 40
3870: PUSH
3871: EMPTY
3872: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3873: LD_INT 1
3875: PPUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_VAR 0 5
3883: PPUSH
3884: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3888: LD_ADDR_OWVAR 26
3892: PUSH
3893: LD_STRING Pavel Grigorovic
3895: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3896: LD_ADDR_OWVAR 33
3900: PUSH
3901: LD_STRING SecondCharsGal
3903: ST_TO_ADDR
// hc_face_number := 4 ;
3904: LD_ADDR_OWVAR 34
3908: PUSH
3909: LD_INT 4
3911: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3912: LD_ADDR_EXP 40
3916: PUSH
3917: LD_EXP 40
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 44
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3935: LD_INT 2
3937: PPUSH
3938: LD_INT 4
3940: PPUSH
3941: LD_INT 2
3943: PPUSH
3944: CALL_OW 380
// hc_name := Lucy Sebel ;
3948: LD_ADDR_OWVAR 26
3952: PUSH
3953: LD_STRING Lucy Sebel
3955: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3956: LD_ADDR_OWVAR 33
3960: PUSH
3961: LD_STRING SecondCharsGal
3963: ST_TO_ADDR
// hc_face_number := 15 ;
3964: LD_ADDR_OWVAR 34
3968: PUSH
3969: LD_INT 15
3971: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3972: LD_ADDR_EXP 40
3976: PUSH
3977: LD_EXP 40
3981: PPUSH
3982: LD_INT 2
3984: PPUSH
3985: CALL_OW 44
3989: PPUSH
3990: CALL_OW 1
3994: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3995: LD_INT 2
3997: PPUSH
3998: LD_INT 4
4000: PPUSH
4001: LD_INT 2
4003: PPUSH
4004: CALL_OW 380
// hc_gallery :=  ;
4008: LD_ADDR_OWVAR 33
4012: PUSH
4013: LD_STRING 
4015: ST_TO_ADDR
// hc_name :=  ;
4016: LD_ADDR_OWVAR 26
4020: PUSH
4021: LD_STRING 
4023: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4024: LD_ADDR_EXP 40
4028: PUSH
4029: LD_EXP 40
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: CALL_OW 44
4041: PPUSH
4042: CALL_OW 1
4046: ST_TO_ADDR
// hc_sex := sex_male ;
4047: LD_ADDR_OWVAR 27
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// hc_class = 11 ;
4055: LD_ADDR_OWVAR 28
4059: PUSH
4060: LD_INT 11
4062: ST_TO_ADDR
// hc_gallery = sandar ;
4063: LD_ADDR_OWVAR 33
4067: PUSH
4068: LD_STRING sandar
4070: ST_TO_ADDR
// hc_face_number = 33 ;
4071: LD_ADDR_OWVAR 34
4075: PUSH
4076: LD_INT 33
4078: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4079: LD_ADDR_OWVAR 26
4083: PUSH
4084: LD_STRING Thabit Muhair Saliba
4086: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4087: LD_ADDR_OWVAR 31
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: LD_INT 0
4097: PUSH
4098: LD_INT 0
4100: PUSH
4101: LD_INT 0
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: ST_TO_ADDR
// Saliba = CreateHuman ;
4110: LD_ADDR_EXP 44
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4120: LD_EXP 44
4124: PPUSH
4125: LD_INT 7
4127: PPUSH
4128: CALL_OW 52
// if gensher_active then
4132: LD_EXP 18
4136: IFFALSE 4163
// begin Gensher = NewCharacter ( Dietrich ) ;
4138: LD_ADDR_EXP 45
4142: PUSH
4143: LD_STRING Dietrich
4145: PPUSH
4146: CALL_OW 25
4150: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4151: LD_EXP 45
4155: PPUSH
4156: LD_INT 94
4158: PPUSH
4159: CALL_OW 52
// end ; InitHc ;
4163: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4167: LD_ADDR_EXP 41
4171: PUSH
4172: EMPTY
4173: ST_TO_ADDR
// for i = 1 to 5 do
4174: LD_ADDR_VAR 0 2
4178: PUSH
4179: DOUBLE
4180: LD_INT 1
4182: DEC
4183: ST_TO_ADDR
4184: LD_INT 5
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4360
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4190: LD_INT 13
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 2
4205: PPUSH
4206: CALL_OW 12
4210: ARRAY
4211: PPUSH
4212: LD_INT 1
4214: PUSH
4215: LD_INT 2
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 2
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: PPUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_INT 25
4239: PUSH
4240: LD_INT 27
4242: PUSH
4243: LD_INT 26
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_INT 1
4253: PPUSH
4254: LD_INT 3
4256: PPUSH
4257: CALL_OW 12
4261: ARRAY
4262: PPUSH
4263: LD_INT 60
4265: PPUSH
4266: LD_INT 100
4268: PPUSH
4269: CALL_OW 12
4273: PPUSH
4274: CALL 53272 0 5
// un := CreateVehicle ;
4278: LD_ADDR_VAR 0 4
4282: PUSH
4283: CALL_OW 45
4287: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4288: LD_ADDR_EXP 41
4292: PUSH
4293: LD_EXP 41
4297: PPUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 1
4305: PLUS
4306: PPUSH
4307: LD_VAR 0 4
4311: PPUSH
4312: CALL_OW 1
4316: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4317: LD_VAR 0 4
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: LD_INT 5
4327: PPUSH
4328: CALL_OW 12
4332: PPUSH
4333: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4337: LD_VAR 0 4
4341: PPUSH
4342: LD_INT 124
4344: PPUSH
4345: LD_INT 141
4347: PPUSH
4348: LD_INT 8
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 50
// end ;
4358: GO 4187
4360: POP
4361: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4362: LD_ADDR_EXP 43
4366: PUSH
4367: EMPTY
4368: PUSH
4369: EMPTY
4370: PUSH
4371: EMPTY
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: LIST
4377: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: DOUBLE
4384: LD_INT 1
4386: DEC
4387: ST_TO_ADDR
4388: LD_INT 3
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: LD_INT 4
4396: PUSH
4397: LD_INT 4
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_OWVAR 67
4410: ARRAY
4411: PUSH
4412: FOR_TO
4413: IFFALSE 4627
// for i = 1 to 3 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_INT 3
4427: PUSH
4428: FOR_TO
4429: IFFALSE 4623
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4431: LD_INT 14
4433: PPUSH
4434: LD_INT 3
4436: PUSH
4437: LD_INT 2
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 1
4446: PPUSH
4447: LD_INT 2
4449: PPUSH
4450: CALL_OW 12
4454: ARRAY
4455: PPUSH
4456: LD_INT 1
4458: PUSH
4459: LD_INT 5
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 2
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 27
4483: PUSH
4484: LD_INT 26
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 4
4501: PPUSH
4502: CALL_OW 12
4506: ARRAY
4507: PPUSH
4508: LD_INT 100
4510: PPUSH
4511: CALL 53272 0 5
// un := CreateVehicle ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 45
4524: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4525: LD_ADDR_EXP 43
4529: PUSH
4530: LD_EXP 43
4534: PPUSH
4535: LD_VAR 0 2
4539: PUSH
4540: LD_EXP 43
4544: PUSH
4545: LD_VAR 0 2
4549: ARRAY
4550: PUSH
4551: LD_INT 1
4553: PLUS
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PPUSH
4559: LD_VAR 0 4
4563: PPUSH
4564: CALL 53394 0 3
4568: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4569: LD_VAR 0 4
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: LD_INT 5
4579: PPUSH
4580: CALL_OW 12
4584: PPUSH
4585: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 21
4599: PUSH
4600: LD_INT 22
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: LD_VAR 0 2
4612: ARRAY
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 49
// end ;
4621: GO 4428
4623: POP
4624: POP
4625: GO 4412
4627: POP
4628: POP
// InitHc ;
4629: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4633: LD_INT 4
4635: PPUSH
4636: LD_INT 5
4638: PPUSH
4639: LD_INT 10
4641: PPUSH
4642: LD_INT 5
4644: PPUSH
4645: LD_INT 0
4647: PPUSH
4648: CALL_OW 58
// end ;
4652: LD_VAR 0 1
4656: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4657: LD_EXP 42
4661: IFFALSE 4735
4663: GO 4665
4665: DISABLE
4666: LD_INT 0
4668: PPUSH
// begin enable ;
4669: ENABLE
// for i in ar_kamikadze do
4670: LD_ADDR_VAR 0 1
4674: PUSH
4675: LD_EXP 42
4679: PUSH
4680: FOR_IN
4681: IFFALSE 4733
// if See ( 1 , i ) then
4683: LD_INT 1
4685: PPUSH
4686: LD_VAR 0 1
4690: PPUSH
4691: CALL_OW 292
4695: IFFALSE 4731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 81
4704: PUSH
4705: LD_INT 2
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PPUSH
4712: CALL_OW 69
4716: PPUSH
4717: LD_VAR 0 1
4721: PPUSH
4722: CALL_OW 74
4726: PPUSH
4727: CALL_OW 115
4731: GO 4680
4733: POP
4734: POP
// end ;
4735: PPOPN 1
4737: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4738: LD_EXP 13
4742: IFFALSE 5059
4744: GO 4746
4746: DISABLE
4747: LD_INT 0
4749: PPUSH
4750: PPUSH
4751: PPUSH
4752: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4753: LD_INT 35
4755: PPUSH
4756: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4760: LD_INT 1
4762: PPUSH
4763: CALL 42350 0 1
4767: PUSH
4768: LD_INT 0
4770: EQUAL
4771: IFFALSE 4753
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 14
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: LD_INT 2
4784: PUSH
4785: LD_INT 32
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: PPUSH
4797: CALL 41954 0 2
// repeat wait ( 0 0$1 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4808: LD_EXP 69
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 33
4819: PUSH
4820: LD_INT 2
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: LD_INT 34
4829: PUSH
4830: LD_INT 32
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: IFFALSE 4801
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4847: LD_ADDR_VAR 0 2
4851: PUSH
4852: LD_EXP 69
4856: PUSH
4857: LD_INT 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 33
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: LD_INT 34
4873: PUSH
4874: LD_INT 32
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PPUSH
4885: CALL_OW 72
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4894: LD_ADDR_VAR 0 4
4898: PUSH
4899: LD_INT 5
4901: PPUSH
4902: CALL_OW 469
4906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4907: LD_INT 35
4909: PPUSH
4910: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4914: LD_ADDR_VAR 0 4
4918: PUSH
4919: LD_INT 5
4921: PPUSH
4922: CALL_OW 469
4926: ST_TO_ADDR
// tmp := 100 ;
4927: LD_ADDR_VAR 0 3
4931: PUSH
4932: LD_INT 100
4934: ST_TO_ADDR
// if pos then
4935: LD_VAR 0 4
4939: IFFALSE 4979
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 1
4956: ARRAY
4957: PPUSH
4958: LD_VAR 0 4
4962: PUSH
4963: LD_INT 2
4965: ARRAY
4966: PPUSH
4967: LD_INT 20
4969: PPUSH
4970: CALL 54290 0 4
4974: PUSH
4975: LD_INT 4
4977: ARRAY
4978: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4979: LD_VAR 0 4
4983: PUSH
4984: LD_EXP 14
4988: NOT
4989: AND
4990: PUSH
4991: LD_VAR 0 3
4995: PUSH
4996: LD_INT 10
4998: LESS
4999: AND
5000: IFFALSE 4907
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5002: LD_VAR 0 2
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 1
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 4
5020: PUSH
5021: LD_INT 2
5023: ARRAY
5024: PPUSH
5025: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5029: LD_VAR 0 2
5033: PPUSH
5034: LD_INT 198
5036: PPUSH
5037: LD_INT 113
5039: PPUSH
5040: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5044: LD_VAR 0 2
5048: PPUSH
5049: LD_INT 124
5051: PPUSH
5052: LD_INT 7
5054: PPUSH
5055: CALL_OW 171
// end ;
5059: PPOPN 4
5061: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5062: LD_EXP 6
5066: IFFALSE 7935
5068: GO 5070
5070: DISABLE
5071: LD_INT 0
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5081: LD_ADDR_VAR 0 4
5085: PUSH
5086: LD_INT 5
5088: PUSH
5089: LD_INT 6
5091: PUSH
5092: LD_INT 7
5094: PUSH
5095: LD_INT 8
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: LD_OWVAR 67
5108: ARRAY
5109: ST_TO_ADDR
// coords := [ ] ;
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: EMPTY
5116: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5117: LD_ADDR_VAR 0 6
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 0
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 1
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 0
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5164: LD_INT 1
5166: PPUSH
5167: LD_INT 14
5169: PUSH
5170: LD_INT 1
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: LD_INT 28
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 14
5187: PUSH
5188: LD_INT 1
5190: PUSH
5191: LD_INT 2
5193: PUSH
5194: LD_INT 25
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_INT 14
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: LD_INT 2
5211: PUSH
5212: LD_INT 28
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: PUSH
5221: LD_INT 14
5223: PUSH
5224: LD_INT 1
5226: PUSH
5227: LD_INT 2
5229: PUSH
5230: LD_INT 29
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: CALL 41954 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5249: LD_INT 21000
5251: PUSH
5252: LD_INT 19950
5254: PUSH
5255: LD_INT 18900
5257: PUSH
5258: LD_INT 18200
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: LD_OWVAR 67
5271: ARRAY
5272: PPUSH
5273: CALL_OW 67
// InitHc ;
5277: CALL_OW 19
// InitUc ;
5281: CALL_OW 18
// uc_side := 2 ;
5285: LD_ADDR_OWVAR 20
5289: PUSH
5290: LD_INT 2
5292: ST_TO_ADDR
// uc_nation := 2 ;
5293: LD_ADDR_OWVAR 21
5297: PUSH
5298: LD_INT 2
5300: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: EMPTY
5307: PUSH
5308: EMPTY
5309: PUSH
5310: EMPTY
5311: PUSH
5312: EMPTY
5313: PUSH
5314: EMPTY
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5323: LD_ADDR_VAR 0 3
5327: PUSH
5328: LD_VAR 0 3
5332: PPUSH
5333: LD_INT 1
5335: PPUSH
5336: LD_EXP 69
5340: PUSH
5341: LD_INT 1
5343: ARRAY
5344: PUSH
5345: LD_INT 2
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_EXP 100
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 34
5362: PUSH
5363: LD_INT 32
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: DIFF
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// for i = 1 to Difficulty do
5386: LD_ADDR_VAR 0 1
5390: PUSH
5391: DOUBLE
5392: LD_INT 1
5394: DEC
5395: ST_TO_ADDR
5396: LD_OWVAR 67
5400: PUSH
5401: FOR_TO
5402: IFFALSE 5540
// begin uc_side := 2 ;
5404: LD_ADDR_OWVAR 20
5408: PUSH
5409: LD_INT 2
5411: ST_TO_ADDR
// uc_nation := 2 ;
5412: LD_ADDR_OWVAR 21
5416: PUSH
5417: LD_INT 2
5419: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5420: LD_INT 13
5422: PPUSH
5423: LD_INT 3
5425: PPUSH
5426: LD_INT 5
5428: PPUSH
5429: LD_INT 29
5431: PPUSH
5432: LD_INT 100
5434: PPUSH
5435: CALL 53272 0 5
// un := CreateVehicle ;
5439: LD_ADDR_VAR 0 2
5443: PUSH
5444: CALL_OW 45
5448: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5449: LD_ADDR_VAR 0 3
5453: PUSH
5454: LD_VAR 0 3
5458: PPUSH
5459: LD_INT 1
5461: PUSH
5462: LD_VAR 0 3
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PUSH
5471: LD_INT 1
5473: PLUS
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: CALL 53394 0 3
5488: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 3
5496: PPUSH
5497: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: LD_INT 16
5508: PPUSH
5509: LD_INT 0
5511: PPUSH
5512: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5516: LD_VAR 0 2
5520: PPUSH
5521: LD_INT 51
5523: PPUSH
5524: LD_INT 10
5526: PPUSH
5527: CALL_OW 111
// wait ( 0 0$2 ) ;
5531: LD_INT 70
5533: PPUSH
5534: CALL_OW 67
// end ;
5538: GO 5401
5540: POP
5541: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 51
5549: PUSH
5550: LD_INT 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 75
5559: PUSH
5560: LD_INT 90
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_VAR 0 3
5578: PUSH
5579: LD_INT 1
5581: ARRAY
5582: PPUSH
5583: LD_VAR 0 5
5587: PPUSH
5588: LD_VAR 0 6
5592: PPUSH
5593: CALL 42187 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5597: LD_ADDR_VAR 0 1
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_INT 1
5609: PUSH
5610: LD_INT 3
5612: PUSH
5613: LD_INT 3
5615: PUSH
5616: LD_INT 3
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_OWVAR 67
5629: ARRAY
5630: PUSH
5631: FOR_TO
5632: IFFALSE 5732
// begin uc_side := 2 ;
5634: LD_ADDR_OWVAR 20
5638: PUSH
5639: LD_INT 2
5641: ST_TO_ADDR
// uc_nation := 2 ;
5642: LD_ADDR_OWVAR 21
5646: PUSH
5647: LD_INT 2
5649: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5650: LD_INT 0
5652: PPUSH
5653: LD_INT 17
5655: PPUSH
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL_OW 380
// un := CreateHuman ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: CALL_OW 44
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5675: LD_ADDR_VAR 0 3
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 3
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 2
5709: PPUSH
5710: CALL 53394 0 3
5714: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5715: LD_VAR 0 2
5719: PPUSH
5720: LD_INT 13
5722: PPUSH
5723: LD_INT 0
5725: PPUSH
5726: CALL_OW 49
// end ;
5730: GO 5631
5732: POP
5733: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 3
5746: PUSH
5747: LD_INT 4
5749: PUSH
5750: LD_INT 4
5752: PUSH
5753: LD_INT 4
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_OWVAR 67
5766: ARRAY
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5890
// begin uc_side := 2 ;
5771: LD_ADDR_OWVAR 20
5775: PUSH
5776: LD_INT 2
5778: ST_TO_ADDR
// uc_nation := 2 ;
5779: LD_ADDR_OWVAR 21
5783: PUSH
5784: LD_INT 2
5786: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5787: LD_INT 0
5789: PPUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 8
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 2
5807: MOD
5808: PUSH
5809: LD_INT 1
5811: PLUS
5812: ARRAY
5813: PPUSH
5814: LD_VAR 0 4
5818: PPUSH
5819: CALL_OW 380
// un := CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5833: LD_ADDR_VAR 0 3
5837: PUSH
5838: LD_VAR 0 3
5842: PPUSH
5843: LD_INT 2
5845: PUSH
5846: LD_VAR 0 3
5850: PUSH
5851: LD_INT 2
5853: ARRAY
5854: PUSH
5855: LD_INT 1
5857: PLUS
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: LD_VAR 0 2
5867: PPUSH
5868: CALL 53394 0 3
5872: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5873: LD_VAR 0 2
5877: PPUSH
5878: LD_INT 13
5880: PPUSH
5881: LD_INT 0
5883: PPUSH
5884: CALL_OW 49
// end ;
5888: GO 5768
5890: POP
5891: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5892: LD_ADDR_VAR 0 5
5896: PUSH
5897: LD_INT 67
5899: PUSH
5900: LD_INT 112
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 85
5909: PUSH
5910: LD_INT 130
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5921: LD_INT 2
5923: PPUSH
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 2
5931: ARRAY
5932: PPUSH
5933: LD_VAR 0 5
5937: PPUSH
5938: LD_VAR 0 6
5942: PPUSH
5943: CALL 42187 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: DOUBLE
5953: LD_INT 1
5955: DEC
5956: ST_TO_ADDR
5957: LD_INT 1
5959: PUSH
5960: LD_INT 2
5962: PUSH
5963: LD_INT 3
5965: PUSH
5966: LD_INT 4
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_OWVAR 67
5979: ARRAY
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6082
// begin uc_side := 2 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 2
5991: ST_TO_ADDR
// uc_nation := 2 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 2
5999: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 17
6005: PPUSH
6006: LD_VAR 0 4
6010: PPUSH
6011: CALL_OW 380
// un := CreateHuman ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: CALL_OW 44
6024: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_VAR 0 3
6034: PPUSH
6035: LD_INT 3
6037: PUSH
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 3
6045: ARRAY
6046: PUSH
6047: LD_INT 1
6049: PLUS
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PPUSH
6055: LD_VAR 0 2
6059: PPUSH
6060: CALL 53394 0 3
6064: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6065: LD_VAR 0 2
6069: PPUSH
6070: LD_INT 14
6072: PPUSH
6073: LD_INT 0
6075: PPUSH
6076: CALL_OW 49
// end ;
6080: GO 5981
6082: POP
6083: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 158
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: LD_INT 148
6101: PUSH
6102: LD_INT 158
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6113: LD_INT 3
6115: PPUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_INT 3
6123: ARRAY
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: LD_VAR 0 6
6134: PPUSH
6135: CALL 42187 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6139: LD_ADDR_VAR 0 1
6143: PUSH
6144: DOUBLE
6145: LD_INT 1
6147: DEC
6148: ST_TO_ADDR
6149: LD_INT 2
6151: PUSH
6152: LD_INT 3
6154: PUSH
6155: LD_INT 4
6157: PUSH
6158: LD_INT 4
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_OWVAR 67
6171: ARRAY
6172: PUSH
6173: FOR_TO
6174: IFFALSE 6398
// begin uc_side := 2 ;
6176: LD_ADDR_OWVAR 20
6180: PUSH
6181: LD_INT 2
6183: ST_TO_ADDR
// uc_nation := 2 ;
6184: LD_ADDR_OWVAR 21
6188: PUSH
6189: LD_INT 2
6191: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6192: LD_INT 14
6194: PPUSH
6195: LD_INT 3
6197: PPUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 5
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 1
6210: PPUSH
6211: LD_INT 2
6213: PPUSH
6214: CALL_OW 12
6218: ARRAY
6219: PPUSH
6220: LD_INT 27
6222: PUSH
6223: LD_INT 26
6225: PUSH
6226: LD_INT 28
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 1
6236: PPUSH
6237: LD_INT 3
6239: PPUSH
6240: CALL_OW 12
6244: ARRAY
6245: PPUSH
6246: LD_INT 100
6248: PPUSH
6249: CALL 53272 0 5
// un := CreateVehicle ;
6253: LD_ADDR_VAR 0 2
6257: PUSH
6258: CALL_OW 45
6262: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6263: LD_ADDR_VAR 0 3
6267: PUSH
6268: LD_VAR 0 3
6272: PPUSH
6273: LD_INT 4
6275: PUSH
6276: LD_VAR 0 3
6280: PUSH
6281: LD_INT 4
6283: ARRAY
6284: PUSH
6285: LD_INT 1
6287: PLUS
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: LD_VAR 0 2
6297: PPUSH
6298: CALL 53394 0 3
6302: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 5
6310: PPUSH
6311: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6315: LD_VAR 0 2
6319: PPUSH
6320: LD_INT 15
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// if GetControl ( un ) = control_manual then
6330: LD_VAR 0 2
6334: PPUSH
6335: CALL_OW 263
6339: PUSH
6340: LD_INT 1
6342: EQUAL
6343: IFFALSE 6374
// begin PrepareHuman ( false , 3 , skill ) ;
6345: LD_INT 0
6347: PPUSH
6348: LD_INT 3
6350: PPUSH
6351: LD_VAR 0 4
6355: PPUSH
6356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6360: CALL_OW 44
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_INT 179
6381: PPUSH
6382: LD_INT 135
6384: PPUSH
6385: CALL_OW 111
// wait ( 0 0$2 ) ;
6389: LD_INT 70
6391: PPUSH
6392: CALL_OW 67
// end ;
6396: GO 6173
6398: POP
6399: POP
// vc_chassis := 15 ;
6400: LD_ADDR_OWVAR 37
6404: PUSH
6405: LD_INT 15
6407: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: LD_VAR 0 3
6417: PPUSH
6418: LD_INT 4
6420: PUSH
6421: LD_VAR 0 3
6425: PUSH
6426: LD_INT 4
6428: ARRAY
6429: PUSH
6430: LD_INT 1
6432: PLUS
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PPUSH
6438: CALL_OW 45
6442: PPUSH
6443: CALL 53394 0 3
6447: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6448: LD_VAR 0 3
6452: PUSH
6453: LD_INT 4
6455: ARRAY
6456: PUSH
6457: LD_VAR 0 3
6461: PUSH
6462: LD_INT 4
6464: ARRAY
6465: ARRAY
6466: PPUSH
6467: LD_INT 15
6469: PPUSH
6470: LD_INT 0
6472: PPUSH
6473: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6477: LD_INT 0
6479: PPUSH
6480: LD_INT 11
6482: PPUSH
6483: LD_VAR 0 4
6487: PPUSH
6488: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6492: LD_ADDR_VAR 0 3
6496: PUSH
6497: LD_VAR 0 3
6501: PPUSH
6502: LD_INT 4
6504: PUSH
6505: LD_VAR 0 3
6509: PUSH
6510: LD_INT 4
6512: ARRAY
6513: PUSH
6514: LD_INT 1
6516: PLUS
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PPUSH
6522: CALL_OW 44
6526: PPUSH
6527: CALL 53394 0 3
6531: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6532: LD_VAR 0 3
6536: PUSH
6537: LD_INT 4
6539: ARRAY
6540: PUSH
6541: LD_VAR 0 3
6545: PUSH
6546: LD_INT 4
6548: ARRAY
6549: ARRAY
6550: PPUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_INT 4
6558: ARRAY
6559: PUSH
6560: LD_VAR 0 3
6564: PUSH
6565: LD_INT 4
6567: ARRAY
6568: PUSH
6569: LD_INT 1
6571: MINUS
6572: ARRAY
6573: PPUSH
6574: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6578: LD_ADDR_VAR 0 5
6582: PUSH
6583: LD_INT 148
6585: PUSH
6586: LD_INT 140
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: EMPTY
6594: LIST
6595: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6596: LD_INT 1
6598: PPUSH
6599: LD_VAR 0 3
6603: PUSH
6604: LD_INT 4
6606: ARRAY
6607: PPUSH
6608: LD_VAR 0 5
6612: PPUSH
6613: LD_VAR 0 6
6617: PPUSH
6618: CALL 42187 0 4
// if gensher_active then
6622: LD_EXP 18
6626: IFFALSE 7032
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6628: LD_EXP 45
6632: PPUSH
6633: LD_STRING D10-Diet-1
6635: PPUSH
6636: CALL_OW 94
// for i = 1 to 2 do
6640: LD_ADDR_VAR 0 1
6644: PUSH
6645: DOUBLE
6646: LD_INT 1
6648: DEC
6649: ST_TO_ADDR
6650: LD_INT 2
6652: PUSH
6653: FOR_TO
6654: IFFALSE 6792
// begin uc_side := 2 ;
6656: LD_ADDR_OWVAR 20
6660: PUSH
6661: LD_INT 2
6663: ST_TO_ADDR
// uc_nation := 2 ;
6664: LD_ADDR_OWVAR 21
6668: PUSH
6669: LD_INT 2
6671: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6672: LD_INT 13
6674: PPUSH
6675: LD_INT 3
6677: PPUSH
6678: LD_INT 5
6680: PPUSH
6681: LD_INT 29
6683: PPUSH
6684: LD_INT 100
6686: PPUSH
6687: CALL 53272 0 5
// un := CreateVehicle ;
6691: LD_ADDR_VAR 0 2
6695: PUSH
6696: CALL_OW 45
6700: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6701: LD_ADDR_VAR 0 3
6705: PUSH
6706: LD_VAR 0 3
6710: PPUSH
6711: LD_INT 5
6713: PUSH
6714: LD_VAR 0 3
6718: PUSH
6719: LD_INT 5
6721: ARRAY
6722: PUSH
6723: LD_INT 1
6725: PLUS
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PPUSH
6731: LD_VAR 0 2
6735: PPUSH
6736: CALL 53394 0 3
6740: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 0
6748: PPUSH
6749: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6753: LD_VAR 0 2
6757: PPUSH
6758: LD_INT 23
6760: PPUSH
6761: LD_INT 0
6763: PPUSH
6764: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6768: LD_VAR 0 2
6772: PPUSH
6773: LD_INT 85
6775: PPUSH
6776: LD_INT 152
6778: PPUSH
6779: CALL_OW 111
// wait ( 0 0$2 ) ;
6783: LD_INT 70
6785: PPUSH
6786: CALL_OW 67
// end ;
6790: GO 6653
6792: POP
6793: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6794: LD_ADDR_VAR 0 1
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_INT 2
6806: PUSH
6807: LD_INT 3
6809: PUSH
6810: LD_INT 3
6812: PUSH
6813: LD_INT 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_OWVAR 67
6826: ARRAY
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6986
// begin uc_side := 2 ;
6831: LD_ADDR_OWVAR 20
6835: PUSH
6836: LD_INT 2
6838: ST_TO_ADDR
// uc_nation := 2 ;
6839: LD_ADDR_OWVAR 21
6843: PUSH
6844: LD_INT 2
6846: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6847: LD_INT 14
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 5
6855: PPUSH
6856: LD_INT 27
6858: PUSH
6859: LD_INT 28
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: LD_INT 1
6868: PPUSH
6869: LD_INT 2
6871: PPUSH
6872: CALL_OW 12
6876: ARRAY
6877: PPUSH
6878: LD_INT 100
6880: PPUSH
6881: CALL 53272 0 5
// un := CreateVehicle ;
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: CALL_OW 45
6894: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 3
6904: PPUSH
6905: LD_INT 5
6907: PUSH
6908: LD_VAR 0 3
6912: PUSH
6913: LD_INT 5
6915: ARRAY
6916: PUSH
6917: LD_INT 1
6919: PLUS
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: LD_VAR 0 2
6929: PPUSH
6930: CALL 53394 0 3
6934: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 0
6942: PPUSH
6943: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6947: LD_VAR 0 2
6951: PPUSH
6952: LD_INT 23
6954: PPUSH
6955: LD_INT 0
6957: PPUSH
6958: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6962: LD_VAR 0 2
6966: PPUSH
6967: LD_INT 85
6969: PPUSH
6970: LD_INT 152
6972: PPUSH
6973: CALL_OW 111
// wait ( 0 0$2 ) ;
6977: LD_INT 70
6979: PPUSH
6980: CALL_OW 67
// end ;
6984: GO 6828
6986: POP
6987: POP
// coords := [ [ 97 , 143 ] ] ;
6988: LD_ADDR_VAR 0 5
6992: PUSH
6993: LD_INT 97
6995: PUSH
6996: LD_INT 143
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7006: LD_INT 1
7008: PPUSH
7009: LD_VAR 0 3
7013: PUSH
7014: LD_INT 5
7016: ARRAY
7017: PPUSH
7018: LD_VAR 0 5
7022: PPUSH
7023: LD_VAR 0 6
7027: PPUSH
7028: CALL 42187 0 4
// end ; Wait ( 13 13$00 ) ;
7032: LD_INT 27300
7034: PPUSH
7035: CALL_OW 67
// tmp := [ ] ;
7039: LD_ADDR_VAR 0 3
7043: PUSH
7044: EMPTY
7045: ST_TO_ADDR
// w := 1 ;
7046: LD_ADDR_VAR 0 7
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// repeat tmp := [ ] ;
7054: LD_ADDR_VAR 0 3
7058: PUSH
7059: EMPTY
7060: ST_TO_ADDR
// if w mod 4 = 0 then
7061: LD_VAR 0 7
7065: PUSH
7066: LD_INT 4
7068: MOD
7069: PUSH
7070: LD_INT 0
7072: EQUAL
7073: IFFALSE 7160
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7075: LD_ADDR_VAR 0 8
7079: PUSH
7080: LD_INT 11
7082: PUSH
7083: LD_INT 1
7085: PUSH
7086: LD_INT 2
7088: PUSH
7089: LD_INT 24
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 11
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 24
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 11
7118: PUSH
7119: LD_INT 1
7121: PUSH
7122: LD_INT 2
7124: PUSH
7125: LD_INT 24
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 11
7136: PUSH
7137: LD_INT 1
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: LD_INT 24
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: LIST
7156: LIST
7157: ST_TO_ADDR
7158: GO 7262
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7160: LD_ADDR_VAR 0 8
7164: PUSH
7165: LD_INT 14
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: LD_INT 2
7173: PUSH
7174: LD_INT 28
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: PUSH
7183: LD_INT 14
7185: PUSH
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 25
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 14
7203: PUSH
7204: LD_INT 1
7206: PUSH
7207: LD_INT 2
7209: PUSH
7210: LD_INT 28
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 14
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: LD_INT 2
7227: PUSH
7228: LD_INT 29
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 11
7239: PUSH
7240: LD_INT 1
7242: PUSH
7243: LD_INT 2
7245: PUSH
7246: LD_INT 24
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: ST_TO_ADDR
// if w mod 3 = 0 then
7262: LD_VAR 0 7
7266: PUSH
7267: LD_INT 3
7269: MOD
7270: PUSH
7271: LD_INT 0
7273: EQUAL
7274: IFFALSE 7350
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7276: LD_ADDR_VAR 0 8
7280: PUSH
7281: LD_VAR 0 8
7285: PPUSH
7286: LD_INT 1
7288: PUSH
7289: LD_VAR 0 8
7293: PUSH
7294: LD_VAR 0 1
7298: ARRAY
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 14
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: LD_INT 2
7316: PUSH
7317: LD_INT 25
7319: PUSH
7320: LD_INT 28
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 12
7337: ARRAY
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL 53394 0 3
7349: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7350: LD_INT 1
7352: PPUSH
7353: LD_VAR 0 8
7357: PPUSH
7358: CALL 41954 0 2
// if GetSide ( ar_dep_w ) = 2 then
7362: LD_INT 45
7364: PPUSH
7365: CALL_OW 255
7369: PUSH
7370: LD_INT 2
7372: EQUAL
7373: IFFALSE 7458
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7375: LD_ADDR_VAR 0 8
7379: PUSH
7380: LD_INT 14
7382: PUSH
7383: LD_INT 1
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: LD_INT 28
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 14
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: LD_INT 2
7406: PUSH
7407: LD_INT 27
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 14
7418: PUSH
7419: LD_INT 1
7421: PUSH
7422: LD_INT 2
7424: PUSH
7425: LD_INT 27
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7439: LD_INT 2
7441: PPUSH
7442: LD_VAR 0 8
7446: PPUSH
7447: CALL 41954 0 2
// wait ( 0 0$50 ) ;
7451: LD_INT 1750
7453: PPUSH
7454: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7458: LD_INT 35
7460: PPUSH
7461: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7465: LD_EXP 69
7469: PUSH
7470: LD_INT 1
7472: ARRAY
7473: PPUSH
7474: LD_INT 3
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 34
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 34
7492: PUSH
7493: LD_EXP 100
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: EMPTY
7508: LIST
7509: LIST
7510: PPUSH
7511: CALL_OW 72
7515: PUSH
7516: LD_INT 4
7518: GREATEREQUAL
7519: IFFALSE 7458
// wait ( 0 0$10 ) ;
7521: LD_INT 350
7523: PPUSH
7524: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: LD_EXP 69
7537: PUSH
7538: LD_INT 1
7540: ARRAY
7541: PPUSH
7542: LD_INT 3
7544: PUSH
7545: LD_INT 2
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 32
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 34
7560: PUSH
7561: LD_EXP 100
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PPUSH
7579: CALL_OW 72
7583: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7584: LD_INT 100
7586: PPUSH
7587: CALL_OW 13
7591: PUSH
7592: LD_INT 50
7594: LESS
7595: IFFALSE 7628
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7597: LD_ADDR_VAR 0 5
7601: PUSH
7602: LD_INT 55
7604: PUSH
7605: LD_INT 7
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 75
7614: PUSH
7615: LD_INT 90
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: ST_TO_ADDR
7626: GO 7657
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7628: LD_ADDR_VAR 0 5
7632: PUSH
7633: LD_INT 128
7635: PUSH
7636: LD_INT 94
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 180
7645: PUSH
7646: LD_INT 135
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: ST_TO_ADDR
// if w mod 4 = 0 then
7657: LD_VAR 0 7
7661: PUSH
7662: LD_INT 4
7664: MOD
7665: PUSH
7666: LD_INT 0
7668: EQUAL
7669: IFFALSE 7700
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7671: LD_ADDR_VAR 0 5
7675: PUSH
7676: LD_INT 91
7678: PUSH
7679: LD_INT 58
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 117
7688: PUSH
7689: LD_INT 107
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_VAR 0 5
7709: PUSH
7710: LD_INT 1
7712: ARRAY
7713: PPUSH
7714: LD_VAR 0 5
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 60
7741: PUSH
7742: EMPTY
7743: LIST
7744: PPUSH
7745: CALL_OW 72
7749: PUSH
7750: LD_INT 0
7752: EQUAL
7753: IFFALSE 7727
// repeat wait ( 0 0$2 ) ;
7755: LD_INT 70
7757: PPUSH
7758: CALL_OW 67
// for i in tmp do
7762: LD_ADDR_VAR 0 1
7766: PUSH
7767: LD_VAR 0 3
7771: PUSH
7772: FOR_IN
7773: IFFALSE 7862
// if GetChassis ( i ) = ar_hovercraft then
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 265
7784: PUSH
7785: LD_INT 11
7787: EQUAL
7788: IFFALSE 7826
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: PPUSH
7810: LD_VAR 0 1
7814: PPUSH
7815: CALL_OW 74
7819: PPUSH
7820: CALL 81290 0 2
7824: GO 7860
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7826: LD_VAR 0 1
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: PPUSH
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 74
7855: PPUSH
7856: CALL_OW 115
7860: GO 7772
7862: POP
7863: POP
// until not tmp ;
7864: LD_VAR 0 3
7868: NOT
7869: IFFALSE 7755
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7871: LD_INT 22050
7873: PPUSH
7874: LD_INT 28350
7876: PPUSH
7877: CALL_OW 12
7881: PPUSH
7882: CALL_OW 67
// w := w + 1 ;
7886: LD_ADDR_VAR 0 7
7890: PUSH
7891: LD_VAR 0 7
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7900: LD_INT 94
7902: PPUSH
7903: CALL_OW 301
7907: PUSH
7908: LD_EXP 50
7912: PUSH
7913: LD_INT 1
7915: ARRAY
7916: PPUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PPUSH
7927: CALL_OW 72
7931: NOT
7932: OR
7933: IFFALSE 7054
// end ;
7935: PPOPN 8
7937: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7938: LD_INT 204
7940: IFFALSE 8406
7942: GO 7944
7944: DISABLE
7945: LD_INT 0
7947: PPUSH
7948: PPUSH
7949: PPUSH
7950: PPUSH
// begin enable ;
7951: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7952: LD_INT 35
7954: PPUSH
7955: LD_INT 1190
7957: PPUSH
7958: CALL_OW 12
7962: PPUSH
7963: CALL_OW 67
// tmp := [ ] ;
7967: LD_ADDR_VAR 0 2
7971: PUSH
7972: EMPTY
7973: ST_TO_ADDR
// uc_side := 8 ;
7974: LD_ADDR_OWVAR 20
7978: PUSH
7979: LD_INT 8
7981: ST_TO_ADDR
// uc_nation := 2 ;
7982: LD_ADDR_OWVAR 21
7986: PUSH
7987: LD_INT 2
7989: ST_TO_ADDR
// InitHc ;
7990: CALL_OW 19
// for i = 1 to 3 do
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: DOUBLE
8000: LD_INT 1
8002: DEC
8003: ST_TO_ADDR
8004: LD_INT 3
8006: PUSH
8007: FOR_TO
8008: IFFALSE 8135
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8010: LD_INT 13
8012: PUSH
8013: LD_INT 14
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: LD_INT 1
8022: PPUSH
8023: LD_INT 2
8025: PPUSH
8026: CALL_OW 12
8030: ARRAY
8031: PPUSH
8032: LD_INT 3
8034: PPUSH
8035: LD_INT 5
8037: PPUSH
8038: LD_INT 27
8040: PUSH
8041: LD_INT 28
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 1
8050: PPUSH
8051: LD_INT 2
8053: PPUSH
8054: CALL_OW 12
8058: ARRAY
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 53272 0 5
// un := CreateVehicle ;
8067: LD_ADDR_VAR 0 3
8071: PUSH
8072: CALL_OW 45
8076: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8077: LD_VAR 0 3
8081: PPUSH
8082: LD_INT 4
8084: PPUSH
8085: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8089: LD_VAR 0 3
8093: PPUSH
8094: LD_INT 15
8096: PPUSH
8097: LD_INT 0
8099: PPUSH
8100: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 2
8113: PPUSH
8114: LD_VAR 0 2
8118: PUSH
8119: LD_INT 1
8121: PLUS
8122: PPUSH
8123: LD_VAR 0 3
8127: PPUSH
8128: CALL_OW 1
8132: ST_TO_ADDR
// end ;
8133: GO 8007
8135: POP
8136: POP
// for i = 1 to 4 do
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: DOUBLE
8143: LD_INT 1
8145: DEC
8146: ST_TO_ADDR
8147: LD_INT 4
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8222
// begin PrepareHuman ( false , 1 , 6 ) ;
8153: LD_INT 0
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 6
8161: PPUSH
8162: CALL_OW 380
// un := CreateHuman ;
8166: LD_ADDR_VAR 0 3
8170: PUSH
8171: CALL_OW 44
8175: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8176: LD_VAR 0 3
8180: PPUSH
8181: LD_INT 15
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8191: LD_ADDR_VAR 0 2
8195: PUSH
8196: LD_VAR 0 2
8200: PPUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 1
8208: PLUS
8209: PPUSH
8210: LD_VAR 0 3
8214: PPUSH
8215: CALL_OW 1
8219: ST_TO_ADDR
// end ;
8220: GO 8150
8222: POP
8223: POP
// wait ( 0 0$3 ) ;
8224: LD_INT 105
8226: PPUSH
8227: CALL_OW 67
// for i in tmp do
8231: LD_ADDR_VAR 0 1
8235: PUSH
8236: LD_VAR 0 2
8240: PUSH
8241: FOR_IN
8242: IFFALSE 8310
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8244: LD_VAR 0 1
8248: PPUSH
8249: CALL_OW 257
8253: PUSH
8254: LD_INT 1
8256: EQUAL
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 247
8267: PUSH
8268: LD_INT 2
8270: EQUAL
8271: OR
8272: IFFALSE 8308
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8274: LD_VAR 0 1
8278: PPUSH
8279: LD_INT 81
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PPUSH
8289: CALL_OW 69
8293: PPUSH
8294: LD_VAR 0 1
8298: PPUSH
8299: CALL_OW 74
8303: PPUSH
8304: CALL_OW 115
8308: GO 8241
8310: POP
8311: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8312: LD_VAR 0 2
8316: PPUSH
8317: LD_INT 210
8319: PPUSH
8320: LD_INT 178
8322: PPUSH
8323: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8327: LD_ADDR_VAR 0 4
8331: PUSH
8332: LD_INT 10
8334: PPUSH
8335: LD_INT 22
8337: PUSH
8338: LD_INT 8
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PPUSH
8345: CALL_OW 70
8349: ST_TO_ADDR
// if x then
8350: LD_VAR 0 4
8354: IFFALSE 8382
// for i in x do
8356: LD_ADDR_VAR 0 1
8360: PUSH
8361: LD_VAR 0 4
8365: PUSH
8366: FOR_IN
8367: IFFALSE 8380
// RemoveUnit ( i ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 64
8378: GO 8366
8380: POP
8381: POP
// wait ( 0 0$1 ) ;
8382: LD_INT 35
8384: PPUSH
8385: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8389: LD_INT 22
8391: PUSH
8392: LD_INT 8
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 69
8403: NOT
8404: IFFALSE 8312
// end ;
8406: PPOPN 4
8408: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8409: LD_INT 22
8411: PUSH
8412: LD_INT 2
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 34
8421: PUSH
8422: LD_INT 31
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PUSH
8429: LD_INT 3
8431: PUSH
8432: LD_INT 24
8434: PUSH
8435: LD_INT 1000
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: PPUSH
8451: CALL_OW 69
8455: IFFALSE 8558
8457: GO 8459
8459: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8460: LD_INT 45
8462: PPUSH
8463: CALL_OW 302
8467: PUSH
8468: LD_INT 45
8470: PPUSH
8471: CALL_OW 255
8475: AND
8476: IFFALSE 8519
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 34
8490: PUSH
8491: LD_INT 31
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: PPUSH
8507: LD_INT 18
8509: PPUSH
8510: LD_INT 8
8512: PPUSH
8513: CALL_OW 111
8517: GO 8558
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8519: LD_INT 22
8521: PUSH
8522: LD_INT 2
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 34
8531: PUSH
8532: LD_INT 31
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: PPUSH
8548: LD_INT 106
8550: PPUSH
8551: LD_INT 14
8553: PPUSH
8554: CALL_OW 111
// end ; end_of_file
8558: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// InGameOn ;
8567: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8571: LD_EXP 21
8575: PPUSH
8576: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8580: LD_INT 2
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_INT 1
8588: PPUSH
8589: LD_INT 1
8591: PPUSH
8592: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 22
8603: PUSH
8604: LD_INT 1
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 1
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 22
8637: PUSH
8638: LD_INT 1
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: LD_INT 34
8647: PUSH
8648: LD_INT 11
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: PPUSH
8659: CALL_OW 69
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: ST_TO_ADDR
// for i = 1 to tmp do
8668: LD_ADDR_VAR 0 6
8672: PUSH
8673: DOUBLE
8674: LD_INT 1
8676: DEC
8677: ST_TO_ADDR
8678: LD_VAR 0 2
8682: PUSH
8683: FOR_TO
8684: IFFALSE 8731
// begin if i = 5 then
8686: LD_VAR 0 6
8690: PUSH
8691: LD_INT 5
8693: EQUAL
8694: IFFALSE 8698
// break ;
8696: GO 8731
// sols := Replace ( sols , i , tmp [ i ] ) ;
8698: LD_ADDR_VAR 0 5
8702: PUSH
8703: LD_VAR 0 5
8707: PPUSH
8708: LD_VAR 0 6
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 6
8722: ARRAY
8723: PPUSH
8724: CALL_OW 1
8728: ST_TO_ADDR
// end ;
8729: GO 8683
8731: POP
8732: POP
// tmp := ar_force_tmp ;
8733: LD_ADDR_VAR 0 2
8737: PUSH
8738: LD_EXP 40
8742: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8743: LD_VAR 0 2
8747: PUSH
8748: LD_INT 1
8750: ARRAY
8751: PPUSH
8752: LD_INT 108
8754: PPUSH
8755: LD_INT 139
8757: PPUSH
8758: LD_INT 0
8760: PPUSH
8761: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8765: LD_VAR 0 2
8769: PUSH
8770: LD_INT 1
8772: ARRAY
8773: PPUSH
8774: LD_EXP 21
8778: PPUSH
8779: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8783: LD_VAR 0 2
8787: PUSH
8788: LD_INT 2
8790: ARRAY
8791: PPUSH
8792: LD_INT 114
8794: PPUSH
8795: LD_INT 132
8797: PPUSH
8798: LD_INT 0
8800: PPUSH
8801: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8805: LD_VAR 0 2
8809: PUSH
8810: LD_INT 3
8812: ARRAY
8813: PPUSH
8814: LD_INT 115
8816: PPUSH
8817: LD_INT 132
8819: PPUSH
8820: LD_INT 0
8822: PPUSH
8823: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8827: LD_VAR 0 2
8831: PUSH
8832: LD_INT 2
8834: ARRAY
8835: PUSH
8836: LD_VAR 0 2
8840: PUSH
8841: LD_INT 3
8843: ARRAY
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 83
8860: PPUSH
8861: LD_INT 123
8863: PPUSH
8864: CALL_OW 111
// Wait ( 0 0$01 ) ;
8868: LD_INT 35
8870: PPUSH
8871: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8875: LD_INT 90
8877: PPUSH
8878: LD_INT 144
8880: PPUSH
8881: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8885: LD_VAR 0 5
8889: PPUSH
8890: LD_INT 88
8892: PPUSH
8893: LD_INT 129
8895: PPUSH
8896: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8900: LD_ADDR_VAR 0 3
8904: PUSH
8905: LD_INT 92
8907: PUSH
8908: LD_INT 131
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 88
8917: PUSH
8918: LD_INT 127
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 91
8927: PUSH
8928: LD_INT 132
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 92
8937: PUSH
8938: LD_INT 134
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: ST_TO_ADDR
// for i = 1 to sols do
8951: LD_ADDR_VAR 0 6
8955: PUSH
8956: DOUBLE
8957: LD_INT 1
8959: DEC
8960: ST_TO_ADDR
8961: LD_VAR 0 5
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9040
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8969: LD_VAR 0 5
8973: PUSH
8974: LD_VAR 0 6
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9014: LD_VAR 0 5
9018: PUSH
9019: LD_VAR 0 6
9023: ARRAY
9024: PPUSH
9025: CALL_OW 197
// AddComHold ( sols ) ;
9029: LD_VAR 0 5
9033: PPUSH
9034: CALL_OW 200
// end ;
9038: GO 8966
9040: POP
9041: POP
// repeat wait ( 0 0$1 ) ;
9042: LD_INT 35
9044: PPUSH
9045: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9049: LD_VAR 0 5
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: LD_INT 92
9060: PPUSH
9061: LD_INT 131
9063: PPUSH
9064: CALL_OW 297
9068: PUSH
9069: LD_INT 4
9071: LESS
9072: IFFALSE 9042
// CenterOnXY ( 96 , 139 ) ;
9074: LD_INT 96
9076: PPUSH
9077: LD_INT 139
9079: PPUSH
9080: CALL_OW 84
// wait ( 0 0$3 ) ;
9084: LD_INT 105
9086: PPUSH
9087: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 135
9096: PPUSH
9097: LD_INT 1
9099: PPUSH
9100: LD_INT 25
9102: NEG
9103: PPUSH
9104: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9108: LD_VAR 0 2
9112: PUSH
9113: LD_INT 2
9115: ARRAY
9116: PPUSH
9117: LD_VAR 0 2
9121: PUSH
9122: LD_INT 1
9124: ARRAY
9125: PPUSH
9126: CALL_OW 250
9130: PUSH
9131: LD_INT 3
9133: PLUS
9134: PPUSH
9135: LD_VAR 0 2
9139: PUSH
9140: LD_INT 1
9142: ARRAY
9143: PPUSH
9144: CALL_OW 251
9148: PPUSH
9149: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9153: LD_VAR 0 2
9157: PUSH
9158: LD_INT 3
9160: ARRAY
9161: PPUSH
9162: LD_INT 7
9164: PPUSH
9165: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9169: LD_VAR 0 2
9173: PUSH
9174: LD_INT 2
9176: ARRAY
9177: PPUSH
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9191: LD_INT 35
9193: PPUSH
9194: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9198: LD_VAR 0 2
9202: PUSH
9203: LD_INT 1
9205: ARRAY
9206: PPUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 2
9214: ARRAY
9215: PPUSH
9216: CALL_OW 296
9220: PUSH
9221: LD_INT 5
9223: LESS
9224: IFFALSE 9191
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 1
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 2
9239: PUSH
9240: LD_INT 2
9242: ARRAY
9243: PPUSH
9244: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9248: LD_VAR 0 2
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D1a-Merc1-1
9259: PPUSH
9260: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9264: LD_VAR 0 2
9268: PUSH
9269: LD_INT 2
9271: ARRAY
9272: PPUSH
9273: LD_STRING D1a-FMerc2-1
9275: PPUSH
9276: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9280: LD_VAR 0 2
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_VAR 0 2
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9302: LD_VAR 0 2
9306: PUSH
9307: LD_INT 1
9309: ARRAY
9310: PPUSH
9311: LD_INT 500
9313: PPUSH
9314: CALL_OW 234
// wait ( 0 0$2 ) ;
9318: LD_INT 70
9320: PPUSH
9321: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_INT 2
9336: PPUSH
9337: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9341: LD_INT 10
9343: PPUSH
9344: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: ARRAY
9356: PPUSH
9357: LD_STRING D1a-Merc1-2
9359: PPUSH
9360: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9364: LD_INT 7
9366: PPUSH
9367: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9371: LD_VAR 0 2
9375: PUSH
9376: LD_INT 1
9378: ARRAY
9379: PPUSH
9380: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9384: LD_VAR 0 2
9388: PUSH
9389: LD_INT 2
9391: ARRAY
9392: PPUSH
9393: LD_INT 10
9395: PPUSH
9396: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9400: LD_VAR 0 2
9404: PUSH
9405: LD_INT 2
9407: ARRAY
9408: PPUSH
9409: LD_STRING D1a-FMerc2-2
9411: PPUSH
9412: CALL_OW 88
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9423: LD_INT 7
9425: PPUSH
9426: CALL_OW 85
// wait ( 0 0$2 ) ;
9430: LD_INT 70
9432: PPUSH
9433: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9437: LD_EXP 44
9441: PPUSH
9442: LD_STRING D1a-Saliba-1
9444: PPUSH
9445: CALL_OW 91
// KillUnit ( Saliba ) ;
9449: LD_EXP 44
9453: PPUSH
9454: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9458: LD_VAR 0 2
9462: PUSH
9463: LD_INT 3
9465: ARRAY
9466: PPUSH
9467: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9471: LD_EXP 21
9475: PPUSH
9476: CALL_OW 85
// wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 88
9494: PPUSH
9495: LD_INT 141
9497: PPUSH
9498: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9502: LD_VAR 0 5
9506: PPUSH
9507: LD_INT 70
9509: PPUSH
9510: CALL_OW 202
// wait ( 0 0$2 ) ;
9514: LD_INT 70
9516: PPUSH
9517: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9521: LD_INT 2
9523: PPUSH
9524: LD_INT 1
9526: PPUSH
9527: LD_INT 2
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: CALL_OW 80
// InGameOff ;
9537: CALL_OW 9
// ComWalk ( sols ) ;
9541: LD_VAR 0 5
9545: PPUSH
9546: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9550: LD_STRING M1
9552: PPUSH
9553: CALL_OW 337
// game_speed := 4 ;
9557: LD_ADDR_OWVAR 65
9561: PUSH
9562: LD_INT 4
9564: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9565: LD_INT 111
9567: PPUSH
9568: LD_INT 135
9570: PPUSH
9571: LD_INT 1
9573: PPUSH
9574: CALL_OW 331
// SaveForQuickRestart ;
9578: CALL_OW 22
// ar_run := true ;
9582: LD_ADDR_EXP 5
9586: PUSH
9587: LD_INT 1
9589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9590: LD_INT 35
9592: PPUSH
9593: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9597: LD_INT 22
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_INT 7
9612: PUSH
9613: LD_INT 10
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PPUSH
9625: CALL_OW 69
9629: PUSH
9630: LD_INT 7
9632: PPUSH
9633: CALL_OW 256
9637: PUSH
9638: LD_INT 999
9640: LESS
9641: OR
9642: IFFALSE 9590
// if GetSide ( ar_dep_s ) = 2 then
9644: LD_INT 7
9646: PPUSH
9647: CALL_OW 255
9651: PUSH
9652: LD_INT 2
9654: EQUAL
9655: IFFALSE 9667
// SetSide ( ar_dep_s , 1 ) ;
9657: LD_INT 7
9659: PPUSH
9660: LD_INT 1
9662: PPUSH
9663: CALL_OW 235
// end ;
9667: LD_VAR 0 1
9671: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9672: LD_EXP 5
9676: IFFALSE 10036
9678: GO 9680
9680: DISABLE
9681: LD_INT 0
9683: PPUSH
9684: PPUSH
9685: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_EXP 40
9695: PUSH
9696: LD_EXP 36
9700: PPUSH
9701: LD_INT 2
9703: PUSH
9704: LD_INT 21
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 21
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 72
9733: ADD
9734: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 5
9742: PPUSH
9743: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9747: LD_INT 5
9749: PPUSH
9750: LD_INT 1
9752: PPUSH
9753: CALL_OW 343
// k := 1 ;
9757: LD_ADDR_VAR 0 3
9761: PUSH
9762: LD_INT 1
9764: ST_TO_ADDR
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 9861
// begin if IsInUnit ( i ) then
9778: LD_VAR 0 1
9782: PPUSH
9783: CALL_OW 310
9787: IFFALSE 9798
// ComExitBuilding ( i ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: CALL_OW 122
// if GetClass ( i ) = 3 then
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 257
9807: PUSH
9808: LD_INT 3
9810: EQUAL
9811: IFFALSE 9847
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9813: LD_VAR 0 1
9817: PPUSH
9818: LD_EXP 41
9822: PUSH
9823: LD_VAR 0 3
9827: ARRAY
9828: PPUSH
9829: CALL_OW 180
// k := k + 1 ;
9833: LD_ADDR_VAR 0 3
9837: PUSH
9838: LD_VAR 0 3
9842: PUSH
9843: LD_INT 1
9845: PLUS
9846: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9847: LD_VAR 0 1
9851: PPUSH
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 173
// end ;
9859: GO 9775
9861: POP
9862: POP
// ar_patrol := true ;
9863: LD_ADDR_EXP 7
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9871: LD_INT 10
9873: PPUSH
9874: CALL_OW 67
// for i in tmp do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_VAR 0 2
9887: PUSH
9888: FOR_IN
9889: IFFALSE 9917
// if not HasTask ( i ) then
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 314
9900: NOT
9901: IFFALSE 9915
// ComMoveToArea ( i , escape_area ) ;
9903: LD_VAR 0 1
9907: PPUSH
9908: LD_INT 10
9910: PPUSH
9911: CALL_OW 113
9915: GO 9888
9917: POP
9918: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9919: LD_ADDR_VAR 0 3
9923: PUSH
9924: LD_VAR 0 2
9928: PPUSH
9929: LD_INT 95
9931: PUSH
9932: LD_INT 10
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PPUSH
9939: CALL_OW 72
9943: ST_TO_ADDR
// if k then
9944: LD_VAR 0 3
9948: IFFALSE 10017
// for i in k do
9950: LD_ADDR_VAR 0 1
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 10015
// begin if IsInUnit ( i ) then
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 310
9972: IFFALSE 9988
// RemoveUnit ( IsInUnit ( i ) ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: CALL_OW 310
9983: PPUSH
9984: CALL_OW 64
// RemoveUnit ( i ) ;
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 64
// tmp := tmp diff i ;
9997: LD_ADDR_VAR 0 2
10001: PUSH
10002: LD_VAR 0 2
10006: PUSH
10007: LD_VAR 0 1
10011: DIFF
10012: ST_TO_ADDR
// end ;
10013: GO 9960
10015: POP
10016: POP
// until tmp = [ ] ;
10017: LD_VAR 0 2
10021: PUSH
10022: EMPTY
10023: EQUAL
10024: IFFALSE 9871
// ChangeSideFog ( 5 , 5 ) ;
10026: LD_INT 5
10028: PPUSH
10029: LD_INT 5
10031: PPUSH
10032: CALL_OW 343
// end ;
10036: PPOPN 3
10038: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10039: LD_EXP 7
10043: IFFALSE 10333
10045: GO 10047
10047: DISABLE
10048: LD_INT 0
10050: PPUSH
10051: PPUSH
10052: PPUSH
// begin uc_side := 2 ;
10053: LD_ADDR_OWVAR 20
10057: PUSH
10058: LD_INT 2
10060: ST_TO_ADDR
// uc_nation := 2 ;
10061: LD_ADDR_OWVAR 21
10065: PUSH
10066: LD_INT 2
10068: ST_TO_ADDR
// InitHc ;
10069: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10073: LD_INT 1
10075: PPUSH
10076: LD_INT 1
10078: PPUSH
10079: LD_INT 6
10081: PPUSH
10082: CALL_OW 380
// un := CreateHuman ;
10086: LD_ADDR_VAR 0 2
10090: PUSH
10091: CALL_OW 44
10095: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10096: LD_INT 14
10098: PPUSH
10099: LD_INT 1
10101: PPUSH
10102: LD_INT 1
10104: PPUSH
10105: LD_INT 27
10107: PPUSH
10108: LD_INT 98
10110: PPUSH
10111: CALL 53272 0 5
// veh := CreateVehicle ;
10115: LD_ADDR_VAR 0 3
10119: PUSH
10120: CALL_OW 45
10124: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_INT 4
10132: PPUSH
10133: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10137: LD_VAR 0 3
10141: PPUSH
10142: LD_INT 179
10144: PPUSH
10145: LD_INT 135
10147: PPUSH
10148: LD_INT 0
10150: PPUSH
10151: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10155: LD_VAR 0 2
10159: PPUSH
10160: LD_VAR 0 3
10164: PPUSH
10165: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10169: LD_VAR 0 2
10173: PPUSH
10174: LD_INT 126
10176: PPUSH
10177: LD_INT 133
10179: PPUSH
10180: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10184: LD_INT 10
10186: PPUSH
10187: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10191: LD_INT 1
10193: PPUSH
10194: LD_VAR 0 3
10198: PPUSH
10199: CALL_OW 292
10203: PUSH
10204: LD_VAR 0 3
10208: PPUSH
10209: LD_INT 7
10211: PPUSH
10212: CALL_OW 296
10216: PUSH
10217: LD_INT 9
10219: LESS
10220: OR
10221: IFFALSE 10184
// ComHold ( veh ) ;
10223: LD_VAR 0 3
10227: PPUSH
10228: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_STRING D2aa-Ar1-1
10239: PPUSH
10240: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: LD_INT 177
10251: PPUSH
10252: LD_INT 96
10254: PPUSH
10255: CALL_OW 111
// AddComExitVehicle ( un ) ;
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10268: LD_INT 35
10270: PPUSH
10271: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_INT 204
10282: PPUSH
10283: CALL_OW 296
10287: PUSH
10288: LD_INT 15
10290: LESS
10291: IFFALSE 10268
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10293: LD_ADDR_EXP 50
10297: PUSH
10298: LD_EXP 50
10302: PPUSH
10303: LD_INT 3
10305: PUSH
10306: LD_EXP 50
10310: PUSH
10311: LD_INT 3
10313: ARRAY
10314: PUSH
10315: LD_INT 1
10317: PLUS
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PPUSH
10323: LD_VAR 0 2
10327: PPUSH
10328: CALL 53394 0 3
10332: ST_TO_ADDR
// end ;
10333: PPOPN 3
10335: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10336: LD_INT 7
10338: PPUSH
10339: CALL_OW 255
10343: PUSH
10344: LD_INT 1
10346: EQUAL
10347: PUSH
10348: LD_INT 7
10350: PPUSH
10351: CALL_OW 301
10355: OR
10356: IFFALSE 12764
10358: GO 10360
10360: DISABLE
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_EXP 36
10374: PPUSH
10375: LD_INT 21
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PPUSH
10385: CALL_OW 72
10389: PUSH
10390: FOR_IN
10391: IFFALSE 10407
// SetSide ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 235
10405: GO 10390
10407: POP
10408: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10409: LD_ADDR_VAR 0 2
10413: PUSH
10414: LD_INT 46
10416: PUSH
10417: LD_INT 41
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: LD_INT 50
10426: PUSH
10427: LD_INT 25
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 57
10436: PUSH
10437: LD_INT 75
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 75
10446: PUSH
10447: LD_INT 89
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 51
10456: PUSH
10457: LD_INT 45
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 95
10466: PUSH
10467: LD_INT 95
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: LD_INT 84
10476: PUSH
10477: LD_INT 77
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 101
10486: PUSH
10487: LD_INT 76
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 118
10496: PUSH
10497: LD_INT 81
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 139
10506: PUSH
10507: LD_INT 97
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PUSH
10514: LD_INT 129
10516: PUSH
10517: LD_INT 114
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 154
10526: PUSH
10527: LD_INT 111
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: ST_TO_ADDR
// base_captured := true ;
10548: LD_ADDR_EXP 6
10552: PUSH
10553: LD_INT 1
10555: ST_TO_ADDR
// DialogueOn ;
10556: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10560: LD_EXP 21
10564: PPUSH
10565: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10569: LD_EXP 21
10573: PPUSH
10574: LD_STRING D2-JMM-1
10576: PPUSH
10577: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10581: LD_EXP 30
10585: PPUSH
10586: LD_STRING D2-Pow-1
10588: PPUSH
10589: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10593: LD_EXP 21
10597: PPUSH
10598: LD_STRING D2-JMM-2
10600: PPUSH
10601: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10605: LD_EXP 30
10609: PPUSH
10610: LD_STRING D2-Pow-2
10612: PPUSH
10613: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10617: LD_EXP 21
10621: PPUSH
10622: LD_STRING D2-JMM-3
10624: PPUSH
10625: CALL_OW 88
// DialogueOff ;
10629: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10633: LD_STRING M2
10635: PPUSH
10636: CALL_OW 337
// Wait ( 0 0$2 ) ;
10640: LD_INT 70
10642: PPUSH
10643: CALL_OW 67
// if IsOk ( Gary ) then
10647: LD_EXP 32
10651: PPUSH
10652: CALL_OW 302
10656: IFFALSE 10670
// Say ( Gary , D2a-Gary-1 ) ;
10658: LD_EXP 32
10662: PPUSH
10663: LD_STRING D2a-Gary-1
10665: PPUSH
10666: CALL_OW 88
// if IsOk ( Bobby ) then
10670: LD_EXP 24
10674: PPUSH
10675: CALL_OW 302
10679: IFFALSE 10693
// Say ( Bobby , D2a-Bobby-1 ) ;
10681: LD_EXP 24
10685: PPUSH
10686: LD_STRING D2a-Bobby-1
10688: PPUSH
10689: CALL_OW 88
// if IsOk ( Cyrus ) then
10693: LD_EXP 25
10697: PPUSH
10698: CALL_OW 302
10702: IFFALSE 10716
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10704: LD_EXP 25
10708: PPUSH
10709: LD_STRING D2a-Cyrus-1
10711: PPUSH
10712: CALL_OW 88
// if IsOk ( Lisa ) then
10716: LD_EXP 22
10720: PPUSH
10721: CALL_OW 302
10725: IFFALSE 10739
// Say ( Lisa , D2a-Lisa-1 ) ;
10727: LD_EXP 22
10731: PPUSH
10732: LD_STRING D2a-Lisa-1
10734: PPUSH
10735: CALL_OW 88
// if IsOk ( Frank ) then
10739: LD_EXP 33
10743: PPUSH
10744: CALL_OW 302
10748: IFFALSE 10762
// Say ( Frank , D2a-Frank-1 ) ;
10750: LD_EXP 33
10754: PPUSH
10755: LD_STRING D2a-Frank-1
10757: PPUSH
10758: CALL_OW 88
// if IsOk ( Cornel ) then
10762: LD_EXP 31
10766: PPUSH
10767: CALL_OW 302
10771: IFFALSE 10785
// Say ( Cornel , D2a-Corn-1 ) ;
10773: LD_EXP 31
10777: PPUSH
10778: LD_STRING D2a-Corn-1
10780: PPUSH
10781: CALL_OW 88
// if IsOk ( Donaldson ) then
10785: LD_EXP 23
10789: PPUSH
10790: CALL_OW 302
10794: IFFALSE 10808
// Say ( Donaldson , D2a-Don-1 ) ;
10796: LD_EXP 23
10800: PPUSH
10801: LD_STRING D2a-Don-1
10803: PPUSH
10804: CALL_OW 88
// if IsOk ( Brown ) then
10808: LD_EXP 27
10812: PPUSH
10813: CALL_OW 302
10817: IFFALSE 10831
// Say ( Brown , D2a-Brown-1 ) ;
10819: LD_EXP 27
10823: PPUSH
10824: LD_STRING D2a-Brown-1
10826: PPUSH
10827: CALL_OW 88
// Wait ( 0 0$30 ) ;
10831: LD_INT 1050
10833: PPUSH
10834: CALL_OW 67
// if IsOk ( Frank ) then
10838: LD_EXP 33
10842: PPUSH
10843: CALL_OW 302
10847: IFFALSE 11113
// begin DialogueOn ;
10849: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10853: LD_EXP 21
10857: PUSH
10858: LD_EXP 33
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PPUSH
10867: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10871: LD_EXP 33
10875: PPUSH
10876: LD_STRING D3F-Frank-1
10878: PPUSH
10879: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10883: LD_EXP 21
10887: PPUSH
10888: LD_STRING D3F-JMM-1
10890: PPUSH
10891: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10895: LD_EXP 33
10899: PPUSH
10900: LD_STRING D3F-Frank-2
10902: PPUSH
10903: CALL_OW 88
// case Query ( QFrank ) of 1 :
10907: LD_STRING QFrank
10909: PPUSH
10910: CALL_OW 97
10914: PUSH
10915: LD_INT 1
10917: DOUBLE
10918: EQUAL
10919: IFTRUE 10923
10921: GO 10946
10923: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10924: LD_EXP 21
10928: PPUSH
10929: LD_STRING D3Fa-JMM-1
10931: PPUSH
10932: CALL_OW 88
// us_scout := 1 ;
10936: LD_ADDR_EXP 8
10940: PUSH
10941: LD_INT 1
10943: ST_TO_ADDR
// end ; 2 :
10944: GO 11109
10946: LD_INT 2
10948: DOUBLE
10949: EQUAL
10950: IFTRUE 10954
10952: GO 11076
10954: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10955: LD_EXP 21
10959: PPUSH
10960: LD_STRING D3Fb-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10967: LD_EXP 33
10971: PPUSH
10972: LD_STRING D3Fb-Frank-1
10974: PPUSH
10975: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10979: LD_STRING QFrank2
10981: PPUSH
10982: CALL_OW 97
10986: PUSH
10987: LD_INT 1
10989: DOUBLE
10990: EQUAL
10991: IFTRUE 10995
10993: GO 11042
10995: POP
// begin us_scout := 2 ;
10996: LD_ADDR_EXP 8
11000: PUSH
11001: LD_INT 2
11003: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11004: LD_EXP 21
11008: PPUSH
11009: LD_STRING D3Fba-JMM-1
11011: PPUSH
11012: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11016: LD_EXP 33
11020: PPUSH
11021: LD_STRING D3Fba-Frank-1
11023: PPUSH
11024: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11028: LD_EXP 21
11032: PPUSH
11033: LD_STRING D3Fba-JMM-2
11035: PPUSH
11036: CALL_OW 88
// end ; 2 :
11040: GO 11074
11042: LD_INT 2
11044: DOUBLE
11045: EQUAL
11046: IFTRUE 11050
11048: GO 11073
11050: POP
// begin us_scout := 0 ;
11051: LD_ADDR_EXP 8
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11059: LD_EXP 21
11063: PPUSH
11064: LD_STRING D3Fbb-JMM-1
11066: PPUSH
11067: CALL_OW 88
// end ; end ;
11071: GO 11074
11073: POP
// end ; 3 :
11074: GO 11109
11076: LD_INT 3
11078: DOUBLE
11079: EQUAL
11080: IFTRUE 11084
11082: GO 11108
11084: POP
// begin us_scout := - 1 ;
11085: LD_ADDR_EXP 8
11089: PUSH
11090: LD_INT 1
11092: NEG
11093: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11094: LD_EXP 21
11098: PPUSH
11099: LD_STRING D3Fc-JMM-1
11101: PPUSH
11102: CALL_OW 88
// end ; end ;
11106: GO 11109
11108: POP
// DialogueOff ;
11109: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11113: LD_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: PUSH
11122: LD_INT 0
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11133
// exit ;
11131: GO 12764
// if us_scout in [ 1 , 2 ] then
11133: LD_EXP 8
11137: PUSH
11138: LD_INT 1
11140: PUSH
11141: LD_INT 2
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: IN
11148: IFFALSE 11827
// begin if IsInUnit ( Frank ) then
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 310
11159: IFFALSE 11170
// ComExit ( Frank ) ;
11161: LD_EXP 33
11165: PPUSH
11166: CALL 85533 0 1
// SetSide ( Frank , 4 ) ;
11170: LD_EXP 33
11174: PPUSH
11175: LD_INT 4
11177: PPUSH
11178: CALL_OW 235
// wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// if us_scout = 2 then
11189: LD_EXP 8
11193: PUSH
11194: LD_INT 2
11196: EQUAL
11197: IFFALSE 11565
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11199: LD_EXP 33
11203: PPUSH
11204: LD_INT 75
11206: PPUSH
11207: LD_INT 63
11209: PPUSH
11210: CALL_OW 111
// AddComHold ( Frank ) ;
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11223: LD_EXP 33
11227: PPUSH
11228: LD_INT 770
11230: PPUSH
11231: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 100
11242: PPUSH
11243: LD_INT 75
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 123
11257: PPUSH
11258: LD_INT 103
11260: PPUSH
11261: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11265: LD_EXP 33
11269: PPUSH
11270: LD_INT 138
11272: PPUSH
11273: LD_INT 108
11275: PPUSH
11276: CALL_OW 171
// AddComHold ( Frank ) ;
11280: LD_EXP 33
11284: PPUSH
11285: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11296: LD_EXP 33
11300: PPUSH
11301: LD_INT 138
11303: PPUSH
11304: LD_INT 108
11306: PPUSH
11307: CALL_OW 307
11311: IFFALSE 11289
// AddComMoveXY ( Frank , 125 , 132 ) ;
11313: LD_EXP 33
11317: PPUSH
11318: LD_INT 125
11320: PPUSH
11321: LD_INT 132
11323: PPUSH
11324: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11328: LD_INT 35
11330: PPUSH
11331: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11335: LD_INT 1
11337: PPUSH
11338: LD_EXP 33
11342: PPUSH
11343: CALL_OW 292
11347: PUSH
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 7
11355: PPUSH
11356: CALL_OW 296
11360: PUSH
11361: LD_INT 7
11363: LESS
11364: OR
11365: IFFALSE 11328
// DialogueOn ;
11367: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11371: LD_EXP 33
11375: PPUSH
11376: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11380: LD_INT 10
11382: PPUSH
11383: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11387: LD_EXP 21
11391: PPUSH
11392: LD_STRING D4Fa-JMM-1
11394: PPUSH
11395: CALL_OW 88
// for i in points do
11399: LD_ADDR_VAR 0 1
11403: PUSH
11404: LD_VAR 0 2
11408: PUSH
11409: FOR_IN
11410: IFFALSE 11468
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11412: LD_VAR 0 1
11416: PUSH
11417: LD_INT 1
11419: ARRAY
11420: PPUSH
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 2
11428: ARRAY
11429: PPUSH
11430: LD_INT 1
11432: PPUSH
11433: LD_INT 20
11435: NEG
11436: PPUSH
11437: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11441: LD_VAR 0 1
11445: PUSH
11446: LD_INT 1
11448: ARRAY
11449: PPUSH
11450: LD_VAR 0 1
11454: PUSH
11455: LD_INT 2
11457: ARRAY
11458: PPUSH
11459: LD_INT 1
11461: PPUSH
11462: CALL_OW 331
// end ;
11466: GO 11409
11468: POP
11469: POP
// dwait ( 0 0$0.5 ) ;
11470: LD_INT 18
11472: PPUSH
11473: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11477: LD_INT 42
11479: PPUSH
11480: LD_INT 27
11482: PPUSH
11483: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_STRING D4Fa-Frank-1
11494: PPUSH
11495: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11499: LD_INT 18
11501: PPUSH
11502: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11506: LD_EXP 21
11510: PPUSH
11511: LD_STRING D4Fa-JMM-2
11513: PPUSH
11514: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11518: LD_INT 118
11520: PPUSH
11521: LD_INT 80
11523: PPUSH
11524: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11528: LD_EXP 33
11532: PPUSH
11533: LD_STRING D4Fa-Frank-2
11535: PPUSH
11536: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11540: LD_INT 10
11542: PPUSH
11543: CALL_OW 68
// DialogueOff ;
11547: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11551: LD_EXP 33
11555: PPUSH
11556: LD_INT 1
11558: PPUSH
11559: CALL_OW 235
// end else
11563: GO 11827
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11565: LD_INT 2
11567: PPUSH
11568: LD_INT 4
11570: PPUSH
11571: LD_INT 2
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 75
11588: PPUSH
11589: LD_INT 63
11591: PPUSH
11592: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11596: LD_EXP 33
11600: PPUSH
11601: LD_INT 175
11603: PPUSH
11604: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 102
11615: PPUSH
11616: LD_INT 76
11618: PPUSH
11619: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11623: LD_EXP 33
11627: PPUSH
11628: LD_INT 108
11630: PPUSH
11631: LD_INT 70
11633: PPUSH
11634: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11638: LD_INT 35
11640: PPUSH
11641: CALL_OW 67
// until See ( 2 , Frank ) ;
11645: LD_INT 2
11647: PPUSH
11648: LD_EXP 33
11652: PPUSH
11653: CALL_OW 292
11657: IFFALSE 11638
// ComMoveXY ( Frank , 112 , 118 ) ;
11659: LD_EXP 33
11663: PPUSH
11664: LD_INT 112
11666: PPUSH
11667: LD_INT 118
11669: PPUSH
11670: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11674: LD_EXP 33
11678: PPUSH
11679: CALL_OW 256
11683: PUSH
11684: LD_INT 750
11686: GREATEREQUAL
11687: IFFALSE 11701
// SetLives ( Frank , 700 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 700
11696: PPUSH
11697: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11708: LD_INT 1
11710: PPUSH
11711: LD_EXP 33
11715: PPUSH
11716: CALL_OW 292
11720: PUSH
11721: LD_EXP 33
11725: PPUSH
11726: LD_INT 7
11728: PPUSH
11729: CALL_OW 296
11733: PUSH
11734: LD_INT 17
11736: LESS
11737: OR
11738: IFFALSE 11701
// DialogueOn ;
11740: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11744: LD_EXP 33
11748: PPUSH
11749: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11753: LD_EXP 33
11757: PPUSH
11758: LD_STRING D4Fb-Frank-1
11760: PPUSH
11761: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING D4Fb-JMM-1
11772: PPUSH
11773: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11777: LD_INT 2
11779: PPUSH
11780: LD_STRING D4Fb-FSci1-1
11782: PPUSH
11783: CALL 16687 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11787: LD_EXP 33
11791: PPUSH
11792: LD_STRING D4Fb-Frank-2
11794: PPUSH
11795: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11799: LD_EXP 21
11803: PPUSH
11804: LD_STRING D4Fb-JMM-2
11806: PPUSH
11807: CALL_OW 88
// DialogueOff ;
11811: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11815: LD_EXP 33
11819: PPUSH
11820: LD_INT 1
11822: PPUSH
11823: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11827: LD_EXP 34
11831: PPUSH
11832: CALL_OW 302
11836: PUSH
11837: LD_EXP 33
11841: NOT
11842: AND
11843: IFFALSE 11991
// begin DialogueOn ;
11845: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11849: LD_EXP 21
11853: PUSH
11854: LD_EXP 34
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11867: LD_EXP 34
11871: PPUSH
11872: LD_STRING D3Y-Yam-1
11874: PPUSH
11875: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11879: LD_EXP 21
11883: PPUSH
11884: LD_STRING D3Y-JMM-1
11886: PPUSH
11887: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11891: LD_EXP 34
11895: PPUSH
11896: LD_STRING D3Y-Yam-2
11898: PPUSH
11899: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11903: LD_STRING QYamoko
11905: PPUSH
11906: CALL_OW 97
11910: PUSH
11911: LD_INT 1
11913: DOUBLE
11914: EQUAL
11915: IFTRUE 11919
11917: GO 11954
11919: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11920: LD_EXP 21
11924: PPUSH
11925: LD_STRING D3Ya-JMM-1
11927: PPUSH
11928: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11932: LD_EXP 34
11936: PPUSH
11937: LD_STRING D3Ya-Yam-1
11939: PPUSH
11940: CALL_OW 88
// us_scout := 1 ;
11944: LD_ADDR_EXP 8
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// end ; 2 :
11952: GO 11987
11954: LD_INT 2
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 11986
11962: POP
// begin us_scout := - 1 ;
11963: LD_ADDR_EXP 8
11967: PUSH
11968: LD_INT 1
11970: NEG
11971: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11972: LD_EXP 21
11976: PPUSH
11977: LD_STRING D3Yb-JMM-1
11979: PPUSH
11980: CALL_OW 88
// end ; end ;
11984: GO 11987
11986: POP
// DialogueOff ;
11987: CALL_OW 7
// end ; if Frank then
11991: LD_EXP 33
11995: IFFALSE 11999
// exit ;
11997: GO 12764
// if us_scout in [ - 1 , 0 ] then
11999: LD_EXP 8
12003: PUSH
12004: LD_INT 1
12006: NEG
12007: PUSH
12008: LD_INT 0
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: IN
12015: IFFALSE 12019
// exit ;
12017: GO 12764
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12019: LD_ADDR_EXP 8
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 1
12032: PUSH
12033: LD_INT 1
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: PUSH
12042: LD_OWVAR 67
12046: ARRAY
12047: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12048: LD_EXP 8
12052: PUSH
12053: LD_INT 1
12055: PUSH
12056: LD_INT 2
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: IN
12063: IFFALSE 12764
// begin if IsInUnit ( Kikuchi ) then
12065: LD_EXP 34
12069: PPUSH
12070: CALL_OW 310
12074: IFFALSE 12085
// ComExitBuilding ( Kikuchi ) ;
12076: LD_EXP 34
12080: PPUSH
12081: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12085: LD_EXP 34
12089: PPUSH
12090: CALL_OW 311
12094: IFFALSE 12105
// ComExitVehicle ( Kikuchi ) ;
12096: LD_EXP 34
12100: PPUSH
12101: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_INT 4
12112: PPUSH
12113: CALL_OW 235
// wait ( 0 0$1 ) ;
12117: LD_INT 35
12119: PPUSH
12120: CALL_OW 67
// if us_scout = 2 then
12124: LD_EXP 8
12128: PUSH
12129: LD_INT 2
12131: EQUAL
12132: IFFALSE 12512
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12134: LD_EXP 34
12138: PPUSH
12139: LD_INT 75
12141: PPUSH
12142: LD_INT 63
12144: PPUSH
12145: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12149: LD_EXP 34
12153: PPUSH
12154: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12158: LD_EXP 34
12162: PPUSH
12163: LD_INT 770
12165: PPUSH
12166: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 100
12177: PPUSH
12178: LD_INT 75
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 123
12192: PPUSH
12193: LD_INT 103
12195: PPUSH
12196: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12200: LD_EXP 34
12204: PPUSH
12205: LD_INT 138
12207: PPUSH
12208: LD_INT 108
12210: PPUSH
12211: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12215: LD_EXP 34
12219: PPUSH
12220: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12224: LD_INT 35
12226: PPUSH
12227: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12231: LD_EXP 34
12235: PPUSH
12236: LD_INT 138
12238: PPUSH
12239: LD_INT 108
12241: PPUSH
12242: CALL_OW 307
12246: IFFALSE 12224
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12248: LD_EXP 34
12252: PPUSH
12253: LD_INT 125
12255: PPUSH
12256: LD_INT 132
12258: PPUSH
12259: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12263: LD_INT 35
12265: PPUSH
12266: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12270: LD_INT 1
12272: PPUSH
12273: LD_EXP 34
12277: PPUSH
12278: CALL_OW 292
12282: PUSH
12283: LD_EXP 34
12287: PPUSH
12288: LD_INT 7
12290: PPUSH
12291: CALL_OW 296
12295: PUSH
12296: LD_INT 7
12298: LESS
12299: OR
12300: IFFALSE 12263
// DialogueOn ;
12302: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12306: LD_EXP 34
12310: PPUSH
12311: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12315: LD_INT 10
12317: PPUSH
12318: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12322: LD_EXP 34
12326: PPUSH
12327: LD_STRING D4Ya-Yam-1
12329: PPUSH
12330: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12334: LD_EXP 21
12338: PPUSH
12339: LD_STRING D4Ya-JMM-1
12341: PPUSH
12342: CALL_OW 88
// for i in points do
12346: LD_ADDR_VAR 0 1
12350: PUSH
12351: LD_VAR 0 2
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12415
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12359: LD_VAR 0 1
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 2
12375: ARRAY
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: LD_INT 20
12382: NEG
12383: PPUSH
12384: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12388: LD_VAR 0 1
12392: PUSH
12393: LD_INT 1
12395: ARRAY
12396: PPUSH
12397: LD_VAR 0 1
12401: PUSH
12402: LD_INT 2
12404: ARRAY
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL_OW 331
// end ;
12413: GO 12356
12415: POP
12416: POP
// dwait ( 0 0$0.5 ) ;
12417: LD_INT 18
12419: PPUSH
12420: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12424: LD_INT 42
12426: PPUSH
12427: LD_INT 27
12429: PPUSH
12430: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12434: LD_EXP 34
12438: PPUSH
12439: LD_STRING D4Ya-Yam-2
12441: PPUSH
12442: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12446: LD_INT 18
12448: PPUSH
12449: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12453: LD_INT 118
12455: PPUSH
12456: LD_INT 80
12458: PPUSH
12459: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12463: LD_EXP 21
12467: PPUSH
12468: LD_STRING D4Ya-JMM-2
12470: PPUSH
12471: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_STRING D4Ya-Yam-3
12482: PPUSH
12483: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 68
// DialogueOff ;
12494: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12498: LD_EXP 34
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 235
// end else
12510: GO 12764
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12512: LD_INT 2
12514: PPUSH
12515: LD_INT 4
12517: PPUSH
12518: LD_INT 2
12520: PPUSH
12521: LD_INT 1
12523: PPUSH
12524: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 75
12535: PPUSH
12536: LD_INT 63
12538: PPUSH
12539: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12543: LD_EXP 34
12547: PPUSH
12548: LD_INT 175
12550: PPUSH
12551: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 102
12562: PPUSH
12563: LD_INT 76
12565: PPUSH
12566: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12570: LD_EXP 34
12574: PPUSH
12575: LD_INT 108
12577: PPUSH
12578: LD_INT 70
12580: PPUSH
12581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12585: LD_INT 35
12587: PPUSH
12588: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12592: LD_INT 2
12594: PPUSH
12595: LD_EXP 34
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12585
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12606: LD_EXP 34
12610: PPUSH
12611: LD_INT 112
12613: PPUSH
12614: LD_INT 118
12616: PPUSH
12617: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12621: LD_EXP 34
12625: PPUSH
12626: CALL_OW 256
12630: PUSH
12631: LD_INT 750
12633: GREATEREQUAL
12634: IFFALSE 12648
// SetLives ( Kikuchi , 700 ) ;
12636: LD_EXP 34
12640: PPUSH
12641: LD_INT 700
12643: PPUSH
12644: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12648: LD_INT 35
12650: PPUSH
12651: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12655: LD_INT 1
12657: PPUSH
12658: LD_EXP 34
12662: PPUSH
12663: CALL_OW 292
12667: PUSH
12668: LD_EXP 34
12672: PPUSH
12673: LD_INT 7
12675: PPUSH
12676: CALL_OW 296
12680: PUSH
12681: LD_INT 17
12683: LESS
12684: OR
12685: IFFALSE 12648
// DialogueOn ;
12687: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12691: LD_EXP 34
12695: PPUSH
12696: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12700: LD_EXP 34
12704: PPUSH
12705: LD_STRING D4Yb-Yam-1
12707: PPUSH
12708: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12712: LD_EXP 21
12716: PPUSH
12717: LD_STRING D4Yb-JMM-1
12719: PPUSH
12720: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12724: LD_EXP 34
12728: PPUSH
12729: LD_STRING D4Yb-Yam-2
12731: PPUSH
12732: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12736: LD_EXP 21
12740: PPUSH
12741: LD_STRING D4Yb-JMM-2
12743: PPUSH
12744: CALL_OW 88
// DialogueOff ;
12748: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12752: LD_EXP 34
12756: PPUSH
12757: LD_INT 1
12759: PPUSH
12760: CALL_OW 235
// end ; end ; end ;
12764: PPOPN 2
12766: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12767: LD_EXP 6
12771: IFFALSE 13804
12773: GO 12775
12775: DISABLE
12776: LD_INT 0
12778: PPUSH
12779: PPUSH
12780: PPUSH
12781: PPUSH
// begin enable ;
12782: ENABLE
// if not seen [ 1 ] then
12783: LD_EXP 9
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: NOT
12792: IFFALSE 12972
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12794: LD_ADDR_VAR 0 2
12798: PUSH
12799: LD_INT 22
12801: PUSH
12802: LD_INT 2
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 25
12814: PUSH
12815: LD_INT 11
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 33
12824: PUSH
12825: LD_INT 4
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PPUSH
12841: CALL_OW 69
12845: ST_TO_ADDR
// if tmp then
12846: LD_VAR 0 2
12850: IFFALSE 12972
// for i in tmp do
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: FOR_IN
12863: IFFALSE 12970
// if See ( 1 , i ) then
12865: LD_INT 1
12867: PPUSH
12868: LD_VAR 0 1
12872: PPUSH
12873: CALL_OW 292
12877: IFFALSE 12968
// begin seen := Replace ( seen , 1 , true ) ;
12879: LD_ADDR_EXP 9
12883: PUSH
12884: LD_EXP 9
12888: PPUSH
12889: LD_INT 1
12891: PPUSH
12892: LD_INT 1
12894: PPUSH
12895: CALL_OW 1
12899: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12900: LD_INT 1
12902: PPUSH
12903: CALL 16509 0 1
12907: IFFALSE 12968
// begin DialogueOn ;
12909: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12913: LD_VAR 0 1
12917: PPUSH
12918: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12922: LD_INT 10
12924: PPUSH
12925: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 1
12936: PPUSH
12937: LD_STRING D5a-Sol2-1
12939: PPUSH
12940: CALL 16687 0 2
12944: ST_TO_ADDR
// if not un then
12945: LD_VAR 0 3
12949: NOT
12950: IFFALSE 12962
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12952: LD_INT 2
12954: PPUSH
12955: LD_STRING D5a-FSol2-1
12957: PPUSH
12958: CALL 16687 0 2
// DialogueOff ;
12962: CALL_OW 7
// break ;
12966: GO 12970
// end ; end ;
12968: GO 12862
12970: POP
12971: POP
// end ; if not seen [ 2 ] then
12972: LD_EXP 9
12976: PUSH
12977: LD_INT 2
12979: ARRAY
12980: NOT
12981: IFFALSE 13206
// begin can_kamikazed := true ;
12983: LD_ADDR_EXP 10
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12991: LD_ADDR_VAR 0 2
12995: PUSH
12996: LD_INT 22
12998: PUSH
12999: LD_INT 2
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: LD_INT 25
13008: PUSH
13009: LD_INT 17
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: ST_TO_ADDR
// if tmp then
13025: LD_VAR 0 2
13029: IFFALSE 13206
// for i in tmp do
13031: LD_ADDR_VAR 0 1
13035: PUSH
13036: LD_VAR 0 2
13040: PUSH
13041: FOR_IN
13042: IFFALSE 13204
// if See ( 1 , i ) then
13044: LD_INT 1
13046: PPUSH
13047: LD_VAR 0 1
13051: PPUSH
13052: CALL_OW 292
13056: IFFALSE 13202
// begin seen := Replace ( seen , 2 , true ) ;
13058: LD_ADDR_EXP 9
13062: PUSH
13063: LD_EXP 9
13067: PPUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 1
13078: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13079: LD_INT 1
13081: PPUSH
13082: CALL 16509 0 1
13086: IFFALSE 13202
// begin DialogueOn ;
13088: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13101: LD_INT 10
13103: PPUSH
13104: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: LD_INT 1
13115: PPUSH
13116: LD_STRING D5b-Sol1-1
13118: PPUSH
13119: CALL 16687 0 2
13123: ST_TO_ADDR
// if not un then
13124: LD_VAR 0 3
13128: NOT
13129: IFFALSE 13147
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13131: LD_ADDR_VAR 0 3
13135: PUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_STRING D5b-FSol1-1
13141: PPUSH
13142: CALL 16687 0 2
13146: ST_TO_ADDR
// if un then
13147: LD_VAR 0 3
13151: IFFALSE 13196
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13153: LD_ADDR_VAR 0 4
13157: PUSH
13158: LD_INT 1
13160: PPUSH
13161: LD_STRING D5b-Sol2-1
13163: PPUSH
13164: LD_VAR 0 3
13168: PPUSH
13169: CALL 16913 0 3
13173: ST_TO_ADDR
// if not un2 then
13174: LD_VAR 0 4
13178: NOT
13179: IFFALSE 13196
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13181: LD_INT 2
13183: PPUSH
13184: LD_STRING D5b-FSol2-1
13186: PPUSH
13187: LD_VAR 0 3
13191: PPUSH
13192: CALL 16913 0 3
// end ; DialogueOff ;
13196: CALL_OW 7
// break ;
13200: GO 13204
// end ; end ;
13202: GO 13041
13204: POP
13205: POP
// end ; if not seen [ 3 ] then
13206: LD_EXP 9
13210: PUSH
13211: LD_INT 3
13213: ARRAY
13214: NOT
13215: IFFALSE 13389
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13217: LD_ADDR_VAR 0 2
13221: PUSH
13222: LD_INT 22
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 33
13234: PUSH
13235: LD_INT 2
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// if tmp then
13251: LD_VAR 0 2
13255: IFFALSE 13389
// for i in tmp do
13257: LD_ADDR_VAR 0 1
13261: PUSH
13262: LD_VAR 0 2
13266: PUSH
13267: FOR_IN
13268: IFFALSE 13387
// if See ( 1 , i ) then
13270: LD_INT 1
13272: PPUSH
13273: LD_VAR 0 1
13277: PPUSH
13278: CALL_OW 292
13282: IFFALSE 13385
// begin seen := Replace ( seen , 3 , true ) ;
13284: LD_ADDR_EXP 9
13288: PUSH
13289: LD_EXP 9
13293: PPUSH
13294: LD_INT 3
13296: PPUSH
13297: LD_INT 1
13299: PPUSH
13300: CALL_OW 1
13304: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13305: LD_INT 1
13307: PPUSH
13308: CALL 16509 0 1
13312: IFFALSE 13385
// begin DialogueOn ;
13314: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13318: LD_VAR 0 1
13322: PPUSH
13323: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13327: LD_INT 10
13329: PPUSH
13330: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13334: LD_ADDR_VAR 0 3
13338: PUSH
13339: LD_INT 1
13341: PPUSH
13342: LD_STRING D8-Sol1-1
13344: PPUSH
13345: CALL 16687 0 2
13349: ST_TO_ADDR
// if not un then
13350: LD_VAR 0 3
13354: NOT
13355: IFFALSE 13367
// SayRand ( sex_female , D8-FSol1-1 ) ;
13357: LD_INT 2
13359: PPUSH
13360: LD_STRING D8-FSol1-1
13362: PPUSH
13363: CALL 16687 0 2
// Say ( JMM , D8-JMM-1 ) ;
13367: LD_EXP 21
13371: PPUSH
13372: LD_STRING D8-JMM-1
13374: PPUSH
13375: CALL_OW 88
// DialogueOff ;
13379: CALL_OW 7
// break ;
13383: GO 13387
// end ; end ;
13385: GO 13267
13387: POP
13388: POP
// end ; if not seen [ 4 ] then
13389: LD_EXP 9
13393: PUSH
13394: LD_INT 4
13396: ARRAY
13397: NOT
13398: IFFALSE 13560
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13400: LD_ADDR_VAR 0 2
13404: PUSH
13405: LD_INT 22
13407: PUSH
13408: LD_INT 2
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: LD_INT 33
13417: PUSH
13418: LD_INT 5
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PPUSH
13429: CALL_OW 69
13433: ST_TO_ADDR
// if tmp then
13434: LD_VAR 0 2
13438: IFFALSE 13560
// for i in tmp do
13440: LD_ADDR_VAR 0 1
13444: PUSH
13445: LD_VAR 0 2
13449: PUSH
13450: FOR_IN
13451: IFFALSE 13558
// if See ( 1 , i ) then
13453: LD_INT 1
13455: PPUSH
13456: LD_VAR 0 1
13460: PPUSH
13461: CALL_OW 292
13465: IFFALSE 13556
// begin seen := Replace ( seen , 4 , true ) ;
13467: LD_ADDR_EXP 9
13471: PUSH
13472: LD_EXP 9
13476: PPUSH
13477: LD_INT 4
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: CALL_OW 1
13487: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13488: LD_INT 1
13490: PPUSH
13491: CALL 16509 0 1
13495: IFFALSE 13556
// begin DialogueOn ;
13497: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13501: LD_VAR 0 1
13505: PPUSH
13506: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13510: LD_INT 10
13512: PPUSH
13513: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13517: LD_ADDR_VAR 0 3
13521: PUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_STRING D5a-Sol1-1
13527: PPUSH
13528: CALL 16687 0 2
13532: ST_TO_ADDR
// if not un then
13533: LD_VAR 0 3
13537: NOT
13538: IFFALSE 13550
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13540: LD_INT 2
13542: PPUSH
13543: LD_STRING D5a-FSol1-1
13545: PPUSH
13546: CALL 16687 0 2
// DialogueOff ;
13550: CALL_OW 7
// break ;
13554: GO 13558
// end ; end ;
13556: GO 13450
13558: POP
13559: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13560: LD_EXP 9
13564: PUSH
13565: LD_INT 5
13567: ARRAY
13568: NOT
13569: PUSH
13570: LD_EXP 9
13574: PUSH
13575: LD_INT 3
13577: ARRAY
13578: AND
13579: IFFALSE 13753
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_INT 22
13588: PUSH
13589: LD_INT 2
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 34
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PPUSH
13610: CALL_OW 69
13614: ST_TO_ADDR
// if tmp then
13615: LD_VAR 0 2
13619: IFFALSE 13753
// for i in tmp do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_VAR 0 2
13630: PUSH
13631: FOR_IN
13632: IFFALSE 13751
// if See ( 1 , i ) then
13634: LD_INT 1
13636: PPUSH
13637: LD_VAR 0 1
13641: PPUSH
13642: CALL_OW 292
13646: IFFALSE 13749
// begin seen := Replace ( seen , 5 , true ) ;
13648: LD_ADDR_EXP 9
13652: PUSH
13653: LD_EXP 9
13657: PPUSH
13658: LD_INT 5
13660: PPUSH
13661: LD_INT 1
13663: PPUSH
13664: CALL_OW 1
13668: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13669: LD_INT 1
13671: PPUSH
13672: CALL 16509 0 1
13676: IFFALSE 13749
// begin DialogueOn ;
13678: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13691: LD_INT 10
13693: PPUSH
13694: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_STRING D8a-Sol2-1
13708: PPUSH
13709: CALL 16687 0 2
13713: ST_TO_ADDR
// if not un then
13714: LD_VAR 0 3
13718: NOT
13719: IFFALSE 13731
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13721: LD_INT 2
13723: PPUSH
13724: LD_STRING D8a-FSol2-1
13726: PPUSH
13727: CALL 16687 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13731: LD_EXP 21
13735: PPUSH
13736: LD_STRING D8a-JMM-1
13738: PPUSH
13739: CALL_OW 88
// DialogueOff ;
13743: CALL_OW 7
// break ;
13747: GO 13751
// end ; end ;
13749: GO 13631
13751: POP
13752: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13753: LD_EXP 9
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PUSH
13762: LD_EXP 9
13766: PUSH
13767: LD_INT 2
13769: ARRAY
13770: AND
13771: PUSH
13772: LD_EXP 9
13776: PUSH
13777: LD_INT 3
13779: ARRAY
13780: AND
13781: PUSH
13782: LD_EXP 9
13786: PUSH
13787: LD_INT 4
13789: ARRAY
13790: AND
13791: PUSH
13792: LD_EXP 9
13796: PUSH
13797: LD_INT 5
13799: ARRAY
13800: AND
13801: IFFALSE 13804
// disable ;
13803: DISABLE
// end ;
13804: PPOPN 4
13806: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13807: LD_EXP 10
13811: PUSH
13812: LD_EXP 11
13816: AND
13817: IFFALSE 14015
13819: GO 13821
13821: DISABLE
13822: LD_INT 0
13824: PPUSH
// begin DialogueOn ;
13825: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13829: LD_EXP 11
13833: PPUSH
13834: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: PPUSH
13846: LD_STRING D5c-Sol1-1
13848: PPUSH
13849: CALL 16687 0 2
13853: ST_TO_ADDR
// if not un then
13854: LD_VAR 0 1
13858: NOT
13859: IFFALSE 13877
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13861: LD_ADDR_VAR 0 1
13865: PUSH
13866: LD_INT 2
13868: PPUSH
13869: LD_STRING D5c-FSol1-1
13871: PPUSH
13872: CALL 16687 0 2
13876: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13877: LD_EXP 21
13881: PPUSH
13882: LD_STRING D5c-JMM-1
13884: PPUSH
13885: CALL_OW 88
// if IsOk ( Lisa ) then
13889: LD_EXP 22
13893: PPUSH
13894: CALL_OW 302
13898: IFFALSE 13914
// Say ( Lisa , D5d-Lisa-1 ) else
13900: LD_EXP 22
13904: PPUSH
13905: LD_STRING D5d-Lisa-1
13907: PPUSH
13908: CALL_OW 88
13912: GO 13999
// if IsOk ( Cyrus ) then
13914: LD_EXP 25
13918: PPUSH
13919: CALL_OW 302
13923: IFFALSE 13939
// Say ( Cyrus , D5d-Cyrus-1 ) else
13925: LD_EXP 25
13929: PPUSH
13930: LD_STRING D5d-Cyrus-1
13932: PPUSH
13933: CALL_OW 88
13937: GO 13999
// if IsOk ( Gary ) then
13939: LD_EXP 32
13943: PPUSH
13944: CALL_OW 302
13948: IFFALSE 13964
// Say ( Gary , D5d-Gary-1 ) else
13950: LD_EXP 32
13954: PPUSH
13955: LD_STRING D5d-Gary-1
13957: PPUSH
13958: CALL_OW 88
13962: GO 13999
// if GetSex ( un ) = sex_male then
13964: LD_VAR 0 1
13968: PPUSH
13969: CALL_OW 258
13973: PUSH
13974: LD_INT 1
13976: EQUAL
13977: IFFALSE 13993
// Say ( un , D5d-Sol1-1 ) else
13979: LD_VAR 0 1
13983: PPUSH
13984: LD_STRING D5d-Sol1-1
13986: PPUSH
13987: CALL_OW 88
13991: GO 13999
// begin DialogueOff ;
13993: CALL_OW 7
// exit ;
13997: GO 14015
// end ; Say ( JMM , D5d-JMM-1 ) ;
13999: LD_EXP 21
14003: PPUSH
14004: LD_STRING D5d-JMM-1
14006: PPUSH
14007: CALL_OW 88
// DialogueOff ;
14011: CALL_OW 7
// end ;
14015: PPOPN 1
14017: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14018: LD_INT 1
14020: PPUSH
14021: LD_INT 17
14023: PPUSH
14024: CALL_OW 294
14028: PUSH
14029: LD_INT 2
14031: GREATEREQUAL
14032: IFFALSE 14164
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14040: LD_INT 10
14042: PPUSH
14043: LD_INT 5
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: LD_INT 10
14051: NEG
14052: PPUSH
14053: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14057: LD_INT 10
14059: PPUSH
14060: LD_INT 5
14062: PPUSH
14063: LD_INT 1
14065: PPUSH
14066: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14070: LD_INT 10
14072: PPUSH
14073: LD_INT 5
14075: PPUSH
14076: CALL_OW 86
// DialogueOn ;
14080: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14084: LD_ADDR_VAR 0 1
14088: PUSH
14089: LD_INT 1
14091: PPUSH
14092: LD_STRING D6-Sci1-1
14094: PPUSH
14095: CALL 16687 0 2
14099: ST_TO_ADDR
// if un then
14100: LD_VAR 0 1
14104: IFFALSE 14142
// begin Say ( JMM , D6-JMM-1 ) ;
14106: LD_EXP 21
14110: PPUSH
14111: LD_STRING D6-JMM-1
14113: PPUSH
14114: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_STRING D6-Sci1-2
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14130: LD_EXP 21
14134: PPUSH
14135: LD_STRING D6-JMM-2
14137: PPUSH
14138: CALL_OW 88
// end ; DialogueOff ;
14142: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14146: LD_STRING M3
14148: PPUSH
14149: CALL_OW 337
// wait ( 0 0$30 ) ;
14153: LD_INT 1050
14155: PPUSH
14156: CALL_OW 67
// AmericanReinforcements ;
14160: CALL 2335 0 0
// end ;
14164: PPOPN 1
14166: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14167: LD_OWVAR 1
14171: PUSH
14172: LD_INT 42000
14174: GREATEREQUAL
14175: PUSH
14176: LD_INT 2
14178: PPUSH
14179: LD_INT 169
14181: PPUSH
14182: LD_INT 90
14184: PPUSH
14185: LD_INT 10
14187: PPUSH
14188: CALL 54290 0 4
14192: PUSH
14193: LD_INT 4
14195: ARRAY
14196: PUSH
14197: LD_INT 0
14199: EQUAL
14200: PUSH
14201: LD_INT 45
14203: PPUSH
14204: CALL_OW 301
14208: OR
14209: PUSH
14210: LD_INT 45
14212: PPUSH
14213: CALL_OW 255
14217: PUSH
14218: LD_INT 1
14220: EQUAL
14221: OR
14222: AND
14223: PUSH
14224: LD_INT 94
14226: PPUSH
14227: CALL_OW 301
14231: NOT
14232: AND
14233: IFFALSE 15438
14235: GO 14237
14237: DISABLE
14238: LD_INT 0
14240: PPUSH
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
// begin uc_side := 5 ;
14245: LD_ADDR_OWVAR 20
14249: PUSH
14250: LD_INT 5
14252: ST_TO_ADDR
// uc_nation := 2 ;
14253: LD_ADDR_OWVAR 21
14257: PUSH
14258: LD_INT 2
14260: ST_TO_ADDR
// InitHc ;
14261: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 3
14270: PPUSH
14271: LD_INT 8
14273: PPUSH
14274: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14278: LD_ADDR_OWVAR 29
14282: PUSH
14283: LD_INT 12
14285: PUSH
14286: LD_INT 12
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: ST_TO_ADDR
// hc_name := Hans Fliege ;
14293: LD_ADDR_OWVAR 26
14297: PUSH
14298: LD_STRING Hans Fliege
14300: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14301: LD_ADDR_OWVAR 33
14305: PUSH
14306: LD_STRING SecondCharsGal
14308: ST_TO_ADDR
// hc_face_number := 7 ;
14309: LD_ADDR_OWVAR 34
14313: PUSH
14314: LD_INT 7
14316: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14317: LD_ADDR_EXP 46
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// InitHc ;
14327: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14331: LD_INT 1
14333: PPUSH
14334: LD_INT 16
14336: PPUSH
14337: LD_INT 2
14339: PPUSH
14340: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14344: LD_ADDR_OWVAR 29
14348: PUSH
14349: LD_INT 12
14351: PUSH
14352: LD_INT 12
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: ST_TO_ADDR
// hc_name :=  ;
14359: LD_ADDR_OWVAR 26
14363: PUSH
14364: LD_STRING 
14366: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14367: LD_ADDR_EXP 47
14371: PUSH
14372: CALL_OW 44
14376: ST_TO_ADDR
// InitHc ;
14377: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14381: LD_INT 35
14383: PPUSH
14384: CALL_OW 67
// until not InBattle ( 1 ) ;
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 463
14395: NOT
14396: IFFALSE 14381
// wait ( 0 0$5 ) ;
14398: LD_INT 175
14400: PPUSH
14401: CALL_OW 67
// DialogueOn ;
14405: CALL_OW 6
// InGameOn ;
14409: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14413: LD_ADDR_VAR 0 1
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 2
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 25
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 25
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 25
14463: PUSH
14464: LD_INT 4
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PUSH
14471: LD_INT 25
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 25
14483: PUSH
14484: LD_INT 8
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PPUSH
14504: CALL_OW 69
14508: PUSH
14509: LD_EXP 21
14513: PUSH
14514: LD_EXP 22
14518: PUSH
14519: LD_EXP 23
14523: PUSH
14524: LD_EXP 24
14528: PUSH
14529: LD_EXP 25
14533: PUSH
14534: LD_EXP 26
14538: PUSH
14539: LD_EXP 27
14543: PUSH
14544: LD_EXP 28
14548: PUSH
14549: LD_EXP 29
14553: PUSH
14554: LD_EXP 31
14558: PUSH
14559: LD_EXP 32
14563: PUSH
14564: LD_EXP 33
14568: PUSH
14569: LD_EXP 34
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: DIFF
14589: PPUSH
14590: LD_INT 26
14592: PUSH
14593: LD_INT 1
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PPUSH
14600: CALL_OW 72
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: ST_TO_ADDR
// if Brown then
14609: LD_EXP 27
14613: IFFALSE 14625
// un := Brown ;
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_EXP 27
14624: ST_TO_ADDR
// if un then
14625: LD_VAR 0 1
14629: IFFALSE 14655
// begin Say ( un , D7-Sol1-1 ) ;
14631: LD_VAR 0 1
14635: PPUSH
14636: LD_STRING D7-Sol1-1
14638: PPUSH
14639: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14643: LD_EXP 21
14647: PPUSH
14648: LD_STRING D7-JMM-1
14650: PPUSH
14651: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14655: LD_EXP 46
14659: PPUSH
14660: LD_STRING D7-Ar1-1
14662: PPUSH
14663: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14667: LD_EXP 21
14671: PPUSH
14672: LD_STRING D7-JMM-2
14674: PPUSH
14675: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14679: LD_EXP 46
14683: PPUSH
14684: LD_STRING D7-Ar1-2
14686: PPUSH
14687: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14691: LD_EXP 21
14695: PPUSH
14696: LD_STRING D7-JMM-3
14698: PPUSH
14699: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14703: LD_EXP 46
14707: PPUSH
14708: LD_STRING D7-Ar1-3
14710: PPUSH
14711: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14715: LD_EXP 21
14719: PPUSH
14720: LD_STRING D7-JMM-4
14722: PPUSH
14723: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14727: LD_EXP 46
14731: PPUSH
14732: LD_STRING D7-Ar1-4
14734: PPUSH
14735: CALL_OW 94
// InGameOff ;
14739: CALL_OW 9
// DialogueOff ;
14743: CALL_OW 7
// case Query ( QCameras ) of 1 :
14747: LD_STRING QCameras
14749: PPUSH
14750: CALL_OW 97
14754: PUSH
14755: LD_INT 1
14757: DOUBLE
14758: EQUAL
14759: IFTRUE 14763
14761: GO 14766
14763: POP
// ; 2 :
14764: GO 14780
14766: LD_INT 2
14768: DOUBLE
14769: EQUAL
14770: IFTRUE 14774
14772: GO 14779
14774: POP
// exit ; end ;
14775: GO 15438
14777: GO 14780
14779: POP
// ChangeMissionObjectives ( MCar ) ;
14780: LD_STRING MCar
14782: PPUSH
14783: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14787: LD_INT 124
14789: PPUSH
14790: LD_INT 90
14792: PPUSH
14793: LD_INT 1
14795: PPUSH
14796: LD_INT 6
14798: NEG
14799: PPUSH
14800: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14804: LD_INT 124
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14817: LD_INT 12
14819: PPUSH
14820: LD_INT 1
14822: PPUSH
14823: CALL_OW 424
// wait ( 3 ) ;
14827: LD_INT 3
14829: PPUSH
14830: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14834: LD_INT 124
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 86
// cargo := false ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 0
14851: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14852: LD_INT 35
14854: PPUSH
14855: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14859: LD_ADDR_VAR 0 3
14863: PUSH
14864: LD_INT 12
14866: PPUSH
14867: LD_INT 32
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 34
14879: PUSH
14880: LD_INT 32
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: LD_INT 58
14889: PUSH
14890: EMPTY
14891: LIST
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: PPUSH
14898: CALL_OW 70
14902: ST_TO_ADDR
// until cargo ;
14903: LD_VAR 0 3
14907: IFFALSE 14852
// cargo := cargo [ 1 ] ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 3
14918: PUSH
14919: LD_INT 1
14921: ARRAY
14922: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14923: LD_VAR 0 3
14927: PPUSH
14928: LD_INT 5
14930: PPUSH
14931: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14935: LD_INT 12
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14945: LD_EXP 46
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14960: LD_EXP 47
14964: PPUSH
14965: LD_INT 11
14967: PPUSH
14968: LD_INT 0
14970: PPUSH
14971: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14975: LD_EXP 46
14979: PUSH
14980: LD_EXP 47
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PPUSH
14989: LD_INT 12
14991: PPUSH
14992: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14996: LD_EXP 46
15000: PPUSH
15001: LD_VAR 0 3
15005: PPUSH
15006: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15010: LD_EXP 46
15014: PUSH
15015: LD_EXP 47
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: LD_INT 209
15026: PPUSH
15027: LD_INT 178
15029: PPUSH
15030: CALL_OW 171
// escaped := 0 ;
15034: LD_ADDR_VAR 0 5
15038: PUSH
15039: LD_INT 0
15041: ST_TO_ADDR
// while ( true ) do
15042: LD_INT 1
15044: IFFALSE 15260
// begin wait ( 0 0$1 ) ;
15046: LD_INT 35
15048: PPUSH
15049: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15053: LD_EXP 46
15057: PPUSH
15058: CALL_OW 314
15062: NOT
15063: PUSH
15064: LD_EXP 47
15068: PPUSH
15069: CALL_OW 314
15073: NOT
15074: OR
15075: IFFALSE 15101
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15077: LD_EXP 46
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PPUSH
15091: LD_INT 209
15093: PPUSH
15094: LD_INT 178
15096: PPUSH
15097: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15101: LD_EXP 46
15105: PPUSH
15106: LD_INT 10
15108: PPUSH
15109: CALL_OW 308
15113: IFFALSE 15138
// begin RemoveUnit ( ar_mechanic ) ;
15115: LD_EXP 46
15119: PPUSH
15120: CALL_OW 64
// escaped := escaped + 1 ;
15124: LD_ADDR_VAR 0 5
15128: PUSH
15129: LD_VAR 0 5
15133: PUSH
15134: LD_INT 1
15136: PLUS
15137: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15138: LD_EXP 47
15142: PPUSH
15143: LD_INT 10
15145: PPUSH
15146: CALL_OW 308
15150: IFFALSE 15175
// begin RemoveUnit ( ar_mechanic_friend ) ;
15152: LD_EXP 47
15156: PPUSH
15157: CALL_OW 64
// escaped := escaped + 1 ;
15161: LD_ADDR_VAR 0 5
15165: PUSH
15166: LD_VAR 0 5
15170: PUSH
15171: LD_INT 1
15173: PLUS
15174: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15175: LD_VAR 0 3
15179: PPUSH
15180: LD_INT 10
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( cargo ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15198: LD_EXP 46
15202: PPUSH
15203: CALL_OW 305
15207: NOT
15208: PUSH
15209: LD_VAR 0 5
15213: PUSH
15214: LD_INT 2
15216: GREATEREQUAL
15217: AND
15218: IFFALSE 15222
// break ;
15220: GO 15260
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15222: LD_EXP 46
15226: PPUSH
15227: CALL_OW 305
15231: NOT
15232: PUSH
15233: LD_EXP 47
15237: PPUSH
15238: CALL_OW 305
15242: NOT
15243: AND
15244: PUSH
15245: LD_VAR 0 5
15249: PUSH
15250: LD_INT 2
15252: LESS
15253: AND
15254: IFFALSE 15258
// exit ;
15256: GO 15438
// end ;
15258: GO 15042
// wait ( 0 0$2 ) ;
15260: LD_INT 70
15262: PPUSH
15263: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15267: LD_EXP 46
15271: PPUSH
15272: LD_STRING D7a-Ar1-1
15274: PPUSH
15275: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15279: LD_ADDR_VAR 0 4
15283: PUSH
15284: LD_INT 129
15286: PUSH
15287: LD_INT 10
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 103
15296: PUSH
15297: LD_INT 6
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 148
15306: PUSH
15307: LD_INT 47
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 155
15316: PUSH
15317: LD_INT 16
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: ST_TO_ADDR
// if Difficulty = 1 then
15330: LD_OWVAR 67
15334: PUSH
15335: LD_INT 1
15337: EQUAL
15338: IFFALSE 15375
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15340: LD_ADDR_VAR 0 4
15344: PUSH
15345: LD_VAR 0 4
15349: PUSH
15350: LD_INT 78
15352: PUSH
15353: LD_INT 7
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: LD_INT 104
15362: PUSH
15363: LD_INT 43
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: ADD
15374: ST_TO_ADDR
// for i in tmp do
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 4
15384: PUSH
15385: FOR_IN
15386: IFFALSE 15419
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15388: LD_VAR 0 2
15392: PUSH
15393: LD_INT 1
15395: ARRAY
15396: PPUSH
15397: LD_VAR 0 2
15401: PUSH
15402: LD_INT 2
15404: ARRAY
15405: PPUSH
15406: LD_INT 1
15408: PPUSH
15409: LD_INT 9
15411: NEG
15412: PPUSH
15413: CALL_OW 330
15417: GO 15385
15419: POP
15420: POP
// SetAchievement ( ACH_FRIEND ) ;
15421: LD_STRING ACH_FRIEND
15423: PPUSH
15424: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15428: LD_INT 129
15430: PPUSH
15431: LD_INT 10
15433: PPUSH
15434: CALL_OW 84
// end ;
15438: PPOPN 5
15440: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15441: LD_EXP 15
15445: PUSH
15446: LD_INT 21000
15448: MINUS
15449: PUSH
15450: LD_OWVAR 1
15454: LESSEQUAL
15455: IFFALSE 15495
15457: GO 15459
15459: DISABLE
// begin powell_warn := true ;
15460: LD_ADDR_EXP 16
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// DialogueOn ;
15468: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15472: LD_EXP 30
15476: PPUSH
15477: LD_STRING D9-Pow-1
15479: PPUSH
15480: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15484: LD_INT 10
15486: PPUSH
15487: CALL_OW 68
// DialogueOff ;
15491: CALL_OW 7
// end ;
15495: END
// every 0 0$1 trigger game_time <= tick do
15496: LD_EXP 15
15500: PUSH
15501: LD_OWVAR 1
15505: LESSEQUAL
15506: IFFALSE 15545
15508: GO 15510
15510: DISABLE
// begin DialogueOn ;
15511: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15515: LD_EXP 30
15519: PPUSH
15520: LD_STRING D9a-Pow-1
15522: PPUSH
15523: CALL_OW 94
// dwait ( 0 0$2 ) ;
15527: LD_INT 70
15529: PPUSH
15530: CALL_OW 68
// DialogueOff ;
15534: CALL_OW 7
// YouLost ( Command ) ;
15538: LD_STRING Command
15540: PPUSH
15541: CALL_OW 104
// end ;
15545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15546: LD_INT 22
15548: PUSH
15549: LD_INT 2
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PUSH
15556: LD_INT 30
15558: PUSH
15559: LD_INT 1
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PPUSH
15570: CALL_OW 69
15574: PUSH
15575: LD_INT 0
15577: EQUAL
15578: PUSH
15579: LD_EXP 21
15583: PPUSH
15584: CALL_OW 302
15588: AND
15589: IFFALSE 16506
15591: GO 15593
15593: DISABLE
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// begin m1 := false ;
15600: LD_ADDR_VAR 0 2
15604: PUSH
15605: LD_INT 0
15607: ST_TO_ADDR
// m2 := false ;
15608: LD_ADDR_VAR 0 3
15612: PUSH
15613: LD_INT 0
15615: ST_TO_ADDR
// m3 := false ;
15616: LD_ADDR_VAR 0 4
15620: PUSH
15621: LD_INT 0
15623: ST_TO_ADDR
// if not am_veh_consturcted then
15624: LD_EXP 20
15628: NOT
15629: IFFALSE 15638
// SetAchievement ( ACH_ARABTECH ) ;
15631: LD_STRING ACH_ARABTECH
15633: PPUSH
15634: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15638: LD_OWVAR 1
15642: PUSH
15643: LD_INT 252000
15645: PUSH
15646: LD_INT 210000
15648: PUSH
15649: LD_INT 199500
15651: PUSH
15652: LD_INT 193200
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: PUSH
15661: LD_OWVAR 67
15665: ARRAY
15666: LESS
15667: IFFALSE 15689
// begin m3 := true ;
15669: LD_ADDR_VAR 0 4
15673: PUSH
15674: LD_INT 1
15676: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15677: LD_STRING Time1
15679: PPUSH
15680: LD_INT 1
15682: PPUSH
15683: CALL_OW 101
// end else
15687: GO 15720
// if not powell_warn then
15689: LD_EXP 16
15693: NOT
15694: IFFALSE 15709
// AddMedal ( Time1 , - 1 ) else
15696: LD_STRING Time1
15698: PPUSH
15699: LD_INT 1
15701: NEG
15702: PPUSH
15703: CALL_OW 101
15707: GO 15720
// AddMedal ( Time1 , - 2 ) ;
15709: LD_STRING Time1
15711: PPUSH
15712: LD_INT 2
15714: NEG
15715: PPUSH
15716: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15720: LD_EXP 17
15724: PUSH
15725: LD_INT 5
15727: PUSH
15728: LD_INT 4
15730: PUSH
15731: LD_INT 3
15733: PUSH
15734: LD_INT 3
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: LIST
15741: LIST
15742: PUSH
15743: LD_OWVAR 67
15747: ARRAY
15748: GREATEREQUAL
15749: IFFALSE 15764
// AddMedal ( Destroy , - 2 ) else
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: NEG
15757: PPUSH
15758: CALL_OW 101
15762: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15764: LD_INT 22
15766: PUSH
15767: LD_INT 2
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 21
15776: PUSH
15777: LD_INT 3
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: LD_INT 50
15786: PUSH
15787: EMPTY
15788: LIST
15789: PUSH
15790: EMPTY
15791: LIST
15792: LIST
15793: LIST
15794: PPUSH
15795: CALL_OW 69
15799: PUSH
15800: LD_INT 25
15802: GREATEREQUAL
15803: IFFALSE 15818
// AddMedal ( Destroy , - 1 ) else
15805: LD_STRING Destroy
15807: PPUSH
15808: LD_INT 1
15810: NEG
15811: PPUSH
15812: CALL_OW 101
15816: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15818: LD_INT 22
15820: PUSH
15821: LD_INT 2
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: PUSH
15828: LD_INT 21
15830: PUSH
15831: LD_INT 3
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 50
15840: PUSH
15841: EMPTY
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 15
15856: GREATEREQUAL
15857: IFFALSE 15879
// begin m1 := true ;
15859: LD_ADDR_VAR 0 2
15863: PUSH
15864: LD_INT 1
15866: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15867: LD_STRING Destroy
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: CALL_OW 101
// end else
15877: GO 15897
// begin m1 := true ;
15879: LD_ADDR_VAR 0 2
15883: PUSH
15884: LD_INT 1
15886: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15887: LD_STRING Destroy
15889: PPUSH
15890: LD_INT 2
15892: PPUSH
15893: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15897: LD_EXP 13
15901: PPUSH
15902: LD_STRING 11_artifact_captured
15904: PPUSH
15905: CALL_OW 39
// if artifact_get then
15909: LD_EXP 13
15913: IFFALSE 15935
// begin m2 := true ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: LD_INT 1
15922: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15923: LD_STRING Artefact
15925: PPUSH
15926: LD_INT 1
15928: PPUSH
15929: CALL_OW 101
// end else
15933: GO 15946
// AddMedal ( Artefact , - 1 ) ;
15935: LD_STRING Artefact
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15946: LD_VAR 0 2
15950: PUSH
15951: LD_VAR 0 3
15955: AND
15956: PUSH
15957: LD_VAR 0 4
15961: AND
15962: PUSH
15963: LD_OWVAR 67
15967: PUSH
15968: LD_INT 3
15970: GREATEREQUAL
15971: AND
15972: IFFALSE 15984
// SetAchievementEX ( ACH_AMER , 11 ) ;
15974: LD_STRING ACH_AMER
15976: PPUSH
15977: LD_INT 11
15979: PPUSH
15980: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15984: LD_VAR 0 2
15988: PUSH
15989: LD_VAR 0 3
15993: AND
15994: PUSH
15995: LD_VAR 0 4
15999: AND
16000: PUSH
16001: LD_EXP 17
16005: PUSH
16006: LD_INT 0
16008: EQUAL
16009: AND
16010: IFFALSE 16026
// begin wait ( 3 ) ;
16012: LD_INT 3
16014: PPUSH
16015: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16019: LD_STRING ACH_GENERAL
16021: PPUSH
16022: CALL_OW 543
// end ; if tick <= 100 100$00 then
16026: LD_OWVAR 1
16030: PUSH
16031: LD_INT 210000
16033: LESSEQUAL
16034: IFFALSE 16050
// begin wait ( 3 ) ;
16036: LD_INT 3
16038: PPUSH
16039: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16043: LD_STRING ACH_ASPEED_11
16045: PPUSH
16046: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16050: LD_STRING MAIN
16052: PPUSH
16053: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16057: LD_ADDR_EXP 19
16061: PUSH
16062: LD_EXP 19
16066: PPUSH
16067: LD_INT 51
16069: PUSH
16070: EMPTY
16071: LIST
16072: PPUSH
16073: CALL_OW 72
16077: ST_TO_ADDR
// tmp := JMM ^ selected ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_EXP 21
16087: PUSH
16088: LD_EXP 19
16092: ADD
16093: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16103: LD_VAR 0 1
16107: PUSH
16108: LD_EXP 21
16112: PUSH
16113: LD_EXP 22
16117: PUSH
16118: LD_EXP 23
16122: PUSH
16123: LD_EXP 24
16127: PUSH
16128: LD_EXP 25
16132: PUSH
16133: LD_EXP 26
16137: PUSH
16138: LD_EXP 27
16142: PUSH
16143: LD_EXP 28
16147: PUSH
16148: LD_EXP 29
16152: PUSH
16153: LD_EXP 31
16157: PUSH
16158: LD_EXP 32
16162: PUSH
16163: LD_EXP 33
16167: PUSH
16168: LD_EXP 34
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: DIFF
16188: PPUSH
16189: LD_STRING 11c_others
16191: PPUSH
16192: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16196: LD_EXP 21
16200: PPUSH
16201: LD_EXP 3
16205: PUSH
16206: LD_STRING JMM
16208: STR
16209: PPUSH
16210: CALL_OW 38
// if Lisa then
16214: LD_EXP 22
16218: IFFALSE 16238
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16220: LD_EXP 22
16224: PPUSH
16225: LD_EXP 3
16229: PUSH
16230: LD_STRING Lisa
16232: STR
16233: PPUSH
16234: CALL_OW 38
// if Donaldson then
16238: LD_EXP 23
16242: IFFALSE 16262
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16244: LD_EXP 23
16248: PPUSH
16249: LD_EXP 3
16253: PUSH
16254: LD_STRING Donaldson
16256: STR
16257: PPUSH
16258: CALL_OW 38
// if Bobby then
16262: LD_EXP 24
16266: IFFALSE 16286
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16268: LD_EXP 24
16272: PPUSH
16273: LD_EXP 3
16277: PUSH
16278: LD_STRING Bobby
16280: STR
16281: PPUSH
16282: CALL_OW 38
// if Cyrus then
16286: LD_EXP 25
16290: IFFALSE 16310
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16292: LD_EXP 25
16296: PPUSH
16297: LD_EXP 3
16301: PUSH
16302: LD_STRING Cyrus
16304: STR
16305: PPUSH
16306: CALL_OW 38
// if Denis then
16310: LD_EXP 26
16314: IFFALSE 16334
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16316: LD_EXP 26
16320: PPUSH
16321: LD_EXP 3
16325: PUSH
16326: LD_STRING Denis
16328: STR
16329: PPUSH
16330: CALL_OW 38
// if Brown then
16334: LD_EXP 27
16338: IFFALSE 16358
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16340: LD_EXP 27
16344: PPUSH
16345: LD_EXP 3
16349: PUSH
16350: LD_STRING Brown
16352: STR
16353: PPUSH
16354: CALL_OW 38
// if Gladstone then
16358: LD_EXP 28
16362: IFFALSE 16382
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16364: LD_EXP 28
16368: PPUSH
16369: LD_EXP 3
16373: PUSH
16374: LD_STRING Gladstone
16376: STR
16377: PPUSH
16378: CALL_OW 38
// if Houten then
16382: LD_EXP 29
16386: IFFALSE 16406
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16388: LD_EXP 29
16392: PPUSH
16393: LD_EXP 3
16397: PUSH
16398: LD_STRING Houten
16400: STR
16401: PPUSH
16402: CALL_OW 38
// if Cornel then
16406: LD_EXP 31
16410: IFFALSE 16430
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16412: LD_EXP 31
16416: PPUSH
16417: LD_EXP 3
16421: PUSH
16422: LD_STRING Cornell
16424: STR
16425: PPUSH
16426: CALL_OW 38
// if Gary then
16430: LD_EXP 32
16434: IFFALSE 16454
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16436: LD_EXP 32
16440: PPUSH
16441: LD_EXP 3
16445: PUSH
16446: LD_STRING Gary
16448: STR
16449: PPUSH
16450: CALL_OW 38
// if Frank then
16454: LD_EXP 33
16458: IFFALSE 16478
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16460: LD_EXP 33
16464: PPUSH
16465: LD_EXP 3
16469: PUSH
16470: LD_STRING Frank
16472: STR
16473: PPUSH
16474: CALL_OW 38
// if Kikuchi then
16478: LD_EXP 34
16482: IFFALSE 16502
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16484: LD_EXP 34
16488: PPUSH
16489: LD_EXP 3
16493: PUSH
16494: LD_STRING Kikuchi
16496: STR
16497: PPUSH
16498: CALL_OW 38
// YouWin ;
16502: CALL_OW 103
// end ;
16506: PPOPN 4
16508: END
// export function CanSayRand ( side ) ; begin
16509: LD_INT 0
16511: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16512: LD_ADDR_VAR 0 2
16516: PUSH
16517: LD_INT 52
16519: PUSH
16520: EMPTY
16521: LIST
16522: PUSH
16523: LD_INT 22
16525: PUSH
16526: LD_VAR 0 1
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 2
16537: PUSH
16538: LD_INT 25
16540: PUSH
16541: LD_INT 1
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PUSH
16548: LD_INT 25
16550: PUSH
16551: LD_INT 2
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 25
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 25
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: LIST
16589: PPUSH
16590: CALL_OW 69
16594: PUSH
16595: LD_EXP 21
16599: PUSH
16600: LD_EXP 33
16604: PUSH
16605: LD_EXP 22
16609: PUSH
16610: LD_EXP 23
16614: PUSH
16615: LD_EXP 24
16619: PUSH
16620: LD_EXP 25
16624: PUSH
16625: LD_EXP 26
16629: PUSH
16630: LD_EXP 27
16634: PUSH
16635: LD_EXP 28
16639: PUSH
16640: LD_EXP 29
16644: PUSH
16645: LD_EXP 30
16649: PUSH
16650: LD_EXP 31
16654: PUSH
16655: LD_EXP 32
16659: PUSH
16660: LD_EXP 34
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: DIFF
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 2
16686: RET
// export function SayRand ( sex , dial ) ; begin
16687: LD_INT 0
16689: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16690: LD_ADDR_VAR 0 3
16694: PUSH
16695: LD_INT 52
16697: PUSH
16698: EMPTY
16699: LIST
16700: PUSH
16701: LD_INT 22
16703: PUSH
16704: LD_INT 1
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 26
16713: PUSH
16714: LD_VAR 0 1
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 25
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 25
16738: PUSH
16739: LD_INT 2
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 3
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 25
16758: PUSH
16759: LD_INT 4
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: PPUSH
16779: CALL_OW 69
16783: PUSH
16784: LD_EXP 21
16788: PUSH
16789: LD_EXP 33
16793: PUSH
16794: LD_EXP 22
16798: PUSH
16799: LD_EXP 23
16803: PUSH
16804: LD_EXP 24
16808: PUSH
16809: LD_EXP 25
16813: PUSH
16814: LD_EXP 26
16818: PUSH
16819: LD_EXP 27
16823: PUSH
16824: LD_EXP 28
16828: PUSH
16829: LD_EXP 29
16833: PUSH
16834: LD_EXP 30
16838: PUSH
16839: LD_EXP 31
16843: PUSH
16844: LD_EXP 32
16848: PUSH
16849: LD_EXP 34
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: DIFF
16870: ST_TO_ADDR
// if not result then
16871: LD_VAR 0 3
16875: NOT
16876: IFFALSE 16880
// exit ;
16878: GO 16908
// result := result [ 1 ] ;
16880: LD_ADDR_VAR 0 3
16884: PUSH
16885: LD_VAR 0 3
16889: PUSH
16890: LD_INT 1
16892: ARRAY
16893: ST_TO_ADDR
// Say ( result , dial ) ;
16894: LD_VAR 0 3
16898: PPUSH
16899: LD_VAR 0 2
16903: PPUSH
16904: CALL_OW 88
// end ;
16908: LD_VAR 0 3
16912: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16913: LD_INT 0
16915: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 22
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 26
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PUSH
16943: LD_INT 2
16945: PUSH
16946: LD_INT 25
16948: PUSH
16949: LD_INT 1
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 25
16958: PUSH
16959: LD_INT 2
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: LD_INT 25
16968: PUSH
16969: LD_INT 3
16971: PUSH
16972: EMPTY
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 25
16978: PUSH
16979: LD_INT 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: PPUSH
16998: CALL_OW 69
17002: PUSH
17003: LD_EXP 21
17007: PUSH
17008: LD_EXP 33
17012: PUSH
17013: LD_EXP 22
17017: PUSH
17018: LD_EXP 23
17022: PUSH
17023: LD_EXP 24
17027: PUSH
17028: LD_EXP 25
17032: PUSH
17033: LD_EXP 26
17037: PUSH
17038: LD_EXP 27
17042: PUSH
17043: LD_EXP 28
17047: PUSH
17048: LD_EXP 29
17052: PUSH
17053: LD_EXP 30
17057: PUSH
17058: LD_EXP 31
17062: PUSH
17063: LD_EXP 32
17067: PUSH
17068: LD_EXP 34
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: PUSH
17089: LD_VAR 0 3
17093: ADD
17094: DIFF
17095: ST_TO_ADDR
// if not result then
17096: LD_VAR 0 4
17100: NOT
17101: IFFALSE 17105
// exit ;
17103: GO 17133
// result := result [ 1 ] ;
17105: LD_ADDR_VAR 0 4
17109: PUSH
17110: LD_VAR 0 4
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// Say ( result , dial ) ;
17119: LD_VAR 0 4
17123: PPUSH
17124: LD_VAR 0 2
17128: PPUSH
17129: CALL_OW 88
// end ; end_of_file
17133: LD_VAR 0 4
17137: RET
// export function CustomEvent ( event ) ; begin
17138: LD_INT 0
17140: PPUSH
// end ;
17141: LD_VAR 0 2
17145: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL_OW 255
17155: PUSH
17156: LD_INT 1
17158: EQUAL
17159: IFFALSE 17169
// artifact_get := true ;
17161: LD_ADDR_EXP 13
17165: PUSH
17166: LD_INT 1
17168: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 255
17178: PUSH
17179: LD_INT 2
17181: EQUAL
17182: IFFALSE 17200
// begin artifact_get := false ;
17184: LD_ADDR_EXP 13
17188: PUSH
17189: LD_INT 0
17191: ST_TO_ADDR
// artifact_stolen := true ;
17192: LD_ADDR_EXP 12
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17200: LD_ADDR_EXP 14
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: PPOPN 2
17210: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17211: LD_ADDR_EXP 14
17215: PUSH
17216: LD_INT 0
17218: ST_TO_ADDR
// end ;
17219: PPOPN 2
17221: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17222: LD_VAR 0 1
17226: PUSH
17227: LD_EXP 21
17231: EQUAL
17232: IFFALSE 17243
// begin YouLost ( JMM ) ;
17234: LD_STRING JMM
17236: PPUSH
17237: CALL_OW 104
// exit ;
17241: GO 17375
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17243: LD_VAR 0 1
17247: PUSH
17248: LD_INT 22
17250: PUSH
17251: LD_INT 1
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: PUSH
17258: LD_INT 21
17260: PUSH
17261: LD_INT 1
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 25
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 2
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 4
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 5
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 8
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: LIST
17344: PPUSH
17345: CALL_OW 69
17349: IN
17350: IFFALSE 17366
// loses_counter := loses_counter + 1 ;
17352: LD_ADDR_EXP 17
17356: PUSH
17357: LD_EXP 17
17361: PUSH
17362: LD_INT 1
17364: PLUS
17365: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17366: LD_VAR 0 1
17370: PPUSH
17371: CALL 45422 0 1
// end ;
17375: PPOPN 1
17377: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17378: LD_VAR 0 1
17382: PPUSH
17383: LD_VAR 0 2
17387: PPUSH
17388: CALL 47756 0 2
// end ;
17392: PPOPN 2
17394: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17395: LD_VAR 0 1
17399: PPUSH
17400: CALL 47065 0 1
// end ;
17404: PPOPN 1
17406: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: LD_VAR 0 2
17416: PPUSH
17417: LD_VAR 0 3
17421: PPUSH
17422: LD_VAR 0 4
17426: PPUSH
17427: LD_VAR 0 5
17431: PPUSH
17432: CALL 44738 0 5
// end ;
17436: PPOPN 5
17438: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17439: LD_VAR 0 1
17443: PPUSH
17444: CALL_OW 248
17448: PUSH
17449: LD_INT 1
17451: EQUAL
17452: IFFALSE 17462
// am_veh_consturcted := true ;
17454: LD_ADDR_EXP 20
17458: PUSH
17459: LD_INT 1
17461: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17462: LD_VAR 0 1
17466: PPUSH
17467: LD_VAR 0 2
17471: PPUSH
17472: CALL 44319 0 2
// end ;
17476: PPOPN 2
17478: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17479: LD_VAR 0 1
17483: PPUSH
17484: CALL_OW 247
17488: PUSH
17489: LD_INT 2
17491: EQUAL
17492: IFFALSE 17496
// exit ;
17494: GO 17513
// if not kamikazed then
17496: LD_EXP 11
17500: NOT
17501: IFFALSE 17513
// kamikazed := unit ;
17503: LD_ADDR_EXP 11
17507: PUSH
17508: LD_VAR 0 1
17512: ST_TO_ADDR
// end ;
17513: PPOPN 1
17515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17516: LD_INT 0
17518: PPUSH
17519: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17520: LD_VAR 0 1
17524: PPUSH
17525: LD_VAR 0 2
17529: PPUSH
17530: LD_VAR 0 3
17534: PPUSH
17535: LD_VAR 0 4
17539: PPUSH
17540: CALL 44157 0 4
// end ;
17544: PPOPN 6
17546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17547: LD_VAR 0 1
17551: PPUSH
17552: LD_VAR 0 2
17556: PPUSH
17557: LD_VAR 0 3
17561: PPUSH
17562: CALL 43932 0 3
// end ;
17566: PPOPN 3
17568: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17569: LD_VAR 0 1
17573: PPUSH
17574: LD_VAR 0 2
17578: PPUSH
17579: CALL 45118 0 2
// end ;
17583: PPOPN 2
17585: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_VAR 0 2
17595: PPUSH
17596: CALL 43626 0 2
// end ;
17600: PPOPN 2
17602: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17603: LD_VAR 0 1
17607: PPUSH
17608: LD_VAR 0 2
17612: PPUSH
17613: CALL 43817 0 2
// end ;
17617: PPOPN 2
17619: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17620: LD_VAR 0 1
17624: PPUSH
17625: CALL 46824 0 1
// end ;
17629: PPOPN 1
17631: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17632: LD_VAR 0 1
17636: PPUSH
17637: LD_VAR 0 2
17641: PPUSH
17642: CALL 48051 0 2
// end ;
17646: PPOPN 2
17648: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17649: LD_VAR 0 1
17653: PPUSH
17654: LD_VAR 0 2
17658: PPUSH
17659: LD_VAR 0 3
17663: PPUSH
17664: LD_VAR 0 4
17668: PPUSH
17669: CALL 48267 0 4
// end ;
17673: PPOPN 4
17675: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: CALL 101409 0 1
// end ; end_of_file
17685: PPOPN 1
17687: END
// every 0 0$1 trigger game do
17688: LD_EXP 2
17692: IFFALSE 17722
17694: GO 17696
17696: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17697: LD_INT 7
17699: PUSH
17700: LD_INT 6
17702: PUSH
17703: LD_INT 4
17705: PUSH
17706: LD_INT 6
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: PPUSH
17715: LD_INT 1750
17717: PPUSH
17718: CALL 17723 0 2
17722: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17723: LD_INT 0
17725: PPUSH
17726: PPUSH
17727: PPUSH
// if not areas then
17728: LD_VAR 0 1
17732: NOT
17733: IFFALSE 17737
// exit ;
17735: GO 17867
// repeat wait ( time ) ;
17737: LD_VAR 0 2
17741: PPUSH
17742: CALL_OW 67
// for i in areas do
17746: LD_ADDR_VAR 0 4
17750: PUSH
17751: LD_VAR 0 1
17755: PUSH
17756: FOR_IN
17757: IFFALSE 17826
// begin p := rand ( 1 , 90 ) ;
17759: LD_ADDR_VAR 0 5
17763: PUSH
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 90
17769: PPUSH
17770: CALL_OW 12
17774: ST_TO_ADDR
// if Prob ( p ) then
17775: LD_VAR 0 5
17779: PPUSH
17780: CALL_OW 13
17784: IFFALSE 17824
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17786: LD_INT 2
17788: PPUSH
17789: LD_INT 5
17791: PPUSH
17792: CALL_OW 12
17796: PPUSH
17797: LD_VAR 0 4
17801: PPUSH
17802: LD_INT 1
17804: PPUSH
17805: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17809: LD_INT 735
17811: PPUSH
17812: LD_INT 1295
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// end ; end ;
17824: GO 17756
17826: POP
17827: POP
// time := time + 0 0$3 ;
17828: LD_ADDR_VAR 0 2
17832: PUSH
17833: LD_VAR 0 2
17837: PUSH
17838: LD_INT 105
17840: PLUS
17841: ST_TO_ADDR
// if time > 6 6$00 then
17842: LD_VAR 0 2
17846: PUSH
17847: LD_INT 12600
17849: GREATER
17850: IFFALSE 17860
// time := 0 0$40 ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: LD_INT 1400
17859: ST_TO_ADDR
// until not game ;
17860: LD_EXP 2
17864: NOT
17865: IFFALSE 17737
// end ;
17867: LD_VAR 0 3
17871: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17872: LD_OWVAR 1
17876: PUSH
17877: LD_INT 84000
17879: PUSH
17880: LD_INT 73500
17882: PUSH
17883: LD_INT 63000
17885: PUSH
17886: LD_INT 52500
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: PUSH
17895: LD_OWVAR 67
17899: ARRAY
17900: LESS
17901: IFFALSE 17928
17903: GO 17905
17905: DISABLE
// begin enable ;
17906: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17907: LD_INT 1
17909: PPUSH
17910: LD_INT 5
17912: PPUSH
17913: CALL_OW 12
17917: PPUSH
17918: LD_INT 7
17920: PPUSH
17921: LD_INT 1
17923: PPUSH
17924: CALL_OW 55
// end ; end_of_file
17928: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17929: LD_INT 0
17931: PPUSH
17932: PPUSH
// skirmish := false ;
17933: LD_ADDR_EXP 48
17937: PUSH
17938: LD_INT 0
17940: ST_TO_ADDR
// debug_mc := false ;
17941: LD_ADDR_EXP 49
17945: PUSH
17946: LD_INT 0
17948: ST_TO_ADDR
// mc_bases := [ ] ;
17949: LD_ADDR_EXP 50
17953: PUSH
17954: EMPTY
17955: ST_TO_ADDR
// mc_sides := [ ] ;
17956: LD_ADDR_EXP 76
17960: PUSH
17961: EMPTY
17962: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17963: LD_ADDR_EXP 51
17967: PUSH
17968: EMPTY
17969: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17970: LD_ADDR_EXP 52
17974: PUSH
17975: EMPTY
17976: ST_TO_ADDR
// mc_need_heal := [ ] ;
17977: LD_ADDR_EXP 53
17981: PUSH
17982: EMPTY
17983: ST_TO_ADDR
// mc_healers := [ ] ;
17984: LD_ADDR_EXP 54
17988: PUSH
17989: EMPTY
17990: ST_TO_ADDR
// mc_build_list := [ ] ;
17991: LD_ADDR_EXP 55
17995: PUSH
17996: EMPTY
17997: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17998: LD_ADDR_EXP 82
18002: PUSH
18003: EMPTY
18004: ST_TO_ADDR
// mc_builders := [ ] ;
18005: LD_ADDR_EXP 56
18009: PUSH
18010: EMPTY
18011: ST_TO_ADDR
// mc_construct_list := [ ] ;
18012: LD_ADDR_EXP 57
18016: PUSH
18017: EMPTY
18018: ST_TO_ADDR
// mc_turret_list := [ ] ;
18019: LD_ADDR_EXP 58
18023: PUSH
18024: EMPTY
18025: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18026: LD_ADDR_EXP 59
18030: PUSH
18031: EMPTY
18032: ST_TO_ADDR
// mc_miners := [ ] ;
18033: LD_ADDR_EXP 64
18037: PUSH
18038: EMPTY
18039: ST_TO_ADDR
// mc_mines := [ ] ;
18040: LD_ADDR_EXP 63
18044: PUSH
18045: EMPTY
18046: ST_TO_ADDR
// mc_minefields := [ ] ;
18047: LD_ADDR_EXP 65
18051: PUSH
18052: EMPTY
18053: ST_TO_ADDR
// mc_crates := [ ] ;
18054: LD_ADDR_EXP 66
18058: PUSH
18059: EMPTY
18060: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18061: LD_ADDR_EXP 67
18065: PUSH
18066: EMPTY
18067: ST_TO_ADDR
// mc_crates_area := [ ] ;
18068: LD_ADDR_EXP 68
18072: PUSH
18073: EMPTY
18074: ST_TO_ADDR
// mc_vehicles := [ ] ;
18075: LD_ADDR_EXP 69
18079: PUSH
18080: EMPTY
18081: ST_TO_ADDR
// mc_attack := [ ] ;
18082: LD_ADDR_EXP 70
18086: PUSH
18087: EMPTY
18088: ST_TO_ADDR
// mc_produce := [ ] ;
18089: LD_ADDR_EXP 71
18093: PUSH
18094: EMPTY
18095: ST_TO_ADDR
// mc_defender := [ ] ;
18096: LD_ADDR_EXP 72
18100: PUSH
18101: EMPTY
18102: ST_TO_ADDR
// mc_parking := [ ] ;
18103: LD_ADDR_EXP 74
18107: PUSH
18108: EMPTY
18109: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18110: LD_ADDR_EXP 60
18114: PUSH
18115: EMPTY
18116: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18117: LD_ADDR_EXP 62
18121: PUSH
18122: EMPTY
18123: ST_TO_ADDR
// mc_scan := [ ] ;
18124: LD_ADDR_EXP 73
18128: PUSH
18129: EMPTY
18130: ST_TO_ADDR
// mc_scan_area := [ ] ;
18131: LD_ADDR_EXP 75
18135: PUSH
18136: EMPTY
18137: ST_TO_ADDR
// mc_tech := [ ] ;
18138: LD_ADDR_EXP 77
18142: PUSH
18143: EMPTY
18144: ST_TO_ADDR
// mc_class := [ ] ;
18145: LD_ADDR_EXP 91
18149: PUSH
18150: EMPTY
18151: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18152: LD_ADDR_EXP 92
18156: PUSH
18157: EMPTY
18158: ST_TO_ADDR
// mc_is_defending := [ ] ;
18159: LD_ADDR_EXP 93
18163: PUSH
18164: EMPTY
18165: ST_TO_ADDR
// end ;
18166: LD_VAR 0 1
18170: RET
// export function MC_Kill ( base ) ; begin
18171: LD_INT 0
18173: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18174: LD_ADDR_EXP 50
18178: PUSH
18179: LD_EXP 50
18183: PPUSH
18184: LD_VAR 0 1
18188: PPUSH
18189: EMPTY
18190: PPUSH
18191: CALL_OW 1
18195: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18196: LD_ADDR_EXP 51
18200: PUSH
18201: LD_EXP 51
18205: PPUSH
18206: LD_VAR 0 1
18210: PPUSH
18211: EMPTY
18212: PPUSH
18213: CALL_OW 1
18217: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18218: LD_ADDR_EXP 52
18222: PUSH
18223: LD_EXP 52
18227: PPUSH
18228: LD_VAR 0 1
18232: PPUSH
18233: EMPTY
18234: PPUSH
18235: CALL_OW 1
18239: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18240: LD_ADDR_EXP 53
18244: PUSH
18245: LD_EXP 53
18249: PPUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: EMPTY
18256: PPUSH
18257: CALL_OW 1
18261: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18262: LD_ADDR_EXP 54
18266: PUSH
18267: LD_EXP 54
18271: PPUSH
18272: LD_VAR 0 1
18276: PPUSH
18277: EMPTY
18278: PPUSH
18279: CALL_OW 1
18283: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18284: LD_ADDR_EXP 55
18288: PUSH
18289: LD_EXP 55
18293: PPUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: EMPTY
18300: PPUSH
18301: CALL_OW 1
18305: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18306: LD_ADDR_EXP 56
18310: PUSH
18311: LD_EXP 56
18315: PPUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: EMPTY
18322: PPUSH
18323: CALL_OW 1
18327: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18328: LD_ADDR_EXP 57
18332: PUSH
18333: LD_EXP 57
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: EMPTY
18344: PPUSH
18345: CALL_OW 1
18349: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18350: LD_ADDR_EXP 58
18354: PUSH
18355: LD_EXP 58
18359: PPUSH
18360: LD_VAR 0 1
18364: PPUSH
18365: EMPTY
18366: PPUSH
18367: CALL_OW 1
18371: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18372: LD_ADDR_EXP 59
18376: PUSH
18377: LD_EXP 59
18381: PPUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: EMPTY
18388: PPUSH
18389: CALL_OW 1
18393: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18394: LD_ADDR_EXP 60
18398: PUSH
18399: LD_EXP 60
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: EMPTY
18410: PPUSH
18411: CALL_OW 1
18415: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18416: LD_ADDR_EXP 61
18420: PUSH
18421: LD_EXP 61
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: LD_INT 0
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18439: LD_ADDR_EXP 62
18443: PUSH
18444: LD_EXP 62
18448: PPUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: EMPTY
18455: PPUSH
18456: CALL_OW 1
18460: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18461: LD_ADDR_EXP 63
18465: PUSH
18466: LD_EXP 63
18470: PPUSH
18471: LD_VAR 0 1
18475: PPUSH
18476: EMPTY
18477: PPUSH
18478: CALL_OW 1
18482: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18483: LD_ADDR_EXP 64
18487: PUSH
18488: LD_EXP 64
18492: PPUSH
18493: LD_VAR 0 1
18497: PPUSH
18498: EMPTY
18499: PPUSH
18500: CALL_OW 1
18504: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18505: LD_ADDR_EXP 65
18509: PUSH
18510: LD_EXP 65
18514: PPUSH
18515: LD_VAR 0 1
18519: PPUSH
18520: EMPTY
18521: PPUSH
18522: CALL_OW 1
18526: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18527: LD_ADDR_EXP 66
18531: PUSH
18532: LD_EXP 66
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: EMPTY
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18549: LD_ADDR_EXP 67
18553: PUSH
18554: LD_EXP 67
18558: PPUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: EMPTY
18565: PPUSH
18566: CALL_OW 1
18570: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18571: LD_ADDR_EXP 68
18575: PUSH
18576: LD_EXP 68
18580: PPUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: EMPTY
18587: PPUSH
18588: CALL_OW 1
18592: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18593: LD_ADDR_EXP 69
18597: PUSH
18598: LD_EXP 69
18602: PPUSH
18603: LD_VAR 0 1
18607: PPUSH
18608: EMPTY
18609: PPUSH
18610: CALL_OW 1
18614: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18615: LD_ADDR_EXP 70
18619: PUSH
18620: LD_EXP 70
18624: PPUSH
18625: LD_VAR 0 1
18629: PPUSH
18630: EMPTY
18631: PPUSH
18632: CALL_OW 1
18636: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18637: LD_ADDR_EXP 71
18641: PUSH
18642: LD_EXP 71
18646: PPUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: EMPTY
18653: PPUSH
18654: CALL_OW 1
18658: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18659: LD_ADDR_EXP 72
18663: PUSH
18664: LD_EXP 72
18668: PPUSH
18669: LD_VAR 0 1
18673: PPUSH
18674: EMPTY
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18681: LD_ADDR_EXP 73
18685: PUSH
18686: LD_EXP 73
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18703: LD_ADDR_EXP 74
18707: PUSH
18708: LD_EXP 74
18712: PPUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18725: LD_ADDR_EXP 75
18729: PUSH
18730: LD_EXP 75
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18747: LD_ADDR_EXP 77
18751: PUSH
18752: LD_EXP 77
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18769: LD_ADDR_EXP 79
18773: PUSH
18774: LD_EXP 79
18778: PPUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18791: LD_ADDR_EXP 80
18795: PUSH
18796: LD_EXP 80
18800: PPUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18813: LD_ADDR_EXP 81
18817: PUSH
18818: LD_EXP 81
18822: PPUSH
18823: LD_VAR 0 1
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18835: LD_ADDR_EXP 82
18839: PUSH
18840: LD_EXP 82
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18857: LD_ADDR_EXP 83
18861: PUSH
18862: LD_EXP 83
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18879: LD_ADDR_EXP 84
18883: PUSH
18884: LD_EXP 84
18888: PPUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18901: LD_ADDR_EXP 85
18905: PUSH
18906: LD_EXP 85
18910: PPUSH
18911: LD_VAR 0 1
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18923: LD_ADDR_EXP 86
18927: PUSH
18928: LD_EXP 86
18932: PPUSH
18933: LD_VAR 0 1
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18945: LD_ADDR_EXP 87
18949: PUSH
18950: LD_EXP 87
18954: PPUSH
18955: LD_VAR 0 1
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18967: LD_ADDR_EXP 88
18971: PUSH
18972: LD_EXP 88
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18989: LD_ADDR_EXP 89
18993: PUSH
18994: LD_EXP 89
18998: PPUSH
18999: LD_VAR 0 1
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19011: LD_ADDR_EXP 90
19015: PUSH
19016: LD_EXP 90
19020: PPUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19033: LD_ADDR_EXP 91
19037: PUSH
19038: LD_EXP 91
19042: PPUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19055: LD_ADDR_EXP 92
19059: PUSH
19060: LD_EXP 92
19064: PPUSH
19065: LD_VAR 0 1
19069: PPUSH
19070: LD_INT 0
19072: PPUSH
19073: CALL_OW 1
19077: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19078: LD_ADDR_EXP 93
19082: PUSH
19083: LD_EXP 93
19087: PPUSH
19088: LD_VAR 0 1
19092: PPUSH
19093: LD_INT 0
19095: PPUSH
19096: CALL_OW 1
19100: ST_TO_ADDR
// end ;
19101: LD_VAR 0 2
19105: RET
// export function MC_Add ( side , units ) ; var base ; begin
19106: LD_INT 0
19108: PPUSH
19109: PPUSH
// base := mc_bases + 1 ;
19110: LD_ADDR_VAR 0 4
19114: PUSH
19115: LD_EXP 50
19119: PUSH
19120: LD_INT 1
19122: PLUS
19123: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19124: LD_ADDR_EXP 76
19128: PUSH
19129: LD_EXP 76
19133: PPUSH
19134: LD_VAR 0 4
19138: PPUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19149: LD_ADDR_EXP 50
19153: PUSH
19154: LD_EXP 50
19158: PPUSH
19159: LD_VAR 0 4
19163: PPUSH
19164: LD_VAR 0 2
19168: PPUSH
19169: CALL_OW 1
19173: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19174: LD_ADDR_EXP 51
19178: PUSH
19179: LD_EXP 51
19183: PPUSH
19184: LD_VAR 0 4
19188: PPUSH
19189: EMPTY
19190: PPUSH
19191: CALL_OW 1
19195: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19196: LD_ADDR_EXP 52
19200: PUSH
19201: LD_EXP 52
19205: PPUSH
19206: LD_VAR 0 4
19210: PPUSH
19211: EMPTY
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19218: LD_ADDR_EXP 53
19222: PUSH
19223: LD_EXP 53
19227: PPUSH
19228: LD_VAR 0 4
19232: PPUSH
19233: EMPTY
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19240: LD_ADDR_EXP 54
19244: PUSH
19245: LD_EXP 54
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19262: LD_ADDR_EXP 55
19266: PUSH
19267: LD_EXP 55
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19284: LD_ADDR_EXP 56
19288: PUSH
19289: LD_EXP 56
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19306: LD_ADDR_EXP 57
19310: PUSH
19311: LD_EXP 57
19315: PPUSH
19316: LD_VAR 0 4
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19328: LD_ADDR_EXP 58
19332: PUSH
19333: LD_EXP 58
19337: PPUSH
19338: LD_VAR 0 4
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19350: LD_ADDR_EXP 59
19354: PUSH
19355: LD_EXP 59
19359: PPUSH
19360: LD_VAR 0 4
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19372: LD_ADDR_EXP 60
19376: PUSH
19377: LD_EXP 60
19381: PPUSH
19382: LD_VAR 0 4
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19394: LD_ADDR_EXP 61
19398: PUSH
19399: LD_EXP 61
19403: PPUSH
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 1
19416: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19417: LD_ADDR_EXP 62
19421: PUSH
19422: LD_EXP 62
19426: PPUSH
19427: LD_VAR 0 4
19431: PPUSH
19432: EMPTY
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19439: LD_ADDR_EXP 63
19443: PUSH
19444: LD_EXP 63
19448: PPUSH
19449: LD_VAR 0 4
19453: PPUSH
19454: EMPTY
19455: PPUSH
19456: CALL_OW 1
19460: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19461: LD_ADDR_EXP 64
19465: PUSH
19466: LD_EXP 64
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: EMPTY
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19483: LD_ADDR_EXP 65
19487: PUSH
19488: LD_EXP 65
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19505: LD_ADDR_EXP 66
19509: PUSH
19510: LD_EXP 66
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19527: LD_ADDR_EXP 67
19531: PUSH
19532: LD_EXP 67
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19549: LD_ADDR_EXP 68
19553: PUSH
19554: LD_EXP 68
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19571: LD_ADDR_EXP 69
19575: PUSH
19576: LD_EXP 69
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_EXP 70
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19615: LD_ADDR_EXP 71
19619: PUSH
19620: LD_EXP 71
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19637: LD_ADDR_EXP 72
19641: PUSH
19642: LD_EXP 72
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19659: LD_ADDR_EXP 73
19663: PUSH
19664: LD_EXP 73
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19681: LD_ADDR_EXP 74
19685: PUSH
19686: LD_EXP 74
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19703: LD_ADDR_EXP 75
19707: PUSH
19708: LD_EXP 75
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19725: LD_ADDR_EXP 77
19729: PUSH
19730: LD_EXP 77
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19747: LD_ADDR_EXP 79
19751: PUSH
19752: LD_EXP 79
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19769: LD_ADDR_EXP 80
19773: PUSH
19774: LD_EXP 80
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19791: LD_ADDR_EXP 81
19795: PUSH
19796: LD_EXP 81
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19813: LD_ADDR_EXP 82
19817: PUSH
19818: LD_EXP 82
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19835: LD_ADDR_EXP 83
19839: PUSH
19840: LD_EXP 83
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19857: LD_ADDR_EXP 84
19861: PUSH
19862: LD_EXP 84
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19879: LD_ADDR_EXP 85
19883: PUSH
19884: LD_EXP 85
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19901: LD_ADDR_EXP 86
19905: PUSH
19906: LD_EXP 86
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19923: LD_ADDR_EXP 87
19927: PUSH
19928: LD_EXP 87
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: EMPTY
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19945: LD_ADDR_EXP 88
19949: PUSH
19950: LD_EXP 88
19954: PPUSH
19955: LD_VAR 0 4
19959: PPUSH
19960: EMPTY
19961: PPUSH
19962: CALL_OW 1
19966: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19967: LD_ADDR_EXP 89
19971: PUSH
19972: LD_EXP 89
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: EMPTY
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19989: LD_ADDR_EXP 90
19993: PUSH
19994: LD_EXP 90
19998: PPUSH
19999: LD_VAR 0 4
20003: PPUSH
20004: EMPTY
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20011: LD_ADDR_EXP 91
20015: PUSH
20016: LD_EXP 91
20020: PPUSH
20021: LD_VAR 0 4
20025: PPUSH
20026: EMPTY
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20033: LD_ADDR_EXP 92
20037: PUSH
20038: LD_EXP 92
20042: PPUSH
20043: LD_VAR 0 4
20047: PPUSH
20048: LD_INT 0
20050: PPUSH
20051: CALL_OW 1
20055: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20056: LD_ADDR_EXP 93
20060: PUSH
20061: LD_EXP 93
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: LD_INT 0
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// result := base ;
20079: LD_ADDR_VAR 0 3
20083: PUSH
20084: LD_VAR 0 4
20088: ST_TO_ADDR
// end ;
20089: LD_VAR 0 3
20093: RET
// export function MC_Start ( ) ; var i ; begin
20094: LD_INT 0
20096: PPUSH
20097: PPUSH
// for i = 1 to mc_bases do
20098: LD_ADDR_VAR 0 2
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_EXP 50
20112: PUSH
20113: FOR_TO
20114: IFFALSE 21214
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20116: LD_ADDR_EXP 50
20120: PUSH
20121: LD_EXP 50
20125: PPUSH
20126: LD_VAR 0 2
20130: PPUSH
20131: LD_EXP 50
20135: PUSH
20136: LD_VAR 0 2
20140: ARRAY
20141: PUSH
20142: LD_INT 0
20144: DIFF
20145: PPUSH
20146: CALL_OW 1
20150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20151: LD_ADDR_EXP 51
20155: PUSH
20156: LD_EXP 51
20160: PPUSH
20161: LD_VAR 0 2
20165: PPUSH
20166: EMPTY
20167: PPUSH
20168: CALL_OW 1
20172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20173: LD_ADDR_EXP 52
20177: PUSH
20178: LD_EXP 52
20182: PPUSH
20183: LD_VAR 0 2
20187: PPUSH
20188: EMPTY
20189: PPUSH
20190: CALL_OW 1
20194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20195: LD_ADDR_EXP 53
20199: PUSH
20200: LD_EXP 53
20204: PPUSH
20205: LD_VAR 0 2
20209: PPUSH
20210: EMPTY
20211: PPUSH
20212: CALL_OW 1
20216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20217: LD_ADDR_EXP 54
20221: PUSH
20222: LD_EXP 54
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: EMPTY
20233: PUSH
20234: EMPTY
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 1
20244: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20245: LD_ADDR_EXP 55
20249: PUSH
20250: LD_EXP 55
20254: PPUSH
20255: LD_VAR 0 2
20259: PPUSH
20260: EMPTY
20261: PPUSH
20262: CALL_OW 1
20266: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20267: LD_ADDR_EXP 82
20271: PUSH
20272: LD_EXP 82
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: EMPTY
20283: PPUSH
20284: CALL_OW 1
20288: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20289: LD_ADDR_EXP 56
20293: PUSH
20294: LD_EXP 56
20298: PPUSH
20299: LD_VAR 0 2
20303: PPUSH
20304: EMPTY
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20311: LD_ADDR_EXP 57
20315: PUSH
20316: LD_EXP 57
20320: PPUSH
20321: LD_VAR 0 2
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL_OW 1
20332: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20333: LD_ADDR_EXP 58
20337: PUSH
20338: LD_EXP 58
20342: PPUSH
20343: LD_VAR 0 2
20347: PPUSH
20348: LD_EXP 50
20352: PUSH
20353: LD_VAR 0 2
20357: ARRAY
20358: PPUSH
20359: LD_INT 2
20361: PUSH
20362: LD_INT 30
20364: PUSH
20365: LD_INT 32
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: LD_INT 30
20374: PUSH
20375: LD_INT 33
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: LIST
20386: PPUSH
20387: CALL_OW 72
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20397: LD_ADDR_EXP 59
20401: PUSH
20402: LD_EXP 59
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: LD_EXP 50
20416: PUSH
20417: LD_VAR 0 2
20421: ARRAY
20422: PPUSH
20423: LD_INT 2
20425: PUSH
20426: LD_INT 30
20428: PUSH
20429: LD_INT 32
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 30
20438: PUSH
20439: LD_INT 31
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: LIST
20450: PUSH
20451: LD_INT 58
20453: PUSH
20454: EMPTY
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PPUSH
20461: CALL_OW 72
20465: PPUSH
20466: CALL_OW 1
20470: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20471: LD_ADDR_EXP 60
20475: PUSH
20476: LD_EXP 60
20480: PPUSH
20481: LD_VAR 0 2
20485: PPUSH
20486: EMPTY
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20493: LD_ADDR_EXP 64
20497: PUSH
20498: LD_EXP 64
20502: PPUSH
20503: LD_VAR 0 2
20507: PPUSH
20508: EMPTY
20509: PPUSH
20510: CALL_OW 1
20514: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20515: LD_ADDR_EXP 63
20519: PUSH
20520: LD_EXP 63
20524: PPUSH
20525: LD_VAR 0 2
20529: PPUSH
20530: EMPTY
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20537: LD_ADDR_EXP 65
20541: PUSH
20542: LD_EXP 65
20546: PPUSH
20547: LD_VAR 0 2
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20559: LD_ADDR_EXP 66
20563: PUSH
20564: LD_EXP 66
20568: PPUSH
20569: LD_VAR 0 2
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20581: LD_ADDR_EXP 67
20585: PUSH
20586: LD_EXP 67
20590: PPUSH
20591: LD_VAR 0 2
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20603: LD_ADDR_EXP 68
20607: PUSH
20608: LD_EXP 68
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20625: LD_ADDR_EXP 69
20629: PUSH
20630: LD_EXP 69
20634: PPUSH
20635: LD_VAR 0 2
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20647: LD_ADDR_EXP 70
20651: PUSH
20652: LD_EXP 70
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20669: LD_ADDR_EXP 71
20673: PUSH
20674: LD_EXP 71
20678: PPUSH
20679: LD_VAR 0 2
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20691: LD_ADDR_EXP 72
20695: PUSH
20696: LD_EXP 72
20700: PPUSH
20701: LD_VAR 0 2
20705: PPUSH
20706: EMPTY
20707: PPUSH
20708: CALL_OW 1
20712: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20713: LD_ADDR_EXP 61
20717: PUSH
20718: LD_EXP 61
20722: PPUSH
20723: LD_VAR 0 2
20727: PPUSH
20728: LD_INT 0
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20736: LD_ADDR_EXP 74
20740: PUSH
20741: LD_EXP 74
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20759: LD_ADDR_EXP 62
20763: PUSH
20764: LD_EXP 62
20768: PPUSH
20769: LD_VAR 0 2
20773: PPUSH
20774: EMPTY
20775: PPUSH
20776: CALL_OW 1
20780: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20781: LD_ADDR_EXP 73
20785: PUSH
20786: LD_EXP 73
20790: PPUSH
20791: LD_VAR 0 2
20795: PPUSH
20796: LD_INT 0
20798: PPUSH
20799: CALL_OW 1
20803: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20804: LD_ADDR_EXP 75
20808: PUSH
20809: LD_EXP 75
20813: PPUSH
20814: LD_VAR 0 2
20818: PPUSH
20819: EMPTY
20820: PPUSH
20821: CALL_OW 1
20825: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20826: LD_ADDR_EXP 78
20830: PUSH
20831: LD_EXP 78
20835: PPUSH
20836: LD_VAR 0 2
20840: PPUSH
20841: LD_INT 0
20843: PPUSH
20844: CALL_OW 1
20848: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20849: LD_ADDR_EXP 79
20853: PUSH
20854: LD_EXP 79
20858: PPUSH
20859: LD_VAR 0 2
20863: PPUSH
20864: EMPTY
20865: PPUSH
20866: CALL_OW 1
20870: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20871: LD_ADDR_EXP 80
20875: PUSH
20876: LD_EXP 80
20880: PPUSH
20881: LD_VAR 0 2
20885: PPUSH
20886: EMPTY
20887: PPUSH
20888: CALL_OW 1
20892: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20893: LD_ADDR_EXP 81
20897: PUSH
20898: LD_EXP 81
20902: PPUSH
20903: LD_VAR 0 2
20907: PPUSH
20908: EMPTY
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20915: LD_ADDR_EXP 83
20919: PUSH
20920: LD_EXP 83
20924: PPUSH
20925: LD_VAR 0 2
20929: PPUSH
20930: LD_EXP 50
20934: PUSH
20935: LD_VAR 0 2
20939: ARRAY
20940: PPUSH
20941: LD_INT 2
20943: PUSH
20944: LD_INT 30
20946: PUSH
20947: LD_INT 6
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 30
20956: PUSH
20957: LD_INT 7
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: PUSH
20964: LD_INT 30
20966: PUSH
20967: LD_INT 8
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 72
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20990: LD_ADDR_EXP 84
20994: PUSH
20995: LD_EXP 84
20999: PPUSH
21000: LD_VAR 0 2
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21012: LD_ADDR_EXP 85
21016: PUSH
21017: LD_EXP 85
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21034: LD_ADDR_EXP 86
21038: PUSH
21039: LD_EXP 86
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21056: LD_ADDR_EXP 87
21060: PUSH
21061: LD_EXP 87
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21078: LD_ADDR_EXP 88
21082: PUSH
21083: LD_EXP 88
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21100: LD_ADDR_EXP 89
21104: PUSH
21105: LD_EXP 89
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21122: LD_ADDR_EXP 90
21126: PUSH
21127: LD_EXP 90
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21144: LD_ADDR_EXP 91
21148: PUSH
21149: LD_EXP 91
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21166: LD_ADDR_EXP 92
21170: PUSH
21171: LD_EXP 92
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: LD_INT 0
21183: PPUSH
21184: CALL_OW 1
21188: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21189: LD_ADDR_EXP 93
21193: PUSH
21194: LD_EXP 93
21198: PPUSH
21199: LD_VAR 0 2
21203: PPUSH
21204: LD_INT 0
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// end ;
21212: GO 20113
21214: POP
21215: POP
// MC_InitSides ( ) ;
21216: CALL 21502 0 0
// MC_InitResearch ( ) ;
21220: CALL 21241 0 0
// CustomInitMacro ( ) ;
21224: CALL 308 0 0
// skirmish := true ;
21228: LD_ADDR_EXP 48
21232: PUSH
21233: LD_INT 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 1
21240: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21241: LD_INT 0
21243: PPUSH
21244: PPUSH
21245: PPUSH
21246: PPUSH
21247: PPUSH
21248: PPUSH
// if not mc_bases then
21249: LD_EXP 50
21253: NOT
21254: IFFALSE 21258
// exit ;
21256: GO 21497
// for i = 1 to 8 do
21258: LD_ADDR_VAR 0 2
21262: PUSH
21263: DOUBLE
21264: LD_INT 1
21266: DEC
21267: ST_TO_ADDR
21268: LD_INT 8
21270: PUSH
21271: FOR_TO
21272: IFFALSE 21298
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21274: LD_ADDR_EXP 77
21278: PUSH
21279: LD_EXP 77
21283: PPUSH
21284: LD_VAR 0 2
21288: PPUSH
21289: EMPTY
21290: PPUSH
21291: CALL_OW 1
21295: ST_TO_ADDR
21296: GO 21271
21298: POP
21299: POP
// tmp := [ ] ;
21300: LD_ADDR_VAR 0 5
21304: PUSH
21305: EMPTY
21306: ST_TO_ADDR
// for i = 1 to mc_sides do
21307: LD_ADDR_VAR 0 2
21311: PUSH
21312: DOUBLE
21313: LD_INT 1
21315: DEC
21316: ST_TO_ADDR
21317: LD_EXP 76
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21381
// if not mc_sides [ i ] in tmp then
21325: LD_EXP 76
21329: PUSH
21330: LD_VAR 0 2
21334: ARRAY
21335: PUSH
21336: LD_VAR 0 5
21340: IN
21341: NOT
21342: IFFALSE 21379
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21344: LD_ADDR_VAR 0 5
21348: PUSH
21349: LD_VAR 0 5
21353: PPUSH
21354: LD_VAR 0 5
21358: PUSH
21359: LD_INT 1
21361: PLUS
21362: PPUSH
21363: LD_EXP 76
21367: PUSH
21368: LD_VAR 0 2
21372: ARRAY
21373: PPUSH
21374: CALL_OW 2
21378: ST_TO_ADDR
21379: GO 21322
21381: POP
21382: POP
// if not tmp then
21383: LD_VAR 0 5
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21497
// for j in tmp do
21392: LD_ADDR_VAR 0 3
21396: PUSH
21397: LD_VAR 0 5
21401: PUSH
21402: FOR_IN
21403: IFFALSE 21495
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21405: LD_ADDR_VAR 0 6
21409: PUSH
21410: LD_INT 22
21412: PUSH
21413: LD_VAR 0 3
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PPUSH
21422: CALL_OW 69
21426: ST_TO_ADDR
// if not un then
21427: LD_VAR 0 6
21431: NOT
21432: IFFALSE 21436
// continue ;
21434: GO 21402
// nation := GetNation ( un [ 1 ] ) ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 6
21445: PUSH
21446: LD_INT 1
21448: ARRAY
21449: PPUSH
21450: CALL_OW 248
21454: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21455: LD_ADDR_EXP 77
21459: PUSH
21460: LD_EXP 77
21464: PPUSH
21465: LD_VAR 0 3
21469: PPUSH
21470: LD_VAR 0 3
21474: PPUSH
21475: LD_VAR 0 4
21479: PPUSH
21480: LD_INT 1
21482: PPUSH
21483: CALL 48471 0 3
21487: PPUSH
21488: CALL_OW 1
21492: ST_TO_ADDR
// end ;
21493: GO 21402
21495: POP
21496: POP
// end ;
21497: LD_VAR 0 1
21501: RET
// export function MC_InitSides ( ) ; var i ; begin
21502: LD_INT 0
21504: PPUSH
21505: PPUSH
// if not mc_bases then
21506: LD_EXP 50
21510: NOT
21511: IFFALSE 21515
// exit ;
21513: GO 21589
// for i = 1 to mc_bases do
21515: LD_ADDR_VAR 0 2
21519: PUSH
21520: DOUBLE
21521: LD_INT 1
21523: DEC
21524: ST_TO_ADDR
21525: LD_EXP 50
21529: PUSH
21530: FOR_TO
21531: IFFALSE 21587
// if mc_bases [ i ] then
21533: LD_EXP 50
21537: PUSH
21538: LD_VAR 0 2
21542: ARRAY
21543: IFFALSE 21585
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21545: LD_ADDR_EXP 76
21549: PUSH
21550: LD_EXP 76
21554: PPUSH
21555: LD_VAR 0 2
21559: PPUSH
21560: LD_EXP 50
21564: PUSH
21565: LD_VAR 0 2
21569: ARRAY
21570: PUSH
21571: LD_INT 1
21573: ARRAY
21574: PPUSH
21575: CALL_OW 255
21579: PPUSH
21580: CALL_OW 1
21584: ST_TO_ADDR
21585: GO 21530
21587: POP
21588: POP
// end ;
21589: LD_VAR 0 1
21593: RET
// every 0 0$03 trigger skirmish do
21594: LD_EXP 48
21598: IFFALSE 21752
21600: GO 21602
21602: DISABLE
// begin enable ;
21603: ENABLE
// MC_CheckBuildings ( ) ;
21604: CALL 26250 0 0
// MC_CheckPeopleLife ( ) ;
21608: CALL 26411 0 0
// RaiseSailEvent ( 100 ) ;
21612: LD_INT 100
21614: PPUSH
21615: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21619: LD_INT 103
21621: PPUSH
21622: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21626: LD_INT 104
21628: PPUSH
21629: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21633: LD_INT 105
21635: PPUSH
21636: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21640: LD_INT 106
21642: PPUSH
21643: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21647: LD_INT 107
21649: PPUSH
21650: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21654: LD_INT 108
21656: PPUSH
21657: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21661: LD_INT 109
21663: PPUSH
21664: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21668: LD_INT 110
21670: PPUSH
21671: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21675: LD_INT 111
21677: PPUSH
21678: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21682: LD_INT 112
21684: PPUSH
21685: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21689: LD_INT 113
21691: PPUSH
21692: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21696: LD_INT 120
21698: PPUSH
21699: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21703: LD_INT 121
21705: PPUSH
21706: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21710: LD_INT 122
21712: PPUSH
21713: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21717: LD_INT 123
21719: PPUSH
21720: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21724: LD_INT 124
21726: PPUSH
21727: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21731: LD_INT 125
21733: PPUSH
21734: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21738: LD_INT 126
21740: PPUSH
21741: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21745: LD_INT 200
21747: PPUSH
21748: CALL_OW 427
// end ;
21752: END
// on SailEvent ( event ) do begin if event < 100 then
21753: LD_VAR 0 1
21757: PUSH
21758: LD_INT 100
21760: LESS
21761: IFFALSE 21772
// CustomEvent ( event ) ;
21763: LD_VAR 0 1
21767: PPUSH
21768: CALL 17138 0 1
// if event = 100 then
21772: LD_VAR 0 1
21776: PUSH
21777: LD_INT 100
21779: EQUAL
21780: IFFALSE 21786
// MC_ClassManager ( ) ;
21782: CALL 22178 0 0
// if event = 101 then
21786: LD_VAR 0 1
21790: PUSH
21791: LD_INT 101
21793: EQUAL
21794: IFFALSE 21800
// MC_RepairBuildings ( ) ;
21796: CALL 26996 0 0
// if event = 102 then
21800: LD_VAR 0 1
21804: PUSH
21805: LD_INT 102
21807: EQUAL
21808: IFFALSE 21814
// MC_Heal ( ) ;
21810: CALL 27903 0 0
// if event = 103 then
21814: LD_VAR 0 1
21818: PUSH
21819: LD_INT 103
21821: EQUAL
21822: IFFALSE 21828
// MC_Build ( ) ;
21824: CALL 28325 0 0
// if event = 104 then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_INT 104
21835: EQUAL
21836: IFFALSE 21842
// MC_TurretWeapon ( ) ;
21838: CALL 29966 0 0
// if event = 105 then
21842: LD_VAR 0 1
21846: PUSH
21847: LD_INT 105
21849: EQUAL
21850: IFFALSE 21856
// MC_BuildUpgrade ( ) ;
21852: CALL 29517 0 0
// if event = 106 then
21856: LD_VAR 0 1
21860: PUSH
21861: LD_INT 106
21863: EQUAL
21864: IFFALSE 21870
// MC_PlantMines ( ) ;
21866: CALL 30396 0 0
// if event = 107 then
21870: LD_VAR 0 1
21874: PUSH
21875: LD_INT 107
21877: EQUAL
21878: IFFALSE 21884
// MC_CollectCrates ( ) ;
21880: CALL 31187 0 0
// if event = 108 then
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 108
21891: EQUAL
21892: IFFALSE 21898
// MC_LinkRemoteControl ( ) ;
21894: CALL 33037 0 0
// if event = 109 then
21898: LD_VAR 0 1
21902: PUSH
21903: LD_INT 109
21905: EQUAL
21906: IFFALSE 21912
// MC_ProduceVehicle ( ) ;
21908: CALL 33218 0 0
// if event = 110 then
21912: LD_VAR 0 1
21916: PUSH
21917: LD_INT 110
21919: EQUAL
21920: IFFALSE 21926
// MC_SendAttack ( ) ;
21922: CALL 33684 0 0
// if event = 111 then
21926: LD_VAR 0 1
21930: PUSH
21931: LD_INT 111
21933: EQUAL
21934: IFFALSE 21940
// MC_Defend ( ) ;
21936: CALL 33792 0 0
// if event = 112 then
21940: LD_VAR 0 1
21944: PUSH
21945: LD_INT 112
21947: EQUAL
21948: IFFALSE 21954
// MC_Research ( ) ;
21950: CALL 34525 0 0
// if event = 113 then
21954: LD_VAR 0 1
21958: PUSH
21959: LD_INT 113
21961: EQUAL
21962: IFFALSE 21968
// MC_MinesTrigger ( ) ;
21964: CALL 35639 0 0
// if event = 120 then
21968: LD_VAR 0 1
21972: PUSH
21973: LD_INT 120
21975: EQUAL
21976: IFFALSE 21982
// MC_RepairVehicle ( ) ;
21978: CALL 35738 0 0
// if event = 121 then
21982: LD_VAR 0 1
21986: PUSH
21987: LD_INT 121
21989: EQUAL
21990: IFFALSE 21996
// MC_TameApe ( ) ;
21992: CALL 36479 0 0
// if event = 122 then
21996: LD_VAR 0 1
22000: PUSH
22001: LD_INT 122
22003: EQUAL
22004: IFFALSE 22010
// MC_ChangeApeClass ( ) ;
22006: CALL 37308 0 0
// if event = 123 then
22010: LD_VAR 0 1
22014: PUSH
22015: LD_INT 123
22017: EQUAL
22018: IFFALSE 22024
// MC_Bazooka ( ) ;
22020: CALL 37958 0 0
// if event = 124 then
22024: LD_VAR 0 1
22028: PUSH
22029: LD_INT 124
22031: EQUAL
22032: IFFALSE 22038
// MC_TeleportExit ( ) ;
22034: CALL 38156 0 0
// if event = 125 then
22038: LD_VAR 0 1
22042: PUSH
22043: LD_INT 125
22045: EQUAL
22046: IFFALSE 22052
// MC_Deposits ( ) ;
22048: CALL 38803 0 0
// if event = 126 then
22052: LD_VAR 0 1
22056: PUSH
22057: LD_INT 126
22059: EQUAL
22060: IFFALSE 22066
// MC_RemoteDriver ( ) ;
22062: CALL 39428 0 0
// if event = 200 then
22066: LD_VAR 0 1
22070: PUSH
22071: LD_INT 200
22073: EQUAL
22074: IFFALSE 22080
// MC_Idle ( ) ;
22076: CALL 41377 0 0
// end ;
22080: PPOPN 1
22082: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22083: LD_INT 0
22085: PPUSH
22086: PPUSH
// if not mc_bases [ base ] or not tag then
22087: LD_EXP 50
22091: PUSH
22092: LD_VAR 0 1
22096: ARRAY
22097: NOT
22098: PUSH
22099: LD_VAR 0 2
22103: NOT
22104: OR
22105: IFFALSE 22109
// exit ;
22107: GO 22173
// for i in mc_bases [ base ] union mc_ape [ base ] do
22109: LD_ADDR_VAR 0 4
22113: PUSH
22114: LD_EXP 50
22118: PUSH
22119: LD_VAR 0 1
22123: ARRAY
22124: PUSH
22125: LD_EXP 79
22129: PUSH
22130: LD_VAR 0 1
22134: ARRAY
22135: UNION
22136: PUSH
22137: FOR_IN
22138: IFFALSE 22171
// if GetTag ( i ) = tag then
22140: LD_VAR 0 4
22144: PPUSH
22145: CALL_OW 110
22149: PUSH
22150: LD_VAR 0 2
22154: EQUAL
22155: IFFALSE 22169
// SetTag ( i , 0 ) ;
22157: LD_VAR 0 4
22161: PPUSH
22162: LD_INT 0
22164: PPUSH
22165: CALL_OW 109
22169: GO 22137
22171: POP
22172: POP
// end ;
22173: LD_VAR 0 3
22177: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22178: LD_INT 0
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
22184: PPUSH
22185: PPUSH
22186: PPUSH
22187: PPUSH
// if not mc_bases then
22188: LD_EXP 50
22192: NOT
22193: IFFALSE 22197
// exit ;
22195: GO 22655
// for i = 1 to mc_bases do
22197: LD_ADDR_VAR 0 2
22201: PUSH
22202: DOUBLE
22203: LD_INT 1
22205: DEC
22206: ST_TO_ADDR
22207: LD_EXP 50
22211: PUSH
22212: FOR_TO
22213: IFFALSE 22653
// begin tmp := MC_ClassCheckReq ( i ) ;
22215: LD_ADDR_VAR 0 4
22219: PUSH
22220: LD_VAR 0 2
22224: PPUSH
22225: CALL 22660 0 1
22229: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22230: LD_ADDR_EXP 91
22234: PUSH
22235: LD_EXP 91
22239: PPUSH
22240: LD_VAR 0 2
22244: PPUSH
22245: LD_VAR 0 4
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// if not tmp then
22255: LD_VAR 0 4
22259: NOT
22260: IFFALSE 22264
// continue ;
22262: GO 22212
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22264: LD_ADDR_VAR 0 6
22268: PUSH
22269: LD_EXP 50
22273: PUSH
22274: LD_VAR 0 2
22278: ARRAY
22279: PPUSH
22280: LD_INT 2
22282: PUSH
22283: LD_INT 30
22285: PUSH
22286: LD_INT 4
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: PUSH
22293: LD_INT 30
22295: PUSH
22296: LD_INT 5
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: PPUSH
22308: CALL_OW 72
22312: PUSH
22313: LD_EXP 50
22317: PUSH
22318: LD_VAR 0 2
22322: ARRAY
22323: PPUSH
22324: LD_INT 2
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 0
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: PPUSH
22352: CALL_OW 72
22356: PUSH
22357: LD_EXP 50
22361: PUSH
22362: LD_VAR 0 2
22366: ARRAY
22367: PPUSH
22368: LD_INT 30
22370: PUSH
22371: LD_INT 3
22373: PUSH
22374: EMPTY
22375: LIST
22376: LIST
22377: PPUSH
22378: CALL_OW 72
22382: PUSH
22383: LD_EXP 50
22387: PUSH
22388: LD_VAR 0 2
22392: ARRAY
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 6
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 7
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: LD_INT 30
22419: PUSH
22420: LD_INT 8
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: PPUSH
22433: CALL_OW 72
22437: PUSH
22438: EMPTY
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: ST_TO_ADDR
// for j = 1 to 4 do
22444: LD_ADDR_VAR 0 3
22448: PUSH
22449: DOUBLE
22450: LD_INT 1
22452: DEC
22453: ST_TO_ADDR
22454: LD_INT 4
22456: PUSH
22457: FOR_TO
22458: IFFALSE 22649
// begin if not tmp [ j ] then
22460: LD_VAR 0 4
22464: PUSH
22465: LD_VAR 0 3
22469: ARRAY
22470: NOT
22471: IFFALSE 22475
// continue ;
22473: GO 22457
// for p in tmp [ j ] do
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 3
22489: ARRAY
22490: PUSH
22491: FOR_IN
22492: IFFALSE 22645
// begin if not b [ j ] then
22494: LD_VAR 0 6
22498: PUSH
22499: LD_VAR 0 3
22503: ARRAY
22504: NOT
22505: IFFALSE 22509
// break ;
22507: GO 22645
// e := 0 ;
22509: LD_ADDR_VAR 0 7
22513: PUSH
22514: LD_INT 0
22516: ST_TO_ADDR
// for k in b [ j ] do
22517: LD_ADDR_VAR 0 8
22521: PUSH
22522: LD_VAR 0 6
22526: PUSH
22527: LD_VAR 0 3
22531: ARRAY
22532: PUSH
22533: FOR_IN
22534: IFFALSE 22561
// if IsNotFull ( k ) then
22536: LD_VAR 0 8
22540: PPUSH
22541: CALL 50624 0 1
22545: IFFALSE 22559
// begin e := k ;
22547: LD_ADDR_VAR 0 7
22551: PUSH
22552: LD_VAR 0 8
22556: ST_TO_ADDR
// break ;
22557: GO 22561
// end ;
22559: GO 22533
22561: POP
22562: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22563: LD_VAR 0 7
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_VAR 0 7
22577: PPUSH
22578: CALL 83788 0 2
22582: NOT
22583: AND
22584: IFFALSE 22643
// begin if IsInUnit ( p ) then
22586: LD_VAR 0 5
22590: PPUSH
22591: CALL_OW 310
22595: IFFALSE 22606
// ComExitBuilding ( p ) ;
22597: LD_VAR 0 5
22601: PPUSH
22602: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22606: LD_VAR 0 5
22610: PPUSH
22611: LD_VAR 0 7
22615: PPUSH
22616: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22620: LD_VAR 0 5
22624: PPUSH
22625: LD_VAR 0 3
22629: PPUSH
22630: CALL_OW 183
// AddComExitBuilding ( p ) ;
22634: LD_VAR 0 5
22638: PPUSH
22639: CALL_OW 182
// end ; end ;
22643: GO 22491
22645: POP
22646: POP
// end ;
22647: GO 22457
22649: POP
22650: POP
// end ;
22651: GO 22212
22653: POP
22654: POP
// end ;
22655: LD_VAR 0 1
22659: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22660: LD_INT 0
22662: PPUSH
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
22671: PPUSH
22672: PPUSH
22673: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22674: LD_VAR 0 1
22678: NOT
22679: PUSH
22680: LD_EXP 50
22684: PUSH
22685: LD_VAR 0 1
22689: ARRAY
22690: NOT
22691: OR
22692: PUSH
22693: LD_EXP 50
22697: PUSH
22698: LD_VAR 0 1
22702: ARRAY
22703: PPUSH
22704: LD_INT 2
22706: PUSH
22707: LD_INT 30
22709: PUSH
22710: LD_INT 0
22712: PUSH
22713: EMPTY
22714: LIST
22715: LIST
22716: PUSH
22717: LD_INT 30
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: LIST
22731: PPUSH
22732: CALL_OW 72
22736: NOT
22737: OR
22738: IFFALSE 22742
// exit ;
22740: GO 26245
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22742: LD_ADDR_VAR 0 4
22746: PUSH
22747: LD_EXP 50
22751: PUSH
22752: LD_VAR 0 1
22756: ARRAY
22757: PPUSH
22758: LD_INT 2
22760: PUSH
22761: LD_INT 25
22763: PUSH
22764: LD_INT 1
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: PUSH
22771: LD_INT 25
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 25
22783: PUSH
22784: LD_INT 3
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: LD_INT 25
22793: PUSH
22794: LD_INT 4
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 25
22803: PUSH
22804: LD_INT 5
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 25
22813: PUSH
22814: LD_INT 8
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: LD_INT 25
22823: PUSH
22824: LD_INT 9
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: PPUSH
22841: CALL_OW 72
22845: ST_TO_ADDR
// if not tmp then
22846: LD_VAR 0 4
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 26245
// for i in tmp do
22855: LD_ADDR_VAR 0 3
22859: PUSH
22860: LD_VAR 0 4
22864: PUSH
22865: FOR_IN
22866: IFFALSE 22897
// if GetTag ( i ) then
22868: LD_VAR 0 3
22872: PPUSH
22873: CALL_OW 110
22877: IFFALSE 22895
// tmp := tmp diff i ;
22879: LD_ADDR_VAR 0 4
22883: PUSH
22884: LD_VAR 0 4
22888: PUSH
22889: LD_VAR 0 3
22893: DIFF
22894: ST_TO_ADDR
22895: GO 22865
22897: POP
22898: POP
// if not tmp then
22899: LD_VAR 0 4
22903: NOT
22904: IFFALSE 22908
// exit ;
22906: GO 26245
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22908: LD_ADDR_VAR 0 5
22912: PUSH
22913: LD_EXP 50
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_INT 2
22926: PUSH
22927: LD_INT 25
22929: PUSH
22930: LD_INT 1
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: PUSH
22937: LD_INT 25
22939: PUSH
22940: LD_INT 5
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: PUSH
22947: LD_INT 25
22949: PUSH
22950: LD_INT 8
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: PUSH
22957: LD_INT 25
22959: PUSH
22960: LD_INT 9
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: PPUSH
22974: CALL_OW 72
22978: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22979: LD_ADDR_VAR 0 6
22983: PUSH
22984: LD_EXP 50
22988: PUSH
22989: LD_VAR 0 1
22993: ARRAY
22994: PPUSH
22995: LD_INT 25
22997: PUSH
22998: LD_INT 2
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: PPUSH
23005: CALL_OW 72
23009: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23010: LD_ADDR_VAR 0 7
23014: PUSH
23015: LD_EXP 50
23019: PUSH
23020: LD_VAR 0 1
23024: ARRAY
23025: PPUSH
23026: LD_INT 25
23028: PUSH
23029: LD_INT 3
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 72
23040: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23041: LD_ADDR_VAR 0 8
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 25
23059: PUSH
23060: LD_INT 4
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: LD_INT 24
23069: PUSH
23070: LD_INT 251
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PPUSH
23081: CALL_OW 72
23085: ST_TO_ADDR
// if mc_is_defending [ base ] then
23086: LD_EXP 93
23090: PUSH
23091: LD_VAR 0 1
23095: ARRAY
23096: IFFALSE 23557
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23098: LD_ADDR_EXP 92
23102: PUSH
23103: LD_EXP 92
23107: PPUSH
23108: LD_VAR 0 1
23112: PPUSH
23113: LD_INT 4
23115: PPUSH
23116: CALL_OW 1
23120: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23121: LD_ADDR_VAR 0 12
23125: PUSH
23126: LD_EXP 50
23130: PUSH
23131: LD_VAR 0 1
23135: ARRAY
23136: PPUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 4
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 5
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: ST_TO_ADDR
// if not b then
23170: LD_VAR 0 12
23174: NOT
23175: IFFALSE 23179
// exit ;
23177: GO 26245
// p := [ ] ;
23179: LD_ADDR_VAR 0 11
23183: PUSH
23184: EMPTY
23185: ST_TO_ADDR
// if sci >= 2 then
23186: LD_VAR 0 8
23190: PUSH
23191: LD_INT 2
23193: GREATEREQUAL
23194: IFFALSE 23225
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23196: LD_ADDR_VAR 0 8
23200: PUSH
23201: LD_VAR 0 8
23205: PUSH
23206: LD_INT 1
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 8
23214: PUSH
23215: LD_INT 2
23217: ARRAY
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: ST_TO_ADDR
23223: GO 23286
// if sci = 1 then
23225: LD_VAR 0 8
23229: PUSH
23230: LD_INT 1
23232: EQUAL
23233: IFFALSE 23254
// sci := [ sci [ 1 ] ] else
23235: LD_ADDR_VAR 0 8
23239: PUSH
23240: LD_VAR 0 8
23244: PUSH
23245: LD_INT 1
23247: ARRAY
23248: PUSH
23249: EMPTY
23250: LIST
23251: ST_TO_ADDR
23252: GO 23286
// if sci = 0 then
23254: LD_VAR 0 8
23258: PUSH
23259: LD_INT 0
23261: EQUAL
23262: IFFALSE 23286
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23264: LD_ADDR_VAR 0 11
23268: PUSH
23269: LD_VAR 0 4
23273: PPUSH
23274: LD_INT 4
23276: PPUSH
23277: CALL 83651 0 2
23281: PUSH
23282: LD_INT 1
23284: ARRAY
23285: ST_TO_ADDR
// if eng > 4 then
23286: LD_VAR 0 6
23290: PUSH
23291: LD_INT 4
23293: GREATER
23294: IFFALSE 23340
// for i = eng downto 4 do
23296: LD_ADDR_VAR 0 3
23300: PUSH
23301: DOUBLE
23302: LD_VAR 0 6
23306: INC
23307: ST_TO_ADDR
23308: LD_INT 4
23310: PUSH
23311: FOR_DOWNTO
23312: IFFALSE 23338
// eng := eng diff eng [ i ] ;
23314: LD_ADDR_VAR 0 6
23318: PUSH
23319: LD_VAR 0 6
23323: PUSH
23324: LD_VAR 0 6
23328: PUSH
23329: LD_VAR 0 3
23333: ARRAY
23334: DIFF
23335: ST_TO_ADDR
23336: GO 23311
23338: POP
23339: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23340: LD_ADDR_VAR 0 4
23344: PUSH
23345: LD_VAR 0 4
23349: PUSH
23350: LD_VAR 0 5
23354: PUSH
23355: LD_VAR 0 6
23359: UNION
23360: PUSH
23361: LD_VAR 0 7
23365: UNION
23366: PUSH
23367: LD_VAR 0 8
23371: UNION
23372: DIFF
23373: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23374: LD_ADDR_VAR 0 13
23378: PUSH
23379: LD_EXP 50
23383: PUSH
23384: LD_VAR 0 1
23388: ARRAY
23389: PPUSH
23390: LD_INT 2
23392: PUSH
23393: LD_INT 30
23395: PUSH
23396: LD_INT 32
23398: PUSH
23399: EMPTY
23400: LIST
23401: LIST
23402: PUSH
23403: LD_INT 30
23405: PUSH
23406: LD_INT 31
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: PUSH
23423: LD_EXP 50
23427: PUSH
23428: LD_VAR 0 1
23432: ARRAY
23433: PPUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 5
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PPUSH
23462: CALL_OW 72
23466: PUSH
23467: LD_INT 6
23469: MUL
23470: PLUS
23471: ST_TO_ADDR
// if bcount < tmp then
23472: LD_VAR 0 13
23476: PUSH
23477: LD_VAR 0 4
23481: LESS
23482: IFFALSE 23528
// for i = tmp downto bcount do
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: DOUBLE
23490: LD_VAR 0 4
23494: INC
23495: ST_TO_ADDR
23496: LD_VAR 0 13
23500: PUSH
23501: FOR_DOWNTO
23502: IFFALSE 23526
// tmp := Delete ( tmp , tmp ) ;
23504: LD_ADDR_VAR 0 4
23508: PUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: LD_VAR 0 4
23518: PPUSH
23519: CALL_OW 3
23523: ST_TO_ADDR
23524: GO 23501
23526: POP
23527: POP
// result := [ tmp , 0 , 0 , p ] ;
23528: LD_ADDR_VAR 0 2
23532: PUSH
23533: LD_VAR 0 4
23537: PUSH
23538: LD_INT 0
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: LD_VAR 0 11
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: LIST
23553: LIST
23554: ST_TO_ADDR
// exit ;
23555: GO 26245
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23557: LD_EXP 50
23561: PUSH
23562: LD_VAR 0 1
23566: ARRAY
23567: PPUSH
23568: LD_INT 2
23570: PUSH
23571: LD_INT 30
23573: PUSH
23574: LD_INT 6
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: LD_INT 30
23583: PUSH
23584: LD_INT 7
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: LD_INT 30
23593: PUSH
23594: LD_INT 8
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 72
23611: NOT
23612: PUSH
23613: LD_EXP 50
23617: PUSH
23618: LD_VAR 0 1
23622: ARRAY
23623: PPUSH
23624: LD_INT 30
23626: PUSH
23627: LD_INT 3
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: PPUSH
23634: CALL_OW 72
23638: NOT
23639: AND
23640: IFFALSE 23712
// begin if eng = tmp then
23642: LD_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: EQUAL
23652: IFFALSE 23656
// exit ;
23654: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23656: LD_ADDR_EXP 92
23660: PUSH
23661: LD_EXP 92
23665: PPUSH
23666: LD_VAR 0 1
23670: PPUSH
23671: LD_INT 1
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23679: LD_ADDR_VAR 0 2
23683: PUSH
23684: LD_INT 0
23686: PUSH
23687: LD_VAR 0 4
23691: PUSH
23692: LD_VAR 0 6
23696: DIFF
23697: PUSH
23698: LD_INT 0
23700: PUSH
23701: LD_INT 0
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// exit ;
23710: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23712: LD_EXP 77
23716: PUSH
23717: LD_EXP 76
23721: PUSH
23722: LD_VAR 0 1
23726: ARRAY
23727: ARRAY
23728: PUSH
23729: LD_EXP 50
23733: PUSH
23734: LD_VAR 0 1
23738: ARRAY
23739: PPUSH
23740: LD_INT 2
23742: PUSH
23743: LD_INT 30
23745: PUSH
23746: LD_INT 6
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 30
23755: PUSH
23756: LD_INT 7
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PUSH
23763: LD_INT 30
23765: PUSH
23766: LD_INT 8
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: PPUSH
23779: CALL_OW 72
23783: AND
23784: PUSH
23785: LD_EXP 50
23789: PUSH
23790: LD_VAR 0 1
23794: ARRAY
23795: PPUSH
23796: LD_INT 30
23798: PUSH
23799: LD_INT 3
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PPUSH
23806: CALL_OW 72
23810: NOT
23811: AND
23812: IFFALSE 24026
// begin if sci >= 6 then
23814: LD_VAR 0 8
23818: PUSH
23819: LD_INT 6
23821: GREATEREQUAL
23822: IFFALSE 23826
// exit ;
23824: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23826: LD_ADDR_EXP 92
23830: PUSH
23831: LD_EXP 92
23835: PPUSH
23836: LD_VAR 0 1
23840: PPUSH
23841: LD_INT 2
23843: PPUSH
23844: CALL_OW 1
23848: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23849: LD_ADDR_VAR 0 9
23853: PUSH
23854: LD_VAR 0 4
23858: PUSH
23859: LD_VAR 0 8
23863: DIFF
23864: PPUSH
23865: LD_INT 4
23867: PPUSH
23868: CALL 83651 0 2
23872: ST_TO_ADDR
// p := [ ] ;
23873: LD_ADDR_VAR 0 11
23877: PUSH
23878: EMPTY
23879: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23880: LD_VAR 0 8
23884: PUSH
23885: LD_INT 6
23887: LESS
23888: PUSH
23889: LD_VAR 0 9
23893: PUSH
23894: LD_INT 6
23896: GREATER
23897: AND
23898: IFFALSE 23979
// begin for i = 1 to 6 - sci do
23900: LD_ADDR_VAR 0 3
23904: PUSH
23905: DOUBLE
23906: LD_INT 1
23908: DEC
23909: ST_TO_ADDR
23910: LD_INT 6
23912: PUSH
23913: LD_VAR 0 8
23917: MINUS
23918: PUSH
23919: FOR_TO
23920: IFFALSE 23975
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23922: LD_ADDR_VAR 0 11
23926: PUSH
23927: LD_VAR 0 11
23931: PPUSH
23932: LD_VAR 0 11
23936: PUSH
23937: LD_INT 1
23939: PLUS
23940: PPUSH
23941: LD_VAR 0 9
23945: PUSH
23946: LD_INT 1
23948: ARRAY
23949: PPUSH
23950: CALL_OW 2
23954: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23955: LD_ADDR_VAR 0 9
23959: PUSH
23960: LD_VAR 0 9
23964: PPUSH
23965: LD_INT 1
23967: PPUSH
23968: CALL_OW 3
23972: ST_TO_ADDR
// end ;
23973: GO 23919
23975: POP
23976: POP
// end else
23977: GO 23999
// if sort then
23979: LD_VAR 0 9
23983: IFFALSE 23999
// p := sort [ 1 ] ;
23985: LD_ADDR_VAR 0 11
23989: PUSH
23990: LD_VAR 0 9
23994: PUSH
23995: LD_INT 1
23997: ARRAY
23998: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_INT 0
24006: PUSH
24007: LD_INT 0
24009: PUSH
24010: LD_INT 0
24012: PUSH
24013: LD_VAR 0 11
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: ST_TO_ADDR
// exit ;
24024: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24026: LD_EXP 77
24030: PUSH
24031: LD_EXP 76
24035: PUSH
24036: LD_VAR 0 1
24040: ARRAY
24041: ARRAY
24042: PUSH
24043: LD_EXP 50
24047: PUSH
24048: LD_VAR 0 1
24052: ARRAY
24053: PPUSH
24054: LD_INT 2
24056: PUSH
24057: LD_INT 30
24059: PUSH
24060: LD_INT 6
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: PUSH
24067: LD_INT 30
24069: PUSH
24070: LD_INT 7
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: PUSH
24077: LD_INT 30
24079: PUSH
24080: LD_INT 8
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: PPUSH
24093: CALL_OW 72
24097: AND
24098: PUSH
24099: LD_EXP 50
24103: PUSH
24104: LD_VAR 0 1
24108: ARRAY
24109: PPUSH
24110: LD_INT 30
24112: PUSH
24113: LD_INT 3
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 72
24124: AND
24125: IFFALSE 24859
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24127: LD_ADDR_EXP 92
24131: PUSH
24132: LD_EXP 92
24136: PPUSH
24137: LD_VAR 0 1
24141: PPUSH
24142: LD_INT 3
24144: PPUSH
24145: CALL_OW 1
24149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 0
24160: PUSH
24161: LD_INT 0
24163: PUSH
24164: LD_INT 0
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: ST_TO_ADDR
// if not eng then
24173: LD_VAR 0 6
24177: NOT
24178: IFFALSE 24241
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24180: LD_ADDR_VAR 0 11
24184: PUSH
24185: LD_VAR 0 4
24189: PPUSH
24190: LD_INT 2
24192: PPUSH
24193: CALL 83651 0 2
24197: PUSH
24198: LD_INT 1
24200: ARRAY
24201: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24202: LD_ADDR_VAR 0 2
24206: PUSH
24207: LD_VAR 0 2
24211: PPUSH
24212: LD_INT 2
24214: PPUSH
24215: LD_VAR 0 11
24219: PPUSH
24220: CALL_OW 1
24224: ST_TO_ADDR
// tmp := tmp diff p ;
24225: LD_ADDR_VAR 0 4
24229: PUSH
24230: LD_VAR 0 4
24234: PUSH
24235: LD_VAR 0 11
24239: DIFF
24240: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24241: LD_VAR 0 4
24245: PUSH
24246: LD_VAR 0 8
24250: PUSH
24251: LD_INT 6
24253: LESS
24254: AND
24255: IFFALSE 24443
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24257: LD_ADDR_VAR 0 9
24261: PUSH
24262: LD_VAR 0 4
24266: PUSH
24267: LD_VAR 0 8
24271: PUSH
24272: LD_VAR 0 7
24276: UNION
24277: DIFF
24278: PPUSH
24279: LD_INT 4
24281: PPUSH
24282: CALL 83651 0 2
24286: ST_TO_ADDR
// p := [ ] ;
24287: LD_ADDR_VAR 0 11
24291: PUSH
24292: EMPTY
24293: ST_TO_ADDR
// if sort then
24294: LD_VAR 0 9
24298: IFFALSE 24414
// for i = 1 to 6 - sci do
24300: LD_ADDR_VAR 0 3
24304: PUSH
24305: DOUBLE
24306: LD_INT 1
24308: DEC
24309: ST_TO_ADDR
24310: LD_INT 6
24312: PUSH
24313: LD_VAR 0 8
24317: MINUS
24318: PUSH
24319: FOR_TO
24320: IFFALSE 24412
// begin if i = sort then
24322: LD_VAR 0 3
24326: PUSH
24327: LD_VAR 0 9
24331: EQUAL
24332: IFFALSE 24336
// break ;
24334: GO 24412
// if GetClass ( i ) = 4 then
24336: LD_VAR 0 3
24340: PPUSH
24341: CALL_OW 257
24345: PUSH
24346: LD_INT 4
24348: EQUAL
24349: IFFALSE 24353
// continue ;
24351: GO 24319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24353: LD_ADDR_VAR 0 11
24357: PUSH
24358: LD_VAR 0 11
24362: PPUSH
24363: LD_VAR 0 11
24367: PUSH
24368: LD_INT 1
24370: PLUS
24371: PPUSH
24372: LD_VAR 0 9
24376: PUSH
24377: LD_VAR 0 3
24381: ARRAY
24382: PPUSH
24383: CALL_OW 2
24387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24388: LD_ADDR_VAR 0 4
24392: PUSH
24393: LD_VAR 0 4
24397: PUSH
24398: LD_VAR 0 9
24402: PUSH
24403: LD_VAR 0 3
24407: ARRAY
24408: DIFF
24409: ST_TO_ADDR
// end ;
24410: GO 24319
24412: POP
24413: POP
// if p then
24414: LD_VAR 0 11
24418: IFFALSE 24443
// result := Replace ( result , 4 , p ) ;
24420: LD_ADDR_VAR 0 2
24424: PUSH
24425: LD_VAR 0 2
24429: PPUSH
24430: LD_INT 4
24432: PPUSH
24433: LD_VAR 0 11
24437: PPUSH
24438: CALL_OW 1
24442: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24443: LD_VAR 0 4
24447: PUSH
24448: LD_VAR 0 7
24452: PUSH
24453: LD_INT 6
24455: LESS
24456: AND
24457: IFFALSE 24645
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24459: LD_ADDR_VAR 0 9
24463: PUSH
24464: LD_VAR 0 4
24468: PUSH
24469: LD_VAR 0 8
24473: PUSH
24474: LD_VAR 0 7
24478: UNION
24479: DIFF
24480: PPUSH
24481: LD_INT 3
24483: PPUSH
24484: CALL 83651 0 2
24488: ST_TO_ADDR
// p := [ ] ;
24489: LD_ADDR_VAR 0 11
24493: PUSH
24494: EMPTY
24495: ST_TO_ADDR
// if sort then
24496: LD_VAR 0 9
24500: IFFALSE 24616
// for i = 1 to 6 - mech do
24502: LD_ADDR_VAR 0 3
24506: PUSH
24507: DOUBLE
24508: LD_INT 1
24510: DEC
24511: ST_TO_ADDR
24512: LD_INT 6
24514: PUSH
24515: LD_VAR 0 7
24519: MINUS
24520: PUSH
24521: FOR_TO
24522: IFFALSE 24614
// begin if i = sort then
24524: LD_VAR 0 3
24528: PUSH
24529: LD_VAR 0 9
24533: EQUAL
24534: IFFALSE 24538
// break ;
24536: GO 24614
// if GetClass ( i ) = 3 then
24538: LD_VAR 0 3
24542: PPUSH
24543: CALL_OW 257
24547: PUSH
24548: LD_INT 3
24550: EQUAL
24551: IFFALSE 24555
// continue ;
24553: GO 24521
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 11
24564: PPUSH
24565: LD_VAR 0 11
24569: PUSH
24570: LD_INT 1
24572: PLUS
24573: PPUSH
24574: LD_VAR 0 9
24578: PUSH
24579: LD_VAR 0 3
24583: ARRAY
24584: PPUSH
24585: CALL_OW 2
24589: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24590: LD_ADDR_VAR 0 4
24594: PUSH
24595: LD_VAR 0 4
24599: PUSH
24600: LD_VAR 0 9
24604: PUSH
24605: LD_VAR 0 3
24609: ARRAY
24610: DIFF
24611: ST_TO_ADDR
// end ;
24612: GO 24521
24614: POP
24615: POP
// if p then
24616: LD_VAR 0 11
24620: IFFALSE 24645
// result := Replace ( result , 3 , p ) ;
24622: LD_ADDR_VAR 0 2
24626: PUSH
24627: LD_VAR 0 2
24631: PPUSH
24632: LD_INT 3
24634: PPUSH
24635: LD_VAR 0 11
24639: PPUSH
24640: CALL_OW 1
24644: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24645: LD_VAR 0 4
24649: PUSH
24650: LD_INT 6
24652: GREATER
24653: PUSH
24654: LD_VAR 0 6
24658: PUSH
24659: LD_INT 6
24661: LESS
24662: AND
24663: IFFALSE 24857
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24665: LD_ADDR_VAR 0 9
24669: PUSH
24670: LD_VAR 0 4
24674: PUSH
24675: LD_VAR 0 8
24679: PUSH
24680: LD_VAR 0 7
24684: UNION
24685: PUSH
24686: LD_VAR 0 6
24690: UNION
24691: DIFF
24692: PPUSH
24693: LD_INT 2
24695: PPUSH
24696: CALL 83651 0 2
24700: ST_TO_ADDR
// p := [ ] ;
24701: LD_ADDR_VAR 0 11
24705: PUSH
24706: EMPTY
24707: ST_TO_ADDR
// if sort then
24708: LD_VAR 0 9
24712: IFFALSE 24828
// for i = 1 to 6 - eng do
24714: LD_ADDR_VAR 0 3
24718: PUSH
24719: DOUBLE
24720: LD_INT 1
24722: DEC
24723: ST_TO_ADDR
24724: LD_INT 6
24726: PUSH
24727: LD_VAR 0 6
24731: MINUS
24732: PUSH
24733: FOR_TO
24734: IFFALSE 24826
// begin if i = sort then
24736: LD_VAR 0 3
24740: PUSH
24741: LD_VAR 0 9
24745: EQUAL
24746: IFFALSE 24750
// break ;
24748: GO 24826
// if GetClass ( i ) = 2 then
24750: LD_VAR 0 3
24754: PPUSH
24755: CALL_OW 257
24759: PUSH
24760: LD_INT 2
24762: EQUAL
24763: IFFALSE 24767
// continue ;
24765: GO 24733
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24767: LD_ADDR_VAR 0 11
24771: PUSH
24772: LD_VAR 0 11
24776: PPUSH
24777: LD_VAR 0 11
24781: PUSH
24782: LD_INT 1
24784: PLUS
24785: PPUSH
24786: LD_VAR 0 9
24790: PUSH
24791: LD_VAR 0 3
24795: ARRAY
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 4
24811: PUSH
24812: LD_VAR 0 9
24816: PUSH
24817: LD_VAR 0 3
24821: ARRAY
24822: DIFF
24823: ST_TO_ADDR
// end ;
24824: GO 24733
24826: POP
24827: POP
// if p then
24828: LD_VAR 0 11
24832: IFFALSE 24857
// result := Replace ( result , 2 , p ) ;
24834: LD_ADDR_VAR 0 2
24838: PUSH
24839: LD_VAR 0 2
24843: PPUSH
24844: LD_INT 2
24846: PPUSH
24847: LD_VAR 0 11
24851: PPUSH
24852: CALL_OW 1
24856: ST_TO_ADDR
// end ; exit ;
24857: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24859: LD_EXP 77
24863: PUSH
24864: LD_EXP 76
24868: PUSH
24869: LD_VAR 0 1
24873: ARRAY
24874: ARRAY
24875: NOT
24876: PUSH
24877: LD_EXP 50
24881: PUSH
24882: LD_VAR 0 1
24886: ARRAY
24887: PPUSH
24888: LD_INT 30
24890: PUSH
24891: LD_INT 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PPUSH
24898: CALL_OW 72
24902: AND
24903: PUSH
24904: LD_EXP 55
24908: PUSH
24909: LD_VAR 0 1
24913: ARRAY
24914: AND
24915: IFFALSE 25523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24917: LD_ADDR_EXP 92
24921: PUSH
24922: LD_EXP 92
24926: PPUSH
24927: LD_VAR 0 1
24931: PPUSH
24932: LD_INT 5
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24940: LD_ADDR_VAR 0 2
24944: PUSH
24945: LD_INT 0
24947: PUSH
24948: LD_INT 0
24950: PUSH
24951: LD_INT 0
24953: PUSH
24954: LD_INT 0
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: ST_TO_ADDR
// if sci > 1 then
24963: LD_VAR 0 8
24967: PUSH
24968: LD_INT 1
24970: GREATER
24971: IFFALSE 24999
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24973: LD_ADDR_VAR 0 4
24977: PUSH
24978: LD_VAR 0 4
24982: PUSH
24983: LD_VAR 0 8
24987: PUSH
24988: LD_VAR 0 8
24992: PUSH
24993: LD_INT 1
24995: ARRAY
24996: DIFF
24997: DIFF
24998: ST_TO_ADDR
// if tmp and not sci then
24999: LD_VAR 0 4
25003: PUSH
25004: LD_VAR 0 8
25008: NOT
25009: AND
25010: IFFALSE 25079
// begin sort := SortBySkill ( tmp , 4 ) ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: LD_VAR 0 4
25021: PPUSH
25022: LD_INT 4
25024: PPUSH
25025: CALL 83651 0 2
25029: ST_TO_ADDR
// if sort then
25030: LD_VAR 0 9
25034: IFFALSE 25050
// p := sort [ 1 ] ;
25036: LD_ADDR_VAR 0 11
25040: PUSH
25041: LD_VAR 0 9
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: ST_TO_ADDR
// if p then
25050: LD_VAR 0 11
25054: IFFALSE 25079
// result := Replace ( result , 4 , p ) ;
25056: LD_ADDR_VAR 0 2
25060: PUSH
25061: LD_VAR 0 2
25065: PPUSH
25066: LD_INT 4
25068: PPUSH
25069: LD_VAR 0 11
25073: PPUSH
25074: CALL_OW 1
25078: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25079: LD_ADDR_VAR 0 4
25083: PUSH
25084: LD_VAR 0 4
25088: PUSH
25089: LD_VAR 0 7
25093: DIFF
25094: ST_TO_ADDR
// if tmp and mech < 6 then
25095: LD_VAR 0 4
25099: PUSH
25100: LD_VAR 0 7
25104: PUSH
25105: LD_INT 6
25107: LESS
25108: AND
25109: IFFALSE 25297
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25111: LD_ADDR_VAR 0 9
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_VAR 0 8
25125: PUSH
25126: LD_VAR 0 7
25130: UNION
25131: DIFF
25132: PPUSH
25133: LD_INT 3
25135: PPUSH
25136: CALL 83651 0 2
25140: ST_TO_ADDR
// p := [ ] ;
25141: LD_ADDR_VAR 0 11
25145: PUSH
25146: EMPTY
25147: ST_TO_ADDR
// if sort then
25148: LD_VAR 0 9
25152: IFFALSE 25268
// for i = 1 to 6 - mech do
25154: LD_ADDR_VAR 0 3
25158: PUSH
25159: DOUBLE
25160: LD_INT 1
25162: DEC
25163: ST_TO_ADDR
25164: LD_INT 6
25166: PUSH
25167: LD_VAR 0 7
25171: MINUS
25172: PUSH
25173: FOR_TO
25174: IFFALSE 25266
// begin if i = sort then
25176: LD_VAR 0 3
25180: PUSH
25181: LD_VAR 0 9
25185: EQUAL
25186: IFFALSE 25190
// break ;
25188: GO 25266
// if GetClass ( i ) = 3 then
25190: LD_VAR 0 3
25194: PPUSH
25195: CALL_OW 257
25199: PUSH
25200: LD_INT 3
25202: EQUAL
25203: IFFALSE 25207
// continue ;
25205: GO 25173
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25207: LD_ADDR_VAR 0 11
25211: PUSH
25212: LD_VAR 0 11
25216: PPUSH
25217: LD_VAR 0 11
25221: PUSH
25222: LD_INT 1
25224: PLUS
25225: PPUSH
25226: LD_VAR 0 9
25230: PUSH
25231: LD_VAR 0 3
25235: ARRAY
25236: PPUSH
25237: CALL_OW 2
25241: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25242: LD_ADDR_VAR 0 4
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 9
25256: PUSH
25257: LD_VAR 0 3
25261: ARRAY
25262: DIFF
25263: ST_TO_ADDR
// end ;
25264: GO 25173
25266: POP
25267: POP
// if p then
25268: LD_VAR 0 11
25272: IFFALSE 25297
// result := Replace ( result , 3 , p ) ;
25274: LD_ADDR_VAR 0 2
25278: PUSH
25279: LD_VAR 0 2
25283: PPUSH
25284: LD_INT 3
25286: PPUSH
25287: LD_VAR 0 11
25291: PPUSH
25292: CALL_OW 1
25296: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25297: LD_ADDR_VAR 0 4
25301: PUSH
25302: LD_VAR 0 4
25306: PUSH
25307: LD_VAR 0 6
25311: DIFF
25312: ST_TO_ADDR
// if tmp and eng < 6 then
25313: LD_VAR 0 4
25317: PUSH
25318: LD_VAR 0 6
25322: PUSH
25323: LD_INT 6
25325: LESS
25326: AND
25327: IFFALSE 25521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25329: LD_ADDR_VAR 0 9
25333: PUSH
25334: LD_VAR 0 4
25338: PUSH
25339: LD_VAR 0 8
25343: PUSH
25344: LD_VAR 0 7
25348: UNION
25349: PUSH
25350: LD_VAR 0 6
25354: UNION
25355: DIFF
25356: PPUSH
25357: LD_INT 2
25359: PPUSH
25360: CALL 83651 0 2
25364: ST_TO_ADDR
// p := [ ] ;
25365: LD_ADDR_VAR 0 11
25369: PUSH
25370: EMPTY
25371: ST_TO_ADDR
// if sort then
25372: LD_VAR 0 9
25376: IFFALSE 25492
// for i = 1 to 6 - eng do
25378: LD_ADDR_VAR 0 3
25382: PUSH
25383: DOUBLE
25384: LD_INT 1
25386: DEC
25387: ST_TO_ADDR
25388: LD_INT 6
25390: PUSH
25391: LD_VAR 0 6
25395: MINUS
25396: PUSH
25397: FOR_TO
25398: IFFALSE 25490
// begin if i = sort then
25400: LD_VAR 0 3
25404: PUSH
25405: LD_VAR 0 9
25409: EQUAL
25410: IFFALSE 25414
// break ;
25412: GO 25490
// if GetClass ( i ) = 2 then
25414: LD_VAR 0 3
25418: PPUSH
25419: CALL_OW 257
25423: PUSH
25424: LD_INT 2
25426: EQUAL
25427: IFFALSE 25431
// continue ;
25429: GO 25397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: LD_VAR 0 11
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: PLUS
25449: PPUSH
25450: LD_VAR 0 9
25454: PUSH
25455: LD_VAR 0 3
25459: ARRAY
25460: PPUSH
25461: CALL_OW 2
25465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25466: LD_ADDR_VAR 0 4
25470: PUSH
25471: LD_VAR 0 4
25475: PUSH
25476: LD_VAR 0 9
25480: PUSH
25481: LD_VAR 0 3
25485: ARRAY
25486: DIFF
25487: ST_TO_ADDR
// end ;
25488: GO 25397
25490: POP
25491: POP
// if p then
25492: LD_VAR 0 11
25496: IFFALSE 25521
// result := Replace ( result , 2 , p ) ;
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: LD_VAR 0 2
25507: PPUSH
25508: LD_INT 2
25510: PPUSH
25511: LD_VAR 0 11
25515: PPUSH
25516: CALL_OW 1
25520: ST_TO_ADDR
// end ; exit ;
25521: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25523: LD_EXP 77
25527: PUSH
25528: LD_EXP 76
25532: PUSH
25533: LD_VAR 0 1
25537: ARRAY
25538: ARRAY
25539: NOT
25540: PUSH
25541: LD_EXP 50
25545: PUSH
25546: LD_VAR 0 1
25550: ARRAY
25551: PPUSH
25552: LD_INT 30
25554: PUSH
25555: LD_INT 3
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PPUSH
25562: CALL_OW 72
25566: AND
25567: PUSH
25568: LD_EXP 55
25572: PUSH
25573: LD_VAR 0 1
25577: ARRAY
25578: NOT
25579: AND
25580: IFFALSE 26245
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25582: LD_ADDR_EXP 92
25586: PUSH
25587: LD_EXP 92
25591: PPUSH
25592: LD_VAR 0 1
25596: PPUSH
25597: LD_INT 6
25599: PPUSH
25600: CALL_OW 1
25604: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25605: LD_ADDR_VAR 0 2
25609: PUSH
25610: LD_INT 0
25612: PUSH
25613: LD_INT 0
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: ST_TO_ADDR
// if sci >= 1 then
25628: LD_VAR 0 8
25632: PUSH
25633: LD_INT 1
25635: GREATEREQUAL
25636: IFFALSE 25658
// tmp := tmp diff sci [ 1 ] ;
25638: LD_ADDR_VAR 0 4
25642: PUSH
25643: LD_VAR 0 4
25647: PUSH
25648: LD_VAR 0 8
25652: PUSH
25653: LD_INT 1
25655: ARRAY
25656: DIFF
25657: ST_TO_ADDR
// if tmp and not sci then
25658: LD_VAR 0 4
25662: PUSH
25663: LD_VAR 0 8
25667: NOT
25668: AND
25669: IFFALSE 25738
// begin sort := SortBySkill ( tmp , 4 ) ;
25671: LD_ADDR_VAR 0 9
25675: PUSH
25676: LD_VAR 0 4
25680: PPUSH
25681: LD_INT 4
25683: PPUSH
25684: CALL 83651 0 2
25688: ST_TO_ADDR
// if sort then
25689: LD_VAR 0 9
25693: IFFALSE 25709
// p := sort [ 1 ] ;
25695: LD_ADDR_VAR 0 11
25699: PUSH
25700: LD_VAR 0 9
25704: PUSH
25705: LD_INT 1
25707: ARRAY
25708: ST_TO_ADDR
// if p then
25709: LD_VAR 0 11
25713: IFFALSE 25738
// result := Replace ( result , 4 , p ) ;
25715: LD_ADDR_VAR 0 2
25719: PUSH
25720: LD_VAR 0 2
25724: PPUSH
25725: LD_INT 4
25727: PPUSH
25728: LD_VAR 0 11
25732: PPUSH
25733: CALL_OW 1
25737: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25738: LD_ADDR_VAR 0 4
25742: PUSH
25743: LD_VAR 0 4
25747: PUSH
25748: LD_VAR 0 7
25752: DIFF
25753: ST_TO_ADDR
// if tmp and mech < 6 then
25754: LD_VAR 0 4
25758: PUSH
25759: LD_VAR 0 7
25763: PUSH
25764: LD_INT 6
25766: LESS
25767: AND
25768: IFFALSE 25950
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25770: LD_ADDR_VAR 0 9
25774: PUSH
25775: LD_VAR 0 4
25779: PUSH
25780: LD_VAR 0 7
25784: DIFF
25785: PPUSH
25786: LD_INT 3
25788: PPUSH
25789: CALL 83651 0 2
25793: ST_TO_ADDR
// p := [ ] ;
25794: LD_ADDR_VAR 0 11
25798: PUSH
25799: EMPTY
25800: ST_TO_ADDR
// if sort then
25801: LD_VAR 0 9
25805: IFFALSE 25921
// for i = 1 to 6 - mech do
25807: LD_ADDR_VAR 0 3
25811: PUSH
25812: DOUBLE
25813: LD_INT 1
25815: DEC
25816: ST_TO_ADDR
25817: LD_INT 6
25819: PUSH
25820: LD_VAR 0 7
25824: MINUS
25825: PUSH
25826: FOR_TO
25827: IFFALSE 25919
// begin if i = sort then
25829: LD_VAR 0 3
25833: PUSH
25834: LD_VAR 0 9
25838: EQUAL
25839: IFFALSE 25843
// break ;
25841: GO 25919
// if GetClass ( i ) = 3 then
25843: LD_VAR 0 3
25847: PPUSH
25848: CALL_OW 257
25852: PUSH
25853: LD_INT 3
25855: EQUAL
25856: IFFALSE 25860
// continue ;
25858: GO 25826
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25860: LD_ADDR_VAR 0 11
25864: PUSH
25865: LD_VAR 0 11
25869: PPUSH
25870: LD_VAR 0 11
25874: PUSH
25875: LD_INT 1
25877: PLUS
25878: PPUSH
25879: LD_VAR 0 9
25883: PUSH
25884: LD_VAR 0 3
25888: ARRAY
25889: PPUSH
25890: CALL_OW 2
25894: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25895: LD_ADDR_VAR 0 4
25899: PUSH
25900: LD_VAR 0 4
25904: PUSH
25905: LD_VAR 0 9
25909: PUSH
25910: LD_VAR 0 3
25914: ARRAY
25915: DIFF
25916: ST_TO_ADDR
// end ;
25917: GO 25826
25919: POP
25920: POP
// if p then
25921: LD_VAR 0 11
25925: IFFALSE 25950
// result := Replace ( result , 3 , p ) ;
25927: LD_ADDR_VAR 0 2
25931: PUSH
25932: LD_VAR 0 2
25936: PPUSH
25937: LD_INT 3
25939: PPUSH
25940: LD_VAR 0 11
25944: PPUSH
25945: CALL_OW 1
25949: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25950: LD_ADDR_VAR 0 4
25954: PUSH
25955: LD_VAR 0 4
25959: PUSH
25960: LD_VAR 0 6
25964: DIFF
25965: ST_TO_ADDR
// if tmp and eng < 4 then
25966: LD_VAR 0 4
25970: PUSH
25971: LD_VAR 0 6
25975: PUSH
25976: LD_INT 4
25978: LESS
25979: AND
25980: IFFALSE 26170
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25982: LD_ADDR_VAR 0 9
25986: PUSH
25987: LD_VAR 0 4
25991: PUSH
25992: LD_VAR 0 7
25996: PUSH
25997: LD_VAR 0 6
26001: UNION
26002: DIFF
26003: PPUSH
26004: LD_INT 2
26006: PPUSH
26007: CALL 83651 0 2
26011: ST_TO_ADDR
// p := [ ] ;
26012: LD_ADDR_VAR 0 11
26016: PUSH
26017: EMPTY
26018: ST_TO_ADDR
// if sort then
26019: LD_VAR 0 9
26023: IFFALSE 26139
// for i = 1 to 4 - eng do
26025: LD_ADDR_VAR 0 3
26029: PUSH
26030: DOUBLE
26031: LD_INT 1
26033: DEC
26034: ST_TO_ADDR
26035: LD_INT 4
26037: PUSH
26038: LD_VAR 0 6
26042: MINUS
26043: PUSH
26044: FOR_TO
26045: IFFALSE 26137
// begin if i = sort then
26047: LD_VAR 0 3
26051: PUSH
26052: LD_VAR 0 9
26056: EQUAL
26057: IFFALSE 26061
// break ;
26059: GO 26137
// if GetClass ( i ) = 2 then
26061: LD_VAR 0 3
26065: PPUSH
26066: CALL_OW 257
26070: PUSH
26071: LD_INT 2
26073: EQUAL
26074: IFFALSE 26078
// continue ;
26076: GO 26044
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26078: LD_ADDR_VAR 0 11
26082: PUSH
26083: LD_VAR 0 11
26087: PPUSH
26088: LD_VAR 0 11
26092: PUSH
26093: LD_INT 1
26095: PLUS
26096: PPUSH
26097: LD_VAR 0 9
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: PPUSH
26108: CALL_OW 2
26112: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 9
26127: PUSH
26128: LD_VAR 0 3
26132: ARRAY
26133: DIFF
26134: ST_TO_ADDR
// end ;
26135: GO 26044
26137: POP
26138: POP
// if p then
26139: LD_VAR 0 11
26143: IFFALSE 26168
// result := Replace ( result , 2 , p ) ;
26145: LD_ADDR_VAR 0 2
26149: PUSH
26150: LD_VAR 0 2
26154: PPUSH
26155: LD_INT 2
26157: PPUSH
26158: LD_VAR 0 11
26162: PPUSH
26163: CALL_OW 1
26167: ST_TO_ADDR
// end else
26168: GO 26214
// for i = eng downto 5 do
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 6
26180: INC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_DOWNTO
26186: IFFALSE 26212
// tmp := tmp union eng [ i ] ;
26188: LD_ADDR_VAR 0 4
26192: PUSH
26193: LD_VAR 0 4
26197: PUSH
26198: LD_VAR 0 6
26202: PUSH
26203: LD_VAR 0 3
26207: ARRAY
26208: UNION
26209: ST_TO_ADDR
26210: GO 26185
26212: POP
26213: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26214: LD_ADDR_VAR 0 2
26218: PUSH
26219: LD_VAR 0 2
26223: PPUSH
26224: LD_INT 1
26226: PPUSH
26227: LD_VAR 0 4
26231: PUSH
26232: LD_VAR 0 5
26236: DIFF
26237: PPUSH
26238: CALL_OW 1
26242: ST_TO_ADDR
// exit ;
26243: GO 26245
// end ; end ;
26245: LD_VAR 0 2
26249: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26250: LD_INT 0
26252: PPUSH
26253: PPUSH
26254: PPUSH
// if not mc_bases then
26255: LD_EXP 50
26259: NOT
26260: IFFALSE 26264
// exit ;
26262: GO 26406
// for i = 1 to mc_bases do
26264: LD_ADDR_VAR 0 2
26268: PUSH
26269: DOUBLE
26270: LD_INT 1
26272: DEC
26273: ST_TO_ADDR
26274: LD_EXP 50
26278: PUSH
26279: FOR_TO
26280: IFFALSE 26397
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26282: LD_ADDR_VAR 0 3
26286: PUSH
26287: LD_EXP 50
26291: PUSH
26292: LD_VAR 0 2
26296: ARRAY
26297: PPUSH
26298: LD_INT 21
26300: PUSH
26301: LD_INT 3
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 3
26310: PUSH
26311: LD_INT 2
26313: PUSH
26314: LD_INT 30
26316: PUSH
26317: LD_INT 29
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: LD_INT 30
26326: PUSH
26327: LD_INT 30
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 3
26345: PUSH
26346: LD_INT 24
26348: PUSH
26349: LD_INT 1000
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL_OW 72
26369: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26370: LD_ADDR_EXP 51
26374: PUSH
26375: LD_EXP 51
26379: PPUSH
26380: LD_VAR 0 2
26384: PPUSH
26385: LD_VAR 0 3
26389: PPUSH
26390: CALL_OW 1
26394: ST_TO_ADDR
// end ;
26395: GO 26279
26397: POP
26398: POP
// RaiseSailEvent ( 101 ) ;
26399: LD_INT 101
26401: PPUSH
26402: CALL_OW 427
// end ;
26406: LD_VAR 0 1
26410: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26411: LD_INT 0
26413: PPUSH
26414: PPUSH
26415: PPUSH
26416: PPUSH
26417: PPUSH
26418: PPUSH
26419: PPUSH
// if not mc_bases then
26420: LD_EXP 50
26424: NOT
26425: IFFALSE 26429
// exit ;
26427: GO 26991
// for i = 1 to mc_bases do
26429: LD_ADDR_VAR 0 2
26433: PUSH
26434: DOUBLE
26435: LD_INT 1
26437: DEC
26438: ST_TO_ADDR
26439: LD_EXP 50
26443: PUSH
26444: FOR_TO
26445: IFFALSE 26982
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26447: LD_ADDR_VAR 0 5
26451: PUSH
26452: LD_EXP 50
26456: PUSH
26457: LD_VAR 0 2
26461: ARRAY
26462: PUSH
26463: LD_EXP 79
26467: PUSH
26468: LD_VAR 0 2
26472: ARRAY
26473: UNION
26474: PPUSH
26475: LD_INT 21
26477: PUSH
26478: LD_INT 1
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: LD_INT 3
26490: PUSH
26491: LD_INT 54
26493: PUSH
26494: EMPTY
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: LD_INT 3
26503: PUSH
26504: LD_INT 24
26506: PUSH
26507: LD_INT 1000
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: LIST
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 72
26531: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26532: LD_ADDR_VAR 0 6
26536: PUSH
26537: LD_EXP 50
26541: PUSH
26542: LD_VAR 0 2
26546: ARRAY
26547: PPUSH
26548: LD_INT 21
26550: PUSH
26551: LD_INT 1
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PUSH
26561: LD_INT 3
26563: PUSH
26564: LD_INT 54
26566: PUSH
26567: EMPTY
26568: LIST
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: LD_INT 24
26579: PUSH
26580: LD_INT 250
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PPUSH
26600: CALL_OW 72
26604: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26605: LD_ADDR_VAR 0 7
26609: PUSH
26610: LD_VAR 0 5
26614: PUSH
26615: LD_VAR 0 6
26619: DIFF
26620: ST_TO_ADDR
// if not need_heal_1 then
26621: LD_VAR 0 6
26625: NOT
26626: IFFALSE 26659
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26628: LD_ADDR_EXP 53
26632: PUSH
26633: LD_EXP 53
26637: PPUSH
26638: LD_VAR 0 2
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: EMPTY
26651: PPUSH
26652: CALL 53394 0 3
26656: ST_TO_ADDR
26657: GO 26729
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26659: LD_ADDR_EXP 53
26663: PUSH
26664: LD_EXP 53
26668: PPUSH
26669: LD_VAR 0 2
26673: PUSH
26674: LD_INT 1
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PPUSH
26681: LD_EXP 53
26685: PUSH
26686: LD_VAR 0 2
26690: ARRAY
26691: PUSH
26692: LD_INT 1
26694: ARRAY
26695: PPUSH
26696: LD_INT 3
26698: PUSH
26699: LD_INT 24
26701: PUSH
26702: LD_INT 1000
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PPUSH
26713: CALL_OW 72
26717: PUSH
26718: LD_VAR 0 6
26722: UNION
26723: PPUSH
26724: CALL 53394 0 3
26728: ST_TO_ADDR
// if not need_heal_2 then
26729: LD_VAR 0 7
26733: NOT
26734: IFFALSE 26767
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26736: LD_ADDR_EXP 53
26740: PUSH
26741: LD_EXP 53
26745: PPUSH
26746: LD_VAR 0 2
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PPUSH
26758: EMPTY
26759: PPUSH
26760: CALL 53394 0 3
26764: ST_TO_ADDR
26765: GO 26799
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26767: LD_ADDR_EXP 53
26771: PUSH
26772: LD_EXP 53
26776: PPUSH
26777: LD_VAR 0 2
26781: PUSH
26782: LD_INT 2
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PPUSH
26789: LD_VAR 0 7
26793: PPUSH
26794: CALL 53394 0 3
26798: ST_TO_ADDR
// if need_heal_2 then
26799: LD_VAR 0 7
26803: IFFALSE 26964
// for j in need_heal_2 do
26805: LD_ADDR_VAR 0 3
26809: PUSH
26810: LD_VAR 0 7
26814: PUSH
26815: FOR_IN
26816: IFFALSE 26962
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26818: LD_ADDR_VAR 0 5
26822: PUSH
26823: LD_EXP 50
26827: PUSH
26828: LD_VAR 0 2
26832: ARRAY
26833: PPUSH
26834: LD_INT 2
26836: PUSH
26837: LD_INT 30
26839: PUSH
26840: LD_INT 6
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 30
26849: PUSH
26850: LD_INT 7
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 30
26859: PUSH
26860: LD_INT 8
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 30
26869: PUSH
26870: LD_INT 0
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 30
26879: PUSH
26880: LD_INT 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: LIST
26891: LIST
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 72
26899: ST_TO_ADDR
// if tmp then
26900: LD_VAR 0 5
26904: IFFALSE 26960
// begin k := NearestUnitToUnit ( tmp , j ) ;
26906: LD_ADDR_VAR 0 4
26910: PUSH
26911: LD_VAR 0 5
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: CALL_OW 74
26925: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26926: LD_VAR 0 3
26930: PPUSH
26931: LD_VAR 0 4
26935: PPUSH
26936: CALL_OW 296
26940: PUSH
26941: LD_INT 5
26943: GREATER
26944: IFFALSE 26960
// ComMoveToNearbyEntrance ( j , k ) ;
26946: LD_VAR 0 3
26950: PPUSH
26951: LD_VAR 0 4
26955: PPUSH
26956: CALL 86012 0 2
// end ; end ;
26960: GO 26815
26962: POP
26963: POP
// if not need_heal_1 and not need_heal_2 then
26964: LD_VAR 0 6
26968: NOT
26969: PUSH
26970: LD_VAR 0 7
26974: NOT
26975: AND
26976: IFFALSE 26980
// continue ;
26978: GO 26444
// end ;
26980: GO 26444
26982: POP
26983: POP
// RaiseSailEvent ( 102 ) ;
26984: LD_INT 102
26986: PPUSH
26987: CALL_OW 427
// end ;
26991: LD_VAR 0 1
26995: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26996: LD_INT 0
26998: PPUSH
26999: PPUSH
27000: PPUSH
27001: PPUSH
27002: PPUSH
27003: PPUSH
27004: PPUSH
27005: PPUSH
// if not mc_bases then
27006: LD_EXP 50
27010: NOT
27011: IFFALSE 27015
// exit ;
27013: GO 27898
// for i = 1 to mc_bases do
27015: LD_ADDR_VAR 0 2
27019: PUSH
27020: DOUBLE
27021: LD_INT 1
27023: DEC
27024: ST_TO_ADDR
27025: LD_EXP 50
27029: PUSH
27030: FOR_TO
27031: IFFALSE 27896
// begin if not mc_building_need_repair [ i ] then
27033: LD_EXP 51
27037: PUSH
27038: LD_VAR 0 2
27042: ARRAY
27043: NOT
27044: IFFALSE 27231
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27046: LD_ADDR_VAR 0 6
27050: PUSH
27051: LD_EXP 69
27055: PUSH
27056: LD_VAR 0 2
27060: ARRAY
27061: PPUSH
27062: LD_INT 3
27064: PUSH
27065: LD_INT 24
27067: PUSH
27068: LD_INT 1000
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 2
27081: PUSH
27082: LD_INT 34
27084: PUSH
27085: LD_INT 13
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 34
27094: PUSH
27095: LD_INT 52
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 34
27104: PUSH
27105: LD_EXP 100
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: LIST
27118: LIST
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PPUSH
27124: CALL_OW 72
27128: ST_TO_ADDR
// if cranes then
27129: LD_VAR 0 6
27133: IFFALSE 27195
// for j in cranes do
27135: LD_ADDR_VAR 0 3
27139: PUSH
27140: LD_VAR 0 6
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27193
// if not IsInArea ( j , mc_parking [ i ] ) then
27148: LD_VAR 0 3
27152: PPUSH
27153: LD_EXP 74
27157: PUSH
27158: LD_VAR 0 2
27162: ARRAY
27163: PPUSH
27164: CALL_OW 308
27168: NOT
27169: IFFALSE 27191
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27171: LD_VAR 0 3
27175: PPUSH
27176: LD_EXP 74
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 113
27191: GO 27145
27193: POP
27194: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27195: LD_ADDR_EXP 52
27199: PUSH
27200: LD_EXP 52
27204: PPUSH
27205: LD_VAR 0 2
27209: PPUSH
27210: EMPTY
27211: PPUSH
27212: CALL_OW 1
27216: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27217: LD_VAR 0 2
27221: PPUSH
27222: LD_INT 101
27224: PPUSH
27225: CALL 22083 0 2
// continue ;
27229: GO 27030
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27231: LD_ADDR_EXP 56
27235: PUSH
27236: LD_EXP 56
27240: PPUSH
27241: LD_VAR 0 2
27245: PPUSH
27246: EMPTY
27247: PPUSH
27248: CALL_OW 1
27252: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27253: LD_VAR 0 2
27257: PPUSH
27258: LD_INT 103
27260: PPUSH
27261: CALL 22083 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27265: LD_ADDR_VAR 0 5
27269: PUSH
27270: LD_EXP 50
27274: PUSH
27275: LD_VAR 0 2
27279: ARRAY
27280: PUSH
27281: LD_EXP 79
27285: PUSH
27286: LD_VAR 0 2
27290: ARRAY
27291: UNION
27292: PPUSH
27293: LD_INT 2
27295: PUSH
27296: LD_INT 25
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 25
27308: PUSH
27309: LD_INT 16
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: LIST
27320: PUSH
27321: EMPTY
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: ST_TO_ADDR
// if mc_need_heal [ i ] then
27329: LD_EXP 53
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: IFFALSE 27383
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27341: LD_ADDR_VAR 0 5
27345: PUSH
27346: LD_VAR 0 5
27350: PUSH
27351: LD_EXP 53
27355: PUSH
27356: LD_VAR 0 2
27360: ARRAY
27361: PUSH
27362: LD_INT 1
27364: ARRAY
27365: PUSH
27366: LD_EXP 53
27370: PUSH
27371: LD_VAR 0 2
27375: ARRAY
27376: PUSH
27377: LD_INT 2
27379: ARRAY
27380: UNION
27381: DIFF
27382: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27383: LD_ADDR_VAR 0 6
27387: PUSH
27388: LD_EXP 69
27392: PUSH
27393: LD_VAR 0 2
27397: ARRAY
27398: PPUSH
27399: LD_INT 2
27401: PUSH
27402: LD_INT 34
27404: PUSH
27405: LD_INT 13
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 34
27414: PUSH
27415: LD_INT 52
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 34
27424: PUSH
27425: LD_EXP 100
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: PPUSH
27440: CALL_OW 72
27444: ST_TO_ADDR
// if cranes then
27445: LD_VAR 0 6
27449: IFFALSE 27585
// begin for j in cranes do
27451: LD_ADDR_VAR 0 3
27455: PUSH
27456: LD_VAR 0 6
27460: PUSH
27461: FOR_IN
27462: IFFALSE 27583
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27464: LD_VAR 0 3
27468: PPUSH
27469: CALL_OW 256
27473: PUSH
27474: LD_INT 1000
27476: EQUAL
27477: PUSH
27478: LD_VAR 0 3
27482: PPUSH
27483: CALL_OW 314
27487: NOT
27488: AND
27489: IFFALSE 27523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27491: LD_VAR 0 3
27495: PPUSH
27496: LD_EXP 51
27500: PUSH
27501: LD_VAR 0 2
27505: ARRAY
27506: PPUSH
27507: LD_VAR 0 3
27511: PPUSH
27512: CALL_OW 74
27516: PPUSH
27517: CALL_OW 130
27521: GO 27581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 256
27532: PUSH
27533: LD_INT 500
27535: LESS
27536: PUSH
27537: LD_VAR 0 3
27541: PPUSH
27542: LD_EXP 74
27546: PUSH
27547: LD_VAR 0 2
27551: ARRAY
27552: PPUSH
27553: CALL_OW 308
27557: NOT
27558: AND
27559: IFFALSE 27581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27561: LD_VAR 0 3
27565: PPUSH
27566: LD_EXP 74
27570: PUSH
27571: LD_VAR 0 2
27575: ARRAY
27576: PPUSH
27577: CALL_OW 113
// end ;
27581: GO 27461
27583: POP
27584: POP
// end ; if tmp > 3 then
27585: LD_VAR 0 5
27589: PUSH
27590: LD_INT 3
27592: GREATER
27593: IFFALSE 27613
// tmp := ShrinkArray ( tmp , 4 ) ;
27595: LD_ADDR_VAR 0 5
27599: PUSH
27600: LD_VAR 0 5
27604: PPUSH
27605: LD_INT 4
27607: PPUSH
27608: CALL 85460 0 2
27612: ST_TO_ADDR
// if not tmp then
27613: LD_VAR 0 5
27617: NOT
27618: IFFALSE 27622
// continue ;
27620: GO 27030
// for j in tmp do
27622: LD_ADDR_VAR 0 3
27626: PUSH
27627: LD_VAR 0 5
27631: PUSH
27632: FOR_IN
27633: IFFALSE 27892
// begin if IsInUnit ( j ) then
27635: LD_VAR 0 3
27639: PPUSH
27640: CALL_OW 310
27644: IFFALSE 27655
// ComExitBuilding ( j ) ;
27646: LD_VAR 0 3
27650: PPUSH
27651: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27655: LD_VAR 0 3
27659: PUSH
27660: LD_EXP 52
27664: PUSH
27665: LD_VAR 0 2
27669: ARRAY
27670: IN
27671: NOT
27672: IFFALSE 27730
// begin SetTag ( j , 101 ) ;
27674: LD_VAR 0 3
27678: PPUSH
27679: LD_INT 101
27681: PPUSH
27682: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27686: LD_ADDR_EXP 52
27690: PUSH
27691: LD_EXP 52
27695: PPUSH
27696: LD_VAR 0 2
27700: PUSH
27701: LD_EXP 52
27705: PUSH
27706: LD_VAR 0 2
27710: ARRAY
27711: PUSH
27712: LD_INT 1
27714: PLUS
27715: PUSH
27716: EMPTY
27717: LIST
27718: LIST
27719: PPUSH
27720: LD_VAR 0 3
27724: PPUSH
27725: CALL 53394 0 3
27729: ST_TO_ADDR
// end ; wait ( 1 ) ;
27730: LD_INT 1
27732: PPUSH
27733: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27737: LD_ADDR_VAR 0 7
27741: PUSH
27742: LD_EXP 51
27746: PUSH
27747: LD_VAR 0 2
27751: ARRAY
27752: ST_TO_ADDR
// if mc_scan [ i ] then
27753: LD_EXP 73
27757: PUSH
27758: LD_VAR 0 2
27762: ARRAY
27763: IFFALSE 27825
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27765: LD_ADDR_VAR 0 7
27769: PUSH
27770: LD_EXP 51
27774: PUSH
27775: LD_VAR 0 2
27779: ARRAY
27780: PPUSH
27781: LD_INT 3
27783: PUSH
27784: LD_INT 30
27786: PUSH
27787: LD_INT 32
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 30
27796: PUSH
27797: LD_INT 33
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 30
27806: PUSH
27807: LD_INT 31
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: PPUSH
27820: CALL_OW 72
27824: ST_TO_ADDR
// if not to_repair_tmp then
27825: LD_VAR 0 7
27829: NOT
27830: IFFALSE 27834
// continue ;
27832: GO 27632
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27834: LD_ADDR_VAR 0 8
27838: PUSH
27839: LD_VAR 0 7
27843: PPUSH
27844: LD_VAR 0 3
27848: PPUSH
27849: CALL_OW 74
27853: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27854: LD_VAR 0 8
27858: PPUSH
27859: LD_INT 16
27861: PPUSH
27862: CALL 55993 0 2
27866: PUSH
27867: LD_INT 4
27869: ARRAY
27870: PUSH
27871: LD_INT 10
27873: LESS
27874: IFFALSE 27890
// ComRepairBuilding ( j , to_repair ) ;
27876: LD_VAR 0 3
27880: PPUSH
27881: LD_VAR 0 8
27885: PPUSH
27886: CALL_OW 130
// end ;
27890: GO 27632
27892: POP
27893: POP
// end ;
27894: GO 27030
27896: POP
27897: POP
// end ;
27898: LD_VAR 0 1
27902: RET
// export function MC_Heal ; var i , j , tmp ; begin
27903: LD_INT 0
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
// if not mc_bases then
27909: LD_EXP 50
27913: NOT
27914: IFFALSE 27918
// exit ;
27916: GO 28320
// for i = 1 to mc_bases do
27918: LD_ADDR_VAR 0 2
27922: PUSH
27923: DOUBLE
27924: LD_INT 1
27926: DEC
27927: ST_TO_ADDR
27928: LD_EXP 50
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28318
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27936: LD_EXP 53
27940: PUSH
27941: LD_VAR 0 2
27945: ARRAY
27946: PUSH
27947: LD_INT 1
27949: ARRAY
27950: NOT
27951: PUSH
27952: LD_EXP 53
27956: PUSH
27957: LD_VAR 0 2
27961: ARRAY
27962: PUSH
27963: LD_INT 2
27965: ARRAY
27966: NOT
27967: AND
27968: IFFALSE 28006
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27970: LD_ADDR_EXP 54
27974: PUSH
27975: LD_EXP 54
27979: PPUSH
27980: LD_VAR 0 2
27984: PPUSH
27985: EMPTY
27986: PPUSH
27987: CALL_OW 1
27991: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27992: LD_VAR 0 2
27996: PPUSH
27997: LD_INT 102
27999: PPUSH
28000: CALL 22083 0 2
// continue ;
28004: GO 27933
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28006: LD_ADDR_VAR 0 4
28010: PUSH
28011: LD_EXP 50
28015: PUSH
28016: LD_VAR 0 2
28020: ARRAY
28021: PPUSH
28022: LD_INT 25
28024: PUSH
28025: LD_INT 4
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PPUSH
28032: CALL_OW 72
28036: ST_TO_ADDR
// if not tmp then
28037: LD_VAR 0 4
28041: NOT
28042: IFFALSE 28046
// continue ;
28044: GO 27933
// if mc_taming [ i ] then
28046: LD_EXP 81
28050: PUSH
28051: LD_VAR 0 2
28055: ARRAY
28056: IFFALSE 28080
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28058: LD_ADDR_EXP 81
28062: PUSH
28063: LD_EXP 81
28067: PPUSH
28068: LD_VAR 0 2
28072: PPUSH
28073: EMPTY
28074: PPUSH
28075: CALL_OW 1
28079: ST_TO_ADDR
// for j in tmp do
28080: LD_ADDR_VAR 0 3
28084: PUSH
28085: LD_VAR 0 4
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28314
// begin if IsInUnit ( j ) then
28093: LD_VAR 0 3
28097: PPUSH
28098: CALL_OW 310
28102: IFFALSE 28113
// ComExitBuilding ( j ) ;
28104: LD_VAR 0 3
28108: PPUSH
28109: CALL_OW 122
// if not j in mc_healers [ i ] then
28113: LD_VAR 0 3
28117: PUSH
28118: LD_EXP 54
28122: PUSH
28123: LD_VAR 0 2
28127: ARRAY
28128: IN
28129: NOT
28130: IFFALSE 28176
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28132: LD_ADDR_EXP 54
28136: PUSH
28137: LD_EXP 54
28141: PPUSH
28142: LD_VAR 0 2
28146: PUSH
28147: LD_EXP 54
28151: PUSH
28152: LD_VAR 0 2
28156: ARRAY
28157: PUSH
28158: LD_INT 1
28160: PLUS
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PPUSH
28166: LD_VAR 0 3
28170: PPUSH
28171: CALL 53394 0 3
28175: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28176: LD_VAR 0 3
28180: PPUSH
28181: CALL_OW 110
28185: PUSH
28186: LD_INT 102
28188: NONEQUAL
28189: IFFALSE 28203
// SetTag ( j , 102 ) ;
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_INT 102
28198: PPUSH
28199: CALL_OW 109
// Wait ( 3 ) ;
28203: LD_INT 3
28205: PPUSH
28206: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28210: LD_EXP 53
28214: PUSH
28215: LD_VAR 0 2
28219: ARRAY
28220: PUSH
28221: LD_INT 1
28223: ARRAY
28224: IFFALSE 28256
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28226: LD_VAR 0 3
28230: PPUSH
28231: LD_EXP 53
28235: PUSH
28236: LD_VAR 0 2
28240: ARRAY
28241: PUSH
28242: LD_INT 1
28244: ARRAY
28245: PUSH
28246: LD_INT 1
28248: ARRAY
28249: PPUSH
28250: CALL_OW 128
28254: GO 28312
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28256: LD_VAR 0 3
28260: PPUSH
28261: CALL_OW 314
28265: NOT
28266: PUSH
28267: LD_EXP 53
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: PUSH
28278: LD_INT 2
28280: ARRAY
28281: AND
28282: IFFALSE 28312
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28284: LD_VAR 0 3
28288: PPUSH
28289: LD_EXP 53
28293: PUSH
28294: LD_VAR 0 2
28298: ARRAY
28299: PUSH
28300: LD_INT 2
28302: ARRAY
28303: PUSH
28304: LD_INT 1
28306: ARRAY
28307: PPUSH
28308: CALL_OW 128
// end ;
28312: GO 28090
28314: POP
28315: POP
// end ;
28316: GO 27933
28318: POP
28319: POP
// end ;
28320: LD_VAR 0 1
28324: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28325: LD_INT 0
28327: PPUSH
28328: PPUSH
28329: PPUSH
28330: PPUSH
28331: PPUSH
// if not mc_bases then
28332: LD_EXP 50
28336: NOT
28337: IFFALSE 28341
// exit ;
28339: GO 29512
// for i = 1 to mc_bases do
28341: LD_ADDR_VAR 0 2
28345: PUSH
28346: DOUBLE
28347: LD_INT 1
28349: DEC
28350: ST_TO_ADDR
28351: LD_EXP 50
28355: PUSH
28356: FOR_TO
28357: IFFALSE 29510
// begin if mc_scan [ i ] then
28359: LD_EXP 73
28363: PUSH
28364: LD_VAR 0 2
28368: ARRAY
28369: IFFALSE 28373
// continue ;
28371: GO 28356
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28373: LD_EXP 55
28377: PUSH
28378: LD_VAR 0 2
28382: ARRAY
28383: NOT
28384: PUSH
28385: LD_EXP 57
28389: PUSH
28390: LD_VAR 0 2
28394: ARRAY
28395: NOT
28396: AND
28397: PUSH
28398: LD_EXP 56
28402: PUSH
28403: LD_VAR 0 2
28407: ARRAY
28408: AND
28409: IFFALSE 28447
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28411: LD_ADDR_EXP 56
28415: PUSH
28416: LD_EXP 56
28420: PPUSH
28421: LD_VAR 0 2
28425: PPUSH
28426: EMPTY
28427: PPUSH
28428: CALL_OW 1
28432: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28433: LD_VAR 0 2
28437: PPUSH
28438: LD_INT 103
28440: PPUSH
28441: CALL 22083 0 2
// continue ;
28445: GO 28356
// end ; if mc_construct_list [ i ] then
28447: LD_EXP 57
28451: PUSH
28452: LD_VAR 0 2
28456: ARRAY
28457: IFFALSE 28677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28459: LD_ADDR_VAR 0 4
28463: PUSH
28464: LD_EXP 50
28468: PUSH
28469: LD_VAR 0 2
28473: ARRAY
28474: PPUSH
28475: LD_INT 25
28477: PUSH
28478: LD_INT 2
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PPUSH
28485: CALL_OW 72
28489: PUSH
28490: LD_EXP 52
28494: PUSH
28495: LD_VAR 0 2
28499: ARRAY
28500: DIFF
28501: ST_TO_ADDR
// if not tmp then
28502: LD_VAR 0 4
28506: NOT
28507: IFFALSE 28511
// continue ;
28509: GO 28356
// for j in tmp do
28511: LD_ADDR_VAR 0 3
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: FOR_IN
28522: IFFALSE 28673
// begin if not mc_builders [ i ] then
28524: LD_EXP 56
28528: PUSH
28529: LD_VAR 0 2
28533: ARRAY
28534: NOT
28535: IFFALSE 28593
// begin SetTag ( j , 103 ) ;
28537: LD_VAR 0 3
28541: PPUSH
28542: LD_INT 103
28544: PPUSH
28545: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28549: LD_ADDR_EXP 56
28553: PUSH
28554: LD_EXP 56
28558: PPUSH
28559: LD_VAR 0 2
28563: PUSH
28564: LD_EXP 56
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: PUSH
28575: LD_INT 1
28577: PLUS
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: LD_VAR 0 3
28587: PPUSH
28588: CALL 53394 0 3
28592: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28593: LD_VAR 0 3
28597: PPUSH
28598: CALL_OW 310
28602: IFFALSE 28613
// ComExitBuilding ( j ) ;
28604: LD_VAR 0 3
28608: PPUSH
28609: CALL_OW 122
// wait ( 3 ) ;
28613: LD_INT 3
28615: PPUSH
28616: CALL_OW 67
// if not mc_construct_list [ i ] then
28620: LD_EXP 57
28624: PUSH
28625: LD_VAR 0 2
28629: ARRAY
28630: NOT
28631: IFFALSE 28635
// break ;
28633: GO 28673
// if not HasTask ( j ) then
28635: LD_VAR 0 3
28639: PPUSH
28640: CALL_OW 314
28644: NOT
28645: IFFALSE 28671
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28647: LD_VAR 0 3
28651: PPUSH
28652: LD_EXP 57
28656: PUSH
28657: LD_VAR 0 2
28661: ARRAY
28662: PUSH
28663: LD_INT 1
28665: ARRAY
28666: PPUSH
28667: CALL 56257 0 2
// end ;
28671: GO 28521
28673: POP
28674: POP
// end else
28675: GO 29508
// if mc_build_list [ i ] then
28677: LD_EXP 55
28681: PUSH
28682: LD_VAR 0 2
28686: ARRAY
28687: IFFALSE 29508
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28689: LD_ADDR_VAR 0 5
28693: PUSH
28694: LD_EXP 50
28698: PUSH
28699: LD_VAR 0 2
28703: ARRAY
28704: PPUSH
28705: LD_INT 2
28707: PUSH
28708: LD_INT 30
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 30
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: LIST
28732: PPUSH
28733: CALL_OW 72
28737: ST_TO_ADDR
// if depot then
28738: LD_VAR 0 5
28742: IFFALSE 28760
// depot := depot [ 1 ] else
28744: LD_ADDR_VAR 0 5
28748: PUSH
28749: LD_VAR 0 5
28753: PUSH
28754: LD_INT 1
28756: ARRAY
28757: ST_TO_ADDR
28758: GO 28768
// depot := 0 ;
28760: LD_ADDR_VAR 0 5
28764: PUSH
28765: LD_INT 0
28767: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28768: LD_EXP 55
28772: PUSH
28773: LD_VAR 0 2
28777: ARRAY
28778: PUSH
28779: LD_INT 1
28781: ARRAY
28782: PUSH
28783: LD_INT 1
28785: ARRAY
28786: PPUSH
28787: CALL 56081 0 1
28791: PUSH
28792: LD_EXP 50
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PPUSH
28803: LD_INT 2
28805: PUSH
28806: LD_INT 30
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 30
28818: PUSH
28819: LD_INT 3
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: LIST
28830: PPUSH
28831: CALL_OW 72
28835: NOT
28836: AND
28837: IFFALSE 28942
// begin for j = 1 to mc_build_list [ i ] do
28839: LD_ADDR_VAR 0 3
28843: PUSH
28844: DOUBLE
28845: LD_INT 1
28847: DEC
28848: ST_TO_ADDR
28849: LD_EXP 55
28853: PUSH
28854: LD_VAR 0 2
28858: ARRAY
28859: PUSH
28860: FOR_TO
28861: IFFALSE 28940
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28863: LD_EXP 55
28867: PUSH
28868: LD_VAR 0 2
28872: ARRAY
28873: PUSH
28874: LD_VAR 0 3
28878: ARRAY
28879: PUSH
28880: LD_INT 1
28882: ARRAY
28883: PUSH
28884: LD_INT 2
28886: EQUAL
28887: IFFALSE 28938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28889: LD_ADDR_EXP 55
28893: PUSH
28894: LD_EXP 55
28898: PPUSH
28899: LD_VAR 0 2
28903: PPUSH
28904: LD_EXP 55
28908: PUSH
28909: LD_VAR 0 2
28913: ARRAY
28914: PPUSH
28915: LD_VAR 0 3
28919: PPUSH
28920: LD_INT 1
28922: PPUSH
28923: LD_INT 0
28925: PPUSH
28926: CALL 52812 0 4
28930: PPUSH
28931: CALL_OW 1
28935: ST_TO_ADDR
// break ;
28936: GO 28940
// end ;
28938: GO 28860
28940: POP
28941: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28942: LD_EXP 55
28946: PUSH
28947: LD_VAR 0 2
28951: ARRAY
28952: PUSH
28953: LD_INT 1
28955: ARRAY
28956: PUSH
28957: LD_INT 1
28959: ARRAY
28960: PUSH
28961: LD_INT 0
28963: EQUAL
28964: PUSH
28965: LD_VAR 0 5
28969: PUSH
28970: LD_VAR 0 5
28974: PPUSH
28975: LD_EXP 55
28979: PUSH
28980: LD_VAR 0 2
28984: ARRAY
28985: PUSH
28986: LD_INT 1
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: PPUSH
28994: LD_EXP 55
28998: PUSH
28999: LD_VAR 0 2
29003: ARRAY
29004: PUSH
29005: LD_INT 1
29007: ARRAY
29008: PUSH
29009: LD_INT 2
29011: ARRAY
29012: PPUSH
29013: LD_EXP 55
29017: PUSH
29018: LD_VAR 0 2
29022: ARRAY
29023: PUSH
29024: LD_INT 1
29026: ARRAY
29027: PUSH
29028: LD_INT 3
29030: ARRAY
29031: PPUSH
29032: LD_EXP 55
29036: PUSH
29037: LD_VAR 0 2
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PUSH
29047: LD_INT 4
29049: ARRAY
29050: PPUSH
29051: CALL 61497 0 5
29055: AND
29056: OR
29057: IFFALSE 29338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29059: LD_ADDR_VAR 0 4
29063: PUSH
29064: LD_EXP 50
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: PPUSH
29075: LD_INT 25
29077: PUSH
29078: LD_INT 2
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PPUSH
29085: CALL_OW 72
29089: PUSH
29090: LD_EXP 52
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: DIFF
29101: ST_TO_ADDR
// if not tmp then
29102: LD_VAR 0 4
29106: NOT
29107: IFFALSE 29111
// continue ;
29109: GO 28356
// for j in tmp do
29111: LD_ADDR_VAR 0 3
29115: PUSH
29116: LD_VAR 0 4
29120: PUSH
29121: FOR_IN
29122: IFFALSE 29334
// begin if not mc_builders [ i ] then
29124: LD_EXP 56
29128: PUSH
29129: LD_VAR 0 2
29133: ARRAY
29134: NOT
29135: IFFALSE 29193
// begin SetTag ( j , 103 ) ;
29137: LD_VAR 0 3
29141: PPUSH
29142: LD_INT 103
29144: PPUSH
29145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29149: LD_ADDR_EXP 56
29153: PUSH
29154: LD_EXP 56
29158: PPUSH
29159: LD_VAR 0 2
29163: PUSH
29164: LD_EXP 56
29168: PUSH
29169: LD_VAR 0 2
29173: ARRAY
29174: PUSH
29175: LD_INT 1
29177: PLUS
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PPUSH
29183: LD_VAR 0 3
29187: PPUSH
29188: CALL 53394 0 3
29192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29193: LD_VAR 0 3
29197: PPUSH
29198: CALL_OW 310
29202: IFFALSE 29213
// ComExitBuilding ( j ) ;
29204: LD_VAR 0 3
29208: PPUSH
29209: CALL_OW 122
// wait ( 3 ) ;
29213: LD_INT 3
29215: PPUSH
29216: CALL_OW 67
// if not mc_build_list [ i ] then
29220: LD_EXP 55
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: NOT
29231: IFFALSE 29235
// break ;
29233: GO 29334
// if not HasTask ( j ) then
29235: LD_VAR 0 3
29239: PPUSH
29240: CALL_OW 314
29244: NOT
29245: IFFALSE 29332
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29247: LD_VAR 0 3
29251: PPUSH
29252: LD_EXP 55
29256: PUSH
29257: LD_VAR 0 2
29261: ARRAY
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PUSH
29267: LD_INT 1
29269: ARRAY
29270: PPUSH
29271: LD_EXP 55
29275: PUSH
29276: LD_VAR 0 2
29280: ARRAY
29281: PUSH
29282: LD_INT 1
29284: ARRAY
29285: PUSH
29286: LD_INT 2
29288: ARRAY
29289: PPUSH
29290: LD_EXP 55
29294: PUSH
29295: LD_VAR 0 2
29299: ARRAY
29300: PUSH
29301: LD_INT 1
29303: ARRAY
29304: PUSH
29305: LD_INT 3
29307: ARRAY
29308: PPUSH
29309: LD_EXP 55
29313: PUSH
29314: LD_VAR 0 2
29318: ARRAY
29319: PUSH
29320: LD_INT 1
29322: ARRAY
29323: PUSH
29324: LD_INT 4
29326: ARRAY
29327: PPUSH
29328: CALL_OW 145
// end ;
29332: GO 29121
29334: POP
29335: POP
// end else
29336: GO 29508
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29338: LD_EXP 50
29342: PUSH
29343: LD_VAR 0 2
29347: ARRAY
29348: PPUSH
29349: LD_EXP 55
29353: PUSH
29354: LD_VAR 0 2
29358: ARRAY
29359: PUSH
29360: LD_INT 1
29362: ARRAY
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: PPUSH
29368: LD_EXP 55
29372: PUSH
29373: LD_VAR 0 2
29377: ARRAY
29378: PUSH
29379: LD_INT 1
29381: ARRAY
29382: PUSH
29383: LD_INT 2
29385: ARRAY
29386: PPUSH
29387: LD_EXP 55
29391: PUSH
29392: LD_VAR 0 2
29396: ARRAY
29397: PUSH
29398: LD_INT 1
29400: ARRAY
29401: PUSH
29402: LD_INT 3
29404: ARRAY
29405: PPUSH
29406: LD_EXP 55
29410: PUSH
29411: LD_VAR 0 2
29415: ARRAY
29416: PUSH
29417: LD_INT 1
29419: ARRAY
29420: PUSH
29421: LD_INT 4
29423: ARRAY
29424: PPUSH
29425: LD_EXP 50
29429: PUSH
29430: LD_VAR 0 2
29434: ARRAY
29435: PPUSH
29436: LD_INT 21
29438: PUSH
29439: LD_INT 3
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PPUSH
29446: CALL_OW 72
29450: PPUSH
29451: EMPTY
29452: PPUSH
29453: CALL 60247 0 7
29457: NOT
29458: IFFALSE 29508
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29460: LD_ADDR_EXP 55
29464: PUSH
29465: LD_EXP 55
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: LD_EXP 55
29479: PUSH
29480: LD_VAR 0 2
29484: ARRAY
29485: PPUSH
29486: LD_INT 1
29488: PPUSH
29489: LD_INT 1
29491: NEG
29492: PPUSH
29493: LD_INT 0
29495: PPUSH
29496: CALL 52812 0 4
29500: PPUSH
29501: CALL_OW 1
29505: ST_TO_ADDR
// continue ;
29506: GO 28356
// end ; end ; end ;
29508: GO 28356
29510: POP
29511: POP
// end ;
29512: LD_VAR 0 1
29516: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29517: LD_INT 0
29519: PPUSH
29520: PPUSH
29521: PPUSH
29522: PPUSH
29523: PPUSH
29524: PPUSH
// if not mc_bases then
29525: LD_EXP 50
29529: NOT
29530: IFFALSE 29534
// exit ;
29532: GO 29961
// for i = 1 to mc_bases do
29534: LD_ADDR_VAR 0 2
29538: PUSH
29539: DOUBLE
29540: LD_INT 1
29542: DEC
29543: ST_TO_ADDR
29544: LD_EXP 50
29548: PUSH
29549: FOR_TO
29550: IFFALSE 29959
// begin tmp := mc_build_upgrade [ i ] ;
29552: LD_ADDR_VAR 0 4
29556: PUSH
29557: LD_EXP 82
29561: PUSH
29562: LD_VAR 0 2
29566: ARRAY
29567: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29568: LD_ADDR_VAR 0 6
29572: PUSH
29573: LD_EXP 83
29577: PUSH
29578: LD_VAR 0 2
29582: ARRAY
29583: PPUSH
29584: LD_INT 2
29586: PUSH
29587: LD_INT 30
29589: PUSH
29590: LD_INT 6
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 30
29599: PUSH
29600: LD_INT 7
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL_OW 72
29616: ST_TO_ADDR
// if not tmp and not lab then
29617: LD_VAR 0 4
29621: NOT
29622: PUSH
29623: LD_VAR 0 6
29627: NOT
29628: AND
29629: IFFALSE 29633
// continue ;
29631: GO 29549
// if tmp then
29633: LD_VAR 0 4
29637: IFFALSE 29757
// for j in tmp do
29639: LD_ADDR_VAR 0 3
29643: PUSH
29644: LD_VAR 0 4
29648: PUSH
29649: FOR_IN
29650: IFFALSE 29755
// begin if UpgradeCost ( j ) then
29652: LD_VAR 0 3
29656: PPUSH
29657: CALL 59907 0 1
29661: IFFALSE 29753
// begin ComUpgrade ( j ) ;
29663: LD_VAR 0 3
29667: PPUSH
29668: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29672: LD_ADDR_EXP 82
29676: PUSH
29677: LD_EXP 82
29681: PPUSH
29682: LD_VAR 0 2
29686: PPUSH
29687: LD_EXP 82
29691: PUSH
29692: LD_VAR 0 2
29696: ARRAY
29697: PUSH
29698: LD_VAR 0 3
29702: DIFF
29703: PPUSH
29704: CALL_OW 1
29708: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29709: LD_ADDR_EXP 57
29713: PUSH
29714: LD_EXP 57
29718: PPUSH
29719: LD_VAR 0 2
29723: PUSH
29724: LD_EXP 57
29728: PUSH
29729: LD_VAR 0 2
29733: ARRAY
29734: PUSH
29735: LD_INT 1
29737: PLUS
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: LD_VAR 0 3
29747: PPUSH
29748: CALL 53394 0 3
29752: ST_TO_ADDR
// end ; end ;
29753: GO 29649
29755: POP
29756: POP
// if not lab or not mc_lab_upgrade [ i ] then
29757: LD_VAR 0 6
29761: NOT
29762: PUSH
29763: LD_EXP 84
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: NOT
29774: OR
29775: IFFALSE 29779
// continue ;
29777: GO 29549
// for j in lab do
29779: LD_ADDR_VAR 0 3
29783: PUSH
29784: LD_VAR 0 6
29788: PUSH
29789: FOR_IN
29790: IFFALSE 29955
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29792: LD_VAR 0 3
29796: PPUSH
29797: CALL_OW 266
29801: PUSH
29802: LD_INT 6
29804: PUSH
29805: LD_INT 7
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: IN
29812: PUSH
29813: LD_VAR 0 3
29817: PPUSH
29818: CALL_OW 461
29822: PUSH
29823: LD_INT 1
29825: NONEQUAL
29826: AND
29827: IFFALSE 29953
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29829: LD_VAR 0 3
29833: PPUSH
29834: LD_EXP 84
29838: PUSH
29839: LD_VAR 0 2
29843: ARRAY
29844: PUSH
29845: LD_INT 1
29847: ARRAY
29848: PPUSH
29849: CALL 60112 0 2
29853: IFFALSE 29953
// begin ComCancel ( j ) ;
29855: LD_VAR 0 3
29859: PPUSH
29860: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29864: LD_VAR 0 3
29868: PPUSH
29869: LD_EXP 84
29873: PUSH
29874: LD_VAR 0 2
29878: ARRAY
29879: PUSH
29880: LD_INT 1
29882: ARRAY
29883: PPUSH
29884: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29888: LD_VAR 0 3
29892: PUSH
29893: LD_EXP 57
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: IN
29904: NOT
29905: IFFALSE 29951
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29907: LD_ADDR_EXP 57
29911: PUSH
29912: LD_EXP 57
29916: PPUSH
29917: LD_VAR 0 2
29921: PUSH
29922: LD_EXP 57
29926: PUSH
29927: LD_VAR 0 2
29931: ARRAY
29932: PUSH
29933: LD_INT 1
29935: PLUS
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PPUSH
29941: LD_VAR 0 3
29945: PPUSH
29946: CALL 53394 0 3
29950: ST_TO_ADDR
// break ;
29951: GO 29955
// end ; end ; end ;
29953: GO 29789
29955: POP
29956: POP
// end ;
29957: GO 29549
29959: POP
29960: POP
// end ;
29961: LD_VAR 0 1
29965: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29966: LD_INT 0
29968: PPUSH
29969: PPUSH
29970: PPUSH
29971: PPUSH
29972: PPUSH
29973: PPUSH
29974: PPUSH
29975: PPUSH
29976: PPUSH
// if not mc_bases then
29977: LD_EXP 50
29981: NOT
29982: IFFALSE 29986
// exit ;
29984: GO 30391
// for i = 1 to mc_bases do
29986: LD_ADDR_VAR 0 2
29990: PUSH
29991: DOUBLE
29992: LD_INT 1
29994: DEC
29995: ST_TO_ADDR
29996: LD_EXP 50
30000: PUSH
30001: FOR_TO
30002: IFFALSE 30389
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30004: LD_EXP 58
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: NOT
30015: PUSH
30016: LD_EXP 50
30020: PUSH
30021: LD_VAR 0 2
30025: ARRAY
30026: PPUSH
30027: LD_INT 30
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PPUSH
30037: CALL_OW 72
30041: NOT
30042: OR
30043: IFFALSE 30047
// continue ;
30045: GO 30001
// busy := false ;
30047: LD_ADDR_VAR 0 8
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30055: LD_ADDR_VAR 0 4
30059: PUSH
30060: LD_EXP 50
30064: PUSH
30065: LD_VAR 0 2
30069: ARRAY
30070: PPUSH
30071: LD_INT 30
30073: PUSH
30074: LD_INT 3
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PPUSH
30081: CALL_OW 72
30085: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 58
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 32
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 33
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not t then
30135: LD_VAR 0 6
30139: NOT
30140: IFFALSE 30144
// continue ;
30142: GO 30001
// for j in tmp do
30144: LD_ADDR_VAR 0 3
30148: PUSH
30149: LD_VAR 0 4
30153: PUSH
30154: FOR_IN
30155: IFFALSE 30185
// if not BuildingStatus ( j ) = bs_idle then
30157: LD_VAR 0 3
30161: PPUSH
30162: CALL_OW 461
30166: PUSH
30167: LD_INT 2
30169: EQUAL
30170: NOT
30171: IFFALSE 30183
// begin busy := true ;
30173: LD_ADDR_VAR 0 8
30177: PUSH
30178: LD_INT 1
30180: ST_TO_ADDR
// break ;
30181: GO 30185
// end ;
30183: GO 30154
30185: POP
30186: POP
// if busy then
30187: LD_VAR 0 8
30191: IFFALSE 30195
// continue ;
30193: GO 30001
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30195: LD_ADDR_VAR 0 7
30199: PUSH
30200: LD_VAR 0 6
30204: PPUSH
30205: LD_INT 35
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PPUSH
30215: CALL_OW 72
30219: ST_TO_ADDR
// if tw then
30220: LD_VAR 0 7
30224: IFFALSE 30301
// begin tw := tw [ 1 ] ;
30226: LD_ADDR_VAR 0 7
30230: PUSH
30231: LD_VAR 0 7
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30240: LD_ADDR_VAR 0 9
30244: PUSH
30245: LD_VAR 0 7
30249: PPUSH
30250: LD_EXP 75
30254: PUSH
30255: LD_VAR 0 2
30259: ARRAY
30260: PPUSH
30261: CALL 58404 0 2
30265: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30266: LD_EXP 89
30270: PUSH
30271: LD_VAR 0 2
30275: ARRAY
30276: IFFALSE 30299
// if not weapon in mc_allowed_tower_weapons [ i ] then
30278: LD_VAR 0 9
30282: PUSH
30283: LD_EXP 89
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: IN
30294: NOT
30295: IFFALSE 30299
// continue ;
30297: GO 30001
// end else
30299: GO 30364
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30301: LD_ADDR_VAR 0 5
30305: PUSH
30306: LD_EXP 58
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PPUSH
30317: LD_VAR 0 4
30321: PPUSH
30322: CALL 84693 0 2
30326: ST_TO_ADDR
// if not tmp2 then
30327: LD_VAR 0 5
30331: NOT
30332: IFFALSE 30336
// continue ;
30334: GO 30001
// tw := tmp2 [ 1 ] ;
30336: LD_ADDR_VAR 0 7
30340: PUSH
30341: LD_VAR 0 5
30345: PUSH
30346: LD_INT 1
30348: ARRAY
30349: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30350: LD_ADDR_VAR 0 9
30354: PUSH
30355: LD_VAR 0 5
30359: PUSH
30360: LD_INT 2
30362: ARRAY
30363: ST_TO_ADDR
// end ; if not weapon then
30364: LD_VAR 0 9
30368: NOT
30369: IFFALSE 30373
// continue ;
30371: GO 30001
// ComPlaceWeapon ( tw , weapon ) ;
30373: LD_VAR 0 7
30377: PPUSH
30378: LD_VAR 0 9
30382: PPUSH
30383: CALL_OW 148
// end ;
30387: GO 30001
30389: POP
30390: POP
// end ;
30391: LD_VAR 0 1
30395: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30396: LD_INT 0
30398: PPUSH
30399: PPUSH
30400: PPUSH
30401: PPUSH
30402: PPUSH
30403: PPUSH
30404: PPUSH
// if not mc_bases then
30405: LD_EXP 50
30409: NOT
30410: IFFALSE 30414
// exit ;
30412: GO 31182
// for i = 1 to mc_bases do
30414: LD_ADDR_VAR 0 2
30418: PUSH
30419: DOUBLE
30420: LD_INT 1
30422: DEC
30423: ST_TO_ADDR
30424: LD_EXP 50
30428: PUSH
30429: FOR_TO
30430: IFFALSE 31180
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30432: LD_EXP 63
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: NOT
30443: PUSH
30444: LD_EXP 63
30448: PUSH
30449: LD_VAR 0 2
30453: ARRAY
30454: PUSH
30455: LD_EXP 64
30459: PUSH
30460: LD_VAR 0 2
30464: ARRAY
30465: EQUAL
30466: OR
30467: PUSH
30468: LD_EXP 73
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: OR
30479: IFFALSE 30483
// continue ;
30481: GO 30429
// if mc_miners [ i ] then
30483: LD_EXP 64
30487: PUSH
30488: LD_VAR 0 2
30492: ARRAY
30493: IFFALSE 30867
// begin for j = mc_miners [ i ] downto 1 do
30495: LD_ADDR_VAR 0 3
30499: PUSH
30500: DOUBLE
30501: LD_EXP 64
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: INC
30512: ST_TO_ADDR
30513: LD_INT 1
30515: PUSH
30516: FOR_DOWNTO
30517: IFFALSE 30865
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30519: LD_EXP 64
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_VAR 0 3
30534: ARRAY
30535: PPUSH
30536: CALL_OW 301
30540: PUSH
30541: LD_EXP 64
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PUSH
30552: LD_VAR 0 3
30556: ARRAY
30557: PPUSH
30558: CALL_OW 257
30562: PUSH
30563: LD_INT 1
30565: NONEQUAL
30566: OR
30567: IFFALSE 30630
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30569: LD_ADDR_VAR 0 5
30573: PUSH
30574: LD_EXP 64
30578: PUSH
30579: LD_VAR 0 2
30583: ARRAY
30584: PUSH
30585: LD_EXP 64
30589: PUSH
30590: LD_VAR 0 2
30594: ARRAY
30595: PUSH
30596: LD_VAR 0 3
30600: ARRAY
30601: DIFF
30602: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30603: LD_ADDR_EXP 64
30607: PUSH
30608: LD_EXP 64
30612: PPUSH
30613: LD_VAR 0 2
30617: PPUSH
30618: LD_VAR 0 5
30622: PPUSH
30623: CALL_OW 1
30627: ST_TO_ADDR
// continue ;
30628: GO 30516
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30630: LD_EXP 64
30634: PUSH
30635: LD_VAR 0 2
30639: ARRAY
30640: PUSH
30641: LD_VAR 0 3
30645: ARRAY
30646: PPUSH
30647: CALL_OW 257
30651: PUSH
30652: LD_INT 1
30654: EQUAL
30655: PUSH
30656: LD_EXP 64
30660: PUSH
30661: LD_VAR 0 2
30665: ARRAY
30666: PUSH
30667: LD_VAR 0 3
30671: ARRAY
30672: PPUSH
30673: CALL_OW 459
30677: NOT
30678: AND
30679: PUSH
30680: LD_EXP 64
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PPUSH
30697: CALL_OW 314
30701: NOT
30702: AND
30703: IFFALSE 30863
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30705: LD_EXP 64
30709: PUSH
30710: LD_VAR 0 2
30714: ARRAY
30715: PUSH
30716: LD_VAR 0 3
30720: ARRAY
30721: PPUSH
30722: CALL_OW 310
30726: IFFALSE 30749
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30728: LD_EXP 64
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PUSH
30739: LD_VAR 0 3
30743: ARRAY
30744: PPUSH
30745: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30749: LD_EXP 64
30753: PUSH
30754: LD_VAR 0 2
30758: ARRAY
30759: PUSH
30760: LD_VAR 0 3
30764: ARRAY
30765: PPUSH
30766: CALL_OW 314
30770: NOT
30771: IFFALSE 30863
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30773: LD_ADDR_VAR 0 7
30777: PUSH
30778: LD_INT 1
30780: PPUSH
30781: LD_EXP 63
30785: PUSH
30786: LD_VAR 0 2
30790: ARRAY
30791: PPUSH
30792: CALL_OW 12
30796: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30797: LD_EXP 64
30801: PUSH
30802: LD_VAR 0 2
30806: ARRAY
30807: PUSH
30808: LD_VAR 0 3
30812: ARRAY
30813: PPUSH
30814: LD_EXP 63
30818: PUSH
30819: LD_VAR 0 2
30823: ARRAY
30824: PUSH
30825: LD_VAR 0 7
30829: ARRAY
30830: PUSH
30831: LD_INT 1
30833: ARRAY
30834: PPUSH
30835: LD_EXP 63
30839: PUSH
30840: LD_VAR 0 2
30844: ARRAY
30845: PUSH
30846: LD_VAR 0 7
30850: ARRAY
30851: PUSH
30852: LD_INT 2
30854: ARRAY
30855: PPUSH
30856: LD_INT 0
30858: PPUSH
30859: CALL_OW 193
// end ; end ; end ;
30863: GO 30516
30865: POP
30866: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30867: LD_ADDR_VAR 0 5
30871: PUSH
30872: LD_EXP 50
30876: PUSH
30877: LD_VAR 0 2
30881: ARRAY
30882: PPUSH
30883: LD_INT 2
30885: PUSH
30886: LD_INT 30
30888: PUSH
30889: LD_INT 4
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 30
30898: PUSH
30899: LD_INT 5
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 30
30908: PUSH
30909: LD_INT 32
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: PPUSH
30922: CALL_OW 72
30926: ST_TO_ADDR
// if not tmp then
30927: LD_VAR 0 5
30931: NOT
30932: IFFALSE 30936
// continue ;
30934: GO 30429
// list := [ ] ;
30936: LD_ADDR_VAR 0 6
30940: PUSH
30941: EMPTY
30942: ST_TO_ADDR
// for j in tmp do
30943: LD_ADDR_VAR 0 3
30947: PUSH
30948: LD_VAR 0 5
30952: PUSH
30953: FOR_IN
30954: IFFALSE 31023
// begin for k in UnitsInside ( j ) do
30956: LD_ADDR_VAR 0 4
30960: PUSH
30961: LD_VAR 0 3
30965: PPUSH
30966: CALL_OW 313
30970: PUSH
30971: FOR_IN
30972: IFFALSE 31019
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30974: LD_VAR 0 4
30978: PPUSH
30979: CALL_OW 257
30983: PUSH
30984: LD_INT 1
30986: EQUAL
30987: PUSH
30988: LD_VAR 0 4
30992: PPUSH
30993: CALL_OW 459
30997: NOT
30998: AND
30999: IFFALSE 31017
// list := list ^ k ;
31001: LD_ADDR_VAR 0 6
31005: PUSH
31006: LD_VAR 0 6
31010: PUSH
31011: LD_VAR 0 4
31015: ADD
31016: ST_TO_ADDR
31017: GO 30971
31019: POP
31020: POP
// end ;
31021: GO 30953
31023: POP
31024: POP
// list := list diff mc_miners [ i ] ;
31025: LD_ADDR_VAR 0 6
31029: PUSH
31030: LD_VAR 0 6
31034: PUSH
31035: LD_EXP 64
31039: PUSH
31040: LD_VAR 0 2
31044: ARRAY
31045: DIFF
31046: ST_TO_ADDR
// if not list then
31047: LD_VAR 0 6
31051: NOT
31052: IFFALSE 31056
// continue ;
31054: GO 30429
// k := mc_mines [ i ] - mc_miners [ i ] ;
31056: LD_ADDR_VAR 0 4
31060: PUSH
31061: LD_EXP 63
31065: PUSH
31066: LD_VAR 0 2
31070: ARRAY
31071: PUSH
31072: LD_EXP 64
31076: PUSH
31077: LD_VAR 0 2
31081: ARRAY
31082: MINUS
31083: ST_TO_ADDR
// if k > list then
31084: LD_VAR 0 4
31088: PUSH
31089: LD_VAR 0 6
31093: GREATER
31094: IFFALSE 31106
// k := list ;
31096: LD_ADDR_VAR 0 4
31100: PUSH
31101: LD_VAR 0 6
31105: ST_TO_ADDR
// for j = 1 to k do
31106: LD_ADDR_VAR 0 3
31110: PUSH
31111: DOUBLE
31112: LD_INT 1
31114: DEC
31115: ST_TO_ADDR
31116: LD_VAR 0 4
31120: PUSH
31121: FOR_TO
31122: IFFALSE 31176
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31124: LD_ADDR_EXP 64
31128: PUSH
31129: LD_EXP 64
31133: PPUSH
31134: LD_VAR 0 2
31138: PUSH
31139: LD_EXP 64
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PUSH
31150: LD_INT 1
31152: PLUS
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PPUSH
31158: LD_VAR 0 6
31162: PUSH
31163: LD_VAR 0 3
31167: ARRAY
31168: PPUSH
31169: CALL 53394 0 3
31173: ST_TO_ADDR
31174: GO 31121
31176: POP
31177: POP
// end ;
31178: GO 30429
31180: POP
31181: POP
// end ;
31182: LD_VAR 0 1
31186: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31187: LD_INT 0
31189: PPUSH
31190: PPUSH
31191: PPUSH
31192: PPUSH
31193: PPUSH
31194: PPUSH
31195: PPUSH
31196: PPUSH
31197: PPUSH
31198: PPUSH
31199: PPUSH
// if not mc_bases then
31200: LD_EXP 50
31204: NOT
31205: IFFALSE 31209
// exit ;
31207: GO 33032
// for i = 1 to mc_bases do
31209: LD_ADDR_VAR 0 2
31213: PUSH
31214: DOUBLE
31215: LD_INT 1
31217: DEC
31218: ST_TO_ADDR
31219: LD_EXP 50
31223: PUSH
31224: FOR_TO
31225: IFFALSE 33030
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31227: LD_EXP 50
31231: PUSH
31232: LD_VAR 0 2
31236: ARRAY
31237: NOT
31238: PUSH
31239: LD_EXP 57
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: OR
31250: IFFALSE 31254
// continue ;
31252: GO 31224
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31254: LD_EXP 66
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: NOT
31265: PUSH
31266: LD_EXP 67
31270: PUSH
31271: LD_VAR 0 2
31275: ARRAY
31276: AND
31277: IFFALSE 31315
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31279: LD_ADDR_EXP 67
31283: PUSH
31284: LD_EXP 67
31288: PPUSH
31289: LD_VAR 0 2
31293: PPUSH
31294: EMPTY
31295: PPUSH
31296: CALL_OW 1
31300: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31301: LD_VAR 0 2
31305: PPUSH
31306: LD_INT 107
31308: PPUSH
31309: CALL 22083 0 2
// continue ;
31313: GO 31224
// end ; target := [ ] ;
31315: LD_ADDR_VAR 0 7
31319: PUSH
31320: EMPTY
31321: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31322: LD_ADDR_VAR 0 6
31326: PUSH
31327: LD_EXP 50
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: CALL_OW 255
31346: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31347: LD_ADDR_VAR 0 9
31351: PUSH
31352: LD_EXP 50
31356: PUSH
31357: LD_VAR 0 2
31361: ARRAY
31362: PPUSH
31363: LD_INT 2
31365: PUSH
31366: LD_INT 30
31368: PUSH
31369: LD_INT 0
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 30
31378: PUSH
31379: LD_INT 1
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: PPUSH
31391: CALL_OW 72
31395: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31396: LD_ADDR_VAR 0 3
31400: PUSH
31401: DOUBLE
31402: LD_EXP 66
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: INC
31413: ST_TO_ADDR
31414: LD_INT 1
31416: PUSH
31417: FOR_DOWNTO
31418: IFFALSE 31663
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31420: LD_EXP 66
31424: PUSH
31425: LD_VAR 0 2
31429: ARRAY
31430: PUSH
31431: LD_VAR 0 3
31435: ARRAY
31436: PUSH
31437: LD_INT 2
31439: ARRAY
31440: PPUSH
31441: LD_EXP 66
31445: PUSH
31446: LD_VAR 0 2
31450: ARRAY
31451: PUSH
31452: LD_VAR 0 3
31456: ARRAY
31457: PUSH
31458: LD_INT 3
31460: ARRAY
31461: PPUSH
31462: CALL_OW 488
31466: PUSH
31467: LD_EXP 66
31471: PUSH
31472: LD_VAR 0 2
31476: ARRAY
31477: PUSH
31478: LD_VAR 0 3
31482: ARRAY
31483: PUSH
31484: LD_INT 2
31486: ARRAY
31487: PPUSH
31488: LD_EXP 66
31492: PUSH
31493: LD_VAR 0 2
31497: ARRAY
31498: PUSH
31499: LD_VAR 0 3
31503: ARRAY
31504: PUSH
31505: LD_INT 3
31507: ARRAY
31508: PPUSH
31509: CALL_OW 284
31513: PUSH
31514: LD_INT 0
31516: EQUAL
31517: AND
31518: IFFALSE 31573
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31520: LD_ADDR_VAR 0 5
31524: PUSH
31525: LD_EXP 66
31529: PUSH
31530: LD_VAR 0 2
31534: ARRAY
31535: PPUSH
31536: LD_VAR 0 3
31540: PPUSH
31541: CALL_OW 3
31545: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31546: LD_ADDR_EXP 66
31550: PUSH
31551: LD_EXP 66
31555: PPUSH
31556: LD_VAR 0 2
31560: PPUSH
31561: LD_VAR 0 5
31565: PPUSH
31566: CALL_OW 1
31570: ST_TO_ADDR
// continue ;
31571: GO 31417
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31573: LD_VAR 0 6
31577: PPUSH
31578: LD_EXP 66
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 2
31597: ARRAY
31598: PPUSH
31599: LD_EXP 66
31603: PUSH
31604: LD_VAR 0 2
31608: ARRAY
31609: PUSH
31610: LD_VAR 0 3
31614: ARRAY
31615: PUSH
31616: LD_INT 3
31618: ARRAY
31619: PPUSH
31620: LD_INT 30
31622: PPUSH
31623: CALL 54290 0 4
31627: PUSH
31628: LD_INT 4
31630: ARRAY
31631: PUSH
31632: LD_INT 0
31634: EQUAL
31635: IFFALSE 31661
// begin target := mc_crates [ i ] [ j ] ;
31637: LD_ADDR_VAR 0 7
31641: PUSH
31642: LD_EXP 66
31646: PUSH
31647: LD_VAR 0 2
31651: ARRAY
31652: PUSH
31653: LD_VAR 0 3
31657: ARRAY
31658: ST_TO_ADDR
// break ;
31659: GO 31663
// end ; end ;
31661: GO 31417
31663: POP
31664: POP
// if not target then
31665: LD_VAR 0 7
31669: NOT
31670: IFFALSE 31674
// continue ;
31672: GO 31224
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31674: LD_ADDR_VAR 0 8
31678: PUSH
31679: LD_EXP 69
31683: PUSH
31684: LD_VAR 0 2
31688: ARRAY
31689: PPUSH
31690: LD_INT 2
31692: PUSH
31693: LD_INT 3
31695: PUSH
31696: LD_INT 58
31698: PUSH
31699: EMPTY
31700: LIST
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 61
31708: PUSH
31709: EMPTY
31710: LIST
31711: PUSH
31712: LD_INT 33
31714: PUSH
31715: LD_INT 5
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 33
31724: PUSH
31725: LD_INT 3
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 34
31744: PUSH
31745: LD_INT 32
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 34
31754: PUSH
31755: LD_INT 51
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 34
31764: PUSH
31765: LD_INT 12
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PPUSH
31782: CALL_OW 72
31786: ST_TO_ADDR
// if not cargo then
31787: LD_VAR 0 8
31791: NOT
31792: IFFALSE 32498
// begin if mc_crates_collector [ i ] < 5 then
31794: LD_EXP 67
31798: PUSH
31799: LD_VAR 0 2
31803: ARRAY
31804: PUSH
31805: LD_INT 5
31807: LESS
31808: IFFALSE 32174
// begin if mc_ape [ i ] then
31810: LD_EXP 79
31814: PUSH
31815: LD_VAR 0 2
31819: ARRAY
31820: IFFALSE 31867
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31822: LD_ADDR_VAR 0 5
31826: PUSH
31827: LD_EXP 79
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PPUSH
31838: LD_INT 25
31840: PUSH
31841: LD_INT 16
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 24
31850: PUSH
31851: LD_INT 750
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PPUSH
31862: CALL_OW 72
31866: ST_TO_ADDR
// if not tmp then
31867: LD_VAR 0 5
31871: NOT
31872: IFFALSE 31919
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31874: LD_ADDR_VAR 0 5
31878: PUSH
31879: LD_EXP 50
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PPUSH
31890: LD_INT 25
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 24
31902: PUSH
31903: LD_INT 750
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PPUSH
31914: CALL_OW 72
31918: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31919: LD_EXP 79
31923: PUSH
31924: LD_VAR 0 2
31928: ARRAY
31929: PUSH
31930: LD_EXP 50
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: PPUSH
31941: LD_INT 25
31943: PUSH
31944: LD_INT 2
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 24
31953: PUSH
31954: LD_INT 750
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PPUSH
31965: CALL_OW 72
31969: AND
31970: PUSH
31971: LD_VAR 0 5
31975: PUSH
31976: LD_INT 5
31978: LESS
31979: AND
31980: IFFALSE 32062
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31982: LD_ADDR_VAR 0 3
31986: PUSH
31987: LD_EXP 50
31991: PUSH
31992: LD_VAR 0 2
31996: ARRAY
31997: PPUSH
31998: LD_INT 25
32000: PUSH
32001: LD_INT 2
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 24
32010: PUSH
32011: LD_INT 750
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PPUSH
32022: CALL_OW 72
32026: PUSH
32027: FOR_IN
32028: IFFALSE 32060
// begin tmp := tmp union j ;
32030: LD_ADDR_VAR 0 5
32034: PUSH
32035: LD_VAR 0 5
32039: PUSH
32040: LD_VAR 0 3
32044: UNION
32045: ST_TO_ADDR
// if tmp >= 5 then
32046: LD_VAR 0 5
32050: PUSH
32051: LD_INT 5
32053: GREATEREQUAL
32054: IFFALSE 32058
// break ;
32056: GO 32060
// end ;
32058: GO 32027
32060: POP
32061: POP
// end ; if not tmp then
32062: LD_VAR 0 5
32066: NOT
32067: IFFALSE 32071
// continue ;
32069: GO 31224
// for j in tmp do
32071: LD_ADDR_VAR 0 3
32075: PUSH
32076: LD_VAR 0 5
32080: PUSH
32081: FOR_IN
32082: IFFALSE 32172
// if not GetTag ( j ) then
32084: LD_VAR 0 3
32088: PPUSH
32089: CALL_OW 110
32093: NOT
32094: IFFALSE 32170
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32096: LD_ADDR_EXP 67
32100: PUSH
32101: LD_EXP 67
32105: PPUSH
32106: LD_VAR 0 2
32110: PUSH
32111: LD_EXP 67
32115: PUSH
32116: LD_VAR 0 2
32120: ARRAY
32121: PUSH
32122: LD_INT 1
32124: PLUS
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PPUSH
32130: LD_VAR 0 3
32134: PPUSH
32135: CALL 53394 0 3
32139: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32140: LD_VAR 0 3
32144: PPUSH
32145: LD_INT 107
32147: PPUSH
32148: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32152: LD_EXP 67
32156: PUSH
32157: LD_VAR 0 2
32161: ARRAY
32162: PUSH
32163: LD_INT 5
32165: GREATEREQUAL
32166: IFFALSE 32170
// break ;
32168: GO 32172
// end ;
32170: GO 32081
32172: POP
32173: POP
// end ; if mc_crates_collector [ i ] and target then
32174: LD_EXP 67
32178: PUSH
32179: LD_VAR 0 2
32183: ARRAY
32184: PUSH
32185: LD_VAR 0 7
32189: AND
32190: IFFALSE 32496
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32192: LD_EXP 67
32196: PUSH
32197: LD_VAR 0 2
32201: ARRAY
32202: PUSH
32203: LD_VAR 0 7
32207: PUSH
32208: LD_INT 1
32210: ARRAY
32211: LESS
32212: IFFALSE 32232
// tmp := mc_crates_collector [ i ] else
32214: LD_ADDR_VAR 0 5
32218: PUSH
32219: LD_EXP 67
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: ST_TO_ADDR
32230: GO 32246
// tmp := target [ 1 ] ;
32232: LD_ADDR_VAR 0 5
32236: PUSH
32237: LD_VAR 0 7
32241: PUSH
32242: LD_INT 1
32244: ARRAY
32245: ST_TO_ADDR
// k := 0 ;
32246: LD_ADDR_VAR 0 4
32250: PUSH
32251: LD_INT 0
32253: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32254: LD_ADDR_VAR 0 3
32258: PUSH
32259: LD_EXP 67
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PUSH
32270: FOR_IN
32271: IFFALSE 32494
// begin k := k + 1 ;
32273: LD_ADDR_VAR 0 4
32277: PUSH
32278: LD_VAR 0 4
32282: PUSH
32283: LD_INT 1
32285: PLUS
32286: ST_TO_ADDR
// if k > tmp then
32287: LD_VAR 0 4
32291: PUSH
32292: LD_VAR 0 5
32296: GREATER
32297: IFFALSE 32301
// break ;
32299: GO 32494
// if not GetClass ( j ) in [ 2 , 16 ] then
32301: LD_VAR 0 3
32305: PPUSH
32306: CALL_OW 257
32310: PUSH
32311: LD_INT 2
32313: PUSH
32314: LD_INT 16
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: IN
32321: NOT
32322: IFFALSE 32375
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32324: LD_ADDR_EXP 67
32328: PUSH
32329: LD_EXP 67
32333: PPUSH
32334: LD_VAR 0 2
32338: PPUSH
32339: LD_EXP 67
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_VAR 0 3
32354: DIFF
32355: PPUSH
32356: CALL_OW 1
32360: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32361: LD_VAR 0 3
32365: PPUSH
32366: LD_INT 0
32368: PPUSH
32369: CALL_OW 109
// continue ;
32373: GO 32270
// end ; if IsInUnit ( j ) then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 310
32384: IFFALSE 32395
// ComExitBuilding ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 122
// wait ( 3 ) ;
32395: LD_INT 3
32397: PPUSH
32398: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32402: LD_VAR 0 3
32406: PPUSH
32407: CALL_OW 314
32411: PUSH
32412: LD_VAR 0 6
32416: PPUSH
32417: LD_VAR 0 7
32421: PUSH
32422: LD_INT 2
32424: ARRAY
32425: PPUSH
32426: LD_VAR 0 7
32430: PUSH
32431: LD_INT 3
32433: ARRAY
32434: PPUSH
32435: LD_INT 30
32437: PPUSH
32438: CALL 54290 0 4
32442: PUSH
32443: LD_INT 4
32445: ARRAY
32446: AND
32447: IFFALSE 32465
// ComStandNearbyBuilding ( j , depot ) else
32449: LD_VAR 0 3
32453: PPUSH
32454: LD_VAR 0 9
32458: PPUSH
32459: CALL 49972 0 2
32463: GO 32492
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32465: LD_VAR 0 3
32469: PPUSH
32470: LD_VAR 0 7
32474: PUSH
32475: LD_INT 2
32477: ARRAY
32478: PPUSH
32479: LD_VAR 0 7
32483: PUSH
32484: LD_INT 3
32486: ARRAY
32487: PPUSH
32488: CALL_OW 117
// end ;
32492: GO 32270
32494: POP
32495: POP
// end ; end else
32496: GO 33028
// begin for j in cargo do
32498: LD_ADDR_VAR 0 3
32502: PUSH
32503: LD_VAR 0 8
32507: PUSH
32508: FOR_IN
32509: IFFALSE 33026
// begin if GetTag ( j ) <> 0 then
32511: LD_VAR 0 3
32515: PPUSH
32516: CALL_OW 110
32520: PUSH
32521: LD_INT 0
32523: NONEQUAL
32524: IFFALSE 32528
// continue ;
32526: GO 32508
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32528: LD_VAR 0 3
32532: PPUSH
32533: CALL_OW 256
32537: PUSH
32538: LD_INT 1000
32540: LESS
32541: PUSH
32542: LD_VAR 0 3
32546: PPUSH
32547: LD_EXP 74
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PPUSH
32558: CALL_OW 308
32562: NOT
32563: AND
32564: IFFALSE 32586
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 74
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PPUSH
32582: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32586: LD_VAR 0 3
32590: PPUSH
32591: CALL_OW 256
32595: PUSH
32596: LD_INT 1000
32598: LESS
32599: PUSH
32600: LD_VAR 0 3
32604: PPUSH
32605: LD_EXP 74
32609: PUSH
32610: LD_VAR 0 2
32614: ARRAY
32615: PPUSH
32616: CALL_OW 308
32620: AND
32621: IFFALSE 32625
// continue ;
32623: GO 32508
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32625: LD_VAR 0 3
32629: PPUSH
32630: CALL_OW 262
32634: PUSH
32635: LD_INT 2
32637: EQUAL
32638: PUSH
32639: LD_VAR 0 3
32643: PPUSH
32644: CALL_OW 261
32648: PUSH
32649: LD_INT 15
32651: LESS
32652: AND
32653: IFFALSE 32657
// continue ;
32655: GO 32508
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32657: LD_VAR 0 3
32661: PPUSH
32662: CALL_OW 262
32666: PUSH
32667: LD_INT 1
32669: EQUAL
32670: PUSH
32671: LD_VAR 0 3
32675: PPUSH
32676: CALL_OW 261
32680: PUSH
32681: LD_INT 10
32683: LESS
32684: AND
32685: IFFALSE 32965
// begin if not depot then
32687: LD_VAR 0 9
32691: NOT
32692: IFFALSE 32696
// continue ;
32694: GO 32508
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32696: LD_VAR 0 3
32700: PPUSH
32701: LD_VAR 0 9
32705: PPUSH
32706: LD_VAR 0 3
32710: PPUSH
32711: CALL_OW 74
32715: PPUSH
32716: CALL_OW 296
32720: PUSH
32721: LD_INT 6
32723: LESS
32724: IFFALSE 32740
// SetFuel ( j , 100 ) else
32726: LD_VAR 0 3
32730: PPUSH
32731: LD_INT 100
32733: PPUSH
32734: CALL_OW 240
32738: GO 32965
// if GetFuel ( j ) = 0 then
32740: LD_VAR 0 3
32744: PPUSH
32745: CALL_OW 261
32749: PUSH
32750: LD_INT 0
32752: EQUAL
32753: IFFALSE 32965
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32755: LD_ADDR_EXP 69
32759: PUSH
32760: LD_EXP 69
32764: PPUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_EXP 69
32774: PUSH
32775: LD_VAR 0 2
32779: ARRAY
32780: PUSH
32781: LD_VAR 0 3
32785: DIFF
32786: PPUSH
32787: CALL_OW 1
32791: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32792: LD_VAR 0 3
32796: PPUSH
32797: CALL_OW 263
32801: PUSH
32802: LD_INT 1
32804: EQUAL
32805: IFFALSE 32821
// ComExitVehicle ( IsInUnit ( j ) ) ;
32807: LD_VAR 0 3
32811: PPUSH
32812: CALL_OW 310
32816: PPUSH
32817: CALL_OW 121
// if GetControl ( j ) = control_remote then
32821: LD_VAR 0 3
32825: PPUSH
32826: CALL_OW 263
32830: PUSH
32831: LD_INT 2
32833: EQUAL
32834: IFFALSE 32845
// ComUnlink ( j ) ;
32836: LD_VAR 0 3
32840: PPUSH
32841: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32845: LD_ADDR_VAR 0 10
32849: PUSH
32850: LD_VAR 0 2
32854: PPUSH
32855: LD_INT 3
32857: PPUSH
32858: CALL 42457 0 2
32862: ST_TO_ADDR
// if fac then
32863: LD_VAR 0 10
32867: IFFALSE 32963
// begin for k in fac do
32869: LD_ADDR_VAR 0 4
32873: PUSH
32874: LD_VAR 0 10
32878: PUSH
32879: FOR_IN
32880: IFFALSE 32961
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32882: LD_ADDR_VAR 0 11
32886: PUSH
32887: LD_VAR 0 10
32891: PPUSH
32892: LD_VAR 0 3
32896: PPUSH
32897: CALL_OW 265
32901: PPUSH
32902: LD_VAR 0 3
32906: PPUSH
32907: CALL_OW 262
32911: PPUSH
32912: LD_VAR 0 3
32916: PPUSH
32917: CALL_OW 263
32921: PPUSH
32922: LD_VAR 0 3
32926: PPUSH
32927: CALL_OW 264
32931: PPUSH
32932: CALL 50890 0 5
32936: ST_TO_ADDR
// if components then
32937: LD_VAR 0 11
32941: IFFALSE 32959
// begin MC_InsertProduceList ( i , components ) ;
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 11
32952: PPUSH
32953: CALL 42002 0 2
// break ;
32957: GO 32961
// end ; end ;
32959: GO 32879
32961: POP
32962: POP
// end ; continue ;
32963: GO 32508
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32965: LD_VAR 0 3
32969: PPUSH
32970: LD_INT 1
32972: PPUSH
32973: CALL_OW 289
32977: PUSH
32978: LD_INT 100
32980: LESS
32981: PUSH
32982: LD_VAR 0 3
32986: PPUSH
32987: CALL_OW 314
32991: NOT
32992: AND
32993: IFFALSE 33022
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32995: LD_VAR 0 3
32999: PPUSH
33000: LD_VAR 0 7
33004: PUSH
33005: LD_INT 2
33007: ARRAY
33008: PPUSH
33009: LD_VAR 0 7
33013: PUSH
33014: LD_INT 3
33016: ARRAY
33017: PPUSH
33018: CALL_OW 117
// break ;
33022: GO 33026
// end ;
33024: GO 32508
33026: POP
33027: POP
// end ; end ;
33028: GO 31224
33030: POP
33031: POP
// end ;
33032: LD_VAR 0 1
33036: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33037: LD_INT 0
33039: PPUSH
33040: PPUSH
33041: PPUSH
33042: PPUSH
// if not mc_bases then
33043: LD_EXP 50
33047: NOT
33048: IFFALSE 33052
// exit ;
33050: GO 33213
// for i = 1 to mc_bases do
33052: LD_ADDR_VAR 0 2
33056: PUSH
33057: DOUBLE
33058: LD_INT 1
33060: DEC
33061: ST_TO_ADDR
33062: LD_EXP 50
33066: PUSH
33067: FOR_TO
33068: IFFALSE 33211
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33070: LD_ADDR_VAR 0 4
33074: PUSH
33075: LD_EXP 69
33079: PUSH
33080: LD_VAR 0 2
33084: ARRAY
33085: PUSH
33086: LD_EXP 72
33090: PUSH
33091: LD_VAR 0 2
33095: ARRAY
33096: UNION
33097: PPUSH
33098: LD_INT 33
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PPUSH
33108: CALL_OW 72
33112: ST_TO_ADDR
// if tmp then
33113: LD_VAR 0 4
33117: IFFALSE 33209
// for j in tmp do
33119: LD_ADDR_VAR 0 3
33123: PUSH
33124: LD_VAR 0 4
33128: PUSH
33129: FOR_IN
33130: IFFALSE 33207
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33132: LD_VAR 0 3
33136: PPUSH
33137: CALL_OW 312
33141: NOT
33142: PUSH
33143: LD_VAR 0 3
33147: PPUSH
33148: CALL_OW 256
33152: PUSH
33153: LD_INT 250
33155: GREATEREQUAL
33156: AND
33157: IFFALSE 33170
// Connect ( j ) else
33159: LD_VAR 0 3
33163: PPUSH
33164: CALL 56365 0 1
33168: GO 33205
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33170: LD_VAR 0 3
33174: PPUSH
33175: CALL_OW 256
33179: PUSH
33180: LD_INT 250
33182: LESS
33183: PUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: CALL_OW 312
33193: AND
33194: IFFALSE 33205
// ComUnlink ( j ) ;
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 136
33205: GO 33129
33207: POP
33208: POP
// end ;
33209: GO 33067
33211: POP
33212: POP
// end ;
33213: LD_VAR 0 1
33217: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33218: LD_INT 0
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// if not mc_bases then
33225: LD_EXP 50
33229: NOT
33230: IFFALSE 33234
// exit ;
33232: GO 33679
// for i = 1 to mc_bases do
33234: LD_ADDR_VAR 0 2
33238: PUSH
33239: DOUBLE
33240: LD_INT 1
33242: DEC
33243: ST_TO_ADDR
33244: LD_EXP 50
33248: PUSH
33249: FOR_TO
33250: IFFALSE 33677
// begin if not mc_produce [ i ] then
33252: LD_EXP 71
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: NOT
33263: IFFALSE 33267
// continue ;
33265: GO 33249
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33267: LD_ADDR_VAR 0 5
33271: PUSH
33272: LD_EXP 50
33276: PUSH
33277: LD_VAR 0 2
33281: ARRAY
33282: PPUSH
33283: LD_INT 30
33285: PUSH
33286: LD_INT 3
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PPUSH
33293: CALL_OW 72
33297: ST_TO_ADDR
// if not fac then
33298: LD_VAR 0 5
33302: NOT
33303: IFFALSE 33307
// continue ;
33305: GO 33249
// for j in fac do
33307: LD_ADDR_VAR 0 3
33311: PUSH
33312: LD_VAR 0 5
33316: PUSH
33317: FOR_IN
33318: IFFALSE 33673
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33320: LD_VAR 0 3
33324: PPUSH
33325: CALL_OW 461
33329: PUSH
33330: LD_INT 2
33332: NONEQUAL
33333: PUSH
33334: LD_VAR 0 3
33338: PPUSH
33339: LD_INT 15
33341: PPUSH
33342: CALL 55993 0 2
33346: PUSH
33347: LD_INT 4
33349: ARRAY
33350: OR
33351: IFFALSE 33355
// continue ;
33353: GO 33317
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33355: LD_VAR 0 3
33359: PPUSH
33360: LD_EXP 71
33364: PUSH
33365: LD_VAR 0 2
33369: ARRAY
33370: PUSH
33371: LD_INT 1
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: PPUSH
33379: LD_EXP 71
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PUSH
33390: LD_INT 1
33392: ARRAY
33393: PUSH
33394: LD_INT 2
33396: ARRAY
33397: PPUSH
33398: LD_EXP 71
33402: PUSH
33403: LD_VAR 0 2
33407: ARRAY
33408: PUSH
33409: LD_INT 1
33411: ARRAY
33412: PUSH
33413: LD_INT 3
33415: ARRAY
33416: PPUSH
33417: LD_EXP 71
33421: PUSH
33422: LD_VAR 0 2
33426: ARRAY
33427: PUSH
33428: LD_INT 1
33430: ARRAY
33431: PUSH
33432: LD_INT 4
33434: ARRAY
33435: PPUSH
33436: CALL_OW 448
33440: PUSH
33441: LD_VAR 0 3
33445: PPUSH
33446: LD_EXP 71
33450: PUSH
33451: LD_VAR 0 2
33455: ARRAY
33456: PUSH
33457: LD_INT 1
33459: ARRAY
33460: PUSH
33461: LD_INT 1
33463: ARRAY
33464: PUSH
33465: LD_EXP 71
33469: PUSH
33470: LD_VAR 0 2
33474: ARRAY
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: PUSH
33480: LD_INT 2
33482: ARRAY
33483: PUSH
33484: LD_EXP 71
33488: PUSH
33489: LD_VAR 0 2
33493: ARRAY
33494: PUSH
33495: LD_INT 1
33497: ARRAY
33498: PUSH
33499: LD_INT 3
33501: ARRAY
33502: PUSH
33503: LD_EXP 71
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PUSH
33514: LD_INT 1
33516: ARRAY
33517: PUSH
33518: LD_INT 4
33520: ARRAY
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: LIST
33526: LIST
33527: PPUSH
33528: CALL 59760 0 2
33532: AND
33533: IFFALSE 33671
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: LD_EXP 71
33544: PUSH
33545: LD_VAR 0 2
33549: ARRAY
33550: PUSH
33551: LD_INT 1
33553: ARRAY
33554: PUSH
33555: LD_INT 1
33557: ARRAY
33558: PPUSH
33559: LD_EXP 71
33563: PUSH
33564: LD_VAR 0 2
33568: ARRAY
33569: PUSH
33570: LD_INT 1
33572: ARRAY
33573: PUSH
33574: LD_INT 2
33576: ARRAY
33577: PPUSH
33578: LD_EXP 71
33582: PUSH
33583: LD_VAR 0 2
33587: ARRAY
33588: PUSH
33589: LD_INT 1
33591: ARRAY
33592: PUSH
33593: LD_INT 3
33595: ARRAY
33596: PPUSH
33597: LD_EXP 71
33601: PUSH
33602: LD_VAR 0 2
33606: ARRAY
33607: PUSH
33608: LD_INT 1
33610: ARRAY
33611: PUSH
33612: LD_INT 4
33614: ARRAY
33615: PPUSH
33616: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33620: LD_ADDR_VAR 0 4
33624: PUSH
33625: LD_EXP 71
33629: PUSH
33630: LD_VAR 0 2
33634: ARRAY
33635: PPUSH
33636: LD_INT 1
33638: PPUSH
33639: CALL_OW 3
33643: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33644: LD_ADDR_EXP 71
33648: PUSH
33649: LD_EXP 71
33653: PPUSH
33654: LD_VAR 0 2
33658: PPUSH
33659: LD_VAR 0 4
33663: PPUSH
33664: CALL_OW 1
33668: ST_TO_ADDR
// break ;
33669: GO 33673
// end ; end ;
33671: GO 33317
33673: POP
33674: POP
// end ;
33675: GO 33249
33677: POP
33678: POP
// end ;
33679: LD_VAR 0 1
33683: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33684: LD_INT 0
33686: PPUSH
33687: PPUSH
33688: PPUSH
// if not mc_bases then
33689: LD_EXP 50
33693: NOT
33694: IFFALSE 33698
// exit ;
33696: GO 33787
// for i = 1 to mc_bases do
33698: LD_ADDR_VAR 0 2
33702: PUSH
33703: DOUBLE
33704: LD_INT 1
33706: DEC
33707: ST_TO_ADDR
33708: LD_EXP 50
33712: PUSH
33713: FOR_TO
33714: IFFALSE 33785
// begin if mc_attack [ i ] then
33716: LD_EXP 70
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: IFFALSE 33783
// begin tmp := mc_attack [ i ] [ 1 ] ;
33728: LD_ADDR_VAR 0 3
33732: PUSH
33733: LD_EXP 70
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: PUSH
33744: LD_INT 1
33746: ARRAY
33747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33748: LD_ADDR_EXP 70
33752: PUSH
33753: LD_EXP 70
33757: PPUSH
33758: LD_VAR 0 2
33762: PPUSH
33763: EMPTY
33764: PPUSH
33765: CALL_OW 1
33769: ST_TO_ADDR
// Attack ( tmp ) ;
33770: LD_VAR 0 3
33774: PPUSH
33775: CALL 105318 0 1
// exit ;
33779: POP
33780: POP
33781: GO 33787
// end ; end ;
33783: GO 33713
33785: POP
33786: POP
// end ;
33787: LD_VAR 0 1
33791: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33792: LD_INT 0
33794: PPUSH
33795: PPUSH
33796: PPUSH
33797: PPUSH
33798: PPUSH
33799: PPUSH
33800: PPUSH
// if not mc_bases then
33801: LD_EXP 50
33805: NOT
33806: IFFALSE 33810
// exit ;
33808: GO 34520
// for i = 1 to mc_bases do
33810: LD_ADDR_VAR 0 2
33814: PUSH
33815: DOUBLE
33816: LD_INT 1
33818: DEC
33819: ST_TO_ADDR
33820: LD_EXP 50
33824: PUSH
33825: FOR_TO
33826: IFFALSE 34518
// begin if not mc_bases [ i ] then
33828: LD_EXP 50
33832: PUSH
33833: LD_VAR 0 2
33837: ARRAY
33838: NOT
33839: IFFALSE 33843
// continue ;
33841: GO 33825
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33843: LD_ADDR_VAR 0 7
33847: PUSH
33848: LD_EXP 50
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PUSH
33859: LD_INT 1
33861: ARRAY
33862: PPUSH
33863: CALL 50194 0 1
33867: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33868: LD_ADDR_EXP 73
33872: PUSH
33873: LD_EXP 73
33877: PPUSH
33878: LD_VAR 0 2
33882: PPUSH
33883: LD_EXP 50
33887: PUSH
33888: LD_VAR 0 2
33892: ARRAY
33893: PUSH
33894: LD_INT 1
33896: ARRAY
33897: PPUSH
33898: CALL_OW 255
33902: PPUSH
33903: LD_EXP 75
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: PPUSH
33914: CALL 50159 0 2
33918: PPUSH
33919: CALL_OW 1
33923: ST_TO_ADDR
// if not mc_scan [ i ] then
33924: LD_EXP 73
33928: PUSH
33929: LD_VAR 0 2
33933: ARRAY
33934: NOT
33935: IFFALSE 34113
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33937: LD_ADDR_EXP 93
33941: PUSH
33942: LD_EXP 93
33946: PPUSH
33947: LD_VAR 0 2
33951: PPUSH
33952: LD_INT 0
33954: PPUSH
33955: CALL_OW 1
33959: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33960: LD_ADDR_VAR 0 4
33964: PUSH
33965: LD_EXP 50
33969: PUSH
33970: LD_VAR 0 2
33974: ARRAY
33975: PPUSH
33976: LD_INT 2
33978: PUSH
33979: LD_INT 25
33981: PUSH
33982: LD_INT 5
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 25
33991: PUSH
33992: LD_INT 8
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 25
34001: PUSH
34002: LD_INT 9
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: PPUSH
34015: CALL_OW 72
34019: ST_TO_ADDR
// if not tmp then
34020: LD_VAR 0 4
34024: NOT
34025: IFFALSE 34029
// continue ;
34027: GO 33825
// for j in tmp do
34029: LD_ADDR_VAR 0 3
34033: PUSH
34034: LD_VAR 0 4
34038: PUSH
34039: FOR_IN
34040: IFFALSE 34111
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34042: LD_VAR 0 3
34046: PPUSH
34047: CALL_OW 310
34051: PPUSH
34052: CALL_OW 266
34056: PUSH
34057: LD_INT 5
34059: EQUAL
34060: PUSH
34061: LD_VAR 0 3
34065: PPUSH
34066: CALL_OW 257
34070: PUSH
34071: LD_INT 1
34073: EQUAL
34074: AND
34075: PUSH
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 459
34085: NOT
34086: AND
34087: PUSH
34088: LD_VAR 0 7
34092: AND
34093: IFFALSE 34109
// ComChangeProfession ( j , class ) ;
34095: LD_VAR 0 3
34099: PPUSH
34100: LD_VAR 0 7
34104: PPUSH
34105: CALL_OW 123
34109: GO 34039
34111: POP
34112: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
34113: LD_EXP 73
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_EXP 93
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: NOT
34135: AND
34136: PUSH
34137: LD_EXP 72
34141: PUSH
34142: LD_VAR 0 2
34146: ARRAY
34147: NOT
34148: AND
34149: IFFALSE 34400
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34151: LD_ADDR_EXP 93
34155: PUSH
34156: LD_EXP 93
34160: PPUSH
34161: LD_VAR 0 2
34165: PPUSH
34166: LD_INT 1
34168: PPUSH
34169: CALL_OW 1
34173: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34174: LD_ADDR_VAR 0 4
34178: PUSH
34179: LD_EXP 50
34183: PUSH
34184: LD_VAR 0 2
34188: ARRAY
34189: PPUSH
34190: LD_INT 2
34192: PUSH
34193: LD_INT 25
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 25
34205: PUSH
34206: LD_INT 5
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 25
34215: PUSH
34216: LD_INT 8
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 25
34225: PUSH
34226: LD_INT 9
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: PPUSH
34240: CALL_OW 72
34244: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34245: LD_ADDR_VAR 0 4
34249: PUSH
34250: LD_VAR 0 4
34254: PUSH
34255: LD_VAR 0 4
34259: PPUSH
34260: LD_INT 18
34262: PPUSH
34263: CALL 82663 0 2
34267: DIFF
34268: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34269: LD_VAR 0 4
34273: NOT
34274: PUSH
34275: LD_EXP 50
34279: PUSH
34280: LD_VAR 0 2
34284: ARRAY
34285: PPUSH
34286: LD_INT 2
34288: PUSH
34289: LD_INT 30
34291: PUSH
34292: LD_INT 4
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 30
34301: PUSH
34302: LD_INT 5
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: LIST
34313: PPUSH
34314: CALL_OW 72
34318: NOT
34319: AND
34320: IFFALSE 34382
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34322: LD_ADDR_VAR 0 4
34326: PUSH
34327: LD_EXP 50
34331: PUSH
34332: LD_VAR 0 2
34336: ARRAY
34337: PPUSH
34338: LD_INT 2
34340: PUSH
34341: LD_INT 25
34343: PUSH
34344: LD_INT 2
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 25
34353: PUSH
34354: LD_INT 3
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 25
34363: PUSH
34364: LD_INT 4
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: PPUSH
34377: CALL_OW 72
34381: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34382: LD_VAR 0 2
34386: PPUSH
34387: LD_VAR 0 4
34391: PPUSH
34392: CALL 110027 0 2
// exit ;
34396: POP
34397: POP
34398: GO 34520
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34400: LD_EXP 73
34404: PUSH
34405: LD_VAR 0 2
34409: ARRAY
34410: PUSH
34411: LD_EXP 93
34415: PUSH
34416: LD_VAR 0 2
34420: ARRAY
34421: NOT
34422: AND
34423: PUSH
34424: LD_EXP 72
34428: PUSH
34429: LD_VAR 0 2
34433: ARRAY
34434: AND
34435: IFFALSE 34516
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34437: LD_ADDR_EXP 93
34441: PUSH
34442: LD_EXP 93
34446: PPUSH
34447: LD_VAR 0 2
34451: PPUSH
34452: LD_INT 1
34454: PPUSH
34455: CALL_OW 1
34459: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34460: LD_ADDR_VAR 0 4
34464: PUSH
34465: LD_EXP 72
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34476: LD_ADDR_EXP 72
34480: PUSH
34481: LD_EXP 72
34485: PPUSH
34486: LD_VAR 0 2
34490: PPUSH
34491: EMPTY
34492: PPUSH
34493: CALL_OW 1
34497: ST_TO_ADDR
// Defend ( i , tmp ) ;
34498: LD_VAR 0 2
34502: PPUSH
34503: LD_VAR 0 4
34507: PPUSH
34508: CALL 110597 0 2
// exit ;
34512: POP
34513: POP
34514: GO 34520
// end ; end ;
34516: GO 33825
34518: POP
34519: POP
// end ;
34520: LD_VAR 0 1
34524: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34525: LD_INT 0
34527: PPUSH
34528: PPUSH
34529: PPUSH
34530: PPUSH
34531: PPUSH
34532: PPUSH
34533: PPUSH
34534: PPUSH
34535: PPUSH
34536: PPUSH
34537: PPUSH
// if not mc_bases then
34538: LD_EXP 50
34542: NOT
34543: IFFALSE 34547
// exit ;
34545: GO 35634
// for i = 1 to mc_bases do
34547: LD_ADDR_VAR 0 2
34551: PUSH
34552: DOUBLE
34553: LD_INT 1
34555: DEC
34556: ST_TO_ADDR
34557: LD_EXP 50
34561: PUSH
34562: FOR_TO
34563: IFFALSE 35632
// begin tmp := mc_lab [ i ] ;
34565: LD_ADDR_VAR 0 6
34569: PUSH
34570: LD_EXP 83
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: ST_TO_ADDR
// if not tmp then
34581: LD_VAR 0 6
34585: NOT
34586: IFFALSE 34590
// continue ;
34588: GO 34562
// idle_lab := 0 ;
34590: LD_ADDR_VAR 0 11
34594: PUSH
34595: LD_INT 0
34597: ST_TO_ADDR
// for j in tmp do
34598: LD_ADDR_VAR 0 3
34602: PUSH
34603: LD_VAR 0 6
34607: PUSH
34608: FOR_IN
34609: IFFALSE 35628
// begin researching := false ;
34611: LD_ADDR_VAR 0 10
34615: PUSH
34616: LD_INT 0
34618: ST_TO_ADDR
// side := GetSide ( j ) ;
34619: LD_ADDR_VAR 0 4
34623: PUSH
34624: LD_VAR 0 3
34628: PPUSH
34629: CALL_OW 255
34633: ST_TO_ADDR
// if not mc_tech [ side ] then
34634: LD_EXP 77
34638: PUSH
34639: LD_VAR 0 4
34643: ARRAY
34644: NOT
34645: IFFALSE 34649
// continue ;
34647: GO 34608
// if BuildingStatus ( j ) = bs_idle then
34649: LD_VAR 0 3
34653: PPUSH
34654: CALL_OW 461
34658: PUSH
34659: LD_INT 2
34661: EQUAL
34662: IFFALSE 34850
// begin if idle_lab and UnitsInside ( j ) < 6 then
34664: LD_VAR 0 11
34668: PUSH
34669: LD_VAR 0 3
34673: PPUSH
34674: CALL_OW 313
34678: PUSH
34679: LD_INT 6
34681: LESS
34682: AND
34683: IFFALSE 34754
// begin tmp2 := UnitsInside ( idle_lab ) ;
34685: LD_ADDR_VAR 0 9
34689: PUSH
34690: LD_VAR 0 11
34694: PPUSH
34695: CALL_OW 313
34699: ST_TO_ADDR
// if tmp2 then
34700: LD_VAR 0 9
34704: IFFALSE 34746
// for x in tmp2 do
34706: LD_ADDR_VAR 0 7
34710: PUSH
34711: LD_VAR 0 9
34715: PUSH
34716: FOR_IN
34717: IFFALSE 34744
// begin ComExitBuilding ( x ) ;
34719: LD_VAR 0 7
34723: PPUSH
34724: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34728: LD_VAR 0 7
34732: PPUSH
34733: LD_VAR 0 3
34737: PPUSH
34738: CALL_OW 180
// end ;
34742: GO 34716
34744: POP
34745: POP
// idle_lab := 0 ;
34746: LD_ADDR_VAR 0 11
34750: PUSH
34751: LD_INT 0
34753: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34754: LD_ADDR_VAR 0 5
34758: PUSH
34759: LD_EXP 77
34763: PUSH
34764: LD_VAR 0 4
34768: ARRAY
34769: PUSH
34770: FOR_IN
34771: IFFALSE 34831
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34773: LD_VAR 0 3
34777: PPUSH
34778: LD_VAR 0 5
34782: PPUSH
34783: CALL_OW 430
34787: PUSH
34788: LD_VAR 0 4
34792: PPUSH
34793: LD_VAR 0 5
34797: PPUSH
34798: CALL 49264 0 2
34802: AND
34803: IFFALSE 34829
// begin researching := true ;
34805: LD_ADDR_VAR 0 10
34809: PUSH
34810: LD_INT 1
34812: ST_TO_ADDR
// ComResearch ( j , t ) ;
34813: LD_VAR 0 3
34817: PPUSH
34818: LD_VAR 0 5
34822: PPUSH
34823: CALL_OW 124
// break ;
34827: GO 34831
// end ;
34829: GO 34770
34831: POP
34832: POP
// if not researching then
34833: LD_VAR 0 10
34837: NOT
34838: IFFALSE 34850
// idle_lab := j ;
34840: LD_ADDR_VAR 0 11
34844: PUSH
34845: LD_VAR 0 3
34849: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34850: LD_VAR 0 3
34854: PPUSH
34855: CALL_OW 461
34859: PUSH
34860: LD_INT 10
34862: EQUAL
34863: IFFALSE 35451
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34865: LD_EXP 79
34869: PUSH
34870: LD_VAR 0 2
34874: ARRAY
34875: NOT
34876: PUSH
34877: LD_EXP 80
34881: PUSH
34882: LD_VAR 0 2
34886: ARRAY
34887: NOT
34888: AND
34889: PUSH
34890: LD_EXP 77
34894: PUSH
34895: LD_VAR 0 4
34899: ARRAY
34900: PUSH
34901: LD_INT 1
34903: GREATER
34904: AND
34905: IFFALSE 35036
// begin ComCancel ( j ) ;
34907: LD_VAR 0 3
34911: PPUSH
34912: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34916: LD_ADDR_EXP 77
34920: PUSH
34921: LD_EXP 77
34925: PPUSH
34926: LD_VAR 0 4
34930: PPUSH
34931: LD_EXP 77
34935: PUSH
34936: LD_VAR 0 4
34940: ARRAY
34941: PPUSH
34942: LD_EXP 77
34946: PUSH
34947: LD_VAR 0 4
34951: ARRAY
34952: PUSH
34953: LD_INT 1
34955: MINUS
34956: PPUSH
34957: LD_EXP 77
34961: PUSH
34962: LD_VAR 0 4
34966: ARRAY
34967: PPUSH
34968: LD_INT 0
34970: PPUSH
34971: CALL 52812 0 4
34975: PPUSH
34976: CALL_OW 1
34980: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34981: LD_ADDR_EXP 77
34985: PUSH
34986: LD_EXP 77
34990: PPUSH
34991: LD_VAR 0 4
34995: PPUSH
34996: LD_EXP 77
35000: PUSH
35001: LD_VAR 0 4
35005: ARRAY
35006: PPUSH
35007: LD_EXP 77
35011: PUSH
35012: LD_VAR 0 4
35016: ARRAY
35017: PPUSH
35018: LD_INT 1
35020: PPUSH
35021: LD_INT 0
35023: PPUSH
35024: CALL 52812 0 4
35028: PPUSH
35029: CALL_OW 1
35033: ST_TO_ADDR
// continue ;
35034: GO 34608
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35036: LD_EXP 79
35040: PUSH
35041: LD_VAR 0 2
35045: ARRAY
35046: PUSH
35047: LD_EXP 80
35051: PUSH
35052: LD_VAR 0 2
35056: ARRAY
35057: NOT
35058: AND
35059: IFFALSE 35186
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35061: LD_ADDR_EXP 80
35065: PUSH
35066: LD_EXP 80
35070: PPUSH
35071: LD_VAR 0 2
35075: PUSH
35076: LD_EXP 80
35080: PUSH
35081: LD_VAR 0 2
35085: ARRAY
35086: PUSH
35087: LD_INT 1
35089: PLUS
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PPUSH
35095: LD_EXP 79
35099: PUSH
35100: LD_VAR 0 2
35104: ARRAY
35105: PUSH
35106: LD_INT 1
35108: ARRAY
35109: PPUSH
35110: CALL 53394 0 3
35114: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35115: LD_EXP 79
35119: PUSH
35120: LD_VAR 0 2
35124: ARRAY
35125: PUSH
35126: LD_INT 1
35128: ARRAY
35129: PPUSH
35130: LD_INT 112
35132: PPUSH
35133: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35137: LD_ADDR_VAR 0 9
35141: PUSH
35142: LD_EXP 79
35146: PUSH
35147: LD_VAR 0 2
35151: ARRAY
35152: PPUSH
35153: LD_INT 1
35155: PPUSH
35156: CALL_OW 3
35160: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35161: LD_ADDR_EXP 79
35165: PUSH
35166: LD_EXP 79
35170: PPUSH
35171: LD_VAR 0 2
35175: PPUSH
35176: LD_VAR 0 9
35180: PPUSH
35181: CALL_OW 1
35185: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35186: LD_EXP 79
35190: PUSH
35191: LD_VAR 0 2
35195: ARRAY
35196: PUSH
35197: LD_EXP 80
35201: PUSH
35202: LD_VAR 0 2
35206: ARRAY
35207: AND
35208: PUSH
35209: LD_EXP 80
35213: PUSH
35214: LD_VAR 0 2
35218: ARRAY
35219: PUSH
35220: LD_INT 1
35222: ARRAY
35223: PPUSH
35224: CALL_OW 310
35228: NOT
35229: AND
35230: PUSH
35231: LD_VAR 0 3
35235: PPUSH
35236: CALL_OW 313
35240: PUSH
35241: LD_INT 6
35243: EQUAL
35244: AND
35245: IFFALSE 35301
// begin tmp2 := UnitsInside ( j ) ;
35247: LD_ADDR_VAR 0 9
35251: PUSH
35252: LD_VAR 0 3
35256: PPUSH
35257: CALL_OW 313
35261: ST_TO_ADDR
// if tmp2 = 6 then
35262: LD_VAR 0 9
35266: PUSH
35267: LD_INT 6
35269: EQUAL
35270: IFFALSE 35301
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35272: LD_VAR 0 9
35276: PUSH
35277: LD_INT 1
35279: ARRAY
35280: PPUSH
35281: LD_INT 112
35283: PPUSH
35284: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35288: LD_VAR 0 9
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PPUSH
35297: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35301: LD_EXP 80
35305: PUSH
35306: LD_VAR 0 2
35310: ARRAY
35311: PUSH
35312: LD_EXP 80
35316: PUSH
35317: LD_VAR 0 2
35321: ARRAY
35322: PUSH
35323: LD_INT 1
35325: ARRAY
35326: PPUSH
35327: CALL_OW 314
35331: NOT
35332: AND
35333: PUSH
35334: LD_EXP 80
35338: PUSH
35339: LD_VAR 0 2
35343: ARRAY
35344: PUSH
35345: LD_INT 1
35347: ARRAY
35348: PPUSH
35349: CALL_OW 310
35353: NOT
35354: AND
35355: IFFALSE 35381
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35357: LD_EXP 80
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_INT 1
35370: ARRAY
35371: PPUSH
35372: LD_VAR 0 3
35376: PPUSH
35377: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35381: LD_EXP 80
35385: PUSH
35386: LD_VAR 0 2
35390: ARRAY
35391: PUSH
35392: LD_INT 1
35394: ARRAY
35395: PPUSH
35396: CALL_OW 310
35400: PUSH
35401: LD_EXP 80
35405: PUSH
35406: LD_VAR 0 2
35410: ARRAY
35411: PUSH
35412: LD_INT 1
35414: ARRAY
35415: PPUSH
35416: CALL_OW 310
35420: PPUSH
35421: CALL_OW 461
35425: PUSH
35426: LD_INT 3
35428: NONEQUAL
35429: AND
35430: IFFALSE 35451
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35432: LD_EXP 80
35436: PUSH
35437: LD_VAR 0 2
35441: ARRAY
35442: PUSH
35443: LD_INT 1
35445: ARRAY
35446: PPUSH
35447: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35451: LD_VAR 0 3
35455: PPUSH
35456: CALL_OW 461
35460: PUSH
35461: LD_INT 6
35463: EQUAL
35464: PUSH
35465: LD_VAR 0 6
35469: PUSH
35470: LD_INT 1
35472: GREATER
35473: AND
35474: IFFALSE 35626
// begin sci := [ ] ;
35476: LD_ADDR_VAR 0 8
35480: PUSH
35481: EMPTY
35482: ST_TO_ADDR
// for x in ( tmp diff j ) do
35483: LD_ADDR_VAR 0 7
35487: PUSH
35488: LD_VAR 0 6
35492: PUSH
35493: LD_VAR 0 3
35497: DIFF
35498: PUSH
35499: FOR_IN
35500: IFFALSE 35552
// begin if sci = 6 then
35502: LD_VAR 0 8
35506: PUSH
35507: LD_INT 6
35509: EQUAL
35510: IFFALSE 35514
// break ;
35512: GO 35552
// if BuildingStatus ( x ) = bs_idle then
35514: LD_VAR 0 7
35518: PPUSH
35519: CALL_OW 461
35523: PUSH
35524: LD_INT 2
35526: EQUAL
35527: IFFALSE 35550
// sci := sci ^ UnitsInside ( x ) ;
35529: LD_ADDR_VAR 0 8
35533: PUSH
35534: LD_VAR 0 8
35538: PUSH
35539: LD_VAR 0 7
35543: PPUSH
35544: CALL_OW 313
35548: ADD
35549: ST_TO_ADDR
// end ;
35550: GO 35499
35552: POP
35553: POP
// if not sci then
35554: LD_VAR 0 8
35558: NOT
35559: IFFALSE 35563
// continue ;
35561: GO 34608
// for x in sci do
35563: LD_ADDR_VAR 0 7
35567: PUSH
35568: LD_VAR 0 8
35572: PUSH
35573: FOR_IN
35574: IFFALSE 35624
// if IsInUnit ( x ) and not HasTask ( x ) then
35576: LD_VAR 0 7
35580: PPUSH
35581: CALL_OW 310
35585: PUSH
35586: LD_VAR 0 7
35590: PPUSH
35591: CALL_OW 314
35595: NOT
35596: AND
35597: IFFALSE 35622
// begin ComExitBuilding ( x ) ;
35599: LD_VAR 0 7
35603: PPUSH
35604: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35608: LD_VAR 0 7
35612: PPUSH
35613: LD_VAR 0 3
35617: PPUSH
35618: CALL_OW 180
// end ;
35622: GO 35573
35624: POP
35625: POP
// end ; end ;
35626: GO 34608
35628: POP
35629: POP
// end ;
35630: GO 34562
35632: POP
35633: POP
// end ;
35634: LD_VAR 0 1
35638: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35639: LD_INT 0
35641: PPUSH
35642: PPUSH
// if not mc_bases then
35643: LD_EXP 50
35647: NOT
35648: IFFALSE 35652
// exit ;
35650: GO 35733
// for i = 1 to mc_bases do
35652: LD_ADDR_VAR 0 2
35656: PUSH
35657: DOUBLE
35658: LD_INT 1
35660: DEC
35661: ST_TO_ADDR
35662: LD_EXP 50
35666: PUSH
35667: FOR_TO
35668: IFFALSE 35731
// if mc_mines [ i ] and mc_miners [ i ] then
35670: LD_EXP 63
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: PUSH
35681: LD_EXP 64
35685: PUSH
35686: LD_VAR 0 2
35690: ARRAY
35691: AND
35692: IFFALSE 35729
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35694: LD_EXP 64
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 1
35707: ARRAY
35708: PPUSH
35709: CALL_OW 255
35713: PPUSH
35714: LD_EXP 63
35718: PUSH
35719: LD_VAR 0 2
35723: ARRAY
35724: PPUSH
35725: CALL 50347 0 2
35729: GO 35667
35731: POP
35732: POP
// end ;
35733: LD_VAR 0 1
35737: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35738: LD_INT 0
35740: PPUSH
35741: PPUSH
35742: PPUSH
35743: PPUSH
35744: PPUSH
35745: PPUSH
35746: PPUSH
35747: PPUSH
// if not mc_bases or not mc_parking then
35748: LD_EXP 50
35752: NOT
35753: PUSH
35754: LD_EXP 74
35758: NOT
35759: OR
35760: IFFALSE 35764
// exit ;
35762: GO 36474
// for i = 1 to mc_bases do
35764: LD_ADDR_VAR 0 2
35768: PUSH
35769: DOUBLE
35770: LD_INT 1
35772: DEC
35773: ST_TO_ADDR
35774: LD_EXP 50
35778: PUSH
35779: FOR_TO
35780: IFFALSE 36472
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35782: LD_EXP 50
35786: PUSH
35787: LD_VAR 0 2
35791: ARRAY
35792: NOT
35793: PUSH
35794: LD_EXP 74
35798: PUSH
35799: LD_VAR 0 2
35803: ARRAY
35804: NOT
35805: OR
35806: IFFALSE 35810
// continue ;
35808: GO 35779
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35810: LD_ADDR_VAR 0 5
35814: PUSH
35815: LD_EXP 50
35819: PUSH
35820: LD_VAR 0 2
35824: ARRAY
35825: PUSH
35826: LD_INT 1
35828: ARRAY
35829: PPUSH
35830: CALL_OW 255
35834: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35835: LD_ADDR_VAR 0 6
35839: PUSH
35840: LD_EXP 50
35844: PUSH
35845: LD_VAR 0 2
35849: ARRAY
35850: PPUSH
35851: LD_INT 30
35853: PUSH
35854: LD_INT 3
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PPUSH
35861: CALL_OW 72
35865: ST_TO_ADDR
// if not fac then
35866: LD_VAR 0 6
35870: NOT
35871: IFFALSE 35922
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35873: LD_ADDR_VAR 0 6
35877: PUSH
35878: LD_EXP 50
35882: PUSH
35883: LD_VAR 0 2
35887: ARRAY
35888: PPUSH
35889: LD_INT 2
35891: PUSH
35892: LD_INT 30
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 30
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: LIST
35916: PPUSH
35917: CALL_OW 72
35921: ST_TO_ADDR
// if not fac then
35922: LD_VAR 0 6
35926: NOT
35927: IFFALSE 35931
// continue ;
35929: GO 35779
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35931: LD_ADDR_VAR 0 7
35935: PUSH
35936: LD_EXP 74
35940: PUSH
35941: LD_VAR 0 2
35945: ARRAY
35946: PPUSH
35947: LD_INT 22
35949: PUSH
35950: LD_VAR 0 5
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 21
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 3
35971: PUSH
35972: LD_INT 24
35974: PUSH
35975: LD_INT 1000
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: LIST
35990: PPUSH
35991: CALL_OW 70
35995: ST_TO_ADDR
// for j in fac do
35996: LD_ADDR_VAR 0 3
36000: PUSH
36001: LD_VAR 0 6
36005: PUSH
36006: FOR_IN
36007: IFFALSE 36088
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36009: LD_ADDR_VAR 0 7
36013: PUSH
36014: LD_VAR 0 7
36018: PUSH
36019: LD_INT 22
36021: PUSH
36022: LD_VAR 0 5
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 91
36033: PUSH
36034: LD_VAR 0 3
36038: PUSH
36039: LD_INT 15
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 21
36049: PUSH
36050: LD_INT 2
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 3
36059: PUSH
36060: LD_INT 24
36062: PUSH
36063: LD_INT 1000
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: PPUSH
36080: CALL_OW 69
36084: UNION
36085: ST_TO_ADDR
36086: GO 36006
36088: POP
36089: POP
// if not vehs then
36090: LD_VAR 0 7
36094: NOT
36095: IFFALSE 36121
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36097: LD_ADDR_EXP 62
36101: PUSH
36102: LD_EXP 62
36106: PPUSH
36107: LD_VAR 0 2
36111: PPUSH
36112: EMPTY
36113: PPUSH
36114: CALL_OW 1
36118: ST_TO_ADDR
// continue ;
36119: GO 35779
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36121: LD_ADDR_VAR 0 8
36125: PUSH
36126: LD_EXP 50
36130: PUSH
36131: LD_VAR 0 2
36135: ARRAY
36136: PPUSH
36137: LD_INT 30
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PPUSH
36147: CALL_OW 72
36151: ST_TO_ADDR
// if tmp then
36152: LD_VAR 0 8
36156: IFFALSE 36259
// begin for j in tmp do
36158: LD_ADDR_VAR 0 3
36162: PUSH
36163: LD_VAR 0 8
36167: PUSH
36168: FOR_IN
36169: IFFALSE 36257
// for k in UnitsInside ( j ) do
36171: LD_ADDR_VAR 0 4
36175: PUSH
36176: LD_VAR 0 3
36180: PPUSH
36181: CALL_OW 313
36185: PUSH
36186: FOR_IN
36187: IFFALSE 36253
// if k then
36189: LD_VAR 0 4
36193: IFFALSE 36251
// if not k in mc_repair_vehicle [ i ] then
36195: LD_VAR 0 4
36199: PUSH
36200: LD_EXP 62
36204: PUSH
36205: LD_VAR 0 2
36209: ARRAY
36210: IN
36211: NOT
36212: IFFALSE 36251
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36214: LD_ADDR_EXP 62
36218: PUSH
36219: LD_EXP 62
36223: PPUSH
36224: LD_VAR 0 2
36228: PPUSH
36229: LD_EXP 62
36233: PUSH
36234: LD_VAR 0 2
36238: ARRAY
36239: PUSH
36240: LD_VAR 0 4
36244: UNION
36245: PPUSH
36246: CALL_OW 1
36250: ST_TO_ADDR
36251: GO 36186
36253: POP
36254: POP
36255: GO 36168
36257: POP
36258: POP
// end ; if not mc_repair_vehicle [ i ] then
36259: LD_EXP 62
36263: PUSH
36264: LD_VAR 0 2
36268: ARRAY
36269: NOT
36270: IFFALSE 36274
// continue ;
36272: GO 35779
// for j in mc_repair_vehicle [ i ] do
36274: LD_ADDR_VAR 0 3
36278: PUSH
36279: LD_EXP 62
36283: PUSH
36284: LD_VAR 0 2
36288: ARRAY
36289: PUSH
36290: FOR_IN
36291: IFFALSE 36468
// begin if GetClass ( j ) <> 3 then
36293: LD_VAR 0 3
36297: PPUSH
36298: CALL_OW 257
36302: PUSH
36303: LD_INT 3
36305: NONEQUAL
36306: IFFALSE 36347
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36308: LD_ADDR_EXP 62
36312: PUSH
36313: LD_EXP 62
36317: PPUSH
36318: LD_VAR 0 2
36322: PPUSH
36323: LD_EXP 62
36327: PUSH
36328: LD_VAR 0 2
36332: ARRAY
36333: PUSH
36334: LD_VAR 0 3
36338: DIFF
36339: PPUSH
36340: CALL_OW 1
36344: ST_TO_ADDR
// continue ;
36345: GO 36290
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36347: LD_VAR 0 3
36351: PPUSH
36352: CALL_OW 311
36356: NOT
36357: PUSH
36358: LD_VAR 0 3
36362: PUSH
36363: LD_EXP 53
36367: PUSH
36368: LD_VAR 0 2
36372: ARRAY
36373: PUSH
36374: LD_INT 1
36376: ARRAY
36377: IN
36378: NOT
36379: AND
36380: PUSH
36381: LD_VAR 0 3
36385: PUSH
36386: LD_EXP 53
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PUSH
36397: LD_INT 2
36399: ARRAY
36400: IN
36401: NOT
36402: AND
36403: IFFALSE 36466
// begin if IsInUnit ( j ) then
36405: LD_VAR 0 3
36409: PPUSH
36410: CALL_OW 310
36414: IFFALSE 36427
// ComExitBuilding ( j ) else
36416: LD_VAR 0 3
36420: PPUSH
36421: CALL_OW 122
36425: GO 36466
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36427: LD_VAR 0 3
36431: PPUSH
36432: LD_VAR 0 7
36436: PUSH
36437: LD_INT 1
36439: ARRAY
36440: PPUSH
36441: CALL 87001 0 2
36445: NOT
36446: IFFALSE 36466
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36448: LD_VAR 0 3
36452: PPUSH
36453: LD_VAR 0 7
36457: PUSH
36458: LD_INT 1
36460: ARRAY
36461: PPUSH
36462: CALL_OW 129
// end ; end ;
36466: GO 36290
36468: POP
36469: POP
// end ;
36470: GO 35779
36472: POP
36473: POP
// end ;
36474: LD_VAR 0 1
36478: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36479: LD_INT 0
36481: PPUSH
36482: PPUSH
36483: PPUSH
36484: PPUSH
36485: PPUSH
36486: PPUSH
36487: PPUSH
36488: PPUSH
36489: PPUSH
36490: PPUSH
36491: PPUSH
// if not mc_bases then
36492: LD_EXP 50
36496: NOT
36497: IFFALSE 36501
// exit ;
36499: GO 37303
// for i = 1 to mc_bases do
36501: LD_ADDR_VAR 0 2
36505: PUSH
36506: DOUBLE
36507: LD_INT 1
36509: DEC
36510: ST_TO_ADDR
36511: LD_EXP 50
36515: PUSH
36516: FOR_TO
36517: IFFALSE 37301
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36519: LD_EXP 78
36523: PUSH
36524: LD_VAR 0 2
36528: ARRAY
36529: NOT
36530: PUSH
36531: LD_EXP 53
36535: PUSH
36536: LD_VAR 0 2
36540: ARRAY
36541: PUSH
36542: LD_INT 1
36544: ARRAY
36545: OR
36546: PUSH
36547: LD_EXP 53
36551: PUSH
36552: LD_VAR 0 2
36556: ARRAY
36557: PUSH
36558: LD_INT 2
36560: ARRAY
36561: OR
36562: PUSH
36563: LD_EXP 76
36567: PUSH
36568: LD_VAR 0 2
36572: ARRAY
36573: PPUSH
36574: LD_INT 1
36576: PPUSH
36577: CALL_OW 325
36581: NOT
36582: OR
36583: PUSH
36584: LD_EXP 73
36588: PUSH
36589: LD_VAR 0 2
36593: ARRAY
36594: OR
36595: IFFALSE 36599
// continue ;
36597: GO 36516
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36599: LD_ADDR_VAR 0 8
36603: PUSH
36604: LD_EXP 50
36608: PUSH
36609: LD_VAR 0 2
36613: ARRAY
36614: PPUSH
36615: LD_INT 25
36617: PUSH
36618: LD_INT 4
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 50
36627: PUSH
36628: EMPTY
36629: LIST
36630: PUSH
36631: LD_INT 3
36633: PUSH
36634: LD_INT 60
36636: PUSH
36637: EMPTY
36638: LIST
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: LIST
36648: PPUSH
36649: CALL_OW 72
36653: PUSH
36654: LD_EXP 54
36658: PUSH
36659: LD_VAR 0 2
36663: ARRAY
36664: DIFF
36665: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36666: LD_ADDR_VAR 0 9
36670: PUSH
36671: LD_EXP 50
36675: PUSH
36676: LD_VAR 0 2
36680: ARRAY
36681: PPUSH
36682: LD_INT 2
36684: PUSH
36685: LD_INT 30
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 30
36697: PUSH
36698: LD_INT 1
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: LIST
36709: PPUSH
36710: CALL_OW 72
36714: ST_TO_ADDR
// if not tmp or not dep then
36715: LD_VAR 0 8
36719: NOT
36720: PUSH
36721: LD_VAR 0 9
36725: NOT
36726: OR
36727: IFFALSE 36731
// continue ;
36729: GO 36516
// side := GetSide ( tmp [ 1 ] ) ;
36731: LD_ADDR_VAR 0 11
36735: PUSH
36736: LD_VAR 0 8
36740: PUSH
36741: LD_INT 1
36743: ARRAY
36744: PPUSH
36745: CALL_OW 255
36749: ST_TO_ADDR
// dep := dep [ 1 ] ;
36750: LD_ADDR_VAR 0 9
36754: PUSH
36755: LD_VAR 0 9
36759: PUSH
36760: LD_INT 1
36762: ARRAY
36763: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36764: LD_ADDR_VAR 0 7
36768: PUSH
36769: LD_EXP 78
36773: PUSH
36774: LD_VAR 0 2
36778: ARRAY
36779: PPUSH
36780: LD_INT 22
36782: PUSH
36783: LD_INT 0
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 25
36792: PUSH
36793: LD_INT 12
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PPUSH
36804: CALL_OW 70
36808: PUSH
36809: LD_INT 22
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 25
36821: PUSH
36822: LD_INT 12
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 91
36831: PUSH
36832: LD_VAR 0 9
36836: PUSH
36837: LD_INT 20
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: LIST
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: LIST
36849: PPUSH
36850: CALL_OW 69
36854: UNION
36855: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36856: LD_ADDR_VAR 0 10
36860: PUSH
36861: LD_EXP 78
36865: PUSH
36866: LD_VAR 0 2
36870: ARRAY
36871: PPUSH
36872: LD_INT 81
36874: PUSH
36875: LD_VAR 0 11
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 70
36888: ST_TO_ADDR
// if not apes or danger_at_area then
36889: LD_VAR 0 7
36893: NOT
36894: PUSH
36895: LD_VAR 0 10
36899: OR
36900: IFFALSE 36950
// begin if mc_taming [ i ] then
36902: LD_EXP 81
36906: PUSH
36907: LD_VAR 0 2
36911: ARRAY
36912: IFFALSE 36948
// begin MC_Reset ( i , 121 ) ;
36914: LD_VAR 0 2
36918: PPUSH
36919: LD_INT 121
36921: PPUSH
36922: CALL 22083 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36926: LD_ADDR_EXP 81
36930: PUSH
36931: LD_EXP 81
36935: PPUSH
36936: LD_VAR 0 2
36940: PPUSH
36941: EMPTY
36942: PPUSH
36943: CALL_OW 1
36947: ST_TO_ADDR
// end ; continue ;
36948: GO 36516
// end ; for j in tmp do
36950: LD_ADDR_VAR 0 3
36954: PUSH
36955: LD_VAR 0 8
36959: PUSH
36960: FOR_IN
36961: IFFALSE 37297
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36963: LD_VAR 0 3
36967: PUSH
36968: LD_EXP 81
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: IN
36979: NOT
36980: PUSH
36981: LD_EXP 81
36985: PUSH
36986: LD_VAR 0 2
36990: ARRAY
36991: PUSH
36992: LD_INT 3
36994: LESS
36995: AND
36996: IFFALSE 37054
// begin SetTag ( j , 121 ) ;
36998: LD_VAR 0 3
37002: PPUSH
37003: LD_INT 121
37005: PPUSH
37006: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37010: LD_ADDR_EXP 81
37014: PUSH
37015: LD_EXP 81
37019: PPUSH
37020: LD_VAR 0 2
37024: PUSH
37025: LD_EXP 81
37029: PUSH
37030: LD_VAR 0 2
37034: ARRAY
37035: PUSH
37036: LD_INT 1
37038: PLUS
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PPUSH
37044: LD_VAR 0 3
37048: PPUSH
37049: CALL 53394 0 3
37053: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37054: LD_VAR 0 3
37058: PUSH
37059: LD_EXP 81
37063: PUSH
37064: LD_VAR 0 2
37068: ARRAY
37069: IN
37070: IFFALSE 37295
// begin if GetClass ( j ) <> 4 then
37072: LD_VAR 0 3
37076: PPUSH
37077: CALL_OW 257
37081: PUSH
37082: LD_INT 4
37084: NONEQUAL
37085: IFFALSE 37138
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37087: LD_ADDR_EXP 81
37091: PUSH
37092: LD_EXP 81
37096: PPUSH
37097: LD_VAR 0 2
37101: PPUSH
37102: LD_EXP 81
37106: PUSH
37107: LD_VAR 0 2
37111: ARRAY
37112: PUSH
37113: LD_VAR 0 3
37117: DIFF
37118: PPUSH
37119: CALL_OW 1
37123: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37124: LD_VAR 0 3
37128: PPUSH
37129: LD_INT 0
37131: PPUSH
37132: CALL_OW 109
// continue ;
37136: GO 36960
// end ; if IsInUnit ( j ) then
37138: LD_VAR 0 3
37142: PPUSH
37143: CALL_OW 310
37147: IFFALSE 37158
// ComExitBuilding ( j ) ;
37149: LD_VAR 0 3
37153: PPUSH
37154: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37158: LD_ADDR_VAR 0 6
37162: PUSH
37163: LD_VAR 0 7
37167: PPUSH
37168: LD_VAR 0 3
37172: PPUSH
37173: CALL_OW 74
37177: ST_TO_ADDR
// if not ape then
37178: LD_VAR 0 6
37182: NOT
37183: IFFALSE 37187
// break ;
37185: GO 37297
// x := GetX ( ape ) ;
37187: LD_ADDR_VAR 0 4
37191: PUSH
37192: LD_VAR 0 6
37196: PPUSH
37197: CALL_OW 250
37201: ST_TO_ADDR
// y := GetY ( ape ) ;
37202: LD_ADDR_VAR 0 5
37206: PUSH
37207: LD_VAR 0 6
37211: PPUSH
37212: CALL_OW 251
37216: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37217: LD_VAR 0 4
37221: PPUSH
37222: LD_VAR 0 5
37226: PPUSH
37227: CALL_OW 488
37231: NOT
37232: PUSH
37233: LD_VAR 0 11
37237: PPUSH
37238: LD_VAR 0 4
37242: PPUSH
37243: LD_VAR 0 5
37247: PPUSH
37248: LD_INT 20
37250: PPUSH
37251: CALL 54290 0 4
37255: PUSH
37256: LD_INT 4
37258: ARRAY
37259: OR
37260: IFFALSE 37264
// break ;
37262: GO 37297
// if not HasTask ( j ) then
37264: LD_VAR 0 3
37268: PPUSH
37269: CALL_OW 314
37273: NOT
37274: IFFALSE 37295
// ComTameXY ( j , x , y ) ;
37276: LD_VAR 0 3
37280: PPUSH
37281: LD_VAR 0 4
37285: PPUSH
37286: LD_VAR 0 5
37290: PPUSH
37291: CALL_OW 131
// end ; end ;
37295: GO 36960
37297: POP
37298: POP
// end ;
37299: GO 36516
37301: POP
37302: POP
// end ;
37303: LD_VAR 0 1
37307: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37308: LD_INT 0
37310: PPUSH
37311: PPUSH
37312: PPUSH
37313: PPUSH
37314: PPUSH
37315: PPUSH
37316: PPUSH
37317: PPUSH
// if not mc_bases then
37318: LD_EXP 50
37322: NOT
37323: IFFALSE 37327
// exit ;
37325: GO 37953
// for i = 1 to mc_bases do
37327: LD_ADDR_VAR 0 2
37331: PUSH
37332: DOUBLE
37333: LD_INT 1
37335: DEC
37336: ST_TO_ADDR
37337: LD_EXP 50
37341: PUSH
37342: FOR_TO
37343: IFFALSE 37951
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37345: LD_EXP 79
37349: PUSH
37350: LD_VAR 0 2
37354: ARRAY
37355: NOT
37356: PUSH
37357: LD_EXP 79
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PPUSH
37368: LD_INT 25
37370: PUSH
37371: LD_INT 12
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PPUSH
37378: CALL_OW 72
37382: NOT
37383: OR
37384: IFFALSE 37388
// continue ;
37386: GO 37342
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37388: LD_ADDR_VAR 0 5
37392: PUSH
37393: LD_EXP 79
37397: PUSH
37398: LD_VAR 0 2
37402: ARRAY
37403: PUSH
37404: LD_INT 1
37406: ARRAY
37407: PPUSH
37408: CALL_OW 255
37412: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37413: LD_VAR 0 5
37417: PPUSH
37418: LD_INT 2
37420: PPUSH
37421: CALL_OW 325
37425: IFFALSE 37678
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37427: LD_ADDR_VAR 0 4
37431: PUSH
37432: LD_EXP 79
37436: PUSH
37437: LD_VAR 0 2
37441: ARRAY
37442: PPUSH
37443: LD_INT 25
37445: PUSH
37446: LD_INT 16
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PPUSH
37453: CALL_OW 72
37457: ST_TO_ADDR
// if tmp < 6 then
37458: LD_VAR 0 4
37462: PUSH
37463: LD_INT 6
37465: LESS
37466: IFFALSE 37678
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37468: LD_ADDR_VAR 0 6
37472: PUSH
37473: LD_EXP 50
37477: PUSH
37478: LD_VAR 0 2
37482: ARRAY
37483: PPUSH
37484: LD_INT 2
37486: PUSH
37487: LD_INT 30
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 30
37499: PUSH
37500: LD_INT 1
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: PPUSH
37512: CALL_OW 72
37516: ST_TO_ADDR
// if depot then
37517: LD_VAR 0 6
37521: IFFALSE 37678
// begin selected := 0 ;
37523: LD_ADDR_VAR 0 7
37527: PUSH
37528: LD_INT 0
37530: ST_TO_ADDR
// for j in depot do
37531: LD_ADDR_VAR 0 3
37535: PUSH
37536: LD_VAR 0 6
37540: PUSH
37541: FOR_IN
37542: IFFALSE 37573
// begin if UnitsInside ( j ) < 6 then
37544: LD_VAR 0 3
37548: PPUSH
37549: CALL_OW 313
37553: PUSH
37554: LD_INT 6
37556: LESS
37557: IFFALSE 37571
// begin selected := j ;
37559: LD_ADDR_VAR 0 7
37563: PUSH
37564: LD_VAR 0 3
37568: ST_TO_ADDR
// break ;
37569: GO 37573
// end ; end ;
37571: GO 37541
37573: POP
37574: POP
// if selected then
37575: LD_VAR 0 7
37579: IFFALSE 37678
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37581: LD_ADDR_VAR 0 3
37585: PUSH
37586: LD_EXP 79
37590: PUSH
37591: LD_VAR 0 2
37595: ARRAY
37596: PPUSH
37597: LD_INT 25
37599: PUSH
37600: LD_INT 12
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PPUSH
37607: CALL_OW 72
37611: PUSH
37612: FOR_IN
37613: IFFALSE 37676
// if not HasTask ( j ) then
37615: LD_VAR 0 3
37619: PPUSH
37620: CALL_OW 314
37624: NOT
37625: IFFALSE 37674
// begin if not IsInUnit ( j ) then
37627: LD_VAR 0 3
37631: PPUSH
37632: CALL_OW 310
37636: NOT
37637: IFFALSE 37653
// ComEnterUnit ( j , selected ) ;
37639: LD_VAR 0 3
37643: PPUSH
37644: LD_VAR 0 7
37648: PPUSH
37649: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37653: LD_VAR 0 3
37657: PPUSH
37658: LD_INT 16
37660: PPUSH
37661: CALL_OW 183
// AddComExitBuilding ( j ) ;
37665: LD_VAR 0 3
37669: PPUSH
37670: CALL_OW 182
// end ;
37674: GO 37612
37676: POP
37677: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37678: LD_VAR 0 5
37682: PPUSH
37683: LD_INT 11
37685: PPUSH
37686: CALL_OW 325
37690: IFFALSE 37949
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37692: LD_ADDR_VAR 0 4
37696: PUSH
37697: LD_EXP 79
37701: PUSH
37702: LD_VAR 0 2
37706: ARRAY
37707: PPUSH
37708: LD_INT 25
37710: PUSH
37711: LD_INT 16
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PPUSH
37718: CALL_OW 72
37722: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37723: LD_VAR 0 4
37727: PUSH
37728: LD_INT 6
37730: GREATEREQUAL
37731: PUSH
37732: LD_VAR 0 5
37736: PPUSH
37737: LD_INT 2
37739: PPUSH
37740: CALL_OW 325
37744: NOT
37745: OR
37746: IFFALSE 37949
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37748: LD_ADDR_VAR 0 8
37752: PUSH
37753: LD_EXP 50
37757: PUSH
37758: LD_VAR 0 2
37762: ARRAY
37763: PPUSH
37764: LD_INT 2
37766: PUSH
37767: LD_INT 30
37769: PUSH
37770: LD_INT 4
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 30
37779: PUSH
37780: LD_INT 5
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: LIST
37791: PPUSH
37792: CALL_OW 72
37796: ST_TO_ADDR
// if barracks then
37797: LD_VAR 0 8
37801: IFFALSE 37949
// begin selected := 0 ;
37803: LD_ADDR_VAR 0 7
37807: PUSH
37808: LD_INT 0
37810: ST_TO_ADDR
// for j in barracks do
37811: LD_ADDR_VAR 0 3
37815: PUSH
37816: LD_VAR 0 8
37820: PUSH
37821: FOR_IN
37822: IFFALSE 37853
// begin if UnitsInside ( j ) < 6 then
37824: LD_VAR 0 3
37828: PPUSH
37829: CALL_OW 313
37833: PUSH
37834: LD_INT 6
37836: LESS
37837: IFFALSE 37851
// begin selected := j ;
37839: LD_ADDR_VAR 0 7
37843: PUSH
37844: LD_VAR 0 3
37848: ST_TO_ADDR
// break ;
37849: GO 37853
// end ; end ;
37851: GO 37821
37853: POP
37854: POP
// if selected then
37855: LD_VAR 0 7
37859: IFFALSE 37949
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37861: LD_ADDR_VAR 0 3
37865: PUSH
37866: LD_EXP 79
37870: PUSH
37871: LD_VAR 0 2
37875: ARRAY
37876: PPUSH
37877: LD_INT 25
37879: PUSH
37880: LD_INT 12
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PPUSH
37887: CALL_OW 72
37891: PUSH
37892: FOR_IN
37893: IFFALSE 37947
// if not IsInUnit ( j ) and not HasTask ( j ) then
37895: LD_VAR 0 3
37899: PPUSH
37900: CALL_OW 310
37904: NOT
37905: PUSH
37906: LD_VAR 0 3
37910: PPUSH
37911: CALL_OW 314
37915: NOT
37916: AND
37917: IFFALSE 37945
// begin ComEnterUnit ( j , selected ) ;
37919: LD_VAR 0 3
37923: PPUSH
37924: LD_VAR 0 7
37928: PPUSH
37929: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37933: LD_VAR 0 3
37937: PPUSH
37938: LD_INT 15
37940: PPUSH
37941: CALL_OW 183
// end ;
37945: GO 37892
37947: POP
37948: POP
// end ; end ; end ; end ; end ;
37949: GO 37342
37951: POP
37952: POP
// end ;
37953: LD_VAR 0 1
37957: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37958: LD_INT 0
37960: PPUSH
37961: PPUSH
37962: PPUSH
37963: PPUSH
// if not mc_bases then
37964: LD_EXP 50
37968: NOT
37969: IFFALSE 37973
// exit ;
37971: GO 38151
// for i = 1 to mc_bases do
37973: LD_ADDR_VAR 0 2
37977: PUSH
37978: DOUBLE
37979: LD_INT 1
37981: DEC
37982: ST_TO_ADDR
37983: LD_EXP 50
37987: PUSH
37988: FOR_TO
37989: IFFALSE 38149
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37991: LD_ADDR_VAR 0 4
37995: PUSH
37996: LD_EXP 50
38000: PUSH
38001: LD_VAR 0 2
38005: ARRAY
38006: PPUSH
38007: LD_INT 25
38009: PUSH
38010: LD_INT 9
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PPUSH
38017: CALL_OW 72
38021: ST_TO_ADDR
// if not tmp then
38022: LD_VAR 0 4
38026: NOT
38027: IFFALSE 38031
// continue ;
38029: GO 37988
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38031: LD_EXP 76
38035: PUSH
38036: LD_VAR 0 2
38040: ARRAY
38041: PPUSH
38042: LD_INT 29
38044: PPUSH
38045: CALL_OW 325
38049: NOT
38050: PUSH
38051: LD_EXP 76
38055: PUSH
38056: LD_VAR 0 2
38060: ARRAY
38061: PPUSH
38062: LD_INT 28
38064: PPUSH
38065: CALL_OW 325
38069: NOT
38070: AND
38071: IFFALSE 38075
// continue ;
38073: GO 37988
// for j in tmp do
38075: LD_ADDR_VAR 0 3
38079: PUSH
38080: LD_VAR 0 4
38084: PUSH
38085: FOR_IN
38086: IFFALSE 38145
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38088: LD_VAR 0 3
38092: PUSH
38093: LD_EXP 53
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: PUSH
38104: LD_INT 1
38106: ARRAY
38107: IN
38108: NOT
38109: PUSH
38110: LD_VAR 0 3
38114: PUSH
38115: LD_EXP 53
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: PUSH
38126: LD_INT 2
38128: ARRAY
38129: IN
38130: NOT
38131: AND
38132: IFFALSE 38143
// ComSpaceTimeShoot ( j ) ;
38134: LD_VAR 0 3
38138: PPUSH
38139: CALL 49355 0 1
38143: GO 38085
38145: POP
38146: POP
// end ;
38147: GO 37988
38149: POP
38150: POP
// end ;
38151: LD_VAR 0 1
38155: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38156: LD_INT 0
38158: PPUSH
38159: PPUSH
38160: PPUSH
38161: PPUSH
38162: PPUSH
38163: PPUSH
38164: PPUSH
38165: PPUSH
38166: PPUSH
// if not mc_bases then
38167: LD_EXP 50
38171: NOT
38172: IFFALSE 38176
// exit ;
38174: GO 38798
// for i = 1 to mc_bases do
38176: LD_ADDR_VAR 0 2
38180: PUSH
38181: DOUBLE
38182: LD_INT 1
38184: DEC
38185: ST_TO_ADDR
38186: LD_EXP 50
38190: PUSH
38191: FOR_TO
38192: IFFALSE 38796
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38194: LD_EXP 85
38198: PUSH
38199: LD_VAR 0 2
38203: ARRAY
38204: NOT
38205: PUSH
38206: LD_INT 38
38208: PPUSH
38209: LD_EXP 76
38213: PUSH
38214: LD_VAR 0 2
38218: ARRAY
38219: PPUSH
38220: CALL_OW 321
38224: PUSH
38225: LD_INT 2
38227: NONEQUAL
38228: OR
38229: IFFALSE 38233
// continue ;
38231: GO 38191
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38233: LD_ADDR_VAR 0 8
38237: PUSH
38238: LD_EXP 50
38242: PUSH
38243: LD_VAR 0 2
38247: ARRAY
38248: PPUSH
38249: LD_INT 30
38251: PUSH
38252: LD_INT 34
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PPUSH
38259: CALL_OW 72
38263: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38264: LD_ADDR_VAR 0 9
38268: PUSH
38269: LD_EXP 50
38273: PUSH
38274: LD_VAR 0 2
38278: ARRAY
38279: PPUSH
38280: LD_INT 25
38282: PUSH
38283: LD_INT 4
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PPUSH
38290: CALL_OW 72
38294: PPUSH
38295: LD_INT 0
38297: PPUSH
38298: CALL 82663 0 2
38302: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38303: LD_VAR 0 9
38307: NOT
38308: PUSH
38309: LD_VAR 0 8
38313: NOT
38314: OR
38315: PUSH
38316: LD_EXP 50
38320: PUSH
38321: LD_VAR 0 2
38325: ARRAY
38326: PPUSH
38327: LD_INT 124
38329: PPUSH
38330: CALL 82663 0 2
38334: OR
38335: IFFALSE 38339
// continue ;
38337: GO 38191
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38339: LD_EXP 86
38343: PUSH
38344: LD_VAR 0 2
38348: ARRAY
38349: PUSH
38350: LD_EXP 85
38354: PUSH
38355: LD_VAR 0 2
38359: ARRAY
38360: LESS
38361: PUSH
38362: LD_EXP 86
38366: PUSH
38367: LD_VAR 0 2
38371: ARRAY
38372: PUSH
38373: LD_VAR 0 8
38377: LESS
38378: AND
38379: IFFALSE 38794
// begin tmp := sci [ 1 ] ;
38381: LD_ADDR_VAR 0 7
38385: PUSH
38386: LD_VAR 0 9
38390: PUSH
38391: LD_INT 1
38393: ARRAY
38394: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38395: LD_VAR 0 7
38399: PPUSH
38400: LD_INT 124
38402: PPUSH
38403: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38407: LD_ADDR_VAR 0 3
38411: PUSH
38412: DOUBLE
38413: LD_EXP 85
38417: PUSH
38418: LD_VAR 0 2
38422: ARRAY
38423: INC
38424: ST_TO_ADDR
38425: LD_EXP 85
38429: PUSH
38430: LD_VAR 0 2
38434: ARRAY
38435: PUSH
38436: FOR_DOWNTO
38437: IFFALSE 38780
// begin if IsInUnit ( tmp ) then
38439: LD_VAR 0 7
38443: PPUSH
38444: CALL_OW 310
38448: IFFALSE 38459
// ComExitBuilding ( tmp ) ;
38450: LD_VAR 0 7
38454: PPUSH
38455: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38459: LD_INT 35
38461: PPUSH
38462: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38466: LD_VAR 0 7
38470: PPUSH
38471: CALL_OW 310
38475: NOT
38476: PUSH
38477: LD_VAR 0 7
38481: PPUSH
38482: CALL_OW 314
38486: NOT
38487: AND
38488: IFFALSE 38459
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38490: LD_ADDR_VAR 0 6
38494: PUSH
38495: LD_VAR 0 7
38499: PPUSH
38500: CALL_OW 250
38504: PUSH
38505: LD_VAR 0 7
38509: PPUSH
38510: CALL_OW 251
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38519: LD_INT 35
38521: PPUSH
38522: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38526: LD_ADDR_VAR 0 4
38530: PUSH
38531: LD_EXP 85
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PUSH
38542: LD_VAR 0 3
38546: ARRAY
38547: PUSH
38548: LD_INT 1
38550: ARRAY
38551: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38552: LD_ADDR_VAR 0 5
38556: PUSH
38557: LD_EXP 85
38561: PUSH
38562: LD_VAR 0 2
38566: ARRAY
38567: PUSH
38568: LD_VAR 0 3
38572: ARRAY
38573: PUSH
38574: LD_INT 2
38576: ARRAY
38577: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38578: LD_VAR 0 7
38582: PPUSH
38583: LD_INT 10
38585: PPUSH
38586: CALL 55993 0 2
38590: PUSH
38591: LD_INT 4
38593: ARRAY
38594: IFFALSE 38632
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38596: LD_VAR 0 7
38600: PPUSH
38601: LD_VAR 0 6
38605: PUSH
38606: LD_INT 1
38608: ARRAY
38609: PPUSH
38610: LD_VAR 0 6
38614: PUSH
38615: LD_INT 2
38617: ARRAY
38618: PPUSH
38619: CALL_OW 111
// wait ( 0 0$10 ) ;
38623: LD_INT 350
38625: PPUSH
38626: CALL_OW 67
// end else
38630: GO 38658
// begin ComMoveXY ( tmp , x , y ) ;
38632: LD_VAR 0 7
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: LD_VAR 0 5
38646: PPUSH
38647: CALL_OW 111
// wait ( 0 0$3 ) ;
38651: LD_INT 105
38653: PPUSH
38654: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38658: LD_VAR 0 7
38662: PPUSH
38663: LD_VAR 0 4
38667: PPUSH
38668: LD_VAR 0 5
38672: PPUSH
38673: CALL_OW 307
38677: IFFALSE 38519
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38679: LD_VAR 0 7
38683: PPUSH
38684: LD_VAR 0 4
38688: PPUSH
38689: LD_VAR 0 5
38693: PPUSH
38694: LD_VAR 0 8
38698: PUSH
38699: LD_VAR 0 3
38703: ARRAY
38704: PPUSH
38705: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38709: LD_INT 35
38711: PPUSH
38712: CALL_OW 67
// until not HasTask ( tmp ) ;
38716: LD_VAR 0 7
38720: PPUSH
38721: CALL_OW 314
38725: NOT
38726: IFFALSE 38709
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38728: LD_ADDR_EXP 86
38732: PUSH
38733: LD_EXP 86
38737: PPUSH
38738: LD_VAR 0 2
38742: PUSH
38743: LD_EXP 86
38747: PUSH
38748: LD_VAR 0 2
38752: ARRAY
38753: PUSH
38754: LD_INT 1
38756: PLUS
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PPUSH
38762: LD_VAR 0 8
38766: PUSH
38767: LD_VAR 0 3
38771: ARRAY
38772: PPUSH
38773: CALL 53394 0 3
38777: ST_TO_ADDR
// end ;
38778: GO 38436
38780: POP
38781: POP
// MC_Reset ( i , 124 ) ;
38782: LD_VAR 0 2
38786: PPUSH
38787: LD_INT 124
38789: PPUSH
38790: CALL 22083 0 2
// end ; end ;
38794: GO 38191
38796: POP
38797: POP
// end ;
38798: LD_VAR 0 1
38802: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38803: LD_INT 0
38805: PPUSH
38806: PPUSH
38807: PPUSH
// if not mc_bases then
38808: LD_EXP 50
38812: NOT
38813: IFFALSE 38817
// exit ;
38815: GO 39423
// for i = 1 to mc_bases do
38817: LD_ADDR_VAR 0 2
38821: PUSH
38822: DOUBLE
38823: LD_INT 1
38825: DEC
38826: ST_TO_ADDR
38827: LD_EXP 50
38831: PUSH
38832: FOR_TO
38833: IFFALSE 39421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38835: LD_ADDR_VAR 0 3
38839: PUSH
38840: LD_EXP 50
38844: PUSH
38845: LD_VAR 0 2
38849: ARRAY
38850: PPUSH
38851: LD_INT 25
38853: PUSH
38854: LD_INT 4
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PPUSH
38861: CALL_OW 72
38865: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38866: LD_VAR 0 3
38870: NOT
38871: PUSH
38872: LD_EXP 87
38876: PUSH
38877: LD_VAR 0 2
38881: ARRAY
38882: NOT
38883: OR
38884: PUSH
38885: LD_EXP 50
38889: PUSH
38890: LD_VAR 0 2
38894: ARRAY
38895: PPUSH
38896: LD_INT 2
38898: PUSH
38899: LD_INT 30
38901: PUSH
38902: LD_INT 0
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 30
38911: PUSH
38912: LD_INT 1
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: LIST
38923: PPUSH
38924: CALL_OW 72
38928: NOT
38929: OR
38930: IFFALSE 38980
// begin if mc_deposits_finder [ i ] then
38932: LD_EXP 88
38936: PUSH
38937: LD_VAR 0 2
38941: ARRAY
38942: IFFALSE 38978
// begin MC_Reset ( i , 125 ) ;
38944: LD_VAR 0 2
38948: PPUSH
38949: LD_INT 125
38951: PPUSH
38952: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38956: LD_ADDR_EXP 88
38960: PUSH
38961: LD_EXP 88
38965: PPUSH
38966: LD_VAR 0 2
38970: PPUSH
38971: EMPTY
38972: PPUSH
38973: CALL_OW 1
38977: ST_TO_ADDR
// end ; continue ;
38978: GO 38832
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38980: LD_EXP 87
38984: PUSH
38985: LD_VAR 0 2
38989: ARRAY
38990: PUSH
38991: LD_INT 1
38993: ARRAY
38994: PUSH
38995: LD_INT 3
38997: ARRAY
38998: PUSH
38999: LD_INT 1
39001: EQUAL
39002: PUSH
39003: LD_INT 20
39005: PPUSH
39006: LD_EXP 76
39010: PUSH
39011: LD_VAR 0 2
39015: ARRAY
39016: PPUSH
39017: CALL_OW 321
39021: PUSH
39022: LD_INT 2
39024: NONEQUAL
39025: AND
39026: IFFALSE 39076
// begin if mc_deposits_finder [ i ] then
39028: LD_EXP 88
39032: PUSH
39033: LD_VAR 0 2
39037: ARRAY
39038: IFFALSE 39074
// begin MC_Reset ( i , 125 ) ;
39040: LD_VAR 0 2
39044: PPUSH
39045: LD_INT 125
39047: PPUSH
39048: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39052: LD_ADDR_EXP 88
39056: PUSH
39057: LD_EXP 88
39061: PPUSH
39062: LD_VAR 0 2
39066: PPUSH
39067: EMPTY
39068: PPUSH
39069: CALL_OW 1
39073: ST_TO_ADDR
// end ; continue ;
39074: GO 38832
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39076: LD_EXP 87
39080: PUSH
39081: LD_VAR 0 2
39085: ARRAY
39086: PUSH
39087: LD_INT 1
39089: ARRAY
39090: PUSH
39091: LD_INT 1
39093: ARRAY
39094: PPUSH
39095: LD_EXP 87
39099: PUSH
39100: LD_VAR 0 2
39104: ARRAY
39105: PUSH
39106: LD_INT 1
39108: ARRAY
39109: PUSH
39110: LD_INT 2
39112: ARRAY
39113: PPUSH
39114: LD_EXP 76
39118: PUSH
39119: LD_VAR 0 2
39123: ARRAY
39124: PPUSH
39125: CALL_OW 440
39129: IFFALSE 39172
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39131: LD_ADDR_EXP 87
39135: PUSH
39136: LD_EXP 87
39140: PPUSH
39141: LD_VAR 0 2
39145: PPUSH
39146: LD_EXP 87
39150: PUSH
39151: LD_VAR 0 2
39155: ARRAY
39156: PPUSH
39157: LD_INT 1
39159: PPUSH
39160: CALL_OW 3
39164: PPUSH
39165: CALL_OW 1
39169: ST_TO_ADDR
39170: GO 39419
// begin if not mc_deposits_finder [ i ] then
39172: LD_EXP 88
39176: PUSH
39177: LD_VAR 0 2
39181: ARRAY
39182: NOT
39183: IFFALSE 39235
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39185: LD_ADDR_EXP 88
39189: PUSH
39190: LD_EXP 88
39194: PPUSH
39195: LD_VAR 0 2
39199: PPUSH
39200: LD_VAR 0 3
39204: PUSH
39205: LD_INT 1
39207: ARRAY
39208: PUSH
39209: EMPTY
39210: LIST
39211: PPUSH
39212: CALL_OW 1
39216: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39217: LD_VAR 0 3
39221: PUSH
39222: LD_INT 1
39224: ARRAY
39225: PPUSH
39226: LD_INT 125
39228: PPUSH
39229: CALL_OW 109
// end else
39233: GO 39419
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39235: LD_EXP 88
39239: PUSH
39240: LD_VAR 0 2
39244: ARRAY
39245: PUSH
39246: LD_INT 1
39248: ARRAY
39249: PPUSH
39250: CALL_OW 310
39254: IFFALSE 39277
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39256: LD_EXP 88
39260: PUSH
39261: LD_VAR 0 2
39265: ARRAY
39266: PUSH
39267: LD_INT 1
39269: ARRAY
39270: PPUSH
39271: CALL_OW 122
39275: GO 39419
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39277: LD_EXP 88
39281: PUSH
39282: LD_VAR 0 2
39286: ARRAY
39287: PUSH
39288: LD_INT 1
39290: ARRAY
39291: PPUSH
39292: CALL_OW 314
39296: NOT
39297: PUSH
39298: LD_EXP 88
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PUSH
39309: LD_INT 1
39311: ARRAY
39312: PPUSH
39313: LD_EXP 87
39317: PUSH
39318: LD_VAR 0 2
39322: ARRAY
39323: PUSH
39324: LD_INT 1
39326: ARRAY
39327: PUSH
39328: LD_INT 1
39330: ARRAY
39331: PPUSH
39332: LD_EXP 87
39336: PUSH
39337: LD_VAR 0 2
39341: ARRAY
39342: PUSH
39343: LD_INT 1
39345: ARRAY
39346: PUSH
39347: LD_INT 2
39349: ARRAY
39350: PPUSH
39351: CALL_OW 297
39355: PUSH
39356: LD_INT 6
39358: GREATER
39359: AND
39360: IFFALSE 39419
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39362: LD_EXP 88
39366: PUSH
39367: LD_VAR 0 2
39371: ARRAY
39372: PUSH
39373: LD_INT 1
39375: ARRAY
39376: PPUSH
39377: LD_EXP 87
39381: PUSH
39382: LD_VAR 0 2
39386: ARRAY
39387: PUSH
39388: LD_INT 1
39390: ARRAY
39391: PUSH
39392: LD_INT 1
39394: ARRAY
39395: PPUSH
39396: LD_EXP 87
39400: PUSH
39401: LD_VAR 0 2
39405: ARRAY
39406: PUSH
39407: LD_INT 1
39409: ARRAY
39410: PUSH
39411: LD_INT 2
39413: ARRAY
39414: PPUSH
39415: CALL_OW 111
// end ; end ; end ;
39419: GO 38832
39421: POP
39422: POP
// end ;
39423: LD_VAR 0 1
39427: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39428: LD_INT 0
39430: PPUSH
39431: PPUSH
39432: PPUSH
39433: PPUSH
39434: PPUSH
39435: PPUSH
39436: PPUSH
39437: PPUSH
39438: PPUSH
39439: PPUSH
39440: PPUSH
// if not mc_bases then
39441: LD_EXP 50
39445: NOT
39446: IFFALSE 39450
// exit ;
39448: GO 40390
// for i = 1 to mc_bases do
39450: LD_ADDR_VAR 0 2
39454: PUSH
39455: DOUBLE
39456: LD_INT 1
39458: DEC
39459: ST_TO_ADDR
39460: LD_EXP 50
39464: PUSH
39465: FOR_TO
39466: IFFALSE 40388
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39468: LD_EXP 50
39472: PUSH
39473: LD_VAR 0 2
39477: ARRAY
39478: NOT
39479: PUSH
39480: LD_EXP 73
39484: PUSH
39485: LD_VAR 0 2
39489: ARRAY
39490: OR
39491: IFFALSE 39495
// continue ;
39493: GO 39465
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39495: LD_ADDR_VAR 0 7
39499: PUSH
39500: LD_EXP 50
39504: PUSH
39505: LD_VAR 0 2
39509: ARRAY
39510: PUSH
39511: LD_INT 1
39513: ARRAY
39514: PPUSH
39515: CALL_OW 248
39519: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39520: LD_VAR 0 7
39524: PUSH
39525: LD_INT 3
39527: EQUAL
39528: PUSH
39529: LD_EXP 69
39533: PUSH
39534: LD_VAR 0 2
39538: ARRAY
39539: PUSH
39540: LD_EXP 72
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: UNION
39551: PPUSH
39552: LD_INT 33
39554: PUSH
39555: LD_INT 2
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PPUSH
39562: CALL_OW 72
39566: NOT
39567: OR
39568: IFFALSE 39572
// continue ;
39570: GO 39465
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39572: LD_ADDR_VAR 0 9
39576: PUSH
39577: LD_EXP 50
39581: PUSH
39582: LD_VAR 0 2
39586: ARRAY
39587: PPUSH
39588: LD_INT 30
39590: PUSH
39591: LD_INT 36
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PPUSH
39598: CALL_OW 72
39602: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39603: LD_ADDR_VAR 0 10
39607: PUSH
39608: LD_EXP 69
39612: PUSH
39613: LD_VAR 0 2
39617: ARRAY
39618: PPUSH
39619: LD_INT 34
39621: PUSH
39622: LD_INT 31
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PPUSH
39629: CALL_OW 72
39633: ST_TO_ADDR
// if not cts and not mcts then
39634: LD_VAR 0 9
39638: NOT
39639: PUSH
39640: LD_VAR 0 10
39644: NOT
39645: AND
39646: IFFALSE 39650
// continue ;
39648: GO 39465
// x := cts ;
39650: LD_ADDR_VAR 0 11
39654: PUSH
39655: LD_VAR 0 9
39659: ST_TO_ADDR
// if not x then
39660: LD_VAR 0 11
39664: NOT
39665: IFFALSE 39677
// x := mcts ;
39667: LD_ADDR_VAR 0 11
39671: PUSH
39672: LD_VAR 0 10
39676: ST_TO_ADDR
// if not x then
39677: LD_VAR 0 11
39681: NOT
39682: IFFALSE 39686
// continue ;
39684: GO 39465
// if mc_remote_driver [ i ] then
39686: LD_EXP 90
39690: PUSH
39691: LD_VAR 0 2
39695: ARRAY
39696: IFFALSE 40083
// for j in mc_remote_driver [ i ] do
39698: LD_ADDR_VAR 0 3
39702: PUSH
39703: LD_EXP 90
39707: PUSH
39708: LD_VAR 0 2
39712: ARRAY
39713: PUSH
39714: FOR_IN
39715: IFFALSE 40081
// begin if GetClass ( j ) <> 3 then
39717: LD_VAR 0 3
39721: PPUSH
39722: CALL_OW 257
39726: PUSH
39727: LD_INT 3
39729: NONEQUAL
39730: IFFALSE 39783
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39732: LD_ADDR_EXP 90
39736: PUSH
39737: LD_EXP 90
39741: PPUSH
39742: LD_VAR 0 2
39746: PPUSH
39747: LD_EXP 90
39751: PUSH
39752: LD_VAR 0 2
39756: ARRAY
39757: PUSH
39758: LD_VAR 0 3
39762: DIFF
39763: PPUSH
39764: CALL_OW 1
39768: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39769: LD_VAR 0 3
39773: PPUSH
39774: LD_INT 0
39776: PPUSH
39777: CALL_OW 109
// continue ;
39781: GO 39714
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39783: LD_EXP 69
39787: PUSH
39788: LD_VAR 0 2
39792: ARRAY
39793: PPUSH
39794: LD_INT 34
39796: PUSH
39797: LD_INT 31
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 58
39806: PUSH
39807: EMPTY
39808: LIST
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PPUSH
39814: CALL_OW 72
39818: PUSH
39819: LD_VAR 0 3
39823: PPUSH
39824: CALL 82751 0 1
39828: NOT
39829: AND
39830: IFFALSE 39901
// begin if IsInUnit ( j ) then
39832: LD_VAR 0 3
39836: PPUSH
39837: CALL_OW 310
39841: IFFALSE 39852
// ComExitBuilding ( j ) ;
39843: LD_VAR 0 3
39847: PPUSH
39848: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39852: LD_VAR 0 3
39856: PPUSH
39857: LD_EXP 69
39861: PUSH
39862: LD_VAR 0 2
39866: ARRAY
39867: PPUSH
39868: LD_INT 34
39870: PUSH
39871: LD_INT 31
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 58
39880: PUSH
39881: EMPTY
39882: LIST
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PPUSH
39888: CALL_OW 72
39892: PUSH
39893: LD_INT 1
39895: ARRAY
39896: PPUSH
39897: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39901: LD_VAR 0 3
39905: PPUSH
39906: CALL_OW 310
39910: NOT
39911: PUSH
39912: LD_VAR 0 3
39916: PPUSH
39917: CALL_OW 310
39921: PPUSH
39922: CALL_OW 266
39926: PUSH
39927: LD_INT 36
39929: NONEQUAL
39930: PUSH
39931: LD_VAR 0 3
39935: PPUSH
39936: CALL 82751 0 1
39940: NOT
39941: AND
39942: OR
39943: IFFALSE 40079
// begin if IsInUnit ( j ) then
39945: LD_VAR 0 3
39949: PPUSH
39950: CALL_OW 310
39954: IFFALSE 39965
// ComExitBuilding ( j ) ;
39956: LD_VAR 0 3
39960: PPUSH
39961: CALL_OW 122
// ct := 0 ;
39965: LD_ADDR_VAR 0 8
39969: PUSH
39970: LD_INT 0
39972: ST_TO_ADDR
// for k in x do
39973: LD_ADDR_VAR 0 4
39977: PUSH
39978: LD_VAR 0 11
39982: PUSH
39983: FOR_IN
39984: IFFALSE 40057
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39986: LD_VAR 0 4
39990: PPUSH
39991: CALL_OW 264
39995: PUSH
39996: LD_INT 31
39998: EQUAL
39999: PUSH
40000: LD_VAR 0 4
40004: PPUSH
40005: CALL_OW 311
40009: NOT
40010: AND
40011: PUSH
40012: LD_VAR 0 4
40016: PPUSH
40017: CALL_OW 266
40021: PUSH
40022: LD_INT 36
40024: EQUAL
40025: PUSH
40026: LD_VAR 0 4
40030: PPUSH
40031: CALL_OW 313
40035: PUSH
40036: LD_INT 3
40038: LESS
40039: AND
40040: OR
40041: IFFALSE 40055
// begin ct := k ;
40043: LD_ADDR_VAR 0 8
40047: PUSH
40048: LD_VAR 0 4
40052: ST_TO_ADDR
// break ;
40053: GO 40057
// end ;
40055: GO 39983
40057: POP
40058: POP
// if ct then
40059: LD_VAR 0 8
40063: IFFALSE 40079
// ComEnterUnit ( j , ct ) ;
40065: LD_VAR 0 3
40069: PPUSH
40070: LD_VAR 0 8
40074: PPUSH
40075: CALL_OW 120
// end ; end ;
40079: GO 39714
40081: POP
40082: POP
// places := 0 ;
40083: LD_ADDR_VAR 0 5
40087: PUSH
40088: LD_INT 0
40090: ST_TO_ADDR
// for j = 1 to x do
40091: LD_ADDR_VAR 0 3
40095: PUSH
40096: DOUBLE
40097: LD_INT 1
40099: DEC
40100: ST_TO_ADDR
40101: LD_VAR 0 11
40105: PUSH
40106: FOR_TO
40107: IFFALSE 40183
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40109: LD_VAR 0 11
40113: PUSH
40114: LD_VAR 0 3
40118: ARRAY
40119: PPUSH
40120: CALL_OW 264
40124: PUSH
40125: LD_INT 31
40127: EQUAL
40128: IFFALSE 40146
// places := places + 1 else
40130: LD_ADDR_VAR 0 5
40134: PUSH
40135: LD_VAR 0 5
40139: PUSH
40140: LD_INT 1
40142: PLUS
40143: ST_TO_ADDR
40144: GO 40181
// if GetBType ( x [ j ] ) = b_control_tower then
40146: LD_VAR 0 11
40150: PUSH
40151: LD_VAR 0 3
40155: ARRAY
40156: PPUSH
40157: CALL_OW 266
40161: PUSH
40162: LD_INT 36
40164: EQUAL
40165: IFFALSE 40181
// places := places + 3 ;
40167: LD_ADDR_VAR 0 5
40171: PUSH
40172: LD_VAR 0 5
40176: PUSH
40177: LD_INT 3
40179: PLUS
40180: ST_TO_ADDR
40181: GO 40106
40183: POP
40184: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40185: LD_VAR 0 5
40189: PUSH
40190: LD_INT 0
40192: EQUAL
40193: PUSH
40194: LD_VAR 0 5
40198: PUSH
40199: LD_EXP 90
40203: PUSH
40204: LD_VAR 0 2
40208: ARRAY
40209: LESSEQUAL
40210: OR
40211: IFFALSE 40215
// continue ;
40213: GO 39465
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40215: LD_ADDR_VAR 0 6
40219: PUSH
40220: LD_EXP 50
40224: PUSH
40225: LD_VAR 0 2
40229: ARRAY
40230: PPUSH
40231: LD_INT 25
40233: PUSH
40234: LD_INT 3
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PPUSH
40241: CALL_OW 72
40245: PUSH
40246: LD_EXP 90
40250: PUSH
40251: LD_VAR 0 2
40255: ARRAY
40256: DIFF
40257: PPUSH
40258: LD_INT 3
40260: PPUSH
40261: CALL 83651 0 2
40265: ST_TO_ADDR
// for j in tmp do
40266: LD_ADDR_VAR 0 3
40270: PUSH
40271: LD_VAR 0 6
40275: PUSH
40276: FOR_IN
40277: IFFALSE 40312
// if GetTag ( j ) > 0 then
40279: LD_VAR 0 3
40283: PPUSH
40284: CALL_OW 110
40288: PUSH
40289: LD_INT 0
40291: GREATER
40292: IFFALSE 40310
// tmp := tmp diff j ;
40294: LD_ADDR_VAR 0 6
40298: PUSH
40299: LD_VAR 0 6
40303: PUSH
40304: LD_VAR 0 3
40308: DIFF
40309: ST_TO_ADDR
40310: GO 40276
40312: POP
40313: POP
// if not tmp then
40314: LD_VAR 0 6
40318: NOT
40319: IFFALSE 40323
// continue ;
40321: GO 39465
// if places then
40323: LD_VAR 0 5
40327: IFFALSE 40386
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40329: LD_ADDR_EXP 90
40333: PUSH
40334: LD_EXP 90
40338: PPUSH
40339: LD_VAR 0 2
40343: PPUSH
40344: LD_EXP 90
40348: PUSH
40349: LD_VAR 0 2
40353: ARRAY
40354: PUSH
40355: LD_VAR 0 6
40359: PUSH
40360: LD_INT 1
40362: ARRAY
40363: UNION
40364: PPUSH
40365: CALL_OW 1
40369: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40370: LD_VAR 0 6
40374: PUSH
40375: LD_INT 1
40377: ARRAY
40378: PPUSH
40379: LD_INT 126
40381: PPUSH
40382: CALL_OW 109
// end ; end ;
40386: GO 39465
40388: POP
40389: POP
// end ;
40390: LD_VAR 0 1
40394: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40395: LD_INT 0
40397: PPUSH
40398: PPUSH
40399: PPUSH
40400: PPUSH
40401: PPUSH
40402: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40403: LD_VAR 0 1
40407: NOT
40408: PUSH
40409: LD_VAR 0 2
40413: NOT
40414: OR
40415: PUSH
40416: LD_VAR 0 3
40420: NOT
40421: OR
40422: PUSH
40423: LD_VAR 0 4
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: LD_INT 2
40433: PUSH
40434: LD_INT 3
40436: PUSH
40437: LD_INT 4
40439: PUSH
40440: LD_INT 5
40442: PUSH
40443: LD_INT 8
40445: PUSH
40446: LD_INT 9
40448: PUSH
40449: LD_INT 15
40451: PUSH
40452: LD_INT 16
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: IN
40466: NOT
40467: OR
40468: IFFALSE 40472
// exit ;
40470: GO 41372
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40472: LD_ADDR_VAR 0 2
40476: PUSH
40477: LD_VAR 0 2
40481: PPUSH
40482: LD_INT 21
40484: PUSH
40485: LD_INT 3
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 24
40494: PUSH
40495: LD_INT 250
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 72
40510: ST_TO_ADDR
// case class of 1 , 15 :
40511: LD_VAR 0 4
40515: PUSH
40516: LD_INT 1
40518: DOUBLE
40519: EQUAL
40520: IFTRUE 40530
40522: LD_INT 15
40524: DOUBLE
40525: EQUAL
40526: IFTRUE 40530
40528: GO 40615
40530: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40531: LD_ADDR_VAR 0 8
40535: PUSH
40536: LD_VAR 0 2
40540: PPUSH
40541: LD_INT 2
40543: PUSH
40544: LD_INT 30
40546: PUSH
40547: LD_INT 32
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 30
40556: PUSH
40557: LD_INT 31
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: LIST
40568: PPUSH
40569: CALL_OW 72
40573: PUSH
40574: LD_VAR 0 2
40578: PPUSH
40579: LD_INT 2
40581: PUSH
40582: LD_INT 30
40584: PUSH
40585: LD_INT 4
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 30
40594: PUSH
40595: LD_INT 5
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: LIST
40606: PPUSH
40607: CALL_OW 72
40611: ADD
40612: ST_TO_ADDR
40613: GO 40861
40615: LD_INT 2
40617: DOUBLE
40618: EQUAL
40619: IFTRUE 40629
40621: LD_INT 16
40623: DOUBLE
40624: EQUAL
40625: IFTRUE 40629
40627: GO 40675
40629: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40630: LD_ADDR_VAR 0 8
40634: PUSH
40635: LD_VAR 0 2
40639: PPUSH
40640: LD_INT 2
40642: PUSH
40643: LD_INT 30
40645: PUSH
40646: LD_INT 0
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PUSH
40653: LD_INT 30
40655: PUSH
40656: LD_INT 1
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: LIST
40667: PPUSH
40668: CALL_OW 72
40672: ST_TO_ADDR
40673: GO 40861
40675: LD_INT 3
40677: DOUBLE
40678: EQUAL
40679: IFTRUE 40683
40681: GO 40729
40683: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40684: LD_ADDR_VAR 0 8
40688: PUSH
40689: LD_VAR 0 2
40693: PPUSH
40694: LD_INT 2
40696: PUSH
40697: LD_INT 30
40699: PUSH
40700: LD_INT 2
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 30
40709: PUSH
40710: LD_INT 3
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: PPUSH
40722: CALL_OW 72
40726: ST_TO_ADDR
40727: GO 40861
40729: LD_INT 4
40731: DOUBLE
40732: EQUAL
40733: IFTRUE 40737
40735: GO 40794
40737: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40738: LD_ADDR_VAR 0 8
40742: PUSH
40743: LD_VAR 0 2
40747: PPUSH
40748: LD_INT 2
40750: PUSH
40751: LD_INT 30
40753: PUSH
40754: LD_INT 6
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 30
40763: PUSH
40764: LD_INT 7
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 30
40773: PUSH
40774: LD_INT 8
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: PPUSH
40787: CALL_OW 72
40791: ST_TO_ADDR
40792: GO 40861
40794: LD_INT 5
40796: DOUBLE
40797: EQUAL
40798: IFTRUE 40814
40800: LD_INT 8
40802: DOUBLE
40803: EQUAL
40804: IFTRUE 40814
40806: LD_INT 9
40808: DOUBLE
40809: EQUAL
40810: IFTRUE 40814
40812: GO 40860
40814: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40815: LD_ADDR_VAR 0 8
40819: PUSH
40820: LD_VAR 0 2
40824: PPUSH
40825: LD_INT 2
40827: PUSH
40828: LD_INT 30
40830: PUSH
40831: LD_INT 4
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 30
40840: PUSH
40841: LD_INT 5
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: LIST
40852: PPUSH
40853: CALL_OW 72
40857: ST_TO_ADDR
40858: GO 40861
40860: POP
// if not tmp then
40861: LD_VAR 0 8
40865: NOT
40866: IFFALSE 40870
// exit ;
40868: GO 41372
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40870: LD_VAR 0 4
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: LD_INT 15
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: IN
40885: PUSH
40886: LD_EXP 59
40890: PUSH
40891: LD_VAR 0 1
40895: ARRAY
40896: AND
40897: IFFALSE 41053
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40899: LD_ADDR_VAR 0 9
40903: PUSH
40904: LD_EXP 59
40908: PUSH
40909: LD_VAR 0 1
40913: ARRAY
40914: PUSH
40915: LD_INT 1
40917: ARRAY
40918: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40919: LD_VAR 0 9
40923: PUSH
40924: LD_EXP 60
40928: PUSH
40929: LD_VAR 0 1
40933: ARRAY
40934: IN
40935: NOT
40936: IFFALSE 41051
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40938: LD_ADDR_EXP 60
40942: PUSH
40943: LD_EXP 60
40947: PPUSH
40948: LD_VAR 0 1
40952: PUSH
40953: LD_EXP 60
40957: PUSH
40958: LD_VAR 0 1
40962: ARRAY
40963: PUSH
40964: LD_INT 1
40966: PLUS
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: LD_VAR 0 9
40976: PPUSH
40977: CALL 53394 0 3
40981: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40982: LD_ADDR_EXP 59
40986: PUSH
40987: LD_EXP 59
40991: PPUSH
40992: LD_VAR 0 1
40996: PPUSH
40997: LD_EXP 59
41001: PUSH
41002: LD_VAR 0 1
41006: ARRAY
41007: PUSH
41008: LD_VAR 0 9
41012: DIFF
41013: PPUSH
41014: CALL_OW 1
41018: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41019: LD_VAR 0 3
41023: PPUSH
41024: LD_EXP 60
41028: PUSH
41029: LD_VAR 0 1
41033: ARRAY
41034: PUSH
41035: LD_EXP 60
41039: PUSH
41040: LD_VAR 0 1
41044: ARRAY
41045: ARRAY
41046: PPUSH
41047: CALL_OW 120
// end ; exit ;
41051: GO 41372
// end ; if tmp > 1 then
41053: LD_VAR 0 8
41057: PUSH
41058: LD_INT 1
41060: GREATER
41061: IFFALSE 41165
// for i = 2 to tmp do
41063: LD_ADDR_VAR 0 6
41067: PUSH
41068: DOUBLE
41069: LD_INT 2
41071: DEC
41072: ST_TO_ADDR
41073: LD_VAR 0 8
41077: PUSH
41078: FOR_TO
41079: IFFALSE 41163
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41081: LD_VAR 0 8
41085: PUSH
41086: LD_VAR 0 6
41090: ARRAY
41091: PPUSH
41092: CALL_OW 461
41096: PUSH
41097: LD_INT 6
41099: EQUAL
41100: IFFALSE 41161
// begin x := tmp [ i ] ;
41102: LD_ADDR_VAR 0 9
41106: PUSH
41107: LD_VAR 0 8
41111: PUSH
41112: LD_VAR 0 6
41116: ARRAY
41117: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41118: LD_ADDR_VAR 0 8
41122: PUSH
41123: LD_VAR 0 8
41127: PPUSH
41128: LD_VAR 0 6
41132: PPUSH
41133: CALL_OW 3
41137: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41138: LD_ADDR_VAR 0 8
41142: PUSH
41143: LD_VAR 0 8
41147: PPUSH
41148: LD_INT 1
41150: PPUSH
41151: LD_VAR 0 9
41155: PPUSH
41156: CALL_OW 2
41160: ST_TO_ADDR
// end ;
41161: GO 41078
41163: POP
41164: POP
// for i in tmp do
41165: LD_ADDR_VAR 0 6
41169: PUSH
41170: LD_VAR 0 8
41174: PUSH
41175: FOR_IN
41176: IFFALSE 41245
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41178: LD_VAR 0 6
41182: PPUSH
41183: CALL_OW 313
41187: PUSH
41188: LD_INT 6
41190: LESS
41191: PUSH
41192: LD_VAR 0 6
41196: PPUSH
41197: CALL_OW 266
41201: PUSH
41202: LD_INT 31
41204: PUSH
41205: LD_INT 32
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: IN
41212: NOT
41213: AND
41214: PUSH
41215: LD_VAR 0 6
41219: PPUSH
41220: CALL_OW 313
41224: PUSH
41225: LD_INT 0
41227: EQUAL
41228: OR
41229: IFFALSE 41243
// begin j := i ;
41231: LD_ADDR_VAR 0 7
41235: PUSH
41236: LD_VAR 0 6
41240: ST_TO_ADDR
// break ;
41241: GO 41245
// end ; end ;
41243: GO 41175
41245: POP
41246: POP
// if j then
41247: LD_VAR 0 7
41251: IFFALSE 41269
// ComEnterUnit ( unit , j ) else
41253: LD_VAR 0 3
41257: PPUSH
41258: LD_VAR 0 7
41262: PPUSH
41263: CALL_OW 120
41267: GO 41372
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41269: LD_ADDR_VAR 0 10
41273: PUSH
41274: LD_VAR 0 2
41278: PPUSH
41279: LD_INT 2
41281: PUSH
41282: LD_INT 30
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 1
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: ST_TO_ADDR
// if depot then
41312: LD_VAR 0 10
41316: IFFALSE 41372
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41318: LD_ADDR_VAR 0 10
41322: PUSH
41323: LD_VAR 0 10
41327: PPUSH
41328: LD_VAR 0 3
41332: PPUSH
41333: CALL_OW 74
41337: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41338: LD_VAR 0 3
41342: PPUSH
41343: LD_VAR 0 10
41347: PPUSH
41348: CALL_OW 296
41352: PUSH
41353: LD_INT 10
41355: GREATER
41356: IFFALSE 41372
// ComStandNearbyBuilding ( unit , depot ) ;
41358: LD_VAR 0 3
41362: PPUSH
41363: LD_VAR 0 10
41367: PPUSH
41368: CALL 49972 0 2
// end ; end ; end ;
41372: LD_VAR 0 5
41376: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41377: LD_INT 0
41379: PPUSH
41380: PPUSH
41381: PPUSH
41382: PPUSH
// if not mc_bases then
41383: LD_EXP 50
41387: NOT
41388: IFFALSE 41392
// exit ;
41390: GO 41631
// for i = 1 to mc_bases do
41392: LD_ADDR_VAR 0 2
41396: PUSH
41397: DOUBLE
41398: LD_INT 1
41400: DEC
41401: ST_TO_ADDR
41402: LD_EXP 50
41406: PUSH
41407: FOR_TO
41408: IFFALSE 41629
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41410: LD_ADDR_VAR 0 4
41414: PUSH
41415: LD_EXP 50
41419: PUSH
41420: LD_VAR 0 2
41424: ARRAY
41425: PPUSH
41426: LD_INT 21
41428: PUSH
41429: LD_INT 1
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PPUSH
41436: CALL_OW 72
41440: PUSH
41441: LD_EXP 79
41445: PUSH
41446: LD_VAR 0 2
41450: ARRAY
41451: UNION
41452: ST_TO_ADDR
// if not tmp then
41453: LD_VAR 0 4
41457: NOT
41458: IFFALSE 41462
// continue ;
41460: GO 41407
// for j in tmp do
41462: LD_ADDR_VAR 0 3
41466: PUSH
41467: LD_VAR 0 4
41471: PUSH
41472: FOR_IN
41473: IFFALSE 41625
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41475: LD_VAR 0 3
41479: PPUSH
41480: CALL_OW 110
41484: NOT
41485: PUSH
41486: LD_VAR 0 3
41490: PPUSH
41491: CALL_OW 314
41495: NOT
41496: AND
41497: PUSH
41498: LD_VAR 0 3
41502: PPUSH
41503: CALL_OW 311
41507: NOT
41508: AND
41509: PUSH
41510: LD_VAR 0 3
41514: PPUSH
41515: CALL_OW 310
41519: NOT
41520: AND
41521: PUSH
41522: LD_VAR 0 3
41526: PUSH
41527: LD_EXP 53
41531: PUSH
41532: LD_VAR 0 2
41536: ARRAY
41537: PUSH
41538: LD_INT 1
41540: ARRAY
41541: IN
41542: NOT
41543: AND
41544: PUSH
41545: LD_VAR 0 3
41549: PUSH
41550: LD_EXP 53
41554: PUSH
41555: LD_VAR 0 2
41559: ARRAY
41560: PUSH
41561: LD_INT 2
41563: ARRAY
41564: IN
41565: NOT
41566: AND
41567: PUSH
41568: LD_VAR 0 3
41572: PUSH
41573: LD_EXP 62
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: IN
41584: NOT
41585: AND
41586: IFFALSE 41623
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41588: LD_VAR 0 2
41592: PPUSH
41593: LD_EXP 50
41597: PUSH
41598: LD_VAR 0 2
41602: ARRAY
41603: PPUSH
41604: LD_VAR 0 3
41608: PPUSH
41609: LD_VAR 0 3
41613: PPUSH
41614: CALL_OW 257
41618: PPUSH
41619: CALL 40395 0 4
// end ;
41623: GO 41472
41625: POP
41626: POP
// end ;
41627: GO 41407
41629: POP
41630: POP
// end ;
41631: LD_VAR 0 1
41635: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41636: LD_INT 0
41638: PPUSH
41639: PPUSH
41640: PPUSH
41641: PPUSH
41642: PPUSH
41643: PPUSH
// if not mc_bases [ base ] then
41644: LD_EXP 50
41648: PUSH
41649: LD_VAR 0 1
41653: ARRAY
41654: NOT
41655: IFFALSE 41659
// exit ;
41657: GO 41841
// tmp := [ ] ;
41659: LD_ADDR_VAR 0 6
41663: PUSH
41664: EMPTY
41665: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41666: LD_ADDR_VAR 0 7
41670: PUSH
41671: LD_VAR 0 3
41675: PPUSH
41676: LD_INT 0
41678: PPUSH
41679: CALL_OW 517
41683: ST_TO_ADDR
// if not list then
41684: LD_VAR 0 7
41688: NOT
41689: IFFALSE 41693
// exit ;
41691: GO 41841
// for i = 1 to amount do
41693: LD_ADDR_VAR 0 5
41697: PUSH
41698: DOUBLE
41699: LD_INT 1
41701: DEC
41702: ST_TO_ADDR
41703: LD_VAR 0 2
41707: PUSH
41708: FOR_TO
41709: IFFALSE 41789
// begin x := rand ( 1 , list [ 1 ] ) ;
41711: LD_ADDR_VAR 0 8
41715: PUSH
41716: LD_INT 1
41718: PPUSH
41719: LD_VAR 0 7
41723: PUSH
41724: LD_INT 1
41726: ARRAY
41727: PPUSH
41728: CALL_OW 12
41732: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41733: LD_ADDR_VAR 0 6
41737: PUSH
41738: LD_VAR 0 6
41742: PPUSH
41743: LD_VAR 0 5
41747: PPUSH
41748: LD_VAR 0 7
41752: PUSH
41753: LD_INT 1
41755: ARRAY
41756: PUSH
41757: LD_VAR 0 8
41761: ARRAY
41762: PUSH
41763: LD_VAR 0 7
41767: PUSH
41768: LD_INT 2
41770: ARRAY
41771: PUSH
41772: LD_VAR 0 8
41776: ARRAY
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PPUSH
41782: CALL_OW 1
41786: ST_TO_ADDR
// end ;
41787: GO 41708
41789: POP
41790: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41791: LD_ADDR_EXP 63
41795: PUSH
41796: LD_EXP 63
41800: PPUSH
41801: LD_VAR 0 1
41805: PPUSH
41806: LD_VAR 0 6
41810: PPUSH
41811: CALL_OW 1
41815: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41816: LD_ADDR_EXP 65
41820: PUSH
41821: LD_EXP 65
41825: PPUSH
41826: LD_VAR 0 1
41830: PPUSH
41831: LD_VAR 0 3
41835: PPUSH
41836: CALL_OW 1
41840: ST_TO_ADDR
// end ;
41841: LD_VAR 0 4
41845: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41846: LD_INT 0
41848: PPUSH
// if not mc_bases [ base ] then
41849: LD_EXP 50
41853: PUSH
41854: LD_VAR 0 1
41858: ARRAY
41859: NOT
41860: IFFALSE 41864
// exit ;
41862: GO 41889
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41864: LD_ADDR_EXP 55
41868: PUSH
41869: LD_EXP 55
41873: PPUSH
41874: LD_VAR 0 1
41878: PPUSH
41879: LD_VAR 0 2
41883: PPUSH
41884: CALL_OW 1
41888: ST_TO_ADDR
// end ;
41889: LD_VAR 0 3
41893: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41894: LD_INT 0
41896: PPUSH
// if not mc_bases [ base ] then
41897: LD_EXP 50
41901: PUSH
41902: LD_VAR 0 1
41906: ARRAY
41907: NOT
41908: IFFALSE 41912
// exit ;
41910: GO 41949
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41912: LD_ADDR_EXP 55
41916: PUSH
41917: LD_EXP 55
41921: PPUSH
41922: LD_VAR 0 1
41926: PPUSH
41927: LD_EXP 55
41931: PUSH
41932: LD_VAR 0 1
41936: ARRAY
41937: PUSH
41938: LD_VAR 0 2
41942: UNION
41943: PPUSH
41944: CALL_OW 1
41948: ST_TO_ADDR
// end ;
41949: LD_VAR 0 3
41953: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41954: LD_INT 0
41956: PPUSH
// if not mc_bases [ base ] then
41957: LD_EXP 50
41961: PUSH
41962: LD_VAR 0 1
41966: ARRAY
41967: NOT
41968: IFFALSE 41972
// exit ;
41970: GO 41997
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41972: LD_ADDR_EXP 71
41976: PUSH
41977: LD_EXP 71
41981: PPUSH
41982: LD_VAR 0 1
41986: PPUSH
41987: LD_VAR 0 2
41991: PPUSH
41992: CALL_OW 1
41996: ST_TO_ADDR
// end ;
41997: LD_VAR 0 3
42001: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42002: LD_INT 0
42004: PPUSH
// if not mc_bases [ base ] then
42005: LD_EXP 50
42009: PUSH
42010: LD_VAR 0 1
42014: ARRAY
42015: NOT
42016: IFFALSE 42020
// exit ;
42018: GO 42057
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42020: LD_ADDR_EXP 71
42024: PUSH
42025: LD_EXP 71
42029: PPUSH
42030: LD_VAR 0 1
42034: PPUSH
42035: LD_EXP 71
42039: PUSH
42040: LD_VAR 0 1
42044: ARRAY
42045: PUSH
42046: LD_VAR 0 2
42050: ADD
42051: PPUSH
42052: CALL_OW 1
42056: ST_TO_ADDR
// end ;
42057: LD_VAR 0 3
42061: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42062: LD_INT 0
42064: PPUSH
// if not mc_bases [ base ] then
42065: LD_EXP 50
42069: PUSH
42070: LD_VAR 0 1
42074: ARRAY
42075: NOT
42076: IFFALSE 42080
// exit ;
42078: GO 42134
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42080: LD_ADDR_EXP 72
42084: PUSH
42085: LD_EXP 72
42089: PPUSH
42090: LD_VAR 0 1
42094: PPUSH
42095: LD_VAR 0 2
42099: PPUSH
42100: CALL_OW 1
42104: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42105: LD_ADDR_EXP 61
42109: PUSH
42110: LD_EXP 61
42114: PPUSH
42115: LD_VAR 0 1
42119: PPUSH
42120: LD_VAR 0 2
42124: PUSH
42125: LD_INT 0
42127: PLUS
42128: PPUSH
42129: CALL_OW 1
42133: ST_TO_ADDR
// end ;
42134: LD_VAR 0 3
42138: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42139: LD_INT 0
42141: PPUSH
// if not mc_bases [ base ] then
42142: LD_EXP 50
42146: PUSH
42147: LD_VAR 0 1
42151: ARRAY
42152: NOT
42153: IFFALSE 42157
// exit ;
42155: GO 42182
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42157: LD_ADDR_EXP 61
42161: PUSH
42162: LD_EXP 61
42166: PPUSH
42167: LD_VAR 0 1
42171: PPUSH
42172: LD_VAR 0 2
42176: PPUSH
42177: CALL_OW 1
42181: ST_TO_ADDR
// end ;
42182: LD_VAR 0 3
42186: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42187: LD_INT 0
42189: PPUSH
42190: PPUSH
42191: PPUSH
42192: PPUSH
// if not mc_bases [ base ] then
42193: LD_EXP 50
42197: PUSH
42198: LD_VAR 0 1
42202: ARRAY
42203: NOT
42204: IFFALSE 42208
// exit ;
42206: GO 42273
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42208: LD_ADDR_EXP 70
42212: PUSH
42213: LD_EXP 70
42217: PPUSH
42218: LD_VAR 0 1
42222: PUSH
42223: LD_EXP 70
42227: PUSH
42228: LD_VAR 0 1
42232: ARRAY
42233: PUSH
42234: LD_INT 1
42236: PLUS
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PPUSH
42242: LD_VAR 0 1
42246: PUSH
42247: LD_VAR 0 2
42251: PUSH
42252: LD_VAR 0 3
42256: PUSH
42257: LD_VAR 0 4
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: PPUSH
42268: CALL 53394 0 3
42272: ST_TO_ADDR
// end ;
42273: LD_VAR 0 5
42277: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42278: LD_INT 0
42280: PPUSH
// if not mc_bases [ base ] then
42281: LD_EXP 50
42285: PUSH
42286: LD_VAR 0 1
42290: ARRAY
42291: NOT
42292: IFFALSE 42296
// exit ;
42294: GO 42321
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42296: LD_ADDR_EXP 87
42300: PUSH
42301: LD_EXP 87
42305: PPUSH
42306: LD_VAR 0 1
42310: PPUSH
42311: LD_VAR 0 2
42315: PPUSH
42316: CALL_OW 1
42320: ST_TO_ADDR
// end ;
42321: LD_VAR 0 3
42325: RET
// export function MC_GetMinesField ( base ) ; begin
42326: LD_INT 0
42328: PPUSH
// result := mc_mines [ base ] ;
42329: LD_ADDR_VAR 0 2
42333: PUSH
42334: LD_EXP 63
42338: PUSH
42339: LD_VAR 0 1
42343: ARRAY
42344: ST_TO_ADDR
// end ;
42345: LD_VAR 0 2
42349: RET
// export function MC_GetProduceList ( base ) ; begin
42350: LD_INT 0
42352: PPUSH
// result := mc_produce [ base ] ;
42353: LD_ADDR_VAR 0 2
42357: PUSH
42358: LD_EXP 71
42362: PUSH
42363: LD_VAR 0 1
42367: ARRAY
42368: ST_TO_ADDR
// end ;
42369: LD_VAR 0 2
42373: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42374: LD_INT 0
42376: PPUSH
42377: PPUSH
// if not mc_bases then
42378: LD_EXP 50
42382: NOT
42383: IFFALSE 42387
// exit ;
42385: GO 42452
// if mc_bases [ base ] then
42387: LD_EXP 50
42391: PUSH
42392: LD_VAR 0 1
42396: ARRAY
42397: IFFALSE 42452
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42399: LD_ADDR_VAR 0 3
42403: PUSH
42404: LD_EXP 50
42408: PUSH
42409: LD_VAR 0 1
42413: ARRAY
42414: PPUSH
42415: LD_INT 30
42417: PUSH
42418: LD_VAR 0 2
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PPUSH
42427: CALL_OW 72
42431: ST_TO_ADDR
// if result then
42432: LD_VAR 0 3
42436: IFFALSE 42452
// result := result [ 1 ] ;
42438: LD_ADDR_VAR 0 3
42442: PUSH
42443: LD_VAR 0 3
42447: PUSH
42448: LD_INT 1
42450: ARRAY
42451: ST_TO_ADDR
// end ; end ;
42452: LD_VAR 0 3
42456: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42457: LD_INT 0
42459: PPUSH
42460: PPUSH
// if not mc_bases then
42461: LD_EXP 50
42465: NOT
42466: IFFALSE 42470
// exit ;
42468: GO 42515
// if mc_bases [ base ] then
42470: LD_EXP 50
42474: PUSH
42475: LD_VAR 0 1
42479: ARRAY
42480: IFFALSE 42515
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42482: LD_ADDR_VAR 0 3
42486: PUSH
42487: LD_EXP 50
42491: PUSH
42492: LD_VAR 0 1
42496: ARRAY
42497: PPUSH
42498: LD_INT 30
42500: PUSH
42501: LD_VAR 0 2
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PPUSH
42510: CALL_OW 72
42514: ST_TO_ADDR
// end ;
42515: LD_VAR 0 3
42519: RET
// export function MC_SetTame ( base , area ) ; begin
42520: LD_INT 0
42522: PPUSH
// if not mc_bases or not base then
42523: LD_EXP 50
42527: NOT
42528: PUSH
42529: LD_VAR 0 1
42533: NOT
42534: OR
42535: IFFALSE 42539
// exit ;
42537: GO 42564
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42539: LD_ADDR_EXP 78
42543: PUSH
42544: LD_EXP 78
42548: PPUSH
42549: LD_VAR 0 1
42553: PPUSH
42554: LD_VAR 0 2
42558: PPUSH
42559: CALL_OW 1
42563: ST_TO_ADDR
// end ;
42564: LD_VAR 0 3
42568: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42569: LD_INT 0
42571: PPUSH
42572: PPUSH
// if not mc_bases or not base then
42573: LD_EXP 50
42577: NOT
42578: PUSH
42579: LD_VAR 0 1
42583: NOT
42584: OR
42585: IFFALSE 42589
// exit ;
42587: GO 42691
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42589: LD_ADDR_VAR 0 4
42593: PUSH
42594: LD_EXP 50
42598: PUSH
42599: LD_VAR 0 1
42603: ARRAY
42604: PPUSH
42605: LD_INT 30
42607: PUSH
42608: LD_VAR 0 2
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PPUSH
42617: CALL_OW 72
42621: ST_TO_ADDR
// if not tmp then
42622: LD_VAR 0 4
42626: NOT
42627: IFFALSE 42631
// exit ;
42629: GO 42691
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42631: LD_ADDR_EXP 82
42635: PUSH
42636: LD_EXP 82
42640: PPUSH
42641: LD_VAR 0 1
42645: PPUSH
42646: LD_EXP 82
42650: PUSH
42651: LD_VAR 0 1
42655: ARRAY
42656: PPUSH
42657: LD_EXP 82
42661: PUSH
42662: LD_VAR 0 1
42666: ARRAY
42667: PUSH
42668: LD_INT 1
42670: PLUS
42671: PPUSH
42672: LD_VAR 0 4
42676: PUSH
42677: LD_INT 1
42679: ARRAY
42680: PPUSH
42681: CALL_OW 2
42685: PPUSH
42686: CALL_OW 1
42690: ST_TO_ADDR
// end ;
42691: LD_VAR 0 3
42695: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42696: LD_INT 0
42698: PPUSH
42699: PPUSH
// if not mc_bases or not base or not kinds then
42700: LD_EXP 50
42704: NOT
42705: PUSH
42706: LD_VAR 0 1
42710: NOT
42711: OR
42712: PUSH
42713: LD_VAR 0 2
42717: NOT
42718: OR
42719: IFFALSE 42723
// exit ;
42721: GO 42784
// for i in kinds do
42723: LD_ADDR_VAR 0 4
42727: PUSH
42728: LD_VAR 0 2
42732: PUSH
42733: FOR_IN
42734: IFFALSE 42782
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42736: LD_ADDR_EXP 84
42740: PUSH
42741: LD_EXP 84
42745: PPUSH
42746: LD_VAR 0 1
42750: PUSH
42751: LD_EXP 84
42755: PUSH
42756: LD_VAR 0 1
42760: ARRAY
42761: PUSH
42762: LD_INT 1
42764: PLUS
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PPUSH
42770: LD_VAR 0 4
42774: PPUSH
42775: CALL 53394 0 3
42779: ST_TO_ADDR
42780: GO 42733
42782: POP
42783: POP
// end ;
42784: LD_VAR 0 3
42788: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42789: LD_INT 0
42791: PPUSH
// if not mc_bases or not base or not areas then
42792: LD_EXP 50
42796: NOT
42797: PUSH
42798: LD_VAR 0 1
42802: NOT
42803: OR
42804: PUSH
42805: LD_VAR 0 2
42809: NOT
42810: OR
42811: IFFALSE 42815
// exit ;
42813: GO 42840
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42815: LD_ADDR_EXP 68
42819: PUSH
42820: LD_EXP 68
42824: PPUSH
42825: LD_VAR 0 1
42829: PPUSH
42830: LD_VAR 0 2
42834: PPUSH
42835: CALL_OW 1
42839: ST_TO_ADDR
// end ;
42840: LD_VAR 0 3
42844: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42845: LD_INT 0
42847: PPUSH
// if not mc_bases or not base or not teleports_exit then
42848: LD_EXP 50
42852: NOT
42853: PUSH
42854: LD_VAR 0 1
42858: NOT
42859: OR
42860: PUSH
42861: LD_VAR 0 2
42865: NOT
42866: OR
42867: IFFALSE 42871
// exit ;
42869: GO 42896
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42871: LD_ADDR_EXP 85
42875: PUSH
42876: LD_EXP 85
42880: PPUSH
42881: LD_VAR 0 1
42885: PPUSH
42886: LD_VAR 0 2
42890: PPUSH
42891: CALL_OW 1
42895: ST_TO_ADDR
// end ;
42896: LD_VAR 0 3
42900: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42901: LD_INT 0
42903: PPUSH
42904: PPUSH
42905: PPUSH
// if not mc_bases or not base or not ext_list then
42906: LD_EXP 50
42910: NOT
42911: PUSH
42912: LD_VAR 0 1
42916: NOT
42917: OR
42918: PUSH
42919: LD_VAR 0 5
42923: NOT
42924: OR
42925: IFFALSE 42929
// exit ;
42927: GO 43102
// tmp := GetFacExtXYD ( x , y , d ) ;
42929: LD_ADDR_VAR 0 8
42933: PUSH
42934: LD_VAR 0 2
42938: PPUSH
42939: LD_VAR 0 3
42943: PPUSH
42944: LD_VAR 0 4
42948: PPUSH
42949: CALL 82781 0 3
42953: ST_TO_ADDR
// if not tmp then
42954: LD_VAR 0 8
42958: NOT
42959: IFFALSE 42963
// exit ;
42961: GO 43102
// for i in tmp do
42963: LD_ADDR_VAR 0 7
42967: PUSH
42968: LD_VAR 0 8
42972: PUSH
42973: FOR_IN
42974: IFFALSE 43100
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42976: LD_ADDR_EXP 55
42980: PUSH
42981: LD_EXP 55
42985: PPUSH
42986: LD_VAR 0 1
42990: PPUSH
42991: LD_EXP 55
42995: PUSH
42996: LD_VAR 0 1
43000: ARRAY
43001: PPUSH
43002: LD_EXP 55
43006: PUSH
43007: LD_VAR 0 1
43011: ARRAY
43012: PUSH
43013: LD_INT 1
43015: PLUS
43016: PPUSH
43017: LD_VAR 0 5
43021: PUSH
43022: LD_INT 1
43024: ARRAY
43025: PUSH
43026: LD_VAR 0 7
43030: PUSH
43031: LD_INT 1
43033: ARRAY
43034: PUSH
43035: LD_VAR 0 7
43039: PUSH
43040: LD_INT 2
43042: ARRAY
43043: PUSH
43044: LD_VAR 0 7
43048: PUSH
43049: LD_INT 3
43051: ARRAY
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: LIST
43057: LIST
43058: PPUSH
43059: CALL_OW 2
43063: PPUSH
43064: CALL_OW 1
43068: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43069: LD_ADDR_VAR 0 5
43073: PUSH
43074: LD_VAR 0 5
43078: PPUSH
43079: LD_INT 1
43081: PPUSH
43082: CALL_OW 3
43086: ST_TO_ADDR
// if not ext_list then
43087: LD_VAR 0 5
43091: NOT
43092: IFFALSE 43098
// exit ;
43094: POP
43095: POP
43096: GO 43102
// end ;
43098: GO 42973
43100: POP
43101: POP
// end ;
43102: LD_VAR 0 6
43106: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43107: LD_INT 0
43109: PPUSH
// if not mc_bases or not base or not weapon_list then
43110: LD_EXP 50
43114: NOT
43115: PUSH
43116: LD_VAR 0 1
43120: NOT
43121: OR
43122: PUSH
43123: LD_VAR 0 2
43127: NOT
43128: OR
43129: IFFALSE 43133
// exit ;
43131: GO 43158
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43133: LD_ADDR_EXP 89
43137: PUSH
43138: LD_EXP 89
43142: PPUSH
43143: LD_VAR 0 1
43147: PPUSH
43148: LD_VAR 0 2
43152: PPUSH
43153: CALL_OW 1
43157: ST_TO_ADDR
// end ;
43158: LD_VAR 0 3
43162: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43163: LD_INT 0
43165: PPUSH
// if not mc_bases or not base or not tech_list then
43166: LD_EXP 50
43170: NOT
43171: PUSH
43172: LD_VAR 0 1
43176: NOT
43177: OR
43178: PUSH
43179: LD_VAR 0 2
43183: NOT
43184: OR
43185: IFFALSE 43189
// exit ;
43187: GO 43214
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43189: LD_ADDR_EXP 77
43193: PUSH
43194: LD_EXP 77
43198: PPUSH
43199: LD_VAR 0 1
43203: PPUSH
43204: LD_VAR 0 2
43208: PPUSH
43209: CALL_OW 1
43213: ST_TO_ADDR
// end ;
43214: LD_VAR 0 3
43218: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43219: LD_INT 0
43221: PPUSH
// if not mc_bases or not parking_area or not base then
43222: LD_EXP 50
43226: NOT
43227: PUSH
43228: LD_VAR 0 2
43232: NOT
43233: OR
43234: PUSH
43235: LD_VAR 0 1
43239: NOT
43240: OR
43241: IFFALSE 43245
// exit ;
43243: GO 43270
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43245: LD_ADDR_EXP 74
43249: PUSH
43250: LD_EXP 74
43254: PPUSH
43255: LD_VAR 0 1
43259: PPUSH
43260: LD_VAR 0 2
43264: PPUSH
43265: CALL_OW 1
43269: ST_TO_ADDR
// end ;
43270: LD_VAR 0 3
43274: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43275: LD_INT 0
43277: PPUSH
// if not mc_bases or not base or not scan_area then
43278: LD_EXP 50
43282: NOT
43283: PUSH
43284: LD_VAR 0 1
43288: NOT
43289: OR
43290: PUSH
43291: LD_VAR 0 2
43295: NOT
43296: OR
43297: IFFALSE 43301
// exit ;
43299: GO 43326
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43301: LD_ADDR_EXP 75
43305: PUSH
43306: LD_EXP 75
43310: PPUSH
43311: LD_VAR 0 1
43315: PPUSH
43316: LD_VAR 0 2
43320: PPUSH
43321: CALL_OW 1
43325: ST_TO_ADDR
// end ;
43326: LD_VAR 0 3
43330: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43331: LD_INT 0
43333: PPUSH
43334: PPUSH
// if not mc_bases or not base then
43335: LD_EXP 50
43339: NOT
43340: PUSH
43341: LD_VAR 0 1
43345: NOT
43346: OR
43347: IFFALSE 43351
// exit ;
43349: GO 43415
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43351: LD_ADDR_VAR 0 3
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: LD_INT 2
43361: PUSH
43362: LD_INT 3
43364: PUSH
43365: LD_INT 4
43367: PUSH
43368: LD_INT 11
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43378: LD_ADDR_EXP 77
43382: PUSH
43383: LD_EXP 77
43387: PPUSH
43388: LD_VAR 0 1
43392: PPUSH
43393: LD_EXP 77
43397: PUSH
43398: LD_VAR 0 1
43402: ARRAY
43403: PUSH
43404: LD_VAR 0 3
43408: DIFF
43409: PPUSH
43410: CALL_OW 1
43414: ST_TO_ADDR
// end ;
43415: LD_VAR 0 2
43419: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43420: LD_INT 0
43422: PPUSH
// result := mc_vehicles [ base ] ;
43423: LD_ADDR_VAR 0 3
43427: PUSH
43428: LD_EXP 69
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: ST_TO_ADDR
// if onlyCombat then
43439: LD_VAR 0 2
43443: IFFALSE 43621
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43445: LD_ADDR_VAR 0 3
43449: PUSH
43450: LD_VAR 0 3
43454: PUSH
43455: LD_VAR 0 3
43459: PPUSH
43460: LD_INT 2
43462: PUSH
43463: LD_INT 34
43465: PUSH
43466: LD_INT 12
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 34
43475: PUSH
43476: LD_INT 51
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 34
43485: PUSH
43486: LD_EXP 95
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 34
43497: PUSH
43498: LD_INT 32
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 34
43507: PUSH
43508: LD_INT 13
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 34
43517: PUSH
43518: LD_INT 52
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: LD_INT 34
43527: PUSH
43528: LD_EXP 100
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 34
43539: PUSH
43540: LD_INT 14
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 34
43549: PUSH
43550: LD_INT 53
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 34
43559: PUSH
43560: LD_EXP 94
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 34
43571: PUSH
43572: LD_INT 31
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 34
43581: PUSH
43582: LD_INT 48
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 34
43591: PUSH
43592: LD_INT 8
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: PPUSH
43615: CALL_OW 72
43619: DIFF
43620: ST_TO_ADDR
// end ; end_of_file
43621: LD_VAR 0 3
43625: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43626: LD_INT 0
43628: PPUSH
43629: PPUSH
43630: PPUSH
// if not mc_bases or not skirmish then
43631: LD_EXP 50
43635: NOT
43636: PUSH
43637: LD_EXP 48
43641: NOT
43642: OR
43643: IFFALSE 43647
// exit ;
43645: GO 43812
// for i = 1 to mc_bases do
43647: LD_ADDR_VAR 0 4
43651: PUSH
43652: DOUBLE
43653: LD_INT 1
43655: DEC
43656: ST_TO_ADDR
43657: LD_EXP 50
43661: PUSH
43662: FOR_TO
43663: IFFALSE 43810
// begin if sci in mc_bases [ i ] then
43665: LD_VAR 0 2
43669: PUSH
43670: LD_EXP 50
43674: PUSH
43675: LD_VAR 0 4
43679: ARRAY
43680: IN
43681: IFFALSE 43808
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43683: LD_ADDR_EXP 79
43687: PUSH
43688: LD_EXP 79
43692: PPUSH
43693: LD_VAR 0 4
43697: PUSH
43698: LD_EXP 79
43702: PUSH
43703: LD_VAR 0 4
43707: ARRAY
43708: PUSH
43709: LD_INT 1
43711: PLUS
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PPUSH
43717: LD_VAR 0 1
43721: PPUSH
43722: CALL 53394 0 3
43726: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43727: LD_ADDR_VAR 0 5
43731: PUSH
43732: LD_EXP 50
43736: PUSH
43737: LD_VAR 0 4
43741: ARRAY
43742: PPUSH
43743: LD_INT 2
43745: PUSH
43746: LD_INT 30
43748: PUSH
43749: LD_INT 0
43751: PUSH
43752: EMPTY
43753: LIST
43754: LIST
43755: PUSH
43756: LD_INT 30
43758: PUSH
43759: LD_INT 1
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: LIST
43770: PPUSH
43771: CALL_OW 72
43775: PPUSH
43776: LD_VAR 0 1
43780: PPUSH
43781: CALL_OW 74
43785: ST_TO_ADDR
// if tmp then
43786: LD_VAR 0 5
43790: IFFALSE 43806
// ComStandNearbyBuilding ( ape , tmp ) ;
43792: LD_VAR 0 1
43796: PPUSH
43797: LD_VAR 0 5
43801: PPUSH
43802: CALL 49972 0 2
// break ;
43806: GO 43810
// end ; end ;
43808: GO 43662
43810: POP
43811: POP
// end ;
43812: LD_VAR 0 3
43816: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43817: LD_INT 0
43819: PPUSH
43820: PPUSH
43821: PPUSH
// if not mc_bases or not skirmish then
43822: LD_EXP 50
43826: NOT
43827: PUSH
43828: LD_EXP 48
43832: NOT
43833: OR
43834: IFFALSE 43838
// exit ;
43836: GO 43927
// for i = 1 to mc_bases do
43838: LD_ADDR_VAR 0 4
43842: PUSH
43843: DOUBLE
43844: LD_INT 1
43846: DEC
43847: ST_TO_ADDR
43848: LD_EXP 50
43852: PUSH
43853: FOR_TO
43854: IFFALSE 43925
// begin if building in mc_busy_turret_list [ i ] then
43856: LD_VAR 0 1
43860: PUSH
43861: LD_EXP 60
43865: PUSH
43866: LD_VAR 0 4
43870: ARRAY
43871: IN
43872: IFFALSE 43923
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43874: LD_ADDR_VAR 0 5
43878: PUSH
43879: LD_EXP 60
43883: PUSH
43884: LD_VAR 0 4
43888: ARRAY
43889: PUSH
43890: LD_VAR 0 1
43894: DIFF
43895: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43896: LD_ADDR_EXP 60
43900: PUSH
43901: LD_EXP 60
43905: PPUSH
43906: LD_VAR 0 4
43910: PPUSH
43911: LD_VAR 0 5
43915: PPUSH
43916: CALL_OW 1
43920: ST_TO_ADDR
// break ;
43921: GO 43925
// end ; end ;
43923: GO 43853
43925: POP
43926: POP
// end ;
43927: LD_VAR 0 3
43931: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43932: LD_INT 0
43934: PPUSH
43935: PPUSH
43936: PPUSH
// if not mc_bases or not skirmish then
43937: LD_EXP 50
43941: NOT
43942: PUSH
43943: LD_EXP 48
43947: NOT
43948: OR
43949: IFFALSE 43953
// exit ;
43951: GO 44152
// for i = 1 to mc_bases do
43953: LD_ADDR_VAR 0 5
43957: PUSH
43958: DOUBLE
43959: LD_INT 1
43961: DEC
43962: ST_TO_ADDR
43963: LD_EXP 50
43967: PUSH
43968: FOR_TO
43969: IFFALSE 44150
// if building in mc_bases [ i ] then
43971: LD_VAR 0 1
43975: PUSH
43976: LD_EXP 50
43980: PUSH
43981: LD_VAR 0 5
43985: ARRAY
43986: IN
43987: IFFALSE 44148
// begin tmp := mc_bases [ i ] diff building ;
43989: LD_ADDR_VAR 0 6
43993: PUSH
43994: LD_EXP 50
43998: PUSH
43999: LD_VAR 0 5
44003: ARRAY
44004: PUSH
44005: LD_VAR 0 1
44009: DIFF
44010: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44011: LD_ADDR_EXP 50
44015: PUSH
44016: LD_EXP 50
44020: PPUSH
44021: LD_VAR 0 5
44025: PPUSH
44026: LD_VAR 0 6
44030: PPUSH
44031: CALL_OW 1
44035: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44036: LD_VAR 0 1
44040: PUSH
44041: LD_EXP 58
44045: PUSH
44046: LD_VAR 0 5
44050: ARRAY
44051: IN
44052: IFFALSE 44091
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44054: LD_ADDR_EXP 58
44058: PUSH
44059: LD_EXP 58
44063: PPUSH
44064: LD_VAR 0 5
44068: PPUSH
44069: LD_EXP 58
44073: PUSH
44074: LD_VAR 0 5
44078: ARRAY
44079: PUSH
44080: LD_VAR 0 1
44084: DIFF
44085: PPUSH
44086: CALL_OW 1
44090: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44091: LD_VAR 0 1
44095: PUSH
44096: LD_EXP 59
44100: PUSH
44101: LD_VAR 0 5
44105: ARRAY
44106: IN
44107: IFFALSE 44146
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44109: LD_ADDR_EXP 59
44113: PUSH
44114: LD_EXP 59
44118: PPUSH
44119: LD_VAR 0 5
44123: PPUSH
44124: LD_EXP 59
44128: PUSH
44129: LD_VAR 0 5
44133: ARRAY
44134: PUSH
44135: LD_VAR 0 1
44139: DIFF
44140: PPUSH
44141: CALL_OW 1
44145: ST_TO_ADDR
// break ;
44146: GO 44150
// end ;
44148: GO 43968
44150: POP
44151: POP
// end ;
44152: LD_VAR 0 4
44156: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44157: LD_INT 0
44159: PPUSH
44160: PPUSH
44161: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44162: LD_EXP 50
44166: NOT
44167: PUSH
44168: LD_EXP 48
44172: NOT
44173: OR
44174: PUSH
44175: LD_VAR 0 3
44179: PUSH
44180: LD_EXP 76
44184: IN
44185: NOT
44186: OR
44187: IFFALSE 44191
// exit ;
44189: GO 44314
// for i = 1 to mc_vehicles do
44191: LD_ADDR_VAR 0 6
44195: PUSH
44196: DOUBLE
44197: LD_INT 1
44199: DEC
44200: ST_TO_ADDR
44201: LD_EXP 69
44205: PUSH
44206: FOR_TO
44207: IFFALSE 44312
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44209: LD_VAR 0 2
44213: PUSH
44214: LD_EXP 69
44218: PUSH
44219: LD_VAR 0 6
44223: ARRAY
44224: IN
44225: PUSH
44226: LD_VAR 0 1
44230: PUSH
44231: LD_EXP 69
44235: PUSH
44236: LD_VAR 0 6
44240: ARRAY
44241: IN
44242: OR
44243: IFFALSE 44310
// begin tmp := mc_vehicles [ i ] diff old ;
44245: LD_ADDR_VAR 0 7
44249: PUSH
44250: LD_EXP 69
44254: PUSH
44255: LD_VAR 0 6
44259: ARRAY
44260: PUSH
44261: LD_VAR 0 2
44265: DIFF
44266: ST_TO_ADDR
// tmp := tmp diff new ;
44267: LD_ADDR_VAR 0 7
44271: PUSH
44272: LD_VAR 0 7
44276: PUSH
44277: LD_VAR 0 1
44281: DIFF
44282: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44283: LD_ADDR_EXP 69
44287: PUSH
44288: LD_EXP 69
44292: PPUSH
44293: LD_VAR 0 6
44297: PPUSH
44298: LD_VAR 0 7
44302: PPUSH
44303: CALL_OW 1
44307: ST_TO_ADDR
// break ;
44308: GO 44312
// end ;
44310: GO 44206
44312: POP
44313: POP
// end ;
44314: LD_VAR 0 5
44318: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44319: LD_INT 0
44321: PPUSH
44322: PPUSH
44323: PPUSH
44324: PPUSH
// if not mc_bases or not skirmish then
44325: LD_EXP 50
44329: NOT
44330: PUSH
44331: LD_EXP 48
44335: NOT
44336: OR
44337: IFFALSE 44341
// exit ;
44339: GO 44733
// side := GetSide ( vehicle ) ;
44341: LD_ADDR_VAR 0 5
44345: PUSH
44346: LD_VAR 0 1
44350: PPUSH
44351: CALL_OW 255
44355: ST_TO_ADDR
// for i = 1 to mc_bases do
44356: LD_ADDR_VAR 0 4
44360: PUSH
44361: DOUBLE
44362: LD_INT 1
44364: DEC
44365: ST_TO_ADDR
44366: LD_EXP 50
44370: PUSH
44371: FOR_TO
44372: IFFALSE 44731
// begin if factory in mc_bases [ i ] then
44374: LD_VAR 0 2
44378: PUSH
44379: LD_EXP 50
44383: PUSH
44384: LD_VAR 0 4
44388: ARRAY
44389: IN
44390: IFFALSE 44729
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44392: LD_EXP 72
44396: PUSH
44397: LD_VAR 0 4
44401: ARRAY
44402: PUSH
44403: LD_EXP 61
44407: PUSH
44408: LD_VAR 0 4
44412: ARRAY
44413: LESS
44414: PUSH
44415: LD_VAR 0 1
44419: PPUSH
44420: CALL_OW 264
44424: PUSH
44425: LD_INT 31
44427: PUSH
44428: LD_INT 32
44430: PUSH
44431: LD_INT 51
44433: PUSH
44434: LD_EXP 95
44438: PUSH
44439: LD_INT 12
44441: PUSH
44442: LD_INT 30
44444: PUSH
44445: LD_EXP 94
44449: PUSH
44450: LD_INT 11
44452: PUSH
44453: LD_INT 53
44455: PUSH
44456: LD_INT 14
44458: PUSH
44459: LD_EXP 98
44463: PUSH
44464: LD_INT 29
44466: PUSH
44467: LD_EXP 96
44471: PUSH
44472: LD_INT 13
44474: PUSH
44475: LD_INT 52
44477: PUSH
44478: LD_EXP 100
44482: PUSH
44483: LD_INT 48
44485: PUSH
44486: LD_INT 8
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: LIST
44507: LIST
44508: IN
44509: NOT
44510: AND
44511: IFFALSE 44559
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44513: LD_ADDR_EXP 72
44517: PUSH
44518: LD_EXP 72
44522: PPUSH
44523: LD_VAR 0 4
44527: PUSH
44528: LD_EXP 72
44532: PUSH
44533: LD_VAR 0 4
44537: ARRAY
44538: PUSH
44539: LD_INT 1
44541: PLUS
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PPUSH
44547: LD_VAR 0 1
44551: PPUSH
44552: CALL 53394 0 3
44556: ST_TO_ADDR
44557: GO 44603
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44559: LD_ADDR_EXP 69
44563: PUSH
44564: LD_EXP 69
44568: PPUSH
44569: LD_VAR 0 4
44573: PUSH
44574: LD_EXP 69
44578: PUSH
44579: LD_VAR 0 4
44583: ARRAY
44584: PUSH
44585: LD_INT 1
44587: PLUS
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PPUSH
44593: LD_VAR 0 1
44597: PPUSH
44598: CALL 53394 0 3
44602: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44603: LD_VAR 0 1
44607: PPUSH
44608: CALL_OW 263
44612: PUSH
44613: LD_INT 2
44615: EQUAL
44616: IFFALSE 44645
// begin repeat wait ( 0 0$3 ) ;
44618: LD_INT 105
44620: PPUSH
44621: CALL_OW 67
// Connect ( vehicle ) ;
44625: LD_VAR 0 1
44629: PPUSH
44630: CALL 56365 0 1
// until IsControledBy ( vehicle ) ;
44634: LD_VAR 0 1
44638: PPUSH
44639: CALL_OW 312
44643: IFFALSE 44618
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44645: LD_VAR 0 1
44649: PPUSH
44650: LD_EXP 74
44654: PUSH
44655: LD_VAR 0 4
44659: ARRAY
44660: PPUSH
44661: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44665: LD_VAR 0 1
44669: PPUSH
44670: CALL_OW 263
44674: PUSH
44675: LD_INT 1
44677: NONEQUAL
44678: IFFALSE 44682
// break ;
44680: GO 44731
// repeat wait ( 0 0$1 ) ;
44682: LD_INT 35
44684: PPUSH
44685: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44689: LD_VAR 0 1
44693: PPUSH
44694: LD_EXP 74
44698: PUSH
44699: LD_VAR 0 4
44703: ARRAY
44704: PPUSH
44705: CALL_OW 308
44709: IFFALSE 44682
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44711: LD_VAR 0 1
44715: PPUSH
44716: CALL_OW 311
44720: PPUSH
44721: CALL_OW 121
// exit ;
44725: POP
44726: POP
44727: GO 44733
// end ; end ;
44729: GO 44371
44731: POP
44732: POP
// end ;
44733: LD_VAR 0 3
44737: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44738: LD_INT 0
44740: PPUSH
44741: PPUSH
44742: PPUSH
44743: PPUSH
// if not mc_bases or not skirmish then
44744: LD_EXP 50
44748: NOT
44749: PUSH
44750: LD_EXP 48
44754: NOT
44755: OR
44756: IFFALSE 44760
// exit ;
44758: GO 45113
// repeat wait ( 0 0$1 ) ;
44760: LD_INT 35
44762: PPUSH
44763: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44767: LD_VAR 0 2
44771: PPUSH
44772: LD_VAR 0 3
44776: PPUSH
44777: CALL_OW 284
44781: IFFALSE 44760
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44783: LD_VAR 0 2
44787: PPUSH
44788: LD_VAR 0 3
44792: PPUSH
44793: CALL_OW 283
44797: PUSH
44798: LD_INT 4
44800: EQUAL
44801: IFFALSE 44805
// exit ;
44803: GO 45113
// for i = 1 to mc_bases do
44805: LD_ADDR_VAR 0 7
44809: PUSH
44810: DOUBLE
44811: LD_INT 1
44813: DEC
44814: ST_TO_ADDR
44815: LD_EXP 50
44819: PUSH
44820: FOR_TO
44821: IFFALSE 45111
// begin if mc_crates_area [ i ] then
44823: LD_EXP 68
44827: PUSH
44828: LD_VAR 0 7
44832: ARRAY
44833: IFFALSE 44944
// for j in mc_crates_area [ i ] do
44835: LD_ADDR_VAR 0 8
44839: PUSH
44840: LD_EXP 68
44844: PUSH
44845: LD_VAR 0 7
44849: ARRAY
44850: PUSH
44851: FOR_IN
44852: IFFALSE 44942
// if InArea ( x , y , j ) then
44854: LD_VAR 0 2
44858: PPUSH
44859: LD_VAR 0 3
44863: PPUSH
44864: LD_VAR 0 8
44868: PPUSH
44869: CALL_OW 309
44873: IFFALSE 44940
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44875: LD_ADDR_EXP 66
44879: PUSH
44880: LD_EXP 66
44884: PPUSH
44885: LD_VAR 0 7
44889: PUSH
44890: LD_EXP 66
44894: PUSH
44895: LD_VAR 0 7
44899: ARRAY
44900: PUSH
44901: LD_INT 1
44903: PLUS
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PPUSH
44909: LD_VAR 0 4
44913: PUSH
44914: LD_VAR 0 2
44918: PUSH
44919: LD_VAR 0 3
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: LIST
44928: PPUSH
44929: CALL 53394 0 3
44933: ST_TO_ADDR
// exit ;
44934: POP
44935: POP
44936: POP
44937: POP
44938: GO 45113
// end ;
44940: GO 44851
44942: POP
44943: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44944: LD_ADDR_VAR 0 9
44948: PUSH
44949: LD_EXP 50
44953: PUSH
44954: LD_VAR 0 7
44958: ARRAY
44959: PPUSH
44960: LD_INT 2
44962: PUSH
44963: LD_INT 30
44965: PUSH
44966: LD_INT 0
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 30
44975: PUSH
44976: LD_INT 1
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: LIST
44987: PPUSH
44988: CALL_OW 72
44992: ST_TO_ADDR
// if not depot then
44993: LD_VAR 0 9
44997: NOT
44998: IFFALSE 45002
// continue ;
45000: GO 44820
// for j in depot do
45002: LD_ADDR_VAR 0 8
45006: PUSH
45007: LD_VAR 0 9
45011: PUSH
45012: FOR_IN
45013: IFFALSE 45107
// if GetDistUnitXY ( j , x , y ) < 30 then
45015: LD_VAR 0 8
45019: PPUSH
45020: LD_VAR 0 2
45024: PPUSH
45025: LD_VAR 0 3
45029: PPUSH
45030: CALL_OW 297
45034: PUSH
45035: LD_INT 30
45037: LESS
45038: IFFALSE 45105
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45040: LD_ADDR_EXP 66
45044: PUSH
45045: LD_EXP 66
45049: PPUSH
45050: LD_VAR 0 7
45054: PUSH
45055: LD_EXP 66
45059: PUSH
45060: LD_VAR 0 7
45064: ARRAY
45065: PUSH
45066: LD_INT 1
45068: PLUS
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PPUSH
45074: LD_VAR 0 4
45078: PUSH
45079: LD_VAR 0 2
45083: PUSH
45084: LD_VAR 0 3
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: LIST
45093: PPUSH
45094: CALL 53394 0 3
45098: ST_TO_ADDR
// exit ;
45099: POP
45100: POP
45101: POP
45102: POP
45103: GO 45113
// end ;
45105: GO 45012
45107: POP
45108: POP
// end ;
45109: GO 44820
45111: POP
45112: POP
// end ;
45113: LD_VAR 0 6
45117: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45118: LD_INT 0
45120: PPUSH
45121: PPUSH
45122: PPUSH
45123: PPUSH
// if not mc_bases or not skirmish then
45124: LD_EXP 50
45128: NOT
45129: PUSH
45130: LD_EXP 48
45134: NOT
45135: OR
45136: IFFALSE 45140
// exit ;
45138: GO 45417
// side := GetSide ( lab ) ;
45140: LD_ADDR_VAR 0 4
45144: PUSH
45145: LD_VAR 0 2
45149: PPUSH
45150: CALL_OW 255
45154: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45155: LD_VAR 0 4
45159: PUSH
45160: LD_EXP 76
45164: IN
45165: NOT
45166: PUSH
45167: LD_EXP 77
45171: NOT
45172: OR
45173: PUSH
45174: LD_EXP 50
45178: NOT
45179: OR
45180: IFFALSE 45184
// exit ;
45182: GO 45417
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45184: LD_ADDR_EXP 77
45188: PUSH
45189: LD_EXP 77
45193: PPUSH
45194: LD_VAR 0 4
45198: PPUSH
45199: LD_EXP 77
45203: PUSH
45204: LD_VAR 0 4
45208: ARRAY
45209: PUSH
45210: LD_VAR 0 1
45214: DIFF
45215: PPUSH
45216: CALL_OW 1
45220: ST_TO_ADDR
// for i = 1 to mc_bases do
45221: LD_ADDR_VAR 0 5
45225: PUSH
45226: DOUBLE
45227: LD_INT 1
45229: DEC
45230: ST_TO_ADDR
45231: LD_EXP 50
45235: PUSH
45236: FOR_TO
45237: IFFALSE 45415
// begin if lab in mc_bases [ i ] then
45239: LD_VAR 0 2
45243: PUSH
45244: LD_EXP 50
45248: PUSH
45249: LD_VAR 0 5
45253: ARRAY
45254: IN
45255: IFFALSE 45413
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45257: LD_VAR 0 1
45261: PUSH
45262: LD_INT 11
45264: PUSH
45265: LD_INT 4
45267: PUSH
45268: LD_INT 3
45270: PUSH
45271: LD_INT 2
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: IN
45280: PUSH
45281: LD_EXP 80
45285: PUSH
45286: LD_VAR 0 5
45290: ARRAY
45291: AND
45292: IFFALSE 45413
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45294: LD_ADDR_VAR 0 6
45298: PUSH
45299: LD_EXP 80
45303: PUSH
45304: LD_VAR 0 5
45308: ARRAY
45309: PUSH
45310: LD_INT 1
45312: ARRAY
45313: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45314: LD_ADDR_EXP 80
45318: PUSH
45319: LD_EXP 80
45323: PPUSH
45324: LD_VAR 0 5
45328: PPUSH
45329: EMPTY
45330: PPUSH
45331: CALL_OW 1
45335: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45336: LD_VAR 0 6
45340: PPUSH
45341: LD_INT 0
45343: PPUSH
45344: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45348: LD_VAR 0 6
45352: PPUSH
45353: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45357: LD_ADDR_EXP 79
45361: PUSH
45362: LD_EXP 79
45366: PPUSH
45367: LD_VAR 0 5
45371: PPUSH
45372: LD_EXP 79
45376: PUSH
45377: LD_VAR 0 5
45381: ARRAY
45382: PPUSH
45383: LD_INT 1
45385: PPUSH
45386: LD_VAR 0 6
45390: PPUSH
45391: CALL_OW 2
45395: PPUSH
45396: CALL_OW 1
45400: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45401: LD_VAR 0 5
45405: PPUSH
45406: LD_INT 112
45408: PPUSH
45409: CALL 22083 0 2
// end ; end ; end ;
45413: GO 45236
45415: POP
45416: POP
// end ;
45417: LD_VAR 0 3
45421: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45422: LD_INT 0
45424: PPUSH
45425: PPUSH
45426: PPUSH
45427: PPUSH
45428: PPUSH
45429: PPUSH
45430: PPUSH
45431: PPUSH
// if not mc_bases or not skirmish then
45432: LD_EXP 50
45436: NOT
45437: PUSH
45438: LD_EXP 48
45442: NOT
45443: OR
45444: IFFALSE 45448
// exit ;
45446: GO 46819
// for i = 1 to mc_bases do
45448: LD_ADDR_VAR 0 3
45452: PUSH
45453: DOUBLE
45454: LD_INT 1
45456: DEC
45457: ST_TO_ADDR
45458: LD_EXP 50
45462: PUSH
45463: FOR_TO
45464: IFFALSE 46817
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45466: LD_VAR 0 1
45470: PUSH
45471: LD_EXP 50
45475: PUSH
45476: LD_VAR 0 3
45480: ARRAY
45481: IN
45482: PUSH
45483: LD_VAR 0 1
45487: PUSH
45488: LD_EXP 57
45492: PUSH
45493: LD_VAR 0 3
45497: ARRAY
45498: IN
45499: OR
45500: PUSH
45501: LD_VAR 0 1
45505: PUSH
45506: LD_EXP 72
45510: PUSH
45511: LD_VAR 0 3
45515: ARRAY
45516: IN
45517: OR
45518: PUSH
45519: LD_VAR 0 1
45523: PUSH
45524: LD_EXP 69
45528: PUSH
45529: LD_VAR 0 3
45533: ARRAY
45534: IN
45535: OR
45536: PUSH
45537: LD_VAR 0 1
45541: PUSH
45542: LD_EXP 79
45546: PUSH
45547: LD_VAR 0 3
45551: ARRAY
45552: IN
45553: OR
45554: PUSH
45555: LD_VAR 0 1
45559: PUSH
45560: LD_EXP 80
45564: PUSH
45565: LD_VAR 0 3
45569: ARRAY
45570: IN
45571: OR
45572: IFFALSE 46815
// begin if un in mc_ape [ i ] then
45574: LD_VAR 0 1
45578: PUSH
45579: LD_EXP 79
45583: PUSH
45584: LD_VAR 0 3
45588: ARRAY
45589: IN
45590: IFFALSE 45629
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45592: LD_ADDR_EXP 79
45596: PUSH
45597: LD_EXP 79
45601: PPUSH
45602: LD_VAR 0 3
45606: PPUSH
45607: LD_EXP 79
45611: PUSH
45612: LD_VAR 0 3
45616: ARRAY
45617: PUSH
45618: LD_VAR 0 1
45622: DIFF
45623: PPUSH
45624: CALL_OW 1
45628: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45629: LD_VAR 0 1
45633: PUSH
45634: LD_EXP 80
45638: PUSH
45639: LD_VAR 0 3
45643: ARRAY
45644: IN
45645: IFFALSE 45669
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45647: LD_ADDR_EXP 80
45651: PUSH
45652: LD_EXP 80
45656: PPUSH
45657: LD_VAR 0 3
45661: PPUSH
45662: EMPTY
45663: PPUSH
45664: CALL_OW 1
45668: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45669: LD_VAR 0 1
45673: PPUSH
45674: CALL_OW 247
45678: PUSH
45679: LD_INT 2
45681: EQUAL
45682: PUSH
45683: LD_VAR 0 1
45687: PPUSH
45688: CALL_OW 110
45692: PUSH
45693: LD_INT 20
45695: EQUAL
45696: PUSH
45697: LD_VAR 0 1
45701: PUSH
45702: LD_EXP 72
45706: PUSH
45707: LD_VAR 0 3
45711: ARRAY
45712: IN
45713: OR
45714: PUSH
45715: LD_VAR 0 1
45719: PPUSH
45720: CALL_OW 264
45724: PUSH
45725: LD_INT 12
45727: PUSH
45728: LD_INT 51
45730: PUSH
45731: LD_EXP 95
45735: PUSH
45736: LD_INT 32
45738: PUSH
45739: LD_INT 13
45741: PUSH
45742: LD_INT 52
45744: PUSH
45745: LD_INT 31
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: IN
45757: OR
45758: AND
45759: IFFALSE 46067
// begin if un in mc_defender [ i ] then
45761: LD_VAR 0 1
45765: PUSH
45766: LD_EXP 72
45770: PUSH
45771: LD_VAR 0 3
45775: ARRAY
45776: IN
45777: IFFALSE 45816
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45779: LD_ADDR_EXP 72
45783: PUSH
45784: LD_EXP 72
45788: PPUSH
45789: LD_VAR 0 3
45793: PPUSH
45794: LD_EXP 72
45798: PUSH
45799: LD_VAR 0 3
45803: ARRAY
45804: PUSH
45805: LD_VAR 0 1
45809: DIFF
45810: PPUSH
45811: CALL_OW 1
45815: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45816: LD_ADDR_VAR 0 8
45820: PUSH
45821: LD_VAR 0 3
45825: PPUSH
45826: LD_INT 3
45828: PPUSH
45829: CALL 42457 0 2
45833: ST_TO_ADDR
// if fac then
45834: LD_VAR 0 8
45838: IFFALSE 46067
// begin for j in fac do
45840: LD_ADDR_VAR 0 4
45844: PUSH
45845: LD_VAR 0 8
45849: PUSH
45850: FOR_IN
45851: IFFALSE 46065
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45853: LD_ADDR_VAR 0 9
45857: PUSH
45858: LD_VAR 0 8
45862: PPUSH
45863: LD_VAR 0 1
45867: PPUSH
45868: CALL_OW 265
45872: PPUSH
45873: LD_VAR 0 1
45877: PPUSH
45878: CALL_OW 262
45882: PPUSH
45883: LD_VAR 0 1
45887: PPUSH
45888: CALL_OW 263
45892: PPUSH
45893: LD_VAR 0 1
45897: PPUSH
45898: CALL_OW 264
45902: PPUSH
45903: CALL 50890 0 5
45907: ST_TO_ADDR
// if components then
45908: LD_VAR 0 9
45912: IFFALSE 46063
// begin if GetWeapon ( un ) = ar_control_tower then
45914: LD_VAR 0 1
45918: PPUSH
45919: CALL_OW 264
45923: PUSH
45924: LD_INT 31
45926: EQUAL
45927: IFFALSE 46044
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45929: LD_VAR 0 1
45933: PPUSH
45934: CALL_OW 311
45938: PPUSH
45939: LD_INT 0
45941: PPUSH
45942: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45946: LD_ADDR_EXP 90
45950: PUSH
45951: LD_EXP 90
45955: PPUSH
45956: LD_VAR 0 3
45960: PPUSH
45961: LD_EXP 90
45965: PUSH
45966: LD_VAR 0 3
45970: ARRAY
45971: PUSH
45972: LD_VAR 0 1
45976: PPUSH
45977: CALL_OW 311
45981: DIFF
45982: PPUSH
45983: CALL_OW 1
45987: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45988: LD_ADDR_VAR 0 7
45992: PUSH
45993: LD_EXP 71
45997: PUSH
45998: LD_VAR 0 3
46002: ARRAY
46003: PPUSH
46004: LD_INT 1
46006: PPUSH
46007: LD_VAR 0 9
46011: PPUSH
46012: CALL_OW 2
46016: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46017: LD_ADDR_EXP 71
46021: PUSH
46022: LD_EXP 71
46026: PPUSH
46027: LD_VAR 0 3
46031: PPUSH
46032: LD_VAR 0 7
46036: PPUSH
46037: CALL_OW 1
46041: ST_TO_ADDR
// end else
46042: GO 46061
// MC_InsertProduceList ( i , [ components ] ) ;
46044: LD_VAR 0 3
46048: PPUSH
46049: LD_VAR 0 9
46053: PUSH
46054: EMPTY
46055: LIST
46056: PPUSH
46057: CALL 42002 0 2
// break ;
46061: GO 46065
// end ; end ;
46063: GO 45850
46065: POP
46066: POP
// end ; end ; if GetType ( un ) = unit_building then
46067: LD_VAR 0 1
46071: PPUSH
46072: CALL_OW 247
46076: PUSH
46077: LD_INT 3
46079: EQUAL
46080: IFFALSE 46483
// begin btype := GetBType ( un ) ;
46082: LD_ADDR_VAR 0 5
46086: PUSH
46087: LD_VAR 0 1
46091: PPUSH
46092: CALL_OW 266
46096: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46097: LD_VAR 0 5
46101: PUSH
46102: LD_INT 29
46104: PUSH
46105: LD_INT 30
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: IN
46112: IFFALSE 46185
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46114: LD_VAR 0 1
46118: PPUSH
46119: CALL_OW 250
46123: PPUSH
46124: LD_VAR 0 1
46128: PPUSH
46129: CALL_OW 251
46133: PPUSH
46134: LD_VAR 0 1
46138: PPUSH
46139: CALL_OW 255
46143: PPUSH
46144: CALL_OW 440
46148: NOT
46149: IFFALSE 46185
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46151: LD_VAR 0 1
46155: PPUSH
46156: CALL_OW 250
46160: PPUSH
46161: LD_VAR 0 1
46165: PPUSH
46166: CALL_OW 251
46170: PPUSH
46171: LD_VAR 0 1
46175: PPUSH
46176: CALL_OW 255
46180: PPUSH
46181: CALL_OW 441
// end ; if btype = b_warehouse then
46185: LD_VAR 0 5
46189: PUSH
46190: LD_INT 1
46192: EQUAL
46193: IFFALSE 46211
// begin btype := b_depot ;
46195: LD_ADDR_VAR 0 5
46199: PUSH
46200: LD_INT 0
46202: ST_TO_ADDR
// pos := 1 ;
46203: LD_ADDR_VAR 0 6
46207: PUSH
46208: LD_INT 1
46210: ST_TO_ADDR
// end ; if btype = b_factory then
46211: LD_VAR 0 5
46215: PUSH
46216: LD_INT 3
46218: EQUAL
46219: IFFALSE 46237
// begin btype := b_workshop ;
46221: LD_ADDR_VAR 0 5
46225: PUSH
46226: LD_INT 2
46228: ST_TO_ADDR
// pos := 1 ;
46229: LD_ADDR_VAR 0 6
46233: PUSH
46234: LD_INT 1
46236: ST_TO_ADDR
// end ; if btype = b_barracks then
46237: LD_VAR 0 5
46241: PUSH
46242: LD_INT 5
46244: EQUAL
46245: IFFALSE 46255
// btype := b_armoury ;
46247: LD_ADDR_VAR 0 5
46251: PUSH
46252: LD_INT 4
46254: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46255: LD_VAR 0 5
46259: PUSH
46260: LD_INT 7
46262: PUSH
46263: LD_INT 8
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: IN
46270: IFFALSE 46280
// btype := b_lab ;
46272: LD_ADDR_VAR 0 5
46276: PUSH
46277: LD_INT 6
46279: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46280: LD_ADDR_EXP 55
46284: PUSH
46285: LD_EXP 55
46289: PPUSH
46290: LD_VAR 0 3
46294: PUSH
46295: LD_EXP 55
46299: PUSH
46300: LD_VAR 0 3
46304: ARRAY
46305: PUSH
46306: LD_INT 1
46308: PLUS
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PPUSH
46314: LD_VAR 0 5
46318: PUSH
46319: LD_VAR 0 1
46323: PPUSH
46324: CALL_OW 250
46328: PUSH
46329: LD_VAR 0 1
46333: PPUSH
46334: CALL_OW 251
46338: PUSH
46339: LD_VAR 0 1
46343: PPUSH
46344: CALL_OW 254
46348: PUSH
46349: EMPTY
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: PPUSH
46355: CALL 53394 0 3
46359: ST_TO_ADDR
// if pos = 1 then
46360: LD_VAR 0 6
46364: PUSH
46365: LD_INT 1
46367: EQUAL
46368: IFFALSE 46483
// begin tmp := mc_build_list [ i ] ;
46370: LD_ADDR_VAR 0 7
46374: PUSH
46375: LD_EXP 55
46379: PUSH
46380: LD_VAR 0 3
46384: ARRAY
46385: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46386: LD_VAR 0 7
46390: PPUSH
46391: LD_INT 2
46393: PUSH
46394: LD_INT 30
46396: PUSH
46397: LD_INT 0
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PUSH
46404: LD_INT 30
46406: PUSH
46407: LD_INT 1
46409: PUSH
46410: EMPTY
46411: LIST
46412: LIST
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: LIST
46418: PPUSH
46419: CALL_OW 72
46423: IFFALSE 46433
// pos := 2 ;
46425: LD_ADDR_VAR 0 6
46429: PUSH
46430: LD_INT 2
46432: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46433: LD_ADDR_VAR 0 7
46437: PUSH
46438: LD_VAR 0 7
46442: PPUSH
46443: LD_VAR 0 6
46447: PPUSH
46448: LD_VAR 0 7
46452: PPUSH
46453: CALL 53720 0 3
46457: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46458: LD_ADDR_EXP 55
46462: PUSH
46463: LD_EXP 55
46467: PPUSH
46468: LD_VAR 0 3
46472: PPUSH
46473: LD_VAR 0 7
46477: PPUSH
46478: CALL_OW 1
46482: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46483: LD_VAR 0 1
46487: PUSH
46488: LD_EXP 50
46492: PUSH
46493: LD_VAR 0 3
46497: ARRAY
46498: IN
46499: IFFALSE 46538
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46501: LD_ADDR_EXP 50
46505: PUSH
46506: LD_EXP 50
46510: PPUSH
46511: LD_VAR 0 3
46515: PPUSH
46516: LD_EXP 50
46520: PUSH
46521: LD_VAR 0 3
46525: ARRAY
46526: PUSH
46527: LD_VAR 0 1
46531: DIFF
46532: PPUSH
46533: CALL_OW 1
46537: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46538: LD_VAR 0 1
46542: PUSH
46543: LD_EXP 57
46547: PUSH
46548: LD_VAR 0 3
46552: ARRAY
46553: IN
46554: IFFALSE 46593
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46556: LD_ADDR_EXP 57
46560: PUSH
46561: LD_EXP 57
46565: PPUSH
46566: LD_VAR 0 3
46570: PPUSH
46571: LD_EXP 57
46575: PUSH
46576: LD_VAR 0 3
46580: ARRAY
46581: PUSH
46582: LD_VAR 0 1
46586: DIFF
46587: PPUSH
46588: CALL_OW 1
46592: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46593: LD_VAR 0 1
46597: PUSH
46598: LD_EXP 69
46602: PUSH
46603: LD_VAR 0 3
46607: ARRAY
46608: IN
46609: IFFALSE 46648
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46611: LD_ADDR_EXP 69
46615: PUSH
46616: LD_EXP 69
46620: PPUSH
46621: LD_VAR 0 3
46625: PPUSH
46626: LD_EXP 69
46630: PUSH
46631: LD_VAR 0 3
46635: ARRAY
46636: PUSH
46637: LD_VAR 0 1
46641: DIFF
46642: PPUSH
46643: CALL_OW 1
46647: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46648: LD_VAR 0 1
46652: PUSH
46653: LD_EXP 72
46657: PUSH
46658: LD_VAR 0 3
46662: ARRAY
46663: IN
46664: IFFALSE 46703
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46666: LD_ADDR_EXP 72
46670: PUSH
46671: LD_EXP 72
46675: PPUSH
46676: LD_VAR 0 3
46680: PPUSH
46681: LD_EXP 72
46685: PUSH
46686: LD_VAR 0 3
46690: ARRAY
46691: PUSH
46692: LD_VAR 0 1
46696: DIFF
46697: PPUSH
46698: CALL_OW 1
46702: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46703: LD_VAR 0 1
46707: PUSH
46708: LD_EXP 59
46712: PUSH
46713: LD_VAR 0 3
46717: ARRAY
46718: IN
46719: IFFALSE 46758
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46721: LD_ADDR_EXP 59
46725: PUSH
46726: LD_EXP 59
46730: PPUSH
46731: LD_VAR 0 3
46735: PPUSH
46736: LD_EXP 59
46740: PUSH
46741: LD_VAR 0 3
46745: ARRAY
46746: PUSH
46747: LD_VAR 0 1
46751: DIFF
46752: PPUSH
46753: CALL_OW 1
46757: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46758: LD_VAR 0 1
46762: PUSH
46763: LD_EXP 58
46767: PUSH
46768: LD_VAR 0 3
46772: ARRAY
46773: IN
46774: IFFALSE 46813
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46776: LD_ADDR_EXP 58
46780: PUSH
46781: LD_EXP 58
46785: PPUSH
46786: LD_VAR 0 3
46790: PPUSH
46791: LD_EXP 58
46795: PUSH
46796: LD_VAR 0 3
46800: ARRAY
46801: PUSH
46802: LD_VAR 0 1
46806: DIFF
46807: PPUSH
46808: CALL_OW 1
46812: ST_TO_ADDR
// end ; break ;
46813: GO 46817
// end ;
46815: GO 45463
46817: POP
46818: POP
// end ;
46819: LD_VAR 0 2
46823: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46824: LD_INT 0
46826: PPUSH
46827: PPUSH
46828: PPUSH
// if not mc_bases or not skirmish then
46829: LD_EXP 50
46833: NOT
46834: PUSH
46835: LD_EXP 48
46839: NOT
46840: OR
46841: IFFALSE 46845
// exit ;
46843: GO 47060
// for i = 1 to mc_bases do
46845: LD_ADDR_VAR 0 3
46849: PUSH
46850: DOUBLE
46851: LD_INT 1
46853: DEC
46854: ST_TO_ADDR
46855: LD_EXP 50
46859: PUSH
46860: FOR_TO
46861: IFFALSE 47058
// begin if building in mc_construct_list [ i ] then
46863: LD_VAR 0 1
46867: PUSH
46868: LD_EXP 57
46872: PUSH
46873: LD_VAR 0 3
46877: ARRAY
46878: IN
46879: IFFALSE 47056
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46881: LD_ADDR_EXP 57
46885: PUSH
46886: LD_EXP 57
46890: PPUSH
46891: LD_VAR 0 3
46895: PPUSH
46896: LD_EXP 57
46900: PUSH
46901: LD_VAR 0 3
46905: ARRAY
46906: PUSH
46907: LD_VAR 0 1
46911: DIFF
46912: PPUSH
46913: CALL_OW 1
46917: ST_TO_ADDR
// if building in mc_lab [ i ] then
46918: LD_VAR 0 1
46922: PUSH
46923: LD_EXP 83
46927: PUSH
46928: LD_VAR 0 3
46932: ARRAY
46933: IN
46934: IFFALSE 46989
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46936: LD_ADDR_EXP 84
46940: PUSH
46941: LD_EXP 84
46945: PPUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: LD_EXP 84
46955: PUSH
46956: LD_VAR 0 3
46960: ARRAY
46961: PPUSH
46962: LD_INT 1
46964: PPUSH
46965: LD_EXP 84
46969: PUSH
46970: LD_VAR 0 3
46974: ARRAY
46975: PPUSH
46976: LD_INT 0
46978: PPUSH
46979: CALL 52812 0 4
46983: PPUSH
46984: CALL_OW 1
46988: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46989: LD_VAR 0 1
46993: PUSH
46994: LD_EXP 50
46998: PUSH
46999: LD_VAR 0 3
47003: ARRAY
47004: IN
47005: NOT
47006: IFFALSE 47052
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47008: LD_ADDR_EXP 50
47012: PUSH
47013: LD_EXP 50
47017: PPUSH
47018: LD_VAR 0 3
47022: PUSH
47023: LD_EXP 50
47027: PUSH
47028: LD_VAR 0 3
47032: ARRAY
47033: PUSH
47034: LD_INT 1
47036: PLUS
47037: PUSH
47038: EMPTY
47039: LIST
47040: LIST
47041: PPUSH
47042: LD_VAR 0 1
47046: PPUSH
47047: CALL 53394 0 3
47051: ST_TO_ADDR
// exit ;
47052: POP
47053: POP
47054: GO 47060
// end ; end ;
47056: GO 46860
47058: POP
47059: POP
// end ;
47060: LD_VAR 0 2
47064: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47065: LD_INT 0
47067: PPUSH
47068: PPUSH
47069: PPUSH
47070: PPUSH
47071: PPUSH
47072: PPUSH
47073: PPUSH
// if not mc_bases or not skirmish then
47074: LD_EXP 50
47078: NOT
47079: PUSH
47080: LD_EXP 48
47084: NOT
47085: OR
47086: IFFALSE 47090
// exit ;
47088: GO 47751
// for i = 1 to mc_bases do
47090: LD_ADDR_VAR 0 3
47094: PUSH
47095: DOUBLE
47096: LD_INT 1
47098: DEC
47099: ST_TO_ADDR
47100: LD_EXP 50
47104: PUSH
47105: FOR_TO
47106: IFFALSE 47749
// begin if building in mc_construct_list [ i ] then
47108: LD_VAR 0 1
47112: PUSH
47113: LD_EXP 57
47117: PUSH
47118: LD_VAR 0 3
47122: ARRAY
47123: IN
47124: IFFALSE 47747
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47126: LD_ADDR_EXP 57
47130: PUSH
47131: LD_EXP 57
47135: PPUSH
47136: LD_VAR 0 3
47140: PPUSH
47141: LD_EXP 57
47145: PUSH
47146: LD_VAR 0 3
47150: ARRAY
47151: PUSH
47152: LD_VAR 0 1
47156: DIFF
47157: PPUSH
47158: CALL_OW 1
47162: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47163: LD_ADDR_EXP 50
47167: PUSH
47168: LD_EXP 50
47172: PPUSH
47173: LD_VAR 0 3
47177: PUSH
47178: LD_EXP 50
47182: PUSH
47183: LD_VAR 0 3
47187: ARRAY
47188: PUSH
47189: LD_INT 1
47191: PLUS
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PPUSH
47197: LD_VAR 0 1
47201: PPUSH
47202: CALL 53394 0 3
47206: ST_TO_ADDR
// btype := GetBType ( building ) ;
47207: LD_ADDR_VAR 0 5
47211: PUSH
47212: LD_VAR 0 1
47216: PPUSH
47217: CALL_OW 266
47221: ST_TO_ADDR
// side := GetSide ( building ) ;
47222: LD_ADDR_VAR 0 8
47226: PUSH
47227: LD_VAR 0 1
47231: PPUSH
47232: CALL_OW 255
47236: ST_TO_ADDR
// if btype = b_lab then
47237: LD_VAR 0 5
47241: PUSH
47242: LD_INT 6
47244: EQUAL
47245: IFFALSE 47295
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47247: LD_ADDR_EXP 83
47251: PUSH
47252: LD_EXP 83
47256: PPUSH
47257: LD_VAR 0 3
47261: PUSH
47262: LD_EXP 83
47266: PUSH
47267: LD_VAR 0 3
47271: ARRAY
47272: PUSH
47273: LD_INT 1
47275: PLUS
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PPUSH
47281: LD_VAR 0 1
47285: PPUSH
47286: CALL 53394 0 3
47290: ST_TO_ADDR
// exit ;
47291: POP
47292: POP
47293: GO 47751
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47295: LD_VAR 0 5
47299: PUSH
47300: LD_INT 0
47302: PUSH
47303: LD_INT 2
47305: PUSH
47306: LD_INT 4
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: LIST
47313: IN
47314: IFFALSE 47438
// begin if btype = b_armoury then
47316: LD_VAR 0 5
47320: PUSH
47321: LD_INT 4
47323: EQUAL
47324: IFFALSE 47334
// btype := b_barracks ;
47326: LD_ADDR_VAR 0 5
47330: PUSH
47331: LD_INT 5
47333: ST_TO_ADDR
// if btype = b_depot then
47334: LD_VAR 0 5
47338: PUSH
47339: LD_INT 0
47341: EQUAL
47342: IFFALSE 47352
// btype := b_warehouse ;
47344: LD_ADDR_VAR 0 5
47348: PUSH
47349: LD_INT 1
47351: ST_TO_ADDR
// if btype = b_workshop then
47352: LD_VAR 0 5
47356: PUSH
47357: LD_INT 2
47359: EQUAL
47360: IFFALSE 47370
// btype := b_factory ;
47362: LD_ADDR_VAR 0 5
47366: PUSH
47367: LD_INT 3
47369: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47370: LD_VAR 0 5
47374: PPUSH
47375: LD_VAR 0 8
47379: PPUSH
47380: CALL_OW 323
47384: PUSH
47385: LD_INT 1
47387: EQUAL
47388: IFFALSE 47434
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47390: LD_ADDR_EXP 82
47394: PUSH
47395: LD_EXP 82
47399: PPUSH
47400: LD_VAR 0 3
47404: PUSH
47405: LD_EXP 82
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: PUSH
47416: LD_INT 1
47418: PLUS
47419: PUSH
47420: EMPTY
47421: LIST
47422: LIST
47423: PPUSH
47424: LD_VAR 0 1
47428: PPUSH
47429: CALL 53394 0 3
47433: ST_TO_ADDR
// exit ;
47434: POP
47435: POP
47436: GO 47751
// end ; if btype in [ b_bunker , b_turret ] then
47438: LD_VAR 0 5
47442: PUSH
47443: LD_INT 32
47445: PUSH
47446: LD_INT 33
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: IN
47453: IFFALSE 47743
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47455: LD_ADDR_EXP 58
47459: PUSH
47460: LD_EXP 58
47464: PPUSH
47465: LD_VAR 0 3
47469: PUSH
47470: LD_EXP 58
47474: PUSH
47475: LD_VAR 0 3
47479: ARRAY
47480: PUSH
47481: LD_INT 1
47483: PLUS
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PPUSH
47489: LD_VAR 0 1
47493: PPUSH
47494: CALL 53394 0 3
47498: ST_TO_ADDR
// if btype = b_bunker then
47499: LD_VAR 0 5
47503: PUSH
47504: LD_INT 32
47506: EQUAL
47507: IFFALSE 47743
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47509: LD_ADDR_EXP 59
47513: PUSH
47514: LD_EXP 59
47518: PPUSH
47519: LD_VAR 0 3
47523: PUSH
47524: LD_EXP 59
47528: PUSH
47529: LD_VAR 0 3
47533: ARRAY
47534: PUSH
47535: LD_INT 1
47537: PLUS
47538: PUSH
47539: EMPTY
47540: LIST
47541: LIST
47542: PPUSH
47543: LD_VAR 0 1
47547: PPUSH
47548: CALL 53394 0 3
47552: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47553: LD_ADDR_VAR 0 6
47557: PUSH
47558: LD_EXP 50
47562: PUSH
47563: LD_VAR 0 3
47567: ARRAY
47568: PPUSH
47569: LD_INT 25
47571: PUSH
47572: LD_INT 1
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: LD_INT 3
47581: PUSH
47582: LD_INT 54
47584: PUSH
47585: EMPTY
47586: LIST
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PPUSH
47596: CALL_OW 72
47600: ST_TO_ADDR
// if tmp then
47601: LD_VAR 0 6
47605: IFFALSE 47611
// exit ;
47607: POP
47608: POP
47609: GO 47751
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47611: LD_ADDR_VAR 0 6
47615: PUSH
47616: LD_EXP 50
47620: PUSH
47621: LD_VAR 0 3
47625: ARRAY
47626: PPUSH
47627: LD_INT 2
47629: PUSH
47630: LD_INT 30
47632: PUSH
47633: LD_INT 4
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: LD_INT 30
47642: PUSH
47643: LD_INT 5
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: PPUSH
47655: CALL_OW 72
47659: ST_TO_ADDR
// if not tmp then
47660: LD_VAR 0 6
47664: NOT
47665: IFFALSE 47671
// exit ;
47667: POP
47668: POP
47669: GO 47751
// for j in tmp do
47671: LD_ADDR_VAR 0 4
47675: PUSH
47676: LD_VAR 0 6
47680: PUSH
47681: FOR_IN
47682: IFFALSE 47741
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47684: LD_ADDR_VAR 0 7
47688: PUSH
47689: LD_VAR 0 4
47693: PPUSH
47694: CALL_OW 313
47698: PPUSH
47699: LD_INT 25
47701: PUSH
47702: LD_INT 1
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: PPUSH
47709: CALL_OW 72
47713: ST_TO_ADDR
// if units then
47714: LD_VAR 0 7
47718: IFFALSE 47739
// begin ComExitBuilding ( units [ 1 ] ) ;
47720: LD_VAR 0 7
47724: PUSH
47725: LD_INT 1
47727: ARRAY
47728: PPUSH
47729: CALL_OW 122
// exit ;
47733: POP
47734: POP
47735: POP
47736: POP
47737: GO 47751
// end ; end ;
47739: GO 47681
47741: POP
47742: POP
// end ; end ; exit ;
47743: POP
47744: POP
47745: GO 47751
// end ; end ;
47747: GO 47105
47749: POP
47750: POP
// end ;
47751: LD_VAR 0 2
47755: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47756: LD_INT 0
47758: PPUSH
47759: PPUSH
47760: PPUSH
47761: PPUSH
47762: PPUSH
47763: PPUSH
47764: PPUSH
// if not mc_bases or not skirmish then
47765: LD_EXP 50
47769: NOT
47770: PUSH
47771: LD_EXP 48
47775: NOT
47776: OR
47777: IFFALSE 47781
// exit ;
47779: GO 48046
// btype := GetBType ( building ) ;
47781: LD_ADDR_VAR 0 6
47785: PUSH
47786: LD_VAR 0 1
47790: PPUSH
47791: CALL_OW 266
47795: ST_TO_ADDR
// x := GetX ( building ) ;
47796: LD_ADDR_VAR 0 7
47800: PUSH
47801: LD_VAR 0 1
47805: PPUSH
47806: CALL_OW 250
47810: ST_TO_ADDR
// y := GetY ( building ) ;
47811: LD_ADDR_VAR 0 8
47815: PUSH
47816: LD_VAR 0 1
47820: PPUSH
47821: CALL_OW 251
47825: ST_TO_ADDR
// d := GetDir ( building ) ;
47826: LD_ADDR_VAR 0 9
47830: PUSH
47831: LD_VAR 0 1
47835: PPUSH
47836: CALL_OW 254
47840: ST_TO_ADDR
// for i = 1 to mc_bases do
47841: LD_ADDR_VAR 0 4
47845: PUSH
47846: DOUBLE
47847: LD_INT 1
47849: DEC
47850: ST_TO_ADDR
47851: LD_EXP 50
47855: PUSH
47856: FOR_TO
47857: IFFALSE 48044
// begin if not mc_build_list [ i ] then
47859: LD_EXP 55
47863: PUSH
47864: LD_VAR 0 4
47868: ARRAY
47869: NOT
47870: IFFALSE 47874
// continue ;
47872: GO 47856
// for j := 1 to mc_build_list [ i ] do
47874: LD_ADDR_VAR 0 5
47878: PUSH
47879: DOUBLE
47880: LD_INT 1
47882: DEC
47883: ST_TO_ADDR
47884: LD_EXP 55
47888: PUSH
47889: LD_VAR 0 4
47893: ARRAY
47894: PUSH
47895: FOR_TO
47896: IFFALSE 48040
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
47898: LD_VAR 0 6
47902: PUSH
47903: LD_VAR 0 7
47907: PUSH
47908: LD_VAR 0 8
47912: PUSH
47913: LD_VAR 0 9
47917: PUSH
47918: EMPTY
47919: LIST
47920: LIST
47921: LIST
47922: LIST
47923: PPUSH
47924: LD_EXP 55
47928: PUSH
47929: LD_VAR 0 4
47933: ARRAY
47934: PUSH
47935: LD_VAR 0 5
47939: ARRAY
47940: PPUSH
47941: CALL 59576 0 2
47945: IFFALSE 48038
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
47947: LD_ADDR_EXP 55
47951: PUSH
47952: LD_EXP 55
47956: PPUSH
47957: LD_VAR 0 4
47961: PPUSH
47962: LD_EXP 55
47966: PUSH
47967: LD_VAR 0 4
47971: ARRAY
47972: PPUSH
47973: LD_VAR 0 5
47977: PPUSH
47978: CALL_OW 3
47982: PPUSH
47983: CALL_OW 1
47987: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47988: LD_ADDR_EXP 57
47992: PUSH
47993: LD_EXP 57
47997: PPUSH
47998: LD_VAR 0 4
48002: PUSH
48003: LD_EXP 57
48007: PUSH
48008: LD_VAR 0 4
48012: ARRAY
48013: PUSH
48014: LD_INT 1
48016: PLUS
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PPUSH
48022: LD_VAR 0 1
48026: PPUSH
48027: CALL 53394 0 3
48031: ST_TO_ADDR
// exit ;
48032: POP
48033: POP
48034: POP
48035: POP
48036: GO 48046
// end ;
48038: GO 47895
48040: POP
48041: POP
// end ;
48042: GO 47856
48044: POP
48045: POP
// end ;
48046: LD_VAR 0 3
48050: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48051: LD_INT 0
48053: PPUSH
48054: PPUSH
48055: PPUSH
// if not mc_bases or not skirmish then
48056: LD_EXP 50
48060: NOT
48061: PUSH
48062: LD_EXP 48
48066: NOT
48067: OR
48068: IFFALSE 48072
// exit ;
48070: GO 48262
// for i = 1 to mc_bases do
48072: LD_ADDR_VAR 0 4
48076: PUSH
48077: DOUBLE
48078: LD_INT 1
48080: DEC
48081: ST_TO_ADDR
48082: LD_EXP 50
48086: PUSH
48087: FOR_TO
48088: IFFALSE 48175
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48090: LD_VAR 0 1
48094: PUSH
48095: LD_EXP 58
48099: PUSH
48100: LD_VAR 0 4
48104: ARRAY
48105: IN
48106: PUSH
48107: LD_VAR 0 1
48111: PUSH
48112: LD_EXP 59
48116: PUSH
48117: LD_VAR 0 4
48121: ARRAY
48122: IN
48123: NOT
48124: AND
48125: IFFALSE 48173
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48127: LD_ADDR_EXP 59
48131: PUSH
48132: LD_EXP 59
48136: PPUSH
48137: LD_VAR 0 4
48141: PUSH
48142: LD_EXP 59
48146: PUSH
48147: LD_VAR 0 4
48151: ARRAY
48152: PUSH
48153: LD_INT 1
48155: PLUS
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PPUSH
48161: LD_VAR 0 1
48165: PPUSH
48166: CALL 53394 0 3
48170: ST_TO_ADDR
// break ;
48171: GO 48175
// end ; end ;
48173: GO 48087
48175: POP
48176: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 257
48186: PUSH
48187: LD_EXP 76
48191: IN
48192: PUSH
48193: LD_VAR 0 1
48197: PPUSH
48198: CALL_OW 266
48202: PUSH
48203: LD_INT 5
48205: EQUAL
48206: AND
48207: PUSH
48208: LD_VAR 0 2
48212: PPUSH
48213: CALL_OW 110
48217: PUSH
48218: LD_INT 18
48220: NONEQUAL
48221: AND
48222: IFFALSE 48262
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48224: LD_VAR 0 2
48228: PPUSH
48229: CALL_OW 257
48233: PUSH
48234: LD_INT 5
48236: PUSH
48237: LD_INT 8
48239: PUSH
48240: LD_INT 9
48242: PUSH
48243: EMPTY
48244: LIST
48245: LIST
48246: LIST
48247: IN
48248: IFFALSE 48262
// SetClass ( unit , 1 ) ;
48250: LD_VAR 0 2
48254: PPUSH
48255: LD_INT 1
48257: PPUSH
48258: CALL_OW 336
// end ;
48262: LD_VAR 0 3
48266: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48267: LD_INT 0
48269: PPUSH
48270: PPUSH
// if not mc_bases or not skirmish then
48271: LD_EXP 50
48275: NOT
48276: PUSH
48277: LD_EXP 48
48281: NOT
48282: OR
48283: IFFALSE 48287
// exit ;
48285: GO 48403
// if GetLives ( abandoned_vehicle ) > 250 then
48287: LD_VAR 0 2
48291: PPUSH
48292: CALL_OW 256
48296: PUSH
48297: LD_INT 250
48299: GREATER
48300: IFFALSE 48304
// exit ;
48302: GO 48403
// for i = 1 to mc_bases do
48304: LD_ADDR_VAR 0 6
48308: PUSH
48309: DOUBLE
48310: LD_INT 1
48312: DEC
48313: ST_TO_ADDR
48314: LD_EXP 50
48318: PUSH
48319: FOR_TO
48320: IFFALSE 48401
// begin if driver in mc_bases [ i ] then
48322: LD_VAR 0 1
48326: PUSH
48327: LD_EXP 50
48331: PUSH
48332: LD_VAR 0 6
48336: ARRAY
48337: IN
48338: IFFALSE 48399
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48340: LD_VAR 0 1
48344: PPUSH
48345: LD_EXP 50
48349: PUSH
48350: LD_VAR 0 6
48354: ARRAY
48355: PPUSH
48356: LD_INT 2
48358: PUSH
48359: LD_INT 30
48361: PUSH
48362: LD_INT 0
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: LD_INT 30
48371: PUSH
48372: LD_INT 1
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: LIST
48383: PPUSH
48384: CALL_OW 72
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PPUSH
48393: CALL 86012 0 2
// break ;
48397: GO 48401
// end ; end ;
48399: GO 48319
48401: POP
48402: POP
// end ; end_of_file
48403: LD_VAR 0 5
48407: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48408: LD_INT 0
48410: PPUSH
48411: PPUSH
// if exist_mode then
48412: LD_VAR 0 2
48416: IFFALSE 48441
// unit := CreateCharacter ( prefix & ident ) else
48418: LD_ADDR_VAR 0 5
48422: PUSH
48423: LD_VAR 0 3
48427: PUSH
48428: LD_VAR 0 1
48432: STR
48433: PPUSH
48434: CALL_OW 34
48438: ST_TO_ADDR
48439: GO 48456
// unit := NewCharacter ( ident ) ;
48441: LD_ADDR_VAR 0 5
48445: PUSH
48446: LD_VAR 0 1
48450: PPUSH
48451: CALL_OW 25
48455: ST_TO_ADDR
// result := unit ;
48456: LD_ADDR_VAR 0 4
48460: PUSH
48461: LD_VAR 0 5
48465: ST_TO_ADDR
// end ;
48466: LD_VAR 0 4
48470: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48471: LD_INT 0
48473: PPUSH
48474: PPUSH
// if not side or not nation then
48475: LD_VAR 0 1
48479: NOT
48480: PUSH
48481: LD_VAR 0 2
48485: NOT
48486: OR
48487: IFFALSE 48491
// exit ;
48489: GO 49259
// case nation of nation_american :
48491: LD_VAR 0 2
48495: PUSH
48496: LD_INT 1
48498: DOUBLE
48499: EQUAL
48500: IFTRUE 48504
48502: GO 48718
48504: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48505: LD_ADDR_VAR 0 4
48509: PUSH
48510: LD_INT 35
48512: PUSH
48513: LD_INT 45
48515: PUSH
48516: LD_INT 46
48518: PUSH
48519: LD_INT 47
48521: PUSH
48522: LD_INT 82
48524: PUSH
48525: LD_INT 83
48527: PUSH
48528: LD_INT 84
48530: PUSH
48531: LD_INT 85
48533: PUSH
48534: LD_INT 86
48536: PUSH
48537: LD_INT 1
48539: PUSH
48540: LD_INT 2
48542: PUSH
48543: LD_INT 6
48545: PUSH
48546: LD_INT 15
48548: PUSH
48549: LD_INT 16
48551: PUSH
48552: LD_INT 7
48554: PUSH
48555: LD_INT 12
48557: PUSH
48558: LD_INT 13
48560: PUSH
48561: LD_INT 10
48563: PUSH
48564: LD_INT 14
48566: PUSH
48567: LD_INT 20
48569: PUSH
48570: LD_INT 21
48572: PUSH
48573: LD_INT 22
48575: PUSH
48576: LD_INT 25
48578: PUSH
48579: LD_INT 32
48581: PUSH
48582: LD_INT 27
48584: PUSH
48585: LD_INT 36
48587: PUSH
48588: LD_INT 69
48590: PUSH
48591: LD_INT 39
48593: PUSH
48594: LD_INT 34
48596: PUSH
48597: LD_INT 40
48599: PUSH
48600: LD_INT 48
48602: PUSH
48603: LD_INT 49
48605: PUSH
48606: LD_INT 50
48608: PUSH
48609: LD_INT 51
48611: PUSH
48612: LD_INT 52
48614: PUSH
48615: LD_INT 53
48617: PUSH
48618: LD_INT 54
48620: PUSH
48621: LD_INT 55
48623: PUSH
48624: LD_INT 56
48626: PUSH
48627: LD_INT 57
48629: PUSH
48630: LD_INT 58
48632: PUSH
48633: LD_INT 59
48635: PUSH
48636: LD_INT 60
48638: PUSH
48639: LD_INT 61
48641: PUSH
48642: LD_INT 62
48644: PUSH
48645: LD_INT 80
48647: PUSH
48648: LD_INT 82
48650: PUSH
48651: LD_INT 83
48653: PUSH
48654: LD_INT 84
48656: PUSH
48657: LD_INT 85
48659: PUSH
48660: LD_INT 86
48662: PUSH
48663: EMPTY
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: LIST
48680: LIST
48681: LIST
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: ST_TO_ADDR
48716: GO 49183
48718: LD_INT 2
48720: DOUBLE
48721: EQUAL
48722: IFTRUE 48726
48724: GO 48952
48726: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48727: LD_ADDR_VAR 0 4
48731: PUSH
48732: LD_INT 35
48734: PUSH
48735: LD_INT 45
48737: PUSH
48738: LD_INT 46
48740: PUSH
48741: LD_INT 47
48743: PUSH
48744: LD_INT 82
48746: PUSH
48747: LD_INT 83
48749: PUSH
48750: LD_INT 84
48752: PUSH
48753: LD_INT 85
48755: PUSH
48756: LD_INT 87
48758: PUSH
48759: LD_INT 70
48761: PUSH
48762: LD_INT 1
48764: PUSH
48765: LD_INT 11
48767: PUSH
48768: LD_INT 3
48770: PUSH
48771: LD_INT 4
48773: PUSH
48774: LD_INT 5
48776: PUSH
48777: LD_INT 6
48779: PUSH
48780: LD_INT 15
48782: PUSH
48783: LD_INT 18
48785: PUSH
48786: LD_INT 7
48788: PUSH
48789: LD_INT 17
48791: PUSH
48792: LD_INT 8
48794: PUSH
48795: LD_INT 20
48797: PUSH
48798: LD_INT 21
48800: PUSH
48801: LD_INT 22
48803: PUSH
48804: LD_INT 72
48806: PUSH
48807: LD_INT 26
48809: PUSH
48810: LD_INT 69
48812: PUSH
48813: LD_INT 39
48815: PUSH
48816: LD_INT 40
48818: PUSH
48819: LD_INT 41
48821: PUSH
48822: LD_INT 42
48824: PUSH
48825: LD_INT 43
48827: PUSH
48828: LD_INT 48
48830: PUSH
48831: LD_INT 49
48833: PUSH
48834: LD_INT 50
48836: PUSH
48837: LD_INT 51
48839: PUSH
48840: LD_INT 52
48842: PUSH
48843: LD_INT 53
48845: PUSH
48846: LD_INT 54
48848: PUSH
48849: LD_INT 55
48851: PUSH
48852: LD_INT 56
48854: PUSH
48855: LD_INT 60
48857: PUSH
48858: LD_INT 61
48860: PUSH
48861: LD_INT 62
48863: PUSH
48864: LD_INT 66
48866: PUSH
48867: LD_INT 67
48869: PUSH
48870: LD_INT 68
48872: PUSH
48873: LD_INT 81
48875: PUSH
48876: LD_INT 82
48878: PUSH
48879: LD_INT 83
48881: PUSH
48882: LD_INT 84
48884: PUSH
48885: LD_INT 85
48887: PUSH
48888: LD_INT 87
48890: PUSH
48891: LD_INT 88
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: ST_TO_ADDR
48950: GO 49183
48952: LD_INT 3
48954: DOUBLE
48955: EQUAL
48956: IFTRUE 48960
48958: GO 49182
48960: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48961: LD_ADDR_VAR 0 4
48965: PUSH
48966: LD_INT 46
48968: PUSH
48969: LD_INT 47
48971: PUSH
48972: LD_INT 1
48974: PUSH
48975: LD_INT 2
48977: PUSH
48978: LD_INT 82
48980: PUSH
48981: LD_INT 83
48983: PUSH
48984: LD_INT 84
48986: PUSH
48987: LD_INT 85
48989: PUSH
48990: LD_INT 86
48992: PUSH
48993: LD_INT 11
48995: PUSH
48996: LD_INT 9
48998: PUSH
48999: LD_INT 20
49001: PUSH
49002: LD_INT 19
49004: PUSH
49005: LD_INT 21
49007: PUSH
49008: LD_INT 24
49010: PUSH
49011: LD_INT 22
49013: PUSH
49014: LD_INT 25
49016: PUSH
49017: LD_INT 28
49019: PUSH
49020: LD_INT 29
49022: PUSH
49023: LD_INT 30
49025: PUSH
49026: LD_INT 31
49028: PUSH
49029: LD_INT 37
49031: PUSH
49032: LD_INT 38
49034: PUSH
49035: LD_INT 32
49037: PUSH
49038: LD_INT 27
49040: PUSH
49041: LD_INT 33
49043: PUSH
49044: LD_INT 69
49046: PUSH
49047: LD_INT 39
49049: PUSH
49050: LD_INT 34
49052: PUSH
49053: LD_INT 40
49055: PUSH
49056: LD_INT 71
49058: PUSH
49059: LD_INT 23
49061: PUSH
49062: LD_INT 44
49064: PUSH
49065: LD_INT 48
49067: PUSH
49068: LD_INT 49
49070: PUSH
49071: LD_INT 50
49073: PUSH
49074: LD_INT 51
49076: PUSH
49077: LD_INT 52
49079: PUSH
49080: LD_INT 53
49082: PUSH
49083: LD_INT 54
49085: PUSH
49086: LD_INT 55
49088: PUSH
49089: LD_INT 56
49091: PUSH
49092: LD_INT 57
49094: PUSH
49095: LD_INT 58
49097: PUSH
49098: LD_INT 59
49100: PUSH
49101: LD_INT 63
49103: PUSH
49104: LD_INT 64
49106: PUSH
49107: LD_INT 65
49109: PUSH
49110: LD_INT 82
49112: PUSH
49113: LD_INT 83
49115: PUSH
49116: LD_INT 84
49118: PUSH
49119: LD_INT 85
49121: PUSH
49122: LD_INT 86
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: ST_TO_ADDR
49180: GO 49183
49182: POP
// if state > - 1 and state < 3 then
49183: LD_VAR 0 3
49187: PUSH
49188: LD_INT 1
49190: NEG
49191: GREATER
49192: PUSH
49193: LD_VAR 0 3
49197: PUSH
49198: LD_INT 3
49200: LESS
49201: AND
49202: IFFALSE 49259
// for i in result do
49204: LD_ADDR_VAR 0 5
49208: PUSH
49209: LD_VAR 0 4
49213: PUSH
49214: FOR_IN
49215: IFFALSE 49257
// if GetTech ( i , side ) <> state then
49217: LD_VAR 0 5
49221: PPUSH
49222: LD_VAR 0 1
49226: PPUSH
49227: CALL_OW 321
49231: PUSH
49232: LD_VAR 0 3
49236: NONEQUAL
49237: IFFALSE 49255
// result := result diff i ;
49239: LD_ADDR_VAR 0 4
49243: PUSH
49244: LD_VAR 0 4
49248: PUSH
49249: LD_VAR 0 5
49253: DIFF
49254: ST_TO_ADDR
49255: GO 49214
49257: POP
49258: POP
// end ;
49259: LD_VAR 0 4
49263: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49264: LD_INT 0
49266: PPUSH
49267: PPUSH
49268: PPUSH
// result := true ;
49269: LD_ADDR_VAR 0 3
49273: PUSH
49274: LD_INT 1
49276: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49277: LD_ADDR_VAR 0 5
49281: PUSH
49282: LD_VAR 0 2
49286: PPUSH
49287: CALL_OW 480
49291: ST_TO_ADDR
// if not tmp then
49292: LD_VAR 0 5
49296: NOT
49297: IFFALSE 49301
// exit ;
49299: GO 49350
// for i in tmp do
49301: LD_ADDR_VAR 0 4
49305: PUSH
49306: LD_VAR 0 5
49310: PUSH
49311: FOR_IN
49312: IFFALSE 49348
// if GetTech ( i , side ) <> state_researched then
49314: LD_VAR 0 4
49318: PPUSH
49319: LD_VAR 0 1
49323: PPUSH
49324: CALL_OW 321
49328: PUSH
49329: LD_INT 2
49331: NONEQUAL
49332: IFFALSE 49346
// begin result := false ;
49334: LD_ADDR_VAR 0 3
49338: PUSH
49339: LD_INT 0
49341: ST_TO_ADDR
// exit ;
49342: POP
49343: POP
49344: GO 49350
// end ;
49346: GO 49311
49348: POP
49349: POP
// end ;
49350: LD_VAR 0 3
49354: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49355: LD_INT 0
49357: PPUSH
49358: PPUSH
49359: PPUSH
49360: PPUSH
49361: PPUSH
49362: PPUSH
49363: PPUSH
49364: PPUSH
49365: PPUSH
49366: PPUSH
49367: PPUSH
49368: PPUSH
49369: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49370: LD_VAR 0 1
49374: NOT
49375: PUSH
49376: LD_VAR 0 1
49380: PPUSH
49381: CALL_OW 257
49385: PUSH
49386: LD_INT 9
49388: NONEQUAL
49389: OR
49390: IFFALSE 49394
// exit ;
49392: GO 49967
// side := GetSide ( unit ) ;
49394: LD_ADDR_VAR 0 9
49398: PUSH
49399: LD_VAR 0 1
49403: PPUSH
49404: CALL_OW 255
49408: ST_TO_ADDR
// tech_space := tech_spacanom ;
49409: LD_ADDR_VAR 0 12
49413: PUSH
49414: LD_INT 29
49416: ST_TO_ADDR
// tech_time := tech_taurad ;
49417: LD_ADDR_VAR 0 13
49421: PUSH
49422: LD_INT 28
49424: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49425: LD_ADDR_VAR 0 11
49429: PUSH
49430: LD_VAR 0 1
49434: PPUSH
49435: CALL_OW 310
49439: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49440: LD_VAR 0 11
49444: PPUSH
49445: CALL_OW 247
49449: PUSH
49450: LD_INT 2
49452: EQUAL
49453: IFFALSE 49457
// exit ;
49455: GO 49967
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49457: LD_ADDR_VAR 0 8
49461: PUSH
49462: LD_INT 81
49464: PUSH
49465: LD_VAR 0 9
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: PUSH
49474: LD_INT 3
49476: PUSH
49477: LD_INT 21
49479: PUSH
49480: LD_INT 3
49482: PUSH
49483: EMPTY
49484: LIST
49485: LIST
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PPUSH
49495: CALL_OW 69
49499: ST_TO_ADDR
// if not tmp then
49500: LD_VAR 0 8
49504: NOT
49505: IFFALSE 49509
// exit ;
49507: GO 49967
// if in_unit then
49509: LD_VAR 0 11
49513: IFFALSE 49537
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49515: LD_ADDR_VAR 0 10
49519: PUSH
49520: LD_VAR 0 8
49524: PPUSH
49525: LD_VAR 0 11
49529: PPUSH
49530: CALL_OW 74
49534: ST_TO_ADDR
49535: GO 49557
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49537: LD_ADDR_VAR 0 10
49541: PUSH
49542: LD_VAR 0 8
49546: PPUSH
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 74
49556: ST_TO_ADDR
// if not enemy then
49557: LD_VAR 0 10
49561: NOT
49562: IFFALSE 49566
// exit ;
49564: GO 49967
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49566: LD_VAR 0 11
49570: PUSH
49571: LD_VAR 0 11
49575: PPUSH
49576: LD_VAR 0 10
49580: PPUSH
49581: CALL_OW 296
49585: PUSH
49586: LD_INT 13
49588: GREATER
49589: AND
49590: PUSH
49591: LD_VAR 0 1
49595: PPUSH
49596: LD_VAR 0 10
49600: PPUSH
49601: CALL_OW 296
49605: PUSH
49606: LD_INT 12
49608: GREATER
49609: OR
49610: IFFALSE 49614
// exit ;
49612: GO 49967
// missile := [ 1 ] ;
49614: LD_ADDR_VAR 0 14
49618: PUSH
49619: LD_INT 1
49621: PUSH
49622: EMPTY
49623: LIST
49624: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49625: LD_VAR 0 9
49629: PPUSH
49630: LD_VAR 0 12
49634: PPUSH
49635: CALL_OW 325
49639: IFFALSE 49668
// missile := Insert ( missile , missile + 1 , 2 ) ;
49641: LD_ADDR_VAR 0 14
49645: PUSH
49646: LD_VAR 0 14
49650: PPUSH
49651: LD_VAR 0 14
49655: PUSH
49656: LD_INT 1
49658: PLUS
49659: PPUSH
49660: LD_INT 2
49662: PPUSH
49663: CALL_OW 2
49667: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49668: LD_VAR 0 9
49672: PPUSH
49673: LD_VAR 0 13
49677: PPUSH
49678: CALL_OW 325
49682: PUSH
49683: LD_VAR 0 10
49687: PPUSH
49688: CALL_OW 255
49692: PPUSH
49693: LD_VAR 0 13
49697: PPUSH
49698: CALL_OW 325
49702: NOT
49703: AND
49704: IFFALSE 49733
// missile := Insert ( missile , missile + 1 , 3 ) ;
49706: LD_ADDR_VAR 0 14
49710: PUSH
49711: LD_VAR 0 14
49715: PPUSH
49716: LD_VAR 0 14
49720: PUSH
49721: LD_INT 1
49723: PLUS
49724: PPUSH
49725: LD_INT 3
49727: PPUSH
49728: CALL_OW 2
49732: ST_TO_ADDR
// if missile < 2 then
49733: LD_VAR 0 14
49737: PUSH
49738: LD_INT 2
49740: LESS
49741: IFFALSE 49745
// exit ;
49743: GO 49967
// x := GetX ( enemy ) ;
49745: LD_ADDR_VAR 0 4
49749: PUSH
49750: LD_VAR 0 10
49754: PPUSH
49755: CALL_OW 250
49759: ST_TO_ADDR
// y := GetY ( enemy ) ;
49760: LD_ADDR_VAR 0 5
49764: PUSH
49765: LD_VAR 0 10
49769: PPUSH
49770: CALL_OW 251
49774: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49775: LD_ADDR_VAR 0 6
49779: PUSH
49780: LD_VAR 0 4
49784: PUSH
49785: LD_INT 1
49787: NEG
49788: PPUSH
49789: LD_INT 1
49791: PPUSH
49792: CALL_OW 12
49796: PLUS
49797: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49798: LD_ADDR_VAR 0 7
49802: PUSH
49803: LD_VAR 0 5
49807: PUSH
49808: LD_INT 1
49810: NEG
49811: PPUSH
49812: LD_INT 1
49814: PPUSH
49815: CALL_OW 12
49819: PLUS
49820: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49821: LD_VAR 0 6
49825: PPUSH
49826: LD_VAR 0 7
49830: PPUSH
49831: CALL_OW 488
49835: NOT
49836: IFFALSE 49858
// begin _x := x ;
49838: LD_ADDR_VAR 0 6
49842: PUSH
49843: LD_VAR 0 4
49847: ST_TO_ADDR
// _y := y ;
49848: LD_ADDR_VAR 0 7
49852: PUSH
49853: LD_VAR 0 5
49857: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49858: LD_ADDR_VAR 0 3
49862: PUSH
49863: LD_INT 1
49865: PPUSH
49866: LD_VAR 0 14
49870: PPUSH
49871: CALL_OW 12
49875: ST_TO_ADDR
// case i of 1 :
49876: LD_VAR 0 3
49880: PUSH
49881: LD_INT 1
49883: DOUBLE
49884: EQUAL
49885: IFTRUE 49889
49887: GO 49906
49889: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49890: LD_VAR 0 1
49894: PPUSH
49895: LD_VAR 0 10
49899: PPUSH
49900: CALL_OW 115
49904: GO 49967
49906: LD_INT 2
49908: DOUBLE
49909: EQUAL
49910: IFTRUE 49914
49912: GO 49936
49914: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49915: LD_VAR 0 1
49919: PPUSH
49920: LD_VAR 0 6
49924: PPUSH
49925: LD_VAR 0 7
49929: PPUSH
49930: CALL_OW 153
49934: GO 49967
49936: LD_INT 3
49938: DOUBLE
49939: EQUAL
49940: IFTRUE 49944
49942: GO 49966
49944: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49945: LD_VAR 0 1
49949: PPUSH
49950: LD_VAR 0 6
49954: PPUSH
49955: LD_VAR 0 7
49959: PPUSH
49960: CALL_OW 154
49964: GO 49967
49966: POP
// end ;
49967: LD_VAR 0 2
49971: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49972: LD_INT 0
49974: PPUSH
49975: PPUSH
49976: PPUSH
49977: PPUSH
49978: PPUSH
49979: PPUSH
// if not unit or not building then
49980: LD_VAR 0 1
49984: NOT
49985: PUSH
49986: LD_VAR 0 2
49990: NOT
49991: OR
49992: IFFALSE 49996
// exit ;
49994: GO 50154
// x := GetX ( building ) ;
49996: LD_ADDR_VAR 0 5
50000: PUSH
50001: LD_VAR 0 2
50005: PPUSH
50006: CALL_OW 250
50010: ST_TO_ADDR
// y := GetY ( building ) ;
50011: LD_ADDR_VAR 0 6
50015: PUSH
50016: LD_VAR 0 2
50020: PPUSH
50021: CALL_OW 251
50025: ST_TO_ADDR
// for i = 0 to 5 do
50026: LD_ADDR_VAR 0 4
50030: PUSH
50031: DOUBLE
50032: LD_INT 0
50034: DEC
50035: ST_TO_ADDR
50036: LD_INT 5
50038: PUSH
50039: FOR_TO
50040: IFFALSE 50152
// begin _x := ShiftX ( x , i , 3 ) ;
50042: LD_ADDR_VAR 0 7
50046: PUSH
50047: LD_VAR 0 5
50051: PPUSH
50052: LD_VAR 0 4
50056: PPUSH
50057: LD_INT 3
50059: PPUSH
50060: CALL_OW 272
50064: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50065: LD_ADDR_VAR 0 8
50069: PUSH
50070: LD_VAR 0 6
50074: PPUSH
50075: LD_VAR 0 4
50079: PPUSH
50080: LD_INT 3
50082: PPUSH
50083: CALL_OW 273
50087: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50088: LD_VAR 0 7
50092: PPUSH
50093: LD_VAR 0 8
50097: PPUSH
50098: CALL_OW 488
50102: NOT
50103: IFFALSE 50107
// continue ;
50105: GO 50039
// if HexInfo ( _x , _y ) = 0 then
50107: LD_VAR 0 7
50111: PPUSH
50112: LD_VAR 0 8
50116: PPUSH
50117: CALL_OW 428
50121: PUSH
50122: LD_INT 0
50124: EQUAL
50125: IFFALSE 50150
// begin ComMoveXY ( unit , _x , _y ) ;
50127: LD_VAR 0 1
50131: PPUSH
50132: LD_VAR 0 7
50136: PPUSH
50137: LD_VAR 0 8
50141: PPUSH
50142: CALL_OW 111
// exit ;
50146: POP
50147: POP
50148: GO 50154
// end ; end ;
50150: GO 50039
50152: POP
50153: POP
// end ;
50154: LD_VAR 0 3
50158: RET
// export function ScanBase ( side , base_area ) ; begin
50159: LD_INT 0
50161: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50162: LD_ADDR_VAR 0 3
50166: PUSH
50167: LD_VAR 0 2
50171: PPUSH
50172: LD_INT 81
50174: PUSH
50175: LD_VAR 0 1
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PPUSH
50184: CALL_OW 70
50188: ST_TO_ADDR
// end ;
50189: LD_VAR 0 3
50193: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50194: LD_INT 0
50196: PPUSH
50197: PPUSH
50198: PPUSH
50199: PPUSH
// result := false ;
50200: LD_ADDR_VAR 0 2
50204: PUSH
50205: LD_INT 0
50207: ST_TO_ADDR
// side := GetSide ( unit ) ;
50208: LD_ADDR_VAR 0 3
50212: PUSH
50213: LD_VAR 0 1
50217: PPUSH
50218: CALL_OW 255
50222: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50223: LD_ADDR_VAR 0 4
50227: PUSH
50228: LD_VAR 0 1
50232: PPUSH
50233: CALL_OW 248
50237: ST_TO_ADDR
// case nat of 1 :
50238: LD_VAR 0 4
50242: PUSH
50243: LD_INT 1
50245: DOUBLE
50246: EQUAL
50247: IFTRUE 50251
50249: GO 50262
50251: POP
// tech := tech_lassight ; 2 :
50252: LD_ADDR_VAR 0 5
50256: PUSH
50257: LD_INT 12
50259: ST_TO_ADDR
50260: GO 50301
50262: LD_INT 2
50264: DOUBLE
50265: EQUAL
50266: IFTRUE 50270
50268: GO 50281
50270: POP
// tech := tech_mortar ; 3 :
50271: LD_ADDR_VAR 0 5
50275: PUSH
50276: LD_INT 41
50278: ST_TO_ADDR
50279: GO 50301
50281: LD_INT 3
50283: DOUBLE
50284: EQUAL
50285: IFTRUE 50289
50287: GO 50300
50289: POP
// tech := tech_bazooka ; end ;
50290: LD_ADDR_VAR 0 5
50294: PUSH
50295: LD_INT 44
50297: ST_TO_ADDR
50298: GO 50301
50300: POP
// if Researched ( side , tech ) then
50301: LD_VAR 0 3
50305: PPUSH
50306: LD_VAR 0 5
50310: PPUSH
50311: CALL_OW 325
50315: IFFALSE 50342
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50317: LD_ADDR_VAR 0 2
50321: PUSH
50322: LD_INT 5
50324: PUSH
50325: LD_INT 8
50327: PUSH
50328: LD_INT 9
50330: PUSH
50331: EMPTY
50332: LIST
50333: LIST
50334: LIST
50335: PUSH
50336: LD_VAR 0 4
50340: ARRAY
50341: ST_TO_ADDR
// end ;
50342: LD_VAR 0 2
50346: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50347: LD_INT 0
50349: PPUSH
50350: PPUSH
50351: PPUSH
// if not mines then
50352: LD_VAR 0 2
50356: NOT
50357: IFFALSE 50361
// exit ;
50359: GO 50505
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50361: LD_ADDR_VAR 0 5
50365: PUSH
50366: LD_INT 81
50368: PUSH
50369: LD_VAR 0 1
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PUSH
50378: LD_INT 3
50380: PUSH
50381: LD_INT 21
50383: PUSH
50384: LD_INT 3
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PPUSH
50399: CALL_OW 69
50403: ST_TO_ADDR
// for i in mines do
50404: LD_ADDR_VAR 0 4
50408: PUSH
50409: LD_VAR 0 2
50413: PUSH
50414: FOR_IN
50415: IFFALSE 50503
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50417: LD_VAR 0 4
50421: PUSH
50422: LD_INT 1
50424: ARRAY
50425: PPUSH
50426: LD_VAR 0 4
50430: PUSH
50431: LD_INT 2
50433: ARRAY
50434: PPUSH
50435: CALL_OW 458
50439: NOT
50440: IFFALSE 50444
// continue ;
50442: GO 50414
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50444: LD_VAR 0 4
50448: PUSH
50449: LD_INT 1
50451: ARRAY
50452: PPUSH
50453: LD_VAR 0 4
50457: PUSH
50458: LD_INT 2
50460: ARRAY
50461: PPUSH
50462: CALL_OW 428
50466: PUSH
50467: LD_VAR 0 5
50471: IN
50472: IFFALSE 50501
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50474: LD_VAR 0 4
50478: PUSH
50479: LD_INT 1
50481: ARRAY
50482: PPUSH
50483: LD_VAR 0 4
50487: PUSH
50488: LD_INT 2
50490: ARRAY
50491: PPUSH
50492: LD_VAR 0 1
50496: PPUSH
50497: CALL_OW 456
// end ;
50501: GO 50414
50503: POP
50504: POP
// end ;
50505: LD_VAR 0 3
50509: RET
// export function Count ( array ) ; var i ; begin
50510: LD_INT 0
50512: PPUSH
50513: PPUSH
// result := 0 ;
50514: LD_ADDR_VAR 0 2
50518: PUSH
50519: LD_INT 0
50521: ST_TO_ADDR
// for i in array do
50522: LD_ADDR_VAR 0 3
50526: PUSH
50527: LD_VAR 0 1
50531: PUSH
50532: FOR_IN
50533: IFFALSE 50557
// if i then
50535: LD_VAR 0 3
50539: IFFALSE 50555
// result := result + 1 ;
50541: LD_ADDR_VAR 0 2
50545: PUSH
50546: LD_VAR 0 2
50550: PUSH
50551: LD_INT 1
50553: PLUS
50554: ST_TO_ADDR
50555: GO 50532
50557: POP
50558: POP
// end ;
50559: LD_VAR 0 2
50563: RET
// export function IsEmpty ( building ) ; begin
50564: LD_INT 0
50566: PPUSH
// if not building then
50567: LD_VAR 0 1
50571: NOT
50572: IFFALSE 50576
// exit ;
50574: GO 50619
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50576: LD_ADDR_VAR 0 2
50580: PUSH
50581: LD_VAR 0 1
50585: PUSH
50586: LD_INT 22
50588: PUSH
50589: LD_VAR 0 1
50593: PPUSH
50594: CALL_OW 255
50598: PUSH
50599: EMPTY
50600: LIST
50601: LIST
50602: PUSH
50603: LD_INT 58
50605: PUSH
50606: EMPTY
50607: LIST
50608: PUSH
50609: EMPTY
50610: LIST
50611: LIST
50612: PPUSH
50613: CALL_OW 69
50617: IN
50618: ST_TO_ADDR
// end ;
50619: LD_VAR 0 2
50623: RET
// export function IsNotFull ( building ) ; begin
50624: LD_INT 0
50626: PPUSH
// if not building then
50627: LD_VAR 0 1
50631: NOT
50632: IFFALSE 50636
// exit ;
50634: GO 50655
// result := UnitsInside ( building ) < 6 ;
50636: LD_ADDR_VAR 0 2
50640: PUSH
50641: LD_VAR 0 1
50645: PPUSH
50646: CALL_OW 313
50650: PUSH
50651: LD_INT 6
50653: LESS
50654: ST_TO_ADDR
// end ;
50655: LD_VAR 0 2
50659: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50660: LD_INT 0
50662: PPUSH
50663: PPUSH
50664: PPUSH
50665: PPUSH
// tmp := [ ] ;
50666: LD_ADDR_VAR 0 3
50670: PUSH
50671: EMPTY
50672: ST_TO_ADDR
// list := [ ] ;
50673: LD_ADDR_VAR 0 5
50677: PUSH
50678: EMPTY
50679: ST_TO_ADDR
// for i = 16 to 25 do
50680: LD_ADDR_VAR 0 4
50684: PUSH
50685: DOUBLE
50686: LD_INT 16
50688: DEC
50689: ST_TO_ADDR
50690: LD_INT 25
50692: PUSH
50693: FOR_TO
50694: IFFALSE 50767
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50696: LD_ADDR_VAR 0 3
50700: PUSH
50701: LD_VAR 0 3
50705: PUSH
50706: LD_INT 22
50708: PUSH
50709: LD_VAR 0 1
50713: PPUSH
50714: CALL_OW 255
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 91
50725: PUSH
50726: LD_VAR 0 1
50730: PUSH
50731: LD_INT 6
50733: PUSH
50734: EMPTY
50735: LIST
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 30
50741: PUSH
50742: LD_VAR 0 4
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: EMPTY
50752: LIST
50753: LIST
50754: LIST
50755: PUSH
50756: EMPTY
50757: LIST
50758: PPUSH
50759: CALL_OW 69
50763: ADD
50764: ST_TO_ADDR
50765: GO 50693
50767: POP
50768: POP
// for i = 1 to tmp do
50769: LD_ADDR_VAR 0 4
50773: PUSH
50774: DOUBLE
50775: LD_INT 1
50777: DEC
50778: ST_TO_ADDR
50779: LD_VAR 0 3
50783: PUSH
50784: FOR_TO
50785: IFFALSE 50873
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50787: LD_ADDR_VAR 0 5
50791: PUSH
50792: LD_VAR 0 5
50796: PUSH
50797: LD_VAR 0 3
50801: PUSH
50802: LD_VAR 0 4
50806: ARRAY
50807: PPUSH
50808: CALL_OW 266
50812: PUSH
50813: LD_VAR 0 3
50817: PUSH
50818: LD_VAR 0 4
50822: ARRAY
50823: PPUSH
50824: CALL_OW 250
50828: PUSH
50829: LD_VAR 0 3
50833: PUSH
50834: LD_VAR 0 4
50838: ARRAY
50839: PPUSH
50840: CALL_OW 251
50844: PUSH
50845: LD_VAR 0 3
50849: PUSH
50850: LD_VAR 0 4
50854: ARRAY
50855: PPUSH
50856: CALL_OW 254
50860: PUSH
50861: EMPTY
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: PUSH
50867: EMPTY
50868: LIST
50869: ADD
50870: ST_TO_ADDR
50871: GO 50784
50873: POP
50874: POP
// result := list ;
50875: LD_ADDR_VAR 0 2
50879: PUSH
50880: LD_VAR 0 5
50884: ST_TO_ADDR
// end ;
50885: LD_VAR 0 2
50889: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50890: LD_INT 0
50892: PPUSH
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
50897: PPUSH
50898: PPUSH
// if not factory then
50899: LD_VAR 0 1
50903: NOT
50904: IFFALSE 50908
// exit ;
50906: GO 51501
// if control = control_apeman then
50908: LD_VAR 0 4
50912: PUSH
50913: LD_INT 5
50915: EQUAL
50916: IFFALSE 51025
// begin tmp := UnitsInside ( factory ) ;
50918: LD_ADDR_VAR 0 8
50922: PUSH
50923: LD_VAR 0 1
50927: PPUSH
50928: CALL_OW 313
50932: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50933: LD_VAR 0 8
50937: PPUSH
50938: LD_INT 25
50940: PUSH
50941: LD_INT 12
50943: PUSH
50944: EMPTY
50945: LIST
50946: LIST
50947: PPUSH
50948: CALL_OW 72
50952: NOT
50953: IFFALSE 50963
// control := control_manual ;
50955: LD_ADDR_VAR 0 4
50959: PUSH
50960: LD_INT 1
50962: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50963: LD_ADDR_VAR 0 8
50967: PUSH
50968: LD_VAR 0 1
50972: PPUSH
50973: CALL 50660 0 1
50977: ST_TO_ADDR
// if tmp then
50978: LD_VAR 0 8
50982: IFFALSE 51025
// begin for i in tmp do
50984: LD_ADDR_VAR 0 7
50988: PUSH
50989: LD_VAR 0 8
50993: PUSH
50994: FOR_IN
50995: IFFALSE 51023
// if i [ 1 ] = b_ext_radio then
50997: LD_VAR 0 7
51001: PUSH
51002: LD_INT 1
51004: ARRAY
51005: PUSH
51006: LD_INT 22
51008: EQUAL
51009: IFFALSE 51021
// begin control := control_remote ;
51011: LD_ADDR_VAR 0 4
51015: PUSH
51016: LD_INT 2
51018: ST_TO_ADDR
// break ;
51019: GO 51023
// end ;
51021: GO 50994
51023: POP
51024: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51025: LD_VAR 0 1
51029: PPUSH
51030: LD_VAR 0 2
51034: PPUSH
51035: LD_VAR 0 3
51039: PPUSH
51040: LD_VAR 0 4
51044: PPUSH
51045: LD_VAR 0 5
51049: PPUSH
51050: CALL_OW 448
51054: IFFALSE 51089
// begin result := [ chassis , engine , control , weapon ] ;
51056: LD_ADDR_VAR 0 6
51060: PUSH
51061: LD_VAR 0 2
51065: PUSH
51066: LD_VAR 0 3
51070: PUSH
51071: LD_VAR 0 4
51075: PUSH
51076: LD_VAR 0 5
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: ST_TO_ADDR
// exit ;
51087: GO 51501
// end ; _chassis := AvailableChassisList ( factory ) ;
51089: LD_ADDR_VAR 0 9
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 475
51103: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51104: LD_ADDR_VAR 0 11
51108: PUSH
51109: LD_VAR 0 1
51113: PPUSH
51114: CALL_OW 476
51118: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51119: LD_ADDR_VAR 0 12
51123: PUSH
51124: LD_VAR 0 1
51128: PPUSH
51129: CALL_OW 477
51133: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51134: LD_ADDR_VAR 0 10
51138: PUSH
51139: LD_VAR 0 1
51143: PPUSH
51144: CALL_OW 478
51148: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51149: LD_VAR 0 9
51153: NOT
51154: PUSH
51155: LD_VAR 0 11
51159: NOT
51160: OR
51161: PUSH
51162: LD_VAR 0 12
51166: NOT
51167: OR
51168: PUSH
51169: LD_VAR 0 10
51173: NOT
51174: OR
51175: IFFALSE 51210
// begin result := [ chassis , engine , control , weapon ] ;
51177: LD_ADDR_VAR 0 6
51181: PUSH
51182: LD_VAR 0 2
51186: PUSH
51187: LD_VAR 0 3
51191: PUSH
51192: LD_VAR 0 4
51196: PUSH
51197: LD_VAR 0 5
51201: PUSH
51202: EMPTY
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: ST_TO_ADDR
// exit ;
51208: GO 51501
// end ; if not chassis in _chassis then
51210: LD_VAR 0 2
51214: PUSH
51215: LD_VAR 0 9
51219: IN
51220: NOT
51221: IFFALSE 51247
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51223: LD_ADDR_VAR 0 2
51227: PUSH
51228: LD_VAR 0 9
51232: PUSH
51233: LD_INT 1
51235: PPUSH
51236: LD_VAR 0 9
51240: PPUSH
51241: CALL_OW 12
51245: ARRAY
51246: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51247: LD_VAR 0 2
51251: PPUSH
51252: LD_VAR 0 3
51256: PPUSH
51257: CALL 51506 0 2
51261: NOT
51262: IFFALSE 51321
// repeat engine := _engine [ 1 ] ;
51264: LD_ADDR_VAR 0 3
51268: PUSH
51269: LD_VAR 0 11
51273: PUSH
51274: LD_INT 1
51276: ARRAY
51277: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51278: LD_ADDR_VAR 0 11
51282: PUSH
51283: LD_VAR 0 11
51287: PPUSH
51288: LD_INT 1
51290: PPUSH
51291: CALL_OW 3
51295: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51296: LD_VAR 0 2
51300: PPUSH
51301: LD_VAR 0 3
51305: PPUSH
51306: CALL 51506 0 2
51310: PUSH
51311: LD_VAR 0 11
51315: PUSH
51316: EMPTY
51317: EQUAL
51318: OR
51319: IFFALSE 51264
// if not control in _control then
51321: LD_VAR 0 4
51325: PUSH
51326: LD_VAR 0 12
51330: IN
51331: NOT
51332: IFFALSE 51358
// control := _control [ rand ( 1 , _control ) ] ;
51334: LD_ADDR_VAR 0 4
51338: PUSH
51339: LD_VAR 0 12
51343: PUSH
51344: LD_INT 1
51346: PPUSH
51347: LD_VAR 0 12
51351: PPUSH
51352: CALL_OW 12
51356: ARRAY
51357: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51358: LD_VAR 0 2
51362: PPUSH
51363: LD_VAR 0 5
51367: PPUSH
51368: CALL 51726 0 2
51372: NOT
51373: IFFALSE 51432
// repeat weapon := _weapon [ 1 ] ;
51375: LD_ADDR_VAR 0 5
51379: PUSH
51380: LD_VAR 0 10
51384: PUSH
51385: LD_INT 1
51387: ARRAY
51388: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51389: LD_ADDR_VAR 0 10
51393: PUSH
51394: LD_VAR 0 10
51398: PPUSH
51399: LD_INT 1
51401: PPUSH
51402: CALL_OW 3
51406: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51407: LD_VAR 0 2
51411: PPUSH
51412: LD_VAR 0 5
51416: PPUSH
51417: CALL 51726 0 2
51421: PUSH
51422: LD_VAR 0 10
51426: PUSH
51427: EMPTY
51428: EQUAL
51429: OR
51430: IFFALSE 51375
// result := [ ] ;
51432: LD_ADDR_VAR 0 6
51436: PUSH
51437: EMPTY
51438: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51439: LD_VAR 0 1
51443: PPUSH
51444: LD_VAR 0 2
51448: PPUSH
51449: LD_VAR 0 3
51453: PPUSH
51454: LD_VAR 0 4
51458: PPUSH
51459: LD_VAR 0 5
51463: PPUSH
51464: CALL_OW 448
51468: IFFALSE 51501
// result := [ chassis , engine , control , weapon ] ;
51470: LD_ADDR_VAR 0 6
51474: PUSH
51475: LD_VAR 0 2
51479: PUSH
51480: LD_VAR 0 3
51484: PUSH
51485: LD_VAR 0 4
51489: PUSH
51490: LD_VAR 0 5
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: ST_TO_ADDR
// end ;
51501: LD_VAR 0 6
51505: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51506: LD_INT 0
51508: PPUSH
// if not chassis or not engine then
51509: LD_VAR 0 1
51513: NOT
51514: PUSH
51515: LD_VAR 0 2
51519: NOT
51520: OR
51521: IFFALSE 51525
// exit ;
51523: GO 51721
// case engine of engine_solar :
51525: LD_VAR 0 2
51529: PUSH
51530: LD_INT 2
51532: DOUBLE
51533: EQUAL
51534: IFTRUE 51538
51536: GO 51576
51538: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51539: LD_ADDR_VAR 0 3
51543: PUSH
51544: LD_INT 11
51546: PUSH
51547: LD_INT 12
51549: PUSH
51550: LD_INT 13
51552: PUSH
51553: LD_INT 14
51555: PUSH
51556: LD_INT 1
51558: PUSH
51559: LD_INT 2
51561: PUSH
51562: LD_INT 3
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: ST_TO_ADDR
51574: GO 51705
51576: LD_INT 1
51578: DOUBLE
51579: EQUAL
51580: IFTRUE 51584
51582: GO 51646
51584: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51585: LD_ADDR_VAR 0 3
51589: PUSH
51590: LD_INT 11
51592: PUSH
51593: LD_INT 12
51595: PUSH
51596: LD_INT 13
51598: PUSH
51599: LD_INT 14
51601: PUSH
51602: LD_INT 1
51604: PUSH
51605: LD_INT 2
51607: PUSH
51608: LD_INT 3
51610: PUSH
51611: LD_INT 4
51613: PUSH
51614: LD_INT 5
51616: PUSH
51617: LD_INT 21
51619: PUSH
51620: LD_INT 23
51622: PUSH
51623: LD_INT 22
51625: PUSH
51626: LD_INT 24
51628: PUSH
51629: EMPTY
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: ST_TO_ADDR
51644: GO 51705
51646: LD_INT 3
51648: DOUBLE
51649: EQUAL
51650: IFTRUE 51654
51652: GO 51704
51654: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51655: LD_ADDR_VAR 0 3
51659: PUSH
51660: LD_INT 13
51662: PUSH
51663: LD_INT 14
51665: PUSH
51666: LD_INT 2
51668: PUSH
51669: LD_INT 3
51671: PUSH
51672: LD_INT 4
51674: PUSH
51675: LD_INT 5
51677: PUSH
51678: LD_INT 21
51680: PUSH
51681: LD_INT 22
51683: PUSH
51684: LD_INT 23
51686: PUSH
51687: LD_INT 24
51689: PUSH
51690: EMPTY
51691: LIST
51692: LIST
51693: LIST
51694: LIST
51695: LIST
51696: LIST
51697: LIST
51698: LIST
51699: LIST
51700: LIST
51701: ST_TO_ADDR
51702: GO 51705
51704: POP
// result := ( chassis in result ) ;
51705: LD_ADDR_VAR 0 3
51709: PUSH
51710: LD_VAR 0 1
51714: PUSH
51715: LD_VAR 0 3
51719: IN
51720: ST_TO_ADDR
// end ;
51721: LD_VAR 0 3
51725: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51726: LD_INT 0
51728: PPUSH
// if not chassis or not weapon then
51729: LD_VAR 0 1
51733: NOT
51734: PUSH
51735: LD_VAR 0 2
51739: NOT
51740: OR
51741: IFFALSE 51745
// exit ;
51743: GO 52807
// case weapon of us_machine_gun :
51745: LD_VAR 0 2
51749: PUSH
51750: LD_INT 2
51752: DOUBLE
51753: EQUAL
51754: IFTRUE 51758
51756: GO 51788
51758: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51759: LD_ADDR_VAR 0 3
51763: PUSH
51764: LD_INT 1
51766: PUSH
51767: LD_INT 2
51769: PUSH
51770: LD_INT 3
51772: PUSH
51773: LD_INT 4
51775: PUSH
51776: LD_INT 5
51778: PUSH
51779: EMPTY
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: ST_TO_ADDR
51786: GO 52791
51788: LD_INT 3
51790: DOUBLE
51791: EQUAL
51792: IFTRUE 51796
51794: GO 51826
51796: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51797: LD_ADDR_VAR 0 3
51801: PUSH
51802: LD_INT 1
51804: PUSH
51805: LD_INT 2
51807: PUSH
51808: LD_INT 3
51810: PUSH
51811: LD_INT 4
51813: PUSH
51814: LD_INT 5
51816: PUSH
51817: EMPTY
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: LIST
51823: ST_TO_ADDR
51824: GO 52791
51826: LD_INT 11
51828: DOUBLE
51829: EQUAL
51830: IFTRUE 51834
51832: GO 51864
51834: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51835: LD_ADDR_VAR 0 3
51839: PUSH
51840: LD_INT 1
51842: PUSH
51843: LD_INT 2
51845: PUSH
51846: LD_INT 3
51848: PUSH
51849: LD_INT 4
51851: PUSH
51852: LD_INT 5
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: LIST
51859: LIST
51860: LIST
51861: ST_TO_ADDR
51862: GO 52791
51864: LD_INT 4
51866: DOUBLE
51867: EQUAL
51868: IFTRUE 51872
51870: GO 51898
51872: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51873: LD_ADDR_VAR 0 3
51877: PUSH
51878: LD_INT 2
51880: PUSH
51881: LD_INT 3
51883: PUSH
51884: LD_INT 4
51886: PUSH
51887: LD_INT 5
51889: PUSH
51890: EMPTY
51891: LIST
51892: LIST
51893: LIST
51894: LIST
51895: ST_TO_ADDR
51896: GO 52791
51898: LD_INT 5
51900: DOUBLE
51901: EQUAL
51902: IFTRUE 51906
51904: GO 51932
51906: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51907: LD_ADDR_VAR 0 3
51911: PUSH
51912: LD_INT 2
51914: PUSH
51915: LD_INT 3
51917: PUSH
51918: LD_INT 4
51920: PUSH
51921: LD_INT 5
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: LIST
51928: LIST
51929: ST_TO_ADDR
51930: GO 52791
51932: LD_INT 9
51934: DOUBLE
51935: EQUAL
51936: IFTRUE 51940
51938: GO 51966
51940: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51941: LD_ADDR_VAR 0 3
51945: PUSH
51946: LD_INT 2
51948: PUSH
51949: LD_INT 3
51951: PUSH
51952: LD_INT 4
51954: PUSH
51955: LD_INT 5
51957: PUSH
51958: EMPTY
51959: LIST
51960: LIST
51961: LIST
51962: LIST
51963: ST_TO_ADDR
51964: GO 52791
51966: LD_INT 7
51968: DOUBLE
51969: EQUAL
51970: IFTRUE 51974
51972: GO 52000
51974: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51975: LD_ADDR_VAR 0 3
51979: PUSH
51980: LD_INT 2
51982: PUSH
51983: LD_INT 3
51985: PUSH
51986: LD_INT 4
51988: PUSH
51989: LD_INT 5
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: LIST
51996: LIST
51997: ST_TO_ADDR
51998: GO 52791
52000: LD_INT 12
52002: DOUBLE
52003: EQUAL
52004: IFTRUE 52008
52006: GO 52034
52008: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52009: LD_ADDR_VAR 0 3
52013: PUSH
52014: LD_INT 2
52016: PUSH
52017: LD_INT 3
52019: PUSH
52020: LD_INT 4
52022: PUSH
52023: LD_INT 5
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: ST_TO_ADDR
52032: GO 52791
52034: LD_INT 13
52036: DOUBLE
52037: EQUAL
52038: IFTRUE 52042
52040: GO 52068
52042: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52043: LD_ADDR_VAR 0 3
52047: PUSH
52048: LD_INT 2
52050: PUSH
52051: LD_INT 3
52053: PUSH
52054: LD_INT 4
52056: PUSH
52057: LD_INT 5
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: ST_TO_ADDR
52066: GO 52791
52068: LD_INT 14
52070: DOUBLE
52071: EQUAL
52072: IFTRUE 52076
52074: GO 52094
52076: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52077: LD_ADDR_VAR 0 3
52081: PUSH
52082: LD_INT 4
52084: PUSH
52085: LD_INT 5
52087: PUSH
52088: EMPTY
52089: LIST
52090: LIST
52091: ST_TO_ADDR
52092: GO 52791
52094: LD_INT 6
52096: DOUBLE
52097: EQUAL
52098: IFTRUE 52102
52100: GO 52120
52102: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52103: LD_ADDR_VAR 0 3
52107: PUSH
52108: LD_INT 4
52110: PUSH
52111: LD_INT 5
52113: PUSH
52114: EMPTY
52115: LIST
52116: LIST
52117: ST_TO_ADDR
52118: GO 52791
52120: LD_INT 10
52122: DOUBLE
52123: EQUAL
52124: IFTRUE 52128
52126: GO 52146
52128: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52129: LD_ADDR_VAR 0 3
52133: PUSH
52134: LD_INT 4
52136: PUSH
52137: LD_INT 5
52139: PUSH
52140: EMPTY
52141: LIST
52142: LIST
52143: ST_TO_ADDR
52144: GO 52791
52146: LD_INT 22
52148: DOUBLE
52149: EQUAL
52150: IFTRUE 52154
52152: GO 52180
52154: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52155: LD_ADDR_VAR 0 3
52159: PUSH
52160: LD_INT 11
52162: PUSH
52163: LD_INT 12
52165: PUSH
52166: LD_INT 13
52168: PUSH
52169: LD_INT 14
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: ST_TO_ADDR
52178: GO 52791
52180: LD_INT 23
52182: DOUBLE
52183: EQUAL
52184: IFTRUE 52188
52186: GO 52214
52188: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52189: LD_ADDR_VAR 0 3
52193: PUSH
52194: LD_INT 11
52196: PUSH
52197: LD_INT 12
52199: PUSH
52200: LD_INT 13
52202: PUSH
52203: LD_INT 14
52205: PUSH
52206: EMPTY
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: ST_TO_ADDR
52212: GO 52791
52214: LD_INT 24
52216: DOUBLE
52217: EQUAL
52218: IFTRUE 52222
52220: GO 52248
52222: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52223: LD_ADDR_VAR 0 3
52227: PUSH
52228: LD_INT 11
52230: PUSH
52231: LD_INT 12
52233: PUSH
52234: LD_INT 13
52236: PUSH
52237: LD_INT 14
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: ST_TO_ADDR
52246: GO 52791
52248: LD_INT 30
52250: DOUBLE
52251: EQUAL
52252: IFTRUE 52256
52254: GO 52282
52256: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52257: LD_ADDR_VAR 0 3
52261: PUSH
52262: LD_INT 11
52264: PUSH
52265: LD_INT 12
52267: PUSH
52268: LD_INT 13
52270: PUSH
52271: LD_INT 14
52273: PUSH
52274: EMPTY
52275: LIST
52276: LIST
52277: LIST
52278: LIST
52279: ST_TO_ADDR
52280: GO 52791
52282: LD_INT 25
52284: DOUBLE
52285: EQUAL
52286: IFTRUE 52290
52288: GO 52308
52290: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52291: LD_ADDR_VAR 0 3
52295: PUSH
52296: LD_INT 13
52298: PUSH
52299: LD_INT 14
52301: PUSH
52302: EMPTY
52303: LIST
52304: LIST
52305: ST_TO_ADDR
52306: GO 52791
52308: LD_INT 27
52310: DOUBLE
52311: EQUAL
52312: IFTRUE 52316
52314: GO 52334
52316: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52317: LD_ADDR_VAR 0 3
52321: PUSH
52322: LD_INT 13
52324: PUSH
52325: LD_INT 14
52327: PUSH
52328: EMPTY
52329: LIST
52330: LIST
52331: ST_TO_ADDR
52332: GO 52791
52334: LD_EXP 99
52338: DOUBLE
52339: EQUAL
52340: IFTRUE 52344
52342: GO 52370
52344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52345: LD_ADDR_VAR 0 3
52349: PUSH
52350: LD_INT 11
52352: PUSH
52353: LD_INT 12
52355: PUSH
52356: LD_INT 13
52358: PUSH
52359: LD_INT 14
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: LIST
52366: LIST
52367: ST_TO_ADDR
52368: GO 52791
52370: LD_INT 28
52372: DOUBLE
52373: EQUAL
52374: IFTRUE 52378
52376: GO 52396
52378: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52379: LD_ADDR_VAR 0 3
52383: PUSH
52384: LD_INT 13
52386: PUSH
52387: LD_INT 14
52389: PUSH
52390: EMPTY
52391: LIST
52392: LIST
52393: ST_TO_ADDR
52394: GO 52791
52396: LD_INT 29
52398: DOUBLE
52399: EQUAL
52400: IFTRUE 52404
52402: GO 52422
52404: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52405: LD_ADDR_VAR 0 3
52409: PUSH
52410: LD_INT 13
52412: PUSH
52413: LD_INT 14
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: ST_TO_ADDR
52420: GO 52791
52422: LD_INT 31
52424: DOUBLE
52425: EQUAL
52426: IFTRUE 52430
52428: GO 52448
52430: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52431: LD_ADDR_VAR 0 3
52435: PUSH
52436: LD_INT 13
52438: PUSH
52439: LD_INT 14
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: ST_TO_ADDR
52446: GO 52791
52448: LD_INT 26
52450: DOUBLE
52451: EQUAL
52452: IFTRUE 52456
52454: GO 52474
52456: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52457: LD_ADDR_VAR 0 3
52461: PUSH
52462: LD_INT 13
52464: PUSH
52465: LD_INT 14
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: ST_TO_ADDR
52472: GO 52791
52474: LD_INT 42
52476: DOUBLE
52477: EQUAL
52478: IFTRUE 52482
52480: GO 52508
52482: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52483: LD_ADDR_VAR 0 3
52487: PUSH
52488: LD_INT 21
52490: PUSH
52491: LD_INT 22
52493: PUSH
52494: LD_INT 23
52496: PUSH
52497: LD_INT 24
52499: PUSH
52500: EMPTY
52501: LIST
52502: LIST
52503: LIST
52504: LIST
52505: ST_TO_ADDR
52506: GO 52791
52508: LD_INT 43
52510: DOUBLE
52511: EQUAL
52512: IFTRUE 52516
52514: GO 52542
52516: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52517: LD_ADDR_VAR 0 3
52521: PUSH
52522: LD_INT 21
52524: PUSH
52525: LD_INT 22
52527: PUSH
52528: LD_INT 23
52530: PUSH
52531: LD_INT 24
52533: PUSH
52534: EMPTY
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: ST_TO_ADDR
52540: GO 52791
52542: LD_INT 44
52544: DOUBLE
52545: EQUAL
52546: IFTRUE 52550
52548: GO 52576
52550: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52551: LD_ADDR_VAR 0 3
52555: PUSH
52556: LD_INT 21
52558: PUSH
52559: LD_INT 22
52561: PUSH
52562: LD_INT 23
52564: PUSH
52565: LD_INT 24
52567: PUSH
52568: EMPTY
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: ST_TO_ADDR
52574: GO 52791
52576: LD_INT 45
52578: DOUBLE
52579: EQUAL
52580: IFTRUE 52584
52582: GO 52610
52584: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52585: LD_ADDR_VAR 0 3
52589: PUSH
52590: LD_INT 21
52592: PUSH
52593: LD_INT 22
52595: PUSH
52596: LD_INT 23
52598: PUSH
52599: LD_INT 24
52601: PUSH
52602: EMPTY
52603: LIST
52604: LIST
52605: LIST
52606: LIST
52607: ST_TO_ADDR
52608: GO 52791
52610: LD_INT 49
52612: DOUBLE
52613: EQUAL
52614: IFTRUE 52618
52616: GO 52644
52618: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52619: LD_ADDR_VAR 0 3
52623: PUSH
52624: LD_INT 21
52626: PUSH
52627: LD_INT 22
52629: PUSH
52630: LD_INT 23
52632: PUSH
52633: LD_INT 24
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: ST_TO_ADDR
52642: GO 52791
52644: LD_INT 51
52646: DOUBLE
52647: EQUAL
52648: IFTRUE 52652
52650: GO 52678
52652: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52653: LD_ADDR_VAR 0 3
52657: PUSH
52658: LD_INT 21
52660: PUSH
52661: LD_INT 22
52663: PUSH
52664: LD_INT 23
52666: PUSH
52667: LD_INT 24
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: LIST
52674: LIST
52675: ST_TO_ADDR
52676: GO 52791
52678: LD_INT 52
52680: DOUBLE
52681: EQUAL
52682: IFTRUE 52686
52684: GO 52712
52686: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52687: LD_ADDR_VAR 0 3
52691: PUSH
52692: LD_INT 21
52694: PUSH
52695: LD_INT 22
52697: PUSH
52698: LD_INT 23
52700: PUSH
52701: LD_INT 24
52703: PUSH
52704: EMPTY
52705: LIST
52706: LIST
52707: LIST
52708: LIST
52709: ST_TO_ADDR
52710: GO 52791
52712: LD_INT 53
52714: DOUBLE
52715: EQUAL
52716: IFTRUE 52720
52718: GO 52738
52720: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52721: LD_ADDR_VAR 0 3
52725: PUSH
52726: LD_INT 23
52728: PUSH
52729: LD_INT 24
52731: PUSH
52732: EMPTY
52733: LIST
52734: LIST
52735: ST_TO_ADDR
52736: GO 52791
52738: LD_INT 46
52740: DOUBLE
52741: EQUAL
52742: IFTRUE 52746
52744: GO 52764
52746: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52747: LD_ADDR_VAR 0 3
52751: PUSH
52752: LD_INT 23
52754: PUSH
52755: LD_INT 24
52757: PUSH
52758: EMPTY
52759: LIST
52760: LIST
52761: ST_TO_ADDR
52762: GO 52791
52764: LD_INT 47
52766: DOUBLE
52767: EQUAL
52768: IFTRUE 52772
52770: GO 52790
52772: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52773: LD_ADDR_VAR 0 3
52777: PUSH
52778: LD_INT 23
52780: PUSH
52781: LD_INT 24
52783: PUSH
52784: EMPTY
52785: LIST
52786: LIST
52787: ST_TO_ADDR
52788: GO 52791
52790: POP
// result := ( chassis in result ) ;
52791: LD_ADDR_VAR 0 3
52795: PUSH
52796: LD_VAR 0 1
52800: PUSH
52801: LD_VAR 0 3
52805: IN
52806: ST_TO_ADDR
// end ;
52807: LD_VAR 0 3
52811: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52812: LD_INT 0
52814: PPUSH
52815: PPUSH
52816: PPUSH
52817: PPUSH
52818: PPUSH
52819: PPUSH
52820: PPUSH
// result := array ;
52821: LD_ADDR_VAR 0 5
52825: PUSH
52826: LD_VAR 0 1
52830: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52831: LD_VAR 0 1
52835: NOT
52836: PUSH
52837: LD_VAR 0 2
52841: NOT
52842: OR
52843: PUSH
52844: LD_VAR 0 3
52848: NOT
52849: OR
52850: PUSH
52851: LD_VAR 0 2
52855: PUSH
52856: LD_VAR 0 1
52860: GREATER
52861: OR
52862: PUSH
52863: LD_VAR 0 3
52867: PUSH
52868: LD_VAR 0 1
52872: GREATER
52873: OR
52874: IFFALSE 52878
// exit ;
52876: GO 53174
// if direction then
52878: LD_VAR 0 4
52882: IFFALSE 52946
// begin d := 1 ;
52884: LD_ADDR_VAR 0 9
52888: PUSH
52889: LD_INT 1
52891: ST_TO_ADDR
// if i_from > i_to then
52892: LD_VAR 0 2
52896: PUSH
52897: LD_VAR 0 3
52901: GREATER
52902: IFFALSE 52928
// length := ( array - i_from ) + i_to else
52904: LD_ADDR_VAR 0 11
52908: PUSH
52909: LD_VAR 0 1
52913: PUSH
52914: LD_VAR 0 2
52918: MINUS
52919: PUSH
52920: LD_VAR 0 3
52924: PLUS
52925: ST_TO_ADDR
52926: GO 52944
// length := i_to - i_from ;
52928: LD_ADDR_VAR 0 11
52932: PUSH
52933: LD_VAR 0 3
52937: PUSH
52938: LD_VAR 0 2
52942: MINUS
52943: ST_TO_ADDR
// end else
52944: GO 53007
// begin d := - 1 ;
52946: LD_ADDR_VAR 0 9
52950: PUSH
52951: LD_INT 1
52953: NEG
52954: ST_TO_ADDR
// if i_from > i_to then
52955: LD_VAR 0 2
52959: PUSH
52960: LD_VAR 0 3
52964: GREATER
52965: IFFALSE 52985
// length := i_from - i_to else
52967: LD_ADDR_VAR 0 11
52971: PUSH
52972: LD_VAR 0 2
52976: PUSH
52977: LD_VAR 0 3
52981: MINUS
52982: ST_TO_ADDR
52983: GO 53007
// length := ( array - i_to ) + i_from ;
52985: LD_ADDR_VAR 0 11
52989: PUSH
52990: LD_VAR 0 1
52994: PUSH
52995: LD_VAR 0 3
52999: MINUS
53000: PUSH
53001: LD_VAR 0 2
53005: PLUS
53006: ST_TO_ADDR
// end ; if not length then
53007: LD_VAR 0 11
53011: NOT
53012: IFFALSE 53016
// exit ;
53014: GO 53174
// tmp := array ;
53016: LD_ADDR_VAR 0 10
53020: PUSH
53021: LD_VAR 0 1
53025: ST_TO_ADDR
// for i = 1 to length do
53026: LD_ADDR_VAR 0 6
53030: PUSH
53031: DOUBLE
53032: LD_INT 1
53034: DEC
53035: ST_TO_ADDR
53036: LD_VAR 0 11
53040: PUSH
53041: FOR_TO
53042: IFFALSE 53162
// begin for j = 1 to array do
53044: LD_ADDR_VAR 0 7
53048: PUSH
53049: DOUBLE
53050: LD_INT 1
53052: DEC
53053: ST_TO_ADDR
53054: LD_VAR 0 1
53058: PUSH
53059: FOR_TO
53060: IFFALSE 53148
// begin k := j + d ;
53062: LD_ADDR_VAR 0 8
53066: PUSH
53067: LD_VAR 0 7
53071: PUSH
53072: LD_VAR 0 9
53076: PLUS
53077: ST_TO_ADDR
// if k > array then
53078: LD_VAR 0 8
53082: PUSH
53083: LD_VAR 0 1
53087: GREATER
53088: IFFALSE 53098
// k := 1 ;
53090: LD_ADDR_VAR 0 8
53094: PUSH
53095: LD_INT 1
53097: ST_TO_ADDR
// if not k then
53098: LD_VAR 0 8
53102: NOT
53103: IFFALSE 53115
// k := array ;
53105: LD_ADDR_VAR 0 8
53109: PUSH
53110: LD_VAR 0 1
53114: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53115: LD_ADDR_VAR 0 10
53119: PUSH
53120: LD_VAR 0 10
53124: PPUSH
53125: LD_VAR 0 8
53129: PPUSH
53130: LD_VAR 0 1
53134: PUSH
53135: LD_VAR 0 7
53139: ARRAY
53140: PPUSH
53141: CALL_OW 1
53145: ST_TO_ADDR
// end ;
53146: GO 53059
53148: POP
53149: POP
// array := tmp ;
53150: LD_ADDR_VAR 0 1
53154: PUSH
53155: LD_VAR 0 10
53159: ST_TO_ADDR
// end ;
53160: GO 53041
53162: POP
53163: POP
// result := array ;
53164: LD_ADDR_VAR 0 5
53168: PUSH
53169: LD_VAR 0 1
53173: ST_TO_ADDR
// end ;
53174: LD_VAR 0 5
53178: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53179: LD_INT 0
53181: PPUSH
53182: PPUSH
// result := 0 ;
53183: LD_ADDR_VAR 0 3
53187: PUSH
53188: LD_INT 0
53190: ST_TO_ADDR
// if not array or not value in array then
53191: LD_VAR 0 1
53195: NOT
53196: PUSH
53197: LD_VAR 0 2
53201: PUSH
53202: LD_VAR 0 1
53206: IN
53207: NOT
53208: OR
53209: IFFALSE 53213
// exit ;
53211: GO 53267
// for i = 1 to array do
53213: LD_ADDR_VAR 0 4
53217: PUSH
53218: DOUBLE
53219: LD_INT 1
53221: DEC
53222: ST_TO_ADDR
53223: LD_VAR 0 1
53227: PUSH
53228: FOR_TO
53229: IFFALSE 53265
// if value = array [ i ] then
53231: LD_VAR 0 2
53235: PUSH
53236: LD_VAR 0 1
53240: PUSH
53241: LD_VAR 0 4
53245: ARRAY
53246: EQUAL
53247: IFFALSE 53263
// begin result := i ;
53249: LD_ADDR_VAR 0 3
53253: PUSH
53254: LD_VAR 0 4
53258: ST_TO_ADDR
// exit ;
53259: POP
53260: POP
53261: GO 53267
// end ;
53263: GO 53228
53265: POP
53266: POP
// end ;
53267: LD_VAR 0 3
53271: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53272: LD_INT 0
53274: PPUSH
// vc_chassis := chassis ;
53275: LD_ADDR_OWVAR 37
53279: PUSH
53280: LD_VAR 0 1
53284: ST_TO_ADDR
// vc_engine := engine ;
53285: LD_ADDR_OWVAR 39
53289: PUSH
53290: LD_VAR 0 2
53294: ST_TO_ADDR
// vc_control := control ;
53295: LD_ADDR_OWVAR 38
53299: PUSH
53300: LD_VAR 0 3
53304: ST_TO_ADDR
// vc_weapon := weapon ;
53305: LD_ADDR_OWVAR 40
53309: PUSH
53310: LD_VAR 0 4
53314: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53315: LD_ADDR_OWVAR 41
53319: PUSH
53320: LD_VAR 0 5
53324: ST_TO_ADDR
// end ;
53325: LD_VAR 0 6
53329: RET
// export function WantPlant ( unit ) ; var task ; begin
53330: LD_INT 0
53332: PPUSH
53333: PPUSH
// result := false ;
53334: LD_ADDR_VAR 0 2
53338: PUSH
53339: LD_INT 0
53341: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53342: LD_ADDR_VAR 0 3
53346: PUSH
53347: LD_VAR 0 1
53351: PPUSH
53352: CALL_OW 437
53356: ST_TO_ADDR
// if task then
53357: LD_VAR 0 3
53361: IFFALSE 53389
// if task [ 1 ] [ 1 ] = p then
53363: LD_VAR 0 3
53367: PUSH
53368: LD_INT 1
53370: ARRAY
53371: PUSH
53372: LD_INT 1
53374: ARRAY
53375: PUSH
53376: LD_STRING p
53378: EQUAL
53379: IFFALSE 53389
// result := true ;
53381: LD_ADDR_VAR 0 2
53385: PUSH
53386: LD_INT 1
53388: ST_TO_ADDR
// end ;
53389: LD_VAR 0 2
53393: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53394: LD_INT 0
53396: PPUSH
53397: PPUSH
53398: PPUSH
53399: PPUSH
// if pos < 1 then
53400: LD_VAR 0 2
53404: PUSH
53405: LD_INT 1
53407: LESS
53408: IFFALSE 53412
// exit ;
53410: GO 53715
// if pos = 1 then
53412: LD_VAR 0 2
53416: PUSH
53417: LD_INT 1
53419: EQUAL
53420: IFFALSE 53453
// result := Replace ( arr , pos [ 1 ] , value ) else
53422: LD_ADDR_VAR 0 4
53426: PUSH
53427: LD_VAR 0 1
53431: PPUSH
53432: LD_VAR 0 2
53436: PUSH
53437: LD_INT 1
53439: ARRAY
53440: PPUSH
53441: LD_VAR 0 3
53445: PPUSH
53446: CALL_OW 1
53450: ST_TO_ADDR
53451: GO 53715
// begin tmp := arr ;
53453: LD_ADDR_VAR 0 6
53457: PUSH
53458: LD_VAR 0 1
53462: ST_TO_ADDR
// s_arr := [ tmp ] ;
53463: LD_ADDR_VAR 0 7
53467: PUSH
53468: LD_VAR 0 6
53472: PUSH
53473: EMPTY
53474: LIST
53475: ST_TO_ADDR
// for i = 1 to pos - 1 do
53476: LD_ADDR_VAR 0 5
53480: PUSH
53481: DOUBLE
53482: LD_INT 1
53484: DEC
53485: ST_TO_ADDR
53486: LD_VAR 0 2
53490: PUSH
53491: LD_INT 1
53493: MINUS
53494: PUSH
53495: FOR_TO
53496: IFFALSE 53541
// begin tmp := tmp [ pos [ i ] ] ;
53498: LD_ADDR_VAR 0 6
53502: PUSH
53503: LD_VAR 0 6
53507: PUSH
53508: LD_VAR 0 2
53512: PUSH
53513: LD_VAR 0 5
53517: ARRAY
53518: ARRAY
53519: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53520: LD_ADDR_VAR 0 7
53524: PUSH
53525: LD_VAR 0 7
53529: PUSH
53530: LD_VAR 0 6
53534: PUSH
53535: EMPTY
53536: LIST
53537: ADD
53538: ST_TO_ADDR
// end ;
53539: GO 53495
53541: POP
53542: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53543: LD_ADDR_VAR 0 6
53547: PUSH
53548: LD_VAR 0 6
53552: PPUSH
53553: LD_VAR 0 2
53557: PUSH
53558: LD_VAR 0 2
53562: ARRAY
53563: PPUSH
53564: LD_VAR 0 3
53568: PPUSH
53569: CALL_OW 1
53573: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53574: LD_ADDR_VAR 0 7
53578: PUSH
53579: LD_VAR 0 7
53583: PPUSH
53584: LD_VAR 0 7
53588: PPUSH
53589: LD_VAR 0 6
53593: PPUSH
53594: CALL_OW 1
53598: ST_TO_ADDR
// for i = s_arr downto 2 do
53599: LD_ADDR_VAR 0 5
53603: PUSH
53604: DOUBLE
53605: LD_VAR 0 7
53609: INC
53610: ST_TO_ADDR
53611: LD_INT 2
53613: PUSH
53614: FOR_DOWNTO
53615: IFFALSE 53699
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53617: LD_ADDR_VAR 0 6
53621: PUSH
53622: LD_VAR 0 7
53626: PUSH
53627: LD_VAR 0 5
53631: PUSH
53632: LD_INT 1
53634: MINUS
53635: ARRAY
53636: PPUSH
53637: LD_VAR 0 2
53641: PUSH
53642: LD_VAR 0 5
53646: PUSH
53647: LD_INT 1
53649: MINUS
53650: ARRAY
53651: PPUSH
53652: LD_VAR 0 7
53656: PUSH
53657: LD_VAR 0 5
53661: ARRAY
53662: PPUSH
53663: CALL_OW 1
53667: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53668: LD_ADDR_VAR 0 7
53672: PUSH
53673: LD_VAR 0 7
53677: PPUSH
53678: LD_VAR 0 5
53682: PUSH
53683: LD_INT 1
53685: MINUS
53686: PPUSH
53687: LD_VAR 0 6
53691: PPUSH
53692: CALL_OW 1
53696: ST_TO_ADDR
// end ;
53697: GO 53614
53699: POP
53700: POP
// result := s_arr [ 1 ] ;
53701: LD_ADDR_VAR 0 4
53705: PUSH
53706: LD_VAR 0 7
53710: PUSH
53711: LD_INT 1
53713: ARRAY
53714: ST_TO_ADDR
// end ; end ;
53715: LD_VAR 0 4
53719: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53720: LD_INT 0
53722: PPUSH
53723: PPUSH
// if not list then
53724: LD_VAR 0 1
53728: NOT
53729: IFFALSE 53733
// exit ;
53731: GO 53824
// i := list [ pos1 ] ;
53733: LD_ADDR_VAR 0 5
53737: PUSH
53738: LD_VAR 0 1
53742: PUSH
53743: LD_VAR 0 2
53747: ARRAY
53748: ST_TO_ADDR
// if not i then
53749: LD_VAR 0 5
53753: NOT
53754: IFFALSE 53758
// exit ;
53756: GO 53824
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53758: LD_ADDR_VAR 0 1
53762: PUSH
53763: LD_VAR 0 1
53767: PPUSH
53768: LD_VAR 0 2
53772: PPUSH
53773: LD_VAR 0 1
53777: PUSH
53778: LD_VAR 0 3
53782: ARRAY
53783: PPUSH
53784: CALL_OW 1
53788: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53789: LD_ADDR_VAR 0 1
53793: PUSH
53794: LD_VAR 0 1
53798: PPUSH
53799: LD_VAR 0 3
53803: PPUSH
53804: LD_VAR 0 5
53808: PPUSH
53809: CALL_OW 1
53813: ST_TO_ADDR
// result := list ;
53814: LD_ADDR_VAR 0 4
53818: PUSH
53819: LD_VAR 0 1
53823: ST_TO_ADDR
// end ;
53824: LD_VAR 0 4
53828: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53829: LD_INT 0
53831: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53832: LD_ADDR_VAR 0 5
53836: PUSH
53837: LD_VAR 0 1
53841: PPUSH
53842: CALL_OW 250
53846: PPUSH
53847: LD_VAR 0 1
53851: PPUSH
53852: CALL_OW 251
53856: PPUSH
53857: LD_VAR 0 2
53861: PPUSH
53862: LD_VAR 0 3
53866: PPUSH
53867: LD_VAR 0 4
53871: PPUSH
53872: CALL 53882 0 5
53876: ST_TO_ADDR
// end ;
53877: LD_VAR 0 5
53881: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53882: LD_INT 0
53884: PPUSH
53885: PPUSH
53886: PPUSH
53887: PPUSH
// if not list then
53888: LD_VAR 0 3
53892: NOT
53893: IFFALSE 53897
// exit ;
53895: GO 54285
// result := [ ] ;
53897: LD_ADDR_VAR 0 6
53901: PUSH
53902: EMPTY
53903: ST_TO_ADDR
// for i in list do
53904: LD_ADDR_VAR 0 7
53908: PUSH
53909: LD_VAR 0 3
53913: PUSH
53914: FOR_IN
53915: IFFALSE 54117
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53917: LD_ADDR_VAR 0 9
53921: PUSH
53922: LD_VAR 0 7
53926: PPUSH
53927: LD_VAR 0 1
53931: PPUSH
53932: LD_VAR 0 2
53936: PPUSH
53937: CALL_OW 297
53941: ST_TO_ADDR
// if not result then
53942: LD_VAR 0 6
53946: NOT
53947: IFFALSE 53973
// result := [ [ i , tmp ] ] else
53949: LD_ADDR_VAR 0 6
53953: PUSH
53954: LD_VAR 0 7
53958: PUSH
53959: LD_VAR 0 9
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: PUSH
53968: EMPTY
53969: LIST
53970: ST_TO_ADDR
53971: GO 54115
// begin if result [ result ] [ 2 ] < tmp then
53973: LD_VAR 0 6
53977: PUSH
53978: LD_VAR 0 6
53982: ARRAY
53983: PUSH
53984: LD_INT 2
53986: ARRAY
53987: PUSH
53988: LD_VAR 0 9
53992: LESS
53993: IFFALSE 54035
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53995: LD_ADDR_VAR 0 6
53999: PUSH
54000: LD_VAR 0 6
54004: PPUSH
54005: LD_VAR 0 6
54009: PUSH
54010: LD_INT 1
54012: PLUS
54013: PPUSH
54014: LD_VAR 0 7
54018: PUSH
54019: LD_VAR 0 9
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PPUSH
54028: CALL_OW 2
54032: ST_TO_ADDR
54033: GO 54115
// for j = 1 to result do
54035: LD_ADDR_VAR 0 8
54039: PUSH
54040: DOUBLE
54041: LD_INT 1
54043: DEC
54044: ST_TO_ADDR
54045: LD_VAR 0 6
54049: PUSH
54050: FOR_TO
54051: IFFALSE 54113
// begin if tmp < result [ j ] [ 2 ] then
54053: LD_VAR 0 9
54057: PUSH
54058: LD_VAR 0 6
54062: PUSH
54063: LD_VAR 0 8
54067: ARRAY
54068: PUSH
54069: LD_INT 2
54071: ARRAY
54072: LESS
54073: IFFALSE 54111
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54075: LD_ADDR_VAR 0 6
54079: PUSH
54080: LD_VAR 0 6
54084: PPUSH
54085: LD_VAR 0 8
54089: PPUSH
54090: LD_VAR 0 7
54094: PUSH
54095: LD_VAR 0 9
54099: PUSH
54100: EMPTY
54101: LIST
54102: LIST
54103: PPUSH
54104: CALL_OW 2
54108: ST_TO_ADDR
// break ;
54109: GO 54113
// end ; end ;
54111: GO 54050
54113: POP
54114: POP
// end ; end ;
54115: GO 53914
54117: POP
54118: POP
// if result and not asc then
54119: LD_VAR 0 6
54123: PUSH
54124: LD_VAR 0 4
54128: NOT
54129: AND
54130: IFFALSE 54205
// begin tmp := result ;
54132: LD_ADDR_VAR 0 9
54136: PUSH
54137: LD_VAR 0 6
54141: ST_TO_ADDR
// for i = tmp downto 1 do
54142: LD_ADDR_VAR 0 7
54146: PUSH
54147: DOUBLE
54148: LD_VAR 0 9
54152: INC
54153: ST_TO_ADDR
54154: LD_INT 1
54156: PUSH
54157: FOR_DOWNTO
54158: IFFALSE 54203
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54160: LD_ADDR_VAR 0 6
54164: PUSH
54165: LD_VAR 0 6
54169: PPUSH
54170: LD_VAR 0 9
54174: PUSH
54175: LD_VAR 0 7
54179: MINUS
54180: PUSH
54181: LD_INT 1
54183: PLUS
54184: PPUSH
54185: LD_VAR 0 9
54189: PUSH
54190: LD_VAR 0 7
54194: ARRAY
54195: PPUSH
54196: CALL_OW 1
54200: ST_TO_ADDR
54201: GO 54157
54203: POP
54204: POP
// end ; tmp := [ ] ;
54205: LD_ADDR_VAR 0 9
54209: PUSH
54210: EMPTY
54211: ST_TO_ADDR
// if mode then
54212: LD_VAR 0 5
54216: IFFALSE 54285
// begin for i = 1 to result do
54218: LD_ADDR_VAR 0 7
54222: PUSH
54223: DOUBLE
54224: LD_INT 1
54226: DEC
54227: ST_TO_ADDR
54228: LD_VAR 0 6
54232: PUSH
54233: FOR_TO
54234: IFFALSE 54273
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54236: LD_ADDR_VAR 0 9
54240: PUSH
54241: LD_VAR 0 9
54245: PPUSH
54246: LD_VAR 0 7
54250: PPUSH
54251: LD_VAR 0 6
54255: PUSH
54256: LD_VAR 0 7
54260: ARRAY
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: PPUSH
54266: CALL_OW 1
54270: ST_TO_ADDR
54271: GO 54233
54273: POP
54274: POP
// result := tmp ;
54275: LD_ADDR_VAR 0 6
54279: PUSH
54280: LD_VAR 0 9
54284: ST_TO_ADDR
// end ; end ;
54285: LD_VAR 0 6
54289: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54290: LD_INT 0
54292: PPUSH
54293: PPUSH
54294: PPUSH
54295: PPUSH
54296: PPUSH
54297: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54298: LD_ADDR_VAR 0 5
54302: PUSH
54303: LD_INT 0
54305: PUSH
54306: LD_INT 0
54308: PUSH
54309: LD_INT 0
54311: PUSH
54312: EMPTY
54313: PUSH
54314: EMPTY
54315: LIST
54316: LIST
54317: LIST
54318: LIST
54319: ST_TO_ADDR
// if not x or not y then
54320: LD_VAR 0 2
54324: NOT
54325: PUSH
54326: LD_VAR 0 3
54330: NOT
54331: OR
54332: IFFALSE 54336
// exit ;
54334: GO 55988
// if not range then
54336: LD_VAR 0 4
54340: NOT
54341: IFFALSE 54351
// range := 10 ;
54343: LD_ADDR_VAR 0 4
54347: PUSH
54348: LD_INT 10
54350: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54351: LD_ADDR_VAR 0 8
54355: PUSH
54356: LD_INT 81
54358: PUSH
54359: LD_VAR 0 1
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: PUSH
54368: LD_INT 92
54370: PUSH
54371: LD_VAR 0 2
54375: PUSH
54376: LD_VAR 0 3
54380: PUSH
54381: LD_VAR 0 4
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: LIST
54390: LIST
54391: PUSH
54392: LD_INT 3
54394: PUSH
54395: LD_INT 21
54397: PUSH
54398: LD_INT 3
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: EMPTY
54406: LIST
54407: LIST
54408: PUSH
54409: EMPTY
54410: LIST
54411: LIST
54412: LIST
54413: PPUSH
54414: CALL_OW 69
54418: ST_TO_ADDR
// if not tmp then
54419: LD_VAR 0 8
54423: NOT
54424: IFFALSE 54428
// exit ;
54426: GO 55988
// for i in tmp do
54428: LD_ADDR_VAR 0 6
54432: PUSH
54433: LD_VAR 0 8
54437: PUSH
54438: FOR_IN
54439: IFFALSE 55963
// begin points := [ 0 , 0 , 0 ] ;
54441: LD_ADDR_VAR 0 9
54445: PUSH
54446: LD_INT 0
54448: PUSH
54449: LD_INT 0
54451: PUSH
54452: LD_INT 0
54454: PUSH
54455: EMPTY
54456: LIST
54457: LIST
54458: LIST
54459: ST_TO_ADDR
// bpoints := 1 ;
54460: LD_ADDR_VAR 0 10
54464: PUSH
54465: LD_INT 1
54467: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54468: LD_VAR 0 6
54472: PPUSH
54473: CALL_OW 247
54477: PUSH
54478: LD_INT 1
54480: DOUBLE
54481: EQUAL
54482: IFTRUE 54486
54484: GO 55064
54486: POP
// begin if GetClass ( i ) = 1 then
54487: LD_VAR 0 6
54491: PPUSH
54492: CALL_OW 257
54496: PUSH
54497: LD_INT 1
54499: EQUAL
54500: IFFALSE 54521
// points := [ 10 , 5 , 3 ] ;
54502: LD_ADDR_VAR 0 9
54506: PUSH
54507: LD_INT 10
54509: PUSH
54510: LD_INT 5
54512: PUSH
54513: LD_INT 3
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: LIST
54520: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54521: LD_VAR 0 6
54525: PPUSH
54526: CALL_OW 257
54530: PUSH
54531: LD_INT 2
54533: PUSH
54534: LD_INT 3
54536: PUSH
54537: LD_INT 4
54539: PUSH
54540: EMPTY
54541: LIST
54542: LIST
54543: LIST
54544: IN
54545: IFFALSE 54566
// points := [ 3 , 2 , 1 ] ;
54547: LD_ADDR_VAR 0 9
54551: PUSH
54552: LD_INT 3
54554: PUSH
54555: LD_INT 2
54557: PUSH
54558: LD_INT 1
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: LIST
54565: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54566: LD_VAR 0 6
54570: PPUSH
54571: CALL_OW 257
54575: PUSH
54576: LD_INT 5
54578: EQUAL
54579: IFFALSE 54600
// points := [ 130 , 5 , 2 ] ;
54581: LD_ADDR_VAR 0 9
54585: PUSH
54586: LD_INT 130
54588: PUSH
54589: LD_INT 5
54591: PUSH
54592: LD_INT 2
54594: PUSH
54595: EMPTY
54596: LIST
54597: LIST
54598: LIST
54599: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54600: LD_VAR 0 6
54604: PPUSH
54605: CALL_OW 257
54609: PUSH
54610: LD_INT 8
54612: EQUAL
54613: IFFALSE 54634
// points := [ 35 , 35 , 30 ] ;
54615: LD_ADDR_VAR 0 9
54619: PUSH
54620: LD_INT 35
54622: PUSH
54623: LD_INT 35
54625: PUSH
54626: LD_INT 30
54628: PUSH
54629: EMPTY
54630: LIST
54631: LIST
54632: LIST
54633: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54634: LD_VAR 0 6
54638: PPUSH
54639: CALL_OW 257
54643: PUSH
54644: LD_INT 9
54646: EQUAL
54647: IFFALSE 54668
// points := [ 20 , 55 , 40 ] ;
54649: LD_ADDR_VAR 0 9
54653: PUSH
54654: LD_INT 20
54656: PUSH
54657: LD_INT 55
54659: PUSH
54660: LD_INT 40
54662: PUSH
54663: EMPTY
54664: LIST
54665: LIST
54666: LIST
54667: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54668: LD_VAR 0 6
54672: PPUSH
54673: CALL_OW 257
54677: PUSH
54678: LD_INT 12
54680: PUSH
54681: LD_INT 16
54683: PUSH
54684: EMPTY
54685: LIST
54686: LIST
54687: IN
54688: IFFALSE 54709
// points := [ 5 , 3 , 2 ] ;
54690: LD_ADDR_VAR 0 9
54694: PUSH
54695: LD_INT 5
54697: PUSH
54698: LD_INT 3
54700: PUSH
54701: LD_INT 2
54703: PUSH
54704: EMPTY
54705: LIST
54706: LIST
54707: LIST
54708: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54709: LD_VAR 0 6
54713: PPUSH
54714: CALL_OW 257
54718: PUSH
54719: LD_INT 17
54721: EQUAL
54722: IFFALSE 54743
// points := [ 100 , 50 , 75 ] ;
54724: LD_ADDR_VAR 0 9
54728: PUSH
54729: LD_INT 100
54731: PUSH
54732: LD_INT 50
54734: PUSH
54735: LD_INT 75
54737: PUSH
54738: EMPTY
54739: LIST
54740: LIST
54741: LIST
54742: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54743: LD_VAR 0 6
54747: PPUSH
54748: CALL_OW 257
54752: PUSH
54753: LD_INT 15
54755: EQUAL
54756: IFFALSE 54777
// points := [ 10 , 5 , 3 ] ;
54758: LD_ADDR_VAR 0 9
54762: PUSH
54763: LD_INT 10
54765: PUSH
54766: LD_INT 5
54768: PUSH
54769: LD_INT 3
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: LIST
54776: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54777: LD_VAR 0 6
54781: PPUSH
54782: CALL_OW 257
54786: PUSH
54787: LD_INT 14
54789: EQUAL
54790: IFFALSE 54811
// points := [ 10 , 0 , 0 ] ;
54792: LD_ADDR_VAR 0 9
54796: PUSH
54797: LD_INT 10
54799: PUSH
54800: LD_INT 0
54802: PUSH
54803: LD_INT 0
54805: PUSH
54806: EMPTY
54807: LIST
54808: LIST
54809: LIST
54810: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54811: LD_VAR 0 6
54815: PPUSH
54816: CALL_OW 257
54820: PUSH
54821: LD_INT 11
54823: EQUAL
54824: IFFALSE 54845
// points := [ 30 , 10 , 5 ] ;
54826: LD_ADDR_VAR 0 9
54830: PUSH
54831: LD_INT 30
54833: PUSH
54834: LD_INT 10
54836: PUSH
54837: LD_INT 5
54839: PUSH
54840: EMPTY
54841: LIST
54842: LIST
54843: LIST
54844: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54845: LD_VAR 0 1
54849: PPUSH
54850: LD_INT 5
54852: PPUSH
54853: CALL_OW 321
54857: PUSH
54858: LD_INT 2
54860: EQUAL
54861: IFFALSE 54878
// bpoints := bpoints * 1.8 ;
54863: LD_ADDR_VAR 0 10
54867: PUSH
54868: LD_VAR 0 10
54872: PUSH
54873: LD_REAL  1.80000000000000E+0000
54876: MUL
54877: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54878: LD_VAR 0 6
54882: PPUSH
54883: CALL_OW 257
54887: PUSH
54888: LD_INT 1
54890: PUSH
54891: LD_INT 2
54893: PUSH
54894: LD_INT 3
54896: PUSH
54897: LD_INT 4
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: LIST
54905: IN
54906: PUSH
54907: LD_VAR 0 1
54911: PPUSH
54912: LD_INT 51
54914: PPUSH
54915: CALL_OW 321
54919: PUSH
54920: LD_INT 2
54922: EQUAL
54923: AND
54924: IFFALSE 54941
// bpoints := bpoints * 1.2 ;
54926: LD_ADDR_VAR 0 10
54930: PUSH
54931: LD_VAR 0 10
54935: PUSH
54936: LD_REAL  1.20000000000000E+0000
54939: MUL
54940: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54941: LD_VAR 0 6
54945: PPUSH
54946: CALL_OW 257
54950: PUSH
54951: LD_INT 5
54953: PUSH
54954: LD_INT 7
54956: PUSH
54957: LD_INT 9
54959: PUSH
54960: EMPTY
54961: LIST
54962: LIST
54963: LIST
54964: IN
54965: PUSH
54966: LD_VAR 0 1
54970: PPUSH
54971: LD_INT 52
54973: PPUSH
54974: CALL_OW 321
54978: PUSH
54979: LD_INT 2
54981: EQUAL
54982: AND
54983: IFFALSE 55000
// bpoints := bpoints * 1.5 ;
54985: LD_ADDR_VAR 0 10
54989: PUSH
54990: LD_VAR 0 10
54994: PUSH
54995: LD_REAL  1.50000000000000E+0000
54998: MUL
54999: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55000: LD_VAR 0 1
55004: PPUSH
55005: LD_INT 66
55007: PPUSH
55008: CALL_OW 321
55012: PUSH
55013: LD_INT 2
55015: EQUAL
55016: IFFALSE 55033
// bpoints := bpoints * 1.1 ;
55018: LD_ADDR_VAR 0 10
55022: PUSH
55023: LD_VAR 0 10
55027: PUSH
55028: LD_REAL  1.10000000000000E+0000
55031: MUL
55032: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55033: LD_ADDR_VAR 0 10
55037: PUSH
55038: LD_VAR 0 10
55042: PUSH
55043: LD_VAR 0 6
55047: PPUSH
55048: LD_INT 1
55050: PPUSH
55051: CALL_OW 259
55055: PUSH
55056: LD_REAL  1.15000000000000E+0000
55059: MUL
55060: MUL
55061: ST_TO_ADDR
// end ; unit_vehicle :
55062: GO 55892
55064: LD_INT 2
55066: DOUBLE
55067: EQUAL
55068: IFTRUE 55072
55070: GO 55880
55072: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55073: LD_VAR 0 6
55077: PPUSH
55078: CALL_OW 264
55082: PUSH
55083: LD_INT 2
55085: PUSH
55086: LD_INT 42
55088: PUSH
55089: LD_INT 24
55091: PUSH
55092: EMPTY
55093: LIST
55094: LIST
55095: LIST
55096: IN
55097: IFFALSE 55118
// points := [ 25 , 5 , 3 ] ;
55099: LD_ADDR_VAR 0 9
55103: PUSH
55104: LD_INT 25
55106: PUSH
55107: LD_INT 5
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55118: LD_VAR 0 6
55122: PPUSH
55123: CALL_OW 264
55127: PUSH
55128: LD_INT 4
55130: PUSH
55131: LD_INT 43
55133: PUSH
55134: LD_INT 25
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: LIST
55141: IN
55142: IFFALSE 55163
// points := [ 40 , 15 , 5 ] ;
55144: LD_ADDR_VAR 0 9
55148: PUSH
55149: LD_INT 40
55151: PUSH
55152: LD_INT 15
55154: PUSH
55155: LD_INT 5
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: LIST
55162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55163: LD_VAR 0 6
55167: PPUSH
55168: CALL_OW 264
55172: PUSH
55173: LD_INT 3
55175: PUSH
55176: LD_INT 23
55178: PUSH
55179: EMPTY
55180: LIST
55181: LIST
55182: IN
55183: IFFALSE 55204
// points := [ 7 , 25 , 8 ] ;
55185: LD_ADDR_VAR 0 9
55189: PUSH
55190: LD_INT 7
55192: PUSH
55193: LD_INT 25
55195: PUSH
55196: LD_INT 8
55198: PUSH
55199: EMPTY
55200: LIST
55201: LIST
55202: LIST
55203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55204: LD_VAR 0 6
55208: PPUSH
55209: CALL_OW 264
55213: PUSH
55214: LD_INT 5
55216: PUSH
55217: LD_INT 27
55219: PUSH
55220: LD_INT 44
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: LIST
55227: IN
55228: IFFALSE 55249
// points := [ 14 , 50 , 16 ] ;
55230: LD_ADDR_VAR 0 9
55234: PUSH
55235: LD_INT 14
55237: PUSH
55238: LD_INT 50
55240: PUSH
55241: LD_INT 16
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55249: LD_VAR 0 6
55253: PPUSH
55254: CALL_OW 264
55258: PUSH
55259: LD_INT 6
55261: PUSH
55262: LD_INT 46
55264: PUSH
55265: EMPTY
55266: LIST
55267: LIST
55268: IN
55269: IFFALSE 55290
// points := [ 32 , 120 , 70 ] ;
55271: LD_ADDR_VAR 0 9
55275: PUSH
55276: LD_INT 32
55278: PUSH
55279: LD_INT 120
55281: PUSH
55282: LD_INT 70
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: LIST
55289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55290: LD_VAR 0 6
55294: PPUSH
55295: CALL_OW 264
55299: PUSH
55300: LD_INT 7
55302: PUSH
55303: LD_INT 28
55305: PUSH
55306: LD_INT 45
55308: PUSH
55309: LD_EXP 99
55313: PUSH
55314: EMPTY
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: IN
55320: IFFALSE 55341
// points := [ 35 , 20 , 45 ] ;
55322: LD_ADDR_VAR 0 9
55326: PUSH
55327: LD_INT 35
55329: PUSH
55330: LD_INT 20
55332: PUSH
55333: LD_INT 45
55335: PUSH
55336: EMPTY
55337: LIST
55338: LIST
55339: LIST
55340: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55341: LD_VAR 0 6
55345: PPUSH
55346: CALL_OW 264
55350: PUSH
55351: LD_INT 47
55353: PUSH
55354: EMPTY
55355: LIST
55356: IN
55357: IFFALSE 55378
// points := [ 67 , 45 , 75 ] ;
55359: LD_ADDR_VAR 0 9
55363: PUSH
55364: LD_INT 67
55366: PUSH
55367: LD_INT 45
55369: PUSH
55370: LD_INT 75
55372: PUSH
55373: EMPTY
55374: LIST
55375: LIST
55376: LIST
55377: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55378: LD_VAR 0 6
55382: PPUSH
55383: CALL_OW 264
55387: PUSH
55388: LD_INT 26
55390: PUSH
55391: EMPTY
55392: LIST
55393: IN
55394: IFFALSE 55415
// points := [ 120 , 30 , 80 ] ;
55396: LD_ADDR_VAR 0 9
55400: PUSH
55401: LD_INT 120
55403: PUSH
55404: LD_INT 30
55406: PUSH
55407: LD_INT 80
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: LIST
55414: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55415: LD_VAR 0 6
55419: PPUSH
55420: CALL_OW 264
55424: PUSH
55425: LD_INT 22
55427: PUSH
55428: EMPTY
55429: LIST
55430: IN
55431: IFFALSE 55452
// points := [ 40 , 1 , 1 ] ;
55433: LD_ADDR_VAR 0 9
55437: PUSH
55438: LD_INT 40
55440: PUSH
55441: LD_INT 1
55443: PUSH
55444: LD_INT 1
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: LIST
55451: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55452: LD_VAR 0 6
55456: PPUSH
55457: CALL_OW 264
55461: PUSH
55462: LD_INT 29
55464: PUSH
55465: EMPTY
55466: LIST
55467: IN
55468: IFFALSE 55489
// points := [ 70 , 200 , 400 ] ;
55470: LD_ADDR_VAR 0 9
55474: PUSH
55475: LD_INT 70
55477: PUSH
55478: LD_INT 200
55480: PUSH
55481: LD_INT 400
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: LIST
55488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55489: LD_VAR 0 6
55493: PPUSH
55494: CALL_OW 264
55498: PUSH
55499: LD_INT 14
55501: PUSH
55502: LD_INT 53
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: IN
55509: IFFALSE 55530
// points := [ 40 , 10 , 20 ] ;
55511: LD_ADDR_VAR 0 9
55515: PUSH
55516: LD_INT 40
55518: PUSH
55519: LD_INT 10
55521: PUSH
55522: LD_INT 20
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: LIST
55529: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55530: LD_VAR 0 6
55534: PPUSH
55535: CALL_OW 264
55539: PUSH
55540: LD_INT 9
55542: PUSH
55543: EMPTY
55544: LIST
55545: IN
55546: IFFALSE 55567
// points := [ 5 , 70 , 20 ] ;
55548: LD_ADDR_VAR 0 9
55552: PUSH
55553: LD_INT 5
55555: PUSH
55556: LD_INT 70
55558: PUSH
55559: LD_INT 20
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: LIST
55566: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55567: LD_VAR 0 6
55571: PPUSH
55572: CALL_OW 264
55576: PUSH
55577: LD_INT 10
55579: PUSH
55580: EMPTY
55581: LIST
55582: IN
55583: IFFALSE 55604
// points := [ 35 , 110 , 70 ] ;
55585: LD_ADDR_VAR 0 9
55589: PUSH
55590: LD_INT 35
55592: PUSH
55593: LD_INT 110
55595: PUSH
55596: LD_INT 70
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: LIST
55603: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55604: LD_VAR 0 6
55608: PPUSH
55609: CALL_OW 265
55613: PUSH
55614: LD_INT 25
55616: EQUAL
55617: IFFALSE 55638
// points := [ 80 , 65 , 100 ] ;
55619: LD_ADDR_VAR 0 9
55623: PUSH
55624: LD_INT 80
55626: PUSH
55627: LD_INT 65
55629: PUSH
55630: LD_INT 100
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: LIST
55637: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55638: LD_VAR 0 6
55642: PPUSH
55643: CALL_OW 263
55647: PUSH
55648: LD_INT 1
55650: EQUAL
55651: IFFALSE 55686
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55653: LD_ADDR_VAR 0 10
55657: PUSH
55658: LD_VAR 0 10
55662: PUSH
55663: LD_VAR 0 6
55667: PPUSH
55668: CALL_OW 311
55672: PPUSH
55673: LD_INT 3
55675: PPUSH
55676: CALL_OW 259
55680: PUSH
55681: LD_INT 4
55683: MUL
55684: MUL
55685: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55686: LD_VAR 0 6
55690: PPUSH
55691: CALL_OW 263
55695: PUSH
55696: LD_INT 2
55698: EQUAL
55699: IFFALSE 55750
// begin j := IsControledBy ( i ) ;
55701: LD_ADDR_VAR 0 7
55705: PUSH
55706: LD_VAR 0 6
55710: PPUSH
55711: CALL_OW 312
55715: ST_TO_ADDR
// if j then
55716: LD_VAR 0 7
55720: IFFALSE 55750
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55722: LD_ADDR_VAR 0 10
55726: PUSH
55727: LD_VAR 0 10
55731: PUSH
55732: LD_VAR 0 7
55736: PPUSH
55737: LD_INT 3
55739: PPUSH
55740: CALL_OW 259
55744: PUSH
55745: LD_INT 3
55747: MUL
55748: MUL
55749: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55750: LD_VAR 0 6
55754: PPUSH
55755: CALL_OW 264
55759: PUSH
55760: LD_INT 5
55762: PUSH
55763: LD_INT 6
55765: PUSH
55766: LD_INT 46
55768: PUSH
55769: LD_INT 44
55771: PUSH
55772: LD_INT 47
55774: PUSH
55775: LD_INT 45
55777: PUSH
55778: LD_INT 28
55780: PUSH
55781: LD_INT 7
55783: PUSH
55784: LD_INT 27
55786: PUSH
55787: LD_INT 29
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: LIST
55795: LIST
55796: LIST
55797: LIST
55798: LIST
55799: LIST
55800: LIST
55801: IN
55802: PUSH
55803: LD_VAR 0 1
55807: PPUSH
55808: LD_INT 52
55810: PPUSH
55811: CALL_OW 321
55815: PUSH
55816: LD_INT 2
55818: EQUAL
55819: AND
55820: IFFALSE 55837
// bpoints := bpoints * 1.2 ;
55822: LD_ADDR_VAR 0 10
55826: PUSH
55827: LD_VAR 0 10
55831: PUSH
55832: LD_REAL  1.20000000000000E+0000
55835: MUL
55836: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55837: LD_VAR 0 6
55841: PPUSH
55842: CALL_OW 264
55846: PUSH
55847: LD_INT 6
55849: PUSH
55850: LD_INT 46
55852: PUSH
55853: LD_INT 47
55855: PUSH
55856: EMPTY
55857: LIST
55858: LIST
55859: LIST
55860: IN
55861: IFFALSE 55878
// bpoints := bpoints * 1.2 ;
55863: LD_ADDR_VAR 0 10
55867: PUSH
55868: LD_VAR 0 10
55872: PUSH
55873: LD_REAL  1.20000000000000E+0000
55876: MUL
55877: ST_TO_ADDR
// end ; unit_building :
55878: GO 55892
55880: LD_INT 3
55882: DOUBLE
55883: EQUAL
55884: IFTRUE 55888
55886: GO 55891
55888: POP
// ; end ;
55889: GO 55892
55891: POP
// for j = 1 to 3 do
55892: LD_ADDR_VAR 0 7
55896: PUSH
55897: DOUBLE
55898: LD_INT 1
55900: DEC
55901: ST_TO_ADDR
55902: LD_INT 3
55904: PUSH
55905: FOR_TO
55906: IFFALSE 55959
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55908: LD_ADDR_VAR 0 5
55912: PUSH
55913: LD_VAR 0 5
55917: PPUSH
55918: LD_VAR 0 7
55922: PPUSH
55923: LD_VAR 0 5
55927: PUSH
55928: LD_VAR 0 7
55932: ARRAY
55933: PUSH
55934: LD_VAR 0 9
55938: PUSH
55939: LD_VAR 0 7
55943: ARRAY
55944: PUSH
55945: LD_VAR 0 10
55949: MUL
55950: PLUS
55951: PPUSH
55952: CALL_OW 1
55956: ST_TO_ADDR
55957: GO 55905
55959: POP
55960: POP
// end ;
55961: GO 54438
55963: POP
55964: POP
// result := Replace ( result , 4 , tmp ) ;
55965: LD_ADDR_VAR 0 5
55969: PUSH
55970: LD_VAR 0 5
55974: PPUSH
55975: LD_INT 4
55977: PPUSH
55978: LD_VAR 0 8
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// end ;
55988: LD_VAR 0 5
55992: RET
// export function DangerAtRange ( unit , range ) ; begin
55993: LD_INT 0
55995: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55996: LD_ADDR_VAR 0 3
56000: PUSH
56001: LD_VAR 0 1
56005: PPUSH
56006: CALL_OW 255
56010: PPUSH
56011: LD_VAR 0 1
56015: PPUSH
56016: CALL_OW 250
56020: PPUSH
56021: LD_VAR 0 1
56025: PPUSH
56026: CALL_OW 251
56030: PPUSH
56031: LD_VAR 0 2
56035: PPUSH
56036: CALL 54290 0 4
56040: ST_TO_ADDR
// end ;
56041: LD_VAR 0 3
56045: RET
// export function DangerInArea ( side , area ) ; begin
56046: LD_INT 0
56048: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_VAR 0 2
56058: PPUSH
56059: LD_INT 81
56061: PUSH
56062: LD_VAR 0 1
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: PPUSH
56071: CALL_OW 70
56075: ST_TO_ADDR
// end ;
56076: LD_VAR 0 3
56080: RET
// export function IsExtension ( b ) ; begin
56081: LD_INT 0
56083: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56084: LD_ADDR_VAR 0 2
56088: PUSH
56089: LD_VAR 0 1
56093: PUSH
56094: LD_INT 23
56096: PUSH
56097: LD_INT 20
56099: PUSH
56100: LD_INT 22
56102: PUSH
56103: LD_INT 17
56105: PUSH
56106: LD_INT 24
56108: PUSH
56109: LD_INT 21
56111: PUSH
56112: LD_INT 19
56114: PUSH
56115: LD_INT 16
56117: PUSH
56118: LD_INT 25
56120: PUSH
56121: LD_INT 18
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: LIST
56131: LIST
56132: LIST
56133: LIST
56134: LIST
56135: IN
56136: ST_TO_ADDR
// end ;
56137: LD_VAR 0 2
56141: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56142: LD_INT 0
56144: PPUSH
56145: PPUSH
56146: PPUSH
// result := [ ] ;
56147: LD_ADDR_VAR 0 4
56151: PUSH
56152: EMPTY
56153: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56154: LD_ADDR_VAR 0 5
56158: PUSH
56159: LD_VAR 0 2
56163: PPUSH
56164: LD_INT 21
56166: PUSH
56167: LD_INT 3
56169: PUSH
56170: EMPTY
56171: LIST
56172: LIST
56173: PPUSH
56174: CALL_OW 70
56178: ST_TO_ADDR
// if not tmp then
56179: LD_VAR 0 5
56183: NOT
56184: IFFALSE 56188
// exit ;
56186: GO 56252
// if checkLink then
56188: LD_VAR 0 3
56192: IFFALSE 56242
// begin for i in tmp do
56194: LD_ADDR_VAR 0 6
56198: PUSH
56199: LD_VAR 0 5
56203: PUSH
56204: FOR_IN
56205: IFFALSE 56240
// if GetBase ( i ) <> base then
56207: LD_VAR 0 6
56211: PPUSH
56212: CALL_OW 274
56216: PUSH
56217: LD_VAR 0 1
56221: NONEQUAL
56222: IFFALSE 56238
// ComLinkToBase ( base , i ) ;
56224: LD_VAR 0 1
56228: PPUSH
56229: LD_VAR 0 6
56233: PPUSH
56234: CALL_OW 169
56238: GO 56204
56240: POP
56241: POP
// end ; result := tmp ;
56242: LD_ADDR_VAR 0 4
56246: PUSH
56247: LD_VAR 0 5
56251: ST_TO_ADDR
// end ;
56252: LD_VAR 0 4
56256: RET
// export function ComComplete ( units , b ) ; var i ; begin
56257: LD_INT 0
56259: PPUSH
56260: PPUSH
// if not units then
56261: LD_VAR 0 1
56265: NOT
56266: IFFALSE 56270
// exit ;
56268: GO 56360
// for i in units do
56270: LD_ADDR_VAR 0 4
56274: PUSH
56275: LD_VAR 0 1
56279: PUSH
56280: FOR_IN
56281: IFFALSE 56358
// if BuildingStatus ( b ) = bs_build then
56283: LD_VAR 0 2
56287: PPUSH
56288: CALL_OW 461
56292: PUSH
56293: LD_INT 1
56295: EQUAL
56296: IFFALSE 56356
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56298: LD_VAR 0 4
56302: PPUSH
56303: LD_STRING h
56305: PUSH
56306: LD_VAR 0 2
56310: PPUSH
56311: CALL_OW 250
56315: PUSH
56316: LD_VAR 0 2
56320: PPUSH
56321: CALL_OW 251
56325: PUSH
56326: LD_VAR 0 2
56330: PUSH
56331: LD_INT 0
56333: PUSH
56334: LD_INT 0
56336: PUSH
56337: LD_INT 0
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: LIST
56344: LIST
56345: LIST
56346: LIST
56347: LIST
56348: PUSH
56349: EMPTY
56350: LIST
56351: PPUSH
56352: CALL_OW 446
56356: GO 56280
56358: POP
56359: POP
// end ;
56360: LD_VAR 0 3
56364: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56365: LD_INT 0
56367: PPUSH
56368: PPUSH
56369: PPUSH
56370: PPUSH
56371: PPUSH
56372: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56373: LD_VAR 0 1
56377: NOT
56378: PUSH
56379: LD_VAR 0 1
56383: PPUSH
56384: CALL_OW 263
56388: PUSH
56389: LD_INT 2
56391: NONEQUAL
56392: OR
56393: IFFALSE 56397
// exit ;
56395: GO 56713
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56397: LD_ADDR_VAR 0 6
56401: PUSH
56402: LD_INT 22
56404: PUSH
56405: LD_VAR 0 1
56409: PPUSH
56410: CALL_OW 255
56414: PUSH
56415: EMPTY
56416: LIST
56417: LIST
56418: PUSH
56419: LD_INT 2
56421: PUSH
56422: LD_INT 30
56424: PUSH
56425: LD_INT 36
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: PUSH
56432: LD_INT 34
56434: PUSH
56435: LD_INT 31
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: LIST
56446: PUSH
56447: EMPTY
56448: LIST
56449: LIST
56450: PPUSH
56451: CALL_OW 69
56455: ST_TO_ADDR
// if not tmp then
56456: LD_VAR 0 6
56460: NOT
56461: IFFALSE 56465
// exit ;
56463: GO 56713
// result := [ ] ;
56465: LD_ADDR_VAR 0 2
56469: PUSH
56470: EMPTY
56471: ST_TO_ADDR
// for i in tmp do
56472: LD_ADDR_VAR 0 3
56476: PUSH
56477: LD_VAR 0 6
56481: PUSH
56482: FOR_IN
56483: IFFALSE 56554
// begin t := UnitsInside ( i ) ;
56485: LD_ADDR_VAR 0 4
56489: PUSH
56490: LD_VAR 0 3
56494: PPUSH
56495: CALL_OW 313
56499: ST_TO_ADDR
// if t then
56500: LD_VAR 0 4
56504: IFFALSE 56552
// for j in t do
56506: LD_ADDR_VAR 0 7
56510: PUSH
56511: LD_VAR 0 4
56515: PUSH
56516: FOR_IN
56517: IFFALSE 56550
// result := Replace ( result , result + 1 , j ) ;
56519: LD_ADDR_VAR 0 2
56523: PUSH
56524: LD_VAR 0 2
56528: PPUSH
56529: LD_VAR 0 2
56533: PUSH
56534: LD_INT 1
56536: PLUS
56537: PPUSH
56538: LD_VAR 0 7
56542: PPUSH
56543: CALL_OW 1
56547: ST_TO_ADDR
56548: GO 56516
56550: POP
56551: POP
// end ;
56552: GO 56482
56554: POP
56555: POP
// if not result then
56556: LD_VAR 0 2
56560: NOT
56561: IFFALSE 56565
// exit ;
56563: GO 56713
// mech := result [ 1 ] ;
56565: LD_ADDR_VAR 0 5
56569: PUSH
56570: LD_VAR 0 2
56574: PUSH
56575: LD_INT 1
56577: ARRAY
56578: ST_TO_ADDR
// if result > 1 then
56579: LD_VAR 0 2
56583: PUSH
56584: LD_INT 1
56586: GREATER
56587: IFFALSE 56699
// begin for i = 2 to result do
56589: LD_ADDR_VAR 0 3
56593: PUSH
56594: DOUBLE
56595: LD_INT 2
56597: DEC
56598: ST_TO_ADDR
56599: LD_VAR 0 2
56603: PUSH
56604: FOR_TO
56605: IFFALSE 56697
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56607: LD_ADDR_VAR 0 4
56611: PUSH
56612: LD_VAR 0 2
56616: PUSH
56617: LD_VAR 0 3
56621: ARRAY
56622: PPUSH
56623: LD_INT 3
56625: PPUSH
56626: CALL_OW 259
56630: PUSH
56631: LD_VAR 0 2
56635: PUSH
56636: LD_VAR 0 3
56640: ARRAY
56641: PPUSH
56642: CALL_OW 432
56646: MINUS
56647: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56648: LD_VAR 0 4
56652: PUSH
56653: LD_VAR 0 5
56657: PPUSH
56658: LD_INT 3
56660: PPUSH
56661: CALL_OW 259
56665: PUSH
56666: LD_VAR 0 5
56670: PPUSH
56671: CALL_OW 432
56675: MINUS
56676: GREATEREQUAL
56677: IFFALSE 56695
// mech := result [ i ] ;
56679: LD_ADDR_VAR 0 5
56683: PUSH
56684: LD_VAR 0 2
56688: PUSH
56689: LD_VAR 0 3
56693: ARRAY
56694: ST_TO_ADDR
// end ;
56695: GO 56604
56697: POP
56698: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56699: LD_VAR 0 1
56703: PPUSH
56704: LD_VAR 0 5
56708: PPUSH
56709: CALL_OW 135
// end ;
56713: LD_VAR 0 2
56717: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56718: LD_INT 0
56720: PPUSH
56721: PPUSH
56722: PPUSH
56723: PPUSH
56724: PPUSH
56725: PPUSH
56726: PPUSH
56727: PPUSH
56728: PPUSH
56729: PPUSH
56730: PPUSH
56731: PPUSH
56732: PPUSH
// result := [ ] ;
56733: LD_ADDR_VAR 0 7
56737: PUSH
56738: EMPTY
56739: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56740: LD_VAR 0 1
56744: PPUSH
56745: CALL_OW 266
56749: PUSH
56750: LD_INT 0
56752: PUSH
56753: LD_INT 1
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: IN
56760: NOT
56761: IFFALSE 56765
// exit ;
56763: GO 58399
// if name then
56765: LD_VAR 0 3
56769: IFFALSE 56785
// SetBName ( base_dep , name ) ;
56771: LD_VAR 0 1
56775: PPUSH
56776: LD_VAR 0 3
56780: PPUSH
56781: CALL_OW 500
// base := GetBase ( base_dep ) ;
56785: LD_ADDR_VAR 0 15
56789: PUSH
56790: LD_VAR 0 1
56794: PPUSH
56795: CALL_OW 274
56799: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56800: LD_ADDR_VAR 0 16
56804: PUSH
56805: LD_VAR 0 1
56809: PPUSH
56810: CALL_OW 255
56814: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56815: LD_ADDR_VAR 0 17
56819: PUSH
56820: LD_VAR 0 1
56824: PPUSH
56825: CALL_OW 248
56829: ST_TO_ADDR
// if sources then
56830: LD_VAR 0 5
56834: IFFALSE 56881
// for i = 1 to 3 do
56836: LD_ADDR_VAR 0 8
56840: PUSH
56841: DOUBLE
56842: LD_INT 1
56844: DEC
56845: ST_TO_ADDR
56846: LD_INT 3
56848: PUSH
56849: FOR_TO
56850: IFFALSE 56879
// AddResourceType ( base , i , sources [ i ] ) ;
56852: LD_VAR 0 15
56856: PPUSH
56857: LD_VAR 0 8
56861: PPUSH
56862: LD_VAR 0 5
56866: PUSH
56867: LD_VAR 0 8
56871: ARRAY
56872: PPUSH
56873: CALL_OW 276
56877: GO 56849
56879: POP
56880: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
56881: LD_ADDR_VAR 0 18
56885: PUSH
56886: LD_VAR 0 15
56890: PPUSH
56891: LD_VAR 0 2
56895: PPUSH
56896: LD_INT 1
56898: PPUSH
56899: CALL 56142 0 3
56903: ST_TO_ADDR
// InitHc ;
56904: CALL_OW 19
// InitUc ;
56908: CALL_OW 18
// uc_side := side ;
56912: LD_ADDR_OWVAR 20
56916: PUSH
56917: LD_VAR 0 16
56921: ST_TO_ADDR
// uc_nation := nation ;
56922: LD_ADDR_OWVAR 21
56926: PUSH
56927: LD_VAR 0 17
56931: ST_TO_ADDR
// if buildings then
56932: LD_VAR 0 18
56936: IFFALSE 58258
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56938: LD_ADDR_VAR 0 19
56942: PUSH
56943: LD_VAR 0 18
56947: PPUSH
56948: LD_INT 2
56950: PUSH
56951: LD_INT 30
56953: PUSH
56954: LD_INT 29
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PUSH
56961: LD_INT 30
56963: PUSH
56964: LD_INT 30
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: EMPTY
56972: LIST
56973: LIST
56974: LIST
56975: PPUSH
56976: CALL_OW 72
56980: ST_TO_ADDR
// if tmp then
56981: LD_VAR 0 19
56985: IFFALSE 57033
// for i in tmp do
56987: LD_ADDR_VAR 0 8
56991: PUSH
56992: LD_VAR 0 19
56996: PUSH
56997: FOR_IN
56998: IFFALSE 57031
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57000: LD_VAR 0 8
57004: PPUSH
57005: CALL_OW 250
57009: PPUSH
57010: LD_VAR 0 8
57014: PPUSH
57015: CALL_OW 251
57019: PPUSH
57020: LD_VAR 0 16
57024: PPUSH
57025: CALL_OW 441
57029: GO 56997
57031: POP
57032: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57033: LD_VAR 0 18
57037: PPUSH
57038: LD_INT 2
57040: PUSH
57041: LD_INT 30
57043: PUSH
57044: LD_INT 32
57046: PUSH
57047: EMPTY
57048: LIST
57049: LIST
57050: PUSH
57051: LD_INT 30
57053: PUSH
57054: LD_INT 33
57056: PUSH
57057: EMPTY
57058: LIST
57059: LIST
57060: PUSH
57061: EMPTY
57062: LIST
57063: LIST
57064: LIST
57065: PPUSH
57066: CALL_OW 72
57070: IFFALSE 57158
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57072: LD_ADDR_VAR 0 8
57076: PUSH
57077: LD_VAR 0 18
57081: PPUSH
57082: LD_INT 2
57084: PUSH
57085: LD_INT 30
57087: PUSH
57088: LD_INT 32
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: LD_INT 30
57097: PUSH
57098: LD_INT 33
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: LIST
57109: PPUSH
57110: CALL_OW 72
57114: PUSH
57115: FOR_IN
57116: IFFALSE 57156
// begin if not GetBWeapon ( i ) then
57118: LD_VAR 0 8
57122: PPUSH
57123: CALL_OW 269
57127: NOT
57128: IFFALSE 57154
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57130: LD_VAR 0 8
57134: PPUSH
57135: LD_VAR 0 8
57139: PPUSH
57140: LD_VAR 0 2
57144: PPUSH
57145: CALL 58404 0 2
57149: PPUSH
57150: CALL_OW 431
// end ;
57154: GO 57115
57156: POP
57157: POP
// end ; for i = 1 to personel do
57158: LD_ADDR_VAR 0 8
57162: PUSH
57163: DOUBLE
57164: LD_INT 1
57166: DEC
57167: ST_TO_ADDR
57168: LD_VAR 0 6
57172: PUSH
57173: FOR_TO
57174: IFFALSE 58238
// begin if i > 4 then
57176: LD_VAR 0 8
57180: PUSH
57181: LD_INT 4
57183: GREATER
57184: IFFALSE 57188
// break ;
57186: GO 58238
// case i of 1 :
57188: LD_VAR 0 8
57192: PUSH
57193: LD_INT 1
57195: DOUBLE
57196: EQUAL
57197: IFTRUE 57201
57199: GO 57281
57201: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57202: LD_ADDR_VAR 0 12
57206: PUSH
57207: LD_VAR 0 18
57211: PPUSH
57212: LD_INT 22
57214: PUSH
57215: LD_VAR 0 16
57219: PUSH
57220: EMPTY
57221: LIST
57222: LIST
57223: PUSH
57224: LD_INT 58
57226: PUSH
57227: EMPTY
57228: LIST
57229: PUSH
57230: LD_INT 2
57232: PUSH
57233: LD_INT 30
57235: PUSH
57236: LD_INT 32
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: LD_INT 30
57245: PUSH
57246: LD_INT 4
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PUSH
57253: LD_INT 30
57255: PUSH
57256: LD_INT 5
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: PUSH
57263: EMPTY
57264: LIST
57265: LIST
57266: LIST
57267: LIST
57268: PUSH
57269: EMPTY
57270: LIST
57271: LIST
57272: LIST
57273: PPUSH
57274: CALL_OW 72
57278: ST_TO_ADDR
57279: GO 57503
57281: LD_INT 2
57283: DOUBLE
57284: EQUAL
57285: IFTRUE 57289
57287: GO 57351
57289: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57290: LD_ADDR_VAR 0 12
57294: PUSH
57295: LD_VAR 0 18
57299: PPUSH
57300: LD_INT 22
57302: PUSH
57303: LD_VAR 0 16
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PUSH
57312: LD_INT 2
57314: PUSH
57315: LD_INT 30
57317: PUSH
57318: LD_INT 0
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: PUSH
57325: LD_INT 30
57327: PUSH
57328: LD_INT 1
57330: PUSH
57331: EMPTY
57332: LIST
57333: LIST
57334: PUSH
57335: EMPTY
57336: LIST
57337: LIST
57338: LIST
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: PPUSH
57344: CALL_OW 72
57348: ST_TO_ADDR
57349: GO 57503
57351: LD_INT 3
57353: DOUBLE
57354: EQUAL
57355: IFTRUE 57359
57357: GO 57421
57359: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57360: LD_ADDR_VAR 0 12
57364: PUSH
57365: LD_VAR 0 18
57369: PPUSH
57370: LD_INT 22
57372: PUSH
57373: LD_VAR 0 16
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: PUSH
57382: LD_INT 2
57384: PUSH
57385: LD_INT 30
57387: PUSH
57388: LD_INT 2
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 3
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: LIST
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PPUSH
57414: CALL_OW 72
57418: ST_TO_ADDR
57419: GO 57503
57421: LD_INT 4
57423: DOUBLE
57424: EQUAL
57425: IFTRUE 57429
57427: GO 57502
57429: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57430: LD_ADDR_VAR 0 12
57434: PUSH
57435: LD_VAR 0 18
57439: PPUSH
57440: LD_INT 22
57442: PUSH
57443: LD_VAR 0 16
57447: PUSH
57448: EMPTY
57449: LIST
57450: LIST
57451: PUSH
57452: LD_INT 2
57454: PUSH
57455: LD_INT 30
57457: PUSH
57458: LD_INT 6
57460: PUSH
57461: EMPTY
57462: LIST
57463: LIST
57464: PUSH
57465: LD_INT 30
57467: PUSH
57468: LD_INT 7
57470: PUSH
57471: EMPTY
57472: LIST
57473: LIST
57474: PUSH
57475: LD_INT 30
57477: PUSH
57478: LD_INT 8
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: EMPTY
57486: LIST
57487: LIST
57488: LIST
57489: LIST
57490: PUSH
57491: EMPTY
57492: LIST
57493: LIST
57494: PPUSH
57495: CALL_OW 72
57499: ST_TO_ADDR
57500: GO 57503
57502: POP
// if i = 1 then
57503: LD_VAR 0 8
57507: PUSH
57508: LD_INT 1
57510: EQUAL
57511: IFFALSE 57622
// begin tmp := [ ] ;
57513: LD_ADDR_VAR 0 19
57517: PUSH
57518: EMPTY
57519: ST_TO_ADDR
// for j in f do
57520: LD_ADDR_VAR 0 9
57524: PUSH
57525: LD_VAR 0 12
57529: PUSH
57530: FOR_IN
57531: IFFALSE 57604
// if GetBType ( j ) = b_bunker then
57533: LD_VAR 0 9
57537: PPUSH
57538: CALL_OW 266
57542: PUSH
57543: LD_INT 32
57545: EQUAL
57546: IFFALSE 57573
// tmp := Insert ( tmp , 1 , j ) else
57548: LD_ADDR_VAR 0 19
57552: PUSH
57553: LD_VAR 0 19
57557: PPUSH
57558: LD_INT 1
57560: PPUSH
57561: LD_VAR 0 9
57565: PPUSH
57566: CALL_OW 2
57570: ST_TO_ADDR
57571: GO 57602
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57573: LD_ADDR_VAR 0 19
57577: PUSH
57578: LD_VAR 0 19
57582: PPUSH
57583: LD_VAR 0 19
57587: PUSH
57588: LD_INT 1
57590: PLUS
57591: PPUSH
57592: LD_VAR 0 9
57596: PPUSH
57597: CALL_OW 2
57601: ST_TO_ADDR
57602: GO 57530
57604: POP
57605: POP
// if tmp then
57606: LD_VAR 0 19
57610: IFFALSE 57622
// f := tmp ;
57612: LD_ADDR_VAR 0 12
57616: PUSH
57617: LD_VAR 0 19
57621: ST_TO_ADDR
// end ; x := personel [ i ] ;
57622: LD_ADDR_VAR 0 13
57626: PUSH
57627: LD_VAR 0 6
57631: PUSH
57632: LD_VAR 0 8
57636: ARRAY
57637: ST_TO_ADDR
// if x = - 1 then
57638: LD_VAR 0 13
57642: PUSH
57643: LD_INT 1
57645: NEG
57646: EQUAL
57647: IFFALSE 57856
// begin for j in f do
57649: LD_ADDR_VAR 0 9
57653: PUSH
57654: LD_VAR 0 12
57658: PUSH
57659: FOR_IN
57660: IFFALSE 57852
// repeat InitHc ;
57662: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57666: LD_VAR 0 9
57670: PPUSH
57671: CALL_OW 266
57675: PUSH
57676: LD_INT 5
57678: EQUAL
57679: IFFALSE 57749
// begin if UnitsInside ( j ) < 3 then
57681: LD_VAR 0 9
57685: PPUSH
57686: CALL_OW 313
57690: PUSH
57691: LD_INT 3
57693: LESS
57694: IFFALSE 57730
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57696: LD_INT 0
57698: PPUSH
57699: LD_INT 5
57701: PUSH
57702: LD_INT 8
57704: PUSH
57705: LD_INT 9
57707: PUSH
57708: EMPTY
57709: LIST
57710: LIST
57711: LIST
57712: PUSH
57713: LD_VAR 0 17
57717: ARRAY
57718: PPUSH
57719: LD_VAR 0 4
57723: PPUSH
57724: CALL_OW 380
57728: GO 57747
// PrepareHuman ( false , i , skill ) ;
57730: LD_INT 0
57732: PPUSH
57733: LD_VAR 0 8
57737: PPUSH
57738: LD_VAR 0 4
57742: PPUSH
57743: CALL_OW 380
// end else
57747: GO 57766
// PrepareHuman ( false , i , skill ) ;
57749: LD_INT 0
57751: PPUSH
57752: LD_VAR 0 8
57756: PPUSH
57757: LD_VAR 0 4
57761: PPUSH
57762: CALL_OW 380
// un := CreateHuman ;
57766: LD_ADDR_VAR 0 14
57770: PUSH
57771: CALL_OW 44
57775: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57776: LD_ADDR_VAR 0 7
57780: PUSH
57781: LD_VAR 0 7
57785: PPUSH
57786: LD_INT 1
57788: PPUSH
57789: LD_VAR 0 14
57793: PPUSH
57794: CALL_OW 2
57798: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57799: LD_VAR 0 14
57803: PPUSH
57804: LD_VAR 0 9
57808: PPUSH
57809: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57813: LD_VAR 0 9
57817: PPUSH
57818: CALL_OW 313
57822: PUSH
57823: LD_INT 6
57825: EQUAL
57826: PUSH
57827: LD_VAR 0 9
57831: PPUSH
57832: CALL_OW 266
57836: PUSH
57837: LD_INT 32
57839: PUSH
57840: LD_INT 31
57842: PUSH
57843: EMPTY
57844: LIST
57845: LIST
57846: IN
57847: OR
57848: IFFALSE 57662
57850: GO 57659
57852: POP
57853: POP
// end else
57854: GO 58236
// for j = 1 to x do
57856: LD_ADDR_VAR 0 9
57860: PUSH
57861: DOUBLE
57862: LD_INT 1
57864: DEC
57865: ST_TO_ADDR
57866: LD_VAR 0 13
57870: PUSH
57871: FOR_TO
57872: IFFALSE 58234
// begin InitHc ;
57874: CALL_OW 19
// if not f then
57878: LD_VAR 0 12
57882: NOT
57883: IFFALSE 57972
// begin PrepareHuman ( false , i , skill ) ;
57885: LD_INT 0
57887: PPUSH
57888: LD_VAR 0 8
57892: PPUSH
57893: LD_VAR 0 4
57897: PPUSH
57898: CALL_OW 380
// un := CreateHuman ;
57902: LD_ADDR_VAR 0 14
57906: PUSH
57907: CALL_OW 44
57911: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57912: LD_ADDR_VAR 0 7
57916: PUSH
57917: LD_VAR 0 7
57921: PPUSH
57922: LD_INT 1
57924: PPUSH
57925: LD_VAR 0 14
57929: PPUSH
57930: CALL_OW 2
57934: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57935: LD_VAR 0 14
57939: PPUSH
57940: LD_VAR 0 1
57944: PPUSH
57945: CALL_OW 250
57949: PPUSH
57950: LD_VAR 0 1
57954: PPUSH
57955: CALL_OW 251
57959: PPUSH
57960: LD_INT 10
57962: PPUSH
57963: LD_INT 0
57965: PPUSH
57966: CALL_OW 50
// continue ;
57970: GO 57871
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57972: LD_VAR 0 12
57976: PUSH
57977: LD_INT 1
57979: ARRAY
57980: PPUSH
57981: CALL_OW 313
57985: PUSH
57986: LD_VAR 0 12
57990: PUSH
57991: LD_INT 1
57993: ARRAY
57994: PPUSH
57995: CALL_OW 266
57999: PUSH
58000: LD_INT 32
58002: PUSH
58003: LD_INT 31
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: IN
58010: AND
58011: PUSH
58012: LD_VAR 0 12
58016: PUSH
58017: LD_INT 1
58019: ARRAY
58020: PPUSH
58021: CALL_OW 313
58025: PUSH
58026: LD_INT 6
58028: EQUAL
58029: OR
58030: IFFALSE 58050
// f := Delete ( f , 1 ) ;
58032: LD_ADDR_VAR 0 12
58036: PUSH
58037: LD_VAR 0 12
58041: PPUSH
58042: LD_INT 1
58044: PPUSH
58045: CALL_OW 3
58049: ST_TO_ADDR
// if not f then
58050: LD_VAR 0 12
58054: NOT
58055: IFFALSE 58073
// begin x := x + 2 ;
58057: LD_ADDR_VAR 0 13
58061: PUSH
58062: LD_VAR 0 13
58066: PUSH
58067: LD_INT 2
58069: PLUS
58070: ST_TO_ADDR
// continue ;
58071: GO 57871
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58073: LD_VAR 0 12
58077: PUSH
58078: LD_INT 1
58080: ARRAY
58081: PPUSH
58082: CALL_OW 266
58086: PUSH
58087: LD_INT 5
58089: EQUAL
58090: IFFALSE 58164
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58092: LD_VAR 0 12
58096: PUSH
58097: LD_INT 1
58099: ARRAY
58100: PPUSH
58101: CALL_OW 313
58105: PUSH
58106: LD_INT 3
58108: LESS
58109: IFFALSE 58145
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58111: LD_INT 0
58113: PPUSH
58114: LD_INT 5
58116: PUSH
58117: LD_INT 8
58119: PUSH
58120: LD_INT 9
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: PUSH
58128: LD_VAR 0 17
58132: ARRAY
58133: PPUSH
58134: LD_VAR 0 4
58138: PPUSH
58139: CALL_OW 380
58143: GO 58162
// PrepareHuman ( false , i , skill ) ;
58145: LD_INT 0
58147: PPUSH
58148: LD_VAR 0 8
58152: PPUSH
58153: LD_VAR 0 4
58157: PPUSH
58158: CALL_OW 380
// end else
58162: GO 58181
// PrepareHuman ( false , i , skill ) ;
58164: LD_INT 0
58166: PPUSH
58167: LD_VAR 0 8
58171: PPUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: CALL_OW 380
// un := CreateHuman ;
58181: LD_ADDR_VAR 0 14
58185: PUSH
58186: CALL_OW 44
58190: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58191: LD_ADDR_VAR 0 7
58195: PUSH
58196: LD_VAR 0 7
58200: PPUSH
58201: LD_INT 1
58203: PPUSH
58204: LD_VAR 0 14
58208: PPUSH
58209: CALL_OW 2
58213: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58214: LD_VAR 0 14
58218: PPUSH
58219: LD_VAR 0 12
58223: PUSH
58224: LD_INT 1
58226: ARRAY
58227: PPUSH
58228: CALL_OW 52
// end ;
58232: GO 57871
58234: POP
58235: POP
// end ;
58236: GO 57173
58238: POP
58239: POP
// result := result ^ buildings ;
58240: LD_ADDR_VAR 0 7
58244: PUSH
58245: LD_VAR 0 7
58249: PUSH
58250: LD_VAR 0 18
58254: ADD
58255: ST_TO_ADDR
// end else
58256: GO 58399
// begin for i = 1 to personel do
58258: LD_ADDR_VAR 0 8
58262: PUSH
58263: DOUBLE
58264: LD_INT 1
58266: DEC
58267: ST_TO_ADDR
58268: LD_VAR 0 6
58272: PUSH
58273: FOR_TO
58274: IFFALSE 58397
// begin if i > 4 then
58276: LD_VAR 0 8
58280: PUSH
58281: LD_INT 4
58283: GREATER
58284: IFFALSE 58288
// break ;
58286: GO 58397
// x := personel [ i ] ;
58288: LD_ADDR_VAR 0 13
58292: PUSH
58293: LD_VAR 0 6
58297: PUSH
58298: LD_VAR 0 8
58302: ARRAY
58303: ST_TO_ADDR
// if x = - 1 then
58304: LD_VAR 0 13
58308: PUSH
58309: LD_INT 1
58311: NEG
58312: EQUAL
58313: IFFALSE 58317
// continue ;
58315: GO 58273
// PrepareHuman ( false , i , skill ) ;
58317: LD_INT 0
58319: PPUSH
58320: LD_VAR 0 8
58324: PPUSH
58325: LD_VAR 0 4
58329: PPUSH
58330: CALL_OW 380
// un := CreateHuman ;
58334: LD_ADDR_VAR 0 14
58338: PUSH
58339: CALL_OW 44
58343: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58344: LD_VAR 0 14
58348: PPUSH
58349: LD_VAR 0 1
58353: PPUSH
58354: CALL_OW 250
58358: PPUSH
58359: LD_VAR 0 1
58363: PPUSH
58364: CALL_OW 251
58368: PPUSH
58369: LD_INT 10
58371: PPUSH
58372: LD_INT 0
58374: PPUSH
58375: CALL_OW 50
// result := result ^ un ;
58379: LD_ADDR_VAR 0 7
58383: PUSH
58384: LD_VAR 0 7
58388: PUSH
58389: LD_VAR 0 14
58393: ADD
58394: ST_TO_ADDR
// end ;
58395: GO 58273
58397: POP
58398: POP
// end ; end ;
58399: LD_VAR 0 7
58403: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58404: LD_INT 0
58406: PPUSH
58407: PPUSH
58408: PPUSH
58409: PPUSH
58410: PPUSH
58411: PPUSH
58412: PPUSH
58413: PPUSH
58414: PPUSH
58415: PPUSH
58416: PPUSH
58417: PPUSH
58418: PPUSH
58419: PPUSH
58420: PPUSH
58421: PPUSH
// result := false ;
58422: LD_ADDR_VAR 0 3
58426: PUSH
58427: LD_INT 0
58429: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58430: LD_VAR 0 1
58434: NOT
58435: PUSH
58436: LD_VAR 0 1
58440: PPUSH
58441: CALL_OW 266
58445: PUSH
58446: LD_INT 32
58448: PUSH
58449: LD_INT 33
58451: PUSH
58452: EMPTY
58453: LIST
58454: LIST
58455: IN
58456: NOT
58457: OR
58458: IFFALSE 58462
// exit ;
58460: GO 59571
// nat := GetNation ( tower ) ;
58462: LD_ADDR_VAR 0 12
58466: PUSH
58467: LD_VAR 0 1
58471: PPUSH
58472: CALL_OW 248
58476: ST_TO_ADDR
// side := GetSide ( tower ) ;
58477: LD_ADDR_VAR 0 16
58481: PUSH
58482: LD_VAR 0 1
58486: PPUSH
58487: CALL_OW 255
58491: ST_TO_ADDR
// x := GetX ( tower ) ;
58492: LD_ADDR_VAR 0 10
58496: PUSH
58497: LD_VAR 0 1
58501: PPUSH
58502: CALL_OW 250
58506: ST_TO_ADDR
// y := GetY ( tower ) ;
58507: LD_ADDR_VAR 0 11
58511: PUSH
58512: LD_VAR 0 1
58516: PPUSH
58517: CALL_OW 251
58521: ST_TO_ADDR
// if not x or not y then
58522: LD_VAR 0 10
58526: NOT
58527: PUSH
58528: LD_VAR 0 11
58532: NOT
58533: OR
58534: IFFALSE 58538
// exit ;
58536: GO 59571
// weapon := 0 ;
58538: LD_ADDR_VAR 0 18
58542: PUSH
58543: LD_INT 0
58545: ST_TO_ADDR
// fac_list := [ ] ;
58546: LD_ADDR_VAR 0 17
58550: PUSH
58551: EMPTY
58552: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58553: LD_ADDR_VAR 0 6
58557: PUSH
58558: LD_VAR 0 1
58562: PPUSH
58563: CALL_OW 274
58567: PPUSH
58568: LD_VAR 0 2
58572: PPUSH
58573: LD_INT 0
58575: PPUSH
58576: CALL 56142 0 3
58580: PPUSH
58581: LD_INT 30
58583: PUSH
58584: LD_INT 3
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: PPUSH
58591: CALL_OW 72
58595: ST_TO_ADDR
// if not factories then
58596: LD_VAR 0 6
58600: NOT
58601: IFFALSE 58605
// exit ;
58603: GO 59571
// for i in factories do
58605: LD_ADDR_VAR 0 8
58609: PUSH
58610: LD_VAR 0 6
58614: PUSH
58615: FOR_IN
58616: IFFALSE 58641
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58618: LD_ADDR_VAR 0 17
58622: PUSH
58623: LD_VAR 0 17
58627: PUSH
58628: LD_VAR 0 8
58632: PPUSH
58633: CALL_OW 478
58637: UNION
58638: ST_TO_ADDR
58639: GO 58615
58641: POP
58642: POP
// if not fac_list then
58643: LD_VAR 0 17
58647: NOT
58648: IFFALSE 58652
// exit ;
58650: GO 59571
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58652: LD_ADDR_VAR 0 5
58656: PUSH
58657: LD_INT 4
58659: PUSH
58660: LD_INT 5
58662: PUSH
58663: LD_INT 9
58665: PUSH
58666: LD_INT 10
58668: PUSH
58669: LD_INT 6
58671: PUSH
58672: LD_INT 7
58674: PUSH
58675: LD_INT 11
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: LIST
58682: LIST
58683: LIST
58684: LIST
58685: LIST
58686: PUSH
58687: LD_INT 27
58689: PUSH
58690: LD_INT 28
58692: PUSH
58693: LD_INT 26
58695: PUSH
58696: LD_INT 30
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: LIST
58703: LIST
58704: PUSH
58705: LD_INT 43
58707: PUSH
58708: LD_INT 44
58710: PUSH
58711: LD_INT 46
58713: PUSH
58714: LD_INT 45
58716: PUSH
58717: LD_INT 47
58719: PUSH
58720: LD_INT 49
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: LIST
58727: LIST
58728: LIST
58729: LIST
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: LIST
58735: PUSH
58736: LD_VAR 0 12
58740: ARRAY
58741: ST_TO_ADDR
// list := list isect fac_list ;
58742: LD_ADDR_VAR 0 5
58746: PUSH
58747: LD_VAR 0 5
58751: PUSH
58752: LD_VAR 0 17
58756: ISECT
58757: ST_TO_ADDR
// if not list then
58758: LD_VAR 0 5
58762: NOT
58763: IFFALSE 58767
// exit ;
58765: GO 59571
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58767: LD_VAR 0 12
58771: PUSH
58772: LD_INT 3
58774: EQUAL
58775: PUSH
58776: LD_INT 49
58778: PUSH
58779: LD_VAR 0 5
58783: IN
58784: AND
58785: PUSH
58786: LD_INT 31
58788: PPUSH
58789: LD_VAR 0 16
58793: PPUSH
58794: CALL_OW 321
58798: PUSH
58799: LD_INT 2
58801: EQUAL
58802: AND
58803: IFFALSE 58863
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58805: LD_INT 22
58807: PUSH
58808: LD_VAR 0 16
58812: PUSH
58813: EMPTY
58814: LIST
58815: LIST
58816: PUSH
58817: LD_INT 35
58819: PUSH
58820: LD_INT 49
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: PUSH
58827: LD_INT 91
58829: PUSH
58830: LD_VAR 0 1
58834: PUSH
58835: LD_INT 10
58837: PUSH
58838: EMPTY
58839: LIST
58840: LIST
58841: LIST
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: LIST
58847: PPUSH
58848: CALL_OW 69
58852: NOT
58853: IFFALSE 58863
// weapon := ru_time_lapser ;
58855: LD_ADDR_VAR 0 18
58859: PUSH
58860: LD_INT 49
58862: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58863: LD_VAR 0 12
58867: PUSH
58868: LD_INT 1
58870: PUSH
58871: LD_INT 2
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: IN
58878: PUSH
58879: LD_INT 11
58881: PUSH
58882: LD_VAR 0 5
58886: IN
58887: PUSH
58888: LD_INT 30
58890: PUSH
58891: LD_VAR 0 5
58895: IN
58896: OR
58897: AND
58898: PUSH
58899: LD_INT 6
58901: PPUSH
58902: LD_VAR 0 16
58906: PPUSH
58907: CALL_OW 321
58911: PUSH
58912: LD_INT 2
58914: EQUAL
58915: AND
58916: IFFALSE 59081
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58918: LD_INT 22
58920: PUSH
58921: LD_VAR 0 16
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: PUSH
58930: LD_INT 2
58932: PUSH
58933: LD_INT 35
58935: PUSH
58936: LD_INT 11
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PUSH
58943: LD_INT 35
58945: PUSH
58946: LD_INT 30
58948: PUSH
58949: EMPTY
58950: LIST
58951: LIST
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: LIST
58957: PUSH
58958: LD_INT 91
58960: PUSH
58961: LD_VAR 0 1
58965: PUSH
58966: LD_INT 18
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: LIST
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: LIST
58978: PPUSH
58979: CALL_OW 69
58983: NOT
58984: PUSH
58985: LD_INT 22
58987: PUSH
58988: LD_VAR 0 16
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 2
58999: PUSH
59000: LD_INT 30
59002: PUSH
59003: LD_INT 32
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: PUSH
59010: LD_INT 30
59012: PUSH
59013: LD_INT 33
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: LIST
59024: PUSH
59025: LD_INT 91
59027: PUSH
59028: LD_VAR 0 1
59032: PUSH
59033: LD_INT 12
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: LIST
59040: PUSH
59041: EMPTY
59042: LIST
59043: LIST
59044: LIST
59045: PUSH
59046: EMPTY
59047: LIST
59048: PPUSH
59049: CALL_OW 69
59053: PUSH
59054: LD_INT 2
59056: GREATER
59057: AND
59058: IFFALSE 59081
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59060: LD_ADDR_VAR 0 18
59064: PUSH
59065: LD_INT 11
59067: PUSH
59068: LD_INT 30
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: PUSH
59075: LD_VAR 0 12
59079: ARRAY
59080: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59081: LD_VAR 0 18
59085: NOT
59086: PUSH
59087: LD_INT 40
59089: PPUSH
59090: LD_VAR 0 16
59094: PPUSH
59095: CALL_OW 321
59099: PUSH
59100: LD_INT 2
59102: EQUAL
59103: AND
59104: PUSH
59105: LD_INT 7
59107: PUSH
59108: LD_VAR 0 5
59112: IN
59113: PUSH
59114: LD_INT 28
59116: PUSH
59117: LD_VAR 0 5
59121: IN
59122: OR
59123: PUSH
59124: LD_INT 45
59126: PUSH
59127: LD_VAR 0 5
59131: IN
59132: OR
59133: AND
59134: IFFALSE 59388
// begin hex := GetHexInfo ( x , y ) ;
59136: LD_ADDR_VAR 0 4
59140: PUSH
59141: LD_VAR 0 10
59145: PPUSH
59146: LD_VAR 0 11
59150: PPUSH
59151: CALL_OW 546
59155: ST_TO_ADDR
// if hex [ 1 ] then
59156: LD_VAR 0 4
59160: PUSH
59161: LD_INT 1
59163: ARRAY
59164: IFFALSE 59168
// exit ;
59166: GO 59571
// height := hex [ 2 ] ;
59168: LD_ADDR_VAR 0 15
59172: PUSH
59173: LD_VAR 0 4
59177: PUSH
59178: LD_INT 2
59180: ARRAY
59181: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59182: LD_ADDR_VAR 0 14
59186: PUSH
59187: LD_INT 0
59189: PUSH
59190: LD_INT 2
59192: PUSH
59193: LD_INT 3
59195: PUSH
59196: LD_INT 5
59198: PUSH
59199: EMPTY
59200: LIST
59201: LIST
59202: LIST
59203: LIST
59204: ST_TO_ADDR
// for i in tmp do
59205: LD_ADDR_VAR 0 8
59209: PUSH
59210: LD_VAR 0 14
59214: PUSH
59215: FOR_IN
59216: IFFALSE 59386
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59218: LD_ADDR_VAR 0 9
59222: PUSH
59223: LD_VAR 0 10
59227: PPUSH
59228: LD_VAR 0 8
59232: PPUSH
59233: LD_INT 5
59235: PPUSH
59236: CALL_OW 272
59240: PUSH
59241: LD_VAR 0 11
59245: PPUSH
59246: LD_VAR 0 8
59250: PPUSH
59251: LD_INT 5
59253: PPUSH
59254: CALL_OW 273
59258: PUSH
59259: EMPTY
59260: LIST
59261: LIST
59262: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59263: LD_VAR 0 9
59267: PUSH
59268: LD_INT 1
59270: ARRAY
59271: PPUSH
59272: LD_VAR 0 9
59276: PUSH
59277: LD_INT 2
59279: ARRAY
59280: PPUSH
59281: CALL_OW 488
59285: IFFALSE 59384
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59287: LD_ADDR_VAR 0 4
59291: PUSH
59292: LD_VAR 0 9
59296: PUSH
59297: LD_INT 1
59299: ARRAY
59300: PPUSH
59301: LD_VAR 0 9
59305: PUSH
59306: LD_INT 2
59308: ARRAY
59309: PPUSH
59310: CALL_OW 546
59314: ST_TO_ADDR
// if hex [ 1 ] then
59315: LD_VAR 0 4
59319: PUSH
59320: LD_INT 1
59322: ARRAY
59323: IFFALSE 59327
// continue ;
59325: GO 59215
// h := hex [ 2 ] ;
59327: LD_ADDR_VAR 0 13
59331: PUSH
59332: LD_VAR 0 4
59336: PUSH
59337: LD_INT 2
59339: ARRAY
59340: ST_TO_ADDR
// if h + 7 < height then
59341: LD_VAR 0 13
59345: PUSH
59346: LD_INT 7
59348: PLUS
59349: PUSH
59350: LD_VAR 0 15
59354: LESS
59355: IFFALSE 59384
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59357: LD_ADDR_VAR 0 18
59361: PUSH
59362: LD_INT 7
59364: PUSH
59365: LD_INT 28
59367: PUSH
59368: LD_INT 45
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: LIST
59375: PUSH
59376: LD_VAR 0 12
59380: ARRAY
59381: ST_TO_ADDR
// break ;
59382: GO 59386
// end ; end ; end ;
59384: GO 59215
59386: POP
59387: POP
// end ; if not weapon then
59388: LD_VAR 0 18
59392: NOT
59393: IFFALSE 59453
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59395: LD_ADDR_VAR 0 5
59399: PUSH
59400: LD_VAR 0 5
59404: PUSH
59405: LD_INT 11
59407: PUSH
59408: LD_INT 30
59410: PUSH
59411: LD_INT 49
59413: PUSH
59414: EMPTY
59415: LIST
59416: LIST
59417: LIST
59418: DIFF
59419: ST_TO_ADDR
// if not list then
59420: LD_VAR 0 5
59424: NOT
59425: IFFALSE 59429
// exit ;
59427: GO 59571
// weapon := list [ rand ( 1 , list ) ] ;
59429: LD_ADDR_VAR 0 18
59433: PUSH
59434: LD_VAR 0 5
59438: PUSH
59439: LD_INT 1
59441: PPUSH
59442: LD_VAR 0 5
59446: PPUSH
59447: CALL_OW 12
59451: ARRAY
59452: ST_TO_ADDR
// end ; if weapon then
59453: LD_VAR 0 18
59457: IFFALSE 59571
// begin tmp := CostOfWeapon ( weapon ) ;
59459: LD_ADDR_VAR 0 14
59463: PUSH
59464: LD_VAR 0 18
59468: PPUSH
59469: CALL_OW 451
59473: ST_TO_ADDR
// j := GetBase ( tower ) ;
59474: LD_ADDR_VAR 0 9
59478: PUSH
59479: LD_VAR 0 1
59483: PPUSH
59484: CALL_OW 274
59488: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59489: LD_VAR 0 9
59493: PPUSH
59494: LD_INT 1
59496: PPUSH
59497: CALL_OW 275
59501: PUSH
59502: LD_VAR 0 14
59506: PUSH
59507: LD_INT 1
59509: ARRAY
59510: GREATEREQUAL
59511: PUSH
59512: LD_VAR 0 9
59516: PPUSH
59517: LD_INT 2
59519: PPUSH
59520: CALL_OW 275
59524: PUSH
59525: LD_VAR 0 14
59529: PUSH
59530: LD_INT 2
59532: ARRAY
59533: GREATEREQUAL
59534: AND
59535: PUSH
59536: LD_VAR 0 9
59540: PPUSH
59541: LD_INT 3
59543: PPUSH
59544: CALL_OW 275
59548: PUSH
59549: LD_VAR 0 14
59553: PUSH
59554: LD_INT 3
59556: ARRAY
59557: GREATEREQUAL
59558: AND
59559: IFFALSE 59571
// result := weapon ;
59561: LD_ADDR_VAR 0 3
59565: PUSH
59566: LD_VAR 0 18
59570: ST_TO_ADDR
// end ; end ;
59571: LD_VAR 0 3
59575: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59576: LD_INT 0
59578: PPUSH
59579: PPUSH
// result := true ;
59580: LD_ADDR_VAR 0 3
59584: PUSH
59585: LD_INT 1
59587: ST_TO_ADDR
// if array1 = array2 then
59588: LD_VAR 0 1
59592: PUSH
59593: LD_VAR 0 2
59597: EQUAL
59598: IFFALSE 59658
// begin for i = 1 to array1 do
59600: LD_ADDR_VAR 0 4
59604: PUSH
59605: DOUBLE
59606: LD_INT 1
59608: DEC
59609: ST_TO_ADDR
59610: LD_VAR 0 1
59614: PUSH
59615: FOR_TO
59616: IFFALSE 59654
// if array1 [ i ] <> array2 [ i ] then
59618: LD_VAR 0 1
59622: PUSH
59623: LD_VAR 0 4
59627: ARRAY
59628: PUSH
59629: LD_VAR 0 2
59633: PUSH
59634: LD_VAR 0 4
59638: ARRAY
59639: NONEQUAL
59640: IFFALSE 59652
// begin result := false ;
59642: LD_ADDR_VAR 0 3
59646: PUSH
59647: LD_INT 0
59649: ST_TO_ADDR
// break ;
59650: GO 59654
// end ;
59652: GO 59615
59654: POP
59655: POP
// end else
59656: GO 59666
// result := false ;
59658: LD_ADDR_VAR 0 3
59662: PUSH
59663: LD_INT 0
59665: ST_TO_ADDR
// end ;
59666: LD_VAR 0 3
59670: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59671: LD_INT 0
59673: PPUSH
59674: PPUSH
// if not array1 or not array2 then
59675: LD_VAR 0 1
59679: NOT
59680: PUSH
59681: LD_VAR 0 2
59685: NOT
59686: OR
59687: IFFALSE 59691
// exit ;
59689: GO 59755
// result := true ;
59691: LD_ADDR_VAR 0 3
59695: PUSH
59696: LD_INT 1
59698: ST_TO_ADDR
// for i = 1 to array1 do
59699: LD_ADDR_VAR 0 4
59703: PUSH
59704: DOUBLE
59705: LD_INT 1
59707: DEC
59708: ST_TO_ADDR
59709: LD_VAR 0 1
59713: PUSH
59714: FOR_TO
59715: IFFALSE 59753
// if array1 [ i ] <> array2 [ i ] then
59717: LD_VAR 0 1
59721: PUSH
59722: LD_VAR 0 4
59726: ARRAY
59727: PUSH
59728: LD_VAR 0 2
59732: PUSH
59733: LD_VAR 0 4
59737: ARRAY
59738: NONEQUAL
59739: IFFALSE 59751
// begin result := false ;
59741: LD_ADDR_VAR 0 3
59745: PUSH
59746: LD_INT 0
59748: ST_TO_ADDR
// break ;
59749: GO 59753
// end ;
59751: GO 59714
59753: POP
59754: POP
// end ;
59755: LD_VAR 0 3
59759: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59760: LD_INT 0
59762: PPUSH
59763: PPUSH
59764: PPUSH
// pom := GetBase ( fac ) ;
59765: LD_ADDR_VAR 0 5
59769: PUSH
59770: LD_VAR 0 1
59774: PPUSH
59775: CALL_OW 274
59779: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59780: LD_ADDR_VAR 0 4
59784: PUSH
59785: LD_VAR 0 2
59789: PUSH
59790: LD_INT 1
59792: ARRAY
59793: PPUSH
59794: LD_VAR 0 2
59798: PUSH
59799: LD_INT 2
59801: ARRAY
59802: PPUSH
59803: LD_VAR 0 2
59807: PUSH
59808: LD_INT 3
59810: ARRAY
59811: PPUSH
59812: LD_VAR 0 2
59816: PUSH
59817: LD_INT 4
59819: ARRAY
59820: PPUSH
59821: CALL_OW 449
59825: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59826: LD_ADDR_VAR 0 3
59830: PUSH
59831: LD_VAR 0 5
59835: PPUSH
59836: LD_INT 1
59838: PPUSH
59839: CALL_OW 275
59843: PUSH
59844: LD_VAR 0 4
59848: PUSH
59849: LD_INT 1
59851: ARRAY
59852: GREATEREQUAL
59853: PUSH
59854: LD_VAR 0 5
59858: PPUSH
59859: LD_INT 2
59861: PPUSH
59862: CALL_OW 275
59866: PUSH
59867: LD_VAR 0 4
59871: PUSH
59872: LD_INT 2
59874: ARRAY
59875: GREATEREQUAL
59876: AND
59877: PUSH
59878: LD_VAR 0 5
59882: PPUSH
59883: LD_INT 3
59885: PPUSH
59886: CALL_OW 275
59890: PUSH
59891: LD_VAR 0 4
59895: PUSH
59896: LD_INT 3
59898: ARRAY
59899: GREATEREQUAL
59900: AND
59901: ST_TO_ADDR
// end ;
59902: LD_VAR 0 3
59906: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59907: LD_INT 0
59909: PPUSH
59910: PPUSH
59911: PPUSH
59912: PPUSH
// pom := GetBase ( building ) ;
59913: LD_ADDR_VAR 0 3
59917: PUSH
59918: LD_VAR 0 1
59922: PPUSH
59923: CALL_OW 274
59927: ST_TO_ADDR
// if not pom then
59928: LD_VAR 0 3
59932: NOT
59933: IFFALSE 59937
// exit ;
59935: GO 60107
// btype := GetBType ( building ) ;
59937: LD_ADDR_VAR 0 5
59941: PUSH
59942: LD_VAR 0 1
59946: PPUSH
59947: CALL_OW 266
59951: ST_TO_ADDR
// if btype = b_armoury then
59952: LD_VAR 0 5
59956: PUSH
59957: LD_INT 4
59959: EQUAL
59960: IFFALSE 59970
// btype := b_barracks ;
59962: LD_ADDR_VAR 0 5
59966: PUSH
59967: LD_INT 5
59969: ST_TO_ADDR
// if btype = b_depot then
59970: LD_VAR 0 5
59974: PUSH
59975: LD_INT 0
59977: EQUAL
59978: IFFALSE 59988
// btype := b_warehouse ;
59980: LD_ADDR_VAR 0 5
59984: PUSH
59985: LD_INT 1
59987: ST_TO_ADDR
// if btype = b_workshop then
59988: LD_VAR 0 5
59992: PUSH
59993: LD_INT 2
59995: EQUAL
59996: IFFALSE 60006
// btype := b_factory ;
59998: LD_ADDR_VAR 0 5
60002: PUSH
60003: LD_INT 3
60005: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60006: LD_ADDR_VAR 0 4
60010: PUSH
60011: LD_VAR 0 5
60015: PPUSH
60016: LD_VAR 0 1
60020: PPUSH
60021: CALL_OW 248
60025: PPUSH
60026: CALL_OW 450
60030: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60031: LD_ADDR_VAR 0 2
60035: PUSH
60036: LD_VAR 0 3
60040: PPUSH
60041: LD_INT 1
60043: PPUSH
60044: CALL_OW 275
60048: PUSH
60049: LD_VAR 0 4
60053: PUSH
60054: LD_INT 1
60056: ARRAY
60057: GREATEREQUAL
60058: PUSH
60059: LD_VAR 0 3
60063: PPUSH
60064: LD_INT 2
60066: PPUSH
60067: CALL_OW 275
60071: PUSH
60072: LD_VAR 0 4
60076: PUSH
60077: LD_INT 2
60079: ARRAY
60080: GREATEREQUAL
60081: AND
60082: PUSH
60083: LD_VAR 0 3
60087: PPUSH
60088: LD_INT 3
60090: PPUSH
60091: CALL_OW 275
60095: PUSH
60096: LD_VAR 0 4
60100: PUSH
60101: LD_INT 3
60103: ARRAY
60104: GREATEREQUAL
60105: AND
60106: ST_TO_ADDR
// end ;
60107: LD_VAR 0 2
60111: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60112: LD_INT 0
60114: PPUSH
60115: PPUSH
60116: PPUSH
// pom := GetBase ( building ) ;
60117: LD_ADDR_VAR 0 4
60121: PUSH
60122: LD_VAR 0 1
60126: PPUSH
60127: CALL_OW 274
60131: ST_TO_ADDR
// if not pom then
60132: LD_VAR 0 4
60136: NOT
60137: IFFALSE 60141
// exit ;
60139: GO 60242
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60141: LD_ADDR_VAR 0 5
60145: PUSH
60146: LD_VAR 0 2
60150: PPUSH
60151: LD_VAR 0 1
60155: PPUSH
60156: CALL_OW 248
60160: PPUSH
60161: CALL_OW 450
60165: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60166: LD_ADDR_VAR 0 3
60170: PUSH
60171: LD_VAR 0 4
60175: PPUSH
60176: LD_INT 1
60178: PPUSH
60179: CALL_OW 275
60183: PUSH
60184: LD_VAR 0 5
60188: PUSH
60189: LD_INT 1
60191: ARRAY
60192: GREATEREQUAL
60193: PUSH
60194: LD_VAR 0 4
60198: PPUSH
60199: LD_INT 2
60201: PPUSH
60202: CALL_OW 275
60206: PUSH
60207: LD_VAR 0 5
60211: PUSH
60212: LD_INT 2
60214: ARRAY
60215: GREATEREQUAL
60216: AND
60217: PUSH
60218: LD_VAR 0 4
60222: PPUSH
60223: LD_INT 3
60225: PPUSH
60226: CALL_OW 275
60230: PUSH
60231: LD_VAR 0 5
60235: PUSH
60236: LD_INT 3
60238: ARRAY
60239: GREATEREQUAL
60240: AND
60241: ST_TO_ADDR
// end ;
60242: LD_VAR 0 3
60246: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60247: LD_INT 0
60249: PPUSH
60250: PPUSH
60251: PPUSH
60252: PPUSH
60253: PPUSH
60254: PPUSH
60255: PPUSH
60256: PPUSH
60257: PPUSH
60258: PPUSH
60259: PPUSH
// result := false ;
60260: LD_ADDR_VAR 0 8
60264: PUSH
60265: LD_INT 0
60267: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60268: LD_VAR 0 5
60272: NOT
60273: PUSH
60274: LD_VAR 0 1
60278: NOT
60279: OR
60280: PUSH
60281: LD_VAR 0 2
60285: NOT
60286: OR
60287: PUSH
60288: LD_VAR 0 3
60292: NOT
60293: OR
60294: IFFALSE 60298
// exit ;
60296: GO 61112
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60298: LD_ADDR_VAR 0 14
60302: PUSH
60303: LD_VAR 0 1
60307: PPUSH
60308: LD_VAR 0 2
60312: PPUSH
60313: LD_VAR 0 3
60317: PPUSH
60318: LD_VAR 0 4
60322: PPUSH
60323: LD_VAR 0 5
60327: PUSH
60328: LD_INT 1
60330: ARRAY
60331: PPUSH
60332: CALL_OW 248
60336: PPUSH
60337: LD_INT 0
60339: PPUSH
60340: CALL 62349 0 6
60344: ST_TO_ADDR
// if not hexes then
60345: LD_VAR 0 14
60349: NOT
60350: IFFALSE 60354
// exit ;
60352: GO 61112
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60354: LD_ADDR_VAR 0 17
60358: PUSH
60359: LD_VAR 0 5
60363: PPUSH
60364: LD_INT 22
60366: PUSH
60367: LD_VAR 0 13
60371: PPUSH
60372: CALL_OW 255
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PUSH
60381: LD_INT 2
60383: PUSH
60384: LD_INT 30
60386: PUSH
60387: LD_INT 0
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: LD_INT 30
60396: PUSH
60397: LD_INT 1
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: LIST
60408: PUSH
60409: EMPTY
60410: LIST
60411: LIST
60412: PPUSH
60413: CALL_OW 72
60417: ST_TO_ADDR
// for i = 1 to hexes do
60418: LD_ADDR_VAR 0 9
60422: PUSH
60423: DOUBLE
60424: LD_INT 1
60426: DEC
60427: ST_TO_ADDR
60428: LD_VAR 0 14
60432: PUSH
60433: FOR_TO
60434: IFFALSE 61110
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60436: LD_ADDR_VAR 0 13
60440: PUSH
60441: LD_VAR 0 14
60445: PUSH
60446: LD_VAR 0 9
60450: ARRAY
60451: PUSH
60452: LD_INT 1
60454: ARRAY
60455: PPUSH
60456: LD_VAR 0 14
60460: PUSH
60461: LD_VAR 0 9
60465: ARRAY
60466: PUSH
60467: LD_INT 2
60469: ARRAY
60470: PPUSH
60471: CALL_OW 428
60475: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60476: LD_VAR 0 14
60480: PUSH
60481: LD_VAR 0 9
60485: ARRAY
60486: PUSH
60487: LD_INT 1
60489: ARRAY
60490: PPUSH
60491: LD_VAR 0 14
60495: PUSH
60496: LD_VAR 0 9
60500: ARRAY
60501: PUSH
60502: LD_INT 2
60504: ARRAY
60505: PPUSH
60506: CALL_OW 351
60510: PUSH
60511: LD_VAR 0 14
60515: PUSH
60516: LD_VAR 0 9
60520: ARRAY
60521: PUSH
60522: LD_INT 1
60524: ARRAY
60525: PPUSH
60526: LD_VAR 0 14
60530: PUSH
60531: LD_VAR 0 9
60535: ARRAY
60536: PUSH
60537: LD_INT 2
60539: ARRAY
60540: PPUSH
60541: CALL_OW 488
60545: NOT
60546: OR
60547: PUSH
60548: LD_VAR 0 13
60552: PPUSH
60553: CALL_OW 247
60557: PUSH
60558: LD_INT 3
60560: EQUAL
60561: OR
60562: IFFALSE 60568
// exit ;
60564: POP
60565: POP
60566: GO 61112
// if not tmp then
60568: LD_VAR 0 13
60572: NOT
60573: IFFALSE 60577
// continue ;
60575: GO 60433
// result := true ;
60577: LD_ADDR_VAR 0 8
60581: PUSH
60582: LD_INT 1
60584: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60585: LD_VAR 0 6
60589: PUSH
60590: LD_VAR 0 13
60594: PPUSH
60595: CALL_OW 247
60599: PUSH
60600: LD_INT 2
60602: EQUAL
60603: AND
60604: PUSH
60605: LD_VAR 0 13
60609: PPUSH
60610: CALL_OW 263
60614: PUSH
60615: LD_INT 1
60617: EQUAL
60618: AND
60619: IFFALSE 60783
// begin if IsDrivenBy ( tmp ) then
60621: LD_VAR 0 13
60625: PPUSH
60626: CALL_OW 311
60630: IFFALSE 60634
// continue ;
60632: GO 60433
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60634: LD_VAR 0 6
60638: PPUSH
60639: LD_INT 3
60641: PUSH
60642: LD_INT 60
60644: PUSH
60645: EMPTY
60646: LIST
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: PUSH
60652: LD_INT 3
60654: PUSH
60655: LD_INT 55
60657: PUSH
60658: EMPTY
60659: LIST
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: PUSH
60665: EMPTY
60666: LIST
60667: LIST
60668: PPUSH
60669: CALL_OW 72
60673: IFFALSE 60781
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60675: LD_ADDR_VAR 0 18
60679: PUSH
60680: LD_VAR 0 6
60684: PPUSH
60685: LD_INT 3
60687: PUSH
60688: LD_INT 60
60690: PUSH
60691: EMPTY
60692: LIST
60693: PUSH
60694: EMPTY
60695: LIST
60696: LIST
60697: PUSH
60698: LD_INT 3
60700: PUSH
60701: LD_INT 55
60703: PUSH
60704: EMPTY
60705: LIST
60706: PUSH
60707: EMPTY
60708: LIST
60709: LIST
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: PPUSH
60715: CALL_OW 72
60719: PUSH
60720: LD_INT 1
60722: ARRAY
60723: ST_TO_ADDR
// if IsInUnit ( driver ) then
60724: LD_VAR 0 18
60728: PPUSH
60729: CALL_OW 310
60733: IFFALSE 60744
// ComExit ( driver ) ;
60735: LD_VAR 0 18
60739: PPUSH
60740: CALL 85533 0 1
// AddComEnterUnit ( driver , tmp ) ;
60744: LD_VAR 0 18
60748: PPUSH
60749: LD_VAR 0 13
60753: PPUSH
60754: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60758: LD_VAR 0 18
60762: PPUSH
60763: LD_VAR 0 7
60767: PPUSH
60768: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60772: LD_VAR 0 18
60776: PPUSH
60777: CALL_OW 181
// end ; continue ;
60781: GO 60433
// end ; if not cleaners or not tmp in cleaners then
60783: LD_VAR 0 6
60787: NOT
60788: PUSH
60789: LD_VAR 0 13
60793: PUSH
60794: LD_VAR 0 6
60798: IN
60799: NOT
60800: OR
60801: IFFALSE 61108
// begin if dep then
60803: LD_VAR 0 17
60807: IFFALSE 60943
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60809: LD_ADDR_VAR 0 16
60813: PUSH
60814: LD_VAR 0 17
60818: PUSH
60819: LD_INT 1
60821: ARRAY
60822: PPUSH
60823: CALL_OW 250
60827: PPUSH
60828: LD_VAR 0 17
60832: PUSH
60833: LD_INT 1
60835: ARRAY
60836: PPUSH
60837: CALL_OW 254
60841: PPUSH
60842: LD_INT 5
60844: PPUSH
60845: CALL_OW 272
60849: PUSH
60850: LD_VAR 0 17
60854: PUSH
60855: LD_INT 1
60857: ARRAY
60858: PPUSH
60859: CALL_OW 251
60863: PPUSH
60864: LD_VAR 0 17
60868: PUSH
60869: LD_INT 1
60871: ARRAY
60872: PPUSH
60873: CALL_OW 254
60877: PPUSH
60878: LD_INT 5
60880: PPUSH
60881: CALL_OW 273
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60890: LD_VAR 0 16
60894: PUSH
60895: LD_INT 1
60897: ARRAY
60898: PPUSH
60899: LD_VAR 0 16
60903: PUSH
60904: LD_INT 2
60906: ARRAY
60907: PPUSH
60908: CALL_OW 488
60912: IFFALSE 60943
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60914: LD_VAR 0 13
60918: PPUSH
60919: LD_VAR 0 16
60923: PUSH
60924: LD_INT 1
60926: ARRAY
60927: PPUSH
60928: LD_VAR 0 16
60932: PUSH
60933: LD_INT 2
60935: ARRAY
60936: PPUSH
60937: CALL_OW 111
// continue ;
60941: GO 60433
// end ; end ; r := GetDir ( tmp ) ;
60943: LD_ADDR_VAR 0 15
60947: PUSH
60948: LD_VAR 0 13
60952: PPUSH
60953: CALL_OW 254
60957: ST_TO_ADDR
// if r = 5 then
60958: LD_VAR 0 15
60962: PUSH
60963: LD_INT 5
60965: EQUAL
60966: IFFALSE 60976
// r := 0 ;
60968: LD_ADDR_VAR 0 15
60972: PUSH
60973: LD_INT 0
60975: ST_TO_ADDR
// for j = r to 5 do
60976: LD_ADDR_VAR 0 10
60980: PUSH
60981: DOUBLE
60982: LD_VAR 0 15
60986: DEC
60987: ST_TO_ADDR
60988: LD_INT 5
60990: PUSH
60991: FOR_TO
60992: IFFALSE 61106
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60994: LD_ADDR_VAR 0 11
60998: PUSH
60999: LD_VAR 0 13
61003: PPUSH
61004: CALL_OW 250
61008: PPUSH
61009: LD_VAR 0 10
61013: PPUSH
61014: LD_INT 2
61016: PPUSH
61017: CALL_OW 272
61021: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61022: LD_ADDR_VAR 0 12
61026: PUSH
61027: LD_VAR 0 13
61031: PPUSH
61032: CALL_OW 251
61036: PPUSH
61037: LD_VAR 0 10
61041: PPUSH
61042: LD_INT 2
61044: PPUSH
61045: CALL_OW 273
61049: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61050: LD_VAR 0 11
61054: PPUSH
61055: LD_VAR 0 12
61059: PPUSH
61060: CALL_OW 488
61064: PUSH
61065: LD_VAR 0 11
61069: PPUSH
61070: LD_VAR 0 12
61074: PPUSH
61075: CALL_OW 428
61079: NOT
61080: AND
61081: IFFALSE 61104
// begin ComMoveXY ( tmp , _x , _y ) ;
61083: LD_VAR 0 13
61087: PPUSH
61088: LD_VAR 0 11
61092: PPUSH
61093: LD_VAR 0 12
61097: PPUSH
61098: CALL_OW 111
// break ;
61102: GO 61106
// end ; end ;
61104: GO 60991
61106: POP
61107: POP
// end ; end ;
61108: GO 60433
61110: POP
61111: POP
// end ;
61112: LD_VAR 0 8
61116: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61117: LD_INT 0
61119: PPUSH
// result := true ;
61120: LD_ADDR_VAR 0 3
61124: PUSH
61125: LD_INT 1
61127: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61128: LD_VAR 0 2
61132: PUSH
61133: LD_INT 24
61135: DOUBLE
61136: EQUAL
61137: IFTRUE 61147
61139: LD_INT 33
61141: DOUBLE
61142: EQUAL
61143: IFTRUE 61147
61145: GO 61172
61147: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61148: LD_ADDR_VAR 0 3
61152: PUSH
61153: LD_INT 32
61155: PPUSH
61156: LD_VAR 0 1
61160: PPUSH
61161: CALL_OW 321
61165: PUSH
61166: LD_INT 2
61168: EQUAL
61169: ST_TO_ADDR
61170: GO 61492
61172: LD_INT 20
61174: DOUBLE
61175: EQUAL
61176: IFTRUE 61180
61178: GO 61205
61180: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61181: LD_ADDR_VAR 0 3
61185: PUSH
61186: LD_INT 6
61188: PPUSH
61189: LD_VAR 0 1
61193: PPUSH
61194: CALL_OW 321
61198: PUSH
61199: LD_INT 2
61201: EQUAL
61202: ST_TO_ADDR
61203: GO 61492
61205: LD_INT 22
61207: DOUBLE
61208: EQUAL
61209: IFTRUE 61219
61211: LD_INT 36
61213: DOUBLE
61214: EQUAL
61215: IFTRUE 61219
61217: GO 61244
61219: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61220: LD_ADDR_VAR 0 3
61224: PUSH
61225: LD_INT 15
61227: PPUSH
61228: LD_VAR 0 1
61232: PPUSH
61233: CALL_OW 321
61237: PUSH
61238: LD_INT 2
61240: EQUAL
61241: ST_TO_ADDR
61242: GO 61492
61244: LD_INT 30
61246: DOUBLE
61247: EQUAL
61248: IFTRUE 61252
61250: GO 61277
61252: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61253: LD_ADDR_VAR 0 3
61257: PUSH
61258: LD_INT 20
61260: PPUSH
61261: LD_VAR 0 1
61265: PPUSH
61266: CALL_OW 321
61270: PUSH
61271: LD_INT 2
61273: EQUAL
61274: ST_TO_ADDR
61275: GO 61492
61277: LD_INT 28
61279: DOUBLE
61280: EQUAL
61281: IFTRUE 61291
61283: LD_INT 21
61285: DOUBLE
61286: EQUAL
61287: IFTRUE 61291
61289: GO 61316
61291: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61292: LD_ADDR_VAR 0 3
61296: PUSH
61297: LD_INT 21
61299: PPUSH
61300: LD_VAR 0 1
61304: PPUSH
61305: CALL_OW 321
61309: PUSH
61310: LD_INT 2
61312: EQUAL
61313: ST_TO_ADDR
61314: GO 61492
61316: LD_INT 16
61318: DOUBLE
61319: EQUAL
61320: IFTRUE 61324
61322: GO 61351
61324: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61325: LD_ADDR_VAR 0 3
61329: PUSH
61330: LD_EXP 106
61334: PPUSH
61335: LD_VAR 0 1
61339: PPUSH
61340: CALL_OW 321
61344: PUSH
61345: LD_INT 2
61347: EQUAL
61348: ST_TO_ADDR
61349: GO 61492
61351: LD_INT 19
61353: DOUBLE
61354: EQUAL
61355: IFTRUE 61365
61357: LD_INT 23
61359: DOUBLE
61360: EQUAL
61361: IFTRUE 61365
61363: GO 61392
61365: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61366: LD_ADDR_VAR 0 3
61370: PUSH
61371: LD_EXP 105
61375: PPUSH
61376: LD_VAR 0 1
61380: PPUSH
61381: CALL_OW 321
61385: PUSH
61386: LD_INT 2
61388: EQUAL
61389: ST_TO_ADDR
61390: GO 61492
61392: LD_INT 17
61394: DOUBLE
61395: EQUAL
61396: IFTRUE 61400
61398: GO 61425
61400: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61401: LD_ADDR_VAR 0 3
61405: PUSH
61406: LD_INT 39
61408: PPUSH
61409: LD_VAR 0 1
61413: PPUSH
61414: CALL_OW 321
61418: PUSH
61419: LD_INT 2
61421: EQUAL
61422: ST_TO_ADDR
61423: GO 61492
61425: LD_INT 18
61427: DOUBLE
61428: EQUAL
61429: IFTRUE 61433
61431: GO 61458
61433: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61434: LD_ADDR_VAR 0 3
61438: PUSH
61439: LD_INT 40
61441: PPUSH
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL_OW 321
61451: PUSH
61452: LD_INT 2
61454: EQUAL
61455: ST_TO_ADDR
61456: GO 61492
61458: LD_INT 27
61460: DOUBLE
61461: EQUAL
61462: IFTRUE 61466
61464: GO 61491
61466: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61467: LD_ADDR_VAR 0 3
61471: PUSH
61472: LD_INT 35
61474: PPUSH
61475: LD_VAR 0 1
61479: PPUSH
61480: CALL_OW 321
61484: PUSH
61485: LD_INT 2
61487: EQUAL
61488: ST_TO_ADDR
61489: GO 61492
61491: POP
// end ;
61492: LD_VAR 0 3
61496: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61497: LD_INT 0
61499: PPUSH
61500: PPUSH
61501: PPUSH
61502: PPUSH
61503: PPUSH
61504: PPUSH
61505: PPUSH
61506: PPUSH
61507: PPUSH
61508: PPUSH
61509: PPUSH
// result := false ;
61510: LD_ADDR_VAR 0 6
61514: PUSH
61515: LD_INT 0
61517: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61518: LD_VAR 0 1
61522: NOT
61523: PUSH
61524: LD_VAR 0 1
61528: PPUSH
61529: CALL_OW 266
61533: PUSH
61534: LD_INT 0
61536: PUSH
61537: LD_INT 1
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: IN
61544: NOT
61545: OR
61546: PUSH
61547: LD_VAR 0 2
61551: NOT
61552: OR
61553: PUSH
61554: LD_VAR 0 5
61558: PUSH
61559: LD_INT 0
61561: PUSH
61562: LD_INT 1
61564: PUSH
61565: LD_INT 2
61567: PUSH
61568: LD_INT 3
61570: PUSH
61571: LD_INT 4
61573: PUSH
61574: LD_INT 5
61576: PUSH
61577: EMPTY
61578: LIST
61579: LIST
61580: LIST
61581: LIST
61582: LIST
61583: LIST
61584: IN
61585: NOT
61586: OR
61587: PUSH
61588: LD_VAR 0 3
61592: PPUSH
61593: LD_VAR 0 4
61597: PPUSH
61598: CALL_OW 488
61602: NOT
61603: OR
61604: IFFALSE 61608
// exit ;
61606: GO 62344
// side := GetSide ( depot ) ;
61608: LD_ADDR_VAR 0 9
61612: PUSH
61613: LD_VAR 0 1
61617: PPUSH
61618: CALL_OW 255
61622: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61623: LD_VAR 0 9
61627: PPUSH
61628: LD_VAR 0 2
61632: PPUSH
61633: CALL 61117 0 2
61637: NOT
61638: IFFALSE 61642
// exit ;
61640: GO 62344
// pom := GetBase ( depot ) ;
61642: LD_ADDR_VAR 0 10
61646: PUSH
61647: LD_VAR 0 1
61651: PPUSH
61652: CALL_OW 274
61656: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61657: LD_ADDR_VAR 0 11
61661: PUSH
61662: LD_VAR 0 2
61666: PPUSH
61667: LD_VAR 0 1
61671: PPUSH
61672: CALL_OW 248
61676: PPUSH
61677: CALL_OW 450
61681: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61682: LD_VAR 0 10
61686: PPUSH
61687: LD_INT 1
61689: PPUSH
61690: CALL_OW 275
61694: PUSH
61695: LD_VAR 0 11
61699: PUSH
61700: LD_INT 1
61702: ARRAY
61703: GREATEREQUAL
61704: PUSH
61705: LD_VAR 0 10
61709: PPUSH
61710: LD_INT 2
61712: PPUSH
61713: CALL_OW 275
61717: PUSH
61718: LD_VAR 0 11
61722: PUSH
61723: LD_INT 2
61725: ARRAY
61726: GREATEREQUAL
61727: AND
61728: PUSH
61729: LD_VAR 0 10
61733: PPUSH
61734: LD_INT 3
61736: PPUSH
61737: CALL_OW 275
61741: PUSH
61742: LD_VAR 0 11
61746: PUSH
61747: LD_INT 3
61749: ARRAY
61750: GREATEREQUAL
61751: AND
61752: NOT
61753: IFFALSE 61757
// exit ;
61755: GO 62344
// if GetBType ( depot ) = b_depot then
61757: LD_VAR 0 1
61761: PPUSH
61762: CALL_OW 266
61766: PUSH
61767: LD_INT 0
61769: EQUAL
61770: IFFALSE 61782
// dist := 28 else
61772: LD_ADDR_VAR 0 14
61776: PUSH
61777: LD_INT 28
61779: ST_TO_ADDR
61780: GO 61790
// dist := 36 ;
61782: LD_ADDR_VAR 0 14
61786: PUSH
61787: LD_INT 36
61789: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61790: LD_VAR 0 1
61794: PPUSH
61795: LD_VAR 0 3
61799: PPUSH
61800: LD_VAR 0 4
61804: PPUSH
61805: CALL_OW 297
61809: PUSH
61810: LD_VAR 0 14
61814: GREATER
61815: IFFALSE 61819
// exit ;
61817: GO 62344
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61819: LD_ADDR_VAR 0 12
61823: PUSH
61824: LD_VAR 0 2
61828: PPUSH
61829: LD_VAR 0 3
61833: PPUSH
61834: LD_VAR 0 4
61838: PPUSH
61839: LD_VAR 0 5
61843: PPUSH
61844: LD_VAR 0 1
61848: PPUSH
61849: CALL_OW 248
61853: PPUSH
61854: LD_INT 0
61856: PPUSH
61857: CALL 62349 0 6
61861: ST_TO_ADDR
// if not hexes then
61862: LD_VAR 0 12
61866: NOT
61867: IFFALSE 61871
// exit ;
61869: GO 62344
// hex := GetHexInfo ( x , y ) ;
61871: LD_ADDR_VAR 0 15
61875: PUSH
61876: LD_VAR 0 3
61880: PPUSH
61881: LD_VAR 0 4
61885: PPUSH
61886: CALL_OW 546
61890: ST_TO_ADDR
// if hex [ 1 ] then
61891: LD_VAR 0 15
61895: PUSH
61896: LD_INT 1
61898: ARRAY
61899: IFFALSE 61903
// exit ;
61901: GO 62344
// height := hex [ 2 ] ;
61903: LD_ADDR_VAR 0 13
61907: PUSH
61908: LD_VAR 0 15
61912: PUSH
61913: LD_INT 2
61915: ARRAY
61916: ST_TO_ADDR
// for i = 1 to hexes do
61917: LD_ADDR_VAR 0 7
61921: PUSH
61922: DOUBLE
61923: LD_INT 1
61925: DEC
61926: ST_TO_ADDR
61927: LD_VAR 0 12
61931: PUSH
61932: FOR_TO
61933: IFFALSE 62263
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61935: LD_VAR 0 12
61939: PUSH
61940: LD_VAR 0 7
61944: ARRAY
61945: PUSH
61946: LD_INT 1
61948: ARRAY
61949: PPUSH
61950: LD_VAR 0 12
61954: PUSH
61955: LD_VAR 0 7
61959: ARRAY
61960: PUSH
61961: LD_INT 2
61963: ARRAY
61964: PPUSH
61965: CALL_OW 488
61969: NOT
61970: PUSH
61971: LD_VAR 0 12
61975: PUSH
61976: LD_VAR 0 7
61980: ARRAY
61981: PUSH
61982: LD_INT 1
61984: ARRAY
61985: PPUSH
61986: LD_VAR 0 12
61990: PUSH
61991: LD_VAR 0 7
61995: ARRAY
61996: PUSH
61997: LD_INT 2
61999: ARRAY
62000: PPUSH
62001: CALL_OW 428
62005: PUSH
62006: LD_INT 0
62008: GREATER
62009: OR
62010: PUSH
62011: LD_VAR 0 12
62015: PUSH
62016: LD_VAR 0 7
62020: ARRAY
62021: PUSH
62022: LD_INT 1
62024: ARRAY
62025: PPUSH
62026: LD_VAR 0 12
62030: PUSH
62031: LD_VAR 0 7
62035: ARRAY
62036: PUSH
62037: LD_INT 2
62039: ARRAY
62040: PPUSH
62041: CALL_OW 351
62045: OR
62046: IFFALSE 62052
// exit ;
62048: POP
62049: POP
62050: GO 62344
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62052: LD_ADDR_VAR 0 8
62056: PUSH
62057: LD_VAR 0 12
62061: PUSH
62062: LD_VAR 0 7
62066: ARRAY
62067: PUSH
62068: LD_INT 1
62070: ARRAY
62071: PPUSH
62072: LD_VAR 0 12
62076: PUSH
62077: LD_VAR 0 7
62081: ARRAY
62082: PUSH
62083: LD_INT 2
62085: ARRAY
62086: PPUSH
62087: CALL_OW 546
62091: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62092: LD_VAR 0 8
62096: PUSH
62097: LD_INT 1
62099: ARRAY
62100: PUSH
62101: LD_VAR 0 8
62105: PUSH
62106: LD_INT 2
62108: ARRAY
62109: PUSH
62110: LD_VAR 0 13
62114: PUSH
62115: LD_INT 2
62117: PLUS
62118: GREATER
62119: OR
62120: PUSH
62121: LD_VAR 0 8
62125: PUSH
62126: LD_INT 2
62128: ARRAY
62129: PUSH
62130: LD_VAR 0 13
62134: PUSH
62135: LD_INT 2
62137: MINUS
62138: LESS
62139: OR
62140: PUSH
62141: LD_VAR 0 8
62145: PUSH
62146: LD_INT 3
62148: ARRAY
62149: PUSH
62150: LD_INT 0
62152: PUSH
62153: LD_INT 8
62155: PUSH
62156: LD_INT 9
62158: PUSH
62159: LD_INT 10
62161: PUSH
62162: LD_INT 11
62164: PUSH
62165: LD_INT 12
62167: PUSH
62168: LD_INT 13
62170: PUSH
62171: LD_INT 16
62173: PUSH
62174: LD_INT 17
62176: PUSH
62177: LD_INT 18
62179: PUSH
62180: LD_INT 19
62182: PUSH
62183: LD_INT 20
62185: PUSH
62186: LD_INT 21
62188: PUSH
62189: EMPTY
62190: LIST
62191: LIST
62192: LIST
62193: LIST
62194: LIST
62195: LIST
62196: LIST
62197: LIST
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: LIST
62203: IN
62204: NOT
62205: OR
62206: PUSH
62207: LD_VAR 0 8
62211: PUSH
62212: LD_INT 5
62214: ARRAY
62215: NOT
62216: OR
62217: PUSH
62218: LD_VAR 0 8
62222: PUSH
62223: LD_INT 6
62225: ARRAY
62226: PUSH
62227: LD_INT 1
62229: PUSH
62230: LD_INT 2
62232: PUSH
62233: LD_INT 7
62235: PUSH
62236: LD_INT 9
62238: PUSH
62239: LD_INT 10
62241: PUSH
62242: LD_INT 11
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: LIST
62249: LIST
62250: LIST
62251: LIST
62252: IN
62253: NOT
62254: OR
62255: IFFALSE 62261
// exit ;
62257: POP
62258: POP
62259: GO 62344
// end ;
62261: GO 61932
62263: POP
62264: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62265: LD_VAR 0 9
62269: PPUSH
62270: LD_VAR 0 3
62274: PPUSH
62275: LD_VAR 0 4
62279: PPUSH
62280: LD_INT 20
62282: PPUSH
62283: CALL 54290 0 4
62287: PUSH
62288: LD_INT 4
62290: ARRAY
62291: IFFALSE 62295
// exit ;
62293: GO 62344
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62295: LD_VAR 0 2
62299: PUSH
62300: LD_INT 29
62302: PUSH
62303: LD_INT 30
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: IN
62310: PUSH
62311: LD_VAR 0 3
62315: PPUSH
62316: LD_VAR 0 4
62320: PPUSH
62321: LD_VAR 0 9
62325: PPUSH
62326: CALL_OW 440
62330: NOT
62331: AND
62332: IFFALSE 62336
// exit ;
62334: GO 62344
// result := true ;
62336: LD_ADDR_VAR 0 6
62340: PUSH
62341: LD_INT 1
62343: ST_TO_ADDR
// end ;
62344: LD_VAR 0 6
62348: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62349: LD_INT 0
62351: PPUSH
62352: PPUSH
62353: PPUSH
62354: PPUSH
62355: PPUSH
62356: PPUSH
62357: PPUSH
62358: PPUSH
62359: PPUSH
62360: PPUSH
62361: PPUSH
62362: PPUSH
62363: PPUSH
62364: PPUSH
62365: PPUSH
62366: PPUSH
62367: PPUSH
62368: PPUSH
62369: PPUSH
62370: PPUSH
62371: PPUSH
62372: PPUSH
62373: PPUSH
62374: PPUSH
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
62383: PPUSH
62384: PPUSH
62385: PPUSH
62386: PPUSH
62387: PPUSH
62388: PPUSH
62389: PPUSH
62390: PPUSH
62391: PPUSH
62392: PPUSH
62393: PPUSH
62394: PPUSH
62395: PPUSH
62396: PPUSH
62397: PPUSH
62398: PPUSH
62399: PPUSH
62400: PPUSH
62401: PPUSH
62402: PPUSH
62403: PPUSH
62404: PPUSH
62405: PPUSH
62406: PPUSH
62407: PPUSH
62408: PPUSH
// result = [ ] ;
62409: LD_ADDR_VAR 0 7
62413: PUSH
62414: EMPTY
62415: ST_TO_ADDR
// temp_list = [ ] ;
62416: LD_ADDR_VAR 0 9
62420: PUSH
62421: EMPTY
62422: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62423: LD_VAR 0 4
62427: PUSH
62428: LD_INT 0
62430: PUSH
62431: LD_INT 1
62433: PUSH
62434: LD_INT 2
62436: PUSH
62437: LD_INT 3
62439: PUSH
62440: LD_INT 4
62442: PUSH
62443: LD_INT 5
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: LIST
62450: LIST
62451: LIST
62452: LIST
62453: IN
62454: NOT
62455: PUSH
62456: LD_VAR 0 1
62460: PUSH
62461: LD_INT 0
62463: PUSH
62464: LD_INT 1
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: IN
62471: PUSH
62472: LD_VAR 0 5
62476: PUSH
62477: LD_INT 1
62479: PUSH
62480: LD_INT 2
62482: PUSH
62483: LD_INT 3
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: LIST
62490: IN
62491: NOT
62492: AND
62493: OR
62494: IFFALSE 62498
// exit ;
62496: GO 80889
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62498: LD_VAR 0 1
62502: PUSH
62503: LD_INT 6
62505: PUSH
62506: LD_INT 7
62508: PUSH
62509: LD_INT 8
62511: PUSH
62512: LD_INT 13
62514: PUSH
62515: LD_INT 12
62517: PUSH
62518: LD_INT 15
62520: PUSH
62521: LD_INT 11
62523: PUSH
62524: LD_INT 14
62526: PUSH
62527: LD_INT 10
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: IN
62541: IFFALSE 62551
// btype = b_lab ;
62543: LD_ADDR_VAR 0 1
62547: PUSH
62548: LD_INT 6
62550: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62551: LD_VAR 0 6
62555: PUSH
62556: LD_INT 0
62558: PUSH
62559: LD_INT 1
62561: PUSH
62562: LD_INT 2
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: LIST
62569: IN
62570: NOT
62571: PUSH
62572: LD_VAR 0 1
62576: PUSH
62577: LD_INT 0
62579: PUSH
62580: LD_INT 1
62582: PUSH
62583: LD_INT 2
62585: PUSH
62586: LD_INT 3
62588: PUSH
62589: LD_INT 6
62591: PUSH
62592: LD_INT 36
62594: PUSH
62595: LD_INT 4
62597: PUSH
62598: LD_INT 5
62600: PUSH
62601: LD_INT 31
62603: PUSH
62604: LD_INT 32
62606: PUSH
62607: LD_INT 33
62609: PUSH
62610: EMPTY
62611: LIST
62612: LIST
62613: LIST
62614: LIST
62615: LIST
62616: LIST
62617: LIST
62618: LIST
62619: LIST
62620: LIST
62621: LIST
62622: IN
62623: NOT
62624: PUSH
62625: LD_VAR 0 6
62629: PUSH
62630: LD_INT 1
62632: EQUAL
62633: AND
62634: OR
62635: PUSH
62636: LD_VAR 0 1
62640: PUSH
62641: LD_INT 2
62643: PUSH
62644: LD_INT 3
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: IN
62651: NOT
62652: PUSH
62653: LD_VAR 0 6
62657: PUSH
62658: LD_INT 2
62660: EQUAL
62661: AND
62662: OR
62663: IFFALSE 62673
// mode = 0 ;
62665: LD_ADDR_VAR 0 6
62669: PUSH
62670: LD_INT 0
62672: ST_TO_ADDR
// case mode of 0 :
62673: LD_VAR 0 6
62677: PUSH
62678: LD_INT 0
62680: DOUBLE
62681: EQUAL
62682: IFTRUE 62686
62684: GO 74139
62686: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62687: LD_ADDR_VAR 0 11
62691: PUSH
62692: LD_INT 0
62694: PUSH
62695: LD_INT 0
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 0
62704: PUSH
62705: LD_INT 1
62707: NEG
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: LD_INT 1
62715: PUSH
62716: LD_INT 0
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: PUSH
62723: LD_INT 1
62725: PUSH
62726: LD_INT 1
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 0
62735: PUSH
62736: LD_INT 1
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: LD_INT 1
62745: NEG
62746: PUSH
62747: LD_INT 0
62749: PUSH
62750: EMPTY
62751: LIST
62752: LIST
62753: PUSH
62754: LD_INT 1
62756: NEG
62757: PUSH
62758: LD_INT 1
62760: NEG
62761: PUSH
62762: EMPTY
62763: LIST
62764: LIST
62765: PUSH
62766: LD_INT 1
62768: NEG
62769: PUSH
62770: LD_INT 2
62772: NEG
62773: PUSH
62774: EMPTY
62775: LIST
62776: LIST
62777: PUSH
62778: LD_INT 0
62780: PUSH
62781: LD_INT 2
62783: NEG
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 1
62791: PUSH
62792: LD_INT 1
62794: NEG
62795: PUSH
62796: EMPTY
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 1
62802: PUSH
62803: LD_INT 2
62805: PUSH
62806: EMPTY
62807: LIST
62808: LIST
62809: PUSH
62810: LD_INT 0
62812: PUSH
62813: LD_INT 2
62815: PUSH
62816: EMPTY
62817: LIST
62818: LIST
62819: PUSH
62820: LD_INT 1
62822: NEG
62823: PUSH
62824: LD_INT 1
62826: PUSH
62827: EMPTY
62828: LIST
62829: LIST
62830: PUSH
62831: LD_INT 1
62833: PUSH
62834: LD_INT 3
62836: PUSH
62837: EMPTY
62838: LIST
62839: LIST
62840: PUSH
62841: LD_INT 0
62843: PUSH
62844: LD_INT 3
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: LD_INT 1
62853: NEG
62854: PUSH
62855: LD_INT 2
62857: PUSH
62858: EMPTY
62859: LIST
62860: LIST
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: LIST
62866: LIST
62867: LIST
62868: LIST
62869: LIST
62870: LIST
62871: LIST
62872: LIST
62873: LIST
62874: LIST
62875: LIST
62876: LIST
62877: LIST
62878: LIST
62879: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62880: LD_ADDR_VAR 0 12
62884: PUSH
62885: LD_INT 0
62887: PUSH
62888: LD_INT 0
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PUSH
62895: LD_INT 0
62897: PUSH
62898: LD_INT 1
62900: NEG
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 1
62908: PUSH
62909: LD_INT 0
62911: PUSH
62912: EMPTY
62913: LIST
62914: LIST
62915: PUSH
62916: LD_INT 1
62918: PUSH
62919: LD_INT 1
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: PUSH
62926: LD_INT 0
62928: PUSH
62929: LD_INT 1
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 1
62938: NEG
62939: PUSH
62940: LD_INT 0
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: LD_INT 1
62949: NEG
62950: PUSH
62951: LD_INT 1
62953: NEG
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: PUSH
62959: LD_INT 1
62961: PUSH
62962: LD_INT 1
62964: NEG
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: PUSH
62970: LD_INT 2
62972: PUSH
62973: LD_INT 0
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PUSH
62980: LD_INT 2
62982: PUSH
62983: LD_INT 1
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: PUSH
62990: LD_INT 1
62992: NEG
62993: PUSH
62994: LD_INT 1
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: LD_INT 2
63003: NEG
63004: PUSH
63005: LD_INT 0
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: PUSH
63012: LD_INT 2
63014: NEG
63015: PUSH
63016: LD_INT 1
63018: NEG
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: LD_INT 2
63026: NEG
63027: PUSH
63028: LD_INT 1
63030: PUSH
63031: EMPTY
63032: LIST
63033: LIST
63034: PUSH
63035: LD_INT 3
63037: NEG
63038: PUSH
63039: LD_INT 0
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: LD_INT 3
63048: NEG
63049: PUSH
63050: LD_INT 1
63052: NEG
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: EMPTY
63059: LIST
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: LIST
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63076: LD_ADDR_VAR 0 13
63080: PUSH
63081: LD_INT 0
63083: PUSH
63084: LD_INT 0
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 0
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 1
63104: PUSH
63105: LD_INT 0
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PUSH
63112: LD_INT 1
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PUSH
63122: LD_INT 0
63124: PUSH
63125: LD_INT 1
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: PUSH
63132: LD_INT 1
63134: NEG
63135: PUSH
63136: LD_INT 0
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PUSH
63143: LD_INT 1
63145: NEG
63146: PUSH
63147: LD_INT 1
63149: NEG
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: PUSH
63159: LD_INT 2
63161: NEG
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 2
63169: PUSH
63170: LD_INT 1
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: LD_INT 2
63179: PUSH
63180: LD_INT 2
63182: PUSH
63183: EMPTY
63184: LIST
63185: LIST
63186: PUSH
63187: LD_INT 1
63189: PUSH
63190: LD_INT 2
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: LD_INT 2
63199: NEG
63200: PUSH
63201: LD_INT 1
63203: NEG
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 2
63211: NEG
63212: PUSH
63213: LD_INT 2
63215: NEG
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 2
63223: NEG
63224: PUSH
63225: LD_INT 3
63227: NEG
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: PUSH
63233: LD_INT 3
63235: NEG
63236: PUSH
63237: LD_INT 2
63239: NEG
63240: PUSH
63241: EMPTY
63242: LIST
63243: LIST
63244: PUSH
63245: LD_INT 3
63247: NEG
63248: PUSH
63249: LD_INT 3
63251: NEG
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63275: LD_ADDR_VAR 0 14
63279: PUSH
63280: LD_INT 0
63282: PUSH
63283: LD_INT 0
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 0
63292: PUSH
63293: LD_INT 1
63295: NEG
63296: PUSH
63297: EMPTY
63298: LIST
63299: LIST
63300: PUSH
63301: LD_INT 1
63303: PUSH
63304: LD_INT 0
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: PUSH
63311: LD_INT 1
63313: PUSH
63314: LD_INT 1
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PUSH
63321: LD_INT 0
63323: PUSH
63324: LD_INT 1
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: PUSH
63331: LD_INT 1
63333: NEG
63334: PUSH
63335: LD_INT 0
63337: PUSH
63338: EMPTY
63339: LIST
63340: LIST
63341: PUSH
63342: LD_INT 1
63344: NEG
63345: PUSH
63346: LD_INT 1
63348: NEG
63349: PUSH
63350: EMPTY
63351: LIST
63352: LIST
63353: PUSH
63354: LD_INT 1
63356: NEG
63357: PUSH
63358: LD_INT 2
63360: NEG
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PUSH
63366: LD_INT 0
63368: PUSH
63369: LD_INT 2
63371: NEG
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 1
63379: PUSH
63380: LD_INT 1
63382: NEG
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: PUSH
63388: LD_INT 1
63390: PUSH
63391: LD_INT 2
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 0
63400: PUSH
63401: LD_INT 2
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: PUSH
63408: LD_INT 1
63410: NEG
63411: PUSH
63412: LD_INT 1
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 1
63421: NEG
63422: PUSH
63423: LD_INT 3
63425: NEG
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: LD_INT 0
63433: PUSH
63434: LD_INT 3
63436: NEG
63437: PUSH
63438: EMPTY
63439: LIST
63440: LIST
63441: PUSH
63442: LD_INT 1
63444: PUSH
63445: LD_INT 2
63447: NEG
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63471: LD_ADDR_VAR 0 15
63475: PUSH
63476: LD_INT 0
63478: PUSH
63479: LD_INT 0
63481: PUSH
63482: EMPTY
63483: LIST
63484: LIST
63485: PUSH
63486: LD_INT 0
63488: PUSH
63489: LD_INT 1
63491: NEG
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PUSH
63497: LD_INT 1
63499: PUSH
63500: LD_INT 0
63502: PUSH
63503: EMPTY
63504: LIST
63505: LIST
63506: PUSH
63507: LD_INT 1
63509: PUSH
63510: LD_INT 1
63512: PUSH
63513: EMPTY
63514: LIST
63515: LIST
63516: PUSH
63517: LD_INT 0
63519: PUSH
63520: LD_INT 1
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: PUSH
63527: LD_INT 1
63529: NEG
63530: PUSH
63531: LD_INT 0
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: PUSH
63538: LD_INT 1
63540: NEG
63541: PUSH
63542: LD_INT 1
63544: NEG
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: PUSH
63550: LD_INT 1
63552: PUSH
63553: LD_INT 1
63555: NEG
63556: PUSH
63557: EMPTY
63558: LIST
63559: LIST
63560: PUSH
63561: LD_INT 2
63563: PUSH
63564: LD_INT 0
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: PUSH
63571: LD_INT 2
63573: PUSH
63574: LD_INT 1
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: LD_INT 1
63583: NEG
63584: PUSH
63585: LD_INT 1
63587: PUSH
63588: EMPTY
63589: LIST
63590: LIST
63591: PUSH
63592: LD_INT 2
63594: NEG
63595: PUSH
63596: LD_INT 0
63598: PUSH
63599: EMPTY
63600: LIST
63601: LIST
63602: PUSH
63603: LD_INT 2
63605: NEG
63606: PUSH
63607: LD_INT 1
63609: NEG
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: PUSH
63615: LD_INT 2
63617: PUSH
63618: LD_INT 1
63620: NEG
63621: PUSH
63622: EMPTY
63623: LIST
63624: LIST
63625: PUSH
63626: LD_INT 3
63628: PUSH
63629: LD_INT 0
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: PUSH
63636: LD_INT 3
63638: PUSH
63639: LD_INT 1
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63664: LD_ADDR_VAR 0 16
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: EMPTY
63676: LIST
63677: LIST
63678: PUSH
63679: LD_INT 0
63681: PUSH
63682: LD_INT 1
63684: NEG
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: LD_INT 0
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 1
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: NEG
63723: PUSH
63724: LD_INT 0
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 1
63733: NEG
63734: PUSH
63735: LD_INT 1
63737: NEG
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: LD_INT 2
63749: NEG
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 2
63757: PUSH
63758: LD_INT 1
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: LD_INT 2
63767: PUSH
63768: LD_INT 2
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 1
63777: PUSH
63778: LD_INT 2
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 2
63787: NEG
63788: PUSH
63789: LD_INT 1
63791: NEG
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 2
63799: NEG
63800: PUSH
63801: LD_INT 2
63803: NEG
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 3
63811: PUSH
63812: LD_INT 2
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 3
63821: PUSH
63822: LD_INT 3
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 2
63831: PUSH
63832: LD_INT 3
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63857: LD_ADDR_VAR 0 17
63861: PUSH
63862: LD_INT 0
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PUSH
63872: LD_INT 0
63874: PUSH
63875: LD_INT 1
63877: NEG
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: LD_INT 1
63885: PUSH
63886: LD_INT 0
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 1
63895: PUSH
63896: LD_INT 1
63898: PUSH
63899: EMPTY
63900: LIST
63901: LIST
63902: PUSH
63903: LD_INT 0
63905: PUSH
63906: LD_INT 1
63908: PUSH
63909: EMPTY
63910: LIST
63911: LIST
63912: PUSH
63913: LD_INT 1
63915: NEG
63916: PUSH
63917: LD_INT 0
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 1
63926: NEG
63927: PUSH
63928: LD_INT 1
63930: NEG
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: PUSH
63936: LD_INT 1
63938: NEG
63939: PUSH
63940: LD_INT 2
63942: NEG
63943: PUSH
63944: EMPTY
63945: LIST
63946: LIST
63947: PUSH
63948: LD_INT 0
63950: PUSH
63951: LD_INT 2
63953: NEG
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: LD_INT 1
63961: PUSH
63962: LD_INT 1
63964: NEG
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 2
63972: PUSH
63973: LD_INT 0
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 2
63982: PUSH
63983: LD_INT 1
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: PUSH
63990: LD_INT 2
63992: PUSH
63993: LD_INT 2
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 1
64002: PUSH
64003: LD_INT 2
64005: PUSH
64006: EMPTY
64007: LIST
64008: LIST
64009: PUSH
64010: LD_INT 0
64012: PUSH
64013: LD_INT 2
64015: PUSH
64016: EMPTY
64017: LIST
64018: LIST
64019: PUSH
64020: LD_INT 1
64022: NEG
64023: PUSH
64024: LD_INT 1
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PUSH
64031: LD_INT 2
64033: NEG
64034: PUSH
64035: LD_INT 0
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PUSH
64042: LD_INT 2
64044: NEG
64045: PUSH
64046: LD_INT 1
64048: NEG
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: LD_INT 2
64056: NEG
64057: PUSH
64058: LD_INT 2
64060: NEG
64061: PUSH
64062: EMPTY
64063: LIST
64064: LIST
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64087: LD_ADDR_VAR 0 18
64091: PUSH
64092: LD_INT 0
64094: PUSH
64095: LD_INT 0
64097: PUSH
64098: EMPTY
64099: LIST
64100: LIST
64101: PUSH
64102: LD_INT 0
64104: PUSH
64105: LD_INT 1
64107: NEG
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 1
64115: PUSH
64116: LD_INT 0
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: LD_INT 1
64125: PUSH
64126: LD_INT 1
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: LD_INT 0
64135: PUSH
64136: LD_INT 1
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 1
64145: NEG
64146: PUSH
64147: LD_INT 0
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 1
64156: NEG
64157: PUSH
64158: LD_INT 1
64160: NEG
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 1
64168: NEG
64169: PUSH
64170: LD_INT 2
64172: NEG
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 0
64180: PUSH
64181: LD_INT 2
64183: NEG
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: LD_INT 1
64194: NEG
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 2
64202: PUSH
64203: LD_INT 0
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 2
64212: PUSH
64213: LD_INT 1
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: LD_INT 2
64222: PUSH
64223: LD_INT 2
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PUSH
64230: LD_INT 1
64232: PUSH
64233: LD_INT 2
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: LD_INT 0
64242: PUSH
64243: LD_INT 2
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 1
64252: NEG
64253: PUSH
64254: LD_INT 1
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 2
64263: NEG
64264: PUSH
64265: LD_INT 0
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 2
64274: NEG
64275: PUSH
64276: LD_INT 1
64278: NEG
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 2
64286: NEG
64287: PUSH
64288: LD_INT 2
64290: NEG
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64317: LD_ADDR_VAR 0 19
64321: PUSH
64322: LD_INT 0
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 0
64334: PUSH
64335: LD_INT 1
64337: NEG
64338: PUSH
64339: EMPTY
64340: LIST
64341: LIST
64342: PUSH
64343: LD_INT 1
64345: PUSH
64346: LD_INT 0
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: LD_INT 1
64355: PUSH
64356: LD_INT 1
64358: PUSH
64359: EMPTY
64360: LIST
64361: LIST
64362: PUSH
64363: LD_INT 0
64365: PUSH
64366: LD_INT 1
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 1
64375: NEG
64376: PUSH
64377: LD_INT 0
64379: PUSH
64380: EMPTY
64381: LIST
64382: LIST
64383: PUSH
64384: LD_INT 1
64386: NEG
64387: PUSH
64388: LD_INT 1
64390: NEG
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 1
64398: NEG
64399: PUSH
64400: LD_INT 2
64402: NEG
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: LD_INT 0
64410: PUSH
64411: LD_INT 2
64413: NEG
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 1
64421: PUSH
64422: LD_INT 1
64424: NEG
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 2
64432: PUSH
64433: LD_INT 0
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: PUSH
64440: LD_INT 2
64442: PUSH
64443: LD_INT 1
64445: PUSH
64446: EMPTY
64447: LIST
64448: LIST
64449: PUSH
64450: LD_INT 2
64452: PUSH
64453: LD_INT 2
64455: PUSH
64456: EMPTY
64457: LIST
64458: LIST
64459: PUSH
64460: LD_INT 1
64462: PUSH
64463: LD_INT 2
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: LD_INT 0
64472: PUSH
64473: LD_INT 2
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: LD_INT 1
64482: NEG
64483: PUSH
64484: LD_INT 1
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: LD_INT 2
64493: NEG
64494: PUSH
64495: LD_INT 0
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 2
64504: NEG
64505: PUSH
64506: LD_INT 1
64508: NEG
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: LD_INT 2
64516: NEG
64517: PUSH
64518: LD_INT 2
64520: NEG
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64547: LD_ADDR_VAR 0 20
64551: PUSH
64552: LD_INT 0
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: EMPTY
64559: LIST
64560: LIST
64561: PUSH
64562: LD_INT 0
64564: PUSH
64565: LD_INT 1
64567: NEG
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PUSH
64573: LD_INT 1
64575: PUSH
64576: LD_INT 0
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PUSH
64583: LD_INT 1
64585: PUSH
64586: LD_INT 1
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 0
64595: PUSH
64596: LD_INT 1
64598: PUSH
64599: EMPTY
64600: LIST
64601: LIST
64602: PUSH
64603: LD_INT 1
64605: NEG
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PUSH
64614: LD_INT 1
64616: NEG
64617: PUSH
64618: LD_INT 1
64620: NEG
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: PUSH
64626: LD_INT 1
64628: NEG
64629: PUSH
64630: LD_INT 2
64632: NEG
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 0
64640: PUSH
64641: LD_INT 2
64643: NEG
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: LD_INT 1
64654: NEG
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: LD_INT 2
64662: PUSH
64663: LD_INT 0
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 2
64672: PUSH
64673: LD_INT 1
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 2
64682: PUSH
64683: LD_INT 2
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 1
64692: PUSH
64693: LD_INT 2
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 0
64702: PUSH
64703: LD_INT 2
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: LD_INT 1
64712: NEG
64713: PUSH
64714: LD_INT 1
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 2
64723: NEG
64724: PUSH
64725: LD_INT 0
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 2
64734: NEG
64735: PUSH
64736: LD_INT 1
64738: NEG
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: PUSH
64744: LD_INT 2
64746: NEG
64747: PUSH
64748: LD_INT 2
64750: NEG
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64777: LD_ADDR_VAR 0 21
64781: PUSH
64782: LD_INT 0
64784: PUSH
64785: LD_INT 0
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 0
64794: PUSH
64795: LD_INT 1
64797: NEG
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 1
64805: PUSH
64806: LD_INT 0
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 1
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 0
64825: PUSH
64826: LD_INT 1
64828: PUSH
64829: EMPTY
64830: LIST
64831: LIST
64832: PUSH
64833: LD_INT 1
64835: NEG
64836: PUSH
64837: LD_INT 0
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 1
64846: NEG
64847: PUSH
64848: LD_INT 1
64850: NEG
64851: PUSH
64852: EMPTY
64853: LIST
64854: LIST
64855: PUSH
64856: LD_INT 1
64858: NEG
64859: PUSH
64860: LD_INT 2
64862: NEG
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: LD_INT 0
64870: PUSH
64871: LD_INT 2
64873: NEG
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 1
64881: PUSH
64882: LD_INT 1
64884: NEG
64885: PUSH
64886: EMPTY
64887: LIST
64888: LIST
64889: PUSH
64890: LD_INT 2
64892: PUSH
64893: LD_INT 0
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_INT 2
64902: PUSH
64903: LD_INT 1
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: PUSH
64910: LD_INT 2
64912: PUSH
64913: LD_INT 2
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PUSH
64920: LD_INT 1
64922: PUSH
64923: LD_INT 2
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: PUSH
64930: LD_INT 0
64932: PUSH
64933: LD_INT 2
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PUSH
64940: LD_INT 1
64942: NEG
64943: PUSH
64944: LD_INT 1
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 2
64953: NEG
64954: PUSH
64955: LD_INT 0
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 2
64964: NEG
64965: PUSH
64966: LD_INT 1
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 2
64976: NEG
64977: PUSH
64978: LD_INT 2
64980: NEG
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65007: LD_ADDR_VAR 0 22
65011: PUSH
65012: LD_INT 0
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 0
65024: PUSH
65025: LD_INT 1
65027: NEG
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 1
65035: PUSH
65036: LD_INT 0
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 1
65045: PUSH
65046: LD_INT 1
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 0
65055: PUSH
65056: LD_INT 1
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PUSH
65063: LD_INT 1
65065: NEG
65066: PUSH
65067: LD_INT 0
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 1
65076: NEG
65077: PUSH
65078: LD_INT 1
65080: NEG
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 1
65088: NEG
65089: PUSH
65090: LD_INT 2
65092: NEG
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 0
65100: PUSH
65101: LD_INT 2
65103: NEG
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 1
65111: PUSH
65112: LD_INT 1
65114: NEG
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PUSH
65120: LD_INT 2
65122: PUSH
65123: LD_INT 0
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PUSH
65130: LD_INT 2
65132: PUSH
65133: LD_INT 1
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PUSH
65140: LD_INT 2
65142: PUSH
65143: LD_INT 2
65145: PUSH
65146: EMPTY
65147: LIST
65148: LIST
65149: PUSH
65150: LD_INT 1
65152: PUSH
65153: LD_INT 2
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 0
65162: PUSH
65163: LD_INT 2
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PUSH
65170: LD_INT 1
65172: NEG
65173: PUSH
65174: LD_INT 1
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 2
65183: NEG
65184: PUSH
65185: LD_INT 0
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 2
65194: NEG
65195: PUSH
65196: LD_INT 1
65198: NEG
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 2
65206: NEG
65207: PUSH
65208: LD_INT 2
65210: NEG
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65237: LD_ADDR_VAR 0 23
65241: PUSH
65242: LD_INT 0
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: EMPTY
65249: LIST
65250: LIST
65251: PUSH
65252: LD_INT 0
65254: PUSH
65255: LD_INT 1
65257: NEG
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: LD_INT 1
65265: PUSH
65266: LD_INT 0
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PUSH
65273: LD_INT 1
65275: PUSH
65276: LD_INT 1
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 0
65285: PUSH
65286: LD_INT 1
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 1
65295: NEG
65296: PUSH
65297: LD_INT 0
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 1
65306: NEG
65307: PUSH
65308: LD_INT 1
65310: NEG
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: PUSH
65316: LD_INT 1
65318: NEG
65319: PUSH
65320: LD_INT 2
65322: NEG
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 0
65330: PUSH
65331: LD_INT 2
65333: NEG
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: LD_INT 1
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: EMPTY
65347: LIST
65348: LIST
65349: PUSH
65350: LD_INT 2
65352: PUSH
65353: LD_INT 0
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: LD_INT 2
65362: PUSH
65363: LD_INT 1
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 2
65372: PUSH
65373: LD_INT 2
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 1
65382: PUSH
65383: LD_INT 2
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: LD_INT 0
65392: PUSH
65393: LD_INT 2
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 1
65402: NEG
65403: PUSH
65404: LD_INT 1
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 2
65413: NEG
65414: PUSH
65415: LD_INT 0
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 2
65424: NEG
65425: PUSH
65426: LD_INT 1
65428: NEG
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 2
65436: NEG
65437: PUSH
65438: LD_INT 2
65440: NEG
65441: PUSH
65442: EMPTY
65443: LIST
65444: LIST
65445: PUSH
65446: LD_INT 2
65448: NEG
65449: PUSH
65450: LD_INT 3
65452: NEG
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: PUSH
65458: LD_INT 1
65460: NEG
65461: PUSH
65462: LD_INT 3
65464: NEG
65465: PUSH
65466: EMPTY
65467: LIST
65468: LIST
65469: PUSH
65470: LD_INT 1
65472: PUSH
65473: LD_INT 2
65475: NEG
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: PUSH
65481: LD_INT 2
65483: PUSH
65484: LD_INT 1
65486: NEG
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65517: LD_ADDR_VAR 0 24
65521: PUSH
65522: LD_INT 0
65524: PUSH
65525: LD_INT 0
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: LD_INT 0
65534: PUSH
65535: LD_INT 1
65537: NEG
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: PUSH
65543: LD_INT 1
65545: PUSH
65546: LD_INT 0
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: PUSH
65553: LD_INT 1
65555: PUSH
65556: LD_INT 1
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 0
65565: PUSH
65566: LD_INT 1
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 1
65575: NEG
65576: PUSH
65577: LD_INT 0
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 1
65586: NEG
65587: PUSH
65588: LD_INT 1
65590: NEG
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 1
65598: NEG
65599: PUSH
65600: LD_INT 2
65602: NEG
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: LD_INT 0
65610: PUSH
65611: LD_INT 2
65613: NEG
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: LD_INT 1
65621: PUSH
65622: LD_INT 1
65624: NEG
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 2
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 2
65642: PUSH
65643: LD_INT 1
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 2
65652: PUSH
65653: LD_INT 2
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 2
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 0
65672: PUSH
65673: LD_INT 2
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 1
65682: NEG
65683: PUSH
65684: LD_INT 1
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: LD_INT 2
65693: NEG
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 2
65704: NEG
65705: PUSH
65706: LD_INT 1
65708: NEG
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 2
65716: NEG
65717: PUSH
65718: LD_INT 2
65720: NEG
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PUSH
65726: LD_INT 1
65728: PUSH
65729: LD_INT 2
65731: NEG
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 2
65739: PUSH
65740: LD_INT 1
65742: NEG
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 3
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 3
65760: PUSH
65761: LD_INT 2
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65793: LD_ADDR_VAR 0 25
65797: PUSH
65798: LD_INT 0
65800: PUSH
65801: LD_INT 0
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 0
65810: PUSH
65811: LD_INT 1
65813: NEG
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: PUSH
65819: LD_INT 1
65821: PUSH
65822: LD_INT 0
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PUSH
65829: LD_INT 1
65831: PUSH
65832: LD_INT 1
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 0
65841: PUSH
65842: LD_INT 1
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 1
65851: NEG
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 1
65862: NEG
65863: PUSH
65864: LD_INT 1
65866: NEG
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 1
65874: NEG
65875: PUSH
65876: LD_INT 2
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 0
65886: PUSH
65887: LD_INT 2
65889: NEG
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 1
65897: PUSH
65898: LD_INT 1
65900: NEG
65901: PUSH
65902: EMPTY
65903: LIST
65904: LIST
65905: PUSH
65906: LD_INT 2
65908: PUSH
65909: LD_INT 0
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: PUSH
65916: LD_INT 2
65918: PUSH
65919: LD_INT 1
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: LD_INT 2
65928: PUSH
65929: LD_INT 2
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PUSH
65936: LD_INT 1
65938: PUSH
65939: LD_INT 2
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: PUSH
65946: LD_INT 0
65948: PUSH
65949: LD_INT 2
65951: PUSH
65952: EMPTY
65953: LIST
65954: LIST
65955: PUSH
65956: LD_INT 1
65958: NEG
65959: PUSH
65960: LD_INT 1
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PUSH
65967: LD_INT 2
65969: NEG
65970: PUSH
65971: LD_INT 0
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: LD_INT 2
65980: NEG
65981: PUSH
65982: LD_INT 1
65984: NEG
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 2
65992: NEG
65993: PUSH
65994: LD_INT 2
65996: NEG
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 3
66004: PUSH
66005: LD_INT 1
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 3
66014: PUSH
66015: LD_INT 2
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 2
66024: PUSH
66025: LD_INT 3
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 1
66034: PUSH
66035: LD_INT 3
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66067: LD_ADDR_VAR 0 26
66071: PUSH
66072: LD_INT 0
66074: PUSH
66075: LD_INT 0
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 0
66084: PUSH
66085: LD_INT 1
66087: NEG
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 1
66095: PUSH
66096: LD_INT 0
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 1
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 0
66115: PUSH
66116: LD_INT 1
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 1
66125: NEG
66126: PUSH
66127: LD_INT 0
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 1
66136: NEG
66137: PUSH
66138: LD_INT 1
66140: NEG
66141: PUSH
66142: EMPTY
66143: LIST
66144: LIST
66145: PUSH
66146: LD_INT 1
66148: NEG
66149: PUSH
66150: LD_INT 2
66152: NEG
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 0
66160: PUSH
66161: LD_INT 2
66163: NEG
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 1
66171: PUSH
66172: LD_INT 1
66174: NEG
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: PUSH
66180: LD_INT 2
66182: PUSH
66183: LD_INT 0
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 1
66195: PUSH
66196: EMPTY
66197: LIST
66198: LIST
66199: PUSH
66200: LD_INT 2
66202: PUSH
66203: LD_INT 2
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PUSH
66210: LD_INT 1
66212: PUSH
66213: LD_INT 2
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 0
66222: PUSH
66223: LD_INT 2
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: NEG
66233: PUSH
66234: LD_INT 1
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 2
66243: NEG
66244: PUSH
66245: LD_INT 0
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 2
66254: NEG
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 2
66266: NEG
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 2
66278: PUSH
66279: LD_INT 3
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 1
66288: PUSH
66289: LD_INT 3
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 1
66298: NEG
66299: PUSH
66300: LD_INT 2
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 2
66309: NEG
66310: PUSH
66311: LD_INT 1
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: LIST
66326: LIST
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66343: LD_ADDR_VAR 0 27
66347: PUSH
66348: LD_INT 0
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 0
66360: PUSH
66361: LD_INT 1
66363: NEG
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 1
66371: PUSH
66372: LD_INT 0
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 1
66381: PUSH
66382: LD_INT 1
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 0
66391: PUSH
66392: LD_INT 1
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 1
66401: NEG
66402: PUSH
66403: LD_INT 0
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 1
66412: NEG
66413: PUSH
66414: LD_INT 1
66416: NEG
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: LD_INT 2
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 0
66436: PUSH
66437: LD_INT 2
66439: NEG
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 1
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 2
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 2
66468: PUSH
66469: LD_INT 1
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 2
66478: PUSH
66479: LD_INT 2
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 1
66488: PUSH
66489: LD_INT 2
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 0
66498: PUSH
66499: LD_INT 2
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 1
66508: NEG
66509: PUSH
66510: LD_INT 1
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: LD_INT 2
66519: NEG
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: EMPTY
66525: LIST
66526: LIST
66527: PUSH
66528: LD_INT 2
66530: NEG
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 2
66542: NEG
66543: PUSH
66544: LD_INT 2
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 1
66554: NEG
66555: PUSH
66556: LD_INT 2
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 2
66565: NEG
66566: PUSH
66567: LD_INT 1
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 3
66576: NEG
66577: PUSH
66578: LD_INT 1
66580: NEG
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 3
66588: NEG
66589: PUSH
66590: LD_INT 2
66592: NEG
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66623: LD_ADDR_VAR 0 28
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 0
66640: PUSH
66641: LD_INT 1
66643: NEG
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 1
66651: PUSH
66652: LD_INT 0
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 1
66661: PUSH
66662: LD_INT 1
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 0
66671: PUSH
66672: LD_INT 1
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: PUSH
66679: LD_INT 1
66681: NEG
66682: PUSH
66683: LD_INT 0
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 1
66692: NEG
66693: PUSH
66694: LD_INT 1
66696: NEG
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: PUSH
66702: LD_INT 1
66704: NEG
66705: PUSH
66706: LD_INT 2
66708: NEG
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: PUSH
66714: LD_INT 0
66716: PUSH
66717: LD_INT 2
66719: NEG
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: PUSH
66725: LD_INT 1
66727: PUSH
66728: LD_INT 1
66730: NEG
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: LD_INT 2
66738: PUSH
66739: LD_INT 0
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 2
66748: PUSH
66749: LD_INT 1
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 2
66758: PUSH
66759: LD_INT 2
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: LD_INT 2
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: LD_INT 1
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: LD_INT 2
66799: NEG
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 2
66810: NEG
66811: PUSH
66812: LD_INT 1
66814: NEG
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 2
66822: NEG
66823: PUSH
66824: LD_INT 2
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 2
66834: NEG
66835: PUSH
66836: LD_INT 3
66838: NEG
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 1
66846: NEG
66847: PUSH
66848: LD_INT 3
66850: NEG
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 3
66858: NEG
66859: PUSH
66860: LD_INT 1
66862: NEG
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 3
66870: NEG
66871: PUSH
66872: LD_INT 2
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66905: LD_ADDR_VAR 0 29
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: LD_INT 0
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 0
66922: PUSH
66923: LD_INT 1
66925: NEG
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 1
66933: PUSH
66934: LD_INT 0
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 1
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 0
66953: PUSH
66954: LD_INT 1
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: NEG
66964: PUSH
66965: LD_INT 0
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: LD_INT 1
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 1
66986: NEG
66987: PUSH
66988: LD_INT 2
66990: NEG
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 0
66998: PUSH
66999: LD_INT 2
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: LD_INT 1
67009: PUSH
67010: LD_INT 1
67012: NEG
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 2
67020: PUSH
67021: LD_INT 0
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 2
67030: PUSH
67031: LD_INT 1
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 1
67040: PUSH
67041: LD_INT 2
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: LD_INT 0
67050: PUSH
67051: LD_INT 2
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 1
67060: NEG
67061: PUSH
67062: LD_INT 1
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 2
67071: NEG
67072: PUSH
67073: LD_INT 1
67075: NEG
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 2
67083: NEG
67084: PUSH
67085: LD_INT 2
67087: NEG
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 2
67095: NEG
67096: PUSH
67097: LD_INT 3
67099: NEG
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 2
67107: PUSH
67108: LD_INT 1
67110: NEG
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: PUSH
67116: LD_INT 3
67118: PUSH
67119: LD_INT 1
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 1
67128: PUSH
67129: LD_INT 3
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 1
67138: NEG
67139: PUSH
67140: LD_INT 2
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: LD_INT 3
67149: NEG
67150: PUSH
67151: LD_INT 2
67153: NEG
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: LIST
67183: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67184: LD_ADDR_VAR 0 30
67188: PUSH
67189: LD_INT 0
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 0
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 1
67222: PUSH
67223: LD_INT 1
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 0
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: PUSH
67240: LD_INT 1
67242: NEG
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 1
67253: NEG
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 1
67265: NEG
67266: PUSH
67267: LD_INT 2
67269: NEG
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 2
67280: NEG
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 1
67288: PUSH
67289: LD_INT 1
67291: NEG
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 2
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 2
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 2
67319: PUSH
67320: LD_INT 2
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 1
67329: PUSH
67330: LD_INT 2
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: LD_INT 1
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 2
67350: NEG
67351: PUSH
67352: LD_INT 0
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 2
67361: NEG
67362: PUSH
67363: LD_INT 1
67365: NEG
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: LD_INT 3
67377: NEG
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 1
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 3
67396: PUSH
67397: LD_INT 2
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 2
67406: PUSH
67407: LD_INT 3
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 2
67416: NEG
67417: PUSH
67418: LD_INT 1
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 3
67427: NEG
67428: PUSH
67429: LD_INT 1
67431: NEG
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67462: LD_ADDR_VAR 0 31
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: LD_INT 0
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 0
67479: PUSH
67480: LD_INT 1
67482: NEG
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 1
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 1
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 0
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 1
67531: NEG
67532: PUSH
67533: LD_INT 1
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: NEG
67544: PUSH
67545: LD_INT 2
67547: NEG
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 1
67555: PUSH
67556: LD_INT 1
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: LD_INT 0
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 2
67576: PUSH
67577: LD_INT 1
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 2
67586: PUSH
67587: LD_INT 2
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 1
67596: PUSH
67597: LD_INT 2
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 0
67606: PUSH
67607: LD_INT 2
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 1
67616: NEG
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 2
67627: NEG
67628: PUSH
67629: LD_INT 1
67631: NEG
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 2
67639: NEG
67640: PUSH
67641: LD_INT 2
67643: NEG
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 2
67651: NEG
67652: PUSH
67653: LD_INT 3
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 2
67663: PUSH
67664: LD_INT 1
67666: NEG
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 3
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: PUSH
67685: LD_INT 3
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: NEG
67695: PUSH
67696: LD_INT 2
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 3
67705: NEG
67706: PUSH
67707: LD_INT 2
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67740: LD_ADDR_VAR 0 32
67744: PUSH
67745: LD_INT 0
67747: PUSH
67748: LD_INT 0
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: PUSH
67769: LD_INT 0
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 1
67778: PUSH
67779: LD_INT 1
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 1
67798: NEG
67799: PUSH
67800: LD_INT 0
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: LD_INT 2
67825: NEG
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 0
67833: PUSH
67834: LD_INT 2
67836: NEG
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 1
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 2
67855: PUSH
67856: LD_INT 1
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 2
67865: PUSH
67866: LD_INT 2
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 1
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: LD_INT 2
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: LD_INT 1
67895: NEG
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: LD_INT 2
67906: NEG
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 2
67917: NEG
67918: PUSH
67919: LD_INT 1
67921: NEG
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 1
67929: NEG
67930: PUSH
67931: LD_INT 3
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 1
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 3
67952: PUSH
67953: LD_INT 2
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 2
67962: PUSH
67963: LD_INT 3
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 2
67972: NEG
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 3
67983: NEG
67984: PUSH
67985: LD_INT 1
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68018: LD_ADDR_VAR 0 33
68022: PUSH
68023: LD_INT 0
68025: PUSH
68026: LD_INT 0
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 0
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 1
68056: PUSH
68057: LD_INT 1
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: NEG
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 1
68099: NEG
68100: PUSH
68101: LD_INT 2
68103: NEG
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: LD_INT 1
68114: NEG
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 2
68122: PUSH
68123: LD_INT 0
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 2
68132: PUSH
68133: LD_INT 1
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 1
68142: PUSH
68143: LD_INT 2
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 0
68152: PUSH
68153: LD_INT 2
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: LD_INT 1
68162: NEG
68163: PUSH
68164: LD_INT 1
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 2
68173: NEG
68174: PUSH
68175: LD_INT 0
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 2
68184: NEG
68185: PUSH
68186: LD_INT 1
68188: NEG
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 2
68196: NEG
68197: PUSH
68198: LD_INT 2
68200: NEG
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 2
68208: NEG
68209: PUSH
68210: LD_INT 3
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 3
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 1
68241: PUSH
68242: LD_INT 3
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 2
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 3
68262: NEG
68263: PUSH
68264: LD_INT 2
68266: NEG
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68297: LD_ADDR_VAR 0 34
68301: PUSH
68302: LD_INT 0
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 0
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 1
68325: PUSH
68326: LD_INT 0
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: LD_INT 1
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: NEG
68379: PUSH
68380: LD_INT 2
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: LD_INT 2
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 1
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 2
68412: PUSH
68413: LD_INT 1
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 2
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 1
68432: PUSH
68433: LD_INT 2
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 1
68442: NEG
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 2
68453: NEG
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 2
68464: NEG
68465: PUSH
68466: LD_INT 1
68468: NEG
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 2
68476: NEG
68477: PUSH
68478: LD_INT 2
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: LD_INT 3
68492: NEG
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 1
68500: PUSH
68501: LD_INT 2
68503: NEG
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 3
68511: PUSH
68512: LD_INT 2
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 2
68521: PUSH
68522: LD_INT 3
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 2
68531: NEG
68532: PUSH
68533: LD_INT 1
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: LD_INT 3
68542: NEG
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68577: LD_ADDR_VAR 0 35
68581: PUSH
68582: LD_INT 0
68584: PUSH
68585: LD_INT 0
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 0
68594: PUSH
68595: LD_INT 1
68597: NEG
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 1
68605: PUSH
68606: LD_INT 0
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: PUSH
68616: LD_INT 1
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 0
68625: PUSH
68626: LD_INT 1
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 1
68646: NEG
68647: PUSH
68648: LD_INT 1
68650: NEG
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 2
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: LD_INT 1
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68689: LD_ADDR_VAR 0 36
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: LD_INT 0
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: LD_INT 0
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 1
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 0
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: LD_INT 0
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 1
68782: PUSH
68783: LD_INT 2
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68801: LD_ADDR_VAR 0 37
68805: PUSH
68806: LD_INT 0
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 0
68818: PUSH
68819: LD_INT 1
68821: NEG
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: LD_INT 0
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: PUSH
68840: LD_INT 1
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: LD_INT 1
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 1
68859: NEG
68860: PUSH
68861: LD_INT 0
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 1
68870: NEG
68871: PUSH
68872: LD_INT 1
68874: NEG
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 1
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 1
68893: NEG
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68913: LD_ADDR_VAR 0 38
68917: PUSH
68918: LD_INT 0
68920: PUSH
68921: LD_INT 0
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 0
68930: PUSH
68931: LD_INT 1
68933: NEG
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: PUSH
68942: LD_INT 0
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: LD_INT 1
68951: PUSH
68952: LD_INT 1
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 0
68961: PUSH
68962: LD_INT 1
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: LD_INT 1
68971: NEG
68972: PUSH
68973: LD_INT 0
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 1
68982: NEG
68983: PUSH
68984: LD_INT 1
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 2
68994: PUSH
68995: LD_INT 1
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: LD_INT 1
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69025: LD_ADDR_VAR 0 39
69029: PUSH
69030: LD_INT 0
69032: PUSH
69033: LD_INT 0
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 0
69042: PUSH
69043: LD_INT 1
69045: NEG
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: LD_INT 0
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 0
69073: PUSH
69074: LD_INT 1
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: NEG
69084: PUSH
69085: LD_INT 0
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: LD_INT 1
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: NEG
69107: PUSH
69108: LD_INT 2
69110: NEG
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 1
69118: PUSH
69119: LD_INT 2
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69137: LD_ADDR_VAR 0 40
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: LD_INT 0
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: LD_INT 1
69157: NEG
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: PUSH
69166: LD_INT 0
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 0
69185: PUSH
69186: LD_INT 1
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 1
69195: NEG
69196: PUSH
69197: LD_INT 0
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: NEG
69207: PUSH
69208: LD_INT 1
69210: NEG
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 1
69218: PUSH
69219: LD_INT 1
69221: NEG
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 1
69229: NEG
69230: PUSH
69231: LD_INT 1
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69249: LD_ADDR_VAR 0 41
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: LD_INT 0
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 0
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 1
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 1
69287: PUSH
69288: LD_INT 1
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: LD_INT 0
69297: PUSH
69298: LD_INT 1
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 1
69307: NEG
69308: PUSH
69309: LD_INT 0
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: LD_INT 1
69318: NEG
69319: PUSH
69320: LD_INT 1
69322: NEG
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: NEG
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: PUSH
69343: LD_INT 1
69345: NEG
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 2
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 2
69363: PUSH
69364: LD_INT 1
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 2
69373: PUSH
69374: LD_INT 2
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 1
69383: PUSH
69384: LD_INT 2
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: LD_INT 1
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 2
69404: NEG
69405: PUSH
69406: LD_INT 0
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 2
69415: NEG
69416: PUSH
69417: LD_INT 1
69419: NEG
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 2
69427: NEG
69428: PUSH
69429: LD_INT 2
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 2
69439: NEG
69440: PUSH
69441: LD_INT 3
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 3
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 3
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 3
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 3
69492: PUSH
69493: LD_INT 3
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 2
69502: PUSH
69503: LD_INT 3
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 2
69512: NEG
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 3
69523: NEG
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 3
69534: NEG
69535: PUSH
69536: LD_INT 1
69538: NEG
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 3
69546: NEG
69547: PUSH
69548: LD_INT 2
69550: NEG
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 3
69558: NEG
69559: PUSH
69560: LD_INT 3
69562: NEG
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69599: LD_ADDR_VAR 0 42
69603: PUSH
69604: LD_INT 0
69606: PUSH
69607: LD_INT 0
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 1
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: LD_INT 0
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: LD_INT 1
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 0
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 1
69657: NEG
69658: PUSH
69659: LD_INT 0
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 1
69668: NEG
69669: PUSH
69670: LD_INT 1
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 1
69680: NEG
69681: PUSH
69682: LD_INT 2
69684: NEG
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 2
69695: NEG
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 1
69703: PUSH
69704: LD_INT 1
69706: NEG
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: PUSH
69712: LD_INT 2
69714: PUSH
69715: LD_INT 1
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 2
69724: PUSH
69725: LD_INT 2
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 1
69734: PUSH
69735: LD_INT 2
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 0
69744: PUSH
69745: LD_INT 2
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 1
69754: NEG
69755: PUSH
69756: LD_INT 1
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 2
69765: NEG
69766: PUSH
69767: LD_INT 1
69769: NEG
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 2
69777: NEG
69778: PUSH
69779: LD_INT 2
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 2
69789: NEG
69790: PUSH
69791: LD_INT 3
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 1
69801: NEG
69802: PUSH
69803: LD_INT 3
69805: NEG
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 0
69813: PUSH
69814: LD_INT 3
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 1
69824: PUSH
69825: LD_INT 2
69827: NEG
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 3
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 3
69845: PUSH
69846: LD_INT 3
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 2
69855: PUSH
69856: LD_INT 3
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 1
69865: PUSH
69866: LD_INT 3
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 0
69875: PUSH
69876: LD_INT 3
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 3
69896: NEG
69897: PUSH
69898: LD_INT 2
69900: NEG
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 3
69908: NEG
69909: PUSH
69910: LD_INT 3
69912: NEG
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: LIST
69926: LIST
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69949: LD_ADDR_VAR 0 43
69953: PUSH
69954: LD_INT 0
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 0
69966: PUSH
69967: LD_INT 1
69969: NEG
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 1
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 1
69987: PUSH
69988: LD_INT 1
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: LD_INT 1
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 1
70007: NEG
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: LD_INT 1
70022: NEG
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: NEG
70031: PUSH
70032: LD_INT 2
70034: NEG
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: LD_INT 2
70045: NEG
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 1
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 2
70064: PUSH
70065: LD_INT 0
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 2
70074: PUSH
70075: LD_INT 1
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 1
70084: PUSH
70085: LD_INT 2
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: LD_INT 2
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: LD_INT 1
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 2
70115: NEG
70116: PUSH
70117: LD_INT 0
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 2
70126: NEG
70127: PUSH
70128: LD_INT 1
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 1
70138: NEG
70139: PUSH
70140: LD_INT 3
70142: NEG
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: LD_INT 3
70153: NEG
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 1
70161: PUSH
70162: LD_INT 2
70164: NEG
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 2
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 3
70183: PUSH
70184: LD_INT 0
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 3
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: LD_INT 3
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 3
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 3
70245: NEG
70246: PUSH
70247: LD_INT 0
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 3
70256: NEG
70257: PUSH
70258: LD_INT 1
70260: NEG
70261: PUSH
70262: EMPTY
70263: LIST
70264: LIST
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70297: LD_ADDR_VAR 0 44
70301: PUSH
70302: LD_INT 0
70304: PUSH
70305: LD_INT 0
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PUSH
70312: LD_INT 0
70314: PUSH
70315: LD_INT 1
70317: NEG
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 1
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 1
70335: PUSH
70336: LD_INT 1
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: LD_INT 1
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 1
70355: NEG
70356: PUSH
70357: LD_INT 0
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 1
70366: NEG
70367: PUSH
70368: LD_INT 1
70370: NEG
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 1
70378: NEG
70379: PUSH
70380: LD_INT 2
70382: NEG
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: LD_INT 1
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 2
70401: PUSH
70402: LD_INT 0
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: PUSH
70412: LD_INT 1
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 2
70421: PUSH
70422: LD_INT 2
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: LD_INT 2
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 1
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 2
70452: NEG
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 2
70463: NEG
70464: PUSH
70465: LD_INT 1
70467: NEG
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 2
70475: NEG
70476: PUSH
70477: LD_INT 2
70479: NEG
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 2
70487: NEG
70488: PUSH
70489: LD_INT 3
70491: NEG
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 2
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 3
70510: PUSH
70511: LD_INT 0
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 3
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 3
70530: PUSH
70531: LD_INT 2
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 3
70540: PUSH
70541: LD_INT 3
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 2
70550: PUSH
70551: LD_INT 3
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 2
70560: NEG
70561: PUSH
70562: LD_INT 1
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 3
70571: NEG
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 3
70582: NEG
70583: PUSH
70584: LD_INT 1
70586: NEG
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 3
70594: NEG
70595: PUSH
70596: LD_INT 2
70598: NEG
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: LD_INT 3
70606: NEG
70607: PUSH
70608: LD_INT 3
70610: NEG
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70647: LD_ADDR_VAR 0 45
70651: PUSH
70652: LD_INT 0
70654: PUSH
70655: LD_INT 0
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: LD_INT 1
70667: NEG
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 1
70675: PUSH
70676: LD_INT 0
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 1
70685: PUSH
70686: LD_INT 1
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 0
70695: PUSH
70696: LD_INT 1
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 1
70705: NEG
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 1
70716: NEG
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: LD_INT 2
70732: NEG
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: LD_INT 0
70740: PUSH
70741: LD_INT 2
70743: NEG
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: PUSH
70752: LD_INT 1
70754: NEG
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 2
70762: PUSH
70763: LD_INT 1
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 2
70772: PUSH
70773: LD_INT 2
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 1
70782: PUSH
70783: LD_INT 2
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 0
70792: PUSH
70793: LD_INT 2
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: NEG
70803: PUSH
70804: LD_INT 1
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: NEG
70814: PUSH
70815: LD_INT 1
70817: NEG
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 2
70825: NEG
70826: PUSH
70827: LD_INT 2
70829: NEG
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 2
70837: NEG
70838: PUSH
70839: LD_INT 3
70841: NEG
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: LD_INT 3
70853: NEG
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PUSH
70859: LD_INT 0
70861: PUSH
70862: LD_INT 3
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 1
70872: PUSH
70873: LD_INT 2
70875: NEG
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 3
70883: PUSH
70884: LD_INT 2
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 3
70893: PUSH
70894: LD_INT 3
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 2
70903: PUSH
70904: LD_INT 3
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 1
70913: PUSH
70914: LD_INT 3
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 0
70923: PUSH
70924: LD_INT 3
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 1
70933: NEG
70934: PUSH
70935: LD_INT 2
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 3
70944: NEG
70945: PUSH
70946: LD_INT 2
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 3
70956: NEG
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70997: LD_ADDR_VAR 0 46
71001: PUSH
71002: LD_INT 0
71004: PUSH
71005: LD_INT 0
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: LD_INT 1
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 1
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 1
71035: PUSH
71036: LD_INT 1
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 1
71055: NEG
71056: PUSH
71057: LD_INT 0
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: LD_INT 1
71070: NEG
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: PUSH
71076: LD_INT 1
71078: NEG
71079: PUSH
71080: LD_INT 2
71082: NEG
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: LD_INT 2
71093: NEG
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 1
71101: PUSH
71102: LD_INT 1
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 2
71112: PUSH
71113: LD_INT 0
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 2
71122: PUSH
71123: LD_INT 1
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 1
71132: PUSH
71133: LD_INT 2
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 0
71142: PUSH
71143: LD_INT 2
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 1
71152: NEG
71153: PUSH
71154: LD_INT 1
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 2
71163: NEG
71164: PUSH
71165: LD_INT 0
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 2
71174: NEG
71175: PUSH
71176: LD_INT 1
71178: NEG
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 1
71186: NEG
71187: PUSH
71188: LD_INT 3
71190: NEG
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 0
71198: PUSH
71199: LD_INT 3
71201: NEG
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 1
71209: PUSH
71210: LD_INT 2
71212: NEG
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 2
71220: PUSH
71221: LD_INT 1
71223: NEG
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 3
71231: PUSH
71232: LD_INT 0
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 3
71241: PUSH
71242: LD_INT 1
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 1
71251: PUSH
71252: LD_INT 3
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: LD_INT 3
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 1
71271: NEG
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 2
71282: NEG
71283: PUSH
71284: LD_INT 1
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 3
71293: NEG
71294: PUSH
71295: LD_INT 0
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 3
71304: NEG
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71345: LD_ADDR_VAR 0 47
71349: PUSH
71350: LD_INT 0
71352: PUSH
71353: LD_INT 0
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 0
71362: PUSH
71363: LD_INT 1
71365: NEG
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PUSH
71371: LD_INT 1
71373: PUSH
71374: LD_INT 0
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 1
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: LD_INT 1
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 1
71403: NEG
71404: PUSH
71405: LD_INT 0
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: NEG
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 1
71426: NEG
71427: PUSH
71428: LD_INT 2
71430: NEG
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: LD_INT 2
71441: NEG
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: LD_INT 1
71452: NEG
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 2
71460: NEG
71461: PUSH
71462: LD_INT 1
71464: NEG
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PUSH
71470: LD_INT 2
71472: NEG
71473: PUSH
71474: LD_INT 2
71476: NEG
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71496: LD_ADDR_VAR 0 48
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: LD_INT 0
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 0
71513: PUSH
71514: LD_INT 1
71516: NEG
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 1
71524: PUSH
71525: LD_INT 0
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: LD_INT 1
71534: PUSH
71535: LD_INT 1
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 0
71544: PUSH
71545: LD_INT 1
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: NEG
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: LD_INT 1
71569: NEG
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 1
71577: NEG
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 0
71589: PUSH
71590: LD_INT 2
71592: NEG
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 1
71600: PUSH
71601: LD_INT 1
71603: NEG
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 2
71611: PUSH
71612: LD_INT 0
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 2
71621: PUSH
71622: LD_INT 1
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71643: LD_ADDR_VAR 0 49
71647: PUSH
71648: LD_INT 0
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 1
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 1
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: LD_INT 1
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: PUSH
71725: LD_INT 1
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 2
71735: PUSH
71736: LD_INT 0
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 2
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 2
71755: PUSH
71756: LD_INT 2
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 2
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71787: LD_ADDR_VAR 0 50
71791: PUSH
71792: LD_INT 0
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: LD_INT 0
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 1
71825: PUSH
71826: LD_INT 1
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: LD_INT 0
71835: PUSH
71836: LD_INT 1
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: NEG
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: LD_INT 1
71860: NEG
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: LD_INT 2
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 2
71878: PUSH
71879: LD_INT 2
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: LD_INT 1
71888: PUSH
71889: LD_INT 2
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 2
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: LD_INT 1
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71931: LD_ADDR_VAR 0 51
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 0
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 1
71959: PUSH
71960: LD_INT 0
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 0
71979: PUSH
71980: LD_INT 1
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 1
71989: NEG
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: LD_INT 1
72004: NEG
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 1
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: LD_INT 1
72032: NEG
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 2
72043: NEG
72044: PUSH
72045: LD_INT 0
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 2
72054: NEG
72055: PUSH
72056: LD_INT 1
72058: NEG
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72078: LD_ADDR_VAR 0 52
72082: PUSH
72083: LD_INT 0
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 0
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 1
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 1
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 1
72136: NEG
72137: PUSH
72138: LD_INT 0
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: LD_INT 1
72151: NEG
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: NEG
72160: PUSH
72161: LD_INT 2
72163: NEG
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: NEG
72172: PUSH
72173: LD_INT 1
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 2
72182: NEG
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 2
72193: NEG
72194: PUSH
72195: LD_INT 1
72197: NEG
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 2
72205: NEG
72206: PUSH
72207: LD_INT 2
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72229: LD_ADDR_VAR 0 53
72233: PUSH
72234: LD_INT 0
72236: PUSH
72237: LD_INT 0
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 0
72246: PUSH
72247: LD_INT 1
72249: NEG
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 1
72257: PUSH
72258: LD_INT 0
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 1
72267: PUSH
72268: LD_INT 1
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 0
72277: PUSH
72278: LD_INT 1
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: LD_INT 0
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: LD_INT 1
72302: NEG
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 1
72310: NEG
72311: PUSH
72312: LD_INT 2
72314: NEG
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: LD_INT 2
72325: NEG
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 1
72333: PUSH
72334: LD_INT 1
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 2
72344: PUSH
72345: LD_INT 0
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 2
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 2
72364: PUSH
72365: LD_INT 2
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 1
72374: PUSH
72375: LD_INT 2
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: PUSH
72382: LD_INT 0
72384: PUSH
72385: LD_INT 2
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 1
72394: NEG
72395: PUSH
72396: LD_INT 1
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 2
72405: NEG
72406: PUSH
72407: LD_INT 0
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 2
72416: NEG
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 2
72428: NEG
72429: PUSH
72430: LD_INT 2
72432: NEG
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72459: LD_ADDR_VAR 0 54
72463: PUSH
72464: LD_INT 0
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 0
72476: PUSH
72477: LD_INT 1
72479: NEG
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: LD_INT 1
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 1
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 0
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: NEG
72518: PUSH
72519: LD_INT 0
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: LD_INT 1
72532: NEG
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: LD_INT 2
72544: NEG
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 2
72555: NEG
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: LD_INT 1
72566: NEG
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 2
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 2
72584: PUSH
72585: LD_INT 1
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 1
72604: PUSH
72605: LD_INT 2
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 0
72614: PUSH
72615: LD_INT 2
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 1
72624: NEG
72625: PUSH
72626: LD_INT 1
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 2
72635: NEG
72636: PUSH
72637: LD_INT 0
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: LD_INT 1
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 2
72658: NEG
72659: PUSH
72660: LD_INT 2
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72689: LD_ADDR_VAR 0 55
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 0
72706: PUSH
72707: LD_INT 1
72709: NEG
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 0
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 1
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 0
72737: PUSH
72738: LD_INT 1
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 1
72747: NEG
72748: PUSH
72749: LD_INT 0
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: NEG
72759: PUSH
72760: LD_INT 1
72762: NEG
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: LD_INT 2
72774: NEG
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 0
72782: PUSH
72783: LD_INT 2
72785: NEG
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 1
72793: PUSH
72794: LD_INT 1
72796: NEG
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 2
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 2
72814: PUSH
72815: LD_INT 1
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 2
72824: PUSH
72825: LD_INT 2
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: LD_INT 2
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: LD_INT 0
72844: PUSH
72845: LD_INT 2
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 1
72854: NEG
72855: PUSH
72856: LD_INT 1
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 2
72865: NEG
72866: PUSH
72867: LD_INT 0
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 2
72876: NEG
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 2
72888: NEG
72889: PUSH
72890: LD_INT 2
72892: NEG
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72919: LD_ADDR_VAR 0 56
72923: PUSH
72924: LD_INT 0
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: LD_INT 1
72939: NEG
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 1
72947: PUSH
72948: LD_INT 0
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 1
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: LD_INT 1
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 1
72977: NEG
72978: PUSH
72979: LD_INT 0
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 1
72988: NEG
72989: PUSH
72990: LD_INT 1
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 1
73000: NEG
73001: PUSH
73002: LD_INT 2
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 0
73012: PUSH
73013: LD_INT 2
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 1
73023: PUSH
73024: LD_INT 1
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 2
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 2
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 2
73054: PUSH
73055: LD_INT 2
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: LD_INT 2
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 0
73074: PUSH
73075: LD_INT 2
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 1
73084: NEG
73085: PUSH
73086: LD_INT 1
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 2
73095: NEG
73096: PUSH
73097: LD_INT 0
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 2
73106: NEG
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: NEG
73119: PUSH
73120: LD_INT 2
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73149: LD_ADDR_VAR 0 57
73153: PUSH
73154: LD_INT 0
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 0
73166: PUSH
73167: LD_INT 1
73169: NEG
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PUSH
73175: LD_INT 1
73177: PUSH
73178: LD_INT 0
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 1
73187: PUSH
73188: LD_INT 1
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 0
73197: PUSH
73198: LD_INT 1
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 1
73207: NEG
73208: PUSH
73209: LD_INT 0
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: LD_INT 1
73222: NEG
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 1
73230: NEG
73231: PUSH
73232: LD_INT 2
73234: NEG
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: LD_INT 2
73245: NEG
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 1
73253: PUSH
73254: LD_INT 1
73256: NEG
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 2
73264: PUSH
73265: LD_INT 0
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 2
73274: PUSH
73275: LD_INT 1
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: LD_INT 2
73284: PUSH
73285: LD_INT 2
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 1
73294: PUSH
73295: LD_INT 2
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 2
73325: NEG
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 2
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 2
73348: NEG
73349: PUSH
73350: LD_INT 2
73352: NEG
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73379: LD_ADDR_VAR 0 58
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 0
73396: PUSH
73397: LD_INT 1
73399: NEG
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 1
73407: PUSH
73408: LD_INT 0
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: LD_INT 1
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 0
73427: PUSH
73428: LD_INT 1
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PUSH
73435: LD_INT 1
73437: NEG
73438: PUSH
73439: LD_INT 0
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 1
73448: NEG
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 1
73460: NEG
73461: PUSH
73462: LD_INT 2
73464: NEG
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 0
73472: PUSH
73473: LD_INT 2
73475: NEG
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 1
73486: NEG
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 2
73494: PUSH
73495: LD_INT 0
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 2
73504: PUSH
73505: LD_INT 1
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: LD_INT 2
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: PUSH
73525: LD_INT 2
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 0
73534: PUSH
73535: LD_INT 2
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 1
73544: NEG
73545: PUSH
73546: LD_INT 1
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 2
73555: NEG
73556: PUSH
73557: LD_INT 0
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 2
73566: NEG
73567: PUSH
73568: LD_INT 1
73570: NEG
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 2
73578: NEG
73579: PUSH
73580: LD_INT 2
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73609: LD_ADDR_VAR 0 59
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 0
73626: PUSH
73627: LD_INT 1
73629: NEG
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: PUSH
73635: LD_INT 1
73637: PUSH
73638: LD_INT 0
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: LD_INT 1
73647: PUSH
73648: LD_INT 1
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 0
73657: PUSH
73658: LD_INT 1
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 1
73667: NEG
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 1
73678: NEG
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: LIST
73694: LIST
73695: LIST
73696: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73697: LD_ADDR_VAR 0 60
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 0
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 1
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 1
73735: PUSH
73736: LD_INT 1
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 0
73745: PUSH
73746: LD_INT 1
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 1
73766: NEG
73767: PUSH
73768: LD_INT 1
73770: NEG
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: LIST
73784: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73785: LD_ADDR_VAR 0 61
73789: PUSH
73790: LD_INT 0
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 0
73802: PUSH
73803: LD_INT 1
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 1
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: LD_INT 1
73823: PUSH
73824: LD_INT 1
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 0
73833: PUSH
73834: LD_INT 1
73836: PUSH
73837: EMPTY
73838: LIST
73839: LIST
73840: PUSH
73841: LD_INT 1
73843: NEG
73844: PUSH
73845: LD_INT 0
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 1
73854: NEG
73855: PUSH
73856: LD_INT 1
73858: NEG
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73873: LD_ADDR_VAR 0 62
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: LD_INT 0
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 0
73890: PUSH
73891: LD_INT 1
73893: NEG
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 1
73911: PUSH
73912: LD_INT 1
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: LD_INT 1
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 1
73931: NEG
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 1
73942: NEG
73943: PUSH
73944: LD_INT 1
73946: NEG
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73961: LD_ADDR_VAR 0 63
73965: PUSH
73966: LD_INT 0
73968: PUSH
73969: LD_INT 0
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 0
73978: PUSH
73979: LD_INT 1
73981: NEG
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 1
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: LD_INT 1
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: LD_INT 1
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 1
74030: NEG
74031: PUSH
74032: LD_INT 1
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74049: LD_ADDR_VAR 0 64
74053: PUSH
74054: LD_INT 0
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: LD_INT 1
74069: NEG
74070: PUSH
74071: EMPTY
74072: LIST
74073: LIST
74074: PUSH
74075: LD_INT 1
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 1
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 0
74097: PUSH
74098: LD_INT 1
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 1
74107: NEG
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 1
74118: NEG
74119: PUSH
74120: LD_INT 1
74122: NEG
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: ST_TO_ADDR
// end ; 1 :
74137: GO 80034
74139: LD_INT 1
74141: DOUBLE
74142: EQUAL
74143: IFTRUE 74147
74145: GO 76770
74147: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74148: LD_ADDR_VAR 0 11
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: LD_INT 3
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: LD_INT 3
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: PUSH
74179: LD_INT 2
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: LIST
74191: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74192: LD_ADDR_VAR 0 12
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: LD_INT 1
74202: NEG
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 3
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 3
74220: PUSH
74221: LD_INT 1
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: LIST
74232: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74233: LD_ADDR_VAR 0 13
74237: PUSH
74238: LD_INT 3
74240: PUSH
74241: LD_INT 2
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 3
74250: PUSH
74251: LD_INT 3
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 2
74260: PUSH
74261: LD_INT 3
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: LIST
74272: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74273: LD_ADDR_VAR 0 14
74277: PUSH
74278: LD_INT 1
74280: PUSH
74281: LD_INT 3
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: PUSH
74288: LD_INT 0
74290: PUSH
74291: LD_INT 3
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: NEG
74301: PUSH
74302: LD_INT 2
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: LIST
74313: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74314: LD_ADDR_VAR 0 15
74318: PUSH
74319: LD_INT 2
74321: NEG
74322: PUSH
74323: LD_INT 1
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 3
74332: NEG
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 3
74343: NEG
74344: PUSH
74345: LD_INT 1
74347: NEG
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: LIST
74357: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74358: LD_ADDR_VAR 0 16
74362: PUSH
74363: LD_INT 2
74365: NEG
74366: PUSH
74367: LD_INT 3
74369: NEG
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 3
74377: NEG
74378: PUSH
74379: LD_INT 2
74381: NEG
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 3
74389: NEG
74390: PUSH
74391: LD_INT 3
74393: NEG
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: LIST
74403: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74404: LD_ADDR_VAR 0 17
74408: PUSH
74409: LD_INT 1
74411: NEG
74412: PUSH
74413: LD_INT 3
74415: NEG
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 0
74423: PUSH
74424: LD_INT 3
74426: NEG
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: LD_INT 2
74437: NEG
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: LIST
74447: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74448: LD_ADDR_VAR 0 18
74452: PUSH
74453: LD_INT 2
74455: PUSH
74456: LD_INT 1
74458: NEG
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 3
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 3
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: LIST
74488: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74489: LD_ADDR_VAR 0 19
74493: PUSH
74494: LD_INT 3
74496: PUSH
74497: LD_INT 2
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: LD_INT 3
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 2
74516: PUSH
74517: LD_INT 3
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: LIST
74528: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74529: LD_ADDR_VAR 0 20
74533: PUSH
74534: LD_INT 1
74536: PUSH
74537: LD_INT 3
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 0
74546: PUSH
74547: LD_INT 3
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: LD_INT 2
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: LIST
74569: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74570: LD_ADDR_VAR 0 21
74574: PUSH
74575: LD_INT 2
74577: NEG
74578: PUSH
74579: LD_INT 1
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: LD_INT 3
74588: NEG
74589: PUSH
74590: LD_INT 0
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 3
74599: NEG
74600: PUSH
74601: LD_INT 1
74603: NEG
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: LIST
74613: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74614: LD_ADDR_VAR 0 22
74618: PUSH
74619: LD_INT 2
74621: NEG
74622: PUSH
74623: LD_INT 3
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 3
74633: NEG
74634: PUSH
74635: LD_INT 2
74637: NEG
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 3
74645: NEG
74646: PUSH
74647: LD_INT 3
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: LIST
74659: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74660: LD_ADDR_VAR 0 23
74664: PUSH
74665: LD_INT 0
74667: PUSH
74668: LD_INT 3
74670: NEG
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 1
74678: NEG
74679: PUSH
74680: LD_INT 4
74682: NEG
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: LD_INT 3
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: LIST
74703: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74704: LD_ADDR_VAR 0 24
74708: PUSH
74709: LD_INT 3
74711: PUSH
74712: LD_INT 0
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 3
74721: PUSH
74722: LD_INT 1
74724: NEG
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 4
74732: PUSH
74733: LD_INT 1
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: LIST
74744: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74745: LD_ADDR_VAR 0 25
74749: PUSH
74750: LD_INT 3
74752: PUSH
74753: LD_INT 3
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 4
74762: PUSH
74763: LD_INT 3
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: PUSH
74770: LD_INT 3
74772: PUSH
74773: LD_INT 4
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: LIST
74784: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74785: LD_ADDR_VAR 0 26
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: LD_INT 3
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: LD_INT 4
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: LD_INT 3
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: LIST
74825: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74826: LD_ADDR_VAR 0 27
74830: PUSH
74831: LD_INT 3
74833: NEG
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 3
74844: NEG
74845: PUSH
74846: LD_INT 1
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 4
74855: NEG
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: LIST
74869: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74870: LD_ADDR_VAR 0 28
74874: PUSH
74875: LD_INT 3
74877: NEG
74878: PUSH
74879: LD_INT 3
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 3
74889: NEG
74890: PUSH
74891: LD_INT 4
74893: NEG
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 4
74901: NEG
74902: PUSH
74903: LD_INT 3
74905: NEG
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: LIST
74915: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74916: LD_ADDR_VAR 0 29
74920: PUSH
74921: LD_INT 1
74923: NEG
74924: PUSH
74925: LD_INT 3
74927: NEG
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: LD_INT 3
74938: NEG
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 1
74946: PUSH
74947: LD_INT 2
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: LD_INT 4
74961: NEG
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 0
74969: PUSH
74970: LD_INT 4
74972: NEG
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: LD_INT 3
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 1
74991: NEG
74992: PUSH
74993: LD_INT 5
74995: NEG
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 0
75003: PUSH
75004: LD_INT 5
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: LD_INT 4
75017: NEG
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 1
75025: NEG
75026: PUSH
75027: LD_INT 6
75029: NEG
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: LD_INT 6
75040: NEG
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 1
75048: PUSH
75049: LD_INT 5
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: LIST
75061: LIST
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75071: LD_ADDR_VAR 0 30
75075: PUSH
75076: LD_INT 2
75078: PUSH
75079: LD_INT 1
75081: NEG
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 3
75089: PUSH
75090: LD_INT 0
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 3
75099: PUSH
75100: LD_INT 1
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 3
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 4
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 4
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 4
75140: PUSH
75141: LD_INT 1
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 5
75151: PUSH
75152: LD_INT 0
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 5
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 5
75171: PUSH
75172: LD_INT 1
75174: NEG
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 6
75182: PUSH
75183: LD_INT 0
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 6
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75214: LD_ADDR_VAR 0 31
75218: PUSH
75219: LD_INT 3
75221: PUSH
75222: LD_INT 2
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 3
75231: PUSH
75232: LD_INT 3
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 2
75241: PUSH
75242: LD_INT 3
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 4
75251: PUSH
75252: LD_INT 3
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 4
75261: PUSH
75262: LD_INT 4
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 3
75271: PUSH
75272: LD_INT 4
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 5
75281: PUSH
75282: LD_INT 4
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 5
75291: PUSH
75292: LD_INT 5
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 4
75301: PUSH
75302: LD_INT 5
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 6
75311: PUSH
75312: LD_INT 5
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 6
75321: PUSH
75322: LD_INT 6
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 5
75331: PUSH
75332: LD_INT 6
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75353: LD_ADDR_VAR 0 32
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: LD_INT 3
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: LD_INT 3
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: NEG
75381: PUSH
75382: LD_INT 2
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: LD_INT 4
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: LD_INT 4
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: LD_INT 3
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: LD_INT 5
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: LD_INT 5
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 4
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 1
75453: PUSH
75454: LD_INT 6
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 0
75463: PUSH
75464: LD_INT 6
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 1
75473: NEG
75474: PUSH
75475: LD_INT 5
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75496: LD_ADDR_VAR 0 33
75500: PUSH
75501: LD_INT 2
75503: NEG
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 3
75514: NEG
75515: PUSH
75516: LD_INT 0
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 3
75525: NEG
75526: PUSH
75527: LD_INT 1
75529: NEG
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 3
75537: NEG
75538: PUSH
75539: LD_INT 1
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 4
75548: NEG
75549: PUSH
75550: LD_INT 0
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 4
75559: NEG
75560: PUSH
75561: LD_INT 1
75563: NEG
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 4
75571: NEG
75572: PUSH
75573: LD_INT 1
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 5
75582: NEG
75583: PUSH
75584: LD_INT 0
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 5
75593: NEG
75594: PUSH
75595: LD_INT 1
75597: NEG
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 5
75605: NEG
75606: PUSH
75607: LD_INT 1
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 6
75616: NEG
75617: PUSH
75618: LD_INT 0
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 6
75627: NEG
75628: PUSH
75629: LD_INT 1
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75651: LD_ADDR_VAR 0 34
75655: PUSH
75656: LD_INT 2
75658: NEG
75659: PUSH
75660: LD_INT 3
75662: NEG
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 3
75670: NEG
75671: PUSH
75672: LD_INT 2
75674: NEG
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 3
75682: NEG
75683: PUSH
75684: LD_INT 3
75686: NEG
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 3
75694: NEG
75695: PUSH
75696: LD_INT 4
75698: NEG
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 4
75706: NEG
75707: PUSH
75708: LD_INT 3
75710: NEG
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 4
75718: NEG
75719: PUSH
75720: LD_INT 4
75722: NEG
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 4
75730: NEG
75731: PUSH
75732: LD_INT 5
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 5
75742: NEG
75743: PUSH
75744: LD_INT 4
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 5
75754: NEG
75755: PUSH
75756: LD_INT 5
75758: NEG
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 5
75766: NEG
75767: PUSH
75768: LD_INT 6
75770: NEG
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 6
75778: NEG
75779: PUSH
75780: LD_INT 5
75782: NEG
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 6
75790: NEG
75791: PUSH
75792: LD_INT 6
75794: NEG
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75814: LD_ADDR_VAR 0 41
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 2
75824: NEG
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: LD_INT 3
75836: NEG
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: LD_INT 2
75847: NEG
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: LIST
75857: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75858: LD_ADDR_VAR 0 42
75862: PUSH
75863: LD_INT 2
75865: PUSH
75866: LD_INT 0
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 2
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 3
75886: PUSH
75887: LD_INT 1
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: LIST
75898: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75899: LD_ADDR_VAR 0 43
75903: PUSH
75904: LD_INT 2
75906: PUSH
75907: LD_INT 2
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 3
75916: PUSH
75917: LD_INT 2
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 2
75926: PUSH
75927: LD_INT 3
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: LIST
75938: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75939: LD_ADDR_VAR 0 44
75943: PUSH
75944: LD_INT 0
75946: PUSH
75947: LD_INT 2
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 1
75956: PUSH
75957: LD_INT 3
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: LD_INT 1
75966: NEG
75967: PUSH
75968: LD_INT 2
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: LIST
75979: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75980: LD_ADDR_VAR 0 45
75984: PUSH
75985: LD_INT 2
75987: NEG
75988: PUSH
75989: LD_INT 0
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: PUSH
75996: LD_INT 2
75998: NEG
75999: PUSH
76000: LD_INT 1
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 3
76009: NEG
76010: PUSH
76011: LD_INT 1
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: LIST
76023: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76024: LD_ADDR_VAR 0 46
76028: PUSH
76029: LD_INT 2
76031: NEG
76032: PUSH
76033: LD_INT 2
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 2
76043: NEG
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 3
76055: NEG
76056: PUSH
76057: LD_INT 2
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: LIST
76069: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76070: LD_ADDR_VAR 0 47
76074: PUSH
76075: LD_INT 2
76077: NEG
76078: PUSH
76079: LD_INT 3
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: LD_INT 3
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76103: LD_ADDR_VAR 0 48
76107: PUSH
76108: LD_INT 1
76110: PUSH
76111: LD_INT 2
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 2
76121: PUSH
76122: LD_INT 1
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76134: LD_ADDR_VAR 0 49
76138: PUSH
76139: LD_INT 3
76141: PUSH
76142: LD_INT 1
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 3
76151: PUSH
76152: LD_INT 2
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76163: LD_ADDR_VAR 0 50
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: LD_INT 3
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 1
76180: PUSH
76181: LD_INT 3
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76192: LD_ADDR_VAR 0 51
76196: PUSH
76197: LD_INT 1
76199: NEG
76200: PUSH
76201: LD_INT 2
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 2
76210: NEG
76211: PUSH
76212: LD_INT 1
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76223: LD_ADDR_VAR 0 52
76227: PUSH
76228: LD_INT 3
76230: NEG
76231: PUSH
76232: LD_INT 1
76234: NEG
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 3
76242: NEG
76243: PUSH
76244: LD_INT 2
76246: NEG
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76256: LD_ADDR_VAR 0 53
76260: PUSH
76261: LD_INT 1
76263: NEG
76264: PUSH
76265: LD_INT 3
76267: NEG
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 0
76275: PUSH
76276: LD_INT 3
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 1
76286: PUSH
76287: LD_INT 2
76289: NEG
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: LIST
76299: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76300: LD_ADDR_VAR 0 54
76304: PUSH
76305: LD_INT 2
76307: PUSH
76308: LD_INT 1
76310: NEG
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 3
76318: PUSH
76319: LD_INT 0
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 3
76328: PUSH
76329: LD_INT 1
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: LIST
76340: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76341: LD_ADDR_VAR 0 55
76345: PUSH
76346: LD_INT 3
76348: PUSH
76349: LD_INT 2
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 3
76358: PUSH
76359: LD_INT 3
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 2
76368: PUSH
76369: LD_INT 3
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: LIST
76380: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76381: LD_ADDR_VAR 0 56
76385: PUSH
76386: LD_INT 1
76388: PUSH
76389: LD_INT 3
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 0
76398: PUSH
76399: LD_INT 3
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: NEG
76409: PUSH
76410: LD_INT 2
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: LIST
76421: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76422: LD_ADDR_VAR 0 57
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: LD_INT 1
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 3
76440: NEG
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 3
76451: NEG
76452: PUSH
76453: LD_INT 1
76455: NEG
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: LIST
76465: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76466: LD_ADDR_VAR 0 58
76470: PUSH
76471: LD_INT 2
76473: NEG
76474: PUSH
76475: LD_INT 3
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 3
76485: NEG
76486: PUSH
76487: LD_INT 2
76489: NEG
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 3
76497: NEG
76498: PUSH
76499: LD_INT 3
76501: NEG
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: LIST
76511: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76512: LD_ADDR_VAR 0 59
76516: PUSH
76517: LD_INT 1
76519: NEG
76520: PUSH
76521: LD_INT 2
76523: NEG
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 0
76531: PUSH
76532: LD_INT 2
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: PUSH
76543: LD_INT 1
76545: NEG
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: LIST
76555: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76556: LD_ADDR_VAR 0 60
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 1
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 2
76584: PUSH
76585: LD_INT 1
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: LIST
76596: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76597: LD_ADDR_VAR 0 61
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: LD_INT 1
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: LD_INT 2
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: PUSH
76625: LD_INT 2
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: LIST
76636: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76637: LD_ADDR_VAR 0 62
76641: PUSH
76642: LD_INT 1
76644: PUSH
76645: LD_INT 2
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 0
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 1
76664: NEG
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: LIST
76677: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76678: LD_ADDR_VAR 0 63
76682: PUSH
76683: LD_INT 1
76685: NEG
76686: PUSH
76687: LD_INT 1
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 2
76696: NEG
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 2
76707: NEG
76708: PUSH
76709: LD_INT 1
76711: NEG
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: LIST
76721: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76722: LD_ADDR_VAR 0 64
76726: PUSH
76727: LD_INT 1
76729: NEG
76730: PUSH
76731: LD_INT 2
76733: NEG
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 2
76741: NEG
76742: PUSH
76743: LD_INT 1
76745: NEG
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 2
76753: NEG
76754: PUSH
76755: LD_INT 2
76757: NEG
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: LIST
76767: ST_TO_ADDR
// end ; 2 :
76768: GO 80034
76770: LD_INT 2
76772: DOUBLE
76773: EQUAL
76774: IFTRUE 76778
76776: GO 80033
76778: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76779: LD_ADDR_VAR 0 29
76783: PUSH
76784: LD_INT 4
76786: PUSH
76787: LD_INT 0
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 4
76796: PUSH
76797: LD_INT 1
76799: NEG
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 5
76807: PUSH
76808: LD_INT 0
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 5
76817: PUSH
76818: LD_INT 1
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 4
76827: PUSH
76828: LD_INT 1
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 3
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 3
76847: PUSH
76848: LD_INT 1
76850: NEG
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: LD_INT 3
76858: PUSH
76859: LD_INT 2
76861: NEG
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 5
76869: PUSH
76870: LD_INT 2
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 3
76879: PUSH
76880: LD_INT 3
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 3
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 4
76899: PUSH
76900: LD_INT 3
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 4
76909: PUSH
76910: LD_INT 4
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 3
76919: PUSH
76920: LD_INT 4
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 2
76929: PUSH
76930: LD_INT 3
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 2
76939: PUSH
76940: LD_INT 2
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 4
76949: PUSH
76950: LD_INT 2
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 2
76959: PUSH
76960: LD_INT 4
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: LD_INT 4
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 0
76979: PUSH
76980: LD_INT 3
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 1
76989: PUSH
76990: LD_INT 4
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: LD_INT 5
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 0
77009: PUSH
77010: LD_INT 5
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 1
77019: NEG
77020: PUSH
77021: LD_INT 4
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: NEG
77031: PUSH
77032: LD_INT 3
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 2
77041: PUSH
77042: LD_INT 5
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 2
77051: NEG
77052: PUSH
77053: LD_INT 3
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 3
77062: NEG
77063: PUSH
77064: LD_INT 0
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 3
77073: NEG
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 2
77085: NEG
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 2
77096: NEG
77097: PUSH
77098: LD_INT 1
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 3
77107: NEG
77108: PUSH
77109: LD_INT 1
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 4
77118: NEG
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 4
77129: NEG
77130: PUSH
77131: LD_INT 1
77133: NEG
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 4
77141: NEG
77142: PUSH
77143: LD_INT 2
77145: NEG
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 2
77153: NEG
77154: PUSH
77155: LD_INT 2
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 4
77164: NEG
77165: PUSH
77166: LD_INT 4
77168: NEG
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 4
77176: NEG
77177: PUSH
77178: LD_INT 5
77180: NEG
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 3
77188: NEG
77189: PUSH
77190: LD_INT 4
77192: NEG
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 3
77200: NEG
77201: PUSH
77202: LD_INT 3
77204: NEG
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 4
77212: NEG
77213: PUSH
77214: LD_INT 3
77216: NEG
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 5
77224: NEG
77225: PUSH
77226: LD_INT 4
77228: NEG
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 5
77236: NEG
77237: PUSH
77238: LD_INT 5
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 3
77248: NEG
77249: PUSH
77250: LD_INT 5
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 5
77260: NEG
77261: PUSH
77262: LD_INT 3
77264: NEG
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77317: LD_ADDR_VAR 0 30
77321: PUSH
77322: LD_INT 4
77324: PUSH
77325: LD_INT 4
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 4
77334: PUSH
77335: LD_INT 3
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 5
77344: PUSH
77345: LD_INT 4
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 5
77354: PUSH
77355: LD_INT 5
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 4
77364: PUSH
77365: LD_INT 5
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 3
77374: PUSH
77375: LD_INT 4
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 3
77384: PUSH
77385: LD_INT 3
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: PUSH
77392: LD_INT 5
77394: PUSH
77395: LD_INT 3
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 3
77404: PUSH
77405: LD_INT 5
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: LD_INT 3
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 0
77424: PUSH
77425: LD_INT 2
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 1
77434: PUSH
77435: LD_INT 3
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 1
77444: PUSH
77445: LD_INT 4
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 0
77454: PUSH
77455: LD_INT 4
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 1
77464: NEG
77465: PUSH
77466: LD_INT 3
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 1
77475: NEG
77476: PUSH
77477: LD_INT 2
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 2
77486: PUSH
77487: LD_INT 4
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 2
77496: NEG
77497: PUSH
77498: LD_INT 2
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 4
77507: NEG
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 4
77518: NEG
77519: PUSH
77520: LD_INT 1
77522: NEG
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 3
77530: NEG
77531: PUSH
77532: LD_INT 0
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 3
77541: NEG
77542: PUSH
77543: LD_INT 1
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 4
77552: NEG
77553: PUSH
77554: LD_INT 1
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 5
77563: NEG
77564: PUSH
77565: LD_INT 0
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: LD_INT 5
77574: NEG
77575: PUSH
77576: LD_INT 1
77578: NEG
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 5
77586: NEG
77587: PUSH
77588: LD_INT 2
77590: NEG
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: PUSH
77596: LD_INT 3
77598: NEG
77599: PUSH
77600: LD_INT 2
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 3
77609: NEG
77610: PUSH
77611: LD_INT 3
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 3
77621: NEG
77622: PUSH
77623: LD_INT 4
77625: NEG
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 2
77633: NEG
77634: PUSH
77635: LD_INT 3
77637: NEG
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 2
77645: NEG
77646: PUSH
77647: LD_INT 2
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 3
77657: NEG
77658: PUSH
77659: LD_INT 2
77661: NEG
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 4
77669: NEG
77670: PUSH
77671: LD_INT 3
77673: NEG
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 4
77681: NEG
77682: PUSH
77683: LD_INT 4
77685: NEG
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 2
77693: NEG
77694: PUSH
77695: LD_INT 4
77697: NEG
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 4
77705: NEG
77706: PUSH
77707: LD_INT 2
77709: NEG
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 0
77717: PUSH
77718: LD_INT 4
77720: NEG
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 0
77728: PUSH
77729: LD_INT 5
77731: NEG
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 1
77739: PUSH
77740: LD_INT 4
77742: NEG
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 1
77750: PUSH
77751: LD_INT 3
77753: NEG
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 0
77761: PUSH
77762: LD_INT 3
77764: NEG
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 1
77772: NEG
77773: PUSH
77774: LD_INT 4
77776: NEG
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 1
77784: NEG
77785: PUSH
77786: LD_INT 5
77788: NEG
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 2
77796: PUSH
77797: LD_INT 3
77799: NEG
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 2
77807: NEG
77808: PUSH
77809: LD_INT 5
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: LIST
77861: LIST
77862: LIST
77863: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77864: LD_ADDR_VAR 0 31
77868: PUSH
77869: LD_INT 0
77871: PUSH
77872: LD_INT 4
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 0
77881: PUSH
77882: LD_INT 3
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 1
77891: PUSH
77892: LD_INT 4
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 1
77901: PUSH
77902: LD_INT 5
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: LD_INT 5
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: LD_INT 4
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 1
77932: NEG
77933: PUSH
77934: LD_INT 3
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: LD_INT 5
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 2
77953: NEG
77954: PUSH
77955: LD_INT 3
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 3
77964: NEG
77965: PUSH
77966: LD_INT 0
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 3
77975: NEG
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 2
77987: NEG
77988: PUSH
77989: LD_INT 0
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 2
77998: NEG
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: LD_INT 3
78009: NEG
78010: PUSH
78011: LD_INT 1
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 4
78020: NEG
78021: PUSH
78022: LD_INT 0
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 4
78031: NEG
78032: PUSH
78033: LD_INT 1
78035: NEG
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 4
78043: NEG
78044: PUSH
78045: LD_INT 2
78047: NEG
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 2
78055: NEG
78056: PUSH
78057: LD_INT 2
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 4
78066: NEG
78067: PUSH
78068: LD_INT 4
78070: NEG
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 4
78078: NEG
78079: PUSH
78080: LD_INT 5
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 3
78090: NEG
78091: PUSH
78092: LD_INT 4
78094: NEG
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 3
78102: NEG
78103: PUSH
78104: LD_INT 3
78106: NEG
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 4
78114: NEG
78115: PUSH
78116: LD_INT 3
78118: NEG
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 5
78126: NEG
78127: PUSH
78128: LD_INT 4
78130: NEG
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 5
78138: NEG
78139: PUSH
78140: LD_INT 5
78142: NEG
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 3
78150: NEG
78151: PUSH
78152: LD_INT 5
78154: NEG
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 5
78162: NEG
78163: PUSH
78164: LD_INT 3
78166: NEG
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: LD_INT 3
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 0
78185: PUSH
78186: LD_INT 4
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: LD_INT 3
78199: NEG
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 1
78207: PUSH
78208: LD_INT 2
78210: NEG
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 0
78218: PUSH
78219: LD_INT 2
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 1
78229: NEG
78230: PUSH
78231: LD_INT 3
78233: NEG
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: LD_INT 4
78245: NEG
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 2
78253: PUSH
78254: LD_INT 2
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 2
78264: NEG
78265: PUSH
78266: LD_INT 4
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 4
78276: PUSH
78277: LD_INT 0
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 4
78286: PUSH
78287: LD_INT 1
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 5
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 5
78307: PUSH
78308: LD_INT 1
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 4
78317: PUSH
78318: LD_INT 1
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 3
78327: PUSH
78328: LD_INT 0
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: LD_INT 1
78340: NEG
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: LD_INT 2
78351: NEG
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 5
78359: PUSH
78360: LD_INT 2
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: LIST
78390: LIST
78391: LIST
78392: LIST
78393: LIST
78394: LIST
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78414: LD_ADDR_VAR 0 32
78418: PUSH
78419: LD_INT 4
78421: NEG
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 3
78444: NEG
78445: PUSH
78446: LD_INT 0
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 3
78455: NEG
78456: PUSH
78457: LD_INT 1
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: LD_INT 4
78466: NEG
78467: PUSH
78468: LD_INT 1
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 5
78477: NEG
78478: PUSH
78479: LD_INT 0
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 5
78488: NEG
78489: PUSH
78490: LD_INT 1
78492: NEG
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 5
78500: NEG
78501: PUSH
78502: LD_INT 2
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 3
78512: NEG
78513: PUSH
78514: LD_INT 2
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 3
78523: NEG
78524: PUSH
78525: LD_INT 3
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 3
78535: NEG
78536: PUSH
78537: LD_INT 4
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 2
78547: NEG
78548: PUSH
78549: LD_INT 3
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 2
78559: NEG
78560: PUSH
78561: LD_INT 2
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 3
78571: NEG
78572: PUSH
78573: LD_INT 2
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 4
78583: NEG
78584: PUSH
78585: LD_INT 3
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 4
78595: NEG
78596: PUSH
78597: LD_INT 4
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 2
78607: NEG
78608: PUSH
78609: LD_INT 4
78611: NEG
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 4
78619: NEG
78620: PUSH
78621: LD_INT 2
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 0
78631: PUSH
78632: LD_INT 4
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 0
78642: PUSH
78643: LD_INT 5
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: LD_INT 4
78656: NEG
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 1
78664: PUSH
78665: LD_INT 3
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 0
78675: PUSH
78676: LD_INT 3
78678: NEG
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 1
78686: NEG
78687: PUSH
78688: LD_INT 4
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 1
78698: NEG
78699: PUSH
78700: LD_INT 5
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 2
78710: PUSH
78711: LD_INT 3
78713: NEG
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 2
78721: NEG
78722: PUSH
78723: LD_INT 5
78725: NEG
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 3
78733: PUSH
78734: LD_INT 0
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 3
78743: PUSH
78744: LD_INT 1
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 4
78754: PUSH
78755: LD_INT 0
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 4
78764: PUSH
78765: LD_INT 1
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: PUSH
78775: LD_INT 1
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 2
78784: PUSH
78785: LD_INT 0
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 2
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 2
78805: PUSH
78806: LD_INT 2
78808: NEG
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 4
78816: PUSH
78817: LD_INT 2
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: LD_INT 4
78826: PUSH
78827: LD_INT 4
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 4
78836: PUSH
78837: LD_INT 3
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 5
78846: PUSH
78847: LD_INT 4
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 5
78856: PUSH
78857: LD_INT 5
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 4
78866: PUSH
78867: LD_INT 5
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 3
78876: PUSH
78877: LD_INT 4
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 3
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: LD_INT 5
78896: PUSH
78897: LD_INT 3
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 3
78906: PUSH
78907: LD_INT 5
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: LIST
78946: LIST
78947: LIST
78948: LIST
78949: LIST
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78961: LD_ADDR_VAR 0 33
78965: PUSH
78966: LD_INT 4
78968: NEG
78969: PUSH
78970: LD_INT 4
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 4
78980: NEG
78981: PUSH
78982: LD_INT 5
78984: NEG
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 3
78992: NEG
78993: PUSH
78994: LD_INT 4
78996: NEG
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 3
79004: NEG
79005: PUSH
79006: LD_INT 3
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 4
79016: NEG
79017: PUSH
79018: LD_INT 3
79020: NEG
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 5
79028: NEG
79029: PUSH
79030: LD_INT 4
79032: NEG
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 5
79040: NEG
79041: PUSH
79042: LD_INT 5
79044: NEG
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 3
79052: NEG
79053: PUSH
79054: LD_INT 5
79056: NEG
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 5
79064: NEG
79065: PUSH
79066: LD_INT 3
79068: NEG
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 0
79076: PUSH
79077: LD_INT 3
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: LD_INT 4
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 1
79098: PUSH
79099: LD_INT 3
79101: NEG
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: LD_INT 2
79112: NEG
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: LD_INT 2
79123: NEG
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 1
79131: NEG
79132: PUSH
79133: LD_INT 3
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: LD_INT 4
79147: NEG
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 2
79155: PUSH
79156: LD_INT 2
79158: NEG
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 2
79166: NEG
79167: PUSH
79168: LD_INT 4
79170: NEG
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 4
79178: PUSH
79179: LD_INT 0
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 4
79188: PUSH
79189: LD_INT 1
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 5
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 5
79209: PUSH
79210: LD_INT 1
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 4
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 3
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 3
79239: PUSH
79240: LD_INT 1
79242: NEG
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 3
79250: PUSH
79251: LD_INT 2
79253: NEG
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 5
79261: PUSH
79262: LD_INT 2
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 3
79271: PUSH
79272: LD_INT 3
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 3
79281: PUSH
79282: LD_INT 2
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 4
79291: PUSH
79292: LD_INT 3
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 4
79301: PUSH
79302: LD_INT 4
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 3
79311: PUSH
79312: LD_INT 4
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 2
79321: PUSH
79322: LD_INT 3
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 2
79331: PUSH
79332: LD_INT 2
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 4
79341: PUSH
79342: LD_INT 2
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 2
79351: PUSH
79352: LD_INT 4
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: LD_INT 4
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: LD_INT 3
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 1
79381: PUSH
79382: LD_INT 4
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 1
79391: PUSH
79392: LD_INT 5
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 0
79401: PUSH
79402: LD_INT 5
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 1
79411: NEG
79412: PUSH
79413: LD_INT 4
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 1
79422: NEG
79423: PUSH
79424: LD_INT 3
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 2
79433: PUSH
79434: LD_INT 5
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: LD_INT 3
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79499: LD_ADDR_VAR 0 34
79503: PUSH
79504: LD_INT 0
79506: PUSH
79507: LD_INT 4
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: LD_INT 5
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 1
79528: PUSH
79529: LD_INT 4
79531: NEG
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 1
79539: PUSH
79540: LD_INT 3
79542: NEG
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: LD_INT 3
79553: NEG
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 1
79561: NEG
79562: PUSH
79563: LD_INT 4
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 1
79573: NEG
79574: PUSH
79575: LD_INT 5
79577: NEG
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 2
79585: PUSH
79586: LD_INT 3
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 2
79596: NEG
79597: PUSH
79598: LD_INT 5
79600: NEG
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 3
79608: PUSH
79609: LD_INT 0
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: LD_INT 1
79621: NEG
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 4
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 4
79639: PUSH
79640: LD_INT 1
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 3
79649: PUSH
79650: LD_INT 1
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 2
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 1
79672: NEG
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 2
79680: PUSH
79681: LD_INT 2
79683: NEG
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 4
79691: PUSH
79692: LD_INT 2
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 4
79701: PUSH
79702: LD_INT 4
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 4
79711: PUSH
79712: LD_INT 3
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 5
79721: PUSH
79722: LD_INT 4
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 5
79731: PUSH
79732: LD_INT 5
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 4
79741: PUSH
79742: LD_INT 5
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 3
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 3
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 5
79771: PUSH
79772: LD_INT 3
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 3
79781: PUSH
79782: LD_INT 5
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: LD_INT 3
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 0
79801: PUSH
79802: LD_INT 2
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 1
79811: PUSH
79812: LD_INT 3
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: LD_INT 4
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 0
79831: PUSH
79832: LD_INT 4
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 1
79841: NEG
79842: PUSH
79843: LD_INT 3
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: LD_INT 2
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: PUSH
79864: LD_INT 4
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: LD_INT 2
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 4
79884: NEG
79885: PUSH
79886: LD_INT 0
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 4
79895: NEG
79896: PUSH
79897: LD_INT 1
79899: NEG
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: LD_INT 3
79907: NEG
79908: PUSH
79909: LD_INT 0
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 3
79918: NEG
79919: PUSH
79920: LD_INT 1
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 4
79929: NEG
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 5
79940: NEG
79941: PUSH
79942: LD_INT 0
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 5
79951: NEG
79952: PUSH
79953: LD_INT 1
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 5
79963: NEG
79964: PUSH
79965: LD_INT 2
79967: NEG
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 3
79975: NEG
79976: PUSH
79977: LD_INT 2
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: ST_TO_ADDR
// end ; end ;
80031: GO 80034
80033: POP
// case btype of b_depot , b_warehouse :
80034: LD_VAR 0 1
80038: PUSH
80039: LD_INT 0
80041: DOUBLE
80042: EQUAL
80043: IFTRUE 80053
80045: LD_INT 1
80047: DOUBLE
80048: EQUAL
80049: IFTRUE 80053
80051: GO 80254
80053: POP
// case nation of nation_american :
80054: LD_VAR 0 5
80058: PUSH
80059: LD_INT 1
80061: DOUBLE
80062: EQUAL
80063: IFTRUE 80067
80065: GO 80123
80067: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80068: LD_ADDR_VAR 0 9
80072: PUSH
80073: LD_VAR 0 11
80077: PUSH
80078: LD_VAR 0 12
80082: PUSH
80083: LD_VAR 0 13
80087: PUSH
80088: LD_VAR 0 14
80092: PUSH
80093: LD_VAR 0 15
80097: PUSH
80098: LD_VAR 0 16
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: PUSH
80111: LD_VAR 0 4
80115: PUSH
80116: LD_INT 1
80118: PLUS
80119: ARRAY
80120: ST_TO_ADDR
80121: GO 80252
80123: LD_INT 2
80125: DOUBLE
80126: EQUAL
80127: IFTRUE 80131
80129: GO 80187
80131: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80132: LD_ADDR_VAR 0 9
80136: PUSH
80137: LD_VAR 0 17
80141: PUSH
80142: LD_VAR 0 18
80146: PUSH
80147: LD_VAR 0 19
80151: PUSH
80152: LD_VAR 0 20
80156: PUSH
80157: LD_VAR 0 21
80161: PUSH
80162: LD_VAR 0 22
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: PUSH
80175: LD_VAR 0 4
80179: PUSH
80180: LD_INT 1
80182: PLUS
80183: ARRAY
80184: ST_TO_ADDR
80185: GO 80252
80187: LD_INT 3
80189: DOUBLE
80190: EQUAL
80191: IFTRUE 80195
80193: GO 80251
80195: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80196: LD_ADDR_VAR 0 9
80200: PUSH
80201: LD_VAR 0 23
80205: PUSH
80206: LD_VAR 0 24
80210: PUSH
80211: LD_VAR 0 25
80215: PUSH
80216: LD_VAR 0 26
80220: PUSH
80221: LD_VAR 0 27
80225: PUSH
80226: LD_VAR 0 28
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: PUSH
80239: LD_VAR 0 4
80243: PUSH
80244: LD_INT 1
80246: PLUS
80247: ARRAY
80248: ST_TO_ADDR
80249: GO 80252
80251: POP
80252: GO 80807
80254: LD_INT 2
80256: DOUBLE
80257: EQUAL
80258: IFTRUE 80268
80260: LD_INT 3
80262: DOUBLE
80263: EQUAL
80264: IFTRUE 80268
80266: GO 80324
80268: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80269: LD_ADDR_VAR 0 9
80273: PUSH
80274: LD_VAR 0 29
80278: PUSH
80279: LD_VAR 0 30
80283: PUSH
80284: LD_VAR 0 31
80288: PUSH
80289: LD_VAR 0 32
80293: PUSH
80294: LD_VAR 0 33
80298: PUSH
80299: LD_VAR 0 34
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: PUSH
80312: LD_VAR 0 4
80316: PUSH
80317: LD_INT 1
80319: PLUS
80320: ARRAY
80321: ST_TO_ADDR
80322: GO 80807
80324: LD_INT 16
80326: DOUBLE
80327: EQUAL
80328: IFTRUE 80386
80330: LD_INT 17
80332: DOUBLE
80333: EQUAL
80334: IFTRUE 80386
80336: LD_INT 18
80338: DOUBLE
80339: EQUAL
80340: IFTRUE 80386
80342: LD_INT 19
80344: DOUBLE
80345: EQUAL
80346: IFTRUE 80386
80348: LD_INT 22
80350: DOUBLE
80351: EQUAL
80352: IFTRUE 80386
80354: LD_INT 20
80356: DOUBLE
80357: EQUAL
80358: IFTRUE 80386
80360: LD_INT 21
80362: DOUBLE
80363: EQUAL
80364: IFTRUE 80386
80366: LD_INT 23
80368: DOUBLE
80369: EQUAL
80370: IFTRUE 80386
80372: LD_INT 24
80374: DOUBLE
80375: EQUAL
80376: IFTRUE 80386
80378: LD_INT 25
80380: DOUBLE
80381: EQUAL
80382: IFTRUE 80386
80384: GO 80442
80386: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80387: LD_ADDR_VAR 0 9
80391: PUSH
80392: LD_VAR 0 35
80396: PUSH
80397: LD_VAR 0 36
80401: PUSH
80402: LD_VAR 0 37
80406: PUSH
80407: LD_VAR 0 38
80411: PUSH
80412: LD_VAR 0 39
80416: PUSH
80417: LD_VAR 0 40
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: PUSH
80430: LD_VAR 0 4
80434: PUSH
80435: LD_INT 1
80437: PLUS
80438: ARRAY
80439: ST_TO_ADDR
80440: GO 80807
80442: LD_INT 6
80444: DOUBLE
80445: EQUAL
80446: IFTRUE 80498
80448: LD_INT 7
80450: DOUBLE
80451: EQUAL
80452: IFTRUE 80498
80454: LD_INT 8
80456: DOUBLE
80457: EQUAL
80458: IFTRUE 80498
80460: LD_INT 13
80462: DOUBLE
80463: EQUAL
80464: IFTRUE 80498
80466: LD_INT 12
80468: DOUBLE
80469: EQUAL
80470: IFTRUE 80498
80472: LD_INT 15
80474: DOUBLE
80475: EQUAL
80476: IFTRUE 80498
80478: LD_INT 11
80480: DOUBLE
80481: EQUAL
80482: IFTRUE 80498
80484: LD_INT 14
80486: DOUBLE
80487: EQUAL
80488: IFTRUE 80498
80490: LD_INT 10
80492: DOUBLE
80493: EQUAL
80494: IFTRUE 80498
80496: GO 80554
80498: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80499: LD_ADDR_VAR 0 9
80503: PUSH
80504: LD_VAR 0 41
80508: PUSH
80509: LD_VAR 0 42
80513: PUSH
80514: LD_VAR 0 43
80518: PUSH
80519: LD_VAR 0 44
80523: PUSH
80524: LD_VAR 0 45
80528: PUSH
80529: LD_VAR 0 46
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: PUSH
80542: LD_VAR 0 4
80546: PUSH
80547: LD_INT 1
80549: PLUS
80550: ARRAY
80551: ST_TO_ADDR
80552: GO 80807
80554: LD_INT 36
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80562
80560: GO 80618
80562: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80563: LD_ADDR_VAR 0 9
80567: PUSH
80568: LD_VAR 0 47
80572: PUSH
80573: LD_VAR 0 48
80577: PUSH
80578: LD_VAR 0 49
80582: PUSH
80583: LD_VAR 0 50
80587: PUSH
80588: LD_VAR 0 51
80592: PUSH
80593: LD_VAR 0 52
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: PUSH
80606: LD_VAR 0 4
80610: PUSH
80611: LD_INT 1
80613: PLUS
80614: ARRAY
80615: ST_TO_ADDR
80616: GO 80807
80618: LD_INT 4
80620: DOUBLE
80621: EQUAL
80622: IFTRUE 80644
80624: LD_INT 5
80626: DOUBLE
80627: EQUAL
80628: IFTRUE 80644
80630: LD_INT 34
80632: DOUBLE
80633: EQUAL
80634: IFTRUE 80644
80636: LD_INT 37
80638: DOUBLE
80639: EQUAL
80640: IFTRUE 80644
80642: GO 80700
80644: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80645: LD_ADDR_VAR 0 9
80649: PUSH
80650: LD_VAR 0 53
80654: PUSH
80655: LD_VAR 0 54
80659: PUSH
80660: LD_VAR 0 55
80664: PUSH
80665: LD_VAR 0 56
80669: PUSH
80670: LD_VAR 0 57
80674: PUSH
80675: LD_VAR 0 58
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: PUSH
80688: LD_VAR 0 4
80692: PUSH
80693: LD_INT 1
80695: PLUS
80696: ARRAY
80697: ST_TO_ADDR
80698: GO 80807
80700: LD_INT 31
80702: DOUBLE
80703: EQUAL
80704: IFTRUE 80750
80706: LD_INT 32
80708: DOUBLE
80709: EQUAL
80710: IFTRUE 80750
80712: LD_INT 33
80714: DOUBLE
80715: EQUAL
80716: IFTRUE 80750
80718: LD_INT 27
80720: DOUBLE
80721: EQUAL
80722: IFTRUE 80750
80724: LD_INT 26
80726: DOUBLE
80727: EQUAL
80728: IFTRUE 80750
80730: LD_INT 28
80732: DOUBLE
80733: EQUAL
80734: IFTRUE 80750
80736: LD_INT 29
80738: DOUBLE
80739: EQUAL
80740: IFTRUE 80750
80742: LD_INT 30
80744: DOUBLE
80745: EQUAL
80746: IFTRUE 80750
80748: GO 80806
80750: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80751: LD_ADDR_VAR 0 9
80755: PUSH
80756: LD_VAR 0 59
80760: PUSH
80761: LD_VAR 0 60
80765: PUSH
80766: LD_VAR 0 61
80770: PUSH
80771: LD_VAR 0 62
80775: PUSH
80776: LD_VAR 0 63
80780: PUSH
80781: LD_VAR 0 64
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: PUSH
80794: LD_VAR 0 4
80798: PUSH
80799: LD_INT 1
80801: PLUS
80802: ARRAY
80803: ST_TO_ADDR
80804: GO 80807
80806: POP
// temp_list2 = [ ] ;
80807: LD_ADDR_VAR 0 10
80811: PUSH
80812: EMPTY
80813: ST_TO_ADDR
// for i in temp_list do
80814: LD_ADDR_VAR 0 8
80818: PUSH
80819: LD_VAR 0 9
80823: PUSH
80824: FOR_IN
80825: IFFALSE 80877
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80827: LD_ADDR_VAR 0 10
80831: PUSH
80832: LD_VAR 0 10
80836: PUSH
80837: LD_VAR 0 8
80841: PUSH
80842: LD_INT 1
80844: ARRAY
80845: PUSH
80846: LD_VAR 0 2
80850: PLUS
80851: PUSH
80852: LD_VAR 0 8
80856: PUSH
80857: LD_INT 2
80859: ARRAY
80860: PUSH
80861: LD_VAR 0 3
80865: PLUS
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: EMPTY
80872: LIST
80873: ADD
80874: ST_TO_ADDR
80875: GO 80824
80877: POP
80878: POP
// result = temp_list2 ;
80879: LD_ADDR_VAR 0 7
80883: PUSH
80884: LD_VAR 0 10
80888: ST_TO_ADDR
// end ;
80889: LD_VAR 0 7
80893: RET
// export function EnemyInRange ( unit , dist ) ; begin
80894: LD_INT 0
80896: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80897: LD_ADDR_VAR 0 3
80901: PUSH
80902: LD_VAR 0 1
80906: PPUSH
80907: CALL_OW 255
80911: PPUSH
80912: LD_VAR 0 1
80916: PPUSH
80917: CALL_OW 250
80921: PPUSH
80922: LD_VAR 0 1
80926: PPUSH
80927: CALL_OW 251
80931: PPUSH
80932: LD_VAR 0 2
80936: PPUSH
80937: CALL 54290 0 4
80941: PUSH
80942: LD_INT 4
80944: ARRAY
80945: ST_TO_ADDR
// end ;
80946: LD_VAR 0 3
80950: RET
// export function PlayerSeeMe ( unit ) ; begin
80951: LD_INT 0
80953: PPUSH
// result := See ( your_side , unit ) ;
80954: LD_ADDR_VAR 0 2
80958: PUSH
80959: LD_OWVAR 2
80963: PPUSH
80964: LD_VAR 0 1
80968: PPUSH
80969: CALL_OW 292
80973: ST_TO_ADDR
// end ;
80974: LD_VAR 0 2
80978: RET
// export function ReverseDir ( unit ) ; begin
80979: LD_INT 0
80981: PPUSH
// if not unit then
80982: LD_VAR 0 1
80986: NOT
80987: IFFALSE 80991
// exit ;
80989: GO 81014
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
80991: LD_ADDR_VAR 0 2
80995: PUSH
80996: LD_VAR 0 1
81000: PPUSH
81001: CALL_OW 254
81005: PUSH
81006: LD_INT 3
81008: PLUS
81009: PUSH
81010: LD_INT 6
81012: MOD
81013: ST_TO_ADDR
// end ;
81014: LD_VAR 0 2
81018: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81019: LD_INT 0
81021: PPUSH
81022: PPUSH
81023: PPUSH
81024: PPUSH
81025: PPUSH
// if not hexes then
81026: LD_VAR 0 2
81030: NOT
81031: IFFALSE 81035
// exit ;
81033: GO 81183
// dist := 9999 ;
81035: LD_ADDR_VAR 0 5
81039: PUSH
81040: LD_INT 9999
81042: ST_TO_ADDR
// for i = 1 to hexes do
81043: LD_ADDR_VAR 0 4
81047: PUSH
81048: DOUBLE
81049: LD_INT 1
81051: DEC
81052: ST_TO_ADDR
81053: LD_VAR 0 2
81057: PUSH
81058: FOR_TO
81059: IFFALSE 81171
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81061: LD_VAR 0 1
81065: PPUSH
81066: LD_VAR 0 2
81070: PUSH
81071: LD_VAR 0 4
81075: ARRAY
81076: PUSH
81077: LD_INT 1
81079: ARRAY
81080: PPUSH
81081: LD_VAR 0 2
81085: PUSH
81086: LD_VAR 0 4
81090: ARRAY
81091: PUSH
81092: LD_INT 2
81094: ARRAY
81095: PPUSH
81096: CALL_OW 297
81100: PUSH
81101: LD_VAR 0 5
81105: LESS
81106: IFFALSE 81169
// begin hex := hexes [ i ] ;
81108: LD_ADDR_VAR 0 7
81112: PUSH
81113: LD_VAR 0 2
81117: PUSH
81118: LD_VAR 0 4
81122: ARRAY
81123: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81124: LD_ADDR_VAR 0 5
81128: PUSH
81129: LD_VAR 0 1
81133: PPUSH
81134: LD_VAR 0 2
81138: PUSH
81139: LD_VAR 0 4
81143: ARRAY
81144: PUSH
81145: LD_INT 1
81147: ARRAY
81148: PPUSH
81149: LD_VAR 0 2
81153: PUSH
81154: LD_VAR 0 4
81158: ARRAY
81159: PUSH
81160: LD_INT 2
81162: ARRAY
81163: PPUSH
81164: CALL_OW 297
81168: ST_TO_ADDR
// end ; end ;
81169: GO 81058
81171: POP
81172: POP
// result := hex ;
81173: LD_ADDR_VAR 0 3
81177: PUSH
81178: LD_VAR 0 7
81182: ST_TO_ADDR
// end ;
81183: LD_VAR 0 3
81187: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81188: LD_INT 0
81190: PPUSH
81191: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81192: LD_VAR 0 1
81196: NOT
81197: PUSH
81198: LD_VAR 0 1
81202: PUSH
81203: LD_INT 21
81205: PUSH
81206: LD_INT 2
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 23
81215: PUSH
81216: LD_INT 2
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PPUSH
81227: CALL_OW 69
81231: IN
81232: NOT
81233: OR
81234: IFFALSE 81238
// exit ;
81236: GO 81285
// for i = 1 to 3 do
81238: LD_ADDR_VAR 0 3
81242: PUSH
81243: DOUBLE
81244: LD_INT 1
81246: DEC
81247: ST_TO_ADDR
81248: LD_INT 3
81250: PUSH
81251: FOR_TO
81252: IFFALSE 81283
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81254: LD_VAR 0 1
81258: PPUSH
81259: CALL_OW 250
81263: PPUSH
81264: LD_VAR 0 1
81268: PPUSH
81269: CALL_OW 251
81273: PPUSH
81274: LD_INT 1
81276: PPUSH
81277: CALL_OW 453
81281: GO 81251
81283: POP
81284: POP
// end ;
81285: LD_VAR 0 2
81289: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81290: LD_INT 0
81292: PPUSH
81293: PPUSH
81294: PPUSH
81295: PPUSH
81296: PPUSH
81297: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81298: LD_VAR 0 1
81302: NOT
81303: PUSH
81304: LD_VAR 0 2
81308: NOT
81309: OR
81310: PUSH
81311: LD_VAR 0 1
81315: PPUSH
81316: CALL_OW 314
81320: OR
81321: IFFALSE 81325
// exit ;
81323: GO 81766
// x := GetX ( enemy_unit ) ;
81325: LD_ADDR_VAR 0 7
81329: PUSH
81330: LD_VAR 0 2
81334: PPUSH
81335: CALL_OW 250
81339: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81340: LD_ADDR_VAR 0 8
81344: PUSH
81345: LD_VAR 0 2
81349: PPUSH
81350: CALL_OW 251
81354: ST_TO_ADDR
// if not x or not y then
81355: LD_VAR 0 7
81359: NOT
81360: PUSH
81361: LD_VAR 0 8
81365: NOT
81366: OR
81367: IFFALSE 81371
// exit ;
81369: GO 81766
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81371: LD_ADDR_VAR 0 6
81375: PUSH
81376: LD_VAR 0 7
81380: PPUSH
81381: LD_INT 0
81383: PPUSH
81384: LD_INT 4
81386: PPUSH
81387: CALL_OW 272
81391: PUSH
81392: LD_VAR 0 8
81396: PPUSH
81397: LD_INT 0
81399: PPUSH
81400: LD_INT 4
81402: PPUSH
81403: CALL_OW 273
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_VAR 0 7
81416: PPUSH
81417: LD_INT 1
81419: PPUSH
81420: LD_INT 4
81422: PPUSH
81423: CALL_OW 272
81427: PUSH
81428: LD_VAR 0 8
81432: PPUSH
81433: LD_INT 1
81435: PPUSH
81436: LD_INT 4
81438: PPUSH
81439: CALL_OW 273
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_VAR 0 7
81452: PPUSH
81453: LD_INT 2
81455: PPUSH
81456: LD_INT 4
81458: PPUSH
81459: CALL_OW 272
81463: PUSH
81464: LD_VAR 0 8
81468: PPUSH
81469: LD_INT 2
81471: PPUSH
81472: LD_INT 4
81474: PPUSH
81475: CALL_OW 273
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_VAR 0 7
81488: PPUSH
81489: LD_INT 3
81491: PPUSH
81492: LD_INT 4
81494: PPUSH
81495: CALL_OW 272
81499: PUSH
81500: LD_VAR 0 8
81504: PPUSH
81505: LD_INT 3
81507: PPUSH
81508: LD_INT 4
81510: PPUSH
81511: CALL_OW 273
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_VAR 0 7
81524: PPUSH
81525: LD_INT 4
81527: PPUSH
81528: LD_INT 4
81530: PPUSH
81531: CALL_OW 272
81535: PUSH
81536: LD_VAR 0 8
81540: PPUSH
81541: LD_INT 4
81543: PPUSH
81544: LD_INT 4
81546: PPUSH
81547: CALL_OW 273
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_VAR 0 7
81560: PPUSH
81561: LD_INT 5
81563: PPUSH
81564: LD_INT 4
81566: PPUSH
81567: CALL_OW 272
81571: PUSH
81572: LD_VAR 0 8
81576: PPUSH
81577: LD_INT 5
81579: PPUSH
81580: LD_INT 4
81582: PPUSH
81583: CALL_OW 273
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: ST_TO_ADDR
// for i = tmp downto 1 do
81600: LD_ADDR_VAR 0 4
81604: PUSH
81605: DOUBLE
81606: LD_VAR 0 6
81610: INC
81611: ST_TO_ADDR
81612: LD_INT 1
81614: PUSH
81615: FOR_DOWNTO
81616: IFFALSE 81717
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81618: LD_VAR 0 6
81622: PUSH
81623: LD_VAR 0 4
81627: ARRAY
81628: PUSH
81629: LD_INT 1
81631: ARRAY
81632: PPUSH
81633: LD_VAR 0 6
81637: PUSH
81638: LD_VAR 0 4
81642: ARRAY
81643: PUSH
81644: LD_INT 2
81646: ARRAY
81647: PPUSH
81648: CALL_OW 488
81652: NOT
81653: PUSH
81654: LD_VAR 0 6
81658: PUSH
81659: LD_VAR 0 4
81663: ARRAY
81664: PUSH
81665: LD_INT 1
81667: ARRAY
81668: PPUSH
81669: LD_VAR 0 6
81673: PUSH
81674: LD_VAR 0 4
81678: ARRAY
81679: PUSH
81680: LD_INT 2
81682: ARRAY
81683: PPUSH
81684: CALL_OW 428
81688: PUSH
81689: LD_INT 0
81691: NONEQUAL
81692: OR
81693: IFFALSE 81715
// tmp := Delete ( tmp , i ) ;
81695: LD_ADDR_VAR 0 6
81699: PUSH
81700: LD_VAR 0 6
81704: PPUSH
81705: LD_VAR 0 4
81709: PPUSH
81710: CALL_OW 3
81714: ST_TO_ADDR
81715: GO 81615
81717: POP
81718: POP
// j := GetClosestHex ( unit , tmp ) ;
81719: LD_ADDR_VAR 0 5
81723: PUSH
81724: LD_VAR 0 1
81728: PPUSH
81729: LD_VAR 0 6
81733: PPUSH
81734: CALL 81019 0 2
81738: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81739: LD_VAR 0 1
81743: PPUSH
81744: LD_VAR 0 5
81748: PUSH
81749: LD_INT 1
81751: ARRAY
81752: PPUSH
81753: LD_VAR 0 5
81757: PUSH
81758: LD_INT 2
81760: ARRAY
81761: PPUSH
81762: CALL_OW 111
// end ;
81766: LD_VAR 0 3
81770: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81771: LD_INT 0
81773: PPUSH
81774: PPUSH
81775: PPUSH
// uc_side = 0 ;
81776: LD_ADDR_OWVAR 20
81780: PUSH
81781: LD_INT 0
81783: ST_TO_ADDR
// uc_nation = 0 ;
81784: LD_ADDR_OWVAR 21
81788: PUSH
81789: LD_INT 0
81791: ST_TO_ADDR
// InitHc_All ( ) ;
81792: CALL_OW 584
// InitVc ;
81796: CALL_OW 20
// if mastodonts then
81800: LD_VAR 0 6
81804: IFFALSE 81871
// for i = 1 to mastodonts do
81806: LD_ADDR_VAR 0 11
81810: PUSH
81811: DOUBLE
81812: LD_INT 1
81814: DEC
81815: ST_TO_ADDR
81816: LD_VAR 0 6
81820: PUSH
81821: FOR_TO
81822: IFFALSE 81869
// begin vc_chassis := 31 ;
81824: LD_ADDR_OWVAR 37
81828: PUSH
81829: LD_INT 31
81831: ST_TO_ADDR
// vc_control := control_rider ;
81832: LD_ADDR_OWVAR 38
81836: PUSH
81837: LD_INT 4
81839: ST_TO_ADDR
// animal := CreateVehicle ;
81840: LD_ADDR_VAR 0 12
81844: PUSH
81845: CALL_OW 45
81849: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81850: LD_VAR 0 12
81854: PPUSH
81855: LD_VAR 0 8
81859: PPUSH
81860: LD_INT 0
81862: PPUSH
81863: CALL 84059 0 3
// end ;
81867: GO 81821
81869: POP
81870: POP
// if horses then
81871: LD_VAR 0 5
81875: IFFALSE 81942
// for i = 1 to horses do
81877: LD_ADDR_VAR 0 11
81881: PUSH
81882: DOUBLE
81883: LD_INT 1
81885: DEC
81886: ST_TO_ADDR
81887: LD_VAR 0 5
81891: PUSH
81892: FOR_TO
81893: IFFALSE 81940
// begin hc_class := 21 ;
81895: LD_ADDR_OWVAR 28
81899: PUSH
81900: LD_INT 21
81902: ST_TO_ADDR
// hc_gallery :=  ;
81903: LD_ADDR_OWVAR 33
81907: PUSH
81908: LD_STRING 
81910: ST_TO_ADDR
// animal := CreateHuman ;
81911: LD_ADDR_VAR 0 12
81915: PUSH
81916: CALL_OW 44
81920: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81921: LD_VAR 0 12
81925: PPUSH
81926: LD_VAR 0 8
81930: PPUSH
81931: LD_INT 0
81933: PPUSH
81934: CALL 84059 0 3
// end ;
81938: GO 81892
81940: POP
81941: POP
// if birds then
81942: LD_VAR 0 1
81946: IFFALSE 82013
// for i = 1 to birds do
81948: LD_ADDR_VAR 0 11
81952: PUSH
81953: DOUBLE
81954: LD_INT 1
81956: DEC
81957: ST_TO_ADDR
81958: LD_VAR 0 1
81962: PUSH
81963: FOR_TO
81964: IFFALSE 82011
// begin hc_class = 18 ;
81966: LD_ADDR_OWVAR 28
81970: PUSH
81971: LD_INT 18
81973: ST_TO_ADDR
// hc_gallery =  ;
81974: LD_ADDR_OWVAR 33
81978: PUSH
81979: LD_STRING 
81981: ST_TO_ADDR
// animal := CreateHuman ;
81982: LD_ADDR_VAR 0 12
81986: PUSH
81987: CALL_OW 44
81991: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81992: LD_VAR 0 12
81996: PPUSH
81997: LD_VAR 0 8
82001: PPUSH
82002: LD_INT 0
82004: PPUSH
82005: CALL 84059 0 3
// end ;
82009: GO 81963
82011: POP
82012: POP
// if tigers then
82013: LD_VAR 0 2
82017: IFFALSE 82101
// for i = 1 to tigers do
82019: LD_ADDR_VAR 0 11
82023: PUSH
82024: DOUBLE
82025: LD_INT 1
82027: DEC
82028: ST_TO_ADDR
82029: LD_VAR 0 2
82033: PUSH
82034: FOR_TO
82035: IFFALSE 82099
// begin hc_class = class_tiger ;
82037: LD_ADDR_OWVAR 28
82041: PUSH
82042: LD_INT 14
82044: ST_TO_ADDR
// hc_gallery =  ;
82045: LD_ADDR_OWVAR 33
82049: PUSH
82050: LD_STRING 
82052: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82053: LD_ADDR_OWVAR 35
82057: PUSH
82058: LD_INT 7
82060: NEG
82061: PPUSH
82062: LD_INT 7
82064: PPUSH
82065: CALL_OW 12
82069: ST_TO_ADDR
// animal := CreateHuman ;
82070: LD_ADDR_VAR 0 12
82074: PUSH
82075: CALL_OW 44
82079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82080: LD_VAR 0 12
82084: PPUSH
82085: LD_VAR 0 8
82089: PPUSH
82090: LD_INT 0
82092: PPUSH
82093: CALL 84059 0 3
// end ;
82097: GO 82034
82099: POP
82100: POP
// if apemans then
82101: LD_VAR 0 3
82105: IFFALSE 82228
// for i = 1 to apemans do
82107: LD_ADDR_VAR 0 11
82111: PUSH
82112: DOUBLE
82113: LD_INT 1
82115: DEC
82116: ST_TO_ADDR
82117: LD_VAR 0 3
82121: PUSH
82122: FOR_TO
82123: IFFALSE 82226
// begin hc_class = class_apeman ;
82125: LD_ADDR_OWVAR 28
82129: PUSH
82130: LD_INT 12
82132: ST_TO_ADDR
// hc_gallery =  ;
82133: LD_ADDR_OWVAR 33
82137: PUSH
82138: LD_STRING 
82140: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82141: LD_ADDR_OWVAR 35
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PPUSH
82150: LD_INT 2
82152: PPUSH
82153: CALL_OW 12
82157: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82158: LD_ADDR_OWVAR 31
82162: PUSH
82163: LD_INT 1
82165: PPUSH
82166: LD_INT 3
82168: PPUSH
82169: CALL_OW 12
82173: PUSH
82174: LD_INT 1
82176: PPUSH
82177: LD_INT 3
82179: PPUSH
82180: CALL_OW 12
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: ST_TO_ADDR
// animal := CreateHuman ;
82197: LD_ADDR_VAR 0 12
82201: PUSH
82202: CALL_OW 44
82206: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82207: LD_VAR 0 12
82211: PPUSH
82212: LD_VAR 0 8
82216: PPUSH
82217: LD_INT 0
82219: PPUSH
82220: CALL 84059 0 3
// end ;
82224: GO 82122
82226: POP
82227: POP
// if enchidnas then
82228: LD_VAR 0 4
82232: IFFALSE 82299
// for i = 1 to enchidnas do
82234: LD_ADDR_VAR 0 11
82238: PUSH
82239: DOUBLE
82240: LD_INT 1
82242: DEC
82243: ST_TO_ADDR
82244: LD_VAR 0 4
82248: PUSH
82249: FOR_TO
82250: IFFALSE 82297
// begin hc_class = 13 ;
82252: LD_ADDR_OWVAR 28
82256: PUSH
82257: LD_INT 13
82259: ST_TO_ADDR
// hc_gallery =  ;
82260: LD_ADDR_OWVAR 33
82264: PUSH
82265: LD_STRING 
82267: ST_TO_ADDR
// animal := CreateHuman ;
82268: LD_ADDR_VAR 0 12
82272: PUSH
82273: CALL_OW 44
82277: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82278: LD_VAR 0 12
82282: PPUSH
82283: LD_VAR 0 8
82287: PPUSH
82288: LD_INT 0
82290: PPUSH
82291: CALL 84059 0 3
// end ;
82295: GO 82249
82297: POP
82298: POP
// if fishes then
82299: LD_VAR 0 7
82303: IFFALSE 82370
// for i = 1 to fishes do
82305: LD_ADDR_VAR 0 11
82309: PUSH
82310: DOUBLE
82311: LD_INT 1
82313: DEC
82314: ST_TO_ADDR
82315: LD_VAR 0 7
82319: PUSH
82320: FOR_TO
82321: IFFALSE 82368
// begin hc_class = 20 ;
82323: LD_ADDR_OWVAR 28
82327: PUSH
82328: LD_INT 20
82330: ST_TO_ADDR
// hc_gallery =  ;
82331: LD_ADDR_OWVAR 33
82335: PUSH
82336: LD_STRING 
82338: ST_TO_ADDR
// animal := CreateHuman ;
82339: LD_ADDR_VAR 0 12
82343: PUSH
82344: CALL_OW 44
82348: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82349: LD_VAR 0 12
82353: PPUSH
82354: LD_VAR 0 9
82358: PPUSH
82359: LD_INT 0
82361: PPUSH
82362: CALL 84059 0 3
// end ;
82366: GO 82320
82368: POP
82369: POP
// end ;
82370: LD_VAR 0 10
82374: RET
// export function WantHeal ( sci , unit ) ; begin
82375: LD_INT 0
82377: PPUSH
// if GetTaskList ( sci ) > 0 then
82378: LD_VAR 0 1
82382: PPUSH
82383: CALL_OW 437
82387: PUSH
82388: LD_INT 0
82390: GREATER
82391: IFFALSE 82461
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82393: LD_VAR 0 1
82397: PPUSH
82398: CALL_OW 437
82402: PUSH
82403: LD_INT 1
82405: ARRAY
82406: PUSH
82407: LD_INT 1
82409: ARRAY
82410: PUSH
82411: LD_STRING l
82413: EQUAL
82414: PUSH
82415: LD_VAR 0 1
82419: PPUSH
82420: CALL_OW 437
82424: PUSH
82425: LD_INT 1
82427: ARRAY
82428: PUSH
82429: LD_INT 4
82431: ARRAY
82432: PUSH
82433: LD_VAR 0 2
82437: EQUAL
82438: AND
82439: IFFALSE 82451
// result := true else
82441: LD_ADDR_VAR 0 3
82445: PUSH
82446: LD_INT 1
82448: ST_TO_ADDR
82449: GO 82459
// result := false ;
82451: LD_ADDR_VAR 0 3
82455: PUSH
82456: LD_INT 0
82458: ST_TO_ADDR
// end else
82459: GO 82469
// result := false ;
82461: LD_ADDR_VAR 0 3
82465: PUSH
82466: LD_INT 0
82468: ST_TO_ADDR
// end ;
82469: LD_VAR 0 3
82473: RET
// export function HealTarget ( sci ) ; begin
82474: LD_INT 0
82476: PPUSH
// if not sci then
82477: LD_VAR 0 1
82481: NOT
82482: IFFALSE 82486
// exit ;
82484: GO 82551
// result := 0 ;
82486: LD_ADDR_VAR 0 2
82490: PUSH
82491: LD_INT 0
82493: ST_TO_ADDR
// if GetTaskList ( sci ) then
82494: LD_VAR 0 1
82498: PPUSH
82499: CALL_OW 437
82503: IFFALSE 82551
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82505: LD_VAR 0 1
82509: PPUSH
82510: CALL_OW 437
82514: PUSH
82515: LD_INT 1
82517: ARRAY
82518: PUSH
82519: LD_INT 1
82521: ARRAY
82522: PUSH
82523: LD_STRING l
82525: EQUAL
82526: IFFALSE 82551
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82528: LD_ADDR_VAR 0 2
82532: PUSH
82533: LD_VAR 0 1
82537: PPUSH
82538: CALL_OW 437
82542: PUSH
82543: LD_INT 1
82545: ARRAY
82546: PUSH
82547: LD_INT 4
82549: ARRAY
82550: ST_TO_ADDR
// end ;
82551: LD_VAR 0 2
82555: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82556: LD_INT 0
82558: PPUSH
82559: PPUSH
82560: PPUSH
82561: PPUSH
// if not base_units then
82562: LD_VAR 0 1
82566: NOT
82567: IFFALSE 82571
// exit ;
82569: GO 82658
// result := false ;
82571: LD_ADDR_VAR 0 2
82575: PUSH
82576: LD_INT 0
82578: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82579: LD_ADDR_VAR 0 5
82583: PUSH
82584: LD_VAR 0 1
82588: PPUSH
82589: LD_INT 21
82591: PUSH
82592: LD_INT 3
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PPUSH
82599: CALL_OW 72
82603: ST_TO_ADDR
// if not tmp then
82604: LD_VAR 0 5
82608: NOT
82609: IFFALSE 82613
// exit ;
82611: GO 82658
// for i in tmp do
82613: LD_ADDR_VAR 0 3
82617: PUSH
82618: LD_VAR 0 5
82622: PUSH
82623: FOR_IN
82624: IFFALSE 82656
// begin result := EnemyInRange ( i , 22 ) ;
82626: LD_ADDR_VAR 0 2
82630: PUSH
82631: LD_VAR 0 3
82635: PPUSH
82636: LD_INT 22
82638: PPUSH
82639: CALL 80894 0 2
82643: ST_TO_ADDR
// if result then
82644: LD_VAR 0 2
82648: IFFALSE 82654
// exit ;
82650: POP
82651: POP
82652: GO 82658
// end ;
82654: GO 82623
82656: POP
82657: POP
// end ;
82658: LD_VAR 0 2
82662: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82663: LD_INT 0
82665: PPUSH
82666: PPUSH
// if not units then
82667: LD_VAR 0 1
82671: NOT
82672: IFFALSE 82676
// exit ;
82674: GO 82746
// result := [ ] ;
82676: LD_ADDR_VAR 0 3
82680: PUSH
82681: EMPTY
82682: ST_TO_ADDR
// for i in units do
82683: LD_ADDR_VAR 0 4
82687: PUSH
82688: LD_VAR 0 1
82692: PUSH
82693: FOR_IN
82694: IFFALSE 82744
// if GetTag ( i ) = tag then
82696: LD_VAR 0 4
82700: PPUSH
82701: CALL_OW 110
82705: PUSH
82706: LD_VAR 0 2
82710: EQUAL
82711: IFFALSE 82742
// result := Replace ( result , result + 1 , i ) ;
82713: LD_ADDR_VAR 0 3
82717: PUSH
82718: LD_VAR 0 3
82722: PPUSH
82723: LD_VAR 0 3
82727: PUSH
82728: LD_INT 1
82730: PLUS
82731: PPUSH
82732: LD_VAR 0 4
82736: PPUSH
82737: CALL_OW 1
82741: ST_TO_ADDR
82742: GO 82693
82744: POP
82745: POP
// end ;
82746: LD_VAR 0 3
82750: RET
// export function IsDriver ( un ) ; begin
82751: LD_INT 0
82753: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82754: LD_ADDR_VAR 0 2
82758: PUSH
82759: LD_VAR 0 1
82763: PUSH
82764: LD_INT 55
82766: PUSH
82767: EMPTY
82768: LIST
82769: PPUSH
82770: CALL_OW 69
82774: IN
82775: ST_TO_ADDR
// end ;
82776: LD_VAR 0 2
82780: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82781: LD_INT 0
82783: PPUSH
82784: PPUSH
// list := [ ] ;
82785: LD_ADDR_VAR 0 5
82789: PUSH
82790: EMPTY
82791: ST_TO_ADDR
// case d of 0 :
82792: LD_VAR 0 3
82796: PUSH
82797: LD_INT 0
82799: DOUBLE
82800: EQUAL
82801: IFTRUE 82805
82803: GO 82938
82805: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82806: LD_ADDR_VAR 0 5
82810: PUSH
82811: LD_VAR 0 1
82815: PUSH
82816: LD_INT 4
82818: MINUS
82819: PUSH
82820: LD_VAR 0 2
82824: PUSH
82825: LD_INT 4
82827: MINUS
82828: PUSH
82829: LD_INT 2
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: LIST
82836: PUSH
82837: LD_VAR 0 1
82841: PUSH
82842: LD_INT 3
82844: MINUS
82845: PUSH
82846: LD_VAR 0 2
82850: PUSH
82851: LD_INT 1
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: LIST
82858: PUSH
82859: LD_VAR 0 1
82863: PUSH
82864: LD_INT 4
82866: PLUS
82867: PUSH
82868: LD_VAR 0 2
82872: PUSH
82873: LD_INT 4
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: LIST
82880: PUSH
82881: LD_VAR 0 1
82885: PUSH
82886: LD_INT 3
82888: PLUS
82889: PUSH
82890: LD_VAR 0 2
82894: PUSH
82895: LD_INT 3
82897: PLUS
82898: PUSH
82899: LD_INT 5
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: LIST
82906: PUSH
82907: LD_VAR 0 1
82911: PUSH
82912: LD_VAR 0 2
82916: PUSH
82917: LD_INT 4
82919: PLUS
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: LIST
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: ST_TO_ADDR
// end ; 1 :
82936: GO 83636
82938: LD_INT 1
82940: DOUBLE
82941: EQUAL
82942: IFTRUE 82946
82944: GO 83079
82946: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82947: LD_ADDR_VAR 0 5
82951: PUSH
82952: LD_VAR 0 1
82956: PUSH
82957: LD_VAR 0 2
82961: PUSH
82962: LD_INT 4
82964: MINUS
82965: PUSH
82966: LD_INT 3
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: LIST
82973: PUSH
82974: LD_VAR 0 1
82978: PUSH
82979: LD_INT 3
82981: MINUS
82982: PUSH
82983: LD_VAR 0 2
82987: PUSH
82988: LD_INT 3
82990: MINUS
82991: PUSH
82992: LD_INT 2
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: LIST
82999: PUSH
83000: LD_VAR 0 1
83004: PUSH
83005: LD_INT 4
83007: MINUS
83008: PUSH
83009: LD_VAR 0 2
83013: PUSH
83014: LD_INT 1
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: LIST
83021: PUSH
83022: LD_VAR 0 1
83026: PUSH
83027: LD_VAR 0 2
83031: PUSH
83032: LD_INT 3
83034: PLUS
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: LIST
83043: PUSH
83044: LD_VAR 0 1
83048: PUSH
83049: LD_INT 4
83051: PLUS
83052: PUSH
83053: LD_VAR 0 2
83057: PUSH
83058: LD_INT 4
83060: PLUS
83061: PUSH
83062: LD_INT 5
83064: PUSH
83065: EMPTY
83066: LIST
83067: LIST
83068: LIST
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: ST_TO_ADDR
// end ; 2 :
83077: GO 83636
83079: LD_INT 2
83081: DOUBLE
83082: EQUAL
83083: IFTRUE 83087
83085: GO 83216
83087: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83088: LD_ADDR_VAR 0 5
83092: PUSH
83093: LD_VAR 0 1
83097: PUSH
83098: LD_VAR 0 2
83102: PUSH
83103: LD_INT 3
83105: MINUS
83106: PUSH
83107: LD_INT 3
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: LIST
83114: PUSH
83115: LD_VAR 0 1
83119: PUSH
83120: LD_INT 4
83122: PLUS
83123: PUSH
83124: LD_VAR 0 2
83128: PUSH
83129: LD_INT 4
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: LIST
83136: PUSH
83137: LD_VAR 0 1
83141: PUSH
83142: LD_VAR 0 2
83146: PUSH
83147: LD_INT 4
83149: PLUS
83150: PUSH
83151: LD_INT 0
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: LIST
83158: PUSH
83159: LD_VAR 0 1
83163: PUSH
83164: LD_INT 3
83166: MINUS
83167: PUSH
83168: LD_VAR 0 2
83172: PUSH
83173: LD_INT 1
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: LIST
83180: PUSH
83181: LD_VAR 0 1
83185: PUSH
83186: LD_INT 4
83188: MINUS
83189: PUSH
83190: LD_VAR 0 2
83194: PUSH
83195: LD_INT 4
83197: MINUS
83198: PUSH
83199: LD_INT 2
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: LIST
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: ST_TO_ADDR
// end ; 3 :
83214: GO 83636
83216: LD_INT 3
83218: DOUBLE
83219: EQUAL
83220: IFTRUE 83224
83222: GO 83357
83224: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83225: LD_ADDR_VAR 0 5
83229: PUSH
83230: LD_VAR 0 1
83234: PUSH
83235: LD_INT 3
83237: PLUS
83238: PUSH
83239: LD_VAR 0 2
83243: PUSH
83244: LD_INT 4
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: LIST
83251: PUSH
83252: LD_VAR 0 1
83256: PUSH
83257: LD_INT 4
83259: PLUS
83260: PUSH
83261: LD_VAR 0 2
83265: PUSH
83266: LD_INT 4
83268: PLUS
83269: PUSH
83270: LD_INT 5
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: LIST
83277: PUSH
83278: LD_VAR 0 1
83282: PUSH
83283: LD_INT 4
83285: MINUS
83286: PUSH
83287: LD_VAR 0 2
83291: PUSH
83292: LD_INT 1
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: LIST
83299: PUSH
83300: LD_VAR 0 1
83304: PUSH
83305: LD_VAR 0 2
83309: PUSH
83310: LD_INT 4
83312: MINUS
83313: PUSH
83314: LD_INT 3
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: LIST
83321: PUSH
83322: LD_VAR 0 1
83326: PUSH
83327: LD_INT 3
83329: MINUS
83330: PUSH
83331: LD_VAR 0 2
83335: PUSH
83336: LD_INT 3
83338: MINUS
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: LIST
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: ST_TO_ADDR
// end ; 4 :
83355: GO 83636
83357: LD_INT 4
83359: DOUBLE
83360: EQUAL
83361: IFTRUE 83365
83363: GO 83498
83365: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83366: LD_ADDR_VAR 0 5
83370: PUSH
83371: LD_VAR 0 1
83375: PUSH
83376: LD_VAR 0 2
83380: PUSH
83381: LD_INT 4
83383: PLUS
83384: PUSH
83385: LD_INT 0
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: LIST
83392: PUSH
83393: LD_VAR 0 1
83397: PUSH
83398: LD_INT 3
83400: PLUS
83401: PUSH
83402: LD_VAR 0 2
83406: PUSH
83407: LD_INT 3
83409: PLUS
83410: PUSH
83411: LD_INT 5
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: LIST
83418: PUSH
83419: LD_VAR 0 1
83423: PUSH
83424: LD_INT 4
83426: PLUS
83427: PUSH
83428: LD_VAR 0 2
83432: PUSH
83433: LD_INT 4
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: LIST
83440: PUSH
83441: LD_VAR 0 1
83445: PUSH
83446: LD_VAR 0 2
83450: PUSH
83451: LD_INT 3
83453: MINUS
83454: PUSH
83455: LD_INT 3
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: LIST
83462: PUSH
83463: LD_VAR 0 1
83467: PUSH
83468: LD_INT 4
83470: MINUS
83471: PUSH
83472: LD_VAR 0 2
83476: PUSH
83477: LD_INT 4
83479: MINUS
83480: PUSH
83481: LD_INT 2
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: LIST
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: ST_TO_ADDR
// end ; 5 :
83496: GO 83636
83498: LD_INT 5
83500: DOUBLE
83501: EQUAL
83502: IFTRUE 83506
83504: GO 83635
83506: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83507: LD_ADDR_VAR 0 5
83511: PUSH
83512: LD_VAR 0 1
83516: PUSH
83517: LD_INT 4
83519: MINUS
83520: PUSH
83521: LD_VAR 0 2
83525: PUSH
83526: LD_INT 1
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: LIST
83533: PUSH
83534: LD_VAR 0 1
83538: PUSH
83539: LD_VAR 0 2
83543: PUSH
83544: LD_INT 4
83546: MINUS
83547: PUSH
83548: LD_INT 3
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: LIST
83555: PUSH
83556: LD_VAR 0 1
83560: PUSH
83561: LD_INT 4
83563: PLUS
83564: PUSH
83565: LD_VAR 0 2
83569: PUSH
83570: LD_INT 4
83572: PLUS
83573: PUSH
83574: LD_INT 5
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: LIST
83581: PUSH
83582: LD_VAR 0 1
83586: PUSH
83587: LD_INT 3
83589: PLUS
83590: PUSH
83591: LD_VAR 0 2
83595: PUSH
83596: LD_INT 4
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: LIST
83603: PUSH
83604: LD_VAR 0 1
83608: PUSH
83609: LD_VAR 0 2
83613: PUSH
83614: LD_INT 3
83616: PLUS
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: LIST
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: ST_TO_ADDR
// end ; end ;
83633: GO 83636
83635: POP
// result := list ;
83636: LD_ADDR_VAR 0 4
83640: PUSH
83641: LD_VAR 0 5
83645: ST_TO_ADDR
// end ;
83646: LD_VAR 0 4
83650: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83651: LD_INT 0
83653: PPUSH
83654: PPUSH
83655: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83656: LD_VAR 0 1
83660: NOT
83661: PUSH
83662: LD_VAR 0 2
83666: PUSH
83667: LD_INT 1
83669: PUSH
83670: LD_INT 2
83672: PUSH
83673: LD_INT 3
83675: PUSH
83676: LD_INT 4
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: IN
83685: NOT
83686: OR
83687: IFFALSE 83691
// exit ;
83689: GO 83783
// tmp := [ ] ;
83691: LD_ADDR_VAR 0 5
83695: PUSH
83696: EMPTY
83697: ST_TO_ADDR
// for i in units do
83698: LD_ADDR_VAR 0 4
83702: PUSH
83703: LD_VAR 0 1
83707: PUSH
83708: FOR_IN
83709: IFFALSE 83752
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83711: LD_ADDR_VAR 0 5
83715: PUSH
83716: LD_VAR 0 5
83720: PPUSH
83721: LD_VAR 0 5
83725: PUSH
83726: LD_INT 1
83728: PLUS
83729: PPUSH
83730: LD_VAR 0 4
83734: PPUSH
83735: LD_VAR 0 2
83739: PPUSH
83740: CALL_OW 259
83744: PPUSH
83745: CALL_OW 2
83749: ST_TO_ADDR
83750: GO 83708
83752: POP
83753: POP
// if not tmp then
83754: LD_VAR 0 5
83758: NOT
83759: IFFALSE 83763
// exit ;
83761: GO 83783
// result := SortListByListDesc ( units , tmp ) ;
83763: LD_ADDR_VAR 0 3
83767: PUSH
83768: LD_VAR 0 1
83772: PPUSH
83773: LD_VAR 0 5
83777: PPUSH
83778: CALL_OW 77
83782: ST_TO_ADDR
// end ;
83783: LD_VAR 0 3
83787: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83788: LD_INT 0
83790: PPUSH
83791: PPUSH
83792: PPUSH
// result := false ;
83793: LD_ADDR_VAR 0 3
83797: PUSH
83798: LD_INT 0
83800: ST_TO_ADDR
// x := GetX ( building ) ;
83801: LD_ADDR_VAR 0 4
83805: PUSH
83806: LD_VAR 0 2
83810: PPUSH
83811: CALL_OW 250
83815: ST_TO_ADDR
// y := GetY ( building ) ;
83816: LD_ADDR_VAR 0 5
83820: PUSH
83821: LD_VAR 0 2
83825: PPUSH
83826: CALL_OW 251
83830: ST_TO_ADDR
// if not building or not x or not y then
83831: LD_VAR 0 2
83835: NOT
83836: PUSH
83837: LD_VAR 0 4
83841: NOT
83842: OR
83843: PUSH
83844: LD_VAR 0 5
83848: NOT
83849: OR
83850: IFFALSE 83854
// exit ;
83852: GO 83946
// if GetTaskList ( unit ) then
83854: LD_VAR 0 1
83858: PPUSH
83859: CALL_OW 437
83863: IFFALSE 83946
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83865: LD_STRING e
83867: PUSH
83868: LD_VAR 0 1
83872: PPUSH
83873: CALL_OW 437
83877: PUSH
83878: LD_INT 1
83880: ARRAY
83881: PUSH
83882: LD_INT 1
83884: ARRAY
83885: EQUAL
83886: PUSH
83887: LD_VAR 0 4
83891: PUSH
83892: LD_VAR 0 1
83896: PPUSH
83897: CALL_OW 437
83901: PUSH
83902: LD_INT 1
83904: ARRAY
83905: PUSH
83906: LD_INT 2
83908: ARRAY
83909: EQUAL
83910: AND
83911: PUSH
83912: LD_VAR 0 5
83916: PUSH
83917: LD_VAR 0 1
83921: PPUSH
83922: CALL_OW 437
83926: PUSH
83927: LD_INT 1
83929: ARRAY
83930: PUSH
83931: LD_INT 3
83933: ARRAY
83934: EQUAL
83935: AND
83936: IFFALSE 83946
// result := true end ;
83938: LD_ADDR_VAR 0 3
83942: PUSH
83943: LD_INT 1
83945: ST_TO_ADDR
// end ;
83946: LD_VAR 0 3
83950: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
83951: LD_INT 0
83953: PPUSH
// result := false ;
83954: LD_ADDR_VAR 0 4
83958: PUSH
83959: LD_INT 0
83961: ST_TO_ADDR
// if GetTaskList ( unit ) then
83962: LD_VAR 0 1
83966: PPUSH
83967: CALL_OW 437
83971: IFFALSE 84054
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83973: LD_STRING M
83975: PUSH
83976: LD_VAR 0 1
83980: PPUSH
83981: CALL_OW 437
83985: PUSH
83986: LD_INT 1
83988: ARRAY
83989: PUSH
83990: LD_INT 1
83992: ARRAY
83993: EQUAL
83994: PUSH
83995: LD_VAR 0 2
83999: PUSH
84000: LD_VAR 0 1
84004: PPUSH
84005: CALL_OW 437
84009: PUSH
84010: LD_INT 1
84012: ARRAY
84013: PUSH
84014: LD_INT 2
84016: ARRAY
84017: EQUAL
84018: AND
84019: PUSH
84020: LD_VAR 0 3
84024: PUSH
84025: LD_VAR 0 1
84029: PPUSH
84030: CALL_OW 437
84034: PUSH
84035: LD_INT 1
84037: ARRAY
84038: PUSH
84039: LD_INT 3
84041: ARRAY
84042: EQUAL
84043: AND
84044: IFFALSE 84054
// result := true ;
84046: LD_ADDR_VAR 0 4
84050: PUSH
84051: LD_INT 1
84053: ST_TO_ADDR
// end ; end ;
84054: LD_VAR 0 4
84058: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84059: LD_INT 0
84061: PPUSH
84062: PPUSH
84063: PPUSH
84064: PPUSH
// if not unit or not area then
84065: LD_VAR 0 1
84069: NOT
84070: PUSH
84071: LD_VAR 0 2
84075: NOT
84076: OR
84077: IFFALSE 84081
// exit ;
84079: GO 84245
// tmp := AreaToList ( area , i ) ;
84081: LD_ADDR_VAR 0 6
84085: PUSH
84086: LD_VAR 0 2
84090: PPUSH
84091: LD_VAR 0 5
84095: PPUSH
84096: CALL_OW 517
84100: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84101: LD_ADDR_VAR 0 5
84105: PUSH
84106: DOUBLE
84107: LD_INT 1
84109: DEC
84110: ST_TO_ADDR
84111: LD_VAR 0 6
84115: PUSH
84116: LD_INT 1
84118: ARRAY
84119: PUSH
84120: FOR_TO
84121: IFFALSE 84243
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84123: LD_ADDR_VAR 0 7
84127: PUSH
84128: LD_VAR 0 6
84132: PUSH
84133: LD_INT 1
84135: ARRAY
84136: PUSH
84137: LD_VAR 0 5
84141: ARRAY
84142: PUSH
84143: LD_VAR 0 6
84147: PUSH
84148: LD_INT 2
84150: ARRAY
84151: PUSH
84152: LD_VAR 0 5
84156: ARRAY
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84162: LD_VAR 0 7
84166: PUSH
84167: LD_INT 1
84169: ARRAY
84170: PPUSH
84171: LD_VAR 0 7
84175: PUSH
84176: LD_INT 2
84178: ARRAY
84179: PPUSH
84180: CALL_OW 428
84184: PUSH
84185: LD_INT 0
84187: EQUAL
84188: IFFALSE 84241
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84190: LD_VAR 0 1
84194: PPUSH
84195: LD_VAR 0 7
84199: PUSH
84200: LD_INT 1
84202: ARRAY
84203: PPUSH
84204: LD_VAR 0 7
84208: PUSH
84209: LD_INT 2
84211: ARRAY
84212: PPUSH
84213: LD_VAR 0 3
84217: PPUSH
84218: CALL_OW 48
// result := IsPlaced ( unit ) ;
84222: LD_ADDR_VAR 0 4
84226: PUSH
84227: LD_VAR 0 1
84231: PPUSH
84232: CALL_OW 305
84236: ST_TO_ADDR
// exit ;
84237: POP
84238: POP
84239: GO 84245
// end ; end ;
84241: GO 84120
84243: POP
84244: POP
// end ;
84245: LD_VAR 0 4
84249: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84250: LD_INT 0
84252: PPUSH
84253: PPUSH
84254: PPUSH
// if not side or side > 8 then
84255: LD_VAR 0 1
84259: NOT
84260: PUSH
84261: LD_VAR 0 1
84265: PUSH
84266: LD_INT 8
84268: GREATER
84269: OR
84270: IFFALSE 84274
// exit ;
84272: GO 84461
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84274: LD_ADDR_VAR 0 4
84278: PUSH
84279: LD_INT 22
84281: PUSH
84282: LD_VAR 0 1
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 21
84293: PUSH
84294: LD_INT 3
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PPUSH
84305: CALL_OW 69
84309: ST_TO_ADDR
// if not tmp then
84310: LD_VAR 0 4
84314: NOT
84315: IFFALSE 84319
// exit ;
84317: GO 84461
// enable_addtolog := true ;
84319: LD_ADDR_OWVAR 81
84323: PUSH
84324: LD_INT 1
84326: ST_TO_ADDR
// AddToLog ( [ ) ;
84327: LD_STRING [
84329: PPUSH
84330: CALL_OW 561
// for i in tmp do
84334: LD_ADDR_VAR 0 3
84338: PUSH
84339: LD_VAR 0 4
84343: PUSH
84344: FOR_IN
84345: IFFALSE 84452
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84347: LD_STRING [
84349: PUSH
84350: LD_VAR 0 3
84354: PPUSH
84355: CALL_OW 266
84359: STR
84360: PUSH
84361: LD_STRING , 
84363: STR
84364: PUSH
84365: LD_VAR 0 3
84369: PPUSH
84370: CALL_OW 250
84374: STR
84375: PUSH
84376: LD_STRING , 
84378: STR
84379: PUSH
84380: LD_VAR 0 3
84384: PPUSH
84385: CALL_OW 251
84389: STR
84390: PUSH
84391: LD_STRING , 
84393: STR
84394: PUSH
84395: LD_VAR 0 3
84399: PPUSH
84400: CALL_OW 254
84404: STR
84405: PUSH
84406: LD_STRING , 
84408: STR
84409: PUSH
84410: LD_VAR 0 3
84414: PPUSH
84415: LD_INT 1
84417: PPUSH
84418: CALL_OW 268
84422: STR
84423: PUSH
84424: LD_STRING , 
84426: STR
84427: PUSH
84428: LD_VAR 0 3
84432: PPUSH
84433: LD_INT 2
84435: PPUSH
84436: CALL_OW 268
84440: STR
84441: PUSH
84442: LD_STRING ],
84444: STR
84445: PPUSH
84446: CALL_OW 561
// end ;
84450: GO 84344
84452: POP
84453: POP
// AddToLog ( ]; ) ;
84454: LD_STRING ];
84456: PPUSH
84457: CALL_OW 561
// end ;
84461: LD_VAR 0 2
84465: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84466: LD_INT 0
84468: PPUSH
84469: PPUSH
84470: PPUSH
84471: PPUSH
84472: PPUSH
// if not area or not rate or not max then
84473: LD_VAR 0 1
84477: NOT
84478: PUSH
84479: LD_VAR 0 2
84483: NOT
84484: OR
84485: PUSH
84486: LD_VAR 0 4
84490: NOT
84491: OR
84492: IFFALSE 84496
// exit ;
84494: GO 84688
// while 1 do
84496: LD_INT 1
84498: IFFALSE 84688
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84500: LD_ADDR_VAR 0 9
84504: PUSH
84505: LD_VAR 0 1
84509: PPUSH
84510: LD_INT 1
84512: PPUSH
84513: CALL_OW 287
84517: PUSH
84518: LD_INT 10
84520: MUL
84521: ST_TO_ADDR
// r := rate / 10 ;
84522: LD_ADDR_VAR 0 7
84526: PUSH
84527: LD_VAR 0 2
84531: PUSH
84532: LD_INT 10
84534: DIVREAL
84535: ST_TO_ADDR
// time := 1 1$00 ;
84536: LD_ADDR_VAR 0 8
84540: PUSH
84541: LD_INT 2100
84543: ST_TO_ADDR
// if amount < min then
84544: LD_VAR 0 9
84548: PUSH
84549: LD_VAR 0 3
84553: LESS
84554: IFFALSE 84572
// r := r * 2 else
84556: LD_ADDR_VAR 0 7
84560: PUSH
84561: LD_VAR 0 7
84565: PUSH
84566: LD_INT 2
84568: MUL
84569: ST_TO_ADDR
84570: GO 84598
// if amount > max then
84572: LD_VAR 0 9
84576: PUSH
84577: LD_VAR 0 4
84581: GREATER
84582: IFFALSE 84598
// r := r / 2 ;
84584: LD_ADDR_VAR 0 7
84588: PUSH
84589: LD_VAR 0 7
84593: PUSH
84594: LD_INT 2
84596: DIVREAL
84597: ST_TO_ADDR
// time := time / r ;
84598: LD_ADDR_VAR 0 8
84602: PUSH
84603: LD_VAR 0 8
84607: PUSH
84608: LD_VAR 0 7
84612: DIVREAL
84613: ST_TO_ADDR
// if time < 0 then
84614: LD_VAR 0 8
84618: PUSH
84619: LD_INT 0
84621: LESS
84622: IFFALSE 84639
// time := time * - 1 ;
84624: LD_ADDR_VAR 0 8
84628: PUSH
84629: LD_VAR 0 8
84633: PUSH
84634: LD_INT 1
84636: NEG
84637: MUL
84638: ST_TO_ADDR
// wait ( time ) ;
84639: LD_VAR 0 8
84643: PPUSH
84644: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84648: LD_INT 35
84650: PPUSH
84651: LD_INT 875
84653: PPUSH
84654: CALL_OW 12
84658: PPUSH
84659: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84663: LD_INT 1
84665: PPUSH
84666: LD_INT 5
84668: PPUSH
84669: CALL_OW 12
84673: PPUSH
84674: LD_VAR 0 1
84678: PPUSH
84679: LD_INT 1
84681: PPUSH
84682: CALL_OW 55
// end ;
84686: GO 84496
// end ;
84688: LD_VAR 0 5
84692: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84693: LD_INT 0
84695: PPUSH
84696: PPUSH
84697: PPUSH
84698: PPUSH
84699: PPUSH
84700: PPUSH
84701: PPUSH
84702: PPUSH
// if not turrets or not factories then
84703: LD_VAR 0 1
84707: NOT
84708: PUSH
84709: LD_VAR 0 2
84713: NOT
84714: OR
84715: IFFALSE 84719
// exit ;
84717: GO 85026
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84719: LD_ADDR_VAR 0 10
84723: PUSH
84724: LD_INT 5
84726: PUSH
84727: LD_INT 6
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 2
84736: PUSH
84737: LD_INT 4
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 3
84746: PUSH
84747: LD_INT 5
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 24
84761: PUSH
84762: LD_INT 25
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 23
84771: PUSH
84772: LD_INT 27
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 42
84785: PUSH
84786: LD_INT 43
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 44
84795: PUSH
84796: LD_INT 46
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 45
84805: PUSH
84806: LD_INT 47
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: LIST
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: LIST
84822: ST_TO_ADDR
// result := [ ] ;
84823: LD_ADDR_VAR 0 3
84827: PUSH
84828: EMPTY
84829: ST_TO_ADDR
// for i in turrets do
84830: LD_ADDR_VAR 0 4
84834: PUSH
84835: LD_VAR 0 1
84839: PUSH
84840: FOR_IN
84841: IFFALSE 85024
// begin nat := GetNation ( i ) ;
84843: LD_ADDR_VAR 0 7
84847: PUSH
84848: LD_VAR 0 4
84852: PPUSH
84853: CALL_OW 248
84857: ST_TO_ADDR
// weapon := 0 ;
84858: LD_ADDR_VAR 0 8
84862: PUSH
84863: LD_INT 0
84865: ST_TO_ADDR
// if not nat then
84866: LD_VAR 0 7
84870: NOT
84871: IFFALSE 84875
// continue ;
84873: GO 84840
// for j in list [ nat ] do
84875: LD_ADDR_VAR 0 5
84879: PUSH
84880: LD_VAR 0 10
84884: PUSH
84885: LD_VAR 0 7
84889: ARRAY
84890: PUSH
84891: FOR_IN
84892: IFFALSE 84933
// if GetBWeapon ( i ) = j [ 1 ] then
84894: LD_VAR 0 4
84898: PPUSH
84899: CALL_OW 269
84903: PUSH
84904: LD_VAR 0 5
84908: PUSH
84909: LD_INT 1
84911: ARRAY
84912: EQUAL
84913: IFFALSE 84931
// begin weapon := j [ 2 ] ;
84915: LD_ADDR_VAR 0 8
84919: PUSH
84920: LD_VAR 0 5
84924: PUSH
84925: LD_INT 2
84927: ARRAY
84928: ST_TO_ADDR
// break ;
84929: GO 84933
// end ;
84931: GO 84891
84933: POP
84934: POP
// if not weapon then
84935: LD_VAR 0 8
84939: NOT
84940: IFFALSE 84944
// continue ;
84942: GO 84840
// for k in factories do
84944: LD_ADDR_VAR 0 6
84948: PUSH
84949: LD_VAR 0 2
84953: PUSH
84954: FOR_IN
84955: IFFALSE 85020
// begin weapons := AvailableWeaponList ( k ) ;
84957: LD_ADDR_VAR 0 9
84961: PUSH
84962: LD_VAR 0 6
84966: PPUSH
84967: CALL_OW 478
84971: ST_TO_ADDR
// if not weapons then
84972: LD_VAR 0 9
84976: NOT
84977: IFFALSE 84981
// continue ;
84979: GO 84954
// if weapon in weapons then
84981: LD_VAR 0 8
84985: PUSH
84986: LD_VAR 0 9
84990: IN
84991: IFFALSE 85018
// begin result := [ i , weapon ] ;
84993: LD_ADDR_VAR 0 3
84997: PUSH
84998: LD_VAR 0 4
85002: PUSH
85003: LD_VAR 0 8
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: ST_TO_ADDR
// exit ;
85012: POP
85013: POP
85014: POP
85015: POP
85016: GO 85026
// end ; end ;
85018: GO 84954
85020: POP
85021: POP
// end ;
85022: GO 84840
85024: POP
85025: POP
// end ;
85026: LD_VAR 0 3
85030: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85031: LD_INT 0
85033: PPUSH
// if not side or side > 8 then
85034: LD_VAR 0 3
85038: NOT
85039: PUSH
85040: LD_VAR 0 3
85044: PUSH
85045: LD_INT 8
85047: GREATER
85048: OR
85049: IFFALSE 85053
// exit ;
85051: GO 85112
// if not range then
85053: LD_VAR 0 4
85057: NOT
85058: IFFALSE 85069
// range := - 12 ;
85060: LD_ADDR_VAR 0 4
85064: PUSH
85065: LD_INT 12
85067: NEG
85068: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85069: LD_VAR 0 1
85073: PPUSH
85074: LD_VAR 0 2
85078: PPUSH
85079: LD_VAR 0 3
85083: PPUSH
85084: LD_VAR 0 4
85088: PPUSH
85089: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85093: LD_VAR 0 1
85097: PPUSH
85098: LD_VAR 0 2
85102: PPUSH
85103: LD_VAR 0 3
85107: PPUSH
85108: CALL_OW 331
// end ;
85112: LD_VAR 0 5
85116: RET
// export function Video ( mode ) ; begin
85117: LD_INT 0
85119: PPUSH
// ingame_video = mode ;
85120: LD_ADDR_OWVAR 52
85124: PUSH
85125: LD_VAR 0 1
85129: ST_TO_ADDR
// interface_hidden = mode ;
85130: LD_ADDR_OWVAR 54
85134: PUSH
85135: LD_VAR 0 1
85139: ST_TO_ADDR
// end ;
85140: LD_VAR 0 2
85144: RET
// export function Join ( array , element ) ; begin
85145: LD_INT 0
85147: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85148: LD_ADDR_VAR 0 3
85152: PUSH
85153: LD_VAR 0 1
85157: PPUSH
85158: LD_VAR 0 1
85162: PUSH
85163: LD_INT 1
85165: PLUS
85166: PPUSH
85167: LD_VAR 0 2
85171: PPUSH
85172: CALL_OW 1
85176: ST_TO_ADDR
// end ;
85177: LD_VAR 0 3
85181: RET
// export function JoinUnion ( array , element ) ; begin
85182: LD_INT 0
85184: PPUSH
// result := array union element ;
85185: LD_ADDR_VAR 0 3
85189: PUSH
85190: LD_VAR 0 1
85194: PUSH
85195: LD_VAR 0 2
85199: UNION
85200: ST_TO_ADDR
// end ;
85201: LD_VAR 0 3
85205: RET
// export function GetBehemoths ( side ) ; begin
85206: LD_INT 0
85208: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85209: LD_ADDR_VAR 0 2
85213: PUSH
85214: LD_INT 22
85216: PUSH
85217: LD_VAR 0 1
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: PUSH
85226: LD_INT 31
85228: PUSH
85229: LD_INT 25
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PPUSH
85240: CALL_OW 69
85244: ST_TO_ADDR
// end ;
85245: LD_VAR 0 2
85249: RET
// export function Shuffle ( array ) ; var i , index ; begin
85250: LD_INT 0
85252: PPUSH
85253: PPUSH
85254: PPUSH
// result := [ ] ;
85255: LD_ADDR_VAR 0 2
85259: PUSH
85260: EMPTY
85261: ST_TO_ADDR
// if not array then
85262: LD_VAR 0 1
85266: NOT
85267: IFFALSE 85271
// exit ;
85269: GO 85370
// Randomize ;
85271: CALL_OW 10
// for i = array downto 1 do
85275: LD_ADDR_VAR 0 3
85279: PUSH
85280: DOUBLE
85281: LD_VAR 0 1
85285: INC
85286: ST_TO_ADDR
85287: LD_INT 1
85289: PUSH
85290: FOR_DOWNTO
85291: IFFALSE 85368
// begin index := rand ( 1 , array ) ;
85293: LD_ADDR_VAR 0 4
85297: PUSH
85298: LD_INT 1
85300: PPUSH
85301: LD_VAR 0 1
85305: PPUSH
85306: CALL_OW 12
85310: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85311: LD_ADDR_VAR 0 2
85315: PUSH
85316: LD_VAR 0 2
85320: PPUSH
85321: LD_VAR 0 2
85325: PUSH
85326: LD_INT 1
85328: PLUS
85329: PPUSH
85330: LD_VAR 0 1
85334: PUSH
85335: LD_VAR 0 4
85339: ARRAY
85340: PPUSH
85341: CALL_OW 2
85345: ST_TO_ADDR
// array := Delete ( array , index ) ;
85346: LD_ADDR_VAR 0 1
85350: PUSH
85351: LD_VAR 0 1
85355: PPUSH
85356: LD_VAR 0 4
85360: PPUSH
85361: CALL_OW 3
85365: ST_TO_ADDR
// end ;
85366: GO 85290
85368: POP
85369: POP
// end ;
85370: LD_VAR 0 2
85374: RET
// export function GetBaseMaterials ( base ) ; begin
85375: LD_INT 0
85377: PPUSH
// result := [ 0 , 0 , 0 ] ;
85378: LD_ADDR_VAR 0 2
85382: PUSH
85383: LD_INT 0
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: LIST
85396: ST_TO_ADDR
// if not base then
85397: LD_VAR 0 1
85401: NOT
85402: IFFALSE 85406
// exit ;
85404: GO 85455
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85406: LD_ADDR_VAR 0 2
85410: PUSH
85411: LD_VAR 0 1
85415: PPUSH
85416: LD_INT 1
85418: PPUSH
85419: CALL_OW 275
85423: PUSH
85424: LD_VAR 0 1
85428: PPUSH
85429: LD_INT 2
85431: PPUSH
85432: CALL_OW 275
85436: PUSH
85437: LD_VAR 0 1
85441: PPUSH
85442: LD_INT 3
85444: PPUSH
85445: CALL_OW 275
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: LIST
85454: ST_TO_ADDR
// end ;
85455: LD_VAR 0 2
85459: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85460: LD_INT 0
85462: PPUSH
85463: PPUSH
// result := array ;
85464: LD_ADDR_VAR 0 3
85468: PUSH
85469: LD_VAR 0 1
85473: ST_TO_ADDR
// if size > 0 then
85474: LD_VAR 0 2
85478: PUSH
85479: LD_INT 0
85481: GREATER
85482: IFFALSE 85528
// for i := array downto size do
85484: LD_ADDR_VAR 0 4
85488: PUSH
85489: DOUBLE
85490: LD_VAR 0 1
85494: INC
85495: ST_TO_ADDR
85496: LD_VAR 0 2
85500: PUSH
85501: FOR_DOWNTO
85502: IFFALSE 85526
// result := Delete ( result , result ) ;
85504: LD_ADDR_VAR 0 3
85508: PUSH
85509: LD_VAR 0 3
85513: PPUSH
85514: LD_VAR 0 3
85518: PPUSH
85519: CALL_OW 3
85523: ST_TO_ADDR
85524: GO 85501
85526: POP
85527: POP
// end ;
85528: LD_VAR 0 3
85532: RET
// export function ComExit ( unit ) ; var tmp ; begin
85533: LD_INT 0
85535: PPUSH
85536: PPUSH
// if not IsInUnit ( unit ) then
85537: LD_VAR 0 1
85541: PPUSH
85542: CALL_OW 310
85546: NOT
85547: IFFALSE 85551
// exit ;
85549: GO 85611
// tmp := IsInUnit ( unit ) ;
85551: LD_ADDR_VAR 0 3
85555: PUSH
85556: LD_VAR 0 1
85560: PPUSH
85561: CALL_OW 310
85565: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85566: LD_VAR 0 3
85570: PPUSH
85571: CALL_OW 247
85575: PUSH
85576: LD_INT 2
85578: EQUAL
85579: IFFALSE 85592
// ComExitVehicle ( unit ) else
85581: LD_VAR 0 1
85585: PPUSH
85586: CALL_OW 121
85590: GO 85601
// ComExitBuilding ( unit ) ;
85592: LD_VAR 0 1
85596: PPUSH
85597: CALL_OW 122
// result := tmp ;
85601: LD_ADDR_VAR 0 2
85605: PUSH
85606: LD_VAR 0 3
85610: ST_TO_ADDR
// end ;
85611: LD_VAR 0 2
85615: RET
// export function ComExitAll ( units ) ; var i ; begin
85616: LD_INT 0
85618: PPUSH
85619: PPUSH
// if not units then
85620: LD_VAR 0 1
85624: NOT
85625: IFFALSE 85629
// exit ;
85627: GO 85655
// for i in units do
85629: LD_ADDR_VAR 0 3
85633: PUSH
85634: LD_VAR 0 1
85638: PUSH
85639: FOR_IN
85640: IFFALSE 85653
// ComExit ( i ) ;
85642: LD_VAR 0 3
85646: PPUSH
85647: CALL 85533 0 1
85651: GO 85639
85653: POP
85654: POP
// end ;
85655: LD_VAR 0 2
85659: RET
// export function ResetHc ; begin
85660: LD_INT 0
85662: PPUSH
// InitHc ;
85663: CALL_OW 19
// hc_importance := 0 ;
85667: LD_ADDR_OWVAR 32
85671: PUSH
85672: LD_INT 0
85674: ST_TO_ADDR
// end ;
85675: LD_VAR 0 1
85679: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85680: LD_INT 0
85682: PPUSH
85683: PPUSH
85684: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85685: LD_ADDR_VAR 0 6
85689: PUSH
85690: LD_VAR 0 1
85694: PUSH
85695: LD_VAR 0 3
85699: PLUS
85700: PUSH
85701: LD_INT 2
85703: DIV
85704: ST_TO_ADDR
// if _x < 0 then
85705: LD_VAR 0 6
85709: PUSH
85710: LD_INT 0
85712: LESS
85713: IFFALSE 85730
// _x := _x * - 1 ;
85715: LD_ADDR_VAR 0 6
85719: PUSH
85720: LD_VAR 0 6
85724: PUSH
85725: LD_INT 1
85727: NEG
85728: MUL
85729: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85730: LD_ADDR_VAR 0 7
85734: PUSH
85735: LD_VAR 0 2
85739: PUSH
85740: LD_VAR 0 4
85744: PLUS
85745: PUSH
85746: LD_INT 2
85748: DIV
85749: ST_TO_ADDR
// if _y < 0 then
85750: LD_VAR 0 7
85754: PUSH
85755: LD_INT 0
85757: LESS
85758: IFFALSE 85775
// _y := _y * - 1 ;
85760: LD_ADDR_VAR 0 7
85764: PUSH
85765: LD_VAR 0 7
85769: PUSH
85770: LD_INT 1
85772: NEG
85773: MUL
85774: ST_TO_ADDR
// result := [ _x , _y ] ;
85775: LD_ADDR_VAR 0 5
85779: PUSH
85780: LD_VAR 0 6
85784: PUSH
85785: LD_VAR 0 7
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: ST_TO_ADDR
// end ;
85794: LD_VAR 0 5
85798: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85799: LD_INT 0
85801: PPUSH
85802: PPUSH
85803: PPUSH
85804: PPUSH
// task := GetTaskList ( unit ) ;
85805: LD_ADDR_VAR 0 7
85809: PUSH
85810: LD_VAR 0 1
85814: PPUSH
85815: CALL_OW 437
85819: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85820: LD_VAR 0 7
85824: NOT
85825: PUSH
85826: LD_VAR 0 1
85830: PPUSH
85831: LD_VAR 0 2
85835: PPUSH
85836: CALL_OW 308
85840: NOT
85841: AND
85842: IFFALSE 85846
// exit ;
85844: GO 85964
// if IsInArea ( unit , area ) then
85846: LD_VAR 0 1
85850: PPUSH
85851: LD_VAR 0 2
85855: PPUSH
85856: CALL_OW 308
85860: IFFALSE 85878
// begin ComMoveToArea ( unit , goAway ) ;
85862: LD_VAR 0 1
85866: PPUSH
85867: LD_VAR 0 3
85871: PPUSH
85872: CALL_OW 113
// exit ;
85876: GO 85964
// end ; if task [ 1 ] [ 1 ] <> M then
85878: LD_VAR 0 7
85882: PUSH
85883: LD_INT 1
85885: ARRAY
85886: PUSH
85887: LD_INT 1
85889: ARRAY
85890: PUSH
85891: LD_STRING M
85893: NONEQUAL
85894: IFFALSE 85898
// exit ;
85896: GO 85964
// x := task [ 1 ] [ 2 ] ;
85898: LD_ADDR_VAR 0 5
85902: PUSH
85903: LD_VAR 0 7
85907: PUSH
85908: LD_INT 1
85910: ARRAY
85911: PUSH
85912: LD_INT 2
85914: ARRAY
85915: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
85916: LD_ADDR_VAR 0 6
85920: PUSH
85921: LD_VAR 0 7
85925: PUSH
85926: LD_INT 1
85928: ARRAY
85929: PUSH
85930: LD_INT 3
85932: ARRAY
85933: ST_TO_ADDR
// if InArea ( x , y , area ) then
85934: LD_VAR 0 5
85938: PPUSH
85939: LD_VAR 0 6
85943: PPUSH
85944: LD_VAR 0 2
85948: PPUSH
85949: CALL_OW 309
85953: IFFALSE 85964
// ComStop ( unit ) ;
85955: LD_VAR 0 1
85959: PPUSH
85960: CALL_OW 141
// end ;
85964: LD_VAR 0 4
85968: RET
// export function Abs ( value ) ; begin
85969: LD_INT 0
85971: PPUSH
// result := value ;
85972: LD_ADDR_VAR 0 2
85976: PUSH
85977: LD_VAR 0 1
85981: ST_TO_ADDR
// if value < 0 then
85982: LD_VAR 0 1
85986: PUSH
85987: LD_INT 0
85989: LESS
85990: IFFALSE 86007
// result := value * - 1 ;
85992: LD_ADDR_VAR 0 2
85996: PUSH
85997: LD_VAR 0 1
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: MUL
86006: ST_TO_ADDR
// end ;
86007: LD_VAR 0 2
86011: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86012: LD_INT 0
86014: PPUSH
86015: PPUSH
86016: PPUSH
86017: PPUSH
86018: PPUSH
86019: PPUSH
86020: PPUSH
86021: PPUSH
// if not unit or not building then
86022: LD_VAR 0 1
86026: NOT
86027: PUSH
86028: LD_VAR 0 2
86032: NOT
86033: OR
86034: IFFALSE 86038
// exit ;
86036: GO 86264
// x := GetX ( building ) ;
86038: LD_ADDR_VAR 0 4
86042: PUSH
86043: LD_VAR 0 2
86047: PPUSH
86048: CALL_OW 250
86052: ST_TO_ADDR
// y := GetY ( building ) ;
86053: LD_ADDR_VAR 0 6
86057: PUSH
86058: LD_VAR 0 2
86062: PPUSH
86063: CALL_OW 251
86067: ST_TO_ADDR
// d := GetDir ( building ) ;
86068: LD_ADDR_VAR 0 8
86072: PUSH
86073: LD_VAR 0 2
86077: PPUSH
86078: CALL_OW 254
86082: ST_TO_ADDR
// r := 4 ;
86083: LD_ADDR_VAR 0 9
86087: PUSH
86088: LD_INT 4
86090: ST_TO_ADDR
// for i := 1 to 5 do
86091: LD_ADDR_VAR 0 10
86095: PUSH
86096: DOUBLE
86097: LD_INT 1
86099: DEC
86100: ST_TO_ADDR
86101: LD_INT 5
86103: PUSH
86104: FOR_TO
86105: IFFALSE 86262
// begin _x := ShiftX ( x , d , r + i ) ;
86107: LD_ADDR_VAR 0 5
86111: PUSH
86112: LD_VAR 0 4
86116: PPUSH
86117: LD_VAR 0 8
86121: PPUSH
86122: LD_VAR 0 9
86126: PUSH
86127: LD_VAR 0 10
86131: PLUS
86132: PPUSH
86133: CALL_OW 272
86137: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86138: LD_ADDR_VAR 0 7
86142: PUSH
86143: LD_VAR 0 6
86147: PPUSH
86148: LD_VAR 0 8
86152: PPUSH
86153: LD_VAR 0 9
86157: PUSH
86158: LD_VAR 0 10
86162: PLUS
86163: PPUSH
86164: CALL_OW 273
86168: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86169: LD_VAR 0 5
86173: PPUSH
86174: LD_VAR 0 7
86178: PPUSH
86179: CALL_OW 488
86183: PUSH
86184: LD_VAR 0 5
86188: PPUSH
86189: LD_VAR 0 7
86193: PPUSH
86194: CALL_OW 428
86198: PPUSH
86199: CALL_OW 247
86203: PUSH
86204: LD_INT 3
86206: PUSH
86207: LD_INT 2
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: IN
86214: NOT
86215: AND
86216: IFFALSE 86260
// begin ComMoveXY ( unit , _x , _y ) ;
86218: LD_VAR 0 1
86222: PPUSH
86223: LD_VAR 0 5
86227: PPUSH
86228: LD_VAR 0 7
86232: PPUSH
86233: CALL_OW 111
// result := [ _x , _y ] ;
86237: LD_ADDR_VAR 0 3
86241: PUSH
86242: LD_VAR 0 5
86246: PUSH
86247: LD_VAR 0 7
86251: PUSH
86252: EMPTY
86253: LIST
86254: LIST
86255: ST_TO_ADDR
// exit ;
86256: POP
86257: POP
86258: GO 86264
// end ; end ;
86260: GO 86104
86262: POP
86263: POP
// end ;
86264: LD_VAR 0 3
86268: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86269: LD_INT 0
86271: PPUSH
86272: PPUSH
86273: PPUSH
// result := 0 ;
86274: LD_ADDR_VAR 0 3
86278: PUSH
86279: LD_INT 0
86281: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86282: LD_VAR 0 1
86286: PUSH
86287: LD_INT 0
86289: LESS
86290: PUSH
86291: LD_VAR 0 1
86295: PUSH
86296: LD_INT 8
86298: GREATER
86299: OR
86300: PUSH
86301: LD_VAR 0 2
86305: PUSH
86306: LD_INT 0
86308: LESS
86309: OR
86310: PUSH
86311: LD_VAR 0 2
86315: PUSH
86316: LD_INT 8
86318: GREATER
86319: OR
86320: IFFALSE 86324
// exit ;
86322: GO 86399
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86324: LD_ADDR_VAR 0 4
86328: PUSH
86329: LD_INT 22
86331: PUSH
86332: LD_VAR 0 2
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PPUSH
86341: CALL_OW 69
86345: PUSH
86346: FOR_IN
86347: IFFALSE 86397
// begin un := UnitShoot ( i ) ;
86349: LD_ADDR_VAR 0 5
86353: PUSH
86354: LD_VAR 0 4
86358: PPUSH
86359: CALL_OW 504
86363: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86364: LD_VAR 0 5
86368: PPUSH
86369: CALL_OW 255
86373: PUSH
86374: LD_VAR 0 1
86378: EQUAL
86379: IFFALSE 86395
// begin result := un ;
86381: LD_ADDR_VAR 0 3
86385: PUSH
86386: LD_VAR 0 5
86390: ST_TO_ADDR
// exit ;
86391: POP
86392: POP
86393: GO 86399
// end ; end ;
86395: GO 86346
86397: POP
86398: POP
// end ;
86399: LD_VAR 0 3
86403: RET
// export function GetCargoBay ( units ) ; begin
86404: LD_INT 0
86406: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86407: LD_ADDR_VAR 0 2
86411: PUSH
86412: LD_VAR 0 1
86416: PPUSH
86417: LD_INT 2
86419: PUSH
86420: LD_INT 34
86422: PUSH
86423: LD_INT 12
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 34
86432: PUSH
86433: LD_INT 51
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 34
86442: PUSH
86443: LD_INT 32
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 34
86452: PUSH
86453: LD_EXP 95
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: PPUSH
86469: CALL_OW 72
86473: ST_TO_ADDR
// end ;
86474: LD_VAR 0 2
86478: RET
// export function Negate ( value ) ; begin
86479: LD_INT 0
86481: PPUSH
// result := not value ;
86482: LD_ADDR_VAR 0 2
86486: PUSH
86487: LD_VAR 0 1
86491: NOT
86492: ST_TO_ADDR
// end ;
86493: LD_VAR 0 2
86497: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
86498: LD_INT 0
86500: PPUSH
// if x1 = x2 then
86501: LD_VAR 0 1
86505: PUSH
86506: LD_VAR 0 3
86510: EQUAL
86511: IFFALSE 86545
// begin if y1 > y2 then
86513: LD_VAR 0 2
86517: PUSH
86518: LD_VAR 0 4
86522: GREATER
86523: IFFALSE 86535
// result := 0 else
86525: LD_ADDR_VAR 0 5
86529: PUSH
86530: LD_INT 0
86532: ST_TO_ADDR
86533: GO 86543
// result := 3 ;
86535: LD_ADDR_VAR 0 5
86539: PUSH
86540: LD_INT 3
86542: ST_TO_ADDR
// exit ;
86543: GO 86631
// end ; if y1 = y2 then
86545: LD_VAR 0 2
86549: PUSH
86550: LD_VAR 0 4
86554: EQUAL
86555: IFFALSE 86589
// begin if x1 > x2 then
86557: LD_VAR 0 1
86561: PUSH
86562: LD_VAR 0 3
86566: GREATER
86567: IFFALSE 86579
// result := 1 else
86569: LD_ADDR_VAR 0 5
86573: PUSH
86574: LD_INT 1
86576: ST_TO_ADDR
86577: GO 86587
// result := 4 ;
86579: LD_ADDR_VAR 0 5
86583: PUSH
86584: LD_INT 4
86586: ST_TO_ADDR
// exit ;
86587: GO 86631
// end ; if x1 > x2 and y1 > y2 then
86589: LD_VAR 0 1
86593: PUSH
86594: LD_VAR 0 3
86598: GREATER
86599: PUSH
86600: LD_VAR 0 2
86604: PUSH
86605: LD_VAR 0 4
86609: GREATER
86610: AND
86611: IFFALSE 86623
// result := 2 else
86613: LD_ADDR_VAR 0 5
86617: PUSH
86618: LD_INT 2
86620: ST_TO_ADDR
86621: GO 86631
// result := 5 ;
86623: LD_ADDR_VAR 0 5
86627: PUSH
86628: LD_INT 5
86630: ST_TO_ADDR
// end ;
86631: LD_VAR 0 5
86635: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86636: LD_INT 0
86638: PPUSH
86639: PPUSH
// if not driver or not IsInUnit ( driver ) then
86640: LD_VAR 0 1
86644: NOT
86645: PUSH
86646: LD_VAR 0 1
86650: PPUSH
86651: CALL_OW 310
86655: NOT
86656: OR
86657: IFFALSE 86661
// exit ;
86659: GO 86751
// vehicle := IsInUnit ( driver ) ;
86661: LD_ADDR_VAR 0 3
86665: PUSH
86666: LD_VAR 0 1
86670: PPUSH
86671: CALL_OW 310
86675: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86676: LD_VAR 0 1
86680: PPUSH
86681: LD_STRING \
86683: PUSH
86684: LD_INT 0
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 0
86692: PUSH
86693: LD_INT 0
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: PUSH
86711: LD_STRING E
86713: PUSH
86714: LD_INT 0
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: LD_VAR 0 3
86724: PUSH
86725: LD_INT 0
86727: PUSH
86728: LD_INT 0
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PPUSH
86747: CALL_OW 446
// end ;
86751: LD_VAR 0 2
86755: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86756: LD_INT 0
86758: PPUSH
86759: PPUSH
// if not driver or not IsInUnit ( driver ) then
86760: LD_VAR 0 1
86764: NOT
86765: PUSH
86766: LD_VAR 0 1
86770: PPUSH
86771: CALL_OW 310
86775: NOT
86776: OR
86777: IFFALSE 86781
// exit ;
86779: GO 86871
// vehicle := IsInUnit ( driver ) ;
86781: LD_ADDR_VAR 0 3
86785: PUSH
86786: LD_VAR 0 1
86790: PPUSH
86791: CALL_OW 310
86795: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86796: LD_VAR 0 1
86800: PPUSH
86801: LD_STRING \
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: LD_INT 0
86812: PUSH
86813: LD_INT 0
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: LD_INT 0
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: PUSH
86831: LD_STRING E
86833: PUSH
86834: LD_INT 0
86836: PUSH
86837: LD_INT 0
86839: PUSH
86840: LD_VAR 0 3
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 0
86850: PUSH
86851: LD_INT 0
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PPUSH
86867: CALL_OW 447
// end ;
86871: LD_VAR 0 2
86875: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
86876: LD_INT 0
86878: PPUSH
86879: PPUSH
86880: PPUSH
// tmp := [ ] ;
86881: LD_ADDR_VAR 0 5
86885: PUSH
86886: EMPTY
86887: ST_TO_ADDR
// for i in units do
86888: LD_ADDR_VAR 0 4
86892: PUSH
86893: LD_VAR 0 1
86897: PUSH
86898: FOR_IN
86899: IFFALSE 86937
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
86901: LD_ADDR_VAR 0 5
86905: PUSH
86906: LD_VAR 0 5
86910: PPUSH
86911: LD_VAR 0 5
86915: PUSH
86916: LD_INT 1
86918: PLUS
86919: PPUSH
86920: LD_VAR 0 4
86924: PPUSH
86925: CALL_OW 256
86929: PPUSH
86930: CALL_OW 2
86934: ST_TO_ADDR
86935: GO 86898
86937: POP
86938: POP
// if not tmp then
86939: LD_VAR 0 5
86943: NOT
86944: IFFALSE 86948
// exit ;
86946: GO 86996
// if asc then
86948: LD_VAR 0 2
86952: IFFALSE 86976
// result := SortListByListAsc ( units , tmp ) else
86954: LD_ADDR_VAR 0 3
86958: PUSH
86959: LD_VAR 0 1
86963: PPUSH
86964: LD_VAR 0 5
86968: PPUSH
86969: CALL_OW 76
86973: ST_TO_ADDR
86974: GO 86996
// result := SortListByListDesc ( units , tmp ) ;
86976: LD_ADDR_VAR 0 3
86980: PUSH
86981: LD_VAR 0 1
86985: PPUSH
86986: LD_VAR 0 5
86990: PPUSH
86991: CALL_OW 77
86995: ST_TO_ADDR
// end ;
86996: LD_VAR 0 3
87000: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87001: LD_INT 0
87003: PPUSH
87004: PPUSH
// task := GetTaskList ( mech ) ;
87005: LD_ADDR_VAR 0 4
87009: PUSH
87010: LD_VAR 0 1
87014: PPUSH
87015: CALL_OW 437
87019: ST_TO_ADDR
// if not task then
87020: LD_VAR 0 4
87024: NOT
87025: IFFALSE 87029
// exit ;
87027: GO 87071
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
87029: LD_ADDR_VAR 0 3
87033: PUSH
87034: LD_VAR 0 4
87038: PUSH
87039: LD_INT 1
87041: ARRAY
87042: PUSH
87043: LD_INT 1
87045: ARRAY
87046: PUSH
87047: LD_STRING r
87049: EQUAL
87050: PUSH
87051: LD_VAR 0 4
87055: PUSH
87056: LD_INT 1
87058: ARRAY
87059: PUSH
87060: LD_INT 4
87062: ARRAY
87063: PUSH
87064: LD_VAR 0 2
87068: EQUAL
87069: AND
87070: ST_TO_ADDR
// end ;
87071: LD_VAR 0 3
87075: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
87076: LD_INT 0
87078: PPUSH
// SetDir ( unit , d ) ;
87079: LD_VAR 0 1
87083: PPUSH
87084: LD_VAR 0 4
87088: PPUSH
87089: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87093: LD_VAR 0 1
87097: PPUSH
87098: LD_VAR 0 2
87102: PPUSH
87103: LD_VAR 0 3
87107: PPUSH
87108: LD_VAR 0 5
87112: PPUSH
87113: CALL_OW 48
// end ;
87117: LD_VAR 0 6
87121: RET
// export function ToNaturalNumber ( number ) ; begin
87122: LD_INT 0
87124: PPUSH
// result := number div 1 ;
87125: LD_ADDR_VAR 0 2
87129: PUSH
87130: LD_VAR 0 1
87134: PUSH
87135: LD_INT 1
87137: DIV
87138: ST_TO_ADDR
// if number < 0 then
87139: LD_VAR 0 1
87143: PUSH
87144: LD_INT 0
87146: LESS
87147: IFFALSE 87157
// result := 0 ;
87149: LD_ADDR_VAR 0 2
87153: PUSH
87154: LD_INT 0
87156: ST_TO_ADDR
// end ;
87157: LD_VAR 0 2
87161: RET
// export function SortByClass ( units , class ) ; var un ; begin
87162: LD_INT 0
87164: PPUSH
87165: PPUSH
// if not units or not class then
87166: LD_VAR 0 1
87170: NOT
87171: PUSH
87172: LD_VAR 0 2
87176: NOT
87177: OR
87178: IFFALSE 87182
// exit ;
87180: GO 87277
// result := [ ] ;
87182: LD_ADDR_VAR 0 3
87186: PUSH
87187: EMPTY
87188: ST_TO_ADDR
// for un in units do
87189: LD_ADDR_VAR 0 4
87193: PUSH
87194: LD_VAR 0 1
87198: PUSH
87199: FOR_IN
87200: IFFALSE 87275
// if GetClass ( un ) = class then
87202: LD_VAR 0 4
87206: PPUSH
87207: CALL_OW 257
87211: PUSH
87212: LD_VAR 0 2
87216: EQUAL
87217: IFFALSE 87244
// result := Insert ( result , 1 , un ) else
87219: LD_ADDR_VAR 0 3
87223: PUSH
87224: LD_VAR 0 3
87228: PPUSH
87229: LD_INT 1
87231: PPUSH
87232: LD_VAR 0 4
87236: PPUSH
87237: CALL_OW 2
87241: ST_TO_ADDR
87242: GO 87273
// result := Replace ( result , result + 1 , un ) ;
87244: LD_ADDR_VAR 0 3
87248: PUSH
87249: LD_VAR 0 3
87253: PPUSH
87254: LD_VAR 0 3
87258: PUSH
87259: LD_INT 1
87261: PLUS
87262: PPUSH
87263: LD_VAR 0 4
87267: PPUSH
87268: CALL_OW 1
87272: ST_TO_ADDR
87273: GO 87199
87275: POP
87276: POP
// end ;
87277: LD_VAR 0 3
87281: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
87282: LD_INT 0
87284: PPUSH
87285: PPUSH
87286: PPUSH
87287: PPUSH
87288: PPUSH
87289: PPUSH
87290: PPUSH
// result := [ ] ;
87291: LD_ADDR_VAR 0 4
87295: PUSH
87296: EMPTY
87297: ST_TO_ADDR
// if x - r < 0 then
87298: LD_VAR 0 1
87302: PUSH
87303: LD_VAR 0 3
87307: MINUS
87308: PUSH
87309: LD_INT 0
87311: LESS
87312: IFFALSE 87324
// min_x := 0 else
87314: LD_ADDR_VAR 0 8
87318: PUSH
87319: LD_INT 0
87321: ST_TO_ADDR
87322: GO 87340
// min_x := x - r ;
87324: LD_ADDR_VAR 0 8
87328: PUSH
87329: LD_VAR 0 1
87333: PUSH
87334: LD_VAR 0 3
87338: MINUS
87339: ST_TO_ADDR
// if y - r < 0 then
87340: LD_VAR 0 2
87344: PUSH
87345: LD_VAR 0 3
87349: MINUS
87350: PUSH
87351: LD_INT 0
87353: LESS
87354: IFFALSE 87366
// min_y := 0 else
87356: LD_ADDR_VAR 0 7
87360: PUSH
87361: LD_INT 0
87363: ST_TO_ADDR
87364: GO 87382
// min_y := y - r ;
87366: LD_ADDR_VAR 0 7
87370: PUSH
87371: LD_VAR 0 2
87375: PUSH
87376: LD_VAR 0 3
87380: MINUS
87381: ST_TO_ADDR
// max_x := x + r ;
87382: LD_ADDR_VAR 0 9
87386: PUSH
87387: LD_VAR 0 1
87391: PUSH
87392: LD_VAR 0 3
87396: PLUS
87397: ST_TO_ADDR
// max_y := y + r ;
87398: LD_ADDR_VAR 0 10
87402: PUSH
87403: LD_VAR 0 2
87407: PUSH
87408: LD_VAR 0 3
87412: PLUS
87413: ST_TO_ADDR
// for _x = min_x to max_x do
87414: LD_ADDR_VAR 0 5
87418: PUSH
87419: DOUBLE
87420: LD_VAR 0 8
87424: DEC
87425: ST_TO_ADDR
87426: LD_VAR 0 9
87430: PUSH
87431: FOR_TO
87432: IFFALSE 87533
// for _y = min_y to max_y do
87434: LD_ADDR_VAR 0 6
87438: PUSH
87439: DOUBLE
87440: LD_VAR 0 7
87444: DEC
87445: ST_TO_ADDR
87446: LD_VAR 0 10
87450: PUSH
87451: FOR_TO
87452: IFFALSE 87529
// begin if not ValidHex ( _x , _y ) then
87454: LD_VAR 0 5
87458: PPUSH
87459: LD_VAR 0 6
87463: PPUSH
87464: CALL_OW 488
87468: NOT
87469: IFFALSE 87473
// continue ;
87471: GO 87451
// if GetResourceTypeXY ( _x , _y ) then
87473: LD_VAR 0 5
87477: PPUSH
87478: LD_VAR 0 6
87482: PPUSH
87483: CALL_OW 283
87487: IFFALSE 87527
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
87489: LD_ADDR_VAR 0 4
87493: PUSH
87494: LD_VAR 0 4
87498: PPUSH
87499: LD_VAR 0 4
87503: PUSH
87504: LD_INT 1
87506: PLUS
87507: PPUSH
87508: LD_VAR 0 5
87512: PUSH
87513: LD_VAR 0 6
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PPUSH
87522: CALL_OW 1
87526: ST_TO_ADDR
// end ;
87527: GO 87451
87529: POP
87530: POP
87531: GO 87431
87533: POP
87534: POP
// end ;
87535: LD_VAR 0 4
87539: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
87540: LD_INT 0
87542: PPUSH
87543: PPUSH
87544: PPUSH
87545: PPUSH
87546: PPUSH
87547: PPUSH
// if not units then
87548: LD_VAR 0 1
87552: NOT
87553: IFFALSE 87557
// exit ;
87555: GO 87958
// result := UnitFilter ( units , [ f_ok ] ) ;
87557: LD_ADDR_VAR 0 3
87561: PUSH
87562: LD_VAR 0 1
87566: PPUSH
87567: LD_INT 50
87569: PUSH
87570: EMPTY
87571: LIST
87572: PPUSH
87573: CALL_OW 72
87577: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
87578: LD_ADDR_VAR 0 7
87582: PUSH
87583: LD_VAR 0 1
87587: PUSH
87588: LD_INT 1
87590: ARRAY
87591: PPUSH
87592: CALL_OW 255
87596: ST_TO_ADDR
// if not result then
87597: LD_VAR 0 3
87601: NOT
87602: IFFALSE 87606
// exit ;
87604: GO 87958
// for i in result do
87606: LD_ADDR_VAR 0 4
87610: PUSH
87611: LD_VAR 0 3
87615: PUSH
87616: FOR_IN
87617: IFFALSE 87956
// begin tag := GetTag ( i ) + 1 ;
87619: LD_ADDR_VAR 0 8
87623: PUSH
87624: LD_VAR 0 4
87628: PPUSH
87629: CALL_OW 110
87633: PUSH
87634: LD_INT 1
87636: PLUS
87637: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
87638: LD_ADDR_VAR 0 6
87642: PUSH
87643: LD_VAR 0 4
87647: PPUSH
87648: CALL_OW 250
87652: PPUSH
87653: LD_VAR 0 4
87657: PPUSH
87658: CALL_OW 251
87662: PPUSH
87663: LD_INT 6
87665: PPUSH
87666: CALL 87282 0 3
87670: ST_TO_ADDR
// if cr then
87671: LD_VAR 0 6
87675: IFFALSE 87714
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
87677: LD_VAR 0 4
87681: PPUSH
87682: LD_VAR 0 6
87686: PUSH
87687: LD_INT 1
87689: ARRAY
87690: PUSH
87691: LD_INT 1
87693: ARRAY
87694: PPUSH
87695: LD_VAR 0 6
87699: PUSH
87700: LD_INT 1
87702: ARRAY
87703: PUSH
87704: LD_INT 2
87706: ARRAY
87707: PPUSH
87708: CALL_OW 116
87712: GO 87954
// if path > tag then
87714: LD_VAR 0 2
87718: PUSH
87719: LD_VAR 0 8
87723: GREATER
87724: IFFALSE 87902
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
87726: LD_ADDR_VAR 0 5
87730: PUSH
87731: LD_INT 81
87733: PUSH
87734: LD_VAR 0 7
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: LD_INT 91
87745: PUSH
87746: LD_VAR 0 4
87750: PUSH
87751: LD_INT 12
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: LIST
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PPUSH
87763: CALL_OW 69
87767: ST_TO_ADDR
// if enemy then
87768: LD_VAR 0 5
87772: IFFALSE 87800
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
87774: LD_VAR 0 4
87778: PPUSH
87779: LD_VAR 0 5
87783: PPUSH
87784: LD_VAR 0 4
87788: PPUSH
87789: CALL_OW 74
87793: PPUSH
87794: CALL_OW 115
87798: GO 87900
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
87800: LD_VAR 0 4
87804: PPUSH
87805: LD_VAR 0 2
87809: PUSH
87810: LD_VAR 0 8
87814: ARRAY
87815: PUSH
87816: LD_INT 1
87818: ARRAY
87819: PPUSH
87820: LD_VAR 0 2
87824: PUSH
87825: LD_VAR 0 8
87829: ARRAY
87830: PUSH
87831: LD_INT 2
87833: ARRAY
87834: PPUSH
87835: CALL_OW 297
87839: PUSH
87840: LD_INT 6
87842: GREATER
87843: IFFALSE 87886
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
87845: LD_VAR 0 4
87849: PPUSH
87850: LD_VAR 0 2
87854: PUSH
87855: LD_VAR 0 8
87859: ARRAY
87860: PUSH
87861: LD_INT 1
87863: ARRAY
87864: PPUSH
87865: LD_VAR 0 2
87869: PUSH
87870: LD_VAR 0 8
87874: ARRAY
87875: PUSH
87876: LD_INT 2
87878: ARRAY
87879: PPUSH
87880: CALL_OW 114
87884: GO 87900
// SetTag ( i , tag ) ;
87886: LD_VAR 0 4
87890: PPUSH
87891: LD_VAR 0 8
87895: PPUSH
87896: CALL_OW 109
// end else
87900: GO 87954
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
87902: LD_ADDR_VAR 0 5
87906: PUSH
87907: LD_INT 81
87909: PUSH
87910: LD_VAR 0 7
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PPUSH
87919: CALL_OW 69
87923: ST_TO_ADDR
// if enemy then
87924: LD_VAR 0 5
87928: IFFALSE 87954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
87930: LD_VAR 0 4
87934: PPUSH
87935: LD_VAR 0 5
87939: PPUSH
87940: LD_VAR 0 4
87944: PPUSH
87945: CALL_OW 74
87949: PPUSH
87950: CALL_OW 115
// end ; end ;
87954: GO 87616
87956: POP
87957: POP
// end ; end_of_file
87958: LD_VAR 0 3
87962: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
87963: LD_INT 0
87965: PPUSH
// ar_miner := 81 ;
87966: LD_ADDR_EXP 101
87970: PUSH
87971: LD_INT 81
87973: ST_TO_ADDR
// ar_crane := 88 ;
87974: LD_ADDR_EXP 100
87978: PUSH
87979: LD_INT 88
87981: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87982: LD_ADDR_EXP 95
87986: PUSH
87987: LD_INT 89
87989: ST_TO_ADDR
// us_hack := 99 ;
87990: LD_ADDR_EXP 96
87994: PUSH
87995: LD_INT 99
87997: ST_TO_ADDR
// us_artillery := 97 ;
87998: LD_ADDR_EXP 97
88002: PUSH
88003: LD_INT 97
88005: ST_TO_ADDR
// ar_bio_bomb := 91 ;
88006: LD_ADDR_EXP 98
88010: PUSH
88011: LD_INT 91
88013: ST_TO_ADDR
// ar_mortar := 92 ;
88014: LD_ADDR_EXP 99
88018: PUSH
88019: LD_INT 92
88021: ST_TO_ADDR
// ru_radar := 98 ;
88022: LD_ADDR_EXP 94
88026: PUSH
88027: LD_INT 98
88029: ST_TO_ADDR
// tech_Artillery := 80 ;
88030: LD_ADDR_EXP 102
88034: PUSH
88035: LD_INT 80
88037: ST_TO_ADDR
// tech_RadMat := 81 ;
88038: LD_ADDR_EXP 103
88042: PUSH
88043: LD_INT 81
88045: ST_TO_ADDR
// tech_BasicTools := 82 ;
88046: LD_ADDR_EXP 104
88050: PUSH
88051: LD_INT 82
88053: ST_TO_ADDR
// tech_Cargo := 83 ;
88054: LD_ADDR_EXP 105
88058: PUSH
88059: LD_INT 83
88061: ST_TO_ADDR
// tech_Track := 84 ;
88062: LD_ADDR_EXP 106
88066: PUSH
88067: LD_INT 84
88069: ST_TO_ADDR
// tech_Crane := 85 ;
88070: LD_ADDR_EXP 107
88074: PUSH
88075: LD_INT 85
88077: ST_TO_ADDR
// tech_Bulldozer := 86 ;
88078: LD_ADDR_EXP 108
88082: PUSH
88083: LD_INT 86
88085: ST_TO_ADDR
// tech_Hovercraft := 87 ;
88086: LD_ADDR_EXP 109
88090: PUSH
88091: LD_INT 87
88093: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
88094: LD_ADDR_EXP 110
88098: PUSH
88099: LD_INT 88
88101: ST_TO_ADDR
// class_mastodont := 31 ;
88102: LD_ADDR_EXP 111
88106: PUSH
88107: LD_INT 31
88109: ST_TO_ADDR
// class_horse := 21 ;
88110: LD_ADDR_EXP 112
88114: PUSH
88115: LD_INT 21
88117: ST_TO_ADDR
// end ;
88118: LD_VAR 0 1
88122: RET
// every 1 do
88123: GO 88125
88125: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
88126: CALL 87963 0 0
88130: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88131: LD_INT 0
88133: PPUSH
// if p2 = 100 then
88134: LD_VAR 0 2
88138: PUSH
88139: LD_INT 100
88141: EQUAL
88142: IFFALSE 89091
// begin if not StreamModeActive then
88144: LD_EXP 113
88148: NOT
88149: IFFALSE 88159
// StreamModeActive := true ;
88151: LD_ADDR_EXP 113
88155: PUSH
88156: LD_INT 1
88158: ST_TO_ADDR
// if p3 = 0 then
88159: LD_VAR 0 3
88163: PUSH
88164: LD_INT 0
88166: EQUAL
88167: IFFALSE 88173
// InitStreamMode ;
88169: CALL 89251 0 0
// if p3 = 1 then
88173: LD_VAR 0 3
88177: PUSH
88178: LD_INT 1
88180: EQUAL
88181: IFFALSE 88191
// sRocket := true ;
88183: LD_ADDR_EXP 118
88187: PUSH
88188: LD_INT 1
88190: ST_TO_ADDR
// if p3 = 2 then
88191: LD_VAR 0 3
88195: PUSH
88196: LD_INT 2
88198: EQUAL
88199: IFFALSE 88209
// sSpeed := true ;
88201: LD_ADDR_EXP 117
88205: PUSH
88206: LD_INT 1
88208: ST_TO_ADDR
// if p3 = 3 then
88209: LD_VAR 0 3
88213: PUSH
88214: LD_INT 3
88216: EQUAL
88217: IFFALSE 88227
// sEngine := true ;
88219: LD_ADDR_EXP 119
88223: PUSH
88224: LD_INT 1
88226: ST_TO_ADDR
// if p3 = 4 then
88227: LD_VAR 0 3
88231: PUSH
88232: LD_INT 4
88234: EQUAL
88235: IFFALSE 88245
// sSpec := true ;
88237: LD_ADDR_EXP 116
88241: PUSH
88242: LD_INT 1
88244: ST_TO_ADDR
// if p3 = 5 then
88245: LD_VAR 0 3
88249: PUSH
88250: LD_INT 5
88252: EQUAL
88253: IFFALSE 88263
// sLevel := true ;
88255: LD_ADDR_EXP 120
88259: PUSH
88260: LD_INT 1
88262: ST_TO_ADDR
// if p3 = 6 then
88263: LD_VAR 0 3
88267: PUSH
88268: LD_INT 6
88270: EQUAL
88271: IFFALSE 88281
// sArmoury := true ;
88273: LD_ADDR_EXP 121
88277: PUSH
88278: LD_INT 1
88280: ST_TO_ADDR
// if p3 = 7 then
88281: LD_VAR 0 3
88285: PUSH
88286: LD_INT 7
88288: EQUAL
88289: IFFALSE 88299
// sRadar := true ;
88291: LD_ADDR_EXP 122
88295: PUSH
88296: LD_INT 1
88298: ST_TO_ADDR
// if p3 = 8 then
88299: LD_VAR 0 3
88303: PUSH
88304: LD_INT 8
88306: EQUAL
88307: IFFALSE 88317
// sBunker := true ;
88309: LD_ADDR_EXP 123
88313: PUSH
88314: LD_INT 1
88316: ST_TO_ADDR
// if p3 = 9 then
88317: LD_VAR 0 3
88321: PUSH
88322: LD_INT 9
88324: EQUAL
88325: IFFALSE 88335
// sHack := true ;
88327: LD_ADDR_EXP 124
88331: PUSH
88332: LD_INT 1
88334: ST_TO_ADDR
// if p3 = 10 then
88335: LD_VAR 0 3
88339: PUSH
88340: LD_INT 10
88342: EQUAL
88343: IFFALSE 88353
// sFire := true ;
88345: LD_ADDR_EXP 125
88349: PUSH
88350: LD_INT 1
88352: ST_TO_ADDR
// if p3 = 11 then
88353: LD_VAR 0 3
88357: PUSH
88358: LD_INT 11
88360: EQUAL
88361: IFFALSE 88371
// sRefresh := true ;
88363: LD_ADDR_EXP 126
88367: PUSH
88368: LD_INT 1
88370: ST_TO_ADDR
// if p3 = 12 then
88371: LD_VAR 0 3
88375: PUSH
88376: LD_INT 12
88378: EQUAL
88379: IFFALSE 88389
// sExp := true ;
88381: LD_ADDR_EXP 127
88385: PUSH
88386: LD_INT 1
88388: ST_TO_ADDR
// if p3 = 13 then
88389: LD_VAR 0 3
88393: PUSH
88394: LD_INT 13
88396: EQUAL
88397: IFFALSE 88407
// sDepot := true ;
88399: LD_ADDR_EXP 128
88403: PUSH
88404: LD_INT 1
88406: ST_TO_ADDR
// if p3 = 14 then
88407: LD_VAR 0 3
88411: PUSH
88412: LD_INT 14
88414: EQUAL
88415: IFFALSE 88425
// sFlag := true ;
88417: LD_ADDR_EXP 129
88421: PUSH
88422: LD_INT 1
88424: ST_TO_ADDR
// if p3 = 15 then
88425: LD_VAR 0 3
88429: PUSH
88430: LD_INT 15
88432: EQUAL
88433: IFFALSE 88443
// sKamikadze := true ;
88435: LD_ADDR_EXP 137
88439: PUSH
88440: LD_INT 1
88442: ST_TO_ADDR
// if p3 = 16 then
88443: LD_VAR 0 3
88447: PUSH
88448: LD_INT 16
88450: EQUAL
88451: IFFALSE 88461
// sTroll := true ;
88453: LD_ADDR_EXP 138
88457: PUSH
88458: LD_INT 1
88460: ST_TO_ADDR
// if p3 = 17 then
88461: LD_VAR 0 3
88465: PUSH
88466: LD_INT 17
88468: EQUAL
88469: IFFALSE 88479
// sSlow := true ;
88471: LD_ADDR_EXP 139
88475: PUSH
88476: LD_INT 1
88478: ST_TO_ADDR
// if p3 = 18 then
88479: LD_VAR 0 3
88483: PUSH
88484: LD_INT 18
88486: EQUAL
88487: IFFALSE 88497
// sLack := true ;
88489: LD_ADDR_EXP 140
88493: PUSH
88494: LD_INT 1
88496: ST_TO_ADDR
// if p3 = 19 then
88497: LD_VAR 0 3
88501: PUSH
88502: LD_INT 19
88504: EQUAL
88505: IFFALSE 88515
// sTank := true ;
88507: LD_ADDR_EXP 142
88511: PUSH
88512: LD_INT 1
88514: ST_TO_ADDR
// if p3 = 20 then
88515: LD_VAR 0 3
88519: PUSH
88520: LD_INT 20
88522: EQUAL
88523: IFFALSE 88533
// sRemote := true ;
88525: LD_ADDR_EXP 143
88529: PUSH
88530: LD_INT 1
88532: ST_TO_ADDR
// if p3 = 21 then
88533: LD_VAR 0 3
88537: PUSH
88538: LD_INT 21
88540: EQUAL
88541: IFFALSE 88551
// sPowell := true ;
88543: LD_ADDR_EXP 144
88547: PUSH
88548: LD_INT 1
88550: ST_TO_ADDR
// if p3 = 22 then
88551: LD_VAR 0 3
88555: PUSH
88556: LD_INT 22
88558: EQUAL
88559: IFFALSE 88569
// sTeleport := true ;
88561: LD_ADDR_EXP 147
88565: PUSH
88566: LD_INT 1
88568: ST_TO_ADDR
// if p3 = 23 then
88569: LD_VAR 0 3
88573: PUSH
88574: LD_INT 23
88576: EQUAL
88577: IFFALSE 88587
// sOilTower := true ;
88579: LD_ADDR_EXP 149
88583: PUSH
88584: LD_INT 1
88586: ST_TO_ADDR
// if p3 = 24 then
88587: LD_VAR 0 3
88591: PUSH
88592: LD_INT 24
88594: EQUAL
88595: IFFALSE 88605
// sShovel := true ;
88597: LD_ADDR_EXP 150
88601: PUSH
88602: LD_INT 1
88604: ST_TO_ADDR
// if p3 = 25 then
88605: LD_VAR 0 3
88609: PUSH
88610: LD_INT 25
88612: EQUAL
88613: IFFALSE 88623
// sSheik := true ;
88615: LD_ADDR_EXP 151
88619: PUSH
88620: LD_INT 1
88622: ST_TO_ADDR
// if p3 = 26 then
88623: LD_VAR 0 3
88627: PUSH
88628: LD_INT 26
88630: EQUAL
88631: IFFALSE 88641
// sEarthquake := true ;
88633: LD_ADDR_EXP 153
88637: PUSH
88638: LD_INT 1
88640: ST_TO_ADDR
// if p3 = 27 then
88641: LD_VAR 0 3
88645: PUSH
88646: LD_INT 27
88648: EQUAL
88649: IFFALSE 88659
// sAI := true ;
88651: LD_ADDR_EXP 154
88655: PUSH
88656: LD_INT 1
88658: ST_TO_ADDR
// if p3 = 28 then
88659: LD_VAR 0 3
88663: PUSH
88664: LD_INT 28
88666: EQUAL
88667: IFFALSE 88677
// sCargo := true ;
88669: LD_ADDR_EXP 157
88673: PUSH
88674: LD_INT 1
88676: ST_TO_ADDR
// if p3 = 29 then
88677: LD_VAR 0 3
88681: PUSH
88682: LD_INT 29
88684: EQUAL
88685: IFFALSE 88695
// sDLaser := true ;
88687: LD_ADDR_EXP 158
88691: PUSH
88692: LD_INT 1
88694: ST_TO_ADDR
// if p3 = 30 then
88695: LD_VAR 0 3
88699: PUSH
88700: LD_INT 30
88702: EQUAL
88703: IFFALSE 88713
// sExchange := true ;
88705: LD_ADDR_EXP 159
88709: PUSH
88710: LD_INT 1
88712: ST_TO_ADDR
// if p3 = 31 then
88713: LD_VAR 0 3
88717: PUSH
88718: LD_INT 31
88720: EQUAL
88721: IFFALSE 88731
// sFac := true ;
88723: LD_ADDR_EXP 160
88727: PUSH
88728: LD_INT 1
88730: ST_TO_ADDR
// if p3 = 32 then
88731: LD_VAR 0 3
88735: PUSH
88736: LD_INT 32
88738: EQUAL
88739: IFFALSE 88749
// sPower := true ;
88741: LD_ADDR_EXP 161
88745: PUSH
88746: LD_INT 1
88748: ST_TO_ADDR
// if p3 = 33 then
88749: LD_VAR 0 3
88753: PUSH
88754: LD_INT 33
88756: EQUAL
88757: IFFALSE 88767
// sRandom := true ;
88759: LD_ADDR_EXP 162
88763: PUSH
88764: LD_INT 1
88766: ST_TO_ADDR
// if p3 = 34 then
88767: LD_VAR 0 3
88771: PUSH
88772: LD_INT 34
88774: EQUAL
88775: IFFALSE 88785
// sShield := true ;
88777: LD_ADDR_EXP 163
88781: PUSH
88782: LD_INT 1
88784: ST_TO_ADDR
// if p3 = 35 then
88785: LD_VAR 0 3
88789: PUSH
88790: LD_INT 35
88792: EQUAL
88793: IFFALSE 88803
// sTime := true ;
88795: LD_ADDR_EXP 164
88799: PUSH
88800: LD_INT 1
88802: ST_TO_ADDR
// if p3 = 36 then
88803: LD_VAR 0 3
88807: PUSH
88808: LD_INT 36
88810: EQUAL
88811: IFFALSE 88821
// sTools := true ;
88813: LD_ADDR_EXP 165
88817: PUSH
88818: LD_INT 1
88820: ST_TO_ADDR
// if p3 = 101 then
88821: LD_VAR 0 3
88825: PUSH
88826: LD_INT 101
88828: EQUAL
88829: IFFALSE 88839
// sSold := true ;
88831: LD_ADDR_EXP 130
88835: PUSH
88836: LD_INT 1
88838: ST_TO_ADDR
// if p3 = 102 then
88839: LD_VAR 0 3
88843: PUSH
88844: LD_INT 102
88846: EQUAL
88847: IFFALSE 88857
// sDiff := true ;
88849: LD_ADDR_EXP 131
88853: PUSH
88854: LD_INT 1
88856: ST_TO_ADDR
// if p3 = 103 then
88857: LD_VAR 0 3
88861: PUSH
88862: LD_INT 103
88864: EQUAL
88865: IFFALSE 88875
// sFog := true ;
88867: LD_ADDR_EXP 134
88871: PUSH
88872: LD_INT 1
88874: ST_TO_ADDR
// if p3 = 104 then
88875: LD_VAR 0 3
88879: PUSH
88880: LD_INT 104
88882: EQUAL
88883: IFFALSE 88893
// sReset := true ;
88885: LD_ADDR_EXP 135
88889: PUSH
88890: LD_INT 1
88892: ST_TO_ADDR
// if p3 = 105 then
88893: LD_VAR 0 3
88897: PUSH
88898: LD_INT 105
88900: EQUAL
88901: IFFALSE 88911
// sSun := true ;
88903: LD_ADDR_EXP 136
88907: PUSH
88908: LD_INT 1
88910: ST_TO_ADDR
// if p3 = 106 then
88911: LD_VAR 0 3
88915: PUSH
88916: LD_INT 106
88918: EQUAL
88919: IFFALSE 88929
// sTiger := true ;
88921: LD_ADDR_EXP 132
88925: PUSH
88926: LD_INT 1
88928: ST_TO_ADDR
// if p3 = 107 then
88929: LD_VAR 0 3
88933: PUSH
88934: LD_INT 107
88936: EQUAL
88937: IFFALSE 88947
// sBomb := true ;
88939: LD_ADDR_EXP 133
88943: PUSH
88944: LD_INT 1
88946: ST_TO_ADDR
// if p3 = 108 then
88947: LD_VAR 0 3
88951: PUSH
88952: LD_INT 108
88954: EQUAL
88955: IFFALSE 88965
// sWound := true ;
88957: LD_ADDR_EXP 141
88961: PUSH
88962: LD_INT 1
88964: ST_TO_ADDR
// if p3 = 109 then
88965: LD_VAR 0 3
88969: PUSH
88970: LD_INT 109
88972: EQUAL
88973: IFFALSE 88983
// sBetray := true ;
88975: LD_ADDR_EXP 145
88979: PUSH
88980: LD_INT 1
88982: ST_TO_ADDR
// if p3 = 110 then
88983: LD_VAR 0 3
88987: PUSH
88988: LD_INT 110
88990: EQUAL
88991: IFFALSE 89001
// sContamin := true ;
88993: LD_ADDR_EXP 146
88997: PUSH
88998: LD_INT 1
89000: ST_TO_ADDR
// if p3 = 111 then
89001: LD_VAR 0 3
89005: PUSH
89006: LD_INT 111
89008: EQUAL
89009: IFFALSE 89019
// sOil := true ;
89011: LD_ADDR_EXP 148
89015: PUSH
89016: LD_INT 1
89018: ST_TO_ADDR
// if p3 = 112 then
89019: LD_VAR 0 3
89023: PUSH
89024: LD_INT 112
89026: EQUAL
89027: IFFALSE 89037
// sStu := true ;
89029: LD_ADDR_EXP 152
89033: PUSH
89034: LD_INT 1
89036: ST_TO_ADDR
// if p3 = 113 then
89037: LD_VAR 0 3
89041: PUSH
89042: LD_INT 113
89044: EQUAL
89045: IFFALSE 89055
// sBazooka := true ;
89047: LD_ADDR_EXP 155
89051: PUSH
89052: LD_INT 1
89054: ST_TO_ADDR
// if p3 = 114 then
89055: LD_VAR 0 3
89059: PUSH
89060: LD_INT 114
89062: EQUAL
89063: IFFALSE 89073
// sMortar := true ;
89065: LD_ADDR_EXP 156
89069: PUSH
89070: LD_INT 1
89072: ST_TO_ADDR
// if p3 = 115 then
89073: LD_VAR 0 3
89077: PUSH
89078: LD_INT 115
89080: EQUAL
89081: IFFALSE 89091
// sRanger := true ;
89083: LD_ADDR_EXP 166
89087: PUSH
89088: LD_INT 1
89090: ST_TO_ADDR
// end ; if p2 = 101 then
89091: LD_VAR 0 2
89095: PUSH
89096: LD_INT 101
89098: EQUAL
89099: IFFALSE 89227
// begin case p3 of 1 :
89101: LD_VAR 0 3
89105: PUSH
89106: LD_INT 1
89108: DOUBLE
89109: EQUAL
89110: IFTRUE 89114
89112: GO 89121
89114: POP
// hHackUnlimitedResources ; 2 :
89115: CALL 100264 0 0
89119: GO 89227
89121: LD_INT 2
89123: DOUBLE
89124: EQUAL
89125: IFTRUE 89129
89127: GO 89136
89129: POP
// hHackSetLevel10 ; 3 :
89130: CALL 100397 0 0
89134: GO 89227
89136: LD_INT 3
89138: DOUBLE
89139: EQUAL
89140: IFTRUE 89144
89142: GO 89151
89144: POP
// hHackSetLevel10YourUnits ; 4 :
89145: CALL 100482 0 0
89149: GO 89227
89151: LD_INT 4
89153: DOUBLE
89154: EQUAL
89155: IFTRUE 89159
89157: GO 89166
89159: POP
// hHackInvincible ; 5 :
89160: CALL 100930 0 0
89164: GO 89227
89166: LD_INT 5
89168: DOUBLE
89169: EQUAL
89170: IFTRUE 89174
89172: GO 89181
89174: POP
// hHackInvisible ; 6 :
89175: CALL 101041 0 0
89179: GO 89227
89181: LD_INT 6
89183: DOUBLE
89184: EQUAL
89185: IFTRUE 89189
89187: GO 89196
89189: POP
// hHackChangeYourSide ; 7 :
89190: CALL 101098 0 0
89194: GO 89227
89196: LD_INT 7
89198: DOUBLE
89199: EQUAL
89200: IFTRUE 89204
89202: GO 89211
89204: POP
// hHackChangeUnitSide ; 8 :
89205: CALL 101140 0 0
89209: GO 89227
89211: LD_INT 8
89213: DOUBLE
89214: EQUAL
89215: IFTRUE 89219
89217: GO 89226
89219: POP
// hHackFog ; end ;
89220: CALL 101241 0 0
89224: GO 89227
89226: POP
// end ; end ;
89227: LD_VAR 0 7
89231: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89232: GO 89234
89234: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89235: LD_STRING initStreamRollete();
89237: PPUSH
89238: CALL_OW 559
// InitStreamMode ;
89242: CALL 89251 0 0
// DefineStreamItems ( ) ;
89246: CALL 89691 0 0
// end ;
89250: END
// function InitStreamMode ; begin
89251: LD_INT 0
89253: PPUSH
// streamModeActive := false ;
89254: LD_ADDR_EXP 113
89258: PUSH
89259: LD_INT 0
89261: ST_TO_ADDR
// normalCounter := 36 ;
89262: LD_ADDR_EXP 114
89266: PUSH
89267: LD_INT 36
89269: ST_TO_ADDR
// hardcoreCounter := 16 ;
89270: LD_ADDR_EXP 115
89274: PUSH
89275: LD_INT 16
89277: ST_TO_ADDR
// sRocket := false ;
89278: LD_ADDR_EXP 118
89282: PUSH
89283: LD_INT 0
89285: ST_TO_ADDR
// sSpeed := false ;
89286: LD_ADDR_EXP 117
89290: PUSH
89291: LD_INT 0
89293: ST_TO_ADDR
// sEngine := false ;
89294: LD_ADDR_EXP 119
89298: PUSH
89299: LD_INT 0
89301: ST_TO_ADDR
// sSpec := false ;
89302: LD_ADDR_EXP 116
89306: PUSH
89307: LD_INT 0
89309: ST_TO_ADDR
// sLevel := false ;
89310: LD_ADDR_EXP 120
89314: PUSH
89315: LD_INT 0
89317: ST_TO_ADDR
// sArmoury := false ;
89318: LD_ADDR_EXP 121
89322: PUSH
89323: LD_INT 0
89325: ST_TO_ADDR
// sRadar := false ;
89326: LD_ADDR_EXP 122
89330: PUSH
89331: LD_INT 0
89333: ST_TO_ADDR
// sBunker := false ;
89334: LD_ADDR_EXP 123
89338: PUSH
89339: LD_INT 0
89341: ST_TO_ADDR
// sHack := false ;
89342: LD_ADDR_EXP 124
89346: PUSH
89347: LD_INT 0
89349: ST_TO_ADDR
// sFire := false ;
89350: LD_ADDR_EXP 125
89354: PUSH
89355: LD_INT 0
89357: ST_TO_ADDR
// sRefresh := false ;
89358: LD_ADDR_EXP 126
89362: PUSH
89363: LD_INT 0
89365: ST_TO_ADDR
// sExp := false ;
89366: LD_ADDR_EXP 127
89370: PUSH
89371: LD_INT 0
89373: ST_TO_ADDR
// sDepot := false ;
89374: LD_ADDR_EXP 128
89378: PUSH
89379: LD_INT 0
89381: ST_TO_ADDR
// sFlag := false ;
89382: LD_ADDR_EXP 129
89386: PUSH
89387: LD_INT 0
89389: ST_TO_ADDR
// sKamikadze := false ;
89390: LD_ADDR_EXP 137
89394: PUSH
89395: LD_INT 0
89397: ST_TO_ADDR
// sTroll := false ;
89398: LD_ADDR_EXP 138
89402: PUSH
89403: LD_INT 0
89405: ST_TO_ADDR
// sSlow := false ;
89406: LD_ADDR_EXP 139
89410: PUSH
89411: LD_INT 0
89413: ST_TO_ADDR
// sLack := false ;
89414: LD_ADDR_EXP 140
89418: PUSH
89419: LD_INT 0
89421: ST_TO_ADDR
// sTank := false ;
89422: LD_ADDR_EXP 142
89426: PUSH
89427: LD_INT 0
89429: ST_TO_ADDR
// sRemote := false ;
89430: LD_ADDR_EXP 143
89434: PUSH
89435: LD_INT 0
89437: ST_TO_ADDR
// sPowell := false ;
89438: LD_ADDR_EXP 144
89442: PUSH
89443: LD_INT 0
89445: ST_TO_ADDR
// sTeleport := false ;
89446: LD_ADDR_EXP 147
89450: PUSH
89451: LD_INT 0
89453: ST_TO_ADDR
// sOilTower := false ;
89454: LD_ADDR_EXP 149
89458: PUSH
89459: LD_INT 0
89461: ST_TO_ADDR
// sShovel := false ;
89462: LD_ADDR_EXP 150
89466: PUSH
89467: LD_INT 0
89469: ST_TO_ADDR
// sSheik := false ;
89470: LD_ADDR_EXP 151
89474: PUSH
89475: LD_INT 0
89477: ST_TO_ADDR
// sEarthquake := false ;
89478: LD_ADDR_EXP 153
89482: PUSH
89483: LD_INT 0
89485: ST_TO_ADDR
// sAI := false ;
89486: LD_ADDR_EXP 154
89490: PUSH
89491: LD_INT 0
89493: ST_TO_ADDR
// sCargo := false ;
89494: LD_ADDR_EXP 157
89498: PUSH
89499: LD_INT 0
89501: ST_TO_ADDR
// sDLaser := false ;
89502: LD_ADDR_EXP 158
89506: PUSH
89507: LD_INT 0
89509: ST_TO_ADDR
// sExchange := false ;
89510: LD_ADDR_EXP 159
89514: PUSH
89515: LD_INT 0
89517: ST_TO_ADDR
// sFac := false ;
89518: LD_ADDR_EXP 160
89522: PUSH
89523: LD_INT 0
89525: ST_TO_ADDR
// sPower := false ;
89526: LD_ADDR_EXP 161
89530: PUSH
89531: LD_INT 0
89533: ST_TO_ADDR
// sRandom := false ;
89534: LD_ADDR_EXP 162
89538: PUSH
89539: LD_INT 0
89541: ST_TO_ADDR
// sShield := false ;
89542: LD_ADDR_EXP 163
89546: PUSH
89547: LD_INT 0
89549: ST_TO_ADDR
// sTime := false ;
89550: LD_ADDR_EXP 164
89554: PUSH
89555: LD_INT 0
89557: ST_TO_ADDR
// sTools := false ;
89558: LD_ADDR_EXP 165
89562: PUSH
89563: LD_INT 0
89565: ST_TO_ADDR
// sSold := false ;
89566: LD_ADDR_EXP 130
89570: PUSH
89571: LD_INT 0
89573: ST_TO_ADDR
// sDiff := false ;
89574: LD_ADDR_EXP 131
89578: PUSH
89579: LD_INT 0
89581: ST_TO_ADDR
// sFog := false ;
89582: LD_ADDR_EXP 134
89586: PUSH
89587: LD_INT 0
89589: ST_TO_ADDR
// sReset := false ;
89590: LD_ADDR_EXP 135
89594: PUSH
89595: LD_INT 0
89597: ST_TO_ADDR
// sSun := false ;
89598: LD_ADDR_EXP 136
89602: PUSH
89603: LD_INT 0
89605: ST_TO_ADDR
// sTiger := false ;
89606: LD_ADDR_EXP 132
89610: PUSH
89611: LD_INT 0
89613: ST_TO_ADDR
// sBomb := false ;
89614: LD_ADDR_EXP 133
89618: PUSH
89619: LD_INT 0
89621: ST_TO_ADDR
// sWound := false ;
89622: LD_ADDR_EXP 141
89626: PUSH
89627: LD_INT 0
89629: ST_TO_ADDR
// sBetray := false ;
89630: LD_ADDR_EXP 145
89634: PUSH
89635: LD_INT 0
89637: ST_TO_ADDR
// sContamin := false ;
89638: LD_ADDR_EXP 146
89642: PUSH
89643: LD_INT 0
89645: ST_TO_ADDR
// sOil := false ;
89646: LD_ADDR_EXP 148
89650: PUSH
89651: LD_INT 0
89653: ST_TO_ADDR
// sStu := false ;
89654: LD_ADDR_EXP 152
89658: PUSH
89659: LD_INT 0
89661: ST_TO_ADDR
// sBazooka := false ;
89662: LD_ADDR_EXP 155
89666: PUSH
89667: LD_INT 0
89669: ST_TO_ADDR
// sMortar := false ;
89670: LD_ADDR_EXP 156
89674: PUSH
89675: LD_INT 0
89677: ST_TO_ADDR
// sRanger := false ;
89678: LD_ADDR_EXP 166
89682: PUSH
89683: LD_INT 0
89685: ST_TO_ADDR
// end ;
89686: LD_VAR 0 1
89690: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
89691: LD_INT 0
89693: PPUSH
89694: PPUSH
89695: PPUSH
89696: PPUSH
89697: PPUSH
// result := [ ] ;
89698: LD_ADDR_VAR 0 1
89702: PUSH
89703: EMPTY
89704: ST_TO_ADDR
// if campaign_id = 1 then
89705: LD_OWVAR 69
89709: PUSH
89710: LD_INT 1
89712: EQUAL
89713: IFFALSE 92651
// begin case mission_number of 1 :
89715: LD_OWVAR 70
89719: PUSH
89720: LD_INT 1
89722: DOUBLE
89723: EQUAL
89724: IFTRUE 89728
89726: GO 89792
89728: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
89729: LD_ADDR_VAR 0 1
89733: PUSH
89734: LD_INT 2
89736: PUSH
89737: LD_INT 4
89739: PUSH
89740: LD_INT 11
89742: PUSH
89743: LD_INT 12
89745: PUSH
89746: LD_INT 15
89748: PUSH
89749: LD_INT 16
89751: PUSH
89752: LD_INT 22
89754: PUSH
89755: LD_INT 23
89757: PUSH
89758: LD_INT 26
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 101
89774: PUSH
89775: LD_INT 102
89777: PUSH
89778: LD_INT 106
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: LIST
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: ST_TO_ADDR
89790: GO 92649
89792: LD_INT 2
89794: DOUBLE
89795: EQUAL
89796: IFTRUE 89800
89798: GO 89872
89800: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
89801: LD_ADDR_VAR 0 1
89805: PUSH
89806: LD_INT 2
89808: PUSH
89809: LD_INT 4
89811: PUSH
89812: LD_INT 11
89814: PUSH
89815: LD_INT 12
89817: PUSH
89818: LD_INT 15
89820: PUSH
89821: LD_INT 16
89823: PUSH
89824: LD_INT 22
89826: PUSH
89827: LD_INT 23
89829: PUSH
89830: LD_INT 26
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 101
89846: PUSH
89847: LD_INT 102
89849: PUSH
89850: LD_INT 105
89852: PUSH
89853: LD_INT 106
89855: PUSH
89856: LD_INT 108
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: ST_TO_ADDR
89870: GO 92649
89872: LD_INT 3
89874: DOUBLE
89875: EQUAL
89876: IFTRUE 89880
89878: GO 89956
89880: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
89881: LD_ADDR_VAR 0 1
89885: PUSH
89886: LD_INT 2
89888: PUSH
89889: LD_INT 4
89891: PUSH
89892: LD_INT 5
89894: PUSH
89895: LD_INT 11
89897: PUSH
89898: LD_INT 12
89900: PUSH
89901: LD_INT 15
89903: PUSH
89904: LD_INT 16
89906: PUSH
89907: LD_INT 22
89909: PUSH
89910: LD_INT 26
89912: PUSH
89913: LD_INT 36
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 101
89930: PUSH
89931: LD_INT 102
89933: PUSH
89934: LD_INT 105
89936: PUSH
89937: LD_INT 106
89939: PUSH
89940: LD_INT 108
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: ST_TO_ADDR
89954: GO 92649
89956: LD_INT 4
89958: DOUBLE
89959: EQUAL
89960: IFTRUE 89964
89962: GO 90048
89964: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89965: LD_ADDR_VAR 0 1
89969: PUSH
89970: LD_INT 2
89972: PUSH
89973: LD_INT 4
89975: PUSH
89976: LD_INT 5
89978: PUSH
89979: LD_INT 8
89981: PUSH
89982: LD_INT 11
89984: PUSH
89985: LD_INT 12
89987: PUSH
89988: LD_INT 15
89990: PUSH
89991: LD_INT 16
89993: PUSH
89994: LD_INT 22
89996: PUSH
89997: LD_INT 23
89999: PUSH
90000: LD_INT 26
90002: PUSH
90003: LD_INT 36
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 101
90022: PUSH
90023: LD_INT 102
90025: PUSH
90026: LD_INT 105
90028: PUSH
90029: LD_INT 106
90031: PUSH
90032: LD_INT 108
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: ST_TO_ADDR
90046: GO 92649
90048: LD_INT 5
90050: DOUBLE
90051: EQUAL
90052: IFTRUE 90056
90054: GO 90156
90056: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90057: LD_ADDR_VAR 0 1
90061: PUSH
90062: LD_INT 2
90064: PUSH
90065: LD_INT 4
90067: PUSH
90068: LD_INT 5
90070: PUSH
90071: LD_INT 6
90073: PUSH
90074: LD_INT 8
90076: PUSH
90077: LD_INT 11
90079: PUSH
90080: LD_INT 12
90082: PUSH
90083: LD_INT 15
90085: PUSH
90086: LD_INT 16
90088: PUSH
90089: LD_INT 22
90091: PUSH
90092: LD_INT 23
90094: PUSH
90095: LD_INT 25
90097: PUSH
90098: LD_INT 26
90100: PUSH
90101: LD_INT 36
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 101
90122: PUSH
90123: LD_INT 102
90125: PUSH
90126: LD_INT 105
90128: PUSH
90129: LD_INT 106
90131: PUSH
90132: LD_INT 108
90134: PUSH
90135: LD_INT 109
90137: PUSH
90138: LD_INT 112
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: ST_TO_ADDR
90154: GO 92649
90156: LD_INT 6
90158: DOUBLE
90159: EQUAL
90160: IFTRUE 90164
90162: GO 90284
90164: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90165: LD_ADDR_VAR 0 1
90169: PUSH
90170: LD_INT 2
90172: PUSH
90173: LD_INT 4
90175: PUSH
90176: LD_INT 5
90178: PUSH
90179: LD_INT 6
90181: PUSH
90182: LD_INT 8
90184: PUSH
90185: LD_INT 11
90187: PUSH
90188: LD_INT 12
90190: PUSH
90191: LD_INT 15
90193: PUSH
90194: LD_INT 16
90196: PUSH
90197: LD_INT 20
90199: PUSH
90200: LD_INT 21
90202: PUSH
90203: LD_INT 22
90205: PUSH
90206: LD_INT 23
90208: PUSH
90209: LD_INT 25
90211: PUSH
90212: LD_INT 26
90214: PUSH
90215: LD_INT 30
90217: PUSH
90218: LD_INT 31
90220: PUSH
90221: LD_INT 32
90223: PUSH
90224: LD_INT 36
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 101
90250: PUSH
90251: LD_INT 102
90253: PUSH
90254: LD_INT 105
90256: PUSH
90257: LD_INT 106
90259: PUSH
90260: LD_INT 108
90262: PUSH
90263: LD_INT 109
90265: PUSH
90266: LD_INT 112
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: ST_TO_ADDR
90282: GO 92649
90284: LD_INT 7
90286: DOUBLE
90287: EQUAL
90288: IFTRUE 90292
90290: GO 90392
90292: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90293: LD_ADDR_VAR 0 1
90297: PUSH
90298: LD_INT 2
90300: PUSH
90301: LD_INT 4
90303: PUSH
90304: LD_INT 5
90306: PUSH
90307: LD_INT 7
90309: PUSH
90310: LD_INT 11
90312: PUSH
90313: LD_INT 12
90315: PUSH
90316: LD_INT 15
90318: PUSH
90319: LD_INT 16
90321: PUSH
90322: LD_INT 20
90324: PUSH
90325: LD_INT 21
90327: PUSH
90328: LD_INT 22
90330: PUSH
90331: LD_INT 23
90333: PUSH
90334: LD_INT 25
90336: PUSH
90337: LD_INT 26
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: PUSH
90356: LD_INT 101
90358: PUSH
90359: LD_INT 102
90361: PUSH
90362: LD_INT 103
90364: PUSH
90365: LD_INT 105
90367: PUSH
90368: LD_INT 106
90370: PUSH
90371: LD_INT 108
90373: PUSH
90374: LD_INT 112
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: ST_TO_ADDR
90390: GO 92649
90392: LD_INT 8
90394: DOUBLE
90395: EQUAL
90396: IFTRUE 90400
90398: GO 90528
90400: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90401: LD_ADDR_VAR 0 1
90405: PUSH
90406: LD_INT 2
90408: PUSH
90409: LD_INT 4
90411: PUSH
90412: LD_INT 5
90414: PUSH
90415: LD_INT 6
90417: PUSH
90418: LD_INT 7
90420: PUSH
90421: LD_INT 8
90423: PUSH
90424: LD_INT 11
90426: PUSH
90427: LD_INT 12
90429: PUSH
90430: LD_INT 15
90432: PUSH
90433: LD_INT 16
90435: PUSH
90436: LD_INT 20
90438: PUSH
90439: LD_INT 21
90441: PUSH
90442: LD_INT 22
90444: PUSH
90445: LD_INT 23
90447: PUSH
90448: LD_INT 25
90450: PUSH
90451: LD_INT 26
90453: PUSH
90454: LD_INT 30
90456: PUSH
90457: LD_INT 31
90459: PUSH
90460: LD_INT 32
90462: PUSH
90463: LD_INT 36
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: PUSH
90488: LD_INT 101
90490: PUSH
90491: LD_INT 102
90493: PUSH
90494: LD_INT 103
90496: PUSH
90497: LD_INT 105
90499: PUSH
90500: LD_INT 106
90502: PUSH
90503: LD_INT 108
90505: PUSH
90506: LD_INT 109
90508: PUSH
90509: LD_INT 112
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: ST_TO_ADDR
90526: GO 92649
90528: LD_INT 9
90530: DOUBLE
90531: EQUAL
90532: IFTRUE 90536
90534: GO 90672
90536: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
90537: LD_ADDR_VAR 0 1
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: LD_INT 4
90547: PUSH
90548: LD_INT 5
90550: PUSH
90551: LD_INT 6
90553: PUSH
90554: LD_INT 7
90556: PUSH
90557: LD_INT 8
90559: PUSH
90560: LD_INT 11
90562: PUSH
90563: LD_INT 12
90565: PUSH
90566: LD_INT 15
90568: PUSH
90569: LD_INT 16
90571: PUSH
90572: LD_INT 20
90574: PUSH
90575: LD_INT 21
90577: PUSH
90578: LD_INT 22
90580: PUSH
90581: LD_INT 23
90583: PUSH
90584: LD_INT 25
90586: PUSH
90587: LD_INT 26
90589: PUSH
90590: LD_INT 28
90592: PUSH
90593: LD_INT 30
90595: PUSH
90596: LD_INT 31
90598: PUSH
90599: LD_INT 32
90601: PUSH
90602: LD_INT 36
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 101
90630: PUSH
90631: LD_INT 102
90633: PUSH
90634: LD_INT 103
90636: PUSH
90637: LD_INT 105
90639: PUSH
90640: LD_INT 106
90642: PUSH
90643: LD_INT 108
90645: PUSH
90646: LD_INT 109
90648: PUSH
90649: LD_INT 112
90651: PUSH
90652: LD_INT 114
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: ST_TO_ADDR
90670: GO 92649
90672: LD_INT 10
90674: DOUBLE
90675: EQUAL
90676: IFTRUE 90680
90678: GO 90864
90680: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
90681: LD_ADDR_VAR 0 1
90685: PUSH
90686: LD_INT 2
90688: PUSH
90689: LD_INT 4
90691: PUSH
90692: LD_INT 5
90694: PUSH
90695: LD_INT 6
90697: PUSH
90698: LD_INT 7
90700: PUSH
90701: LD_INT 8
90703: PUSH
90704: LD_INT 9
90706: PUSH
90707: LD_INT 10
90709: PUSH
90710: LD_INT 11
90712: PUSH
90713: LD_INT 12
90715: PUSH
90716: LD_INT 13
90718: PUSH
90719: LD_INT 14
90721: PUSH
90722: LD_INT 15
90724: PUSH
90725: LD_INT 16
90727: PUSH
90728: LD_INT 17
90730: PUSH
90731: LD_INT 18
90733: PUSH
90734: LD_INT 19
90736: PUSH
90737: LD_INT 20
90739: PUSH
90740: LD_INT 21
90742: PUSH
90743: LD_INT 22
90745: PUSH
90746: LD_INT 23
90748: PUSH
90749: LD_INT 24
90751: PUSH
90752: LD_INT 25
90754: PUSH
90755: LD_INT 26
90757: PUSH
90758: LD_INT 28
90760: PUSH
90761: LD_INT 30
90763: PUSH
90764: LD_INT 31
90766: PUSH
90767: LD_INT 32
90769: PUSH
90770: LD_INT 36
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 101
90806: PUSH
90807: LD_INT 102
90809: PUSH
90810: LD_INT 103
90812: PUSH
90813: LD_INT 104
90815: PUSH
90816: LD_INT 105
90818: PUSH
90819: LD_INT 106
90821: PUSH
90822: LD_INT 107
90824: PUSH
90825: LD_INT 108
90827: PUSH
90828: LD_INT 109
90830: PUSH
90831: LD_INT 110
90833: PUSH
90834: LD_INT 111
90836: PUSH
90837: LD_INT 112
90839: PUSH
90840: LD_INT 114
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: ST_TO_ADDR
90862: GO 92649
90864: LD_INT 11
90866: DOUBLE
90867: EQUAL
90868: IFTRUE 90872
90870: GO 91064
90872: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
90873: LD_ADDR_VAR 0 1
90877: PUSH
90878: LD_INT 2
90880: PUSH
90881: LD_INT 3
90883: PUSH
90884: LD_INT 4
90886: PUSH
90887: LD_INT 5
90889: PUSH
90890: LD_INT 6
90892: PUSH
90893: LD_INT 7
90895: PUSH
90896: LD_INT 8
90898: PUSH
90899: LD_INT 9
90901: PUSH
90902: LD_INT 10
90904: PUSH
90905: LD_INT 11
90907: PUSH
90908: LD_INT 12
90910: PUSH
90911: LD_INT 13
90913: PUSH
90914: LD_INT 14
90916: PUSH
90917: LD_INT 15
90919: PUSH
90920: LD_INT 16
90922: PUSH
90923: LD_INT 17
90925: PUSH
90926: LD_INT 18
90928: PUSH
90929: LD_INT 19
90931: PUSH
90932: LD_INT 20
90934: PUSH
90935: LD_INT 21
90937: PUSH
90938: LD_INT 22
90940: PUSH
90941: LD_INT 23
90943: PUSH
90944: LD_INT 24
90946: PUSH
90947: LD_INT 25
90949: PUSH
90950: LD_INT 26
90952: PUSH
90953: LD_INT 28
90955: PUSH
90956: LD_INT 30
90958: PUSH
90959: LD_INT 31
90961: PUSH
90962: LD_INT 32
90964: PUSH
90965: LD_INT 34
90967: PUSH
90968: LD_INT 36
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 101
91006: PUSH
91007: LD_INT 102
91009: PUSH
91010: LD_INT 103
91012: PUSH
91013: LD_INT 104
91015: PUSH
91016: LD_INT 105
91018: PUSH
91019: LD_INT 106
91021: PUSH
91022: LD_INT 107
91024: PUSH
91025: LD_INT 108
91027: PUSH
91028: LD_INT 109
91030: PUSH
91031: LD_INT 110
91033: PUSH
91034: LD_INT 111
91036: PUSH
91037: LD_INT 112
91039: PUSH
91040: LD_INT 114
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: ST_TO_ADDR
91062: GO 92649
91064: LD_INT 12
91066: DOUBLE
91067: EQUAL
91068: IFTRUE 91072
91070: GO 91280
91072: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91073: LD_ADDR_VAR 0 1
91077: PUSH
91078: LD_INT 1
91080: PUSH
91081: LD_INT 2
91083: PUSH
91084: LD_INT 3
91086: PUSH
91087: LD_INT 4
91089: PUSH
91090: LD_INT 5
91092: PUSH
91093: LD_INT 6
91095: PUSH
91096: LD_INT 7
91098: PUSH
91099: LD_INT 8
91101: PUSH
91102: LD_INT 9
91104: PUSH
91105: LD_INT 10
91107: PUSH
91108: LD_INT 11
91110: PUSH
91111: LD_INT 12
91113: PUSH
91114: LD_INT 13
91116: PUSH
91117: LD_INT 14
91119: PUSH
91120: LD_INT 15
91122: PUSH
91123: LD_INT 16
91125: PUSH
91126: LD_INT 17
91128: PUSH
91129: LD_INT 18
91131: PUSH
91132: LD_INT 19
91134: PUSH
91135: LD_INT 20
91137: PUSH
91138: LD_INT 21
91140: PUSH
91141: LD_INT 22
91143: PUSH
91144: LD_INT 23
91146: PUSH
91147: LD_INT 24
91149: PUSH
91150: LD_INT 25
91152: PUSH
91153: LD_INT 26
91155: PUSH
91156: LD_INT 27
91158: PUSH
91159: LD_INT 28
91161: PUSH
91162: LD_INT 30
91164: PUSH
91165: LD_INT 31
91167: PUSH
91168: LD_INT 32
91170: PUSH
91171: LD_INT 33
91173: PUSH
91174: LD_INT 34
91176: PUSH
91177: LD_INT 36
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 101
91218: PUSH
91219: LD_INT 102
91221: PUSH
91222: LD_INT 103
91224: PUSH
91225: LD_INT 104
91227: PUSH
91228: LD_INT 105
91230: PUSH
91231: LD_INT 106
91233: PUSH
91234: LD_INT 107
91236: PUSH
91237: LD_INT 108
91239: PUSH
91240: LD_INT 109
91242: PUSH
91243: LD_INT 110
91245: PUSH
91246: LD_INT 111
91248: PUSH
91249: LD_INT 112
91251: PUSH
91252: LD_INT 113
91254: PUSH
91255: LD_INT 114
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: ST_TO_ADDR
91278: GO 92649
91280: LD_INT 13
91282: DOUBLE
91283: EQUAL
91284: IFTRUE 91288
91286: GO 91484
91288: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91289: LD_ADDR_VAR 0 1
91293: PUSH
91294: LD_INT 1
91296: PUSH
91297: LD_INT 2
91299: PUSH
91300: LD_INT 3
91302: PUSH
91303: LD_INT 4
91305: PUSH
91306: LD_INT 5
91308: PUSH
91309: LD_INT 8
91311: PUSH
91312: LD_INT 9
91314: PUSH
91315: LD_INT 10
91317: PUSH
91318: LD_INT 11
91320: PUSH
91321: LD_INT 12
91323: PUSH
91324: LD_INT 14
91326: PUSH
91327: LD_INT 15
91329: PUSH
91330: LD_INT 16
91332: PUSH
91333: LD_INT 17
91335: PUSH
91336: LD_INT 18
91338: PUSH
91339: LD_INT 19
91341: PUSH
91342: LD_INT 20
91344: PUSH
91345: LD_INT 21
91347: PUSH
91348: LD_INT 22
91350: PUSH
91351: LD_INT 23
91353: PUSH
91354: LD_INT 24
91356: PUSH
91357: LD_INT 25
91359: PUSH
91360: LD_INT 26
91362: PUSH
91363: LD_INT 27
91365: PUSH
91366: LD_INT 28
91368: PUSH
91369: LD_INT 30
91371: PUSH
91372: LD_INT 31
91374: PUSH
91375: LD_INT 32
91377: PUSH
91378: LD_INT 33
91380: PUSH
91381: LD_INT 34
91383: PUSH
91384: LD_INT 36
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 101
91422: PUSH
91423: LD_INT 102
91425: PUSH
91426: LD_INT 103
91428: PUSH
91429: LD_INT 104
91431: PUSH
91432: LD_INT 105
91434: PUSH
91435: LD_INT 106
91437: PUSH
91438: LD_INT 107
91440: PUSH
91441: LD_INT 108
91443: PUSH
91444: LD_INT 109
91446: PUSH
91447: LD_INT 110
91449: PUSH
91450: LD_INT 111
91452: PUSH
91453: LD_INT 112
91455: PUSH
91456: LD_INT 113
91458: PUSH
91459: LD_INT 114
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: ST_TO_ADDR
91482: GO 92649
91484: LD_INT 14
91486: DOUBLE
91487: EQUAL
91488: IFTRUE 91492
91490: GO 91704
91492: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
91493: LD_ADDR_VAR 0 1
91497: PUSH
91498: LD_INT 1
91500: PUSH
91501: LD_INT 2
91503: PUSH
91504: LD_INT 3
91506: PUSH
91507: LD_INT 4
91509: PUSH
91510: LD_INT 5
91512: PUSH
91513: LD_INT 6
91515: PUSH
91516: LD_INT 7
91518: PUSH
91519: LD_INT 8
91521: PUSH
91522: LD_INT 9
91524: PUSH
91525: LD_INT 10
91527: PUSH
91528: LD_INT 11
91530: PUSH
91531: LD_INT 12
91533: PUSH
91534: LD_INT 13
91536: PUSH
91537: LD_INT 14
91539: PUSH
91540: LD_INT 15
91542: PUSH
91543: LD_INT 16
91545: PUSH
91546: LD_INT 17
91548: PUSH
91549: LD_INT 18
91551: PUSH
91552: LD_INT 19
91554: PUSH
91555: LD_INT 20
91557: PUSH
91558: LD_INT 21
91560: PUSH
91561: LD_INT 22
91563: PUSH
91564: LD_INT 23
91566: PUSH
91567: LD_INT 24
91569: PUSH
91570: LD_INT 25
91572: PUSH
91573: LD_INT 26
91575: PUSH
91576: LD_INT 27
91578: PUSH
91579: LD_INT 28
91581: PUSH
91582: LD_INT 29
91584: PUSH
91585: LD_INT 30
91587: PUSH
91588: LD_INT 31
91590: PUSH
91591: LD_INT 32
91593: PUSH
91594: LD_INT 33
91596: PUSH
91597: LD_INT 34
91599: PUSH
91600: LD_INT 36
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 101
91642: PUSH
91643: LD_INT 102
91645: PUSH
91646: LD_INT 103
91648: PUSH
91649: LD_INT 104
91651: PUSH
91652: LD_INT 105
91654: PUSH
91655: LD_INT 106
91657: PUSH
91658: LD_INT 107
91660: PUSH
91661: LD_INT 108
91663: PUSH
91664: LD_INT 109
91666: PUSH
91667: LD_INT 110
91669: PUSH
91670: LD_INT 111
91672: PUSH
91673: LD_INT 112
91675: PUSH
91676: LD_INT 113
91678: PUSH
91679: LD_INT 114
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: ST_TO_ADDR
91702: GO 92649
91704: LD_INT 15
91706: DOUBLE
91707: EQUAL
91708: IFTRUE 91712
91710: GO 91924
91712: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
91713: LD_ADDR_VAR 0 1
91717: PUSH
91718: LD_INT 1
91720: PUSH
91721: LD_INT 2
91723: PUSH
91724: LD_INT 3
91726: PUSH
91727: LD_INT 4
91729: PUSH
91730: LD_INT 5
91732: PUSH
91733: LD_INT 6
91735: PUSH
91736: LD_INT 7
91738: PUSH
91739: LD_INT 8
91741: PUSH
91742: LD_INT 9
91744: PUSH
91745: LD_INT 10
91747: PUSH
91748: LD_INT 11
91750: PUSH
91751: LD_INT 12
91753: PUSH
91754: LD_INT 13
91756: PUSH
91757: LD_INT 14
91759: PUSH
91760: LD_INT 15
91762: PUSH
91763: LD_INT 16
91765: PUSH
91766: LD_INT 17
91768: PUSH
91769: LD_INT 18
91771: PUSH
91772: LD_INT 19
91774: PUSH
91775: LD_INT 20
91777: PUSH
91778: LD_INT 21
91780: PUSH
91781: LD_INT 22
91783: PUSH
91784: LD_INT 23
91786: PUSH
91787: LD_INT 24
91789: PUSH
91790: LD_INT 25
91792: PUSH
91793: LD_INT 26
91795: PUSH
91796: LD_INT 27
91798: PUSH
91799: LD_INT 28
91801: PUSH
91802: LD_INT 29
91804: PUSH
91805: LD_INT 30
91807: PUSH
91808: LD_INT 31
91810: PUSH
91811: LD_INT 32
91813: PUSH
91814: LD_INT 33
91816: PUSH
91817: LD_INT 34
91819: PUSH
91820: LD_INT 36
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 101
91862: PUSH
91863: LD_INT 102
91865: PUSH
91866: LD_INT 103
91868: PUSH
91869: LD_INT 104
91871: PUSH
91872: LD_INT 105
91874: PUSH
91875: LD_INT 106
91877: PUSH
91878: LD_INT 107
91880: PUSH
91881: LD_INT 108
91883: PUSH
91884: LD_INT 109
91886: PUSH
91887: LD_INT 110
91889: PUSH
91890: LD_INT 111
91892: PUSH
91893: LD_INT 112
91895: PUSH
91896: LD_INT 113
91898: PUSH
91899: LD_INT 114
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: ST_TO_ADDR
91922: GO 92649
91924: LD_INT 16
91926: DOUBLE
91927: EQUAL
91928: IFTRUE 91932
91930: GO 92056
91932: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91933: LD_ADDR_VAR 0 1
91937: PUSH
91938: LD_INT 2
91940: PUSH
91941: LD_INT 4
91943: PUSH
91944: LD_INT 5
91946: PUSH
91947: LD_INT 7
91949: PUSH
91950: LD_INT 11
91952: PUSH
91953: LD_INT 12
91955: PUSH
91956: LD_INT 15
91958: PUSH
91959: LD_INT 16
91961: PUSH
91962: LD_INT 20
91964: PUSH
91965: LD_INT 21
91967: PUSH
91968: LD_INT 22
91970: PUSH
91971: LD_INT 23
91973: PUSH
91974: LD_INT 25
91976: PUSH
91977: LD_INT 26
91979: PUSH
91980: LD_INT 30
91982: PUSH
91983: LD_INT 31
91985: PUSH
91986: LD_INT 32
91988: PUSH
91989: LD_INT 33
91991: PUSH
91992: LD_INT 34
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 101
92018: PUSH
92019: LD_INT 102
92021: PUSH
92022: LD_INT 103
92024: PUSH
92025: LD_INT 106
92027: PUSH
92028: LD_INT 108
92030: PUSH
92031: LD_INT 112
92033: PUSH
92034: LD_INT 113
92036: PUSH
92037: LD_INT 114
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: ST_TO_ADDR
92054: GO 92649
92056: LD_INT 17
92058: DOUBLE
92059: EQUAL
92060: IFTRUE 92064
92062: GO 92276
92064: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92065: LD_ADDR_VAR 0 1
92069: PUSH
92070: LD_INT 1
92072: PUSH
92073: LD_INT 2
92075: PUSH
92076: LD_INT 3
92078: PUSH
92079: LD_INT 4
92081: PUSH
92082: LD_INT 5
92084: PUSH
92085: LD_INT 6
92087: PUSH
92088: LD_INT 7
92090: PUSH
92091: LD_INT 8
92093: PUSH
92094: LD_INT 9
92096: PUSH
92097: LD_INT 10
92099: PUSH
92100: LD_INT 11
92102: PUSH
92103: LD_INT 12
92105: PUSH
92106: LD_INT 13
92108: PUSH
92109: LD_INT 14
92111: PUSH
92112: LD_INT 15
92114: PUSH
92115: LD_INT 16
92117: PUSH
92118: LD_INT 17
92120: PUSH
92121: LD_INT 18
92123: PUSH
92124: LD_INT 19
92126: PUSH
92127: LD_INT 20
92129: PUSH
92130: LD_INT 21
92132: PUSH
92133: LD_INT 22
92135: PUSH
92136: LD_INT 23
92138: PUSH
92139: LD_INT 24
92141: PUSH
92142: LD_INT 25
92144: PUSH
92145: LD_INT 26
92147: PUSH
92148: LD_INT 27
92150: PUSH
92151: LD_INT 28
92153: PUSH
92154: LD_INT 29
92156: PUSH
92157: LD_INT 30
92159: PUSH
92160: LD_INT 31
92162: PUSH
92163: LD_INT 32
92165: PUSH
92166: LD_INT 33
92168: PUSH
92169: LD_INT 34
92171: PUSH
92172: LD_INT 36
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 101
92214: PUSH
92215: LD_INT 102
92217: PUSH
92218: LD_INT 103
92220: PUSH
92221: LD_INT 104
92223: PUSH
92224: LD_INT 105
92226: PUSH
92227: LD_INT 106
92229: PUSH
92230: LD_INT 107
92232: PUSH
92233: LD_INT 108
92235: PUSH
92236: LD_INT 109
92238: PUSH
92239: LD_INT 110
92241: PUSH
92242: LD_INT 111
92244: PUSH
92245: LD_INT 112
92247: PUSH
92248: LD_INT 113
92250: PUSH
92251: LD_INT 114
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: ST_TO_ADDR
92274: GO 92649
92276: LD_INT 18
92278: DOUBLE
92279: EQUAL
92280: IFTRUE 92284
92282: GO 92420
92284: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92285: LD_ADDR_VAR 0 1
92289: PUSH
92290: LD_INT 2
92292: PUSH
92293: LD_INT 4
92295: PUSH
92296: LD_INT 5
92298: PUSH
92299: LD_INT 7
92301: PUSH
92302: LD_INT 11
92304: PUSH
92305: LD_INT 12
92307: PUSH
92308: LD_INT 15
92310: PUSH
92311: LD_INT 16
92313: PUSH
92314: LD_INT 20
92316: PUSH
92317: LD_INT 21
92319: PUSH
92320: LD_INT 22
92322: PUSH
92323: LD_INT 23
92325: PUSH
92326: LD_INT 25
92328: PUSH
92329: LD_INT 26
92331: PUSH
92332: LD_INT 30
92334: PUSH
92335: LD_INT 31
92337: PUSH
92338: LD_INT 32
92340: PUSH
92341: LD_INT 33
92343: PUSH
92344: LD_INT 34
92346: PUSH
92347: LD_INT 35
92349: PUSH
92350: LD_INT 36
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 101
92378: PUSH
92379: LD_INT 102
92381: PUSH
92382: LD_INT 103
92384: PUSH
92385: LD_INT 106
92387: PUSH
92388: LD_INT 108
92390: PUSH
92391: LD_INT 112
92393: PUSH
92394: LD_INT 113
92396: PUSH
92397: LD_INT 114
92399: PUSH
92400: LD_INT 115
92402: PUSH
92403: EMPTY
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: ST_TO_ADDR
92418: GO 92649
92420: LD_INT 19
92422: DOUBLE
92423: EQUAL
92424: IFTRUE 92428
92426: GO 92648
92428: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92429: LD_ADDR_VAR 0 1
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: LD_INT 3
92442: PUSH
92443: LD_INT 4
92445: PUSH
92446: LD_INT 5
92448: PUSH
92449: LD_INT 6
92451: PUSH
92452: LD_INT 7
92454: PUSH
92455: LD_INT 8
92457: PUSH
92458: LD_INT 9
92460: PUSH
92461: LD_INT 10
92463: PUSH
92464: LD_INT 11
92466: PUSH
92467: LD_INT 12
92469: PUSH
92470: LD_INT 13
92472: PUSH
92473: LD_INT 14
92475: PUSH
92476: LD_INT 15
92478: PUSH
92479: LD_INT 16
92481: PUSH
92482: LD_INT 17
92484: PUSH
92485: LD_INT 18
92487: PUSH
92488: LD_INT 19
92490: PUSH
92491: LD_INT 20
92493: PUSH
92494: LD_INT 21
92496: PUSH
92497: LD_INT 22
92499: PUSH
92500: LD_INT 23
92502: PUSH
92503: LD_INT 24
92505: PUSH
92506: LD_INT 25
92508: PUSH
92509: LD_INT 26
92511: PUSH
92512: LD_INT 27
92514: PUSH
92515: LD_INT 28
92517: PUSH
92518: LD_INT 29
92520: PUSH
92521: LD_INT 30
92523: PUSH
92524: LD_INT 31
92526: PUSH
92527: LD_INT 32
92529: PUSH
92530: LD_INT 33
92532: PUSH
92533: LD_INT 34
92535: PUSH
92536: LD_INT 35
92538: PUSH
92539: LD_INT 36
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 101
92582: PUSH
92583: LD_INT 102
92585: PUSH
92586: LD_INT 103
92588: PUSH
92589: LD_INT 104
92591: PUSH
92592: LD_INT 105
92594: PUSH
92595: LD_INT 106
92597: PUSH
92598: LD_INT 107
92600: PUSH
92601: LD_INT 108
92603: PUSH
92604: LD_INT 109
92606: PUSH
92607: LD_INT 110
92609: PUSH
92610: LD_INT 111
92612: PUSH
92613: LD_INT 112
92615: PUSH
92616: LD_INT 113
92618: PUSH
92619: LD_INT 114
92621: PUSH
92622: LD_INT 115
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: ST_TO_ADDR
92646: GO 92649
92648: POP
// end else
92649: GO 92868
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
92651: LD_ADDR_VAR 0 1
92655: PUSH
92656: LD_INT 1
92658: PUSH
92659: LD_INT 2
92661: PUSH
92662: LD_INT 3
92664: PUSH
92665: LD_INT 4
92667: PUSH
92668: LD_INT 5
92670: PUSH
92671: LD_INT 6
92673: PUSH
92674: LD_INT 7
92676: PUSH
92677: LD_INT 8
92679: PUSH
92680: LD_INT 9
92682: PUSH
92683: LD_INT 10
92685: PUSH
92686: LD_INT 11
92688: PUSH
92689: LD_INT 12
92691: PUSH
92692: LD_INT 13
92694: PUSH
92695: LD_INT 14
92697: PUSH
92698: LD_INT 15
92700: PUSH
92701: LD_INT 16
92703: PUSH
92704: LD_INT 17
92706: PUSH
92707: LD_INT 18
92709: PUSH
92710: LD_INT 19
92712: PUSH
92713: LD_INT 20
92715: PUSH
92716: LD_INT 21
92718: PUSH
92719: LD_INT 22
92721: PUSH
92722: LD_INT 23
92724: PUSH
92725: LD_INT 24
92727: PUSH
92728: LD_INT 25
92730: PUSH
92731: LD_INT 26
92733: PUSH
92734: LD_INT 27
92736: PUSH
92737: LD_INT 28
92739: PUSH
92740: LD_INT 29
92742: PUSH
92743: LD_INT 30
92745: PUSH
92746: LD_INT 31
92748: PUSH
92749: LD_INT 32
92751: PUSH
92752: LD_INT 33
92754: PUSH
92755: LD_INT 34
92757: PUSH
92758: LD_INT 35
92760: PUSH
92761: LD_INT 36
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 101
92804: PUSH
92805: LD_INT 102
92807: PUSH
92808: LD_INT 103
92810: PUSH
92811: LD_INT 104
92813: PUSH
92814: LD_INT 105
92816: PUSH
92817: LD_INT 106
92819: PUSH
92820: LD_INT 107
92822: PUSH
92823: LD_INT 108
92825: PUSH
92826: LD_INT 109
92828: PUSH
92829: LD_INT 110
92831: PUSH
92832: LD_INT 111
92834: PUSH
92835: LD_INT 112
92837: PUSH
92838: LD_INT 113
92840: PUSH
92841: LD_INT 114
92843: PUSH
92844: LD_INT 115
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: ST_TO_ADDR
// if result then
92868: LD_VAR 0 1
92872: IFFALSE 93161
// begin normal :=  ;
92874: LD_ADDR_VAR 0 3
92878: PUSH
92879: LD_STRING 
92881: ST_TO_ADDR
// hardcore :=  ;
92882: LD_ADDR_VAR 0 4
92886: PUSH
92887: LD_STRING 
92889: ST_TO_ADDR
// for i = 1 to normalCounter do
92890: LD_ADDR_VAR 0 5
92894: PUSH
92895: DOUBLE
92896: LD_INT 1
92898: DEC
92899: ST_TO_ADDR
92900: LD_EXP 114
92904: PUSH
92905: FOR_TO
92906: IFFALSE 93007
// begin tmp := 0 ;
92908: LD_ADDR_VAR 0 2
92912: PUSH
92913: LD_STRING 0
92915: ST_TO_ADDR
// if result [ 1 ] then
92916: LD_VAR 0 1
92920: PUSH
92921: LD_INT 1
92923: ARRAY
92924: IFFALSE 92989
// if result [ 1 ] [ 1 ] = i then
92926: LD_VAR 0 1
92930: PUSH
92931: LD_INT 1
92933: ARRAY
92934: PUSH
92935: LD_INT 1
92937: ARRAY
92938: PUSH
92939: LD_VAR 0 5
92943: EQUAL
92944: IFFALSE 92989
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92946: LD_ADDR_VAR 0 1
92950: PUSH
92951: LD_VAR 0 1
92955: PPUSH
92956: LD_INT 1
92958: PPUSH
92959: LD_VAR 0 1
92963: PUSH
92964: LD_INT 1
92966: ARRAY
92967: PPUSH
92968: LD_INT 1
92970: PPUSH
92971: CALL_OW 3
92975: PPUSH
92976: CALL_OW 1
92980: ST_TO_ADDR
// tmp := 1 ;
92981: LD_ADDR_VAR 0 2
92985: PUSH
92986: LD_STRING 1
92988: ST_TO_ADDR
// end ; normal := normal & tmp ;
92989: LD_ADDR_VAR 0 3
92993: PUSH
92994: LD_VAR 0 3
92998: PUSH
92999: LD_VAR 0 2
93003: STR
93004: ST_TO_ADDR
// end ;
93005: GO 92905
93007: POP
93008: POP
// for i = 1 to hardcoreCounter do
93009: LD_ADDR_VAR 0 5
93013: PUSH
93014: DOUBLE
93015: LD_INT 1
93017: DEC
93018: ST_TO_ADDR
93019: LD_EXP 115
93023: PUSH
93024: FOR_TO
93025: IFFALSE 93130
// begin tmp := 0 ;
93027: LD_ADDR_VAR 0 2
93031: PUSH
93032: LD_STRING 0
93034: ST_TO_ADDR
// if result [ 2 ] then
93035: LD_VAR 0 1
93039: PUSH
93040: LD_INT 2
93042: ARRAY
93043: IFFALSE 93112
// if result [ 2 ] [ 1 ] = 100 + i then
93045: LD_VAR 0 1
93049: PUSH
93050: LD_INT 2
93052: ARRAY
93053: PUSH
93054: LD_INT 1
93056: ARRAY
93057: PUSH
93058: LD_INT 100
93060: PUSH
93061: LD_VAR 0 5
93065: PLUS
93066: EQUAL
93067: IFFALSE 93112
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93069: LD_ADDR_VAR 0 1
93073: PUSH
93074: LD_VAR 0 1
93078: PPUSH
93079: LD_INT 2
93081: PPUSH
93082: LD_VAR 0 1
93086: PUSH
93087: LD_INT 2
93089: ARRAY
93090: PPUSH
93091: LD_INT 1
93093: PPUSH
93094: CALL_OW 3
93098: PPUSH
93099: CALL_OW 1
93103: ST_TO_ADDR
// tmp := 1 ;
93104: LD_ADDR_VAR 0 2
93108: PUSH
93109: LD_STRING 1
93111: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93112: LD_ADDR_VAR 0 4
93116: PUSH
93117: LD_VAR 0 4
93121: PUSH
93122: LD_VAR 0 2
93126: STR
93127: ST_TO_ADDR
// end ;
93128: GO 93024
93130: POP
93131: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93132: LD_STRING getStreamItemsFromMission("
93134: PUSH
93135: LD_VAR 0 3
93139: STR
93140: PUSH
93141: LD_STRING ","
93143: STR
93144: PUSH
93145: LD_VAR 0 4
93149: STR
93150: PUSH
93151: LD_STRING ")
93153: STR
93154: PPUSH
93155: CALL_OW 559
// end else
93159: GO 93168
// ToLua ( getStreamItemsFromMission("","") ) ;
93161: LD_STRING getStreamItemsFromMission("","")
93163: PPUSH
93164: CALL_OW 559
// end ;
93168: LD_VAR 0 1
93172: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93173: LD_EXP 113
93177: PUSH
93178: LD_EXP 118
93182: AND
93183: IFFALSE 93307
93185: GO 93187
93187: DISABLE
93188: LD_INT 0
93190: PPUSH
93191: PPUSH
// begin enable ;
93192: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93193: LD_ADDR_VAR 0 2
93197: PUSH
93198: LD_INT 22
93200: PUSH
93201: LD_OWVAR 2
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 2
93212: PUSH
93213: LD_INT 34
93215: PUSH
93216: LD_INT 7
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 34
93225: PUSH
93226: LD_INT 45
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 34
93235: PUSH
93236: LD_INT 28
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 34
93245: PUSH
93246: LD_INT 47
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PPUSH
93264: CALL_OW 69
93268: ST_TO_ADDR
// if not tmp then
93269: LD_VAR 0 2
93273: NOT
93274: IFFALSE 93278
// exit ;
93276: GO 93307
// for i in tmp do
93278: LD_ADDR_VAR 0 1
93282: PUSH
93283: LD_VAR 0 2
93287: PUSH
93288: FOR_IN
93289: IFFALSE 93305
// begin SetLives ( i , 0 ) ;
93291: LD_VAR 0 1
93295: PPUSH
93296: LD_INT 0
93298: PPUSH
93299: CALL_OW 234
// end ;
93303: GO 93288
93305: POP
93306: POP
// end ;
93307: PPOPN 2
93309: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93310: LD_EXP 113
93314: PUSH
93315: LD_EXP 119
93319: AND
93320: IFFALSE 93404
93322: GO 93324
93324: DISABLE
93325: LD_INT 0
93327: PPUSH
93328: PPUSH
// begin enable ;
93329: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93330: LD_ADDR_VAR 0 2
93334: PUSH
93335: LD_INT 22
93337: PUSH
93338: LD_OWVAR 2
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 32
93349: PUSH
93350: LD_INT 3
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PPUSH
93361: CALL_OW 69
93365: ST_TO_ADDR
// if not tmp then
93366: LD_VAR 0 2
93370: NOT
93371: IFFALSE 93375
// exit ;
93373: GO 93404
// for i in tmp do
93375: LD_ADDR_VAR 0 1
93379: PUSH
93380: LD_VAR 0 2
93384: PUSH
93385: FOR_IN
93386: IFFALSE 93402
// begin SetLives ( i , 0 ) ;
93388: LD_VAR 0 1
93392: PPUSH
93393: LD_INT 0
93395: PPUSH
93396: CALL_OW 234
// end ;
93400: GO 93385
93402: POP
93403: POP
// end ;
93404: PPOPN 2
93406: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93407: LD_EXP 113
93411: PUSH
93412: LD_EXP 116
93416: AND
93417: IFFALSE 93510
93419: GO 93421
93421: DISABLE
93422: LD_INT 0
93424: PPUSH
// begin enable ;
93425: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93426: LD_ADDR_VAR 0 1
93430: PUSH
93431: LD_INT 22
93433: PUSH
93434: LD_OWVAR 2
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: PUSH
93443: LD_INT 2
93445: PUSH
93446: LD_INT 25
93448: PUSH
93449: LD_INT 5
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 25
93458: PUSH
93459: LD_INT 9
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: LD_INT 25
93468: PUSH
93469: LD_INT 8
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PPUSH
93486: CALL_OW 69
93490: PUSH
93491: FOR_IN
93492: IFFALSE 93508
// begin SetClass ( i , 1 ) ;
93494: LD_VAR 0 1
93498: PPUSH
93499: LD_INT 1
93501: PPUSH
93502: CALL_OW 336
// end ;
93506: GO 93491
93508: POP
93509: POP
// end ;
93510: PPOPN 1
93512: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93513: LD_EXP 113
93517: PUSH
93518: LD_EXP 117
93522: AND
93523: PUSH
93524: LD_OWVAR 65
93528: PUSH
93529: LD_INT 7
93531: LESS
93532: AND
93533: IFFALSE 93547
93535: GO 93537
93537: DISABLE
// begin enable ;
93538: ENABLE
// game_speed := 7 ;
93539: LD_ADDR_OWVAR 65
93543: PUSH
93544: LD_INT 7
93546: ST_TO_ADDR
// end ;
93547: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93548: LD_EXP 113
93552: PUSH
93553: LD_EXP 120
93557: AND
93558: IFFALSE 93760
93560: GO 93562
93562: DISABLE
93563: LD_INT 0
93565: PPUSH
93566: PPUSH
93567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93568: LD_ADDR_VAR 0 3
93572: PUSH
93573: LD_INT 81
93575: PUSH
93576: LD_OWVAR 2
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 21
93587: PUSH
93588: LD_INT 1
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PPUSH
93599: CALL_OW 69
93603: ST_TO_ADDR
// if not tmp then
93604: LD_VAR 0 3
93608: NOT
93609: IFFALSE 93613
// exit ;
93611: GO 93760
// if tmp > 5 then
93613: LD_VAR 0 3
93617: PUSH
93618: LD_INT 5
93620: GREATER
93621: IFFALSE 93633
// k := 5 else
93623: LD_ADDR_VAR 0 2
93627: PUSH
93628: LD_INT 5
93630: ST_TO_ADDR
93631: GO 93643
// k := tmp ;
93633: LD_ADDR_VAR 0 2
93637: PUSH
93638: LD_VAR 0 3
93642: ST_TO_ADDR
// for i := 1 to k do
93643: LD_ADDR_VAR 0 1
93647: PUSH
93648: DOUBLE
93649: LD_INT 1
93651: DEC
93652: ST_TO_ADDR
93653: LD_VAR 0 2
93657: PUSH
93658: FOR_TO
93659: IFFALSE 93758
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93661: LD_VAR 0 3
93665: PUSH
93666: LD_VAR 0 1
93670: ARRAY
93671: PPUSH
93672: LD_VAR 0 1
93676: PUSH
93677: LD_INT 4
93679: MOD
93680: PUSH
93681: LD_INT 1
93683: PLUS
93684: PPUSH
93685: CALL_OW 259
93689: PUSH
93690: LD_INT 10
93692: LESS
93693: IFFALSE 93756
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93695: LD_VAR 0 3
93699: PUSH
93700: LD_VAR 0 1
93704: ARRAY
93705: PPUSH
93706: LD_VAR 0 1
93710: PUSH
93711: LD_INT 4
93713: MOD
93714: PUSH
93715: LD_INT 1
93717: PLUS
93718: PPUSH
93719: LD_VAR 0 3
93723: PUSH
93724: LD_VAR 0 1
93728: ARRAY
93729: PPUSH
93730: LD_VAR 0 1
93734: PUSH
93735: LD_INT 4
93737: MOD
93738: PUSH
93739: LD_INT 1
93741: PLUS
93742: PPUSH
93743: CALL_OW 259
93747: PUSH
93748: LD_INT 1
93750: PLUS
93751: PPUSH
93752: CALL_OW 237
93756: GO 93658
93758: POP
93759: POP
// end ;
93760: PPOPN 3
93762: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93763: LD_EXP 113
93767: PUSH
93768: LD_EXP 121
93772: AND
93773: IFFALSE 93793
93775: GO 93777
93777: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93778: LD_INT 4
93780: PPUSH
93781: LD_OWVAR 2
93785: PPUSH
93786: LD_INT 0
93788: PPUSH
93789: CALL_OW 324
93793: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93794: LD_EXP 113
93798: PUSH
93799: LD_EXP 150
93803: AND
93804: IFFALSE 93824
93806: GO 93808
93808: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93809: LD_INT 19
93811: PPUSH
93812: LD_OWVAR 2
93816: PPUSH
93817: LD_INT 0
93819: PPUSH
93820: CALL_OW 324
93824: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93825: LD_EXP 113
93829: PUSH
93830: LD_EXP 122
93834: AND
93835: IFFALSE 93937
93837: GO 93839
93839: DISABLE
93840: LD_INT 0
93842: PPUSH
93843: PPUSH
// begin enable ;
93844: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93845: LD_ADDR_VAR 0 2
93849: PUSH
93850: LD_INT 22
93852: PUSH
93853: LD_OWVAR 2
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 2
93864: PUSH
93865: LD_INT 34
93867: PUSH
93868: LD_INT 11
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 34
93877: PUSH
93878: LD_INT 30
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: LIST
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PPUSH
93894: CALL_OW 69
93898: ST_TO_ADDR
// if not tmp then
93899: LD_VAR 0 2
93903: NOT
93904: IFFALSE 93908
// exit ;
93906: GO 93937
// for i in tmp do
93908: LD_ADDR_VAR 0 1
93912: PUSH
93913: LD_VAR 0 2
93917: PUSH
93918: FOR_IN
93919: IFFALSE 93935
// begin SetLives ( i , 0 ) ;
93921: LD_VAR 0 1
93925: PPUSH
93926: LD_INT 0
93928: PPUSH
93929: CALL_OW 234
// end ;
93933: GO 93918
93935: POP
93936: POP
// end ;
93937: PPOPN 2
93939: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93940: LD_EXP 113
93944: PUSH
93945: LD_EXP 123
93949: AND
93950: IFFALSE 93970
93952: GO 93954
93954: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93955: LD_INT 32
93957: PPUSH
93958: LD_OWVAR 2
93962: PPUSH
93963: LD_INT 0
93965: PPUSH
93966: CALL_OW 324
93970: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93971: LD_EXP 113
93975: PUSH
93976: LD_EXP 124
93980: AND
93981: IFFALSE 94162
93983: GO 93985
93985: DISABLE
93986: LD_INT 0
93988: PPUSH
93989: PPUSH
93990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93991: LD_ADDR_VAR 0 2
93995: PUSH
93996: LD_INT 22
93998: PUSH
93999: LD_OWVAR 2
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 33
94010: PUSH
94011: LD_INT 3
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PPUSH
94022: CALL_OW 69
94026: ST_TO_ADDR
// if not tmp then
94027: LD_VAR 0 2
94031: NOT
94032: IFFALSE 94036
// exit ;
94034: GO 94162
// side := 0 ;
94036: LD_ADDR_VAR 0 3
94040: PUSH
94041: LD_INT 0
94043: ST_TO_ADDR
// for i := 1 to 8 do
94044: LD_ADDR_VAR 0 1
94048: PUSH
94049: DOUBLE
94050: LD_INT 1
94052: DEC
94053: ST_TO_ADDR
94054: LD_INT 8
94056: PUSH
94057: FOR_TO
94058: IFFALSE 94106
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94060: LD_OWVAR 2
94064: PUSH
94065: LD_VAR 0 1
94069: NONEQUAL
94070: PUSH
94071: LD_OWVAR 2
94075: PPUSH
94076: LD_VAR 0 1
94080: PPUSH
94081: CALL_OW 81
94085: PUSH
94086: LD_INT 2
94088: EQUAL
94089: AND
94090: IFFALSE 94104
// begin side := i ;
94092: LD_ADDR_VAR 0 3
94096: PUSH
94097: LD_VAR 0 1
94101: ST_TO_ADDR
// break ;
94102: GO 94106
// end ;
94104: GO 94057
94106: POP
94107: POP
// if not side then
94108: LD_VAR 0 3
94112: NOT
94113: IFFALSE 94117
// exit ;
94115: GO 94162
// for i := 1 to tmp do
94117: LD_ADDR_VAR 0 1
94121: PUSH
94122: DOUBLE
94123: LD_INT 1
94125: DEC
94126: ST_TO_ADDR
94127: LD_VAR 0 2
94131: PUSH
94132: FOR_TO
94133: IFFALSE 94160
// if Prob ( 60 ) then
94135: LD_INT 60
94137: PPUSH
94138: CALL_OW 13
94142: IFFALSE 94158
// SetSide ( i , side ) ;
94144: LD_VAR 0 1
94148: PPUSH
94149: LD_VAR 0 3
94153: PPUSH
94154: CALL_OW 235
94158: GO 94132
94160: POP
94161: POP
// end ;
94162: PPOPN 3
94164: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94165: LD_EXP 113
94169: PUSH
94170: LD_EXP 126
94174: AND
94175: IFFALSE 94294
94177: GO 94179
94179: DISABLE
94180: LD_INT 0
94182: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94183: LD_ADDR_VAR 0 1
94187: PUSH
94188: LD_INT 22
94190: PUSH
94191: LD_OWVAR 2
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PUSH
94200: LD_INT 21
94202: PUSH
94203: LD_INT 1
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 3
94212: PUSH
94213: LD_INT 23
94215: PUSH
94216: LD_INT 0
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: LIST
94231: PPUSH
94232: CALL_OW 69
94236: PUSH
94237: FOR_IN
94238: IFFALSE 94292
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94240: LD_VAR 0 1
94244: PPUSH
94245: CALL_OW 257
94249: PUSH
94250: LD_INT 1
94252: PUSH
94253: LD_INT 2
94255: PUSH
94256: LD_INT 3
94258: PUSH
94259: LD_INT 4
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: IN
94268: IFFALSE 94290
// SetClass ( un , rand ( 1 , 4 ) ) ;
94270: LD_VAR 0 1
94274: PPUSH
94275: LD_INT 1
94277: PPUSH
94278: LD_INT 4
94280: PPUSH
94281: CALL_OW 12
94285: PPUSH
94286: CALL_OW 336
94290: GO 94237
94292: POP
94293: POP
// end ;
94294: PPOPN 1
94296: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94297: LD_EXP 113
94301: PUSH
94302: LD_EXP 125
94306: AND
94307: IFFALSE 94386
94309: GO 94311
94311: DISABLE
94312: LD_INT 0
94314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94315: LD_ADDR_VAR 0 1
94319: PUSH
94320: LD_INT 22
94322: PUSH
94323: LD_OWVAR 2
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 21
94334: PUSH
94335: LD_INT 3
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PPUSH
94346: CALL_OW 69
94350: ST_TO_ADDR
// if not tmp then
94351: LD_VAR 0 1
94355: NOT
94356: IFFALSE 94360
// exit ;
94358: GO 94386
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94360: LD_VAR 0 1
94364: PUSH
94365: LD_INT 1
94367: PPUSH
94368: LD_VAR 0 1
94372: PPUSH
94373: CALL_OW 12
94377: ARRAY
94378: PPUSH
94379: LD_INT 100
94381: PPUSH
94382: CALL_OW 234
// end ;
94386: PPOPN 1
94388: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94389: LD_EXP 113
94393: PUSH
94394: LD_EXP 127
94398: AND
94399: IFFALSE 94497
94401: GO 94403
94403: DISABLE
94404: LD_INT 0
94406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94407: LD_ADDR_VAR 0 1
94411: PUSH
94412: LD_INT 22
94414: PUSH
94415: LD_OWVAR 2
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 21
94426: PUSH
94427: LD_INT 1
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PPUSH
94438: CALL_OW 69
94442: ST_TO_ADDR
// if not tmp then
94443: LD_VAR 0 1
94447: NOT
94448: IFFALSE 94452
// exit ;
94450: GO 94497
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94452: LD_VAR 0 1
94456: PUSH
94457: LD_INT 1
94459: PPUSH
94460: LD_VAR 0 1
94464: PPUSH
94465: CALL_OW 12
94469: ARRAY
94470: PPUSH
94471: LD_INT 1
94473: PPUSH
94474: LD_INT 4
94476: PPUSH
94477: CALL_OW 12
94481: PPUSH
94482: LD_INT 3000
94484: PPUSH
94485: LD_INT 9000
94487: PPUSH
94488: CALL_OW 12
94492: PPUSH
94493: CALL_OW 492
// end ;
94497: PPOPN 1
94499: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94500: LD_EXP 113
94504: PUSH
94505: LD_EXP 128
94509: AND
94510: IFFALSE 94530
94512: GO 94514
94514: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94515: LD_INT 1
94517: PPUSH
94518: LD_OWVAR 2
94522: PPUSH
94523: LD_INT 0
94525: PPUSH
94526: CALL_OW 324
94530: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94531: LD_EXP 113
94535: PUSH
94536: LD_EXP 129
94540: AND
94541: IFFALSE 94624
94543: GO 94545
94545: DISABLE
94546: LD_INT 0
94548: PPUSH
94549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94550: LD_ADDR_VAR 0 2
94554: PUSH
94555: LD_INT 22
94557: PUSH
94558: LD_OWVAR 2
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 21
94569: PUSH
94570: LD_INT 3
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PPUSH
94581: CALL_OW 69
94585: ST_TO_ADDR
// if not tmp then
94586: LD_VAR 0 2
94590: NOT
94591: IFFALSE 94595
// exit ;
94593: GO 94624
// for i in tmp do
94595: LD_ADDR_VAR 0 1
94599: PUSH
94600: LD_VAR 0 2
94604: PUSH
94605: FOR_IN
94606: IFFALSE 94622
// SetBLevel ( i , 10 ) ;
94608: LD_VAR 0 1
94612: PPUSH
94613: LD_INT 10
94615: PPUSH
94616: CALL_OW 241
94620: GO 94605
94622: POP
94623: POP
// end ;
94624: PPOPN 2
94626: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94627: LD_EXP 113
94631: PUSH
94632: LD_EXP 130
94636: AND
94637: IFFALSE 94748
94639: GO 94641
94641: DISABLE
94642: LD_INT 0
94644: PPUSH
94645: PPUSH
94646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94647: LD_ADDR_VAR 0 3
94651: PUSH
94652: LD_INT 22
94654: PUSH
94655: LD_OWVAR 2
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 25
94666: PUSH
94667: LD_INT 1
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PPUSH
94678: CALL_OW 69
94682: ST_TO_ADDR
// if not tmp then
94683: LD_VAR 0 3
94687: NOT
94688: IFFALSE 94692
// exit ;
94690: GO 94748
// un := tmp [ rand ( 1 , tmp ) ] ;
94692: LD_ADDR_VAR 0 2
94696: PUSH
94697: LD_VAR 0 3
94701: PUSH
94702: LD_INT 1
94704: PPUSH
94705: LD_VAR 0 3
94709: PPUSH
94710: CALL_OW 12
94714: ARRAY
94715: ST_TO_ADDR
// if Crawls ( un ) then
94716: LD_VAR 0 2
94720: PPUSH
94721: CALL_OW 318
94725: IFFALSE 94736
// ComWalk ( un ) ;
94727: LD_VAR 0 2
94731: PPUSH
94732: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94736: LD_VAR 0 2
94740: PPUSH
94741: LD_INT 5
94743: PPUSH
94744: CALL_OW 336
// end ;
94748: PPOPN 3
94750: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
94751: LD_EXP 113
94755: PUSH
94756: LD_EXP 131
94760: AND
94761: PUSH
94762: LD_OWVAR 67
94766: PUSH
94767: LD_INT 3
94769: LESS
94770: AND
94771: IFFALSE 94790
94773: GO 94775
94775: DISABLE
// Difficulty := Difficulty + 1 ;
94776: LD_ADDR_OWVAR 67
94780: PUSH
94781: LD_OWVAR 67
94785: PUSH
94786: LD_INT 1
94788: PLUS
94789: ST_TO_ADDR
94790: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94791: LD_EXP 113
94795: PUSH
94796: LD_EXP 132
94800: AND
94801: IFFALSE 94904
94803: GO 94805
94805: DISABLE
94806: LD_INT 0
94808: PPUSH
// begin for i := 1 to 5 do
94809: LD_ADDR_VAR 0 1
94813: PUSH
94814: DOUBLE
94815: LD_INT 1
94817: DEC
94818: ST_TO_ADDR
94819: LD_INT 5
94821: PUSH
94822: FOR_TO
94823: IFFALSE 94902
// begin uc_nation := nation_nature ;
94825: LD_ADDR_OWVAR 21
94829: PUSH
94830: LD_INT 0
94832: ST_TO_ADDR
// uc_side := 0 ;
94833: LD_ADDR_OWVAR 20
94837: PUSH
94838: LD_INT 0
94840: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94841: LD_ADDR_OWVAR 29
94845: PUSH
94846: LD_INT 12
94848: PUSH
94849: LD_INT 12
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: ST_TO_ADDR
// hc_agressivity := 20 ;
94856: LD_ADDR_OWVAR 35
94860: PUSH
94861: LD_INT 20
94863: ST_TO_ADDR
// hc_class := class_tiger ;
94864: LD_ADDR_OWVAR 28
94868: PUSH
94869: LD_INT 14
94871: ST_TO_ADDR
// hc_gallery :=  ;
94872: LD_ADDR_OWVAR 33
94876: PUSH
94877: LD_STRING 
94879: ST_TO_ADDR
// hc_name :=  ;
94880: LD_ADDR_OWVAR 26
94884: PUSH
94885: LD_STRING 
94887: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94888: CALL_OW 44
94892: PPUSH
94893: LD_INT 0
94895: PPUSH
94896: CALL_OW 51
// end ;
94900: GO 94822
94902: POP
94903: POP
// end ;
94904: PPOPN 1
94906: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94907: LD_EXP 113
94911: PUSH
94912: LD_EXP 133
94916: AND
94917: IFFALSE 94926
94919: GO 94921
94921: DISABLE
// StreamSibBomb ;
94922: CALL 94927 0 0
94926: END
// export function StreamSibBomb ; var i , x , y ; begin
94927: LD_INT 0
94929: PPUSH
94930: PPUSH
94931: PPUSH
94932: PPUSH
// result := false ;
94933: LD_ADDR_VAR 0 1
94937: PUSH
94938: LD_INT 0
94940: ST_TO_ADDR
// for i := 1 to 16 do
94941: LD_ADDR_VAR 0 2
94945: PUSH
94946: DOUBLE
94947: LD_INT 1
94949: DEC
94950: ST_TO_ADDR
94951: LD_INT 16
94953: PUSH
94954: FOR_TO
94955: IFFALSE 95154
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94957: LD_ADDR_VAR 0 3
94961: PUSH
94962: LD_INT 10
94964: PUSH
94965: LD_INT 20
94967: PUSH
94968: LD_INT 30
94970: PUSH
94971: LD_INT 40
94973: PUSH
94974: LD_INT 50
94976: PUSH
94977: LD_INT 60
94979: PUSH
94980: LD_INT 70
94982: PUSH
94983: LD_INT 80
94985: PUSH
94986: LD_INT 90
94988: PUSH
94989: LD_INT 100
94991: PUSH
94992: LD_INT 110
94994: PUSH
94995: LD_INT 120
94997: PUSH
94998: LD_INT 130
95000: PUSH
95001: LD_INT 140
95003: PUSH
95004: LD_INT 150
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 1
95026: PPUSH
95027: LD_INT 15
95029: PPUSH
95030: CALL_OW 12
95034: ARRAY
95035: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95036: LD_ADDR_VAR 0 4
95040: PUSH
95041: LD_INT 10
95043: PUSH
95044: LD_INT 20
95046: PUSH
95047: LD_INT 30
95049: PUSH
95050: LD_INT 40
95052: PUSH
95053: LD_INT 50
95055: PUSH
95056: LD_INT 60
95058: PUSH
95059: LD_INT 70
95061: PUSH
95062: LD_INT 80
95064: PUSH
95065: LD_INT 90
95067: PUSH
95068: LD_INT 100
95070: PUSH
95071: LD_INT 110
95073: PUSH
95074: LD_INT 120
95076: PUSH
95077: LD_INT 130
95079: PUSH
95080: LD_INT 140
95082: PUSH
95083: LD_INT 150
95085: PUSH
95086: EMPTY
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 1
95105: PPUSH
95106: LD_INT 15
95108: PPUSH
95109: CALL_OW 12
95113: ARRAY
95114: ST_TO_ADDR
// if ValidHex ( x , y ) then
95115: LD_VAR 0 3
95119: PPUSH
95120: LD_VAR 0 4
95124: PPUSH
95125: CALL_OW 488
95129: IFFALSE 95152
// begin result := [ x , y ] ;
95131: LD_ADDR_VAR 0 1
95135: PUSH
95136: LD_VAR 0 3
95140: PUSH
95141: LD_VAR 0 4
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: ST_TO_ADDR
// break ;
95150: GO 95154
// end ; end ;
95152: GO 94954
95154: POP
95155: POP
// if result then
95156: LD_VAR 0 1
95160: IFFALSE 95220
// begin ToLua ( playSibBomb() ) ;
95162: LD_STRING playSibBomb()
95164: PPUSH
95165: CALL_OW 559
// wait ( 0 0$14 ) ;
95169: LD_INT 490
95171: PPUSH
95172: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95176: LD_VAR 0 1
95180: PUSH
95181: LD_INT 1
95183: ARRAY
95184: PPUSH
95185: LD_VAR 0 1
95189: PUSH
95190: LD_INT 2
95192: ARRAY
95193: PPUSH
95194: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95198: LD_VAR 0 1
95202: PUSH
95203: LD_INT 1
95205: ARRAY
95206: PPUSH
95207: LD_VAR 0 1
95211: PUSH
95212: LD_INT 2
95214: ARRAY
95215: PPUSH
95216: CALL_OW 429
// end ; end ;
95220: LD_VAR 0 1
95224: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95225: LD_EXP 113
95229: PUSH
95230: LD_EXP 135
95234: AND
95235: IFFALSE 95247
95237: GO 95239
95239: DISABLE
// YouLost (  ) ;
95240: LD_STRING 
95242: PPUSH
95243: CALL_OW 104
95247: END
// every 0 0$1 trigger StreamModeActive and sFog do
95248: LD_EXP 113
95252: PUSH
95253: LD_EXP 134
95257: AND
95258: IFFALSE 95272
95260: GO 95262
95262: DISABLE
// FogOff ( your_side ) ;
95263: LD_OWVAR 2
95267: PPUSH
95268: CALL_OW 344
95272: END
// every 0 0$1 trigger StreamModeActive and sSun do
95273: LD_EXP 113
95277: PUSH
95278: LD_EXP 136
95282: AND
95283: IFFALSE 95311
95285: GO 95287
95287: DISABLE
// begin solar_recharge_percent := 0 ;
95288: LD_ADDR_OWVAR 79
95292: PUSH
95293: LD_INT 0
95295: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95296: LD_INT 10500
95298: PPUSH
95299: CALL_OW 67
// solar_recharge_percent := 100 ;
95303: LD_ADDR_OWVAR 79
95307: PUSH
95308: LD_INT 100
95310: ST_TO_ADDR
// end ;
95311: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95312: LD_EXP 113
95316: PUSH
95317: LD_EXP 137
95321: AND
95322: IFFALSE 95561
95324: GO 95326
95326: DISABLE
95327: LD_INT 0
95329: PPUSH
95330: PPUSH
95331: PPUSH
// begin tmp := [ ] ;
95332: LD_ADDR_VAR 0 3
95336: PUSH
95337: EMPTY
95338: ST_TO_ADDR
// for i := 1 to 6 do
95339: LD_ADDR_VAR 0 1
95343: PUSH
95344: DOUBLE
95345: LD_INT 1
95347: DEC
95348: ST_TO_ADDR
95349: LD_INT 6
95351: PUSH
95352: FOR_TO
95353: IFFALSE 95458
// begin uc_nation := nation_nature ;
95355: LD_ADDR_OWVAR 21
95359: PUSH
95360: LD_INT 0
95362: ST_TO_ADDR
// uc_side := 0 ;
95363: LD_ADDR_OWVAR 20
95367: PUSH
95368: LD_INT 0
95370: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95371: LD_ADDR_OWVAR 29
95375: PUSH
95376: LD_INT 12
95378: PUSH
95379: LD_INT 12
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: ST_TO_ADDR
// hc_agressivity := 20 ;
95386: LD_ADDR_OWVAR 35
95390: PUSH
95391: LD_INT 20
95393: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95394: LD_ADDR_OWVAR 28
95398: PUSH
95399: LD_INT 17
95401: ST_TO_ADDR
// hc_gallery :=  ;
95402: LD_ADDR_OWVAR 33
95406: PUSH
95407: LD_STRING 
95409: ST_TO_ADDR
// hc_name :=  ;
95410: LD_ADDR_OWVAR 26
95414: PUSH
95415: LD_STRING 
95417: ST_TO_ADDR
// un := CreateHuman ;
95418: LD_ADDR_VAR 0 2
95422: PUSH
95423: CALL_OW 44
95427: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95428: LD_VAR 0 2
95432: PPUSH
95433: LD_INT 1
95435: PPUSH
95436: CALL_OW 51
// tmp := tmp ^ un ;
95440: LD_ADDR_VAR 0 3
95444: PUSH
95445: LD_VAR 0 3
95449: PUSH
95450: LD_VAR 0 2
95454: ADD
95455: ST_TO_ADDR
// end ;
95456: GO 95352
95458: POP
95459: POP
// repeat wait ( 0 0$1 ) ;
95460: LD_INT 35
95462: PPUSH
95463: CALL_OW 67
// for un in tmp do
95467: LD_ADDR_VAR 0 2
95471: PUSH
95472: LD_VAR 0 3
95476: PUSH
95477: FOR_IN
95478: IFFALSE 95552
// begin if IsDead ( un ) then
95480: LD_VAR 0 2
95484: PPUSH
95485: CALL_OW 301
95489: IFFALSE 95509
// begin tmp := tmp diff un ;
95491: LD_ADDR_VAR 0 3
95495: PUSH
95496: LD_VAR 0 3
95500: PUSH
95501: LD_VAR 0 2
95505: DIFF
95506: ST_TO_ADDR
// continue ;
95507: GO 95477
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95509: LD_VAR 0 2
95513: PPUSH
95514: LD_INT 3
95516: PUSH
95517: LD_INT 22
95519: PUSH
95520: LD_INT 0
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PPUSH
95531: CALL_OW 69
95535: PPUSH
95536: LD_VAR 0 2
95540: PPUSH
95541: CALL_OW 74
95545: PPUSH
95546: CALL_OW 115
// end ;
95550: GO 95477
95552: POP
95553: POP
// until not tmp ;
95554: LD_VAR 0 3
95558: NOT
95559: IFFALSE 95460
// end ;
95561: PPOPN 3
95563: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95564: LD_EXP 113
95568: PUSH
95569: LD_EXP 138
95573: AND
95574: IFFALSE 95628
95576: GO 95578
95578: DISABLE
// begin ToLua ( displayTroll(); ) ;
95579: LD_STRING displayTroll();
95581: PPUSH
95582: CALL_OW 559
// wait ( 3 3$00 ) ;
95586: LD_INT 6300
95588: PPUSH
95589: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95593: LD_STRING hideTroll();
95595: PPUSH
95596: CALL_OW 559
// wait ( 1 1$00 ) ;
95600: LD_INT 2100
95602: PPUSH
95603: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95607: LD_STRING displayTroll();
95609: PPUSH
95610: CALL_OW 559
// wait ( 1 1$00 ) ;
95614: LD_INT 2100
95616: PPUSH
95617: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95621: LD_STRING hideTroll();
95623: PPUSH
95624: CALL_OW 559
// end ;
95628: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95629: LD_EXP 113
95633: PUSH
95634: LD_EXP 139
95638: AND
95639: IFFALSE 95702
95641: GO 95643
95643: DISABLE
95644: LD_INT 0
95646: PPUSH
// begin p := 0 ;
95647: LD_ADDR_VAR 0 1
95651: PUSH
95652: LD_INT 0
95654: ST_TO_ADDR
// repeat game_speed := 1 ;
95655: LD_ADDR_OWVAR 65
95659: PUSH
95660: LD_INT 1
95662: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95663: LD_INT 35
95665: PPUSH
95666: CALL_OW 67
// p := p + 1 ;
95670: LD_ADDR_VAR 0 1
95674: PUSH
95675: LD_VAR 0 1
95679: PUSH
95680: LD_INT 1
95682: PLUS
95683: ST_TO_ADDR
// until p >= 60 ;
95684: LD_VAR 0 1
95688: PUSH
95689: LD_INT 60
95691: GREATEREQUAL
95692: IFFALSE 95655
// game_speed := 4 ;
95694: LD_ADDR_OWVAR 65
95698: PUSH
95699: LD_INT 4
95701: ST_TO_ADDR
// end ;
95702: PPOPN 1
95704: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95705: LD_EXP 113
95709: PUSH
95710: LD_EXP 140
95714: AND
95715: IFFALSE 95861
95717: GO 95719
95719: DISABLE
95720: LD_INT 0
95722: PPUSH
95723: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95724: LD_ADDR_VAR 0 1
95728: PUSH
95729: LD_INT 22
95731: PUSH
95732: LD_OWVAR 2
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: PUSH
95741: LD_INT 2
95743: PUSH
95744: LD_INT 30
95746: PUSH
95747: LD_INT 0
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 30
95756: PUSH
95757: LD_INT 1
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: LIST
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: PPUSH
95773: CALL_OW 69
95777: ST_TO_ADDR
// if not depot then
95778: LD_VAR 0 1
95782: NOT
95783: IFFALSE 95787
// exit ;
95785: GO 95861
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95787: LD_ADDR_VAR 0 2
95791: PUSH
95792: LD_VAR 0 1
95796: PUSH
95797: LD_INT 1
95799: PPUSH
95800: LD_VAR 0 1
95804: PPUSH
95805: CALL_OW 12
95809: ARRAY
95810: PPUSH
95811: CALL_OW 274
95815: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95816: LD_VAR 0 2
95820: PPUSH
95821: LD_INT 1
95823: PPUSH
95824: LD_INT 0
95826: PPUSH
95827: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95831: LD_VAR 0 2
95835: PPUSH
95836: LD_INT 2
95838: PPUSH
95839: LD_INT 0
95841: PPUSH
95842: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95846: LD_VAR 0 2
95850: PPUSH
95851: LD_INT 3
95853: PPUSH
95854: LD_INT 0
95856: PPUSH
95857: CALL_OW 277
// end ;
95861: PPOPN 2
95863: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95864: LD_EXP 113
95868: PUSH
95869: LD_EXP 141
95873: AND
95874: IFFALSE 95971
95876: GO 95878
95878: DISABLE
95879: LD_INT 0
95881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95882: LD_ADDR_VAR 0 1
95886: PUSH
95887: LD_INT 22
95889: PUSH
95890: LD_OWVAR 2
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 21
95901: PUSH
95902: LD_INT 1
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 3
95911: PUSH
95912: LD_INT 23
95914: PUSH
95915: LD_INT 0
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: LIST
95930: PPUSH
95931: CALL_OW 69
95935: ST_TO_ADDR
// if not tmp then
95936: LD_VAR 0 1
95940: NOT
95941: IFFALSE 95945
// exit ;
95943: GO 95971
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95945: LD_VAR 0 1
95949: PUSH
95950: LD_INT 1
95952: PPUSH
95953: LD_VAR 0 1
95957: PPUSH
95958: CALL_OW 12
95962: ARRAY
95963: PPUSH
95964: LD_INT 200
95966: PPUSH
95967: CALL_OW 234
// end ;
95971: PPOPN 1
95973: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95974: LD_EXP 113
95978: PUSH
95979: LD_EXP 142
95983: AND
95984: IFFALSE 96063
95986: GO 95988
95988: DISABLE
95989: LD_INT 0
95991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95992: LD_ADDR_VAR 0 1
95996: PUSH
95997: LD_INT 22
95999: PUSH
96000: LD_OWVAR 2
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: LD_INT 21
96011: PUSH
96012: LD_INT 2
96014: PUSH
96015: EMPTY
96016: LIST
96017: LIST
96018: PUSH
96019: EMPTY
96020: LIST
96021: LIST
96022: PPUSH
96023: CALL_OW 69
96027: ST_TO_ADDR
// if not tmp then
96028: LD_VAR 0 1
96032: NOT
96033: IFFALSE 96037
// exit ;
96035: GO 96063
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96037: LD_VAR 0 1
96041: PUSH
96042: LD_INT 1
96044: PPUSH
96045: LD_VAR 0 1
96049: PPUSH
96050: CALL_OW 12
96054: ARRAY
96055: PPUSH
96056: LD_INT 60
96058: PPUSH
96059: CALL_OW 234
// end ;
96063: PPOPN 1
96065: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96066: LD_EXP 113
96070: PUSH
96071: LD_EXP 143
96075: AND
96076: IFFALSE 96175
96078: GO 96080
96080: DISABLE
96081: LD_INT 0
96083: PPUSH
96084: PPUSH
// begin enable ;
96085: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96086: LD_ADDR_VAR 0 1
96090: PUSH
96091: LD_INT 22
96093: PUSH
96094: LD_OWVAR 2
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 61
96105: PUSH
96106: EMPTY
96107: LIST
96108: PUSH
96109: LD_INT 33
96111: PUSH
96112: LD_INT 2
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: PUSH
96119: EMPTY
96120: LIST
96121: LIST
96122: LIST
96123: PPUSH
96124: CALL_OW 69
96128: ST_TO_ADDR
// if not tmp then
96129: LD_VAR 0 1
96133: NOT
96134: IFFALSE 96138
// exit ;
96136: GO 96175
// for i in tmp do
96138: LD_ADDR_VAR 0 2
96142: PUSH
96143: LD_VAR 0 1
96147: PUSH
96148: FOR_IN
96149: IFFALSE 96173
// if IsControledBy ( i ) then
96151: LD_VAR 0 2
96155: PPUSH
96156: CALL_OW 312
96160: IFFALSE 96171
// ComUnlink ( i ) ;
96162: LD_VAR 0 2
96166: PPUSH
96167: CALL_OW 136
96171: GO 96148
96173: POP
96174: POP
// end ;
96175: PPOPN 2
96177: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96178: LD_EXP 113
96182: PUSH
96183: LD_EXP 144
96187: AND
96188: IFFALSE 96328
96190: GO 96192
96192: DISABLE
96193: LD_INT 0
96195: PPUSH
96196: PPUSH
// begin ToLua ( displayPowell(); ) ;
96197: LD_STRING displayPowell();
96199: PPUSH
96200: CALL_OW 559
// uc_side := 0 ;
96204: LD_ADDR_OWVAR 20
96208: PUSH
96209: LD_INT 0
96211: ST_TO_ADDR
// uc_nation := 2 ;
96212: LD_ADDR_OWVAR 21
96216: PUSH
96217: LD_INT 2
96219: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96220: LD_ADDR_OWVAR 37
96224: PUSH
96225: LD_INT 14
96227: ST_TO_ADDR
// vc_engine := engine_siberite ;
96228: LD_ADDR_OWVAR 39
96232: PUSH
96233: LD_INT 3
96235: ST_TO_ADDR
// vc_control := control_apeman ;
96236: LD_ADDR_OWVAR 38
96240: PUSH
96241: LD_INT 5
96243: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96244: LD_ADDR_OWVAR 40
96248: PUSH
96249: LD_INT 29
96251: ST_TO_ADDR
// un := CreateVehicle ;
96252: LD_ADDR_VAR 0 2
96256: PUSH
96257: CALL_OW 45
96261: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96262: LD_VAR 0 2
96266: PPUSH
96267: LD_INT 1
96269: PPUSH
96270: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96274: LD_INT 35
96276: PPUSH
96277: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96281: LD_VAR 0 2
96285: PPUSH
96286: LD_INT 22
96288: PUSH
96289: LD_OWVAR 2
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: PPUSH
96298: CALL_OW 69
96302: PPUSH
96303: LD_VAR 0 2
96307: PPUSH
96308: CALL_OW 74
96312: PPUSH
96313: CALL_OW 115
// until IsDead ( un ) ;
96317: LD_VAR 0 2
96321: PPUSH
96322: CALL_OW 301
96326: IFFALSE 96274
// end ;
96328: PPOPN 2
96330: END
// every 0 0$1 trigger StreamModeActive and sStu do
96331: LD_EXP 113
96335: PUSH
96336: LD_EXP 152
96340: AND
96341: IFFALSE 96357
96343: GO 96345
96345: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96346: LD_STRING displayStucuk();
96348: PPUSH
96349: CALL_OW 559
// ResetFog ;
96353: CALL_OW 335
// end ;
96357: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96358: LD_EXP 113
96362: PUSH
96363: LD_EXP 145
96367: AND
96368: IFFALSE 96509
96370: GO 96372
96372: DISABLE
96373: LD_INT 0
96375: PPUSH
96376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96377: LD_ADDR_VAR 0 2
96381: PUSH
96382: LD_INT 22
96384: PUSH
96385: LD_OWVAR 2
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 21
96396: PUSH
96397: LD_INT 1
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: EMPTY
96405: LIST
96406: LIST
96407: PPUSH
96408: CALL_OW 69
96412: ST_TO_ADDR
// if not tmp then
96413: LD_VAR 0 2
96417: NOT
96418: IFFALSE 96422
// exit ;
96420: GO 96509
// un := tmp [ rand ( 1 , tmp ) ] ;
96422: LD_ADDR_VAR 0 1
96426: PUSH
96427: LD_VAR 0 2
96431: PUSH
96432: LD_INT 1
96434: PPUSH
96435: LD_VAR 0 2
96439: PPUSH
96440: CALL_OW 12
96444: ARRAY
96445: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96446: LD_VAR 0 1
96450: PPUSH
96451: LD_INT 0
96453: PPUSH
96454: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96458: LD_VAR 0 1
96462: PPUSH
96463: LD_OWVAR 3
96467: PUSH
96468: LD_VAR 0 1
96472: DIFF
96473: PPUSH
96474: LD_VAR 0 1
96478: PPUSH
96479: CALL_OW 74
96483: PPUSH
96484: CALL_OW 115
// wait ( 0 0$20 ) ;
96488: LD_INT 700
96490: PPUSH
96491: CALL_OW 67
// SetSide ( un , your_side ) ;
96495: LD_VAR 0 1
96499: PPUSH
96500: LD_OWVAR 2
96504: PPUSH
96505: CALL_OW 235
// end ;
96509: PPOPN 2
96511: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96512: LD_EXP 113
96516: PUSH
96517: LD_EXP 146
96521: AND
96522: IFFALSE 96628
96524: GO 96526
96526: DISABLE
96527: LD_INT 0
96529: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96530: LD_ADDR_VAR 0 1
96534: PUSH
96535: LD_INT 22
96537: PUSH
96538: LD_OWVAR 2
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PUSH
96547: LD_INT 2
96549: PUSH
96550: LD_INT 30
96552: PUSH
96553: LD_INT 0
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 30
96562: PUSH
96563: LD_INT 1
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: LIST
96574: PUSH
96575: EMPTY
96576: LIST
96577: LIST
96578: PPUSH
96579: CALL_OW 69
96583: ST_TO_ADDR
// if not depot then
96584: LD_VAR 0 1
96588: NOT
96589: IFFALSE 96593
// exit ;
96591: GO 96628
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96593: LD_VAR 0 1
96597: PUSH
96598: LD_INT 1
96600: ARRAY
96601: PPUSH
96602: CALL_OW 250
96606: PPUSH
96607: LD_VAR 0 1
96611: PUSH
96612: LD_INT 1
96614: ARRAY
96615: PPUSH
96616: CALL_OW 251
96620: PPUSH
96621: LD_INT 70
96623: PPUSH
96624: CALL_OW 495
// end ;
96628: PPOPN 1
96630: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96631: LD_EXP 113
96635: PUSH
96636: LD_EXP 147
96640: AND
96641: IFFALSE 96852
96643: GO 96645
96645: DISABLE
96646: LD_INT 0
96648: PPUSH
96649: PPUSH
96650: PPUSH
96651: PPUSH
96652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96653: LD_ADDR_VAR 0 5
96657: PUSH
96658: LD_INT 22
96660: PUSH
96661: LD_OWVAR 2
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 21
96672: PUSH
96673: LD_INT 1
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PPUSH
96684: CALL_OW 69
96688: ST_TO_ADDR
// if not tmp then
96689: LD_VAR 0 5
96693: NOT
96694: IFFALSE 96698
// exit ;
96696: GO 96852
// for i in tmp do
96698: LD_ADDR_VAR 0 1
96702: PUSH
96703: LD_VAR 0 5
96707: PUSH
96708: FOR_IN
96709: IFFALSE 96850
// begin d := rand ( 0 , 5 ) ;
96711: LD_ADDR_VAR 0 4
96715: PUSH
96716: LD_INT 0
96718: PPUSH
96719: LD_INT 5
96721: PPUSH
96722: CALL_OW 12
96726: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96727: LD_ADDR_VAR 0 2
96731: PUSH
96732: LD_VAR 0 1
96736: PPUSH
96737: CALL_OW 250
96741: PPUSH
96742: LD_VAR 0 4
96746: PPUSH
96747: LD_INT 3
96749: PPUSH
96750: LD_INT 12
96752: PPUSH
96753: CALL_OW 12
96757: PPUSH
96758: CALL_OW 272
96762: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96763: LD_ADDR_VAR 0 3
96767: PUSH
96768: LD_VAR 0 1
96772: PPUSH
96773: CALL_OW 251
96777: PPUSH
96778: LD_VAR 0 4
96782: PPUSH
96783: LD_INT 3
96785: PPUSH
96786: LD_INT 12
96788: PPUSH
96789: CALL_OW 12
96793: PPUSH
96794: CALL_OW 273
96798: ST_TO_ADDR
// if ValidHex ( x , y ) then
96799: LD_VAR 0 2
96803: PPUSH
96804: LD_VAR 0 3
96808: PPUSH
96809: CALL_OW 488
96813: IFFALSE 96848
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96815: LD_VAR 0 1
96819: PPUSH
96820: LD_VAR 0 2
96824: PPUSH
96825: LD_VAR 0 3
96829: PPUSH
96830: LD_INT 3
96832: PPUSH
96833: LD_INT 6
96835: PPUSH
96836: CALL_OW 12
96840: PPUSH
96841: LD_INT 1
96843: PPUSH
96844: CALL_OW 483
// end ;
96848: GO 96708
96850: POP
96851: POP
// end ;
96852: PPOPN 5
96854: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96855: LD_EXP 113
96859: PUSH
96860: LD_EXP 148
96864: AND
96865: IFFALSE 96959
96867: GO 96869
96869: DISABLE
96870: LD_INT 0
96872: PPUSH
96873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96874: LD_ADDR_VAR 0 2
96878: PUSH
96879: LD_INT 22
96881: PUSH
96882: LD_OWVAR 2
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 32
96893: PUSH
96894: LD_INT 1
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 21
96903: PUSH
96904: LD_INT 2
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: LIST
96915: PPUSH
96916: CALL_OW 69
96920: ST_TO_ADDR
// if not tmp then
96921: LD_VAR 0 2
96925: NOT
96926: IFFALSE 96930
// exit ;
96928: GO 96959
// for i in tmp do
96930: LD_ADDR_VAR 0 1
96934: PUSH
96935: LD_VAR 0 2
96939: PUSH
96940: FOR_IN
96941: IFFALSE 96957
// SetFuel ( i , 0 ) ;
96943: LD_VAR 0 1
96947: PPUSH
96948: LD_INT 0
96950: PPUSH
96951: CALL_OW 240
96955: GO 96940
96957: POP
96958: POP
// end ;
96959: PPOPN 2
96961: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96962: LD_EXP 113
96966: PUSH
96967: LD_EXP 149
96971: AND
96972: IFFALSE 97038
96974: GO 96976
96976: DISABLE
96977: LD_INT 0
96979: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96980: LD_ADDR_VAR 0 1
96984: PUSH
96985: LD_INT 22
96987: PUSH
96988: LD_OWVAR 2
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 30
96999: PUSH
97000: LD_INT 29
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PPUSH
97011: CALL_OW 69
97015: ST_TO_ADDR
// if not tmp then
97016: LD_VAR 0 1
97020: NOT
97021: IFFALSE 97025
// exit ;
97023: GO 97038
// DestroyUnit ( tmp [ 1 ] ) ;
97025: LD_VAR 0 1
97029: PUSH
97030: LD_INT 1
97032: ARRAY
97033: PPUSH
97034: CALL_OW 65
// end ;
97038: PPOPN 1
97040: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97041: LD_EXP 113
97045: PUSH
97046: LD_EXP 151
97050: AND
97051: IFFALSE 97180
97053: GO 97055
97055: DISABLE
97056: LD_INT 0
97058: PPUSH
// begin uc_side := 0 ;
97059: LD_ADDR_OWVAR 20
97063: PUSH
97064: LD_INT 0
97066: ST_TO_ADDR
// uc_nation := nation_arabian ;
97067: LD_ADDR_OWVAR 21
97071: PUSH
97072: LD_INT 2
97074: ST_TO_ADDR
// hc_gallery :=  ;
97075: LD_ADDR_OWVAR 33
97079: PUSH
97080: LD_STRING 
97082: ST_TO_ADDR
// hc_name :=  ;
97083: LD_ADDR_OWVAR 26
97087: PUSH
97088: LD_STRING 
97090: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97091: LD_INT 1
97093: PPUSH
97094: LD_INT 11
97096: PPUSH
97097: LD_INT 10
97099: PPUSH
97100: CALL_OW 380
// un := CreateHuman ;
97104: LD_ADDR_VAR 0 1
97108: PUSH
97109: CALL_OW 44
97113: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97114: LD_VAR 0 1
97118: PPUSH
97119: LD_INT 1
97121: PPUSH
97122: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97126: LD_INT 35
97128: PPUSH
97129: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97133: LD_VAR 0 1
97137: PPUSH
97138: LD_INT 22
97140: PUSH
97141: LD_OWVAR 2
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PPUSH
97150: CALL_OW 69
97154: PPUSH
97155: LD_VAR 0 1
97159: PPUSH
97160: CALL_OW 74
97164: PPUSH
97165: CALL_OW 115
// until IsDead ( un ) ;
97169: LD_VAR 0 1
97173: PPUSH
97174: CALL_OW 301
97178: IFFALSE 97126
// end ;
97180: PPOPN 1
97182: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97183: LD_EXP 113
97187: PUSH
97188: LD_EXP 153
97192: AND
97193: IFFALSE 97205
97195: GO 97197
97197: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97198: LD_STRING earthquake(getX(game), 0, 32)
97200: PPUSH
97201: CALL_OW 559
97205: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97206: LD_EXP 113
97210: PUSH
97211: LD_EXP 154
97215: AND
97216: IFFALSE 97307
97218: GO 97220
97220: DISABLE
97221: LD_INT 0
97223: PPUSH
// begin enable ;
97224: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97225: LD_ADDR_VAR 0 1
97229: PUSH
97230: LD_INT 22
97232: PUSH
97233: LD_OWVAR 2
97237: PUSH
97238: EMPTY
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 21
97244: PUSH
97245: LD_INT 2
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: PUSH
97252: LD_INT 33
97254: PUSH
97255: LD_INT 3
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: LIST
97266: PPUSH
97267: CALL_OW 69
97271: ST_TO_ADDR
// if not tmp then
97272: LD_VAR 0 1
97276: NOT
97277: IFFALSE 97281
// exit ;
97279: GO 97307
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97281: LD_VAR 0 1
97285: PUSH
97286: LD_INT 1
97288: PPUSH
97289: LD_VAR 0 1
97293: PPUSH
97294: CALL_OW 12
97298: ARRAY
97299: PPUSH
97300: LD_INT 1
97302: PPUSH
97303: CALL_OW 234
// end ;
97307: PPOPN 1
97309: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97310: LD_EXP 113
97314: PUSH
97315: LD_EXP 155
97319: AND
97320: IFFALSE 97461
97322: GO 97324
97324: DISABLE
97325: LD_INT 0
97327: PPUSH
97328: PPUSH
97329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97330: LD_ADDR_VAR 0 3
97334: PUSH
97335: LD_INT 22
97337: PUSH
97338: LD_OWVAR 2
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: PUSH
97347: LD_INT 25
97349: PUSH
97350: LD_INT 1
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PPUSH
97361: CALL_OW 69
97365: ST_TO_ADDR
// if not tmp then
97366: LD_VAR 0 3
97370: NOT
97371: IFFALSE 97375
// exit ;
97373: GO 97461
// un := tmp [ rand ( 1 , tmp ) ] ;
97375: LD_ADDR_VAR 0 2
97379: PUSH
97380: LD_VAR 0 3
97384: PUSH
97385: LD_INT 1
97387: PPUSH
97388: LD_VAR 0 3
97392: PPUSH
97393: CALL_OW 12
97397: ARRAY
97398: ST_TO_ADDR
// if Crawls ( un ) then
97399: LD_VAR 0 2
97403: PPUSH
97404: CALL_OW 318
97408: IFFALSE 97419
// ComWalk ( un ) ;
97410: LD_VAR 0 2
97414: PPUSH
97415: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97419: LD_VAR 0 2
97423: PPUSH
97424: LD_INT 9
97426: PPUSH
97427: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97431: LD_INT 28
97433: PPUSH
97434: LD_OWVAR 2
97438: PPUSH
97439: LD_INT 2
97441: PPUSH
97442: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97446: LD_INT 29
97448: PPUSH
97449: LD_OWVAR 2
97453: PPUSH
97454: LD_INT 2
97456: PPUSH
97457: CALL_OW 322
// end ;
97461: PPOPN 3
97463: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97464: LD_EXP 113
97468: PUSH
97469: LD_EXP 156
97473: AND
97474: IFFALSE 97585
97476: GO 97478
97478: DISABLE
97479: LD_INT 0
97481: PPUSH
97482: PPUSH
97483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97484: LD_ADDR_VAR 0 3
97488: PUSH
97489: LD_INT 22
97491: PUSH
97492: LD_OWVAR 2
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 25
97503: PUSH
97504: LD_INT 1
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: EMPTY
97512: LIST
97513: LIST
97514: PPUSH
97515: CALL_OW 69
97519: ST_TO_ADDR
// if not tmp then
97520: LD_VAR 0 3
97524: NOT
97525: IFFALSE 97529
// exit ;
97527: GO 97585
// un := tmp [ rand ( 1 , tmp ) ] ;
97529: LD_ADDR_VAR 0 2
97533: PUSH
97534: LD_VAR 0 3
97538: PUSH
97539: LD_INT 1
97541: PPUSH
97542: LD_VAR 0 3
97546: PPUSH
97547: CALL_OW 12
97551: ARRAY
97552: ST_TO_ADDR
// if Crawls ( un ) then
97553: LD_VAR 0 2
97557: PPUSH
97558: CALL_OW 318
97562: IFFALSE 97573
// ComWalk ( un ) ;
97564: LD_VAR 0 2
97568: PPUSH
97569: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97573: LD_VAR 0 2
97577: PPUSH
97578: LD_INT 8
97580: PPUSH
97581: CALL_OW 336
// end ;
97585: PPOPN 3
97587: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97588: LD_EXP 113
97592: PUSH
97593: LD_EXP 157
97597: AND
97598: IFFALSE 97742
97600: GO 97602
97602: DISABLE
97603: LD_INT 0
97605: PPUSH
97606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97607: LD_ADDR_VAR 0 2
97611: PUSH
97612: LD_INT 22
97614: PUSH
97615: LD_OWVAR 2
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PUSH
97624: LD_INT 21
97626: PUSH
97627: LD_INT 2
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: LD_INT 2
97636: PUSH
97637: LD_INT 34
97639: PUSH
97640: LD_INT 12
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: PUSH
97647: LD_INT 34
97649: PUSH
97650: LD_INT 51
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: PUSH
97657: LD_INT 34
97659: PUSH
97660: LD_INT 32
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: PUSH
97673: EMPTY
97674: LIST
97675: LIST
97676: LIST
97677: PPUSH
97678: CALL_OW 69
97682: ST_TO_ADDR
// if not tmp then
97683: LD_VAR 0 2
97687: NOT
97688: IFFALSE 97692
// exit ;
97690: GO 97742
// for i in tmp do
97692: LD_ADDR_VAR 0 1
97696: PUSH
97697: LD_VAR 0 2
97701: PUSH
97702: FOR_IN
97703: IFFALSE 97740
// if GetCargo ( i , mat_artifact ) = 0 then
97705: LD_VAR 0 1
97709: PPUSH
97710: LD_INT 4
97712: PPUSH
97713: CALL_OW 289
97717: PUSH
97718: LD_INT 0
97720: EQUAL
97721: IFFALSE 97738
// SetCargo ( i , mat_siberit , 100 ) ;
97723: LD_VAR 0 1
97727: PPUSH
97728: LD_INT 3
97730: PPUSH
97731: LD_INT 100
97733: PPUSH
97734: CALL_OW 290
97738: GO 97702
97740: POP
97741: POP
// end ;
97742: PPOPN 2
97744: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97745: LD_EXP 113
97749: PUSH
97750: LD_EXP 158
97754: AND
97755: IFFALSE 97938
97757: GO 97759
97759: DISABLE
97760: LD_INT 0
97762: PPUSH
97763: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97764: LD_ADDR_VAR 0 2
97768: PUSH
97769: LD_INT 22
97771: PUSH
97772: LD_OWVAR 2
97776: PUSH
97777: EMPTY
97778: LIST
97779: LIST
97780: PPUSH
97781: CALL_OW 69
97785: ST_TO_ADDR
// if not tmp then
97786: LD_VAR 0 2
97790: NOT
97791: IFFALSE 97795
// exit ;
97793: GO 97938
// for i := 1 to 2 do
97795: LD_ADDR_VAR 0 1
97799: PUSH
97800: DOUBLE
97801: LD_INT 1
97803: DEC
97804: ST_TO_ADDR
97805: LD_INT 2
97807: PUSH
97808: FOR_TO
97809: IFFALSE 97936
// begin uc_side := your_side ;
97811: LD_ADDR_OWVAR 20
97815: PUSH
97816: LD_OWVAR 2
97820: ST_TO_ADDR
// uc_nation := nation_american ;
97821: LD_ADDR_OWVAR 21
97825: PUSH
97826: LD_INT 1
97828: ST_TO_ADDR
// vc_chassis := us_morphling ;
97829: LD_ADDR_OWVAR 37
97833: PUSH
97834: LD_INT 5
97836: ST_TO_ADDR
// vc_engine := engine_siberite ;
97837: LD_ADDR_OWVAR 39
97841: PUSH
97842: LD_INT 3
97844: ST_TO_ADDR
// vc_control := control_computer ;
97845: LD_ADDR_OWVAR 38
97849: PUSH
97850: LD_INT 3
97852: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97853: LD_ADDR_OWVAR 40
97857: PUSH
97858: LD_INT 10
97860: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97861: LD_VAR 0 2
97865: PUSH
97866: LD_INT 1
97868: ARRAY
97869: PPUSH
97870: CALL_OW 310
97874: NOT
97875: IFFALSE 97922
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97877: CALL_OW 45
97881: PPUSH
97882: LD_VAR 0 2
97886: PUSH
97887: LD_INT 1
97889: ARRAY
97890: PPUSH
97891: CALL_OW 250
97895: PPUSH
97896: LD_VAR 0 2
97900: PUSH
97901: LD_INT 1
97903: ARRAY
97904: PPUSH
97905: CALL_OW 251
97909: PPUSH
97910: LD_INT 12
97912: PPUSH
97913: LD_INT 1
97915: PPUSH
97916: CALL_OW 50
97920: GO 97934
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97922: CALL_OW 45
97926: PPUSH
97927: LD_INT 1
97929: PPUSH
97930: CALL_OW 51
// end ;
97934: GO 97808
97936: POP
97937: POP
// end ;
97938: PPOPN 2
97940: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97941: LD_EXP 113
97945: PUSH
97946: LD_EXP 159
97950: AND
97951: IFFALSE 98173
97953: GO 97955
97955: DISABLE
97956: LD_INT 0
97958: PPUSH
97959: PPUSH
97960: PPUSH
97961: PPUSH
97962: PPUSH
97963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97964: LD_ADDR_VAR 0 6
97968: PUSH
97969: LD_INT 22
97971: PUSH
97972: LD_OWVAR 2
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 21
97983: PUSH
97984: LD_INT 1
97986: PUSH
97987: EMPTY
97988: LIST
97989: LIST
97990: PUSH
97991: LD_INT 3
97993: PUSH
97994: LD_INT 23
97996: PUSH
97997: LD_INT 0
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: LIST
98012: PPUSH
98013: CALL_OW 69
98017: ST_TO_ADDR
// if not tmp then
98018: LD_VAR 0 6
98022: NOT
98023: IFFALSE 98027
// exit ;
98025: GO 98173
// s1 := rand ( 1 , 4 ) ;
98027: LD_ADDR_VAR 0 2
98031: PUSH
98032: LD_INT 1
98034: PPUSH
98035: LD_INT 4
98037: PPUSH
98038: CALL_OW 12
98042: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98043: LD_ADDR_VAR 0 4
98047: PUSH
98048: LD_VAR 0 6
98052: PUSH
98053: LD_INT 1
98055: ARRAY
98056: PPUSH
98057: LD_VAR 0 2
98061: PPUSH
98062: CALL_OW 259
98066: ST_TO_ADDR
// if s1 = 1 then
98067: LD_VAR 0 2
98071: PUSH
98072: LD_INT 1
98074: EQUAL
98075: IFFALSE 98095
// s2 := rand ( 2 , 4 ) else
98077: LD_ADDR_VAR 0 3
98081: PUSH
98082: LD_INT 2
98084: PPUSH
98085: LD_INT 4
98087: PPUSH
98088: CALL_OW 12
98092: ST_TO_ADDR
98093: GO 98103
// s2 := 1 ;
98095: LD_ADDR_VAR 0 3
98099: PUSH
98100: LD_INT 1
98102: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98103: LD_ADDR_VAR 0 5
98107: PUSH
98108: LD_VAR 0 6
98112: PUSH
98113: LD_INT 1
98115: ARRAY
98116: PPUSH
98117: LD_VAR 0 3
98121: PPUSH
98122: CALL_OW 259
98126: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98127: LD_VAR 0 6
98131: PUSH
98132: LD_INT 1
98134: ARRAY
98135: PPUSH
98136: LD_VAR 0 2
98140: PPUSH
98141: LD_VAR 0 5
98145: PPUSH
98146: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98150: LD_VAR 0 6
98154: PUSH
98155: LD_INT 1
98157: ARRAY
98158: PPUSH
98159: LD_VAR 0 3
98163: PPUSH
98164: LD_VAR 0 4
98168: PPUSH
98169: CALL_OW 237
// end ;
98173: PPOPN 6
98175: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98176: LD_EXP 113
98180: PUSH
98181: LD_EXP 160
98185: AND
98186: IFFALSE 98265
98188: GO 98190
98190: DISABLE
98191: LD_INT 0
98193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98194: LD_ADDR_VAR 0 1
98198: PUSH
98199: LD_INT 22
98201: PUSH
98202: LD_OWVAR 2
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: PUSH
98211: LD_INT 30
98213: PUSH
98214: LD_INT 3
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PPUSH
98225: CALL_OW 69
98229: ST_TO_ADDR
// if not tmp then
98230: LD_VAR 0 1
98234: NOT
98235: IFFALSE 98239
// exit ;
98237: GO 98265
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98239: LD_VAR 0 1
98243: PUSH
98244: LD_INT 1
98246: PPUSH
98247: LD_VAR 0 1
98251: PPUSH
98252: CALL_OW 12
98256: ARRAY
98257: PPUSH
98258: LD_INT 1
98260: PPUSH
98261: CALL_OW 234
// end ;
98265: PPOPN 1
98267: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98268: LD_EXP 113
98272: PUSH
98273: LD_EXP 161
98277: AND
98278: IFFALSE 98390
98280: GO 98282
98282: DISABLE
98283: LD_INT 0
98285: PPUSH
98286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98287: LD_ADDR_VAR 0 2
98291: PUSH
98292: LD_INT 22
98294: PUSH
98295: LD_OWVAR 2
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PUSH
98304: LD_INT 2
98306: PUSH
98307: LD_INT 30
98309: PUSH
98310: LD_INT 27
98312: PUSH
98313: EMPTY
98314: LIST
98315: LIST
98316: PUSH
98317: LD_INT 30
98319: PUSH
98320: LD_INT 26
98322: PUSH
98323: EMPTY
98324: LIST
98325: LIST
98326: PUSH
98327: LD_INT 30
98329: PUSH
98330: LD_INT 28
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PUSH
98337: EMPTY
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PPUSH
98347: CALL_OW 69
98351: ST_TO_ADDR
// if not tmp then
98352: LD_VAR 0 2
98356: NOT
98357: IFFALSE 98361
// exit ;
98359: GO 98390
// for i in tmp do
98361: LD_ADDR_VAR 0 1
98365: PUSH
98366: LD_VAR 0 2
98370: PUSH
98371: FOR_IN
98372: IFFALSE 98388
// SetLives ( i , 1 ) ;
98374: LD_VAR 0 1
98378: PPUSH
98379: LD_INT 1
98381: PPUSH
98382: CALL_OW 234
98386: GO 98371
98388: POP
98389: POP
// end ;
98390: PPOPN 2
98392: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98393: LD_EXP 113
98397: PUSH
98398: LD_EXP 162
98402: AND
98403: IFFALSE 98677
98405: GO 98407
98407: DISABLE
98408: LD_INT 0
98410: PPUSH
98411: PPUSH
98412: PPUSH
// begin i := rand ( 1 , 7 ) ;
98413: LD_ADDR_VAR 0 1
98417: PUSH
98418: LD_INT 1
98420: PPUSH
98421: LD_INT 7
98423: PPUSH
98424: CALL_OW 12
98428: ST_TO_ADDR
// case i of 1 :
98429: LD_VAR 0 1
98433: PUSH
98434: LD_INT 1
98436: DOUBLE
98437: EQUAL
98438: IFTRUE 98442
98440: GO 98452
98442: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98443: LD_STRING earthquake(getX(game), 0, 32)
98445: PPUSH
98446: CALL_OW 559
98450: GO 98677
98452: LD_INT 2
98454: DOUBLE
98455: EQUAL
98456: IFTRUE 98460
98458: GO 98474
98460: POP
// begin ToLua ( displayStucuk(); ) ;
98461: LD_STRING displayStucuk();
98463: PPUSH
98464: CALL_OW 559
// ResetFog ;
98468: CALL_OW 335
// end ; 3 :
98472: GO 98677
98474: LD_INT 3
98476: DOUBLE
98477: EQUAL
98478: IFTRUE 98482
98480: GO 98586
98482: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98483: LD_ADDR_VAR 0 2
98487: PUSH
98488: LD_INT 22
98490: PUSH
98491: LD_OWVAR 2
98495: PUSH
98496: EMPTY
98497: LIST
98498: LIST
98499: PUSH
98500: LD_INT 25
98502: PUSH
98503: LD_INT 1
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: PUSH
98510: EMPTY
98511: LIST
98512: LIST
98513: PPUSH
98514: CALL_OW 69
98518: ST_TO_ADDR
// if not tmp then
98519: LD_VAR 0 2
98523: NOT
98524: IFFALSE 98528
// exit ;
98526: GO 98677
// un := tmp [ rand ( 1 , tmp ) ] ;
98528: LD_ADDR_VAR 0 3
98532: PUSH
98533: LD_VAR 0 2
98537: PUSH
98538: LD_INT 1
98540: PPUSH
98541: LD_VAR 0 2
98545: PPUSH
98546: CALL_OW 12
98550: ARRAY
98551: ST_TO_ADDR
// if Crawls ( un ) then
98552: LD_VAR 0 3
98556: PPUSH
98557: CALL_OW 318
98561: IFFALSE 98572
// ComWalk ( un ) ;
98563: LD_VAR 0 3
98567: PPUSH
98568: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98572: LD_VAR 0 3
98576: PPUSH
98577: LD_INT 8
98579: PPUSH
98580: CALL_OW 336
// end ; 4 :
98584: GO 98677
98586: LD_INT 4
98588: DOUBLE
98589: EQUAL
98590: IFTRUE 98594
98592: GO 98655
98594: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98595: LD_ADDR_VAR 0 2
98599: PUSH
98600: LD_INT 22
98602: PUSH
98603: LD_OWVAR 2
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: PUSH
98612: LD_INT 30
98614: PUSH
98615: LD_INT 29
98617: PUSH
98618: EMPTY
98619: LIST
98620: LIST
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PPUSH
98626: CALL_OW 69
98630: ST_TO_ADDR
// if not tmp then
98631: LD_VAR 0 2
98635: NOT
98636: IFFALSE 98640
// exit ;
98638: GO 98677
// DestroyUnit ( tmp [ 1 ] ) ;
98640: LD_VAR 0 2
98644: PUSH
98645: LD_INT 1
98647: ARRAY
98648: PPUSH
98649: CALL_OW 65
// end ; 5 .. 7 :
98653: GO 98677
98655: LD_INT 5
98657: DOUBLE
98658: GREATEREQUAL
98659: IFFALSE 98667
98661: LD_INT 7
98663: DOUBLE
98664: LESSEQUAL
98665: IFTRUE 98669
98667: GO 98676
98669: POP
// StreamSibBomb ; end ;
98670: CALL 94927 0 0
98674: GO 98677
98676: POP
// end ;
98677: PPOPN 3
98679: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98680: LD_EXP 113
98684: PUSH
98685: LD_EXP 163
98689: AND
98690: IFFALSE 98846
98692: GO 98694
98694: DISABLE
98695: LD_INT 0
98697: PPUSH
98698: PPUSH
98699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98700: LD_ADDR_VAR 0 2
98704: PUSH
98705: LD_INT 81
98707: PUSH
98708: LD_OWVAR 2
98712: PUSH
98713: EMPTY
98714: LIST
98715: LIST
98716: PUSH
98717: LD_INT 2
98719: PUSH
98720: LD_INT 21
98722: PUSH
98723: LD_INT 1
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 21
98732: PUSH
98733: LD_INT 2
98735: PUSH
98736: EMPTY
98737: LIST
98738: LIST
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: LIST
98744: PUSH
98745: EMPTY
98746: LIST
98747: LIST
98748: PPUSH
98749: CALL_OW 69
98753: ST_TO_ADDR
// if not tmp then
98754: LD_VAR 0 2
98758: NOT
98759: IFFALSE 98763
// exit ;
98761: GO 98846
// p := 0 ;
98763: LD_ADDR_VAR 0 3
98767: PUSH
98768: LD_INT 0
98770: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98771: LD_INT 35
98773: PPUSH
98774: CALL_OW 67
// p := p + 1 ;
98778: LD_ADDR_VAR 0 3
98782: PUSH
98783: LD_VAR 0 3
98787: PUSH
98788: LD_INT 1
98790: PLUS
98791: ST_TO_ADDR
// for i in tmp do
98792: LD_ADDR_VAR 0 1
98796: PUSH
98797: LD_VAR 0 2
98801: PUSH
98802: FOR_IN
98803: IFFALSE 98834
// if GetLives ( i ) < 1000 then
98805: LD_VAR 0 1
98809: PPUSH
98810: CALL_OW 256
98814: PUSH
98815: LD_INT 1000
98817: LESS
98818: IFFALSE 98832
// SetLives ( i , 1000 ) ;
98820: LD_VAR 0 1
98824: PPUSH
98825: LD_INT 1000
98827: PPUSH
98828: CALL_OW 234
98832: GO 98802
98834: POP
98835: POP
// until p > 20 ;
98836: LD_VAR 0 3
98840: PUSH
98841: LD_INT 20
98843: GREATER
98844: IFFALSE 98771
// end ;
98846: PPOPN 3
98848: END
// every 0 0$1 trigger StreamModeActive and sTime do
98849: LD_EXP 113
98853: PUSH
98854: LD_EXP 164
98858: AND
98859: IFFALSE 98894
98861: GO 98863
98863: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98864: LD_INT 28
98866: PPUSH
98867: LD_OWVAR 2
98871: PPUSH
98872: LD_INT 2
98874: PPUSH
98875: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98879: LD_INT 30
98881: PPUSH
98882: LD_OWVAR 2
98886: PPUSH
98887: LD_INT 2
98889: PPUSH
98890: CALL_OW 322
// end ;
98894: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98895: LD_EXP 113
98899: PUSH
98900: LD_EXP 165
98904: AND
98905: IFFALSE 99026
98907: GO 98909
98909: DISABLE
98910: LD_INT 0
98912: PPUSH
98913: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98914: LD_ADDR_VAR 0 2
98918: PUSH
98919: LD_INT 22
98921: PUSH
98922: LD_OWVAR 2
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: PUSH
98931: LD_INT 21
98933: PUSH
98934: LD_INT 1
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: PUSH
98941: LD_INT 3
98943: PUSH
98944: LD_INT 23
98946: PUSH
98947: LD_INT 0
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: LIST
98962: PPUSH
98963: CALL_OW 69
98967: ST_TO_ADDR
// if not tmp then
98968: LD_VAR 0 2
98972: NOT
98973: IFFALSE 98977
// exit ;
98975: GO 99026
// for i in tmp do
98977: LD_ADDR_VAR 0 1
98981: PUSH
98982: LD_VAR 0 2
98986: PUSH
98987: FOR_IN
98988: IFFALSE 99024
// begin if Crawls ( i ) then
98990: LD_VAR 0 1
98994: PPUSH
98995: CALL_OW 318
98999: IFFALSE 99010
// ComWalk ( i ) ;
99001: LD_VAR 0 1
99005: PPUSH
99006: CALL_OW 138
// SetClass ( i , 2 ) ;
99010: LD_VAR 0 1
99014: PPUSH
99015: LD_INT 2
99017: PPUSH
99018: CALL_OW 336
// end ;
99022: GO 98987
99024: POP
99025: POP
// end ;
99026: PPOPN 2
99028: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99029: LD_EXP 113
99033: PUSH
99034: LD_EXP 166
99038: AND
99039: IFFALSE 99320
99041: GO 99043
99043: DISABLE
99044: LD_INT 0
99046: PPUSH
99047: PPUSH
99048: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99049: LD_OWVAR 2
99053: PPUSH
99054: LD_INT 9
99056: PPUSH
99057: LD_INT 1
99059: PPUSH
99060: LD_INT 1
99062: PPUSH
99063: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99067: LD_INT 9
99069: PPUSH
99070: LD_OWVAR 2
99074: PPUSH
99075: CALL_OW 343
// uc_side := 9 ;
99079: LD_ADDR_OWVAR 20
99083: PUSH
99084: LD_INT 9
99086: ST_TO_ADDR
// uc_nation := 2 ;
99087: LD_ADDR_OWVAR 21
99091: PUSH
99092: LD_INT 2
99094: ST_TO_ADDR
// hc_name := Dark Warrior ;
99095: LD_ADDR_OWVAR 26
99099: PUSH
99100: LD_STRING Dark Warrior
99102: ST_TO_ADDR
// hc_gallery :=  ;
99103: LD_ADDR_OWVAR 33
99107: PUSH
99108: LD_STRING 
99110: ST_TO_ADDR
// hc_noskilllimit := true ;
99111: LD_ADDR_OWVAR 76
99115: PUSH
99116: LD_INT 1
99118: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99119: LD_ADDR_OWVAR 31
99123: PUSH
99124: LD_INT 30
99126: PUSH
99127: LD_INT 30
99129: PUSH
99130: LD_INT 30
99132: PUSH
99133: LD_INT 30
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: ST_TO_ADDR
// un := CreateHuman ;
99142: LD_ADDR_VAR 0 3
99146: PUSH
99147: CALL_OW 44
99151: ST_TO_ADDR
// hc_noskilllimit := false ;
99152: LD_ADDR_OWVAR 76
99156: PUSH
99157: LD_INT 0
99159: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99160: LD_VAR 0 3
99164: PPUSH
99165: LD_INT 1
99167: PPUSH
99168: CALL_OW 51
// p := 0 ;
99172: LD_ADDR_VAR 0 2
99176: PUSH
99177: LD_INT 0
99179: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99180: LD_INT 35
99182: PPUSH
99183: CALL_OW 67
// p := p + 1 ;
99187: LD_ADDR_VAR 0 2
99191: PUSH
99192: LD_VAR 0 2
99196: PUSH
99197: LD_INT 1
99199: PLUS
99200: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99201: LD_VAR 0 3
99205: PPUSH
99206: CALL_OW 256
99210: PUSH
99211: LD_INT 1000
99213: LESS
99214: IFFALSE 99228
// SetLives ( un , 1000 ) ;
99216: LD_VAR 0 3
99220: PPUSH
99221: LD_INT 1000
99223: PPUSH
99224: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99228: LD_VAR 0 3
99232: PPUSH
99233: LD_INT 81
99235: PUSH
99236: LD_OWVAR 2
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: PUSH
99245: LD_INT 91
99247: PUSH
99248: LD_VAR 0 3
99252: PUSH
99253: LD_INT 30
99255: PUSH
99256: EMPTY
99257: LIST
99258: LIST
99259: LIST
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PPUSH
99265: CALL_OW 69
99269: PPUSH
99270: LD_VAR 0 3
99274: PPUSH
99275: CALL_OW 74
99279: PPUSH
99280: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99284: LD_VAR 0 2
99288: PUSH
99289: LD_INT 60
99291: GREATER
99292: PUSH
99293: LD_VAR 0 3
99297: PPUSH
99298: CALL_OW 301
99302: OR
99303: IFFALSE 99180
// if un then
99305: LD_VAR 0 3
99309: IFFALSE 99320
// RemoveUnit ( un ) ;
99311: LD_VAR 0 3
99315: PPUSH
99316: CALL_OW 64
// end ;
99320: PPOPN 3
99322: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99323: LD_INT 0
99325: PPUSH
// case cmd of 301 :
99326: LD_VAR 0 1
99330: PUSH
99331: LD_INT 301
99333: DOUBLE
99334: EQUAL
99335: IFTRUE 99339
99337: GO 99371
99339: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99340: LD_VAR 0 6
99344: PPUSH
99345: LD_VAR 0 7
99349: PPUSH
99350: LD_VAR 0 8
99354: PPUSH
99355: LD_VAR 0 4
99359: PPUSH
99360: LD_VAR 0 5
99364: PPUSH
99365: CALL 100572 0 5
99369: GO 99492
99371: LD_INT 302
99373: DOUBLE
99374: EQUAL
99375: IFTRUE 99379
99377: GO 99416
99379: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99380: LD_VAR 0 6
99384: PPUSH
99385: LD_VAR 0 7
99389: PPUSH
99390: LD_VAR 0 8
99394: PPUSH
99395: LD_VAR 0 9
99399: PPUSH
99400: LD_VAR 0 4
99404: PPUSH
99405: LD_VAR 0 5
99409: PPUSH
99410: CALL 100663 0 6
99414: GO 99492
99416: LD_INT 303
99418: DOUBLE
99419: EQUAL
99420: IFTRUE 99424
99422: GO 99461
99424: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99425: LD_VAR 0 6
99429: PPUSH
99430: LD_VAR 0 7
99434: PPUSH
99435: LD_VAR 0 8
99439: PPUSH
99440: LD_VAR 0 9
99444: PPUSH
99445: LD_VAR 0 4
99449: PPUSH
99450: LD_VAR 0 5
99454: PPUSH
99455: CALL 99497 0 6
99459: GO 99492
99461: LD_INT 304
99463: DOUBLE
99464: EQUAL
99465: IFTRUE 99469
99467: GO 99491
99469: POP
// hHackTeleport ( unit , x , y ) ; end ;
99470: LD_VAR 0 2
99474: PPUSH
99475: LD_VAR 0 4
99479: PPUSH
99480: LD_VAR 0 5
99484: PPUSH
99485: CALL 101256 0 3
99489: GO 99492
99491: POP
// end ;
99492: LD_VAR 0 12
99496: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99497: LD_INT 0
99499: PPUSH
99500: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99501: LD_VAR 0 1
99505: PUSH
99506: LD_INT 1
99508: LESS
99509: PUSH
99510: LD_VAR 0 1
99514: PUSH
99515: LD_INT 3
99517: GREATER
99518: OR
99519: PUSH
99520: LD_VAR 0 5
99524: PPUSH
99525: LD_VAR 0 6
99529: PPUSH
99530: CALL_OW 428
99534: OR
99535: IFFALSE 99539
// exit ;
99537: GO 100259
// uc_side := your_side ;
99539: LD_ADDR_OWVAR 20
99543: PUSH
99544: LD_OWVAR 2
99548: ST_TO_ADDR
// uc_nation := nation ;
99549: LD_ADDR_OWVAR 21
99553: PUSH
99554: LD_VAR 0 1
99558: ST_TO_ADDR
// bc_level = 1 ;
99559: LD_ADDR_OWVAR 43
99563: PUSH
99564: LD_INT 1
99566: ST_TO_ADDR
// case btype of 1 :
99567: LD_VAR 0 2
99571: PUSH
99572: LD_INT 1
99574: DOUBLE
99575: EQUAL
99576: IFTRUE 99580
99578: GO 99591
99580: POP
// bc_type := b_depot ; 2 :
99581: LD_ADDR_OWVAR 42
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
99589: GO 100203
99591: LD_INT 2
99593: DOUBLE
99594: EQUAL
99595: IFTRUE 99599
99597: GO 99610
99599: POP
// bc_type := b_warehouse ; 3 :
99600: LD_ADDR_OWVAR 42
99604: PUSH
99605: LD_INT 1
99607: ST_TO_ADDR
99608: GO 100203
99610: LD_INT 3
99612: DOUBLE
99613: EQUAL
99614: IFTRUE 99618
99616: GO 99629
99618: POP
// bc_type := b_lab ; 4 .. 9 :
99619: LD_ADDR_OWVAR 42
99623: PUSH
99624: LD_INT 6
99626: ST_TO_ADDR
99627: GO 100203
99629: LD_INT 4
99631: DOUBLE
99632: GREATEREQUAL
99633: IFFALSE 99641
99635: LD_INT 9
99637: DOUBLE
99638: LESSEQUAL
99639: IFTRUE 99643
99641: GO 99695
99643: POP
// begin bc_type := b_lab_half ;
99644: LD_ADDR_OWVAR 42
99648: PUSH
99649: LD_INT 7
99651: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99652: LD_ADDR_OWVAR 44
99656: PUSH
99657: LD_INT 10
99659: PUSH
99660: LD_INT 11
99662: PUSH
99663: LD_INT 12
99665: PUSH
99666: LD_INT 15
99668: PUSH
99669: LD_INT 14
99671: PUSH
99672: LD_INT 13
99674: PUSH
99675: EMPTY
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: LIST
99681: LIST
99682: PUSH
99683: LD_VAR 0 2
99687: PUSH
99688: LD_INT 3
99690: MINUS
99691: ARRAY
99692: ST_TO_ADDR
// end ; 10 .. 13 :
99693: GO 100203
99695: LD_INT 10
99697: DOUBLE
99698: GREATEREQUAL
99699: IFFALSE 99707
99701: LD_INT 13
99703: DOUBLE
99704: LESSEQUAL
99705: IFTRUE 99709
99707: GO 99786
99709: POP
// begin bc_type := b_lab_full ;
99710: LD_ADDR_OWVAR 42
99714: PUSH
99715: LD_INT 8
99717: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99718: LD_ADDR_OWVAR 44
99722: PUSH
99723: LD_INT 10
99725: PUSH
99726: LD_INT 12
99728: PUSH
99729: LD_INT 14
99731: PUSH
99732: LD_INT 13
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: LIST
99739: LIST
99740: PUSH
99741: LD_VAR 0 2
99745: PUSH
99746: LD_INT 9
99748: MINUS
99749: ARRAY
99750: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99751: LD_ADDR_OWVAR 45
99755: PUSH
99756: LD_INT 11
99758: PUSH
99759: LD_INT 15
99761: PUSH
99762: LD_INT 12
99764: PUSH
99765: LD_INT 15
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: PUSH
99774: LD_VAR 0 2
99778: PUSH
99779: LD_INT 9
99781: MINUS
99782: ARRAY
99783: ST_TO_ADDR
// end ; 14 :
99784: GO 100203
99786: LD_INT 14
99788: DOUBLE
99789: EQUAL
99790: IFTRUE 99794
99792: GO 99805
99794: POP
// bc_type := b_workshop ; 15 :
99795: LD_ADDR_OWVAR 42
99799: PUSH
99800: LD_INT 2
99802: ST_TO_ADDR
99803: GO 100203
99805: LD_INT 15
99807: DOUBLE
99808: EQUAL
99809: IFTRUE 99813
99811: GO 99824
99813: POP
// bc_type := b_factory ; 16 :
99814: LD_ADDR_OWVAR 42
99818: PUSH
99819: LD_INT 3
99821: ST_TO_ADDR
99822: GO 100203
99824: LD_INT 16
99826: DOUBLE
99827: EQUAL
99828: IFTRUE 99832
99830: GO 99843
99832: POP
// bc_type := b_ext_gun ; 17 :
99833: LD_ADDR_OWVAR 42
99837: PUSH
99838: LD_INT 17
99840: ST_TO_ADDR
99841: GO 100203
99843: LD_INT 17
99845: DOUBLE
99846: EQUAL
99847: IFTRUE 99851
99849: GO 99879
99851: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99852: LD_ADDR_OWVAR 42
99856: PUSH
99857: LD_INT 19
99859: PUSH
99860: LD_INT 23
99862: PUSH
99863: LD_INT 19
99865: PUSH
99866: EMPTY
99867: LIST
99868: LIST
99869: LIST
99870: PUSH
99871: LD_VAR 0 1
99875: ARRAY
99876: ST_TO_ADDR
99877: GO 100203
99879: LD_INT 18
99881: DOUBLE
99882: EQUAL
99883: IFTRUE 99887
99885: GO 99898
99887: POP
// bc_type := b_ext_radar ; 19 :
99888: LD_ADDR_OWVAR 42
99892: PUSH
99893: LD_INT 20
99895: ST_TO_ADDR
99896: GO 100203
99898: LD_INT 19
99900: DOUBLE
99901: EQUAL
99902: IFTRUE 99906
99904: GO 99917
99906: POP
// bc_type := b_ext_radio ; 20 :
99907: LD_ADDR_OWVAR 42
99911: PUSH
99912: LD_INT 22
99914: ST_TO_ADDR
99915: GO 100203
99917: LD_INT 20
99919: DOUBLE
99920: EQUAL
99921: IFTRUE 99925
99923: GO 99936
99925: POP
// bc_type := b_ext_siberium ; 21 :
99926: LD_ADDR_OWVAR 42
99930: PUSH
99931: LD_INT 21
99933: ST_TO_ADDR
99934: GO 100203
99936: LD_INT 21
99938: DOUBLE
99939: EQUAL
99940: IFTRUE 99944
99942: GO 99955
99944: POP
// bc_type := b_ext_computer ; 22 :
99945: LD_ADDR_OWVAR 42
99949: PUSH
99950: LD_INT 24
99952: ST_TO_ADDR
99953: GO 100203
99955: LD_INT 22
99957: DOUBLE
99958: EQUAL
99959: IFTRUE 99963
99961: GO 99974
99963: POP
// bc_type := b_ext_track ; 23 :
99964: LD_ADDR_OWVAR 42
99968: PUSH
99969: LD_INT 16
99971: ST_TO_ADDR
99972: GO 100203
99974: LD_INT 23
99976: DOUBLE
99977: EQUAL
99978: IFTRUE 99982
99980: GO 99993
99982: POP
// bc_type := b_ext_laser ; 24 :
99983: LD_ADDR_OWVAR 42
99987: PUSH
99988: LD_INT 25
99990: ST_TO_ADDR
99991: GO 100203
99993: LD_INT 24
99995: DOUBLE
99996: EQUAL
99997: IFTRUE 100001
99999: GO 100012
100001: POP
// bc_type := b_control_tower ; 25 :
100002: LD_ADDR_OWVAR 42
100006: PUSH
100007: LD_INT 36
100009: ST_TO_ADDR
100010: GO 100203
100012: LD_INT 25
100014: DOUBLE
100015: EQUAL
100016: IFTRUE 100020
100018: GO 100031
100020: POP
// bc_type := b_breastwork ; 26 :
100021: LD_ADDR_OWVAR 42
100025: PUSH
100026: LD_INT 31
100028: ST_TO_ADDR
100029: GO 100203
100031: LD_INT 26
100033: DOUBLE
100034: EQUAL
100035: IFTRUE 100039
100037: GO 100050
100039: POP
// bc_type := b_bunker ; 27 :
100040: LD_ADDR_OWVAR 42
100044: PUSH
100045: LD_INT 32
100047: ST_TO_ADDR
100048: GO 100203
100050: LD_INT 27
100052: DOUBLE
100053: EQUAL
100054: IFTRUE 100058
100056: GO 100069
100058: POP
// bc_type := b_turret ; 28 :
100059: LD_ADDR_OWVAR 42
100063: PUSH
100064: LD_INT 33
100066: ST_TO_ADDR
100067: GO 100203
100069: LD_INT 28
100071: DOUBLE
100072: EQUAL
100073: IFTRUE 100077
100075: GO 100088
100077: POP
// bc_type := b_armoury ; 29 :
100078: LD_ADDR_OWVAR 42
100082: PUSH
100083: LD_INT 4
100085: ST_TO_ADDR
100086: GO 100203
100088: LD_INT 29
100090: DOUBLE
100091: EQUAL
100092: IFTRUE 100096
100094: GO 100107
100096: POP
// bc_type := b_barracks ; 30 :
100097: LD_ADDR_OWVAR 42
100101: PUSH
100102: LD_INT 5
100104: ST_TO_ADDR
100105: GO 100203
100107: LD_INT 30
100109: DOUBLE
100110: EQUAL
100111: IFTRUE 100115
100113: GO 100126
100115: POP
// bc_type := b_solar_power ; 31 :
100116: LD_ADDR_OWVAR 42
100120: PUSH
100121: LD_INT 27
100123: ST_TO_ADDR
100124: GO 100203
100126: LD_INT 31
100128: DOUBLE
100129: EQUAL
100130: IFTRUE 100134
100132: GO 100145
100134: POP
// bc_type := b_oil_power ; 32 :
100135: LD_ADDR_OWVAR 42
100139: PUSH
100140: LD_INT 26
100142: ST_TO_ADDR
100143: GO 100203
100145: LD_INT 32
100147: DOUBLE
100148: EQUAL
100149: IFTRUE 100153
100151: GO 100164
100153: POP
// bc_type := b_siberite_power ; 33 :
100154: LD_ADDR_OWVAR 42
100158: PUSH
100159: LD_INT 28
100161: ST_TO_ADDR
100162: GO 100203
100164: LD_INT 33
100166: DOUBLE
100167: EQUAL
100168: IFTRUE 100172
100170: GO 100183
100172: POP
// bc_type := b_oil_mine ; 34 :
100173: LD_ADDR_OWVAR 42
100177: PUSH
100178: LD_INT 29
100180: ST_TO_ADDR
100181: GO 100203
100183: LD_INT 34
100185: DOUBLE
100186: EQUAL
100187: IFTRUE 100191
100189: GO 100202
100191: POP
// bc_type := b_siberite_mine ; end ;
100192: LD_ADDR_OWVAR 42
100196: PUSH
100197: LD_INT 30
100199: ST_TO_ADDR
100200: GO 100203
100202: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100203: LD_ADDR_VAR 0 8
100207: PUSH
100208: LD_VAR 0 5
100212: PPUSH
100213: LD_VAR 0 6
100217: PPUSH
100218: LD_VAR 0 3
100222: PPUSH
100223: CALL_OW 47
100227: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100228: LD_OWVAR 42
100232: PUSH
100233: LD_INT 32
100235: PUSH
100236: LD_INT 33
100238: PUSH
100239: EMPTY
100240: LIST
100241: LIST
100242: IN
100243: IFFALSE 100259
// PlaceWeaponTurret ( b , weapon ) ;
100245: LD_VAR 0 8
100249: PPUSH
100250: LD_VAR 0 4
100254: PPUSH
100255: CALL_OW 431
// end ;
100259: LD_VAR 0 7
100263: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100264: LD_INT 0
100266: PPUSH
100267: PPUSH
100268: PPUSH
100269: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100270: LD_ADDR_VAR 0 4
100274: PUSH
100275: LD_INT 22
100277: PUSH
100278: LD_OWVAR 2
100282: PUSH
100283: EMPTY
100284: LIST
100285: LIST
100286: PUSH
100287: LD_INT 2
100289: PUSH
100290: LD_INT 30
100292: PUSH
100293: LD_INT 0
100295: PUSH
100296: EMPTY
100297: LIST
100298: LIST
100299: PUSH
100300: LD_INT 30
100302: PUSH
100303: LD_INT 1
100305: PUSH
100306: EMPTY
100307: LIST
100308: LIST
100309: PUSH
100310: EMPTY
100311: LIST
100312: LIST
100313: LIST
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: PPUSH
100319: CALL_OW 69
100323: ST_TO_ADDR
// if not tmp then
100324: LD_VAR 0 4
100328: NOT
100329: IFFALSE 100333
// exit ;
100331: GO 100392
// for i in tmp do
100333: LD_ADDR_VAR 0 2
100337: PUSH
100338: LD_VAR 0 4
100342: PUSH
100343: FOR_IN
100344: IFFALSE 100390
// for j = 1 to 3 do
100346: LD_ADDR_VAR 0 3
100350: PUSH
100351: DOUBLE
100352: LD_INT 1
100354: DEC
100355: ST_TO_ADDR
100356: LD_INT 3
100358: PUSH
100359: FOR_TO
100360: IFFALSE 100386
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100362: LD_VAR 0 2
100366: PPUSH
100367: CALL_OW 274
100371: PPUSH
100372: LD_VAR 0 3
100376: PPUSH
100377: LD_INT 99999
100379: PPUSH
100380: CALL_OW 277
100384: GO 100359
100386: POP
100387: POP
100388: GO 100343
100390: POP
100391: POP
// end ;
100392: LD_VAR 0 1
100396: RET
// export function hHackSetLevel10 ; var i , j ; begin
100397: LD_INT 0
100399: PPUSH
100400: PPUSH
100401: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100402: LD_ADDR_VAR 0 2
100406: PUSH
100407: LD_INT 21
100409: PUSH
100410: LD_INT 1
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PPUSH
100417: CALL_OW 69
100421: PUSH
100422: FOR_IN
100423: IFFALSE 100475
// if IsSelected ( i ) then
100425: LD_VAR 0 2
100429: PPUSH
100430: CALL_OW 306
100434: IFFALSE 100473
// begin for j := 1 to 4 do
100436: LD_ADDR_VAR 0 3
100440: PUSH
100441: DOUBLE
100442: LD_INT 1
100444: DEC
100445: ST_TO_ADDR
100446: LD_INT 4
100448: PUSH
100449: FOR_TO
100450: IFFALSE 100471
// SetSkill ( i , j , 10 ) ;
100452: LD_VAR 0 2
100456: PPUSH
100457: LD_VAR 0 3
100461: PPUSH
100462: LD_INT 10
100464: PPUSH
100465: CALL_OW 237
100469: GO 100449
100471: POP
100472: POP
// end ;
100473: GO 100422
100475: POP
100476: POP
// end ;
100477: LD_VAR 0 1
100481: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100482: LD_INT 0
100484: PPUSH
100485: PPUSH
100486: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100487: LD_ADDR_VAR 0 2
100491: PUSH
100492: LD_INT 22
100494: PUSH
100495: LD_OWVAR 2
100499: PUSH
100500: EMPTY
100501: LIST
100502: LIST
100503: PUSH
100504: LD_INT 21
100506: PUSH
100507: LD_INT 1
100509: PUSH
100510: EMPTY
100511: LIST
100512: LIST
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PPUSH
100518: CALL_OW 69
100522: PUSH
100523: FOR_IN
100524: IFFALSE 100565
// begin for j := 1 to 4 do
100526: LD_ADDR_VAR 0 3
100530: PUSH
100531: DOUBLE
100532: LD_INT 1
100534: DEC
100535: ST_TO_ADDR
100536: LD_INT 4
100538: PUSH
100539: FOR_TO
100540: IFFALSE 100561
// SetSkill ( i , j , 10 ) ;
100542: LD_VAR 0 2
100546: PPUSH
100547: LD_VAR 0 3
100551: PPUSH
100552: LD_INT 10
100554: PPUSH
100555: CALL_OW 237
100559: GO 100539
100561: POP
100562: POP
// end ;
100563: GO 100523
100565: POP
100566: POP
// end ;
100567: LD_VAR 0 1
100571: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100572: LD_INT 0
100574: PPUSH
// uc_side := your_side ;
100575: LD_ADDR_OWVAR 20
100579: PUSH
100580: LD_OWVAR 2
100584: ST_TO_ADDR
// uc_nation := nation ;
100585: LD_ADDR_OWVAR 21
100589: PUSH
100590: LD_VAR 0 1
100594: ST_TO_ADDR
// InitHc ;
100595: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100599: LD_INT 0
100601: PPUSH
100602: LD_VAR 0 2
100606: PPUSH
100607: LD_VAR 0 3
100611: PPUSH
100612: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100616: LD_VAR 0 4
100620: PPUSH
100621: LD_VAR 0 5
100625: PPUSH
100626: CALL_OW 428
100630: PUSH
100631: LD_INT 0
100633: EQUAL
100634: IFFALSE 100658
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100636: CALL_OW 44
100640: PPUSH
100641: LD_VAR 0 4
100645: PPUSH
100646: LD_VAR 0 5
100650: PPUSH
100651: LD_INT 1
100653: PPUSH
100654: CALL_OW 48
// end ;
100658: LD_VAR 0 6
100662: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100663: LD_INT 0
100665: PPUSH
100666: PPUSH
// uc_side := your_side ;
100667: LD_ADDR_OWVAR 20
100671: PUSH
100672: LD_OWVAR 2
100676: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100677: LD_VAR 0 1
100681: PUSH
100682: LD_INT 1
100684: PUSH
100685: LD_INT 2
100687: PUSH
100688: LD_INT 3
100690: PUSH
100691: LD_INT 4
100693: PUSH
100694: LD_INT 5
100696: PUSH
100697: EMPTY
100698: LIST
100699: LIST
100700: LIST
100701: LIST
100702: LIST
100703: IN
100704: IFFALSE 100716
// uc_nation := nation_american else
100706: LD_ADDR_OWVAR 21
100710: PUSH
100711: LD_INT 1
100713: ST_TO_ADDR
100714: GO 100759
// if chassis in [ 11 , 12 , 13 , 14 ] then
100716: LD_VAR 0 1
100720: PUSH
100721: LD_INT 11
100723: PUSH
100724: LD_INT 12
100726: PUSH
100727: LD_INT 13
100729: PUSH
100730: LD_INT 14
100732: PUSH
100733: EMPTY
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: IN
100739: IFFALSE 100751
// uc_nation := nation_arabian else
100741: LD_ADDR_OWVAR 21
100745: PUSH
100746: LD_INT 2
100748: ST_TO_ADDR
100749: GO 100759
// uc_nation := nation_russian ;
100751: LD_ADDR_OWVAR 21
100755: PUSH
100756: LD_INT 3
100758: ST_TO_ADDR
// vc_chassis := chassis ;
100759: LD_ADDR_OWVAR 37
100763: PUSH
100764: LD_VAR 0 1
100768: ST_TO_ADDR
// vc_engine := engine ;
100769: LD_ADDR_OWVAR 39
100773: PUSH
100774: LD_VAR 0 2
100778: ST_TO_ADDR
// vc_control := control ;
100779: LD_ADDR_OWVAR 38
100783: PUSH
100784: LD_VAR 0 3
100788: ST_TO_ADDR
// vc_weapon := weapon ;
100789: LD_ADDR_OWVAR 40
100793: PUSH
100794: LD_VAR 0 4
100798: ST_TO_ADDR
// un := CreateVehicle ;
100799: LD_ADDR_VAR 0 8
100803: PUSH
100804: CALL_OW 45
100808: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100809: LD_VAR 0 8
100813: PPUSH
100814: LD_INT 0
100816: PPUSH
100817: LD_INT 5
100819: PPUSH
100820: CALL_OW 12
100824: PPUSH
100825: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100829: LD_VAR 0 8
100833: PPUSH
100834: LD_VAR 0 5
100838: PPUSH
100839: LD_VAR 0 6
100843: PPUSH
100844: LD_INT 1
100846: PPUSH
100847: CALL_OW 48
// end ;
100851: LD_VAR 0 7
100855: RET
// export hInvincible ; every 1 do
100856: GO 100858
100858: DISABLE
// hInvincible := [ ] ;
100859: LD_ADDR_EXP 167
100863: PUSH
100864: EMPTY
100865: ST_TO_ADDR
100866: END
// every 10 do var i ;
100867: GO 100869
100869: DISABLE
100870: LD_INT 0
100872: PPUSH
// begin enable ;
100873: ENABLE
// if not hInvincible then
100874: LD_EXP 167
100878: NOT
100879: IFFALSE 100883
// exit ;
100881: GO 100927
// for i in hInvincible do
100883: LD_ADDR_VAR 0 1
100887: PUSH
100888: LD_EXP 167
100892: PUSH
100893: FOR_IN
100894: IFFALSE 100925
// if GetLives ( i ) < 1000 then
100896: LD_VAR 0 1
100900: PPUSH
100901: CALL_OW 256
100905: PUSH
100906: LD_INT 1000
100908: LESS
100909: IFFALSE 100923
// SetLives ( i , 1000 ) ;
100911: LD_VAR 0 1
100915: PPUSH
100916: LD_INT 1000
100918: PPUSH
100919: CALL_OW 234
100923: GO 100893
100925: POP
100926: POP
// end ;
100927: PPOPN 1
100929: END
// export function hHackInvincible ; var i ; begin
100930: LD_INT 0
100932: PPUSH
100933: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100934: LD_ADDR_VAR 0 2
100938: PUSH
100939: LD_INT 2
100941: PUSH
100942: LD_INT 21
100944: PUSH
100945: LD_INT 1
100947: PUSH
100948: EMPTY
100949: LIST
100950: LIST
100951: PUSH
100952: LD_INT 21
100954: PUSH
100955: LD_INT 2
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: LIST
100966: PPUSH
100967: CALL_OW 69
100971: PUSH
100972: FOR_IN
100973: IFFALSE 101034
// if IsSelected ( i ) then
100975: LD_VAR 0 2
100979: PPUSH
100980: CALL_OW 306
100984: IFFALSE 101032
// begin if i in hInvincible then
100986: LD_VAR 0 2
100990: PUSH
100991: LD_EXP 167
100995: IN
100996: IFFALSE 101016
// hInvincible := hInvincible diff i else
100998: LD_ADDR_EXP 167
101002: PUSH
101003: LD_EXP 167
101007: PUSH
101008: LD_VAR 0 2
101012: DIFF
101013: ST_TO_ADDR
101014: GO 101032
// hInvincible := hInvincible union i ;
101016: LD_ADDR_EXP 167
101020: PUSH
101021: LD_EXP 167
101025: PUSH
101026: LD_VAR 0 2
101030: UNION
101031: ST_TO_ADDR
// end ;
101032: GO 100972
101034: POP
101035: POP
// end ;
101036: LD_VAR 0 1
101040: RET
// export function hHackInvisible ; var i , j ; begin
101041: LD_INT 0
101043: PPUSH
101044: PPUSH
101045: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101046: LD_ADDR_VAR 0 2
101050: PUSH
101051: LD_INT 21
101053: PUSH
101054: LD_INT 1
101056: PUSH
101057: EMPTY
101058: LIST
101059: LIST
101060: PPUSH
101061: CALL_OW 69
101065: PUSH
101066: FOR_IN
101067: IFFALSE 101091
// if IsSelected ( i ) then
101069: LD_VAR 0 2
101073: PPUSH
101074: CALL_OW 306
101078: IFFALSE 101089
// ComForceInvisible ( i ) ;
101080: LD_VAR 0 2
101084: PPUSH
101085: CALL_OW 496
101089: GO 101066
101091: POP
101092: POP
// end ;
101093: LD_VAR 0 1
101097: RET
// export function hHackChangeYourSide ; begin
101098: LD_INT 0
101100: PPUSH
// if your_side = 8 then
101101: LD_OWVAR 2
101105: PUSH
101106: LD_INT 8
101108: EQUAL
101109: IFFALSE 101121
// your_side := 0 else
101111: LD_ADDR_OWVAR 2
101115: PUSH
101116: LD_INT 0
101118: ST_TO_ADDR
101119: GO 101135
// your_side := your_side + 1 ;
101121: LD_ADDR_OWVAR 2
101125: PUSH
101126: LD_OWVAR 2
101130: PUSH
101131: LD_INT 1
101133: PLUS
101134: ST_TO_ADDR
// end ;
101135: LD_VAR 0 1
101139: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101140: LD_INT 0
101142: PPUSH
101143: PPUSH
101144: PPUSH
// for i in all_units do
101145: LD_ADDR_VAR 0 2
101149: PUSH
101150: LD_OWVAR 3
101154: PUSH
101155: FOR_IN
101156: IFFALSE 101234
// if IsSelected ( i ) then
101158: LD_VAR 0 2
101162: PPUSH
101163: CALL_OW 306
101167: IFFALSE 101232
// begin j := GetSide ( i ) ;
101169: LD_ADDR_VAR 0 3
101173: PUSH
101174: LD_VAR 0 2
101178: PPUSH
101179: CALL_OW 255
101183: ST_TO_ADDR
// if j = 8 then
101184: LD_VAR 0 3
101188: PUSH
101189: LD_INT 8
101191: EQUAL
101192: IFFALSE 101204
// j := 0 else
101194: LD_ADDR_VAR 0 3
101198: PUSH
101199: LD_INT 0
101201: ST_TO_ADDR
101202: GO 101218
// j := j + 1 ;
101204: LD_ADDR_VAR 0 3
101208: PUSH
101209: LD_VAR 0 3
101213: PUSH
101214: LD_INT 1
101216: PLUS
101217: ST_TO_ADDR
// SetSide ( i , j ) ;
101218: LD_VAR 0 2
101222: PPUSH
101223: LD_VAR 0 3
101227: PPUSH
101228: CALL_OW 235
// end ;
101232: GO 101155
101234: POP
101235: POP
// end ;
101236: LD_VAR 0 1
101240: RET
// export function hHackFog ; begin
101241: LD_INT 0
101243: PPUSH
// FogOff ( true ) ;
101244: LD_INT 1
101246: PPUSH
101247: CALL_OW 344
// end ;
101251: LD_VAR 0 1
101255: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101256: LD_INT 0
101258: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101259: LD_VAR 0 1
101263: PPUSH
101264: LD_VAR 0 2
101268: PPUSH
101269: LD_VAR 0 3
101273: PPUSH
101274: LD_INT 1
101276: PPUSH
101277: LD_INT 1
101279: PPUSH
101280: CALL_OW 483
// CenterOnXY ( x , y ) ;
101284: LD_VAR 0 2
101288: PPUSH
101289: LD_VAR 0 3
101293: PPUSH
101294: CALL_OW 84
// end ; end_of_file
101298: LD_VAR 0 4
101302: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101303: LD_INT 0
101305: PPUSH
101306: PPUSH
101307: PPUSH
101308: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101309: LD_VAR 0 1
101313: PPUSH
101314: CALL_OW 264
101318: PUSH
101319: LD_EXP 98
101323: EQUAL
101324: IFFALSE 101396
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101326: LD_INT 68
101328: PPUSH
101329: LD_VAR 0 1
101333: PPUSH
101334: CALL_OW 255
101338: PPUSH
101339: CALL_OW 321
101343: PUSH
101344: LD_INT 2
101346: EQUAL
101347: IFFALSE 101359
// eff := 70 else
101349: LD_ADDR_VAR 0 4
101353: PUSH
101354: LD_INT 70
101356: ST_TO_ADDR
101357: GO 101367
// eff := 30 ;
101359: LD_ADDR_VAR 0 4
101363: PUSH
101364: LD_INT 30
101366: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101367: LD_VAR 0 1
101371: PPUSH
101372: CALL_OW 250
101376: PPUSH
101377: LD_VAR 0 1
101381: PPUSH
101382: CALL_OW 251
101386: PPUSH
101387: LD_VAR 0 4
101391: PPUSH
101392: CALL_OW 495
// end ; end ;
101396: LD_VAR 0 2
101400: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101401: LD_INT 0
101403: PPUSH
// end ;
101404: LD_VAR 0 4
101408: RET
// export function SOS_Command ( cmd ) ; begin
101409: LD_INT 0
101411: PPUSH
// end ;
101412: LD_VAR 0 2
101416: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101417: LD_INT 0
101419: PPUSH
// if cmd = 121 then
101420: LD_VAR 0 1
101424: PUSH
101425: LD_INT 121
101427: EQUAL
101428: IFFALSE 101430
// end ;
101430: LD_VAR 0 6
101434: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101435: LD_INT 0
101437: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101438: LD_VAR 0 1
101442: PUSH
101443: LD_INT 250
101445: EQUAL
101446: PUSH
101447: LD_VAR 0 2
101451: PPUSH
101452: CALL_OW 264
101456: PUSH
101457: LD_EXP 101
101461: EQUAL
101462: AND
101463: IFFALSE 101484
// MinerPlaceMine ( unit , x , y ) ;
101465: LD_VAR 0 2
101469: PPUSH
101470: LD_VAR 0 4
101474: PPUSH
101475: LD_VAR 0 5
101479: PPUSH
101480: CALL 103833 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101484: LD_VAR 0 1
101488: PUSH
101489: LD_INT 251
101491: EQUAL
101492: PUSH
101493: LD_VAR 0 2
101497: PPUSH
101498: CALL_OW 264
101502: PUSH
101503: LD_EXP 101
101507: EQUAL
101508: AND
101509: IFFALSE 101530
// MinerDetonateMine ( unit , x , y ) ;
101511: LD_VAR 0 2
101515: PPUSH
101516: LD_VAR 0 4
101520: PPUSH
101521: LD_VAR 0 5
101525: PPUSH
101526: CALL 104110 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101530: LD_VAR 0 1
101534: PUSH
101535: LD_INT 252
101537: EQUAL
101538: PUSH
101539: LD_VAR 0 2
101543: PPUSH
101544: CALL_OW 264
101548: PUSH
101549: LD_EXP 101
101553: EQUAL
101554: AND
101555: IFFALSE 101576
// MinerCreateMinefield ( unit , x , y ) ;
101557: LD_VAR 0 2
101561: PPUSH
101562: LD_VAR 0 4
101566: PPUSH
101567: LD_VAR 0 5
101571: PPUSH
101572: CALL 104527 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101576: LD_VAR 0 1
101580: PUSH
101581: LD_INT 253
101583: EQUAL
101584: PUSH
101585: LD_VAR 0 2
101589: PPUSH
101590: CALL_OW 257
101594: PUSH
101595: LD_INT 5
101597: EQUAL
101598: AND
101599: IFFALSE 101620
// ComBinocular ( unit , x , y ) ;
101601: LD_VAR 0 2
101605: PPUSH
101606: LD_VAR 0 4
101610: PPUSH
101611: LD_VAR 0 5
101615: PPUSH
101616: CALL 104898 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101620: LD_VAR 0 1
101624: PUSH
101625: LD_INT 254
101627: EQUAL
101628: PUSH
101629: LD_VAR 0 2
101633: PPUSH
101634: CALL_OW 264
101638: PUSH
101639: LD_EXP 96
101643: EQUAL
101644: AND
101645: PUSH
101646: LD_VAR 0 3
101650: PPUSH
101651: CALL_OW 263
101655: PUSH
101656: LD_INT 3
101658: EQUAL
101659: AND
101660: IFFALSE 101676
// HackDestroyVehicle ( unit , selectedUnit ) ;
101662: LD_VAR 0 2
101666: PPUSH
101667: LD_VAR 0 3
101671: PPUSH
101672: CALL 103193 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101676: LD_VAR 0 1
101680: PUSH
101681: LD_INT 255
101683: EQUAL
101684: PUSH
101685: LD_VAR 0 2
101689: PPUSH
101690: CALL_OW 264
101694: PUSH
101695: LD_INT 14
101697: PUSH
101698: LD_INT 53
101700: PUSH
101701: EMPTY
101702: LIST
101703: LIST
101704: IN
101705: AND
101706: PUSH
101707: LD_VAR 0 4
101711: PPUSH
101712: LD_VAR 0 5
101716: PPUSH
101717: CALL_OW 488
101721: AND
101722: IFFALSE 101746
// CutTreeXYR ( unit , x , y , 12 ) ;
101724: LD_VAR 0 2
101728: PPUSH
101729: LD_VAR 0 4
101733: PPUSH
101734: LD_VAR 0 5
101738: PPUSH
101739: LD_INT 12
101741: PPUSH
101742: CALL 101759 0 4
// end ;
101746: LD_VAR 0 6
101750: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
101751: LD_INT 0
101753: PPUSH
// end ;
101754: LD_VAR 0 4
101758: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101759: LD_INT 0
101761: PPUSH
101762: PPUSH
101763: PPUSH
101764: PPUSH
101765: PPUSH
101766: PPUSH
101767: PPUSH
101768: PPUSH
101769: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101770: LD_VAR 0 1
101774: NOT
101775: PUSH
101776: LD_VAR 0 2
101780: PPUSH
101781: LD_VAR 0 3
101785: PPUSH
101786: CALL_OW 488
101790: NOT
101791: OR
101792: PUSH
101793: LD_VAR 0 4
101797: NOT
101798: OR
101799: IFFALSE 101803
// exit ;
101801: GO 102143
// list := [ ] ;
101803: LD_ADDR_VAR 0 13
101807: PUSH
101808: EMPTY
101809: ST_TO_ADDR
// if x - r < 0 then
101810: LD_VAR 0 2
101814: PUSH
101815: LD_VAR 0 4
101819: MINUS
101820: PUSH
101821: LD_INT 0
101823: LESS
101824: IFFALSE 101836
// min_x := 0 else
101826: LD_ADDR_VAR 0 7
101830: PUSH
101831: LD_INT 0
101833: ST_TO_ADDR
101834: GO 101852
// min_x := x - r ;
101836: LD_ADDR_VAR 0 7
101840: PUSH
101841: LD_VAR 0 2
101845: PUSH
101846: LD_VAR 0 4
101850: MINUS
101851: ST_TO_ADDR
// if y - r < 0 then
101852: LD_VAR 0 3
101856: PUSH
101857: LD_VAR 0 4
101861: MINUS
101862: PUSH
101863: LD_INT 0
101865: LESS
101866: IFFALSE 101878
// min_y := 0 else
101868: LD_ADDR_VAR 0 8
101872: PUSH
101873: LD_INT 0
101875: ST_TO_ADDR
101876: GO 101894
// min_y := y - r ;
101878: LD_ADDR_VAR 0 8
101882: PUSH
101883: LD_VAR 0 3
101887: PUSH
101888: LD_VAR 0 4
101892: MINUS
101893: ST_TO_ADDR
// max_x := x + r ;
101894: LD_ADDR_VAR 0 9
101898: PUSH
101899: LD_VAR 0 2
101903: PUSH
101904: LD_VAR 0 4
101908: PLUS
101909: ST_TO_ADDR
// max_y := y + r ;
101910: LD_ADDR_VAR 0 10
101914: PUSH
101915: LD_VAR 0 3
101919: PUSH
101920: LD_VAR 0 4
101924: PLUS
101925: ST_TO_ADDR
// for _x = min_x to max_x do
101926: LD_ADDR_VAR 0 11
101930: PUSH
101931: DOUBLE
101932: LD_VAR 0 7
101936: DEC
101937: ST_TO_ADDR
101938: LD_VAR 0 9
101942: PUSH
101943: FOR_TO
101944: IFFALSE 102061
// for _y = min_y to max_y do
101946: LD_ADDR_VAR 0 12
101950: PUSH
101951: DOUBLE
101952: LD_VAR 0 8
101956: DEC
101957: ST_TO_ADDR
101958: LD_VAR 0 10
101962: PUSH
101963: FOR_TO
101964: IFFALSE 102057
// begin if not ValidHex ( _x , _y ) then
101966: LD_VAR 0 11
101970: PPUSH
101971: LD_VAR 0 12
101975: PPUSH
101976: CALL_OW 488
101980: NOT
101981: IFFALSE 101985
// continue ;
101983: GO 101963
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101985: LD_VAR 0 11
101989: PPUSH
101990: LD_VAR 0 12
101994: PPUSH
101995: CALL_OW 351
101999: PUSH
102000: LD_VAR 0 11
102004: PPUSH
102005: LD_VAR 0 12
102009: PPUSH
102010: CALL_OW 554
102014: AND
102015: IFFALSE 102055
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102017: LD_ADDR_VAR 0 13
102021: PUSH
102022: LD_VAR 0 13
102026: PPUSH
102027: LD_VAR 0 13
102031: PUSH
102032: LD_INT 1
102034: PLUS
102035: PPUSH
102036: LD_VAR 0 11
102040: PUSH
102041: LD_VAR 0 12
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PPUSH
102050: CALL_OW 2
102054: ST_TO_ADDR
// end ;
102055: GO 101963
102057: POP
102058: POP
102059: GO 101943
102061: POP
102062: POP
// if not list then
102063: LD_VAR 0 13
102067: NOT
102068: IFFALSE 102072
// exit ;
102070: GO 102143
// for i in list do
102072: LD_ADDR_VAR 0 6
102076: PUSH
102077: LD_VAR 0 13
102081: PUSH
102082: FOR_IN
102083: IFFALSE 102141
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102085: LD_VAR 0 1
102089: PPUSH
102090: LD_STRING M
102092: PUSH
102093: LD_VAR 0 6
102097: PUSH
102098: LD_INT 1
102100: ARRAY
102101: PUSH
102102: LD_VAR 0 6
102106: PUSH
102107: LD_INT 2
102109: ARRAY
102110: PUSH
102111: LD_INT 0
102113: PUSH
102114: LD_INT 0
102116: PUSH
102117: LD_INT 0
102119: PUSH
102120: LD_INT 0
102122: PUSH
102123: EMPTY
102124: LIST
102125: LIST
102126: LIST
102127: LIST
102128: LIST
102129: LIST
102130: LIST
102131: PUSH
102132: EMPTY
102133: LIST
102134: PPUSH
102135: CALL_OW 447
102139: GO 102082
102141: POP
102142: POP
// end ;
102143: LD_VAR 0 5
102147: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102148: LD_EXP 170
102152: NOT
102153: IFFALSE 102203
102155: GO 102157
102157: DISABLE
// begin initHack := true ;
102158: LD_ADDR_EXP 170
102162: PUSH
102163: LD_INT 1
102165: ST_TO_ADDR
// hackTanks := [ ] ;
102166: LD_ADDR_EXP 171
102170: PUSH
102171: EMPTY
102172: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102173: LD_ADDR_EXP 172
102177: PUSH
102178: EMPTY
102179: ST_TO_ADDR
// hackLimit := 3 ;
102180: LD_ADDR_EXP 173
102184: PUSH
102185: LD_INT 3
102187: ST_TO_ADDR
// hackDist := 12 ;
102188: LD_ADDR_EXP 174
102192: PUSH
102193: LD_INT 12
102195: ST_TO_ADDR
// hackCounter := [ ] ;
102196: LD_ADDR_EXP 175
102200: PUSH
102201: EMPTY
102202: ST_TO_ADDR
// end ;
102203: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102204: LD_EXP 170
102208: PUSH
102209: LD_INT 34
102211: PUSH
102212: LD_EXP 96
102216: PUSH
102217: EMPTY
102218: LIST
102219: LIST
102220: PPUSH
102221: CALL_OW 69
102225: AND
102226: IFFALSE 102481
102228: GO 102230
102230: DISABLE
102231: LD_INT 0
102233: PPUSH
102234: PPUSH
// begin enable ;
102235: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102236: LD_ADDR_VAR 0 1
102240: PUSH
102241: LD_INT 34
102243: PUSH
102244: LD_EXP 96
102248: PUSH
102249: EMPTY
102250: LIST
102251: LIST
102252: PPUSH
102253: CALL_OW 69
102257: PUSH
102258: FOR_IN
102259: IFFALSE 102479
// begin if not i in hackTanks then
102261: LD_VAR 0 1
102265: PUSH
102266: LD_EXP 171
102270: IN
102271: NOT
102272: IFFALSE 102355
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102274: LD_ADDR_EXP 171
102278: PUSH
102279: LD_EXP 171
102283: PPUSH
102284: LD_EXP 171
102288: PUSH
102289: LD_INT 1
102291: PLUS
102292: PPUSH
102293: LD_VAR 0 1
102297: PPUSH
102298: CALL_OW 1
102302: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102303: LD_ADDR_EXP 172
102307: PUSH
102308: LD_EXP 172
102312: PPUSH
102313: LD_EXP 172
102317: PUSH
102318: LD_INT 1
102320: PLUS
102321: PPUSH
102322: EMPTY
102323: PPUSH
102324: CALL_OW 1
102328: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102329: LD_ADDR_EXP 175
102333: PUSH
102334: LD_EXP 175
102338: PPUSH
102339: LD_EXP 175
102343: PUSH
102344: LD_INT 1
102346: PLUS
102347: PPUSH
102348: EMPTY
102349: PPUSH
102350: CALL_OW 1
102354: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102355: LD_VAR 0 1
102359: PPUSH
102360: CALL_OW 302
102364: NOT
102365: IFFALSE 102378
// begin HackUnlinkAll ( i ) ;
102367: LD_VAR 0 1
102371: PPUSH
102372: CALL 102484 0 1
// continue ;
102376: GO 102258
// end ; HackCheckCapturedStatus ( i ) ;
102378: LD_VAR 0 1
102382: PPUSH
102383: CALL 102927 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102387: LD_ADDR_VAR 0 2
102391: PUSH
102392: LD_INT 81
102394: PUSH
102395: LD_VAR 0 1
102399: PPUSH
102400: CALL_OW 255
102404: PUSH
102405: EMPTY
102406: LIST
102407: LIST
102408: PUSH
102409: LD_INT 33
102411: PUSH
102412: LD_INT 3
102414: PUSH
102415: EMPTY
102416: LIST
102417: LIST
102418: PUSH
102419: LD_INT 91
102421: PUSH
102422: LD_VAR 0 1
102426: PUSH
102427: LD_EXP 174
102431: PUSH
102432: EMPTY
102433: LIST
102434: LIST
102435: LIST
102436: PUSH
102437: LD_INT 50
102439: PUSH
102440: EMPTY
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: PPUSH
102449: CALL_OW 69
102453: ST_TO_ADDR
// if not tmp then
102454: LD_VAR 0 2
102458: NOT
102459: IFFALSE 102463
// continue ;
102461: GO 102258
// HackLink ( i , tmp ) ;
102463: LD_VAR 0 1
102467: PPUSH
102468: LD_VAR 0 2
102472: PPUSH
102473: CALL 102620 0 2
// end ;
102477: GO 102258
102479: POP
102480: POP
// end ;
102481: PPOPN 2
102483: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102484: LD_INT 0
102486: PPUSH
102487: PPUSH
102488: PPUSH
// if not hack in hackTanks then
102489: LD_VAR 0 1
102493: PUSH
102494: LD_EXP 171
102498: IN
102499: NOT
102500: IFFALSE 102504
// exit ;
102502: GO 102615
// index := GetElementIndex ( hackTanks , hack ) ;
102504: LD_ADDR_VAR 0 4
102508: PUSH
102509: LD_EXP 171
102513: PPUSH
102514: LD_VAR 0 1
102518: PPUSH
102519: CALL 53179 0 2
102523: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102524: LD_EXP 172
102528: PUSH
102529: LD_VAR 0 4
102533: ARRAY
102534: IFFALSE 102615
// begin for i in hackTanksCaptured [ index ] do
102536: LD_ADDR_VAR 0 3
102540: PUSH
102541: LD_EXP 172
102545: PUSH
102546: LD_VAR 0 4
102550: ARRAY
102551: PUSH
102552: FOR_IN
102553: IFFALSE 102579
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102555: LD_VAR 0 3
102559: PUSH
102560: LD_INT 1
102562: ARRAY
102563: PPUSH
102564: LD_VAR 0 3
102568: PUSH
102569: LD_INT 2
102571: ARRAY
102572: PPUSH
102573: CALL_OW 235
102577: GO 102552
102579: POP
102580: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102581: LD_ADDR_EXP 172
102585: PUSH
102586: LD_EXP 172
102590: PPUSH
102591: LD_VAR 0 4
102595: PPUSH
102596: EMPTY
102597: PPUSH
102598: CALL_OW 1
102602: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102603: LD_VAR 0 1
102607: PPUSH
102608: LD_INT 0
102610: PPUSH
102611: CALL_OW 505
// end ; end ;
102615: LD_VAR 0 2
102619: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102620: LD_INT 0
102622: PPUSH
102623: PPUSH
102624: PPUSH
// if not hack in hackTanks or not vehicles then
102625: LD_VAR 0 1
102629: PUSH
102630: LD_EXP 171
102634: IN
102635: NOT
102636: PUSH
102637: LD_VAR 0 2
102641: NOT
102642: OR
102643: IFFALSE 102647
// exit ;
102645: GO 102922
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102647: LD_ADDR_VAR 0 2
102651: PUSH
102652: LD_VAR 0 1
102656: PPUSH
102657: LD_VAR 0 2
102661: PPUSH
102662: LD_INT 1
102664: PPUSH
102665: LD_INT 1
102667: PPUSH
102668: CALL 53829 0 4
102672: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102673: LD_ADDR_VAR 0 5
102677: PUSH
102678: LD_EXP 171
102682: PPUSH
102683: LD_VAR 0 1
102687: PPUSH
102688: CALL 53179 0 2
102692: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102693: LD_EXP 172
102697: PUSH
102698: LD_VAR 0 5
102702: ARRAY
102703: PUSH
102704: LD_EXP 173
102708: LESS
102709: IFFALSE 102898
// begin for i := 1 to vehicles do
102711: LD_ADDR_VAR 0 4
102715: PUSH
102716: DOUBLE
102717: LD_INT 1
102719: DEC
102720: ST_TO_ADDR
102721: LD_VAR 0 2
102725: PUSH
102726: FOR_TO
102727: IFFALSE 102896
// begin if hackTanksCaptured [ index ] = hackLimit then
102729: LD_EXP 172
102733: PUSH
102734: LD_VAR 0 5
102738: ARRAY
102739: PUSH
102740: LD_EXP 173
102744: EQUAL
102745: IFFALSE 102749
// break ;
102747: GO 102896
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102749: LD_ADDR_EXP 175
102753: PUSH
102754: LD_EXP 175
102758: PPUSH
102759: LD_VAR 0 5
102763: PPUSH
102764: LD_EXP 175
102768: PUSH
102769: LD_VAR 0 5
102773: ARRAY
102774: PUSH
102775: LD_INT 1
102777: PLUS
102778: PPUSH
102779: CALL_OW 1
102783: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102784: LD_ADDR_EXP 172
102788: PUSH
102789: LD_EXP 172
102793: PPUSH
102794: LD_VAR 0 5
102798: PUSH
102799: LD_EXP 172
102803: PUSH
102804: LD_VAR 0 5
102808: ARRAY
102809: PUSH
102810: LD_INT 1
102812: PLUS
102813: PUSH
102814: EMPTY
102815: LIST
102816: LIST
102817: PPUSH
102818: LD_VAR 0 2
102822: PUSH
102823: LD_VAR 0 4
102827: ARRAY
102828: PUSH
102829: LD_VAR 0 2
102833: PUSH
102834: LD_VAR 0 4
102838: ARRAY
102839: PPUSH
102840: CALL_OW 255
102844: PUSH
102845: EMPTY
102846: LIST
102847: LIST
102848: PPUSH
102849: CALL 53394 0 3
102853: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102854: LD_VAR 0 2
102858: PUSH
102859: LD_VAR 0 4
102863: ARRAY
102864: PPUSH
102865: LD_VAR 0 1
102869: PPUSH
102870: CALL_OW 255
102874: PPUSH
102875: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102879: LD_VAR 0 2
102883: PUSH
102884: LD_VAR 0 4
102888: ARRAY
102889: PPUSH
102890: CALL_OW 141
// end ;
102894: GO 102726
102896: POP
102897: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102898: LD_VAR 0 1
102902: PPUSH
102903: LD_EXP 172
102907: PUSH
102908: LD_VAR 0 5
102912: ARRAY
102913: PUSH
102914: LD_INT 0
102916: PLUS
102917: PPUSH
102918: CALL_OW 505
// end ;
102922: LD_VAR 0 3
102926: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102927: LD_INT 0
102929: PPUSH
102930: PPUSH
102931: PPUSH
102932: PPUSH
// if not hack in hackTanks then
102933: LD_VAR 0 1
102937: PUSH
102938: LD_EXP 171
102942: IN
102943: NOT
102944: IFFALSE 102948
// exit ;
102946: GO 103188
// index := GetElementIndex ( hackTanks , hack ) ;
102948: LD_ADDR_VAR 0 4
102952: PUSH
102953: LD_EXP 171
102957: PPUSH
102958: LD_VAR 0 1
102962: PPUSH
102963: CALL 53179 0 2
102967: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102968: LD_ADDR_VAR 0 3
102972: PUSH
102973: DOUBLE
102974: LD_EXP 172
102978: PUSH
102979: LD_VAR 0 4
102983: ARRAY
102984: INC
102985: ST_TO_ADDR
102986: LD_INT 1
102988: PUSH
102989: FOR_DOWNTO
102990: IFFALSE 103162
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102992: LD_ADDR_VAR 0 5
102996: PUSH
102997: LD_EXP 172
103001: PUSH
103002: LD_VAR 0 4
103006: ARRAY
103007: PUSH
103008: LD_VAR 0 3
103012: ARRAY
103013: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103014: LD_VAR 0 5
103018: PUSH
103019: LD_INT 1
103021: ARRAY
103022: PPUSH
103023: CALL_OW 302
103027: NOT
103028: PUSH
103029: LD_VAR 0 5
103033: PUSH
103034: LD_INT 1
103036: ARRAY
103037: PPUSH
103038: CALL_OW 255
103042: PUSH
103043: LD_VAR 0 1
103047: PPUSH
103048: CALL_OW 255
103052: NONEQUAL
103053: OR
103054: IFFALSE 103160
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103056: LD_VAR 0 5
103060: PUSH
103061: LD_INT 1
103063: ARRAY
103064: PPUSH
103065: CALL_OW 305
103069: PUSH
103070: LD_VAR 0 5
103074: PUSH
103075: LD_INT 1
103077: ARRAY
103078: PPUSH
103079: CALL_OW 255
103083: PUSH
103084: LD_VAR 0 1
103088: PPUSH
103089: CALL_OW 255
103093: EQUAL
103094: AND
103095: IFFALSE 103119
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103097: LD_VAR 0 5
103101: PUSH
103102: LD_INT 1
103104: ARRAY
103105: PPUSH
103106: LD_VAR 0 5
103110: PUSH
103111: LD_INT 2
103113: ARRAY
103114: PPUSH
103115: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103119: LD_ADDR_EXP 172
103123: PUSH
103124: LD_EXP 172
103128: PPUSH
103129: LD_VAR 0 4
103133: PPUSH
103134: LD_EXP 172
103138: PUSH
103139: LD_VAR 0 4
103143: ARRAY
103144: PPUSH
103145: LD_VAR 0 3
103149: PPUSH
103150: CALL_OW 3
103154: PPUSH
103155: CALL_OW 1
103159: ST_TO_ADDR
// end ; end ;
103160: GO 102989
103162: POP
103163: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103164: LD_VAR 0 1
103168: PPUSH
103169: LD_EXP 172
103173: PUSH
103174: LD_VAR 0 4
103178: ARRAY
103179: PUSH
103180: LD_INT 0
103182: PLUS
103183: PPUSH
103184: CALL_OW 505
// end ;
103188: LD_VAR 0 2
103192: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103193: LD_INT 0
103195: PPUSH
103196: PPUSH
103197: PPUSH
103198: PPUSH
// if not hack in hackTanks then
103199: LD_VAR 0 1
103203: PUSH
103204: LD_EXP 171
103208: IN
103209: NOT
103210: IFFALSE 103214
// exit ;
103212: GO 103299
// index := GetElementIndex ( hackTanks , hack ) ;
103214: LD_ADDR_VAR 0 5
103218: PUSH
103219: LD_EXP 171
103223: PPUSH
103224: LD_VAR 0 1
103228: PPUSH
103229: CALL 53179 0 2
103233: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103234: LD_ADDR_VAR 0 4
103238: PUSH
103239: DOUBLE
103240: LD_INT 1
103242: DEC
103243: ST_TO_ADDR
103244: LD_EXP 172
103248: PUSH
103249: LD_VAR 0 5
103253: ARRAY
103254: PUSH
103255: FOR_TO
103256: IFFALSE 103297
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103258: LD_EXP 172
103262: PUSH
103263: LD_VAR 0 5
103267: ARRAY
103268: PUSH
103269: LD_VAR 0 4
103273: ARRAY
103274: PUSH
103275: LD_INT 1
103277: ARRAY
103278: PUSH
103279: LD_VAR 0 2
103283: EQUAL
103284: IFFALSE 103295
// KillUnit ( vehicle ) ;
103286: LD_VAR 0 2
103290: PPUSH
103291: CALL_OW 66
103295: GO 103255
103297: POP
103298: POP
// end ;
103299: LD_VAR 0 3
103303: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103304: LD_EXP 176
103308: NOT
103309: IFFALSE 103344
103311: GO 103313
103313: DISABLE
// begin initMiner := true ;
103314: LD_ADDR_EXP 176
103318: PUSH
103319: LD_INT 1
103321: ST_TO_ADDR
// minersList := [ ] ;
103322: LD_ADDR_EXP 177
103326: PUSH
103327: EMPTY
103328: ST_TO_ADDR
// minerMinesList := [ ] ;
103329: LD_ADDR_EXP 178
103333: PUSH
103334: EMPTY
103335: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103336: LD_ADDR_EXP 179
103340: PUSH
103341: LD_INT 5
103343: ST_TO_ADDR
// end ;
103344: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103345: LD_EXP 176
103349: PUSH
103350: LD_INT 34
103352: PUSH
103353: LD_EXP 101
103357: PUSH
103358: EMPTY
103359: LIST
103360: LIST
103361: PPUSH
103362: CALL_OW 69
103366: AND
103367: IFFALSE 103830
103369: GO 103371
103371: DISABLE
103372: LD_INT 0
103374: PPUSH
103375: PPUSH
103376: PPUSH
103377: PPUSH
// begin enable ;
103378: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103379: LD_ADDR_VAR 0 1
103383: PUSH
103384: LD_INT 34
103386: PUSH
103387: LD_EXP 101
103391: PUSH
103392: EMPTY
103393: LIST
103394: LIST
103395: PPUSH
103396: CALL_OW 69
103400: PUSH
103401: FOR_IN
103402: IFFALSE 103474
// begin if not i in minersList then
103404: LD_VAR 0 1
103408: PUSH
103409: LD_EXP 177
103413: IN
103414: NOT
103415: IFFALSE 103472
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103417: LD_ADDR_EXP 177
103421: PUSH
103422: LD_EXP 177
103426: PPUSH
103427: LD_EXP 177
103431: PUSH
103432: LD_INT 1
103434: PLUS
103435: PPUSH
103436: LD_VAR 0 1
103440: PPUSH
103441: CALL_OW 1
103445: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103446: LD_ADDR_EXP 178
103450: PUSH
103451: LD_EXP 178
103455: PPUSH
103456: LD_EXP 178
103460: PUSH
103461: LD_INT 1
103463: PLUS
103464: PPUSH
103465: EMPTY
103466: PPUSH
103467: CALL_OW 1
103471: ST_TO_ADDR
// end end ;
103472: GO 103401
103474: POP
103475: POP
// for i := minerMinesList downto 1 do
103476: LD_ADDR_VAR 0 1
103480: PUSH
103481: DOUBLE
103482: LD_EXP 178
103486: INC
103487: ST_TO_ADDR
103488: LD_INT 1
103490: PUSH
103491: FOR_DOWNTO
103492: IFFALSE 103828
// begin if IsLive ( minersList [ i ] ) then
103494: LD_EXP 177
103498: PUSH
103499: LD_VAR 0 1
103503: ARRAY
103504: PPUSH
103505: CALL_OW 300
103509: IFFALSE 103537
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103511: LD_EXP 177
103515: PUSH
103516: LD_VAR 0 1
103520: ARRAY
103521: PPUSH
103522: LD_EXP 178
103526: PUSH
103527: LD_VAR 0 1
103531: ARRAY
103532: PPUSH
103533: CALL_OW 505
// if not minerMinesList [ i ] then
103537: LD_EXP 178
103541: PUSH
103542: LD_VAR 0 1
103546: ARRAY
103547: NOT
103548: IFFALSE 103552
// continue ;
103550: GO 103491
// for j := minerMinesList [ i ] downto 1 do
103552: LD_ADDR_VAR 0 2
103556: PUSH
103557: DOUBLE
103558: LD_EXP 178
103562: PUSH
103563: LD_VAR 0 1
103567: ARRAY
103568: INC
103569: ST_TO_ADDR
103570: LD_INT 1
103572: PUSH
103573: FOR_DOWNTO
103574: IFFALSE 103824
// begin side := GetSide ( minersList [ i ] ) ;
103576: LD_ADDR_VAR 0 3
103580: PUSH
103581: LD_EXP 177
103585: PUSH
103586: LD_VAR 0 1
103590: ARRAY
103591: PPUSH
103592: CALL_OW 255
103596: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103597: LD_ADDR_VAR 0 4
103601: PUSH
103602: LD_EXP 178
103606: PUSH
103607: LD_VAR 0 1
103611: ARRAY
103612: PUSH
103613: LD_VAR 0 2
103617: ARRAY
103618: PUSH
103619: LD_INT 1
103621: ARRAY
103622: PPUSH
103623: LD_EXP 178
103627: PUSH
103628: LD_VAR 0 1
103632: ARRAY
103633: PUSH
103634: LD_VAR 0 2
103638: ARRAY
103639: PUSH
103640: LD_INT 2
103642: ARRAY
103643: PPUSH
103644: CALL_OW 428
103648: ST_TO_ADDR
// if not tmp then
103649: LD_VAR 0 4
103653: NOT
103654: IFFALSE 103658
// continue ;
103656: GO 103573
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103658: LD_VAR 0 4
103662: PUSH
103663: LD_INT 81
103665: PUSH
103666: LD_VAR 0 3
103670: PUSH
103671: EMPTY
103672: LIST
103673: LIST
103674: PPUSH
103675: CALL_OW 69
103679: IN
103680: PUSH
103681: LD_EXP 178
103685: PUSH
103686: LD_VAR 0 1
103690: ARRAY
103691: PUSH
103692: LD_VAR 0 2
103696: ARRAY
103697: PUSH
103698: LD_INT 1
103700: ARRAY
103701: PPUSH
103702: LD_EXP 178
103706: PUSH
103707: LD_VAR 0 1
103711: ARRAY
103712: PUSH
103713: LD_VAR 0 2
103717: ARRAY
103718: PUSH
103719: LD_INT 2
103721: ARRAY
103722: PPUSH
103723: CALL_OW 458
103727: AND
103728: IFFALSE 103822
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103730: LD_EXP 178
103734: PUSH
103735: LD_VAR 0 1
103739: ARRAY
103740: PUSH
103741: LD_VAR 0 2
103745: ARRAY
103746: PUSH
103747: LD_INT 1
103749: ARRAY
103750: PPUSH
103751: LD_EXP 178
103755: PUSH
103756: LD_VAR 0 1
103760: ARRAY
103761: PUSH
103762: LD_VAR 0 2
103766: ARRAY
103767: PUSH
103768: LD_INT 2
103770: ARRAY
103771: PPUSH
103772: LD_VAR 0 3
103776: PPUSH
103777: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103781: LD_ADDR_EXP 178
103785: PUSH
103786: LD_EXP 178
103790: PPUSH
103791: LD_VAR 0 1
103795: PPUSH
103796: LD_EXP 178
103800: PUSH
103801: LD_VAR 0 1
103805: ARRAY
103806: PPUSH
103807: LD_VAR 0 2
103811: PPUSH
103812: CALL_OW 3
103816: PPUSH
103817: CALL_OW 1
103821: ST_TO_ADDR
// end ; end ;
103822: GO 103573
103824: POP
103825: POP
// end ;
103826: GO 103491
103828: POP
103829: POP
// end ;
103830: PPOPN 4
103832: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103833: LD_INT 0
103835: PPUSH
103836: PPUSH
// result := false ;
103837: LD_ADDR_VAR 0 4
103841: PUSH
103842: LD_INT 0
103844: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103845: LD_VAR 0 1
103849: PPUSH
103850: CALL_OW 264
103854: PUSH
103855: LD_EXP 101
103859: EQUAL
103860: NOT
103861: IFFALSE 103865
// exit ;
103863: GO 104105
// index := GetElementIndex ( minersList , unit ) ;
103865: LD_ADDR_VAR 0 5
103869: PUSH
103870: LD_EXP 177
103874: PPUSH
103875: LD_VAR 0 1
103879: PPUSH
103880: CALL 53179 0 2
103884: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103885: LD_EXP 178
103889: PUSH
103890: LD_VAR 0 5
103894: ARRAY
103895: PUSH
103896: LD_EXP 179
103900: GREATEREQUAL
103901: IFFALSE 103905
// exit ;
103903: GO 104105
// ComMoveXY ( unit , x , y ) ;
103905: LD_VAR 0 1
103909: PPUSH
103910: LD_VAR 0 2
103914: PPUSH
103915: LD_VAR 0 3
103919: PPUSH
103920: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103924: LD_INT 35
103926: PPUSH
103927: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103931: LD_VAR 0 1
103935: PPUSH
103936: LD_VAR 0 2
103940: PPUSH
103941: LD_VAR 0 3
103945: PPUSH
103946: CALL 83951 0 3
103950: NOT
103951: PUSH
103952: LD_VAR 0 1
103956: PPUSH
103957: CALL_OW 314
103961: AND
103962: IFFALSE 103966
// exit ;
103964: GO 104105
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103966: LD_VAR 0 2
103970: PPUSH
103971: LD_VAR 0 3
103975: PPUSH
103976: CALL_OW 428
103980: PUSH
103981: LD_VAR 0 1
103985: EQUAL
103986: PUSH
103987: LD_VAR 0 1
103991: PPUSH
103992: CALL_OW 314
103996: NOT
103997: AND
103998: IFFALSE 103924
// PlaySoundXY ( x , y , PlantMine ) ;
104000: LD_VAR 0 2
104004: PPUSH
104005: LD_VAR 0 3
104009: PPUSH
104010: LD_STRING PlantMine
104012: PPUSH
104013: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104017: LD_VAR 0 2
104021: PPUSH
104022: LD_VAR 0 3
104026: PPUSH
104027: LD_VAR 0 1
104031: PPUSH
104032: CALL_OW 255
104036: PPUSH
104037: LD_INT 0
104039: PPUSH
104040: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104044: LD_ADDR_EXP 178
104048: PUSH
104049: LD_EXP 178
104053: PPUSH
104054: LD_VAR 0 5
104058: PUSH
104059: LD_EXP 178
104063: PUSH
104064: LD_VAR 0 5
104068: ARRAY
104069: PUSH
104070: LD_INT 1
104072: PLUS
104073: PUSH
104074: EMPTY
104075: LIST
104076: LIST
104077: PPUSH
104078: LD_VAR 0 2
104082: PUSH
104083: LD_VAR 0 3
104087: PUSH
104088: EMPTY
104089: LIST
104090: LIST
104091: PPUSH
104092: CALL 53394 0 3
104096: ST_TO_ADDR
// result := true ;
104097: LD_ADDR_VAR 0 4
104101: PUSH
104102: LD_INT 1
104104: ST_TO_ADDR
// end ;
104105: LD_VAR 0 4
104109: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104110: LD_INT 0
104112: PPUSH
104113: PPUSH
104114: PPUSH
// if not unit in minersList then
104115: LD_VAR 0 1
104119: PUSH
104120: LD_EXP 177
104124: IN
104125: NOT
104126: IFFALSE 104130
// exit ;
104128: GO 104522
// index := GetElementIndex ( minersList , unit ) ;
104130: LD_ADDR_VAR 0 6
104134: PUSH
104135: LD_EXP 177
104139: PPUSH
104140: LD_VAR 0 1
104144: PPUSH
104145: CALL 53179 0 2
104149: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104150: LD_ADDR_VAR 0 5
104154: PUSH
104155: DOUBLE
104156: LD_EXP 178
104160: PUSH
104161: LD_VAR 0 6
104165: ARRAY
104166: INC
104167: ST_TO_ADDR
104168: LD_INT 1
104170: PUSH
104171: FOR_DOWNTO
104172: IFFALSE 104333
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104174: LD_EXP 178
104178: PUSH
104179: LD_VAR 0 6
104183: ARRAY
104184: PUSH
104185: LD_VAR 0 5
104189: ARRAY
104190: PUSH
104191: LD_INT 1
104193: ARRAY
104194: PUSH
104195: LD_VAR 0 2
104199: EQUAL
104200: PUSH
104201: LD_EXP 178
104205: PUSH
104206: LD_VAR 0 6
104210: ARRAY
104211: PUSH
104212: LD_VAR 0 5
104216: ARRAY
104217: PUSH
104218: LD_INT 2
104220: ARRAY
104221: PUSH
104222: LD_VAR 0 3
104226: EQUAL
104227: AND
104228: IFFALSE 104331
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104230: LD_EXP 178
104234: PUSH
104235: LD_VAR 0 6
104239: ARRAY
104240: PUSH
104241: LD_VAR 0 5
104245: ARRAY
104246: PUSH
104247: LD_INT 1
104249: ARRAY
104250: PPUSH
104251: LD_EXP 178
104255: PUSH
104256: LD_VAR 0 6
104260: ARRAY
104261: PUSH
104262: LD_VAR 0 5
104266: ARRAY
104267: PUSH
104268: LD_INT 2
104270: ARRAY
104271: PPUSH
104272: LD_VAR 0 1
104276: PPUSH
104277: CALL_OW 255
104281: PPUSH
104282: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104286: LD_ADDR_EXP 178
104290: PUSH
104291: LD_EXP 178
104295: PPUSH
104296: LD_VAR 0 6
104300: PPUSH
104301: LD_EXP 178
104305: PUSH
104306: LD_VAR 0 6
104310: ARRAY
104311: PPUSH
104312: LD_VAR 0 5
104316: PPUSH
104317: CALL_OW 3
104321: PPUSH
104322: CALL_OW 1
104326: ST_TO_ADDR
// exit ;
104327: POP
104328: POP
104329: GO 104522
// end ; end ;
104331: GO 104171
104333: POP
104334: POP
// for i := minerMinesList [ index ] downto 1 do
104335: LD_ADDR_VAR 0 5
104339: PUSH
104340: DOUBLE
104341: LD_EXP 178
104345: PUSH
104346: LD_VAR 0 6
104350: ARRAY
104351: INC
104352: ST_TO_ADDR
104353: LD_INT 1
104355: PUSH
104356: FOR_DOWNTO
104357: IFFALSE 104520
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104359: LD_EXP 178
104363: PUSH
104364: LD_VAR 0 6
104368: ARRAY
104369: PUSH
104370: LD_VAR 0 5
104374: ARRAY
104375: PUSH
104376: LD_INT 1
104378: ARRAY
104379: PPUSH
104380: LD_EXP 178
104384: PUSH
104385: LD_VAR 0 6
104389: ARRAY
104390: PUSH
104391: LD_VAR 0 5
104395: ARRAY
104396: PUSH
104397: LD_INT 2
104399: ARRAY
104400: PPUSH
104401: LD_VAR 0 2
104405: PPUSH
104406: LD_VAR 0 3
104410: PPUSH
104411: CALL_OW 298
104415: PUSH
104416: LD_INT 6
104418: LESS
104419: IFFALSE 104518
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104421: LD_EXP 178
104425: PUSH
104426: LD_VAR 0 6
104430: ARRAY
104431: PUSH
104432: LD_VAR 0 5
104436: ARRAY
104437: PUSH
104438: LD_INT 1
104440: ARRAY
104441: PPUSH
104442: LD_EXP 178
104446: PUSH
104447: LD_VAR 0 6
104451: ARRAY
104452: PUSH
104453: LD_VAR 0 5
104457: ARRAY
104458: PUSH
104459: LD_INT 2
104461: ARRAY
104462: PPUSH
104463: LD_VAR 0 1
104467: PPUSH
104468: CALL_OW 255
104472: PPUSH
104473: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104477: LD_ADDR_EXP 178
104481: PUSH
104482: LD_EXP 178
104486: PPUSH
104487: LD_VAR 0 6
104491: PPUSH
104492: LD_EXP 178
104496: PUSH
104497: LD_VAR 0 6
104501: ARRAY
104502: PPUSH
104503: LD_VAR 0 5
104507: PPUSH
104508: CALL_OW 3
104512: PPUSH
104513: CALL_OW 1
104517: ST_TO_ADDR
// end ; end ;
104518: GO 104356
104520: POP
104521: POP
// end ;
104522: LD_VAR 0 4
104526: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104527: LD_INT 0
104529: PPUSH
104530: PPUSH
104531: PPUSH
104532: PPUSH
104533: PPUSH
104534: PPUSH
104535: PPUSH
104536: PPUSH
104537: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104538: LD_VAR 0 1
104542: PPUSH
104543: CALL_OW 264
104547: PUSH
104548: LD_EXP 101
104552: EQUAL
104553: NOT
104554: PUSH
104555: LD_VAR 0 1
104559: PUSH
104560: LD_EXP 177
104564: IN
104565: NOT
104566: OR
104567: IFFALSE 104571
// exit ;
104569: GO 104893
// index := GetElementIndex ( minersList , unit ) ;
104571: LD_ADDR_VAR 0 6
104575: PUSH
104576: LD_EXP 177
104580: PPUSH
104581: LD_VAR 0 1
104585: PPUSH
104586: CALL 53179 0 2
104590: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104591: LD_ADDR_VAR 0 8
104595: PUSH
104596: LD_EXP 179
104600: PUSH
104601: LD_EXP 178
104605: PUSH
104606: LD_VAR 0 6
104610: ARRAY
104611: MINUS
104612: ST_TO_ADDR
// if not minesFreeAmount then
104613: LD_VAR 0 8
104617: NOT
104618: IFFALSE 104622
// exit ;
104620: GO 104893
// tmp := [ ] ;
104622: LD_ADDR_VAR 0 7
104626: PUSH
104627: EMPTY
104628: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104629: LD_ADDR_VAR 0 5
104633: PUSH
104634: DOUBLE
104635: LD_INT 1
104637: DEC
104638: ST_TO_ADDR
104639: LD_VAR 0 8
104643: PUSH
104644: FOR_TO
104645: IFFALSE 104840
// begin _d := rand ( 0 , 5 ) ;
104647: LD_ADDR_VAR 0 11
104651: PUSH
104652: LD_INT 0
104654: PPUSH
104655: LD_INT 5
104657: PPUSH
104658: CALL_OW 12
104662: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104663: LD_ADDR_VAR 0 12
104667: PUSH
104668: LD_INT 2
104670: PPUSH
104671: LD_INT 6
104673: PPUSH
104674: CALL_OW 12
104678: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104679: LD_ADDR_VAR 0 9
104683: PUSH
104684: LD_VAR 0 2
104688: PPUSH
104689: LD_VAR 0 11
104693: PPUSH
104694: LD_VAR 0 12
104698: PPUSH
104699: CALL_OW 272
104703: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104704: LD_ADDR_VAR 0 10
104708: PUSH
104709: LD_VAR 0 3
104713: PPUSH
104714: LD_VAR 0 11
104718: PPUSH
104719: LD_VAR 0 12
104723: PPUSH
104724: CALL_OW 273
104728: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104729: LD_VAR 0 9
104733: PPUSH
104734: LD_VAR 0 10
104738: PPUSH
104739: CALL_OW 488
104743: PUSH
104744: LD_VAR 0 9
104748: PUSH
104749: LD_VAR 0 10
104753: PUSH
104754: EMPTY
104755: LIST
104756: LIST
104757: PUSH
104758: LD_VAR 0 7
104762: IN
104763: NOT
104764: AND
104765: PUSH
104766: LD_VAR 0 9
104770: PPUSH
104771: LD_VAR 0 10
104775: PPUSH
104776: CALL_OW 458
104780: NOT
104781: AND
104782: IFFALSE 104824
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104784: LD_ADDR_VAR 0 7
104788: PUSH
104789: LD_VAR 0 7
104793: PPUSH
104794: LD_VAR 0 7
104798: PUSH
104799: LD_INT 1
104801: PLUS
104802: PPUSH
104803: LD_VAR 0 9
104807: PUSH
104808: LD_VAR 0 10
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: PPUSH
104817: CALL_OW 1
104821: ST_TO_ADDR
104822: GO 104838
// i := i - 1 ;
104824: LD_ADDR_VAR 0 5
104828: PUSH
104829: LD_VAR 0 5
104833: PUSH
104834: LD_INT 1
104836: MINUS
104837: ST_TO_ADDR
// end ;
104838: GO 104644
104840: POP
104841: POP
// for i in tmp do
104842: LD_ADDR_VAR 0 5
104846: PUSH
104847: LD_VAR 0 7
104851: PUSH
104852: FOR_IN
104853: IFFALSE 104891
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104855: LD_VAR 0 1
104859: PPUSH
104860: LD_VAR 0 5
104864: PUSH
104865: LD_INT 1
104867: ARRAY
104868: PPUSH
104869: LD_VAR 0 5
104873: PUSH
104874: LD_INT 2
104876: ARRAY
104877: PPUSH
104878: CALL 103833 0 3
104882: NOT
104883: IFFALSE 104889
// exit ;
104885: POP
104886: POP
104887: GO 104893
104889: GO 104852
104891: POP
104892: POP
// end ;
104893: LD_VAR 0 4
104897: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104898: LD_INT 0
104900: PPUSH
104901: PPUSH
104902: PPUSH
104903: PPUSH
104904: PPUSH
104905: PPUSH
104906: PPUSH
// if not GetClass ( unit ) = class_sniper then
104907: LD_VAR 0 1
104911: PPUSH
104912: CALL_OW 257
104916: PUSH
104917: LD_INT 5
104919: EQUAL
104920: NOT
104921: IFFALSE 104925
// exit ;
104923: GO 105313
// dist := 8 ;
104925: LD_ADDR_VAR 0 5
104929: PUSH
104930: LD_INT 8
104932: ST_TO_ADDR
// viewRange := 12 ;
104933: LD_ADDR_VAR 0 7
104937: PUSH
104938: LD_INT 12
104940: ST_TO_ADDR
// side := GetSide ( unit ) ;
104941: LD_ADDR_VAR 0 6
104945: PUSH
104946: LD_VAR 0 1
104950: PPUSH
104951: CALL_OW 255
104955: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104956: LD_INT 61
104958: PPUSH
104959: LD_VAR 0 6
104963: PPUSH
104964: CALL_OW 321
104968: PUSH
104969: LD_INT 2
104971: EQUAL
104972: IFFALSE 104982
// viewRange := 16 ;
104974: LD_ADDR_VAR 0 7
104978: PUSH
104979: LD_INT 16
104981: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104982: LD_VAR 0 1
104986: PPUSH
104987: LD_VAR 0 2
104991: PPUSH
104992: LD_VAR 0 3
104996: PPUSH
104997: CALL_OW 297
105001: PUSH
105002: LD_VAR 0 5
105006: GREATER
105007: IFFALSE 105086
// begin ComMoveXY ( unit , x , y ) ;
105009: LD_VAR 0 1
105013: PPUSH
105014: LD_VAR 0 2
105018: PPUSH
105019: LD_VAR 0 3
105023: PPUSH
105024: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105028: LD_INT 35
105030: PPUSH
105031: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105035: LD_VAR 0 1
105039: PPUSH
105040: LD_VAR 0 2
105044: PPUSH
105045: LD_VAR 0 3
105049: PPUSH
105050: CALL 83951 0 3
105054: NOT
105055: IFFALSE 105059
// exit ;
105057: GO 105313
// until GetDistUnitXY ( unit , x , y ) < dist ;
105059: LD_VAR 0 1
105063: PPUSH
105064: LD_VAR 0 2
105068: PPUSH
105069: LD_VAR 0 3
105073: PPUSH
105074: CALL_OW 297
105078: PUSH
105079: LD_VAR 0 5
105083: LESS
105084: IFFALSE 105028
// end ; ComTurnXY ( unit , x , y ) ;
105086: LD_VAR 0 1
105090: PPUSH
105091: LD_VAR 0 2
105095: PPUSH
105096: LD_VAR 0 3
105100: PPUSH
105101: CALL_OW 118
// wait ( 5 ) ;
105105: LD_INT 5
105107: PPUSH
105108: CALL_OW 67
// _d := GetDir ( unit ) ;
105112: LD_ADDR_VAR 0 10
105116: PUSH
105117: LD_VAR 0 1
105121: PPUSH
105122: CALL_OW 254
105126: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105127: LD_ADDR_VAR 0 8
105131: PUSH
105132: LD_VAR 0 1
105136: PPUSH
105137: CALL_OW 250
105141: PPUSH
105142: LD_VAR 0 10
105146: PPUSH
105147: LD_VAR 0 5
105151: PPUSH
105152: CALL_OW 272
105156: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105157: LD_ADDR_VAR 0 9
105161: PUSH
105162: LD_VAR 0 1
105166: PPUSH
105167: CALL_OW 251
105171: PPUSH
105172: LD_VAR 0 10
105176: PPUSH
105177: LD_VAR 0 5
105181: PPUSH
105182: CALL_OW 273
105186: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105187: LD_VAR 0 8
105191: PPUSH
105192: LD_VAR 0 9
105196: PPUSH
105197: CALL_OW 488
105201: NOT
105202: IFFALSE 105206
// exit ;
105204: GO 105313
// ComAnimCustom ( unit , 1 ) ;
105206: LD_VAR 0 1
105210: PPUSH
105211: LD_INT 1
105213: PPUSH
105214: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105218: LD_VAR 0 8
105222: PPUSH
105223: LD_VAR 0 9
105227: PPUSH
105228: LD_VAR 0 6
105232: PPUSH
105233: LD_VAR 0 7
105237: PPUSH
105238: CALL_OW 330
// repeat wait ( 1 ) ;
105242: LD_INT 1
105244: PPUSH
105245: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105249: LD_VAR 0 1
105253: PPUSH
105254: CALL_OW 316
105258: PUSH
105259: LD_VAR 0 1
105263: PPUSH
105264: CALL_OW 314
105268: OR
105269: PUSH
105270: LD_VAR 0 1
105274: PPUSH
105275: CALL_OW 302
105279: NOT
105280: OR
105281: PUSH
105282: LD_VAR 0 1
105286: PPUSH
105287: CALL_OW 301
105291: OR
105292: IFFALSE 105242
// RemoveSeeing ( _x , _y , side ) ;
105294: LD_VAR 0 8
105298: PPUSH
105299: LD_VAR 0 9
105303: PPUSH
105304: LD_VAR 0 6
105308: PPUSH
105309: CALL_OW 331
// end ; end_of_file
105313: LD_VAR 0 4
105317: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105318: LD_INT 0
105320: PPUSH
105321: PPUSH
105322: PPUSH
105323: PPUSH
105324: PPUSH
105325: PPUSH
105326: PPUSH
105327: PPUSH
105328: PPUSH
105329: PPUSH
105330: PPUSH
105331: PPUSH
105332: PPUSH
105333: PPUSH
105334: PPUSH
105335: PPUSH
105336: PPUSH
105337: PPUSH
105338: PPUSH
105339: PPUSH
105340: PPUSH
105341: PPUSH
105342: PPUSH
105343: PPUSH
105344: PPUSH
105345: PPUSH
105346: PPUSH
105347: PPUSH
105348: PPUSH
105349: PPUSH
105350: PPUSH
105351: PPUSH
105352: PPUSH
105353: PPUSH
// if not list then
105354: LD_VAR 0 1
105358: NOT
105359: IFFALSE 105363
// exit ;
105361: GO 110022
// base := list [ 1 ] ;
105363: LD_ADDR_VAR 0 3
105367: PUSH
105368: LD_VAR 0 1
105372: PUSH
105373: LD_INT 1
105375: ARRAY
105376: ST_TO_ADDR
// group := list [ 2 ] ;
105377: LD_ADDR_VAR 0 4
105381: PUSH
105382: LD_VAR 0 1
105386: PUSH
105387: LD_INT 2
105389: ARRAY
105390: ST_TO_ADDR
// path := list [ 3 ] ;
105391: LD_ADDR_VAR 0 5
105395: PUSH
105396: LD_VAR 0 1
105400: PUSH
105401: LD_INT 3
105403: ARRAY
105404: ST_TO_ADDR
// flags := list [ 4 ] ;
105405: LD_ADDR_VAR 0 6
105409: PUSH
105410: LD_VAR 0 1
105414: PUSH
105415: LD_INT 4
105417: ARRAY
105418: ST_TO_ADDR
// mined := [ ] ;
105419: LD_ADDR_VAR 0 27
105423: PUSH
105424: EMPTY
105425: ST_TO_ADDR
// bombed := [ ] ;
105426: LD_ADDR_VAR 0 28
105430: PUSH
105431: EMPTY
105432: ST_TO_ADDR
// healers := [ ] ;
105433: LD_ADDR_VAR 0 31
105437: PUSH
105438: EMPTY
105439: ST_TO_ADDR
// to_heal := [ ] ;
105440: LD_ADDR_VAR 0 30
105444: PUSH
105445: EMPTY
105446: ST_TO_ADDR
// repairs := [ ] ;
105447: LD_ADDR_VAR 0 33
105451: PUSH
105452: EMPTY
105453: ST_TO_ADDR
// to_repair := [ ] ;
105454: LD_ADDR_VAR 0 32
105458: PUSH
105459: EMPTY
105460: ST_TO_ADDR
// if not group or not path then
105461: LD_VAR 0 4
105465: NOT
105466: PUSH
105467: LD_VAR 0 5
105471: NOT
105472: OR
105473: IFFALSE 105477
// exit ;
105475: GO 110022
// side := GetSide ( group [ 1 ] ) ;
105477: LD_ADDR_VAR 0 35
105481: PUSH
105482: LD_VAR 0 4
105486: PUSH
105487: LD_INT 1
105489: ARRAY
105490: PPUSH
105491: CALL_OW 255
105495: ST_TO_ADDR
// if flags then
105496: LD_VAR 0 6
105500: IFFALSE 105644
// begin f_ignore_area := flags [ 1 ] ;
105502: LD_ADDR_VAR 0 17
105506: PUSH
105507: LD_VAR 0 6
105511: PUSH
105512: LD_INT 1
105514: ARRAY
105515: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105516: LD_ADDR_VAR 0 18
105520: PUSH
105521: LD_VAR 0 6
105525: PUSH
105526: LD_INT 2
105528: ARRAY
105529: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105530: LD_ADDR_VAR 0 19
105534: PUSH
105535: LD_VAR 0 6
105539: PUSH
105540: LD_INT 3
105542: ARRAY
105543: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105544: LD_ADDR_VAR 0 20
105548: PUSH
105549: LD_VAR 0 6
105553: PUSH
105554: LD_INT 4
105556: ARRAY
105557: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105558: LD_ADDR_VAR 0 21
105562: PUSH
105563: LD_VAR 0 6
105567: PUSH
105568: LD_INT 5
105570: ARRAY
105571: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105572: LD_ADDR_VAR 0 22
105576: PUSH
105577: LD_VAR 0 6
105581: PUSH
105582: LD_INT 6
105584: ARRAY
105585: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105586: LD_ADDR_VAR 0 23
105590: PUSH
105591: LD_VAR 0 6
105595: PUSH
105596: LD_INT 7
105598: ARRAY
105599: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105600: LD_ADDR_VAR 0 24
105604: PUSH
105605: LD_VAR 0 6
105609: PUSH
105610: LD_INT 8
105612: ARRAY
105613: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105614: LD_ADDR_VAR 0 25
105618: PUSH
105619: LD_VAR 0 6
105623: PUSH
105624: LD_INT 9
105626: ARRAY
105627: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105628: LD_ADDR_VAR 0 26
105632: PUSH
105633: LD_VAR 0 6
105637: PUSH
105638: LD_INT 10
105640: ARRAY
105641: ST_TO_ADDR
// end else
105642: GO 105724
// begin f_ignore_area := false ;
105644: LD_ADDR_VAR 0 17
105648: PUSH
105649: LD_INT 0
105651: ST_TO_ADDR
// f_capture := false ;
105652: LD_ADDR_VAR 0 18
105656: PUSH
105657: LD_INT 0
105659: ST_TO_ADDR
// f_ignore_civ := false ;
105660: LD_ADDR_VAR 0 19
105664: PUSH
105665: LD_INT 0
105667: ST_TO_ADDR
// f_murder := false ;
105668: LD_ADDR_VAR 0 20
105672: PUSH
105673: LD_INT 0
105675: ST_TO_ADDR
// f_mines := false ;
105676: LD_ADDR_VAR 0 21
105680: PUSH
105681: LD_INT 0
105683: ST_TO_ADDR
// f_repair := false ;
105684: LD_ADDR_VAR 0 22
105688: PUSH
105689: LD_INT 0
105691: ST_TO_ADDR
// f_heal := false ;
105692: LD_ADDR_VAR 0 23
105696: PUSH
105697: LD_INT 0
105699: ST_TO_ADDR
// f_spacetime := false ;
105700: LD_ADDR_VAR 0 24
105704: PUSH
105705: LD_INT 0
105707: ST_TO_ADDR
// f_attack_depot := false ;
105708: LD_ADDR_VAR 0 25
105712: PUSH
105713: LD_INT 0
105715: ST_TO_ADDR
// f_crawl := false ;
105716: LD_ADDR_VAR 0 26
105720: PUSH
105721: LD_INT 0
105723: ST_TO_ADDR
// end ; if f_heal then
105724: LD_VAR 0 23
105728: IFFALSE 105755
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105730: LD_ADDR_VAR 0 31
105734: PUSH
105735: LD_VAR 0 4
105739: PPUSH
105740: LD_INT 25
105742: PUSH
105743: LD_INT 4
105745: PUSH
105746: EMPTY
105747: LIST
105748: LIST
105749: PPUSH
105750: CALL_OW 72
105754: ST_TO_ADDR
// if f_repair then
105755: LD_VAR 0 22
105759: IFFALSE 105786
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105761: LD_ADDR_VAR 0 33
105765: PUSH
105766: LD_VAR 0 4
105770: PPUSH
105771: LD_INT 25
105773: PUSH
105774: LD_INT 3
105776: PUSH
105777: EMPTY
105778: LIST
105779: LIST
105780: PPUSH
105781: CALL_OW 72
105785: ST_TO_ADDR
// units_path := [ ] ;
105786: LD_ADDR_VAR 0 16
105790: PUSH
105791: EMPTY
105792: ST_TO_ADDR
// for i = 1 to group do
105793: LD_ADDR_VAR 0 7
105797: PUSH
105798: DOUBLE
105799: LD_INT 1
105801: DEC
105802: ST_TO_ADDR
105803: LD_VAR 0 4
105807: PUSH
105808: FOR_TO
105809: IFFALSE 105838
// units_path := Replace ( units_path , i , path ) ;
105811: LD_ADDR_VAR 0 16
105815: PUSH
105816: LD_VAR 0 16
105820: PPUSH
105821: LD_VAR 0 7
105825: PPUSH
105826: LD_VAR 0 5
105830: PPUSH
105831: CALL_OW 1
105835: ST_TO_ADDR
105836: GO 105808
105838: POP
105839: POP
// repeat for i = group downto 1 do
105840: LD_ADDR_VAR 0 7
105844: PUSH
105845: DOUBLE
105846: LD_VAR 0 4
105850: INC
105851: ST_TO_ADDR
105852: LD_INT 1
105854: PUSH
105855: FOR_DOWNTO
105856: IFFALSE 109978
// begin wait ( 5 ) ;
105858: LD_INT 5
105860: PPUSH
105861: CALL_OW 67
// tmp := [ ] ;
105865: LD_ADDR_VAR 0 14
105869: PUSH
105870: EMPTY
105871: ST_TO_ADDR
// attacking := false ;
105872: LD_ADDR_VAR 0 29
105876: PUSH
105877: LD_INT 0
105879: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105880: LD_VAR 0 4
105884: PUSH
105885: LD_VAR 0 7
105889: ARRAY
105890: PPUSH
105891: CALL_OW 301
105895: PUSH
105896: LD_VAR 0 4
105900: PUSH
105901: LD_VAR 0 7
105905: ARRAY
105906: NOT
105907: OR
105908: IFFALSE 106017
// begin if GetType ( group [ i ] ) = unit_human then
105910: LD_VAR 0 4
105914: PUSH
105915: LD_VAR 0 7
105919: ARRAY
105920: PPUSH
105921: CALL_OW 247
105925: PUSH
105926: LD_INT 1
105928: EQUAL
105929: IFFALSE 105975
// begin to_heal := to_heal diff group [ i ] ;
105931: LD_ADDR_VAR 0 30
105935: PUSH
105936: LD_VAR 0 30
105940: PUSH
105941: LD_VAR 0 4
105945: PUSH
105946: LD_VAR 0 7
105950: ARRAY
105951: DIFF
105952: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105953: LD_ADDR_VAR 0 31
105957: PUSH
105958: LD_VAR 0 31
105962: PUSH
105963: LD_VAR 0 4
105967: PUSH
105968: LD_VAR 0 7
105972: ARRAY
105973: DIFF
105974: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105975: LD_ADDR_VAR 0 4
105979: PUSH
105980: LD_VAR 0 4
105984: PPUSH
105985: LD_VAR 0 7
105989: PPUSH
105990: CALL_OW 3
105994: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105995: LD_ADDR_VAR 0 16
105999: PUSH
106000: LD_VAR 0 16
106004: PPUSH
106005: LD_VAR 0 7
106009: PPUSH
106010: CALL_OW 3
106014: ST_TO_ADDR
// continue ;
106015: GO 105855
// end ; if f_repair then
106017: LD_VAR 0 22
106021: IFFALSE 106510
// begin if GetType ( group [ i ] ) = unit_vehicle then
106023: LD_VAR 0 4
106027: PUSH
106028: LD_VAR 0 7
106032: ARRAY
106033: PPUSH
106034: CALL_OW 247
106038: PUSH
106039: LD_INT 2
106041: EQUAL
106042: IFFALSE 106232
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106044: LD_VAR 0 4
106048: PUSH
106049: LD_VAR 0 7
106053: ARRAY
106054: PPUSH
106055: CALL_OW 256
106059: PUSH
106060: LD_INT 700
106062: LESS
106063: PUSH
106064: LD_VAR 0 4
106068: PUSH
106069: LD_VAR 0 7
106073: ARRAY
106074: PUSH
106075: LD_VAR 0 32
106079: IN
106080: NOT
106081: AND
106082: IFFALSE 106106
// to_repair := to_repair union group [ i ] ;
106084: LD_ADDR_VAR 0 32
106088: PUSH
106089: LD_VAR 0 32
106093: PUSH
106094: LD_VAR 0 4
106098: PUSH
106099: LD_VAR 0 7
106103: ARRAY
106104: UNION
106105: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106106: LD_VAR 0 4
106110: PUSH
106111: LD_VAR 0 7
106115: ARRAY
106116: PPUSH
106117: CALL_OW 256
106121: PUSH
106122: LD_INT 1000
106124: EQUAL
106125: PUSH
106126: LD_VAR 0 4
106130: PUSH
106131: LD_VAR 0 7
106135: ARRAY
106136: PUSH
106137: LD_VAR 0 32
106141: IN
106142: AND
106143: IFFALSE 106167
// to_repair := to_repair diff group [ i ] ;
106145: LD_ADDR_VAR 0 32
106149: PUSH
106150: LD_VAR 0 32
106154: PUSH
106155: LD_VAR 0 4
106159: PUSH
106160: LD_VAR 0 7
106164: ARRAY
106165: DIFF
106166: ST_TO_ADDR
// if group [ i ] in to_repair then
106167: LD_VAR 0 4
106171: PUSH
106172: LD_VAR 0 7
106176: ARRAY
106177: PUSH
106178: LD_VAR 0 32
106182: IN
106183: IFFALSE 106230
// begin if not IsInArea ( group [ i ] , f_repair ) then
106185: LD_VAR 0 4
106189: PUSH
106190: LD_VAR 0 7
106194: ARRAY
106195: PPUSH
106196: LD_VAR 0 22
106200: PPUSH
106201: CALL_OW 308
106205: NOT
106206: IFFALSE 106228
// ComMoveToArea ( group [ i ] , f_repair ) ;
106208: LD_VAR 0 4
106212: PUSH
106213: LD_VAR 0 7
106217: ARRAY
106218: PPUSH
106219: LD_VAR 0 22
106223: PPUSH
106224: CALL_OW 113
// continue ;
106228: GO 105855
// end ; end else
106230: GO 106510
// if group [ i ] in repairs then
106232: LD_VAR 0 4
106236: PUSH
106237: LD_VAR 0 7
106241: ARRAY
106242: PUSH
106243: LD_VAR 0 33
106247: IN
106248: IFFALSE 106510
// begin if IsInUnit ( group [ i ] ) then
106250: LD_VAR 0 4
106254: PUSH
106255: LD_VAR 0 7
106259: ARRAY
106260: PPUSH
106261: CALL_OW 310
106265: IFFALSE 106333
// begin z := IsInUnit ( group [ i ] ) ;
106267: LD_ADDR_VAR 0 13
106271: PUSH
106272: LD_VAR 0 4
106276: PUSH
106277: LD_VAR 0 7
106281: ARRAY
106282: PPUSH
106283: CALL_OW 310
106287: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106288: LD_VAR 0 13
106292: PUSH
106293: LD_VAR 0 32
106297: IN
106298: PUSH
106299: LD_VAR 0 13
106303: PPUSH
106304: LD_VAR 0 22
106308: PPUSH
106309: CALL_OW 308
106313: AND
106314: IFFALSE 106331
// ComExitVehicle ( group [ i ] ) ;
106316: LD_VAR 0 4
106320: PUSH
106321: LD_VAR 0 7
106325: ARRAY
106326: PPUSH
106327: CALL_OW 121
// end else
106331: GO 106510
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106333: LD_ADDR_VAR 0 13
106337: PUSH
106338: LD_VAR 0 4
106342: PPUSH
106343: LD_INT 95
106345: PUSH
106346: LD_VAR 0 22
106350: PUSH
106351: EMPTY
106352: LIST
106353: LIST
106354: PUSH
106355: LD_INT 58
106357: PUSH
106358: EMPTY
106359: LIST
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: PPUSH
106365: CALL_OW 72
106369: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106370: LD_VAR 0 4
106374: PUSH
106375: LD_VAR 0 7
106379: ARRAY
106380: PPUSH
106381: CALL_OW 314
106385: NOT
106386: IFFALSE 106508
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106388: LD_ADDR_VAR 0 10
106392: PUSH
106393: LD_VAR 0 13
106397: PPUSH
106398: LD_VAR 0 4
106402: PUSH
106403: LD_VAR 0 7
106407: ARRAY
106408: PPUSH
106409: CALL_OW 74
106413: ST_TO_ADDR
// if not x then
106414: LD_VAR 0 10
106418: NOT
106419: IFFALSE 106423
// continue ;
106421: GO 105855
// if GetLives ( x ) < 1000 then
106423: LD_VAR 0 10
106427: PPUSH
106428: CALL_OW 256
106432: PUSH
106433: LD_INT 1000
106435: LESS
106436: IFFALSE 106460
// ComRepairVehicle ( group [ i ] , x ) else
106438: LD_VAR 0 4
106442: PUSH
106443: LD_VAR 0 7
106447: ARRAY
106448: PPUSH
106449: LD_VAR 0 10
106453: PPUSH
106454: CALL_OW 129
106458: GO 106508
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106460: LD_VAR 0 23
106464: PUSH
106465: LD_VAR 0 4
106469: PUSH
106470: LD_VAR 0 7
106474: ARRAY
106475: PPUSH
106476: CALL_OW 256
106480: PUSH
106481: LD_INT 1000
106483: LESS
106484: AND
106485: NOT
106486: IFFALSE 106508
// ComEnterUnit ( group [ i ] , x ) ;
106488: LD_VAR 0 4
106492: PUSH
106493: LD_VAR 0 7
106497: ARRAY
106498: PPUSH
106499: LD_VAR 0 10
106503: PPUSH
106504: CALL_OW 120
// end ; continue ;
106508: GO 105855
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106510: LD_VAR 0 23
106514: PUSH
106515: LD_VAR 0 4
106519: PUSH
106520: LD_VAR 0 7
106524: ARRAY
106525: PPUSH
106526: CALL_OW 247
106530: PUSH
106531: LD_INT 1
106533: EQUAL
106534: AND
106535: IFFALSE 107013
// begin if group [ i ] in healers then
106537: LD_VAR 0 4
106541: PUSH
106542: LD_VAR 0 7
106546: ARRAY
106547: PUSH
106548: LD_VAR 0 31
106552: IN
106553: IFFALSE 106826
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106555: LD_VAR 0 4
106559: PUSH
106560: LD_VAR 0 7
106564: ARRAY
106565: PPUSH
106566: LD_VAR 0 23
106570: PPUSH
106571: CALL_OW 308
106575: NOT
106576: PUSH
106577: LD_VAR 0 4
106581: PUSH
106582: LD_VAR 0 7
106586: ARRAY
106587: PPUSH
106588: CALL_OW 314
106592: NOT
106593: AND
106594: IFFALSE 106618
// ComMoveToArea ( group [ i ] , f_heal ) else
106596: LD_VAR 0 4
106600: PUSH
106601: LD_VAR 0 7
106605: ARRAY
106606: PPUSH
106607: LD_VAR 0 23
106611: PPUSH
106612: CALL_OW 113
106616: GO 106824
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106618: LD_VAR 0 4
106622: PUSH
106623: LD_VAR 0 7
106627: ARRAY
106628: PPUSH
106629: CALL 82474 0 1
106633: PPUSH
106634: CALL_OW 256
106638: PUSH
106639: LD_INT 1000
106641: EQUAL
106642: IFFALSE 106661
// ComStop ( group [ i ] ) else
106644: LD_VAR 0 4
106648: PUSH
106649: LD_VAR 0 7
106653: ARRAY
106654: PPUSH
106655: CALL_OW 141
106659: GO 106824
// if not HasTask ( group [ i ] ) and to_heal then
106661: LD_VAR 0 4
106665: PUSH
106666: LD_VAR 0 7
106670: ARRAY
106671: PPUSH
106672: CALL_OW 314
106676: NOT
106677: PUSH
106678: LD_VAR 0 30
106682: AND
106683: IFFALSE 106824
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106685: LD_ADDR_VAR 0 13
106689: PUSH
106690: LD_VAR 0 30
106694: PPUSH
106695: LD_INT 3
106697: PUSH
106698: LD_INT 54
106700: PUSH
106701: EMPTY
106702: LIST
106703: PUSH
106704: EMPTY
106705: LIST
106706: LIST
106707: PPUSH
106708: CALL_OW 72
106712: PPUSH
106713: LD_VAR 0 4
106717: PUSH
106718: LD_VAR 0 7
106722: ARRAY
106723: PPUSH
106724: CALL_OW 74
106728: ST_TO_ADDR
// if z then
106729: LD_VAR 0 13
106733: IFFALSE 106824
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106735: LD_INT 91
106737: PUSH
106738: LD_VAR 0 13
106742: PUSH
106743: LD_INT 10
106745: PUSH
106746: EMPTY
106747: LIST
106748: LIST
106749: LIST
106750: PUSH
106751: LD_INT 81
106753: PUSH
106754: LD_VAR 0 13
106758: PPUSH
106759: CALL_OW 255
106763: PUSH
106764: EMPTY
106765: LIST
106766: LIST
106767: PUSH
106768: EMPTY
106769: LIST
106770: LIST
106771: PPUSH
106772: CALL_OW 69
106776: PUSH
106777: LD_INT 0
106779: EQUAL
106780: IFFALSE 106804
// ComHeal ( group [ i ] , z ) else
106782: LD_VAR 0 4
106786: PUSH
106787: LD_VAR 0 7
106791: ARRAY
106792: PPUSH
106793: LD_VAR 0 13
106797: PPUSH
106798: CALL_OW 128
106802: GO 106824
// ComMoveToArea ( group [ i ] , f_heal ) ;
106804: LD_VAR 0 4
106808: PUSH
106809: LD_VAR 0 7
106813: ARRAY
106814: PPUSH
106815: LD_VAR 0 23
106819: PPUSH
106820: CALL_OW 113
// end ; continue ;
106824: GO 105855
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106826: LD_VAR 0 4
106830: PUSH
106831: LD_VAR 0 7
106835: ARRAY
106836: PPUSH
106837: CALL_OW 256
106841: PUSH
106842: LD_INT 700
106844: LESS
106845: PUSH
106846: LD_VAR 0 4
106850: PUSH
106851: LD_VAR 0 7
106855: ARRAY
106856: PUSH
106857: LD_VAR 0 30
106861: IN
106862: NOT
106863: AND
106864: IFFALSE 106888
// to_heal := to_heal union group [ i ] ;
106866: LD_ADDR_VAR 0 30
106870: PUSH
106871: LD_VAR 0 30
106875: PUSH
106876: LD_VAR 0 4
106880: PUSH
106881: LD_VAR 0 7
106885: ARRAY
106886: UNION
106887: ST_TO_ADDR
// if group [ i ] in to_heal then
106888: LD_VAR 0 4
106892: PUSH
106893: LD_VAR 0 7
106897: ARRAY
106898: PUSH
106899: LD_VAR 0 30
106903: IN
106904: IFFALSE 107013
// begin if GetLives ( group [ i ] ) = 1000 then
106906: LD_VAR 0 4
106910: PUSH
106911: LD_VAR 0 7
106915: ARRAY
106916: PPUSH
106917: CALL_OW 256
106921: PUSH
106922: LD_INT 1000
106924: EQUAL
106925: IFFALSE 106951
// to_heal := to_heal diff group [ i ] else
106927: LD_ADDR_VAR 0 30
106931: PUSH
106932: LD_VAR 0 30
106936: PUSH
106937: LD_VAR 0 4
106941: PUSH
106942: LD_VAR 0 7
106946: ARRAY
106947: DIFF
106948: ST_TO_ADDR
106949: GO 107013
// begin if not IsInArea ( group [ i ] , to_heal ) then
106951: LD_VAR 0 4
106955: PUSH
106956: LD_VAR 0 7
106960: ARRAY
106961: PPUSH
106962: LD_VAR 0 30
106966: PPUSH
106967: CALL_OW 308
106971: NOT
106972: IFFALSE 106996
// ComMoveToArea ( group [ i ] , f_heal ) else
106974: LD_VAR 0 4
106978: PUSH
106979: LD_VAR 0 7
106983: ARRAY
106984: PPUSH
106985: LD_VAR 0 23
106989: PPUSH
106990: CALL_OW 113
106994: GO 107011
// ComHold ( group [ i ] ) ;
106996: LD_VAR 0 4
107000: PUSH
107001: LD_VAR 0 7
107005: ARRAY
107006: PPUSH
107007: CALL_OW 140
// continue ;
107011: GO 105855
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107013: LD_VAR 0 4
107017: PUSH
107018: LD_VAR 0 7
107022: ARRAY
107023: PPUSH
107024: LD_INT 10
107026: PPUSH
107027: CALL 80894 0 2
107031: NOT
107032: PUSH
107033: LD_VAR 0 16
107037: PUSH
107038: LD_VAR 0 7
107042: ARRAY
107043: PUSH
107044: EMPTY
107045: EQUAL
107046: NOT
107047: AND
107048: IFFALSE 107314
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107050: LD_VAR 0 4
107054: PUSH
107055: LD_VAR 0 7
107059: ARRAY
107060: PPUSH
107061: CALL_OW 262
107065: PUSH
107066: LD_INT 1
107068: PUSH
107069: LD_INT 2
107071: PUSH
107072: EMPTY
107073: LIST
107074: LIST
107075: IN
107076: IFFALSE 107117
// if GetFuel ( group [ i ] ) < 10 then
107078: LD_VAR 0 4
107082: PUSH
107083: LD_VAR 0 7
107087: ARRAY
107088: PPUSH
107089: CALL_OW 261
107093: PUSH
107094: LD_INT 10
107096: LESS
107097: IFFALSE 107117
// SetFuel ( group [ i ] , 12 ) ;
107099: LD_VAR 0 4
107103: PUSH
107104: LD_VAR 0 7
107108: ARRAY
107109: PPUSH
107110: LD_INT 12
107112: PPUSH
107113: CALL_OW 240
// if units_path [ i ] then
107117: LD_VAR 0 16
107121: PUSH
107122: LD_VAR 0 7
107126: ARRAY
107127: IFFALSE 107312
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107129: LD_VAR 0 4
107133: PUSH
107134: LD_VAR 0 7
107138: ARRAY
107139: PPUSH
107140: LD_VAR 0 16
107144: PUSH
107145: LD_VAR 0 7
107149: ARRAY
107150: PUSH
107151: LD_INT 1
107153: ARRAY
107154: PUSH
107155: LD_INT 1
107157: ARRAY
107158: PPUSH
107159: LD_VAR 0 16
107163: PUSH
107164: LD_VAR 0 7
107168: ARRAY
107169: PUSH
107170: LD_INT 1
107172: ARRAY
107173: PUSH
107174: LD_INT 2
107176: ARRAY
107177: PPUSH
107178: CALL_OW 297
107182: PUSH
107183: LD_INT 6
107185: GREATER
107186: IFFALSE 107261
// begin if not HasTask ( group [ i ] ) then
107188: LD_VAR 0 4
107192: PUSH
107193: LD_VAR 0 7
107197: ARRAY
107198: PPUSH
107199: CALL_OW 314
107203: NOT
107204: IFFALSE 107259
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107206: LD_VAR 0 4
107210: PUSH
107211: LD_VAR 0 7
107215: ARRAY
107216: PPUSH
107217: LD_VAR 0 16
107221: PUSH
107222: LD_VAR 0 7
107226: ARRAY
107227: PUSH
107228: LD_INT 1
107230: ARRAY
107231: PUSH
107232: LD_INT 1
107234: ARRAY
107235: PPUSH
107236: LD_VAR 0 16
107240: PUSH
107241: LD_VAR 0 7
107245: ARRAY
107246: PUSH
107247: LD_INT 1
107249: ARRAY
107250: PUSH
107251: LD_INT 2
107253: ARRAY
107254: PPUSH
107255: CALL_OW 114
// end else
107259: GO 107312
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107261: LD_ADDR_VAR 0 15
107265: PUSH
107266: LD_VAR 0 16
107270: PUSH
107271: LD_VAR 0 7
107275: ARRAY
107276: PPUSH
107277: LD_INT 1
107279: PPUSH
107280: CALL_OW 3
107284: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107285: LD_ADDR_VAR 0 16
107289: PUSH
107290: LD_VAR 0 16
107294: PPUSH
107295: LD_VAR 0 7
107299: PPUSH
107300: LD_VAR 0 15
107304: PPUSH
107305: CALL_OW 1
107309: ST_TO_ADDR
// continue ;
107310: GO 105855
// end ; end ; end else
107312: GO 109976
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107314: LD_ADDR_VAR 0 14
107318: PUSH
107319: LD_INT 81
107321: PUSH
107322: LD_VAR 0 4
107326: PUSH
107327: LD_VAR 0 7
107331: ARRAY
107332: PPUSH
107333: CALL_OW 255
107337: PUSH
107338: EMPTY
107339: LIST
107340: LIST
107341: PPUSH
107342: CALL_OW 69
107346: ST_TO_ADDR
// if not tmp then
107347: LD_VAR 0 14
107351: NOT
107352: IFFALSE 107356
// continue ;
107354: GO 105855
// if f_ignore_area then
107356: LD_VAR 0 17
107360: IFFALSE 107448
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107362: LD_ADDR_VAR 0 15
107366: PUSH
107367: LD_VAR 0 14
107371: PPUSH
107372: LD_INT 3
107374: PUSH
107375: LD_INT 92
107377: PUSH
107378: LD_VAR 0 17
107382: PUSH
107383: LD_INT 1
107385: ARRAY
107386: PUSH
107387: LD_VAR 0 17
107391: PUSH
107392: LD_INT 2
107394: ARRAY
107395: PUSH
107396: LD_VAR 0 17
107400: PUSH
107401: LD_INT 3
107403: ARRAY
107404: PUSH
107405: EMPTY
107406: LIST
107407: LIST
107408: LIST
107409: LIST
107410: PUSH
107411: EMPTY
107412: LIST
107413: LIST
107414: PPUSH
107415: CALL_OW 72
107419: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107420: LD_VAR 0 14
107424: PUSH
107425: LD_VAR 0 15
107429: DIFF
107430: IFFALSE 107448
// tmp := tmp diff tmp2 ;
107432: LD_ADDR_VAR 0 14
107436: PUSH
107437: LD_VAR 0 14
107441: PUSH
107442: LD_VAR 0 15
107446: DIFF
107447: ST_TO_ADDR
// end ; if not f_murder then
107448: LD_VAR 0 20
107452: NOT
107453: IFFALSE 107511
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107455: LD_ADDR_VAR 0 15
107459: PUSH
107460: LD_VAR 0 14
107464: PPUSH
107465: LD_INT 3
107467: PUSH
107468: LD_INT 50
107470: PUSH
107471: EMPTY
107472: LIST
107473: PUSH
107474: EMPTY
107475: LIST
107476: LIST
107477: PPUSH
107478: CALL_OW 72
107482: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107483: LD_VAR 0 14
107487: PUSH
107488: LD_VAR 0 15
107492: DIFF
107493: IFFALSE 107511
// tmp := tmp diff tmp2 ;
107495: LD_ADDR_VAR 0 14
107499: PUSH
107500: LD_VAR 0 14
107504: PUSH
107505: LD_VAR 0 15
107509: DIFF
107510: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107511: LD_ADDR_VAR 0 14
107515: PUSH
107516: LD_VAR 0 4
107520: PUSH
107521: LD_VAR 0 7
107525: ARRAY
107526: PPUSH
107527: LD_VAR 0 14
107531: PPUSH
107532: LD_INT 1
107534: PPUSH
107535: LD_INT 1
107537: PPUSH
107538: CALL 53829 0 4
107542: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107543: LD_VAR 0 4
107547: PUSH
107548: LD_VAR 0 7
107552: ARRAY
107553: PPUSH
107554: CALL_OW 257
107558: PUSH
107559: LD_INT 1
107561: EQUAL
107562: IFFALSE 108010
// begin if WantPlant ( group [ i ] ) then
107564: LD_VAR 0 4
107568: PUSH
107569: LD_VAR 0 7
107573: ARRAY
107574: PPUSH
107575: CALL 53330 0 1
107579: IFFALSE 107583
// continue ;
107581: GO 105855
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107583: LD_VAR 0 18
107587: PUSH
107588: LD_VAR 0 4
107592: PUSH
107593: LD_VAR 0 7
107597: ARRAY
107598: PPUSH
107599: CALL_OW 310
107603: NOT
107604: AND
107605: PUSH
107606: LD_VAR 0 14
107610: PUSH
107611: LD_INT 1
107613: ARRAY
107614: PUSH
107615: LD_VAR 0 14
107619: PPUSH
107620: LD_INT 21
107622: PUSH
107623: LD_INT 2
107625: PUSH
107626: EMPTY
107627: LIST
107628: LIST
107629: PUSH
107630: LD_INT 58
107632: PUSH
107633: EMPTY
107634: LIST
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: PPUSH
107640: CALL_OW 72
107644: IN
107645: AND
107646: IFFALSE 107682
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107648: LD_VAR 0 4
107652: PUSH
107653: LD_VAR 0 7
107657: ARRAY
107658: PPUSH
107659: LD_VAR 0 14
107663: PUSH
107664: LD_INT 1
107666: ARRAY
107667: PPUSH
107668: CALL_OW 120
// attacking := true ;
107672: LD_ADDR_VAR 0 29
107676: PUSH
107677: LD_INT 1
107679: ST_TO_ADDR
// continue ;
107680: GO 105855
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107682: LD_VAR 0 26
107686: PUSH
107687: LD_VAR 0 4
107691: PUSH
107692: LD_VAR 0 7
107696: ARRAY
107697: PPUSH
107698: CALL_OW 257
107702: PUSH
107703: LD_INT 1
107705: EQUAL
107706: AND
107707: PUSH
107708: LD_VAR 0 4
107712: PUSH
107713: LD_VAR 0 7
107717: ARRAY
107718: PPUSH
107719: CALL_OW 256
107723: PUSH
107724: LD_INT 800
107726: LESS
107727: AND
107728: PUSH
107729: LD_VAR 0 4
107733: PUSH
107734: LD_VAR 0 7
107738: ARRAY
107739: PPUSH
107740: CALL_OW 318
107744: NOT
107745: AND
107746: IFFALSE 107763
// ComCrawl ( group [ i ] ) ;
107748: LD_VAR 0 4
107752: PUSH
107753: LD_VAR 0 7
107757: ARRAY
107758: PPUSH
107759: CALL_OW 137
// if f_mines then
107763: LD_VAR 0 21
107767: IFFALSE 108010
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107769: LD_VAR 0 14
107773: PUSH
107774: LD_INT 1
107776: ARRAY
107777: PPUSH
107778: CALL_OW 247
107782: PUSH
107783: LD_INT 3
107785: EQUAL
107786: PUSH
107787: LD_VAR 0 14
107791: PUSH
107792: LD_INT 1
107794: ARRAY
107795: PUSH
107796: LD_VAR 0 27
107800: IN
107801: NOT
107802: AND
107803: IFFALSE 108010
// begin x := GetX ( tmp [ 1 ] ) ;
107805: LD_ADDR_VAR 0 10
107809: PUSH
107810: LD_VAR 0 14
107814: PUSH
107815: LD_INT 1
107817: ARRAY
107818: PPUSH
107819: CALL_OW 250
107823: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107824: LD_ADDR_VAR 0 11
107828: PUSH
107829: LD_VAR 0 14
107833: PUSH
107834: LD_INT 1
107836: ARRAY
107837: PPUSH
107838: CALL_OW 251
107842: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107843: LD_ADDR_VAR 0 12
107847: PUSH
107848: LD_VAR 0 4
107852: PUSH
107853: LD_VAR 0 7
107857: ARRAY
107858: PPUSH
107859: CALL 80979 0 1
107863: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107864: LD_VAR 0 4
107868: PUSH
107869: LD_VAR 0 7
107873: ARRAY
107874: PPUSH
107875: LD_VAR 0 10
107879: PPUSH
107880: LD_VAR 0 11
107884: PPUSH
107885: LD_VAR 0 14
107889: PUSH
107890: LD_INT 1
107892: ARRAY
107893: PPUSH
107894: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107898: LD_VAR 0 4
107902: PUSH
107903: LD_VAR 0 7
107907: ARRAY
107908: PPUSH
107909: LD_VAR 0 10
107913: PPUSH
107914: LD_VAR 0 12
107918: PPUSH
107919: LD_INT 7
107921: PPUSH
107922: CALL_OW 272
107926: PPUSH
107927: LD_VAR 0 11
107931: PPUSH
107932: LD_VAR 0 12
107936: PPUSH
107937: LD_INT 7
107939: PPUSH
107940: CALL_OW 273
107944: PPUSH
107945: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107949: LD_VAR 0 4
107953: PUSH
107954: LD_VAR 0 7
107958: ARRAY
107959: PPUSH
107960: LD_INT 71
107962: PPUSH
107963: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107967: LD_ADDR_VAR 0 27
107971: PUSH
107972: LD_VAR 0 27
107976: PPUSH
107977: LD_VAR 0 27
107981: PUSH
107982: LD_INT 1
107984: PLUS
107985: PPUSH
107986: LD_VAR 0 14
107990: PUSH
107991: LD_INT 1
107993: ARRAY
107994: PPUSH
107995: CALL_OW 1
107999: ST_TO_ADDR
// attacking := true ;
108000: LD_ADDR_VAR 0 29
108004: PUSH
108005: LD_INT 1
108007: ST_TO_ADDR
// continue ;
108008: GO 105855
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108010: LD_VAR 0 4
108014: PUSH
108015: LD_VAR 0 7
108019: ARRAY
108020: PPUSH
108021: CALL_OW 257
108025: PUSH
108026: LD_INT 17
108028: EQUAL
108029: PUSH
108030: LD_VAR 0 4
108034: PUSH
108035: LD_VAR 0 7
108039: ARRAY
108040: PPUSH
108041: CALL_OW 110
108045: PUSH
108046: LD_INT 71
108048: EQUAL
108049: NOT
108050: AND
108051: IFFALSE 108197
// begin attacking := false ;
108053: LD_ADDR_VAR 0 29
108057: PUSH
108058: LD_INT 0
108060: ST_TO_ADDR
// k := 5 ;
108061: LD_ADDR_VAR 0 9
108065: PUSH
108066: LD_INT 5
108068: ST_TO_ADDR
// if tmp < k then
108069: LD_VAR 0 14
108073: PUSH
108074: LD_VAR 0 9
108078: LESS
108079: IFFALSE 108091
// k := tmp ;
108081: LD_ADDR_VAR 0 9
108085: PUSH
108086: LD_VAR 0 14
108090: ST_TO_ADDR
// for j = 1 to k do
108091: LD_ADDR_VAR 0 8
108095: PUSH
108096: DOUBLE
108097: LD_INT 1
108099: DEC
108100: ST_TO_ADDR
108101: LD_VAR 0 9
108105: PUSH
108106: FOR_TO
108107: IFFALSE 108195
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108109: LD_VAR 0 14
108113: PUSH
108114: LD_VAR 0 8
108118: ARRAY
108119: PUSH
108120: LD_VAR 0 14
108124: PPUSH
108125: LD_INT 58
108127: PUSH
108128: EMPTY
108129: LIST
108130: PPUSH
108131: CALL_OW 72
108135: IN
108136: NOT
108137: IFFALSE 108193
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108139: LD_VAR 0 4
108143: PUSH
108144: LD_VAR 0 7
108148: ARRAY
108149: PPUSH
108150: LD_VAR 0 14
108154: PUSH
108155: LD_VAR 0 8
108159: ARRAY
108160: PPUSH
108161: CALL_OW 115
// attacking := true ;
108165: LD_ADDR_VAR 0 29
108169: PUSH
108170: LD_INT 1
108172: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108173: LD_VAR 0 4
108177: PUSH
108178: LD_VAR 0 7
108182: ARRAY
108183: PPUSH
108184: LD_INT 71
108186: PPUSH
108187: CALL_OW 109
// continue ;
108191: GO 108106
// end ; end ;
108193: GO 108106
108195: POP
108196: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108197: LD_VAR 0 4
108201: PUSH
108202: LD_VAR 0 7
108206: ARRAY
108207: PPUSH
108208: CALL_OW 257
108212: PUSH
108213: LD_INT 8
108215: EQUAL
108216: PUSH
108217: LD_VAR 0 4
108221: PUSH
108222: LD_VAR 0 7
108226: ARRAY
108227: PPUSH
108228: CALL_OW 264
108232: PUSH
108233: LD_INT 28
108235: PUSH
108236: LD_INT 45
108238: PUSH
108239: LD_INT 7
108241: PUSH
108242: LD_INT 47
108244: PUSH
108245: EMPTY
108246: LIST
108247: LIST
108248: LIST
108249: LIST
108250: IN
108251: OR
108252: IFFALSE 108508
// begin attacking := false ;
108254: LD_ADDR_VAR 0 29
108258: PUSH
108259: LD_INT 0
108261: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108262: LD_VAR 0 14
108266: PUSH
108267: LD_INT 1
108269: ARRAY
108270: PPUSH
108271: CALL_OW 266
108275: PUSH
108276: LD_INT 32
108278: PUSH
108279: LD_INT 31
108281: PUSH
108282: LD_INT 33
108284: PUSH
108285: LD_INT 4
108287: PUSH
108288: LD_INT 5
108290: PUSH
108291: EMPTY
108292: LIST
108293: LIST
108294: LIST
108295: LIST
108296: LIST
108297: IN
108298: IFFALSE 108484
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108300: LD_ADDR_VAR 0 9
108304: PUSH
108305: LD_VAR 0 14
108309: PUSH
108310: LD_INT 1
108312: ARRAY
108313: PPUSH
108314: CALL_OW 266
108318: PPUSH
108319: LD_VAR 0 14
108323: PUSH
108324: LD_INT 1
108326: ARRAY
108327: PPUSH
108328: CALL_OW 250
108332: PPUSH
108333: LD_VAR 0 14
108337: PUSH
108338: LD_INT 1
108340: ARRAY
108341: PPUSH
108342: CALL_OW 251
108346: PPUSH
108347: LD_VAR 0 14
108351: PUSH
108352: LD_INT 1
108354: ARRAY
108355: PPUSH
108356: CALL_OW 254
108360: PPUSH
108361: LD_VAR 0 14
108365: PUSH
108366: LD_INT 1
108368: ARRAY
108369: PPUSH
108370: CALL_OW 248
108374: PPUSH
108375: LD_INT 0
108377: PPUSH
108378: CALL 62349 0 6
108382: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108383: LD_ADDR_VAR 0 8
108387: PUSH
108388: LD_VAR 0 4
108392: PUSH
108393: LD_VAR 0 7
108397: ARRAY
108398: PPUSH
108399: LD_VAR 0 9
108403: PPUSH
108404: CALL 81019 0 2
108408: ST_TO_ADDR
// if j then
108409: LD_VAR 0 8
108413: IFFALSE 108482
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108415: LD_VAR 0 8
108419: PUSH
108420: LD_INT 1
108422: ARRAY
108423: PPUSH
108424: LD_VAR 0 8
108428: PUSH
108429: LD_INT 2
108431: ARRAY
108432: PPUSH
108433: CALL_OW 488
108437: IFFALSE 108482
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108439: LD_VAR 0 4
108443: PUSH
108444: LD_VAR 0 7
108448: ARRAY
108449: PPUSH
108450: LD_VAR 0 8
108454: PUSH
108455: LD_INT 1
108457: ARRAY
108458: PPUSH
108459: LD_VAR 0 8
108463: PUSH
108464: LD_INT 2
108466: ARRAY
108467: PPUSH
108468: CALL_OW 116
// attacking := true ;
108472: LD_ADDR_VAR 0 29
108476: PUSH
108477: LD_INT 1
108479: ST_TO_ADDR
// continue ;
108480: GO 105855
// end ; end else
108482: GO 108508
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108484: LD_VAR 0 4
108488: PUSH
108489: LD_VAR 0 7
108493: ARRAY
108494: PPUSH
108495: LD_VAR 0 14
108499: PUSH
108500: LD_INT 1
108502: ARRAY
108503: PPUSH
108504: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108508: LD_VAR 0 4
108512: PUSH
108513: LD_VAR 0 7
108517: ARRAY
108518: PPUSH
108519: CALL_OW 265
108523: PUSH
108524: LD_INT 11
108526: EQUAL
108527: IFFALSE 108805
// begin k := 10 ;
108529: LD_ADDR_VAR 0 9
108533: PUSH
108534: LD_INT 10
108536: ST_TO_ADDR
// x := 0 ;
108537: LD_ADDR_VAR 0 10
108541: PUSH
108542: LD_INT 0
108544: ST_TO_ADDR
// if tmp < k then
108545: LD_VAR 0 14
108549: PUSH
108550: LD_VAR 0 9
108554: LESS
108555: IFFALSE 108567
// k := tmp ;
108557: LD_ADDR_VAR 0 9
108561: PUSH
108562: LD_VAR 0 14
108566: ST_TO_ADDR
// for j = k downto 1 do
108567: LD_ADDR_VAR 0 8
108571: PUSH
108572: DOUBLE
108573: LD_VAR 0 9
108577: INC
108578: ST_TO_ADDR
108579: LD_INT 1
108581: PUSH
108582: FOR_DOWNTO
108583: IFFALSE 108658
// begin if GetType ( tmp [ j ] ) = unit_human then
108585: LD_VAR 0 14
108589: PUSH
108590: LD_VAR 0 8
108594: ARRAY
108595: PPUSH
108596: CALL_OW 247
108600: PUSH
108601: LD_INT 1
108603: EQUAL
108604: IFFALSE 108656
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108606: LD_VAR 0 4
108610: PUSH
108611: LD_VAR 0 7
108615: ARRAY
108616: PPUSH
108617: LD_VAR 0 14
108621: PUSH
108622: LD_VAR 0 8
108626: ARRAY
108627: PPUSH
108628: CALL 81290 0 2
// x := tmp [ j ] ;
108632: LD_ADDR_VAR 0 10
108636: PUSH
108637: LD_VAR 0 14
108641: PUSH
108642: LD_VAR 0 8
108646: ARRAY
108647: ST_TO_ADDR
// attacking := true ;
108648: LD_ADDR_VAR 0 29
108652: PUSH
108653: LD_INT 1
108655: ST_TO_ADDR
// end ; end ;
108656: GO 108582
108658: POP
108659: POP
// if not x then
108660: LD_VAR 0 10
108664: NOT
108665: IFFALSE 108805
// begin attacking := true ;
108667: LD_ADDR_VAR 0 29
108671: PUSH
108672: LD_INT 1
108674: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108675: LD_VAR 0 4
108679: PUSH
108680: LD_VAR 0 7
108684: ARRAY
108685: PPUSH
108686: CALL_OW 250
108690: PPUSH
108691: LD_VAR 0 4
108695: PUSH
108696: LD_VAR 0 7
108700: ARRAY
108701: PPUSH
108702: CALL_OW 251
108706: PPUSH
108707: CALL_OW 546
108711: PUSH
108712: LD_INT 2
108714: ARRAY
108715: PUSH
108716: LD_VAR 0 14
108720: PUSH
108721: LD_INT 1
108723: ARRAY
108724: PPUSH
108725: CALL_OW 250
108729: PPUSH
108730: LD_VAR 0 14
108734: PUSH
108735: LD_INT 1
108737: ARRAY
108738: PPUSH
108739: CALL_OW 251
108743: PPUSH
108744: CALL_OW 546
108748: PUSH
108749: LD_INT 2
108751: ARRAY
108752: EQUAL
108753: IFFALSE 108781
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108755: LD_VAR 0 4
108759: PUSH
108760: LD_VAR 0 7
108764: ARRAY
108765: PPUSH
108766: LD_VAR 0 14
108770: PUSH
108771: LD_INT 1
108773: ARRAY
108774: PPUSH
108775: CALL 81290 0 2
108779: GO 108805
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108781: LD_VAR 0 4
108785: PUSH
108786: LD_VAR 0 7
108790: ARRAY
108791: PPUSH
108792: LD_VAR 0 14
108796: PUSH
108797: LD_INT 1
108799: ARRAY
108800: PPUSH
108801: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108805: LD_VAR 0 4
108809: PUSH
108810: LD_VAR 0 7
108814: ARRAY
108815: PPUSH
108816: CALL_OW 264
108820: PUSH
108821: LD_INT 29
108823: EQUAL
108824: IFFALSE 109190
// begin if WantsToAttack ( group [ i ] ) in bombed then
108826: LD_VAR 0 4
108830: PUSH
108831: LD_VAR 0 7
108835: ARRAY
108836: PPUSH
108837: CALL_OW 319
108841: PUSH
108842: LD_VAR 0 28
108846: IN
108847: IFFALSE 108851
// continue ;
108849: GO 105855
// k := 8 ;
108851: LD_ADDR_VAR 0 9
108855: PUSH
108856: LD_INT 8
108858: ST_TO_ADDR
// x := 0 ;
108859: LD_ADDR_VAR 0 10
108863: PUSH
108864: LD_INT 0
108866: ST_TO_ADDR
// if tmp < k then
108867: LD_VAR 0 14
108871: PUSH
108872: LD_VAR 0 9
108876: LESS
108877: IFFALSE 108889
// k := tmp ;
108879: LD_ADDR_VAR 0 9
108883: PUSH
108884: LD_VAR 0 14
108888: ST_TO_ADDR
// for j = 1 to k do
108889: LD_ADDR_VAR 0 8
108893: PUSH
108894: DOUBLE
108895: LD_INT 1
108897: DEC
108898: ST_TO_ADDR
108899: LD_VAR 0 9
108903: PUSH
108904: FOR_TO
108905: IFFALSE 109037
// begin if GetType ( tmp [ j ] ) = unit_building then
108907: LD_VAR 0 14
108911: PUSH
108912: LD_VAR 0 8
108916: ARRAY
108917: PPUSH
108918: CALL_OW 247
108922: PUSH
108923: LD_INT 3
108925: EQUAL
108926: IFFALSE 109035
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108928: LD_VAR 0 14
108932: PUSH
108933: LD_VAR 0 8
108937: ARRAY
108938: PUSH
108939: LD_VAR 0 28
108943: IN
108944: NOT
108945: PUSH
108946: LD_VAR 0 14
108950: PUSH
108951: LD_VAR 0 8
108955: ARRAY
108956: PPUSH
108957: CALL_OW 313
108961: AND
108962: IFFALSE 109035
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108964: LD_VAR 0 4
108968: PUSH
108969: LD_VAR 0 7
108973: ARRAY
108974: PPUSH
108975: LD_VAR 0 14
108979: PUSH
108980: LD_VAR 0 8
108984: ARRAY
108985: PPUSH
108986: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108990: LD_ADDR_VAR 0 28
108994: PUSH
108995: LD_VAR 0 28
108999: PPUSH
109000: LD_VAR 0 28
109004: PUSH
109005: LD_INT 1
109007: PLUS
109008: PPUSH
109009: LD_VAR 0 14
109013: PUSH
109014: LD_VAR 0 8
109018: ARRAY
109019: PPUSH
109020: CALL_OW 1
109024: ST_TO_ADDR
// attacking := true ;
109025: LD_ADDR_VAR 0 29
109029: PUSH
109030: LD_INT 1
109032: ST_TO_ADDR
// break ;
109033: GO 109037
// end ; end ;
109035: GO 108904
109037: POP
109038: POP
// if not attacking and f_attack_depot then
109039: LD_VAR 0 29
109043: NOT
109044: PUSH
109045: LD_VAR 0 25
109049: AND
109050: IFFALSE 109145
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109052: LD_ADDR_VAR 0 13
109056: PUSH
109057: LD_VAR 0 14
109061: PPUSH
109062: LD_INT 2
109064: PUSH
109065: LD_INT 30
109067: PUSH
109068: LD_INT 0
109070: PUSH
109071: EMPTY
109072: LIST
109073: LIST
109074: PUSH
109075: LD_INT 30
109077: PUSH
109078: LD_INT 1
109080: PUSH
109081: EMPTY
109082: LIST
109083: LIST
109084: PUSH
109085: EMPTY
109086: LIST
109087: LIST
109088: LIST
109089: PPUSH
109090: CALL_OW 72
109094: ST_TO_ADDR
// if z then
109095: LD_VAR 0 13
109099: IFFALSE 109145
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109101: LD_VAR 0 4
109105: PUSH
109106: LD_VAR 0 7
109110: ARRAY
109111: PPUSH
109112: LD_VAR 0 13
109116: PPUSH
109117: LD_VAR 0 4
109121: PUSH
109122: LD_VAR 0 7
109126: ARRAY
109127: PPUSH
109128: CALL_OW 74
109132: PPUSH
109133: CALL_OW 115
// attacking := true ;
109137: LD_ADDR_VAR 0 29
109141: PUSH
109142: LD_INT 1
109144: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109145: LD_VAR 0 4
109149: PUSH
109150: LD_VAR 0 7
109154: ARRAY
109155: PPUSH
109156: CALL_OW 256
109160: PUSH
109161: LD_INT 500
109163: LESS
109164: IFFALSE 109190
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109166: LD_VAR 0 4
109170: PUSH
109171: LD_VAR 0 7
109175: ARRAY
109176: PPUSH
109177: LD_VAR 0 14
109181: PUSH
109182: LD_INT 1
109184: ARRAY
109185: PPUSH
109186: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109190: LD_VAR 0 4
109194: PUSH
109195: LD_VAR 0 7
109199: ARRAY
109200: PPUSH
109201: CALL_OW 264
109205: PUSH
109206: LD_INT 49
109208: EQUAL
109209: IFFALSE 109330
// begin if not HasTask ( group [ i ] ) then
109211: LD_VAR 0 4
109215: PUSH
109216: LD_VAR 0 7
109220: ARRAY
109221: PPUSH
109222: CALL_OW 314
109226: NOT
109227: IFFALSE 109330
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109229: LD_ADDR_VAR 0 9
109233: PUSH
109234: LD_INT 81
109236: PUSH
109237: LD_VAR 0 4
109241: PUSH
109242: LD_VAR 0 7
109246: ARRAY
109247: PPUSH
109248: CALL_OW 255
109252: PUSH
109253: EMPTY
109254: LIST
109255: LIST
109256: PPUSH
109257: CALL_OW 69
109261: PPUSH
109262: LD_VAR 0 4
109266: PUSH
109267: LD_VAR 0 7
109271: ARRAY
109272: PPUSH
109273: CALL_OW 74
109277: ST_TO_ADDR
// if k then
109278: LD_VAR 0 9
109282: IFFALSE 109330
// if GetDistUnits ( group [ i ] , k ) > 10 then
109284: LD_VAR 0 4
109288: PUSH
109289: LD_VAR 0 7
109293: ARRAY
109294: PPUSH
109295: LD_VAR 0 9
109299: PPUSH
109300: CALL_OW 296
109304: PUSH
109305: LD_INT 10
109307: GREATER
109308: IFFALSE 109330
// ComMoveUnit ( group [ i ] , k ) ;
109310: LD_VAR 0 4
109314: PUSH
109315: LD_VAR 0 7
109319: ARRAY
109320: PPUSH
109321: LD_VAR 0 9
109325: PPUSH
109326: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109330: LD_VAR 0 4
109334: PUSH
109335: LD_VAR 0 7
109339: ARRAY
109340: PPUSH
109341: CALL_OW 256
109345: PUSH
109346: LD_INT 250
109348: LESS
109349: PUSH
109350: LD_VAR 0 4
109354: PUSH
109355: LD_VAR 0 7
109359: ARRAY
109360: PUSH
109361: LD_INT 21
109363: PUSH
109364: LD_INT 2
109366: PUSH
109367: EMPTY
109368: LIST
109369: LIST
109370: PUSH
109371: LD_INT 23
109373: PUSH
109374: LD_INT 2
109376: PUSH
109377: EMPTY
109378: LIST
109379: LIST
109380: PUSH
109381: EMPTY
109382: LIST
109383: LIST
109384: PPUSH
109385: CALL_OW 69
109389: IN
109390: AND
109391: IFFALSE 109516
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109393: LD_ADDR_VAR 0 9
109397: PUSH
109398: LD_OWVAR 3
109402: PUSH
109403: LD_VAR 0 4
109407: PUSH
109408: LD_VAR 0 7
109412: ARRAY
109413: DIFF
109414: PPUSH
109415: LD_VAR 0 4
109419: PUSH
109420: LD_VAR 0 7
109424: ARRAY
109425: PPUSH
109426: CALL_OW 74
109430: ST_TO_ADDR
// if not k then
109431: LD_VAR 0 9
109435: NOT
109436: IFFALSE 109440
// continue ;
109438: GO 105855
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109440: LD_VAR 0 9
109444: PUSH
109445: LD_INT 81
109447: PUSH
109448: LD_VAR 0 4
109452: PUSH
109453: LD_VAR 0 7
109457: ARRAY
109458: PPUSH
109459: CALL_OW 255
109463: PUSH
109464: EMPTY
109465: LIST
109466: LIST
109467: PPUSH
109468: CALL_OW 69
109472: IN
109473: PUSH
109474: LD_VAR 0 9
109478: PPUSH
109479: LD_VAR 0 4
109483: PUSH
109484: LD_VAR 0 7
109488: ARRAY
109489: PPUSH
109490: CALL_OW 296
109494: PUSH
109495: LD_INT 5
109497: LESS
109498: AND
109499: IFFALSE 109516
// ComAutodestruct ( group [ i ] ) ;
109501: LD_VAR 0 4
109505: PUSH
109506: LD_VAR 0 7
109510: ARRAY
109511: PPUSH
109512: CALL 81188 0 1
// end ; if f_attack_depot then
109516: LD_VAR 0 25
109520: IFFALSE 109632
// begin k := 6 ;
109522: LD_ADDR_VAR 0 9
109526: PUSH
109527: LD_INT 6
109529: ST_TO_ADDR
// if tmp < k then
109530: LD_VAR 0 14
109534: PUSH
109535: LD_VAR 0 9
109539: LESS
109540: IFFALSE 109552
// k := tmp ;
109542: LD_ADDR_VAR 0 9
109546: PUSH
109547: LD_VAR 0 14
109551: ST_TO_ADDR
// for j = 1 to k do
109552: LD_ADDR_VAR 0 8
109556: PUSH
109557: DOUBLE
109558: LD_INT 1
109560: DEC
109561: ST_TO_ADDR
109562: LD_VAR 0 9
109566: PUSH
109567: FOR_TO
109568: IFFALSE 109630
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109570: LD_VAR 0 8
109574: PPUSH
109575: CALL_OW 266
109579: PUSH
109580: LD_INT 0
109582: PUSH
109583: LD_INT 1
109585: PUSH
109586: EMPTY
109587: LIST
109588: LIST
109589: IN
109590: IFFALSE 109628
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109592: LD_VAR 0 4
109596: PUSH
109597: LD_VAR 0 7
109601: ARRAY
109602: PPUSH
109603: LD_VAR 0 14
109607: PUSH
109608: LD_VAR 0 8
109612: ARRAY
109613: PPUSH
109614: CALL_OW 115
// attacking := true ;
109618: LD_ADDR_VAR 0 29
109622: PUSH
109623: LD_INT 1
109625: ST_TO_ADDR
// break ;
109626: GO 109630
// end ;
109628: GO 109567
109630: POP
109631: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109632: LD_VAR 0 4
109636: PUSH
109637: LD_VAR 0 7
109641: ARRAY
109642: PPUSH
109643: CALL_OW 302
109647: PUSH
109648: LD_VAR 0 29
109652: NOT
109653: AND
109654: IFFALSE 109976
// begin if GetTag ( group [ i ] ) = 71 then
109656: LD_VAR 0 4
109660: PUSH
109661: LD_VAR 0 7
109665: ARRAY
109666: PPUSH
109667: CALL_OW 110
109671: PUSH
109672: LD_INT 71
109674: EQUAL
109675: IFFALSE 109716
// begin if HasTask ( group [ i ] ) then
109677: LD_VAR 0 4
109681: PUSH
109682: LD_VAR 0 7
109686: ARRAY
109687: PPUSH
109688: CALL_OW 314
109692: IFFALSE 109698
// continue else
109694: GO 105855
109696: GO 109716
// SetTag ( group [ i ] , 0 ) ;
109698: LD_VAR 0 4
109702: PUSH
109703: LD_VAR 0 7
109707: ARRAY
109708: PPUSH
109709: LD_INT 0
109711: PPUSH
109712: CALL_OW 109
// end ; k := 8 ;
109716: LD_ADDR_VAR 0 9
109720: PUSH
109721: LD_INT 8
109723: ST_TO_ADDR
// x := 0 ;
109724: LD_ADDR_VAR 0 10
109728: PUSH
109729: LD_INT 0
109731: ST_TO_ADDR
// if tmp < k then
109732: LD_VAR 0 14
109736: PUSH
109737: LD_VAR 0 9
109741: LESS
109742: IFFALSE 109754
// k := tmp ;
109744: LD_ADDR_VAR 0 9
109748: PUSH
109749: LD_VAR 0 14
109753: ST_TO_ADDR
// for j = 1 to k do
109754: LD_ADDR_VAR 0 8
109758: PUSH
109759: DOUBLE
109760: LD_INT 1
109762: DEC
109763: ST_TO_ADDR
109764: LD_VAR 0 9
109768: PUSH
109769: FOR_TO
109770: IFFALSE 109868
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109772: LD_VAR 0 14
109776: PUSH
109777: LD_VAR 0 8
109781: ARRAY
109782: PPUSH
109783: CALL_OW 247
109787: PUSH
109788: LD_INT 1
109790: EQUAL
109791: PUSH
109792: LD_VAR 0 14
109796: PUSH
109797: LD_VAR 0 8
109801: ARRAY
109802: PPUSH
109803: CALL_OW 256
109807: PUSH
109808: LD_INT 250
109810: LESS
109811: PUSH
109812: LD_VAR 0 20
109816: AND
109817: PUSH
109818: LD_VAR 0 20
109822: NOT
109823: PUSH
109824: LD_VAR 0 14
109828: PUSH
109829: LD_VAR 0 8
109833: ARRAY
109834: PPUSH
109835: CALL_OW 256
109839: PUSH
109840: LD_INT 250
109842: GREATEREQUAL
109843: AND
109844: OR
109845: AND
109846: IFFALSE 109866
// begin x := tmp [ j ] ;
109848: LD_ADDR_VAR 0 10
109852: PUSH
109853: LD_VAR 0 14
109857: PUSH
109858: LD_VAR 0 8
109862: ARRAY
109863: ST_TO_ADDR
// break ;
109864: GO 109868
// end ;
109866: GO 109769
109868: POP
109869: POP
// if x then
109870: LD_VAR 0 10
109874: IFFALSE 109898
// ComAttackUnit ( group [ i ] , x ) else
109876: LD_VAR 0 4
109880: PUSH
109881: LD_VAR 0 7
109885: ARRAY
109886: PPUSH
109887: LD_VAR 0 10
109891: PPUSH
109892: CALL_OW 115
109896: GO 109922
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109898: LD_VAR 0 4
109902: PUSH
109903: LD_VAR 0 7
109907: ARRAY
109908: PPUSH
109909: LD_VAR 0 14
109913: PUSH
109914: LD_INT 1
109916: ARRAY
109917: PPUSH
109918: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109922: LD_VAR 0 4
109926: PUSH
109927: LD_VAR 0 7
109931: ARRAY
109932: PPUSH
109933: CALL_OW 314
109937: NOT
109938: IFFALSE 109976
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109940: LD_VAR 0 4
109944: PUSH
109945: LD_VAR 0 7
109949: ARRAY
109950: PPUSH
109951: LD_VAR 0 14
109955: PPUSH
109956: LD_VAR 0 4
109960: PUSH
109961: LD_VAR 0 7
109965: ARRAY
109966: PPUSH
109967: CALL_OW 74
109971: PPUSH
109972: CALL_OW 115
// end ; end ; end ;
109976: GO 105855
109978: POP
109979: POP
// wait ( 0 0$2 ) ;
109980: LD_INT 70
109982: PPUSH
109983: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109987: LD_VAR 0 4
109991: NOT
109992: PUSH
109993: LD_VAR 0 4
109997: PUSH
109998: EMPTY
109999: EQUAL
110000: OR
110001: PUSH
110002: LD_INT 81
110004: PUSH
110005: LD_VAR 0 35
110009: PUSH
110010: EMPTY
110011: LIST
110012: LIST
110013: PPUSH
110014: CALL_OW 69
110018: NOT
110019: OR
110020: IFFALSE 105840
// end ;
110022: LD_VAR 0 2
110026: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
110027: LD_INT 0
110029: PPUSH
110030: PPUSH
110031: PPUSH
110032: PPUSH
110033: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110034: LD_VAR 0 1
110038: NOT
110039: PUSH
110040: LD_EXP 50
110044: PUSH
110045: LD_VAR 0 1
110049: ARRAY
110050: NOT
110051: OR
110052: PUSH
110053: LD_VAR 0 2
110057: NOT
110058: OR
110059: IFFALSE 110063
// exit ;
110061: GO 110592
// side := mc_sides [ base ] ;
110063: LD_ADDR_VAR 0 5
110067: PUSH
110068: LD_EXP 76
110072: PUSH
110073: LD_VAR 0 1
110077: ARRAY
110078: ST_TO_ADDR
// if not side then
110079: LD_VAR 0 5
110083: NOT
110084: IFFALSE 110088
// exit ;
110086: GO 110592
// for i in solds do
110088: LD_ADDR_VAR 0 6
110092: PUSH
110093: LD_VAR 0 2
110097: PUSH
110098: FOR_IN
110099: IFFALSE 110160
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110101: LD_VAR 0 6
110105: PPUSH
110106: CALL_OW 310
110110: PPUSH
110111: CALL_OW 266
110115: PUSH
110116: LD_INT 32
110118: PUSH
110119: LD_INT 31
110121: PUSH
110122: EMPTY
110123: LIST
110124: LIST
110125: IN
110126: IFFALSE 110146
// solds := solds diff i else
110128: LD_ADDR_VAR 0 2
110132: PUSH
110133: LD_VAR 0 2
110137: PUSH
110138: LD_VAR 0 6
110142: DIFF
110143: ST_TO_ADDR
110144: GO 110158
// SetTag ( i , 18 ) ;
110146: LD_VAR 0 6
110150: PPUSH
110151: LD_INT 18
110153: PPUSH
110154: CALL_OW 109
110158: GO 110098
110160: POP
110161: POP
// if not solds then
110162: LD_VAR 0 2
110166: NOT
110167: IFFALSE 110171
// exit ;
110169: GO 110592
// repeat wait ( 0 0$2 ) ;
110171: LD_INT 70
110173: PPUSH
110174: CALL_OW 67
// enemy := mc_scan [ base ] ;
110178: LD_ADDR_VAR 0 4
110182: PUSH
110183: LD_EXP 73
110187: PUSH
110188: LD_VAR 0 1
110192: ARRAY
110193: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110194: LD_EXP 50
110198: PUSH
110199: LD_VAR 0 1
110203: ARRAY
110204: NOT
110205: PUSH
110206: LD_EXP 50
110210: PUSH
110211: LD_VAR 0 1
110215: ARRAY
110216: PUSH
110217: EMPTY
110218: EQUAL
110219: OR
110220: IFFALSE 110257
// begin for i in solds do
110222: LD_ADDR_VAR 0 6
110226: PUSH
110227: LD_VAR 0 2
110231: PUSH
110232: FOR_IN
110233: IFFALSE 110246
// ComStop ( i ) ;
110235: LD_VAR 0 6
110239: PPUSH
110240: CALL_OW 141
110244: GO 110232
110246: POP
110247: POP
// solds := [ ] ;
110248: LD_ADDR_VAR 0 2
110252: PUSH
110253: EMPTY
110254: ST_TO_ADDR
// exit ;
110255: GO 110592
// end ; for i in solds do
110257: LD_ADDR_VAR 0 6
110261: PUSH
110262: LD_VAR 0 2
110266: PUSH
110267: FOR_IN
110268: IFFALSE 110564
// begin if IsInUnit ( i ) then
110270: LD_VAR 0 6
110274: PPUSH
110275: CALL_OW 310
110279: IFFALSE 110290
// ComExitBuilding ( i ) ;
110281: LD_VAR 0 6
110285: PPUSH
110286: CALL_OW 122
// if GetLives ( i ) > 333 then
110290: LD_VAR 0 6
110294: PPUSH
110295: CALL_OW 256
110299: PUSH
110300: LD_INT 333
110302: GREATER
110303: IFFALSE 110331
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110305: LD_VAR 0 6
110309: PPUSH
110310: LD_VAR 0 4
110314: PPUSH
110315: LD_VAR 0 6
110319: PPUSH
110320: CALL_OW 74
110324: PPUSH
110325: CALL_OW 115
110329: GO 110562
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110331: LD_VAR 0 6
110335: PPUSH
110336: LD_EXP 50
110340: PUSH
110341: LD_VAR 0 1
110345: ARRAY
110346: PPUSH
110347: LD_INT 2
110349: PUSH
110350: LD_INT 30
110352: PUSH
110353: LD_INT 0
110355: PUSH
110356: EMPTY
110357: LIST
110358: LIST
110359: PUSH
110360: LD_INT 30
110362: PUSH
110363: LD_INT 1
110365: PUSH
110366: EMPTY
110367: LIST
110368: LIST
110369: PUSH
110370: LD_INT 30
110372: PUSH
110373: LD_INT 6
110375: PUSH
110376: EMPTY
110377: LIST
110378: LIST
110379: PUSH
110380: EMPTY
110381: LIST
110382: LIST
110383: LIST
110384: LIST
110385: PPUSH
110386: CALL_OW 72
110390: PPUSH
110391: LD_VAR 0 6
110395: PPUSH
110396: CALL_OW 74
110400: PPUSH
110401: CALL_OW 296
110405: PUSH
110406: LD_INT 10
110408: GREATER
110409: IFFALSE 110562
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110411: LD_ADDR_VAR 0 7
110415: PUSH
110416: LD_EXP 50
110420: PUSH
110421: LD_VAR 0 1
110425: ARRAY
110426: PPUSH
110427: LD_INT 2
110429: PUSH
110430: LD_INT 30
110432: PUSH
110433: LD_INT 0
110435: PUSH
110436: EMPTY
110437: LIST
110438: LIST
110439: PUSH
110440: LD_INT 30
110442: PUSH
110443: LD_INT 1
110445: PUSH
110446: EMPTY
110447: LIST
110448: LIST
110449: PUSH
110450: LD_INT 30
110452: PUSH
110453: LD_INT 6
110455: PUSH
110456: EMPTY
110457: LIST
110458: LIST
110459: PUSH
110460: EMPTY
110461: LIST
110462: LIST
110463: LIST
110464: LIST
110465: PPUSH
110466: CALL_OW 72
110470: PPUSH
110471: LD_VAR 0 6
110475: PPUSH
110476: CALL_OW 74
110480: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110481: LD_VAR 0 6
110485: PPUSH
110486: LD_VAR 0 7
110490: PPUSH
110491: CALL_OW 250
110495: PPUSH
110496: LD_INT 3
110498: PPUSH
110499: LD_INT 5
110501: PPUSH
110502: CALL_OW 272
110506: PPUSH
110507: LD_VAR 0 7
110511: PPUSH
110512: CALL_OW 251
110516: PPUSH
110517: LD_INT 3
110519: PPUSH
110520: LD_INT 5
110522: PPUSH
110523: CALL_OW 273
110527: PPUSH
110528: CALL_OW 111
// SetTag ( i , 0 ) ;
110532: LD_VAR 0 6
110536: PPUSH
110537: LD_INT 0
110539: PPUSH
110540: CALL_OW 109
// solds := solds diff i ;
110544: LD_ADDR_VAR 0 2
110548: PUSH
110549: LD_VAR 0 2
110553: PUSH
110554: LD_VAR 0 6
110558: DIFF
110559: ST_TO_ADDR
// continue ;
110560: GO 110267
// end ; end ;
110562: GO 110267
110564: POP
110565: POP
// until not solds or not enemy ;
110566: LD_VAR 0 2
110570: NOT
110571: PUSH
110572: LD_VAR 0 4
110576: NOT
110577: OR
110578: IFFALSE 110171
// MC_Reset ( base , 18 ) ;
110580: LD_VAR 0 1
110584: PPUSH
110585: LD_INT 18
110587: PPUSH
110588: CALL 22083 0 2
// end ;
110592: LD_VAR 0 3
110596: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
110597: LD_INT 0
110599: PPUSH
110600: PPUSH
110601: PPUSH
110602: PPUSH
110603: PPUSH
110604: PPUSH
110605: PPUSH
110606: PPUSH
110607: PPUSH
110608: PPUSH
110609: PPUSH
110610: PPUSH
110611: PPUSH
110612: PPUSH
110613: PPUSH
110614: PPUSH
110615: PPUSH
110616: PPUSH
110617: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110618: LD_ADDR_VAR 0 12
110622: PUSH
110623: LD_EXP 50
110627: PUSH
110628: LD_VAR 0 1
110632: ARRAY
110633: PPUSH
110634: LD_INT 25
110636: PUSH
110637: LD_INT 3
110639: PUSH
110640: EMPTY
110641: LIST
110642: LIST
110643: PPUSH
110644: CALL_OW 72
110648: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110649: LD_EXP 90
110653: PUSH
110654: LD_VAR 0 1
110658: ARRAY
110659: IFFALSE 110683
// mechs := mechs diff mc_remote_driver [ base ] ;
110661: LD_ADDR_VAR 0 12
110665: PUSH
110666: LD_VAR 0 12
110670: PUSH
110671: LD_EXP 90
110675: PUSH
110676: LD_VAR 0 1
110680: ARRAY
110681: DIFF
110682: ST_TO_ADDR
// for i in mechs do
110683: LD_ADDR_VAR 0 4
110687: PUSH
110688: LD_VAR 0 12
110692: PUSH
110693: FOR_IN
110694: IFFALSE 110729
// if GetTag ( i ) > 0 then
110696: LD_VAR 0 4
110700: PPUSH
110701: CALL_OW 110
110705: PUSH
110706: LD_INT 0
110708: GREATER
110709: IFFALSE 110727
// mechs := mechs diff i ;
110711: LD_ADDR_VAR 0 12
110715: PUSH
110716: LD_VAR 0 12
110720: PUSH
110721: LD_VAR 0 4
110725: DIFF
110726: ST_TO_ADDR
110727: GO 110693
110729: POP
110730: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110731: LD_ADDR_VAR 0 8
110735: PUSH
110736: LD_EXP 50
110740: PUSH
110741: LD_VAR 0 1
110745: ARRAY
110746: PPUSH
110747: LD_INT 2
110749: PUSH
110750: LD_INT 25
110752: PUSH
110753: LD_INT 1
110755: PUSH
110756: EMPTY
110757: LIST
110758: LIST
110759: PUSH
110760: LD_INT 25
110762: PUSH
110763: LD_INT 5
110765: PUSH
110766: EMPTY
110767: LIST
110768: LIST
110769: PUSH
110770: LD_INT 25
110772: PUSH
110773: LD_INT 8
110775: PUSH
110776: EMPTY
110777: LIST
110778: LIST
110779: PUSH
110780: LD_INT 25
110782: PUSH
110783: LD_INT 9
110785: PUSH
110786: EMPTY
110787: LIST
110788: LIST
110789: PUSH
110790: EMPTY
110791: LIST
110792: LIST
110793: LIST
110794: LIST
110795: LIST
110796: PPUSH
110797: CALL_OW 72
110801: ST_TO_ADDR
// if not defenders and not solds then
110802: LD_VAR 0 2
110806: NOT
110807: PUSH
110808: LD_VAR 0 8
110812: NOT
110813: AND
110814: IFFALSE 110818
// exit ;
110816: GO 112588
// depot_under_attack := false ;
110818: LD_ADDR_VAR 0 16
110822: PUSH
110823: LD_INT 0
110825: ST_TO_ADDR
// sold_defenders := [ ] ;
110826: LD_ADDR_VAR 0 17
110830: PUSH
110831: EMPTY
110832: ST_TO_ADDR
// if mechs then
110833: LD_VAR 0 12
110837: IFFALSE 110990
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110839: LD_ADDR_VAR 0 4
110843: PUSH
110844: LD_VAR 0 2
110848: PPUSH
110849: LD_INT 21
110851: PUSH
110852: LD_INT 2
110854: PUSH
110855: EMPTY
110856: LIST
110857: LIST
110858: PPUSH
110859: CALL_OW 72
110863: PUSH
110864: FOR_IN
110865: IFFALSE 110988
// begin if GetTag ( i ) <> 20 then
110867: LD_VAR 0 4
110871: PPUSH
110872: CALL_OW 110
110876: PUSH
110877: LD_INT 20
110879: NONEQUAL
110880: IFFALSE 110894
// SetTag ( i , 20 ) ;
110882: LD_VAR 0 4
110886: PPUSH
110887: LD_INT 20
110889: PPUSH
110890: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110894: LD_VAR 0 4
110898: PPUSH
110899: CALL_OW 263
110903: PUSH
110904: LD_INT 1
110906: EQUAL
110907: PUSH
110908: LD_VAR 0 4
110912: PPUSH
110913: CALL_OW 311
110917: NOT
110918: AND
110919: IFFALSE 110986
// begin un := mechs [ 1 ] ;
110921: LD_ADDR_VAR 0 10
110925: PUSH
110926: LD_VAR 0 12
110930: PUSH
110931: LD_INT 1
110933: ARRAY
110934: ST_TO_ADDR
// ComExit ( un ) ;
110935: LD_VAR 0 10
110939: PPUSH
110940: CALL 85533 0 1
// AddComEnterUnit ( un , i ) ;
110944: LD_VAR 0 10
110948: PPUSH
110949: LD_VAR 0 4
110953: PPUSH
110954: CALL_OW 180
// SetTag ( un , 19 ) ;
110958: LD_VAR 0 10
110962: PPUSH
110963: LD_INT 19
110965: PPUSH
110966: CALL_OW 109
// mechs := mechs diff un ;
110970: LD_ADDR_VAR 0 12
110974: PUSH
110975: LD_VAR 0 12
110979: PUSH
110980: LD_VAR 0 10
110984: DIFF
110985: ST_TO_ADDR
// end ; end ;
110986: GO 110864
110988: POP
110989: POP
// if solds then
110990: LD_VAR 0 8
110994: IFFALSE 111053
// for i in solds do
110996: LD_ADDR_VAR 0 4
111000: PUSH
111001: LD_VAR 0 8
111005: PUSH
111006: FOR_IN
111007: IFFALSE 111051
// if not GetTag ( i ) then
111009: LD_VAR 0 4
111013: PPUSH
111014: CALL_OW 110
111018: NOT
111019: IFFALSE 111049
// begin defenders := defenders union i ;
111021: LD_ADDR_VAR 0 2
111025: PUSH
111026: LD_VAR 0 2
111030: PUSH
111031: LD_VAR 0 4
111035: UNION
111036: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111037: LD_VAR 0 4
111041: PPUSH
111042: LD_INT 18
111044: PPUSH
111045: CALL_OW 109
// end ;
111049: GO 111006
111051: POP
111052: POP
// repeat wait ( 0 0$2 ) ;
111053: LD_INT 70
111055: PPUSH
111056: CALL_OW 67
// enemy := mc_scan [ base ] ;
111060: LD_ADDR_VAR 0 21
111064: PUSH
111065: LD_EXP 73
111069: PUSH
111070: LD_VAR 0 1
111074: ARRAY
111075: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111076: LD_EXP 50
111080: PUSH
111081: LD_VAR 0 1
111085: ARRAY
111086: NOT
111087: PUSH
111088: LD_EXP 50
111092: PUSH
111093: LD_VAR 0 1
111097: ARRAY
111098: PUSH
111099: EMPTY
111100: EQUAL
111101: OR
111102: IFFALSE 111139
// begin for i in defenders do
111104: LD_ADDR_VAR 0 4
111108: PUSH
111109: LD_VAR 0 2
111113: PUSH
111114: FOR_IN
111115: IFFALSE 111128
// ComStop ( i ) ;
111117: LD_VAR 0 4
111121: PPUSH
111122: CALL_OW 141
111126: GO 111114
111128: POP
111129: POP
// defenders := [ ] ;
111130: LD_ADDR_VAR 0 2
111134: PUSH
111135: EMPTY
111136: ST_TO_ADDR
// exit ;
111137: GO 112588
// end ; for i in defenders do
111139: LD_ADDR_VAR 0 4
111143: PUSH
111144: LD_VAR 0 2
111148: PUSH
111149: FOR_IN
111150: IFFALSE 112048
// begin e := NearestUnitToUnit ( enemy , i ) ;
111152: LD_ADDR_VAR 0 13
111156: PUSH
111157: LD_VAR 0 21
111161: PPUSH
111162: LD_VAR 0 4
111166: PPUSH
111167: CALL_OW 74
111171: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111172: LD_ADDR_VAR 0 7
111176: PUSH
111177: LD_EXP 50
111181: PUSH
111182: LD_VAR 0 1
111186: ARRAY
111187: PPUSH
111188: LD_INT 2
111190: PUSH
111191: LD_INT 30
111193: PUSH
111194: LD_INT 0
111196: PUSH
111197: EMPTY
111198: LIST
111199: LIST
111200: PUSH
111201: LD_INT 30
111203: PUSH
111204: LD_INT 1
111206: PUSH
111207: EMPTY
111208: LIST
111209: LIST
111210: PUSH
111211: EMPTY
111212: LIST
111213: LIST
111214: LIST
111215: PPUSH
111216: CALL_OW 72
111220: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111221: LD_ADDR_VAR 0 16
111225: PUSH
111226: LD_VAR 0 7
111230: NOT
111231: PUSH
111232: LD_VAR 0 7
111236: PPUSH
111237: LD_INT 3
111239: PUSH
111240: LD_INT 24
111242: PUSH
111243: LD_INT 600
111245: PUSH
111246: EMPTY
111247: LIST
111248: LIST
111249: PUSH
111250: EMPTY
111251: LIST
111252: LIST
111253: PPUSH
111254: CALL_OW 72
111258: OR
111259: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111260: LD_VAR 0 4
111264: PPUSH
111265: CALL_OW 247
111269: PUSH
111270: LD_INT 2
111272: DOUBLE
111273: EQUAL
111274: IFTRUE 111278
111276: GO 111674
111278: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111279: LD_VAR 0 4
111283: PPUSH
111284: CALL_OW 256
111288: PUSH
111289: LD_INT 1000
111291: EQUAL
111292: PUSH
111293: LD_VAR 0 4
111297: PPUSH
111298: LD_VAR 0 13
111302: PPUSH
111303: CALL_OW 296
111307: PUSH
111308: LD_INT 40
111310: LESS
111311: PUSH
111312: LD_VAR 0 13
111316: PPUSH
111317: LD_EXP 75
111321: PUSH
111322: LD_VAR 0 1
111326: ARRAY
111327: PPUSH
111328: CALL_OW 308
111332: OR
111333: AND
111334: IFFALSE 111456
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111336: LD_VAR 0 4
111340: PPUSH
111341: CALL_OW 262
111345: PUSH
111346: LD_INT 1
111348: EQUAL
111349: PUSH
111350: LD_VAR 0 4
111354: PPUSH
111355: CALL_OW 261
111359: PUSH
111360: LD_INT 30
111362: LESS
111363: AND
111364: PUSH
111365: LD_VAR 0 7
111369: AND
111370: IFFALSE 111440
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111372: LD_VAR 0 4
111376: PPUSH
111377: LD_VAR 0 7
111381: PPUSH
111382: LD_VAR 0 4
111386: PPUSH
111387: CALL_OW 74
111391: PPUSH
111392: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111396: LD_VAR 0 4
111400: PPUSH
111401: LD_VAR 0 7
111405: PPUSH
111406: LD_VAR 0 4
111410: PPUSH
111411: CALL_OW 74
111415: PPUSH
111416: CALL_OW 296
111420: PUSH
111421: LD_INT 6
111423: LESS
111424: IFFALSE 111438
// SetFuel ( i , 100 ) ;
111426: LD_VAR 0 4
111430: PPUSH
111431: LD_INT 100
111433: PPUSH
111434: CALL_OW 240
// end else
111438: GO 111454
// ComAttackUnit ( i , e ) ;
111440: LD_VAR 0 4
111444: PPUSH
111445: LD_VAR 0 13
111449: PPUSH
111450: CALL_OW 115
// end else
111454: GO 111557
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111456: LD_VAR 0 13
111460: PPUSH
111461: LD_EXP 75
111465: PUSH
111466: LD_VAR 0 1
111470: ARRAY
111471: PPUSH
111472: CALL_OW 308
111476: NOT
111477: PUSH
111478: LD_VAR 0 4
111482: PPUSH
111483: LD_VAR 0 13
111487: PPUSH
111488: CALL_OW 296
111492: PUSH
111493: LD_INT 40
111495: GREATEREQUAL
111496: AND
111497: PUSH
111498: LD_VAR 0 4
111502: PPUSH
111503: CALL_OW 256
111507: PUSH
111508: LD_INT 650
111510: LESSEQUAL
111511: OR
111512: PUSH
111513: LD_VAR 0 4
111517: PPUSH
111518: LD_EXP 74
111522: PUSH
111523: LD_VAR 0 1
111527: ARRAY
111528: PPUSH
111529: CALL_OW 308
111533: NOT
111534: AND
111535: IFFALSE 111557
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111537: LD_VAR 0 4
111541: PPUSH
111542: LD_EXP 74
111546: PUSH
111547: LD_VAR 0 1
111551: ARRAY
111552: PPUSH
111553: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111557: LD_VAR 0 4
111561: PPUSH
111562: CALL_OW 256
111566: PUSH
111567: LD_INT 1000
111569: LESS
111570: PUSH
111571: LD_VAR 0 4
111575: PPUSH
111576: CALL_OW 263
111580: PUSH
111581: LD_INT 1
111583: EQUAL
111584: AND
111585: PUSH
111586: LD_VAR 0 4
111590: PPUSH
111591: CALL_OW 311
111595: AND
111596: PUSH
111597: LD_VAR 0 4
111601: PPUSH
111602: LD_EXP 74
111606: PUSH
111607: LD_VAR 0 1
111611: ARRAY
111612: PPUSH
111613: CALL_OW 308
111617: AND
111618: IFFALSE 111672
// begin mech := IsDrivenBy ( i ) ;
111620: LD_ADDR_VAR 0 9
111624: PUSH
111625: LD_VAR 0 4
111629: PPUSH
111630: CALL_OW 311
111634: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111635: LD_VAR 0 9
111639: PPUSH
111640: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111644: LD_VAR 0 9
111648: PPUSH
111649: LD_VAR 0 4
111653: PPUSH
111654: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111658: LD_VAR 0 9
111662: PPUSH
111663: LD_VAR 0 4
111667: PPUSH
111668: CALL_OW 180
// end ; end ; unit_human :
111672: GO 112019
111674: LD_INT 1
111676: DOUBLE
111677: EQUAL
111678: IFTRUE 111682
111680: GO 112018
111682: POP
// begin b := IsInUnit ( i ) ;
111683: LD_ADDR_VAR 0 18
111687: PUSH
111688: LD_VAR 0 4
111692: PPUSH
111693: CALL_OW 310
111697: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111698: LD_ADDR_VAR 0 19
111702: PUSH
111703: LD_VAR 0 18
111707: NOT
111708: PUSH
111709: LD_VAR 0 18
111713: PPUSH
111714: CALL_OW 266
111718: PUSH
111719: LD_INT 32
111721: PUSH
111722: LD_INT 31
111724: PUSH
111725: EMPTY
111726: LIST
111727: LIST
111728: IN
111729: OR
111730: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
111731: LD_VAR 0 18
111735: PPUSH
111736: CALL_OW 266
111740: PUSH
111741: LD_INT 5
111743: EQUAL
111744: PUSH
111745: LD_VAR 0 4
111749: PPUSH
111750: CALL_OW 257
111754: PUSH
111755: LD_INT 1
111757: PUSH
111758: LD_INT 2
111760: PUSH
111761: LD_INT 3
111763: PUSH
111764: LD_INT 4
111766: PUSH
111767: EMPTY
111768: LIST
111769: LIST
111770: LIST
111771: LIST
111772: IN
111773: AND
111774: IFFALSE 111811
// begin class := AllowSpecClass ( i ) ;
111776: LD_ADDR_VAR 0 20
111780: PUSH
111781: LD_VAR 0 4
111785: PPUSH
111786: CALL 50194 0 1
111790: ST_TO_ADDR
// if class then
111791: LD_VAR 0 20
111795: IFFALSE 111811
// ComChangeProfession ( i , class ) ;
111797: LD_VAR 0 4
111801: PPUSH
111802: LD_VAR 0 20
111806: PPUSH
111807: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111811: LD_VAR 0 16
111815: PUSH
111816: LD_VAR 0 2
111820: PPUSH
111821: LD_INT 21
111823: PUSH
111824: LD_INT 2
111826: PUSH
111827: EMPTY
111828: LIST
111829: LIST
111830: PPUSH
111831: CALL_OW 72
111835: PUSH
111836: LD_INT 1
111838: LESSEQUAL
111839: OR
111840: PUSH
111841: LD_VAR 0 19
111845: AND
111846: PUSH
111847: LD_VAR 0 4
111851: PUSH
111852: LD_VAR 0 17
111856: IN
111857: NOT
111858: AND
111859: IFFALSE 111952
// begin if b then
111861: LD_VAR 0 18
111865: IFFALSE 111914
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111867: LD_VAR 0 18
111871: PPUSH
111872: LD_VAR 0 21
111876: PPUSH
111877: LD_VAR 0 18
111881: PPUSH
111882: CALL_OW 74
111886: PPUSH
111887: CALL_OW 296
111891: PUSH
111892: LD_INT 10
111894: LESS
111895: PUSH
111896: LD_VAR 0 18
111900: PPUSH
111901: CALL_OW 461
111905: PUSH
111906: LD_INT 7
111908: NONEQUAL
111909: AND
111910: IFFALSE 111914
// continue ;
111912: GO 111149
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111914: LD_ADDR_VAR 0 17
111918: PUSH
111919: LD_VAR 0 17
111923: PPUSH
111924: LD_VAR 0 17
111928: PUSH
111929: LD_INT 1
111931: PLUS
111932: PPUSH
111933: LD_VAR 0 4
111937: PPUSH
111938: CALL_OW 1
111942: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111943: LD_VAR 0 4
111947: PPUSH
111948: CALL_OW 122
// end ; if sold_defenders then
111952: LD_VAR 0 17
111956: IFFALSE 112016
// if i in sold_defenders then
111958: LD_VAR 0 4
111962: PUSH
111963: LD_VAR 0 17
111967: IN
111968: IFFALSE 112016
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111970: LD_VAR 0 4
111974: PPUSH
111975: CALL_OW 314
111979: NOT
111980: PUSH
111981: LD_VAR 0 4
111985: PPUSH
111986: LD_VAR 0 13
111990: PPUSH
111991: CALL_OW 296
111995: PUSH
111996: LD_INT 30
111998: LESS
111999: AND
112000: IFFALSE 112016
// ComAttackUnit ( i , e ) ;
112002: LD_VAR 0 4
112006: PPUSH
112007: LD_VAR 0 13
112011: PPUSH
112012: CALL_OW 115
// end ; end ; end ;
112016: GO 112019
112018: POP
// if IsDead ( i ) then
112019: LD_VAR 0 4
112023: PPUSH
112024: CALL_OW 301
112028: IFFALSE 112046
// defenders := defenders diff i ;
112030: LD_ADDR_VAR 0 2
112034: PUSH
112035: LD_VAR 0 2
112039: PUSH
112040: LD_VAR 0 4
112044: DIFF
112045: ST_TO_ADDR
// end ;
112046: GO 111149
112048: POP
112049: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112050: LD_VAR 0 21
112054: NOT
112055: PUSH
112056: LD_VAR 0 2
112060: NOT
112061: OR
112062: PUSH
112063: LD_EXP 50
112067: PUSH
112068: LD_VAR 0 1
112072: ARRAY
112073: NOT
112074: OR
112075: IFFALSE 111053
// MC_Reset ( base , 18 ) ;
112077: LD_VAR 0 1
112081: PPUSH
112082: LD_INT 18
112084: PPUSH
112085: CALL 22083 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112089: LD_ADDR_VAR 0 2
112093: PUSH
112094: LD_VAR 0 2
112098: PUSH
112099: LD_VAR 0 2
112103: PPUSH
112104: LD_INT 2
112106: PUSH
112107: LD_INT 25
112109: PUSH
112110: LD_INT 1
112112: PUSH
112113: EMPTY
112114: LIST
112115: LIST
112116: PUSH
112117: LD_INT 25
112119: PUSH
112120: LD_INT 5
112122: PUSH
112123: EMPTY
112124: LIST
112125: LIST
112126: PUSH
112127: LD_INT 25
112129: PUSH
112130: LD_INT 8
112132: PUSH
112133: EMPTY
112134: LIST
112135: LIST
112136: PUSH
112137: LD_INT 25
112139: PUSH
112140: LD_INT 9
112142: PUSH
112143: EMPTY
112144: LIST
112145: LIST
112146: PUSH
112147: EMPTY
112148: LIST
112149: LIST
112150: LIST
112151: LIST
112152: LIST
112153: PPUSH
112154: CALL_OW 72
112158: DIFF
112159: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112160: LD_VAR 0 21
112164: NOT
112165: PUSH
112166: LD_VAR 0 2
112170: PPUSH
112171: LD_INT 21
112173: PUSH
112174: LD_INT 2
112176: PUSH
112177: EMPTY
112178: LIST
112179: LIST
112180: PPUSH
112181: CALL_OW 72
112185: AND
112186: IFFALSE 112524
// begin tmp := FilterByTag ( defenders , 19 ) ;
112188: LD_ADDR_VAR 0 11
112192: PUSH
112193: LD_VAR 0 2
112197: PPUSH
112198: LD_INT 19
112200: PPUSH
112201: CALL 82663 0 2
112205: ST_TO_ADDR
// if tmp then
112206: LD_VAR 0 11
112210: IFFALSE 112280
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112212: LD_ADDR_VAR 0 11
112216: PUSH
112217: LD_VAR 0 11
112221: PPUSH
112222: LD_INT 25
112224: PUSH
112225: LD_INT 3
112227: PUSH
112228: EMPTY
112229: LIST
112230: LIST
112231: PPUSH
112232: CALL_OW 72
112236: ST_TO_ADDR
// if tmp then
112237: LD_VAR 0 11
112241: IFFALSE 112280
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112243: LD_ADDR_EXP 62
112247: PUSH
112248: LD_EXP 62
112252: PPUSH
112253: LD_VAR 0 1
112257: PPUSH
112258: LD_EXP 62
112262: PUSH
112263: LD_VAR 0 1
112267: ARRAY
112268: PUSH
112269: LD_VAR 0 11
112273: UNION
112274: PPUSH
112275: CALL_OW 1
112279: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112280: LD_VAR 0 1
112284: PPUSH
112285: LD_INT 19
112287: PPUSH
112288: CALL 22083 0 2
// repeat wait ( 0 0$1 ) ;
112292: LD_INT 35
112294: PPUSH
112295: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112299: LD_EXP 50
112303: PUSH
112304: LD_VAR 0 1
112308: ARRAY
112309: NOT
112310: PUSH
112311: LD_EXP 50
112315: PUSH
112316: LD_VAR 0 1
112320: ARRAY
112321: PUSH
112322: EMPTY
112323: EQUAL
112324: OR
112325: IFFALSE 112362
// begin for i in defenders do
112327: LD_ADDR_VAR 0 4
112331: PUSH
112332: LD_VAR 0 2
112336: PUSH
112337: FOR_IN
112338: IFFALSE 112351
// ComStop ( i ) ;
112340: LD_VAR 0 4
112344: PPUSH
112345: CALL_OW 141
112349: GO 112337
112351: POP
112352: POP
// defenders := [ ] ;
112353: LD_ADDR_VAR 0 2
112357: PUSH
112358: EMPTY
112359: ST_TO_ADDR
// exit ;
112360: GO 112588
// end ; for i in defenders do
112362: LD_ADDR_VAR 0 4
112366: PUSH
112367: LD_VAR 0 2
112371: PUSH
112372: FOR_IN
112373: IFFALSE 112462
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112375: LD_VAR 0 4
112379: PPUSH
112380: LD_EXP 74
112384: PUSH
112385: LD_VAR 0 1
112389: ARRAY
112390: PPUSH
112391: CALL_OW 308
112395: NOT
112396: IFFALSE 112420
// ComMoveToArea ( i , mc_parking [ base ] ) else
112398: LD_VAR 0 4
112402: PPUSH
112403: LD_EXP 74
112407: PUSH
112408: LD_VAR 0 1
112412: ARRAY
112413: PPUSH
112414: CALL_OW 113
112418: GO 112460
// if GetControl ( i ) = control_manual then
112420: LD_VAR 0 4
112424: PPUSH
112425: CALL_OW 263
112429: PUSH
112430: LD_INT 1
112432: EQUAL
112433: IFFALSE 112460
// if IsDrivenBy ( i ) then
112435: LD_VAR 0 4
112439: PPUSH
112440: CALL_OW 311
112444: IFFALSE 112460
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112446: LD_VAR 0 4
112450: PPUSH
112451: CALL_OW 311
112455: PPUSH
112456: CALL_OW 121
// end ;
112460: GO 112372
112462: POP
112463: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112464: LD_VAR 0 2
112468: PPUSH
112469: LD_INT 95
112471: PUSH
112472: LD_EXP 74
112476: PUSH
112477: LD_VAR 0 1
112481: ARRAY
112482: PUSH
112483: EMPTY
112484: LIST
112485: LIST
112486: PPUSH
112487: CALL_OW 72
112491: PUSH
112492: LD_VAR 0 2
112496: EQUAL
112497: PUSH
112498: LD_EXP 73
112502: PUSH
112503: LD_VAR 0 1
112507: ARRAY
112508: OR
112509: PUSH
112510: LD_EXP 50
112514: PUSH
112515: LD_VAR 0 1
112519: ARRAY
112520: NOT
112521: OR
112522: IFFALSE 112292
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112524: LD_ADDR_EXP 72
112528: PUSH
112529: LD_EXP 72
112533: PPUSH
112534: LD_VAR 0 1
112538: PPUSH
112539: LD_VAR 0 2
112543: PPUSH
112544: LD_INT 21
112546: PUSH
112547: LD_INT 2
112549: PUSH
112550: EMPTY
112551: LIST
112552: LIST
112553: PPUSH
112554: CALL_OW 72
112558: PPUSH
112559: CALL_OW 1
112563: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112564: LD_VAR 0 1
112568: PPUSH
112569: LD_INT 19
112571: PPUSH
112572: CALL 22083 0 2
// MC_Reset ( base , 20 ) ;
112576: LD_VAR 0 1
112580: PPUSH
112581: LD_INT 20
112583: PPUSH
112584: CALL 22083 0 2
// end ; end_of_file
112588: LD_VAR 0 3
112592: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112593: LD_VAR 0 1
112597: PUSH
112598: LD_INT 200
112600: DOUBLE
112601: GREATEREQUAL
112602: IFFALSE 112610
112604: LD_INT 299
112606: DOUBLE
112607: LESSEQUAL
112608: IFTRUE 112612
112610: GO 112644
112612: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112613: LD_VAR 0 1
112617: PPUSH
112618: LD_VAR 0 2
112622: PPUSH
112623: LD_VAR 0 3
112627: PPUSH
112628: LD_VAR 0 4
112632: PPUSH
112633: LD_VAR 0 5
112637: PPUSH
112638: CALL 101435 0 5
112642: GO 112721
112644: LD_INT 300
112646: DOUBLE
112647: GREATEREQUAL
112648: IFFALSE 112656
112650: LD_INT 399
112652: DOUBLE
112653: LESSEQUAL
112654: IFTRUE 112658
112656: GO 112720
112658: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112659: LD_VAR 0 1
112663: PPUSH
112664: LD_VAR 0 2
112668: PPUSH
112669: LD_VAR 0 3
112673: PPUSH
112674: LD_VAR 0 4
112678: PPUSH
112679: LD_VAR 0 5
112683: PPUSH
112684: LD_VAR 0 6
112688: PPUSH
112689: LD_VAR 0 7
112693: PPUSH
112694: LD_VAR 0 8
112698: PPUSH
112699: LD_VAR 0 9
112703: PPUSH
112704: LD_VAR 0 10
112708: PPUSH
112709: LD_VAR 0 11
112713: PPUSH
112714: CALL 99323 0 11
112718: GO 112721
112720: POP
// end ;
112721: PPOPN 11
112723: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
112724: LD_VAR 0 1
112728: PPUSH
112729: LD_VAR 0 2
112733: PPUSH
112734: LD_VAR 0 3
112738: PPUSH
112739: LD_VAR 0 4
112743: PPUSH
112744: LD_VAR 0 5
112748: PPUSH
112749: CALL 101417 0 5
// end ; end_of_file
112753: PPOPN 5
112755: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
112756: LD_VAR 0 1
112760: PPUSH
112761: LD_VAR 0 2
112765: PPUSH
112766: LD_VAR 0 3
112770: PPUSH
112771: LD_VAR 0 4
112775: PPUSH
112776: LD_VAR 0 5
112780: PPUSH
112781: LD_VAR 0 6
112785: PPUSH
112786: CALL 88131 0 6
// end ;
112790: PPOPN 6
112792: END
